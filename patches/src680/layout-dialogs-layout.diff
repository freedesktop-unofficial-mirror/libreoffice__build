diff --git a/layout/.gitignore b/layout/.gitignore
new file mode 100644
index 0000000..814c9db
--- /dev/null
+++ layout/.gitignore
@@ -0,0 +1,7 @@
+unxlngi6.pro
+unxlngx6.pro
+TAGS
+tags
+*~
+*-
+*.pyc
diff --git a/layout/ChangeLog b/layout/ChangeLog
new file mode 100644
index 0000000..326cbe2
--- /dev/null
+++ layout/ChangeLog
@@ -0,0 +1,546 @@
+2007-10-24  Jan Nieuwenhuizen  <janneke@gnu.org>
+
+	* Discontinued for now.  Generate from git log.
+
+2007-10-22  Jan Nieuwenhuizen  <janneke@gnu.org>
+
+	* source/awt/vclxsplitter.hxx:
+	* source/awt/vclxtabcontrol.hxx:
+	* source/core/bin.cxx:
+	* source/core/bin.hxx:
+	* source/core/box.cxx:
+	* source/core/box.hxx:
+	* source/core/container.hxx:
+	* source/core/flow.cxx:
+	* source/core/flow.hxx:
+	* source/core/table.hxx (getHeightForWidth): Use sal_Int32 instead of
+	LONG.  Fixes compile on x86_64.
+
+	* source/awt/vclxsplitter.cxx: 
+	* source/awt/vclxscroller.cxx: 
+	* source/awt/vclxdialog.cxx: Use %d, as INT is used here,
+	not LONG.  Fixes compile warnings on x86_64.
+
+	* workben/refresh: FIXME: filter-out flood of
+
+	    class <> has virtual functions but non-virtual destructor
+
+	  for now, to make other messages visible.
+
+	* Resolve conflicts.
+
+2007-10-19  Jan Nieuwenhuizen  <janneke@gnu.org>
+
+	* workben/test.cxx (MyApp::Main): Display usage () upon -h, --help.
+
+	* workben/refresh: Append "$@" so that refresh --inst FOO works.
+
+	* README: New file.
+
+	* workben/refresh: Softcode outdir.  Fixes running on x86_64.
+
+	* workben/makefile.mk (APP1STDLIBS): Softcode layout library name.
+	Fixes linking on x86_64.
+
+	* workben/zoom.cxx: Another <c..> include.  Fixes compiling test
+	on x86_64.
+
+2007-10-18  Jan Nieuwenhuizen  <janneke@gnu.org>	 
+							 
+	* .gitignore: Ingore x86_64 output dir too.	 
+							 
+	* source/wrapper/wimpl.hxx: 			 
+	* source/core/timeout.cxx: 			 	
+	* source/core/deck.cxx: 			 
+	* source/core/byteseq.cxx: 			 
+	* source/core/bin.cxx: Add some <c..> includes.	 
+							 
+2007-10-22  Jan Nieuwenhuizen  <janneke@gnu.org>
+
+	* Remove two empty files.
+
+	* Deleted      workben/editor_pre
+	* Deleted      workben/output
+
+	* Incorporate http://www.alunos.dcc.fc.up.pt/~c0607045/trash/openoffice/layout.tgz
+
+	* Modified     source/core/box.cxx
+	* Modified     source/core/table.cxx
+	* Modified     source/wrapper/wcontainer.cxx
+	* Modified     workben/editor.cxx
+	* Modified     workben/flow.xml
+	* Added        cenarios
+	* Added        source/Documento por Gravar 1
+	* Added        source/api/com/sun/star/awt/XLayoutFlow.idl
+	* Added        source/api/com/sun/star/awt/XLayoutFlowContainer.idl
+	* Added        source/awt/non-interactable-containers.xml
+	* Added        source/awt/vclxfactory.cxx
+	* Added        source/awt/vclxfiledialog.cxx
+	* Added        source/awt/vclxfiledialog.hxx
+	* Added        source/awt/vclxline.cxx
+	* Added        source/awt/vclxline.hxx
+	* Added        source/awt/vclxpane.cxx
+	* Added        source/awt/vclxpane.hxx
+	* Added        source/awt/vclxradiobutton.cxx
+	* Added        source/awt/vclxradiobutton.hxx
+	* Added        source/gtk/vclxcommon.cxx
+	* Added        source/gtk/vclxcommon.hxx
+	* Added        source/gtk/vclxcontainer.cxx
+	* Added        source/gtk/vclxcontainer.hxx
+	* Added        source/gtk/vclxdialog.cxx
+	* Added        source/gtk/vclxdialog.hxx
+	* Added        source/gtk/vclxwidget.cxx
+	* Added        source/gtk/vclxwidget.hxx
+	* Added        workben/adjust.xml
+	* Added        workben/editor-normal.xml
+	* Added        workben/editor_pre
+	* Added        workben/flow-container.xml
+	* Added        workben/output
+	* Added        workben/test.xml
+
+2007-08-20  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/wrapper/wimpl.hxx (wrapperGone): fix ordering
+	issue.
+
+	* workben/editor.cxx (PropertiesList::destruct): bin,
+	use virtual destructors.
+
+	* source/core/visualcnt.cxx: set only size, not
+	position too.
+
+2007-08-20  Michael Meeks  <michael.meeks@novell.com>
+
+	* merge Ricardo's nice work ...
+
+2007-08-20  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/core/box.cxx (getMinimumSize): calculate size
+	correctly wrt. 2x padding.
+
+2007-08-17  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/core/helper.cxx (findAndRemove): rename
+	border -> 'has_border' to not conflict with container /
+	widget prop of same name.
+
+	* workben/*.xml: rename all border attributes. 
+
+	* source/core/box.hxx: bin bogus mnBorderWidth - use
+	the container instead.
+
+	* source/core/helper.cxx: rename 'border' to 
+	'has_border' so container borders work.
+	(anyFromString): fix type of LONG, add unsigned types &
+	re-order into TypeClass.idl sequence.
+
+	* source/awt/vclxbutton.cxx (IconButton): center
+	labels, somehow setting a graphic changes the behavior
+	of widgets with no align set.
+
+2007-08-16  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/wrapper/wcontainer.cxx (Clear): get condition
+	right.
+
+	* source/core/container.cxx (setParent): cope with null
+	parents by not throwing.
+
+	* workben/editor.cxx: add Alignment ... and adapt to new
+	property code - so we get container properties.
+
+	* source/core/helper.cxx (setProperties): adapt to new
+	layoutimpl::prophlp helpers.
+	(canHandleProps, queryPropertyInfo, setProperty, getProperty):
+	impl.
+
+2007-08-16  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/core/*.cxx: calm down debug.
+
+	* source/core/align.cxx, box.cxx: add PROPHELPER_SET_INFO
+	to the child props too ... (doh).
+
+	* source/core/helper.hxx (PROPHELPER_SET_INFO): impl. this
+	as a macro, comment it heavily.
+	* source/core/container.hxx, box.hxx, align.hxx, bin.hxx: add
+	the macro back cf. 2007-06-07 ...
+
+	* source/core/import.cxx, source/wrapper/wimpl.hxx: calm the
+	churning debug problem down: finally can see the important
+	messages.
+
+	* workben/editor.cxx (EditorDialog): add 'maDelete' member &
+	rename 'engine->mpEngine'
+
+	* source/awt/vclxbutton.cxx (IconButton, VCLXCancelButton),
+	(VCLXHelpButton): impl.
+
+	* source/core/import.cxx (handleCornerCases): bin.
+
+2007-08-16  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/awt/vclxproxy.cxx (queryInterface): fixup.
+
+	* source/awt/vclxbutton.cxx: impl OKButton stub.
+
+	* source/awt/vclxproxy.cxx: gut-wrenching manual cut/paste
+	proxy creation: urgh.
+
+	* source/core/import.cxx (handleCornerCases): bin okbutton
+	corner case.
+
+2007-08-15  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/core/helper.cxx (setProperties): add debug for
+	dropped properties.
+
+	* source/core/container.cxx (queryInterface, acquire,
+	release): unwind nightmarish UNO lifecycle evil: not
+	implementing acquire/release is a spectacularly bad
+	idea: trashed memory gets accessed by the next queryinterface.
+
+2007-08-15  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/wrapper/wrapper.cxx (GetPeer): bin debug.
+	(Clear): impl. for Ricardo.
+
+	* workben/editor.cxx (naturalSize): impl. and call post
+	construction, so we size to the total size with the added
+	widgets.
+
+	* source/core/root.hxx: remember to declare we impl.
+	XLayoutConstrains.
+
+	* workben/editor.cxx (getDepth, makeListEntryName): impl.
+	& cleanup code.
+
+	* workben/editor.hxx (class EditorEngine): bin maIdentList.
+
+2007-08-15  Michael Meeks  <michael.meeks@novell.com>
+
+	* workben/editor.cxx (PropertyEntry): show the
+	widgets post construction: now appears to work
+	as nicely, if not better than before.
+
+	* source/wrapper/wcontainer.cxx (Container): add
+	warning if no peer to associate with is found.
+	(Container): actually assign mxContainer.
+
+	* source/wrapper/wbutton.cxx (SetImageAlign): impl.
+	SetImageAlign, and use it to align-left the images.
+
+	* workben/test.cxx (InitUCB): enable this.
+	(Main): set more magic environment variables: 'magic'!
+
+2007-08-14  Michael Meeks  <michael.meeks@novell.com>
+
+	* workben/test.cxx: attempt to defeat stupid configmgr
+	bootstrapping evilness.
+
+	* workben/test.cxx (UnoBootstrapSucks): log component
+	instantiations, and exception text - caught config mgr.
+	not being happy.
+
+	* source/inc/layoutcore.hxx: impl. - a header for
+	sharing code from core -> wrapper.
+
+	* source/wrapper/wbutton.cxx (ImageImpl): impl.
+	and add SetImageMode method.
+
+	* source/core/helper.cxx (loadGraphic): impl.
+
+	* inc/layout/layout.hxx: add lstbox.h for
+	LISTBOX_ENTRY_NOT_FOUND & fix editor with this.
+
+	* source/core/helper.cxx (createWidget): merge
+	conflicts.
+
+2007-08-09  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/awt/vclxtabcontrol.?xx, source/awt/makefile.mk,
+	* utils/makefile.mk: import TabControl.
+
+	* source/core/*.cxx: put in 'layoutimpl' namespace.
+
+	* source/core/import.cxx (WidgetElement): handle
+	corner cases again.
+
+2007-08-09  Michael Meeks  <michael.meeks@novell.com>
+
+	* doc/stats.ods: statistics on widget impl. & attribute
+	priorities.
+
+	* source/core/helper.cxx (createWidget): re-enable
+	handleCornerCases.
+
+	* source/core/import.cxx (handleCornerCases):
+	un-comment handle-corner-cases.
+
+2007-08-09  Ricardo Cruz  <rpmcruz@alunos.dcc.fc.up.pt>
+
+	* latest work.
+
+2007-07-30  Michael Meeks  <michael.meeks@novell.com>
+
+	* doc/vcl.txt: add notes on how fallback awt peer
+	creation happens.
+
+	* doc/awt-props.ods: try to bring some sanity to the
+	cut/paste frenzy in the awt properties.
+
+	* source/core/import.cxx (ToplevelElement): switch back
+	to the new pseudo-'root' 'XLayoutContainer' approach that
+	is cleaner & simpler.
+
+2007-07-30  Michael Meeks  <michael.meeks@novell.com>
+
+	* workben/editor.cxx (createWidget): fix variable naming
+	_name -> pName; fix createContainer call signature.
+
+	* source/core/deck.cxx (setVisible): switch to queueRecalc.
+
+	* source/core/root.cxx (getChildren, removeChild): impl.
+
+	* source/core/container.cxx (getSingleChild): impl.
+	helper & upd. callers.
+
+	* Resolve conflicts with Ricardo.
+
+2007-07-26  Ricardo Cruz  <rpmcruz@alunos.dcc.fc.up.pt>
+
+	* Added SVLXTabControl that offers XWindow and XLayoutContainer
+	interfaces for the VCL TabControl.
+	But its allocateSize() isn't being called (though sometimes it
+	is), so multi tabs are broken.
+    
+	* Touched a bit XLayoutContainer interface: added getChildren()
+	and removeChildren(). And got rid of clearChildren().
+	SPECIFICATION: setParent() must be called on child when added
+	or removed to a container -- in case child implements XChild
+	-- pass null to remove.
+    
+2007-07-25  Michael Meeks  <michael.meeks@novell.com>
+
+	* notes.txt, doc/metricfield.txt, doc/oldnotes.txt:
+	move some of my cruft out of notes.txt
+
+	* source/core/root.cxx: made LayoutRoot implement
+	XLayoutConstrains and XLayoutContainer (a simple bin).
+
+	* source/core/timeout.cxx: do idle sizing via the
+	toplevel.
+
+	* source/core/import.cxx (~ToplevelElement): simplify
+	toplevel sizing. Tie LayoutRoot to the toplevel window:
+	ok for now.
+
+2007-07-25  Michael Meeks  <michael.meeks@novell.com>
+
+	* workben/zoom.xml: update variously.
+
+	* source/core/timeout.cxx: add evil hack using VCL
+	idle handler to layout idly (not that we do re-layout
+	yet).
+
+	* source/core/container.cxx (allocateChildAt): calm
+	down debug spew.
+
+	* source/wrapper: move fields pieces from wrapper.cxx
+	to 'wfields.cxx'.
+
+	* NB. The code now depends on recent toolkit/ changes in
+	HEAD ooo-build.
+
+2007-07-13  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/wrapper/*.cxx: propagate a Context* pointer
+	through to all wrapper instances; ready to implement
+	OKButton / CancelButton etc.
+
+	* source/wrapper/wbutton.cxx: split from
+	* source/wrapper/wrapper.cxx: here.
+
+	* source/core/import.cxx (handleCornerCases): impl.
+	and call - the ok/help/cancel buttons are -so- lame in
+	awt, we need to emulate them in the wrapper.
+
+2007-07-12  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/wrapper/wrapper.cxx (GetPeerHandle): switch
+	to just 1 impl, with an optional nId argument too,
+	in case we need it.
+	
+	* inc/layout/layout.hxx, source/wrapper/impl.hxx,
+	* source/wrapper/wrap_container.cxx,
+	* source/wrapper/wrapper.cxx: impl. new 'Box'
+	container type, also allow explicit widget
+	instantiation.
+
+	* workben/editor.cxx: re-work to use a sequence of
+	PushButtons instead of create<N> thing.
+
+2007-07-06  Ricardo Cruz  <rpmcruz@alunos.dcc.fc.up.pt>
+
+	* a bunch of stuff touched (in special workben/editor.hxx and cxx):
+	Sorry, will try to take better care of the ChangeLog in
+	the future...
+
+    Made a first layout editor. Added temporary calls recalc()
+    and clearChildren() to the XLayoutContainer interface. :P
+    Quite hacky overall; but its already more functional than
+    was targetting for the milestone, and will be cleaning it up...
+    
+    Committed part of koehin's patch: the ListBox wrapper.
+
+2007-06-22  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/wrapper/wrapper.cxx: impl. NumericFormatter -
+	we still need MetricField to implement a (mis-named)
+	XCurrencyField interface though ...
+
+2007-06-22  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/wrapper/wrapper.cxx (WindowImpl): add
+	get/setProperty helpers.
+	(PushButton::[Is]Check[ed]): impl.
+
+	* source/core/*: some debug calming action.
+
+	* source/wrapper/wrapper.cxx (::Dialog): get toplevel
+	widget correctly.
+	(GetPeerHandle): calm debug.
+
+2007-06-21  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/wrapper/wrapper.cxx (Dialog::SetText),
+
+	* source/core/import.cxx (startRootElement): check
+	the namespace & allow non-framewindow toplevels.
+	(WidgetElement): !pParent -> WindowClass_TOP.
+
+	* workben/zoom.xml: add 'group' attributes, hmm. Not
+	working that well for some reaosn.
+
+	* source/wrapper/wrapper.cxx (ButtonImpl::SetClickHdl)
+	don't add the action listener until we need to to preserve
+	VCL's semantics.
+
+2007-06-20  Ricardo Cruz   <rpmcruz@alunos.dcc.fc.up.pt>
+
+	* source/core/import.h/cxx: added support for radio groups.
+	As agreed, a group is specified by an id. So, the xml
+	would be:  <radio group="pizza" value="margarita" /> ...
+
+2007-06-20  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/core/import.cxx (WidgetElement): filter out 'id'
+	property and add into mrRoot.
+
+	* source/core/helper.cxx (setProperties): remove 'id' bits.
+
+2007-06-20  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/core/byteseq.cxx: add - gross hack, to go later.
+	* source/core/root.cxx: upd. to use it.
+
+	* workben/test.cxx: move much of the file reading /
+	stream handling evil into the core & initialize via UNO.
+
+	* workben/*: remove LAYOUT_API_TEST conditionals ...
+
+2007-06-20  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/core/root.[ch]xx: start of XLayoutRoot impl.
+	
+	* source/core/factory.cxx: UNO component registration fun.
+
+	* workben/test.cxx: turn off zoomy bits if
+	LAYOUT_API_TEST is not set.
+
+	* source/wrapper/wrapper.cxx: impl. first cut at
+	wrapping logic; get a few things in order.
+
+2007-06-19  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/*: move to source/core/*
+
+	* source/wrapper: add.
+
+	* prj/build.lst: upd.
+
+2007-06-19  Michael Meeks  <michael.meeks@novell.com>
+
+	* workben/zoom.[ch]xx: import cut/paste of
+	svx/source/dialog/zoom.[ch]xx - hack out svx dependencies
+	and port to:
+
+	* inc/layout/layout.hxx: new 'layout' wrapper API
+
+2007-06-08  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/helper.hxx: move ChildProps
+	* source/helper.hxx: to here, rename to PropHelper,
+	add include guards etc.
+
+	* source/import.?xx: substantial clean up.
+	
+	* workben/*.xml: switch namespace
+
+2007-06-07  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/container.cxx: remove static singleton setting
+	'getPropertSetInfo' method, and make it abstract.
+	* source/bin.cxx, source/box.cxx: implement here, so we
+	get different SetInfo for each.
+
+	* source/vbox.cxx (convertFastPropertyValue): impl. properly.
+
+	* source/import.cxx (ChildElement::startChildElement): pass
+	the right child attributes.
+	(addChildWidget): actually set properties on the container's
+	child not the widget itself.
+
+2007-06-06  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/makefile.mk,
+	* source/import.cxx: rename from newimport.cxx
+
+	* source/newimport.cxx (getPropAsInt): bin, obsolete.
+	(addChildWidget): add setProperties call for child props.
+	(windowResized): do size request before allocate.
+
+2007-06-06  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/newimport.cxx (getAttributeProps): re-factor & split.
+	(findAndRemove): this.
+
+	* source/helper.cxx (setProperties, toUnoNaming, anyFromString): 
+	split from newimport.cxx.
+
+	* source/newimport.cxx (~ToplevelElement): add, so we
+	show the dialog post sizing.
+
+	* workben/*.xml: remove 'show' attribute on toplevels.
+
+2007-06-06  Michael Meeks  <michael.meeks@novell.com>
+
+	* source/newimport.cxx: add hacks (missing Ricardo's
+	hierarchy parsing), to whack all children in 1 hbox.
+	We have layout at last.
+
+	* source/vbox.cxx (allocateChildAt): get PosSize flags right.
+
+	* source/newimport.cxx (startRootElement): upd.
+	(ResizeListener): impl.
+
+	* source/newimport.hxx (class ToplevelElement): add.
+
+2007-06-05  Michael Meeks  <michael.meeks@novell.com>
+
+	* workben/layout.xml: add nested vbox.
+	
+	* workben/layout-flat.xml: flat xml
+	
+	* start a ChangeLog
+
diff --git a/layout/README b/layout/README
new file mode 100644
index 0000000..f52c1b9
--- /dev/null
+++ layout/README
@@ -0,0 +1,35 @@
+Experimental Layout module for OOo-build
+
+http://lilypond.org/~janneke/vc/layout.git/.git
+
+* Checkout alongside the other modules over your go-oo copy, under
+  build/oog680-m5 [1].  You won't have this directory until you firstly
+  compile go-oo, as it will extract Sun's OpenOffice, apply a few
+  patches and wrap it up in the build system.  Do something like
+
+    . ~/vc/ooo-build/build/oog680-m239/Linux*sh
+    cd $SRC_ROOT
+    git clone http://lilypond.org/~janneke/vc/layout.git/.git
+
+* Point /usr/local/lib/ooo to your ooo installation.
+
+   sudo ln -s ~/pkg/ooo /usr/local/lib/ooo 
+
+* Source refresh in workben, do something like
+
+    cd workben && . ./refresh [--inst OOO_INSTALL_PREFIX]
+
+[1] this name changes from oobuild to oobuild version as it targets
+different upstream states I guess...
+
+Integration into OOo:
+
+* in ~/vc/ooo-build, run ooinstall, I do
+
+   14:49:25 janneke@peder:~/vc/ooo-build
+   $ ooinstall -l ~/pkg/ooo
+
+* run it:
+
+   cd ~/pkg/ooo
+   ./soffice.bin
diff --git a/layout/TODO b/layout/TODO
new file mode 100644
index 0000000..ca102f0
--- /dev/null
+++ layout/TODO
@@ -0,0 +1,140 @@
+-*-outline-*-
+
+* code
+** features
+*** localization
+*** support cnt:cnt:? 
+*** icons from Jakub included
+*** support using label (verb) on yes/ok no/cancel buttons for some platforms
+but keep using yes/no on Windows, eg
+*** remove -DTEST_LAYOUT=1 from util/makefile.mk
+
+** fixes
+*** mpRadioGroup HACK --> use radiogroup property
+*** toolkit/source/awt/vclxwindow.cxx
+   empty-out VCLXWindow::getMinimumSize
+*** missing properties
+	'title' -> 'Set Zoom'
+Missing prop Title
+Missing prop ValueStep
+Missing prop Radiogroup
+Missing prop Default
+*** bug in wordcountdialog: right alignment of numbers `jump' when resizing
+       the dialog.  the 0 and 00 are never exactly aligned.
+*** look into code duplication: source/core/*.
+*** Remove magic constants
+fHorAlign = fVerAlign = 0.5; --> float const [CENTER?] = 0.5;
+
+*** remove stuff?
+helper.cxx:
+/*
+ * -------------------------- cut and paste from vclxtoolkit --------------------------
+ * to reduce dependencies ... axe on merge ...
+ */
+
+byteseq.cxx:
+// This is - unbelievably ugly - but then getting the UCB to work is worse.
+// cut/paste from xmlscript/source/xml_helper/xml_byteseq.cxx
+
+*** box.hxx: use vbox/hbox polymorphism instead of if (mbHorizontal)
+
+* integration
+
+* distributing: [LayoutDialogs]
+git diff 5db78fc5 layout scp2 > layout-dialogs-layout.diff
+git diff 5db78fc5 |grep -v gitignore | grep 'git a'|grep -Ev 'a/(layout|scp2)/'|sed -e's@.*git a/@@' -e 's@/.*@@' | sort -u | tr '\n' ' '
+git diff 5db78fc5 $(git diff 5db78fc5 |grep -v gitignore | grep 'git a'| grep -Ev 'a/(layout|scp2)/' | sed -e's@.*git a/@@' -e 's@/.*@@' | sort -u | tr '\n' ' ') > layout-dialogs.diff
+
+Soo...
+
+m237: fc105178
+
+#git diff  offapi toolkit > layout-dialogs-offapi-toolkit.diff
+
+git diff fc105178 layout | sed 's@^\([+-]\{3\}\) \(a\|b\)/@\1 @' > layout-dialogs-layout.diff
+git diff fc105178 config_office scp2 | sed 's@^\([+-]\{3\}\) \(a\|b\)/@\1 @' > layout-dialogs-config_office-scp2.diff
+git diff fc105178 svx sw | sed 's@^\([+-]\{3\}\) \(a\|b\)/@\1 @' > layout-dialogs-svx-sw.diff
+
+m241: 5e9b2546
+m241': b8e24264
+m241'': 53ddc663
+m1: fbde8234
+m1': d1f42c99
+
+* porting
+** Zoom dialog
+*** list of radio buttons indented: workben/zoom-indent.xml ?
+** Word Count dialog
+** 'Format' dialog
+TODO
+
+
+* play with / improve Ricardo's editor
+** broken after new uno registration
+	+ this is not meant to be a production level tool, but still,
+	  it can be improved I think :-)
+
+* improve Kohei's converter (poke him on IRC (afternoons) about this)
+
+** current hack: workben/run-s2x
+
+   . Imported into layout
+
+	+ Kohei wrote the start of a nice script to convert ugly,
+	  obsolete resource files to nice new XML files ;-)
+		+ unfortunately it is buggy.
+		+ see ooo-build/scratch/layout-src2xml/*
+		+ we should move this into the git repo.
+	+ bug to fix: case problems in XML
+		+ XML produced has wrong case items, and names are
+		  different to those we (and AWT) expects ->
+		  de-stdlycapsise
+		+ cf. layout/source/core/helper.cxx:
+			toUnoNaming, anyFromString
+			setProperties
+			+ NB. we want to have nice 'clean' looking non-stdlycaps XML
+		+ also toolkit/source/awt/vclxwindows.cxx /ImplGetPropertyIds/
+		+ also toolkit/source/helper/property.cxx
+	+ bug to fix: property name problems
+		+ often the resource name strings (cf. legacy resource
+		  compiler in rsc/) don't match the awt toolkit properties
+		+ ie. need to map Label="foo" to Text="foo" (or whatever).
+
+* OLD notes
+
++ Before OOoCon
+    + editor polish
+	+ cut / paste
+	+ export xml
+	+ "import .src"
+	[ use native VCL menus ... ]
+    + dialogs:
+	+ porting 'Format' dialog.
+	+ wrapper code - improving ...
+    + XML fixes
+	+ "load" command for shared fragments
+    + slides:
+	+ UNO object hierarchy for a given window ...
+
++ Later
+    + dual-compile code under VCL & 'layout' and compare
+      event ordering (eg.).
+	+ test-tool
+    + scrolled-pane impl.
+
+
+* i18n
+    + forget java property files nonsense
+	- dump old wiki pointers into layout/doc for reference
+    + hit on transex3
+	+ new tool 'slayex3' (or equiv. incomprehensible name to suit ;-)
+	+ 2 roles:
+	    + read XML dump to SDF [ AFAIR we can merge these ]
+	    + read XML file and SDF, dump <N> translated XML files
+	    + suitably named:
+    + in layout/ read right translation:
+	+ cf. vcl/source/gdi/impimagetree.cxx
+	    + does this for 'images.zip' case.
+	+ [ also does .zip load bits: if we impl. this we should
+	    have a simple file fallback first for now I think ]
+
diff --git a/layout/doc/apinotes.txt b/layout/doc/apinotes.txt
new file mode 100644
index 0000000..dc5a8cf
--- /dev/null
+++ layout/doc/apinotes.txt
@@ -0,0 +1,76 @@
+Notes on API wrapper pieces ...
+
+SvxZoomDialog::SvxZoomDialog( Window* pParent, const SfxItemSet& rCoreSet ) :
+	Dialog( pParent, SVX_RES( RID_SVXDLG_ZOOM ) ),
+
+What do we do ?
+	+ lots of potential VCL/Svx/Sfx etc. top-levels ...
+
+	+ Create the window & the 1st member: 'FooHandle' ?
+	    + Multiply inherited ?
+	+ object from where ?
+
+	+ Default:
+	    + a pseudo-Dialog / wrapper ...
+	    + load using layout (etc.)
+		+ register an SID table ?
+		    + necessary ?
+		+ SIDs ? - post it ...
+
+
+	+ [ Otherwise ... hook up via a helper /
+	    constructor member ... ]
+
+* Fixed:
+    + OKButton / CancelButton
+	+ don't chain to PushButton::Click
+	    + if there is no ClickHdl set ... [ !urgh! ...]
+
+    * FIXME:
+	other widgets ...
+	* How do we cope ? *
+	....
+	    + priorities ? Layout ?
+	    + de-coupling ?
+	    + native widgets ?
+	    + hmm...
+	+ custom widgets ?
+	    + 'OKButton' ... (?) :-)
+	    + 'CancelButton'
+	    + 'HelpButton' ...
+	+ a VCL hack ...
+	    + create an 'addLayout()' method ?
+	    + [ like cl's ? ]
+	+ implement this ...
+
+** Lifecycle ?
+    + how do we track the 'Impl'
+      vs. the pImpl vs. (etc.)
+	+ held by mutual references ?
+
+    + pointer to the widget itself passed in ? 
+	+ MI ?
+    + when the widget dies - just NULL the
+      listener's back-ptr ?
+
+    + Locking [!?] - how / why / what / who ?
+	+ urgh ...
+	+ threading bits ...
+
+    + SID table (?) ...
+	+ [ necessary ? - just use the SID name as the XML attr ? ]
+	+ LAYOUT_ID(a) -> "#a" - stringified ...
+
+** FIXME:
+    + we need a decent MetricField implementation
+	+ it is more than a SpinField
+	+ need to move the 'Border' property down (etc.)
+	+ re-arrange the properties to be next to the impls.
+	  in awt ...
+
+    + fix the 
+
+XCurrencyField (huh)
+    needs implementing for VCLXMetricField (non-existent) ...
+    copy the code from XCurrencyField ? make a sub-class there ?
+
diff --git a/layout/doc/awt-props.ods b/layout/doc/awt-props.ods
new file mode 100644
index 0000000..ec1dc52
Binary files /dev/null and b/layout/doc/awt-props.ods differ
diff --git a/layout/doc/metricfield.txt b/layout/doc/metricfield.txt
new file mode 100644
index 0000000..21ebe4b
--- /dev/null
+++ layout/doc/metricfield.txt
@@ -0,0 +1,57 @@
+** MetricField:
+    + in vcl: 
+class VCL_DLLPUBLIC CurrencyField : public SpinField, public CurrencyFormatter
+class VCL_DLLPUBLIC CurrencyFormatter : public NumericFormatter
+class VCL_DLLPUBLIC MetricFormatter : public NumericFormatter
+class VCL_DLLPUBLIC NumericFormatter : public FormatterBase
+
+MetricFormatter - very simple sal_Int64 wrapping ...
+    + no doubles ...
+    + *Could* replicate this with the same interface:
+	+ prolly easier / better to add an XMetricField interface.
+
+vcl's MetricField - itself does a load of (double) casting ...
+    + to get the value it wants :-)
+    + Urgh ! ...
+
+** Can we just twist VCLXCurrencyField to this purpose ?
+    + what differences would we want ?
+    + LongCurrencyFormatter -> 'MetricFormatter' ...
+
+** Interesting !
+    + VCLXCurrencyField is based on 'LongCurrencyField' not CurrencyField ...
+	+ this is really based on 'BigInt' [ curious ] - so even more precision loss.
+
+    + So ... cut/paste VCLXCurencyField -> VCLXMetricField 
+
+	    + Look at 'VCLXNumericField' interface ...
+		+ Use 'XNumericField' instead (?)
+		    + why does this just not "just work" ?
+
+    + The 'MetricField' (is also a MetricFormatter)
+	+ MetricFormatter [ unusually ] has 'Unit' support
+	    + API grep shows:
+		+ a) requires 'fieldunit'
+		+ b) has "UserValue"
+		+ c) => new IDL interface required ...
+		+ sub-set / expand NumericField ?
+
+	    + add 'CustomConvert' ?
+	    + add '[SG]etFirst'/Last
+	    + Properties:
+	        + 'Unit' 
+		+ 'CustomUnitText'
+	    + 'spin-size' -> 'value-step'
+	    + 'BaseValue' ...
+	    + sal_Int64 ... [!?] ...
+	    + CorrectedValue
+	    + Want properties for the UI designer (?)
+		+ move that stuff out into there ?
+    + FIXME:
+	+ rationalise the 'Modify' event crud ...
+	    + share the code in a base-class ...
+
+    + Wrapper:
+        + need to have static methods 'ConvertDoubleValue' etc.
+	+ also 'ConvertValue' etc.
+	+ GetCorrectedValue - never used ...
diff --git a/layout/doc/notes.txt b/layout/doc/notes.txt
new file mode 100644
index 0000000..63bb164
--- /dev/null
+++ layout/doc/notes.txt
@@ -0,0 +1,117 @@
+--- How layout / hierarchy should work ---
+
+On-screen:
+
++-------------------+
+| Label:   [Entry]  |
+| - - - - - - - - - |                  |
+|             [ Ok ]|
++-------------------+
+
+AWT Window hierarcy:
+	Window
+		+ Label
+		+ Entry
+		+ Ok
+
+	ie. unchanged, and backwards compatible - a flat
+representation.
+
+Toolkit Hierachy
+
+	WindowContainer [Bin?]
+		+ Vbox
+			+ HBox
+				+ Label
+				+ Entry
+		+ Alignment
+			+ Ok
+
+	the layout process would happen inside the toolkit code
+(perhaps eventually genericisd itself), and the result from the
+(re-)layout process would be a set of SetPosition/SetSize calls made
+to VCL.
+
+--- code pointers ---
+
+** AWT interfaces:
+    + offapi/com/sun/star/awt/* - eg. XButton.idl
+	+ 'XLayoutConstrains.idl' [ published & mis-named ! ]
+
+    + We can build 'Layout' into the AWT at the toolkit level
+	+ this should be fairly easy, and wouldn't touch VCL much.
+
+** Toolkit (awt) implementation:
+    + toolkit/source/awt/vclxwindows.cxx:
+	+ much of the implementation lurks in here ...
+    + The size information is in 'vclxwindows.cxx' ...
+
+    + toolkit/source/helper/unowrapper.cxx
+	+ factories / code to associate UNO peers with VCL windows
+	+ pWindow->
+
+--- Tests ---
+
+Integration tests:
+    cf. http://www.openoffice.org/issues/show_bug.cgi?id=78747
+
+
+--- more thoughts ---
+
+** Extra Design constraints: [!?]
+	+ accessibility
+	+ QA test-tool-age ... - tests ~will need re-write (unfortunately)
+
+* New functionality we would like:
+	+ ShowAll (vs. Show/Hide) && HideAll ...
+
+Necessary to re- build && deliver svtools/ having delivered toolkit ...
+    rm unxlngi6.pro/slo/textwindowaccessibility.* # first ...
+
+** Layout containers:
+    + XIndexAccess ? - sorted container (?)
+
+* Consider 'XLayoutRoot' top-level ...
+    + inherit from XNameContainer - widgets by name / id ...
+    + hack a VCL dialog ?
+	+ we need a handle we can pass back of some form:
+	+ XWindowPeer getPeer() ... [ can use that I guess ? ]
+    + also need a service interface ?
+	+ or parameters passed as Anys ? [ugh]
+
+* Decided
+    + use 'layout' by itself & small patches
+      to toolkit/ in ooo-build.
+
+* TODO:
+    + need a 'queueResize' method ...
+	+ trigger on show/hide ...
+    + allocateSize should take an awt::Rectangle ...
+    + impl. XLayoutRoot
+    + special cases:
+        + radio-button-group
+	+ notebook
+
+* svx/source/dialog/zoom*
+
+Michael's Todo:
+    + handle MetricField: 'unit' enum etc. - introspection ? or ...
+    + make OK/Cancel buttons function as they should ...
+    + merge layout-svtools.diff into CWS as last step before inclusion ...
+    + FixedLine:
+	+ get sizing right ...
+	+ hook up new virtual methods into toolkit/ (m225) - i#80754
+	+ copy the crud from toolkit's custom vclxwindows.cxx
+	  "calcMinimumSize" logic ...
+    + get ok/help/cancel buttons working ...
+
+    + fix / rationalise property adding in toolkit ...
+	+ simplify it with the new VCLWindow base :-)
+	+ simplify it ...
+	    + spreadsheet ...
+	+ VCLXImageConsumer - can't be instantiated itself
+             anyway ! -> bin the 'true' & just add all these
+	     props unconditionally ...	
+
+    + switch construction attributes into their own xmlns to
+      avoid treading on other properties ...
diff --git a/layout/doc/oldnotes.txt b/layout/doc/oldnotes.txt
new file mode 100644
index 0000000..a5cb949
--- /dev/null
+++ layout/doc/oldnotes.txt
@@ -0,0 +1,224 @@
+* Obsolete notes ...
+
+** Form XML format:
+
+    + from the basic editor:
+
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE dlg:window PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "dialog.dtd">
+<dlg:window xmlns:dlg="http://openoffice.org/2000/dialog" xmlns:script="http://openoffice.org/2000/script" dlg:id="Dialog1" dlg:left="204" dlg:top="148" dlg:width="136" dlg:height="115" dlg:closeable="true" dlg:moveable="true">
+  <dlg:bulletinboard>
+    <dlg:button dlg:id="OkButtonName" dlg:tab-index="0" dlg:left="86" dlg:top="92" dlg:width="44" dlg:height="19" dlg:value="OkButtonLabel"/>
+    <dlg:titledbox dlg:id="FrameControl1" dlg:tab-index="1" dlg:left="4" dlg:top="7" dlg:width="68" dlg:height="41">
+      <dlg:title dlg:value="FrameControl1"/>
+    </dlg:titledbox>
+    <dlg:scrollbar dlg:id="ScrollBar1" dlg:tab-index="2" dlg:left="82" dlg:top="10" dlg:width="45" dlg:height="24"/>
+    <dlg:scrollbar dlg:id="ScrollBar2" dlg:tab-index="3" dlg:left="107" dlg:top="43" dlg:width="21" dlg:height="37" dlg:align="vertical"/>
+    <dlg:timefield dlg:id="TimeField1" dlg:tab-index="4" dlg:left="4" dlg:top="92" dlg:width="28" dlg:height="19"/>
+    <dlg:text dlg:id="Label1" dlg:tab-index="5" dlg:left="22" dlg:top="61" dlg:width="44" dlg:height="15" dlg:value="Label1"/>
+  </dlg:bulletinboard>
+</dlg:window>
+
+    + code to read this & generate UIs is in:
+	+ DTD: xmlscript/dtd/dialog.dtd
+	+ xmlscript/source/xmldlg_imexp/imp_share.hxx, line 674
+	+ xmlscript/source/misc/unoservices.cxx
+		xmlscript/source/xmlflat_imexp/xmlbas_import.cxx (?)
+		"com.sun.star.comp.xmlscript.XMLBasicImporter"
+	+ the dialog piece seems separate ?
+		"importDialogModel" ...
+	+ cf. the interesting test code ...
+	+ cd xmlscript/test
+	  dmake
+	  ../unxlngi6.pro/bin/imexp /opt/OOInstall ./test.xml
+	    + generates & renders a dialog ...
+
+	+ This code has ~all we need to get a simple impl.
+	    + compatibility wrappers [!]
+
+    // first create model:
+    Reference< container::XNameContainer > xModel( xContext->getServiceManager()->createInstanceWithContext(
+	OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.awt.UnoControlDialogModel" ) ), xContext ), UNO_QUERY );
+    // NB. xmldlg_addfunc.cxx not xmldlg_import.cxx [!?] ;-)
+    ::xmlscript::importDialogModel( ::xmlscript::createInputStream( bytes ),
+				    xModel, xContext );
+
+    // second create view of model:
+    Reference< awt::XControl > xDlg( xMSF->createInstance(
+	OUString(RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.awt.UnoControlDialog" ) ) ), UNO_QUERY );
+    xDlg->setModel( Reference< awt::XControlModel >::query( xModel ) );
+
+    // third - associate toolkit / peer ...
+    Reference< awt::XToolkit> xToolkit( xMSF->createInstance(
+	OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.awt.ExtToolkit" ) ) ), UNO_QUERY );
+    xDlg->createPeer( xToolkit, 0 );
+
+    // fourth - execute [ nasty ... ]
+    Reference< awt::XDialog > xD( xDlg, UNO_QUERY );
+    xD->execute();
+
+
+** Basic dialog editor:
+
+    + basctl/source/dlged/dlged.cxx
+	+ dialog editor (?)
+    + basctl/source/basicide/basobj3.cxx
+    + basctl/source/basicide/basides3.cxx
+	+ BasicIDEShell:CreateDlgWin ...
+
+
+** FIXME:
+	+ createPeer - when called is always passed
+	  the toplevel [ it seems ... ]
+	+ we need to pass a container instead ...
+		+ or have some separate hint / method ?
+		+ or call the 'setChild' inside the model
+		  construction bits ? [!?]
+
+UnoControlContainer::addingControl:
+	+ only caller to 'setContext'
+		+ sets the 'Parent' for peers ...
+
+Dialog is an UnoControlContainer ...
+	+ hmm ...
+	+ 'XControlContainer'
+		+ perhaps just what we need ... [!]
+	+ our VBox should be one ...
+
+	+ Other things: tab widgets are 'UnoControlContainers' ...
+		+ finally remembered: xml foo ...
+		+ 
+
+
+	+ FIXME: it -seems- that we don't store
+		 much hierarchy in the model [ any ? ]
+		+ UnoControlModel -> ?
+
+	+ UnoControlDialogModel - has an XNameContainer ...
+		+ but ... only the UnoControl-Dialog-Model has this ...
+
+
+	+ Wow - even the percieved hierarchy:
+		+ 'exportDialogModel'
+			+ achieved by 'getElementNames'
+				-> flat set of names ... [urgh]
+
+	+ So - we need to add more structure:
+		+ XNameContainers ...
+			+ that we insert into [!?]
+		+ we also need to retain order for packing.
+
+	+ need a list of sillies to reverse / revert (?) ...
+
+	+ back-compat:
+		+ kill bogus nesting eg. radiogroup ...
+			[ have a group/tag instead - or hierarchical names ? ]
+		+ ditto for 'titledbox' ...
+		+ menulists - seem rather unrelated / bogus anyway.
+		+ Add into toplevel & child ...
+
+    + copy Dialog bits into unocontrolcontainer.cxx ...
+	+ re-using unocontrolcontainer ...
+
+
+** FIXME:
+    + we need property introspection on the awt widgets:
+	+ but they have no property interfaces [!] -
+	    interestingly the UnoControl's don't either
+	    only the UnoControlModel foo ...
+	+ unocontrols.cxx:
+	    Uno
+    + source/helper/property.cxx
+	+ has all the type information ...
+	+ but no information on what properties are
+	  valid for a type ... - implicit in the UnoControlModel's
+	  code ...
+	    + ImplGetPropertyInfos ...
+
+    + add to vclxwindow.cxx:
+	+ inc/toolkit/helper/property.hxx
+	+ 'getProperties' static ...
+
+** It seems that things like UnoControlComboBoxModel are missing
+   some derived properties: EchoChar (etc.)
+    UnoControlDateFieldModel - missing ... EchoChar too (?) - deliberate ?
+    + query these ... [!?]
+
+layout container - start child 'combobox'
+   missing property 46 (EchoChar)
+   missing property 48 (HardLineBreaks)
+   missing property 12 (HScroll)
+   missing property 104 (LineEndFormat)
+   missing property 10 (MultiLine)
+   missing property 13 (VScroll)
+
+    + add regression test:
+	+ count number of properties ...
+
+
+TODO:
+	add 'XPropertySetInfo' to VCLXWindow:
+	    + trivial to implement :-)
+	    + hook it to Ricardo's parser ... [!] :-)
+
+* xmlscript
+	+ xmldlg_import.cxx - 
+	+ xml_helper/xml_impctx.cxx - foo ...
+
+
+* plan:
+	+ hard-code container hooks into the xmlscript/ parser ...
+	+ create a layout object in toolkit/
+		+ populate it with good things ...
+
+	+ coupling to toolkit - widget instantiation: how ...
+		+ ComponentInfos
+			+ vclxtoolkit.cxx:
+		+ has a 'hook function' for 'fnSvtCreateWindow'
+		  for SVT widgets :-) [ grotesque ;-]
+			+ [ wow - fetched by dlopen! ;-]
+
+	+ A little app - a-la solver: using awt (?)
+		+ XMessageBoxFactory ...
+		+ XToolkit:
+			+ CreateWindow ...
+		+ ** how does the xml code generate these guys ? **
+
+	+ what APIs does the xmlimporter use ? not 'createWindow' seemingly.
+
++ existing xml import uses: property bag a -lot-:
+	Reference< beans::XPropertySet > xProps(
+	        _pImport->_xDialogModel, UNO_QUERY_THROW );
+	* we do _xDialogModel->insertByName (new any<XControlModel>())
+		+ to build hierarchy ( cf. ~ControlImportContext )
+
+	DialogImport:
+		css::uno::Reference< css::container::XNameContainer > _xDialogModel;
+
+	Reference< container::XNameContainer > xModel( xContext->getServiceManager()->createInstanceWithContext(
+			OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.awt.UnoControlDialogModel" ) ), xContext ), UNO_QUERY );
+
+	toolkit/source/controls/dialogcontrol.cxx
+		+ UnoControlButtonModel (eg.)
+		+ service 'UnoControlModel' ...
+
+	+ poke at 'titledbox' or 'radiogroup' to see how containment works there ...
+		+ how will child widget properties work ?
+		+ bug with a 'vbox' inside a 'titledbox' ...
+	+ titledbox - acts as a container (interesting)
+		- offsetting child positions
+	+ how will pseudo-containers eg. "radiogroup" cope ?
+
+	+ propose new syntax: [ with child properties a-la glade ]:
+
+	<hbox id="baa" flange="true">
+		<child padding="0" expand="false" fill="false">
+			<radio id="foo" value="..."/>
+		</child>
+		<radio id="foo" value="..."/>
+	</hbox>
+	
+	+ if 'child' element omitted - default properties used ...
+	+ if multiple elements in same 'child' set: all have the same props.
+
+
diff --git a/layout/doc/stats.ods b/layout/doc/stats.ods
new file mode 100644
index 0000000..b3eed68
Binary files /dev/null and b/layout/doc/stats.ods differ
diff --git a/layout/doc/vcl.txt b/layout/doc/vcl.txt
new file mode 100644
index 0000000..dbafbc5
--- /dev/null
+++ layout/doc/vcl.txt
@@ -0,0 +1,20 @@
+* How do very basic vcl widgets get peers:
+
+    + toolkit/awt/ VCLXToolkit::ImplCreateWindow
+	+ calls GetComponentInterface (sal_True) - if no comp. iface.
+
+    + vcl's Window:
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindowPeer > GetComponentInterface( BOOL bCreate = TRUE );
+
+    + vcl/inc/vcl/unowrap.hxx:
+	// Window
+	virtual ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindowPeer> GetWindowInterface( Window* pWindow, sal_Bool bCreate ) = 0;
+	virtual void				SetWindowInterface( Window* pWindow, ::com::sun::star::uno::Reference< ::com::sun::star::awt::XWindowPeer > xIFace ) = 0;
+
+    + from svapp.cxx Application::SetUnoWrapper
+	-> toolkit/awt 'ToolkitWorkerFunction' ( extern C / dlopen linkage )
+
+    + from toolkit/source/helper/unowrapper.cxx:
+	-> CreateXWindow -> 'return new VCLXWindow' 
+	    ** FIXME: we need love in here too:
+		+ METRICBOX eg.
\ No newline at end of file
diff --git a/layout/inc/layout/layout-post.hxx b/layout/inc/layout/layout-post.hxx
new file mode 100644
index 0000000..0fe921d
--- /dev/null
+++ layout/inc/layout/layout-post.hxx
@@ -0,0 +1,30 @@
+#ifndef _LAYOUT_POST_HXX
+#define _LAYOUT_POST_HXX
+
+#if ENABLE_LAYOUT
+
+#undef Button
+#undef CancelButton
+#undef FixedInfo
+#undef FixedLine
+#undef FixedText
+#undef HelpButton
+#undef MetricField
+#undef OKButton
+#undef RadioButton
+#undef SfxModalDialog
+
+#undef Window
+
+#undef SVX_RES
+#define SVX_RES(i)        ResId(i,DIALOG_MGR())
+
+#undef SW_RES
+#define SW_RES(i)               ResId(i,SWDIALOG_MGR())
+
+/* Allow re-inclusion for cxx file. */
+#undef _LAYOUT_PRE_HXX
+
+#endif /* ENABLE_LAYOUT */
+
+#endif /* _LAYOUT_POST_HXX */
diff --git a/layout/inc/layout/layout-pre.hxx b/layout/inc/layout/layout-pre.hxx
new file mode 100644
index 0000000..2c467ce
--- /dev/null
+++ layout/inc/layout/layout-pre.hxx
@@ -0,0 +1,64 @@
+#ifndef _LAYOUT_PRE_HXX
+#define _LAYOUT_PRE_HXX
+
+#if ENABLE_LAYOUT
+
+//#if !LAYOUT
+//#define LAYOUT 1
+//#endif
+//#define LAYOUT_NS layout
+
+// TWBN, but find that SfxModalDialog and FixedLine are already defined, eg compiling
+// dlgfact.cxx
+//typedef layout::Dialog SfxModalDialog;
+//typedef layout::FixedLine FixedLine;
+
+#define Button layout::Button
+#define CancelButton layout::CancelButton
+#define FixedInfo layout::FixedInfo
+#define FixedLine layout::FixedLine
+#define FixedText layout::FixedText
+#define HelpButton layout::HelpButton
+#define MetricField layout::MetricField
+#define OKButton layout::OKButton
+#define RadioButton layout::RadioButton
+#define SfxModalDialog layout::Dialog
+
+/* FIXME: why are we defaulting to layout::Window?
+   /home/janneke/vc/ooo-build/build/hack/sw/source/ui/dialog/wordcountdialog.cxx:87: error: no matching function for call to 'layout::Dialog::Dialog(Window*&, const char [14], const char [7])'
+   ../../../../layout/inc/layout/layout.hxx:304: note: candidates are: layout::Dialog::Dialog(layout::Window*, const char*, const char*, sal_uInt32)
+   ../../../../layout/inc/layout/layout.hxx:300: note:                 layout::Dialog::Dialog(const layout::Dialog&)
+*/
+
+#define Window ::Window
+
+#undef SVX_RES
+#define SVX_RES(x) #x
+#undef SW_RES
+#define SW_RES(x) #x
+
+/* Hmm.  This hack makes zoom.cxx, wordcountdialog.cxx diffs smaller
+ * but is not scalable. */
+#ifdef _LAYOUT_POST_HXX
+
+#ifdef _SVX_ZOOM_CXX
+#undef SfxModalDialog
+#define SfxModalDialog( pParent, SVX_RES_RID ) layout::Dialog( pParent, "zoom.xml", "dialog" )
+#define _SVX_ZOOM_HRC
+#endif /* _SVX_ZOOM_CXX */
+
+#ifdef SW_WORDCOUNTDIALOG_HXX
+#undef SfxModalDialog
+#define SfxModalDialog( pParent, SW_RES_RID ) layout::Dialog( pParent, "wordcount.xml", "dialog" )
+#define SW_WORDCOUNTDIALOG_HRC
+#endif /* SW_WORDCOUNTDIALOG_HXX */
+
+#endif /* _SVX_ZOOM_CXX */
+
+#else /* !ENABLE_LAYOUT */
+
+#define LAYOUT_PRE_POST
+
+#endif /* !ENABLE_LAYOUT */
+
+#endif /* _LAYOUT_PRE_HXX */
diff --git a/layout/inc/layout/layout.hxx b/layout/inc/layout/layout.hxx
new file mode 100644
index 0000000..c4706db
--- /dev/null
+++ layout/inc/layout/layout.hxx
@@ -0,0 +1,440 @@
+#ifndef _LAYOUT_HXX
+#define _LAYOUT_HXX
+
+#if ENABLE_LAYOUT
+
+#include <com/sun/star/uno/XInterface.hpp>
+#include <com/sun/star/awt/XLayoutContainer.hpp>
+#include <tools/link.hxx>
+#include <tools/string.hxx>
+
+// FIXME: eventually wrap FieldUnit
+#include <vcl/fldunit.hxx>
+// FIXME: eventually wrap this too ...
+#include <vcl/wintypes.hxx>
+
+class Window;
+
+namespace layout
+{
+
+namespace css = ::com::sun::star;
+
+typedef css::uno::Reference< css::uno::XInterface > PeerHandle;
+class ContextImpl;
+class Context
+{
+    ContextImpl *pImpl;
+public:
+    Context( const char *pPath );
+    ~Context();
+    PeerHandle GetPeerHandle( const char *pId, sal_uInt32 nId = 0 ) const;
+    void setToplevel( PeerHandle xToplevel );
+    PeerHandle getToplevel();
+    PeerHandle getRoot();
+};
+
+class ImageImpl;
+class Image
+{
+    ImageImpl *pImpl;
+public:
+    Image( const char *pName );
+    ~Image();
+    ImageImpl &getImpl() const { return *pImpl; }
+};
+
+// make declaring wrappers easier ...
+#define DECL_CONSTRUCTORS(t,par,defaultWinBit) \
+    protected:                                 \
+        explicit t( WindowImpl *pImpl ) : \
+            par( pImpl ) {} \
+        const char *GetUnoName() const; \
+    public: \
+        t( Context *pCtx, const char *pId, sal_uInt32 nId = 0 ); \
+        t( Window *pParent, WinBits nStyle = defaultWinBit )
+#define DECL_GET_IMPL(t) \
+        inline t##Impl &getImpl() const
+
+// follows the VCL inheritance hierarchy ...
+
+class WindowImpl;
+class Window
+{
+protected:
+    WindowImpl *mpImpl;
+    static PeerHandle CreatePeer( Window *pParent, WinBits nStyle,
+                                  const char *pName);
+public:
+    PeerHandle GetPeer();
+    Context *getContext();
+    DECL_GET_IMPL( Window );
+    explicit Window( WindowImpl *pImpl );
+    virtual ~Window();
+
+    void Enable( bool bEnable = true );
+    inline void Disable() { Enable( false ); }
+    void Show( BOOL bVisible = TRUE );
+    inline void Hide() { Show( FALSE ); }
+    void GrabFocus();
+    void FreeResource() {}
+
+    WinBits GetStyle();
+    void SetStyle( WinBits nStyle );
+};
+
+class ControlImpl;
+class Control : public Window
+{
+    DECL_GET_IMPL( Control );
+    DECL_CONSTRUCTORS( Control, Window, 0 );
+public:
+// void SetText( const String& rStr ); - can't do this here ...
+};
+
+class FixedLineImpl;
+class FixedLine : public Control
+{
+    friend class FixedLineImpl;
+    DECL_GET_IMPL( FixedLine );
+    DECL_CONSTRUCTORS( FixedLine, Control, WB_HORZ );
+};
+
+class FixedTextImpl;
+class FixedText : public Control
+{
+    friend class FixedTextImpl;
+    DECL_GET_IMPL( FixedText );
+    DECL_CONSTRUCTORS( FixedText, Control, 0 );
+public:
+    void SetText( const String& rStr );
+};
+
+class FixedInfoImpl;
+class FixedInfo : public FixedText
+{
+    friend class FixedInfoImpl;
+    DECL_GET_IMPL( FixedInfo );
+    DECL_CONSTRUCTORS( FixedInfo, FixedText, 0 );
+};
+
+class ButtonImpl;
+class Button : public Control
+{
+    friend class ButtonImpl;
+    DECL_GET_IMPL( Button );
+    DECL_CONSTRUCTORS( Button, Control, 0 );
+public:
+    void SetText( const String& rStr );
+    BOOL SetModeImage( const Image& rImage );
+    void SetImageAlign( ImageAlign eAlign );
+
+    void SetClickHdl( const Link& rLink );
+    virtual void Click() /* pure virtual? */;
+};
+
+class PushButtonImpl;
+class PushButton : public Button
+{
+    DECL_GET_IMPL( PushButton );
+    DECL_CONSTRUCTORS( PushButton, Button, 0 );
+public:
+    void Check( BOOL bCheck = TRUE );
+    BOOL IsChecked() const;
+
+    void Toggle();
+    void SetToggleHdl( const Link& rLink );
+};
+
+class OKButton : public PushButton
+{
+    DECL_CONSTRUCTORS( OKButton, PushButton, WB_DEFBUTTON );
+};
+class CancelButton : public PushButton
+{
+    DECL_CONSTRUCTORS( CancelButton, PushButton, 0 );
+};
+class YesButton : public PushButton
+{
+    DECL_CONSTRUCTORS( YesButton, PushButton, WB_DEFBUTTON );
+};
+class NoButton : public PushButton
+{
+    DECL_CONSTRUCTORS( NoButton, PushButton, 0 );
+};
+class RetryButton : public PushButton
+{
+    DECL_CONSTRUCTORS( RetryButton, PushButton, 0 );
+};
+class IgnoreButton : public PushButton
+{
+    DECL_CONSTRUCTORS( IgnoreButton, PushButton, 0 );
+};
+class ResetButton : public PushButton
+{
+    DECL_CONSTRUCTORS( ResetButton, PushButton, 0 );
+};
+class ApplyButton : public PushButton
+{
+    DECL_CONSTRUCTORS( ApplyButton, PushButton, 0 );
+};
+class HelpButton : public PushButton
+{
+    DECL_CONSTRUCTORS( HelpButton, PushButton, 0 );
+};
+
+class RadioButtonImpl;
+class RadioButton : public Button
+{
+    DECL_GET_IMPL( RadioButton );
+    DECL_CONSTRUCTORS( RadioButton, Button, 0 );
+public:
+    void Check( BOOL bCheck = TRUE );
+    BOOL IsChecked() const;
+
+    void Toggle();
+    void SetToggleHdl( const Link& rLink );
+};
+
+class CheckBoxImpl;
+class CheckBox : public Button
+{
+    DECL_GET_IMPL( CheckBox );
+    DECL_CONSTRUCTORS( CheckBox, Button, 0 );
+public:
+    void Check( BOOL bCheck = TRUE );
+    BOOL IsChecked() const;
+
+    void Toggle();
+    void SetToggleHdl( const Link& rLink );
+};
+
+class EditImpl;
+class Edit : public Control
+{
+    DECL_GET_IMPL( Edit );
+    DECL_CONSTRUCTORS( Edit, Control, WB_BORDER );
+public:
+    void SetText( const XubString& rStr ) const;
+    XubString GetText() const;
+    void SetModifyHdl( const Link& rLink );
+};
+
+class MultiLineEditImpl;
+class MultiLineEdit : public Edit
+{
+    DECL_GET_IMPL( MultiLineEdit );
+    DECL_CONSTRUCTORS( MultiLineEdit, Edit, WB_LEFT|WB_BORDER );
+};
+
+class SpinFieldImpl;
+class SpinField : public Edit
+{
+    DECL_GET_IMPL( SpinField );
+    DECL_CONSTRUCTORS( SpinField, Edit, 0 );
+};
+
+class FormatterBaseImpl;
+class FormatterBase
+{
+protected:
+    FormatterBaseImpl *mpFormatImpl;
+    FormatterBase( FormatterBaseImpl *pFormatImpl )
+        : mpFormatImpl( pFormatImpl ) {}
+};
+
+class NumericFormatterImpl;
+class NumericFormatter : public FormatterBase
+{
+protected:
+    explicit NumericFormatter( FormatterBaseImpl *pImpl );
+    NumericFormatterImpl &getFormatImpl() const;
+public:
+    void SetMin( sal_Int64 nNewMin );
+    void SetMax( sal_Int64 nNewMax );
+    void SetFirst( sal_Int64 nNewFirst );
+    void SetLast( sal_Int64 nNewLast );
+    void SetSpinSize( sal_Int64 nNewSize );
+
+    void SetValue( sal_Int64 nNewValue );
+    sal_Int64 GetValue() const;
+};
+
+class NumericFieldImpl;
+class NumericField : public SpinField, public NumericFormatter
+{
+    DECL_GET_IMPL( NumericField );
+public:
+    NumericField( Context *pCtx, const char *pId, sal_uInt32 nId = 0 );
+    NumericField( Window *pParent, WinBits nStyle );
+};
+
+class MetricFormatterImpl;
+// Different inheritance to save code
+class MetricFormatter : public FormatterBase
+{
+  protected:
+    explicit MetricFormatter( FormatterBaseImpl *pImpl );
+    MetricFormatterImpl &getFormatImpl() const;
+public:
+    void SetMin( sal_Int64 nNewMin, FieldUnit nUnit = FUNIT_NONE );
+    void SetMax( sal_Int64 nNewMax, FieldUnit nUnit = FUNIT_NONE );
+    void SetFirst( sal_Int64 nNewFirst, FieldUnit nUnit = FUNIT_NONE );
+    void SetLast( sal_Int64 nNewLast, FieldUnit nUnit = FUNIT_NONE );
+    void SetValue( sal_Int64 nNewValue, FieldUnit nUnit = FUNIT_NONE );
+    sal_Int64 GetValue( FieldUnit nUnit = FUNIT_NONE ) const;
+
+    void SetSpinSize( sal_Int64 nNewSize );
+};
+
+class MetricFieldImpl;
+class MetricField : public SpinField, public MetricFormatter
+{
+    DECL_GET_IMPL( MetricField );
+public:
+    MetricField( Context *pCtx, const char *pId, sal_uInt32 nId = 0 );
+    MetricField( Window *pParent, WinBits nStyle );
+};
+
+#define COMBOBOX_APPEND            ((USHORT)0xFFFF)
+#define COMBOBOX_ENTRY_NOTFOUND    ((USHORT)0xFFFF)
+class ComboBoxImpl;
+class ComboBox : public Edit
+{
+    DECL_GET_IMPL( ComboBox );
+    DECL_CONSTRUCTORS( ComboBox, Edit, 0 );
+
+public:
+    USHORT InsertEntry( const XubString& rStr, USHORT nPos = COMBOBOX_APPEND );
+    void RemoveEntry( const XubString& rStr );
+    void RemoveEntry( USHORT nPos );
+    void Clear();
+
+    USHORT GetEntryPos( const XubString& rStr ) const;
+    XubString GetEntry( USHORT nPos ) const;
+    USHORT GetEntryCount() const;
+
+    void SetClickHdl( const Link& rLink );
+    void SetSelectHdl( const Link& rLink );
+};
+
+#define LISTBOX_APPEND               ((USHORT)0xFFFF)
+#define LISTBOX_ENTRY_NOTFOUND       ((USHORT)0xFFFF)
+class ListBoxImpl;
+class ListBox : public Control
+{
+    DECL_GET_IMPL( ListBox );
+    DECL_CONSTRUCTORS( ListBox, Control, WB_BORDER );
+public:
+    USHORT InsertEntry( const XubString& rStr, USHORT nPos = LISTBOX_APPEND );
+
+    void RemoveEntry( const XubString& rStr );
+    void RemoveEntry( USHORT nPos );
+    void Clear();
+
+    USHORT GetEntryPos( const XubString& rStr ) const;
+    XubString GetEntry( USHORT nPos ) const;
+    USHORT GetEntryCount() const;
+
+    void SelectEntry( const XubString& rStr, BOOL bSelect = TRUE );
+    void SelectEntryPos( USHORT nPos, BOOL bSelect = TRUE );
+
+    USHORT GetSelectEntryCount() const;
+    XubString GetSelectEntry( USHORT nSelIndex = 0 ) const;
+    USHORT GetSelectEntryPos( USHORT nSelIndex = 0 ) const;
+
+    void SetSelectHdl( const Link& rLink );
+    void SetClickHdl( const Link& rLink );
+};
+
+class DialogImpl;
+class Dialog : public Context, public Window
+{
+    DECL_GET_IMPL( Dialog );
+    void SetParent( Window *pParent );
+    void SetParent( ::Window *pParent );
+public:
+    Dialog( Window *pOptParent, const char *pXMLPath, const char *pId, sal_uInt32 nId = 0 );
+    Dialog( ::Window *pOptParent, const char *pXMLPath, const char *pId, sal_uInt32 nId = 0 );
+    short Execute();
+    void EndDialog( long nResult = 0 );
+    void SetText( const String& rStr );
+};
+
+// -----------------------------------------------------------------
+//                 layout container / helper wrappers
+// -----------------------------------------------------------------
+
+class Container
+{
+protected:
+    css::uno::Reference< css::awt::XLayoutContainer > mxContainer;
+    Container( const rtl::OUString &rName, sal_Int32 nBorder );
+public:
+    Container( const Context *pCtx, const char *pId );
+
+    void Add( Window *pWindow );
+    void Add( Container *pContainer );
+
+    void Remove( Window *pWindow );
+    void Remove( Container *pContainer );
+    void Clear();
+    // we can't really do a GetChildren() as they don't have a common class,
+    // besides we would need to keep track of children, uh
+
+    void ShowAll( bool bVisible );
+
+    css::uno::Reference< css::awt::XLayoutContainer > getImpl()
+    { return mxContainer; }
+};
+
+class Table : public Container
+{
+protected:
+    Table( sal_Int32 nBorder, sal_Int32 nColumns );
+public:
+    Table( const Context *pCtx, const char *pId )
+        : Container( pCtx, pId ) {}
+    void Add( Window *pWindow, bool bXExpand, bool bYExpand,
+              sal_Int32 nXSpan = 1, sal_Int32 nYSpan = 1 );
+    void Add( Container *pContainer, bool bXExpand, bool bYExpand,
+              sal_Int32 nXSpan = 1, sal_Int32 nYSpan = 1 );
+
+private:
+    void setProps( css::uno::Reference< css::awt::XLayoutConstrains > xChild,
+                   bool bXExpand, bool bYExpand, sal_Int32 nXSpan, sal_Int32 nYSpan );
+};
+
+class Box : public Container
+{
+protected:
+    Box( const rtl::OUString &rName, sal_Int32 nBorder, bool bHomogeneous );
+public:
+    Box( const Context *pCtx, const char *pId )
+        : Container( pCtx, pId ) {}
+    void Add( Window *pWindow, bool bExpand, bool bFill, sal_Int32 nPadding);
+    void Add( Container *pContainer, bool bExpand, bool bFill, sal_Int32 nPadding);
+
+private:
+    void setProps( css::uno::Reference< css::awt::XLayoutConstrains > xChild,
+                   bool bXExpand, bool bYExpand, sal_Int32 nPadding );
+};
+
+class HBox : public Box
+{
+public:
+    HBox( sal_Int32 nBorder, bool bHomogeneous )
+        : Box( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "hbox" ) ), nBorder, bHomogeneous ) {}
+};
+class VBox : public Box
+{
+public:
+    VBox( sal_Int32 nBorder, bool bHomogeneous )
+        : Box( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "vbox" ) ), nBorder, bHomogeneous ) {}
+};
+
+} // end namespace layout
+
+#endif /* ENABLE_LAYOUT */
+
+#endif /* _LAYOUT_HXX */
diff --git a/layout/prj/build.lst b/layout/prj/build.lst
new file mode 100644
index 0000000..952df14
--- /dev/null
+++ layout/prj/build.lst
@@ -0,0 +1,8 @@
+ly	layout	: toolkit xmlscript unotools NULL
+ly	layout                usr1	-	all	ly_mkout NULL
+ly	layout\source\api     nmake	-	all	ly_api NULL
+ly	layout\source\awt     nmake	-	all	ly_awt ly_api NULL
+ly	layout\source\core    nmake	-	all	ly_core ly_api NULL
+ly	layout\source\wrapper nmake	-	all	ly_wrap ly_api NULL
+ly	layout\workben        nmake	-	all	ly_workben ly_api ly_awt ly_core ly_wrap NULL
+ly	layout\util	      nmake	-	all	ly_util ly_api ly_awt ly_core ly_wrap NULL
diff --git a/layout/prj/d.lst b/layout/prj/d.lst
new file mode 100644
index 0000000..20e2a55
--- /dev/null
+++ layout/prj/d.lst
@@ -0,0 +1,18 @@
+mkdir: %_DEST%\inc%_EXT%\layout
+mkdir: %_DEST%\inc%_EXT%\com
+mkdir: %_DEST%\inc%_EXT%\com\sun
+mkdir: %_DEST%\inc%_EXT%\com\sun\star\awt
+
+..\%__SRC%\lib\lib*.so %_DEST%\lib%_EXT%
+..\%__SRC%\lib\*.sl %_DEST%\lib%_EXT%\*.sl
+..\%__SRC%\lib\*.a %_DEST%\lib%_EXT%\*.a
+..\%__SRC%\lib\*.dylib %_DEST%\lib%_EXT%\*.dylib
+..\%__SRC%\lib\layout.lib %_DEST%\lib%_EXT%\layout.lib
+..\%__SRC%\bin\layout*.dll %_DEST%\bin%_EXT%\layout*.dll
+..\%__SRC%\misc\layout*.map %_DEST%\bin%_EXT%\layout*.map
+..\%__SRC%\lib\*.xml %_DEST%\lib%_EXT%\*.xml
+
+..\inc\layout\*.hxx %_DEST%\inc%_EXT%\layout\*.hxx
+
+..\%__SRC%\inc\com\sun\star\ui\awt\*.hdl %_DEST%\inc%_EXT%\com\sun\star\awt\*.hdl
+..\%__SRC%\inc\com\sun\star\ui\awt\*.hpp %_DEST%\inc%_EXT%\com\sun\star\awt\*.hpp
diff --git a/layout/source/.gitignore b/layout/source/.gitignore
new file mode 100644
index 0000000..b25c15b
--- /dev/null
+++ layout/source/.gitignore
@@ -0,0 +1 @@
+*~
diff --git a/layout/source/api/com/sun/star/awt/MaxChildrenException.idl b/layout/source/api/com/sun/star/awt/MaxChildrenException.idl
new file mode 100644
index 0000000..f595679
--- /dev/null
+++ layout/source/api/com/sun/star/awt/MaxChildrenException.idl
@@ -0,0 +1,27 @@
+#ifndef __com_sun_star_awt_MaxChildrenException_idl__ 
+#define __com_sun_star_awt_MaxChildrenException_idl__ 
+
+#ifndef __com_sun_star_uno_Exception_idl__
+#include <com/sun/star/uno/Exception.idl>
+#endif
+
+//============================================================================= 
+
+module com {  module sun {  module star {  module awt {
+
+//============================================================================= 
+ 
+/** This exception is thrown when adding a child to a container that is full.
+
+	@see     XLayoutContainer
+	@see     com::sun::star::awt::XLayoutContainer::addChild
+ */
+published exception MaxChildrenException: com::sun::star::uno::Exception
+{ 
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };
+
+#endif
diff --git a/layout/source/api/com/sun/star/awt/XDialog2.idl b/layout/source/api/com/sun/star/awt/XDialog2.idl
new file mode 100644
index 0000000..a9b99dc
--- /dev/null
+++ layout/source/api/com/sun/star/awt/XDialog2.idl
@@ -0,0 +1,26 @@
+#ifndef __com_sun_star_awt_XDialog2_idl__ 
+#define __com_sun_star_awt_XDialog2_idl__ 
+ 
+#ifndef __com_sun_star_awt_XDialog_idl__
+#include <com/sun/star/awt/XDialog.idl> 
+#endif 
+ 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module awt {
+ 
+//============================================================================= 
+ 
+/** Makes it possible to end a dialog.
+ */
+published interface XDialog2: com::sun::star::awt::XDialog
+{ 
+    void endDialog ( [in] long Result );
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
diff --git a/layout/source/api/com/sun/star/awt/XLayoutContainer.idl b/layout/source/api/com/sun/star/awt/XLayoutContainer.idl
new file mode 100644
index 0000000..d324c6d
--- /dev/null
+++ layout/source/api/com/sun/star/awt/XLayoutContainer.idl
@@ -0,0 +1,75 @@
+#ifndef __com_sun_star_awt_XLayoutContainer_idl__ 
+#define __com_sun_star_awt_XLayoutContainer_idl__ 
+
+#ifndef __com_sun_star_awt_XLayoutConstrains_idl__ 
+#include <com/sun/star/awt/XLayoutConstrains.idl> 
+#endif 
+#ifndef __com_sun_star_awt_Rectangle_idl__ 
+#include <com/sun/star/awt/Rectangle.idl> 
+#endif 
+#ifndef __com_sun_star_beans_XPropertySet_idl__ 
+#include <com/sun/star/beans/XPropertySet.idl> 
+#endif 
+#ifndef __com_sun_star_container_XChild_idl__ 
+#include <com/sun/star/container/XChild.idl> 
+#endif
+#ifndef __com_sun_star_awt_MaxChildrenException_idl__ 
+#include <com/sun/star/awt/MaxChildrenException.idl> 
+#endif
+#ifndef __com_sun_star_awt_XLayoutUnit_idl__ 
+#include <com/sun/star/awt/XLayoutUnit.idl> 
+#endif
+
+//============================================================================= 
+
+module com {  module sun {  module star {  module awt {
+
+//============================================================================= 
+
+published interface XLayoutUnit;
+
+/** specifies the layout constraints for a surrounding container.
+ */
+published interface XLayoutContainer: com::sun::star::container::XChild
+{
+	/* Add/remove a child. Some containers provide an interface for
+	   adding children which you should use. */
+    void addChild( [in] com::sun::star::awt::XLayoutConstrains Child )
+		raises( com::sun::star::awt::MaxChildrenException ); 
+    void removeChild( [in] com::sun::star::awt::XLayoutConstrains Child );
+	sequence< com::sun::star::awt::XLayoutConstrains > getChildren();
+
+	/* Read/modify some child layout properties. XPropertySet provides a
+	   rich API that allows, e.g., for introspection.
+	   Should rarely be a need to use; containers shall provide an interface
+	   for setting properties more confortably. */
+    com::sun::star::beans::XPropertySet getChildProperties(
+		[in] com::sun::star::awt::XLayoutConstrains Child );
+
+	/* Set at initilization, this object should be notified when a containers state
+	   changes, that may affect its size, to queue a layout re-calculation. */
+	void setLayoutUnit( [in] com::sun::star::awt::XLayoutUnit Unit );
+
+	// TEMP: no need for this...
+	com::sun::star::awt::XLayoutUnit getLayoutUnit();
+
+	/* To be used by the parent for the purpose of layout management. 
+	   For widgets, use XWindow::setPosSize() */
+    void allocateArea( [in] com::sun::star::awt::Rectangle NewArea );
+
+	/* Used by the layouting unit to evaluate size damage, and force a
+	   re-allocation. */
+	com::sun::star::awt::Size getRequestedSize();
+	com::sun::star::awt::Rectangle getAllocatedArea();
+
+	/* For flow layouting (e.g. wrap-able labels). TODO: We might want to
+	   re-design this approach -- check XLayoutConstrains::calcAdjustedSize(). */
+	long getHeightForWidth( [in] long Width );
+	boolean hasHeightForWidth();
+};
+ 
+//============================================================================= 
+
+}; }; }; };
+
+#endif
diff --git a/layout/source/api/com/sun/star/awt/XLayoutFlow.idl b/layout/source/api/com/sun/star/awt/XLayoutFlow.idl
new file mode 100644
index 0000000..b82c3b1
--- /dev/null
+++ layout/source/api/com/sun/star/awt/XLayoutFlow.idl
@@ -0,0 +1,29 @@
+#ifndef __com_sun_star_awt_XLayoutFlow_idl__ 
+#define __com_sun_star_awt_XLayoutFlow_idl__ 
+
+//============================================================================= 
+
+#include <com/sun/star/uno/XInterface.idl> 
+ 
+module com {  module sun {  module star {  module awt {
+ 
+//============================================================================= 
+ 
+/** Enables height-for-width layout negociations, which allows for label wrapping
+ *  and flow containers. Can be implemented by either a container or an ordinary widget;
+ *  whether its parent will honor it is another story, so keep implementing
+ *  getMinimumSize().
+ */
+published interface XLayoutFlow
+{
+	long getHeightForWidth( [in] long Width );
+
+	/* Allow the container/widget to toggle the functionality. */
+	boolean hasHeightForWidth();
+};
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif 
diff --git a/layout/source/api/com/sun/star/awt/XLayoutFlowContainer.idl b/layout/source/api/com/sun/star/awt/XLayoutFlowContainer.idl
new file mode 100644
index 0000000..57080fd
--- /dev/null
+++ layout/source/api/com/sun/star/awt/XLayoutFlowContainer.idl
@@ -0,0 +1,25 @@
+#ifndef __com_sun_star_awt_XLayoutUnit_idl__ 
+#define __com_sun_star_awt_XLayoutUnit_idl__ 
+
+#include <com/sun/star/awt/XLayoutContainer.idl> 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module awt {
+ 
+//============================================================================= 
+ 
+/** Responsible to evaluate size damages and force a re-calculation. Containers
+    should let it know of state changes that may affects their size.
+ *  All children of a top-level window should share the same object.
+ */
+published interface XLayoutContainer
+{
+	void queueResize( [in] com::sun::star::awt::XLayoutContainer Container );
+};
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif 
diff --git a/layout/source/api/com/sun/star/awt/XLayoutRoot.idl b/layout/source/api/com/sun/star/awt/XLayoutRoot.idl
new file mode 100644
index 0000000..5826f2f
--- /dev/null
+++ layout/source/api/com/sun/star/awt/XLayoutRoot.idl
@@ -0,0 +1,31 @@
+#ifndef __com_sun_star_awt_XLayoutRoot_idl__ 
+#define __com_sun_star_awt_XLayoutRoot_idl__ 
+ 
+#ifndef __com_sun_star_awt_XLayoutContainer_idl__ 
+#include <com/sun/star/awt/XLayoutContainer.idl> 
+#endif 
+#ifndef __com_sun_star_container_XNameAccess_idl__ 
+#include <com/sun/star/container/XNameAccess.idl> 
+#endif 
+#ifndef __com_sun_star_container_XNameContainer_idl__ 
+#include <com/sun/star/container/XNameContainer.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module awt {
+ 
+//============================================================================= 
+ 
+/** specifies an interface for a top-level layoutable widget
+ */
+published interface XLayoutRoot: com::sun::star::container::XNameAccess
+{
+    com::sun::star::awt::XLayoutContainer getLayoutContainer();
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
diff --git a/layout/source/api/com/sun/star/awt/XLayoutUnit.idl b/layout/source/api/com/sun/star/awt/XLayoutUnit.idl
new file mode 100644
index 0000000..fa844e6
--- /dev/null
+++ layout/source/api/com/sun/star/awt/XLayoutUnit.idl
@@ -0,0 +1,29 @@
+#ifndef __com_sun_star_awt_XLayoutUnit_idl__ 
+#define __com_sun_star_awt_XLayoutUnit_idl__ 
+
+#ifndef __com_sun_star_awt_XLayoutContainer_idl__ 
+#include <com/sun/star/awt/XLayoutContainer.idl> 
+#endif
+
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module awt {
+ 
+//============================================================================= 
+
+published interface XLayoutContainer;
+
+/** Responsible to evaluate size damages and force a re-calculation. Containers
+    should let it know of state changes that may affects their size.
+ *  All children of a top-level window should share the same object.
+ */
+published interface XLayoutUnit
+{
+	void queueResize( [in] com::sun::star::awt::XLayoutContainer Container );
+};
+ 
+//============================================================================= 
+ 
+}; }; }; };
+ 
+#endif
diff --git a/layout/source/api/makefile.mk b/layout/source/api/makefile.mk
new file mode 100644
index 0000000..f095bd4
--- /dev/null
+++ layout/source/api/makefile.mk
@@ -0,0 +1,44 @@
+PRJ=..$/..
+
+PRJNAME=layout
+TARGET=api
+ENABLE_EXCEPTIONS=TRUE
+TARGETTYPE=GUI
+
+
+# --- Settings -----------------------------------------------------------
+
+.INCLUDE :	settings.mk
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+# --- Private UNO ----------------------------------------------------------
+
+PRIVATERDB = localtypes.rdb
+UNOUCRRDB = $(BIN)$/layout.rdb
+UNOUCRDEP = $(UNOUCRRDB)
+UNOUCROUT = $(OUT)$/inc
+
+CPPUMAKERFLAGS += -C -X$(SOLARBINDIR)$/types.rdb
+
+UNOTYPES = com.sun.star.awt.XLayoutRoot \
+           com.sun.star.awt.XLayoutContainer \
+           com.sun.star.awt.XLayoutUnit \
+           com.sun.star.awt.XDialog2 \
+           com.sun.star.awt.MaxChildrenException
+
+ALLIDLFILES = $(foreach,i,$(UNOTYPES) $(subst,.,$/ $i).idl)
+
+# ==========================================================================
+
+.INCLUDE :	target.mk
+
+# --- Private UNO ----------------------------------------------------------
+
+ALLTAR : $(UNOUCRRDB)
+
+$(BIN)$/$(PRIVATERDB) : $(ALLIDLFILES)
+	$(IDLC) -I. -I$(SOLARIDLDIR) -O$(UCR) $(ALLIDLFILES)
+	$(REGMERGE) $@ /UCR $(UCR)$/{$(?:f:s/.idl/.urd/)}
+
+$(UNOUCRRDB) : $(BIN)$/$(PRIVATERDB)
+	$(COPY) $< $@ 
diff --git a/layout/source/awt/forward.hxx b/layout/source/awt/forward.hxx
new file mode 100644
index 0000000..e51f7aa
--- /dev/null
+++ layout/source/awt/forward.hxx
@@ -0,0 +1,41 @@
+#ifndef AWT_FORWARD_HXX
+#define AWT_FORWARD_HXX
+
+#ifndef _COMPHELPER_UNO3_HXX_
+#include <comphelper/uno3.hxx>
+#endif
+
+#define IMPLEMENT_FORWARD_XTYPEPROVIDER1( classname, baseclass ) \
+    ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Type > SAL_CALL classname::getTypes(  ) throw (::com::sun::star::uno::RuntimeException) \
+    { return baseclass::getTypes(); } \
+    IMPLEMENT_GET_IMPLEMENTATION_ID( classname )
+
+#define IMPLEMENT_2_FORWARD_XINTERFACE1( classname, refcountbase1, refcountbase2 ) \
+    void SAL_CALL classname::acquire() throw() { refcountbase1::acquire(); refcountbase2::acquire(); } \
+    void SAL_CALL classname::release() throw() { refcountbase1::release(); refcountbase2::release(); } \
+    ::com::sun::star::uno::Any SAL_CALL classname::queryInterface( const ::com::sun::star::uno::Type& _rType ) throw (::com::sun::star::uno::RuntimeException) \
+    { \
+        ::com::sun::star::uno::Any aReturn = refcountbase1::queryInterface( _rType ); \
+        if ( !aReturn.hasValue() ) \
+        { \
+            aReturn = refcountbase2::queryInterface( _rType ); \
+        } \
+        return aReturn; \
+    }
+
+#define IMPLEMENT_2_FORWARD_XINTERFACE2( classname, refcountbase1, refcountbase2, baseclass3 ) \
+    void SAL_CALL classname::acquire() throw() { refcountbase1::acquire(); refcountbase2::acquire(); } \
+    void SAL_CALL classname::release() throw() { refcountbase1::release(); refcountbase2::release(); } \
+    ::com::sun::star::uno::Any SAL_CALL classname::queryInterface( const ::com::sun::star::uno::Type& _rType ) throw (::com::sun::star::uno::RuntimeException) \
+    { \
+        ::com::sun::star::uno::Any aReturn = refcountbase1::queryInterface( _rType ); \
+        if ( !aReturn.hasValue() ) \
+        { \
+            aReturn = refcountbase2::queryInterface( _rType ); \
+            if ( !aReturn.hasValue() ) \
+                aReturn = baseclass3::queryInterface( _rType ); \
+        } \
+        return aReturn; \
+    }
+
+#endif /*AWT_FORWARD_HXX*/
diff --git a/layout/source/awt/makefile.mk b/layout/source/awt/makefile.mk
new file mode 100644
index 0000000..caa9c72
--- /dev/null
+++ layout/source/awt/makefile.mk
@@ -0,0 +1,30 @@
+PRJ=..$/..
+PRJNAME=layout
+TARGET=awt
+ENABLE_EXCEPTIONS=true
+TARGETTYPE=GUI
+
+.INCLUDE : settings.mk
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+CFLAGS += -DENABLE_LAYOUT=1
+
+CXXFILES= \
+	vclxtabcontrol.cxx \
+	vclxproxy.cxx \
+	vclxbutton.cxx \
+	vclxdialog.cxx \
+	vclxscroller.cxx \
+	vclxsplitter.cxx \
+	vclxfixedline.cxx
+
+SLOFILES= \
+	$(SLO)$/vclxtabcontrol.obj \
+	$(SLO)$/vclxproxy.obj \
+	$(SLO)$/vclxbutton.obj \
+	$(SLO)$/vclxdialog.obj \
+	$(SLO)$/vclxscroller.obj \
+	$(SLO)$/vclxsplitter.obj \
+	$(SLO)$/vclxfixedline.obj	
+
+.INCLUDE : target.mk
diff --git a/layout/source/awt/non-interactable-containers.xml b/layout/source/awt/non-interactable-containers.xml
new file mode 100644
index 0000000..7e0b420
--- /dev/null
+++ layout/source/awt/non-interactable-containers.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             title="Interactable Containers" optimumsize="true"
+             border="true" sizeable="true" moveable="true">
+	<hbox>
+		<table columns="3" cnt:title="Page 1">
+			<pushbutton cnt:x-expand="false" cnt:row-span="2" label="1,1" />
+			<pushbutton cnt:y-expand="false" label="1,2" />
+			<pushbutton cnt:y-expand="false" label="1,3" />
+			<pushbutton cnt:col-span="2" label="2,1" />
+		</table>
+	</hbox>
+</dialog>
diff --git a/layout/source/awt/vclxbutton.cxx b/layout/source/awt/vclxbutton.cxx
new file mode 100644
index 0000000..14aeccd
--- /dev/null
+++ layout/source/awt/vclxbutton.cxx
@@ -0,0 +1,128 @@
+#include "vclxbutton.hxx"
+
+#include "layoutcore.hxx"
+#include <com/sun/star/awt/ImagePosition.hpp>
+#include <vcl/button.hxx>
+
+IconButton::IconButton( css::uno::Reference< css::uno::XInterface > xButton,
+                        rtl::OUString aDefaultLabel, const char *pGraphName )
+    : VCLXProxy( xButton )
+{
+    setLabel( aDefaultLabel );
+    setProperty( rtl::OUString::createFromAscii( "Graphic" ),
+                 css::uno::Any( layoutimpl::loadGraphic( pGraphName ) ) );
+    setProperty( rtl::OUString::createFromAscii( "ImagePosition" ),
+                 css::uno::Any( css::awt::ImagePosition::LeftCenter ) );
+    setProperty( rtl::OUString::createFromAscii( "Align" ),
+                 css::uno::Any( (sal_Int16) 1 /* magic - center */ ) );
+}
+
+// FIXME: l10n/i18n of Reset & Apply
+
+VCLXOKButton::VCLXOKButton( css::uno::Reference< css::uno::XInterface > xButton )
+    : IconButton( xButton, Button::GetStandardText( BUTTON_OK ),
+                  "res/commandimagelist/sc_ok.png" )
+{
+}
+
+VCLXCancelButton::VCLXCancelButton( css::uno::Reference< css::uno::XInterface > xButton )
+    : IconButton( xButton, Button::GetStandardText( BUTTON_CANCEL ),
+//    : IconButton( xButton, rtl::OUString::createFromAscii( "~Cancel " ),
+                  "res/commandimagelist/sc_cancel.png" )
+{
+}
+
+VCLXYesButton::VCLXYesButton( css::uno::Reference< css::uno::XInterface > xButton )
+    : IconButton( xButton, Button::GetStandardText( BUTTON_YES ),
+                  "res/commandimagelist/sc_yes.png" )
+{
+}
+
+VCLXNoButton::VCLXNoButton( css::uno::Reference< css::uno::XInterface > xButton )
+    : IconButton( xButton, Button::GetStandardText( BUTTON_NO ),
+                  "res/commandimagelist/sc_no.png" )
+{
+}
+
+VCLXRetryButton::VCLXRetryButton( css::uno::Reference< css::uno::XInterface > xButton )
+    : IconButton( xButton, Button::GetStandardText( BUTTON_RETRY ),
+                  "res/commandimagelist/sc_retry.png" )
+{
+}
+
+VCLXIgnoreButton::VCLXIgnoreButton( css::uno::Reference< css::uno::XInterface > xButton )
+    : IconButton( xButton, Button::GetStandardText( BUTTON_IGNORE ),
+                  "res/commandimagelist/sc_ignore.png" )
+{
+}
+
+VCLXResetButton::VCLXResetButton( css::uno::Reference< css::uno::XInterface > xButton )
+    : IconButton( xButton, rtl::OUString::createFromAscii( "~Reset " ),
+                  "res/commandimagelist/sc_reset.png" )
+{
+}
+
+VCLXApplyButton::VCLXApplyButton( css::uno::Reference< css::uno::XInterface > xButton )
+    : IconButton( xButton, rtl::OUString::createFromAscii( "Apply" ),
+                  "res/commandimagelist/sc_apply.png" )
+{
+}
+
+VCLXHelpButton::VCLXHelpButton( css::uno::Reference< css::uno::XInterface > xButton )
+    : IconButton( xButton, Button::GetStandardText( BUTTON_HELP ),
+                  "res/commandimagelist/sc_help.png" )
+{
+}
+
+namespace layoutimpl
+{
+css::uno::Reference< css::awt::XLayoutConstrains >
+createInternalWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
+                      css::uno::Reference< css::uno::XInterface > xParent,
+                      const rtl::OUString &rName, long nProps )
+{
+    css::uno::Reference< css::awt::XLayoutConstrains > xRef, xWrapped;
+    bool bOK = false;
+    bool bCancel = false;
+    bool bYes = false;
+    bool bNo = false;
+    bool bRetry = false;
+    bool bIgnore = false;
+    bool bReset = false;
+    bool bApply = false;
+    bool bHelp = false;
+    if ( ( bOK = rName.equalsAscii( "okbutton" ) )
+         || ( bCancel = rName.equalsAscii( "cancelbutton" ) )
+         || ( bYes = rName.equalsAscii( "yesbutton" ) )
+         || ( bNo = rName.equalsAscii( "nobutton" ) )
+         || ( bRetry = rName.equalsAscii( "retrybutton" ) )
+         || ( bIgnore = rName.equalsAscii( "ignorebutton" ) )
+         || ( bReset = rName.equalsAscii( "resetbutton" ) )
+         || ( bApply = rName.equalsAscii( "applybutton" ) )
+         || ( bHelp = rName.equalsAscii( "helpbutton" ) ) )
+    {
+        xWrapped = createWidget( xToolkit, xParent,
+                                 rtl::OUString::createFromAscii( "pushbutton" ),
+                                 nProps );
+        if ( bOK )
+            xRef = new VCLXOKButton( xWrapped );
+        if ( bCancel )
+            xRef = new VCLXCancelButton( xWrapped );
+        if ( bYes )
+            xRef = new VCLXYesButton( xWrapped );
+        if ( bNo )
+            xRef = new VCLXNoButton( xWrapped );
+        if ( bRetry )
+            xRef = new VCLXRetryButton( xWrapped );
+        if ( bIgnore )
+            xRef = new VCLXIgnoreButton( xWrapped );
+        if ( bReset )
+            xRef = new VCLXResetButton( xWrapped );
+        if ( bApply )
+            xRef = new VCLXApplyButton( xWrapped );
+        if ( bHelp )
+            xRef = new VCLXHelpButton( xWrapped );
+    }
+    return xRef;
+}
+};
diff --git a/layout/source/awt/vclxbutton.hxx b/layout/source/awt/vclxbutton.hxx
new file mode 100644
index 0000000..c3507f9
--- /dev/null
+++ layout/source/awt/vclxbutton.hxx
@@ -0,0 +1,103 @@
+#ifndef LAYOUT_AWT_VCLXBUTTON_HXX
+#define LAYOUT_AWT_VCLXBUTTON_HXX
+
+#include "vclxproxy.hxx"
+
+/* Replacements for broken toolkit/ impls. of ok, cancel, help button, etc. */
+
+class IconButton : public VCLXProxy
+{
+protected:
+    IconButton( css::uno::Reference< css::uno::XInterface > xButton,
+                rtl::OUString aDefaultLabel, const char *pGraphName );
+};
+
+//FIXME: this does not work, see alerthbox.cxx
+//#define VCL_RTTI 1
+#if VCL_RTTI
+class VCLXOKButton;
+::com::sun::star::uno::Type const & SAL_CALL getCppuType(const ::com::sun::star::uno::Reference< VCLXOKButton > *) SAL_THROW(());
+#endif
+
+class VCLXOKButton : public IconButton
+{
+public:
+    VCLXOKButton( css::uno::Reference< css::uno::XInterface > xButton );
+#if VCL_RTTI
+    static ::com::sun::star::uno::Type const& static_type( void * p=0 )
+    {
+        ( void )p;
+        return ::getCppuType( static_cast< ::com::sun::star::uno::Reference< VCLXOKButton > * >( 0 ) );
+    }
+#endif
+};
+
+#if VCL_RTTI
+inline ::com::sun::star::uno::Type const & SAL_CALL getCppuType( com::sun::star::uno::Reference< VCLXOKButton > const *) SAL_THROW( () )
+{
+    return ::cppu::UnoType< VCLXOKButton >::get();
+}
+#endif
+
+inline ::com::sun::star::uno::Type const & cppu_detail_getUnoType( VCLXOKButton const * )
+{
+    static typelib_TypeDescriptionReference *the_type = 0;
+    if ( !the_type )
+    {
+        typelib_static_type_init( &the_type, typelib_TypeClass_INTERFACE, "VCLXOKButton" );
+    }
+    return * reinterpret_cast< ::com::sun::star::uno::Type * >( &the_type );
+}
+
+class VCLXCancelButton : public IconButton
+{
+public:
+    VCLXCancelButton( css::uno::Reference< css::uno::XInterface > xButton );
+};
+
+class VCLXYesButton : public IconButton
+{
+public:
+    VCLXYesButton( css::uno::Reference< css::uno::XInterface > xButton );
+};
+
+class VCLXNoButton : public IconButton
+{
+public:
+    VCLXNoButton( css::uno::Reference< css::uno::XInterface > xButton );
+};
+
+class VCLXRetryButton : public IconButton
+{
+public:
+    VCLXRetryButton( css::uno::Reference< css::uno::XInterface > xButton );
+};
+
+class VCLXIgnoreButton : public IconButton
+{
+public:
+    VCLXIgnoreButton( css::uno::Reference< css::uno::XInterface > xButton );
+};
+
+class VCLXResetButton : public IconButton
+{
+public:
+    VCLXResetButton( css::uno::Reference< css::uno::XInterface > xButton );
+};
+
+class VCLXApplyButton : public IconButton
+{
+public:
+    VCLXApplyButton( css::uno::Reference< css::uno::XInterface > xButton );
+};
+
+class VCLXHelpButton : public IconButton
+{
+public:
+    VCLXHelpButton( css::uno::Reference< css::uno::XInterface > xButton );
+};
+
+
+
+
+#endif // LAYOUT_AWT_VCLXBUTTON_HXX
diff --git a/layout/source/awt/vclxdialog.cxx b/layout/source/awt/vclxdialog.cxx
new file mode 100644
index 0000000..d3ba521
--- /dev/null
+++ layout/source/awt/vclxdialog.cxx
@@ -0,0 +1,355 @@
+#include "vclxdialog.hxx"
+
+#ifndef _TOOLKIT_HELPER_PROPERTY_HXX_
+#include "toolkit/helper/property.hxx"
+#endif
+#ifndef _COM_SUN_STAR_AWT_SCROLLBARORIENTATION_HPP_
+#include <com/sun/star/awt/ScrollBarOrientation.hpp>
+#endif
+
+
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+
+#include <vcl/msgbox.hxx>
+#include <vcl/wrkwin.hxx>
+#include <vcl/syswin.hxx>
+#include <vcl/menu.hxx>
+#include <vcl/dialog.hxx>
+
+#include <vcl/svapp.hxx>
+#include <vcl/syschild.hxx>
+#include <vcl/sysdata.hxx>
+#include <cppuhelper/typeprovider.hxx>
+
+#include <toolkit/awt/vclxmenu.hxx>
+#include <toolkit/helper/macros.hxx>
+
+#include <com/sun/star/lang/SystemDependent.hpp>
+#include <com/sun/star/awt/SystemDependentXWindow.hpp>
+
+#ifndef _TOOLKIT_HELPER_VCLUNOHELPER_HXX_
+#include <toolkit/helper/vclunohelper.hxx>
+#endif
+
+#include <com/sun/star/awt/PosSize.hpp>
+
+#include "../core/timer.hxx"
+
+using namespace toolkit;
+//........................................................................
+namespace layoutimpl
+{
+//........................................................................
+
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::awt;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star;
+
+//====================================================================
+//= VCLXDialog
+//====================================================================
+DBG_NAME( VCLXDialog )
+//--------------------------------------------------------------------
+VCLXDialog::VCLXDialog()
+: VCLXWindow()
+    , VCLXDialog_Base()
+    , Bin()
+    , bRealized( false ), bResizeSafeguard( false )
+{
+    DBG_CTOR( VCLXDialog, NULL );
+
+/*        mxLayoutUnit = uno::Reference< awt::XLayoutUnit >( new LayoutUnit() );
+          assert(mxLayoutUnit.is());*/
+}
+
+//--------------------------------------------------------------------
+VCLXDialog::~VCLXDialog()
+{
+    DBG_DTOR( VCLXDialog, NULL );
+}
+
+//--------------------------------------------------------------------
+IMPLEMENT_2_FORWARD_XINTERFACE2( VCLXDialog, VCLXWindow, Bin, VCLXDialog_Base )
+
+//--------------------------------------------------------------------
+IMPLEMENT_FORWARD_XTYPEPROVIDER2( VCLXDialog, VCLXWindow, VCLXDialog_Base )
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXDialog::dispose( ) throw(RuntimeException)
+{
+    {
+        ::vos::OGuard aGuard( GetMutex() );
+
+        EventObject aDisposeEvent;
+        aDisposeEvent.Source = *this;
+//            maTabListeners.disposeAndClear( aDisposeEvent );
+    }
+
+    VCLXWindow::dispose();
+}
+
+void VCLXDialog::resizedCb()
+{
+    queueResize();
+}
+
+void SAL_CALL VCLXDialog::allocateArea( const css::awt::Rectangle &rArea )
+    throw (css::uno::RuntimeException)
+{
+    awt::Size reqSize = Bin::getMinimumSize();
+    reqSize.Height = getHeightForWidth( rArea.Width );
+
+    if ( !bRealized )
+    {
+        setPosSize( 0, 0, reqSize.Width, reqSize.Height, PosSize::SIZE );
+        bRealized = true;
+        setVisible( true );
+    }
+    else
+    {
+        awt::Size curSize = getSize();
+        if ( reqSize.Width > curSize.Width )
+            setPosSize( 0, 0, reqSize.Width, 0, PosSize::WIDTH );
+        if ( reqSize.Height > curSize.Height )
+            setPosSize( 0, 0, 0, reqSize.Height, PosSize::HEIGHT );
+    }
+
+    awt::Size size = getSize();
+    maAllocation.Width = size.Width;
+    maAllocation.Height = size.Height;
+
+    Bin::allocateArea( maAllocation );
+}
+
+//--------------------------------------------------------------------
+void VCLXDialog::ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent )
+{
+    ::vos::OClearableGuard aGuard( GetMutex() );
+
+    switch ( _rVclWindowEvent.GetId() )
+    {
+        case VCLEVENT_WINDOW_RESIZE:
+            resizedCb();
+        default:
+            aGuard.clear();
+            VCLXWindow::ProcessWindowEvent( _rVclWindowEvent );
+            break;
+    }
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXDialog::setProperty( const ::rtl::OUString& PropertyName, const Any &Value ) throw(RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    if ( GetWindow() )
+    {
+        sal_uInt16 nPropertyId = GetPropertyId( PropertyName );
+        switch ( nPropertyId )
+        {
+            default:
+                VCLXWindow::setProperty( PropertyName, Value );
+        }
+    }
+}
+
+//--------------------------------------------------------------------
+Any SAL_CALL VCLXDialog::getProperty( const ::rtl::OUString& PropertyName ) throw(RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    Any aReturn;
+    if ( GetWindow() )
+    {
+        sal_uInt16 nPropertyId = GetPropertyId( PropertyName );
+        switch ( nPropertyId )
+        {
+            default:
+                aReturn = VCLXWindow::getProperty( PropertyName );
+        }
+    }
+    return aReturn;
+}
+
+//---------------------------------------------------------------------
+
+::com::sun::star::uno::Any VCLXDialog::getWindowHandle( const ::com::sun::star::uno::Sequence< sal_Int8 >& /*ProcessId*/, sal_Int16 SystemType ) throw(::com::sun::star::uno::RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    ::com::sun::star::uno::Any aRet;
+    Window* pWindow = VCLXWindow::GetWindow();
+    if ( pWindow )
+    {
+        const SystemEnvData* pSysData = ((SystemWindow *)pWindow)->GetSystemData();
+        if ( pSysData )
+        {
+#if (defined WNT)
+            if ( SystemType == ::com::sun::star::lang::SystemDependent::SYSTEM_WIN32 )
+            {
+                aRet <<= (sal_Int32)pSysData->hWnd;
+            }
+#elif (defined OS2)
+            if ( SystemType == ::com::sun::star::lang::SystemDependent::SYSTEM_OS2 )
+            {
+                aRet <<= (sal_Int32)pSysData->hWnd;
+            }
+#elif (defined QUARTZ)
+            if ( SystemType == ::com::sun::star::lang::SystemDependent::SYSTEM_MAC )
+            {
+                aRet <<= (sal_IntPtr)pSysData->rWindow;
+            }
+#elif (defined UNX)
+            if ( SystemType == ::com::sun::star::lang::SystemDependent::SYSTEM_XWINDOW )
+            {
+                ::com::sun::star::awt::SystemDependentXWindow aSD;
+                aSD.DisplayPointer = sal::static_int_cast< sal_Int64 >(reinterpret_cast< sal_IntPtr >(pSysData->pDisplay));
+                aSD.WindowHandle = pSysData->aWindow;
+                aRet <<= aSD;
+            }
+#endif
+        }
+    }
+    return aRet;
+}
+
+
+void VCLXDialog::addTopWindowListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XTopWindowListener >& rxListener ) throw(::com::sun::star::uno::RuntimeException)
+{
+#if 1
+    ::vos::OGuard aGuard( GetMutex() );
+
+    GetTopWindowListeners().addInterface( rxListener );
+#else
+#endif
+}
+
+void VCLXDialog::removeTopWindowListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XTopWindowListener >& rxListener ) throw(::com::sun::star::uno::RuntimeException)
+{
+#if 1
+    ::vos::OGuard aGuard( GetMutex() );
+
+    GetTopWindowListeners().removeInterface( rxListener );
+#endif
+}
+
+void VCLXDialog::toFront(  ) throw(::com::sun::star::uno::RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    Window* pWindow = GetWindow();
+    if ( pWindow )
+        ((WorkWindow*)pWindow)->ToTop( TOTOP_RESTOREWHENMIN );
+}
+
+void VCLXDialog::toBack(  ) throw(::com::sun::star::uno::RuntimeException)
+{
+/* Not possible in VCL...
+
+   ::vos::OGuard aGuard( GetMutex() );
+
+   Window* pWindow = GetWindow();
+   if ( pWindow )
+   {
+   ((WorkWindow*)pWindow)->ToBack();
+   }
+*/
+}
+
+void VCLXDialog::setMenuBar( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XMenuBar >& /*rxMenu*/ ) throw(::com::sun::star::uno::RuntimeException)
+{
+#if 0
+    ::vos::OGuard aGuard( GetMutex() );
+
+    SystemWindow* pWindow = (SystemWindow*) GetWindow();
+    if ( pWindow )
+    {
+        pWindow->SetMenuBar( NULL );
+        if ( rxMenu.is() )
+        {
+            VCLXMenu* pMenu = VCLXMenu::GetImplementation( rxMenu );
+            if ( pMenu && !pMenu->IsPopupMenu() )
+                pWindow->SetMenuBar( (MenuBar*) pMenu->GetMenu() );
+        }
+    }
+    mxMenuBar = rxMenu;
+#endif
+}
+
+void VCLXDialog::setTitle( const ::rtl::OUString& Title ) throw(::com::sun::star::uno::RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    Window* pWindow = GetWindow();
+    if ( pWindow )
+        pWindow->SetText( Title );
+}
+
+::rtl::OUString VCLXDialog::getTitle() throw(::com::sun::star::uno::RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    ::rtl::OUString aTitle;
+    Window* pWindow = GetWindow();
+    if ( pWindow )
+        aTitle = pWindow->GetText();
+    return aTitle;
+}
+
+sal_Int16 VCLXDialog::execute() throw(::com::sun::star::uno::RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    sal_Int16 nRet = 0;
+    if ( GetWindow() )
+    {
+        Dialog* pDlg = (Dialog*) GetWindow();
+        Window* pParent = pDlg->GetWindow( WINDOW_PARENTOVERLAP );
+        Window* pOldParent = NULL;
+        if ( pParent && !pParent->IsReallyVisible() )
+        {
+            pOldParent = pDlg->GetParent();
+            Window* pFrame = pDlg->GetWindow( WINDOW_FRAME );
+            if ( pFrame != pDlg )
+                pDlg->SetParent( pFrame );
+        }
+        nRet = pDlg->Execute();
+        if ( pOldParent )
+            pDlg->SetParent( pOldParent );
+    }
+    return nRet;
+}
+
+void VCLXDialog::endDialog( sal_Int32 nResult ) throw(::com::sun::star::uno::RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    if ( nResult == BUTTONID_HELP )
+    {
+        // UGH: c&p button.cxx
+        ::Window* pFocusWin = Application::GetFocusWindow();
+        if ( !pFocusWin )
+            pFocusWin = GetWindow();
+
+        HelpEvent aEvt( pFocusWin->GetPointerPosPixel(), HELPMODE_CONTEXT );
+        pFocusWin->RequestHelp( aEvt );
+        return;
+    }
+
+    Dialog* pDlg = (Dialog*) GetWindow();
+    if ( pDlg )
+        pDlg->EndDialog( nResult );
+}
+
+void VCLXDialog::endExecute() throw(::com::sun::star::uno::RuntimeException)
+{
+    endDialog( 0 );
+}
+
+//........................................................................
+} // namespace toolkit
+//........................................................................
diff --git a/layout/source/awt/vclxdialog.hxx b/layout/source/awt/vclxdialog.hxx
new file mode 100644
index 0000000..f7ecb6d
--- /dev/null
+++ layout/source/awt/vclxdialog.hxx
@@ -0,0 +1,114 @@
+#ifndef LAYOUT_AWT_VCLXDIALOG_HXX
+#define LAYOUT_AWT_VCLXDIALOG_HXX
+
+#ifndef _TOOLKIT_AWT_VCLXWINDOW_HXX_
+#include <toolkit/awt/vclxwindow.hxx>
+#endif
+#ifndef _TOOLKIT_HELPER_LISTENERMULTIPLEXER_HXX_
+#include <toolkit/helper/listenermultiplexer.hxx>
+#endif
+#ifndef _CPPUHELPER_IMPLBASE3_HXX_
+#include <cppuhelper/implbase3.hxx>
+#endif
+#ifndef _COMPHELPER_UNO3_HXX_
+#include <comphelper/uno3.hxx>
+#endif
+
+#include <com/sun/star/awt/XSystemDependentWindowPeer.hpp>
+#include <com/sun/star/awt/XTopWindow.hpp>
+#include <com/sun/star/awt/XMenuBar.hpp>
+#include <com/sun/star/awt/XDialog2.hpp>
+
+#include <com/sun/star/awt/XSimpleTabController.hpp>
+#include "../core/bin.hxx"
+
+#include <com/sun/star/awt/MaxChildrenException.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include "forward.hxx"
+
+using namespace toolkit;
+
+//........................................................................
+namespace layoutimpl
+{
+//........................................................................
+
+//====================================================================
+//= VCLXDialog
+//====================================================================
+
+typedef ::cppu::ImplHelper3 < ::com::sun::star::awt::XTopWindow,
+                              ::com::sun::star::awt::XSystemDependentWindowPeer,
+                              ::com::sun::star::awt::XDialog2
+                              >   VCLXDialog_Base;
+
+class VCLXDialog :public VCLXWindow
+                 ,public VCLXDialog_Base
+                 ,public Bin
+{
+public:
+    VCLXDialog();
+
+    // ::com::sun::star::awt::XDialog2
+    void SAL_CALL endDialog( sal_Int32 nResult ) throw(::com::sun::star::uno::RuntimeException);
+
+protected:
+    ~VCLXDialog( );
+
+    // XInterface
+    DECLARE_XINTERFACE()
+
+    // XTypeProvider
+    DECLARE_XTYPEPROVIDER()
+
+    // XComponent
+    void SAL_CALL dispose( ) throw(::com::sun::star::uno::RuntimeException);
+
+    // VclWindowPeer
+    virtual void SAL_CALL setProperty( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Any SAL_CALL getProperty( const ::rtl::OUString& PropertyName ) throw(::com::sun::star::uno::RuntimeException);
+
+    // VCLXWindow
+    void ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent );
+
+    // ::com::sun::star::awt::XSystemDependendtWindowPeer
+    ::com::sun::star::uno::Any SAL_CALL getWindowHandle( const ::com::sun::star::uno::Sequence< sal_Int8 >& ProcessId, sal_Int16 SystemType ) throw(::com::sun::star::uno::RuntimeException);
+
+    // ::com::sun::star::awt::XTopWindow
+    void SAL_CALL addTopWindowListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XTopWindowListener >& rxListener ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL removeTopWindowListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XTopWindowListener >& rxListener ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL toFront(  ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL toBack(  ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL setMenuBar( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XMenuBar >& xMenu ) throw(::com::sun::star::uno::RuntimeException);
+
+    // ::com::sun::star::awt::XDialog
+    void SAL_CALL setTitle( const ::rtl::OUString& Title ) throw(::com::sun::star::uno::RuntimeException);
+    ::rtl::OUString SAL_CALL getTitle(  ) throw(::com::sun::star::uno::RuntimeException);
+    sal_Int16 SAL_CALL execute(  ) throw(::com::sun::star::uno::RuntimeException);
+    void SAL_CALL endExecute() throw(::com::sun::star::uno::RuntimeException);
+
+    // ::com::sun::star::awt::XLayoutContainer
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+
+    void resizedCb();
+
+    static void     ImplGetPropertyIds( std::list< sal_uInt16 > &/*aIds*/ )
+    {
+    }
+    virtual void    GetPropertyIds( std::list< sal_uInt16 > &aIds ) { return ImplGetPropertyIds( aIds ); }
+
+private:
+    VCLXDialog( const VCLXDialog& );            // never implemented
+    VCLXDialog& operator=( const VCLXDialog& ); // never implemented
+    bool bRealized, bResizeSafeguard;
+
+    css::uno::Reference< css::awt::XLayoutUnit > mxLayoutUnit;
+};
+
+//........................................................................
+} // namespace layoutimpl
+//........................................................................
+
+#endif /*LAYOUT_AWT_VCLXDIALOG_HXX*/
diff --git a/layout/source/awt/vclxfixedline.cxx b/layout/source/awt/vclxfixedline.cxx
new file mode 100644
index 0000000..1d3add6
--- /dev/null
+++ layout/source/awt/vclxfixedline.cxx
@@ -0,0 +1,122 @@
+#include "vclxfixedline.hxx"
+#ifndef _TOOLKIT_HELPER_PROPERTY_HXX_
+#include "toolkit/helper/property.hxx"
+#endif
+
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+#include <vcl/fixed.hxx>
+
+#ifndef _TOOLKIT_HELPER_VCLUNOHELPER_HXX_
+#include <toolkit/helper/vclunohelper.hxx>
+#endif
+
+#include <com/sun/star/awt/PosSize.hpp>
+
+using namespace toolkit;
+//........................................................................
+namespace layoutimpl
+{
+//........................................................................
+
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::awt;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star;
+
+//====================================================================
+//= VCLXFixedLine
+//====================================================================
+DBG_NAME( VCLXFixedLine )
+//--------------------------------------------------------------------
+VCLXFixedLine::VCLXFixedLine()
+: VCLXWindow()
+{
+    DBG_CTOR( VCLXPane, NULL );
+}
+
+//--------------------------------------------------------------------
+VCLXFixedLine::~VCLXFixedLine()
+{
+    DBG_DTOR( VCLXFixedLine, NULL );
+}
+
+//--------------------------------------------------------------------
+//    IMPLEMENT_FORWARD_XINTERFACE1( VCLXFixedLine, VCLXWindow )
+
+//--------------------------------------------------------------------
+IMPLEMENT_FORWARD_XTYPEPROVIDER1( VCLXFixedLine, VCLXWindow )
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXFixedLine::dispose( ) throw(RuntimeException)
+{
+    {
+        ::vos::OGuard aGuard( GetMutex() );
+
+        EventObject aDisposeEvent;
+        aDisposeEvent.Source = *this;
+    }
+
+    VCLXWindow::dispose();
+}
+
+//--------------------------------------------------------------------
+::com::sun::star::awt::Size SAL_CALL VCLXFixedLine::getMinimumSize()
+    throw(::com::sun::star::uno::RuntimeException)
+{
+    return awt::Size( 8, 8 );
+}
+
+//--------------------------------------------------------------------
+void VCLXFixedLine::ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent )
+{
+    ::vos::OClearableGuard aGuard( GetMutex() );
+
+    switch ( _rVclWindowEvent.GetId() )
+    {
+        default:
+            aGuard.clear();
+            VCLXWindow::ProcessWindowEvent( _rVclWindowEvent );
+            break;
+    }
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXFixedLine::setProperty( const ::rtl::OUString& PropertyName, const Any &Value ) throw(RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    if ( GetWindow() )
+    {
+        sal_uInt16 nPropertyId = GetPropertyId( PropertyName );
+        switch ( nPropertyId )
+        {
+            default:
+                VCLXWindow::setProperty( PropertyName, Value );
+        }
+    }
+}
+
+//--------------------------------------------------------------------
+Any SAL_CALL VCLXFixedLine::getProperty( const ::rtl::OUString& PropertyName ) throw(RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    Any aReturn;
+    if ( GetWindow() )
+    {
+        sal_uInt16 nPropertyId = GetPropertyId( PropertyName );
+        switch ( nPropertyId )
+        {
+            default:
+                aReturn = VCLXWindow::getProperty( PropertyName );
+        }
+    }
+    return aReturn;
+}
+
+//........................................................................
+} // namespace toolkit
+//........................................................................
diff --git a/layout/source/awt/vclxfixedline.hxx b/layout/source/awt/vclxfixedline.hxx
new file mode 100644
index 0000000..a66f432
--- /dev/null
+++ layout/source/awt/vclxfixedline.hxx
@@ -0,0 +1,71 @@
+#ifndef LAYOUT_AWT_VCLXFIXEDLINE_HXX
+#define LAYOUT_AWT_VCLXFIXEDLINE_HXX
+
+#ifndef _TOOLKIT_AWT_VCLXWINDOW_HXX_
+#include <toolkit/awt/vclxwindow.hxx>
+#endif
+#ifndef _TOOLKIT_HELPER_LISTENERMULTIPLEXER_HXX_
+#include <toolkit/helper/listenermultiplexer.hxx>
+#endif
+#ifndef _CPPUHELPER_IMPLBASE1_HXX_
+#include <cppuhelper/implbase1.hxx>
+#endif
+#ifndef _COMPHELPER_UNO3_HXX_
+#include <comphelper/uno3.hxx>
+#endif
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include "forward.hxx"
+
+/* We just provide our own FixedLine, because default has no width... */
+
+class FixedLine;
+using namespace toolkit;
+
+//........................................................................
+namespace layoutimpl
+{
+//........................................................................
+
+//====================================================================
+//= VCLXFixedLine
+//====================================================================
+
+class VCLXFixedLine :public VCLXWindow
+{
+public:
+    VCLXFixedLine();
+
+protected:
+    ~VCLXFixedLine( );
+
+    // XInterface
+//        DECLARE_XINTERFACE()
+
+    // XTypeProvider
+    DECLARE_XTYPEPROVIDER()
+
+    // XComponent
+    void SAL_CALL dispose( ) throw(::com::sun::star::uno::RuntimeException);
+
+    virtual ::com::sun::star::awt::Size SAL_CALL getMinimumSize()
+        throw(::com::sun::star::uno::RuntimeException);
+
+    // VclWindowPeer
+    virtual void SAL_CALL setProperty( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Any SAL_CALL getProperty( const ::rtl::OUString& PropertyName ) throw(::com::sun::star::uno::RuntimeException);
+
+    // VCLXWindow
+    void ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent );
+
+private:
+    VCLXFixedLine( const VCLXFixedLine& );            // never implemented
+    VCLXFixedLine& operator=( const VCLXFixedLine& ); // never implemented
+};
+
+//........................................................................
+} // namespacetoolkit
+//........................................................................
+
+#endif /*LAYOUT_AWT_VCLXFIXEDLINE_HXX*/
diff --git a/layout/source/awt/vclxproxy.cxx b/layout/source/awt/vclxproxy.cxx
new file mode 100644
index 0000000..e161c77
--- /dev/null
+++ layout/source/awt/vclxproxy.cxx
@@ -0,0 +1,448 @@
+#include "vclxproxy.hxx"
+
+namespace css = com::sun::star;
+
+// This is a generic proxy class - override it to wrap &
+// extend these interfaces
+// Warning: this is of course not complete ...
+
+VCLXProxy::VCLXProxy( css::uno::Reference< css::uno::XInterface > xObject )
+    : mxDevice( xObject, css::uno::UNO_QUERY )
+    , mxTypeProvider( xObject, css::uno::UNO_QUERY )
+    , mxUnoTunnel( xObject, css::uno::UNO_QUERY )
+    , mxComponent( xObject, css::uno::UNO_QUERY )
+    , mxWindow( xObject, css::uno::UNO_QUERY )
+    , mxWindow2( xObject, css::uno::UNO_QUERY )
+    , mxWindowPeer( xObject, css::uno::UNO_QUERY )
+    , mxVclWindowPeer( xObject, css::uno::UNO_QUERY )
+    , mxLayoutConstrains( xObject, css::uno::UNO_QUERY )
+    , mxView( xObject, css::uno::UNO_QUERY )
+    , mxDockableWindow( xObject, css::uno::UNO_QUERY )
+    , mxAccessible( xObject, css::uno::UNO_QUERY )
+    , mxEventListener( xObject, css::uno::UNO_QUERY )
+    , mxPropertySetInfo( xObject, css::uno::UNO_QUERY )
+    , mxItemEventBroadcaster( xObject, css::uno::UNO_QUERY )
+    , mxImageConsumer( xObject, css::uno::UNO_QUERY )
+    , mxButton( xObject, css::uno::UNO_QUERY )
+    , mxToggleButton( xObject, css::uno::UNO_QUERY )
+{
+}
+
+css::uno::Any SAL_CALL
+VCLXProxy::queryInterface( const css::uno::Type & rType ) throw (css::uno::RuntimeException)
+{
+    css::uno::Any aRet;
+
+#define QI(t,memb) \
+    if (!aRet.hasValue() && memb.is() && rType == t::static_type()) \
+        aRet = css::uno::Any( css::uno::Reference< t >( static_cast<t *>(this) ) )
+
+    // VCLXDevice
+    QI( css::awt::XDevice, mxDevice );
+    QI( css::lang::XTypeProvider, mxTypeProvider );
+    QI( css::lang::XUnoTunnel, mxUnoTunnel );
+
+    // VCLXWindow
+    if (!aRet.hasValue() && mxComponent.is() &&
+        rType == css::lang::XComponent::static_type())
+        aRet = css::uno::Any( css::uno::Reference< css::lang::XComponent >( static_cast<css::awt::XWindow *>(this) ) );
+
+    QI( css::awt::XWindow, mxWindow );
+    QI( css::awt::XWindow2, mxWindow2 );
+    QI( css::awt::XWindowPeer, mxWindowPeer );
+    QI( css::awt::XVclWindowPeer, mxVclWindowPeer );
+    QI( css::awt::XLayoutConstrains, mxLayoutConstrains );
+    QI( css::awt::XView, mxView );
+    QI( css::awt::XDockableWindow, mxDockableWindow );
+    QI( css::accessibility::XAccessible, mxAccessible );
+    QI( css::lang::XEventListener, mxEventListener );
+
+    QI( css::beans::XPropertySetInfo, mxPropertySetInfo );
+    QI( css::awt::XItemEventBroadcaster, mxItemEventBroadcaster );
+    // VCLXImageConsumer
+    QI( css::awt::XImageConsumer, mxImageConsumer );
+    // VCLXButton
+    QI( css::awt::XButton, mxButton );
+    QI( css::awt::XToggleButton, mxToggleButton );
+#undef QI
+
+    if ( !aRet.hasValue() )
+        aRet = OWeakObject::queryInterface( rType );
+    return aRet;
+}
+
+
+// Tons of boilerplate ... urgh [!]
+
+// lang::XComponent
+void VCLXProxy::dispose() throw (css::uno::RuntimeException)
+{
+    mxComponent->dispose();
+}
+void VCLXProxy::addEventListener( const css::uno::Reference< css::lang::XEventListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxComponent->addEventListener( xListener );
+}
+void VCLXProxy::removeEventListener( const css::uno::Reference< css::lang::XEventListener >& aListener ) throw (css::uno::RuntimeException)
+{
+    mxComponent->removeEventListener( aListener );
+}
+
+// awt::XWindowPeer
+css::uno::Reference< css::awt::XToolkit > VCLXProxy::getToolkit() throw (css::uno::RuntimeException)
+{
+    return mxWindowPeer->getToolkit();
+}
+void VCLXProxy::setPointer( const css::uno::Reference< css::awt::XPointer >& Pointer ) throw (css::uno::RuntimeException)
+{
+    mxWindowPeer->setPointer( Pointer );
+}
+void VCLXProxy::setBackground( ::sal_Int32 Color ) throw (css::uno::RuntimeException)
+{
+    mxWindowPeer->setBackground( Color );
+}
+void VCLXProxy::invalidate( ::sal_Int16 Flags ) throw (css::uno::RuntimeException)
+{
+    mxWindowPeer->invalidate( Flags );
+}
+void VCLXProxy::invalidateRect( const css::awt::Rectangle& Rect, ::sal_Int16 Flags ) throw (css::uno::RuntimeException)
+{
+    mxWindowPeer->invalidateRect( Rect, Flags );
+}
+
+// awt::XDevice
+css::uno::Reference< css::awt::XGraphics > VCLXProxy::createGraphics() throw (css::uno::RuntimeException)
+{
+    return mxDevice->createGraphics();
+}
+css::uno::Reference< css::awt::XDevice > VCLXProxy::createDevice( ::sal_Int32 nWidth, ::sal_Int32 nHeight ) throw (css::uno::RuntimeException)
+{
+    return mxDevice->createDevice( nWidth, nHeight );
+}
+css::awt::DeviceInfo VCLXProxy::getInfo() throw (css::uno::RuntimeException)
+{
+    return mxDevice->getInfo();
+}
+css::uno::Sequence< css::awt::FontDescriptor > VCLXProxy::getFontDescriptors() throw (css::uno::RuntimeException)
+{
+    return mxDevice->getFontDescriptors();
+}
+css::uno::Reference< css::awt::XFont > VCLXProxy::getFont( const css::awt::FontDescriptor& aDescriptor ) throw (css::uno::RuntimeException)
+{
+    return mxDevice->getFont( aDescriptor );
+}
+css::uno::Reference< css::awt::XBitmap > VCLXProxy::createBitmap( ::sal_Int32 nX, ::sal_Int32 nY, ::sal_Int32 nWidth, ::sal_Int32 nHeight ) throw (css::uno::RuntimeException)
+{
+    return mxDevice->createBitmap( nX, nY, nWidth, nHeight );
+}
+css::uno::Reference< css::awt::XDisplayBitmap > VCLXProxy::createDisplayBitmap( const css::uno::Reference< css::awt::XBitmap >& Bitmap ) throw (css::uno::RuntimeException)
+{
+    return mxDevice->createDisplayBitmap( Bitmap );
+}
+
+// lang::XTypeProvider
+css::uno::Sequence< css::uno::Type > VCLXProxy::getTypes() throw (css::uno::RuntimeException)
+{
+    return mxTypeProvider->getTypes();
+}
+css::uno::Sequence< ::sal_Int8 > VCLXProxy::getImplementationId() throw (css::uno::RuntimeException)
+{
+    return mxTypeProvider->getImplementationId();
+}
+
+// lang::XUnoTunnel
+::sal_Int64 VCLXProxy::getSomething( const css::uno::Sequence< ::sal_Int8 >& aIdentifier ) throw (css::uno::RuntimeException)
+{
+    return mxUnoTunnel->getSomething( aIdentifier );
+}
+
+// awt::XWindow2
+void VCLXProxy::setOutputSize( const css::awt::Size& aSize ) throw (css::uno::RuntimeException)
+{
+    mxWindow2->setOutputSize( aSize );
+}
+css::awt::Size VCLXProxy::getOutputSize() throw (css::uno::RuntimeException)
+{
+    return mxWindow2->getOutputSize();
+}
+::sal_Bool VCLXProxy::isVisible() throw (css::uno::RuntimeException)
+{
+    return mxWindow2->isVisible();
+}
+::sal_Bool VCLXProxy::isActive() throw (css::uno::RuntimeException)
+{
+    return mxWindow2->isActive();
+}
+::sal_Bool VCLXProxy::isEnabled() throw (css::uno::RuntimeException)
+{
+    return mxWindow2->isEnabled();
+}
+::sal_Bool VCLXProxy::hasFocus() throw (css::uno::RuntimeException)
+{
+    return mxWindow2->hasFocus();
+}
+
+// awt::XWindow
+void VCLXProxy::setPosSize( ::sal_Int32 X, ::sal_Int32 Y, ::sal_Int32 Width, ::sal_Int32 Height, ::sal_Int16 Flags ) throw (css::uno::RuntimeException)
+{
+    mxWindow->setPosSize( X, Y, Width, Height, Flags );
+}
+css::awt::Rectangle VCLXProxy::getPosSize() throw (css::uno::RuntimeException)
+{
+    return mxWindow->getPosSize();
+}
+void VCLXProxy::setVisible( ::sal_Bool Visible ) throw (css::uno::RuntimeException)
+{
+    mxWindow->setVisible( Visible );
+}
+void VCLXProxy::setEnable( ::sal_Bool Enable ) throw (css::uno::RuntimeException)
+{
+    mxWindow->setEnable( Enable );
+}
+void VCLXProxy::setFocus() throw (css::uno::RuntimeException)
+{
+    mxWindow->setFocus();
+}
+void VCLXProxy::addWindowListener( const css::uno::Reference< css::awt::XWindowListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->addWindowListener( xListener );
+}
+void VCLXProxy::removeWindowListener( const css::uno::Reference< css::awt::XWindowListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->removeWindowListener( xListener );
+}
+void VCLXProxy::addFocusListener( const css::uno::Reference< css::awt::XFocusListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->addFocusListener( xListener );
+}
+void VCLXProxy::removeFocusListener( const css::uno::Reference< css::awt::XFocusListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->removeFocusListener( xListener );
+}
+void VCLXProxy::addKeyListener( const css::uno::Reference< css::awt::XKeyListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->addKeyListener( xListener );
+}
+void VCLXProxy::removeKeyListener( const css::uno::Reference< css::awt::XKeyListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->removeKeyListener( xListener );
+}
+void VCLXProxy::addMouseListener( const css::uno::Reference< css::awt::XMouseListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->addMouseListener( xListener );
+}
+void VCLXProxy::removeMouseListener( const css::uno::Reference< css::awt::XMouseListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->removeMouseListener( xListener );
+}
+void VCLXProxy::addMouseMotionListener( const css::uno::Reference< css::awt::XMouseMotionListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->addMouseMotionListener( xListener );
+}
+void VCLXProxy::removeMouseMotionListener( const css::uno::Reference< css::awt::XMouseMotionListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->removeMouseMotionListener( xListener );
+}
+void VCLXProxy::addPaintListener( const css::uno::Reference< css::awt::XPaintListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->addPaintListener( xListener );
+}
+void VCLXProxy::removePaintListener( const css::uno::Reference< css::awt::XPaintListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxWindow->removePaintListener( xListener );
+}
+
+// awt::XVclWindowPeer
+::sal_Bool VCLXProxy::isChild( const css::uno::Reference< css::awt::XWindowPeer >& Peer ) throw (css::uno::RuntimeException)
+{
+    return mxVclWindowPeer->isChild( Peer );
+}
+void VCLXProxy::setDesignMode( ::sal_Bool bOn ) throw (css::uno::RuntimeException)
+{
+    mxVclWindowPeer->setDesignMode( bOn );
+}
+::sal_Bool VCLXProxy::isDesignMode() throw (css::uno::RuntimeException)
+{
+    return mxVclWindowPeer->isDesignMode();
+}
+void VCLXProxy::enableClipSiblings( ::sal_Bool bClip ) throw (css::uno::RuntimeException)
+{
+    mxVclWindowPeer->enableClipSiblings( bClip );
+}
+void VCLXProxy::setForeground( ::sal_Int32 Color ) throw (css::uno::RuntimeException)
+{
+    mxVclWindowPeer->setForeground( Color );
+}
+void VCLXProxy::setControlFont( const css::awt::FontDescriptor& aFont ) throw (css::uno::RuntimeException)
+{
+    mxVclWindowPeer->setControlFont( aFont );
+}
+void VCLXProxy::getStyles( ::sal_Int16 nType, css::awt::FontDescriptor& Font, ::sal_Int32& ForegroundColor, ::sal_Int32& BackgroundColor ) throw (css::uno::RuntimeException)
+{
+    mxVclWindowPeer->getStyles( nType, Font, ForegroundColor, BackgroundColor );
+}
+void VCLXProxy::setProperty( const ::rtl::OUString& PropertyName, const css::uno::Any& Value ) throw (css::uno::RuntimeException)
+{
+    mxVclWindowPeer->setProperty( PropertyName, Value );
+}
+css::uno::Any VCLXProxy::getProperty( const ::rtl::OUString& PropertyName ) throw (css::uno::RuntimeException)
+{
+    return mxVclWindowPeer->getProperty( PropertyName );
+}
+
+// awt::XLayoutConstrains
+css::awt::Size VCLXProxy::getMinimumSize() throw (css::uno::RuntimeException)
+{
+    return mxLayoutConstrains->getMinimumSize();
+}
+css::awt::Size VCLXProxy::getPreferredSize() throw (css::uno::RuntimeException)
+{
+    return mxLayoutConstrains->getPreferredSize();
+}
+css::awt::Size VCLXProxy::calcAdjustedSize( const css::awt::Size& aNewSize ) throw (css::uno::RuntimeException)
+{
+    return mxLayoutConstrains->calcAdjustedSize( aNewSize );
+}
+
+// awt::XView
+::sal_Bool VCLXProxy::setGraphics( const css::uno::Reference< css::awt::XGraphics >& aDevice ) throw (css::uno::RuntimeException)
+{
+    return mxView->setGraphics( aDevice );
+}
+css::uno::Reference< css::awt::XGraphics > VCLXProxy::getGraphics() throw (css::uno::RuntimeException)
+{
+    return mxView->getGraphics();
+}
+css::awt::Size VCLXProxy::getSize() throw (css::uno::RuntimeException)
+{
+    return mxView->getSize();
+}
+void VCLXProxy::draw( ::sal_Int32 nX, ::sal_Int32 nY ) throw (css::uno::RuntimeException)
+{
+    mxView->draw( nX, nY );
+}
+void VCLXProxy::setZoom( float fZoomX, float fZoomY ) throw (css::uno::RuntimeException)
+{
+    mxView->setZoom( fZoomX, fZoomY );
+}
+
+// awt::XDockableWindow
+void VCLXProxy::addDockableWindowListener( const css::uno::Reference< css::awt::XDockableWindowListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxDockableWindow->addDockableWindowListener( xListener );
+}
+void VCLXProxy::removeDockableWindowListener( const css::uno::Reference< css::awt::XDockableWindowListener >& xListener ) throw (css::uno::RuntimeException)
+{
+    mxDockableWindow->removeDockableWindowListener( xListener );
+}
+void VCLXProxy::enableDocking( ::sal_Bool bEnable ) throw (css::uno::RuntimeException)
+{
+    mxDockableWindow->enableDocking( bEnable );
+}
+::sal_Bool VCLXProxy::isFloating() throw (css::uno::RuntimeException)
+{
+    return mxDockableWindow->isFloating();
+}
+void VCLXProxy::setFloatingMode( ::sal_Bool bFloating ) throw (css::uno::RuntimeException)
+{
+    mxDockableWindow->setFloatingMode( bFloating );
+}
+void VCLXProxy::lock() throw (css::uno::RuntimeException)
+{
+    mxDockableWindow->lock();
+}
+void VCLXProxy::unlock() throw (css::uno::RuntimeException)
+{
+    mxDockableWindow->unlock();
+}
+::sal_Bool VCLXProxy::isLocked() throw (css::uno::RuntimeException)
+{
+    return mxDockableWindow->isLocked();
+}
+void VCLXProxy::startPopupMode( const css::awt::Rectangle& WindowRect ) throw (css::uno::RuntimeException)
+{
+    mxDockableWindow->startPopupMode( WindowRect );
+}
+::sal_Bool VCLXProxy::isInPopupMode() throw (css::uno::RuntimeException)
+{
+    return mxDockableWindow->isInPopupMode();
+}
+
+// accessibility::XAccessible
+css::uno::Reference< css::accessibility::XAccessibleContext > VCLXProxy::getAccessibleContext() throw (css::uno::RuntimeException)
+{
+    return mxAccessible->getAccessibleContext();
+}
+
+// lang::XEventListener
+void VCLXProxy::disposing( const css::lang::EventObject& Source ) throw (css::uno::RuntimeException)
+{
+    mxEventListener->disposing( Source );
+}
+
+// beans::XPropertySetInfo
+css::uno::Sequence< css::beans::Property > VCLXProxy::getProperties() throw (css::uno::RuntimeException)
+{
+    return mxPropertySetInfo->getProperties();
+}
+css::beans::Property VCLXProxy::getPropertyByName( const ::rtl::OUString& aName ) throw (css::beans::UnknownPropertyException, css::uno::RuntimeException)
+{
+    return mxPropertySetInfo->getPropertyByName( aName );
+}
+::sal_Bool VCLXProxy::hasPropertyByName( const ::rtl::OUString& Name ) throw (css::uno::RuntimeException)
+{
+    return mxPropertySetInfo->hasPropertyByName( Name );
+}
+
+// awt::XImageConsumer
+void VCLXProxy::init( ::sal_Int32 Width, ::sal_Int32 Height ) throw (css::uno::RuntimeException)
+{
+    mxImageConsumer->init( Width, Height );
+}
+void VCLXProxy::setColorModel( ::sal_Int16 BitCount, const css::uno::Sequence< ::sal_Int32 >& RGBAPal, ::sal_Int32 RedMask, ::sal_Int32 GreenMask, ::sal_Int32 BlueMask, ::sal_Int32 AlphaMask ) throw (css::uno::RuntimeException)
+{
+    mxImageConsumer->setColorModel( BitCount, RGBAPal, RedMask, GreenMask, BlueMask, AlphaMask );
+}
+void VCLXProxy::setPixelsByBytes( ::sal_Int32 nX, ::sal_Int32 nY, ::sal_Int32 nWidth, ::sal_Int32 nHeight, const css::uno::Sequence< ::sal_Int8 >& aProducerData, ::sal_Int32 nOffset, ::sal_Int32 nScanSize ) throw (css::uno::RuntimeException)
+{
+    mxImageConsumer->setPixelsByBytes( nX, nY, nWidth, nHeight, aProducerData, nOffset, nScanSize );
+}
+void VCLXProxy::setPixelsByLongs( ::sal_Int32 nX, ::sal_Int32 nY, ::sal_Int32 nWidth, ::sal_Int32 nHeight, const css::uno::Sequence< ::sal_Int32 >& aProducerData, ::sal_Int32 nOffset, ::sal_Int32 nScanSize ) throw (css::uno::RuntimeException)
+{
+    mxImageConsumer->setPixelsByLongs( nX, nY, nWidth, nHeight, aProducerData, nOffset, nScanSize );
+}
+void VCLXProxy::complete( ::sal_Int32 Status, const css::uno::Reference< css::awt::XImageProducer >& xProducer ) throw (css::uno::RuntimeException)
+{
+    mxImageConsumer->complete( Status, xProducer );
+}
+
+// awt::XButton
+void VCLXProxy::addActionListener( const css::uno::Reference< css::awt::XActionListener >& l ) throw (css::uno::RuntimeException)
+{
+    mxButton->addActionListener( l );
+}
+void VCLXProxy::removeActionListener( const css::uno::Reference< css::awt::XActionListener >& l ) throw (css::uno::RuntimeException)
+{
+    mxButton->removeActionListener( l );
+}
+void VCLXProxy::setLabel( const ::rtl::OUString& Label ) throw (css::uno::RuntimeException)
+{
+    if ( mxButton.is() )
+        mxButton->setLabel( Label );
+}
+void VCLXProxy::setActionCommand( const ::rtl::OUString& Command ) throw (css::uno::RuntimeException)
+{
+    mxButton->setActionCommand( Command );
+}
+
+// awt::XItemEventBroadcaster
+void VCLXProxy::addItemListener( const css::uno::Reference< css::awt::XItemListener >& l ) throw (css::uno::RuntimeException)
+{
+    if ( mxItemEventBroadcaster.is() )
+        mxItemEventBroadcaster->addItemListener( l );
+}
+void VCLXProxy::removeItemListener( const css::uno::Reference< css::awt::XItemListener >& l ) throw (css::uno::RuntimeException)
+{
+    if ( mxItemEventBroadcaster.is() )
+        mxItemEventBroadcaster->removeItemListener( l );
+}
diff --git a/layout/source/awt/vclxproxy.hxx b/layout/source/awt/vclxproxy.hxx
new file mode 100644
index 0000000..7f66c03
--- /dev/null
+++ layout/source/awt/vclxproxy.hxx
@@ -0,0 +1,206 @@
+#ifndef LAYOUT_AWT_VCLXPROXY_HXX
+#define LAYOUT_AWT_VCLXPROXY_HXX
+
+#include <com/sun/star/awt/XDevice.hpp>
+#include <com/sun/star/lang/XTypeProvider.hpp>
+#include <com/sun/star/lang/XUnoTunnel.hpp>
+
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/awt/XWindow2.hpp>
+#include <com/sun/star/awt/XVclWindowPeer.hpp>
+#include <com/sun/star/awt/XLayoutConstrains.hpp>
+#include <com/sun/star/awt/XView.hpp>
+#include <com/sun/star/awt/XPointer.hpp>
+#include <com/sun/star/awt/XGraphics.hpp>
+#include <com/sun/star/beans/XPropertyChangeListener.hpp>
+#include <com/sun/star/beans/XPropertySetInfo.hpp>
+#include <com/sun/star/accessibility/XAccessible.hpp>
+#include <com/sun/star/accessibility/XAccessibleContext.hpp>
+#include <com/sun/star/awt/XDockableWindow.hpp>
+
+#include <com/sun/star/awt/XImageConsumer.hpp>
+#include <com/sun/star/awt/XButton.hpp>
+#include <com/sun/star/awt/XToggleButton.hpp>
+
+#include <cppuhelper/weak.hxx>
+
+namespace css = com::sun::star;
+
+// This is a generic proxy class - override it to wrap &
+// extend these interfaces
+// Warning: this is of course not complete ...
+class VCLXProxy :
+    // VCLXDevice
+    public css::awt::XDevice,
+    public css::lang::XTypeProvider,
+    public css::lang::XUnoTunnel,
+    // VCLXWindow
+    public css::awt::XWindow2,
+    public css::awt::XVclWindowPeer,
+    public css::awt::XLayoutConstrains,
+    public css::awt::XView,
+    public css::awt::XDockableWindow,
+    public css::accessibility::XAccessible,
+    public css::lang::XEventListener,
+    public css::beans::XPropertySetInfo,
+    // VCLXImageConsumer
+    public css::awt::XImageConsumer,
+    // VCLXButton
+    public css::awt::XButton,
+    public css::awt::XToggleButton,
+    public ::cppu::OWeakObject
+{
+    // VCLXDevice
+    css::uno::Reference< css::awt::XDevice > mxDevice;
+    css::uno::Reference< css::lang::XTypeProvider > mxTypeProvider;
+    css::uno::Reference< css::lang::XUnoTunnel > mxUnoTunnel;
+
+    // VCLXWindow
+    css::uno::Reference< css::lang::XComponent > mxComponent;
+    css::uno::Reference< css::awt::XWindow > mxWindow;
+    css::uno::Reference< css::awt::XWindow2 > mxWindow2;
+    css::uno::Reference< css::awt::XWindowPeer > mxWindowPeer;
+    css::uno::Reference< css::awt::XVclWindowPeer > mxVclWindowPeer;
+    css::uno::Reference< css::awt::XLayoutConstrains > mxLayoutConstrains;
+    css::uno::Reference< css::awt::XView > mxView;
+    css::uno::Reference< css::awt::XDockableWindow > mxDockableWindow;
+    css::uno::Reference< css::accessibility::XAccessible > mxAccessible;
+    css::uno::Reference< css::lang::XEventListener > mxEventListener;
+    css::uno::Reference< css::beans::XPropertySetInfo > mxPropertySetInfo;
+    css::uno::Reference< css::awt::XItemEventBroadcaster > mxItemEventBroadcaster;
+
+    // VCLXImageConsumer
+    css::uno::Reference< css::awt::XImageConsumer > mxImageConsumer;
+
+    // VCLXButton
+    css::uno::Reference< css::awt::XButton > mxButton;
+    css::uno::Reference< css::awt::XToggleButton > mxToggleButton;
+
+public:
+    VCLXProxy( css::uno::Reference< css::uno::XInterface > xObject );
+
+    // XInterface
+    virtual void SAL_CALL acquire() throw() { ::cppu::OWeakObject::acquire(); }
+    virtual void SAL_CALL release() throw() { ::cppu::OWeakObject::release(); }
+    virtual css::uno::Any SAL_CALL queryInterface( const css::uno::Type & rType ) throw (css::uno::RuntimeException);
+
+    // lang::XComponent
+    virtual void SAL_CALL dispose() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL addEventListener( const css::uno::Reference< css::lang::XEventListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeEventListener( const css::uno::Reference< css::lang::XEventListener >& aListener ) throw (css::uno::RuntimeException);
+
+    // awt::XWindowPeer
+    virtual css::uno::Reference< css::awt::XToolkit > SAL_CALL getToolkit() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setPointer( const css::uno::Reference< css::awt::XPointer >& Pointer ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setBackground( ::sal_Int32 Color ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL invalidate( ::sal_Int16 Flags ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL invalidateRect( const css::awt::Rectangle& Rect, ::sal_Int16 Flags ) throw (css::uno::RuntimeException);
+
+    // awt::XDevice
+    virtual css::uno::Reference< css::awt::XGraphics > SAL_CALL createGraphics() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::awt::XDevice > SAL_CALL createDevice( ::sal_Int32 nWidth, ::sal_Int32 nHeight ) throw (css::uno::RuntimeException);
+    virtual css::awt::DeviceInfo SAL_CALL getInfo() throw (css::uno::RuntimeException);
+    virtual css::uno::Sequence< css::awt::FontDescriptor > SAL_CALL getFontDescriptors() throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::awt::XFont > SAL_CALL getFont( const css::awt::FontDescriptor& aDescriptor ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::awt::XBitmap > SAL_CALL createBitmap( ::sal_Int32 nX, ::sal_Int32 nY, ::sal_Int32 nWidth, ::sal_Int32 nHeight ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::awt::XDisplayBitmap > SAL_CALL createDisplayBitmap( const css::uno::Reference< css::awt::XBitmap >& Bitmap ) throw (css::uno::RuntimeException);
+
+    // lang::XTypeProvider
+    virtual css::uno::Sequence< css::uno::Type > SAL_CALL getTypes() throw (css::uno::RuntimeException);
+    virtual css::uno::Sequence< ::sal_Int8 > SAL_CALL getImplementationId() throw (css::uno::RuntimeException);
+
+    // lang::XUnoTunnel
+    virtual ::sal_Int64 SAL_CALL getSomething( const css::uno::Sequence< ::sal_Int8 >& aIdentifier ) throw (css::uno::RuntimeException);
+
+    // awt::XWindow2
+    virtual void SAL_CALL setOutputSize( const css::awt::Size& aSize ) throw (css::uno::RuntimeException);
+    virtual css::awt::Size SAL_CALL getOutputSize() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL isVisible() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL isActive() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL isEnabled() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL hasFocus() throw (css::uno::RuntimeException);
+
+    // awt::XWindow
+    virtual void SAL_CALL setPosSize( ::sal_Int32 X, ::sal_Int32 Y, ::sal_Int32 Width, ::sal_Int32 Height, ::sal_Int16 Flags ) throw (css::uno::RuntimeException);
+    virtual css::awt::Rectangle SAL_CALL getPosSize() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setVisible( ::sal_Bool Visible ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setEnable( ::sal_Bool Enable ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setFocus() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL addWindowListener( const css::uno::Reference< css::awt::XWindowListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeWindowListener( const css::uno::Reference< css::awt::XWindowListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL addFocusListener( const css::uno::Reference< css::awt::XFocusListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeFocusListener( const css::uno::Reference< css::awt::XFocusListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL addKeyListener( const css::uno::Reference< css::awt::XKeyListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeKeyListener( const css::uno::Reference< css::awt::XKeyListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL addMouseListener( const css::uno::Reference< css::awt::XMouseListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeMouseListener( const css::uno::Reference< css::awt::XMouseListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL addMouseMotionListener( const css::uno::Reference< css::awt::XMouseMotionListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeMouseMotionListener( const css::uno::Reference< css::awt::XMouseMotionListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL addPaintListener( const css::uno::Reference< css::awt::XPaintListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removePaintListener( const css::uno::Reference< css::awt::XPaintListener >& xListener ) throw (css::uno::RuntimeException);
+
+    // awt::XVclWindowPeer
+    virtual ::sal_Bool SAL_CALL isChild( const css::uno::Reference< css::awt::XWindowPeer >& Peer ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setDesignMode( ::sal_Bool bOn ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL isDesignMode() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL enableClipSiblings( ::sal_Bool bClip ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setForeground( ::sal_Int32 Color ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setControlFont( const css::awt::FontDescriptor& aFont ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL getStyles( ::sal_Int16 nType, css::awt::FontDescriptor& Font, ::sal_Int32& ForegroundColor, ::sal_Int32& BackgroundColor ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setProperty( const ::rtl::OUString& PropertyName, const css::uno::Any& Value ) throw (css::uno::RuntimeException);
+    virtual css::uno::Any SAL_CALL getProperty( const ::rtl::OUString& PropertyName ) throw (css::uno::RuntimeException);
+
+    // awt::XLayoutConstrains
+    virtual css::awt::Size SAL_CALL getMinimumSize() throw (css::uno::RuntimeException);
+    virtual css::awt::Size SAL_CALL getPreferredSize() throw (css::uno::RuntimeException);
+    virtual css::awt::Size SAL_CALL calcAdjustedSize( const css::awt::Size& aNewSize ) throw (css::uno::RuntimeException);
+
+    // awt::XView
+    virtual ::sal_Bool SAL_CALL setGraphics( const css::uno::Reference< css::awt::XGraphics >& aDevice ) throw (css::uno::RuntimeException);
+    virtual css::uno::Reference< css::awt::XGraphics > SAL_CALL getGraphics() throw (css::uno::RuntimeException);
+    virtual css::awt::Size SAL_CALL getSize() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL draw( ::sal_Int32 nX, ::sal_Int32 nY ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setZoom( float fZoomX, float fZoomY ) throw (css::uno::RuntimeException);
+
+    // awt::XDockableWindow
+    virtual void SAL_CALL addDockableWindowListener( const css::uno::Reference< css::awt::XDockableWindowListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeDockableWindowListener( const css::uno::Reference< css::awt::XDockableWindowListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL enableDocking( ::sal_Bool bEnable ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL isFloating() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setFloatingMode( ::sal_Bool bFloating ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL lock() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL unlock() throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL isLocked() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL startPopupMode( const css::awt::Rectangle& WindowRect ) throw (css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL isInPopupMode() throw (css::uno::RuntimeException);
+
+    // accessibility::XAccessible
+    virtual css::uno::Reference< css::accessibility::XAccessibleContext > SAL_CALL getAccessibleContext() throw (css::uno::RuntimeException);
+
+    // lang::XEventListener
+    virtual void SAL_CALL disposing( const css::lang::EventObject& Source ) throw (css::uno::RuntimeException);
+
+    // beans::XPropertySetInfo
+    virtual css::uno::Sequence< css::beans::Property > SAL_CALL getProperties() throw (css::uno::RuntimeException);
+    virtual css::beans::Property SAL_CALL getPropertyByName( const ::rtl::OUString& aName ) throw (css::beans::UnknownPropertyException, css::uno::RuntimeException);
+    virtual ::sal_Bool SAL_CALL hasPropertyByName( const ::rtl::OUString& Name ) throw (css::uno::RuntimeException);
+
+    // awt::XImageConsumer
+    virtual void SAL_CALL init( ::sal_Int32 Width, ::sal_Int32 Height ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setColorModel( ::sal_Int16 BitCount, const css::uno::Sequence< ::sal_Int32 >& RGBAPal, ::sal_Int32 RedMask, ::sal_Int32 GreenMask, ::sal_Int32 BlueMask, ::sal_Int32 AlphaMask ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setPixelsByBytes( ::sal_Int32 nX, ::sal_Int32 nY, ::sal_Int32 nWidth, ::sal_Int32 nHeight, const css::uno::Sequence< ::sal_Int8 >& aProducerData, ::sal_Int32 nOffset, ::sal_Int32 nScanSize ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setPixelsByLongs( ::sal_Int32 nX, ::sal_Int32 nY, ::sal_Int32 nWidth, ::sal_Int32 nHeight, const css::uno::Sequence< ::sal_Int32 >& aProducerData, ::sal_Int32 nOffset, ::sal_Int32 nScanSize ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL complete( ::sal_Int32 Status, const css::uno::Reference< css::awt::XImageProducer >& xProducer ) throw (css::uno::RuntimeException);
+
+    // awt::XButton
+    virtual void SAL_CALL addActionListener( const css::uno::Reference< css::awt::XActionListener >& l ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeActionListener( const css::uno::Reference< css::awt::XActionListener >& l ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setLabel( const ::rtl::OUString& Label ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL setActionCommand( const ::rtl::OUString& Command ) throw (css::uno::RuntimeException);
+
+    // awt::XItemEventBroadcaster
+    virtual void SAL_CALL addItemListener( const css::uno::Reference< css::awt::XItemListener >& l ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeItemListener( const css::uno::Reference< css::awt::XItemListener >& l ) throw (css::uno::RuntimeException);
+};
+
+#endif // LAYOUT_AWT_VCLXPROXY_HXX
diff --git a/layout/source/awt/vclxscroller.cxx b/layout/source/awt/vclxscroller.cxx
new file mode 100644
index 0000000..b279357
--- /dev/null
+++ layout/source/awt/vclxscroller.cxx
@@ -0,0 +1,204 @@
+#include "vclxscroller.hxx"
+#ifndef _TOOLKIT_HELPER_PROPERTY_HXX_
+#include "toolkit/helper/property.hxx"
+#endif
+#ifndef _COM_SUN_STAR_AWT_SCROLLBARORIENTATION_HPP_
+#include <com/sun/star/awt/ScrollBarOrientation.hpp>
+#endif
+
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+#include <vcl/scrbar.hxx>
+
+#ifndef _TOOLKIT_HELPER_VCLUNOHELPER_HXX_
+#include <toolkit/helper/vclunohelper.hxx>
+#endif
+
+#include <com/sun/star/awt/PosSize.hpp>
+
+#include <sal/macros.h>
+#include <assert.h>
+
+//#include <vcl/fixed.h>
+
+using namespace toolkit;
+//........................................................................
+namespace layoutimpl
+{
+//........................................................................
+
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::awt;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star;
+
+//====================================================================
+//= VCLXScroller
+//====================================================================
+DBG_NAME( VCLXScroller )
+//--------------------------------------------------------------------
+VCLXScroller::VCLXScroller( )
+: VCLXWindow()
+    , Bin()
+{
+    DBG_CTOR( VCLXScroller, NULL );
+    mpHorScrollBar = mpVerScrollBar = 0;
+}
+
+//--------------------------------------------------------------------
+VCLXScroller::~VCLXScroller()
+{
+    DBG_DTOR( VCLXScroller, NULL );
+}
+
+//--------------------------------------------------------------------
+IMPLEMENT_2_FORWARD_XINTERFACE1( VCLXScroller, VCLXWindow, Container )
+
+//--------------------------------------------------------------------
+IMPLEMENT_FORWARD_XTYPEPROVIDER1( VCLXScroller, VCLXWindow )
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXScroller::dispose( ) throw(RuntimeException)
+{
+    {
+        ::vos::OGuard aGuard( GetMutex() );
+
+        EventObject aDisposeEvent;
+        aDisposeEvent.Source = *this;
+//            maTabListeners.disposeAndClear( aDisposeEvent );
+    }
+
+    VCLXWindow::dispose();
+}
+
+//--------------------------------------------------------------------
+void VCLXScroller::ensureScrollBars()
+{
+
+    if ( !mpVerScrollBar )
+    {
+        mpVerScrollBar = new ScrollBar( GetWindow() , WB_VERT );
+        mpVerScrollBar->SetLineSize( 4 );
+        mpVerScrollBar->SetPageSize( 15 );
+        mpVerScrollBar->Show();
+        mpVerScrollBar->SetScrollHdl( LINK( this, VCLXScroller, ScrollHdl ) );
+    }
+    if ( !mpHorScrollBar )
+    {
+        mpHorScrollBar = new ScrollBar( GetWindow() , WB_HORZ );
+        mpHorScrollBar->SetLineSize( 4 );
+        mpHorScrollBar->SetPageSize( 15 );
+        mpHorScrollBar->Show();
+        mpHorScrollBar->SetScrollHdl( LINK( this, VCLXScroller, ScrollHdl ) );
+    } //        mpContent = new FixedImage( this, ImplGetWinBits( WindowAttributes, 0 ) );
+
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXScroller::allocateArea(
+    const ::com::sun::star::awt::Rectangle &rArea )
+    throw (::com::sun::star::uno::RuntimeException)
+{
+    ensureScrollBars();        // shouldn't be needed
+
+    maAllocation = rArea;
+    setPosSize( rArea.X, rArea.Y, rArea.Width, rArea.Height, PosSize::POSSIZE );
+
+    mpHorScrollBar->SetRangeMin( 0 );
+    mpHorScrollBar->SetRangeMax( SAL_MAX( maChildRequisition.Width - rArea.Width, 0 ) );
+    mpVerScrollBar->SetRangeMin( 0 );
+    mpVerScrollBar->SetRangeMax( SAL_MAX( maChildRequisition.Height - rArea.Height, 0 ) );
+
+    int thumbX = mpHorScrollBar->GetThumbPos();
+    int thumbY = mpVerScrollBar->GetThumbPos();
+    int thumbWidth = mpVerScrollBar->GetSizePixel().getWidth();
+    int thumbHeight = mpHorScrollBar->GetSizePixel().getHeight();
+
+    mpHorScrollBar->SetPosSizePixel( rArea.X, rArea.Y + rArea.Height - thumbHeight - 2,
+                                     rArea.Width - thumbWidth, thumbHeight );
+    mpVerScrollBar->SetPosSizePixel( rArea.X + rArea.Width - thumbWidth - 2, rArea.Y-2,
+                                     thumbWidth, rArea.Height - thumbHeight );
+
+    awt::Rectangle childRect( rArea.X - thumbX, rArea.Y - thumbY,
+                              SAL_MAX( maChildRequisition.Width, rArea.Width ) - thumbWidth - 4,
+                              SAL_MAX( maChildRequisition.Height, rArea.Height ) - thumbHeight - 4 );
+    if ( mxChild.is() )
+        allocateChildAt( mxChild, childRect );
+}
+
+//--------------------------------------------------------------------
+#define MAX_CHILD_REQ 40
+::com::sun::star::awt::Size SAL_CALL VCLXScroller::getMinimumSize()
+    throw(::com::sun::star::uno::RuntimeException)
+{
+    ensureScrollBars();
+    assert( mpHorScrollBar && mpVerScrollBar );
+    awt::Size childSize = Bin::getMinimumSize();
+    int thumbWidth = mpVerScrollBar->GetSizePixel().getWidth();
+    int thumbHeight = mpHorScrollBar->GetSizePixel().getHeight();
+    maRequisition = awt::Size(
+        SAL_MIN( MAX_CHILD_REQ, childSize.Width ) + thumbWidth,
+        SAL_MIN( MAX_CHILD_REQ, childSize.Height ) + thumbHeight );
+    return maRequisition;
+}
+
+//--------------------------------------------------------------------
+void VCLXScroller::ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent )
+{
+    ::vos::OClearableGuard aGuard( GetMutex() );
+
+    switch ( _rVclWindowEvent.GetId() )
+    {
+        default:
+            aGuard.clear();
+            VCLXWindow::ProcessWindowEvent( _rVclWindowEvent );
+            break;
+    }
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXScroller::setProperty( const ::rtl::OUString& PropertyName, const Any &Value ) throw(RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    if ( GetWindow() )
+    {
+        sal_uInt16 nPropertyId = GetPropertyId( PropertyName );
+        switch ( nPropertyId )
+        {
+            default:
+                VCLXWindow::setProperty( PropertyName, Value );
+        }
+    }
+}
+
+//--------------------------------------------------------------------
+Any SAL_CALL VCLXScroller::getProperty( const ::rtl::OUString& PropertyName ) throw(RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    Any aReturn;
+    if ( GetWindow() )
+    {
+        sal_uInt16 nPropertyId = GetPropertyId( PropertyName );
+        switch ( nPropertyId )
+        {
+            default:
+                aReturn = VCLXWindow::getProperty( PropertyName );
+        }
+    }
+    return aReturn;
+}
+
+IMPL_LINK( VCLXScroller, ScrollHdl, ScrollBar *, pScrollBar )
+{
+    (void) pScrollBar;
+    forceRecalc();
+    return 0;
+}
+
+//........................................................................
+} // namespace toolkit
+//........................................................................
diff --git a/layout/source/awt/vclxscroller.hxx b/layout/source/awt/vclxscroller.hxx
new file mode 100644
index 0000000..a74f9dd
--- /dev/null
+++ layout/source/awt/vclxscroller.hxx
@@ -0,0 +1,84 @@
+#ifndef LAYOUT_AWT_VCLXSCROLLER_HXX
+#define LAYOUT_AWT_VCLXSCROLLER_HXX
+
+#ifndef _TOOLKIT_AWT_VCLXWINDOW_HXX_
+#include <toolkit/awt/vclxwindow.hxx>
+#endif
+#ifndef _TOOLKIT_HELPER_LISTENERMULTIPLEXER_HXX_
+#include <toolkit/helper/listenermultiplexer.hxx>
+#endif
+#ifndef _CPPUHELPER_IMPLBASE1_HXX_
+#include <cppuhelper/implbase1.hxx>
+#endif
+#ifndef _COMPHELPER_UNO3_HXX_
+#include <comphelper/uno3.hxx>
+#endif
+#include "../core/bin.hxx"
+
+#include <com/sun/star/awt/MaxChildrenException.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include "forward.hxx"
+
+class ScrollBar;
+class FixedImage;
+using namespace toolkit;
+
+//........................................................................
+namespace layoutimpl
+{
+//........................................................................
+
+//====================================================================
+//= VCLXScroller
+//====================================================================
+
+class VCLXScroller :public VCLXWindow
+                   ,public Bin
+{
+public:
+    VCLXScroller( );
+
+protected:
+    ~VCLXScroller( );
+
+    // XInterface
+    DECLARE_XINTERFACE()
+
+    // XTypeProvider
+    DECLARE_XTYPEPROVIDER()
+
+    // XComponent
+    void SAL_CALL dispose( ) throw(::com::sun::star::uno::RuntimeException);
+
+    // ::com::sun::star::awt::XLayoutContainer
+    virtual void SAL_CALL allocateArea( const ::com::sun::star::awt::Rectangle &rArea )
+        throw (::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::awt::Size SAL_CALL getMinimumSize()
+        throw(::com::sun::star::uno::RuntimeException);
+
+    // VclWindowPeer
+    virtual void SAL_CALL setProperty( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Any SAL_CALL getProperty( const ::rtl::OUString& PropertyName ) throw(::com::sun::star::uno::RuntimeException);
+
+    // VCLXWindow
+    void ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent );
+
+private:
+    VCLXScroller( const VCLXScroller& );            // never implemented
+    VCLXScroller& operator=( const VCLXScroller& ); // never implemented
+
+    // because the underlying window is only setup-ed after construction, init
+    // scrollbars at play-time
+    void ensureScrollBars();
+
+    FixedImage *mpContent;  // dummy
+    ScrollBar *mpHorScrollBar, *mpVerScrollBar;
+    DECL_LINK( ScrollHdl, ScrollBar* );
+};
+
+//........................................................................
+} // namespacetoolkit
+//........................................................................
+
+#endif /*LAYOUT_AWT_VCLXSCROLLER_HXX*/
diff --git a/layout/source/awt/vclxsplitter.cxx b/layout/source/awt/vclxsplitter.cxx
new file mode 100644
index 0000000..25e740b
--- /dev/null
+++ layout/source/awt/vclxsplitter.cxx
@@ -0,0 +1,319 @@
+#include "vclxsplitter.hxx"
+#ifndef _TOOLKIT_HELPER_PROPERTY_HXX_
+#include "toolkit/helper/property.hxx"
+#endif
+
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+#include <vcl/split.hxx>
+
+#ifndef _TOOLKIT_HELPER_VCLUNOHELPER_HXX_
+#include <toolkit/helper/vclunohelper.hxx>
+#endif
+
+#include <com/sun/star/awt/PosSize.hpp>
+
+#include <assert.h>
+#include <sal/macros.h>
+
+using namespace toolkit;
+//........................................................................
+namespace layoutimpl
+{
+//........................................................................
+
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::awt;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star;
+
+class SplitterChildProps : public PropHelper
+{
+public:
+    SplitterChildProps( VCLXSplitter::ChildData *pData )
+    {
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "Shrink" ),
+                 ::getCppuType( static_cast< const rtl::OUString* >( NULL ) ),
+                 &(pData->bShrink) );
+    }
+    PROPHELPER_SET_INFO
+};
+
+//====================================================================
+//= VCLXSplitter
+//====================================================================
+DBG_NAME( VCLXSplitter )
+//--------------------------------------------------------------------
+VCLXSplitter::VCLXSplitter( bool bHorizontal )
+: VCLXWindow()
+    , Container()
+{
+    DBG_CTOR( VCLXSplitter, NULL );
+    mnHandleRatio = 0.5;
+    mbHandlePressed = false;
+    mbHorizontal = bHorizontal;
+    mpSplitter = NULL;
+}
+
+//--------------------------------------------------------------------
+VCLXSplitter::~VCLXSplitter()
+{
+    DBG_DTOR( VCLXSplitter, NULL );
+}
+
+//--------------------------------------------------------------------
+IMPLEMENT_2_FORWARD_XINTERFACE1( VCLXSplitter, VCLXWindow, Container )
+
+//--------------------------------------------------------------------
+IMPLEMENT_FORWARD_XTYPEPROVIDER1( VCLXSplitter, VCLXWindow )
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXSplitter::dispose( ) throw(RuntimeException)
+{
+    {
+        ::vos::OGuard aGuard( GetMutex() );
+
+        EventObject aDisposeEvent;
+        aDisposeEvent.Source = *this;
+//            maTabListeners.disposeAndClear( aDisposeEvent );
+    }
+
+    VCLXWindow::dispose();
+}
+
+//--------------------------------------------------------------------
+void VCLXSplitter::ensureSplitter()
+{
+    if ( !mpSplitter )
+    {
+        mpSplitter = new Splitter( GetWindow() , mbHorizontal ? WB_HORZ : WB_VERT );
+        mpSplitter->Show();
+        mpSplitter->SetEndSplitHdl( LINK( this, VCLXSplitter, HandleMovedHdl ) );
+    }
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXSplitter::addChild(
+    const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XLayoutConstrains > &xChild )
+    throw (::com::sun::star::uno::RuntimeException, ::com::sun::star::awt::MaxChildrenException)
+{
+    ChildData *pData;
+    if ( ! maChildren[ 0 ].xChild.is() )
+        pData = &maChildren[ 0 ];
+    else if ( ! maChildren[ 1 ].xChild.is() )
+        pData = &maChildren[ 1 ];
+    else
+        throw css::awt::MaxChildrenException();
+
+    if ( xChild.is() )
+    {
+        pData->xChild = xChild;
+        setChildParent( xChild );
+        queueResize();
+    }
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXSplitter::removeChild( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XLayoutConstrains > &xChild )
+    throw (::com::sun::star::uno::RuntimeException)
+{
+    ChildData *pData = 0;
+    if ( maChildren[ 0 ].xChild == xChild )
+        pData = &maChildren[ 0 ];
+    else if ( maChildren[ 1 ].xChild == xChild )
+        pData = &maChildren[ 1 ];
+
+    if ( pData )
+    {
+        pData->xChild = uno::Reference< awt::XLayoutConstrains >();
+        unsetChildParent( xChild );
+        queueResize();
+    }
+}
+
+//--------------------------------------------------------------------
+::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference
+                                 < ::com::sun::star::awt::XLayoutConstrains > > SAL_CALL VCLXSplitter::getChildren()
+    throw (::com::sun::star::uno::RuntimeException)
+{
+    int childLen = (maChildren[ 0 ].xChild.is() ? 1: 0) +
+        (maChildren[ 1 ].xChild.is() ? 1: 0);
+    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > childrenSeq( childLen );
+    int i = 0;
+    if ( maChildren[ 0 ].xChild.is() )
+        childrenSeq[ i++ ] = maChildren[ 0 ].xChild;
+    if ( maChildren[ 1 ].xChild.is() )
+        childrenSeq[ i++ ] = maChildren[ 1 ].xChild;
+    return childrenSeq;
+}
+
+//--------------------------------------------------------------------
+uno::Reference< beans::XPropertySet > SAL_CALL
+VCLXSplitter::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException)
+{
+    ChildData *pData = 0;
+    if ( maChildren[ 0 ].xChild == xChild )
+        pData = &maChildren[ 0 ];
+    else if ( maChildren[ 1 ].xChild == xChild )
+        pData = &maChildren[ 1 ];
+
+    if ( pData )
+    {
+        if ( !pData->xProps.is() )
+        {
+            PropHelper *pProps = new SplitterChildProps( pData );
+            pProps->setChangeListener( this );
+            pData->xProps = pProps;
+        }
+        return pData->xProps;
+    }
+    return uno::Reference< beans::XPropertySet >();
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXSplitter::allocateArea(
+    const ::com::sun::star::awt::Rectangle &rArea )
+    throw (::com::sun::star::uno::RuntimeException)
+{
+    ensureSplitter();  // shouldn't be needed...
+    getMinimumSize();
+    int splitDiff;
+    if ( mbHorizontal )
+        splitDiff = rArea.Width - maAllocation.Width;
+    else
+        splitDiff = rArea.Height - maAllocation.Height;
+
+    assert(mpSplitter);
+    if ( splitDiff )
+        mpSplitter->SetSplitPosPixel( mpSplitter->GetSplitPosPixel() + splitDiff/2 );
+
+    maAllocation = rArea;
+    int width = mbHorizontal ? rArea.Width : rArea.Height;
+    int splitLen = 2;
+    int splitPos = mpSplitter->GetSplitPosPixel();
+    setPosSize( rArea.X, rArea.Y, rArea.Width, rArea.Height, PosSize::POSSIZE );
+    if ( mbHorizontal )
+        mpSplitter->SetPosSizePixel( splitPos, 0, splitLen, rArea.Height, PosSize::POSSIZE );
+    else
+        mpSplitter->SetPosSizePixel( 0, splitPos, rArea.Width, splitLen, PosSize::POSSIZE );
+    mpSplitter->SetDragRectPixel( ::Rectangle( 0, 0, rArea.Width, rArea.Height ) );
+    int leftWidth = splitPos;
+    int rightWidth = width - splitPos;
+
+    if ( maChildren[ 0 ].xChild.is() )
+    {
+        awt::Rectangle childRect( 0, 0, rArea.Width, rArea.Height );
+
+        if ( mbHorizontal )
+            childRect.Width = leftWidth - 2;
+        else
+            childRect.Height = leftWidth - 2;
+        allocateChildAt( maChildren[ 0 ].xChild, childRect );
+    }
+    if ( maChildren[ 1 ].xChild.is() )
+    {
+        awt::Rectangle childRect( 0, 0, rArea.Width, rArea.Height );
+
+        if ( mbHorizontal )
+        {
+            childRect.X += leftWidth + splitLen + 2;
+            childRect.Width = rightWidth;
+        }
+        else
+        {
+            childRect.Y += leftWidth + splitLen + 2;
+            childRect.Height = rightWidth;
+        }
+        allocateChildAt( maChildren[ 1 ].xChild, childRect );
+    }
+}
+
+//--------------------------------------------------------------------
+::com::sun::star::awt::Size SAL_CALL VCLXSplitter::getMinimumSize()
+    throw(::com::sun::star::uno::RuntimeException)
+{
+    ensureSplitter();
+
+    awt::Size size( mbHorizontal ? 2 : 0, mbHorizontal ? 0 : 2 );
+    for( unsigned int i = 0; i < 2; i++ )
+    {
+        if ( maChildren[ i ].xChild.is() )
+        {
+            awt::Size childSize = maChildren[ i ].xChild->getMinimumSize();
+            if ( mbHorizontal )
+            {
+                size.Width += childSize.Width;
+                size.Height = SAL_MAX( size.Height, childSize.Height );
+            }
+            else
+            {
+                size.Width = SAL_MAX( size.Width, childSize.Width );
+                size.Height += childSize.Height;
+            }
+        }
+    }
+
+    maRequisition = size;
+    return size;
+}
+
+//--------------------------------------------------------------------
+void VCLXSplitter::ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent )
+{
+    ::vos::OClearableGuard aGuard( GetMutex() );
+    switch ( _rVclWindowEvent.GetId() )
+    {
+        default:
+            aGuard.clear();
+            VCLXWindow::ProcessWindowEvent( _rVclWindowEvent );
+            break;
+    }
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXSplitter::setProperty( const ::rtl::OUString& PropertyName, const Any &Value ) throw(RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    if ( GetWindow() )
+    {
+        sal_uInt16 nPropertyId = GetPropertyId( PropertyName );
+        switch ( nPropertyId )
+        {
+            default:
+                VCLXWindow::setProperty( PropertyName, Value );
+        }
+    }
+}
+
+//--------------------------------------------------------------------
+Any SAL_CALL VCLXSplitter::getProperty( const ::rtl::OUString& PropertyName ) throw(RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    Any aReturn;
+    if ( GetWindow() )
+    {
+        sal_uInt16 nPropertyId = GetPropertyId( PropertyName );
+        switch ( nPropertyId )
+        {
+            default:
+                aReturn = VCLXWindow::getProperty( PropertyName );
+        }
+    }
+    return aReturn;
+}
+
+IMPL_LINK( VCLXSplitter, HandleMovedHdl, Splitter *, pSplitter )
+{
+    (void) pSplitter;
+    forceRecalc();
+    return 0;
+}
+
+//........................................................................
+} // namespace toolkit
+//........................................................................
diff --git a/layout/source/awt/vclxsplitter.hxx b/layout/source/awt/vclxsplitter.hxx
new file mode 100644
index 0000000..60179c8
--- /dev/null
+++ layout/source/awt/vclxsplitter.hxx
@@ -0,0 +1,118 @@
+#ifndef LAYOUT_AWT_VCLXSPLITTER_HXX
+#define LAYOUT_AWT_VCLXSPLITTER_HXX
+
+#ifndef _TOOLKIT_AWT_VCLXWINDOW_HXX_
+#include <toolkit/awt/vclxwindow.hxx>
+#endif
+#ifndef _TOOLKIT_HELPER_LISTENERMULTIPLEXER_HXX_
+#include <toolkit/helper/listenermultiplexer.hxx>
+#endif
+#ifndef _CPPUHELPER_IMPLBASE1_HXX_
+#include <cppuhelper/implbase1.hxx>
+#endif
+#ifndef _COMPHELPER_UNO3_HXX_
+#include <comphelper/uno3.hxx>
+#endif
+#include "../core/container.hxx"
+
+#include <com/sun/star/awt/MaxChildrenException.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include "forward.hxx"
+
+class Splitter;
+using namespace toolkit;
+
+//........................................................................
+namespace layoutimpl
+{
+//........................................................................
+
+//====================================================================
+//= VCLXSplitter
+//====================================================================
+
+class VCLXSplitter :public VCLXWindow
+                   ,public Container
+{
+public:
+    VCLXSplitter( bool bHorizontal );
+
+protected:
+    ~VCLXSplitter( );
+
+    // XInterface
+    DECLARE_XINTERFACE()
+
+    // XTypeProvider
+    DECLARE_XTYPEPROVIDER()
+
+    // XComponent
+    void SAL_CALL dispose( ) throw(::com::sun::star::uno::RuntimeException);
+
+    // ::com::sun::star::awt::XLayoutContainer
+    virtual void SAL_CALL addChild(
+        const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XLayoutConstrains >& Child )
+        throw (::com::sun::star::uno::RuntimeException, ::com::sun::star::awt::MaxChildrenException);
+    virtual void SAL_CALL removeChild( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XLayoutConstrains >& Child )
+        throw (::com::sun::star::uno::RuntimeException);
+
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference
+                                             < ::com::sun::star::awt::XLayoutConstrains > > SAL_CALL getChildren()
+        throw (::com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL allocateArea( const ::com::sun::star::awt::Rectangle &rArea )
+        throw (::com::sun::star::uno::RuntimeException);
+
+    virtual ::com::sun::star::awt::Size SAL_CALL getMinimumSize()
+        throw(::com::sun::star::uno::RuntimeException);
+
+    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
+        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    // unimplemented:
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException)
+    { return false; }
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 /*nWidth*/ )
+    throw(css::uno::RuntimeException)
+    { return maRequisition.Height; }
+
+    // VclWindowPeer
+    virtual void SAL_CALL setProperty( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Any SAL_CALL getProperty( const ::rtl::OUString& PropertyName ) throw(::com::sun::star::uno::RuntimeException);
+
+    // VCLXWindow
+    void ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent );
+
+private:
+    VCLXSplitter( const VCLXSplitter& );            // never implemented
+    VCLXSplitter& operator=( const VCLXSplitter& ); // never implemented
+
+    // Maps page ids to child references
+    friend class SplitterChildProps;
+    struct ChildData
+    {
+        sal_Bool bShrink;
+
+        css::uno::Reference< css::awt::XLayoutConstrains > xChild;
+        css::uno::Reference< css::beans::XPropertySet >    xProps;
+        bool isVisible();
+    };
+    ChildData maChildren[ 2 ];  // some may be null
+
+    float mnHandleRatio;
+    bool mbHandlePressed;
+
+    DECL_LINK( HandleMovedHdl, Splitter* );
+    bool mbHorizontal;
+    Splitter *mpSplitter;
+    void ensureSplitter();
+};
+
+//........................................................................
+} // namespacetoolkit
+//........................................................................
+
+#endif /*LAYOUT_AWT_VCLXSPLITTER_HXX*/
diff --git a/layout/source/awt/vclxtabcontrol.cxx b/layout/source/awt/vclxtabcontrol.cxx
new file mode 100644
index 0000000..d76f2f4
--- /dev/null
+++ layout/source/awt/vclxtabcontrol.cxx
@@ -0,0 +1,532 @@
+#include "vclxtabcontrol.hxx"
+
+#ifndef _TOOLKIT_HELPER_PROPERTY_HXX_
+#include "toolkit/helper/property.hxx"
+#endif
+#ifndef _COM_SUN_STAR_AWT_SCROLLBARORIENTATION_HPP_
+#include <com/sun/star/awt/ScrollBarOrientation.hpp>
+#endif
+
+
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+#ifndef _SV_TABCTRL_HXX
+#include <vcl/tabctrl.hxx>
+#endif
+
+#ifndef _TOOLKIT_HELPER_VCLUNOHELPER_HXX_
+#include <toolkit/helper/vclunohelper.hxx>
+#endif
+
+#include <vcl/tabpage.hxx>
+#include <com/sun/star/awt/PosSize.hpp>
+#include <sal/macros.h>
+
+using namespace toolkit;
+//........................................................................
+namespace layoutimpl
+{
+//........................................................................
+
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::awt;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star;
+
+class TabChildProps : public PropHelper
+{
+public:
+    TabChildProps( VCLXTabControl::ChildData *pData )
+    {
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "Title" ),
+                 ::getCppuType( static_cast< const rtl::OUString* >( NULL ) ),
+                 &(pData->aTitle) );
+    }
+    PROPHELPER_SET_INFO
+};
+
+//====================================================================
+//= VCLXTabControl
+//====================================================================
+DBG_NAME( VCLXTabControl )
+//--------------------------------------------------------------------
+VCLXTabControl::VCLXTabControl()
+: VCLXWindow()
+    , VCLXTabControl_Base()
+    , Container()
+{
+    DBG_CTOR( VCLXTabControl, NULL );
+    mnNextTabId = 1;
+    mnChildrenNb = 0;
+}
+
+//--------------------------------------------------------------------
+VCLXTabControl::~VCLXTabControl()
+{
+    DBG_DTOR( VCLXTabControl, NULL );
+}
+
+//--------------------------------------------------------------------
+IMPLEMENT_2_FORWARD_XINTERFACE2( VCLXTabControl, VCLXWindow, Container, VCLXTabControl_Base )
+
+//--------------------------------------------------------------------
+IMPLEMENT_FORWARD_XTYPEPROVIDER2( VCLXTabControl, VCLXWindow, VCLXTabControl_Base )
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::dispose( ) throw(RuntimeException)
+{
+    {
+        ::vos::OGuard aGuard( GetMutex() );
+
+        EventObject aDisposeEvent;
+        aDisposeEvent.Source = *this;
+//            maTabListeners.disposeAndClear( aDisposeEvent );
+    }
+
+    VCLXWindow::dispose();
+}
+/*
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::addTabListener( const Reference< XTabListener >& listener ) throw (RuntimeException)
+{
+if ( listener.is() )
+maTabListeners.addInterface( listener );
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::removeTabListener( const Reference< XTabListener >& listener ) throw (RuntimeException)
+{
+if ( listener.is() )
+maTabListeners.removeInterface( listener );
+}
+*/
+
+//--------------------------------------------------------------------
+TabControl *VCLXTabControl::getTabControl() const throw (RuntimeException)
+{
+    TabControl *pTabControl = static_cast< TabControl* >( GetWindow() );
+    if ( pTabControl )
+        return pTabControl;
+    throw RuntimeException();
+}
+
+//--------------------------------------------------------------------
+sal_Int32 SAL_CALL VCLXTabControl::insertTab() throw (RuntimeException)
+{
+    TabControl *pTabControl = getTabControl();
+    int id = mnNextTabId++;
+    rtl::OUString title (RTL_CONSTASCII_USTRINGPARAM( "" ) );
+    pTabControl->InsertPage( id, title.getStr(), TAB_APPEND );
+    pTabControl->SetTabPage( id, new TabPage( pTabControl ) );
+    return id;
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::removeTab( sal_Int32 ID ) throw (RuntimeException, IndexOutOfBoundsException)
+{
+    TabControl *pTabControl = getTabControl();
+    if ( pTabControl->GetTabPage( ID ) == NULL )
+        throw IndexOutOfBoundsException();
+    pTabControl->RemovePage( ID );
+}
+
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::activateTab( sal_Int32 ID ) throw (RuntimeException, IndexOutOfBoundsException)
+{
+    TabControl *pTabControl = getTabControl();
+    if ( pTabControl->GetTabPage( ID ) == NULL )
+        throw IndexOutOfBoundsException();
+    pTabControl->SelectTabPage( ID );
+}
+
+//--------------------------------------------------------------------
+sal_Int32 SAL_CALL VCLXTabControl::getActiveTabID() throw (RuntimeException)
+{
+    return getTabControl()->GetCurPageId( );
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::addTabListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XTabListener >& xListener ) throw (::com::sun::star::uno::RuntimeException)
+{
+    std::list< ::com::sun::star::uno::Reference
+        < ::com::sun::star::awt::XTabListener > >::const_iterator it;
+    for( it = mxTabListeners.begin(); it != mxTabListeners.end(); it++)
+    {
+        if ( *it == xListener )
+            // already added
+            return;
+    }
+    mxTabListeners.push_back( xListener );
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::removeTabListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XTabListener >& xListener ) throw (::com::sun::star::uno::RuntimeException)
+{
+    std::list< ::com::sun::star::uno::Reference
+        < ::com::sun::star::awt::XTabListener > >::iterator it;
+    for( it = mxTabListeners.begin(); it != mxTabListeners.end(); it++)
+    {
+        if ( *it == xListener )
+        {
+            mxTabListeners.erase( it );
+            break;
+        }
+    }
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::setTabProps( sal_Int32 ID, const Sequence< NamedValue >& Properties ) throw (RuntimeException, IndexOutOfBoundsException)
+{
+    TabControl *pTabControl = getTabControl();
+    if ( pTabControl->GetTabPage( ID ) == NULL )
+        throw IndexOutOfBoundsException();
+
+    for( int i = 0; i < Properties.getLength(); i++ )
+    {
+        const rtl::OUString &name = Properties[i].Name;
+        const Any &value = Properties[i].Value;
+
+        if ( name  == rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Title" ) ) )
+        {
+            rtl::OUString title = value.get<rtl::OUString>();
+            pTabControl->SetPageText( ID, title.getStr() );
+        }
+    }
+}
+
+//--------------------------------------------------------------------
+Sequence< NamedValue > SAL_CALL VCLXTabControl::getTabProps( sal_Int32 ID )
+    throw (IndexOutOfBoundsException, RuntimeException)
+{
+    TabControl *pTabControl = getTabControl();
+    if ( pTabControl->GetTabPage( ID ) == NULL )
+        throw IndexOutOfBoundsException();
+
+#define ADD_PROP( seq, i, name, val ) {                                \
+        NamedValue value;                                                  \
+        value.Name = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( name ) ); \
+        value.Value = makeAny( val );                                      \
+        seq[i] = value;                                                    \
+    }
+
+    Sequence< NamedValue > props( 2 );
+    ADD_PROP( props, 0, "Title", rtl::OUString( pTabControl->GetPageText( ID ) ) );
+    ADD_PROP( props, 1, "Position", pTabControl->GetPagePos( ID ) );
+#undef ADD_PROP
+    return props;
+}
+
+//--------------------------------------------------------------------
+
+// TODO: draw tab border here
+void SAL_CALL VCLXTabControl::draw( sal_Int32 nX, sal_Int32 nY ) throw(::com::sun::star::uno::RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    TabControl *pTabControl = getTabControl();
+    TabPage *pTabPage = pTabControl->GetTabPage( getActiveTabID() );
+    if ( pTabPage )
+    {
+        ::Point aPos( nX, nY );
+        ::Size  aSize = pTabPage->GetSizePixel();
+
+        OutputDevice* pDev = VCLUnoHelper::GetOutputDevice( GetViewGraphics() );
+        aPos  = pDev->PixelToLogic( aPos );
+        aSize = pDev->PixelToLogic( aSize );
+
+        pTabPage->Draw( pDev, aPos, aSize, 0 );
+    }
+
+    VCLXWindow::draw( nX, nY );
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::addChild(
+    const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XLayoutConstrains > &xChild )
+    throw (::com::sun::star::uno::RuntimeException, ::com::sun::star::awt::MaxChildrenException)
+{
+    unsigned int id = insertTab();
+    if ( maChildren.size() < id )
+        maChildren.resize( id, 0 );
+    mnChildrenNb++;
+
+    if ( xChild.is() )
+    {
+        ChildData *pData = new ChildData();
+        pData->xChild = xChild;
+        maChildren[ id-1 ] = pData;
+
+        setChildParent( xChild );
+        queueResize();
+    }
+}
+
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::removeChild( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XLayoutConstrains > &xChild )
+    throw (::com::sun::star::uno::RuntimeException)
+{
+    for( unsigned i = 0; i < maChildren.size(); i++)
+    {
+        if ( maChildren[ i ] && maChildren[ i ]->xChild == xChild )
+        {
+            removeTab( i );
+            delete maChildren[ i ];
+            maChildren[ i ] = NULL;
+            mnChildrenNb--;
+
+            unsetChildParent( xChild );
+            queueResize();
+            break;
+        }
+    }
+}
+
+//--------------------------------------------------------------------
+::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference
+                                 < ::com::sun::star::awt::XLayoutConstrains > > SAL_CALL VCLXTabControl::getChildren()
+    throw (::com::sun::star::uno::RuntimeException)
+{
+    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > childrenSeq( mnChildrenNb );
+    for( unsigned si = 0, ci = 0; ci < maChildren.size(); ci++)
+    {
+        if ( maChildren[ ci ] && maChildren[ ci ]->xChild.is() )
+            childrenSeq[si++] = maChildren[ ci ]->xChild;
+    }
+    return childrenSeq;
+}
+
+//--------------------------------------------------------------------
+uno::Reference< beans::XPropertySet > SAL_CALL
+VCLXTabControl::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException)
+{
+    std::vector< ChildData * >::iterator iter;
+    for( iter = maChildren.begin(); iter != maChildren.end(); iter++)
+    {
+        if ( (*iter)->xChild == xChild )
+        {
+            if ( !(*iter)->xProps.is() )
+            {
+                // FIXME: make me safe !
+                PropHelper *pProps = new TabChildProps( *iter );
+                pProps->setChangeListener( this );
+                (*iter)->xProps = pProps;
+            }
+            return (*iter)->xProps;
+        }
+    }
+    return uno::Reference< beans::XPropertySet >();
+}
+
+// TEMP:
+static void setChildrenVisible( uno::Reference < awt::XLayoutConstrains > xChild, bool visible )
+{
+    uno::Reference< awt::XWindow > xWin( xChild, uno::UNO_QUERY);
+    if ( xWin.is() )
+    {
+        xWin->setVisible( visible );
+//xWin->setPosSize( 0, 0, 5, 5, PosSize::POSSIZE );
+    }
+
+    uno::Reference < awt::XLayoutContainer > xCont( xChild, uno::UNO_QUERY );
+    if ( xCont.is())
+    {
+        uno::Sequence< uno::Reference < awt::XLayoutConstrains > > children = xCont->getChildren();
+        for( int i = 0; i < children.getLength(); i++ )
+        {
+            setChildrenVisible( children[i], visible );
+        }
+    }
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::allocateArea(
+    const ::com::sun::star::awt::Rectangle &rArea )
+    throw (::com::sun::star::uno::RuntimeException)
+{
+    maAllocation = rArea;
+
+    TabControl *pTabControl = getTabControl();
+
+// FIXME: this is wrong. We just want to set tab controls pos/size for the tabs menu,
+// otherwise, it gets events that should go to children (I guess we could solve this
+// by making the tabcontrol as the actual XWindow parent of its children, when importing...)
+// Not sure about TabPage drawing... That doesn't work on gtk+; just ignoring that.
+// LATER: Nah, the proper fix is to get the XWindow hierarchy straight.
+
+    setPosSize( rArea.X, rArea.Y, rArea.Width, rArea.Height, PosSize::POSSIZE );
+
+    // FIXME: we can save cycles by setting visibility more sensibly. Having
+    // it here does makes it easier when changing tabs (just needs a recalc())
+    for( unsigned int i = 0; i < maChildren.size(); i++ )
+    {
+        if ( !maChildren[ i ] )
+            continue;
+        ::com::sun::star::uno::Reference
+              < ::com::sun::star::awt::XLayoutConstrains > xChild( maChildren[ i ]->xChild );
+        if ( xChild.is() )
+        {
+            uno::Reference< awt::XWindow > xWin( xChild, uno::UNO_QUERY );
+            bool active = (i+1 == (unsigned) getActiveTabID());
+
+            // HACK: since our layout:: container don't implement XWindow, we have no easy
+            // way to set them invisible; lets just set all their children as such :P
+#if 0
+            if ( xWin.is() )
+                xWin->setVisible( active );
+#else
+            setChildrenVisible( xChild, active );
+#endif
+
+            if ( active )
+            {
+                ::Rectangle label_rect = pTabControl->GetTabBounds( i+1 );
+                ::Rectangle page_rect = pTabControl->GetTabPageBounds( i+1 );
+
+                awt::Rectangle childRect;
+                childRect.X = page_rect.Left();
+                childRect.Y = SAL_MAX( label_rect.Bottom(), page_rect.Top() );
+                childRect.Width = page_rect.Right() - page_rect.Left();
+                childRect.Height = page_rect.Bottom() - childRect.Y;
+
+                allocateChildAt( xChild, childRect );
+            }
+        }
+    }
+}
+
+//--------------------------------------------------------------------
+::com::sun::star::awt::Size SAL_CALL VCLXTabControl::getMinimumSize()
+    throw(::com::sun::star::uno::RuntimeException)
+{
+    awt::Size size = VCLXWindow::getMinimumSize();
+    awt::Size childrenSize( 0, 0 );
+
+    TabControl* pTabControl = static_cast< TabControl* >( GetWindow() );
+    if ( !pTabControl )
+        return size;
+
+    // calculate size to accomodate all children
+    for( unsigned int i = 0; i < maChildren.size(); i++ )
+    {
+        ChildData *pChild = maChildren[ i ];
+        if ( pChild && pChild->xChild.is() )
+        {
+            // set the title prop here...
+            pTabControl->SetPageText( i+1, pChild->aTitle.getStr() );
+
+            awt::Size childSize( pChild->xChild->getMinimumSize() );
+            childrenSize.Width = SAL_MAX( childSize.Width, childrenSize.Width );
+            childrenSize.Height = SAL_MAX( childSize.Height, childrenSize.Height );
+        }
+    }
+
+    size.Width += childrenSize.Width;
+    size.Height += childrenSize.Height + 20;
+    maRequisition = size;
+    return size;
+}
+
+//--------------------------------------------------------------------
+void VCLXTabControl::ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent )
+{
+    ::vos::OClearableGuard aGuard( GetMutex() );
+    TabControl* pTabControl = static_cast< TabControl* >( GetWindow() );
+    if ( !pTabControl )
+        return;
+
+    switch ( _rVclWindowEvent.GetId() )
+    {
+        case VCLEVENT_TABPAGE_ACTIVATE:
+            forceRecalc();
+        case VCLEVENT_TABPAGE_DEACTIVATE:
+        case VCLEVENT_TABPAGE_INSERTED:
+        case VCLEVENT_TABPAGE_REMOVED:
+        case VCLEVENT_TABPAGE_REMOVEDALL:
+        case VCLEVENT_TABPAGE_PAGETEXTCHANGED:
+        {
+            ULONG page = (ULONG) _rVclWindowEvent.GetData();
+            std::list< ::com::sun::star::uno::Reference
+                < ::com::sun::star::awt::XTabListener > >::iterator it;
+            for( it = mxTabListeners.begin(); it != mxTabListeners.end(); it++)
+            {
+                ::com::sun::star::uno::Reference
+                    < ::com::sun::star::awt::XTabListener > listener = *it;
+
+                switch ( _rVclWindowEvent.GetId() )
+                {
+
+                    case VCLEVENT_TABPAGE_ACTIVATE:
+                        listener->activated( page );
+                        break;
+                    case VCLEVENT_TABPAGE_DEACTIVATE:
+                        listener->deactivated( page );
+                        break;
+                    case VCLEVENT_TABPAGE_INSERTED:
+                        listener->inserted( page );
+                        break;
+                    case VCLEVENT_TABPAGE_REMOVED:
+                        listener->removed( page );
+                        break;
+                    case VCLEVENT_TABPAGE_REMOVEDALL:
+                        for( int i = 1; i < mnNextTabId; i++)
+                        {
+                            if ( pTabControl->GetTabPage( i ) )
+                                listener->removed( i );
+                        }
+                        break;
+                    case VCLEVENT_TABPAGE_PAGETEXTCHANGED:
+                        listener->changed( page, getTabProps( page ) );
+                        break;
+                }
+            }
+            break;
+        }
+        default:
+            aGuard.clear();
+            VCLXWindow::ProcessWindowEvent( _rVclWindowEvent );
+            break;
+    }
+}
+
+//--------------------------------------------------------------------
+void SAL_CALL VCLXTabControl::setProperty( const ::rtl::OUString& PropertyName, const Any &Value ) throw(RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    if ( GetWindow() )
+    {
+        sal_uInt16 nPropertyId = GetPropertyId( PropertyName );
+        switch ( nPropertyId )
+        {
+            default:
+                VCLXWindow::setProperty( PropertyName, Value );
+        }
+    }
+}
+
+//--------------------------------------------------------------------
+Any SAL_CALL VCLXTabControl::getProperty( const ::rtl::OUString& PropertyName ) throw(RuntimeException)
+{
+    ::vos::OGuard aGuard( GetMutex() );
+
+    Any aReturn;
+    if ( GetWindow() )
+    {
+        sal_uInt16 nPropertyId = GetPropertyId( PropertyName );
+        switch ( nPropertyId )
+        {
+            default:
+                aReturn = VCLXWindow::getProperty( PropertyName );
+        }
+    }
+    return aReturn;
+}
+
+//........................................................................
+} // namespace toolkit
+//........................................................................
diff --git a/layout/source/awt/vclxtabcontrol.hxx b/layout/source/awt/vclxtabcontrol.hxx
new file mode 100644
index 0000000..1b04265
--- /dev/null
+++ layout/source/awt/vclxtabcontrol.hxx
@@ -0,0 +1,142 @@
+#ifndef LAYOUT_AWT_VCLXTABCONTROLLER_HXX
+#define LAYOUT_AWT_VCLXTABCONTROLLER_HXX
+
+#ifndef _TOOLKIT_AWT_VCLXWINDOW_HXX_
+#include <toolkit/awt/vclxwindow.hxx>
+#endif
+#ifndef _TOOLKIT_HELPER_LISTENERMULTIPLEXER_HXX_
+#include <toolkit/helper/listenermultiplexer.hxx>
+#endif
+#ifndef _CPPUHELPER_IMPLBASE1_HXX_
+#include <cppuhelper/implbase1.hxx>
+#endif
+#ifndef _COMPHELPER_UNO3_HXX_
+#include <comphelper/uno3.hxx>
+#endif
+#ifndef _COM_SUN_STAR_AWT_XSIMPLETABCONTROLLER_HPP_
+#include <com/sun/star/awt/XSimpleTabController.hpp>
+#endif
+#include "../core/container.hxx"
+
+#include <com/sun/star/awt/MaxChildrenException.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include "forward.hxx"
+
+class TabControl;
+using namespace toolkit;
+
+//........................................................................
+namespace layoutimpl
+{
+//........................................................................
+
+//====================================================================
+//= VCLXTabControl
+//====================================================================
+
+typedef ::cppu::ImplHelper1 <   ::com::sun::star::awt::XSimpleTabController
+                                >   VCLXTabControl_Base;
+
+class VCLXTabControl :public VCLXWindow
+                     ,public VCLXTabControl_Base
+                     ,public Container
+{
+public:
+    VCLXTabControl();
+
+protected:
+    ~VCLXTabControl( );
+
+    // XInterface
+    DECLARE_XINTERFACE()
+
+    // XTypeProvider
+    DECLARE_XTYPEPROVIDER()
+
+    // XComponent
+    void SAL_CALL dispose( ) throw(::com::sun::star::uno::RuntimeException);
+
+    virtual SAL_CALL void draw( sal_Int32 nX, sal_Int32 nY ) throw        (::com::sun::star::uno::RuntimeException);
+
+    // XSimpleTabController
+    virtual ::sal_Int32 SAL_CALL insertTab() throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL removeTab( ::sal_Int32 ID ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL setTabProps( ::sal_Int32 ID, const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::NamedValue >& Properties ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::beans::NamedValue > SAL_CALL getTabProps( ::sal_Int32 ID ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL activateTab( ::sal_Int32 ID ) throw (::com::sun::star::lang::IndexOutOfBoundsException, ::com::sun::star::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getActiveTabID(  ) throw (::com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL addTabListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XTabListener >& Listener ) throw (::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL removeTabListener( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XTabListener >& Listener ) throw (::com::sun::star::uno::RuntimeException);
+
+    // ::com::sun::star::awt::XLayoutContainer
+    virtual void SAL_CALL addChild(
+        const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XLayoutConstrains >& Child )
+        throw (::com::sun::star::uno::RuntimeException, ::com::sun::star::awt::MaxChildrenException);
+    virtual void SAL_CALL removeChild( const ::com::sun::star::uno::Reference< ::com::sun::star::awt::XLayoutConstrains >& Child )
+        throw (::com::sun::star::uno::RuntimeException);
+
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Reference
+                                             < ::com::sun::star::awt::XLayoutConstrains > > SAL_CALL getChildren()
+        throw (::com::sun::star::uno::RuntimeException);
+
+    virtual void SAL_CALL allocateArea( const ::com::sun::star::awt::Rectangle &rArea )
+        throw (::com::sun::star::uno::RuntimeException);
+
+    virtual ::com::sun::star::awt::Size SAL_CALL getMinimumSize()
+        throw(::com::sun::star::uno::RuntimeException);
+
+    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
+        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    // unimplemented:
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException)
+    { return false; }
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 /*nWidth*/ )
+    throw(css::uno::RuntimeException)
+    { return maRequisition.Height; }
+
+    // VclWindowPeer
+    virtual void SAL_CALL setProperty( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Any& Value ) throw(::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Any SAL_CALL getProperty( const ::rtl::OUString& PropertyName ) throw(::com::sun::star::uno::RuntimeException);
+
+    // VCLXWindow
+    void ProcessWindowEvent( const VclWindowEvent& _rVclWindowEvent );
+
+private:
+    VCLXTabControl( const VCLXTabControl& );            // never implemented
+    VCLXTabControl& operator=( const VCLXTabControl& ); // never implemented
+
+    // Each tab page needs an unique id.
+    int mnNextTabId;
+
+    // Maps page ids to child references
+    friend class TabChildProps;
+    struct ChildData
+    {
+        rtl::OUString aTitle;
+        css::awt::Size aRequisition;
+        css::uno::Reference< css::awt::XLayoutConstrains > xChild;
+        css::uno::Reference< css::beans::XPropertySet >    xProps;
+        bool isVisible();
+    };
+    std::vector< ChildData * > maChildren;  // some may be null
+    int mnChildrenNb;
+
+    // FIXME: we might want to use a Multiplexer
+    std::list< ::com::sun::star::uno::Reference
+               < ::com::sun::star::awt::XTabListener > > mxTabListeners;
+
+    inline TabControl *getTabControl( ) const throw (::com::sun::star::uno::RuntimeException);
+};
+
+//........................................................................
+} // namespacetoolkit
+//........................................................................
+
+#endif /*LAYOUT_AWT_VCLXTABCONTROLLER_HXX*/
diff --git a/layout/source/core/bin.cxx b/layout/source/core/bin.cxx
new file mode 100644
index 0000000..8f5c758
--- /dev/null
+++ layout/source/core/bin.cxx
@@ -0,0 +1,159 @@
+#include "bin.hxx"
+
+#include <sal/macros.h>
+
+namespace layoutimpl
+{
+
+using namespace css;
+
+/* Bin */
+
+Bin::Bin() : Container()
+{
+}
+
+void SAL_CALL
+Bin::addChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException, awt::MaxChildrenException)
+{
+    if ( mxChild.is() )
+        throw awt::MaxChildrenException();
+    if ( xChild.is() )
+    {
+        mxChild = xChild;
+        setChildParent( xChild );
+        queueResize();
+    }
+}
+
+void SAL_CALL
+Bin::removeChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException)
+{
+    if ( xChild == mxChild )
+    {
+        mxChild = uno::Reference< awt::XLayoutConstrains >();
+        unsetChildParent( xChild );
+        queueResize();
+    }
+}
+
+uno::Sequence< uno::Reference< awt::XLayoutConstrains > > SAL_CALL
+Bin::getChildren()
+    throw (uno::RuntimeException)
+{
+    return getSingleChild (mxChild);
+}
+
+void SAL_CALL
+Bin::allocateArea( const awt::Rectangle &rArea )
+    throw (uno::RuntimeException)
+{
+    maAllocation = rArea;
+    if ( mxChild.is() )
+        allocateChildAt( mxChild, rArea );
+}
+
+awt::Size SAL_CALL
+Bin::getMinimumSize()
+    throw(uno::RuntimeException)
+{
+    if ( mxChild.is() )
+        return maRequisition = maChildRequisition = mxChild->getMinimumSize();
+    return maRequisition = awt::Size( 0, 0 );
+}
+
+uno::Reference< beans::XPropertySet > SAL_CALL
+Bin::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& )
+    throw (uno::RuntimeException)
+{
+    return uno::Reference< beans::XPropertySet >();
+}
+
+sal_Bool SAL_CALL
+Bin::hasHeightForWidth()
+    throw(uno::RuntimeException)
+{
+    uno::Reference< awt::XLayoutContainer > xChildCont( mxChild, uno::UNO_QUERY );
+    if ( xChildCont.is() )
+        return xChildCont->hasHeightForWidth();
+    return false;
+}
+
+sal_Int32 SAL_CALL
+Bin::getHeightForWidth( sal_Int32 nWidth )
+    throw(uno::RuntimeException)
+{
+    uno::Reference< awt::XLayoutContainer > xChildCont( mxChild, uno::UNO_QUERY );
+    if ( xChildCont.is() )
+        return xChildCont->getHeightForWidth( nWidth );
+    return maRequisition.Height;
+}
+
+/* Align */
+
+Align::Align() : Bin()
+{
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Halign" ),
+             ::getCppuType( static_cast< const float* >( NULL ) ),
+             &fHorAlign );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Valign" ),
+             ::getCppuType( static_cast< const float* >( NULL ) ),
+             &fVerAlign );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Hfill" ),
+             ::getCppuType( static_cast< const float* >( NULL ) ),
+             &fHorFill );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Vfill" ),
+             ::getCppuType( static_cast< const float* >( NULL ) ),
+             &fVerFill );
+
+    fHorAlign = fVerAlign = 0.5;
+    fHorFill = fVerFill = 0;
+}
+
+void SAL_CALL
+Align::allocateArea( const awt::Rectangle &rArea )
+    throw (uno::RuntimeException)
+{
+    maAllocation = rArea;
+    if ( !mxChild.is() )
+        return;
+
+    awt::Rectangle aChildArea;
+    aChildArea.Width = SAL_MIN( rArea.Width, maChildRequisition.Width );
+    aChildArea.Width += (sal_Int32) SAL_MAX(
+        0, (rArea.Width - maChildRequisition.Width) * fHorFill );
+    aChildArea.Height = SAL_MIN( rArea.Height, maChildRequisition.Height );
+    aChildArea.Height += (sal_Int32) SAL_MAX(
+        0, (rArea.Height - maChildRequisition.Height) * fVerFill );
+
+    aChildArea.X = rArea.X + (sal_Int32)( (rArea.Width - aChildArea.Width) * fHorAlign );
+    aChildArea.Y = rArea.Y + (sal_Int32)( (rArea.Height - aChildArea.Height) * fVerAlign );
+
+    allocateChildAt( mxChild, aChildArea );
+}
+
+/* MinSize */
+
+MinSize::MinSize() : Bin()
+{
+    mnMinWidth = mnMinHeight = 0;
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "MinWidth" ),
+             ::getCppuType( static_cast< const long* >( NULL ) ),
+             &mnMinWidth );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "MinHeight" ),
+             ::getCppuType( static_cast< const long* >( NULL ) ),
+             &mnMinHeight );
+}
+
+awt::Size SAL_CALL MinSize::getMinimumSize()
+    throw(uno::RuntimeException)
+{
+    Bin::getMinimumSize();
+    maRequisition.Width = SAL_MAX( maRequisition.Width, mnMinWidth );
+    maRequisition.Height = SAL_MAX( maRequisition.Height, mnMinHeight );
+    return maRequisition;
+}
+
+} // namespace layoutimpl
diff --git a/layout/source/core/bin.hxx b/layout/source/core/bin.hxx
new file mode 100644
index 0000000..dbde59a
--- /dev/null
+++ layout/source/core/bin.hxx
@@ -0,0 +1,89 @@
+/* A few simple binary containers */
+
+#ifndef CORE_BIN_HXX
+#define CORE_BIN_HXX
+
+#include "container.hxx"
+
+namespace layoutimpl
+{
+
+class Bin : public Container
+{
+protected:
+    // Child
+    css::awt::Size maChildRequisition;
+    css::uno::Reference< css::awt::XLayoutConstrains > mxChild;
+
+public:
+    Bin();
+    virtual ~Bin() {}
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
+    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Sequence< css::uno::Reference
+                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
+        throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
+        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
+        throw(css::uno::RuntimeException);
+
+    // css::awt::XLayoutConstrains
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException);
+
+    PROPHELPER_SET_INFO
+};
+
+// Align gives control over child position on the allocated space.
+class Align : public Bin
+{
+    friend class AlignChildProps;
+protected:
+    // properties
+    float fHorAlign, fVerAlign;
+    float fHorFill, fVerFill;
+
+public:
+    Align();
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+
+    PROPHELPER_SET_INFO
+};
+
+// Makes child request its or a specified size, whatever is larger.
+class MinSize : public Bin
+{
+protected:
+    // properties
+    long mnMinWidth, mnMinHeight;
+
+public:
+    MinSize();
+
+    // css::awt::XLayoutContainer
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException);
+
+    PROPHELPER_SET_INFO
+};
+
+} //  namespace layoutimpl
+
+#endif /*CORE_BIN_HXX*/
diff --git a/layout/source/core/box.cxx b/layout/source/core/box.cxx
new file mode 100644
index 0000000..16519ed
--- /dev/null
+++ layout/source/core/box.cxx
@@ -0,0 +1,338 @@
+#include "box.hxx"
+
+#include <tools/debug.hxx>
+#include <sal/macros.h>
+
+// fixed point precision for distributing error
+#define FIXED_PT 16
+
+namespace layoutimpl
+{
+
+using namespace css;
+
+class BoxChildProps : public PropHelper
+{
+public:
+    BoxChildProps( Box::ChildData *pData )
+    {
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "Expand" ),
+                 ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+                 &(pData->bExpand) );
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "Fill" ),
+                 ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+                 &(pData->bFill) );
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "Padding" ),
+                 ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+                 &(pData->nPadding) );
+    }
+    PROPHELPER_SET_INFO
+};
+
+bool Box::ChildData::isVisible()
+{
+    // FIXME: call the 'isVisible' method on it ?
+    if ( !xChild.is() )
+    {
+        DBG_ERROR( "FIXME: invalid child !" );
+    }
+    return xChild.is();
+}
+
+Box::Box( bool horizontal )
+    : Container()
+    , mnSpacing( 0 )
+    , mbHomogeneous( false )
+    , mbHorizontal( horizontal )
+{
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Homogeneous" ),
+             ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+             &mbHomogeneous );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Spacing" ),
+             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+             &mnSpacing );
+    mbHasFlowChildren = false;
+}
+
+Box::ChildData *
+Box::createChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
+{
+    ChildData *p = new ChildData();
+
+    p->nPadding = 0;
+    p->bExpand = true;
+    p->bFill = true;
+    p->xChild = xChild;
+    return p;
+}
+
+void SAL_CALL
+Box::addChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException, awt::MaxChildrenException)
+{
+    if ( xChild.is() )
+    {
+        ChildData *pData = createChild( xChild );
+        maChildren.push_back( pData );
+        setChildParent( xChild );
+        queueResize();
+    }
+}
+
+Box::ChildData *
+Box::removeChildData( std::list< ChildData *> lst, css::uno::Reference< css::awt::XLayoutConstrains > const& xChild )
+{
+    for( std::list< ChildData * >::iterator it = lst.begin();
+         it != lst.end(); it++ )
+    {
+        if ( (*it)->xChild == xChild )
+        {
+            lst.erase( it );
+            return *it;
+        }
+    }
+    return 0;
+}
+
+void SAL_CALL
+Box::removeChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException)
+{
+    if ( ChildData *p = removeChildData( maChildren, xChild ) )
+    {
+        // CHECK: BoxChildProps leaks?
+        delete p;
+        unsetChildParent( xChild );
+        queueResize();
+    }
+    else
+    {
+        DBG_ERROR( "Box: removeChild: no such child" );
+    }
+}
+
+uno::Sequence< uno::Reference < awt::XLayoutConstrains > > SAL_CALL
+Box::getChildren()
+    throw (uno::RuntimeException)
+{
+    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > children( maChildren.size() );
+    unsigned int i = 0;
+    for( std::list< ChildData * >::iterator it = maChildren.begin();
+         it != maChildren.end(); it++, i++ )
+        children[i] = (*it)->xChild;
+
+    return children;
+}
+
+uno::Reference< beans::XPropertySet > SAL_CALL
+Box::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException)
+{
+    std::list< ChildData * >::iterator iter;
+    for( iter = maChildren.begin(); iter != maChildren.end(); iter++)
+    {
+        if ( (*iter)->xChild == xChild )
+        {
+            if ( !(*iter)->xProps.is() )
+            {
+                // FIXME: make me safe !
+                PropHelper *pProps = new BoxChildProps( *iter );
+                pProps->setChangeListener( this );
+                (*iter)->xProps = pProps;
+            }
+            return (*iter)->xProps;
+        }
+    }
+    return uno::Reference< beans::XPropertySet >();
+}
+
+awt::Size
+Box::calculateSize( long nWidth )
+{
+    int nVisibleChildren = 0;
+    // primary vs secundary axis (instead of a X and Y)
+    int nPrimSize = 0, nSecSize = 0;
+    int nFlowMinWidth = 0;  // in case the box only has flow children
+
+    mbHasFlowChildren = false;
+
+    std::list<ChildData *>::const_iterator it;
+    for( it = maChildren.begin(); it != maChildren.end(); it++ )
+    {
+        ChildData *child = *it;
+        if ( !child->isVisible() )
+            continue;
+
+        uno::Reference< awt::XLayoutContainer > xChildCont( child->xChild, uno::UNO_QUERY );
+        bool bFlow = xChildCont.is() && xChildCont->hasHeightForWidth();
+
+        awt::Size aChildSize = child->aRequisition = child->xChild->getMinimumSize();
+
+        if ( !mbHorizontal /*vertical*/ && bFlow )
+        {
+            if ( nFlowMinWidth == 0 || nFlowMinWidth > aChildSize.Width )
+                nFlowMinWidth = aChildSize.Width;
+            mbHasFlowChildren = true;
+        }
+        else
+        {
+            int size = primDim( aChildSize ) + child->nPadding * 2;
+            if ( mbHomogeneous )
+                nPrimSize = SAL_MAX( nPrimSize, size );
+            else
+                nPrimSize += size;
+
+            nSecSize = SAL_MAX( nSecSize, secDim( aChildSize ) );
+        }
+        nVisibleChildren++;
+    }
+
+    if ( nVisibleChildren )
+    {
+        if ( mbHomogeneous )
+            nPrimSize *= nVisibleChildren;
+        nPrimSize += (nVisibleChildren - 1) * mnSpacing;
+    }
+
+    if ( mbHasFlowChildren )
+    {
+        if ( nWidth == 0 )
+            nWidth = nSecSize ? nSecSize : nFlowMinWidth;
+        for( it = maChildren.begin(); it != maChildren.end(); it++ )
+        {
+            ChildData *child = *it;
+            if ( !child->isVisible() )
+                continue;
+
+            uno::Reference< awt::XLayoutContainer > xChildCont( child->xChild, uno::UNO_QUERY );
+            bool bFlow = xChildCont.is() && xChildCont->hasHeightForWidth();
+
+            if ( bFlow )
+                nPrimSize += xChildCont->getHeightForWidth( nWidth );
+        }
+    }
+
+    nPrimSize += mnBorderWidth * 2;
+    nSecSize += mnBorderWidth * 2;
+    return awt::Size( mbHorizontal ? nPrimSize : nSecSize,
+                      mbHorizontal ? nSecSize : nPrimSize );
+}
+
+awt::Size SAL_CALL
+Box::getMinimumSize() throw(uno::RuntimeException)
+{
+    maRequisition = calculateSize();
+    return maRequisition;
+}
+
+sal_Bool SAL_CALL
+Box::hasHeightForWidth()
+    throw(uno::RuntimeException)
+{
+    return mbHasFlowChildren;
+}
+
+sal_Int32 SAL_CALL
+Box::getHeightForWidth( sal_Int32 nWidth )
+    throw(uno::RuntimeException)
+{
+    if ( hasHeightForWidth() )
+        return calculateSize( nWidth ).Height;
+    return maRequisition.Height;
+}
+
+void SAL_CALL
+Box::allocateArea( const awt::Rectangle &newArea )
+    throw (uno::RuntimeException)
+{
+    maAllocation = newArea;
+    int nVisibleChildren = 0, nExpandChildren = 0;
+
+    std::list<ChildData *>::const_iterator it;
+    for( it = maChildren.begin(); it != maChildren.end(); it++ )
+    {
+        ChildData *child = *it;
+        if ( child->isVisible() )
+        {
+            nVisibleChildren++;
+            if ( child->bExpand )
+                nExpandChildren++;
+        }
+    }
+    if ( !nVisibleChildren )
+        return;
+
+    // split rectangle for dimension helpers
+    awt::Point newPoint( newArea.X, newArea.Y );
+    awt::Size newSize( newArea.Width, newArea.Height );
+
+    int nExtraSpace;
+    if ( mbHomogeneous )
+        nExtraSpace = ( ( primDim( newSize ) - mnBorderWidth * 2 -
+                          ( nVisibleChildren - 1 ) * mnSpacing )) / nVisibleChildren;
+    else if ( nExpandChildren )
+    {
+        int reqSize = primDim( maRequisition );
+        if ( !mbHorizontal && hasHeightForWidth() )
+            reqSize = getHeightForWidth( newArea.Width );
+        nExtraSpace = ( primDim( newSize ) - reqSize ) / nExpandChildren;
+    }
+    else
+        nExtraSpace = 0;
+
+    int nChildPrimPoint, nChildSecPoint, nChildPrimSize, nChildSecSize;
+
+    int nStartPoint = primDim( newPoint ) + mnBorderWidth;
+    int nBoxSecSize = SAL_MAX( 1, secDim( newSize ) - mnBorderWidth * 2 );
+
+    for( it = maChildren.begin(); it != maChildren.end(); it++ )
+    {
+        ChildData *child = *it;
+        if ( !child->isVisible() )
+            continue;
+
+        awt::Point aChildPos;
+        int nBoxPrimSize;  // of the available box space
+
+        if ( mbHomogeneous )
+            nBoxPrimSize = nExtraSpace;
+        else
+        {
+            uno::Reference< awt::XLayoutContainer > xChildCont( child->xChild, uno::UNO_QUERY );
+            bool bFlow = xChildCont.is() && xChildCont->hasHeightForWidth();
+            if ( !mbHorizontal && bFlow )
+                nBoxPrimSize = xChildCont->getHeightForWidth( newArea.Width );
+            else
+                nBoxPrimSize = primDim( child->aRequisition );
+            nBoxPrimSize += child->nPadding;
+            if ( child->bExpand )
+                nBoxPrimSize += nExtraSpace;
+        }
+
+        nChildPrimPoint = nStartPoint + child->nPadding;
+        nChildSecPoint = secDim( newPoint ) + mnBorderWidth;
+
+        nChildSecSize = nBoxSecSize;
+        if ( child->bFill )
+            nChildPrimSize = SAL_MAX( 1, nBoxPrimSize - child->nPadding);
+        else
+        {
+            nChildPrimSize = primDim( child->aRequisition );
+            nChildPrimPoint += (nBoxPrimSize - nChildPrimSize) / 2;
+
+            nChildSecPoint += (nBoxSecSize - nChildSecSize) / 2;
+        }
+
+        awt::Rectangle area;
+        area.X = mbHorizontal ? nChildPrimPoint : nChildSecPoint;
+        area.Y = mbHorizontal ? nChildSecPoint : nChildPrimPoint;
+        area.Width = mbHorizontal ? nChildPrimSize : nChildSecSize;
+        area.Height = mbHorizontal ? nChildSecSize : nChildPrimSize;
+
+        allocateChildAt( child->xChild, area );
+
+        nStartPoint += nBoxPrimSize + mnSpacing + child->nPadding;
+    }
+}
+
+} // namespace layoutimpl
diff --git a/layout/source/core/box.hxx b/layout/source/core/box.hxx
new file mode 100644
index 0000000..967d982
--- /dev/null
+++ layout/source/core/box.hxx
@@ -0,0 +1,91 @@
+#ifndef CORE_BOX_HXX
+#define CORE_BOX_HXX
+
+#include "container.hxx"
+
+#include <com/sun/star/awt/Point.hpp>
+
+#include <list>
+
+namespace layoutimpl
+{
+
+class Box : public Container
+{
+    friend class BoxChildProps;
+protected:
+    // Box properties (i.e. affect all children)
+    sal_Int32 mnSpacing;
+    sal_Bool mbHomogeneous;
+    sal_Bool mbHorizontal;  // false for Vertical
+
+    // Children properties
+    struct ChildData
+    {
+      sal_Int32 nPadding;
+      sal_Bool  bExpand, bFill;
+      css::awt::Size aRequisition;
+      css::uno::Reference< css::awt::XLayoutConstrains > xChild;
+      css::uno::Reference< css::beans::XPropertySet > xProps;
+      bool isVisible();
+    };
+    std::list< ChildData * > maChildren;
+    bool mbHasFlowChildren;
+
+public:
+    Box( bool horizontal );
+
+    static ChildData *createChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild );
+
+    ChildData *removeChildData( std::list< ChildData *>, css::uno::Reference< css::awt::XLayoutConstrains > const& Child );
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
+    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Sequence< css::uno::Reference
+                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
+        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
+        throw(css::uno::RuntimeException);
+
+    // helper: mix of getMinimumSize() and getHeightForWidth()
+    css::awt::Size calculateSize( long nWidth = 0 );
+
+    PROPHELPER_SET_INFO
+
+private:
+    /* Helpers to deal with the joint Box directions. */
+    inline int primDim (const css::awt::Size &size)
+    { if (mbHorizontal) return size.Width; else return size.Height; }
+    inline int secDim (const css::awt::Size &size)
+    { if (mbHorizontal) return size.Height; else return size.Width; }
+    inline int primDim (const css::awt::Point &point)
+    { if (mbHorizontal) return point.X; else return point.Y; }
+    inline int secDim (const css::awt::Point &point)
+    { if (mbHorizontal) return point.Y; else return point.X; }
+};
+
+struct VBox : public Box
+{ VBox() : Box (false) {} };
+
+struct HBox : public Box
+{ HBox() : Box (true) {} };
+
+} //  namespace layoutimpl
+
+#endif /*CORE_BOX_HXX*/
diff --git a/layout/source/core/byteseq.cxx b/layout/source/core/byteseq.cxx
new file mode 100644
index 0000000..f3d8510
--- /dev/null
+++ layout/source/core/byteseq.cxx
@@ -0,0 +1,147 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: xml_byteseq.cxx,v $
+ *
+ *  $Revision: 1.5 $
+ *
+ *  last change: $Author: obo $ $Date: 2006/09/17 11:37:10 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// This is - unbelievably ugly - but then getting the UCB to work is worse.
+// cut/paste from xmlscript/source/xml_helper/xml_byteseq.cxx
+
+#include <stdio.h>
+#include <rtl/memory.h>
+#include <rtl/byteseq.hxx>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/io/XInputStream.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+
+using namespace rtl;
+using namespace osl;
+using namespace com::sun::star;
+using namespace com::sun::star::uno;
+
+namespace layoutimpl
+{
+
+uno::Reference< io::XInputStream >
+getFileAsStream( const uno::Reference< lang::XMultiServiceFactory > &xFactory,
+                 const rtl::OUString &rName );
+
+class BSeqInputStream
+    : public ::cppu::WeakImplHelper1< io::XInputStream >
+{
+    ByteSequence _seq;
+    sal_Int32 _nPos;
+
+public:
+    inline BSeqInputStream( ByteSequence const & rSeq )
+        SAL_THROW( () )
+        : _seq( rSeq )
+        , _nPos( 0 )
+    {
+    }
+
+    // XInputStream
+    virtual sal_Int32 SAL_CALL readBytes(
+        Sequence< sal_Int8 > & rData, sal_Int32 nBytesToRead )
+        throw (io::NotConnectedException, io::BufferSizeExceededException, io::IOException, RuntimeException);
+    virtual sal_Int32 SAL_CALL readSomeBytes(
+        Sequence< sal_Int8 > & rData, sal_Int32 nMaxBytesToRead )
+        throw (io::NotConnectedException, io::BufferSizeExceededException, io::IOException, RuntimeException);
+    virtual void SAL_CALL skipBytes(
+        sal_Int32 nBytesToSkip )
+        throw (io::NotConnectedException, io::BufferSizeExceededException, io::IOException, RuntimeException);
+    virtual sal_Int32 SAL_CALL available()
+        throw (io::NotConnectedException, io::IOException, RuntimeException);
+    virtual void SAL_CALL closeInput()
+        throw (io::NotConnectedException, io::IOException, RuntimeException);
+};
+//__________________________________________________________________________________________________
+sal_Int32 BSeqInputStream::readBytes(
+    Sequence< sal_Int8 > & rData, sal_Int32 nBytesToRead )
+    throw (io::NotConnectedException, io::BufferSizeExceededException, io::IOException, RuntimeException)
+{
+    nBytesToRead = ((nBytesToRead > _seq.getLength() - _nPos)
+                    ? _seq.getLength() - _nPos
+                    : nBytesToRead);
+
+    ByteSequence aBytes( _seq.getConstArray() + _nPos, nBytesToRead );
+    rData = toUnoSequence( aBytes );
+    _nPos += nBytesToRead;
+    return nBytesToRead;
+} //__________________________________________________________________________________________________
+sal_Int32 BSeqInputStream::readSomeBytes(
+    Sequence< sal_Int8 > & rData, sal_Int32 nMaxBytesToRead )
+    throw (io::NotConnectedException, io::BufferSizeExceededException, io::IOException, RuntimeException)
+{
+    return readBytes( rData, nMaxBytesToRead );
+} //__________________________________________________________________________________________________
+void BSeqInputStream::skipBytes(
+    sal_Int32 /*nBytesToSkip*/ )
+    throw (io::NotConnectedException, io::BufferSizeExceededException, io::IOException, RuntimeException)
+{
+} //__________________________________________________________________________________________________
+sal_Int32 BSeqInputStream::available()
+    throw (io::NotConnectedException, io::IOException, RuntimeException)
+{
+    return (_seq.getLength() - _nPos);
+} //__________________________________________________________________________________________________
+void BSeqInputStream::closeInput()
+    throw (io::NotConnectedException, io::IOException, RuntimeException)
+{
+}
+
+//==================================================================================================
+uno::Reference< io::XInputStream >
+getFileAsStream( const uno::Reference< lang::XMultiServiceFactory > & /* xFactory */,
+                 const rtl::OUString &rName )
+{
+    rtl::OString fname = rtl::OUStringToOString( rName, RTL_TEXTENCODING_UTF8 );
+    // create the input stream
+    FILE *f = ::fopen( fname, "rb" );
+    if (f)
+    {
+        ::fseek( f, 0 ,SEEK_END );
+        int nLength = ::ftell( f );
+        ::fseek( f, 0, SEEK_SET );
+
+        ByteSequence bytes( nLength );
+        ::fread( bytes.getArray(), nLength, 1, f );
+        ::fclose( f );
+
+        return new BSeqInputStream( bytes );
+    }
+
+    throw Exception( OUString( RTL_CONSTASCII_USTRINGPARAM("### Cannot read file!") ),
+                     Reference< XInterface >() );
+}
+
+} // namespace layoutimpl
diff --git a/layout/source/core/container.cxx b/layout/source/core/container.cxx
new file mode 100644
index 0000000..12fe964
--- /dev/null
+++ layout/source/core/container.cxx
@@ -0,0 +1,141 @@
+#include "container.hxx"
+
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/awt/PosSize.hpp>
+#include <tools/debug.hxx>
+
+namespace layoutimpl {
+
+using namespace css;
+
+Container::Container()
+    : Container_Base()
+    , PropHelper()
+    , mnBorderWidth( 0 )
+{
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Border" ),
+             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+             &mnBorderWidth );
+    setChangeListener( this );
+}
+
+uno::Any
+Container::queryInterface( const uno::Type & rType ) throw (uno::RuntimeException)
+{
+    uno::Any aRet = Container_Base::queryInterface( rType );
+    return aRet.hasValue() ? aRet : PropHelper::queryInterface( rType );
+}
+
+void
+Container::allocateChildAt( const uno::Reference< awt::XLayoutConstrains > &xChild,
+                            const awt::Rectangle &rArea )
+    throw( uno::RuntimeException )
+{
+    uno::Reference< awt::XLayoutContainer > xCont( xChild, uno::UNO_QUERY );
+    if ( xCont.is() )
+        xCont->allocateArea( rArea );
+    else
+    {
+        uno::Reference< awt::XWindow > xWindow( xChild, uno::UNO_QUERY );
+        if ( xWindow.is() )
+            xWindow->setPosSize( rArea.X, rArea.Y, rArea.Width, rArea.Height,
+                                 awt::PosSize::POSSIZE );
+        else
+        {
+            DBG_ERROR( "Error: non-sizeable child" );
+        }
+    }
+}
+
+uno::Sequence< uno::Reference< awt::XLayoutConstrains > >
+Container::getSingleChild ( uno::Reference< awt::XLayoutConstrains >const &xChildOrNil )
+{
+    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > aSeq( ( xChildOrNil.is() ? 1 : 0 ) );
+    if ( xChildOrNil.is() )
+        aSeq[0] = xChildOrNil;
+    return aSeq;
+}
+
+void
+Container::queueResize()
+{
+    if ( mxLayoutUnit.is() )
+        mxLayoutUnit->queueResize( uno::Reference< awt::XLayoutContainer >( this ) );
+}
+
+void
+Container::setChildParent( const uno::Reference< awt::XLayoutConstrains >& xChild )
+{
+    uno::Reference< awt::XLayoutContainer > xContChild( xChild, uno::UNO_QUERY );
+    if ( xContChild.is() )
+    {
+        xContChild->setParent( uno::Reference< awt::XLayoutContainer >( this ) );
+#if 0
+        assert( !mxLayoutUnit.is() );
+        xContChild->setLayoutUnit( mxLayoutUnit );
+#endif
+    }
+}
+
+void
+Container::unsetChildParent( const uno::Reference< awt::XLayoutConstrains >& xChild )
+{
+    uno::Reference< awt::XLayoutContainer > xContChild( xChild, uno::UNO_QUERY );
+    if ( xContChild.is() )
+    {
+        xContChild->setParent( uno::Reference< awt::XLayoutContainer >() );
+#if 0
+        xContChild->setLayoutUnit( uno::Reference< awt::XLayoutUnit >() );
+#endif
+    }
+}
+
+#if 0
+std::string
+Container::getLabel()  // debug label
+{
+    std::string depth;
+    uno::Reference< awt::XLayoutContainer > xContainer( this );
+    while ( xContainer.is() )
+    {
+        int node = 0;  // child nb
+        uno::Reference< awt::XLayoutContainer > xParent = xContainer->getContainerParent();
+        if ( xParent.is() )
+        {
+
+            uno::Sequence< uno::Reference< awt::XLayoutConstrains > > aChildren;
+            aChildren = xParent->getChildren();
+            for( node = 0; node < aChildren.getLength(); node++ )
+                if ( aChildren[ node ] == xContainer )
+                    break;
+        }
+
+        char str[ 8 ];
+        snprintf( str, 8, "%d", node );
+        if ( depth.empty() )
+            depth = std::string( str );
+        else
+            depth = std::string( str ) + ":" + depth;
+
+        xContainer = xParent;
+    }
+
+    return std::string( getName() ) + " (" + depth + ")";
+}
+#endif
+
+void Container::propertiesChanged()
+{
+    if ( !mxParent.is() )
+    {
+        DBG_ERROR( "Properties listener: error container doesn't have parent" );
+    }
+
+    // ask parent to be re-calculated
+// FIXME: thats wrongg actually. We just need to do a "queueResize();"
+    
+    if ( mxLayoutUnit.is() && mxParent.is() )
+        mxLayoutUnit->queueResize( mxParent );
+}
+
+}
diff --git a/layout/source/core/container.hxx b/layout/source/core/container.hxx
new file mode 100644
index 0000000..362050a
--- /dev/null
+++ layout/source/core/container.hxx
@@ -0,0 +1,109 @@
+#ifndef CORE_CONTAINER_HXX
+#define CORE_CONTAINER_HXX
+
+#include "helper.hxx"
+
+#include <cppuhelper/implbase2.hxx>
+#include <com/sun/star/awt/MaxChildrenException.hpp>
+
+namespace layoutimpl
+{
+namespace css = ::com::sun::star;
+
+typedef ::cppu::WeakImplHelper2< css::awt::XLayoutContainer,
+                                 css::awt::XLayoutConstrains > Container_Base;
+
+class Container : public Container_Base, public PropHelper, public PropHelper::Listener
+{
+    friend class ChildProps;
+protected:
+    // Widget properties
+    css::uno::Reference< css::awt::XLayoutContainer > mxParent;
+    css::uno::Reference< css::awt::XLayoutUnit > mxLayoutUnit;
+    css::awt::Size maRequisition;
+    css::awt::Rectangle maAllocation;
+
+    // Container properties
+    sal_Int32 mnBorderWidth;
+
+    // Utilities
+    void allocateChildAt( const css::uno::Reference< css::awt::XLayoutConstrains > &xChild,
+                          const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+    static css::uno::Sequence< css::uno::Reference< css::awt::XLayoutConstrains > >
+    getSingleChild (const css::uno::Reference< css::awt::XLayoutConstrains > &xChildOrNil);
+    void setChildParent( const css::uno::Reference< css::awt::XLayoutConstrains >& xChild );
+    void unsetChildParent( const css::uno::Reference< css::awt::XLayoutConstrains >& xChild );
+
+    void queueResize();
+    void forceRecalc() { allocateArea( maAllocation ); }
+
+public:
+    Container();
+    virtual ~Container() {}
+
+    // XInterface
+    virtual void SAL_CALL acquire() throw() { PropHelper::acquire(); }
+    virtual void SAL_CALL release() throw() { PropHelper::release(); }
+    virtual ::com::sun::star::uno::Any SAL_CALL queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException);
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException, css::awt::MaxChildrenException) = 0;
+    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException) = 0;
+
+    virtual css::uno::Sequence< css::uno::Reference
+                                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
+        throw (css::uno::RuntimeException) = 0;
+
+    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
+        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException) = 0;
+
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException) = 0;
+
+    void SAL_CALL setLayoutUnit( const css::uno::Reference< css::awt::XLayoutUnit > &xUnit )
+        throw(css::uno::RuntimeException)
+    { mxLayoutUnit = xUnit; }
+    css::uno::Reference< css::awt::XLayoutUnit > SAL_CALL getLayoutUnit()
+        throw(css::uno::RuntimeException)
+    { return mxLayoutUnit; }
+
+    css::awt::Size SAL_CALL getRequestedSize() throw(css::uno::RuntimeException)
+    { return maRequisition; }
+    com::sun::star::awt::Rectangle SAL_CALL getAllocatedArea() throw(css::uno::RuntimeException)
+    { return maAllocation; }
+
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException) = 0;
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
+        throw(css::uno::RuntimeException) = 0;
+
+    // css::awt::XLayoutContainer: css::container::XChild
+    css::uno::Reference< css::uno::XInterface > SAL_CALL getParent()
+        throw (css::uno::RuntimeException)
+    { return mxParent; }
+    void SAL_CALL setParent( const css::uno::Reference< css::uno::XInterface > &xParent )
+        throw (css::uno::RuntimeException)
+    { mxParent = css::uno::Reference< css::awt::XLayoutContainer >( xParent, css::uno::UNO_QUERY ); }
+
+    // css::awt::XLayoutConstrains
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException) = 0;
+    // (not properly implemented in toolkit, ignore it.)
+    css::awt::Size SAL_CALL getPreferredSize()
+        throw(css::uno::RuntimeException) { return getMinimumSize(); } // TODO: use this for flow?
+    css::awt::Size SAL_CALL calcAdjustedSize( const css::awt::Size& rNewSize )
+        throw(css::uno::RuntimeException) { return rNewSize; }
+
+PROPHELPER_SET_INFO
+
+protected:
+    void propertiesChanged();
+};
+
+} //  namespace layoutimpl
+
+#endif /*CORE_CONTAINER_HXX*/
diff --git a/layout/source/core/dialogbuttonhbox.cxx b/layout/source/core/dialogbuttonhbox.cxx
new file mode 100644
index 0000000..95723c2
--- /dev/null
+++ layout/source/core/dialogbuttonhbox.cxx
@@ -0,0 +1,264 @@
+#include "dialogbuttonhbox.hxx"
+
+#include <tools/debug.hxx>
+#include <toolkit/awt/vclxwindows.hxx>
+#include <vcl/button.hxx>
+
+#include "flow.hxx"
+#include "../awt/vclxbutton.hxx"
+#include "proplist.hxx"
+
+#if TEST_LAYOUT && !defined( DBG_UTIL )
+#include <stdio.h>
+#undef DBG_ERROR
+#define DBG_ERROR printf
+#undef DBG_ERROR1
+#define DBG_ERROR1 printf
+#undef DBG_ERROR2
+#define DBG_ERROR2 printf
+#endif /* TEST_LAYOUT && !DBG_UTIL */
+
+namespace layoutimpl
+{
+
+using namespace css;
+
+//FIXME: how to set platform-dependant variables?
+DialogButtonHBox::Ordering const DialogButtonHBox::DEFAULT_ORDERING =
+#if defined( MACOSX )
+    DialogButtonHBox::MacOS;
+#elif defined( SAL_W32 )
+DialogButtonHBox::WINDOWS;
+#elif defined( ENABLE_KDE )
+DialogButtonHBox::KDE;
+#else /* !MACOSX && !SAL_W32 && !ENABLE_KDE */
+DialogButtonHBox::GNOME;
+#endif /* !MACOSX && !SAL_W32 && !ENABLE_KDE */
+
+DialogButtonHBox::DialogButtonHBox()
+    : HBox()
+    , mnOrdering( DEFAULT_ORDERING )
+    , mFlow()
+    , mpAction( 0 )
+    , mpAffirmative( 0 )
+    , mpAlternate( 0 )
+    , mpApply( 0 )
+    , mpCancel( 0 )
+    , mpFlow( createChild( uno::Reference< awt::XLayoutConstrains > ( &mFlow ) ) )
+    , mpHelp( 0 )
+    , mpReset( 0 )
+{
+    mbHomogeneous = true;
+}
+
+void
+DialogButtonHBox::setOrdering( rtl::OUString const& ordering )
+{
+    if ( ordering.equalsIgnoreAsciiCaseAscii( "GNOME" ) )
+        mnOrdering = GNOME;
+    else if ( ordering.equalsIgnoreAsciiCaseAscii( "KDE" ) )
+        mnOrdering = KDE;
+    else if ( ordering.equalsIgnoreAsciiCaseAscii( "MacOS" ) )
+        mnOrdering = MACOS;
+    else if ( ordering.equalsIgnoreAsciiCaseAscii( "Windows" ) )
+        mnOrdering = WINDOWS;
+    else
+    {
+        DBG_ERROR1( "DialogButtonHBox: no such ordering: %s", OUSTRING_CSTR( ordering ) );
+    }
+}
+
+void
+DialogButtonHBox::addChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
+    throw ( uno::RuntimeException, awt::MaxChildrenException )
+{
+    if ( !xChild.is() )
+        return;
+
+    ChildData *p = createChild( xChild );
+
+#define IS_BUTTON(t) dynamic_cast<VCLX##t##Button *>( xChild.get () )
+
+    /* Sort Retry as Action */
+    if ( !mpAction && IS_BUTTON( Retry ) )
+        mpAction = p;
+    else if ( !mpAffirmative && IS_BUTTON( OK ) )
+        mpAffirmative = p;
+    else if ( !mpAffirmative && IS_BUTTON( Yes ) )
+        mpAffirmative = p;
+    else if ( !mpAlternate && IS_BUTTON( No ) )
+        mpAlternate = p;
+    /* Sort Ignore as Alternate */
+    else if ( !mpAlternate && IS_BUTTON( Ignore ) )
+        mpAlternate = p;
+    else if ( !mpApply && IS_BUTTON( Apply ) )
+        mpApply = p;
+    else if ( !mpCancel && IS_BUTTON( Cancel ) )
+        mpCancel = p;
+    /* Let the user overwrite Flow */
+    else if ( /* !mpFlow && */ dynamic_cast<Flow *>( xChild.get () ) )
+        mpFlow = p;
+    else if ( !mpHelp && IS_BUTTON( Help ) )
+        mpHelp = p;
+    else if ( !mpReset && IS_BUTTON( Reset ) )
+        mpReset = p;
+    else
+        maOther.push_back( p );
+    orderChildren();
+    setChildParent( xChild );
+    queueResize();
+}
+
+void
+DialogButtonHBox::orderChildren()
+{
+    if ( mnOrdering == WINDOWS )
+        windowsOrdering();
+    else if ( mnOrdering == MACOS )
+        macosOrdering();
+    else if ( mnOrdering == KDE )
+        kdeOrdering();
+    else if ( 1 || mnOrdering == GNOME )
+        gnomeOrdering();
+}
+
+void SAL_CALL
+DialogButtonHBox::removeChild( uno::Reference< awt::XLayoutConstrains > const& xChild )
+    throw ( uno::RuntimeException)
+{
+    if ( !xChild.is ())
+        return;
+
+    ChildData *p = 0;
+
+    if ( mpAction && mpAction->xChild == xChild )
+        p = mpAction;
+    else if ( mpAffirmative && mpAffirmative->xChild == xChild )
+        p = mpAffirmative;
+    else if ( mpAlternate && mpAlternate->xChild == xChild )
+        p = mpAlternate;
+    else if ( mpApply && mpApply->xChild == xChild )
+        p = mpApply;
+    else if ( mpCancel && mpCancel->xChild == xChild )
+        p = mpCancel;
+    else if ( mpFlow && mpFlow->xChild == xChild )
+        p = mpFlow;
+    else if ( mpReset && mpReset->xChild == xChild )
+        p = mpReset;
+    else if ( mpHelp && mpHelp->xChild == xChild )
+        p = mpHelp;
+    else
+        p = removeChildData( maOther, xChild );
+
+    if ( p )
+    {
+        delete p;
+        unsetChildParent( xChild );
+        orderChildren();
+        queueResize();
+    }
+    else
+    {
+        DBG_ERROR( "DialogButtonHBox: removeChild: no such child" );
+    }
+}
+
+void
+DialogButtonHBox::gnomeOrdering()
+{
+    std::list< ChildData * > ordered;
+    if ( mpHelp )
+        ordered.push_back( mpHelp );
+    if ( mpReset )
+        ordered.push_back( mpReset );
+    if ( mpFlow && ( mpHelp || mpReset ) )
+        ordered.push_back( mpFlow );
+    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
+    if ( mpAction )
+        ordered.push_back( mpAction );
+    if ( mpApply )
+        ordered.push_back( mpApply );
+    if ( mpAlternate )
+        ordered.push_back( mpAlternate );
+    if ( mpCancel )
+        ordered.push_back( mpCancel );
+    if ( mpAffirmative )
+        ordered.push_back( mpAffirmative );
+    maChildren = ordered;
+}
+
+void
+DialogButtonHBox::kdeOrdering()
+{
+    std::list< ChildData * > ordered;
+    if ( mpHelp )
+        ordered.push_back( mpHelp );
+    if ( mpReset )
+        ordered.push_back( mpReset );
+    if ( mpFlow && ( mpHelp || mpReset ) )
+        ordered.push_back( mpFlow );
+    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
+    if ( mpAction )
+        ordered.push_back( mpAction );
+    if ( mpAffirmative )
+        ordered.push_back( mpAffirmative );
+    if ( mpApply )
+        ordered.push_back( mpApply );
+    if ( mpAlternate )
+        ordered.push_back( mpAlternate );
+    if ( mpCancel )
+        ordered.push_back( mpCancel );
+    maChildren = ordered;
+}
+
+void
+DialogButtonHBox::macosOrdering()
+{
+    std::list< ChildData * > ordered;
+    if ( mpHelp )
+        ordered.push_back( mpHelp );
+    if ( mpReset )
+        ordered.push_back( mpReset );
+    if ( mpApply )
+        ordered.push_back( mpApply );
+    if ( mpAction )
+        ordered.push_back( mpAction );
+    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
+    if ( mpFlow ) // Always flow? && ( maOther.size () || mpHelp || mpReset || mpAction ) )
+        ordered.push_back( mpFlow );
+    if ( mpAlternate )
+        ordered.push_back( mpAlternate );
+    if ( mpFlow && mpAlternate )
+        ordered.push_back( mpFlow );
+    if ( mpCancel )
+        ordered.push_back( mpCancel );
+    if ( mpAffirmative )
+        ordered.push_back( mpAffirmative );
+    maChildren = ordered;
+}
+
+void
+DialogButtonHBox::windowsOrdering()
+{
+    std::list< ChildData * > ordered;
+    if ( mpReset )
+        ordered.push_back( mpReset );
+    if ( mpReset && mpFlow )
+        ordered.push_back( mpFlow );
+    if ( mpAffirmative )
+        ordered.push_back( mpAffirmative );
+    if ( mpAlternate )
+        ordered.push_back( mpAlternate );
+    if ( mpAction )
+        ordered.push_back( mpAction );
+    if ( mpCancel )
+        ordered.push_back( mpCancel );
+    if ( mpApply )
+        ordered.push_back( mpApply );
+    ordered.insert( ordered.end(), maOther.begin(), maOther.end() );
+    if ( mpHelp )
+        ordered.push_back( mpHelp );
+    maChildren = ordered;
+}
+
+} // namespace layoutimpl
diff --git a/layout/source/core/dialogbuttonhbox.hxx b/layout/source/core/dialogbuttonhbox.hxx
new file mode 100644
index 0000000..debbefa
--- /dev/null
+++ layout/source/core/dialogbuttonhbox.hxx
@@ -0,0 +1,46 @@
+#ifndef CORE_DIALOGBUTTONHBOX_HXX
+#define CORE_DIALOGBUTTONHBOX_HXX
+
+#include "box.hxx"
+#include "flow.hxx"
+
+namespace layoutimpl
+{
+
+class DialogButtonHBox : public HBox
+{
+public:
+    DialogButtonHBox();
+
+    void setOrdering( rtl::OUString const& ordering );
+    void SAL_CALL addChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild ) throw ( css::uno::RuntimeException, css::awt::MaxChildrenException );
+    void SAL_CALL removeChild( css::uno::Reference< css::awt::XLayoutConstrains > const& xChild ) throw ( css::uno::RuntimeException );
+
+private:
+    enum Ordering { PLATFORM, GNOME, KDE, MACOS, WINDOWS };
+
+    void orderChildren();
+    void gnomeOrdering();
+    void kdeOrdering();
+    void macosOrdering();
+    void windowsOrdering();
+
+    static Ordering const DEFAULT_ORDERING;
+    Ordering mnOrdering;
+    Flow mFlow;
+
+    ChildData *mpAction; /* [..]?, [Retry?] */
+    ChildData *mpAffirmative; /* OK, Yes, Save */
+    ChildData *mpAlternate; /* NO, [Ignore?], Don't save, Quit without saving */
+    ChildData *mpApply; /* Deprecated? */
+    ChildData *mpCancel; /* Cancel, Close */
+    ChildData *mpFlow;
+    ChildData *mpHelp;
+    ChildData *mpReset;
+
+    std::list< ChildData *> maOther;
+};
+
+} // namespace layoutimpl
+
+#endif /* CORE_DIALOGBUTTONHBOX_HXX */
diff --git a/layout/source/core/factory.cxx b/layout/source/core/factory.cxx
new file mode 100644
index 0000000..509056e
--- /dev/null
+++ layout/source/core/factory.cxx
@@ -0,0 +1,131 @@
+#include "factory.hxx"
+
+#include <com/sun/star/registry/XRegistryKey.hpp>
+#include <com/sun/star/registry/InvalidRegistryException.hpp>
+#include <cppuhelper/factory.hxx>
+
+#include "root.hxx"
+
+using namespace ::com::sun::star;
+using namespace layoutimpl;
+
+extern "C"
+{
+
+    void SAL_CALL component_getImplementationEnvironment( const sal_Char ** ppEnvTypeName, uno_Environment ** /*ppEnv*/ )
+    {
+        *ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+    }
+
+    void * SAL_CALL component_getFactory( const sal_Char * pImplName, void * pServiceManager, void * /*pRegistryKey*/ )
+    {
+        void * pRet = 0;
+
+        ::rtl::OUString aImplName( ::rtl::OUString::createFromAscii( pImplName ) );
+        uno::Reference< lang::XSingleServiceFactory > xFactory;
+
+        if ( pServiceManager && aImplName.equals( LayoutFactory::impl_staticGetImplementationName() ) )
+            xFactory = ::cppu::createOneInstanceFactory( reinterpret_cast< lang::XMultiServiceFactory*>( pServiceManager ),
+                                                         LayoutFactory::impl_staticGetImplementationName(),
+                                                         LayoutFactory::impl_staticCreateSelfInstance,
+                                                         LayoutFactory::impl_staticGetSupportedServiceNames() );
+        if ( xFactory.is() )
+        {
+            xFactory->acquire();
+            pRet = xFactory.get();
+        }
+
+        return pRet;
+    }
+
+    sal_Bool SAL_CALL component_writeInfo( void * /*pServiceManager*/, void * pRegistryKey )
+    {
+        if (pRegistryKey)
+        {
+            try
+            {
+                uno::Reference< registry::XRegistryKey > xKey( reinterpret_cast< registry::XRegistryKey* >( pRegistryKey ) );
+                uno::Reference< registry::XRegistryKey >  xNewKey;
+
+                xNewKey = xKey->createKey( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("/") ) +
+                                           LayoutFactory::impl_staticGetImplementationName() +
+                                           ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "/UNO/SERVICES") )  );
+
+                const uno::Sequence< ::rtl::OUString > aServices = LayoutFactory::impl_staticGetSupportedServiceNames();
+                for( sal_Int32 i = 0; i < aServices.getLength(); i++ )
+                    xNewKey->createKey( aServices.getConstArray()[i] );
+
+                return sal_True;
+            }
+            catch (registry::InvalidRegistryException &)
+            {   OSL_ENSURE( sal_False, "### InvalidRegistryException!" );   }
+        }
+        return sal_False;
+    }
+
+} // extern "C"
+
+// Component registration
+::rtl::OUString SAL_CALL LayoutFactory::impl_staticGetImplementationName()
+{
+    return ::rtl::OUString::createFromAscii("com.sun.star.comp.awt.Layout");
+}
+
+uno::Sequence< ::rtl::OUString > SAL_CALL LayoutFactory::impl_staticGetSupportedServiceNames()
+{
+    uno::Sequence< ::rtl::OUString > aRet(2);
+    aRet[0] = ::rtl::OUString::createFromAscii("com.sun.star.awt.Layout");
+    aRet[1] = ::rtl::OUString::createFromAscii("com.sun.star.comp.awt.Layout");
+    return aRet;
+}
+
+uno::Reference< uno::XInterface > SAL_CALL LayoutFactory::impl_staticCreateSelfInstance(
+    const uno::Reference< lang::XMultiServiceFactory >& xServiceManager )
+{
+    return uno::Reference< uno::XInterface >( *new LayoutFactory( xServiceManager ) );
+}
+
+// XServiceInfo
+::rtl::OUString SAL_CALL LayoutFactory::getImplementationName()
+    throw ( uno::RuntimeException )
+{
+    return impl_staticGetImplementationName();
+}
+
+uno::Sequence< ::rtl::OUString > SAL_CALL LayoutFactory::getSupportedServiceNames()
+    throw ( uno::RuntimeException )
+{
+    return impl_staticGetSupportedServiceNames();
+}
+
+sal_Bool SAL_CALL LayoutFactory::supportsService( const ::rtl::OUString& ServiceName )
+    throw ( uno::RuntimeException )
+{
+    uno::Sequence< ::rtl::OUString > aSeq = impl_staticGetSupportedServiceNames();
+    for( sal_Int32 i = 0; i < aSeq.getLength(); i++ )
+        if ( ServiceName.compareTo( aSeq[i] ) == 0 )
+            return sal_True;
+
+    return sal_False;
+}
+
+// XSingleServiceFactory
+uno::Reference< uno::XInterface > SAL_CALL LayoutFactory::createInstance()
+    throw ( uno::Exception,
+            uno::RuntimeException )
+{
+    return uno::Reference< uno::XInterface >(
+        static_cast< OWeakObject* >( new LayoutRoot( m_xFactory ) ),
+        uno::UNO_QUERY );
+}
+
+uno::Reference< uno::XInterface > SAL_CALL LayoutFactory::createInstanceWithArguments(
+    const uno::Sequence< uno::Any >& aArguments )
+    throw ( uno::Exception,
+            uno::RuntimeException )
+{
+    uno::Reference< uno::XInterface > layout = createInstance();
+    uno::Reference< lang::XInitialization > xInit( layout, uno::UNO_QUERY );
+    xInit->initialize( aArguments );
+    return layout;
+}
diff --git a/layout/source/core/factory.hxx b/layout/source/core/factory.hxx
new file mode 100644
index 0000000..60b2184
--- /dev/null
+++ layout/source/core/factory.hxx
@@ -0,0 +1,55 @@
+#ifndef FACTORY_HXX_
+#define FACTORY_HXX_
+
+#ifndef _COM_SUN_STAR_LANG_XSINGLESERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XSingleServiceFactory.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#endif
+
+
+#ifndef _CPPUHELPER_IMPLBASE2_HXX_
+#include <cppuhelper/implbase2.hxx>
+#endif
+
+namespace layoutimpl
+{
+class Layout;
+}
+
+class LayoutFactory : public ::cppu::WeakImplHelper2< ::com::sun::star::lang::XSingleServiceFactory,
+                                                      ::com::sun::star::lang::XServiceInfo >
+{
+    ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > m_xFactory;
+
+public:
+    LayoutFactory( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xFactory )
+        : m_xFactory( xFactory )
+    {
+        OSL_ENSURE( xFactory.is(), "No service manager is provided!\n" );
+    }
+
+    static ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL
+    impl_staticGetSupportedServiceNames();
+
+    static ::rtl::OUString SAL_CALL impl_staticGetImplementationName();
+
+    static ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL
+    impl_staticCreateSelfInstance(
+        const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >& xServiceManager );
+
+
+    // XSingleServiceFactory
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL createInstance() throw (::com::sun::star::uno::Exception, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL createInstanceWithArguments( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aArguments ) throw (::com::sun::star::uno::Exception, ::com::sun::star::uno::RuntimeException);
+
+    // XServiceInfo
+    virtual ::rtl::OUString SAL_CALL getImplementationName() throw (::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) throw (::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames() throw (::com::sun::star::uno::RuntimeException);
+
+};
+
+#endif /* FACTORY_HXX */
diff --git a/layout/source/core/flow.cxx b/layout/source/core/flow.cxx
new file mode 100644
index 0000000..c8573c8
--- /dev/null
+++ layout/source/core/flow.cxx
@@ -0,0 +1,176 @@
+#include "flow.hxx"
+
+#include <sal/macros.h>
+
+namespace layoutimpl
+{
+
+using namespace css;
+
+bool Flow::ChildData::isVisible()
+{
+    return xChild.is();
+}
+
+Flow::Flow()
+    : Container()
+    , mnSpacing( 0 )
+    , mbHomogeneous( false )
+{
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Homogeneous" ),
+             ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+             &mbHomogeneous );
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Spacing" ),
+             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+             &mnSpacing );
+}
+
+void SAL_CALL
+Flow::addChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw (uno::RuntimeException, css::awt::MaxChildrenException)
+{
+    if ( xChild.is() )
+    {
+        ChildData *pData = new ChildData();
+        pData->xChild = xChild;
+        maChildren.push_back( pData );
+
+        setChildParent( xChild );
+        queueResize();
+    }
+}
+
+void SAL_CALL
+Flow::removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& xChild )
+    throw (css::uno::RuntimeException)
+{
+    for( std::list< ChildData * >::iterator it = maChildren.begin();
+         it != maChildren.end(); it++ )
+    {
+        if ( (*it)->xChild == xChild )
+        {
+            delete *it;
+            maChildren.erase( it );
+
+            unsetChildParent( xChild );
+            queueResize();
+            break;
+        }
+    }
+}
+
+css::uno::Sequence< css::uno::Reference < css::awt::XLayoutConstrains > > SAL_CALL
+Flow::getChildren()
+    throw (css::uno::RuntimeException)
+{
+    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > children( maChildren.size() );
+    unsigned int i = 0;
+    for( std::list< ChildData * >::iterator it = maChildren.begin();
+         it != maChildren.end(); it++, i++ )
+        children[i] = (*it)->xChild;
+
+    return children;
+}
+
+uno::Reference< beans::XPropertySet > SAL_CALL
+Flow::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& /*xChild*/ )
+    throw (uno::RuntimeException)
+{
+    return uno::Reference< beans::XPropertySet >();
+}
+
+css::awt::Size
+Flow::calculateSize( long nMaxWidth )
+{
+    long nNeedHeight = 0;
+
+    std::list<ChildData *>::const_iterator it;
+    mnEachWidth = 0;
+    // first pass, for homogeneous property
+    for (it = maChildren.begin(); it != maChildren.end(); it++)
+    {
+        if ( !(*it)->isVisible() )
+            continue;
+        (*it)->aRequisition = (*it)->xChild->getMinimumSize();
+        if ( mbHomogeneous )
+            mnEachWidth = SAL_MAX( mnEachWidth, (*it)->aRequisition.Width );
+    }
+
+    long nRowWidth = 0, nRowHeight = 0;
+    for (it = maChildren.begin(); it != maChildren.end(); it++)
+    {
+        if ( !(*it)->isVisible() )
+            continue;
+
+        awt::Size aChildSize = (*it)->aRequisition;
+        if ( mbHomogeneous )
+            aChildSize.Width = mnEachWidth;
+
+        if ( nMaxWidth && nRowWidth > 0 && nRowWidth + aChildSize.Width > nMaxWidth )
+        {
+            nRowWidth = 0;
+            nNeedHeight += nRowHeight;
+            nRowHeight = 0;
+        }
+        nRowHeight = SAL_MAX( nRowHeight, aChildSize.Height );
+        nRowWidth += aChildSize.Width;
+    }
+    nNeedHeight += nRowHeight;
+
+    return awt::Size( nRowWidth, nNeedHeight );
+}
+
+awt::Size SAL_CALL
+Flow::getMinimumSize() throw(uno::RuntimeException)
+{
+    return maRequisition = calculateSize( 0 );
+}
+
+sal_Bool SAL_CALL
+Flow::hasHeightForWidth()
+    throw(css::uno::RuntimeException)
+{
+    return true;
+}
+
+sal_Int32 SAL_CALL
+Flow::getHeightForWidth( sal_Int32 nWidth )
+    throw(css::uno::RuntimeException)
+{
+    return calculateSize( nWidth ).Height;
+}
+
+void SAL_CALL
+Flow::allocateArea( const css::awt::Rectangle &rArea )
+    throw (css::uno::RuntimeException)
+{
+    maAllocation = rArea;
+
+    std::list<ChildData *>::const_iterator it;
+    long nX = 0, nY = 0, nRowHeight = 0;
+    for (it = maChildren.begin(); it != maChildren.end(); it++)
+    {
+        ChildData *child = *it;
+        if ( !child->isVisible() )
+            continue;
+
+        awt::Size aChildSize( child->aRequisition );
+        if ( mbHomogeneous )
+            aChildSize.Width = mnEachWidth;
+
+        if ( nX > 0 && nX + aChildSize.Width > rArea.Width )
+        {
+            nX = 0;
+            nY += nRowHeight;
+            nRowHeight = 0;
+        }
+        nRowHeight = SAL_MAX( nRowHeight, aChildSize.Height );
+
+        allocateChildAt( child->xChild,
+                         awt::Rectangle( rArea.X + nX, rArea.Y + nY, aChildSize.Width, aChildSize.Height ) );
+
+        nX += aChildSize.Width;
+    }
+}
+
+} // namespace layoutimpl
diff --git a/layout/source/core/flow.hxx b/layout/source/core/flow.hxx
new file mode 100644
index 0000000..8e21e86
--- /dev/null
+++ layout/source/core/flow.hxx
@@ -0,0 +1,65 @@
+#ifndef CORE_FLOW_HXX
+#define CORE_FLOW_HXX
+
+#include "container.hxx"
+
+#include <list>
+
+namespace layoutimpl
+{
+
+class Flow : public Container
+{
+protected:
+    // Box properties (i.e. affect all children)
+    sal_Int32 mnSpacing;
+    sal_Bool mbHomogeneous;
+
+    // Children properties
+    struct ChildData
+    {
+        css::awt::Size aRequisition;
+        css::uno::Reference< css::awt::XLayoutConstrains > xChild;
+        css::uno::Reference< css::beans::XPropertySet >    xProps;
+        bool isVisible();
+    };
+    std::list< ChildData * > maChildren;
+    long mnEachWidth;  // on homogeneous, the width of every child
+
+public:
+    Flow();
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
+    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Sequence< css::uno::Reference
+                                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
+        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 nWidth )
+        throw(css::uno::RuntimeException);
+
+PROPHELPER_SET_INFO
+
+private:
+    // shared between getMinimumSize() and getHeightForWidth()
+    css::awt::Size calculateSize( long nMaxWidth );
+};
+
+} //  namespace layoutimpl
+
+#endif /*FLOW_CORE_HXX*/
diff --git a/layout/source/core/helper.cxx b/layout/source/core/helper.cxx
new file mode 100644
index 0000000..2b31f06
--- /dev/null
+++ layout/source/core/helper.cxx
@@ -0,0 +1,538 @@
+#include "helper.hxx"
+
+#include <assert.h>
+#include <list>
+#include <com/sun/star/awt/WindowAttribute.hpp>
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/awt/VclWindowPeerAttribute.hpp>
+#include <tools/debug.hxx>
+
+#include "proplist.hxx"
+#include "layoutcore.hxx"
+
+#if TEST_LAYOUT && !defined( DBG_UTIL )
+#include <stdio.h>
+#undef DBG_ERROR
+#define DBG_ERROR printf
+#undef DBG_ERROR1
+#define DBG_ERROR1 printf
+#undef DBG_ERROR2
+#define DBG_ERROR2 printf
+#endif /* TEST_LAYOUT && !DBG_UTIL */
+
+namespace layoutimpl
+{
+using namespace com::sun::star;
+using rtl::OUString;
+
+uno::Reference< awt::XWindowPeer >
+getParent( uno::Reference< uno::XInterface > xRef )
+{
+    do
+    {
+        uno::Reference< awt::XWindowPeer > xPeer( xRef, uno::UNO_QUERY );
+        if ( xPeer.is() )
+            return xPeer;
+
+        uno::Reference< awt::XLayoutContainer > xCont( xRef, uno::UNO_QUERY );
+        if ( xCont.is() )
+            xRef = xCont->getParent();
+    }
+    while ( xRef.is() );
+
+    return uno::Reference< awt::XWindowPeer >();
+}
+
+#if 0
+static uno::Reference< awt::XWindowPeer >
+getToplevel( uno::Reference< uno::XInterface > xRef )
+{
+    uno::Reference< awt::XWindowPeer > xTop, i;
+    while ( ( i = uno::Reference< awt::XWindowPeer >( xRef, uno::UNO_QUERY ) ).is() )
+    {
+        xTop = i;
+
+        uno::Reference< awt::XLayoutContainer > xCont( xRef, uno::UNO_QUERY );
+        if ( xCont.is() )
+            xRef = xCont->getParent();
+        else
+            xRef = uno::Reference< awt::XWindowPeer >();
+    }
+
+    return xTop;
+}
+#endif
+
+}
+
+#include "dialogbuttonhbox.hxx"
+#include "bin.hxx"
+#include "box.hxx"
+#include "table.hxx"
+#include "flow.hxx"
+
+namespace layoutimpl
+{
+
+static uno::Reference< awt::XLayoutConstrains > ImplCreateWindow(
+    uno::Reference< uno::XInterface > xParent,
+    OUString aName, long WindowAttributes );
+
+uno::Reference< awt::XLayoutContainer >
+createContainer( const OUString &rName )
+{
+    uno::Reference< awt::XLayoutContainer > xPeer;
+
+    if ( rName.equalsAscii( "hbox" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new HBox() );
+    else if ( rName.equalsAscii( "vbox" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new VBox() );
+    else if ( rName.equalsAscii( "table" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new Table() );
+    else if ( rName.equalsAscii( "flow" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new Flow() );
+    else if ( rName.equalsAscii( "bin" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new Bin() );
+    else if ( rName.equalsAscii( "min-size" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new MinSize() );
+    else if ( rName.equalsAscii( "align" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new Align() );
+    else if ( rName.equalsAscii( "dialogbuttonhbox" ) )
+        xPeer = uno::Reference< awt::XLayoutContainer >( new DialogButtonHBox() );
+
+    return xPeer;
+}
+
+static uno::Reference< awt::XLayoutConstrains >
+createToolkitWidget( uno::Reference< awt::XToolkit > xToolkit,
+                     uno::Reference< uno::XInterface > xParent,
+                     const OUString &rName, long nProps )
+{
+    uno::Reference< awt::XLayoutConstrains > xPeer;
+    bool bToplevel = !xParent.is();
+
+    // UNO Control Widget
+    awt::WindowDescriptor desc;
+    if ( bToplevel )
+        desc.Type = awt::WindowClass_TOP;
+    else
+    {
+        desc.Type = awt::WindowClass_SIMPLE;
+
+        // top container -- a wrapper for framewindow -- is de-coupled
+        // from awt::XWindowPeer. So, getParent() fails at it.
+//            uno::Reference< awt::XWindowPeer > xWinParent = getParent( xParent );
+
+        uno::Reference< awt::XWindowPeer > xWinParent( xParent, uno::UNO_QUERY );
+
+        assert( xParent.is() );
+        assert( xWinParent.is() );
+        desc.Parent = xWinParent;
+    }
+
+    desc.ParentIndex = 0;
+    // debugging help ...
+    desc.Bounds.X = 0;
+    desc.Bounds.Y = 0;
+    desc.Bounds.Width = 300;
+    desc.Bounds.Height = 200;
+
+    desc.WindowAttributes = nProps;
+    desc.WindowServiceName = rName;
+
+    uno::Reference< awt::XWindowPeer > xWinPeer;
+    try
+    {
+        xWinPeer = xToolkit->createWindow( desc );
+        if ( !xWinPeer.is() )
+            throw uno::RuntimeException(
+                OUString( RTL_CONSTASCII_USTRINGPARAM( "Cannot create peer" ) ),
+                uno::Reference< uno::XInterface >() );
+        xPeer = uno::Reference< awt::XLayoutConstrains >( xWinPeer, uno::UNO_QUERY );
+    }
+    catch( uno::Exception &ex )
+    {
+        DBG_ERROR1( "Warning:  %s is not a recognized type", OUSTRING_CSTR( rName ) );
+        return uno::Reference< awt::XLayoutConstrains >();
+    }
+
+    // default to visible, let then people change it on properties
+    if ( ! bToplevel )
+    {
+        uno::Reference< awt::XWindow> xWindow( xPeer, uno::UNO_QUERY );
+        if ( xWindow.is() )
+            xWindow->setVisible( true );
+    }
+    return xPeer;
+}
+
+uno::Reference< awt::XLayoutConstrains >
+createWidget( uno::Reference< awt::XToolkit > xToolkit,
+              uno::Reference< uno::XInterface > xParent,
+              const OUString &rName, long nProps )
+{
+    uno::Reference< awt::XLayoutConstrains > xPeer;
+
+    xPeer = uno::Reference< awt::XLayoutConstrains >(
+        createContainer( rName ), uno::UNO_QUERY );
+    if ( xPeer.is() )
+        return xPeer;
+
+    xPeer = ImplCreateWindow( xParent, rName, nProps );
+    if ( xPeer.is() )
+        return xPeer;
+
+    xPeer = createInternalWidget( xToolkit, xParent, rName, nProps );
+    if ( xPeer.is() )
+        return xPeer;
+
+#if FIXED_INFO
+    OUString tName = rName;
+    // FIXME
+    if ( rName.equalsAscii( "fixedinfo" ) )
+        tName = OUString::createFromAscii( "fixedtext" );
+    xPeer = createToolkitWidget( xToolkit, xParent, tName, nProps );
+#else
+    xPeer = createToolkitWidget( xToolkit, xParent, rName, nProps );
+#endif
+    return xPeer;
+}
+
+PropHelper::PropHelper() : LockHelper()
+                         , cppu::OPropertySetHelper( maBrdcstHelper )
+                         , pHelper( NULL )
+{
+}
+
+void
+PropHelper::addProp (const char *pName, sal_Int32 nNameLen, rtl_TextEncoding e,
+                     uno::Type aType, void *pPtr)
+{
+    // this sucks rocks for effiency ...
+    PropDetails aDetails;
+    aDetails.aName = rtl::OUString::intern( pName, nNameLen, e );
+    aDetails.aType = aType;
+    aDetails.pValue = pPtr;
+    maDetails.push_back( aDetails );
+}
+
+cppu::IPropertyArrayHelper & SAL_CALL
+PropHelper::getInfoHelper()
+{
+    if ( ! pHelper )
+    {
+        uno::Sequence< beans::Property > aProps( maDetails.size() );
+        for( unsigned int i = 0; i < maDetails.size(); i++)
+        {
+            aProps[i].Name = maDetails[i].aName;
+            aProps[i].Type = maDetails[i].aType;
+            aProps[i].Handle = i;
+            aProps[i].Attributes = 0;
+        }
+        pHelper = new cppu::OPropertyArrayHelper( aProps, false /* fixme: faster ? */ );
+
+    }
+    return *pHelper;
+}
+
+sal_Bool SAL_CALL
+PropHelper::convertFastPropertyValue(
+    uno::Any & rConvertedValue,
+    uno::Any & rOldValue,
+    sal_Int32 nHandle,
+    const uno::Any& rValue )
+    throw (lang::IllegalArgumentException)
+{
+    OSL_ASSERT( nHandle >= 0 && nHandle < (sal_Int32) maDetails.size() );
+
+    // FIXME: no Any::getValue ...
+    getFastPropertyValue( rOldValue, nHandle );
+    if ( rOldValue != rValue )
+    {
+        rConvertedValue = rValue;
+        return sal_True; // changed
+    }
+    else
+    {
+        rConvertedValue.clear();
+        rOldValue.clear();
+    }
+    return sal_False;
+}
+
+
+void SAL_CALL
+PropHelper::setFastPropertyValue_NoBroadcast( sal_Int32 nHandle,
+                                              const uno::Any& rValue )
+    throw (uno::Exception)
+{
+    OSL_ASSERT( nHandle >= 0 && nHandle < (sal_Int32) maDetails.size() );
+
+    const PropDetails &rInfo = maDetails[ nHandle ];
+
+    uno_type_assignData( rInfo.pValue, rInfo.aType.getTypeLibType(),
+                         rValue.pData, rValue.pType,
+                         0, 0, 0 );
+
+    if ( mpListener )
+        mpListener->propertiesChanged();
+}
+
+void SAL_CALL
+PropHelper::getFastPropertyValue( uno::Any& rValue,
+                                  sal_Int32 nHandle ) const
+{
+    OSL_ASSERT( nHandle >= 0 && nHandle < (sal_Int32) maDetails.size() );
+    const PropDetails &rInfo = maDetails[ nHandle ];
+#if 0
+    switch ( rInfo.aType.getTypeClass() )
+    {
+#define MAP(classtype,ctype)                        \
+        case uno::TypeClass_##classtype:       \
+            rValue <<= *(ctype *)(rInfo.pValue);    \
+        break
+        MAP( DOUBLE, double );
+        MAP( SHORT, sal_Int16 );
+        MAP( LONG,  sal_Int32 );
+        MAP( UNSIGNED_SHORT, sal_uInt16 );
+        MAP( UNSIGNED_LONG, sal_uInt32 );
+        MAP( STRING, ::rtl::OUString );
+        default:
+            DBG_ERROR( "ERROR: unknown type to map!" );
+            break;
+    }
+#undef MAP
+#endif
+    rValue.setValue( rInfo.pValue, rInfo.aType );
+}
+
+::com::sun::star::uno::Any
+PropHelper::queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException)
+{
+    return OPropertySetHelper::queryInterface( rType );
+}
+
+} // namespace layoutimpl
+
+
+/*
+ * -------------------------- cut and paste from vclxtoolkit --------------------------
+ * to reduce dependencies ... axe on merge ...
+ */
+
+#include "../awt/vclxproxy.hxx"
+#include <toolkit/awt/vclxwindow.hxx>
+#include <vcl/tabctrl.hxx>
+#include "../awt/vclxtabcontrol.hxx"
+#include <vcl/dialog.hxx>
+#include "../awt/vclxdialog.hxx"
+#include <vcl/fixed.hxx>
+#include "../awt/vclxscroller.hxx"
+#include "../awt/vclxsplitter.hxx"
+#include "../awt/vclxfixedline.hxx"
+#include <vcl/tabpage.hxx>
+
+namespace layoutimpl
+{
+
+WinBits ImplGetWinBits( sal_uInt32 nComponentAttribs, sal_uInt16 nCompType )
+{
+    WinBits nWinBits = 0;
+
+    sal_Bool bMessBox = sal_False;
+    if ( ( nCompType == WINDOW_INFOBOX ) ||
+( nCompType == WINDOW_MESSBOX ) ||
+( nCompType == WINDOW_QUERYBOX ) ||
+( nCompType == WINDOW_WARNINGBOX ) ||
+( nCompType == WINDOW_ERRORBOX ) )
+    {
+        bMessBox = sal_True;
+    }
+
+    if ( nComponentAttribs & ::com::sun::star::awt::WindowAttribute::BORDER )
+        nWinBits |= WB_BORDER;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::NOBORDER )
+        nWinBits |= WB_NOBORDER;
+    if ( nComponentAttribs & ::com::sun::star::awt::WindowAttribute::SIZEABLE )
+        nWinBits |= WB_SIZEABLE;
+    if ( nComponentAttribs & ::com::sun::star::awt::WindowAttribute::MOVEABLE )
+        nWinBits |= WB_MOVEABLE;
+    if ( nComponentAttribs & ::com::sun::star::awt::WindowAttribute::CLOSEABLE )
+        nWinBits |= WB_CLOSEABLE;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::HSCROLL )
+        nWinBits |= WB_HSCROLL;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::VSCROLL )
+        nWinBits |= WB_VSCROLL;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::LEFT )
+        nWinBits |= WB_LEFT;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::CENTER )
+        nWinBits |= WB_CENTER;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::RIGHT )
+        nWinBits |= WB_RIGHT;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::SPIN )
+        nWinBits |= WB_SPIN;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::SORT )
+        nWinBits |= WB_SORT;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::DROPDOWN )
+        nWinBits |= WB_DROPDOWN;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::DEFBUTTON )
+        nWinBits |= WB_DEFBUTTON;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::READONLY )
+        nWinBits |= WB_READONLY;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::CLIPCHILDREN )
+        nWinBits |= WB_CLIPCHILDREN;
+    if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::GROUP )
+        nWinBits |= WB_GROUP;
+
+    // These bits are not uniqe
+    if ( bMessBox )
+    {
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::OK )
+            nWinBits |= WB_OK;
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::OK_CANCEL )
+            nWinBits |= WB_OK_CANCEL;
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::YES_NO )
+            nWinBits |= WB_YES_NO;
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::YES_NO_CANCEL )
+            nWinBits |= WB_YES_NO_CANCEL;
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::RETRY_CANCEL )
+            nWinBits |= WB_RETRY_CANCEL;
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::DEF_OK )
+            nWinBits |= WB_DEF_OK;
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::DEF_CANCEL )
+            nWinBits |= WB_DEF_CANCEL;
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::DEF_RETRY )
+            nWinBits |= WB_DEF_RETRY;
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::DEF_YES )
+            nWinBits |= WB_DEF_YES;
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::DEF_NO )
+            nWinBits |= WB_DEF_NO;
+    }
+
+    if ( nCompType == WINDOW_MULTILINEEDIT )
+    {
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::AUTOHSCROLL )
+            nWinBits |= WB_AUTOHSCROLL;
+        if ( nComponentAttribs & ::com::sun::star::awt::VclWindowPeerAttribute::AUTOVSCROLL )
+            nWinBits |= WB_AUTOVSCROLL;
+    }
+
+
+    if ( nComponentAttribs & ::com::sun::star::awt::WindowAttribute::NODECORATION )
+    {
+        // No decoration removes several window attributes and must
+        // set WB_NOBODER!
+        nWinBits &= ~WB_BORDER;
+        nWinBits &= ~WB_SIZEABLE;
+        nWinBits &= ~WB_MOVEABLE;
+        nWinBits &= ~WB_CLOSEABLE;
+        nWinBits |= WB_NOBORDER;
+    }
+
+    return nWinBits;
+}
+
+uno::Reference< awt::XLayoutConstrains > ImplCreateWindow(
+    uno::Reference< uno::XInterface > xParent,
+    OUString aName, long WindowAttributes )
+{
+    VCLXWindow *pNewComp = NULL;
+    Window     *pNewWindow = NULL;
+    Window     *pParent = NULL;
+    uno::Reference< awt::XLayoutConstrains > xRef;
+
+    VCLXWindow* pParentComponent = VCLXWindow::GetImplementation( xParent );
+    if ( pParentComponent )
+        pParent = pParentComponent->GetWindow();
+
+    if ( aName.equalsAscii( "dialog" ) )
+    {
+        if ( pParent == NULL )
+            // DIALOG_NO_PARENT == 0xffff
+            // it would crash otherwise
+// FIXME: check for crash
+            pParent = DIALOG_NO_PARENT; /*DIALOG_NO_PARENT == 0xffff ?! :P*/
+        pNewWindow = new Dialog( pParent,
+                                 ImplGetWinBits( WindowAttributes, 0 ) );
+        pNewComp = new layoutimpl::VCLXDialog();
+
+        WindowAttributes ^= awt::WindowAttribute::SHOW;
+    }
+    else if ( aName.equalsAscii( "modaldialog" ) )
+    {
+        if ( pParent == NULL )
+            pParent = DIALOG_NO_PARENT;
+        pNewWindow = new ModalDialog( pParent,
+                                      ImplGetWinBits( WindowAttributes, 0 ) );
+        pNewComp = new layoutimpl::VCLXDialog();
+
+        WindowAttributes ^= awt::WindowAttribute::SHOW;
+    }
+    else if ( aName.equalsAscii( "tabcontrol" ) )
+    {
+        pNewWindow = new TabControl( pParent,
+                                     ImplGetWinBits( WindowAttributes, WINDOW_TABCONTROL ) );
+        pNewComp = new layoutimpl::VCLXTabControl();
+    }
+    else if ( aName.equalsAscii( "scroller" ) )
+    {
+        // used FixedImage because I just want some empty non-intrusive widget
+        pNewWindow = new FixedImage( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
+        pNewComp = new layoutimpl::VCLXScroller();
+    }
+    else if ( aName.equalsAscii( "hsplitter" ) || aName.equalsAscii( "vsplitter" ) )
+    {
+        pNewWindow = new FixedImage( pParent, ImplGetWinBits( WindowAttributes, 0 ) );
+        pNewComp = new layoutimpl::VCLXSplitter( aName.equalsAscii( "hsplitter" ) );
+    }
+    else if ( aName.equalsAscii( "hfixedline" ) || aName.equalsAscii( "vfixedline" ) )
+    {
+        WinBits nStyle = ImplGetWinBits( WindowAttributes, 0 );
+        nStyle ^= WB_HORZ;
+        if ( aName.equalsAscii( "hfixedline" ) )
+            nStyle |= WB_HORZ;
+        else
+            nStyle |= WB_VERT;
+        pNewWindow = new FixedLine( pParent, nStyle );
+        pNewComp = new layoutimpl::VCLXFixedLine();
+    }
+
+    if ( !pNewWindow )
+        return xRef;
+
+    pNewWindow->SetCreatedWithToolkit( sal_True );
+    pNewComp->SetCreatedWithToolkit( TRUE );
+    xRef = pNewComp;
+    pNewWindow->SetComponentInterface( pNewComp );
+    if ( WindowAttributes & awt::WindowAttribute::SHOW )
+        pNewWindow->Show();
+
+    return xRef;
+}
+
+} // namespace layoutimpl
+
+// Avoid polluting the rest of the code with vcl linkage pieces ...
+
+#include <vcl/imagerepository.hxx>
+#include <vcl/bitmapex.hxx>
+#include <vcl/graph.hxx>
+
+namespace layoutimpl
+{
+
+uno::Reference< graphic::XGraphic > loadGraphic( const char *pName )
+{
+    BitmapEx aBmp;
+
+    OUString aStr( pName, strlen( pName ), RTL_TEXTENCODING_ASCII_US );
+    if ( aStr.compareToAscii( ".uno:" ) == 0 )
+        aStr = aStr.copy( 5 ).toAsciiLowerCase();
+
+    if ( !vcl::ImageRepository::loadImage( OUString::createFromAscii( pName ), aBmp, true ) )
+        return uno::Reference< graphic::XGraphic >();
+
+    return Graphic( aBmp ).GetXGraphic();
+}
+
+} // namespace layoutimpl
diff --git a/layout/source/core/helper.hxx b/layout/source/core/helper.hxx
new file mode 100644
index 0000000..38f791c
--- /dev/null
+++ layout/source/core/helper.hxx
@@ -0,0 +1,122 @@
+#ifndef HELPER_HXX
+#define HELPER_HXX
+
+#include <vector>
+
+#include <com/sun/star/awt/XLayoutConstrains.hpp>
+#include <com/sun/star/awt/XLayoutContainer.hpp>
+#include <com/sun/star/awt/XVclWindowPeer.hpp>
+#include <com/sun/star/xml/input/XRoot.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <cppuhelper/propshlp.hxx>
+#include <rtl/ustring.hxx>
+
+namespace layoutimpl
+{
+
+namespace css = ::com::sun::star;
+
+/* ChildProps -- a helper to set child properties for the XLayoutContainer interface. */
+
+class LockHelper
+{
+public:
+    osl::Mutex               maGuard;
+    cppu::OBroadcastHelper maBrdcstHelper;
+    LockHelper() : maBrdcstHelper( maGuard )
+    {
+    }
+};
+
+class PropHelper : public LockHelper
+                 , public cppu::OPropertySetHelper
+                 , public cppu::OWeakObject
+{
+    cppu::OPropertyArrayHelper *pHelper;
+
+    struct PropDetails
+    {
+        rtl::OUString  aName;
+        css::uno::Type aType;
+        void          *pValue;
+    };
+    std::vector< PropDetails > maDetails;
+
+protected:
+    void addProp( char const *pName, sal_Int32 nNameLen, rtl_TextEncoding e,
+                  css::uno::Type aType, void *pPtr );
+
+public:
+    PropHelper();
+
+    // com::sun::star::uno::XInterface
+    void SAL_CALL acquire() throw() { OWeakObject::acquire(); }
+    void SAL_CALL release() throw() { OWeakObject::release(); }
+    ::com::sun::star::uno::Any SAL_CALL queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException);
+
+    // cppu::OPropertySetHelper
+    virtual cppu::IPropertyArrayHelper & SAL_CALL getInfoHelper();
+    virtual sal_Bool SAL_CALL convertFastPropertyValue( css::uno::Any &,
+                                                        css::uno::Any &, sal_Int32 nHandle, const css::uno::Any & )
+        throw(css::lang::IllegalArgumentException);
+    virtual void SAL_CALL setFastPropertyValue_NoBroadcast( sal_Int32 nHandle,
+                                                            const css::uno::Any& rValue ) throw (css::uno::Exception);
+    virtual void SAL_CALL getFastPropertyValue( css::uno::Any& rValue,
+                                                sal_Int32 nHandle ) const;
+
+    // you -must- use this macro in sub-classes that define new properties.
+    // NB. 'static' ...
+    // com::sun::star::beans::XMultiPropertySet
+#define PROPHELPER_SET_INFO \
+    css::uno::Reference< css::beans::XPropertySetInfo > SAL_CALL \
+    getPropertySetInfo() throw(css::uno::RuntimeException) \
+    { \
+        static css::uno::Reference< css::beans::XPropertySetInfo > xInfo( \
+            createPropertySetInfo( getInfoHelper() ) ); \
+        return xInfo; \
+    }
+    PROPHELPER_SET_INFO
+
+    struct Listener
+    {
+        virtual void propertiesChanged() = 0;
+    };
+    void setChangeListener( Listener *pListener )
+    {
+        mpListener = pListener;
+    }
+
+protected:
+    Listener *mpListener;
+};
+
+css::uno::Any anyFromString (const rtl::OUString &value, const css::uno::Type &type);
+
+// The native widgets wrapper hierarchy may not reflect that of the layout
+// hierarchy as some containers don't have an associated native widget.
+// Use this function to get the native parent of the given peer.
+css::uno::Reference< css::awt::XWindowPeer >
+getParent( css::uno::Reference< css::uno::XInterface > xPeer );
+
+
+struct WidgetFactory
+{
+    virtual css::uno::Reference< css::awt::XLayoutConstrains >
+    createWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
+                  css::uno::Reference< css::uno::XInterface > xParent,
+                  const rtl::OUString &rName, long nProps );
+};
+
+// A local factory method - should use UNO services in due course
+css::uno::Reference< css::awt::XLayoutConstrains >
+createWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
+              css::uno::Reference< css::uno::XInterface > xParent,
+              const rtl::OUString &rName, long nProps );
+
+// Factory for containers (not visible ones)
+css::uno::Reference< css::awt::XLayoutContainer >
+createContainer( const rtl::OUString &rName );
+
+} // namespace layoutimpl
+
+#endif /* HELPER_HXX */
diff --git a/layout/source/core/import.cxx b/layout/source/core/import.cxx
new file mode 100644
index 0000000..2b805e8
--- /dev/null
+++ layout/source/core/import.cxx
@@ -0,0 +1,187 @@
+#include "import.hxx"
+
+#include <com/sun/star/awt/XDialog2.hpp>
+#include <tools/debug.hxx>
+
+#include "root.hxx"
+#include "helper.hxx"
+#include "dialogbuttonhbox.hxx"
+
+
+#define XMLNS_LAYOUT_URI    "http://openoffice.org/2007/layout"
+#define XMLNS_CONTAINER_URI "http://openoffice.org/2007/layout/container"
+
+namespace layoutimpl
+{
+using namespace css;
+
+using ::rtl::OUString;
+
+ElementBase::~ElementBase()
+SAL_THROW( () )
+{
+    //delete mpImport;
+    //mpImport = 0;
+}
+
+//** parser
+WidgetElement::WidgetElement (sal_Int32 nUid, const OUString &rName,
+                              const uno::Reference <xml::input::XAttributes> &attributes,
+                              ElementBase *pParent,
+                              ImportContext *pImport)
+SAL_THROW (())
+: ElementBase( nUid, rName, attributes, pParent, pImport )
+{
+    OUString name = rName.toAsciiLowerCase();
+
+    PropList aProps;
+    propsFromAttributes( attributes, aProps, pImport->XMLNS_LAYOUT_UID );
+
+    OUString aId;
+    findAndRemove( "id", aProps, aId );
+
+    {
+//DEBUG
+        uno::Reference< awt::XLayoutConstrains > xParent;
+        if ( pParent )
+            xParent = ((WidgetElement *) pParent)->mpWidget->getPeer();
+
+
+        mpWidget = pImport->mrRoot.create( aId, name,
+                                           getAttributeProps( aProps ), uno::Reference< awt::XLayoutContainer >( xParent, uno::UNO_QUERY ) );
+
+    }
+
+    // TODO: handle with non-existing widgets
+
+    mpWidget->setProperties( aProps );
+
+    uno::Reference< awt::XDialog2 > xDialog( mpWidget->getPeer(), uno::UNO_QUERY );
+    if ( xDialog.is() )
+    {
+        OUString aTitle;
+        if ( findAndRemove( "title", aProps, aTitle ) )
+            xDialog->setTitle( aTitle );
+    } // DEBUG:
+    else if ( pParent == NULL )
+    {
+        DBG_ERROR( "Fatal error: top node isn't a dialog" );
+    }
+
+    bool bOrdering;
+    OUString aOrdering;
+    bOrdering = findAndRemove( "ordering", aProps, aOrdering );
+    if ( DialogButtonHBox *b = dynamic_cast<DialogButtonHBox *> ( mpWidget->getPeer().get() ) )
+    {
+        if ( bOrdering )
+            b->setOrdering ( aOrdering );
+    }
+
+#ifdef IMPORT_RADIOGROUP
+    bool bSetRadioGroup, bSetTitle;
+    OUString aRadioGroup, aTitle;
+    bSetRadioGroup = findAndRemove( "radiogroup", aProps, aRadioGroup );
+    bSetTitle = findAndRemove( "title", aProps, aTitle );
+
+    setProperties( mxPeer, aProps );
+
+    // we need to add radio buttons to the group after their properties are
+    // set, so we can check if they should be the one selected by default or not.
+    // And the state changed event isn't fired when changing properties.
+    if ( bSetRadioGroup )
+    {
+        static int i = 0;
+        i++;
+        uno::Reference< awt::XRadioButton > xRadio( mxPeer, uno::UNO_QUERY );
+        if ( xRadio.is() )
+            pImport->mxRadioGroups.addItem( aRadioGroup, xRadio );
+    }
+    if ( bSetTitle )
+    {
+        uno::Reference< awt::XDialog2 > xDialog( mxPeer, uno::UNO_QUERY );
+        if ( xDialog.is() )
+            xDialog->setTitle( aTitle );
+    }
+#endif
+}
+
+WidgetElement::~WidgetElement()
+{
+    //delete mpWidget;
+    //mpWidget = 0;
+}
+
+uno::Reference <xml::input::XElement>
+WidgetElement::startChildElement (sal_Int32 nUid, OUString const &name,
+                                  uno::Reference <xml::input::XAttributes> const &attributes)
+    throw( xml::sax::SAXException, uno::RuntimeException )
+{
+    // Adding a child to the widget
+    WidgetElement *pChild = new WidgetElement (nUid, name, attributes, this, mpImport);
+
+    if ( !mpWidget->addChild( pChild->mpWidget ) )
+    {
+        DBG_ERROR2("ERROR: cannot add %s to container %s, container full", OUSTRING_CSTR( name ), OUSTRING_CSTR( getLocalName() ) );
+        throw xml::sax::SAXException();
+    }
+
+    PropList aProps;
+    propsFromAttributes( attributes, aProps, mpImport->XMLNS_CONTAINER_UID );
+    mpWidget->setChildProperties( pChild->mpWidget, aProps );
+
+    return pChild;
+}
+
+// ---- ElementBase ----
+
+ElementBase::ElementBase(sal_Int32 nUid, OUString const & rLocalName,
+                         uno::Reference< xml::input::XAttributes > const & xAttributes,
+                         ElementBase * pParent,
+                         ImportContext * pImport )
+SAL_THROW(())
+: mpImport( pImport )
+    , mpParent( pParent )
+    , mnUid( nUid )
+    , maLocalName( rLocalName )
+    , mxAttributes( xAttributes )
+{
+}
+
+// ---- ImportContext ----
+
+void ImportContext::startDocument(
+    uno::Reference< xml::input::XNamespaceMapping > const & xNamespaceMapping )
+    throw (xml::sax::SAXException, uno::RuntimeException)
+{
+    XMLNS_LAYOUT_UID = xNamespaceMapping->getUidByUri(
+        OUString( RTL_CONSTASCII_USTRINGPARAM( XMLNS_LAYOUT_URI ) ) );
+    XMLNS_CONTAINER_UID = xNamespaceMapping->getUidByUri(
+        OUString( RTL_CONSTASCII_USTRINGPARAM( XMLNS_CONTAINER_URI ) ) );
+}
+
+ToplevelElement::ToplevelElement (OUString const &rName,
+                                  uno::Reference <xml::input::XAttributes> const &xAttributes,
+                                  ImportContext *pImport)
+SAL_THROW(())
+: WidgetElement( 0, rName, xAttributes, NULL, pImport )
+{
+}
+
+ToplevelElement::~ToplevelElement()
+{
+}
+
+uno::Reference< xml::input::XElement > ImportContext::startRootElement(
+    sal_Int32 nUid, OUString const & rLocalName,
+    uno::Reference< xml::input::XAttributes > const & xAttributes )
+    throw (xml::sax::SAXException, uno::RuntimeException)
+{
+    if (XMLNS_LAYOUT_UID != nUid)
+        throw xml::sax::SAXException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("illegal namespace!") ),
+            uno::Reference< uno::XInterface >(), uno::Any() );
+    else
+        return new ToplevelElement (rLocalName, xAttributes, this);
+}
+
+} // namespace layoutimpl
diff --git a/layout/source/core/import.hxx b/layout/source/core/import.hxx
new file mode 100644
index 0000000..ba081c5
--- /dev/null
+++ layout/source/core/import.hxx
@@ -0,0 +1,278 @@
+#ifndef IMPORT_HXX
+#define IMPORT_HXX
+
+#include <map>
+#include <list>
+#include <hash_map>
+
+#include <com/sun/star/xml/input/XRoot.hpp>
+#include <cppuhelper/implbase1.hxx>
+
+namespace layoutimpl
+{
+class LayoutRoot;
+class LayoutWidget;
+namespace css = ::com::sun::star;
+
+/* blocks under IMPORT_RADIOGROUP are marked for deletion.
+   The use of it is to synchronize radio buttons into groups.
+   But toolkit doesn't fire toggle events when toggled from the code.
+   Another approach is to implement our own XRadioButton from our
+   internal toolkit. We could have some singleton where they would
+   register... We would need to add another attribute...
+*/
+
+#ifdef IMPORT_RADIOGROUP
+#include <com/sun/star/awt/XRadioButton.hpp>
+class RadioGroups
+{
+public:
+    RadioGroups()
+    {
+    }
+
+    void addItem( rtl::OUString id, css::uno::Reference< css::awt::XRadioButton > xRadio )
+        throw (css::uno::RuntimeException)
+    {
+        if ( ! xRadio.is() )
+            throw css::uno::RuntimeException();
+
+        css::uno::Reference< RadioGroup > group;
+        RadioGroupsMap::iterator it = mxRadioGroups.find( id );
+        if ( it == mxRadioGroups.end() )
+        {
+            group = css::uno::Reference< RadioGroup > ( new RadioGroup() );
+            mxRadioGroups [id] = group;
+        }
+        else
+            group = it->second;
+        group->addItem( xRadio );
+    }
+
+private:
+    class RadioGroup : public ::cppu::WeakImplHelper1< css::awt::XItemListener >
+    {
+    public:
+        RadioGroup()
+        {
+        }
+
+        void addItem( css::uno::Reference< css::awt::XRadioButton > xRadio )
+        {
+            if ( ! mxSelectedRadio.is() )
+            {
+                xRadio->setState( true );
+                mxSelectedRadio = xRadio;
+            }
+            else if ( xRadio->getState() )
+            {
+                mxSelectedRadio->setState( false );
+                mxSelectedRadio = xRadio;
+            }
+
+            xRadio->addItemListener( this );
+            mxRadios.push_back (xRadio);
+        }
+
+    private:
+        typedef std::list< css::uno::Reference< css::awt::XRadioButton > > RadioButtonsList;
+        RadioButtonsList mxRadios;
+        css::uno::Reference< css::awt::XRadioButton > mxSelectedRadio;
+
+        // awt::XItemListener
+        void itemStateChanged( const com::sun::star::awt::ItemEvent& e)
+            throw (css::uno::RuntimeException)
+        {
+            if ( e.Selected )
+            {
+                mxSelectedRadio->setState( false );
+                // the only radio button selected would be the one that fired the event
+                for( RadioButtonsList::iterator it = mxRadios.begin(); it != mxRadios.end(); it++ )
+                    if ( (*it)->getState() )
+                    {
+                        mxSelectedRadio = *it;
+                        break;
+                    }
+            }
+        }
+
+        // lang::XEventListener
+        void SAL_CALL disposing( const css::lang::EventObject& )
+            throw (css::uno::RuntimeException)
+        {
+        }
+    };
+
+    // each RadioGroup will stay alive after RadioGroups die with the ImportContext
+    // because they are referenced by every XRadioButton through the listener
+    typedef std::map< rtl::OUString, css::uno::Reference< RadioGroup > > RadioGroupsMap;
+    RadioGroupsMap mxRadioGroups;
+};
+#endif
+
+#if 0
+// generator
+class Widget
+{
+public:
+    Widget( css::uno::Reference< css::awt::XToolkit > xToolkit,
+            css::uno::Reference< css::awt::XWindow > xToplevel,
+            rtl::OUString unoName, long attrbs );
+    virtual ~Widget();
+
+    virtual void setProperties( const PropList &rProps );
+
+    virtual bool addChild( Widget *pChild );
+    virtual void setChildProperties( Widget *pChild, const PropList &rProps );
+
+    inline css::uno::Reference< css::awt::XLayoutConstrains > getPeer()
+    { return mxWidget; }
+
+protected:
+    css::uno::Reference< css::awt::XLayoutConstrains > mxWidget;
+    css::uno::Reference< css::awt::XLayoutContainer > mxContainer;
+};
+
+class Root
+{
+public:
+    Root( css::uno::Reference< css::awt::XToolkit > xToolkit )
+        : mxToolkit( xToolkit ) {}
+    ~Root();
+
+    virtual Widget *create( rtl::OUString id, const rtl::OUString unoName, long attrbs );
+
+    css::uno::Reference< css::awt::XLayoutConstrains > getById( rtl::OUString id );
+    inline css::uno::Reference< css::awt::XLayoutConstrains > getToplevel();
+
+protected:
+    css::uno::Reference< css::awt::XToolkit > mxToolkit;
+    Widget *mpToplevel;
+
+    typedef std::hash_map< rtl::OUString, css::uno::Reference< css::awt::XLayoutConstrains >,
+                           rtl::OUStringHash > ItemHash;
+    ItemHash maItems;
+};
+#endif
+
+// parser
+class ImportContext : public ::cppu::WeakImplHelper1< css::xml::input::XRoot >
+{
+public:
+    sal_Int32 XMLNS_LAYOUT_UID, XMLNS_CONTAINER_UID;
+    LayoutRoot &mrRoot; // switch to XNameContainer ref ?
+#ifdef IMPORT_RADIOGROUP
+    RadioGroups mxRadioGroups;
+#endif
+
+    inline ImportContext( LayoutRoot &rRoot ) SAL_THROW( () )
+        : mrRoot( rRoot ) {}
+    virtual ~ImportContext() {}
+
+    // XRoot
+    virtual void SAL_CALL startDocument(
+        css::uno::Reference< css::xml::input::XNamespaceMapping >
+        const & xNamespaceMapping )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+    virtual void SAL_CALL endDocument()
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+    virtual void SAL_CALL processingInstruction(
+        ::rtl::OUString const & /* rTarget */, ::rtl::OUString const & /* rData */ )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+    virtual void SAL_CALL setDocumentLocator(
+        css::uno::Reference< css::xml::sax::XLocator > const & /* xLocator */ )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+    virtual css::uno::Reference< css::xml::input::XElement >
+    SAL_CALL startRootElement(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference<css::xml::input::XAttributes > const & xAttributes )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException);
+};
+
+class ElementBase : public ::cppu::WeakImplHelper1< css::xml::input::XElement >
+{
+protected:
+    ImportContext *mpImport;
+/* TODO: check if all this memebers are needed. */
+    ElementBase   *mpParent;
+    sal_Int32      mnUid;
+
+    ::rtl::OUString maLocalName;
+    css::uno::Reference< css::xml::input::XAttributes > mxAttributes;
+public:
+    ElementBase(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference< css::xml::input::XAttributes > const & xAttributes,
+        ElementBase * pParent, ImportContext * pImport )
+    SAL_THROW( () );
+    virtual ~ElementBase() SAL_THROW(());
+
+    // XElement
+    virtual css::uno::Reference<css::xml::input::XElement> SAL_CALL getParent()
+        throw (css::uno::RuntimeException)
+    { return static_cast< css::xml::input::XElement * >( mpParent ); }
+    virtual ::rtl::OUString SAL_CALL getLocalName() throw (css::uno::RuntimeException)
+    { return maLocalName; }
+    virtual sal_Int32 SAL_CALL getUid() throw (css::uno::RuntimeException)
+    { return mnUid; }
+    virtual css::uno::Reference< css::xml::input::XAttributes >
+    SAL_CALL getAttributes() throw (css::uno::RuntimeException)
+    { return mxAttributes; }
+
+    virtual void SAL_CALL ignorableWhitespace(
+        ::rtl::OUString const & /* rWhitespaces */ )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+    virtual void SAL_CALL characters( ::rtl::OUString const & /* rChars */ )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+    virtual void SAL_CALL processingInstruction(
+        ::rtl::OUString const & /* Target */, ::rtl::OUString const & /* Data */ )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+
+    virtual css::uno::Reference< css::xml::input::XElement >
+    SAL_CALL startChildElement(
+        sal_Int32 nUid, ::rtl::OUString const & rLocalName,
+        css::uno::Reference<css::xml::input::XAttributes > const & xAttributes )
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException) = 0;
+    virtual void SAL_CALL endElement()
+        throw (css::xml::sax::SAXException, css::uno::RuntimeException)
+    { /* ignore */ }
+};
+
+class WidgetElement : public ElementBase
+{
+protected:
+    LayoutWidget *mpWidget;
+
+public:
+    WidgetElement( sal_Int32 nUid, rtl::OUString const &name,
+                   css::uno::Reference< css::xml::input::XAttributes > const &attributes,
+                   ElementBase *parent, ImportContext *import ) SAL_THROW (());
+
+    ~WidgetElement();
+
+
+    virtual css::uno::Reference< css::xml::input::XElement> SAL_CALL
+    startChildElement (sal_Int32 id, rtl::OUString const &name,
+                       css::uno::Reference< css::xml::input::XAttributes > const &attributes)
+        throw( css::xml::sax::SAXException, css::uno::RuntimeException );
+};
+
+class ToplevelElement : public WidgetElement
+{
+public:
+    ToplevelElement( rtl::OUString const &name,
+                     css::uno::Reference< css::xml::input::XAttributes > const &attributes,
+                     ImportContext *import ) SAL_THROW (());
+    ~ToplevelElement();
+};
+
+
+} // namespace layoutimpl
+
+#endif /* IMPORT_HXX */
diff --git a/layout/source/core/makefile.mk b/layout/source/core/makefile.mk
new file mode 100644
index 0000000..9f23cc8
--- /dev/null
+++ layout/source/core/makefile.mk
@@ -0,0 +1,42 @@
+PRJ=..$/..
+PRJNAME=layout
+TARGET=core
+ENABLE_EXCEPTIONS=true
+TARGETTYPE=GUI
+
+.INCLUDE : settings.mk
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+CFLAGS += -DENABLE_LAYOUT=1
+
+CXXFILES= \
+	bin.cxx \
+	box.cxx \
+	byteseq.cxx \
+	container.cxx \
+	dialogbuttonhbox.cxx \
+	factory.cxx \
+	flow.cxx \
+	helper.cxx \
+	import.cxx \
+	proplist.cxx \
+	root.cxx \
+	table.cxx \
+	timer.cxx
+
+SLOFILES= \
+	$(SLO)$/bin.obj \
+	$(SLO)$/box.obj \
+	$(SLO)$/byteseq.obj \
+	$(SLO)$/container.obj \
+	$(SLO)$/dialogbuttonhbox.obj \
+	$(SLO)$/factory.obj \
+	$(SLO)$/flow.obj \
+	$(SLO)$/helper.obj \
+	$(SLO)$/import.obj \
+	$(SLO)$/proplist.obj \
+	$(SLO)$/root.obj \
+	$(SLO)$/table.obj \
+	$(SLO)$/timer.obj
+
+.INCLUDE : target.mk
diff --git a/layout/source/core/proplist.cxx b/layout/source/core/proplist.cxx
new file mode 100644
index 0000000..e7ff556
--- /dev/null
+++ layout/source/core/proplist.cxx
@@ -0,0 +1,413 @@
+#include "proplist.hxx"
+
+#include <rtl/ustrbuf.hxx>
+#include <com/sun/star/awt/WindowAttribute.hpp>
+#include <com/sun/star/beans/XPropertySet.hpp>
+#include <com/sun/star/awt/XVclWindowPeer.hpp>
+#include <com/sun/star/awt/VclWindowPeerAttribute.hpp>
+#include <tools/debug.hxx>
+
+#if TEST_LAYOUT && !defined( DBG_UTIL )
+#include <stdio.h>
+#undef DBG_ERROR
+#define DBG_ERROR printf
+#undef DBG_ERROR1
+#define DBG_ERROR1 printf
+#undef DBG_ERROR2
+#define DBG_ERROR2 printf
+#endif /* TEST_LAYOUT && !DBG_UTIL */
+
+namespace layoutimpl
+{
+
+using namespace com::sun::star;
+using rtl::OString;
+using rtl::OUString;
+using rtl::OUStringBuffer;
+
+namespace prophlp
+{
+
+bool canHandleProps( const uno::Reference< uno::XInterface > &xPeer )
+{
+    uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
+    if ( xPropSet.is() )
+        return true;
+    uno::Reference< beans::XPropertySetInfo > xInfo( xPeer, uno::UNO_QUERY );
+    uno::Reference< awt::XVclWindowPeer> xVclPeer( xPeer, uno::UNO_QUERY );
+    return xInfo.is() && xVclPeer.is();
+}
+
+uno::Reference< beans::XPropertySetInfo > queryPropertyInfo(
+    const uno::Reference< uno::XInterface > &xPeer )
+{
+    uno::Reference< beans::XPropertySetInfo > xInfo( xPeer, uno::UNO_QUERY );
+    if ( !xInfo.is() )
+    {
+        uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
+        if ( xPropSet.is() )
+            xInfo = xPropSet->getPropertySetInfo();
+    }
+    return xInfo;
+}
+
+void setProperty( const uno::Reference< uno::XInterface > &xPeer,
+                  const OUString &rName, uno::Any aValue )
+{
+    uno::Reference< awt::XVclWindowPeer> xVclPeer( xPeer, uno::UNO_QUERY );
+    if ( xVclPeer.is() )
+        xVclPeer->setProperty( rName, aValue );
+    else
+    {
+        uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
+        xPropSet->setPropertyValue( rName, aValue );
+    }
+}
+
+uno::Any getProperty( const uno::Reference< uno::XInterface > &xPeer,
+                           const OUString &rName )
+{
+    uno::Reference< awt::XVclWindowPeer> xVclPeer( xPeer, uno::UNO_QUERY );
+    if ( xVclPeer.is() )
+        return xVclPeer->getProperty( rName );
+
+    uno::Reference< beans::XPropertySet > xPropSet( xPeer, uno::UNO_QUERY );
+    return xPropSet->getPropertyValue( rName );
+}
+
+} // namespace prophlp
+
+
+/* Given a string and a type, it converts the string to the type, and returns
+   it encapsulated in Any. */
+uno::Any anyFromString( const OUString &value, const uno::Type &type )
+{
+    switch ( type.getTypeClass() )
+    {
+        case uno::TypeClass_CHAR:
+            return uno::makeAny( value.toChar() );
+        case uno::TypeClass_BOOLEAN:
+            if ( value == OUString( RTL_CONSTASCII_USTRINGPARAM( "true" ) ) )
+                return uno::makeAny( true );
+            else if ( value == OUString( RTL_CONSTASCII_USTRINGPARAM( "false" ) ) )
+                return uno::makeAny( false );
+            break;  // ends switch, throws exception
+        case uno::TypeClass_BYTE:
+            return uno::makeAny( ( sal_uInt8 ) value.toInt32() );
+        case uno::TypeClass_SHORT:
+            return uno::makeAny( ( sal_Int16 ) value.toInt32() );
+        case uno::TypeClass_UNSIGNED_SHORT:
+            return uno::makeAny( ( sal_uInt16 ) value.toInt32() );
+        case uno::TypeClass_ENUM:
+            return uno::makeAny( ( sal_Int16 ) value.toInt32() );
+        case uno::TypeClass_LONG:
+            return uno::makeAny( ( sal_Int32 ) value.toInt32() );
+        case uno::TypeClass_UNSIGNED_LONG:
+            return uno::makeAny( ( sal_uInt32 ) value.toInt32() );
+        case uno::TypeClass_HYPER:
+            return uno::makeAny( ( sal_Int64 ) value.toInt64() );
+        case uno::TypeClass_UNSIGNED_HYPER:
+            return uno::makeAny( ( sal_uInt16 ) value.toInt64() );
+        case uno::TypeClass_FLOAT:
+            return uno::makeAny( value.toFloat() );
+        case uno::TypeClass_DOUBLE:
+            return uno::makeAny( value.toDouble() );
+        case uno::TypeClass_STRING:
+            return uno::makeAny( value );
+        case uno::TypeClass_CONSTANT:
+            if ( value.getLength() > 2 && value[0] == '0' && value[1] == 'x' )
+                return uno::makeAny( value.copy( 2 ).toInt32( 16 ) );
+            return uno::makeAny( value.toInt32() );
+        case uno::TypeClass_SEQUENCE:
+        {
+            sal_Int32 i = 0;
+            bool escaped = false, first = true;
+            OUString item, token;
+            std::list< OUString > values;
+            do
+            {
+                token = value.getToken( 0, ':', i );
+
+                if ( !token.getLength() && !escaped )
+                {
+                    escaped = true;
+                    item += OUString( ':' );
+                }
+                else if ( escaped )
+                {
+                    escaped = false;
+                    item += token;
+                }
+                else
+                {
+                    if ( !first )
+                        values.push_back( item );
+                    item = token;
+                }
+                first = false;
+            }
+            while ( i >= 0 );
+            if ( item.getLength() )
+                values.push_back( item );
+
+            uno::Sequence< OUString > seq( values.size() );
+            i = 0;
+            for( std::list< OUString >::const_iterator it = values.begin();
+                 it != values.end(); it++, i++ )
+                seq[ i ] = *it;
+
+            return uno::makeAny( seq );
+        }
+        break;
+
+        default:
+            DBG_ERROR1( "ERROR: unknown property type of value: `%s'", OUSTRING_CSTR( value ) );
+            break;
+    }
+    throw uno::RuntimeException();
+}
+
+/* Converts the XML naming scheme to UNO's, for legacy compatibility
+   (so, ergo, "one-two-three-four" -> "OneTwoThreeFour"). */
+static OUString toUnoNaming (const OUString &string )
+{
+    OUStringBuffer buffer( string.getLength() );
+    sal_Unicode *str = string.pData->buffer;
+    bool capitalize = true;
+
+    for ( int i = 0; i < string.getLength(); i++ )
+    {
+        if (str[i] == '-' )
+            capitalize = true;
+        else
+        {
+            if ( capitalize && str[i] >= 'a' && str[i] <= 'z' )
+                buffer.append( (sal_Unicode ) ( str[i] - 'a' + 'A' ) );
+            else
+                buffer.append( (sal_Unicode ) str[i] );
+            capitalize = false;
+        }
+    }
+
+    return buffer.makeStringAndClear();
+}
+
+/*
+ * convert incoming XML style property names, to AWT style property names.
+ * convert the values based on introspection information.
+ * apply to either an XPropertySet or an XPropertySetInfo | XVclWindowPeer
+ * aggregate.
+ */
+void
+setProperties( const uno::Reference< uno::XInterface > &xPeer,
+               const PropList &rProps )
+{
+    if ( !prophlp::canHandleProps( xPeer ) )
+    {
+        DBG_ERROR( "Error: setProperties - bad handle ignoring props:" );
+        PropList::const_iterator cur;
+        for( cur = rProps.begin(); cur != rProps.end(); cur++ )
+        {
+            OString attr = OUStringToOString( cur->first, RTL_TEXTENCODING_UTF8 );
+            OString value = OUStringToOString( cur->second, RTL_TEXTENCODING_UTF8 );
+        }
+        return;
+    }
+
+    uno::Reference< beans::XPropertySetInfo > xInfo
+        = prophlp::queryPropertyInfo( xPeer );
+
+    PropList::const_iterator cur;
+    for( cur = rProps.begin(); cur != rProps.end(); cur++ )
+    {
+        OUString attr = cur->first;
+        OUString value = cur->second;
+
+        attr = toUnoNaming( attr );
+
+        // get a Property object
+        beans::Property prop;
+        try
+        {
+            prop = xInfo->getPropertyByName( attr );
+        }
+        catch( beans::UnknownPropertyException &ex )
+        {
+            DBG_ERROR1( "Warning: unknown attribute: `%s'", OUSTRING_CSTR( attr ) );
+            continue;
+        }
+
+        if ( prop.Name.getLength() <= 0 )
+        {
+            DBG_ERROR1( "Warning: missing prop: `%s'", OUSTRING_CSTR( attr ) );
+            continue;
+        }
+
+        // encapsulates value in an uno::Any
+        uno::Any any;
+        try
+        {
+            any = anyFromString( value, prop.Type );
+        }
+        catch( uno::RuntimeException &ex )
+        {
+            DBG_ERROR5( "Warning: %s( %s )( %s ) attribute is of type %s( rejected: %s )", OUSTRING_CSTR( attr ), OUSTRING_CSTR( value ), OUSTRING_CSTR( prop.Name ),  OUSTRING_CSTR( prop.Type.getTypeName() ), OUSTRING_CSTR( value ) );
+            continue;
+        }
+
+        // sets value on property
+        try
+        {
+            prophlp::setProperty( xPeer, attr, any );
+        }
+        catch( ... )
+        {
+            DBG_ERROR2( "Warning: cannot set attribute %s to %s ", OUSTRING_CSTR( attr ), OUSTRING_CSTR( value ) );
+        }
+    }
+}
+
+
+
+struct AttributesMap
+{
+    const char *name;
+    long value;
+    bool windowAttr;
+};
+static const AttributesMap attribsMap[] =
+{
+    { "autohscroll",  awt::VclWindowPeerAttribute::AUTOHSCROLL,  false },
+    { "autovscroll",  awt::VclWindowPeerAttribute::AUTOVSCROLL,  false },
+    { "center",       awt::VclWindowPeerAttribute::CENTER,       false },
+    { "clipchildren", awt::VclWindowPeerAttribute::CLIPCHILDREN, false },
+    { "closeable",    awt::WindowAttribute::CLOSEABLE,           true },
+    { "defbutton",    awt::VclWindowPeerAttribute::DEFBUTTON,    false },
+    { "dropdown",     awt::VclWindowPeerAttribute::DROPDOWN,     false },
+    { "fullsize",     awt::WindowAttribute::FULLSIZE,            true  }, //FIXME?
+    { "group",        awt::VclWindowPeerAttribute::GROUP,        false },
+    { "has_border",   awt::WindowAttribute::BORDER,              true },
+    { "hscroll",      awt::VclWindowPeerAttribute::HSCROLL,      false },
+    { "left",         awt::VclWindowPeerAttribute::LEFT,         false },
+    { "moveable",     awt::WindowAttribute::MOVEABLE,            true },
+    { "noborder",     awt::VclWindowPeerAttribute::NOBORDER,     false },
+// Comment-out for <= m237
+//    { "nolabel",      awt::VclWindowPeerAttribute::NOLABEL,      false },
+    { "optimumsize",  awt::WindowAttribute::OPTIMUMSIZE,         false },
+    { "readonly",     awt::VclWindowPeerAttribute::READONLY,     false },
+    { "right",        awt::VclWindowPeerAttribute::RIGHT,        false },
+    { "show",         awt::WindowAttribute::SHOW,                true },
+    { "sizeable",     awt::WindowAttribute::SIZEABLE,            true },
+    { "sort",         awt::VclWindowPeerAttribute::SORT,         false },
+    { "spin",         awt::VclWindowPeerAttribute::SPIN,         false },
+    { "vscroll",      awt::VclWindowPeerAttribute::VSCROLL,      false },
+
+    // cutting on OK, YES_NO_CANCEL and related obscure attributes...
+};
+static const int attribsMapLen = sizeof( attribsMap ) / sizeof( AttributesMap );
+
+#if 0
+long getAttribute( const OUString &rName, bool bTopWindow )
+{
+
+    int min = 0, max = attribsMapLen - 1, mid, cmp;
+    do
+    {
+        mid = min +( max - min )/2;
+        cmp = rName.compareToAscii( attribsMap[ mid ].name );
+        if ( cmp > 0 )
+            min = mid+1;
+        else if ( cmp < 0 )
+            max = mid-1;
+        else
+        {
+            if ( bTopWindow || attribsMap[ mid ].value )
+                return attribsMap[ mid ].windowAttr;
+            return 0;
+        }
+    }
+    while ( min <= max );
+    return 0;
+}
+#endif
+
+void propsFromAttributes( const uno::Reference<xml::input::XAttributes> & xAttributes,
+                          PropList &rProps, sal_Int32 nNamespace )
+{
+
+
+    sal_Int32 nAttrs = xAttributes->getLength();
+    for( sal_Int32 i = 0; i < nAttrs; i++ )
+    {
+        if ( nNamespace != xAttributes->getUidByIndex( i ) )
+            continue;
+
+        std::pair< OUString, OUString > aElem
+( xAttributes->getLocalNameByIndex( i ),
+              xAttributes->getValueByIndex( i ) );
+
+        if ( aElem.first.getLength() > 0 ) // namespace bits ..
+            rProps.push_back( aElem );
+    }
+}
+
+bool
+findAndRemove( const char *pAttr, PropList &rProps, OUString &rValue )
+{
+    PropList::iterator cur;
+    OUString aName = OUString::createFromAscii( pAttr );
+
+    for( cur = rProps.begin(); cur != rProps.end(); cur++ )
+    {
+        if ( cur->first.equalsIgnoreAsciiCase( aName ) )
+        {
+            rValue = cur->second;
+            rProps.erase( cur );
+            return true;
+        }
+    }
+    rValue = OUString();
+    return false;
+}
+
+long
+getAttributeProps( PropList &rProps )
+{
+    long nAttrs = 0;
+    OUString aValue;
+
+    OUString trueStr( RTL_CONSTASCII_USTRINGPARAM( "true" ) );
+
+    if ( findAndRemove( "show", rProps, aValue ) &&
+        aValue.equalsIgnoreAsciiCase(
+            OUString( RTL_CONSTASCII_USTRINGPARAM( "false" ) ) ) )
+        ;
+    else
+        nAttrs |= awt::WindowAttribute::SHOW;
+
+    for( int i = 0; i < attribsMapLen; i++ )
+    {
+        if ( findAndRemove( attribsMap[i].name, rProps, aValue ) )
+        {
+            if ( aValue.equalsIgnoreAsciiCase( trueStr ) )
+                nAttrs |= attribsMap[i].value;
+        }
+    }
+
+    if ( findAndRemove( "align", rProps, aValue ) )
+    {
+        sal_Int32 nVal = aValue.toInt32();
+
+        if ( nVal == 0 /* PROPERTY_ALIGN_LEFT */ )
+            nAttrs |= awt::VclWindowPeerAttribute::LEFT;
+        else if ( nVal == 1 /* PROPERTY_ALIGN_CENTER */ )
+            nAttrs |= awt::VclWindowPeerAttribute::CENTER;
+        else if ( nVal == 2 )
+            nAttrs |= awt::VclWindowPeerAttribute::RIGHT;
+    }
+
+    return nAttrs;
+}
+
+}
+
diff --git a/layout/source/core/proplist.hxx b/layout/source/core/proplist.hxx
new file mode 100644
index 0000000..f057340
--- /dev/null
+++ layout/source/core/proplist.hxx
@@ -0,0 +1,31 @@
+#ifndef CORE_PROPLIST_HXX
+#define CORE_PROPLIST_HXX
+
+#include <list>
+#include <com/sun/star/xml/input/XAttributes.hpp>
+
+#include <rtl/ustring.hxx>
+
+namespace layoutimpl
+{
+
+namespace css = ::com::sun::star;
+
+typedef std::list< std::pair< rtl::OUString, rtl::OUString > > PropList;
+
+void propsFromAttributes( const css::uno::Reference<css::xml::input::XAttributes> & xAttributes,
+                          PropList &rProps, sal_Int32 nNamespace );
+
+void setProperties( const css::uno::Reference< css::uno::XInterface > &xBag,
+                    const PropList &rProps);
+
+long getAttributeProps( PropList &rProps );
+bool findAndRemove( const char *pAttr, PropList &rProps, rtl::OUString &rValue);
+
+}
+
+// Convert a rtl::OUString to a byte string.
+#define OUSTRING_CSTR( str ) \
+    rtl::OUStringToOString( str, RTL_TEXTENCODING_ASCII_US ).getStr()
+
+#endif // CORE_PROPLIST_HXX
diff --git a/layout/source/core/root.cxx b/layout/source/core/root.cxx
new file mode 100644
index 0000000..7c0fac4
--- /dev/null
+++ layout/source/core/root.cxx
@@ -0,0 +1,349 @@
+#include "root.hxx"
+
+#include <assert.h>
+#include <com/sun/star/xml/sax/XParser.hpp>
+#include <unotools/bootstrap.hxx>
+#include <unotools/localfilehelper.hxx>
+
+#if TEST_LAYOUT
+#include <stdio.h>
+#endif
+
+#include "helper.hxx"
+#include "import.hxx"
+#include "timer.hxx"
+
+namespace layoutimpl
+{
+
+using namespace css;
+using ::rtl::OUString;
+using ::utl::Bootstrap;
+using ::utl::LocalFileHelper;
+
+LayoutRoot::LayoutRoot( const uno::Reference< lang::XMultiServiceFactory >& xFactory )
+    : mbDisposed( sal_False )
+    , mxFactory( xFactory )
+    , mpListeners( NULL )
+    , mpToplevel( NULL )
+{
+    if ( !xFactory.is() )
+        throw uno::RuntimeException();
+    mxLayoutUnit = uno::Reference< awt::XLayoutUnit >( new LayoutUnit() );
+}
+
+LayoutRoot::~LayoutRoot()
+{
+// TODO: we want to delete the top level LayoutWidget...
+    ::osl::MutexGuard aGuard( maMutex );
+    if ( !mbDisposed )
+    {
+        try
+        {
+            m_refCount++; // inhibit multiple destruction
+            dispose();
+        }
+        catch( uno::Exception& )
+        {
+        }
+    }
+}
+
+
+// XInitialization
+void SAL_CALL LayoutRoot::initialize( const uno::Sequence< uno::Any >& aArguments )
+    throw ( uno::Exception,
+            uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+
+    if ( mbDisposed )
+        throw lang::DisposedException();
+
+    if ( mxContainer.is() ) // only 1 init ...
+        throw uno::Exception();
+
+    if ( !aArguments.getLength() )
+        throw lang::IllegalArgumentException();
+
+    OSL_ENSURE( aArguments.getLength() == 1, "Wrong arg count\n" );
+
+    OUString aXMLName;
+    if ( !( aArguments[0] >>= aXMLName ) )
+        throw lang::IllegalArgumentException();
+
+    uno::Reference< xml::sax::XParser > xParser
+        ( mxFactory->createInstance(
+            OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.xml.sax.Parser" ) ) ),
+          uno::UNO_QUERY );
+    OSL_ASSERT( xParser.is() );
+    if (! xParser.is())
+    {
+        throw uno::RuntimeException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM( "cannot create sax-parser component" ) ),
+            uno::Reference< uno::XInterface >() );
+    }
+
+    String aXMLFile;
+    // FIXME: how to get/check cwd [url]?
+    // if ( LocalFileHelper::IsFileContent( aXMLName ) )
+    // if ( LocalFileHelper::IsLocalFile( aXMLName ) )
+#if TEST_LAYOUT // read from cwd first
+    if ( FILE *f = ::fopen( OUSTRING_CSTR( aXMLName ), "r" ) )
+    {
+        ::fclose( f );
+        aXMLFile = aXMLName;
+    }
+    else
+#endif /* TEST_LAYOU */
+    {
+        OUString aShareUrl;
+        Bootstrap::locateSharedData( aShareUrl );
+        OUString aXMLUrl = aShareUrl
+            + OUString::createFromAscii( "/layout/" ) + aXMLName;
+        LocalFileHelper::ConvertURLToPhysicalName( aXMLUrl, aXMLFile );
+    }
+
+    uno::Reference< io::XInputStream > xStream = getFileAsStream( mxFactory, aXMLFile );
+
+    // error handler, entity resolver omitted
+
+    // FIXME: quite possibly we want to pass this in ...
+    uno::Reference< awt::XToolkit > xToolkit;
+
+    mxToolkit = uno::Reference< awt::XToolkit >(
+        mxFactory->createInstance(
+            OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.awt.Toolkit" ) ) ),
+        uno::UNO_QUERY );
+
+    if ( !mxToolkit.is() )
+        throw uno::RuntimeException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM( "failed to create toolkit!" ) ),
+            uno::Reference< uno::XInterface >() );
+
+    ImportContext *pCtx = new ImportContext( *this );
+
+    uno::Reference< xml::input::XRoot > xRoot( pCtx );
+    uno::Sequence < uno::Any > aArgs( 1 );
+    aArgs[0] <<= xRoot;
+    uno::Reference< xml::sax::XDocumentHandler > xDocHandler
+        (mxFactory->createInstanceWithArguments
+         ( OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.xml.input.SaxDocumentHandler" ) ),
+          aArgs ), uno::UNO_QUERY );
+
+    xParser->setDocumentHandler( xDocHandler );
+
+    xml::sax::InputSource source;
+    source.aInputStream = xStream;
+    source.sSystemId = OUString( RTL_CONSTASCII_USTRINGPARAM( "virtual file" ) );
+
+    xParser->parseStream( source );
+}
+
+// XLayoutContainer
+uno::Reference< awt::XLayoutContainer > LayoutRoot::getLayoutContainer() throw (uno::RuntimeException)
+{
+    return uno::Reference< awt::XLayoutContainer >();
+}
+
+// local helper ...
+void LayoutRoot::addItem( const OUString &rName,
+                          const uno::Reference< awt::XLayoutConstrains > &xRef )
+{
+    maItems[ rName ] = xRef;
+}
+
+// XNameAccess
+uno::Any SAL_CALL LayoutRoot::getByName( const OUString &rName )
+    throw ( container::NoSuchElementException,
+            lang::WrappedTargetException,
+            uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+    if ( mbDisposed )
+        throw lang::DisposedException();
+
+    uno::Reference< awt::XLayoutConstrains > xItem;
+    ItemHash::iterator i = maItems.find( rName );
+    if ( i != maItems.end() )
+        xItem = i->second;
+    return uno::makeAny( xItem );
+}
+
+sal_Bool SAL_CALL LayoutRoot::hasByName( const OUString &rName )
+    throw (uno::RuntimeException)
+{
+    ::osl::MutexGuard aGuard( maMutex );
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    ItemHash::iterator i = maItems.find( rName );
+    return i != maItems.end();
+}
+
+uno::Sequence< OUString > SAL_CALL LayoutRoot::getElementNames()
+    throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    uno::Sequence< OUString > aNames( maItems.size() );
+    sal_Int32 nPos = 0;
+
+    for( ItemHash::const_iterator i = maItems.begin();
+         i != maItems.end(); i++ )
+        aNames[ nPos++ ] = i->first;
+
+    return aNames;
+}
+
+uno::Type SAL_CALL LayoutRoot::getElementType()
+    throw ( uno::RuntimeException )
+{
+    return getCppuType( ( const uno::Reference< awt::XLayoutConstrains >* )NULL );
+}
+
+sal_Bool SAL_CALL LayoutRoot::hasElements()
+    throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    return maItems.size() > 0;
+}
+
+// XComponent
+void SAL_CALL LayoutRoot::dispose()
+    throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    if ( mpListeners )
+    {
+
+        lang::EventObject aSource( static_cast< ::cppu::OWeakObject* >(this) );
+        mpListeners->disposeAndClear( aSource );
+        delete mpListeners;
+        mpListeners = NULL;
+    }
+
+    maItems.clear();
+    mbDisposed = sal_True;
+}
+
+void SAL_CALL LayoutRoot::addEventListener( const uno::Reference< lang::XEventListener >& xListener )
+    throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    if ( !mpListeners )
+        mpListeners = new ::cppu::OInterfaceContainerHelper( maMutex );
+    mpListeners->addInterface( xListener );
+}
+
+void SAL_CALL LayoutRoot::removeEventListener( const uno::Reference< lang::XEventListener >& xListener )
+    throw ( uno::RuntimeException )
+{
+    ::osl::MutexGuard aGuard( maMutex );
+
+    if ( mbDisposed ) throw lang::DisposedException();
+
+    if ( mpListeners )
+        mpListeners->removeInterface( xListener );
+}
+
+// builder
+
+LayoutWidget *LayoutRoot::create( OUString id, const OUString unoName, long attrbs,uno::Reference< awt::XLayoutContainer > xParent )
+{
+    LayoutWidget *pWidget = new LayoutWidget( mxToolkit, xParent, unoName, attrbs );
+    if ( !mpToplevel )
+    {
+        mpToplevel = pWidget;
+        mxWindow = uno::Reference< awt::XWindow >( pWidget->getPeer(), uno::UNO_QUERY );
+        mxContainer = pWidget->mxContainer;
+    }
+    if ( pWidget->mxContainer.is() )
+        pWidget->mxContainer->setLayoutUnit( mxLayoutUnit );
+    if ( id.getLength() )
+        maItems[ id ] = pWidget->getPeer();
+    return pWidget;
+}
+
+/*
+  uno::Reference< awt::XLayoutConstrains > LayoutRoot::getToplevel()
+  {
+  if ( mpToplevel )
+  return mpToplevel->getPeer();
+  return uno::Reference< awt::XLayoutConstrains > ();
+  }
+
+  uno::Reference< awt::XLayoutConstrains > LayoutRoot::getById( OUString id )
+  {
+  uno::Reference< awt::XLayoutConstrains > rRef = 0;
+  ItemHash::iterator i = maItems.find( id );
+  if ( i != maItems.end() )
+  rRef = i->second;
+  return rRef;
+  }
+*/
+
+LayoutWidget::LayoutWidget( uno::Reference< awt::XToolkit > xToolkit,
+                            uno::Reference< awt::XLayoutContainer > xParent,
+                            OUString unoName, long attrbs )
+{
+    while ( xParent.is() && !uno::Reference< awt::XWindow >( xParent, uno::UNO_QUERY ).is() )
+    {
+        uno::Reference< awt::XLayoutContainer > xContainer( xParent, uno::UNO_QUERY );
+        assert( xContainer.is() );
+        xParent = uno::Reference< awt::XLayoutContainer >( xContainer->getParent(), uno::UNO_QUERY );
+    }
+
+    mxWidget = createWidget( xToolkit, xParent, unoName, attrbs );
+    assert( mxWidget.is() );
+    mxContainer = uno::Reference< awt::XLayoutContainer >( mxWidget, uno::UNO_QUERY );
+}
+
+LayoutWidget::~LayoutWidget()
+{
+    /* should we dispose of the references...? */
+    // at least of its children... Or should root?
+}
+
+bool LayoutWidget::addChild( LayoutWidget *pChild )
+{
+    if ( !mxContainer.is() )
+        return false;
+
+    try
+    {
+        mxContainer->addChild( pChild->mxWidget );
+    }
+    catch( awt::MaxChildrenException ex )
+    {
+        return false;
+    }
+    return true;
+}
+
+void LayoutWidget::setProperties( const PropList &rProps )
+{
+    ::layoutimpl::setProperties( mxWidget, rProps );
+}
+
+void LayoutWidget::setChildProperties( LayoutWidget *pChild, const PropList &rProps )
+{
+    uno::Reference< beans::XPropertySet > xChildProps;
+    xChildProps = mxContainer->getChildProperties( pChild->mxWidget );
+
+    if ( xChildProps.is() )
+        ::layoutimpl::setProperties( xChildProps, rProps );
+}
+
+
+} // namespace layoutimpl
+
diff --git a/layout/source/core/root.hxx b/layout/source/core/root.hxx
new file mode 100644
index 0000000..ffe3315
--- /dev/null
+++ layout/source/core/root.hxx
@@ -0,0 +1,124 @@
+#ifndef CORE_ROOT_HXX
+#define CORE_ROOT_HXX
+
+#include <hash_map>
+
+#include <com/sun/star/awt/XLayoutRoot.hpp>
+#include <com/sun/star/awt/XToolkit.hpp>
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/io/XInputStream.hpp>
+#include <com/sun/star/lang/XComponent.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+#include <cppuhelper/implbase3.hxx>
+#include <cppuhelper/interfacecontainer.h>
+
+#include "proplist.hxx"
+
+namespace layoutimpl
+{
+
+namespace css = ::com::sun::star;
+
+css::uno::Reference< css::io::XInputStream >
+getFileAsStream( const css::uno::Reference< css::lang::XMultiServiceFactory > &xFactory,
+                 const rtl::OUString &rName );
+
+/* Interface generation code -- to hook to a parser. */
+
+/*
+  TODO: (ricardo) I think we should cut on LayoutRoot, stripping out its widget
+  proxy interface (just make it return the root widget). Would even make it easier
+  if there was interest to support multiple toplevel widgets in the same file.
+
+  We also need to make sure the code gets diposed well... There is no need to keep
+  these objects around after initialization...
+*/
+
+
+class LayoutWidget;
+
+class LayoutRoot : public ::cppu::WeakImplHelper3<
+    css::awt::XLayoutRoot,
+    css::lang::XInitialization,
+    css::lang::XComponent>
+{
+protected:
+    ::osl::Mutex maMutex;
+
+    typedef std::hash_map< rtl::OUString,
+                           css::uno::Reference< css::awt::XLayoutConstrains >,
+                           ::rtl::OUStringHash > ItemHash;
+    ItemHash maItems;
+
+    sal_Bool mbDisposed;
+    css::uno::Reference< css::lang::XMultiServiceFactory > mxFactory;
+    ::cppu::OInterfaceContainerHelper *mpListeners;
+
+    css::uno::Reference< css::awt::XWindow >          mxWindow;
+    css::uno::Reference< css::awt::XLayoutContainer > mxContainer;
+
+    css::uno::Reference< css::awt::XToolkit > mxToolkit;
+    LayoutWidget *mpToplevel;
+    css::uno::Reference< css::awt::XLayoutUnit > mxLayoutUnit;
+
+public:
+    LayoutRoot( const css::uno::Reference< css::lang::XMultiServiceFactory >& xFactory );
+    virtual ~LayoutRoot();
+
+    void addItem( const rtl::OUString &rName,
+                  const css::uno::Reference< css::awt::XLayoutConstrains > &xRef );
+
+    void setWindow(    css::uno::Reference< css::awt::XLayoutConstrains > xPeer )
+    {
+        mxWindow = css::uno::Reference< css::awt::XWindow >( xPeer, css::uno::UNO_QUERY );
+    }
+
+    // get XLayoutContainer
+    virtual css::uno::Reference< css::awt::XLayoutContainer > getLayoutContainer() throw (css::uno::RuntimeException);
+
+    // XInitialization
+    virtual void SAL_CALL initialize( const css::uno::Sequence< css::uno::Any >& aArguments ) throw (css::uno::Exception, css::uno::RuntimeException);
+
+    // XNameAccess
+    virtual css::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (css::container::NoSuchElementException, css::lang::WrappedTargetException, css::uno::RuntimeException);
+    virtual css::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames() throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (css::uno::RuntimeException);
+    virtual css::uno::Type SAL_CALL getElementType() throw (css::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL hasElements() throw (css::uno::RuntimeException);
+
+    // XComponent
+    virtual void SAL_CALL dispose() throw (css::uno::RuntimeException);
+    virtual void SAL_CALL addEventListener( const css::uno::Reference< css::lang::XEventListener >& xListener ) throw (css::uno::RuntimeException);
+    virtual void SAL_CALL removeEventListener( const css::uno::Reference< css::lang::XEventListener >& aListener ) throw (css::uno::RuntimeException);
+
+    // generator
+    virtual LayoutWidget *create( rtl::OUString id, const rtl::OUString unoName, long attrbs, css::uno::Reference< css::awt::XLayoutContainer > xParent );
+};
+
+class LayoutWidget
+{
+    friend class LayoutRoot;
+
+public:
+    LayoutWidget() {}
+    LayoutWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
+                  css::uno::Reference< css::awt::XLayoutContainer > xToplevel,
+                  rtl::OUString unoName, long attrbs );
+    virtual ~LayoutWidget();
+
+    virtual void setProperties( const PropList &rProps );
+
+    virtual bool addChild( LayoutWidget *pChild );
+    virtual void setChildProperties( LayoutWidget *pChild, const PropList &rProps );
+
+    inline css::uno::Reference< css::awt::XLayoutConstrains > getPeer()
+    { return mxWidget; }
+
+protected:
+    css::uno::Reference< css::awt::XLayoutConstrains > mxWidget;
+    css::uno::Reference< css::awt::XLayoutContainer > mxContainer;
+};
+
+} // namespace layoutimpl
+
+#endif // CORE_ROOT_HXX
diff --git a/layout/source/core/table.cxx b/layout/source/core/table.cxx
new file mode 100644
index 0000000..2cffbb8
--- /dev/null
+++ layout/source/core/table.cxx
@@ -0,0 +1,326 @@
+#include <table.hxx>
+
+#include <sal/macros.h>
+#include <osl/mutex.hxx>
+#include <cppuhelper/propshlp.hxx>
+#include <cppuhelper/interfacecontainer.h>
+#include <com/sun/star/awt/PosSize.hpp>
+#include <tools/debug.hxx>
+
+// fixed point precision for distributing error
+#define FIXED_PT 16
+
+namespace layoutimpl
+{
+
+using namespace com::sun::star;
+
+class TableChildProps : public PropHelper
+{
+public:
+    TableChildProps( Table::ChildData *pData )
+    {
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "XExpand" ),
+                 ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+                 &( pData->bExpand[ 0 ] ) );
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "YExpand" ),
+                 ::getCppuType( static_cast< const sal_Bool* >( NULL ) ),
+                 &( pData->bExpand[ 1 ] ) );
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "ColSpan" ),
+                 ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+                 &( pData->nColSpan ) );
+        addProp( RTL_CONSTASCII_USTRINGPARAM( "RowSpan" ),
+                 ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+                 &( pData->nRowSpan ) );
+    }
+    PROPHELPER_SET_INFO
+};
+
+bool Table::ChildData::isVisible()
+{
+    if ( !xChild.is() || nColSpan < 1 || nRowSpan < 1 )
+        return false;
+    return xChild.is();
+}
+
+Table::Table()
+    : Container()
+{
+    // another default value could be 0xffff for infinite columns( = 1 row )
+    mnColsLen = 1;
+    addProp( RTL_CONSTASCII_USTRINGPARAM( "Columns" ),
+             ::getCppuType( static_cast< const sal_Int32* >( NULL ) ),
+             &mnColsLen );
+}
+
+void SAL_CALL
+Table::addChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw( uno::RuntimeException, awt::MaxChildrenException )
+{
+    if ( xChild.is() )
+    {
+        ChildData *pData = new ChildData();
+        pData->bExpand[ 0 ] = pData->bExpand[ 1 ] = true;
+        pData->nColSpan = pData->nRowSpan = 1;
+        pData->xChild = xChild;
+        maChildren.push_back( pData );
+
+        setChildParent( xChild );
+        queueResize();
+
+        // cause of flicker
+        allocateChildAt( xChild, awt::Rectangle( 0,0,0,0 ) );
+    }
+}
+
+void SAL_CALL
+Table::removeChild( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw( uno::RuntimeException )
+{
+    for( std::list< ChildData * >::iterator it = maChildren.begin();
+         it != maChildren.end(); it++ )
+    {
+        if ( ( *it )->xChild == xChild )
+        {
+            delete *it;
+            maChildren.erase( it );
+
+            unsetChildParent( xChild );
+            queueResize();
+            break;
+        }
+    }
+    DBG_ERROR( "Table error: trying to remove child that doesn't exist" );
+}
+
+uno::Sequence< uno::Reference < awt::XLayoutConstrains > > SAL_CALL
+Table::getChildren()
+    throw( uno::RuntimeException )
+{
+    uno::Sequence< uno::Reference< awt::XLayoutConstrains > > children( maChildren.size() );
+    unsigned int i = 0;
+    for( std::list< ChildData * >::iterator it = maChildren.begin();
+         it != maChildren.end(); it++, i++ )
+        children[i] =( *it )->xChild;
+
+    return children;
+}
+
+uno::Reference< beans::XPropertySet > SAL_CALL
+Table::getChildProperties( const uno::Reference< awt::XLayoutConstrains >& xChild )
+    throw( uno::RuntimeException )
+{
+    std::list< ChildData * >::iterator iter;
+    for( iter = maChildren.begin(); iter != maChildren.end(); iter++ )
+    {
+        if ( ( *iter )->xChild == xChild )
+        {
+            if ( !( *iter )->xProps.is() )
+            {
+                // FIXME: make me safe !
+                PropHelper *pProps = new TableChildProps( *iter );
+                pProps->setChangeListener( this );
+( *iter )->xProps = pProps;
+            }
+            return( *iter )->xProps;
+        }
+    }
+    return uno::Reference< beans::XPropertySet >();
+}
+
+awt::Size SAL_CALL
+Table::getMinimumSize() throw( uno::RuntimeException )
+{
+    int nRowsLen = 0;
+
+    // 1. layout the table -- adjust to cope with row-spans...
+    {
+        // temporary 1D representation of the table
+        std::vector< ChildData *> aTable;
+
+        int col = 0, row = 0;
+        for( std::list<ChildData *>::iterator it = maChildren.begin();
+             it != maChildren.end(); it++ )
+        {
+            ChildData *child = *it;
+            if ( !child->isVisible() )
+                continue;
+
+            while ( col + SAL_MIN( child->nColSpan, mnColsLen ) > mnColsLen )
+            {
+                col = 0;
+                row++;
+
+                unsigned int i = col +( row*mnColsLen );
+                while ( aTable.size() > i && !aTable[ i ] )
+                    i++;
+
+                col = i % mnColsLen;
+                row = i / mnColsLen;
+            }
+
+            child->nLeftCol = col;
+            child->nRightCol = SAL_MIN( col + child->nColSpan, mnColsLen );
+            child->nTopRow = row;
+            child->nBottomRow = row + child->nRowSpan;
+
+            col += child->nColSpan;
+
+            unsigned int start = child->nLeftCol +( child->nTopRow*mnColsLen );
+            unsigned int end =( child->nRightCol-1 ) +( ( child->nBottomRow-1 )*mnColsLen );
+            if ( aTable.size() < end+1 )
+                aTable.resize( end+1, NULL );
+            for( unsigned int i = start; i < end; i++ )
+                aTable[ i ] = child;
+
+            nRowsLen = SAL_MAX( nRowsLen, child->nBottomRow );
+        }
+    }
+
+    // 2. calculate columns/rows sizes
+    for( int g = 0; g < 2; g++ )
+    {
+        std::vector< GroupData > &aGroup = g == 0 ? maCols : maRows;
+
+        aGroup.clear();
+        aGroup.resize( g == 0 ? mnColsLen : nRowsLen );
+
+        // 2.1 base sizes on one-column/row children
+        for( std::list<ChildData *>::iterator it = maChildren.begin();
+             it != maChildren.end(); it++ )
+        {
+            ChildData *child = *it;
+            if ( !child->isVisible() )
+                continue;
+            const int nFirstAttach = g == 0 ? child->nLeftCol : child->nTopRow;
+            const int nLastAttach  = g == 0 ? child->nRightCol : child->nBottomRow;
+
+            if ( nFirstAttach == nLastAttach-1 )
+            {
+                child->aRequisition = child->xChild->getMinimumSize();
+                int attach = nFirstAttach;
+                int child_size = g == 0 ? child->aRequisition.Width
+                    : child->aRequisition.Height;
+                aGroup[ attach ].nSize = SAL_MAX( aGroup[ attach ].nSize, child_size );
+                if ( child->bExpand[ g ] )
+                    aGroup[ attach ].bExpand = true;
+            }
+        }
+
+        // 2.2 make sure multiple-columns/rows children fit
+        for( std::list<ChildData *>::iterator it = maChildren.begin();
+             it != maChildren.end(); it++ )
+        {
+            ChildData *child = *it;
+            if ( !child->isVisible() )
+                continue;
+            const int nFirstAttach = g == 0 ? child->nLeftCol : child->nTopRow;
+            const int nLastAttach  = g == 0 ? child->nRightCol : child->nBottomRow;
+
+            if ( nFirstAttach != nLastAttach-1 )
+            {
+                child->aRequisition = child->xChild->getMinimumSize();
+                int size = 0;
+                int expandables = 0;
+                for( int i = nFirstAttach; i < nLastAttach; i++ )
+                {
+                    size += aGroup[ i ].nSize;
+                    if ( aGroup[ i ].bExpand )
+                        expandables++;
+                }
+
+                int child_size = g == 0 ? child->aRequisition.Width
+                    : child->aRequisition.Height;
+                int extra = child_size - size;
+                if ( extra > 0 )
+                {
+                    if ( expandables )
+                        extra /= expandables;
+                    else
+                        extra /= nLastAttach - nFirstAttach;
+
+                    for( int i = nFirstAttach; i < nLastAttach; i++ )
+                        if ( expandables == 0 || aGroup[ i ].bExpand )
+                            aGroup[ i ].nSize += extra;
+                }
+            }
+        }
+    }
+
+    // 3. Sum everything up
+    mnColExpandables =( mnRowExpandables = 0 );
+    maRequisition.Width =( maRequisition.Height = 0 );
+    for( std::vector<GroupData>::iterator it = maCols.begin();
+         it != maCols.end(); it++ )
+    {
+        maRequisition.Width += it->nSize;
+        if ( it->bExpand )
+            mnColExpandables++;
+    }
+    for( std::vector<GroupData>::iterator it = maRows.begin();
+         it != maRows.end(); it++ )
+    {
+        maRequisition.Height += it->nSize;
+        if ( it->bExpand )
+            mnRowExpandables++;
+    }
+
+    return maRequisition;
+}
+
+void SAL_CALL
+Table::allocateArea( const awt::Rectangle &rArea )
+    throw( uno::RuntimeException )
+{
+    maAllocation = rArea;
+    if ( maCols.size() == 0 || maRows.size() == 0 )
+        return;
+
+    int nExtraSize[ 2 ] = { SAL_MAX( rArea.Width - maRequisition.Width, 0 ),
+                            SAL_MAX( rArea.Height - maRequisition.Height, 0 ) };
+    // split it
+    nExtraSize[ 0 ] /= mnColExpandables ? mnColExpandables : mnColsLen;
+    nExtraSize[ 1 ] /= mnRowExpandables ? mnRowExpandables : maRows.size();
+
+    for( std::list<ChildData *>::const_iterator it = maChildren.begin();
+         it != maChildren.end(); it++ )
+    {
+        ChildData *child = *it;
+        if ( !child->isVisible() )
+            continue;
+
+        awt::Rectangle rChildArea( rArea.X, rArea.Y, 0, 0 );
+
+        for( int g = 0; g < 2; g++ )
+        {
+            std::vector< GroupData > &aGroup = g == 0 ? maCols : maRows;
+            const int nFirstAttach = g == 0 ? child->nLeftCol : child->nTopRow;
+            const int nLastAttach  = g == 0 ? child->nRightCol : child->nBottomRow;
+
+            for( int i = 0; i < nFirstAttach; i++ )
+            {
+                int gSize = aGroup[ i ].nSize;
+                if ( aGroup[ i ].bExpand )
+                    gSize += nExtraSize[ g ];
+                if ( g == 0 )
+                    rChildArea.X += gSize;
+                else
+                    rChildArea.Y += gSize;
+            }
+            for( int i = nFirstAttach; i < nLastAttach; i++ )
+            {
+                int gSize = aGroup[ i ].nSize;
+                if ( aGroup[ i ].bExpand )
+                    gSize += nExtraSize[ g ];
+                if ( g == 0 )
+                    rChildArea.Width  += gSize;
+                else
+                    rChildArea.Height += gSize;
+            }
+        }
+
+        allocateChildAt( child->xChild, rChildArea );
+    }
+}
+
+} // namespace layoutimpl
diff --git a/layout/source/core/table.hxx b/layout/source/core/table.hxx
new file mode 100644
index 0000000..1374de2
--- /dev/null
+++ layout/source/core/table.hxx
@@ -0,0 +1,79 @@
+#ifndef TABLE_HXX
+#define TABLE_HXX
+
+#include "container.hxx"
+
+#include <list>
+
+namespace layoutimpl
+{
+
+class Table : public Container
+{
+    friend class TableChildProps;
+protected:
+    // Table properties
+    sal_Int32 mnColsLen;
+
+    // Children properties
+    struct ChildData
+    {
+        sal_Bool  bExpand[ 2 ];
+        sal_Int32 nColSpan, nRowSpan;
+        css::awt::Size aRequisition;
+        css::uno::Reference< css::awt::XLayoutConstrains > xChild;
+        css::uno::Reference< css::beans::XPropertySet >    xProps;
+        bool isVisible();
+
+        // automatically calculated
+        int nLeftCol, nRightCol, nTopRow, nBottomRow;
+    };
+    std::list< ChildData * > maChildren;
+
+    // a group of children; either a column or a row
+    struct GroupData
+    {
+        sal_Bool bExpand;
+        int nSize;  // request size (width or height)
+        GroupData() : bExpand( false ), nSize( 0 ) {}
+    };
+    std::vector< GroupData > maCols, maRows;
+    int mnColExpandables, mnRowExpandables;
+
+public:
+    Table();
+
+    // css::awt::XLayoutContainer
+    virtual void SAL_CALL addChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException, css::awt::MaxChildrenException);
+    virtual void SAL_CALL removeChild( const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Sequence< css::uno::Reference
+                                < css::awt::XLayoutConstrains > > SAL_CALL getChildren()
+        throw (css::uno::RuntimeException);
+
+    virtual css::uno::Reference< css::beans::XPropertySet > SAL_CALL getChildProperties(
+        const css::uno::Reference< css::awt::XLayoutConstrains >& Child )
+        throw (css::uno::RuntimeException);
+
+    virtual void SAL_CALL allocateArea( const css::awt::Rectangle &rArea )
+        throw (css::uno::RuntimeException);
+
+    virtual css::awt::Size SAL_CALL getMinimumSize()
+        throw(css::uno::RuntimeException);
+
+    // unimplemented:
+    virtual sal_Bool SAL_CALL hasHeightForWidth()
+        throw(css::uno::RuntimeException)
+    { return false; }
+    virtual sal_Int32 SAL_CALL getHeightForWidth( sal_Int32 /*nWidth*/ )
+    throw(css::uno::RuntimeException)
+    { return maRequisition.Height; }
+
+    PROPHELPER_SET_INFO
+};
+
+} //  namespace layoutimpl
+
+#endif /*TABLE_HXX*/
diff --git a/layout/source/core/timer.cxx b/layout/source/core/timer.cxx
new file mode 100644
index 0000000..496d206
--- /dev/null
+++ layout/source/core/timer.cxx
@@ -0,0 +1,121 @@
+#include "timer.hxx"
+
+#include <vector>
+#include <list>
+#include <vcl/timer.hxx>
+#include <com/sun/star/awt/XLayoutContainer.hpp>
+
+namespace layoutimpl
+{
+using namespace ::com::sun::star;
+
+class AllocateTimer : public Timer
+{
+    typedef std::list< uno::Reference< awt::XLayoutContainer > > ContainerList;
+    ContainerList mxContainers;
+    uno::Reference< awt::XLayoutContainer > mxLastAdded;
+
+public:
+    AllocateTimer()
+    {
+        // timer set to 0 -- just process it as soon as it gets idle
+        SetTimeout( 0 );
+    }
+
+    static inline bool isParentOf( uno::Reference< awt::XLayoutContainer > xParent,
+                                   uno::Reference< awt::XLayoutContainer > xWidget )
+    {
+        while ( xWidget.is() )
+        {
+            if ( xWidget == xParent )
+                return true;
+            xWidget = uno::Reference< awt::XLayoutContainer >( xWidget->getParent(), uno::UNO_QUERY );
+        }
+        return false;
+    }
+
+    static inline void eraseChildren( ContainerList::iterator &it, ContainerList &list )
+    {
+        ContainerList::iterator jt = list.begin();
+        while ( jt != list.end() )
+        {
+            if ( it != jt && isParentOf( *it, *jt ) )
+                jt = list.erase( jt );
+            else
+                jt++;
+        }
+    }
+
+    static inline bool isContainerDamaged( uno::Reference< awt::XLayoutContainer > xContainer )
+    {
+        uno::Reference< awt::XLayoutConstrains > xConstrains( xContainer, uno::UNO_QUERY );
+        awt::Size lastReq( xContainer->getRequestedSize() );
+        awt::Size curReq( xConstrains->getMinimumSize() );
+        return lastReq.Width != curReq.Width || lastReq.Height != curReq.Height;
+    }
+
+    void add( const uno::Reference< awt::XLayoutContainer > &xContainer )
+    {
+        // small optimization
+        if ( mxLastAdded == xContainer )
+            return;
+        mxLastAdded = xContainer;
+
+        mxContainers.push_back( xContainer );
+    }
+
+    virtual void Timeout()
+    {
+        mxLastAdded = uno::Reference< awt::XLayoutContainer >();
+
+        // 1. remove duplications and children
+        for( ContainerList::iterator it = mxContainers.begin();
+             it != mxContainers.end(); it++ )
+            eraseChildren( it, mxContainers );
+
+        // 2. check damage extent
+        for( ContainerList::iterator it = mxContainers.begin();
+             it != mxContainers.end(); it++ )
+        {
+            uno::Reference< awt::XLayoutContainer > xContainer = *it;
+            while ( xContainer->getParent().is() && isContainerDamaged( xContainer ) )
+            {
+                xContainer = uno::Reference< awt::XLayoutContainer >(
+                    xContainer->getParent(), uno::UNO_QUERY );
+            }
+
+            if ( *it != xContainer )
+            {
+                // 2.2 replace it with parent
+                *it = xContainer;
+
+                // 2.3 remove children of new parent
+                eraseChildren( it, mxContainers );
+            }
+        }
+
+        // 3. force re-calculations
+        for( ContainerList::iterator it = mxContainers.begin();
+             it != mxContainers.end(); it++ )
+            (*it)->allocateArea( (*it)->getAllocatedArea() );
+    }
+};
+
+static void AddResizeTimeout( const uno::Reference< awt::XLayoutContainer > &xCont )
+{
+    static AllocateTimer timer;
+    timer.add( xCont );
+    timer.Start();
+}
+
+LayoutUnit::LayoutUnit() : LayoutUnit_Base()
+{
+}
+
+void SAL_CALL LayoutUnit::queueResize( const uno::Reference< awt::XLayoutContainer > &xContainer )
+    throw( uno::RuntimeException )
+{
+    AddResizeTimeout( xContainer );
+}
+
+}
diff --git a/layout/source/core/timer.hxx b/layout/source/core/timer.hxx
new file mode 100644
index 0000000..d87528c
--- /dev/null
+++ layout/source/core/timer.hxx
@@ -0,0 +1,22 @@
+#ifndef CORE_TIMER_HXX
+#define CORE_TIMER_HXX
+
+#include <com/sun/star/awt/XLayoutUnit.hpp>
+#include <cppuhelper/implbase1.hxx>
+
+namespace layoutimpl
+{
+
+typedef ::cppu::WeakImplHelper1< com::sun::star::awt::XLayoutUnit > LayoutUnit_Base;
+
+class LayoutUnit : public LayoutUnit_Base
+{
+public:
+    LayoutUnit();
+    void SAL_CALL queueResize( const com::sun::star::uno::Reference< com::sun::star::awt::XLayoutContainer > &xContainer )
+        throw( com::sun::star::uno::RuntimeException );
+};
+
+}
+
+#endif /*CORE_TIMER_HXX*/
diff --git a/layout/source/inc/layoutcore.hxx b/layout/source/inc/layoutcore.hxx
new file mode 100644
index 0000000..cce3a94
--- /dev/null
+++ layout/source/inc/layoutcore.hxx
@@ -0,0 +1,49 @@
+#ifndef _LAYOUT_CORE_HXX_
+#define _LAYOUT_CORE_HXX_
+
+#include <com/sun/star/awt/XToolkit.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+#include <com/sun/star/awt/XLayoutContainer.hpp>
+#include <com/sun/star/awt/XLayoutConstrains.hpp>
+
+#include <layout/layout.hxx>
+
+namespace layoutimpl
+{
+
+namespace css = layout::css;
+
+css::uno::Reference< css::awt::XLayoutContainer >
+createContainer( const rtl::OUString &rName );
+
+css::uno::Reference< css::awt::XLayoutConstrains >
+createWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
+              css::uno::Reference< css::uno::XInterface > xParent,
+              const rtl::OUString &rName, long nProps );
+
+css::uno::Reference< css::awt::XLayoutConstrains >
+createInternalWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
+                      css::uno::Reference< css::uno::XInterface > xParent,
+                      const rtl::OUString &rName, long nProps );
+
+css::uno::Reference< css::graphic::XGraphic > loadGraphic( const char *pName );
+
+// Helpers - unfortunately VCLXWindows don't implement XPropertySet
+// but containers do - these helpers help us to hide this
+namespace prophlp
+{
+// can we set properties on this handle ?
+bool canHandleProps( const css::uno::Reference< css::uno::XInterface > &xRef );
+// if so which properties ?
+css::uno::Reference< css::beans::XPropertySetInfo > queryPropertyInfo(
+    const css::uno::Reference< css::uno::XInterface > &xRef );
+// set / get ...
+void setProperty( const css::uno::Reference< css::uno::XInterface > &xRef,
+                  const rtl::OUString &rName,
+                  css::uno::Any aValue );
+css::uno::Any getProperty( const css::uno::Reference< css::uno::XInterface > &xRef,
+                           const rtl::OUString &rName );
+} // namespace prophlp
+} // namespace layoutimpl
+
+#endif // _LAYOUT_CORE_HXX_
diff --git a/layout/source/wrapper/makefile.mk b/layout/source/wrapper/makefile.mk
new file mode 100644
index 0000000..fb8545f
--- /dev/null
+++ layout/source/wrapper/makefile.mk
@@ -0,0 +1,24 @@
+PRJ=..$/..
+PRJNAME=layout
+TARGET=wrapper
+ENABLE_EXCEPTIONS=true
+TARGETTYPE=GUI
+
+.INCLUDE : settings.mk
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+CFLAGS += -DENABLE_LAYOUT
+
+CXXFILES= \
+	wrapper.cxx \
+	wbutton.cxx \
+	wcontainer.cxx \
+	wfield.cxx
+
+SLOFILES= \
+	$(SLO)$/wrapper.obj \
+	$(SLO)$/wbutton.obj \
+	$(SLO)$/wcontainer.obj \
+	$(SLO)$/wfield.obj
+
+.INCLUDE : target.mk
diff --git a/layout/source/wrapper/wbutton.cxx b/layout/source/wrapper/wbutton.cxx
new file mode 100644
index 0000000..73f2a04
--- /dev/null
+++ layout/source/wrapper/wbutton.cxx
@@ -0,0 +1,381 @@
+#include "wrapper.hxx"
+
+#include <com/sun/star/awt/XActionListener.hpp>
+#include <com/sun/star/awt/XButton.hpp>
+#include <com/sun/star/awt/XCheckBox.hpp>
+#include <com/sun/star/awt/XRadioButton.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <toolkit/awt/vclxwindow.hxx>
+#include <vcl/event.hxx>
+#include <vcl/msgbox.hxx>
+#include <vcl/svapp.hxx>
+#include <vcl/window.hxx>
+
+#include <list>
+
+#include "layoutcore.hxx"
+
+using namespace ::com::sun::star;
+
+namespace layout
+{
+
+// Window/Control/Button
+class ButtonImpl : public ControlImpl,
+                   public ::cppu::WeakImplHelper1< awt::XActionListener >,
+                   public ::cppu::WeakImplHelper1< awt::XItemListener >
+{
+    Link maClickHdl;
+  protected:
+    // we add toggle hooks here to cut on code
+    Link maToggleHdl;
+  public:
+    uno::Reference< awt::XButton > mxButton;
+    ButtonImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : ControlImpl( pCtx, xPeer, pWindow )
+        , mxButton( xPeer, uno::UNO_QUERY )
+    {
+        mxButton->addActionListener( this );
+    }
+
+    ~ButtonImpl()
+    {
+    }
+
+    virtual void Click() { /* make me pure virtual? */ };
+
+    void SetClickHdl( const Link& rLink )
+    {
+        maClickHdl = rLink;
+        if ( !rLink )
+            mxButton->removeActionListener( this );
+        else
+            mxButton->addActionListener( this );
+    }
+
+    virtual void SAL_CALL disposing( const css::lang::EventObject& /* Source */ )
+        throw (css::uno::RuntimeException)
+    { mxButton.clear(); }
+
+    virtual void SAL_CALL actionPerformed( const css::awt::ActionEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        if ( !maClickHdl )
+            Click();
+        else
+            maClickHdl.Call( static_cast<Window *>( mpWindow ) );
+    }
+
+    virtual  // HACK: doesn't need to be virtual... remove in future...
+    void SAL_CALL itemStateChanged( const css::awt::ItemEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        maToggleHdl.Call( static_cast<Window *>( mpWindow ) );
+    }
+
+    BOOL SetModeImage( css::uno::Reference< css::graphic::XGraphic > xGraph )
+    {
+        setProperty( "Graphic", uno::Any( xGraph ) );
+        return true;
+    }
+};
+
+void Button::SetText( const String& rStr )
+{
+    if ( !getImpl().mxButton.is() )
+        return;
+    getImpl().mxButton->setLabel( rStr );
+}
+
+void Button::SetClickHdl( const Link& rLink )
+{
+    getImpl().SetClickHdl( rLink );
+}
+
+BOOL Button::SetModeImage( const Image& rImage )
+{
+    return getImpl().SetModeImage( rImage.getImpl().mxGraphic );
+}
+
+void Button::SetImageAlign( ImageAlign eAlign )
+{
+    getImpl().setProperty( "ImageAlign", uno::Any( (sal_Int16) eAlign ) );
+}
+
+void Button::Click()
+{
+}
+
+DECL_GET_IMPL_IMPL( Button )
+DECL_CONSTRUCTOR_IMPLS( Button, Control, "button" );
+
+// Window/Control/Button/PushButton
+class PushButtonImpl : public ButtonImpl
+{
+  public:
+    PushButtonImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : ButtonImpl( pCtx, xPeer, pWindow ) {}
+
+    void SetToggleHdl( const Link& rLink )
+    {
+        // XButton doesn't have an explicit event for Toggle. Anyway, it is a
+        // superset of the clicks: all clicks, and explicit toggles
+        maToggleHdl = rLink;
+        if ( !rLink )
+            mxButton->removeActionListener( this );
+        else
+            mxButton->addActionListener( this );
+    }
+
+    virtual void SAL_CALL actionPerformed( const css::awt::ActionEvent& rEvent )
+        throw (css::uno::RuntimeException)
+    {
+        ButtonImpl::actionPerformed( rEvent );
+        fireToggle();
+    }
+
+    inline void fireToggle()
+    {
+        maToggleHdl.Call(  static_cast<Window *>( mpWindow ) );
+    }
+};
+
+void PushButton::Check( BOOL bCheck )
+{
+    getImpl().setProperty( "State", uno::Any( (sal_Int16) !!bCheck ) );
+    // XButton doesn't have explicit toggle event
+    getImpl().fireToggle();
+}
+
+BOOL PushButton::IsChecked() const
+{
+    return !!( getImpl().getProperty( "State" ).get< sal_Int16 >() );
+}
+
+void PushButton::Toggle()
+{
+    Check( true );
+}
+
+void PushButton::SetToggleHdl( const Link& rLink )
+{
+    getImpl().SetToggleHdl( rLink );
+}
+
+DECL_GET_IMPL_IMPL( PushButton )
+DECL_CONSTRUCTOR_IMPLS( PushButton, Button, "pushbutton" );
+
+ // HACK: put every radio button into a group :/
+static std::list< RadioButtonImpl*> mpRadioGroup;
+
+// Window/Control/Button/RadioButton
+class RadioButtonImpl : public ButtonImpl
+{
+public:
+    uno::Reference< awt::XRadioButton > mxRadioButton;
+    RadioButtonImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : ButtonImpl( pCtx, xPeer, pWindow )
+        , mxRadioButton( xPeer, uno::UNO_QUERY )
+    {
+        // TEMP:
+        mpRadioGroup.push_back( this );
+        mxRadioButton->addItemListener( this );
+    }
+
+    ~RadioButtonImpl()
+    {
+        //mxRadioButton->removeItemListener( this );
+        mpRadioGroup.pop_front();
+    }
+
+    void Check( BOOL bCheck )
+    {
+        if ( !mxRadioButton.is() )
+            return;
+        mxRadioButton->setState( !!bCheck );
+        fireToggle();
+
+        if ( bCheck )
+            unsetOthersGroup( this );
+    }
+
+    BOOL IsChecked()
+    {
+        if ( !mxRadioButton.is() )
+            return FALSE;
+        return mxRadioButton->getState();
+    }
+
+    static void unsetOthersGroup( RadioButtonImpl* current )
+    {
+        // set all others to false
+        for( std::list< RadioButtonImpl*>::iterator it = mpRadioGroup.begin();
+                 it != mpRadioGroup.end(); it++ )
+        {
+#if 0 // BREAKS in OOo
+            if ( *it != current )
+                (*it)->Check( false );
+#else
+            if ( *it != current && (*it)->IsChecked() )
+            {
+                (*it)->Check( false );
+                return;
+            }
+#endif
+        }
+    }
+
+    void SetToggleHdl( const Link& rLink )
+    {
+        maToggleHdl = rLink;
+#if 0
+        if ( !rLink )
+            mxRadioButton->removeItemListener( this );
+        else
+            mxRadioButton->addItemListener( this );
+#endif
+    }
+
+    inline void fireToggle()
+    {
+        maToggleHdl.Call(  static_cast<Window *>( mpWindow ) );
+    }
+
+//HACK: temp
+    virtual void SAL_CALL itemStateChanged( const css::awt::ItemEvent& rEvent )
+        throw (css::uno::RuntimeException)
+    {
+        if ( !!maToggleHdl )
+        ButtonImpl::itemStateChanged( rEvent );
+
+        if ( IsChecked() )
+            unsetOthersGroup( this );
+    }
+};
+
+void RadioButton::Check( BOOL bCheck )
+{
+    getImpl().Check( bCheck );
+}
+
+BOOL RadioButton::IsChecked() const
+{
+    return getImpl().IsChecked();
+}
+
+void RadioButton::SetToggleHdl( const Link& rLink )
+{
+    getImpl().SetToggleHdl( rLink );
+}
+
+DECL_GET_IMPL_IMPL( RadioButton )
+DECL_CONSTRUCTOR_IMPLS( RadioButton, Button, "radiobutton" );
+
+// Window/Control/Button/CheckBox
+class CheckBoxImpl : public ButtonImpl
+{
+  public:
+    uno::Reference< awt::XCheckBox > mxCheckBox;
+    CheckBoxImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : ButtonImpl( pCtx, xPeer, pWindow )
+        , mxCheckBox( xPeer, uno::UNO_QUERY ) {}
+
+    void SetToggleHdl( const Link& rLink )
+    {
+        maToggleHdl = rLink;
+        if ( !rLink )
+            mxCheckBox->removeItemListener( this );
+        else
+            mxCheckBox->addItemListener( this );
+    }
+};
+
+void CheckBox::Check( BOOL bCheck )
+{
+    if ( !getImpl().mxCheckBox.is() )
+        return;
+    getImpl().mxCheckBox->setState( !!bCheck );
+}
+
+BOOL CheckBox::IsChecked() const
+{
+    if ( !getImpl().mxCheckBox.is() )
+        return FALSE;
+    return getImpl().mxCheckBox->getState();
+}
+
+void CheckBox::SetToggleHdl( const Link& rLink )
+{
+    getImpl().SetToggleHdl( rLink );
+}
+
+DECL_GET_IMPL_IMPL( CheckBox )
+DECL_CONSTRUCTOR_IMPLS( CheckBox, Button, "checkbox" );
+
+// Window/Control/Button/PushButton/etc
+#define BUTTON_IMPL(t, parent, response) \
+    class t##Impl : public parent##Impl \
+    { \
+    public: \
+        t##Impl( Context *pCtx, PeerHandle const& xPeer, Window *pWindow ) \
+            : parent##Impl( pCtx, xPeer, pWindow ) \
+        { \
+        } \
+        void Click() \
+        { \
+            Dialog *d = static_cast<Dialog *>( mpCtx ); \
+            d->EndDialog( response ); \
+        } \
+    }
+
+/* Common button types currently unavailable in OOo: */
+/* mpReset */
+/* mpApply */
+/* mpAction */
+#define RET_RESET 6
+#define RET_APPLY 7
+#define BUTTONID_RESET RET_RESET
+#define BUTTONID_APPLY RET_APPLY
+
+BUTTON_IMPL( OKButton, PushButton, BUTTONID_OK );
+BUTTON_IMPL( CancelButton, PushButton, BUTTONID_CANCEL );
+BUTTON_IMPL( YesButton, PushButton, BUTTONID_YES );
+BUTTON_IMPL( NoButton, PushButton, BUTTONID_NO );
+BUTTON_IMPL( RetryButton, PushButton, BUTTONID_RETRY );
+BUTTON_IMPL( IgnoreButton, PushButton, BUTTONID_IGNORE );
+BUTTON_IMPL( ResetButton, PushButton, BUTTONID_RESET );
+BUTTON_IMPL( ApplyButton, PushButton, BUTTONID_APPLY ); /* Deprecated? */
+BUTTON_IMPL( HelpButton, PushButton, BUTTONID_HELP );
+
+DECL_CONSTRUCTOR_IMPLS( OKButton, PushButton, "okbutton" );
+DECL_CONSTRUCTOR_IMPLS( CancelButton, PushButton, "cancelbutton" );
+DECL_CONSTRUCTOR_IMPLS( YesButton, PushButton, "yesbutton" );
+DECL_CONSTRUCTOR_IMPLS( NoButton, PushButton, "nobutton" );
+DECL_CONSTRUCTOR_IMPLS( RetryButton, PushButton, "retrybutton" );
+DECL_CONSTRUCTOR_IMPLS( IgnoreButton, PushButton, "ignorebutton" );
+DECL_CONSTRUCTOR_IMPLS( ResetButton, PushButton, "resetbutton" );
+DECL_CONSTRUCTOR_IMPLS( ApplyButton, PushButton, "applybutton" );  /* Deprecated? */
+DECL_CONSTRUCTOR_IMPLS( HelpButton, PushButton, "helpbutton" );
+
+
+ImageImpl::ImageImpl( const char *pName )
+    : mxGraphic( layoutimpl::loadGraphic( pName ) )
+{
+    if ( !mxGraphic.is() )
+    {
+        DBG_ERROR1( "ERROR: failed to load image: `%s'", pName );
+    }
+
+}
+
+Image::Image( const char *pName )
+    : pImpl( new ImageImpl( pName ) )
+{
+}
+
+Image::~Image()
+{
+    delete pImpl;
+}
+
+}; // namespace layout
diff --git a/layout/source/wrapper/wcontainer.cxx b/layout/source/wrapper/wcontainer.cxx
new file mode 100644
index 0000000..6057fbc
--- /dev/null
+++ layout/source/wrapper/wcontainer.cxx
@@ -0,0 +1,202 @@
+#include "wrapper.hxx"
+
+#include "layoutcore.hxx"
+#include <com/sun/star/awt/XLayoutRoot.hpp>
+#include <com/sun/star/awt/XLayoutContainer.hpp>
+
+#include <comphelper/processfactory.hxx>
+
+#include <tools/debug.hxx>
+
+using namespace ::com::sun::star;
+
+namespace layout
+{
+
+// Container
+Container::Container( const Context *pCtx, const char *pId )
+    : mxContainer( pCtx->GetPeerHandle( pId ), uno::UNO_QUERY )
+{
+    if ( !mxContainer.is() )
+    {
+        DBG_ERROR1( "Error: failed to associate container with '%s'", pId );
+    }
+}
+
+Container::Container( const rtl::OUString &rName, sal_Int32 nBorder )
+{
+    mxContainer = layoutimpl::createContainer( rName );
+
+    uno::Reference< beans::XPropertySet > xProps( mxContainer, uno::UNO_QUERY_THROW );
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Border" ) ),
+                              uno::Any( nBorder ) );
+}
+
+void Container::Add( Window *pChild )
+{
+    if ( pChild )
+    {
+        uno::Reference< awt::XLayoutConstrains > xChild( pChild->GetPeer(), uno::UNO_QUERY );
+        mxContainer->addChild( xChild );
+    }
+}
+
+void Container::Add( Container *pChild )
+{
+    if ( pChild )
+    {
+        uno::Reference< awt::XLayoutConstrains > xChild( pChild->getImpl(), uno::UNO_QUERY );
+        mxContainer->addChild( xChild );
+    }
+}
+
+void Container::Remove( Window *pChild )
+{
+    if ( pChild )
+    {
+        uno::Reference< awt::XLayoutConstrains > xChild( pChild->GetPeer(), uno::UNO_QUERY );
+        mxContainer->removeChild( xChild );
+    }
+}
+
+void Container::Remove( Container *pChild )
+{
+    if ( pChild )
+    {
+        uno::Reference< awt::XLayoutConstrains > xChild( pChild->getImpl(), uno::UNO_QUERY );
+        mxContainer->removeChild( xChild );
+    }
+}
+
+void Container::Clear()
+{
+    css::uno::Sequence< css::uno::Reference < css::awt::XLayoutConstrains > > children;
+    children = mxContainer->getChildren();
+    for( int i = 0; i < children.getLength(); i++ )
+        mxContainer->removeChild( children[ i ] );
+}
+
+void Container::ShowAll( bool bShow )
+{
+    struct inner
+    {
+        static void setChildrenVisible( uno::Reference < awt::XLayoutContainer > xCont,
+                                        bool bVisible )  /* auxiliary */
+        {
+            if ( xCont.is() )
+            {
+                uno::Sequence< uno::Reference < awt::XLayoutConstrains > > aChildren;
+                aChildren = xCont->getChildren();
+                for( int i = 0; i < aChildren.getLength(); i++ )
+                {
+                    uno::Reference < awt::XLayoutConstrains > xChild( aChildren[ i ] );
+
+                    uno::Reference< awt::XWindow > xWin( xChild, uno::UNO_QUERY);
+                    if ( xWin.is() )
+                        xWin->setVisible( bVisible );
+
+                    uno::Reference < awt::XLayoutContainer > xChildCont(
+                        xChild, uno::UNO_QUERY );
+                    setChildrenVisible( xChildCont, bVisible );
+                }
+            }
+        }
+    };
+
+    inner::setChildrenVisible( mxContainer, bShow );
+}
+
+// Container/Table
+Table::Table( sal_Int32 nBorder, sal_Int32 nColumns )
+    : Container( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "table" ) ), nBorder )
+{
+    uno::Reference< beans::XPropertySet > xProps( mxContainer, uno::UNO_QUERY_THROW );
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Columns" ) ),
+                              uno::Any( nColumns ) );
+}
+
+void Table::Add( Window *pWindow, bool bXExpand, bool bYExpand,
+                 sal_Int32 nXSpan, sal_Int32 nYSpan )
+{
+    if ( !pWindow )
+        return;
+    WindowImpl &rImpl = pWindow->getImpl();
+    uno::Reference< awt::XLayoutConstrains > xChild( rImpl.mxWindow,
+                                                     uno::UNO_QUERY );
+    mxContainer->addChild( xChild );
+    setProps( xChild, bXExpand, bYExpand, nXSpan, nYSpan );
+}
+
+void Table::Add( Container *pContainer, bool bXExpand, bool bYExpand,
+                 sal_Int32 nXSpan, sal_Int32 nYSpan )
+{
+    if ( !pContainer )
+        return;
+    uno::Reference< awt::XLayoutConstrains > xChild( pContainer->getImpl(),
+                                                     uno::UNO_QUERY );
+    mxContainer->addChild( xChild );
+    setProps( xChild, bXExpand, bYExpand, nXSpan, nYSpan );
+}
+
+void Table::setProps( uno::Reference< awt::XLayoutConstrains > xChild,
+                      bool bXExpand, bool bYExpand, sal_Int32 nXSpan, sal_Int32 nYSpan )
+{
+    uno::Reference< beans::XPropertySet > xProps
+        ( mxContainer->getChildProperties( xChild ), uno::UNO_QUERY_THROW );
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "XExpand" ) ),
+                              uno::Any( bXExpand ) );
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "YExpand" ) ),
+                              uno::Any( bYExpand ) );
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "ColSpan" ) ),
+                              uno::Any( nXSpan ) );
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "RowSpan" ) ),
+                              uno::Any( nYSpan ) );
+}
+
+// Container/Box
+Box::Box( const rtl::OUString &rName, sal_Int32 nBorder, bool bHomogeneous )
+    : Container( rName, nBorder )
+{
+    uno::Reference< beans::XPropertySet > xProps( mxContainer, uno::UNO_QUERY_THROW );
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "Homogeneous" ) ),
+                              uno::Any( bHomogeneous ) );
+}
+
+void Box::Add( Window *pWindow, bool bExpand, bool bFill, sal_Int32 nPadding)
+{
+    if ( !pWindow )
+        return;
+    WindowImpl &rImpl = pWindow->getImpl();
+    uno::Reference< awt::XLayoutConstrains > xChild( rImpl.mxWindow,
+                                                     uno::UNO_QUERY );
+
+    mxContainer->addChild( xChild );
+    setProps( xChild, bExpand, bFill, nPadding );
+}
+
+void Box::Add( Container *pContainer, bool bExpand, bool bFill, sal_Int32 nPadding)
+{
+    if ( !pContainer )
+        return;
+
+    uno::Reference< awt::XLayoutConstrains > xChild( pContainer->getImpl(),
+                                                     uno::UNO_QUERY );
+    mxContainer->addChild( xChild );
+    setProps( xChild, bExpand, bFill, nPadding );
+}
+
+void Box::setProps( uno::Reference< awt::XLayoutConstrains > xChild,
+                    bool bExpand, bool bFill, sal_Int32 nPadding )
+{
+    uno::Reference< beans::XPropertySet > xProps
+        ( mxContainer->getChildProperties( xChild ), uno::UNO_QUERY_THROW );
+
+    xProps->setPropertyValue( rtl::OUString ( RTL_CONSTASCII_USTRINGPARAM( "Expand" ) ),
+                              uno::Any( bExpand ) );
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Fill" ) ),
+                              uno::Any( bFill ) );
+    xProps->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Padding" ) ),
+                              uno::Any( nPadding ) );
+}
+
+}; // end namespace layout
diff --git a/layout/source/wrapper/wfield.cxx b/layout/source/wrapper/wfield.cxx
new file mode 100644
index 0000000..46aae21
--- /dev/null
+++ layout/source/wrapper/wfield.cxx
@@ -0,0 +1,582 @@
+#include "wrapper.hxx"
+
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/awt/XMetricField.hpp>
+#include <com/sun/star/awt/XCurrencyField.hpp>
+#include <com/sun/star/awt/XTextComponent.hpp>
+#include <com/sun/star/awt/XListBox.hpp>
+#include <com/sun/star/awt/XComboBox.hpp>
+#include <cppuhelper/implbase1.hxx>
+#include <com/sun/star/awt/XActionListener.hpp>
+#include <com/sun/star/awt/XItemListener.hpp>
+
+using namespace ::com::sun::star;
+
+namespace layout
+{
+
+class EditImpl : public ControlImpl,
+                 public ::cppu::WeakImplHelper1< awt::XTextListener >
+{
+    Link maModifyHdl;
+  public:
+    uno::Reference< awt::XTextComponent > mxEdit;
+    EditImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : ControlImpl( pCtx, xPeer, pWindow )
+        ,  mxEdit( xPeer, uno::UNO_QUERY )
+    {
+    }
+
+    virtual void SAL_CALL disposing( const css::lang::EventObject& /* Source */ )
+        throw (css::uno::RuntimeException)
+    {
+        SetModifyHdl( Link() );
+        mxEdit.clear();
+    }
+
+    void SetModifyHdl( const Link& rLink )
+    {
+        if ( !mxEdit.is() )
+            return;
+        maModifyHdl = rLink;
+        if ( !rLink )
+            mxEdit->removeTextListener( this );
+        else
+            mxEdit->addTextListener( this );
+    }
+
+    void SAL_CALL textChanged( const css::awt::TextEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        maModifyHdl.Call( mpWindow );
+    }
+};
+
+void Edit::SetText( const XubString& rStr ) const
+{
+    if ( !getImpl().mxEdit.is() )
+        return;
+    getImpl().mxEdit->setText( rStr );
+}
+
+XubString Edit::GetText() const
+{
+    if ( !getImpl().mxEdit.is() )
+        return XubString();
+    return XubString( getImpl().mxEdit->getText());
+}
+
+void Edit::SetModifyHdl( const Link& rLink )
+{
+    getImpl().SetModifyHdl( rLink );
+}
+
+DECL_CONSTRUCTOR_IMPLS( Edit, Control, "edit" );
+DECL_GET_IMPL_IMPL( Edit )
+
+// Window/Control/Edit/MultiLineEdit
+class MultiLineEditImpl : public EditImpl
+{
+public:
+    MultiLineEditImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : EditImpl( pCtx, xPeer, pWindow )
+    {
+    }
+};
+
+DECL_CONSTRUCTOR_IMPLS( MultiLineEdit, Edit, "multilineedit" );
+DECL_GET_IMPL_IMPL( MultiLineEdit )
+
+// Window/Control/Edit/SpinField
+class SpinFieldImpl : public EditImpl
+{
+  public:
+    SpinFieldImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : EditImpl( pCtx, xPeer, pWindow ) {}
+};
+
+DECL_CONSTRUCTOR_IMPLS( SpinField, Edit, "spinfield" );
+
+// Window/Control/Edit/SpinField/NumericField
+class NumericFieldImpl : public SpinFieldImpl
+{
+  public:
+    NumericFieldImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : SpinFieldImpl( pCtx, xPeer, pWindow ) {}
+};
+
+// Window/Control/Edit/SpinField/MetricField
+class MetricFieldImpl : public SpinFieldImpl
+{
+  public:
+    MetricFieldImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : SpinFieldImpl( pCtx, xPeer, pWindow ) {}
+};
+
+DECL_GET_IMPL_IMPL( SpinField )
+DECL_GET_IMPL_IMPL( NumericField )
+DECL_GET_IMPL_IMPL( MetricField )
+
+// FormatterBase
+class FormatterBaseImpl
+{
+  protected:
+    PeerHandle mxPeer;
+  public:
+    explicit FormatterBaseImpl( const PeerHandle &xPeer )
+        : mxPeer( xPeer ) {};
+};
+
+class NumericFormatterImpl : public FormatterBaseImpl
+{
+  public:
+    uno::Reference< awt::XCurrencyField > mxField;
+    explicit NumericFormatterImpl( const PeerHandle &xPeer )
+        : FormatterBaseImpl( xPeer )
+        , mxField( xPeer, uno::UNO_QUERY ) {}
+
+    // FIXME: burn that CPU ! cut/paste from vclxwindows.cxx
+    double valueToDouble( sal_Int64 nValue )
+    {
+        sal_Int16 nDigits = mxField->getDecimalDigits();
+        double n = nValue;
+        for ( sal_uInt16 d = 0; d < nDigits; d++ )
+            n /= 10;
+        return n;
+    } // FIXME: burn that CPU ! cut/paste from vclxwindows.cxx
+    sal_Int64 doubleToValue( double nValue )
+    {
+        sal_Int16 nDigits = mxField->getDecimalDigits();
+        double n = nValue;
+        for ( sal_uInt16 d = 0; d < nDigits; d++ )
+            n *= 10;
+        return (sal_Int64) n;
+    }
+};
+
+class MetricFormatterImpl : public FormatterBaseImpl
+{
+  public:
+    uno::Reference< awt::XMetricField > mxField;
+    explicit MetricFormatterImpl( const PeerHandle &xPeer )
+        : FormatterBaseImpl( xPeer )
+        , mxField( xPeer, uno::UNO_QUERY ) {}
+};
+
+// NumericFormatter
+
+NumericFormatter::NumericFormatter( FormatterBaseImpl *pImpl )
+    : FormatterBase( pImpl )
+{
+}
+
+NumericFormatterImpl& NumericFormatter::getFormatImpl() const
+{
+    return *( static_cast<NumericFormatterImpl *>( mpFormatImpl ) );
+}
+
+#define SET_IMPL(vclmethod, idlmethod) \
+    void NumericFormatter::vclmethod( sal_Int64 nValue ) \
+    { \
+        if ( !getFormatImpl().mxField.is() ) \
+            return; \
+        getFormatImpl().mxField->idlmethod( getFormatImpl().valueToDouble( nValue ) ); \
+    }
+
+SET_IMPL( SetMin, setMin )
+SET_IMPL( SetMax, setMax )
+SET_IMPL( SetLast, setLast )
+SET_IMPL( SetFirst, setFirst )
+SET_IMPL( SetValue, setValue )
+SET_IMPL( SetSpinSize, setSpinSize )
+
+sal_Int64 NumericFormatter::GetValue() const
+{
+    if ( !getFormatImpl().mxField.is() )
+        return 0;
+    return getFormatImpl().doubleToValue( getFormatImpl().mxField->getValue() );
+}
+
+#undef SET_IMPL
+
+DECL_CONSTRUCTOR_IMPLS_2( NumericField, SpinField, NumericFormatter, "numericfield" );
+
+// MetricFormatter
+
+MetricFormatter::MetricFormatter( FormatterBaseImpl *pImpl )
+    : FormatterBase( pImpl ) {}
+MetricFormatterImpl& MetricFormatter::getFormatImpl() const
+{    return *( static_cast<MetricFormatterImpl *>( mpFormatImpl ) );   }
+
+#define MetricUnitVclToUno(a) ((sal_uInt16)(a))
+
+#define SET_IMPL(vclmethod, idlmethod) \
+    void MetricFormatter::vclmethod( sal_Int64 nValue, FieldUnit nUnit ) \
+    { \
+        if ( !getFormatImpl().mxField.is() ) \
+            return; \
+        getFormatImpl().mxField->idlmethod( nValue, MetricUnitVclToUno( nUnit ) ); \
+    }
+
+SET_IMPL( SetMin, setMin )
+SET_IMPL( SetMax, setMax )
+SET_IMPL( SetLast, setLast )
+SET_IMPL( SetFirst, setFirst )
+SET_IMPL( SetValue, setValue )
+
+#undef SET_IMPL
+
+void MetricFormatter::SetSpinSize( sal_Int64 nValue )
+{
+    if ( !getFormatImpl().mxField.is() )
+        return;
+    getFormatImpl().mxField->setSpinSize( nValue );
+}
+
+sal_Int64 MetricFormatter::GetValue( FieldUnit nUnit ) const
+{
+    if ( !getFormatImpl().mxField.is() )
+        return 0;
+    return getFormatImpl().mxField->getValue( MetricUnitVclToUno( nUnit ) );
+}
+
+DECL_CONSTRUCTOR_IMPLS_2( MetricField, SpinField, MetricFormatter, "metricfield" );
+
+// Window/Control/Edit/ComboBox
+class ComboBoxImpl : public EditImpl,
+                     public ::cppu::WeakImplHelper1< awt::XActionListener >,
+                     public ::cppu::WeakImplHelper1< awt::XItemListener >
+{
+    Link maClickHdl, maSelectHdl;
+public:
+    uno::Reference< awt::XComboBox > mxComboBox;
+    ComboBoxImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : EditImpl( pCtx, xPeer, pWindow ),
+        mxComboBox( xPeer, uno::UNO_QUERY )
+    {
+    }
+
+    USHORT InsertEntry(const XubString& rStr, USHORT nPos)
+    {
+        if ( nPos == COMBOBOX_APPEND )
+            nPos = GetEntryCount();
+        mxComboBox->addItem( rtl::OUString( rStr ), nPos );
+        return nPos;
+    }
+
+    void RemoveEntry( USHORT nPos )
+    {
+        mxComboBox->removeItems( nPos, 1 );
+    }
+
+    USHORT GetEntryPos( const XubString& rStr ) const
+    {
+        uno::Sequence< rtl::OUString> aItems( mxComboBox->getItems() );
+        rtl::OUString rKey( rStr );
+        for( unsigned int i = 0; aItems.getLength(); i++ )
+        {
+            if ( aItems[ i ] == rKey )
+                return i;
+        }
+        return COMBOBOX_ENTRY_NOTFOUND;
+    }
+
+    XubString GetEntry( USHORT nPos ) const
+    {
+        return XubString( mxComboBox->getItem( nPos ) );
+    }
+
+    USHORT GetEntryCount() const
+    {
+        return mxComboBox->getItemCount();
+    }
+
+    void SetClickHdl( const Link& rLink )
+    {
+        maClickHdl = rLink;
+        if ( !rLink )
+            mxComboBox->removeActionListener( this );
+        else
+            mxComboBox->addActionListener( this );
+    }
+
+    void SetSelectHdl( const Link& rLink )
+    {
+        maSelectHdl = rLink;
+        if ( !rLink )
+            mxComboBox->removeItemListener( this );
+        else
+            mxComboBox->addItemListener( this );
+    }
+
+    virtual void SAL_CALL disposing( const css::lang::EventObject& /* Source */ )
+        throw (css::uno::RuntimeException)
+    {
+        mxComboBox.clear();
+    }
+
+    virtual void SAL_CALL actionPerformed( const css::awt::ActionEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        ComboBox* pComboBox = static_cast<ComboBox*>( mpWindow );
+        if ( !pComboBox )
+            return;
+        maClickHdl.Call( pComboBox );
+    }
+
+    virtual void SAL_CALL itemStateChanged( const css::awt::ItemEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        ComboBox* pComboBox = static_cast<ComboBox*>( mpWindow );
+        if ( !pComboBox )
+            return;
+        maSelectHdl.Call( pComboBox );
+    }
+};
+
+USHORT ComboBox::InsertEntry( const XubString &rStr, USHORT nPos )
+{
+    return getImpl().InsertEntry( rStr, nPos );
+}
+
+void ComboBox::RemoveEntry( const XubString& rStr )
+{
+    getImpl().RemoveEntry( GetEntryPos( rStr ) );
+}
+
+void ComboBox::RemoveEntry( USHORT nPos )
+{
+    getImpl().RemoveEntry( nPos );
+}
+
+void ComboBox::Clear()
+{
+    uno::Sequence< rtl::OUString> aNoItems;
+    getImpl().setProperty( "StringItemList", uno::Any( aNoItems ) );
+}
+
+USHORT ComboBox::GetEntryPos( const XubString& rStr ) const
+{
+    return getImpl().GetEntryPos( rStr );
+}
+
+XubString ComboBox::GetEntry( USHORT nPos ) const
+{
+    rtl::OUString rItem = getImpl().mxComboBox->getItem( nPos );
+    return XubString( rItem );
+}
+
+USHORT ComboBox::GetEntryCount() const
+{
+    return getImpl().GetEntryCount();
+}
+
+void ComboBox::SetClickHdl( const Link& rLink )
+{
+    getImpl().SetClickHdl( rLink );
+}
+
+void ComboBox::SetSelectHdl( const Link& rLink )
+{
+    getImpl().SetSelectHdl( rLink );
+}
+
+DECL_CONSTRUCTOR_IMPLS( ComboBox, Edit, "combobox" );
+DECL_GET_IMPL_IMPL( ComboBox )
+
+// Window/Control/ListBox
+class ListBoxImpl : public ControlImpl,
+                    public ::cppu::WeakImplHelper1< awt::XActionListener >,
+                    public ::cppu::WeakImplHelper1< awt::XItemListener >
+{
+    Link maClickHdl, maSelectHdl;
+public:
+    uno::Reference< awt::XListBox > mxListBox;
+    ListBoxImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : ControlImpl( pCtx, xPeer, pWindow ),
+        mxListBox( xPeer, uno::UNO_QUERY )
+    {
+    }
+
+    USHORT InsertEntry(const XubString& rStr, USHORT nPos)
+    {
+        if ( nPos == LISTBOX_APPEND )
+            nPos = mxListBox->getItemCount();
+        mxListBox->addItem( rtl::OUString( rStr ), nPos );
+        return nPos;
+    }
+
+    void RemoveEntry( USHORT nPos )
+    {
+        mxListBox->removeItems( nPos, 1 );
+    }
+
+    USHORT RemoveEntry(const XubString& rStr, USHORT nPos)
+    {
+        if ( nPos == LISTBOX_APPEND )
+            nPos = mxListBox->getItemCount();
+        mxListBox->addItem( rtl::OUString( rStr ), nPos );
+        return nPos;
+    }
+
+    USHORT GetEntryPos( const XubString& rStr ) const
+    {
+        uno::Sequence< rtl::OUString> aItems( mxListBox->getItems() );
+        rtl::OUString rKey( rStr );
+        for( unsigned int i = 0; aItems.getLength(); i++ )
+        {
+            if ( aItems[ i ] == rKey )
+                return i;
+        }
+        return LISTBOX_ENTRY_NOTFOUND;
+    }
+
+    XubString GetEntry( USHORT nPos ) const
+    {
+        return mxListBox->getItem( nPos );
+    }
+
+    USHORT GetEntryCount() const
+    {
+        return mxListBox->getItemCount();
+    }
+
+    void SelectEntryPos( USHORT nPos, BOOL bSelect )
+    {
+        mxListBox->selectItemPos( nPos, bSelect );
+    }
+
+    USHORT GetSelectEntryCount() const
+    {
+        return mxListBox->getSelectedItems().getLength();
+    }
+
+    USHORT GetSelectEntryPos( USHORT nSelIndex ) const
+    {
+        USHORT nSelected = 0;
+        if ( mxListBox->isMutipleMode() )
+        {
+            uno::Sequence< short > aItems( mxListBox->getSelectedItemsPos() );
+            if ( nSelIndex < aItems.getLength() )
+                nSelected = aItems[ nSelIndex ];
+        }
+        else
+            nSelected = mxListBox->getSelectedItemPos();
+        return nSelected;
+    }
+
+    void SetClickHdl( const Link& rLink )
+    {
+        maClickHdl = rLink;
+        if ( !rLink )
+            mxListBox->removeActionListener( this );
+        else
+            mxListBox->addActionListener( this );
+    }
+
+    void SetSelectHdl( const Link& rLink )
+    {
+        maSelectHdl = rLink;
+        if ( !rLink )
+            mxListBox->removeItemListener( this );
+        else
+            mxListBox->addItemListener( this );
+    }
+
+    virtual void SAL_CALL disposing( const css::lang::EventObject& /* Source */ )
+        throw (css::uno::RuntimeException)
+    {
+        mxListBox.clear();
+    }
+
+    void SAL_CALL actionPerformed( const css::awt::ActionEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        maClickHdl.Call( mpWindow );
+    }
+
+    void SAL_CALL itemStateChanged( const css::awt::ItemEvent& /* rEvent */ )
+        throw (css::uno::RuntimeException)
+    {
+        ListBox* pListBox = static_cast<ListBox*>( mpWindow );
+        if ( !pListBox )
+            return;
+        maSelectHdl.Call( pListBox );
+    }
+};
+
+USHORT ListBox::InsertEntry(const XubString& rStr, USHORT nPos)
+{
+    return getImpl().InsertEntry(rStr, nPos);
+}
+
+void ListBox::RemoveEntry( USHORT nPos )
+{
+    return getImpl().RemoveEntry( nPos );
+}
+
+void ListBox::RemoveEntry( const XubString& rStr )
+{
+    return getImpl().RemoveEntry( GetEntryPos( rStr ) );
+}
+
+void ListBox::Clear()
+{
+    uno::Sequence< rtl::OUString> aNoItems;
+    getImpl().setProperty( "StringItemList", uno::Any( aNoItems ) );
+}
+
+USHORT ListBox::GetEntryPos( const XubString& rStr ) const
+{
+    return getImpl().GetEntryPos( rStr );
+}
+
+XubString ListBox::GetEntry( USHORT nPos ) const
+{
+    return getImpl().GetEntry( nPos );
+}
+
+USHORT ListBox::GetEntryCount() const
+{
+    return getImpl().GetEntryCount();
+}
+
+void ListBox::SelectEntryPos( USHORT nPos, BOOL bSelect )
+{
+    getImpl().SelectEntryPos( nPos, bSelect );
+}
+
+void ListBox::SelectEntry( const XubString& rStr, BOOL bSelect )
+{
+    SelectEntryPos( GetEntryPos( rStr ), bSelect );
+}
+
+USHORT ListBox::GetSelectEntryCount() const
+{
+    return getImpl().GetSelectEntryCount();
+}
+
+USHORT ListBox::GetSelectEntryPos( USHORT nSelIndex ) const
+{
+    return getImpl().GetSelectEntryPos( nSelIndex );
+}
+
+XubString ListBox::GetSelectEntry( USHORT nSelIndex ) const
+{
+    return GetEntry( GetSelectEntryPos( nSelIndex ) );
+}
+
+void ListBox::SetSelectHdl( const Link& rLink )
+{
+    getImpl().SetSelectHdl( rLink );
+}
+
+void ListBox::SetClickHdl( const Link& rLink )
+{
+    getImpl().SetClickHdl( rLink );
+}
+
+DECL_CONSTRUCTOR_IMPLS( ListBox, Control, "listbox" );
+DECL_GET_IMPL_IMPL( ListBox )
+
+}; // end namespace layout
diff --git a/layout/source/wrapper/wrapper.cxx b/layout/source/wrapper/wrapper.cxx
new file mode 100644
index 0000000..41d093a
--- /dev/null
+++ layout/source/wrapper/wrapper.cxx
@@ -0,0 +1,461 @@
+#include "wrapper.hxx"
+
+#include <com/sun/star/awt/XFixedText.hpp>
+#include <com/sun/star/awt/XDialog2.hpp>
+#include <com/sun/star/awt/WindowAttribute.hpp>
+#include <com/sun/star/awt/VclWindowPeerAttribute.hpp>
+#include <comphelper/processfactory.hxx>
+#include <vcl/window.hxx>
+#include <toolkit/awt/vclxwindow.hxx>
+
+#include "layoutcore.hxx"
+#include "../core/factory.hxx"
+#include "../core/root.hxx"
+
+using namespace ::com::sun::star;
+
+namespace layout
+{
+
+// Context bits ...
+class ContextImpl
+{
+    uno::Reference< awt::XLayoutRoot > mxRoot;
+    uno::Reference< container::XNameAccess > mxNameAccess;
+    PeerHandle mxTopLevel;
+
+public:
+    ContextImpl( char const *pPath )
+    {
+        uno::Sequence< uno::Any > aParams( 1 );
+        aParams[0] <<= rtl::OUString( pPath, strlen( pPath ), RTL_TEXTENCODING_UTF8 );
+
+        uno::Reference< lang::XSingleServiceFactory > xFactory(
+            comphelper::createProcessComponent(
+                rtl::OUString::createFromAscii( "com.sun.star.awt.Layout" ) ),
+            uno::UNO_QUERY );
+        if ( !xFactory.is() )
+        {
+            throw uno::RuntimeException(
+                rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Layout engine not installed" ) ),
+                uno::Reference< uno::XInterface >() );
+        }
+        mxRoot = uno::Reference< awt::XLayoutRoot >(
+            xFactory->createInstanceWithArguments( aParams ),
+            uno::UNO_QUERY );
+
+        mxNameAccess = uno::Reference< container::XNameAccess >( mxRoot, uno::UNO_QUERY );
+    }
+
+    ~ContextImpl()
+    {
+    }
+
+    PeerHandle getByName( const rtl::OUString &rName )
+    {
+        uno::Any val = mxNameAccess->getByName( rName );
+        PeerHandle xRet;
+        val >>= xRet;
+        return xRet;
+    }
+    PeerHandle getTopLevel()                 { return mxTopLevel; }
+    void setTopLevel( PeerHandle xToplevel ) { mxTopLevel = xToplevel; }
+    PeerHandle getRoot()                     { return mxRoot; }
+};
+
+Context::Context( const char *pPath )
+    : pImpl( new ContextImpl( pPath ) )
+{
+}
+Context::~Context()
+{
+    delete pImpl;
+    pImpl = NULL;
+}
+
+void Context::setToplevel( PeerHandle xToplevel )
+{
+    pImpl->setTopLevel( xToplevel );
+}
+
+PeerHandle Context::getToplevel()
+{
+    return pImpl->getTopLevel();
+}
+PeerHandle Context::getRoot()
+{
+     return pImpl->getRoot();
+}
+
+PeerHandle Context::GetPeerHandle( const char *pId, sal_uInt32 nId ) const
+{
+    PeerHandle xHandle;
+    xHandle = pImpl->getByName( rtl::OUString( pId, strlen( pId ), RTL_TEXTENCODING_UTF8 ) );
+    if ( !xHandle.is() )
+    {
+        DBG_ERROR1( "Failed to fetch widget '%s'", pId );
+    }
+
+    if ( nId != 0 )
+    {
+        rtl::OString aStr = rtl::OString::valueOf( (sal_Int32) nId );
+        xHandle = GetPeerHandle( aStr, 0 );
+    }
+    return xHandle;
+}
+
+// Window/Dialog
+class DialogImpl : public WindowImpl
+{
+public:
+    uno::Reference< awt::XDialog2 > mxDialog;
+    DialogImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : WindowImpl( pCtx, xPeer, pWindow )
+        , mxDialog( xPeer, uno::UNO_QUERY )
+    {
+    }
+};
+
+// Accessors
+DECL_GET_IMPL_IMPL( Control )
+DECL_GET_IMPL_IMPL( Dialog )
+
+Window::Window( WindowImpl *pImpl )
+: mpImpl( pImpl )
+{
+}
+
+Window::~Window()
+{
+    /* likely to be an UNO object - with floating references */
+    mpImpl->wrapperGone();
+    mpImpl = NULL;
+}
+
+Context *Window::getContext()
+{
+    return this && mpImpl ? mpImpl->mpCtx : NULL;
+}
+
+PeerHandle Window::GetPeer()
+{
+    if (!mpImpl)
+        return PeerHandle();
+    return mpImpl->mxWindow;
+}
+
+struct ToolkitVclPropsMap
+{
+    WinBits vclStyle;
+    long initAttr;
+    const char *propName;
+
+    // the value to give the prop to enable/disable it -- not the most brilliant
+    // type declaration and storage, but does the work... properties are
+    // either a boolean or a short since they are either a directly wrappers for
+    // a WinBit, or aggregates related (like Align for WB_LEFT, _RIGHT and _CENTER).
+    bool isBoolean;
+    short enableProp, disableProp;
+};
+
+#define TYPE_BOOL  true
+#define TYPE_SHORT false
+#define NOTYPE     0
+static const ToolkitVclPropsMap toolkitVclPropsMap[] =
+{
+    { WB_BORDER,    awt::WindowAttribute::BORDER,    "Border", TYPE_SHORT, 1, 0 },
+    { WB_NOBORDER,    awt::VclWindowPeerAttribute::NOBORDER,    "Border", TYPE_SHORT, 0, 1 },
+    { WB_SIZEABLE,    awt::WindowAttribute::SIZEABLE,    NULL, NOTYPE, 0, 0 },
+    { WB_MOVEABLE,    awt::WindowAttribute::MOVEABLE,    NULL, NOTYPE, 0, 0 },
+    { WB_CLOSEABLE,    awt::WindowAttribute::CLOSEABLE,    NULL, NOTYPE, 0, 0 },
+
+    { WB_HSCROLL,    awt::VclWindowPeerAttribute::HSCROLL,    NULL, NOTYPE, 0, 0 },
+    { WB_VSCROLL,    awt::VclWindowPeerAttribute::VSCROLL,    NULL, NOTYPE, 0, 0 },
+    { WB_LEFT,    awt::VclWindowPeerAttribute::LEFT,    "Align", TYPE_SHORT, 0, 0 },
+    { WB_CENTER,    awt::VclWindowPeerAttribute::CENTER,    "Align", TYPE_SHORT, 1, 0 },
+    { WB_RIGHT,    awt::VclWindowPeerAttribute::RIGHT,    "Align", TYPE_SHORT, 2, 0 },
+    { WB_SPIN,    awt::VclWindowPeerAttribute::SPIN,    NULL, NOTYPE, 0, 0 },
+    { WB_SORT,    awt::VclWindowPeerAttribute::SORT,    NULL, NOTYPE, 0, 0 },
+    { WB_DROPDOWN,    awt::VclWindowPeerAttribute::DROPDOWN,    "Dropdown",    TYPE_BOOL, 1, 0 },
+    { WB_DEFBUTTON,    awt::VclWindowPeerAttribute::DEFBUTTON,    "DefaultButton", TYPE_BOOL, 1, 0 },
+    { WB_READONLY,    awt::VclWindowPeerAttribute::READONLY,    NULL, NOTYPE, 0, 0 },
+    { WB_CLIPCHILDREN,    awt::VclWindowPeerAttribute::CLIPCHILDREN,    NULL, NOTYPE, 0, 0 },
+    { WB_GROUP,    awt::VclWindowPeerAttribute::GROUP,    NULL, NOTYPE, 0, 0 },
+
+    { WB_OK,    awt::VclWindowPeerAttribute::OK,    NULL, NOTYPE, 0, 0 },
+    { WB_OK_CANCEL,    awt::VclWindowPeerAttribute::OK_CANCEL,    NULL, NOTYPE, 0, 0 },
+    { WB_YES_NO,    awt::VclWindowPeerAttribute::YES_NO,    NULL, NOTYPE, 0, 0 },
+    { WB_YES_NO_CANCEL,    awt::VclWindowPeerAttribute::YES_NO_CANCEL,    NULL, NOTYPE, 1, 0 },
+    { WB_RETRY_CANCEL,    awt::VclWindowPeerAttribute::RETRY_CANCEL,    NULL, NOTYPE, 1, 0 },
+    { WB_DEF_OK,    awt::VclWindowPeerAttribute::DEF_OK,    NULL, NOTYPE, 0, 0 },
+    { WB_DEF_CANCEL,    awt::VclWindowPeerAttribute::DEF_CANCEL,    NULL, NOTYPE, 1, 0 },
+    { WB_DEF_RETRY,    awt::VclWindowPeerAttribute::DEF_RETRY,    NULL, NOTYPE, 0, 0 },
+    { WB_DEF_YES,    awt::VclWindowPeerAttribute::DEF_YES,    NULL, NOTYPE, 0, 0 },
+    { WB_DEF_NO,    awt::VclWindowPeerAttribute::DEF_NO,    NULL, NOTYPE, 0, 0 },
+
+    { WB_AUTOHSCROLL, awt::VclWindowPeerAttribute::AUTOHSCROLL, "AutoHScroll", TYPE_BOOL, 1, 0 },
+    { WB_AUTOVSCROLL, awt::VclWindowPeerAttribute::AUTOVSCROLL, "AutoVScroll",    TYPE_BOOL, 1, 0 },
+
+    { WB_WORDBREAK,    0,    "MultiLine", TYPE_BOOL, 1, 0 },
+    { WB_NOPOINTERFOCUS,    0,    "FocusOnClick", TYPE_BOOL, 1, 0 },
+    { WB_TOGGLE,    0,    "Toggle", TYPE_BOOL, 1, 0 },
+    { WB_REPEAT,    0,    "Repeat", TYPE_BOOL, 1, 0 },
+    { WB_NOHIDESELECTION,    0,    "HideInactiveSelection", TYPE_BOOL, 1, 0 },
+};
+#undef TYPE_BOOL
+#undef TYPE_SHORT
+#undef NOTYPE
+
+static const int toolkitVclPropsMapLen =
+    sizeof( toolkitVclPropsMap ) / sizeof( ToolkitVclPropsMap );
+
+void Window::SetStyle( WinBits nStyle )
+{
+    uno::Reference< awt::XVclWindowPeer > xPeer = mpImpl->mxVclPeer;
+    for( int i = 0; i < toolkitVclPropsMapLen; i++ )
+    {
+        if ( toolkitVclPropsMap[ i ].propName )
+        {
+            short nValue;
+            if ( nStyle & toolkitVclPropsMap[ i ].vclStyle )
+                nValue = toolkitVclPropsMap[ i ].enableProp;
+            else
+                nValue = toolkitVclPropsMap[ i ].disableProp;
+            uno::Any aValue;
+            if ( toolkitVclPropsMap[ i ].isBoolean )
+                aValue = uno::makeAny( (bool) nValue );
+            else
+                aValue = uno::makeAny( (short) nValue );
+            mpImpl->setProperty( toolkitVclPropsMap[ i ].propName, aValue );
+        }
+    }
+}
+
+WinBits Window::GetStyle()
+{
+    uno::Reference< awt::XVclWindowPeer > xPeer = mpImpl->mxVclPeer;
+    WinBits ret = 0;
+    for( int i = 0; i < toolkitVclPropsMapLen; i++ )
+    {
+        if ( toolkitVclPropsMap[ i ].propName )
+        {
+            short nValue;
+            if ( toolkitVclPropsMap[ i ].isBoolean )
+            {
+                bool bValue;
+                mpImpl->getProperty( toolkitVclPropsMap[ i ].propName ) >>= bValue;
+                nValue = bValue ? 1 : 0;
+            }
+            else
+                mpImpl->getProperty( toolkitVclPropsMap[ i ].propName ) >>= nValue;
+            if ( nValue == toolkitVclPropsMap[ i ].enableProp )
+                ret |= toolkitVclPropsMap[i].vclStyle;
+        }
+    }
+    return ret;
+}
+
+/* Unpleasant way to get an xToolkit pointer ... */
+uno::Reference< awt::XToolkit > getToolkit()
+{
+    static uno::Reference< awt::XToolkit > xToolkit;
+    if (!xToolkit.is())
+    {
+        // Urgh ...
+        xToolkit = uno::Reference< awt::XToolkit >(
+            ::comphelper::getProcessServiceFactory()->createInstance(
+                rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.awt.Toolkit" ) ) ),
+            uno::UNO_QUERY );
+        if ( !xToolkit.is() )
+            throw uno::RuntimeException(
+                rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "failed to create toolkit!") ),
+                uno::Reference< uno::XInterface >() );
+    }
+    return xToolkit;
+}
+
+PeerHandle Window::CreatePeer( Window *pParent, WinBits nStyle, const char *pName)
+{
+
+    long nWinAttrbs = 0;
+    for( int i = 0; i < toolkitVclPropsMapLen; i++ )
+        if ( nStyle & toolkitVclPropsMap[ i ].vclStyle )
+            nWinAttrbs |= toolkitVclPropsMap[ i ].initAttr;
+
+    return layoutimpl::createWidget( getToolkit(), pParent->GetPeer(),
+                                     rtl::OUString::createFromAscii( pName ), nWinAttrbs );
+
+
+#if 0
+    awt::WindowDescriptor desc;
+
+    // debugging help ...
+    desc.Bounds.X = 0;
+    desc.Bounds.Y = 0;
+    desc.Bounds.Width = 300;
+    desc.Bounds.Height = 200;
+
+    desc.ParentIndex = 0;
+    // FIXME: this code should be shared with
+    // toolkit/source/awt/vclxtoolkit.cxx (ImplGetWinBits)
+    desc.WindowAttributes = 0;
+    for( int i = 0; i < toolkitVclPropsMapLen; i++ )
+        if ( nStyle & toolkitVclPropsMap[ i ].vclStyle )
+            desc.WindowAttributes |= toolkitVclPropsMap[ i ].initAttr;
+    desc.WindowServiceName = rtl::OUString( pName, strlen( pName ),
+                                            RTL_TEXTENCODING_ASCII_US );
+
+    // FIXME: we really want to walk up the peer hierarchy
+    // and get the top-level that this requires.
+    if ( pParent != NULL )
+    {
+        PeerHandle hdl = pParent->GetPeer();
+        desc.Parent = uno::Reference< awt::XWindowPeer >( hdl, uno::UNO_QUERY );
+    }
+
+    PeerHandle xPeer = getToolkit()->createWindow( desc );
+
+    // not all WinBits have an equivalent attribute, some are available through
+    // properties though
+    for( int i = 0; i < toolkitVclPropsMapLen; i++ )
+        if ( nStyle & toolkitVclPropsMap[ i ].vclStyle &&
+            !toolkitVclPropsMap[ i ].initAttr &&
+            toolkitVclPropsMap[ i ].propName )
+        {
+            uno::Any aValue;
+            if ( toolkitVclPropsMap[ i ].isBoolean )
+                aValue = uno::makeAny( (bool) toolkitVclPropsMap[ i ].enableProp );
+            else
+                aValue = uno::makeAny( (short) toolkitVclPropsMap[ i ].enableProp );
+            layoutimpl::prophlp::setProperty( xPeer,
+                                              rtl::OUString::createFromAscii( toolkitVclPropsMap[ i ].propName ), aValue );
+        }
+
+    return xPeer;
+#endif
+}
+
+void Window::Enable( bool bEnable )
+{
+    if ( !getImpl().mxWindow.is() )
+        return;
+    getImpl().mxWindow->setEnable( bEnable );
+}
+
+void Window::Show( BOOL bVisible )
+{
+    if ( !getImpl().mxWindow.is() )
+        return;
+    getImpl().mxWindow->setVisible( bVisible );
+}
+
+void Window::GrabFocus()
+{
+    if ( !getImpl().mxWindow.is() )
+        return;
+    getImpl().mxWindow->setFocus();
+}
+
+Dialog::Dialog( Window *pParent, const char *pXMLPath, const char *pId, sal_uInt32 nId )
+    : Context( pXMLPath )
+    , Window( new DialogImpl( this, Context::GetPeerHandle( pId, nId ), this ) )
+{
+    if ( pParent )
+        SetParent( pParent );
+}
+
+Dialog::Dialog( ::Window *pParent, const char *pXMLPath, const char *pId, sal_uInt32 nId )
+    : Context( pXMLPath )
+    , Window( new DialogImpl( this, Context::GetPeerHandle( pId, nId ), this ) )
+{
+    if ( pParent )
+        SetParent( pParent );
+}
+
+void Dialog::SetParent( ::Window *pParent )
+{
+    uno::Reference <awt::XWindow> ref( GetPeer(), uno::UNO_QUERY );
+    ::Window *window = VCLXWindow::GetImplementation( ref )->GetWindow();
+    window->SetParent( pParent );
+}
+
+void Dialog::SetParent( Window *pParent )
+{
+    uno::Reference <awt::XWindow> parentRef( pParent->GetPeer(), uno::UNO_QUERY );
+    ::Window *parentWindow = VCLXWindow::GetImplementation( parentRef )->GetWindow();
+    SetParent( parentWindow );
+}
+
+short Dialog::Execute()
+{
+    if ( !getImpl().mxDialog.is() )
+        return -1;
+    return getImpl().mxDialog->execute();
+}
+
+void Dialog::EndDialog( long nResult )
+{
+    if ( !getImpl().mxDialog.is() )
+        return;
+    getImpl().mxDialog->endDialog( nResult );
+}
+
+void Dialog::SetText( const String& rStr )
+{
+    if ( !getImpl().mxDialog.is() )
+        return;
+    getImpl().mxDialog->setTitle( rStr );
+}
+
+class FixedLineImpl : public ControlImpl
+{
+public:
+    FixedLineImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : ControlImpl( pCtx, xPeer, pWindow )
+    {
+    }
+};
+
+DECL_CONSTRUCTOR_IMPLS( FixedLine, Control, "hfixedline" );
+DECL_GET_IMPL_IMPL( FixedLine )
+
+class FixedTextImpl : public ControlImpl
+{
+public:
+    uno::Reference< awt::XFixedText > mxFixedText;
+    FixedTextImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : ControlImpl( pCtx, xPeer, pWindow )
+        , mxFixedText( xPeer, uno::UNO_QUERY )
+    {
+    }
+
+    virtual void SAL_CALL disposing( const css::lang::EventObject& /* Source */ )
+        throw (css::uno::RuntimeException)
+    {
+        mxFixedText.clear();
+    }
+};
+
+DECL_CONSTRUCTOR_IMPLS( FixedText, Control, "fixedtext" );
+DECL_GET_IMPL_IMPL( FixedText )
+
+void FixedText::SetText( const String& rStr )
+{
+    if ( !getImpl().mxFixedText.is() )
+        return;
+    getImpl().mxFixedText->setText( rStr );
+}
+
+class FixedInfoImpl : public FixedTextImpl
+{
+public:
+    FixedInfoImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : FixedTextImpl( pCtx, xPeer, pWindow )
+    {
+    }
+};
+
+DECL_CONSTRUCTOR_IMPLS( FixedInfo, FixedText, "fixedinfo" );
+DECL_GET_IMPL_IMPL( FixedInfo )
+
+}; // end namespace layout
diff --git a/layout/source/wrapper/wrapper.hxx b/layout/source/wrapper/wrapper.hxx
new file mode 100644
index 0000000..87c5a86
--- /dev/null
+++ layout/source/wrapper/wrapper.hxx
@@ -0,0 +1,115 @@
+#ifndef WRAPPER_HXX
+#define WRAPPER_HXX
+
+#include <layout/layout.hxx>
+#include <com/sun/star/uno/Reference.hxx>
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/awt/XVclWindowPeer.hpp>
+#include <com/sun/star/graphic/XGraphic.hpp>
+
+#include <cstring>
+
+namespace css = com::sun::star;
+
+namespace layout
+{
+// Window
+class WindowImpl
+{
+  public:
+    Window  *mpWindow;
+    Context *mpCtx;
+    css::uno::Reference< css::awt::XWindow >        mxWindow;
+    css::uno::Reference< css::awt::XVclWindowPeer > mxVclPeer;
+
+    WindowImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : mpWindow ( pWindow )
+        , mpCtx ( pCtx )
+        , mxWindow ( xPeer, css::uno::UNO_QUERY )
+        , mxVclPeer( xPeer, css::uno::UNO_QUERY )
+    {
+    }
+
+    virtual ~WindowImpl()
+    {
+    }
+
+    void wrapperGone()
+    {
+        mpWindow = NULL;
+        mpCtx = NULL;
+        if ( mxWindow.is() )
+        {
+            css::uno::Reference< css::lang::XComponent > xComp( mxWindow, css::uno::UNO_QUERY );
+            mxWindow.clear();
+            if ( xComp.is() )
+                xComp->dispose();
+        }
+    }
+
+    css::uno::Any getProperty( const char *pName )
+    {
+        if ( !this || !mxVclPeer.is() )
+            return css::uno::Any();
+        return mxVclPeer->getProperty
+            ( rtl::OUString( pName, strlen( pName ), RTL_TEXTENCODING_ASCII_US ) );
+    }
+    void setProperty( const char *pName, css::uno::Any aAny )
+    {
+        if ( !this || !mxVclPeer.is() )
+            return;
+        mxVclPeer->setProperty
+            ( rtl::OUString( pName, strlen( pName ), RTL_TEXTENCODING_ASCII_US ), aAny );
+    }
+};
+
+// Window/Control
+class ControlImpl : public WindowImpl
+{
+  public:
+    ControlImpl( Context *pCtx, const PeerHandle &xPeer, Window *pWindow )
+        : WindowImpl( pCtx, xPeer, pWindow ) {}
+};
+
+class ImageImpl
+{
+  public:
+    css::uno::Reference< css::graphic::XGraphic > mxGraphic;
+    ImageImpl( const char *pName );
+};
+
+// Window/Control/Edit
+inline WindowImpl &Window::getImpl() const
+{ return *(static_cast< WindowImpl * >( mpImpl )); }
+
+// Helpers for defining boiler-plate constructors ...
+// Could in-line in top-level but not with safe static_casts.
+#define DECL_GET_IMPL_IMPL(t) \
+    inline t##Impl &t::getImpl() const \
+    { \
+        return *(static_cast<t##Impl *>(mpImpl)); \
+    }
+#define DECL_CONSTRUCTOR_IMPLS(t,par,unoName) \
+    t::t( Context *pCtx, const char *pId, sal_uInt32 nId ) \
+        : par( new t##Impl( pCtx, pCtx->GetPeerHandle( pId, nId ), this ) ) \
+    { \
+    } \
+    t::t( Window *pParent, WinBits nBits) \
+        : par( new t##Impl( pParent->getContext(), Window::CreatePeer( pParent, nBits, unoName ), this ) ) \
+    { \
+    }
+#define DECL_CONSTRUCTOR_IMPLS_2(t,win_par,other_par,unoName) \
+    t::t( Context *pCtx, const char *pId, sal_uInt32 nId ) \
+        : win_par( new t##Impl( pCtx, pCtx->GetPeerHandle( pId, nId ), this ) ) \
+        , other_par( new other_par##Impl( Window::GetPeer() ) ) \
+    { \
+    } \
+    t::t( Window *pParent, WinBits nBits) \
+        : win_par( new t##Impl( pParent->getContext(), Window::CreatePeer( pParent, nBits, unoName ), this ) ) \
+        , other_par( new other_par##Impl( Window::GetPeer() ) ) \
+    { \
+    }
+
+}; // end namespace layout
+
+#endif // WRAPPER_HXX
diff --git a/layout/src2xml/README b/layout/src2xml/README
new file mode 100644
index 0000000..ef30040
--- /dev/null
+++ layout/src2xml/README
@@ -0,0 +1,16 @@
+SRC2XML: Convert OO.o resource to Layout XML.
+
+This directory contains a Python script to convert OO.o's existing dialog
+resource files into XML layout files.
+
+The main executable file is located in ./source/src2xml.py.  Run
+
+   source/src2xml.py --help
+
+for more information.
+
+See also: source/dryrunall.sh and ../workben/run-s2x
+
+
+Author: Kohei Yoshida  <kyoshida@novell.com>
+Modifications: Jan Nieuwenhuizen  <jnieuwenhuizen@novell.com>
diff --git a/layout/src2xml/dryrunall.sh b/layout/src2xml/dryrunall.sh
new file mode 100755
index 0000000..a2bd803
--- /dev/null
+++ layout/src2xml/dryrunall.sh
@@ -0,0 +1,2 @@
+#! /bin/bash
+source/src2xml.py --dry-run --includes-from=include.lst $(cat src.lst) "$@"
diff --git a/layout/src2xml/include-sc.lst b/layout/src2xml/include-sc.lst
new file mode 100644
index 0000000..7b821a2
--- /dev/null
+++ layout/src2xml/include-sc.lst
@@ -0,0 +1,8 @@
+../../solver/680/unxlngi6.pro/inc
+../../sc
+../../sc/inc
+../../sc/addin/inc
+../../sc/source/ui/inc
+../../sc/source/core/inc
+../../sc/source/filter/inc
+../../sc/unxlngi6.pro/inc
diff --git a/layout/src2xml/include-sd.lst b/layout/src2xml/include-sd.lst
new file mode 100644
index 0000000..44b1f66
--- /dev/null
+++ layout/src2xml/include-sd.lst
@@ -0,0 +1,6 @@
+../../solver/680/unxlngi6.pro/inc
+../../sd
+../../sd/inc
+../../sd/source/ui/inc
+../../sd/source/ui/slidesorter/inc
+../../sd/unxlngi6.pro/inc
diff --git a/layout/src2xml/include-sw.lst b/layout/src2xml/include-sw.lst
new file mode 100644
index 0000000..44fa895
--- /dev/null
+++ layout/src2xml/include-sw.lst
@@ -0,0 +1,5 @@
+../../solver/680/unxlngi6.pro/inc
+../../sw/source/ui/inc
+../../sw/source/core/inc
+../../sw/source/filter/inc
+../../sw/unxlngi6.pro/inc
diff --git a/layout/src2xml/include.lst b/layout/src2xml/include.lst
new file mode 100644
index 0000000..2798191
--- /dev/null
+++ layout/src2xml/include.lst
@@ -0,0 +1,305 @@
+../../solver/680/unxlngi6.pro/inc
+../../io/inc
+../../io/unxlngi6.pro/inc
+../../sc/inc
+../../sc/addin/inc
+../../sc/source/ui/inc
+../../sc/source/core/inc
+../../sc/source/filter/inc
+../../sc/unxlngi6.pro/inc
+../../sd/inc
+../../sd/source/ui/inc
+../../sd/source/ui/slidesorter/inc
+../../sd/unxlngi6.pro/inc
+../../sw/inc
+../../sw/source/ui/inc
+../../sw/source/core/inc
+../../sw/source/filter/inc
+../../sw/unxlngi6.pro/inc
+../../xt/unxlngi6.pro/inc
+../../agg/inc
+../../icu/unxlngi6.pro/inc
+../../idl/inc
+../../idl/unxlngi6.pro/inc
+../../jut/unxlngi6.pro/inc
+../../nas/unxlngi6.pro/inc
+../../odk/inc
+../../sal/qa/inc
+../../sal/inc
+../../sal/unxlngi6.pro/inc
+../../sax/unxlngi6.pro/inc
+../../sch/inc
+../../sch/source/ui/inc
+../../sch/unxlngi6.pro/inc
+../../sj2/inc
+../../sj2/source/inc
+../../sj2/unxlngi6.pro/inc
+../../rsc/inc
+../../rsc/unxlngi6.pro/inc
+../../so3/inc
+../../so3/unxlngi6.pro/inc
+../../sot/inc
+../../sot/unxlngi6.pro/inc
+../../svx/inc
+../../svx/source/inc
+../../svx/source/unodialogs/inc
+../../svx/unxlngi6.pro/inc
+../../ucb/inc
+../../ucb/source/inc
+../../ucb/unxlngi6.pro/inc
+../../udm/inc
+../../udm/source/inc
+../../vcl/inc
+../../vcl/unx/inc
+../../vcl/unx/source/inc
+../../vcl/win/inc
+../../vcl/aqua/inc
+../../vcl/unxlngi6.pro/inc
+../../ure/unxlngi6.pro/inc
+../../uui/unxlngi6.pro/inc
+../../vos/inc
+../../vos/unxlngi6.pro/inc
+../../dbaccess/inc
+../../dbaccess/source/ui/inc
+../../dbaccess/source/inc
+../../dbaccess/source/core/inc
+../../dbaccess/source/sdbtools/inc
+../../dbaccess/unxlngi6.pro/inc
+../../transex3/inc
+../../transex3/unxlngi6.pro/inc
+../../bean/unxlngi6.pro/inc
+../../cosv/inc
+../../cosv/source/inc
+../../cppu/inc
+../../cppu/unxlngi6.pro/inc
+../../idlc/inc
+../../idlc/unxlngi6.pro/inc
+../../o3tl/inc
+../../o3tl/unxlngi6.pro/inc
+../../jurt/unxlngi6.pro/inc
+../../sane/inc
+../../scp2/inc
+../../scp2/unxlngi6.pro/inc
+../../sfx2/inc
+../../sfx2/source/inc
+../../sfx2/unxlngi6.pro/inc
+../../stoc/inc
+../../stoc/unxlngi6.pro/inc
+../../framework/inc
+../../framework/source/inc
+../../framework/unxlngi6.pro/inc
+../../desktop/inc
+../../desktop/source/inc
+../../desktop/source/deployment/inc
+../../desktop/source/deployment/registry/inc
+../../desktop/unxlngi6.pro/inc
+../../external/unxlngi6.pro/inc
+../../xml2cmp/source/inc
+../../xml2cmp/unxlngi6.pro/inc
+../../xmlhelp/inc
+../../xmlhelp/unxlngi6.pro/inc
+../../soltools/inc
+../../soltools/testSHL/inc
+../../soltools/unxlngi6.pro/inc
+../../unixODBC/inc
+../../basic/inc
+../../basic/source/inc
+../../basic/unxlngi6.pro/inc
+../../boost/unxlngi6.pro/inc
+../../XmlSearch/unxlngi6.pro/inc
+../../fondu/unxlngi6.pro/inc
+../../forms/inc
+../../forms/source/inc
+../../forms/source/solar/inc
+../../forms/unxlngi6.pro/inc
+../../ridljar/unxlngi6.pro/inc
+../../offuh/unxlngi6.pro/inc
+../../pyuno/inc
+../../pyuno/unxlngi6.pro/inc
+../../shell/inc
+../../shell/unxlngi6.pro/inc
+../../store/inc
+../../store/unxlngi6.pro/inc
+../../sysui/unxlngi6.pro/inc
+../../tools/inc
+../../tools/win/inc
+../../tools/unxlngi6.pro/inc
+../../twain/inc
+../../unoil/unxlngi6.pro/inc
+../../cppcanvas/inc
+../../cppcanvas/source/inc
+../../cppcanvas/unxlngi6.pro/inc
+../../sandbox/unxlngi6.pro/inc
+../../eventattacher/unxlngi6.pro/inc
+../../unotools/inc
+../../unotools/unxlngi6.pro/inc
+../../scaddins/unxlngi6.pro/inc
+../../javaunohelper/inc
+../../javaunohelper/unxlngi6.pro/inc
+../../configmgr/inc
+../../configmgr/source/inc
+../../configmgr/unxlngi6.pro/inc
+../../hwpfilter/inc
+../../hwpfilter/unxlngi6.pro/inc
+../../libxmlsec/unxlngi6.pro/inc
+../../jvmaccess/inc
+../../jvmaccess/unxlngi6.pro/inc
+../../comphelper/inc
+../../comphelper/unxlngi6.pro/inc
+../../helpcontent2/unxlngi6.pro/inc
+../../animations/inc
+../../animations/unxlngi6.pro/inc
+../../fileaccess/unxlngi6.pro/inc
+../../i18npool/inc
+../../i18npool/unxlngi6.pro/inc
+../../i18nutil/inc
+../../i18nutil/unxlngi6.pro/inc
+../../accessibility/inc
+../../accessibility/unxlngi6.pro/inc
+../../testshl2/inc
+../../testshl2/source/inc
+../../testshl2/unxlngi6.pro/inc
+../../lpsolve/unxlngi6.pro/inc
+../../setup_native/inc
+../../setup_native/unxlngi6.pro/inc
+../../embedserv/source/inc
+../../psprint_config/unxlngi6.pro/inc
+../../basctl/inc
+../../basctl/source/inc
+../../basctl/unxlngi6.pro/inc
+../../cpputools/unxlngi6.pro/inc
+../../stlport/unxlngi6.pro/inc
+../../canvas/inc
+../../canvas/unxlngi6.pro/inc
+../../embeddedobj/inc
+../../embeddedobj/source/inc
+../../embeddedobj/unxlngi6.pro/inc
+../../chart2/inc
+../../chart2/source/inc
+../../chart2/source/view/inc
+../../chart2/source/model/inc
+../../chart2/source/controller/inc
+../../chart2/unxlngi6.pro/inc
+../../scsolver/source/inc
+../../scsolver/unxlngi6.pro/inc
+../../automation/inc
+../../automation/source/inc
+../../automation/unxlngi6.pro/inc
+../../portaudio/unxlngi6.pro/inc
+../../svtools/inc
+../../svtools/unx/inc
+../../svtools/source/inc
+../../svtools/unxlngi6.pro/inc
+../../dtrans/inc
+../../dtrans/source/inc
+../../dtrans/unxlngi6.pro/inc
+../../x11_extensions/inc
+../../fpicker/inc
+../../fpicker/unxlngi6.pro/inc
+../../filter/inc
+../../filter/unxlngi6.pro/inc
+../../extras/unxlngi6.pro/inc
+../../writerperfect/unxlngi6.pro/inc
+../../toolkit/inc
+../../toolkit/unxlngi6.pro/inc
+../../officecfg/unxlngi6.pro/inc
+../../unodevtools/inc
+../../unodevtools/unxlngi6.pro/inc
+../../cppuhelper/inc
+../../cppuhelper/unxlngi6.pro/inc
+../../jvmfwk/inc
+../../jvmfwk/unxlngi6.pro/inc
+../../layout/inc
+../../layout/unxlngi6.pro/inc
+../../linguistic/inc
+../../linguistic/unxlngi6.pro/inc
+../../libegg/inc
+../../libegg/unxlngi6.pro/inc
+../../libwpd/unxlngi6.pro/inc
+../../libwpg/unxlngi6.pro/inc
+../../libwps/unxlngi6.pro/inc
+../../lingucomponent/inc
+../../lingucomponent/unxlngi6.pro/inc
+../../np_sdk/unxlngi6.pro/inc
+../../offapi/unxlngi6.pro/inc
+../../xmlsecurity/inc
+../../xmlsecurity/unxlngi6.pro/inc
+../../padmin/unxlngi6.pro/inc
+../../goodies/inc
+../../goodies/unxlngi6.pro/inc
+../../regexp/inc
+../../regexp/unxlngi6.pro/inc
+../../ucbhelper/inc
+../../ucbhelper/unxlngi6.pro/inc
+../../berkeleydb/unxlngi6.pro/inc
+../../UnoControls/inc
+../../UnoControls/source/inc
+../../UnoControls/unxlngi6.pro/inc
+../../msfontextract/unxlngi6.pro/inc
+../../solenv/inc
+../../solenv/unxmacxp/inc
+../../solver/680/unxlngi6.pro/inc
+../../postprocess/unxlngi6.pro/inc
+../../udkapi/unxlngi6.pro/inc
+../../unoxml/unxlngi6.pro/inc
+../../starmath/inc
+../../starmath/unxlngi6.pro/inc
+../../mdbtools/unxlngi6.pro/inc
+../../basebmp/inc
+../../basegfx/inc
+../../basegfx/source/inc
+../../basegfx/unxlngi6.pro/inc
+../../xmerge/inc
+../../xmerge/source/inc
+../../xmerge/unxlngi6.pro/inc
+../../xmloff/inc
+../../xmloff/unxlngi6.pro/inc
+../../oovbaapi/unxlngi6.pro/inc
+../../package/inc
+../../package/unxlngi6.pro/inc
+../../extensions/inc
+../../extensions/source/inc
+../../extensions/source/plugin/inc
+../../extensions/unxlngi6.pro/inc
+../../codemaker/inc
+../../codemaker/unxlngi6.pro/inc
+../../salhelper/inc
+../../salhelper/unxlngi6.pro/inc
+../../rdbmaker/inc
+../../rdbmaker/unxlngi6.pro/inc
+../../instsetoo_native/unxlngi6.pro/inc
+../../autodoc/inc
+../../autodoc/source/ary/inc
+../../autodoc/source/inc
+../../autodoc/source/display/inc
+../../autodoc/source/parser_i/inc
+../../autodoc/source/parser/inc
+../../avmedia/inc
+../../avmedia/source/inc
+../../avmedia/unxlngi6.pro/inc
+../../lotuswordpro/unxlngi6.pro/inc
+../../remotebridges/unxlngi6.pro/inc
+../../slideshow/inc
+../../slideshow/source/inc
+../../slideshow/unxlngi6.pro/inc
+../../connectivity/inc
+../../connectivity/source/inc
+../../connectivity/unxlngi6.pro/inc
+../../readlicense_oo/unxlngi6.pro/inc
+../../scripting/inc
+../../scripting/source/inc
+../../scripting/unxlngi6.pro/inc
+../../wizards/unxlngi6.pro/inc
+../../xmlscript/inc
+../../xmlscript/source/inc
+../../xmlscript/unxlngi6.pro/inc
+../../bridges/inc
+../../bridges/unxlngi6.pro/inc
+../../testtools/inc
+../../testtools/unxlngi6.pro/inc
+../../registry/inc
+../../registry/unxlngi6.pro/inc
+../../cli_ure/inc
+../../cli_ure/unxlngi6.pro/inc
+../../psprint/inc
+../../psprint/unxlngi6.pro/inc
\ No newline at end of file
diff --git a/layout/src2xml/sc.sh b/layout/src2xml/sc.sh
new file mode 100755
index 0000000..1bfb213
--- /dev/null
+++ layout/src2xml/sc.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+source/src2xml.py --include-path=$(tr '\n' ':' < include-sc.lst) --dry-run $(cat src-sc.lst) "$@"
diff --git a/layout/src2xml/sd.sh b/layout/src2xml/sd.sh
new file mode 100755
index 0000000..78b4720
--- /dev/null
+++ layout/src2xml/sd.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+
+source/src2xml.py --include-path=$(tr '\n' ':' < include-sd.lst) --dry-run $(cat src-sd.lst) "$@"
diff --git a/layout/src2xml/source/boxer.py b/layout/src2xml/source/boxer.py
new file mode 100644
index 0000000..c697ec8
--- /dev/null
+++ layout/src2xml/source/boxer.py
@@ -0,0 +1,71 @@
+
+from globals import *
+
+
+class DlgLayoutBuilder(object):
+    def __init__ (self, dlgnode):
+        self.dlgnode = dlgnode
+        self.rows = {}
+
+    def addWidget (self, elem):
+        x, y = int(elem.getAttr('x')), int(elem.getAttr('y'))
+        if self.rows.has_key(y):
+            self.rows[y][x] = elem
+        else:
+            self.rows[y] = {}
+            self.rows[y][x] = elem
+
+    def build (self):
+        root = Element('vbox')
+        ys = self.rows.keys()
+        ys.sort()
+        for y in ys:
+            xs = self.rows[y].keys()
+            xs.sort()
+
+            if len(xs) == 1:
+                root.appendChild(self.rows[y][xs[0]])
+                continue
+
+            hbox = Element('hbox')
+            root.appendChild(hbox)
+            for x in xs:
+                elem = self.rows[y][x]
+                hbox.appendChild(elem)
+
+        return root
+
+
+class Boxer(object):
+    def __init__ (self, root):
+        self.root = root
+
+    def layout (self):
+
+        newroot = RootNode()
+        for dlgnode in self.root.children:
+            newdlgnode = self.__walkDlgNode(dlgnode)
+            newroot.children.append(newdlgnode)
+
+        return newroot
+
+    def __walkDlgNode (self, dlgnode):
+
+        newnode = Element(dlgnode.name)
+        newnode.clone(dlgnode)
+        newnode.setAttr("xmlns", "http://openoffice.org/2007/layout")
+        newnode.setAttr("xmlns:cnt", "http://openoffice.org/2007/layout/container")
+        mx = DlgLayoutBuilder(newnode)
+
+        # Each dialog node is expected to have a flat list of widgets.
+        for widget in dlgnode.children:
+            if widget.hasAttr('x') and widget.hasAttr('y'):
+                mx.addWidget(widget)
+            else:
+                newnode.appendChild(widget)
+
+        vbox = mx.build()
+        if len(vbox.children) > 0:
+            newnode.appendChild(vbox)
+
+        return newnode
diff --git a/layout/src2xml/source/expression.py b/layout/src2xml/source/expression.py
new file mode 100644
index 0000000..b5f58c4
--- /dev/null
+++ layout/src2xml/source/expression.py
@@ -0,0 +1,111 @@
+
+import sys
+import globals
+
+def toString (node):
+
+    if node == None:
+        return ''
+
+    chars = '('
+
+    if type(node.left) == type(0):
+        chars += "%d"%node.left
+    else:
+        chars += toString(node.left)
+
+    chars += node.op
+
+    if type(node.right) == type(0):
+        chars += "%d"%node.right
+    else:
+        chars += toString(node.right)
+
+    chars += ")"
+
+    return chars
+
+class Node(object):
+    def __init__ (self):
+        self.left = None
+        self.right = None
+        self.parent = None
+        self.op = None
+
+class ExpParser(object):
+
+    def __init__ (self, tokens):
+        self.tokens = tokens
+
+    def jumpToRoot (self):
+        while self.ptr.parent != None:
+            self.ptr = self.ptr.parent
+
+    def build (self):
+        self.ptr = Node()
+
+        for token in self.tokens:
+
+            if token in '+-':
+                if self.ptr.left == None:
+                    raise globals.ParseError ('')
+                if self.ptr.right == None:
+                    self.ptr.op = token
+                else:
+                    self.jumpToRoot()
+                    self.ptr.parent = Node()
+                    self.ptr.parent.left = self.ptr
+                    self.ptr = self.ptr.parent
+                    self.ptr.op = token
+
+            elif token in '*/':
+                if self.ptr.left == None:
+                    raise globals.ParseError ('')
+                elif self.ptr.right == None:
+                    self.ptr.op = token
+                else:
+                    num = self.ptr.right
+                    self.ptr.right = Node()
+                    self.ptr.right.parent = self.ptr
+                    self.ptr.right.left = num
+                    self.ptr.right.op = token
+                    self.ptr = self.ptr.right
+
+            elif token == '(':
+                if self.ptr.left == None:
+                    self.ptr.left = Node()
+                    self.ptr.left.parent = self.ptr
+                    self.ptr = self.ptr.left
+                elif self.ptr.right == None:
+                    self.ptr.right = Node()
+                    self.ptr.right.parent = self.ptr
+                    self.ptr = self.ptr.right
+                else:
+                    raise globals.ParseError ('')
+
+            elif token == ')':
+                if self.ptr.left == None:
+                    raise globals.ParseError ('')
+                elif self.ptr.right == None:
+                    raise globals.ParseError ('')
+                elif self.ptr.parent == None:
+                    pass
+                else:
+                    self.ptr = self.ptr.parent
+
+            else:
+                num = int(token)
+                if self.ptr.left == None:
+                    self.ptr.left = num
+                elif self.ptr.right == None:
+                    self.ptr.right = num
+                else:
+                    raise globals.ParseError ('')
+
+    def dumpTree (self):
+        self.jumpToRoot()
+        print toString(self.ptr)
+
+
+
+
diff --git a/layout/src2xml/source/expression_test.py b/layout/src2xml/source/expression_test.py
new file mode 100755
index 0000000..7e7393f
--- /dev/null
+++ layout/src2xml/source/expression_test.py
@@ -0,0 +1,23 @@
+#!/usr/bin/env python
+
+import sys
+import expression
+
+def run (exp):
+    tokens = exp.split()
+    expparser = expression.ExpParser(tokens)
+    expparser.build()
+    expparser.dumpTree()
+
+def main ():
+    run("6 + 34")
+    run("6 + 34 - 10")
+    run("6 + 34 - 10 + 200")
+    run("6 + 34 - 10 * 200")
+    run("6 + 34 - 10 * 200 + 18")
+    run("6 + 34 - 10 * 200 + 18 / 2")
+
+    run("6 * ( ( 10 + 2 ) - 10 ) * 33")
+
+if __name__ == '__main__':
+    main()
diff --git a/layout/src2xml/source/globals.py b/layout/src2xml/source/globals.py
new file mode 100644
index 0000000..5e170b8
--- /dev/null
+++ layout/src2xml/source/globals.py
@@ -0,0 +1,115 @@
+import sys
+
+class ParseError (Exception): 
+    pass
+
+def error (msg, exit=0):
+    sys.stderr.write (msg)
+    if exit:
+        sys.exit (exit)
+
+def progress (msg):
+    sys.stderr.write(msg)
+
+
+def removeQuote (text):
+    """Remove quotes from a literal.
+"""
+    if len(text) >= 2 and text[0] == text[len(text)-1] == '"':
+        text = text[1:-1]
+    return text
+
+
+class Macro(object):
+    def __init__ (self, name):
+        self.name = name
+        self.tokens = []
+        self.vars = {}
+
+
+class Node(object):
+    def __init__ (self):
+        self.children = []
+
+    def appendChild (self, childnode):
+        self.children.append(childnode)
+        childnode.parent = self
+
+    def getChildren (self):
+        return self.children
+
+
+class RootNode(Node):
+    def __init__ (self):
+        Node.__init__(self)
+
+    def dump (self):
+        chars = ''
+        for child in self.getChildren():
+            chars += child.dump()
+        return chars
+
+
+class Element(Node):
+
+    INDENT = "    "
+
+    def __init__ (self, name, rid = None):
+        Node.__init__(self)
+        self.name = name
+        self.parent = None
+#        print "name: " + self.name - stats ...
+
+        # The following attributes are copied when 'clone'ed.
+        self.rid = rid
+        self.attrs = {}
+
+    def dump (self, level = 0):
+        chars = ''
+        chars += "\n" + Element.INDENT*level
+        chars += '<%s'%self.name
+
+        if self.rid != None:
+            self.setAttr("rid", self.rid)
+
+        chars += self.__dumpAttrs()
+
+        if len(self.children) == 0:
+            chars += '/>'
+        else:
+            chars += '>'
+            for child in self.getChildren():
+                chars += child.dump(level+1)
+    
+            chars += "\n"+Element.INDENT*level
+            chars += "</%s>"%self.name
+
+        return chars
+
+    def hasAttr (self, name):
+        return self.attrs.has_key(name)
+
+    def getAttr (self, name):
+        return self.attrs[name]
+
+    def setAttr (self, name, value):
+        if type(value) == type(0):
+            value = "%d"%value
+        self.attrs[name] = removeQuote(value)
+#        print "attr: " + self.name + "." + name - stats ...
+        return
+
+    def clone (self, elem):
+        keys = elem.attrs.keys()
+        for key in keys:
+            self.attrs[key] = elem.attrs[key]
+        self.rid = elem.rid
+
+    def __dumpAttrs (self):
+        text = ''
+        keys = self.attrs.keys()
+        keys.sort()
+        for key in keys:
+            value = self.attrs[key]
+            text += ' %s="%s"'%(key, value)
+        return text
diff --git a/layout/src2xml/source/macroexpander_test.py b/layout/src2xml/source/macroexpander_test.py
new file mode 100755
index 0000000..823bcdb
--- /dev/null
+++ layout/src2xml/source/macroexpander_test.py
@@ -0,0 +1,71 @@
+#!/usr/bin/env python
+
+import srclexer, srcparser, globals
+
+class TestCase:
+
+    @staticmethod
+    def run (tokens, defines):
+        mcExpander = srcparser.MacroExpander(tokens, defines)
+        mcExpander.debug = True
+        mcExpander.expand()
+        tokens = mcExpander.getTokens()
+        print tokens
+
+    @staticmethod
+    def simpleNoArgs ():
+        tokens = ['FUNC_FOO', '(', 'left', ',', 'right', ')']
+        defines = {}
+        macro = globals.Macro('FUNC_FOO')
+        macro.tokens = ['Here', 'comes', 'X', 'and', 'Y']
+        defines['FUNC_FOO'] = macro
+        TestCase.run(tokens, defines)
+
+    @staticmethod
+    def simpleArgs ():
+        tokens = ['FUNC_FOO', '(', 'left', ',', 'right', ')']
+        defines = {}
+        macro = globals.Macro('FUNC_FOO')
+        macro.tokens = ['Here', 'comes', 'X', 'and', 'Y']
+        macro.vars['X'] = 0
+        macro.vars['Y'] = 1
+        defines['FUNC_FOO'] = macro
+        TestCase.run(tokens, defines)
+
+    @staticmethod
+    def multiTokenArgs ():
+        tokens = ['FUNC_FOO', '(', 'left1', 'left2', 'left3', ',', 'right', ')']
+        defines = {}
+        macro = globals.Macro('FUNC_FOO')
+        macro.tokens = ['Here', 'comes', 'X', 'and', 'Y']
+        macro.vars['X'] = 0
+        macro.vars['Y'] = 1
+        defines['FUNC_FOO'] = macro
+        TestCase.run(tokens, defines)
+
+    @staticmethod
+    def nestedTokenArgs ():
+        tokens = ['FUNC_BAA', '(', 'left', ',', 'right', ')']
+        defines = {}
+        macro = globals.Macro('FUNC_FOO')
+        macro.tokens = ['Here', 'comes', 'X', 'and', 'Y']
+        macro.vars['X'] = 0
+        macro.vars['Y'] = 1
+        defines['FUNC_FOO'] = macro
+        macro = globals.Macro('FUNC_BAA')
+        macro.tokens = ['FUNC_FOO']
+        defines['FUNC_BAA'] = macro
+        TestCase.run(tokens, defines)
+
+def main ():
+    print "simple expansion with no arguments"
+    TestCase.simpleNoArgs()
+    print "simple argument expansion"
+    TestCase.simpleArgs()
+    print "multi-token argument expansion"
+    TestCase.multiTokenArgs()
+    print "nested argument expansion"
+    TestCase.nestedTokenArgs()
+
+if __name__ ==  '__main__':
+    main()
diff --git a/layout/src2xml/source/macroparser.py b/layout/src2xml/source/macroparser.py
new file mode 100644
index 0000000..1a221b4
--- /dev/null
+++ layout/src2xml/source/macroparser.py
@@ -0,0 +1,130 @@
+
+import sys
+from globals import *
+import srclexer
+
+class MacroParser(object):
+
+    def __init__ (self, buf):
+        self.buffer = buf
+        self.macro = None
+        self.debug = False
+
+    def parse (self):
+        """
+A macro with arguments must have its open paren immediately following 
+its name without any whitespace.
+"""
+        if self.debug:
+            print "-"*68
+            print "parsing '%s'"%self.buffer
+
+        i = 0
+        bufSize = len(self.buffer)
+        name, buf = '', ''
+        while i < bufSize:
+            c = self.buffer[i]
+            if c in [' ', "\t"] and len(name) == 0:
+                # This is a simple macro with no arguments.
+                name = buf
+                vars = []
+                content = self.buffer[i:]
+                self.setMacro(name, vars, content)
+                return
+            elif c == '(' and len(name) == 0:
+                # This one has arguments.
+                name = buf
+                buf = self.buffer[i:]
+                vars, content = self.parseArgs(buf)
+                self.setMacro(name, vars, content)
+                return
+            else:
+                buf += c
+                i += 1
+
+    def parseArgs (self, buffer):
+        """Parse arguments.
+
+The buffer is expected to be formatted like '(a, b, c)' where the first 
+character is the open paren.
+"""
+        scope = 0
+        buf = ''
+        vars = []
+        content = ''
+        bufSize = len(buffer)
+        i = 0
+        while i < bufSize:
+            c = buffer[i]
+            if c == '(':
+                scope += 1
+            elif c == ')':
+                scope -= 1
+                if len(buf) > 0:
+                    vars.append(buf)
+                if scope == 0:
+                    break
+            elif c == ',':
+                if len(buf) == 0:
+                    raise globals.ParseError ('')
+                vars.append(buf)
+                buf = ''
+            elif c in " \t" and scope > 0:
+                pass
+            else:
+                buf += c
+
+            i += 1
+
+        if scope > 0:
+            raise globals.ParseError ('')
+
+        return vars, buffer[i+1:]
+
+
+    def setMacro (self, name, vars, content):
+        if self.debug:
+            print "-"*68
+            print "name: %s"%name
+            for var in vars:
+                print "var: %s"%var
+            if len(vars) == 0:
+                print "no vars"
+            print "content: '%s'"%content
+
+        if len(content) > 0:
+            self.macro = Macro(name)
+            for i in xrange(0, len(vars)):
+                self.macro.vars[vars[i]] = i
+
+            # tokinize it using lexer.
+            mclexer = srclexer.SrcLexer(content)
+            mclexer.expandHeaders = False
+            mclexer.inMacroDefine = True
+            mclexer.tokenize()
+            self.macro.tokens = mclexer.getTokens()
+            if self.debug:
+                print self.macro.tokens
+            
+            if not self.isValidMacro(self.macro):
+                self.macro = None
+
+        if self.debug:
+            if self.macro != None:
+                print "macro registered!"
+            else:
+                print "macro not registered"
+
+    def isValidMacro (self, macro):
+
+        n = len(macro.tokens)
+        if n == 0:
+            return False
+        elif len(macro.name) > 4 and macro.name[1:4] == 'ID_':
+            # We don't want to expand macros like HID_, SID_, WID_, etc.
+            return False
+        return True
+
+
+    def getMacro (self):
+        return self.macro
diff --git a/layout/src2xml/source/macroparser_test.py b/layout/src2xml/source/macroparser_test.py
new file mode 100755
index 0000000..a706483
--- /dev/null
+++ layout/src2xml/source/macroparser_test.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python
+
+import macroparser
+
+def runParser (buf):
+    mparser = macroparser.MacroParser(buf)
+    mparser.debug = True
+    mparser.parse()
+
+def main ():
+    buf = 'FOO   (asdfsdaf)'
+    runParser(buf)
+    buf = 'FOO (x, y)  (x) + (y)'
+    runParser(buf)
+    buf = 'FOO(x, y)  (x) + (y)'
+    runParser(buf)
+
+
+if __name__ == '__main__':
+    main()
diff --git a/layout/src2xml/source/src2xml.py b/layout/src2xml/source/src2xml.py
new file mode 100755
index 0000000..8d082ee
--- /dev/null
+++ layout/src2xml/source/src2xml.py
@@ -0,0 +1,219 @@
+#!/usr/bin/env python
+
+import getopt
+import os
+import re
+import sys
+#
+from srclexer import SrcLexer
+from srcparser import SrcParser
+from boxer import Boxer
+# FIXME
+from globals import *
+
+def option_parser ():
+    import optparse
+    p = optparse.OptionParser ()
+
+    p.usage = '''src2xml.py [OPTION]... SRC-FILE...'''
+
+    examples = '''
+Examples:
+  src2xml.py --output-dir=. --post-process --ignore-includes zoom.src
+  src2xml.py --dry-run -I svx/inc -I svx/source/dialog zoom.src
+'''
+
+    def format_examples (self):
+        return examples
+    
+    if 'epilog' in  p.__dict__:
+        p.formatter.format_epilog = format_examples
+        p.epilog = examples
+    else:
+        p.formatter.format_description = format_examples
+        p.description = examples
+
+    p.description = '''OOo SRC To Layout XML Converter.
+
+Convert OO.o's existing dialog resource files into XML layout files.
+'''
+
+    p.add_option ('-l', '--debug-lexer', action='store_true',
+                  dest='debug_lexer', default=False,
+                  help='debug lexer')
+
+    p.add_option ('-p', '--debug-parser', action='store_true',
+                  dest='debug_parser', default=False,
+                  help='debug parser')
+
+    p.add_option ('-m', '--debug-macro', action='store_true',
+                  dest='debug_macro', default=False,
+                  help='debug macro')
+
+    p.add_option ('-n', '--dry-run', action='store_true',
+                  dest='dry_run', default=False,
+                  help='dry run')
+
+    p.add_option ('-k', '--keep-going', action='store_true',
+                  dest='keep_going', default=False,
+                  help='continue after error')
+
+    p.add_option ('-i', '--ignore-includes', action='store_true',
+                  dest='ignore_includes', default=False,
+                  help='ignore #include directives')
+
+    p.add_option ('-I', '--include-dir', action='append',
+                  dest='include_path',
+                  default=[],
+                  metavar='DIR',
+                  help='append DIR to include path')
+
+    def from_file (option, opt_str, value, parser):
+        lst = getattr (parser.values, option.dest)
+        lst += file (value).read ().split ('\n')
+        setattr (parser.values, option.dest, lst)
+
+    def from_path (option, opt_str, value, parser):
+        lst = getattr (parser.values, option.dest)
+        lst += value.split (':')
+        setattr (parser.values, option.dest, lst)
+
+    # Junk me?
+    p.add_option ('--includes-from-file', action='callback', callback=from_file,
+                  dest='include_path',
+                  default=[],
+                  type='string',
+                  metavar='FILE',
+                  help='append directory list from FILE to include path')
+
+    p.add_option ('--include-path', action='callback', callback=from_path,
+                  dest='include_path',
+                  type='string',
+                  default=[],
+                  metavar='PATH',
+                  help='append PATH to include path')
+
+    p.add_option ('--only-expand-macros', action='store_true',
+                  dest='only_expand_macros', default=False,
+                  help='FIXME: better to say what NOT to expand?')
+
+    p.add_option ('-o', '--output-dir', action='store',
+                  dest='output_dir', default=None,
+                  metavar='DIR',
+                  help='Output to DIR')
+
+    p.add_option ('-s', '--post-process', action='store_true',
+                  dest='post_process', default=False,
+                  help='post process output for use in Layout')
+
+    p.add_option ('--stop-on-header', action='store_true',
+                  dest='stopOnHeader', default=False,
+                  help='FIXME: remove this?')
+
+    return p
+
+
+def convert (file_name, options):
+    progress ("parsing %(file_name)s ..." % locals ())
+    fullpath = os.path.abspath(file_name)
+    if not os.path.isfile(fullpath):
+        error("no such file", exit=True)
+
+    ##options.include_path.append (os.path.dirname (fullpath))
+
+    input = file (fullpath, 'r').read()
+    lexer = SrcLexer(input, fullpath)
+    lexer.expandHeaders = not options.ignore_includes
+    lexer.includeDirs = options.include_path
+    lexer.stopOnHeader = options.stopOnHeader
+    lexer.debugMacro = options.debug_macro
+#     lexer.debug = True
+    if options.debug_lexer:
+        lexer.debug = True
+        lexer.tokenize()
+        progress ("-"*68 + "\n")
+        progress ("** token dump\n")
+        lexer.dumpTokens()
+        progress ("** end of token dump\n")
+        return
+
+    # Tokenize it using lexer
+    lexer.tokenize()
+
+    parser = SrcParser(lexer.getTokens(), lexer.getDefines())
+    parser.only_expand_macros = options.only_expand_macros
+    if options.debug_parser:
+        parser.debug = True
+        root = parser.parse()
+        print root.dump()
+        return
+
+    # Parse the tokens.
+    root = parser.parse()
+
+    # Box it, and return the XML tree.
+    root = Boxer(root).layout()
+    output = root.dump()
+    if not options.dry_run:
+        progress ("\n")
+    return output
+
+def dry_one_file (file_name, options):
+    try:
+        str = convert(file_name, options)
+        progress ("  SUCCESS\n")
+    except Exception, e:
+        if options.keep_going:
+            progress ("  FAILED\n")
+        else:
+            import traceback
+            print traceback.format_exc (None)
+            raise e
+
+def post_process (s):
+    """Make output directly usable by layout module."""
+    s = re.sub ('(</?)([a-z]+)-([a-z]+)-([a-z]+)', r'\1\2\3\4', s)
+    s = re.sub ('(</?)([a-z]+)-([a-z]+)', r'\1\2\3', s)
+    s = re.sub ('(<(radiobutton|(fixed(info|text)))[^>]*) text=', r'\1 label=', s)
+    s = re.sub (' (height|width|x|y)="[0-9]*"', '', s)
+
+    s = s.replace ('<modaldialog', '<modaldialog sizeable="true"')
+    s = s.replace (' rid=', ' id=')
+    s = s.replace (' border="true"', ' has_border="true"')
+    s = s.replace (' def-button="true"', ' default="true"')
+    return s
+
+XML_HEADER = '<?xml version="1.0" encoding="UTF-8"?>\n'
+
+def do_one_file (file_name, options):
+    str = XML_HEADER
+    str += convert(file_name, options)
+    str += '\n'
+
+    if options.post_process:
+        str = post_process (str)
+    h = sys.stdout
+    if options.output_dir:
+        base = os.path.basename (file_name)
+        root, ext = os.path.splitext (base)
+        out_name = options.output_dir + '/' + root + '.xml'
+        progress ("writing %(out_name)s ..." % locals ())
+        h = file (out_name, 'w')
+    h.write (str)
+    h.flush ()
+    progress ("\n")
+
+def main ():
+    p = option_parser ()
+    (options, files) = option_parser ().parse_args ()
+    if not files:
+        p.error ("no input files")
+
+    for f in files:
+        if options.dry_run:
+            dry_one_file (f, options)
+        else:
+            do_one_file (f, options)
+        
+if __name__ == '__main__':
+    main ()
diff --git a/layout/src2xml/source/srclexer.py b/layout/src2xml/source/srclexer.py
new file mode 100644
index 0000000..5a5a331
--- /dev/null
+++ layout/src2xml/source/srclexer.py
@@ -0,0 +1,488 @@
+import sys, os.path
+from globals import *
+import macroparser
+
+class EOF(Exception):
+    def __init__ (self):
+        pass
+
+    def str (self):
+        return "end of file"
+
+class BOF(Exception):
+    def __init__ (self):
+        pass
+
+    def str (self):
+        return "beginning of file"
+
+
+def removeHeaderQuotes (orig):
+    if len(orig) <= 2:
+        return orig
+    elif orig[0] == orig[-1] == '"':
+        return orig[1:-1]
+    elif orig[0] == '<' and orig[-1] == '>':
+        return orig[1:-1]
+
+    return orig
+
+
+def dumpTokens (tokens, toError=False):
+
+    scope = 0
+    indent = "    "
+    line = ''
+    chars = ''
+    
+    for token in tokens:
+        if token in '{<':
+            if len(line) > 0:
+                chars += indent*scope + line + "\n"
+                line = ''
+            chars += indent*scope + token + "\n"
+            scope += 1
+
+        elif token in '}>':
+            if len(line) > 0:
+                chars += indent*scope + line + "\n"
+                line = ''
+            scope -= 1
+            chars += indent*scope + token
+
+        elif token == ';':
+            if len(line) > 0:
+                chars += indent*scope + line + ";\n"
+                line = ''
+            else:
+                chars += ";\n"
+        elif len(token) > 0:
+            line += token + ' '
+
+    if len(line) > 0:
+        chars += line
+    chars += "\n"
+    if toError:
+        sys.stderr.write(chars)
+    else:
+        sys.stdout.write(chars)
+
+
+class HeaderData(object):
+    def __init__ (self):
+        self.defines = {}
+        self.tokens = []
+
+
+class SrcLexer(object):
+    """Lexicographical analyzer for .src format.
+
+The role of a lexer is to parse the source file and break it into 
+appropriate tokens.  Such tokens are later passed to a parser to
+build the syntax tree.
+"""
+    headerCache = {}
+
+    VISIBLE = 0
+    INVISIBLE_PRE = 1
+    INVISIBLE_POST = 2
+
+    def __init__ (self, chars, filepath = None):
+        self.filepath = filepath
+        self.parentLexer = None
+        self.chars = chars
+        self.bufsize = len(self.chars)
+
+        # TODO: use parameters for this
+        # Properties that can be copied.
+        self.headerDict = dict ()
+        self.debug = False
+        self.debugMacro = False
+        self.includeDirs = list ()
+        self.expandHeaders = True
+        self.inMacroDefine = False
+        self.stopOnHeader = False
+
+    def copyProperties (self, other):
+        """Copy properties from another instance of SrcLexer."""
+
+        # TODO: use parameters for this
+        self.headerDict = other.headerDict
+        self.debug = other.debug
+        self.debugMacro = other.debugMacro
+        self.includeDirs = other.includeDirs[:]
+        self.expandHeaders = other.expandHeaders
+        self.inMacroDefine = other.inMacroDefine
+        self.stopOnHeader = other.stopOnHeader
+
+    def init (self):
+        self.firstNonBlank = ''
+        self.token = ''
+        self.tokens = []
+        self.defines = {}
+        self.visibilityStack = []
+
+    def getTokens (self):
+        return self.tokens
+
+    def getDefines (self):
+        return self.defines
+
+    def nextPos (self, i):
+        while True:
+            i += 1
+            try:
+                c = self.chars[i]
+            except IndexError:
+                raise EOF
+
+            if ord(c) in [0x0D]:
+                continue
+            break
+        return i
+
+    def prevPos (self, i):
+        while True:
+            i -= 1
+            try:
+                c = self.chars[i]
+            except IndexError:
+                raise BOF
+
+            if ord(c) in [0x0D]:
+                continue
+            break
+        return i
+
+    def isCodeVisible (self):
+        if len(self.visibilityStack) == 0:
+            return True
+        for item in self.visibilityStack:
+            if item != SrcLexer.VISIBLE:
+                return False
+        return True
+        
+    def tokenize (self):
+        self.init()
+
+        i = 0
+        while True:
+            c = self.chars[i]
+
+            if self.firstNonBlank == '' and not c in [' ', "\n", "\t"]:
+                # Store the first non-blank in a line.
+                self.firstNonBlank = c
+            elif c == "\n":
+                self.firstNonBlank = ''
+
+            if c == '#':
+                i = self.pound(i)
+            elif c == '/':
+                i = self.slash(i)
+            elif c == "\n":
+                i = self.lineBreak(i)
+            elif c == '"':
+                i = self.doubleQuote(i)
+            elif c in [' ', "\t"]:
+                i = self.blank(i)
+            elif c in ";()[]{}<>,=+-*":
+                # Any outstanding single-character token.
+                i = self.anyToken(i, c)
+            elif self.isCodeVisible():
+                self.token += c
+
+            try:
+                i = self.nextPos(i)
+            except EOF:
+                break
+
+        if len(self.token):
+            self.tokens.append(self.token)
+
+        if not self.parentLexer and self.debug:
+            progress ("-"*68 + "\n")
+            progress ("All defines found in this translation unit:\n")
+            keys = self.defines.keys()
+            keys.sort()
+            for key in keys:
+                progress ("@ %s\n"%key)
+
+    def dumpTokens (self, toError=False):
+        dumpTokens(self.tokens, toError)
+
+
+    def maybeAddToken (self):
+        if len(self.token) > 0:
+            self.tokens.append(self.token)
+            self.token = ''
+
+
+    #--------------------------------------------------------------------
+    # character handlers
+
+    def blank (self, i):
+        if not self.isCodeVisible():
+            return i
+
+        self.maybeAddToken()
+        return i
+
+
+    def pound (self, i):
+
+        if self.inMacroDefine:
+            return i
+
+        if not self.firstNonBlank == '#':
+            return i
+
+        self.maybeAddToken()
+        # We are in preprocessing mode.
+
+        # Get the macro command name '#<command> .....'
+
+        command, define, buf = '', '', ''
+        firstNonBlank = False
+        while True:
+            try:
+                i = self.nextPos(i)
+                c = self.chars[i]
+                if c == '\\' and self.chars[self.nextPos(i)] == "\n":
+                    i = self.nextPos(i)
+                    continue
+            except EOF:
+                break
+
+            if c == "\n":
+                if len(buf) > 0 and len(command) == 0:
+                    command = buf
+                i = self.prevPos(i)
+                break
+            elif c in [' ', "\t"]:
+                if not firstNonBlank:
+                    # Ignore any leading blanks after the '#'.
+                    continue
+
+                if len(command) == 0:
+                    command = buf
+                    buf = ''
+                else:
+                    buf += ' '
+            elif c == '(':
+                if len(buf) > 0 and len(command) == 0:
+                    command = buf
+                buf += c
+            else:
+                if not firstNonBlank:
+                    firstNonBlank = True
+                buf += c
+
+        if command == 'define':
+            self.handleMacroDefine(buf)
+        elif command == 'include':
+            self.handleMacroInclude(buf)
+        elif command == 'ifdef':
+            defineName = buf.strip()
+            if self.defines.has_key(defineName):
+                self.visibilityStack.append(SrcLexer.VISIBLE)
+            else:
+                self.visibilityStack.append(SrcLexer.INVISIBLE_PRE)
+
+        elif command == 'ifndef':
+            defineName = buf.strip()
+            if self.defines.has_key(defineName):
+                self.visibilityStack.append(SrcLexer.INVISIBLE_PRE)
+            else:
+                self.visibilityStack.append(SrcLexer.VISIBLE)
+
+        elif command == 'if':
+            if self.evalCodeVisibility(buf):
+                self.visibilityStack.append(SrcLexer.VISIBLE)
+            else:
+                self.visibilityStack.append(SrcLexer.INVISIBLE_PRE)
+
+        elif command == 'elif':
+            if len(self.visibilityStack) == 0:
+                raise ParseError ('')
+
+            if self.visibilityStack[-1] == SrcLexer.VISIBLE:
+                self.visibilityStack[-1] = SrcLexer.INVISIBLE_POST
+            elif self.visibilityStack[-1] == SrcLexer.INVISIBLE_PRE:
+                # Evaluate only if the current visibility is false.
+                if self.evalCodeVisibility(buf):
+                    self.visibilityStack[-1] = SrcLexer.VISIBLE
+
+        elif command == 'else':
+            if len(self.visibilityStack) == 0:
+                raise ParseError ('')
+
+            if self.visibilityStack[-1] == SrcLexer.VISIBLE:
+                self.visibilityStack[-1] = SrcLexer.INVISIBLE_POST
+            if self.visibilityStack[-1] == SrcLexer.INVISIBLE_PRE:
+                self.visibilityStack[-1] = SrcLexer.VISIBLE
+
+        elif command == 'endif':
+            if len(self.visibilityStack) == 0:
+                raise ParseError ('')
+            self.visibilityStack.pop()
+
+        elif command == 'undef':
+            pass
+        elif command in ['error', 'pragma']:
+            pass
+        else:
+            print "'%s' '%s'"%(command, buf)
+            print self.filepath
+            sys.exit(0)
+
+        return i
+
+
+    def evalCodeVisibility (self, buf):
+        try:
+            return eval(buf)
+        except:
+            return True
+        
+    def handleMacroDefine (self, buf):
+
+        mparser = macroparser.MacroParser(buf)
+        mparser.debug = self.debugMacro
+        mparser.parse()
+        macro = mparser.getMacro()
+        if macro:
+            self.defines[macro.name] = macro
+
+    def handleMacroInclude (self, buf):
+
+        # Strip excess string if any.
+        pos = buf.find(' ')
+        if pos >= 0:
+            buf = buf[:pos]
+        headerSub = removeHeaderQuotes(buf)
+
+        if not self.expandHeaders:
+            # We don't want to expand headers.  Bail out.
+            if self.debug:
+                progress ("%s ignored\n"%headerSub)
+            return
+
+        defines = {}
+        headerPath = None
+        for includeDir in self.includeDirs:
+            hpath = includeDir + '/' + headerSub
+            if os.path.isfile(hpath) and hpath != self.filepath:
+                headerPath = hpath
+                break
+
+        if not headerPath:
+            error("included header file " + headerSub + " not found\n", self.stopOnHeader)
+            return
+        
+        if self.debug:
+            progress ("%s found\n"%headerPath)
+
+        if headerPath in self.headerDict:
+            if self.debug:
+                progress ("%s already included\n"%headerPath)
+            return
+
+        if SrcLexer.headerCache.has_key(headerPath):
+            if self.debug:
+                progress ("%s in cache\n"%headerPath)
+            for key in SrcLexer.headerCache[headerPath].defines.keys():
+                self.defines[key] = SrcLexer.headerCache[headerPath].defines[key]
+            return
+
+        chars = open(headerPath, 'r').read()
+        mclexer = SrcLexer(chars, headerPath)
+        mclexer.copyProperties(self)
+        mclexer.parentLexer = self
+        mclexer.tokenize()
+        hdrData = HeaderData()
+        hdrData.tokens = mclexer.getTokens()
+        headerDefines = mclexer.getDefines()
+        for key in headerDefines.keys():
+            defines[key] = headerDefines[key]
+            hdrData.defines[key] = headerDefines[key]
+
+        self.headerDict[headerPath] = True
+        SrcLexer.headerCache[headerPath] = hdrData
+
+        # Update the list of headers that have already been expaneded.
+        for key in mclexer.headerDict.keys():
+            self.headerDict[key] = True
+
+        if self.debug:
+            progress ("defines found in header %s:\n"%headerSub)
+            for key in defines.keys():
+                progress ("  '%s'\n"%key)
+
+        for key in defines.keys():
+            self.defines[key] = defines[key]
+
+
+    def slash (self, i):
+        if not self.isCodeVisible():
+            return i
+
+        if i < self.bufsize - 1 and self.chars[i+1] == '/':
+            # Parse line comment.
+            line = ''
+            i += 2
+            while i < self.bufsize:
+                c = self.chars[i]
+                if ord(c) in [0x0A, 0x0D]:
+                    return i - 1
+                line += c
+                i += 1
+            self.token = ''
+        elif i < self.bufsize - 1 and self.chars[i+1] == '*':
+            comment = ''
+            i += 2
+            while i < self.bufsize:
+                c = self.chars[i]
+                if c == '/' and self.chars[i-1] == '*':
+                    return i
+                comment += c
+                i += 1
+        else:
+            return self.anyToken(i, '/')
+
+        return i
+
+
+    def lineBreak (self, i):
+        if not self.isCodeVisible():
+            return i
+
+        self.maybeAddToken()
+
+        return i
+
+
+    def doubleQuote (self, i):
+        if not self.isCodeVisible():
+            return i
+
+        literal = ''
+        i += 1
+        while i < self.bufsize:
+            c = self.chars[i]
+            if c == '"':
+                self.tokens.append('"'+literal+'"')
+                break
+            literal += c
+            i += 1
+
+        return i
+
+
+    def anyToken (self, i, token):
+        if not self.isCodeVisible():
+            return i
+
+        self.maybeAddToken()
+        self.token = token
+        self.maybeAddToken()
+        return i
diff --git a/layout/src2xml/source/srcparser.py b/layout/src2xml/source/srcparser.py
new file mode 100644
index 0000000..b25d39e
--- /dev/null
+++ layout/src2xml/source/srcparser.py
@@ -0,0 +1,416 @@
+import sys
+from globals import *
+import srclexer
+
+# simple name translation map
+postTransMap = {"ok-button": "okbutton", 
+                "cancel-button": "cancelbutton",
+                "help-button": "helpbutton"}
+
+def transName (name):
+    """Translate a mixed-casing name to dash-separated name.
+
+Translate a mixed-casing name (e.g. MyLongName) to a dash-separated name
+(e.g. my-long-name).
+"""
+    def isUpper (c):
+        return c >= 'A' and c <= 'Z'
+
+    newname = ''
+    parts = []
+    buf = ''
+    for c in name:
+        if isUpper(c) and len(buf) > 1:
+            parts.append(buf)
+            buf = c
+        else:
+            buf += c
+
+    if len(buf) > 0:
+        parts.append(buf)
+
+    first = True
+    for part in parts:
+        if first:
+            first = False
+        else:
+            newname += '-'
+        newname += part.lower()
+
+    # special-case mapping ...
+    if 0: #postTransMap.has_key(newname):
+        newname = postTransMap[newname]
+
+    return newname
+
+
+def transValue (value):
+    """Translate certain values.
+
+Examples of translated values include TRUE -> true, FALSE -> false.
+"""
+    if value.lower() in ["true", "false"]:
+        value = value.lower()
+    return value
+
+
+def renameAttribute (name, elemName):
+
+    # TODO: all manner of evil special cases ...
+    if elemName == 'metric-field' and name == 'spin-size':
+        return 'step-size'
+
+    return name
+
+
+class Statement(object):
+    """Container to hold information for a single statement.
+
+Each statement consists of the left-hand-side token(s), and right-hand-side
+tokens, separated by a '=' token.  This class stores the information on the
+left-hand-side tokens.
+"""
+    def __init__ (self):
+        self.leftTokens = []
+        self.leftScope = None
+
+
+class MacroExpander(object):
+    def __init__ (self, tokens, defines):
+        self.tokens = tokens
+        self.defines = defines
+
+    def expand (self):
+        self.pos = 0
+        while self.pos < len(self.tokens):
+            self.expandToken()
+
+    def expandToken (self):
+        token = self.tokens[self.pos]
+        if not self.defines.has_key(token):
+            self.pos += 1
+            return
+
+        macro = self.defines[token]
+        nvars = len(macro.vars.keys())
+        if nvars == 0:
+            # Simple expansion
+            self.tokens[self.pos:self.pos+1] = macro.tokens
+            return
+        else:
+            # Expansion with arguments.
+            values, lastPos = self.parseValues()
+            newtokens = []
+            for mtoken in macro.tokens:
+                if macro.vars.has_key(mtoken):
+                    # variable
+                    pos = macro.vars[mtoken]
+                    valtokens = values[pos]
+                    for valtoken in valtokens:
+                        newtokens.append(valtoken)
+                else:
+                    # not a variable
+                    newtokens.append(mtoken)
+
+            self.tokens[self.pos:self.pos+lastPos+1] = newtokens
+
+
+    def parseValues (self):
+        """Parse tokens to get macro function variable values.
+
+Be aware that there is an implicit quotes around the text between the open 
+paren, the comma(s), and the close paren.  For instance, if a macro is defined 
+as FOO(a, b) and is used as FOO(one two three, and four), then the 'a' must be 
+replaced with 'one two three', and the 'b' replaced with 'and four'.  In other 
+words, whitespace does not end a token.  
+
+"""
+        values = []
+        i = 1
+        scope = 0
+        value = []
+        while True:
+            try:
+                tk = self.tokens[self.pos+i]
+            except IndexError:
+                progress ("error parsing values (%d)\n"%i)
+                for j in xrange(0, i):
+                    print self.tokens[self.pos+j],
+                print ''
+                srclexer.dumpTokens(self.tokens)
+                srclexer.dumpTokens(self.newtokens)
+                print "tokens expanded so far:"
+                for tk in self.expandedTokens:
+                    print "-"*20
+                    print tk
+                    srclexer.dumpTokens(self.defines[tk].tokens)
+                sys.exit(1)
+            if tk == '(':
+                value = []
+                scope += 1
+            elif tk == ',':
+                values.append(value)
+                value = []
+            elif tk == ')':
+                scope -= 1
+                values.append(value)
+                value = []
+                if scope == 0:
+                    break
+                else:
+                    raise ParseError ('')
+            else:
+                value.append(tk)
+            i += 1
+
+        return values, i
+
+    def getTokens (self):
+        return self.tokens
+
+
+class SrcParser(object):
+
+    def __init__ (self, tokens, defines = None):
+        self.tokens = tokens
+        self.defines = defines
+        self.debug = False
+        self.onlyExpandMacros = False
+
+    def init (self):
+        self.elementStack = [RootNode()]
+        self.stmtData = Statement()
+        self.tokenBuf = []
+        self.leftTokens = []
+
+        # Expand defined macros.
+        if self.debug:
+            progress ("-"*68+"\n")
+            for key in self.defines.keys():
+                progress ("define: %s\n"%key)
+
+        self.expandMacro()
+        self.tokenSize = len(self.tokens)
+
+    def expandMacro (self):
+        macroExp = MacroExpander(self.tokens, self.defines)
+        macroExp.expand()
+        self.tokens = macroExp.getTokens()
+        if self.onlyExpandMacros:
+            srclexer.dumpTokens(self.tokens)
+            sys.exit(0)
+
+    def parse (self):
+        """Parse it!
+
+This is the main loop for the parser.  This is where it all begins and ends.
+"""
+        self.init()
+
+        i = 0
+        while i < self.tokenSize:
+            tk = self.tokens[i]
+            if tk == '{':
+                i = self.openBrace(i)
+            elif tk == '}':
+                i = self.closeBrace(i)
+            elif tk == ';':
+                i = self.semiColon(i)
+            elif tk == '=':
+                i = self.assignment(i)
+            else:
+                self.tokenBuf.append(tk)
+
+            i += 1
+
+        return self.elementStack[0]
+
+    #-------------------------------------------------------------------------
+    # Token Handlers
+
+    """
+Each token handler takes the current token position and returns the position 
+of the last token processed.  For the most part, the current token position 
+and the last processed token are one and the same, in which case the handler 
+can simply return the position value it receives without incrementing it.  
+
+If you need to read ahead to process more tokens than just the current token, 
+make sure that the new token position points to the last token that has been 
+processed, not the next token that has not yet been processed.  This is 
+because the main loop increments the token position when it returns from the 
+handler.
+""" 
+
+    # assignment token '='
+    def assignment (self, i):
+        self.leftTokens = self.tokenBuf[:]
+        if self.stmtData.leftScope == None:
+            # Keep track of lhs data in case of compound statement.
+            self.stmtData.leftTokens = self.tokenBuf[:]
+            self.stmtData.leftScope = len(self.elementStack) - 1
+
+        self.tokenBuf = []
+        return i
+    
+    # open brace token '{'
+    def openBrace (self, i):
+        bufSize = len(self.tokenBuf)
+        leftSize = len(self.leftTokens)
+        obj = None
+        if bufSize == 0 and leftSize > 0:
+            # Name = { ...
+            obj = Element(self.leftTokens[0])
+
+        elif bufSize > 0 and leftSize == 0:
+            # Type Name { ...
+            wgtType = self.tokenBuf[0]
+            wgtRID = None
+            if bufSize >= 2:
+                wgtRID = self.tokenBuf[1]
+            obj = Element(wgtType, wgtRID)
+
+        else:
+            # LeftName = Name { ...
+            obj = Element(self.leftTokens[0])
+            obj.setAttr("type", self.tokenBuf[0])
+
+        obj.name = transName(obj.name)
+
+        if obj.name == 'string-list':
+            i = self.parseStringList(i)
+        elif obj.name == 'filter-list':
+            i = self.parseFilterList(i, obj)
+        else:
+            self.elementStack[-1].appendChild(obj)
+            self.elementStack.append(obj)
+
+        self.tokenBuf = []
+        self.leftTokens = []
+
+        return i
+
+    # close brace token '}'
+    def closeBrace (self, i):
+        if len(self.tokenBuf) > 0:
+            if self.debug:
+                print self.tokenBuf
+            raise ParseError ('')
+        self.elementStack.pop()
+        return i
+
+    # semi colon token ';'
+    def semiColon (self, i):
+        stackSize = len(self.elementStack)
+        scope = stackSize - 1
+        if len(self.tokenBuf) == 0:
+            pass
+        elif scope == 0:
+            # We are not supposed to have any statment in global scope.  
+            # Just ignore this statement.
+            pass
+        else:
+            # Statement within a scope.  Import it as an attribute for the 
+            # current element.
+            elem = self.elementStack[-1]
+
+            name = "none"
+            if len(self.leftTokens) > 0:
+                # Use the leftmost token as the name for now.  If we need to
+                # do more complex parsing of lhs, add more code here.
+                name = self.leftTokens[0]
+                name = transName(name)
+
+            if name == 'pos':
+                i = self.parsePosAttr(i)
+            elif name == 'size':
+                i = self.parseSizeAttr(i)
+            elif len (self.tokenBuf) == 1:
+                # Simple value
+                value = transValue(self.tokenBuf[0])
+                name = renameAttribute(name, elem.name)
+                elem.setAttr(name, value)
+
+            if not self.stmtData.leftScope == None and self.stmtData.leftScope < scope:
+                # This is a nested scope within a statement.  Do nothing for now.
+                pass
+
+        if self.stmtData.leftScope == scope:
+            # end of (nested) statement.
+            self.stmtData.leftScope = None
+
+        self.tokenBuf = []
+        self.leftTokens = []
+
+        return i
+
+    def parseStringList (self, i):
+
+        i += 1
+        while i < self.tokenSize:
+            tk = self.tokens[i]
+            if tk == '}':
+                break
+            i += 1
+
+        return i
+
+    def parseFilterList (self, i, obj):
+        self.elementStack[-1].appendChild(obj)
+        self.elementStack.append(obj)
+
+        return i
+
+    def parsePosAttr (self, i):
+
+        # MAP_APPFONT ( 6 , 5 )
+        elem = self.elementStack[-1]
+        x, y = self.parseMapAppfont(self.tokenBuf)
+        elem.setAttr("x", x)
+        elem.setAttr("y", y)
+
+        return i
+
+    def parseSizeAttr (self, i):
+
+        # MAP_APPFONT ( 6 , 5 )
+        elem = self.elementStack[-1]
+        width, height = self.parseMapAppfont(self.tokenBuf)
+        elem.setAttr("width", width)
+        elem.setAttr("height", height)
+
+        return i
+
+    def parseMapAppfont (self, tokens):
+        values = []
+        scope = 0
+        val = ''
+        for tk in tokens:
+            if tk == '(':
+                scope += 1
+                if scope == 1:
+                    val = ''
+                else:
+                    val += tk
+            elif tk == ')':
+                scope -= 1
+                if scope == 0:
+                    if len(val) == 0:
+                        raise ParseError ('')
+                    values.append(val)
+                    break
+                else:
+                    val += tk
+            elif tk == ',':
+                if len(val) == 0:
+                    raise ParseError ('')
+                values.append(val)
+                val = ''
+            elif scope > 0:
+                val += tk
+
+        if len(values) != 2:
+            raise ParseError ('')
+
+        return eval(values[0]), eval(values[1])
+
+
diff --git a/layout/src2xml/src-sc.lst b/layout/src2xml/src-sc.lst
new file mode 100644
index 0000000..bb2417d
--- /dev/null
+++ layout/src2xml/src-sc.lst
@@ -0,0 +1,57 @@
+../../sc/util/hidother.src
+../../sc/addin/datefunc/dfa.src
+../../sc/addin/rot13/rot13.src
+../../sc/source/ui/src/crnrdlg.src
+../../sc/source/ui/src/hdrcont.src
+../../sc/source/ui/src/solvrdlg.src
+../../sc/source/ui/src/miscdlgs.src
+../../sc/source/ui/src/tabopdlg.src
+../../sc/source/ui/src/popup.src
+../../sc/source/ui/src/autofmt.src
+../../sc/source/ui/src/toolbox.src
+../../sc/source/ui/src/opredlin.src
+../../sc/source/ui/src/namedlg.src
+../../sc/source/ui/src/sortdlg.src
+../../sc/source/ui/src/textdlgs.src
+../../sc/source/ui/src/optdlg.src
+../../sc/source/ui/src/scwarngs.src
+../../sc/source/ui/src/scfuncs.src
+../../sc/source/ui/src/filter.src
+../../sc/source/ui/src/simpref.src
+../../sc/source/ui/src/attrdlg.src
+../../sc/source/ui/src/sc.src
+../../sc/source/ui/src/globstr.src
+../../sc/source/ui/src/scstring.src
+../../sc/source/ui/src/dbnamdlg.src
+../../sc/source/ui/src/subtdlg.src
+../../sc/source/ui/src/pseudo.src
+../../sc/source/ui/src/condfrmt.src
+../../sc/source/ui/src/chartdlg.src
+../../sc/source/ui/src/scerrors.src
+../../sc/source/ui/dbgui/outline.src
+../../sc/source/ui/dbgui/pvfundlg.src
+../../sc/source/ui/dbgui/scendlg.src
+../../sc/source/ui/dbgui/pivot.src
+../../sc/source/ui/dbgui/dpgroupdlg.src
+../../sc/source/ui/dbgui/dapitype.src
+../../sc/source/ui/dbgui/imoptdlg.src
+../../sc/source/ui/dbgui/consdlg.src
+../../sc/source/ui/dbgui/validate.src
+../../sc/source/ui/dbgui/asciiopt.src
+../../sc/source/ui/drawfunc/objdraw.src
+../../sc/source/ui/drawfunc/drformsh.src
+../../sc/source/ui/styleui/scstyles.src
+../../sc/source/ui/styleui/styledlg.src
+../../sc/source/ui/formdlg/parawin.src
+../../sc/source/ui/formdlg/dwfunctr.src
+../../sc/source/ui/formdlg/formdlgs.src
+../../sc/source/ui/navipi/navipi.src
+../../sc/source/ui/miscdlgs/acredlin.src
+../../sc/source/ui/miscdlgs/highred.src
+../../sc/source/ui/miscdlgs/linkarea.src
+../../sc/source/ui/miscdlgs/instbdlg.src
+../../sc/source/ui/pagedlg/pagedlg.src
+../../sc/source/ui/pagedlg/tphf.src
+../../sc/source/ui/pagedlg/hfedtdlg.src
+../../sc/source/ui/docshell/tpstat.src
+../../sc/source/core/src/compiler.src
diff --git a/layout/src2xml/src-sd.lst b/layout/src2xml/src-sd.lst
new file mode 100644
index 0000000..6dc236e
--- /dev/null
+++ layout/src2xml/src-sd.lst
@@ -0,0 +1,124 @@
+../../sd/util/hidother.src
+../../sd/source/ui/app/tbxids_tmpl.src
+../../sd/source/ui/app/popup2_tmpl.src
+../../sd/source/ui/app/popup.src
+../../sd/source/ui/app/toolbox.src
+../../sd/source/ui/app/menuids2_tmpl.src
+../../sd/source/ui/app/sdstring.src
+../../sd/source/ui/app/menu_tmpl.src
+../../sd/source/ui/app/strings.src
+../../sd/source/ui/app/menuids_tmpl.src
+../../sd/source/ui/app/accel_tmpl.src
+../../sd/source/ui/app/tbx_ww.src
+../../sd/source/ui/app/accelids_tmpl.src
+../../sd/source/ui/app/menuportal_tmpl.src
+../../sd/source/ui/app/menuids3_tmpl.src
+../../sd/source/ui/app/app.src
+../../sd/source/ui/app/res_bmp.src
+../../sd/source/ui/app/pseudo.src
+../../sd/source/ui/app/menuids4_tmpl.src
+../../sd/source/ui/app/toolbox2_tmpl.src
+../../sd/source/ui/dlg/headerfooterdlg.src
+../../sd/source/ui/dlg/dlgfield.src
+../../sd/source/ui/dlg/sdobjpal.src
+../../sd/source/ui/dlg/morphdlg.src
+../../sd/source/ui/dlg/PaneDockingWindow.src
+../../sd/source/ui/dlg/dlgsnap.src
+../../sd/source/ui/dlg/tpoption.src
+../../sd/source/ui/dlg/present.src
+../../sd/source/ui/dlg/sdpreslt.src
+../../sd/source/ui/dlg/dlgass.src
+../../sd/source/ui/dlg/tpaction.src
+../../sd/source/ui/dlg/prntopts.src
+../../sd/source/ui/dlg/prltempl.src
+../../sd/source/ui/dlg/custsdlg.src
+../../sd/source/ui/dlg/inspagob.src
+../../sd/source/ui/dlg/paragr.src
+../../sd/source/ui/dlg/dlgpage.src
+../../sd/source/ui/dlg/vectdlg.src
+../../sd/source/ui/dlg/dlgolbul.src
+../../sd/source/ui/dlg/copydlg.src
+../../sd/source/ui/dlg/dlg_char.src
+../../sd/source/ui/dlg/printdlg.src
+../../sd/source/ui/dlg/ins_page.src
+../../sd/source/ui/dlg/animobjs.src
+../../sd/source/ui/dlg/ins_paste.src
+../../sd/source/ui/dlg/tabtempl.src
+../../sd/source/ui/dlg/LayerDialog.src
+../../sd/source/ui/dlg/masterlayoutdlg.src
+../../sd/source/ui/dlg/navigatr.src
+../../sd/source/ui/dlg/brkdlg.src
+../../sd/source/ui/slidesorter/shell/SlideSorterChildWindow.src
+../../sd/source/ui/notes/NotesChildWindow.src
+../../sd/source/ui/toolpanel/ToolPanelChildWindow.src
+../../sd/source/ui/animations/CustomAnimationCreateDialog.src
+../../sd/source/ui/animations/CustomAnimationDialog.src
+../../sd/source/ui/animations/CustomAnimation.src
+../../sd/source/ui/animations/CustomAnimationSchemesPane.src
+../../sd/source/ui/animations/SlideTransitionPane.src
+../../sd/source/ui/animations/AnimationSchemesPane.src
+../../sd/source/ui/animations/CustomAnimationPane.src
+../../sd/source/ui/accessibility/accessibility.src
+../../sd/source/ui/slideshow/slideshow.src
+../../sd/source/core/glob.src
+../../sd/source/filter/html/pubdlg.src
+../../sd/unxlngi6.pro/inc/menu.src
+../../sd/unxlngi6.pro/inc/menuids2.src
+../../sd/unxlngi6.pro/inc/menuids3.src
+../../sd/unxlngi6.pro/inc/menuids4.src
+../../sd/unxlngi6.pro/inc/popup2.src
+../../sd/unxlngi6.pro/inc/toolbox2.src
+../../sd/unxlngi6.pro/inc/accel.src
+../../sd/unxlngi6.pro/inc/menuids.src
+../../sd/unxlngi6.pro/inc/menuportal.src
+../../sd/unxlngi6.pro/inc/accelids.src
+../../sd/unxlngi6.pro/inc/tbxids.src
+../../sd/unxlngi6.pro/misc/app/popup.src
+../../sd/unxlngi6.pro/misc/app/toolbox.src
+../../sd/unxlngi6.pro/misc/app/sdstring.src
+../../sd/unxlngi6.pro/misc/app/strings.src
+../../sd/unxlngi6.pro/misc/app/tbx_ww.src
+../../sd/unxlngi6.pro/misc/app/app.src
+../../sd/unxlngi6.pro/misc/app/res_bmp.src
+../../sd/unxlngi6.pro/misc/app/pseudo.src
+../../sd/unxlngi6.pro/misc/dlg/headerfooterdlg.src
+../../sd/unxlngi6.pro/misc/dlg/dlgfield.src
+../../sd/unxlngi6.pro/misc/dlg/morphdlg.src
+../../sd/unxlngi6.pro/misc/dlg/PaneDockingWindow.src
+../../sd/unxlngi6.pro/misc/dlg/dlgsnap.src
+../../sd/unxlngi6.pro/misc/dlg/tpoption.src
+../../sd/unxlngi6.pro/misc/dlg/present.src
+../../sd/unxlngi6.pro/misc/dlg/sdpreslt.src
+../../sd/unxlngi6.pro/misc/dlg/dlgass.src
+../../sd/unxlngi6.pro/misc/dlg/tpaction.src
+../../sd/unxlngi6.pro/misc/dlg/prntopts.src
+../../sd/unxlngi6.pro/misc/dlg/prltempl.src
+../../sd/unxlngi6.pro/misc/dlg/custsdlg.src
+../../sd/unxlngi6.pro/misc/dlg/inspagob.src
+../../sd/unxlngi6.pro/misc/dlg/paragr.src
+../../sd/unxlngi6.pro/misc/dlg/dlgpage.src
+../../sd/unxlngi6.pro/misc/dlg/vectdlg.src
+../../sd/unxlngi6.pro/misc/dlg/dlgolbul.src
+../../sd/unxlngi6.pro/misc/dlg/copydlg.src
+../../sd/unxlngi6.pro/misc/dlg/dlg_char.src
+../../sd/unxlngi6.pro/misc/dlg/printdlg.src
+../../sd/unxlngi6.pro/misc/dlg/ins_page.src
+../../sd/unxlngi6.pro/misc/dlg/animobjs.src
+../../sd/unxlngi6.pro/misc/dlg/ins_paste.src
+../../sd/unxlngi6.pro/misc/dlg/tabtempl.src
+../../sd/unxlngi6.pro/misc/dlg/LayerDialog.src
+../../sd/unxlngi6.pro/misc/dlg/masterlayoutdlg.src
+../../sd/unxlngi6.pro/misc/dlg/navigatr.src
+../../sd/unxlngi6.pro/misc/dlg/brkdlg.src
+../../sd/unxlngi6.pro/misc/core/glob.src
+../../sd/unxlngi6.pro/misc/html/pubdlg.src
+../../sd/unxlngi6.pro/misc/notes/NotesChildWindow.src
+../../sd/unxlngi6.pro/misc/accessibility/accessibility.src
+../../sd/unxlngi6.pro/misc/animui/CustomAnimationCreateDialog.src
+../../sd/unxlngi6.pro/misc/animui/CustomAnimationDialog.src
+../../sd/unxlngi6.pro/misc/animui/CustomAnimation.src
+../../sd/unxlngi6.pro/misc/animui/CustomAnimationSchemesPane.src
+../../sd/unxlngi6.pro/misc/animui/SlideTransitionPane.src
+../../sd/unxlngi6.pro/misc/animui/AnimationSchemesPane.src
+../../sd/unxlngi6.pro/misc/animui/CustomAnimationPane.src
+../../sd/unxlngi6.pro/misc/slideshow/slideshow.src
diff --git a/layout/src2xml/src-sw.lst b/layout/src2xml/src-sw.lst
new file mode 100644
index 0000000..8d43400
--- /dev/null
+++ layout/src2xml/src-sw.lst
@@ -0,0 +1,121 @@
+../../sw/sdi/swslots.src
+../../sw/util/hidother.src
+../../sw/source/ui/app/mn.src
+../../sw/source/ui/app/app.src
+../../sw/source/ui/app/error.src
+../../sw/source/ui/web/web.src
+../../sw/source/ui/dbui/addresslistdialog.src
+../../sw/source/ui/dbui/customizeaddresslistdialog.src
+../../sw/source/ui/dbui/mailmergewizard.src
+../../sw/source/ui/dbui/mmlayoutpage.src
+../../sw/source/ui/dbui/dbui.src
+../../sw/source/ui/dbui/createaddresslistdialog.src
+../../sw/source/ui/dbui/mmoutputpage.src
+../../sw/source/ui/dbui/dbtablepreviewdialog.src
+../../sw/source/ui/dbui/mmmergepage.src
+../../sw/source/ui/dbui/dbinsdlg.src
+../../sw/source/ui/dbui/selectdbtabledialog.src
+../../sw/source/ui/dbui/mmoutputtypepage.src
+../../sw/source/ui/dbui/mailmergechildwindow.src
+../../sw/source/ui/dbui/mmpreparemergepage.src
+../../sw/source/ui/dbui/mmdocselectpage.src
+../../sw/source/ui/dbui/mmgreetingspage.src
+../../sw/source/ui/dbui/mmaddressblockpage.src
+../../sw/source/ui/misc/linenum.src
+../../sw/source/ui/misc/outline.src
+../../sw/source/ui/misc/glosbib.src
+../../sw/source/ui/misc/pgfnote.src
+../../sw/source/ui/misc/redlndlg.src
+../../sw/source/ui/misc/glossary.src
+../../sw/source/ui/misc/numberingtypelistbox.src
+../../sw/source/ui/misc/autocorr.src
+../../sw/source/ui/misc/insfnote.src
+../../sw/source/ui/misc/srtdlg.src
+../../sw/source/ui/misc/num.src
+../../sw/source/ui/misc/pggrid.src
+../../sw/source/ui/misc/bookmark.src
+../../sw/source/ui/misc/docfnote.src
+../../sw/source/ui/misc/insrule.src
+../../sw/source/ui/docvw/docvw.src
+../../sw/source/ui/docvw/access.src
+../../sw/source/ui/fldui/javaedit.src
+../../sw/source/ui/fldui/fldref.src
+../../sw/source/ui/fldui/fldtdlg.src
+../../sw/source/ui/fldui/fldfunc.src
+../../sw/source/ui/fldui/flddok.src
+../../sw/source/ui/fldui/flddinf.src
+../../sw/source/ui/fldui/inpdlg.src
+../../sw/source/ui/fldui/flddb.src
+../../sw/source/ui/fldui/changedb.src
+../../sw/source/ui/fldui/fldvar.src
+../../sw/source/ui/fldui/DropDownFieldDialog.src
+../../sw/source/ui/fldui/fldui.src
+../../sw/source/ui/fmtui/tmpdlg.src
+../../sw/source/ui/fmtui/fmtui.src
+../../sw/source/ui/index/cnttab.src
+../../sw/source/ui/index/multmrk.src
+../../sw/source/ui/index/idxmrk.src
+../../sw/source/ui/lingu/olmenu.src
+../../sw/source/ui/table/colwd.src
+../../sw/source/ui/table/rowht.src
+../../sw/source/ui/table/tautofmt.src
+../../sw/source/ui/table/splittbl.src
+../../sw/source/ui/table/chartins.src
+../../sw/source/ui/table/tabledlg.src
+../../sw/source/ui/table/split.src
+../../sw/source/ui/table/convert.src
+../../sw/source/ui/table/insrc.src
+../../sw/source/ui/table/table.src
+../../sw/source/ui/table/mergetbl.src
+../../sw/source/ui/table/instable.src
+../../sw/source/ui/utlui/utlui.src
+../../sw/source/ui/utlui/initui.src
+../../sw/source/ui/utlui/navipi.src
+../../sw/source/ui/utlui/attrdesc.src
+../../sw/source/ui/utlui/gloslst.src
+../../sw/source/ui/utlui/poolfmt.src
+../../sw/source/ui/utlui/unotools.src
+../../sw/source/ui/wrtsh/wrtsh.src
+../../sw/source/ui/chrdlg/chardlg.src
+../../sw/source/ui/chrdlg/swbreak.src
+../../sw/source/ui/chrdlg/ccoll.src
+../../sw/source/ui/chrdlg/paradlg.src
+../../sw/source/ui/chrdlg/drpcps.src
+../../sw/source/ui/chrdlg/chrdlg.src
+../../sw/source/ui/chrdlg/numpara.src
+../../sw/source/ui/config/mailconfigpage.src
+../../sw/source/ui/config/optcomp.src
+../../sw/source/ui/config/optdlg.src
+../../sw/source/ui/config/optload.src
+../../sw/source/ui/config/redlopt.src
+../../sw/source/ui/dialog/abstract.src
+../../sw/source/ui/dialog/docstdlg.src
+../../sw/source/ui/dialog/ascfldlg.src
+../../sw/source/ui/dialog/dialog.src
+../../sw/source/ui/dialog/regionsw.src
+../../sw/source/ui/dialog/wordcountdialog.src
+../../sw/source/ui/dochdl/dochdl.src
+../../sw/source/ui/dochdl/selglos.src
+../../sw/source/ui/envelp/mailmrge.src
+../../sw/source/ui/envelp/envelp.src
+../../sw/source/ui/envelp/labprt.src
+../../sw/source/ui/envelp/envlop.src
+../../sw/source/ui/envelp/label.src
+../../sw/source/ui/envelp/envfmt.src
+../../sw/source/ui/envelp/labfmt.src
+../../sw/source/ui/envelp/envprt.src
+../../sw/source/ui/smartmenu/stmenu.src
+../../sw/source/ui/frmdlg/frmpage.src
+../../sw/source/ui/frmdlg/cption.src
+../../sw/source/ui/frmdlg/column.src
+../../sw/source/ui/frmdlg/wrap.src
+../../sw/source/ui/frmdlg/frmui.src
+../../sw/source/ui/globdoc/globdoc.src
+../../sw/source/ui/ribbar/tbxanchr.src
+../../sw/source/ui/ribbar/workctrl.src
+../../sw/source/ui/ribbar/inputwin.src
+../../sw/source/ui/ribbar/tblctrl.src
+../../sw/source/ui/shells/shells.src
+../../sw/source/ui/uiview/pview.src
+../../sw/source/ui/uiview/view.src
+../../sw/source/core/undo/undo.src
diff --git a/layout/src2xml/src.lst b/layout/src2xml/src.lst
new file mode 100644
index 0000000..5375af0
--- /dev/null
+++ layout/src2xml/src.lst
@@ -0,0 +1,696 @@
+../../sc/util/hidother.src
+../../sc/addin/datefunc/dfa.src
+../../sc/addin/rot13/rot13.src
+../../sc/source/ui/src/crnrdlg.src
+../../sc/source/ui/src/hdrcont.src
+../../sc/source/ui/src/solvrdlg.src
+../../sc/source/ui/src/miscdlgs.src
+../../sc/source/ui/src/tabopdlg.src
+../../sc/source/ui/src/popup.src
+../../sc/source/ui/src/autofmt.src
+../../sc/source/ui/src/toolbox.src
+../../sc/source/ui/src/opredlin.src
+../../sc/source/ui/src/namedlg.src
+../../sc/source/ui/src/sortdlg.src
+../../sc/source/ui/src/textdlgs.src
+../../sc/source/ui/src/optdlg.src
+../../sc/source/ui/src/scwarngs.src
+../../sc/source/ui/src/scfuncs.src
+../../sc/source/ui/src/filter.src
+../../sc/source/ui/src/simpref.src
+../../sc/source/ui/src/attrdlg.src
+../../sc/source/ui/src/sc.src
+../../sc/source/ui/src/globstr.src
+../../sc/source/ui/src/scstring.src
+../../sc/source/ui/src/dbnamdlg.src
+../../sc/source/ui/src/subtdlg.src
+../../sc/source/ui/src/pseudo.src
+../../sc/source/ui/src/condfrmt.src
+../../sc/source/ui/src/scerrors.src
+../../sc/source/ui/dbgui/outline.src
+../../sc/source/ui/dbgui/pvfundlg.src
+../../sc/source/ui/dbgui/scendlg.src
+../../sc/source/ui/dbgui/pivot.src
+../../sc/source/ui/dbgui/dpgroupdlg.src
+../../sc/source/ui/dbgui/dapitype.src
+../../sc/source/ui/dbgui/imoptdlg.src
+../../sc/source/ui/dbgui/consdlg.src
+../../sc/source/ui/dbgui/validate.src
+../../sc/source/ui/dbgui/asciiopt.src
+../../sc/source/ui/drawfunc/objdraw.src
+../../sc/source/ui/drawfunc/drformsh.src
+../../sc/source/ui/styleui/scstyles.src
+../../sc/source/ui/styleui/styledlg.src
+../../sc/source/ui/formdlg/parawin.src
+../../sc/source/ui/formdlg/dwfunctr.src
+../../sc/source/ui/formdlg/formdlgs.src
+../../sc/source/ui/navipi/navipi.src
+../../sc/source/ui/miscdlgs/acredlin.src
+../../sc/source/ui/miscdlgs/highred.src
+../../sc/source/ui/miscdlgs/linkarea.src
+../../sc/source/ui/miscdlgs/instbdlg.src
+../../sc/source/ui/pagedlg/pagedlg.src
+../../sc/source/ui/pagedlg/tphf.src
+../../sc/source/ui/pagedlg/hfedtdlg.src
+../../sc/source/ui/docshell/tpstat.src
+../../sc/source/core/src/compiler.src
+../../sd/util/hidother.src
+../../sd/source/ui/app/tbxids_tmpl.src
+../../sd/source/ui/app/popup2_tmpl.src
+../../sd/source/ui/app/popup.src
+../../sd/source/ui/app/toolbox.src
+../../sd/source/ui/app/menuids2_tmpl.src
+../../sd/source/ui/app/sdstring.src
+../../sd/source/ui/app/menu_tmpl.src
+../../sd/source/ui/app/strings.src
+../../sd/source/ui/app/menuids_tmpl.src
+../../sd/source/ui/app/accel_tmpl.src
+../../sd/source/ui/app/tbx_ww.src
+../../sd/source/ui/app/accelids_tmpl.src
+../../sd/source/ui/app/menuportal_tmpl.src
+../../sd/source/ui/app/menuids3_tmpl.src
+../../sd/source/ui/app/app.src
+../../sd/source/ui/app/res_bmp.src
+../../sd/source/ui/app/pseudo.src
+../../sd/source/ui/app/menuids4_tmpl.src
+../../sd/source/ui/app/toolbox2_tmpl.src
+../../sd/source/ui/dlg/headerfooterdlg.src
+../../sd/source/ui/dlg/dlgfield.src
+../../sd/source/ui/dlg/sdobjpal.src
+../../sd/source/ui/dlg/morphdlg.src
+../../sd/source/ui/dlg/PaneDockingWindow.src
+../../sd/source/ui/dlg/dlgsnap.src
+../../sd/source/ui/dlg/tpoption.src
+../../sd/source/ui/dlg/present.src
+../../sd/source/ui/dlg/sdpreslt.src
+../../sd/source/ui/dlg/dlgass.src
+../../sd/source/ui/dlg/tpaction.src
+../../sd/source/ui/dlg/prntopts.src
+../../sd/source/ui/dlg/prltempl.src
+../../sd/source/ui/dlg/custsdlg.src
+../../sd/source/ui/dlg/inspagob.src
+../../sd/source/ui/dlg/paragr.src
+../../sd/source/ui/dlg/dlgpage.src
+../../sd/source/ui/dlg/vectdlg.src
+../../sd/source/ui/dlg/dlgolbul.src
+../../sd/source/ui/dlg/copydlg.src
+../../sd/source/ui/dlg/dlg_char.src
+../../sd/source/ui/dlg/printdlg.src
+../../sd/source/ui/dlg/animobjs.src
+../../sd/source/ui/dlg/ins_paste.src
+../../sd/source/ui/dlg/tabtempl.src
+../../sd/source/ui/dlg/LayerDialog.src
+../../sd/source/ui/dlg/masterlayoutdlg.src
+../../sd/source/ui/dlg/navigatr.src
+../../sd/source/ui/dlg/brkdlg.src
+../../sd/source/ui/slidesorter/shell/SlideSorterChildWindow.src
+../../sd/source/ui/notes/NotesChildWindow.src
+../../sd/source/ui/toolpanel/ToolPanelChildWindow.src
+../../sd/source/ui/animations/CustomAnimationCreateDialog.src
+../../sd/source/ui/animations/CustomAnimationDialog.src
+../../sd/source/ui/animations/CustomAnimation.src
+../../sd/source/ui/animations/CustomAnimationSchemesPane.src
+../../sd/source/ui/animations/SlideTransitionPane.src
+../../sd/source/ui/animations/AnimationSchemesPane.src
+../../sd/source/ui/animations/CustomAnimationPane.src
+../../sd/source/ui/accessibility/accessibility.src
+../../sd/source/ui/slideshow/slideshow.src
+../../sd/source/core/glob.src
+../../sd/source/filter/html/pubdlg.src
+../../sw/sdi/swslots.src
+../../sw/util/hidother.src
+../../sw/source/ui/app/mn.src
+../../sw/source/ui/app/app.src
+../../sw/source/ui/app/error.src
+../../sw/source/ui/web/web.src
+../../sw/source/ui/dbui/addresslistdialog.src
+../../sw/source/ui/dbui/customizeaddresslistdialog.src
+../../sw/source/ui/dbui/mailmergewizard.src
+../../sw/source/ui/dbui/mmlayoutpage.src
+../../sw/source/ui/dbui/dbui.src
+../../sw/source/ui/dbui/createaddresslistdialog.src
+../../sw/source/ui/dbui/mmoutputpage.src
+../../sw/source/ui/dbui/dbtablepreviewdialog.src
+../../sw/source/ui/dbui/mmmergepage.src
+../../sw/source/ui/dbui/dbinsdlg.src
+../../sw/source/ui/dbui/selectdbtabledialog.src
+../../sw/source/ui/dbui/mmoutputtypepage.src
+../../sw/source/ui/dbui/mailmergechildwindow.src
+../../sw/source/ui/dbui/mmpreparemergepage.src
+../../sw/source/ui/dbui/mmdocselectpage.src
+../../sw/source/ui/dbui/mmgreetingspage.src
+../../sw/source/ui/dbui/mmaddressblockpage.src
+../../sw/source/ui/misc/linenum.src
+../../sw/source/ui/misc/outline.src
+../../sw/source/ui/misc/glosbib.src
+../../sw/source/ui/misc/pgfnote.src
+../../sw/source/ui/misc/redlndlg.src
+../../sw/source/ui/misc/glossary.src
+../../sw/source/ui/misc/numberingtypelistbox.src
+../../sw/source/ui/misc/autocorr.src
+../../sw/source/ui/misc/insfnote.src
+../../sw/source/ui/misc/srtdlg.src
+../../sw/source/ui/misc/num.src
+../../sw/source/ui/misc/pggrid.src
+../../sw/source/ui/misc/bookmark.src
+../../sw/source/ui/misc/docfnote.src
+../../sw/source/ui/misc/insrule.src
+../../sw/source/ui/docvw/docvw.src
+../../sw/source/ui/docvw/access.src
+../../sw/source/ui/fldui/javaedit.src
+../../sw/source/ui/fldui/fldref.src
+../../sw/source/ui/fldui/fldtdlg.src
+../../sw/source/ui/fldui/fldfunc.src
+../../sw/source/ui/fldui/flddok.src
+../../sw/source/ui/fldui/flddinf.src
+../../sw/source/ui/fldui/inpdlg.src
+../../sw/source/ui/fldui/flddb.src
+../../sw/source/ui/fldui/changedb.src
+../../sw/source/ui/fldui/fldvar.src
+../../sw/source/ui/fldui/DropDownFieldDialog.src
+../../sw/source/ui/fldui/fldui.src
+../../sw/source/ui/fmtui/tmpdlg.src
+../../sw/source/ui/fmtui/fmtui.src
+../../sw/source/ui/index/cnttab.src
+../../sw/source/ui/index/multmrk.src
+../../sw/source/ui/index/idxmrk.src
+../../sw/source/ui/lingu/olmenu.src
+../../sw/source/ui/table/colwd.src
+../../sw/source/ui/table/rowht.src
+../../sw/source/ui/table/tautofmt.src
+../../sw/source/ui/table/splittbl.src
+../../sw/source/ui/table/chartins.src
+../../sw/source/ui/table/tabledlg.src
+../../sw/source/ui/table/split.src
+../../sw/source/ui/table/convert.src
+../../sw/source/ui/table/insrc.src
+../../sw/source/ui/table/table.src
+../../sw/source/ui/table/mergetbl.src
+../../sw/source/ui/table/instable.src
+../../sw/source/ui/utlui/utlui.src
+../../sw/source/ui/utlui/initui.src
+../../sw/source/ui/utlui/navipi.src
+../../sw/source/ui/utlui/attrdesc.src
+../../sw/source/ui/utlui/gloslst.src
+../../sw/source/ui/utlui/poolfmt.src
+../../sw/source/ui/utlui/unotools.src
+../../sw/source/ui/wrtsh/wrtsh.src
+../../sw/source/ui/chrdlg/chardlg.src
+../../sw/source/ui/chrdlg/swbreak.src
+../../sw/source/ui/chrdlg/ccoll.src
+../../sw/source/ui/chrdlg/paradlg.src
+../../sw/source/ui/chrdlg/drpcps.src
+../../sw/source/ui/chrdlg/chrdlg.src
+../../sw/source/ui/chrdlg/numpara.src
+../../sw/source/ui/config/mailconfigpage.src
+../../sw/source/ui/config/optcomp.src
+../../sw/source/ui/config/optdlg.src
+../../sw/source/ui/config/optload.src
+../../sw/source/ui/config/redlopt.src
+../../sw/source/ui/dialog/abstract.src
+../../sw/source/ui/dialog/docstdlg.src
+../../sw/source/ui/dialog/ascfldlg.src
+../../sw/source/ui/dialog/dialog.src
+../../sw/source/ui/dialog/regionsw.src
+../../sw/source/ui/dialog/wordcountdialog.src
+../../sw/source/ui/dochdl/dochdl.src
+../../sw/source/ui/dochdl/selglos.src
+../../sw/source/ui/envelp/mailmrge.src
+../../sw/source/ui/envelp/envelp.src
+../../sw/source/ui/envelp/labprt.src
+../../sw/source/ui/envelp/envlop.src
+../../sw/source/ui/envelp/label.src
+../../sw/source/ui/envelp/envfmt.src
+../../sw/source/ui/envelp/labfmt.src
+../../sw/source/ui/envelp/envprt.src
+../../sw/source/ui/smartmenu/stmenu.src
+../../sw/source/ui/frmdlg/frmpage.src
+../../sw/source/ui/frmdlg/cption.src
+../../sw/source/ui/frmdlg/column.src
+../../sw/source/ui/frmdlg/wrap.src
+../../sw/source/ui/frmdlg/frmui.src
+../../sw/source/ui/globdoc/globdoc.src
+../../sw/source/ui/ribbar/tbxanchr.src
+../../sw/source/ui/ribbar/workctrl.src
+../../sw/source/ui/ribbar/inputwin.src
+../../sw/source/ui/ribbar/tblctrl.src
+../../sw/source/ui/shells/shells.src
+../../sw/source/ui/uiview/pview.src
+../../sw/source/ui/uiview/view.src
+../../sw/source/core/undo/undo.src
+../../sch/util/hidother.src
+../../sch/source/ui/app/res_hc_bmp.src
+../../sch/source/ui/app/menu_tmpl.src
+../../sch/source/ui/app/strings.src
+../../sch/source/ui/app/menuids_tmpl.src
+../../sch/source/ui/app/app.src
+../../sch/source/ui/app/res_bmp.src
+../../sch/source/ui/dlg/axisgrid.src
+../../sch/source/ui/dlg/attrib2.src
+../../sch/source/ui/dlg/attrib3.src
+../../sch/source/ui/dlg/attrib4.src
+../../sch/source/ui/dlg/tpappopt.src
+../../sch/source/ui/dlg/tplabel.src
+../../sch/source/ui/dlg/attrib.src
+../../sch/source/ui/dlg/title.src
+../../sch/source/ui/dlg/lightdlg.src
+../../sch/source/ui/dlg/viewdlg.src
+../../sch/source/ui/dlg/dgrdata.src
+../../sch/source/ui/dlg/dlggraut.src
+../../sch/source/ui/dlg/tpscaley.src
+../../sch/source/ui/dlg/datdescr.src
+../../sch/source/ui/dlg/legend.src
+../../sch/source/ui/dlg/diagrtyp.src
+../../sch/source/ui/dlg/datstat.src
+../../sch/source/core/glob.src
+../../so3/src/svuidlg.src
+../../so3/src/formats.src
+../../so3/src/nocode.src
+../../so3/util/hidother.src
+../../so3/workben/ddetest/ddetest.src
+../../so3/workben/paintdlg.src
+../../so3/workben/svser.src
+../../so3/workben/paint.src
+../../svx/util/hidother.src
+../../svx/source/src/app.src
+../../svx/source/form/fmstring.src
+../../svx/source/form/filtnav.src
+../../svx/source/form/fmexpl.src
+../../svx/source/form/fmsearch.src
+../../svx/source/form/tbxform.src
+../../svx/source/form/formshell.src
+../../svx/source/form/datanavi.src
+../../svx/source/intro/ooo.src
+../../svx/source/intro/iso.src
+../../svx/source/items/svxitems.src
+../../svx/source/items/svxerr.src
+../../svx/source/editeng/editeng.src
+../../svx/source/accessibility/accessibility.src
+../../svx/source/mnuctrls/mnuctrls.src
+../../svx/source/engine3d/float3d.src
+../../svx/source/engine3d/string3d.src
+../../svx/source/dialog/textanim.src
+../../svx/source/dialog/hyperdlg.src
+../../svx/source/dialog/textattr.src
+../../svx/source/dialog/tabarea.src
+../../svx/source/dialog/rubydialog.src
+../../svx/source/dialog/frmdirlbox.src
+../../svx/source/dialog/chardlg.src
+../../svx/source/dialog/numfmt.src
+../../svx/source/dialog/doclinkdialog.src
+../../svx/source/dialog/treeopt.src
+../../svx/source/dialog/page.src
+../../svx/source/dialog/opthtml.src
+../../svx/source/dialog/frmsel.src
+../../svx/source/dialog/ruler.src
+../../svx/source/dialog/optgdlg.src
+../../svx/source/dialog/fontwork.src
+../../svx/source/dialog/backgrnd.src
+../../svx/source/dialog/SpellDialog.src
+../../svx/source/dialog/labdlg.src
+../../svx/source/dialog/charmap.src
+../../svx/source/dialog/zoom.src
+../../svx/source/dialog/border.src
+../../svx/source/dialog/svuidlg.src
+../../svx/source/dialog/impgrf.src
+../../svx/source/dialog/dlgname.src
+../../svx/source/dialog/test.src
+../../svx/source/dialog/selector.src
+../../svx/source/dialog/optupdt.src
+../../svx/source/dialog/numpages.src
+../../svx/source/dialog/thesdlg.src
+../../svx/source/dialog/tabline.src
+../../svx/source/dialog/srchdlg.src
+../../svx/source/dialog/contdlg.src
+../../svx/source/dialog/paragrph.src
+../../svx/source/dialog/commonlingui.src
+../../svx/source/dialog/sdstring.src
+../../svx/source/dialog/optmemory.src
+../../svx/source/dialog/grfflt.src
+../../svx/source/dialog/langbox.src
+../../svx/source/dialog/bbdlg.src
+../../svx/source/dialog/hangulhanjadlg.src
+../../svx/source/dialog/txenctab.src
+../../svx/source/dialog/connpooloptions.src
+../../svx/source/dialog/dbregister.src
+../../svx/source/dialog/macropg.src
+../../svx/source/dialog/fontsubs.src
+../../svx/source/dialog/align.src
+../../svx/source/dialog/hyprlink.src
+../../svx/source/dialog/imapdlg.src
+../../svx/source/dialog/dlgctrl.src
+../../svx/source/dialog/tabstpge.src
+../../svx/source/dialog/readonlyimage.src
+../../svx/source/dialog/docrecovery.src
+../../svx/source/dialog/hlmarkwn.src
+../../svx/source/dialog/internationaloptions.src
+../../svx/source/dialog/optjava.src
+../../svx/source/dialog/language.src
+../../svx/source/dialog/hdft.src
+../../svx/source/dialog/lingu.src
+../../svx/source/dialog/grfpage.src
+../../svx/source/dialog/iconcdlg.src
+../../svx/source/dialog/swframeposstrings.src
+../../svx/source/dialog/connect.src
+../../svx/source/dialog/bmpmask.src
+../../svx/source/dialog/postdlg.src
+../../svx/source/dialog/checklbx.src
+../../svx/source/dialog/autocdlg.src
+../../svx/source/dialog/measure.src
+../../svx/source/dialog/cfg.src
+../../svx/source/dialog/scriptdlg.src
+../../svx/source/dialog/langtab.src
+../../svx/source/dialog/srchxtra.src
+../../svx/source/dialog/ctredlin.src
+../../svx/source/dialog/passwd.src
+../../svx/source/dialog/transfrm.src
+../../svx/source/dialog/optfltr.src
+../../svx/source/dialog/prtqry.src
+../../svx/source/dialog/eventdlg.src
+../../svx/source/dialog/hyphen.src
+../../svx/source/dialog/swpossizetabpage.src
+../../svx/source/dialog/dstribut.src
+../../svx/source/svxlink/linkmgr.src
+../../svx/source/fmcomp/gridctrl.src
+../../svx/source/fmcomp/showcols.src
+../../svx/source/outliner/outliner.src
+../../svx/source/unodraw/unodraw.src
+../../svx/source/svdraw/svdstr.src
+../../svx/source/stbctrls/stbctrls.src
+../../svx/source/unodialogs/textconversiondlgs/chinese_translationdialog.src
+../../svx/source/unodialogs/textconversiondlgs/chinese_dictionarydialog.src
+../../svx/source/toolbars/fontworkbar.src
+../../svx/source/toolbars/extrusionbar.src
+../../svx/source/options/optlingu.src
+../../svx/source/options/optasian.src
+../../svx/source/options/optdict.src
+../../svx/source/options/optinet2.src
+../../svx/source/options/optspell.src
+../../svx/source/options/optsave.src
+../../svx/source/options/optgrid.src
+../../svx/source/options/multipat.src
+../../svx/source/options/optcolor.src
+../../svx/source/options/optpath.src
+../../svx/source/options/optctl.src
+../../svx/source/options/optaccessibility.src
+../../svx/source/options/optjsearch.src
+../../svx/source/options/optgenrl.src
+../../svx/source/gallery2/gallery.src
+../../svx/source/gallery2/galtheme.src
+../../svx/source/tbxctrls/extrusioncontrols.src
+../../svx/source/tbxctrls/tbcontrl.src
+../../svx/source/tbxctrls/fontworkgallery.src
+../../svx/source/tbxctrls/lboxctrl.src
+../../svx/source/tbxctrls/linectrl.src
+../../svx/source/tbxctrls/tbxdraw.src
+../../svx/source/tbxctrls/grafctrl.src
+../../svx/source/tbxctrls/colrctrl.src
+../../vcl/source/src/menu.src
+../../vcl/source/src/stdtext.src
+../../vcl/source/src/images.src
+../../vcl/source/src/helptext.src
+../../vcl/source/src/btntext.src
+../../vcl/source/src/units.src
+../../uui/source/passworderrs.src
+../../uui/source/logindlg.src
+../../uui/source/passworddlg.src
+../../uui/source/ids.src
+../../uui/source/masterpassworddlg.src
+../../uui/source/passcrtdlg.src
+../../uui/source/cookiedg.src
+../../uui/source/fltdlg.src
+../../uui/source/masterpasscrtdlg.src
+../../dbaccess/util/hidother.src
+../../dbaccess/source/ui/app/app.src
+../../dbaccess/source/ui/dlg/indexdialog.src
+../../dbaccess/source/ui/dlg/RelationDlg.src
+../../dbaccess/source/ui/dlg/queryfilter.src
+../../dbaccess/source/ui/dlg/AdvancedPageDlg.src
+../../dbaccess/source/ui/dlg/queryorder.src
+../../dbaccess/source/ui/dlg/dbadmin.src
+../../dbaccess/source/ui/dlg/dsselect.src
+../../dbaccess/source/ui/dlg/paramdialog.src
+../../dbaccess/source/ui/dlg/CollectionView.src
+../../dbaccess/source/ui/dlg/sqlmessage.src
+../../dbaccess/source/ui/dlg/UserAdmin.src
+../../dbaccess/source/ui/dlg/ConnectionPage.src
+../../dbaccess/source/ui/dlg/dlgattr.src
+../../dbaccess/source/ui/dlg/AutoControls.src
+../../dbaccess/source/ui/dlg/dlgsave.src
+../../dbaccess/source/ui/dlg/UserAdminDlg.src
+../../dbaccess/source/ui/dlg/directsql.src
+../../dbaccess/source/ui/dlg/dlgsize.src
+../../dbaccess/source/ui/dlg/AdabasStat.src
+../../dbaccess/source/ui/dlg/dbfindex.src
+../../dbaccess/source/ui/dlg/dbadminsetup.src
+../../dbaccess/source/ui/dlg/AdabasStatDlg.src
+../../dbaccess/source/ui/dlg/adtabdlg.src
+../../dbaccess/source/ui/dlg/dbadmin2.src
+../../dbaccess/source/ui/uno/dbinteraction.src
+../../dbaccess/source/ui/misc/WizardPages.src
+../../dbaccess/source/ui/misc/dbumiscres.src
+../../dbaccess/source/ui/control/undosqledit.src
+../../dbaccess/source/ui/control/TableGrantCtrl.src
+../../dbaccess/source/ui/control/tabletree.src
+../../dbaccess/source/ui/imagelists/dbimagelists.src
+../../dbaccess/source/ui/relationdesign/relation.src
+../../dbaccess/source/ui/tabledesign/table.src
+../../dbaccess/source/ui/querydesign/querydlg.src
+../../dbaccess/source/ui/querydesign/query.src
+../../dbaccess/source/ui/browser/bcommon.src
+../../dbaccess/source/ui/browser/sbagrid.src
+../../dbaccess/source/ui/browser/sbabrw.src
+../../dbaccess/source/core/resource/strings.src
+../../dbaccess/source/sdbtools/resource/sdbt_strings.src
+../../sfx2/util/hidother.src
+../../sfx2/source/doc/sfxbasemodel.src
+../../sfx2/source/doc/doctempl.src
+../../sfx2/source/doc/doc.src
+../../sfx2/source/doc/secmacrowarnings.src
+../../sfx2/source/doc/new.src
+../../sfx2/source/doc/docvor.src
+../../sfx2/source/doc/graphhelp.src
+../../sfx2/source/doc/doctdlg.src
+../../sfx2/source/appl/dde.src
+../../sfx2/source/appl/newhelp.src
+../../sfx2/source/appl/sfx.src
+../../sfx2/source/appl/app.src
+../../sfx2/source/menu/menu.src
+../../sfx2/source/view/view.src
+../../sfx2/source/bastyp/fltfnc.src
+../../sfx2/source/bastyp/bastyp.src
+../../sfx2/source/config/config.src
+../../sfx2/source/dialog/recfloat.src
+../../sfx2/source/dialog/templdlg.src
+../../sfx2/source/dialog/newstyle.src
+../../sfx2/source/dialog/dinfdlg.src
+../../sfx2/source/dialog/alienwarn.src
+../../sfx2/source/dialog/dinfedt.src
+../../sfx2/source/dialog/printopt.src
+../../sfx2/source/dialog/srchdlg.src
+../../sfx2/source/dialog/mailwindow.src
+../../sfx2/source/dialog/dialog.src
+../../sfx2/source/dialog/macropg.src
+../../sfx2/source/dialog/versdlg.src
+../../sfx2/source/dialog/mgetempl.src
+../../sfx2/source/dialog/filedlghelper.src
+../../sfx2/source/dialog/cfg.src
+../../sfx2/source/dialog/passwd.src
+../../framework/util/hidother.src
+../../framework/source/classes/resource.src
+../../desktop/util/hidother.src
+../../desktop/source/app/desktop.src
+../../desktop/source/deployment/gui/dp_gui_dependencydialog.src
+../../desktop/source/deployment/gui/dp_gui_backend.src
+../../desktop/source/deployment/gui/dp_gui_versionboxes.src
+../../desktop/source/deployment/gui/dp_gui_updatedialog.src
+../../desktop/source/deployment/gui/dp_gui_updateinstalldialog.src
+../../desktop/source/deployment/gui/dp_gui_dialog.src
+../../desktop/source/deployment/misc/dp_misc.src
+../../desktop/source/deployment/manager/dp_manager.src
+../../desktop/source/deployment/unopkg/unopkg.src
+../../desktop/source/deployment/registry/sfwk/dp_sfwk.src
+../../desktop/source/deployment/registry/component/dp_component.src
+../../desktop/source/deployment/registry/dp_registry.src
+../../desktop/source/deployment/registry/configuration/dp_configuration.src
+../../desktop/source/deployment/registry/script/dp_script.src
+../../desktop/source/deployment/registry/package/dp_package.src
+../../desktop/source/migration/migration.src
+../../desktop/source/migration/wizard.src
+../../basic/source/app/basic.src
+../../basic/source/app/ttmsg.src
+../../basic/source/app/svtmsg.src
+../../basic/source/app/testtool.src
+../../basic/source/app/basmsg.src
+../../basic/source/sbx/format.src
+../../basic/source/classes/sb.src
+../../basic/workben/basmgr.src
+../../forms/source/resource/xforms.src
+../../forms/source/resource/strings.src
+../../scaddins/source/datefunc/datefunc.src
+../../scaddins/source/analysis/analysis_deffuncnames.src
+../../scaddins/source/analysis/analysis.src
+../../scaddins/source/analysis/analysis_funcnames.src
+../../basctl/util/hidother.src
+../../basctl/source/dlged/dlgresid.src
+../../basctl/source/dlged/managelang.src
+../../basctl/source/basicide/tbxctl.src
+../../basctl/source/basicide/moptions.src
+../../basctl/source/basicide/macrodlg.src
+../../basctl/source/basicide/objdlg.src
+../../basctl/source/basicide/basidesh.src
+../../basctl/source/basicide/moduldlg.src
+../../basctl/source/basicide/brkdlg.src
+../../chart2/source/controller/menu/ContextMenu.src
+../../chart2/source/controller/menu/MainMenu.src
+../../chart2/source/controller/dialogs/tp_DataLabel.src
+../../chart2/source/controller/dialogs/Strings_ChartTypes.src
+../../chart2/source/controller/dialogs/dlg_InsertTitle.src
+../../chart2/source/controller/dialogs/Strings.src
+../../chart2/source/controller/dialogs/tp_SeriesStatistic.src
+../../chart2/source/controller/dialogs/dlg_InsertDataLabel.src
+../../chart2/source/controller/dialogs/Strings_Statistic.src
+../../chart2/source/controller/dialogs/dlg_InsertLegend.src
+../../chart2/source/controller/dialogs/dlg_RotateDiagram.src
+../../chart2/source/controller/dialogs/tp_PointGeometry.src
+../../chart2/source/controller/dialogs/dlg_ObjectProperties.src
+../../chart2/source/controller/dialogs/Bitmaps_HC.src
+../../chart2/source/controller/dialogs/tp_TitleRotation.src
+../../chart2/source/controller/dialogs/dlg_ChartType.src
+../../chart2/source/controller/dialogs/Bitmaps.src
+../../chart2/source/controller/dialogs/dlg_InsertStatistic.src
+../../chart2/source/controller/dialogs/Strings_Scale.src
+../../chart2/source/controller/dialogs/tp_LegendPosition.src
+../../chart2/source/controller/dialogs/dlg_InsertAxis_Grid.src
+../../chart2/source/controller/dialogs/tp_AxisLabel.src
+../../chart2/source/controller/dialogs/tp_SeriesToAxis.src
+../../chart2/source/controller/dialogs/tp_Scale.src
+../../scsolver/source/ui/scsolver.src
+../../automation/source/miniapp/servres.src
+../../svtools/util/hidother.src
+../../svtools/bmpmaker/bmp.src
+../../svtools/source/uno/unoifac2.src
+../../svtools/source/java/javaerror.src
+../../svtools/source/java/patchjavaerror.src
+../../svtools/source/misc/imagemgr.src
+../../svtools/source/misc/iniman.src
+../../svtools/source/misc/config.src
+../../svtools/source/misc/errtxt.src
+../../svtools/source/misc/ehdl.src
+../../svtools/source/misc/helpagent.src
+../../svtools/source/control/ctrlbox.src
+../../svtools/source/control/ctrltool.src
+../../svtools/source/control/calendar.src
+../../svtools/source/control/filectrl.src
+../../svtools/source/dialogs/colrdlg.src
+../../svtools/source/dialogs/addresstemplate.src
+../../svtools/source/dialogs/prnsetup.src
+../../svtools/source/dialogs/formats.src
+../../svtools/source/dialogs/filedlg2.src
+../../svtools/source/dialogs/so3res.src
+../../svtools/source/dialogs/printdlg.src
+../../svtools/source/dialogs/logindlg.src
+../../svtools/source/dialogs/wizardmachine.src
+../../svtools/source/misc1/mediatyp.src
+../../svtools/source/brwbox/editbrowsebox.src
+../../svtools/source/contnr/fileview.src
+../../svtools/source/contnr/svcontnr.src
+../../svtools/source/contnr/templwin.src
+../../svtools/source/items1/cstitem.src
+../../svtools/source/filter.vcl/filter/dlgepng.src
+../../svtools/source/filter.vcl/filter/dlgexpor.src
+../../svtools/source/filter.vcl/filter/dlgejpg.src
+../../svtools/source/filter.vcl/filter/strings.src
+../../svtools/source/Accessibility/accessiblelistboxentry.src
+../../svtools/source/productregistration/registrationdlg.src
+../../svtools/source/plugapp/commtest.src
+../../svtools/source/plugapp/testtool.src
+../../fpicker/source/office/OfficeFilePicker.src
+../../fpicker/source/office/iodlg.src
+../../filter/source/pdf/impdialog.src
+../../filter/source/pdf/pdf.src
+../../filter/source/t602/t602filter.src
+../../filter/source/flash/impswfdialog.src
+../../filter/source/xsltdialog/xmlfiltertabdialog.src
+../../filter/source/xsltdialog/xmlfiltersettingsdialog.src
+../../filter/source/xsltdialog/xmlfileview.src
+../../filter/source/xsltdialog/xmlfilterdialogstrings.src
+../../filter/source/xsltdialog/hidother.src
+../../filter/source/xsltdialog/xmlfiltertabpagexslt.src
+../../filter/source/xsltdialog/xmlfiltertestdialog.src
+../../filter/source/xsltdialog/xmlfiltertabpagebasic.src
+../../toolkit/source/awt/accessiblestrings.src
+../../toolkit/source/awt/xthrobber.src
+../../xmlsecurity/source/dialogs/warnings.src
+../../xmlsecurity/source/dialogs/macrosecurity.src
+../../xmlsecurity/source/dialogs/certificatechooser.src
+../../xmlsecurity/source/dialogs/digitalsignaturesdialog.src
+../../xmlsecurity/source/dialogs/certificateviewer.src
+../../xmlsecurity/source/component/warnbox.src
+../../padmin/source/rtsetup.src
+../../padmin/source/padialog.src
+../../goodies/source/inv/strings.src
+../../goodies/source/inv/gegner.src
+../../goodies/source/filter.vcl/eps/epsstr.src
+../../goodies/source/filter.vcl/eps/dlgeps.src
+../../goodies/source/filter.vcl/egif/dlgegif.src
+../../goodies/source/filter.vcl/egif/egifstr.src
+../../goodies/source/filter.vcl/epbm/dlgepbm.src
+../../goodies/source/filter.vcl/epbm/epbmstr.src
+../../goodies/source/filter.vcl/epgm/dlgepgm.src
+../../goodies/source/filter.vcl/epgm/epgmstr.src
+../../goodies/source/filter.vcl/eppm/dlgeppm.src
+../../goodies/source/filter.vcl/eppm/eppmstr.src
+../../goodies/source/filter.vcl/epict/dlgepct.src
+../../goodies/source/filter.vcl/epict/epictstr.src
+../../goodies/source/filter.vcl/eos2met/dlgeos2.src
+../../goodies/source/filter.vcl/eos2met/eos2mstr.src
+../../ucbhelper/workben/ucbexplorer/ucbexplorer.src
+../../starmath/util/hidother.src
+../../starmath/source/commands.src
+../../starmath/source/symbol.src
+../../starmath/source/menu_tmpl.src
+../../starmath/source/smres.src
+../../extensions/qa/complex/extensions/orl_de.src
+../../extensions/qa/complex/extensions/orl_en-US.src
+../../extensions/util/hidother.src
+../../extensions/source/bibliography/menu.src
+../../extensions/source/bibliography/toolbar.src
+../../extensions/source/bibliography/datman.src
+../../extensions/source/bibliography/sections.src
+../../extensions/source/bibliography/hidother.src
+../../extensions/source/bibliography/bib.src
+../../extensions/source/scanner/grid.src
+../../extensions/source/scanner/sanedlg.src
+../../extensions/source/dbpilots/dbpilots.src
+../../extensions/source/dbpilots/gridpages.src
+../../extensions/source/dbpilots/listcombopages.src
+../../extensions/source/dbpilots/groupboxpages.src
+../../extensions/source/dbpilots/commonpagesdbp.src
+../../extensions/source/abpilot/abspilot.src
+../../extensions/source/update/ui/updatecheckui.src
+../../extensions/source/propctrlr/taborder.src
+../../extensions/source/propctrlr/listselectiondlg.src
+../../extensions/source/propctrlr/formlinkdialog.src
+../../extensions/source/propctrlr/fontdialog.src
+../../extensions/source/propctrlr/selectlabeldialog.src
+../../extensions/source/propctrlr/pcrmiscres.src
+../../extensions/source/propctrlr/formres.src
+../../extensions/source/propctrlr/newdatatype.src
+../../extensions/source/propctrlr/propres.src
+../../extensions/source/preload/preload.src
+../../extensions/workben/testresource.src
+../../avmedia/util/hidother.src
+../../avmedia/source/framework/mediacontrol.src
+../../avmedia/source/viewer/mediawindow.src
+../../connectivity/source/resource/conn_shared_res.src
+../../connectivity/source/drivers/hsqldb/hsqlui.src
+../../scripting/source/runtimemgr/ScriptExecDialog.src
+../../wizards/util/hidother.src
+../../wizards/source/euro/euro.src
+../../wizards/source/imagelists/imagelists.src
+../../wizards/source/webwizard/webwizar.src
+../../wizards/source/template/template.src
+../../wizards/source/schedule/schedule.src
+../../wizards/source/importwizard/importwi.src
+../../wizards/source/formwizard/dbwizres.src
diff --git a/layout/src2xml/sw.sh b/layout/src2xml/sw.sh
new file mode 100755
index 0000000..22f16d4
--- /dev/null
+++ layout/src2xml/sw.sh
@@ -0,0 +1,3 @@
+#! /bin/bash
+
+source/src2xml.py --include-path=$(tr '\n' ':' < include-sw.lst) --dry-run $(cat src-sw.lst) "$@"
diff --git a/layout/util/makefile.mk b/layout/util/makefile.mk
new file mode 100644
index 0000000..8e215fc
--- /dev/null
+++ layout/util/makefile.mk
@@ -0,0 +1,35 @@
+PRJ=..
+PRJNAME=layout
+TARGET=layout
+TARGETTYPE=GUI
+VERSION=$(UPD)
+ENABLE_EXCEPTIONS=TRUE
+
+.INCLUDE : settings.mk
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+LIB1FILES= \
+	$(SLB)$/awt.lib \
+	$(SLB)$/core.lib \
+	$(SLB)$/wrapper.lib
+LIB1TARGET= $(SLB)$/$(TARGET).lib
+SHL1TARGET= $(TARGET)$(UPD)$(DLLPOSTFIX)
+SHL1IMPLIB= i$(TARGET)
+# SHL1USE_EXPORTS=ordinal
+
+SHL1LIBS= $(LIB1TARGET)
+SHL1STDLIBS=  \
+	$(UNOTOOLSLIB) \
+	$(TKLIB) \
+	$(TOOLSLIB) \
+	$(COMPHELPERLIB) \
+	$(VCLLIB) \
+	$(CPPULIB) \
+	$(CPPUHELPERLIB) \
+	$(SALLIB)
+
+# SHL1DEF= $(MISC)$/$(SHL1TARGET).def
+# DEF1NAME= $(SHL1TARGET)
+# DEFLIB1NAME=$(TARGET)
+
+.INCLUDE :	target.mk
diff --git a/layout/util/makefile.pmk b/layout/util/makefile.pmk
new file mode 100644
index 0000000..c904c51
--- /dev/null
+++ layout/util/makefile.pmk
@@ -0,0 +1,5 @@
+CFLAGS+=-DENABLE_LAYOUT=1 -DTEST_LAYOUT=1
+
+.IF "$(COMNAME)" == "gcc3"
+CFLAGS+=-Wall -Wno-non-virtual-dtor
+.ENDIF
diff --git a/layout/workben/.gitignore b/layout/workben/.gitignore
new file mode 100644
index 0000000..e89ac98
--- /dev/null
+++ layout/workben/.gitignore
@@ -0,0 +1 @@
+core.*
diff --git a/layout/workben/adjust.xml b/layout/workben/adjust.xml
new file mode 100644
index 0000000..59439da
--- /dev/null
+++ layout/workben/adjust.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+	id="window1" title="Text Editor" optimumsize="true"
+	has_border="true" sizeable="true" moveable="true">
+    <vbox>
+	<!-- Ver Top -->
+	<hbox>
+	    <align v-align="0" h-align="0" v-fill="0" h-fill="0">
+		<pushbutton label="Top Left" />
+	    </align>
+	    <align>
+		<pushbutton label="Top Middle" v-align="0" h-align="0.5" v-fill="0" h-fill="0" />
+	    </align>
+	    <align>
+		<pushbutton label="Top Right" v-align="0" h-align="1" v-fill="0" h-fill="0" />
+	    </align>
+	</hbox>
+	<!-- Ver Middle -->
+	<hbox>
+	    <align>
+		<pushbutton label="Middle Left" v-align="0.5" h-align="0" v-fill="0" h-fill="0" />
+	    </align>
+	    <align>
+		<pushbutton label="Middle Middle" v-align="0.5" h-align="0.5" v-fill="0" h-fill="0" />
+	    </align>
+	    <align>
+		<pushbutton label="Middle Right" v-align="0.5" h-align="1" v-fill="0" h-fill="0" />
+	    </align>
+	</hbox>
+	<!-- Ver Bottom -->
+	<hbox>
+	    <align>
+		<pushbutton label="Bottom Left" v-align="1" h-align="0" v-fill="0" h-fill="0" />
+	    </align>
+	    <align>
+		<pushbutton label="Bottom Middle" v-align="1" h-align="0.5" v-fill="0" h-fill="0" />
+	    </align>
+	    <align>
+		<pushbutton label="Bottom Right" v-align="1" h-align="1" v-fill="0" h-fill="0" />
+	    </align>
+	</hbox>
+    </vbox>
+</dialog>
diff --git a/layout/workben/align.xml b/layout/workben/align.xml
new file mode 100644
index 0000000..1da5d36
--- /dev/null
+++ layout/workben/align.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+        xmlns:cnt="http://openoffice.org/2007/layout/container"
+        title="Align Test" optimumsize="true" has_border="true" sizeable="true" moveable="true">
+    <vbox>
+	<!-- Ver Top -->
+	<hbox>
+	    <align halign="0" valign="0">
+		<pushbutton label="Top Left" />
+	    </align>
+	    <align halign="0.5" valign="0">
+		<pushbutton label="Top Middle"  />
+	    </align>
+	    <align halign="1" valign="0">
+		<pushbutton label="Top Right"  />
+	    </align>
+	</hbox>
+	<!-- Ver Middle -->
+	<hbox>
+	    <align halign="0" valign="0.5">
+		<pushbutton label="Middle Left" />
+	    </align>
+	    <align halign="0.5" valign="0.5">
+		<pushbutton label="Middle Middle" />
+	    </align>
+	    <align halign="1" valign="0.5">
+		<pushbutton label="Middle Right" />
+	    </align>
+	</hbox>
+	<!-- Ver Bottom -->
+	<hbox>
+	    <align halign="0" valign="1">
+		<pushbutton label="Bottom Left" />
+	    </align>
+	    <align halign="0.5" valign="1">
+		<pushbutton label="Bottom Middle" />
+	    </align>
+	    <align halign="1" valign="1">
+		<pushbutton label="Bottom Right" />
+	    </align>
+	</hbox>
+    </vbox>
+</dialog>
diff --git a/layout/workben/boxtest.xml b/layout/workben/boxtest.xml
new file mode 100644
index 0000000..8015b3f
--- /dev/null
+++ layout/workben/boxtest.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+        xmlns:cnt="http://openoffice.org/2007/layout/container"
+        title="Box Test" optimumsize="true" has_border="true" sizeable="true" moveable="true">
+	<vbox>
+		<hbox cnt:expand="false" cnt:fill="false">
+			<pushbutton label="XML Left"
+			            cnt:expand="false" cnt:fill="false"/>
+	        <pushbutton label="XML Middle"
+	                            cnt:expand="true" cnt:fill="false"/>
+	        <pushbutton label="XML Right"
+	                            cnt:expand="true" cnt:fill="true"/>
+	        </hbox>
+		<hbox cnt:expand="true" cnt:fill="false">
+			<pushbutton label="XML Left"
+			            cnt:expand="false" cnt:fill="false"/>
+	                <pushbutton label="XML Middle"
+	                            cnt:expand="true" cnt:fill="false"/>
+	                <pushbutton label="XML Right"
+	                            cnt:expand="true" cnt:fill="true"/>
+	        </hbox>
+		<hbox cnt:expand="true" cnt:fill="true">
+			<pushbutton label="XML Left"
+			            cnt:expand="false" cnt:fill="false"/>
+	                <pushbutton label="XML Middle"
+	                            cnt:expand="true" cnt:fill="false"/>
+	                <pushbutton label="XML Right"
+	                            cnt:expand="true" cnt:fill="true"/>
+	        </hbox>
+	</vbox>
+</dialog>
diff --git a/layout/workben/dialogbuttons-ok.xml b/layout/workben/dialogbuttons-ok.xml
new file mode 100644
index 0000000..5b6e123
--- /dev/null
+++ layout/workben/dialogbuttons-ok.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<modaldialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             id="dialog" title="Dialog Button Ordering" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true">
+    <vbox border="5" spacing="5">
+	<fixedline text="Platform default"/>
+	<dialogbuttonhbox border="5" spacing="5">
+	    <flow/>
+	    <okbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Alternate"/>
+	</dialogbuttonhbox>
+	<fixedline text="GNOME"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="gnome">
+	    <flow/>
+	    <okbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Alternate"/>
+	</dialogbuttonhbox>
+	<fixedline text="KDE"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="kde">
+	    <flow/>
+	    <okbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Alternate"/>
+	</dialogbuttonhbox>
+	<fixedline text="MacOS"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="macos">
+	    <flow/>
+	    <okbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Alternate"/>
+	</dialogbuttonhbox>
+	<fixedline text="Windows"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="windows">
+	    <flow/>
+	    <okbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Alternate"/>
+	</dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/layout/workben/dialogbuttons-reset.xml b/layout/workben/dialogbuttons-reset.xml
new file mode 100644
index 0000000..4f4b782
--- /dev/null
+++ layout/workben/dialogbuttons-reset.xml
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<modaldialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             id="dialog" title="Dialog Button Ordering" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true">
+    <vbox border="5" spacing="5">
+	<fixedline text="Platform default"/>
+	<dialogbuttonhbox border="5" spacing="5">
+	    <flow/>
+	    <okbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Alternate"/>
+	    <resetbutton/>
+	</dialogbuttonhbox>
+	<fixedline text="GNOME"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="gnome">
+	    <flow/>
+	    <okbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Alternate"/>
+	    <resetbutton/>
+	</dialogbuttonhbox>
+	<fixedline text="KDE"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="kde">
+	    <flow/>
+	    <okbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Alternate"/>
+	    <resetbutton/>
+	</dialogbuttonhbox>
+	<fixedline text="MacOS"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="macos">
+	    <flow/>
+	    <okbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Alternate"/>
+	    <resetbutton/>
+	</dialogbuttonhbox>
+	<fixedline text="Windows"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="windows">
+	    <flow/>
+	    <okbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Alternate"/>
+	    <resetbutton/>
+	</dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/layout/workben/dialogbuttons-save.xml b/layout/workben/dialogbuttons-save.xml
new file mode 100644
index 0000000..6361b79
--- /dev/null
+++ layout/workben/dialogbuttons-save.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<modaldialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             id="dialog" title="Dialog Button Ordering" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true">
+    <vbox border="5" spacing="5">
+	<fixedline text="Platform default"/>
+	<dialogbuttonhbox border="5" spacing="5">
+	    <flow/>
+	    <yesbutton label="~Save"/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Don't save"/>
+	</dialogbuttonhbox>
+	<fixedline text="GNOME"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="gnome">
+	    <flow/>
+	    <yesbutton label="~Save"/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Don't save"/>
+	</dialogbuttonhbox>
+	<fixedline text="KDE"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="kde">
+	    <flow/>
+	    <yesbutton label="~Save"/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Don't save"/>
+	</dialogbuttonhbox>
+	<fixedline text="MacOS"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="macos">
+	    <flow/>
+	    <yesbutton label="~Save"/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Don't save"/>
+	</dialogbuttonhbox>
+	<fixedline text="Windows"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="windows">
+	    <flow/>
+	    <yesbutton label="~Save"/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton label="~Don't save"/>
+	</dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/layout/workben/dialogbuttons-yes.xml b/layout/workben/dialogbuttons-yes.xml
new file mode 100644
index 0000000..9116bd9
--- /dev/null
+++ layout/workben/dialogbuttons-yes.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<modaldialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             id="dialog" title="Dialog Button Ordering" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true">
+    <vbox border="5" spacing="5">
+	<fixedline text="Platform default"/>
+	<dialogbuttonhbox border="5" spacing="5">
+	    <flow/>
+	    <yesbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton xlabel="~Alternate"/>
+	</dialogbuttonhbox>
+	<fixedline text="GNOME"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="gnome">
+	    <flow/>
+	    <yesbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton xlabel="~Alternate"/>
+	</dialogbuttonhbox>
+	<fixedline text="KDE"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="kde">
+	    <flow/>
+	    <yesbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton xlabel="~Alternate"/>
+	</dialogbuttonhbox>
+	<fixedline text="MacOS"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="macos">
+	    <flow/>
+	    <yesbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton xlabel="~Alternate"/>
+	</dialogbuttonhbox>
+	<fixedline text="Windows"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="windows">
+	    <flow/>
+	    <yesbutton/>
+	    <cancelbutton/>
+	    <helpbutton/>
+	    <nobutton xlabel="~Alternate"/>
+	</dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/layout/workben/editor-normal.xml b/layout/workben/editor-normal.xml
new file mode 100644
index 0000000..c2d2a59
--- /dev/null
+++ layout/workben/editor-normal.xml
@@ -0,0 +1,53 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!-- Would be cool to have others Editor layouts (e.g. Glade-like with
+     a window for each function). -->
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+        xmlns:cnt="http://openoffice.org/2007/layout/container"
+        id="dialog" title="Layout Editor" sizeable="true" >
+	<vbox>
+		<hbox>
+			<min-size min-width="120" cnt:expand="false">
+				<vbox>
+					<fixedtext label="Layout:" cnt:expand="false" />
+					<hbox>
+						<listbox id="layout-tree" has_border="true" />
+						<vbox cnt:expand="false">
+							<pushbutton id="layout-up-button" cnt:expand="false" />
+							<pushbutton id="layout-down-button" cnt:expand="false" />
+							<fixedtext cnt:expand="true" />
+							<pushbutton id="layout-remove-button" cnt:expand="false" />
+						</vbox>
+					</hbox>
+				</vbox>
+			</min-size>
+			<min-size min-width="120">
+				<vbox>
+					<fixedtext label="Preview:" cnt:expand="false" />
+					<vbox border="50">
+						<bin id="preview-box" />
+					</vbox>
+				</vbox>
+			</min-size>
+			<min-size min-width="120" cnt:expand="false">
+				<vbox>
+					<fixedtext label="Properties:" cnt:expand="false" />
+					<table id="properties-box" columns="3" />
+				</vbox>
+			</min-size>
+		</hbox>
+		<hfixedline cnt:expand="false" />
+		<vbox cnt:expand="false">
+			<fixedtext label="Create widgets:" cnt:expand="false" />
+			<flow id="create-widget" homogeneous="true" spacing="2" />
+			<fixedtext label="Create containers:" cnt:expand="false" />
+			<flow id="create-container" homogeneous="true" spacing="2" />
+		</vbox>
+		<hbox cnt:expand="false">
+			<vbox><fixedline /><fixedline /><fixedline /><fixedline /></vbox>
+<!--			<pushbutton id="import-button" label="Import..." cnt:expand="false"/>-->
+			<pushbutton id="export-button" label="Export (stdout)" cnt:expand="false"/>
+		</hbox>
+	</vbox>
+</dialog>
diff --git a/layout/workben/editor.cxx b/layout/workben/editor.cxx
new file mode 100644
index 0000000..bb1a743
--- /dev/null
+++ layout/workben/editor.cxx
@@ -0,0 +1,1876 @@
+#include "editor.hxx"
+
+#undef NDEBUG
+#include <assert.h>
+#include <stdio.h>
+
+#include <vector>
+#include <list>
+#include <rtl/strbuf.hxx>
+#include <rtl/ustrbuf.hxx>
+
+using namespace layout::css;
+
+using rtl::OUString;
+
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/awt/XWindowPeer.hpp>
+#include <com/sun/star/awt/XVclWindowPeer.hpp>
+#include <com/sun/star/awt/XLayoutConstrains.hpp>
+#include <com/sun/star/awt/XLayoutContainer.hpp>
+#include <com/sun/star/awt/WindowAttribute.hpp>
+
+#include <com/sun/star/awt/XToolkit.hpp>
+#include <toolkit/helper/property.hxx>
+
+#include <vcl/lstbox.h>
+
+// FIXME:
+//#define FILEDLG
+
+// somewhat of a hack unfortunately ...
+#include "../source/inc/layoutcore.hxx"
+#include "../source/core/root.hxx"
+#include "../source/core/helper.hxx"
+
+//** Utilities
+
+#define OUSTRING_CSTR( str ) \
+    rtl::OUStringToOString( str, RTL_TEXTENCODING_ASCII_US ).getStr()
+
+// TODO: automatically generated
+struct WidgetSpec {
+    const char *pLabel, *pName, *pIconName;
+    bool bIsContainer; };
+static const WidgetSpec WIDGETS_SPECS[] = {
+    { "Label",         "fixedtext"   , "sc_label.png",        false },
+    { "Button",        "pushbutton"  , "sc_pushbutton.png",   false },
+    { "Radio Button",  "radiobutton" , "sc_radiobutton.png",  false },
+    { "Check Box",     "checkbox"    , "sc_checkbox.png",     false },
+    { "Line Edit",     "edit"        , "sc_edit.png",         false },
+    { "Numeric Field", "numericfield", "sc_numericfield.png", false },
+    { "List Box                  ", "listbox"     , NULL,                  false },
+    // containers
+    { "Hor Box",       "hbox"        , NULL,                  true  },
+    { "Ver Box",       "vbox"        , NULL,                  true  },
+    { "Table",         "table"       , NULL,                  true  },
+    { "Alignment",     "align"       , NULL,                  true  },
+    { "Tab Control",   "tabcontrol"  , NULL,                  true  },
+    { "Hor Splitter",  "hsplitter"   , NULL,                  true  },
+    { "Ver Splitter",  "vsplitter"   , NULL,                  true  },
+    { "Scroller",      "scroller"    , NULL,                  true  },
+};
+const int WIDGETS_SPECS_LEN = sizeof (WIDGETS_SPECS) / sizeof (WidgetSpec);
+
+// TEMP: from helper
+namespace layoutimpl {
+
+    typedef std::list< std::pair< rtl::OUString, rtl::OUString > > PropList;
+
+    css::uno::Reference< css::awt::XLayoutConstrains >
+        createWidget( css::uno::Reference< css::awt::XToolkit > xToolkit,
+                      css::uno::Reference< css::uno::XInterface > xParent,
+                      const rtl::OUString &rName, long nProps, bool bToplevel );
+
+    uno::Any anyFromString (const rtl::OUString &value, const uno::Type &type);
+};
+
+using namespace layout;
+using namespace layoutimpl;
+namespace css = ::com::sun::star;
+
+static rtl::OUString anyToString (uno::Any value)
+{
+    try
+    {
+        switch (value.getValueTypeClass()) {
+            case uno::TypeClass_STRING:
+                return value.get<rtl::OUString>();
+            case uno::TypeClass_CONSTANT:
+                return rtl::OUString::valueOf (value.get<sal_Int32>());
+            case uno::TypeClass_LONG:
+                return rtl::OUString::valueOf (value.get<sal_Int64>());
+            case uno::TypeClass_SHORT:
+                // FIXME: seems broken
+                return rtl::OUString::valueOf ((sal_Int32) value.get<short>());
+
+            case uno::TypeClass_FLOAT:
+                return rtl::OUString::valueOf (value.get<float>());
+            case uno::TypeClass_DOUBLE:
+                return rtl::OUString::valueOf (value.get<double>());
+
+            case uno::TypeClass_BOOLEAN:
+            {
+                bool val = value.get<sal_Bool>();
+                return rtl::OUString( val ? "1" : "0", 1, RTL_TEXTENCODING_ASCII_US );
+/*                if ( val )
+                    return rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "true" ) );
+                else
+                    return rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "false" ) );*/
+            }
+            default:
+                break;
+        }
+    }
+    catch(...) {}
+    return rtl::OUString();
+}
+
+static inline long anyToNatural (uno::Any value)
+{ return anyToString( value ).toInt64(); }
+static inline double anyToDecimal (uno::Any value)
+{ return anyToString( value ).toDouble(); }
+
+/* XLayoutContainer/XLayoutConstrains are a bit of a hasle to work with.
+   Let's wrap them. */
+class Widget : public layoutimpl::LayoutWidget {
+friend class EditorRoot;
+
+    Widget *mpParent;
+    std::vector< Widget *> maChildren;
+    bool mbForeign;
+
+    rtl::OUString mrId;
+    rtl::OUString mrLabel, mrUnoName;
+
+// TODO: store original properties. And some property handling methods.
+    long mnOriAttrbs;
+    layoutimpl::PropList maOriProps, maOriChildProps;
+
+public:
+
+    // to be used to wrap the root
+    Widget( uno::Reference< awt::XLayoutConstrains > xImport, const char *label )
+    : mpParent( 0 ), mbForeign( true )
+    {
+        mxWidget = xImport;
+        mxContainer = uno::Reference< awt::XLayoutContainer >( mxWidget, uno::UNO_QUERY );
+
+        mrLabel = rtl::OUString( label, strlen( label ), RTL_TEXTENCODING_UTF8  );
+
+#if 0  /* obsolete */
+        // FIXME: this code is meant to import a XML file. Just use the importer,
+        // then pass the root widget. But information like the ID string is lost.
+        // So, this needs to be more closely tight to the importer.
+        uno::Sequence< uno::Reference< awt::XLayoutConstrains > > aChildren;
+        for ( int i = 0; i < aChildren.getLength(); i++ )
+        {
+            Widget *pChild = new Widget( aChildren[ i ], "---" );
+            maChildren.push_back( pChild );
+            pChild->mpParent = this;
+        }
+#endif
+    }
+
+    Widget( rtl::OUString id, uno::Reference< awt::XToolkit > xToolkit,
+            uno::Reference< awt::XLayoutContainer > xParent,
+            rtl::OUString unoName, long nAttrbs )
+    : mpParent( 0 ), mbForeign( false ), mrId( id ),
+      mnOriAttrbs( nAttrbs )
+    {
+    while ( xParent.is() && !uno::Reference< awt::XWindow >( xParent, uno::UNO_QUERY ).is() )
+    {
+        uno::Reference< awt::XLayoutContainer > xContainer( xParent, uno::UNO_QUERY );
+        assert( xContainer.is() );
+        xParent = uno::Reference< awt::XLayoutContainer >( xContainer->getParent(), uno::UNO_QUERY );
+    }
+
+        mxWidget = layoutimpl::createWidget( xToolkit, xParent, unoName, nAttrbs );
+        assert( mxWidget.is() );
+        mxContainer = uno::Reference< awt::XLayoutContainer >( mxWidget, uno::UNO_QUERY );
+
+        mrLabel = mrUnoName = unoName;
+        // try to get a nicer label for the widget
+        for ( int i = 0; i < WIDGETS_SPECS_LEN; i++ )
+            if ( unoName.equalsAscii( WIDGETS_SPECS[ i ].pName ) )
+            {
+                const char *label = WIDGETS_SPECS[ i ].pLabel;
+                mrLabel = rtl::OUString( label, strlen( label ), RTL_TEXTENCODING_UTF8  );
+                break;
+            }
+
+        // set default Text property
+        // TODO: disable editing of text fields, check boxes selected, etc...
+#if 0
+        uno::Reference< awt::XVclWindowPeer> xVclPeer( mxWidget, uno::UNO_QUERY )
+        if ( xVclPeer.is() ) // XVclWindowPeer ignores missing / incorrect properties 
+
+//FIXME: it looks odd on widgets like NumericField seeing text which is deleted
+// when you interact with it... We can avoid it for those widgets, by doing a getProp
+// of "Text" and check if it is empty or not.
+
+            xVclPeer->setProperty( rtl::OUString::createFromAscii( "Text" ),
+                uno::makeAny( rtl::OUString::createFromAscii( "new widget" ) ) );
+#endif
+
+        // store original properties
+        {
+            PropertyIterator it( this, WINDOW_PROPERTY );
+            while ( it.hasNext() )
+            {
+                beans::Property prop = it.next();
+                rtl::OUString name( prop.Name );
+                rtl::OUString value( getProperty( name, WINDOW_PROPERTY ) );
+fprintf(stderr, "original property: %s = %s\n", OUSTRING_CSTR(name), OUSTRING_CSTR(value));
+                std::pair< rtl::OUString, rtl::OUString > pair( name, value );
+                maOriProps.push_back( pair );
+            }
+        }
+
+    }
+
+    ~Widget()
+    {
+        for ( std::vector< Widget *>::const_iterator it = maChildren.begin();
+             it != maChildren.end(); it++ )
+            delete *it;
+        if ( !mbForeign )
+        {
+            uno::Reference< lang::XComponent > xComp( mxWidget, uno::UNO_QUERY );
+            if ( xComp.is() )
+                // some widgets, like our containers, don't implement this interface...
+                xComp->dispose();
+        }
+    }
+
+    uno::Reference< awt::XLayoutConstrains > impl()
+    {
+        return mxWidget;
+    }
+
+    // LayoutWidget
+    virtual bool addChild( LayoutWidget *pChild )
+    {
+        return addChild( static_cast< Widget * >( pChild ) );
+    }
+
+    virtual void setProperties( const PropList &rProps )
+    {
+//        maOriProps = rProps;
+        LayoutWidget::setProperties( rProps );
+    }
+
+    virtual void setChildProperties( LayoutWidget *pChild, const PropList &rProps )
+    {
+        maOriChildProps = rProps;        
+        LayoutWidget::setChildProperties( pChild, rProps );
+    }
+
+    // tree travel
+    Widget *up()
+    {
+        return mpParent;
+    }
+
+    Widget *down()
+    {
+        if ( maChildren.empty() )
+            return NULL;
+        return maChildren.front();
+    }
+
+    Widget *next()
+    {
+        if ( mpParent )
+        {
+            int pos = mpParent->getChildPos( this );
+            return mpParent->getChild( pos+1 );
+        }
+        return NULL;
+    }
+
+    Widget *prev()
+    {
+        if ( mpParent )
+        {
+            int pos = mpParent->getChildPos( this );
+            return mpParent->getChild( pos-1 );
+        }
+        return NULL;
+    }
+
+    // handle
+    bool addChild( Widget *pChild, int pos = 0xffff )
+    {
+        if ( !mxContainer.is() )
+            return false;
+
+        uno::Sequence< uno::Reference < awt::XLayoutConstrains > > aChildren;
+        aChildren = mxContainer->getChildren();
+        int nChildrenLen = aChildren.getLength();
+
+        // ugly, but let's check if the container is next to full...
+        try {
+            mxContainer->addChild( pChild->mxWidget );
+        }
+        catch( awt::MaxChildrenException ex ) {
+            return false;
+        }
+
+        if ( pos < nChildrenLen )
+        {  // if its on the middle, we need to make space for it
+            mxContainer->removeChild( pChild->mxWidget );
+            for ( int i = pos; i < nChildrenLen; i++ )
+                mxContainer->removeChild( aChildren[ i ] );
+            mxContainer->addChild( pChild->mxWidget );
+            for ( int i = pos; i < nChildrenLen; i++ )
+                mxContainer->addChild( aChildren[ i ] );
+            maChildren.insert( maChildren.begin()+pos, pChild );
+        }
+        else
+            maChildren.push_back( pChild );
+
+        assert( pChild->mpParent == NULL );
+        pChild->mpParent = this;
+
+        // store container props
+        {
+            pChild->maOriChildProps.clear();
+            PropertyIterator it( pChild, CONTAINER_PROPERTY );
+            while ( it.hasNext() )
+            {
+                beans::Property prop = it.next();
+                rtl::OUString name( prop.Name );
+                rtl::OUString value( pChild->getProperty( name, CONTAINER_PROPERTY ) );
+                std::pair< rtl::OUString, rtl::OUString > pair( name, value );
+                pChild->maOriChildProps.push_back( pair );
+            }
+        }
+
+        return true;
+    }
+
+    bool removeChild( Widget *pChild )
+    {
+        if ( !mxContainer.is() || pChild->mpParent != this )
+            return false;
+
+        mxContainer->removeChild( pChild->mxWidget );
+
+        unsigned int pos = getChildPos( pChild );
+        if ( pos < maChildren.size() )
+            maChildren.erase( maChildren.begin()+pos );
+        pChild->mpParent = NULL;
+
+        return true;
+    }
+
+    bool swapWithChild( Widget *pChild )
+    {
+        if ( !pChild->isContainer() )
+            return false;
+
+        // remove all child's childrens, and try to add them here
+        removeChild( pChild );
+
+        // keep a copy for failure
+        std::vector< Widget *> aChildren = maChildren;
+        std::vector< Widget *> aChildChildren = pChild->maChildren;
+
+        for ( std::vector< Widget *>::const_iterator it = aChildChildren.begin();
+             it != aChildChildren.end(); it++ )
+            pChild->removeChild( *it );
+
+        for ( std::vector< Widget *>::const_iterator it = aChildChildren.begin();
+             it != aChildChildren.end(); it++ )
+            if ( !addChild( *it ) )
+            {    // failure
+                for ( std::vector< Widget *>::const_iterator jt = aChildChildren.begin();
+                     jt != it; jt++ )
+                    removeChild( *jt );
+                for ( std::vector< Widget *>::const_iterator jt = aChildChildren.begin();
+                     jt != aChildChildren.end(); jt++ )
+                    pChild->addChild( *jt );
+                return false;
+            }
+
+        Widget *pParent = up();
+
+        if ( pParent )
+        {
+            pParent->removeChild( this );
+            pParent->addChild( pChild );
+        }
+        pChild->addChild( this );
+        return true;
+    }
+
+    unsigned int getChildPos( Widget *pChild )
+    {
+        int i = 0;
+        for ( std::vector< Widget *>::const_iterator it = maChildren.begin();
+             it != maChildren.end(); it++, i++ )
+            if ( *it == pChild )
+                break;
+        return i;
+    }
+
+    Widget *getChild( int pos )
+    {
+        if ( pos >= 0 && pos < (signed) maChildren.size() )
+            return *(maChildren.begin() + pos);
+        return NULL;
+    }
+
+    bool isContainer()
+    { return mxContainer.is(); }
+    unsigned int getChildrenLen()
+    { return maChildren.size(); }
+
+    rtl::OUString getLabel() const
+    { return mrLabel; }
+    rtl::OUString getUnoName() const
+    { return mrUnoName; }
+
+    int getDepth()
+    {
+        int depth = 0;
+        for ( Widget *pWidget = mpParent; pWidget; pWidget = pWidget->mpParent )
+            depth++;
+        return depth;
+    }
+
+    enum PropertyKind {
+        WINDOW_PROPERTY, CONTAINER_PROPERTY, WINBITS_PROPERTY
+    };
+
+    static rtl::OUString findProperty( const PropList &props, rtl::OUString propName )
+    {
+        for ( PropList::const_iterator it = props.begin(); it != props.end(); it++ )
+            if ( it->first.equalsIgnoreAsciiCase( propName ) )
+                return it->second;
+fprintf(stderr, "Serious error: property '%s' not found\n", OUSTRING_CSTR(propName));
+        return rtl::OUString();
+    }
+
+    rtl::OUString getOriginalProperty( rtl::OUString rPropName, PropertyKind rKind )
+    {
+        rtl::OUString rValue;
+        switch ( rKind ) {
+            case WINDOW_PROPERTY:
+                rValue = findProperty( maOriProps, rPropName );
+                break;
+            case CONTAINER_PROPERTY:
+                rValue = findProperty( maOriChildProps, rPropName );
+                break;
+            case WINBITS_PROPERTY:
+                // TODO
+                break;
+        }
+
+        return rValue;
+    }
+
+    rtl::OUString getProperty( rtl::OUString rPropName, PropertyKind rKind )
+    {
+        rtl::OUString rValue;
+        switch ( rKind ) {
+            case WINDOW_PROPERTY:
+                rValue = anyToString( layoutimpl::prophlp::getProperty( mxWidget, rPropName ) );
+                break;
+            case CONTAINER_PROPERTY:
+                if ( mpParent )
+                    rValue = anyToString( layoutimpl::prophlp::getProperty(
+                        mpParent->mxContainer->getChildProperties( mxWidget ), rPropName ) );
+                break;
+            case WINBITS_PROPERTY:
+                // TODO
+                break;
+        }
+
+        return rValue;
+    }
+
+    bool isPropertyTouched( rtl::OUString propName, PropertyKind rKind )
+    {
+        rtl::OUString oriValue = getOriginalProperty( propName, rKind );
+        rtl::OUString newValue = getProperty( propName, rKind );
+        bool isTouched = oriValue != newValue;
+fprintf(stderr, "is property '%s' touched? %s  (%s vs %s)\n", OUSTRING_CSTR(propName), isTouched ? "yes" : "no", OUSTRING_CSTR(oriValue), OUSTRING_CSTR(newValue));
+        return isTouched;
+    }
+
+    void setProperty( rtl::OUString rPropName, PropertyKind rKind, uno::Any rValue )
+    {
+        switch ( rKind ) {
+            case WINDOW_PROPERTY:
+                layoutimpl::prophlp::setProperty( mxWidget, rPropName, rValue );
+                break;
+            case CONTAINER_PROPERTY:
+                if ( mpParent )
+                    layoutimpl::prophlp::setProperty(
+                        mpParent->mxContainer->getChildProperties( mxWidget ), rPropName, rValue );
+                break;
+            case WINBITS_PROPERTY:
+                // TODO
+                break;
+        }
+    }
+
+    struct PropertyIterator {
+        friend class Widget;
+        PropertyKind mrKind;
+        uno::Sequence< beans::Property > maProps;
+        int nPropIt;
+
+        PropertyIterator( Widget *pWidget, PropertyKind rKind )
+        : mrKind( rKind ), nPropIt( 0 )
+        {
+            switch ( rKind )
+            {
+                case WINDOW_PROPERTY:
+                    if ( layoutimpl::prophlp::canHandleProps( pWidget->mxWidget ) )
+                    {
+                        uno::Reference< beans::XPropertySetInfo > xInfo
+                            = layoutimpl::prophlp::queryPropertyInfo( pWidget->mxWidget );
+                        if ( !xInfo.is() )
+                            return;
+
+                        maProps = xInfo->getProperties();
+                    }
+                    break;
+                case CONTAINER_PROPERTY:
+                    if ( pWidget->mpParent )
+                    {
+                        uno::Reference< beans::XPropertySet >xParentSet(
+                            pWidget->mpParent->mxContainer->getChildProperties( pWidget->mxWidget ) );
+                        if ( xParentSet.is())
+                        {
+                            uno::Reference< beans::XPropertySetInfo > xInfo( xParentSet->getPropertySetInfo() );
+                            if ( xInfo.is() )
+                                maProps = xInfo->getProperties();
+                        }
+                    }
+                    break;
+                case WINBITS_PROPERTY:
+                    // TODO
+                    break;
+            }
+        }
+
+        bool hasNext()
+        {
+            return nPropIt < maProps.getLength();
+        }
+
+        beans::Property next()
+        {
+/*            rtl::OUString propName, propValue;
+            propName = maProps[ nPropIt ];
+            propValue = getProperty( propName, mrKind, false);
+            nPropIt++;
+            return std::pair< rtl::OUString, rtl::OUString > propPair( propName, propValue );*/
+            return maProps[ nPropIt++ ];
+        }
+    };
+};
+
+class EditorRoot : public layoutimpl::LayoutRoot {
+    Widget *mpParent;
+
+public:
+    EditorRoot( const uno::Reference< lang::XMultiServiceFactory >& xFactory,
+                Widget *pParent )
+    : layoutimpl::LayoutRoot( xFactory ), mpParent( pParent )
+    {
+    }
+
+    // generation
+    virtual layoutimpl::LayoutWidget *create( rtl::OUString id, const rtl::OUString unoName,
+        long attrbs, uno::Reference< awt::XLayoutContainer > xParent )
+    {
+        if ( unoName.compareToAscii( "dialog" ) == 0 )
+            return mpParent;
+
+        // TODO: go through specs to map unoName to a more human-readable label
+        Widget *pWidget = new Widget( id, mxToolkit, xParent, unoName, attrbs );
+        if ( !mxWindow.is() )
+            mxWindow = uno::Reference< awt::XWindow >( pWidget->getPeer(), uno::UNO_QUERY );
+
+        if ( pWidget->mxContainer.is() )
+            pWidget->mxContainer->setLayoutUnit( mpParent->mxContainer->getLayoutUnit() );
+
+        return pWidget;
+    }
+};
+
+/* Working with the layout in 1D, as if it was a flat list. */
+namespace FlatLayout
+{
+    Widget *next( Widget *pWidget )
+    {
+        Widget *pNext;
+        pNext = pWidget->down();
+        if ( pNext ) return pNext;
+        pNext = pWidget->next();
+        if ( pNext ) return pNext;
+        for ( Widget *pUp = pWidget->up(); pUp != NULL; pUp = pUp->up() )
+            if ( (pNext = pUp->next()) != NULL )
+                return pNext;
+        return NULL;
+    }
+
+/*
+    Widget *prev( Widget *pWidget )
+    {
+        Widget *pPrev;
+        pPrev = pWidget->prev();
+        if ( !pPrev )
+            return pWidget->up();
+
+        Widget *pBottom = pPrev->down();
+        if ( pBottom )
+        {
+            while ( pBottom->down() || pBottom->next() )
+            {
+                for ( Widget *pNext = pBottom->next(); pNext; pNext = pNext->next() )
+                    pBottom = pNext;
+                Widget *pDown = pBottom->down();
+                if ( pDown )
+                    pBottom = pDown;
+            }
+            return pBottom;
+        }
+        return pPrev;
+    }
+*/
+
+    bool moveWidget( Widget *pWidget, bool up /*or down*/ )
+    {
+        // Keep child parent&pos for in case of failure
+        Widget *pOriContainer = pWidget->up();
+        unsigned int oriChildPos = pOriContainer->getChildPos( pWidget );
+
+        // Get parent&sibling before removing it, since relations get cut
+        Widget *pSibling = up ? pWidget->prev() : pWidget->next();
+        Widget *pContainer = pWidget->up();
+        if ( !pContainer )
+            return false;
+
+        // try to swap with parent or child
+        // We need to allow for this at least for the root node...
+        if ( !pSibling )
+        {
+            if ( up )
+            {
+                if ( pContainer->swapWithChild( pWidget ) )
+                    return true;
+            }
+            else
+            {
+// TODO: this is a nice feature, but we probably want to do it explicitely...
+#if 0
+                if ( pWidget->down() && pWidget->swapWithChild( pWidget->down() ) )
+                    return true;
+#endif
+            }
+        }
+
+        pContainer->removeChild( pWidget );
+
+        // if has up sibling -- append to it, else swap with it
+        if ( pSibling )
+        {
+            if ( pSibling->addChild( pWidget, up ? 0xffff : 0 ) )
+                return true;
+
+            unsigned int childPos = pContainer->getChildPos( pSibling );
+            if ( pContainer->addChild( pWidget, childPos + (up ? 0 : 1) ) )
+                return true;  // should always be succesful
+        }
+        // go through parents -- try to get prepended to them
+        else
+        {
+            for ( ; pContainer && pContainer->up(); pContainer = pContainer->up() )
+            {
+                unsigned int childPos = pContainer->up()->getChildPos( pContainer );
+                if ( pContainer->up()->addChild( pWidget, childPos + (up ? 0 : 1) ) )
+                    return true;
+            }
+        }
+
+        // failed -- try to get it to its old position
+        if ( !pOriContainer->addChild( pWidget, oriChildPos ) )
+        {
+            // a parent should never reject a child back. but if it ever
+            // happens, just kill it, we don't run an orphanate here ;P
+            delete pWidget;
+            return true;
+        }
+        return false;
+    }
+
+    // NOTE: root is considered to be number -1
+    Widget *get( Widget *pRoot, int nb )
+    {
+        Widget *it;
+        for ( it = pRoot; it != NULL && nb >= 0; it = next( it ) )
+            nb--;
+        return it;
+    }
+
+    int get( Widget *pRoot, Widget *pWidget )
+    {
+        int nRet = -1;
+        Widget *it;
+        for ( it = pRoot; it != NULL && it != pWidget; it = next( it ) )
+            nRet++;
+        return nRet;
+    }
+};
+
+//** PropertiesList widget
+
+class PropertiesList : public layout::Table
+{
+    class PropertyEntry
+    {
+        friend class PropertiesList;
+
+        /* wrapper between the widget and Any */
+        struct AnyWidget
+        {
+            DECL_LINK( ApplyPropertyHdl, layout::Window* );
+            DECL_LINK( FlagToggledHdl, layout::CheckBox* );
+
+            AnyWidget( Widget *pWidget, rtl::OUString aPropName, Widget::PropertyKind aPropKind )
+            : mpWidget( pWidget ), maPropName( aPropName ), maPropKind( aPropKind )
+            {
+                mpFlag = 0;
+                mbBlockFlagCallback = false;
+                bFirstGet = true;
+            }
+
+            virtual ~AnyWidget()
+            {
+                fprintf(stderr, "~AnyWidget\n");
+            }
+
+            void save( uno::Any aValue )
+            {
+                mpWidget->setProperty( maPropName, maPropKind, aValue );
+                checkProperty();
+            }
+
+void checkProperty()
+{
+                bool flag = mpWidget->isPropertyTouched( maPropName, maPropKind );
+
+                if ( mpFlag && mpFlag->IsChecked() != flag )
+                {
+                    CheckFlag( flag, true );
+                }
+}
+
+            void CheckFlag( bool bValue, bool bBlockCallback )
+            {
+                if ( bBlockCallback )
+                    mbBlockFlagCallback = true;
+                mpFlag->Check( bValue );
+                mbBlockFlagCallback = false;
+            }
+
+            bool bFirstGet;  // HACK
+            rtl::OUString getValue()
+            {
+//                return mpWidget->getOriProperty( maPropName );
+                rtl::OUString value;
+                if ( bFirstGet )    // king of ugliness
+                    value = mpWidget->getProperty( maPropName, maPropKind );
+                else
+                    value = mpWidget->getOriginalProperty( maPropName, maPropKind );
+                bFirstGet = false;
+                return value;
+            }
+
+            // FIXME: wrapper should have a base class for this...
+            virtual layout::Window *getWindow() = 0;
+            virtual layout::Container *getContainer() { return NULL; }
+
+            virtual void load() = 0;
+            virtual void store() = 0;
+
+            Widget *mpWidget;
+            rtl::OUString maPropName;
+            Widget::PropertyKind maPropKind;
+            layout::CheckBox *mpFlag;
+            bool mbBlockFlagCallback;
+        };
+
+        struct AnyEdit : public AnyWidget, layout::HBox
+        {
+            layout::Edit *mpEdit;
+            bool mbMultiLine;
+            layout::PushButton *mpExpand;
+            DECL_LINK( ExpandEditHdl, layout::PushButton* );
+
+            // so we can create widgets (like transforming the Edit into a
+            // MultiLineEdit)
+            layout::Window *mpWinParent;
+
+            AnyEdit( Widget *pWidget, rtl::OUString aPropName,
+                     Widget::PropertyKind aPropKind, layout::Window *pWinParent )
+            : AnyWidget( pWidget, aPropName, aPropKind ), layout::HBox( 0, false ), mpWinParent( pWinParent )
+            {
+                mpEdit = NULL;
+                mpExpand = new layout::PushButton( pWinParent, WB_TOGGLE );
+                mpExpand->SetToggleHdl( LINK( this, AnyEdit, ExpandEditHdl ) );
+                setAsMultiLine( false );
+
+                load();
+            }
+
+            virtual ~AnyEdit()
+            {
+                delete mpEdit;
+                delete mpExpand;
+            }
+
+            virtual layout::Window *getWindow()
+            { return NULL; }
+            virtual layout::Container *getContainer()
+            { return this; }
+
+            void setAsMultiLine( bool bMultiLine )
+            {
+                Clear();
+                XubString text;
+                if ( mpEdit )
+                {
+                    text = mpEdit->GetText();
+printf("Remove mpEdit and expand\n");
+                    Remove( mpEdit );
+                    Remove( mpExpand );
+                    delete mpEdit;
+                }
+
+                if ( bMultiLine )
+                {
+                    mpEdit = new layout::Edit( mpWinParent, WB_BORDER );
+                    mpExpand->SetText( String::CreateFromAscii( "-" ) );
+                }
+                else
+                {
+                    mpEdit = new layout::Edit( mpWinParent, WB_BORDER );
+                    mpExpand->SetText( String::CreateFromAscii( "+" ) );
+                }
+
+                mpEdit->SetText( text );
+                mpEdit->SetModifyHdl( LINK( this, AnyEdit, ApplyPropertyHdl ) );
+
+                Add( mpEdit, true, true, 0 );
+                Add( mpExpand, false, true, 0 );
+
+                mbMultiLine = bMultiLine;
+            }
+
+#if 0
+            // TODO: make this global... We'll likely need it for export...
+            struct Translate {
+                const char *ori, *dest;
+            };
+            static rtl::OUString stringReplace( rtl::OUString _str,
+                                                Translate *trans )
+            {
+                const sal_Unicode *str = _str.getStr();
+                rtl::OUStringBuffer buf;
+                int i, j, k;
+                for ( i = 0; i < _str.getLength(); i++ )
+                {
+                    for ( j = 0; trans[ j ].ori; j++ )
+                    {
+                        const char *ori = trans[ j ].ori;
+                        for ( k = 0; ori[ k ] && i+k < _str.getLength(); k++ )
+                            if ( ori[ k ] != str[ i+k ] )
+                                break;
+                        if ( !ori[ k ] )
+                        {
+                            // found substring
+                            buf.appendAscii( trans[ j ].dest );
+                            i += k;
+                            continue;
+                        }
+                    }
+                    buf.append( str[ i ] );
+                }
+                return buf.makeStringAndClear();
+            }
+#endif
+
+            virtual void load()
+            {
+#if 0
+                // replace end of lines by "\\n" strings
+                Translate trans[] = {
+                    { "\\", "\\\\" }, { "\n", "\\n" }, { 0, 0 }
+                }; 
+                rtl::OUString str = anyToString( getValue() );
+                str = stringReplace( str, trans );
+                SetText( str );
+#endif
+                mpEdit->SetText( getValue() );
+                checkProperty();
+            }
+
+            virtual void store()
+            {
+#if 0
+                // replace "\\n" strings by actual end of lines
+                Translate trans[] = {
+                    { "\\\\", "\\"  }, { "\\n", "\n" },
+                    { "\\", "" }, { 0, 0 }
+                }; 
+                rtl::OUString str = GetText();
+                str = stringReplace( str, trans );
+                save( uno::makeAny( str ) );
+#endif
+                save( uno::makeAny( (rtl::OUString) mpEdit->GetText() ) );
+            }
+        };
+
+        struct AnyInteger : public AnyWidget, NumericField
+        {
+            AnyInteger( Widget *pWidget, rtl::OUString aPropName,
+                        Widget::PropertyKind aPropKind, Window *pWinParent )
+            : AnyWidget( pWidget, aPropName, aPropKind ), NumericField( pWinParent, WB_SPIN|WB_BORDER )
+            {
+                load();
+                SetModifyHdl( LINK( this, AnyInteger, ApplyPropertyHdl ) );
+            }
+
+            virtual Window *getWindow()
+            { return this; }
+
+            virtual void load()
+            {
+                OUString text = getValue();
+                SetText( text.getStr() );
+                checkProperty();
+            }
+
+            virtual void store()
+            {
+fprintf(stderr, "store number: %ld\n", rtl::OUString( GetText() ).toInt64());
+                save( uno::makeAny( rtl::OUString( GetText() ).toInt64() ) );
+            }
+        };
+
+        struct AnyFloat : public AnyInteger
+        {
+            AnyFloat( Widget *pWidget, rtl::OUString aPropName,
+                      Widget::PropertyKind aPropKind, Window *pWinParent )
+            : AnyInteger( pWidget, aPropName, aPropKind, pWinParent )
+            {}
+
+            virtual void store()
+            {
+                save( uno::makeAny( rtl::OUString( GetText() ).toDouble() ) );
+            }
+        };
+
+        struct AnyCheckBox : public AnyWidget, layout::CheckBox
+        {
+            AnyCheckBox( Widget *pWidget, rtl::OUString aPropName,
+                         Widget::PropertyKind aPropKind, layout::Window *pWinParent )
+            : AnyWidget( pWidget, aPropName, aPropKind ), layout::CheckBox( pWinParent )
+            {
+                // adding some whitespaces to make the hit area larger
+//                SetText( String::CreateFromAscii( "" ) );
+                load();
+                SetToggleHdl( LINK( this, AnyWidget, ApplyPropertyHdl ) );
+            }
+
+            virtual ~AnyCheckBox()
+            {
+                fprintf(stderr, "~AnyCheckBox\n");
+            }
+
+            virtual layout::Window *getWindow()
+            { return this; }
+
+            virtual void load()
+            {
+fprintf(stderr, "loading boolean value\n");
+                Check( getValue().toInt64() );
+                setLabel();
+                checkProperty();
+            }
+
+            virtual void store()
+            {
+                save( uno::makeAny( IsChecked() ) );
+                setLabel();
+            }
+
+            void setLabel()
+            {
+                SetText( String::CreateFromAscii( IsChecked() ? "true" : "false" ) );
+            }            
+        };
+
+        struct AnyListBox : public AnyWidget, layout::ListBox
+        {
+            AnyListBox( Widget *pWidget, rtl::OUString aPropName,
+                        Widget::PropertyKind aPropKind, Window *pWinParent )
+            : AnyWidget( pWidget, aPropName, aPropKind ), layout::ListBox( pWinParent, WB_DROPDOWN )
+            {
+                SetSelectHdl( LINK( this, AnyWidget, ApplyPropertyHdl ) );
+            }
+
+            virtual layout::Window *getWindow()
+            { return this; }
+
+            virtual void load()
+            {
+                SelectEntryPos( getValue().toInt32() );
+                checkProperty();
+            }
+
+            virtual void store()
+            {
+                save( uno::makeAny( (short) GetSelectEntryPos() ) );
+            }
+        };
+
+        struct AnyAlign : public AnyListBox
+        {
+            AnyAlign( Widget *pWidget, rtl::OUString aPropName,
+                      Widget::PropertyKind aPropKind, Window *pWinParent )
+            : AnyListBox( pWidget, aPropName, aPropKind, pWinParent )
+            {
+                InsertEntry( XubString::CreateFromAscii( "Left" ) );
+                InsertEntry( XubString::CreateFromAscii( "Center" ) );
+                InsertEntry( XubString::CreateFromAscii( "Right" ) );
+                load();
+            }
+        };
+
+        /* AnyListBox and AnyComboBox different in that a ComboBox allows the user
+           to add other options, operating in strings, instead of constants.
+           (its more like a suggestive AnyEdit) */
+        struct AnyComboBox : public AnyWidget, layout::ComboBox
+        {
+            AnyComboBox( Widget *pWidget, rtl::OUString aPropName,
+                         Widget::PropertyKind aPropKind, Window *pWinParent )
+            : AnyWidget( pWidget, aPropName, aPropKind ), layout::ComboBox( pWinParent, WB_DROPDOWN )
+            {
+                SetModifyHdl( LINK( this, AnyComboBox, ApplyPropertyHdl ) );
+            }
+
+            virtual layout::Window *getWindow()
+            { return this; }
+
+            virtual void load()
+            {
+                SetText( getValue() );
+                checkProperty();
+            }
+
+            virtual void store()
+            {
+                save( uno::makeAny( (rtl::OUString) GetText() ) );
+            }
+        };
+
+        struct AnyFontStyle : public AnyComboBox
+        {
+            AnyFontStyle( Widget *pWidget, rtl::OUString aPropName,
+                          Widget::PropertyKind aPropKind, Window *pWinParent )
+            : AnyComboBox( pWidget, aPropName, aPropKind, pWinParent )
+            {
+                InsertEntry( XubString::CreateFromAscii( "Bold" ) );
+                InsertEntry( XubString::CreateFromAscii( "Italic" ) );
+                InsertEntry( XubString::CreateFromAscii( "Bold Italic" ) );
+                InsertEntry( XubString::CreateFromAscii( "Fett" ) );
+                load();
+            }
+        };
+
+        layout::FixedText *mpLabel;
+        layout::CheckBox *mpFlag;
+        AnyWidget *mpValue;
+
+        public:
+            PropertyEntry( layout::Window *pWinParent, AnyWidget *pAnyWidget )
+            {
+                mpLabel = new layout::FixedText( pWinParent );
+                {
+                    // append ':' to aPropName
+                    rtl::OUStringBuffer buf( pAnyWidget->maPropName );
+                    buf.append( sal_Unicode (':') );
+                    mpLabel->SetText( buf.makeStringAndClear() );
+                }
+                mpValue = pAnyWidget;
+                mpFlag = new layout::CheckBox( pWinParent );
+                mpFlag->SetToggleHdl( LINK( mpValue, AnyWidget, FlagToggledHdl ) );
+                mpValue->mpFlag = mpFlag;
+            }
+
+            ~PropertyEntry()
+            {
+            fprintf(stderr, "REMOVING label, flag and value\n");
+                delete mpLabel;
+                delete mpFlag;
+                delete mpValue;
+            }
+
+            // Use this factory rather than the constructor -- check for NULL
+            static PropertyEntry *construct( Widget *pWidget, rtl::OUString aPropName,
+                                             Widget::PropertyKind aPropKind, sal_uInt16 nType,
+                                             layout::Window *pWinParent )
+            {
+                AnyWidget *pAnyWidget;
+                switch (nType) {
+                    case uno::TypeClass_STRING:
+                        if ( aPropName.compareToAscii( "FontStyleName" ) == 0 )
+                        {
+                            pAnyWidget = new AnyFontStyle( pWidget, aPropName, aPropKind, pWinParent );
+                            break;
+                        }
+                        pAnyWidget = new AnyEdit( pWidget, aPropName, aPropKind, pWinParent );
+                        break;
+                    case uno::TypeClass_SHORT:
+                        if ( aPropName.compareToAscii( "Align" ) == 0 )
+                        {
+                            pAnyWidget = new AnyAlign( pWidget, aPropName, aPropKind, pWinParent );
+                            break;
+                        }
+                        // otherwise, treat as any other number...
+                    case uno::TypeClass_LONG:
+                    case uno::TypeClass_UNSIGNED_LONG:
+                        pAnyWidget = new AnyInteger( pWidget, aPropName, aPropKind, pWinParent );
+                        break;
+                    case uno::TypeClass_FLOAT:
+                    case uno::TypeClass_DOUBLE:
+                        pAnyWidget = new AnyFloat( pWidget, aPropName, aPropKind, pWinParent );
+                        break;
+                    case uno::TypeClass_BOOLEAN:
+                        pAnyWidget = new AnyCheckBox( pWidget, aPropName, aPropKind, pWinParent );
+                        break;
+                    default:
+                        return NULL;
+                }
+                return new PropertyEntry( pWinParent, pAnyWidget );
+            }
+        };
+
+    layout::Window *mpParentWindow;
+
+    std::list< PropertyEntry* > maPropertiesList;
+    layout::FixedLine *mpSeparator;
+
+    // some properties are obscure, or simply don't make sense in this
+    // context. Let's just ignore them.
+    // Maybe we could offer them in an expander or something...
+    static bool toIgnore( rtl::OUString prop )
+    {
+        // binary search -- keep the list sorted alphabetically
+        static char const *toIgnoreList[] = {
+            "DefaultControl", "FocusOnClick", "FontCharWidth", "FontCharset",
+            "FontEmphasisMark", "FontFamily", "FontHeight", "FontKerning", "FontName",
+            "FontOrientation", "FontPitch", "FontRelief", "FontSlant", "FontStrikeout",
+            "FontType", "FontWordLineMode", "HelpText", "HelpURL", "MultiLine",
+            "Printable", "Repeat", "RepeatDelay", "Tabstop"
+        };
+
+#if 0
+        // checks list sanity -- enable this when you add some entries...
+        for ( unsigned int i = 1; i < sizeof( toIgnoreList )/sizeof( char * ); i++ )
+        {
+            if ( strcmp(toIgnoreList[i-1], toIgnoreList[i]) >= 0 )
+            {
+                printf("ignore list not ordered properly: "
+                       "'%s' should come before '%s'\n",
+                       toIgnoreList[i], toIgnoreList[i-1]);
+                exit(-1);
+            }
+        }
+#endif
+
+        int min = 0, max = sizeof( toIgnoreList )/sizeof( char * ) - 1, mid, cmp;
+        do {
+            mid = min + (max - min)/2;
+            cmp = prop.compareToAscii( toIgnoreList[ mid ] );
+            if ( cmp > 0 )
+                min = mid+1;
+            else if ( cmp < 0 )
+                max = mid-1;
+            else
+                return true;
+        } while ( min <= max );
+        return false;
+   }
+
+public:
+    PropertiesList( layout::Dialog *dialog )
+    : layout::Table( dialog, "properties-box" )
+    , mpParentWindow( dialog ), mpSeparator( 0 )
+    {
+    }
+
+    ~PropertiesList()
+    {
+        clear();
+    }
+
+private:
+    // auxiliary, add properties from the peer to the list
+    void addProperties( Widget *pWidget, Widget::PropertyKind rKind )
+    {
+        Widget::PropertyIterator it( pWidget, rKind );
+        while ( it.hasNext() )
+        {
+            beans::Property prop = it.next();
+            rtl::OUString name( prop.Name );
+            if ( toIgnore( name ) )
+                continue;
+            sal_uInt16 type = prop.Type.getTypeClass();
+
+            PropertyEntry *propEntry = PropertyEntry::construct(
+                pWidget, name, rKind, type, mpParentWindow );
+
+            if ( propEntry )
+            {
+                Add( propEntry->mpLabel, false, false );
+                // HACK: one of these will return Null...
+                Add( propEntry->mpValue->getWindow(), true, false );
+                Add( propEntry->mpValue->getContainer(), true, false );
+
+                Add( propEntry->mpFlag, false, false );
+                maPropertiesList.push_back( propEntry );
+            }
+        }
+    }
+
+public:
+    void selectedWidget( Widget *pWidget )
+    {
+        clear();
+        if ( !pWidget )
+            return;
+
+        addProperties( pWidget, Widget::CONTAINER_PROPERTY );
+
+        mpSeparator = new layout::FixedLine( mpParentWindow );
+        // TODO: we may want to have to separate list widgets here...
+        Add( mpSeparator, false, false, 3, 1 );
+
+        addProperties( pWidget, Widget::WINDOW_PROPERTY );
+
+        ShowAll( true );
+    }
+
+    void clear()
+    {
+        Container::Clear();        
+
+        for ( std::list< PropertyEntry* >::iterator it = maPropertiesList.begin();
+             it != maPropertiesList.end(); it++)
+            delete *it;
+        maPropertiesList.clear();
+
+        delete mpSeparator;
+        mpSeparator = NULL;
+    }
+};
+
+IMPL_LINK( PropertiesList::PropertyEntry::AnyWidget, ApplyPropertyHdl, layout::Window *, pWin )
+{
+    (void) pWin;
+    store();
+    return 0;
+}
+
+IMPL_LINK( PropertiesList::PropertyEntry::AnyWidget, FlagToggledHdl, layout::CheckBox *, pCheck )
+{
+fprintf(stderr, "Property flag pressed -- is: %d\n", pCheck->IsChecked());
+    if ( !mbBlockFlagCallback )
+    {
+        bool checked = pCheck->IsChecked();
+        if ( !checked )  // revert
+{
+fprintf(stderr, "revert\n");
+            load();
+}
+        else
+        {
+fprintf(stderr, "user can't dirty the flag!\n");
+            // User can't flag the property as dirty
+            // Actually, we may want to allow the designer to force a property to be stored.
+            // Could be useful when the default value of some new property wasn't yet decided...
+            CheckFlag( false, true );
+        }
+    }
+else
+fprintf(stderr, "Property flag pressed -- BLOCKED\n");
+    return 0;
+}
+
+IMPL_LINK( PropertiesList::PropertyEntry::AnyEdit, ExpandEditHdl, layout::PushButton *, pBtn )
+{
+    setAsMultiLine( pBtn->IsChecked() );
+    return 0;
+}
+
+//** SortListBox auxiliary widget
+
+class SortListBox
+{        // For a manual sort ListBox; asks for a ListBox and Up/Down/Remove
+         // buttons to wrap
+DECL_LINK( ItemSelectedHdl, layout::ListBox* );
+DECL_LINK( UpPressedHdl, layout::Button* );
+DECL_LINK( DownPressedHdl, layout::Button* );
+DECL_LINK( RemovePressedHdl, layout::Button* );
+layout::PushButton *mpUpButton, *mpDownButton, *mpRemoveButton;
+
+protected:
+layout::ListBox *mpListBox;
+
+    virtual void upPressed( USHORT nPos )
+    {
+        XubString str = mpListBox->GetSelectEntry();
+        mpListBox->RemoveEntry( nPos );
+        nPos = mpListBox->InsertEntry( str, nPos-1 );
+        mpListBox->SelectEntryPos( nPos );
+    }
+
+    virtual void downPressed( USHORT nPos )
+    {
+        XubString str = mpListBox->GetSelectEntry();
+        mpListBox->RemoveEntry( nPos );
+        nPos = mpListBox->InsertEntry( str, nPos+1 );
+        mpListBox->SelectEntryPos( nPos );
+    }
+
+    virtual void removePressed( USHORT nPos )
+    {
+        mpListBox->RemoveEntry( nPos );
+    }
+
+    virtual void itemSelected( USHORT nPos )
+    {
+        // if we had some XLayoutContainer::canAdd() or maxChildren() function
+        // we could make a function to check if we can move selected and enable/
+        // /disable the move buttons as appropriate
+
+        if ( nPos == LISTBOX_ENTRY_NOTFOUND )
+        {
+            mpUpButton->Disable();
+            mpDownButton->Disable();
+            mpRemoveButton->Disable();
+        }
+        else
+        {
+            mpUpButton->Enable();
+            mpDownButton->Enable();
+            mpRemoveButton->Enable();
+        }
+    }
+
+public:
+    SortListBox( layout::ListBox *pListBox, layout::PushButton *pUpButton, layout::PushButton *pDownButton,
+                 layout::PushButton *pRemoveButton )
+    : mpUpButton( pUpButton), mpDownButton( pDownButton), mpRemoveButton( pRemoveButton ),
+      mpListBox( pListBox )
+    {
+        mpListBox->SetSelectHdl( LINK( this, SortListBox, ItemSelectedHdl ) );
+
+        mpUpButton->SetModeImage( layout::Image ( "res/commandimagelist/lc_moveup.png" ) );
+        mpUpButton->SetImageAlign( IMAGEALIGN_LEFT );
+        mpUpButton->SetClickHdl( LINK( this, SortListBox, UpPressedHdl ) );
+
+        mpDownButton->SetModeImage( layout::Image ( "res/commandimagelist/lc_movedown.png" ) );
+        mpDownButton->SetImageAlign( IMAGEALIGN_LEFT );
+        mpDownButton->SetClickHdl( LINK( this, SortListBox, DownPressedHdl ) );
+
+        // "res/commandimagelist/lch_delete.png", "res/commandimagelist/lc_delete.png"
+        mpRemoveButton->SetModeImage( layout::Image ( "res/commandimagelist/sc_closedoc.png" ) );
+        mpRemoveButton->SetImageAlign( IMAGEALIGN_LEFT );
+        mpRemoveButton->SetClickHdl( LINK( this, SortListBox, RemovePressedHdl ) );
+
+        // fire an un-select event
+        itemSelected( LISTBOX_ENTRY_NOTFOUND );
+    }
+
+    ~SortListBox()
+    {
+        delete mpListBox;
+        delete mpUpButton;
+        delete mpDownButton;
+        delete mpRemoveButton;
+    }
+};
+
+IMPL_LINK( SortListBox, UpPressedHdl, layout::Button *, pBtn )
+{
+    (void) pBtn;
+    USHORT pos = mpListBox->GetSelectEntryPos();
+    if ( pos > 0 && pos != LISTBOX_ENTRY_NOTFOUND )
+        upPressed( pos );
+    return 0;
+}
+
+IMPL_LINK( SortListBox, DownPressedHdl, layout::Button *, pBtn )
+{
+    (void) pBtn;
+    USHORT pos = mpListBox->GetSelectEntryPos();
+    if ( pos < mpListBox->GetEntryCount() && pos != LISTBOX_ENTRY_NOTFOUND )
+        downPressed( pos );
+    return 0;
+}
+
+IMPL_LINK( SortListBox, RemovePressedHdl, layout::Button *, pBtn )
+{
+    (void) pBtn;
+    USHORT pos = mpListBox->GetSelectEntryPos();
+    if ( pos != LISTBOX_ENTRY_NOTFOUND )
+        removePressed( pos );
+    return 0;
+}
+
+IMPL_LINK( SortListBox, ItemSelectedHdl, layout::ListBox *, pList )
+{
+    (void) pList;
+    USHORT pos = mpListBox->GetSelectEntryPos();
+    itemSelected( pos );
+    return 0;
+}
+
+//** LayoutTree widget
+
+class LayoutTree : public SortListBox
+{
+public:
+    struct Listener
+    {
+        virtual void widgetSelected( Widget *pWidget ) = 0;
+    };
+
+private:
+    Listener *mpListener;
+
+public:
+    Widget *mpRootWidget;
+
+    LayoutTree( layout::Dialog *dialog )
+    : SortListBox( new layout::ListBox( dialog, "layout-tree" ),
+                   new layout::PushButton( dialog, "layout-up-button" ),
+                   new layout::PushButton( dialog, "layout-down-button" ),
+                   new layout::PushButton( dialog, "layout-remove-button" ) )
+    {
+        layout::PeerHandle handle = dialog->GetPeerHandle( "preview-box" );
+        uno::Reference< awt::XLayoutConstrains > xWidget( handle, uno::UNO_QUERY );
+        mpRootWidget = new Widget( xWidget, "root" );
+    }
+
+    ~LayoutTree()
+    {
+        delete mpRootWidget;
+    }
+
+    Widget *getWidget( int nPos )
+    {
+        if ( nPos != LISTBOX_ENTRY_NOTFOUND )
+            return FlatLayout::get( mpRootWidget, nPos );
+        return NULL;
+    }
+
+    Widget *getSelectedWidget()
+    {
+        Widget *pWidget = getWidget( mpListBox->GetSelectEntryPos() );
+        if ( !pWidget )  // return root, if none selected
+            pWidget = mpRootWidget;
+        return pWidget;
+    }
+
+    void selectWidget( Widget *pWidget )
+    {
+        int pos = FlatLayout::get( mpRootWidget, pWidget );
+        if ( pos == -1 )
+            // if asked to select hidden root, select visible root
+            pos = 0;
+        mpListBox->SelectEntryPos( pos );
+    }
+
+    void rebuild()
+    {
+        struct inner
+        {
+            // pads a string with whitespaces
+            static rtl::OUString padString( rtl::OUString name, int depth )
+            {
+                rtl::OStringBuffer aBuf( depth * 4 + name.getLength() + 2 );
+                for (int i = 0; i < depth; i++)
+                    aBuf.append( "    " );
+                aBuf.append( rtl::OUStringToOString( name, RTL_TEXTENCODING_ASCII_US ) );
+                return rtl::OUString( aBuf.getStr(), aBuf.getLength(),
+                                      RTL_TEXTENCODING_UTF8 );
+            }
+        };
+
+        mpListBox->Clear();
+        for ( Widget *i = FlatLayout::next( mpRootWidget ); i; i = FlatLayout::next( i ) )
+            mpListBox->InsertEntry( inner::padString( i->getLabel(), i->getDepth()-1 ) );
+
+        // any selection, no longer is. ListBox doesn't fire the event on this case;
+        // force it.
+        itemSelected( LISTBOX_ENTRY_NOTFOUND );
+    }
+
+    void setListener( Listener *pListener )
+    { mpListener = pListener; }
+
+    // print in XML format...
+
+static rtl::OUString toXMLNaming (const rtl::OUString &string)
+{
+    rtl::OUStringBuffer buffer (string.getLength());
+    sal_Unicode *str = string.pData->buffer;
+    for (int i = 0; i < string.getLength(); i++) {
+        if ( str[i] >= 'A' && str[i] <= 'Z' )
+        {
+            if ( i > 0 )
+                buffer.append ((sal_Unicode) '-');
+            buffer.append ((sal_Unicode) (str[i] - 'A' + 'a'));
+        }
+        else
+            buffer.append ((sal_Unicode) str[i]);
+    }
+
+    return buffer.makeStringAndClear();
+}
+
+    void print()
+    {
+        printf("\t\tExport:\n");
+        printf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
+               "<dialog xmlns=\"http://openoffice.org/2007/layout\"\n"
+               "        xmlns:cnt=\"http://openoffice.org/2007/layout/container\"\n"
+               "        id=\"dialog\" title=\"Unnamed\" sizeable=\"true\" >\n");
+
+        for ( Widget *i = FlatLayout::next( mpRootWidget ); i; i = FlatLayout::next( i ) )
+        {
+            for ( int d = i->getDepth(); d > 0; d-- )
+                printf("    ");
+            printf("<%s ", OUSTRING_CSTR( i->getUnoName() ) );
+
+            for ( int kind = 0; kind < 2; kind++ )
+            {
+                Widget::PropertyKind wKind = kind == 0 ? Widget::WINDOW_PROPERTY
+                                                          : Widget::CONTAINER_PROPERTY;
+                Widget::PropertyIterator it( i, wKind );
+                while ( it.hasNext() )
+                {
+                    beans::Property prop = it.next();
+                    if ( !i->isPropertyTouched( prop.Name, wKind ) )
+                        continue;
+
+                    rtl::OUString value = i->getProperty( prop.Name, wKind );
+                    if ( prop.Type.getTypeClass() == uno::TypeClass_BOOLEAN )
+                    {
+                        if ( value.compareToAscii( "0" ) )
+                             value = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("false") );
+                        else
+                             value = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("true") );
+                    }
+
+                    if ( value.getLength() > 0 )
+                        printf("%s%s=\"%s\" ",
+                            kind == 0 ? "" : "cnt:",
+                            OUSTRING_CSTR( toXMLNaming( prop.Name ) ), OUSTRING_CSTR( value )
+                        );
+
+                }
+            }
+            printf("/>\n");
+        }
+        printf("</dialog>\n");
+    }
+
+protected:
+    virtual void upPressed( USHORT nPos )
+    {
+        Widget *pWidget = getWidget( nPos );
+        if ( FlatLayout::moveWidget( pWidget, true ) )
+            rebuild();
+        selectWidget( pWidget );
+    }
+
+    virtual void downPressed( USHORT nPos )
+    {
+        Widget *pWidget = getWidget( nPos );
+        if ( FlatLayout::moveWidget( pWidget, false ) )
+            rebuild();
+        selectWidget( pWidget );
+    }
+
+    virtual void removePressed( USHORT nPos )
+    {
+        Widget *pWidget = getWidget( nPos );
+        if ( pWidget )
+        {
+            pWidget->up()->removeChild( pWidget );
+            delete pWidget;
+            rebuild();
+        }
+    }
+
+    virtual void itemSelected( USHORT nPos )
+    {
+        mpListener->widgetSelected( getWidget( nPos ) );
+        SortListBox::itemSelected( nPos );
+    }
+};
+
+//** EditorImpl
+
+class EditorImpl : public LayoutTree::Listener
+{
+    void createWidget( const char *unoName );
+
+    PropertiesList *mpPropertiesList;
+    LayoutTree *mpLayoutTree;
+
+    layout::PushButton *pImportButton, *pExportButton;
+#ifdef FILEDLG
+    FileDialog *pImportDialog;
+#endif
+    DECL_LINK( ImportButtonHdl, layout::PushButton* );
+    DECL_LINK( ExportButtonHdl, layout::PushButton* );
+#ifdef FILEDLG
+    DECL_LINK( ImportDialogHdl, FileDialog* );
+#endif
+
+    // framework stuff
+    uno::Reference< lang::XMultiServiceFactory > mxFactory;
+    uno::Reference< awt::XToolkit > mxToolkit;
+    uno::Reference< awt::XWindow > mxToplevel;
+
+    virtual void widgetSelected( Widget *pWidget );
+    DECL_LINK( CreateWidgetHdl, layout::Button* );
+
+    std::list< layout::PushButton *> maCreateButtons;
+
+public:
+
+    EditorImpl( layout::Dialog *dialog,
+        // we should probable open this channel (or whatever its called) ourselves
+                uno::Reference< lang::XMultiServiceFactory > xMSF );
+    ~EditorImpl();
+
+    void loadFile( const rtl::OUString &aTestFile );
+};
+
+EditorImpl::EditorImpl( layout::Dialog *dialog,
+                        uno::Reference< lang::XMultiServiceFactory > xFactory )
+    : mxFactory( xFactory )
+    , mxToplevel( dialog->GetPeerHandle( "dialog" ), uno::UNO_QUERY )
+    // FIXME: any of these should work
+    //dialog->getContext()->getRoot(), uno::UNO_QUERY )
+    // dialog->GetPeer(), uno::UNO_QUERY )
+{
+fprintf (stderr, "EditorImpl()\n");
+    // framework
+    mxToolkit = uno::Reference< awt::XToolkit >(
+        mxFactory->createInstance(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.awt.Toolkit" ) ) ),
+        uno::UNO_QUERY );
+    assert( mxToolkit.is() );
+
+    // custom widgets
+fprintf (stderr, "custom widgets\n");
+    mpPropertiesList = new PropertiesList( dialog );
+
+    mpLayoutTree = new LayoutTree( dialog );
+    mpLayoutTree->setListener( this );
+
+/*    if ( xImport.is() )
+    mpLayoutTree->getWidget( -1 )->addChild( new Widget( xImport, "import" ) );*/
+
+    // create buttons
+    layout::Container aWidgets( dialog, "create-widget" );
+    layout::Container aContainers( dialog, "create-container" );
+    for ( int i = 0; i < WIDGETS_SPECS_LEN; i++ )
+    {
+        layout::PushButton *pBtn = new layout::PushButton( (layout::Window *) dialog );
+        pBtn->SetText( rtl::OUString::createFromAscii( WIDGETS_SPECS[ i ].pLabel ) );
+        pBtn->SetClickHdl( LINK( this, EditorImpl, CreateWidgetHdl ) );
+        if ( WIDGETS_SPECS[ i ].pIconName != NULL )
+        {
+            rtl::OString aPath ("res/commandimagelist/");
+            aPath += WIDGETS_SPECS[ i ].pIconName;
+            layout::Image aImg( aPath );
+            pBtn->SetModeImage( aImg );
+            pBtn->SetImageAlign( IMAGEALIGN_LEFT );
+        }
+        pBtn->Show();
+        maCreateButtons.push_back( pBtn );
+        layout::Container *pBox = WIDGETS_SPECS[ i ].bIsContainer ? &aContainers : &aWidgets;
+        pBox->Add( pBtn );
+    }
+
+#ifdef FILEDLG
+fprintf(stderr,"creating file dialog\n");
+    pImportDialog = new FileDialog( NULL/*(layout::Window *) dialog*/, 0 );
+fprintf(stderr,"connecting it\n");
+    pImportDialog->SetFileSelectHdl( LINK( this, EditorImpl, ImportDialogHdl ) );
+fprintf(stderr,"done file dialog\n");
+#endif
+
+/*    pImportButton = new layout::PushButton( dialog, "import-button" );
+    pImportButton->SetClickHdl( LINK( this, EditorImpl, ImportButtonHdl ) );*/
+    pExportButton = new layout::PushButton( dialog, "export-button" );
+    pExportButton->SetClickHdl( LINK( this, EditorImpl, ExportButtonHdl ) );
+}
+
+EditorImpl::~EditorImpl()
+{
+    delete mpPropertiesList;
+    delete mpLayoutTree;
+    for ( std::list< layout::PushButton * >::const_iterator i = maCreateButtons.begin();
+         i != maCreateButtons.end(); i++)
+        delete *i;
+    delete pImportButton;
+    delete pExportButton;
+#ifdef FILEDLG
+    delete pImportDialog;
+#endif
+}
+
+void EditorImpl::loadFile( const rtl::OUString &aTestFile )
+{
+fprintf( stderr, "TEST: layout instance\n" );
+    uno::Reference< awt::XLayoutRoot > xRoot
+        ( new EditorRoot( mxFactory, mpLayoutTree->mpRootWidget ) );
+
+/*
+mxMSF->createInstance
+                ( ::rtl::OUString::createFromAscii( "com.sun.star.awt.Layout" ) ),
+          uno::UNO_QUERY );
+*/
+    if ( !xRoot.is() )
+    {
+        throw uno::RuntimeException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("could not create awt Layout component!") ),
+            uno::Reference< uno::XInterface >() );
+    }
+
+fprintf( stderr, "TEST: initing root\n" );
+    uno::Reference< lang::XInitialization > xInit( xRoot, uno::UNO_QUERY );
+    if ( !xInit.is() )
+    {
+        throw uno::RuntimeException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("Layout has no XInitialization!") ),
+            uno::Reference< uno::XInterface >() );
+    }
+
+fprintf( stderr, "TEST: running parser\n" );
+    uno::Sequence< uno::Any > aParams( 1 );
+    aParams[0] <<= aTestFile;
+fprintf( stderr, "TEST: do it\n" );
+    xInit->initialize( aParams );
+fprintf( stderr, "TEST: file loaded\n" );
+
+    mpLayoutTree->rebuild();
+}
+
+void EditorImpl::createWidget( const char *name )
+{
+    Widget *pWidget = mpLayoutTree->getSelectedWidget();
+
+    Widget *pChild = new Widget( rtl::OUString(), mxToolkit, uno::Reference< awt::XLayoutContainer >( mxToplevel, uno::UNO_QUERY ), rtl::OUString::createFromAscii( name ), awt::WindowAttribute::SHOW );
+    if ( !pWidget->addChild( pChild ) )
+    {
+        delete pChild;
+        // we may want to popup an error message
+    }
+    else
+    {
+        mpLayoutTree->rebuild();
+        mpLayoutTree->selectWidget( pWidget );
+    }
+}
+
+void EditorImpl::widgetSelected( Widget *pWidget )
+{
+    // we know can't add widget to a non-container, so let's disable the create
+    // buttons then. Would be nice to have a method to check if a container is
+    // full as well...
+    if ( !pWidget || pWidget->isContainer() )
+    {
+        for ( std::list< layout::PushButton *>::const_iterator it = maCreateButtons.begin();
+             it != maCreateButtons.end(); it++)
+            (*it)->Enable();
+    }
+    else
+    {
+        for ( std::list< layout::PushButton *>::const_iterator it = maCreateButtons.begin();
+             it != maCreateButtons.end(); it++)
+            (*it)->Disable();
+    }
+
+    mpPropertiesList->selectedWidget( pWidget );
+}
+
+IMPL_LINK( EditorImpl, CreateWidgetHdl, layout::Button *, pBtn )
+{
+    int i = 0;
+    for ( std::list< layout::PushButton *>::const_iterator it = maCreateButtons.begin();
+         it != maCreateButtons.end(); it++, i++ )
+    {
+        if ( pBtn == *it )
+            break;
+    }
+    assert( i < WIDGETS_SPECS_LEN );
+    createWidget( WIDGETS_SPECS[i].pName );
+    return 0;
+}
+
+IMPL_LINK( EditorImpl, ImportButtonHdl, layout::PushButton *, pBtn )
+{
+    (void) pBtn;
+fprintf(stderr, "IMPORT!\n");
+#ifdef FILEDLG
+    pImportDialog->Execute();
+#endif
+
+    return 0;
+}
+
+#ifdef FILEDLG
+IMPL_LINK( EditorImpl, ImportDialogHdl, FileDialog *, pDialog )
+{
+//fprintf(stderr, "Executing import dialog!\n");
+
+    UniString path = pDialog->GetPath();
+fprintf(stderr, "got import file: %s\n",rtl::OUStringToOString( path, RTL_TEXTENCODING_ASCII_US ).getStr() );
+
+    return 0;
+}
+#endif
+
+IMPL_LINK( EditorImpl, ExportButtonHdl, layout::PushButton *, pBtn )
+{
+    (void) pBtn;
+    mpLayoutTree->print();
+    return 0;
+}
+
+//** Editor, the Dialog
+
+Editor::Editor( uno::Reference< lang::XMultiServiceFactory > xFactory,
+                rtl::OUString aFile )
+    : layout::Dialog( (Window*) (NULL), "editor.xml", "dialog" )
+    , mpImpl( new EditorImpl( this, xFactory ) )
+{
+    if ( aFile.getLength() )
+        mpImpl->loadFile( aFile );
+
+    // parent:
+    FreeResource();
+}
+
+Editor::~Editor()
+{
+    delete mpImpl;
+}
diff --git a/layout/workben/editor.hxx b/layout/workben/editor.hxx
new file mode 100644
index 0000000..7e94d71
--- /dev/null
+++ layout/workben/editor.hxx
@@ -0,0 +1,21 @@
+#ifndef EDITOR_HXX
+#define EDITOR_HXX
+
+#include <layout/layout.hxx>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+
+class EditorImpl;
+
+class Editor : public layout::Dialog
+{
+EditorImpl *mpImpl;
+
+public:
+    Editor( com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory > xMSF,
+            rtl::OUString aFile );
+    ~Editor();
+
+    void loadFile( const rtl::OUString &aTestFile );
+};
+
+#endif /*EDITOR_HXX*/
diff --git a/layout/workben/editor.xml b/layout/workben/editor.xml
new file mode 100644
index 0000000..a81c367
--- /dev/null
+++ layout/workben/editor.xml
@@ -0,0 +1,52 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!-- Normal skin -->
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+        xmlns:cnt="http://openoffice.org/2007/layout/container"
+        id="dialog" title="Layout Editor" sizeable="true">
+	<vbox>
+		<hbox>
+			<min-size min-width="120" cnt:expand="false">
+				<vbox>
+					<fixedtext label="Layout:" cnt:expand="false" />
+					<hbox>
+						<listbox id="layout-tree" has_border="true" />
+						<vbox cnt:expand="false">
+							<pushbutton id="layout-up-button" cnt:expand="false" />
+							<pushbutton id="layout-down-button" cnt:expand="false" />
+							<fixedtext cnt:expand="true" />
+							<pushbutton id="layout-remove-button" cnt:expand="false" />
+						</vbox>
+					</hbox>
+				</vbox>
+			</min-size>
+			<min-size min-width="120">
+				<vbox>
+					<fixedtext label="Preview:" cnt:expand="false" />
+					<vbox border="50">
+						<bin id="preview-box" />
+					</vbox>
+				</vbox>
+			</min-size>
+			<min-size min-width="120" cnt:expand="false">
+				<vbox>
+					<fixedtext label="Properties:" cnt:expand="false" />
+					<table id="properties-box" columns="3" />
+				</vbox>
+			</min-size>
+		</hbox>
+		<hfixedline cnt:expand="false" />
+		<vbox cnt:expand="false">
+			<fixedtext label="Create widgets:" cnt:expand="false" />
+			<flow id="create-widget" homogeneous="true" spacing="2" />
+			<fixedtext label="Create containers:" cnt:expand="false" />
+			<flow id="create-container" homogeneous="true" spacing="2" />
+		</vbox>
+		<hbox cnt:expand="false">
+			<vbox><fixedline /><fixedline /><fixedline /><fixedline /></vbox>
+<!--			<pushbutton id="import-button" label="Import..." cnt:expand="false"/>-->
+			<pushbutton id="export-button" label="Export (stdout)" cnt:expand="false"/>
+		</hbox>
+	</vbox>
+</dialog>
diff --git a/layout/workben/flow-container.xml b/layout/workben/flow-container.xml
new file mode 100644
index 0000000..cdfc052
--- /dev/null
+++ layout/workben/flow-container.xml
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             title="Interactable Containers" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true">
+	<vbox>
+			<table columns="3" cnt:title="Page 1">
+				<pushbutton cnt:x-expand="false" cnt:row-span="2" label="1,1" />
+				<pushbutton cnt:y-expand="false" label="1,2" />
+				<pushbutton cnt:y-expand="false" label="1,3" />
+				<pushbutton cnt:col-span="2" label="2,1" />
+			</table>
+		<flow>
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+			<table columns="3" cnt:title="Page 1">
+				<pushbutton cnt:x-expand="false" cnt:row-span="2" label="1,1" />
+				<pushbutton cnt:y-expand="false" label="1,2" />
+				<pushbutton cnt:y-expand="false" label="1,3" />
+				<pushbutton cnt:col-span="2" label="2,1" />
+			</table>
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+		</flow>
+		<hbox cnt:expand="false">
+			<align>
+				<okbutton cnt:hfill="0" cnt:halign="0" />
+			</align>
+			<align>
+				<okbutton cnt:hfill="0" cnt:halign="0.3" />
+			</align>
+			<align>
+				<okbutton cnt:hfill="0" cnt:halign="0.5" />
+			</align>
+			<align>
+				<okbutton cnt:hfill="0" cnt:halign="0.7" />
+			</align>
+			<align>
+				<okbutton cnt:hfill="0" cnt:halign="1" />
+			</align>
+		</hbox>
+	</vbox>
+</dialog>
diff --git a/layout/workben/flow.xml b/layout/workben/flow.xml
new file mode 100644
index 0000000..050c5a0
--- /dev/null
+++ layout/workben/flow.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+        xmlns:cnt="http://openoffice.org/2007/layout/container"
+        title="Flowing" optimumsize="true" has_border="true" sizeable="true" moveable="true">
+	<vbox spacing="5">
+		<flow>
+			<pushbutton label="Button 1" />
+			<pushbutton label="Button 2" />
+			<pushbutton label="Button 3" />
+			<pushbutton label="Button 4" />
+			<pushbutton label="Button 5" />
+			<pushbutton label="Button 6" />
+			<pushbutton label="Button 7" />
+		</flow>
+	</vbox>
+</dialog>
diff --git a/layout/workben/interactable-containers.xml b/layout/workben/interactable-containers.xml
new file mode 100644
index 0000000..a72b8da
--- /dev/null
+++ layout/workben/interactable-containers.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             title="Interactable Containers" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true">
+	<hsplitter>
+			<scroller>
+				<vbox>
+					<pushbutton label="Some Label" />
+					<edit has_border="true" text="Some Text" />
+					<listbox has_border="true" string-item-list="Item One:Item Two:Item Three:Item Four:Item Five:Item Six:Item Seven" />
+					<combobox has_border="true" string-item-list="Item One:Item Two:Item Three" />
+					<pushbutton label="Some Label" />
+					<pushbutton label="Some Label" />
+					<pushbutton label="Some Label" />
+					<pushbutton label="Some Label" />
+					<pushbutton label="Some Label" />
+					<pushbutton label="Some Label" />
+					<pushbutton label="Some Label" />
+					<pushbutton label="Some Label" />
+					<pushbutton label="Some Label" />
+					<pushbutton label="Some Label" />
+					<pushbutton label="Some Label" />
+					<pushbutton label="Some Label" />
+				</vbox>
+			</scroller>
+		<vsplitter>
+			<pushbutton label="Corner" />
+			<tabcontrol>
+				<table columns="3" cnt:title="Page 1">
+					<pushbutton cnt:x-expand="false" cnt:row-span="2" label="1,1" />
+					<pushbutton cnt:y-expand="false" label="1,2" />
+					<pushbutton cnt:y-expand="false" label="1,3" />
+					<pushbutton cnt:col-span="2" label="2,1" />
+				</table>
+				<vbox cnt:title="Page 2">
+					<pushbutton label="1" />
+					<pushbutton label="2" />
+					<pushbutton label="3" />
+					<pushbutton label="4" />
+				</vbox>
+				<pushbutton label="Content 3" cnt:title="Page 3" />
+				<pushbutton label="Content 4" cnt:title="Page 4" />
+				<pushbutton label="Content 5" cnt:title="Page 5" />
+			</tabcontrol>
+		</vscroll>
+	</hsplitter>
+</dialog>
diff --git a/layout/workben/layout-flat.xml b/layout/workben/layout-flat.xml
new file mode 100644
index 0000000..b42e0ab
--- /dev/null
+++ layout/workben/layout-flat.xml
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<framewindow  xmlns="http://openoffice.org/2007/layout"
+    id="window1" title="Test-Dialog" optimumsize="true"
+    has_border="true" sizeable="true" moveable="true"
+    width="800" height="300">
+        <pushbutton label="XML Left" toggle="true" show="true"
+	x="10" y="10" width="400" height="200"/>
+        <pushbutton label="XML Right" toggle="true" show="true"
+	x="420" y="10" width="400" height="200"/>
+	<checkbox label="XML cool ?" enabled="true" show="true"
+	 state="1" tristate="true" align="1"
+	 x="10" y="210" width="800" height="100"/>
+</framewindow>
\ No newline at end of file
diff --git a/layout/workben/layout.xml b/layout/workben/layout.xml
new file mode 100644
index 0000000..efa8d0a
--- /dev/null
+++ layout/workben/layout.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             id="window1" title="Test-Dialog" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true">
+	<hbox border="20" spacing="10" homogeneous="true">
+		<pushbutton label="XML Left"
+		            cnt:expand="true" cnt:fill="true" />
+		<pushbutton label="XML Center"
+		            cnt:expand="true" cnt:fill="false" />
+		<pushbutton label="XML Right"
+		            cnt:expand="false" cnt:fill="false" />
+	</hbox>
+</dialog>
diff --git a/layout/workben/makefile.mk b/layout/workben/makefile.mk
new file mode 100644
index 0000000..1d52964
--- /dev/null
+++ layout/workben/makefile.mk
@@ -0,0 +1,67 @@
+PRJ=..
+PRJNAME=layout
+TARGET=test
+TARGETTYPE=GUI
+LIBTARGET=NO
+ENABLE_EXCEPTIONS=TRUE
+
+.INCLUDE :  settings.mk
+
+# hack for now ...
+CFLAGS += -I../source/core
+CFLAGS += -I../$(PRJ)/svx/inc -I../$(PRJ)/svtools/inc -I../$(PRJ)/sfx2/inc
+CFLAGS += -DSHAREDLIB -D_DLL_ -fpic
+CFLAGS += -DENABLE_LAYOUT=1 -DTEST_LAYOUT=1
+
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+CXXFILES=\
+	editor.cxx \
+	wordcountdialog.cxx \
+	test.cxx \
+	zoom.cxx
+
+OBJFILES=\
+	$(OBJ)$/editor.obj \
+	$(OBJ)$/test.obj \
+	$(OBJ)$/wordcountdialog.obj \
+	$(OBJ)$/zoom.obj
+
+APP1TARGET=$(TARGET)
+APP1OBJS=$(OBJFILES)
+# FIXME - review deps list ...
+APP1STDLIBS= \
+		$(TOOLSLIB)			\
+		$(COMPHELPERLIB)		\
+		$(VCLLIB)			\
+		$(CPPULIB)			\
+		$(CPPUHELPERLIB)		\
+		$(SALLIB)			\
+		$(XMLSCRIPTLIB)			\
+		-l$(PRJNAME)$(UPD)$(DLLPOSTFIX)
+# another hack ... ;-)	
+
+.INCLUDE :  target.mk
+
+# FIXME - some cut/paste evil .def file needed for win32 ...
+
+# FIXME: move this rule and .xml files into sw/svx trees,
+#        install into xml directory instead of lib.
+.IF "$(ENABLE_LAYOUT)"!=""
+ALLTAR: \
+    $(DLLDEST)$/wordcount.xml\
+    $(DLLDEST)$/zoom.xml
+
+$(DLLDEST)$/%.xml: %.xml
+# modes, INSTALL?
+	-$(MKDIR) $(@:d)
+	$(COPY) $< $@
+.ENDIF # ENABLE_LAYOUT
+
+dist .PHONY :
+	./un-test.sh zoom.cxx > ../$(PRJ)/svx/source/dialog/zoom.cxx
+	./un-test.sh zoom.hxx > ../$(PRJ)/svx/source/dialog/zoom.hxx
+	./un-test.sh wordcountdialog.cxx > ../$(PRJ)/sw/source/ui/dialog/wordcountdialog.cxx
+	./un-test.sh wordcountdialog.hxx > ../$(PRJ)/sw/source/ui/inc/wordcountdialog.hxx
+	# FIXME: broken setup
+	ln -sf ../inc/wordcountdialog.hxx ../$(PRJ)/sw/source/ui/dialog/wordcountdialog.hxx 
diff --git a/layout/workben/non-interactable-containers.xml b/layout/workben/non-interactable-containers.xml
new file mode 100644
index 0000000..8d23560
--- /dev/null
+++ layout/workben/non-interactable-containers.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             title="Interactable Containers" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true">
+	<vbox spacing="10">
+			<table columns="3" cnt:title="Page 1">
+				<pushbutton cnt:x-expand="false" cnt:row-span="2" label="1,1" />
+				<pushbutton cnt:y-expand="false" label="1,2" />
+				<pushbutton cnt:y-expand="false" label="1,3" />
+				<pushbutton cnt:col-span="2" label="2,1" />
+			</table>
+		<hfixedline/>
+		<flow cnt:expand="false">
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+			<table columns="3" cnt:title="Page 1">
+				<pushbutton cnt:x-expand="false" cnt:row-span="2" label="1,1" />
+				<pushbutton cnt:y-expand="false" label="1,2" />
+				<pushbutton cnt:y-expand="false" label="1,3" />
+				<pushbutton cnt:col-span="2" label="2,1" />
+			</table>
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+			<pushbutton label="label" />
+		</flow>
+		<hfixedline/>
+		<hbox cnt:expand="false">
+<!--			<align>
+				<okbutton cnt:hfill="0.2" cnt:halign="0.2" />
+			</align>
+			<align>
+				<okbutton cnt:hfill="0.8" cnt:halign="0.2" />
+			</align>-->
+		</hbox>
+	</vbox>
+</dialog>
diff --git a/layout/workben/numeric.xml b/layout/workben/numeric.xml
new file mode 100644
index 0000000..a29fec9
--- /dev/null
+++ layout/workben/numeric.xml
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<framewindow xmlns="http://openoffice.org/2007/layout"
+              xmlns:cnt="http://openoffice.org/2007/layout/container"
+              id="window1" title="Test-Dialog" optimumsize="true"
+              has_border="true" sizeable="true" moveable="true">
+                <vbox>
+			<numericfield text="5" spin="true" enforce-format="false" value-min="5.3" value-max="17.8"/>
+                        <pushbutton />
+                </vbox>
+</framewindow>
diff --git a/layout/workben/ooo-patch b/layout/workben/ooo-patch
new file mode 100755
index 0000000..7d62f47
--- /dev/null
+++ layout/workben/ooo-patch
@@ -0,0 +1,6 @@
+#! /bin/sh
+commit=${1-d1f42c99} # m1'
+
+git diff $commit layout | sed 's@^\([+-]\{3\}\) \(a\|b\)/@\1 @' > layout-dialogs-layout.diff
+git diff $commit config_office scp2 | sed 's@^\([+-]\{3\}\) \(a\|b\)/@\1 @' > layout-dialogs-config_office-scp2.diff
+git diff $commit svx sw | sed 's@^\([+-]\{3\}\) \(a\|b\)/@\1 @' > layout-dialogs-svx-sw.diff
diff --git a/layout/workben/paragraph.cxx b/layout/workben/paragraph.cxx
new file mode 100644
index 0000000..42bb78b
--- /dev/null
+++ layout/workben/paragraph.cxx
@@ -0,0 +1,2422 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: paragrph.cxx,v $
+ *
+ *  $Revision: 1.50 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 17:32:41 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#ifdef SVX_DLLIMPLEMENTATION
+#undef SVX_DLLIMPLEMENTATION
+#endif
+
+#ifndef _SFXSTYLE_HXX
+#include <svtools/style.hxx>
+#endif
+#ifndef _SFXAPP_HXX //autogen
+#include <sfx2/app.hxx>
+#endif
+#ifndef _SFX_OBJSH_HXX //autogen
+#include <sfx2/objsh.hxx>
+#endif
+#ifndef _SV_MNEMONIC_HXX
+#include <vcl/mnemonic.hxx>
+#endif
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#define _SVX_PARAGRPH_CXX   0
+
+
+
+
+#ifndef _SVTOOLS_LANGUAGEOPTIONS_HXX
+#include <svtools/languageoptions.hxx>
+#endif
+#include <svx/dialogs.hrc>
+#include "paragraph.hrc"
+#include "paragraph.hxx"
+#include <svx/frmdiritem.hxx>
+
+#include <svx/lspcitem.hxx>
+#include <svx/adjitem.hxx>
+#include <svx/orphitem.hxx>
+#include <svx/widwitem.hxx>
+#include <svx/tstpitem.hxx>
+#include <svx/pmdlitem.hxx>
+#include <svx/spltitem.hxx>
+#include <svx/hyznitem.hxx>
+#include <svx/ulspitem.hxx>
+#include <svx/lrspitem.hxx>
+#include <svx/brkitem.hxx>
+#include <svx/keepitem.hxx>
+#include <svx/dialmgr.hxx>
+#ifndef _SVX_PARAVERTALIGNITEM_HXX
+#include <svx/paravertalignitem.hxx>
+#endif
+#include <svtools/eitem.hxx> //add CHINA001
+#include <sfx2/request.hxx> //add CHINA001
+#include <svtools/intitem.hxx> //add CHINA001
+
+// static ----------------------------------------------------------------
+
+static USHORT pStdRanges[] =
+{
+    SID_ATTR_PARA_LINESPACE,        // 10033
+    SID_ATTR_PARA_LINESPACE,
+    SID_ATTR_LRSPACE,                // 10048 -
+    SID_ATTR_ULSPACE,                // 10049
+    SID_ATTR_PARA_REGISTER,            // 10413
+    SID_ATTR_PARA_REGISTER,
+    0
+};
+
+static USHORT pAlignRanges[] =
+{
+    SID_ATTR_PARA_ADJUST,            // 10027
+    SID_ATTR_PARA_ADJUST,
+    0
+};
+
+static USHORT pExtRanges[] =
+{
+    SID_ATTR_PARA_PAGEBREAK,        // 10037 -
+    SID_ATTR_PARA_WIDOWS,            // 10041
+    SID_ATTR_PARA_MODEL,            // 10065 -
+    SID_ATTR_PARA_KEEP,                // 10066
+    0
+};
+
+// define ----------------------------------------------------------------
+
+#define MAX_DURCH 5670      // 10 cm ist sinnvoll als maximaler Durchschuss
+                            // laut BP
+#define FIX_DIST_DEF 283    // Standard-Fix-Abstand 0,5cm
+
+// enum ------------------------------------------------------------------
+
+enum LineSpaceList
+{
+    LLINESPACE_1    = 0,
+    LLINESPACE_15   = 1,
+    LLINESPACE_2    = 2,
+    LLINESPACE_PROP = 3,
+    LLINESPACE_MIN  = 4,
+    LLINESPACE_DURCH= 5,
+    LLINESPACE_FIX     = 6,
+    LLINESPACE_END
+};
+
+// C-Funktion ------------------------------------------------------------
+
+void SetLineSpace_Impl( SvxLineSpacingItem&, int, long lValue = 0 );
+
+void SetLineSpace_Impl( SvxLineSpacingItem& rLineSpace,
+                        int eSpace, long lValue )
+{
+    switch ( eSpace )
+    {
+        case LLINESPACE_1:
+            rLineSpace.GetLineSpaceRule() = SVX_LINE_SPACE_AUTO;
+            rLineSpace.GetInterLineSpaceRule() = SVX_INTER_LINE_SPACE_OFF;
+            break;
+
+        case LLINESPACE_15:
+            rLineSpace.GetLineSpaceRule() = SVX_LINE_SPACE_AUTO;
+            rLineSpace.SetPropLineSpace( 150 );
+            break;
+
+        case LLINESPACE_2:
+            rLineSpace.GetLineSpaceRule() = SVX_LINE_SPACE_AUTO;
+            rLineSpace.SetPropLineSpace( 200 );
+            break;
+
+        case LLINESPACE_PROP:
+            rLineSpace.GetLineSpaceRule() = SVX_LINE_SPACE_AUTO;
+            rLineSpace.SetPropLineSpace( (BYTE)lValue );
+            break;
+
+        case LLINESPACE_MIN:
+            rLineSpace.SetLineHeight( (USHORT)lValue );
+            rLineSpace.GetInterLineSpaceRule() = SVX_INTER_LINE_SPACE_OFF;
+            break;
+
+        case LLINESPACE_DURCH:
+            rLineSpace.GetLineSpaceRule() = SVX_LINE_SPACE_AUTO;
+            rLineSpace.SetInterLineSpace( (USHORT)lValue );
+            break;
+
+        case LLINESPACE_FIX:
+            rLineSpace.SetLineHeight((USHORT)lValue);
+            rLineSpace.GetLineSpaceRule() = SVX_LINE_SPACE_FIX;
+            rLineSpace.GetInterLineSpaceRule() = SVX_INTER_LINE_SPACE_OFF;
+        break;
+    }
+}
+
+
+USHORT GetHtmlMode_Impl(const SfxItemSet& rSet)
+{
+    USHORT nHtmlMode = 0;
+    const SfxPoolItem* pItem = 0;
+    SfxObjectShell* pShell;
+    if(SFX_ITEM_SET == rSet.GetItemState(SID_HTML_MODE, FALSE, &pItem) ||
+        ( 0 != (pShell = SfxObjectShell::Current()) &&
+                    0 != (pItem = pShell->GetItem(SID_HTML_MODE))))
+    {
+        nHtmlMode = ((SfxUInt16Item*)pItem)->GetValue();
+    }
+    return nHtmlMode;
+
+}
+
+// class SvxStdParagraphTabPage ------------------------------------------
+
+IMPL_LINK( SvxStdParagraphTabPage, ELRLoseFocusHdl, Edit *, EMPTYARG )
+{
+//! if ( aLeftIndent.IsRelativeMode() )
+//!     return 0; //!!!
+
+    SfxItemPool* pPool = GetItemSet().GetPool();
+    DBG_ASSERT( pPool, "Wo ist der Pool" );
+    FieldUnit eUnit =
+        MapToFieldUnit( pPool->GetMetric( GetWhich( SID_ATTR_LRSPACE ) ) );
+
+    sal_Int64 nL = aLeftIndent.Denormalize( aLeftIndent.GetValue( eUnit ) );
+    sal_Int64 nR = aRightIndent.Denormalize( aRightIndent.GetValue( eUnit ) );
+    String aTmp = aFLineIndent.GetText();
+
+    // Erstzeilen Einzug
+    if( aLeftIndent.GetMin() < 0 )
+        aFLineIndent.SetMin( -99999, FUNIT_MM );
+    else
+        aFLineIndent.SetMin( aFLineIndent.Normalize( -nL ), eUnit );
+
+    // Check nur fuer konkrete Breite (Shell)
+    sal_Int64 nTmp = nWidth - nL - nR - MM50;
+    aFLineIndent.SetMax( aFLineIndent.Normalize( nTmp ), eUnit );
+
+    if ( !aTmp.Len() )
+        aFLineIndent.SetEmptyFieldValue();
+    // Maximum Links Rechts
+    aTmp = aLeftIndent.GetText();
+    nTmp = nWidth - nR - MM50;
+    aLeftIndent.SetMax( aLeftIndent.Normalize( nTmp ), eUnit );
+
+    if ( !aTmp.Len() )
+        aLeftIndent.SetEmptyFieldValue();
+    aTmp = aRightIndent.GetText();
+    nTmp = nWidth - nL - MM50;
+    aRightIndent.SetMax( aRightIndent.Normalize( nTmp ), eUnit );
+
+    if ( !aTmp.Len() )
+        aRightIndent.SetEmptyFieldValue();
+    return 0;
+}
+
+// -----------------------------------------------------------------------
+
+SfxTabPage* SvxStdParagraphTabPage::Create( Window* pParent,
+                                            const SfxItemSet& rSet)
+{
+    return new SvxStdParagraphTabPage( pParent, rSet );
+}
+
+// -----------------------------------------------------------------------
+
+BOOL SvxStdParagraphTabPage::FillItemSet( SfxItemSet& rOutSet )
+{
+    SfxItemState eState = SFX_ITEM_UNKNOWN;
+    const SfxPoolItem* pOld = 0;
+    SfxItemPool* pPool = rOutSet.GetPool();
+    DBG_ASSERT( pPool, "Wo ist der Pool" );
+
+    BOOL bModified = FALSE;
+    USHORT nWhich;
+    USHORT nPos = aLineDist.GetSelectEntryPos();
+
+    if ( LISTBOX_ENTRY_NOTFOUND != nPos &&
+         ( nPos != aLineDist.GetSavedValue() ||
+           aLineDistAtPercentBox.IsValueModified() ||
+           aLineDistAtMetricBox.IsValueModified() ) )
+    {
+        nWhich = GetWhich( SID_ATTR_PARA_LINESPACE );
+        SfxMapUnit eUnit = pPool->GetMetric( nWhich );
+        SvxLineSpacingItem aSpacing(
+            (const SvxLineSpacingItem&)GetItemSet().Get( nWhich ) );
+
+        switch ( nPos )
+        {
+            case LLINESPACE_1:
+            case LLINESPACE_15:
+            case LLINESPACE_2:
+                SetLineSpace_Impl( aSpacing, nPos );
+                break;
+
+            case LLINESPACE_PROP:
+                SetLineSpace_Impl( aSpacing, nPos,
+                                   static_cast<long>(aLineDistAtPercentBox.Denormalize(
+                                   aLineDistAtPercentBox.GetValue() )) );
+                break;
+
+            case LLINESPACE_MIN:
+            case LLINESPACE_DURCH:
+            case LLINESPACE_FIX:
+                SetLineSpace_Impl( aSpacing, nPos,
+                    GetCoreValue( aLineDistAtMetricBox, eUnit ) );
+            break;
+
+            default:
+                DBG_ERROR( "unbekannter Type fuer Zeilenabstand." );
+                break;
+        }
+        eState = GetItemSet().GetItemState( nWhich );
+        pOld = GetOldItem( rOutSet, SID_ATTR_PARA_LINESPACE );
+
+        if ( !pOld || !( *(const SvxLineSpacingItem*)pOld == aSpacing ) ||
+             SFX_ITEM_DONTCARE == eState )
+        {
+            rOutSet.Put( aSpacing );
+            bModified |= TRUE;
+        }
+    }
+
+    if ( aTopDist.IsValueModified() || aBottomDist.IsValueModified() )
+    {
+        nWhich = GetWhich( SID_ATTR_ULSPACE );
+        SfxMapUnit eUnit = pPool->GetMetric( nWhich );
+        pOld = GetOldItem( rOutSet, SID_ATTR_ULSPACE );
+        SvxULSpaceItem aMargin( nWhich );
+
+        if ( bRelativeMode )
+        {
+            DBG_ASSERT( GetItemSet().GetParent(), "No ParentSet" );
+
+            const SvxULSpaceItem& rOldItem =
+                (const SvxULSpaceItem&)GetItemSet().GetParent()->Get( nWhich );
+
+            if ( aTopDist.IsRelative() )
+                aMargin.SetUpper( rOldItem.GetUpper(),
+                                  (USHORT)aTopDist.GetValue() );
+            else
+                aMargin.SetUpper( (USHORT)GetCoreValue( aTopDist, eUnit ) );
+
+            if ( aBottomDist.IsRelative() )
+                aMargin.SetLower( rOldItem.GetLower(),
+                                  (USHORT)aBottomDist.GetValue() );
+            else
+                aMargin.SetLower( (USHORT)GetCoreValue( aBottomDist, eUnit ) );
+
+        }
+        else
+        {
+            aMargin.SetUpper( (USHORT)GetCoreValue( aTopDist, eUnit ) );
+            aMargin.SetLower( (USHORT)GetCoreValue( aBottomDist, eUnit ) );
+        }
+        eState = GetItemSet().GetItemState( nWhich );
+
+        if ( !pOld || !( *(const SvxULSpaceItem*)pOld == aMargin ) ||
+             SFX_ITEM_DONTCARE == eState )
+        {
+            rOutSet.Put( aMargin );
+            bModified |= TRUE;
+        }
+    }
+    FASTBOOL bNullTab = FALSE;
+
+    if ( aLeftIndent.IsValueModified() ||
+         aFLineIndent.IsValueModified() ||
+         aRightIndent.IsValueModified()
+         ||     aAutoCB.GetSavedValue() != aAutoCB.IsChecked() )
+    {
+        nWhich = GetWhich( SID_ATTR_LRSPACE );
+        SfxMapUnit eUnit = pPool->GetMetric( nWhich );
+        SvxLRSpaceItem aMargin( nWhich );
+        pOld = GetOldItem( rOutSet, SID_ATTR_LRSPACE );
+
+        if ( bRelativeMode )
+        {
+            DBG_ASSERT( GetItemSet().GetParent(), "No ParentSet" );
+
+            const SvxLRSpaceItem& rOldItem =
+                (const SvxLRSpaceItem&)GetItemSet().GetParent()->Get( nWhich );
+
+            if ( aLeftIndent.IsRelative() )
+                aMargin.SetTxtLeft( rOldItem.GetTxtLeft(),
+                                    (USHORT)aLeftIndent.GetValue() );
+            else
+                aMargin.SetTxtLeft( GetCoreValue( aLeftIndent, eUnit ) );
+
+            if ( aRightIndent.IsRelative() )
+                aMargin.SetRight( rOldItem.GetRight(),
+                                  (USHORT)aRightIndent.GetValue() );
+            else
+                aMargin.SetRight( GetCoreValue( aRightIndent, eUnit ) );
+
+            if ( aFLineIndent.IsRelative() )
+                aMargin.SetTxtFirstLineOfst( rOldItem.GetTxtFirstLineOfst(),
+                                             (USHORT)aFLineIndent.GetValue() );
+            else
+                aMargin.SetTxtFirstLineOfst(
+                    (USHORT)GetCoreValue( aFLineIndent, eUnit ) );
+        }
+        else
+        {
+            aMargin.SetTxtLeft( GetCoreValue( aLeftIndent, eUnit ) );
+            aMargin.SetRight( GetCoreValue( aRightIndent, eUnit ) );
+            aMargin.SetTxtFirstLineOfst(
+                (USHORT)GetCoreValue( aFLineIndent, eUnit ) );
+        }
+        aMargin.SetAutoFirst(aAutoCB.IsChecked());
+        if ( aMargin.GetTxtFirstLineOfst() < 0 )
+            bNullTab = TRUE;
+        eState = GetItemSet().GetItemState( nWhich );
+
+        if ( !pOld || !( *(const SvxLRSpaceItem*)pOld == aMargin ) ||
+             SFX_ITEM_DONTCARE == eState )
+        {
+            rOutSet.Put( aMargin );
+            bModified |= TRUE;
+        }
+    }
+
+    if ( bNullTab )
+    {
+        MapUnit eUnit = (MapUnit)pPool->GetMetric( GetWhich( SID_ATTR_TABSTOP ) );
+        if ( MAP_100TH_MM != eUnit )
+        {
+
+            // negativer Erstzeileneinzug -> ggf. Null Default-Tabstop setzen
+            USHORT _nWhich = GetWhich( SID_ATTR_TABSTOP );
+            const SfxItemSet& rInSet = GetItemSet();
+
+            if ( rInSet.GetItemState( _nWhich ) >= SFX_ITEM_AVAILABLE )
+            {
+                const SvxTabStopItem& rTabItem =
+                    (const SvxTabStopItem&)rInSet.Get( _nWhich );
+                SvxTabStopItem aNullTab( rTabItem );
+                SvxTabStop aNull( 0, SVX_TAB_ADJUST_DEFAULT );
+                aNullTab.Insert( aNull );
+                rOutSet.Put( aNullTab );
+            }
+        }
+    }
+    if( aRegisterCB.IsVisible())
+    {
+        const SfxBoolItem* pBoolItem = (SfxBoolItem*)GetOldItem(
+                            rOutSet, SID_ATTR_PARA_REGISTER);
+        SfxBoolItem* pRegItem = (SfxBoolItem*)pBoolItem->Clone();
+        USHORT _nWhich = GetWhich( SID_ATTR_PARA_REGISTER );
+        BOOL bSet = pRegItem->GetValue();
+
+        if(aRegisterCB.IsChecked() != bSet )
+        {
+            pRegItem->SetValue(!bSet);
+            rOutSet.Put(*pRegItem);
+            bModified |= TRUE;
+        }
+        else if ( SFX_ITEM_DEFAULT == GetItemSet().GetItemState( _nWhich, FALSE ) )
+            rOutSet.ClearItem(_nWhich);
+        delete pRegItem;
+    }
+
+    return bModified;
+}
+
+// -----------------------------------------------------------------------
+
+void SvxStdParagraphTabPage::Reset( const SfxItemSet& rSet )
+{
+    SfxItemPool* pPool = rSet.GetPool();
+    DBG_ASSERT( pPool, "Wo ist der Pool?" );
+    String aEmpty;
+
+    // Metrik einstellen
+    FieldUnit eFUnit = GetModuleFieldUnit( &rSet );
+    SetFieldUnit( aLeftIndent, eFUnit );
+    SetFieldUnit( aRightIndent, eFUnit );
+    SetFieldUnit( aFLineIndent, eFUnit );
+    SetFieldUnit( aTopDist, eFUnit );
+    SetFieldUnit( aBottomDist, eFUnit );
+    SetFieldUnit( aLineDistAtMetricBox, eFUnit );
+
+    USHORT _nWhich = GetWhich( SID_ATTR_LRSPACE );
+    SfxItemState eItemState = rSet.GetItemState( _nWhich );
+
+    if ( eItemState >= SFX_ITEM_AVAILABLE )
+    {
+        SfxMapUnit eUnit = pPool->GetMetric( _nWhich );
+
+        if ( bRelativeMode )
+        {
+            const SvxLRSpaceItem& rOldItem =
+                (const SvxLRSpaceItem&)rSet.Get( _nWhich );
+
+            if ( rOldItem.GetPropLeft() != 100 )
+            {
+                aLeftIndent.SetRelative( TRUE );
+                aLeftIndent.SetValue( rOldItem.GetPropLeft() );
+            }
+            else
+            {
+                aLeftIndent.SetRelative();
+                SetFieldUnit( aLeftIndent, eFUnit );
+                SetMetricValue( aLeftIndent, rOldItem.GetTxtLeft(), eUnit );
+            }
+
+            if ( rOldItem.GetPropRight() != 100 )
+            {
+                aRightIndent.SetRelative( TRUE );
+                aRightIndent.SetValue( rOldItem.GetPropRight() );
+            }
+            else
+            {
+                aRightIndent.SetRelative();
+                SetFieldUnit( aRightIndent, eFUnit );
+                SetMetricValue( aRightIndent, rOldItem.GetRight(), eUnit );
+            }
+
+            if ( rOldItem.GetPropTxtFirstLineOfst() != 100 )
+            {
+                aFLineIndent.SetRelative( TRUE );
+                aFLineIndent.SetValue( rOldItem.GetPropTxtFirstLineOfst() );
+            }
+            else
+            {
+                aFLineIndent.SetRelative();
+                aFLineIndent.SetMin(-9999);
+                SetFieldUnit( aFLineIndent, eFUnit );
+                SetMetricValue( aFLineIndent, rOldItem.GetTxtFirstLineOfst(),
+                                eUnit );
+            }
+            aAutoCB.Check(rOldItem.IsAutoFirst());
+        }
+        else
+        {
+            const SvxLRSpaceItem& rSpace =
+                (const SvxLRSpaceItem&)rSet.Get( _nWhich );
+
+            SetMetricValue( aLeftIndent, rSpace.GetTxtLeft(), eUnit );
+            SetMetricValue( aRightIndent, rSpace.GetRight(), eUnit );
+            SetMetricValue( aFLineIndent, rSpace.GetTxtFirstLineOfst(), eUnit );
+            aAutoCB.Check(rSpace.IsAutoFirst());
+        }
+        AutoHdl_Impl(&aAutoCB);
+    }
+    else
+    {
+        aLeftIndent.SetEmptyFieldValue();
+        aRightIndent.SetEmptyFieldValue();
+        aFLineIndent.SetEmptyFieldValue();
+    }
+
+    _nWhich = GetWhich( SID_ATTR_ULSPACE );
+    eItemState = rSet.GetItemState( _nWhich );
+
+    if ( eItemState >= SFX_ITEM_AVAILABLE )
+    {
+        SfxMapUnit eUnit = pPool->GetMetric( _nWhich );
+
+        if ( bRelativeMode )
+        {
+            const SvxULSpaceItem& rOldItem =
+                (const SvxULSpaceItem&)rSet.Get( _nWhich );
+
+            if ( rOldItem.GetPropUpper() != 100 )
+            {
+                aTopDist.SetRelative( TRUE );
+                aTopDist.SetValue( rOldItem.GetPropUpper() );
+            }
+            else
+            {
+                aTopDist.SetRelative();
+                SetFieldUnit( aTopDist, eFUnit );
+                SetMetricValue( aTopDist, rOldItem.GetUpper(), eUnit );
+            }
+
+            if ( rOldItem.GetPropLower() != 100 )
+            {
+                aBottomDist.SetRelative( TRUE );
+                aBottomDist.SetValue( rOldItem.GetPropLower() );
+            }
+            else
+            {
+                aBottomDist.SetRelative();
+                SetFieldUnit( aBottomDist, eFUnit );
+                SetMetricValue( aBottomDist, rOldItem.GetLower(), eUnit );
+            }
+        }
+        else
+        {
+            const SvxULSpaceItem& rTopMargin =
+                (const SvxULSpaceItem&)rSet.Get( _nWhich );
+            SetMetricValue( aTopDist, rTopMargin.GetUpper(), eUnit );
+            SetMetricValue( aBottomDist, rTopMargin.GetLower(), eUnit );
+        }
+    }
+    else
+    {
+        aTopDist.SetEmptyFieldValue();
+        aBottomDist.SetEmptyFieldValue();
+    }
+
+    _nWhich = GetWhich( SID_ATTR_PARA_LINESPACE );
+    eItemState = rSet.GetItemState( _nWhich );
+
+    if ( eItemState >= SFX_ITEM_AVAILABLE )
+        SetLineSpacing_Impl( (const SvxLineSpacingItem &)rSet.Get( _nWhich ) );
+    else
+        aLineDist.SetNoSelection();
+
+
+    _nWhich = GetWhich( SID_ATTR_PARA_REGISTER );
+    eItemState = rSet.GetItemState( _nWhich );
+
+    if ( eItemState >= SFX_ITEM_AVAILABLE )
+        aRegisterCB.Check( ((const SfxBoolItem &)rSet.Get( _nWhich )).GetValue());
+    aRegisterCB.SaveValue();
+    USHORT nHtmlMode = GetHtmlMode_Impl(rSet);
+    if(nHtmlMode & HTMLMODE_ON)
+    {
+        aRegisterCB.Hide();
+        aRegisterFL.Hide();
+        aAutoCB.Hide();
+        if(!(nHtmlMode & HTMLMODE_SOME_STYLES)) // IE oder SW
+        {
+            aRightLabel.Disable();
+            aRightIndent.Disable();
+            aTopDist.Disable();  //HTML3.2 und NS 3.0
+            aBottomDist.Disable();
+            if(!(nHtmlMode & HTMLMODE_FIRSTLINE)) //NS 3.0
+            {
+                aFLineIndent.Disable();
+                aFLineLabel.Disable();
+            }
+        }
+    }
+
+    ELRLoseFocusHdl( NULL );
+    aAutoCB.SaveValue();
+    aLineDist.SaveValue();
+}
+
+// -----------------------------------------------------------------------
+
+void SvxStdParagraphTabPage::EnableRelativeMode()
+{
+    DBG_ASSERT( GetItemSet().GetParent(), "RelativeMode, but no parent-set!" );
+
+    aLeftIndent.EnableRelativeMode( 0, 999 );
+    aFLineIndent.EnableRelativeMode( 0, 999 );
+    aRightIndent.EnableRelativeMode( 0, 999 );
+    aTopDist.EnableRelativeMode( 0, 999 );
+    aBottomDist.EnableRelativeMode( 0, 999 );
+    bRelativeMode = TRUE;
+}
+
+// -----------------------------------------------------------------------
+
+int SvxStdParagraphTabPage::DeactivatePage( SfxItemSet* _pSet )
+{
+    ELRLoseFocusHdl( NULL );
+
+    if ( _pSet )
+        FillItemSet( *_pSet );
+    return LEAVE_PAGE;
+}
+
+// -----------------------------------------------------------------------
+
+SvxStdParagraphTabPage::SvxStdParagraphTabPage( Window* pParent,
+                                                const SfxItemSet& rAttr ) :
+
+    SfxTabPage( pParent, SVX_RES( RID_SVXPAGE_STD_PARAGRAPH ), rAttr ),
+
+    aLeftLabel              ( this, SVX_RES( FT_LEFTINDENT ) ),
+    aLeftIndent             ( this, SVX_RES( ED_LEFTINDENT ) ),
+    aRightLabel             ( this, SVX_RES( FT_RIGHTINDENT ) ),
+    aRightIndent            ( this, SVX_RES( ED_RIGHTINDENT ) ),
+    
+    aFLineLabel             ( this, SVX_RES( FT_FLINEINDENT ) ),
+    aFLineIndent            ( this, SVX_RES( ED_FLINEINDENT ) ),
+    aAutoCB                 ( this, SVX_RES( CB_AUTO ) ),
+    aIndentFrm              ( this, SVX_RES( FL_INDENT ) ),
+    aTopLabel               ( this, SVX_RES( FT_TOPDIST ) ),
+    aTopDist                ( this, SVX_RES( ED_TOPDIST ) ),
+    aBottomLabel            ( this, SVX_RES( FT_BOTTOMDIST ) ),
+    aBottomDist             ( this, SVX_RES( ED_BOTTOMDIST ) ),
+    aDistFrm                ( this, SVX_RES( FL_DIST ) ),
+    aLineDist               ( this, SVX_RES( LB_LINEDIST ) ),
+    aLineDistAtLabel        ( this, SVX_RES( FT_LINEDIST ) ),
+    aLineDistAtPercentBox   ( this, SVX_RES( ED_LINEDISTPERCENT ) ),
+    aLineDistAtMetricBox    ( this, SVX_RES( ED_LINEDISTMETRIC ) ),
+    aLineDistFrm            ( this, SVX_RES( FL_LINEDIST ) ),
+    sAbsDist                ( SVX_RES(ST_LINEDIST_ABS) ),
+    aExampleWin             ( this, SVX_RES( WN_EXAMPLE ) ),
+    aRegisterCB             ( this, SVX_RES( CB_REGISTER ) ),
+    aRegisterFL             ( this, SVX_RES( FL_REGISTER ) ),
+    pActLineDistFld ( &aLineDistAtPercentBox ),
+    nAbst           ( MAX_DURCH ),
+    nWidth          ( 11905 /*567 * 50*/ ),
+    nMinFixDist(0L),
+
+    bRelativeMode   ( FALSE ),
+    bNegativeIndents(FALSE)
+
+{
+    // diese Page braucht ExchangeSupport
+    SetExchangeSupport();
+
+    aLineDistAtMetricBox.Hide();
+    FreeResource();
+    Init_Impl();
+    aFLineIndent.SetMin(-9999);    // wird default auf 0 gesetzt
+}
+
+
+// -----------------------------------------------------------------------
+
+void SvxStdParagraphTabPage::EnableNegativeMode()
+{
+    aLeftIndent.SetMin(-9999);
+    aRightIndent.SetMin(-9999);
+#if SUPD>629
+    aRightIndent.EnableNegativeMode();
+    aLeftIndent.EnableNegativeMode();
+#endif
+    bNegativeIndents = TRUE;
+}
+
+// -----------------------------------------------------------------------
+
+USHORT* SvxStdParagraphTabPage::GetRanges()
+{
+    return pStdRanges;
+}
+
+// -----------------------------------------------------------------------
+
+void SvxStdParagraphTabPage::SetLineSpacing_Impl
+(
+    const SvxLineSpacingItem &rAttr
+)
+{
+    SfxMapUnit eUnit = GetItemSet().GetPool()->GetMetric( rAttr.Which() );
+
+    switch( rAttr.GetLineSpaceRule() )
+    {
+        case SVX_LINE_SPACE_AUTO:
+        {
+            SvxInterLineSpace eInter = rAttr.GetInterLineSpaceRule();
+
+            switch( eInter )
+            {
+                // Default einzeilig
+                case SVX_INTER_LINE_SPACE_OFF:
+                    aLineDist.SelectEntryPos( LLINESPACE_1 );
+                    break;
+
+                // Default einzeilig
+                case SVX_INTER_LINE_SPACE_PROP:
+                    if ( 100 == rAttr.GetPropLineSpace() )
+                    {
+                        aLineDist.SelectEntryPos( LLINESPACE_1 );
+                        break;
+                    }
+                    // 1.5zeilig
+                    if ( 150 == rAttr.GetPropLineSpace() )
+                    {
+                        aLineDist.SelectEntryPos( LLINESPACE_15 );
+                        break;
+                    }
+                    // 2zeilig
+                    if ( 200 == rAttr.GetPropLineSpace() )
+                    {
+                        aLineDist.SelectEntryPos( LLINESPACE_2 );
+                        break;
+                    }
+                    // eingestellter Prozentwert
+                    aLineDistAtPercentBox.
+                        SetValue( aLineDistAtPercentBox.Normalize(
+                                        rAttr.GetPropLineSpace() ) );
+                    aLineDist.SelectEntryPos( LLINESPACE_PROP );
+                    break;
+
+                case SVX_INTER_LINE_SPACE_FIX:
+                    SetMetricValue( aLineDistAtMetricBox,
+                                    rAttr.GetInterLineSpace(), eUnit );
+                    aLineDist.SelectEntryPos( LLINESPACE_DURCH );
+                    break;
+                default: ;//prevent warning
+            }
+        }
+        break;
+        case SVX_LINE_SPACE_FIX:
+            SetMetricValue(aLineDistAtMetricBox, rAttr.GetLineHeight(), eUnit);
+            aLineDist.SelectEntryPos( LLINESPACE_FIX );
+        break;
+
+        case SVX_LINE_SPACE_MIN:
+            SetMetricValue(aLineDistAtMetricBox, rAttr.GetLineHeight(), eUnit);
+            aLineDist.SelectEntryPos( LLINESPACE_MIN );
+            break;
+        default: ;//prevent warning
+    }
+    LineDistHdl_Impl( &aLineDist );
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxStdParagraphTabPage, LineDistHdl_Impl, ListBox *, pBox )
+{
+    switch( pBox->GetSelectEntryPos() )
+    {
+        case LLINESPACE_1:
+        case LLINESPACE_15:
+        case LLINESPACE_2:
+            aLineDistAtLabel.Enable(FALSE);
+            pActLineDistFld->Enable(FALSE);
+            pActLineDistFld->SetText( String() );
+            break;
+
+        case LLINESPACE_DURCH:
+            // Setzen eines sinnvollen Defaults?
+            // MS Begrenzen min(10, aPageSize)
+            aLineDistAtPercentBox.Hide();
+            pActLineDistFld = &aLineDistAtMetricBox;
+            aLineDistAtMetricBox.SetMin(0);
+
+
+            if ( !aLineDistAtMetricBox.GetText().Len() )
+                aLineDistAtMetricBox.SetValue(
+                    aLineDistAtMetricBox.Normalize( 1 ) );
+            aLineDistAtPercentBox.Hide();
+            pActLineDistFld->Show();
+            pActLineDistFld->Enable();
+            aLineDistAtLabel.Enable();
+            break;
+
+        case LLINESPACE_MIN:
+            aLineDistAtPercentBox.Hide();
+            pActLineDistFld = &aLineDistAtMetricBox;
+            aLineDistAtMetricBox.SetMin(0);
+
+            if ( !aLineDistAtMetricBox.GetText().Len() )
+                aLineDistAtMetricBox.SetValue(
+                    aLineDistAtMetricBox.Normalize( 10 ), FUNIT_TWIP );
+            aLineDistAtPercentBox.Hide();
+            pActLineDistFld->Show();
+            pActLineDistFld->Enable();
+            aLineDistAtLabel.Enable();
+            break;
+
+        case LLINESPACE_PROP:
+            aLineDistAtMetricBox.Hide();
+            pActLineDistFld = &aLineDistAtPercentBox;
+
+            if ( !aLineDistAtPercentBox.GetText().Len() )
+                aLineDistAtPercentBox.SetValue(
+                    aLineDistAtPercentBox.Normalize( 100 ), FUNIT_TWIP );
+            aLineDistAtMetricBox.Hide();
+            pActLineDistFld->Show();
+            pActLineDistFld->Enable();
+            aLineDistAtLabel.Enable();
+            break;
+        case LLINESPACE_FIX:
+        {
+            aLineDistAtPercentBox.Hide();
+            pActLineDistFld = &aLineDistAtMetricBox;
+            sal_Int64 nTemp = aLineDistAtMetricBox.GetValue();
+            aLineDistAtMetricBox.SetMin(aLineDistAtMetricBox.Normalize(nMinFixDist), FUNIT_TWIP);
+
+            // wurde der Wert beim SetMin veraendert, dann ist es Zeit
+            // fuer den default
+            if ( aLineDistAtMetricBox.GetValue() != nTemp )
+                SetMetricValue( aLineDistAtMetricBox,
+                                    FIX_DIST_DEF, SFX_MAPUNIT_TWIP ); // fix gibt's nur im Writer
+            aLineDistAtPercentBox.Hide();
+            pActLineDistFld->Show();
+            pActLineDistFld->Enable();
+            aLineDistAtLabel.Enable();
+        }
+        break;
+    }
+    UpdateExample_Impl( TRUE );
+    return 0;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK_INLINE_START( SvxStdParagraphTabPage, ModifyHdl_Impl, SvxRelativeField *, EMPTYARG )
+{
+    UpdateExample_Impl();
+    return 0;
+}
+IMPL_LINK_INLINE_END( SvxStdParagraphTabPage, ModifyHdl_Impl, SvxRelativeField *, EMPTYARG )
+
+// -----------------------------------------------------------------------
+
+void SvxStdParagraphTabPage::Init_Impl()
+{
+    aLineDist.SetSelectHdl(
+        LINK( this, SvxStdParagraphTabPage, LineDistHdl_Impl ) );
+
+    Link aLink = LINK( this, SvxStdParagraphTabPage, ELRLoseFocusHdl );
+    aFLineIndent.SetLoseFocusHdl( aLink );
+    aLeftIndent.SetLoseFocusHdl( aLink );
+    aRightIndent.SetLoseFocusHdl( aLink );
+
+    aLink = LINK( this, SvxStdParagraphTabPage, ModifyHdl_Impl );
+    aFLineIndent.SetModifyHdl( aLink );
+    aLeftIndent.SetModifyHdl( aLink );
+    aRightIndent.SetModifyHdl( aLink );
+    aTopDist.SetModifyHdl( aLink );
+    aBottomDist.SetModifyHdl( aLink );
+
+    aAutoCB.SetClickHdl( LINK( this, SvxStdParagraphTabPage, AutoHdl_Impl ));
+    SfxItemPool* pPool = GetItemSet().GetPool();
+    DBG_ASSERT( pPool, "Wo ist der Pool" );
+    FieldUnit eUnit =
+        MapToFieldUnit( pPool->GetMetric( GetWhich( SID_ATTR_LRSPACE ) ) );
+
+    aTopDist.SetMax( aTopDist.Normalize( nAbst ), eUnit );
+    aBottomDist.SetMax( aBottomDist.Normalize( nAbst ), eUnit );
+    aLineDistAtMetricBox.SetMax(
+        aLineDistAtMetricBox.Normalize( nAbst ), eUnit );
+}
+
+// -----------------------------------------------------------------------
+
+void SvxStdParagraphTabPage::UpdateExample_Impl( BOOL bAll )
+{
+    aExampleWin.SetFirstLineOfst(
+        (short)aFLineIndent.Denormalize( aFLineIndent.GetValue( FUNIT_TWIP ) ) );
+    aExampleWin.SetLeftMargin(
+        static_cast<long>(aLeftIndent.Denormalize( aLeftIndent.GetValue( FUNIT_TWIP ) ) ) );
+    aExampleWin.SetRightMargin(
+        static_cast<long>(aRightIndent.Denormalize( aRightIndent.GetValue( FUNIT_TWIP ) ) ) );
+    aExampleWin.SetUpper(
+        (USHORT)aTopDist.Denormalize( aTopDist.GetValue( FUNIT_TWIP ) ) );
+    aExampleWin.SetLower(
+        (USHORT)aBottomDist.Denormalize( aBottomDist.GetValue( FUNIT_TWIP ) ) );
+
+
+
+    USHORT nPos = aLineDist.GetSelectEntryPos();
+
+    switch ( nPos )
+    {
+        case LLINESPACE_1:
+        case LLINESPACE_15:
+        case LLINESPACE_2:
+            aExampleWin.SetLineSpace( (SvxPrevLineSpace)nPos );
+            break;
+
+        case LLINESPACE_PROP:
+            aExampleWin.SetLineSpace( (SvxPrevLineSpace)nPos,
+                (USHORT)aLineDistAtPercentBox.Denormalize(
+                aLineDistAtPercentBox.GetValue() ) );
+            break;
+
+        case LLINESPACE_MIN:
+        case LLINESPACE_DURCH:
+        case LLINESPACE_FIX:
+            aExampleWin.SetLineSpace( (SvxPrevLineSpace)nPos,
+                (USHORT)GetCoreValue( aLineDistAtMetricBox, SFX_MAPUNIT_TWIP ) );
+            break;
+    }
+    aExampleWin.Draw( bAll );
+}
+
+// -----------------------------------------------------------------------
+
+void SvxStdParagraphTabPage::EnableRegisterMode()
+{
+    aRegisterCB.Show();
+    aRegisterFL.Show();
+}
+
+/*-----------------16.01.97 19.54-------------------
+
+--------------------------------------------------*/
+IMPL_LINK( SvxStdParagraphTabPage, AutoHdl_Impl, CheckBox*, pBox )
+{
+    BOOL bEnable = !pBox->IsChecked();
+    aFLineLabel .Enable(bEnable);
+    aFLineIndent.Enable(bEnable);
+    return 0;
+}
+
+/*-----------------16.01.97 18.00-------------------
+
+--------------------------------------------------*/
+void SvxStdParagraphTabPage::SetPageWidth( USHORT nPageWidth )
+{
+    nWidth = nPageWidth;
+}
+/*-----------------16.01.97 18.01-------------------
+
+--------------------------------------------------*/
+void SvxStdParagraphTabPage::SetMaxDistance( USHORT nMaxDist )
+{
+    nAbst = nMaxDist;
+}
+
+/*-----------------17.01.97 08.11-------------------
+
+--------------------------------------------------*/
+void SvxStdParagraphTabPage::EnableAutoFirstLine()
+{
+    aAutoCB.Show();
+}
+
+/*-----------------11.06.97 11.48-------------------
+    absoluter Zeilenabstand
+--------------------------------------------------*/
+void    SvxStdParagraphTabPage::EnableAbsLineDist(long nMinTwip)
+{
+    aLineDist.InsertEntry(sAbsDist);
+    nMinFixDist = nMinTwip;
+}
+
+//addd CHINA001 begin
+void    SvxStdParagraphTabPage::PageCreated(SfxAllItemSet aSet)
+{
+
+/* CHINA001 different bit represent call to different method of SvxStdParagraphTabPage
+                        0x0001 --->EnableRelativeMode()
+                        0x0002 --->EnableRegisterMode()
+                        0x0004 --->EnableAutoFirstLine()
+                        0x0008 --->EnableNegativeMode()
+
+
+            */
+    SFX_ITEMSET_ARG    (&aSet,pPageWidthItem,SfxUInt16Item,SID_SVXSTDPARAGRAPHTABPAGE_PAGEWIDTH,sal_False);
+    SFX_ITEMSET_ARG    (&aSet,pFlagSetItem,SfxUInt32Item,SID_SVXSTDPARAGRAPHTABPAGE_FLAGSET,sal_False);
+    SFX_ITEMSET_ARG    (&aSet,pLineDistItem,SfxUInt32Item,SID_SVXSTDPARAGRAPHTABPAGE_ABSLINEDIST,sal_False);
+
+    if (pPageWidthItem)
+        SetPageWidth(pPageWidthItem->GetValue());
+
+    if (pFlagSetItem )
+        if (( 0x0001 & pFlagSetItem->GetValue())== 0x0001 )
+            EnableRelativeMode();
+
+    if (pFlagSetItem)
+        if (( 0x0002 & pFlagSetItem->GetValue())== 0x0002 )
+                EnableRegisterMode();
+
+    if (pFlagSetItem)
+        if ( ( 0x0004 & pFlagSetItem->GetValue())== 0x0004 )
+            EnableAutoFirstLine();
+
+    if(pLineDistItem)
+        EnableAbsLineDist(pLineDistItem->GetValue());
+
+    if (pFlagSetItem)
+        if    (( 0x0008 & pFlagSetItem->GetValue()) == 0x0008 )
+                EnableNegativeMode();
+
+}
+//end of CHINA001
+
+#define LASTLINEPOS_DEFAULT        0
+#define LASTLINEPOS_LEFT        1
+
+#define LASTLINECOUNT_OLD        3
+#define LASTLINECOUNT_NEW        4
+
+// class SvxParaAlignTabPage ------------------------------------------------
+
+/*-----------------16.01.97 19.34-------------------
+
+--------------------------------------------------*/
+SvxParaAlignTabPage::SvxParaAlignTabPage( Window* pParent, const SfxItemSet& rSet )
+    : SfxTabPage(pParent, SVX_RES( RID_SVXPAGE_ALIGN_PARAGRAPH ),rSet),
+    aAlignFrm           ( this, SVX_RES( FL_ALIGN ) ),
+    aLeft               ( this, SVX_RES( BTN_LEFTALIGN ) ),
+    aRight                ( this, SVX_RES( BTN_RIGHTALIGN ) ),
+    aCenter                ( this, SVX_RES( BTN_CENTERALIGN ) ),
+    aJustify            ( this, SVX_RES( BTN_JUSTIFYALIGN ) ),
+    aLastLineFT         ( this, SVX_RES( FT_LASTLINE ) ),
+    aLastLineLB            ( this, SVX_RES( LB_LASTLINE ) ),
+    aExpandCB            ( this, SVX_RES( CB_EXPAND ) ),
+    aSnapToGridCB        ( this, SVX_RES( CB_SNAP ) ),
+    aExampleWin            ( this, SVX_RES( WN_EXAMPLE ) ),
+
+    aVertAlignFL        ( this, SVX_RES( FL_VERTALIGN ) ),
+    aVertAlignFT        ( this, SVX_RES( FT_VERTALIGN ) ),
+    aVertAlignLB        ( this, SVX_RES( LB_VERTALIGN ) ),
+
+    aPropertiesFL        ( this, SVX_RES( FL_PROPERTIES    )),
+    aTextDirectionFT    ( this, SVX_RES( FT_TEXTDIRECTION )),
+    aTextDirectionLB    ( this, SVX_RES( LB_TEXTDIRECTION ))
+{
+    SvtLanguageOptions aLangOptions;
+    USHORT nLastLinePos = LASTLINEPOS_DEFAULT;
+
+    if ( aLangOptions.IsAsianTypographyEnabled() )
+    {
+        String sLeft(SVX_RES(ST_LEFTALIGN_ASIAN));
+        aLeft.SetText(sLeft);
+        aRight.SetText(String(SVX_RES(ST_RIGHTALIGN_ASIAN)));
+        sLeft = MnemonicGenerator::EraseAllMnemonicChars( sLeft );
+
+        if ( aLastLineLB.GetEntryCount() == LASTLINECOUNT_OLD )
+        {
+            aLastLineLB.RemoveEntry( 0 );
+            aLastLineLB.InsertEntry( sLeft, 0 );
+        }
+        else
+            nLastLinePos = LASTLINEPOS_LEFT;
+    }
+    // remove "Default" or "Left" entry, depends on CJKOptions
+    if ( aLastLineLB.GetEntryCount() == LASTLINECOUNT_NEW )
+        aLastLineLB.RemoveEntry( nLastLinePos );
+
+    FreeResource();
+    Link aLink = LINK( this, SvxParaAlignTabPage, AlignHdl_Impl );
+    aLeft.SetClickHdl( aLink );
+    aRight.SetClickHdl( aLink );
+    aCenter.SetClickHdl( aLink );
+    aJustify.SetClickHdl( aLink );
+    aLastLineLB.SetSelectHdl( LINK( this, SvxParaAlignTabPage, LastLineHdl_Impl ) );
+    aTextDirectionLB.SetSelectHdl( LINK( this, SvxParaAlignTabPage, TextDirectionHdl_Impl ) );
+
+    USHORT nHtmlMode = GetHtmlMode_Impl(rSet);
+    if(!(nHtmlMode & HTMLMODE_ON) || (0 != (nHtmlMode & HTMLMODE_SOME_STYLES)) )
+    {
+        if( aLangOptions.IsCTLFontEnabled() )
+        {
+            aTextDirectionLB.InsertEntryValue( SVX_RESSTR( RID_SVXSTR_FRAMEDIR_LTR ), FRMDIR_HORI_LEFT_TOP );
+            aTextDirectionLB.InsertEntryValue( SVX_RESSTR( RID_SVXSTR_FRAMEDIR_RTL ), FRMDIR_HORI_RIGHT_TOP );
+            aTextDirectionLB.InsertEntryValue( SVX_RESSTR( RID_SVXSTR_FRAMEDIR_SUPER ), FRMDIR_ENVIRONMENT );
+
+            aPropertiesFL.Show();
+            aTextDirectionFT.Show();
+            aTextDirectionLB.Show();
+        }
+    }
+}
+
+/*-----------------16.01.97 19.33-------------------
+
+--------------------------------------------------*/
+SvxParaAlignTabPage::~SvxParaAlignTabPage()
+{
+}
+
+/*-----------------16.01.97 19.33-------------------
+
+--------------------------------------------------*/
+int SvxParaAlignTabPage::DeactivatePage( SfxItemSet* _pSet )
+{
+    if ( _pSet )
+        FillItemSet( *_pSet );
+    return LEAVE_PAGE;
+}
+
+/*-----------------16.01.97 19.33-------------------
+
+--------------------------------------------------*/
+SfxTabPage*    SvxParaAlignTabPage::Create( Window* pParent, const SfxItemSet& rSet )
+{
+    return new SvxParaAlignTabPage(pParent, rSet);
+}
+
+/*-----------------16.01.97 19.33-------------------
+
+--------------------------------------------------*/
+USHORT*    SvxParaAlignTabPage::GetRanges()
+{
+    return pAlignRanges;
+
+}
+
+/*-----------------16.01.97 19.33-------------------
+
+--------------------------------------------------*/
+BOOL SvxParaAlignTabPage::FillItemSet( SfxItemSet& rOutSet )
+{
+    BOOL bModified = FALSE;
+
+    FASTBOOL bAdj = FALSE, bChecked = FALSE;
+    SvxAdjust eAdjust = SVX_ADJUST_LEFT;
+
+    if ( aLeft.IsChecked() )
+    {
+        eAdjust = SVX_ADJUST_LEFT;
+        bAdj = !aLeft.GetSavedValue();
+        bChecked = TRUE;
+    }
+    else if ( aRight.IsChecked() )
+    {
+        eAdjust = SVX_ADJUST_RIGHT;
+        bAdj = !aRight.GetSavedValue();
+        bChecked = TRUE;
+    }
+    else if ( aCenter.IsChecked() )
+    {
+        eAdjust = SVX_ADJUST_CENTER;
+        bAdj = !aCenter.GetSavedValue();
+        bChecked = TRUE;
+    }
+    else if ( aJustify.IsChecked() )
+    {
+        eAdjust = SVX_ADJUST_BLOCK;
+        bAdj = !aJustify.GetSavedValue() ||
+            aExpandCB.IsChecked() != aExpandCB.GetSavedValue() ||
+            aLastLineLB.GetSelectEntryPos() != aLastLineLB.GetSavedValue();
+        bChecked = TRUE;
+    }
+    USHORT _nWhich = GetWhich( SID_ATTR_PARA_ADJUST );
+
+    if ( bAdj )
+    {
+        const SvxAdjustItem* pOld =
+            (const SvxAdjustItem*)GetOldItem( rOutSet, SID_ATTR_PARA_ADJUST );
+        SvxAdjust eOneWord = aExpandCB.IsChecked() ? SVX_ADJUST_BLOCK
+                                                   : SVX_ADJUST_LEFT;
+        USHORT nLBPos = aLastLineLB.GetSelectEntryPos();
+        SvxAdjust eLastBlock = SVX_ADJUST_LEFT;
+
+        if ( 1 == nLBPos )
+            eLastBlock = SVX_ADJUST_CENTER;
+        else if ( 2 == nLBPos )
+            eLastBlock = SVX_ADJUST_BLOCK;
+
+        FASTBOOL bNothingWasChecked =
+            !aLeft.GetSavedValue() && !aRight.GetSavedValue() &&
+            !aCenter.GetSavedValue() && !aJustify.GetSavedValue();
+
+        if ( !pOld || pOld->GetAdjust() != eAdjust ||
+             pOld->GetOneWord() != eOneWord ||
+             pOld->GetLastBlock() != eLastBlock ||
+             ( bChecked && bNothingWasChecked ) )
+        {
+            bModified |= TRUE;
+            SvxAdjustItem aAdj(
+                (const SvxAdjustItem&)GetItemSet().Get( _nWhich ) );
+            aAdj.SetAdjust( eAdjust );
+            aAdj.SetOneWord( eOneWord );
+            aAdj.SetLastBlock( eLastBlock );
+            rOutSet.Put( aAdj );
+        }
+    }
+    if(aSnapToGridCB.IsChecked() != aSnapToGridCB.GetSavedValue())
+    {
+        rOutSet.Put(SvxParaGridItem(aSnapToGridCB.IsChecked(), GetWhich( SID_ATTR_PARA_SNAPTOGRID )));
+        bModified = TRUE;
+    }
+    if(aVertAlignLB.GetSavedValue() != aVertAlignLB.GetSelectEntryPos())
+    {
+        rOutSet.Put(SvxParaVertAlignItem(aVertAlignLB.GetSelectEntryPos(), GetWhich( SID_PARA_VERTALIGN )));
+        bModified = TRUE;
+    }
+
+    if( aTextDirectionLB.IsVisible() )
+    {
+        SvxFrameDirection eDir = aTextDirectionLB.GetSelectEntryValue();
+        if( eDir != aTextDirectionLB.GetSavedValue() )
+        {
+            rOutSet.Put( SvxFrameDirectionItem( eDir, GetWhich( SID_ATTR_FRAMEDIRECTION ) ) );
+            bModified = TRUE;
+        }
+    }
+
+    return bModified;
+}
+
+/*-----------------16.01.97 19.33-------------------
+
+--------------------------------------------------*/
+void SvxParaAlignTabPage::Reset( const SfxItemSet& rSet )
+{
+    USHORT _nWhich = GetWhich( SID_ATTR_PARA_ADJUST );
+    SfxItemState eItemState = rSet.GetItemState( _nWhich );
+
+    USHORT nLBSelect = 0;
+    if ( eItemState >= SFX_ITEM_AVAILABLE )
+    {
+        const SvxAdjustItem& rAdj = (const SvxAdjustItem&)rSet.Get( _nWhich );
+
+        switch ( rAdj.GetAdjust() /*!!! VB fragen rAdj.GetLastBlock()*/ )
+        {
+            case SVX_ADJUST_LEFT: aLeft.Check(); break;
+
+            case SVX_ADJUST_RIGHT: aRight.Check(); break;
+
+            case SVX_ADJUST_CENTER: aCenter.Check(); break;
+
+            case SVX_ADJUST_BLOCK: aJustify.Check(); break;
+            default: ; //prevent warning
+        }
+        BOOL bEnable = aJustify.IsChecked();
+        aLastLineFT.Enable(bEnable);
+        aLastLineLB.Enable(bEnable);
+        aExpandCB  .Enable(bEnable);
+
+        aExpandCB.Check(SVX_ADJUST_BLOCK == rAdj.GetOneWord());
+        switch(rAdj.GetLastBlock())
+        {
+            case SVX_ADJUST_LEFT:  nLBSelect = 0; break;
+
+            case SVX_ADJUST_CENTER: nLBSelect = 1;  break;
+
+            case SVX_ADJUST_BLOCK: nLBSelect = 2;  break;
+            default: ; //prevent warning
+        }
+    }
+    else
+    {
+        aLeft.Check( FALSE );
+        aRight.Check( FALSE );
+        aCenter.Check( FALSE );
+        aJustify.Check( FALSE );
+    }
+    aLastLineLB.SelectEntryPos(nLBSelect);
+
+    USHORT nHtmlMode = GetHtmlMode_Impl(rSet);
+    if(nHtmlMode & HTMLMODE_ON)
+    {
+        aLastLineLB.Hide();
+        aLastLineFT.Hide();
+        aExpandCB.Hide();
+        if(!(nHtmlMode & HTMLMODE_FULL_STYLES|HTMLMODE_FIRSTLINE) )
+            aJustify.Disable();
+        aSnapToGridCB.Show(FALSE);
+    }
+    _nWhich = GetWhich(SID_ATTR_PARA_SNAPTOGRID);
+    eItemState = rSet.GetItemState( _nWhich );
+    if ( eItemState >= SFX_ITEM_AVAILABLE )
+    {
+        const SvxParaGridItem& rSnap = (const SvxParaGridItem&)rSet.Get( _nWhich );
+        aSnapToGridCB.Check(rSnap.GetValue());
+    }
+
+    _nWhich = GetWhich( SID_PARA_VERTALIGN );
+    eItemState = rSet.GetItemState( _nWhich );
+
+    if ( eItemState >= SFX_ITEM_AVAILABLE )
+    {
+        aVertAlignLB.Show();
+        aVertAlignFL.Show();
+        aVertAlignFT.Show();
+
+        const SvxParaVertAlignItem& rAlign = (const SvxParaVertAlignItem&)rSet.Get( _nWhich );
+        aVertAlignLB.SelectEntryPos(rAlign.GetValue());
+    }
+
+    _nWhich = GetWhich( SID_ATTR_FRAMEDIRECTION );
+    //text direction
+    if( SFX_ITEM_AVAILABLE <= rSet.GetItemState( _nWhich ) )
+    {
+        const SvxFrameDirectionItem& rFrameDirItem = ( const SvxFrameDirectionItem& ) rSet.Get( _nWhich );
+        aTextDirectionLB.SelectEntryValue( (SvxFrameDirection)rFrameDirItem.GetValue() );
+        aTextDirectionLB.SaveValue();
+    }
+
+    aSnapToGridCB.SaveValue();
+    aVertAlignLB.SaveValue();
+    aLeft.SaveValue();
+    aRight.SaveValue();
+    aCenter.SaveValue();
+    aJustify.SaveValue();
+    aLastLineLB.SaveValue();
+    aExpandCB.SaveValue();
+
+    UpdateExample_Impl(TRUE);
+}
+
+/*-----------------17.01.97 08.06-------------------
+
+--------------------------------------------------*/
+IMPL_LINK( SvxParaAlignTabPage, AlignHdl_Impl, RadioButton*, EMPTYARG )
+{
+    BOOL bJustify = aJustify.IsChecked();
+    aLastLineFT.Enable(bJustify);
+    aLastLineLB.Enable(bJustify);
+    aExpandCB.Enable(bJustify);
+    UpdateExample_Impl(FALSE);
+    return 0;
+}
+
+IMPL_LINK( SvxParaAlignTabPage, LastLineHdl_Impl, ListBox*, EMPTYARG )
+{
+    UpdateExample_Impl(FALSE);
+    return 0;
+}
+
+IMPL_LINK( SvxParaAlignTabPage, TextDirectionHdl_Impl, ListBox*, EMPTYARG )
+{
+    SvxFrameDirection eDir = aTextDirectionLB.GetSelectEntryValue();
+    switch ( eDir )
+    {
+        // check the default alignment for this text direction
+        case FRMDIR_HORI_LEFT_TOP :        aLeft.Check( TRUE ); break;
+        case FRMDIR_HORI_RIGHT_TOP :    aRight.Check( TRUE ); break;
+        case FRMDIR_ENVIRONMENT :        /* do nothing */ break;
+        default:
+        {
+            DBG_ERRORFILE( "SvxParaAlignTabPage::TextDirectionHdl_Impl(): other directions not supported" );
+        }
+    }
+
+    return 0;
+}
+
+/*-----------------16.01.97 19.34-------------------
+
+--------------------------------------------------*/
+void    SvxParaAlignTabPage::UpdateExample_Impl( BOOL bAll )
+{
+    if ( aLeft.IsChecked() )
+        aExampleWin.SetAdjust( SVX_ADJUST_LEFT );
+    else if ( aRight.IsChecked() )
+        aExampleWin.SetAdjust( SVX_ADJUST_RIGHT );
+    else if ( aCenter.IsChecked() )
+        aExampleWin.SetAdjust( SVX_ADJUST_CENTER );
+    else if ( aJustify.IsChecked() )
+    {
+        aExampleWin.SetAdjust( SVX_ADJUST_BLOCK );
+        SvxAdjust eLastBlock = SVX_ADJUST_LEFT;
+        USHORT nLBPos = aLastLineLB.GetSelectEntryPos();
+        if(nLBPos == 1)
+            eLastBlock = SVX_ADJUST_CENTER;
+        else if(nLBPos == 2)
+            eLastBlock = SVX_ADJUST_BLOCK;
+        aExampleWin.SetLastLine( eLastBlock );
+    }
+
+    aExampleWin.Draw( bAll );
+}
+/*-----------------17.01.97 08.04-------------------
+    Erweiterungen fuer den Blocksatz einschalten
+--------------------------------------------------*/
+void SvxParaAlignTabPage::EnableJustifyExt()
+{
+    aLastLineFT.Show();
+    aLastLineLB.Show();
+    aExpandCB  .Show();
+    SvtLanguageOptions aCJKOptions;
+    if(aCJKOptions.IsAsianTypographyEnabled())
+        aSnapToGridCB.Show();
+
+}
+//add CHINA001 begin
+void SvxParaAlignTabPage::PageCreated (SfxAllItemSet aSet)
+{
+    SFX_ITEMSET_ARG    (&aSet,pBoolItem,SfxBoolItem,SID_SVXPARAALIGNTABPAGE_ENABLEJUSTIFYEXT,sal_False);
+    if (pBoolItem)
+        if(pBoolItem->GetValue())
+            EnableJustifyExt();
+}
+//end of CHINA001
+// class SvxExtParagraphTabPage ------------------------------------------
+
+SfxTabPage* SvxExtParagraphTabPage::Create( Window* pParent,
+                                            const SfxItemSet& rSet )
+{
+    return new SvxExtParagraphTabPage( pParent, rSet );
+}
+
+// -----------------------------------------------------------------------
+
+BOOL SvxExtParagraphTabPage::FillItemSet( SfxItemSet& rOutSet )
+{
+    BOOL bModified = FALSE;
+    USHORT _nWhich = GetWhich( SID_ATTR_PARA_HYPHENZONE );
+    const TriState eHyphenState = aHyphenBox.GetState();
+    const SfxPoolItem* pOld = GetOldItem( rOutSet, SID_ATTR_PARA_HYPHENZONE );
+
+    if ( eHyphenState != aHyphenBox.GetSavedValue()     ||
+         aExtHyphenBeforeBox.IsValueModified()                ||
+         aExtHyphenAfterBox.IsValueModified()            ||
+         aMaxHyphenEdit.IsValueModified() )
+    {
+        SvxHyphenZoneItem aHyphen(
+            (const SvxHyphenZoneItem&)GetItemSet().Get( _nWhich ) );
+        aHyphen.SetHyphen( eHyphenState == STATE_CHECK );
+
+        if ( eHyphenState == STATE_CHECK )
+        {
+            aHyphen.GetMinLead() = (BYTE)aExtHyphenBeforeBox.GetValue();
+            aHyphen.GetMinTrail() = (BYTE)aExtHyphenAfterBox.GetValue();
+        }
+        aHyphen.GetMaxHyphens() = (BYTE)aMaxHyphenEdit.GetValue();
+
+        if ( !pOld ||
+            !( *(SvxHyphenZoneItem*)pOld == aHyphen ) ||
+                eHyphenState != aHyphenBox.GetSavedValue())
+        {
+            rOutSet.Put( aHyphen );
+            bModified |= TRUE;
+        }
+    }
+
+    if (aPagenumEdit.IsEnabled() && aPagenumEdit.IsValueModified())
+    {
+        SfxUInt16Item aPageNum( SID_ATTR_PARA_PAGENUM,
+                                (USHORT)aPagenumEdit.GetValue() );
+
+        pOld = GetOldItem( rOutSet, SID_ATTR_PARA_PAGENUM );
+
+        if ( !pOld || ( (const SfxUInt16Item*)pOld )->GetValue() != aPageNum.GetValue() )
+        {
+            rOutSet.Put( aPageNum );
+            bModified |= TRUE;
+        }
+    }
+
+    // Seitenumbruch
+
+    TriState eState = aApplyCollBtn.GetState();
+    FASTBOOL bIsPageModel = FALSE;
+
+    _nWhich = GetWhich( SID_ATTR_PARA_MODEL );
+    String sPage;
+    if ( eState != aApplyCollBtn.GetSavedValue() ||
+         ( STATE_CHECK == eState &&
+           aApplyCollBox.GetSelectEntryPos() != aApplyCollBox.GetSavedValue() ) )
+    {
+        if ( eState == STATE_CHECK )
+        {
+            sPage = aApplyCollBox.GetSelectEntry();
+            bIsPageModel = 0 != sPage.Len();
+        }
+        pOld = GetOldItem( rOutSet, SID_ATTR_PARA_MODEL );
+
+        if ( !pOld || ( (const SvxPageModelItem*)pOld )->GetValue() != sPage )
+        {
+            rOutSet.Put( SvxPageModelItem( sPage, FALSE, _nWhich ) );
+            bModified |= TRUE;
+        }
+        else
+            bIsPageModel = FALSE;
+    }
+    else if(STATE_CHECK == eState && aApplyCollBtn.IsEnabled())
+        bIsPageModel = TRUE;
+    else
+        rOutSet.Put( SvxPageModelItem( sPage, FALSE, _nWhich ) );
+
+    _nWhich = GetWhich( SID_ATTR_PARA_PAGEBREAK );
+
+    if ( bIsPageModel )
+        // wird PageModel eingeschaltet, dann immer PageBreak ausschalten
+        rOutSet.Put( SvxFmtBreakItem( SVX_BREAK_NONE, _nWhich ) );
+    else
+    {
+        eState = aPageBreakBox.GetState();
+        SfxItemState eModelState = GetItemSet().GetItemState(SID_ATTR_PARA_MODEL, FALSE);
+
+        if ( (eModelState == SFX_ITEM_SET && STATE_CHECK == aPageBreakBox.GetState()) ||
+             eState != aPageBreakBox.GetSavedValue()                ||
+             aBreakTypeLB.GetSelectEntryPos() != aBreakTypeLB.GetSavedValue()   ||
+             aBreakPositionLB.GetSelectEntryPos() != aBreakPositionLB.GetSavedValue() )
+        {
+            const SvxFmtBreakItem rOldBreak(
+                    (const SvxFmtBreakItem&)GetItemSet().Get( _nWhich ));
+            SvxFmtBreakItem aBreak(rOldBreak.GetBreak(), rOldBreak.Which());
+
+            switch ( eState )
+            {
+                case STATE_CHECK:
+                {
+                    BOOL bBefore = aBreakPositionLB.GetSelectEntryPos() == 0;
+
+                    if ( aBreakTypeLB.GetSelectEntryPos() == 0 )
+                    {
+                        if ( bBefore )
+                            aBreak.SetValue( SVX_BREAK_PAGE_BEFORE );
+                        else
+                            aBreak.SetValue( SVX_BREAK_PAGE_AFTER );
+                    }
+                    else
+                    {
+                        if ( bBefore )
+                            aBreak.SetValue( SVX_BREAK_COLUMN_BEFORE );
+                        else
+                            aBreak.SetValue( SVX_BREAK_COLUMN_AFTER );
+                    }
+                    break;
+                }
+
+                case STATE_NOCHECK:
+                    aBreak.SetValue( SVX_BREAK_NONE );
+                    break;
+                default: ; //prevent warning
+            }
+            pOld = GetOldItem( rOutSet, SID_ATTR_PARA_PAGEBREAK );
+
+            if ( eState != aPageBreakBox.GetSavedValue()                ||
+                    !pOld || !( *(const SvxFmtBreakItem*)pOld == aBreak ) )
+            {
+                bModified |= TRUE;
+                rOutSet.Put( aBreak );
+            }
+        }
+    }
+
+
+    // Absatztrennung
+    _nWhich = GetWhich( SID_ATTR_PARA_SPLIT );
+    eState = aKeepTogetherBox.GetState();
+
+    if ( eState != aKeepTogetherBox.GetSavedValue() )
+    {
+        pOld = GetOldItem( rOutSet, SID_ATTR_PARA_SPLIT );
+
+        if ( !pOld || ( (const SvxFmtSplitItem*)pOld )->GetValue() !=
+                      ( eState == STATE_NOCHECK ) )
+        {
+            rOutSet.Put( SvxFmtSplitItem( eState == STATE_NOCHECK, _nWhich ) );
+            bModified |= TRUE;
+        }
+    }
+
+    // Absaetze zusammenhalten
+    _nWhich = GetWhich( SID_ATTR_PARA_KEEP );
+    eState = aKeepParaBox.GetState();
+
+    if ( eState != aKeepParaBox.GetSavedValue() )
+    {
+        pOld = GetOldItem( rOutSet, SID_ATTR_PARA_KEEP );
+
+        // hat sich der Status geaendert, muss immer geputtet werden
+        rOutSet.Put( SvxFmtKeepItem( eState == STATE_CHECK, _nWhich ) );
+        bModified |= TRUE;
+    }
+
+    // Witwen und Waisen
+    _nWhich = GetWhich( SID_ATTR_PARA_WIDOWS );
+    eState = aWidowBox.GetState();
+
+    if ( eState != aWidowBox.GetSavedValue() ||
+         aWidowRowNo.IsValueModified() )
+    {
+        SvxWidowsItem rItem( eState == STATE_CHECK ?
+                             (BYTE)aWidowRowNo.GetValue() : 0, _nWhich );
+        pOld = GetOldItem( rOutSet, SID_ATTR_PARA_WIDOWS );
+
+        if ( eState != aWidowBox.GetSavedValue() || !pOld || !( *(const SvxWidowsItem*)pOld == rItem ) )
+        {
+            rOutSet.Put( rItem );
+            bModified |= TRUE;
+        }
+    }
+
+    _nWhich = GetWhich( SID_ATTR_PARA_ORPHANS );
+    eState = aOrphanBox.GetState();
+
+    if ( eState != aOrphanBox.GetSavedValue() ||
+         aOrphanRowNo.IsValueModified() )
+    {
+        SvxOrphansItem rItem( eState == STATE_CHECK ?
+                             (BYTE)aOrphanRowNo.GetValue() : 0, _nWhich );
+        pOld = GetOldItem( rOutSet, SID_ATTR_PARA_ORPHANS );
+
+        if ( eState != aOrphanBox.GetSavedValue() ||
+                !pOld ||
+                    !( *(const SvxOrphansItem*)pOld == rItem ) )
+        {
+            rOutSet.Put( rItem );
+            bModified |= TRUE;
+        }
+    }
+
+    return bModified;
+}
+
+// -----------------------------------------------------------------------
+
+void SvxExtParagraphTabPage::Reset( const SfxItemSet& rSet )
+{
+    USHORT _nWhich = GetWhich( SID_ATTR_PARA_HYPHENZONE );
+    SfxItemState eItemState = rSet.GetItemState( _nWhich );
+
+    BOOL bItemAvailable = eItemState >= SFX_ITEM_AVAILABLE;
+    BOOL bIsHyphen = FALSE;
+    if( !bHtmlMode && bItemAvailable )
+    {
+        const SvxHyphenZoneItem& rHyphen =
+            (const SvxHyphenZoneItem&)rSet.Get( _nWhich );
+        aHyphenBox.EnableTriState( FALSE );
+
+        bIsHyphen = rHyphen.IsHyphen();
+        aHyphenBox.SetState( bIsHyphen ? STATE_CHECK : STATE_NOCHECK );
+
+        aExtHyphenBeforeBox.SetValue( rHyphen.GetMinLead() );
+        aExtHyphenAfterBox.SetValue( rHyphen.GetMinTrail() );
+        aMaxHyphenEdit.SetValue( rHyphen.GetMaxHyphens() );
+    }
+    else
+    {
+        aHyphenBox.SetState( STATE_DONTKNOW );
+    }
+    BOOL bEnable = bItemAvailable && bIsHyphen;
+    aExtHyphenBeforeBox.Enable(bEnable);
+    aExtHyphenAfterBox.Enable(bEnable);
+    aBeforeText.Enable(bEnable);
+    aAfterText.Enable(bEnable);
+    aMaxHyphenLabel.Enable(bEnable);
+    aMaxHyphenEdit.Enable(bEnable);
+
+    _nWhich = GetWhich( SID_ATTR_PARA_PAGENUM );
+
+    if ( rSet.GetItemState(_nWhich) >= SFX_ITEM_AVAILABLE )
+    {
+        const USHORT nPageNum =
+            ( (const SfxUInt16Item&)rSet.Get( _nWhich ) ).GetValue();
+        aPagenumEdit.SetValue( nPageNum );
+    }
+
+    if ( bPageBreak )
+    {
+        // zuerst PageModel behandeln
+        _nWhich = GetWhich( SID_ATTR_PARA_MODEL );
+        BOOL bIsPageModel = FALSE;
+        eItemState = rSet.GetItemState( _nWhich );
+
+        if ( eItemState >= SFX_ITEM_SET )
+        {
+            aApplyCollBtn.EnableTriState( FALSE );
+
+            const SvxPageModelItem& rModel =
+                (const SvxPageModelItem&)rSet.Get( _nWhich );
+            String aStr( rModel.GetValue() );
+
+            if ( aStr.Len() &&
+                 aApplyCollBox.GetEntryPos( aStr ) != LISTBOX_ENTRY_NOTFOUND )
+            {
+                aApplyCollBox.SelectEntry( aStr );
+                aApplyCollBtn.SetState( STATE_CHECK );
+                bIsPageModel = TRUE;
+
+                aPageBreakBox.Enable();
+                aPageBreakBox.EnableTriState( FALSE );
+                aBreakTypeFT.Enable();
+                aBreakTypeLB.Enable();
+                aBreakPositionFT.Enable();
+                aBreakPositionLB.Enable();
+                aApplyCollBtn.Enable();
+                aPageBreakBox.SetState( STATE_CHECK );
+
+                //select page break
+                aBreakTypeLB.SelectEntryPos(0);
+                //select break before
+                aBreakPositionLB.SelectEntryPos(0);
+            }
+            else
+            {
+                aApplyCollBox.SetNoSelection();
+                aApplyCollBtn.SetState( STATE_NOCHECK );
+            }
+        }
+        else if ( SFX_ITEM_DONTCARE == eItemState )
+        {
+            aApplyCollBtn.EnableTriState( TRUE );
+            aApplyCollBtn.SetState( STATE_DONTKNOW );
+            aApplyCollBox.SetNoSelection();
+        }
+        else
+        {
+            aApplyCollBtn.Enable(FALSE);
+            aApplyCollBox.Enable(FALSE);
+            aPagenumEdit.Enable(FALSE);
+            aPagenumText.Enable(FALSE);
+        }
+//!!!    ApplyCollClickHdl_Impl( &aApplyCollBtn );
+
+        if ( !bIsPageModel )
+        {
+            _nWhich = GetWhich( SID_ATTR_PARA_PAGEBREAK );
+            eItemState = rSet.GetItemState( _nWhich );
+
+            if ( eItemState >= SFX_ITEM_AVAILABLE )
+            {
+                const SvxFmtBreakItem& rPageBreak =
+                    (const SvxFmtBreakItem&)rSet.Get( _nWhich );
+
+                SvxBreak eBreak = (SvxBreak)rPageBreak.GetValue();
+
+                // PageBreak nicht ueber CTRL-RETURN,
+                // dann kann CheckBox frei gegeben werden
+                aPageBreakBox.Enable();
+                aPageBreakBox.EnableTriState( FALSE );
+                aBreakTypeFT.Enable();
+                aBreakTypeLB.Enable();
+                aBreakPositionFT.Enable();
+                aBreakPositionLB.Enable();
+
+                aPageBreakBox.SetState( STATE_CHECK );
+
+                BOOL _bEnable =     eBreak != SVX_BREAK_NONE &&
+                                eBreak != SVX_BREAK_COLUMN_BEFORE &&
+                                eBreak != SVX_BREAK_COLUMN_AFTER;
+                aApplyCollBtn.Enable(_bEnable);
+                if(!_bEnable)
+                {
+                    aApplyCollBox.Enable(_bEnable);
+                    aPagenumEdit.Enable(_bEnable);
+                }
+
+                if ( eBreak == SVX_BREAK_NONE )
+                    aPageBreakBox.SetState( STATE_NOCHECK );
+
+                USHORT nType = 0; // selection position in break type ListBox : Page
+                USHORT nPosition = 0; //  selection position in break position ListBox : Before
+                switch ( eBreak )
+                {
+                    case SVX_BREAK_PAGE_BEFORE:
+                        break;
+                    case SVX_BREAK_PAGE_AFTER:
+                        nPosition = 1;
+                        break;
+                    case SVX_BREAK_COLUMN_BEFORE:
+                        nType = 1;
+                        break;
+                    case SVX_BREAK_COLUMN_AFTER:
+                        nType = 1;
+                        nPosition = 1;
+                        break;
+                    default: ;//prevent warning
+                }
+                aBreakTypeLB.SelectEntryPos(nType);
+                aBreakPositionLB.SelectEntryPos(nPosition);
+            }
+            else if ( SFX_ITEM_DONTCARE == eItemState )
+                aPageBreakBox.SetState( STATE_DONTKNOW );
+            else
+            {
+                aPageBreakBox.Enable(FALSE);
+                aBreakTypeFT.Enable(FALSE);
+                aBreakTypeLB.Enable(FALSE);
+                aBreakPositionFT.Enable(FALSE);
+                aBreakPositionLB.Enable(FALSE);
+            }
+        }
+
+        PageBreakPosHdl_Impl( &aBreakPositionLB );
+        PageBreakHdl_Impl( &aPageBreakBox );
+    }
+
+    _nWhich = GetWhich( SID_ATTR_PARA_KEEP );
+    eItemState = rSet.GetItemState( _nWhich );
+
+    if ( eItemState >= SFX_ITEM_AVAILABLE )
+    {
+        aKeepParaBox.EnableTriState( FALSE );
+        const SvxFmtKeepItem& rKeep =
+            (const SvxFmtKeepItem&)rSet.Get( _nWhich );
+
+        if ( rKeep.GetValue() )
+            aKeepParaBox.SetState( STATE_CHECK );
+        else
+            aKeepParaBox.SetState( STATE_NOCHECK );
+    }
+    else if ( SFX_ITEM_DONTCARE == eItemState )
+        aKeepParaBox.SetState( STATE_DONTKNOW );
+    else
+        aKeepParaBox.Enable(FALSE);
+
+    _nWhich = GetWhich( SID_ATTR_PARA_SPLIT );
+    eItemState = rSet.GetItemState( _nWhich );
+
+    if ( eItemState >= SFX_ITEM_AVAILABLE )
+    {
+        const SvxFmtSplitItem& rSplit =
+            (const SvxFmtSplitItem&)rSet.Get( _nWhich );
+        aKeepTogetherBox.EnableTriState( FALSE );
+
+        if ( !rSplit.GetValue() )
+            aKeepTogetherBox.SetState( STATE_CHECK );
+        else
+        {
+            aKeepTogetherBox.SetState( STATE_NOCHECK );
+
+            // Witwen und Waisen
+            aWidowBox.Enable();
+            _nWhich = GetWhich( SID_ATTR_PARA_WIDOWS );
+            SfxItemState eTmpState = rSet.GetItemState( _nWhich );
+
+            if ( eTmpState >= SFX_ITEM_AVAILABLE )
+            {
+                const SvxWidowsItem& rWidow =
+                    (const SvxWidowsItem&)rSet.Get( _nWhich );
+                aWidowBox.EnableTriState( FALSE );
+                const USHORT nLines = rWidow.GetValue();
+
+                BOOL _bEnable = nLines > 0;
+                aWidowRowNo.SetValue( aWidowRowNo.Normalize( nLines ) );
+                aWidowBox.SetState( _bEnable ? STATE_CHECK : STATE_NOCHECK);
+                aWidowRowNo.Enable(_bEnable);
+                aWidowRowLabel.Enable(_bEnable);
+
+            }
+            else if ( SFX_ITEM_DONTCARE == eTmpState )
+                aWidowBox.SetState( STATE_DONTKNOW );
+            else
+                aWidowBox.Enable(FALSE);
+
+            aOrphanBox.Enable();
+            _nWhich = GetWhich( SID_ATTR_PARA_ORPHANS );
+            eTmpState = rSet.GetItemState( _nWhich );
+
+            if ( eTmpState >= SFX_ITEM_AVAILABLE )
+            {
+                const SvxOrphansItem& rOrphan =
+                    (const SvxOrphansItem&)rSet.Get( _nWhich );
+                const USHORT nLines = rOrphan.GetValue();
+                aOrphanBox.EnableTriState( FALSE );
+
+                BOOL _bEnable = nLines > 0;
+                aOrphanBox.SetState( _bEnable ? STATE_CHECK : STATE_NOCHECK);
+                aOrphanRowNo.SetValue( aOrphanRowNo.Normalize( nLines ) );
+                aOrphanRowNo.Enable(_bEnable);
+                aOrphanRowLabel.Enable(_bEnable);
+
+            }
+            else if ( SFX_ITEM_DONTCARE == eTmpState )
+                aOrphanBox.SetState( STATE_DONTKNOW );
+            else
+                aOrphanBox.Enable(FALSE);
+        }
+    }
+    else if ( SFX_ITEM_DONTCARE == eItemState )
+        aKeepTogetherBox.SetState( STATE_DONTKNOW );
+    else
+        aKeepTogetherBox.Enable(FALSE);
+
+    // damit alles richt enabled wird
+    KeepTogetherHdl_Impl( 0 );
+    WidowHdl_Impl( 0 );
+    OrphanHdl_Impl( 0 );
+
+    aHyphenBox.SaveValue();
+    aExtHyphenBeforeBox.SaveValue();
+    aExtHyphenAfterBox.SaveValue();
+    aMaxHyphenEdit.SaveValue();
+    aPageBreakBox.SaveValue();
+    aBreakPositionLB.SaveValue();
+    aBreakTypeLB.SaveValue();
+    aApplyCollBtn.SaveValue();
+    aApplyCollBox.SaveValue();
+    aPagenumEdit.SaveValue();
+    aKeepTogetherBox.SaveValue();
+    aKeepParaBox.SaveValue();
+    aWidowBox.SaveValue();
+    aOrphanBox.SaveValue();
+}
+
+// -----------------------------------------------------------------------
+
+int SvxExtParagraphTabPage::DeactivatePage( SfxItemSet* _pSet )
+{
+    if ( _pSet )
+        FillItemSet( *_pSet );
+    return LEAVE_PAGE;
+}
+
+// -----------------------------------------------------------------------
+
+void SvxExtParagraphTabPage::DisablePageBreak()
+{
+    bPageBreak = FALSE;
+    aPageBreakBox.Enable(FALSE);
+    aBreakTypeLB.RemoveEntry(0);
+    aBreakPositionFT.Enable(FALSE);
+    aBreakPositionLB.Enable(FALSE);
+    aApplyCollBtn.Enable(FALSE);
+    aApplyCollBox.Enable(FALSE);
+    aPagenumEdit.Enable(FALSE);
+}
+
+// -----------------------------------------------------------------------
+
+SvxExtParagraphTabPage::SvxExtParagraphTabPage( Window* pParent, const SfxItemSet& rAttr ) :
+
+    SfxTabPage( pParent, SVX_RES( RID_SVXPAGE_EXT_PARAGRAPH ), rAttr ),
+
+    aHyphenBox            ( this, SVX_RES( BTN_HYPHEN ) ),
+    aBeforeText            ( this, SVX_RES( FT_HYPHENBEFORE ) ),
+    aExtHyphenBeforeBox ( this, SVX_RES( ED_HYPHENBEFORE ) ),
+    aAfterText            ( this, SVX_RES( FT_HYPHENAFTER ) ),
+    aExtHyphenAfterBox  ( this, SVX_RES( ED_HYPHENAFTER ) ),
+    aMaxHyphenLabel     ( this, SVX_RES( FT_MAXHYPH ) ),
+    aMaxHyphenEdit        ( this, SVX_RES( ED_MAXHYPH ) ),
+    aExtFL              ( this, SVX_RES( FL_HYPHEN ) ),
+    aBreaksFL           ( this, SVX_RES( FL_BREAKS ) ),
+    aPageBreakBox       ( this, SVX_RES( BTN_PAGEBREAK ) ),
+    aBreakTypeFT        ( this, SVX_RES( FT_BREAKTYPE     )),
+    aBreakTypeLB        ( this, SVX_RES( LB_BREAKTYPE     )),
+    aBreakPositionFT    ( this, SVX_RES( FT_BREAKPOSITION )),
+    aBreakPositionLB    ( this, SVX_RES( LB_BREAKPOSITION )),
+//    aPageBox            ( this, SVX_RES( BTN_BREAKPAGE ) ),
+//    aColumnBox          ( this, SVX_RES( BTN_BREAKCOLUMN ) ),
+//    aBeforeBox          ( this, SVX_RES( BTN_PAGEBREAKBEFORE ) ),
+//    aAfterBox           ( this, SVX_RES( BTN_PAGEBREAKAFTER ) ),
+    aApplyCollBtn       ( this, SVX_RES( BTN_PAGECOLL ) ),
+    aApplyCollBox       ( this, SVX_RES( LB_PAGECOLL ) ),
+    aPagenumText        ( this, SVX_RES( FT_PAGENUM ) ),
+    aPagenumEdit        ( this, SVX_RES( ED_PAGENUM ) ),
+    aExtendFL           ( this, SVX_RES( FL_OPTIONS ) ),
+    aKeepTogetherBox    ( this, SVX_RES( BTN_KEEPTOGETHER ) ),
+    aKeepParaBox        ( this, SVX_RES( CB_KEEPTOGETHER ) ),
+    aOrphanBox          ( this, SVX_RES( BTN_ORPHANS ) ),
+    aOrphanRowNo        ( this, SVX_RES( ED_ORPHANS ) ),
+    aOrphanRowLabel     ( this, SVX_RES( FT_ORPHANS ) ),
+    aWidowBox           ( this, SVX_RES( BTN_WIDOWS ) ),
+    aWidowRowNo         ( this, SVX_RES( ED_WIDOWS ) ),
+    aWidowRowLabel      ( this, SVX_RES( FT_WIDOWS ) ),
+    bPageBreak  ( TRUE ),
+    bHtmlMode   ( FALSE ),
+    nStdPos     ( 0 )
+{
+    FreeResource();
+
+    // diese Page braucht ExchangeSupport
+    SetExchangeSupport();
+
+    aHyphenBox.SetClickHdl(         LINK( this, SvxExtParagraphTabPage, HyphenClickHdl_Impl ) );
+    aPageBreakBox.SetClickHdl(         LINK( this, SvxExtParagraphTabPage, PageBreakHdl_Impl ) );
+    aKeepTogetherBox.SetClickHdl(     LINK( this, SvxExtParagraphTabPage, KeepTogetherHdl_Impl ) );
+    aWidowBox.SetClickHdl(             LINK( this, SvxExtParagraphTabPage, WidowHdl_Impl ) );
+    aOrphanBox.SetClickHdl(         LINK( this, SvxExtParagraphTabPage, OrphanHdl_Impl ) );
+    aApplyCollBtn.SetClickHdl(         LINK( this, SvxExtParagraphTabPage, ApplyCollClickHdl_Impl ) );
+    aBreakTypeLB.SetSelectHdl(      LINK( this, SvxExtParagraphTabPage, PageBreakTypeHdl_Impl ) );
+    aBreakPositionLB.SetSelectHdl(  LINK( this, SvxExtParagraphTabPage, PageBreakPosHdl_Impl ) );
+
+    SfxObjectShell* pSh = SfxObjectShell::Current();
+    if ( pSh )
+    {
+        SfxStyleSheetBasePool* pPool = pSh->GetStyleSheetPool();
+        pPool->SetSearchMask( SFX_STYLE_FAMILY_PAGE );
+        SfxStyleSheetBase* pStyle = pPool->First();
+        String aStdName;
+
+        while( pStyle )
+        {
+            if ( aStdName.Len() == 0 )
+                // first style == standard style
+                aStdName = pStyle->GetName();
+            aApplyCollBox.InsertEntry( pStyle->GetName() );
+            pStyle = pPool->Next();
+        }
+        nStdPos = aApplyCollBox.GetEntryPos( aStdName );
+    }
+
+    USHORT nHtmlMode = GetHtmlMode_Impl( rAttr );
+    if ( nHtmlMode & HTMLMODE_ON )
+    {
+        bHtmlMode = TRUE;
+        aHyphenBox             .Enable(FALSE);
+        aBeforeText             .Enable(FALSE);
+        aExtHyphenBeforeBox  .Enable(FALSE);
+        aAfterText             .Enable(FALSE);
+        aExtHyphenAfterBox   .Enable(FALSE);
+        aMaxHyphenLabel      .Enable(FALSE);
+        aMaxHyphenEdit         .Enable(FALSE);
+        aExtFL               .Enable(FALSE);
+        aPagenumText         .Enable(FALSE);
+        aPagenumEdit         .Enable(FALSE);
+        // no column break in HTML
+        aBreakTypeLB.RemoveEntry(1);
+    }
+}
+
+// -----------------------------------------------------------------------
+
+__EXPORT SvxExtParagraphTabPage::~SvxExtParagraphTabPage()
+{
+}
+
+// -----------------------------------------------------------------------
+
+USHORT* SvxExtParagraphTabPage::GetRanges()
+{
+    return pExtRanges;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxExtParagraphTabPage, PageBreakHdl_Impl, TriStateBox *, EMPTYARG )
+{
+    switch ( aPageBreakBox.GetState() )
+    {
+        case STATE_CHECK:
+            aBreakTypeFT.Enable();
+            aBreakTypeLB.Enable();
+            aBreakPositionFT.Enable();
+            aBreakPositionLB.Enable();
+
+            if ( 0 == aBreakTypeLB.GetSelectEntryPos()&&
+                0 == aBreakPositionLB.GetSelectEntryPos() )
+            {
+                aApplyCollBtn.Enable();
+
+                BOOL bEnable = STATE_CHECK == aApplyCollBtn.GetState() &&
+                                            aApplyCollBox.GetEntryCount();
+                aApplyCollBox.Enable(bEnable);
+                if(!bHtmlMode)
+                {
+                    aPagenumText.Enable(bEnable);
+                    aPagenumEdit.Enable(bEnable);
+                }
+            }
+            break;
+
+        case STATE_NOCHECK:
+        case STATE_DONTKNOW:
+            aApplyCollBtn.SetState( STATE_NOCHECK );
+            aApplyCollBtn.Enable(FALSE);
+            aApplyCollBox.Enable(FALSE);
+            aPagenumText.Enable(FALSE);
+            aPagenumEdit.Enable(FALSE);
+            aBreakTypeFT.Enable(FALSE);
+            aBreakTypeLB.Enable(FALSE);
+            aBreakPositionFT.Enable(FALSE);
+            aBreakPositionLB.Enable(FALSE);
+            break;
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxExtParagraphTabPage, KeepTogetherHdl_Impl, TriStateBox *, EMPTYARG )
+{
+    BOOL bEnable = aKeepTogetherBox.GetState() == STATE_NOCHECK;
+    aWidowBox.Enable(bEnable);
+    aOrphanBox.Enable(bEnable);
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxExtParagraphTabPage, WidowHdl_Impl, TriStateBox *, EMPTYARG )
+{
+    switch ( aWidowBox.GetState() )
+    {
+        case STATE_CHECK:
+            aWidowRowNo.Enable();
+            aWidowRowLabel.Enable();
+            aKeepTogetherBox.Enable(FALSE);
+            break;
+
+        case STATE_NOCHECK:
+            if ( aOrphanBox.GetState() == STATE_NOCHECK )
+                aKeepTogetherBox.Enable();
+
+        // kein break
+        case STATE_DONTKNOW:
+            aWidowRowNo.Enable(FALSE);
+            aWidowRowLabel.Enable(FALSE);
+            break;
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxExtParagraphTabPage, OrphanHdl_Impl, TriStateBox *, EMPTYARG )
+{
+    switch( aOrphanBox.GetState() )
+    {
+        case STATE_CHECK:
+            aOrphanRowNo.Enable();
+            aOrphanRowLabel.Enable();
+            aKeepTogetherBox.Enable(FALSE);
+            break;
+
+        case STATE_NOCHECK:
+            if ( aWidowBox.GetState() == STATE_NOCHECK )
+                aKeepTogetherBox.Enable();
+
+        // kein break
+        case STATE_DONTKNOW:
+            aOrphanRowNo.Enable(FALSE);
+            aOrphanRowLabel.Enable(FALSE);
+            break;
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxExtParagraphTabPage, HyphenClickHdl_Impl, TriStateBox *, EMPTYARG )
+{
+
+    BOOL bEnable = aHyphenBox.GetState() == STATE_CHECK;
+    aBeforeText.Enable(bEnable);
+    aExtHyphenBeforeBox.Enable(bEnable);
+    aAfterText.Enable(bEnable);
+    aExtHyphenAfterBox.Enable(bEnable);
+    aMaxHyphenLabel.Enable(bEnable);
+    aMaxHyphenEdit.Enable(bEnable);
+    aHyphenBox.SetState( bEnable ? STATE_CHECK : STATE_NOCHECK);
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxExtParagraphTabPage, ApplyCollClickHdl_Impl, TriStateBox *, EMPTYARG )
+{
+    BOOL bEnable = FALSE;
+    if ( aApplyCollBtn.GetState() == STATE_CHECK &&
+         aApplyCollBox.GetEntryCount() )
+    {
+        bEnable = TRUE;
+        aApplyCollBox.SelectEntryPos( nStdPos );
+    }
+    else
+    {
+        aApplyCollBox.SetNoSelection();
+    }
+    aApplyCollBox.Enable(bEnable);
+    if(!bHtmlMode)
+    {
+        aPagenumText.Enable(bEnable);
+        aPagenumEdit.Enable(bEnable);
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxExtParagraphTabPage, PageBreakPosHdl_Impl, ListBox *, pListBox )
+{
+    if ( 0 == pListBox->GetSelectEntryPos() )
+    {
+        aApplyCollBtn.Enable();
+
+        BOOL bEnable = aApplyCollBtn.GetState() == STATE_CHECK &&
+                                    aApplyCollBox.GetEntryCount();
+
+        aApplyCollBox.Enable(bEnable);
+        if(!bHtmlMode)
+        {
+            aPagenumText.Enable(bEnable);
+            aPagenumEdit.Enable(bEnable);
+        }
+    }
+    else if ( 1 == pListBox->GetSelectEntryPos() )
+    {
+        aApplyCollBtn.SetState( STATE_NOCHECK );
+        aApplyCollBtn.Enable(FALSE);
+        aApplyCollBox.Enable(FALSE);
+        aPagenumText.Enable(FALSE);
+        aPagenumEdit.Enable(FALSE);
+    }
+    return 0;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxExtParagraphTabPage, PageBreakTypeHdl_Impl, ListBox *, pListBox )
+{
+    //column break or break break after
+    USHORT nBreakPos = aBreakPositionLB.GetSelectEntryPos();
+    if ( pListBox->GetSelectEntryPos() == 1 || 1 == nBreakPos)
+    {
+        aApplyCollBtn.SetState( STATE_NOCHECK );
+        aApplyCollBtn.Enable(FALSE);
+        aApplyCollBox.Enable(FALSE);
+        aPagenumText.Enable(FALSE);
+        aPagenumEdit.Enable(FALSE);
+    }
+    else
+        PageBreakPosHdl_Impl( &aBreakPositionLB );
+    return 0;
+}
+//Add CHINA001 begin
+void SvxExtParagraphTabPage::PageCreated(SfxAllItemSet aSet)
+{
+
+
+    SFX_ITEMSET_ARG    (&aSet,pDisablePageBreakItem,SfxBoolItem,SID_DISABLE_SVXEXTPARAGRAPHTABPAGE_PAGEBREAK,sal_False);
+
+    if (pDisablePageBreakItem)
+        if ( pDisablePageBreakItem->GetValue())
+                    DisablePageBreak();
+
+
+}
+//end of Add CHINA001
+/*-- 29.11.00 11:36:24---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+SvxAsianTabPage::SvxAsianTabPage( Window* pParent, const SfxItemSet& rSet ) :
+    SfxTabPage(pParent, SVX_RES( RID_SVXPAGE_PARA_ASIAN ), rSet),
+    aOptionsFL(         this, SVX_RES(FL_AS_OPTIONS       )),
+    aForbiddenRulesCB(  this, SVX_RES(CB_AS_FORBIDDEN     )),
+    aAllowWordBreakCB(  this, SVX_RES(CB_AS_ALLOW_WORD_BREAK)),
+    aHangingPunctCB(    this, SVX_RES(CB_AS_HANG_PUNC     )),
+    aCharDistFL(        this, SVX_RES(FL_AS_CHAR_DIST     )),
+    aPuntuationCB(         this, SVX_RES(CB_AS_PUNCTUATION   )),
+    aScriptSpaceCB(     this, SVX_RES(CB_AS_SCRIPT_SPACE    )),
+    aAdjustNumbersCB(    this, SVX_RES(CB_AS_ADJUST_NUMBERS))
+
+{
+    FreeResource();
+
+    Link aLink = LINK( this, SvxAsianTabPage, ClickHdl_Impl );
+    aHangingPunctCB.SetClickHdl( aLink );
+    aScriptSpaceCB.SetClickHdl( aLink );
+    aForbiddenRulesCB.SetClickHdl( aLink );
+
+//JP 28.3.2001 - these options currently not available!
+    aAllowWordBreakCB.Hide();
+    aCharDistFL.Hide();
+    aPuntuationCB.Hide();
+    aAdjustNumbersCB.Hide();
+    aScriptSpaceCB.SetPosPixel( aHangingPunctCB.GetPosPixel() );
+    aHangingPunctCB.SetPosPixel( aAllowWordBreakCB.GetPosPixel() );
+//JP 28.3.2001 - these options currently not available!
+}
+/*-- 29.11.00 11:36:24---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+SvxAsianTabPage::~SvxAsianTabPage()
+{
+}
+/*-- 29.11.00 11:36:24---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+SfxTabPage*    SvxAsianTabPage::Create(    Window* pParent, const SfxItemSet& rSet )
+{
+    return new SvxAsianTabPage(pParent, rSet);
+}
+/*-- 29.11.00 11:36:24---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+USHORT*        SvxAsianTabPage::GetRanges()
+{
+    static USHORT pRanges[] =
+    {
+        SID_ATTR_PARA_SCRIPTSPACE,
+        SID_ATTR_PARA_HANGPUNCTUATION,
+        SID_ATTR_PARA_FORBIDDEN_RULES,
+        0
+    };
+    return pRanges;
+}
+/*-- 29.11.00 11:36:24---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+BOOL        SvxAsianTabPage::FillItemSet( SfxItemSet& rSet )
+{
+    BOOL bRet = FALSE;
+    SfxItemPool* pPool = rSet.GetPool();
+    if(aScriptSpaceCB.IsChecked() != aScriptSpaceCB.GetSavedValue())
+    {
+        SfxBoolItem* pNewItem = (SfxBoolItem*)rSet.Get(
+            pPool->GetWhich(SID_ATTR_PARA_SCRIPTSPACE)).Clone();
+        pNewItem->SetValue(aScriptSpaceCB.IsChecked());
+        rSet.Put(*pNewItem);
+        delete pNewItem;
+        bRet = TRUE;
+    }
+    if(aHangingPunctCB.IsChecked() != aHangingPunctCB.GetSavedValue())
+    {
+        SfxBoolItem* pNewItem = (SfxBoolItem*)rSet.Get(
+            pPool->GetWhich(SID_ATTR_PARA_HANGPUNCTUATION)).Clone();
+        pNewItem->SetValue(aHangingPunctCB.IsChecked());
+        rSet.Put(*pNewItem);
+        delete pNewItem;
+        bRet = TRUE;
+    }
+    if(aForbiddenRulesCB.IsChecked() != aForbiddenRulesCB.GetSavedValue())
+    {
+        SfxBoolItem* pNewItem = (SfxBoolItem*)rSet.Get(
+            pPool->GetWhich(SID_ATTR_PARA_FORBIDDEN_RULES)).Clone();
+        pNewItem->SetValue(aForbiddenRulesCB.IsChecked());
+        rSet.Put(*pNewItem);
+        delete pNewItem;
+        bRet = TRUE;
+    }
+    return bRet;
+}
+/*-- 29.11.00 11:36:25---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+void lcl_SetBox(const SfxItemSet& rSet, USHORT nSlotId, TriStateBox& rBox)
+{
+    USHORT _nWhich = rSet.GetPool()->GetWhich(nSlotId);
+    SfxItemState eState = rSet.GetItemState(_nWhich, TRUE);
+    if(!eState)
+        rBox.Enable(FALSE);
+    else if(eState >= SFX_ITEM_AVAILABLE)
+    {
+        rBox.EnableTriState( FALSE );
+        rBox.Check(((const SfxBoolItem&)rSet.Get(_nWhich)).GetValue());
+    }
+    else
+        rBox.SetState( STATE_DONTKNOW );
+    rBox.SaveValue();
+}
+
+
+void SvxAsianTabPage::Reset( const SfxItemSet& rSet )
+{
+    lcl_SetBox(rSet, SID_ATTR_PARA_FORBIDDEN_RULES, aForbiddenRulesCB );
+//    lcl_SetBox(rSet, , aAllowWordBreakCB );
+    lcl_SetBox(rSet, SID_ATTR_PARA_HANGPUNCTUATION, aHangingPunctCB );
+
+
+    //character distance not yet available
+//    lcl_SetBox(rSet, , aPuntuationCB    );
+    lcl_SetBox(rSet, SID_ATTR_PARA_SCRIPTSPACE, aScriptSpaceCB );
+//    lcl_SetBox(rSet, , aAdjustNumbersCB );
+    aAllowWordBreakCB    .Enable(FALSE);
+    aPuntuationCB        .Enable(FALSE);
+    aAdjustNumbersCB    .Enable(FALSE);
+}
+/* -----------------------------19.12.00 12:59--------------------------------
+
+ ---------------------------------------------------------------------------*/
+IMPL_LINK( SvxAsianTabPage, ClickHdl_Impl, TriStateBox*, pBox )
+{
+    pBox->EnableTriState( FALSE );
+    return 0;
+}
diff --git a/layout/workben/paragraph.hrc b/layout/workben/paragraph.hrc
new file mode 100644
index 0000000..0d0057b
--- /dev/null
+++ layout/workben/paragraph.hrc
@@ -0,0 +1,131 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: paragrph.hrc,v $
+ *
+ *  $Revision: 1.17 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 21:51:23 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef _SVX_PARAGRPH_HRC
+#define _SVX_PARAGRPH_HRC
+
+// StandardTabPage ----------------------------------------------------------
+
+#define FT_LEFTINDENT			10
+#define ED_LEFTINDENT			11
+#define FT_FLINEINDENT			12
+#define ED_FLINEINDENT			13
+#define FT_RIGHTINDENT			14
+#define ED_RIGHTINDENT			15
+#define FL_INDENT                       16
+
+#define FT_TOPDIST                      20
+#define ED_TOPDIST                      21
+#define FT_BOTTOMDIST			22
+#define ED_BOTTOMDIST			23
+#define FL_DIST                         24
+
+#define BTN_LEFTALIGN			30
+#define BTN_RIGHTALIGN			31
+#define BTN_CENTERALIGN			32
+#define BTN_JUSTIFYALIGN		33
+#define FL_ALIGN                        34
+#define FL_VERTALIGN                    35
+#define LB_VERTALIGN                    36
+#define FL_VERTEX                       37
+#define CB_SNAP                         38
+#define FT_VERTALIGN                    39
+
+
+#define LB_LINEDIST                     40
+#define FT_LINEDIST                     41
+#define ED_LINEDISTPERCENT		42
+#define ED_LINEDISTMETRIC		43
+#define FL_LINEDIST                     44
+#define WN_EXAMPLE                      46
+
+#define CB_AUTO                         48
+#define FT_LASTLINE                     49
+#define LB_LASTLINE                     50
+#define CB_EXPAND                       51
+#define ST_LINEDIST_ABS                 52
+#define ST_LEFTALIGN_ASIAN              53
+#define ST_RIGHTALIGN_ASIAN             54
+
+// ExtendedTabPage ----------------------------------------------------------
+
+#define BTN_HYPHEN                      50
+#define ED_HYPHENBEFORE			52
+#define FT_HYPHENBEFORE			53
+#define ED_HYPHENAFTER			55
+#define FT_HYPHENAFTER			56
+#define FL_HYPHEN                       57
+
+#define BTN_PAGEBREAK			60
+#define FT_BREAKTYPE            61
+#define LB_BREAKTYPE            62
+#define FT_BREAKPOSITION        63
+#define LB_BREAKPOSITION        64
+#define BTN_PAGECOLL			65
+#define LB_PAGECOLL                     66
+#define BTN_KEEPTOGETHER		67
+#define BTN_WIDOWS                      68
+#define ED_WIDOWS                       69
+#define FT_WIDOWS                       70
+#define BTN_ORPHANS                     71
+#define ED_ORPHANS                      72
+#define FT_ORPHANS                      73
+#define FL_OPTIONS                      74
+#define FT_PAGENUM                      75
+#define ED_PAGENUM                      76
+#define FL_BREAKS						77
+
+#define CB_KEEPTOGETHER                 80
+#define FT_MAXHYPH  					81
+#define ED_MAXHYPH                      83
+
+#define CB_REGISTER                     84
+#define FL_REGISTER                     85
+#define FL_PROPERTIES                   90
+#define FT_TEXTDIRECTION                91
+#define LB_TEXTDIRECTION                92
+
+
+//asian typography
+#define FL_AS_OPTIONS                   1
+#define CB_AS_HANG_PUNC                 2
+#define CB_AS_ALLOW_WORD_BREAK          3
+#define CB_AS_FORBIDDEN                 4
+#define FL_AS_CHAR_DIST                 5
+#define CB_AS_PUNCTUATION               6
+#define CB_AS_SCRIPT_SPACE				7
+#define CB_AS_ADJUST_NUMBERS            8
+
+#endif
+
diff --git a/layout/workben/paragraph.hxx b/layout/workben/paragraph.hxx
new file mode 100644
index 0000000..59add0e
--- /dev/null
+++ layout/workben/paragraph.hxx
@@ -0,0 +1,356 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: paragrph.hxx,v $
+ *
+ *  $Revision: 1.5 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 17:32:56 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef _SVX_PARAGRPH_HXX
+#define _SVX_PARAGRPH_HXX
+
+// include ---------------------------------------------------------------
+
+#ifndef _BUTTON_HXX //autogen
+#include <vcl/button.hxx>
+#endif
+#ifndef _FIXED_HXX //autogen
+#include <vcl/fixed.hxx>
+#endif
+#ifndef _SFXTABDLG_HXX //autogen
+#include <sfx2/tabdlg.hxx>
+#endif
+#ifndef _SVX_PARAPREV_HXX
+#include <svx/paraprev.hxx>        // Preview
+#endif
+#ifndef _SVX_FRMDIRLBOX_HXX
+#include <svx/frmdirlbox.hxx>
+#endif
+
+#ifndef _LSTBOX_HXX //autogen
+#include <vcl/lstbox.hxx>
+#endif
+
+#include <svx/relfld.hxx>
+#include <svx/dlgutil.hxx>
+#include <svx/htmlmode.hxx>
+#include <svx/flagsdef.hxx>
+#include <svx/pgrditem.hxx>
+
+// define ----------------------------------------------------------------
+
+// 1/2 cm in TWIPS
+// wird auch fuer Minimalgrosse der LayFrms aller Arten benutzt
+//CHINA001 #define MM50   283
+
+// forward ---------------------------------------------------------------
+
+class SvxLineSpacingItem;
+class SvxParagraphControllerItem;
+
+// class SvxStdParagraphTabPage ------------------------------------------
+
+/*     {k:\svx\prototyp\dialog\parastd.bmp}
+
+    [Beschreibung]
+    Mit dieser TabPage koennen Standard-Attribute eines Absatzes eingestellt
+    werden (Einzug, Abstand, Ausrichtung, Zeilenabstand).
+
+    [Items]
+    <SvxAdjustItem><SID_ATTR_PARA_ADJUST>
+    <SvxLineSpacingItem><SID_ATTR_PARA_LINESPACE>
+    <SvxULSpaceItem><SID_ATTR_ULSPACE>
+    <SvxLRSpaceItem><SID_ATTR_LRSPACE>
+*/
+
+class SvxStdParagraphTabPage: public SfxTabPage
+{
+    using TabPage::DeactivatePage;
+
+private:
+    SvxStdParagraphTabPage( Window* pParent, const SfxItemSet& rSet );
+
+    // Einzug
+    FixedText                aLeftLabel;
+    SvxRelativeField        aLeftIndent;
+
+    FixedText                aRightLabel;
+    SvxRelativeField        aRightIndent;
+
+    FixedText                aFLineLabel;
+    SvxRelativeField        aFLineIndent;
+    CheckBox                aAutoCB;
+
+    FixedLine               aIndentFrm;
+
+    // Abstaende
+    FixedText                aTopLabel;
+    SvxRelativeField        aTopDist;
+    FixedText                aBottomLabel;
+    SvxRelativeField        aBottomDist;
+    FixedLine               aDistFrm;
+
+    // Zeilenabstand
+    ListBox                    aLineDist;
+    FixedText                aLineDistAtLabel;
+    MetricField                aLineDistAtPercentBox;
+    MetricField                aLineDistAtMetricBox;
+    FixedLine               aLineDistFrm;
+    String                     sAbsDist;
+    SvxParaPrevWindow        aExampleWin;
+
+    //Registerhaltigkeit - nur Writer
+    CheckBox                aRegisterCB;
+    FixedLine               aRegisterFL;
+
+    Edit*                    pActLineDistFld;
+    long                    nAbst;
+    long                    nWidth;
+    long                     nMinFixDist;
+    BOOL                    bRelativeMode;
+    BOOL                    bNegativeIndents;
+
+#ifdef _SVX_PARAGRPH_CXX
+    void                    SetLineSpacing_Impl( const SvxLineSpacingItem& rAttr );
+    void                    Init_Impl();
+    void                    UpdateExample_Impl( BOOL bAll = FALSE );
+
+    DECL_LINK( LineDistHdl_Impl, ListBox* );
+    DECL_LINK( ModifyHdl_Impl, SvxRelativeField* );
+    DECL_LINK( AutoHdl_Impl, CheckBox* );
+#endif
+
+protected:
+    virtual int                DeactivatePage( SfxItemSet* pSet = 0 );
+
+public:
+    DECL_LINK( ELRLoseFocusHdl, Edit* );
+
+    static SfxTabPage*        Create( Window* pParent, const SfxItemSet& rSet );
+    static USHORT*            GetRanges();
+
+    virtual BOOL            FillItemSet( SfxItemSet& rSet );
+    virtual void            Reset( const SfxItemSet& rSet );
+
+
+    void                    SetPageWidth( USHORT nPageWidth );
+    void                    SetMaxDistance( USHORT nMaxDist );
+    void                    EnableRelativeMode();
+    void                     EnableRegisterMode();
+    void                    EnableAutoFirstLine();
+    void                    EnableAbsLineDist(long nMinTwip);
+    void                    EnableNegativeMode();
+    virtual void             PageCreated(SfxAllItemSet aSet); // add CHINA001
+};
+
+// class SvxParaAlignTabPage ------------------------------------------------
+
+class SvxParaAlignTabPage : public SfxTabPage
+{
+    using TabPage::DeactivatePage;
+
+    // Ausrichtung
+    FixedLine               aAlignFrm;
+    RadioButton             aLeft;
+    RadioButton                aRight;
+    RadioButton                aCenter;
+    RadioButton                aJustify;
+    FixedText                aLastLineFT;
+    ListBox                    aLastLineLB;
+    CheckBox                aExpandCB;
+
+    CheckBox                aSnapToGridCB;
+
+    //preview
+    SvxParaPrevWindow        aExampleWin;
+    //vertical alignment
+    FixedLine               aVertAlignFL;
+
+    FixedText               aVertAlignFT;
+    ListBox                 aVertAlignLB;
+
+    FixedLine                   aPropertiesFL;
+    FixedText                   aTextDirectionFT;
+    svx::FrameDirectionListBox    aTextDirectionLB;
+
+#ifdef _SVX_PARAGRPH_CXX
+    DECL_LINK(                 AlignHdl_Impl, RadioButton* );
+    DECL_LINK(                 LastLineHdl_Impl, ListBox* );
+    DECL_LINK(                 TextDirectionHdl_Impl, ListBox* );
+
+    void                    UpdateExample_Impl( BOOL bAll = FALSE );
+#endif
+
+                            SvxParaAlignTabPage( Window* pParent, const SfxItemSet& rSet );
+    virtual                    ~SvxParaAlignTabPage();
+
+protected:
+    virtual int                DeactivatePage( SfxItemSet* pSet = 0 );
+
+public:
+    static SfxTabPage*        Create( Window* pParent, const SfxItemSet& rSet );
+    static USHORT*            GetRanges();
+
+    virtual BOOL            FillItemSet( SfxItemSet& rSet );
+    virtual void            Reset( const SfxItemSet& rSet );
+
+    void                    EnableJustifyExt();
+    virtual void             PageCreated(SfxAllItemSet aSet); // add CHINA001
+};
+
+// class SvxExtParagraphTabPage ------------------------------------------
+
+/*    {k:\svx\prototyp\dialog\paraext.bmp}
+
+    [Beschreibung]
+    Mit dieser TabPage koennen Spezial-Attribute eines Absatzes eingestellt
+    werden (Silbentrennung, Seitenumbruch, Schusterjungen, Hurenkinder, ...).
+
+    [Items]
+    <SvxHyphenZoneItem><SID_ATTR_PARA_HYPHENZONE>
+    <SvxFmtBreakItem><SID_ATTR_PARA_PAGEBREAK>
+    <SvxFmtSplitItem><SID_ATTR_PARA_SPLIT>
+    <SvxWidowsItem><SID_ATTR_PARA_WIDOWS>
+    <SvxOrphansItem><SID_ATTR_PARA_ORPHANS>
+*/
+
+class SvxExtParagraphTabPage: public SfxTabPage
+{
+    using TabPage::DeactivatePage;
+
+public:
+    virtual                ~SvxExtParagraphTabPage();
+
+    static SfxTabPage*    Create(    Window* pParent,
+                                const SfxItemSet& rSet );
+    static USHORT*        GetRanges();
+
+    virtual BOOL        FillItemSet( SfxItemSet& rSet );
+    virtual void        Reset( const SfxItemSet& rSet );
+
+    void                DisablePageBreak();
+
+protected:
+    virtual int            DeactivatePage( SfxItemSet* pSet = 0 );
+
+private:
+                        SvxExtParagraphTabPage( Window* pParent, const SfxItemSet& rSet );
+
+    // Silbentrennung
+    TriStateBox            aHyphenBox;
+    FixedText            aBeforeText;
+    NumericField        aExtHyphenBeforeBox;
+//    FixedText            aHyphenBeforeLabel;
+    FixedText            aAfterText;
+    NumericField        aExtHyphenAfterBox;
+//    FixedText            aHyphenAfterLabel;
+    FixedText             aMaxHyphenLabel;
+    NumericField        aMaxHyphenEdit;
+    FixedLine           aExtFL;
+
+    // Seitenumbruch
+    FixedLine            aBreaksFL;
+    TriStateBox            aPageBreakBox;
+    FixedText           aBreakTypeFT;
+    ListBox             aBreakTypeLB;
+    FixedText           aBreakPositionFT;
+    ListBox             aBreakPositionLB;
+    TriStateBox            aApplyCollBtn;
+    ListBox                aApplyCollBox;
+    FixedText           aPagenumText;
+    NumericField           aPagenumEdit;
+
+    FixedLine           aExtendFL;
+
+    // Absatzteilung
+    TriStateBox            aKeepTogetherBox;
+    TriStateBox            aKeepParaBox;
+
+    // Witwen/Waisen
+    TriStateBox            aOrphanBox;
+    NumericField           aOrphanRowNo;
+    FixedText            aOrphanRowLabel;
+
+    TriStateBox            aWidowBox;
+    NumericField           aWidowRowNo;
+    FixedText            aWidowRowLabel;
+
+    BOOL                bPageBreak;
+    BOOL                bHtmlMode;
+    USHORT                nStdPos;
+
+#ifdef _SVX_PARAGRPH_CXX
+    DECL_LINK( PageBreakHdl_Impl, TriStateBox* );
+    DECL_LINK( KeepTogetherHdl_Impl, TriStateBox* );
+    DECL_LINK( WidowHdl_Impl, TriStateBox* );
+    DECL_LINK( OrphanHdl_Impl, TriStateBox* );
+    DECL_LINK( HyphenClickHdl_Impl, TriStateBox* );
+    DECL_LINK( ApplyCollClickHdl_Impl, TriStateBox* );
+    DECL_LINK( PageBreakPosHdl_Impl, ListBox* );
+    DECL_LINK( PageBreakTypeHdl_Impl, ListBox* );
+#endif
+    virtual void             PageCreated(SfxAllItemSet aSet); // add CHINA001
+};
+/* -----------------------------29.11.00 11:33--------------------------------
+
+ ---------------------------------------------------------------------------*/
+class SvxAsianTabPage : public SfxTabPage
+{
+    FixedLine       aOptionsFL;
+
+    TriStateBox        aForbiddenRulesCB;
+    TriStateBox        aAllowWordBreakCB;
+    TriStateBox        aHangingPunctCB;
+
+    FixedLine       aCharDistFL;
+    TriStateBox        aPuntuationCB;
+    TriStateBox        aScriptSpaceCB;
+    TriStateBox        aAdjustNumbersCB;
+
+    SvxAsianTabPage( Window* pParent, const SfxItemSet& rSet );
+
+#ifdef _SVX_PARAGRPH_CXX
+    DECL_LINK( ClickHdl_Impl, TriStateBox* );
+#endif
+public:
+    ~SvxAsianTabPage();
+
+
+    static SfxTabPage*    Create(    Window* pParent,
+                                const SfxItemSet& rSet );
+    static USHORT*        GetRanges();
+
+    virtual BOOL        FillItemSet( SfxItemSet& rSet );
+    virtual void        Reset( const SfxItemSet& rSet );
+
+};
+
+#endif // #ifndef _SVX_PARAGRPH_HXX
+
+
diff --git a/layout/workben/paragraph.src b/layout/workben/paragraph.src
new file mode 100644
index 0000000..323b941
--- /dev/null
+++ layout/workben/paragraph.src
@@ -0,0 +1,728 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: paragrph.src,v $
+ *
+ *  $Revision: 1.83 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 17:33:12 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+ // include ---------------------------------------------------------------
+#include <svx/dialogs.hrc>
+#include "helpid.hrc"
+#include "paragrph.hrc"
+
+ // RID_SVXPAGE_STD_PARAGRAPH ---------------------------------------------
+TabPage RID_SVXPAGE_STD_PARAGRAPH
+{
+	HelpId = HID_FORMAT_PARAGRAPH_STD ;
+	Hide = TRUE ;
+	Text [ en-US ] = "Indents and Spacing" ;
+	Size = MAP_APPFONT ( 260 , 185 ) ;
+	FixedText FT_LEFTINDENT
+	{
+		Pos = MAP_APPFONT ( 12 , 16 ) ;
+		Size = MAP_APPFONT ( 120 , 8 ) ;
+        Left = TRUE ;
+        Text [ en-US ] = "Before text" ;
+	};
+	MetricField ED_LEFTINDENT
+	{
+		Border = TRUE ;
+		Pos = MAP_APPFONT ( 135 , 14 ) ;
+		Size = MAP_APPFONT ( 40 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Maximum = 9999 ;
+		DecimalDigits = 2 ;
+		Unit = FUNIT_CM ;
+		Last = 9999 ;
+		SpinSize = 10 ;
+	};
+	FixedText FT_RIGHTINDENT
+	{
+		Pos = MAP_APPFONT ( 12 , 32 ) ;
+		Size = MAP_APPFONT ( 120 , 8 ) ;
+        Left = TRUE ;
+        Text [ en-US ] = "After text" ;
+	};
+	MetricField ED_RIGHTINDENT
+	{
+		Border = TRUE ;
+		Pos = MAP_APPFONT ( 135 , 30 ) ;
+		Size = MAP_APPFONT ( 40 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Maximum = 9999 ;
+		DecimalDigits = 2 ;
+		Unit = FUNIT_CM ;
+		Last = 9999 ;
+		SpinSize = 10 ;
+	};
+	FixedText FT_FLINEINDENT
+	{
+		Pos = MAP_APPFONT ( 12 , 48 ) ;
+		Size = MAP_APPFONT ( 120 , 8 ) ;
+		Text [ en-US ] = "~First line" ;
+		Left = TRUE ;
+	};
+	MetricField ED_FLINEINDENT
+	{
+		Border = TRUE ;
+		Pos = MAP_APPFONT ( 135 , 46 ) ;
+		Size = MAP_APPFONT ( 40 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Minimum = -9999 ;
+		Maximum = 9999 ;
+		DecimalDigits = 2 ;
+		Unit = FUNIT_CM ;
+		First = -9999 ;
+		Last = 9999 ;
+		SpinSize = 10 ;
+	};
+	CheckBox CB_AUTO
+	{
+		Pos = MAP_APPFONT ( 12 , 61 ) ;
+		Size = MAP_APPFONT ( 120 , 10 ) ;
+		Hide = TRUE ;
+		Text [ en-US ] = "~Automatic" ;
+	};
+    FixedLine FL_INDENT
+	{
+        Pos = MAP_APPFONT ( 6 , 3 ) ;
+        Size = MAP_APPFONT ( 173 , 8 ) ;
+		Text [ en-US ] = "Indent" ;
+	};
+	FixedText FT_TOPDIST
+	{
+		Pos = MAP_APPFONT ( 12 , 90 ) ;
+		Size = MAP_APPFONT ( 120 , 8 ) ;
+		Left = TRUE ;
+        Text [ en-US ] = "Ab~ove paragraph" ;
+	};
+	MetricField ED_TOPDIST
+	{
+		Border = TRUE ;
+		Pos = MAP_APPFONT ( 135 , 88 ) ;
+		Size = MAP_APPFONT ( 40 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Maximum = 9999 ;
+		DecimalDigits = 2 ;
+		Unit = FUNIT_CM ;
+		Last = 9999 ;
+		SpinSize = 10 ;
+	};
+	FixedText FT_BOTTOMDIST
+	{
+		Pos = MAP_APPFONT ( 12 , 104 ) ;
+		Size = MAP_APPFONT ( 120 , 8 ) ;
+		Left = TRUE ;
+        Text [ en-US ] = "Below paragraph" ;
+	};
+	MetricField ED_BOTTOMDIST
+	{
+		Border = TRUE ;
+		Pos = MAP_APPFONT ( 135 , 104 ) ;
+		Size = MAP_APPFONT ( 40 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Maximum = 9999 ;
+		DecimalDigits = 2 ;
+		Unit = FUNIT_CM ;
+		Last = 9999 ;
+		SpinSize = 10 ;
+	};
+    FixedLine FL_DIST
+	{
+		Pos = MAP_APPFONT ( 6 , 77 ) ;
+        Size = MAP_APPFONT ( 173 , 8 ) ;
+		Text [ en-US ] = "Spacing" ;
+	};
+	ListBox LB_LINEDIST
+	{
+		Pos = MAP_APPFONT ( 12 , 133 ) ;
+		Size = MAP_APPFONT ( 55 , 72 ) ;
+		DropDown = TRUE ;
+		StringList [ en-US ] =
+		{
+			< "Single" ; Default ; > ;
+			< "1.5 lines" ; Default ; > ;
+			< "Double" ; Default ; > ;
+			< "Proportional" ; Default ; > ;
+			< "At least" ; Default ; > ;
+			< "Leading" ; Default ; > ;
+		};
+	};
+	String ST_LINEDIST_ABS
+	{
+		Text [ en-US ] = "Fixed" ;
+	};
+	FixedText FT_LINEDIST
+	{
+		Disable = TRUE ;
+		Pos = MAP_APPFONT ( 70 , 135 ) ;
+		Size = MAP_APPFONT ( 60 , 8 ) ;
+		Text [ en-US ] = "of" ;
+		Left = TRUE ;
+	};
+	MetricField ED_LINEDISTPERCENT
+	{
+		Disable = TRUE ;
+		Border = TRUE ;
+		Pos = MAP_APPFONT ( 135 , 133 ) ;
+		Size = MAP_APPFONT ( 40 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Minimum = 50 ;
+		Maximum = 200 ;
+		Value = 100 ;
+		Unit = FUNIT_CUSTOM ;
+		CustomUnitText = "%" ;
+		First = 50 ;
+		Last = 200 ;
+		SpinSize = 1 ;
+	};
+	MetricField ED_LINEDISTMETRIC
+	{
+		Disable = TRUE ;
+		Border = TRUE ;
+		Hide = TRUE ;
+		Pos = MAP_APPFONT ( 135 , 133 ) ;
+		Size = MAP_APPFONT ( 40 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Maximum = 9999 ;
+		DecimalDigits = 2 ;
+		Unit = FUNIT_CM ;
+		Last = 9999 ;
+		SpinSize = 10 ;
+	};
+    FixedLine FL_LINEDIST
+	{
+		Pos = MAP_APPFONT ( 6 , 122 ) ;
+        Size = MAP_APPFONT ( 173 , 8 ) ;
+		Text [ en-US ] = "Line spacing" ;
+	};
+	Window WN_EXAMPLE
+	{
+        Border = TRUE ;
+        Pos = MAP_APPFONT ( 185 , 7 ) ;
+        Size = MAP_APPFONT ( 68 , 112 ) ;
+	};
+	CheckBox CB_REGISTER
+	{
+		Pos = MAP_APPFONT ( 12 , 162 ) ;
+		Size = MAP_APPFONT ( 120 , 10 ) ;
+		Hide = TRUE ;
+		Text [ en-US ] = "A~ctivate" ;
+	};
+    FixedLine FL_REGISTER
+	{
+		Pos = MAP_APPFONT ( 6 , 151 ) ;
+        Size = MAP_APPFONT ( 173 , 8 ) ;
+		Hide = TRUE ;
+		Text [ en-US ] = "Register-true" ;
+	};
+
+};
+ // RID_SVXPAGE_ALIGN_PARAGRAPH ---------------------------------------------
+TabPage RID_SVXPAGE_ALIGN_PARAGRAPH
+{
+	HelpId = HID_FORMAT_PARAGRAPH_ALIGN ;
+	Hide = TRUE ;
+	Text [ en-US ] = "Alignment" ;
+	Size = MAP_APPFONT ( 260 , 185 ) ;
+    FixedLine FL_ALIGN
+	{
+		Pos = MAP_APPFONT ( 6 , 3 ) ;
+        Size = MAP_APPFONT ( 173 , 8 ) ;
+		Text [ en-US ] = "Options" ;
+		Group = TRUE ;
+	};
+    RadioButton BTN_LEFTALIGN
+	{
+		Pos = MAP_APPFONT ( 12 , 14 ) ;
+		Size = MAP_APPFONT ( 161 , 10 ) ;
+		Text [ en-US ] = "~Left" ;
+		Group = TRUE ;
+	};
+	RadioButton BTN_RIGHTALIGN
+	{
+		Pos = MAP_APPFONT ( 12 , 28 ) ;
+		Size = MAP_APPFONT ( 161 , 10 ) ;
+		Text [ en-US ] = "Righ~t" ;
+	};
+    RadioButton BTN_CENTERALIGN
+	{
+		Pos = MAP_APPFONT ( 12 , 42 ) ;
+		Size = MAP_APPFONT ( 161 , 10 ) ;
+		Text [ en-US ] = "~Center" ;
+	};
+	RadioButton BTN_JUSTIFYALIGN
+	{
+		Pos = MAP_APPFONT ( 12 , 56 ) ;
+		Size = MAP_APPFONT ( 161 , 10 ) ;
+		Text [ en-US ] = "Justified" ;
+	};
+    String ST_LEFTALIGN_ASIAN
+    {
+        Text [ en-US ] = "~Left/Top" ;
+	};
+    String ST_RIGHTALIGN_ASIAN
+    {
+        Text [ en-US ] = "Righ~t/Bottom" ;
+	};
+	FixedText FT_LASTLINE
+	{
+		Pos = MAP_APPFONT ( 20 , 72 ) ;
+		Size = MAP_APPFONT ( 80 , 8 ) ;
+		Hide = TRUE ;
+		Text [ en-US ] = "~Last line" ;
+	};
+	ListBox LB_LASTLINE
+	{
+		Pos = MAP_APPFONT ( 105 , 70 ) ;
+		Size = MAP_APPFONT ( 70 , 50 ) ;
+		DropDown = TRUE ;
+		Hide = TRUE ;
+		StringList [ en-US ] =
+		{
+			< "Default" ; Default ; > ;
+			< "Left" ; Default ; > ;
+			< "Centered" ; Default ; > ;
+            < "Justified"; Default; > ;
+		};
+	};
+	CheckBox CB_EXPAND
+	{
+		Pos = MAP_APPFONT ( 20 , 86 ) ;
+		Size = MAP_APPFONT ( 153 , 10 ) ;
+		Hide = TRUE ;
+		Text [ en-US ] = "~Expand single word" ;
+	};
+    CheckBox CB_SNAP
+    {
+        Pos = MAP_APPFONT ( 20 , 100 ) ;
+		Size = MAP_APPFONT ( 153 , 10 ) ;
+        Hide = TRUE ;
+    	Text [ en-US ] = "Snap to text grid (if active)";
+	};
+    Window WN_EXAMPLE
+	{
+        Border = TRUE ;
+        Pos = MAP_APPFONT ( 185 , 7 ) ;
+        Size = MAP_APPFONT ( 68 , 112 ) ;
+	};
+    FixedLine FL_VERTALIGN
+    {
+        Pos = MAP_APPFONT ( 6 , 122 ) ;
+        Size = MAP_APPFONT ( 173 , 8 ) ;
+        Hide = TRUE;
+		Text [ en-US ] = "Text-to-text";
+	};
+    FixedText FT_VERTALIGN
+    {
+        Pos = MAP_APPFONT ( 12 , 135 ) ;
+        Size = MAP_APPFONT ( 90 , 8 ) ;
+        Hide = TRUE;
+    	Text [ en-US ] = "~Alignment";
+	};
+    ListBox LB_VERTALIGN
+    {
+		Pos = MAP_APPFONT ( 105 , 133 ) ;
+        Size = MAP_APPFONT ( 70 , 50 ) ;
+		DropDown = TRUE ;
+		Hide = TRUE ;
+		StringList [ en-US ] =
+		{
+			< "Automatic" ; > ;
+			< "Base line" ; > ;
+			< "Top" ; > ;
+			< "Middle" ; > ;
+			< "Bottom" ; > ;
+		};
+	};
+    FixedLine   FL_PROPERTIES
+    {
+        Pos = MAP_APPFONT ( 6 , 154 ) ;
+        Size = MAP_APPFONT ( 248 , 8 ) ;
+        Hide = TRUE ;
+    	Text [ en-US ] = "Properties";
+	};
+    FixedText   FT_TEXTDIRECTION
+    {
+        Pos = MAP_APPFONT ( 12 , 167 ) ;
+        Size = MAP_APPFONT ( 60 , 8 ) ;
+        Hide = TRUE ;
+    	Text [ en-US ] = "Text ~direction";
+	};
+    ListBox LB_TEXTDIRECTION
+    {
+		Border = TRUE ;
+		Pos = MAP_APPFONT ( 105 , 165 ) ;
+		Size = MAP_APPFONT ( 146 , 50 ) ;
+		DropDown = TRUE ;
+		Hide = TRUE ;
+	};
+};
+ // RID_SVXPAGE_EXT_PARAGRAPH ---------------------------------------------
+TabPage RID_SVXPAGE_EXT_PARAGRAPH
+{
+	HelpId = HID_FORMAT_PARAGRAPH_EXT ;
+	Hide = TRUE ;
+	Text [ en-US ] = "Text Flow" ;
+	Size = MAP_APPFONT ( 260 , 185 ) ;
+	TriStateBox BTN_HYPHEN
+	{
+		Pos = MAP_APPFONT ( 12 , 14 ) ;
+		Size = MAP_APPFONT ( 236 , 10 ) ;
+		Text [ en-US ] = "A~utomatically" ;
+	};
+	NumericField ED_HYPHENBEFORE
+	{
+		Disable = TRUE ;
+		Border = TRUE ;
+		Pos = MAP_APPFONT ( 21 , 26 ) ;
+		Size = MAP_APPFONT ( 24 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Minimum = 2 ;
+		Maximum = 9 ;
+		Value = 2 ;
+		First = 2 ;
+		Last = 9 ;
+	};
+	FixedText FT_HYPHENBEFORE
+	{
+		Disable = TRUE ;
+		Pos = MAP_APPFONT ( 48 , 29 ) ;
+		Size = MAP_APPFONT ( 200 , 8 ) ;
+		Text [ en-US ] = "C~haracters at line end" ;
+		Left = TRUE ;
+	};
+	NumericField ED_HYPHENAFTER
+	{
+		Disable = TRUE ;
+		Border = TRUE ;
+		Pos = MAP_APPFONT ( 21 , 41 ) ;
+		Size = MAP_APPFONT ( 24 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Minimum = 2 ;
+		Maximum = 9 ;
+		Value = 2 ;
+		First = 2 ;
+		Last = 9 ;
+	};
+	FixedText FT_HYPHENAFTER
+	{
+		Disable = TRUE ;
+		Pos = MAP_APPFONT ( 48 , 43 ) ;
+		Size = MAP_APPFONT ( 200 , 8 ) ;
+		Text [ en-US ] = "Cha~racters at line begin" ;
+		Left = TRUE ;
+	};
+	FixedText FT_MAXHYPH
+	{
+		Pos = MAP_APPFONT ( 48 , 57 ) ;
+		Size = MAP_APPFONT ( 200 , 8 ) ;
+		WordBreak = TRUE ;
+		Text [ en-US ] = "~Maximum number of consecutive hyphens" ;
+	};
+	NumericField ED_MAXHYPH
+	{
+		Border = TRUE ;
+		Pos = MAP_APPFONT ( 21 , 55 ) ;
+		Size = MAP_APPFONT ( 24 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Maximum = 99 ;
+		Last = 99 ;
+	};
+    FixedLine FL_HYPHEN
+	{
+		Pos = MAP_APPFONT ( 6 , 3 ) ;
+        Size = MAP_APPFONT ( 248 , 8 ) ;
+		Text [ en-US ] = "Hyphenation" ;
+	};
+    FixedLine FL_OPTIONS
+	{	// is moved one section deeper to not raise unnecessary translations
+		Pos = MAP_APPFONT ( 6 , 116 ) ;
+        Size = MAP_APPFONT ( 248 , 8 ) ;
+		Text [ en-US ] = "Options" ;
+		Group = TRUE ;
+	};
+    FixedLine FL_BREAKS
+	{
+		Pos = MAP_APPFONT ( 6 , 73 ) ;
+        Size = MAP_APPFONT ( 248 , 8 ) ;
+		Text [ en-US ] = "Breaks" ;
+		Group = TRUE ;
+	};
+    TriStateBox BTN_PAGEBREAK
+	{
+		 //			Disable = TRUE;
+        Pos = MAP_APPFONT ( 12 , 86 ) ;
+        Size = MAP_APPFONT ( 61 , 10 ) ;
+		Text [ en-US ] = "Insert" ;
+		Group = TRUE ;
+	};
+    FixedText FT_BREAKTYPE
+    {
+        Pos = MAP_APPFONT ( 75 , 86 ) ;
+        Size = MAP_APPFONT ( 21 , 10 ) ;
+    	Text [ en-US ] = "~Type";
+	};
+    ListBox LB_BREAKTYPE
+    {
+        Border = TRUE ;
+        Pos = MAP_APPFONT ( 98 , 84 ) ;
+        Size = MAP_APPFONT ( 61 , 50 ) ;
+		DropDown = TRUE ;
+	StringList [ en-US ] =
+	{
+		 < "Page" ; 0; > ;
+		< "Column" ; 1; > ;
+	};
+	};
+    FixedText FT_BREAKPOSITION
+    {
+        Pos = MAP_APPFONT ( 163 , 86 ) ;
+        Size = MAP_APPFONT ( 45 , 10 ) ;
+        Right = TRUE;
+    	Text [ en-US ] = "Position";
+	};
+    ListBox LB_BREAKPOSITION
+    {
+        Border = TRUE ;
+        Pos = MAP_APPFONT ( 211 , 84 ) ;
+        Size = MAP_APPFONT ( 40 , 50 ) ;
+		DropDown = TRUE ;
+	StringList [ en-US ] =
+	{
+		 < "Before" ; 0; > ;
+		< "After" ; 1; > ;
+	};
+	};
+    TriStateBox BTN_PAGECOLL
+	{
+		 //			Disable = TRUE;
+        Pos = MAP_APPFONT (21 , 100 ) ;
+		Size = MAP_APPFONT ( 75 , 10 ) ;
+		Text [ en-US ] = "With Page St~yle" ;
+		Group = TRUE ;
+	};
+	ListBox LB_PAGECOLL
+	{
+		 //			Disable = TRUE;
+        Pos = MAP_APPFONT ( 98 , 98 ) ;
+		Size = MAP_APPFONT ( 61 , 50 ) ;
+		DropDown = TRUE ;
+		Sort = TRUE;
+	};
+	FixedText FT_PAGENUM
+	{
+        Pos = MAP_APPFONT ( 163 , 100 ) ;
+        Size = MAP_APPFONT ( 45 , 8 ) ;
+        Right = TRUE ;
+		Text [ en-US ] = "Page ~number" ;
+	};
+	NumericField ED_PAGENUM
+	{
+		Border = TRUE ;
+        Pos = MAP_APPFONT ( 211 , 98 ) ;
+		Size = MAP_APPFONT ( 26 , 12 ) ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Minimum = 0 ;
+		Maximum = 9999 ;
+		Value = 0 ;
+		First = 0 ;
+		Last = 9999 ;
+	};
+	TriStateBox BTN_KEEPTOGETHER
+	{
+        Pos = MAP_APPFONT ( 12 , 127 ) ;
+        Size = MAP_APPFONT ( 236 , 10 ) ;
+		Text [ en-US ] = "~Do not split paragraph" ;
+		Group = TRUE ;
+	};
+	TriStateBox CB_KEEPTOGETHER
+	{
+        Pos = MAP_APPFONT ( 12, 141 ) ;
+        Size = MAP_APPFONT ( 236 , 10 ) ;
+		Text [ en-US ] = "~Keep with next paragraph" ;
+	};
+	TriStateBox BTN_ORPHANS
+	{
+		Disable = TRUE ;
+        Pos = MAP_APPFONT ( 12 , 155 ) ;
+        Size = MAP_APPFONT ( 120 , 10 ) ;
+		Group = TRUE ;
+		Text [ en-US ] = "~Orphan control";
+	};
+	NumericField ED_ORPHANS
+	{
+		Disable = TRUE ;
+		Border = TRUE ;
+        Pos = MAP_APPFONT ( 134 , 153 ) ;
+		Size = MAP_APPFONT ( 24 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Minimum = 2 ;
+		Maximum = 9 ;
+		Value = 2 ;
+		First = 2 ;
+		Last = 9 ;
+	};
+	FixedText FT_ORPHANS
+	{
+		Disable = TRUE ;
+        Pos = MAP_APPFONT ( 161 , 155 ) ;
+		Size = MAP_APPFONT ( 86 , 8 ) ;
+		Text [ en-US ] = "Lines" ;
+		Left = TRUE ;
+	};
+	TriStateBox BTN_WIDOWS
+	{
+		Disable = TRUE ;
+        Pos = MAP_APPFONT ( 12 , 169 ) ;
+        Size = MAP_APPFONT ( 120 , 10 ) ;
+		Group = TRUE ;
+		Text [ en-US ] = "~Widow control";
+	};
+	NumericField ED_WIDOWS
+	{
+		Disable = TRUE ;
+		Border = TRUE ;
+        Pos = MAP_APPFONT ( 134 , 167 ) ;
+		Size = MAP_APPFONT ( 24 , 12 ) ;
+		Group = TRUE ;
+		Left = TRUE ;
+		Repeat = TRUE ;
+		Spin = TRUE ;
+		Minimum = 2 ;
+		Maximum = 9 ;
+		Value = 2 ;
+		First = 2 ;
+		Last = 9 ;
+	};
+	FixedText FT_WIDOWS
+	{
+		Disable = TRUE ;
+        Pos = MAP_APPFONT ( 161 , 169 ) ;
+		Size = MAP_APPFONT ( 86 , 8 ) ;
+		Text [ en-US ] = "Lines" ;
+		Left = TRUE ;
+	};
+};
+/*-- 29.11.00 11:36:24---------------------------------------------------
+  Asian typography
+  -----------------------------------------------------------------------*/
+TabPage RID_SVXPAGE_PARA_ASIAN
+{
+	HelpId = HID_SVXPAGE_PARA_ASIAN ;
+	Hide = TRUE ;
+	Text [ en-US ] = "Asian Typography";
+	Size = MAP_APPFONT ( 260 , 185 ) ;
+    FixedLine FL_AS_OPTIONS
+	{
+		Pos = MAP_APPFONT ( 6 , 3 ) ;
+        Size = MAP_APPFONT ( 248 , 8 ) ;
+        Text [ en-US ] = "Line change";
+	};
+	TriStateBox CB_AS_FORBIDDEN
+	{
+		Pos = MAP_APPFONT ( 12 , 14 ) ;
+        Size = MAP_APPFONT ( 242 , 10 ) ;
+		Text [ en-US ] = "Apply list of forbidden characters to the beginning and end of lines";
+	};
+	TriStateBox CB_AS_ALLOW_WORD_BREAK
+	{
+		Pos = MAP_APPFONT ( 12 , 28 ) ;
+        Size = MAP_APPFONT ( 242 , 10 ) ;
+		Text [ en-US ] = "Allow ~breaks in words in Latin text";
+	};
+	TriStateBox CB_AS_HANG_PUNC
+	{
+		Pos = MAP_APPFONT ( 12 , 42 ) ;
+        Size = MAP_APPFONT ( 242 , 10 ) ;
+		Text [ en-US ] = "Allow hanging punctuation";
+	};
+    FixedLine FL_AS_CHAR_DIST
+	{
+		Pos = MAP_APPFONT ( 6 , 58 ) ;
+        Size = MAP_APPFONT ( 248 , 8 ) ;
+		Text [ en-US ] = "Character spacing";
+	};
+	TriStateBox CB_AS_PUNCTUATION
+	{
+		Pos = MAP_APPFONT ( 12, 69 ) ;
+        Size = MAP_APPFONT ( 242 , 10 ) ;
+		Text [ en-US ] = "Allow punctuation at line start";
+	};
+	TriStateBox CB_AS_SCRIPT_SPACE
+	{
+        Pos = MAP_APPFONT ( 12 , 83 ) ;
+        Size = MAP_APPFONT ( 242 , 10 ) ;
+		Text [ en-US ] = "Apply spacing between Asian, Latin and Complex text";
+	};
+	TriStateBox CB_AS_ADJUST_NUMBERS
+	{
+		Pos = MAP_APPFONT ( 12 , 97 ) ;
+        Size = MAP_APPFONT ( 242 , 10 ) ;
+		Text [ en-US ] = "Automatically adjust space between Asian text and numbers";
+	};
+};
+
+// ********************************************************************** EOF
diff --git a/layout/workben/paragraph.xml b/layout/workben/paragraph.xml
new file mode 100644
index 0000000..8132353
--- /dev/null
+++ layout/workben/paragraph.xml
@@ -0,0 +1,77 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+        xmlns:cnt="http://openoffice.org/2007/layout/container"
+        id="dialog" title="Paragraph" optimumsize="true"
+        has_border="true" sizeable="true" moveable="true">
+<vbox>
+	<tabcontrol>
+		<vbox cnt:title="Indents and Spacing">
+			<hbox cnt:expand="false">
+			 	<fixedtext id="FL_INDENT" label="Indent" cnt:expand="false" />
+			 	<fixedline />
+			 </hbox>
+			 <table columns="2" cnt:expand="false">
+			 	<fixedtext id="FT_LEFTINDENT" label="Before text" />
+			 	<metricfield id="ED_LEFTINDENT" spin="true" has_border="true"/>
+			 	<fixedtext id="FT_RIGHTINDENT" label="After text" />
+			 	<metricfield id="ED_RIGHTINDENT" spin="true" has_border="true"/>
+			 	<fixedtext id="FT_FLINEINDENT" label="First line" />
+			 	<metricfield id="ED_FLINEINDENT" spin="true" has_border="true" />
+			 	<checkbox id="CB_AUTO" label="Automatic" cnt:col-span="2" />
+			 </table>
+			<hbox cnt:expand="false">
+			 	<fixedtext id="FL_DIST" label="Spacing" cnt:expand="false" />
+			 	<fixedline />
+			 </hbox>
+			 <table columns="2" cnt:expand="false">
+			 	<fixedtext id="FT_TOPDIST" label="Above paragraph" />
+			 	<numericfield id="ED_TOPDIST" spin="true" has_border="true" />
+			 	<fixedtext id="FT_BOTTOMDIST" label="Below paragraph" />
+			 	<numericfield id="ED_BOTTOMDIST" spin="true" has_border="true" />
+			 </table>
+			<hbox cnt:expand="false">
+			 	<fixedtext id="FL_LINEDIST" label="Line spacing" cnt:expand="false" />
+			 	<fixedline />
+			 </hbox>
+			<hbox cnt:expand="false">
+				<listbox id="LB_LINEDIST" dropdown="true"
+					string-item-list="Single:1.5 lines:Double:Proportional"
+					cnt:expand="false"/>
+				<fixedtext id="FT_LINEDIST" label="of" cnt:expand="true" />
+				<numericfield id="ED_LINEDISTPERCENT" value="0" />
+			</hbox>
+			<hbox id="FL_REGISTER" cnt:expand="false">
+				<fixedtext label="Register-true" cnt:expand="false" />
+				<fixedline />
+			</hbox>
+		 	<checkbox id="CB_REGISTER" cnt:expand="false" label="Activate" />
+		</vbox>
+
+		<vbox cnt:title="Alignment">
+			<hbox cnt:expand="false">
+				<fixedtext id="FL_ALIGN" label="Options" cnt:expand="false" />
+				<fixedline />
+			</hbox>
+		 	<radiobutton id="BTN_LEFTALIGN" label="Left" cnt:expand="false" />
+		 	<radiobutton id="BTN_RIGHTALIGN" label="Right" cnt:expand="false" />
+		 	<radiobutton id="BTN_CENTERALIGN" label="Center" cnt:expand="false" />
+		 	<radiobutton id="BTN_JUSTIFYALIGN" label="Justify" cnt:expand="false" />
+			<hbox cnt:expand="false">
+				<fixedtext id="FL_ALIGN" label="Last line" cnt:expand="false" />
+				<listbox dropdown="true" string-item-list="Left:Centered:Justified"
+				          id="LB_LASTLINE" />
+			</hbox>
+		</vbox>
+	</tabcontrol>
+
+	<align cnt:expand="false">
+		<hbox cnt:expand="false" cnt:hfill="0" cnt:halign="1">
+			<pushbutton label="OK" />
+			<pushbutton label="Cancel" />
+			<pushbutton label="Help" />
+			<pushbutton label="Reset" />
+		</hbox>
+	</align>
+</vbox>
+</dialog>
diff --git a/layout/workben/radio-groups.xml b/layout/workben/radio-groups.xml
new file mode 100644
index 0000000..a1dd6bf
--- /dev/null
+++ layout/workben/radio-groups.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+        xmlns:cnt="http://openoffice.org/2007/layout/container"
+        title="Radio Groups Test"
+        optimumsize="true" has_border="true" sizeable="true" moveable="true">
+	<vbox>
+		<hbox>
+			<radiobutton group="1" label="Group 1"
+			             cnt:expand="false" cnt:fill="false" />
+			<radiobutton group="2" label="Group 2"
+			             cnt:expand="true" cnt:fill="true" />
+			<radiobutton group="2" label="Group 2"
+			             cnt:expand="true" cnt:fill="false" />
+			<radiobutton group="1" label="Group 1 (default)" state="1"
+			             cnt:expand="false" cnt:fill="false" />
+		</hbox>
+		<radiobutton group="1" label="Group 1" state="0"
+		             cnt:expand="false" cnt:fill="false" />
+	</vbox>
+</dialog>
diff --git a/layout/workben/refresh b/layout/workben/refresh
new file mode 100644
index 0000000..f4dd41b
--- /dev/null
+++ layout/workben/refresh
@@ -0,0 +1,3 @@
+echo "source me ..."
+test -n "${INPATH}" && rm -Rf ../${INPATH}
+build debug=true && cp ../${INPATH}/lib/*.so ../../solver/680/${INPATH}/lib && dmake debug=true && ../${INPATH}/bin/test "$@"
diff --git a/layout/workben/run-s2x b/layout/workben/run-s2x
new file mode 100755
index 0000000..926addf
--- /dev/null
+++ layout/workben/run-s2x
@@ -0,0 +1,6 @@
+#! /bin/sh
+
+SRC=${1-../../svx/source/dialog/zoom.src}
+SRC=${1-../../sw/source/ui/dialog/wordcountdialog.src}
+
+../src2xml/source/src2xml.py --ignore-includes --post-process --output-dir=. $SRC
diff --git a/layout/workben/scroller.xml b/layout/workben/scroller.xml
new file mode 100644
index 0000000..361fbe2
--- /dev/null
+++ layout/workben/scroller.xml
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+        xmlns:cnt="http://openoffice.org/2007/layout/container"
+        title="Scroll Test" optimumsize="true"
+        has_border="true" sizeable="true" moveable="true">
+	<vbox>
+		<scroller>
+			<vbox>
+				<pushbutton label="Button 1" />
+				<edit has_border="true" text="Edit 1" />
+				<pushbutton label="Button 2" />
+				<pushbutton label="Button 3" />
+				<pushbutton label="Button 4" />
+				<pushbutton label="Button 5" />
+				<pushbutton label="Button 6" />
+				<pushbutton label="Button 7" />
+				<pushbutton label="Button 8" />
+				<pushbutton label="Button 9" />
+				<pushbutton label="Button 10" />
+				<pushbutton label="Button 11" />
+				<pushbutton label="Button 12" />
+				<pushbutton label="Button 13" />
+				<pushbutton label="Button 14" />
+				<pushbutton label="Button 15" />
+				<pushbutton label="Button 16" />
+				<pushbutton label="Button 17" />
+			</vbox>
+		</scroller>
+		<okbutton cnt:expand="false" />
+	</vbox>
+</dialog>
diff --git a/layout/workben/sequence.xml b/layout/workben/sequence.xml
new file mode 100644
index 0000000..d475bcf
--- /dev/null
+++ layout/workben/sequence.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<framewindow xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             xmlns:style="http://openoffice.org/2007/layout/style"
+             title="Sequence Test" style:optimumsize="true"
+             style:has_border="true" style:sizeable="true" style:moveable="true">
+		<vbox>
+			<multilistbox linecount="5" string-item-list=":a:b::c:::d::::e:as:"
+			                            selected-items="0:1" />
+			<okbutton cnt:expand="false" />
+		</vbox>
+</framewindow>
diff --git a/layout/workben/shutdown.xml b/layout/workben/shutdown.xml
new file mode 100644
index 0000000..7863caa
--- /dev/null
+++ layout/workben/shutdown.xml
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<modaldialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             id="dialog" title="Shutdown Dialog" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true">
+    <vbox border="5" spacing="5">
+	<fixedline text="Platform default"/>
+	<dialogbuttonhbox border="5" spacing="5">
+	    <flow/>
+	    <okbutton label="~Shutdown"/>
+	    <cancelbutton/>
+	    <pushbutton label="Pause"/>
+	    <pushbutton label="Sleep"/>
+	    <pushbutton label="Restart"/>
+	</dialogbuttonhbox>
+	<fixedline text="GNOME"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="gnome">
+	    <flow/>
+	    <okbutton label="~Shutdown"/>
+	    <cancelbutton/>
+	    <pushbutton label="Pause"/>
+	    <pushbutton label="Sleep"/>
+	    <pushbutton label="Restart"/>
+	</dialogbuttonhbox>
+	<fixedline text="KDE"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="kde">
+	    <flow/>
+	    <okbutton label="~Shutdown"/>
+	    <cancelbutton/>
+	    <pushbutton label="Pause"/>
+	    <pushbutton label="Sleep"/>
+	    <pushbutton label="Restart"/>
+	</dialogbuttonhbox>
+	<fixedline text="MacOS"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="macos">
+	    <flow/>
+	    <okbutton label="~Shutdown"/>
+	    <cancelbutton/>
+	    <pushbutton label="Pause"/>
+	    <pushbutton label="Sleep"/>
+	    <pushbutton label="Restart"/>
+	</dialogbuttonhbox>
+	<fixedline text="Windows"/>
+	<dialogbuttonhbox border="5" spacing="5" ordering="windowsg">
+	    <flow/>
+	    <okbutton label="~Shutdown"/>
+	    <cancelbutton/>
+	    <pushbutton label="Pause"/>
+	    <pushbutton label="Sleep"/>
+	    <pushbutton label="Restart"/>
+	</dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/layout/workben/simple-paragraph.cxx b/layout/workben/simple-paragraph.cxx
new file mode 100644
index 0000000..5acf09f
--- /dev/null
+++ layout/workben/simple-paragraph.cxx
@@ -0,0 +1,159 @@
+#ifdef SVX_DLLIMPLEMENTATION
+#undef SVX_DLLIMPLEMENTATION
+#endif
+
+#include <toolkit/awt/vclxwindow.hxx>
+
+// include ---------------------------------------------------------------
+
+#include <stdio.h>
+
+#ifndef _SHL_HXX
+#include <tools/shl.hxx>
+#endif
+#ifndef _SFX_OBJSH_HXX
+#include <sfx2/objsh.hxx>
+#endif
+#ifndef _SV_MSGBOX_HXX //autogen wg. RET_OK, RET_CANCEL
+#include <vcl/msgbox.hxx>
+#endif
+
+#include <stdio.h>
+
+namespace SVX {
+#include <svx/paraprev.hxx>        // Preview
+};
+
+#include "simple-paragraph.hxx"
+
+#include <assert.h>
+
+
+
+
+
+// StandardTabPage ----------------------------------------------------------
+
+#define FT_LEFTINDENT            10
+#define ED_LEFTINDENT            11
+#define FT_FLINEINDENT            12
+#define ED_FLINEINDENT            13
+#define FT_RIGHTINDENT            14
+#define ED_RIGHTINDENT            15
+#define FL_INDENT                       16
+
+#define FT_TOPDIST                      20
+#define ED_TOPDIST                      21
+#define FT_BOTTOMDIST            22
+#define ED_BOTTOMDIST            23
+#define FL_DIST                         24
+
+#define BTN_LEFTALIGN            30
+#define BTN_RIGHTALIGN            31
+#define BTN_CENTERALIGN            32
+#define BTN_JUSTIFYALIGN        33
+#define FL_ALIGN                        34
+#define FL_VERTALIGN                    35
+#define LB_VERTALIGN                    36
+#define FL_VERTEX                       37
+#define CB_SNAP                         38
+#define FT_VERTALIGN                    39
+
+
+#define LB_LINEDIST                     40
+#define FT_LINEDIST                     41
+#define ED_LINEDISTPERCENT        42
+#define ED_LINEDISTMETRIC        43
+#define FL_LINEDIST                     44
+#define WN_EXAMPLE                      46
+
+#define CB_AUTO                         48
+#define FT_LASTLINE                     49
+#define LB_LASTLINE                     50
+#define CB_EXPAND                       51
+#define ST_LINEDIST_ABS                 52
+#define ST_LEFTALIGN_ASIAN              53
+#define ST_RIGHTALIGN_ASIAN             54
+
+// ExtendedTabPage ----------------------------------------------------------
+
+#define BTN_HYPHEN                      50
+#define ED_HYPHENBEFORE            52
+#define FT_HYPHENBEFORE            53
+#define ED_HYPHENAFTER            55
+#define FT_HYPHENAFTER            56
+#define FL_HYPHEN                       57
+
+#define BTN_PAGEBREAK            60
+#define FT_BREAKTYPE            61
+#define LB_BREAKTYPE            62
+#define FT_BREAKPOSITION        63
+#define LB_BREAKPOSITION        64
+#define BTN_PAGECOLL            65
+#define LB_PAGECOLL                     66
+#define BTN_KEEPTOGETHER        67
+#define BTN_WIDOWS                      68
+#define ED_WIDOWS                       69
+#define FT_WIDOWS                       70
+#define BTN_ORPHANS                     71
+#define ED_ORPHANS                      72
+#define FT_ORPHANS                      73
+#define FL_OPTIONS                      74
+#define FT_PAGENUM                      75
+#define ED_PAGENUM                      76
+#define FL_BREAKS                        77
+
+#define CB_KEEPTOGETHER                 80
+#define FT_MAXHYPH                      81
+#define ED_MAXHYPH                      83
+
+#define CB_REGISTER                     84
+#define FL_REGISTER                     85
+#define FL_PROPERTIES                   90
+#define FT_TEXTDIRECTION                91
+#define LB_TEXTDIRECTION                92
+
+
+//asian typography
+#define FL_AS_OPTIONS                   1
+#define CB_AS_HANG_PUNC                 2
+#define CB_AS_ALLOW_WORD_BREAK          3
+#define CB_AS_FORBIDDEN                 4
+#define FL_AS_CHAR_DIST                 5
+#define CB_AS_PUNCTUATION               6
+#define CB_AS_SCRIPT_SPACE                7
+#define CB_AS_ADJUST_NUMBERS            8
+
+
+
+
+
+
+
+
+SvxSimpleParagraphDialog::SvxSimpleParagraphDialog( Window* pParent ) :
+    SfxTabPage( pParent, SVX_RES( RID_SVXPAGE_STD_PARAGRAPH ), rAttr ),
+    Dialog( pParent, "simple-paragraph.xml", "dialog" ),
+    aLineSpacingList( this, "line-spacing-list" )
+{
+fprintf(stderr, "creating res mgr\n");
+    pMgr = ResMgr::CreateResMgr("SOME_NAME");
+fprintf(stderr, "getting parent\n");
+    VCLXWindow *pCompParent = VCLXWindow::GetImplementation( GetPeer() );
+    assert( pCompParent != NULL );
+    assert( pCompParent->GetWindow() != NULL );
+fprintf(stderr, "creating foreign vcl widget\n");
+/*    pPrevWin = new SVX::SvxParaPrevWindow(
+        pCompParent->GetWindow(),
+        ResId(1234, *pMgr)
+        );*/
+
+fprintf(stderr, "done\n");
+    FreeResource();
+}
+
+// -----------------------------------------------------------------------
+
+SvxSimpleParagraphDialog::~SvxSimpleParagraphDialog()
+{
+}
diff --git a/layout/workben/simple-paragraph.hxx b/layout/workben/simple-paragraph.hxx
new file mode 100644
index 0000000..000bec5
--- /dev/null
+++ layout/workben/simple-paragraph.hxx
@@ -0,0 +1,25 @@
+#ifndef _SVX_SIMPLE_PARAGRAPH_HXX
+#define _SVX_SIMPLE_PARAGRAPH_HXX
+
+#include <layout/layout.hxx>
+
+#include <svx/paraprev.hxx>        // Preview
+
+namespace SVX {
+    class SvxParaPrevWindow;
+};
+class ResMgr;
+
+class SvxSimpleParagraphDialog : public SfxTabPage, public layout::Dialog
+{
+private:
+    ListBox aLineSpacingList;
+    SVX::SvxParaPrevWindow *pPrevWin;
+    ResMgr *pMgr;
+
+public:
+    SvxSimpleParagraphDialog( Window* pParent );
+    ~SvxSimpleParagraphDialog();
+};
+
+#endif
diff --git a/layout/workben/simple-paragraph.xml b/layout/workben/simple-paragraph.xml
new file mode 100644
index 0000000..0548ac7
--- /dev/null
+++ layout/workben/simple-paragraph.xml
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+        xmlns:cnt="http://openoffice.org/2007/layout/container"
+        id="dialog" title="Paragraph test" optimumsize="true"
+        has_border="true" sizeable="true" moveable="true">
+	<vbox>
+		<listbox id="line-spacing-list" dropdown="true" cnt:expand="false"
+		         string-item-list="Single:1.5 lines:Double:Proportional" />
+	</vbox>
+</dialog>
diff --git a/layout/workben/splitter.xml b/layout/workben/splitter.xml
new file mode 100644
index 0000000..95e14f1
--- /dev/null
+++ layout/workben/splitter.xml
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             title="Splitter Test" optimumsize="true" has_border="true" sizeable="true" moveable="true">
+	<vbox>
+		<hsplitter>
+			<pushbutton label="Left" />
+			<pushbutton label="Right" />
+		</hsplitter>
+		<okbutton cnt:expand="false" />
+	</vbox>
+</dialog>
diff --git a/layout/workben/tabcontrol.xml b/layout/workben/tabcontrol.xml
new file mode 100644
index 0000000..7939233
--- /dev/null
+++ layout/workben/tabcontrol.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+        xmlns:cnt="http://openoffice.org/2007/layout/container"
+        title="TabControl Test" optimumsize="true"
+        has_border="true" sizeable="true" moveable="true">
+	<vbox>
+		<tabcontrol>
+-			<pushbutton label="Child 1" cnt:title="Page 1" />
+			<edit has_border="true" text="Child 2" cnt:title="Page 2" />
+			<vbox cnt:title="Page 3">
+				<pushbutton label="Child 3"/>
+				<edit has_border="true" text="Child 4" />
+			</vbox>
+		</tabcontrol>
+		<okbutton cnt:expand="false" />
+	</vbox>
+</dialog>
diff --git a/layout/workben/table.xml b/layout/workben/table.xml
new file mode 100644
index 0000000..59ce362
--- /dev/null
+++ layout/workben/table.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             title="Table Test" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true">
+	<table columns="3">
+		<!-- row 0 -->
+		<pushbutton cnt:x-expand="false" cnt:row-span="2" label="1,1" />
+		<pushbutton cnt:y-expand="false" label="1,2" />
+		<pushbutton cnt:y-expand="false" label="1,3" />
+		<!-- row 1 -->
+		<pushbutton cnt:col-span="2" label="2,1" />
+	</table>
+</dialog>
diff --git a/layout/workben/test.cxx b/layout/workben/test.cxx
new file mode 100644
index 0000000..c850a4d
--- /dev/null
+++ layout/workben/test.cxx
@@ -0,0 +1,286 @@
+#include <vcl/svapp.hxx>
+// This works and was used before for standalone test, not sure why
+// we'd want it.
+#define LAYOUT_WEAK 1
+#include "uno.hxx"
+
+#include <cstdio>
+#include <osl/file.h>
+
+#include <rtl/ustring.hxx>
+#include <cppuhelper/bootstrap.hxx>
+
+#include <ucbhelper/contentbroker.hxx>
+#include <ucbhelper/configurationkeys.hxx>
+
+#include <comphelper/processfactory.hxx>
+#include <com/sun/star/xml/sax/SAXException.hpp>
+
+#include "editor.hxx"
+
+#include "wordcountdialog.hxx"
+#undef _LAYOUT_POST_HXX
+#include "zoom.hxx"
+#undef _LAYOUT_POST_HXX
+
+//#undef SW_WORDCOUNTDIALOG_HXX
+#include <layout/layout-pre.hxx>
+
+using namespace ::rtl;
+using namespace ::cppu;
+using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+
+Reference< XComponentContext > createInitialComponentContext(
+    OUString const & inst_dir )
+{
+    Reference< XComponentContext > xContext;
+    
+    try
+    {
+        OUString file_url;
+        oslFileError rc = osl_getFileURLFromSystemPath(
+            inst_dir.pData, &file_url.pData );
+        OSL_ASSERT( osl_File_E_None == rc );
+        (void) rc;  // quiet warning
+        
+        OUString unorc = file_url + OUString(
+            OUString::createFromAscii( "/program/" SAL_CONFIGFILE( "uno" )) );
+        
+        return defaultBootstrap_InitialComponentContext( unorc );
+    }
+    
+    catch( Exception& rExc )
+    {
+        OString aStr( OUStringToOString( rExc.Message,
+                                         RTL_TEXTENCODING_ASCII_US ) );
+        OSL_ENSURE( 0, aStr.getStr() );
+    }
+    
+    return xContext;
+}
+
+
+// -----------------------------------------------------------------------
+
+class LayoutTest : public Application
+{
+    Reference< XComponentContext >          mxContext;
+    Reference< lang::XMultiServiceFactory > mxMSF;
+    OUString mInstallDir;
+    OUString mTestDialog;
+    bool mEditMode;
+    std::list< OUString > mFiles;
+
+public:
+    LayoutTest( char const* installDir );
+
+    void RunEditor();
+    void RunFiles();
+    void ExceptionalMain();
+    void Init();
+    void InitUCB();
+    void LoadFile( OUString const &aName );
+    void Main();
+    void ParseCommandLine();
+};
+
+static void usage()
+{
+    fprintf (stderr, "usage: test [--inst inst_dir] [DIALOG.XML]... | --test [DIALOG.XML]\n" );
+    exit( 2 );
+}
+
+void LayoutTest::LoadFile( const OUString &aTestFile )
+{
+    fprintf( stderr, "TEST: layout instance\n" );
+
+    uno::Reference< lang::XSingleServiceFactory > xFactory(
+        comphelper::createProcessComponent(
+            rtl::OUString::createFromAscii( "com.sun.star.awt.Layout" ) ),
+        uno::UNO_QUERY );
+    if ( !xFactory.is() )
+    {
+        fprintf( stderr, "Layout engine not installed\n" );
+        throw uno::RuntimeException(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Layout engine not installed" ) ),
+            uno::Reference< uno::XInterface >() );
+    }
+    fprintf( stderr, "TEST: initing root\n" );
+
+    uno::Sequence< uno::Any > aParams( 1 );
+    aParams[0] <<= aTestFile;
+
+    uno::Reference< awt::XLayoutRoot > xRoot (
+        xFactory->createInstanceWithArguments( aParams ),
+        uno::UNO_QUERY );
+
+    fprintf( stderr, "TEST: file loaded\n" );
+}
+
+// Nurgh ...
+void LayoutTest::InitUCB()
+{
+    OUString aEmpty;
+    Sequence< Any > aArgs(6);
+    aArgs[0]
+        <<= OUString::createFromAscii(UCB_CONFIGURATION_KEY1_LOCAL);
+    aArgs[1]
+        <<= OUString::createFromAscii(UCB_CONFIGURATION_KEY2_OFFICE);
+    aArgs[2] <<= OUString::createFromAscii( "PIPE" );
+    aArgs[3] <<= aEmpty;
+    aArgs[4] <<= OUString::createFromAscii( "PORTAL" );
+    aArgs[5] <<= aEmpty;
+
+    if (! ::ucbhelper::ContentBroker::initialize( mxMSF, aArgs ) )
+        fprintf( stderr, "Failed to init content broker\n" );
+}
+
+#define INIT_ENV_VOODOO( installDir )                                   \
+    /* Unless you do this, obviously you don't deserve to have anything work */ \
+    OString aCfg = "CFG_INIFILE=file://"                                \
+                 + OUStringToOString( installDir, RTL_TEXTENCODING_UTF8 ) \
+                 + "/program/configmgrrc";                              \
+    putenv( (char *)aCfg.getStr() );                                    \
+    /* Unless you do this, obviously you don't want your paths to be correct & \
+       hence no images.zip location is possible. */                     \
+    OString aBaseInst = "BaseInstallation=file://"                      \
+                 + OUStringToOString( installDir, RTL_TEXTENCODING_UTF8 ); \
+    putenv( (char *)aBaseInst.getStr() );                               \
+
+void LayoutTest::Init()
+{
+    INIT_ENV_VOODOO( mInstallDir );
+
+    mxContext = createInitialComponentContext( mInstallDir );
+    mxMSF = new UnoBootstrapLayout( Reference< lang::XMultiServiceFactory >( mxContext->getServiceManager(), UNO_QUERY ) );
+    ::comphelper::setProcessServiceFactory( mxMSF );
+    InitUCB();
+}
+
+void LayoutTest::ParseCommandLine()
+{
+    for ( int i = 0; i < GetCommandLineParamCount(); i++ )
+    {
+        OUString aParam = OUString( GetCommandLineParam( i ) );
+        if ( aParam.equalsAscii( "-h" ) || aParam.equalsAscii( "--help" ) )
+            usage();
+        if ( aParam.equalsAscii( "--inst" ) )
+        {
+            if ( i >= GetCommandLineParamCount() - 1)
+                usage();
+            mInstallDir = GetCommandLineParam( ++i );
+        }
+        else if ( aParam.equalsAscii( "--test" ) )
+        {
+            mTestDialog = OUString::createFromAscii( "zoom" );
+            if (i + 1 < GetCommandLineParamCount())
+                mTestDialog = GetCommandLineParam( ++i );
+        }
+        else if ( aParam.equalsAscii( "--editor" ) )
+            mEditMode = true;
+        else
+            mFiles.push_back( aParam );
+    }
+
+    if ( mFiles.size() <= 0 )
+        mFiles.push_back( OUString::createFromAscii( "layout.xml" ) );
+}    
+
+void LayoutTest::RunEditor()
+{
+    OUString aFile;
+    if ( !mFiles.empty()
+        && mFiles.front().compareToAscii( "layout.xml" ) != 0 )
+        aFile = mFiles.front();
+    Editor editor( mxMSF, aFile );
+    editor.Show();
+    editor.Execute();
+}
+
+void RunDialog( layout::Dialog& dialog )
+{
+    dialog.Show();
+    dialog.Execute();
+    fprintf( stderr, "1st execute exited" );
+    dialog.Execute();
+    fprintf( stderr, "2nd execute exited" );
+}
+
+void TestDialog( OUString const& name )
+{
+    if ( name.equalsAscii( "zoom" ) )
+    {
+        SvxZoomDialog zoom( 0 );
+        RunDialog( zoom );
+    }
+    else if ( name.equalsAscii( "wordcount" ) )
+    {
+        SwWordCountDialog words ( 0 );
+        RunDialog( words );
+    }
+}
+
+void LayoutTest::RunFiles()
+{
+    fprintf( stderr, "TEST: loading files\n" );
+    for ( std::list< OUString >::iterator  i = mFiles.begin(); i != mFiles.end(); i++ )
+        LoadFile( *i );
+    fprintf( stderr, "TEST: executing\n" );
+    Execute(); 
+    fprintf( stderr, "TEST: done executing\n" );
+}
+
+void LayoutTest::ExceptionalMain()
+{
+    ParseCommandLine();
+    Init();
+    INIT_ENV_VOODOO( mInstallDir );
+
+    if ( mTestDialog.getLength() )
+        TestDialog( mTestDialog );
+    else if ( mEditMode )
+        RunEditor();
+    else
+        RunFiles();
+}
+
+void LayoutTest::Main()
+{
+    try
+    {
+        ExceptionalMain();
+    }
+    catch (xml::sax::SAXException & rExc)
+    {
+        OString aStr( OUStringToOString( rExc.Message,
+                                         RTL_TEXTENCODING_ASCII_US ) );
+        uno::Exception exc;
+        if (rExc.WrappedException >>= exc)
+        {
+            aStr += OString( " >>> " );
+            aStr += OUStringToOString( exc.Message, RTL_TEXTENCODING_ASCII_US );
+        }
+        fprintf (stderr, "Parsing error: '%s'\n", aStr.getStr());
+        OSL_ENSURE( 0, aStr.getStr() );
+    }
+    catch ( uno::Exception & rExc )
+    {
+        OString aStr( OUStringToOString( rExc.Message,
+                                         RTL_TEXTENCODING_ASCII_US ) );
+        fprintf (stderr, "UNO error: '%s'\n", aStr.getStr());
+        OSL_ENSURE( 0, aStr.getStr() );
+    }
+
+    Reference< lang::XComponent > xComp( mxContext, UNO_QUERY );
+    if ( xComp.is() )
+        xComp->dispose();
+}
+
+
+LayoutTest::LayoutTest( char const* installDir )
+    : mInstallDir( OUString::createFromAscii ( installDir ) )
+{
+}
+
+LayoutTest LayoutTest( "/usr/local/lib/ooo" );
diff --git a/layout/workben/test.xml b/layout/workben/test.xml
new file mode 100644
index 0000000..c933265
--- /dev/null
+++ layout/workben/test.xml
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<dialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             title="Interactable Containers" optimumsize="true"
+             has_border="true" sizeable="true" moveable="true">
+	<tabcontrol>
+		<tabpage cnt:title="Page">
+			<pushbutton label="Test" />
+		</tabpage>
+	</tabcontrol>
+</dialog>
diff --git a/layout/workben/un-test.sh b/layout/workben/un-test.sh
new file mode 100755
index 0000000..ef2518f
--- /dev/null
+++ layout/workben/un-test.sh
@@ -0,0 +1,14 @@
+#! /bin/sh
+
+# un-test.sh: remove TEST_LAYOUT code from OO.o implementation
+
+sed -e 's!^#!@!' < $1\
+    -e 's!$! /*$*/!' \
+    -e 's!^@\(.*TEST_LAYOUT\)!#\1!'\
+    | tee i \
+    | cpp -traditional -C -CC -DNON_LAYOUT_COMPILE_FIXES=1 \
+    | grep -F '/*$*/' \
+    | sed -e 's! /\*\$\*/!!' \
+    -e 's!^@!#!' \
+    -e 's!#define 1 1!#define NON_LAYOUT_COMPILE_FIXES 1!'
+
diff --git a/layout/workben/uno.hxx b/layout/workben/uno.hxx
new file mode 100644
index 0000000..dc5e958
--- /dev/null
+++ layout/workben/uno.hxx
@@ -0,0 +1,79 @@
+#ifndef _LAYOUT_UNO_HXX
+#define _LAYOUT_UNO_HXX
+
+#include <stdio.h>
+#include <com/sun/star/lang/XComponent.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+
+#include "../source/core/root.hxx"
+#include "../source/core/factory.hxx"
+
+#if LAYOUT_WEAK
+#include <cppuhelper/implbase1.hxx>
+class UnoBootstrapLayout : public ::cppu::WeakImplHelper1< com::sun::star::lang::XMultiServiceFactory >
+#else /* !LAYOUT_WEAK */
+class UnoBootstrapLayout : public com::sun::star::lang::XMultiServiceFactory
+#endif /* LAYOUT_WEAK */
+{
+public:
+    com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory > mxMSF;
+    UnoBootstrapLayout( com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory > xMSF )
+        : mxMSF( xMSF )
+    {
+        fprintf( stderr, "UnoBootstrap Layout\n" );
+    }
+    virtual com::sun::star::uno::Reference< com::sun::star::uno::XInterface > SAL_CALL
+    createInstance( const rtl::OUString& aServiceSpecifier ) throw (com::sun::star::uno::Exception, com::sun::star::uno::RuntimeException)
+    {
+        if ( aServiceSpecifier.equalsAscii( "com.sun.star.awt.Layout" ) )
+        {
+            fprintf( stderr, "UnoBootstrapLayout: create service '%s'\n",
+                     rtl::OUStringToOString (aServiceSpecifier, RTL_TEXTENCODING_UTF8 ).getStr() );
+            return com::sun::star::uno::Reference< com::sun::star::lang::XSingleServiceFactory >( new ::LayoutFactory( this ) );
+        }
+        else
+        {
+            fprintf( stderr, "UnoBootstrapLayout: create service '%s'\n",
+                     rtl::OUStringToOString (aServiceSpecifier, RTL_TEXTENCODING_UTF8 ).getStr() );
+            try
+            {
+                return mxMSF->createInstance( aServiceSpecifier );
+            }
+            catch ( const com::sun::star::uno::Exception &rExc )
+            {
+                rtl::OString aStr( rtl::OUStringToOString( rExc.Message, RTL_TEXTENCODING_ASCII_US ) );
+                fprintf( stderr, "service construction exception '%s'\n", aStr.getStr());
+                throw rExc;
+            }
+        }
+    }
+    virtual com::sun::star::uno::Reference< com::sun::star::uno::XInterface > SAL_CALL
+    createInstanceWithArguments( const rtl::OUString& ServiceSpecifier, const com::sun::star::uno::Sequence< com::sun::star::uno::Any >& Arguments ) throw (com::sun::star::uno::Exception, com::sun::star::uno::RuntimeException)
+    {
+        return mxMSF->createInstanceWithArguments( ServiceSpecifier, Arguments );
+    }
+    virtual com::sun::star::uno::Sequence< rtl::OUString > SAL_CALL
+    getAvailableServiceNames() throw (com::sun::star::uno::RuntimeException)
+    {
+        return mxMSF->getAvailableServiceNames();
+    }
+
+#if !LAYOUT_WEAK
+    // XInterface
+    virtual ::com::sun::star::uno::Any SAL_CALL queryInterface( const ::com::sun::star::uno::Type & rType ) throw(::com::sun::star::uno::RuntimeException)
+    {
+        return mxMSF->queryInterface( rType );
+    }
+    virtual void SAL_CALL acquire() throw()
+    {
+        mxMSF->acquire();
+    }
+    virtual void SAL_CALL release() throw()
+    {
+        mxMSF->release();
+    }
+#endif /* !LAYOUT_WEAK */
+};
+
+#endif /* _LAYOUT_UNO_HXX */
diff --git a/layout/workben/wordcount-plain.xml b/layout/workben/wordcount-plain.xml
new file mode 100644
index 0000000..cf31a76
--- /dev/null
+++ layout/workben/wordcount-plain.xml
@@ -0,0 +1,29 @@
+
+
+<modaldialog sizeable="true" height="108" help-id="HID_DLG_WORDCOUNT" moveable="true" output-size="true" id="DLG_WORDCOUNT" sv-look="true" text="Word Count" width="170" xmlns="http://openoffice.org/2007/layout" xmlns:cnt="http://openoffice.org/2007/layout/container">
+    <vbox>
+        <fixedline height="8" id="FL_CURRENT" text="Current selection" width="158" x="6" y="3"/>
+        <hbox>
+            <fixedtext height="8" id="FT_CURRENTWORD" label="Words:" width="80" x="12" y="14"/>
+            <fixedtext height="8" id="FI_CURRENTWORD" right="true" width="50" x="111" y="14"/>
+        </hbox>
+        <hbox>
+            <fixedtext height="8" id="FT_CURRENTCHARACTER" label="Characters:" width="80" x="12" y="26"/>
+            <fixedtext height="8" id="FI_CURRENTCHARACTER" right="true" width="50" x="111" y="26"/>
+        </hbox>
+        <fixedline height="8" id="FL_DOC" text="Whole document" width="158" x="6" y="40"/>
+        <hbox>
+            <fixedtext height="8" id="FT_DOCWORD" label="Words:" width="80" x="12" y="51"/>
+            <fixedtext height="8" id="FI_DOCWORD" right="true" width="50" x="111" y="51"/>
+        </hbox>
+        <hbox>
+            <fixedtext height="8" id="FT_DOCCHARACTER" label="Characters:" width="80" x="12" y="63"/>
+            <fixedtext height="8" id="FI_DOCCHARACTER" right="true" width="50" x="111" y="63"/>
+        </hbox>
+        <fixedline height="8" id="FL_BOTTOM" width="158" x="6" y="77"/>
+        <hbox>
+            <okbutton def-button="true" height="14" id="PB_OK" width="50" x="61" y="88"/>
+            <helpbutton height="14" id="PB_HELP" width="50" x="114" y="88"/>
+        </hbox>
+    </vbox>
+</modaldialog>
diff --git a/layout/workben/wordcount-tight.xml b/layout/workben/wordcount-tight.xml
new file mode 100644
index 0000000..9ff84b3
--- /dev/null
+++ layout/workben/wordcount-tight.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<modaldialog xmlns="http://openoffice.org/2007/layout"
+	     xmlns:cnt="http://openoffice.org/2007/layout/container"
+	     help-id="HID_DLG_WORDCOUNT"
+	     id="dialog"
+	     sizeable="true" moveable="true" optimumsize="true"
+	     has_border="true" sv-look="true" title="Word Count">
+    <vbox border="5" spacing="5">
+        <fixedline id="FL_CURRENT" text="Current selection"/>
+        <hbox>
+	    <fixedtext id="FT_CURRENTWORD" label="Words:" cnt:padding="13"/>
+	    <fixedinfo id="FI_CURRENTWORD" right="true" label="0" cnt:padding="13"/>
+        </hbox>
+        <hbox>
+	    <fixedtext id="FT_CURRENTCHARACTER" label="Characters:" cnt:padding="13"/>
+	    <fixedinfo id="FI_CURRENTCHARACTER" right="true" label="00" cnt:padding="13"/>
+        </hbox>
+        <fixedline id="FL_DOC" text="Whole document"/>
+        <hbox>
+	    <fixedtext id="FT_DOCWORD" label="Words:" cnt:padding="13"/>
+	    <fixedinfo id="FI_DOCWORD" right="true" label="000" cnt:padding="13"/>
+        </hbox>
+        <hbox>
+	    <fixedtext id="FT_DOCCHARACTER" label="Characters:" cnt:padding="13"/>
+	    <fixedinfo id="FI_DOCCHARACTER" right="true" label="0000" cnt:padding="13"/>
+        </hbox>
+        <fixedline cnt:padding="1" id="FL_BOTTOM"/>
+        <hbox border="5">
+	    <flow homogeneous="true"/>
+	    <okbutton id="PB_OK" cnt:expand="false" default="true"/>
+	    <helpbutton id="PB_HELP" cnt:expand="false"/>
+        </hbox>
+    </vbox>
+</modaldialog>
diff --git a/layout/workben/wordcount.xml b/layout/workben/wordcount.xml
new file mode 100644
index 0000000..07ad484
--- /dev/null
+++ layout/workben/wordcount.xml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<modaldialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             help-id="HID_DLG_WORDCOUNT"
+             id="dialog"
+             sizeable="true" moveable="true" optimumsize="true"
+             has_border="true" sv-look="true" title="Word Count">
+    <vbox border="5" spacing="5">
+        <fixedline id="FL_CURRENT" text="Current selection"/>
+	<hbox>
+	    <vbox cnt:padding="13" spacing="5">
+		<hbox>
+		    <fixedtext id="FT_CURRENTWORD" label="Words:"/>
+		    <flow cnt:padding="60"/>
+		    <fixedtext id="FI_CURRENTWORD" right="true" label="0"/>
+		</hbox>
+		<hbox>
+		    <fixedtext id="FT_CURRENTCHARACTER" label="Characters:"/>
+		    <flow cnt:padding="60"/>
+		    <fixedtext id="FI_CURRENTCHARACTER" right="true" label="00"/>
+		</hbox>
+	    </vbox>
+	</hbox>
+	<!-- if we could do cnt:cnt:padding="-13" here, we would not have to close
+	     and reope the hbox/vbox thing !-->
+        <fixedline id="FL_DOC" text="Whole document"/>
+	<hbox>
+	    <vbox cnt:padding="13" spacing="5">
+		<hbox>
+		    <fixedtext id="FT_DOCWORD" label="Words:"/>
+		    <fixedtext id="FI_DOCWORD" right="true" label="000"/>
+		</hbox>
+		<hbox>
+		    <fixedtext id="FT_DOCCHARACTER" label="Characters:"/>
+		    <fixedtext id="FI_DOCCHARACTER" right="true" label="0000"/>
+		</hbox>
+	    </vbox>
+	</hbox>
+        <fixedline cnt:padding="1" id="FL_BOTTOM"/>
+	<dialogbuttonhbox spacing="5">
+            <flow/>
+            <okbutton id="PB_OK"/>
+            <helpbutton id="PB_HELP"/>
+        </dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/layout/workben/wordcountdialog.cxx b/layout/workben/wordcountdialog.cxx
new file mode 100644
index 0000000..710b075
--- /dev/null
+++ layout/workben/wordcountdialog.cxx
@@ -0,0 +1,110 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: wordcountdialog.cxx,v $
+ *
+ *  $Revision: 1.8 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/09/27 11:39:08 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#if !TEST_LAYOUT
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sw.hxx"
+#ifdef SW_DLLIMPLEMENTATION
+#undef SW_DLLIMPLEMENTATION
+#endif
+
+#ifndef _SWTYPES_HXX
+#include <swtypes.hxx>
+#endif
+#endif /* !TEST_LAYOUT */
+#ifndef SW_WORDCOUNTDIALOG_HXX
+#include <wordcountdialog.hxx>
+#endif
+#if !TEST_LAYOUT
+#ifndef _DOCSTAT_HXX
+#include <docstat.hxx>
+#endif
+
+#include <dialog.hrc>
+#endif /* !TEST_LAYOUT */
+#include <layout/layout-pre.hxx>
+#if !TEST_LAYOUT
+#include <wordcountdialog.hrc>
+#endif /* !TEST_LAYOUT */
+
+/*-- 06.04.2004 16:05:55---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+SwWordCountDialog::SwWordCountDialog(Window* pParent) :
+    SfxModalDialog(pParent, SW_RES(DLG_WORDCOUNT)),
+#if defined _MSC_VER
+#pragma warning (disable : 4355)
+#endif
+    aCurrentFL( this, SW_RES(              FL_CURRENT            )),
+    aCurrentWordFT( this, SW_RES(          FT_CURRENTWORD        )),
+    aCurrentWordFI( this, SW_RES(          FI_CURRENTWORD        )),
+    aCurrentCharacterFT( this, SW_RES(     FT_CURRENTCHARACTER   )),
+    aCurrentCharacterFI( this, SW_RES(     FI_CURRENTCHARACTER   )),
+
+    aDocFL( this, SW_RES(                  FL_DOC                )),
+    aDocWordFT( this, SW_RES(              FT_DOCWORD            )),
+    aDocWordFI( this, SW_RES(              FI_DOCWORD            )),
+    aDocCharacterFT( this, SW_RES(         FT_DOCCHARACTER       )),
+    aDocCharacterFI( this, SW_RES(         FI_DOCCHARACTER       )),
+    aBottomFL(this, SW_RES(                FL_BOTTOM             )),
+    aOK( this, SW_RES(                     PB_OK                 )),
+    aHelp( this, SW_RES(                   PB_HELP               ))
+#if defined _MSC_VER
+#pragma warning (default : 4355)
+#endif
+{
+    FreeResource();
+}
+/*-- 06.04.2004 16:05:56---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+SwWordCountDialog::~SwWordCountDialog()
+{
+}
+/*-- 06.04.2004 16:05:57---------------------------------------------------
+
+  -----------------------------------------------------------------------*/
+void  SwWordCountDialog::SetValues(const SwDocStat& rCurrent, const SwDocStat& rDoc)
+{
+#if !TEST_LAYOUT
+    aCurrentWordFI.SetText(     String::CreateFromInt32(rCurrent.nWord ));
+    aCurrentCharacterFI.SetText(String::CreateFromInt32(rCurrent.nChar ));
+    aDocWordFI.SetText(         String::CreateFromInt32(rDoc.nWord ));
+    aDocCharacterFI.SetText(    String::CreateFromInt32(rDoc.nChar ));
+#endif /* !TEST_LAYOUT */
+}
+
+
+
diff --git a/layout/workben/wordcountdialog.hxx b/layout/workben/wordcountdialog.hxx
new file mode 100644
index 0000000..1c96157
--- /dev/null
+++ layout/workben/wordcountdialog.hxx
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: wordcountdialog.hxx,v $
+ *
+ *  $Revision: 1.3 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/09 10:18:42 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef SW_WORDCOUNTDIALOG_HXX
+#define SW_WORDCOUNTDIALOG_HXX
+#ifndef _BASEDLGS_HXX 
+#include <sfx2/basedlgs.hxx>
+#endif
+#ifndef _STDCTRL_HXX 
+#include <svtools/stdctrl.hxx>
+#endif
+#ifndef _SV_BUTTON_HXX
+#include <vcl/button.hxx>
+#endif
+#include <layout/layout.hxx>
+#include <layout/layout-pre.hxx>
+struct SwDocStat;
+class SwWordCountDialog : public SfxModalDialog
+{
+    FixedLine       aCurrentFL;
+    FixedText       aCurrentWordFT;
+    FixedInfo       aCurrentWordFI;
+    FixedText       aCurrentCharacterFT;
+    FixedInfo       aCurrentCharacterFI;
+
+    FixedLine       aDocFL;
+    FixedText       aDocWordFT;
+    FixedInfo       aDocWordFI;
+    FixedText       aDocCharacterFT;
+    FixedInfo       aDocCharacterFI;
+
+    FixedLine       aBottomFL;
+
+    OKButton        aOK;
+    HelpButton      aHelp;
+
+public:    
+    SwWordCountDialog(Window* pParent);
+    ~SwWordCountDialog();
+
+    void    SetValues(const SwDocStat& rCurrent, const SwDocStat& rDoc);
+};
+
+#include <layout/layout-post.hxx>
+
+#endif
diff --git a/layout/workben/zoom-indent.xml b/layout/workben/zoom-indent.xml
new file mode 100644
index 0000000..5a6a226
--- /dev/null
+++ layout/workben/zoom-indent.xml
@@ -0,0 +1,41 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<modaldialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             id="dialog" title="Set Zoom" optimumsize="true"
+	     help-id="SID_ATTR_ZOOM"
+             has_border="true" sizeable="true" moveable="true">
+    <hbox border="5" spacing="0">
+        <vbox spacing="0">
+	    <fixedline id="FixedLine" text="Zoom factor" cnt:expand="true"/>
+	    <hbox> <!-- for left margin !-->
+		<vbox cnt:padding="13" spacing="4" cnt:expand="true">
+		    <radiobutton radiogroup="zoom" id="WholePage" label="Whole Page"/>
+		    <radiobutton radiogroup="zoom" id="PageWidth" label="Page Width"/>
+		    <radiobutton radiogroup="zoom" id="Optimal"   label="Optimal"/>
+		    <radiobutton radiogroup="zoom" id="Zoom200"   label="~200 %"/>
+		    <radiobutton radiogroup="zoom" id="Zoom150"   label="15~0 %"/>
+		    <radiobutton radiogroup="zoom" id="Zoom100"   label="~100 %"/>
+		    <radiobutton radiogroup="zoom" id="Zoom75"    label="~75 %"/>
+		    <radiobutton radiogroup="zoom" id="Zoom50"    label="~50 %"/>
+		    <hbox cnt:expand="false">
+			<align cnt:expand="false">
+			    <radiobutton cnt:v-align="0.5" cnt:v-fill="0" radiogroup="zoom" id="BtnUser" label="~Variable"/>
+			</align>
+			<flow cnt:padding="10" cnt:expand="false"/>
+			<metricfield id="User" value-step="1"
+				     repeat="true" has_border="true" spin="true"
+				     text="100%" unit="11" custom-unit-text="%"
+				     right="true"/>
+			<flow cnt:padding="10" cnt:expand="true"/>
+		    </hbox>
+		</vbox>
+	    </hbox>
+	</vbox>
+	<vbox border="6" spacing="4">
+	    <okbutton     id="OkButton"     cnt:expand="false" default="true"/>
+	    <cancelbutton id="CancelButton" cnt:expand="false"/>
+	    <helpbutton   id="HelpButton"   cnt:expand="false"/>
+	</vbox>
+    </hbox>
+</modaldialog>
diff --git a/layout/workben/zoom-plain.xml b/layout/workben/zoom-plain.xml
new file mode 100644
index 0000000..30b72a3
--- /dev/null
+++ layout/workben/zoom-plain.xml
@@ -0,0 +1,20 @@
+
+
+<modaldialog sizeable="true" height="142" help-id="SID_ATTR_ZOOM" moveable="true" output-size="true" id="RID_SVXDLG_ZOOM" sv-look="true" text="Zoom" width="160" xmlns="http://openoffice.org/2007/layout" xmlns:cnt="http://openoffice.org/2007/layout/container">
+    <vbox>
+        <fixedline height="8" id="FL_ZOOM" text="Zoom factor" width="92" x="6" y="3"/>
+        <okbutton def-button="true" height="14" id="BTN_ZOOM_OK" width="50" x="104" y="6"/>
+        <radiobutton height="10" id="BTN_WHOLE_PAGE" width="80" x="12" y="14"/>
+        <cancelbutton height="14" id="BTN_ZOOM_CANCEL" width="50" x="104" y="23"/>
+        <radiobutton height="10" id="BTN_PAGE_WIDTH" width="80" x="12" y="27"/>
+        <radiobutton height="10" id="BTN_OPTIMAL" width="80" x="12" y="40"/>
+        <helpbutton height="14" id="BTN_ZOOM_HELP" width="50" x="104" y="43"/>
+        <radiobutton height="10" id="BTN_200" label="~200 %" width="80" x="12" y="53"/>
+        <radiobutton height="10" id="BTN_150" label="15~0 %" width="80" x="12" y="66"/>
+        <radiobutton height="10" id="BTN_100" label="~100 %" width="80" x="12" y="79"/>
+        <radiobutton height="10" id="BTN_75" label="~75 %" width="80" x="12" y="92"/>
+        <radiobutton height="10" id="BTN_50" label="~50 %" width="80" x="12" y="105"/>
+        <metricfield has_border="true" custom-unit-text="%" group="true" height="12" left="true" repeat="true" id="ED_USER" spin="true" step-size="1" unit="FUNIT_CUSTOM" width="36" x="56" y="120"/>
+        <radiobutton height="10" id="BTN_USER" label="~Variable" width="42" x="12" y="121"/>
+    </vbox>
+</modaldialog>
diff --git a/layout/workben/zoom.cxx b/layout/workben/zoom.cxx
new file mode 100644
index 0000000..9046c28
--- /dev/null
+++ layout/workben/zoom.cxx
@@ -0,0 +1,491 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: zoom.cxx,v $
+ *
+ *  $Revision: 1.9 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 17:52:39 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#if !TEST_LAYOUT
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_svx.hxx"
+#endif /* !TEST_LAYOUT */
+
+#ifdef SVX_DLLIMPLEMENTATION
+#undef SVX_DLLIMPLEMENTATION
+#endif
+
+// include ---------------------------------------------------------------
+
+#if TEST_LAYOUT
+#include <cstdio>
+#endif /* TEST_LAYOUT */
+#ifndef _SHL_HXX
+#include <tools/shl.hxx>
+#endif
+#ifndef _SFXITEMSET_HXX
+#include <svtools/itemset.hxx>
+#endif
+#ifndef _SFXITEMPOOL_HXX
+#include <svtools/itempool.hxx>
+#endif
+#ifndef _SFX_OBJSH_HXX
+#include <sfx2/objsh.hxx>
+#endif
+#ifndef _SV_MSGBOX_HXX //autogen wg. RET_OK, RET_CANCEL
+#include <vcl/msgbox.hxx>
+#endif
+
+#define _SVX_ZOOM_CXX
+
+#include <svx/dialogs.hrc>
+#if !ENABLE_LAYOUT
+#include "zoom.hrc"
+#endif /* !ENABLE_LAYOUT */
+
+#include "zoom.hxx"
+#if TEST_LAYOUT
+#define SVX_ZOOM_OPTIMAL "Zoom optimal"
+#define SVX_ZOOM_PAGEWIDTH "Zoom page width"
+#define SVX_ZOOM_WHOLEPAGE "Zoom whole page"
+struct SvxZoomItem
+{
+    void SetType( char const* s )
+    {
+        fputs( s, stderr );
+    }
+
+    void SetValue( int n )
+    {
+        fprintf( stderr, "Zoom factor: %d\n", int( n ) );
+    }
+};
+#else /* !TEST_LAYOUT */
+#include <svx/zoomitem.hxx>
+#include <svx/dialmgr.hxx>
+#endif /* !TEST_LAYOUT */
+
+#ifndef _SVX_ZOOM_DEF_HXX
+#include "zoom_def.hxx"
+#endif
+
+#include <layout/layout-pre.hxx>
+
+// static ----------------------------------------------------------------
+
+static USHORT pRanges[] =
+{
+	SID_ATTR_ZOOM,
+	SID_ATTR_ZOOM,
+	0
+};
+
+#define SPECIAL_FACTOR	((USHORT)0xFFFF)
+
+// class SvxZoomDialog ---------------------------------------------------
+
+USHORT SvxZoomDialog::GetFactor() const
+{
+	if ( a200Btn.IsChecked() )
+		return 200;
+	if ( a150Btn.IsChecked() )
+		return 150;
+	if ( a100Btn.IsChecked() )
+		return 100;
+	if ( a75Btn.IsChecked() )
+		return 75;
+	if ( a50Btn.IsChecked() )
+		return 50;
+	if ( aUserBtn.IsChecked() )
+		return (USHORT)aUserEdit.GetValue();
+	else
+		return SPECIAL_FACTOR;
+}
+
+// -----------------------------------------------------------------------
+
+void SvxZoomDialog::SetFactor( USHORT nNewFactor, USHORT nBtnId )
+{
+#if TEST_LAYOUT
+    printf ("\t\t set factor %d\n", (int)nNewFactor);
+#endif /* !TEST_LAYOUT */
+	aUserEdit.Disable();
+
+	if ( !nBtnId )
+	{
+		if ( nNewFactor == 200 )
+		{
+			a200Btn.Check();
+			a200Btn.GrabFocus();
+		}
+		else if ( nNewFactor == 150 )
+		{
+			a150Btn.Check();
+			a150Btn.GrabFocus();
+		}
+		else if ( nNewFactor == 100 )
+		{
+			a100Btn.Check();
+			a100Btn.GrabFocus();
+		}
+		else if ( nNewFactor == 75 )
+		{
+			a75Btn.Check();
+			a75Btn.GrabFocus();
+		}
+		else if ( nNewFactor == 50 )
+		{
+			a50Btn.Check();
+			a50Btn.GrabFocus();
+		}
+		else
+		{
+			aUserBtn.Check();
+			aUserEdit.Enable();
+			aUserEdit.SetValue( (long)nNewFactor );
+			aUserEdit.GrabFocus();
+		}
+	}
+	else
+	{
+		aUserEdit.SetValue( (long)nNewFactor );
+
+		if ( ZOOMBTN_OPTIMAL == nBtnId )
+		{
+			aOptimalBtn.Check();
+			aOptimalBtn.GrabFocus();
+		}
+		else if ( ZOOMBTN_PAGEWIDTH == nBtnId )
+		{
+			aPageWidthBtn.Check();
+			aPageWidthBtn.GrabFocus();
+		}
+		else if ( ZOOMBTN_WHOLEPAGE == nBtnId )
+		{
+			aWholePageBtn.Check();
+			aWholePageBtn.GrabFocus();
+		}
+	}
+}
+
+// -----------------------------------------------------------------------
+
+void SvxZoomDialog::SetButtonText( USHORT nBtnId, const String& rNewTxt )
+{
+	switch ( nBtnId )
+	{
+		case ZOOMBTN_OPTIMAL: // Optimal-Button
+			aOptimalBtn.SetText( rNewTxt );
+			break;
+
+		case ZOOMBTN_PAGEWIDTH: // Seitenbreite-Button
+			aPageWidthBtn.SetText( rNewTxt );
+			break;
+
+		case ZOOMBTN_WHOLEPAGE: // Ganze Seite-Button
+			aWholePageBtn.SetText( rNewTxt );
+			break;
+
+		default:
+			DBG_ERROR( "wrong button number" );
+	}
+}
+
+// -----------------------------------------------------------------------
+
+void SvxZoomDialog::HideButton( USHORT nBtnId )
+{
+	switch ( nBtnId )
+	{
+		case ZOOMBTN_OPTIMAL: // Optimal-Button
+			aOptimalBtn.Hide();
+			break;
+
+		case ZOOMBTN_PAGEWIDTH: // Seitenbreite-Button
+			aPageWidthBtn.Hide();
+			break;
+
+		case ZOOMBTN_WHOLEPAGE: // Ganze Seite-Button
+			aWholePageBtn.Hide();
+			break;
+
+		default:
+			DBG_ERROR( "Falsche Button-Nummer!!!" );
+	}
+}
+
+// -----------------------------------------------------------------------
+
+void SvxZoomDialog::SetLimits( USHORT nMin, USHORT nMax )
+{
+	DBG_ASSERT( nMin < nMax, "invalid limits" );
+    aUserEdit.SetMin( nMin );
+	aUserEdit.SetFirst( nMin );
+    aUserEdit.SetMax( nMax );
+	aUserEdit.SetLast( nMax );
+}
+
+// -----------------------------------------------------------------------
+
+void SvxZoomDialog::SetSpinSize( USHORT nNewSpin )
+{
+	aUserEdit.SetSpinSize( nNewSpin );
+}
+
+// -----------------------------------------------------------------------
+
+#if TEST_LAYOUT
+SvxZoomDialog::SvxZoomDialog( Window* pParent ) :
+#else /* !TEST_LAYOUT */
+SvxZoomDialog::SvxZoomDialog( Window* pParent, const SfxItemSet& rCoreSet ) :
+#endif /* !TEST_LAYOUT */
+
+	SfxModalDialog( pParent, SVX_RES( RID_SVXDLG_ZOOM ) ),
+
+    aZoomFl         ( this, SVX_RES( FL_ZOOM ) ),
+    aWholePageBtn   ( this, SVX_RES( BTN_WHOLE_PAGE ) ),
+    aPageWidthBtn   ( this, SVX_RES( BTN_PAGE_WIDTH ) ),
+    aOptimalBtn     ( this, SVX_RES( BTN_OPTIMAL ) ),
+    a200Btn         ( this, SVX_RES( BTN_200 ) ),
+	a150Btn         ( this, SVX_RES( BTN_150 ) ),
+	a100Btn         ( this, SVX_RES( BTN_100 ) ),
+	a75Btn          ( this, SVX_RES( BTN_75 ) ),
+	a50Btn          ( this, SVX_RES( BTN_50 ) ),
+    aUserBtn        ( this, SVX_RES( BTN_USER ) ),
+	aUserEdit       ( this, SVX_RES( ED_USER ) ),
+    aOKBtn          ( this, SVX_RES( BTN_ZOOM_OK ) ),
+	aCancelBtn      ( this, SVX_RES( BTN_ZOOM_CANCEL ) ),
+	aHelpBtn	    ( this, SVX_RES( BTN_ZOOM_HELP ) ),
+
+#if !TEST_LAYOUT
+	rSet		( rCoreSet ),
+#endif /* !TEST_LAYOUT */
+	pOutSet     ( NULL ),
+	bModified	( FALSE )
+
+{
+	Link aLink = LINK( this, SvxZoomDialog, UserHdl );
+	a200Btn.SetClickHdl( aLink );
+	a150Btn.SetClickHdl( aLink );
+	a100Btn.SetClickHdl( aLink );
+	a75Btn.SetClickHdl( aLink );
+	a50Btn.SetClickHdl( aLink );
+	aOptimalBtn.SetClickHdl( aLink );
+	aPageWidthBtn.SetClickHdl( aLink );
+	aWholePageBtn.SetClickHdl( aLink );
+	aUserBtn.SetClickHdl( aLink );
+	aOKBtn.SetClickHdl( LINK( this, SvxZoomDialog, OKHdl ) );
+	aUserEdit.SetModifyHdl( LINK( this, SvxZoomDialog, SpinHdl ) );
+
+	// Default-Werte
+	USHORT nValue = 100;
+	USHORT nMin = 10;
+	USHORT nMax = 1000;
+
+#if !TEST_LAYOUT
+	// ggf. erst den alten Wert besorgen
+	const SfxUInt16Item* pOldUserItem = 0;
+	SfxObjectShell* pSh = SfxObjectShell::Current();
+
+	if ( pSh )
+		pOldUserItem = (const SfxUInt16Item*)pSh->GetItem( SID_ATTR_ZOOM_USER );
+
+	if ( pOldUserItem )
+		nValue = pOldUserItem->GetValue();
+
+	// UserEdit initialisieren
+	if ( nMin > nValue )
+		nMin = nValue;
+	if ( nMax < nValue )
+		nMax = nValue;
+#endif /* !TEST_LAYOUT */
+    aUserEdit.SetMin( nMin );
+	aUserEdit.SetFirst( nMin );
+    aUserEdit.SetMax( nMax );
+	aUserEdit.SetLast( nMax );
+	aUserEdit.SetValue( nValue );
+
+#if TEST_LAYOUT
+    USHORT nZoom = 100;
+    SetFactor( nZoom );
+#else /* !TEST_LAYOUT */
+	const SfxPoolItem& rItem = rSet.Get( rSet.GetPool()->GetWhich( SID_ATTR_ZOOM ) );
+
+	if ( rItem.ISA(SvxZoomItem) )
+	{
+		const SvxZoomItem& rZoomItem = (const SvxZoomItem&)rItem;
+        USHORT nZoom = rZoomItem.GetValue();
+		SvxZoomType eType = rZoomItem.GetType();
+		USHORT nValSet = rZoomItem.GetValueSet();
+		USHORT nBtnId = 0;
+
+		switch ( eType )
+		{
+			case SVX_ZOOM_OPTIMAL:
+				nBtnId = ZOOMBTN_OPTIMAL;
+				break;
+			case SVX_ZOOM_PAGEWIDTH:
+				nBtnId = ZOOMBTN_PAGEWIDTH;
+				break;
+			case SVX_ZOOM_WHOLEPAGE:
+				nBtnId = ZOOMBTN_WHOLEPAGE;
+				break;
+			case SVX_ZOOM_PERCENT:
+				break;
+            case SVX_ZOOM_PAGEWIDTH_NOBORDER:
+                break;
+		}
+
+		// ggf. Buttons disablen
+		if ( !(SVX_ZOOM_ENABLE_50 & nValSet) )
+			a50Btn.Disable();
+		if ( !(SVX_ZOOM_ENABLE_75 & nValSet) )
+			a75Btn.Disable();
+		if ( !(SVX_ZOOM_ENABLE_100 & nValSet) )
+			a100Btn.Disable();
+		if ( !(SVX_ZOOM_ENABLE_150 & nValSet) )
+			a150Btn.Disable();
+		if ( !(SVX_ZOOM_ENABLE_200 & nValSet) )
+			a200Btn.Disable();
+		if ( !(SVX_ZOOM_ENABLE_OPTIMAL & nValSet) )
+			aOptimalBtn.Disable();
+		if ( !(SVX_ZOOM_ENABLE_PAGEWIDTH & nValSet) )
+			aPageWidthBtn.Disable();
+		if ( !(SVX_ZOOM_ENABLE_WHOLEPAGE & nValSet) )
+			aWholePageBtn.Disable();
+        SetFactor( nZoom, nBtnId );
+	}
+	else
+	{
+        USHORT nZoom = ( (const SfxUInt16Item&)rItem ).GetValue();
+        SetFactor( nZoom );
+	}
+#endif /* !TEST_LAYOUT */
+
+	FreeResource();
+}
+
+// -----------------------------------------------------------------------
+
+SvxZoomDialog::~SvxZoomDialog()
+{
+	delete pOutSet;
+	pOutSet = 0;
+}
+
+// -----------------------------------------------------------------------
+
+USHORT* SvxZoomDialog::GetRanges()
+{
+	return pRanges;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxZoomDialog, UserHdl, RadioButton *, pBtn )
+{
+#if TEST_LAYOUT
+    fprintf( stderr, "SvxZoomDialog::UserHdl\n" );
+#endif /* TEST_LAYOUT */
+	bModified |= TRUE;
+
+	if ( pBtn == &aUserBtn )
+	{
+		aUserEdit.Enable();
+		aUserEdit.GrabFocus();
+	}
+	else
+		aUserEdit.Disable();
+	return 0;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxZoomDialog, SpinHdl, MetricField *, EMPTYARG )
+{
+	if ( !aUserBtn.IsChecked() )
+		return 0;
+	bModified |= TRUE;
+	return 0;
+}
+
+// -----------------------------------------------------------------------
+
+IMPL_LINK( SvxZoomDialog, OKHdl, Button *, pBtn )
+{
+	if ( bModified || &aOKBtn != pBtn )
+	{
+#if TEST_LAYOUT
+		SvxZoomItem aItem;
+#else /* !TEST_LAYOUT */
+		SvxZoomItem aItem( SVX_ZOOM_PERCENT, 0,
+						   rSet.GetPool()->GetWhich( SID_ATTR_ZOOM ) );
+
+#endif /* !TEST_LAYOUT */
+		if ( &aOKBtn == pBtn )
+		{
+			USHORT nFactor = GetFactor();
+
+			if ( SPECIAL_FACTOR == nFactor )
+			{
+				if ( aOptimalBtn.IsChecked() )
+					aItem.SetType( SVX_ZOOM_OPTIMAL );
+				else if ( aPageWidthBtn.IsChecked() )
+					aItem.SetType( SVX_ZOOM_PAGEWIDTH );
+				else if ( aWholePageBtn.IsChecked() )
+					aItem.SetType( SVX_ZOOM_WHOLEPAGE );
+			}
+			else
+				aItem.SetValue( nFactor );
+		}
+		else
+		{
+			DBG_ERROR( "Wrong Button" );
+			return 0;
+		}
+#if !TEST_LAYOUT
+		pOutSet = new SfxItemSet( rSet );
+		pOutSet->Put( aItem );
+
+		// Wert aus dem UserEdit "uber den Dialog hinaus merken
+		SfxObjectShell* pSh = SfxObjectShell::Current();
+
+		if ( pSh )
+			pSh->PutItem( SfxUInt16Item( SID_ATTR_ZOOM_USER,
+										 (UINT16)aUserEdit.GetValue() ) );
+#endif /* !TEST_LAYOUT */
+		EndDialog( RET_OK );
+	}
+	else
+		EndDialog( RET_CANCEL );
+	return 0;
+}
+
+
diff --git a/layout/workben/zoom.hxx b/layout/workben/zoom.hxx
new file mode 100644
index 0000000..db630cd
--- /dev/null
+++ layout/workben/zoom.hxx
@@ -0,0 +1,129 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: zoom.hxx,v $
+ *
+ *  $Revision: 1.3 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 22:23:41 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef _SVX_ZOOM_HXX
+#define _SVX_ZOOM_HXX
+
+// include ---------------------------------------------------------------
+
+#include <layout/layout.hxx>
+#ifndef _BASEDLGS_HXX //autogen wg. SfxModalDialog
+#include <sfx2/basedlgs.hxx>
+#endif
+#ifndef _SV_BUTTON_HXX //autogen wg. Radio-/OK-/Cancel-/HelpButton
+#include <vcl/button.hxx>
+#endif
+#ifndef _SV_FIELD_HXX //autogen wg. MetricField
+#include <vcl/field.hxx>
+#endif
+#ifndef _SV_FIXED_HXX
+#include <vcl/fixed.hxx>
+#endif
+
+// define ----------------------------------------------------------------
+/* CHINA001
+#define	ZOOMBTN_OPTIMAL		((USHORT)0x0001)
+#define ZOOMBTN_PAGEWIDTH	((USHORT)0x0002)
+#define ZOOMBTN_WHOLEPAGE	((USHORT)0x0004)
+*/
+#ifndef _SVX_ZOOM_HXX
+#include "zoom_def.hxx"
+#endif
+// class SvxZoomDialog ---------------------------------------------------
+/*
+	{k:\svx\prototyp\dialog\zoom.bmp}
+
+	[Beschreibung]
+	Mit diesem Dialog wird ein Zoom-Faktor eingestellt.
+
+	[Items]
+	SvxZoomItem	<SID_ATTR_ZOOM>
+*/
+
+#include <layout/layout-pre.hxx>
+
+class SvxZoomDialog : public SfxModalDialog
+{
+private:
+    FixedLine           aZoomFl;
+	RadioButton 		aWholePageBtn;
+	RadioButton 		aPageWidthBtn;
+	RadioButton 		aOptimalBtn;
+    RadioButton         a200Btn;
+	RadioButton 		a150Btn;
+	RadioButton 		a100Btn;
+	RadioButton 		a75Btn;
+	RadioButton 		a50Btn;
+    RadioButton         aUserBtn;
+	MetricField 		aUserEdit;
+	OKButton  			aOKBtn;
+	CancelButton		aCancelBtn;
+	HelpButton			aHelpBtn;
+
+#if !TEST_LAYOUT
+	const SfxItemSet&	rSet;
+#endif /* !TEST_LAYOUT */
+	SfxItemSet*			pOutSet;
+	BOOL				bModified;
+
+#ifdef _SVX_ZOOM_CXX
+	DECL_LINK( UserHdl, RadioButton* );
+	DECL_LINK( SpinHdl, MetricField* );
+	DECL_LINK( OKHdl, Button* );
+#endif
+
+public:
+#if TEST_LAYOUT
+	SvxZoomDialog( Window* pParent );
+#else /* !TEST_LAYOUT */
+	SvxZoomDialog( Window* pParent, const SfxItemSet& rCoreSet );
+#endif /* !TEST_LAYOUT */
+	~SvxZoomDialog();
+
+	static USHORT*		GetRanges();
+	const SfxItemSet*	GetOutputItemSet() const { return pOutSet; }
+
+	USHORT				GetFactor() const;
+	void				SetFactor( USHORT nNewFactor, USHORT nBtnId = 0 );
+
+	void				SetButtonText( USHORT nBtnId, const String& aNewTxt );
+	void				HideButton( USHORT nBtnId );
+	void				SetLimits( USHORT nMin, USHORT nMax );
+	void				SetSpinSize( USHORT nNewSpin );
+};
+
+#include <layout/layout-post.hxx>
+
+#endif
+
diff --git a/layout/workben/zoom.xml b/layout/workben/zoom.xml
new file mode 100644
index 0000000..e2c0ead
--- /dev/null
+++ layout/workben/zoom.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<modaldialog xmlns="http://openoffice.org/2007/layout"
+             xmlns:cnt="http://openoffice.org/2007/layout/container"
+             id="dialog" title="Set Zoom" optimumsize="true"
+	     help-id="SID_ATTR_ZOOM"
+             has_border="true" sizeable="true" moveable="true">
+    <vbox spacing="5" border="5">
+	<fixedline id="FL_ZOOM" text="Zoom factor" cnt:expand="true"/>
+	<radiobutton radiogroup="zoom" id="BTN_WHOLE_PAGE" label="Whole Page"/>
+	<radiobutton radiogroup="zoom" id="BTN_PAGE_WIDTH" label="Page Width"/>
+	<radiobutton radiogroup="zoom" id="BTN_OPTIMAL"   label="Optimal"/>
+	<radiobutton radiogroup="zoom" id="BTN_200"   label="~200 %"/>
+	<radiobutton radiogroup="zoom" id="BTN_150"   label="15~0 %"/>
+	<radiobutton radiogroup="zoom" id="BTN_100"   label="~100 %"/>
+	<radiobutton radiogroup="zoom" id="BTN_75"    label="~75 %"/>
+	<radiobutton radiogroup="zoom" id="BTN_50"    label="~50 %"/>
+	<hbox cnt:expand="false" cnt:fill="true">
+	    <align cnt:expand="false" cnt:fill="true">
+		<radiobutton cnt:v-align="0.5" cnt:v-fill="0" radiogroup="zoom" id="BTN_USER" label="~Variable"/>
+	    </align>
+	    <flow cnt:padding="10" cnt:expand="false"/>
+	    <metricfield id="ED_USER" value-step="1"
+			 repeat="true" has_border="true" spin="true"
+			 text="100%" unit="13" custom-unit-text="%"
+			 right="true"
+			 cnt:expand="false"/>
+	</hbox>
+        <fixedline cnt:padding="1" id="FL_BOTTOM"/>
+	<dialogbuttonhbox border="5" spacing="5">
+	    <flow/>
+	    <okbutton     id="BTN_ZOOM_OK"/>
+	    <cancelbutton id="BTN_ZOOM_CANCEL"/>
+	    <helpbutton   id="BTN_ZOOM_HELP"/>
+	</dialogbuttonhbox>
+    </vbox>
+</modaldialog>
diff --git a/layout/workben/zoom_def.hxx b/layout/workben/zoom_def.hxx
new file mode 100644
index 0000000..2d2ce94
--- /dev/null
+++ layout/workben/zoom_def.hxx
@@ -0,0 +1,8 @@
+#ifndef _SVX_ZOOM_DEF_HXX
+#define _SVX_ZOOM_DEF_HXX
+
+#define	ZOOMBTN_OPTIMAL		((USHORT)0x0001)
+#define ZOOMBTN_PAGEWIDTH	((USHORT)0x0002)
+#define ZOOMBTN_WHOLEPAGE	((USHORT)0x0004)
+
+#endif
