Index: mkdepend/cppsetup.c
===================================================================
RCS file: /cvs/tools/soltools/mkdepend/cppsetup.c,v
retrieving revision 1.3
diff -u -p -r1.3 cppsetup.c
--- soltools/mkdepend/cppsetup.c	22 Apr 2004 10:16:31 -0000	1.3
+++ soltools/mkdepend/cppsetup.c	2 Jan 2007 14:40:33 -0000
@@ -95,20 +95,6 @@ cppsetup(line, filep, inc)
 	return(value);
 }
 
-struct symtab *lookup(symbol)
-	char	*symbol;
-{
-	static struct symtab    undefined;
-	struct symtab   *sp;
-
-	sp = isdefined(symbol, currentinc, NULL);
-	if (sp == NULL) {
-		sp = &undefined;
-		sp->s_value = NULL;
-	}
-	return (sp);
-}
-
 pperror(tag, x0,x1,x2,x3,x4)
 	int	tag,x0,x1,x2,x3,x4;
 {
@@ -163,7 +149,7 @@ _my_if_errors (ip, cp, expecting)
 
 #define MAXNAMELEN 256
 
-static struct symtab *
+char *
 _lookup_variable (ip, var, len)
     IfParser *ip;
     const char *var;
@@ -177,7 +163,7 @@ _lookup_variable (ip, var, len)
 
     strncpy (tmpbuf, var, len);
     tmpbuf[len] = '\0';
-    return isdefined (tmpbuf, pd->inc, NULL);
+    return isdefined(tmpbuf);
 }
 
 
@@ -201,13 +187,13 @@ _my_eval_variable (ip, var, len)
     const char *var;
     int len;
 {
-    struct symtab *s;
+    char *s;
 
     s = _lookup_variable (ip, var, len);
     if (!s)
 	return 0;
     do {
-	var = s->s_value;
+	var = s;
 	if (!isvarfirstletter(*var))
 	    break;
 	s = _lookup_variable (ip, var, strlen(var));
@@ -217,7 +203,7 @@ _my_eval_variable (ip, var, len)
 }
 
 
-cppsetup(line, filep, inc)
+int cppsetup(line, filep, inc)
 	register char	*line;
 	register struct filepointer	*filep;
 	register struct inclist		*inc;
Index: mkdepend/def.h
===================================================================
RCS file: /cvs/tools/soltools/mkdepend/def.h,v
retrieving revision 1.4
diff -u -p -r1.4 def.h
--- soltools/mkdepend/def.h	22 Sep 2006 08:56:47 -0000	1.4
+++ soltools/mkdepend/def.h	2 Jan 2007 14:40:33 -0000
@@ -61,7 +65,8 @@ in this Software without prior written a
 #define MAXFILES	2048  /* Increased from 512. -mcafee */
 						  /* Increased from 1024. -mh */
 #define MAXDIRS		64
-#define SYMTABINC	10	/* must be > 1 for define() to work right */
+#define SYMHASHSEED     131  /* 131 1313 13131 ... */
+#define SYMHASHMEMBERS	64	/* must be 2^x to work right */
 #define	TRUE		1
 #define	FALSE		0
 
@@ -108,9 +113,14 @@ extern int	_debugmask;
 
 typedef	unsigned char boolean;
 
-struct symtab {
-	char	*s_name;
-	char	*s_value;
+struct pair {
+	char        *p_name;
+	char        *p_value;
+	struct pair *p_next;
+};
+
+struct symhash {
+	struct pair *s_pairs[SYMHASHMEMBERS];
 };
 
 struct	inclist {
@@ -118,9 +128,6 @@ struct	inclist {
 	char		*i_file;	/* path name of the include file */
 	struct inclist	**i_list;	/* list of files it itself includes */
 	int		i_listlen;	/* length of i_list */
-	struct symtab	*i_defs;	/* symbol table for this file */
-	int		i_ndefs;	/* current # defines */
-	int		i_deflen;	/* amount of space in table */
 	boolean		i_defchecked;	/* whether defines have been checked */
 	boolean		i_notified;	/* whether we have revealed includes */
 	boolean		i_marked;	/* whether it's in the makefile */
@@ -150,13 +157,16 @@ char			*realloc();
 char			*copy();
 char			*base_name();
 char			*getline();
-struct symtab		*slookup();
-struct symtab		*isdefined();
-struct symtab		*fdefined();
+char			*isdefined();
 struct filepointer	*getfile();
 struct inclist		*newinclude();
 struct inclist		*inc_path();
 
+void define( char *def, struct symhash **symbols );
+void hash_define(char *name, char * val, struct symhash **symbols);
+struct symhash *hash_copy( struct symhash *symbols );
+void hash_free( struct symhash *symbols );
+
 #if NeedVarargsPrototypes
 extern fatalerr(char *, ...);
 extern warning(char *, ...);
Index: mkdepend/imakemdep.h
===================================================================
RCS file: /cvs/tools/soltools/mkdepend/imakemdep.h,v
retrieving revision 1.1
diff -u -p -r1.1 imakemdep.h
--- soltools/mkdepend/imakemdep.h	18 Apr 2001 09:10:59 -0000	1.1
+++ soltools/mkdepend/imakemdep.h	2 Jan 2007 14:40:33 -0000
@@ -513,7 +513,7 @@ char *cpp_argv[ARGUMENTS] = {
  *     them to the the following table.  The definition of struct symtab is
  *     in util/makedepend/def.h.
  */
-struct symtab	predefs[] = {
+struct pair	predefs[] = {
 #ifdef apollo
 	{"apollo", "1"},
 #endif
Index: mkdepend/main.c
===================================================================
RCS file: /cvs/tools/soltools/mkdepend/main.c,v
retrieving revision 1.8.6.1
diff -u -p -r1.8.6.1 main.c
--- soltools/mkdepend/main.c	31 Oct 2006 14:55:45 -0000	1.8.6.1
+++ soltools/mkdepend/main.c	2 Jan 2007 14:40:33 -0000
@@ -116,8 +116,9 @@ void freefile(struct filepointer * fp);
 void redirect(char * line, char * makefile );
 
 struct	inclist inclist[ MAXFILES ],
-		*inclistp = inclist,
-		maininclist;
+		*inclistp = inclist;
+
+struct symhash *maininclist = NULL;
 
 char	*filelist[ MAXFILES ];
 char	*includedirs[ MAXDIRS + 1 ];
@@ -171,16 +172,16 @@ int main(argc, argv)
 	register struct inclist	*ip;
 	char	*makefile = NULL;
 	struct filepointer	*filecontent;
-	struct symtab *psymp = predefs;
+	struct pair *psymp = predefs;
 	char *endmarker = NULL;
 	char *defincdir = NULL;
     struct IncludesCollection* incCollection;
 
 	ProgramName = argv[0];
 
-	while (psymp->s_name)
+	while (psymp->p_name)
 	{
-	    define2(psymp->s_name, psymp->s_value, &maininclist);
+	    hash_define(psymp->p_name, psymp->p_value, &maininclist);
 	    psymp++;
 	}
 	if (argc == 2 && argv[1][0] == '@') {
@@ -451,10 +454,14 @@ int main(argc, argv)
     incCollection = create_IncludesCollection();
 	
     for(fp=filelist; *fp; fp++) {
+		struct symhash *includes;
 		filecontent = getfile(*fp);
 		ip = newinclude(*fp, (char *)NULL);
 
-		find_includes(filecontent, ip, ip, 0, FALSE, incCollection);
+		includes = hash_copy( maininclist );
+		find_includes(filecontent, ip, ip, 0, FALSE, incCollection, includes);
+		hash_free( includes );
+		
 		freefile(filecontent);
 		recursive_pr_include(ip, ip->i_file, base_name(*fp));
 		inc_clean();
Index: mkdepend/parse.c
===================================================================
RCS file: /cvs/tools/soltools/mkdepend/parse.c,v
retrieving revision 1.3
diff -u -p -r1.3 parse.c
--- soltools/mkdepend/parse.c	22 Sep 2006 08:57:33 -0000	1.3
+++ soltools/mkdepend/parse.c	2 Jan 2007 14:40:33 -0000
@@ -27,35 +27,35 @@ in this Software without prior written a
 */
 
 #include "def.h"
-void define( char *def, struct inclist *file );
-void define2(char * name, char * val, struct inclist * file);
-void undefine( char	*symbol, register struct inclist *file );
+char *hash_lookup( char *symbol, struct symhash *symbols );
+void hash_undefine( char *symbol, struct symhash *symbols );
 
 extern char	*directives[];
-extern struct inclist	maininclist;
+extern struct symhash *maininclist;
 
-int find_includes(filep, file, file_red, recursion, failOK, incCollection)
+int find_includes(filep, file, file_red, recursion, failOK, incCollection, symbols)
 	struct filepointer	*filep;
 	struct inclist		*file, *file_red;
 	int			recursion;
 	boolean			failOK;
     struct IncludesCollection* incCollection; 
+	struct symhash		*symbols;
 {
 	register char	*line;
 	register int	type;
 	boolean recfailOK;
 
 	while ((line = getline(filep))) {
-		switch(type = deftype(line, filep, file_red, file, TRUE)) {
+		switch(type = deftype(line, filep, file_red, file, TRUE, symbols)) {
 		case IF:
 		doif:
 			type = find_includes(filep, file,
-				file_red, recursion+1, failOK, incCollection);
+				file_red, recursion+1, failOK, incCollection, symbols);
 			while ((type == ELIF) || (type == ELIFFALSE) ||
 			       (type == ELIFGUESSFALSE))
-				type = gobble(filep, file, file_red);
+				type = gobble(filep, file, file_red, symbols);
 			if (type == ELSE)
-				gobble(filep, file, file_red);
+				gobble(filep, file, file_red, symbols);
 			break;
 		case IFFALSE:
 		case IFGUESSFALSE:
@@ -64,10 +64,10 @@ int find_includes(filep, file, file_red,
 			    recfailOK = TRUE;
 			else
 			    recfailOK = failOK;
-			type = gobble(filep, file, file_red);
+			type = gobble(filep, file, file_red, symbols);
 			if (type == ELSE)
 			    find_includes(filep, file,
-					  file_red, recursion+1, recfailOK, incCollection);
+					  file_red, recursion+1, recfailOK, incCollection, symbols);
 			else
 			if (type == ELIF)
 			    goto doif;
@@ -77,28 +77,28 @@ int find_includes(filep, file, file_red,
 			break;
 		case IFDEF:
 		case IFNDEF:
-			if ((type == IFDEF && isdefined(line, file_red, NULL))
-			 || (type == IFNDEF && !isdefined(line, file_red, NULL))) {
+			if ((type == IFDEF && hash_lookup(line, symbols))
+			 || (type == IFNDEF && !hash_lookup(line, symbols))) {
 				debug(1,(type == IFNDEF ?
 				    "line %d: %s !def'd in %s via %s%s\n" : "",
 				    filep->f_line, line,
 				    file->i_file, file_red->i_file, ": doit"));
 				type = find_includes(filep, file,
-					file_red, recursion+1, failOK, incCollection);
+					file_red, recursion+1, failOK, incCollection, symbols);
 				while (type == ELIF || type == ELIFFALSE || type == ELIFGUESSFALSE)
-					type = gobble(filep, file, file_red);
+					type = gobble(filep, file, file_red, symbols);
 				if (type == ELSE)
-					gobble(filep, file, file_red);
+					gobble(filep, file, file_red, symbols);
 			}
 			else {
 				debug(1,(type == IFDEF ?
 				    "line %d: %s !def'd in %s via %s%s\n" : "",
 				    filep->f_line, line,
 				    file->i_file, file_red->i_file, ": gobble"));
-				type = gobble(filep, file, file_red);
+				type = gobble(filep, file, file_red, symbols);
 				if (type == ELSE)
 					find_includes(filep, file,
-						file_red, recursion + 1, failOK, incCollection);
+						file_red, recursion + 1, failOK, incCollection, symbols);
 				else if (type == ELIF)
 				    	goto doif;
 				else if (type == ELIFFALSE || type == ELIFGUESSFALSE)
@@ -110,12 +110,12 @@ int find_includes(filep, file, file_red,
 		case ELIFGUESSFALSE:
 		case ELIF:
 			if (!recursion)
-				gobble(filep, file, file_red);
+				gobble(filep, file, file_red, symbols);
 		case ENDIF:
 			if (recursion)
 				return(type);
 		case DEFINE:
-			define(line, file);
+			define(line, &symbols);
 			break;
 		case UNDEF:
 			if (!*line) {
@@ -123,13 +123,13 @@ int find_includes(filep, file, file_red,
 				file_red->i_file, filep->f_line, line);
 			    break;
 			}
-			undefine(line, file_red);
+			hash_undefine(line, symbols);
 			break;
 		case INCLUDE:
-			add_include(filep, file, file_red, line, FALSE, failOK, incCollection);
+			add_include(filep, file, file_red, line, FALSE, failOK, incCollection, symbols);
 			break;
 		case INCLUDEDOT:
-			add_include(filep, file, file_red, line, TRUE, failOK, incCollection);
+			add_include(filep, file, file_red, line, TRUE, failOK, incCollection, symbols);
 			break;
 		case ERROR:
 		    	warning("%s: %d: %s\n", file_red->i_file,
@@ -160,26 +160,27 @@ int find_includes(filep, file, file_red,
 	return(-1);
 }
 
-int gobble(filep, file, file_red)
+int gobble(filep, file, file_red, symbols)
 	register struct filepointer *filep;
 	struct inclist		*file, *file_red;
+	struct symhash		*symbols;
 {
 	register char	*line;
 	register int	type;
 
 	while ((line = getline(filep))) {
-		switch(type = deftype(line, filep, file_red, file, FALSE)) {
+		switch(type = deftype(line, filep, file_red, file, FALSE, symbols)) {
 		case IF:
 		case IFFALSE:
 		case IFGUESSFALSE:
 		case IFDEF:
 		case IFNDEF:
-			type = gobble(filep, file, file_red);
+			type = gobble(filep, file, file_red, symbols);
 			while ((type == ELIF) || (type == ELIFFALSE) ||
 			       (type == ELIFGUESSFALSE))
-			    type = gobble(filep, file, file_red);
+			    type = gobble(filep, file, file_red, symbols);
 			if (type == ELSE)
-			        (void)gobble(filep, file, file_red);
+			        (void)gobble(filep, file, file_red, symbols);
 			break;
 		case ELSE:
 		case ENDIF:
@@ -213,11 +214,12 @@ int gobble(filep, file, file_red)
 /*
  * Decide what type of # directive this line is.
  */
-int deftype (line, filep, file_red, file, parse_it)
+int deftype (line, filep, file_red, file, parse_it, symbols)
 	register char	*line;
 	register struct filepointer *filep;
 	register struct inclist *file_red, *file;
 	int	parse_it;
+	struct symhash	*symbols;
 {
 	register char	*p;
 	char	*directive, savechar;
@@ -253,7 +255,7 @@ int deftype (line, filep, file_red, file
 	     */
 	    debug(0,("%s, line %d: #elif %s ",
 		   file->i_file, filep->f_line, p));
-	    ret = zero_value(p, filep, file_red);
+	    ret = zero_value(p, filep, file_red, symbols);
 	    if (ret != IF)
 	    {
 		debug(0,("false...\n"));
@@ -282,7 +284,7 @@ int deftype (line, filep, file_red, file
 		/*
 		 * parse an expression.
 		 */
-		ret = zero_value(p, filep, file_red);
+		ret = zero_value(p, filep, file_red, symbols);
 		debug(0,("%s, line %d: %s #if %s\n",
 			 file->i_file, filep->f_line, ret?"false":"true", p));
 		break;
@@ -304,17 +306,17 @@ int deftype (line, filep, file_red, file
 
 		/* Support ANSI macro substitution */
 		{
-		    struct symtab *sym = isdefined(p, file_red, NULL);
-		    while (sym) {
-			p = sym->s_value;
-			debug(3,("%s : #includes SYMBOL %s = %s\n",
-			       file->i_incstring,
-			       sym -> s_name,
-			       sym -> s_value));
-			/* mark file as having included a 'soft include' */
-			file->i_included_sym = TRUE; 
-			sym = isdefined(p, file_red, NULL);
-		    }
+			char *sym = hash_lookup(p, symbols);
+			while (sym)
+			{
+				p = sym;
+				debug(3,("%s : #includes SYMBOL %s\n",
+							file->i_incstring,
+							sym));
+				/* mark file as having included a 'soft include' */
+				file->i_included_sym = TRUE; 
+				sym = hash_lookup(p, symbols);
+			}
 		}
 
 		/*
@@ -357,76 +359,37 @@ int deftype (line, filep, file_red, file
 	return(ret);
 }
 
-struct symtab *isdefined(symbol, file, srcfile)
-	register char	*symbol;
-	struct inclist	*file;
-	struct inclist	**srcfile;
-{
-	register struct symtab	*val;
-
-	val = slookup(symbol, &maininclist);
-	if (val) {
-		debug(1,("%s defined on command line\n", symbol));
-		if (srcfile != NULL) *srcfile = &maininclist;
-		return(val);
-	}
-	val = fdefined(symbol, file, srcfile);
-	if (val)
-		return(val);
-	debug(1,("%s not defined in %s\n", symbol, file->i_file));
-	return(NULL);
-}
-
-struct symtab *fdefined(symbol, file, srcfile)
-	register char	*symbol;
-	struct inclist	*file;
-	struct inclist	**srcfile;
-{
-	register struct inclist	**ip;
-	register struct symtab	*val;
-	register int	i;
-	static int	recurse_lvl = 0;
-
-	if (file->i_defchecked)
-		return(NULL);
-	file->i_defchecked = TRUE;
-	val = slookup(symbol, file);
-	if (val)
-		debug(1,("%s defined in %s as %s\n", symbol, file->i_file, val->s_value));
-	if (val == NULL && file->i_list)
-		{
-		for (ip = file->i_list, i=0; i < file->i_listlen; i++, ip++)
-		  {
-			val = fdefined(symbol, *ip, srcfile);
-			if (val) {
-				break;
-			}
-		  }
-		}
-	else if (val != NULL && srcfile != NULL) *srcfile = file;
-	recurse_lvl--;
-	file->i_defchecked = FALSE;
+/*
+ * HACK! - so that we do not have to introduce 'symbols' in each cppsetup.c
+ * function...  It's safe, functions from cppsetup.c don't return here.
+ */
+struct symhash *global_symbols = NULL;
 
-	return(val);
+char * isdefined( symbol )
+	register char *symbol;
+{
+	return hash_lookup( symbol, global_symbols );
 }
 
 /*
  * Return type based on if the #if expression evaluates to 0
  */
-int zero_value(exp, filep, file_red)
+int zero_value(exp, filep, file_red, symbols)
 	register char	*exp;
 	register struct filepointer *filep;
 	register struct inclist *file_red;
+	register struct symhash *symbols;
 {
+	global_symbols = symbols; /* HACK! see above */
 	if (cppsetup(exp, filep, file_red))
 	    return(IFFALSE);
 	else
 	    return(IF);
 }
 
-void define(def, file)
-	char	*def;
-	struct inclist	*file;
+void define( def, symbols )
+    char	        *def;
+    struct symhash **symbols;
 {
     char *val;
 
@@ -441,137 +404,205 @@ void define(def, file)
 
     if (!*val)
 	val = "1";
-    define2(def, val, file);
+    hash_define( def, val, symbols );
 }
 
-void define2(name, val, file)
-	char	*name, *val;
-	struct inclist	*file;
+static int hash( str )
+    register char *str;
 {
-    int first, last, below;
-    register struct symtab *sp = NULL, *dest;
+    /* Hash (Kernighan and Ritchie) */
+    register unsigned int hashval = 0;
+    register unsigned int i       = 0;
+    char *s = str;
 
-    /* Make space if it's needed */
-    if (file->i_defs == NULL)
+    for ( ; *str; str++ )
     {
-	file->i_defs = (struct symtab *)
-			malloc(sizeof (struct symtab) * SYMTABINC);
-	file->i_deflen = SYMTABINC;
-	file->i_ndefs = 0;
+        hashval = ( hashval * SYMHASHSEED ) + ( *str );
     }
-    else if (file->i_ndefs == file->i_deflen)
-	file->i_defs = (struct symtab *)
-			realloc(file->i_defs,
-			    sizeof(struct symtab)*(file->i_deflen+=SYMTABINC));
-
-    if (file->i_defs == NULL)
-	fatalerr("malloc()/realloc() failure in insert_defn()\n");
-
-    below = first = 0;
-    last = file->i_ndefs - 1;
-    while (last >= first)
+
+    //fprintf( stderr, "hash: %s, %d\n", s, hashval & ( SYMHASHMEMBERS - 1 ) );
+    return hashval & ( SYMHASHMEMBERS - 1 );
+}
+
+struct symhash *hash_copy( symbols )
+    struct symhash *symbols;
+{
+    int i;
+    struct symhash *newsym;
+    if ( !symbols )
+        return NULL;
+
+    newsym = (struct symhash *) malloc( sizeof( struct symhash ) );
+    
+    for ( i = 0; i < SYMHASHMEMBERS; ++i )
     {
-	/* Fast inline binary search */
-	register char *s1;
-	register char *s2;
-	register int middle = (first + last) / 2;
-
-	/* Fast inline strchr() */
-	s1 = name;
-	s2 = file->i_defs[middle].s_name;
-	while (*s1++ == *s2++)
-	    if (s2[-1] == '\0') break;
+        if ( !symbols->s_pairs[ i ] )
+            newsym->s_pairs[ i ] = NULL;
+        else
+        {
+            struct pair *it = symbols->s_pairs[ i ];
+            struct pair *nw = newsym->s_pairs[ i ] = (struct pair*) malloc( sizeof( struct pair ) );
+            nw->p_name = it->p_name;
+            nw->p_value = it->p_value;
+            nw->p_next = NULL;
+            
+            while ( it->p_next )
+            {
+                nw->p_next = (struct pair*) malloc( sizeof( struct pair ) );
+                it = it->p_next;
+                nw = nw->p_next;
+                nw->p_name = it->p_name;
+                nw->p_value = it->p_value;
+                nw->p_next = NULL;
+            }
+        }
+    }
+    return newsym;
+}
 
-	/* If exact match, set sp and break */
-	if (*--s1 == *--s2) 
-	{
-	    sp = file->i_defs + middle;
-	    break;
-	}
+void hash_free( symbols )
+    struct symhash *symbols;
+{
+    int i;
+
+    if ( !symbols )
+        return;
 
-	/* If name > i_defs[middle] ... */
-	if (*s1 > *s2) 
-	{
-	    below = first;
-	    first = middle + 1;
-	}
-	/* else ... */
-	else
-	{
-	    below = last = middle - 1;
-	}
+    for ( i = 0; i < SYMHASHMEMBERS; ++i )
+    {
+        struct pair *it = symbols->s_pairs[ i ];
+        struct pair *next;
+        while ( it )
+        {
+            next = it->p_next;
+            free( it );
+            it = next;
+        }
     }
+    free( symbols->s_pairs );
+}
 
-    /* Search is done.  If we found an exact match to the symbol name,
-       just replace its s_value */
-    if (sp != NULL)
+void hash_define( name, val, symbols )
+    char            *name, *val;
+    struct symhash **symbols;
+{
+    int hashval;
+    struct pair *it;
+
+    if ( !symbols )
+        return;
+
+    /* Make space if it's needed */
+    if ( *symbols == NULL )
     {
-	free(sp->s_value);
-	sp->s_value = copy(val);
-	return;
+        int i;
+
+        *symbols = (struct symhash *) malloc( sizeof( struct symhash ) );
+        if ( *symbols == NULL )
+            fatalerr( "malloc()/realloc() failure in insert_defn()\n" );
+
+        for ( i = 0; i < SYMHASHMEMBERS; ++i )
+            (*symbols)->s_pairs[i] = NULL;
     }
 
-    sp = file->i_defs + file->i_ndefs++;
-    dest = file->i_defs + below + 1;
-    while (sp > dest)
+    hashval = hash( name );
+    it = (*symbols)->s_pairs[ hashval ];
+    
+    /* Replace/insert the symbol */
+    if ( it == NULL )
     {
-	*sp = sp[-1];
-	sp--;
+        it = (*symbols)->s_pairs[ hashval ] = (struct pair*) malloc( sizeof( struct pair ) );
+        it->p_name = copy( name );
+        it->p_value = copy( val );
+        it->p_next = NULL;
+    }
+    else if ( strcmp( it->p_name, name ) == 0 )
+    {
+        it->p_value = copy( val );
+    }
+    else
+    {
+        while ( it->p_next && ( strcmp( it->p_next->p_name, name ) != 0 ) )
+        {
+            it = it->p_next;
+        }
+        if ( it->p_next )
+            it->p_next->p_name = copy( name );
+        else
+        {
+            it->p_next = (struct pair*) malloc( sizeof( struct pair ) );
+            it->p_next->p_name = copy( name );
+            it->p_next->p_value = copy( val );
+            it->p_next->p_next = NULL;
+        }
     }
-    sp->s_name = copy(name);
-    sp->s_value = copy(val);
 }
 
-struct symtab *slookup(symbol, file)
-	register char	*symbol;
-	register struct inclist	*file;
+char *hash_lookup( symbol, symbols )
+    char           *symbol;
+    struct symhash *symbols;
 {
+    struct pair *it;
+
-	register int first = 0;
-	register int last = file->i_ndefs - 1;
-
-	if (file) while (last >= first)
-	{
-	    /* Fast inline binary search */
-	    register char *s1;
-	    register char *s2;
-	    register int middle = (first + last) / 2;
-
-	    /* Fast inline strchr() */
-	    s1 = symbol;
-	    s2 = file->i_defs[middle].s_name;
-	    while (*s1++ == *s2++)
-	        if (s2[-1] == '\0') break;
+    if ( !symbols )
+        return NULL;
+    
+    it = symbols->s_pairs[ hash( symbol ) ];
 
-	    /* If exact match, we're done */
-	    if (*--s1 == *--s2) 
-	    {
-	        return file->i_defs + middle;
-	    }
+    while ( it && ( strcmp( it->p_name, symbol ) != 0 ) )
+    {
+        it = it->p_next;
+    }
+    if ( it )
+        return it->p_value;
 
-	    /* If symbol > i_defs[middle] ... */
-	    if (*s1 > *s2) 
-	    {
-	        first = middle + 1;
-	    }
-	    /* else ... */
-	    else
-	    {
-	        last = middle - 1;
-	    }
-	}
-	return(NULL);
+    return NULL;
 }
 
-void undefine(symbol, file)
-	char	*symbol;
-	register struct inclist	*file;
+void hash_undefine( symbol, symbols )
+    char           *symbol;
+    struct symhash *symbols;
 {
+    int hashval;
+    struct pair *it;
+
-	register struct symtab *ptr;
-	struct inclist *srcfile;
-	while ((ptr = isdefined(symbol, file, &srcfile)) != NULL)
-	{
-	    srcfile->i_ndefs--;
-	    for (; ptr < srcfile->i_defs + srcfile->i_ndefs; ptr++)
-		*ptr = ptr[1];
-	}
+    if ( !symbols )
+        return;
+    
+    hashval = hash( symbol );
+    it = symbols->s_pairs[ hashval ];
+    
+    /* Replace/insert the symbol */
+    if ( it == NULL )
+        return;
+    else if ( strcmp( it->p_name, symbol ) == 0 )
+    {
+        if ( it->p_next )
+        {
+            struct pair *tmp;
+            it->p_name = it->p_next->p_name;
+            it->p_value = it->p_next->p_value;
+            tmp = it->p_next->p_next;
+            free( it->p_next );
+            it->p_next = tmp;
+        }
+        else
+        {
+            free( it );
+            symbols->s_pairs[ hashval ] = NULL;
+        }
+    }
+    else
+    {
+        while ( it->p_next && ( strcmp( it->p_next->p_name, symbol ) != 0 ) )
+        {
+            it = it->p_next;
+        }
+        if ( it->p_next )
+        {
+            struct pair *tmp = it->p_next;
+            it->p_next = it->p_next->p_next;
+            free( tmp );
+        }
+    }
 }
Index: mkdepend/pr.c
===================================================================
RCS file: /cvs/tools/soltools/mkdepend/pr.c,v
retrieving revision 1.3
diff -u -p -r1.3 pr.c
--- soltools/mkdepend/pr.c	22 Sep 2006 08:57:51 -0000	1.3
+++ soltools/mkdepend/pr.c	2 Jan 2007 14:40:33 -0000
@@ -39,12 +39,13 @@ extern boolean	printed;
 extern boolean	verbose;
 extern boolean	show_where_not;
 
-void add_include(filep, file, file_red, include, dot, failOK, incCollection)
+void add_include(filep, file, file_red, include, dot, failOK, incCollection, symbols)
 	struct filepointer	*filep;
 	struct inclist	*file, *file_red;
 	char	*include;
 	boolean	dot;
     struct IncludesCollection* incCollection;
+	struct symhash  *symbols;
 {
 	register struct inclist	*newfile;
 	register struct filepointer	*content;
@@ -77,7 +78,7 @@ void add_include(filep, file, file_red, 
 		if (!newfile->i_searched) {
 			newfile->i_searched = TRUE;
 			content = getfile(newfile->i_file);
-			find_includes(content, newfile, file_red, 0, failOK, incCollection);
+			find_includes(content, newfile, file_red, 0, failOK, incCollection, symbols);
 			freefile(content);
 		}
 	}
