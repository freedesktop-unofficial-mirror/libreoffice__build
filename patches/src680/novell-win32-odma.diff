--- ucb/prj/build.lst	18 Oct 2005 08:45:24 -0000	1.20
+++ ucb/prj/build.lst	13 Mar 2006 10:55:34 -0000
@@ -14,2 +14,3 @@ uc	ucb\source\ucp\package		nmake	-	all	u
 uc	ucb\source\ucp\tdoc			nmake	-	all	uc_tdoc NULL
 uc	ucb\source\ucp\expand		nmake	-	all	uc_expand NULL
+uc	ucb\source\ucp\odma			nmake	-	w	uc_odma NULL
dummy line to avoid confusing diff-mode
--- ucb/prj/d.lst	18 Oct 2005 08:45:24 -0000	1.20
+++ ucb/prj/d.lst	13 Mar 2006 10:55:34 -0000
@@ -23,6 +23,11 @@
 ..\%__SRC%\lib\ucp*.uno.dylib %_DEST%\lib%_EXT%\ucp*.uno.dylib
 ..\%__SRC%\misc\ucp*.map %_DEST%\bin%_EXT%\ucp*.map
 ..\%__SRC%\misc\ucp*.sym %_DEST%\bin%_EXT%\ucp*.sym
+
+..\%__SRC%\slb\odma_lib.lib %_DEST%\lib%_EXT%\odma_lib.lib
+..\source\ucp\odma\odma.h %_DEST%\inc%_EXT%\odma.h
+..\source\ucp\odma\odma_lib.hxx %_DEST%\inc%_EXT%\odma_lib.hxx
+
 ..\source\ucp\file\ucpfile.xml %_DEST%\xml%_EXT%\ucpfile.xml
 ..\source\ucp\ftp\ucpftp.xml %_DEST%\xml%_EXT%\ucpftp.xml
 ..\source\ucp\hierarchy\ucphier.xml %_DEST%\xml%_EXT%\ucphier.xml
Index: ucb/source/ucp/odma/makefile.mk
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/makefile.mk,v
retrieving revision 1.4
diff -p -u -r1.4 makefile.mk
--- ucb/source/ucp/odma/makefile.mk	9 Sep 2005 15:49:57 -0000	1.4
+++ ucb/source/ucp/odma/makefile.mk	6 Nov 2006 00:12:08 -0000
@@ -63,8 +63,7 @@ LIB2TARGET=NO
 
 # --- General -----------------------------------------------------
 
-# @@@ Adjust template file names. Add own files here.
-SLOFILES=\
+SLO1FILES=\
 	$(SLO)$/odma_lib.obj    		\
 	$(SLO)$/odma_services.obj    	\
 	$(SLO)$/odma_provider.obj    	\
@@ -76,7 +75,7 @@ SLOFILES=\
 
 
 LIB1TARGET=$(SLB)$/_$(TARGET).lib
-LIB1OBJFILES=$(SLOFILES)
+LIB1OBJFILES=$(SLO1FILES)
 
 # --- Shared-Library ---------------------------------------------------
 
@@ -122,6 +121,13 @@ APP2STDLIBS+=$(LIBCIMT)
 # @@@ A description string for you UCP.
 DEF2DES=UCB ODMA URL converter
 
+# --- odma_lib library -----------------------------------------------
+
+SLO3FILES=$(SLO)$/odma_lib.obj
+
+LIB3TARGET=$(SLB)$/odma_lib.lib
+LIB3OBJFILES=$(SLO3FILES)
+
 # --- Targets ----------------------------------------------------------
 
 .INCLUDE: target.mk
Index: ucb/source/ucp/odma/odma.h
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma.h,v
retrieving revision 1.4
diff -p -u -r1.4 odma.h
--- ucb/source/ucp/odma/odma.h	25 Aug 2003 13:00:04 -0000	1.4
+++ ucb/source/ucp/odma/odma.h	6 Nov 2006 00:12:08 -0000
@@ -1 +1,315 @@
-#error	"odma.h: This file is not included in OpenOffice.org (yet). Please download the latest version at http://www.infonuovo.com/odma/downloads"
+/* odma.h - Definitions, prototypes, etc. for Open Document Managment API
+	(ODMA) version 2.0.
+
+	COPYRIGHT (C) 1994, 1995
+	AIIM International
+	All Right Reserved
+*/
+
+#ifndef ODMA_H
+#define ODMA_H
+
+/* Type definitions */
+typedef LPVOID ODMHANDLE;
+typedef LPSTR (*ODMSAVEASCALLBACK)(DWORD dwEnvData, LPSTR lpszFormat, LPVOID pInstanceData);
+typedef int ODMSTATUS;
+
+/* Constants */
+#define ODM_API_VERSION			200		/* Version of the API */
+
+#ifdef WIN32
+	#define ODM_DOCID_MAX		255		/* Win32 */
+
+#elif defined( _WINDOWS_ ) || defined( _MSDOS )
+	#define ODM_DOCID_MAX		80		/* Windows 3.x */
+
+#else
+	#define ODM_DOCID_MAX		255		/* Other platforms */
+#endif
+
+#define ODM_DMSID_MAX			9		/* Max length of a DMS ID including the 
+										/* terminating NULL character.  */
+
+#define ODM_APPID_MAX			16		/* Max length of a application ID including
+										/* the terminating NULL character.  */
+
+// ODMA 2.0
+#define ODM_QUERYID_MAX			255		// Max length of a query ID including
+													// the terminating NULL character.
+
+#define ODM_FORMAT_MAX			81 // Max length of a format including
+													// the terminating NULL character.
+
+// Maximum length of a filename returned by ODMA including the terminating
+//	NULL character.  Platform dependent.
+
+#ifdef WIN32
+	#define ODM_FILENAME_MAX	255		/* Win32 */
+
+#elif defined( _WINDOWS_ ) || defined( _MSDOS )
+	#define ODM_FILENAME_MAX	128		/* Windows 3.x */
+
+#elif defined( unix ) || defined( _UNIX )
+	#define ODM_FILENAME_MAX	1024	/* Unix */
+
+#else
+	#define ODM_FILENAME_MAX	255		/* Other platforms */
+#endif
+
+
+/* Common format type names */
+#define ODM_FORMAT_TEXT	"Text"
+#define ODM_FORMAT_RTF	"Rich text format"
+#define ODM_FORMAT_DCA	"DCA RFT"		/* IBM DCA Rich Format Text */
+#define ODM_FORMAT_TIFF	"Tiff"
+#define ODM_FORMAT_GIF	"Gif"				/* Compuserve Graphics Interchange Format */
+#define ODM_FORMAT_BMP	"Windows bitmap"
+#define ODM_FORMAT_PCX	"PCX"
+#define ODM_FORMAT_CGM	"CGM"				/* Computer Graphics Metafile */
+#define ODM_FORMAT_EXE	"Executable file"
+#define ODM_FORMAT_PCL	"PCL"				/* HP Printer Control Language */
+#define ODM_FORMAT_PS	"PostScript"
+
+
+/* Error returns */
+#define ODM_SUCCESS			0		// Success!
+#define ODM_E_FAIL			1		/* Unspecified failure */
+#define ODM_E_CANCEL		2		/* Action was cancelled at user's request */
+#define ODM_E_NODMS			3		/* DMS not registered */
+#define ODM_E_CANTINIT		4		/* DMS failed to initalize */
+#define ODM_E_VERSION		5		/* DMS doesn't support the requested 
+									           version of ODMA */
+#define ODM_E_APPSELECT		6        /* User has indicated that he wants to use 
+                                       the application's file selection 
+                                       capabilities rather than those of the 
+                                       DMS. */
+#define ODM_E_USERINT		7        /* Requested action cannot be performed 
+                                       without user interaction, but silent 
+                                       mode was specified. */
+#define ODM_E_HANDLE		8        /* The DMHANDLE argument was invalid. */
+#define ODM_E_ACCESS		9        /* User does not have requested access 
+                                       rights to specified document. */
+#define ODM_E_INUSE			10        /* Document is currently in use and cannot 
+                                       be accessed in specified mode. */
+#define ODM_E_DOCID			11        /* Invalid document ID */
+#define ODM_E_OPENMODE		12        /* The specified action is incompatible 
+                                       with the mode in which the document was
+                                       opened. */
+#define ODM_E_NOOPEN		13        /* The specified document is not open. */
+#define ODM_E_ITEM			14        /* Invalid item specifier. */
+#define ODM_E_OTHERAPP		15        /* Selected document was for another app. */
+#define ODM_E_NOMOREDATA	16		/* No more data is available */
+#define ODM_E_PARTIALSUCCESS 17		/* */
+// Additional Error code from ODMA 2.0
+#define ODM_E_REQARG		18		/* */
+#define ODM_E_NOSUPPORT		19		/* */
+#define ODM_E_TRUNCATED		20		/* */
+#define ODM_E_INVARG  21
+#define ODM_E_OFFLINE  22		/* */
+
+
+// ODMOpenDoc modes
+#define ODM_MODIFYMODE		1        /* Open document in a modifiable mode. */
+#define ODM_VIEWMODE		2        /* Open document in non-modifiable mode. */
+// ODMA 2.0
+#define ODM_REFCOPY			3
+
+
+// Actions for ODMActivate
+#define ODM_NONE			0        /* No specific action is requested.  */
+#define ODM_DELETE			1        /* Delete the specified document.  */
+#define ODM_SHOWATTRIBUTES	2        /* Display the specified document's profile 
+                                       or attributes. */
+#define ODM_EDITATTRIBUTES	3        /* Edit the specified document's profile or
+                                       attributes. */
+#define ODM_VIEWDOC			4        /* Display the specified document in a 
+                                       viewer window. */
+#define ODM_OPENDOC			5        /* Open the specified document in its 
+                                       native application.  */
+// ODMA 2.0
+#define ODM_NEWDOC			6
+#define ODM_CHECKOUT		7
+#define ODM_CANCELCHECKOUT	8
+#define ODM_CHECKIN			9
+#define ODM_SHOWHISTORY		10
+
+
+// Item selectors for ODMGetDocInfo and ODMSetDocInfo
+#define ODM_AUTHOR			1        /* Author of the document. */
+#define ODM_NAME			2        /* Descriptive name of the document.  */
+#define ODM_TYPE			3        /* Type of the document.  */
+#define ODM_TITLETEXT		4        /* Suggested text to display in the 
+                                       document window's title bar. */
+#define ODM_DMS_DEFINED		5        /* DMS defined data. */
+#define ODM_CONTENTFORMAT	6        /* String describing document's format */
+// ODMA 2.0
+#define ODM_ALTERNATE_RENDERINGS	7
+#define ODM_CHECKEDOUTBY	8
+#define ODM_CHECKOUTCOMMENT	9
+#define ODM_CHECKOUTDATE	10
+#define ODM_CREATEDBY		11
+#define ODM_CREATEDDATE		12
+#define ODM_DOCID_LATEST	13
+#define ODM_DOCID_RELEASED	14
+#define ODM_DOCVERSION		15
+#define ODM_DOCVERSION_LATEST	16
+#define ODM_DOCVERSION_RELEASED	17
+#define ODM_LOCATION		18
+#define ODM_KEYWORDS		19
+#define ODM_LASTCHECKINBY	20
+#define ODM_LASTCHECKINDATE	21
+#define ODM_MODIFYDATE		22
+#define ODM_MODIFYDATE_LATEST	23
+#define ODM_MODIFYDATE_RELEASED	24
+#define ODM_OWNER			25
+#define ODM_SUBJECT			26
+#define ODM_TITLETEXT_RO	27
+#define ODM_URL				28
+
+
+// Item selectors for ODMQueryCapability ODMA 2.0
+#define ODM_QC_ACTIVATE				1
+#define ODM_QC_CLOSEDOC				2
+#define ODM_QC_CLOSEDOCEX			3
+#define ODM_QC_GETALTERNATECONTENT	4
+#define ODM_QC_GETDMSINFO			5
+#define ODM_QC_GETDOCINFO			6
+#define ODM_QC_GETDOCRELATION		7
+#define ODM_QC_GETLEADMONIKER		8
+#define ODM_QC_NEWDOC				9
+#define ODM_QC_OPENDOC				10
+#define ODM_QC_QUERYCLOSE			11
+#define ODM_QC_QUERYEXECUTE			12
+#define ODM_QC_QUERYGETRESULTS		13
+#define ODM_QC_SAVEAS				14
+#define ODM_QC_SAVEASEX				15
+#define ODM_QC_SAVEDOC				16
+#define ODM_QC_SAVEDOCEX			17
+#define ODM_QC_SELECTDOC			18
+#define ODM_QC_SELECTDOCEX			19
+#define ODM_QC_SETALTERNATECONTENT	20
+#define ODM_QC_SETDOCEVENT			21
+#define ODM_QC_SETDOCRELATION		22
+#define ODM_QC_SETDOCINFO			23
+
+
+// Misc. modes, flags
+#define ODM_SILENT			16        /* Don't interact with the user while
+                                       fulfilling this request. */
+//ODMA 2.0
+#define ODM_VERSION_SAME	1 
+#define ODM_VERSION_MAJOR	2
+#define ODM_VERSION_MINOR	4
+#define ODM_VERSION_CHANGED	8 
+#define ODM_ALT_DELETE		32
+
+//ODMA 2.0 DMS Info Flags 
+#define ODM_EXT_QUERY		1	
+#define ODM_EXT_WORKFLOW 	2	
+
+// Flags for Query Interface
+#define ODM_ALL				1		// All DMS's should be searched
+#define ODM_SPECIFIC		2		// Only specific DMS's should be searched
+
+
+// Function prototypes
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ODMSTATUS WINAPI ODMRegisterApp(ODMHANDLE FAR *pOdmHandle, WORD version,
+	LPSTR lpszAppId, DWORD dwEnvData, LPVOID pReserved);
+
+void WINAPI ODMUnRegisterApp(ODMHANDLE odmHandle);
+
+ODMSTATUS WINAPI ODMSelectDoc(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	LPDWORD pdwFlags);
+
+ODMSTATUS WINAPI ODMOpenDoc(ODMHANDLE odmHandle, DWORD flags,
+	LPSTR lpszDocId, LPSTR lpszDocLocation);
+
+ODMSTATUS WINAPI ODMSaveDoc(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	LPSTR lpszNewDocId);
+
+ODMSTATUS WINAPI ODMCloseDoc(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	DWORD activeTime, DWORD pagesPrinted, LPVOID sessionData, WORD dataLen);
+
+ODMSTATUS WINAPI ODMNewDoc(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	DWORD dwFlags, LPSTR lpszFormat, LPSTR lpszDocLocation);
+
+ODMSTATUS WINAPI ODMSaveAs(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	LPSTR lpszNewDocId, LPSTR lpszFormat, ODMSAVEASCALLBACK pcbCallBack,
+	LPVOID pInstanceData);
+
+ODMSTATUS WINAPI ODMActivate(ODMHANDLE odmHandle, WORD action,
+	LPSTR lpszDocId);
+
+ODMSTATUS WINAPI ODMGetDocInfo(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	WORD item, LPSTR lpszData, WORD dataLen);
+
+ODMSTATUS WINAPI ODMSetDocInfo(ODMHANDLE odmHandle, LPSTR lpszDocId,
+	WORD item, LPSTR lpszData);
+
+ODMSTATUS WINAPI ODMGetDMSInfo(ODMHANDLE odmHandle, LPSTR lpszDmsId,
+	LPWORD pwVerNo, LPDWORD pdwExtensions);
+
+/* Query Enhancements */
+WORD WINAPI ODMGetDMSCount();
+
+WORD WINAPI ODMGetDMSList( LPSTR buffer, WORD buffer_size );
+
+ODMSTATUS WINAPI ODMGetDMS( LPCSTR lpszAppId, LPSTR lpszDMSId );
+
+ODMSTATUS WINAPI ODMSetDMS( LPCSTR lpszAppId, LPCSTR lpszDMSId );
+
+ODMSTATUS WINAPI ODMQueryExecute(ODMHANDLE odmHandle, LPCSTR lpszQuery,
+								 DWORD flags, LPCSTR lpszDMSList, LPSTR queryId );
+
+ODMSTATUS WINAPI ODMQueryGetResults(ODMHANDLE odmHandle, LPCSTR queryId,
+									LPSTR lpszDocId, LPSTR lpszDocName, WORD docNameLen,
+									WORD *docCount );
+
+ODMSTATUS WINAPI ODMQueryClose(ODMHANDLE odmHandle, LPCSTR queryId );
+
+/* ODMA 2.0 Enhancements */
+ODMSTATUS WINAPI ODMCloseDocEx(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPDWORD pdwFlags, DWORD activeTime, DWORD pagesPrinted,
+							LPVOID sessionData, WORD dataLen);
+
+ODMSTATUS WINAPI ODMSaveAsEx(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPSTR lpszNewDocId, LPSTR lpszFormat, ODMSAVEASCALLBACK pcbCallBack,
+							LPVOID pInstanceData, LPDWORD pdwFlags);
+
+ODMSTATUS WINAPI ODMSaveDocEx(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPSTR lpszNewDocId,	LPDWORD pdwFlags);
+
+ODMSTATUS WINAPI ODMSelectDocEx(ODMHANDLE odmHandle, LPSTR lpszDocIds,
+							LPWORD pwDocIdsLen, LPWORD pwDocCount, LPDWORD pdwFlags,
+							LPSTR lpszFormatFilter);
+
+ODMSTATUS WINAPI ODMQueryCapability(ODMHANDLE odmHandle, LPCSTR lpszDmsId,
+							DWORD function, DWORD item, DWORD flags);
+
+ODMSTATUS WINAPI ODMSetDocEvent(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							DWORD flags, DWORD event, LPVOID lpData, DWORD dwDataLen,
+							LPSTR lpszComment);
+
+ODMSTATUS WINAPI ODMGetAlternateContent(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPDWORD pdwFlags, LPSTR lpszFormat, LPSTR lpszDocLocation);
+
+ODMSTATUS WINAPI ODMSetAlternateContent(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPDWORD pdwFlags, LPSTR lpszFormat, LPSTR lpszDocLocation);
+
+ODMSTATUS WINAPI ODMGetDocRelation(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPDWORD pdwFlags, LPSTR lpszLinkedId, LPSTR lpszFormat,
+							LPSTR lpszPreviousId);
+
+ODMSTATUS WINAPI ODMSetDocRelation(ODMHANDLE odmHandle, LPSTR lpszDocId,
+							LPDWORD pdwFlags, LPSTR lpszLinkedId, LPSTR lpszFormat,
+							LPSTR lpszPreviousId);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: ucb/source/ucp/odma/odma_content.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_content.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_content.cxx
--- ucb/source/ucp/odma/odma_content.cxx	17 Sep 2006 13:57:15 -0000	1.5
+++ ucb/source/ucp/odma/odma_content.cxx	6 Nov 2006 00:12:08 -0000
@@ -126,21 +126,24 @@
 #ifndef ODMA_INPUTSTREAM_HXX
 #include "odma_inputstream.hxx"
 #endif
-#ifndef _UCBHELPER_CONTENT_HXX 
-#include <ucbhelper/content.hxx>
-#endif
 #ifndef _COM_SUN_STAR_UNO_EXCEPTION_HPP_
 #include <com/sun/star/uno/Exception.hpp>
 #endif
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
-#ifndef _OSL_FILE_HXX_ 
+#ifndef _OSL_FILE_HXX_
 #include <osl/file.hxx>
 #endif
 
-using namespace com::sun;
-using namespace com::sun::star;
+using namespace com::sun::star::beans;
+using namespace com::sun::star::container;
+using namespace com::sun::star::io;
+using namespace com::sun::star::lang;
+using namespace com::sun::star::sdbc;
+using namespace com::sun::star::ucb;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::util;
 using namespace odma;
 
 //=========================================================================
@@ -151,16 +154,16 @@ using namespace odma;
 //=========================================================================
 //=========================================================================
 
-Content::Content( const uno::Reference< lang::XMultiServiceFactory >& rxSMgr,
+Content::Content( const Reference< XMultiServiceFactory >& rxSMgr,
                   ContentProvider* pProvider,
-                  const uno::Reference< star::ucb::XContentIdentifier >& Identifier,
-				  const ::vos::ORef<ContentProperties>& _rProps)
+                  const Reference< XContentIdentifier >& Identifier,
+				  const ::vos::ORef< ContentProperties >& _rProps)
 	: ContentImplHelper( rxSMgr, pProvider, Identifier )
-	,m_aProps(_rProps)
-	,m_pProvider(pProvider)
-	,m_pContent(NULL)
+	, m_aProps( _rProps )
+	, m_pProvider( pProvider )
+	, m_pContent( NULL )
 {
-	OSL_ENSURE(m_aProps.isValid(),"No valid ContentPropeties!");
+	OSL_ENSURE( m_aProps.isValid(), "No valid ContentPropeties!" );
 }
 
 //=========================================================================
@@ -177,24 +180,26 @@ Content::~Content()
 //=========================================================================
 
 // virtual
-void SAL_CALL Content::acquire() throw()
+void SAL_CALL Content::acquire()
+	throw ()
 {
 	ContentImplHelper::acquire();
 }
 
 //=========================================================================
 // virtual
-void SAL_CALL Content::release() throw()
+void SAL_CALL Content::release()
+	throw()
 {
 	ContentImplHelper::release();
 }
 
 //=========================================================================
 // virtual
-uno::Any SAL_CALL Content::queryInterface( const uno::Type & rType )
-    throw ( uno::RuntimeException )
+Any SAL_CALL Content::queryInterface( const Type & rType )
+    throw ( RuntimeException )
 {
-    uno::Any aRet;
+    Any aRet;
 
 	// @@@ Add support for additional interfaces.
 #if 0
@@ -215,8 +220,8 @@ XTYPEPROVIDER_COMMON_IMPL( Content );
 
 //=========================================================================
 // virtual
-uno::Sequence< uno::Type > SAL_CALL Content::getTypes()
-    throw( uno::RuntimeException )
+Sequence< Type > SAL_CALL Content::getTypes()
+    throw ( RuntimeException )
 {
 	// @@@ Add own interfaces.
 
@@ -228,16 +233,16 @@ uno::Sequence< uno::Type > SAL_CALL Cont
 	  	if ( !pCollection )
 	  	{
             static cppu::OTypeCollection aCollection(
-                CPPU_TYPE_REF( lang::XTypeProvider ),
-                CPPU_TYPE_REF( lang::XServiceInfo ),
-                CPPU_TYPE_REF( lang::XComponent ),
-                CPPU_TYPE_REF( star::ucb::XContent ),
-                CPPU_TYPE_REF( star::ucb::XCommandProcessor ),
-                CPPU_TYPE_REF( beans::XPropertiesChangeNotifier ),
-                CPPU_TYPE_REF( star::ucb::XCommandInfoChangeNotifier ),
-                CPPU_TYPE_REF( beans::XPropertyContainer ),
-                CPPU_TYPE_REF( beans::XPropertySetInfoChangeNotifier ),
-                CPPU_TYPE_REF( container::XChild ) );
+                CPPU_TYPE_REF( XTypeProvider ),
+                CPPU_TYPE_REF( XServiceInfo ),
+                CPPU_TYPE_REF( XComponent ),
+                CPPU_TYPE_REF( XContent ),
+                CPPU_TYPE_REF( XCommandProcessor ),
+                CPPU_TYPE_REF( XPropertiesChangeNotifier ),
+                CPPU_TYPE_REF( XCommandInfoChangeNotifier ),
+                CPPU_TYPE_REF( XPropertyContainer ),
+                CPPU_TYPE_REF( XPropertySetInfoChangeNotifier ),
+                CPPU_TYPE_REF( XChild ) );
 	  		pCollection = &aCollection;
 		}
 	}
@@ -253,7 +258,7 @@ uno::Sequence< uno::Type > SAL_CALL Cont
 
 // virtual
 rtl::OUString SAL_CALL Content::getImplementationName()
-    throw( uno::RuntimeException )
+    throw ( RuntimeException )
 {
     // @@@ Adjust implementation name. Keep the prefix "com.sun.star.comp."!
     return rtl::OUString::createFromAscii( "com.sun.star.comp.odma.Content" );
@@ -261,11 +266,11 @@ rtl::OUString SAL_CALL Content::getImple
 
 //=========================================================================
 // virtual
-uno::Sequence< rtl::OUString > SAL_CALL Content::getSupportedServiceNames()
-    throw( uno::RuntimeException )
+Sequence< rtl::OUString > SAL_CALL Content::getSupportedServiceNames()
+    throw ( RuntimeException )
 {
 	// @@@ Adjust macro name.
-    uno::Sequence< rtl::OUString > aSNS( 1 );
+    Sequence< rtl::OUString > aSNS( 1 );
 	aSNS.getArray()[ 0 ]
             = rtl::OUString::createFromAscii( ODMA_CONTENT_SERVICE_NAME );
 	return aSNS;
@@ -279,7 +284,7 @@ uno::Sequence< rtl::OUString > SAL_CALL 
 
 // virtual
 rtl::OUString SAL_CALL Content::getContentType()
-    throw( uno::RuntimeException )
+    throw ( RuntimeException )
 {
 	// @@@ Adjust macro name ( def in odma_provider.hxx ).
     return rtl::OUString::createFromAscii( ODMA_CONTENT_TYPE );
@@ -292,54 +297,43 @@ rtl::OUString SAL_CALL Content::getConte
 //=========================================================================
 
 // virtual
-uno::Any SAL_CALL Content::execute(
-        const star::ucb::Command& aCommand,
-        sal_Int32 CommandId,
-        const uno::Reference< star::ucb::XCommandEnvironment >& Environment )
-    throw( uno::Exception,
-           star::ucb::CommandAbortedException,
-           uno::RuntimeException )
+Any SAL_CALL Content::execute( const Command& aCommand,
+							   sal_Int32 /* CommandId */,
+							   const Reference< XCommandEnvironment >& Environment )
+    throw ( Exception,
+			CommandAbortedException,
+			RuntimeException )
 {
-    uno::Any aRet;
+    Any aRet;
 
-    if ( aCommand.Name.equalsAsciiL(
-			RTL_CONSTASCII_STRINGPARAM( "getPropertyValues" ) ) )
+    if ( aCommand.Name.equalsAscii( "getPropertyValues" ) )
 	{
-		//////////////////////////////////////////////////////////////////
-		// getPropertyValues
-		//////////////////////////////////////////////////////////////////
-
-        uno::Sequence< beans::Property > Properties;
+        Sequence< Property > Properties;
 		if ( !( aCommand.Argument >>= Properties ) )
 		{
             OSL_ENSURE( sal_False, "Wrong argument type!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
 		}
 
         aRet <<= getPropertyValues( Properties, Environment );
 	}
-    else if ( aCommand.Name.equalsAsciiL(
-				RTL_CONSTASCII_STRINGPARAM( "setPropertyValues" ) ) )
+    else if ( aCommand.Name.equalsAscii( "setPropertyValues" ) )
     {
-		//////////////////////////////////////////////////////////////////
-		// setPropertyValues
-		//////////////////////////////////////////////////////////////////
-
-        uno::Sequence< beans::PropertyValue > aProperties;
+        Sequence< PropertyValue > aProperties;
 		if ( !( aCommand.Argument >>= aProperties ) )
 		{
             OSL_ENSURE( sal_False, "Wrong argument type!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
         }
@@ -348,66 +342,52 @@ uno::Any SAL_CALL Content::execute(
 		{
             OSL_ENSURE( sal_False, "No properties!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
         }
 
         aRet <<= setPropertyValues( aProperties, Environment );
 	}
-    else if ( aCommand.Name.equalsAsciiL(
-				RTL_CONSTASCII_STRINGPARAM( "getPropertySetInfo" ) ) )
+    else if ( aCommand.Name.equalsAscii( "getPropertySetInfo" ) )
     {
-		//////////////////////////////////////////////////////////////////
-		// getPropertySetInfo
-		//////////////////////////////////////////////////////////////////
-
 		// Note: Implemented by base class.
 		aRet <<= getPropertySetInfo( Environment );
 	}
-    else if ( aCommand.Name.equalsAsciiL(
-				RTL_CONSTASCII_STRINGPARAM( "getCommandInfo" ) ) )
+    else if ( aCommand.Name.equalsAscii( "getCommandInfo" ) )
     {
-		//////////////////////////////////////////////////////////////////
-		// getCommandInfo
-		//////////////////////////////////////////////////////////////////
-
 		// Note: Implemented by base class.
 		aRet <<= getCommandInfo( Environment );
 	}
-    else if ( aCommand.Name.equalsAsciiL(
-				RTL_CONSTASCII_STRINGPARAM( "open" ) ) )
+    else if ( aCommand.Name.equalsAscii( "open" ) )
     {
-        star::ucb::OpenCommandArgument2 aOpenCommand;
+        OpenCommandArgument2 aOpenCommand;
       	if ( !( aCommand.Argument >>= aOpenCommand ) )
 		{
             OSL_ENSURE( sal_False, "Wrong argument type!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
         }
 
         sal_Bool bOpenFolder =
-            ( ( aOpenCommand.Mode == star::ucb::OpenMode::ALL ) ||
-              ( aOpenCommand.Mode == star::ucb::OpenMode::FOLDERS ) ||
-              ( aOpenCommand.Mode == star::ucb::OpenMode::DOCUMENTS ) );
+            ( ( aOpenCommand.Mode == OpenMode::ALL ) ||
+              ( aOpenCommand.Mode == OpenMode::FOLDERS ) ||
+              ( aOpenCommand.Mode == OpenMode::DOCUMENTS ) );
 
         if ( bOpenFolder)
 		{
             // open as folder - return result set
 
-            uno::Reference< star::ucb::XDynamicResultSet > xSet
-                            = new DynamicResultSet( m_xSMgr,
-													this,
-													aOpenCommand,
-													Environment );
+            Reference< XDynamicResultSet > xSet
+				= new DynamicResultSet( m_xSMgr, this, aOpenCommand, Environment );
     		aRet <<= xSet;
   		}
 
@@ -416,17 +396,15 @@ uno::Any SAL_CALL Content::execute(
             // Open document - supply document data stream.
 
             // Check open mode
-            if ( ( aOpenCommand.Mode
-                    == star::ucb::OpenMode::DOCUMENT_SHARE_DENY_NONE ) ||
-                 ( aOpenCommand.Mode
-                    == star::ucb::OpenMode::DOCUMENT_SHARE_DENY_WRITE ) )
+            if ( aOpenCommand.Mode == OpenMode::DOCUMENT_SHARE_DENY_NONE ||
+                 aOpenCommand.Mode == OpenMode::DOCUMENT_SHARE_DENY_WRITE )
             {
                 // Unsupported.
                 ucbhelper::cancelCommandExecution(
-                    uno::makeAny( star::ucb::UnsupportedOpenModeException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    sal_Int16( aOpenCommand.Mode ) ) ),
+                    makeAny( UnsupportedOpenModeException(
+								 rtl::OUString(),
+								 static_cast< cppu::OWeakObject * >( this ),
+								 sal_Int16( aOpenCommand.Mode ) ) ),
                     Environment );
                 // Unreachable
             }
@@ -435,41 +413,38 @@ uno::Any SAL_CALL Content::execute(
             rtl::OUString aURL = m_xIdentifier->getContentIdentifier();
 			rtl::OUString sFileURL = openDoc();
 			delete m_pContent;
-			m_pContent = new ::ucb::Content(sFileURL,NULL);
-			if(!m_pContent->isDocument())
+			m_pContent = new ::ucb::Content( sFileURL, NULL );
+			if ( ! m_pContent->isDocument() )
 			{
-				rtl::OUString sErrorMsg(RTL_CONSTASCII_USTRINGPARAM("File: "));
+				rtl::OUString sErrorMsg( RTL_CONSTASCII_USTRINGPARAM( "File: " ));
 				sErrorMsg += sFileURL;
-				sErrorMsg += rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(" could not be found."));
+				sErrorMsg += rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( " could not be found." ));
 				ucbhelper::cancelCommandExecution(
-						uno::makeAny( io::IOException(
-										sErrorMsg,
-										static_cast< cppu::OWeakObject * >( this )) ),
-						Environment );
+					makeAny( IOException(
+								 sErrorMsg,
+								 static_cast< cppu::OWeakObject * >( this )) ),
+					Environment );
+				// Unreachable
 			}
 
-            uno::Reference< io::XOutputStream > xOut
-                = uno::Reference< io::XOutputStream >(
-                    aOpenCommand.Sink, uno::UNO_QUERY );
+            Reference< XOutputStream > xOut( aOpenCommand.Sink, UNO_QUERY );
     		if ( xOut.is() )
       		{
 				// @@@ PUSH: write data into xOut
-				m_pContent->openStream(xOut);
+				m_pContent->openStream( xOut );
       		}
     		else
       		{
-                uno::Reference< io::XActiveDataSink > xDataSink
-                    = uno::Reference< io::XActiveDataSink >(
-                        aOpenCommand.Sink, uno::UNO_QUERY );
+                Reference< XActiveDataSink > xDataSink( aOpenCommand.Sink, UNO_QUERY );
       			if ( xDataSink.is() )
 				{
 	  				// @@@ PULL: wait for client read
-					uno::Reference< io::XInputStream > xIn;
+					Reference< XInputStream > xIn;
 					try
 					{
 						xIn = m_pContent->openStream();
 					}
-					catch(uno::Exception&)
+					catch( Exception& )
 					{
 						OSL_ENSURE(0,"Exception occured while creating the file content!");
 					}
@@ -477,10 +452,10 @@ uno::Any SAL_CALL Content::execute(
 				}
       			else
 				{
-					uno::Reference< io::XActiveDataStreamer > activeDataStreamer( aOpenCommand.Sink,uno::UNO_QUERY );
-					if(activeDataStreamer.is())
+					Reference< XActiveDataStreamer > activeDataStreamer( aOpenCommand.Sink, UNO_QUERY );
+					if ( activeDataStreamer.is() )
 					{
-						activeDataStreamer->setStream(new OOdmaStream(m_pContent,getContentProvider(),m_aProps));
+						activeDataStreamer->setStream( new OOdmaStream( m_pContent,getContentProvider(), m_aProps ) );
 						m_pContent = NULL; // don't delete here because the stream is now the owner
 					}
 					else
@@ -489,10 +464,10 @@ uno::Any SAL_CALL Content::execute(
 						//       implementation. Support for this type of
 						//       sink is optional...
 						ucbhelper::cancelCommandExecution(
-							uno::makeAny( com::sun::star::ucb::UnsupportedDataSinkException(
-									rtl::OUString(),
-									static_cast< cppu::OWeakObject * >( this ),
-									aOpenCommand.Sink ) ),
+							makeAny( UnsupportedDataSinkException(
+										 rtl::OUString(),
+										 static_cast< cppu::OWeakObject * >( this ),
+										 aOpenCommand.Sink ) ),
 							Environment );
 						// Unreachable
 					}
@@ -500,173 +475,120 @@ uno::Any SAL_CALL Content::execute(
 	  		}
 		}
 	}
-	else if ( aCommand.Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "close" ) ) )
+	else if ( aCommand.Name.equalsAscii( "close" ) )
     {
-		getContentProvider()->closeDocument(m_aProps->m_sDocumentId);
+		getContentProvider()->closeDocument( m_aProps->m_sDocumentId );
 	}
-	else if ( aCommand.Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "delete" ) ) )
+	else if ( aCommand.Name.equalsAscii( "delete" ) )
     {
-		//////////////////////////////////////////////////////////////////
-		// delete
-		//////////////////////////////////////////////////////////////////
-
 		// Remove own and all children's Additional Core Properties.
 		removeAdditionalPropertySet( sal_True );
 		// Remove own and all childrens(!) persistent data.
-		if(!getContentProvider()->deleteDocument(m_aProps))
+		if ( ! getContentProvider()->deleteDocument( m_aProps ) )
 			ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
+		// Unreachable
 	}
-    else if ( aCommand.Name.equalsAsciiL(
-				RTL_CONSTASCII_STRINGPARAM( "insert" ) ) )
+    else if ( aCommand.Name.equalsAscii( "insert" ) )
     {
-		//////////////////////////////////////////////////////////////////
-		// insert
-		//////////////////////////////////////////////////////////////////
-
-        star::ucb::InsertCommandArgument arg;
+        InsertCommandArgument arg;
       	if ( !( aCommand.Argument >>= arg ) )
 		{
 	  		OSL_ENSURE( sal_False, "Wrong argument type!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
 		}
 
       	insert( arg.Data, arg.ReplaceExisting, Environment );
     }
-	else if( ! aCommand.Name.compareToAscii( "transfer" ) )
+	else if ( aCommand.Name.equalsAscii( "transfer" ) )
 	{
-		com::sun::star::ucb::TransferInfo aTransferInfo;
-		if( ! ( aCommand.Argument >>= aTransferInfo ) )
+		// So far I have determined that this command is called when
+		// doing "Save As" to copy an already written backup copy of
+		// the document in the file system into the DMS.
+
+		// Maybe also in other situations.
+
+		TransferInfo aTransferInfo;
+		if ( ! ( aCommand.Argument >>= aTransferInfo ) )
 		{
 			OSL_ENSURE( sal_False, "Wrong argument type!" );
             ucbhelper::cancelCommandExecution(
-                uno::makeAny( lang::IllegalArgumentException(
-                                    rtl::OUString(),
-                                    static_cast< cppu::OWeakObject * >( this ),
-                                    -1 ) ),
+                makeAny( IllegalArgumentException(
+							 rtl::OUString(),
+							 static_cast< cppu::OWeakObject * >( this ),
+							 -1 ) ),
                 Environment );
             // Unreachable
 		}
+
 		::vos::ORef<ContentProperties> aProp = m_aProps;
-		if(aProp->m_bIsFolder)
+		if ( aProp->m_bIsFolder )
 		{
-			aProp = getContentProvider()->getContentPropertyWithTitle(aTransferInfo.NewTitle);
-			if(!aProp.isValid())
-				aProp = getContentProvider()->getContentPropertyWithSavedAsName(aTransferInfo.NewTitle);
+			aProp = getContentProvider()->getContentPropertyWithDocumentId( aTransferInfo.NewTitle );
+			if ( ! aProp.isValid() )
+				aProp = getContentProvider()->getContentPropertyWithSavedAsName( aTransferInfo.NewTitle );
 			sal_Bool bError = !aProp.isValid();
-			if(bError)
-			{
-				sal_Char* pExtension = NULL;
-				::rtl::OString sExt;
-				sal_Int32 nPos = aTransferInfo.NewTitle.lastIndexOf('.');
-				if(nPos != -1)
-				{
-					sExt = ::rtl::OUStringToOString(aTransferInfo.NewTitle.copy(nPos+1),RTL_TEXTENCODING_ASCII_US);
-					if(sExt.equalsIgnoreAsciiCase("txt"))
-						pExtension = ODM_FORMAT_TEXT;
-					else if(sExt.equalsIgnoreAsciiCase("rtf"))
-						pExtension = ODM_FORMAT_RTF;
-					else if(sExt.equalsIgnoreAsciiCase("ps"))
-						pExtension = ODM_FORMAT_PS;
-					else  
-						pExtension = const_cast<sal_Char*>(sExt.getStr());
-				}
-				else
-					pExtension = ODM_FORMAT_TEXT;
 
-				sal_Char* lpszNewDocId = new sal_Char[ODM_DOCID_MAX];
-				void *pData = NULL;
-				DWORD dwFlags = ODM_SILENT;
-				ODMSTATUS odm = NODMSaveAsEx(ContentProvider::getHandle(),
-											 NULL, // means it is saved the first time
-											 lpszNewDocId,
-											 pExtension,
-											 NULL, // no callback function here
-											 pData,
-											 &dwFlags);
-
-				// check if we have to call the DMS dialog
-				if(odm == ODM_E_USERINT) 
-				{ 
-					dwFlags = 0;
-					odm = NODMSaveAsEx(ContentProvider::getHandle(),
-											 NULL, // means it is saved the first time
-											 lpszNewDocId,
-											 pExtension,
-											 NULL, // no callback function here
-											 pData,
-											 &dwFlags);
-				}
-				bError = odm != ODM_SUCCESS;
-				if(!bError)
-				{
-					aProp = new ContentProperties();
-					aProp->m_sDocumentId	= ::rtl::OString(lpszNewDocId);
-					aProp->m_sContentType	= ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
-					aProp->m_sSavedAsName	= aTransferInfo.NewTitle;
-					getContentProvider()->append(aProp);
-
-					// now set the title
-					WORD nDocInfo = ODM_NAME;
-					::rtl::OUString sFileName = aTransferInfo.NewTitle;
-					sal_Int32 nIndex = aTransferInfo.NewTitle.lastIndexOf( sal_Unicode('.') );
-					if(nIndex != -1)
-						sFileName = aTransferInfo.NewTitle.copy(0,nIndex);
-
-					::rtl::OString sDocInfoValue = ::rtl::OUStringToOString(sFileName,RTL_TEXTENCODING_ASCII_US);
-					odm = NODMSetDocInfo(	ContentProvider::getHandle(),
-											lpszNewDocId,
-											nDocInfo,
-											const_cast<sal_Char*>(sDocInfoValue.getStr())
-											);
-
-				}
-				else if ( odm == ODM_E_CANCEL)
-					ODMSTATUS odm = NODMActivate(ContentProvider::getHandle(),
-												 ODM_DELETE,
-												 lpszNewDocId);
+			// There used to be code below that called ODMSaveAsEx,
+			// but that was very broken. We have already called
+			// ODMSaveAsEx in the ODMA file picker when selecting the
+			// name for a new document, or the document already exists
+			// in the DMS and we don't need any ODMSaveAsEx. The ODMA
+			// file picker tells odma::ContentProvider about the new
+			// document's DOCID, so the
+			// getContentPropertyWithDocumentId() call above should
+			// succeed.
 
-				delete lpszNewDocId;
-			}
-			if(bError)
+			if ( bError )
+			{
 				ucbhelper::cancelCommandExecution(
-						uno::makeAny( lang::IllegalArgumentException(
-											rtl::OUString(),
-											static_cast< cppu::OWeakObject * >( this ),
-											-1 ) ),
-						Environment );
+					makeAny( IllegalArgumentException(
+								 rtl::OUString(),
+								 static_cast< cppu::OWeakObject * >( this ),
+								 -1 ) ),
+					Environment );
+				// Unreachable
+			}
 		}
-		rtl::OUString sFileURL = ContentProvider::openDoc(aProp);
+		rtl::OUString sFileURL = ContentProvider::openDoc( aProp );
 
 		sal_Int32 nLastIndex = sFileURL.lastIndexOf( sal_Unicode('/') );
-		::ucb::Content aContent(sFileURL.copy(0,nLastIndex),NULL);
-		//	aTransferInfo.NameClash = com::sun::star::ucb::NameClash::OVERWRITE;
+
+		// Create a new Content object for the "shadow" file
+		// corresponding to the opened document from the DMS.
+		::ucb::Content aContent( sFileURL.copy( 0, nLastIndex), NULL );
 		aTransferInfo.NewTitle = sFileURL.copy( 1 + nLastIndex );
-		aContent.executeCommand(::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("transfer")),uno::makeAny(aTransferInfo));
-		getContentProvider()->saveDocument(aProp->m_sDocumentId);
+
+		// Copy our saved backup copy to the "shadow" file.
+		aContent.executeCommand(::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "transfer" ) ), makeAny( aTransferInfo ) );
+
+		// Tell the DMS that the "shadow" file is done and can be
+		// imported.
+		getContentProvider()->saveDocument( aProp->m_sDocumentId );
+    }
+	else if ( aCommand.Name.equalsAscii( "getCasePreservingURL" ) )
+	{
+        rtl::OUString CasePreservingURL = openDoc();
+		aRet <<= CasePreservingURL;
 	}
 	else
 	{
-		//////////////////////////////////////////////////////////////////
-		// Unsupported command
-		//////////////////////////////////////////////////////////////////
-
         OSL_ENSURE( sal_False, "Content::execute - unsupported command!" );
 
         ucbhelper::cancelCommandExecution(
-            uno::makeAny( star::ucb::UnsupportedCommandException(
-                            rtl::OUString(),
-                            static_cast< cppu::OWeakObject * >( this ) ) ),
+            makeAny( UnsupportedCommandException(
+						 rtl::OUString(),
+						 static_cast< cppu::OWeakObject * >( this ) ) ),
             Environment );
         // Unreachable
     }
@@ -676,8 +598,8 @@ uno::Any SAL_CALL Content::execute(
 
 //=========================================================================
 // virtual
-void SAL_CALL Content::abort( sal_Int32 CommandId )
-    throw( uno::RuntimeException )
+void SAL_CALL Content::abort( sal_Int32 /* CommandId */ )
+    throw ( RuntimeException )
 {
 	// @@@ Implement logic to abort running commands, if this makes
 	//     sense for your content.
@@ -695,9 +617,9 @@ void SAL_CALL Content::abort( sal_Int32 
     ::rtl::OUString sURL = m_xIdentifier->getContentIdentifier();
 
     // @@@ Extract URL of parent from aURL and return it...
-	static ::rtl::OUString sScheme1(RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT "/"));
-	static ::rtl::OUString sScheme2(RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT));
-	if(sURL == sScheme1 || sURL == sScheme2)
+	static ::rtl::OUString sScheme1( RTL_CONSTASCII_USTRINGPARAM( ODMA_URL_SCHEME ODMA_URL_SHORT "/" ) );
+	static ::rtl::OUString sScheme2( RTL_CONSTASCII_USTRINGPARAM( ODMA_URL_SCHEME ODMA_URL_SHORT ) );
+	if ( sURL == sScheme1 || sURL == sScheme2 )
 		sURL = ::rtl::OUString();
 	else
 		sURL = sScheme1;
@@ -707,11 +629,11 @@ void SAL_CALL Content::abort( sal_Int32 
 
 //=========================================================================
 // static
-uno::Reference< sdbc::XRow > Content::getPropertyValues(
-            const uno::Reference< lang::XMultiServiceFactory >& rSMgr,
-            const uno::Sequence< beans::Property >& rProperties,
-            const ::vos::ORef<ContentProperties>& rData,
-            const vos::ORef< ::ucb::ContentProviderImplHelper >& rProvider,
+Reference< XRow > Content::getPropertyValues(
+            const Reference< XMultiServiceFactory >& rSMgr,
+            const Sequence< Property >& rProperties,
+            const ::vos::ORef< ContentProperties>& rData,
+            const vos::ORef< ucb::ContentProviderImplHelper >& rProvider,
             const rtl::OUString& rContentId )
 {
 	// Note: Empty sequence means "get values of all supported properties".
@@ -722,65 +644,55 @@ uno::Reference< sdbc::XRow > Content::ge
 	sal_Int32 nCount = rProperties.getLength();
 	if ( nCount )
 	{
-        uno::Reference< beans::XPropertySet > xAdditionalPropSet;
+        Reference< XPropertySet > xAdditionalPropSet;
 		sal_Bool bTriedToGetAdditonalPropSet = sal_False;
 
-        const beans::Property* pProps = rProperties.getConstArray();
+        const Property* pProps = rProperties.getConstArray();
 		for ( sal_Int32 n = 0; n < nCount; ++n )
 		{
-            const beans::Property& rProp = pProps[ n ];
+            const Property& rProp = pProps[ n ];
 
 			// Process Core properties.
 
-            if ( rProp.Name.equalsAsciiL(
-					RTL_CONSTASCII_STRINGPARAM( "ContentType" ) ) )
+            if ( rProp.Name.equalsAscii( "ContentType" ) )
             {
-				xRow->appendString ( rProp, rData->m_sContentType );
+				xRow->appendString( rProp, rData->m_sContentType );
 			}
-            else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "Title" ) ) )
+            else if ( rProp.Name.equalsAscii( "Title" ) )
 			{
-				xRow->appendString ( rProp, rData->m_sTitle );
+				xRow->appendString( rProp, rData->m_sTitle );
 			}
-            else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "IsDocument" ) ) )
+            else if ( rProp.Name.equalsAscii( "IsDocument" ) )
 			{
 				xRow->appendBoolean( rProp, rData->m_bIsDocument );
 			}
-            else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "IsFolder" ) ) )
+            else if ( rProp.Name.equalsAscii( "IsFolder" ) )
 			{
 				xRow->appendBoolean( rProp, rData->m_bIsFolder );
 			}
-            else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "DateCreated" ) ) )
+            else if ( rProp.Name.equalsAscii( "DateCreated" ) )
 			{
 				xRow->appendTimestamp( rProp, rData->m_aDateCreated );
 			}
-			else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "DateModified" ) ) )
+			else if ( rProp.Name.equalsAscii( "DateModified" ) )
 			{
 				xRow->appendTimestamp( rProp, rData->m_aDateModified );
 			}
-			else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "IsReadOnly" ) ) )
+			else if ( rProp.Name.equalsAscii( "IsReadOnly" ) )
 			{
 				xRow->appendBoolean( rProp, rData->m_bIsReadOnly );
 			}
-			else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "Author" ) ) )
+			else if ( rProp.Name.equalsAscii( "Author" ) )
 			{
-				xRow->appendString ( rProp, rData->m_sAuthor );
+				xRow->appendString( rProp, rData->m_sAuthor );
 			}
-			else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "Subject" ) ) )
+			else if ( rProp.Name.equalsAscii( "Subject" ) )
 			{
-				xRow->appendString ( rProp, rData->m_sSubject );
+				xRow->appendString( rProp, rData->m_sSubject );
 			}
-			else if ( rProp.Name.equalsAsciiL(
-                    RTL_CONSTASCII_STRINGPARAM( "Keywords" ) ) )
+			else if ( rProp.Name.equalsAscii( "Keywords" ) )
 			{
-				xRow->appendString ( rProp, rData->m_sKeywords );
+				xRow->appendString( rProp, rData->m_sKeywords );
 			}
 			else
 			{
@@ -795,19 +707,18 @@ uno::Reference< sdbc::XRow > Content::ge
 
 				if ( !bTriedToGetAdditonalPropSet && !xAdditionalPropSet.is() )
 				{
-					xAdditionalPropSet
-                        = uno::Reference< beans::XPropertySet >(
-							rProvider->getAdditionalPropertySet( rContentId,
-																 sal_False ),
-                            uno::UNO_QUERY );
+					xAdditionalPropSet = Reference< XPropertySet >(
+						rProvider->getAdditionalPropertySet( rContentId,
+															 sal_False ),
+						UNO_QUERY );
 					bTriedToGetAdditonalPropSet = sal_True;
 				}
 
 				if ( xAdditionalPropSet.is() )
 				{
 					if ( !xRow->appendPropertySetValue(
-												xAdditionalPropSet,
-												rProp ) )
+							 xAdditionalPropSet,
+							 rProp ) )
 					{
 						// Append empty entry.
 						xRow->appendVoid( rProp );
@@ -824,73 +735,67 @@ uno::Reference< sdbc::XRow > Content::ge
 	else
 	{
 		// Append all Core Properties.
-		xRow->appendString (
-            beans::Property( rtl::OUString::createFromAscii( "ContentType" ),
+		xRow->appendString(
+            Property( rtl::OUString::createFromAscii( "ContentType" ),
 					  -1,
                       getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_sContentType );
-		xRow->appendString (
-            beans::Property( rtl::OUString::createFromAscii( "Title" ),
+		xRow->appendString(
+            Property( rtl::OUString::createFromAscii( "Title" ),
 					  -1,
                       getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND ),
+                      PropertyAttribute::BOUND ),
 			rData->m_sTitle );
 		xRow->appendBoolean(
-            beans::Property( rtl::OUString::createFromAscii( "IsDocument" ),
+            Property( rtl::OUString::createFromAscii( "IsDocument" ),
 					  -1,
 					  getCppuBooleanType(),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_bIsDocument );
 		xRow->appendBoolean(
-            beans::Property( rtl::OUString::createFromAscii( "IsFolder" ),
+            Property( rtl::OUString::createFromAscii( "IsFolder" ),
 					  -1,
 					  getCppuBooleanType(),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_bIsFolder );
 
 		// @@@ Append other properties supported directly.
 		xRow->appendTimestamp(
-            beans::Property( rtl::OUString::createFromAscii( "DateCreated" ),
+            Property( rtl::OUString::createFromAscii( "DateCreated" ),
 					  -1,
-					  getCppuType(static_cast< const com::sun::star::util::DateTime * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+					  getCppuType( static_cast< const DateTime * >( 0 ) ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_aDateCreated );
 		xRow->appendTimestamp(
-            beans::Property( rtl::OUString::createFromAscii( "DateModified" ),
+            Property( rtl::OUString::createFromAscii( "DateModified" ),
 					  -1,
-					  getCppuType(static_cast< const com::sun::star::util::DateTime * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+					  getCppuType( static_cast< const DateTime * >( 0 ) ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_aDateModified );
 		xRow->appendBoolean(
-            beans::Property( rtl::OUString::createFromAscii( "IsReadOnly" ),
+            Property( rtl::OUString::createFromAscii( "IsReadOnly" ),
 					  -1,
 					  getCppuBooleanType(),
-                      beans::PropertyAttribute::BOUND
-                        | beans::PropertyAttribute::READONLY ),
+                      PropertyAttribute::BOUND | PropertyAttribute::READONLY ),
 			rData->m_bIsReadOnly );
-		xRow->appendString (
-            beans::Property( rtl::OUString::createFromAscii( "Author" ),
+		xRow->appendString(
+            Property( rtl::OUString::createFromAscii( "Author" ),
 					  -1,
                       getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND ),
+                      PropertyAttribute::BOUND ),
 			rData->m_sAuthor );
-		xRow->appendString (
-            beans::Property( rtl::OUString::createFromAscii( "Subject" ),
+		xRow->appendString(
+            Property( rtl::OUString::createFromAscii( "Subject" ),
 					  -1,
                       getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND ),
+                      PropertyAttribute::BOUND ),
 			rData->m_sSubject );
-		xRow->appendString (
-            beans::Property( rtl::OUString::createFromAscii( "Keywords" ),
+		xRow->appendString(
+            Property( rtl::OUString::createFromAscii( "Keywords" ),
 					  -1,
                       getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
-                      beans::PropertyAttribute::BOUND ),
+                      PropertyAttribute::BOUND ),
 			rData->m_sKeywords );
 
 		// @@@ Note: If your data source supports adding/removing
@@ -902,19 +807,19 @@ uno::Reference< sdbc::XRow > Content::ge
 
 		// Append all Additional Core Properties.
 
-        uno::Reference< beans::XPropertySet > xSet(
+        Reference< XPropertySet > xSet(
 			rProvider->getAdditionalPropertySet( rContentId, sal_False ),
-            uno::UNO_QUERY );
+            UNO_QUERY );
 		xRow->appendPropertySet( xSet );
 	}
 
-    return uno::Reference< sdbc::XRow >( xRow.get() );
+    return Reference< XRow >( xRow.get() );
 }
 
 //=========================================================================
-uno::Reference< sdbc::XRow > Content::getPropertyValues(
-            const uno::Sequence< beans::Property >& rProperties,
-            const uno::Reference< star::ucb::XCommandEnvironment >& xEnv )
+Reference< XRow > Content::getPropertyValues(
+            const Sequence< Property >& rProperties,
+            const Reference< XCommandEnvironment >& /* xEnv */ )
 {
 	osl::Guard< osl::Mutex > aGuard( m_aMutex );
 	return getPropertyValues( m_xSMgr,
@@ -927,17 +832,17 @@ uno::Reference< sdbc::XRow > Content::ge
 }
 
 //=========================================================================
-uno::Sequence< uno::Any > Content::setPropertyValues(
-            const uno::Sequence< beans::PropertyValue >& rValues,
-            const uno::Reference< star::ucb::XCommandEnvironment >& xEnv )
+Sequence< Any > Content::setPropertyValues(
+            const Sequence< PropertyValue >& rValues,
+            const Reference< XCommandEnvironment >& /* xEnv */ )
 {
 	osl::ClearableGuard< osl::Mutex > aGuard( m_aMutex );
 
-    uno::Sequence< uno::Any > aRet( rValues.getLength() );
-    uno::Sequence< beans::PropertyChangeEvent > aChanges( rValues.getLength() );
+    Sequence< Any > aRet( rValues.getLength() );
+    Sequence< PropertyChangeEvent > aChanges( rValues.getLength() );
 	sal_Int32 nChanged = 0;
 
-    beans::PropertyChangeEvent aEvent;
+    PropertyChangeEvent aEvent;
     aEvent.Source         = static_cast< cppu::OWeakObject * >( this );
 	aEvent.Further 		  = sal_False;
 //	aEvent.PropertyName	  =
@@ -945,44 +850,43 @@ uno::Sequence< uno::Any > Content::setPr
 //	aEvent.OldValue		  =
 //	aEvent.NewValue       =
 
-    const beans::PropertyValue* pValues = rValues.getConstArray();
+    const PropertyValue* pValues = rValues.getConstArray();
 	sal_Int32 nCount = rValues.getLength();
 
-    uno::Reference< star::ucb::XPersistentPropertySet > xAdditionalPropSet;
+    Reference< XPersistentPropertySet > xAdditionalPropSet;
 	sal_Bool bTriedToGetAdditonalPropSet = sal_False;
 
 	for ( sal_Int32 n = 0; n < nCount; ++n )
 	{
-        const beans::PropertyValue& rValue = pValues[ n ];
+        const PropertyValue& rValue = pValues[ n ];
 
-        if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Title" ) ) )
+        if ( rValue.Name.equalsAscii( "Title" ) )
 		{
-			changePropertyValue(rValue,n,m_aProps->m_sTitle,nChanged,aRet,aChanges);
+			changePropertyValue( rValue, n, m_aProps->m_sTitle, nChanged, aRet, aChanges );
 		}
-		else if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Author") ) )
+		else if ( rValue.Name.equalsAscii( "Author") )
 		{
-			changePropertyValue(rValue,n,m_aProps->m_sAuthor,nChanged,aRet,aChanges);
+			changePropertyValue( rValue, n, m_aProps->m_sAuthor, nChanged, aRet, aChanges );
 		}
-		else if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Keywords") ) )
+		else if ( rValue.Name.equalsAscii( "Keywords") )
 		{
-			changePropertyValue(rValue,n,m_aProps->m_sKeywords,nChanged,aRet,aChanges);
+			changePropertyValue( rValue, n, m_aProps->m_sKeywords, nChanged, aRet, aChanges );
 		}
-		else if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Subject") ) )
+		else if ( rValue.Name.equalsAscii( "Subject") )
 		{
-			changePropertyValue(rValue,n,m_aProps->m_sSubject,nChanged,aRet,aChanges);
+			changePropertyValue( rValue, n, m_aProps->m_sSubject, nChanged, aRet, aChanges );
 		}
-		else if (	rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "ContentType" ) )	||
-					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "IsDocument" ) )	||
-					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "IsFolder" ) )		||
-					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "DateCreated" ) )	||
-					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "DateModified" ) )	||
-					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "IsReadOnly" ) ) )
+		else if ( rValue.Name.equalsAscii( "ContentType" )	||
+				  rValue.Name.equalsAscii( "IsDocument" ) ||
+				  rValue.Name.equalsAscii( "IsFolder" ) ||
+				  rValue.Name.equalsAscii( "DateCreated" ) ||
+				  rValue.Name.equalsAscii( "DateModified" ) ||
+				  rValue.Name.equalsAscii( "IsReadOnly" ) )
         {
 			// Read-only property!
-            aRet[ n ] <<= lang::IllegalAccessException(
-                            rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(
-                                "Property is read-only!") ),
-                            static_cast< cppu::OWeakObject * >( this ) );
+            aRet[ n ] <<= IllegalAccessException(
+				rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Property is read-only!" ) ),
+				static_cast< cppu::OWeakObject * >( this ) );
 		}
 		else
 		{
@@ -1005,13 +909,12 @@ uno::Sequence< uno::Any > Content::setPr
 			{
 				try
 				{
-                    uno::Any aOldValue
-                        = xAdditionalPropSet->getPropertyValue( rValue.Name );
+                    Any aOldValue( xAdditionalPropSet->getPropertyValue( rValue.Name ));
 					if ( aOldValue != rValue.Value )
 					{
 						xAdditionalPropSet->setPropertyValue(
-												rValue.Name, rValue.Value );
-
+							rValue.Name, rValue.Value );
+						
 						aEvent.PropertyName = rValue.Name;
 						aEvent.OldValue		= aOldValue;
 						aEvent.NewValue     = rValue.Value;
@@ -1024,26 +927,26 @@ uno::Sequence< uno::Any > Content::setPr
                         // Old value equals new value. No error!
                     }
 				}
-                catch ( beans::UnknownPropertyException const & e )
+                catch ( UnknownPropertyException const & e )
 				{
                     aRet[ n ] <<= e;
 				}
-                catch ( lang::WrappedTargetException const & e )
+                catch ( WrappedTargetException const & e )
 				{
                     aRet[ n ] <<= e;
 				}
-                catch ( beans::PropertyVetoException const & e )
+                catch ( PropertyVetoException const & e )
 				{
                     aRet[ n ] <<= e;
 				}
-                catch ( lang::IllegalArgumentException const & e )
+                catch ( IllegalArgumentException const & e )
 				{
                     aRet[ n ] <<= e;
 				}
 			}
             else
             {
-                aRet[ n ] <<= uno::Exception(
+                aRet[ n ] <<= Exception(
                                 rtl::OUString::createFromAscii(
                                     "No property set for storing the value!" ),
                                 static_cast< cppu::OWeakObject * >( this ) );
@@ -1108,8 +1011,7 @@ void Content::queryChildren( ContentRefL
 			{
 				// No further slashes / only a final slash. It's a child!
 				rChildren.push_back(
-					ContentRef(
-						static_cast< Content * >( xChild.getBodyPtr() ) ) );
+					ContentRef( static_cast< Content * >( xChild.getBodyPtr() ) ) );
 			}
 		}
 		++it;
@@ -1117,12 +1019,10 @@ void Content::queryChildren( ContentRefL
 }
 #endif
 //=========================================================================
-void Content::insert(
-        const uno::Reference< io::XInputStream > & xInputStream,
-        sal_Bool bReplaceExisting,
-        const uno::Reference<
-            com::sun::star::ucb::XCommandEnvironment >& Environment )
-    throw( uno::Exception )
+void Content::insert( const Reference< XInputStream > & xInputStream,
+					  sal_Bool bReplaceExisting,
+					  const Reference< XCommandEnvironment >& Environment )
+    throw ( Exception )
 {
 	osl::ClearableGuard< osl::Mutex > aGuard( m_aMutex );
 
@@ -1131,13 +1031,13 @@ void Content::insert(
 	{
         OSL_ENSURE( sal_False, "Content::insert - property value missing!" );
 
-        uno::Sequence< rtl::OUString > aProps( 1 );
+        Sequence< rtl::OUString > aProps( 1 );
         aProps[ 0 ] = rtl::OUString::createFromAscii( "zzzz" );
         ucbhelper::cancelCommandExecution(
-            uno::makeAny( star::ucb::MissingPropertiesException(
-                                rtl::OUString(),
-                                static_cast< cppu::OWeakObject * >( this ),
-                                aProps ) ),
+            makeAny( MissingPropertiesException(
+						 rtl::OUString(),
+						 static_cast< cppu::OWeakObject * >( this ),
+						 aProps ) ),
             Environment );
         // Unreachable
 	}
@@ -1147,29 +1047,29 @@ void Content::insert(
         OSL_ENSURE( sal_False, "Content::insert - No data stream!" );
 
         ucbhelper::cancelCommandExecution(
-            uno::makeAny( star::ucb::MissingInputStreamException(
-                            rtl::OUString(),
-                            static_cast< cppu::OWeakObject * >( this ) ) ),
+            makeAny( MissingInputStreamException(
+						 rtl::OUString(),
+						 static_cast< cppu::OWeakObject * >( this ) ) ),
             Environment );
         // Unreachable
     }
 
 	// Assemble new content identifier...
 
-    //	uno::Reference< star::ucb::XContentIdentifier > xId = ...;
+    //	Reference< XContentIdentifier > xId = ...;
 
     // Fail, if a resource with given id already exists.
     if ( !bReplaceExisting ) // && hasData( m_xIdentifier ) )
     {
 		ucbhelper::cancelCommandExecution(
-            uno::makeAny( star::ucb::UnsupportedCommandException(
-                            rtl::OUString(),
-                            static_cast< cppu::OWeakObject * >( this ) ) ),
+            makeAny( UnsupportedCommandException(
+						 rtl::OUString(),
+						 static_cast< cppu::OWeakObject * >( this ) ) ),
             Environment );
 //        ucbhelper::cancelCommandExecution(
-//						star::ucb::IOErrorCode_ALREADY_EXISTING,
+//						IOErrorCode_ALREADY_EXISTING,
 //						Environment,
-//						uno::makeAny(static_cast< cppu::OWeakObject * >( this ))
+//						makeAny( static_cast< cppu::OWeakObject * >( this ) )
 //                         );
         // Unreachable
     }
@@ -1185,11 +1085,11 @@ void Content::insert(
 #if 0
 //=========================================================================
 void Content::destroy( sal_Bool bDeletePhysical )
-    throw( uno::Exception )
+    throw ( Exception )
 {
 	// @@@ take care about bDeletePhysical -> trashcan support
 
-    uno::Reference< star::ucb::XContent > xThis = this;
+    Reference< XContent > xThis = this;
 
 	deleted();
 
@@ -1214,16 +1114,17 @@ void Content::destroy( sal_Bool bDeleteP
 // -----------------------------------------------------------------------------
 ::rtl::OUString Content::openDoc()
 {
-	OSL_ENSURE(m_aProps.isValid(),"No valid content properties!");
-	return ContentProvider::openDoc(m_aProps);
+	OSL_ENSURE( m_aProps.isValid(), "No valid content properties!" );
+	return ContentProvider::openDoc( m_aProps );
 }
 // -----------------------------------------------------------------------------
-void Content::changePropertyValue(const beans::PropertyValue& _rValue,
-								  sal_Int32 _rnCurrentPos,
-								  ::rtl::OUString& _rsMemberValue,
-								  sal_Int32& _rnChanged,
-								  uno::Sequence< uno::Any >& _rRet,
-								  uno::Sequence< beans::PropertyChangeEvent >& _rChanges) throw (beans::IllegalTypeException)
+void Content::changePropertyValue( const PropertyValue& _rValue,
+								   sal_Int32 _rnCurrentPos,
+								   ::rtl::OUString& _rsMemberValue,
+								   sal_Int32& _rnChanged,
+								   Sequence< Any >& _rRet,
+								   Sequence< PropertyChangeEvent >& _rChanges )
+	throw ( IllegalTypeException )
 {
     rtl::OUString sNewValue;
 	sal_Bool bError = sal_False;
@@ -1233,35 +1134,35 @@ void Content::changePropertyValue(const 
 		{
 			osl::Guard< osl::Mutex > aGuard( m_aMutex );
 			// first we have to check if we could change the property inside the DMS
-			::rtl::OString sDocInfoValue = ::rtl::OUStringToOString(sNewValue,RTL_TEXTENCODING_ASCII_US);
-			WORD nDocInfo;
-			if(&_rsMemberValue == &m_aProps->m_sTitle)
+			::rtl::OString sDocInfoValue = ::rtl::OUStringToOString( sNewValue, RTL_TEXTENCODING_ASCII_US );
+			WORD nDocInfo = 0;
+			if ( &_rsMemberValue == &m_aProps->m_sTitle )
 				nDocInfo = ODM_TITLETEXT;
-			else if(&_rsMemberValue == &m_aProps->m_sAuthor)
+			else if ( &_rsMemberValue == &m_aProps->m_sAuthor )
 				nDocInfo = ODM_AUTHOR;
-			else if(&_rsMemberValue == &m_aProps->m_sSubject)
+			else if ( &_rsMemberValue == &m_aProps->m_sSubject )
 				nDocInfo = ODM_SUBJECT;
-			else if(&_rsMemberValue == &m_aProps->m_sKeywords)
+			else if ( &_rsMemberValue == &m_aProps->m_sKeywords )
 				nDocInfo = ODM_KEYWORDS;
 			else
 				bError = sal_True;
 
-			if(!bError)
+			if ( ! bError )
 			{
 				ODMSTATUS odm = NODMSetDocInfo(	ContentProvider::getHandle(),
-												const_cast<sal_Char*>(m_aProps->m_sDocumentId.getStr()),
+												const_cast<sal_Char*>( m_aProps->m_sDocumentId.getStr() ),
 												nDocInfo,
-												const_cast<sal_Char*>(sDocInfoValue.getStr())
+												const_cast<sal_Char*>( sDocInfoValue.getStr() )
 												);
-				if(odm == ODM_SUCCESS)
+				if ( odm == ODM_SUCCESS )
 				{
-					beans::PropertyChangeEvent aEvent;
+					PropertyChangeEvent aEvent;
 					aEvent.Source			= static_cast< cppu::OWeakObject * >( this );
 					aEvent.Further 			= sal_False;
 					aEvent.PropertyHandle	= -1;
 					aEvent.PropertyName		= _rValue.Name;
-					aEvent.OldValue			= uno::makeAny( _rsMemberValue );
-					aEvent.NewValue			= uno::makeAny( sNewValue );
+					aEvent.OldValue			= makeAny( _rsMemberValue );
+					aEvent.NewValue			= makeAny( sNewValue );
 
 					_rChanges.getArray()[ _rnChanged ] = aEvent;
 
@@ -1278,12 +1179,12 @@ void Content::changePropertyValue(const 
     else
 		bError = sal_True;
 
-	if(bError)
+	if ( bError )
     {
-        _rRet[ _rnCurrentPos ] <<= beans::IllegalTypeException(
-                        rtl::OUString::createFromAscii(
-                            "Property value has wrong type!" ),
-                        static_cast< cppu::OWeakObject * >( this ) );
+        _rRet[ _rnCurrentPos ] <<= IllegalTypeException(
+			rtl::OUString::createFromAscii(
+				"Property value has wrong type!" ),
+			static_cast< cppu::OWeakObject * >( this ) );
     }
 }
 // -----------------------------------------------------------------------------
Index: ucb/source/ucp/odma/odma_content.hxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_content.hxx,v
retrieving revision 1.4
diff -p -u -r1.4 odma_content.hxx
--- ucb/source/ucp/odma/odma_content.hxx	9 Sep 2005 15:50:31 -0000	1.4
+++ ucb/source/ucp/odma/odma_content.hxx	6 Nov 2006 00:12:08 -0000
@@ -39,29 +39,25 @@
 
 #include <list>
 
+#ifndef _COM_SUN_STAR_BEANS_PROPERTY_HPP_
+#include <com/sun/star/beans/Property.hpp>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_
+#include <com/sun/star/beans/PropertyValue.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XINPUTSTREAM_HPP_
+#include <com/sun/star/io/XInputStream.hpp>
+#endif
+#ifndef _COM_SUN_STAR_SDBC_XROW_HPP_
+#include <com/sun/star/sdbc/XRow.hpp>
+#endif
+#ifndef _UCBHELPER_CONTENT_HXX
+#include <ucbhelper/content.hxx>
+#endif
 #ifndef _UCBHELPER_CONTENTHELPER_HXX
 #include <ucbhelper/contenthelper.hxx>
 #endif
 
-namespace com { namespace sun { namespace star { 
-	namespace beans {
-		struct Property;
-		struct PropertyValue;
-	} 
-	namespace sdbc {
-		class XRow;
-	}
-	namespace io {
-		class XInputStream;
-	}
-}}}
-namespace ucb
-{
-	class Content;
-}
-
-
-// @@@ Adjust namespace name.
 namespace odma
 {
 
@@ -71,7 +67,7 @@ namespace odma
 
 // UNO service name for the content.
 #define ODMA_CONTENT_SERVICE_NAME \
-							"com.sun.star.ucb.OdmaContent"
+							"com.sun.star.ucb.ODMAContent"
 
 //=========================================================================
 class ContentProvider;
@@ -98,9 +94,9 @@ private:
 						::com::sun::star::ucb::XCommandEnvironment >& xEnv );
     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >
     setPropertyValues( const ::com::sun::star::uno::Sequence<
-                        ::com::sun::star::beans::PropertyValue >& rValues,
+                       ::com::sun::star::beans::PropertyValue >& rValues,
                        const ::com::sun::star::uno::Reference<
-                        ::com::sun::star::ucb::XCommandEnvironment >& xEnv );
+                       ::com::sun::star::ucb::XCommandEnvironment >& xEnv );
 
 	/** openDoc returns the file URL for the DOC ID
 		@return the url of the temporary file
@@ -128,10 +124,10 @@ private:
 
   // Command "insert"
     void insert( const ::com::sun::star::uno::Reference<
-                    ::com::sun::star::io::XInputStream > & xInputStream,
+                 ::com::sun::star::io::XInputStream > & xInputStream,
                  sal_Bool bReplaceExisting,
                  const com::sun::star::uno::Reference<
-                    com::sun::star::ucb::XCommandEnvironment >& Environment )
+                 com::sun::star::ucb::XCommandEnvironment >& Environment )
         throw( ::com::sun::star::uno::Exception );
 
 //  // Command "delete"
@@ -140,11 +136,11 @@ private:
 
 public:
 	Content( const ::com::sun::star::uno::Reference<
-				::com::sun::star::lang::XMultiServiceFactory >& rxSMgr,
-				ContentProvider* pProvider,
+			   ::com::sun::star::lang::XMultiServiceFactory >& rxSMgr,
+			 ContentProvider* pProvider,
 			 const ::com::sun::star::uno::Reference<
-				::com::sun::star::ucb::XContentIdentifier >& Identifier,
-				const ::vos::ORef<ContentProperties>& _rProps);
+			   ::com::sun::star::ucb::XContentIdentifier >& Identifier,
+			 const ::vos::ORef< ContentProperties >& _rProps);
 	virtual ~Content();
 
 	// XInterface
Index: ucb/source/ucp/odma/odma_contentcaps.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_contentcaps.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_contentcaps.cxx
--- ucb/source/ucp/odma/odma_contentcaps.cxx	17 Sep 2006 13:57:29 -0000	1.5
+++ ucb/source/ucp/odma/odma_contentcaps.cxx	6 Nov 2006 00:12:08 -0000
@@ -92,7 +92,7 @@ using namespace odma;
 
 // virtual
 uno::Sequence< beans::Property > Content::getProperties(
-             const uno::Reference< star::ucb::XCommandEnvironment > & xEnv )
+             const uno::Reference< star::ucb::XCommandEnvironment > & /* xEnv */ )
 {
 	// @@@ Add additional properties...
 
@@ -193,7 +193,7 @@ uno::Sequence< beans::Property > Content
 //=========================================================================
 // virtual
 uno::Sequence< star::ucb::CommandInfo > Content::getCommands(
-            const uno::Reference< star::ucb::XCommandEnvironment > & xEnv )
+            const uno::Reference< star::ucb::XCommandEnvironment > & /* xEnv */ )
 {
 	// @@@ Add additional commands...
 
Index: ucb/source/ucp/odma/odma_contentprops.hxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_contentprops.hxx,v
retrieving revision 1.4
diff -p -u -r1.4 odma_contentprops.hxx
--- ucb/source/ucp/odma/odma_contentprops.hxx	9 Sep 2005 15:51:07 -0000	1.4
+++ ucb/source/ucp/odma/odma_contentprops.hxx	6 Nov 2006 00:12:08 -0000
@@ -80,6 +80,7 @@ namespace odma
 		{}
 
 		inline ::rtl::OUString getTitle()		const { return m_sTitle;		}
+		inline ::rtl::OUString getDocumentId()	const { return ::rtl::OStringToOUString( m_sDocumentId, RTL_TEXTENCODING_ASCII_US ); }
 		inline ::rtl::OUString getSavedAsName() const { return m_sSavedAsName;	}
 	};
 	typedef ::std::binary_function< ::vos::ORef<ContentProperties>, ::rtl::OUString,bool> TContentPropertiesFunctorBase;
Index: ucb/source/ucp/odma/odma_datasupplier.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_datasupplier.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_datasupplier.cxx
--- ucb/source/ucp/odma/odma_datasupplier.cxx	17 Sep 2006 13:57:42 -0000	1.5
+++ ucb/source/ucp/odma/odma_datasupplier.cxx	6 Nov 2006 00:12:08 -0000
@@ -63,9 +63,6 @@
 #ifndef ODMA_PROVIDER_HXX
 #include "odma_provider.hxx"
 #endif
-#ifndef ODMA_LIB_HXX
-#include "odma_lib.hxx"
-#endif
 
 using namespace com::sun::star::beans;
 using namespace com::sun::star::lang;
@@ -170,11 +167,11 @@ DataSupplier::~DataSupplier()
 
 //=========================================================================
 // virtual
-::rtl::OUString DataSupplier::queryContentIdentifierString( sal_uInt32 nIndex )
+::rtl::OUString DataSupplier::queryContentIdentifierString( sal_Int32 nIndex )
 {
 	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( nIndex < m_pImpl->m_aResults.size() )
+	if ( nIndex < (sal_Int32) m_pImpl->m_aResults.size() )
 	{
 		::rtl::OUString aId = m_pImpl->m_aResults[ nIndex ]->aId;
 		if ( aId.getLength() )
@@ -200,11 +197,11 @@ DataSupplier::~DataSupplier()
 //=========================================================================
 // virtual
 Reference< XContentIdentifier > DataSupplier::queryContentIdentifier(
-														sal_uInt32 nIndex )
+														sal_Int32 nIndex )
 {
 	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( nIndex < m_pImpl->m_aResults.size() )
+	if ( nIndex < (sal_Int32) m_pImpl->m_aResults.size() )
 	{
 		Reference< XContentIdentifier > xId
 								= m_pImpl->m_aResults[ nIndex ]->xId;
@@ -227,11 +224,11 @@ Reference< XContentIdentifier > DataSupp
 
 //=========================================================================
 // virtual
-Reference< XContent > DataSupplier::queryContent( sal_uInt32 nIndex )
+Reference< XContent > DataSupplier::queryContent( sal_Int32 nIndex )
 {
 	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( nIndex < m_pImpl->m_aResults.size() )
+	if ( nIndex < (sal_Int32) m_pImpl->m_aResults.size() )
 	{
 		Reference< XContent > xContent
 								= m_pImpl->m_aResults[ nIndex ]->xContent;
@@ -262,11 +259,11 @@ Reference< XContent > DataSupplier::quer
 
 //=========================================================================
 // virtual
-sal_Bool DataSupplier::getResult( sal_uInt32 nIndex )
+sal_Bool DataSupplier::getResult( sal_Int32 nIndex )
 {
 	osl::ClearableGuard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( m_pImpl->m_aResults.size() > nIndex )
+	if ( (sal_Int32) m_pImpl->m_aResults.size() > nIndex )
 	{
 		// Result already present.
 		return sal_True;
@@ -281,10 +278,11 @@ sal_Bool DataSupplier::getResult( sal_uI
 
 	sal_uInt32 nOldCount = m_pImpl->m_aResults.size();
 	sal_Bool bFound = sal_False;
-	sal_uInt32 nPos = nOldCount;
 
 	// @@@ Obtain data and put it into result list...
 /*
+	sal_uInt32 nPos = nOldCount;
+
 	while ( m_pImpl->m_aFolder.next( m_pImpl->m_aIterator ) )
 	{
 		m_pImpl->m_aResults.push_back(
@@ -308,7 +306,7 @@ sal_Bool DataSupplier::getResult( sal_uI
 	ODMSTATUS odm = NODMGetDMS(ODMA_ODMA_REGNAME, lpszDMSList);
 	lpszDMSList[strlen(lpszDMSList)+1] = '\0';
 
-	::rtl::OString sQuery("SELECT ODM_DOCID, ODM_NAME");
+	::rtl::OString sQuery("SELECT ODM_DOCID_LATEST, ODM_NAME");
 	
 	DWORD dwFlags = ODM_SPECIFIC;
 	odm = NODMQueryExecute(ContentProvider::getHandle(), sQuery,dwFlags, lpszDMSList, pQueryId );
@@ -322,7 +320,7 @@ sal_Bool DataSupplier::getResult( sal_uI
 
 	
 	::rtl::OUString sContentType(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
-	sal_uInt32 nCurrentCount = 0;
+	sal_Int32 nCurrentCount = 0;
 	do
 	{
 		if(nCount >= nMaxCount)
@@ -377,7 +375,7 @@ sal_Bool DataSupplier::getResult( sal_uI
 
 //=========================================================================
 // virtual
-sal_uInt32 DataSupplier::totalCount()
+sal_Int32 DataSupplier::totalCount()
 {
 	osl::ClearableGuard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
@@ -412,7 +410,7 @@ sal_uInt32 DataSupplier::totalCount()
 
 //=========================================================================
 // virtual
-sal_uInt32 DataSupplier::currentCount()
+sal_Int32 DataSupplier::currentCount()
 {
 	return m_pImpl->m_aResults.size();
 }
@@ -426,11 +424,11 @@ sal_Bool DataSupplier::isCountFinal()
 
 //=========================================================================
 // virtual
-Reference< XRow > DataSupplier::queryPropertyValues( sal_uInt32 nIndex  )
+Reference< XRow > DataSupplier::queryPropertyValues( sal_Int32 nIndex  )
 {
 	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( nIndex < m_pImpl->m_aResults.size() )
+	if ( nIndex < (sal_Int32) m_pImpl->m_aResults.size() )
 	{
 		Reference< XRow > xRow = m_pImpl->m_aResults[ nIndex ]->xRow;
 		if ( xRow.is() )
@@ -457,11 +455,11 @@ Reference< XRow > DataSupplier::queryPro
 
 //=========================================================================
 // virtual
-void DataSupplier::releasePropertyValues( sal_uInt32 nIndex )
+void DataSupplier::releasePropertyValues( sal_Int32 nIndex )
 {
 	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
 
-	if ( nIndex < m_pImpl->m_aResults.size() )
+	if ( nIndex < (sal_Int32) m_pImpl->m_aResults.size() )
 		m_pImpl->m_aResults[ nIndex ]->xRow = Reference< XRow >();
 }
 
Index: ucb/source/ucp/odma/odma_datasupplier.hxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_datasupplier.hxx,v
retrieving revision 1.4
diff -p -u -r1.4 odma_datasupplier.hxx
--- ucb/source/ucp/odma/odma_datasupplier.hxx	9 Sep 2005 15:51:37 -0000	1.4
+++ ucb/source/ucp/odma/odma_datasupplier.hxx	6 Nov 2006 00:12:08 -0000
@@ -49,6 +49,8 @@ class DataSupplier : public ucb::ResultS
 {
 	DataSupplier_Impl* m_pImpl;
 
+	virtual sal_Bool getResult( sal_Int32 nIndex );
+
 public:
 	DataSupplier( const com::sun::star::uno::Reference<
 				  	com::sun::star::lang::XMultiServiceFactory >& rxSMgr,
@@ -56,22 +58,20 @@ public:
 				  sal_Int32 nOpenMode );
 	virtual ~DataSupplier();
 
-	virtual rtl::OUString queryContentIdentifierString( sal_uInt32 nIndex );
+	virtual rtl::OUString queryContentIdentifierString( sal_Int32 nIndex );
 	virtual com::sun::star::uno::Reference<
 				com::sun::star::ucb::XContentIdentifier >
-	queryContentIdentifier( sal_uInt32 nIndex );
+	queryContentIdentifier( sal_Int32 nIndex );
 	virtual com::sun::star::uno::Reference< com::sun::star::ucb::XContent >
-	queryContent( sal_uInt32 nIndex );
-
-	virtual sal_Bool getResult( sal_uInt32 nIndex );
+	queryContent( sal_Int32 nIndex );
 
-	virtual sal_uInt32 totalCount();
-	virtual sal_uInt32 currentCount();
+	virtual sal_Int32 totalCount();
+	virtual sal_Int32 currentCount();
 	virtual sal_Bool isCountFinal();
 
 	virtual com::sun::star::uno::Reference< com::sun::star::sdbc::XRow >
-	queryPropertyValues( sal_uInt32 nIndex  );
-	virtual void releasePropertyValues( sal_uInt32 nIndex );
+	queryPropertyValues( sal_Int32 nIndex  );
+	virtual void releasePropertyValues( sal_Int32 nIndex );
 
 	virtual void close();
 
Index: ucb/source/ucp/odma/odma_lib.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_lib.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_lib.cxx
--- ucb/source/ucp/odma/odma_lib.cxx	17 Sep 2006 13:58:10 -0000	1.5
+++ ucb/source/ucp/odma/odma_lib.cxx	6 Nov 2006 00:12:08 -0000
@@ -44,6 +44,8 @@
 #ifndef _RTL_USTRING_HXX_ 
 #include <rtl/ustring.hxx>
 #endif
+#include <tools/prewin.h>
+#include <tools/postwin.h>
 #ifndef ODMA_LIB_HXX
 #include "odma_lib.hxx"
 #endif
@@ -84,17 +86,18 @@ namespace odma
 
 	sal_Bool LoadFunctions(oslModule _pODMA);
 
-	sal_Bool LoadLibrary()
+	sal_Bool DMSsAvailable()
 	{
 		static sal_Bool bLoaded = sal_False;
-		static oslModule pODMA = NULL;
+		static sal_Bool bBeenHere = sal_False;
+		oslModule pODMA = NULL;
 		
-		if (bLoaded) 
-			return sal_True;
+		if (bBeenHere) 
+			return bLoaded;
+
 		::rtl::OUString sPath;
 	#ifdef WIN
 		sPath = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMA.DLL"));
-		
 	#endif
 	#ifdef WNT
 		sPath = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMA32.DLL"));
@@ -103,11 +106,21 @@ namespace odma
 		sPath = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("libodma.so"));
 	#endif
 
+		bBeenHere = sal_True;
+
 		pODMA = osl_loadModule( sPath.pData,SAL_LOADMODULE_NOW );
 		if( !pODMA)
 			return sal_False;
 
-		return bLoaded = LoadFunctions(pODMA);
+		if (!LoadFunctions(pODMA))
+			return sal_False;
+
+		bLoaded = (NODMGetDMSCount() > 0);
+
+		if (getenv ("NO_ODMA"))
+			bLoaded = sal_False;
+
+		return bLoaded;
 	}
 	// -------------------------------------------------------------------------
 
Index: ucb/source/ucp/odma/odma_lib.hxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_lib.hxx,v
retrieving revision 1.4
diff -p -u -r1.4 odma_lib.hxx
--- ucb/source/ucp/odma/odma_lib.hxx	9 Sep 2005 15:52:48 -0000	1.4
+++ ucb/source/ucp/odma/odma_lib.hxx	6 Nov 2006 00:12:08 -0000
@@ -35,20 +35,8 @@
 #ifndef ODMA_LIB_HXX
 #define ODMA_LIB_HXX
 
-typedef void	            *LPVOID;
-typedef char				*LPSTR, 
-							*PSTR;
-typedef const char			*LPCSTR;
-typedef unsigned long       DWORD;
-typedef unsigned short      WORD;
-typedef unsigned short      *LPWORD;
-typedef DWORD		        *LPDWORD;
-
-#define WINAPI				__stdcall
-#define FAR
-
 #ifndef ODMA_H
-#include "odma.h"
+#include <odma.h>
 #endif
 
 namespace odma
@@ -215,37 +203,37 @@ namespace odma
 
 	// now we define some macros
 
-	#define NODMRegisterApp(a,b,c,d,e)			(*(pODMRegisterApp))(a,b,c,d,e)
-	#define NODMUnRegisterApp(a)				(*(pODMUnRegisterApp))(a)
-	#define NODMSelectDoc(a,b,c)				(*(pODMSelectDoc))(a,b,c)
-	#define NODMOpenDoc(a,b,c,d)				(*(pODMOpenDoc))(a,b,c,d)
-	#define NODMSaveDoc(a,b,c)					(*(pODMSaveDoc))(a,b,c)
-	#define NODMCloseDoc(a,b,c,d,e,f)			(*(pODMCloseDoc))(a,b,c,d,e,f)
-	#define NODMNewDoc(a,b,c,d,e)				(*(pODMNewDoc))(a,b,c,d,e)
-	#define NODMSaveAs(a,b,c,d,e,f)				(*(pODMSaveAs))(a,b,c,d,e,f)
-	#define NODMActivate(a,b,c)					(*(pODMActivate))(a,b,c)
-	#define NODMGetDocInfo(a,b,c,d,e)			(*(pODMGetDocInfo))(a,b,c,d,e)
-	#define NODMSetDocInfo(a,b,c,d)				(*(pODMSetDocInfo))(a,b,c,d)
-	#define NODMGetDMSInfo(a,b,c,d)				(*(pODMGetDMSInfo))(a,b,c,d)
-	#define NODMGetDMSCount()					(*(pODMGetDMSCount))()
-	#define NODMGetDMSList(a,b)					(*(pODMGetDMSList))(a,b)
-	#define NODMGetDMS(a,b)						(*(pODMGetDMS))(a,b)
-	#define NODMSetDMS(a,b)						(*(pODMSetDMS))(a,b)
-	#define NODMQueryExecute(a,b,c,d,e)			(*(pODMQueryExecute))(a,b,c,d,e)
-	#define NODMQueryGetResults(a,b,c,d,e,f)	(*(pODMQueryGetResults))(a,b,c,d,e,f)
-	#define NODMQueryClose(a,b)					(*(pODMQueryClose))(a,b)
-	#define NODMCloseDocEx(a,b,c,d,e,f,g)		(*(pODMCloseDocEx))(a,b,c,d,e,f,g)
-	#define NODMSaveAsEx(a,b,c,d,e,f,g)			(*(pODMSaveAsEx))(a,b,c,d,e,f,g)
-	#define NODMSaveDocEx(a,b,c,d)				(*(pODMSaveDocEx))(a,b,c,d)
-	#define NODMSelectDocEx(a,b,c,d,e,f)		(*(pODMSelectDocEx))(a,b,c,d,e,f)
-	#define NODMQueryCapability(a,b,c,d,e)		(*(pODMQueryCapability))(a,b,c,d,e)
-	#define NODMSetDocEvent(a,b,c,d,e,f,g)		(*(pODMSetDocEvent))(a,b,c,d,e,f,g)
-	#define NODMGetAlternateContent(a,b,c,d,e)	(*(pODMGetAlternateContent))(a,b,c,d,e)
-	#define NODMSetAlternateContent(a,b,c,d,e)	(*(pODMSetAlternateContent))(a,b,c,d,e)
-	#define NODMGetDocRelation(a,b,c,d,e,f)		(*(pODMGetDocRelation))(a,b,c,d,e,f)
-	#define NODMSetDocRelation(a,b,c,d,e,f)		(*(pODMSetDocRelation))(a,b,c,d,e,f)
+	#define NODMRegisterApp(a,b,c,d,e)			(*(::odma::pODMRegisterApp))(a,b,c,d,e)
+	#define NODMUnRegisterApp(a)				(*(::odma::pODMUnRegisterApp))(a)
+	#define NODMSelectDoc(a,b,c)				(*(::odma::pODMSelectDoc))(a,b,c)
+	#define NODMOpenDoc(a,b,c,d)				(*(::odma::pODMOpenDoc))(a,b,c,d)
+	#define NODMSaveDoc(a,b,c)					(*(::odma::pODMSaveDoc))(a,b,c)
+	#define NODMCloseDoc(a,b,c,d,e,f)			(*(::odma::pODMCloseDoc))(a,b,c,d,e,f)
+	#define NODMNewDoc(a,b,c,d,e)				(*(::odma::pODMNewDoc))(a,b,c,d,e)
+	#define NODMSaveAs(a,b,c,d,e,f)				(*(::odma::pODMSaveAs))(a,b,c,d,e,f)
+	#define NODMActivate(a,b,c)					(*(::odma::pODMActivate))(a,b,c)
+	#define NODMGetDocInfo(a,b,c,d,e)			(*(::odma::pODMGetDocInfo))(a,b,c,d,e)
+	#define NODMSetDocInfo(a,b,c,d)				(*(::odma::pODMSetDocInfo))(a,b,c,d)
+	#define NODMGetDMSInfo(a,b,c,d)				(*(::odma::pODMGetDMSInfo))(a,b,c,d)
+	#define NODMGetDMSCount()					(*(::odma::pODMGetDMSCount))()
+	#define NODMGetDMSList(a,b)					(*(::odma::pODMGetDMSList))(a,b)
+	#define NODMGetDMS(a,b)						(*(::odma::pODMGetDMS))(a,b)
+	#define NODMSetDMS(a,b)						(*(::odma::pODMSetDMS))(a,b)
+	#define NODMQueryExecute(a,b,c,d,e)			(*(::odma::pODMQueryExecute))(a,b,c,d,e)
+	#define NODMQueryGetResults(a,b,c,d,e,f)	(*(::odma::pODMQueryGetResults))(a,b,c,d,e,f)
+	#define NODMQueryClose(a,b)					(*(::odma::pODMQueryClose))(a,b)
+	#define NODMCloseDocEx(a,b,c,d,e,f,g)		(*(::odma::pODMCloseDocEx))(a,b,c,d,e,f,g)
+	#define NODMSaveAsEx(a,b,c,d,e,f,g)			(*(::odma::pODMSaveAsEx))(a,b,c,d,e,f,g)
+	#define NODMSaveDocEx(a,b,c,d)				(*(::odma::pODMSaveDocEx))(a,b,c,d)
+	#define NODMSelectDocEx(a,b,c,d,e,f)		(*(::odma::pODMSelectDocEx))(a,b,c,d,e,f)
+	#define NODMQueryCapability(a,b,c,d,e)		(*(::odma::pODMQueryCapability))(a,b,c,d,e)
+	#define NODMSetDocEvent(a,b,c,d,e,f,g)		(*(::odma::pODMSetDocEvent))(a,b,c,d,e,f,g)
+	#define NODMGetAlternateContent(a,b,c,d,e)	(*(::odma::pODMGetAlternateContent))(a,b,c,d,e)
+	#define NODMSetAlternateContent(a,b,c,d,e)	(*(::odma::pODMSetAlternateContent))(a,b,c,d,e)
+	#define NODMGetDocRelation(a,b,c,d,e,f)		(*(::odma::pODMGetDocRelation))(a,b,c,d,e,f)
+	#define NODMSetDocRelation(a,b,c,d,e,f)		(*(::odma::pODMSetDocRelation))(a,b,c,d,e,f)
 
-	sal_Bool LoadLibrary();
+	sal_Bool DMSsAvailable();
 
 	extern TODMRegisterApp			pODMRegisterApp;
 	extern TODMUnRegisterApp		pODMUnRegisterApp;
Index: ucb/source/ucp/odma/odma_main.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_main.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_main.cxx
--- ucb/source/ucp/odma/odma_main.cxx	17 Sep 2006 13:58:24 -0000	1.5
+++ ucb/source/ucp/odma/odma_main.cxx	6 Nov 2006 00:12:08 -0000
@@ -68,12 +68,12 @@ void _cdecl main( int argc, char * argv[
 		::rtl::OUString* pArguments = new ::rtl::OUString[argc-1];
 		for(int i = 1; i < argc;++i)
 		{
-			pArguments[i] = ::rtl::OUString::createFromAscii(argv[1]);
-			if( pArguments[i].matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_ODMAID)))
+			pArguments[i-1] = ::rtl::OUString::createFromAscii(argv[i]);
+			if( pArguments[i-1].matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_ODMAID)))
 			{
 				::rtl::OUString sArgument = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT "/"));
-				sArgument += pArguments[i];
-				pArguments[i] = sArgument;
+				sArgument += pArguments[i-1];
+				pArguments[i-1] = sArgument;
 			}
 		}
 		{
Index: ucb/source/ucp/odma/odma_provider.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_provider.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_provider.cxx
--- ucb/source/ucp/odma/odma_provider.cxx	17 Sep 2006 13:58:37 -0000	1.5
+++ ucb/source/ucp/odma/odma_provider.cxx	6 Nov 2006 00:12:08 -0000
@@ -96,7 +96,7 @@ ContentProvider::ContentProvider(
 ContentProvider::~ContentProvider()
 {
 	ContentsMap::iterator aIter = m_aContents.begin();
-	for (;aIter != m_aContents.begin() ;++aIter )
+	for (;aIter != m_aContents.end() ;++aIter )
 	{
 		if(aIter->second->m_bIsOpen)
 			closeDocument(aIter->first);
@@ -112,20 +112,7 @@ ODMHANDLE ContentProvider::getHandle() 
 { 
 	if(!m_aOdmHandle)
 	{
-		ODMSTATUS odm = NODMRegisterApp(&m_aOdmHandle,ODM_API_VERSION,ODMA_ODMA_REGNAME,NULL,NULL);
-		switch(odm)
-		{
-		case ODM_SUCCESS:
-			break;
-		case ODM_E_NODMS:
-			break;
-		case ODM_E_CANTINIT:
-			break;
-		case ODM_E_VERSION:
-			break;
-		default:
-			break;
-		}
+		NODMRegisterApp(&m_aOdmHandle,ODM_API_VERSION,ODMA_ODMA_REGNAME,NULL,NULL);
 	}
 	return m_aOdmHandle; 
 }
@@ -194,12 +181,12 @@ uno::Reference< star::ucb::XContent > SA
     rtl::OUString aScheme( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME) ) );
 	sal_Int32 nIndex = 0;
 	rtl::OUString sOdma = aScheme.getToken(3,'.',nIndex);
-	rtl::OUString sCanonicURL = Identifier->getContentIdentifier();
 	// check if url starts with odma
     if ( !(Identifier->getContentProviderScheme().equalsIgnoreAsciiCase( aScheme ) || 
 		   Identifier->getContentProviderScheme().equalsIgnoreAsciiCase( sOdma )) )
         throw star::ucb::IllegalIdentifierException();
 
+	rtl::OUString sCanonicURL = Identifier->getContentIdentifier();
 	if(!(	sCanonicURL.matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_SCHEME_SHORT ODMA_URL_SHORT)) ||
 			sCanonicURL.matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT))))
 		throw star::ucb::IllegalIdentifierException();
@@ -241,23 +228,22 @@ uno::Reference< star::ucb::XContent > SA
 	if( sCanonicURL.matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_ODMAID)))
 	{// we get an orignal ODMA id so we have to look for the name
 		::rtl::OString sDocId = ::rtl::OUStringToOString(sCanonicURL,RTL_TEXTENCODING_MS_1252);
-		sal_Char* lpszDocName = new sal_Char[ODM_NAME_MAX];
+		sal_Char szDocName[ODM_NAME_MAX];
 		
 		ODMSTATUS odm = NODMGetDocInfo(	getHandle(),
 										const_cast<sal_Char*>(sDocId.getStr()),
 										ODM_NAME,
-										lpszDocName,
+										szDocName,
 										ODM_NAME_MAX
 									);
 		if(odm == ODM_SUCCESS)
 		{
 			aProp = new ContentProperties();
-			aProp->m_sDocumentName = ::rtl::OStringToOUString(rtl::OString(lpszDocName),RTL_TEXTENCODING_ASCII_US);
+			aProp->m_sDocumentName = ::rtl::OStringToOUString(rtl::OString(szDocName),RTL_TEXTENCODING_ASCII_US);
 			aProp->m_sDocumentId   = sDocId;
 			aProp->m_sContentType  = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
 			append(aProp);
 		}
-		delete lpszDocName;
 	}
 	else // we got an already fetched name here so look for it
 	{
@@ -315,20 +301,18 @@ void ContentProvider::saveDocument(const
 	ContentsMap::iterator aIter = m_aContents.find(_sDocumentId);
 	if(aIter != m_aContents.end())
 	{
-		sal_Char* lpszDocId = new sal_Char[ODM_DOCID_MAX];
+		sal_Char szDocId[ODM_DOCID_MAX];
 		DWORD dwFlags = ODM_SILENT;
 		ODMSTATUS odm = NODMSaveDocEx(getHandle(),
 									const_cast<sal_Char*>(_sDocumentId.getStr()),
-									lpszDocId,
+									szDocId,
 									&dwFlags);
 		OSL_ENSURE(odm == ODM_SUCCESS,"Could not save document!");
 		if(odm != ODM_SUCCESS)
 		{
-			delete lpszDocId;
 			throw uno::Exception();
 		}
-		aIter->second->m_sDocumentId = rtl::OString(lpszDocId);
-		delete lpszDocId;
+		aIter->second->m_sDocumentId = rtl::OString(szDocId);
 	}
 }
 // -----------------------------------------------------------------------------
@@ -367,80 +351,71 @@ util::DateTime toDateTime(const ::rtl::O
 void ContentProvider::fillDocumentProperties(const ::vos::ORef<ContentProperties>& _rProp)
 {
 	// read some properties from the DMS
-	sal_Char* lpszDocInfo = new sal_Char[ODM_DOCID_MAX];
+	sal_Char szDocInfo[ODM_DOCID_MAX];
 	sal_Char* pDocId = const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr());
 
 	// read the create date of the document
 	ODMSTATUS odm = NODMGetDocInfo(	getHandle(),
 									pDocId,
 									ODM_CREATEDDATE,
-									lpszDocInfo,
+									szDocInfo,
 									ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_aDateCreated = toDateTime(::rtl::OString(lpszDocInfo));
+		_rProp->m_aDateCreated = toDateTime(::rtl::OString(szDocInfo));
 
 	// read the modified date of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_MODIFYDATE,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_aDateModified = toDateTime(::rtl::OString(lpszDocInfo));
+		_rProp->m_aDateModified = toDateTime(::rtl::OString(szDocInfo));
 
 	// read the title of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_TITLETEXT,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_sTitle = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+		_rProp->m_sTitle = ::rtl::OStringToOUString(rtl::OString(szDocInfo),RTL_TEXTENCODING_ASCII_US);
 
 	// read the name of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_NAME,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_sDocumentName = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+		_rProp->m_sDocumentName = ::rtl::OStringToOUString(rtl::OString(szDocInfo),RTL_TEXTENCODING_ASCII_US);
 
 	// read the author of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_AUTHOR,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_sAuthor = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+		_rProp->m_sAuthor = ::rtl::OStringToOUString(rtl::OString(szDocInfo),RTL_TEXTENCODING_ASCII_US);
 
 	// read the subject of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_SUBJECT,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_sSubject = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+		_rProp->m_sSubject = ::rtl::OStringToOUString(rtl::OString(szDocInfo),RTL_TEXTENCODING_ASCII_US);
 
 	// read the keywords of the document
 	odm = NODMGetDocInfo(	getHandle(),
 							pDocId,
 							ODM_KEYWORDS,
-							lpszDocInfo,
+							szDocInfo,
 							ODM_DOCID_MAX);
 	if(odm == ODM_SUCCESS)
-		_rProp->m_sKeywords = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
-
-/*
-	odm = NODMGetDocInfo(	getHandle(),
-									const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()),
-									ODM_URL,
-									lpszDocInfo,
-									ODM_DOCID_MAX);
-*/
-	delete lpszDocInfo;
+		_rProp->m_sKeywords = ::rtl::OStringToOUString(rtl::OString(szDocInfo),RTL_TEXTENCODING_ASCII_US);
 }
 // -----------------------------------------------------------------------------
 void ContentProvider::append(const ::vos::ORef<ContentProperties>& _rProp)
@@ -459,23 +434,23 @@ void ContentProvider::append(const ::vos
 	ODMSTATUS odm = NODMGetDMS(ODMA_ODMA_REGNAME, lpszDMSList);
 	if(odm == ODM_SUCCESS)
 	{
-		sal_Char* pQueryId = new sal_Char[ODM_QUERYID_MAX];
+		sal_Char szQueryId[ODM_QUERYID_MAX];
 		lpszDMSList[strlen(lpszDMSList)+1] = '\0';
 
 		::rtl::OString sTitleText(::rtl::OUStringToOString(_sDocumentName,RTL_TEXTENCODING_ASCII_US));
-		::rtl::OString sQuery("SELECT ODM_DOCID, ODM_NAME WHERE ODM_TITLETEXT = '");
+		::rtl::OString sQuery("SELECT ODM_DOCID_LATEST, ODM_NAME WHERE ODM_TITLETEXT = '");
 		sQuery += sTitleText;
 		sQuery += "'";
 		
 		DWORD dwFlags = ODM_SPECIFIC;
-		odm = NODMQueryExecute(getHandle(), sQuery,dwFlags, lpszDMSList, pQueryId );
+		odm = NODMQueryExecute(getHandle(), sQuery,dwFlags, lpszDMSList, szQueryId );
 		if(odm == ODM_SUCCESS)
 		{
 			sal_uInt16 nCount		= 10;
-			sal_uInt16 nMaxCount	= 10;
-			sal_Char* lpszDocId		= new sal_Char[ODM_DOCID_MAX * nMaxCount];
-			sal_Char* lpszDocName	= new sal_Char[ODM_NAME_MAX * nMaxCount];
-			sal_Char* lpszDocInfo	= new sal_Char[ODM_DOCID_MAX];
+			const int nMaxCount		= 10;
+			sal_Char szDocId[ODM_DOCID_MAX * nMaxCount];
+			sal_Char szDocName[ODM_NAME_MAX * nMaxCount];
+			sal_Char szDocInfo[ODM_DOCID_MAX];
 			
 			::rtl::OUString sContentType(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
 			do
@@ -484,21 +459,21 @@ void ContentProvider::append(const ::vos
 				{
 					// get the result
 					nCount = nMaxCount;
-					odm = NODMQueryGetResults(getHandle(), pQueryId,lpszDocId, lpszDocName, ODM_NAME_MAX, (WORD*)&nCount);
+					odm = NODMQueryGetResults(getHandle(), szQueryId, szDocId, szDocName, ODM_NAME_MAX, (WORD*)&nCount);
 				}
 				if(odm == ODM_SUCCESS)
 					for(sal_uInt16 i = 0; i < nCount; ++i)
 					{
 						odm = NODMGetDocInfo(	getHandle(),
-												&lpszDocId[ODM_DOCID_MAX*i],
+												&szDocId[ODM_DOCID_MAX*i],
 												ODM_TITLETEXT,
-												lpszDocInfo,
+												szDocInfo,
 												ODM_DOCID_MAX);
-						if( odm == ODM_SUCCESS && sTitleText == ::rtl::OString(lpszDocInfo))
+						if( odm == ODM_SUCCESS && sTitleText == ::rtl::OString(szDocInfo))
 						{
 							aReturn = new ContentProperties();
-							aReturn->m_sDocumentName	= ::rtl::OStringToOUString(rtl::OString(&lpszDocName[ODM_NAME_MAX*i]),RTL_TEXTENCODING_ASCII_US);
-							aReturn->m_sDocumentId	= ::rtl::OString(&lpszDocId[ODM_DOCID_MAX*i]);
+							aReturn->m_sDocumentName	= ::rtl::OStringToOUString(rtl::OString(&szDocName[ODM_NAME_MAX*i]),RTL_TEXTENCODING_ASCII_US);
+							aReturn->m_sDocumentId	= ::rtl::OString(&szDocId[ODM_DOCID_MAX*i]);
 							aReturn->m_sContentType	= sContentType;
 							append(aReturn);
 							nCount = 0; // break condition from outer loop
@@ -507,15 +482,10 @@ void ContentProvider::append(const ::vos
 					}
 			}
 			while(nCount > nMaxCount);
-
-			delete lpszDocInfo;
-			delete lpszDocId;
-			delete lpszDocName;
 		}
 
 		// now close the query
-		odm = NODMQueryClose(ContentProvider::getHandle(), pQueryId);
-		delete pQueryId;
+		odm = NODMQueryClose(ContentProvider::getHandle(), szQueryId);
 	}
 	delete lpszDMSList;
 	
@@ -551,33 +521,36 @@ void ContentProvider::append(const ::vos
 	return getContentProperty(_sTitle,aFunc);
 }
 // -----------------------------------------------------------------------------
+::vos::ORef<ContentProperties> ContentProvider::getContentPropertyWithDocumentId(const ::rtl::OUString& _sDocumentId) const
+{
+	ContentPropertiesMemberFunctor aFunc(::std::mem_fun(&ContentProperties::getDocumentId));
+	return getContentProperty(_sDocumentId,aFunc);
+}
+// -----------------------------------------------------------------------------
 ::rtl::OUString ContentProvider::openDoc(const ::vos::ORef<ContentProperties>& _rProp)  throw (::com::sun::star::uno::Exception)
 {
 	OSL_ENSURE(_rProp.isValid(),"No valid content properties!");
 	if(!_rProp->m_bIsOpen)
 	{
-		sal_Char *pFileName = new sal_Char[ODM_FILENAME_MAX];
+		sal_Char szFileName[ODM_FILENAME_MAX];
 		
 		DWORD dwFlag = ODM_MODIFYMODE | ODM_SILENT;
-		ODMSTATUS odm = NODMOpenDoc(getHandle(), dwFlag, const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()), pFileName);
+		ODMSTATUS odm = NODMOpenDoc(getHandle(), dwFlag, const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()), szFileName);
 		switch(odm)
 		{
 			case ODM_E_INUSE:
 				dwFlag = ODM_VIEWMODE;
-				if( NODMOpenDoc(getHandle(), dwFlag, const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()), pFileName) != ODM_SUCCESS)
+				if( NODMOpenDoc(getHandle(), dwFlag, const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()), szFileName) != ODM_SUCCESS)
 					break;
 				// else run through
 			case ODM_SUCCESS:
-				::osl::FileBase::getFileURLFromSystemPath(::rtl::OStringToOUString(rtl::OString(pFileName),RTL_TEXTENCODING_ASCII_US)
+				::osl::FileBase::getFileURLFromSystemPath(::rtl::OStringToOUString(rtl::OString(szFileName),RTL_TEXTENCODING_ASCII_US)
 															,_rProp->m_sFileURL);
 				_rProp->m_bIsOpen = sal_True;
 				break;
 			default:
-				delete pFileName;
 				throw uno::Exception();  // TODO give a more precise error message here
 		}
-
-		delete pFileName;
 	}
 	return _rProp->m_sFileURL;
 }
Index: ucb/source/ucp/odma/odma_provider.hxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_provider.hxx,v
retrieving revision 1.4
diff -p -u -r1.4 odma_provider.hxx
--- ucb/source/ucp/odma/odma_provider.hxx	9 Sep 2005 15:53:43 -0000	1.4
+++ ucb/source/ucp/odma/odma_provider.hxx	6 Nov 2006 00:12:09 -0000
@@ -40,6 +40,8 @@
 #ifndef _UCBHELPER_PROVIDERHELPER_HXX
 #include <ucbhelper/providerhelper.hxx>
 #endif
+#include <tools/prewin.h>
+#include <tools/postwin.h>
 #ifndef ODMA_LIB_HXX
 #include "odma_lib.hxx"
 #endif
@@ -60,7 +62,7 @@ namespace odma {
 // UNO service name for the provider. This name will be used by the UCB to
 // create instances of the provider.
 #define ODMA_CONTENT_PROVIDER_SERVICE_NAME \
-				"com.sun.star.ucb.OdmaContentProvider"
+				"com.sun.star.ucb.ODMAContentProvider"
 //	#define ODMA_CONTENT_PROVIDER_SERVICE_NAME_LENGTH	34
 
 // URL scheme. This is the scheme the provider will be able to create
@@ -150,14 +152,21 @@ public:
 	*/
 	::vos::ORef<ContentProperties> queryContentProperty(const ::rtl::OUString& _sDocumentName);
 
-	/** getContentProperty returns the ContentProperties for the first content with that title
+	/** getContentPropertyWithTitle returns the ContentProperties for the first content with that title
 		@param	_sTitle	the title of the document
 
 		@return	the content properties
 	*/
 	::vos::ORef<ContentProperties> getContentPropertyWithTitle(const ::rtl::OUString& _sTitle) const;
 
-	/** getContentProperty returns the ContentProperties for the first content with that SavedAsName
+	/** getContentPropertyWithDocumentId returns the ContentProperties for the first content with that title
+		@param	_sTitle	the title of the document
+
+		@return	the content properties
+	*/
+	::vos::ORef<ContentProperties> getContentPropertyWithDocumentId(const ::rtl::OUString& _sDocumentId) const;
+
+	/** getContentPropertyWithSavedAsName returns the ContentProperties for the first content with that SavedAsName
 		@param	_sSaveAsName	the SavedAsName of the document
 
 		@return	the content properties
Index: ucb/source/ucp/odma/odma_services.cxx
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/odma_services.cxx,v
retrieving revision 1.5
diff -p -u -r1.5 odma_services.cxx
--- ucb/source/ucp/odma/odma_services.cxx	17 Sep 2006 13:59:05 -0000	1.5
+++ ucb/source/ucp/odma/odma_services.cxx	6 Nov 2006 00:12:09 -0000
@@ -52,9 +52,6 @@
 #ifndef ODMA_PROVIDER_HXX
 #include "odma_provider.hxx"
 #endif
-#ifndef ODMA_LIB_HXX
-#include "odma_lib.hxx"
-#endif
 
 using namespace rtl;
 using namespace com::sun::star::uno;
@@ -102,14 +99,14 @@ static sal_Bool writeInfo( void * pRegis
 
 //=========================================================================
 extern "C" void SAL_CALL component_getImplementationEnvironment(
-	const sal_Char ** ppEnvTypeName, uno_Environment ** ppEnv )
+	const sal_Char ** ppEnvTypeName, uno_Environment ** /* ppEnv */ )
 {
 	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
 }
 
 //=========================================================================
 extern "C" sal_Bool SAL_CALL component_writeInfo(
-	void * pServiceManager, void * pRegistryKey )
+	void * /* pServiceManager */, void * pRegistryKey )
 {
 	return pRegistryKey &&
 
@@ -125,7 +122,7 @@ extern "C" sal_Bool SAL_CALL component_w
 
 //=========================================================================
 extern "C" void * SAL_CALL component_getFactory(
-	const sal_Char * pImplName, void * pServiceManager, void * pRegistryKey )
+	const sal_Char * pImplName, void * pServiceManager, void * /* pRegistryKey */ )
 {
 	void * pRet = 0;
 
@@ -141,10 +138,8 @@ extern "C" void * SAL_CALL component_get
 	if ( ::odma::ContentProvider::getImplementationName_Static().
 				compareToAscii( pImplName ) == 0 )
 	{
-		if(::odma::LoadLibrary())
+		if(::odma::DMSsAvailable())
 			xFactory = ::odma::ContentProvider::createServiceFactory( xSMgr );
-		else
-			OSL_ASSERT(!"Could not load library!");
 	}
 
 	//////////////////////////////////////////////////////////////////////
Index: ucb/source/ucp/odma/ucpodma.xml
===================================================================
RCS file: /cvs/ucb/ucb/ucb/source/ucp/odma/ucpodma.xml,v
retrieving revision 1.3
diff -p -u -r1.3 ucpodma.xml
--- ucb/source/ucp/odma/ucpodma.xml	25 Aug 2003 13:02:22 -0000	1.3
+++ ucb/source/ucp/odma/ucpodma.xml	6 Nov 2006 00:12:09 -0000
@@ -11,7 +11,7 @@
             Ocke Janssen
         </author>
         <name>
-            com.sun.star.comp.ucb.OdmaContentProvider
+            com.sun.star.comp.ucb.ODMAContentProvider
         </name>
         <description>
 	    This component implements a Content Provider for the Universal
dummy line to avoid confusing diff-mode
--- officecfg/registry/data/org/openoffice/ucb/Configuration.xcu	8 Sep 2005 15:07:17 -0000	1.9
+++ officecfg/registry/data/org/openoffice/ucb/Configuration.xcu	13 Mar 2006 11:05:44 -0000
@@ -151,4 +151,15 @@
               </prop>
             </node>
+            <node oor:name="Provider12" oor:op="replace">
+              <prop oor:name="ServiceName">
+                <value>com.sun.star.ucb.ODMAContentProvider</value>
+              </prop>
+              <prop oor:name="URLTemplate">
+                <value>vnd.sun.star.odma</value>
+              </prop>
+              <prop oor:name="Arguments">
+                <value/>
+              </prop>
+            </node>
           </node>
         </node>
dummy line to avoid confusing diff-mode
--- scp2/source/ooo/file_library_ooo.scp	17 Feb 2006 16:52:02 -0000	1.184.2.2
+++ scp2/source/ooo/file_library_ooo.scp	13 Mar 2006 11:07:23 -0000
@@ -2069,4 +2071,6 @@
 SPECIAL_UNO_COMPONENT_LIB_FILE_PATCH(gid_File_Ucpexpand1, ucpexpand1.uno)
 
+SPECIAL_UNO_COMPONENT_LIB_FILE_PATCH(gid_File_Ucpodma1, ucpodma1)
+
 #ifndef SYSTEM_HUNSPELL
 
dummy line to avoid confusing diff-mode
--- desktop/source/app/cmdlineargs.cxx	8 Sep 2005 17:05:40 -0000	1.28
+++ desktop/source/app/cmdlineargs.cxx	13 Mar 2006 12:00:25 -0000
@@ -275,4 +282,13 @@
 					else
 					{
+						if( bOpenEvent || bViewEvent || bForceNewEvent || bForceOpenEvent )
+						{
+							if( ::rtl::OUString(aArgStr).matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM("::ODMA")) )
+							{
+								::rtl::OUString sArg = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("vnd.sun.star.odma:/"));
+								sArg += aArgStr;
+								aArgStr = sArg;
+							}	
+						}
 						// handle this argument as a filename
 						if ( bOpenEvent )
dummy line to avoid confusing diff-mode
--- fpicker/prj/build.lst
+++ fpicker/prj/build.lst
@@ -1,4 +1,5 @@
-fp	fpicker	:	rdbmaker svtools NULL
+fp	fpicker	:	ucb rdbmaker svtools NULL
 fp	fpicker\source\generic				nmake	-	all	fp_generic NULL
 fp	fpicker\source\office				nmake	-	all	fp_office NULL
+fp	fpicker\source\odma				nmake	-	w	fp_odma NULL
 fp	fpicker\source\unx\gnome			nmake	-	u	fp_gnome_filepicker NULL
dummy line to avoid confusing diff-mode
--- fpicker/source/generic/makefile.mk
+++ fpicker/source/generic/makefile.mk
@@ -54,6 +54,7 @@
 SHL1IMPLIB=	i$(TARGET)
 SHL1OBJS=	$(SLOFILES)
 SHL1STDLIBS=\
+	$(ODMA_LIB_LIB) \
 	$(VCLLIB) \
 	$(SVLLIB) \
 	$(CPPUHELPERLIB) \
dummy line to avoid confusing diff-mode
--- fpicker/source/generic/fpicker.cxx
+++ fpicker/source/generic/fpicker.cxx
@@ -51,6 +51,12 @@
 #include "com/sun/star/lang/XMultiComponentFactory.hpp"
 #endif
 
+#ifdef WNT
+#include <tools/prewin.h>
+#include <tools/postwin.h>
+#include <odma_lib.hxx>
+#endif
+
 #ifndef INCLUDED_SVTOOLS_MISCOPT_HXX
 #include "svtools/miscopt.hxx"
 #endif
@@ -75,13 +75,20 @@
  */
 static OUString FilePicker_getSystemPickerServiceName()
 {
+#ifdef UNX
 	OUString aDesktopEnvironment (Application::GetDesktopEnvironment());
 	if (aDesktopEnvironment.equalsIgnoreAsciiCaseAscii ("gnome"))
 		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.GtkFilePicker"));
 	else if (aDesktopEnvironment.equalsIgnoreAsciiCaseAscii ("kde"))
 		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.KDEFilePicker"));
- 	else
-		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.SystemFilePicker"));
+#endif
+#ifdef WNT
+	if (SvtMiscOptions().TryODMADialog() && ::odma::DMSsAvailable()) {
+		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.ODMAFilePicker"));
+	}
+	return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.Win32FilePicker"));
+#endif
+	return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.SystemFilePicker"));
 }
 
 static Reference< css::uno::XInterface > FilePicker_createInstance (
@@ -173,12 +173,18 @@
 static OUString FolderPicker_getSystemPickerServiceName()
 {
 	OUString aDesktopEnvironment (Application::GetDesktopEnvironment());
+#ifdef UNX
 	if (aDesktopEnvironment.equalsIgnoreAsciiCaseAscii ("gnome"))
 		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.GtkFolderPicker"));
 	else if (aDesktopEnvironment.equalsIgnoreAsciiCaseAscii ("kde"))
 		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.KDEFolderPicker"));
-	else
-		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.SystemFolderPicker"));
+#endif
+#ifdef WNT
+	if (SvtMiscOptions().TryODMADialog() && ::odma::DMSsAvailable()) {
+		return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.ODMAFolderPicker"));
+	}
+#endif
+	return OUString (RTL_CONSTASCII_USTRINGPARAM ("com.sun.star.ui.dialogs.SystemFolderPicker"));
 }
 
 static Reference< css::uno::XInterface > FolderPicker_createInstance (
diff -ruN fpicker/source/odma/ODMAFilePicker.cxx fpicker/source/odma/ODMAFilePicker.cxx
--- fpicker/source/odma/ODMAFilePicker.cxx	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/ODMAFilePicker.cxx	2006-11-03 13:31:25.014750000 +0000
@@ -0,0 +1,563 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "ODMAFilePicker.hxx"
+
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_
+#include <com/sun/star/beans/PropertyValue.hpp>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_STRINGPAIR_HPP_
+#include <com/sun/star/beans/StringPair.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_FILEPREVIEWIMAGEFORMATS_HPP_
+#include <com/sun/star/ui/dialogs/FilePreviewImageFormats.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UI_DIALOGS_EXECUTABLEDIALOGRESULTS_HPP_
+#include <com/sun/star/ui/dialogs/ExecutableDialogResults.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UI_DIALOGS_TEMPLATEDESCRIPTION_HPP_
+#include <com/sun/star/ui/dialogs/TemplateDescription.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_XCOMMANDENVIRONMENT_HPP_
+#include <com/sun/star/ucb/XCommandEnvironment.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UNO_ANY_HXX_
+#include <com/sun/star/uno/Any.hxx>
+#endif
+#ifndef _COM_SUN_STAR_UNO_SEQUENCE_HXX_
+#include <com/sun/star/uno/Sequence.hxx>
+#endif
+
+#ifndef _COMPHELPER_SEQUENCE_HXX_
+#include <comphelper/sequence.hxx>
+#endif
+#ifndef _CPPUHELPER_TYPEPROVIDER_HXX_
+#include <cppuhelper/typeprovider.hxx>
+#endif
+#ifndef _UCBHELPER_CONTENT_HXX
+#include <ucbhelper/content.hxx>
+#endif
+#ifndef _UNOTOOLS_UCBHELPER_HXX
+#include <unotools/ucbhelper.hxx>
+#endif
+
+#ifndef ODMA_LIB_HXX
+#include <tools/prewin.h>
+#include <tools/postwin.h>
+#include <odma_lib.hxx>
+#endif
+
+// using ----------------------------------------------------------------
+
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::ui::dialogs;
+using namespace ::com::sun::star::ucb;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::util;
+using namespace ::utl;
+
+//------------------------------------------------------------------------------------
+// class ODMAFilePicker
+//------------------------------------------------------------------------------------
+ODMAFilePicker::ODMAFilePicker( const Reference < XMultiServiceFactory >& xFactory ) :
+	cppu::WeakComponentImplHelper9<
+	  XFilterManager, 
+	  XFilterGroupManager,
+	  XFilePickerControlAccess,
+	  XFilePickerNotifier,
+	  XFilePreview,
+	  XInitialization,
+	  XCancellable,
+	  XEventListener,
+	  XServiceInfo>( m_rbHelperMtx ),
+	m_bMultiSelectionMode( sal_False ),
+	m_aDefaultName( ),
+	m_aFiles( ),
+	m_nDialogKind( OPEN )
+{
+	m_bUseDMS = ::odma::DMSsAvailable();
+	m_xSystemFilePicker = xFactory->createInstance(
+		::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.Win32FilePicker" ) );
+}
+
+// XExecutableDialog functions
+
+void SAL_CALL ODMAFilePicker::setTitle( const ::rtl::OUString& aTitle )
+	throw (RuntimeException)
+{
+	Reference< XExecutableDialog > xExecutableDialog( m_xSystemFilePicker, UNO_QUERY );
+	xExecutableDialog->setTitle( aTitle);
+}
+
+sal_Int16 SAL_CALL ODMAFilePicker::execute( )
+	throw (RuntimeException)
+{
+	ODMSTATUS status;
+	ODMHANDLE handle;
+	WORD count = 0;
+	DWORD flags;
+
+	status = NODMRegisterApp( &handle, ODM_API_VERSION, "sodma", NULL, NULL );
+	if (status == ODM_SUCCESS)
+	{
+		if (m_nDialogKind == OPEN)
+		{
+			const int MAXDOCS = 10;
+			char docids[ODM_DOCID_MAX*MAXDOCS+1];
+			WORD docidslen = sizeof( docids );
+
+			flags = 0;
+			if (m_bMultiSelectionMode)
+				count = MAXDOCS;
+			else
+				count = 1;
+			status = NODMSelectDocEx( handle, docids, &docidslen, &count, &flags, NULL );
+			if (status == ODM_SUCCESS)
+			{
+				// GroupWise doesn't set docidslen or count, so
+				// calculate number of document IDs manually 
+				char *p = docids;
+				count = 0;
+				while (*p) {
+					count++;
+					p += strlen( p ) + 1;
+				}
+			}
+			else if (status == ODM_E_NOSUPPORT)
+			{
+				status = NODMSelectDoc( handle, docids, &flags );
+				if (status == ODM_SUCCESS)
+					count = 1;
+			}
+			NODMUnRegisterApp( handle );
+			if (status == ODM_SUCCESS)
+			{
+				rtl::OUString *strings = new rtl::OUString[count];
+				int i;
+				char *p = docids;
+				
+				for (i = 0; i < count; i++) {
+					// Insane API... the first element is a full URI, the rest
+					// are just the "basenames" in the same "directory".
+					if (i == 0)
+						strings[0] = rtl::OUString::createFromAscii( "vnd.sun.star.odma:/" ) + rtl::OUString::createFromAscii( p );
+					else
+						strings[i] = rtl::OUString::createFromAscii( p );
+					p += strlen( p );
+				}
+
+				m_aFiles = Sequence< rtl::OUString >( strings, count );
+				delete[] strings;
+				return ExecutableDialogResults::OK;
+			}
+		}
+		else /* m_nDialogKind == SAVE */
+		{
+			char newdocid[ODM_DOCID_MAX+1];
+			
+			if (m_aDefaultName.getLength() == 0 ||
+				!m_aDefaultName.matchIgnoreAsciiCaseAsciiL( "::ODMA\\", 7, 0 ))
+			{
+				char tempdocid[ODM_DOCID_MAX+1];
+
+				status = NODMNewDoc( handle, tempdocid, ODM_SILENT, NULL, NULL );
+				if (status == ODM_SUCCESS)
+					status = NODMSaveAs( handle, tempdocid, newdocid, NULL, NULL, NULL );
+			}
+			else
+			{
+				rtl::OString sDefaultName = rtl::OUStringToOString( m_aDefaultName, RTL_TEXTENCODING_ASCII_US );
+				status = NODMSaveAs( handle,
+									 const_cast<sal_Char*>( sDefaultName.getStr() ),
+									 newdocid, NULL, NULL, NULL );
+			}
+
+			NODMUnRegisterApp( handle );
+			if (status == ODM_SUCCESS)
+			{
+				rtl::OUString s( rtl::OUString::createFromAscii( "vnd.sun.star.odma:/" ) +
+								 rtl::OUString::createFromAscii( newdocid ) );
+				// Create a Content for the odma URL so that
+				// odma::ContentProvider will learn about the DOCID we
+				// just created.
+				ucb::Content content( s, Reference< XCommandEnvironment >() );
+				m_aFiles = Sequence< rtl::OUString >( &s, 1 );
+				return ExecutableDialogResults::OK;
+			}
+		}
+	}
+	if (status == ODM_E_APPSELECT)
+	{
+		m_bUseDMS = sal_False;
+
+		Reference< XExecutableDialog > xExecutableDialog( m_xSystemFilePicker, UNO_QUERY );
+		return xExecutableDialog->execute();
+	}
+
+	// Fallback
+	return ExecutableDialogResults::CANCEL;
+}
+
+// XFilePicker functions
+
+void SAL_CALL ODMAFilePicker::setMultiSelectionMode( sal_Bool bMode )
+	throw( RuntimeException )
+{
+	m_bMultiSelectionMode = bMode;
+
+	Reference< XFilePicker > xFilePicker( m_xSystemFilePicker, UNO_QUERY );
+	xFilePicker->setMultiSelectionMode( bMode );
+}
+
+void SAL_CALL ODMAFilePicker::setDefaultName( const rtl::OUString& aName )
+	throw( RuntimeException )
+{
+	// When editing a document from DMS, and doing Save As, this is
+	// called twice, first with the complete DOCID, the second time
+	// with the "extension" removed. Of course, this is bogus, as
+	// DOCIDs should be treated as opaque strings, they don't have
+	// "extensions".
+
+	// In the GroupWise case a DOCID is like
+	// ::ODMA\GRPWISE\FOO1.BAR.FOO-Bla_bla:12345.12 where the final
+	// dot separates the version number, not an "extension".
+	//
+	// So ignore the second call.
+	//
+	// The second call without "extension" is done if the
+	// XFilePickerControlAccess is set to have auto-extension turned
+	// on. (See sfx2/source/dialog/filedlghelper.cxx:
+	// FileDialogHelper_Impl::implInitializeFileName().) Thus we could
+	// alternatively make sure that a getValue call to get
+	// ExtendedFilePickerElementIds::CHECKBOX_AUTOEXTENSION returns
+	// false. But that might be hard as we don't know in advance
+	// whether the user will click the "use application dialog"
+	// button. If so, we indeed do use auto-extensions.
+	//
+	// Yes, this is ugly, relying on knowing details on how this
+	// function will be called.
+
+	if ( m_aDefaultName.getLength() == 0 )
+		m_aDefaultName = aName;
+
+	Reference< XFilePicker > xFilePicker( m_xSystemFilePicker, UNO_QUERY );
+	xFilePicker->setDefaultName( aName );
+}
+
+void SAL_CALL ODMAFilePicker::setDisplayDirectory( const rtl::OUString& aDirectory )
+    throw( IllegalArgumentException, RuntimeException )
+{
+	m_aDisplayDirectory = aDirectory;
+
+	Reference< XFilePicker > xFilePicker( m_xSystemFilePicker, UNO_QUERY );
+	xFilePicker->setDisplayDirectory( aDirectory );
+}
+
+rtl::OUString SAL_CALL ODMAFilePicker::getDisplayDirectory( )
+	throw( RuntimeException )
+{
+	if (m_bUseDMS)
+		return m_aDisplayDirectory;
+
+	Reference< XFilePicker > xFilePicker( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePicker->getDisplayDirectory();
+}
+
+Sequence< rtl::OUString > SAL_CALL ODMAFilePicker::getFiles( )
+	throw( RuntimeException )
+{
+	if (m_bUseDMS)
+		return m_aFiles;
+
+	Reference< XFilePicker > xFilePicker( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePicker->getFiles();
+}
+
+// XFilePickerControlAccess functions
+
+void SAL_CALL ODMAFilePicker::setValue( sal_Int16 nElementID,
+										sal_Int16 nControlAction,
+										const Any& rValue )
+    throw( RuntimeException )
+{
+	Reference< XFilePickerControlAccess > xFilePickerControlAccess( m_xSystemFilePicker, UNO_QUERY );
+	xFilePickerControlAccess->setValue( nElementID, nControlAction, rValue );
+}
+
+Any SAL_CALL ODMAFilePicker::getValue( sal_Int16 nElementID, sal_Int16 nControlAction )
+    throw( RuntimeException )
+{
+	Reference< XFilePickerControlAccess > xFilePickerControlAccess( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePickerControlAccess->getValue( nElementID, nControlAction );
+}
+
+void SAL_CALL ODMAFilePicker::setLabel( sal_Int16 nLabelID, const rtl::OUString& rValue )
+    throw ( RuntimeException )
+{
+	Reference< XFilePickerControlAccess > xFilePickerControlAccess( m_xSystemFilePicker, UNO_QUERY );
+	xFilePickerControlAccess->setLabel( nLabelID, rValue );
+}
+
+rtl::OUString SAL_CALL ODMAFilePicker::getLabel( sal_Int16 nLabelID )
+    throw ( RuntimeException )
+{
+	Reference< XFilePickerControlAccess > xFilePickerControlAccess( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePickerControlAccess->getLabel( nLabelID );
+}
+
+void SAL_CALL ODMAFilePicker::enableControl( sal_Int16 nElementID, sal_Bool bEnable )
+    throw( RuntimeException )
+{
+	Reference< XFilePickerControlAccess > xFilePickerControlAccess( m_xSystemFilePicker, UNO_QUERY );
+	xFilePickerControlAccess->enableControl( nElementID, bEnable );
+}
+
+// XFilePickerNotifier functions
+
+void SAL_CALL ODMAFilePicker::addFilePickerListener( const Reference< XFilePickerListener >& xListener )
+	throw ( RuntimeException )
+{
+	Reference< XFilePickerNotifier > xFilePickerNotifier( m_xSystemFilePicker, UNO_QUERY );
+	xFilePickerNotifier->addFilePickerListener( xListener );
+}
+
+void SAL_CALL ODMAFilePicker::removeFilePickerListener( const Reference< XFilePickerListener >& xListener )
+	throw ( RuntimeException )
+{
+	Reference< XFilePickerNotifier > xFilePickerNotifier( m_xSystemFilePicker, UNO_QUERY );
+	xFilePickerNotifier->removeFilePickerListener( xListener );
+}
+
+// XFilePreview functions
+
+Sequence< sal_Int16 > SAL_CALL ODMAFilePicker::getSupportedImageFormats( )
+    throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->getSupportedImageFormats();
+}
+
+sal_Int32 SAL_CALL ODMAFilePicker::getTargetColorDepth( )
+	throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->getTargetColorDepth();
+}
+
+sal_Int32 SAL_CALL ODMAFilePicker::getAvailableWidth( )
+	throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->getAvailableWidth();
+}
+
+sal_Int32 SAL_CALL ODMAFilePicker::getAvailableHeight( )
+	throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->getAvailableHeight();
+}
+
+void SAL_CALL ODMAFilePicker::setImage( sal_Int16 aImageFormat, const Any& rImage )
+    throw ( IllegalArgumentException, RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	xFilePreview->setImage( aImageFormat, rImage);
+}
+
+sal_Bool SAL_CALL ODMAFilePicker::setShowState( sal_Bool bShowState )
+    throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->setShowState( bShowState);
+}
+
+sal_Bool SAL_CALL ODMAFilePicker::getShowState( )
+	throw ( RuntimeException )
+{
+	Reference< XFilePreview > xFilePreview( m_xSystemFilePicker, UNO_QUERY );
+	return xFilePreview->getShowState();
+}
+
+// XFilterGroupManager functions
+
+void SAL_CALL ODMAFilePicker::appendFilterGroup( const ::rtl::OUString& sGroupTitle,
+												 const Sequence< StringPair >& aFilters )
+	throw ( IllegalArgumentException, RuntimeException )
+{
+	Reference< XFilterGroupManager > xFilterGroupManager( m_xSystemFilePicker, UNO_QUERY );
+	xFilterGroupManager->appendFilterGroup( sGroupTitle, aFilters );
+}
+
+// XFilterManager functions
+
+void SAL_CALL ODMAFilePicker::appendFilter( const rtl::OUString& aTitle,
+                                           const rtl::OUString& aFilter )
+    throw( IllegalArgumentException, RuntimeException )
+{
+	Reference< XFilterManager > xFilterManager( m_xSystemFilePicker, UNO_QUERY );
+	xFilterManager->appendFilter( aTitle, aFilter );
+}
+
+void SAL_CALL ODMAFilePicker::setCurrentFilter( const rtl::OUString& aTitle )
+    throw( IllegalArgumentException, RuntimeException )
+{
+	Reference< XFilterManager > xFilterManager( m_xSystemFilePicker, UNO_QUERY );
+	xFilterManager->setCurrentFilter( aTitle );
+}
+
+rtl::OUString SAL_CALL ODMAFilePicker::getCurrentFilter( )
+    throw( RuntimeException )
+{
+	Reference< XFilterManager > xFilterManager( m_xSystemFilePicker, UNO_QUERY );
+	return xFilterManager->getCurrentFilter();
+}
+
+// XInitialization functions
+
+void SAL_CALL ODMAFilePicker::initialize( const Sequence< Any >& aArguments )
+	throw ( Exception, RuntimeException )
+{
+	if (aArguments.getLength( ) > 0)
+	{
+		Any aAny = aArguments[0];
+
+		if ( (aAny.getValueType() == ::getCppuType((sal_Int16*)0)) ||
+			 (aAny.getValueType() == ::getCppuType((sal_Int8*)0)) )
+		{
+			sal_Int16 nTemplateId = -1;
+			aAny >>= nTemplateId;
+
+			switch (nTemplateId) {
+			case TemplateDescription::FILEOPEN_SIMPLE:
+			case TemplateDescription::FILEOPEN_LINK_PREVIEW_IMAGE_TEMPLATE:
+			case TemplateDescription::FILEOPEN_PLAY:
+			case TemplateDescription::FILEOPEN_READONLY_VERSION:
+			case TemplateDescription::FILEOPEN_LINK_PREVIEW:
+				m_nDialogKind = OPEN;
+				break;
+			default:
+				m_nDialogKind = SAVE;
+			}
+		}
+	}
+
+	Reference< XInitialization > xInitialization( m_xSystemFilePicker, UNO_QUERY );
+	xInitialization->initialize( aArguments );
+}
+
+// XCancellable functions
+
+void SAL_CALL ODMAFilePicker::cancel( )
+	throw( ::com::sun::star::uno::RuntimeException )
+{
+	Reference< XCancellable > xCancellable( m_xSystemFilePicker, UNO_QUERY );
+	xCancellable->cancel();
+}
+
+// XEventListener functions
+
+void SAL_CALL ODMAFilePicker::disposing( const ::com::sun::star::lang::EventObject& aEvent )
+	throw( RuntimeException )
+{
+	Reference< XEventListener > xEventListener( m_xSystemFilePicker, UNO_QUERY );
+	xEventListener->disposing( aEvent );
+}
+
+// XServiceInfo functions
+
+rtl::OUString SAL_CALL ODMAFilePicker::getImplementationName( )
+	throw( RuntimeException )
+{
+	return impl_getStaticImplementationName();
+}
+
+sal_Bool SAL_CALL ODMAFilePicker::supportsService( const rtl::OUString& sServiceName )
+	throw( RuntimeException )
+{
+    Sequence< rtl::OUString > seqServiceNames = getSupportedServiceNames();
+    const rtl::OUString* pArray = seqServiceNames.getConstArray();
+    for ( sal_Int32 i = 0; i < seqServiceNames.getLength(); i++ )
+	{
+        if ( sServiceName == pArray[i] )
+		{
+            return sal_True ;
+		}
+	}
+    return sal_False ;
+}
+
+Sequence< rtl::OUString > SAL_CALL ODMAFilePicker::getSupportedServiceNames( )
+	throw( RuntimeException )
+{
+	return impl_getStaticSupportedServiceNames();
+}
+
+Sequence< rtl::OUString > ODMAFilePicker::impl_getStaticSupportedServiceNames( )
+{
+    Sequence< rtl::OUString > seqServiceNames( 3 );
+    rtl::OUString* pArray = seqServiceNames.getArray();
+    pArray[0] = rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.FilePicker" );
+    pArray[1] = rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.ODMAFilePicker" );
+
+	// Super-ugly, but check the function sal_Bool
+	// lcl_isSystemFilePicker( const Reference< XFilePicker >& ) in
+	// sfx2/source/dialog/filedlghelper.cxx 
+
+    // Lovely undocumented coupling right across abstraction layers,
+    // isn't it?  If we don't claim to implement this "service" (which
+    // is not defined in any IDL file, btw), we get hangs.
+
+    pArray[2] = rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.SystemFilePicker" );
+    return seqServiceNames ;
+}
+
+rtl::OUString ODMAFilePicker::impl_getStaticImplementationName( )
+{
+    return rtl::OUString::createFromAscii( "com.sun.star.svtools.ODMAFilePicker" );
+}
+
+Reference< XInterface > SAL_CALL ODMAFilePicker::impl_createInstance(
+	const Reference< XComponentContext >& rxContext)
+	throw( Exception )
+{
+	Reference< XMultiServiceFactory > xServiceManager (rxContext->getServiceManager(), UNO_QUERY_THROW);
+	return Reference< XInterface >( *new ODMAFilePicker( xServiceManager ) );
+}
diff -ruN fpicker/source/odma/ODMAFilePicker.hxx fpicker/source/odma/ODMAFilePicker.hxx
--- fpicker/source/odma/ODMAFilePicker.hxx	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/ODMAFilePicker.hxx	2006-11-02 01:39:33.483549300 +0000
@@ -0,0 +1,242 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef INCLUDED_ODMA_FILEPICKER_HXX
+#define INCLUDED_ODMA_FILEPICKER_HXX
+
+#ifndef _CPPUHELPER_COMPBASE9_HXX_
+#include <cppuhelper/compbase9.hxx>
+#endif
+
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_XFILEPICKERCONTROLACCESS_HPP_
+#include <com/sun/star/ui/dialogs/XFilePickerControlAccess.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_XFILEPICKERNOTIFIER_HPP_
+#include <com/sun/star/ui/dialogs/XFilePickerNotifier.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_XFILEPREVIEW_HPP_
+#include <com/sun/star/ui/dialogs/XFilePreview.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_XFILTERMANAGER_HPP_
+#include <com/sun/star/ui/dialogs/XFilterManager.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UI_DIALOGS_XFILTERGROUPMANAGER_HPP_
+#include <com/sun/star/ui/dialogs/XFilterGroupManager.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UI_DIALOGS_XFILEPICKERLISTENER_HPP_
+#include <com/sun/star/ui/dialogs/XFilePickerListener.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UTIL_XCANCELLABLE_HPP_
+#include <com/sun/star/util/XCancellable.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UNO_XCOMPONENT_CONTEXT_HPP_
+#include <com/sun/star/uno/XComponentContext.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_LANG_XINITIALIZATION_HPP_
+#include <com/sun/star/lang/XInitialization.hpp>
+#endif
+
+// class ODMAFilePicker ---------------------------------------------------
+
+class ODMAFilePicker :
+	public cppu::WeakComponentImplHelper9<
+	  ::com::sun::star::ui::dialogs::XFilterManager,
+	  ::com::sun::star::ui::dialogs::XFilterGroupManager,
+	  ::com::sun::star::ui::dialogs::XFilePickerControlAccess,
+	  ::com::sun::star::ui::dialogs::XFilePickerNotifier,
+	  ::com::sun::star::ui::dialogs::XFilePreview,
+	  ::com::sun::star::lang::XInitialization,
+      ::com::sun::star::util::XCancellable,
+	  ::com::sun::star::lang::XEventListener,
+	  ::com::sun::star::lang::XServiceInfo >		
+{
+private:
+	sal_Bool m_bUseDMS;
+	sal_Bool m_bMultiSelectionMode;
+	rtl::OUString m_aDefaultName;
+	rtl::OUString m_aDisplayDirectory;
+	::com::sun::star::uno::Sequence< rtl::OUString > m_aFiles;
+	enum { OPEN, SAVE } m_nDialogKind;
+
+	::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > m_xSystemFilePicker;
+
+protected:
+	::osl::Mutex m_rbHelperMtx;
+
+public:
+
+	ODMAFilePicker( const ::com::sun::star::uno::Reference < ::com::sun::star::lang::XMultiServiceFactory >& xFactory );
+
+	// XFilterManager functions
+
+	virtual void SAL_CALL appendFilter( const ::rtl::OUString& aTitle,
+										const ::rtl::OUString& aFilter )
+		throw( ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException );
+
+	virtual void SAL_CALL setCurrentFilter( const ::rtl::OUString& aTitle )
+		throw( ::com::sun::star::lang::IllegalArgumentException,
+			   ::com::sun::star::uno::RuntimeException );
+
+	virtual ::rtl::OUString SAL_CALL getCurrentFilter( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	// XFilterGroupManager functions
+
+	virtual void SAL_CALL appendFilterGroup( const ::rtl::OUString& sGroupTitle,
+											 const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::StringPair >& aFilters )
+		throw (::com::sun::star::lang::IllegalArgumentException,
+			   ::com::sun::star::uno::RuntimeException );
+
+	// XFilePickerControlAccess functions
+
+	virtual void SAL_CALL setValue( sal_Int16 nControlID,
+									sal_Int16 nControlAction,
+									const ::com::sun::star::uno::Any& aValue )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	virtual ::com::sun::star::uno::Any SAL_CALL getValue( sal_Int16 nControlID,
+											 sal_Int16 nControlAction )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual void SAL_CALL setLabel( sal_Int16 nControlID,
+									const ::rtl::OUString& aValue )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual ::rtl::OUString SAL_CALL getLabel( sal_Int16 nControlID )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+	virtual void SAL_CALL enableControl( sal_Int16 nControlID,
+										 sal_Bool bEnable )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	// XFilePicker functions
+
+	virtual void SAL_CALL setMultiSelectionMode( sal_Bool bMode )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	virtual void SAL_CALL setDefaultName( const ::rtl::OUString& aName )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	virtual void SAL_CALL setDisplayDirectory( const ::rtl::OUString& aDirectory )
+		throw( ::com::sun::star::lang::IllegalArgumentException,
+			   ::com::sun::star::uno::RuntimeException );
+
+	virtual ::rtl::OUString SAL_CALL getDisplayDirectory( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getFiles( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	// XExecutableDialog functions
+
+	virtual void SAL_CALL setTitle( const ::rtl::OUString& aTitle )
+		throw (::com::sun::star::uno::RuntimeException);
+
+	virtual sal_Int16 SAL_CALL execute(  )
+		throw (::com::sun::star::uno::RuntimeException);
+
+	// XFilePickerNotifier functions
+
+    virtual void SAL_CALL addFilePickerListener( const ::com::sun::star::uno::Reference< ::com::sun::star::ui::dialogs::XFilePickerListener >& xListener )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual void SAL_CALL removeFilePickerListener( const ::com::sun::star::uno::Reference< ::com::sun::star::ui::dialogs::XFilePickerListener >& xListener )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+	// XFilePreview functions
+
+    virtual ::com::sun::star::uno::Sequence< sal_Int16 > SAL_CALL getSupportedImageFormats( )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Int32 SAL_CALL getTargetColorDepth( )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Int32 SAL_CALL getAvailableWidth( )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Int32 SAL_CALL getAvailableHeight( )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual void SAL_CALL setImage( sal_Int16 aImageFormat,
+									const ::com::sun::star::uno::Any& aImage )
+		throw ( ::com::sun::star::lang::IllegalArgumentException,
+				::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Bool SAL_CALL setShowState( sal_Bool bShowState )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Bool SAL_CALL getShowState( )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+	// XInitialization functions
+
+    virtual void SAL_CALL initialize( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aArguments )
+		throw ( ::com::sun::star::uno::Exception, ::com::sun::star::uno::RuntimeException );
+
+	// XCancellable functions
+
+	virtual void SAL_CALL cancel( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	// XEventListener functions
+
+	using cppu::WeakComponentImplHelperBase::disposing;
+	virtual void SAL_CALL disposing( const ::com::sun::star::lang::EventObject& aEvent ) 
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	// XServiceInfo functions
+
+    virtual ::rtl::OUString SAL_CALL getImplementationName( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& sServiceName )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	/* Helper for XServiceInfo */
+	static ::com::sun::star::uno::Sequence< ::rtl::OUString > impl_getStaticSupportedServiceNames( );
+	static ::rtl::OUString impl_getStaticImplementationName( );
+
+    /* Helper for registry */
+	static ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL impl_createInstance ( const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XComponentContext >& rxContext )
+		throw( ::com::sun::star::uno::Exception );
+};
+
+#endif // INCLUDED_ODMA_FILEPICKER_HXX
diff -ruN fpicker/source/odma/ODMAFolderPicker.cxx fpicker/source/odma/ODMAFolderPicker.cxx
--- fpicker/source/odma/ODMAFolderPicker.cxx	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/ODMAFolderPicker.cxx	2006-10-30 01:09:51.281250000 +0000
@@ -0,0 +1,200 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "ODMAFolderPicker.hxx"
+
+#define _SVSTDARR_STRINGSDTOR
+#include "svtools/svstdarr.hxx"
+
+#ifndef  _COM_SUN_STAR_CONTAINER_XCONTENTENUMERATIONACCESS_HPP_
+#include <com/sun/star/container/XContentEnumerationAccess.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_CONTAINER_XSET_HPP_
+#include <com/sun/star/container/XSet.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_UNO_ANY_HXX_
+#include <com/sun/star/uno/Any.hxx>
+#endif
+#ifndef  _CPPUHELPER_FACTORY_HXX_
+#include <cppuhelper/factory.hxx>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_XPROPERTYSET_HPP_
+#include <com/sun/star/beans/XPropertySet.hpp>
+#endif
+
+#ifndef INCLUDED_SVTOOLS_PATHOPTIONS_HXX
+#include <svtools/pathoptions.hxx>
+#endif
+
+#ifndef ODMA_LIB_HXX
+#include <tools/prewin.h>
+#include <odma_lib.hxx>
+#include <tools/postwin.h>
+#endif
+
+// using ----------------------------------------------------------------
+
+using namespace ::com::sun::star::beans;
+using namespace ::com::sun::star::container;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::uno;
+
+//------------------------------------------------------------------------------------
+// class ODMAFolderPicker
+//------------------------------------------------------------------------------------
+
+//------------------------------------------------------------------------------------
+ODMAFolderPicker::ODMAFolderPicker( const Reference < XMultiServiceFactory >& xFactory ) :
+	cppu::WeakComponentImplHelper2<
+	  XFolderPicker,
+	  XServiceInfo>( m_rbHelperMtx ),
+	m_bUseDMS( sal_False )
+{
+	m_xInterface = xFactory->createInstance(
+		::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.SystemFolderPicker" ) );
+}
+
+// XExecutableDialog functions
+
+void SAL_CALL ODMAFolderPicker::setTitle( const ::rtl::OUString& _rTitle ) throw (RuntimeException)
+{
+	if (m_bUseDMS)
+		return;
+
+	Reference< XExecutableDialog > xExecutableDialog( m_xInterface, UNO_QUERY );
+	xExecutableDialog->setTitle( _rTitle);
+}
+
+sal_Int16 SAL_CALL ODMAFolderPicker::execute( )
+	throw (RuntimeException)
+{
+	if (m_bUseDMS)
+		throw new RuntimeException( );
+
+	Reference< XExecutableDialog > xExecutableDialog( m_xInterface, UNO_QUERY );
+	return xExecutableDialog->execute();
+}
+
+// XFolderPicker functions
+
+void SAL_CALL ODMAFolderPicker::setDisplayDirectory( const ::rtl::OUString& aDirectory )
+    throw( IllegalArgumentException, RuntimeException )
+{
+	if (m_bUseDMS)
+		return;
+
+	Reference< XFolderPicker > xFolderPicker( m_xInterface, UNO_QUERY );
+	xFolderPicker->setDisplayDirectory( aDirectory );
+}
+
+::rtl::OUString SAL_CALL ODMAFolderPicker::getDisplayDirectory( )
+	throw( RuntimeException )
+{
+	if (m_bUseDMS)
+		return rtl::OUString();
+
+	Reference< XFolderPicker > xFolderPicker( m_xInterface, UNO_QUERY );
+	return xFolderPicker->getDisplayDirectory();
+}
+
+::rtl::OUString SAL_CALL ODMAFolderPicker::getDirectory( )
+	throw( RuntimeException )
+{
+	if (m_bUseDMS)
+		return rtl::OUString();
+
+	Reference< XFolderPicker > xFolderPicker( m_xInterface, UNO_QUERY );
+	return xFolderPicker->getDirectory();
+}
+
+void SAL_CALL ODMAFolderPicker::setDescription( const ::rtl::OUString& aDescription )
+    throw( RuntimeException )
+{
+	if (m_bUseDMS)
+		return;
+
+	Reference< XFolderPicker > xFolderPicker( m_xInterface, UNO_QUERY );
+	xFolderPicker->setDescription( aDescription );
+}
+
+// XServiceInfo
+
+::rtl::OUString SAL_CALL ODMAFolderPicker::getImplementationName( )
+	throw( RuntimeException )
+{
+	return impl_getStaticImplementationName();
+}
+
+sal_Bool SAL_CALL ODMAFolderPicker::supportsService( const ::rtl::OUString& sServiceName )
+	throw( RuntimeException )
+{
+    Sequence< ::rtl::OUString > seqServiceNames = getSupportedServiceNames();
+    const ::rtl::OUString* pArray = seqServiceNames.getConstArray();
+    for ( sal_Int32 i = 0; i < seqServiceNames.getLength(); i++ )
+	{
+        if ( sServiceName == pArray[i] )
+		{
+            return sal_True ;
+		}
+	}
+    return sal_False ;
+}
+
+Sequence< ::rtl::OUString > SAL_CALL ODMAFolderPicker::getSupportedServiceNames()
+	throw( RuntimeException )
+{
+	return impl_getStaticSupportedServiceNames();
+}
+
+Sequence< ::rtl::OUString > ODMAFolderPicker::impl_getStaticSupportedServiceNames( )
+{
+    Sequence< ::rtl::OUString > seqServiceNames( 2 );
+    ::rtl::OUString* pArray = seqServiceNames.getArray();
+    pArray[0] = ::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.FolderPicker" );
+    pArray[1] = ::rtl::OUString::createFromAscii( "com.sun.star.ui.dialogs.ODMAFolderPicker" );
+    return seqServiceNames ;
+}
+
+::rtl::OUString ODMAFolderPicker::impl_getStaticImplementationName( )
+{
+    return ::rtl::OUString::createFromAscii( "com.sun.star.svtools.ODMAFolderPicker" );
+}
+
+Reference< XInterface > SAL_CALL ODMAFolderPicker::impl_createInstance( const Reference< XComponentContext >& rxContext )
+    throw( Exception )
+{
+	Reference< XMultiServiceFactory > xServiceManager (rxContext->getServiceManager(), UNO_QUERY_THROW);
+	return Reference< XInterface >( *new ODMAFolderPicker( xServiceManager ) );
+}
diff -ruN fpicker/source/odma/ODMAFolderPicker.hxx fpicker/source/odma/ODMAFolderPicker.hxx
--- fpicker/source/odma/ODMAFolderPicker.hxx	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/ODMAFolderPicker.hxx	2006-10-26 22:36:34.718125000 +0000
@@ -0,0 +1,118 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef INCLUDED_ODMA_FOLDERPICKER_HXX
+#define INCLUDED_ODMA_FOLDERPICKER_HXX
+
+#ifndef _CPPUHELPER_COMPBASE2_HXX_
+#include <cppuhelper/compbase2.hxx>
+#endif
+
+#ifndef  _COM_SUN_STAR_UI_DIALOGS_XFOLDERPICKER_HPP_
+#include <com/sun/star/ui/dialogs/XFolderPicker.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#endif
+#ifndef  _COM_SUN_STAR_LANG_XSINGLESERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XSingleServiceFactory.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_DISPOSEDEXCEPTION_HPP_
+#include <com/sun/star/lang/DisposedException.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UNO_XCOMPONENTCONTEXT_HPP_
+#include <com/sun/star/uno/XComponentContext.hpp>
+#endif
+
+// class ODMAFolderPicker ---------------------------------------------------
+
+class ODMAFolderPicker :
+	public cppu::WeakComponentImplHelper2<
+	  ::com::sun::star::ui::dialogs::XFolderPicker,	
+	  ::com::sun::star::lang::XServiceInfo >
+{
+private:
+	sal_Bool m_bUseDMS;
+
+protected:
+	::osl::Mutex m_rbHelperMtx;
+
+	::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > m_xInterface;
+
+public:
+	ODMAFolderPicker( const ::com::sun::star::uno::Reference < ::com::sun::star::lang::XMultiServiceFactory >& xFactory );
+
+	// XFolderPicker functions
+
+	virtual void SAL_CALL setDisplayDirectory( const ::rtl::OUString& aDirectory )
+		throw( ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException );
+
+	virtual ::rtl::OUString SAL_CALL getDisplayDirectory( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual ::rtl::OUString SAL_CALL getDirectory( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual void SAL_CALL setDescription( const ::rtl::OUString& aDescription )
+		throw ( ::com::sun::star::uno::RuntimeException );
+
+	// XExecutableDialog functions
+
+	virtual void SAL_CALL setTitle( const ::rtl::OUString& _rTitle )
+		throw (::com::sun::star::uno::RuntimeException);
+
+	virtual sal_Int16 SAL_CALL execute(  )
+		throw (::com::sun::star::uno::RuntimeException);
+
+	// XServiceInfo functions
+
+    virtual ::rtl::OUString SAL_CALL getImplementationName( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& sServiceName )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+    virtual com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames( )
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	/* Helper for XServiceInfo */
+	static com::sun::star::uno::Sequence< ::rtl::OUString > impl_getStaticSupportedServiceNames( );
+	static ::rtl::OUString impl_getStaticImplementationName( );
+
+	/* Helper for registry */
+	static ::com::sun::star::uno::Reference< com::sun::star::uno::XInterface > SAL_CALL impl_createInstance ( const ::com::sun::star::uno::Reference< com::sun::star::uno::XComponentContext >& rxContext )
+		throw( com::sun::star::uno::Exception );
+};
+
+#endif // INCLUDED_ODMA_FOLDERPICKER_HXX
diff -ruN fpicker/source/odma/exports.map fpicker/source/odma/exports.map
--- fpicker/source/odma/exports.map	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/exports.map	2006-10-25 20:34:28.536983200 +0000
@@ -0,0 +1,8 @@
+UDK_3_0_0 {
+    global:
+		component_getImplementationEnvironment;
+		component_writeInfo;
+		component_getFactory;
+	local:
+		*;
+};
diff -ruN fpicker/source/odma/fps_odma.cxx fpicker/source/odma/fps_odma.cxx
--- fpicker/source/odma/fps_odma.cxx	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/fps_odma.cxx	2006-10-25 01:19:43.329875000 +0000
@@ -0,0 +1,86 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SAL_TYPES_H_
+#include "sal/types.h"
+#endif
+
+#ifndef _CPPUHELPER_IMPLEMENTATIONENTRY_HXX_
+#include "cppuhelper/implementationentry.hxx"
+#endif
+
+#include "ODMAFilePicker.hxx"
+#include "ODMAFolderPicker.hxx"
+
+static cppu::ImplementationEntry g_entries[] =
+{
+	{
+		ODMAFilePicker::impl_createInstance,
+		ODMAFilePicker::impl_getStaticImplementationName,
+		ODMAFilePicker::impl_getStaticSupportedServiceNames,
+		cppu::createSingleComponentFactory, 0, 0
+	},
+	{
+		ODMAFolderPicker::impl_createInstance,
+		ODMAFolderPicker::impl_getStaticImplementationName,
+		ODMAFolderPicker::impl_getStaticSupportedServiceNames,
+		cppu::createSingleComponentFactory, 0, 0
+	},
+	{ 0, 0, 0, 0, 0, 0 }
+};
+
+extern "C"
+{
+SAL_DLLPUBLIC_EXPORT void SAL_CALL component_getImplementationEnvironment (
+	const sal_Char ** ppEnvTypeName, uno_Environment ** /* ppEnv */)
+{
+	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+}
+
+SAL_DLLPUBLIC_EXPORT sal_Bool SAL_CALL component_writeInfo (
+	void * pServiceManager, void * pRegistryKey)
+{
+	return cppu::component_writeInfoHelper (
+		pServiceManager, pRegistryKey, g_entries);
+}
+
+SAL_DLLPUBLIC_EXPORT void * SAL_CALL component_getFactory (
+	const sal_Char * pImplementationName, void * pServiceManager, void * pRegistryKey)
+{
+	return cppu::component_getFactoryHelper (
+		pImplementationName, pServiceManager, pRegistryKey, g_entries);
+}
+
+} // extern "C"
diff -ruN fpicker/source/odma/makefile.mk fpicker/source/odma/makefile.mk
--- fpicker/source/odma/makefile.mk	1970-01-01 00:00:00.000000000 +0000
+++ fpicker/source/odma/makefile.mk	2006-10-30 14:40:05.281250000 +0000
@@ -0,0 +1,79 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+PRJ=..$/..
+
+PRJNAME=fpicker
+TARGET=fps_odma
+LIBTARGET=NO
+ENABLE_EXCEPTIONS=TRUE
+GEN_HID=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+DLLPRE=
+
+# --- Files --------------------------------------------------------
+
+SLOFILES=\
+	$(SLO)$/ODMAFilePicker.obj \
+	$(SLO)$/ODMAFolderPicker.obj \
+	$(SLO)$/fps_odma.obj
+
+SHL1TARGET=	$(TARGET).uno
+SHL1IMPLIB=	i$(TARGET)
+SHL1OBJS=	$(SLOFILES)
+SHL1STDLIBS=\
+	$(ODMA_LIB_LIB) \
+	$(SVTOOLLIB) \
+	$(TKLIB) \
+	$(VCLLIB) \
+	$(SVLLIB) \
+	$(UNOTOOLSLIB) \
+	$(TOOLSLIB) \
+	$(UCBHELPERLIB) \
+	$(COMPHELPERLIB) \
+	$(CPPUHELPERLIB) \
+	$(CPPULIB) \
+	$(SALLIB)
+
+SHL1VERSIONMAP=exports.map
+SHL1DEF=	$(MISC)$/$(SHL1TARGET).def
+DEF1NAME=	$(SHL1TARGET)
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
dummy line to avoid confusing diff-mode
--- scp2/source/ooo/file_library_ooo.scp
+++ scp2/source/ooo/file_library_ooo.scp
@@ -850,6 +850,10 @@
 #endif
 #endif
 
+#ifdef WNT
+SPECIAL_UNO_COMPONENT_LIB_FILE_PATCH( gid_File_Lib_Fps_ODMA, fps_odma.uno )
+#endif
+
 SPECIAL_UNO_COMPONENT_LIB_FILE_PATCH( gid_File_Lib_Fps_Office, fps_office.uno )
 SPECIAL_UNO_COMPONENT_LIB_FILE_PATCH( gid_File_Lib_Fpicker, fpicker.uno )
 
dummy line to avoid confusing diff-mode
--- solenv/inc/libs.mk
+++ solenv/inc/libs.mk
@@ -35,4 +35,7 @@
 
 .IF "$(GUI)"=="UNX" || "$(GUI)"=="MAC"
+
+# No ODMA on UNX
+ODMA_LIB_LIB= 
 
 #
@@ -279,6 +279,7 @@
 					$(USED_UNO_LIBS)
 
 .ELSE				# "$(GUI)"=="UNX" || "$(GUI)"=="MAC"
+ODMA_LIB_LIB=odma_lib.lib
 AWTLIB*=jawt.lib
 AVMEDIALIB=$(LIBPRE) iavmedia.lib
 ICUINLIB=icuin.lib
dummy line to avoid confusing diff-mode
--- svtools/inc/miscopt.hxx
+++ svtools/inc/miscopt.hxx
@@ -136,6 +136,10 @@
         void        SetUseSystemFileDialog( sal_Bool bSet );
         sal_Bool    IsUseSystemFileDialogReadOnly() const;
 
+        sal_Bool    TryODMADialog() const;
+        void        SetTryODMADialog( sal_Bool bSet );
+        sal_Bool    IsTryUseODMADialogReadOnly() const;
+
         sal_Bool DisableUICustomization() const;
 
         sal_Bool    IsPluginsEnabled() const;
dummy line to avoid confusing diff-mode
--- svtools/source/config/miscopt.cxx
+++ svtools/source/config/miscopt.cxx
@@ -110,8 +110,10 @@
 #define PROPERTYHANDLE_SYMBOLSTYLE			4
 #define PROPERTYNAME_DISABLEUICUSTOMIZATION	ASCII_STR("DisableUICustomization")
 #define PROPERTYHANDLE_DISABLEUICUSTOMIZATION			5
+#define PROPERTYNAME_TRYODMADIALOG	ASCII_STR("TryODMADialog")
+#define PROPERTYHANDLE_TRYODMADIALOG	6
 
-#define PROPERTYCOUNT						6
+#define PROPERTYCOUNT						7
 
 #define VCL_TOOLBOX_STYLE_FLAT				((USHORT)0x0004) // from <vcl/toolbox.hxx>
 
@@ -131,6 +131,8 @@
     LinkList    aList;
     sal_Bool    m_bUseSystemFileDialog;
     sal_Bool    m_bIsUseSystemFileDialogRO;
+    sal_Bool    m_bTryODMADialog;
+    sal_Bool    m_bIsTryODMADialogRO;
     sal_Bool    m_bPluginsEnabled;
     sal_Bool    m_bIsPluginsEnabledRO;
     sal_Int16   m_nSymbolsSize;
@@ -207,6 +207,15 @@
         inline sal_Bool IsUseSystemFileDialogReadOnly() const
         { return m_bIsUseSystemFileDialogRO; }
 
+        inline sal_Bool TryODMADialog() const
+        { return m_bTryODMADialog; }
+
+        inline void SetTryODMADialog( sal_Bool bSet )
+        {  m_bTryODMADialog = bSet; SetModified(); }
+
+        inline sal_Bool IsTryUseODMADialogReadOnly() const
+        { return m_bIsTryODMADialogRO; }
+
         inline sal_Bool DisableUICustomization() const
         { return m_bDisableUICustomization; }
 
@@ -319,6 +319,8 @@
 
     , m_bUseSystemFileDialog( sal_False )
     , m_bIsUseSystemFileDialogRO( sal_False )
+    , m_bTryODMADialog( sal_False )
+    , m_bIsTryODMADialogRO( sal_False )
     , m_bPluginsEnabled( sal_False )
     , m_bIsPluginsEnabledRO( sal_False )
     , m_nSymbolsSize( 0 )
@@ -388,6 +388,16 @@
                 break;
             }
 
+            case PROPERTYHANDLE_TRYODMADIALOG :
+            {
+                if( !(seqValues[nProperty] >>= m_bTryODMADialog) )
+                {
+                    DBG_ERROR("Wrong type of \"Misc\\TryODMADialog\"!" );
+                }
+                m_bIsTryODMADialogRO = seqRO[nProperty];
+                break;
+            }
+
             case PROPERTYHANDLE_SYMBOLSTYLE :
             {
                 ::rtl::OUString aSymbolsStyle;
@@ -489,6 +489,13 @@
                                                                 DBG_ERROR("Wrong type of \"Misc\\PluginsEnabled\"!" );
                                                         }
                                                     break;
+            case PROPERTYHANDLE_TRYODMADIALOG       :   {
+                                                            if( !(seqValues[nProperty] >>= m_bTryODMADialog) )
+                                                            {
+                                                                DBG_ERROR("Wrong type of \"Misc\\TryODMADialog\"!" );
+                                                            }
+                                                        }
+                                                    break;
             case PROPERTYHANDLE_SYMBOLSTYLE         :   {
                                                             ::rtl::OUString aSymbolsStyle;
                                                             if( seqValues[nProperty] >>= aSymbolsStyle )
@@ -638,6 +638,13 @@
                 break;
             }
 
+            case PROPERTYHANDLE_TRYODMADIALOG :
+            {
+                if ( !m_bIsTryODMADialogRO )
+                    seqValues[nProperty] <<= m_bTryODMADialog;
+                break;
+            }
+
             case PROPERTYHANDLE_SYMBOLSTYLE :
             {
                 if ( !m_bIsSymbolsStyleRO )
@@ -668,7 +668,8 @@
         PROPERTYNAME_TOOLBOXSTYLE,
         PROPERTYNAME_USESYSTEMFILEDIALOG,
         PROPERTYNAME_SYMBOLSTYLE,
-        PROPERTYNAME_DISABLEUICUSTOMIZATION
+        PROPERTYNAME_DISABLEUICUSTOMIZATION,
+        PROPERTYNAME_TRYODMADIALOG
 	};
 
 	// Initialize return sequence with these list ...
@@ -737,6 +737,21 @@
     return m_pDataContainer->IsUseSystemFileDialogReadOnly();
 }
 
+sal_Bool SvtMiscOptions::TryODMADialog() const
+{
+    return m_pDataContainer->TryODMADialog();
+}
+
+void SvtMiscOptions::SetTryODMADialog( sal_Bool bEnable )
+{
+    m_pDataContainer->SetTryODMADialog( bEnable );
+}
+
+sal_Bool SvtMiscOptions::IsTryUseODMADialogReadOnly() const
+{
+    return m_pDataContainer->IsTryUseODMADialogReadOnly();
+}
+
 sal_Bool SvtMiscOptions::IsPluginsEnabled() const
 {
     return m_pDataContainer->IsPluginsEnabled();
dummy line to avoid confusing diff-mode
--- officecfg/registry/schema/org/openoffice/Office/Common.xcs
+++ officecfg/registry/schema/org/openoffice/Office/Common.xcs
@@ -5131,6 +5131,13 @@
 				</info>
 				<value>true</value>
 			</prop>
+			<prop oor:name="TryODMADialog" oor:type="xs:boolean">
+				<info>
+					<author>tml</author>
+					<desc>Determines whether to show the document creation and selection of the machine's default ODMA (Open Document Management Architecture) DMS (Document Management System). If true, and the machine has a DMS available, the DMS's dialog will be displayed. That dialog then gives the opportunity to use the application's dialog instead, which means the normal system file and folder pickers will be displayed. Relevant only on Windows.</desc>
+				</info>
+				<value>true</value>
+			</prop>
 			<prop oor:name="DisableUICustomization" oor:type="xs:boolean">
 				<info>
 					<author>RSiddhartha</author>
dummy line to avoid confusing diff-mode
--- svx/source/dialog/optgdlg.src
+++ svx/source/dialog/optgdlg.src
@@ -136,47 +136,54 @@
 		Text [ de ] = "%PRODUCTNAME-Dialoge ~verwenden" ;
 		Text [ en-US ] = "~Use %PRODUCTNAME dialogs";
 	};
+	CheckBox CB_ODMADLG
+	{
+        Pos = MAP_APPFONT( COL1, ROW8 );
+		Size = MAP_APPFONT( WHOLE_WIDTH - COL4, RSC_CD_CHECKBOX_HEIGHT );
+		Text [ de ] = "ODMA DMS Dialoge ~verwenden" ;
+		Text [ en-US ] = "Show ODMA DMS dialogs first";
+	};
     FixedLine FL_DOCSTATUS
     {
-        Pos = MAP_APPFONT( COL0, ROW8 );
+        Pos = MAP_APPFONT( COL0, ROW9 );
 		Size = MAP_APPFONT( WHOLE_WIDTH, RSC_CD_FIXEDLINE_HEIGHT );
         Text [ de ] = "Dokumentstatus" ;
     	Text [ en-US ] = "Document status";
 	};
     CheckBox CB_DOCSTATUS
 	{
-        Pos = MAP_APPFONT( COL1, ROW9 );
+        Pos = MAP_APPFONT( COL1, ROW10 );
 		Size = MAP_APPFONT( WHOLE_WIDTH - COL1, RSC_CD_CHECKBOX_HEIGHT );
         Text [ de ] = "~Drucken setzt \"Dokument geändert\" Status" ;
     	Text [ en-US ] = "~Printing sets \"document modified\" status";
 	};
 	FixedLine FL_TWOFIGURE
 	{
-		Pos = MAP_APPFONT( COL0, ROW10 );
+		Pos = MAP_APPFONT( COL0, ROW11 );
 		Size = MAP_APPFONT( WHOLE_WIDTH, RSC_CD_FIXEDLINE_HEIGHT );
 		Text [ de ] = "Zweistellige Jahreszahlen" ;
 		Text [ en-US ] = "Year (two digits)" ;
 	};
 	FixedText FT_INTERPRET
 	{
-		Pos = MAP_APPFONT( COL1, OFFS_TEXTBOX_FIXEDTEXT(ROW11) );
+		Pos = MAP_APPFONT( COL1, OFFS_TEXTBOX_FIXEDTEXT(ROW12) );
 		Size = MAP_APPFONT( DIFF( COL1, COL3), RSC_CD_FIXEDTEXT_HEIGHT );
 		Text [ de ] = "~Interpretieren als Jahre zwischen";
 		Text [ en-US ] = "Interpret as years between";
 	};
 	NumericField NF_YEARVALUE
 	{
 		Border = TRUE ;
-		Pos = MAP_APPFONT( COL4, ROW11 );
+		Pos = MAP_APPFONT( COL4, ROW12 );
 		Size = MAP_APPFONT( EDIT_WIDTH, RSC_CD_TEXTBOX_HEIGHT );
 		Minimum = 1583 ;
 		Maximum = 9857 ;
 		Spin = TRUE ;
 		Repeat = TRUE ;
 	};
 	FixedText FT_TOYEAR
 	{
-		Pos = MAP_APPFONT( COL6, OFFS_TEXTBOX_FIXEDTEXT(ROW11) );
+		Pos = MAP_APPFONT( COL6, OFFS_TEXTBOX_FIXEDTEXT(ROW12) );
 		Size = MAP_APPFONT( WHOLE_WIDTH - COL6, RSC_CD_FIXEDTEXT_HEIGHT );
 		Text [ de ] = "und " ;
 		Text [ en-US ] = "and " ;
dummy line to avoid confusing diff-mode
--- svx/source/dialog/optgdlg.hrc
+++ svx/source/dialog/optgdlg.hrc
@@ -64,6 +64,7 @@
 #define ROW9					(ROW8+RSC_CD_FIXEDLINE_HEIGHT+ROWSPACE)
 #define ROW10					(ROW9+RSC_CD_CHECKBOX_HEIGHT+ROWSPACE)
 #define ROW11					(ROW10+RSC_CD_FIXEDLINE_HEIGHT+ROWSPACE)
+#define ROW12					(ROW11+RSC_CD_FIXEDLINE_HEIGHT+ROWSPACE)
 
 #define DIFF(v1,v2)						(v2-v1)
 #define OFFS_TEXTBOX_FIXEDTEXT(base)	(base+(RSC_CD_TEXTBOX_HEIGHT-RSC_CD_FIXEDTEXT_HEIGHT)/2)
@@ -200,6 +200,7 @@
 #define FT_HELPAGENT_TIME_UNIT      59
 #define FL_DOCSTATUS                60
 #define CB_DOCSTATUS                61
+#define CB_ODMADLG                  62
 #endif // #ifndef _SVX_OPTGDLG_HRC
 
 // ******************************************************************* EOF
dummy line to avoid confusing diff-mode
--- svx/source/dialog/optgdlg.hxx
+++ svx/source/dialog/optgdlg.hxx
@@ -74,6 +74,7 @@
     FixedLine           aFileDlgFL;
     ReadOnlyImage       aFileDlgROImage;
 	CheckBox            aFileDlgCB;
+	CheckBox            aODMADlgCB;
 
     FixedLine           aDocStatusFL;
     CheckBox            aDocStatusCB;
@@ -89,6 +89,9 @@
 	DECL_LINK( TwoFigureConfigHdl, NumericField* );
 	DECL_LINK( HelpCheckHdl_Impl, CheckBox* );
 	DECL_LINK( HelpAgentResetHdl_Impl, PushButton* );
+#ifdef WNT
+	DECL_LINK( OnFileDlgToggled, CheckBox* );
+#endif
 protected:
 	virtual int         DeactivatePage( SfxItemSet* pSet = NULL );
 
dummy line to avoid confusing diff-mode
--- svx/source/dialog/optgdlg.cxx
+++ svx/source/dialog/optgdlg.cxx
@@ -291,6 +291,7 @@
 	aFileDlgFL			( this, ResId( FL_FILEDLG ) ),
     aFileDlgROImage     ( this, ResId( FI_FILEDLG_RO ) ),
 	aFileDlgCB			( this, ResId( CB_FILEDLG ) ),
+	aODMADlgCB			( this, ResId( CB_ODMADLG ) ),
 	aDocStatusFL		( this, ResId( FL_DOCSTATUS ) ),
 	aDocStatusCB		( this, ResId( CB_DOCSTATUS ) ),
 	aTwoFigureFL		( this, ResId( FL_TWOFIGURE ) ),
@@ -313,6 +313,31 @@
 	}
 #	endif
 #endif
+
+#ifdef WNT
+	aFileDlgCB.SetToggleHdl( LINK( this, OfaMiscTabPage, OnFileDlgToggled ) );
+#else
+	{
+		aODMADlgCB.Hide();
+		// rearrange the following controls
+		Point aNewPos = aDocStatusFL.GetPosPixel();
+		long nDelta = aNewPos.Y() - aFileDlgFL.GetPosPixel().Y();
+
+		Window* pWins[] =
+		{
+		    &aDocStatusFL, &aDocStatusCB, &aTwoFigureFL,
+		    &aInterpretFT, &aYearValueField, &aToYearFT
+		};
+		Window** pCurrent = pWins;
+		const sal_Int32 nCount = sizeof( pWins ) / sizeof( pWins[ 0 ] );
+		for ( sal_Int32 i = 0; i < nCount; ++i, ++pCurrent )
+		{
+		    aNewPos = (*pCurrent)->GetPosPixel();
+		    aNewPos.Y() -= nDelta;
+		    (*pCurrent)->SetPosPixel( aNewPos );
+		}
+	}
+#endif
 
     if ( !aFileDlgCB.IsVisible() )
     {
@@ -405,6 +405,14 @@
         aHelpFormatLB.SetEntryData( i, pData );
     }
 }
+
+#ifdef WNT
+IMPL_LINK( OfaMiscTabPage, OnFileDlgToggled, CheckBox*, EMPTYARG ) 
+{
+	aODMADlgCB.Enable( !aFileDlgCB.IsChecked() );
+	return 0;
+}
+#endif
 
 // -----------------------------------------------------------------------
 
@@ -429,6 +429,13 @@
         bModified = TRUE;
     }
 
+    if ( aODMADlgCB.IsChecked() != aODMADlgCB.GetSavedValue() )
+    {
+        SvtMiscOptions aMiscOpt;
+        aMiscOpt.SetTryODMADialog( aODMADlgCB.IsChecked() );
+        bModified = TRUE;
+    }
+
 	if ( aDocStatusCB.IsChecked() != aDocStatusCB.GetSavedValue() )
     {
         SvtPrintWarningOptions aPrintOptions;
@@ -476,6 +476,9 @@
     aFileDlgCB.Check( !aMiscOpt.UseSystemFileDialog() );
     aFileDlgCB.SaveValue();
 
+    aODMADlgCB.Check( aMiscOpt.TryODMADialog() );
+    aODMADlgCB.SaveValue();
+
     SvtPrintWarningOptions aPrintOptions;
     aDocStatusCB.Check(aPrintOptions.IsModifyDocumentOnPrintingAllowed());
     aDocStatusCB.SaveValue();
dummy line to avoid confusing diff-mode
--- solenv/bin/modules/installer/windows/component.pm
+++ solenv/bin/modules/installer/windows/component.pm
@@ -101,6 +101,11 @@
 	{
 		return $installer::globals::templatefolder;
 	}
+
+	if ( $destdir =~ /\bPREDEFINED_OSWINSHELLNEWDIR\b/ )
+	{
+		return "WindowsShellNewFolder";
+	}
 
 	my $destination = $onefile->{'destination'};
 	
dummy line to avoid confusing diff-mode
--- solenv/bin/modules/installer/windows/directory.pm
+++ solenv/bin/modules/installer/windows/directory.pm
@@ -174,6 +174,12 @@
 
 	my $oneline = "TARGETDIR\t\tSourceDir\n";
 	push(@{$directorytableref}, $oneline);
+	
+	my $oneline = "WindowsFolder\tTARGETDIR\tWindows\n";
+	push(@{$directorytableref}, $oneline);
+
+	my $oneline = "WindowsShellNewFolder\tWindowsFolder\tShellNew\n";
+	push(@{$directorytableref}, $oneline);
 	
 	my $sourcediraddon = "";
 	if (($installer::globals::addchildprojects) ||
dummy line to avoid confusing diff-mode
--- scp2/source/ooo/file_ooo.scp
+++ scp2/source/ooo/file_ooo.scp
@@ -2025,24 +2025,56 @@
 #ifdef WNT
 
 STD_SHELLNEW_FILE(gid_File_Shellnew_Ods_Soffice, soffice.ods)
 
+File gid_File_Shellnew2_Ods_Soffice
+    TXT_FILE_BODY;
+    Styles = (PACKED,WORKSTATION, OVERWRITE);
+    Dir = PREDEFINED_OSWINSHELLNEWDIR;
+    NetDir = gid_Dir_Shellnew;
+    Name = "soffice.ods";
+End
+
 #endif
 
 #ifdef WNT
 
 STD_SHELLNEW_FILE(gid_File_Shellnew_Odg_Soffice, soffice.odg)
 
+File gid_File_Shellnew2_Odg_Soffice
+    TXT_FILE_BODY;
+    Styles = (PACKED,WORKSTATION, OVERWRITE);
+    Dir = PREDEFINED_OSWINSHELLNEWDIR;
+    NetDir = gid_Dir_Shellnew;
+    Name = "soffice.odg";
+End
+
 #endif
 
 #ifdef WNT
 
 STD_SHELLNEW_FILE(gid_File_Shellnew_Odp_Soffice, soffice.odp)
 
+File gid_File_Shellnew2_Odp_Soffice
+    TXT_FILE_BODY;
+    Styles = (PACKED,WORKSTATION, OVERWRITE);
+    Dir = PREDEFINED_OSWINSHELLNEWDIR;
+    NetDir = gid_Dir_Shellnew;
+    Name = "soffice.odp";
+End
+
 #endif
 
 #ifdef WNT
 
 STD_SHELLNEW_FILE(gid_File_Shellnew_Odt_Soffice, soffice.odt)
 
+File gid_File_Shellnew2_Odt_Soffice
+    TXT_FILE_BODY;
+    Styles = (PACKED,WORKSTATION, OVERWRITE);
+    Dir = PREDEFINED_OSWINSHELLNEWDIR;
+    NetDir = gid_Dir_Shellnew;
+    Name = "soffice.odt";
+End
+
 #endif
 
dummy line to avoid confusing diff-mode
