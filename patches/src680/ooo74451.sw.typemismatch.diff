--- sw/source/filter/ww8/wrtw8esh.cxx.old	2006-12-12 17:30:12.000000000 +0100
+++ sw/source/filter/ww8/wrtw8esh.cxx	2007-03-28 12:47:05.198977616 +0200
@@ -494,7 +494,7 @@
 //so that word will have to place them in the right place. Doubly so that
 //the SO drawings and writer frames have different ideas themselves as to
 //how to be positioned when in RTL mode!
-bool RTLGraphicsHack(long &rLeft, long nWidth,
+bool RTLGraphicsHack(SwTwips &rLeft, SwTwips nWidth,
     SwHoriOrient eHoriOri, SwRelationOrient eHoriRel, SwTwips nPageLeft,
     SwTwips nPageRight, SwTwips nPageSize)
 {
--- sw/source/filter/ww8/ww8graf.cxx.old	2006-12-14 19:27:46.000000000 +0100
+++ sw/source/filter/ww8/ww8graf.cxx	2007-03-28 12:47:05.208977767 +0200
@@ -2344,7 +2344,7 @@
 
 //#109311# Miserable miserable hack to fudge word's graphic layout in
 //RTL mode to ours.
-bool SwWW8ImplReader::MiserableRTLGraphicsHack(long &rLeft,  long nWidth,
+bool SwWW8ImplReader::MiserableRTLGraphicsHack(SwTwips &rLeft, SwTwips nWidth,
     SwHoriOrient eHoriOri, SwRelationOrient eHoriRel)
 {
     if (!IsRightToLeft())
@@ -2517,10 +2517,12 @@
         // floating screen objects, which are imported.
         {
             //#109311# Miserable miserable hack.
-            long nWidth = (pFSPA->nXaRight - pFSPA->nXaLeft);
-            if (MiserableRTLGraphicsHack(pFSPA->nXaLeft, nWidth, eHoriOri,
+            SwTwips nWidth = (pFSPA->nXaRight - pFSPA->nXaLeft);
+            SwTwips nLeft = pFSPA->nXaLeft;
+            if (MiserableRTLGraphicsHack(nLeft, nWidth, eHoriOri,
                 eHoriRel))
             {
+                pFSPA->nXaLeft = nLeft;
                 pFSPA->nXaRight = pFSPA->nXaLeft + nWidth;
             }
         }
--- sw/source/filter/ww8/ww8par.hxx.old	2006-11-06 15:54:12.000000000 +0100
+++ sw/source/filter/ww8/ww8par.hxx	2007-03-28 12:47:05.208977767 +0200
@@ -1290,7 +1290,7 @@
     SdrObject* CreateContactObject(SwFrmFmt* pFlyFmt);
     RndStdIds ProcessEscherAlign(SvxMSDffImportRec* pRecord, WW8_FSPA *pFSPA,
         SfxItemSet &rFlySet, bool bOrgObjectWasReplace);
-    bool MiserableRTLGraphicsHack(long &rLeft, long nWidth,
+    bool MiserableRTLGraphicsHack(SwTwips &rLeft, SwTwips nWidth,
         SwHoriOrient eHoriOri, SwRelationOrient eHoriRel);
     SwFrmFmt* Read_GrafLayer( long nGrafAnchorCp );
     SwFlyFrmFmt* ImportReplaceableDrawables( SdrObject* &rpObject,
@@ -1563,7 +1563,7 @@
 void SyncIndentWithList(SvxLRSpaceItem &rLR, const SwNumFmt &rFmt);
 long GetListFirstLineIndent(const SwNumFmt &rFmt);
 String BookmarkToWriter(const String &rBookmark);
-bool RTLGraphicsHack(long &rLeft, long nWidth,
+bool RTLGraphicsHack(SwTwips &rLeft, SwTwips nWidth,
     SwHoriOrient eHoriOri, SwRelationOrient eHoriRel, SwTwips nPageLeft,
     SwTwips nPageRight, SwTwips nPageSize);
 void MatchEscherMirrorIntoFlySet(const SvxMSDffImportRec &rRecord,
--- sw/source/filter/ww8/ww8par6.cxx.old	2006-12-01 16:57:19.000000000 +0100
+++ sw/source/filter/ww8/ww8par6.cxx	2007-03-28 12:47:05.208977767 +0200
@@ -2240,7 +2240,7 @@
     Put(SvxFrameDirectionItem(FRMDIR_HORI_LEFT_TOP));
 
 /*Below can all go when we have from left in rtl mode*/
-    long nXPos = pFS->nXPos;
+    SwTwips nXPos = pFS->nXPos;
     SwRelationOrient eHRel = pFS->eHRel;
     rReader.MiserableRTLGraphicsHack(nXPos, pFS->nWidth, pFS->eHAlign, eHRel);
 /*Above can all go when we have from left in rtl mode*/
--- sw/source/filter/ww8/ww8struc.hxx.old	2006-04-19 15:43:21.000000000 +0200
+++ sw/source/filter/ww8/ww8struc.hxx	2007-03-28 12:47:05.208977767 +0200
@@ -834,25 +834,25 @@
 struct WW8_FSPA
 {
 public:
-    long nSpId;     //Shape Identifier. Used in conjunction with the office art data (found via fcDggInfo in the FIB) to find the actual data for this shape.
-    long nXaLeft;   //left of rectangle enclosing shape relative to the origin of the shape
-    long nYaTop;        //top of rectangle enclosing shape relative to the origin of the shape
-    long nXaRight;  //right of rectangle enclosing shape relative to the origin of the shape
-    long nYaBottom;//bottom of the rectangle enclosing shape relative to the origin of the shape
-    USHORT bHdr:1;
+    sal_Int32 nSpId;     //Shape Identifier. Used in conjunction with the office art data (found via fcDggInfo in the FIB) to find the actual data for this shape.
+    sal_Int32 nXaLeft;   //left of rectangle enclosing shape relative to the origin of the shape
+    sal_Int32 nYaTop;        //top of rectangle enclosing shape relative to the origin of the shape
+    sal_Int32 nXaRight;  //right of rectangle enclosing shape relative to the origin of the shape
+    sal_Int32 nYaBottom;//bottom of the rectangle enclosing shape relative to the origin of the shape
+    sal_uInt16 bHdr:1;
     //0001 1 in the undo doc when shape is from the header doc, 0 otherwise (undefined when not in the undo doc)
-    USHORT nbx:2;
+    sal_uInt16 nbx:2;
     //0006 x position of shape relative to anchor CP
     //0 relative to page margin
     //1 relative to top of page
     //2 relative to text (column for horizontal text; paragraph for vertical text)
     //3 reserved for future use
-    USHORT nby:2;
+    sal_uInt16 nby:2;
     //0018 y position of shape relative to anchor CP
     //0 relative to page margin
     //1 relative to top of page
     //2 relative to text (paragraph for horizontal text; column for vertical text)
-    USHORT nwr:4;
+    sal_uInt16 nwr:4;
     //01E0 text wrapping mode
     //0 like 2, but doesn't require absolute object
     //1 no text next to shape
@@ -861,22 +861,22 @@
     //4 wrap tightly around object
     //5 wrap tightly, but allow holes
     //6-15 reserved for future use
-    USHORT nwrk:4;
+    sal_uInt16 nwrk:4;
     //1E00 text wrapping mode type (valid only for wrapping modes 2 and 4
     //0 wrap both sides
     //1 wrap only on left
     //2 wrap only on right
     //3 wrap only on largest side
-    USHORT bRcaSimple:1;
+    sal_uInt16 bRcaSimple:1;
     //2000 when set, temporarily overrides bx, by, forcing the xaLeft, xaRight, yaTop, and yaBottom fields to all be page relative.
-    USHORT bBelowText:1;
+    sal_uInt16 bBelowText:1;
     //4000
     //1 shape is below text
     //0 shape is above text
-    USHORT bAnchorLock:1;
+    sal_uInt16 bAnchorLock:1;
     //8000  1 anchor is locked
     //      0 anchor is not locked
-    long nTxbx; //count of textboxes in shape (undo doc only)
+    sal_Int32 nTxbx; //count of textboxes in shape (undo doc only)
 public:
     enum FSPAOrient {RelPgMargin, RelPageBorder, RelText};
 };
