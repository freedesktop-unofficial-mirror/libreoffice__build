--- dtrans/source/X11/X11_selection.cxx.old	2006-10-05 11:06:26.208388000 +0200
+++ dtrans/source/X11/X11_selection.cxx	2006-10-05 11:45:59.888388000 +0200
@@ -116,7 +116,7 @@
 }
 
 
-static const int nXdndProtocolRevision = 5;
+static const long nXdndProtocolRevision = 5;
 
 // mapping between mime types (or what the office thinks of mime types)
 // and X convention types
@@ -1338,7 +1338,7 @@
 	std::vector< Atom > aNativeTypes;
 	if( aAtoms.getLength() )
 	{
-		int nAtoms = aAtoms.getLength() / 4;
+		sal_Int32 nAtoms = aAtoms.getLength() / sizeof(Atom);
 		Atom* pAtoms = (Atom*)aAtoms.getArray();
 		rTypes.realloc( nAtoms );
 		aNativeTypes.resize( nAtoms );
@@ -1457,6 +1457,12 @@
     return it->second->m_pPixmap;
 }
 
+static sal_Size GetTrueFormatSize(int nFormat)
+{
+	// http://mail.gnome.org/archives/wm-spec-list/2003-March/msg00067.html
+	return nFormat == 32 ? sizeof(long) : nFormat/8;	
+}
+
 bool SelectionManager::sendData( SelectionAdaptor* pAdaptor,
                                  Window requestor,
                                  Atom target,
@@ -1592,13 +1598,15 @@
             rInc.m_nTransferStartTime	= time( NULL );
 
             // use incr protocol, signal start to requestor
-            int nMinSize = m_nIncrementalThreshold;
+            long nMinSize = m_nIncrementalThreshold;
             XSelectInput( m_pDisplay, requestor, PropertyChangeMask );
             XChangeProperty( m_pDisplay, requestor, property,
                              m_nINCRAtom, 32,  PropModeReplace, (unsigned char*)&nMinSize, 1 );
             XFlush( m_pDisplay );
         }
         else
+        {
+            sal_Size nUnitSize = GetTrueFormatSize(nFormat);
             XChangeProperty( m_pDisplay,
                              requestor,
                              property,
@@ -1606,7 +1614,8 @@
                              nFormat,
                              PropModeReplace,
                              (const unsigned char*)aData.getConstArray(),
-                             aData.getLength()/(nFormat/8) );
+                             aData.getLength()/nUnitSize );
+            }
     }
 #if OSL_DEBUG_LEVEL > 1
     else
@@ -1674,7 +1683,7 @@
 		}
         else if( rRequest.target == m_nTIMESTAMPAtom )
         {
-            sal_uInt32 nTimeStamp = (sal_uInt32)m_aSelections[rRequest.selection]->m_nOrigTimestamp;
+            long nTimeStamp = (long)m_aSelections[rRequest.selection]->m_nOrigTimestamp;
             XChangeProperty( m_pDisplay, rRequest.requestor, rRequest.property,
                              XA_INTEGER, 32, PropModeReplace, (const unsigned char*)&nTimeStamp, 1 );
             aNotify.xselection.property = rRequest.property;
@@ -1904,11 +1913,14 @@
 					 OUStringToOString( getString( nType ), RTL_TEXTENCODING_ISO_8859_1 ).getStr(),
 					 nFormat, nBytes );
 #endif
+	
+			sal_Size nUnitSize = GetTrueFormatSize(nFormat);
+
 			if( it->second->m_eState == Selection::WaitingForData ||
 				it->second->m_eState == Selection::WaitingForResponse )
 			{
 				// copy data
-				it->second->m_aData = Sequence< sal_Int8 >( (sal_Int8*)pData, nItems*nFormat/8 );
+				it->second->m_aData = Sequence< sal_Int8 >( (sal_Int8*)pData, nItems*nUnitSize );
 				it->second->m_eState = Selection::Inactive;
 				it->second->m_aDataArrived.set();
 			}
@@ -1917,9 +1929,9 @@
                 if( nItems )
                 {
                     // append data
-                    Sequence< sal_Int8 > aData( it->second->m_aData.getLength() + nItems*nFormat/8 );
+                    Sequence< sal_Int8 > aData( it->second->m_aData.getLength() + nItems*nUnitSize );
                     memcpy( aData.getArray(), it->second->m_aData.getArray(), it->second->m_aData.getLength() );
-                    memcpy( aData.getArray() + it->second->m_aData.getLength(), pData, nItems*nFormat/8 );
+                    memcpy( aData.getArray() + it->second->m_aData.getLength(), pData, nItems*nUnitSize );
                     it->second->m_aData = aData;
                 }
                 else
@@ -2005,6 +2017,8 @@
                          nBytes, nBytes > 32 ? 32 : nBytes,
                          (const unsigned char*)rInc.m_aData.getConstArray()+rInc.m_nBufferPos );
 #endif
+
+				sal_Size nUnitSize = GetTrueFormatSize(rInc.m_nFormat);
                 
                 XChangeProperty( m_pDisplay,
                                  rInc.m_aRequestor,
@@ -2013,7 +2027,7 @@
                                  rInc.m_nFormat,
                                  PropModeReplace,
                                  (const unsigned char*)rInc.m_aData.getConstArray()+rInc.m_nBufferPos,
-                                 nBytes/(rInc.m_nFormat/8) );
+                                 nBytes/nUnitSize );
                 rInc.m_nBufferPos += nBytes;
                 rInc.m_nTransferStartTime = nCurrentTime;
 
@@ -2100,7 +2114,8 @@
                                     &pData );
             }
             it->second->m_eState		= Selection::Inactive;
-            it->second->m_aData			= Sequence< sal_Int8 >((sal_Int8*)pData, nFormat/8 * nItems );
+            sal_Size nUnitSize = GetTrueFormatSize(nFormat);
+            it->second->m_aData			= Sequence< sal_Int8 >((sal_Int8*)pData, nItems * nUnitSize);
             it->second->m_aDataArrived.set();
             if( pData )
                 XFree( pData );
--- svtools/inc/brwbox.hxx.old	2006-10-05 11:06:26.108388000 +0200
+++ svtools/inc/brwbox.hxx	2006-10-05 11:45:59.908388000 +0200
@@ -94,7 +94,8 @@
 // -------------------
 
 #define BROWSER_INVALIDID           USHRT_MAX
-#define BROWSER_ENDOFSELECTION      -1
+#include <tools/multisel.hxx>
+#define BROWSER_ENDOFSELECTION      SFX_ENDOFSELECTION
 
 typedef ULONG BrowserMode;
 
--- sw/source/filter/html/swhtml.hxx.old	2006-10-05 11:06:26.178388000 +0200
+++ sw/source/filter/html/swhtml.hxx	2006-10-05 11:45:59.888388000 +0200
@@ -450,7 +450,7 @@
 
 	sal_uInt32 	aFontHeights[7];	// die Font-Hoehen 1-7
 	sal_uInt32	nScriptStartLineNr;	// Zeilennummer eines Script-Blocks
-	sal_uInt32					nEventId;
+	ULONG		nEventId;
 
 	sal_uInt16	nBaseFontStMin;		//
 	sal_uInt16	nFontStMin; 		//
--- sw/source/filter/ww8/ww8scan.cxx.old	2006-10-05 11:06:26.198388000 +0200
+++ sw/source/filter/ww8/ww8scan.cxx	2006-10-05 11:45:59.898388000 +0200
@@ -6483,7 +6483,7 @@
             cDBC = Get_Long( pData );
             cDBCFtnEdn = Get_Long( pData );
 
-            pData += 1 * sizeof( long );
+            pData += 1 * sizeof( INT32);
 
             nfcFtnRef = Get_Short( pData );
             nfcEdnRef = Get_Short( pData );
@@ -6775,7 +6775,7 @@
         Set_UInt32( pData, cDBC );
         Set_UInt32( pData, cDBCFtnEdn );
 
-        pData += 1 * sizeof( long );
+        pData += 1 * sizeof( INT32);
 
         Set_UInt16( pData, nfcFtnRef );
         Set_UInt16( pData, nfcEdnRef );
--- tools/source/generic/fract.cxx.old	2006-10-05 11:06:26.148388000 +0200
+++ tools/source/generic/fract.cxx	2006-10-05 11:45:59.908388000 +0200
@@ -531,22 +531,22 @@
         return;
 
     // Zaehler und Nenner auf den Stack fuer schnelleren Zugriff
-    UINT32 nMul;
-    UINT32 nDiv;
+    unsigned long nMul;
+    unsigned long nDiv;
     BOOL   bNeg;
     if ( nNumerator >= 0 )
     {
-        nMul = (UINT32)nNumerator;
+        nMul = (unsigned long)nNumerator;
         bNeg = FALSE;
     }
     else
     {
-        nMul = (UINT32)(-nNumerator);
+        nMul = (unsigned long)(-nNumerator);
         bNeg = TRUE;
     }
-    nDiv=(UINT32)nDenominator;
+    nDiv=(unsigned long)nDenominator;
 
-    UINT32 a=nMul; unsigned nMulZ=0; // Fuehrende Nullen zaehlen
+    unsigned long a=nMul; unsigned nMulZ=0; // Fuehrende Nullen zaehlen
     while (a<0x00800000) { nMulZ+=8; a<<=8; }
     while (a<0x80000000) { nMulZ++; a<<=1; }
     a=nDiv; unsigned nDivZ=0; // Fuehrende Nullen zaehlen
@@ -554,8 +554,8 @@
     while (a<0x80000000) { nDivZ++; a<<=1; }
     // Anzahl der verwendeten Digits bestimmen
     // Auch hier gehe ich davon aus, dass es sich um 32Bit-Werte handelt
-    int nMulDigits=32-nMulZ;
-    int nDivDigits=32-nDivZ;
+    int nMulDigits=(sizeof(long) * 8)-nMulZ;
+    int nDivDigits=(sizeof(long) * 8)-nDivZ;
     // Nun bestimmen, wieviele Stellen hinten weg koennen
     // Hier koennte man das Ergebnis noch etwas optimieren...
     int nMulWeg=nMulDigits-nSignificantBits; if (nMulWeg<0) nMulWeg=0;
--- vcl/source/gdi/bmpacc.cxx.old	2006-10-05 11:06:26.208388000 +0200
+++ vcl/source/gdi/bmpacc.cxx	2006-10-05 11:45:59.898388000 +0200
@@ -301,7 +301,7 @@
 			nMask = SWAPLONG( nMask );
 #endif
 			for( sal_uInt32 i = 0; i < nHeight; i++, pLast4Bytes += nScanSize )
-				( *(long*) pLast4Bytes ) &= nMask;
+				( *(sal_uInt32*) pLast4Bytes ) &= nMask;
 		}
 	}
 }
--- vcl/unx/source/gdi/pspgraphics.cxx.old	2006-10-05 11:06:26.258388000 +0200
+++ vcl/unx/source/gdi/pspgraphics.cxx	2006-10-05 11:45:59.918388000 +0200
@@ -63,7 +63,7 @@
 
     FncGetPixel			mpFncGetPixel;
     Scanline			mpScanAccess;
-    sal_Int32			mnScanOffset;
+    sal_PtrDiff			mnScanOffset;
 
     sal_uInt32			ColorOf (BitmapColor& rColor) const;
     sal_uInt8			GrayOf  (BitmapColor& rColor) const;
