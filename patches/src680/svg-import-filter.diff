--- filter/source/config/fragments/fcfg_drawgraphics.mk	2008-02-26 11:23:18.000000000 +0100
+++ filter/source/config/fragments/fcfg_drawgraphics.mk	2008-02-23 12:59:42.000000000 +0100
@@ -54,6 +54,7 @@
     SGF___StarOffice_Writer_SGF \
     SGV___StarDraw_2_0 \
     SVM___StarView_Metafile \
+    SVG___Scalable_Vector_Graphics \
     TGA___Truevision_TARGA \
     TIF___Tag_Image_File \
     WMF___MS_Windows_Metafile \
--- filter/source/config/fragments/filters/SVG___Scalable_Vector_Graphics.xcu	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/config/fragments/filters/SVG___Scalable_Vector_Graphics.xcu	2008-02-23 12:59:42.000000000 +0100
@@ -0,0 +1,13 @@
+	<node oor:name="SVG - Scalable Vector Graphics" oor:op="replace">
+		<prop oor:name="Flags"><value>IMPORT ALIEN USESOPTIONS 3RDPARTYFILTER PREFERRED</value></prop>
+		<prop oor:name="UIComponent"/>
+		<prop oor:name="FilterService"><value>com.sun.star.comp.Draw.SVGFilter</value></prop>
+		<prop oor:name="UserData"><value></value></prop>
+		<prop oor:name="UIName">
+			<value xml:lang="x-default">SVG - Scalable Vector Graphics</value>
+		</prop>
+		<prop oor:name="FileFormatVersion"><value>0</value></prop>
+		<prop oor:name="Type"><value>svg_Scalable_Vector_Graphics</value></prop>
+		<prop oor:name="TemplateName"/>
+		<prop oor:name="DocumentService"><value>com.sun.star.drawing.DrawingDocument</value></prop>
+	</node>
--- filter/source/config/fragments/types/svg_Scalable_Vector_Graphics.xcu	2008-02-26 11:23:18.000000000 +0100
+++ filter/source/config/fragments/types/svg_Scalable_Vector_Graphics.xcu	2008-02-23 12:59:42.000000000 +0100
@@ -1,12 +1,12 @@
 	<node oor:name="svg_Scalable_Vector_Graphics" oor:op="replace" >
-		<prop oor:name="DetectService"/>
+		<prop oor:name="DetectService"><value>com.sun.star.comp.filters.XMLFilterDetect</value></prop>
 		<prop oor:name="URLPattern"/>
 		<prop oor:name="Extensions"><value>svg</value></prop>
 		<prop oor:name="MediaType"><value>image/svg+xml</value></prop>
-		<prop oor:name="Preferred"><value>false</value></prop>
-		<prop oor:name="PreferredFilter"/>
+		<prop oor:name="Preferred"><value>true</value></prop>
+		<prop oor:name="PreferredFilter"><value>SVG - Scalable Vector Graphics</value></prop>
 		<prop oor:name="UIName">
 			<value>SVG - Scalable Vector Graphics</value>
 		</prop>
-		<prop oor:name="ClipboardFormat"/>
+		<prop oor:name="ClipboardFormat"><value>doctype:xmlns="http://www.w3.org/2000/svg"</value></prop>
 	</node>
--- filter/source/svg/b2dellipse.cxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/b2dellipse.cxx	2008-02-23 21:35:38.000000000 +0100
@@ -0,0 +1,139 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Fridrich Strba  <fridrich.strba@bluewin.ch>
+ *      Thorsten Behrens <tbehrens@novell.com>	   	
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#include "b2dellipse.hxx"
+
+#include <osl/diagnose.h>
+
+#include <basegfx/point/b2dpoint.hxx>
+
+#include <basegfx/matrix/b2dhommatrix.hxx>
+
+#include <rtl/instance.hxx>
+
+#include <boost/scoped_ptr.hpp>
+#include <vector>
+#include <algorithm>
+
+class ImplB2DEllipse
+{
+	 basegfx::B2DPoint maCenter;
+	 basegfx::B2DTuple maRadius;
+
+public:
+	ImplB2DEllipse()
+	:	maCenter(0.0f, 0.0f),
+		maRadius(0.0f, 0.0f)
+	{}
+
+	ImplB2DEllipse(const ImplB2DEllipse& rToBeCopied)
+	:	maCenter(rToBeCopied.maCenter),
+		maRadius(rToBeCopied.maRadius)
+	{}
+	
+    ImplB2DEllipse& operator=( const ImplB2DEllipse& rToBeCopied )
+    {
+		maCenter = rToBeCopied.maCenter;
+		maRadius = rToBeCopied.maRadius;
+
+        return *this;
+    }
+
+	bool isEqual(const ImplB2DEllipse& rCandidate) const
+	{
+		return (maCenter == rCandidate.maCenter)
+			&& (maRadius == rCandidate.maRadius);
+	}
+
+	basegfx::B2DPoint getCenter() const
+	{
+		return maCenter;
+	}
+	
+	void setCenter(const basegfx::B2DPoint& rCenter)
+	{
+		maCenter = rCenter;
+	}
+		
+	basegfx::B2DTuple getRadius() const
+	{
+		return maRadius;
+	}
+	
+	void setRadius(const basegfx::B2DTuple& rRadius)
+	{
+		maRadius = rRadius;
+	}
+		
+
+	void transform(const basegfx::B2DHomMatrix& /* rMatrix */)
+	{
+	}
+};
+
+//////////////////////////////////////////////////////////////////////////////
+
+namespace basegfx
+{
+
+	B2DEllipse::B2DEllipse() 
+	{}
+
+	B2DEllipse::B2DEllipse(const basegfx::B2DPoint& rCenter, const basegfx::B2DTuple& rRadius)
+	:	maCenter(rCenter), maRadius(rRadius)
+	{
+	}
+
+	B2DEllipse::~B2DEllipse()
+	{
+	}
+
+	bool B2DEllipse::operator==(const B2DEllipse& rEllipse) const
+	{
+		return (maCenter == rEllipse.maCenter) && (maRadius == rEllipse.maRadius);
+	}
+
+	bool B2DEllipse::operator!=(const B2DEllipse& rEllipse) const
+	{
+        return !(*this == rEllipse);
+	}
+
+	basegfx::B2DPoint B2DEllipse::getB2DEllipseCenter() const
+	{
+		return maCenter;
+	}
+
+	void B2DEllipse::setB2DEllipseCenter(const basegfx::B2DPoint& rCenter)
+	{
+		maCenter = rCenter;
+	}
+
+	basegfx::B2DTuple B2DEllipse::getB2DEllipseRadius() const
+	{
+		return maRadius;
+	}
+
+	void B2DEllipse::setB2DEllipseRadius(const basegfx::B2DTuple& rRadius)
+	{
+		maRadius = rRadius;
+	}
+
+	void B2DEllipse::transform(const basegfx::B2DHomMatrix& /* rMatrix */)
+	{
+	}
+} // end of namespace basegfx
+
+//////////////////////////////////////////////////////////////////////////////
+// eof
--- filter/source/svg/b2dellipse.hxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/b2dellipse.hxx	2008-02-23 21:35:52.000000000 +0100
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Fridrich Strba  <fridrich.strba@bluewin.ch>
+ *      Thorsten Behrens <tbehrens@novell.com>	   	
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef _BASEGFX_B2DELLIPSE_HXX
+#define _BASEGFX_B2DELLIPSE_HXX
+
+#include <sal/types.h>
+
+#include <o3tl/cow_wrapper.hxx>
+
+#include <basegfx/point/b2dpoint.hxx>
+
+#include <basegfx/tuple/b2dtuple.hxx>
+
+#include <basegfx/vector/b2enums.hxx>
+
+//////////////////////////////////////////////////////////////////////////////
+// predeclarations
+class ImplB2DEllipse;
+
+namespace basegfx
+{
+	class B2DPoint;
+	class B2DVector;
+	class B2DHomMatrix;
+} // end of namespace basegfx
+
+//////////////////////////////////////////////////////////////////////////////
+
+namespace basegfx
+{
+	class B2DEllipse
+	{
+	private:
+	 basegfx::B2DPoint maCenter;
+	 basegfx::B2DTuple maRadius;
+
+	public:
+		B2DEllipse();
+		B2DEllipse(const B2DEllipse& rEllipse);
+		B2DEllipse(const basegfx::B2DPoint& rCenter, const basegfx::B2DTuple& rRadius);
+		~B2DEllipse();
+
+		// assignment operator
+		B2DEllipse& operator=(const B2DEllipse& rEllipse);
+
+		// compare operators
+		bool operator==(const B2DEllipse& rEllipse) const;
+		bool operator!=(const B2DEllipse& rEllipse) const;
+
+		// Coordinate interface
+		basegfx::B2DPoint getB2DEllipseCenter() const;
+		void setB2DEllipseCenter(const basegfx::B2DPoint& rCenter);
+		
+		basegfx::B2DTuple getB2DEllipseRadius() const;
+		void setB2DEllipseRadius(const basegfx::B2DTuple& rRadius);
+		
+		// apply transformation given in matrix form to the Ellipse
+		void transform(const basegfx::B2DHomMatrix& rMatrix);
+	};
+} // end of namespace basegfx
+
+//////////////////////////////////////////////////////////////////////////////
+
+#endif /* _BASEGFX_B2DELLIPSE_HXX */
--- filter/source/svg/exports.map	2008-02-26 11:23:18.000000000 +0100
+++ filter/source/svg/exports.map	2008-02-23 12:59:42.000000000 +0100
@@ -1,4 +1,4 @@
-PDFFILTER_1_0 {
+SVGFILTER_1_0 {
         global:
                 component_getImplementationEnvironment;
                 component_getFactory;
@@ -6,4 +6,4 @@
 
         local:
                 *;
-}; 
\ No newline at end of file
+}; 
--- filter/source/svg/gentoken.pl	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/gentoken.pl	2008-02-23 12:59:42.000000000 +0100
@@ -0,0 +1,58 @@
+# from oox/source/token - should really put this into solenv
+
+$ARGV0 = shift @ARGV;
+$ARGV1 = shift @ARGV;
+$ARGV2 = shift @ARGV;
+
+open ( TOKENS, $ARGV0 ) || die "can't open token file: $!";
+my %tokens;
+
+while ( defined ($line = <TOKENS>) )
+{
+	if( !($line =~ /^#/) )
+	{
+		chomp($line);
+		@token = split(/\s+/,$line);
+		if ( not defined ($token[1]) )
+		{
+			$token[1] = "XML_".$token[0];
+			$token[1] =~ tr/\-\.\:/___/;
+			$token[1] =~ s/\+/PLUS/g;
+			$token[1] =~ s/\-/MINUS/g;
+		}
+
+		$tokens{$token[0]} = uc($token[1]);
+	}
+}
+close ( TOKENS );
+
+open ( HXX, ">$ARGV1" ) || die "can't open tokens.hxx file: $!";
+open ( GPERF, ">$ARGV2" ) || die "can't open tokens.gperf file: $!";
+
+print ( GPERF "%language=C++\n" );
+print ( GPERF "%global-table\n" );
+print ( GPERF "%null-strings\n" );
+print ( GPERF "%struct-type\n" );
+print ( GPERF "struct xmltoken\n" );
+print ( GPERF "{\n" );
+print ( GPERF "  const sal_Char *name; sal_Int32 nToken; \n" );
+print ( GPERF "};\n" );
+print ( GPERF "%%\n" );
+
+print ( HXX "#ifndef INCLUDED_AUTOGEN_TOKEN_HXX\n" );
+print ( HXX "#define INCLUDED_AUTOGEN_TOKEN_HXX\n\n" );
+print ( HXX "#include <sal/types.h>\n\n" );
+
+$i = 0;
+foreach( sort(keys(%tokens)) )
+{
+	print( HXX "const sal_Int32 $tokens{$_} = $i;\n" );
+	print( GPERF "$_,$tokens{$_}\n" );
+	$i = $i + 1;
+}
+print ( GPERF "%%\n" );
+print ( HXX "const sal_Int32 XML_TOKEN_COUNT = $i;\n" );
+print ( HXX "const sal_Int32 XML_TOKEN_INVALID = -1;\n\n" );
+print ( HXX "#endif\n" );
+close ( HXX );
+close ( GPERF );
--- filter/source/svg/gfxtypes.hxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/gfxtypes.hxx	2008-02-23 12:59:42.000000000 +0100
@@ -0,0 +1,309 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Fridrich Strba  <fridrich.strba@bluewin.ch>
+ *      Thorsten Behrens <tbehrens@novell.com>	   	
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_GFXTYPES_HXX
+#define INCLUDED_GFXTYPES_HXX
+
+#include <basegfx/range/b2drange.hxx>
+#include <basegfx/matrix/b2dhommatrix.hxx>
+#include <basegfx/polygon/b2dlinegeometry.hxx>
+
+#include <hash_set>
+#include <hash_map>
+
+namespace svgi
+{
+
+struct ARGBColor
+{
+    double toDoubleColor( sal_uInt8 val ) { return val/255.0; }
+
+    ARGBColor() : a(0.0), r(0.0), g(0.0), b(0.0)
+    {}
+    explicit ARGBColor(double fGrey) : a(1.0), r(fGrey), g(fGrey), b(fGrey)
+    {}
+    ARGBColor( double r_, double g_, double b_ ) : 
+        a(1.0), r(r_), g(g_), b(b_)
+    {}
+    ARGBColor( double a_, double r_, double g_, double b_ ) : 
+        a(a_), r(r_), g(g_), b(b_)
+    {}
+    ARGBColor( int r_, int g_, int b_ ) : 
+        a(1.0),
+        r(toDoubleColor(r_)), 
+        g(toDoubleColor(g_)), 
+        b(toDoubleColor(b_))
+    {}
+    ARGBColor( int a_, int r_, int g_, int b_ ) : 
+        a(toDoubleColor(a_)), 
+        r(toDoubleColor(r_)), 
+        g(toDoubleColor(g_)), 
+        b(toDoubleColor(b_))
+    {}
+    double a;
+    double r;
+    double g;
+    double b;
+};
+inline bool operator==( const ARGBColor& rLHS, const ARGBColor& rRHS )
+{ return rLHS.a==rRHS.a && rLHS.r==rRHS.r && rLHS.g==rRHS.g && rLHS.b==rRHS.b; }
+
+struct GradientStop
+{
+    GradientStop() : maStopColor(), mnStopPosition(0.0)
+    {}
+    ARGBColor maStopColor;
+    double    mnStopPosition;
+};
+inline bool operator==( const GradientStop& rLHS, const GradientStop& rRHS )
+{ return rLHS.mnStopPosition==rRHS.mnStopPosition && rLHS.maStopColor==rRHS.maStopColor; }
+
+struct Gradient
+{
+    Gradient() : maStops(), mbBoundingBoxUnits(false)
+    {}
+    std::vector<GradientStop> maStops;
+    bool                      mbBoundingBoxUnits;
+};
+
+inline bool operator==( const Gradient& rLHS, const Gradient& rRHS )
+{ return rLHS.mbBoundingBoxUnits==rRHS.mbBoundingBoxUnits && rLHS.maStops==rRHS.maStops; }
+
+enum PaintType
+{
+    NONE,
+    SOLID,
+    GRADIENT
+};
+
+enum FillRule
+{
+    NON_ZERO,
+    EVEN_ODD
+};
+
+enum TextAlign
+{
+    BEFORE,
+    CENTER,
+    AFTER
+};
+
+enum CapStyle
+{
+    BUTT,
+    RECT,
+    ROUND
+};
+
+enum FontStyle
+{
+    STYLE_NORMAL,
+    STYLE_OBLIQUE,
+    STYLE_ITALIC
+};
+
+enum FontVariant
+{
+    VARIANT_NORMAL,
+    VARIANT_SMALLCAPS
+};
+
+struct State
+{
+    State() :
+        maCTM(),
+        maTransform(),
+        maViewport(),
+        maViewBox(),
+        maFontFamily(), // app-default
+        mnFontSize(12.0),
+        meFontStyle(STYLE_NORMAL),
+        meFontVariant(VARIANT_NORMAL),
+        mnFontWeight(400.0),
+        meTextAnchor(BEFORE),
+        meTextDisplayAlign(BEFORE),
+        mnTextLineIncrement(0.0),
+        maCurrentColor(1.0),
+        mbVisibility(true),
+        meFillType(NONE),
+        mnFillOpacity(1.0),
+        meStrokeType(NONE),
+        mnStrokeOpacity(1.0),
+        meViewportFillType(NONE),
+        mnViewportFillOpacity(1.0),
+        maFillColor(0.0),
+        maFillGradient(),
+        meFillRule(NON_ZERO),
+        maStrokeColor(0.0),
+        maStrokeGradient(),
+        maDashArray(),
+        mnDashOffset(0.0),
+        meLineCap(BUTT),
+        meLineJoin(basegfx::tools::B2DLINEJOIN_MITER),
+        mnMiterLimit(4.0),
+        mnStrokeWidth(1.0),
+        maViewportFillColor(1.0),
+        maViewportFillGradient(),
+        mnStyleId(0)
+    {}
+
+    basegfx::B2DHomMatrix       maCTM;
+    basegfx::B2DHomMatrix       maTransform;
+    basegfx::B2DRange           maViewport;
+    basegfx::B2DRange           maViewBox;
+
+    rtl::OUString               maFontFamily;
+    /** Absolute: xx-small=6.94 | x-small=8.33 | small=10 | medium=12 | large=14.4 | x-large=17.28 | xx-large=20.736
+
+        Relative(to parent): larger (enlarge by 1.2)
+                             smaller (shrink by 1.2)
+
+     */
+    double                      mnFontSize;
+    FontStyle                   meFontStyle;
+    FontVariant                 meFontVariant;
+    double                      mnFontWeight;
+
+    TextAlign                   meTextAnchor; // text-anchor
+    TextAlign                   meTextDisplayAlign; // display-align
+    double                      mnTextLineIncrement; // 0.0 means auto
+
+    ARGBColor                   maCurrentColor;
+    bool                        mbVisibility;
+
+    PaintType                   meFillType;
+    double                      mnFillOpacity;
+    PaintType                   meStrokeType;
+    double                      mnStrokeOpacity;
+    PaintType                   meViewportFillType;
+    double                      mnViewportFillOpacity;
+
+    ARGBColor                   maFillColor;
+    Gradient                    maFillGradient;
+    FillRule                    meFillRule;
+
+    ARGBColor                   maStrokeColor;
+    Gradient                    maStrokeGradient;
+    std::vector<double>         maDashArray;
+    double                      mnDashOffset;
+    CapStyle                    meLineCap;
+    basegfx::tools::B2DLineJoin meLineJoin;
+    double                      mnMiterLimit;
+    double                      mnStrokeWidth;
+
+    ARGBColor                   maViewportFillColor;
+    Gradient                    maViewportFillGradient;
+
+    sal_Int32                   mnStyleId;
+};
+
+inline bool operator==(const State& rLHS, const State& rRHS )
+{
+    return rLHS.maCTM==rRHS.maCTM &&
+        rLHS.maTransform==rRHS.maTransform &&
+        rLHS.maViewport==rRHS.maViewport &&
+        rLHS.maViewBox==rRHS.maViewBox &&
+        rLHS.maFontFamily==rRHS.maFontFamily &&
+        rLHS.mnFontSize==rRHS.mnFontSize &&
+        rLHS.meFontStyle==rRHS.meFontStyle &&
+        rLHS.meFontVariant==rRHS.meFontVariant &&
+        rLHS.mnFontWeight==rRHS.mnFontWeight &&
+        rLHS.meTextAnchor==rRHS.meTextAnchor &&
+        rLHS.meTextDisplayAlign==rRHS.meTextDisplayAlign &&
+        rLHS.mnTextLineIncrement==rRHS.mnTextLineIncrement &&
+        rLHS.maCurrentColor==rRHS.maCurrentColor &&
+        rLHS.mbVisibility==rRHS.mbVisibility &&
+        rLHS.meFillType==rRHS.meFillType &&
+        rLHS.mnFillOpacity==rRHS.mnFillOpacity &&
+        rLHS.meStrokeType==rRHS.meStrokeType &&
+        rLHS.mnStrokeOpacity==rRHS.mnStrokeOpacity &&
+        rLHS.meViewportFillType==rRHS.meViewportFillType &&
+        rLHS.mnViewportFillOpacity==rRHS.mnViewportFillOpacity &&
+        rLHS.maFillColor==rRHS.maFillColor &&
+        rLHS.maFillGradient==rRHS.maFillGradient &&
+        rLHS.meFillRule==rRHS.meFillRule &&
+        rLHS.maStrokeColor==rRHS.maStrokeColor &&
+        rLHS.maStrokeGradient==rRHS.maStrokeGradient &&
+        rLHS.maDashArray==rRHS.maDashArray &&
+        rLHS.mnDashOffset==rRHS.mnDashOffset &&
+        rLHS.meLineCap==rRHS.meLineCap &&
+        rLHS.meLineJoin==rRHS.meLineJoin &&
+        rLHS.mnMiterLimit==rRHS.mnMiterLimit &&
+        rLHS.mnStrokeWidth==rRHS.mnStrokeWidth &&
+        rLHS.maViewportFillColor==rRHS.maViewportFillColor &&
+        rLHS.maViewportFillGradient==rRHS.maViewportFillGradient;
+}
+        
+struct StateHash
+{
+    size_t operator()(const State& rState ) const
+    {
+        return size_t(rState.maCTM.get( 0, 0 ))
+            ^  size_t(rState.maCTM.get( 1, 0 ))
+            ^  size_t(rState.maCTM.get( 0, 1 ))
+            ^  size_t(rState.maCTM.get( 1, 1 ))
+            ^  size_t(rState.maCTM.get( 0, 2 ))
+            ^  size_t(rState.maCTM.get( 1, 2 ))
+            ^  size_t(rState.maViewport.getWidth())
+            ^  size_t(rState.maViewport.getHeight())
+            ^  size_t(rState.maViewBox.getWidth())
+            ^  size_t(rState.maViewBox.getHeight())
+            ^  size_t(rState.maFontFamily.hashCode())
+            ^  size_t(rState.mnFontSize)
+            ^  size_t(rState.meFontStyle)
+            ^  size_t(rState.meFontVariant)
+            ^  size_t(rState.mnFontWeight)
+            ^  size_t(rState.meTextAnchor)
+            ^  size_t(rState.meTextDisplayAlign)
+            ^  size_t(rState.mnTextLineIncrement)
+            ^  size_t(rState.mbVisibility)
+            ^  size_t(rState.meFillType)
+            ^  size_t(rState.mnFillOpacity)
+            ^  size_t(rState.meStrokeType)
+            ^  size_t(rState.mnStrokeOpacity)
+            ^  size_t(rState.meViewportFillType)
+            ^  size_t(rState.mnViewportFillOpacity)
+            ^  size_t(rState.maFillColor.a)
+            ^  size_t(rState.maFillColor.r)
+            ^  size_t(rState.maFillColor.g)
+            ^  size_t(rState.maFillColor.b)
+            ^  size_t(rState.maFillGradient.maStops.size())
+            ^  size_t(rState.meFillRule)
+            ^  size_t(rState.maStrokeColor.a)
+            ^  size_t(rState.maStrokeColor.r)
+            ^  size_t(rState.maStrokeColor.g)
+            ^  size_t(rState.maStrokeColor.b)
+            ^  size_t(rState.maStrokeGradient.maStops.size())
+            ^  size_t(rState.maDashArray.size())
+            ^  size_t(rState.mnDashOffset)
+            ^  size_t(rState.meLineCap)
+            ^  size_t(rState.meLineJoin)
+            ^  size_t(rState.mnMiterLimit)
+            ^  size_t(rState.mnStrokeWidth)
+            ^  size_t(rState.maViewportFillColor.a)
+            ^  size_t(rState.maViewportFillColor.r)
+            ^  size_t(rState.maViewportFillColor.g)
+            ^  size_t(rState.maViewportFillColor.b)
+            ^  size_t(rState.maViewportFillGradient.maStops.size());
+    }
+};
+
+typedef std::hash_set<State, StateHash> StatePool;
+typedef std::hash_map<sal_Int32, State> StateMap;
+
+} // namespace svgi
+
+#endif
--- filter/source/svg/makefile.mk	2008-02-26 11:23:18.000000000 +0100
+++ filter/source/svg/makefile.mk	2008-02-23 15:23:12.000000000 +0100
@@ -34,47 +34,48 @@
 #*************************************************************************
 
 PRJ=..$/..
+
 PRJNAME=filter
 TARGET=svgfilter
-
 ENABLE_EXCEPTIONS=TRUE
 
 # --- Settings ----------------------------------
 
-.INCLUDE :  	settings.mk
+.INCLUDE :  settings.mk
+.INCLUDE :	libs.mk
 
 # --- Types -------------------------------------
 
-SLOFILES=	$(SLO)$/svguno.obj			\
-			$(SLO)$/svgfilter.obj		\
+SLOFILES= \
+			$(SLO)$/b2dellipse.obj	\
+			$(SLO)$/parserfragments.obj	\
 			$(SLO)$/svgexport.obj		\
+			$(SLO)$/svgfilter.obj		\
 			$(SLO)$/svgfontexport.obj	\
-			$(SLO)$/svgwriter.obj	
-.IF "$(SOLAR_JAVA)"!=""
-SLOFILES+=		$(SLO)$/svgimport.obj
-.ENDIF
+			$(SLO)$/svgimport.obj		\
+			$(SLO)$/svgreader.obj		\
+			$(SLO)$/svguno.obj			\
+			$(SLO)$/svgwriter.obj		\
+			$(SLO)$/tokenmap.obj        \
+			$(SLO)$/units.obj
 
 # --- Library -----------------------------------
 
 SHL1TARGET=$(TARGET)$(UPD)$(DLLPOSTFIX)
 
 SHL1STDLIBS=\
+	$(BASEGFXLIB)		\
 	$(SVXLIB)			\
 	$(XMLOFFLIB)		\
-	$(GOODIESLIB)		\
+	$(BASEGFXLIB)		\
 	$(VCLLIB)			\
 	$(UNOTOOLSLIB)		\
 	$(TOOLSLIB)			\
 	$(COMPHELPERLIB)	\
 	$(CPPUHELPERLIB)	\
 	$(CPPULIB)			\
-	$(SALLIB) 
-
-.IF "$(SOLAR_JAVA)"!=""
-SHL1STDLIBS+=\
-	$(JVMACCESSLIB)
-.ENDIF
-
+	$(SALLIB)			\
+	$(LIBXML)
 
 SHL1DEPN=
 SHL1IMPLIB=	i$(SHL1TARGET)
@@ -87,3 +88,15 @@
 # --- Targets ----------------------------------
 
 .INCLUDE : target.mk
+
+# Generate gperf files - from oox/source/token
+$(INCCOM)$/tokens.hxx $(MISC)$/tokens.gperf : tokens.txt gentoken.pl
+		$(PERL) gentoken.pl tokens.txt $(INCCOM)$/tokens.hxx $(MISC)$/tokens.gperf
+
+$(INCCOM)$/tokens.cxx : $(MISC)$/tokens.gperf makefile.mk
+		gperf --compare-strncmp -C -m 20 $(MISC)$/tokens.gperf | $(SED) -e "s/(char\*)0/(char\*)0, 0/g" >$(INCCOM)$/tokens.cxx
+
+$(SLO)$/tokenmap.obj : $(INCCOM)$/tokens.cxx $(INCCOM)$/tokens.hxx
+
+$(SLO)$/svgreader.obj : $(INCCOM)$/tokens.cxx $(INCCOM)$/tokens.hxx
+
--- filter/source/svg/parserfragments.cxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/parserfragments.cxx	2008-02-26 11:49:33.000000000 +0100
@@ -0,0 +1,384 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Fridrich Strba  <fridrich.strba@bluewin.ch>
+ *      Thorsten Behrens <tbehrens@novell.com>	   	
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_filter.hxx"
+
+#include "parserfragments.hxx"
+#include "gfxtypes.hxx"
+
+#include <basegfx/tools/canvastools.hxx>
+#include <com/sun/star/geometry/AffineMatrix2D.hpp>
+
+#include <boost/bind.hpp>
+#include <boost/spirit.hpp>
+#include <boost/spirit/dynamic/while.hpp>
+#include <numeric>
+#include <algorithm>
+
+#include "units.hxx"
+
+using namespace ::com::sun::star;
+
+namespace svgi
+{
+
+inline sal_uInt8 hex2int( char val )
+{
+    return val <= '9' ? val-'0' : (val < 'a' ? val+10-'A' : val+10-'a');
+}
+
+void setFourBitColor( double& rChannel, char nChar )
+{
+    const sal_uInt8 nVal(hex2int(nChar));
+    fprintf(stderr, "setFourBitCOlor %d color\n", nVal );
+    rChannel = (nVal*16+nVal)/255.0;
+}
+
+void setEightBitColor( double& rChannel, const char* pStart, const char* )
+{
+    const sal_uInt8 nVal0(hex2int(pStart[0]));
+    const sal_uInt8 nVal1(hex2int(pStart[1]));
+    fprintf(stderr, "setEightbitCOlor %d, %d color\n", nVal0, nVal1 );
+    rChannel = (nVal0*16+nVal1)/255.0;
+}
+
+void setIntColor( double& rChannel, sal_uInt8 nVal )
+{
+    fprintf(stderr, "setIntColor %d color\n", nVal );
+    rChannel = nVal/255.0;
+}
+
+void calcRotation(std::vector<geometry::AffineMatrix2D>& rTransforms,
+                  geometry::AffineMatrix2D&              rCurrTransform,
+                  double                                 fRotationAngle)
+{
+    ::basegfx::B2DHomMatrix aCurr;
+    aCurr.translate(-rCurrTransform.m02,-rCurrTransform.m12);
+    aCurr.rotate(fRotationAngle*M_PI/180);
+    aCurr.translate(rCurrTransform.m02,rCurrTransform.m12);
+
+	fprintf(stderr, "calcRotation - fRotationAngle - %f\n", fRotationAngle);
+    rTransforms.push_back(
+        basegfx::unotools::affineMatrixFromHomMatrix(
+            rCurrTransform,
+            aCurr));
+}
+
+void calcSkewX(std::vector<geometry::AffineMatrix2D>& rTransforms,
+               double                                 fSkewAngle)
+{
+    geometry::AffineMatrix2D aMat(1.0,0.0,0.0,
+                                  tan(fSkewAngle),1.0,0.0);
+    rTransforms.push_back(aMat);
+}
+
+void calcSkewY(std::vector<geometry::AffineMatrix2D>& rTransforms,
+               double                                 fSkewAngle)
+{
+    geometry::AffineMatrix2D aMat(1.0,tan(fSkewAngle),0.0,
+                                  0.0,1.0,0.0);
+    rTransforms.push_back(aMat);
+}
+
+geometry::AffineMatrix2D multiplyMatrix( const geometry::AffineMatrix2D& rLHS,
+                                         const geometry::AffineMatrix2D& rRHS )
+{
+    basegfx::B2DHomMatrix aLHS;
+    basegfx::B2DHomMatrix aRHS;
+
+    basegfx::unotools::homMatrixFromAffineMatrix(aLHS,rLHS);
+    basegfx::unotools::homMatrixFromAffineMatrix(aRHS,rRHS);
+
+    aRHS*=aLHS;
+
+    geometry::AffineMatrix2D aRet;
+    return basegfx::unotools::affineMatrixFromHomMatrix(aRet,aRHS);
+}
+
+bool parseColor( const char* sColor, ARGBColor& rColor  )
+{
+    using namespace ::boost::spirit;
+
+    int_parser<sal_uInt8,10,1,3> byte_p;
+
+    return parse(sColor,
+        //  Begin grammar
+        (
+            // the #rrggbb form
+            ('#' >> (xdigit_p >> xdigit_p)[boost::bind(&setEightBitColor,
+                                                       boost::ref(rColor.r),_1,_2)]
+                 >> (xdigit_p >> xdigit_p)[boost::bind(&setEightBitColor,
+                                                       boost::ref(rColor.g),_1,_2)]
+                 >> (xdigit_p >> xdigit_p)[boost::bind(&setEightBitColor,
+                                                       boost::ref(rColor.b),_1,_2)]) 
+          |
+            // the #rgb form
+            ('#' >> xdigit_p[boost::bind(&setFourBitColor,
+                                         boost::ref(rColor.r),_1)] 
+                 >> xdigit_p[boost::bind(&setFourBitColor,
+                                         boost::ref(rColor.g),_1)] 
+                 >> xdigit_p[boost::bind(&setFourBitColor,
+                                         boost::ref(rColor.b),_1)]) 
+          |
+            // rgb() form
+            (str_p("rgb") 
+             >> '(' >>
+                         // rgb(int,int,int)
+                         (byte_p[boost::bind(&setIntColor,
+                                             boost::ref(rColor.r),_1)] >> ',' >>
+                          byte_p[boost::bind(&setIntColor,
+                                             boost::ref(rColor.g),_1)] >> ',' >>
+                          byte_p[boost::bind(&setIntColor,
+                                             boost::ref(rColor.b),_1)])
+                       |  
+                         // rgb(double,double,double)
+                         (real_p[assign_a(rColor.r)] >> ',' >>
+                          real_p[assign_a(rColor.g)] >> ',' >>
+                          real_p[assign_a(rColor.b)])
+             >> ')')
+          |  
+            str_p("black")[assign_a(rColor,ARGBColor(0,0,0))]
+          |
+            str_p("silver")[assign_a(rColor,ARGBColor(192,192,192))]
+          |  
+            str_p("gray")[assign_a(rColor,ARGBColor(128,128,128))]
+          |  
+            str_p("white")[assign_a(rColor,ARGBColor(255,255,255))]
+          |  
+            str_p("maroon")[assign_a(rColor,ARGBColor(128,0,0))]
+          |  
+            str_p("red")[assign_a(rColor,ARGBColor(255,0,0))]
+          |  
+            str_p("purple")[assign_a(rColor,ARGBColor(128,0,128))]
+          |  
+            str_p("fuchsia")[assign_a(rColor,ARGBColor(255,0,255))]
+          |  
+            str_p("green")[assign_a(rColor,ARGBColor(0,128,0))]
+          |  
+            str_p("lime")[assign_a(rColor,ARGBColor(0,255,0))]
+          |  
+            str_p("olive")[assign_a(rColor,ARGBColor(128,128,0))]
+          |  
+            str_p("yellow")[assign_a(rColor,ARGBColor(255,255,0))]
+          |  
+            str_p("navy")[assign_a(rColor,ARGBColor(0,0,128))]
+          |  
+            str_p("blue")[assign_a(rColor,ARGBColor(0,0,255))]
+          |  
+            str_p("teal")[assign_a(rColor,ARGBColor(0,128,128))]
+          |  
+            str_p("aqua")[assign_a(rColor,ARGBColor(0,255,255))]
+        ),
+        //  End grammar
+        space_p).full;
+}
+
+//////////////////////////////////////////////////////////////
+
+bool parseTransform( const char* sTransform, basegfx::B2DHomMatrix& rTransform )
+{
+    using namespace ::boost::spirit;
+
+    double fRefOffsetX(0.0);
+    double fRefOffsetY(0.0);
+    bool   bRefTransform(false);
+
+    double fRotationAngle=0.0;
+    double fSkewAngle=0.0;
+    geometry::AffineMatrix2D aIdentityTransform;
+    geometry::AffineMatrix2D aCurrTransform;
+    std::vector<geometry::AffineMatrix2D> aTransforms;
+    aIdentityTransform.m00 = 1.0; aIdentityTransform.m11 = 1.0;
+    aCurrTransform = aIdentityTransform;
+    
+    const bool bRes = parse(sTransform,
+        //  Begin grammar
+        (
+            // identity transform
+            str_p("none")
+          |
+            // the ref() form
+            (str_p("ref")
+             >> '('
+             >> str_p("svg")[assign_a(bRefTransform,true)] 
+             >> !(real_p[assign_a(fRefOffsetX)] >> ',' >>
+                  real_p[assign_a(fRefOffsetY)])
+             >> ')')
+          |
+            // the transform-list form
+            (list_p(
+               (   
+                 // matrix(a,b,c,d,e,f)  
+                 (str_p("matrix") 
+                  >> '('
+                  >> real_p[assign_a(aCurrTransform.m00)] >> ',' 
+                  >> real_p[assign_a(aCurrTransform.m10)] >> ',' 
+                  >> real_p[assign_a(aCurrTransform.m01)] >> ',' 
+                  >> real_p[assign_a(aCurrTransform.m11)] >> ',' 
+                  >> real_p[assign_a(aCurrTransform.m02)] >> ',' 
+                  >> real_p[assign_a(aCurrTransform.m12)]
+                  >> ')')[push_back_a(aTransforms,aCurrTransform)]
+               |  
+                 // translate(x,[y])
+                 (str_p("translate") 
+                  >> '('
+                  >> real_p[assign_a(aCurrTransform.m02)]
+                  >> !(',' >> real_p[assign_a(aCurrTransform.m12)])
+                  >> ')')[push_back_a(aTransforms,aCurrTransform)]
+               |  
+                 // scale(x,[y])
+                 (str_p("scale") 
+                  >> '('
+                  >> real_p[assign_a(aCurrTransform.m00)]
+                  >> !(',' >> real_p[assign_a(aCurrTransform.m11)])
+                  >> ')')[push_back_a(aTransforms,aCurrTransform)]
+               |  
+                 // rotate(phi,[cx, cy])
+                 (str_p("rotate") 
+                  >> '('
+                  >> real_p[assign_a(fRotationAngle)] >> ')')[boost::bind(&calcRotation,
+                                                  boost::ref(aTransforms),
+                                                  boost::ref(aCurrTransform),
+                                                  boost::cref(fRotationAngle))]
+               |  
+                 // skewX(phi)
+                 (str_p("skewX") 
+                  >> '(' 
+                  >> real_p[assign_a(fSkewAngle)] 
+                  >> ')')[boost::bind(&calcSkewX,
+                                      boost::ref(aTransforms),
+                                      boost::cref(fSkewAngle))]
+               |  
+                 // skewY(phi)
+                 (str_p("skewY") 
+                  >> '(' 
+                  >> real_p[assign_a(fSkewAngle)] 
+                  >> ')')[boost::bind(&calcSkewY,
+                                      boost::ref(aTransforms),
+                                      boost::cref(fSkewAngle))]
+                 // reset current transform after every push
+               )[assign_a(aCurrTransform,aIdentityTransform)],
+                 // list delimiter is either ',' or space
+                ',' | eps_p ))
+        ),
+        //  End grammar
+        space_p).full;
+
+    if( !bRes )
+        return false;
+
+    // fold all transformations into one
+    const geometry::AffineMatrix2D aTotalTransform(
+        std::accumulate(aTransforms.begin(),
+                        aTransforms.end(),
+                        aIdentityTransform,
+                        &multiplyMatrix));
+
+    basegfx::unotools::homMatrixFromAffineMatrix(
+        rTransform,
+        aTotalTransform);
+
+    // TODO(F1): handle the ref case
+    return bRes;
+}
+
+//////////////////////////////////////////////////////////////
+
+bool parseViewBox( const char* sViewbox, basegfx::B2DRange& rRect )
+{
+    using namespace ::boost::spirit;
+
+    double x=0.0,y=0.0,w=0.0,h=0.0;
+    
+    const bool bRes = parse(sViewbox,
+        //  Begin grammar
+        (
+            // either comma- or space-delimited list of four doubles
+            (real_p[assign_a(x)] >> ',' >>
+             real_p[assign_a(y)] >> ',' >>
+             real_p[assign_a(w)] >> ',' >>
+             real_p[assign_a(h)])
+           | 
+            (real_p[assign_a(x)] >>
+             real_p[assign_a(y)] >>
+             real_p[assign_a(w)] >>
+             real_p[assign_a(h)])
+        ),
+        //  End grammar
+        space_p).full;
+
+    if( !bRes )
+        return false;
+
+    rRect = basegfx::B2DRange(x,y,x+w,y+h);
+
+    return true;
+}
+
+//////////////////////////////////////////////////////////////
+
+bool parseDashArray( const char* sDashArray, std::vector<double>& rOutputVector )
+{
+    using namespace ::boost::spirit;
+    
+    rOutputVector.clear();
+    return parse(sDashArray,
+        //  Begin grammar
+        (
+            // parse comma-delimited list of doubles
+            list_p(real_p[push_back_a(rOutputVector)])
+        ),
+        //  End grammar
+        space_p).full;
+}
+
+//////////////////////////////////////////////////////////////
+
+namespace
+{
+void appendChar( std::string& str, char character)
+{
+	str.append(1,character);
+}
+}
+
+bool parseXlinkHref( const char* sXlinkHref, std::string& data )
+{
+	using namespace ::boost::spirit;
+	
+	data.erase(data.begin(),data.end());
+
+    return parse(sXlinkHref,
+        //  Begin grammar
+        (
+            // the data uri
+            (str_p("data:") >> while_p(~eps_p(','))[anychar_p] >>
+			 ',' >> repeat_p(1, more)[anychar_p[boost::bind(&appendChar,
+                                      boost::ref(data),
+                                      _1)]]) 
+#if 0
+          |
+            // the "normal" uri
+            (repeat_p(1, more)[anychar_p[boost::bind(&appendChar,
+                                      boost::ref(data),
+                                      _1)]]) 
+#endif
+        ),
+        //  End grammar
+        space_p).full;
+}
+
+} // namespace svgi
--- filter/source/svg/parserfragments.hxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/parserfragments.hxx	2008-02-26 11:45:57.000000000 +0100
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Fridrich Strba  <fridrich.strba@bluewin.ch>
+ *      Thorsten Behrens <tbehrens@novell.com>	   	
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_PARSERFRAGMENTS_HXX
+#define INCLUDED_PARSERFRAGMENTS_HXX
+
+#include <sal/config.h>
+#include <vector>
+#include <string>
+
+namespace basegfx
+{ 
+    class B2DHomMatrix; 
+    class B2DRange; 
+}
+namespace svgi
+{
+    struct ARGBColor;
+
+    /// Parse given string for one of the SVG color grammars
+    bool parseColor( const char* sColor, ARGBColor& rColor );
+
+    /// Parse given string for one of the SVG transformation grammars
+    bool parseTransform( const char* sTransform, basegfx::B2DHomMatrix& rTransform );
+
+    /// Parse given string for the viewBox attribute
+    bool parseViewBox( const char* sViewbox, basegfx::B2DRange& rRect );
+
+    /// Parse given string for a list of double values, comma-delimited
+    bool parseDashArray( const char* sDashArray, std::vector<double>& rOutputVector );
+	
+	/// Parse given string for the xlink attribute
+	bool parseXlinkHref( const char* xlink, std::string& data );
+
+} // namespace svgi
+
+#endif
--- filter/source/svg/svgfilter.cxx	2008-02-26 11:23:18.000000000 +0100
+++ filter/source/svg/svgfilter.cxx	2008-02-23 12:59:42.000000000 +0100
@@ -96,11 +96,9 @@
     if( pFocusWindow )
     	pFocusWindow->EnterWait();
 
-#ifdef SOLAR_JAVA
     if( mxDstDoc.is() )
         bRet = implImport( rDescriptor );
     else
-#endif
     if( mxSrcDoc.is() )
 	{
 		uno::Reference< frame::XDesktop > xDesktop( mxMSF->createInstance( ::rtl::OUString::createFromAscii( "com.sun.star.frame.Desktop" ) ), 
@@ -169,13 +167,11 @@
 
 // -----------------------------------------------------------------------------
 
-#ifdef SOLAR_JAVA
 void SAL_CALL SVGFilter::setTargetDocument( const Reference< XComponent >& xDoc ) 
 	throw (::com::sun::star::lang::IllegalArgumentException, RuntimeException)
 {
 	mxDstDoc = xDoc;
 }
-#endif
 
 // -----------------------------------------------------------------------------
 
@@ -194,25 +190,29 @@
 
 // -----------------------------------------------------------------------------
 
-#define SERVICE_NAME "com.sun.star.document.SVGFilter"
+#define SERVICE_NAME1 "com.sun.star.document.ImportFilter"
+#define SERVICE_NAME2 "com.sun.star.document.ExportFilter"
 
 sal_Bool SAL_CALL SVGFilter_supportsService( const OUString& ServiceName ) 
 	throw (RuntimeException)
 {
-    return ServiceName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM ( SERVICE_NAME ) );
+	return (ServiceName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM ( SERVICE_NAME1 ) ) ||
+		ServiceName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM ( SERVICE_NAME2 ) ) );
 }
 
 // -----------------------------------------------------------------------------
 
 Sequence< OUString > SAL_CALL SVGFilter_getSupportedServiceNames(  ) throw (RuntimeException)
 {
-	Sequence < OUString > aRet(1);
-    OUString* pArray = aRet.getArray();
-    pArray[0] =  OUString ( RTL_CONSTASCII_USTRINGPARAM ( SERVICE_NAME ) );
-    return aRet;
+	Sequence < OUString > aRet(2);
+	OUString* pArray = aRet.getArray();
+	pArray[0] =  OUString ( RTL_CONSTASCII_USTRINGPARAM ( SERVICE_NAME1 ) );
+	pArray[1] =  OUString ( RTL_CONSTASCII_USTRINGPARAM ( SERVICE_NAME2 ) ); 
+	return aRet;
 }
 
-#undef SERVICE_NAME
+#undef SERVICE_NAME1
+#undef SERVICE_NAME2
 
 // -----------------------------------------------------------------------------
 
--- filter/source/svg/svgfilter.hxx	2008-02-26 11:23:18.000000000 +0100
+++ filter/source/svg/svgfilter.hxx	2008-02-23 12:59:42.000000000 +0100
@@ -231,18 +231,11 @@
 class SVGActionWriter;
 class EditFieldInfo;
 
-#ifdef SOLAR_JAVA
 class SVGFilter : public cppu::WeakImplHelper5 < XFilter,
 											     XImporter,
                                                  XExporter,
 												 XInitialization,
 												 XServiceInfo >
-#else // !SOLAR_JAVA
-class SVGFilter : public cppu::WeakImplHelper4 < XFilter,
-                                                 XExporter,
-                                                 XInitialization,
-                                                 XServiceInfo >
-#endif
 {
 	typedef ::std::hash_map< Reference< XInterface >, ObjectRepresentation, HashReferenceXInterface > ObjectMap;
 
@@ -259,15 +252,11 @@
 
 	ObjectMap*							mpObjects;
 	Reference< XComponent >				mxSrcDoc;
-#ifdef SOLAR_JAVA
 	Reference< XComponent >				mxDstDoc;
-#endif
 	Reference< XDrawPage > 				mxDefaultPage;
 	Link								maOldFieldHdl;
 
-#ifdef SOLAR_JAVA
     sal_Bool                            implImport( const Sequence< PropertyValue >& rDescriptor ) throw (RuntimeException);
-#endif
 
     sal_Bool                            implExport( const Sequence< PropertyValue >& rDescriptor ) throw (RuntimeException);
     Reference< XDocumentHandler >       implCreateExportDocumentHandler( const Reference< XOutputStream >& rxOStm );
@@ -306,10 +295,8 @@
     virtual sal_Bool SAL_CALL filter( const Sequence< PropertyValue >& rDescriptor ) throw(RuntimeException);
     virtual void SAL_CALL cancel( ) throw (RuntimeException);
 
-#ifdef SOLAR_JAVA
 	// XImporter
     virtual void SAL_CALL setTargetDocument( const Reference< XComponent >& xDoc ) throw(IllegalArgumentException, RuntimeException);
-#endif
 
 	// XExporter
     virtual void SAL_CALL setSourceDocument( const Reference< XComponent >& xDoc ) throw(IllegalArgumentException, RuntimeException);
--- filter/source/svg/svgimport.cxx	2008-02-26 11:23:18.000000000 +0100
+++ filter/source/svg/svgimport.cxx	2008-02-23 12:59:42.000000000 +0100
@@ -37,160 +37,59 @@
 #include "precompiled_filter.hxx"
 
 #include "svgfilter.hxx" 
+#include "svgreader.hxx" 
+
 #include "rtl/ref.hxx"
-#include "jvmaccess/virtualmachine.hxx"
-// -------------
-// - SVGFilter -
-// -------------
+
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+
+#include <com/sun/star/lang/XComponent.hpp>
+
+#include <com/sun/star/uno/Any.hxx>
+#include <com/sun/star/uno/Type.hxx>
+
+#include <com/sun/star/beans/PropertyValue.hpp>
+
+#include <com/sun/star/xml/sax/XParser.hpp>
+#include <com/sun/star/xml/sax/InputSource.hpp>
+#include <com/sun/star/xml/XImportFilter.hpp>
+
+#include <com/sun/star/io/XActiveDataSource.hpp>
+#include <com/sun/star/task/XStatusIndicator.hpp>
+
+using namespace ::com::sun::star;
+using namespace ::svgi;
 
 sal_Bool SVGFilter::implImport( const Sequence< PropertyValue >& rDescriptor )
 	throw (RuntimeException)
 {
-    Reference< XMultiServiceFactory >	xServiceFactory( ::comphelper::getProcessServiceFactory() ) ;
-	rtl::OUString							aTmpFileName;
-	String								aFileName;
-	sal_Int32							nLength = rDescriptor.getLength();
-	const PropertyValue*				pValue = rDescriptor.getConstArray();
-	sal_Bool							bRet = sal_False;
-	
-	for( sal_Int32 i = 0 ; ( i < nLength ) && !aTmpFileName.getLength(); i++)
-		if( pValue[ i ].Name.equalsAscii( "FileName" ) )
-			pValue[ i ].Value >>= aTmpFileName;
-
-    if( aTmpFileName.getLength() && xServiceFactory.is() )
-    {
-
-	    Reference< XJavaVM >    xJavaVM( xServiceFactory->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("com.sun.star.java.JavaVirtualMachine") ) ), UNO_QUERY );
-        Sequence< sal_Int8 >    aProcessID( 17 );
-		String					aLocalFile;
-
-		if( ::utl::LocalFileHelper::ConvertURLToPhysicalName( aTmpFileName, aLocalFile ) && aLocalFile.Len() )
+    rtl::OUString aURL;
+    uno::Reference< io::XInputStream > xInputStream;
+    uno::Reference< task::XStatusIndicator > xStatus;
+    const sal_Int32 nLength = rDescriptor.getLength();
+    const beans::PropertyValue* pAttribs = rDescriptor.getConstArray();
+    for ( sal_Int32 i=0 ; i<nLength; ++i, ++pAttribs )
+	{
+        if( pAttribs->Name.equalsAscii( "InputStream" ) )
         {
-			rtl_getGlobalProcessId( (sal_uInt8 *) aProcessID.getArray() );
-            aProcessID[16] = 0;            
-		
-            OSL_ENSURE(sizeof (sal_Int64)
-                       >= sizeof (jvmaccess::VirtualMachine *),
-                       "Pointer cannot be represented as sal_Int64");
-            sal_Int64 nPointer = reinterpret_cast< sal_Int64 >(
-                static_cast< jvmaccess::VirtualMachine * >(0));
-            xJavaVM->getJavaVM(aProcessID) >>= nPointer;
-            rtl::Reference<jvmaccess::VirtualMachine> _virtualMachine =
-                reinterpret_cast< jvmaccess::VirtualMachine * >(nPointer);
-            if (!_virtualMachine.is())
-                return bRet;
-            
-            jobjectArray    aArgs;
-            jclass          aClass;
-            jmethodID       aMId;
-            jstring         aJStr;
-            
-            try
-            {
-                jvmaccess::VirtualMachine::AttachGuard vmGuard(_virtualMachine);
-                
-                JNIEnv * pEnv = vmGuard.getEnvironment();
-                
-                aClass = pEnv->FindClass( "SOTranscoder" );
-                
-                if( aClass )
-                {
-					aMId = pEnv->GetStaticMethodID( aClass, "main", "([Ljava/lang/String;)V" );
-					if ( aMId )
-					{
-
-						::utl::TempFile aTempFile;
-						String			aOutputURL( aTempFile.GetURL() );
-						String			aOutputFile;
-	                    
-						aTempFile.EnableKillingFile();
-	                    
-						if( ::utl::LocalFileHelper::ConvertURLToPhysicalName( aOutputURL, aOutputFile ) && aOutputFile.Len() )
-						{
-							aJStr = pEnv->NewStringUTF( ByteString( aLocalFile.GetBuffer(), RTL_TEXTENCODING_UTF8 ).GetBuffer() );
-							aArgs = static_cast<jobjectArray>(pEnv->NewObjectArray( 2, pEnv->FindClass( "java/lang/String" ), aJStr ));
-							aJStr = pEnv->NewStringUTF( ByteString( aOutputFile.GetBuffer(), RTL_TEXTENCODING_UTF8 ).GetBuffer() );
-							pEnv->SetObjectArrayElement( aArgs, 1, aJStr );
-							pEnv->CallStaticVoidMethod( aClass, aMId, aArgs );
-	                        
-							Graphic		aGraphic;
-							SvStream*	pIStm = ::utl::UcbStreamHelper::CreateStream( aOutputURL, STREAM_READ );
-	                        
-							if( pIStm )
-							{
-								GraphicConverter::Import( *pIStm, aGraphic );
-								delete pIStm;
-							}
-	                        
-							Reference< XDrawPagesSupplier > xDrawPagesSupplier( mxDstDoc, UNO_QUERY );
-	                        
-							if( xDrawPagesSupplier.is() && ( aGraphic.GetType() != GRAPHIC_NONE ) )
-							{
-								Reference< XDrawPages > xDrawPages( xDrawPagesSupplier->getDrawPages() );
-	                            
-								if( xDrawPages.is() && xDrawPages->getCount() )
-								{
-									Reference< XDrawPage >	xDrawPage;
-	                                
-									if( xDrawPages->getByIndex( 0 ) >>= xDrawPage )
-									{
-										Reference< XShapes >		xShapes( xDrawPage, UNO_QUERY );
-										Reference< XPropertySet>	xPagePropSet( xDrawPage, UNO_QUERY );
-										Reference< XShape >			xShape( Reference< XMultiServiceFactory >( mxDstDoc, UNO_QUERY )->createInstance( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.drawing.GraphicObjectShape" ) ) ), UNO_QUERY );
-	                                    
-										if( xPagePropSet.is() && xShapes.is() && xShape.is() )
-										{
-											Reference< XPropertySet >	xPropSet( xShape, UNO_QUERY );
-											sal_Int32					nPageWidth = 0, nPageHeight = 0;
-	                                        
-											xPagePropSet->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Width" ) ) ) >>= nPageWidth;
-											xPagePropSet->getPropertyValue( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "Height" ) ) ) >>= nPageHeight;
-	                                        
-											if( xPropSet.is() && nPageWidth && nPageHeight )
-											{
-												xShapes->add( xShape );
-	                                            
-												::com::sun::star::awt::Point	aPos;
-												::com::sun::star::awt::Size		aSize;
-												GraphicObject					aGraphObj( aGraphic );
-												String							aGraphURL( RTL_CONSTASCII_USTRINGPARAM( "vnd.sun.star.GraphicObject:" ) );
-												Any								aValue;
-												Size							aGraphicSize;
-												const MapMode					aTargetMapMode( MAP_100TH_MM );
-	                                            
-												if( aGraphObj.GetPrefMapMode().GetMapUnit() == MAP_PIXEL )
-													aGraphicSize = Application::GetDefaultDevice()->PixelToLogic( aGraphObj.GetPrefSize(), aTargetMapMode );
-												else
-													aGraphicSize = OutputDevice::LogicToLogic( aGraphObj.GetPrefSize(), aGraphObj.GetPrefMapMode(), aTargetMapMode );
-	                                            
-												aGraphURL += String( aGraphObj.GetUniqueID(), RTL_TEXTENCODING_ASCII_US );
-												aValue <<= rtl::OUString( aGraphURL );
-												xPropSet->setPropertyValue( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "GraphicURL" ) ), aValue );
-	                                            
-												aPos.X = ( nPageWidth - aGraphicSize.Width() ) >> 1;
-												aPos.Y = ( nPageHeight - aGraphicSize.Height() ) >> 1;
-	                                            
-												aSize.Width = aGraphicSize.Width();
-												aSize.Height = aGraphicSize.Height();
-	                                                
-												xShape->setPosition( aPos );
-												xShape->setSize( aSize );
-	                                            
-												bRet = sal_True;
-											}
-										}
-									}
-								}
-							}
-						}
-                    }
-                }
-            }
-            catch (jvmaccess::VirtualMachine::AttachGuard::CreationException &)
-            {
-            }
-        }            
-    }
-    return bRet;
+            pAttribs->Value >>= xInputStream;
+        }
+        else if( pAttribs->Name.equalsAscii( "StatusIndicator" ) )
+            pAttribs->Value >>= xStatus;
+	}
+
+    OSL_ASSERT(xInputStream.is());
+    if(!xInputStream.is()) 
+        return sal_False;
+
+	rtl::OUString sXMLImportService ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Draw.XMLOasisImporter" ) );
+	Reference < XDocumentHandler > xInternalHandler( mxMSF->createInstance( sXMLImportService ), UNO_QUERY );
+
+	// The XImporter sets up an empty target document for XDocumentHandler to write to.. 
+	uno::Reference < XImporter > xImporter(xInternalHandler, UNO_QUERY);
+	xImporter->setTargetDocument(mxDstDoc);
+
+    SVGReader aReader(mxMSF, xInputStream, xInternalHandler);
+    return aReader.parseAndConvert();
 }
     
--- filter/source/svg/svgreader.cxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/svgreader.cxx	2008-02-26 11:48:21.000000000 +0100
@@ -0,0 +1,1309 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Fridrich Strba  <fridrich.strba@bluewin.ch>
+ *      Thorsten Behrens <tbehrens@novell.com>	   	
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_filter.hxx"
+
+#include "svgreader.hxx"
+#include <xmloff/attrlist.hxx>
+#include "gfxtypes.hxx"
+#include "units.hxx"
+#include "parserfragments.hxx"
+#include "tokenmap.hxx"
+#include "b2dellipse.hxx"
+
+#include <rtl/math.hxx>
+#include <rtl/ref.hxx>
+#include <rtl/ustring.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <basegfx/vector/b2enums.hxx>
+#include <basegfx/range/b2drange.hxx>
+#include <basegfx/matrix/b2dhommatrix.hxx>
+#include <basegfx/polygon/b2dpolypolygon.hxx>
+#include <basegfx/polygon/b2dlinegeometry.hxx>
+#include <basegfx/polygon/b2dpolygontools.hxx>
+#include <basegfx/polygon/b2dpolypolygontools.hxx>
+#include <basegfx/polygon/b2dlinegeometry.hxx>
+#include <com/sun/star/io/XSeekable.hpp>
+#include <com/sun/star/xml/sax/XParser.hpp>
+#include <com/sun/star/xml/dom/XDocumentBuilder.hpp>
+#include <com/sun/star/xml/dom/NodeType.hpp>
+
+#include <boost/bind.hpp>
+#include <hash_set>
+
+#define USTR(x) rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+#define OASIS_STR "urn:oasis:names:tc:opendocument:xmlns:"
+
+using namespace ::com::sun::star;
+
+namespace svgi
+{
+namespace
+{
+/** Visit all elements of the given tree (in-order traversal)
+
+    Given functor is called for every element, and passed the
+    element's attributes, if any
+ */
+template<typename Func> void visitElements(Func& rFunc,
+                                           const uno::Reference<xml::dom::XElement> xElem)
+{
+    if( xElem->hasAttributes() )
+        rFunc(xElem,xElem->getAttributes());
+    else
+        rFunc(xElem);
+
+    // notify children processing
+    rFunc.push();
+
+    // recurse over children
+    uno::Reference<xml::dom::XNodeList> xChildren( xElem->getChildNodes() );
+    const sal_Int32 nNumNodes( xChildren->getLength() );
+    for( sal_Int32 i=0; i<nNumNodes; ++i )
+    {
+        if( xChildren->item(i)->getNodeType() == xml::dom::NodeType_ELEMENT_NODE )
+            visitElements( rFunc,
+                           uno::Reference<xml::dom::XElement>(
+                               xChildren->item(i),
+                               uno::UNO_QUERY_THROW) );
+    }
+
+    // children processing done
+    rFunc.pop();
+}
+
+struct AnnotatingVisitor
+{
+    AnnotatingVisitor(StatePool&                                        rStatePool,
+                      StateMap&                                         rStateMap,
+                      const uno::Reference<xml::sax::XDocumentHandler>& xDocumentHandler) :
+        mnCurrStateId(0),
+        maCurrState(),
+        maParentStates(),
+        mrStates(rStatePool),
+        mrStateMap(rStateMap),
+        mxDocumentHandler(xDocumentHandler)
+    {
+        State aState;
+        aState.maCTM = aState.maTransform;
+        maParentStates.push_back(aState);
+    }
+
+    void operator()( const uno::Reference<xml::dom::XElement>& )
+    {}
+
+    void operator()( const uno::Reference<xml::dom::XElement>&      xElem,
+                     const uno::Reference<xml::dom::XNamedNodeMap>& xAttributes )
+    {
+        // init state. inherit defaults from parent.
+        maCurrState = maParentStates.back(); 
+        maCurrState.maTransform.identity();
+
+        fprintf(stderr,"the CTM is currently #1: %f %f %f %f %f %f\n", 
+                maCurrState.maCTM.get(0,0),
+                maCurrState.maCTM.get(0,1),
+                maCurrState.maCTM.get(0,2),
+                maCurrState.maCTM.get(1,0),
+                maCurrState.maCTM.get(1,1),
+                maCurrState.maCTM.get(1,2));
+
+        // scan for style info
+        const sal_Int32 nNumElems( xAttributes->getLength() );
+        rtl::OUString sAttributeValue;
+        for( sal_Int32 i=0; i<nNumElems; ++i )
+        {
+            sAttributeValue = xAttributes->item(i)->getNodeValue();
+            const sal_Int32 nTokenId( 
+                getTokenId(xAttributes->item(i)->getNodeName()));
+            if( XML_STYLE == nTokenId )
+                parseStyle(sAttributeValue);
+            else 
+                parseAttribute(nTokenId, 
+                               xAttributes->item(i)->getNodeName(),
+                               sAttributeValue);
+        }
+
+        // all attributes parsed, can calc total CTM now
+        if( !maCurrState.maViewBox.isEmpty() &&
+            maCurrState.maViewBox.getWidth() != 0.0 && 
+            maCurrState.maViewBox.getHeight() != 0.0 )
+        {
+            // transform aViewBox into viewport, such that they
+            // coincide
+            maCurrState.maTransform.translate(-maCurrState.maViewBox.getMinX(),
+                                              -maCurrState.maViewBox.getMinY());
+            maCurrState.maTransform.scale(maCurrState.maViewport.getWidth()/maCurrState.maViewBox.getWidth(),
+                                          maCurrState.maViewport.getHeight()/maCurrState.maViewBox.getHeight());
+        }
+        maCurrState.maCTM *= maCurrState.maTransform;
+
+        fprintf(stderr,"the CTM is currently #2: %f %f %f %f %f %f\n", 
+                maCurrState.maCTM.get(0,0),
+                maCurrState.maCTM.get(0,1),
+                maCurrState.maCTM.get(0,2),
+                maCurrState.maCTM.get(1,0),
+                maCurrState.maCTM.get(1,1),
+                maCurrState.maCTM.get(1,2));
+        
+        // if necessary, serialize to automatic-style section
+        writeStyle(xElem);
+    }
+
+    rtl::OUString getStyleName( const char* sPrefix, sal_Int32 nId )
+    {
+        return rtl::OUString::createFromAscii(sPrefix)+rtl::OUString::valueOf(nId);
+    }
+
+    sal_Int8 toByteColor( double val )
+    {
+        // TODO(Q3): duplicated from vcl::unotools
+        return sal::static_int_cast<sal_Int8>(
+            basegfx::fround(val*255.0));
+    }
+
+    rtl::OUString getOdfColor( const ARGBColor& rColor )
+    {
+        // TODO(Q3): duplicated from pdfimport
+        rtl::OUStringBuffer aBuf( 7 );
+        const sal_uInt8 nRed  ( toByteColor(rColor.r)   );
+        const sal_uInt8 nGreen( toByteColor(rColor.g) );
+        const sal_uInt8 nBlue ( toByteColor(rColor.b)  );
+        aBuf.append( sal_Unicode('#') );
+        if( nRed < 10 )
+            aBuf.append( sal_Unicode('0') );
+        aBuf.append( sal_Int32(nRed), 16 );
+        if( nGreen < 10 )
+            aBuf.append( sal_Unicode('0') );
+        aBuf.append( sal_Int32(nGreen), 16 );
+        if( nBlue < 10 )
+            aBuf.append( sal_Unicode('0') );
+        aBuf.append( sal_Int32(nBlue), 16 );
+
+        // TODO(F3): respect alpha transparency (polygons etc.)
+        OSL_ASSERT(rColor.a == 1.0);
+
+        return aBuf.makeStringAndClear();
+    }
+
+    bool writeStyle(const State& rState)
+    {
+        rtl::Reference<SvXMLAttributeList> xAttrs( new SvXMLAttributeList() );
+        uno::Reference<xml::sax::XAttributeList> xUnoAttrs( xAttrs.get() );
+
+        std::pair<StatePool::iterator,
+                  bool> aRes = mrStates.insert(rState);
+        if( !aRes.second )
+            return false; // not written
+
+        ++mnCurrStateId;
+
+        // mnStyleId does not take part in hashing/comparison
+        const_cast<State&>(*aRes.first).mnStyleId = mnCurrStateId;
+        mrStateMap.insert(std::make_pair(
+                              mnCurrStateId,
+                              rState));
+        
+        // serialize to automatic-style section
+		xAttrs->AddAttribute( USTR( "style:name" ), getStyleName("svggraphicstyle", mnCurrStateId) );
+		xAttrs->AddAttribute( USTR( "style:family" ), USTR("graphic") );
+        mxDocumentHandler->startElement( USTR("style:style"), 
+                                         xUnoAttrs );
+        
+        xAttrs->Clear();
+        if( rState.meFillType != NONE )
+        {
+            xAttrs->AddAttribute( USTR( "draw:fill" ), USTR("solid"));
+            xAttrs->AddAttribute( USTR( "draw:fill-color" ), getOdfColor(rState.maFillColor));
+            if( maCurrState.mnFillOpacity != 1.0 )
+                xAttrs->AddAttribute( USTR( "draw:fill-opacity" ), rtl::OUString::valueOf(maCurrState.mnFillOpacity));
+        }
+        else
+            xAttrs->AddAttribute( USTR( "draw:fill" ), USTR("none"));
+
+        if( rState.meStrokeType != NONE )
+        {
+            xAttrs->AddAttribute( USTR( "draw:stroke" ), USTR("solid"));
+            xAttrs->AddAttribute( USTR( "draw:stroke-color" ), getOdfColor(rState.maStrokeColor));
+        }
+        else
+            xAttrs->AddAttribute( USTR( "draw:stroke" ), USTR("none"));
+
+        if( maCurrState.mnStrokeWidth != 0.0 )
+        {
+#if 1
+            ::basegfx::B2DVector aVec(maCurrState.mnStrokeWidth,0);
+            aVec *= maCurrState.maCTM;
+            xAttrs->AddAttribute( USTR("svg:stroke-width"), rtl::OUString::valueOf( aVec.getLength()/1000.0 )+USTR("mm"));
+#else
+			xAttrs->AddAttribute( USTR("svg:stroke-width"), rtl::OUString::valueOf(maCurrState.mnStrokeWidth/100.0)+USTR("mm"));
+#endif
+        }
+        if( maCurrState.meLineJoin == basegfx::tools::B2DLINEJOIN_MITER )
+            xAttrs->AddAttribute( USTR( "draw:stroke-linejoin"), USTR("miter"));
+        else if( maCurrState.meLineJoin == basegfx::tools::B2DLINEJOIN_ROUND )
+            xAttrs->AddAttribute( USTR( "draw:stroke-linejoin"), USTR("round"));
+        else if( maCurrState.meLineJoin == basegfx::tools::B2DLINEJOIN_BEVEL )
+            xAttrs->AddAttribute( USTR( "draw:stroke-linejoin"), USTR("bevel"));
+        if( maCurrState.mnStrokeOpacity != 1.0 )
+            xAttrs->AddAttribute( USTR("svg:stroke-opacity"), rtl::OUString::valueOf(maCurrState.mnStrokeOpacity));
+        mxDocumentHandler->startElement( USTR("style:graphic-properties"), 
+                                         xUnoAttrs );
+        mxDocumentHandler->endElement( USTR("style:graphic-properties") );
+        mxDocumentHandler->endElement( USTR("style:style") );
+
+        return true; // newly written
+    }
+
+    void writeStyle(const uno::Reference<xml::dom::XElement>& xElem)
+    {
+        sal_Int32 nEmulatedStyleId=0;
+        if( maCurrState.maDashArray.size() && 
+            maCurrState.meStrokeType != NONE )
+        {
+            // ODF dashing is severly borked - generate filled shape
+            // instead (further down the road - here, we simply
+            // emulate a filled style with the next id)
+
+            // move all stroke attribs to fill, Clear stroking
+            State aEmulatedStrokeState( maCurrState );
+            aEmulatedStrokeState.meFillType = maCurrState.meStrokeType;
+            aEmulatedStrokeState.mnFillOpacity = maCurrState.mnStrokeOpacity;
+            aEmulatedStrokeState.maFillColor = maCurrState.maStrokeColor;
+            aEmulatedStrokeState.maFillGradient = maCurrState.maStrokeGradient;
+            aEmulatedStrokeState.meFillRule = EVEN_ODD;
+            aEmulatedStrokeState.meStrokeType = NONE;
+
+            if( writeStyle(aEmulatedStrokeState) )
+                nEmulatedStyleId = mnCurrStateId;
+            else
+                nEmulatedStyleId = mrStates.find(aEmulatedStrokeState)->mnStyleId;
+        }
+
+        sal_Int32 nStyleId=0;
+        if( writeStyle(maCurrState) )
+            nStyleId = mnCurrStateId;
+        else
+            nStyleId = mrStates.find(maCurrState)->mnStyleId;
+
+        xElem->setAttribute(USTR("internal-style-ref"),
+                            rtl::OUString::valueOf(
+                                nStyleId)
+                            +USTR("$")
+                            +rtl::OUString::valueOf(
+                                nEmulatedStyleId));
+    }
+
+    void push()
+    {
+        maParentStates.push_back(maCurrState);
+    }
+
+    void pop()
+    {
+        maParentStates.pop_back();
+    }
+
+    void parseAttribute( const sal_Int32      nTokenId, 
+                         const rtl::OUString& sAttribute, 
+                         const rtl::OUString& sValue )
+    {
+        rtl::OString aValueUtf8( sValue.getStr(), 
+                                 sValue.getLength(), 
+                                 RTL_TEXTENCODING_UTF8 );
+        switch(nTokenId)
+        {
+            case XML_WIDTH:
+            {
+                const double fViewPortWidth(
+                    convLength(sValue));
+            
+                maCurrState.maViewport.expand(
+                    basegfx::B2DTuple(fViewPortWidth,0.0));
+                break;
+            }
+            case XML_HEIGHT:
+            {
+                const double fViewPortHeight(
+                    convLength(sValue));
+            
+                maCurrState.maViewport.expand(
+                    basegfx::B2DTuple(0.0,fViewPortHeight));
+                break;
+            }
+            case XML_VIEWBOX:
+            {
+                // TODO(F1): preserveAspectRatio
+                parseViewBox(
+                    aValueUtf8,
+                    maCurrState.maViewBox);
+                break;
+            }
+            case XML_FILL_RULE:
+            {
+                if( aValueUtf8 == "evenodd" )
+                    maCurrState.meFillRule = EVEN_ODD;
+                else if( aValueUtf8 == "nonzero" )
+                    maCurrState.meFillRule = NON_ZERO;
+                else if( aValueUtf8 == "inherit" )
+                    maCurrState.meFillRule = maParentStates.back().meFillRule;
+                break;
+            }
+            case XML_STROKE_WIDTH:
+            {
+                if( aValueUtf8 == "inherit" )
+                    maCurrState.mnStrokeWidth = maParentStates.back().mnStrokeWidth;
+                else
+                    maCurrState.mnStrokeWidth = convLength(sValue);
+                break;
+            }
+            case XML_STROKE_LINECAP:
+            {
+                if( aValueUtf8 == "butt" )
+                    maCurrState.meLineCap = BUTT;
+                else if( aValueUtf8 == "round" )
+                    maCurrState.meLineCap = ROUND;
+                else if( aValueUtf8 == "square" )
+                    maCurrState.meLineCap = RECT;
+                else if( aValueUtf8 == "inherit" )
+                    maCurrState.meLineCap = maParentStates.back().meLineCap;
+                break;
+            }
+            case XML_STROKE_LINEJOIN:
+            {
+                if( aValueUtf8 == "miter" )
+                    maCurrState.meLineJoin = basegfx::tools::B2DLINEJOIN_MITER;
+                else if( aValueUtf8 == "round" )
+                    maCurrState.meLineJoin = basegfx::tools::B2DLINEJOIN_ROUND;
+                else if( aValueUtf8 == "bevel" )
+                    maCurrState.meLineJoin = basegfx::tools::B2DLINEJOIN_BEVEL;
+                else if( aValueUtf8 == "inherit" )
+                    maCurrState.meLineJoin = maParentStates.back().meLineJoin;
+                break;
+            }
+            case XML_STROKE_MITERLIMIT:
+            {
+                if( aValueUtf8 == "inherit" )
+                    maCurrState.mnMiterLimit = maParentStates.back().mnMiterLimit;
+                else
+                    maCurrState.mnMiterLimit = aValueUtf8.toDouble();
+                break;
+            }
+            case XML_STROKE_DASHOFFSET:
+            {
+                if( aValueUtf8 == "inherit" )
+                    maCurrState.mnDashOffset = maParentStates.back().mnDashOffset;
+                else
+                    maCurrState.mnDashOffset = convLength(sValue);
+                break;
+            }
+            case XML_STROKE_DASHARRAY:
+            {
+                if( aValueUtf8 == "none" )
+                    maCurrState.maDashArray.clear();
+                else if( aValueUtf8 == "inherit" )
+                    maCurrState.maDashArray = maParentStates.back().maDashArray;
+                else
+                    parseDashArray(aValueUtf8.getStr(),
+                                   maCurrState.maDashArray);
+                break;
+            }
+            case XML_FILL:
+            {
+                const State& rParent( maParentStates.back() );
+                parsePaint( aValueUtf8.getStr(),
+                            maCurrState.meFillType,
+                            maCurrState.maFillColor,
+                            maCurrState.maFillGradient,
+                            rParent.meFillType,
+                            rParent.maFillColor,
+                            rParent.maFillGradient );
+                break;
+            }
+            case XML_STROKE:
+            {
+                const State& rParent( maParentStates.back() );
+                parsePaint( aValueUtf8.getStr(),
+                            maCurrState.meStrokeType,
+                            maCurrState.maStrokeColor,
+                            maCurrState.maStrokeGradient,
+                            rParent.meStrokeType,
+                            rParent.maStrokeColor,
+                            rParent.maStrokeGradient );
+                break;
+            }
+            case XML_TRANSFORM:
+            {
+                basegfx::B2DHomMatrix aTransform;
+                parseTransform(aValueUtf8.getStr(),aTransform);
+				// Ugly and temprorary hack
+				aTransform.set(0,2,convLength(aTransform.get(0,2),SVG_LENGTH_UNIT_PT));
+				aTransform.set(1,2,convLength(aTransform.get(1,2),SVG_LENGTH_UNIT_PT));
+                maCurrState.maTransform = maCurrState.maTransform*aTransform;
+                break;
+            }
+            default:
+                fprintf(stderr, 
+                        "unhandled token %s (detected as %s)\n", 
+                        rtl::OUStringToOString(
+                            sAttribute,
+                            RTL_TEXTENCODING_UTF8 ).getStr(),
+                        getTokenName(nTokenId));
+                break;
+        }
+    }
+
+    void parseStyle( const rtl::OUString& sValue )
+    {
+        // split individual style attributes
+        sal_Int32 nIndex=0, nDummyIndex=0;
+        rtl::OUString aCurrToken;
+        do 
+        {
+            aCurrToken=sValue.getToken(0,';',nIndex);
+            
+            // split attrib & value
+            nDummyIndex=0;
+            rtl::OUString aCurrAttrib(
+                aCurrToken.getToken(0,':',nDummyIndex).trim());
+            OSL_ASSERT(nDummyIndex!=-1);
+            nDummyIndex=0;
+            rtl::OUString aCurrValue(
+                aCurrToken.getToken(1,':',nDummyIndex).trim());
+            OSL_ASSERT(nDummyIndex==-1);
+
+            // recurse into normal attribute parsing
+            parseAttribute( getTokenId(aCurrAttrib),
+                            aCurrAttrib,
+                            aCurrValue );
+        }
+        while( nIndex != -1 );
+    }
+
+    void parsePaint( const char*      sValue, 
+                     PaintType&       rType,
+                     ARGBColor&       rColor,
+                     Gradient&        rGradient,
+                     const PaintType& rInheritType,
+                     const ARGBColor& rInheritColor,
+                     const Gradient&  rInheritGradient )
+    {
+        if( strcmp(sValue,"none") == 0 )
+            rType = NONE;
+        else if( strcmp(sValue,"currentColor") == 0 )
+        {
+            rType = SOLID;
+            rColor = maCurrState.maCurrentColor;
+        }
+        else if( strcmp(sValue,"inherit") == 0)
+        {
+            rType = rInheritType;
+            rColor = rInheritColor;
+            rGradient = rInheritGradient;
+        }
+        else
+        { 
+            rType = SOLID;
+            parseColor(sValue,rColor);
+        }
+    }
+
+    sal_Int32                                   mnCurrStateId;
+    State                                       maCurrState;
+    std::vector<State>                          maParentStates;
+    StatePool&                                  mrStates;
+    StateMap&                                   mrStateMap;
+    uno::Reference<xml::sax::XDocumentHandler>  mxDocumentHandler;
+};
+
+/// Annotate svg styles with unique references to state pool
+static void annotateStyles( StatePool&                                        rStatePool,
+                            StateMap&                                         rStateMap,
+                            const uno::Reference<xml::dom::XElement>          xElem,
+                            const uno::Reference<xml::sax::XDocumentHandler>& xDocHdl )
+{
+    AnnotatingVisitor aVisitor(rStatePool,rStateMap,xDocHdl);
+    visitElements(aVisitor, xElem);
+}
+
+struct ShapeWritingVisitor
+{
+    ShapeWritingVisitor(StatePool&                                        rStatePool,
+                        StateMap&                                         rStateMap,
+                        const uno::Reference<xml::sax::XDocumentHandler>& xDocumentHandler) :
+        mrStates(rStatePool),
+        mrStateMap(rStateMap),
+        mxDocumentHandler(xDocumentHandler),
+        mnShapeNum(0)
+    {}
+
+    void operator()( const uno::Reference<xml::dom::XElement>& )
+    {
+    }
+
+    void operator()( const uno::Reference<xml::dom::XElement>&      xElem,
+                     const uno::Reference<xml::dom::XNamedNodeMap>& xAttributes )
+    {
+        rtl::Reference<SvXMLAttributeList> xAttrs( new SvXMLAttributeList() );
+        uno::Reference<xml::sax::XAttributeList> xUnoAttrs( xAttrs.get() );
+        
+        sal_Int32 nDummyIndex(0);
+        rtl::OUString sStyleId(
+            xElem->getAttribute(
+                USTR("internal-style-ref")).getToken(
+                    0,'$',nDummyIndex));
+        StateMap::iterator pOrigState=mrStateMap.find(
+            sStyleId.toInt32());
+        maCurrState = pOrigState != mrStateMap.end() ? pOrigState->second : maParentStates.back();
+
+        fprintf(stderr,"the CTM is now #2: %f %f %f %f %f %f\n", 
+                maCurrState.maCTM.get(0,0),
+                maCurrState.maCTM.get(0,1),
+                maCurrState.maCTM.get(0,2),
+                maCurrState.maCTM.get(1,0),
+                maCurrState.maCTM.get(1,1),
+                maCurrState.maCTM.get(1,2));
+        
+        const sal_Int32 nTokenId(getTokenId(xElem->getNodeName()));
+        switch(nTokenId)
+        {
+		    case XML_LINE:
+			{
+                // collect attributes
+                const sal_Int32 nNumElems( xAttributes->getLength() );
+                rtl::OUString sAttributeValue;
+                double x1=0.0,y1=0.0,x2=0.0,y2=0.0;
+                for( sal_Int32 i=0; i<nNumElems; ++i )
+                {
+                    sAttributeValue = xAttributes->item(i)->getNodeValue();
+                    const sal_Int32 nAttribId( 
+                        getTokenId(xAttributes->item(i)->getNodeName()));
+                    switch(nAttribId)
+                    {
+                        case XML_X1:
+                            x1= convLength(sAttributeValue);
+                            break;
+                        case XML_X2:
+                            x2 = convLength(sAttributeValue);
+                            break;
+                        case XML_Y1:
+                            y1 = convLength(sAttributeValue);
+                            break;
+                        case XML_Y2:
+                            y2 = convLength(sAttributeValue);
+                            break;
+                        default:
+                            // skip
+                            break;
+                    }
+                }
+
+				rtl::OUString sLinePath = USTR("M")+rtl::OUString::valueOf(x1)+USTR(",")
+					+rtl::OUString::valueOf(y1)+USTR("L")+rtl::OUString::valueOf(x2)+USTR(",")
+					+rtl::OUString::valueOf(y2);
+                basegfx::B2DPolyPolygon aPoly;
+                basegfx::tools::importFromSvgD(aPoly, sLinePath);
+
+                writePathShape(xAttrs,
+                               xUnoAttrs,
+                               xElem,
+                               sStyleId,
+                               basegfx::B2DPolyPolygon(aPoly));                
+                break;
+			}
+            case XML_POLYGON:
+            case XML_POLYLINE:
+            {
+                rtl::OUString sPoints = xElem->hasAttribute(USTR("points")) ? xElem->getAttribute(USTR("points")) : USTR("");
+                basegfx::B2DPolygon aPoly;
+                basegfx::tools::importFromSvgPoints(aPoly, sPoints);
+                // if( nTokenId == XML_POLYGON )
+                    aPoly.setClosed(true);
+
+				// assuming the coordinates are in pts since they are interpreted as such by different renderers
+				basegfx::B2DHomMatrix aScale;
+				aScale.scale(2540.0f/72.0f,2540.0f/72.0f);
+				aPoly.transform(aScale);
+
+                writePathShape(xAttrs,
+                               xUnoAttrs,
+                               xElem,
+                               sStyleId,
+                               basegfx::B2DPolyPolygon(aPoly));
+                break;
+            }
+            case XML_RECT:
+            {
+                // collect attributes
+                const sal_Int32 nNumElems( xAttributes->getLength() );
+                rtl::OUString sAttributeValue;
+                bool bRxSeen=false, bRySeen=false;
+                double x=0.0,y=0.0,width=0.0,height=0.0,rx=0.0,ry=0.0;
+                for( sal_Int32 i=0; i<nNumElems; ++i )
+                {
+                    sAttributeValue = xAttributes->item(i)->getNodeValue();
+                    const sal_Int32 nAttribId( 
+                        getTokenId(xAttributes->item(i)->getNodeName()));
+                    switch(nAttribId)
+                    {
+                        case XML_X:
+                            x = convLength(sAttributeValue);
+                            break;
+                        case XML_Y:
+                            y = convLength(sAttributeValue);
+                            break;
+                        case XML_WIDTH:
+                            width = convLength(sAttributeValue);
+                            break;
+                        case XML_HEIGHT:
+                            height = convLength(sAttributeValue);
+                            break;
+                        case XML_RX:
+                            rx = convLength(sAttributeValue);
+                            bRxSeen=true;
+                            break;
+                        case XML_RY:
+                            ry = convLength(sAttributeValue);
+                            bRySeen=true;
+                            break;
+                        default:
+                            // skip
+                            break;
+                    }
+                }
+
+                if( bRxSeen && !bRySeen )
+                    ry = rx;
+                else if( bRySeen && !bRxSeen )
+                    rx = ry;
+
+                basegfx::B2DPolygon aPoly;
+                aPoly = basegfx::tools::createPolygonFromRect(
+                    basegfx::B2DRange(x,y,x+width,y+height),
+                    rx, ry );
+
+                writePathShape(xAttrs,
+                               xUnoAttrs,
+                               xElem,
+                               sStyleId,
+                               basegfx::B2DPolyPolygon(aPoly));                
+                break;
+            }
+            case XML_PATH:
+            {
+                rtl::OUString sPath = xElem->hasAttribute(USTR("d")) ? xElem->getAttribute(USTR("d")) : USTR("");
+                basegfx::B2DPolyPolygon aPoly;
+                basegfx::tools::importFromSvgD(aPoly, sPath);
+
+				// assuming the coordinates are in pts since they are interpreted as such by different renderers
+				basegfx::B2DHomMatrix aScale;
+				aScale.scale(2540.0f/72.0f,2540.0f/72.0f);
+				aPoly.transform(aScale);
+				
+                writePathShape(xAttrs,
+                               xUnoAttrs,
+                               xElem,
+                               sStyleId,
+                               aPoly);
+                break;
+            }
+			case XML_CIRCLE:
+			{
+                // collect attributes
+                const sal_Int32 nNumElems( xAttributes->getLength() );
+                rtl::OUString sAttributeValue;
+                double cx=0.0,cy=0.0,r=0.0;
+                for( sal_Int32 i=0; i<nNumElems; ++i )
+                {
+                    sAttributeValue = xAttributes->item(i)->getNodeValue();
+                    const sal_Int32 nAttribId( 
+                        getTokenId(xAttributes->item(i)->getNodeName()));
+                    switch(nAttribId)
+                    {
+                        case XML_CX:
+                            cx = convLength(sAttributeValue);
+                            break;
+                        case XML_CY:
+                            cy = convLength(sAttributeValue);
+                            break;
+                        case XML_R:
+                            r = convLength(sAttributeValue);
+                        default:
+                            // skip
+                            break;
+                    }
+                }
+
+                writeEllipseShape(xAttrs,
+                               xUnoAttrs,
+                               xElem,
+                               sStyleId,
+                               basegfx::B2DEllipse(basegfx::B2DPoint(cx, cy), basegfx::B2DTuple(r,r)));                
+				break;
+			}
+			case XML_ELLIPSE:
+			{
+                // collect attributes
+                const sal_Int32 nNumElems( xAttributes->getLength() );
+                rtl::OUString sAttributeValue;
+                double cx=0.0,cy=0.0,rx=0.0, ry=0.0;
+                for( sal_Int32 i=0; i<nNumElems; ++i )
+                {
+                    sAttributeValue = xAttributes->item(i)->getNodeValue();
+                    const sal_Int32 nAttribId( 
+                        getTokenId(xAttributes->item(i)->getNodeName()));
+                    switch(nAttribId)
+                    {
+                        case XML_CX:
+                            cx = convLength(sAttributeValue);
+                            break;
+                        case XML_CY:
+                            cy = convLength(sAttributeValue);
+                            break;
+                        case XML_RX:
+                            rx = convLength(sAttributeValue);
+							break;
+						case XML_RY:
+							ry = convLength(sAttributeValue);
+                        default:
+                            // skip
+                            break;
+                    }
+                }
+
+                writeEllipseShape(xAttrs,
+                               xUnoAttrs,
+                               xElem,
+                               sStyleId,
+                               basegfx::B2DEllipse(basegfx::B2DPoint(cx, cy), basegfx::B2DTuple(rx,ry)));                
+				break;
+			}
+            case XML_IMAGE:
+            {
+                // collect attributes
+                const sal_Int32 nNumElems( xAttributes->getLength() );
+                rtl::OUString sAttributeValue;
+                double x=0.0,y=0.0,width=0.0,height=0.0;
+                for( sal_Int32 i=0; i<nNumElems; ++i )
+                {
+                    sAttributeValue = xAttributes->item(i)->getNodeValue();
+                    const sal_Int32 nAttribId( 
+                        getTokenId(xAttributes->item(i)->getNodeName()));
+                    switch(nAttribId)
+                    {
+                        case XML_X:
+                            x = convLength(sAttributeValue);
+                            break;
+                        case XML_Y:
+                            y = convLength(sAttributeValue);
+                            break;
+                        case XML_WIDTH:
+                            width = convLength(sAttributeValue);
+                            break;
+                        case XML_HEIGHT:
+                            height = convLength(sAttributeValue);
+                            break;
+                        default:
+                            // skip
+                            break;
+                    }
+                }
+
+                rtl::OUString sValue = xElem->hasAttribute(USTR("href")) ? xElem->getAttribute(USTR("href")) : USTR("");
+        		rtl::OString aValueUtf8( sValue.getStr(), sValue.getLength(), RTL_TEXTENCODING_UTF8 );
+				std::string sLinkValue;
+				parseXlinkHref(aValueUtf8.getStr(), sLinkValue);
+
+				if (!sLinkValue.empty())
+					writeBinaryData(xAttrs, xUnoAttrs, xElem, basegfx::B2DRange(x,y,x+width,y+height), sLinkValue);
+                break;
+            }
+        }
+    }
+
+    void push()
+    {
+        maParentStates.push_back(maCurrState);
+    }
+
+    void pop()
+    {
+        maParentStates.pop_back();
+    }
+	
+	void writeBinaryData( rtl::Reference<SvXMLAttributeList>&           xAttrs,
+						const uno::Reference<xml::sax::XAttributeList>& xUnoAttrs,
+						const uno::Reference<xml::dom::XElement>&       /* xElem */,
+						const basegfx::B2DRange&                        rShapeBounds,
+						const std::string&                              data)
+	{
+		xAttrs->Clear();
+        xAttrs->AddAttribute( USTR( "svg:x" ), rtl::OUString::valueOf(rShapeBounds.getMinX()/100.0)+USTR("mm"));
+        xAttrs->AddAttribute( USTR( "svg:y" ), rtl::OUString::valueOf(rShapeBounds.getMinY()/100.0)+USTR("mm"));
+        xAttrs->AddAttribute( USTR( "svg:width" ), rtl::OUString::valueOf(rShapeBounds.getWidth()/100.0)+USTR("mm"));
+        xAttrs->AddAttribute( USTR( "svg:height" ), rtl::OUString::valueOf(rShapeBounds.getHeight()/100.0)+USTR("mm"));
+
+		mxDocumentHandler->startElement(USTR("draw:frame"),xUnoAttrs);
+
+		xAttrs->Clear();
+		mxDocumentHandler->startElement(USTR("draw:image"),xUnoAttrs);
+
+		mxDocumentHandler->startElement(USTR("office:binary-data"),xUnoAttrs);
+
+		mxDocumentHandler->characters(rtl::OUString::createFromAscii(data.c_str()));
+
+        mxDocumentHandler->endElement(USTR("office:binary-data"));
+
+        mxDocumentHandler->endElement(USTR("draw:image"));
+
+        mxDocumentHandler->endElement(USTR("draw:frame"));
+	}
+						  
+
+	void writeTransformAttribute(const basegfx::B2DHomMatrix rMatrix, rtl::Reference<SvXMLAttributeList>& xAttrs)
+	{
+		basegfx::B2DTuple rScale, rTranslate;
+		double rRotate, rShearX;
+		::rtl::OUString sTransformValue;
+		if (!rMatrix.decompose(rScale, rTranslate, rRotate, rShearX))
+			return;
+		if (rScale.getX() != 1.0 || rScale.getY() != 1.0)
+			sTransformValue += USTR("scale(")+::rtl::OUString::valueOf(rScale.getX())+USTR(" ")
+			     +::rtl::OUString::valueOf(rScale.getY())+USTR(") ");
+		if (rTranslate.getX() != 0.0f || rTranslate.getY() != 0.0f)
+			sTransformValue += USTR("translate(")+::rtl::OUString::valueOf(rTranslate.getX()/100.0f)+USTR("mm ")
+			     +::rtl::OUString::valueOf(rTranslate.getY()/100.0f)+USTR("mm) ");
+		if (rRotate != 0.0f)
+			sTransformValue += USTR("rotate(")+::rtl::OUString::valueOf(rRotate)+USTR(") ");
+
+		if (rShearX != 0.0f)
+			sTransformValue += USTR("skewX(")+::rtl::OUString::valueOf(rShearX)+USTR(") ");
+		if (!sTransformValue.getLength())
+			return;
+		xAttrs->AddAttribute( USTR("draw:transform"), sTransformValue);
+	}
+
+    void writeEllipseShape( rtl::Reference<SvXMLAttributeList>&          xAttrs,
+                         const uno::Reference<xml::sax::XAttributeList>& xUnoAttrs,
+                         const uno::Reference<xml::dom::XElement>&       xElem,
+                         const rtl::OUString&                            rStyleId,
+                         const basegfx::B2DEllipse&                      rEllipse)
+    {
+        State aState = maCurrState;
+        rtl::OUString aStyleId(rStyleId);
+		
+		xAttrs->Clear();
+
+        fprintf(stderr,"the CTM is now #2: %f %f %f %f %f %f\n", 
+                maCurrState.maCTM.get(0,0),
+                maCurrState.maCTM.get(0,1),
+                maCurrState.maCTM.get(0,2),
+                maCurrState.maCTM.get(1,0),
+                maCurrState.maCTM.get(1,1),
+                maCurrState.maCTM.get(1,2));
+        
+		basegfx::B2DPolygon aPoly = basegfx::tools::createPolygonFromEllipse(rEllipse.getB2DEllipseCenter(),
+			rEllipse.getB2DEllipseRadius().getX(), rEllipse.getB2DEllipseRadius().getY());
+		writePathShape(xAttrs, xUnoAttrs, xElem, rStyleId, basegfx::B2DPolyPolygon(aPoly));
+		
+    }
+
+    void writePathShape( rtl::Reference<SvXMLAttributeList>&             xAttrs,
+                         const uno::Reference<xml::sax::XAttributeList>& xUnoAttrs,
+                         const uno::Reference<xml::dom::XElement>&       xElem,
+                         const rtl::OUString&                            rStyleId,
+                         const basegfx::B2DPolyPolygon&                  rPoly )
+    {
+        // we might need to split up polypolygon into multiple path
+        // shapes (e.g. when emulating line stroking)
+        std::vector<basegfx::B2DPolyPolygon> aPolys(1,rPoly);
+        State aState = maCurrState;
+        rtl::OUString aStyleId(rStyleId);
+		
+		xAttrs->Clear();
+
+        fprintf(stderr,"the CTM is now #2: %f %f %f %f %f %f\n", 
+                maCurrState.maCTM.get(0,0),
+                maCurrState.maCTM.get(0,1),
+                maCurrState.maCTM.get(0,2),
+                maCurrState.maCTM.get(1,0),
+                maCurrState.maCTM.get(1,1),
+                maCurrState.maCTM.get(1,2));
+        
+		if( aState.maDashArray.size() )
+        {
+            // ODF dashing is severly borked - generate filled polygon instead
+            aPolys.clear();
+            for( sal_uInt32 i=0; i<rPoly.count(); ++i )
+            {                
+                aPolys.push_back(
+                    basegfx::tools::createAreaGeometryForPolygon(
+                        rPoly.getB2DPolygon(i),
+                        aState.mnStrokeWidth/2.0,
+                        aState.meLineJoin));
+                // TODO(F2): line ends
+            }
+
+            sal_Int32 nDummyIndex(0);
+            aStyleId = xElem->getAttribute(
+                USTR("internal-style-ref")).getToken(1,'$',nDummyIndex);
+            StateMap::iterator pAlternateState=mrStateMap.find(aStyleId.toInt32());
+            aState = pAlternateState != mrStateMap.end() ? pAlternateState->second : maParentStates.back();
+            OSL_ENSURE( pAlternateState == mrStateMap.end(),
+                        "Doh - where's my alternate style entry?!" );
+        }
+
+        // TODO(F2): separate out shear, rotate etc.
+        // apply transformation to polygon, to keep draw
+        // import in 100th mm
+        std::for_each(aPolys.begin(),aPolys.end(),
+                      boost::bind(&basegfx::B2DPolyPolygon::transform,
+                                  _1,boost::cref(aState.maCTM)));
+
+        for( sal_uInt32 i=0; i<aPolys.size(); ++i )
+        {
+            fillShapeProperties(xAttrs,
+                                xElem,
+                                aPolys[i].areControlPointsUsed() ?
+                                basegfx::tools::getRange(
+                                    basegfx::tools::adaptiveSubdivideByAngle(aPolys[i])) :
+                                basegfx::tools::getRange(aPolys[i]),
+                                USTR("svggraphicstyle")+aStyleId);
+            
+            xAttrs->AddAttribute( USTR( "svg:d" ), basegfx::tools::exportToSvgD(
+                aPolys[i],
+                false,   // no relative coords. causes rounding errors      
+                false )); // no quad bezier detection. crashes older versions.   
+            mxDocumentHandler->startElement(USTR("draw:path"), 
+                                            xUnoAttrs);
+            mxDocumentHandler->endElement(USTR("draw:path"));
+        }
+    }
+
+    void fillShapeProperties( rtl::Reference<SvXMLAttributeList>&       xAttrs, 
+                              const uno::Reference<xml::dom::XElement>& /* xElem */,
+                              const basegfx::B2DRange&                  rShapeBounds,
+                              const rtl::OUString&                      rStyleName )
+    {
+        xAttrs->AddAttribute( USTR( "draw:z-index" ), rtl::OUString::valueOf( mnShapeNum++ ));
+        xAttrs->AddAttribute( USTR( "draw:style-name" ), rStyleName);
+        xAttrs->AddAttribute( USTR( "svg:width" ), rtl::OUString::valueOf(rShapeBounds.getWidth()/100.0)+USTR("mm"));
+        xAttrs->AddAttribute( USTR( "svg:height" ), rtl::OUString::valueOf(rShapeBounds.getHeight()/100.0)+USTR("mm"));
+
+        // OOo expects the viewbox to be in 100th of mm
+        xAttrs->AddAttribute( USTR( "svg:viewBox" ), 
+            USTR("0 0 ")
+            + rtl::OUString::valueOf( 
+                basegfx::fround(rShapeBounds.getWidth()) )
+            + USTR(" ")
+            + rtl::OUString::valueOf(
+                basegfx::fround(rShapeBounds.getHeight()) ));
+
+        // TODO(F1): decompose transformation in calling code, and use
+        // transform attribute here
+		// writeTranslate(maCurrState.maCTM, xAttrs);
+        xAttrs->AddAttribute( USTR( "svg:x" ), rtl::OUString::valueOf(rShapeBounds.getMinX()/100.0)+USTR("mm"));
+        xAttrs->AddAttribute( USTR( "svg:y" ), rtl::OUString::valueOf(rShapeBounds.getMinY()/100.0)+USTR("mm"));
+    }
+
+    State                                      maCurrState;
+    std::vector<State>                         maParentStates;
+    StatePool&                                 mrStates;
+    StateMap&                                  mrStateMap;
+    uno::Reference<xml::sax::XDocumentHandler> mxDocumentHandler;
+    sal_Int32                                  mnShapeNum;
+};
+
+/// Write out shapes from DOM tree
+static void writeShapes( StatePool&                                        rStatePool,
+                         StateMap&                                         rStateMap,
+                         const uno::Reference<xml::dom::XElement>          xElem,
+                         const uno::Reference<xml::sax::XDocumentHandler>& xDocHdl )
+{
+    ShapeWritingVisitor aVisitor(rStatePool,rStateMap,xDocHdl);
+    visitElements(aVisitor, xElem);
+}
+
+#ifdef VERBOSE
+struct DumpingVisitor
+{
+    void operator()( const uno::Reference<xml::dom::XElement>& xElem )
+    {
+        fprintf(stderr, "name: %s\n", 
+                rtl::OUStringToOString(
+                    xElem->getTagName(),
+                    RTL_TEXTENCODING_UTF8 ).getStr());
+    }
+
+    void operator()( const uno::Reference<xml::dom::XElement>&      xElem,
+                     const uno::Reference<xml::dom::XNamedNodeMap>& xAttributes )
+    {
+        fprintf(stderr, "name: %s", 
+                rtl::OUStringToOString(
+                    xElem->getTagName(),
+                    RTL_TEXTENCODING_UTF8 ).getStr());
+        const sal_Int32 nNumElems( xAttributes->getLength() );
+        for( sal_Int32 i=0; i<nNumElems; ++i )
+        {
+            fprintf(stderr, " %s=%s", 
+                    rtl::OUStringToOString(
+                        xAttributes->item(i)->getNodeName(),
+                        RTL_TEXTENCODING_UTF8 ).getStr(),
+                    rtl::OUStringToOString(
+                        xAttributes->item(i)->getNodeValue(),
+                        RTL_TEXTENCODING_UTF8 ).getStr());
+        }
+
+        fprintf(stderr, "\n");
+    }
+
+    void push() {}
+    void pop()  {}
+};
+
+static void dumpTree( const uno::Reference<xml::dom::XElement> xElem )
+{
+    DumpingVisitor aVisitor;
+    visitElements(aVisitor, xElem);
+}
+#endif
+
+} // namespace 
+
+
+SVGReader::SVGReader(const uno::Reference<lang::XMultiServiceFactory>&     xServiceFactory,
+                     const uno::Reference<io::XInputStream>&           xInputStream, 
+                     const uno::Reference<xml::sax::XDocumentHandler>& xDocumentHandler) :
+	m_xServiceFactory( xServiceFactory ),
+	m_xInputStream( xInputStream ),
+	m_xDocumentHandler( xDocumentHandler )
+{
+}
+
+sal_Bool SVGReader::parseAndConvert()
+{
+	uno::Reference<xml::dom::XDocumentBuilder> xDomBuilder( 
+        m_xServiceFactory->createInstance( 
+            rtl::OUString::createFromAscii("com.sun.star.xml.dom.DocumentBuilder")), uno::UNO_QUERY );
+
+    uno::Reference<xml::dom::XDocument> xDom(
+        xDomBuilder->parse(m_xInputStream),
+        uno::UNO_QUERY_THROW );
+
+    uno::Reference<xml::dom::XElement> xDocElem( xDom->getDocumentElement(),
+                                                 uno::UNO_QUERY_THROW );
+
+    /////////////////////////////////////////////////////////////////
+    // doc boilerplate    
+    /////////////////////////////////////////////////////////////////
+
+    m_xDocumentHandler->startDocument();
+    
+    // get the document dimensions
+
+    // if the "width" and "height" attributes are missing, inkscape fakes
+    // A4 portrait for. Let's do the same.
+	if (!xDocElem->hasAttribute(USTR("width")))
+		xDocElem->setAttribute(USTR("width"), USTR("210mm"));
+	if (!xDocElem->hasAttribute(USTR("height")))
+		xDocElem->setAttribute(USTR("height"), USTR("297mm"));
+		
+    double fViewPortWidth( convLength(xDocElem->getAttribute(USTR("width"))));
+    double fViewPortHeight( convLength(xDocElem->getAttribute(USTR("height"))));
+
+    // document prolog
+    rtl::Reference<SvXMLAttributeList> xAttrs( new SvXMLAttributeList() );
+    uno::Reference<xml::sax::XAttributeList> xUnoAttrs( xAttrs.get() );
+	
+    xAttrs->AddAttribute( USTR( "xmlns:office" ), USTR( OASIS_STR "office:1.0" ));
+    xAttrs->AddAttribute( USTR( "xmlns:style" ), USTR( OASIS_STR "style:1.0" ));
+    xAttrs->AddAttribute( USTR( "xmlns:text" ), USTR( OASIS_STR "text:1.0" ));
+    xAttrs->AddAttribute( USTR( "xmlns:svg" ), USTR( OASIS_STR "svg-compatible:1.0" ));
+    xAttrs->AddAttribute( USTR( "xmlns:table" ), USTR( OASIS_STR "table:1.0" ));
+    xAttrs->AddAttribute( USTR( "xmlns:draw" ), USTR( OASIS_STR "drawing:1.0" ));
+    xAttrs->AddAttribute( USTR( "xmlns:fo" ), USTR( OASIS_STR "xsl-fo-compatible:1.0" ));
+    xAttrs->AddAttribute( USTR( "xmlns:xlink" ), USTR( "http://www.w3.org/1999/xlink" ));
+    xAttrs->AddAttribute( USTR( "xmlns:dc" ), USTR( "http://purl.org/dc/elements/1.1/" ));
+    xAttrs->AddAttribute( USTR( "xmlns:number" ), USTR( OASIS_STR "datastyle:1.0" ));
+    xAttrs->AddAttribute( USTR( "xmlns:presentation" ), USTR( OASIS_STR "presentation:1.0" ));
+    xAttrs->AddAttribute( USTR( "xmlns:math" ), USTR( "http://www.w3.org/1998/Math/MathML" ));
+    xAttrs->AddAttribute( USTR( "xmlns:form" ), USTR( OASIS_STR "form:1.0" ));
+    xAttrs->AddAttribute( USTR( "xmlns:script" ), USTR( OASIS_STR "script:1.0" ));
+    xAttrs->AddAttribute( USTR( "xmlns:dom" ), USTR( "http://www.w3.org/2001/xml-events" ));
+    xAttrs->AddAttribute( USTR( "xmlns:xforms" ), USTR( "http://www.w3.org/2002/xforms" ));
+    xAttrs->AddAttribute( USTR( "xmlns:xsd" ), USTR( "http://www.w3.org/2001/XMLSchema" ));
+    xAttrs->AddAttribute( USTR( "xmlns:xsi" ), USTR( "http://www.w3.org/2001/XMLSchema-instance" ));
+    xAttrs->AddAttribute( USTR( "office:version" ), USTR( "1.0" ));
+	xAttrs->AddAttribute( USTR( "office:mimetype" ), USTR( "application/vnd.oasis.opendocument.graphics" ));
+
+    m_xDocumentHandler->startElement( USTR("office:document"), xUnoAttrs );
+
+    xAttrs->Clear();
+
+	m_xDocumentHandler->startElement( USTR("office:settings"), xUnoAttrs);
+	
+	xAttrs->AddAttribute( USTR( "config:name" ), USTR( "ooo:view-settings" ));
+	m_xDocumentHandler->startElement( USTR("config:config-item-set"), xUnoAttrs);
+	
+	xAttrs->Clear();
+	
+	xAttrs->AddAttribute( USTR( "config:name" ), USTR( "VisibleAreaTop" ));
+	xAttrs->AddAttribute( USTR( "config:type" ), USTR( "int" ));
+	m_xDocumentHandler->startElement( USTR( "config:config-item" ), xUnoAttrs);
+
+	m_xDocumentHandler->characters( USTR( "0" ));
+
+	m_xDocumentHandler->endElement( USTR( "config:config-item" ));
+	
+	xAttrs->Clear();
+	
+	xAttrs->AddAttribute( USTR( "config:name" ), USTR( "VisibleAreaLeft" ));
+	xAttrs->AddAttribute( USTR( "config:type" ), USTR( "int" ));
+	m_xDocumentHandler->startElement( USTR( "config:config-item" ), xUnoAttrs);
+
+	m_xDocumentHandler->characters( USTR( "0" ));
+
+	m_xDocumentHandler->endElement( USTR( "config:config-item" ));
+	
+	xAttrs->Clear();
+	
+	xAttrs->AddAttribute( USTR( "config:name" ), USTR( "VisibleAreaWidth" ));
+	xAttrs->AddAttribute( USTR( "config:type" ), USTR( "int" ));
+	m_xDocumentHandler->startElement( USTR( "config:config-item" ), xUnoAttrs);
+
+	sal_Int64 iWidth = sal_Int64(fViewPortWidth);
+	m_xDocumentHandler->characters( ::rtl::OUString::valueOf(iWidth) );
+
+	m_xDocumentHandler->endElement( USTR( "config:config-item" ));
+	
+	xAttrs->Clear();
+	
+	xAttrs->AddAttribute( USTR( "config:name" ), USTR( "VisibleAreaHeight" ));
+	xAttrs->AddAttribute( USTR( "config:type" ), USTR( "int" ));
+	m_xDocumentHandler->startElement( USTR( "config:config-item" ), xUnoAttrs);
+
+	sal_Int64 iHeight = sal_Int64(fViewPortHeight);
+	m_xDocumentHandler->characters( ::rtl::OUString::valueOf(iHeight) );
+
+	m_xDocumentHandler->endElement( USTR( "config:config-item" ));
+	
+	m_xDocumentHandler->endElement( USTR( "config:config-item-set" ));
+	
+	m_xDocumentHandler->endElement( USTR( "office:settings" ));
+
+	xAttrs->Clear();
+	
+    m_xDocumentHandler->startElement( USTR("office:automatic-styles"), 
+                                      xUnoAttrs );
+ 
+    xAttrs->AddAttribute( USTR( "style:name" ), USTR("pagelayout1"));
+    m_xDocumentHandler->startElement( USTR("style:page-layout"), 
+                                      xUnoAttrs );
+    // TODO(Q3): this is super-ugly. In-place container come to mind.
+    xAttrs->Clear();
+
+    // make page viewport-width times viewport-height mm large - add
+    // 5% border at every side
+    xAttrs->AddAttribute( USTR( "fo:margin-top" ), USTR("0mm"));
+    xAttrs->AddAttribute( USTR( "fo:margin-bottom" ), USTR("0mm"));
+    xAttrs->AddAttribute( USTR( "fo:margin-left" ), USTR("0mm"));
+    xAttrs->AddAttribute( USTR( "fo:margin-right" ), USTR("0mm"));
+    xAttrs->AddAttribute( USTR( "fo:page-width" ), rtl::OUString::valueOf(fViewPortWidth/100.0)+USTR("mm"));
+    xAttrs->AddAttribute( USTR( "fo:page-height" ), rtl::OUString::valueOf(fViewPortHeight/100.0)+USTR("mm"));
+    xAttrs->AddAttribute( USTR( "style:print-orientation" ), 
+        fViewPortWidth > fViewPortHeight ? 
+        USTR("landscape") :
+        USTR("portrait"));
+    m_xDocumentHandler->startElement( USTR("style:page-layout-properties"), 
+                                      xUnoAttrs );
+    m_xDocumentHandler->endElement( USTR("style:page-layout-properties") );
+    m_xDocumentHandler->endElement( USTR("style:page-layout") );
+
+    xAttrs->Clear();
+    xAttrs->AddAttribute( USTR( "style:name" ), USTR("pagestyle1"));
+    xAttrs->AddAttribute( USTR( "style:family" ), USTR("drawing-page"));
+    m_xDocumentHandler->startElement( USTR("style:style"), 
+                                      xUnoAttrs );
+
+    xAttrs->Clear();
+    xAttrs->AddAttribute( USTR( "draw:background-size" ), USTR("border"));
+    xAttrs->AddAttribute( USTR( "draw:fill" ), USTR("none"));
+    m_xDocumentHandler->startElement( USTR("style:drawing-page-properties"), 
+                                      xUnoAttrs );
+    m_xDocumentHandler->endElement( USTR("style:drawing-page-properties") );
+    m_xDocumentHandler->endElement( USTR("style:style") );
+
+    StatePool aStatePool;
+    StateMap  aStateMap;
+    annotateStyles(aStatePool,aStateMap,
+                   xDocElem,m_xDocumentHandler);
+
+#ifdef VERBOSE
+    dumpTree(xDocElem);
+#endif
+
+    m_xDocumentHandler->endElement( USTR("office:automatic-styles") );
+
+    ////////////////////////////////////////////////////////////////////
+
+    xAttrs->Clear();
+    m_xDocumentHandler->startElement( USTR("office:styles"), 
+                                      xUnoAttrs);
+    m_xDocumentHandler->endElement( USTR("office:styles") );
+
+    ////////////////////////////////////////////////////////////////////
+
+    m_xDocumentHandler->startElement( USTR("office:master-styles"), 
+                                      xUnoAttrs );
+    xAttrs->Clear();
+    xAttrs->AddAttribute( USTR( "style:name" ), USTR("Default"));
+    xAttrs->AddAttribute( USTR( "style:page-layout-name" ), USTR("pagelayout1"));
+    xAttrs->AddAttribute( USTR( "draw:style-name" ), USTR("pagestyle1"));
+    m_xDocumentHandler->startElement( USTR("style:master-page"), 
+                                      xUnoAttrs );
+    m_xDocumentHandler->endElement( USTR("style:master-page") );
+
+    m_xDocumentHandler->endElement( USTR("office:master-styles") );
+
+    ////////////////////////////////////////////////////////////////////
+
+    xAttrs->Clear();
+    m_xDocumentHandler->startElement( USTR("office:body"), 
+                                      xUnoAttrs );
+    m_xDocumentHandler->startElement( USTR("office:drawing"), 
+                                      xUnoAttrs );
+
+    xAttrs->Clear();
+    xAttrs->AddAttribute( USTR( "draw:master-page-name" ), USTR("Default"));
+    xAttrs->AddAttribute( USTR( "draw:style-name" ), USTR("pagestyle1"));
+    m_xDocumentHandler->startElement(USTR("draw:page"), 
+                                     xUnoAttrs);
+
+    // write out all shapes
+    writeShapes(aStatePool,
+                aStateMap,
+                xDocElem,
+                m_xDocumentHandler);
+
+    m_xDocumentHandler->endElement( USTR("draw:page") );
+    m_xDocumentHandler->endElement( USTR("office:drawing") );
+    m_xDocumentHandler->endElement( USTR("office:body") );
+    m_xDocumentHandler->endElement( USTR("office:document") );
+    m_xDocumentHandler->endDocument();
+
+    return sal_True;
+}
+
+} // namespace svgi
--- filter/source/svg/svgreader.hxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/svgreader.hxx	2008-02-23 12:59:42.000000000 +0100
@@ -0,0 +1,43 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Fridrich Strba  <fridrich.strba@bluewin.ch>
+ *      Thorsten Behrens <tbehrens@novell.com>	   	
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_SVGREADER_HXX
+#define INCLUDED_SVGREADER_HXX
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/xml/sax/XDocumentHandler.hpp>
+#include <com/sun/star/io/XInputStream.hpp>
+
+namespace svgi
+{
+
+class SVGReader
+{
+    const ::com::sun::star::uno::Reference< com::sun::star::lang::XMultiServiceFactory >      m_xServiceFactory;    
+    const ::com::sun::star::uno::Reference< com::sun::star::io::XInputStream >              m_xInputStream;
+	const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XDocumentHandler >  m_xDocumentHandler;
+
+public:
+    SVGReader( const com::sun::star::uno::Reference<com::sun::star::lang::XMultiServiceFactory>&           xServiceFactory,
+               const com::sun::star::uno::Reference< com::sun::star::io::XInputStream >&               xInputStream,
+               const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XDocumentHandler >& xDocumentHandler );
+
+	sal_Bool parseAndConvert();
+};
+
+} // namespace svgi
+
+#endif
--- filter/source/svg/tokenmap.cxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/tokenmap.cxx	2008-02-23 12:59:42.000000000 +0100
@@ -0,0 +1,62 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Fridrich Strba  <fridrich.strba@bluewin.ch>
+ *      Thorsten Behrens <tbehrens@novell.com>	   	
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *      Parts copyright 2005 by Sun Microsystems, Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_filter.hxx"
+
+#include "tokenmap.hxx"
+#include <string.h>
+
+namespace svgi 
+{
+
+#include "tokens.cxx"
+
+sal_Int32 getTokenId( const char* sIdent, sal_Int32 nLen )
+{
+	const struct xmltoken* t = Perfect_Hash::in_word_set( sIdent, nLen );
+	if( t )
+		return t->nToken;
+	else
+		return XML_TOKEN_INVALID;
+}
+
+sal_Int32 getTokenId( const rtl::OUString& sIdent )
+{
+	rtl::OString aUTF8( sIdent.getStr(), 
+                        sIdent.getLength(), 
+                        RTL_TEXTENCODING_UTF8 );
+    return getTokenId( aUTF8.getStr(), aUTF8.getLength() );
+}
+
+const char* getTokenName( sal_Int32 nTokenId )
+{
+	if( nTokenId >= XML_TOKEN_COUNT )
+		return NULL;
+
+    const xmltoken* pCurr=wordlist;
+    const xmltoken* pEnd=wordlist+sizeof(wordlist)/sizeof(*wordlist);
+    while( pCurr != pEnd )
+    {
+        if(pCurr->nToken == nTokenId)
+            return pCurr->name;
+        ++pCurr;
+    }
+
+    return NULL;
+}
+
+} // namespace svgi
--- filter/source/svg/tokenmap.hxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/tokenmap.hxx	2008-02-23 12:59:42.000000000 +0100
@@ -0,0 +1,32 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Fridrich Strba  <fridrich.strba@bluewin.ch>
+ *      Thorsten Behrens <tbehrens@novell.com>	   	
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_TOKENMAP_HXX
+#define INCLUDED_TOKENMAP_HXX
+
+#include "tokens.hxx"
+
+#include <rtl/string.hxx>
+#include <rtl/ustring.hxx>
+
+namespace svgi
+{
+    sal_Int32   getTokenId( const char* sIdent, sal_Int32 nLen );
+    sal_Int32   getTokenId( const rtl::OUString& sIdent );
+    const char* getTokenName( sal_Int32 nTokenId );
+
+} // namespace svgi
+
+#endif
--- filter/source/svg/tokens.txt	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/tokens.txt	2008-02-23 12:59:42.000000000 +0100
@@ -0,0 +1,246 @@
+#######################################
+#
+# elements (SVG Tiny 1.2)
+#
+#######################################
+a
+animate
+animateColor
+animateMotion
+animateTransform
+animation
+audio
+circle
+defs
+desc
+discard
+ellipse
+font
+font-face
+font-face-src
+font-face-uri
+foreignObject
+g
+glyph
+handler
+hkern
+image
+line
+linearGradient
+listener
+metadata
+missing-glyph
+mpath
+path
+polygon
+polyline
+prefetch
+radialGradient
+rect
+script
+set
+solidColor
+stop
+svg
+switch
+tbreak
+text
+textArea
+title
+tspan
+use
+video
+#######################################
+#
+# properties (SVG Tiny 1.2)
+#
+#######################################
+audio-level
+color
+color-rendering
+display
+display-align
+fill
+fill-opacity
+fill-rule
+font-family
+font-size
+font-style
+font-variant
+font-weight
+image-rendering
+line-increment
+opacity
+pointer-events
+shape-rendering
+solid-color
+solid-opacity
+stop-color
+stop-opacity
+stroke
+stroke-dasharray
+stroke-dashoffset
+stroke-linecap
+stroke-linejoin
+stroke-miterlimit
+stroke-opacity
+stroke-width
+text-align
+text-anchor
+text-rendering
+vector-effect
+viewport-fill
+viewport-fill-opacity
+visibility
+#######################################
+#
+# attributes (SVG Tiny 1.2)
+#
+#######################################
+accent-height
+accumulate
+additive
+alphabetic
+arabic-form
+ascent
+attributeName
+attributeType
+bandwidth
+baseProfile
+bbox
+begin
+by
+calcMode
+cap-height
+class
+contentScriptType
+cx
+cy
+d
+defaultAction
+descent
+dur
+editable
+end
+ev:event
+event
+externalResourcesRequired
+fill
+focusHighlight
+focusable
+font-family
+font-stretch
+font-style
+font-variant
+font-weight
+from
+g1
+g2
+glyph-name
+gradientUnits
+handler
+hanging
+height
+height
+horiz-adv-x
+horiz-origin-x
+id
+ideographic
+initialVisibility
+k
+keyPoints
+keySplines
+keyTimes
+lang
+mathematical
+max
+mediaCharacterEncoding
+mediaContentEncodings
+mediaSize
+mediaTime
+min
+nav-down
+nav-down-left
+nav-down-right
+nav-left
+nav-next
+nav-prev
+nav-right
+nav-up
+nav-up-left
+nav-up-right
+observer
+offset
+origin
+overlay
+overline-position
+overline-thickness
+panose-1
+path
+pathLength
+phase
+playbackOrder
+points
+preserveAspectRatio
+propagate
+r
+repeatCount
+repeatDur
+requiredExtensions
+requiredFeatures
+requiredFonts
+requiredFormats
+restart
+rotate
+rx
+ry
+slope
+snapshotTime
+stemh
+stemv
+strikethrough-position
+strikethrough-thickness
+style
+syncBehavior
+syncBehaviorDefault
+syncMaster
+syncTolerance
+syncToleranceDefault
+systemLanguage
+target
+timelineBegin
+to
+transform
+transformBehavior
+type
+u1
+u2
+underline-position
+underline-thickness
+unicode
+unicode-range
+units-per-em
+values
+version
+viewBox
+width
+widths
+x
+x-height
+x1
+x2
+xlink:actuate
+xlink:arcrole
+xlink:href
+xlink:role
+xlink:show
+xlink:title
+xlink:type
+xml:base
+xml:id
+xml:lang
+xml:space
+y
+y1
+y2
+zoomAndPan
\ No newline at end of file
--- filter/source/svg/units.cxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/units.cxx	2008-02-26 10:52:58.000000000 +0100
@@ -0,0 +1,146 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Jan Holesovsky   <kendy@suse.cz>
+ *      Fridrich Strba   <fridrich.strba@bluewin.ch>
+ *      Thorsten Behrens <tbehrens@novell.com>	   	
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_filter.hxx"
+
+#include "units.hxx"
+
+#include <string.h>
+#include <rtl/ustring.hxx>
+
+#include <boost/bind.hpp>
+#include <boost/spirit.hpp>
+#include <boost/spirit/dynamic/select.hpp>
+
+namespace svgi
+{
+
+namespace
+{
+
+void appendChar( rtl::OUString& str, char character)
+{
+	str += rtl::OUString((sal_Char *)&character, 1, RTL_TEXTENCODING_UTF8);
+}
+
+void appendString( rtl::OUString& str, const char *characters)
+{
+	str += rtl::OUString((sal_Char *)characters, strlen(characters), RTL_TEXTENCODING_UTF8);
+}
+
+void appendDouble( rtl::OUString& str, double value, SvgUnit unit )
+{
+	str += rtl::OUString::valueOf(convLength(value, unit));
+}
+
+} //namespace
+
+double convLength( double value, SvgUnit unit )
+{
+    // convert svg unit to internal coordinates ("pixel"). Since the
+    // OOo drawing layer is still largely integer-based, the initial
+    // viewport transformation includes a certain scale factor
+    switch ( unit )
+    {
+        case SVG_LENGTH_UNIT_CM: return value * 1000.0;
+        case SVG_LENGTH_UNIT_EM: fprintf( stderr, "TODO: legth type EM not implemented.\n" ); return 1000.0;
+        case SVG_LENGTH_UNIT_EX: fprintf( stderr, "TODO: legth type EX not implemented.\n" ); return 1000.0;
+        case SVG_LENGTH_UNIT_IN: return value * 2540.0;
+        case SVG_LENGTH_UNIT_MM: return value * 100.0;
+        case SVG_LENGTH_UNIT_PC: return value * 2540.0/6.0;
+        case SVG_LENGTH_UNIT_PCT: fprintf( stderr, "TODO: legth type PCT not implemented.\n" ); return 1000.0;
+        case SVG_LENGTH_UNIT_PT: return value * 2540.0/72.0;
+        case SVG_LENGTH_UNIT_PX: return value;
+		case SVG_LENGTH_UNIT_USER: return value * 2540.0/72.0;  //FIXME, not true according to the documentation
+        default: fprintf( stderr, "Unknown length type\n" );
+    }
+
+    return 0.0;
+}
+
+double convLength( const rtl::OUString& sValue )
+{
+    using namespace ::boost::spirit;
+
+    rtl::OString aUTF8 = rtl::OUStringToOString( sValue, 
+                                                 RTL_TEXTENCODING_UTF8 );  
+
+    double  nVal=0.0;
+    SvgUnit eUnit=SVG_LENGTH_UNIT_PX;
+    const bool bRes = parse(aUTF8.getStr(),
+        //  Begin grammar
+        (
+            real_p[assign_a(nVal)] 
+            >> (  str_p("cm") [assign_a(eUnit,SVG_LENGTH_UNIT_CM)]
+                | str_p("em") [assign_a(eUnit,SVG_LENGTH_UNIT_EM)]
+                | str_p("ex") [assign_a(eUnit,SVG_LENGTH_UNIT_EX)]
+                | str_p("in") [assign_a(eUnit,SVG_LENGTH_UNIT_IN)]
+                | str_p("mm") [assign_a(eUnit,SVG_LENGTH_UNIT_MM)]
+                | str_p("pc") [assign_a(eUnit,SVG_LENGTH_UNIT_PC)]
+                | str_p("pct")[assign_a(eUnit,SVG_LENGTH_UNIT_PCT)]
+                | str_p("pt") [assign_a(eUnit,SVG_LENGTH_UNIT_PT)]
+                | str_p("px") [assign_a(eUnit,SVG_LENGTH_UNIT_PX)]
+                | str_p("") [assign_a(eUnit,SVG_LENGTH_UNIT_USER)]
+                | end_p)
+        ),
+        //  End grammar
+        space_p).full;
+
+    if( !bRes )
+        return 0.0;
+
+    return convLength(nVal,eUnit);
+}
+
+#if 0
+void transformPathPointsString( rtl::OUString& sData )
+{
+    using namespace ::boost::spirit;
+
+	rtl::OUString sBackupString;
+    rtl::OString aUTF8 = rtl::OUStringToOString( sData, 
+                                                 RTL_TEXTENCODING_UTF8 );  
+    double  nVal=0.0;
+	const bool bRes = parse(aUTF8.getStr(),
+        //  Begin grammar
+        (
+            lexeme_d[
+				repeat_p(1, more)[
+					(real_p[assign_a(nVal)] >> str_p("cm")[boost::bind(&appendDouble,boost::ref(sBackupString),nVal,SVG_LENGTH_UNIT_CM)])
+    	    		| (real_p[assign_a(nVal)] >> str_p("em")[boost::bind(&appendDouble,boost::ref(sBackupString),nVal,SVG_LENGTH_UNIT_EM)])
+        	    	| (real_p[assign_a(nVal)] >> str_p("ex")[boost::bind(&appendDouble,boost::ref(sBackupString),nVal,SVG_LENGTH_UNIT_EX)])
+            	    | (real_p[assign_a(nVal)] >> str_p("in")[boost::bind(&appendDouble,boost::ref(sBackupString),nVal,SVG_LENGTH_UNIT_IN)])
+	            	| (real_p[assign_a(nVal)] >> str_p("mm")[boost::bind(&appendDouble,boost::ref(sBackupString),nVal,SVG_LENGTH_UNIT_MM)])
+					| (real_p[assign_a(nVal)] >> str_p("pc")[boost::bind(&appendDouble,boost::ref(sBackupString),nVal,SVG_LENGTH_UNIT_PC)])
+					| (real_p[assign_a(nVal)] >> str_p("pct")[boost::bind(&appendDouble,boost::ref(sBackupString),nVal,SVG_LENGTH_UNIT_PCT)])
+					| (real_p[assign_a(nVal)] >> str_p("pt")[boost::bind(&appendDouble,boost::ref(sBackupString),nVal,SVG_LENGTH_UNIT_PT)])
+					| (real_p[assign_a(nVal)] >> str_p("px")[boost::bind(&appendDouble,boost::ref(sBackupString),nVal,SVG_LENGTH_UNIT_PX)])
+					| (real_p[boost::bind(&appendDouble,boost::ref(sBackupString),_1,SVG_LENGTH_UNIT_USER)])
+					| anychar_p[boost::bind(&appendChar, boost::ref(sBackupString),_1)]
+				]
+			]
+		),
+        //  End grammar
+        space_p).full;
+
+	if ( bRes )
+			sData = sBackupString;
+}									
+#endif
+
+
+} // namespace svgi
--- filter/source/svg/units.hxx	1970-01-01 01:00:00.000000000 +0100
+++ filter/source/svg/units.hxx	2008-02-26 10:51:31.000000000 +0100
@@ -0,0 +1,47 @@
+/*************************************************************************
+ *
+ *    OpenOffice.org - a multi-platform office productivity suite
+ *
+ *    Author:
+ *      Jan Holesovsky   <kendy@suse.cz>
+ *      Fridrich Strba   <fridrich.strba@bluewin.ch>
+ *      Thorsten Behrens <tbehrens@novell.com>	   	
+ *
+ *      Copyright (C) 2008, Novell Inc.
+ *
+ *   The Contents of this file are made available subject to
+ *   the terms of GNU Lesser General Public License Version 2.1.
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_UNITS_HXX
+#define INCLUDED_UNITS_HXX
+
+#include <sal/config.h>
+
+namespace rtl{ class OUString; }
+namespace svgi
+{
+    enum SvgUnit
+    {
+        SVG_LENGTH_UNIT_CM,
+        SVG_LENGTH_UNIT_EM,
+        SVG_LENGTH_UNIT_EX,
+        SVG_LENGTH_UNIT_IN,
+        SVG_LENGTH_UNIT_MM,
+        SVG_LENGTH_UNIT_PC,
+        SVG_LENGTH_UNIT_PCT,
+        SVG_LENGTH_UNIT_PT,
+        SVG_LENGTH_UNIT_PX,
+		SVG_LENGTH_UNIT_USER
+    };
+
+    /// return svg_length_t in 100th's of mm
+    double convLength( double fVal, SvgUnit unit );
+    double convLength( const rtl::OUString& sValue );
+#if 0
+	void transformPathPointsString( rtl::OUString& sData );
+#endif
+} // namespace svgi
+
+#endif
