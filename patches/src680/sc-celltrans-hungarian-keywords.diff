Index: sc/source/core/inc/cellkeytranslator.hxx
===================================================================
RCS file: /cvs/sc/sc/source/core/inc/cellkeytranslator.hxx,v
retrieving revision 1.2
retrieving revision 1.2.50.1
diff -u -r1.2 -r1.2.50.1
--- sc/source/core/inc/cellkeytranslator.hxx	24 Jul 2007 09:22:56 -0000	1.2
+++ sc/source/core/inc/cellkeytranslator.hxx	6 Sep 2007 16:23:30 -0000	1.2.50.1
@@ -38,6 +38,7 @@
 
 #include "global.hxx"
 #include "opcode.hxx"
+#include "unotools/transliterationwrapper.hxx"
 #include <hash_map>
 #include <list>
 #include <memory>
@@ -92,6 +93,7 @@
 
     static ::std::auto_ptr<ScCellKeywordTranslator> spInstance;
     ScCellKeywordHashMap maStringNameMap;
+    ::utl::TransliterationWrapper maTransWrapper;
 };
 
 #endif
Index: sc/source/core/tool/cellkeytranslator.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/cellkeytranslator.cxx,v
retrieving revision 1.2
retrieving revision 1.2.50.5
diff -u -r1.2 -r1.2.50.5
--- sc/source/core/tool/cellkeytranslator.cxx	24 Jul 2007 09:23:06 -0000	1.2
+++ sc/source/core/tool/cellkeytranslator.cxx	6 Sep 2007 17:50:33 -0000	1.2.50.5
@@ -34,13 +34,21 @@
  ************************************************************************/
 
 #include "cellkeytranslator.hxx"
+#include "comphelper/processfactory.hxx"
+#include "i18npool/mslangid.hxx"
+#include "i18npool/lang.h"
 #include "rtl/ustring.hxx"
 
+#include <com/sun/star/i18n/TransliterationModules.hpp>
+
 using ::com::sun::star::lang::Locale;
+using ::com::sun::star::uno::Sequence;
 using ::std::list;
 using ::std::hash_map;
 using ::rtl::OUString;
 
+using namespace ::com::sun::star;
+
 enum LocaleMatch
 {
     LOCALE_MATCH_NONE = 0,
@@ -77,7 +85,8 @@
 
 ::std::auto_ptr<ScCellKeywordTranslator> ScCellKeywordTranslator::spInstance(NULL);
 
-static void lclMatchKeyword(String& rName, const ScCellKeywordHashMap& aMap, OpCode eOpCode = ocNone, const Locale* pLocale = NULL)
+static void lclMatchKeyword(String& rName, const ScCellKeywordHashMap& aMap, 
+                            OpCode eOpCode = ocNone, const Locale* pLocale = NULL)
 {
     ScCellKeywordHashMap::const_iterator itrEnd = aMap.end();
     ScCellKeywordHashMap::const_iterator itr = aMap.find(rName);
@@ -162,10 +171,15 @@
     if ( !spInstance.get() )
         spInstance.reset( new ScCellKeywordTranslator );
 
+    LanguageType eLang = pLocale ? MsLangId::convertLocaleToLanguageWithFallback(*pLocale) : LANGUAGE_SYSTEM;
+    Sequence<sal_Int32> aOffsets;
+    rName = spInstance->maTransWrapper.transliterate(rName, eLang, 0, rName.Len(), &aOffsets);
     lclMatchKeyword(rName, spInstance->maStringNameMap, eOpCode, pLocale);
 }
 
-ScCellKeywordTranslator::ScCellKeywordTranslator()
+ScCellKeywordTranslator::ScCellKeywordTranslator() :
+    maTransWrapper( ::comphelper::getProcessServiceFactory(), 
+                    i18n::TransliterationModules_LOWERCASE_UPPERCASE )
 {
     init();
 }
@@ -176,42 +190,26 @@
 
 struct TransItem
 {
-    const sal_Char* from;
-    const sal_Char* to;
-    OpCode          func;
+    const sal_Unicode*  from;
+    const sal_Char*     to;
+    OpCode              func;
 };
 
 void ScCellKeywordTranslator::init()
 {
-    // 1. Keywords must be all uppercase.
-    // 2. Mapping must be <localized string name> to <English string name>.
+    ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
 
-    // French language locale.
+    // The file below has been autogenerated by sc/workben/celltrans/parse.py.
+    // To add new locale keywords, edit sc/workben/celltrans/keywords_utf16.txt
+    // and re-run the parse.py script.
+    // 
+    // All keywords must be uppercase, and the mapping must be from the 
+    // localized keyword to the English keyword.
+    // 
+    // Make sure that the original keyword file (keywords_utf16.txt) is 
+    // encoded in UCS-2/UTF-16!
 
-    static const Locale aFr(OUString::createFromAscii("fr"), OUString(), OUString());
-    static const TransItem pFr[] = 
-    {
-        // CELL
-        {"ADRESSE",    "ADDRESS",   ocCell},
-        {"COLONNE",    "COL",       ocCell},
-        {"CONTENU",    "CONTENTS",  ocCell},
-        {"COULEUR",    "COLOR",     ocCell},
-        {"LARGEUR",    "WIDTH",     ocCell},
-        {"LIGNE",      "ROW",       ocCell},
-        {"NOMFICHIER", "FILENAME",  ocCell},
-        {"PREFIXE",    "PREFIX",    ocCell},
-        {"PROTEGE",    "PROTECT",   ocCell},
-
-        // INFO
-        {"NBFICH",     "NUMFILE",   ocInfo},
-        {"RECALCUL",   "RECALC",    ocInfo},
-        {"SYSTEXPL",   "SYSTEM",    ocInfo},
-        {"VERSION",    "RELEASE",   ocInfo},
-        {"VERSIONSE",  "OSVERSION", ocInfo},
-
-        {NULL, NULL, ocNone}
-    };
-    addToMap(pFr, aFr);
+    #include "cellkeywords.inl"
 }
 
 void ScCellKeywordTranslator::addToMap(const String& rKey, const sal_Char* pName, const Locale& rLocale, OpCode eOpCode)
@@ -235,5 +233,5 @@
 void ScCellKeywordTranslator::addToMap(const TransItem* pItems, const Locale& rLocale)
 {
     for (sal_uInt16 i = 0; pItems[i].from != NULL; ++i)
-        addToMap(String::CreateFromAscii(pItems[i].from), pItems[i].to, rLocale, pItems[i].func);
+        addToMap(String(pItems[i].from), pItems[i].to, rLocale, pItems[i].func);
 }
Index: sc/source/core/tool/cellkeywords.inl
===================================================================
RCS file: sc/source/core/tool/cellkeywords.inl
diff -N sc/source/core/tool/cellkeywords.inl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/core/tool/cellkeywords.inl	3 Oct 2007 20:15:32 -0000	1.1.2.3
@@ -0,0 +1,126 @@
+// This file has been automatically generated.  Do not hand-edit this!
+
+// ---------------------------------------------------------------------------
+// French language locale (automatically generated)
+// ---------------------------------------------------------------------------
+static const Locale aFr(OUString::createFromAscii("fr"), OUString(), OUString());
+
+// pre instantiations of localized function names
+static const sal_Unicode cell_address_fr[] = {
+    0x0041, 0x0044, 0x0052, 0x0045, 0x0053, 0x0053, 0x0045, 0x0000};
+static const sal_Unicode cell_col_fr[] = {
+    0x0043, 0x004F, 0x004C, 0x004F, 0x004E, 0x004E, 0x0045, 0x0000};
+static const sal_Unicode cell_contents_fr[] = {
+    0x0043, 0x004F, 0x004E, 0x0054, 0x0045, 0x004E, 0x0055, 0x0000};
+static const sal_Unicode cell_color_fr[] = {
+    0x0043, 0x004F, 0x0055, 0x004C, 0x0045, 0x0055, 0x0052, 0x0000};
+static const sal_Unicode cell_width_fr[] = {
+    0x004C, 0x0041, 0x0052, 0x0047, 0x0045, 0x0055, 0x0052, 0x0000};
+static const sal_Unicode cell_row_fr[] = {
+    0x004C, 0x0049, 0x0047, 0x004E, 0x0045, 0x0000};
+static const sal_Unicode cell_filename_fr[] = {
+    0x004E, 0x004F, 0x004D, 0x0046, 0x0049, 0x0043, 0x0048, 0x0049, 0x0045, 0x0052, 0x0000};
+static const sal_Unicode cell_prefix_fr[] = {
+    0x0050, 0x0052, 0x0045, 0x0046, 0x0049, 0x0058, 0x0045, 0x0000};
+static const sal_Unicode cell_protect_fr[] = {
+    0x0050, 0x0052, 0x004F, 0x0054, 0x0045, 0x0047, 0x0045, 0x0000};
+static const sal_Unicode info_numfile_fr[] = {
+    0x004E, 0x0042, 0x0046, 0x0049, 0x0043, 0x0048, 0x0000};
+static const sal_Unicode info_recalc_fr[] = {
+    0x0052, 0x0045, 0x0043, 0x0041, 0x004C, 0x0043, 0x0055, 0x004C, 0x0000};
+static const sal_Unicode info_system_fr[] = {
+    0x0053, 0x0059, 0x0053, 0x0054, 0x0045, 0x0058, 0x0050, 0x004C, 0x0000};
+static const sal_Unicode info_release_fr[] = {
+    0x0056, 0x0045, 0x0052, 0x0053, 0x0049, 0x004F, 0x004E, 0x0000};
+static const sal_Unicode info_osversion_fr[] = {
+    0x0056, 0x0045, 0x0052, 0x0053, 0x0049, 0x004F, 0x004E, 0x0053, 0x0045, 0x0000};
+
+static const TransItem pFr[] = {
+    {cell_address_fr, "ADDRESS", ocCell},
+    {cell_col_fr, "COL", ocCell},
+    {cell_contents_fr, "CONTENTS", ocCell},
+    {cell_color_fr, "COLOR", ocCell},
+    {cell_width_fr, "WIDTH", ocCell},
+    {cell_row_fr, "ROW", ocCell},
+    {cell_filename_fr, "FILENAME", ocCell},
+    {cell_prefix_fr, "PREFIX", ocCell},
+    {cell_protect_fr, "PROTECT", ocCell},
+    {info_numfile_fr, "NUMFILE", ocInfo},
+    {info_recalc_fr, "RECALC", ocInfo},
+    {info_system_fr, "SYSTEM", ocInfo},
+    {info_release_fr, "RELEASE", ocInfo},
+    {info_osversion_fr, "OSVERSION", ocInfo},
+    {NULL, NULL, ocNone}
+};
+
+addToMap(pFr, aFr);
+
+// ---------------------------------------------------------------------------
+// Hungarian language locale (automatically generated)
+// ---------------------------------------------------------------------------
+static const Locale aHu(OUString::createFromAscii("hu"), OUString(), OUString());
+
+// pre instantiations of localized function names
+static const sal_Unicode cell_address_hu[] = {
+    0x0043, 0x00CD, 0x004D, 0x0000};
+static const sal_Unicode cell_col_hu[] = {
+    0x004F, 0x0053, 0x005A, 0x004C, 0x004F, 0x0050, 0x0000};
+static const sal_Unicode cell_color_hu[] = {
+    0x0053, 0x005A, 0x00CD, 0x004E, 0x0000};
+static const sal_Unicode cell_contents_hu[] = {
+    0x0054, 0x0041, 0x0052, 0x0054, 0x0041, 0x004C, 0x004F, 0x004D, 0x0000};
+static const sal_Unicode cell_width_hu[] = {
+    0x0053, 0x005A, 0x00C9, 0x004C, 0x0045, 0x0053, 0x0000};
+static const sal_Unicode cell_row_hu[] = {
+    0x0053, 0x004F, 0x0052, 0x0000};
+static const sal_Unicode cell_filename_hu[] = {
+    0x0046, 0x0049, 0x004C, 0x0045, 0x004E, 0x00C9, 0x0056, 0x0000};
+static const sal_Unicode cell_prefix_hu[] = {
+    0x0050, 0x0052, 0x0045, 0x0046, 0x0049, 0x0058, 0x0000};
+static const sal_Unicode cell_protect_hu[] = {
+    0x0056, 0x00C9, 0x0044, 0x0045, 0x0054, 0x0054, 0x0000};
+static const sal_Unicode cell_coord_hu[] = {
+    0x004B, 0x004F, 0x004F, 0x0052, 0x0044, 0x0000};
+static const sal_Unicode cell_format_hu[] = {
+    0x0046, 0x004F, 0x0052, 0x004D, 0x0041, 0x0000};
+static const sal_Unicode cell_parentheses_hu[] = {
+    0x005A, 0x00C1, 0x0052, 0x00D3, 0x004A, 0x0045, 0x004C, 0x0045, 0x004B, 0x0000};
+static const sal_Unicode cell_sheet_hu[] = {
+    0x004C, 0x0041, 0x0050, 0x0000};
+static const sal_Unicode cell_type_hu[] = {
+    0x0054, 0x00CD, 0x0050, 0x0055, 0x0053, 0x0000};
+static const sal_Unicode info_numfile_hu[] = {
+    0x0046, 0x0049, 0x004C, 0x0045, 0x0053, 0x005A, 0x00C1, 0x004D, 0x0000};
+static const sal_Unicode info_recalc_hu[] = {
+    0x0053, 0x005A, 0x00C1, 0x004D, 0x004F, 0x004C, 0x00C1, 0x0053, 0x0000};
+static const sal_Unicode info_system_hu[] = {
+    0x0052, 0x0045, 0x004E, 0x0044, 0x0053, 0x005A, 0x0045, 0x0052, 0x0000};
+static const sal_Unicode info_release_hu[] = {
+    0x0056, 0x0045, 0x0052, 0x005A, 0x0049, 0x00D3, 0x0000};
+static const sal_Unicode info_osversion_hu[] = {
+    0x004F, 0x0050, 0x0052, 0x0045, 0x004E, 0x0044, 0x0053, 0x005A, 0x0045, 0x0052, 0x0000};
+
+static const TransItem pHu[] = {
+    {cell_address_hu, "ADDRESS", ocCell},
+    {cell_col_hu, "COL", ocCell},
+    {cell_color_hu, "COLOR", ocCell},
+    {cell_contents_hu, "CONTENTS", ocCell},
+    {cell_width_hu, "WIDTH", ocCell},
+    {cell_row_hu, "ROW", ocCell},
+    {cell_filename_hu, "FILENAME", ocCell},
+    {cell_prefix_hu, "PREFIX", ocCell},
+    {cell_protect_hu, "PROTECT", ocCell},
+    {cell_coord_hu, "COORD", ocCell},
+    {cell_format_hu, "FORMAT", ocCell},
+    {cell_parentheses_hu, "PARENTHESES", ocCell},
+    {cell_sheet_hu, "SHEET", ocCell},
+    {cell_type_hu, "TYPE", ocCell},
+    {info_numfile_hu, "NUMFILE", ocInfo},
+    {info_recalc_hu, "RECALC", ocInfo},
+    {info_system_hu, "SYSTEM", ocInfo},
+    {info_release_hu, "RELEASE", ocInfo},
+    {info_osversion_hu, "OSVERSION", ocInfo},
+    {NULL, NULL, ocNone}
+};
+
+addToMap(pHu, aHu);
Index: sc/source/core/tool/interpr1.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/interpr1.cxx,v
retrieving revision 1.50
retrieving revision 1.50.42.2
diff -u -r1.50 -r1.50.42.2
--- sc/source/core/tool/interpr1.cxx	31 Jul 2007 16:36:31 -0000	1.50
+++ sc/source/core/tool/interpr1.cxx	6 Sep 2007 16:23:30 -0000	1.50.42.2
@@ -1648,7 +1648,6 @@
 			String			aFuncResult;
 			ScBaseCell*		pCell = GetCell( aCellPos );
 
-			aInfoType.ToUpperAscii();
             ScCellKeywordTranslator::transKeyword(aInfoType, ScGlobal::pLocale, ocCell);
 
 // *** ADDRESS INFO ***
Index: sc/source/core/tool/interpr5.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/interpr5.cxx,v
retrieving revision 1.27
retrieving revision 1.27.48.2
diff -u -r1.27 -r1.27.48.2
--- sc/source/core/tool/interpr5.cxx	24 Jul 2007 09:23:32 -0000	1.27
+++ sc/source/core/tool/interpr5.cxx	6 Sep 2007 16:23:30 -0000	1.27.48.2
@@ -3977,7 +3977,7 @@
 {
 	if( MustHaveParamCount( GetByte(), 1 ) )
 	{
-        String aStr = String( GetString() ).ToUpperAscii();
+        String aStr = GetString();
         ScCellKeywordTranslator::transKeyword(aStr, ScGlobal::pLocale, ocInfo);
         if( aStr.EqualsAscii( "SYSTEM" ) )
             PushString( String( RTL_CONSTASCII_USTRINGPARAM( SC_INFO_OSVERSION ) ) );
Index: sc/workben/celltrans/keywords_utf16.txt
===================================================================
RCS file: sc/workben/celltrans/keywords_utf16.txt
diff -N sc/workben/celltrans/keywords_utf16.txt
Binary files /dev/null and /tmp/cvszCaOyZ differ
Index: sc/workben/celltrans/parse.py
===================================================================
RCS file: sc/workben/celltrans/parse.py
diff -N sc/workben/celltrans/parse.py
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/workben/celltrans/parse.py	6 Sep 2007 02:57:32 -0000	1.1.2.4
@@ -0,0 +1,217 @@
+#!/usr/bin/env python
+#***********************************************************************
+#
+#  OpenOffice.org - a multi-platform office productivity suite
+#
+#  $RCSfile$
+#
+#  $Revision$
+#
+#  last change: $Author$ $Date$
+#
+#  The Contents of this file are made available subject to
+#  the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#    GNU Lesser General Public License Version 2.1
+#    =============================================
+#    Copyright 2005 by Sun Microsystems, Inc.
+#    901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#    This library is free software; you can redistribute it and/or
+#    modify it under the terms of the GNU Lesser General Public
+#    License version 2.1, as published by the Free Software Foundation.
+#
+#    This library is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#    Lesser General Public License for more details.
+#
+#    You should have received a copy of the GNU Lesser General Public
+#    License along with this library; if not, write to the Free Software
+#    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#    MA  02111-1307  USA
+#
+#***********************************************************************
+
+import sys
+
+localeNames = {'fr': 'French', 'hu': 'Hungarian'}
+def getLocaleName (code):
+    global localeNames
+    if localeNames.has_key(code):
+        return localeNames[code]
+    else:
+        return "(unknown locale)"
+
+def getAscii (ords):
+    ascii = ''
+    for c in ords:
+        ascii += chr(c)
+    return ascii
+
+class LocaleData(object):
+    def __init__ (self, locale):
+        self.locale = locale
+        self.funcList = {}
+
+    def addKeywordMap (self, funcName, localeName, engName):
+        if not self.funcList.has_key(funcName):
+            self.funcList[funcName] = []
+
+        self.funcList[funcName].append([localeName, engName])
+
+    def getLocaleFuncVarName (self, func, pair):
+        return func.lower() + "_" + getAscii(pair[1]).lower() + "_" + self.locale
+
+    def dumpCode (self):
+        chars = ""
+
+        # locale output
+        chars += "// " + "-"*75 + "\n"
+        chars += "// %s language locale (automatically generated)\n"%getLocaleName(self.locale)
+        chars += "// " + "-"*75 + "\n"
+        chars += "static const Locale a" + self.locale.capitalize() + "(OUString::createFromAscii(\""
+        chars += self.locale
+        chars += "\"), OUString(), OUString());\n\n"
+
+        # pre instantiations of localized function names.
+        funcs = self.funcList.keys()
+        funcs.sort()
+        chars += "// pre instantiations of localized function names\n"
+        for func in funcs:
+            for item in self.funcList[func]:
+                chars += "static const sal_Unicode " + self.getLocaleFuncVarName(func, item) + "[] = {\n"
+                chars += "    "
+                isFirst = True
+                # Dump the UTF-16 bytes.
+                for uval in item[0]:
+                    if isFirst:
+                        isFirst = False
+                    else:
+                        chars += ", "
+                    chars += "0x%.4X"%uval
+
+                # Don't forget to null-terminate the string.
+                if not isFirst:
+                    chars += ", "
+                chars += "0x0000"
+
+                chars += "};\n"
+
+        # map item instantiations
+        chars += "\n"
+        chars += "static const TransItem p" + self.locale.capitalize() + "[] = {\n"
+        for func in funcs:
+            for item in self.funcList[func]:
+                chars += "    "
+                chars += "{%s, \"%s\", %s},\n"%(self.getLocaleFuncVarName(func, item),
+                                                getAscii(item[1]),
+                                                "oc"+func.capitalize())
+
+        chars += "    {NULL, NULL, ocNone}\n"
+        chars += "};\n\n"
+
+        # addToMap call
+        chars += "addToMap(%s, %s);\n"%(
+            "p"+self.locale.capitalize(), "a"+self.locale.capitalize())
+
+        return chars
+
+class Parser(object):
+
+    def __init__ (self, args):
+        # default input & output files.
+        self.infile = "./keywords_utf16.txt"
+        self.outfile = "../../source/core/tool/cellkeywords.inl"
+
+        if len(args) >= 2:
+            self.infile = args[1]
+        if len(args) >= 3:
+            self.outfile = args[2]
+
+    def getDByte (self):
+        # Assume little endian.
+        bh = ord(self.bytes[self.i])
+        bl = ord(self.bytes[self.i+1])
+        dbyte = bl*256 + bh
+        self.i += 2
+        return dbyte
+
+    def parseLine (self):
+        buf = []
+        while self.i < self.size:
+            dbyte = self.getDByte()
+            if dbyte == 0x000A:
+                break
+            buf.append(dbyte)
+        return buf
+
+    def dumpBuf (self, buf, linefeed=True):
+        for item in buf:
+            sys.stdout.write(chr(item))
+        if linefeed:
+            print ''
+
+    def parse (self):
+
+        file = open(self.infile, 'r')
+        self.bytes = file.read()
+        file.close()
+
+        self.size = len(self.bytes)
+        self.i = 0
+
+        localeList = []  # stores an array of locale data objects.
+        funcName = None
+        word = []
+        wordPair = []
+
+        while self.i < self.size:
+            dbyte = self.getDByte()
+            if dbyte == 0xFEFF and self.i == 2:
+                # unicode signature - ignore it.
+                pass
+            elif dbyte == 0x0024:
+                # $ - locale name
+                buf = self.parseLine()
+                locale = getAscii(buf)
+                localeList.append(LocaleData(locale))
+
+            elif dbyte == 0x0040:
+                # @ - function name
+                buf = self.parseLine()
+                funcName = getAscii(buf)
+
+            elif dbyte == 0x002C:
+                # , - comma separator
+                if len(word) > 0:
+                    wordPair.append(word)
+                    word = []
+            elif dbyte == 0x000A:
+                # linefeed
+                if len(word) > 0:
+                    wordPair.append(word)
+                    word = []
+                if len(wordPair) >= 2:
+                    localeList[-1].addKeywordMap(funcName, wordPair[0], wordPair[1])
+                wordPair = []
+            elif dbyte in [0x0009, 0x0020]:
+                # whitespace - ignore it.
+                pass
+            else:
+                word.append(dbyte)
+
+        chars = "// This file has been automatically generated.  Do not hand-edit this!\n"
+        for obj in localeList:
+            chars += "\n" + obj.dumpCode()
+    
+        # Write to output file.
+        file = open(self.outfile, 'w')
+        file.write(chars)
+        file.close()
+
+if __name__=='__main__':
+    parser = Parser(sys.argv)
+    parser.parse()
+
