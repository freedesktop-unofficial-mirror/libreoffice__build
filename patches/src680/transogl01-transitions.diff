diff -rup ../src680-m237.orig/slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx
--- ../src680-m237.orig/slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx	2007-12-05 15:02:57.000000000 +0100
+++ slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx	2007-12-10 16:54:17.000000000 +0100
@@ -236,9 +236,7 @@ void OGLTransitionerImpl::initWindowFrom
             SystemWindowData winData;
             winData.nSize = sizeof(winData);
             winData.pVisual = (void*)(vi->visual);
-            pWindow=new SystemChildWindow(pPWindow,
-                                          0,
-                                          &winData);
+            pWindow=new SystemChildWindow(pPWindow, 0, &winData, FALSE);
             pChildSysData = pWindow->GetSystemData();
             if( pChildSysData )
             {
@@ -275,10 +273,9 @@ void OGLTransitionerImpl::initWindowFrom
                                  GL_TRUE);
 
     glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx );
-
-    OSL_ENSURE( glXIsDirect(GLWin.dpy, GLWin.ctx) , "Can't Directly Render to the Screen, perhaps 3D transitions aren't for you." );
     glEnable(GL_CULL_FACE);
     glCullFace(GL_BACK);
+    glClearColor (0, 0, 0, 0);
     glClear(GL_COLOR_BUFFER_BIT);
     unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
     
@@ -289,9 +286,12 @@ void OGLTransitionerImpl::initWindowFrom
     glMaterialfv(GL_FRONT,GL_DIFFUSE,materialDiffuse);
     glEnable(GL_LIGHT0);
     glEnable(GL_NORMALIZE);
-        
-    if( EnteringBytes.hasElements() && EnteringBytes.hasElements())
+
+    if( LeavingBytes.hasElements() && EnteringBytes.hasElements())
        GLInitSlides();//we already have uninitialized slides, let's initialize 
+
+    if (pTransition)
+        pTransition->prepare ();
 }
 
 void OGLTransitionerImpl::setSlides( const uno::Reference< rendering::XBitmap >& xLeavingSlide, 
@@ -333,20 +333,22 @@ void OGLTransitionerImpl::GLInitSlides()
     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();
     double EyePos(10.0);
-    double RealF(-1.0);
-    double RealN(1.0);
+    double RealF(1.0);
+    double RealN(-1.0);
     double RealL(-1.0);
     double RealR(1.0);
     double RealB(-1.0);
     double RealT(1.0);
-    double ClipN(EyePos+2.0*RealN);
-    double ClipF(EyePos+2.0*RealF);
+    double ClipN(EyePos+5.0*RealN);
+    double ClipF(EyePos+15.0*RealF);
     double ClipL(RealL*8.0);
     double ClipR(RealR*8.0);
     double ClipB(RealB*8.0);
     double ClipT(RealT*8.0);
     //This scaling is to take the plane with BottomLeftCorner(-1,-1,0) and TopRightCorner(1,1,0) and map it to the screen after the perspective division.
-    glScaled( 1.0 / ( ( ( RealR * 2.0 * ClipN ) / ( EyePos * ( ClipR - ClipL ) ) ) - ( ( ClipR + ClipL ) / ( ClipR - ClipL ) ) ), 1 / ( ( ( RealT * 2.0 * ClipN ) / ( EyePos * ( ClipT - ClipB ) ) ) - ( ( ClipT + ClipB ) / ( ClipT - ClipB ) ) ) , 1.0 );
+    glScaled( 1.0 / ( ( ( RealR * 2.0 * ClipN ) / ( EyePos * ( ClipR - ClipL ) ) ) - ( ( ClipR + ClipL ) / ( ClipR - ClipL ) ) ),
+              1.0 / ( ( ( RealT * 2.0 * ClipN ) / ( EyePos * ( ClipT - ClipB ) ) ) - ( ( ClipT + ClipB ) / ( ClipT - ClipB ) ) ),
+              1.0 );
 	glFrustum(ClipL,ClipR,ClipB,ClipT,ClipN,ClipF);
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
@@ -449,11 +451,12 @@ void SAL_CALL OGLTransitionerImpl::updat
         
     glEnable(GL_DEPTH_TEST);
 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
-	//glLoadIdentity();
+
 	if(pTransition)
 	    pTransition->display( nTime , GLleavingSlide , GLenteringSlide , 
-                              SlideSize.Width/static_cast<double>(GLWin.Width),
-                              SlideSize.Height/static_cast<double>(GLWin.Height) );
+                              SlideSize.Width, SlideSize.Height,
+                              static_cast<double>(GLWin.Width),
+                              static_cast<double>(GLWin.Height) );
 	unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
 	if( pWindow )
         pWindow->Show();
@@ -465,6 +468,10 @@ void OGLTransitionerImpl::disposing()
     osl::MutexGuard const guard( m_aMutex );
     glDeleteTextures(1,&GLleavingSlide);
     glDeleteTextures(1,&GLenteringSlide);
+
+    if (pTransition)
+        pTransition->finish();
+
     if(GLWin.ctx)
 	{
 	    OSL_ENSURE( glXMakeCurrent(GLWin.dpy, None, NULL) , "Error releasing glX context" );
@@ -539,10 +546,25 @@ public:
             case animations::TransitionSubType::CORNERSIN :  
                 pTransition->makeInsideCubeFaceToLeft();
                 break;
+            case animations::TransitionSubType::LEFTTORIGHT :
+                pTransition->makeFallLeaving();
+                break;
+            case animations::TransitionSubType::TOPTOBOTTOM :
+                pTransition->makeTurnAround();
+                break;
+            case animations::TransitionSubType::TOPRIGHT :
+                pTransition->makeTurnDown();
+                break;
+            case animations::TransitionSubType::TOPLEFT :
+                pTransition->makeIris();
+                break;
+            case animations::TransitionSubType::BOTTOMRIGHT :
+                pTransition->makeRochade();
+                break;
             default:
                 return uno::Reference< presentation::XTransition >();
         }
-        
+
         rtl::Reference<OGLTransitionerImpl> xRes(
             new OGLTransitionerImpl(pTransition) );
         if( view.is () ) {
diff -rup ../src680-m237.orig/slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx
--- ../src680-m237.orig/slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx	2007-11-09 11:17:00.000000000 +0100
+++ slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx	2007-12-10 16:56:36.000000000 +0100
@@ -42,6 +43,9 @@ void OGLTransitionImpl::clear()
     OverallOperations.clear();
     maLeavingSlidePrimitives.clear();
     maEnteringSlidePrimitives.clear();
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
+        delete maSceneObjects[i];
+    maSceneObjects.clear();
 }
 
 OGLTransitionImpl::~OGLTransitionImpl()
@@ -49,8 +53,28 @@ OGLTransitionImpl::~OGLTransitionImpl()
     clear();
 }
 
-void OGLTransitionImpl::display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex , double SlideWidthScale, double SlideHeightScale)
+void OGLTransitionImpl::prepare()
 {
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
+        maSceneObjects[i]->prepare();
+    }
+}
+
+void OGLTransitionImpl::finish()
+{
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i) {
+        maSceneObjects[i]->finish();
+    }
+}
+
+void OGLTransitionImpl::display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex,
+                                 double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    double SlideWidthScale, SlideHeightScale;
+
+    SlideWidthScale = SlideWidth/DispWidth;
+    SlideHeightScale = SlideHeight/DispHeight;
+
     glPushMatrix();
     glEnable(GL_TEXTURE_2D);
     //TODO change to foreach
@@ -62,17 +86,21 @@ void OGLTransitionImpl::display( double 
     glBindTexture(GL_TEXTURE_2D, glEnteringSlideTex);
     for(unsigned int i(0); i < maEnteringSlidePrimitives.size(); ++i)
         maEnteringSlidePrimitives[i].display(nTime,SlideWidthScale,SlideHeightScale);
+
+    for(unsigned int i(0); i < maSceneObjects.size(); ++i)
+        maSceneObjects[i]->display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
+    
+
     glPopMatrix();
 }
 
-void Primitive::display(double nTime, double SlideWidthScale, double SlideHeightScale)
+void Primitive::display(double nTime, double WidthScale, double HeightScale)
 {
     glPushMatrix();
-    glEnable(GL_TEXTURE_2D);
     for(unsigned int i(0); i < Operations.size(); ++i)
-        Operations[i]->interpolate( nTime ,SlideWidthScale,SlideHeightScale);
-    glScaled(SlideWidthScale,SlideHeightScale,1);
-    
+        Operations[i]->interpolate( nTime ,WidthScale,HeightScale);
+    glScaled(WidthScale,HeightScale,1);
+
     glEnableClientState( GL_VERTEX_ARRAY );
     if(!Normals.empty())
     {
@@ -80,9 +108,9 @@ void Primitive::display(double nTime, do
         glEnableClientState( GL_NORMAL_ARRAY );
     }
     glEnableClientState( GL_TEXTURE_COORD_ARRAY );
-    glTexCoordPointer( 2 , GL_DOUBLE , 0 , &TexCoords[0] );
-    glVertexPointer( 3 , GL_DOUBLE , 0 , &Vertices[0] );
-    glDrawArrays( GL_TRIANGLES , 0 , Vertices.size() );
+    glTexCoordPointer( 2, GL_DOUBLE, 0, &TexCoords[0] );
+    glVertexPointer( 3, GL_DOUBLE, 0, &Vertices[0] );
+    glDrawArrays( GL_TRIANGLES, 0, Vertices.size() );
     glPopMatrix();
 }
 
@@ -92,6 +120,60 @@ Primitive::~Primitive()
         delete Operations[i];
 }
 
+void SceneObject::display(double nTime, double /* SlideWidth */, double /* SlideHeight */, double DispWidth, double DispHeight )
+{
+    for(unsigned int i(0); i < maPrimitives.size(); ++i) {
+        // fixme: allow various model spaces, now we make it so that
+        // it is regular -1,-1 to 1,1, where the whole display fits in
+        glPushMatrix();
+        if (DispHeight > DispWidth)
+            glScaled(DispHeight/DispWidth, 1, 1);
+        else
+            glScaled(1, DispWidth/DispHeight, 1);
+        maPrimitives[i].display(nTime, 1, 1);
+        glPopMatrix();
+    }
+}
+
+void SceneObject::pushPrimitive(Primitive p)
+{
+    maPrimitives.push_back(p);
+}
+
+SceneObject::SceneObject()
+    : maPrimitives()
+{
+}
+
+Iris::Iris()
+    : SceneObject ()
+{
+}
+
+void Iris::display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight )
+{
+    glBindTexture(GL_TEXTURE_2D, maTexture);
+    SceneObject::display(nTime, SlideWidth, SlideHeight, DispWidth, DispHeight);
+}
+
+void Iris::prepare()
+{
+    static GLubyte img[3] = { 80, 80, 80 };
+    
+    glGenTextures(1, &maTexture);
+    glBindTexture(GL_TEXTURE_2D, maTexture);
+    glTexImage2D(GL_TEXTURE_2D, 0, 3, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, img);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+}
+
+void Iris::finish()
+{
+    glDeleteTextures(1, &maTexture);
+}
+
 void OGLTransitionImpl::makeOutsideCubeFaceToLeft()
 {
     clear();
@@ -102,11 +184,11 @@ void OGLTransitionImpl::makeOutsideCubeF
 
     maLeavingSlidePrimitives.push_back(Slide);
 
-    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),-90,false,0.0,1.0));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),90,false,0.0,1.0));
 
     maEnteringSlidePrimitives.push_back(Slide);
 
-    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),90,true,0.0,1.0));
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),-90,true,0.0,1.0));
 }
 
 void OGLTransitionImpl::makeInsideCubeFaceToLeft()
@@ -119,11 +201,150 @@ void OGLTransitionImpl::makeInsideCubeFa
 
     maLeavingSlidePrimitives.push_back(Slide);
 
-    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),90,false,0.0,1.0));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),-90,false,0.0,1.0));
 
     maEnteringSlidePrimitives.push_back(Slide);
     
-    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),-90,true,0.0,1.0));
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),90,true,0.0,1.0));
+}
+
+void OGLTransitionImpl::makeFallLeaving()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(1,0,0),basegfx::B3DVector(0,-1,0), 90,true,0.0,1.0));
+    maLeavingSlidePrimitives.push_back(Slide);
+}
+
+void OGLTransitionImpl::makeTurnAround()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0),-180,false,0.0,1.0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, -1.5),true, 0, 0.5));
+    OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1.5), true, 0.5, 1));
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0, 1, 0),basegfx::B3DVector(0, 0, 0), -180, true, 0.0, 1.0));
+}
+
+void OGLTransitionImpl::makeTurnDown()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 0.0001), false, -1.0, 0.0));
+    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), -90, true, 0.0, 1.0));
+    Slide.Operations.push_back(new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(-1, 1, 0), 90, false, -1.0, 0.0));
+    maEnteringSlidePrimitives.push_back(Slide);
+}
+
+void OGLTransitionImpl::makeIris()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle (basegfx::B2DVector (0,0), basegfx::B2DVector (1,0), basegfx::B2DVector (0,1));
+    Slide.pushTriangle (basegfx::B2DVector (1,0), basegfx::B2DVector (0,1), basegfx::B2DVector (1,1));
+    maEnteringSlidePrimitives.push_back (Slide);
+
+    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, 0.0001), false, -1, 0));
+    Slide.Operations.push_back (new STranslate (basegfx::B3DVector (0, 0, -0.0002), false, 0.5, 1));
+    maLeavingSlidePrimitives.push_back (Slide);
+
+
+    Primitive irisPart, part;
+    int i, nSteps = 24, nParts = 7;
+    double lt = 0, t = 1.0/nSteps, cx, cy, lcx, lcy, lx = 1, ly = 0, x, y, cxo, cyo, lcxo, lcyo, of=2.2, f=1.42;
+
+    for (i=1; i<=nSteps; i++) {
+        x = cos ((3*2*M_PI*t)/nParts);
+        y = -sin ((3*2*M_PI*t)/nParts);
+        cx = (f*x + 1)/2;
+        cy = (f*y + 1)/2;
+        lcx = (f*lx + 1)/2;
+        lcy = (f*ly + 1)/2;
+        cxo = (of*x + 1)/2;
+        cyo = (of*y + 1)/2;
+        lcxo = (of*lx + 1)/2;
+        lcyo = (of*ly + 1)/2;
+        irisPart.pushTriangle (basegfx::B2DVector (lcx, lcy),
+                               basegfx::B2DVector (lcxo, lcyo),
+                               basegfx::B2DVector (cx, cy));
+        irisPart.pushTriangle (basegfx::B2DVector (cx, cy),
+                               basegfx::B2DVector (lcxo, lcyo),
+                               basegfx::B2DVector (cxo, cyo));
+        lx = x;
+        ly = y;
+        lt = t;
+        t += 1.0/nSteps;
+    }
+
+    Iris* pIris = new Iris();
+    double angle = 87;
+
+    for (i = 0; i < nParts; i++) {
+        irisPart.Operations.clear ();
+        double rx, ry;
+
+        rx = cos ((2*M_PI*i)/nParts);
+        ry = sin ((2*M_PI*i)/nParts);
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0),  angle, true, 0.0, 0.5));
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(rx, ry, 0), -angle, true, 0.5, 1));
+        if (i > 0) {
+            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(rx, ry, 0),  false, -1, 0));
+            irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(0, 0, 1), basegfx::B3DVector(0, 0, 0), i*360.0/nParts, false, -1, 0));
+            irisPart.Operations.push_back (new STranslate (basegfx::B3DVector(-1, 0, 0),  false, -1, 0));
+        }
+        irisPart.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, 1), false, -2, 0.0));
+        irisPart.Operations.push_back (new SRotate (basegfx::B3DVector(1, .5, 0), basegfx::B3DVector(1, 0, 0), -30, false, -1, 0));
+        pIris->pushPrimitive (irisPart);
+    }
+
+    maSceneObjects.push_back (pIris);
+}
+
+void OGLTransitionImpl::makeRochade()
+{
+    clear();
+    Primitive Slide;
+    
+    double w, h;
+
+    w = 2.2;
+    h = 5;
+
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.25, -0.25, true, 0, 1));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.clear();
+    Slide.Operations.push_back(new SEllipseTranslate(w, h, 0.75, 0.25, true, 0, 1));
+    Slide.Operations.push_back(new STranslate(basegfx::B3DVector(0, 0, -h), false, -1, 0));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), -45, true, 0, 1));
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,0), 45, false, -1, 0));
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    //     OverallOperations.push_back(new SEllipseTranslate(0.5, 2, 0, 1, true, 0, 1));
+//      push_back(new STranslate(basegfx::B3DVector(0, 0, -2), true, 0, 0.5));
+//      OverallOperations.push_back(new STranslate(basegfx::B3DVector(0, 0, 2), true, 0.5, 1));
 }
 
 // TODO(Q3): extract to basegfx
@@ -237,7 +544,7 @@
         NextRadius += dRadius;
     }
     {
-        Radius = sqrt(2);
+        Radius = sqrt(2.0);
         Primitive LeavingSlide;
         Primitive EnteringSlide;
         for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
@@ -408,6 +629,34 @@ void RotateAndScaleDepthByWidth::interpo
     glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-SlideWidthScale*origin.getZ());
 }
 
+SEllipseTranslate::SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+    width = dWidth;
+    height = dHeight;
+    startPosition = dStartPosition;
+    endPosition = dEndPosition;
+}
+
+void SEllipseTranslate::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+
+    double a1, a2, x, y;
+    a1 = startPosition*2*M_PI;
+    a2 = (startPosition + t*(endPosition - startPosition))*2*M_PI;
+    x = width*(cos (a2) - cos (a1))/2;
+    y = height*(sin (a2) - sin (a1))/2;
+
+    glTranslated(x, 0, y);
+}
+
 STranslate* STranslate::clone()
 {
     return new STranslate(*this);
@@ -422,6 +673,11 @@ SScale* SScale::clone()
     return new SScale(*this);
 }
 
+SEllipseTranslate* SEllipseTranslate::clone()
+{
+    return new SEllipseTranslate(*this);
+}
+
 RotateAndScaleDepthByWidth* RotateAndScaleDepthByWidth::clone()
 {
     return new RotateAndScaleDepthByWidth(*this);
@@ -464,7 +730,7 @@
     Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
 
     //figure out if they're facing the correct way, and make them face the correct way.
-    basegfx::B3DVector Normal( cross( Verts[0] - Verts[1] , Verts[1] - Verts[2] ) );
+    basegfx::B3DVector Normal( basegfx::cross( Verts[0] - Verts[1] , Verts[1] - Verts[2] ) );
     if(Normal.getZ() >= 0.0)//if the normal is facing us
     {
         Texs.push_back(SlideLocation0);
@@ -494,4 +750,3 @@ void Primitive::pushTriangle(const baseg
     Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
     Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
 }
-
diff -rup ../src680-m237.orig/slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx
--- ../src680-m237.orig/slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx	2007-12-05 15:02:49.000000000 +0100
+++ slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx	2007-12-05 16:43:08.000000000 +0100
@@ -39,9 +39,11 @@
 #include <basegfx/vector/b3dvector.hxx>
 
 #include <vector>
+#include <GL/gl.h>
 
 class Primitive;
 class Operation;
+class SceneObject;
 
 /** OpenGL 3D Transition class. It implicitly is constructed from XOGLTransition
 
@@ -52,17 +54,26 @@ class OGLTransitionImpl
 public:
     OGLTransitionImpl() :
         maLeavingSlidePrimitives(),
-        maEnteringSlidePrimitives()
+        maEnteringSlidePrimitives(),
+        maSceneObjects()
     {}
 
     ~OGLTransitionImpl();
     
-    void display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex , double SlideWidthScale, double SlideHeightScale);
+    void prepare();
+    void display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    void finish();
+
     void makeOutsideCubeFaceToLeft();
     void makeInsideCubeFaceToLeft();
     void makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m );
     void makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles );
     void makeHelix( ::sal_uInt16 nRows );
+    void makeFallLeaving();
+    void makeTurnAround();
+    void makeTurnDown();
+    void makeIris();
+    void makeRochade();
 
 private:
     /** clears all the primitives and operations
@@ -77,11 +88,46 @@ private:
 	*/
     std::vector<Primitive> maEnteringSlidePrimitives;
     
+    /** All the surrounding scene objects
+	*/
+    std::vector<SceneObject*> maSceneObjects;
+
     /** All the operations that should be applied to both leaving and entering slide primitives. These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
 	*/
 	std::vector<Operation*> OverallOperations;
 };
 
+class SceneObject
+{
+public:
+    SceneObject();
+
+    virtual void prepare() {};
+    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    virtual void finish() {};
+
+    void pushPrimitive (Primitive p);
+
+protected:
+    /** All the surrounding scene primitives
+	*/
+    std::vector<Primitive> maPrimitives;
+};
+
+class Iris : public SceneObject
+{
+public:
+    Iris ();
+
+    virtual void prepare();
+    virtual void display(double nTime, double SlideWidth, double SlideHeight, double DispWidth, double DispHeight);
+    virtual void finish();
+
+private:
+
+    GLuint maTexture;
+};
+
 /** This class is a list of Triangles that will share Operations, and could possibly share  
 */
 class Primitive
@@ -301,6 +347,42 @@ private:
 	basegfx::B3DVector vector;
 };
 
+/** translation transformation
+*/
+class SEllipseTranslate: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    SEllipseTranslate* clone();
+	
+	/** Constructor
+	    
+	    @param Vector
+	    vector to translate
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	SEllipseTranslate(double dWidth, double dHeight, double dStartPosition, double dEndPosition, bool bInter, double T0, double T1);
+	~SEllipseTranslate(){}
+private:
+    /** width and length of the ellipse
+     */
+    double width, height;
+
+    /** start and end position on the ellipse <0,1>
+     */
+    double startPosition;
+    double endPosition;
+};
+
 /** Same as SRotate, except the depth is scaled by the width of the slide divided by the width of the window.
 */
 class RotateAndScaleDepthByWidth: public Operation
