--- config_office/configure.in.old	2007-10-12 15:22:45.000000000 +0200
+++ config_office/configure.in	2007-10-11 20:32:30.000000000 +0200
@@ -4339,7 +4339,7 @@ AC_MSG_CHECKING([which neon to use])
 if test -n "$with_system_neon" -o -n "$with_system_libs" && \
 	test "$with_system_neon" != "no"; then
         AC_MSG_RESULT([external])
-        PKG_CHECK_MODULES(NEON, neon >= 0.26.0, , AC_MSG_ERROR([you need neon >= 0.26.x for system-neon]))
+        PKG_CHECK_MODULES(NEON, neon >= 0.24.0, , AC_MSG_ERROR([you need neon >= 0.24.x for system-neon]))
         NEON_VERSION="`$PKG_CONFIG --modversion neon | $SED 's/\.//g'`"
         NEON_CFLAGS="$NEON_CFLAGS -DSYSTEM_NEON -DUSE_DAV_LOCKS=1"
         SYSTEM_NEON=YES
--- ucb/source/ucp/webdav/LinkSequence.cxx.old	2007-07-03 14:12:27.000000000 +0200
+++ ucb/source/ucp/webdav/LinkSequence.cxx	2007-10-12 15:00:48.000000000 +0200
@@ -180,7 +180,11 @@ bool LinkSequence::createFromXML( const 
                       rInData.getStr() + nStart,
                       nEnd - nStart + TOKEN_LENGTH );
 
+#if NEON_VERSION >= 0250
         success = !ne_xml_failed( parser );
+#else
+        success = !!ne_xml_valid( parser );
+#endif
 
         ne_xml_destroy( parser );
 
--- ucb/source/ucp/webdav/LockEntrySequence.cxx.old	2007-07-03 14:12:39.000000000 +0200
+++ ucb/source/ucp/webdav/LockEntrySequence.cxx	2007-10-12 10:42:28.000000000 +0200
@@ -205,7 +205,11 @@ bool LockEntrySequence::createFromXML( c
                        rInData.getStr() + nStart,
                        nEnd - nStart + TOKEN_LENGTH );
 
+#if NEON_VERSION >= 0250
         success = !ne_xml_failed( parser );
+#else
+        success = !!ne_xml_valid( parser );
+#endif
 
         ne_xml_destroy( parser );
 
--- ucb/source/ucp/webdav/LockSequence.cxx.old	2007-07-03 14:12:52.000000000 +0200
+++ ucb/source/ucp/webdav/LockSequence.cxx	2007-10-12 10:43:58.000000000 +0200
@@ -338,7 +338,11 @@ bool LockSequence::createFromXML( const 
                       rInData.getStr() + nStart,
                       nEnd - nStart + TOKEN_LENGTH );
 
+#if NEON_VERSION >= 0250
         success = !ne_xml_failed( parser );
+#else
+        success = !!ne_xml_valid( parser );
+#endif
 
         ne_xml_destroy( parser );
 
--- ucb/source/ucp/webdav/NeonHeadRequest.cxx.old	2007-07-03 14:13:05.000000000 +0200
+++ ucb/source/ucp/webdav/NeonHeadRequest.cxx	2007-10-12 15:07:59.000000000 +0200
@@ -56,6 +56,7 @@ using namespace com::sun::star;
 
 namespace {
 
+#if NEON_VERSION >= 0250
 void process_headers(ne_request *req,
                      DAVResource &rResource,
                      const std::vector< ::rtl::OUString > &rHeaderNames)
@@ -104,6 +105,69 @@ void process_headers(ne_request *req,
         }
     }
 }
+#else
+struct NeonHeadRequestContext
+{
+    DAVResource * pResource;
+    const std::vector< ::rtl::OUString > * pHeaderNames;
+
+    NeonHeadRequestContext( DAVResource * p,
+                            const std::vector< ::rtl::OUString > * pHeaders )
+    : pResource( p ), pHeaderNames( pHeaders ) {}
+};
+
+extern "C" void NHR_ResponseHeaderCatcher( void * userdata,
+                                           const char * value )
+{
+    rtl::OUString aHeader( rtl::OUString::createFromAscii( value ) );
+    sal_Int32 nPos = aHeader.indexOf( ':' );
+
+    if ( nPos != -1 )
+    {
+        rtl::OUString aHeaderName( aHeader.copy( 0, nPos ) );
+
+        NeonHeadRequestContext * pCtx
+            = static_cast< NeonHeadRequestContext * >( userdata );
+
+        // Note: Empty vector means that all headers are requested.
+        bool bIncludeIt = ( pCtx->pHeaderNames->size() == 0 );
+
+        if ( !bIncludeIt )
+        {
+            // Check whether this header was requested.
+            std::vector< ::rtl::OUString >::const_iterator it(
+                pCtx->pHeaderNames->begin() );
+            const std::vector< ::rtl::OUString >::const_iterator end(
+                pCtx->pHeaderNames->end() );
+
+            while ( it != end )
+            {
+                if ( (*it) == aHeaderName )
+                    break;
+
+                ++it;
+            }
+
+            if ( it != end )
+                bIncludeIt = true;
+        }
+
+        if ( bIncludeIt )
+        {
+            // Create & set the PropertyValue
+            DAVPropertyValue thePropertyValue;
+            thePropertyValue.Name = aHeaderName;
+            thePropertyValue.IsCaseSensitive = false;
+
+            if ( nPos < aHeader.getLength() )
+                thePropertyValue.Value <<= aHeader.copy( nPos + 1 ).trim();
+
+            // Add the newly created PropertyValue
+            pCtx->pResource->properties.push_back( thePropertyValue );
+        }
+    }
+}
+#endif
 
 } // namespace
 
@@ -129,9 +193,16 @@ NeonHeadRequest::NeonHeadRequest( HttpSe
                                             inPath,
                                             RTL_TEXTENCODING_UTF8 ) );
 
+#if NEON_VERSION < 0250
+    NeonHeadRequestContext aCtx( &ioResource, &inHeaderNames );
+    ne_add_response_header_catcher( req, NHR_ResponseHeaderCatcher, &aCtx );
+#endif
+
     nError = ne_request_dispatch( req );
 
+#if NEON_VERSION >= 0250
     process_headers(req, ioResource, inHeaderNames);
+#endif
 
     if ( nError == NE_OK && ne_get_status( req )->klass != 2 )
         nError = NE_ERROR;
--- ucb/source/ucp/webdav/NeonPropFindRequest.cxx.old	2007-07-03 14:13:17.000000000 +0200
+++ ucb/source/ucp/webdav/NeonPropFindRequest.cxx	2007-10-12 11:53:50.000000000 +0200
@@ -176,14 +176,19 @@ extern "C" int NPFR_propfind_iter( void*
 
 // -------------------------------------------------------------------
 extern "C" void NPFR_propfind_results( void* userdata,
+#if NEON_VERSION >= 0260
                                        const ne_uri* href_uri,
+#else
+                                       const char* href,
+#endif
                                        const NeonPropFindResultSet* set )
 {
 	// @@@ href is not the uri! DAVResource ctor wants uri!
 
+#if NEON_VERSION >= 0260
 	// href should be free'd? says header ...
 	char* href = ne_uri_unparse(href_uri);
-
+#endif
 	DAVResource theResource(
 						OStringToOUString( href, RTL_TEXTENCODING_UTF8 ) );
 
@@ -213,14 +218,19 @@ extern "C" int NPFR_propnames_iter( void
 
 // -------------------------------------------------------------------
 extern "C" void NPFR_propnames_results( void* userdata,
+#if NEON_VERSION >= 0260
                                         const ne_uri* href_uri,
+#else
+                                        const char* href,
+#endif
                                         const NeonPropFindResultSet* results )
 {
 	// @@@ href is not the uri! DAVResourceInfo ctor wants uri!
 
+#if NEON_VERSION >= 0260
 	// href should be free'd? says header ...
 	char* href = ne_uri_unparse(href_uri);
-
+#endif
 	// Create entry for the resource.
 	DAVResourceInfo theResource(
 						OStringToOUString( href, RTL_TEXTENCODING_UTF8 ) );
--- ucb/source/ucp/webdav/NeonSession.cxx.old	2007-10-11 20:32:19.000000000 +0200
+++ ucb/source/ucp/webdav/NeonSession.cxx	2007-10-12 15:12:32.000000000 +0200
@@ -211,7 +211,11 @@ struct NeonRequestContext
 // A simple Neon response_block_reader for use with an XInputStream
 // -------------------------------------------------------------------
 
+#if NEON_VERSION >= 0250
 extern "C" int NeonSession_ResponseBlockReader(void * inUserData, 
+#else
+extern "C" void NeonSession_ResponseBlockReader(void * inUserData, 
+#endif
                                                const char * inBuf, 
                                                size_t inLen )
 {
@@ -227,7 +231,9 @@ extern "C" int NeonSession_ResponseBlock
         if ( xInputStream.is() )
             xInputStream->AddToStream( inBuf, inLen );
     }
+#if NEON_VERSION >= 0250
     return 0;
+#endif
 }
 
 // -------------------------------------------------------------------
@@ -235,7 +241,11 @@ extern "C" int NeonSession_ResponseBlock
 // A simple Neon response_block_reader for use with an XOutputStream
 // -------------------------------------------------------------------
 
+#if NEON_VERSION >= 0250
 extern "C" int NeonSession_ResponseBlockWriter( void * inUserData, 
+#else
+extern "C" void NeonSession_ResponseBlockWriter( void * inUserData, 
+#endif
                                                 const char * inBuf, 
                                                 size_t inLen )
 {
@@ -253,7 +263,9 @@ extern "C" int NeonSession_ResponseBlock
             xOutputStream->writeBytes( aSeq );
         }
     }
+#if NEON_VERSION >= 0250
     return 0;
+#endif
 }
 
 // -------------------------------------------------------------------
@@ -1472,10 +1484,15 @@ int NeonSession::GET( ne_session * sess,
     void *cursor = NULL;
     const char *name, *value;
 
+#if NEON_VERSION < 0250
+    if ( getheaders )
+	ne_add_response_header_catcher( req, runResponseHeaderHandler, userdata );
+#endif
     ne_add_response_body_reader( req, ne_accept_2xx, reader, userdata );
 
     ret = ne_request_dispatch( req );
 
+#if NEON_VERSION >= 0250
     if ( getheaders )
     {
         while ((cursor = ne_response_header_iterate(req, cursor, &name, &value)) 
@@ -1488,6 +1505,7 @@ int NeonSession::GET( ne_session * sess,
             runResponseHeaderHandler(userdata, buffer);
         }
     }
+#endif
     if ( ret == NE_OK && ne_get_status( req )->klass != 2 )
         ret = NE_ERROR;
 
--- ucb/source/ucp/webdav/NeonUri.cxx.old	2007-07-18 09:49:06.000000000 +0200
+++ ucb/source/ucp/webdav/NeonUri.cxx	2007-10-12 13:52:13.000000000 +0200
@@ -73,24 +73,36 @@ using namespace webdav_ucp;
 namespace {
 
 const ne_uri g_sUriDefaultsHTTP  = { "http",  
+#if NEON_VERSION >= 0260
                                      NULL, 
+#endif
                                      NULL, 
                                      DEFAULT_HTTP_PORT, 
+#if NEON_VERSION >= 0260
                                      NULL, 
+#endif
                                      NULL, 
                                      NULL };
 const ne_uri g_sUriDefaultsHTTPS = { "https", 
+#if NEON_VERSION >= 0260
                                      NULL, 
+#endif
                                      NULL, 
                                      DEFAULT_HTTPS_PORT, 
+#if NEON_VERSION >= 0260
                                      NULL, 
+#endif
                                      NULL, 
                                      NULL };
 const ne_uri g_sUriDefaultsFTP   = { "ftp",   
+#if NEON_VERSION >= 0260
                                      NULL, 
+#endif
                                      NULL, 
                                      DEFAULT_FTP_PORT, 
+#if NEON_VERSION >= 0260
                                      NULL, 
+#endif
                                      NULL, 
                                      NULL };
 } // namespace
@@ -176,7 +188,11 @@ void NeonUri::init( const rtl::OString &
                     pUri->scheme ? pUri->scheme : pUriDefs->scheme,
                     RTL_TEXTENCODING_UTF8 );
     mUserInfo = rtl::OStringToOUString(
+#if NEON_VERSION >= 0260
                     pUri->userinfo ? pUri->userinfo : pUriDefs->userinfo,
+#else
+                    pUri->authinfo ? pUri->authinfo : pUriDefs->authinfo,
+#endif
                     RTL_TEXTENCODING_UTF8 );
     mHostName = rtl::OStringToOUString(
                     pUri->host ? pUri->host : pUriDefs->host,
@@ -186,6 +202,7 @@ void NeonUri::init( const rtl::OString &
                     pUri->path ? pUri->path : pUriDefs->path,
                     RTL_TEXTENCODING_UTF8 );
 
+#if NEON_VERSION >= 0260
     if ( pUri->query ) 
     {
         mPath += rtl::OUString::createFromAscii( "?" );
@@ -199,6 +216,7 @@ void NeonUri::init( const rtl::OString &
         mPath += rtl::OStringToOUString( 
             pUri->fragment,  RTL_TEXTENCODING_UTF8 );
     }
+#endif
 }
 
 // -------------------------------------------------------------------
--- ucb/source/ucp/webdav/UCBDeadPropertyValue.cxx.old	2007-07-03 14:14:22.000000000 +0200
+++ ucb/source/ucp/webdav/UCBDeadPropertyValue.cxx	2007-10-12 13:53:32.000000000 +0200
@@ -393,7 +393,11 @@ bool UCBDeadPropertyValue::createFromXML
 
         ne_xml_parse( parser, rInData.getStr(), rInData.getLength() );
 
+#if NEON_VERSION >= 0250
         success = !ne_xml_failed( parser );
+#else
+        success = !!ne_xml_valid( parser );
+#endif
 
         ne_xml_destroy( parser );
 
