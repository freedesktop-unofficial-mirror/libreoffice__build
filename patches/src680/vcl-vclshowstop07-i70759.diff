--- vcl/source/gdi/sallayout.cxx.O	2006-11-07 18:46:54.000000000 +0100
+++ vcl/source/gdi/sallayout.cxx	2006-11-07 18:47:00.000000000 +0100
@@ -1198,27 +1198,28 @@
 
             // do not stretch non-stretchable glyphs
             if( (pG->mnOrigWidth <= 0) || (nStretchable <= 0) )
-	        continue;
+                continue;
 
             // distribute extra space equally to stretchable glyphs
             int nDeltaWidth = nDiffWidth / nStretchable--;
             nDiffWidth     -= nDeltaWidth;
             pG->mnNewWidth += nDeltaWidth;
             nDeltaSum      += nDeltaWidth;
-	}
+        }
     }
     else // condensed case
     {
-	// squeeze width by moving glyphs proportionally
+        // squeeze width by moving glyphs proportionally
+        double fSqueeze = (double)nNewWidth / nOldWidth;
         for( pG = mpGlyphItems; ++pG < pGRight;)
-	{
-	    int nX = pG->maLinearPos.X() - maBasePoint.X();
-	    nX = nX * nNewWidth / nOldWidth;
-	    pG->maLinearPos.X() = nX + maBasePoint.X();
-	}
-	// adjust glyph widths to new positions
+        {
+            int nX = pG->maLinearPos.X() - maBasePoint.X();
+            nX = (int)(nX * fSqueeze);
+            pG->maLinearPos.X() = nX + maBasePoint.X();
+        }
+        // adjust glyph widths to new positions
         for( pG = mpGlyphItems; pG < pGRight; ++pG )
-	    pG->mnNewWidth = pG[1].maLinearPos.X() - pG[0].maLinearPos.X();
+            pG->mnNewWidth = pG[1].maLinearPos.X() - pG[0].maLinearPos.X();
     }
 }
 
