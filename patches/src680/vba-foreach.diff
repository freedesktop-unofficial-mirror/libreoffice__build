Index: basic/source/runtime/runtime.cxx
===================================================================
--- basic/source/runtime/runtime.cxx	(revision 28)
+++ basic/source/runtime/runtime.cxx	(revision 90)
@@ -59,6 +59,8 @@
  *
  ************************************************************************/
 
+#include <com/sun/star/reflection/XIdlReflection.hpp>
+
 #ifndef _FSYS_HXX //autogen
 #include <tools/fsys.hxx>
 #endif
@@ -71,6 +73,7 @@
 #endif
 #include <svtools/sbx.hxx>
 #include <svtools/syslocale.hxx>
+#include <sbunoobj.hxx>
 #include "runtime.hxx"
 #pragma hdrstop
 #include "sbintern.hxx"
@@ -87,6 +90,8 @@
 // Makro MEMBER()
 #include <macfix.hxx>
 
+using namespace com::sun::star::container;
+using namespace com::sun::star::reflection;
 
 // #91147 Global reschedule flag
 static BOOL bStaticGlobalEnableReschedule = TRUE;
@@ -150,6 +157,7 @@
 	// Verzweigen
 	MEMBER(SbiRuntime::StepSTOP),  	  	// Programmende
 	MEMBER(SbiRuntime::StepINITFOR),  	// FOR-Variable initialisieren
+	MEMBER(SbiRuntime::StepINITFOREACH),// FOR Each-Variable init
 	MEMBER(SbiRuntime::StepNEXT),	  	// FOR-Variable inkrementieren
 	MEMBER(SbiRuntime::StepCASE),	  	// Anfang CASE
 	MEMBER(SbiRuntime::StepENDCASE),  	// Ende CASE
@@ -937,8 +929,76 @@
 	SbxVariableRef xBgn = PopVar();
 	p->refVar = PopVar();
 	*(p->refVar) = *xBgn;
+	p->bForEach = FALSE;
 }
 
+void SbiRuntime::PushForEach()
+{
+	SbiForStack* p = new SbiForStack;
+	p->pNext = pForStk;
+	pForStk = p;
+	p->refInc = PopVar();
+	p->refVar = PopVar();
+	p->eType = p->refVar->GetType();
+	p->bForEach = TRUE;
+
+	// Is Array?
+	SbxDimArray* pArray;
+	if( pArray = PTR_CAST(SbxDimArray,(SbxBase*)p->refInc->GetObject()) )
+	{
+		short nLower, nUpper;
+		pArray->GetDim( 1, nLower, nUpper );
+		// Use end variable to control the steps
+		p->refEnd = new SbxVariable;
+		p->refEnd->PutInteger( nLower );
+		return;
+	}
+
+	SbxBaseRef pCollObj = (SbxBase*)p->refInc->GetObject();
+	SbxBaseRef pVarObj = (SbxBase*)p->refVar->GetObject();
+	
+	// Check Object
+	if( !(pCollObj && pCollObj->ISA(SbUnoObject)) || !(pVarObj && pVarObj->ISA(SbUnoObject)) )
+	{
+		Error( SbERR_NO_OBJECT );
+		return;
+	}
+	
+	// Check interface XEnumeration is supported
+	String sInterface = String::CreateFromAscii( "com.sun.star.container.XEnumeration" );
+	if( !((SbUnoObject*)(SbxBase*)pCollObj)->supportsInterface( sInterface ) )
+	{
+		Error( SbERR_NOT_A_COLL );
+		return;
+	}
+	
+	// Create reference
+	Any aAny = ((SbUnoObject*)(SbxBase*)pCollObj)->getUnoAny();
+	Reference< XInterface > x = *(Reference< XInterface >*)aAny.getValue();
+	Reference< XIdlReflection > xCoreReflection = ((SbUnoObject*)(SbxBase*)pCollObj)->getCoreReflection();
+
+	Reference< XIdlClass > xClass = xCoreReflection->forName( sInterface );
+	if( !xClass.is() || !xCoreReflection.is() )
+	{
+		Error( SbERR_INTERNAL_ERROR );
+		return;
+	}
+	
+	OUString aClassName = xClass->getName();
+	Type aClassType( xClass->getTypeClass(), aClassName.getStr() );
+
+	if( !x->queryInterface( aClassType ).hasValue() )
+	{
+		Error( SbERR_NO_OBJECT );
+		return;
+	}
+
+	// Store Collection 
+	Any aEnum = x->queryInterface( aClassType );
+  	Reference< XEnumeration > xEnum( aEnum, UNO_QUERY );
+  	p->xColl = xEnum;
+}
+
 // Poppen des FOR-Stacks
 
 void SbiRuntime::PopFor()
Index: basic/source/runtime/step0.cxx
===================================================================
--- basic/source/runtime/step0.cxx	(revision 28)
+++ basic/source/runtime/step0.cxx	(revision 90)
@@ -770,6 +770,11 @@
 	pInst->Stop();
 }
 
+void SbiRuntime::StepINITFOREACH()
+{
+	PushForEach();
+}
+
 // FOR-Variable initialisieren
 
 void SbiRuntime::StepINITFOR()
@@ -783,8 +776,10 @@
 {
 	if( !pForStk )
 		StarBASIC::FatalError( SbERR_INTERNAL_ERROR );
-	else
-		pForStk->refVar->Compute( SbxPLUS, *pForStk->refInc );
+	else{
+		if( !pForStk->bForEach )
+			pForStk->refVar->Compute( SbxPLUS, *pForStk->refInc );
+	}
 }
 
 // Anfang CASE: TOS in CASE-Stack
Index: basic/source/runtime/step1.cxx
===================================================================
--- basic/source/runtime/step1.cxx	(revision 28)
+++ basic/source/runtime/step1.cxx	(revision 90)
@@ -67,12 +67,16 @@
 #include "sbintern.hxx"
 #include "iosys.hxx"
 #include "image.hxx"
+#include "sbunoobj.hxx"
 
+#include <com/sun/star/lang/XServiceInfo.hpp>
+
 #include "segmentc.hxx"
 #pragma SW_SEGMENT_CLASS( SBRUNTIME, SBRUNTIME_CODE )
 
+using namespace com::sun::star::lang;
+
 // Laden einer numerischen Konstanten (+ID)
-
 void SbiRuntime::StepLOADNC( USHORT nOp1 )
 {
 	SbxVariable* p = new SbxVariable( SbxDOUBLE );
@@ -256,6 +260,84 @@
 		StepJUMP( nOp1 );
 }
 
+//////////////////////////////////////////////////////////////////////////
+// Helper method to get next element in array or collection
+//////////////////////////////////////////////////////////////////////////
+BOOL nextElement( SbiForStack* pForStk )
+{
+	SbxDimArray* pArray;
+	// Array
+	if( pArray = PTR_CAST(SbxDimArray, (SbxBase*)pForStk->refInc->GetObject() ) )
+	{
+		short nLower, nUpper;
+		pArray->GetDim( 1, nLower, nUpper );			
+		nLower = (short)pForStk->refEnd->GetInteger();
+		
+		SbxDataType eType = pForStk->eType;
+		for( short i = nLower ; i <= nUpper ; ++i )
+		{
+			SbxDataType eVarType = pArray->Get( &i )->GetType();
+			// Array contains type?
+			if( eVarType ==  eType || eType == SbxVARIANT || eType == SbxEMPTY )
+			{
+				// Copy element to Variable
+				switch( eVarType )
+				{
+					case SbxBOOL:
+						pForStk->refVar->PutBool( pArray->Get( &i )->GetBool() );
+						break;								
+					case SbxDOUBLE:
+						pForStk->refVar->PutDouble( pArray->Get( &i )->GetDouble() );
+						break;
+					case SbxSINGLE:
+						pForStk->refVar->PutSingle( pArray->Get( &i )->GetSingle() );
+						break;
+					case SbxLONG:
+						pForStk->refVar->PutLong( pArray->Get( &i )->GetLong() );
+						break;
+					case SbxSTRING:	
+						pForStk->refVar->PutString( pArray->Get( &i )->GetString() );
+						break;
+					case SbxINTEGER:
+						pForStk->refVar->PutInteger( pArray->Get( &i )->GetInteger() );
+						break;
+					case SbxDATE:
+						pForStk->refVar->PutDate( pArray->Get( &i )->GetDate() );
+						break;
+					case SbxOBJECT:						
+						pForStk->refVar->PutObject( pArray->Get( &i )->GetObject() );
+						break;
+				}
+				// Next element
+				pForStk->refEnd->PutInteger( i+1 );
+				return TRUE;
+			}
+		}
+	}
+	// Collection
+	else if( pForStk->eType == SbxOBJECT )
+	{
+		Any aElem;
+		Any aVar = ((SbUnoObject*)(SbxBase*)pForStk->refVar->GetObject())->getUnoAny();
+		Reference< XServiceInfo > xVarInfo( aVar, UNO_QUERY );
+		//Search for element with the same type
+		while( pForStk->xColl->hasMoreElements() )				
+		{
+			aElem = pForStk->xColl->nextElement();
+			Reference< XServiceInfo > xElemInfo( aElem,UNO_QUERY );
+			if( xElemInfo.is() && xVarInfo.is() ){
+				if( xVarInfo->getImplementationName().equals( xElemInfo->getImplementationName() ) )
+				{
+					pForStk->refVar->PutObject( new SbUnoObject( aElem.getValueTypeName() ,aElem ) );
+					return TRUE;				
+				}
+			}
+		}
+	}
+	return FALSE;
+}// End of nextElement
+//////////////////////////////////////////////////////////////////////////
+
 // FOR-Variable testen (+Endlabel)
 
 void SbiRuntime::StepTESTFOR( USHORT nOp1 )
@@ -264,11 +343,24 @@
 		StarBASIC::FatalError( SbERR_INTERNAL_ERROR );
 	else
 	{
-		SbxOperator eOp = ( pForStk->refInc->GetDouble() < 0 ) ? SbxLT : SbxGT;
-		if( pForStk->refVar->Compare( eOp, *pForStk->refEnd ) )
+		// For Each sintaxe?
+		if( pForStk->bForEach )
 		{
-			PopFor();
-			StepJUMP( nOp1 );
+			if( !nextElement( pForStk ) )
+			{
+				PopFor();
+				StepJUMP( nOp1 );
+			}
+		}			
+		// Normal Operation
+		else 
+		{
+			SbxOperator eOp = ( pForStk->refInc->GetDouble() < 0 ) ? SbxLT : SbxGT;
+			if( pForStk->refVar->Compare( eOp, *pForStk->refEnd ) )
+			{
+				PopFor();
+				StepJUMP( nOp1 );
+			}
 		}
 	}
 }

Index: basic/source/inc/runtime.hxx
===================================================================
--- basic/source/inc/runtime.hxx	(revision 28)
+++ basic/source/inc/runtime.hxx	(revision 90)
@@ -89,10 +89,12 @@
 #ifndef _COM_SUN_STAR_LANG_XCOMPONENT_HPP_
 #include <com/sun/star/lang/XComponent.hpp>
 #endif
+#include <com/sun/star/container/XEnumeration.hpp>
 
 using namespace rtl;
 using namespace com::sun::star::uno;
 using namespace com::sun::star::lang;
+using namespace com::sun::star::container;
 
 
 // Define activates old file implementation
@@ -136,9 +138,12 @@
 
 struct SbiForStack { 		  		// for/next stack:
 	SbiForStack*   pNext;	   		// Chain
+	Reference< XEnumeration > xColl;	// Collection variable
 	SbxVariableRef refVar;	   		// loop variable
 	SbxVariableRef refEnd;	   		// end expression
 	SbxVariableRef refInc;	   		// increment expression
+	SbxDataType eType;			// Data Type of loop variable
+	BOOL bForEach;				// use For Each sintaxe
 };
 
 #define MAXRECURSION 500            // max. 500 Rekursionen
@@ -404,6 +408,7 @@
 	void ClearArgvStack();          // Argv-Stack freigeben
 
 	void PushFor();                 // For-Element push
+	void PushForEach();		 // For Each-Element push	
 	void PopFor();                  // For-Element pop
 	void ClearForStack();           // For-Stack freigeben
 
@@ -431,7 +431,7 @@
 	void StepARGV(),    StepINPUT(),	StepLINPUT(),	StepSTOP();
 	void StepGET(),		StepSET(),	 	StepPUT(),		StepPUTC();
 	void StepDIM(),     StepREDIM(),	StepREDIMP(),	StepERASE();
-	void StepINITFOR(), StepNEXT(),		StepERROR();
+       void StepINITFOR(), StepINITFOREACH(), StepNEXT(),              StepERROR();
 	void StepCASE(),	StepENDCASE(),  StepSTDERROR();
 	void StepNOERROR(), StepCHANNEL(),  StepCHANNEL0(),	StepPRINT();
 	void StepPRINTF(),	StepWRITE(),    StepRENAME(),   StepPROMPT();

Index: basic/source/inc/opcodes.hxx
===================================================================
--- basic/source/inc/opcodes.hxx	(revision 28)
+++ basic/source/inc/opcodes.hxx	(revision 90)
@@ -102,6 +102,7 @@
 	// Verzweigen
 	_STOP,              // Programmende
 	_INITFOR,           // FOR-Variable initialisieren
+	_INITFOREACH,       // FOR EACH-Variable init
 	_NEXT,              // FOR-Variable inkrementieren
 	_CASE,				// Anfang CASE
 	_ENDCASE,           // Ende CASE

Index: basic/source/classes/sbunoobj.cxx
===================================================================
--- basic/source/classes/sbunoobj.cxx	(revision 28)
+++ basic/source/classes/sbunoobj.cxx	(revision 90)
@@ -2546,6 +2546,40 @@
 	return aRetAny;
 }
 
+// Get supported interfaces
+String SbUnoObject::GetSupportedInterfaces()
+{
+	return Impl_GetSupportedInterfaces( GetClassName(), this );
+}
+
+// Get supported methods
+String SbUnoObject::DumpMethods()
+{
+	return Impl_DumpMethods( GetClassName(), this );
+}
+
+// Get supported properties
+String SbUnoObject::DumpProperties()
+{
+	return Impl_DumpProperties( GetClassName(), this );
+}
+
+// Check interfacesupport
+BOOL SbUnoObject::supportsInterface( String &sInterface )
+{
+	String sSupported = GetSupportedInterfaces();
+	String sSearch = sInterface;
+	sSearch.AppendAscii( "\n" );
+	if( sSupported.Search( sSearch )  == STRING_NOTFOUND )
+		return false;
+	return true;
+}
+
+Reference< XIdlReflection > SbUnoObject::getCoreReflection()
+{
+	return getCoreReflection_Impl();
+}
+
 // Hilfsmethode zum Anlegen einer Uno-Struct per CoreReflection
 SbUnoObject* Impl_CreateUnoStruct( const String& aClassName )
 {

Index: basic/source/comp/loops.cxx
===================================================================
--- basic/source/comp/loops.cxx	(revision 28)
+++ basic/source/comp/loops.cxx	(revision 90)
@@ -238,29 +238,46 @@
 
 void SbiParser::For()
 {
-	SbiExpression aLvalue( this, SbOPERAND );
-	aLvalue.Gen();		// Variable auf dem Stack
-	TestToken( EQ );
-	SbiExpression aStartExpr( this );
-	aStartExpr.Gen();	// Startausdruck auf dem Stack
-	TestToken( TO );
-	SbiExpression aStopExpr( this );
-	aStopExpr.Gen();	// Endausdruck auf dem Stack
-	if( Peek() == STEP )
+	SbiExpression* aLvalue;
+
+	if( Peek() == EACH )
 	{
+		// New sintaxe: For Each... in ...
 		Next();
-		SbiExpression aStepExpr( this );
-		aStepExpr.Gen();
+		aLvalue = new SbiExpression( this, SbOPERAND );
+		aLvalue->Gen();		// Varaiable to for stack
+		TestToken( _IN_ );
+		SbiExpression aCollExpr( this, SbOPERAND );
+		aCollExpr.Gen();	// Colletion var to for stack
+		TestEoln();	
+		aGen.Gen( _INITFOREACH );
 	}
 	else
 	{
-		SbiExpression aOne( this, 1, SbxINTEGER );
-		aOne.Gen();
+		aLvalue = new SbiExpression( this, SbOPERAND );
+		aLvalue->Gen();		// Variable auf dem Stack
+		TestToken( EQ );
+		SbiExpression aStartExpr( this );
+		aStartExpr.Gen();	// Startausdruck auf dem Stack
+		TestToken( TO );
+		SbiExpression aStopExpr( this );
+		aStopExpr.Gen();	// Endausdruck auf dem Stack
+		if( Peek() == STEP )
+		{
+			Next();
+			SbiExpression aStepExpr( this );
+			aStepExpr.Gen();
+		}
+		else
+		{
+			SbiExpression aOne( this, 1, SbxINTEGER );
+			aOne.Gen();
+		}
+		TestEoln();
+		// Der Stack hat jetzt 4 Elemente: Variable, Start, Ende, Inkrement
+		// Startwert binden
+		aGen.Gen( _INITFOR );
 	}
-	TestEoln();
-	// Der Stack hat jetzt 4 Elemente: Variable, Start, Ende, Inkrement
-	// Startwert binden
-	aGen.Gen( _INITFOR );
 	USHORT nLoop = aGen.GetPC();
 	// Test durchfuehren, evtl. Stack freigeben
 	USHORT nEndTarget = aGen.Gen( _TESTFOR, 0 );
@@ -271,9 +271,9 @@
 	// Kommen Variable nach NEXT?
 	if( Peek() == SYMBOL )
 	{
 		SbiExpression aVar( this, SbOPERAND );
-		if( aVar.GetRealVar() != aLvalue.GetRealVar() )
+		if( aVar.GetRealVar() != aLvalue->GetRealVar() )
 			Error( SbERR_EXPECTED, aVar.GetRealVar()->GetName() );
 	}
 	aGen.BackChain( nEndTarget );
 	CloseBlock();


Index: basic/source/inc/sbunoobj.hxx
===================================================================
RCS file: /cvs/script/basic/source/inc/sbunoobj.hxx,v
retrieving revision 1.6.44.1
diff -u -r1.6.44.1 sbunoobj.hxx
--- basic/source/inc/sbunoobj.hxx	20 Jan 2004 10:01:34 -0000	1.6.44.1
+++ basic/source/inc/sbunoobj.hxx	25 Aug 2004 15:51:11 -0000
@@ -95,6 +95,7 @@
 #ifndef _COM_SUN_STAR_REFLECTION_XIDLCLASS_HPP_
 #include <com/sun/star/reflection/XIdlClass.hpp>
 #endif
+#include <com/sun/star/reflection/XIdlReflection.hpp>
 #ifndef _RTL_USTRING_
 #include <rtl/ustring>
 #endif
@@ -140,6 +141,11 @@
 	Reference< XIntrospectionAccess > getIntrospectionAccess( void )	{ return mxUnoAccess; }
 	Reference< XInvocation > getInvocation( void )			{ return mxInvocation; }
 
+	String GetSupportedInterfaces();
+	String DumpMethods();
+	String DumpProperties();
+	BOOL supportsInterface( String &sInterface );
+	Reference< XIdlReflection > getCoreReflection();		
 	void SFX_NOTIFY( SfxBroadcaster&, const TypeId&, const SfxHint& rHint, const TypeId& );
 };
 SV_DECL_IMPL_REF(SbUnoObject);
