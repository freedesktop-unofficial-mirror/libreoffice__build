Index: bridges/inc/bridges/remote/marshal.hxx
===================================================================
RCS file: /cvs/udk/bridges/inc/bridges/remote/marshal.hxx,v
retrieving revision 1.2
retrieving revision 1.2.18.1
diff -u -p -r1.2 -r1.2.18.1
--- bridges/inc/bridges/remote/marshal.hxx	7 Sep 2005 22:12:40 -0000	1.2
+++ bridges/inc/bridges/remote/marshal.hxx	25 Nov 2005 09:11:24 -0000	1.2.18.1
@@ -33,6 +33,9 @@
  *
  ************************************************************************/
 #include <com/sun/star/uno/Sequence.hxx>
+#ifndef INCLUDED_CPPU_UNOTYPE_HXX
+#include "cppu/unotype.hxx"
+#endif
 
 typedef struct _uno_Environment uno_Environment;	
 struct remote_Interface;
@@ -84,7 +87,7 @@ private:
 template < class C >
 inline void operator <<= (Marshal & r,  C& value)
 {
-	r.pack( &value, getCppuType( &value ) );
+	r.pack( &value, cppu::getTypeFavourUnsigned( &value ) );
 }
 
 }
Index: bridges/inc/bridges/remote/unmarshal.hxx
===================================================================
RCS file: /cvs/udk/bridges/inc/bridges/remote/unmarshal.hxx,v
retrieving revision 1.3
retrieving revision 1.3.18.1
diff -u -p -r1.3 -r1.3.18.1
--- bridges/inc/bridges/remote/unmarshal.hxx	7 Sep 2005 22:13:57 -0000	1.3
+++ bridges/inc/bridges/remote/unmarshal.hxx	25 Nov 2005 09:11:25 -0000	1.3.18.1
@@ -38,6 +38,10 @@
 #include <com/sun/star/uno/Sequence.hxx>
 #include <uno/data.h>
 
+#ifndef INCLUDED_CPPU_UNOTYPE_HXX
+#include "cppu/unotype.hxx"
+#endif
+
 #include <bridges/remote/remote.h>
 #include <bridges/remote/context.h>
 #include <bridges/remote/helper.hxx>
@@ -84,7 +88,8 @@ inline sal_Bool Unmarshal::checkAddition
 template < class C >
 inline sal_Bool operator >>= (Unmarshal & r, C& value)
 {
-	return r.unpackAndDestruct( &value , getCppuType( &value ) );
+	return r.unpackAndDestruct(
+        &value , cppu::getTypeFavourUnsigned( &value ) );
 }
 
 }
Index: codemaker/source/cppumaker/cpputype.cxx
===================================================================
RCS file: /cvs/udk/codemaker/source/cppumaker/cpputype.cxx,v
retrieving revision 1.35
retrieving revision 1.35.10.1
diff -u -p -r1.35 -r1.35.10.1
--- codemaker/source/cppumaker/cpputype.cxx	8 Sep 2005 02:12:25 -0000	1.35
+++ codemaker/source/cppumaker/cpputype.cxx	24 Nov 2005 08:21:08 -0000	1.35.10.1
@@ -289,7 +289,6 @@ CppuType::CppuType(typereg::Reader& type
 	: m_inheritedMemberCount(0)
 	, m_cppuTypeLeak(sal_False)
 	, m_cppuTypeDynamic(sal_True)
-	, m_cppuTypeStatic(sal_False)
 	, m_indentLength(0)
 	, m_typeName(typeName)
     , m_name(typeName.copy(typeName.lastIndexOf('/') + 1))
@@ -310,6 +309,7 @@ void CppuType::addGetCppuTypeIncludes(co
         || m_typeName.equals("com/sun/star/uno/Exception"))
     {
         includes.addType();
+        includes.addCppuUnotypeHxx();
         includes.addSalTypesH();
         includes.addTypelibTypeclassH();
         includes.addTypelibTypedescriptionH();
@@ -332,6 +332,7 @@ void CppuType::addLightGetCppuTypeInclud
 {
     //TODO: Determine what is really needed, instead of relying on
     // addDefaultHxxIncludes
+    includes.addCppuUnotypeHxx();
 }
 
 void CppuType::addNormalGetCppuTypeIncludes(
@@ -339,6 +340,7 @@ void CppuType::addNormalGetCppuTypeInclu
 {
     //TODO: Determine what is really needed, instead of relying on
     // addDefaultHxxIncludes
+    includes.addCppuUnotypeHxx();
 }
 
 void CppuType::addComprehensiveGetCppuTypeIncludes(
@@ -346,6 +348,63 @@ void CppuType::addComprehensiveGetCppuTy
 {
     //TODO: Determine what is really needed, instead of relying on
     // addDefaultHxxIncludes
+    includes.addCppuUnotypeHxx();
+}
+
+bool CppuType::isPolymorphic() const { return false; }
+
+void CppuType::dumpTemplateHead(FileStream & out) const {}
+
+void CppuType::dumpTemplateParameters(FileStream &) const {}
+
+void CppuType::dumpGetCppuTypePreamble(FileStream & out) {
+    if (isPolymorphic()) {
+        out << "namespace cppu {\n\n";
+        dumpTemplateHead(out);
+        out << "class UnoType< ";
+        dumpType(out, m_typeName);
+        dumpTemplateParameters(out);
+        out << " > {\npublic:\n";
+        inc();
+        out << indent()
+            << "static inline ::com::sun::star::uno::Type const & get() {\n";
+    } else {
+        if (codemaker::cppumaker::dumpNamespaceOpen(out, m_typeName, false)) {
+            out << "\n\n";
+        }
+        out << "inline ::com::sun::star::uno::Type const & cppu_getUnoType(";
+        dumpType(out, m_typeName, false, false, true);
+        out << " const *) {\n";
+    }
+    inc();
+}
+
+void CppuType::dumpGetCppuTypePostamble(FileStream & out) {
+    dec();
+    if (isPolymorphic()) {
+        out << indent() << "}\n\nprivate:\n"
+            << indent() << "UnoType(UnoType &); // not defined\n"
+            << indent() << "~UnoType(); // not defined\n"
+            << indent()
+            << "void operator =(UnoType); // not defined\n};\n\n}\n\n";
+    } else {
+        out << "};\n\n";
+        if (codemaker::cppumaker::dumpNamespaceClose(out, m_typeName, false)) {
+            out << "\n\n";
+        }
+    }
+    dumpTemplateHead(out);
+    out << "inline ::com::sun::star::uno::Type const & SAL_CALL getCppuType(";
+    dumpType(out, m_typeName);
+    dumpTemplateParameters(out);
+    out << " const *) SAL_THROW(()) {\n";
+    inc();
+    out << indent() << "return ::cppu::UnoType< ";
+    dumpType(out, m_typeName);
+    dumpTemplateParameters(out);
+    out << " >::get();\n";
+    dec();
+    out << indent() << "}\n";
 }
 
 sal_Bool CppuType::dump(CppuOptions* pOptions)
@@ -360,13 +419,8 @@ sal_Bool CppuType::dump(CppuOptions* pOp
 
 	if (pOptions->isValid("-L"))
 		m_cppuTypeLeak = sal_True;
-	if (pOptions->isValid("-C"))
+	if (pOptions->isValid("-C") || pOptions->isValid("-CS"))
 		m_cppuTypeDynamic = sal_False;
-	if (pOptions->isValid("-CS"))
-	{
-		m_cppuTypeDynamic = sal_False;
-		m_cppuTypeStatic = sal_True;
-	}
 
 	OString outPath;
 	if (pOptions->isValid("-O"))
@@ -575,9 +629,8 @@ void CppuType::dumpGetCppuType(FileStrea
         out << " *) SAL_THROW(()) {\n";
         inc();
         out << indent()
-            << ("return *reinterpret_cast< const ::com::sun::star::uno::Type *"
-                " >(::typelib_static_type_getByTypeClass("
-                "typelib_TypeClass_INTERFACE));\n");
+            << ("return ::cppu::UnoType< ::com::sun::star::uno::XInterface"
+                " >::get();\n");
         dec();
         out << indent() << "}\n";
     } else if (m_typeName.equals("com/sun/star/uno/Exception")) {
@@ -588,9 +641,8 @@ void CppuType::dumpGetCppuType(FileStrea
         out << " *) SAL_THROW(()) {\n";
         inc();
         out << indent()
-            << ("return *reinterpret_cast< const ::com::sun::star::uno::Type *"
-                " >(::typelib_static_type_getByTypeClass("
-                "typelib_TypeClass_EXCEPTION));\n");
+            << ("return ::cppu::UnoType< ::com::sun::star::uno::Exception"
+                " >::get();\n");
         dec();
         out << indent() << "}\n";
     } else if (m_cppuTypeLeak) {
@@ -604,18 +656,7 @@ void CppuType::dumpGetCppuType(FileStrea
 
 void CppuType::dumpLightGetCppuType(FileStream& o)
 {
-	if (m_reader.getTypeClass() == RT_TYPE_TYPEDEF)
-	{
-		o << "inline const ::com::sun::star::uno::Type& SAL_CALL get_"
-          << m_typeName.replace('/', '_') << "_Type( ) SAL_THROW( () )\n{\n";
-	} else
-	{
-		o << "inline const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
-		dumpType(o, m_typeName, sal_True, sal_False);
-		o << "* ) SAL_THROW( () )\n{\n";
-	}
-	inc();
-
+    dumpGetCppuTypePreamble(o);
     o << indent()
       << "static typelib_TypeDescriptionReference * the_type = 0;\n";
 
@@ -628,18 +669,12 @@ void CppuType::dumpLightGetCppuType(File
 	o << indent()
       << ("return * reinterpret_cast< ::com::sun::star::uno::Type * >("
           " &the_type );\n");
-	dec();
-	o << indent() << "}\n";
-
-	return;
+    dumpGetCppuTypePostamble(o);
 }
 
 void CppuType::dumpNormalGetCppuType(FileStream& o)
 {
-	o << "inline const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
-	dumpType(o, m_typeName, sal_True, sal_False);
-	o << "* ) SAL_THROW( () )\n{\n";
-	inc();
+    dumpGetCppuTypePreamble(o);
 
     o << indent()
       << "static typelib_TypeDescriptionReference * the_type = 0;\n";
@@ -742,22 +777,12 @@ void CppuType::dumpNormalGetCppuType(Fil
       << ("return * reinterpret_cast< const ::com::sun::star::uno::Type * >("
           " &the_type );\n");
 
-    dec();
-	o << indent() << "}\n";
-
-	return;
+    dumpGetCppuTypePostamble(o);
 }
 
 void CppuType::dumpComprehensiveGetCppuType(FileStream& o)
 {
-	if (m_cppuTypeStatic)
-		o << "static";
-	else
-		o << "inline";
-	o << " const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
-	dumpType(o, m_typeName, sal_True, sal_False);
-	o << "* ) SAL_THROW( () )\n{\n";
-	inc();
+    dumpGetCppuTypePreamble(o);
 
     o << indent() << "static ::com::sun::star::uno::Type * the_pType = 0;\n";
 
@@ -861,8 +886,7 @@ void CppuType::dumpComprehensiveGetCppuT
 	dec();
 	o << indent() << "}\n\n";
 	o << indent() << "return *the_pType;\n";
-	dec();
-	o << "}\n";
+    dumpGetCppuTypePostamble(o);
 }
 
 void CppuType::dumpCppuGetTypeMemberDecl(FileStream& o, CppuTypeDecl eDeclFlag)
@@ -1443,12 +1467,7 @@ sal_Bool InterfaceType::dumpHFile(
         o << "\n";
     }
 
-    o << "\n";
-	if (m_cppuTypeStatic)
-		o << "static";
-	else
-		o << "inline";
-	o << " const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
+	o << "\ninline const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
 	dumpType(o, m_typeName, sal_True, sal_False);
 	o << "* ) SAL_THROW( () );\n\n";
 
@@ -1635,10 +1654,7 @@ void InterfaceType::dumpMethods(FileStre
 
 void InterfaceType::dumpNormalGetCppuType(FileStream& o)
 {
-	o << "inline const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
-	dumpType(o, m_typeName, sal_True, sal_False);
-	o << "* ) SAL_THROW( () )\n{\n";
-	inc();
+    dumpGetCppuTypePreamble(o);
 
     o << indent()
       << "static typelib_TypeDescriptionReference * the_type = 0;\n";
@@ -1684,22 +1700,12 @@ void InterfaceType::dumpNormalGetCppuTyp
       << ("return * reinterpret_cast< ::com::sun::star::uno::Type * >("
           " &the_type );\n");
 
-    dec();
-    o << indent() << "}\n";
-
-	return;
+    dumpGetCppuTypePostamble(o);
 }
 
 void InterfaceType::dumpComprehensiveGetCppuType(FileStream& o)
 {
-	if (m_cppuTypeStatic)
-		o << "static";
-	else
-		o << "inline";
-	o << " const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
-	dumpType(o, m_typeName, sal_True, sal_False);
-	o << "* ) SAL_THROW( () )\n{\n";
-	inc();
+    dumpGetCppuTypePreamble(o);
 
     o << indent() << "static ::com::sun::star::uno::Type * the_pType = 0;\n";
 
@@ -1807,8 +1813,7 @@ void InterfaceType::dumpComprehensiveGet
 	o << indent() << "}\n\n"
 	  << indent() << "return *the_pType;\n";
 
-	dec();
-	o << "}\n";
+    dumpGetCppuTypePostamble(o);
 }
 
 void InterfaceType::dumpCppuAttributeRefs(FileStream& o, sal_uInt32& index)
@@ -1964,6 +1969,7 @@ void InterfaceType::addComprehensiveGetC
 {
     // The comprehensive getCppuType method always includes a line
     // "getCppuType( (const ::com::sun::star::uno::RuntimeException*)0 );":
+    includes.addCppuUnotypeHxx();
     includes.add("com/sun/star/uno/RuntimeException");
 }
 
@@ -2540,11 +2546,7 @@ sal_Bool StructureType::dumpHFile(
 	  << "class Type;\n} } } }\n\n";
 
     dumpTemplateHead(o);
-	if (m_cppuTypeStatic)
-		o << "static";
-	else
-		o << "inline";
-	o << " const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
+	o << "inline const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
 	dumpType(o, m_typeName, sal_True, sal_False); 
     dumpTemplateParameters(o);
 	o << "* );\n\n";
@@ -3123,6 +3125,7 @@ void StructureType::addLightGetCppuTypeI
     codemaker::cppumaker::Includes & includes) const
 {
     includes.addType();
+    includes.addCppuUnotypeHxx();
     includes.addSalTypesH();
     includes.addTypelibTypeclassH();
     includes.addTypelibTypedescriptionH();
@@ -3137,6 +3140,7 @@ void StructureType::addNormalGetCppuType
     codemaker::cppumaker::Includes & includes) const
 {
     includes.addType();
+    includes.addCppuUnotypeHxx();
     includes.addSalTypesH();
     includes.addTypelibTypeclassH();
     includes.addTypelibTypedescriptionH();
@@ -3151,6 +3155,7 @@ void StructureType::addComprehensiveGetC
     codemaker::cppumaker::Includes & includes) const
 {
     includes.addType();
+    includes.addCppuUnotypeHxx();
     includes.addOslDoublecheckedlockingH();
     includes.addOslMutexHxx();
     includes.addRtlUstringH();
@@ -3207,22 +3212,6 @@ void StructureType::dumpTemplateParamete
     }
 }
 
-void StructureType::dumpGetCppuTypePreamble(FileStream & out) {
-    out << indent();
-    dumpTemplateHead(out);
-    out << (m_cppuTypeStatic ? "static" : "inline")
-        << " ::com::sun::star::uno::Type const & SAL_CALL getCppuType(";
-    dumpType(out, m_typeName);
-    dumpTemplateParameters(out);
-    out << " const *) {\n";
-    inc();
-}
-
-void StructureType::dumpGetCppuTypePostamble(FileStream & out) {
-    dec();
-    out << indent() << "}\n";
-}
-
 //*************************************************************************
 // ExceptionType
 //*************************************************************************
@@ -3262,11 +3251,7 @@ sal_Bool ExceptionType::dumpHFile(
 	o << "\nnamespace com { namespace sun { namespace star { namespace uno {\n"
 	  << "class Type;\n} } } }\n\n";
 
-	if (m_cppuTypeStatic)
-		o << "static";
-	else
-		o << "inline";
-	o << " const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
+	o << "inline const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
 	dumpType(o, m_typeName, sal_True, sal_False); 
 	o << "* ) SAL_THROW( () );\n\n";
 
@@ -3648,11 +3633,7 @@ sal_Bool EnumType::dumpHFile(
 	o << "\nnamespace com { namespace sun { namespace star { namespace uno {\n"
 	  << "class Type;\n} } } }\n\n";
 
-	if (m_cppuTypeStatic)
-		o << "static";
-	else
-		o << "inline";
-	o << " const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
+	o << "inline const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
 	dumpType(o, m_typeName, sal_True, sal_False); 
 	o << "* ) SAL_THROW( () );\n\n";
 
@@ -3718,10 +3699,7 @@ sal_Bool EnumType::dumpHxxFile(
 
 void EnumType::dumpNormalGetCppuType(FileStream& o)
 {
-	o << "inline const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
-	dumpType(o, m_typeName, sal_True, sal_False); 
-	o << "* ) SAL_THROW( () )\n{\n";
-	inc();
+    dumpGetCppuTypePreamble(o);
 
     o << indent()
       << "static typelib_TypeDescriptionReference * the_type = 0;\n";
@@ -3741,22 +3719,12 @@ void EnumType::dumpNormalGetCppuType(Fil
 	o << indent()
       << ("return * reinterpret_cast< ::com::sun::star::uno::Type * >("
           " &the_type );\n");
-	dec();
-	o << indent() << "}\n";
-	
-	return;
+    dumpGetCppuTypePostamble(o);
 }
 
 void EnumType::dumpComprehensiveGetCppuType(FileStream& o)
 {
-	if (m_cppuTypeStatic)
-		o << "static";
-	else
-		o << "inline";
-	o << " const ::com::sun::star::uno::Type& SAL_CALL getCppuType( ";
-	dumpType(o, m_typeName, sal_True, sal_False); 
-	o << "* ) SAL_THROW( () )\n{\n";
-	inc();
+    dumpGetCppuTypePreamble(o);
 
     o << indent() << "static ::com::sun::star::uno::Type * the_pType = 0;\n";
 
@@ -3826,8 +3794,7 @@ void EnumType::dumpComprehensiveGetCppuT
 	o << indent() << "}\n\n"
 	  << indent() << "return *the_pType;\n";
 
-	dec();
-	o << "}\n";
+    dumpGetCppuTypePostamble(o);
 }
 
 //*************************************************************************
Index: codemaker/source/cppumaker/cpputype.hxx
===================================================================
RCS file: /cvs/udk/codemaker/source/cppumaker/cpputype.hxx,v
retrieving revision 1.8
retrieving revision 1.8.10.1
diff -u -p -r1.8 -r1.8.10.1
--- codemaker/source/cppumaker/cpputype.hxx	8 Sep 2005 02:12:40 -0000	1.8
+++ codemaker/source/cppumaker/cpputype.hxx	24 Nov 2005 08:21:09 -0000	1.8.10.1
@@ -130,6 +130,16 @@ protected:
     virtual void addComprehensiveGetCppuTypeIncludes(
         codemaker::cppumaker::Includes & includes) const;
 
+    virtual bool isPolymorphic() const;
+
+    virtual void dumpTemplateHead(FileStream & out) const;
+
+    virtual void dumpTemplateParameters(FileStream & out) const;
+
+    void dumpGetCppuTypePreamble(FileStream & out);
+
+    void dumpGetCppuTypePostamble(FileStream & out);
+
     void addDefaultHIncludes(codemaker::cppumaker::Includes & includes) const;
     void addDefaultHxxIncludes(codemaker::cppumaker::Includes & includes) const;
 
@@ -141,7 +151,6 @@ protected:
 
 	sal_Bool			m_cppuTypeLeak;
 	sal_Bool			m_cppuTypeDynamic;
-	sal_Bool			m_cppuTypeStatic;
 	sal_uInt32			m_indentLength;
 	::rtl::OString		m_typeName;
 	::rtl::OString		m_name;
@@ -275,16 +284,11 @@ protected:
     virtual void addComprehensiveGetCppuTypeIncludes(
         codemaker::cppumaker::Includes & includes) const;
 
-private:
-    bool isPolymorphic() const;
-
-    void dumpTemplateHead(FileStream & out) const;
+    virtual bool isPolymorphic() const;
 
-    void dumpTemplateParameters(FileStream & out) const;
+    virtual void dumpTemplateHead(FileStream & out) const;
 
-    void dumpGetCppuTypePreamble(FileStream & out);
-
-    void dumpGetCppuTypePostamble(FileStream & out);
+    virtual void dumpTemplateParameters(FileStream & out) const;
 };
 
 class ExceptionType : public CppuType
Index: codemaker/source/cppumaker/includes.cxx
===================================================================
RCS file: /cvs/udk/codemaker/source/cppumaker/includes.cxx,v
retrieving revision 1.3
retrieving revision 1.3.12.1
diff -u -p -r1.3 -r1.3.12.1
--- codemaker/source/cppumaker/includes.cxx	8 Sep 2005 02:13:24 -0000	1.3
+++ codemaker/source/cppumaker/includes.cxx	24 Nov 2005 08:21:09 -0000	1.3.12.1
@@ -58,10 +58,11 @@ Includes::Includes(
     m_includeAny(dependencies.hasAnyDependency()), m_includeReference(false),
     m_includeSequence(dependencies.hasSequenceDependency()),
     m_includeType(dependencies.hasTypeDependency()),
-    m_includeCppuMacrosHxx(false), m_includeOslDoublecheckedlockingH(false),
-    m_includeOslMutexHxx(false), m_includeRtlStrbufHxx(false),
-    m_includeRtlStringH(false), m_includeRtlTextencH(false),
-    m_includeRtlUstrbufHxx(false), m_includeRtlUstringH(false),
+    m_includeCppuMacrosHxx(false), m_includeCppuUnotypeHxx(false),
+    m_includeOslDoublecheckedlockingH(false), m_includeOslMutexHxx(false),
+    m_includeRtlStrbufHxx(false), m_includeRtlStringH(false),
+    m_includeRtlTextencH(false), m_includeRtlUstrbufHxx(false),
+    m_includeRtlUstringH(false),
     m_includeRtlUstringHxx(dependencies.hasStringDependency()),
     m_includeSalTypesH(
         dependencies.hasBooleanDependency() || dependencies.hasByteDependency()
@@ -227,6 +228,11 @@ void Includes::dump(FileStream & out, rt
         dumpEmptyLineBeforeFirst(out, &first);
         out << ("#ifndef _CPPU_MACROS_HXX_\n"
                 "#include \"cppu/macros.hxx\"\n#endif\n");
+    }
+    if (m_includeCppuUnotypeHxx) {
+        dumpEmptyLineBeforeFirst(out, &first);
+        out << ("#ifndef INCLUDED_CPPU_UNOTYPE_HXX\n"
+                "#include \"cppu/unotype.hxx\"\n#endif\n");
     }
     if (m_includeOslDoublecheckedlockingH) {
         dumpEmptyLineBeforeFirst(out, &first);
Index: codemaker/source/cppumaker/includes.hxx
===================================================================
RCS file: /cvs/udk/codemaker/source/cppumaker/includes.hxx,v
retrieving revision 1.3
retrieving revision 1.3.12.1
diff -u -p -r1.3 -r1.3.12.1
--- codemaker/source/cppumaker/includes.hxx	8 Sep 2005 02:13:38 -0000	1.3
+++ codemaker/source/cppumaker/includes.hxx	24 Nov 2005 08:21:09 -0000	1.3.12.1
@@ -65,6 +65,8 @@ public:
 
     void addCppuMacrosHxx() { m_includeCppuMacrosHxx = true; }
 
+    void addCppuUnotypeHxx() { m_includeCppuUnotypeHxx = true; }
+
     void addOslDoublecheckedlockingH()
     { m_includeOslDoublecheckedlockingH = true; }
 
@@ -109,6 +111,7 @@ private:
     bool m_includeSequence;
     bool m_includeType;
     bool m_includeCppuMacrosHxx;
+    bool m_includeCppuUnotypeHxx;
     bool m_includeOslDoublecheckedlockingH;
     bool m_includeOslMutexHxx;
     bool m_includeRtlStrbufHxx;
Index: comphelper/inc/comphelper/property.hxx
===================================================================
RCS file: /cvs/util/comphelper/inc/comphelper/property.hxx,v
retrieving revision 1.7
retrieving revision 1.7.32.1
diff -u -p -r1.7 -r1.7.32.1
--- comphelper/inc/comphelper/property.hxx	8 Sep 2005 02:35:26 -0000	1.7
+++ comphelper/inc/comphelper/property.hxx	28 Nov 2005 13:00:58 -0000	1.7.32.1
@@ -52,6 +52,9 @@
 #ifndef INCLUDED_COMPHELPERDLLAPI_H
 #include "comphelper/comphelperdllapi.h"
 #endif
+#ifndef INCLUDED_CPPU_UNOTYPE_HXX
+#include "cppu/unotype.hxx"
+#endif
 
 //=========================================================================
 //= property helper classes
@@ -156,7 +159,8 @@ sal_Bool tryPropertyValue(staruno::Any& 
 template <class ENUMTYPE>
 sal_Bool tryPropertyValueEnum(staruno::Any& /*out*/_rConvertedValue, staruno::Any& /*out*/_rOldValue, const staruno::Any& _rValueToSet, const ENUMTYPE& _rCurrentValue)
 {
-	if (getCppuType(&_rCurrentValue).getTypeClass() != staruno::TypeClass_ENUM)
+    if (cppu::getTypeFavourUnsigned(&_rCurrentValue).getTypeClass()
+        != staruno::TypeClass_ENUM)
 		return tryPropertyValue(_rConvertedValue, _rOldValue, _rValueToSet, _rCurrentValue);
 
 	sal_Bool bModified(sal_False);
Index: comphelper/inc/comphelper/types.hxx
===================================================================
RCS file: /cvs/util/comphelper/inc/comphelper/types.hxx,v
retrieving revision 1.8
retrieving revision 1.8.32.1
diff -u -p -r1.8 -r1.8.32.1
--- comphelper/inc/comphelper/types.hxx	8 Sep 2005 02:40:50 -0000	1.8
+++ comphelper/inc/comphelper/types.hxx	25 Nov 2005 09:10:15 -0000	1.8.32.1
@@ -61,7 +61,9 @@
 #ifndef INCLUDED_COMPHELPERDLLAPI_H
 #include "comphelper/comphelperdllapi.h"
 #endif
-
+#ifndef INCLUDED_CPPU_UNOTYPE_HXX
+#include "cppu/unotype.hxx"
+#endif
 
 namespace com { namespace sun { namespace star { namespace awt {
 	struct FontDescriptor;
@@ -110,7 +112,7 @@ namespace comphelper
 	template <class TYPE>
 	sal_Bool isA(const staruno::Type& _rType, TYPE* pDummy)
 	{
-		return  _rType.equals(getCppuType(pDummy));
+		return  _rType.equals(cppu::getTypeFavourUnsigned(pDummy));
 	}
 
 	//-------------------------------------------------------------------------
@@ -120,7 +122,8 @@ namespace comphelper
 	template <class TYPE>
 	sal_Bool isA(const staruno::Any& _rVal, TYPE* pDummy)
 	{
-		return  _rVal.getValueType().equals(getCppuType(pDummy));
+		return  _rVal.getValueType().equals(
+            cppu::getTypeFavourUnsigned(pDummy));
 	}
 
 	//-------------------------------------------------------------------------
@@ -129,7 +132,9 @@ namespace comphelper
 	template <class TYPE>
 	sal_Bool isAReference(const staruno::Type& _rType, TYPE* pDummy)
 	{
-		return  _rType.equals(getCppuType(reinterpret_cast<staruno::Reference<TYPE>*>(NULL)));
+		return  _rType.equals(
+            cppu::getTypeFavourUnsigned(
+                static_cast<staruno::Reference<TYPE>*>(NULL)));
 	}
 
 	//-------------------------------------------------------------------------
@@ -138,7 +143,9 @@ namespace comphelper
 	template <class TYPE>
 	sal_Bool isAReference(const staruno::Any& _rVal, TYPE* pDummy)
 	{
-		return  _rVal.getValueType().equals(getCppuType(reinterpret_cast<staruno::Reference<TYPE>*>(NULL)));
+		return  _rVal.getValueType().equals(
+            cppu::getTypeFavourUnsigned(
+                static_cast<staruno::Reference<TYPE>*>(NULL)));
 	}
 
 	//-------------------------------------------------------------------------
Index: cppu/inc/com/sun/star/uno/Any.h
===================================================================
RCS file: /cvs/udk/cppu/inc/com/sun/star/uno/Any.h,v
retrieving revision 1.11
retrieving revision 1.11.18.1
diff -u -p -r1.11 -r1.11.18.1
--- cppu/inc/com/sun/star/uno/Any.h	8 Sep 2005 08:32:57 -0000	1.11
+++ cppu/inc/com/sun/star/uno/Any.h	24 Nov 2005 08:18:07 -0000	1.11.18.1
@@ -44,6 +44,9 @@
 #ifndef _COM_SUN_STAR_UNO_TYPE_H_
 #include <com/sun/star/uno/Type.h>
 #endif
+#ifndef INCLUDED_CPPU_UNOTYPE_HXX
+#include "cppu/unotype.hxx"
+#endif
 
 #ifndef _RTL_ALLOC_H_
 #include <rtl/alloc.h>
@@ -385,13 +388,15 @@ inline sal_Bool SAL_CALL operator == ( c
 
 /** Gets the meta type of IDL type any.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type any
 */
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const ::com::sun::star::uno::Any * ) SAL_THROW( () )
 {
-	return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-		::typelib_static_type_getByTypeClass( typelib_TypeClass_ANY ) );
+    return ::cppu::UnoType< ::com::sun::star::uno::Any >::get();
 }
 
 #endif
Index: cppu/inc/com/sun/star/uno/Any.hxx
===================================================================
RCS file: /cvs/udk/cppu/inc/com/sun/star/uno/Any.hxx,v
retrieving revision 1.16
retrieving revision 1.16.18.1
diff -u -p -r1.16 -r1.16.18.1
--- cppu/inc/com/sun/star/uno/Any.hxx	8 Sep 2005 08:33:21 -0000	1.16
+++ cppu/inc/com/sun/star/uno/Any.hxx	24 Nov 2005 08:18:08 -0000	1.16.18.1
@@ -50,7 +50,9 @@
 #ifndef _COM_SUN_STAR_UNO_GENFUNC_HXX_
 #include <com/sun/star/uno/genfunc.hxx>
 #endif
-
+#ifndef INCLUDED_CPPU_UNOTYPE_HXX
+#include "cppu/unotype.hxx"
+#endif
 
 namespace com
 {     
@@ -72,7 +74,8 @@ template <typename T>
 inline Any::Any( T const & value )
 {
 	::uno_type_any_construct(
-		this, const_cast<T *>(&value), getCppuType(&value).getTypeLibType(),
+		this, const_cast<T *>(&value),
+        ::cppu::getTypeFavourUnsigned(&value).getTypeLibType(),
         (uno_AcquireFunc) cpp_acquire );
 }
 //______________________________________________________________________________
@@ -169,7 +172,7 @@ inline sal_Bool Any::isExtractableTo( co
 template <typename T>
 inline bool Any::has() const
 {
-    Type const & rType = getCppuType( static_cast<T const *>(0) );
+    Type const & rType = ::cppu::getTypeFavourUnsigned(static_cast< T * >(0));
     return ::uno_type_isAssignableFromData(
         rType.getTypeLibType(), pData, pType,
         (uno_QueryInterfaceFunc) cpp_queryInterface,
@@ -200,7 +203,7 @@ inline sal_Bool Any::operator != ( const
 template< class C >
 inline Any SAL_CALL makeAny( const C & value ) SAL_THROW( () )
 { 
-	return Any( &value, getCppuType( &value ) );
+	return Any( &value, ::cppu::getTypeFavourUnsigned(&value) );
 }
 
 // additionally specialized for C++ bool
@@ -216,7 +219,7 @@ inline Any SAL_CALL makeAny( bool const 
 template< class C >
 inline void SAL_CALL operator <<= ( Any & rAny, const C & value ) SAL_THROW( () )
 { 
-	const Type & rType = getCppuType( &value );
+	const Type & rType = ::cppu::getTypeFavourUnsigned(&value);
 	::uno_type_any_assign(
 		&rAny, const_cast< C * >( &value ), rType.getTypeLibType(),
         (uno_AcquireFunc)cpp_acquire, (uno_ReleaseFunc)cpp_release );
@@ -237,7 +240,7 @@ inline void SAL_CALL operator <<= ( Any 
 template< class C >
 inline sal_Bool SAL_CALL operator >>= ( const Any & rAny, C & value ) SAL_THROW( () )
 {
-	const Type & rType = getCppuType( &value );
+	const Type & rType = ::cppu::getTypeFavourUnsigned(&value);
 	return ::uno_type_assignData(
 		&value, rType.getTypeLibType(),
 		rAny.pData, rAny.pType,
@@ -558,7 +561,7 @@ inline sal_Bool SAL_CALL operator == ( c
 template< class C >
 inline sal_Bool SAL_CALL operator == ( const Any & rAny, const C & value ) SAL_THROW( () )
 {
-	const Type & rType = getCppuType( &value );
+	const Type & rType = ::cppu::getTypeFavourUnsigned(&value);
 	return ::uno_type_equalData(
 		rAny.pData, rAny.pType,
 		const_cast< C * >( &value ), rType.getTypeLibType(),
@@ -584,9 +587,11 @@ T Any::get() const
     T value;
     if (! (*this >>= value)) {
         throw RuntimeException(
-            ::rtl::OUString( cppu_Any_extraction_failure_msg(
-                                 this, getCppuType(&value).getTypeLibType() ),
-                             SAL_NO_ACQUIRE ),
+            ::rtl::OUString(
+                cppu_Any_extraction_failure_msg(
+                    this,
+                    ::cppu::getTypeFavourUnsigned(&value).getTypeLibType() ),
+                SAL_NO_ACQUIRE ),
             Reference<XInterface>() );
     }
     return value;
Index: cppu/inc/com/sun/star/uno/Sequence.h
===================================================================
RCS file: /cvs/udk/cppu/inc/com/sun/star/uno/Sequence.h,v
retrieving revision 1.16
retrieving revision 1.16.18.1
diff -u -p -r1.16 -r1.16.18.1
--- cppu/inc/com/sun/star/uno/Sequence.h	8 Sep 2005 08:34:21 -0000	1.16
+++ cppu/inc/com/sun/star/uno/Sequence.h	24 Nov 2005 08:18:08 -0000	1.16.18.1
@@ -265,6 +265,9 @@ inline ::com::sun::star::uno::Sequence< 
 
 /** Gets the meta type of IDL sequence.
 
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
     @tplparam E element type of sequence
     @param dummy typed pointer for function signature
     @return type of IDL sequence
Index: cppu/inc/com/sun/star/uno/Sequence.hxx
===================================================================
RCS file: /cvs/udk/cppu/inc/com/sun/star/uno/Sequence.hxx,v
retrieving revision 1.20
retrieving revision 1.20.18.1
diff -u -p -r1.20 -r1.20.18.1
--- cppu/inc/com/sun/star/uno/Sequence.hxx	8 Sep 2005 08:34:43 -0000	1.20
+++ cppu/inc/com/sun/star/uno/Sequence.hxx	24 Nov 2005 08:18:09 -0000	1.20.18.1
@@ -53,7 +53,9 @@
 #ifndef _COM_SUN_STAR_UNO_GENFUNC_HXX_
 #include "com/sun/star/uno/genfunc.hxx"
 #endif
-
+#ifndef INCLUDED_CPPU_UNOTYPE_HXX
+#include "cppu/unotype.hxx"
+#endif
 
 namespace com
 {     
@@ -72,7 +74,7 @@ typelib_TypeDescriptionReference * Seque
 template< class E >
 inline Sequence< E >::Sequence() SAL_THROW( () )
 {
-    const Type & rType = getCppuType( this );
+    const Type & rType = ::cppu::getTypeFavourUnsigned( this );
     ::uno_type_sequence_construct(
         &_pSequence, rType.getTypeLibType(),
         0, 0, (uno_AcquireFunc)cpp_acquire );
@@ -99,7 +101,7 @@ inline Sequence< E >::Sequence(
 template< class E >
 inline Sequence< E >::Sequence( const E * pElements, sal_Int32 len )
 {
-    const Type & rType = getCppuType( this );
+    const Type & rType = ::cppu::getTypeFavourUnsigned( this );
 #if ! defined EXCEPTIONS_OFF
     sal_Bool success = 
 #endif    
@@ -116,7 +118,7 @@ inline Sequence< E >::Sequence( const E 
 template< class E >
 inline Sequence< E >::Sequence( sal_Int32 len )
 {
-    const Type & rType = getCppuType( this );
+    const Type & rType = ::cppu::getTypeFavourUnsigned( this );
 #if ! defined EXCEPTIONS_OFF
     sal_Bool success = 
 #endif    
@@ -133,7 +135,7 @@ inline Sequence< E >::Sequence( sal_Int3
 template< class E >
 inline Sequence< E >::~Sequence() SAL_THROW( () )
 {
-    const Type & rType = getCppuType( this );
+    const Type & rType = ::cppu::getTypeFavourUnsigned( this );
     ::uno_type_destructData(
         this, rType.getTypeLibType(), (uno_ReleaseFunc)cpp_release );
 }
@@ -142,7 +144,7 @@ inline Sequence< E >::~Sequence() SAL_TH
 template< class E >
 inline Sequence< E > & Sequence< E >::operator = ( const Sequence< E > & rSeq ) SAL_THROW( () )
 {
-    const Type & rType = getCppuType( this );
+    const Type & rType = ::cppu::getTypeFavourUnsigned( this );
     ::uno_type_sequence_assign(
         &_pSequence, rSeq._pSequence, rType.getTypeLibType(), (uno_ReleaseFunc)cpp_release );
     return *this;
@@ -155,7 +157,7 @@ inline sal_Bool Sequence< E >::operator 
 {
     if (_pSequence == rSeq._pSequence)
         return sal_True;
-    const Type & rType = getCppuType( this );
+    const Type & rType = ::cppu::getTypeFavourUnsigned( this );
     return ::uno_type_equalData(
         const_cast< Sequence< E > * >( this ), rType.getTypeLibType(),
         const_cast< Sequence< E > * >( &rSeq ), rType.getTypeLibType(),
@@ -175,7 +177,7 @@ inline sal_Bool Sequence< E >::operator 
 template< class E >
 inline E * Sequence< E >::getArray()
 {
-    const Type & rType = getCppuType( this );
+    const Type & rType = ::cppu::getTypeFavourUnsigned( this );
 #if ! defined EXCEPTIONS_OFF
     sal_Bool success = 
 #endif
@@ -214,7 +216,7 @@ inline const E & Sequence< E >::operator
 template< class E >
 inline void Sequence< E >::realloc( sal_Int32 nSize )
 {
-    const Type & rType = getCppuType( this );
+    const Type & rType = ::cppu::getTypeFavourUnsigned( this );
 #if !defined EXCEPTIONS_OFF
     sal_Bool success = 
 #endif
@@ -240,22 +242,33 @@ inline ::com::sun::star::uno::Sequence< 
 }
 }
 
+namespace cppu {
+
+template< typename T > inline ::com::sun::star::uno::Type const &
+getTypeFavourUnsigned(::com::sun::star::uno::Sequence< T > const *) {
+    if (::com::sun::star::uno::Sequence< T >::s_pType == 0) {
+        ::typelib_static_sequence_type_init(
+            &::com::sun::star::uno::Sequence< T >::s_pType,
+            (::cppu::getTypeFavourUnsigned(
+                static_cast<
+                typename ::com::sun::star::uno::Sequence< T >::ElementType * >(
+                    0)).
+             getTypeLibType()));
+    }
+    return detail::getTypeFromTypeDescriptionReference(
+        &::com::sun::star::uno::Sequence< T >::s_pType);
+}
+
+}
+
 // generic sequence template
 template< class E >
 inline const ::com::sun::star::uno::Type &
 SAL_CALL getCppuType( const ::com::sun::star::uno::Sequence< E > * )
     SAL_THROW( () )
 {
-	if (! ::com::sun::star::uno::Sequence< E >::s_pType)
-	{
-		const ::com::sun::star::uno::Type & rElementType = getCppuType(
-			(typename ::com::sun::star::uno::Sequence< E >::ElementType const *)0 );
-		::typelib_static_sequence_type_init(
-			& ::com::sun::star::uno::Sequence< E >::s_pType,
-			rElementType.getTypeLibType() );
-	}
-	return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-		& ::com::sun::star::uno::Sequence< E >::s_pType );
+    return ::cppu::getTypeFavourUnsigned(
+        static_cast< ::com::sun::star::uno::Sequence< E > * >(0));
 }
 
 // generic sequence template for given element type (e.g. C++ arrays)
Index: cppu/inc/com/sun/star/uno/Type.h
===================================================================
RCS file: /cvs/udk/cppu/inc/com/sun/star/uno/Type.h,v
retrieving revision 1.13
retrieving revision 1.13.18.1
diff -u -p -r1.13 -r1.13.18.1
--- cppu/inc/com/sun/star/uno/Type.h	8 Sep 2005 08:35:01 -0000	1.13
+++ cppu/inc/com/sun/star/uno/Type.h	24 Nov 2005 08:18:09 -0000	1.13.18.1
@@ -234,6 +234,9 @@ public:
 }
 
 /** Gets the meta type of IDL type "type".
+
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
     
 	@param dummy typed pointer for function signature
 	@return type of IDL type "type"
@@ -262,12 +265,18 @@ inline const ::com::sun::star::uno::Type
 inline const ::com::sun::star::uno::Type & SAL_CALL getBooleanCppuType() SAL_THROW( () );
 /** Gets the meta type of IDL type boolean.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type boolean
 */
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const sal_Bool * ) SAL_THROW( () );
 /** Gets the meta type of IDL type boolean.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type boolean
 */
@@ -287,6 +296,9 @@ inline const ::com::sun::star::uno::Type
 
 /** Gets the meta type of IDL type byte.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type byte
 */
@@ -294,6 +306,9 @@ inline const ::com::sun::star::uno::Type
 
 /** Gets the meta type of IDL type string.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type string
 */
@@ -301,6 +316,9 @@ inline const ::com::sun::star::uno::Type
 
 /** Gets the meta type of IDL type short.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type short
 */
@@ -308,6 +326,9 @@ inline const ::com::sun::star::uno::Type
 
 /** Gets the meta type of IDL type unsigned short.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type unsigned short
 */
@@ -315,6 +336,9 @@ inline const ::com::sun::star::uno::Type
 
 /** Gets the meta type of IDL type long.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type long
 */
@@ -322,6 +346,9 @@ inline const ::com::sun::star::uno::Type
 
 /** Gets the meta type of IDL type unsigned long.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type unsigned long
 */
@@ -329,6 +356,9 @@ inline const ::com::sun::star::uno::Type
 
 /** Gets the meta type of IDL type hyper.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type hyper
 */
@@ -336,6 +366,9 @@ inline const ::com::sun::star::uno::Type
 
 /** Gets the meta type of IDL type unsigned hyper.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type unsigned hyper
 */
@@ -343,6 +376,9 @@ inline const ::com::sun::star::uno::Type
 
 /** Gets the meta type of IDL type float.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type float
 */
@@ -350,6 +386,9 @@ inline const ::com::sun::star::uno::Type
 
 /** Gets the meta type of IDL type double.
     
+    There are cases (involving templates) where uses of getCppuType are known to
+    not compile.  Use cppu::UnoType or cppu::getTypeFavourUnsigned instead.
+    
 	@param dummy typed pointer for function signature
 	@return type of IDL type double
 */
@@ -415,7 +454,7 @@ template< typename T > inline const ::co
 getCppuType() SAL_THROW(());
 
 /** Gets the meta type of IDL type char.
-    
+
     @return type of IDL type char
 
     @since UDK 3.2.0
Index: cppu/inc/com/sun/star/uno/Type.hxx
===================================================================
RCS file: /cvs/udk/cppu/inc/com/sun/star/uno/Type.hxx,v
retrieving revision 1.12
retrieving revision 1.12.18.1
diff -u -p -r1.12 -r1.12.18.1
--- cppu/inc/com/sun/star/uno/Type.hxx	8 Sep 2005 08:35:19 -0000	1.12
+++ cppu/inc/com/sun/star/uno/Type.hxx	24 Nov 2005 08:18:10 -0000	1.12.18.1
@@ -42,7 +42,9 @@
 #ifndef _COM_SUN_STAR_UNO_TYPE_H_
 #include <com/sun/star/uno/Type.h>
 #endif
-
+#ifndef INCLUDED_CPPU_UNOTYPE_HXX
+#include "cppu/unotype.hxx"
+#endif
 
 namespace com
 {     
@@ -117,113 +119,94 @@ typelib_TypeDescriptionReference * Array
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const ::com::sun::star::uno::Type * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_TYPE ) );
+    return ::cppu::UnoType< ::com::sun::star::uno::Type >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuVoidType() SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_VOID ) );
+    return ::cppu::UnoType< ::cppu::UnoVoidType >::get();
 }
 inline const ::com::sun::star::uno::Type & SAL_CALL getVoidCppuType() SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_VOID ) );
+    return ::cppu::UnoType< ::cppu::UnoVoidType >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuBooleanType() SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_BOOLEAN ) );
+    return ::cppu::UnoType< bool >::get();
 }
 inline const ::com::sun::star::uno::Type & SAL_CALL getBooleanCppuType() SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_BOOLEAN ) );
+    return ::cppu::UnoType< bool >::get();
 }
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const sal_Bool * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_BOOLEAN ) );
+    return ::cppu::UnoType< bool >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType(
     bool const * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_BOOLEAN ) );
+    return ::cppu::UnoType< bool >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCharCppuType() SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_CHAR ) );
+    return ::cppu::UnoType< ::cppu::UnoCharType >::get();
 }
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuCharType() SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_CHAR ) );
+    return ::cppu::UnoType< ::cppu::UnoCharType >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const sal_Int8 * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_BYTE ) );
+    return ::cppu::UnoType< ::sal_Int8 >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const ::rtl::OUString * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_STRING ) );
+    return ::cppu::UnoType< ::rtl::OUString >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const sal_Int16 * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_SHORT ) );
+    return ::cppu::UnoType< ::sal_Int16 >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const sal_uInt16 * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_UNSIGNED_SHORT ) );
+    return ::cppu::UnoType< ::cppu::UnoUnsignedShortType >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const sal_Int32 * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_LONG ) );
+    return ::cppu::UnoType< ::sal_Int32 >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const sal_uInt32 * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_UNSIGNED_LONG ) );
+    return ::cppu::UnoType< ::sal_uInt32 >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const sal_Int64 * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_HYPER ) );
+    return ::cppu::UnoType< ::sal_Int64 >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const sal_uInt64 * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_UNSIGNED_HYPER ) );
+    return ::cppu::UnoType< ::sal_uInt64 >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const float * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_FLOAT ) );
+    return ::cppu::UnoType< float >::get();
 }
 
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType( const double * ) SAL_THROW( () )
 {
-    return * reinterpret_cast< const ::com::sun::star::uno::Type * >(
-        ::typelib_static_type_getByTypeClass( typelib_TypeClass_DOUBLE ) );
+    return ::cppu::UnoType< double >::get();
 }
 
 template< class T >
@@ -231,7 +214,8 @@ inline const ::com::sun::star::uno::Type
 {
 	if (! ::com::sun::star::uno::Array< T >::s_pType)
 	{
-		const ::com::sun::star::uno::Type & rElementType = getCppuType( *pT );
+		const ::com::sun::star::uno::Type & rElementType =
+            ::cppu::getTypeFavourUnsigned( *pT );
 		sal_Int32 size = sizeof( **pT );
 		sal_Int32 dim1 = sizeof( *pT ) / size;
 		::typelib_static_array_type_init(
@@ -247,7 +231,8 @@ inline const ::com::sun::star::uno::Type
 {
 	if (! ::com::sun::star::uno::Array< T >::s_pType)
 	{
-		const ::com::sun::star::uno::Type & rElementType = getCppuType( **pT );
+		const ::com::sun::star::uno::Type & rElementType =
+            ::cppu::getTypeFavourUnsigned( **pT );
 		sal_Int32 size = sizeof( ***pT );
 		sal_Int32 dim2 = sizeof( **pT ) / size;
 		sal_Int32 dim1 = sizeof( *pT ) / dim2 / size;
@@ -264,7 +249,8 @@ inline const ::com::sun::star::uno::Type
 {
 	if (! ::com::sun::star::uno::Array< T >::s_pType)
 	{
-		const ::com::sun::star::uno::Type & rElementType = getCppuType( ***pT );
+		const ::com::sun::star::uno::Type & rElementType =
+            ::cppu::getTypeFavourUnsigned( ***pT );
 		sal_Int32 size = sizeof( ****pT );
 		sal_Int32 dim3 = sizeof( ***pT ) / size;
 		sal_Int32 dim2 = sizeof( **pT ) / dim3 / size;
@@ -282,7 +268,8 @@ inline const ::com::sun::star::uno::Type
 {
 	if (! ::com::sun::star::uno::Array< T >::s_pType)
 	{
-		const ::com::sun::star::uno::Type & rElementType = getCppuType( ****pT );
+		const ::com::sun::star::uno::Type & rElementType =
+            ::cppu::getTypeFavourUnsigned( ****pT );
 		sal_Int32 size = sizeof( *****pT );
 		sal_Int32 dim4 = sizeof( ****pT ) / size;
 		sal_Int32 dim3 = sizeof( ***pT ) / dim4 / size;
@@ -301,7 +288,8 @@ inline const ::com::sun::star::uno::Type
 {
 	if (! ::com::sun::star::uno::Array< T >::s_pType)
 	{
-		const ::com::sun::star::uno::Type & rElementType = getCppuType( *****pT );
+		const ::com::sun::star::uno::Type & rElementType =
+            ::cppu::getTypeFavourUnsigned( *****pT );
 		sal_Int32 size = sizeof( ******pT );
 		sal_Int32 dim5 = sizeof( *****pT ) / size;
 		sal_Int32 dim4 = sizeof( ****pT ) / dim5 / size;
@@ -321,7 +309,8 @@ inline const ::com::sun::star::uno::Type
 {
 	if (! ::com::sun::star::uno::Array< T >::s_pType)
 	{
-		const ::com::sun::star::uno::Type & rElementType = getCppuType( ******pT );
+		const ::com::sun::star::uno::Type & rElementType =
+            ::cppu::getTypeFavourUnsigned( ******pT );
 		sal_Int32 size = sizeof( *******pT );
 		sal_Int32 dim6 = sizeof( ******pT ) / size;
 		sal_Int32 dim5 = sizeof( *****pT ) / dim6 / size;
@@ -340,14 +329,14 @@ inline const ::com::sun::star::uno::Type
 template< typename T >
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType() SAL_THROW(())
 {
-    return getCppuType(static_cast< T * >(0));
+    return ::cppu::UnoType< T >::get();
 }
 
 template<>
 inline const ::com::sun::star::uno::Type & SAL_CALL getCppuType< sal_Unicode >()
     SAL_THROW(())
 {
-    return getCharCppuType();
+    return ::cppu::UnoType< ::cppu::UnoCharType >::get();
 }
 
 #endif
Index: cppu/inc/cppu/unotype.hxx
===================================================================
RCS file: cppu/inc/cppu/unotype.hxx
diff -N cppu/inc/cppu/unotype.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ cppu/inc/cppu/unotype.hxx	24 Nov 2005 08:19:28 -0000	1.1.2.1
@@ -0,0 +1,338 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_CPPU_UNOTYPE_HXX
+#define INCLUDED_CPPU_UNOTYPE_HXX
+
+#ifndef _SAL_CONFIG_H_
+#include "sal/config.h"
+#endif
+
+#include <cstddef>
+
+#ifndef _COM_SUN_STAR_UNO_TYPE_H_
+#include "com/sun/star/uno/Type.h"
+#endif
+#ifndef _SAL_TYPES_H_
+#include "sal/types.h"
+#endif
+#ifndef _TYPELIB_TYPECLASS_H_
+#include "typelib/typeclass.h"
+#endif
+#ifndef _TYPELIB_TYPEDESCRIPTION_H_
+#include "typelib/typedescription.h"
+#endif
+
+namespace com { namespace sun { namespace star { namespace uno {
+    class Any;
+    class Exception;
+    template< typename > class Reference;
+    template< typename > class Sequence;
+    class XInterface;
+} } } }
+namespace rtl { class OUString; }
+
+namespace cppu {
+
+template< typename > class UnoType;
+
+/**
+   A unique C++ type representing the UNO type VOID in cppu::UnoType.
+
+   This type is declared but not defined.  Its only use is as a template
+   argument to cppu::UnoType.
+*/
+struct UnoVoidType;
+
+/**
+   A unique C++ type representing the UNO type UNSIGNED SHORT in cppu::UnoType.
+
+   On some platforms, the UNO types UNSIGNED SHORT and CHAR map to the same C++
+   type, so this C++ type is needed to unambiguously specify UNO types in
+   cppu::UnoType.
+
+   This type is declared but not defined.  Its only use is as a template
+   argument to cppu::UnoType.
+*/
+struct UnoUnsignedShortType;
+
+/**
+   A unique C++ type representing the UNO type UNSIGNED SHORT in cppu::UnoType.
+
+   On some platforms, the UNO types UNSIGNED SHORT and CHAR map to the same C++
+   type, so this C++ type is needed to unambiguously specify UNO types in
+   cppu::UnoType.
+
+   This type is declared but not defined.  Its only use is as a template
+   argument to cppu::UnoType.
+*/
+struct UnoCharType;
+
+/**
+   A unique C++ type template representing the UNO sequence types in
+   cppu::UnoType.
+
+   On some platforms, the UNO types UNSIGNED SHORT and CHAR map to the same C++
+   type, so this C++ type is needed to unambiguously specify UNO types in
+   cppu::UnoType.
+
+   This type is declared but not defined.  Its only use is as a template
+   argument to cppu::UnoType.
+*/
+template< typename > struct UnoSequenceType;
+
+namespace detail {
+
+inline ::com::sun::star::uno::Type const & getTypeFromTypeDescriptionReference(
+    ::typelib_TypeDescriptionReference * const * tdr)
+{
+    return *reinterpret_cast< ::com::sun::star::uno::Type const * >(tdr);
+}
+
+inline ::com::sun::star::uno::Type const &
+getTypeFromTypeClass(::typelib_TypeClass tc) {
+    return getTypeFromTypeDescriptionReference(
+        ::typelib_static_type_getByTypeClass(tc));
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::cppu::UnoVoidType const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_VOID);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(bool const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_BOOLEAN);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::sal_Bool const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_BOOLEAN);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::sal_Int8 const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_BYTE);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::sal_Int16 const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_SHORT);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::cppu::UnoUnsignedShortType const *) {
+    return ::cppu::detail::getTypeFromTypeClass(
+        ::typelib_TypeClass_UNSIGNED_SHORT);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::sal_Int32 const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_LONG);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::sal_uInt32 const *) {
+    return ::cppu::detail::getTypeFromTypeClass(
+        ::typelib_TypeClass_UNSIGNED_LONG);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::sal_Int64 const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_HYPER);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::sal_uInt64 const *) {
+    return ::cppu::detail::getTypeFromTypeClass(
+        ::typelib_TypeClass_UNSIGNED_HYPER);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(float const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_FLOAT);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(double const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_DOUBLE);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::cppu::UnoCharType const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_CHAR);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::rtl::OUString const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_STRING);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::com::sun::star::uno::Type const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_TYPE);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::com::sun::star::uno::Any const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_ANY);
+}
+
+template< typename T > inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::cppu::UnoSequenceType< T > const *) {
+    static typelib_TypeDescriptionReference * p = 0;
+    if (p == 0) {
+        ::typelib_static_sequence_type_init(
+            &p, ::cppu::UnoType< T >::get().getTypeLibType());
+    }
+    return ::cppu::detail::getTypeFromTypeDescriptionReference(&p);
+}
+
+template< typename T > inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::com::sun::star::uno::Sequence< T > const *) {
+    return ::cppu::detail::cppu_getUnoType(
+        static_cast< ::cppu::UnoSequenceType< T > * >(0));
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::com::sun::star::uno::Exception const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_EXCEPTION);
+}
+
+inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::com::sun::star::uno::XInterface const *) {
+    return ::cppu::detail::getTypeFromTypeClass(::typelib_TypeClass_INTERFACE);
+}
+
+template< typename T > inline ::com::sun::star::uno::Type const &
+cppu_getUnoType(::com::sun::star::uno::Reference< T > const *) {
+    return ::cppu::UnoType< T >::get();
+}
+
+template< typename T > struct UnsignedShortVsChar1 {
+    typedef T t;
+};
+
+template<> struct UnsignedShortVsChar1< ::sal_Unicode > {
+    typedef ::cppu::UnoCharType t;
+};
+
+template< typename T > struct UnsignedShortVsChar2 {
+    typedef typename ::cppu::detail::UnsignedShortVsChar1< T >::t t;
+};
+
+template<> struct UnsignedShortVsChar2< ::sal_uInt16 > {};
+
+}
+
+/**
+   Get the com::sun::star::uno::Type instance representing a certain UNO type.
+
+   For each C++ type representing a UNO type, the corresponding instantiation of
+   this template has a public static member function get().  (The template is
+   specialized for C++ templates representing polymorphic struct type templates
+   of UNO.  In those cases, it does not work to instantiate UnoType with a C++
+   type that is derived from a C++ type that represents a UNO type, but does not
+   itself represent a UNO type.  In all other cases, UnoType even works for such
+   C++ types that are unambiguously derived from one C++ type that represents a
+   UNO type.)  In addition to those C++ types that are mappings of UNO types
+   (except for sal_uInt16 and sal_Unicode, see below), the following C++ types
+   are appropriate as template arguments: cppu::UnoVoidType, bool,
+   cppu::UnoUnsignedShortType, cppu::UnoCharType, cppu::UnoSequenceType with any
+   appropriate template argument (the latter three to unambiguously specify UNO
+   types, as the UNO types UNSIGNED SHORT and CHAR map to the same C++ type on
+   some platforms), and com::sun::star::uno::Reference with any appropriate
+   template argument.
+*/
+template< typename T > class UnoType {
+public:
+    static inline ::com::sun::star::uno::Type const & get() {
+        using namespace ::cppu::detail;
+        return cppu_getUnoType(static_cast< T * >(0));
+    }
+
+private:
+    UnoType(UnoType &); // not defined
+    ~UnoType(); // not defined
+    void operator =(UnoType); // not defined
+};
+
+/**
+   A working replacement for getCppuType (see there).
+
+   There are three overloads of this function that together form the replacement
+   of getCppuType.  The replacement has exactly the same semantics as
+   getCppuType, in that it works for the the UNO type UNSIGNED SHORT but not for
+   the UNO type CHAR on those platforms where both UNO types map to the same C++
+   type.
+*/
+template< typename T > inline ::com::sun::star::uno::Type const &
+getTypeFavourUnsigned(
+    T const *,
+    typename ::cppu::detail::UnsignedShortVsChar2< T >::t const * = 0)
+{
+    return ::cppu::UnoType<
+        typename ::cppu::detail::UnsignedShortVsChar2< T >::t >::get();
+}
+
+/**
+   A working replacement for getCppuType (see there).
+
+   There are three overloads of this function that together form the replacement
+   of getCppuType.  The replacement has exactly the same semantics as
+   getCppuType, in that it works for the the UNO type UNSIGNED SHORT but not for
+   the UNO type CHAR on those platforms where both UNO types map to the same C++
+   type.
+*/
+inline ::com::sun::star::uno::Type const &
+getTypeFavourUnsigned(sal_uInt16 const *) {
+    return ::cppu::UnoType< ::cppu::UnoUnsignedShortType >::get();
+}
+
+/**
+   A working replacement for getCppuType (see there).
+
+   There are three overloads of this function that together form the replacement
+   of getCppuType.  The replacement has the same semantics as getCppuType, in
+   that it works for the the UNO type UNSIGNED SHORT, but not for the UNO type
+   CHAR.
+*/
+template< typename T > inline ::com::sun::star::uno::Type const &
+getTypeFavourUnsigned(::com::sun::star::uno::Sequence< T > const *);
+    // defined in com/sun/star/uno/Sequence.hxx
+
+}
+
+#endif
Index: cppu/inc/uno/mapping.hxx
===================================================================
RCS file: /cvs/udk/cppu/inc/uno/mapping.hxx,v
retrieving revision 1.8
retrieving revision 1.8.18.1
diff -u -p -r1.8 -r1.8.18.1
--- cppu/inc/uno/mapping.hxx	8 Sep 2005 08:41:49 -0000	1.8
+++ cppu/inc/uno/mapping.hxx	24 Nov 2005 08:18:11 -0000	1.8.18.1
@@ -53,7 +53,9 @@
 #ifndef _COM_SUN_STAR_UNO_REFERENCE_HXX_
 #include <com/sun/star/uno/Reference.hxx>
 #endif
-
+#ifndef INCLUDED_CPPU_UNOTYPE_HXX
+#include "cppu/unotype.hxx"
+#endif
 
 typedef struct _typelib_TypeDescription typelib_TypeDescription;
 typedef struct _typelib_InterfaceTypeDescription typelib_InterfaceTypeDescription;
@@ -314,7 +316,8 @@ inline sal_Bool mapToCpp( Reference< C >
 		::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(UNO_LB_UNO) ),
 		::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(CPPU_CURRENT_LANGUAGE_BINDING_NAME) ) );
 	OSL_ASSERT( aMapping.is() );
-	aMapping.mapInterface( (void **)ppRet, pUnoI, getCppuType( ppRet ) );
+	aMapping.mapInterface(
+            (void **)ppRet, pUnoI, ::cppu::getTypeFavourUnsigned( ppRet ) );
 	return (0 != *ppRet);
 }
 /** Maps an UNO interface of the currently used compiler environment to binary C UNO.
@@ -331,7 +334,8 @@ inline sal_Bool mapToUno( uno_Interface 
 		::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(CPPU_CURRENT_LANGUAGE_BINDING_NAME) ),
 		::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(UNO_LB_UNO) ) );
 	OSL_ASSERT( aMapping.is() );
-	aMapping.mapInterface( (void **)ppRet, x.get(), getCppuType( &x ) );
+	aMapping.mapInterface(
+            (void **)ppRet, x.get(), ::cppu::getTypeFavourUnsigned( &x ) );
 	return (0 != *ppRet);
 }
 
Index: cppu/prj/d.lst
===================================================================
RCS file: /cvs/udk/cppu/prj/d.lst,v
retrieving revision 1.15
retrieving revision 1.15.46.1
diff -u -p -r1.15 -r1.15.46.1
--- cppu/prj/d.lst	3 Nov 2004 08:49:55 -0000	1.15
+++ cppu/prj/d.lst	24 Nov 2005 08:18:12 -0000	1.15.46.1
@@ -7,6 +7,7 @@ mkdir: %_DEST%\inc%_EXT%\typelib
 mkdir: %_DEST%\inc%_EXT%\uno
 
 ..\inc\cppu\macros.hxx %_DEST%\inc%_EXT%\cppu\macros.hxx
+..\inc\cppu\unotype.hxx %_DEST%\inc%_EXT%\cppu\unotype.hxx
 
 ..\inc\com\sun\star\uno\Reference.h %_DEST%\inc%_EXT%\com\sun\star\uno\Reference.h
 ..\inc\com\sun\star\uno\Reference.hxx %_DEST%\inc%_EXT%\com\sun\star\uno\Reference.hxx
Index: cppu/qa/makefile.mk
===================================================================
RCS file: /cvs/udk/cppu/qa/makefile.mk,v
retrieving revision 1.3
retrieving revision 1.3.18.1
diff -u -p -r1.3 -r1.3.18.1
--- cppu/qa/makefile.mk	8 Sep 2005 08:42:56 -0000	1.3
+++ cppu/qa/makefile.mk	24 Nov 2005 08:18:12 -0000	1.3.18.1
@@ -45,14 +45,21 @@ DLLPRE = # no leading "lib" on .so files
 
 INCPRE += $(MISC)$/$(TARGET)$/inc
 
-SHL1TARGET = $(TARGET)
+SHL1TARGET = $(TARGET)_any
 SHL1OBJS = $(SLO)$/test_any.obj
 SHL1STDLIBS = $(CPPULIB) $(CPPUNITLIB) $(SALLIB)
 SHL1VERSIONMAP = version.map
 SHL1IMPLIB = i$(SHL1TARGET)
 DEF1NAME = $(SHL1TARGET)
 
-SLOFILES = $(SHL1OBJS)
+SHL2TARGET = $(TARGET)_unotype
+SHL2OBJS = $(SLO)$/test_unotype.obj
+SHL2STDLIBS = $(CPPULIB) $(CPPUNITLIB) $(SALLIB)
+SHL2VERSIONMAP = version.map
+SHL2IMPLIB = i$(SHL2TARGET)
+DEF2NAME = $(SHL2TARGET)
+
+SLOFILES = $(SHL1OBJS) $(SHL2OBJS)
 
 .INCLUDE: target.mk
 
@@ -74,5 +81,6 @@ $(MISC)$/$(TARGET)$/types.urd: types.idl
     - $(MKDIR) $(MISC)$/$(TARGET)
     $(IDLC) -O$(MISC)$/$(TARGET) -I$(SOLARIDLDIR) -cid -we $<
 
-test .PHONY: $(SHL1TARGETN)
+test .PHONY: $(SHL1TARGETN) $(SHL2TARGETN)
     testshl2 $(SHL1TARGETN)
+    testshl2 $(SHL2TARGETN)
Index: cppu/qa/test_unotype.cxx
===================================================================
RCS file: cppu/qa/test_unotype.cxx
diff -N cppu/qa/test_unotype.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ cppu/qa/test_unotype.cxx	24 Nov 2005 08:19:41 -0000	1.1.2.1
@@ -0,0 +1,463 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "sal/config.h"
+
+#include <iostream>
+#include <typeinfo>
+
+#include "com/sun/star/beans/Optional.hpp"
+#include "com/sun/star/beans/PropertyChangeEvent.hpp"
+#include "com/sun/star/lang/EventObject.hpp"
+#include "com/sun/star/uno/Exception.hpp"
+#include "com/sun/star/uno/Reference.hxx"
+#include "com/sun/star/uno/RuntimeException.hpp"
+#include "com/sun/star/uno/Sequence.hxx"
+#include "com/sun/star/uno/Type.hxx"
+#include "com/sun/star/uno/TypeClass.hpp"
+#include "com/sun/star/uno/XComponentContext.hpp"
+#include "com/sun/star/uno/XInterface.hpp"
+#include "cppu/unotype.hxx"
+#include "cppunit/simpleheader.hxx"
+#include "rtl/ustring.h"
+#include "rtl/ustring.hxx"
+#include "sal/types.h"
+
+namespace com { namespace sun { namespace star { namespace uno {
+    class Any;
+} } } }
+
+namespace {
+
+namespace css = com::sun::star;
+
+struct DerivedStruct1: css::lang::EventObject {};
+
+struct DerivedStruct2: css::beans::PropertyChangeEvent {};
+
+struct DerivedException1: css::uno::Exception {};
+
+struct DerivedException2: css::uno::RuntimeException {};
+
+struct DerivedInterface1: css::uno::XInterface {};
+
+struct DerivedInterface2: css::uno::XComponentContext {};
+
+class Test: public ::CppUnit::TestFixture {
+public:
+    void testUnoType();
+
+    void testGetTypeFavourUnsigned();
+
+    CPPUNIT_TEST_SUITE(Test);
+    CPPUNIT_TEST(testUnoType);
+    CPPUNIT_TEST(testGetTypeFavourUnsigned);
+    CPPUNIT_TEST_SUITE_END();
+};
+
+void Test::testUnoType() {
+    css::uno::Type t;
+    t = ::cppu::UnoType< ::cppu::UnoVoidType >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_VOID, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("void")), t.getTypeName());
+    t = ::cppu::UnoType< bool >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_BOOLEAN, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("boolean")),
+        t.getTypeName());
+    CPPUNIT_ASSERT(::cppu::UnoType< ::sal_Bool >::get() == t);
+    t = ::cppu::UnoType< ::sal_Int8 >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_BYTE, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("byte")), t.getTypeName());
+    t = ::cppu::UnoType< ::sal_Int16 >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_SHORT, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("short")), t.getTypeName());
+    t = ::cppu::UnoType< ::cppu::UnoUnsignedShortType >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_UNSIGNED_SHORT, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("unsigned short")),
+        t.getTypeName());
+    t = ::cppu::UnoType< ::sal_Int32 >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_LONG, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("long")), t.getTypeName());
+    t = ::cppu::UnoType< ::sal_uInt32 >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_UNSIGNED_LONG, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("unsigned long")),
+        t.getTypeName());
+    t = ::cppu::UnoType< ::sal_Int64 >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_HYPER, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("hyper")), t.getTypeName());
+    t = ::cppu::UnoType< ::sal_uInt64 >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_UNSIGNED_HYPER, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("unsigned hyper")),
+        t.getTypeName());
+    t = ::cppu::UnoType< float >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_FLOAT, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("float")), t.getTypeName());
+    t = ::cppu::UnoType< double >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_DOUBLE, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("double")),
+        t.getTypeName());
+    t = ::cppu::UnoType< ::cppu::UnoCharType >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_CHAR, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("char")), t.getTypeName());
+    t = ::cppu::UnoType< ::rtl::OUString >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_STRING, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("string")),
+        t.getTypeName());
+    t = ::cppu::UnoType< css::uno::Type >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_TYPE, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("type")), t.getTypeName());
+    t = ::cppu::UnoType< css::uno::Any >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_ANY, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("any")), t.getTypeName());
+    t = ::cppu::UnoType< ::cppu::UnoSequenceType< ::sal_Int8 > >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_SEQUENCE, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("[]byte")),
+        t.getTypeName());
+    CPPUNIT_ASSERT(
+        ::cppu::UnoType< css::uno::Sequence< ::sal_Int8 > >::get() == t);
+    t = ::cppu::UnoType<
+        ::cppu::UnoSequenceType< ::cppu::UnoUnsignedShortType > >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_SEQUENCE, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("[]unsigned short")),
+        t.getTypeName());
+    t = ::cppu::UnoType<
+        ::cppu::UnoSequenceType< ::cppu::UnoCharType > >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_SEQUENCE, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("[]char")),
+        t.getTypeName());
+    t = ::cppu::UnoType< ::cppu::UnoSequenceType< ::cppu::UnoSequenceType<
+        ::sal_Int8 > > >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_SEQUENCE, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("[][]byte")),
+        t.getTypeName());
+    CPPUNIT_ASSERT(
+        ::cppu::UnoType<
+        css::uno::Sequence< css::uno::Sequence< ::sal_Int8 > > >::get() == t);
+    t = ::cppu::UnoType< ::cppu::UnoSequenceType< ::cppu::UnoSequenceType<
+        ::cppu::UnoUnsignedShortType > > >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_SEQUENCE, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("[][]unsigned short")),
+        t.getTypeName());
+    t = ::cppu::UnoType< ::cppu::UnoSequenceType< ::cppu::UnoSequenceType<
+        ::cppu::UnoCharType > > >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_SEQUENCE, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("[][]char")),
+        t.getTypeName());
+    t = ::cppu::UnoType< css::uno::TypeClass >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_ENUM, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM("com.sun.star.uno.TypeClass")),
+        t.getTypeName());
+    t = ::cppu::UnoType< css::lang::EventObject >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_STRUCT, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM("com.sun.star.lang.EventObject")),
+        t.getTypeName());
+    CPPUNIT_ASSERT(::cppu::UnoType< DerivedStruct1 >::get() == t);
+    t = ::cppu::UnoType< css::beans::PropertyChangeEvent >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_STRUCT, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM(
+                "com.sun.star.beans.PropertyChangeEvent")),
+        t.getTypeName());
+#if !(defined __SUNPRO_CC && __SUNPRO_CC <= 0x550) // erroneous ambiguity stated
+    CPPUNIT_ASSERT(::cppu::UnoType< DerivedStruct2 >::get() == t);
+#endif
+    t = ::cppu::UnoType< css::beans::Optional< ::sal_Int8 > >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_STRUCT, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM("com.sun.star.beans.Optional<byte>")),
+        t.getTypeName());
+    t = ::cppu::UnoType< css::uno::Exception >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_EXCEPTION, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM("com.sun.star.uno.Exception")),
+        t.getTypeName());
+    CPPUNIT_ASSERT(::cppu::UnoType< DerivedException1 >::get() == t);
+    t = ::cppu::UnoType< css::uno::RuntimeException >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_EXCEPTION, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM("com.sun.star.uno.RuntimeException")),
+        t.getTypeName());
+#if !(defined __SUNPRO_CC && __SUNPRO_CC <= 0x550) // erroneous ambiguity stated
+    CPPUNIT_ASSERT(::cppu::UnoType< DerivedException2 >::get() == t);
+#endif
+    t = ::cppu::UnoType< css::uno::XInterface >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_INTERFACE, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM("com.sun.star.uno.XInterface")),
+        t.getTypeName());
+    CPPUNIT_ASSERT(
+        ::cppu::UnoType< css::uno::Reference< css::uno::XInterface > >::get() ==
+        t);
+    CPPUNIT_ASSERT(::cppu::UnoType< DerivedInterface1 >::get() == t);
+    CPPUNIT_ASSERT(
+        ::cppu::UnoType< css::uno::Reference< DerivedInterface1 > >::get() ==
+        t);
+    t = ::cppu::UnoType< css::uno::XComponentContext >::get();
+    CPPUNIT_ASSERT_EQUAL(css::uno::TypeClass_INTERFACE, t.getTypeClass());
+    CPPUNIT_ASSERT_EQUAL(
+        ::rtl::OUString(
+            RTL_CONSTASCII_USTRINGPARAM("com.sun.star.uno.XComponentContext")),
+        t.getTypeName());
+    CPPUNIT_ASSERT(
+        ::cppu::UnoType<
+        css::uno::Reference< css::uno::XComponentContext > >::get() == t);
+#if !(defined __SUNPRO_CC && __SUNPRO_CC <= 0x550) // erroneous ambiguity stated
+    CPPUNIT_ASSERT(::cppu::UnoType< DerivedInterface2 >::get() == t);
+    CPPUNIT_ASSERT(
+        ::cppu::UnoType< css::uno::Reference< DerivedInterface2 > >::get() ==
+        t);
+#endif
+}
+
+void Test::testGetTypeFavourUnsigned() {
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< ::cppu::UnoVoidType *>(0)) ==
+        ::cppu::UnoType< ::cppu::UnoVoidType >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< bool *>(0)) ==
+        ::cppu::UnoType< bool >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< ::sal_Bool *>(0)) ==
+        ::cppu::UnoType< bool >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< ::sal_Int8 *>(0)) ==
+        ::cppu::UnoType< ::sal_Int8 >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< ::sal_Int16 *>(0)) ==
+        ::cppu::UnoType< ::sal_Int16 >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< ::cppu::UnoUnsignedShortType *>(0)) ==
+        ::cppu::UnoType< ::cppu::UnoUnsignedShortType >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< ::sal_uInt16 *>(0)) ==
+        ::cppu::UnoType< ::cppu::UnoUnsignedShortType >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< ::sal_Int32 *>(0)) ==
+        ::cppu::UnoType< ::sal_Int32 >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< ::sal_uInt32 *>(0)) ==
+        ::cppu::UnoType< ::sal_uInt32 >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< ::sal_Int64 *>(0)) ==
+        ::cppu::UnoType< ::sal_Int64 >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< ::sal_uInt64 *>(0)) ==
+        ::cppu::UnoType< ::sal_uInt64 >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< float *>(0)) ==
+        ::cppu::UnoType< float >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< double *>(0)) ==
+        ::cppu::UnoType< double >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< ::cppu::UnoCharType *>(0)) ==
+        ::cppu::UnoType< ::cppu::UnoCharType >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< ::rtl::OUString *>(0)) ==
+        ::cppu::UnoType< ::rtl::OUString >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< css::uno::Type *>(0)) ==
+        ::cppu::UnoType< css::uno::Type >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< css::uno::Any *>(0)) ==
+        ::cppu::UnoType< css::uno::Any >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast<
+            ::cppu::UnoSequenceType< ::cppu::UnoUnsignedShortType > *>(0)) ==
+        ::cppu::UnoType<
+        ::cppu::UnoSequenceType< ::cppu::UnoUnsignedShortType > >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< css::uno::Sequence< ::sal_uInt16 > *>(0)) ==
+        ::cppu::UnoType<
+        ::cppu::UnoSequenceType< ::cppu::UnoUnsignedShortType > >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< ::cppu::UnoSequenceType< ::cppu::UnoSequenceType<
+            ::cppu::UnoUnsignedShortType > > *>(0)) ==
+        ::cppu::UnoType< ::cppu::UnoSequenceType< ::cppu::UnoSequenceType<
+        ::cppu::UnoUnsignedShortType > > >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< css::uno::Sequence< css::uno::Sequence<
+            ::sal_uInt16 > > *>(0)) ==
+        ::cppu::UnoType< ::cppu::UnoSequenceType< ::cppu::UnoSequenceType<
+        ::cppu::UnoUnsignedShortType > > >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< css::uno::TypeClass *>(0)) ==
+        ::cppu::UnoType< css::uno::TypeClass >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< css::lang::EventObject *>(0)) ==
+        ::cppu::UnoType< css::lang::EventObject >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< DerivedStruct1 *>(0)) ==
+        ::cppu::UnoType< css::lang::EventObject >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< css::beans::PropertyChangeEvent *>(0)) ==
+        ::cppu::UnoType< css::beans::PropertyChangeEvent >::get());
+#if !(defined __SUNPRO_CC && __SUNPRO_CC <= 0x550) // erroneous ambiguity stated
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< DerivedStruct2 *>(0)) ==
+        ::cppu::UnoType< css::beans::PropertyChangeEvent >::get());
+#endif
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< css::beans::Optional< ::sal_Int8 > *>(0)) ==
+        ::cppu::UnoType< css::beans::Optional< ::sal_Int8 > >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< css::uno::Exception *>(0)) ==
+        ::cppu::UnoType< css::uno::Exception >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< DerivedException1 *>(0)) ==
+        ::cppu::UnoType< css::uno::Exception >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< css::uno::RuntimeException *>(0)) ==
+        ::cppu::UnoType< css::uno::RuntimeException >::get());
+#if !(defined __SUNPRO_CC && __SUNPRO_CC <= 0x550) // erroneous ambiguity stated
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< DerivedException2 *>(0)) ==
+        ::cppu::UnoType< css::uno::RuntimeException >::get());
+#endif
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< css::uno::XInterface *>(0)) ==
+        ::cppu::UnoType< css::uno::XInterface >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< css::uno::Reference< css::uno::XInterface > *>(0)) ==
+        ::cppu::UnoType< css::uno::XInterface >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< DerivedInterface1 *>(0)) ==
+        ::cppu::UnoType< css::uno::XInterface >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< css::uno::Reference< DerivedInterface1 > *>(0)) ==
+        ::cppu::UnoType< css::uno::XInterface >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< css::uno::XComponentContext *>(0)) ==
+        ::cppu::UnoType< css::uno::XComponentContext >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast<
+            css::uno::Reference< css::uno::XComponentContext > *>(0)) ==
+        ::cppu::UnoType< css::uno::XComponentContext >::get());
+#if !(defined __SUNPRO_CC && __SUNPRO_CC <= 0x550) // erroneous ambiguity stated
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(static_cast< DerivedInterface2 *>(0)) ==
+        ::cppu::UnoType< css::uno::XComponentContext >::get());
+    CPPUNIT_ASSERT(
+        ::cppu::getTypeFavourUnsigned(
+            static_cast< css::uno::Reference< DerivedInterface2 > *>(0)) ==
+        ::cppu::UnoType< css::uno::XComponentContext >::get());
+#endif
+    if (typeid(::sal_Unicode) == typeid(::sal_uInt16)) {
+        ::std::cout << "info: typeid(::sal_Unicode) == typeid(::sal_uInt16)\n";
+        CPPUNIT_ASSERT(
+            ::cppu::getTypeFavourUnsigned(
+                static_cast< ::sal_Unicode *>(0)) ==
+            ::cppu::UnoType< ::cppu::UnoUnsignedShortType >::get());
+        CPPUNIT_ASSERT(
+            ::cppu::getTypeFavourUnsigned(
+                static_cast< css::uno::Sequence< ::sal_Unicode > *>(0)) ==
+            ::cppu::UnoType<
+            ::cppu::UnoSequenceType< ::cppu::UnoUnsignedShortType > >::get());
+        CPPUNIT_ASSERT(
+            ::cppu::getTypeFavourUnsigned(
+                static_cast< css::uno::Sequence< css::uno::Sequence<
+                ::sal_Unicode > > *>(0)) ==
+            ::cppu::UnoType< ::cppu::UnoSequenceType< ::cppu::UnoSequenceType<
+            ::cppu::UnoUnsignedShortType > > >::get());
+    } else {
+        ::std::cout << "info: typeid(::sal_Unicode) != typeid(::sal_uInt16)\n";
+        CPPUNIT_ASSERT(
+            ::cppu::getTypeFavourUnsigned(
+                static_cast< ::sal_Unicode *>(0)) ==
+            ::cppu::UnoType< ::cppu::UnoCharType >::get());
+        CPPUNIT_ASSERT(
+            ::cppu::getTypeFavourUnsigned(
+                static_cast< css::uno::Sequence< ::sal_Unicode > *>(0)) ==
+            ::cppu::UnoType<
+            ::cppu::UnoSequenceType< ::cppu::UnoCharType > >::get());
+        CPPUNIT_ASSERT(
+            ::cppu::getTypeFavourUnsigned(
+                static_cast< css::uno::Sequence< css::uno::Sequence<
+                ::sal_Unicode > > *>(0)) ==
+            ::cppu::UnoType< ::cppu::UnoSequenceType< ::cppu::UnoSequenceType<
+            ::cppu::UnoCharType > > >::get());
+    }
+}
+
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(Test, "alltests");
+
+}
+
+NOADDITIONAL;
