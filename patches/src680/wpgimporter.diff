--- config_office/configure.in	7 May 2007 09:28:02 -0000	1.189.2.5
+++ config_office/configure.in	7 May 2007 13:46:58 -0000
@@ -299,6 +299,9 @@
 AC_ARG_WITH(system-libwps,
 [  --with-system-libwps    Use libwps already on system
 ],,)
+AC_ARG_WITH(system-libwpg,
+[  --with-system-libwpg    Use libwpg already on system
+],,)
 AC_ARG_WITH(system-libxml,
 [  --with-system-libxml    Use libxml already on system
 ],,)
@@ -3021,6 +3024,24 @@
 AC_SUBST(LIBWPS_LIBS)
 
 dnl ===================================================================
+dnl Check for system libwpg
+dnl ===================================================================
+AC_MSG_CHECKING([which libwpg to use])
+if test -n "$with_system_libwpg" -o -n "$with_system_libs" && \
+        test "$with_system_libwpg" != "no"; then
+    AC_MSG_RESULT([external])
+    SYSTEM_LIBWPG=YES
+    PKG_CHECK_MODULES( LIBWPG, libwpg-0.1 )
+else
+    AC_MSG_RESULT([internal])
+    SYSTEM_LIBWPS=NO
+    BUILD_TYPE="$BUILD_TYPE LIBWPG"
+fi
+AC_SUBST(SYSTEM_LIBWPG)
+AC_SUBST(LIBWPG_CFLAGS)
+AC_SUBST(LIBWPG_LIBS)
+
+dnl ===================================================================
 dnl Check whether freetype2 supports emboldening
 dnl ===================================================================
 if test "$SYSTEM_FREETYPE" = "YES" ; then
--- config_office/set_soenv.in	7 May 2007 09:28:12 -0000	1.127.2.5
+++ config_office/set_soenv.in	7 May 2007 13:47:01 -0000
@@ -1820,6 +1820,9 @@
 ToFile( "SYSTEM_LIBWPS",     "@SYSTEM_LIBWPS@",    "e" );
 ToFile( "LIBWPS_CFLAGS",     "@LIBWPS_CFLAGS@",    "e" );
 ToFile( "LIBWPS_LIBS",       "@LIBWPS_LIBS@",      "e" );
+ToFile( "SYSTEM_LIBWPG",     "@SYSTEM_LIBWPG@",    "e" );
+ToFile( "LIBWPG_CFLAGS",     "@LIBWPG_CFLAGS@",    "e" );
+ToFile( "LIBWPG_LIBS",       "@LIBWPG_LIBS@",      "e" );
 ToFile( "SYSTEM_LIBXML",     "@SYSTEM_LIBXML@",    "e" );
 ToFile( "USE_FT_EMBOLDEN",   "@USE_FT_EMBOLDEN@",  "e" );
 ToFile( "LIBXML_CFLAGS",     "@LIBXML_CFLAGS@",    "e" );
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ filter/source/config/fragments/filters/WordPerfectGraphics.xcu	2007-05-07 13:20:27.000000000 +0200
@@ -0,0 +1,14 @@
+    <node oor:name="WordPerfect Graphics" oor:op="replace">
+        <prop oor:name="Flags"><value>IMPORT ALIEN USESOPTIONS 3RDPARTYFILTER PREFERRED</value></prop>
+        <prop oor:name="UIComponent"/>
+        <prop oor:name="FilterService"><value>com.sun.star.comp.Draw.WPGImportFilter</value></prop>
+        <prop oor:name="UserData"><value></value></prop>
+        <prop oor:name="UIName">
+            <value xml:lang="x-default">WordPerfect Graphics</value>
+        </prop>
+        <prop oor:name="Installed"><value>true</value></prop>
+        <prop oor:name="FileFormatVersion"><value>0</value></prop>
+        <prop oor:name="Type"><value>draw_WordPerfect_Graphics</value></prop>
+        <prop oor:name="TemplateName"/>
+        <prop oor:name="DocumentService"><value>com.sun.star.drawing.DrawingDocument</value></prop>
+    </node>
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ filter/source/config/fragments/types/draw_WordPerfect_Graphics.xcu	2007-05-07 13:20:11.000000000 +0200
@@ -0,0 +1,12 @@
+		<node oor:name="draw_WordPerfect_Graphics" oor:op="replace" >
+			<prop oor:name="DetectService"><value>com.sun.star.comp.Draw.WPGImportFilter</value></prop>
+			<prop oor:name="URLPattern"/>
+			<prop oor:name="Extensions"><value>wpg</value></prop>
+			<prop oor:name="MediaType"><value>image/x-wpg</value></prop>
+			<prop oor:name="Preferred"><value>true</value></prop>
+			<prop oor:name="PreferredFilter"><value>WordPerfect Graphics</value></prop>
+			<prop oor:name="UIName">
+				<value>WordPerfect Graphics</value>
+			</prop>
+			<prop oor:name="ClipboardFormat"/>
+		</node>
--- filter/source/config/fragments/fcfg_draw.mk	14 Jul 2005 15:02:56 -0000	1.6
+++ filter/source/config/fragments/fcfg_draw.mk	7 May 2007 13:50:06 -0000
@@ -24,7 +24,8 @@
     draw_StarOffice_XML_Draw_Template \
     pdf_Portable_Document_Format\
     draw8 \
-    draw8_template
+    draw8_template \
+    draw_WordPerfect_Graphics
 
 # -----------------------------------------------
 # count = 9
@@ -34,7 +35,9 @@
     draw_StarOffice_XML_Draw_Template \
     draw_pdf_Export \
     draw8 \
-    draw8_template
+    draw8_template \
+    WordPerfectGraphics
+
 
 # -----------------------------------------------
 # count = 6
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ writerperfect/source/wpgimp/GraphicsElement.cxx	2007-05-07 13:59:43.000000000 +0200
@@ -0,0 +1,61 @@
+/* GraphicsElement: The items we are collecting to be put into the Writer
+ * document: paragraph and spans of text, as well as section breaks.
+ *
+ * Copyright (C) 2002-2003 William Lachance (william.lachance@sympatico.ca)
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the 
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
+ * Boston, MA  02111-1301 USA
+ *
+ * For further information visit http://libwpg.sourceforge.net
+ *
+ */
+
+/* "This product is not manufactured, approved, or supported by 
+ * Corel Corporation or Corel Corporation Limited."
+ */
+
+#include "GraphicsElement.hxx"
+#include "OOGraphicsHandler.hxx"
+#include <string.h>
+
+#define ASCII_SPACE 0x0020
+
+void TagGraphicsElement::print() const
+{
+}
+
+void OpenTagGraphicsElement::write(OOGraphicsHandler *pHandler) const
+{
+	pHandler->startElement(getTagName().c_str(), maAttrList);
+}
+
+void OpenTagGraphicsElement::print() const
+{ 
+	TagGraphicsElement::print(); 	
+}
+
+void OpenTagGraphicsElement::addAttribute(const std::string &szAttributeName, const std::string &sAttributeValue)
+{
+	std::pair<std::string, std::string> tmpAttribute;
+	tmpAttribute.first = szAttributeName;
+	tmpAttribute.second = sAttributeValue;
+    maAttrList.push_back(tmpAttribute);
+}
+
+void CloseTagGraphicsElement::write(OOGraphicsHandler *pHandler) const
+{
+
+	pHandler->endElement(getTagName().c_str());
+}
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ writerperfect/source/wpgimp/GraphicsElement.hxx	2007-05-07 15:01:27.000000000 +0200
@@ -0,0 +1,74 @@
+/* GraphicsElement: The items we are collecting to be put into the Writer
+ * document: paragraph and spans of text, as well as section breaks.
+ *
+ * Copyright (C) 2002-2003 William Lachance (william.lachance@sympatico.ca)
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the 
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
+ * Boston, MA  02111-1301 USA
+ *
+ * For further information visit http://libwpd.sourceforge.net
+ *
+ */
+
+/* "This product is not manufactured, approved, or supported by 
+ * Corel Corporation or Corel Corporation Limited."
+ */
+
+#ifndef _GRAPHICSELEMENT_H
+#define _GRAPHICSELEMENT_H
+#include <string>
+#include <map>
+#include <vector>
+
+#include "OOGraphicsHandler.hxx"
+
+class GraphicsElement
+{
+public:	
+	virtual ~GraphicsElement() {}
+	virtual void write(OOGraphicsHandler *pHandler) const = 0;
+	virtual void print() const {}
+};
+
+class TagGraphicsElement : public GraphicsElement
+{
+public:
+	explicit TagGraphicsElement(const char *szTagName) : msTagName(szTagName) {}
+	const std::string &getTagName() const { return msTagName; }
+	virtual void print() const;
+private:
+	const std::string msTagName;
+};
+
+class OpenTagGraphicsElement : public TagGraphicsElement
+{
+public:
+	explicit OpenTagGraphicsElement(const char *szTagName) : TagGraphicsElement(szTagName) {}
+	~OpenTagGraphicsElement() {}
+	void addAttribute(const std::string &szAttributeName, const std::string &sAttributeValue);
+	virtual void write(OOGraphicsHandler *pHandler) const;
+	virtual void print () const;
+private:
+	std::vector<std::pair<std::string, std::string> > maAttrList;
+};
+
+class CloseTagGraphicsElement : public TagGraphicsElement
+{
+public:
+	explicit CloseTagGraphicsElement(const char *szTagName) : TagGraphicsElement(szTagName) {}
+	virtual void write(OOGraphicsHandler *pHandler) const;
+};
+
+#endif
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ writerperfect/source/wpgimp/makefile.mk	2007-05-07 15:31:24.000000000 +0200
@@ -0,0 +1,37 @@
+PRJ=..$/..
+
+PRJNAME=writerperfect
+TARGET=wpgimp
+ENABLE_EXCEPTIONS=true
+
+.INCLUDE :  settings.mk
+
+.IF "$(SYSTEM_LIBWPD)" == "YES"
+INCPRE+=$(LIBWPD_CFLAGS)
+.ELSE
+INCPRE+=$(SOLARVER)$/$(UPD)$/$(INPATH)$/inc$/libwpd
+.ENDIF
+
+.IF "$(SYSTEM_LIBWPS)" == "YES"
+INCPRE+=$(LIBWPS_CFLAGS)
+.ELSE
+INCPRE+=$(SOLARVER)$/$(UPD)$/$(INPATH)$/inc$/libwps
+.ENDIF
+
+.IF "$(SYSTEM_LIBWPG)" == "YES"
+INCPRE+=$(LIBWPG_CFLAGS)
+.ELSE
+INCPRE+=$(SOLARVER)$/$(UPD)$/$(INPATH)$/inc$/libwpg
+.ENDIF
+
+# broken but ... necessary, internal include shafted ...
+INCPRE+= -I..
+
+SLOFILES= \
+    $(SLO)$/GraphicsElement.obj \
+    $(SLO)$/OdgExporter.obj  \
+    $(SLO)$/OOGraphicsHandler.obj  \
+    $(SLO)$/WPGImportFilter.obj \
+	$(SLO)$/wpgimport_genericfilter.obj		
+
+.INCLUDE :  target.mk
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ writerperfect/source/wpgimp/OdgExporter.cxx	2007-05-07 15:20:45.000000000 +0200
@@ -0,0 +1,497 @@
+/* libwpg
+ * Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+ * Copyright (C) 2006 Fridrich Strba (fridrich.strba@bluewin.ch)
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the 
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
+ * Boston, MA  02111-1301 USA
+ *
+ * For further information visit http://libwpg.sourceforge.net
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+
+#include "OdgExporter.hxx"
+#include "GraphicsElement.hxx"
+#include "OOGraphicsHandler.hxx"
+#include <locale>
+
+OdgExporter::OdgExporter(OOGraphicsHandler *pHandler):
+	mpHandler(pHandler),
+	m_fillRule(AlternatingFill),
+	m_gradientIndex(1),
+	m_dashIndex(1), 
+	m_styleIndex(1)
+{
+	m_value.imbue(std::locale("C"));
+	m_name.imbue(std::locale("C"));
+}
+
+OdgExporter::~OdgExporter()
+{}
+
+void OdgExporter::startDocument(double width, double height)
+{
+	m_gradientIndex = 1;
+	m_dashIndex = 1;
+	m_styleIndex = 1;
+
+	mpHandler->startDocument();
+	OpenTagGraphicsElement tmpOfficeDocumentContent("office:document");
+	tmpOfficeDocumentContent.addAttribute("xmlns:office", "urn:oasis:names:tc:opendocument:xmlns:office:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:style", "urn:oasis:names:tc:opendocument:xmlns:style:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:text", "urn:oasis:names:tc:opendocument:xmlns:text:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:draw", "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:dc", "http://purl.org/dc/elements/1.1/");
+	tmpOfficeDocumentContent.addAttribute("xmlns:svg", "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0");
+	tmpOfficeDocumentContent.addAttribute("xmlns:fo", "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0");
+	tmpOfficeDocumentContent.addAttribute("office:version", "1.0");	
+	tmpOfficeDocumentContent.write(mpHandler);
+
+	OpenTagGraphicsElement("office:styles").write(mpHandler);
+	CloseTagGraphicsElement("office:styles").write(mpHandler);
+	
+	OpenTagGraphicsElement("office:automatic-styles").write(mpHandler);
+
+	OpenTagGraphicsElement tmpStylePageLayoutOpenElement("style:page-layout");
+	tmpStylePageLayoutOpenElement.addAttribute("style:name", "PM0");
+	tmpStylePageLayoutOpenElement.write(mpHandler);
+
+	OpenTagGraphicsElement tmpStylePageLayoutPropertiesOpenElement("style:page-layout-properties");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-top", "0cm");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-bottom", "0cm");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-left", "0cm");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:margin-right", "0cm");
+	m_value.str("");
+	m_value << width * 2.54 << "cm";
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:page-width", m_value.str());
+	m_value.str("");
+	m_value << height * 2.54 << "cm";
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("fo:page-height", m_value.str());
+	m_value.str("");
+	tmpStylePageLayoutPropertiesOpenElement.addAttribute("style:print-orientation", "portrait");
+	tmpStylePageLayoutPropertiesOpenElement.write(mpHandler);
+
+	CloseTagGraphicsElement("style:page-layout-properties").write(mpHandler);
+
+	CloseTagGraphicsElement("style:page-layout").write(mpHandler);
+
+	OpenTagGraphicsElement tmpStyleStyleOpenElement("style:style");
+	tmpStyleStyleOpenElement.addAttribute("style:name", "dp1");
+	tmpStyleStyleOpenElement.addAttribute("style:family", "drawing-page");
+	tmpStyleStyleOpenElement.write(mpHandler);
+
+	OpenTagGraphicsElement tmpStyleDrawingPagePropertiesOpenElement("style:drawing-page-properties");
+	tmpStyleDrawingPagePropertiesOpenElement.addAttribute("draw:background-size", "border");
+	tmpStyleDrawingPagePropertiesOpenElement.addAttribute("draw:fill", "none");
+	tmpStyleDrawingPagePropertiesOpenElement.write(mpHandler);
+
+	CloseTagGraphicsElement("style:drawing-page-properties").write(mpHandler);
+
+	CloseTagGraphicsElement("style:style").write(mpHandler);
+}
+
+void OdgExporter::endDocument()
+{
+	CloseTagGraphicsElement("office:automatic-styles").write(mpHandler);
+
+	OpenTagGraphicsElement("office:master-styles").write(mpHandler);
+
+	OpenTagGraphicsElement tmpStyleMasterPageOpenElement("style:master-page");
+	tmpStyleMasterPageOpenElement.addAttribute("style:name", "Default");
+	tmpStyleMasterPageOpenElement.addAttribute("style:page-layout-name", "PM0");
+	tmpStyleMasterPageOpenElement.addAttribute("draw:style-name", "dp1");
+	tmpStyleMasterPageOpenElement.write(mpHandler);
+
+	CloseTagGraphicsElement("style:master-page").write(mpHandler);
+
+	CloseTagGraphicsElement("office:master-styles").write(mpHandler);
+
+	OpenTagGraphicsElement("office:body").write(mpHandler);
+
+	OpenTagGraphicsElement("office:drawing").write(mpHandler);
+
+	OpenTagGraphicsElement tmpDrawPageOpenElement("draw:page");
+	tmpDrawPageOpenElement.addAttribute("draw:name", "page1");
+	tmpDrawPageOpenElement.addAttribute("draw:style-name", "dp1");
+	tmpDrawPageOpenElement.addAttribute("draw:master-page-name", "Default");
+	tmpDrawPageOpenElement.write(mpHandler);
+
+	for (std::vector<GraphicsElement *>::const_iterator bodyIter = mpBodyElements.begin();
+		bodyIter != mpBodyElements.end(); bodyIter++)
+	{
+		(*bodyIter)->write(mpHandler);
+	}	
+
+	CloseTagGraphicsElement("draw:page").write(mpHandler);
+	CloseTagGraphicsElement("office:drawing").write(mpHandler);
+	CloseTagGraphicsElement("office:body").write(mpHandler);
+	CloseTagGraphicsElement("office:document").write(mpHandler);
+
+	mpHandler->endDocument();
+}
+
+void OdgExporter::setPen(const libwpg::WPGPen& pen)
+{
+	m_pen = pen;
+}
+
+void OdgExporter::setBrush(const libwpg::WPGBrush& brush)
+{
+	m_brush = brush;
+}
+
+void OdgExporter::setFillRule(FillRule rule)
+{
+	m_fillRule = rule;
+}
+
+void OdgExporter::startLayer(unsigned int /* id */)
+{
+}
+
+void OdgExporter::endLayer(unsigned int)
+{
+}
+
+void OdgExporter::drawRectangle(const libwpg::WPGRect& rect, double rx, double /* ry */)
+{
+	writeStyle();
+	OpenTagGraphicsElement *pDrawRectElement = new OpenTagGraphicsElement("draw:rect");
+	m_value.str("");
+	m_value << "gr" << m_styleIndex-1;
+	pDrawRectElement->addAttribute("draw:style-name", m_value.str());
+	m_value.str("");
+	m_value << rect.x1 * 2.54 << "cm";
+	pDrawRectElement->addAttribute("svg:x", m_value.str());
+	m_value.str("");
+	m_value << rect.y1 * 2.54 << "cm";
+	pDrawRectElement->addAttribute("svg:y", m_value.str());
+	m_value.str("");
+	m_value << (rect.x2-rect.x1) * 2.54 << "cm";
+	pDrawRectElement->addAttribute("svg:width", m_value.str());
+	m_value.str("");
+	m_value << (rect.y2-rect.y1) * 2.54 << "cm";
+	pDrawRectElement->addAttribute("svg:height", m_value.str());
+	m_value.str("");
+	m_value << rx * 2.54 << "cm";
+	// FIXME: what to do when rx != ry ?
+	pDrawRectElement->addAttribute("draw:corner-radius", m_value.str());
+	m_value.str("");
+	mpBodyElements.push_back(static_cast<GraphicsElement *>(pDrawRectElement));
+	mpBodyElements.push_back(static_cast<GraphicsElement *>(new CloseTagGraphicsElement("draw:rect")));	
+}
+
+void OdgExporter::drawEllipse(const libwpg::WPGPoint& center, double rx, double ry)
+{
+	writeStyle();
+	OpenTagGraphicsElement *pDrawEllipseElement = new OpenTagGraphicsElement("draw:ellipse");
+	m_value.str("");
+	m_value << "gr" << m_styleIndex-1;
+	pDrawEllipseElement->addAttribute("draw:style-name", m_value.str());
+	m_value.str("");
+	m_value << (center.x-rx) * 2.54 << "cm";
+	pDrawEllipseElement->addAttribute("svg:x", m_value.str());
+	m_value.str("");
+	m_value << (center.y-ry) * 2.54 << "cm";
+	pDrawEllipseElement->addAttribute("svg:y", m_value.str());
+	m_value.str("");
+	m_value <<  2* rx * 2.54 << "cm";
+	pDrawEllipseElement->addAttribute("svg:width", m_value.str());
+	m_value.str("");
+	m_value << 2 * ry * 2.54 << "cm";
+	pDrawEllipseElement->addAttribute("svg:height", m_value.str());
+	m_value.str("");	
+	mpBodyElements.push_back(static_cast<GraphicsElement *>(pDrawEllipseElement));
+	mpBodyElements.push_back(static_cast<GraphicsElement *>(new CloseTagGraphicsElement("draw:ellipse")));
+}
+
+void OdgExporter::drawPolygon(const libwpg::WPGPointArray& vertices)
+{
+	if(vertices.count() < 2)
+		return;
+
+	if(vertices.count() == 2)
+	{
+		const libwpg::WPGPoint& p1 = vertices[0];
+		const libwpg::WPGPoint& p2 = vertices[1];
+
+		writeStyle();
+		OpenTagGraphicsElement *pDrawLineElement = new OpenTagGraphicsElement("draw:line");
+		m_value.str("");
+		m_value << "gr" << m_styleIndex-1;
+		pDrawLineElement->addAttribute("draw:style-name", m_value.str());
+		m_value.str("");
+		pDrawLineElement->addAttribute("draw:text-style-name", "P1");
+		pDrawLineElement->addAttribute("draw:layer", "layout");
+		m_value << p1.x * 2.54 << "cm";
+		pDrawLineElement->addAttribute("svg:x1", m_value.str());
+		m_value.str("");
+		m_value << p1.y * 2.54 << "cm";
+		pDrawLineElement->addAttribute("svg:y1", m_value.str());
+		m_value.str("");
+		m_value  << p2.x * 2.54 << "cm";
+		pDrawLineElement->addAttribute("svg:x2", m_value.str());
+		m_value.str("");
+		m_value << p2.y * 2.54 << "cm";
+		pDrawLineElement->addAttribute("svg:y2", m_value.str());
+		m_value.str("");
+		mpBodyElements.push_back(static_cast<GraphicsElement *>(pDrawLineElement));
+		mpBodyElements.push_back(static_cast<GraphicsElement *>(new CloseTagGraphicsElement("draw:line")));
+	}
+	else
+	{
+		// draw as path
+		libwpg::WPGPath path;
+		path.moveTo(vertices[0]);
+		for(unsigned long ii = 1; ii < vertices.count(); ii++)
+			path.lineTo(vertices[ii]);
+		path.closed = true;
+		drawPath(path);
+	}
+}
+
+void OdgExporter::drawPath(const libwpg::WPGPath& path)
+{
+	if(path.count() == 0)
+		return;
+
+	// try to find the bounding box
+	// this is simple convex hull technique, the bounding box might not be
+	// accurate but that should be enough for this purpose
+	libwpg::WPGPoint p = path.element(0).point;
+	libwpg::WPGPoint q = path.element(0).point;
+	for(unsigned k = 0; k < path.count(); k++)
+	{
+		libwpg::WPGPathElement element = path.element(k);
+		p.x = (p.x > element.point.x) ? element.point.x : p.x; 
+		p.y = (p.y > element.point.y) ? element.point.y : p.y; 
+		q.x = (q.x < element.point.x) ? element.point.x : q.x; 
+		q.y = (q.y < element.point.y) ? element.point.y : q.y; 
+		if(element.type == libwpg::WPGPathElement::CurveToElement)
+		{
+			p.x = (p.x > element.extra1.x) ? element.extra1.x : p.x; 
+			p.y = (p.y > element.extra1.y) ? element.extra1.y : p.y; 
+			q.x = (q.x < element.extra1.x) ? element.extra1.x : q.x; 
+			q.y = (q.y < element.extra1.y) ? element.extra1.y : q.y; 
+			p.x = (p.x > element.extra2.x) ? element.extra2.x : p.x; 
+			p.y = (p.y > element.extra2.y) ? element.extra2.y : p.y; 
+			q.x = (q.x < element.extra2.x) ? element.extra2.x : q.x; 
+			q.y = (q.y < element.extra2.y) ? element.extra2.y : q.y; 
+		}
+	}
+	double vw = q.x - p.x;
+	double vh = q.y - p.y;
+		
+	writeStyle();
+
+	OpenTagGraphicsElement *pDrawPathElement = new OpenTagGraphicsElement("draw:path");
+	m_value.str("");
+	m_value << "gr" << m_styleIndex-1;
+	pDrawPathElement->addAttribute("draw:style-name", m_value.str());
+	m_value.str("");
+	pDrawPathElement->addAttribute("draw:text-style-name", "P1");
+	pDrawPathElement->addAttribute("draw:layer", "layout");
+	m_value << p.x * 2.54 << "cm";
+	pDrawPathElement->addAttribute("svg:x", m_value.str());
+	m_value.str("");
+	m_value << p.y * 2.54 << "cm";
+	pDrawPathElement->addAttribute("svg:y", m_value.str());
+	m_value.str("");
+	m_value << vw * 2.54 << "cm";
+	pDrawPathElement->addAttribute("svg:width", m_value.str());
+	m_value.str("");
+	m_value << vh * 2.54 << "cm";
+	pDrawPathElement->addAttribute("svg:height", m_value.str());
+	m_value.str("");
+	m_value << "0 0 " << (int)(vw*2540) << " " << (int)(vh*2540);
+	pDrawPathElement->addAttribute("svg:viewBox", m_value.str());
+	m_value.str("");
+
+	for(unsigned i = 0; i < path.count(); i++)
+	{
+		libwpg::WPGPathElement element = path.element(i);
+		libwpg::WPGPoint point = element.point;
+		switch(element.type)
+		{
+			// 2540 is 2.54*1000, 2.54 cm = 1 inch
+			case libwpg::WPGPathElement::MoveToElement:
+				m_value << "M" << (int)((point.x-p.x)*2540) << " ";
+				m_value << (int)((point.y-p.y)*2540);
+				break;
+				
+			case libwpg::WPGPathElement::LineToElement:
+				m_value << "L" << (int)((point.x-p.x)*2540) << " ";
+				m_value << (int)((point.y-p.y)*2540);
+				break;
+			
+			case libwpg::WPGPathElement::CurveToElement:
+				m_value << "C" << (int)((element.extra1.x-p.x)*2540) << " ";
+				m_value << (int)((element.extra1.y-p.y)*2540) << " ";
+				m_value << (int)((element.extra2.x-p.x)*2540) << " ";
+				m_value << (int)((element.extra2.y-p.y)*2540) << " ";
+				m_value << (int)((point.x-p.x)*2540) << " ";
+				m_value << (int)((point.y-p.y)*2540);
+				break;
+			
+			default:
+				break;
+		}
+	}
+	if(path.closed)
+		m_value << " Z";
+	pDrawPathElement->addAttribute("svg:d", m_value.str());
+	m_value.str("");
+	mpBodyElements.push_back(static_cast<GraphicsElement *>(pDrawPathElement));
+	mpBodyElements.push_back(static_cast<GraphicsElement *>(new CloseTagGraphicsElement("draw:path")));
+}
+
+static std::string colorToHex(const libwpg::WPGColor& color)
+{
+	char hexdigits[] = "0123456789abcdef";
+	char buffer[] = "123456";
+	buffer[0] = hexdigits[(color.red >> 4) & 15];
+	buffer[1] = hexdigits[color.red & 15];
+	buffer[2] = hexdigits[(color.green >> 4) & 15];
+	buffer[3] = hexdigits[color.green & 15];
+	buffer[4] = hexdigits[(color.blue >> 4) & 15];
+	buffer[5] = hexdigits[color.blue & 15];
+	return std::string(buffer);
+}
+
+void OdgExporter::writeStyle()
+{
+	m_value.str("");
+	m_name.str("");
+
+	if(!m_pen.solid && (m_pen.dashArray.count() >=2 ) )
+	{
+		// ODG only supports dashes with the same length of spaces inbetween
+		// here we take the first space and assume everything else the same
+		// note that dash length is written in percentage
+		double distance = m_pen.dashArray.at(1);
+		OpenTagGraphicsElement tmpDrawStrokeDashElement("draw:stroke-dash");
+		tmpDrawStrokeDashElement.addAttribute("draw:style", "rect");
+		m_value << "Dash_" << m_dashIndex++;
+		tmpDrawStrokeDashElement.addAttribute("draw:name", m_value.str());
+		m_value.str("");
+		m_value << distance*100 << "%";
+		tmpDrawStrokeDashElement.addAttribute("draw:distance", m_value.str());
+		m_value.str("");
+		for(unsigned i = 0; i < m_pen.dashArray.count()/2; i++)
+		{
+			m_name << "draw:dots" << i+1;
+			tmpDrawStrokeDashElement.addAttribute(m_name.str(), "1");
+			m_name.str("");
+			m_name << "draw:dots" << i+1 << "-length";
+			m_value << 100*m_pen.dashArray.at(i*2) << "%";
+			tmpDrawStrokeDashElement.addAttribute(m_name.str(), m_value.str());
+			m_name.str("");
+			m_value.str("");
+		}
+		tmpDrawStrokeDashElement.write(mpHandler);
+		CloseTagGraphicsElement("draw:stroke-dash").write(mpHandler);
+	}
+
+	if(m_brush.style == libwpg::WPGBrush::Gradient)
+	{
+		OpenTagGraphicsElement tmpDrawGradientElement("draw:gradient");
+		tmpDrawGradientElement.addAttribute("draw:style", "linear");
+		m_value << "Gradient_" << m_gradientIndex++;
+		tmpDrawGradientElement.addAttribute("draw:name", m_value.str());
+		m_value.str("");
+
+		// ODG angle unit is 0.1 degree
+		double angle = -m_brush.gradient.angle();
+		while(angle < 0)
+			angle += 360;
+		while(angle > 360)
+			angle -= 360;
+
+		m_value << angle*10;
+		tmpDrawGradientElement.addAttribute("draw:angle", m_value.str());
+		m_value.str("");
+
+		libwpg::WPGColor startColor = m_brush.gradient.stopColor(0);
+		libwpg::WPGColor stopColor = m_brush.gradient.stopColor(1);
+		m_value << "#" << colorToHex(startColor);
+		tmpDrawGradientElement.addAttribute("draw:start-color", m_value.str());
+		m_value.str("");
+		m_value << "#" << colorToHex(stopColor);
+		tmpDrawGradientElement.addAttribute("draw:end-color", m_value.str());
+		m_value.str("");
+		tmpDrawGradientElement.addAttribute("draw:start-intensity", "100%");
+		tmpDrawGradientElement.addAttribute("draw:end-intensity", "100%");
+		tmpDrawGradientElement.addAttribute("draw:border", "0%");
+		tmpDrawGradientElement.write(mpHandler);
+		CloseTagGraphicsElement("draw:gradient").write(mpHandler);
+	}
+
+	OpenTagGraphicsElement tmpStyleStyleElement("style:style");
+	m_value << "gr" << m_styleIndex;
+	tmpStyleStyleElement.addAttribute("style:name", m_value.str());
+	m_value.str("");
+	tmpStyleStyleElement.addAttribute("style:family", "graphic");
+	tmpStyleStyleElement.addAttribute("style:parent-style-name", "standard");
+	tmpStyleStyleElement.write(mpHandler);
+
+	OpenTagGraphicsElement tmpStyleGraphicPropertiesElement("style:graphic-properties");
+
+	if(m_pen.width > 0.0)
+	{
+		m_value << m_pen.width * 2.54 << "cm";
+		tmpStyleGraphicPropertiesElement.addAttribute("svg:stroke-width", m_value.str());
+		m_value.str("");
+		m_value << "#" << colorToHex(m_pen.foreColor);
+		tmpStyleGraphicPropertiesElement.addAttribute("svg:stroke-color", m_value.str());
+		m_value.str("");
+
+		if(!m_pen.solid)
+		{
+			tmpStyleGraphicPropertiesElement.addAttribute("draw:stroke", "dash");
+			m_value << "Dash_" << m_dashIndex-1;
+			tmpStyleGraphicPropertiesElement.addAttribute("draw:stroke-dash", m_value.str());
+			m_value.str("");
+		}
+	}
+	else
+		tmpStyleGraphicPropertiesElement.addAttribute("draw:stroke", "none");
+
+	if(m_brush.style == libwpg::WPGBrush::NoBrush)
+		tmpStyleGraphicPropertiesElement.addAttribute("draw:fill", "none");
+
+	if(m_brush.style == libwpg::WPGBrush::Solid)
+	{
+		tmpStyleGraphicPropertiesElement.addAttribute("draw:fill", "solid");
+		m_value << "#" << colorToHex(m_brush.foreColor);
+		tmpStyleGraphicPropertiesElement.addAttribute("draw:fill-color", m_value.str());
+		m_value.str("");
+	}
+
+	if(m_brush.style == libwpg::WPGBrush::Gradient)
+	{
+		tmpStyleGraphicPropertiesElement.addAttribute("draw:fill", "gradient");
+		m_value << "Gradient_" << m_gradientIndex-1;
+		tmpStyleGraphicPropertiesElement.addAttribute("draw:fill-gradient-name", m_value.str());
+		m_value.str("");
+	}
+
+	tmpStyleGraphicPropertiesElement.write(mpHandler);
+	CloseTagGraphicsElement("style:graphic-properties").write(mpHandler);
+
+	CloseTagGraphicsElement("style:style").write(mpHandler);
+	m_styleIndex++;
+}
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ writerperfect/source/wpgimp/OdgExporter.hxx	2007-05-07 15:16:44.000000000 +0200
@@ -0,0 +1,71 @@
+/* libwpg
+ * Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the 
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
+ * Boston, MA  02111-1301 USA
+ *
+ * For further information visit http://libwpg.sourceforge.net
+ */
+
+/* "This product is not manufactured, approved, or supported by
+ * Corel Corporation or Corel Corporation Limited."
+ */
+
+#ifndef __ODGEXPORTER_H__
+#define __ODGEXPORTER_H__
+
+#include <iostream>
+#include <sstream>
+#include <string>
+
+#include <libwpg/libwpg.h>
+#include "GraphicsElement.hxx"
+#include "OOGraphicsHandler.hxx"
+
+class OdgExporter : public libwpg::WPGPaintInterface {
+public:
+	OdgExporter(OOGraphicsHandler *pHandler);
+	~OdgExporter();
+
+	void startDocument(double imageWidth, double imageHeight);
+	void endDocument();
+	void startLayer(unsigned int id);
+	void endLayer(unsigned int id);
+
+	void setPen(const libwpg::WPGPen& pen);
+	void setBrush(const libwpg::WPGBrush& brush);
+	void setFillRule(FillRule rule);
+
+	void drawRectangle(const libwpg::WPGRect& rect, double rx, double ry);
+	void drawEllipse(const libwpg::WPGPoint& center, double rx, double ry);
+	void drawPolygon(const libwpg::WPGPointArray& vertices);
+	void drawPath(const libwpg::WPGPath& path);
+
+private:
+	std::vector <GraphicsElement *> mpBodyElements;
+	std::vector <GraphicsElement *> mpStylesElements;
+	OOGraphicsHandler *mpHandler;
+
+	libwpg::WPGPen m_pen;
+	libwpg::WPGBrush m_brush;
+	FillRule m_fillRule;
+	int m_gradientIndex;
+	int m_dashIndex;
+	int m_styleIndex;
+	void writeStyle();
+	std::ostringstream m_value, m_name;
+};
+
+#endif // __ODGEXPORTER_H__
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ writerperfect/source/wpgimp/OOGraphicsHandler.cxx	2007-05-07 15:05:50.000000000 +0200
@@ -0,0 +1,80 @@
+/* 
+ * Copyright (C) 2004 William Lachance (william.lachance@sympatico.ca)
+ * Copyright (C) 2004 Net Integration Technologies (http://www.net-itech.com)
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+  *
+ * For further information visit http://libwpd.sourceforge.net
+ *
+ */
+#include "OOGraphicsHandler.hxx"
+#include <string.h>
+
+#ifndef _COM_SUN_STAR_XML_SAX_XDOCUMENTHANDLER_HPP_
+#include <com/sun/star/xml/sax/XDocumentHandler.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_XML_SAX_XATTRIBUTELIST_HPP_
+#include <com/sun/star/xml/sax/XAttributeList.hpp>
+#endif
+
+#ifndef _ATTRLIST_HPP_
+#include <xmloff/attrlist.hxx>
+#endif
+
+using namespace ::rtl;
+using rtl::OUString;
+
+using com::sun::star::xml::sax::XAttributeList;
+
+OOGraphicsHandler::OOGraphicsHandler(Reference < XDocumentHandler > &xHandler) :
+	mxHandler(xHandler)
+{
+}
+
+void OOGraphicsHandler::startDocument() 
+{
+	mxHandler->startDocument();
+}
+
+void OOGraphicsHandler::endDocument()
+{
+	mxHandler->endDocument();
+}
+
+void OOGraphicsHandler::startElement(const char *psName, const std::vector< std::pair <std::string, std::string> > &xPropList)
+{
+	SvXMLAttributeList *pAttrList = new SvXMLAttributeList();
+	Reference < XAttributeList > xAttrList(pAttrList);
+	for (std::vector<std::pair<std::string,std::string> >::const_iterator Iter = xPropList.begin();
+		Iter != xPropList.end(); Iter++)
+	{
+		pAttrList->AddAttribute(OUString::createFromAscii((*Iter).first.c_str()),
+			OUString::createFromAscii((*Iter).second.c_str()));
+	}
+
+	mxHandler->startElement(OUString::createFromAscii(psName), xAttrList);
+}
+
+void OOGraphicsHandler::endElement(const char *psName)
+{
+	mxHandler->endElement(OUString::createFromAscii(psName));
+}
+
+void OOGraphicsHandler::characters(const std::string &sCharacters)
+{
+	OUString sCharU16(sCharacters.c_str(), strlen(sCharacters.c_str()), RTL_TEXTENCODING_UTF8);
+	mxHandler->characters(sCharU16);
+}
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ writerperfect/source/wpgimp/OOGraphicsHandler.hxx	2007-05-07 15:04:00.000000000 +0200
@@ -0,0 +1,30 @@
+#ifndef _OOGRAPHICSHANDLER_H
+#define _OOGRAPHICSHANDLER_H
+
+#ifndef _COM_SUN_STAR_XML_SAX_XDOCUMENTHANDLER_HPP_
+#include <com/sun/star/xml/sax/XDocumentHandler.hpp>
+#endif
+
+#include <string>
+#include <map>
+#include <vector>
+
+using com::sun::star::uno::Reference;
+using com::sun::star::xml::sax::XDocumentHandler;
+
+class OOGraphicsHandler
+{ 
+public:
+        OOGraphicsHandler(Reference < XDocumentHandler > &xHandler);
+        virtual ~OOGraphicsHandler() {}
+        virtual void startDocument();
+        virtual void endDocument();
+        virtual void startElement(const char *psName, const std::vector< std::pair <std::string, std::string> > &xPropList);
+        virtual void endElement(const char *psName);
+        virtual void characters(const std::string &sCharacters);
+
+private:
+        Reference < XDocumentHandler > mxHandler;
+};
+
+#endif // _OOGRAPHICSHANDLER_H
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ writerperfect/source/wpgimp/WPGImportFilter.cxx	2007-05-07 15:30:43.000000000 +0200
@@ -0,0 +1,332 @@
+/* WPGImportFilter: Sets up the filter, and calls OdgExporter
+ * to do the actual filtering
+ *
+ * Copyright (C) 2000 by Sun Microsystems, Inc.
+ * Copyright (C) 2002-2004 William Lachance (wlach@interlog.com)
+ * Copyright (C) 2004 Net Integration Technologies (http://www.net-itech.com)
+ * Copyright (C) 2004-2006 Fridrich Strba <fridrich.strba@bluewin.ch>
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
+ * 02111-1307, USA.
+ *
+ *  Contributor(s): Martin Gallwey (gallwey@sun.com)
+ *
+ */
+
+/* "This product is not manufactured, approved, or supported by 
+ * Corel Corporation or Corel Corporation Limited."
+ */
+
+#ifndef _OSL_DIAGNOSE_H_
+#include <osl/diagnose.h>
+#endif
+#ifndef _RTL_TENCINFO_H_
+#include <rtl/tencinfo.h>
+#endif
+#ifndef _COM_SUN_STAR_LANG_XMULTISERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XINPUTSTREAM_HPP_
+#include <com/sun/star/io/XInputStream.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_XATTRIBUTELIST_HPP_
+#include <com/sun/star/xml/sax/XAttributeList.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_XDOCUMENTHANDLER_HPP_
+#include <com/sun/star/xml/sax/XDocumentHandler.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_INPUTSOURCE_HPP_
+#include <com/sun/star/xml/sax/InputSource.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_XPARSER_HPP_
+#include <com/sun/star/xml/sax/XParser.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_LANG_XMULTISERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XINPUTSTREAM_HPP_
+#include <com/sun/star/io/XInputStream.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_IO_XSEEKABLE_HPP_
+#include <com/sun/star/io/XSeekable.hpp>
+#endif
+
+#include <com/sun/star/uno/Reference.h>
+
+#ifndef _ATTRLIST_HPP_
+#include <xmloff/attrlist.hxx>
+#endif
+#ifndef _XMLKYWD_HPP
+#include <xmloff/xmlkywd.hxx>
+#endif
+
+#include "OOGraphicsHandler.hxx"
+#include "OdgExporter.hxx"
+#include "WPGImportFilter.hxx"
+#include "stream/WPXSvStream.h"
+
+#include <iostream>
+
+using namespace ::com::sun::star::uno;
+using com::sun::star::uno::Reference;
+using com::sun::star::io::XInputStream;
+using com::sun::star::io::XSeekable;
+using com::sun::star::uno::Sequence;
+using namespace ::rtl;
+using rtl::OString;
+using rtl::OUString;
+using com::sun::star::uno::Sequence;
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::Any;
+using com::sun::star::uno::UNO_QUERY;
+using com::sun::star::uno::XInterface;
+using com::sun::star::uno::Exception;
+using com::sun::star::uno::RuntimeException;
+using com::sun::star::lang::XMultiServiceFactory;
+using com::sun::star::beans::PropertyValue;
+using com::sun::star::document::XFilter;
+using com::sun::star::document::XExtendedFilterDetection;
+
+using com::sun::star::io::XInputStream;
+using com::sun::star::document::XImporter;
+using com::sun::star::xml::sax::InputSource;
+using com::sun::star::xml::sax::XAttributeList;
+using com::sun::star::xml::sax::XDocumentHandler;
+using com::sun::star::xml::sax::XParser;
+
+
+sal_Bool SAL_CALL WPGImportFilter::filter( const Sequence< ::com::sun::star::beans::PropertyValue >& aDescriptor ) 
+	throw (RuntimeException)
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter::filter" << std::endl;
+#endif
+	sal_Int32 nLength = aDescriptor.getLength();
+	const PropertyValue * pValue = aDescriptor.getConstArray();
+	OUString sURL;
+	Reference < XInputStream > xInputStream;
+	for ( sal_Int32 i = 0 ; i < nLength; i++)
+	{
+		if ( pValue[i].Name.equalsAsciiL ( RTL_CONSTASCII_STRINGPARAM ( "InputStream" ) ) )
+		pValue[i].Value >>= xInputStream;
+		else if ( pValue[i].Name.equalsAsciiL ( RTL_CONSTASCII_STRINGPARAM ( "URL" ) ) )
+		pValue[i].Value >>= sURL;
+	}
+	if ( !xInputStream.is() )
+	{
+		OSL_ASSERT( 0 );
+		return sal_False;
+	}
+	OString sFileName;
+	sFileName = OUStringToOString(sURL, RTL_TEXTENCODING_INFO_ASCII);
+
+	// An XML import service: what we push sax messages to..
+	OUString sXMLImportService ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Draw.XMLOasisImporter" ) );
+	Reference < XDocumentHandler > xInternalHandler( mxMSF->createInstance( sXMLImportService ), UNO_QUERY );
+
+	// The XImporter sets up an empty target document for XDocumentHandler to write to.. 
+	Reference < XImporter > xImporter(xInternalHandler, UNO_QUERY);
+	xImporter->setTargetDocument( mxDoc );
+
+	// OO Graphics Handler: abstract class to handle document SAX messages, concrete implementation here
+	// writes to in-memory target doc
+	OOGraphicsHandler xHandler(xInternalHandler);
+
+	WPXInputStream* input = new WPXSvInputStream( xInputStream );
+
+	if (input->isOLEStream())
+	{
+		WPXInputStream* olestream = input->getDocumentOLEStream();
+		if (olestream)
+		{
+			delete input;
+			input = olestream;
+		}
+	}
+
+	OdgExporter exporter(&xHandler);
+	bool tmpParseResult = libwpg::WPGraphics::parse(input, &exporter);
+	if (input)
+		delete input;
+	xInputStream->closeInput();
+	return tmpParseResult;
+}
+
+void SAL_CALL WPGImportFilter::cancel(  ) 
+	throw (RuntimeException)
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter::cancel" << std::endl;
+#endif
+}
+
+// XImporter
+void SAL_CALL WPGImportFilter::setTargetDocument( const Reference< ::com::sun::star::lang::XComponent >& xDoc )
+	throw (::com::sun::star::lang::IllegalArgumentException, RuntimeException)
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter::setTargetDocument" << std::endl;
+#endif
+	meType = FILTER_IMPORT;
+	mxDoc = xDoc;
+}
+
+// XExtendedFilterDetection
+OUString SAL_CALL WPGImportFilter::detect( com::sun::star::uno::Sequence< PropertyValue >& Descriptor )
+	throw( com::sun::star::uno::RuntimeException )
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter::detect" << std::endl;
+#endif
+	OUString sTypeName = OUString( RTL_CONSTASCII_USTRINGPARAM ( "" ) );
+	sal_Int32 nLength = Descriptor.getLength();
+	sal_Int32 location = nLength;
+	const PropertyValue * pValue = Descriptor.getConstArray();
+	Reference < XInputStream > xInputStream;
+	for ( sal_Int32 i = 0 ; i < nLength; i++)
+	{
+		if ( pValue[i].Name.equalsAsciiL ( RTL_CONSTASCII_STRINGPARAM ( "TypeName" ) ) )
+			location=i;
+		else if ( pValue[i].Name.equalsAsciiL ( RTL_CONSTASCII_STRINGPARAM ( "InputStream" ) ) )
+			pValue[i].Value >>= xInputStream;
+    }
+    
+	WPXInputStream* input = new WPXSvInputStream( xInputStream );
+
+	if (input->isOLEStream())
+	{
+		WPXInputStream* olestream = input->getDocumentOLEStream();
+		if (olestream)
+		{
+			delete input;
+			input = olestream;
+		}
+	}
+
+	if (libwpg::WPGraphics::isSupported(input))
+		sTypeName = OUString( RTL_CONSTASCII_USTRINGPARAM ( "draw_WordPerfect_Graphics" ) );
+
+	if (input)
+		delete input;
+
+	if (!sTypeName.equalsAscii(""))
+	{
+		if ( location == Descriptor.getLength() )
+		{
+			Descriptor.realloc(nLength+1);
+			Descriptor[location].Name = ::rtl::OUString::createFromAscii( "TypeName" );
+		}
+
+		Descriptor[location].Value <<=sTypeName;
+	}
+	return sTypeName;		
+}
+
+
+// XInitialization
+void SAL_CALL WPGImportFilter::initialize( const Sequence< Any >& aArguments ) 
+	throw (Exception, RuntimeException)
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter::initialize" << std::endl;
+#endif
+	Sequence < PropertyValue > aAnySeq;
+	sal_Int32 nLength = aArguments.getLength();
+	if ( nLength && ( aArguments[0] >>= aAnySeq ) )
+	{
+		const PropertyValue * pValue = aAnySeq.getConstArray();
+		nLength = aAnySeq.getLength();
+		for ( sal_Int32 i = 0 ; i < nLength; i++)
+		{
+			if ( pValue[i].Name.equalsAsciiL ( RTL_CONSTASCII_STRINGPARAM ( "Type" ) ) )
+			{
+				pValue[i].Value >>= msFilterName;
+				break;
+			}
+		}
+	}
+}
+OUString WPGImportFilter_getImplementationName ()
+	throw (RuntimeException)
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter_getImplementationName" << std::endl;
+#endif
+	return OUString ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.comp.Draw.WPGImportFilter" ) );
+}
+
+#define SERVICE_NAME1 "com.sun.star.document.ImportFilter"
+#define SERVICE_NAME2 "com.sun.star.document.ExtendedTypeDetection"
+sal_Bool SAL_CALL WPGImportFilter_supportsService( const OUString& ServiceName ) 
+	throw (RuntimeException)
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter_supportsService" << std::endl;
+#endif
+	return (ServiceName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM ( SERVICE_NAME1 ) ) ||
+		ServiceName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM ( SERVICE_NAME2 ) ) );
+}
+Sequence< OUString > SAL_CALL WPGImportFilter_getSupportedServiceNames(  ) 
+	throw (RuntimeException)
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter_getSupportedServiceNames" << std::endl;
+#endif
+	Sequence < OUString > aRet(2);
+	OUString* pArray = aRet.getArray();
+	pArray[0] =  OUString ( RTL_CONSTASCII_USTRINGPARAM ( SERVICE_NAME1 ) );
+	pArray[1] =  OUString ( RTL_CONSTASCII_USTRINGPARAM ( SERVICE_NAME2 ) ); 
+	return aRet;
+}
+#undef SERVICE_NAME2
+#undef SERVICE_NAME1
+
+Reference< XInterface > SAL_CALL WPGImportFilter_createInstance( const Reference< XMultiServiceFactory > & rSMgr)
+	throw( Exception )
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter_createInstance" << std::endl;
+#endif
+	return (cppu::OWeakObject*) new WPGImportFilter( rSMgr );
+}
+
+// XServiceInfo
+OUString SAL_CALL WPGImportFilter::getImplementationName(  ) 
+	throw (RuntimeException)
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter::getImplementationName" << std::endl;
+#endif
+	return WPGImportFilter_getImplementationName();
+}
+sal_Bool SAL_CALL WPGImportFilter::supportsService( const OUString& rServiceName ) 
+	throw (RuntimeException)
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter::supportsService" << std::endl;
+#endif
+	return WPGImportFilter_supportsService( rServiceName );
+}
+Sequence< OUString > SAL_CALL WPGImportFilter::getSupportedServiceNames(  ) 
+	throw (RuntimeException)
+{
+#ifdef DEBUG
+	std::cerr << "WPGImportFilter::getSupportedServiceNames" << std::endl;
+#endif
+	return WPGImportFilter_getSupportedServiceNames();
+}
+
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ writerperfect/source/wpgimp/WPGImportFilter.hxx	2007-05-07 13:54:21.000000000 +0200
@@ -0,0 +1,128 @@
+/* 
+ * Copyright (C) 2000 by Sun Microsystems, Inc.
+ * Copyright (C) 2002-2004 William Lachance (wlach@interlog.com)
+ * Copyright (C) 2004 Net Integration Technologies (http://www.net-itech.com)
+ * Copyright (C) 2004 Fridrich Strba <fridrich.strba@bluewin.ch>
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
+ * 02111-1307, USA.
+ *
+ *  Contributor(s): Martin Gallwey (gallwey@sun.com)
+ *
+ */
+
+/* "This product is not manufactured, approved, or supported by 
+ * Corel Corporation or Corel Corporation Limited."
+ */
+#ifndef _WPGIMPORTFILTER_HXX
+#define _WPGIMPORTFILTER_HXX
+
+#ifndef _COM_SUN_STAR_DOCUMENT_XFILTER_HPP_
+#include <com/sun/star/document/XFilter.hpp>
+#endif
+#ifndef _COM_SUN_STAR_DOCUMENT_XIMPORTER_HPP_
+#include <com/sun/star/document/XImporter.hpp>
+#endif
+#ifndef _COM_SUN_STAR_DOCUMENT_XEXTENDEDFILTERDETECTION_HPP_
+#include <com/sun/star/document/XExtendedFilterDetection.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_XINITIALIZATION_HPP_
+#include <com/sun/star/lang/XInitialization.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_XSERVICEINFO_HPP_
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#endif
+#ifndef _COM_SUN_STAR_XML_SAX_XDOCUMENTHANDLER_HPP_
+#include <com/sun/star/xml/sax/XDocumentHandler.hpp>
+#endif
+#ifndef _CPPUHELPER_IMPLBASE5_HXX_
+#include <cppuhelper/implbase5.hxx>
+#endif
+
+#include <stdio.h>
+
+enum FilterType 
+{
+	FILTER_IMPORT,
+	FILTER_EXPORT
+};
+/* This component will be instantiated for both import or export. Whether it calls
+ * setSourceDocument or setTargetDocument determines which Impl function the filter
+ * member calls */
+class WPGImportFilter : public cppu::WeakImplHelper5 
+< 
+	com::sun::star::document::XFilter,
+	com::sun::star::document::XImporter,
+	com::sun::star::document::XExtendedFilterDetection,
+	com::sun::star::lang::XInitialization,
+	com::sun::star::lang::XServiceInfo
+>
+{
+protected:
+	// oo.org declares
+	::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > mxMSF;
+	::com::sun::star::uno::Reference< ::com::sun::star::lang::XComponent > mxDoc;
+	::rtl::OUString msFilterName;
+	::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XDocumentHandler > mxHandler;
+
+	FilterType meType;
+
+public:
+	WPGImportFilter( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > &rxMSF)
+	: mxMSF( rxMSF ) {}
+	virtual ~WPGImportFilter() {}
+
+	// XFilter
+	virtual sal_Bool SAL_CALL filter( const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& aDescriptor ) 
+		throw (::com::sun::star::uno::RuntimeException);
+	virtual void SAL_CALL cancel(  ) 
+		throw (::com::sun::star::uno::RuntimeException);
+
+	// XImporter
+	virtual void SAL_CALL setTargetDocument( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XComponent >& xDoc ) 
+		throw (::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException);
+
+ 	//XExtendedFilterDetection
+	virtual ::rtl::OUString SAL_CALL detect( com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue >& Descriptor ) 
+		throw( com::sun::star::uno::RuntimeException );
+
+	// XInitialization
+	virtual void SAL_CALL initialize( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aArguments ) 
+		throw (::com::sun::star::uno::Exception, ::com::sun::star::uno::RuntimeException);
+
+	// XServiceInfo
+	virtual ::rtl::OUString SAL_CALL getImplementationName(  ) 
+		throw (::com::sun::star::uno::RuntimeException);
+	virtual sal_Bool SAL_CALL supportsService( const ::rtl::OUString& ServiceName ) 
+		throw (::com::sun::star::uno::RuntimeException);
+	virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames(  ) 
+		throw (::com::sun::star::uno::RuntimeException);
+
+};
+
+::rtl::OUString WPGImportFilter_getImplementationName()
+	throw ( ::com::sun::star::uno::RuntimeException );
+
+sal_Bool SAL_CALL WPGImportFilter_supportsService( const ::rtl::OUString& ServiceName ) 
+	throw ( ::com::sun::star::uno::RuntimeException );
+
+::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL WPGImportFilter_getSupportedServiceNames(  ) 
+	throw ( ::com::sun::star::uno::RuntimeException );
+
+::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >
+SAL_CALL WPGImportFilter_createInstance( const ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > & rSMgr)
+	throw ( ::com::sun::star::uno::Exception );
+
+#endif
--- /dev/null	2007-04-19 15:48:30.000000000 +0200
+++ writerperfect/source/wpgimp/wpgimport_genericfilter.cxx	2007-05-07 15:32:03.000000000 +0200
@@ -0,0 +1,101 @@
+/* genericfilter: mostly generic code for registering the filter
+ *
+ * Portions of this code Copyright 2000 by Sun Microsystems, Inc.
+ * Rest is Copyright (C) 2002 William Lachance (wlach@interlog.com)
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  
+ * 02111-1307, USA.
+ */
+
+/* "This product is not manufactured, approved, or supported by 
+ * Corel Corporation or Corel Corporation Limited."
+ */
+#include <stdio.h>
+
+#include <osl/mutex.hxx>
+#include <osl/thread.h>
+#include <cppuhelper/factory.hxx>
+
+#ifndef _COM_SUN_STAR_LANG_XSINGLESERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XSingleServiceFactory.hpp>
+#endif
+
+#include "WPGImportFilter.hxx"
+
+using namespace ::rtl;
+using namespace ::cppu;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::registry;
+
+extern "C"
+{
+//==================================================================================================
+void SAL_CALL component_getImplementationEnvironment(
+	const sal_Char ** ppEnvTypeName, uno_Environment ** /* ppEnv */ )
+{
+	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+}
+//==================================================================================================
+sal_Bool SAL_CALL component_writeInfo(
+	void * /* pServiceManager */, void * pRegistryKey )
+{
+	if (pRegistryKey)
+	{
+		try
+		{
+            sal_Int32 nPos = 0;
+            Reference< XRegistryKey > xNewKey(
+				reinterpret_cast< XRegistryKey * >( pRegistryKey )->createKey( WPGImportFilter_getImplementationName() ) ); 
+            xNewKey = xNewKey->createKey( OUString::createFromAscii( "/UNO/SERVICES" ) );
+			
+			const Sequence< OUString > & rSNL = WPGImportFilter_getSupportedServiceNames();
+			const OUString * pArray = rSNL.getConstArray();
+			for ( nPos = rSNL.getLength(); nPos--; )
+				xNewKey->createKey( pArray[nPos] );
+
+			return sal_True;
+		}
+		catch (InvalidRegistryException &)
+		{
+			OSL_ENSURE( sal_False, "### InvalidRegistryException!" );
+		}
+	}
+	return sal_False;
+}
+//==================================================================================================
+void * SAL_CALL component_getFactory(
+	const sal_Char * pImplName, void * pServiceManager, void * /* pRegistryKey */ )
+{
+	void * pRet = 0;
+
+    OUString implName = OUString::createFromAscii( pImplName );
+	if ( pServiceManager && implName.equals(WPGImportFilter_getImplementationName()) )
+	{
+		Reference< XSingleServiceFactory > xFactory( createSingleFactory(
+			reinterpret_cast< XMultiServiceFactory * >( pServiceManager ),
+			OUString::createFromAscii( pImplName ),
+			WPGImportFilter_createInstance, WPGImportFilter_getSupportedServiceNames() ) );
+		
+		if (xFactory.is())
+		{
+			xFactory->acquire();
+			pRet = xFactory.get();
+		}
+	}
+	
+	return pRet;
+}
+}
--- writerperfect/prj/build.lst	18 Dec 2006 13:12:18 -0000	1.8.12.2
+++ writerperfect/prj/build.lst	7 May 2007 13:53:32 -0000
@@ -1,7 +1,8 @@
-wp      writerperfect : LIBWPS:libwps LIBWPD:libwpd sot comphelper xmloff so3 NULL
+wp      writerperfect : LIBWPG:libwpg LIBWPS:libwps LIBWPD:libwpd sot comphelper xmloff so3 NULL
 wp	writerperfect			usr1	-	all	wp_mkout NULL
 wp	writerperfect\source\stream	nmake	-	all	wp_stream NULL
 wp	writerperfect\source\filter	nmake	-	all	wp_filter NULL
 wp	writerperfect\source\wpdimp	nmake	-	all	wp_wpdimp NULL
 wp	writerperfect\source\wpsimp	nmake	-	all	wp_wpsimp NULL
-wp	writerperfect\util		nmake	-	all	wp_util wp_wpsimp wp_wpdimp wp_filter wp_stream NULL
+wp  writerperfect\source\wpgimp nmake   -   all wp_wpgimp NULL
+wp	writerperfect\util		nmake	-	all	wp_util wp_wpgimp wp_wpsimp wp_wpdimp wp_filter wp_stream NULL
--- writerperfect/source/wpsimp/makefile.mk	18 Dec 2006 13:12:22 -0000	1.1.2.1
+++ writerperfect/source/wpsimp/makefile.mk	7 May 2007 13:53:32 -0000
@@ -18,6 +18,12 @@
 INCPRE+=$(SOLARVER)$/$(UPD)$/$(INPATH)$/inc$/libwps
 .ENDIF
 
+.IF "$(SYSTEM_LIBWPG)" == "YES"
+INCPRE+=$(LIBWPG_CFLAGS)
+.ELSE
+INCPRE+=$(SOLARVER)$/$(UPD)$/$(INPATH)$/inc$/libwpg
+.ENDIF
+
 # broken but ... necessary, internal include shafted ...
 INCPRE+= -I..
 
--- writerperfect/util/makefile.mk	7 May 2007 09:28:20 -0000	1.6.6.4
+++ writerperfect/util/makefile.mk	7 May 2007 13:53:32 -0000
@@ -20,10 +20,17 @@
 LIBWPS=-lwpslib
 .ENDIF
 
+.IF "$(SYSTEM_LIBWPG)" == "YES"
+LIBWPG=$(LIBWPG_LIBS)
+.ELSE
+LIBWPG=-lwpglib
+.ENDIF
+
 .ELSE
 
 LIBWPD=$(LIBPRE) wpdlib.lib
 LIBWPS=$(LIBPRE) wpslib.lib
+LIBWPG=$(LIBPRE) wpglib.lib
 
 .ENDIF
 
@@ -83,4 +90,31 @@
 SHL2VERSIONMAP=msworks.map
 DEF2NAME=$(SHL2TARGET)
 
+LIB3TARGET= $(SLB)$/wpgimport.lib
+LIB3FILES= \
+	$(SLB)$/stream.lib  \
+	$(SLB)$/wpgimp.lib
+SHL3LIBS=$(LIB3TARGET)
+SHL3STDLIBS+= \
+	$(SVLLIB)	\
+	$(SOTLIB) \
+	$(SO2LIB) \
+	$(SVTOOLLIB) \
+	$(UNOTOOLSLIB) \
+	$(TOOLSLIB) \
+	$(COMPHELPERLIB) \
+	$(UCBHELPERLIB) \
+	$(CPPUHELPERLIB) \
+	$(CPPULIB) \
+	$(SALLIB) \
+	$(XMLOFFLIB) \
+	$(LIBWPD) \
+	$(LIBWPG)
+
+SHL3TARGET = wpgimport$(UPD)$(DLLPOSTFIX)
+SHL3IMPLIB = i$(SHL3TARGET)
+SHL3LIBS = $(LIB3TARGET)
+SHL3VERSIONMAP=wpgimport.map
+DEF3NAME=$(SHL3TARGET)
+
 .INCLUDE :  target.mk
--- scp2/source/graphicfilter/file_graphicfilter.scp	20 Jun 2006 04:52:21 -0000	1.11
+++ scp2/source/graphicfilter/file_graphicfilter.scp	7 May 2007 13:55:23 -0000
@@ -67,3 +67,5 @@
 
 STD_UNO_LIB_FILE_PATCH( gid_File_Lib_Svg, svgfilter )
 
+STD_UNO_LIB_FILE_PATCH( gid_File_Lib_WPGImport, wpgimport )
+
