Index: canvas/source/cairo/cairo_canvashelper.cxx
===================================================================
RCS file: /cvs/gsl/canvas/source/cairo/cairo_canvashelper.cxx,v
retrieving revision 1.9
retrieving revision 1.7.20.5
diff -u -p -u -p -r1.9 -r1.7.20.5
--- canvas/source/cairo/cairo_canvashelper.cxx	2 Aug 2007 16:32:02 -0000	1.9
+++ canvas/source/cairo/cairo_canvashelper.cxx	27 Aug 2007 14:35:48 -0000	1.7.20.5
@@ -110,12 +110,18 @@ namespace cairocanvas
 		}
     }
 
-    void CanvasHelper::init( const ::basegfx::B2ISize& /*rSize*/,
+    void CanvasHelper::init( const ::basegfx::B2ISize& rSize,
                              SpriteCanvas&             rDevice )
     {
+        maSize = rSize;
         mpDevice = &rDevice;
     }
 
+    void CanvasHelper::setSize( const ::basegfx::B2ISize& rSize )
+    {
+        maSize = rSize;
+    }
+
     void CanvasHelper::setSurface( Surface* pSurface, bool bHasAlpha, SurfaceProvider* pSurfaceProvider )
     {
         mbHaveAlpha = bHasAlpha;
@@ -251,8 +257,7 @@ namespace cairocanvas
             cairo_set_operator( mpCairo, CAIRO_OPERATOR_SOURCE );
             cairo_set_source_rgba( mpCairo, 0, 0, 0, 0 );
             
-			const ::basegfx::B2ISize& rSize( mpDevice->getSizePixel() );
-			cairo_rectangle( mpCairo, 0, 0, rSize.getX(), rSize.getY() );
+			cairo_rectangle( mpCairo, 0, 0, maSize.getX(), maSize.getY() );
             cairo_fill( mpCairo );
 
             cairo_restore( mpCairo );
@@ -1157,11 +1162,9 @@ namespace cairocanvas
                 geometry::IntegerSize2D aBitmapSize = rSize;
 
 		if( mpCairo ) {
-			const ::basegfx::B2ISize& aSize = mpDevice->getSizePixel();
-
 			cairo_save( mpCairo );
 
-			cairo_rectangle( mpCairo, 0, 0, aSize.getX(), aSize.getY() );
+			cairo_rectangle( mpCairo, 0, 0, maSize.getX(), maSize.getY() );
 			cairo_clip( mpCairo );
 
 			useStates( viewState, renderState, true );
@@ -1219,8 +1222,8 @@ namespace cairocanvas
 
 				// in case the bitmap doesn't have alpha and covers whole area
 				// we try to change surface to plain rgb
-				OSL_TRACE ("chance to change surface to rgb, %f, %f, %f x %f (%d x %d)", x, y, width, height, aSize.getX(), aSize.getY() );
-				if( x <= 0 && y <= 0 && x + width >= aSize.getX() && y + height >= aSize.getY() )
+				OSL_TRACE ("chance to change surface to rgb, %f, %f, %f x %f (%d x %d)", x, y, width, height, maSize.getX(), maSize.getY() );
+				if( x <= 0 && y <= 0 && x + width >= maSize.getX() && y + height >= maSize.getY() )
 				{
 					OSL_TRACE ("trying to change surface to rgb");
 					if( mpSurfaceProvider ) {
@@ -1318,7 +1321,7 @@ namespace cairocanvas
         if( !mpDevice )
             geometry::IntegerSize2D(1, 1); // we're disposed
 
-        return ::basegfx::unotools::integerSize2DFromB2ISize( mpDevice->getSizePixel() );
+        return ::basegfx::unotools::integerSize2DFromB2ISize( maSize );
     }
 
     uno::Reference< rendering::XBitmap > CanvasHelper::getScaledBitmap( const geometry::RealSize2D&	newSize, 
@@ -1343,10 +1346,42 @@ namespace cairocanvas
 		return uno::Reference< rendering::XBitmap >();
     }
 
-    uno::Sequence< sal_Int8 > CanvasHelper::getData( rendering::IntegerBitmapLayout&     /*bitmapLayout*/, 
-                                                     const geometry::IntegerRectangle2D& /*rect*/ )
+    uno::Sequence< sal_Int8 > CanvasHelper::getData( rendering::IntegerBitmapLayout&     aLayout, 
+                                                     const geometry::IntegerRectangle2D& rect )
     {
-        // TODO
+        if( mpCairo ) {
+            const sal_Int32 nWidth( rect.X2 - rect.X1 );
+            const sal_Int32 nHeight( rect.Y2 - rect.Y1 );
+            uno::Sequence< sal_Int8 > aRes( 4*nWidth*nHeight );
+            sal_Int8* pData = aRes.getArray();
+            ::cairo::cairo_surface_t* pImageSurface = cairo_image_surface_create_for_data( (unsigned char *) pData,
+ 																						   CAIRO_FORMAT_ARGB32,
+ 																						   nWidth, nHeight, 4*nWidth );
+            ::cairo::cairo_t* pCairo = cairo_create( pImageSurface );
+            cairo_set_source_surface( pCairo, mpSurface->mpSurface, -rect.X1, -rect.Y1);
+            cairo_paint( pCairo );
+            cairo_destroy( pCairo );
+            cairo_surface_destroy( pImageSurface );
+ 
+            aLayout.ScanLines = nHeight;
+            aLayout.ScanLineBytes = nWidth*4;
+            aLayout.ScanLineStride = aLayout.ScanLineBytes;
+            aLayout.PlaneStride = 0;
+            aLayout.ColorSpace.set( mpDevice ); 
+            aLayout.NumComponents = 4;
+            aLayout.ComponentMasks.realloc(4);
+            aLayout.ComponentMasks[0] = 0x00FF0000;
+            aLayout.ComponentMasks[1] = 0x0000FF00;
+            aLayout.ComponentMasks[2] = 0x000000FF;
+            aLayout.ComponentMasks[3] = 0xFF000000;
+            aLayout.Palette.clear();
+            aLayout.Endianness = rendering::Endianness::LITTLE;
+            aLayout.Format = rendering::IntegerBitmapFormat::CHUNKY_32BIT;
+            aLayout.IsMsbFirst = sal_False;
+ 
+            return aRes;
+        }
+ 
         return uno::Sequence< sal_Int8 >();
     }
 
@@ -1381,8 +1416,8 @@ namespace cairocanvas
 
         const geometry::IntegerSize2D& rBmpSize( getSize() );
 
-        aLayout.ScanLines = rBmpSize.Width;
-        aLayout.ScanLineBytes = rBmpSize.Height * 4;
+        aLayout.ScanLines = rBmpSize.Height;
+        aLayout.ScanLineBytes = rBmpSize.Width * 4;
         aLayout.ScanLineStride = aLayout.ScanLineBytes;
         aLayout.PlaneStride = 0;
         aLayout.ColorSpace.set( mpDevice ); 
@@ -1416,11 +1451,9 @@ namespace cairocanvas
 		OSL_TRACE("CanvasHelper::repaint");
 
 		if( mpCairo ) {
-			const ::basegfx::B2ISize& aSize = mpDevice->getSizePixel();
-
 			cairo_save( mpCairo );
 
-			cairo_rectangle( mpCairo, 0, 0, aSize.getX(), aSize.getY() );
+			cairo_rectangle( mpCairo, 0, 0, maSize.getX(), maSize.getY() );
 			cairo_clip( mpCairo );
 
 			useStates( viewState, renderState, true );
Index: canvas/source/cairo/cairo_canvashelper.hxx
===================================================================
RCS file: /cvs/gsl/canvas/source/cairo/cairo_canvashelper.hxx,v
retrieving revision 1.4
retrieving revision 1.4.6.1
diff -u -p -u -p -r1.4 -r1.4.6.1
--- canvas/source/cairo/cairo_canvashelper.hxx	17 Jul 2007 14:20:45 -0000	1.4
+++ canvas/source/cairo/cairo_canvashelper.hxx	27 Aug 2007 14:35:48 -0000	1.4.6.1
@@ -99,6 +99,7 @@ namespace cairocanvas
         void init( const ::basegfx::B2ISize& rSizePixel,
                    SpriteCanvas&             rDevice );
 
+        void setSize( const ::basegfx::B2ISize& rSize );
 	void setSurface( ::cairo::Surface* pSurface, bool bHasAlpha, SurfaceProvider* pSurfaceProvider = NULL );
 
         // CanvasHelper functionality
@@ -323,6 +324,7 @@ namespace cairocanvas
 		::cairo::Cairo* mpCairo;
 		::cairo::Surface* mpSurface;
 		SurfaceProvider* mpSurfaceProvider;
+        ::basegfx::B2ISize maSize;
     };
 
     void doPolyPolygonImplementation( ::basegfx::B2DPolyPolygon aPolyPolygon,
Index: canvas/source/cairo/cairo_spritecanvas.cxx
===================================================================
RCS file: /cvs/gsl/canvas/source/cairo/cairo_spritecanvas.cxx,v
retrieving revision 1.5
retrieving revision 1.5.6.1
diff -u -p -u -p -r1.5 -r1.5.6.1
--- canvas/source/cairo/cairo_spritecanvas.cxx	17 Jul 2007 14:21:38 -0000	1.5
+++ canvas/source/cairo/cairo_spritecanvas.cxx	27 Aug 2007 14:35:48 -0000	1.5.6.1
@@ -221,7 +221,7 @@ namespace cairocanvas
         return maDeviceHelper.getSizePixel();
     }
 
-    void SpriteCanvas::setSizePixel( const ::basegfx::B2ISize& /*rSize*/ )
+    void SpriteCanvas::setSizePixel( const ::basegfx::B2ISize& rSize )
     {
 		if( mpBackgroundSurface )
 		{
@@ -235,6 +235,7 @@ namespace cairocanvas
 		}
 		mpBackgroundCairo = mpBackgroundSurface->getCairo();
 
+		maCanvasHelper.setSize( rSize );
 		maCanvasHelper.setSurface( mpBackgroundSurface, false );
     }
 
Index: canvas/source/vcl/canvasbitmaphelper.cxx
===================================================================
RCS file: /cvs/gsl/canvas/source/vcl/canvasbitmaphelper.cxx,v
retrieving revision 1.10
retrieving revision 1.9.42.2
diff -u -p -u -p -r1.10 -r1.9.42.2
--- canvas/source/vcl/canvasbitmaphelper.cxx	17 Jul 2007 14:25:12 -0000	1.10
+++ canvas/source/vcl/canvasbitmaphelper.cxx	25 Jul 2007 15:05:05 -0000	1.9.42.2
@@ -137,7 +137,7 @@ namespace vclcanvas
             new CanvasBitmap( aRes, mpDevice ) );
     }
 
-    uno::Sequence< sal_Int8 > CanvasBitmapHelper::getData( rendering::IntegerBitmapLayout& 		,
+    uno::Sequence< sal_Int8 > CanvasBitmapHelper::getData( rendering::IntegerBitmapLayout& 		aLayout,
                                                            const geometry::IntegerRectangle2D&	rect )
     {
         RTL_LOGFILE_CONTEXT( aLog, "::vclcanvas::CanvasBitmapHelper::getData()" );
@@ -145,6 +145,24 @@ namespace vclcanvas
         if( !mpBackBuffer )
             return uno::Sequence< sal_Int8 >(); // we're disposed
 
+        const sal_Int32 nWidth( rect.X2 - rect.X1 );
+        const sal_Int32 nHeight( rect.Y2 - rect.Y1 );
+        aLayout.ScanLines = nHeight;
+        aLayout.ScanLineBytes = nWidth*4;
+        aLayout.ScanLineStride = aLayout.ScanLineBytes;
+        aLayout.PlaneStride = 0;
+        aLayout.ColorSpace.set( mpDevice ); 
+        aLayout.NumComponents = 4;
+        aLayout.ComponentMasks.realloc(4);
+        aLayout.ComponentMasks[0] = 0x00FF0000;
+        aLayout.ComponentMasks[1] = 0x0000FF00;
+        aLayout.ComponentMasks[2] = 0x000000FF;
+        aLayout.ComponentMasks[3] = 0xFF000000;
+        aLayout.Palette.clear();
+        aLayout.Endianness = rendering::Endianness::LITTLE;
+        aLayout.Format = rendering::IntegerBitmapFormat::CHUNKY_32BIT;
+        aLayout.IsMsbFirst = sal_False;
+
         Bitmap aBitmap( mpBackBuffer->getBitmapReference().GetBitmap() );
         Bitmap aAlpha( mpBackBuffer->getBitmapReference().GetAlpha().GetBitmap() );
 
Index: canvas/source/vcl/canvashelper.cxx
===================================================================
RCS file: /cvs/gsl/canvas/source/vcl/canvashelper.cxx,v
retrieving revision 1.13
retrieving revision 1.10.42.3
diff -u -p -u -p -r1.13 -r1.10.42.3
--- canvas/source/vcl/canvashelper.cxx	30 Aug 2007 15:21:07 -0000	1.13
+++ canvas/source/vcl/canvashelper.cxx	30 Sep 2007 00:18:06 -0000	1.10.42.3
@@ -900,7 +900,7 @@ namespace vclcanvas
             new CanvasBitmap( aBitmap, mpDevice ) );
     }
 
-    uno::Sequence< sal_Int8 > CanvasHelper::getData( rendering::IntegerBitmapLayout& 		,
+    uno::Sequence< sal_Int8 > CanvasHelper::getData( rendering::IntegerBitmapLayout& 		aLayout,
                                                      const geometry::IntegerRectangle2D&	rect )
     {
         if( !mpOutDev.get() )
@@ -912,14 +912,30 @@ namespace vclcanvas
         Bitmap aBitmap( mpOutDev->getOutDev().GetBitmap(aRect.TopLeft(), 
                                                         aRect.GetSize()) );
 
+        const sal_Int32 nWidth( rect.X2 - rect.X1 );
+        const sal_Int32 nHeight( rect.Y2 - rect.Y1 );
+        aLayout.ScanLines = nHeight;
+        aLayout.ScanLineBytes = nWidth*4;
+        aLayout.ScanLineStride = aLayout.ScanLineBytes;
+        aLayout.PlaneStride = 0;
+        aLayout.ColorSpace.set( mpDevice ); 
+        aLayout.NumComponents = 4;
+        aLayout.ComponentMasks.realloc(4);
+        aLayout.ComponentMasks[0] = 0x00FF0000;
+        aLayout.ComponentMasks[1] = 0x0000FF00;
+        aLayout.ComponentMasks[2] = 0x000000FF;
+        aLayout.ComponentMasks[3] = 0xFF000000;
+        aLayout.Palette.clear();
+        aLayout.Endianness = rendering::Endianness::LITTLE;
+        aLayout.Format = rendering::IntegerBitmapFormat::CHUNKY_32BIT;
+        aLayout.IsMsbFirst = sal_False;
+
         ScopedBitmapReadAccess pReadAccess( aBitmap.AcquireReadAccess(),
                                             aBitmap );
 
         if( pReadAccess.get() != NULL )
         {
             // TODO(F1): Support more formats.
-            const sal_Int32 nWidth( rect.X2 - rect.X1 );
-            const sal_Int32 nHeight( rect.Y2 - rect.Y1 );
 
             // for the time being, always return as BGRA 
             uno::Sequence< sal_Int8 > aRes( 4*nWidth*nHeight );
Index: slideshow/prj/build.lst
===================================================================
RCS file: /cvs/graphics/slideshow/prj/build.lst,v
retrieving revision 1.6
retrieving revision 1.5.34.6
diff -u -p -u -p -r1.6 -r1.5.34.6
--- slideshow/prj/build.lst	17 Jul 2007 14:32:58 -0000	1.6
+++ slideshow/prj/build.lst	10 Oct 2007 08:50:38 -0000	1.5.34.6
@@ -5,6 +5,7 @@ pe	slideshow\source\api					nmake	-	all	
 pe	slideshow\source\engine					nmake	-	all	pe_engine pe_api pe_inc NULL
 pe	slideshow\source\engine\slide			nmake	-	all	pe_slide pe_api pe_inc NULL
 pe	slideshow\source\engine\shapes			nmake	-	all	pe_shapes pe_api pe_inc NULL
+pe  slideshow\source\engine\OGLTrans        nmake   -   u pe_ogltrans pe_api pe_inc NULL
 pe	slideshow\source\engine\transitions		nmake	-	all	pe_transitions pe_api pe_inc NULL
 pe	slideshow\source\engine\animationnodes	nmake	-	all	pe_animationnodes pe_api pe_inc NULL
 pe	slideshow\source\engine\activities		nmake	-	all	pe_activities pe_api pe_inc NULL
Index: slideshow/prj/d.lst
===================================================================
RCS file: /cvs/graphics/slideshow/prj/d.lst,v
retrieving revision 1.5
retrieving revision 1.5.26.1
diff -u -p -u -p -r1.5 -r1.5.26.1
--- slideshow/prj/d.lst	12 Dec 2006 16:27:43 -0000	1.5
+++ slideshow/prj/d.lst	10 Oct 2007 08:50:38 -0000	1.5.26.1
@@ -1,4 +1,6 @@
+..\%__SRC%\bin\OGLTrans.uno.dll %_DEST%\bin%_EXT%\OGLTrans.uno.dll
 ..\%__SRC%\bin\slideshow.uno.dll %_DEST%\bin%_EXT%\slideshow.uno.dll
 ..\%__SRC%\bin\*.rdb %_DEST%\bin%_EXT%\*.rdb
 ..\%__SRC%\lib\slideshow.uno.so %_DEST%\lib%_EXT%\slideshow.uno.so
+..\%__SRC%\lib\OGLTrans.uno.so %_DEST%\lib%_EXT%\OGLTrans.uno.so
 ..\%__SRC%\lib\*.dylib %_DEST%\lib%_EXT%\*.dylib
Index: slideshow/source/api/makefile.mk
===================================================================
RCS file: /cvs/graphics/slideshow/source/api/makefile.mk,v
retrieving revision 1.7
retrieving revision 1.7.8.2
diff -u -p -u -p -r1.7 -r1.7.8.2
--- slideshow/source/api/makefile.mk	25 Jan 2007 14:04:41 -0000	1.7
+++ slideshow/source/api/makefile.mk	10 Oct 2007 21:03:44 -0000	1.7.8.2
@@ -64,7 +64,9 @@ UNOTYPES = \
 	com.sun.star.presentation.XSlideShow \
 	com.sun.star.presentation.XSlideShowView \
 	com.sun.star.presentation.XSlideShowListener \
-	com.sun.star.presentation.XShapeEventListener
+	com.sun.star.presentation.XShapeEventListener \
+	com.sun.star.presentation.XTransitionFactory \
+	com.sun.star.presentation.XTransition
 
 ALLIDLFILES = $(foreach,i,$(UNOTYPES) $(subst,.,$/ $i).idl)
 
Index: slideshow/source/api/com/sun/star/presentation/XTransition.idl
===================================================================
RCS file: slideshow/source/api/com/sun/star/presentation/XTransition.idl
diff -N slideshow/source/api/com/sun/star/presentation/XTransition.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ slideshow/source/api/com/sun/star/presentation/XTransition.idl	10 Oct 2007 21:03:44 -0000	1.1.2.1
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_presentation_XTransition_idl__
+#define __com_sun_star_presentation_XTransition_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+
+module com {  module sun {  module star {  module presentation {
+/** Transition interface to render custom transitions over time.<p>
+
+    @since OOo 2.4
+ */
+interface XTransition : ::com::sun::star::uno::XInterface
+{
+    /** Update transition on screen to given time state.<p>
+
+        @param t 
+        Time on the transition timeline to display. Must be in the
+        [0,1] range.
+     */
+    void update( [in] double t );
+};
+
+}; }; }; };
+
+#endif
+
Index: slideshow/source/api/com/sun/star/presentation/XTransitionFactory.idl
===================================================================
RCS file: slideshow/source/api/com/sun/star/presentation/XTransitionFactory.idl
diff -N slideshow/source/api/com/sun/star/presentation/XTransitionFactory.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ slideshow/source/api/com/sun/star/presentation/XTransitionFactory.idl	10 Oct 2007 21:03:44 -0000	1.1.2.1
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_presentation_XTransitionFactory_idl__
+#define __com_sun_star_presentation_XTransitionFactory_idl__
+
+#ifndef __com_sun_star_presentation_XTransition_idl__ 
+#include <com/sun/star/presentation/XTransition.idl> 
+#endif 
+#ifndef __com_sun_star_geometry_RealPoint2D_idl__ 
+#include <com/sun/star/geometry/RealPoint2D.idl> 
+#endif 
+
+
+module com {  module sun {  module star {  
+
+module rendering { interface XBitmap; };
+
+module presentation {
+
+interface XTransition;
+interface XSlideShowView;
+
+/** TransitionFactory interface to request optional custom Transition instances for slideshow transitions.<p>
+
+    This interface provides the necessary methods to query and create optional transition effects for a SlideShow<p>
+
+    @since OOo 2.4
+ */
+interface XTransitionFactory : ::com::sun::star::uno::XInterface
+{
+    /** Checks whether this instance provides an implementation for given transition id.<p>
+     */
+    boolean hasTransition( [in] short transitionType, [in] short transitionSubType );
+
+    /** Actually create a transition for the given transition id
+
+        @param transitionType
+        Main type of transition (@see ::com::sun::star::animation::TransitionType)
+
+        @param transitionSubType
+        Subtype for the transition (@see ::com::sun::star::animation::TransitionSubType)
+
+        @param view
+        Slideshow view to display on
+
+        @param leavingBitmap
+        Bitmap of the slide that's going to leave the screen
+
+        @param enteringBitmap
+        Bitmap of the slide that's going to enter the screen
+
+        @param slideOffset
+        Offset in pixel from the top, left edge of the view, such that the
+        slide displays similar to normal slideshow
+     */
+    XTransition createTransition( [in] short                                 transitionType, 
+                                  [in] short                                 transitionSubType,
+                                  [in] XSlideShowView                        view,
+                                  [in] com::sun::star::rendering::XBitmap    leavingBitmap,
+                                  [in] com::sun::star::rendering::XBitmap    enteringBitmap,
+                                  [in] com::sun::star::geometry::RealPoint2D slideOffset );
+};
+
+service TransitionFactory : XTransitionFactory;
+
+}; }; }; };
+
+#endif
+
Index: slideshow/source/engine/slidebitmap.cxx
===================================================================
RCS file: /cvs/graphics/slideshow/source/engine/slidebitmap.cxx,v
retrieving revision 1.9
retrieving revision 1.8.26.2
diff -u -p -u -p -r1.9 -r1.8.26.2
--- slideshow/source/engine/slidebitmap.cxx	17 Jul 2007 14:40:28 -0000	1.9
+++ slideshow/source/engine/slidebitmap.cxx	25 Jul 2007 15:21:32 -0000	1.8.26.2
@@ -129,6 +129,12 @@ namespace slideshow
         {
             maClipPoly = rClipPoly;
         }
+        
+        ::com::sun::star::uno::Reference<
+                ::com::sun::star::rendering::XBitmap >    SlideBitmap::getXBitmap()
+        {
+        return mxBitmap;
+        }
 
     }
 }
Index: slideshow/source/engine/slideshowimpl.cxx
===================================================================
RCS file: /cvs/graphics/slideshow/source/engine/slideshowimpl.cxx,v
retrieving revision 1.5
retrieving revision 1.5.6.2
diff -u -p -u -p -r1.5 -r1.5.6.2
--- slideshow/source/engine/slideshowimpl.cxx	5 Sep 2007 17:40:47 -0000	1.5
+++ slideshow/source/engine/slideshowimpl.cxx	10 Oct 2007 21:03:44 -0000	1.5.6.2
@@ -44,7 +44,9 @@
 #include <cppuhelper/implementationentry.hxx>
 #include <cppuhelper/compbase2.hxx>
 #include <cppuhelper/interfacecontainer.h>
+#include <cppuhelper/exc_hlp.hxx>
 
+#include <comphelper/anytostring.hxx>
 #include <comphelper/make_shared_from_uno.hxx>
 #include <comphelper/scopeguard.hxx>
 #include <comphelper/optional.hxx>
@@ -346,7 +348,9 @@ private:
     SoundPlayerSharedPtr                    mpCurrentSlideTransitionSound;
     
     uno::Reference<uno::XComponentContext>  mxComponentContext;
-    
+    uno::Reference<
+        presentation::XTransitionFactory>   mxOptionalTransitionFactory;
+
     /// the previously running slide
     SlideSharedPtr                          mpPreviousSlide;
     /// the currently running slide
@@ -447,6 +451,7 @@ SlideShowImpl::SlideShowImpl(
       mpWaitSymbol(),
       mpCurrentSlideTransitionSound(),
       mxComponentContext( xContext ),
+      mxOptionalTransitionFactory(),
       mpCurrentSlide(),
       mpPrefetchSlide(),
       mxPrefetchSlide(),
@@ -465,6 +470,19 @@ SlideShowImpl::SlideShowImpl(
     // keep care not constructing any UNO references to this inside ctor,
     // shift that code to create()!
     
+    uno::Reference<lang::XMultiComponentFactory> xFactory( 
+        mxComponentContext->getServiceManager() );
+
+    if( xFactory.is() )
+    {
+        // #i82460# try to retrieve special transition factory
+        mxOptionalTransitionFactory.set( 
+            xFactory->createInstanceWithContext( 
+                ::rtl::OUString::createFromAscii( "com.sun.star.presentation.TransitionFactory" ),
+                mxComponentContext ), 
+            uno::UNO_QUERY );
+    }
+
     mpListener.reset( new SeparateListenerImpl(
                           *this, 
                           maScreenUpdater,
@@ -655,6 +673,7 @@ ActivitySharedPtr SlideShowImpl::createS
             maViewContainer,
             maScreenUpdater,
             maEventMultiplexer,
+            mxOptionalTransitionFactory,
             nTransitionType,
             nTransitionSubType,
             bTransitionDirection,
Index: slideshow/source/engine/slideview.cxx
===================================================================
RCS file: /cvs/graphics/slideshow/source/engine/slideview.cxx,v
retrieving revision 1.4
retrieving revision 1.4.4.1
diff -u -p -u -p -r1.4 -r1.4.4.1
--- slideshow/source/engine/slideview.cxx	20 Jul 2007 05:28:30 -0000	1.4
+++ slideshow/source/engine/slideview.cxx	10 Oct 2007 12:02:30 -0000	1.4.4.1
@@ -233,14 +233,17 @@ void clearRect( ::cppcanvas::CanvasShare
 #if defined(VERBOSE) && defined(DBG_UTIL)
     ::cppcanvas::CanvasSharedPtr pCliplessCanvas( pCanvas->clone() );
     pCliplessCanvas->setClip();
-    ::cppcanvas::PolyPolygonSharedPtr pPolyPoly2( 
-        ::cppcanvas::BaseGfxFactory::getInstance().createPolyPolygon( pCliplessCanvas, 
-                                                                      pCanvas->getClip() ) );
 
-    if( pPolyPoly2 )
+    if( pCanvas->getClip() )
     {
-        pPolyPoly2->setRGBALineColor( 0x008000FFU );
-        pPolyPoly2->draw();
+        ::cppcanvas::PolyPolygonSharedPtr pPolyPoly2(
+            ::cppcanvas::BaseGfxFactory::getInstance().createPolyPolygon( pCliplessCanvas, 
+                                                                          *(pCanvas->getClip()) ));
+        if( pPolyPoly2 )
+        {
+            pPolyPoly2->setRGBALineColor( 0x008000FFU );
+            pPolyPoly2->draw();
+        }
     }
 #endif
 }
Index: slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx
===================================================================
RCS file: slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx
diff -N slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.cxx	10 Oct 2007 21:03:44 -0000	1.1.2.11
@@ -0,0 +1,497 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2007 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include "OGLTrans_TransitionImpl.hxx"
+#include <GL/gl.h>
+
+void OGLTransitionImpl::clear()
+{
+    for(unsigned int i( 0 ); i < OverallOperations.size(); ++i)
+        delete OverallOperations[i];
+    OverallOperations.clear();
+    maLeavingSlidePrimitives.clear();
+    maEnteringSlidePrimitives.clear();
+}
+
+OGLTransitionImpl::~OGLTransitionImpl()
+{
+    clear();
+}
+
+void OGLTransitionImpl::display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex , double SlideWidthScale, double SlideHeightScale)
+{
+    glPushMatrix();
+    glEnable(GL_TEXTURE_2D);
+    //TODO change to foreach
+    for(unsigned int i(0); i < OverallOperations.size(); ++i)
+        OverallOperations[i]->interpolate(nTime,SlideWidthScale,SlideHeightScale);
+    glBindTexture(GL_TEXTURE_2D, glLeavingSlideTex);
+    for(unsigned int i(0); i < maLeavingSlidePrimitives.size(); ++i)
+        maLeavingSlidePrimitives[i].display(nTime,SlideWidthScale,SlideHeightScale);
+    glBindTexture(GL_TEXTURE_2D, glEnteringSlideTex);
+    for(unsigned int i(0); i < maEnteringSlidePrimitives.size(); ++i)
+        maEnteringSlidePrimitives[i].display(nTime,SlideWidthScale,SlideHeightScale);
+    glPopMatrix();
+}
+
+void Primitive::display(double nTime, double SlideWidthScale, double SlideHeightScale)
+{
+    glPushMatrix();
+    glEnable(GL_TEXTURE_2D);
+    for(unsigned int i(0); i < Operations.size(); ++i)
+        Operations[i]->interpolate( nTime ,SlideWidthScale,SlideHeightScale);
+    glScaled(SlideWidthScale,SlideHeightScale,1);
+    
+    glEnableClientState( GL_VERTEX_ARRAY );
+    if(!Normals.empty())
+    {
+        glNormalPointer( GL_DOUBLE , 0 , &Normals[0] );
+        glEnableClientState( GL_NORMAL_ARRAY );
+    }
+    glEnableClientState( GL_TEXTURE_COORD_ARRAY );
+    glTexCoordPointer( 2 , GL_DOUBLE , 0 , &TexCoords[0] );
+    glVertexPointer( 3 , GL_DOUBLE , 0 , &Vertices[0] );
+    glDrawArrays( GL_TRIANGLES , 0 , Vertices.size() );
+    glPopMatrix();
+}
+
+Primitive::~Primitive()
+{
+    for(unsigned int i( 0 ); i < Operations.size(); ++i)
+        delete Operations[i];
+}
+
+void OGLTransitionImpl::makeOutsideCubeFaceToLeft()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),-90,false,0.0,1.0));
+
+    maEnteringSlidePrimitives.push_back(Slide);
+
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,-1),90,true,0.0,1.0));
+}
+
+void OGLTransitionImpl::makeInsideCubeFaceToLeft()
+{
+    clear();
+    Primitive Slide;
+    
+    Slide.pushTriangle(basegfx::B2DVector(0,0),basegfx::B2DVector(1,0),basegfx::B2DVector(0,1));
+    Slide.pushTriangle(basegfx::B2DVector(1,0),basegfx::B2DVector(0,1),basegfx::B2DVector(1,1));
+
+    maLeavingSlidePrimitives.push_back(Slide);
+
+    Slide.Operations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),90,false,0.0,1.0));
+
+    maEnteringSlidePrimitives.push_back(Slide);
+    
+    OverallOperations.push_back(new RotateAndScaleDepthByWidth(basegfx::B3DVector(0,1,0),basegfx::B3DVector(0,0,1),-90,true,0.0,1.0));
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B2DVector clamp(const basegfx::B2DVector& v)
+{
+    return basegfx::B2DVector(std::min(std::max(v.getX(),-1.0),1.0),
+                              std::min(std::max(v.getY(),-1.0),1.0));
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B3DVector clamp(const basegfx::B3DVector& v)
+{
+    return basegfx::B3DVector(std::min(std::max(v.getX(),-1.0),1.0),
+                              std::min(std::max(v.getY(),-1.0),1.0),
+                              std::min(std::max(v.getZ(),-1.0),1.0));
+}
+
+inline double randFromNeg1to1()
+{
+    return ( ( static_cast<double>( rand() ) / static_cast<double>( RAND_MAX ) ) * 2.0 ) - 1.0;
+}
+
+// TODO(Q3): extract to basegfx
+inline basegfx::B3DVector randNormVectorInXYPlane()
+{
+    basegfx::B3DVector toReturn(randFromNeg1to1(),randFromNeg1to1(),0.0);
+    return toReturn/toReturn.getLength();
+}
+
+void OGLTransitionImpl::makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles )
+{
+    clear();
+    double dAngle(2*3.1415926/static_cast<double>( nPointsOnCircles ));
+    if(nCircles < 2 || nPointsOnCircles < 4)
+    {
+        makeNByMTileFlip(1,1);
+        return;
+    }
+    double Radius(1.0/static_cast<double>( nCircles ));
+    double dRadius(Radius);
+    double LastRadius(0.0);
+    double NextRadius(2*Radius);
+
+    /// now we know there is at least two circles
+    /// the first will always be a full circle
+    /// the last will always be the outer shell of the slide with a circle hole
+
+    //add the full circle
+    std::vector<basegfx::B2DVector> unScaledTexCoords;
+    double TempAngle(0.0);
+    for(unsigned int Point(0); Point < nPointsOnCircles; ++Point)
+    {
+        unScaledTexCoords.push_back( basegfx::B2DVector( cos(TempAngle - 3.1415926/2.0) , sin(TempAngle- 3.1415926/2.0) ) );
+
+        TempAngle += dAngle;
+    }
+    
+    {
+        //double angle(0.0);
+        Primitive EnteringSlide;
+        Primitive LeavingSlide;
+        for(int Point(0); Point + 1 < nPointsOnCircles; ++Point)
+        {
+            EnteringSlide.pushTriangle( basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point + 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) );
+            LeavingSlide.pushTriangle( basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point + 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ Point ] / 2.0 + basegfx::B2DVector( 0.5, 0.5) );
+        }
+        EnteringSlide.pushTriangle( basegfx::B2DVector(0.5,0.5) , Radius * unScaledTexCoords[ 0 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) , Radius * unScaledTexCoords[ nPointsOnCircles - 1 ] / 2.0 + basegfx::B2DVector( 0.5 , 0.5 ) );
+        LeavingSlide.pushTriangle( basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+    
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+    
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+        LastRadius = Radius;
+        Radius = NextRadius;
+        NextRadius += dRadius;
+    }    
+    
+    for(int i(1); i < nCircles - 1; ++i)
+    {
+        Primitive LeavingSlide;
+        Primitive EnteringSlide;
+        for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
+        {            
+            EnteringSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            EnteringSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            
+            LeavingSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            LeavingSlide.pushTriangle(Radius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        }
+        
+        EnteringSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        EnteringSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        LeavingSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        LeavingSlide.pushTriangle(Radius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , Radius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, Radius/2.0 , (NextRadius + 1)/2.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+        
+        LastRadius = Radius;
+        Radius = NextRadius;
+        NextRadius += dRadius;
+    }
+    {
+        Radius = sqrt(2);
+        Primitive LeavingSlide;
+        Primitive EnteringSlide;
+        for(int Side(0); Side < nPointsOnCircles - 1; ++Side)
+        {
+            
+            EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[Side + 1])/2.0 + basegfx::B2DVector(0.5,0.5) );
+            
+            LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) );
+            LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[Side])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[Side + 1]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[Side + 1])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        }
+        
+        EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        EnteringSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[0])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[nPointsOnCircles - 1]/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) );
+        LeavingSlide.pushTriangle(clamp(Radius*unScaledTexCoords[nPointsOnCircles - 1])/2.0 + basegfx::B2DVector(0.5,0.5) , LastRadius*unScaledTexCoords[0]/2.0 + basegfx::B2DVector(0.5,0.5) , clamp(Radius*unScaledTexCoords[0])/2.0 + basegfx::B2DVector(0.5,0.5) );
+        
+        basegfx::B3DVector axis(randNormVectorInXYPlane());
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, (LastRadius + dRadius)/2.0 , 1.0 ) );
+        LeavingSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , 180, true, (LastRadius + dRadius)/2.0 , 1.0 ) );
+        EnteringSlide.Operations.push_back( new SRotate( axis , basegfx::B3DVector(0,0,0) , -180, false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(EnteringSlide);
+        maLeavingSlidePrimitives.push_back(LeavingSlide);
+    }
+}
+
+void OGLTransitionImpl::makeHelix( ::sal_uInt16 nRows )
+{
+    clear();
+    double invN(1.0/static_cast<double>(nRows));
+    double iDn = 0.0;
+    double iPDn = invN;
+    for(unsigned int i(0); i < nRows; ++i)
+    {
+        Primitive Tile;
+        
+        Tile.pushTriangle(basegfx::B2DVector( 1.0 , iDn ) , basegfx::B2DVector( 0.0 , iDn ) , basegfx::B2DVector( 0.0 , iPDn ));
+            
+        Tile.pushTriangle(basegfx::B2DVector( 1.0 , iPDn ) , basegfx::B2DVector( 1.0 , iDn ) , basegfx::B2DVector( 0.0 , iPDn ));
+        
+        Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 0 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , 180 , 
+                                                true,std::min(std::max(static_cast<double>(i - nRows/2.0)*invN/2.0,0.0),1.0),
+                                                std::min(std::max(static_cast<double>(i + nRows/2.0)*invN/2.0,0.0),1.0) ) );
+        
+        maLeavingSlidePrimitives.push_back(Tile);
+        
+        Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 0 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , -180 , false,0.0,1.0) );
+        
+        maEnteringSlidePrimitives.push_back(Tile);
+            
+        iDn += invN;
+        iPDn += invN;
+    }
+}
+
+void OGLTransitionImpl::makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m )
+{
+    clear();
+    double invN(1.0/static_cast<double>(n));
+    double invM(1.0/static_cast<double>(m));
+    double iDn = 0.0;
+    double iPDn = invN;
+    for(unsigned int i(0); i < n; ++i)
+    {
+        double jDm = 0.0;
+        double jPDm = invM;
+        for(unsigned int j(0); j < m; ++j)
+        {
+            Primitive Tile;
+
+            Tile.pushTriangle(basegfx::B2DVector( iPDn , jDm ) , basegfx::B2DVector( iDn , jDm ) , basegfx::B2DVector( iDn , jPDm ));
+
+            Tile.pushTriangle(basegfx::B2DVector( iPDn , jPDm ) , basegfx::B2DVector( iPDn , jDm ) , basegfx::B2DVector( iDn , jPDm ));//bottom left corner of tile            
+
+            Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 1 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , 180 , true, iDn*jDm/2.0 , ((iPDn*jPDm)+1.0)/2.0 ) );
+            maLeavingSlidePrimitives.push_back(Tile);
+            Tile.Operations.push_back( new SRotate( basegfx::B3DVector( 1 , 1 , 0 ) , ( Tile.getVertices()[1] + Tile.getVertices()[3] )/2.0 , -180, false, iDn*jDm/2.0 , ((iPDn*jPDm)+1.0)/2.0 ) );
+
+            maEnteringSlidePrimitives.push_back(Tile);
+
+            jDm += invM;
+            jPDm += invM;
+        }
+        iDn += invN;
+        iPDn += invN;
+    }
+}
+
+SRotate::SRotate(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+SScale::SScale(const basegfx::B3DVector& Scale,const basegfx::B3DVector& Origin, bool bInter, double T0, double T1):scale(Scale),origin(Origin)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+RotateAndScaleDepthByWidth::RotateAndScaleDepthByWidth(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle, bool bInter, double T0, double T1):axis(Axis),origin(Origin),angle(Angle)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+
+STranslate::STranslate(const basegfx::B3DVector& Vector, bool bInter, double T0, double T1):vector(Vector)
+{
+    nT0 = T0;
+    nT1 = T1;
+    bInterpolate = bInter;
+}
+
+inline double intervalInter(double t, double T0, double T1)
+{
+    return ( t - T0 ) / ( T1 - T0 );
+}
+
+void STranslate::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*t*vector.getX(),SlideHeightScale*t*vector.getY(),t*vector.getZ());
+}
+
+void SRotate::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),origin.getZ());
+    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-origin.getZ());
+}
+
+void SScale::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),origin.getZ());
+    glScaled((1-t) + t*scale.getX(),(1-t) + t*scale.getY(),(1-t) + t*scale.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-origin.getZ());
+}
+
+void RotateAndScaleDepthByWidth::interpolate(double t,double SlideWidthScale,double SlideHeightScale)
+{
+    if(t <= nT0)
+        return;
+    if(!bInterpolate || t > nT1)
+        t = nT1;
+    t = intervalInter(t,nT0,nT1);
+    glTranslated(SlideWidthScale*origin.getX(),SlideHeightScale*origin.getY(),SlideWidthScale*origin.getZ());
+    glRotated(t*angle,axis.getX(),axis.getY(),axis.getZ());
+    glTranslated(-SlideWidthScale*origin.getX(),-SlideHeightScale*origin.getY(),-SlideWidthScale*origin.getZ());
+}
+
+STranslate* STranslate::clone()
+{
+    return new STranslate(*this);
+}
+SRotate* SRotate::clone()
+{
+    return new SRotate(*this);
+}
+
+SScale* SScale::clone()
+{
+    return new SScale(*this);
+}
+
+RotateAndScaleDepthByWidth* RotateAndScaleDepthByWidth::clone()
+{
+    return new RotateAndScaleDepthByWidth(*this);
+}
+
+const Primitive& Primitive::operator=(const Primitive& rvalue)
+{
+    for(unsigned int i( 0 ); i < rvalue.Operations.size(); ++i)
+        Operations.push_back(rvalue.Operations[i]->clone());
+    for(unsigned int i( 0 ); i < rvalue.Vertices.size(); ++i)//SPEED! use std::copy or something. this is slow.
+        Vertices.push_back(rvalue.Vertices[i]);
+    for(unsigned int i( 0 ); i < rvalue.TexCoords.size(); ++i)//SPEED! use std::copy or something. this is slow.
+        TexCoords.push_back(rvalue.TexCoords[i]);
+    for(unsigned int i( 0 ); i < rvalue.Normals.size(); ++i)//SPEED! use std::copy or something. this is slow.
+        Normals.push_back(rvalue.Normals[i]);    
+    return *this;   
+}
+    
+Primitive::Primitive(const Primitive& rvalue)
+{
+    for(unsigned int i( 0 ); i < rvalue.Operations.size(); ++i)
+        Operations.push_back(rvalue.Operations[i]->clone());
+    for(unsigned int i( 0 ); i < rvalue.Vertices.size(); ++i)//SPEED! use std::copy or something. this is slow.
+        Vertices.push_back(rvalue.Vertices[i]);
+    for(unsigned int i( 0 ); i < rvalue.TexCoords.size(); ++i)//SPEED! use std::copy or something. this is slow.
+        TexCoords.push_back(rvalue.TexCoords[i]);
+    for(unsigned int i( 0 ); i < rvalue.Normals.size(); ++i)//SPEED! use std::copy or something. this is slow.
+        Normals.push_back(rvalue.Normals[i]);
+}
+
+void Primitive::pushTriangle(const basegfx::B2DVector& SlideLocation0,const basegfx::B2DVector& SlideLocation1,const basegfx::B2DVector& SlideLocation2)
+{
+    std::vector<basegfx::B3DVector> Verts;
+    std::vector<basegfx::B2DVector> Texs;
+    Verts.reserve(3);
+    Texs.reserve(3);
+
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation0.getX() - 1, -2*SlideLocation0.getY() + 1 , 0.0 ));
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation1.getX() - 1, -2*SlideLocation1.getY() + 1 , 0.0 ));
+    Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
+
+    //figure out if they're facing the correct way, and make them face the correct way.
+    basegfx::B3DVector Normal( cross( Verts[0] - Verts[1] , Verts[1] - Verts[2] ) );
+    if(Normal.getZ() >= 0.0)//if the normal is facing us
+    {
+        Texs.push_back(SlideLocation0);
+        Texs.push_back(SlideLocation1);
+        Texs.push_back(SlideLocation2);
+    }
+    else // if the normal is facing away from us, make it face us
+    {
+        Texs.push_back(SlideLocation0);
+        Texs.push_back(SlideLocation2);
+        Texs.push_back(SlideLocation1);
+        Verts.clear();
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation0.getX() - 1, -2*SlideLocation0.getY() + 1 , 0.0 ));
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation2.getX() - 1, -2*SlideLocation2.getY() + 1 , 0.0 ));
+        Verts.push_back(basegfx::B3DVector( 2*SlideLocation1.getX() - 1, -2*SlideLocation1.getY() + 1 , 0.0 ));
+    }
+
+    Vertices.push_back(Verts[0]);
+    Vertices.push_back(Verts[1]);
+    Vertices.push_back(Verts[2]);
+
+    TexCoords.push_back(Texs[0]);
+    TexCoords.push_back(Texs[1]);
+    TexCoords.push_back(Texs[2]);
+    
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+    Normals.push_back(basegfx::B3DVector(0,0,1));//all normals always face the screen when untransformed.
+}
+
Index: slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx
===================================================================
RCS file: slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx
diff -N slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ slideshow/source/engine/OGLTrans/OGLTrans_TransitionImpl.hxx	10 Oct 2007 21:03:44 -0000	1.1.2.8
@@ -0,0 +1,321 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2007 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef INCLUDED_SLIDESHOW_TRANSITION_HXX_
+#define INCLUDED_SLIDESHOW_TRANSITION_HXX_
+
+#include <basegfx/vector/b2dvector.hxx>
+#include <basegfx/vector/b3dvector.hxx>
+
+#include <vector>
+
+class Primitive;
+class Operation;
+
+/** OpenGL 3D Transition class. It implicitly is constructed from XOGLTransition
+
+	This class is capable of making itself into many difference transitions. It holds Primitives and Operations on those primitives.
+*/
+class OGLTransitionImpl
+{
+public:
+    OGLTransitionImpl() :
+        maLeavingSlidePrimitives(),
+        maEnteringSlidePrimitives()
+    {}
+
+    ~OGLTransitionImpl();
+    
+    void display( double nTime, ::sal_Int32 glLeavingSlideTex, ::sal_Int32 glEnteringSlideTex , double SlideWidthScale, double SlideHeightScale);
+    void makeOutsideCubeFaceToLeft();
+    void makeInsideCubeFaceToLeft();
+    void makeNByMTileFlip( ::sal_uInt16 n, ::sal_uInt16 m );
+    void makeRevolvingCircles( ::sal_uInt16 nCircles , ::sal_uInt16 nPointsOnCircles );
+    void makeHelix( ::sal_uInt16 nRows );
+
+private:
+    /** clears all the primitives and operations
+	*/
+    void clear();
+    
+    /** All the primitives that use the leaving slide texture
+	*/
+    std::vector<Primitive> maLeavingSlidePrimitives;
+    
+    /** All the primitives that use the leaving slide texture
+	*/
+    std::vector<Primitive> maEnteringSlidePrimitives;
+    
+    /** All the operations that should be applied to both leaving and entering slide primitives. These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
+	*/
+	std::vector<Operation*> OverallOperations;
+};
+
+/** This class is a list of Triangles that will share Operations, and could possibly share  
+*/
+class Primitive
+{
+public:
+    Primitive() {}
+    explicit Primitive(const Primitive& rvalue);
+	~Primitive();
+
+    void display(double nTime, double SlideWidthScale, double SlideHeightScale);
+    const Primitive& operator=(const Primitive& rvalue);
+    
+    /** PushBack a vertex,normal, and tex coord. Each SlideLocation is where on the slide is mapped to this location ( from (0,0) to (1,1)  ). This will make sure the correct aspect ratio is used, and helps to make slides begin and end at the correct position. (0,0) is the top left of the slide, and (1,1) is the bottom right.
+    
+    @param SlideLocation0
+    Location of first Vertex on slide
+    
+    @param SlideLocation1
+    Location of second Vertex on slide
+    
+    @param SlideLocation2
+    Location of third Vertex on slide
+    
+    */
+    void pushTriangle(const basegfx::B2DVector& SlideLocation0,const basegfx::B2DVector& SlideLocation1,const basegfx::B2DVector& SlideLocation2);
+    
+    /** clear all the vertices, normals, tex coordinates, and normals
+    */
+    void clearTriangles();
+    
+    /** guards against directly changing the vertices
+        
+        @return        
+        the list of vertices
+    */
+    const std::vector<basegfx::B3DVector>& getVertices() const {return Vertices;}
+    
+    /** guards against directly changing the vertices
+    */
+    const std::vector<basegfx::B3DVector>& getNormals() const {return Normals;}
+    
+    /** guards against directly changing the vertices
+    
+        @return        
+        the list of Texture Coordinates
+    
+    */
+    const std::vector<basegfx::B2DVector>& getTexCoords() const {return TexCoords;}
+
+    /** list of Operations to be performed on this primitive.These operations will be called in the order they were pushed back in. In OpenGL this effectively uses the operations in the opposite order they were pushed back.
+    
+        @return        
+        the list of Operations
+    
+    */    
+    std::vector<Operation*> Operations;
+
+private:
+    /** list of vertices
+    */
+	std::vector<basegfx::B3DVector> Vertices;
+	
+	/** list of Normals
+    */
+	std::vector<basegfx::B3DVector> Normals;
+	
+	/** list of Texture Coordinates
+    */
+	std::vector<basegfx::B2DVector> TexCoords;
+};
+
+/** This class is to be derived to make any operation (tranform) you may need in order to construct your transitions
+*/
+class Operation
+{
+public:
+	Operation(){}
+	virtual ~Operation(){}
+	
+	/** Should this operation be interpolated . If TRUE, the transform will smoothly move from making no difference from t = 0.0 to nT0 to being completely transformed from t = nT1 to 1. If FALSE, the transform will be inneffectual from t = 0 to nT0, and completely transformed from t = nT0 to 1. 
+	*/
+	bool bInterpolate;
+	
+	/** time to begin the transformation
+	*/
+	double nT0;
+	
+	/** time to finish the transformation
+	*/
+	double nT1;
+public:
+    /** this is the function that is called to give the Operation to OpenGL.
+        
+        @param t
+        time from t = 0 to t = 1
+        
+        @param SlideWidthScale
+        width of slide divided by width of window
+        
+        @param SlideHeightScale
+        height of slide divided by height of window
+    
+    */
+	virtual void interpolate(double t,double SlideWidthScale,double SlideHeightScale) = 0;
+	
+	/** return a copy of this operation
+	*/
+    virtual Operation* clone() = 0;
+};
+
+/** this class is a generic CounterClockWise(CCW) rotation with an axis angle
+*/
+class SRotate: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    virtual SRotate* clone();
+	
+	/** Constructor
+	    
+	    @param Axis
+	    axis to rotate about
+	    
+	    @param Origin
+	    position that rotation axis runs through
+	    
+	    @param Angle
+	    angle in radians of CCW rotation
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	SRotate(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
+	~SRotate(){}
+private:
+    /** axis to rotate CCW about
+    */
+	basegfx::B3DVector axis;
+	
+	/** position that rotation axis runs through
+	*/
+    basegfx::B3DVector origin;
+    
+    /** angle in radians of CCW rotation
+    */
+	double angle;
+};
+
+/** scaling transformation
+*/
+class SScale: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    SScale* clone();
+	
+	/** Constructor
+	    
+        @param Scale
+	    amount to scale by 
+	    
+	    @param Origin
+	    position that rotation axis runs through
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	SScale(const basegfx::B3DVector& Scale, const basegfx::B3DVector& Origin,bool bInter, double T0, double T1);
+	~SScale(){}
+private:
+	basegfx::B3DVector scale;
+	basegfx::B3DVector origin;
+};
+
+/** translation transformation
+*/
+class STranslate: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    STranslate* clone();
+	
+	/** Constructor
+	    
+	    @param Vector
+	    vector to translate
+	    
+	    @param bInter
+	    see Operation
+	    
+	    @param T0
+	    transformation starting time
+	    
+	    @param T1
+	    transformation ending time
+	
+	*/
+	STranslate(const basegfx::B3DVector& Vector,bool bInter, double T0, double T1);
+	~STranslate(){}
+private:
+    /** vector to translate by
+    */
+	basegfx::B3DVector vector;
+};
+
+/** Same as SRotate, except the depth is scaled by the width of the slide divided by the width of the window.
+*/
+class RotateAndScaleDepthByWidth: public Operation
+{
+public:
+	void interpolate(double t,double SlideWidthScale,double SlideHeightScale);
+    RotateAndScaleDepthByWidth* clone();
+
+	RotateAndScaleDepthByWidth(const basegfx::B3DVector& Axis,const basegfx::B3DVector& Origin,double Angle,bool bInter, double T0, double T1);
+	~RotateAndScaleDepthByWidth(){}
+private:
+	basegfx::B3DVector axis;
+    basegfx::B3DVector origin;
+	double angle;
+};
+
+#endif // INCLUDED_SLIDESHOW_TRANSITION_HXX_
+
Index: slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx
===================================================================
RCS file: slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx
diff -N slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ slideshow/source/engine/OGLTrans/OGLTrans_TransitionerImpl.cxx	10 Oct 2007 21:03:44 -0000	1.1.2.9
@@ -0,0 +1,570 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2007 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "OGLTrans_TransitionImpl.hxx"
+
+#include <com/sun/star/rendering/IntegerBitmapLayout.hpp>
+#include <com/sun/star/rendering/IntegerBitmapFormat.hpp>
+#include <com/sun/star/animations/TransitionType.hpp>
+#include <com/sun/star/animations/TransitionSubType.hpp>
+#include <com/sun/star/presentation/XTransitionFactory.hpp>
+#include <com/sun/star/presentation/XTransition.hpp>
+#include <com/sun/star/presentation/XSlideShowView.hpp>
+#include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
+#include <com/sun/star/geometry/IntegerSize2D.hpp>
+
+#include <cppuhelper/compbase1.hxx>
+#include <cppuhelper/basemutex.hxx>
+#include <cppuhelper/factory.hxx>
+#include <rtl/ref.hxx>
+
+#include <comphelper/servicedecl.hxx>
+
+#include <canvas/canvastools.hxx>
+#include <tools/gen.hxx>
+#include <vcl/window.hxx>
+#include <vcl/syschild.hxx>
+#include <vcl/sysdata.hxx>
+
+#include <boost/noncopyable.hpp>
+
+#include <GL/gl.h>
+#include <GL/glu.h>
+namespace unx
+{
+#include <X11/keysym.h>
+#include <GL/glx.h>
+}
+
+using namespace ::com::sun::star;
+
+namespace
+{
+
+typedef cppu::WeakComponentImplHelper1<presentation::XTransition> OGLTransitionerImplBase;
+
+/** This is the Transitioner class for OpenGL 3D transitions in
+ * slideshow. At the moment, it's Linux only. This class is implicitly
+ * constructed from XTransitionFactory.
+*/
+class OGLTransitionerImpl : private cppu::BaseMutex, private boost::noncopyable, public OGLTransitionerImplBase
+{
+public:
+    explicit OGLTransitionerImpl(OGLTransitionImpl* pOGLTransition);
+    void initWindowFromSlideShowView( const uno::Reference< presentation::XSlideShowView >& xView, double, double);
+    void setSlides( const uno::Reference< rendering::XBitmap >& xLeavingSlide , const uno::Reference< rendering::XBitmap >& xEnteringSlide );
+
+    // XTransition
+    virtual SAL_CALL void update( double nTime ) throw (uno::RuntimeException);
+    
+protected:
+    // WeakComponentImplHelperBase
+    virtual void SAL_CALL disposing();
+    
+    bool isDisposed() const
+    {
+        return (rBHelper.bDisposed || rBHelper.bInDispose);
+    }
+
+private:    
+    /** After the window has been created, and the slides have been set, we'll initialize the slides with OpenGL.
+    */
+    void GLInitSlides();
+    
+    /// Holds the information of our new child window
+    struct GLWindow
+    {
+    	unx::Display*           dpy;
+    	int						screen;
+    	unx::Window				win;
+    	unx::GLXContext			ctx;
+    	unsigned int			bpp;
+    	unsigned int            Width;
+    	unsigned int            Height;
+    } GLWin;
+    
+    /** OpenGL handle to the leaving slide's texture
+    */
+    unsigned int GLleavingSlide;
+    /** OpenGL handle to the entering slide's texture
+    */
+    unsigned int GLenteringSlide;
+    
+    /** pointer to our window which we MIGHT create.
+    */
+    class SystemChildWindow* pWindow;
+    
+    /** raw bytes of the entering bitmap
+    */
+    uno::Sequence<signed char> EnteringBytes;
+    
+    /** raw bytes of the leaving bitmap
+    */
+    uno::Sequence<signed char> LeavingBytes;
+    
+    /** the form the raw bytes are in for the bitmaps
+    */
+    rendering::IntegerBitmapLayout SlideBitmapLayout; 
+    
+    /** the size of the slides
+    */    
+    geometry::IntegerSize2D SlideSize;
+    
+    /** Our Transition to be used.
+    */    
+    OGLTransitionImpl* pTransition;
+};
+
+void OGLTransitionerImpl::initWindowFromSlideShowView( const uno::Reference< presentation::XSlideShowView >& xView, double, double)
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed())
+        return;
+
+    /// take the XSlideShowView and extract the parent window from it. see viewmediashape.cxx
+    uno::Reference< rendering::XCanvas > xCanvas(xView->getCanvas(), uno::UNO_QUERY_THROW);
+	uno::Sequence< uno::Any > aDeviceParams;
+	::canvas::tools::getDeviceInfo( xCanvas, aDeviceParams );
+	::rtl::OUString aImplName;
+	aDeviceParams[ 0 ] >>= aImplName;
+	sal_Int64 aVal = 0;
+	aDeviceParams[1] >>= aVal;
+	Window* pPWindow = reinterpret_cast< Window* >( aVal );
+	GLWin.Width = pPWindow->GetSizePixel().Width();
+	GLWin.Height = pPWindow->GetSizePixel().Height();
+
+    const SystemEnvData* sysData(pPWindow->GetSystemData());
+    GLWin.dpy = reinterpret_cast<unx::Display*>(sysData->pDisplay);
+    GLWin.win = sysData->aWindow;
+    GLWin.screen = unx::XDefaultScreen(GLWin.dpy);
+    unx::XVisualInfo* vi( NULL );
+    static int attrList3[] =
+        {
+            GLX_RGBA,//only TrueColor or DirectColor
+            //single buffered
+            GLX_RED_SIZE,4,//use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,//use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,//use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,0,//no depth buffer
+            None
+        };
+    static int attrList2[] = 
+        {
+            GLX_RGBA,/// only TrueColor or DirectColor
+            /// single buffered
+            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,1,/// use the maximum depth bits, making sure there is a depth buffer
+            None
+        };
+    static int attrList1[] =
+        {
+            GLX_RGBA,/// only TrueColor or DirectColor
+            GLX_DOUBLEBUFFER,/// only double buffer
+            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,0,/// no depth buffer
+            None
+        };
+    static int attrList0[] =
+        {
+            GLX_RGBA,/// only TrueColor or DirectColor
+            GLX_DOUBLEBUFFER,/// only double buffer
+            GLX_RED_SIZE,4,/// use the maximum red bits, with a minimum of 4 bits
+            GLX_GREEN_SIZE,4,/// use the maximum green bits, with a minimum of 4 bits
+            GLX_BLUE_SIZE,4,/// use the maximum blue bits, with a minimum of 4 bits
+            GLX_DEPTH_SIZE,1,/// use the maximum depth bits, making sure there is a depth buffer
+            None
+       }; 
+    static int* attrTable[] = 
+        {
+            attrList0,
+            attrList1,
+            attrList2,
+            attrList3,
+            NULL
+        };
+	int** pAttributeTable = attrTable;
+    const SystemEnvData* pChildSysData = NULL;
+    delete pWindow;
+    pWindow=NULL;
+    while( *pAttributeTable )
+    {
+        // try to find a visual for the current set of attributes
+        vi = unx::glXChooseVisual( GLWin.dpy,
+                                   GLWin.screen,
+                                   *pAttributeTable );
+    
+        if( vi )
+        {
+            SystemWindowData winData;
+            winData.nSize = sizeof(winData);
+            winData.pVisual = (void*)(vi->visual);
+            pWindow=new SystemChildWindow(pPWindow,
+                                          0,
+                                          &winData);
+            pChildSysData = pWindow->GetSystemData();
+            if( pChildSysData )
+            {
+                break;
+            }
+            else
+            {
+                delete pWindow, pWindow=NULL;
+            }
+        }
+        ++pAttributeTable;
+    }
+
+    if( pWindow )
+    {
+        OSL_TRACE("OGLTrans: using VisualID %08X\n",
+                  vi->visualid);
+
+        pWindow->SetMouseTransparent( TRUE );
+        pWindow->SetParentClipMode( PARENTCLIPMODE_NOCLIP );
+        pWindow->EnableEraseBackground( FALSE );
+        pWindow->SetControlForeground();
+        pWindow->SetControlBackground();
+        pWindow->EnablePaint(FALSE);
+        pWindow->SetPosSizePixel(pPWindow->GetPosPixel(),pPWindow->GetSizePixel());
+
+        GLWin.dpy = reinterpret_cast<unx::Display*>(pChildSysData->pDisplay);
+        GLWin.win = pChildSysData->aWindow;
+    }
+
+    GLWin.ctx = glXCreateContext(GLWin.dpy,
+                                 vi,
+                                 0,
+                                 GL_TRUE);
+
+    glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx );
+
+    OSL_ENSURE( glXIsDirect(GLWin.dpy, GLWin.ctx) , "Can't Directly Render to the Screen, perhaps 3D transitions aren't for you." );
+    glEnable(GL_CULL_FACE);
+    glCullFace(GL_BACK);
+    glClear(GL_COLOR_BUFFER_BIT);
+    unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
+    
+    glEnable(GL_LIGHTING);
+    GLfloat light_direction[] = { 0.0 , 0.0 , 1.0 };
+    GLfloat materialDiffuse[] = { 1.0 , 1.0 , 1.0 , 1.0};
+    glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, light_direction);
+    glMaterialfv(GL_FRONT,GL_DIFFUSE,materialDiffuse);
+    glEnable(GL_LIGHT0);
+    glEnable(GL_NORMALIZE);
+        
+    if( EnteringBytes.hasElements() && EnteringBytes.hasElements())
+       GLInitSlides();//we already have uninitialized slides, let's initialize 
+}
+
+void OGLTransitionerImpl::setSlides( const uno::Reference< rendering::XBitmap >& xLeavingSlide, 
+                                     const uno::Reference< rendering::XBitmap >& xEnteringSlide )
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed())
+        return;
+        
+    uno::Reference< rendering::XIntegerBitmap > LeavingSlideIntBitmap( xLeavingSlide , uno::UNO_QUERY_THROW );
+    uno::Reference< rendering::XIntegerBitmap > EnteringSlideIntBitmap( xEnteringSlide , uno::UNO_QUERY_THROW );
+
+    geometry::IntegerRectangle2D SlideRect;
+    SlideSize = LeavingSlideIntBitmap->getSize();
+    SlideRect.X1 = 0;
+    SlideRect.X2 = SlideSize.Width;
+    SlideRect.Y1 = 0;
+    SlideRect.Y2 = SlideSize.Height;
+
+    LeavingBytes = LeavingSlideIntBitmap->getData(SlideBitmapLayout,SlideRect);
+    EnteringBytes = EnteringSlideIntBitmap->getData(SlideBitmapLayout,SlideRect);
+
+
+    if(GLWin.ctx)//if we have a rendering context, let's init the slides
+        GLInitSlides();
+
+    OSL_ENSURE(SlideBitmapLayout.Endianness == 0,"only handle little endian now");
+    OSL_ENSURE(SlideBitmapLayout.PlaneStride == 0,"only handle no plane stride now");
+}
+
+void OGLTransitionerImpl::GLInitSlides()
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed())
+        return;
+
+    glMatrixMode(GL_PROJECTION);
+    glLoadIdentity();
+    double EyePos(10.0);
+    double RealF(-1.0);
+    double RealN(1.0);
+    double RealL(-1.0);
+    double RealR(1.0);
+    double RealB(-1.0);
+    double RealT(1.0);
+    double ClipN(EyePos+2.0*RealN);
+    double ClipF(EyePos+2.0*RealF);
+    double ClipL(RealL*8.0);
+    double ClipR(RealR*8.0);
+    double ClipB(RealB*8.0);
+    double ClipT(RealT*8.0);
+    //This scaling is to take the plane with BottomLeftCorner(-1,-1,0) and TopRightCorner(1,1,0) and map it to the screen after the perspective division.
+    glScaled( 1.0 / ( ( ( RealR * 2.0 * ClipN ) / ( EyePos * ( ClipR - ClipL ) ) ) - ( ( ClipR + ClipL ) / ( ClipR - ClipL ) ) ), 1 / ( ( ( RealT * 2.0 * ClipN ) / ( EyePos * ( ClipT - ClipB ) ) ) - ( ( ClipT + ClipB ) / ( ClipT - ClipB ) ) ) , 1.0 );
+	glFrustum(ClipL,ClipR,ClipB,ClipT,ClipN,ClipF);
+    glMatrixMode(GL_MODELVIEW);
+    glLoadIdentity();
+    glTranslated(0,0,-EyePos);
+
+    GLint internalFormat;
+    GLint Format;
+	switch( SlideBitmapLayout.NumComponents )
+	{
+	case 3:
+	    Format = GL_RGB;
+	    break;
+	case 4:
+	    Format = GL_RGBA;
+	    break;
+	default:
+	    OSL_ENSURE(false, "unsupported number of color components");
+	    Format = GL_RGB;
+	}
+	
+	switch( SlideBitmapLayout.Format )
+	{
+	case rendering::IntegerBitmapFormat::CHUNKY_16BIT:
+	    switch( Format)
+	    {
+	    case GL_RGBA:
+	        internalFormat = GL_RGBA4;
+	        break;
+	    default:
+	    OSL_ENSURE(false, "unsupported bitmap integer format");
+	    internalFormat = GL_RGBA;
+	    }
+	    break;
+	case rendering::IntegerBitmapFormat::CHUNKY_24BIT:
+	    switch( Format)
+	    {
+	    case GL_RGB:
+	        internalFormat = GL_RGB8;
+	        Format = GL_BGR;//24 bit bitmaps are BGR, not RGB
+	        break;
+	    default:
+	        OSL_ENSURE(false, "unsupported bitmap integer format");
+	        internalFormat = GL_RGB;
+	        Format = GL_BGR;//24 bit bitmaps are BGR, not RGB
+	    }
+	    break;
+	case rendering::IntegerBitmapFormat::CHUNKY_32BIT:
+	    switch( Format)
+	    {
+	    case GL_RGBA:
+	        Format = GL_BGRA;//32 bit bitmaps are BGRA, not RGBA
+	        internalFormat = GL_RGBA8;
+	        break;
+	    default:
+	    OSL_ENSURE(false, "unsupported bitmap integer format");
+	    internalFormat = GL_RGBA;
+	    Format = GL_BGRA;//32 bit bitmaps are BGRA, not RGBA
+	    }
+	    break;
+	default:
+	    OSL_ENSURE(false, "unsupported bitmap integer format");
+	    internalFormat = GL_RGB;
+	}
+
+    glDeleteTextures(1,&GLleavingSlide);
+    
+    glGenTextures(1, &GLleavingSlide);
+	glBindTexture(GL_TEXTURE_2D, GLleavingSlide);
+	gluBuild2DMipmaps(GL_TEXTURE_2D, internalFormat , SlideSize.Width, SlideSize.Height, Format, GL_UNSIGNED_BYTE, &LeavingBytes[0]);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);//TRILINEAR FILTERING
+	GLfloat largest_supported_anisotropy;
+	glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &largest_supported_anisotropy);
+	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, largest_supported_anisotropy);//anistropic filtering (to make texturing not suck when looking at polygons from oblique angles)
+	
+	OSL_ENSURE(glIsTexture(GLleavingSlide), "Can't generate Leaving slide textures in OpenGL");
+	
+	glDeleteTextures(1,&GLenteringSlide);
+	
+	glGenTextures(1, &GLenteringSlide);
+	glBindTexture(GL_TEXTURE_2D, GLenteringSlide);
+	gluBuild2DMipmaps(GL_TEXTURE_2D, internalFormat , SlideSize.Width, SlideSize.Height, Format, GL_UNSIGNED_BYTE, &EnteringBytes[0]);
+    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);//TRILINEAR FILTERING
+	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, largest_supported_anisotropy);//anistropic filtering (to make texturing not suck when looking at polygons from oblique angles)
+	
+	OSL_ENSURE( glIsTexture(GLenteringSlide), "Can't generate entering slide textures in OpenGL" );
+}
+
+void SAL_CALL OGLTransitionerImpl::update( double nTime ) throw (uno::RuntimeException)
+{
+    osl::MutexGuard const guard( m_aMutex );
+
+    if (isDisposed())
+        return;
+        
+    glEnable(GL_DEPTH_TEST);
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+	//glLoadIdentity();
+	if(pTransition)
+	    pTransition->display( nTime , GLleavingSlide , GLenteringSlide , 
+                              SlideSize.Width/static_cast<double>(GLWin.Width),
+                              SlideSize.Height/static_cast<double>(GLWin.Height) );
+	unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
+	if( pWindow )
+        pWindow->Show();
+}
+
+// we are about to be disposed (someone call dispose() on us)
+void OGLTransitionerImpl::disposing()
+{
+    osl::MutexGuard const guard( m_aMutex );
+    glDeleteTextures(1,&GLleavingSlide);
+    glDeleteTextures(1,&GLenteringSlide);
+    if(GLWin.ctx)
+	{
+	    OSL_ENSURE( glXMakeCurrent(GLWin.dpy, None, NULL) , "Error releasing glX context" );
+		glXDestroyContext(GLWin.dpy, GLWin.ctx);
+		GLWin.ctx = NULL;
+	}
+	delete pWindow;
+    delete pTransition;
+}
+
+OGLTransitionerImpl::OGLTransitionerImpl(OGLTransitionImpl* pOGLTransition) : 
+    OGLTransitionerImplBase(m_aMutex), 
+    GLWin(),
+    GLleavingSlide( 0 ), 
+    GLenteringSlide( 0 ), 
+    pWindow( NULL ), 
+    EnteringBytes(),
+    LeavingBytes(),
+    SlideBitmapLayout(),
+    SlideSize(),
+    pTransition(pOGLTransition)
+{
+    GLWin.ctx = 0;
+}
+
+typedef cppu::WeakComponentImplHelper1<presentation::XTransitionFactory> OGLTransitionFactoryImplBase;
+
+class OGLTransitionFactoryImpl : private cppu::BaseMutex, public OGLTransitionFactoryImplBase
+{
+public:
+    explicit OGLTransitionFactoryImpl( const uno::Reference< uno::XComponentContext >& ) :
+        OGLTransitionFactoryImplBase(m_aMutex)
+    {}
+
+    // XTransitionFactory
+    virtual ::sal_Bool SAL_CALL hasTransition( ::sal_Int16 transitionType, ::sal_Int16 transitionSubType ) throw (uno::RuntimeException)
+    {
+        return createTransition(transitionType, 
+                                transitionSubType, 
+                                uno::Reference< presentation::XSlideShowView >(),
+                                uno::Reference< rendering::XBitmap >(),
+                                uno::Reference< rendering::XBitmap >(),
+                                geometry::RealPoint2D()).is();
+    }
+
+    virtual uno::Reference< presentation::XTransition > SAL_CALL createTransition( 
+        ::sal_Int16                                           transitionType, 
+        ::sal_Int16                                           transitionSubType, 
+        const uno::Reference< presentation::XSlideShowView >& view, 
+        const uno::Reference< rendering::XBitmap >&           leavingBitmap, 
+        const uno::Reference< rendering::XBitmap >&           enteringBitmap, 
+        const geometry::RealPoint2D&                          slideOffset ) throw (uno::RuntimeException)
+    {
+        if( transitionType != animations::TransitionType::MISCSHAPEWIPE )
+            return uno::Reference< presentation::XTransition >();
+
+        OGLTransitionImpl* pTransition = new OGLTransitionImpl();
+        switch( transitionSubType )
+        {
+            case animations::TransitionSubType::ACROSS:
+                pTransition->makeNByMTileFlip(5,5);
+                break;   
+            case animations::TransitionSubType::CORNERSOUT:
+                pTransition->makeOutsideCubeFaceToLeft();
+                break;            
+            case animations::TransitionSubType::CIRCLE:
+                pTransition->makeRevolvingCircles(5,20);
+                break;
+            case animations::TransitionSubType::FANOUTHORIZONTAL:
+                pTransition->makeHelix(20);
+                break;
+            case animations::TransitionSubType::CORNERSIN :  
+                pTransition->makeInsideCubeFaceToLeft();
+                break;
+            default:
+                return uno::Reference< presentation::XTransition >();
+        }
+        
+        rtl::Reference<OGLTransitionerImpl> xRes(
+            new OGLTransitionerImpl(pTransition) );
+        xRes->initWindowFromSlideShowView(view,slideOffset.X,slideOffset.Y);
+        xRes->setSlides(leavingBitmap,enteringBitmap);
+
+        return uno::Reference<presentation::XTransition>(xRes.get());
+    }
+};
+
+}
+
+namespace sdecl = comphelper::service_decl;
+#if defined (__GNUC__) && (__GNUC__ == 3 && __GNUC_MINOR__ <= 3)
+ sdecl::class_<OGLTransitionFactoryImpl> serviceImpl;
+ const sdecl::ServiceDecl OGLTransitionFactoryDecl(
+     serviceImpl,
+#else
+ const sdecl::ServiceDecl OGLTransitionFactoryDecl(
+     sdecl::class_<OGLTransitionFactoryImpl>(),
+#endif
+    "com.sun.star.comp.presentation.OGLTransitionFactory",
+    "com.sun.star.presentation.TransitionFactory" );
+
+// The C shared lib entry points
+COMPHELPER_SERVICEDECL_EXPORTS1(OGLTransitionFactoryDecl)
Index: slideshow/source/engine/OGLTrans/exports.dxp
===================================================================
RCS file: slideshow/source/engine/OGLTrans/exports.dxp
diff -N slideshow/source/engine/OGLTrans/exports.dxp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ slideshow/source/engine/OGLTrans/exports.dxp	8 Aug 2007 03:40:27 -0000	1.1.2.1
@@ -0,0 +1,3 @@
+component_getImplementationEnvironment
+component_writeInfo
+component_getFactory
Index: slideshow/source/engine/OGLTrans/exports.map
===================================================================
RCS file: slideshow/source/engine/OGLTrans/exports.map
diff -N slideshow/source/engine/OGLTrans/exports.map
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ slideshow/source/engine/OGLTrans/exports.map	8 Aug 2007 03:40:27 -0000	1.1.2.1
@@ -0,0 +1,8 @@
+SLI_1_0 {
+	global:
+		component_getImplementationEnvironment;
+		component_writeInfo;
+		component_getFactory;
+	local:
+		*;
+};
Index: slideshow/source/engine/OGLTrans/makefile.mk
===================================================================
RCS file: slideshow/source/engine/OGLTrans/makefile.mk
diff -N slideshow/source/engine/OGLTrans/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ slideshow/source/engine/OGLTrans/makefile.mk	8 Aug 2007 03:39:30 -0000	1.1.2.8
@@ -0,0 +1,83 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=slideshow
+TARGET=OGLTrans
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------------
+
+.INCLUDE :      settings.mk
+.INCLUDE : $(PRJ)$/util$/makefile.pmk
+
+# --- Nothing to do if we're compiling with --disable-opengl -----------
+.IF "$(ENABLE_OPENGL)" != "TRUE"
+@all:
+	@echo "Building without OpenGL Transitions..."
+.ENDIF
+
+# --- Common ----------------------------------------------------------
+#.IF "$(GUI)"=="UNX"
+
+#.IF "$(SYSTEM_OPENGL)" == "YES"
+CFLAGS+=$(OGLTRANS_CFLAGS)
+#.ELSE
+#CFLAGS+=-I$(SOLARINCDIR)/OGLTrans
+#.ENDIF
+
+SLOFILES = \
+        $(SLO)$/OGLTrans_TransitionImpl.obj \
+        $(SLO)$/OGLTrans_TransitionerImpl.obj
+        
+SHL1TARGET=$(TARGET).uno
+
+SHL1STDLIBS= $(SALLIB) $(VCLLIB) $(CPPULIB) $(CPPUHELPERLIB) $(COMPHELPERLIB) $(CANVASTOOLSLIB) -lGL -lGLU -lX11
+
+SHL1IMPLIB=i$(TARGET)
+SHL1LIBS=$(SLB)$/$(TARGET).lib
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+
+SHL1VERSIONMAP=exports.map
+
+DEF1NAME=$(SHL1TARGET)
+DEF1EXPORTFILE=exports.dxp
+
+#.ENDIF
+
+# ==========================================================================
+
+.INCLUDE :	target.mk
Index: slideshow/source/engine/activities/activitiesfactory.cxx
===================================================================
RCS file: /cvs/graphics/slideshow/source/engine/activities/activitiesfactory.cxx,v
retrieving revision 1.10
retrieving revision 1.10.6.1
diff -u -p -u -p -r1.10 -r1.10.6.1
--- slideshow/source/engine/activities/activitiesfactory.cxx	17 Jul 2007 14:44:06 -0000	1.10
+++ slideshow/source/engine/activities/activitiesfactory.cxx	28 Aug 2007 07:55:18 -0000	1.10.6.1
@@ -844,11 +844,13 @@ public:
     {
         if (this->isDisposed() || !mpAnim)
             return;
-        ContinuousActivityBase::startAnimation();
+        
         
         // start animation
         mpAnim->start( getShape(),
                        getShapeAttributeLayer() );
+                       
+        ContinuousActivityBase::startAnimation();
     }
     
     virtual void endAnimation()
Index: slideshow/source/engine/animationnodes/animationnodefactory.cxx
===================================================================
RCS file: /cvs/graphics/slideshow/source/engine/animationnodes/animationnodefactory.cxx,v
retrieving revision 1.11
retrieving revision 1.11.4.1
diff -u -p -u -p -r1.11 -r1.11.4.1
--- slideshow/source/engine/animationnodes/animationnodefactory.cxx	17 Jul 2007 14:47:27 -0000	1.11
+++ slideshow/source/engine/animationnodes/animationnodefactory.cxx	10 Oct 2007 12:02:30 -0000	1.11.4.1
@@ -618,8 +618,8 @@ AnimationNodeSharedPtr AnimationNodeFact
 void AnimationNodeFactory::showTree( AnimationNodeSharedPtr& pRootNode )
 {
     if( pRootNode )
-        DEBUG_NODES_SHOWTREE( dynamic_cast<BaseContainerNode*>(
-                                  pRootNode));
+        DEBUG_NODES_SHOWTREE( boost::dynamic_pointer_cast<BaseContainerNode>(
+                                  pRootNode).get() );
 }
 #endif
 
Index: slideshow/source/engine/shapes/viewshape.cxx
===================================================================
RCS file: /cvs/graphics/slideshow/source/engine/shapes/viewshape.cxx,v
retrieving revision 1.2
retrieving revision 1.2.4.1
diff -u -p -u -p -r1.2 -r1.2.4.1
--- slideshow/source/engine/shapes/viewshape.cxx	17 Jul 2007 14:55:49 -0000	1.2
+++ slideshow/source/engine/shapes/viewshape.cxx	10 Oct 2007 12:02:31 -0000	1.2.4.1
@@ -48,6 +48,9 @@
 #include <com/sun/star/rendering/PanoseLetterForm.hpp>
 #include <com/sun/star/awt/FontSlant.hpp>
 
+#include <cppuhelper/exc_hlp.hxx>
+#include <comphelper/anytostring.hxx>
+
 #include <basegfx/polygon/b2dpolygontools.hxx>
 #include <basegfx/numeric/ftools.hxx>
 #include <basegfx/matrix/b2dhommatrix.hxx>
Index: slideshow/source/engine/transitions/slidetransitionfactory.cxx
===================================================================
RCS file: /cvs/graphics/slideshow/source/engine/transitions/slidetransitionfactory.cxx,v
retrieving revision 1.14
retrieving revision 1.13.26.13
diff -u -p -u -p -r1.14 -r1.13.26.13
--- slideshow/source/engine/transitions/slidetransitionfactory.cxx	17 Jul 2007 15:00:21 -0000	1.14
+++ slideshow/source/engine/transitions/slidetransitionfactory.cxx	10 Oct 2007 21:03:44 -0000	1.13.26.13
@@ -39,6 +39,7 @@
 #include <canvas/debug.hxx>
 
 #include <basegfx/matrix/b2dhommatrix.hxx>
+#include <basegfx/tools/canvastools.hxx>
 #include <basegfx/polygon/b2dpolygontools.hxx>
 #include <basegfx/polygon/b2dpolypolygontools.hxx>
 
@@ -47,8 +48,11 @@
 #include <comphelper/optional.hxx>
 #include <comphelper/make_shared_from_uno.hxx>
 
+#include <com/sun/star/rendering/XIntegerBitmap.hpp>
+#include <com/sun/star/rendering/IntegerBitmapLayout.hpp>
 #include <com/sun/star/animations/TransitionType.hpp>
 #include <com/sun/star/animations/TransitionSubType.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
 
 #include "slidechangebase.hxx"
 #include "transitionfactory.hxx"
@@ -59,6 +63,8 @@
 #include "combtransition.hxx"
 #include "tools.hxx"
 
+#include <boost/bind.hpp>
+
 
 /***************************************************
  ***                                             ***
@@ -102,6 +108,70 @@ void fillPage( const ::cppcanvas::Canvas
               rFillColor.getIntegerColor() );
 }
 
+class PluginSlideChange: public SlideChangeBase
+{
+public:
+    /** Create a new SlideChanger, for the given leaving and
+        entering slide bitmaps, which uses super secret OpenGL
+        stuff.
+    */
+    PluginSlideChange( sal_Int16                                nTransitionType,
+                       sal_Int16                                nTransitionSubType,
+                       boost::optional<SlideSharedPtr> const&   leavingSlide_,
+                       const SlideSharedPtr&                    pEnteringSlide,
+                       const UnoViewContainer&                  rViewContainer,
+                       ScreenUpdater&                           rScreenUpdater,
+                       const uno::Reference<
+                             presentation::XTransitionFactory>& xFactory,
+                       const SoundPlayerSharedPtr&              pSoundPlayer, 
+                       EventMultiplexer&                        rEventMultiplexer) :
+        SlideChangeBase( leavingSlide_,
+                         pEnteringSlide,
+                         pSoundPlayer,
+                         rViewContainer,
+                         rScreenUpdater,
+                         rEventMultiplexer ),
+        maTransitions()
+    {
+        // create one transition per view
+        UnoViewVector::const_iterator aCurrView (rViewContainer.begin());
+        const UnoViewVector::const_iterator aEnd(rViewContainer.end());
+        while( aCurrView != aEnd )
+        {
+            const ::basegfx::B2DHomMatrix aViewTransform(
+                (*aCurrView)->getCanvas()->getTransformation() );
+            const ::basegfx::B2DPoint aOffsetPixel(
+                aViewTransform * ::basegfx::B2DPoint() );
+        
+            maTransitions.push_back(
+                xFactory->createTransition( 
+                    nTransitionType, 
+                    nTransitionSubType,
+                    (*aCurrView)->getUnoView(),
+                    getLeavingBitmap(ViewEntry(*aCurrView))->getXBitmap(),
+                    getEnteringBitmap(ViewEntry(*aCurrView))->getXBitmap(),
+                    basegfx::unotools::point2DFromB2DPoint(aOffsetPixel) ) );
+
+            ENSURE_AND_THROW(maTransitions.back().is(),
+                             "Failed to create plugin transition");
+            ++aCurrView;
+        }
+    }
+        
+    virtual bool operator()( double t )
+    {
+        std::for_each(maTransitions.begin(),
+                      maTransitions.end(),
+                      boost::bind( &presentation::XTransition::update,
+                                   _1, t) );
+        return true;
+    }
+
+private:
+    // One transition object per view
+    std::vector< uno::Reference<presentation::XTransition> > maTransitions;
+};
+
 
 class ClippedSlideChange : public SlideChangeBase
 {
@@ -610,20 +680,46 @@ NumberAnimationSharedPtr createSlideWipe
     }
 }
 
+NumberAnimationSharedPtr createPluginTransition(
+    sal_Int16                                nTransitionType,
+    sal_Int16                                nTransitionSubType,
+    boost::optional<SlideSharedPtr> const&   pLeavingSlide,
+    const SlideSharedPtr&                    pEnteringSlide,
+    const UnoViewContainer&                  rViewContainer,
+    ScreenUpdater&                           rScreenUpdater,
+    const uno::Reference<
+          presentation::XTransitionFactory>& xFactory,
+    const SoundPlayerSharedPtr&              pSoundPlayer, 
+    EventMultiplexer&                        rEventMultiplexer)
+{
+    return NumberAnimationSharedPtr( 
+        new PluginSlideChange(
+            nTransitionType,
+            nTransitionSubType,
+            pLeavingSlide,
+            pEnteringSlide,
+            rViewContainer,
+            rScreenUpdater,
+            xFactory,
+            pSoundPlayer,
+            rEventMultiplexer ));
+}
+
 } // anon namespace
 
 
 NumberAnimationSharedPtr TransitionFactory::createSlideTransition(
-    const SlideSharedPtr&       pLeavingSlide,
-    const SlideSharedPtr&       pEnteringSlide,
-    const UnoViewContainer&     rViewContainer,
-    ScreenUpdater&              rScreenUpdater,
-    EventMultiplexer&           rEventMultiplexer,
-    sal_Int16                   nTransitionType,
-    sal_Int16                   nTransitionSubType,
-    bool                        bTransitionDirection,
-    const RGBColor&  			rTransitionFadeColor,
-    const SoundPlayerSharedPtr& pSoundPlayer            )
+    const SlideSharedPtr&                                   pLeavingSlide,
+    const SlideSharedPtr&                                   pEnteringSlide,
+    const UnoViewContainer&                                 rViewContainer,
+    ScreenUpdater&                                          rScreenUpdater,
+    EventMultiplexer&                                       rEventMultiplexer,
+    const uno::Reference<presentation::XTransitionFactory>& xOptionalFactory,
+    sal_Int16                                               nTransitionType,
+    sal_Int16                                               nTransitionSubType,
+    bool                                                    bTransitionDirection,
+    const RGBColor&                                         rTransitionFadeColor,
+    const SoundPlayerSharedPtr&                             pSoundPlayer            )
 {
     // xxx todo: change to TransitionType::NONE, TransitionSubType::NONE:
     if (nTransitionType == 0 && nTransitionSubType == 0) {
@@ -640,6 +736,23 @@ NumberAnimationSharedPtr TransitionFacto
         pEnteringSlide,
         "TransitionFactory::createSlideTransition(): Invalid entering slide" );
     
+    if( xOptionalFactory.is() && 
+        xOptionalFactory->hasTransition(nTransitionType, nTransitionSubType) )
+    {
+        // #i82460# - optional plugin factory claims this transition. delegate.
+        return NumberAnimationSharedPtr(
+            createPluginTransition(
+                nTransitionType,
+                nTransitionSubType,
+                comphelper::make_optional(pLeavingSlide),
+                pEnteringSlide,
+                rViewContainer,
+                rScreenUpdater,
+                xOptionalFactory,
+                pSoundPlayer,
+                rEventMultiplexer ));
+    }
+
     const TransitionInfo* pTransitionInfo( 
         getTransitionInfo( nTransitionType, nTransitionSubType ) );
 
@@ -714,6 +827,7 @@ NumberAnimationSharedPtr TransitionFacto
                             rViewContainer,
                             rScreenUpdater,
                             rEventMultiplexer,
+                            xOptionalFactory,
                             pRandomTransitionInfo->mnTransitionType,
                             pRandomTransitionInfo->mnTransitionSubType,
                             bTransitionDirection,
Index: slideshow/source/inc/delayevent.hxx
===================================================================
RCS file: /cvs/graphics/slideshow/source/inc/delayevent.hxx,v
retrieving revision 1.8
retrieving revision 1.8.4.1
diff -u -p -u -p -r1.8 -r1.8.4.1
--- slideshow/source/inc/delayevent.hxx	17 Jul 2007 15:04:35 -0000	1.8
+++ slideshow/source/inc/delayevent.hxx	10 Oct 2007 12:02:31 -0000	1.8.4.1
@@ -59,7 +59,7 @@ public:
 #if defined(VERBOSE) && defined(DBG_UTIL)
     Delay( const boost::function0<void>& func,
            double nTimeout,
-           char const* const origin ) : Event(origin),
+           char const* const  ) :
 #else
     Delay( const boost::function0<void>& func,
            double nTimeout ) :
Index: slideshow/source/inc/slidebitmap.hxx
===================================================================
RCS file: /cvs/graphics/slideshow/source/inc/slidebitmap.hxx,v
retrieving revision 1.6
retrieving revision 1.5.26.3
diff -u -p -u -p -r1.6 -r1.5.26.3
--- slideshow/source/inc/slidebitmap.hxx	17 Jul 2007 15:15:33 -0000	1.6
+++ slideshow/source/inc/slidebitmap.hxx	25 Jul 2007 15:55:01 -0000	1.5.26.3
@@ -80,8 +80,12 @@ namespace slideshow
 
             bool 				draw( const ::cppcanvas::CanvasSharedPtr& rCanvas ) const;
             ::basegfx::B2ISize 	getSize() const;
+            ::basegfx::B2DPoint getOutputPos() const{return maOutputPos;}
             void				move( const ::basegfx::B2DPoint& rNewPos );
             void				clip( const ::basegfx::B2DPolyPolygon& rClipPoly );
+            
+            ::com::sun::star::uno::Reference<
+                ::com::sun::star::rendering::XBitmap >    getXBitmap();
 
         private:
             ::basegfx::B2DPoint										maOutputPos;
Index: slideshow/source/inc/transitionfactory.hxx
===================================================================
RCS file: /cvs/graphics/slideshow/source/inc/transitionfactory.hxx,v
retrieving revision 1.8
retrieving revision 1.8.4.1
diff -u -p -u -p -r1.8 -r1.8.4.1
--- slideshow/source/inc/transitionfactory.hxx	17 Jul 2007 15:17:38 -0000	1.8
+++ slideshow/source/inc/transitionfactory.hxx	10 Oct 2007 21:03:45 -0000	1.8.4.1
@@ -37,6 +37,7 @@
 #define INCLUDED_SLIDESHOW_TRANSITIONFACTORY_HXX
 
 #include <com/sun/star/animations/XTransitionFilter.hpp>
+#include <com/sun/star/presentation/XTransitionFactory.hpp>
 
 #include "animatableshape.hxx"
 #include "rgbcolor.hxx"
@@ -116,16 +117,19 @@ namespace slideshow
                 transition effect
              */
             static NumberAnimationSharedPtr createSlideTransition(
-                const SlideSharedPtr& 		rLeavingSlide,
-                const SlideSharedPtr& 		rEnteringSlide,
-                const UnoViewContainer&     rViewContainer,
-                ScreenUpdater&              rScreenUpdater,
-                EventMultiplexer&           rEventMultiplexer,
-                sal_Int16               	nTransitionType,
-                sal_Int16               	nTransitionSubType,
-                bool						bTransitionDirection,
-                const RGBColor&				rTransitionFadeColor,
-                const SoundPlayerSharedPtr&	rSoundPlayer );
+                const SlideSharedPtr&                          rLeavingSlide,
+                const SlideSharedPtr&                          rEnteringSlide,
+                const UnoViewContainer&                        rViewContainer,
+                ScreenUpdater&                                 rScreenUpdater,
+                EventMultiplexer&                              rEventMultiplexer,
+                const com::sun::star::uno::Reference<
+                      com::sun::star::presentation::XTransitionFactory>& 
+                                                               xOptionalFactory,
+                sal_Int16                                      nTransitionType,
+                sal_Int16                                      nTransitionSubType,
+                bool                                           bTransitionDirection,
+                const RGBColor&                                rTransitionFadeColor,
+                const SoundPlayerSharedPtr&                    rSoundPlayer );
             
         private:
             static const TransitionInfo* getTransitionInfo(
Index: slideshow/test/demoshow.cxx
===================================================================
RCS file: /cvs/graphics/slideshow/test/demoshow.cxx,v
retrieving revision 1.3
retrieving revision 1.3.4.1
diff -u -p -u -p -r1.3 -r1.3.4.1
--- slideshow/test/demoshow.cxx	17 Jul 2007 15:21:06 -0000	1.3
+++ slideshow/test/demoshow.cxx	27 Jul 2007 13:30:59 -0000	1.3.4.1
@@ -568,13 +568,13 @@ void DemoApp::Main()
     uno::Sequence< uno::Any > aArgs( 2 );
 	aArgs[ 0 ] <<= rtl::OUString::createFromAscii( UCB_CONFIGURATION_KEY1_LOCAL );
 	aArgs[ 1 ] <<= rtl::OUString::createFromAscii( UCB_CONFIGURATION_KEY2_OFFICE );
-    ::ucb::ContentBroker::initialize( xFactory, aArgs );
+    ::ucbhelper::ContentBroker::initialize( xFactory, aArgs );
 
 	DemoWindow pWindow;
 	pWindow.Execute();
 
     // clean up UCB
-	::ucb::ContentBroker::deinitialize();
+	::ucbhelper::ContentBroker::deinitialize();
 }
 }
 
Index: vcl/unx/source/window/salobj.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/window/salobj.cxx,v
retrieving revision 1.21
retrieving revision 1.19.132.2
diff -u -p -u -p -r1.21 -r1.19.132.2
--- vcl/unx/source/window/salobj.cxx	3 Jul 2007 14:08:34 -0000	1.21
+++ vcl/unx/source/window/salobj.cxx	25 Jul 2007 17:12:39 -0000	1.19.132.2
@@ -154,6 +154,14 @@ X11SalObject* X11SalObject::CreateObject
                  static_cast<unsigned int> (aVisID) );
         #endif
         pSalDisp->GetXLib()->PushXErrorLevel( true );
+
+        // TEMP TEMP TEMP - deletion missing...
+        // create colormap for visual - there might not be one
+        aAttribs.colormap = XCreateColormap( pDisp,
+                                             pSalDisp->GetRootWindow( nScreen ),
+                                             pVisual,
+                                             AllocNone );
+
         pObject->maSecondary =
             XCreateWindow( pDisp,
                            pSalDisp->GetRootWindow( nScreen ),
@@ -161,7 +169,7 @@ X11SalObject* X11SalObject::CreateObject
                            1, 1, 0,
                            nDepth, InputOutput,
                            pVisual,
-                           CWEventMask, &aAttribs );
+                           CWEventMask|CWColormap, &aAttribs );
         XSync( pDisp, False );
         BOOL bWasXError = pSalDisp->GetXLib()->HasXErrorOccured();
         pSalDisp->GetXLib()->PopXErrorLevel();
