diff -urNp sworig/source/ui/docvw/edtwin.cxx sw/source/ui/docvw/edtwin.cxx
--- sworig/source/ui/docvw/edtwin.cxx	2006-05-05 17:15:28.000000000 +0800
+++ sw/source/ui/docvw/edtwin.cxx	2006-08-15 11:57:50.000000000 +0800
@@ -201,6 +201,11 @@
 #ifndef _WRTSH_HXX //autogen
 #include <wrtsh.hxx>
 #endif
+
+#ifndef _EXPFLD_HXX
+#include <expfld.hxx>
+#endif
+
 #ifndef _FLDBAS_HXX //autogen
 #include <fldbas.hxx>
 #endif
@@ -1712,6 +1717,8 @@ KEYINPUT_CHECKTABLE:
 				case KEY_LEFT:
 				case KEY_LEFT | KEY_MOD1:
                 {
+                    if( rSh.HasReadonlySel() )
+                        goto READONLY_SECTION_WITH_FIELD;
                     BOOL bMod1 = 0 != (rKeyCode.GetModifier() & KEY_MOD1);
                     if(!bMod1)
                     {
@@ -1790,8 +1797,9 @@ KEYINPUT_CHECKTABLE_INSDEL:
 						eKeyState = KS_TblColCellInsDel;
 					}
 					break;
-
                 case KEY_DELETE:
+                    if( rSh.HasReadonlySel() )
+                            goto READONLY_SECTION_WITH_FIELD;
                     if (rSh.IsInFrontOfLabel() &&
                         rSh.NumOrNoNum(FALSE))
                         eKeyState = KS_NumOrNoNum;
@@ -1854,6 +1862,8 @@ KEYINPUT_CHECKTABLE_INSDEL:
 						else
 							eNextKeyState = eKeyState, eKeyState = KS_CheckAutoCorrect;
 					}
+					else
+					    goto READONLY_SECTION_WITH_FIELD;
 					break;
 
 				case KEY_RETURN | KEY_MOD2:		// ALT-Return
@@ -1958,10 +1968,14 @@ KEYINPUT_CHECKTABLE_INSDEL:
                             // <--
                         }
 					}
+					else
+					    goto READONLY_SECTION_WITH_FIELD;
 					break;
 
 				case KEY_RIGHT:
 					{
+                        if( rSh.HasReadonlySel() )
+                            goto READONLY_SECTION_WITH_FIELD;
                         SwPaM * pCrsr = rSh.GetCrsr(); // #i27615#
                         BOOL bMod1 = 0 !=
                             (rKeyCode.GetModifier() & KEY_MOD1);
@@ -2113,6 +2127,7 @@ KEYINPUT_CHECKTABLE_INSDEL:
                 }
             }
 			break;
+			
         case KS_CheckDocReadOnlyKeys:
 			{
 				eKeyState = KS_KeyToView;
@@ -2317,8 +2332,122 @@ KEYINPUT_CHECKTABLE_INSDEL:
 			eKeyState = KS_Ende;
 		}
 		else
+		
+READONLY_SECTION_WITH_FIELD:
 		{
-			InfoBox( this, SW_RES( MSG_READONLY_CONTENT )).Execute();
+			USHORT nKeyCode = rKeyCode.GetCode();
+			
+			SwField* pField = NULL;
+			static BOOL isNewFld = FALSE; 
+			
+			if (( nKeyCode == KEY_TAB ) || ( nKeyCode == KEY_RIGHT ) || ( nKeyCode == KEY_RETURN ))
+			{
+			    //GetView().GetViewFrame()->GetDispatcher()->Execute(FN_GOTO_NEXT_INPUTFLD);
+			    SwFieldType* pFld = rSh.GetFldType( 0, RES_INPUTFLD );
+			    if( pFld )
+	            {
+	                if (rSh.MoveFldType( pFld, TRUE ))
+	                    isNewFld = TRUE;
+	            }
+			}
+			else if ( ( nKeyCode == KEY_LEFT ) )
+			{
+			    SwFieldType* pFld = rSh.GetFldType( 0, RES_INPUTFLD );
+			    if( pFld )
+	            {
+	                if (rSh.MoveFldType( pFld, FALSE ))
+	                    isNewFld = TRUE;
+	            }
+			}
+			else if ( ( nKeyCode == KEY_BACKSPACE ) )
+			{
+			    pField = rSh.GetCurFld();
+			    //if the current field is inputfield
+			    if (pField && (pField->GetTypeId() == TYP_INPUTFLD) )
+			    {
+			        rSh.StartAllAction();
+	                BOOL bModified = FALSE;
+	                
+			        SwInputField* pInpFld = (SwInputField*)pField;
+			        String aTmp = pInpFld->GetPar1();
+			        if ( aTmp.Len() > 0 )
+			        {
+			            aTmp = aTmp.Reverse();
+			            aTmp = aTmp.Erase( 0, 1 );
+			            aTmp = aTmp.Reverse();
+			            pInpFld->SetPar1(aTmp);
+			        }
+			        
+			        rSh.SwEditShell::UpdateFlds(*pInpFld);
+			        rSh.SetUndoNoResetModified();
+
+	                rSh.EndAllAction();
+			    }
+			}
+			else if ( ( nKeyCode == KEY_DELETE ) )
+			{
+			    pField = rSh.GetCurFld();
+			    //if the current field is inputfield
+			    if (pField && (pField->GetTypeId() == TYP_INPUTFLD) )
+			    {
+			        rSh.StartAllAction();
+	                BOOL bModified = FALSE;
+	                
+			        SwInputField* pInpFld = (SwInputField*)pField;
+			        String aTmp = pInpFld->GetPar1();
+			        if ( aTmp.Len() > 0 )
+			        {
+			            aTmp = aTmp.Erase( 0, 1 );
+			            pInpFld->SetPar1(aTmp);
+			        }
+			        
+			        rSh.SwEditShell::UpdateFlds(*pInpFld);
+			        rSh.SetUndoNoResetModified();
+
+	                rSh.EndAllAction();
+			    }
+			}
+			else
+			{
+			    //get the current field
+			    pField = rSh.GetCurFld();
+			    //if cann't find input field in current position, jump to the next field
+			    if (!pField || (pField->GetTypeId() != TYP_INPUTFLD))
+			    {
+	                SwFieldType* pFld = rSh.GetFldType( 0, RES_INPUTFLD );
+			        if( pFld )
+	                {
+	                    if (rSh.MoveFldType( pFld, TRUE ))
+	                    {
+	                        isNewFld = TRUE;
+                            pField = rSh.GetCurFld();
+	                    }
+	                }
+	            }
+	            //if we have an inputfield in current position, otherwise there is no inputfield in this document
+			    if (pField && (pField->GetTypeId() == TYP_INPUTFLD) )
+			    {		        
+			        rSh.StartAllAction();
+	                BOOL bModified = FALSE;
+	                
+			        SwInputField* pInpFld = (SwInputField*)pField;
+			        String aTmp = pInpFld->GetPar1();
+			        if (isNewFld)
+			        {
+			            pInpFld->SetPar1(aCh);
+			            isNewFld = FALSE;
+			        }
+			        else
+				        pInpFld->SetPar1(aTmp.Append(aCh));
+			        
+			        rSh.SwEditShell::UpdateFlds(*pInpFld);
+			        rSh.SetUndoNoResetModified();
+
+	                rSh.EndAllAction();
+			    }
+			    else
+			        InfoBox( this, SW_RES( MSG_READONLY_CONTENT )).Execute();
+			}
 // ???			Window::KeyInput( aKeyEvent );
 			eKeyState = KS_Ende;
 		}
