diff -purN o3tl/inc/o3tl/cow_wrapper.hxx o3tl/inc/o3tl/cow_wrapper.hxx
--- o3tl/inc/o3tl/cow_wrapper.hxx	1970-01-01 01:00:00.000000000 +0100
+++ o3tl/inc/o3tl/cow_wrapper.hxx	2006-05-11 13:18:21.000000000 +0200
@@ -0,0 +1,335 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_O3TL_COW_WRAPPER_HXX
+#define INCLUDED_O3TL_COW_WRAPPER_HXX
+
+#include <osl/interlck.h>
+
+#include <algorithm>
+
+#include <boost/utility.hpp>
+#include <boost/checked_delete.hpp>
+
+namespace o3tl
+{
+    /** Thread-unsafe refcounting
+
+        This is the default locking policy for cow_wrapper. No
+        locking/guarding against concurrent access is performed
+        whatsoever.
+     */
+    struct UnsafeRefCountingPolicy
+    {
+        typedef sal_uInt32 ref_count_t;
+        static void incrementCount( ref_count_t& rCount ) { ++rCount; }
+        static bool decrementCount( ref_count_t& rCount ) { return --rCount != 0; }
+    };
+
+    /** Thread-safe refcounting
+
+        Use this to have the cow_wrapper refcounting mechanisms employ
+        the thread-safe oslInterlockedCount .
+     */
+    struct ThreadSafeRefCountingPolicy
+    {
+        typedef oslInterlockedCount ref_count_t;
+        static void incrementCount( ref_count_t& rCount ) { osl_incrementInterlockedCount(&rCount); }
+        static bool decrementCount( ref_count_t& rCount ) 
+        { 
+            if( rCount == 1 ) // caller is already the only/last reference
+                return false;
+            else
+                return osl_decrementInterlockedCount(&rCount) != 0; 
+        }
+    };
+
+    /** Copy-on-write wrapper.
+
+        This template provides copy-on-write semantics for the wrapped
+        type: when copying, the operation is performed shallow,
+        i.e. different cow_wrapper objects share the same underlying
+        instance. Only when accessing the underlying object via
+        non-const methods, a unique copy is provided.
+
+        The type parameter <code>T</code> must satisfy the following
+        requirements: it must be default-constructible, copyable (it
+        need not be assignable), and be of non-reference type. Note
+        that, despite the fact that this template provides access to
+        the wrapped type via pointer-like methods
+        (<code>operator->()</code> and <code>operator*()</code>), it does
+        <em>not</em> work like e.g. the boost pointer wrappers
+        (shared_ptr, scoped_ptr, etc.). Internally, the cow_wrapper
+        holds a by-value instance of the wrapped object. This is to
+        avoid one additional heap allocation, and providing access via
+        <code>operator->()</code>/<code>operator*()</code> is because
+        <code>operator.()</code> cannot be overridden.
+
+        Regarding thread safety: this wrapper is <em>not</em>
+        thread-safe per se, because cow_wrapper has no way of
+        syncronizing the potentially many different cow_wrapper
+        instances, that reference a single shared value_type
+        instance. That said, when passing
+        <code>ThreadSafeRefCountingPolicy</code> as the
+        <code>MTPolicy</code> parameter, accessing a thread-safe
+        pointee through multiple cow_wrapper instances might be
+        thread-safe, if the individual pointee methods are
+        thread-safe, <em>including</em> pointee's copy
+        constructor. Any wrapped object that needs external
+        synchronisation (e.g. via an external mutex, which arbitrates
+        access to object methods, and can be held across multiple
+        object method calls) cannot easily be dealt with in a
+        thread-safe way, because, as noted, objects are shared behind
+        the client's back.
+
+        @attention if one wants to use the pimpl idiom together with
+        cow_wrapper (i.e. put an opaque type into the cow_wrapper),
+        then <em>all<em> methods in the surrounding class needs to be
+        non-inline (<em>including</em> destructor, copy constructor
+        and assignment operator).
+
+        @example
+        <pre>
+class cow_wrapper_client_impl;
+
+class cow_wrapper_client
+{
+public:
+    cow_wrapper_client();
+    cow_wrapper_client( const cow_wrapper_client& );
+    ~cow_wrapper_client();
+
+    cow_wrapper_client& operator=( const cow_wrapper_client& );
+
+    void modify( int nVal );
+    int queryUnmodified() const;
+
+private:
+    otl::cow_wrapper< cow_wrapper_client_impl > maImpl;
+};
+        </pre>
+        and the implementation file would look like this:
+        <pre>
+class cow_wrapper_client_impl
+{
+public:
+	void setValue( int nVal ) { mnValue = nVal; }
+	int getValue() const { return mnValue; }
+
+private:
+	int mnValue;
+}
+
+cow_wrapper_client::cow_wrapper_client() :
+	maImpl()
+{
+}
+cow_wrapper_client::cow_wrapper_client( const cow_wrapper_client& rSrc ) :
+	maImpl( rSrc.maImpl )
+{
+}
+cow_wrapper_client::~cow_wrapper_client()
+{
+}
+cow_wrapper_client& cow_wrapper_client::operator=( const cow_wrapper_client& rSrc )
+{
+	maImpl = rSrc.maImpl;
+    return *this;
+}
+void cow_wrapper_client::modify( int nVal )
+{
+	maImpl->setValue( nVal );
+}
+void cow_wrapper_client::queryUnmodified() const
+{
+	return maImpl->getValue();
+}
+        </pre>
+     */
+    template<typename T, class MTPolicy=UnsafeRefCountingPolicy> class cow_wrapper
+    {
+        /** shared value object - gets cloned before cow_wrapper hands
+            out a non-const reference to it
+         */
+        struct impl_t : private boost::noncopyable
+        {
+            impl_t() : 
+                m_value(),
+                m_ref_count(1)
+            {
+            }
+
+            explicit impl_t( const T& v ) : 
+                m_value(v),
+                m_ref_count(1)
+            {
+            }
+
+            T                              m_value;
+            typename MTPolicy::ref_count_t m_ref_count;
+        };
+
+        void release()
+        {
+            if( !MTPolicy::decrementCount(m_pimpl->m_ref_count) )
+                boost::checked_delete(m_pimpl), m_pimpl=0;
+        }
+
+    public:
+        typedef T        value_type;
+        typedef T*       pointer;
+        typedef MTPolicy mt_policy;
+
+        /** Default-construct wrapped type instance
+         */
+        cow_wrapper() : 
+            m_pimpl( new impl_t() )
+        {
+        }
+
+        /** Copy-construct wrapped type instance from given object
+         */
+        explicit cow_wrapper( const value_type& r ) : 
+            m_pimpl( new impl_t(r) )
+        {
+        }
+
+        /** Shallow-copy given cow_wrapper
+         */
+        explicit cow_wrapper( const cow_wrapper& rSrc ) : // nothrow
+            m_pimpl( rSrc.m_pimpl )
+        {
+            MTPolicy::incrementCount( m_pimpl->m_ref_count );
+        }
+
+        ~cow_wrapper() // nothrow, if ~T does not throw
+        {
+            release();
+        }
+
+        /// now sharing rSrc cow_wrapper instance with us
+        cow_wrapper& operator=( const cow_wrapper& rSrc ) // nothrow
+        {
+            // this already guards against self-assignment
+            MTPolicy::incrementCount( rSrc.m_pimpl->m_ref_count );
+
+            release();
+            m_pimpl = rSrc.m_pimpl;
+            
+            return *this;
+        }
+
+        /// unshare with any other cow_wrapper instance
+        value_type& make_unique()
+        {
+            if( m_pimpl->m_ref_count > 1 )
+            {
+                impl_t* pimpl = new impl_t(m_pimpl->m_value);
+                release();
+                m_pimpl = pimpl;
+            }
+            
+            return m_pimpl->m_value;
+        }
+
+        /// true, if not shared with any other cow_wrapper instance
+        bool is_unique() const // nothrow
+        {
+            return m_pimpl->m_ref_count == 1;
+        }
+
+        /// return number of shared instances (1 for unique object)
+        typename MTPolicy::ref_count_t use_count() const // nothrow
+        {
+            return m_pimpl->m_ref_count;
+        }
+
+        void swap(cow_wrapper& r) // never throws
+        {
+            std::swap(m_pimpl, r.m_pimpl);
+        }
+        
+        pointer		      operator->()       { return &make_unique(); }
+        value_type&       operator*()        { return make_unique(); }
+        const pointer     operator->() const { return &m_pimpl->m_value; }
+        const value_type& operator*()  const { return m_pimpl->m_value; }
+
+        pointer           get()       { return &make_unique(); }
+        const pointer	  get() const { return &m_pimpl->m_value; }
+
+        /// true, if both cow_wrapper internally share the same object
+        bool              same_object( const cow_wrapper& rOther ) const
+        {
+            return rOther.m_pimpl == m_pimpl;
+        }
+
+    private:
+        impl_t* m_pimpl;
+    };
+
+
+    template<class T, class P> inline bool operator==( const cow_wrapper<T,P>& a, 
+                                                       const cow_wrapper<T,P>& b )
+    {
+        return a.same_object(b) ? true : *a == *b;
+    }
+
+    template<class T, class P> inline bool operator!=( const cow_wrapper<T,P>& a, 
+                                                       const cow_wrapper<T,P>& b )
+    {
+        return a.same_object(b) ? false : *a != *b;
+    }
+
+    template<class A, class B, class P> inline bool operator<( const cow_wrapper<A,P>& a, 
+                                                               const cow_wrapper<B,P>& b )
+    {
+        return *a < *b;
+    }
+
+    template<class T, class P> inline void swap( cow_wrapper<T,P>& a, 
+                                                 cow_wrapper<T,P>& b )
+    {
+        a.swap(b);
+    }
+
+    // to enable boost::mem_fn on cow_wrapper
+    template<class T, class P> inline T * get_pointer( const cow_wrapper<T,P>& r )
+    {
+        return r.get();
+    }
+
+}
+
+#endif /* INCLUDED_O3TL_COW_WRAPPER_HXX */
diff -purN o3tl/prj/build.lst o3tl/prj/build.lst
--- o3tl/prj/build.lst	1970-01-01 01:00:00.000000000 +0100
+++ o3tl/prj/build.lst	2006-07-17 13:32:49.000000000 +0200
@@ -0,0 +1,6 @@
+ot	o3tl	:	sal testshl2 NULL
+ot	o3tl									usr1	-	all	ot_mkout NULL
+ot	o3tl\inc								get		-	all	ot_inc NULL
+ot	o3tl\prj								get		-	all	ot_prj NULL
+#ot	o3tl\qa									nmake	-	all	ot_qa NULL
+
diff -purN o3tl/prj/d.lst o3tl/prj/d.lst
--- o3tl/prj/d.lst	1970-01-01 01:00:00.000000000 +0100
+++ o3tl/prj/d.lst	2006-01-25 17:15:55.000000000 +0100
@@ -0,0 +1,2 @@
+mkdir: %_DEST%\inc%_EXT%\o3tl
+..\inc\o3tl\*.hxx %_DEST%\inc%_EXT%\o3tl\*.hxx
diff -purN o3tl/qa/cow_wrapper_clients.cxx o3tl/qa/cow_wrapper_clients.cxx
--- o3tl/qa/cow_wrapper_clients.cxx	1970-01-01 01:00:00.000000000 +0100
+++ o3tl/qa/cow_wrapper_clients.cxx	2006-03-23 16:25:00.000000000 +0100
@@ -0,0 +1,214 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include "cow_wrapper_clients.hxx"
+
+namespace o3tltests {
+
+class cow_wrapper_client2_impl
+{
+public:
+    cow_wrapper_client2_impl() : mnValue(0) {}
+    explicit cow_wrapper_client2_impl( int nVal ) : mnValue(nVal) {}
+    void setValue( int nVal ) { mnValue = nVal; }
+    int  getValue() const { return mnValue; }
+
+    bool operator==( const cow_wrapper_client2_impl& rRHS ) const { return mnValue == rRHS.mnValue; }
+    bool operator!=( const cow_wrapper_client2_impl& rRHS ) const { return mnValue != rRHS.mnValue; }
+    bool operator<( const cow_wrapper_client2_impl& rRHS ) const { return mnValue < rRHS.mnValue; }
+
+private:
+    int mnValue;
+};
+
+cow_wrapper_client2::cow_wrapper_client2() : maImpl()
+{
+}
+
+cow_wrapper_client2::cow_wrapper_client2( int nVal ) : 
+    maImpl( cow_wrapper_client2_impl(nVal) )
+{
+}
+
+cow_wrapper_client2::~cow_wrapper_client2()
+{
+}
+
+cow_wrapper_client2::cow_wrapper_client2( const cow_wrapper_client2& rSrc ) : 
+    maImpl(rSrc.maImpl)
+{
+}
+
+cow_wrapper_client2& cow_wrapper_client2::operator=( const cow_wrapper_client2& rSrc )
+{
+    maImpl = rSrc.maImpl;
+
+	return *this;
+}
+
+void cow_wrapper_client2::modify( int nVal )
+{
+    maImpl->setValue( nVal );
+}
+
+int  cow_wrapper_client2::queryUnmodified() const
+{
+    return maImpl->getValue();
+}
+
+void cow_wrapper_client2::makeUnique() 
+{ 
+    maImpl.make_unique(); 
+}
+bool cow_wrapper_client2::is_unique() const 
+{ 
+    return maImpl.is_unique(); 
+}
+oslInterlockedCount cow_wrapper_client2::use_count() const
+{ 
+    return maImpl.use_count(); 
+}
+void cow_wrapper_client2::swap( cow_wrapper_client2& r )
+{ 
+    o3tl::swap(maImpl, r.maImpl); 
+} 
+
+bool cow_wrapper_client2::operator==( const cow_wrapper_client2& rRHS ) const
+{ 
+    return maImpl == rRHS.maImpl; 
+}
+bool cow_wrapper_client2::operator!=( const cow_wrapper_client2& rRHS ) const
+{ 
+    return maImpl != rRHS.maImpl; 
+}
+bool cow_wrapper_client2::operator<( const cow_wrapper_client2& rRHS ) const 
+{ 
+    return maImpl < rRHS.maImpl; 
+}
+
+// ---------------------------------------------------------------------------
+
+cow_wrapper_client3::cow_wrapper_client3() : maImpl()
+{
+}
+
+cow_wrapper_client3::cow_wrapper_client3( int nVal ) : 
+    maImpl( cow_wrapper_client2_impl(nVal) )
+{
+}
+
+cow_wrapper_client3::~cow_wrapper_client3()
+{
+}
+
+cow_wrapper_client3::cow_wrapper_client3( const cow_wrapper_client3& rSrc ) : 
+    maImpl(rSrc.maImpl)
+{
+}
+
+cow_wrapper_client3& cow_wrapper_client3::operator=( const cow_wrapper_client3& rSrc )
+{
+    maImpl = rSrc.maImpl;
+
+	return *this;
+}
+
+void cow_wrapper_client3::modify( int nVal )
+{
+    maImpl->setValue( nVal );
+}
+
+int  cow_wrapper_client3::queryUnmodified() const
+{
+    return maImpl->getValue();
+}
+
+void cow_wrapper_client3::makeUnique() 
+{ 
+    maImpl.make_unique(); 
+}
+bool cow_wrapper_client3::is_unique() const 
+{ 
+    return maImpl.is_unique(); 
+}
+oslInterlockedCount cow_wrapper_client3::use_count() const
+{ 
+    return maImpl.use_count(); 
+}
+void cow_wrapper_client3::swap( cow_wrapper_client3& r )
+{ 
+    o3tl::swap(maImpl, r.maImpl); 
+} 
+
+bool cow_wrapper_client3::operator==( const cow_wrapper_client3& rRHS ) const
+{ 
+    return maImpl == rRHS.maImpl; 
+}
+bool cow_wrapper_client3::operator!=( const cow_wrapper_client3& rRHS ) const
+{ 
+    return maImpl != rRHS.maImpl; 
+}
+bool cow_wrapper_client3::operator<( const cow_wrapper_client3& rRHS ) const 
+{ 
+    return maImpl < rRHS.maImpl; 
+}
+
+} // namespace o3tltests
diff -purN o3tl/qa/cow_wrapper_clients.hxx o3tl/qa/cow_wrapper_clients.hxx
--- o3tl/qa/cow_wrapper_clients.hxx	1970-01-01 01:00:00.000000000 +0100
+++ o3tl/qa/cow_wrapper_clients.hxx	2006-03-23 16:25:00.000000000 +0100
@@ -0,0 +1,162 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef INCLUDED_COW_WRAPPER_CLIENTS_HXX
+#define INCLUDED_COW_WRAPPER_CLIENTS_HXX
+
+#include "o3tl/cow_wrapper.hxx"
+
+/* Definition of Cow_Wrapper_Clients classes */
+
+namespace o3tltests {
+
+/** This is a header and a separate compilation unit on purpose -
+    cow_wrapper needs destructor, copy constructor and assignment
+    operator to be outline, when pimpl idiom is used
+ */
+
+/// test non-opaque impl type
+class cow_wrapper_client1
+{
+public:
+    cow_wrapper_client1() : maImpl() {}
+    explicit cow_wrapper_client1( int nVal ) : maImpl(nVal) {}
+
+    void modify( int nVal ) { *maImpl = nVal; }
+    int  queryUnmodified() const { return *maImpl; }
+
+    void makeUnique() { maImpl.make_unique(); }
+    bool is_unique() const { return maImpl.is_unique(); }
+    oslInterlockedCount use_count() const { return maImpl.use_count(); }
+    void swap( cow_wrapper_client1& r ) { o3tl::swap(maImpl, r.maImpl); } 
+
+    bool operator==( const cow_wrapper_client1& rRHS ) const { return maImpl == rRHS.maImpl; }
+    bool operator!=( const cow_wrapper_client1& rRHS ) const { return maImpl != rRHS.maImpl; }
+    bool operator<( const cow_wrapper_client1& rRHS ) const { return maImpl < rRHS.maImpl; }
+
+private:
+    o3tl::cow_wrapper< int > maImpl;
+};
+
+
+class cow_wrapper_client2_impl;
+
+/** test opaque impl type - need to explicitely declare lifetime
+    methods
+ */
+class cow_wrapper_client2
+{
+public:
+    cow_wrapper_client2();
+    explicit cow_wrapper_client2( int nVal );
+    ~cow_wrapper_client2();
+
+    cow_wrapper_client2( const cow_wrapper_client2& );
+    cow_wrapper_client2& operator=( const cow_wrapper_client2& );
+
+    void modify( int nVal );
+    int  queryUnmodified() const;
+
+    void makeUnique();
+    bool is_unique() const;
+    oslInterlockedCount use_count() const;
+    void swap( cow_wrapper_client2& r );
+
+    bool operator==( const cow_wrapper_client2& rRHS ) const;
+    bool operator!=( const cow_wrapper_client2& rRHS ) const;
+    bool operator<( const cow_wrapper_client2& rRHS ) const;
+
+private:
+    o3tl::cow_wrapper< cow_wrapper_client2_impl > maImpl;
+};
+
+/** test MT-safe cow_wrapper - basically the same as
+    cow_wrapper_client2, only with different refcounting policy
+ */
+class cow_wrapper_client3
+{
+public:
+    cow_wrapper_client3();
+    explicit cow_wrapper_client3( int nVal );
+    ~cow_wrapper_client3();
+
+    cow_wrapper_client3( const cow_wrapper_client3& );
+    cow_wrapper_client3& operator=( const cow_wrapper_client3& );
+
+    void modify( int nVal );
+    int  queryUnmodified() const;
+
+    void makeUnique();
+    bool is_unique() const;
+    oslInterlockedCount use_count() const;
+    void swap( cow_wrapper_client3& r );
+
+    bool operator==( const cow_wrapper_client3& rRHS ) const;
+    bool operator!=( const cow_wrapper_client3& rRHS ) const;
+    bool operator<( const cow_wrapper_client3& rRHS ) const;
+
+private:
+    o3tl::cow_wrapper< cow_wrapper_client2_impl, o3tl::ThreadSafeRefCountingPolicy > maImpl;
+};
+
+} // namespace o3tltests
+
+#endif /* INCLUDED_COW_WRAPPER_CLIENTS_HXX */
diff -purN o3tl/qa/export.map o3tl/qa/export.map
--- o3tl/qa/export.map	1970-01-01 01:00:00.000000000 +0100
+++ o3tl/qa/export.map	2006-01-25 17:17:58.000000000 +0100
@@ -0,0 +1,42 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+UDK_3.1 {
+    global:
+		registerAllTestFunction;
+
+    local:
+        *;
+};
diff -purN o3tl/qa/makefile.mk o3tl/qa/makefile.mk
--- o3tl/qa/makefile.mk	1970-01-01 01:00:00.000000000 +0100
+++ o3tl/qa/makefile.mk	2006-01-25 17:18:16.000000000 +0100
@@ -0,0 +1,82 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+PRJ=..
+
+PRJNAME=o3tl
+TARGET=tests
+
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Common ----------------------------------------------------------
+
+# BEGIN ----------------------------------------------------------------
+SHL1OBJS=  \
+	$(SLO)$/tests.obj	\
+	$(SLO)$/cow_wrapper_clients.obj
+
+SHL1TARGET= tests
+SHL1STDLIBS= 	$(SALLIB)		 \
+				$(CPPUNITLIB)
+
+SHL1IMPLIB= i$(SHL1TARGET)
+
+DEF1NAME    =$(SHL1TARGET)
+SHL1VERSIONMAP = export.map 
+
+# END ------------------------------------------------------------------
+
+#------------------------------- All object files -------------------------------
+# do this here, so we get right dependencies
+SLOFILES=$(SHL1OBJS) 
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE : target.mk
+.INCLUDE : _cppunit.mk 
+
+# --- Enable test execution in normal build ------------------------
+
+unittest : $(SHL1TARGETN)
+		@+echo ----------------------------------------------------------
+		@+echo - start unit test on library $(SHL1TARGETN)
+		@+echo ----------------------------------------------------------
+		testshl2 $(SHL1TARGETN)
+
+ALLTAR : unittest
diff -purN o3tl/qa/tests.cxx o3tl/qa/tests.cxx
--- o3tl/qa/tests.cxx	1970-01-01 01:00:00.000000000 +0100
+++ o3tl/qa/tests.cxx	2006-07-13 16:18:47.000000000 +0200
@@ -0,0 +1,136 @@
+// autogenerated file with codegen.pl
+
+#include <cppunit/simpleheader.hxx>
+
+#include "cow_wrapper_clients.hxx"
+
+using namespace ::o3tl;
+
+
+namespace o3tltests
+{
+
+class cow_wrapper_test : public CppUnit::TestFixture
+{
+public:
+    template< class T > void test( T& rTestObj1, T& rTestObj2, T& rTestObj3 )
+    {
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1 is unique", 
+                               rTestObj1.is_unique() );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj2 is unique", 
+                               rTestObj2.is_unique() );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj3 is unique", 
+                               rTestObj3.is_unique() );
+
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1 != rTestObj2", 
+                               rTestObj1 != rTestObj2 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj2 != rTestObj3", 
+                               rTestObj2 != rTestObj3 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1 != rTestObj3", 
+                               rTestObj1 != rTestObj3 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1 < rTestObj2", 
+                               rTestObj1 < rTestObj2 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj2 < rTestObj3", 
+                               rTestObj2 < rTestObj3 );
+
+        rTestObj2 = rTestObj1;
+        rTestObj3 = rTestObj1;
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1 == rTestObj2", 
+                               rTestObj1 == rTestObj2 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1 == rTestObj3", 
+                               rTestObj1 == rTestObj3 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1.use_count() == 3", 
+                               rTestObj1.use_count() == 3 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj2.use_count() == 3", 
+                               rTestObj2.use_count() == 3 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj3.use_count() == 3", 
+                               rTestObj3.use_count() == 3 );
+        
+        rTestObj2.makeUnique();
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1 == rTestObj2", 
+                               rTestObj1 == rTestObj2 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1 == rTestObj3", 
+                               rTestObj1 == rTestObj3 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1.use_count() == 2", 
+                               rTestObj1.use_count() == 2 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj2.use_count() == 1", 
+                               rTestObj2.use_count() == 1 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj2.is_unique()", 
+                               rTestObj2.is_unique() );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj3.use_count() == 2", 
+                               rTestObj3.use_count() == 2 );
+
+        rTestObj2.swap( rTestObj3 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1 == rTestObj2", 
+                               rTestObj1 == rTestObj2 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1 == rTestObj3", 
+                               rTestObj1 == rTestObj3 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj1.use_count() == 2", 
+                               rTestObj1.use_count() == 2 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj2.use_count() == 2", 
+                               rTestObj2.use_count() == 2 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj3.use_count() == 1", 
+                               rTestObj3.use_count() == 1 );
+        CPPUNIT_ASSERT_MESSAGE("rTestObj3.is_unique()", 
+                               rTestObj3.is_unique() );
+    }
+
+    void testCowWrapper()
+    {
+        // setup
+        cow_wrapper_client1 aTestObj1;
+        cow_wrapper_client1 aTestObj2;
+        cow_wrapper_client1 aTestObj3;
+        
+        cow_wrapper_client2 aTestObj4;
+        cow_wrapper_client2 aTestObj5;
+        cow_wrapper_client2 aTestObj6;
+
+        cow_wrapper_client3 aTestObj7;
+        cow_wrapper_client3 aTestObj8;
+        cow_wrapper_client3 aTestObj9;
+
+        {
+            aTestObj1 = cow_wrapper_client1( 1 );
+            aTestObj2.modify( 2 );
+            aTestObj3.modify( 3 );
+            
+            aTestObj4 = cow_wrapper_client2( 4 );
+            aTestObj5.modify( 5 );
+            aTestObj6.modify( 6 );
+
+            aTestObj7 = cow_wrapper_client3( 7 );
+            aTestObj8.modify( 8 );
+            aTestObj9.modify( 9 );
+        }
+        // all three temporaries are dead now
+
+        // test
+        test( aTestObj1, aTestObj2, aTestObj3 );
+        test( aTestObj4, aTestObj5, aTestObj6 );
+        test( aTestObj7, aTestObj8, aTestObj9 );
+    }
+
+    // Change the following lines only, if you add, remove or rename 
+    // member functions of the current class, 
+    // because these macros are need by auto register mechanism.
+
+    CPPUNIT_TEST_SUITE(cow_wrapper_test);
+    CPPUNIT_TEST(testCowWrapper);
+    CPPUNIT_TEST_SUITE_END();
+};
+
+// -----------------------------------------------------------------------------
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(o3tltests::cow_wrapper_test, "cow_wrapper_test");
+} // namespace o3tltests
+
+
+// -----------------------------------------------------------------------------
+
+// this macro creates an empty function, which will called by the RegisterAllFunctions()
+// to let the user the possibility to also register some functions by hand.
+void RegisterAdditionalFunctions(FktRegFuncPtr )
+{
+}
+// NOADDITIONAL;
+
