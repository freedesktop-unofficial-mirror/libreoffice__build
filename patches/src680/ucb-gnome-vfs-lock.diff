--- ucb/source/ucp/gvfs/content.cxx	2007-03-26 13:35:09.000000000 +0200
+++ ucb/source/ucp/gvfs/content.cxx	2007-03-26 18:01:57.000000000 +0200
@@ -60,6 +60,9 @@
 #ifndef _COM_SUN_STAR_IO_XOUTPUTSTREAM_HPP_
 #include <com/sun/star/io/XOutputStream.hpp>
 #endif
+#ifndef _COM_SUN_STAR_IO_XACTIVEDATASTREAMER_HPP_
+#include <com/sun/star/io/XActiveDataStreamer.hpp>
+#endif
 #ifndef _COM_SUN_STAR_LANG_ILLEGALACCESSEXCEPTION_HPP_
 #include <com/sun/star/lang/IllegalAccessException.hpp>
 #endif
@@ -90,6 +93,9 @@
 #ifndef _COM_SUN_STAR_UCB_INTERACTIVENETWORKWRITEEXCEPTION_HPP_
 #include <com/sun/star/ucb/InteractiveNetworkWriteException.hpp>
 #endif
+#ifndef _COM_SUN_STAR_UCB_IOERRORCODE_HPP_
+#include <com/sun/star/ucb/IOErrorCode.hpp>
+#endif
 #ifndef _COM_SUN_STAR_UCB_NAMECLASH_HPP_
 #include <com/sun/star/ucb/NameClash.hpp>
 #endif
@@ -204,7 +210,8 @@ Content::Content(
   throw ( star::ucb::ContentCreationException )
 	: ContentImplHelper( rxSMgr, pProvider, Identifier ),
 	  m_pProvider( pProvider ),
-	  m_bTransient( sal_False )
+	  m_bTransient( sal_False ),
+	  m_bForceReadOnly( sal_False )
 {
 	CLEAR_INFO (&m_info);
 #ifdef DEBUG
@@ -221,7 +228,8 @@ Content::Content( const ::com::sun::star
 	throw ( ::com::sun::star::ucb::ContentCreationException )
 	: ContentImplHelper( rxSMgr, pProvider, Identifier ),
 	  m_pProvider( pProvider ),
-	  m_bTransient( sal_True )
+	  m_bTransient( sal_True ),
+	  m_bForceReadOnly( sal_False )
 {
 	CLEAR_INFO (&m_info);
 
@@ -699,7 +707,9 @@ uno::Reference< sdbc::XRow > Content::ge
 		}
 
 		else if (rProp.Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "IsReadOnly" ) ) ) {
-			if (m_info.valid_fields & GNOME_VFS_FILE_INFO_FIELDS_PERMISSIONS) {
+			if ( m_bForceReadOnly )
+				xRow->appendBoolean( rProp, sal_True );
+			else if (m_info.valid_fields & GNOME_VFS_FILE_INFO_FIELDS_PERMISSIONS) {
 				bool read_only = true;
 
 				if (m_info.uid == getuid () &&
@@ -1039,10 +1049,12 @@ void Content::insert(
 	if ( bReplaceExisting ) {
 		Authentication aAuth( xEnv );
 		result = gnome_vfs_open( &handle, (const sal_Char *)aURI,
-					 GNOME_VFS_OPEN_WRITE );
+					 (GnomeVFSOpenMode)(GNOME_VFS_OPEN_WRITE | GNOME_VFS_OPEN_LOCKED) );
 	}
 
-	if ( result != GNOME_VFS_OK ) {
+	if ( result == GNOME_VFS_ERROR_LOCKED )
+		throwLocked( xEnv );
+	else if ( result != GNOME_VFS_OK ) {
 		int perm;
 		Authentication aAuth( xEnv );
 
@@ -1050,10 +1062,13 @@ void Content::insert(
 			 ( GNOME_VFS_PERM_GROUP_WRITE | GNOME_VFS_PERM_GROUP_READ ) );
 
 		result = gnome_vfs_create
-			( &handle, (const sal_Char *)aURI, GNOME_VFS_OPEN_WRITE, TRUE, perm );
+			( &handle, (const sal_Char *)aURI,
+			  (GnomeVFSOpenMode)(GNOME_VFS_OPEN_WRITE | GNOME_VFS_OPEN_LOCKED), TRUE, perm );
 	}
 
-	if( result != GNOME_VFS_OK )
+	if ( result == GNOME_VFS_ERROR_LOCKED )
+		throwLocked( xEnv );
+	else if ( result != GNOME_VFS_OK )
 		cancelCommandExecution( result, xEnv, sal_True );
 
 	if ( !xInputStream.is() ) {
@@ -1362,6 +1377,22 @@ void Content::cancelCommandExecution(
     // Unreachable
 }
 
+void Content::throwLocked( const uno::Reference< star::ucb::XCommandEnvironment > & xEnv)
+	throw( uno::Exception )
+{
+#ifdef DEBUG
+	g_warning( "File locked, throwing IOErrorCode_LOCKING_VIOLATION" );
+#endif
+
+	m_bForceReadOnly = sal_True;
+
+	ucbhelper::cancelCommandExecution( star::ucb::IOErrorCode_LOCKING_VIOLATION,
+			uno::Sequence< uno::Any >( 0 ), // FIXME more info about the file
+			xEnv,
+			rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "an error occured during file opening" ) ),
+			this );
+}
+
 uno::Sequence< beans::Property > Content::getProperties(
     const uno::Reference< com::sun::star::ucb::XCommandEnvironment > & /*xEnv*/ )
 {
@@ -1521,48 +1552,53 @@ Content::createTempStream( const ::com::
 }
 
 ::com::sun::star::uno::Reference<
-	::com::sun::star::io::XInputStream > 
-Content::createInputStream( const ::com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment >& xEnv )
+	::com::sun::star::io::XStream > 
+Content::createStream( const ::com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment >& xEnv,
+                       bool bReadWrite )
 	throw( ::com::sun::star::uno::Exception )
 {
 	GnomeVFSHandle *handle = NULL;
 	GnomeVFSResult  result;
-	uno::Reference<io::XInputStream > xIn;
+	uno::Reference<io::XStream > xStream;
 
 	Authentication aAuth( xEnv );
-    	osl::Guard< osl::Mutex > aGuard( m_aMutex );
+	osl::Guard< osl::Mutex > aGuard( m_aMutex );
 
 	getInfo( xEnv );
 	::rtl::OString aURI = getOURI();
 
 	if ( !(m_info.valid_fields & GNOME_VFS_FILE_INFO_FIELDS_SIZE) )
-		return createTempStream( xEnv );
+		return xStream;
 
-	result = gnome_vfs_open
-		( &handle, (const sal_Char *)aURI,
-		  (GnomeVFSOpenMode) (GNOME_VFS_OPEN_READ | GNOME_VFS_OPEN_RANDOM ) );
+	int nOpenMode = (GNOME_VFS_OPEN_READ | GNOME_VFS_OPEN_RANDOM);
+	if ( bReadWrite )
+		nOpenMode |= (GNOME_VFS_OPEN_WRITE | GNOME_VFS_OPEN_LOCKED);
+
+	result = gnome_vfs_open( &handle, (const sal_Char *)aURI, (GnomeVFSOpenMode) nOpenMode );
 	
 	if (result == GNOME_VFS_ERROR_INVALID_OPEN_MODE ||
 	    result == GNOME_VFS_ERROR_NOT_SUPPORTED)
-		return createTempStream( xEnv );
-	
-	if (result != GNOME_VFS_OK)
+		return xStream;
+
+	if (result == GNOME_VFS_ERROR_LOCKED )
+		throwLocked( xEnv );
+	else if (result != GNOME_VFS_OK)
 		cancelCommandExecution( result, xEnv );
 
 	// Try a seek just to make sure it's Random access: some lie.
 	result = gnome_vfs_seek( handle, GNOME_VFS_SEEK_START, 0);
 	if (result == GNOME_VFS_ERROR_NOT_SUPPORTED) {
 		gnome_vfs_close( handle );
-		return createTempStream( xEnv );
+		return xStream;
 	}
 
 	if (result != GNOME_VFS_OK)
 		cancelCommandExecution( result, xEnv );
 
 	if (handle != NULL)
-		xIn = new ::gvfs::Stream( handle, &m_info );
+		xStream = new ::gvfs::Stream( handle, &m_info );
 
-	return xIn;
+	return xStream;
 }
 
 sal_Bool
@@ -1572,25 +1608,53 @@ Content::feedSink( uno::Reference< ::com
 	if ( !aSink.is() )
 		return sal_False;
 
-	uno::Reference< io::XOutputStream > xOut
-		= uno::Reference< io::XOutputStream >(aSink, uno::UNO_QUERY );
-	uno::Reference< io::XActiveDataSink > xDataSink
-		= uno::Reference< io::XActiveDataSink >(aSink, uno::UNO_QUERY );
-	
-	if ( !xOut.is() && !xDataSink.is() )
-		return sal_False;
-
-	uno::Reference< io::XInputStream > xIn = createInputStream( xEnv );
-	if ( !xIn.is() )
-		return sal_False;
-	
+	uno::Reference< io::XOutputStream > xOut( aSink, uno::UNO_QUERY );
 	if ( xOut.is() )
+	{
+#ifdef DEBUG
+		g_warning( "feedSink(), using XOutputStream" );
+#endif
+		uno::Reference< io::XInputStream > xIn( createStream( xEnv, false ), uno::UNO_QUERY );
+		if ( !xIn.is() )
+			xIn = createTempStream( xEnv );
+		if ( !xIn.is() )
+			return sal_False;
+
 		copyData( xIn, xOut );
+		return sal_True;
+	}
 
+	uno::Reference< io::XActiveDataSink > xDataSink( aSink, uno::UNO_QUERY );
 	if ( xDataSink.is() )
+	{
+#ifdef DEBUG
+		g_warning( "feedSink(), using XActiveDataSink" );
+#endif
+		uno::Reference< io::XInputStream > xIn( createStream( xEnv, false ), uno::UNO_QUERY );
+		if ( !xIn.is() )
+			xIn = createTempStream( xEnv );
+		if ( !xIn.is() )
+			return sal_False;
+
 		xDataSink->setInputStream( xIn );
+		return sal_True;
+	}
+
+	uno::Reference< io::XActiveDataStreamer > xDataStreamer( aSink, uno::UNO_QUERY );
+	if ( xDataStreamer.is() )
+	{
+#ifdef DEBUG
+		g_warning( "feedSink(), using XActiveDataStreamer" );
+#endif
+		uno::Reference< io::XStream > xStream = createStream( xEnv, true );
+		if ( !xStream.is() )
+			return sal_False;
 
-	return sal_True;
+		xDataStreamer->setStream( xStream );
+		return sal_True;
+	}
+	
+	return sal_False;
 }
 
 extern "C" {
--- ucb/source/ucp/gvfs/content.hxx	2007-03-26 13:35:09.000000000 +0200
+++ ucb/source/ucp/gvfs/content.hxx	2007-03-26 18:51:44.000000000 +0200
@@ -65,6 +65,7 @@ namespace com { namespace sun { namespac
 namespace com { namespace sun { namespace star { namespace io {
 	class XInputStream;
 	class XOutputStream;
+	class XStream;
 } } } }
 
 namespace com { namespace sun { namespace star { namespace sdbc {
@@ -108,6 +109,7 @@ private:
 	ContentProvider  *m_pProvider;  // No need for a ref, base class holds object
 	sal_Bool          m_bTransient; // A non-existant (as yet) item
 	GnomeVFSFileInfo  m_info;       // cached status information
+	sal_Bool          m_bForceReadOnly; // behave as read-only
 
 	// Internal helpers
 	void                       queryChildren   ( ContentRefList& rChildren );
@@ -182,9 +184,10 @@ private:
 					com::sun::star::ucb::XCommandEnvironment >& xEnv )
 		throw( ::com::sun::star::uno::Exception );
 	::com::sun::star::uno::Reference<
-		::com::sun::star::io::XInputStream > 
-		createInputStream(  const ::com::sun::star::uno::Reference<
-					com::sun::star::ucb::XCommandEnvironment >& xEnv )
+		::com::sun::star::io::XStream > 
+		createStream(  const ::com::sun::star::uno::Reference<
+					com::sun::star::ucb::XCommandEnvironment >& xEnv,
+					bool bReadWrite )
 		throw( ::com::sun::star::uno::Exception );
        	sal_Bool feedSink( ::com::sun::star::uno::Reference<
 				::com::sun::star::uno::XInterface> aSink,
@@ -200,6 +203,9 @@ private:
 				    sal_Bool bWrite = sal_False )
 		throw( ::com::sun::star::uno::Exception );
 
+	void throwLocked(const ::com::sun::star::uno::Reference< com::sun::star::ucb::XCommandEnvironment > & xEnv)
+		throw( ::com::sun::star::uno::Exception );
+
 
 public:
 	// Non-interface bits
--- ucb/source/ucp/gvfs/makefile.mk	2007-03-26 13:35:09.000000000 +0200
+++ ucb/source/ucp/gvfs/makefile.mk	2007-03-23 15:06:26.000000000 +0100
@@ -61,6 +61,10 @@ CFLAGS+=-gdwarf-2
 PKGCONFIG_LIBS!:=-Wl,--export-dynamic $(PKGCONFIG_LIBS:s/ -llinc//:s/ -lbonobo-activation//:s/ -lgconf-2//:s/ -lORBit-2//:s/ -lIDL-2//:s/ -lgmodule-2.0//:s/ -lgobject-2.0//:s/ -lgthread-2.0//)
 .ENDIF          # "$(OS)" == "LINUX"
 
+.IF "$(debug)" != "" || "$(DEBUG)" != ""
+CFLAGS+=-DDEBUG
+.ENDIF
+
 # no "lib" prefix
 DLLPRE =
 
