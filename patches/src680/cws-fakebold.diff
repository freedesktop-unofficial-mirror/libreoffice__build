Index: vcl/source/glyphs/gcach_ftyp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/gcach_ftyp.cxx,v
retrieving revision 1.115
retrieving revision 1.115.46.1
diff -u -p -u -p -r1.115 -r1.115.46.1
--- vcl/source/glyphs/gcach_ftyp.cxx	9 Sep 2005 12:13:09 -0000	1.115
+++ vcl/source/glyphs/gcach_ftyp.cxx	11 Oct 2005 14:22:22 -0000	1.115.46.1
@@ -108,6 +108,29 @@
 
 // -----------------------------------------------------------------------
 
+// the gamma table makes artificial bold look better for CJK glyphs
+static unsigned char aGammaTable[257];
+
+static void InitGammaTable()
+{
+    static const int M_MAX = 255;
+    static const int M_X   = 128;
+    static const int M_Y   = 208;
+
+    unsigned int x, a;
+    for( x = 0; x < 256; x++)
+    {
+        if ( x <= M_X )
+            a = ( x * M_Y + M_X / 2) / M_X;
+        else
+            a = M_Y + ( ( x - M_X ) * ( M_MAX - M_Y ) +
+                ( M_MAX - M_X ) / 2 ) / ( M_MAX - M_X );
+    
+        aGammaTable[x] = (unsigned char)a;
+    }
+}
+// -----------------------------------------------------------------------
+
 static FT_Library aLibFT = 0;
 
 // #110607# enable linking with old FT versions
@@ -465,6 +488,8 @@ FreetypeManager::FreetypeManager()
     pEnv = ::getenv( "SAL_AUTOHINTING_PRIORITY" );
     if( pEnv )
         nPrioAutoHint  = pEnv[0] - '0';
+
+    InitGammaTable();
 }
 
 // -----------------------------------------------------------------------
@@ -782,6 +807,26 @@ FreetypeServerFont::FreetypeServerFont( 
     // TODO: query GASP table for load flags
     mnLoadFlags = FT_LOAD_DEFAULT;
 
+    mbArtItalic = (rFSD.meItalic != ITALIC_NONE && rFSD.mpFontData->GetSlant() == ITALIC_NONE);
+    mbArtBold = (rFSD.meWeight > WEIGHT_MEDIUM && rFSD.mpFontData->GetWeight() <= WEIGHT_MEDIUM);
+
+    static const int TT_CODEPAGE_RANGE_874  = (1L << 16); // Thai
+    static const int TT_CODEPAGE_RANGE_932  = (1L << 17); // JIS/Japan
+    static const int TT_CODEPAGE_RANGE_936  = (1L << 18); // Chinese: Simplified
+    static const int TT_CODEPAGE_RANGE_949  = (1L << 19); // Korean Wansung
+    static const int TT_CODEPAGE_RANGE_950  = (1L << 20); // Chinese: Traditional
+    static const int TT_CODEPAGE_RANGE_1361 = (1L << 21); // Korean Johab
+    static const int TT_CODEPAGE_RANGES1_CJKT = 0x3F0000; // all of the above
+    const TT_OS2* pOs2 = (const TT_OS2*)FT_Get_Sfnt_Table( maFaceFT, ft_sfnt_os2 );
+    if ((pOs2) && (pOs2->ulCodePageRange1 & TT_CODEPAGE_RANGES1_CJKT )
+	      && rFSD.mnHeight < 20)
+	mbUseGamma = true;
+    else
+	mbUseGamma = false;
+
+    if (mbUseGamma)
+	mnLoadFlags |= FT_LOAD_FORCE_AUTOHINT;
+
     if( (mnSin != 0) && (mnCos != 0) ) // hinting for 0/90/180/270 degrees only
         mnLoadFlags |= FT_LOAD_NO_HINTING;
     mnLoadFlags |= FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH; //#88334#
@@ -1092,7 +1137,7 @@ int FreetypeServerFont::FixupGlyphIndex(
 
 #if !defined(TT_CONFIG_OPTION_BYTECODE_INTERPRETER)
     // #95556# autohinting not yet optimized for non-western glyph styles
-    if( !(mnLoadFlags & FT_LOAD_NO_HINTING)
+    if( !(mnLoadFlags & (FT_LOAD_NO_HINTING | FT_LOAD_FORCE_AUTOHINT) )
     &&  ( (aChar >= 0x0600 && aChar < 0x1E00)   // south-east asian + arabic
         ||(aChar >= 0x2900 && aChar < 0xD800)   // CJKV
         ||(aChar >= 0xF800) ) )                 // presentation + symbols
@@ -1126,8 +1171,10 @@ void FreetypeServerFont::InitGlyphData( 
     SplitGlyphFlags( *this, nGlyphIndex, nGlyphFlags );
 
     int nLoadFlags = mnLoadFlags;
-    if( nGlyphFlags & GF_UNHINTED )
-        nLoadFlags |= FT_LOAD_NO_HINTING;
+
+    // Add by Firefly(firefly@firefly.idv.tw)
+//    if (mbArtItalic)
+//	nLoadFlags |= FT_LOAD_NO_BITMAP;    
 
     FT_Error rc = -1;
 #if (FTVERSION <= 2008)
@@ -1156,6 +1203,7 @@ void FreetypeServerFont::InitGlyphData( 
     }
 
     int nCharWidth = maFaceFT->glyph->metrics.horiAdvance;
+
     if( nGlyphFlags & GF_ROTMASK ) {  // for bVertical rotated glyphs
         const FT_Size_Metrics& rMetrics = maFaceFT->size->metrics;
 #if (FTVERSION < 2000)
@@ -1178,6 +1226,7 @@ void FreetypeServerFont::InitGlyphData( 
     {
         int t=aBbox.yMin; aBbox.yMin=aBbox.yMax, aBbox.yMax=t;
     }
+
     rGD.SetOffset( aBbox.xMin, -aBbox.yMax );
     rGD.SetSize( Size( (aBbox.xMax-aBbox.xMin+1), (aBbox.yMax-aBbox.yMin) ) );
 
@@ -1207,6 +1256,10 @@ bool FreetypeServerFont::GetGlyphBitmap1
 
     FT_Int nLoadFlags = mnLoadFlags;
 
+    // Add by Firefly(firefly@firefly.idv.tw)
+    if (mbArtItalic)
+	nLoadFlags |= FT_LOAD_NO_BITMAP;    
+
 #if (FTVERSION >= 2002)
     // for 0/90/180/270 degree fonts enable autohinting even if not advisable
     // non-hinted and non-antialiased bitmaps just look too ugly
@@ -1242,6 +1295,17 @@ bool FreetypeServerFont::GetGlyphBitmap1
 
     int nAngle = ApplyGlyphTransform( nGlyphFlags, pGlyphFT, true );
 
+    // Add by Firefly(firefly@firefly.idv.tw)
+    // ¼ÒÀÀ±×Åé
+    if (mbArtItalic)
+    {
+	FT_Matrix matrix;
+	matrix.xx = matrix.yy = 0x10000L;
+	matrix.xy = 0x6000L;
+	matrix.yx = 0;
+	FT_Glyph_Transform( pGlyphFT, &matrix, NULL );
+    }
+
     if( pGlyphFT->format != ft_glyph_format_bitmap )
     {
         if( pGlyphFT->format == ft_glyph_format_outline )
@@ -1263,9 +1327,18 @@ bool FreetypeServerFont::GetGlyphBitmap1
 
     const FT_Bitmap& rBitmapFT  = rBmpGlyphFT->bitmap;
     rRawBitmap.mnHeight         = rBitmapFT.rows;
-    rRawBitmap.mnWidth          = rBitmapFT.width;
-    rRawBitmap.mnScanlineSize   = rBitmapFT.pitch;
     rRawBitmap.mnBitCount       = 1;
+    if( mbArtBold )
+    {
+	rRawBitmap.mnWidth = rBitmapFT.width + 1;
+	int nLineBytes = (rRawBitmap.mnWidth + 7) >> 3;
+        rRawBitmap.mnScanlineSize  = (nLineBytes > rBitmapFT.pitch) ? nLineBytes : rBitmapFT.pitch;
+    }
+    else
+    {
+	rRawBitmap.mnWidth          = rBitmapFT.width;
+	rRawBitmap.mnScanlineSize   = rBitmapFT.pitch;
+    }
 
     const ULONG nNeededSize = rRawBitmap.mnScanlineSize * rRawBitmap.mnHeight;
 
@@ -1276,7 +1349,35 @@ bool FreetypeServerFont::GetGlyphBitmap1
         rRawBitmap.mpBits = new unsigned char[ rRawBitmap.mnAllocated ];
     }
 
-    memcpy( rRawBitmap.mpBits, rBitmapFT.buffer, nNeededSize );
+    if( !mbArtBold )
+    {
+	memcpy( rRawBitmap.mpBits, rBitmapFT.buffer, nNeededSize );
+    }
+    else
+    {
+        memset( rRawBitmap.mpBits, 0, nNeededSize );
+	const unsigned char* pSrcLine = rBitmapFT.buffer;
+	unsigned char* pDstLine = rRawBitmap.mpBits;
+	for( int h = rRawBitmap.mnHeight; --h >= 0; )
+	{
+	    memcpy( pDstLine, pSrcLine, rBitmapFT.pitch );
+	    pDstLine += rRawBitmap.mnScanlineSize;
+	    pSrcLine += rBitmapFT.pitch;
+	}
+
+	unsigned char* p = rRawBitmap.mpBits;
+	for( int y=0; y < rRawBitmap.mnHeight; y++ )
+	{
+	    unsigned char nLastByte = 0;
+	    for( int x=0; x < rRawBitmap.mnScanlineSize; x++ )
+	    {
+		unsigned char nTmp = p[x] << 7;
+		p[x] |= (p[x] >> 1) | nLastByte;
+		nLastByte = nTmp;
+	    }
+	    p += rRawBitmap.mnScanlineSize;
+	}
+    }
 
     FT_Done_Glyph( pGlyphFT );
 
@@ -1306,6 +1407,10 @@ bool FreetypeServerFont::GetGlyphBitmap8
 
     FT_Int nLoadFlags = mnLoadFlags;
 
+    // Add by Firefly(firefly@firefly.idv.tw)
+    if (mbArtItalic)
+	nLoadFlags |= FT_LOAD_NO_BITMAP;    
+
 #if (FTVERSION <= 2004) && !defined(TT_CONFIG_OPTION_BYTECODE_INTERPRETER)
     // autohinting in FT<=2.0.4 makes antialiased glyphs look worse
     nLoadFlags |= FT_LOAD_NO_HINTING;
@@ -1343,6 +1448,15 @@ bool FreetypeServerFont::GetGlyphBitmap8
 
     int nAngle = ApplyGlyphTransform( nGlyphFlags, pGlyphFT, true );
 
+    if( mbArtItalic )
+    {
+	FT_Matrix matrix;
+	matrix.xx = matrix.yy = 0x10000L;
+	matrix.xy = 0x6000L;
+	matrix.yx = 0;
+	FT_Glyph_Transform( pGlyphFT, &matrix, NULL );
+    }
+
     if( pGlyphFT->format == ft_glyph_format_outline )
         ((FT_OutlineGlyph)pGlyphFT)->outline.flags |= ft_outline_high_precision;
 
@@ -1361,8 +1475,14 @@ bool FreetypeServerFont::GetGlyphBitmap8
     const FT_Bitmap& rBitmapFT  = rBmpGlyphFT->bitmap;
     rRawBitmap.mnHeight         = rBitmapFT.rows;
     rRawBitmap.mnWidth          = rBitmapFT.width;
-    rRawBitmap.mnScanlineSize   = ((bEmbedded?rBitmapFT.width:rBitmapFT.pitch) + 3) & -4;
     rRawBitmap.mnBitCount       = 8;
+    rRawBitmap.mnScanlineSize   = bEmbedded ? rBitmapFT.width : rBitmapFT.pitch;
+    if( mbArtBold )
+    {
+	++rRawBitmap.mnWidth;
+        ++rRawBitmap.mnScanlineSize;
+    }
+    rRawBitmap.mnScanlineSize = (rRawBitmap.mnScanlineSize + 3) & -4;
 
     const ULONG nNeededSize = rRawBitmap.mnScanlineSize * rRawBitmap.mnHeight;
     if( rRawBitmap.mnAllocated < nNeededSize )
@@ -1400,6 +1520,36 @@ bool FreetypeServerFont::GetGlyphBitmap8
         }
     }
 
+    if( mbArtBold )
+    {
+	// overlay with glyph image shifted by one left pixel
+	unsigned char* p = rRawBitmap.mpBits;
+	for( int y=0; y < rRawBitmap.mnHeight; y++ )
+	{
+	    unsigned char nLastByte = 0;
+	    for( int x=0; x < rRawBitmap.mnWidth; x++ )
+	    {
+	        unsigned char nTmp = p[x];
+	        p[x] |= p[x] | nLastByte;
+	        nLastByte = nTmp;
+	    }
+	    p += rRawBitmap.mnScanlineSize;
+	}
+    }
+
+    if( !bEmbedded && mbUseGamma )
+    {
+	unsigned char* p = rRawBitmap.mpBits;
+	for( int y=0; y < rRawBitmap.mnHeight; y++ )
+	{
+	    for( int x=0; x < rRawBitmap.mnWidth; x++ )
+	    {
+	        p[x] = aGammaTable[ p[x] ];
+	    }
+	    p += rRawBitmap.mnScanlineSize;
+	}
+    }
+
     FT_Done_Glyph( pGlyphFT );
 
     // special case for 0/90/180/270 degree orientation
@@ -1942,7 +2092,7 @@ bool FreetypeServerFont::GetGlyphOutline
     int nGlyphFlags;
     SplitGlyphFlags( *this, nGlyphIndex, nGlyphFlags );
 
-    FT_Int nLoadFlags = FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP;
+    FT_Int nLoadFlags = FT_LOAD_DEFAULT | FT_LOAD_TARGET_LIGHT;
     FT_Error rc = FT_Load_Glyph( maFaceFT, nGlyphIndex, nLoadFlags );
     if( rc != FT_Err_Ok )
         return false;
Index: vcl/source/glyphs/gcach_ftyp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/gcach_ftyp.hxx,v
retrieving revision 1.31
retrieving revision 1.31.48.1
diff -u -p -u -p -r1.31 -r1.31.48.1
--- vcl/source/glyphs/gcach_ftyp.hxx	9 Sep 2005 12:13:26 -0000	1.31
+++ vcl/source/glyphs/gcach_ftyp.hxx	11 Oct 2005 14:22:27 -0000	1.31.48.1
@@ -213,6 +213,10 @@ private:
     FT_FaceRec_*                maFaceFT;
     FT_SizeRec_*                maSizeFT;
 
+    bool			mbArtItalic;
+    bool			mbArtBold;
+    bool			mbUseGamma;
+
     typedef ::std::hash_map<int,int> GlyphSubstitution;
     GlyphSubstitution           maGlyphSubstitution;
     rtl_UnicodeToTextConverter  maRecodeConverter;
Index: vcl/source/glyphs/glyphcache.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/glyphcache.cxx,v
retrieving revision 1.30
retrieving revision 1.30.46.1
diff -u -p -u -p -r1.30 -r1.30.46.1
--- vcl/source/glyphs/glyphcache.cxx	9 Sep 2005 12:14:52 -0000	1.30
+++ vcl/source/glyphs/glyphcache.cxx	11 Oct 2005 14:22:29 -0000	1.30.46.1
@@ -89,6 +89,8 @@ size_t GlyphCache::IFSD_Hash::operator()
     nHash   += rFontSelData.mnHeight;
     nHash   += rFontSelData.mnOrientation;
     nHash   += rFontSelData.mbVertical;
+    nHash   += rFontSelData.meItalic;
+    nHash   += rFontSelData.meWeight;
     return nHash;
 }
 
@@ -107,6 +109,10 @@ bool GlyphCache::IFSD_Equal::operator()(
     ||  (rA.mbNonAntialiased != rB.mbNonAntialiased) )
         return false;
 
+    if( (rA.meItalic != rB.meItalic)
+    ||  (rA.meWeight != rB.meWeight) )
+	return false;
+
     if( (rA.mnWidth != rB.mnWidth)
     && ((rA.mnHeight != rB.mnWidth) || (rA.mnWidth != 0)) )
         return false;
