--- sd/source/ui/inc/ViewShell.hxx	2005-02-17 15:13:08.000000000 +0530
+++ sd/source/ui/inc/ViewShell.hxx	2005-04-05 08:39:18.000000000 +0530
@@ -544,6 +544,7 @@
         As a result the border is adapted.
     */
 	virtual void ShowUIControls (bool bVisible = true);
+	BOOL IsPageFlipMode(void) const;
 
 protected:
     friend class ViewShellBase;

--- sd/source/ui/view/viewshel.cxx	2005-01-31 20:26:31.000000000 +0530
+++ sd/source/ui/view/viewshel.cxx	2005-04-05 14:04:24.184158571 +0530
@@ -205,6 +205,11 @@
 
 static const int DELTA_ZOOM = 10;
 
+BOOL ViewShell::IsPageFlipMode(void) const
+{
+	return this->ISA(DrawViewShell) && mpContentWindow.get() != NULL &&
+		mpContentWindow->GetVisibleHeight() >= 1.0;
+}
 SfxViewFrame* ViewShell::GetViewFrame (void) const
 {
     OSL_ASSERT (GetViewShell()!=NULL);
@@ -813,7 +820,14 @@
             {
                 if( mpContentWindow.get() == pWin )
                 {
-                    bDone = pWin->HandleScrollCommand( rCEvt,
+		  ULONG nScrollLines = pData->GetScrollLines();
+		  if(IsPageFlipMode())
+			nScrollLines = COMMAND_WHEEL_PAGESCROLL;
+		  CommandWheelData aWheelData( pData->GetDelta(),pData->GetNotchDelta(),
+			nScrollLines,pData->GetMode(),pData->GetModifier(),pData->IsHorz() );
+ 		  CommandEvent aReWrite( rCEvt.GetMousePosPixel(),rCEvt.GetCommand(),
+			rCEvt.IsMouseEvent(),(const void *) &aWheelData );
+	          bDone = pWin->HandleScrollCommand( aReWrite,
                         mpHorizontalScrollBar.get(),
                         mpVerticalScrollBar.get());
                 }

--- sd/source/ui/view/viewshe2.cxx	2005-02-16 22:33:50.000000000 +0530
+++ sd/source/ui/view/viewshe2.cxx	2005-04-05 14:04:16.666031855 +0530
@@ -193,14 +193,30 @@
 	{
 		long nH = (long)(mpContentWindow->GetVisibleHeight() * 32000);
 		long nY = (long)(mpContentWindow->GetVisibleY() * 32000);
-		mpVerticalScrollBar->SetVisibleSize(nH);
-		mpVerticalScrollBar->SetThumbPos(nY);
-		nH = 32000 - nH;
-		long nLine = (long) (mpContentWindow->GetScrlLineHeight() * nH);
-		long nPage = (long) (mpContentWindow->GetScrlPageHeight() * nH);
-		mpVerticalScrollBar->SetLineSize(nLine);
-		mpVerticalScrollBar->SetPageSize(nPage);
-	}
+		USHORT nCurPage ,nTotalPages;
+		if(IsPageFlipMode()) // ie in zoom mode where no panning
+		{
+			SdPage* pPage = static_cast<DrawViewShell*>(this)->GetActualPage();
+                	nCurPage = (pPage->GetPageNum() - 1) / 2;
+			nTotalPages = GetDoc()->GetSdPageCount(pPage->GetPageKind());		  	 						
+			mpVerticalScrollBar->SetRange(Range(0,256*nTotalPages));	
+			mpVerticalScrollBar->SetVisibleSize(256);
+			mpVerticalScrollBar->SetThumbPos(256*nCurPage);
+			mpVerticalScrollBar->SetLineSize(256);
+			mpVerticalScrollBar->SetPageSize(256); 		  			
+		}	
+		else 
+		{			
+			mpVerticalScrollBar->SetRange(Range(0,32000));	
+			mpVerticalScrollBar->SetVisibleSize(nH);
+			mpVerticalScrollBar->SetThumbPos(nY);
+			nH = 32000 - nH;
+			long nLine = (long) (mpContentWindow->GetScrlLineHeight() * nH);
+			long nPage = (long) (mpContentWindow->GetScrlPageHeight() * nH);
+			mpVerticalScrollBar->SetLineSize(nLine);
+			mpVerticalScrollBar->SetPageSize(nPage); 
+		}
+	}		
 	if (mbHasRulers)
 	{
 		UpdateHRuler();
@@ -291,10 +307,17 @@
 
 long ViewShell::VirtVScrollHdl(ScrollBar* pVScroll)
 {
-	long nDelta = pVScroll->GetDelta();
+	if(IsPageFlipMode())
+	{ 
+	   SdPage* pPage = static_cast<DrawViewShell*>(this)->GetActualPage();
+           USHORT nCurPage = (pPage->GetPageNum() - 1) / 2;
+	   USHORT nNewPage = pVScroll->GetThumbPos()/256;	
+	   if( nCurPage != nNewPage )
+		 static_cast<DrawViewShell*>(this)->SwitchPage(nNewPage);
+	}
 
-	if (nDelta != 0)
-	{
+	else //panning mode
+	{ 		
 		double fY = (double) pVScroll->GetThumbPos() / pVScroll->GetRange().Len();
 
         ::sd::View* pView = GetView();
