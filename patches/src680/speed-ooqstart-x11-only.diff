--- desktop/unx/source/makefile.mk	2006-03-08 16:51:04.000000000 +0000
+++ desktop/unx/source/makefile.mk	2006-03-08 14:34:20.000000000 +0000
@@ -10,18 +10,20 @@ NO_DEFAULT_STL=TRUE
 dummy:
 	@echo "Nothing to build. GUIBASE == $(GUIBASE), WITH_WIDGETSET == $(WITH_WIDGETSET)"
 
-.ELSE # build with gtk+
+.ELSE # we need glib...
 
-PKGCONFIG_MODULES=gtk+-2.0
+PKGCONFIG_MODULES=glib-2.0
 .INCLUDE: pkg_config.mk
 
 CFLAGS+= $(PKGCONFIG_CFLAGS)
+STDLIB=
 
 APP1TARGET = $(TARGET)
-APP1OBJS   = $(OBJ)$/start.obj
+APP1OBJS   = $(OBJ)$/splashx.obj $(OBJ)$/start.obj
 APP1NOSAL  = TRUE
 APP1LIBSALCPPRT=
-APP1STDLIBS = $(PKGCONFIG_LIBS)
+APP1CODETYPE = C
+APP1STDLIBS = $(PKGCONFIG_LIBS) -lX11
 
 .ENDIF
 
--- desktop/unx/source/splashx.c	1970-01-01 00:00:00.000000000 +0000
+++ desktop/unx/source/splashx.c	2006-03-08 17:08:23.000000000 +0000
@@ -0,0 +1,528 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+#include <X11/Xutil.h>
+
+#include <endian.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "splashx.h"
+
+#define WINDOW_WIDTH  440
+#define WINDOW_HEIGHT 299
+
+#define PROGRESS_XOFFSET 12
+#define PROGRESS_YOFFSET 18
+#define PROGRESS_BARSPACE 2
+
+static Display *display = NULL;
+static int screen;
+static int depth;
+static Visual *visual = NULL;
+
+static int width = WINDOW_WIDTH;
+static int height = WINDOW_HEIGHT;
+
+static Colormap color_map;
+static Window win;
+static GC gc;
+
+typedef struct {
+	unsigned char b, g, r;
+} color_t;
+static color_t *bitmap = NULL;
+
+#define BMP_HEADER_LEN 14
+#define WIN_INFO_LEN 40
+
+#define UINT8( x )      ( (unsigned int)( ( (uint8_t *)( x ) )[0] ) )
+
+#define UINT16( x ) (   ( (unsigned int)( ( (uint8_t *)( x ) )[0] ) ) + \
+                      ( ( (unsigned int)( ( (uint8_t *)( x ) )[1] ) ) << 8 ) )
+
+#define UINT32( x ) (   ( (unsigned int)( ( (uint8_t *)( x ) )[0] ) ) + \
+                      ( ( (unsigned int)( ( (uint8_t *)( x ) )[1] ) ) << 8  ) + \
+                      ( ( (unsigned int)( ( (uint8_t *)( x ) )[2] ) ) << 16 ) + \
+                      ( ( (unsigned int)( ( (uint8_t *)( x ) )[3] ) ) << 24 ) )
+
+#define MAX( x, y ) ( ( (x) > (y) )? (x): (y) )
+
+#define LOAD_FAILURE( msg ) \
+	{ \
+		fprintf( stderr, "%s: " msg, filename ); \
+		close( fd ); \
+		return 0; \
+	}
+
+// Load the specified Windows 24bit BMP to 'bitmap'
+// Return: 1 - success, 0 - failure
+int splash_load_bmp( char *filename )
+{
+	int fd = open( filename, O_RDONLY );
+	if ( fd < 0 )
+		return 0;
+
+	char file_header[ BMP_HEADER_LEN ];
+	
+	if ( read( fd, file_header, BMP_HEADER_LEN ) != BMP_HEADER_LEN || file_header[0] != 'B' || file_header[1] != 'M' )
+		LOAD_FAILURE( "Not a bitmap.\n" );
+
+	int file_size = UINT32( file_header + 2 );
+	
+	char info_header[ WIN_INFO_LEN ];
+	if ( read( fd, info_header, 4 ) != 4 )
+		LOAD_FAILURE( "Unable to read the header.\n" );
+
+	int header_size = UINT32( info_header );
+	if ( header_size != WIN_INFO_LEN )
+		LOAD_FAILURE( "Not a Windows bitmap.\n" );
+
+	if ( read( fd, info_header + 4, WIN_INFO_LEN - 4 ) != WIN_INFO_LEN - 4 )
+		LOAD_FAILURE( "The header ended too early.\n" );
+
+	width = UINT32( info_header + 4 );
+	height = UINT32( info_header + 8 );
+
+	int bits = UINT16( info_header + 14 );
+	int compression = UINT16( info_header + 16 );
+
+	if ( bits != 24 )
+		LOAD_FAILURE( "Just 24 bpp bitmaps are supported.\n" );
+
+	if ( compression != 0 )
+		LOAD_FAILURE( "Just uncompressed bitmaps are supported.\n" );
+
+	size_t bitmap_size = width * height * 3;
+	bitmap = malloc( bitmap_size );
+	if ( bitmap == NULL )
+		LOAD_FAILURE( "Cannot allocate memory for the data.\n" );
+
+	int y;
+	size_t line_size = width * 3;
+	color_t *line = bitmap + ( height - 1 ) * width;
+	for ( y = height; y > 0; --y, line -= width )
+	{
+		if ( read( fd, line, line_size ) != line_size )
+			LOAD_FAILURE( "Cannot read the bitmap data.\n" );
+	}
+
+	close( fd );
+	return 1;
+}
+
+// Universal shift: bits >= 0 - left, otherwise right
+#define SHIFT( x, bits ) ( ( (bits) >= 0 )? ( (x) << (bits) ): ( (x) >> -(bits) ) )
+
+// Position of the highest bit (more or less integer log2)
+inline int HIGHEST_BIT( unsigned long x )
+{
+	int i = 0;
+	for ( ; x; ++i )
+		x >>= 1;
+
+	return i;
+}
+
+// Number of bits set to 1
+inline int BITS( unsigned long x )
+{
+	int i = 0;
+	for ( ; x; x >>= 1 )
+		if ( x & 1UL )
+			++i;
+
+	return i;
+}
+
+// Set 'bitmap' as the background of our 'win' window
+static void create_pixmap()
+{
+	if ( !bitmap )
+		return;
+
+	Pixmap pixmap = XCreatePixmap( display, win, width, height, depth );
+
+	unsigned long value_mask = 0;
+	XGCValues values;
+	GC pixmap_gc = XCreateGC( display, pixmap, value_mask, &values );
+
+	if ( visual->class == TrueColor )
+	{
+		unsigned long red_mask   = visual->red_mask;
+		unsigned long green_mask = visual->green_mask;
+		unsigned long blue_mask  = visual->blue_mask;
+
+		unsigned long red_delta_mask   = ( 1UL << ( 8 - BITS( red_mask ) ) ) - 1;
+		unsigned long green_delta_mask = ( 1UL << ( 8 - BITS( green_mask ) ) ) - 1;
+		unsigned long blue_delta_mask  = ( 1UL << ( 8 - BITS( blue_mask ) ) ) - 1;
+
+		int red_shift   = HIGHEST_BIT( red_mask ) - 8;
+		int green_shift = HIGHEST_BIT( green_mask ) - 8;
+		int blue_shift  = HIGHEST_BIT( blue_mask ) - 8;
+
+		XImage *image = XCreateImage( display, visual, depth, ZPixmap,
+				0, NULL, width, height, 32, 0 );
+
+		int bytes_per_line = image->bytes_per_line;
+		int bpp = image->bits_per_pixel;
+		int byte_order = image->byte_order; 
+		int machine_byte_order = ( __BYTE_ORDER == __LITTLE_ENDIAN )? LSBFirst: MSBFirst;
+
+		if ( __BYTE_ORDER != __LITTLE_ENDIAN && __BYTE_ORDER != __BIG_ENDIAN )
+		{
+			fprintf( stderr, "Unsupported machine endianity.\n" );
+			XFreeGC( display, pixmap_gc );
+			XFreePixmap( display, pixmap );
+			XDestroyImage( image );
+			return;
+		}
+
+		char *data = malloc( height * bytes_per_line );
+		image->data = data;
+
+		// The following dithers & converts the color_t color to one
+		// acceptable for the visual
+#define COPY_IN_OUT( code ) \
+		{ \
+			int x, y; \
+			for ( y = 0; y < height; ++y ) \
+			{ \
+				unsigned long red_delta = 0, green_delta = 0, blue_delta = 0; \
+				for ( x = 0; x < width; ++x, ++in  ) \
+				{ \
+					unsigned long red   = in->r + red_delta; \
+					unsigned long green = in->g + green_delta; \
+					unsigned long blue  = in->b + blue_delta; \
+					red_delta = red & red_delta_mask; \
+					green_delta = green & green_delta_mask; \
+					blue_delta = blue & blue_delta_mask; \
+					if ( red > 255 ) \
+						red = 255; \
+					if ( green > 255 ) \
+						green = 255; \
+					if ( blue > 255 ) \
+						blue = 255; \
+					unsigned long pixel = \
+						( SHIFT( red, red_shift ) & red_mask ) | \
+						( SHIFT( green, green_shift ) & green_mask ) | \
+						( SHIFT( blue, blue_shift ) & blue_mask ); \
+					code \
+				} \
+			} \
+		}
+
+		color_t *in = bitmap;
+		char *out = data;
+
+		if ( bpp == 32 )
+		{
+			if ( machine_byte_order == byte_order )
+				COPY_IN_OUT( *( (uint32_t *)out ) = (uint32_t)pixel; out += 4; )
+			else
+				COPY_IN_OUT( uint32_t tmp = pixel;
+							 *( (uint8_t *)out     ) = *( (uint8_t *)(&tmp) + 3 );
+							 *( (uint8_t *)out + 1 ) = *( (uint8_t *)(&tmp) + 2 );
+							 *( (uint8_t *)out + 2 ) = *( (uint8_t *)(&tmp) + 1 );
+							 *( (uint8_t *)out + 3 ) = *( (uint8_t *)(&tmp)     );
+							 out += 4; )
+		}
+		else if ( bpp == 24 )
+		{
+			if ( machine_byte_order == byte_order && byte_order == LSBFirst )
+				COPY_IN_OUT( *( (color_t *)out ) = *( (color_t *)( &pixel ) ); out += 3; )
+			if ( machine_byte_order == byte_order && byte_order == MSBFirst )
+				COPY_IN_OUT( uint32_t tmp = pixel;
+							 *( (uint8_t *)out     ) = *( (uint8_t *)(&tmp) + 1 );
+							 *( (uint8_t *)out + 1 ) = *( (uint8_t *)(&tmp) + 2 );
+							 *( (uint8_t *)out + 2 ) = *( (uint8_t *)(&tmp) + 3 );
+							 out += 3; )
+			else
+				COPY_IN_OUT( uint32_t tmp = pixel;
+							 *( (uint8_t *)out     ) = *( (uint8_t *)(&tmp) + 3 );
+							 *( (uint8_t *)out + 1 ) = *( (uint8_t *)(&tmp) + 2 );
+							 *( (uint8_t *)out + 2 ) = *( (uint8_t *)(&tmp) + 1 );
+							 out += 3; )
+		}
+		else if ( bpp == 16 )
+		{
+			if ( machine_byte_order == byte_order )
+				COPY_IN_OUT( *( (uint16_t *)out ) = (uint16_t)pixel; out += 2; )
+			else
+				COPY_IN_OUT( uint16_t tmp = pixel;
+							 *( (uint8_t *)out     ) = *( (uint8_t *)(&tmp) + 1 );
+							 *( (uint8_t *)out + 1 ) = *( (uint8_t *)(&tmp)     );
+							 out += 2; );
+		}
+		else if ( bpp == 8 )
+		{
+			COPY_IN_OUT( *( (uint8_t *)out ) = (uint8_t)pixel; ++out; )
+		}
+		else
+		{
+			fprintf( stderr, "Unsupported depth: %d bits per pixel.\n", bpp );
+			XFreeGC( display, pixmap_gc );
+			XFreePixmap( display, pixmap );
+			XDestroyImage( image );
+			return;
+		}
+
+#undef COPY_IN_OUT
+
+		XPutImage( display, pixmap, pixmap_gc, image, 0, 0, 0, 0, width, height );
+		XDestroyImage( image );
+	}
+	else //if ( depth == 1 || visual->class == DirectColor )
+	{
+		// FIXME Something like the following, but faster ;-) - XDrawPoint is not
+		// a good idea...
+		int x, y;
+		for ( y = 0; y < height; ++y )
+		{
+			color_t *color = bitmap + y * width;
+
+			int delta = 0;
+			for ( x = 0; x < width; ++x, ++color )
+			{
+				int rnd = (int)( ( (long)( random() - RAND_MAX/2 ) * 32000 )/RAND_MAX );
+				int luminance = delta + rnd + 299 * (int)color->r + 587 * (int)color->g + 114 * (int)color->b;
+
+				if ( luminance < 128000 )
+				{
+					XSetForeground( display, pixmap_gc, BlackPixel( display, screen ) );
+					delta = luminance;
+				}
+				else
+				{
+					XSetForeground( display, pixmap_gc, WhitePixel( display, screen ) );
+					delta = luminance - 255000;
+				}
+
+				XDrawPoint( display, pixmap, pixmap_gc, x, y );
+			}
+		}
+	}
+
+	XSetWindowBackgroundPixmap( display, win, pixmap );
+
+	XFreeGC( display, pixmap_gc );
+	XFreePixmap( display, pixmap );
+}
+
+// The old method of hiding the window decorations
+static void suppress_decorations_motif()
+{
+	struct {
+		unsigned long flags, functions, decorations;
+		long input_mode;
+		unsigned long status;
+	} mwmhints;
+
+	Atom a = XInternAtom( display, "_MOTIF_WM_HINTS", False );
+
+	mwmhints.flags = 15; // functions, decorations, input_mode, status
+	mwmhints.functions = 2; // ?
+	mwmhints.decorations = 0;
+	mwmhints.input_mode = 0;
+
+	XChangeProperty( display, win, a, a, 32,
+			PropModeReplace, (unsigned char*)&mwmhints, 5 );
+}
+
+// This is a splash, set it as such.
+// If it fails, just hide the decorations...
+static void suppress_decorations()
+{
+	Atom atom_type = XInternAtom( display, "_NET_WM_WINDOW_TYPE", True );
+	Atom atom_splash = XInternAtom( display, "_NET_WM_WINDOW_TYPE_SPLASH", True );
+
+	if ( atom_type != None && atom_splash != None )
+		XChangeProperty( display, win, atom_type, XA_ATOM, 32,
+				PropModeReplace, (unsigned char*)&atom_splash, 1 );
+	//else
+		suppress_decorations_motif(); // FIXME: Unconditional until Metacity/compiz's SPLASH handling is fixed
+}
+
+// Create the window
+// Return: 1 - success, 0 - failure
+int splash_create_window( int argc, char** argv )
+{
+	char *display_name = NULL;
+	int i;
+	for ( i = 0; i < argc; i++ )
+	{
+		if ( !strcmp( argv[i], "-display" )  || !strcmp( argv[i], "--display" ) )
+			display_name = ( i + 1 < argc )? argv[i+1]: NULL;
+	}
+
+	if ( !display_name )
+		display_name = getenv( "DISPLAY" );
+
+	// init display
+	display = XOpenDisplay( display_name );
+	if ( !display )
+	{
+		fprintf( stderr, "Failed to open display\n" );
+		return 0;
+	}
+
+	// create the window
+	screen = DefaultScreen( display );
+	depth = DefaultDepth( display, screen );
+	color_map = DefaultColormap( display, screen );
+	visual = DefaultVisual( display, screen );
+
+	Window root_win = RootWindow( display, screen );
+	int display_width = DisplayWidth( display, screen );
+	int display_height = DisplayHeight( display, screen );
+
+	win = XCreateSimpleWindow( display, root_win,
+			( display_width - width ) / 2, ( display_height - height ) / 2,
+			width, height, 0,
+			BlackPixel( display, screen ), BlackPixel( display, screen ) );
+
+	XSetWindowColormap( display, win, color_map );
+
+	// FIXME Do we want an own colormap for 8bpp displays?
+
+	// not resizable, no decorations, etc.
+	unsigned long value_mask = 0;
+	XGCValues values;
+	gc = XCreateGC( display, win, value_mask, &values );
+
+	XSizeHints size_hints;
+	size_hints.flags = PPosition | PSize | PMinSize | PMaxSize;
+	size_hints.min_width = width;
+	size_hints.max_width = width;
+	size_hints.min_height = height;
+	size_hints.max_height = height;
+
+	char *name = "OpenOffice.org";
+	char *icon = "icon"; // FIXME
+
+	XSetStandardProperties( display, win, name, icon, None,
+			0, 0, &size_hints ); 
+
+	// the actual work
+	suppress_decorations();
+	create_pixmap();
+
+	// show it
+	XSelectInput( display, win, 0 );
+	XMapWindow( display, win );
+
+	return 1;
+}
+
+// Re-draw & rocess the events
+// Just throwing them away - we do not need anything more...
+static void process_events()
+{
+	XEvent xev;
+	int num_events;
+
+	XFlush( display );
+	num_events = XPending( display );
+	while ( num_events > 0 )
+	{
+		num_events--;
+		XNextEvent( display, &xev );
+		//process_event(xev);
+	}
+}
+
+// Draw the progress
+void splash_draw_progress( int progress )
+{
+	// values taken from desktop/source/splash/splash.cxx
+	static int tlx = 212;
+	static int tly = 216;
+	static int barwidth = 263;
+	static int barheight = 8;
+	static int barspace = PROGRESS_BARSPACE;
+	static int initialized = 0;
+	if ( !initialized )
+	{
+		if ( width <= 500)
+		{
+			barwidth  = width - (2 * PROGRESS_XOFFSET);
+			barheight = 6;
+			tlx = PROGRESS_XOFFSET;
+			tly = height - PROGRESS_YOFFSET;
+		}
+		initialized = 1;
+	}
+
+	// sanity
+	if ( progress < 0 )
+		progress = 0;
+	if ( progress > 100 )
+		progress = 100;
+	
+	// draw progress...
+	int length = ( progress * barwidth / 100 ) - ( 2 * barspace );
+	if (length < 0)
+		length = 0;
+
+	// border
+	XSetForeground( display, gc, WhitePixel( display, screen ) );
+	XDrawRectangle( display, win, gc,
+			tlx, tly,
+			barwidth, barheight );
+
+	// progress bar
+	XSetForeground( display, gc, WhitePixel( display, screen ) );
+	XFillRectangle( display, win, gc,
+			tlx + barspace, tly + barspace,
+			length + 1, barheight - 2*barspace + 1 );
+
+	// pending events
+	process_events();
+}
+
+// Close the window & cleanup
+void splash_close_window()
+{
+	XCloseDisplay( display );
+
+	free( bitmap );
+	bitmap = NULL;
+}
--- desktop/unx/source/splashx.h	1970-01-01 00:00:00.000000000 +0000
+++ desktop/unx/source/splashx.h	2006-03-08 17:07:25.000000000 +0000
@@ -0,0 +1,58 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SPLASHX_H
+#define _SPLASHX_H
+
+// Load the specified Windows 24bit BMP we can have as a background of the
+// splash.
+// 
+// Note: Must be called before the create_window(), otherwise there will be no
+// image in the splash, just black rectangle.
+// 
+// Return: 1 - success, 0 - failure (non-existing, etc.)
+int splash_load_bmp( char *filename );
+
+// Create the splash window
+// Return: 1 - success, 0 - failure
+int splash_create_window( int argc, char** argv );
+
+// Destroy the splash window
+void splash_close_window();
+
+// Update the progress bar
+void splash_draw_progress( int progress );
+
+#endif // _SPLASHX_H
--- desktop/unx/source/start.c	2006-03-08 16:51:04.000000000 +0000
+++ desktop/unx/source/start.c	2006-03-08 17:08:34.000000000 +0000
@@ -1,6 +1,41 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
 #include <signal.h>
 #include <unistd.h>
-#include <gtk/gtk.h>
+#include <glib.h>
 #include <limits.h>
 #include <stdlib.h>
 #include <sys/types.h>
@@ -142,56 +177,10 @@ send_args (int fd, GPtrArray *args, cons
 	return write (fd, arg_str->str, len) == len;
 }
 
-static void
-init_gtk (int argc, char **argv)
-{
-	int i;
-    char *args[3];
-	char **argptr = args;
-	
-	args[0] = argv[0];
-	argc = 1;
-	for (i = 0; i < argc - 1; i++)
-	{
-		if (!strcmp (argv[i], "-display") ||
-		!strcmp (argv[i], "--display"))
-		{
-			args[argc++] = g_strdup ("--display");
-			args[argc++] = argv[i+1];
-		}
-	}
-    gtk_init_check( &argc, &argptr );
-}
-
-static void
-center_window (GtkWindow *window, void *dummy)
-{
-	GdkRectangle rect;
-
-	gdk_screen_get_monitor_geometry (window->screen, 0, &rect);
-	int sx = rect.width;
-	int sy = rect.height;
-	
-	GdkGeometry geom;
-	geom.base_width = GTK_WIDGET (window)->allocation.width;
-	geom.base_height = GTK_WIDGET (window)->allocation.height;
-	geom.min_width = geom.max_width = geom.base_width;
-	geom.min_height = geom.max_height = geom.base_height;
-
-	gtk_window_move (window, sx / 2 - geom.min_width / 2,
-			 sy / 2 - geom.min_height / 2);
-
-	int hints = GDK_HINT_POS | GDK_HINT_USER_POS |
-		GDK_HINT_BASE_SIZE | GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE |
-		GDK_HINT_USER_SIZE;
-
-	gtk_window_set_geometry_hints (window, NULL, &geom, (GdkWindowHints) hints);
-}
-
 typedef struct {
 	gboolean finish;
 	gboolean error;
-	GtkProgressBar *progress_bar;
+	int percent;
 }  StatusClosure;
 
 static gboolean
@@ -221,8 +210,7 @@ status_pipe_update (GIOChannel * source,
 				if (!g_ascii_strncasecmp (str->str, "end", 3))
 					retval = FALSE;
 				if (sscanf (str->str, "%d%%", &percent))
-					gtk_progress_bar_set_fraction (cl->progress_bar,
-											   (float) percent / 100.0);
+					cl->percent = percent;
 				break;
 		}
 		g_string_free (str, TRUE);
@@ -240,72 +228,32 @@ status_pipe_update (GIOChannel * source,
 	return retval;
 }
 
-static GdkPixbuf *
-get_splash (const char *image_path)
+static void
+load_splash_image (const char *image_path)
 {
 	char *path;
-	GdkPixbuf *pixbuf;
+	int success;
 
 	path = g_strconcat (image_path, "/intro-nld.bmp", NULL);
-	pixbuf = gdk_pixbuf_new_from_file (path, NULL);
+	success = splash_load_bmp (path);
 	g_free (path);
-	if (pixbuf)
-		return pixbuf;
+	if (success)
+		return;
 
 	path = g_strconcat (image_path, "/intro.bmp", NULL);
-	pixbuf = gdk_pixbuf_new_from_file (path, NULL);
+	success = splash_load_bmp (path);
 	g_free (path);
-
-	return pixbuf;
 }
 
 static void
-show_splash (const char *image_path, GIOChannel *status_channel)
+show_splash (GIOChannel *status_channel)
 {
-	GdkPixbuf *pixbuf;
-	GtkWidget *contents;
-	GtkWidget *vbox;
 	StatusClosure cl;
 
-	if ((pixbuf = get_splash (image_path)))
-		contents = gtk_image_new_from_pixbuf (pixbuf);
-	else
-		contents = gtk_label_new ("No splash pixmap");
-
 	/* setup closure */
 	cl.finish = FALSE;
 	cl.error = FALSE;
-	cl.progress_bar = GTK_PROGRESS_BAR (gtk_progress_bar_new ());
-
-	/* pack contents & progres bar */
-	vbox = gtk_vbox_new (FALSE, 0);
-	gtk_box_pack_start (GTK_BOX (vbox), contents,
-				TRUE, FALSE, 0);
-	gtk_progress_bar_set_orientation (
-		cl.progress_bar, GTK_PROGRESS_LEFT_TO_RIGHT);
-	gtk_progress_bar_set_fraction (cl.progress_bar, 0.03);
-	gtk_box_pack_start (GTK_BOX (vbox), GTK_WIDGET (cl.progress_bar),
-				FALSE, FALSE, 0);
-
-	/* setup window */
-	GtkWindow *window;
-	window = GTK_WINDOW (gtk_window_new (GTK_WINDOW_TOPLEVEL));
-	gtk_window_set_has_frame (window, FALSE);
-	gtk_window_set_resizable (window, FALSE);
-	gtk_window_set_decorated (window, FALSE);
-/*		gtk_window_set_icon_name (window, "foo"); FIXME splash WM icon ? */
-
-	/* click to dismiss */
-	GtkWidget *event_box;
-	event_box = gtk_event_box_new ();
-	gtk_container_add (GTK_CONTAINER (event_box), vbox);
-	g_signal_connect_swapped (G_OBJECT (event_box), "button_press_event",
-				  G_CALLBACK (gtk_widget_hide), (gpointer) window);
-
-	gtk_container_add (GTK_CONTAINER (window), event_box);
-	g_signal_connect (G_OBJECT (window), "realize", 
-			  G_CALLBACK (center_window), NULL);
-	gtk_widget_show_all (GTK_WIDGET (window));
+	cl.percent = 0;
 
 	/* setup status listener ... */
 	g_io_add_watch (status_channel, 
@@ -316,7 +264,13 @@ show_splash (const char *image_path, GIO
 	g_warning ("Start main loop...\n");
 #endif
 	while (!cl.finish)
-               g_main_context_iteration (g_main_context_default (), TRUE);
+	{
+		splash_draw_progress (cl.percent);
+		if ( g_main_context_pending (g_main_context_default ()) )
+			g_main_context_iteration (g_main_context_default (), TRUE);
+		else
+			usleep (20000);
+	}
 
 	if (cl.error)
 		g_warning ("Unknown error forking main binary / abnormal early exit ...");
@@ -343,20 +297,6 @@ static void
 system_checks (void)
 {
 #ifdef LINUX
-	int fd;
-	char *recently_used;
-
-	/* FIXME: force right ownership of ~/.ooo-* as well
-	 * really all that work should be done by OO.o - not here.
-	 */
-
-	/* force right ownership on ~/.recently-used despite umask */
-	recently_used = g_strconcat (g_get_home_dir (), "/.recently-used", NULL);
-	fd = open (recently_used, O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
-	if (fd >= 0)
-		close (fd);
-	g_free (recently_used);
-
 	/* check proc is mounted - lots of things fail otherwise */
 	if (!g_file_test ("/proc/version", G_FILE_TEST_EXISTS))
 		g_warning ("/proc not mounted - OO.o is unlikely to work well if at all");
@@ -458,16 +398,6 @@ setup_args (int argc, char **argv, const
 	{
 		char *converted;
 
-		if (arg_check (argv[i], "widgets-set"))
-		{
-			char *widget_env;
-			if (i >= argc - 1)
-				continue;
-			widget_env = g_strconcat ("SAL_USE_VCLPLUGIN=", argv[i+1], NULL);
-			putenv (widget_env); /* deliberate leak */
-			i++;
-			continue;
-		}
 		if (i)
 			converted = convert_path (argv[i], cwd_str, next_arg_not_filename);
 		else
@@ -481,8 +411,8 @@ setup_args (int argc, char **argv, const
 			have_non_option = TRUE;
 
 		else if (arg_check (argv[i], "nologo") ||
-			 arg_check (argv[i], "headless") ||
-			 arg_check (argv[i], "invisible"))
+				 arg_check (argv[i], "headless") ||
+				 arg_check (argv[i], "invisible"))
 			*inhibit_splash = TRUE;
 
 		else if (arg_check (argv[i], "-pt"))
@@ -525,6 +455,8 @@ int main (int argc, char **argv)
 	if (!app_path)
 		g_error ("Pathalogical failure: can't read app link\n");
 
+	load_splash_image (app_path);
+
 	pipe_path = get_pipe_path (app_path);
 
 	if ((fd = connect_pipe (pipe_path)) >= 0)
@@ -536,20 +468,24 @@ int main (int argc, char **argv)
 
 	if (!sent_args)
 	{
+		if (!inhibit_splash)
+		{
+			if (splash_create_window (argc, argv))
+				splash_draw_progress (0);
+			else
+				inhibit_splash = TRUE;
+		}
+
 		if (! fork_app (app_path, args, fd, &status_channel))
 			return 1;
-	}
 
-	init_gtk (argc, argv);
-	if (sent_args || inhibit_splash)
-	{
-		gdk_notify_startup_complete ();
-		return 0;
+		if (!inhibit_splash)
+		{
+			show_splash (status_channel);
+			splash_close_window ();
+		}
 	}
 
-	if (!inhibit_splash)
-		show_splash (app_path, status_channel);
-
 	g_ptr_array_foreach (args, (GFunc)g_free, NULL);
 	g_ptr_array_free (args, TRUE);
 	g_free (app_path);
