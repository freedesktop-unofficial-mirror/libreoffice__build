--- hsqldb/hsqldb_1_8_0.old	2006-11-03 16:38:39.000000000 +0100
+++ hsqldb/hsqldb_1_8_0	2006-11-03 20:12:01.000000000 +0100
@@ -1,58 +1,6 @@
-*** misc/hsqldb/makefile.mk	2006-10-11 20:13:37.000000000 +0200
---- misc/build/hsqldb/makefile.mk	2006-10-11 20:25:37.000000000 +0200
-***************
-*** 1 ****
-! dummy
---- 1,47 ----
-! #*************************************************************************
-! #
-! #   OpenOffice.org - a multi-platform office productivity suite
-! #
-! #   $RCSfile: build-java-target.diff,v $
-! #
-! #   $Revision: 1.1 $
-! #
-! #   last change: $Author: pmladek $ $Date: 2006/10/12 15:20:23 $
-! #
-! #   The Contents of this file are made available subject to
-! #   the terms of GNU Lesser General Public License Version 2.1.
-! #
-! #
-! #     GNU Lesser General Public License Version 2.1
-! #     =============================================
-! #     Copyright 2005 by Sun Microsystems, Inc.
-! #     901 San Antonio Road, Palo Alto, CA 94303, USA
-! #
-! #     This library is free software; you can redistribute it and/or
-! #     modify it under the terms of the GNU Lesser General Public
-! #     License version 2.1, as published by the Free Software Foundation.
-! #
-! #     This library is distributed in the hope that it will be useful,
-! #     but WITHOUT ANY WARRANTY; without even the implied warranty of
-! #     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-! #     Lesser General Public License for more details.
-! #
-! #     You should have received a copy of the GNU Lesser General Public
-! #     License along with this library; if not, write to the Free Software
-! #     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
-! #     MA  02111-1307  USA
-! #
-! #*************************************************************************
-! 
-! PRJ=..$/..$/..$/..
-! PRJNAME=so_hsqldb
-! TARGET=so_hsqldb
-! 
-! # buildfile is in a subdirectory
-! ANT_BUILDFILE=build$/build.xml
-! 
-! .INCLUDE : ant.mk
-! 
-! ANT_FLAGS+=-Dbuild.label="build-$(RSCREVISION)" jar
-! 
-! ALLTAR : ANTBUILD
-*** misc/hsqldb/build/build.xml	2005-10-23 18:54:00.000000000 +0200
---- misc/build/hsqldb/build/build.xml	2006-10-11 17:37:43.000000000 +0200
+diff -crN misc/hsqldb/build/build.xml misc/build/hsqldb/build/build.xml
+*** misc/hsqldb/build/build.xml	2006-11-03 20:04:36.000000000 +0100
+--- misc/build/hsqldb/build/build.xml	2006-11-03 20:05:44.000000000 +0100
 ***************
 *** 16,28 ****
      <property file='build/build.properties'/>
@@ -524,8 +472,9 @@
           <jar jarfile="lib/hsqldbmain.jar"
                basedir="classes"
            >
-*** misc/hsqldb/doc/changelist_1_8_0.txt	Wed Nov  2 14:19:26 2005
---- misc/build/hsqldb/doc/changelist_1_8_0.txt	Tue May 30 16:22:33 2006
+diff -crN misc/hsqldb/doc/changelist_1_8_0.txt misc/build/hsqldb/doc/changelist_1_8_0.txt
+*** misc/hsqldb/doc/changelist_1_8_0.txt	2006-11-03 20:05:07.000000000 +0100
+--- misc/build/hsqldb/doc/changelist_1_8_0.txt	2006-11-03 20:05:44.000000000 +0100
 ***************
 *** 6,11 ****
 --- 6,19 ----
@@ -543,8 +492,9 @@
   
   2005.11.02 1.8.0.3
   
-*** misc/hsqldb/docsrc/guide/sqltool.xml	Sat Jun  4 20:07:12 2005
---- misc/build/hsqldb/docsrc/guide/sqltool.xml	Tue May 30 16:22:32 2006
+diff -crN misc/hsqldb/docsrc/guide/sqltool.xml misc/build/hsqldb/docsrc/guide/sqltool.xml
+*** misc/hsqldb/docsrc/guide/sqltool.xml	2005-06-04 20:07:12.000000000 +0200
+--- misc/build/hsqldb/docsrc/guide/sqltool.xml	2006-11-03 20:05:44.000000000 +0100
 ***************
 *** 33,122 ****
               control and error handling).
@@ -1138,9 +1088,216 @@
       </section>
 +     -->
   </chapter>
-Files misc/hsqldb/lib/hsqldb.jar and misc/build/hsqldb/lib/hsqldb.jar differ
-*** misc/hsqldb/src/org/hsqldb/Column.java	Sun Oct 23 18:26:18 2005
---- misc/build/hsqldb/src/org/hsqldb/Column.java	Tue May 30 16:22:32 2006
+diff -crN misc/hsqldb/makefile.mk misc/build/hsqldb/makefile.mk
+*** misc/hsqldb/makefile.mk	2006-11-03 20:02:40.000000000 +0100
+--- misc/build/hsqldb/makefile.mk	2006-11-03 20:05:44.000000000 +0100
+***************
+*** 1 ****
+! dummy
+--- 1,47 ----
+! #*************************************************************************
+! #
+! #   OpenOffice.org - a multi-platform office productivity suite
+! #
+! #   $RCSfile: build-java-target.diff,v $
+! #
+! #   $Revision: 1.1 $
+! #
+! #   last change: $Author: pmladek $ $Date: 2006/10/12 15:20:23 $
+! #
+! #   The Contents of this file are made available subject to
+! #   the terms of GNU Lesser General Public License Version 2.1.
+! #
+! #
+! #     GNU Lesser General Public License Version 2.1
+! #     =============================================
+! #     Copyright 2005 by Sun Microsystems, Inc.
+! #     901 San Antonio Road, Palo Alto, CA 94303, USA
+! #
+! #     This library is free software; you can redistribute it and/or
+! #     modify it under the terms of the GNU Lesser General Public
+! #     License version 2.1, as published by the Free Software Foundation.
+! #
+! #     This library is distributed in the hope that it will be useful,
+! #     but WITHOUT ANY WARRANTY; without even the implied warranty of
+! #     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+! #     Lesser General Public License for more details.
+! #
+! #     You should have received a copy of the GNU Lesser General Public
+! #     License along with this library; if not, write to the Free Software
+! #     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+! #     MA  02111-1307  USA
+! #
+! #*************************************************************************
+! 
+! PRJ=..$/..$/..$/..
+! PRJNAME=so_hsqldb
+! TARGET=so_hsqldb
+! 
+! # buildfile is in a subdirectory
+! ANT_BUILDFILE=build$/build.xml
+! 
+! .INCLUDE : ant.mk
+! 
+! ANT_FLAGS+=-Dbuild.label="build-$(RSCREVISION)" jar
+! 
+! ALLTAR : ANTBUILD
+diff -crN misc/hsqldb/src/org/hsqldb/BaseMemoryNode.java misc/build/hsqldb/src/org/hsqldb/BaseMemoryNode.java
+*** misc/hsqldb/src/org/hsqldb/BaseMemoryNode.java	2005-10-23 18:26:18.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/BaseMemoryNode.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 83,91 ****
+   */
+  abstract class BaseMemoryNode extends Node {
+  
+!     protected Node nLeft;
+!     protected Node nRight;
+!     protected Node nParent;
+  
+      void delete() {
+          iBalance = -2;
+--- 83,91 ----
+   */
+  abstract class BaseMemoryNode extends Node {
+  
+!     public Node nLeft;
+!     public Node nRight;
+!     public Node nParent;
+  
+      void delete() {
+          iBalance = -2;
+diff -crN misc/hsqldb/src/org/hsqldb/CachedRow.java misc/build/hsqldb/src/org/hsqldb/CachedRow.java
+*** misc/hsqldb/src/org/hsqldb/CachedRow.java	2005-10-23 18:26:18.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/CachedRow.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 99,111 ****
+      static final int NO_POS = -1;
+  
+      //
+!     protected Table tTable;
+      int             storageSize;
+  
+      /**
+       *  Flag indicating unwritten data.
+       */
+!     protected boolean hasDataChanged;
+  
+      /**
+       *  Flag indicating Node data has changed.
+--- 99,111 ----
+      static final int NO_POS = -1;
+  
+      //
+!     public Table tTable;
+      int             storageSize;
+  
+      /**
+       *  Flag indicating unwritten data.
+       */
+!     public boolean hasDataChanged;
+  
+      /**
+       *  Flag indicating Node data has changed.
+***************
+*** 173,179 ****
+          oData = in.readData(tTable.getColumnTypes());
+      }
+  
+!     private void readRowInfo(RowInputInterface in)
+      throws IOException, HsqlException {
+  
+          // for use when additional transaction info is attached to rows
+--- 173,179 ----
+          oData = in.readData(tTable.getColumnTypes());
+      }
+  
+!     public void readRowInfo(RowInputInterface in)
+      throws IOException, HsqlException {
+  
+          // for use when additional transaction info is attached to rows
+***************
+*** 313,319 ****
+          } catch (IOException e) {}
+      }
+  
+!     private void writeRowInfo(RowOutputInterface out) {
+  
+          // for use when additional transaction info is attached to rows
+      }
+--- 313,319 ----
+          } catch (IOException e) {}
+      }
+  
+!     public void writeRowInfo(RowOutputInterface out) {
+  
+          // for use when additional transaction info is attached to rows
+      }
+***************
+*** 342,348 ****
+       * @throws IOException
+       * @throws HsqlException
+       */
+!     private void writeNodes(RowOutputInterface out) throws IOException {
+  
+          out.writeSize(storageSize);
+  
+--- 342,348 ----
+       * @throws IOException
+       * @throws HsqlException
+       */
+!     public void writeNodes(RowOutputInterface out) throws IOException {
+  
+          out.writeSize(storageSize);
+  
+diff -crN misc/hsqldb/src/org/hsqldb/Column.java misc/build/hsqldb/src/org/hsqldb/Column.java
+*** misc/hsqldb/src/org/hsqldb/Column.java	2005-10-23 18:26:18.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Column.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 126,138 ****
+      // most variables are final but not declared so because of a bug in
+      // JDK 1.1.8 compiler
+      public HsqlName         columnName;
+!     private int             colType;
+!     private int             colSize;
+!     private int             colScale;
+!     private boolean         isNullable;
+!     private boolean         isIdentity;
+!     private boolean         isPrimaryKey;
+!     private Expression      defaultExpression;
+      long                    identityStart;
+      long                    identityIncrement;
+      static final BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);
+--- 126,138 ----
+      // most variables are final but not declared so because of a bug in
+      // JDK 1.1.8 compiler
+      public HsqlName         columnName;
+!     public int             colType;
+!     public int             colSize;
+!     public int             colScale;
+!     public boolean         isNullable;
+!     public boolean         isIdentity;
+!     public boolean         isPrimaryKey;
+!     public Expression      defaultExpression;
+      long                    identityStart;
+      long                    identityIncrement;
+      static final BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);
+***************
+*** 187,193 ****
+          }
+      }
+  
+!     private Column() {}
+  
+      /**
+       * Used for primary key changes.
+--- 187,193 ----
+          }
+      }
+  
+!     public Column() {}
+  
+      /**
+       * Used for primary key changes.
 ***************
 *** 932,937 ****
 --- 932,941 ----
@@ -1167,1784 +1324,19152 @@
                       if (o instanceof java.lang.Number) {
                           return convertToLong(o);
                       }
-*** misc/hsqldb/src/org/hsqldb/CompiledStatement.java	Fri Nov  4 20:36:42 2005
---- misc/build/hsqldb/src/org/hsqldb/CompiledStatement.java	Tue May 30 16:22:32 2006
 ***************
-*** 647,656 ****
-          for (int i = 0; i < subqueries.length; i++) {
-              sb.append("\n[level=").append(subqueries[i].level).append(
-                  '\n').append("hasParams=").append(
-!                 subqueries[i].hasParams).append('\n').append(
-!                 "org.hsqldb.Select@").append(
-!                 Integer.toHexString(subqueries[i].select.hashCode())).append(
-!                 "]");
-          }
+*** 1199,1205 ****
+       * @return
+       * @throws  HsqlException
+       */
+!     private static Object convertString(String s,
+                                          int type) throws HsqlException {
   
-          sb.append(']');
---- 647,660 ----
-          for (int i = 0; i < subqueries.length; i++) {
-              sb.append("\n[level=").append(subqueries[i].level).append(
-                  '\n').append("hasParams=").append(
-!                 subqueries[i].hasParams).append('\n');
-! 
-!             if (subqueries[i].select != null) {
-!                 sb.append("org.hsqldb.Select@").append(
-!                     Integer.toHexString(subqueries[i].select.hashCode()));
-!             }
-! 
-!             sb.append("]");
-          }
+          switch (type) {
+--- 1207,1213 ----
+       * @return
+       * @throws  HsqlException
+       */
+!     public static Object convertString(String s,
+                                          int type) throws HsqlException {
   
-          sb.append(']');
-*** misc/hsqldb/src/org/hsqldb/DITableInfo.java	Sun Oct 23 17:40:10 2005
---- misc/build/hsqldb/src/org/hsqldb/DITableInfo.java	Tue May 30 16:22:32 2006
+          switch (type) {
+diff -crN misc/hsqldb/src/org/hsqldb/CompiledStatementExecutor.java misc/build/hsqldb/src/org/hsqldb/CompiledStatementExecutor.java
+*** misc/hsqldb/src/org/hsqldb/CompiledStatementExecutor.java	2005-11-04 20:36:42.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/CompiledStatementExecutor.java	2006-11-03 20:08:11.000000000 +0100
 ***************
-*** 552,568 ****
-       * @return null (not implemented)
+*** 54,64 ****
+   */
+  final class CompiledStatementExecutor {
+  
+!     private Session session;
+!     private Result  updateResult;
+!     private static Result emptyZeroResult =
+          new Result(ResultConstants.UPDATECOUNT);
+!     private static Result updateOneResult =
+          new Result(ResultConstants.UPDATECOUNT);
+  
+      static {
+--- 54,64 ----
+   */
+  final class CompiledStatementExecutor {
+  
+!     public Session session;
+!     public Result  updateResult;
+!     public static Result emptyZeroResult =
+          new Result(ResultConstants.UPDATECOUNT);
+!     public static Result updateOneResult =
+          new Result(ResultConstants.UPDATECOUNT);
+  
+      static {
+***************
+*** 120,126 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
        */
-      Integer getIndexCardinality(int i) {
-- 
--         // TODO:     - implement cardinality for all table and index types
--         // REQUIRES: - checkpoint of cardinality for CACHED tables
--         //           - maybe extend SET TABLE <table-name> INDEX ... DDL to
--         //           include index cardinality as well as index roots?
--         // REQUIRES: completion of TODOs in Index for non-unique indices
--         // REQUIRES: setIndexInfoDirty() for DatabaseInformation and related
--         //           support  code.  That is global setDirty on every update
--         //           DML ruins DatabaseInforamation system table caching
--         //           effect
-- //      return ValuePool.getInt(index.getCardinality());
-          return null;
-      }
+!     private Result executeImpl(CompiledStatement cs) throws HsqlException {
+  
+          switch (cs.type) {
+  
+--- 120,126 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeImpl(CompiledStatement cs) throws HsqlException {
+  
+          switch (cs.type) {
   
---- 552,557 ----
 ***************
-*** 611,619 ****
-       * @param i zero-based index specifier
-       * @return null (not implemented)
+*** 160,166 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
        */
-!     Integer getIndexPages(int i) {
-! 
-!         // not supported yet: hsqldb does not even know what a "page" is
-          return null;
-      }
+!     private Result executeCallStatement(CompiledStatement cs)
+      throws HsqlException {
   
---- 600,606 ----
-       * @param i zero-based index specifier
-       * @return null (not implemented)
+          Expression e = cs.expression;          // representing CALL
+--- 160,166 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
        */
-!     Integer getIndexRowCardinality(int i) {
-          return null;
-      }
+!     public Result executeCallStatement(CompiledStatement cs)
+      throws HsqlException {
   
-*** misc/hsqldb/src/org/hsqldb/Database.java	Sat Nov  5 19:15:56 2005
---- misc/build/hsqldb/src/org/hsqldb/Database.java	Tue May 30 16:22:32 2006
+          Expression e = cs.expression;          // representing CALL
 ***************
-*** 118,126 ****
-   */
-  public class Database {
+*** 197,203 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeDeleteStatement(CompiledStatement cs)
+      throws HsqlException {
   
-!     int            databaseID;
-!     private String sType;
-!     private String sName;
+          Table       table  = cs.targetTable;
+--- 197,203 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeDeleteStatement(CompiledStatement cs)
+      throws HsqlException {
   
-  // loosecannon1@users 1.7.2 patch properties on the JDBC URL
-      private HsqlProperties urlProperties;
---- 118,126 ----
-   */
-  public class Database {
+          Table       table  = cs.targetTable;
+***************
+*** 232,238 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeInsertSelectStatement(CompiledStatement cs)
+      throws HsqlException {
   
-!     int    databaseID;
-!     String sType;
-!     String sName;
+          Table     t   = cs.targetTable;
+--- 232,238 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeInsertSelectStatement(CompiledStatement cs)
+      throws HsqlException {
   
-  // loosecannon1@users 1.7.2 patch properties on the JDBC URL
-      private HsqlProperties urlProperties;
-*** misc/hsqldb/src/org/hsqldb/DatabaseCommandInterpreter.java	Sun Nov  6 23:01:34 2005
---- misc/build/hsqldb/src/org/hsqldb/DatabaseCommandInterpreter.java	Tue May 30 16:22:32 2006
+          Table     t   = cs.targetTable;
 ***************
-*** 1451,1477 ****
-          // in certain cases; the workaround here discards such scripted column
-          // lists when used in OOo
-          if (tokenizer.isGetThis(Token.T_OPENBRACKET)) {
-!             try {    // added line
-                  HsqlArrayList list = Parser.getColumnNames(database, null,
-                      tokenizer, true);
+*** 286,292 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeInsertValuesStatement(CompiledStatement cs)
+      throws HsqlException {
   
-                  colList = new HsqlName[list.size()];
-                  colList = (HsqlName[]) list.toArray(colList);
+          Table        t    = cs.targetTable;
+--- 286,292 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeInsertValuesStatement(CompiledStatement cs)
+      throws HsqlException {
   
-!                 //added lines to make sure all columns are quoted
-                  if (database.isStoredFileAccess()) {
-                      for (int i = 0; i < colList.length; i++) {
-                          if (!colList[i].isNameQuoted) {
-!                             throw (Trace.error(Trace.INVALID_IDENTIFIER));
-                          }
-                      }
-                  }
-              } catch (HsqlException e) {
+          Table        t    = cs.targetTable;
+***************
+*** 317,323 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeSelectStatement(CompiledStatement cs)
+      throws HsqlException {
   
-!                 //added lines to catch unquoted column names with spaces
-                  if (database.isStoredFileAccess()) {
--                     colList = null;
-- 
-                      while (!tokenizer.getString().equals(
-                              Token.T_CLOSEBRACKET)) {}
-                  } else {
---- 1451,1477 ----
-          // in certain cases; the workaround here discards such scripted column
-          // lists when used in OOo
-          if (tokenizer.isGetThis(Token.T_OPENBRACKET)) {
-!             try {
-                  HsqlArrayList list = Parser.getColumnNames(database, null,
-                      tokenizer, true);
+          Select select = cs.select;
+--- 317,323 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeSelectStatement(CompiledStatement cs)
+      throws HsqlException {
   
-                  colList = new HsqlName[list.size()];
-                  colList = (HsqlName[]) list.toArray(colList);
+          Select select = cs.select;
+***************
+*** 358,364 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeUpdateStatement(CompiledStatement cs)
+      throws HsqlException {
   
-!                 //added lines to make sure all valid columns are quoted
-                  if (database.isStoredFileAccess()) {
-                      for (int i = 0; i < colList.length; i++) {
-                          if (!colList[i].isNameQuoted) {
-!                             colList = null;
-! 
-!                             break;
-                          }
-                      }
-                  }
-              } catch (HsqlException e) {
+          Table       table  = cs.targetTable;
+--- 358,364 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeUpdateStatement(CompiledStatement cs)
+      throws HsqlException {
   
-!                 //added lines to catch unquoted names with spaces
-                  if (database.isStoredFileAccess()) {
-                      while (!tokenizer.getString().equals(
-                              Token.T_CLOSEBRACKET)) {}
-                  } else {
+          Table       table  = cs.targetTable;
 ***************
-*** 1864,1869 ****
---- 1864,1871 ----
-              throw Trace.error(Trace.COLUMN_ALREADY_EXISTS, newName);
-          }
+*** 420,426 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     private Result executeDDLStatement(CompiledStatement cs)
+      throws HsqlException {
+          return session.sqlExecuteDirectNoPreChecks(cs.sql);
+      }
+--- 420,426 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the result of executing the statement
+       */
+!     public Result executeDDLStatement(CompiledStatement cs)
+      throws HsqlException {
+          return session.sqlExecuteDirectNoPreChecks(cs.sql);
+      }
+diff -crN misc/hsqldb/src/org/hsqldb/CompiledStatement.java misc/build/hsqldb/src/org/hsqldb/CompiledStatement.java
+*** misc/hsqldb/src/org/hsqldb/CompiledStatement.java	2005-11-04 20:36:42.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/CompiledStatement.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 355,361 ****
+      /**
+       * For parameters in INSERT_VALUES and INSERT_SELECT lists
+       */
+!     private void resolveInsertParameterTypes() {
   
-+         t.database.schemaManager.checkColumnIsInView(t,
-+                 column.columnName.name);
-          session.commit();
-          session.setScripting(true);
-          t.renameColumn(column, newName, isquoted);
+          for (int i = 0; i < select.iResultLen; i++) {
+              Expression colexpr = select.exprColumns[i];
+--- 355,361 ----
+      /**
+       * For parameters in INSERT_VALUES and INSERT_SELECT lists
+       */
+!     public void resolveInsertParameterTypes() {
+  
+          for (int i = 0; i < select.iResultLen; i++) {
+              Expression colexpr = select.exprColumns[i];
 ***************
-*** 2466,2472 ****
-      private Table newTable(int type, String name, boolean quoted,
-                             HsqlName schema) throws HsqlException {
+*** 368,374 ****
+          }
+      }
   
--         int sid = session.getId();
-          HsqlName tableHsqlName = database.nameManager.newHsqlName(name,
-              quoted);
+!     private void setParameters(Expression[] params) {
+  
+          this.parameters = params;
+  
+--- 368,374 ----
+          }
+      }
+  
+!     public void setParameters(Expression[] params) {
+  
+          this.parameters = params;
   
---- 2468,2473 ----
 ***************
-*** 2536,2543 ****
-                  if (defExpr == null) {
-                      String columnName = column.columnName.name;
+*** 381,387 ****
+          this.paramTypes = types;
+      }
   
-!                     throw Trace.error(Trace.COLUMN_TYPE_MISMATCH,
-!                                       Trace.NO_DEFAULT_VALUE_FOR_COLUMN,
-                                        new Object[]{ columnName });
-                  }
-              }
---- 2537,2543 ----
-                  if (defExpr == null) {
-                      String columnName = column.columnName.name;
+!     private void setSubqueries(SubQuery[] subqueries) {
+          this.subqueries = subqueries;
+      }
+  
+--- 381,387 ----
+          this.paramTypes = types;
+      }
+  
+!     public void setSubqueries(SubQuery[] subqueries) {
+          this.subqueries = subqueries;
+      }
   
-!                     throw Trace.error(Trace.NO_DEFAULT_VALUE_FOR_COLUMN,
-                                        new Object[]{ columnName });
-                  }
-              }
 ***************
-*** 2710,2727 ****
-          return;
+*** 432,438 ****
+          subqueries   = null;
       }
   
-      private void processCreateAlias() throws HsqlException {
+!     private static final Result updateCountResult =
+          new Result(ResultConstants.UPDATECOUNT);
   
-          String alias;
-          String methodFQN;
+      Result describeResult() {
+--- 432,438 ----
+          subqueries   = null;
+      }
   
-!         alias = tokenizer.getSimpleName();
+!     public static final Result updateCountResult =
+          new Result(ResultConstants.UPDATECOUNT);
   
-          tokenizer.getThis(Token.T_FOR);
+      Result describeResult() {
+***************
+*** 566,572 ****
+       * @throws Exception if a database access or io error occurs
+       * @return the String representation of this object
+       */
+!     private String describeImpl(Session session) throws Exception {
   
-          methodFQN = upgradeMethodFQN(tokenizer.getSimpleName());
+          StringBuffer sb;
   
-!         database.getAliasMap().put(alias, methodFQN);
+--- 566,572 ----
+       * @throws Exception if a database access or io error occurs
+       * @return the String representation of this object
+       */
+!     public String describeImpl(Session session) throws Exception {
+  
+          StringBuffer sb;
+  
+***************
+*** 640,656 ****
+          }
       }
   
-      private void processCreateIndex(boolean unique) throws HsqlException {
---- 2710,2741 ----
-          return;
+!     private StringBuffer appendSubqueries(StringBuffer sb) {
+  
+          sb.append("SUBQUERIES[");
+  
+          for (int i = 0; i < subqueries.length; i++) {
+              sb.append("\n[level=").append(subqueries[i].level).append(
+                  '\n').append("hasParams=").append(
+!                 subqueries[i].hasParams).append('\n').append(
+!                 "org.hsqldb.Select@").append(
+!                 Integer.toHexString(subqueries[i].select.hashCode())).append(
+!                 "]");
+          }
+  
+          sb.append(']');
+--- 640,660 ----
+          }
       }
   
-+     /**
-+      * If an invalid alias is encountered while processing an old script,
-+      * simply discard it.
-+      */
-      private void processCreateAlias() throws HsqlException {
+!     public StringBuffer appendSubqueries(StringBuffer sb) {
   
-          String alias;
-          String methodFQN;
+          sb.append("SUBQUERIES[");
   
-!         try {
-!             alias = tokenizer.getSimpleName();
-!         } catch (HsqlException e) {
-!             if (session.isProcessingScript()) {
-!                 alias = null;
-!             } else {
-!                 throw e;
+          for (int i = 0; i < subqueries.length; i++) {
+              sb.append("\n[level=").append(subqueries[i].level).append(
+                  '\n').append("hasParams=").append(
+!                 subqueries[i].hasParams).append('\n');
+! 
+!             if (subqueries[i].select != null) {
+!                 sb.append("org.hsqldb.Select@").append(
+!                     Integer.toHexString(subqueries[i].select.hashCode()));
 !             }
-!         }
+! 
+!             sb.append("]");
+          }
   
-          tokenizer.getThis(Token.T_FOR);
+          sb.append(']');
+***************
+*** 658,671 ****
+          return sb;
+      }
   
-          methodFQN = upgradeMethodFQN(tokenizer.getSimpleName());
+!     private StringBuffer appendTable(StringBuffer sb) {
   
-!         if (alias != null) {
-!             database.getAliasMap().put(alias, methodFQN);
-!         }
+          sb.append("TABLE[").append(targetTable.getName().name).append(']');
+  
+          return sb;
       }
   
-      private void processCreateIndex(boolean unique) throws HsqlException {
-***************
-*** 3200,3205 ****
---- 3214,3220 ----
+!     private StringBuffer appendColumns(StringBuffer sb) {
   
-          tc = processCreateFK(t, n);
+          sb.append("COLUMNS=[");
   
-+         checkFKColumnDefaults(t, tc);
-          t.checkColumnsMatch(tc.core.mainColArray, tc.core.refTable,
-                              tc.core.refColArray);
-          session.commit();
-*** misc/hsqldb/src/org/hsqldb/DatabaseInformationFull.java	Sat Oct 29 18:30:22 2005
---- misc/build/hsqldb/src/org/hsqldb/DatabaseInformationFull.java	Tue May 30 16:22:32 2006
-***************
-*** 449,457 ****
+--- 662,675 ----
+          return sb;
+      }
   
-          // Do it.
-          while (caches.hasNext()) {
-!             cache      = (DataFileCache) caches.next();
-!             row        = t.getEmptyRowData();
-!             iFreeBytes = 0;
-              row[icache_file] =
-                  FileUtil.canonicalOrAbsolutePath(cache.getFileName());
-              row[imax_cache_sz]    = ValuePool.getInt(cache.capacity());
---- 449,456 ----
+!     public StringBuffer appendTable(StringBuffer sb) {
   
-          // Do it.
-          while (caches.hasNext()) {
-!             cache = (DataFileCache) caches.next();
-!             row   = t.getEmptyRowData();
-              row[icache_file] =
-                  FileUtil.canonicalOrAbsolutePath(cache.getFileName());
-              row[imax_cache_sz]    = ValuePool.getInt(cache.capacity());
-*** misc/hsqldb/src/org/hsqldb/DatabaseInformationMain.java	Sat Oct 29 18:30:22 2005
---- misc/build/hsqldb/src/org/hsqldb/DatabaseInformationMain.java	Tue May 30 16:22:32 2006
-***************
-*** 1351,1357 ****
-       * COLUMN_NAME      VARCHAR   simple column name
-       * ASC_OR_DESC      VARCHAR   col. sort sequence: {"A" (Asc) | "D" (Desc)}
-       * CARDINALITY      INTEGER   # of unique values in index (not implemented)
-!      * PAGES            INTEGER   index page use (not implemented)
-       * FILTER_CONDITION VARCHAR   filter condition, if any (not implemented)
-       * </pre> <p>
-       *
---- 1351,1357 ----
-       * COLUMN_NAME      VARCHAR   simple column name
-       * ASC_OR_DESC      VARCHAR   col. sort sequence: {"A" (Asc) | "D" (Desc)}
-       * CARDINALITY      INTEGER   # of unique values in index (not implemented)
-!      * ROW_CARDINALITY  INTEGER   # of rows in index (not implemented)
-       * FILTER_CONDITION VARCHAR   filter condition, if any (not implemented)
-       * </pre> <p>
-       *
-***************
-*** 1378,1384 ****
-              addColumn(t, "COLUMN_NAME", Types.VARCHAR);
-              addColumn(t, "ASC_OR_DESC", Types.VARCHAR, 1, true);
-              addColumn(t, "CARDINALITY", Types.INTEGER);
-!             addColumn(t, "PAGES", Types.INTEGER);
-              addColumn(t, "FILTER_CONDITION", Types.VARCHAR);
+          sb.append("TABLE[").append(targetTable.getName().name).append(']');
   
-              // order: NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION.
---- 1378,1384 ----
-              addColumn(t, "COLUMN_NAME", Types.VARCHAR);
-              addColumn(t, "ASC_OR_DESC", Types.VARCHAR, 1, true);
-              addColumn(t, "CARDINALITY", Types.INTEGER);
-!             addColumn(t, "ROW_CARDINALITY", Types.INTEGER);
-              addColumn(t, "FILTER_CONDITION", Types.VARCHAR);
+          return sb;
+      }
   
-              // order: NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION.
-***************
-*** 1404,1410 ****
-          //String  columnName;
-          //String  ascOrDesc;
-          Integer cardinality;
-!         Integer pages;
-          String  filterCondition;
+!     public StringBuffer appendColumns(StringBuffer sb) {
   
-          // Intermediate holders
---- 1404,1410 ----
-          //String  columnName;
-          //String  ascOrDesc;
-          Integer cardinality;
-!         Integer rowCardinality;
-          String  filterCondition;
+          sb.append("COLUMNS=[");
   
-          // Intermediate holders
 ***************
-*** 1430,1436 ****
-          final int icolumn_name      = 8;
-          final int iasc_or_desc      = 9;
-          final int icardinality      = 10;
-!         final int ipages            = 11;
-          final int ifilter_condition = 12;
+*** 681,687 ****
+          return sb;
+      }
   
-          // Initialization
---- 1430,1436 ----
-          final int icolumn_name      = 8;
-          final int iasc_or_desc      = 9;
-          final int icardinality      = 10;
-!         final int irowcardinality   = 11;
-          final int ifilter_condition = 12;
+!     private StringBuffer appendParms(StringBuffer sb) {
   
-          // Initialization
-***************
-*** 1469,1480 ****
-                      continue;
-                  }
-  
-!                 indexName   = ti.getIndexName(i);
-!                 nonUnique   = ti.isIndexNonUnique(i);
-!                 cardinality = ti.getIndexCardinality(i);
-!                 pages       = ti.getIndexPages(i);
-!                 cols        = ti.getIndexColumns(i);
-!                 indexType   = ti.getIndexType(i);
+          sb.append("PARAMETERS=[");
   
-                  for (int k = 0; k < colCount; k++) {
-                      col                    = cols[k];
---- 1469,1480 ----
-                      continue;
-                  }
-  
-!                 indexName      = ti.getIndexName(i);
-!                 nonUnique      = ti.isIndexNonUnique(i);
-!                 cardinality    = ti.getIndexCardinality(i);
-!                 rowCardinality = ti.getIndexRowCardinality(i);
-!                 cols           = ti.getIndexColumns(i);
-!                 indexType      = ti.getIndexType(i);
+--- 685,691 ----
+          return sb;
+      }
   
-                  for (int k = 0; k < colCount; k++) {
-                      col                    = cols[k];
-***************
-*** 1490,1496 ****
-                      row[icolumn_name]      = ti.getColName(col);
-                      row[iasc_or_desc]      = ti.getIndexColDirection(i, col);
-                      row[icardinality]      = cardinality;
-!                     row[ipages]            = pages;
-                      row[ifilter_condition] = filterCondition;
+!     public StringBuffer appendParms(StringBuffer sb) {
   
-                      t.insertSys(row);
---- 1490,1496 ----
-                      row[icolumn_name]      = ti.getColName(col);
-                      row[iasc_or_desc]      = ti.getIndexColDirection(i, col);
-                      row[icardinality]      = cardinality;
-!                     row[irowcardinality]   = rowCardinality;
-                      row[ifilter_condition] = filterCondition;
+          sb.append("PARAMETERS=[");
   
-                      t.insertSys(row);
-*** misc/hsqldb/src/org/hsqldb/DatabaseManager.java	Sun Nov  6 23:26:52 2005
---- misc/build/hsqldb/src/org/hsqldb/DatabaseManager.java	Tue May 30 16:22:32 2006
 ***************
-*** 241,247 ****
-              String path, HsqlProperties props) throws HsqlException {
-  
-          Database db;
-!         Object   key = path;
-          HashMap  databaseMap;
-  
-          if (type == DatabaseURL.S_FILE) {
---- 241,247 ----
-              String path, HsqlProperties props) throws HsqlException {
+*** 695,701 ****
+          return sb;
+      }
   
-          Database db;
-!         String   key = path;
-          HashMap  databaseMap;
+!     private StringBuffer appendCondition(Session session, StringBuffer sb) {
   
-          if (type == DatabaseURL.S_FILE) {
-***************
-*** 375,382 ****
-              }
-          } else if (type == DatabaseURL.S_RES) {
-              databaseMap = resDatabaseMap;
-!         } else {
-              databaseMap = memDatabaseMap;
-          }
+          return condition == null ? sb.append("CONDITION[]\n")
+                                   : sb.append("CONDITION[").append(
+--- 699,705 ----
+          return sb;
+      }
   
-          databaseIDMap.remove(dbID);
---- 375,386 ----
-              }
-          } else if (type == DatabaseURL.S_RES) {
-              databaseMap = resDatabaseMap;
-!         } else if (type == DatabaseURL.S_MEM) {
-              databaseMap = memDatabaseMap;
-+         } else {
-+             throw (Trace.runtimeError(
-+                 Trace.INTERNAL_UNSUPPORTED_OPERATION,
-+                 "DatabaseManager.lookupDatabaseObject()"));
-          }
+!     public StringBuffer appendCondition(Session session, StringBuffer sb) {
   
-          databaseIDMap.remove(dbID);
-***************
-*** 479,488 ****
+          return condition == null ? sb.append("CONDITION[]\n")
+                                   : sb.append("CONDITION[").append(
+diff -crN misc/hsqldb/src/org/hsqldb/CompiledStatementManager.java misc/build/hsqldb/src/org/hsqldb/CompiledStatementManager.java
+*** misc/hsqldb/src/org/hsqldb/CompiledStatementManager.java	2005-06-26 16:33:48.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/CompiledStatementManager.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 81,108 ****
+       * The Database for which this object is managing
+       * CompiledStatement objects.
+       */
+!     private Database database;
   
-      // converts file path to database lookup key, converting any
-      // thrown exception to an HsqlException in the process
-!     private static Object filePathToKey(String path) throws HsqlException {
+      /** Map:  SQL String => Compiled Statement id (int) */
+!     private IntKeyHashMap schemaMap;
   
-          try {
-!             return FileUtil.canonicalFile(path);
-          } catch (Exception e) {
-              throw Trace.error(Trace.FILE_IO_ERROR, e.toString());
-          }
---- 483,492 ----
+      /** Map: Compiled Statement id (int) => SQL String */
+!     private IntKeyHashMap sqlLookup;
   
-      // converts file path to database lookup key, converting any
-      // thrown exception to an HsqlException in the process
-!     private static String filePathToKey(String path) throws HsqlException {
+      /** Map: Compiled statment id (int) => CompiledStatement object. */
+!     private IntKeyHashMap csidMap;
   
-          try {
-!             return FileUtil.canonicalPath(path);
-          } catch (Exception e) {
-              throw Trace.error(Trace.FILE_IO_ERROR, e.toString());
-          }
-*** misc/hsqldb/src/org/hsqldb/Expression.java	Fri Nov  4 20:55:42 2005
---- misc/build/hsqldb/src/org/hsqldb/Expression.java	Tue May 30 16:22:32 2006
-***************
-*** 234,247 ****
-      private int aggregateSpec = AGGREGATE_NONE;
+      /** Map: Session id (int) => Map: compiled statement id (int) => use count in session; */
+!     private IntKeyHashMap sessionMap;
   
-      // nodes
-!     private Expression eArg, eArg2;
+      /** Map: Compiled statment id (int) => total use count (all sessions) */
+!     private IntKeyIntValueHashMap useMap;
   
-!     // VALUE, VALUELIST
-!     Object          valueData;
-!     private HashSet hList;
-!     private int     dataType;
+      /**
+       * Monotonically increasing counter used to assign unique ids to compiled
+       * statements.
+       */
+!     private int next_cs_id;
   
-      // VALUE LIST NEW
-      Expression[]    valueList;
-      private boolean isFixedConstantValueList;
+      /**
+       * Constructs a new instance of <code>CompiledStatementManager</code>.
+--- 81,108 ----
+       * The Database for which this object is managing
+       * CompiledStatement objects.
+       */
+!     public Database database;
   
---- 234,247 ----
-      private int aggregateSpec = AGGREGATE_NONE;
+      /** Map:  SQL String => Compiled Statement id (int) */
+!     public IntKeyHashMap schemaMap;
   
-      // nodes
-!     Expression eArg, eArg2;
+      /** Map: Compiled Statement id (int) => SQL String */
+!     public IntKeyHashMap sqlLookup;
   
-!     // VALUE
-!     Object      valueData;
-!     private int dataType;
+      /** Map: Compiled statment id (int) => CompiledStatement object. */
+!     public IntKeyHashMap csidMap;
   
-      // VALUE LIST NEW
-+     HashSet         hList;
-      Expression[]    valueList;
-      private boolean isFixedConstantValueList;
+      /** Map: Session id (int) => Map: compiled statement id (int) => use count in session; */
+!     public IntKeyHashMap sessionMap;
   
-***************
-*** 263,269 ****
-      private TableFilter tableFilter;                // null if not yet resolved
-      TableFilter         outerFilter;                // defined if this is part of an OUTER JOIN condition tree
+      /** Map: Compiled statment id (int) => total use count (all sessions) */
+!     public IntKeyIntValueHashMap useMap;
   
-!     //
-      private int     columnIndex;
-      private boolean columnQuoted;
-      private int     precision;
---- 263,269 ----
-      private TableFilter tableFilter;                // null if not yet resolved
-      TableFilter         outerFilter;                // defined if this is part of an OUTER JOIN condition tree
+      /**
+       * Monotonically increasing counter used to assign unique ids to compiled
+       * statements.
+       */
+!     public int next_cs_id;
   
-!     // COLUMN
-      private int     columnIndex;
-      private boolean columnQuoted;
-      private int     precision;
+      /**
+       * Constructs a new instance of <code>CompiledStatementManager</code>.
 ***************
-*** 413,420 ****
+*** 156,162 ****
+       *
+       * @return the next compiled statement identifier in the sequence.
        */
-      Expression(String schema, String table, String column) {
+!     private int nextID() {
   
-!         schema    = schema;
-!         tableName = table;
+          next_cs_id++;
   
-          if (column == null) {
-              exprType = ASTERISK;
---- 413,420 ----
+--- 156,162 ----
+       *
+       * @return the next compiled statement identifier in the sequence.
        */
-      Expression(String schema, String table, String column) {
+!     public int nextID() {
   
-!         this.schema = schema;
-!         tableName   = table;
+          next_cs_id++;
   
-          if (column == null) {
-              exprType = ASTERISK;
+diff -crN misc/hsqldb/src/org/hsqldb/Constraint.java misc/build/hsqldb/src/org/hsqldb/Constraint.java
+*** misc/hsqldb/src/org/hsqldb/Constraint.java	2005-10-23 18:26:18.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Constraint.java	2006-11-03 20:08:11.000000000 +0100
 ***************
-*** 1572,1578 ****
-              result = result && eArg2.checkResolved(check);
-          }
+*** 193,199 ****
+          core.updateAction = updateAction;
+      }
   
-!         if (subQuery != null) {
-              result = result && subQuery.select.checkResolved(check);
-          }
+!     private Constraint() {}
   
---- 1572,1578 ----
-              result = result && eArg2.checkResolved(check);
-          }
+      /**
+       * Returns the HsqlName.
+--- 193,199 ----
+          core.updateAction = updateAction;
+      }
   
-!         if (subQuery != null && subQuery.select != null) {
-              result = result && subQuery.select.checkResolved(check);
-          }
+!     public Constraint() {}
   
-*** misc/hsqldb/src/org/hsqldb/Index.java	Sun Oct 23 17:40:10 2005
---- misc/build/hsqldb/src/org/hsqldb/Index.java	Tue May 30 16:22:32 2006
+      /**
+       * Returns the HsqlName.
 ***************
-*** 259,265 ****
+*** 205,211 ****
+      /**
+       * Changes constraint name.
+       */
+!     private void setName(String name, boolean isquoted) throws HsqlException {
+          constName.rename(name, isquoted);
+      }
   
-      Node getRoot(Session session) {
+--- 205,211 ----
+      /**
+       * Changes constraint name.
+       */
+!     public void setName(String name, boolean isquoted) throws HsqlException {
+          constName.rename(name, isquoted);
+      }
   
-!         if (isTemp) {
-              return session.getIndexRoot(indexName, onCommitPreserve);
-          } else {
-              return root;
---- 259,265 ----
+***************
+*** 573,579 ****
+       * table. Also returns true if any column covered by the foreign key
+       * constraint has a null value.
+       */
+!     private static boolean hasReferencedRow(Session session,
+              Object[] rowdata, int[] rowColArray,
+              Index mainIndex) throws HsqlException {
+  
+--- 573,579 ----
+       * table. Also returns true if any column covered by the foreign key
+       * constraint has a null value.
+       */
+!     public static boolean hasReferencedRow(Session session,
+              Object[] rowdata, int[] rowColArray,
+              Index mainIndex) throws HsqlException {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/DatabaseCommandInterpreter.java misc/build/hsqldb/src/org/hsqldb/DatabaseCommandInterpreter.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseCommandInterpreter.java	2005-11-06 23:01:34.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseCommandInterpreter.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 111,119 ****
+  // fredt@users 20041209 - patch by tytar@users to set default table type
+  class DatabaseCommandInterpreter {
+  
+!     private Tokenizer tokenizer = new Tokenizer();
+!     private Database  database;
+!     private Session   session;
   
-      Node getRoot(Session session) {
+      /**
+       * Constructs a new DatabaseCommandInterpreter for the given Session
+--- 111,119 ----
+  // fredt@users 20041209 - patch by tytar@users to set default table type
+  class DatabaseCommandInterpreter {
+  
+!     public Tokenizer tokenizer = new Tokenizer();
+!     public Database  database;
+!     public Session   session;
   
-!         if (isTemp && session != null) {
-              return session.getIndexRoot(indexName, onCommitPreserve);
-          } else {
-              return root;
+      /**
+       * Constructs a new DatabaseCommandInterpreter for the given Session
 ***************
-*** 562,568 ****
-          }
+*** 191,197 ****
+                                : result;
       }
   
-!     public Row findRow(Session session, Row row) throws HsqlException {
-  
-          Node node = search(session, row);
+!     private Result executePart(int cmd, String token) throws Throwable {
   
---- 562,571 ----
-          }
+          Result result   = Session.emptyUpdateCount;
+          int    brackets = 0;
+--- 191,197 ----
+                                : result;
       }
   
-!     /**
-!      * Finds an existing row
-!      */
-!     Row findRow(Session session, Row row) throws HsqlException {
+!     public Result executePart(int cmd, String token) throws Throwable {
   
-          Node node = search(session, row);
+          Result result   = Session.emptyUpdateCount;
+          int    brackets = 0;
+***************
+*** 392,398 ****
+       * @throws IOException
+       * @throws HsqlException
+       */
+!     private Result processScript() throws IOException, HsqlException {
   
+          String           token = tokenizer.getString();
+          ScriptWriterText dsw   = null;
+--- 392,398 ----
+       * @throws IOException
+       * @throws HsqlException
+       */
+!     public Result processScript() throws IOException, HsqlException {
+  
+          String           token = tokenizer.getString();
+          ScriptWriterText dsw   = null;
 ***************
-*** 1034,1040 ****
+*** 433,439 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processCreate() throws HsqlException {
+  
+          boolean unique = false;
+          int     tableType;
+--- 433,439 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processCreate() throws HsqlException {
+  
+          boolean unique = false;
+          int     tableType;
+***************
+*** 552,558 ****
+       * @return  column index map
+       * @throws  HsqlException if a column is not found or is duplicate
+       */
+!     private int[] processColumnList(Table t,
+                                      boolean acceptAscDesc)
+                                      throws HsqlException {
+  
+--- 552,558 ----
+       * @return  column index map
+       * @throws  HsqlException if a column is not found or is duplicate
+       */
+!     public int[] processColumnList(Table t,
+                                      boolean acceptAscDesc)
+                                      throws HsqlException {
+  
+***************
+*** 576,582 ****
        *
        * @throws HsqlException
        */
-!     Node search(Session session, Row row) throws HsqlException {
+!     private void processCreateTrigger() throws HsqlException {
   
-          Object[] d = row.getData();
-          Node     x = getRoot(session);
---- 1037,1043 ----
+          Table      t;
+          boolean    isForEach;
+--- 576,582 ----
        *
        * @throws HsqlException
        */
-!     private Node search(Session session, Row row) throws HsqlException {
+!     public void processCreateTrigger() throws HsqlException {
   
-          Object[] d = row.getData();
-          Node     x = getRoot(session);
+          Table      t;
+          boolean    isForEach;
 ***************
-*** 1211,1216 ****
---- 1214,1230 ----
-          }
+*** 697,703 ****
+  // --
       }
   
-+     private RowIterator getIterator(Session session, Node x) {
-+ 
-+         if (x == null) {
-+             return emptyIterator;
-+         } else {
-+             IndexRowIterator it = new IndexRowIterator(session, this, x);
-+ 
-+             return it;
-+         }
-+     }
-+ 
-      static class IndexRowIterator implements RowIterator {
+!     private Column processCreateColumn() throws HsqlException {
   
-          Session                    session;
-*** misc/hsqldb/src/org/hsqldb/Parser.java	Wed Nov  2 14:05:00 2005
---- misc/build/hsqldb/src/org/hsqldb/Parser.java	Tue May 30 16:24:12 2006
+          String   token    = tokenizer.getSimpleName();
+          boolean  isQuoted = tokenizer.wasQuotedIdentifier();
+--- 697,703 ----
+  // --
+      }
+  
+!     public Column processCreateColumn() throws HsqlException {
+  
+          String   token    = tokenizer.getSimpleName();
+          boolean  isQuoted = tokenizer.wasQuotedIdentifier();
 ***************
-*** 232,238 ****
-                          &&!t.getLongNameFirst().equals(
-                              table.getName().name)) {
-                      throw (Trace.error(Trace.TABLE_NOT_FOUND,
-!                                        t.getLongNameFirst()));
-                  }
-              }
+*** 714,720 ****
+       *  @return a Column object with indicated attributes
+       *  @throws  HsqlException
+       */
+!     private Column processCreateColumn(HsqlName hsqlName)
+      throws HsqlException {
   
---- 232,238 ----
-                          &&!t.getLongNameFirst().equals(
-                              table.getName().name)) {
-                      throw (Trace.error(Trace.TABLE_NOT_FOUND,
-!                                        new Object[] { t.getLongNameFirst() }));
-                  }
-              }
+          boolean    isIdentity        = false;
+--- 714,720 ----
+       *  @return a Column object with indicated attributes
+       *  @throws  HsqlException
+       */
+!     public Column processCreateColumn(HsqlName hsqlName)
+      throws HsqlException {
   
+          boolean    isIdentity        = false;
 ***************
-*** 889,895 ****
-                      TableFilter f = e.findTableFilter(filters);
+*** 879,885 ****
+       * @throws HsqlException
+       * @return new Expression
+       */
+!     private Expression processCreateDefaultExpression(int type, int length,
+              int scale) throws HsqlException {
   
-                      if (f == null) {
-!                         throw Trace.error(Trace.TABLE_NOT_FOUND, tablename);
-                      }
+          if (type == Types.OTHER) {
+--- 879,885 ----
+       * @throws HsqlException
+       * @return new Expression
+       */
+!     public Expression processCreateDefaultExpression(int type, int length,
+              int scale) throws HsqlException {
   
-                      pos      = addFilterColumns(f, vcolumn, pos);
---- 889,895 ----
-                      TableFilter f = e.findTableFilter(filters);
+          if (type == Types.OTHER) {
+***************
+*** 950,956 ****
+       * @throws HsqlException
+       * @return list of constraints
+       */
+!     private HsqlArrayList processCreateConstraints(Table t,
+              boolean constraint, int[] primarykeycolumn) throws HsqlException {
   
-                      if (f == null) {
-!                         throw Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ tablename });
-                      }
+          String        token;
+--- 950,956 ----
+       * @throws HsqlException
+       * @return list of constraints
+       */
+!     public HsqlArrayList processCreateConstraints(Table t,
+              boolean constraint, int[] primarykeycolumn) throws HsqlException {
   
-                      pos      = addFilterColumns(f, vcolumn, pos);
+          String        token;
 ***************
-*** 2330,2335 ****
---- 2330,2337 ----
-              } else {
-                  iToken = Expression.COLUMN;
-              }
-+         } else if (tokenizer.wasParameter()) {
-+             iToken = Expression.PARAM;
-          } else if (sToken.length() == 0) {
-              iToken = Expression.END;
-          } else {
+*** 1106,1112 ****
+       * @param c check constraint
+       * @throws HsqlException
+       */
+!     private void processCreateCheckConstraintCondition(Constraint c)
+      throws HsqlException {
+  
+          tokenizer.getThis(Token.T_OPENBRACKET);
+--- 1106,1112 ----
+       * @param c check constraint
+       * @throws HsqlException
+       */
+!     public void processCreateCheckConstraintCondition(Constraint c)
+      throws HsqlException {
+  
+          tokenizer.getThis(Token.T_OPENBRACKET);
 ***************
-*** 2789,2795 ****
+*** 1125,1131 ****
+       * @param type Description of the Parameter
+       * @throws HsqlException
+       */
+!     private void processCreateTable(int type) throws HsqlException {
   
-              if (tablename != null
-                      &&!tableFilter.getName().equals(tablename)) {
-!                 throw Trace.error(Trace.TABLE_NOT_FOUND);
-              }
+          String token = tokenizer.getName();
+          HsqlName schemaname =
+--- 1125,1131 ----
+       * @param type Description of the Parameter
+       * @throws HsqlException
+       */
+!     public void processCreateTable(int type) throws HsqlException {
   
-              tokenizer.getThis(Token.T_EQUALS);
---- 2791,2797 ----
+          String token = tokenizer.getName();
+          HsqlName schemaname =
+***************
+*** 1287,1293 ****
+       * @throws HsqlException
+       * @return constraint
+       */
+!     private Constraint processCreateFK(Table t,
+                                         HsqlName cname) throws HsqlException {
   
-              if (tablename != null
-                      &&!tableFilter.getName().equals(tablename)) {
-!                 throw Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ tablename });
-              }
+          int[]  localcol;
+--- 1287,1293 ----
+       * @throws HsqlException
+       * @return constraint
+       */
+!     public Constraint processCreateFK(Table t,
+                                         HsqlName cname) throws HsqlException {
   
-              tokenizer.getThis(Token.T_EQUALS);
-*** misc/hsqldb/src/org/hsqldb/Row.java	Sun Oct 23 17:40:16 2005
---- misc/build/hsqldb/src/org/hsqldb/Row.java	Tue May 30 16:22:32 2006
+          int[]  localcol;
 ***************
-*** 95,101 ****
-      /**
-       *  Default constructor used only in subclasses.
+*** 1429,1435 ****
+       *
+       * @throws HsqlException
        */
-!     Row() {}
+!     private void processCreateView() throws HsqlException {
   
-      /**
-       *  Constructor for MEMORY table Row. The result is a Row with Nodes that
---- 95,101 ----
-      /**
-       *  Default constructor used only in subclasses.
+          String name = tokenizer.getName();
+          HsqlName schemaname =
+--- 1429,1435 ----
+       *
+       * @throws HsqlException
        */
-!     protected Row() {}
+!     public void processCreateView() throws HsqlException {
   
-      /**
-       *  Constructor for MEMORY table Row. The result is a Row with Nodes that
-*** misc/hsqldb/src/org/hsqldb/SchemaManager.java	Sun Oct 23 17:40:16 2005
---- misc/build/hsqldb/src/org/hsqldb/SchemaManager.java	Tue May 30 16:24:12 2006
+          String name = tokenizer.getName();
+          HsqlName schemaname =
 ***************
-*** 350,356 ****
+*** 1451,1477 ****
+          // in certain cases; the workaround here discards such scripted column
+          // lists when used in OOo
+          if (tokenizer.isGetThis(Token.T_OPENBRACKET)) {
+!             try {    // added line
+                  HsqlArrayList list = Parser.getColumnNames(database, null,
+                      tokenizer, true);
   
-          if (t == null) {
-              if (!"INFORMATION_SCHEMA".equals(schema)) {
-!                 throw Trace.error(Trace.TABLE_NOT_FOUND);
-              }
+                  colList = new HsqlName[list.size()];
+                  colList = (HsqlName[]) list.toArray(colList);
   
-              if (database.dbInfo != null) {
---- 350,356 ----
+!                 //added lines to make sure all columns are quoted
+                  if (database.isStoredFileAccess()) {
+                      for (int i = 0; i < colList.length; i++) {
+                          if (!colList[i].isNameQuoted) {
+!                             throw (Trace.error(Trace.INVALID_IDENTIFIER));
+                          }
+                      }
+                  }
+              } catch (HsqlException e) {
   
-          if (t == null) {
-              if (!"INFORMATION_SCHEMA".equals(schema)) {
-!                 throw Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ name });
-              }
+!                 //added lines to catch unquoted column names with spaces
+                  if (database.isStoredFileAccess()) {
+-                     colList = null;
+- 
+                      while (!tokenizer.getString().equals(
+                              Token.T_CLOSEBRACKET)) {}
+                  } else {
+--- 1451,1477 ----
+          // in certain cases; the workaround here discards such scripted column
+          // lists when used in OOo
+          if (tokenizer.isGetThis(Token.T_OPENBRACKET)) {
+!             try {
+                  HsqlArrayList list = Parser.getColumnNames(database, null,
+                      tokenizer, true);
   
-              if (database.dbInfo != null) {
+                  colList = new HsqlName[list.size()];
+                  colList = (HsqlName[]) list.toArray(colList);
+  
+!                 //added lines to make sure all valid columns are quoted
+                  if (database.isStoredFileAccess()) {
+                      for (int i = 0; i < colList.length; i++) {
+                          if (!colList[i].isNameQuoted) {
+!                             colList = null;
+! 
+!                             break;
+                          }
+                      }
+                  }
+              } catch (HsqlException e) {
+  
+!                 //added lines to catch unquoted names with spaces
+                  if (database.isStoredFileAccess()) {
+                      while (!tokenizer.getString().equals(
+                              Token.T_CLOSEBRACKET)) {}
+                  } else {
 ***************
-*** 359,365 ****
-          }
+*** 1509,1515 ****
+       * @param t table
+       * @throws HsqlException
+       */
+!     private void processAlterTableRename(Table t) throws HsqlException {
   
-          if (t == null) {
-!             throw Trace.error(Trace.TABLE_NOT_FOUND, name);
-          }
+          String  schema = t.getSchemaName();
+          String  newName;
+--- 1509,1515 ----
+       * @param t table
+       * @throws HsqlException
+       */
+!     public void processAlterTableRename(Table t) throws HsqlException {
   
-          return t;
---- 359,365 ----
-          }
+          String  schema = t.getSchemaName();
+          String  newName;
+***************
+*** 1556,1562 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processAlter() throws HsqlException {
   
-          if (t == null) {
-!             throw Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ name });
-          }
+          String token;
+  
+--- 1556,1562 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processAlter() throws HsqlException {
+  
+          String token;
   
-          return t;
 ***************
-*** 377,383 ****
-          Table t = findUserTable(session, name, schema);
+*** 1604,1610 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processAlterTable() throws HsqlException {
   
-          if (t == null) {
-!             throw Trace.error(Trace.TABLE_NOT_FOUND, name);
-          }
+          String tableName = tokenizer.getName();
+          String schema =
+--- 1604,1610 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processAlterTable() throws HsqlException {
   
-          return t;
---- 377,383 ----
-          Table t = findUserTable(session, name, schema);
+          String tableName = tokenizer.getName();
+          String schema =
+***************
+*** 1765,1771 ****
+       * @param t table
+       * @throws HsqlException
+       */
+!     private void processAlterColumn(Table t) throws HsqlException {
   
-          if (t == null) {
-!             throw Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ name });
-          }
+          String columnName  = tokenizer.getSimpleName();
+          int    columnIndex = t.getColumnNr(columnName);
+--- 1765,1771 ----
+       * @param t table
+       * @throws HsqlException
+       */
+!     public void processAlterColumn(Table t) throws HsqlException {
   
-          return t;
+          String columnName  = tokenizer.getSimpleName();
+          int    columnIndex = t.getColumnNr(columnName);
 ***************
-*** 718,724 ****
-                  return;
-              } else {
-                  throw Trace.error(isView ? Trace.VIEW_NOT_FOUND
-!                                          : Trace.TABLE_NOT_FOUND, name);
-              }
+*** 1838,1844 ****
           }
+      }
   
---- 718,724 ----
-                  return;
-              } else {
-                  throw Trace.error(isView ? Trace.VIEW_NOT_FOUND
-!                                          : Trace.TABLE_NOT_FOUND, new Object[]{ name });
-              }
+!     private void processAlterColumnType(Table table,
+                                          Column oldCol) throws HsqlException {
+  
+          Column     newCol = processCreateColumn(oldCol.columnName);
+--- 1838,1844 ----
           }
+      }
+  
+!     public void processAlterColumnType(Table table,
+                                          Column oldCol) throws HsqlException {
   
+          Column     newCol = processCreateColumn(oldCol.columnName);
 ***************
-*** 728,734 ****
-  // ft - concurrent
+*** 1853,1859 ****
+       * @param column column
+       * @throws HsqlException
+       */
+!     private void processAlterColumnRename(Table t,
+                                            Column column)
+                                            throws HsqlException {
+  
+--- 1853,1859 ----
+       * @param column column
+       * @throws HsqlException
+       */
+!     public void processAlterColumnRename(Table t,
+                                            Column column)
+                                            throws HsqlException {
+  
+***************
+*** 1864,1869 ****
+--- 1864,1871 ----
+              throw Trace.error(Trace.COLUMN_ALREADY_EXISTS, newName);
+          }
+  
++         t.database.schemaManager.checkColumnIsInView(t,
++                 column.columnName.name);
           session.commit();
-          dropTable(table, cascade);
-!         session.setScripting(!table.isTemp());
+          session.setScripting(true);
+          t.renameColumn(column, newName, isquoted);
+***************
+*** 1874,1886 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processAlterIndex() throws HsqlException {
+  
+          // only the one supported operation, so far
+          processAlterIndexRename();
       }
   
-      void dropTable(Table table, boolean cascade) throws HsqlException {
---- 728,734 ----
-  // ft - concurrent
-          session.commit();
-          dropTable(table, cascade);
-!         session.setScripting(true);
+!     private void processAlterSchema() throws HsqlException {
+  
+          // only the one supported operation, so far
+          processAlterSchemaRename();
+--- 1876,1888 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processAlterIndex() throws HsqlException {
+  
+          // only the one supported operation, so far
+          processAlterIndexRename();
       }
   
-      void dropTable(Table table, boolean cascade) throws HsqlException {
-*** misc/hsqldb/src/org/hsqldb/Session.java	Fri Nov  4 20:36:52 2005
---- misc/build/hsqldb/src/org/hsqldb/Session.java	Tue May 30 16:22:33 2006
+!     public void processAlterSchema() throws HsqlException {
+  
+          // only the one supported operation, so far
+          processAlterSchemaRename();
 ***************
-*** 119,125 ****
-      //
-      Database          database;
-      private User      user;
-!     HsqlArrayList     transactionList;
-      private boolean   isNestedTransaction;
-      private int       nestedOldTransIndex;
-      int               isolationMode = SessionInterface.TX_READ_COMMITTED;
---- 119,125 ----
-      //
-      Database          database;
-      private User      user;
-!     HsqlArrayList     rowActionList;
-      private boolean   isNestedTransaction;
-      private int       nestedOldTransIndex;
-      int               isolationMode = SessionInterface.TX_READ_COMMITTED;
+*** 1891,1897 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processDrop() throws HsqlException {
+  
+          String  token;
+          boolean isview;
+--- 1893,1899 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processDrop() throws HsqlException {
+  
+          String  token;
+          boolean isview;
 ***************
-*** 172,178 ****
-          sessionId                 = id;
-          database                  = db;
-          this.user                 = user;
-!         transactionList           = new HsqlArrayList(true);
-          savepoints                = new HashMappedList(4);
-          isAutoCommit              = autocommit;
-          isReadOnly                = readonly;
---- 172,178 ----
-          sessionId                 = id;
-          database                  = db;
-          this.user                 = user;
-!         rowActionList             = new HsqlArrayList(true);
-          savepoints                = new HashMappedList(4);
-          isAutoCommit              = autocommit;
-          isReadOnly                = readonly;
+*** 1957,1963 ****
+       * @param grant true if grant, false if revoke
+       * @throws HsqlException
+       */
+!     private void processGrantOrRevoke(boolean grant) throws HsqlException {
+  
+          int    right;
+          Object accessKey;
+--- 1959,1965 ----
+       * @param grant true if grant, false if revoke
+       * @throws HsqlException
+       */
+!     public void processGrantOrRevoke(boolean grant) throws HsqlException {
+  
+          int    right;
+          Object accessKey;
 ***************
-*** 228,234 ****
+*** 2024,2030 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processConnect() throws HsqlException {
   
-              database                  = null;
-              user                      = null;
-!             transactionList           = null;
-              savepoints                = null;
-              intConnection             = null;
-              compiledStatementExecutor = null;
---- 228,234 ----
+          String userName;
+          String password;
+--- 2026,2032 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processConnect() throws HsqlException {
   
-              database                  = null;
-              user                      = null;
-!             rowActionList             = null;
-              savepoints                = null;
-              intConnection             = null;
-              compiledStatementExecutor = null;
+          String userName;
+          String password;
 ***************
-*** 386,398 ****
-       * @param  row the deleted row
+*** 2060,2066 ****
+       *
        * @throws  HsqlException
        */
-!     boolean addTransactionDelete(Table table, Row row) throws HsqlException {
-  
-          if (!isAutoCommit || isNestedTransaction) {
-              Transaction t = new Transaction(true, table, row,
-                                              actionTimestamp);
+!     private void processSet() throws HsqlException {
   
-!             transactionList.add(t);
-              database.txManager.addTransaction(this, t);
+          String token;
   
-              return true;
---- 386,398 ----
-       * @param  row the deleted row
+--- 2062,2068 ----
+       *
        * @throws  HsqlException
        */
-!     boolean addDeleteAction(Table table, Row row) throws HsqlException {
+!     public void processSet() throws HsqlException {
   
-          if (!isAutoCommit || isNestedTransaction) {
-              Transaction t = new Transaction(true, table, row,
-                                              actionTimestamp);
+          String token;
   
-!             rowActionList.add(t);
-              database.txManager.addTransaction(this, t);
+***************
+*** 2322,2328 ****
+       * @return   true if next token is "TRUE"; false if next token is "FALSE"
+       * @throws  HsqlException if the next token is neither "TRUE" or "FALSE"
+       */
+!     private boolean processTrueOrFalse() throws HsqlException {
+  
+          String sToken = tokenizer.getSimpleToken();
+  
+--- 2324,2330 ----
+       * @return   true if next token is "TRUE"; false if next token is "FALSE"
+       * @throws  HsqlException if the next token is neither "TRUE" or "FALSE"
+       */
+!     public boolean processTrueOrFalse() throws HsqlException {
+  
+          String sToken = tokenizer.getSimpleToken();
   
-              return true;
 ***************
-*** 410,422 ****
-       * @param  row the inserted row
+*** 2340,2346 ****
+       *
        * @throws  HsqlException
        */
-!     boolean addTransactionInsert(Table table, Row row) throws HsqlException {
-  
-          if (!isAutoCommit || isNestedTransaction) {
-              Transaction t = new Transaction(false, table, row,
-                                              actionTimestamp);
+!     private void processCommit() throws HsqlException {
+          tokenizer.isGetThis(Token.T_WORK);
+          session.commit();
+      }
+--- 2342,2348 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processCommit() throws HsqlException {
+          tokenizer.isGetThis(Token.T_WORK);
+          session.commit();
+      }
+***************
+*** 2350,2356 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processRollback() throws HsqlException {
   
-!             transactionList.add(t);
-              database.txManager.addTransaction(this, t);
+          String  token;
+          boolean toSavepoint;
+--- 2352,2358 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processRollback() throws HsqlException {
   
-              return true;
---- 410,422 ----
-       * @param  row the inserted row
+          String  token;
+          boolean toSavepoint;
+***************
+*** 2382,2388 ****
+       *
        * @throws  HsqlException
        */
-!     boolean addInsertAction(Table table, Row row) throws HsqlException {
+!     private void processSavepoint() throws HsqlException {
   
-          if (!isAutoCommit || isNestedTransaction) {
-              Transaction t = new Transaction(false, table, row,
-                                              actionTimestamp);
+          String token;
   
-!             rowActionList.add(t);
-              database.txManager.addTransaction(this, t);
+--- 2384,2390 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processSavepoint() throws HsqlException {
+  
+          String token;
   
-              return true;
 ***************
-*** 469,475 ****
-          }
+*** 2396,2402 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processShutdown() throws HsqlException {
   
-          synchronized (database) {
-!             if (!transactionList.isEmpty()) {
-                  try {
-                      database.logger.writeCommitStatement(this);
-                  } catch (HsqlException e) {}
---- 469,475 ----
-          }
+          int    closemode;
+          String token;
+--- 2398,2404 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processShutdown() throws HsqlException {
   
-          synchronized (database) {
-!             if (!rowActionList.isEmpty()) {
-                  try {
-                      database.logger.writeCommitStatement(this);
-                  } catch (HsqlException e) {}
+          int    closemode;
+          String token;
 ***************
-*** 492,498 ****
-          }
+*** 2431,2437 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void processCheckpoint() throws HsqlException {
   
-          synchronized (database) {
-!             if (transactionList.size() != 0) {
-                  try {
-                      database.logger.writeToLog(this, Token.T_ROLLBACK);
-                  } catch (HsqlException e) {}
---- 492,498 ----
-          }
+          boolean defrag;
+          String  token;
+--- 2433,2439 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void processCheckpoint() throws HsqlException {
   
-          synchronized (database) {
-!             if (rowActionList.size() != 0) {
-                  try {
-                      database.logger.writeToLog(this, Token.T_ROLLBACK);
-                  } catch (HsqlException e) {}
+          boolean defrag;
+          String  token;
 ***************
-*** 520,526 ****
-      void savepoint(String name) throws HsqlException {
+*** 2455,2461 ****
+      }
   
-          savepoints.remove(name);
-!         savepoints.add(name, ValuePool.getInt(transactionList.size()));
+  // --------------------- new methods / simplifications ------------------------
+!     private HsqlName newIndexHsqlName(String name,
+                                        boolean isQuoted) throws HsqlException {
   
-          try {
-              database.logger.writeToLog(this, Token.T_SAVEPOINT + " " + name);
---- 520,526 ----
-      void savepoint(String name) throws HsqlException {
+          return HsqlName.isReservedIndexName(name)
+--- 2457,2463 ----
+      }
   
-          savepoints.remove(name);
-!         savepoints.add(name, ValuePool.getInt(rowActionList.size()));
+  // --------------------- new methods / simplifications ------------------------
+!     public HsqlName newIndexHsqlName(String name,
+                                        boolean isQuoted) throws HsqlException {
   
-          try {
-              database.logger.writeToLog(this, Token.T_SAVEPOINT + " " + name);
+          return HsqlName.isReservedIndexName(name)
 ***************
-*** 580,586 ****
-              Trace.doAssert(false, "beginNestedTransaction");
-          }
-  
-!         nestedOldTransIndex = transactionList.size();
-          isNestedTransaction = true;
+*** 2463,2472 ****
+                 : database.nameManager.newHsqlName(name, isQuoted);
       }
   
---- 580,586 ----
-              Trace.doAssert(false, "beginNestedTransaction");
-          }
+!     private Table newTable(int type, String name, boolean quoted,
+                             HsqlName schema) throws HsqlException {
   
-!         nestedOldTransIndex = rowActionList.size();
-          isNestedTransaction = true;
+-         int sid = session.getId();
+          HsqlName tableHsqlName = database.nameManager.newHsqlName(name,
+              quoted);
+  
+--- 2465,2473 ----
+                 : database.nameManager.newHsqlName(name, isQuoted);
       }
   
+!     public Table newTable(int type, String name, boolean quoted,
+                             HsqlName schema) throws HsqlException {
+  
+          HsqlName tableHsqlName = database.nameManager.newHsqlName(name,
+              quoted);
+  
 ***************
-*** 731,737 ****
-       * @return the current value
+*** 2493,2499 ****
+       * @throws HsqlException if the operation of adding the Column, c, to
+       *      the table t is not valid
        */
-      int getTransactionSize() {
-!         return transactionList.size();
-      }
+!     private void checkAddColumn(Table t, Column c) throws HsqlException {
   
-      /**
---- 731,737 ----
-       * @return the current value
+          boolean canAdd = true;
+  
+--- 2494,2500 ----
+       * @throws HsqlException if the operation of adding the Column, c, to
+       *      the table t is not valid
        */
-      int getTransactionSize() {
-!         return rowActionList.size();
+!     public void checkAddColumn(Table t, Column c) throws HsqlException {
+  
+          boolean canAdd = true;
+  
+***************
+*** 2519,2525 ****
+          }
       }
   
-      /**
-*** misc/hsqldb/src/org/hsqldb/Table.java	Sat Nov  5 19:09:56 2005
---- misc/build/hsqldb/src/org/hsqldb/Table.java	Tue May 30 16:24:12 2006
+!     private void checkFKColumnDefaults(Table t,
+                                         Constraint tc) throws HsqlException {
+  
+          boolean check = tc.core.updateAction == Constraint.SET_DEFAULT;
+--- 2520,2526 ----
+          }
+      }
+  
+!     public void checkFKColumnDefaults(Table t,
+                                         Constraint tc) throws HsqlException {
+  
+          boolean check = tc.core.updateAction == Constraint.SET_DEFAULT;
 ***************
-*** 355,361 ****
-       */
-      protected void setDataSource(Session s, String source, boolean isDesc,
-                                   boolean newFile) throws HsqlException {
-!         throw (Trace.error(Trace.TABLE_NOT_FOUND));
+*** 2536,2550 ****
+                  if (defExpr == null) {
+                      String columnName = column.columnName.name;
+  
+!                     throw Trace.error(Trace.COLUMN_TYPE_MISMATCH,
+!                                       Trace.NO_DEFAULT_VALUE_FOR_COLUMN,
+                                        new Object[]{ columnName });
+                  }
+              }
+          }
       }
   
-      /**
---- 355,361 ----
-       */
-      protected void setDataSource(Session s, String source, boolean isDesc,
-                                   boolean newFile) throws HsqlException {
-!         throw (Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ tableName.name }));
+!     private void processAlterSequence() throws HsqlException {
+  
+          long   start;
+          String name       = tokenizer.getName();
+--- 2537,2550 ----
+                  if (defExpr == null) {
+                      String columnName = column.columnName.name;
+  
+!                     throw Trace.error(Trace.NO_DEFAULT_VALUE_FOR_COLUMN,
+                                        new Object[]{ columnName });
+                  }
+              }
+          }
       }
   
-      /**
+!     public void processAlterSequence() throws HsqlException {
+  
+          long   start;
+          String name       = tokenizer.getName();
 ***************
-*** 1097,1103 ****
-       * the first non-unique index. NULL if there is no user-defined index.
+*** 2568,2574 ****
        *
+       * @throws HsqlException
        */
-!     private void setBestRowIdentifiers() {
+!     private void processAlterIndexRename() throws HsqlException {
   
-          int[]   briCols      = null;
-          int     briColsCount = 0;
---- 1097,1103 ----
-       * the first non-unique index. NULL if there is no user-defined index.
+          String name = tokenizer.getName();
+          String schema =
+--- 2568,2574 ----
        *
+       * @throws HsqlException
        */
-!     void setBestRowIdentifiers() {
+!     public void processAlterIndexRename() throws HsqlException {
   
-          int[]   briCols      = null;
-          int     briColsCount = 0;
+          String name = tokenizer.getName();
+          String schema =
 ***************
-*** 1333,1339 ****
+*** 2619,2625 ****
+       *
+       * @throws HsqlException
        */
-      public void setIndexRoots(int[] roots) throws HsqlException {
+!     private void processAlterSchemaRename() throws HsqlException {
   
-!         Trace.check(isCached, Trace.TABLE_NOT_FOUND);
+          String name = tokenizer.getSimpleName();
   
-          for (int i = 0; i < getIndexCount(); i++) {
-              int p = roots[i];
---- 1333,1339 ----
+--- 2619,2625 ----
+       *
+       * @throws HsqlException
        */
-      public void setIndexRoots(int[] roots) throws HsqlException {
+!     public void processAlterSchemaRename() throws HsqlException {
   
-!         Trace.check(isCached, Trace.TABLE_NOT_FOUND, new Object[]{ tableName.name });
+          String name = tokenizer.getSimpleName();
   
-          for (int i = 0; i < getIndexCount(); i++) {
-              int p = roots[i];
 ***************
-*** 1359,1365 ****
-      void setIndexRoots(String s) throws HsqlException {
+*** 2637,2643 ****
+       * @param t table
+       * @throws HsqlException
+       */
+!     private void processAlterTableAddColumn(Table t) throws HsqlException {
   
-          // the user may try to set this; this is not only internal problem
-!         Trace.check(isCached, Trace.TABLE_NOT_FOUND);
+          String token;
+          int    colindex = t.getColumnCount();
+--- 2637,2643 ----
+       * @param t table
+       * @throws HsqlException
+       */
+!     public void processAlterTableAddColumn(Table t) throws HsqlException {
   
-          Tokenizer t     = new Tokenizer(s);
-          int[]     roots = new int[getIndexCount()];
---- 1359,1365 ----
-      void setIndexRoots(String s) throws HsqlException {
+          String token;
+          int    colindex = t.getColumnCount();
+***************
+*** 2665,2671 ****
+       * @param t table
+       * @throws HsqlException
+       */
+!     private void processAlterTableDropColumn(Table t) throws HsqlException {
   
-          // the user may try to set this; this is not only internal problem
-!         Trace.check(isCached, Trace.TABLE_NOT_FOUND, new Object[]{ tableName.name });
+          String token;
+          int    colindex;
+--- 2665,2671 ----
+       * @param t table
+       * @throws HsqlException
+       */
+!     public void processAlterTableDropColumn(Table t) throws HsqlException {
   
-          Tokenizer t     = new Tokenizer(s);
-          int[]     roots = new int[getIndexCount()];
+          String token;
+          int    colindex;
 ***************
-*** 1709,1715 ****
-      /**
-       * Returns empty Object array for a new row.
+*** 2686,2692 ****
+       * @param t table
+       * @throws HsqlException
        */
-!     Object[] getEmptyRowData() {
-          return new Object[columnCount];
+!     private void processAlterTableDropConstraint(Table t)
+      throws HsqlException {
+          processAlterTableDropConstraint(t, tokenizer.getName());
       }
-  
---- 1709,1715 ----
-      /**
-       * Returns empty Object array for a new row.
+--- 2686,2692 ----
+       * @param t table
+       * @throws HsqlException
        */
-!     public Object[] getEmptyRowData() {
-          return new Object[columnCount];
+!     public void processAlterTableDropConstraint(Table t)
+      throws HsqlException {
+          processAlterTableDropConstraint(t, tokenizer.getName());
       }
+***************
+*** 2698,2704 ****
+       * @param name
+       * @throws HsqlException
+       */
+!     private void processAlterTableDropConstraint(Table t,
+              String cname) throws HsqlException {
+  
+          session.commit();
+--- 2698,2704 ----
+       * @param name
+       * @throws HsqlException
+       */
+!     public void processAlterTableDropConstraint(Table t,
+              String cname) throws HsqlException {
   
+          session.commit();
 ***************
-*** 1910,1916 ****
-          indexRow(session, row);
+*** 2710,2730 ****
+          return;
+      }
   
-          if (session != null) {
-!             session.addTransactionInsert(this, row);
-          }
+!     private void processCreateAlias() throws HsqlException {
   
-          if (isLogged) {
---- 1910,1916 ----
-          indexRow(session, row);
+          String alias;
+          String methodFQN;
   
-          if (session != null) {
-!             session.addInsertAction(this, row);
-          }
+!         alias = tokenizer.getSimpleName();
   
-          if (isLogged) {
-***************
-*** 1930,1936 ****
-          indexRow(session, r);
+          tokenizer.getThis(Token.T_FOR);
   
-          if (session != null) {
-!             session.addTransactionInsert(this, r);
-          }
+          methodFQN = upgradeMethodFQN(tokenizer.getSimpleName());
+  
+!         database.getAliasMap().put(alias, methodFQN);
       }
   
---- 1930,1936 ----
-          indexRow(session, r);
+!     private void processCreateIndex(boolean unique) throws HsqlException {
   
-          if (session != null) {
-!             session.addInsertAction(this, r);
-          }
+          Table   t;
+          String  indexName       = tokenizer.getName();
+--- 2710,2744 ----
+          return;
+      }
+  
+!     /**
+!      * If an invalid alias is encountered while processing an old script,
+!      * simply discard it.
+!      */
+!     public void processCreateAlias() throws HsqlException {
+  
+          String alias;
+          String methodFQN;
+  
+!         try {
+!             alias = tokenizer.getSimpleName();
+!         } catch (HsqlException e) {
+!             if (session.isProcessingScript()) {
+!                 alias = null;
+!             } else {
+!                 throw e;
+!             }
+!         }
+  
+          tokenizer.getThis(Token.T_FOR);
+  
+          methodFQN = upgradeMethodFQN(tokenizer.getSimpleName());
+  
+!         if (alias != null) {
+!             database.getAliasMap().put(alias, methodFQN);
+!         }
       }
   
+!     public void processCreateIndex(boolean unique) throws HsqlException {
+  
+          Table   t;
+          String  indexName       = tokenizer.getName();
 ***************
-*** 2814,2820 ****
-          row.delete();
+*** 2768,2774 ****
+       * be positive
+       * @throws HsqlException
+       */
+!     private void processCreateSequence() throws HsqlException {
   
-          if (session != null) {
-!             boolean tx = session.addTransactionDelete(this, row);
-          }
+  /*
+          CREATE SEQUENCE <name>
+--- 2782,2788 ----
+       * be positive
+       * @throws HsqlException
+       */
+!     public void processCreateSequence() throws HsqlException {
   
-          if (log && isLogged) {
---- 2814,2820 ----
-          row.delete();
+  /*
+          CREATE SEQUENCE <name>
+***************
+*** 2817,2823 ****
+       * CREATE SCHEMA PUBLIC in scripts should pass this, so we do not throw
+       * if this schema is created a second time
+       */
+!     private void processCreateSchema() throws HsqlException {
   
-          if (session != null) {
-!             session.addDeleteAction(this, row);
-          }
+          String  name     = tokenizer.getSimpleName();
+          boolean isquoted = tokenizer.wasQuotedIdentifier();
+--- 2831,2837 ----
+       * CREATE SCHEMA PUBLIC in scripts should pass this, so we do not throw
+       * if this schema is created a second time
+       */
+!     public void processCreateSchema() throws HsqlException {
   
-          if (log && isLogged) {
+          String  name     = tokenizer.getSimpleName();
+          boolean isquoted = tokenizer.wasQuotedIdentifier();
 ***************
-*** 2896,2902 ****
-          row.delete();
+*** 2842,2848 ****
+          session.loggedSchema = session.currentSchema;
+      }
   
-          if (session != null) {
-!             session.addTransactionDelete(this, row);
+!     private void processCreateUser() throws HsqlException {
+  
+          String  name;
+          String  password;
+--- 2856,2862 ----
+          session.loggedSchema = session.currentSchema;
+      }
+  
+!     public void processCreateUser() throws HsqlException {
+  
+          String  name;
+          String  password;
+***************
+*** 2863,2873 ****
           }
       }
   
---- 2896,2902 ----
-          row.delete();
+!     private void processDisconnect() throws HsqlException {
+          session.close();
+      }
   
-          if (session != null) {
-!             session.addDeleteAction(this, row);
+!     private void processDropTable(boolean isView) throws HsqlException {
+  
+          boolean ifexists = false;
+          boolean cascade  = false;
+--- 2877,2887 ----
           }
       }
   
-*** misc/hsqldb/src/org/hsqldb/Tokenizer.java	Fri Nov  4 21:20:40 2005
---- misc/build/hsqldb/src/org/hsqldb/Tokenizer.java	Fri Jun  9 14:21:37 2006
+!     public void processDisconnect() throws HsqlException {
+          session.close();
+      }
+  
+!     public void processDropTable(boolean isView) throws HsqlException {
+  
+          boolean ifexists = false;
+          boolean cascade  = false;
 ***************
-*** 98,122 ****
-   */
-  public class Tokenizer {
+*** 2904,2917 ****
+                                           isView, cascade);
+      }
   
-!     private static final int NO_TYPE   = 0,
-!                              NAME      = 1,
-!                              LONG_NAME = 2,
-!                              SPECIAL   = 3,
-!                              NUMBER    = 4,
-!                              FLOAT     = 5,
-!                              STRING    = 6,
-!                              LONG      = 7,
-!                              DECIMAL   = 8,
-!                              BOOLEAN   = 9,
-!                              DATE      = 10,
-!                              TIME      = 11,
-!                              TIMESTAMP = 12,
-!                              NULL      = 13;
+!     private void processDropUser() throws HsqlException {
   
-      // used only internally
-!     private static final int QUOTED_IDENTIFIER = 14,
-!                              REMARK_LINE       = 15,
-!                              REMARK            = 16;
-      private String           sCommand;
-      private int              iLength;
-      private int              iIndex;
---- 98,123 ----
-   */
-  public class Tokenizer {
+          session.checkAdmin();
+          session.checkDDLWrite();
+          database.getUserManager().dropUser(getPassword());
+      }
   
-!     private static final int NO_TYPE     = 0,
-!                              NAME        = 1,
-!                              LONG_NAME   = 2,
-!                              SPECIAL     = 3,
-!                              NUMBER      = 4,
-!                              FLOAT       = 5,
-!                              STRING      = 6,
-!                              LONG        = 7,
-!                              DECIMAL     = 8,
-!                              BOOLEAN     = 9,
-!                              DATE        = 10,
-!                              TIME        = 11,
-!                              TIMESTAMP   = 12,
-!                              NULL        = 13,
-!                              NAMED_PARAM = 14;
+!     private void processDropSequence() throws HsqlException {
+  
+          boolean ifexists = false;
+  
+--- 2918,2931 ----
+                                           isView, cascade);
+      }
+  
+!     public void processDropUser() throws HsqlException {
+  
+          session.checkAdmin();
+          session.checkDDLWrite();
+          database.getUserManager().dropUser(getPassword());
+      }
+  
+!     public void processDropSequence() throws HsqlException {
+  
+          boolean ifexists = false;
   
-      // used only internally
-!     private static final int QUOTED_IDENTIFIER = 15,
-!                              REMARK_LINE       = 16,
-!                              REMARK            = 17;
-      private String           sCommand;
-      private int              iLength;
-      private int              iIndex;
 ***************
-*** 342,347 ****
---- 343,359 ----
-          return !Token.isKeyword(sToken);
+*** 2949,2955 ****
+          database.schemaManager.dropSequence(sequence);
       }
   
-+     /** checks whether the previously obtained token was a (named) parameter
-+      *
-+      * @return true if the previously obtained token was a (named) parameter
-+      */
-+     boolean wasParameter() throws HsqlException {
-+ 
-+         Trace.doAssert(!bWait, "Querying state when in Wait mode");
-+ 
-+         return ( iType == NAMED_PARAM );
-+     }
-+ 
-      /**
-       * Name means all quoted and unquoted identifiers plus any word not in the
-       * hKeyword list.
+!     private void processDropTrigger() throws HsqlException {
+  
+          session.checkAdmin();
+          session.checkDDLWrite();
+--- 2963,2969 ----
+          database.schemaManager.dropSequence(sequence);
+      }
+  
+!     public void processDropTrigger() throws HsqlException {
+  
+          session.checkAdmin();
+          session.checkDDLWrite();
 ***************
-*** 386,400 ****
+*** 2961,2967 ****
+          database.schemaManager.dropTrigger(session, triggername, schemaname);
+      }
   
-      boolean wasSimpleToken() throws HsqlException {
-          return iType != QUOTED_IDENTIFIER && iType != LONG_NAME
-!                && iType != STRING;
+!     private void processDropIndex() throws HsqlException {
+  
+          String name = tokenizer.getName();
+          String schema =
+--- 2975,2981 ----
+          database.schemaManager.dropTrigger(session, triggername, schemaname);
       }
   
-      String getSimpleToken() throws HsqlException {
+!     public void processDropIndex() throws HsqlException {
   
-          getToken();
+          String name = tokenizer.getName();
+          String schema =
+***************
+*** 2984,2990 ****
+          database.schemaManager.dropIndex(session, name, schema, ifexists);
+      }
   
-!         if (iType == QUOTED_IDENTIFIER || iType == LONG_NAME
-!                 || iType == STRING) {
-              String token = iType == LONG_NAME ? sLongNameFirst
-                                                : sToken;
+!     private void processDropSchema() throws HsqlException {
   
---- 398,411 ----
+          String  name    = tokenizer.getSimpleName();
+          boolean cascade = tokenizer.isGetThis(Token.T_CASCADE);
+--- 2998,3004 ----
+          database.schemaManager.dropIndex(session, name, schema, ifexists);
+      }
   
-      boolean wasSimpleToken() throws HsqlException {
-          return iType != QUOTED_IDENTIFIER && iType != LONG_NAME
-!                && iType != STRING && iType != NAMED_PARAM;
+!     public void processDropSchema() throws HsqlException {
+  
+          String  name    = tokenizer.getSimpleName();
+          boolean cascade = tokenizer.isGetThis(Token.T_CASCADE);
+***************
+*** 3004,3010 ****
+          }
       }
   
-      String getSimpleToken() throws HsqlException {
+!     private Result processExplainPlan() throws IOException, HsqlException {
   
-          getToken();
+          // PRE:  we assume only one DML or DQL has been submitted
+          //       and simply ignore anything following the first
+--- 3018,3024 ----
+          }
+      }
   
-!         if (!wasSimpleToken()) {
-              String token = iType == LONG_NAME ? sLongNameFirst
-                                                : sToken;
+!     public Result processExplainPlan() throws IOException, HsqlException {
   
+          // PRE:  we assume only one DML or DQL has been submitted
+          //       and simply ignore anything following the first
 ***************
-*** 485,491 ****
+*** 3076,3082 ****
+      static final int    oldLibLen = oldLib.length();
+      static final String newLib    = "org.hsqldb.Library.";
   
-          getToken();
+!     private static String upgradeMethodFQN(String fqn) {
   
-!         if (sToken.equals(Token.T_MINUS)) {
-              minus = true;
+          if (fqn.startsWith(oldLib)) {
+              fqn = newLib + fqn.substring(oldLibLen);
+--- 3090,3096 ----
+      static final int    oldLibLen = oldLib.length();
+      static final String newLib    = "org.hsqldb.Library.";
   
-              getToken();
---- 496,502 ----
+!     public static String upgradeMethodFQN(String fqn) {
   
-          getToken();
+          if (fqn.startsWith(oldLib)) {
+              fqn = newLib + fqn.substring(oldLibLen);
+***************
+*** 3153,3159 ****
+       * @param t table
+       * @throws  HsqlException
+       */
+!     private void logTableDDL(Table t) throws HsqlException {
   
-!         if (sToken.equals("-")) {
-              minus = true;
+          StringBuffer tableDDL;
+          String       sourceDDL;
+--- 3167,3173 ----
+       * @param t table
+       * @throws  HsqlException
+       */
+!     public void logTableDDL(Table t) throws HsqlException {
   
-              getToken();
+          StringBuffer tableDDL;
+          String       sourceDDL;
 ***************
-*** 835,840 ****
---- 846,861 ----
+*** 3171,3177 ****
+          }
+      }
   
-                      return;
+!     private void processAlterTableAddUniqueConstraint(Table t,
+              HsqlName n) throws HsqlException {
   
-+                 case ':' :
-+                     Trace.check(++iIndex < iLength, Trace.UNEXPECTED_END_OF_COMMAND);
-+ 
-+                     c = sCommand.charAt(iIndex);
-+                     Trace.check(Character.isJavaIdentifierStart(c), Trace.INVALID_IDENTIFIER, ":" + c);
-+ 
-+                     iType = NAMED_PARAM;
-+ 
-+                     break;
-+ 
-                  case '\"' :
-                      lastTokenQuotedID = true;
-                      iType             = QUOTED_IDENTIFIER;
+          int[] col;
+--- 3185,3191 ----
+          }
+      }
+  
+!     public void processAlterTableAddUniqueConstraint(Table t,
+              HsqlName n) throws HsqlException {
+  
+          int[] col;
 ***************
-*** 916,921 ****
---- 937,943 ----
+*** 3189,3195 ****
+          tableWorks.createUniqueConstraint(col, n);
+      }
   
-              switch (iType) {
+!     private void processAlterTableAddForeignKeyConstraint(Table t,
+              HsqlName n) throws HsqlException {
   
-+                 case NAMED_PARAM :
-                  case NAME :
-                      if (Character.isJavaIdentifierPart(c)) {
-                          break;
+          Constraint tc;
+--- 3203,3209 ----
+          tableWorks.createUniqueConstraint(col, n);
+      }
+  
+!     public void processAlterTableAddForeignKeyConstraint(Table t,
+              HsqlName n) throws HsqlException {
+  
+          Constraint tc;
 ***************
-*** 925,930 ****
---- 947,956 ----
-                      sToken = sCommand.substring(start, iIndex).toUpperCase(
-                          Locale.ENGLISH);
+*** 3200,3205 ****
+--- 3214,3220 ----
   
-+                     // the following only for NAME, not for NAMED_PARAM
-+                     if ( iType == NAMED_PARAM )
-+                         return;
-+ 
-                      if (c == '.') {
-                          typeLongNameFirst = iType;
-                          sLongNameFirst    = sToken;
-*** misc/hsqldb/src/org/hsqldb/Trace.java	Fri Nov  4 20:36:56 2005
---- misc/build/hsqldb/src/org/hsqldb/Trace.java	Fri Jun  9 14:20:23 2006
+          tc = processCreateFK(t, n);
+  
++         checkFKColumnDefaults(t, tc);
+          t.checkColumnsMatch(tc.core.mainColArray, tc.core.refTable,
+                              tc.core.refColArray);
+          session.commit();
 ***************
-*** 111,371 ****
-          null);
+*** 3212,3218 ****
+                                      tc.core.updateAction);
+      }
   
-      //
-!     public static final int DATABASE_ALREADY_IN_USE                 = 1,
-!                             CONNECTION_IS_CLOSED                    = 2,
-!                             CONNECTION_IS_BROKEN                    = 3,
-!                             DATABASE_IS_SHUTDOWN                    = 4,
-!                             COLUMN_COUNT_DOES_NOT_MATCH             = 5,
-!                             DIVISION_BY_ZERO                        = 6,
-!                             INVALID_ESCAPE                          = 7,
-!                             INTEGRITY_CONSTRAINT_VIOLATION          = 8,
-!                             VIOLATION_OF_UNIQUE_INDEX               = 9,
-!                             TRY_TO_INSERT_NULL                      = 10,
-!                             UNEXPECTED_TOKEN                        = 11,
-!                             UNEXPECTED_END_OF_COMMAND               = 12,
-!                             UNKNOWN_FUNCTION                        = 13,
-!                             NEED_AGGREGATE                          = 14,
-!                             SUM_OF_NON_NUMERIC                      = 15,
-!                             WRONG_DATA_TYPE                         = 16,
-!                             CARDINALITY_VIOLATION_NO_SUBCLASS       = 17,
-!                             SERIALIZATION_FAILURE                   = 18,
-!                             TRANSFER_CORRUPTED                      = 19,
-!                             FUNCTION_NOT_SUPPORTED                  = 20,
-!                             TABLE_ALREADY_EXISTS                    = 21,
-!                             TABLE_NOT_FOUND                         = 22,
-!                             INDEX_ALREADY_EXISTS                    = 23,
-!                             SECOND_PRIMARY_KEY                      = 24,
-!                             DROP_PRIMARY_KEY                        = 25,
-!                             INDEX_NOT_FOUND                         = 26,
-!                             COLUMN_ALREADY_EXISTS                   = 27,
-!                             COLUMN_NOT_FOUND                        = 28,
-!                             FILE_IO_ERROR                           = 29,
-!                             WRONG_DATABASE_FILE_VERSION             = 30,
-!                             DATABASE_IS_READONLY                    = 31,
-!                             DATA_IS_READONLY                        = 32,
-!                             ACCESS_IS_DENIED                        = 33,
-!                             INPUTSTREAM_ERROR                       = 34,
-!                             NO_DATA_IS_AVAILABLE                    = 35,
-!                             USER_ALREADY_EXISTS                     = 36,
-!                             USER_NOT_FOUND                          = 37,
-!                             ASSERT_FAILED                           = 38,
-!                             EXTERNAL_STOP                           = 39,
-!                             GENERAL_ERROR                           = 40,
-!                             WRONG_OUT_PARAMETER                     = 41,
-!                             FUNCTION_NOT_FOUND                      = 42,
-!                             TRIGGER_NOT_FOUND                       = 43,
-!                             SAVEPOINT_NOT_FOUND                     = 44,
-!                             LABEL_REQUIRED                          = 45,
-!                             WRONG_DEFAULT_CLAUSE                    = 46,
-!                             FOREIGN_KEY_NOT_ALLOWED                 = 47,
-!                             UNKNOWN_DATA_SOURCE                     = 48,
-!                             BAD_INDEX_CONSTRAINT_NAME               = 49,
-!                             DROP_FK_INDEX                           = 50,
-!                             RESULTSET_FORWARD_ONLY                  = 51,
-!                             VIEW_ALREADY_EXISTS                     = 52,
-!                             VIEW_NOT_FOUND                          = 53,
-!                             NOT_USED_54                             = 54,
-!                             NOT_A_TABLE                             = 55,
-!                             SYSTEM_INDEX                            = 56,
-!                             COLUMN_TYPE_MISMATCH                    = 57,
-!                             BAD_ADD_COLUMN_DEFINITION               = 58,
-!                             DROP_SYSTEM_CONSTRAINT                  = 59,
-!                             CONSTRAINT_ALREADY_EXISTS               = 60,
-!                             CONSTRAINT_NOT_FOUND                    = 61,
-!                             INVALID_JDBC_ARGUMENT                   = 62,
-!                             DATABASE_IS_MEMORY_ONLY                 = 63,
-!                             OUTER_JOIN_CONDITION                    = 64,
-!                             NUMERIC_VALUE_OUT_OF_RANGE              = 65,
-!                             MISSING_SOFTWARE_MODULE                 = 66,
-!                             NOT_IN_AGGREGATE_OR_GROUP_BY            = 67,
-!                             INVALID_GROUP_BY                        = 68,
-!                             INVALID_HAVING                          = 69,
-!                             INVALID_ORDER_BY                        = 70,
-!                             INVALID_ORDER_BY_IN_DISTINCT_SELECT     = 71,
-!                             OUT_OF_MEMORY                           = 72,
-!                             OPERATION_NOT_SUPPORTED                 = 73,
-!                             INVALID_IDENTIFIER                      = 74,
-!                             TEXT_TABLE_SOURCE                       = 75,
-!                             TEXT_FILE                               = 76,
-!                             NOT_USED_77                             = 77,
-!                             ERROR_IN_SCRIPT_FILE                    = 78,
-!                             NULL_IN_VALUE_LIST                      = 79,
-!                             SOCKET_ERROR                            = 80,
-!                             INVALID_CHARACTER_ENCODING              = 81,
-!                             NOT_USED_82                             = 82,
-!                             NOT_USED_83                             = 83,
-!                             NOT_USED_84                             = 84,
-!                             UNEXPECTED_EXCEPTION                    = 85,
-!                             NOT_USED_86                             = 86,
-!                             NOT_USED_87                             = 87,
-!                             NOT_USED_88                             = 88,
-!                             NOT_USED_89                             = 89,
-!                             NOT_USED_90                             = 90,
-!                             NOT_USED_91                             = 91,
-!                             NOT_USED_92                             = 92,
-!                             NOT_USED_93                             = 93,
-!                             DATABASE_NOT_EXISTS                     = 94,
-!                             INVALID_CONVERSION                      = 95,
-!                             ERROR_IN_BINARY_SCRIPT_1                = 96,
-!                             ERROR_IN_BINARY_SCRIPT_2                = 97,
-!                             GENERAL_IO_ERROR                        = 98,
-!                             EXPRESSION_NOT_SUPPORTED                = 99,
-!                             Constraint_violation                    = 100,
-!                             Database_dropTable                      = 101,
-!                             ERROR_IN_CONSTRAINT_COLUMN_LIST         = 102,
-!                             TABLE_HAS_NO_PRIMARY_KEY                = 103,
-!                             VIOLATION_OF_UNIQUE_CONSTRAINT          = 104,
-!                             NO_DEFAULT_VALUE_FOR_COLUMN             = 105,
-!                             NULL_VALUE_AS_BOOLEAN                   = 106,
-!                             DatabaseManager_getDatabase             = 107,
-!                             NOT_USED_108                            = 108,
-!                             NOT_USED_109                            = 109,
-!                             NOT_USED_110                            = 110,
-!                             NOT_USED_111                            = 111,
-!                             NOT_USED_112                            = 112,
-!                             DatabaseScriptReader_readDDL            = 113,
-!                             DatabaseScriptReader_readExistingData   = 114,
-!                             Message_Pair                            = 115,
-!                             LOAD_SAVE_PROPERTIES                    = 116,
-!                             INVALID_TRANSACTION_STATE_NO_SUBCLASS   = 117,
-!                             JDBC_INVALID_BRI_SCOPE                  = 118,
-!                             JDBC_NO_RESULT_SET_METADATA             = 119,
-!                             JDBC_NO_RESULT_SET                      = 120,
-!                             MISSING_CLOSEBRACKET                    = 121,
-!                             ITSNS_OVERWRITE                         = 122,
-!                             COLUMN_IS_IN_INDEX                      = 123,
-!                             STRING_DATA_TRUNCATION                  = 124,
-!                             QUOTED_IDENTIFIER_REQUIRED              = 125,
-!                             STATEMENT_IS_CLOSED                     = 126,
-!                             DatabaseRowInput_skipBytes              = 127,
-!                             DatabaseRowInput_readLine               = 128,
-!                             DATA_FILE_ERROR                         = 129,
-!                             NOT_USED_130                            = 130,
-!                             HsqlDateTime_null_string                = 131,
-!                             NOT_USED_132                            = 132,
-!                             HsqlDateTime_null_date                  = 133,
-!                             NOT_USED_134                            = 134,
-!                             HsqlProperties_load                     = 135,
-!                             HsqlSocketFactorySecure_verify          = 136,
-!                             HsqlSocketFactorySecure_verify2         = 137,
-!                             jdbcConnection_nativeSQL                = 138,
-!                             HsqlSocketFactorySecure_verify3         = 139,
-!                             NOT_USED_140                            = 140,
-!                             NOT_USED_141                            = 141,
-!                             jdbcStatement_executeUpdate             = 142,
-!                             LockFile_checkHeartbeat                 = 143,
-!                             LockFile_checkHeartbeat2                = 144,
-!                             TEXT_STRING_HAS_NEWLINE                 = 145,
-!                             Result_Result                           = 146,
-!                             SERVER_NO_DATABASE                      = 147,
-!                             Server_openServerSocket                 = 148,
-!                             Server_openServerSocket2                = 149,
-!                             TEXT_TABLE_HEADER                       = 150,
-!                             NOT_USED_151                            = 151,
-!                             TextDatabaseRowOutput_writeIntData      = 152,
-!                             INVALID_LIMIT                           = 153,
-!                             JDBC_STATEMENT_NOT_ROW_COUNT            = 154,
-!                             JDBC_STATEMENT_NOT_RESULTSET            = 155,
-!                             AMBIGUOUS_COLUMN_REFERENCE              = 156,
-!                             CHECK_CONSTRAINT_VIOLATION              = 157,
-!                             JDBC_RESULTSET_IS_CLOSED                = 158,
-!                             SINGLE_COLUMN_EXPECTED                  = 159,
-!                             TOKEN_REQUIRED                          = 160,
-!                             NOT_USED_161                            = 161,
-!                             NOT_USED_162                            = 162,
-!                             ORDER_LIMIT_REQUIRED                    = 163,
-!                             TRIGGER_ALREADY_EXISTS                  = 164,
-!                             ASSERT_DIRECT_EXEC_WITH_PARAM           = 165,
-!                             NOT_USED_166                            = 166,
-!                             Expression_compareValues                = 167,
-!                             INVALID_LIMIT_EXPRESSION                = 168,
-!                             INVALID_TOP_EXPRESSION                  = 169,
-!                             SQL_CONSTRAINT_REQUIRED                 = 170,
-!                             TableWorks_dropConstraint               = 171,
-!                             TEXT_TABLE_SOURCE_FILENAME              = 172,
-!                             TEXT_TABLE_SOURCE_VALUE_MISSING         = 173,
-!                             TEXT_TABLE_SOURCE_SEPARATOR             = 174,
-!                             UNSUPPORTED_PARAM_CLASS                 = 175,
-!                             JDBC_NULL_STREAM                        = 176,
-!                             INTEGRITY_CONSTRAINT_VIOLATION_NOPARENT = 177,
-!                             NOT_USED_178                            = 178,
-!                             NOT_USED_179                            = 179,
-!                             QuotedTextDatabaseRowInput_getField     = 180,
-!                             QuotedTextDatabaseRowInput_getField2    = 181,
-!                             TextDatabaseRowInput_getField           = 182,
-!                             TextDatabaseRowInput_getField2          = 183,
-!                             TextDatabaseRowInput_getField3          = 184,
-!                             Parser_ambiguous_between1               = 185,
-!                             SEQUENCE_REFERENCED_BY_VIEW             = 186,
-!                             NOT_USED_187                            = 187,
-!                             TextCache_openning_file_error           = 188,
-!                             TextCache_closing_file_error            = 189,
-!                             TextCache_purging_file_error            = 190,
-!                             SEQUENCE_NOT_FOUND                      = 191,
-!                             SEQUENCE_ALREADY_EXISTS                 = 192,
-!                             TABLE_REFERENCED_CONSTRAINT             = 193,
-!                             TABLE_REFERENCED_VIEW                   = 194,
-!                             NOT_USED_195                            = 195,
-!                             TEXT_SOURCE_EXISTS                      = 196,
-!                             COLUMN_IS_REFERENCED                    = 197,
-!                             FUNCTION_CALL_ERROR                     = 198,
-!                             TRIGGERED_DATA_CHANGE                   = 199,
-!                             INVALID_FUNCTION_ARGUMENT               = 200,
-!                             INTERNAL_UNSUPPORTED_OPERATION          = 201,
-!                             NOT_USED_202                            = 202,
-!                             INVALID_PREPARED_STATEMENT              = 203,
-!                             CREATE_TRIGGER_COMMAND_1                = 204,
-!                             TRIGGER_FUNCTION_CLASS_NOT_FOUND        = 205,
-!                             NOT_USED_206                            = 206,
-!                             NOT_USED_207                            = 207,
-!                             INVALID_COLLATION_NAME_NO_SUBCLASS      = 208,
-!                             DataFileCache_makeRow                   = 209,
-!                             DataFileCache_open                      = 210,
-!                             DataFileCache_close                     = 211,
-!                             Expression_resolveTypes1                = 212,
-!                             Expression_resolveTypes2                = 213,
-!                             Expression_resolveTypes3                = 214,
-!                             Expression_resolveTypes4                = 215,
-!                             UNRESOLVED_PARAMETER_TYPE               = 216,
-!                             Expression_resolveTypes6                = 217,
-!                             Expression_resolveTypes7                = 218,
-!                             Expression_resolveTypeForLike           = 219,
-!                             NOT_USED_220                            = 220,
-!                             Expression_resolveTypeForIn2            = 221,
-!                             Session_execute                         = 222,
-!                             NOT_USED_223                            = 223,
-!                             NOT_USED_224                            = 224,
-!                             DATA_FILE_IS_FULL                       = 225,
-!                             THREE_PART_IDENTIFIER                   = 226,
-!                             INVALID_SCHEMA_NAME_NO_SUBCLASS         = 227,
-!                             DEPENDENT_DATABASE_OBJECT_EXISTS        = 228,
-!                             NO_SUCH_ROLE_GRANT                      = 229,
-!                             NO_SUCH_ROLE_REVOKE                     = 230,
-!                             NONMOD_ACCOUNT                          = 231,
-!                             NO_SUCH_GRANTEE                         = 232,
-!                             MISSING_SYSAUTH                         = 233,
-!                             MISSING_GRANTEE                         = 234,
-!                             CHANGE_GRANTEE                          = 235,
-!                             NULL_NAME                               = 236,
-!                             ILLEGAL_ROLE_NAME                       = 237,
-!                             ROLE_ALREADY_EXISTS                     = 238,
-!                             NO_SUCH_ROLE                            = 239,
-!                             MISSING_ROLEMANAGER                     = 240,
-!                             GRANTEE_ALREADY_EXISTS                  = 241,
-!                             MISSING_PUBLIC_GRANTEE                  = 242,
-!                             NONMOD_GRANTEE                          = 243,
-!                             CIRCULAR_GRANT                          = 244,
-!                             ALREADY_HAVE_ROLE                       = 245,
-!                             DONT_HAVE_ROLE                          = 246,
-!                             NOT_USED_247                            = 247,
-!                             RETRIEVE_NEST_ROLE_FAIL                 = 248,
-!                             NO_SUCH_RIGHT                           = 249,
-!                             IN_SCHEMA_DEFINITION                    = 250,
-!                             PRIMARY_KEY_NOT_ALLOWED                 = 251,
-!                             COLUMN_IS_IN_CONSTRAINT                 = 252,
-!                             COLUMN_SIZE_REQUIRED                    = 253,
-!                             INVALID_SIZE_PRECISION                  = 254,
-!                             LAST_ERROR_HANDLE                       = 255;
+!     private void processAlterTableAddCheckConstraint(Table table,
+              HsqlName name) throws HsqlException {
   
-      //
-      static String MESSAGE_TAG = "$$";
---- 111,374 ----
-          null);
+          Constraint check;
+--- 3227,3233 ----
+                                      tc.core.updateAction);
+      }
   
-      //
-!     public static final int
-! 
-!     //
-!     DATABASE_ALREADY_IN_USE                 = 1,
-!     CONNECTION_IS_CLOSED                    = 2,
-!     CONNECTION_IS_BROKEN                    = 3,
-!     DATABASE_IS_SHUTDOWN                    = 4,
-!     COLUMN_COUNT_DOES_NOT_MATCH             = 5,
-!     DIVISION_BY_ZERO                        = 6,
-!     INVALID_ESCAPE                          = 7,
-!     INTEGRITY_CONSTRAINT_VIOLATION          = 8,
-!     VIOLATION_OF_UNIQUE_INDEX               = 9,
-!     TRY_TO_INSERT_NULL                      = 10,
-!     UNEXPECTED_TOKEN                        = 11,
-!     UNEXPECTED_END_OF_COMMAND               = 12,
-!     UNKNOWN_FUNCTION                        = 13,
-!     NEED_AGGREGATE                          = 14,
-!     SUM_OF_NON_NUMERIC                      = 15,
-!     WRONG_DATA_TYPE                         = 16,
-!     CARDINALITY_VIOLATION_NO_SUBCLASS       = 17,
-!     SERIALIZATION_FAILURE                   = 18,
-!     TRANSFER_CORRUPTED                      = 19,
-!     FUNCTION_NOT_SUPPORTED                  = 20,
-!     TABLE_ALREADY_EXISTS                    = 21,
-!     TABLE_NOT_FOUND                         = 22,
-!     INDEX_ALREADY_EXISTS                    = 23,
-!     SECOND_PRIMARY_KEY                      = 24,
-!     DROP_PRIMARY_KEY                        = 25,
-!     INDEX_NOT_FOUND                         = 26,
-!     COLUMN_ALREADY_EXISTS                   = 27,
-!     COLUMN_NOT_FOUND                        = 28,
-!     FILE_IO_ERROR                           = 29,
-!     WRONG_DATABASE_FILE_VERSION             = 30,
-!     DATABASE_IS_READONLY                    = 31,
-!     DATA_IS_READONLY                        = 32,
-!     ACCESS_IS_DENIED                        = 33,
-!     INPUTSTREAM_ERROR                       = 34,
-!     NO_DATA_IS_AVAILABLE                    = 35,
-!     USER_ALREADY_EXISTS                     = 36,
-!     USER_NOT_FOUND                          = 37,
-!     ASSERT_FAILED                           = 38,
-!     EXTERNAL_STOP                           = 39,
-!     GENERAL_ERROR                           = 40,
-!     WRONG_OUT_PARAMETER                     = 41,
-!     FUNCTION_NOT_FOUND                      = 42,
-!     TRIGGER_NOT_FOUND                       = 43,
-!     SAVEPOINT_NOT_FOUND                     = 44,
-!     LABEL_REQUIRED                          = 45,
-!     WRONG_DEFAULT_CLAUSE                    = 46,
-!     FOREIGN_KEY_NOT_ALLOWED                 = 47,
-!     UNKNOWN_DATA_SOURCE                     = 48,
-!     BAD_INDEX_CONSTRAINT_NAME               = 49,
-!     DROP_FK_INDEX                           = 50,
-!     RESULTSET_FORWARD_ONLY                  = 51,
-!     VIEW_ALREADY_EXISTS                     = 52,
-!     VIEW_NOT_FOUND                          = 53,
-!     NOT_USED_54                             = 54,
-!     NOT_A_TABLE                             = 55,
-!     SYSTEM_INDEX                            = 56,
-!     COLUMN_TYPE_MISMATCH                    = 57,
-!     BAD_ADD_COLUMN_DEFINITION               = 58,
-!     DROP_SYSTEM_CONSTRAINT                  = 59,
-!     CONSTRAINT_ALREADY_EXISTS               = 60,
-!     CONSTRAINT_NOT_FOUND                    = 61,
-!     INVALID_JDBC_ARGUMENT                   = 62,
-!     DATABASE_IS_MEMORY_ONLY                 = 63,
-!     OUTER_JOIN_CONDITION                    = 64,
-!     NUMERIC_VALUE_OUT_OF_RANGE              = 65,
-!     MISSING_SOFTWARE_MODULE                 = 66,
-!     NOT_IN_AGGREGATE_OR_GROUP_BY            = 67,
-!     INVALID_GROUP_BY                        = 68,
-!     INVALID_HAVING                          = 69,
-!     INVALID_ORDER_BY                        = 70,
-!     INVALID_ORDER_BY_IN_DISTINCT_SELECT     = 71,
-!     OUT_OF_MEMORY                           = 72,
-!     OPERATION_NOT_SUPPORTED                 = 73,
-!     INVALID_IDENTIFIER                      = 74,
-!     TEXT_TABLE_SOURCE                       = 75,
-!     TEXT_FILE                               = 76,
-!     NOT_USED_77                             = 77,
-!     ERROR_IN_SCRIPT_FILE                    = 78,
-!     NULL_IN_VALUE_LIST                      = 79,
-!     SOCKET_ERROR                            = 80,
-!     INVALID_CHARACTER_ENCODING              = 81,
-!     NOT_USED_82                             = 82,
-!     NOT_USED_83                             = 83,
-!     NOT_USED_84                             = 84,
-!     UNEXPECTED_EXCEPTION                    = 85,
-!     NOT_USED_86                             = 86,
-!     NOT_USED_87                             = 87,
-!     NOT_USED_88                             = 88,
-!     NOT_USED_89                             = 89,
-!     NOT_USED_90                             = 90,
-!     NOT_USED_91                             = 91,
-!     NOT_USED_92                             = 92,
-!     NOT_USED_93                             = 93,
-!     DATABASE_NOT_EXISTS                     = 94,
-!     INVALID_CONVERSION                      = 95,
-!     ERROR_IN_BINARY_SCRIPT_1                = 96,
-!     ERROR_IN_BINARY_SCRIPT_2                = 97,
-!     GENERAL_IO_ERROR                        = 98,
-!     EXPRESSION_NOT_SUPPORTED                = 99,
-!     Constraint_violation                    = 100,
-!     Database_dropTable                      = 101,
-!     ERROR_IN_CONSTRAINT_COLUMN_LIST         = 102,
-!     TABLE_HAS_NO_PRIMARY_KEY                = 103,
-!     VIOLATION_OF_UNIQUE_CONSTRAINT          = 104,
-!     NO_DEFAULT_VALUE_FOR_COLUMN             = 105,
-!     NULL_VALUE_AS_BOOLEAN                   = 106,
-!     DatabaseManager_getDatabase             = 107,
-!     NOT_USED_108                            = 108,
-!     NOT_USED_109                            = 109,
-!     NOT_USED_110                            = 110,
-!     NOT_USED_111                            = 111,
-!     NOT_USED_112                            = 112,
-!     DatabaseScriptReader_readDDL            = 113,
-!     DatabaseScriptReader_readExistingData   = 114,
-!     Message_Pair                            = 115,
-!     LOAD_SAVE_PROPERTIES                    = 116,
-!     INVALID_TRANSACTION_STATE_NO_SUBCLASS   = 117,
-!     JDBC_INVALID_BRI_SCOPE                  = 118,
-!     JDBC_NO_RESULT_SET_METADATA             = 119,
-!     JDBC_NO_RESULT_SET                      = 120,
-!     MISSING_CLOSEBRACKET                    = 121,
-!     ITSNS_OVERWRITE                         = 122,
-!     COLUMN_IS_IN_INDEX                      = 123,
-!     STRING_DATA_TRUNCATION                  = 124,
-!     QUOTED_IDENTIFIER_REQUIRED              = 125,
-!     STATEMENT_IS_CLOSED                     = 126,
-!     DatabaseRowInput_skipBytes              = 127,
-!     DatabaseRowInput_readLine               = 128,
-!     DATA_FILE_ERROR                         = 129,
-!     NOT_USED_130                            = 130,
-!     HsqlDateTime_null_string                = 131,
-!     NOT_USED_132                            = 132,
-!     HsqlDateTime_null_date                  = 133,
-!     NOT_USED_134                            = 134,
-!     HsqlProperties_load                     = 135,
-!     HsqlSocketFactorySecure_verify          = 136,
-!     HsqlSocketFactorySecure_verify2         = 137,
-!     jdbcConnection_nativeSQL                = 138,
-!     HsqlSocketFactorySecure_verify3         = 139,
-!     NOT_USED_140                            = 140,
-!     NOT_USED_141                            = 141,
-!     jdbcStatement_executeUpdate             = 142,
-!     LockFile_checkHeartbeat                 = 143,
-!     LockFile_checkHeartbeat2                = 144,
-!     TEXT_STRING_HAS_NEWLINE                 = 145,
-!     Result_Result                           = 146,
-!     SERVER_NO_DATABASE                      = 147,
-!     Server_openServerSocket                 = 148,
-!     Server_openServerSocket2                = 149,
-!     TEXT_TABLE_HEADER                       = 150,
-!     NOT_USED_151                            = 151,
-!     TextDatabaseRowOutput_writeIntData      = 152,
-!     INVALID_LIMIT                           = 153,
-!     JDBC_STATEMENT_NOT_ROW_COUNT            = 154,
-!     JDBC_STATEMENT_NOT_RESULTSET            = 155,
-!     AMBIGUOUS_COLUMN_REFERENCE              = 156,
-!     CHECK_CONSTRAINT_VIOLATION              = 157,
-!     JDBC_RESULTSET_IS_CLOSED                = 158,
-!     SINGLE_COLUMN_EXPECTED                  = 159,
-!     TOKEN_REQUIRED                          = 160,
-!     NOT_USED_161                            = 161,
-!     NOT_USED_162                            = 162,
-!     ORDER_LIMIT_REQUIRED                    = 163,
-!     TRIGGER_ALREADY_EXISTS                  = 164,
-!     ASSERT_DIRECT_EXEC_WITH_PARAM           = 165,
-!     NOT_USED_166                            = 166,
-!     Expression_compareValues                = 167,
-!     INVALID_LIMIT_EXPRESSION                = 168,
-!     INVALID_TOP_EXPRESSION                  = 169,
-!     SQL_CONSTRAINT_REQUIRED                 = 170,
-!     TableWorks_dropConstraint               = 171,
-!     TEXT_TABLE_SOURCE_FILENAME              = 172,
-!     TEXT_TABLE_SOURCE_VALUE_MISSING         = 173,
-!     TEXT_TABLE_SOURCE_SEPARATOR             = 174,
-!     UNSUPPORTED_PARAM_CLASS                 = 175,
-!     JDBC_NULL_STREAM                        = 176,
-!     INTEGRITY_CONSTRAINT_VIOLATION_NOPARENT = 177,
-!     NOT_USED_178                            = 178,
-!     NOT_USED_179                            = 179,
-!     QuotedTextDatabaseRowInput_getField     = 180,
-!     QuotedTextDatabaseRowInput_getField2    = 181,
-!     TextDatabaseRowInput_getField           = 182,
-!     TextDatabaseRowInput_getField2          = 183,
-!     TextDatabaseRowInput_getField3          = 184,
-!     Parser_ambiguous_between1               = 185,
-!     SEQUENCE_REFERENCED_BY_VIEW             = 186,
-!     NOT_USED_187                            = 187,
-!     TextCache_openning_file_error           = 188,
-!     TextCache_closing_file_error            = 189,
-!     TextCache_purging_file_error            = 190,
-!     SEQUENCE_NOT_FOUND                      = 191,
-!     SEQUENCE_ALREADY_EXISTS                 = 192,
-!     TABLE_REFERENCED_CONSTRAINT             = 193,
-!     TABLE_REFERENCED_VIEW                   = 194,
-!     NOT_USED_195                            = 195,
-!     TEXT_SOURCE_EXISTS                      = 196,
-!     COLUMN_IS_REFERENCED                    = 197,
-!     FUNCTION_CALL_ERROR                     = 198,
-!     TRIGGERED_DATA_CHANGE                   = 199,
-!     INVALID_FUNCTION_ARGUMENT               = 200,
-!     INTERNAL_UNSUPPORTED_OPERATION          = 201,
+!     public void processAlterTableAddCheckConstraint(Table table,
+              HsqlName name) throws HsqlException {
+  
+          Constraint check;
+***************
+*** 3232,3238 ****
+          tableWorks.createCheckConstraint(check, name);
+      }
+  
+!     private void processAlterTableAddPrimaryKey(Table t,
+              HsqlName n) throws HsqlException {
+  
+          int[] col;
+--- 3247,3253 ----
+          tableWorks.createCheckConstraint(check, name);
+      }
+  
+!     public void processAlterTableAddPrimaryKey(Table t,
+              HsqlName n) throws HsqlException {
+  
+          int[] col;
+***************
+*** 3246,3252 ****
+          tableWorks.addPrimaryKey(col, n);
+      }
+  
+!     private void processReleaseSavepoint() throws HsqlException {
+  
+          String token;
+  
+--- 3261,3267 ----
+          tableWorks.addPrimaryKey(col, n);
+      }
+  
+!     public void processReleaseSavepoint() throws HsqlException {
+  
+          String token;
+  
+***************
+*** 3257,3263 ****
+          session.releaseSavepoint(token);
+      }
+  
+!     private void processAlterUser() throws HsqlException {
+  
+          String userName;
+          String password;
+--- 3272,3278 ----
+          session.releaseSavepoint(token);
+      }
+  
+!     public void processAlterUser() throws HsqlException {
+  
+          String userName;
+          String password;
+***************
+*** 3278,3284 ****
+          session.setScripting(false);
+      }
+  
+!     private String getUserIdentifier() throws HsqlException {
+  
+          String    token = tokenizer.getString();
+          Tokenizer t     = new Tokenizer(token);
+--- 3293,3299 ----
+          session.setScripting(false);
+      }
+  
+!     public String getUserIdentifier() throws HsqlException {
+  
+          String    token = tokenizer.getString();
+          Tokenizer t     = new Tokenizer(token);
+***************
+*** 3286,3292 ****
+          return t.getSimpleName();
+      }
+  
+!     private String getPassword() throws HsqlException {
+  
+          String token = tokenizer.getString();
+  
+--- 3301,3307 ----
+          return t.getSimpleName();
+      }
+  
+!     public String getPassword() throws HsqlException {
+  
+          String token = tokenizer.getString();
+  
+***************
+*** 3299,3305 ****
+       *
+       * @throws HsqlException
+       */
+!     private void processRoleGrantOrRevoke(boolean grant)
+      throws HsqlException {
+  
+          String         token;
+--- 3314,3320 ----
+       *
+       * @throws HsqlException
+       */
+!     public void processRoleGrantOrRevoke(boolean grant)
+      throws HsqlException {
+  
+          String         token;
+diff -crN misc/hsqldb/src/org/hsqldb/DatabaseInformationFull.java misc/build/hsqldb/src/org/hsqldb/DatabaseInformationFull.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseInformationFull.java	2005-10-29 18:30:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseInformationFull.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 66,72 ****
+  extends org.hsqldb.DatabaseInformationMain {
+  
+      /** Provides SQL function/procedure reporting support. */
+!     protected DIProcedureInfo pi;
+  
+      /**
+       * Constructs a new DatabaseInformationFull instance. <p>
+--- 66,72 ----
+  extends org.hsqldb.DatabaseInformationMain {
+  
+      /** Provides SQL function/procedure reporting support. */
+!     public DIProcedureInfo pi;
+  
+      /**
+       * Constructs a new DatabaseInformationFull instance. <p>
+***************
+*** 88,94 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the system table corresponding to the specified index
+       */
+!     protected Table generateTable(int tableIndex) throws HsqlException {
+  
+          switch (tableIndex) {
+  
+--- 88,94 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the system table corresponding to the specified index
+       */
+!     public Table generateTable(int tableIndex) throws HsqlException {
+  
+          switch (tableIndex) {
+  
+***************
+*** 449,457 ****
+  
+          // Do it.
+          while (caches.hasNext()) {
+!             cache      = (DataFileCache) caches.next();
+!             row        = t.getEmptyRowData();
+!             iFreeBytes = 0;
+              row[icache_file] =
+                  FileUtil.canonicalOrAbsolutePath(cache.getFileName());
+              row[imax_cache_sz]    = ValuePool.getInt(cache.capacity());
+--- 449,456 ----
+  
+          // Do it.
+          while (caches.hasNext()) {
+!             cache = (DataFileCache) caches.next();
+!             row   = t.getEmptyRowData();
+              row[icache_file] =
+                  FileUtil.canonicalOrAbsolutePath(cache.getFileName());
+              row[imax_cache_sz]    = ValuePool.getInt(cache.capacity());
+***************
+*** 3238,3244 ****
+       *      in the table
+       *
+       */
+!     protected void addPColRows(Table t, HsqlArrayList l, String cat,
+                                 String schem, String pName, String cName,
+                                 Integer cType, Integer dType, String tName,
+                                 Integer prec, Integer len, Integer scale,
+--- 3237,3243 ----
+       *      in the table
+       *
+       */
+!     public void addPColRows(Table t, HsqlArrayList l, String cat,
+                                 String schem, String pName, String cName,
+                                 Integer cType, Integer dType, String tName,
+                                 Integer prec, Integer len, Integer scale,
+***************
+*** 3338,3344 ****
+       *      in the table
+       *
+       */
+!     protected void addProcRows(Table t, HsqlArrayList l, String cat,
+                                 String schem, String pName, Integer ip,
+                                 Integer op, Integer rs, String remark,
+                                 Integer pType, String origin,
+--- 3337,3343 ----
+       *      in the table
+       *
+       */
+!     public void addProcRows(Table t, HsqlArrayList l, String cat,
+                                 String schem, String pName, Integer ip,
+                                 Integer op, Integer rs, String remark,
+                                 Integer pType, String origin,
+diff -crN misc/hsqldb/src/org/hsqldb/DatabaseInformation.java misc/build/hsqldb/src/org/hsqldb/DatabaseInformation.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseInformation.java	2005-05-16 16:49:36.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseInformation.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 56,124 ****
+  class DatabaseInformation {
+  
+      // ids for system table names strictly in order of sysTableNames[]
+!     protected static final int SYSTEM_BESTROWIDENTIFIER = 0;
+!     protected static final int SYSTEM_CATALOGS          = 1;
+!     protected static final int SYSTEM_COLUMNPRIVILEGES  = 2;
+!     protected static final int SYSTEM_COLUMNS           = 3;
+!     protected static final int SYSTEM_CROSSREFERENCE    = 4;
+!     protected static final int SYSTEM_INDEXINFO         = 5;
+!     protected static final int SYSTEM_PRIMARYKEYS       = 6;
+!     protected static final int SYSTEM_PROCEDURECOLUMNS  = 7;
+!     protected static final int SYSTEM_PROCEDURES        = 8;
+!     protected static final int SYSTEM_SCHEMAS           = 9;
+!     protected static final int SYSTEM_SUPERTABLES       = 10;
+!     protected static final int SYSTEM_SUPERTYPES        = 11;
+!     protected static final int SYSTEM_TABLEPRIVILEGES   = 12;
+!     protected static final int SYSTEM_TABLES            = 13;
+!     protected static final int SYSTEM_TABLETYPES        = 14;
+!     protected static final int SYSTEM_TYPEINFO          = 15;
+!     protected static final int SYSTEM_UDTATTRIBUTES     = 16;
+!     protected static final int SYSTEM_UDTS              = 17;
+!     protected static final int SYSTEM_USERS             = 18;
+!     protected static final int SYSTEM_VERSIONCOLUMNS    = 19;
+  
+      // HSQLDB-specific
+!     protected static final int SYSTEM_ALIASES         = 20;
+!     protected static final int SYSTEM_BYTECODE        = 21;
+!     protected static final int SYSTEM_CACHEINFO       = 22;
+!     protected static final int SYSTEM_CLASSPRIVILEGES = 23;
+!     protected static final int SYSTEM_SESSIONINFO     = 24;
+!     protected static final int SYSTEM_PROPERTIES      = 25;
+!     protected static final int SYSTEM_SESSIONS        = 26;
+!     protected static final int SYSTEM_TRIGGERCOLUMNS  = 27;
+!     protected static final int SYSTEM_TRIGGERS        = 28;
+!     protected static final int SYSTEM_ALLTYPEINFO     = 29;
+  
+  // boucherb@users 20030305 - brought in line with SQL 200n
+!     protected static final int SYSTEM_VIEWS = 30;
+  
+  // boucherb@users 20030403 - isolated and improved text table reporting
+!     protected static final int SYSTEM_TEXTTABLES = 31;
+  
+  // boucherb@users 20040107 - metadata support for sequences
+!     protected static final int SYSTEM_SEQUENCES        = 32;
+!     protected static final int SYSTEM_USAGE_PRIVILEGES = 33;
+  
+  // boucherb@users 20040107 - metadata support for constraints
+!     protected static final int SYSTEM_CHECK_CONSTRAINTS = 34;
+!     protected static final int SYSTEM_TABLE_CONSTRAINTS = 35;
+  
+  // boucherb@users 20040107 - metadata support for view usage breakdown- SQL 200n
+!     protected static final int SYSTEM_CHECK_COLUMN_USAGE  = 36;
+!     protected static final int SYSTEM_CHECK_ROUTINE_USAGE = 37;
+!     protected static final int SYSTEM_CHECK_TABLE_USAGE   = 38;
+!     protected static final int SYSTEM_VIEW_COLUMN_USAGE   = 39;
+!     protected static final int SYSTEM_VIEW_TABLE_USAGE    = 40;
+!     protected static final int SYSTEM_VIEW_ROUTINE_USAGE  = 41;
+  
+  // boucherb@users 20050514 - further SQL 200n metdata support
+!     protected static final int SYSTEM_AUTHORIZATIONS                 = 42;
+!     protected static final int SYSTEM_COLLATIONS                     = 43;
+!     protected static final int SYSTEM_ROLE_AUTHORIZATION_DESCRIPTORS = 44;
+!     protected static final int SYSTEM_SCHEMATA                       = 45;
+  
+      /** system table names strictly in order of their ids */
+!     protected static final String[] sysTableNames = {
+          "SYSTEM_BESTROWIDENTIFIER",                 //
+          "SYSTEM_CATALOGS",                          //
+          "SYSTEM_COLUMNPRIVILEGES",                  //
+--- 56,124 ----
+  class DatabaseInformation {
+  
+      // ids for system table names strictly in order of sysTableNames[]
+!     public static final int SYSTEM_BESTROWIDENTIFIER = 0;
+!     public static final int SYSTEM_CATALOGS          = 1;
+!     public static final int SYSTEM_COLUMNPRIVILEGES  = 2;
+!     public static final int SYSTEM_COLUMNS           = 3;
+!     public static final int SYSTEM_CROSSREFERENCE    = 4;
+!     public static final int SYSTEM_INDEXINFO         = 5;
+!     public static final int SYSTEM_PRIMARYKEYS       = 6;
+!     public static final int SYSTEM_PROCEDURECOLUMNS  = 7;
+!     public static final int SYSTEM_PROCEDURES        = 8;
+!     public static final int SYSTEM_SCHEMAS           = 9;
+!     public static final int SYSTEM_SUPERTABLES       = 10;
+!     public static final int SYSTEM_SUPERTYPES        = 11;
+!     public static final int SYSTEM_TABLEPRIVILEGES   = 12;
+!     public static final int SYSTEM_TABLES            = 13;
+!     public static final int SYSTEM_TABLETYPES        = 14;
+!     public static final int SYSTEM_TYPEINFO          = 15;
+!     public static final int SYSTEM_UDTATTRIBUTES     = 16;
+!     public static final int SYSTEM_UDTS              = 17;
+!     public static final int SYSTEM_USERS             = 18;
+!     public static final int SYSTEM_VERSIONCOLUMNS    = 19;
+  
+      // HSQLDB-specific
+!     public static final int SYSTEM_ALIASES         = 20;
+!     public static final int SYSTEM_BYTECODE        = 21;
+!     public static final int SYSTEM_CACHEINFO       = 22;
+!     public static final int SYSTEM_CLASSPRIVILEGES = 23;
+!     public static final int SYSTEM_SESSIONINFO     = 24;
+!     public static final int SYSTEM_PROPERTIES      = 25;
+!     public static final int SYSTEM_SESSIONS        = 26;
+!     public static final int SYSTEM_TRIGGERCOLUMNS  = 27;
+!     public static final int SYSTEM_TRIGGERS        = 28;
+!     public static final int SYSTEM_ALLTYPEINFO     = 29;
+  
+  // boucherb@users 20030305 - brought in line with SQL 200n
+!     public static final int SYSTEM_VIEWS = 30;
+  
+  // boucherb@users 20030403 - isolated and improved text table reporting
+!     public static final int SYSTEM_TEXTTABLES = 31;
+  
+  // boucherb@users 20040107 - metadata support for sequences
+!     public static final int SYSTEM_SEQUENCES        = 32;
+!     public static final int SYSTEM_USAGE_PRIVILEGES = 33;
+  
+  // boucherb@users 20040107 - metadata support for constraints
+!     public static final int SYSTEM_CHECK_CONSTRAINTS = 34;
+!     public static final int SYSTEM_TABLE_CONSTRAINTS = 35;
+  
+  // boucherb@users 20040107 - metadata support for view usage breakdown- SQL 200n
+!     public static final int SYSTEM_CHECK_COLUMN_USAGE  = 36;
+!     public static final int SYSTEM_CHECK_ROUTINE_USAGE = 37;
+!     public static final int SYSTEM_CHECK_TABLE_USAGE   = 38;
+!     public static final int SYSTEM_VIEW_COLUMN_USAGE   = 39;
+!     public static final int SYSTEM_VIEW_TABLE_USAGE    = 40;
+!     public static final int SYSTEM_VIEW_ROUTINE_USAGE  = 41;
+  
+  // boucherb@users 20050514 - further SQL 200n metdata support
+!     public static final int SYSTEM_AUTHORIZATIONS                 = 42;
+!     public static final int SYSTEM_COLLATIONS                     = 43;
+!     public static final int SYSTEM_ROLE_AUTHORIZATION_DESCRIPTORS = 44;
+!     public static final int SYSTEM_SCHEMATA                       = 45;
+  
+      /** system table names strictly in order of their ids */
+!     public static final String[] sysTableNames = {
+          "SYSTEM_BESTROWIDENTIFIER",                 //
+          "SYSTEM_CATALOGS",                          //
+          "SYSTEM_COLUMNPRIVILEGES",                  //
+***************
+*** 266,272 ****
+      };
+  
+      /** Map: table name => table id */
+!     protected static final IntValueHashMap sysTableNamesMap;
+  
+      static {
+          sysTableNamesMap = new IntValueHashMap(47);
+--- 266,272 ----
+      };
+  
+      /** Map: table name => table id */
+!     public static final IntValueHashMap sysTableNamesMap;
+  
+      static {
+          sysTableNamesMap = new IntValueHashMap(47);
+***************
+*** 281,293 ****
+      }
+  
+      /** Database for which to produce tables */
+!     protected final Database database;
+  
+      /**
+       * Simple object-wide flag indicating that all of this object's cached
+       * data is dirty.
+       */
+!     protected boolean isDirty = true;
+  
+      /**
+       * state flag -- if true, contentful tables are to be produced, else
+--- 281,293 ----
+      }
+  
+      /** Database for which to produce tables */
+!     public final Database database;
+  
+      /**
+       * Simple object-wide flag indicating that all of this object's cached
+       * data is dirty.
+       */
+!     public boolean isDirty = true;
+  
+      /**
+       * state flag -- if true, contentful tables are to be produced, else
+***************
+*** 295,301 ****
+       * database startup where user views reference system tables and faster
+       * system table structural reflection for table metadata.
+       */
+!     protected boolean withContent = false;
+  
+      /**
+       * Factory method retuns the fullest system table producer
+--- 295,301 ----
+       * database startup where user views reference system tables and faster
+       * system table structural reflection for table metadata.
+       */
+!     public boolean withContent = false;
+  
+      /**
+       * Factory method retuns the fullest system table producer
+diff -crN misc/hsqldb/src/org/hsqldb/DatabaseInformationMain.java misc/build/hsqldb/src/org/hsqldb/DatabaseInformationMain.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseInformationMain.java	2005-10-29 18:30:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseInformationMain.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 118,157 ****
+      // HsqlName objects for the system tables
+  
+      /** The HsqlNames of the system tables. */
+!     protected static final HsqlName[] sysTableHsqlNames;
+  
+      /** Current user for each cached system table */
+!     protected final int[] sysTableSessions = new int[sysTableNames.length];
+  
+      /** true if the contents of a cached system table depends on the session */
+!     protected final boolean[] sysTableSessionDependent =
+          new boolean[sysTableNames.length];
+  
+      /** cache of system tables */
+!     protected final Table[] sysTables = new Table[sysTableNames.length];
+  
+      /** Set: { names of system tables that are not to be cached } */
+!     protected static final HashSet nonCachedTablesSet;
+  
+      /**
+       * Map: simple <code>Column</code> name <code>String</code> object =>
+       * <code>HsqlName</code> object.
+       */
+!     protected static final HashMap columnNameMap;
+  
+      /**
+       * The <code>Session</code> object under consideration in the current
+       * executution context.
+       */
+!     protected Session session;
+  
+      /** The table types HSQLDB supports. */
+!     protected static final String[] tableTypes = new String[] {
+          "GLOBAL TEMPORARY", "SYSTEM TABLE", "TABLE", "VIEW"
+      };
+  
+      /** Provides naming support. */
+!     protected DINameSpace ns;
+  
+      static {
+          columnNameMap      = new HashMap();
+--- 118,157 ----
+      // HsqlName objects for the system tables
+  
+      /** The HsqlNames of the system tables. */
+!     public static final HsqlName[] sysTableHsqlNames;
+  
+      /** Current user for each cached system table */
+!     public final int[] sysTableSessions = new int[sysTableNames.length];
+  
+      /** true if the contents of a cached system table depends on the session */
+!     public final boolean[] sysTableSessionDependent =
+          new boolean[sysTableNames.length];
+  
+      /** cache of system tables */
+!     public final Table[] sysTables = new Table[sysTableNames.length];
+  
+      /** Set: { names of system tables that are not to be cached } */
+!     public static final HashSet nonCachedTablesSet;
+  
+      /**
+       * Map: simple <code>Column</code> name <code>String</code> object =>
+       * <code>HsqlName</code> object.
+       */
+!     public static final HashMap columnNameMap;
+  
+      /**
+       * The <code>Session</code> object under consideration in the current
+       * executution context.
+       */
+!     public Session session;
+  
+      /** The table types HSQLDB supports. */
+!     public static final String[] tableTypes = new String[] {
+          "GLOBAL TEMPORARY", "SYSTEM TABLE", "TABLE", "VIEW"
+      };
+  
+      /** Provides naming support. */
+!     public DINameSpace ns;
+  
+      static {
+          columnNameMap      = new HashMap();
+***************
+*** 218,224 ****
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     protected final void addColumn(Table t, String name, int type, int size,
+                                     boolean nullable) throws HsqlException {
+  
+          HsqlName cn;
+--- 218,224 ----
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     public final void addColumn(Table t, String name, int type, int size,
+                                     boolean nullable) throws HsqlException {
+  
+          HsqlName cn;
+***************
+*** 249,255 ****
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     protected final void addColumn(Table t, String name, int type,
+                                     boolean nullable) throws HsqlException {
+          addColumn(t, name, type, 0, nullable);
+      }
+--- 249,255 ----
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     public final void addColumn(Table t, String name, int type,
+                                     boolean nullable) throws HsqlException {
+          addColumn(t, name, type, 0, nullable);
+      }
+***************
+*** 264,270 ****
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     protected final void addColumn(Table t, String name,
+                                     int type) throws HsqlException {
+          addColumn(t, name, type, true);
+      }
+--- 264,270 ----
+       * @throws HsqlException if a problem occurs when adding the
+       *      column (e.g. duplicate name)
+       */
+!     public final void addColumn(Table t, String name,
+                                     int type) throws HsqlException {
+          addColumn(t, name, type, true);
+      }
+***************
+*** 276,282 ****
+       *
+       * @return an enumeration over all of the tables in this database
+       */
+!     protected final Iterator allTables() {
+          return new WrapperIterator(database.schemaManager.allTablesIterator(),
+                                     new WrapperIterator(sysTables, true));
+      }
+--- 276,282 ----
+       *
+       * @return an enumeration over all of the tables in this database
+       */
+!     public final Iterator allTables() {
+          return new WrapperIterator(database.schemaManager.allTablesIterator(),
+                                     new WrapperIterator(sysTables, true));
+      }
+***************
+*** 287,293 ****
+       *
+       * @throws HsqlException if a database access error occurs
+       */
+!     protected final void cacheClear() throws HsqlException {
+  
+          int i = sysTables.length;
+  
+--- 287,293 ----
+       *
+       * @throws HsqlException if a database access error occurs
+       */
+!     public final void cacheClear() throws HsqlException {
+  
+          int i = sysTables.length;
+  
+***************
+*** 312,318 ****
+       * @throws HsqlException if a database access error occurs
+       * @return the system table corresponding to the specified tableIndex value
+       */
+!     protected Table generateTable(int tableIndex) throws HsqlException {
+  
+          Table t = sysTables[tableIndex];
+  
+--- 312,318 ----
+       * @throws HsqlException if a database access error occurs
+       * @return the system table corresponding to the specified tableIndex value
+       */
+!     public Table generateTable(int tableIndex) throws HsqlException {
+  
+          Table t = sysTables[tableIndex];
+  
+***************
+*** 417,423 ****
+       *
+       * @throws HsqlException if a database access error occurs
+       */
+!     protected final void init() throws HsqlException {
+  
+          ns = new DINameSpace(database);
+  
+--- 417,423 ----
+       *
+       * @throws HsqlException if a database access error occurs
+       */
+!     public final void init() throws HsqlException {
+  
+          ns = new DINameSpace(database);
+  
+***************
+*** 488,494 ****
+       * @param table the table for which to check accessibility
+       * @throws HsqlException if a database access error occurs
+       */
+!     protected final boolean isAccessibleTable(Table table)
+      throws HsqlException {
+          return session.isAccessible(table.getName());
+      }
+--- 488,494 ----
+       * @param table the table for which to check accessibility
+       * @throws HsqlException if a database access error occurs
+       */
+!     public final boolean isAccessibleTable(Table table)
+      throws HsqlException {
+          return session.isAccessible(table.getName());
+      }
+***************
+*** 500,506 ****
+       * @param name of the table
+       * @throws HsqlException if a database access error occurs
+       */
+!     protected final Table createBlankTable(HsqlName name)
+      throws HsqlException {
+          return new Table(database, name, Table.SYSTEM_TABLE);
+      }
+--- 500,506 ----
+       * @param name of the table
+       * @throws HsqlException if a database access error occurs
+       */
+!     public final Table createBlankTable(HsqlName name)
+      throws HsqlException {
+          return new Table(database, name, Table.SYSTEM_TABLE);
+      }
+***************
+*** 1351,1357 ****
+       * COLUMN_NAME      VARCHAR   simple column name
+       * ASC_OR_DESC      VARCHAR   col. sort sequence: {"A" (Asc) | "D" (Desc)}
+       * CARDINALITY      INTEGER   # of unique values in index (not implemented)
+!      * PAGES            INTEGER   index page use (not implemented)
+       * FILTER_CONDITION VARCHAR   filter condition, if any (not implemented)
+       * </pre> <p>
+       *
+--- 1351,1357 ----
+       * COLUMN_NAME      VARCHAR   simple column name
+       * ASC_OR_DESC      VARCHAR   col. sort sequence: {"A" (Asc) | "D" (Desc)}
+       * CARDINALITY      INTEGER   # of unique values in index (not implemented)
+!      * ROW_CARDINALITY  INTEGER   # of rows in index (not implemented)
+       * FILTER_CONDITION VARCHAR   filter condition, if any (not implemented)
+       * </pre> <p>
+       *
+***************
+*** 1378,1384 ****
+              addColumn(t, "COLUMN_NAME", Types.VARCHAR);
+              addColumn(t, "ASC_OR_DESC", Types.VARCHAR, 1, true);
+              addColumn(t, "CARDINALITY", Types.INTEGER);
+!             addColumn(t, "PAGES", Types.INTEGER);
+              addColumn(t, "FILTER_CONDITION", Types.VARCHAR);
+  
+              // order: NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION.
+--- 1378,1384 ----
+              addColumn(t, "COLUMN_NAME", Types.VARCHAR);
+              addColumn(t, "ASC_OR_DESC", Types.VARCHAR, 1, true);
+              addColumn(t, "CARDINALITY", Types.INTEGER);
+!             addColumn(t, "ROW_CARDINALITY", Types.INTEGER);
+              addColumn(t, "FILTER_CONDITION", Types.VARCHAR);
+  
+              // order: NON_UNIQUE, TYPE, INDEX_NAME, and ORDINAL_POSITION.
+***************
+*** 1404,1410 ****
+          //String  columnName;
+          //String  ascOrDesc;
+          Integer cardinality;
+!         Integer pages;
+          String  filterCondition;
+  
+          // Intermediate holders
+--- 1404,1410 ----
+          //String  columnName;
+          //String  ascOrDesc;
+          Integer cardinality;
+!         Integer rowCardinality;
+          String  filterCondition;
+  
+          // Intermediate holders
+***************
+*** 1430,1436 ****
+          final int icolumn_name      = 8;
+          final int iasc_or_desc      = 9;
+          final int icardinality      = 10;
+!         final int ipages            = 11;
+          final int ifilter_condition = 12;
+  
+          // Initialization
+--- 1430,1436 ----
+          final int icolumn_name      = 8;
+          final int iasc_or_desc      = 9;
+          final int icardinality      = 10;
+!         final int irowcardinality   = 11;
+          final int ifilter_condition = 12;
+  
+          // Initialization
+***************
+*** 1469,1480 ****
+                      continue;
+                  }
+  
+!                 indexName   = ti.getIndexName(i);
+!                 nonUnique   = ti.isIndexNonUnique(i);
+!                 cardinality = ti.getIndexCardinality(i);
+!                 pages       = ti.getIndexPages(i);
+!                 cols        = ti.getIndexColumns(i);
+!                 indexType   = ti.getIndexType(i);
+  
+                  for (int k = 0; k < colCount; k++) {
+                      col                    = cols[k];
+--- 1469,1480 ----
+                      continue;
+                  }
+  
+!                 indexName      = ti.getIndexName(i);
+!                 nonUnique      = ti.isIndexNonUnique(i);
+!                 cardinality    = ti.getIndexCardinality(i);
+!                 rowCardinality = ti.getIndexRowCardinality(i);
+!                 cols           = ti.getIndexColumns(i);
+!                 indexType      = ti.getIndexType(i);
+  
+                  for (int k = 0; k < colCount; k++) {
+                      col                    = cols[k];
+***************
+*** 1490,1496 ****
+                      row[icolumn_name]      = ti.getColName(col);
+                      row[iasc_or_desc]      = ti.getIndexColDirection(i, col);
+                      row[icardinality]      = cardinality;
+!                     row[ipages]            = pages;
+                      row[ifilter_condition] = filterCondition;
+  
+                      t.insertSys(row);
+--- 1490,1496 ----
+                      row[icolumn_name]      = ti.getColName(col);
+                      row[iasc_or_desc]      = ti.getIndexColDirection(i, col);
+                      row[icardinality]      = cardinality;
+!                     row[irowcardinality]   = rowCardinality;
+                      row[ifilter_condition] = filterCondition;
+  
+                      t.insertSys(row);
+diff -crN misc/hsqldb/src/org/hsqldb/Database.java misc/build/hsqldb/src/org/hsqldb/Database.java
+*** misc/hsqldb/src/org/hsqldb/Database.java	2005-11-05 19:15:56.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Database.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 118,135 ****
+   */
+  public class Database {
+  
+!     int            databaseID;
+!     private String sType;
+!     private String sName;
+  
+  // loosecannon1@users 1.7.2 patch properties on the JDBC URL
+!     private HsqlProperties urlProperties;
+!     private String         sPath;
+      DatabaseInformation    dbInfo;
+      ClassLoader            classLoader;
+  
+      /** indicates the state of the database */
+!     private int   dbState;
+      public Logger logger;
+  
+      /** true means that all tables are readonly. */
+--- 118,135 ----
+   */
+  public class Database {
+  
+!     int    databaseID;
+!     String sType;
+!     String sName;
+  
+  // loosecannon1@users 1.7.2 patch properties on the JDBC URL
+!     public HsqlProperties urlProperties;
+!     public String         sPath;
+      DatabaseInformation    dbInfo;
+      ClassLoader            classLoader;
+  
+      /** indicates the state of the database */
+!     public int   dbState;
+      public Logger logger;
+  
+      /** true means that all tables are readonly. */
+***************
+*** 139,159 ****
+       * true means that all CACHED and TEXT tables are readonly.
+       *  MEMORY tables are updatable but updates are not persisted.
+       */
+!     private boolean filesReadOnly;
+  
+      /** true means filesReadOnly but CACHED and TEXT tables are disallowed */
+!     private boolean                filesInJar;
+      public boolean                 sqlEnforceStrictSize;
+      public int                     firstIdentity;
+!     private boolean                bIgnoreCase;
+!     private boolean                bReferentialIntegrity;
+!     private HsqlDatabaseProperties databaseProperties;
+!     private boolean                shutdownOnNoConnection;
+  
+      // schema invarient objects
+!     private HashMap        hAlias;
+!     private UserManager    userManager;
+!     private GranteeManager granteeManager;
+      HsqlNameManager        nameManager;
+  
+      // session related objects
+--- 139,159 ----
+       * true means that all CACHED and TEXT tables are readonly.
+       *  MEMORY tables are updatable but updates are not persisted.
+       */
+!     public boolean filesReadOnly;
+  
+      /** true means filesReadOnly but CACHED and TEXT tables are disallowed */
+!     public boolean                filesInJar;
+      public boolean                 sqlEnforceStrictSize;
+      public int                     firstIdentity;
+!     public boolean                bIgnoreCase;
+!     public boolean                bReferentialIntegrity;
+!     public HsqlDatabaseProperties databaseProperties;
+!     public boolean                shutdownOnNoConnection;
+  
+      // schema invarient objects
+!     public HashMap        hAlias;
+!     public UserManager    userManager;
+!     public GranteeManager granteeManager;
+      HsqlNameManager        nameManager;
+  
+      // session related objects
+***************
+*** 514,520 ****
+       *  Called by the garbage collector on this Databases object when garbage
+       *  collection determines that there are no more references to it.
+       */
+!     protected void finalize() {
+  
+          if (getState() != DATABASE_ONLINE) {
+              return;
+--- 514,520 ----
+       *  Called by the garbage collector on this Databases object when garbage
+       *  collection determines that there are no more references to it.
+       */
+!     public void finalize() {
+  
+          if (getState() != DATABASE_ONLINE) {
+              return;
+***************
+*** 627,633 ****
+          }
+      }
+  
+!     private synchronized void setState(int state) {
+          dbState = state;
+      }
+  
+--- 627,633 ----
+          }
+      }
+  
+!     public synchronized void setState(int state) {
+          dbState = state;
+      }
+  
+***************
+*** 675,682 ****
+          return urlProperties;
+      }
+  
+!     private FileAccess fileaccess;
+!     private boolean    isStoredFileAccess;
+  
+      public synchronized FileAccess getFileAccess() {
+          return fileaccess;
+--- 675,682 ----
+          return urlProperties;
+      }
+  
+!     public FileAccess fileaccess;
+!     public boolean    isStoredFileAccess;
+  
+      public synchronized FileAccess getFileAccess() {
+          return fileaccess;
+diff -crN misc/hsqldb/src/org/hsqldb/DatabaseManager.java misc/build/hsqldb/src/org/hsqldb/DatabaseManager.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseManager.java	2005-11-06 23:26:52.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseManager.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 62,68 ****
+      // Database and Server registry
+  
+      /** provides unique ID's for the Databases currently in registry */
+!     private static int dbIDCounter;
+  
+      /** name to Database mapping for mem: databases */
+      static final HashMap memDatabaseMap = new HashMap();
+--- 62,68 ----
+      // Database and Server registry
+  
+      /** provides unique ID's for the Databases currently in registry */
+!     public static int dbIDCounter;
+  
+      /** name to Database mapping for mem: databases */
+      static final HashMap memDatabaseMap = new HashMap();
+***************
+*** 237,247 ****
+      }
+  
+  // loosecannon1@users 1.7.2 patch properties on the JDBC URL
+!     private static synchronized Database getDatabaseObject(String type,
+              String path, HsqlProperties props) throws HsqlException {
+  
+          Database db;
+!         Object   key = path;
+          HashMap  databaseMap;
+  
+          if (type == DatabaseURL.S_FILE) {
+--- 237,247 ----
+      }
+  
+  // loosecannon1@users 1.7.2 patch properties on the JDBC URL
+!     public static synchronized Database getDatabaseObject(String type,
+              String path, HsqlProperties props) throws HsqlException {
+  
+          Database db;
+!         String   key = path;
+          HashMap  databaseMap;
+  
+          if (type == DatabaseURL.S_FILE) {
+***************
+*** 276,282 ****
+       * Looks up database of a given type and path in the registry. Returns
+       * null if there is none.
+       */
+!     private static synchronized Database lookupDatabaseObject(String type,
+              String path) throws HsqlException {
+  
+          Object  key = path;
+--- 276,282 ----
+       * Looks up database of a given type and path in the registry. Returns
+       * null if there is none.
+       */
+!     public static synchronized Database lookupDatabaseObject(String type,
+              String path) throws HsqlException {
+  
+          Object  key = path;
+***************
+*** 302,308 ****
+       * Adds a database to the registry. Returns
+       * null if there is none.
+       */
+!     private static synchronized void addDatabaseObject(String type,
+              String path, Database db) throws HsqlException {
+  
+          Object  key = path;
+--- 302,308 ----
+       * Adds a database to the registry. Returns
+       * null if there is none.
+       */
+!     public static synchronized void addDatabaseObject(String type,
+              String path, Database db) throws HsqlException {
+  
+          Object  key = path;
+***************
+*** 375,382 ****
+              }
+          } else if (type == DatabaseURL.S_RES) {
+              databaseMap = resDatabaseMap;
+!         } else {
+              databaseMap = memDatabaseMap;
+          }
+  
+          databaseIDMap.remove(dbID);
+--- 375,386 ----
+              }
+          } else if (type == DatabaseURL.S_RES) {
+              databaseMap = resDatabaseMap;
+!         } else if (type == DatabaseURL.S_MEM) {
+              databaseMap = memDatabaseMap;
++         } else {
++             throw (Trace.runtimeError(
++                 Trace.INTERNAL_UNSUPPORTED_OPERATION,
++                 "DatabaseManager.lookupDatabaseObject()"));
+          }
+  
+          databaseIDMap.remove(dbID);
+***************
+*** 406,412 ****
+      /**
+       * Deregisters a server as serving a given database. Not yet used.
+       */
+!     private static void deRegisterServer(Server server, Database db) {
+  
+          Iterator it = serverMap.values().iterator();
+  
+--- 410,416 ----
+      /**
+       * Deregisters a server as serving a given database. Not yet used.
+       */
+!     public static void deRegisterServer(Server server, Database db) {
+  
+          Iterator it = serverMap.values().iterator();
+  
+***************
+*** 424,430 ****
+      /**
+       * Registers a server as serving a given database.
+       */
+!     private static void registerServer(Server server, Database db) {
+  
+          if (!serverMap.containsKey(server)) {
+              serverMap.put(server, new HashSet());
+--- 428,434 ----
+      /**
+       * Registers a server as serving a given database.
+       */
+!     public static void registerServer(Server server, Database db) {
+  
+          if (!serverMap.containsKey(server)) {
+              serverMap.put(server, new HashSet());
+***************
+*** 439,445 ****
+       * Notifies all servers that serve the database that the database has been
+       * shutdown.
+       */
+!     private static void notifyServers(Database db) {
+  
+          Iterator it = serverMap.keySet().iterator();
+  
+--- 443,449 ----
+       * Notifies all servers that serve the database that the database has been
+       * shutdown.
+       */
+!     public static void notifyServers(Database db) {
+  
+          Iterator it = serverMap.keySet().iterator();
+  
+***************
+*** 471,477 ****
+      }
+  
+      // Timer
+!     private static final HsqlTimer timer = new HsqlTimer();
+  
+      public static HsqlTimer getTimer() {
+          return timer;
+--- 475,481 ----
+      }
+  
+      // Timer
+!     public static final HsqlTimer timer = new HsqlTimer();
+  
+      public static HsqlTimer getTimer() {
+          return timer;
+***************
+*** 479,488 ****
+  
+      // converts file path to database lookup key, converting any
+      // thrown exception to an HsqlException in the process
+!     private static Object filePathToKey(String path) throws HsqlException {
+  
+          try {
+!             return FileUtil.canonicalFile(path);
+          } catch (Exception e) {
+              throw Trace.error(Trace.FILE_IO_ERROR, e.toString());
+          }
+--- 483,492 ----
+  
+      // converts file path to database lookup key, converting any
+      // thrown exception to an HsqlException in the process
+!     public static String filePathToKey(String path) throws HsqlException {
+  
+          try {
+!             return FileUtil.canonicalPath(path);
+          } catch (Exception e) {
+              throw Trace.error(Trace.FILE_IO_ERROR, e.toString());
+          }
+diff -crN misc/hsqldb/src/org/hsqldb/DatabaseScript.java misc/build/hsqldb/src/org/hsqldb/DatabaseScript.java
+*** misc/hsqldb/src/org/hsqldb/DatabaseScript.java	2005-10-29 18:30:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DatabaseScript.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 651,657 ****
+      /**
+       * Generates the column definitions for a table.
+       */
+!     private static void getColumnList(Table t, int[] col, int len,
+                                        StringBuffer a) {
+  
+          a.append('(');
+--- 651,657 ----
+      /**
+       * Generates the column definitions for a table.
+       */
+!     public static void getColumnList(Table t, int[] col, int len,
+                                        StringBuffer a) {
+  
+          a.append('(');
+***************
+*** 670,676 ****
+      /**
+       * Generates the foreign key declaration for a given Constraint object.
+       */
+!     private static void getFKStatement(Constraint c, StringBuffer a) {
+  
+          a.append(Token.T_CONSTRAINT).append(' ');
+          a.append(c.getName().statementName);
+--- 670,676 ----
+      /**
+       * Generates the foreign key declaration for a given Constraint object.
+       */
+!     public static void getFKStatement(Constraint c, StringBuffer a) {
+  
+          a.append(Token.T_CONSTRAINT).append(' ');
+          a.append(c.getName().statementName);
+***************
+*** 702,708 ****
+      /**
+       * Returns the foreign key action rule.
+       */
+!     private static String getFKAction(int action) {
+  
+          switch (action) {
+  
+--- 702,708 ----
+      /**
+       * Returns the foreign key action rule.
+       */
+!     public static String getFKAction(int action) {
+  
+          switch (action) {
+  
+***************
+*** 723,729 ****
+      /**
+       * Adds a script line to the result.
+       */
+!     private static void addRow(Result r, String sql) {
+  
+          if (sql == null || sql.length() == 0) {
+              return;
+--- 723,729 ----
+      /**
+       * Adds a script line to the result.
+       */
+!     public static void addRow(Result r, String sql) {
+  
+          if (sql == null || sql.length() == 0) {
+              return;
+***************
+*** 748,754 ****
+       * grant select on system tables
+       *
+       */
+!     private static void addRightsStatements(Database dDatabase, Result r) {
+  
+          StringBuffer   a;
+          HashMappedList userlist = dDatabase.getUserManager().getUsers();
+--- 748,754 ----
+       * grant select on system tables
+       *
+       */
+!     public static void addRightsStatements(Database dDatabase, Result r) {
+  
+          StringBuffer   a;
+          HashMappedList userlist = dDatabase.getUserManager().getUsers();
+diff -crN misc/hsqldb/src/org/hsqldb/DINameSpace.java misc/build/hsqldb/src/org/hsqldb/DINameSpace.java
+*** misc/hsqldb/src/org/hsqldb/DINameSpace.java	2005-10-23 18:26:20.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DINameSpace.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 61,70 ****
+  final class DINameSpace {
+  
+      /** The Database for which the name space functionality is provided */
+!     private Database database;
+  
+      /** The catalog name reported by this namespace */
+!     private String catalogName;
+  
+      /**
+       * Set { <code>Class</code> FQN <code>String</code> objects }. <p>
+--- 61,70 ----
+  final class DINameSpace {
+  
+      /** The Database for which the name space functionality is provided */
+!     public Database database;
+  
+      /** The catalog name reported by this namespace */
+!     public String catalogName;
+  
+      /**
+       * Set { <code>Class</code> FQN <code>String</code> objects }. <p>
+***************
+*** 74,80 ****
+       * support of the expected SQL CLI scalar functions and other core
+       * HSQLDB SQL functions and stored procedures. <p>
+       */
+!     private static HashSet builtin = new HashSet();
+  
+      // procedure columns
+      // make temporary ad-hoc spec a little more "official"
+--- 74,80 ----
+       * support of the expected SQL CLI scalar functions and other core
+       * HSQLDB SQL functions and stored procedures. <p>
+       */
+!     public static HashSet builtin = new HashSet();
+  
+      // procedure columns
+      // make temporary ad-hoc spec a little more "official"
+diff -crN misc/hsqldb/src/org/hsqldb/DIProcedureInfo.java misc/build/hsqldb/src/org/hsqldb/DIProcedureInfo.java
+*** misc/hsqldb/src/org/hsqldb/DIProcedureInfo.java	2005-10-23 18:26:20.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DIProcedureInfo.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 70,94 ****
+      static final int      procedureNoNulls         = 0;
+      static final int      procedureNullable        = 1;
+      static final int      procedureNullableUnknown = 2;
+!     private Class         clazz;
+!     private Class[]       colClasses;
+!     private int[]         colTypes;
+!     private int           colOffset;
+!     private int           colCount;
+!     private boolean       colsResolved;
+!     private String        fqn;
+!     private String        specificName;
+!     private int           hnd_remarks;
+!     private Method        method;
+!     private String        sig;
+!     private DINameSpace   nameSpace;
+!     private final HashMap typeMap = new HashMap();
+  
+      public DIProcedureInfo(DINameSpace ns) throws HsqlException {
+          setNameSpace(ns);
+      }
+  
+!     private int colOffset() {
+  
+          if (!colsResolved) {
+              resolveCols();
+--- 70,94 ----
+      static final int      procedureNoNulls         = 0;
+      static final int      procedureNullable        = 1;
+      static final int      procedureNullableUnknown = 2;
+!     public Class         clazz;
+!     public Class[]       colClasses;
+!     public int[]         colTypes;
+!     public int           colOffset;
+!     public int           colCount;
+!     public boolean       colsResolved;
+!     public String        fqn;
+!     public String        specificName;
+!     public int           hnd_remarks;
+!     public Method        method;
+!     public String        sig;
+!     public DINameSpace   nameSpace;
+!     public final HashMap typeMap = new HashMap();
+  
+      public DIProcedureInfo(DINameSpace ns) throws HsqlException {
+          setNameSpace(ns);
+      }
+  
+!     public int colOffset() {
+  
+          if (!colsResolved) {
+              resolveCols();
+***************
+*** 512,518 ****
+          } catch (Exception e) {}
+      }
+  
+!     private void resolveCols() {
+  
+          Class   rType;
+          Class[] pTypes;
+--- 512,518 ----
+          } catch (Exception e) {}
+      }
+  
+!     public void resolveCols() {
+  
+          Class   rType;
+          Class[] pTypes;
+diff -crN misc/hsqldb/src/org/hsqldb/DiskNode.java misc/build/hsqldb/src/org/hsqldb/DiskNode.java
+*** misc/hsqldb/src/org/hsqldb/DiskNode.java	2005-10-23 17:40:08.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DiskNode.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 93,103 ****
+   */
+  class DiskNode extends Node {
+  
+!     protected Row    rData;
+!     private int      iLeft   = NO_POS;
+!     private int      iRight  = NO_POS;
+!     private int      iParent = NO_POS;
+!     private int      iId;    // id of Index object for this Node
+      static final int SIZE_IN_BYTE = 4 * 4;
+  
+      DiskNode(CachedRow r, RowInputInterface in,
+--- 93,103 ----
+   */
+  class DiskNode extends Node {
+  
+!     public Row    rData;
+!     public int      iLeft   = NO_POS;
+!     public int      iRight  = NO_POS;
+!     public int      iParent = NO_POS;
+!     public int      iId;    // id of Index object for this Node
+      static final int SIZE_IN_BYTE = 4 * 4;
+  
+      DiskNode(CachedRow r, RowInputInterface in,
+***************
+*** 162,168 ****
+          return rData;
+      }
+  
+!     private Node findNode(int pos) throws HsqlException {
+  
+          Node ret = null;
+          Row  r   = ((CachedRow) rData).getTable().getRow(pos);
+--- 162,168 ----
+          return rData;
+      }
+  
+!     public Node findNode(int pos) throws HsqlException {
+  
+          Node ret = null;
+          Row  r   = ((CachedRow) rData).getTable().getRow(pos);
+***************
+*** 373,379 ****
+          writeTranslatePointer(iParent, out, lookup);
+      }
+  
+!     private void writeTranslatePointer(int pointer, RowOutputInterface out,
+                                         IntLookup lookup) {
+  
+          int newPointer = 0;
+--- 373,379 ----
+          writeTranslatePointer(iParent, out, lookup);
+      }
+  
+!     public void writeTranslatePointer(int pointer, RowOutputInterface out,
+                                         IntLookup lookup) {
+  
+          int newPointer = 0;
+diff -crN misc/hsqldb/src/org/hsqldb/DITableInfo.java misc/build/hsqldb/src/org/hsqldb/DITableInfo.java
+*** misc/hsqldb/src/org/hsqldb/DITableInfo.java	2005-10-23 17:40:10.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DITableInfo.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 55,73 ****
+      static final short tableIndexOther    = 3;
+  
+      /** Used in buffer size and character octet length determinations. */
+!     private static final int HALF_MAX_INT = Integer.MAX_VALUE >>> 1;
+  
+      /** BundleHandler id for column remarks resource bundle. */
+!     private int hnd_column_remarks = -1;
+  
+      /** BundleHandler id for table remarks resource bundle. */
+!     private int hnd_table_remarks = -1;
+  
+      /** The Table object upon which this object is reporting. */
+!     private Table table;
+  
+      /** Provides intrinsic type infformation support. */
+!     private static final DITypeInfo ti = new DITypeInfo();
+  
+      /**
+       * Creates a new DITableInfo object with the default Locale and reporting
+--- 55,73 ----
+      static final short tableIndexOther    = 3;
+  
+      /** Used in buffer size and character octet length determinations. */
+!     public static final int HALF_MAX_INT = Integer.MAX_VALUE >>> 1;
+  
+      /** BundleHandler id for column remarks resource bundle. */
+!     public int hnd_column_remarks = -1;
+  
+      /** BundleHandler id for table remarks resource bundle. */
+!     public int hnd_table_remarks = -1;
+  
+      /** The Table object upon which this object is reporting. */
+!     public Table table;
+  
+      /** Provides intrinsic type infformation support. */
+!     public static final DITypeInfo ti = new DITypeInfo();
+  
+      /**
+       * Creates a new DITableInfo object with the default Locale and reporting
+***************
+*** 552,568 ****
+       * @return null (not implemented)
+       */
+      Integer getIndexCardinality(int i) {
+- 
+-         // TODO:     - implement cardinality for all table and index types
+-         // REQUIRES: - checkpoint of cardinality for CACHED tables
+-         //           - maybe extend SET TABLE <table-name> INDEX ... DDL to
+-         //           include index cardinality as well as index roots?
+-         // REQUIRES: completion of TODOs in Index for non-unique indices
+-         // REQUIRES: setIndexInfoDirty() for DatabaseInformation and related
+-         //           support  code.  That is global setDirty on every update
+-         //           DML ruins DatabaseInforamation system table caching
+-         //           effect
+- //      return ValuePool.getInt(index.getCardinality());
+          return null;
+      }
+  
+--- 552,557 ----
+***************
+*** 611,619 ****
+       * @param i zero-based index specifier
+       * @return null (not implemented)
+       */
+!     Integer getIndexPages(int i) {
+! 
+!         // not supported yet: hsqldb does not even know what a "page" is
+          return null;
+      }
+  
+--- 600,606 ----
+       * @param i zero-based index specifier
+       * @return null (not implemented)
+       */
+!     Integer getIndexRowCardinality(int i) {
+          return null;
+      }
+  
+diff -crN misc/hsqldb/src/org/hsqldb/DITypeInfo.java misc/build/hsqldb/src/org/hsqldb/DITypeInfo.java
+*** misc/hsqldb/src/org/hsqldb/DITypeInfo.java	2005-10-23 18:26:20.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/DITypeInfo.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 57,75 ****
+      static final int typeSearchable = 3;
+  
+      /** BundleHandler id for create params resource bundle. */
+!     private int hnd_create_params = -1;
+  
+      /** BundleHandler id for local names resource bundle. */
+!     private int hnd_local_names = -1;
+  
+      /** BundleHandler id for data type remarks resource bundle. */
+!     private int hnd_remarks = -1;
+  
+      /** The SQL type code on which this object is reporting. */
+!     private int type = Types.NULL;
+  
+      /** The HSQLDB subtype code on which this object is reporting. */
+!     private int typeSub = Types.TYPE_SUB_DEFAULT;
+      boolean     locale_set;
+  
+      /** Creates a new DITypeInfo object having the default Locale. */
+--- 57,75 ----
+      static final int typeSearchable = 3;
+  
+      /** BundleHandler id for create params resource bundle. */
+!     public int hnd_create_params = -1;
+  
+      /** BundleHandler id for local names resource bundle. */
+!     public int hnd_local_names = -1;
+  
+      /** BundleHandler id for data type remarks resource bundle. */
+!     public int hnd_remarks = -1;
+  
+      /** The SQL type code on which this object is reporting. */
+!     public int type = Types.NULL;
+  
+      /** The HSQLDB subtype code on which this object is reporting. */
+!     public int typeSub = Types.TYPE_SUB_DEFAULT;
+      boolean     locale_set;
+  
+      /** Creates a new DITypeInfo object having the default Locale. */
+diff -crN misc/hsqldb/src/org/hsqldb/Expression.java misc/build/hsqldb/src/org/hsqldb/Expression.java
+*** misc/hsqldb/src/org/hsqldb/Expression.java	2005-11-04 20:55:42.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Expression.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 222,249 ****
+          });
+      }
+  
+!     private static final int AGGREGATE_SELF     = -1;
+!     private static final int AGGREGATE_NONE     = 0;
+!     private static final int AGGREGATE_LEFT     = 1;
+!     private static final int AGGREGATE_RIGHT    = 2;
+!     private static final int AGGREGATE_BOTH     = 3;
+!     private static final int AGGREGATE_FUNCTION = 4;
+  
+      // type
+      int         exprType;
+!     private int aggregateSpec = AGGREGATE_NONE;
+  
+      // nodes
+!     private Expression eArg, eArg2;
+  
+!     // VALUE, VALUELIST
+!     Object          valueData;
+!     private HashSet hList;
+!     private int     dataType;
+  
+      // VALUE LIST NEW
+      Expression[]    valueList;
+!     private boolean isFixedConstantValueList;
+  
+      // QUERY - in single value selects, IN or EXISTS predicates
+      SubQuery subQuery;
+--- 222,249 ----
+          });
+      }
+  
+!     public static final int AGGREGATE_SELF     = -1;
+!     public static final int AGGREGATE_NONE     = 0;
+!     public static final int AGGREGATE_LEFT     = 1;
+!     public static final int AGGREGATE_RIGHT    = 2;
+!     public static final int AGGREGATE_BOTH     = 3;
+!     public static final int AGGREGATE_FUNCTION = 4;
+  
+      // type
+      int         exprType;
+!     public int aggregateSpec = AGGREGATE_NONE;
+  
+      // nodes
+!     Expression eArg, eArg2;
+  
+!     // VALUE
+!     Object      valueData;
+!     public int dataType;
+  
+      // VALUE LIST NEW
++     HashSet         hList;
+      Expression[]    valueList;
+!     public boolean isFixedConstantValueList;
+  
+      // QUERY - in single value selects, IN or EXISTS predicates
+      SubQuery subQuery;
+***************
+*** 253,283 ****
+      Function function;
+  
+      // LIKE
+!     private Like likeObject;
+  
+      // COLUMN
+!     private String      catalog;
+!     private String      schema;
+!     private String      tableName;
+!     private String      columnName;
+!     private TableFilter tableFilter;                // null if not yet resolved
+      TableFilter         outerFilter;                // defined if this is part of an OUTER JOIN condition tree
+  
+!     //
+!     private int     columnIndex;
+!     private boolean columnQuoted;
+!     private int     precision;
+!     private int     scale;
+!     private String  columnAlias;                    // if it is a column of a select column list
+!     private boolean aliasQuoted;
+  
+      //
+!     private boolean isDescending;                   // if it is a column in a order by
+      int             joinedTableColumnIndex = -1;    // >= 0 when it is used for order by
+      boolean         isDistinctAggregate;
+  
+      // PARAM
+!     private boolean isParam;
+  
+      // does Expression stem from a JOIN <table> ON <expression>
+      boolean isInJoin;
+--- 253,283 ----
+      Function function;
+  
+      // LIKE
+!     public Like likeObject;
+  
+      // COLUMN
+!     public String      catalog;
+!     public String      schema;
+!     public String      tableName;
+!     public String      columnName;
+!     public TableFilter tableFilter;                // null if not yet resolved
+      TableFilter         outerFilter;                // defined if this is part of an OUTER JOIN condition tree
+  
+!     // COLUMN
+!     public int     columnIndex;
+!     public boolean columnQuoted;
+!     public int     precision;
+!     public int     scale;
+!     public String  columnAlias;                    // if it is a column of a select column list
+!     public boolean aliasQuoted;
+  
+      //
+!     public boolean isDescending;                   // if it is a column in a order by
+      int             joinedTableColumnIndex = -1;    // >= 0 when it is used for order by
+      boolean         isDistinctAggregate;
+  
+      // PARAM
+!     public boolean isParam;
+  
+      // does Expression stem from a JOIN <table> ON <expression>
+      boolean isInJoin;
+***************
+*** 413,420 ****
+       */
+      Expression(String schema, String table, String column) {
+  
+!         schema    = schema;
+!         tableName = table;
+  
+          if (column == null) {
+              exprType = ASTERISK;
+--- 413,420 ----
+       */
+      Expression(String schema, String table, String column) {
+  
+!         this.schema = schema;
+!         tableName   = table;
+  
+          if (column == null) {
+              exprType = ASTERISK;
+***************
+*** 494,500 ****
+                 && scale == other.scale;
+      }
+  
+!     private void checkAggregate() {
+  
+          if (isAggregate(exprType)) {
+              aggregateSpec = AGGREGATE_SELF;
+--- 494,500 ----
+                 && scale == other.scale;
+      }
+  
+!     public void checkAggregate() {
+  
+          if (isAggregate(exprType)) {
+              aggregateSpec = AGGREGATE_SELF;
+***************
+*** 833,839 ****
+          throw Trace.error(Trace.EXPRESSION_NOT_SUPPORTED);
+      }
+  
+!     private String describe(Session session, int blanks) {
+  
+          int          lIType;
+          StringBuffer buf = new StringBuffer(64);
+--- 833,839 ----
+          throw Trace.error(Trace.EXPRESSION_NOT_SUPPORTED);
+      }
+  
+!     public String describe(Session session, int blanks) {
+  
+          int          lIType;
+          StringBuffer buf = new StringBuffer(64);
+***************
+*** 1214,1220 ****
+       *
+       * @return boolean
+       */
+!     private boolean isColumn() {
+  
+          switch (exprType) {
+  
+--- 1214,1220 ----
+       *
+       * @return boolean
+       */
+!     public boolean isColumn() {
+  
+          switch (exprType) {
+  
+***************
+*** 1572,1578 ****
+              result = result && eArg2.checkResolved(check);
+          }
+  
+!         if (subQuery != null) {
+              result = result && subQuery.select.checkResolved(check);
+          }
+  
+--- 1572,1578 ----
+              result = result && eArg2.checkResolved(check);
+          }
+  
+!         if (subQuery != null && subQuery.select != null) {
+              result = result && subQuery.select.checkResolved(check);
+          }
+  
+***************
+*** 3474,3480 ****
+          return compareValues(session, o1, o2);
+      }
+  
+!     private Boolean compareValues(Session session, Object o1,
+                                    Object o2) throws HsqlException {
+  
+          int type = eArg.dataType;
+--- 3474,3480 ----
+          return compareValues(session, o1, o2);
+      }
+  
+!     public Boolean compareValues(Session session, Object o1,
+                                    Object o2) throws HsqlException {
+  
+          int type = eArg.dataType;
+***************
+*** 3532,3538 ****
+       * @return boolean
+       * @throws HsqlException
+       */
+!     private Boolean testInCondition(Session session,
+                                      Object o) throws HsqlException {
+  
+          if (o == null) {
+--- 3532,3538 ----
+       * @return boolean
+       * @throws HsqlException
+       */
+!     public Boolean testInCondition(Session session,
+                                      Object o) throws HsqlException {
+  
+          if (o == null) {
+***************
+*** 3596,3602 ****
+          throw Trace.error(Trace.WRONG_DATA_TYPE);
+      }
+  
+!     private Boolean testExistsCondition(Session session)
+      throws HsqlException {
+  
+          if (subQuery.isResolved) {
+--- 3596,3602 ----
+          throw Trace.error(Trace.WRONG_DATA_TYPE);
+      }
+  
+!     public Boolean testExistsCondition(Session session)
+      throws HsqlException {
+  
+          if (subQuery.isResolved) {
+***************
+*** 3610,3616 ****
+          }
+      }
+  
+!     private Boolean testAnyAllCondition(Session session,
+                                          Object o) throws HsqlException {
+  
+          if (o == null) {
+--- 3610,3616 ----
+          }
+      }
+  
+!     public Boolean testAnyAllCondition(Session session,
+                                          Object o) throws HsqlException {
+  
+          if (o == null) {
+***************
+*** 3633,3639 ****
+          return result;
+      }
+  
+!     private Boolean getAnyAllValue(Session session, Object o,
+                                     SubQuery subquery) throws HsqlException {
+  
+          boolean     empty    = subquery.table.isEmpty(session);
+--- 3633,3639 ----
+          return result;
+      }
+  
+!     public Boolean getAnyAllValue(Session session, Object o,
+                                     SubQuery subquery) throws HsqlException {
+  
+          boolean     empty    = subquery.table.isEmpty(session);
+diff -crN misc/hsqldb/src/org/hsqldb/Function.java misc/build/hsqldb/src/org/hsqldb/Function.java
+*** misc/hsqldb/src/org/hsqldb/Function.java	2005-10-23 17:40:10.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Function.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 96,115 ****
+   */
+  class Function {
+  
+!     private String         sFunction;
+!     private Method         mMethod;
+!     private Class          cReturnClass;
+!     private Class[]        aArgClasses;
+!     private int            iReturnType;
+!     private int            iArgCount;
+!     private int            iSqlArgCount;
+!     private int            iSqlArgStart;
+!     private int[]          iArgType;
+!     private boolean[]      bArgNullable;
+      Expression[]           eArg;
+!     private boolean        bConnection;
+!     private static HashMap methodCache = new HashMap();
+!     private int            fID;
+      String                 name;        // name used to call function
+      boolean                isSimple;    //CURRENT_TIME, NOW etc.
+      boolean                hasAggregate;
+--- 96,115 ----
+   */
+  class Function {
+  
+!     public String         sFunction;
+!     public Method         mMethod;
+!     public Class          cReturnClass;
+!     public Class[]        aArgClasses;
+!     public int            iReturnType;
+!     public int            iArgCount;
+!     public int            iSqlArgCount;
+!     public int            iSqlArgStart;
+!     public int[]          iArgType;
+!     public boolean[]      bArgNullable;
+      Expression[]           eArg;
+!     public boolean        bConnection;
+!     public static HashMap methodCache = new HashMap();
+!     public int            fID;
+      String                 name;        // name used to call function
+      boolean                isSimple;    //CURRENT_TIME, NOW etc.
+      boolean                hasAggregate;
+***************
+*** 368,374 ****
+          // Library function throw HsqlException
+      }
+  
+!     private Object[] getArguments(Session session) throws HsqlException {
+  
+          int      i    = bConnection ? 1
+                                      : 0;
+--- 368,374 ----
+          // Library function throw HsqlException
+      }
+  
+!     public Object[] getArguments(Session session) throws HsqlException {
+  
+          int      i    = bConnection ? 1
+                                      : 0;
+***************
+*** 405,411 ****
+      /**
+       * returns null if any non-nullable element of values is null
+       */
+!     private Object[] getNotNull(Object[] values) throws HsqlException {
+  
+          int i = bConnection ? 1
+                              : 0;
+--- 405,411 ----
+      /**
+       * returns null if any non-nullable element of values is null
+       */
+!     public Object[] getNotNull(Object[] values) throws HsqlException {
+  
+          int i = bConnection ? 1
+                              : 0;
+diff -crN misc/hsqldb/src/org/hsqldb/Grantee.java misc/build/hsqldb/src/org/hsqldb/Grantee.java
+*** misc/hsqldb/src/org/hsqldb/Grantee.java	2005-10-29 18:30:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Grantee.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 52,60 ****
+   * Method names ending in Direct indicate methods which do not recurse
+   * to look through Roles which "this" object is a member of.
+   *
+!  * We use the word "Admin" (e.g., in private variable "admin" and method
+   * "isAdmin()) to mean this Grantee has admin priv by any means.
+!  * We use the word "adminDirect" (e.g., in private variable "adminDirect"
+   * and method "isAdminDirect()) to mean this Grantee has admin priv
+   * directly.
+   *
+--- 52,60 ----
+   * Method names ending in Direct indicate methods which do not recurse
+   * to look through Roles which "this" object is a member of.
+   *
+!  * We use the word "Admin" (e.g., in public variable "admin" and method
+   * "isAdmin()) to mean this Grantee has admin priv by any means.
+!  * We use the word "adminDirect" (e.g., in public variable "adminDirect"
+   * and method "isAdminDirect()) to mean this Grantee has admin priv
+   * directly.
+   *
+***************
+*** 73,93 ****
+       * true if this grantee has database administrator priv directly
+       *  (ie., not by membership in any role)
+       */
+!     private boolean isAdminDirect = false;
+  
+      /** true if this grantee has database administrator priv by any means. */
+!     private boolean isAdmin = false;
+  
+      /** contains righs granted direct, or via roles, expept those of PUBLIC */
+!     private IntValueHashMap fullRightsMap = new IntValueHashMap();
+  
+      /**
+       * Grantee name.
+       */
+!     private String granteeName;
+  
+      /** map with database object identifier keys and access privileges values */
+!     private IntValueHashMap rightsMap;
+  
+      /** These are the DIRECT roles.  Each of these may contain nested roles */
+      HashSet roles = new HashSet();
+--- 73,93 ----
+       * true if this grantee has database administrator priv directly
+       *  (ie., not by membership in any role)
+       */
+!     public boolean isAdminDirect = false;
+  
+      /** true if this grantee has database administrator priv by any means. */
+!     public boolean isAdmin = false;
+  
+      /** contains righs granted direct, or via roles, expept those of PUBLIC */
+!     public IntValueHashMap fullRightsMap = new IntValueHashMap();
+  
+      /**
+       * Grantee name.
+       */
+!     public String granteeName;
+  
+      /** map with database object identifier keys and access privileges values */
+!     public IntValueHashMap rightsMap;
+  
+      /** These are the DIRECT roles.  Each of these may contain nested roles */
+      HashSet roles = new HashSet();
+***************
+*** 98,107 ****
+       * Note: All Grantee objects except the special
+       * SYS and PUBLIC Grantee objects contain a reference to this object
+       */
+!     private Grantee pubGrantee;
+  
+      /** Needed only to give access to the roles for this database */
+!     private GranteeManager granteeManager;
+  
+      /**
+       * Constructor, with a argument reference to the PUBLIC User Object which
+--- 98,107 ----
+       * Note: All Grantee objects except the special
+       * SYS and PUBLIC Grantee objects contain a reference to this object
+       */
+!     public Grantee pubGrantee;
+  
+      /** Needed only to give access to the roles for this database */
+!     public GranteeManager granteeManager;
+  
+      /**
+       * Constructor, with a argument reference to the PUBLIC User Object which
+***************
+*** 219,225 ****
+       *
+       * @return Given role with new elements added.
+       */
+!     private HashSet addGranteeAndRoles(HashSet set) {
+  
+          String candidateRole;
+  
+--- 219,225 ----
+       *
+       * @return Given role with new elements added.
+       */
+!     public HashSet addGranteeAndRoles(HashSet set) {
+  
+          String candidateRole;
+  
+***************
+*** 407,413 ****
+       * Considers none of pubGranee, nested roles, admin privs, globally
+       * available Class object.
+       */
+!     protected boolean isDirectlyAccessible(Object dbObject,
+                                             int rights) throws HsqlException {
+  
+          int n = rightsMap.get(dbObject, 0);
+--- 407,413 ----
+       * Considers none of pubGranee, nested roles, admin privs, globally
+       * available Class object.
+       */
+!     public boolean isDirectlyAccessible(Object dbObject,
+                                             int rights) throws HsqlException {
+  
+          int n = rightsMap.get(dbObject, 0);
+diff -crN misc/hsqldb/src/org/hsqldb/GranteeManager.java misc/build/hsqldb/src/org/hsqldb/GranteeManager.java
+*** misc/hsqldb/src/org/hsqldb/GranteeManager.java	2005-10-29 18:30:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/GranteeManager.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 105,117 ****
+       * Map of String-to-Grantee-objects.<p>
+       * Primary object maintained by this class
+       */
+!     private HashMappedList map = new HashMappedList();
+  
+      /**
+       * This object's set of Role objects. <p>
+       * role-Strings-to-Grantee-object
+       */
+!     private HashMappedList roleMap = new HashMappedList();
+  
+      /**
+       * Construct the GranteeManager for a Database.
+--- 105,117 ----
+       * Map of String-to-Grantee-objects.<p>
+       * Primary object maintained by this class
+       */
+!     public HashMappedList map = new HashMappedList();
+  
+      /**
+       * This object's set of Role objects. <p>
+       * role-Strings-to-Grantee-object
+       */
+!     public HashMappedList roleMap = new HashMappedList();
+  
+      /**
+       * Construct the GranteeManager for a Database.
+***************
+*** 451,457 ****
+          return list;
+      }
+  
+!     private static String[] getRightsArraySub(int right) {
+  
+  //        checkValidFlags(right);
+          if (right == 0) {
+--- 451,457 ----
+          return list;
+      }
+  
+!     public static String[] getRightsArraySub(int right) {
+  
+  //        checkValidFlags(right);
+          if (right == 0) {
+diff -crN misc/hsqldb/src/org/hsqldb/GroupedResult.java misc/build/hsqldb/src/org/hsqldb/GroupedResult.java
+*** misc/hsqldb/src/org/hsqldb/GroupedResult.java	2005-10-23 18:26:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/GroupedResult.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 68,80 ****
+  class GroupedResult {
+  
+  /** @todo fredt - initialise results on first use */
+!     private Result        result;
+      int                   groupBegin;
+      int                   groupEnd;
+!     private final boolean isGrouped;
+!     private final boolean isAggregated;
+!     private HashSet       groups;
+!     private ResultGroup   currGroup;
+  
+      GroupedResult(Select select, Result.ResultMetaData meta) {
+  
+--- 68,80 ----
+  class GroupedResult {
+  
+  /** @todo fredt - initialise results on first use */
+!     public Result        result;
+      int                   groupBegin;
+      int                   groupEnd;
+!     public final boolean isGrouped;
+!     public final boolean isAggregated;
+!     public HashSet       groups;
+!     public ResultGroup   currGroup;
+  
+      GroupedResult(Select select, Result.ResultMetaData meta) {
+  
+***************
+*** 152,158 ****
+          Object[] row;
+          int      hashCode;
+  
+!         private ResultGroup(Object[] row) {
+  
+              this.row = row;
+              hashCode = 0;
+--- 152,158 ----
+          Object[] row;
+          int      hashCode;
+  
+!         public ResultGroup(Object[] row) {
+  
+              this.row = row;
+              hashCode = 0;
+***************
+*** 189,195 ****
+              return true;
+          }
+  
+!         private boolean equals(Object o1, Object o2) {
+              return (o1 == null) ? o2 == null
+                                  : o1.equals(o2);
+          }
+--- 189,195 ----
+              return true;
+          }
+  
+!         public boolean equals(Object o1, Object o2) {
+              return (o1 == null) ? o2 == null
+                                  : o1.equals(o2);
+          }
+diff -crN misc/hsqldb/src/org/hsqldb/HSQLClientConnection.java misc/build/hsqldb/src/org/hsqldb/HSQLClientConnection.java
+*** misc/hsqldb/src/org/hsqldb/HSQLClientConnection.java	2005-10-23 17:40:10.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HSQLClientConnection.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 56,73 ****
+  
+      static final int          BUFFER_SIZE = 0x1000;
+      final byte[]              mainBuffer  = new byte[BUFFER_SIZE];
+!     private boolean           isClosed;
+!     private Socket            socket;
+!     protected OutputStream    dataOutput;
+!     protected DataInputStream dataInput;
+!     protected RowOutputBinary rowOut;
+!     protected RowInputBinary  rowIn;
+!     private Result            resultOut;
+!     private int               sessionID;
+  
+      //
+!     private boolean isReadOnly   = false;
+!     private boolean isAutoCommit = true;
+  
+      //
+      String  host;
+--- 56,73 ----
+  
+      static final int          BUFFER_SIZE = 0x1000;
+      final byte[]              mainBuffer  = new byte[BUFFER_SIZE];
+!     public boolean           isClosed;
+!     public Socket            socket;
+!     public OutputStream    dataOutput;
+!     public DataInputStream dataInput;
+!     public RowOutputBinary rowOut;
+!     public RowInputBinary  rowIn;
+!     public Result            resultOut;
+!     public int               sessionID;
+  
+      //
+!     public boolean isReadOnly   = false;
+!     public boolean isAutoCommit = true;
+  
+      //
+      String  host;
+***************
+*** 113,119 ****
+       * resultOut is reused to trasmit all remote calls for session management.
+       * Here the structure is preset for sending attributes.
+       */
+!     private void initStructures() {
+  
+          rowOut    = new RowOutputBinary(mainBuffer);
+          rowIn     = new RowInputBinary(rowOut);
+--- 113,119 ----
+       * resultOut is reused to trasmit all remote calls for session management.
+       * Here the structure is preset for sending attributes.
+       */
+!     public void initStructures() {
+  
+          rowOut    = new RowOutputBinary(mainBuffer);
+          rowIn     = new RowInputBinary(rowOut);
+***************
+*** 122,133 ****
+          resultOut.add(new Object[7]);
+      }
+  
+!     protected void initConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {
+          openConnection(host, port, isTLS);
+      }
+  
+!     protected void openConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {
+  
+          try {
+--- 122,133 ----
+          resultOut.add(new Object[7]);
+      }
+  
+!     public void initConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {
+          openConnection(host, port, isTLS);
+      }
+  
+!     public void openConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {
+  
+          try {
+***************
+*** 143,149 ****
+          }
+      }
+  
+!     protected void closeConnection() {
+  
+          try {
+              if (socket != null) {
+--- 143,149 ----
+          }
+      }
+  
+!     public void closeConnection() {
+  
+          try {
+              if (socket != null) {
+***************
+*** 186,192 ****
+          } catch (Exception e) {}
+      }
+  
+!     private Object getAttribute(int id) throws HsqlException {
+  
+          resultOut.setResultType(ResultConstants.GETSESSIONATTR);
+  
+--- 186,192 ----
+          } catch (Exception e) {}
+      }
+  
+!     public Object getAttribute(int id) throws HsqlException {
+  
+          resultOut.setResultType(ResultConstants.GETSESSIONATTR);
+  
+***************
+*** 199,205 ****
+          return in.rRoot.data[id];
+      }
+  
+!     private void setAttribute(Object property, int id) throws HsqlException {
+  
+          resultOut.setResultType(ResultConstants.SETSESSIONATTR);
+          ArrayUtil.fillArray(resultOut.rRoot.data, null);
+--- 199,205 ----
+          return in.rRoot.data[id];
+      }
+  
+!     public void setAttribute(Object property, int id) throws HsqlException {
+  
+          resultOut.setResultType(ResultConstants.SETSESSIONATTR);
+          ArrayUtil.fillArray(resultOut.rRoot.data, null);
+***************
+*** 335,345 ****
+          databaseID = resultIn.databaseID;
+      }
+  
+!     protected void write(Result r) throws IOException, HsqlException {
+          Result.write(r, rowOut, dataOutput);
+      }
+  
+!     protected Result read() throws IOException, HsqlException {
+  
+          Result r = Result.read(rowIn, dataInput);
+  
+--- 335,345 ----
+          databaseID = resultIn.databaseID;
+      }
+  
+!     public void write(Result r) throws IOException, HsqlException {
+          Result.write(r, rowOut, dataOutput);
+      }
+  
+!     public Result read() throws IOException, HsqlException {
+  
+          Result r = Result.read(rowIn, dataInput);
+  
+diff -crN misc/hsqldb/src/org/hsqldb/HsqlDateTime.java misc/build/hsqldb/src/org/hsqldb/HsqlDateTime.java
+*** misc/hsqldb/src/org/hsqldb/HsqlDateTime.java	2005-10-23 18:26:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HsqlDateTime.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 74,86 ****
+       * A reusable static value for today's date. Should only be accessed
+       * by getToday()
+       */
+!     private static Calendar today          = new GregorianCalendar();
+!     private static Calendar tempCal        = new GregorianCalendar();
+!     private static Calendar tempCalDefault = new GregorianCalendar();
+!     private static Calendar tempCalGMT =
+          new GregorianCalendar(TimeZone.getTimeZone("GMT"));
+!     private static Date tempDate = new Date(0);
+!     private static Date currentDate;
+  
+      static {
+          resetToday(System.currentTimeMillis());
+--- 74,86 ----
+       * A reusable static value for today's date. Should only be accessed
+       * by getToday()
+       */
+!     public static Calendar today          = new GregorianCalendar();
+!     public static Calendar tempCal        = new GregorianCalendar();
+!     public static Calendar tempCalDefault = new GregorianCalendar();
+!     public static Calendar tempCalGMT =
+          new GregorianCalendar(TimeZone.getTimeZone("GMT"));
+!     public static Date tempDate = new Date(0);
+!     public static Date currentDate;
+  
+      static {
+          resetToday(System.currentTimeMillis());
+***************
+*** 230,239 ****
+          return new Timestamp(millis);
+      }
+  
+!     private static final String sdftPattern     = "HH:mm:ss";
+!     private static final String sdfdPattern     = "yyyy-MM-dd";
+!     private static final String sdftsPattern    = "yyyy-MM-dd HH:mm:ss.";
+!     private static final String sdftsSysPattern = "yyyy-MM-dd HH:mm:ss.SSS";
+      static SimpleDateFormat     sdfd = new SimpleDateFormat(sdfdPattern);
+      static SimpleDateFormat     sdft = new SimpleDateFormat(sdftPattern);
+      static SimpleDateFormat     sdfts = new SimpleDateFormat(sdftsPattern);
+--- 230,239 ----
+          return new Timestamp(millis);
+      }
+  
+!     public static final String sdftPattern     = "HH:mm:ss";
+!     public static final String sdfdPattern     = "yyyy-MM-dd";
+!     public static final String sdftsPattern    = "yyyy-MM-dd HH:mm:ss.";
+!     public static final String sdftsSysPattern = "yyyy-MM-dd HH:mm:ss.SSS";
+      static SimpleDateFormat     sdfd = new SimpleDateFormat(sdfdPattern);
+      static SimpleDateFormat     sdft = new SimpleDateFormat(sdftPattern);
+      static SimpleDateFormat     sdfts = new SimpleDateFormat(sdftsPattern);
+***************
+*** 269,275 ****
+          }
+      }
+  
+!     private static java.util.Date sysDate = new java.util.Date();
+  
+      public static String getSytemTimeString() {
+  
+--- 269,275 ----
+          }
+      }
+  
+!     public static java.util.Date sysDate = new java.util.Date();
+  
+      public static String getSytemTimeString() {
+  
+***************
+*** 341,347 ****
+      /**
+       * resets the static reusable value today
+       */
+!     private static synchronized void resetToday(long millis) {
+  
+  //#ifdef JDBC3
+          // Use method directly
+--- 341,347 ----
+      /**
+       * resets the static reusable value today
+       */
+!     public static synchronized void resetToday(long millis) {
+  
+  //#ifdef JDBC3
+          // Use method directly
+***************
+*** 362,373 ****
+  
+      /**
+       * Sets the time in the given Calendar using the given milliseconds value; wrapper method to
+!      * allow use of more efficient JDK1.4 method on JDK1.4 (was protected in earlier versions).
+       *
+       * @param       cal                             the Calendar
+       * @param       millis                  the time value in milliseconds
+       */
+!     private static void setTimeInMillis(Calendar cal, long millis) {
+  
+  //#ifdef JDBC3
+          // Use method directly
+--- 362,373 ----
+  
+      /**
+       * Sets the time in the given Calendar using the given milliseconds value; wrapper method to
+!      * allow use of more efficient JDK1.4 method on JDK1.4 (was public in earlier versions).
+       *
+       * @param       cal                             the Calendar
+       * @param       millis                  the time value in milliseconds
+       */
+!     public static void setTimeInMillis(Calendar cal, long millis) {
+  
+  //#ifdef JDBC3
+          // Use method directly
+***************
+*** 407,413 ****
+  
+      /**
+       * Gets the time from the given Calendar as a milliseconds value; wrapper method to
+!      * allow use of more efficient JDK1.4 method on JDK1.4 (was protected in earlier versions).
+       *
+       * @param       cal                             the Calendar
+       * @return      the time value in milliseconds
+--- 407,413 ----
+  
+      /**
+       * Gets the time from the given Calendar as a milliseconds value; wrapper method to
+!      * allow use of more efficient JDK1.4 method on JDK1.4 (was public in earlier versions).
+       *
+       * @param       cal                             the Calendar
+       * @return      the time value in milliseconds
+***************
+*** 518,524 ****
+          }
+      }
+  
+!     private static final char[][] dateTokens     = {
+          {
+              'R', 'R', 'R', 'R'
+          }, {
+--- 518,524 ----
+          }
+      }
+  
+!     public static final char[][] dateTokens     = {
+          {
+              'R', 'R', 'R', 'R'
+          }, {
+***************
+*** 567,573 ****
+              'P', '.', 'M', '.'
+          }
+      };
+!     private static final String[] javaDateTokens = {
+          "yyyy", "yyyy", "yyyy", "yy", "yy", "G", "G", "G", "G", "MMM",
+          "MMMMM", "E", "w", "dd", "D", "k", "K", "K", "mm", "ss", "aaa", "aaa",
+          "aaa", "aaa"
+--- 567,573 ----
+              'P', '.', 'M', '.'
+          }
+      };
+!     public static final String[] javaDateTokens = {
+          "yyyy", "yyyy", "yyyy", "yy", "yy", "G", "G", "G", "G", "MMM",
+          "MMMMM", "E", "w", "dd", "D", "k", "K", "K", "mm", "ss", "aaa", "aaa",
+          "aaa", "aaa"
+***************
+*** 620,629 ****
+       */
+      static class Tokenizer {
+  
+!         private int     last;
+!         private int     offset;
+!         private long    state;
+!         private boolean consumed;
+  
+          public Tokenizer() {
+              reset();
+--- 620,629 ----
+       */
+      static class Tokenizer {
+  
+!         public int     last;
+!         public int     offset;
+!         public long    state;
+!         public boolean consumed;
+  
+          public Tokenizer() {
+              reset();
+***************
+*** 669,675 ****
+           * @param bit
+           * @return
+           */
+!         private boolean isZeroBit(int bit) {
+              return (state & (1L << bit)) == 0;
+          }
+  
+--- 669,675 ----
+           * @param bit
+           * @return
+           */
+!         public boolean isZeroBit(int bit) {
+              return (state & (1L << bit)) == 0;
+          }
+  
+***************
+*** 677,683 ****
+           * Sets the specified bit.
+           * @param bit
+           */
+!         private void setBit(int bit) {
+              state |= (1L << bit);
+          }
+  
+--- 677,683 ----
+           * Sets the specified bit.
+           * @param bit
+           */
+!         public void setBit(int bit) {
+              state |= (1L << bit);
+          }
+  
+diff -crN misc/hsqldb/src/org/hsqldb/HsqlException.java misc/build/hsqldb/src/org/hsqldb/HsqlException.java
+*** misc/hsqldb/src/org/hsqldb/HsqlException.java	2005-10-23 18:26:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HsqlException.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 42,50 ****
+   */
+  public class HsqlException extends Exception {
+  
+!     private String message;
+!     private String state;
+!     private int    code;
+  
+      /**
+       * @param message String
+--- 42,50 ----
+   */
+  public class HsqlException extends Exception {
+  
+!     public String message;
+!     public String state;
+!     public int    code;
+  
+      /**
+       * @param message String
+diff -crN misc/hsqldb/src/org/hsqldb/HsqlNameManager.java misc/build/hsqldb/src/org/hsqldb/HsqlNameManager.java
+*** misc/hsqldb/src/org/hsqldb/HsqlNameManager.java	2005-11-04 20:36:46.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/HsqlNameManager.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 61,74 ****
+   */
+  public class HsqlNameManager {
+  
+!     private static HsqlNameManager staticManager = new HsqlNameManager();
+  
+      static {
+          staticManager.serialNumber = Integer.MIN_VALUE;
+      }
+  
+!     private int serialNumber = 1;    // 0 is reserved in lookups
+!     private int sysNumber    = 0;
+  
+      static HsqlName newHsqlSystemObjectName(String name) {
+          return new HsqlName(staticManager, name);
+--- 61,74 ----
+   */
+  public class HsqlNameManager {
+  
+!     public static HsqlNameManager staticManager = new HsqlNameManager();
+  
+      static {
+          staticManager.serialNumber = Integer.MIN_VALUE;
+      }
+  
+!     public int serialNumber = 1;    // 0 is reserved in lookups
+!     public int sysNumber    = 0;
+  
+      static HsqlName newHsqlSystemObjectName(String name) {
+          return new HsqlName(staticManager, name);
+***************
+*** 133,153 ****
+          boolean           isNameQuoted;
+          public String     statementName;
+          public HsqlName   schema;
+!         private final int hashCode;
+  
+!         private HsqlName(HsqlNameManager man) {
+              manager  = man;
+              hashCode = manager.serialNumber++;
+          }
+  
+!         private HsqlName(HsqlNameManager man, String name, boolean isquoted) {
+  
+              this(man);
+  
+              rename(name, isquoted);
+          }
+  
+!         private HsqlName(HsqlNameManager man, String prefix, String name,
+                           boolean isquoted) {
+  
+              this(man);
+--- 133,153 ----
+          boolean           isNameQuoted;
+          public String     statementName;
+          public HsqlName   schema;
+!         public final int hashCode;
+  
+!         public HsqlName(HsqlNameManager man) {
+              manager  = man;
+              hashCode = manager.serialNumber++;
+          }
+  
+!         public HsqlName(HsqlNameManager man, String name, boolean isquoted) {
+  
+              this(man);
+  
+              rename(name, isquoted);
+          }
+  
+!         public HsqlName(HsqlNameManager man, String prefix, String name,
+                           boolean isquoted) {
+  
+              this(man);
+***************
+*** 155,161 ****
+              rename(prefix, name, isquoted);
+          }
+  
+!         private HsqlName(HsqlNameManager man, String name) {
+  
+              this(man);
+  
+--- 155,161 ----
+              rename(prefix, name, isquoted);
+          }
+  
+!         public HsqlName(HsqlNameManager man, String name) {
+  
+              this(man);
+  
+diff -crN misc/hsqldb/src/org/hsqldb/HsqlServerFactory.java misc/build/hsqldb/src/org/hsqldb/HsqlServerFactory.java
+*** misc/hsqldb/src/org/hsqldb/HsqlServerFactory.java	2005-10-23 18:26:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HsqlServerFactory.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 49,55 ****
+   */
+  public class HsqlServerFactory {
+  
+!     private HsqlServerFactory() {}
+  
+      public static HsqlSocketRequestHandler createHsqlServer(String dbFilePath,
+              boolean debugMessages, boolean silentMode) throws SQLException {
+--- 49,55 ----
+   */
+  public class HsqlServerFactory {
+  
+!     public HsqlServerFactory() {}
+  
+      public static HsqlSocketRequestHandler createHsqlServer(String dbFilePath,
+              boolean debugMessages, boolean silentMode) throws SQLException {
+diff -crN misc/hsqldb/src/org/hsqldb/HsqlSocketFactory.java misc/build/hsqldb/src/org/hsqldb/HsqlSocketFactory.java
+*** misc/hsqldb/src/org/hsqldb/HsqlSocketFactory.java	2005-10-23 18:26:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HsqlSocketFactory.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 48,55 ****
+  public class HsqlSocketFactory {
+  
+  // ----------------------------- static members ---------------------------------
+!     private static HsqlSocketFactory plainImpl;
+!     private static HsqlSocketFactory sslImpl;
+  
+  // ------------------------------ constructors ---------------------------------
+  
+--- 48,55 ----
+  public class HsqlSocketFactory {
+  
+  // ----------------------------- static members ---------------------------------
+!     public static HsqlSocketFactory plainImpl;
+!     public static HsqlSocketFactory sslImpl;
+  
+  // ------------------------------ constructors ---------------------------------
+  
+***************
+*** 57,63 ****
+       * External construction disabled.  New factory instances are retreived
+       * through the newHsqlSocketFactory method instead.
+       */
+!     protected HsqlSocketFactory() throws Exception {}
+  
+  // ------------------------- factory builder method ----------------------------
+  
+--- 57,63 ----
+       * External construction disabled.  New factory instances are retreived
+       * through the newHsqlSocketFactory method instead.
+       */
+!     public HsqlSocketFactory() throws Exception {}
+  
+  // ------------------------- factory builder method ----------------------------
+  
+***************
+*** 133,139 ****
+      }
+  
+  // ------------------------ static utility methods -----------------------------
+!     private static HsqlSocketFactory getPlainImpl() throws Exception {
+  
+          synchronized (HsqlSocketFactory.class) {
+              if (plainImpl == null) {
+--- 133,139 ----
+      }
+  
+  // ------------------------ static utility methods -----------------------------
+!     public static HsqlSocketFactory getPlainImpl() throws Exception {
+  
+          synchronized (HsqlSocketFactory.class) {
+              if (plainImpl == null) {
+***************
+*** 144,150 ****
+          return plainImpl;
+      }
+  
+!     private static HsqlSocketFactory getSSLImpl() throws Exception {
+  
+          synchronized (HsqlSocketFactory.class) {
+              if (sslImpl == null) {
+--- 144,150 ----
+          return plainImpl;
+      }
+  
+!     public static HsqlSocketFactory getSSLImpl() throws Exception {
+  
+          synchronized (HsqlSocketFactory.class) {
+              if (sslImpl == null) {
+***************
+*** 170,176 ****
+       * @throws Exception if a new secure socket factory cannot
+       *      be constructed
+       */
+!     private static HsqlSocketFactory newFactory(String implClass)
+      throws Exception {
+  
+          Class       clazz;
+--- 170,176 ----
+       * @throws Exception if a new secure socket factory cannot
+       *      be constructed
+       */
+!     public static HsqlSocketFactory newFactory(String implClass)
+      throws Exception {
+  
+          Class       clazz;
+***************
+*** 182,188 ****
+          clazz    = Class.forName(implClass);
+          ctorParm = new Class[0];
+  
+!         // protected constructor
+          ctor    = clazz.getDeclaredConstructor(ctorParm);
+          ctorArg = new Object[0];
+  
+--- 182,188 ----
+          clazz    = Class.forName(implClass);
+          ctorParm = new Class[0];
+  
+!         // public constructor
+          ctor    = clazz.getDeclaredConstructor(ctorParm);
+          ctorArg = new Object[0];
+  
+diff -crN misc/hsqldb/src/org/hsqldb/HsqlSocketFactorySecure.java misc/build/hsqldb/src/org/hsqldb/HsqlSocketFactorySecure.java
+*** misc/hsqldb/src/org/hsqldb/HsqlSocketFactorySecure.java	2005-10-23 18:26:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HsqlSocketFactorySecure.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 65,86 ****
+  // --------------------------------- members -----------------------------------
+  
+      /** The underlying socket factory implementation. */
+!     protected Object socketFactory;
+  
+      /** The underlying server socket factory implementation. */
+!     protected Object serverSocketFactory;
+  
+      /**
+       * Monitor object to guard against conncurrent modification
+       * of the underlying socket factory implementation member.
+       */
+!     protected final Object socket_factory_mutex = new Object();
+  
+      /**
+       * Monitor object to guard against concurrent modification of
+       * the underlying server socket factory implementation member.
+       */
+!     protected final Object server_socket_factory_mutex = new Object();
+  
+  // ------------------------------ constructors ---------------------------------
+  
+--- 65,86 ----
+  // --------------------------------- members -----------------------------------
+  
+      /** The underlying socket factory implementation. */
+!     public Object socketFactory;
+  
+      /** The underlying server socket factory implementation. */
+!     public Object serverSocketFactory;
+  
+      /**
+       * Monitor object to guard against conncurrent modification
+       * of the underlying socket factory implementation member.
+       */
+!     public final Object socket_factory_mutex = new Object();
+  
+      /**
+       * Monitor object to guard against concurrent modification of
+       * the underlying server socket factory implementation member.
+       */
+!     public final Object server_socket_factory_mutex = new Object();
+  
+  // ------------------------------ constructors ---------------------------------
+  
+***************
+*** 88,94 ****
+       * External construction disabled.  New factory instances are retreived
+       * through the newHsqlSocketFactory method instead.
+       */
+!     protected HsqlSocketFactorySecure() throws Exception {
+  
+          super();
+  
+--- 88,94 ----
+       * External construction disabled.  New factory instances are retreived
+       * through the newHsqlSocketFactory method instead.
+       */
+!     public HsqlSocketFactorySecure() throws Exception {
+  
+          super();
+  
+***************
+*** 174,180 ****
+          return ss;
+      }
+  
+!     private static void dump(String title, String[] as) {
+  
+          Trace.printSystemOut(title);
+          Trace.printSystemOut("----------------------------");
+--- 174,180 ----
+          return ss;
+      }
+  
+!     public static void dump(String title, String[] as) {
+  
+          Trace.printSystemOut(title);
+          Trace.printSystemOut("----------------------------");
+***************
+*** 263,269 ****
+       *      underlying factory
+       * @return the underlying javax.net.ssl.SSLServerSocketFactory
+       */
+!     protected SSLServerSocketFactory getServerSocketFactoryImpl()
+      throws Exception {
+  
+          Object factory;
+--- 263,269 ----
+       *      underlying factory
+       * @return the underlying javax.net.ssl.SSLServerSocketFactory
+       */
+!     public SSLServerSocketFactory getServerSocketFactoryImpl()
+      throws Exception {
+  
+          Object factory;
+***************
+*** 287,293 ****
+       *      underlying factory
+       * @return the underlying javax.net.ssl.SSLSocketFactory
+       */
+!     protected SSLSocketFactory getSocketFactoryImpl() throws Exception {
+  
+          Object factory;
+  
+--- 287,293 ----
+       *      underlying factory
+       * @return the underlying javax.net.ssl.SSLSocketFactory
+       */
+!     public SSLSocketFactory getSocketFactoryImpl() throws Exception {
+  
+          Object factory;
+  
+***************
+*** 313,319 ****
+       * @param session SSLSession used on the connection to host
+       * @throws Exception if the certificate chain cannot be verified
+       */
+!     protected void verify(String host, SSLSession session) throws Exception {
+  
+          X509Certificate[] chain;
+          X509Certificate   certificate;
+--- 313,319 ----
+       * @param session SSLSession used on the connection to host
+       * @throws Exception if the certificate chain cannot be verified
+       */
+!     public void verify(String host, SSLSession session) throws Exception {
+  
+          X509Certificate[] chain;
+          X509Certificate   certificate;
+diff -crN misc/hsqldb/src/org/hsqldb/HTTPClientConnection.java misc/build/hsqldb/src/org/hsqldb/HTTPClientConnection.java
+*** misc/hsqldb/src/org/hsqldb/HTTPClientConnection.java	2005-10-23 18:26:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/HTTPClientConnection.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 53,59 ****
+          super(host, port, path, database, isTLS, user, password);
+      }
+  
+!     protected void initConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {}
+  
+      public synchronized Result execute(Result r) throws HsqlException {
+--- 53,59 ----
+          super(host, port, path, database, isTLS, user, password);
+      }
+  
+!     public void initConnection(String host, int port,
+                                    boolean isTLS) throws HsqlException {}
+  
+      public synchronized Result execute(Result r) throws HsqlException {
+***************
+*** 67,73 ****
+          return result;
+      }
+  
+!     protected void write(Result r) throws IOException, HsqlException {
+  
+          rowOut.reset();
+          r.write(rowOut);
+--- 67,73 ----
+          return result;
+      }
+  
+!     public void write(Result r) throws IOException, HsqlException {
+  
+          rowOut.reset();
+          r.write(rowOut);
+***************
+*** 84,90 ****
+          dataOutput.flush();
+      }
+  
+!     protected Result read() throws IOException, HsqlException {
+  
+          // fredt - for WebServer 4 lines should be skipped
+          // for Servlet, number of lines depends on Servlet container
+--- 84,90 ----
+          dataOutput.flush();
+      }
+  
+!     public Result read() throws IOException, HsqlException {
+  
+          // fredt - for WebServer 4 lines should be skipped
+          // for Servlet, number of lines depends on Servlet container
+diff -crN misc/hsqldb/src/org/hsqldb/Index.java misc/build/hsqldb/src/org/hsqldb/Index.java
+*** misc/hsqldb/src/org/hsqldb/Index.java	2005-10-23 17:40:10.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Index.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 98,116 ****
+      static final int POINTER_INDEX = 2;
+  
+      // fields
+!     private final HsqlName indexName;
+      final boolean[]        colCheck;
+!     private final int[]    colIndex;
+!     private final int[]    colType;
+      final int[]            pkCols;
+      final int[]            pkTypes;
+!     private final boolean  isUnique;    // DDL uniqueness
+!     private final boolean  useRowId;
+      final boolean          isConstraint;
+      final boolean          isForward;
+      final boolean          isTemp;
+!     private Node           root;
+!     private int            depth;
+      final Collation        collation;
+      static IndexRowIterator emptyIterator = new IndexRowIterator(null, null,
+          null);
+--- 98,116 ----
+      static final int POINTER_INDEX = 2;
+  
+      // fields
+!     public final HsqlName indexName;
+      final boolean[]        colCheck;
+!     public final int[]    colIndex;
+!     public final int[]    colType;
+      final int[]            pkCols;
+      final int[]            pkTypes;
+!     public final boolean  isUnique;    // DDL uniqueness
+!     public final boolean  useRowId;
+      final boolean          isConstraint;
+      final boolean          isForward;
+      final boolean          isTemp;
+!     public Node           root;
+!     public int            depth;
+      final Collation        collation;
+      static IndexRowIterator emptyIterator = new IndexRowIterator(null, null,
+          null);
+***************
+*** 259,265 ****
+  
+      Node getRoot(Session session) {
+  
+!         if (isTemp) {
+              return session.getIndexRoot(indexName, onCommitPreserve);
+          } else {
+              return root;
+--- 259,265 ----
+  
+      Node getRoot(Session session) {
+  
+!         if (isTemp && session != null) {
+              return session.getIndexRoot(indexName, onCommitPreserve);
+          } else {
+              return root;
+***************
+*** 307,313 ****
+      /**
+       * Balances part of the tree after an alteration to the index.
+       */
+!     private void balance(Session session, Node x,
+                           boolean isleft) throws HsqlException {
+  
+          while (true) {
+--- 307,313 ----
+      /**
+       * Balances part of the tree after an alteration to the index.
+       */
+!     public void balance(Session session, Node x,
+                           boolean isleft) throws HsqlException {
+  
+          while (true) {
+***************
+*** 562,568 ****
+          }
+      }
+  
+!     public Row findRow(Session session, Row row) throws HsqlException {
+  
+          Node node = search(session, row);
+  
+--- 562,571 ----
+          }
+      }
+  
+!     /**
+!      * Finds an existing row
+!      */
+!     Row findRow(Session session, Row row) throws HsqlException {
+  
+          Node node = search(session, row);
+  
+***************
+*** 588,594 ****
+       * @return matching node or null
+       * @throws HsqlException
+       */
+!     private Node findNotNull(Session session, Object[] rowdata,
+                               int[] rowColMap,
+                               boolean first) throws HsqlException {
+  
+--- 591,597 ----
+       * @return matching node or null
+       * @throws HsqlException
+       */
+!     public Node findNotNull(Session session, Object[] rowdata,
+                               int[] rowColMap,
+                               boolean first) throws HsqlException {
+  
+***************
+*** 976,982 ****
+       *
+       * @throws HsqlException
+       */
+!     private Node child(Node x, boolean isleft) throws HsqlException {
+          return isleft ? x.getLeft()
+                        : x.getRight();
+      }
+--- 979,985 ----
+       *
+       * @throws HsqlException
+       */
+!     public Node child(Node x, boolean isleft) throws HsqlException {
+          return isleft ? x.getLeft()
+                        : x.getRight();
+      }
+***************
+*** 989,995 ****
+       *
+       * @throws HsqlException
+       */
+!     private void replace(Session session, Node x,
+                           Node n) throws HsqlException {
+  
+          if (x.equals(getRoot(session))) {
+--- 992,998 ----
+       *
+       * @throws HsqlException
+       */
+!     public void replace(Session session, Node x,
+                           Node n) throws HsqlException {
+  
+          if (x.equals(getRoot(session))) {
+***************
+*** 1012,1018 ****
+       *
+       * @throws HsqlException
+       */
+!     private void set(Node x, boolean isleft, Node n) throws HsqlException {
+  
+          if (isleft) {
+              x.setLeft(n);
+--- 1015,1021 ----
+       *
+       * @throws HsqlException
+       */
+!     public void set(Node x, boolean isleft, Node n) throws HsqlException {
+  
+          if (isleft) {
+              x.setLeft(n);
+***************
+*** 1034,1040 ****
+       *
+       * @throws HsqlException
+       */
+!     Node search(Session session, Row row) throws HsqlException {
+  
+          Object[] d = row.getData();
+          Node     x = getRoot(session);
+--- 1037,1043 ----
+       *
+       * @throws HsqlException
+       */
+!     public Node search(Session session, Row row) throws HsqlException {
+  
+          Object[] d = row.getData();
+          Node     x = getRoot(session);
+***************
+*** 1129,1135 ****
+       *
+       * @throws HsqlException
+       */
+!     private int compareRowForInsert(Session session, Row newRow,
+                                      Row existingRow) throws HsqlException {
+  
+          Object[] a       = newRow.getData();
+--- 1132,1138 ----
+       *
+       * @throws HsqlException
+       */
+!     public int compareRowForInsert(Session session, Row newRow,
+                                      Row existingRow) throws HsqlException {
+  
+          Object[] a       = newRow.getData();
+***************
+*** 1211,1228 ****
+          }
+      }
+  
+      static class IndexRowIterator implements RowIterator {
+  
+          Session                    session;
+          Index                      index;
+          Node                       nextnode;
+!         protected IndexRowIterator last;
+!         protected IndexRowIterator next;
+  
+          /**
+           * When session == null, rows from all sessions are returned
+           */
+!         private IndexRowIterator(Session session, Index index, Node node) {
+  
+              if (index == null) {
+                  return;
+--- 1214,1242 ----
+          }
+      }
+  
++     public RowIterator getIterator(Session session, Node x) {
++ 
++         if (x == null) {
++             return emptyIterator;
++         } else {
++             IndexRowIterator it = new IndexRowIterator(session, this, x);
++ 
++             return it;
++         }
++     }
++ 
+      static class IndexRowIterator implements RowIterator {
+  
+          Session                    session;
+          Index                      index;
+          Node                       nextnode;
+!         public IndexRowIterator last;
+!         public IndexRowIterator next;
+  
+          /**
+           * When session == null, rows from all sessions are returned
+           */
+!         public IndexRowIterator(Session session, Index index, Node node) {
+  
+              if (index == null) {
+                  return;
+diff -crN misc/hsqldb/src/org/hsqldb/jdbc/jdbcCallableStatement.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcCallableStatement.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcCallableStatement.java	2005-10-23 18:26:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcCallableStatement.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 296,306 ****
+  implements CallableStatement {
+  
+      /** parameter name => parameter index */
+!     private IntValueHashMap parameterNameMap;
+  
+      /** parameter index => registered OUT type */
+  
+!     //    private IntKeyIntValueHashMap outRegistrationMap;
+  
+      /**
+       * Constructs a new jdbcCallableStatement with the specified connection and
+--- 296,306 ----
+  implements CallableStatement {
+  
+      /** parameter name => parameter index */
+!     public IntValueHashMap parameterNameMap;
+  
+      /** parameter index => registered OUT type */
+  
+!     //    public IntKeyIntValueHashMap outRegistrationMap;
+  
+      /**
+       * Constructs a new jdbcCallableStatement with the specified connection and
+***************
+*** 385,391 ****
+       * @param i the one-based column index to check
+       * @throws SQLException if there is no such OUT or IN OUT column
+       */
+!     private void checkGetParameterIndex(int i) throws SQLException {
+  
+          checkClosed();
+  
+--- 385,391 ----
+       * @param i the one-based column index to check
+       * @throws SQLException if there is no such OUT or IN OUT column
+       */
+!     public void checkGetParameterIndex(int i) throws SQLException {
+  
+          checkClosed();
+  
+***************
+*** 421,427 ****
+       * @throws SQLException if not registered
+       */
+      /*
+!     private void checkIsRegisteredParameterIndex(int parameterIndex)
+      throws SQLException {
+  
+          int    type;
+--- 421,427 ----
+       * @throws SQLException if not registered
+       */
+      /*
+!     public void checkIsRegisteredParameterIndex(int parameterIndex)
+      throws SQLException {
+  
+          int    type;
+diff -crN misc/hsqldb/src/org/hsqldb/jdbc/jdbcColumnMetaData.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcColumnMetaData.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcColumnMetaData.java	2005-10-23 18:26:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcColumnMetaData.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 126,132 ****
+       *
+       * @return a Sring representation of this object
+       */
+!     private String toStringImpl() throws Exception {
+  
+          StringBuffer sb;
+          Field[]      fields;
+--- 126,132 ----
+       *
+       * @return a Sring representation of this object
+       */
+!     public String toStringImpl() throws Exception {
+  
+          StringBuffer sb;
+          Field[]      fields;
+diff -crN misc/hsqldb/src/org/hsqldb/jdbc/jdbcConnection.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcConnection.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcConnection.java	2005-11-06 23:05:18.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcConnection.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 422,428 ****
+      boolean isInternal;
+  
+      /** Is this connection to a network server instance. */
+!     protected boolean isNetConn;
+  
+      /**
+       * Is this connection closed?
+--- 422,428 ----
+      boolean isInternal;
+  
+      /** Is this connection to a network server instance. */
+!     public boolean isNetConn;
+  
+      /**
+       * Is this connection closed?
+***************
+*** 430,439 ****
+      boolean isClosed;
+  
+      /** The first warning in the chain. Null if there are no warnings. */
+!     private SQLWarning rootWarning;
+  
+      /** Synchronizes concurrent modification of the warning chain */
+!     private Object rootWarning_mutex = new Object();
+  
+      /**
+       * The set of open Statement objects returned by this Connection from
+--- 430,439 ----
+      boolean isClosed;
+  
+      /** The first warning in the chain. Null if there are no warnings. */
+!     public SQLWarning rootWarning;
+  
+      /** Synchronizes concurrent modification of the warning chain */
+!     public Object rootWarning_mutex = new Object();
+  
+      /**
+       * The set of open Statement objects returned by this Connection from
+***************
+*** 441,447 ****
+       * used solely for closing the statements when this Connection is closed.
+       */
+      /*
+!     private org.hsqldb.lib.HashSet statementSet =
+          new org.hsqldb.lib.HashSet();
+       */
+  
+--- 441,447 ----
+       * used solely for closing the statements when this Connection is closed.
+       */
+      /*
+!     public org.hsqldb.lib.HashSet statementSet =
+          new org.hsqldb.lib.HashSet();
+       */
+  
+***************
+*** 755,794 ****
+                      } else if (c == '"') {
+                          state = outside_escape_inside_double_quotes;
+                      } else if (c == '{') {
+-                         sb.setCharAt(i++, ' ');
+  
+!                         i = StringUtil.skipSpaces(sql, i);
+! 
+!                         if (sql.regionMatches(true, i, "fn ", 0, 3)
+!                                 || sql.regionMatches(true, i, "oj ", 0, 3)
+!                                 || sql.regionMatches(true, i, "ts ", 0, 3)) {
+!                             sb.setCharAt(i++, ' ');
+!                             sb.setCharAt(i++, ' ');
+!                         } else if (sql.regionMatches(true, i, "d ", 0, 2)
+!                                    || sql.regionMatches(true, i, "t ", 0,
+!                                                         2)) {
+!                             sb.setCharAt(i++, ' ');
+!                         } else if (sql.regionMatches(true, i, "call ", 0,
+!                                                      5)) {
+!                             i += 4;
+!                         } else if (sql.regionMatches(true, i, "?= call ", 0,
+!                                                      8)) {
+!                             sb.setCharAt(i++, ' ');
+!                             sb.setCharAt(i++, ' ');
+! 
+!                             i += 5;
+!                         } else if (sql.regionMatches(true, i, "escape ", 0,
+!                                                      7)) {
+!                             i += 6;
+!                         } else {
+!                             i--;
+! 
+!                             throw new SQLException(Trace
+!                                 .getMessage(Trace
+!                                     .jdbcConnection_nativeSQL, true, new Object[]{ sql
+!                                         .substring(i) }), "S0010", Trace
+!                                             .INVALID_JDBC_ARGUMENT);
+!                         }
+  
+                          // changed = true;
+                          nest++;
+--- 755,762 ----
+                      } else if (c == '"') {
+                          state = outside_escape_inside_double_quotes;
+                      } else if (c == '{') {
+  
+!                         i = onStartEscapeSequence(sql, sb, i);
+  
+                          // changed = true;
+                          nest++;
+***************
+*** 825,862 ****
+                          state = (nest == 0) ? outside_all
+                                              : inside_escape;
+                      } else if (c == '{') {
+-                         sb.setCharAt(i++, ' ');
+  
+!                         if (sql.regionMatches(true, i, "fn ", 0, 3)
+!                                 || sql.regionMatches(true, i, "oj ", 0, 3)
+!                                 || sql.regionMatches(true, i, "ts ", 0, 3)) {
+!                             sb.setCharAt(i++, ' ');
+!                             sb.setCharAt(i++, ' ');
+!                         } else if (sql.regionMatches(true, i, "d ", 0, 2)
+!                                    || sql.regionMatches(true, i, "t ", 0,
+!                                                         2)) {
+!                             sb.setCharAt(i++, ' ');
+!                         } else if (sql.regionMatches(true, i, "call ", 0,
+!                                                      5)) {
+!                             i += 4;
+!                         } else if (sql.regionMatches(true, i, "?= call ", 0,
+!                                                      8)) {
+!                             sb.setCharAt(i++, ' ');
+!                             sb.setCharAt(i++, ' ');
+! 
+!                             i += 5;
+!                         } else if (sql.regionMatches(true, i, "escape ", 0,
+!                                                      7)) {
+!                             i += 6;
+!                         } else {
+!                             i--;
+! 
+!                             throw new SQLException(Trace
+!                                 .getMessage(Trace
+!                                     .jdbcConnection_nativeSQL, true, new Object[]{ sql
+!                                         .substring(i) }), "S0010", Trace
+!                                             .INVALID_JDBC_ARGUMENT);
+!                         }
+  
+                          // changed = true;
+                          nest++;
+--- 793,800 ----
+                          state = (nest == 0) ? outside_all
+                                              : inside_escape;
+                      } else if (c == '{') {
+  
+!                         i = onStartEscapeSequence(sql, sb, i);
+  
+                          // changed = true;
+                          nest++;
+***************
+*** 2500,2506 ****
+       *  The default implementation simply attempts to silently {@link
+       *  #close() close()} this <code>Connection</code>
+       */
+!     protected void finalize() {
+  
+          try {
+              close();
+--- 2438,2444 ----
+       *  The default implementation simply attempts to silently {@link
+       *  #close() close()} this <code>Connection</code>
+       */
+!     public void finalize() {
+  
+          try {
+              close();
+***************
+*** 2702,2705 ****
+--- 2640,2685 ----
+                                     + e.getMessage());
+          }
+      }
++ 
++     /** is called from within nativeSQL when the start of an JDBC escape sequence is encountered
++      */
++     public int onStartEscapeSequence( String sql, StringBuffer sb, int i ) throws SQLException {
++ 
++         sb.setCharAt(i++, ' ');
++ 
++         i = StringUtil.skipSpaces(sql, i);
++ 
++         if (sql.regionMatches(true, i, "fn ", 0, 3)
++                 || sql.regionMatches(true, i, "oj ", 0, 3)
++                 || sql.regionMatches(true, i, "ts ", 0, 3)) {
++             sb.setCharAt(i++, ' ');
++             sb.setCharAt(i++, ' ');
++         } else if (sql.regionMatches(true, i, "d ", 0, 2)
++                    || sql.regionMatches(true, i, "t ", 0,
++                                         2)) {
++             sb.setCharAt(i++, ' ');
++         } else if (sql.regionMatches(true, i, "call ", 0,
++                                      5)) {
++             i += 4;
++         } else if (sql.regionMatches(true, i, "?= call ", 0,
++                                      8)) {
++             sb.setCharAt(i++, ' ');
++             sb.setCharAt(i++, ' ');
++ 
++             i += 5;
++         } else if (sql.regionMatches(true, i, "escape ", 0,
++                                      7)) {
++             i += 6;
++         } else {
++             i--;
++ 
++             throw new SQLException(Trace
++                 .getMessage(Trace
++                     .jdbcConnection_nativeSQL, true, new Object[]{ sql
++                         .substring(i) }), "S0010", Trace
++                             .INVALID_JDBC_ARGUMENT);
++         }
++ 
++         return i;
++     }
+  }
+diff -crN misc/hsqldb/src/org/hsqldb/jdbc/jdbcDatabaseMetaData.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcDatabaseMetaData.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcDatabaseMetaData.java	2005-10-23 18:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcDatabaseMetaData.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 283,301 ****
+      static final Integer INT_COLUMNS_NO_NULLS = new Integer(columnNoNulls);
+  
+      // -----------------------------------------------------------------------
+!     // private attributes
+      // -----------------------------------------------------------------------
+  
+      /**
+       * The connection this object uses to retrieve database instance-specific
+       * metadata.
+       */
+!     private jdbcConnection connection;
+  
+      /**
+       * Connection property for schema reporting.
+       */
+!     private boolean useSchemaDefault;
+  
+      /**
+       * A CSV list representing the SQL IN list to use when generating
+--- 283,301 ----
+      static final Integer INT_COLUMNS_NO_NULLS = new Integer(columnNoNulls);
+  
+      // -----------------------------------------------------------------------
+!     // public attributes
+      // -----------------------------------------------------------------------
+  
+      /**
+       * The connection this object uses to retrieve database instance-specific
+       * metadata.
+       */
+!     public jdbcConnection connection;
+  
+      /**
+       * Connection property for schema reporting.
+       */
+!     public boolean useSchemaDefault;
+  
+      /**
+       * A CSV list representing the SQL IN list to use when generating
+***************
+*** 303,309 ****
+       * <code>scope</code> argument is <code>bestRowSession</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     private static final String BRI_SESSION_SCOPE_IN_LIST = "("
+          + bestRowSession + ")";
+  
+      /**
+--- 303,309 ----
+       * <code>scope</code> argument is <code>bestRowSession</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     public static final String BRI_SESSION_SCOPE_IN_LIST = "("
+          + bestRowSession + ")";
+  
+      /**
+***************
+*** 312,318 ****
+       * <code>scope</code> argument is <code>bestRowTemporary</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     private static final String BRI_TEMPORARY_SCOPE_IN_LIST = "("
+          + bestRowTemporary + "," + bestRowTransaction + "," + bestRowSession
+          + ")";
+  
+--- 312,318 ----
+       * <code>scope</code> argument is <code>bestRowTemporary</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     public static final String BRI_TEMPORARY_SCOPE_IN_LIST = "("
+          + bestRowTemporary + "," + bestRowTransaction + "," + bestRowSession
+          + ")";
+  
+***************
+*** 322,328 ****
+       * <code>scope</code> argument is <code>bestRowTransaction</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     private static final String BRI_TRANSACTION_SCOPE_IN_LIST = "("
+          + bestRowTransaction + "," + bestRowSession + ")";
+  
+      /**
+--- 322,328 ----
+       * <code>scope</code> argument is <code>bestRowTransaction</code>.
+       * @since HSQLDB 1.7.2
+       */
+!     public static final String BRI_TRANSACTION_SCOPE_IN_LIST = "("
+          + bestRowTransaction + "," + bestRowSession + ")";
+  
+      /**
+***************
+*** 333,339 ****
+       *
+       * @since HSQLDB 1.7.2
+       */
+!     private static final String selstar = "SELECT * FROM INFORMATION_SCHEMA.";
+  
+      /**
+       * " WHERE 1=1 ". <p>
+--- 333,339 ----
+       *
+       * @since HSQLDB 1.7.2
+       */
+!     public static final String selstar = "SELECT * FROM INFORMATION_SCHEMA.";
+  
+      /**
+       * " WHERE 1=1 ". <p>
+***************
+*** 348,354 ****
+       * end of this and Presto! Everything works :-) <p>
+       * @since HSQLDB 1.7.2
+       */
+!     private static final String whereTrue = " WHERE 1=1";
+  
+      //----------------------------------------------------------------------
+      // First, a variety of minor information about the target database.
+--- 348,354 ----
+       * end of this and Presto! Everything works :-) <p>
+       * @since HSQLDB 1.7.2
+       */
+!     public static final String whereTrue = " WHERE 1=1";
+  
+      //----------------------------------------------------------------------
+      // First, a variety of minor information about the target database.
+***************
+*** 5468,5474 ****
+       *
+       *      </UL>
+       */
+!     private static String and(String id, String op, Object val) {
+  
+          // The JDBC standard for pattern arguments seems to be:
+          //
+--- 5468,5474 ----
+       *
+       *      </UL>
+       */
+!     public static String and(String id, String op, Object val) {
+  
+          // The JDBC standard for pattern arguments seems to be:
+          //
+***************
+*** 5544,5550 ****
+       * @return the result of issuing the statement
+       * @throws SQLException is a database error occurs
+       */
+!     private ResultSet execute(String sql) throws SQLException {
+  
+          // NOTE:
+          // Need to create a jdbcStatement here so jdbcResultSet can return
+--- 5544,5550 ----
+       * @return the result of issuing the statement
+       * @throws SQLException is a database error occurs
+       */
+!     public ResultSet execute(String sql) throws SQLException {
+  
+          // NOTE:
+          // Need to create a jdbcStatement here so jdbcResultSet can return
+***************
+*** 5572,5578 ****
+       *
+       *  If the <em>where</em> clause is null, it is ommited.  <p>
+       *
+!      *  It is assumed that the table name is non-null, since this is a private
+       *  method.  No check is performed. <p>
+       *
+       * @return the result of executing "SELECT * FROM " + table " " + where
+--- 5572,5578 ----
+       *
+       *  If the <em>where</em> clause is null, it is ommited.  <p>
+       *
+!      *  It is assumed that the table name is non-null, since this is a public
+       *  method.  No check is performed. <p>
+       *
+       * @return the result of executing "SELECT * FROM " + table " " + where
+***************
+*** 5580,5586 ****
+       * @param where the where condition for the select
+       * @throws SQLException if database error occurs
+       */
+!     private ResultSet executeSelect(String table,
+                                      String where) throws SQLException {
+  
+          String select = selstar + table;
+--- 5580,5586 ----
+       * @param where the where condition for the select
+       * @throws SQLException if database error occurs
+       */
+!     public ResultSet executeSelect(String table,
+                                      String where) throws SQLException {
+  
+          String select = selstar + table;
+***************
+*** 5604,5610 ****
+       *      "SELECT * FROM &lt;table&gt; WHERE 1=1"
+       * @param t the name of the table
+       */
+!     private StringBuffer toQueryPrefix(String t) {
+  
+          StringBuffer sb = new StringBuffer(255);
+  
+--- 5604,5610 ----
+       *      "SELECT * FROM &lt;table&gt; WHERE 1=1"
+       * @param t the name of the table
+       */
+!     public StringBuffer toQueryPrefix(String t) {
+  
+          StringBuffer sb = new StringBuffer(255);
+  
+***************
+*** 5620,5626 ****
+       * @return true if the argument, s, is filter paramter value that
+       *        requires a corresponding IS NULL predicate
+       */
+!     private static boolean wantsIsNull(String s) {
+          return (s != null && s.length() == 0);
+      }
+  
+--- 5620,5626 ----
+       * @return true if the argument, s, is filter paramter value that
+       *        requires a corresponding IS NULL predicate
+       */
+!     public static boolean wantsIsNull(String s) {
+          return (s != null && s.length() == 0);
+      }
+  
+***************
+*** 5629,5635 ****
+       * is present, any DatabaseMetaData call with an empty string as the
+       * schema parameter will use the default schema (noramlly "PUBLIC").
+       */
+!     private String translateSchema(String schemaName) throws SQLException {
+  
+          if (useSchemaDefault && schemaName != null
+                  && schemaName.length() == 0) {
+--- 5629,5635 ----
+       * is present, any DatabaseMetaData call with an empty string as the
+       * schema parameter will use the default schema (noramlly "PUBLIC").
+       */
+!     public String translateSchema(String schemaName) throws SQLException {
+  
+          if (useSchemaDefault && schemaName != null
+                  && schemaName.length() == 0) {
+diff -crN misc/hsqldb/src/org/hsqldb/jdbc/jdbcDataSource.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcDataSource.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcDataSource.java	2005-10-23 18:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcDataSource.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 97,123 ****
+      /**
+       * Login timeout
+       */
+!     private int loginTimeout = 0;
+  
+      /**
+       * Log writer
+       */
+!     private transient PrintWriter logWriter;
+  
+      /**
+       * Default password to use for connections
+       */
+!     private String password = "";
+  
+      /**
+       * Default user to use for connections
+       */
+!     private String user = "";
+  
+      /**
+       * Database location
+       */
+!     private String database = "";
+  
+      /**
+       * Constructor
+--- 97,123 ----
+      /**
+       * Login timeout
+       */
+!     public int loginTimeout = 0;
+  
+      /**
+       * Log writer
+       */
+!     public transient PrintWriter logWriter;
+  
+      /**
+       * Default password to use for connections
+       */
+!     public String password = "";
+  
+      /**
+       * Default user to use for connections
+       */
+!     public String user = "";
+  
+      /**
+       * Database location
+       */
+!     public String database = "";
+  
+      /**
+       * Constructor
+diff -crN misc/hsqldb/src/org/hsqldb/jdbc/jdbcParameterMetaData.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcParameterMetaData.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcParameterMetaData.java	2005-10-23 18:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcParameterMetaData.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 314,320 ****
+       * @return a String representation of this object
+       * @throws Exception if a reflection error occurs
+       */
+!     private String toStringImpl() throws Exception {
+  
+          StringBuffer sb;
+          Method[]     methods;
+--- 314,320 ----
+       * @return a String representation of this object
+       * @throws Exception if a reflection error occurs
+       */
+!     public String toStringImpl() throws Exception {
+  
+          StringBuffer sb;
+          Method[]     methods;
+diff -crN misc/hsqldb/src/org/hsqldb/jdbc/jdbcPreparedStatement.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcPreparedStatement.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcPreparedStatement.java	2005-10-23 18:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcPreparedStatement.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 207,244 ****
+  implements PreparedStatement {
+  
+      /** The parameter values for the next non-batch execution. */
+!     protected Object[] parameterValues;
+  
+      /** The SQL types of the parameters. */
+!     protected int[] parameterTypes;
+  
+      /** The (IN, IN OUT, or OUT) modes of parameters */
+!     protected int[] parameterModes;
+  
+      /** Lengths for streams. */
+!     protected int[] streamLengths;
+  
+      /** Has a stream or CLOB / BLOB parameter value. */
+!     protected boolean hasStreams;
+  
+      /**
+       * Description of result set metadata. <p>
+       */
+!     protected Result rsmdDescriptor;
+  
+      /** Description of parameter metadata. */
+!     protected Result pmdDescriptor;
+  
+      /** This object's one and one ResultSetMetaData object. */
+!     protected jdbcResultSetMetaData rsmd;
+  
+  // NOTE:  pmd is declared as Object to avoid yet another #ifdef.
+  
+      /** This object's one and only ParameterMetaData object. */
+!     protected Object pmd;
+  
+      /** The SQL character sequence that this object represents. */
+!     protected String sql;
+  
+      /**
+       * The id with which this object's corresponding
+--- 207,244 ----
+  implements PreparedStatement {
+  
+      /** The parameter values for the next non-batch execution. */
+!     public Object[] parameterValues;
+  
+      /** The SQL types of the parameters. */
+!     public int[] parameterTypes;
+  
+      /** The (IN, IN OUT, or OUT) modes of parameters */
+!     public int[] parameterModes;
+  
+      /** Lengths for streams. */
+!     public int[] streamLengths;
+  
+      /** Has a stream or CLOB / BLOB parameter value. */
+!     public boolean hasStreams;
+  
+      /**
+       * Description of result set metadata. <p>
+       */
+!     public Result rsmdDescriptor;
+  
+      /** Description of parameter metadata. */
+!     public Result pmdDescriptor;
+  
+      /** This object's one and one ResultSetMetaData object. */
+!     public jdbcResultSetMetaData rsmd;
+  
+  // NOTE:  pmd is declared as Object to avoid yet another #ifdef.
+  
+      /** This object's one and only ParameterMetaData object. */
+!     public Object pmd;
+  
+      /** The SQL character sequence that this object represents. */
+!     public String sql;
+  
+      /**
+       * The id with which this object's corresponding
+***************
+*** 247,259 ****
+       * {@link org.hsqldb.CompiledStatementManager CompiledStatementManager}
+       * object.
+       */
+!     protected int statementID;
+  
+      /**
+       * Whether this statement generates only a single row update count in
+       * response to execution.
+       */
+!     protected boolean isRowCount;
+  
+  // fredt@users 20020215 - patch 517028 by peterhudson@users - method defined
+  // fredt@users 20020215 - patch 517028 by peterhudson@users - method defined
+--- 247,259 ----
+       * {@link org.hsqldb.CompiledStatementManager CompiledStatementManager}
+       * object.
+       */
+!     public int statementID;
+  
+      /**
+       * Whether this statement generates only a single row update count in
+       * response to execution.
+       */
+!     public boolean isRowCount;
+  
+  // fredt@users 20020215 - patch 517028 by peterhudson@users - method defined
+  // fredt@users 20020215 - patch 517028 by peterhudson@users - method defined
+***************
+*** 1885,1891 ****
+       *      something other than a single row update count.
+       * @throws SQLException if the argument, yes, does not match
+       */
+!     protected void checkIsRowCount(boolean yes) throws SQLException {
+  
+          if (yes != isRowCount) {
+              int msg = yes ? Trace.JDBC_STATEMENT_NOT_ROW_COUNT
+--- 1885,1891 ----
+       *      something other than a single row update count.
+       * @throws SQLException if the argument, yes, does not match
+       */
+!     public void checkIsRowCount(boolean yes) throws SQLException {
+  
+          if (yes != isRowCount) {
+              int msg = yes ? Trace.JDBC_STATEMENT_NOT_ROW_COUNT
+***************
+*** 1902,1908 ****
+       * @param i The parameter index to check
+       * @throws SQLException if the specified parameter index is invalid
+       */
+!     protected void checkSetParameterIndex(int i) throws SQLException {
+  
+          int    mode;
+          String msg;
+--- 1902,1908 ----
+       * @param i The parameter index to check
+       * @throws SQLException if the specified parameter index is invalid
+       */
+!     public void checkSetParameterIndex(int i) throws SQLException {
+  
+          int    mode;
+          String msg;
+***************
+*** 1941,1947 ****
+       * @param o object
+       * @throws SQLException if either argument is not acceptable.
+       */
+!     private void setParameter(int i, Object o) throws SQLException {
+  
+          checkSetParameterIndex(i);
+  
+--- 1941,1947 ----
+       * @param o object
+       * @throws SQLException if either argument is not acceptable.
+       */
+!     public void setParameter(int i, Object o) throws SQLException {
+  
+          checkSetParameterIndex(i);
+  
+***************
+*** 2025,2031 ****
+       * @param value object to set
+       * @throws SQLException if either argument is not acceptable
+       */
+!     private void setIntParameter(int i, int value) throws SQLException {
+  
+          checkSetParameterIndex(i);
+  
+--- 2025,2031 ----
+       * @param value object to set
+       * @throws SQLException if either argument is not acceptable
+       */
+!     public void setIntParameter(int i, int value) throws SQLException {
+  
+          checkSetParameterIndex(i);
+  
+***************
+*** 2054,2060 ****
+       * @param value object to set
+       * @throws SQLException if either argument is not acceptable
+       */
+!     private void setLongParameter(int i, long value) throws SQLException {
+  
+          checkSetParameterIndex(i);
+  
+--- 2054,2060 ----
+       * @param value object to set
+       * @throws SQLException if either argument is not acceptable
+       */
+!     public void setLongParameter(int i, long value) throws SQLException {
+  
+          checkSetParameterIndex(i);
+  
+diff -crN misc/hsqldb/src/org/hsqldb/jdbc/jdbcResultSet.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcResultSet.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcResultSet.java	2005-10-23 17:40:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcResultSet.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 412,442 ****
+      /**
+       * The current record containing the data for the row
+       */
+!     private Record nCurrent;
+  
+      /** The row upon which this ResultSet is currently positioned. */
+!     private int iCurrentRow;
+  
+      /** When the result of updating the database, the number of updated rows. */
+!     private int iUpdateCount;
+  
+      /** Is current row before the first row? */
+!     private boolean bInit;    // false if before first row
+  
+      /** How many columns does this ResultSet have? */
+      int iColumnCount;
+  
+      /** Did the last getXXX method encounter a null value? */
+!     private boolean bWasNull;
+  
+      /** The ResultSetMetaData object for this ResultSet */
+!     private ResultSetMetaData rsmd;
+  
+      /** Properties of this ResultSet's parent Connection. */
+!     private HsqlProperties connProperties;
+  
+      /** is the connection via network */
+!     private boolean isNetConn;
+  
+      /**
+       * The Statement that generated this result. Null if the result is
+--- 412,442 ----
+      /**
+       * The current record containing the data for the row
+       */
+!     public Record nCurrent;
+  
+      /** The row upon which this ResultSet is currently positioned. */
+!     public int iCurrentRow;
+  
+      /** When the result of updating the database, the number of updated rows. */
+!     public int iUpdateCount;
+  
+      /** Is current row before the first row? */
+!     public boolean bInit;    // false if before first row
+  
+      /** How many columns does this ResultSet have? */
+      int iColumnCount;
+  
+      /** Did the last getXXX method encounter a null value? */
+!     public boolean bWasNull;
+  
+      /** The ResultSetMetaData object for this ResultSet */
+!     public ResultSetMetaData rsmd;
+  
+      /** Properties of this ResultSet's parent Connection. */
+!     public HsqlProperties connProperties;
+  
+      /** is the connection via network */
+!     public boolean isNetConn;
+  
+      /**
+       * The Statement that generated this result. Null if the result is
+***************
+*** 4862,4868 ****
+       *
+       * @throws  SQLException when no row data is available
+       */
+!     private void checkAvailable() throws SQLException {
+  
+          if (rResult == null ||!bInit || nCurrent == null) {
+              throw Util.sqlException(Trace.NO_DATA_IS_AVAILABLE);
+--- 4862,4868 ----
+       *
+       * @throws  SQLException when no row data is available
+       */
+!     public void checkAvailable() throws SQLException {
+  
+          if (rResult == null ||!bInit || nCurrent == null) {
+              throw Util.sqlException(Trace.NO_DATA_IS_AVAILABLE);
+***************
+*** 4874,4880 ****
+       *
+       * @throws SQLException when this result set is closed
+       */
+!     private void checkClosed() throws SQLException {
+  
+          if (rResult == null
+                  || (sqlStatement != null && sqlStatement.isClosed)) {
+--- 4874,4880 ----
+       *
+       * @throws SQLException when this result set is closed
+       */
+!     public void checkClosed() throws SQLException {
+  
+          if (rResult == null
+                  || (sqlStatement != null && sqlStatement.isClosed)) {
+***************
+*** 4901,4907 ****
+       *
+       * @param  o the Object to track
+       */
+!     private boolean checkNull(Object o) {
+  
+          if (o == null) {
+              bWasNull = true;
+--- 4901,4907 ----
+       *
+       * @param  o the Object to track
+       */
+!     public boolean checkNull(Object o) {
+  
+          if (o == null) {
+              bWasNull = true;
+***************
+*** 4929,4935 ****
+       * @throws SQLException when there is no data, the column index is
+       *    invalid, or the conversion cannot be performed
+       */
+!     private Object getColumnInType(int columnIndex,
+                                     int type) throws SQLException {
+  
+          checkAvailable();
+--- 4929,4935 ----
+       * @throws SQLException when there is no data, the column index is
+       *    invalid, or the conversion cannot be performed
+       */
+!     public Object getColumnInType(int columnIndex,
+                                     int type) throws SQLException {
+  
+          checkAvailable();
+***************
+*** 4950,4956 ****
+          }
+  
+          if (t != type) {
+!             if (o instanceof Binary) {
+                  throw Util.sqlException(Trace.WRONG_DATA_TYPE);
+              }
+  
+--- 4950,4956 ----
+          }
+  
+          if (t != type) {
+!             if (o instanceof Binary && type != Types.CHAR) {
+                  throw Util.sqlException(Trace.WRONG_DATA_TYPE);
+              }
+  
+diff -crN misc/hsqldb/src/org/hsqldb/jdbc/jdbcResultSetMetaData.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcResultSetMetaData.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcResultSetMetaData.java	2005-10-23 18:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcResultSetMetaData.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 97,118 ****
+       * An array of objects, each of which represents the reported attributes
+       * for  a single column of this object's parent ResultSet.
+       */
+!     private jdbcColumnMetaData[] columnMetaData;
+  
+      /** The number of columns in this object's parent ResultSet. */
+!     private int columnCount;
+  
+      /**
+       * Whether to use the underlying column name or label when reporting
+       * getColumnName().
+       */
+!     private boolean useColumnName;
+  
+      /**
+       * If true, then timings for init() are printed
+       * to the console.
+       */
+!     private static final boolean TRACE = false;
+  
+      /**
+       * Constructs a new jdbcResultSetMetaData object from the specified
+--- 97,118 ----
+       * An array of objects, each of which represents the reported attributes
+       * for  a single column of this object's parent ResultSet.
+       */
+!     public jdbcColumnMetaData[] columnMetaData;
+  
+      /** The number of columns in this object's parent ResultSet. */
+!     public int columnCount;
+  
+      /**
+       * Whether to use the underlying column name or label when reporting
+       * getColumnName().
+       */
+!     public boolean useColumnName;
+  
+      /**
+       * If true, then timings for init() are printed
+       * to the console.
+       */
+!     public static final boolean TRACE = false;
+  
+      /**
+       * Constructs a new jdbcResultSetMetaData object from the specified
+***************
+*** 1137,1143 ****
+       * @throws SQLException when this object's parent ResultSet has
+       *      no such column
+       */
+!     private void checkColumn(int column) throws SQLException {
+  
+          if (column < 1 || column > columnCount) {
+              throw Util.sqlException(Trace.COLUMN_NOT_FOUND,
+--- 1137,1143 ----
+       * @throws SQLException when this object's parent ResultSet has
+       *      no such column
+       */
+!     public void checkColumn(int column) throws SQLException {
+  
+          if (column < 1 || column > columnCount) {
+              throw Util.sqlException(Trace.COLUMN_NOT_FOUND,
+diff -crN misc/hsqldb/src/org/hsqldb/jdbc/jdbcStatement.java misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcStatement.java
+*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcStatement.java	2005-10-23 18:26:24.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcStatement.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 136,160 ****
+      volatile boolean isClosed;
+  
+      /** Is escape processing enabled? */
+!     private boolean isEscapeProcessing = true;
+  
+      /** The connection used to execute this statement. */
+!     protected jdbcConnection connection;
+  
+      /** The maximum number of rows to generate when executing this statement. */
+!     protected int maxRows;
+  
+      /** The result of executing this statement. */
+!     protected Result resultIn;
+  
+      /** The result set type obtained by executing this statement. */
+!     protected int rsType = jdbcResultSet.TYPE_FORWARD_ONLY;
+  
+      /** Used by this statement to communicate non-batched requests. */
+!     protected Result resultOut = new Result(ResultConstants.SQLEXECDIRECT);
+  
+      /** Use by this statement to communicate batched execution requests */
+!     protected Result batchResultOut = null;
+  
+      // boucherb@users
+      // NOTE:
+--- 136,160 ----
+      volatile boolean isClosed;
+  
+      /** Is escape processing enabled? */
+!     public boolean isEscapeProcessing = true;
+  
+      /** The connection used to execute this statement. */
+!     public jdbcConnection connection;
+  
+      /** The maximum number of rows to generate when executing this statement. */
+!     public int maxRows;
+  
+      /** The result of executing this statement. */
+!     public Result resultIn;
+  
+      /** The result set type obtained by executing this statement. */
+!     public int rsType = jdbcResultSet.TYPE_FORWARD_ONLY;
+  
+      /** Used by this statement to communicate non-batched requests. */
+!     public Result resultOut = new Result(ResultConstants.SQLEXECDIRECT);
+  
+      /** Use by this statement to communicate batched execution requests */
+!     public Result batchResultOut = null;
+  
+      // boucherb@users
+      // NOTE:
+***************
+*** 1559,1565 ****
+       * @param sql a character sequence representing the SQL to be executed
+       * @throws SQLException when a database access error occurs
+       */
+!     private void fetchResult(String sql) throws SQLException {
+  
+          if (isEscapeProcessing) {
+              sql = connection.nativeSQL(sql);
+--- 1559,1565 ----
+       * @param sql a character sequence representing the SQL to be executed
+       * @throws SQLException when a database access error occurs
+       */
+!     public void fetchResult(String sql) throws SQLException {
+  
+          if (isEscapeProcessing) {
+              sql = connection.nativeSQL(sql);
+diff -crN misc/hsqldb/src/org/hsqldb/lib/ArrayUtil.java misc/build/hsqldb/src/org/hsqldb/lib/ArrayUtil.java
+*** misc/hsqldb/src/org/hsqldb/lib/ArrayUtil.java	2005-10-29 10:51:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/ArrayUtil.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 51,57 ****
+      public static final int        CLASS_CODE_OBJECT  = 'L';
+      public static final int        CLASS_CODE_SHORT   = 'S';
+      public static final int        CLASS_CODE_BOOLEAN = 'Z';
+!     private static IntValueHashMap classCodeMap       = new IntValueHashMap();
+  
+      static {
+          classCodeMap.put(byte.class, ArrayUtil.CLASS_CODE_BYTE);
+--- 51,57 ----
+      public static final int        CLASS_CODE_OBJECT  = 'L';
+      public static final int        CLASS_CODE_SHORT   = 'S';
+      public static final int        CLASS_CODE_BOOLEAN = 'Z';
+!     public static IntValueHashMap classCodeMap       = new IntValueHashMap();
+  
+      static {
+          classCodeMap.put(byte.class, ArrayUtil.CLASS_CODE_BYTE);
+diff -crN misc/hsqldb/src/org/hsqldb/lib/BaseList.java misc/build/hsqldb/src/org/hsqldb/lib/BaseList.java
+*** misc/hsqldb/src/org/hsqldb/lib/BaseList.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/BaseList.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 42,48 ****
+   */
+  abstract class BaseList {
+  
+!     protected int elementCount;
+  
+      abstract Object get(int index);
+  
+--- 42,48 ----
+   */
+  abstract class BaseList {
+  
+!     public int elementCount;
+  
+      abstract Object get(int index);
+  
+***************
+*** 135,141 ****
+          return new BaseListIterator();
+      }
+  
+!     private class BaseListIterator implements Iterator {
+  
+          int     counter = 0;
+          boolean removed;
+--- 135,141 ----
+          return new BaseListIterator();
+      }
+  
+!     public class BaseListIterator implements Iterator {
+  
+          int     counter = 0;
+          boolean removed;
+diff -crN misc/hsqldb/src/org/hsqldb/lib/DoubleIntIndex.java misc/build/hsqldb/src/org/hsqldb/lib/DoubleIntIndex.java
+*** misc/hsqldb/src/org/hsqldb/lib/DoubleIntIndex.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/DoubleIntIndex.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 52,68 ****
+   */
+  public class DoubleIntIndex implements IntLookup {
+  
+!     private int           count = 0;
+!     private int           capacity;
+!     private boolean       sorted       = true;
+!     private boolean       sortOnValues = true;
+!     private boolean       hasChanged;
+!     private final boolean fixedSize;
+!     private int[]         keys;
+!     private int[]         values;
+  
+  //
+!     private int targetSearchValue;
+  
+      public DoubleIntIndex(int capacity, boolean fixedSize) {
+  
+--- 52,68 ----
+   */
+  public class DoubleIntIndex implements IntLookup {
+  
+!     public int           count = 0;
+!     public int           capacity;
+!     public boolean       sorted       = true;
+!     public boolean       sortOnValues = true;
+!     public boolean       hasChanged;
+!     public final boolean fixedSize;
+!     public int[]         keys;
+!     public int[]         values;
+  
+  //
+!     public int targetSearchValue;
+  
+      public DoubleIntIndex(int capacity, boolean fixedSize) {
+  
+***************
+*** 395,401 ****
+       * or -1
+       * @return index or -1 if not found
+       */
+!     private int binaryFirstSearch() {
+  
+          int low     = 0;
+          int high    = count;
+--- 395,401 ----
+       * or -1
+       * @return index or -1 if not found
+       */
+!     public int binaryFirstSearch() {
+  
+          int low     = 0;
+          int high    = count;
+***************
+*** 425,431 ****
+       * Returns the index of the lowest element > the given search target
+       *     @return the index
+       */
+!     private int binaryGreaterSearch() {
+  
+          int low     = 0;
+          int high    = count;
+--- 425,431 ----
+       * Returns the index of the lowest element > the given search target
+       *     @return the index
+       */
+!     public int binaryGreaterSearch() {
+  
+          int low     = 0;
+          int high    = count;
+***************
+*** 452,458 ****
+       * or count
+       *     @return the index
+       */
+!     private int binarySlotSearch() {
+  
+          int low     = 0;
+          int high    = count;
+--- 452,458 ----
+       * or count
+       *     @return the index
+       */
+!     public int binarySlotSearch() {
+  
+          int low     = 0;
+          int high    = count;
+***************
+*** 478,484 ****
+       * or count or -1 if target is found
+       * @return the index
+       */
+!     private int binaryEmptySlotSearch() {
+  
+          int low     = 0;
+          int high    = count;
+--- 478,484 ----
+       * or count or -1 if target is found
+       * @return the index
+       */
+!     public int binaryEmptySlotSearch() {
+  
+          int low     = 0;
+          int high    = count;
+***************
+*** 501,507 ****
+          return low;
+      }
+  
+!     private synchronized void fastQuickSort() {
+  
+          quickSort(0, count - 1);
+          insertionSort(0, count - 1);
+--- 501,507 ----
+          return low;
+      }
+  
+!     public synchronized void fastQuickSort() {
+  
+          quickSort(0, count - 1);
+          insertionSort(0, count - 1);
+***************
+*** 509,515 ****
+          sorted = true;
+      }
+  
+!     private void quickSort(int l, int r) {
+  
+          int M = 4;
+          int i;
+--- 509,515 ----
+          sorted = true;
+      }
+  
+!     public void quickSort(int l, int r) {
+  
+          int M = 4;
+          int i;
+***************
+*** 556,562 ****
+          }
+      }
+  
+!     private void insertionSort(int lo0, int hi0) {
+  
+          int i;
+          int j;
+--- 556,562 ----
+          }
+      }
+  
+!     public void insertionSort(int lo0, int hi0) {
+  
+          int i;
+          int j;
+***************
+*** 574,580 ****
+          }
+      }
+  
+!     private void moveAndInsertRow(int i, int j) {
+  
+          int col1 = keys[i];
+          int col2 = values[i];
+--- 574,580 ----
+          }
+      }
+  
+!     public void moveAndInsertRow(int i, int j) {
+  
+          int col1 = keys[i];
+          int col2 = values[i];
+***************
+*** 585,598 ****
+          values[j] = col2;
+      }
+  
+!     private void doubleCapacity() {
+  
+          keys     = (int[]) ArrayUtil.resizeArray(keys, capacity * 2);
+          values   = (int[]) ArrayUtil.resizeArray(values, capacity * 2);
+          capacity *= 2;
+      }
+  
+!     private void swap(int i1, int i2) {
+  
+          int col1 = keys[i1];
+          int col2 = values[i1];
+--- 585,598 ----
+          values[j] = col2;
+      }
+  
+!     public void doubleCapacity() {
+  
+          keys     = (int[]) ArrayUtil.resizeArray(keys, capacity * 2);
+          values   = (int[]) ArrayUtil.resizeArray(values, capacity * 2);
+          capacity *= 2;
+      }
+  
+!     public void swap(int i1, int i2) {
+  
+          int col1 = keys[i1];
+          int col2 = values[i1];
+***************
+*** 603,609 ****
+          values[i2] = col2;
+      }
+  
+!     private void moveRows(int fromIndex, int toIndex, int rows) {
+          System.arraycopy(keys, fromIndex, keys, toIndex, rows);
+          System.arraycopy(values, fromIndex, values, toIndex, rows);
+      }
+--- 603,609 ----
+          values[i2] = col2;
+      }
+  
+!     public void moveRows(int fromIndex, int toIndex, int rows) {
+          System.arraycopy(keys, fromIndex, keys, toIndex, rows);
+          System.arraycopy(values, fromIndex, values, toIndex, rows);
+      }
+***************
+*** 631,637 ****
+       * @param i the index
+       * @return -1, 0 or +1
+       */
+!     private int compare(int i) {
+  
+          if (sortOnValues) {
+              if (targetSearchValue > values[i]) {
+--- 631,637 ----
+       * @param i the index
+       * @return -1, 0 or +1
+       */
+!     public int compare(int i) {
+  
+          if (sortOnValues) {
+              if (targetSearchValue > values[i]) {
+***************
+*** 668,674 ****
+       * @param j the second index
+       * @return true or false
+       */
+!     private boolean lessThan(int i, int j) {
+  
+          if (sortOnValues) {
+              if (values[i] < values[j]) {
+--- 668,674 ----
+       * @param j the second index
+       * @return true or false
+       */
+!     public boolean lessThan(int i, int j) {
+  
+          if (sortOnValues) {
+              if (values[i] < values[j]) {
+diff -crN misc/hsqldb/src/org/hsqldb/lib/HashMappedList.java misc/build/hsqldb/src/org/hsqldb/lib/HashMappedList.java
+*** misc/hsqldb/src/org/hsqldb/lib/HashMappedList.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HashMappedList.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 182,188 ****
+          return getLookup(key, key.hashCode());
+      }
+  
+!     private void checkRange(int i) {
+  
+          if (i < 0 || i >= size()) {
+              throw new IndexOutOfBoundsException();
+--- 182,188 ----
+          return getLookup(key, key.hashCode());
+      }
+  
+!     public void checkRange(int i) {
+  
+          if (i < 0 || i >= size()) {
+              throw new IndexOutOfBoundsException();
+diff -crN misc/hsqldb/src/org/hsqldb/lib/HsqlArrayHeap.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlArrayHeap.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlArrayHeap.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlArrayHeap.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 43,51 ****
+  public class HsqlArrayHeap implements HsqlHeap {
+  
+  // --------------------------------- members -----------------------------------
+!     protected ObjectComparator oc;
+!     protected int              count;
+!     protected Object[]         heap;
+  
+  // ------------------------------ constructors ---------------------------------
+  
+--- 43,51 ----
+  public class HsqlArrayHeap implements HsqlHeap {
+  
+  // --------------------------------- members -----------------------------------
+!     public ObjectComparator oc;
+!     public int              count;
+!     public Object[]         heap;
+  
+  // ------------------------------ constructors ---------------------------------
+  
+***************
+*** 311,317 ****
+  //        System.arraycopy(oldheap, 0, heap, 0, count);
+  //    }
+  // -------------------- internal implementation methods ------------------------
+!     private void increaseCapacity() {
+  
+          Object[] oldheap;
+  
+--- 311,317 ----
+  //        System.arraycopy(oldheap, 0, heap, 0, count);
+  //    }
+  // -------------------- internal implementation methods ------------------------
+!     public void increaseCapacity() {
+  
+          Object[] oldheap;
+  
+diff -crN misc/hsqldb/src/org/hsqldb/lib/HsqlArrayList.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlArrayList.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlArrayList.java	2005-10-23 17:40:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlArrayList.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 47,58 ****
+  
+  //fredt@users
+  /*
+!     private static Reporter reporter = new Reporter();
+  
+!     private static class Reporter {
+  
+!         private static int initCounter   = 0;
+!         private static int updateCounter = 0;
+  
+          Reporter() {
+  
+--- 47,58 ----
+  
+  //fredt@users
+  /*
+!     public static Reporter reporter = new Reporter();
+  
+!     public static class Reporter {
+  
+!         public static int initCounter   = 0;
+!         public static int updateCounter = 0;
+  
+          Reporter() {
+  
+***************
+*** 61,67 ****
+              } catch (SecurityException e) {}
+          }
+  
+!         protected void finalize() {
+  
+              System.out.println("HsqlArrayList init count: " + initCounter);
+              System.out.println("HsqlArrayList update count: "
+--- 61,67 ----
+              } catch (SecurityException e) {}
+          }
+  
+!         public void finalize() {
+  
+              System.out.println("HsqlArrayList init count: " + initCounter);
+              System.out.println("HsqlArrayList update count: "
+***************
+*** 69,78 ****
+          }
+      }
+  */
+!     private static final int   DEFAULT_INITIAL_CAPACITY = 10;
+!     private static final float DEFAULT_RESIZE_FACTOR    = 2.0f;
+!     private Object[]           elementData;
+!     private boolean            minimizeOnClear;
+  
+      /** Creates a new instance of HsqlArrayList */
+      public HsqlArrayList() {
+--- 69,78 ----
+          }
+      }
+  */
+!     public static final int   DEFAULT_INITIAL_CAPACITY = 10;
+!     public static final float DEFAULT_RESIZE_FACTOR    = 2.0f;
+!     public Object[]           elementData;
+!     public boolean            minimizeOnClear;
+  
+      /** Creates a new instance of HsqlArrayList */
+      public HsqlArrayList() {
+***************
+*** 236,242 ****
+          return elementCount;
+      }
+  
+!     private void increaseCapacity() {
+  
+          int baseSize = elementData.length == 0 ? 1
+                                                 : elementData.length;
+--- 236,242 ----
+          return elementCount;
+      }
+  
+!     public void increaseCapacity() {
+  
+          int baseSize = elementData.length == 0 ? 1
+                                                 : elementData.length;
+***************
+*** 259,265 ****
+  
+          Enumeration en = new Enumeration() {
+  
+!             private int pos = 0;
+  
+              public Object nextElement() {
+  
+--- 259,265 ----
+  
+          Enumeration en = new Enumeration() {
+  
+!             public int pos = 0;
+  
+              public Object nextElement() {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/lib/HsqlByteArrayInputStream.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlByteArrayInputStream.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlByteArrayInputStream.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlByteArrayInputStream.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 47,56 ****
+  public class HsqlByteArrayInputStream extends InputStream
+  implements DataInput {
+  
+!     protected byte[] buf;
+!     protected int    pos;
+!     protected int    mark = 0;
+!     protected int    count;
+  
+      public HsqlByteArrayInputStream(byte[] buf) {
+  
+--- 47,56 ----
+  public class HsqlByteArrayInputStream extends InputStream
+  implements DataInput {
+  
+!     public byte[] buf;
+!     public int    pos;
+!     public int    mark = 0;
+!     public int    count;
+  
+      public HsqlByteArrayInputStream(byte[] buf) {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/lib/HsqlByteArrayOutputStream.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlByteArrayOutputStream.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlByteArrayOutputStream.java	2005-10-23 17:40:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlByteArrayOutputStream.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 48,55 ****
+  public class HsqlByteArrayOutputStream extends java.io.OutputStream
+  implements DataOutput {
+  
+!     protected byte[] buf;
+!     protected int    count;
+  
+      public HsqlByteArrayOutputStream() {
+          this(128);
+--- 48,55 ----
+  public class HsqlByteArrayOutputStream extends java.io.OutputStream
+  implements DataOutput {
+  
+!     public byte[] buf;
+!     public int    count;
+  
+      public HsqlByteArrayOutputStream() {
+          this(128);
+***************
+*** 251,257 ****
+          return this.buf;
+      }
+  
+!     protected void ensureRoom(int extra) {
+  
+          int newcount = count + extra;
+  
+--- 251,257 ----
+          return this.buf;
+      }
+  
+!     public void ensureRoom(int extra) {
+  
+          int newcount = count + extra;
+  
+***************
+*** 265,271 ****
+          }
+      }
+  
+!     protected void reset(int newSize) {
+  
+          count = 0;
+  
+--- 265,271 ----
+          }
+      }
+  
+!     public void reset(int newSize) {
+  
+          count = 0;
+  
+diff -crN misc/hsqldb/src/org/hsqldb/lib/HsqlDeque.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlDeque.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlDeque.java	2005-10-23 17:40:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlDeque.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 47,59 ****
+   */
+  public class HsqlDeque extends BaseList implements HsqlList {
+  
+!     private Object[] list;
+!     private int      firstindex = 0;    // index of first list element
+!     private int      endindex   = 0;    // index of last list element + 1
+  
+      // can grow to fill list
+      // if elementCount == 0 then firstindex == endindex
+!     private static final int DEFAULT_INITIAL_CAPACITY = 10;
+  
+      public HsqlDeque() {
+          list = new Object[DEFAULT_INITIAL_CAPACITY];
+--- 47,59 ----
+   */
+  public class HsqlDeque extends BaseList implements HsqlList {
+  
+!     public Object[] list;
+!     public int      firstindex = 0;    // index of first list element
+!     public int      endindex   = 0;    // index of last list element + 1
+  
+      // can grow to fill list
+      // if elementCount == 0 then firstindex == endindex
+!     public static final int DEFAULT_INITIAL_CAPACITY = 10;
+  
+      public HsqlDeque() {
+          list = new Object[DEFAULT_INITIAL_CAPACITY];
+***************
+*** 242,248 ****
+          return value;
+      }
+  
+!     private int getInternalIndex(int i) throws IndexOutOfBoundsException {
+  
+          if (i < 0 || i >= elementCount) {
+              throw new IndexOutOfBoundsException();
+--- 242,248 ----
+          return value;
+      }
+  
+!     public int getInternalIndex(int i) throws IndexOutOfBoundsException {
+  
+          if (i < 0 || i >= elementCount) {
+              throw new IndexOutOfBoundsException();
+***************
+*** 257,263 ****
+          return index;
+      }
+  
+!     private void resetCapacity() {
+  
+          if (elementCount < list.length) {
+              return;
+--- 257,263 ----
+          return index;
+      }
+  
+!     public void resetCapacity() {
+  
+          if (elementCount < list.length) {
+              return;
+diff -crN misc/hsqldb/src/org/hsqldb/lib/HsqlLinkedList.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlLinkedList.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlLinkedList.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlLinkedList.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 46,55 ****
+       * A reference to the head of the list.  It is a dummy head (that is, the
+       * Node for index 0 is actually first.next).
+       */
+!     private Node first;
+  
+      /** A reference to the tail of the list */
+!     private Node last;
+  
+      /**
+       * Creates a new instance of HsqlLinkedList.
+--- 46,55 ----
+       * A reference to the head of the list.  It is a dummy head (that is, the
+       * Node for index 0 is actually first.next).
+       */
+!     public Node first;
+  
+      /** A reference to the tail of the list */
+!     public Node last;
+  
+      /**
+       * Creates a new instance of HsqlLinkedList.
+***************
+*** 197,203 ****
+       * index within the list (0 &lt;= <code>index</code> &lt;
+       * <code>size</code>).
+       */
+!     protected final Node getInternal(int index) {
+  
+          //Check preconditions for the index variable
+          if (index >= size()) {
+--- 197,203 ----
+       * index within the list (0 &lt;= <code>index</code> &lt;
+       * <code>size</code>).
+       */
+!     public final Node getInternal(int index) {
+  
+          //Check preconditions for the index variable
+          if (index >= size()) {
+***************
+*** 232,238 ****
+       * jcpeck@users
+       * @version 05/24/2002
+       */
+!     private static class Node {
+  
+          public Node   next;
+          public Object data;
+--- 232,238 ----
+       * jcpeck@users
+       * @version 05/24/2002
+       */
+!     public static class Node {
+  
+          public Node   next;
+          public Object data;
+diff -crN misc/hsqldb/src/org/hsqldb/lib/HsqlTaskQueue.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlTaskQueue.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlTaskQueue.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlTaskQueue.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 43,52 ****
+  public class HsqlTaskQueue {
+  
+      /** The thread used to process commands */
+!     protected Thread taskRunnerThread;
+  
+      /** Special queue element to signal termination */
+!     protected static final Runnable SHUTDOWNTASK = new Runnable() {
+          public void run() {}
+      };
+  
+--- 43,52 ----
+  public class HsqlTaskQueue {
+  
+      /** The thread used to process commands */
+!     public Thread taskRunnerThread;
+  
+      /** Special queue element to signal termination */
+!     public static final Runnable SHUTDOWNTASK = new Runnable() {
+          public void run() {}
+      };
+  
+***************
+*** 55,73 ****
+       *
+       * Once set true, stays true forever
+       */
+!     protected volatile boolean isShutdown;
+  
+      public synchronized Thread getTaskRunnerThread() {
+          return taskRunnerThread;
+      }
+  
+!     protected synchronized void clearThread() {
+          taskRunnerThread = null;
+      }
+  
+!     protected final HsqlDeque queue = new HsqlDeque();
+  
+!     protected class TaskRunner implements Runnable {
+  
+          public void run() {
+  
+--- 55,73 ----
+       *
+       * Once set true, stays true forever
+       */
+!     public volatile boolean isShutdown;
+  
+      public synchronized Thread getTaskRunnerThread() {
+          return taskRunnerThread;
+      }
+  
+!     public synchronized void clearThread() {
+          taskRunnerThread = null;
+      }
+  
+!     public final HsqlDeque queue = new HsqlDeque();
+  
+!     public class TaskRunner implements Runnable {
+  
+          public void run() {
+  
+***************
+*** 101,107 ****
+          }
+      }
+  
+!     protected final TaskRunner taskRunner = new TaskRunner();
+  
+      public HsqlTaskQueue() {}
+  
+--- 101,107 ----
+          }
+      }
+  
+!     public final TaskRunner taskRunner = new TaskRunner();
+  
+      public HsqlTaskQueue() {}
+  
+diff -crN misc/hsqldb/src/org/hsqldb/lib/HsqlThreadFactory.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlThreadFactory.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlThreadFactory.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlThreadFactory.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 47,53 ****
+       * The factory implementation.  Typically, this will be the
+       * HsqlThreadFactory object itself.
+       */
+!     protected ThreadFactory factory;
+  
+      /**
+       * Constructs a new HsqlThreadFactory that uses itself as the factory
+--- 47,53 ----
+       * The factory implementation.  Typically, this will be the
+       * HsqlThreadFactory object itself.
+       */
+!     public ThreadFactory factory;
+  
+      /**
+       * Constructs a new HsqlThreadFactory that uses itself as the factory
+diff -crN misc/hsqldb/src/org/hsqldb/lib/HsqlTimer.java misc/build/hsqldb/src/org/hsqldb/lib/HsqlTimer.java
+*** misc/hsqldb/src/org/hsqldb/lib/HsqlTimer.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/HsqlTimer.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 47,63 ****
+  public class HsqlTimer implements ObjectComparator {
+  
+      /** The priority queue for the scheduled tasks. */
+!     protected final TaskQueue taskQueue = new TaskQueue(16,
+          (ObjectComparator) this);
+  
+      /** The inner runnable that executes tasks in the background thread. */
+!     protected final TaskRunner taskRunner = new TaskRunner();
+  
+      /** The background thread. */
+!     protected Thread taskRunnerThread;
+  
+      /** The factory that procduces the background threads. */
+!     protected ThreadFactory threadFactory;
+  
+      /**
+       * Constructs a new HsqlTimer using the default thread factory
+--- 47,63 ----
+  public class HsqlTimer implements ObjectComparator {
+  
+      /** The priority queue for the scheduled tasks. */
+!     public final TaskQueue taskQueue = new TaskQueue(16,
+          (ObjectComparator) this);
+  
+      /** The inner runnable that executes tasks in the background thread. */
+!     public final TaskRunner taskRunner = new TaskRunner();
+  
+      /** The background thread. */
+!     public Thread taskRunnerThread;
+  
+      /** The factory that procduces the background threads. */
+!     public ThreadFactory threadFactory;
+  
+      /**
+       * Constructs a new HsqlTimer using the default thread factory
+***************
+*** 359,365 ****
+       * @param b if true, use fixed rate else use fixed period
+       * @return a reference to the scheduled task
+       */
+!     protected Task addTask(long n, Runnable r, long p, boolean b) {
+  
+          Task task;
+  
+--- 359,365 ----
+       * @param b if true, use fixed rate else use fixed period
+       * @return a reference to the scheduled task
+       */
+!     public Task addTask(long n, Runnable r, long p, boolean b) {
+  
+          Task task;
+  
+***************
+*** 375,381 ****
+      }
+  
+      /** Sets the background thread to null. */
+!     protected synchronized void clearThread() {
+          taskRunnerThread = null;
+      }
+  
+--- 375,381 ----
+      }
+  
+      /** Sets the background thread to null. */
+!     public synchronized void clearThread() {
+          taskRunnerThread = null;
+      }
+  
+***************
+*** 385,391 ****
+       *
+       * @return the next task to execute, or null
+       */
+!     protected synchronized Task nextTask() {
+  
+          Task    task;
+          long    now;
+--- 385,391 ----
+       *
+       * @return the next task to execute, or null
+       */
+!     public synchronized Task nextTask() {
+  
+          Task    task;
+          long    now;
+***************
+*** 452,458 ****
+       *
+       * @return System.currentTimeMillis()
+       */
+!     private static long now() {
+  
+          nowCount++;
+  
+--- 452,458 ----
+       *
+       * @return System.currentTimeMillis()
+       */
+!     public static long now() {
+  
+          nowCount++;
+  
+***************
+*** 467,473 ****
+       * but using an inner class protects the public run method
+       * from potential abuse.
+       */
+!     protected class TaskRunner implements Runnable {
+  
+          public void run() {
+  
+--- 467,473 ----
+       * but using an inner class protects the public run method
+       * from potential abuse.
+       */
+!     public class TaskRunner implements Runnable {
+  
+          public void run() {
+  
+***************
+*** 495,501 ****
+       * for execution by the enclosing HsqlTimer's TaskRunner in a
+       * background thread.
+       */
+!     protected class Task {
+  
+          /** What to run */
+          final Runnable runnable;
+--- 495,501 ----
+       * for execution by the enclosing HsqlTimer's TaskRunner in a
+       * background thread.
+       */
+!     public class Task {
+  
+          /** What to run */
+          final Runnable runnable;
+***************
+*** 504,523 ****
+          long period;
+  
+          /** The time this task was last executed, or 0 if never */
+!         private long last;
+  
+          /** The next time this task is scheduled to execute */
+!         private long next;
+  
+          /**
+           * Whether to remove this task instead of running it
+           * the next time it makes its way to the head of the
+           * timer queue.
+           */
+!         private boolean cancelled = false;
+  
+          /** protect the cancelled field under concurrent access */
+!         private Object cancel_mutex = new Object();
+  
+          /**
+           * Whether periodic task is sheduled using fixed delay or fixed rate.
+--- 504,523 ----
+          long period;
+  
+          /** The time this task was last executed, or 0 if never */
+!         public long last;
+  
+          /** The next time this task is scheduled to execute */
+!         public long next;
+  
+          /**
+           * Whether to remove this task instead of running it
+           * the next time it makes its way to the head of the
+           * timer queue.
+           */
+!         public boolean cancelled = false;
+  
+          /** protect the cancelled field under concurrent access */
+!         public Object cancel_mutex = new Object();
+  
+          /**
+           * Whether periodic task is sheduled using fixed delay or fixed rate.
+***************
+*** 628,634 ****
+       * only, as there is no public interface to reinsert Task objects after
+       * they have been removed.
+       */
+!     protected class TaskQueue extends HsqlArrayHeap {
+  
+          /**
+           * Constructs a new TaskQueue with the specified initial capacity and
+--- 628,634 ----
+       * only, as there is no public interface to reinsert Task objects after
+       * they have been removed.
+       */
+!     public class TaskQueue extends HsqlArrayHeap {
+  
+          /**
+           * Constructs a new TaskQueue with the specified initial capacity and
+***************
+*** 702,708 ****
+  //            return name;
+  //        }
+  //
+! //        protected void printstats() {
+  //            System.out.println(this + " avg. latency: " + (total/(runs-1)));
+  //        }
+  //    }
+--- 702,708 ----
+  //            return name;
+  //        }
+  //
+! //        public void printstats() {
+  //            System.out.println(this + " avg. latency: " + (total/(runs-1)));
+  //        }
+  //    }
+diff -crN misc/hsqldb/src/org/hsqldb/lib/IntKeyIntValueHashMap.java misc/build/hsqldb/src/org/hsqldb/lib/IntKeyIntValueHashMap.java
+*** misc/hsqldb/src/org/hsqldb/lib/IntKeyIntValueHashMap.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/IntKeyIntValueHashMap.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 42,49 ****
+   */
+  public class IntKeyIntValueHashMap extends BaseHashMap {
+  
+!     private Set        keySet;
+!     private Collection values;
+  
+      public IntKeyIntValueHashMap() {
+          this(16, 0.75f);
+--- 42,49 ----
+   */
+  public class IntKeyIntValueHashMap extends BaseHashMap {
+  
+!     public Set        keySet;
+!     public Collection values;
+  
+      public IntKeyIntValueHashMap() {
+          this(16, 0.75f);
+diff -crN misc/hsqldb/src/org/hsqldb/lib/LongKeyIntValueHashMap.java misc/build/hsqldb/src/org/hsqldb/lib/LongKeyIntValueHashMap.java
+*** misc/hsqldb/src/org/hsqldb/lib/LongKeyIntValueHashMap.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/LongKeyIntValueHashMap.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 42,49 ****
+   */
+  public class LongKeyIntValueHashMap extends BaseHashMap {
+  
+!     private Set        keySet;
+!     private Collection values;
+  
+      public LongKeyIntValueHashMap() {
+          this(16, 0.75f);
+--- 42,49 ----
+   */
+  public class LongKeyIntValueHashMap extends BaseHashMap {
+  
+!     public Set        keySet;
+!     public Collection values;
+  
+      public LongKeyIntValueHashMap() {
+          this(16, 0.75f);
+diff -crN misc/hsqldb/src/org/hsqldb/lib/MD5.java misc/build/hsqldb/src/org/hsqldb/lib/MD5.java
+*** misc/hsqldb/src/org/hsqldb/lib/MD5.java	2004-01-12 19:30:40.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/lib/MD5.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 83,89 ****
+      /**
+       * The jce MD5 message digest generator.
+       */
+!     private static MessageDigest md5;
+  
+      /**
+       * Retrieves a hexidecimal character sequence representing the MD5
+--- 83,89 ----
+      /**
+       * The jce MD5 message digest generator.
+       */
+!     public static MessageDigest md5;
+  
+      /**
+       * Retrieves a hexidecimal character sequence representing the MD5
+diff -crN misc/hsqldb/src/org/hsqldb/lib/SimpleLog.java misc/build/hsqldb/src/org/hsqldb/lib/SimpleLog.java
+*** misc/hsqldb/src/org/hsqldb/lib/SimpleLog.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/SimpleLog.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 35,43 ****
+  import java.io.FileWriter;
+  import java.io.PrintWriter;
+  
+  /**
+   * Simple log for recording abnormal events in persistence<p>
+!  * Log levels, 0 and 1 are currently supported.
+   *
+   * @author fredt@users
+   * @version 1.8.0
+--- 35,49 ----
+  import java.io.FileWriter;
+  import java.io.PrintWriter;
+  
++ import org.hsqldb.HsqlDateTime;
++ 
+  /**
+   * Simple log for recording abnormal events in persistence<p>
+!  * Log levels, LOG_NONE, LOG_ERROR, and LOG_NORMAL are currently supported.<p>
+!  * LOG_ERROR corresponds to property value 1 and logs main database events plus
+!  * any major errors encountered in operation.
+!  * LOG_NORMAL corresponds to property value 2 and logs additional normal events
+!  * and minor errors.
+   *
+   * @author fredt@users
+   * @version 1.8.0
+***************
+*** 45,58 ****
+   */
+  public class SimpleLog {
+  
+!     private PrintWriter writer;
+!     private int         level;
+  
+      public SimpleLog(String path, int level, boolean useFile) {
+  
+          this.level = level;
+  
+!         if (level != 0) {
+              if (useFile) {
+                  File file = new File(path);
+  
+--- 51,67 ----
+   */
+  public class SimpleLog {
+  
+!     public static int   LOG_NONE   = 0;
+!     public static int   LOG_ERROR  = 1;
+!     public static int   LOG_NORMAL = 2;
+!     public PrintWriter writer;
+!     public int         level;
+  
+      public SimpleLog(String path, int level, boolean useFile) {
+  
+          this.level = level;
+  
+!         if (level != LOG_NONE) {
+              if (useFile) {
+                  File file = new File(path);
+  
+***************
+*** 63,69 ****
+          }
+      }
+  
+!     private void makeLog(File file) {
+  
+          try {
+              FileUtil.makeParentDirectories(file);
+--- 72,78 ----
+          }
+      }
+  
+!     public void makeLog(File file) {
+  
+          try {
+              FileUtil.makeParentDirectories(file);
+***************
+*** 88,115 ****
+          return writer;
+      }
+  
+!     public synchronized void sendLine(String message) {
+  
+!         if (level != 0) {
+!             writer.println(message);
+          }
+      }
+  
+!     public synchronized void logContext(String message) {
+  
+!         if (level == 0) {
+              return;
+          }
+  
+!         String info = "";
+  
+  //#ifdef JDBC3
+          Throwable           t        = new Throwable();
+          StackTraceElement[] elements = t.getStackTrace();
+  
+          if (elements.length > 1) {
+!             info = elements[1].getClassName() + "."
+!                    + elements[1].getMethodName();
+          }
+  
+  //#endif
+--- 97,124 ----
+          return writer;
+      }
+  
+!     public synchronized void sendLine(int atLevel, String message) {
+  
+!         if (level >= atLevel) {
+!             writer.println(HsqlDateTime.getSytemTimeString() + " " + message);
+          }
+      }
+  
+!     public synchronized void logContext(int atLevel, String message) {
+  
+!         if (level < atLevel) {
+              return;
+          }
+  
+!         String info = HsqlDateTime.getSytemTimeString();
+  
+  //#ifdef JDBC3
+          Throwable           t        = new Throwable();
+          StackTraceElement[] elements = t.getStackTrace();
+  
+          if (elements.length > 1) {
+!             info += " " + elements[1].getClassName() + "."
+!                     + elements[1].getMethodName();
+          }
+  
+  //#endif
+***************
+*** 118,135 ****
+  
+      public synchronized void logContext(Throwable t) {
+  
+!         if (level == 0) {
+              return;
+          }
+  
+!         String info = t.getClass().getName();
+  
+  //#ifdef JDBC3
+          StackTraceElement[] elements = t.getStackTrace();
+  
+          if (elements.length > 0) {
+!             info = elements[0].getClassName() + "."
+!                    + elements[0].getMethodName();
+          }
+  
+  //#endif
+--- 127,144 ----
+  
+      public synchronized void logContext(Throwable t) {
+  
+!         if (level == LOG_NONE) {
+              return;
+          }
+  
+!         String info = HsqlDateTime.getSytemTimeString();
+  
+  //#ifdef JDBC3
+          StackTraceElement[] elements = t.getStackTrace();
+  
+          if (elements.length > 0) {
+!             info += " " + elements[0].getClassName() + "."
+!                     + elements[0].getMethodName();
+          }
+  
+  //#endif
+diff -crN misc/hsqldb/src/org/hsqldb/lib/Sort.java misc/build/hsqldb/src/org/hsqldb/lib/Sort.java
+*** misc/hsqldb/src/org/hsqldb/lib/Sort.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/Sort.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 146,152 ****
+      /**
+       * Swaps the a'th and b'th elements of the specified Row array.
+       */
+!     private static void swap(Object[] w, int a, int b) {
+  
+          Object t = w[a];
+  
+--- 146,152 ----
+      /**
+       * Swaps the a'th and b'th elements of the specified Row array.
+       */
+!     public static void swap(Object[] w, int a, int b) {
+  
+          Object t = w[a];
+  
+diff -crN misc/hsqldb/src/org/hsqldb/lib/StopWatch.java misc/build/hsqldb/src/org/hsqldb/lib/StopWatch.java
+*** misc/hsqldb/src/org/hsqldb/lib/StopWatch.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/StopWatch.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 51,64 ****
+       * from stopped to running state, as reported
+       * by System.currentTimeMillis().
+       */
+!     private long startTime;
+!     private long lastStart;
+  
+      /**
+       * The accumulated running time of this object since
+       * it was last zeroed.
+       */
+!     private long total;
+  
+      /** Flags if this object is started or stopped. */
+      boolean running = false;
+--- 51,64 ----
+       * from stopped to running state, as reported
+       * by System.currentTimeMillis().
+       */
+!     public long startTime;
+!     public long lastStart;
+  
+      /**
+       * The accumulated running time of this object since
+       * it was last zeroed.
+       */
+!     public long total;
+  
+      /** Flags if this object is started or stopped. */
+      boolean running = false;
+diff -crN misc/hsqldb/src/org/hsqldb/lib/StringConverter.java misc/build/hsqldb/src/org/hsqldb/lib/StringConverter.java
+*** misc/hsqldb/src/org/hsqldb/lib/StringConverter.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/StringConverter.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 87,98 ****
+  // fredt@users 20020328 - patch 1.7.0 by fredt - error trapping
+  public class StringConverter {
+  
+!     private static final byte[] HEXBYTES = {
+          (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4',
+          (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9',
+          (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f'
+      };
+!     private static final String HEXINDEX = "0123456789abcdef0123456789ABCDEF";
+  
+      /**
+       * Converts a String into a byte array by using a big-endian two byte
+--- 87,98 ----
+  // fredt@users 20020328 - patch 1.7.0 by fredt - error trapping
+  public class StringConverter {
+  
+!     public static final byte[] HEXBYTES = {
+          (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4',
+          (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9',
+          (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f'
+      };
+!     public static final String HEXINDEX = "0123456789abcdef0123456789ABCDEF";
+  
+      /**
+       * Converts a String into a byte array by using a big-endian two byte
+diff -crN misc/hsqldb/src/org/hsqldb/lib/StringInputStream.java misc/build/hsqldb/src/org/hsqldb/lib/StringInputStream.java
+*** misc/hsqldb/src/org/hsqldb/lib/StringInputStream.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/StringInputStream.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 42,51 ****
+   */
+  public class StringInputStream extends InputStream {
+  
+!     protected int    strOffset  = 0;
+!     protected int    charOffset = 0;
+!     protected int    available;
+!     protected String str;
+  
+      public StringInputStream(String s) {
+          str       = s;
+--- 42,51 ----
+   */
+  public class StringInputStream extends InputStream {
+  
+!     public int    strOffset  = 0;
+!     public int    charOffset = 0;
+!     public int    available;
+!     public String str;
+  
+      public StringInputStream(String s) {
+          str       = s;
+diff -crN misc/hsqldb/src/org/hsqldb/lib/WrapperIterator.java misc/build/hsqldb/src/org/hsqldb/lib/WrapperIterator.java
+*** misc/hsqldb/src/org/hsqldb/lib/WrapperIterator.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/WrapperIterator.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 46,62 ****
+   */
+  public class WrapperIterator implements Iterator {
+  
+!     private static final Object[] emptyelements = new Object[0];
+!     private Object[]              elements;
+!     private int                   i;
+  
+      // chained iterators
+!     private boolean  chained;
+!     private Iterator it1;
+!     private Iterator it2;
+  
+      /** return only not null elements */
+!     private boolean notNull;
+  
+      /**
+       * Constructor for an empty iterator. <p>
+--- 46,62 ----
+   */
+  public class WrapperIterator implements Iterator {
+  
+!     public static final Object[] emptyelements = new Object[0];
+!     public Object[]              elements;
+!     public int                   i;
+  
+      // chained iterators
+!     public boolean  chained;
+!     public Iterator it1;
+!     public Iterator it2;
+  
+      /** return only not null elements */
+!     public boolean notNull;
+  
+      /**
+       * Constructor for an empty iterator. <p>
+diff -crN misc/hsqldb/src/org/hsqldb/lib/ZipUnzipFile.java misc/build/hsqldb/src/org/hsqldb/lib/ZipUnzipFile.java
+*** misc/hsqldb/src/org/hsqldb/lib/ZipUnzipFile.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/lib/ZipUnzipFile.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 86,92 ****
+   */
+  public class ZipUnzipFile {
+  
+!     private static final int COPY_BLOCK_SIZE = 1 << 16;
+  
+      public static void compressFile(String infilename, String outfilename,
+                                      FileAccess storage) throws IOException {
+--- 86,92 ----
+   */
+  public class ZipUnzipFile {
+  
+!     public static final int COPY_BLOCK_SIZE = 1 << 16;
+  
+      public static void compressFile(String infilename, String outfilename,
+                                      FileAccess storage) throws IOException {
+diff -crN misc/hsqldb/src/org/hsqldb/Library.java misc/build/hsqldb/src/org/hsqldb/Library.java
+*** misc/hsqldb/src/org/hsqldb/Library.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Library.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 291,297 ****
+          }
+      };
+  
+!     private Library() {}
+  
+      static HashMap getAliasMap() {
+  
+--- 291,297 ----
+          }
+      };
+  
+!     public Library() {}
+  
+      static HashMap getAliasMap() {
+  
+***************
+*** 305,318 ****
+          return h;
+      }
+  
+!     private static void register(HashMap h, String[][] s) {
+  
+          for (int i = 0; i < s.length; i++) {
+              h.put(s[i][0], s[i][1]);
+          }
+      }
+  
+!     private static final Random rRandom = new Random();
+  
+      // NUMERIC FUNCTIONS
+  // fredt@users 20020220 - patch 489184 by xclayl@users - thread safety
+--- 305,318 ----
+          return h;
+      }
+  
+!     public static void register(HashMap h, String[][] s) {
+  
+          for (int i = 0; i < s.length; i++) {
+              h.put(s[i][0], s[i][1]);
+          }
+      }
+  
+!     public static final Random rRandom = new Random();
+  
+      // NUMERIC FUNCTIONS
+  // fredt@users 20020220 - patch 489184 by xclayl@users - thread safety
+***************
+*** 361,367 ****
+      }
+  
+      // this magic number works for 100000000000000; but not for 0.1 and 0.01
+!     private static final double LOG10_FACTOR = 0.43429448190325183;
+  
+      /**
+       * Returns the base 10 logarithm of the given <code>double</code> value.
+--- 361,367 ----
+      }
+  
+      // this magic number works for 100000000000000; but not for 0.1 and 0.01
+!     public static final double LOG10_FACTOR = 0.43429448190325183;
+  
+      /**
+       * Returns the base 10 logarithm of the given <code>double</code> value.
+***************
+*** 1652,1658 ****
+       *           from this value to return the number of date-parts
+       *           between the two arguments.
+       */
+!     private static long getElapsed(int field, java.util.Date d1,
+                                     java.util.Date d2) {
+  
+          // can we do this very simply?
+--- 1652,1658 ----
+       *           from this value to return the number of date-parts
+       *           between the two arguments.
+       */
+!     public static long getElapsed(int field, java.util.Date d1,
+                                     java.util.Date d2) {
+  
+          // can we do this very simply?
+***************
+*** 1932,1938 ****
+  /** @todo  see bitxor and datediff numbering */
+  
+      //
+!     private static final IntValueHashMap functionMap =
+          new IntValueHashMap(67);
+      static final Double piValue = new Double(Library.pi());
+  
+--- 1932,1938 ----
+  /** @todo  see bitxor and datediff numbering */
+  
+      //
+!     public static final IntValueHashMap functionMap =
+          new IntValueHashMap(67);
+      static final Double piValue = new Double(Library.pi());
+  
+diff -crN misc/hsqldb/src/org/hsqldb/Like.java misc/build/hsqldb/src/org/hsqldb/Like.java
+*** misc/hsqldb/src/org/hsqldb/Like.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Like.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 82,93 ****
+  // fredt@users 20031006 - patch 1.7.2 - reuse Like objects for all rows
+  class Like {
+  
+!     private char[]   cLike;
+!     private int[]    wildCardType;
+!     private int      iLen;
+!     private boolean  isIgnoreCase;
+!     private int      iFirstWildCard;
+!     private boolean  isNull;
+      Character        escapeChar;
+      boolean          hasCollation;
+      boolean          optimised;
+--- 82,93 ----
+  // fredt@users 20031006 - patch 1.7.2 - reuse Like objects for all rows
+  class Like {
+  
+!     public char[]   cLike;
+!     public int[]    wildCardType;
+!     public int      iLen;
+!     public boolean  isIgnoreCase;
+!     public int      iFirstWildCard;
+!     public boolean  isNull;
+      Character        escapeChar;
+      boolean          hasCollation;
+      boolean          optimised;
+***************
+*** 121,127 ****
+          normalize(session, s);
+      }
+  
+!     private String getStartsWith() {
+  
+          if (iLen == 0) {
+              return "";
+--- 121,127 ----
+          normalize(session, s);
+      }
+  
+!     public String getStartsWith() {
+  
+          if (iLen == 0) {
+              return "";
+***************
+*** 174,180 ****
+       *
+       * @return
+       */
+!     private boolean compareAt(String s, int i, int j, int jLen) {
+  
+          for (; i < iLen; i++) {
+              switch (wildCardType[i]) {
+--- 174,180 ----
+       *
+       * @return
+       */
+!     public boolean compareAt(String s, int i, int j, int jLen) {
+  
+          for (; i < iLen; i++) {
+              switch (wildCardType[i]) {
+***************
+*** 223,229 ****
+       * @param pattern
+       * @param b
+       */
+!     private void normalize(Session session, String pattern) {
+  
+          isNull = pattern == null;
+  
+--- 223,229 ----
+       * @param pattern
+       * @param b
+       */
+!     public void normalize(Session session, String pattern) {
+  
+          isNull = pattern == null;
+  
+diff -crN misc/hsqldb/src/org/hsqldb/MemoryNode.java misc/build/hsqldb/src/org/hsqldb/MemoryNode.java
+*** misc/hsqldb/src/org/hsqldb/MemoryNode.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/MemoryNode.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 79,85 ****
+   */
+  class MemoryNode extends BaseMemoryNode {
+  
+!     protected Row rData;
+  
+      /**
+       *  A MemoreyNode is permenently linked with the row it refers to.
+--- 79,85 ----
+   */
+  class MemoryNode extends BaseMemoryNode {
+  
+!     public Row rData;
+  
+      /**
+       *  A MemoreyNode is permenently linked with the row it refers to.
+diff -crN misc/hsqldb/src/org/hsqldb/NumberSequence.java misc/build/hsqldb/src/org/hsqldb/NumberSequence.java
+*** misc/hsqldb/src/org/hsqldb/NumberSequence.java	2005-10-23 17:40:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/NumberSequence.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 45,59 ****
+      HsqlName name;
+  
+      // original start value - used in CREATE and ALTER commands
+!     private long startValue;
+  
+      // present value
+!     private long currValue;
+  
+      // last value
+!     private long lastValue;
+!     private long increment;
+!     private int  dataType;
+  
+      /**
+       * constructor with initial value and increment;
+--- 45,59 ----
+      HsqlName name;
+  
+      // original start value - used in CREATE and ALTER commands
+!     public long startValue;
+  
+      // present value
+!     public long currValue;
+  
+      // last value
+!     public long lastValue;
+!     public long increment;
+!     public int  dataType;
+  
+      /**
+       * constructor with initial value and increment;
+diff -crN misc/hsqldb/src/org/hsqldb/Parser.java misc/build/hsqldb/src/org/hsqldb/Parser.java
+*** misc/hsqldb/src/org/hsqldb/Parser.java	2005-11-02 14:05:00.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Parser.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 122,141 ****
+   */
+  class Parser {
+  
+!     private Database  database;
+!     private Tokenizer tokenizer;
+!     private Session   session;
+!     private String    sSchema;
+!     private String    sTable;
+!     private String    sToken;
+!     private boolean   wasQuoted;
+!     private Object    oData;
+!     private int       iType;
+!     private int       iToken;
+  
+      //
+!     private int           subQueryLevel;
+!     private HsqlArrayList subQueryList = new HsqlArrayList();
+  
+      /**
+       *  Constructs a new Parser object with the given context.
+--- 122,141 ----
+   */
+  class Parser {
+  
+!     public Database  database;
+!     public Tokenizer tokenizer;
+!     public Session   session;
+!     public String    sSchema;
+!     public String    sTable;
+!     public String    sToken;
+!     public boolean   wasQuoted;
+!     public Object    oData;
+!     public int       iType;
+!     public int       iToken;
+  
+      //
+!     public int           subQueryLevel;
+!     public HsqlArrayList subQueryList = new HsqlArrayList();
+  
+      /**
+       *  Constructs a new Parser object with the given context.
+***************
+*** 232,238 ****
+                          &&!t.getLongNameFirst().equals(
+                              table.getName().name)) {
+                      throw (Trace.error(Trace.TABLE_NOT_FOUND,
+!                                        t.getLongNameFirst()));
+                  }
+              }
+  
+--- 232,238 ----
+                          &&!t.getLongNameFirst().equals(
+                              table.getName().name)) {
+                      throw (Trace.error(Trace.TABLE_NOT_FOUND,
+!                                        new Object[] { t.getLongNameFirst() }));
+                  }
+              }
+  
+***************
+*** 746,752 ****
+  // in other RDBMS's
+  // "SELECT LIMIT n 0" discards the first n rows and returns the remaining rows
+  // fredt@users 20020225 - patch 456679 by hiep256 - TOP keyword
+!     private void parseLimit(String token, Select select,
+                              boolean isEnd) throws HsqlException {
+  
+          if (select.limitCondition != null) {
+--- 746,752 ----
+  // in other RDBMS's
+  // "SELECT LIMIT n 0" discards the first n rows and returns the remaining rows
+  // fredt@users 20020225 - patch 456679 by hiep256 - TOP keyword
+!     public void parseLimit(String token, Select select,
+                              boolean isEnd) throws HsqlException {
+  
+          if (select.limitCondition != null) {
+***************
+*** 825,831 ****
+          throw Trace.error(Trace.WRONG_DATA_TYPE, messageid);
+      }
+  
+!     private void parseOrderBy(Select select,
+                                HsqlArrayList vcolumn) throws HsqlException {
+  
+          String token;
+--- 825,831 ----
+          throw Trace.error(Trace.WRONG_DATA_TYPE, messageid);
+      }
+  
+!     public void parseOrderBy(Select select,
+                                HsqlArrayList vcolumn) throws HsqlException {
+  
+          String token;
+***************
+*** 855,861 ****
+          select.iOrderLen = len;
+      }
+  
+!     private void resolveSelectTableFilter(Select select,
+                                            HsqlArrayList vcolumn,
+                                            HsqlArrayList vfilter)
+                                            throws HsqlException {
+--- 855,861 ----
+          select.iOrderLen = len;
+      }
+  
+!     public void resolveSelectTableFilter(Select select,
+                                            HsqlArrayList vcolumn,
+                                            HsqlArrayList vfilter)
+                                            throws HsqlException {
+***************
+*** 889,895 ****
+                      TableFilter f = e.findTableFilter(filters);
+  
+                      if (f == null) {
+!                         throw Trace.error(Trace.TABLE_NOT_FOUND, tablename);
+                      }
+  
+                      pos      = addFilterColumns(f, vcolumn, pos);
+--- 889,895 ----
+                      TableFilter f = e.findTableFilter(filters);
+  
+                      if (f == null) {
+!                         throw Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ tablename });
+                      }
+  
+                      pos      = addFilterColumns(f, vcolumn, pos);
+***************
+*** 947,953 ****
+       * @throws HsqlException if an ambiguous reference to an alias or
+       *      non-integer column index is encountered
+       */
+!     private static Expression resolveOrderByExpression(Expression e,
+              Select select, HsqlArrayList vcolumn) throws HsqlException {
+  
+          int     visiblecols = select.iResultLen;
+--- 947,953 ----
+       * @throws HsqlException if an ambiguous reference to an alias or
+       *      non-integer column index is encountered
+       */
+!     public static Expression resolveOrderByExpression(Expression e,
+              Select select, HsqlArrayList vcolumn) throws HsqlException {
+  
+          int     visiblecols = select.iResultLen;
+***************
+*** 991,997 ****
+          return e;
+      }
+  
+!     private static Expression resolveOrderByColumnIndex(Expression e,
+              HsqlArrayList vcolumn, int visiblecols) throws HsqlException {
+  
+          // order by 1,2,3
+--- 991,997 ----
+          return e;
+      }
+  
+!     public static Expression resolveOrderByColumnIndex(Expression e,
+              HsqlArrayList vcolumn, int visiblecols) throws HsqlException {
+  
+          // order by 1,2,3
+***************
+*** 1010,1016 ****
+          throw Trace.error(Trace.INVALID_ORDER_BY);
+      }
+  
+!     private TableFilter parseSimpleTableFilter(int type)
+      throws HsqlException {
+  
+          String alias  = null;
+--- 1010,1016 ----
+          throw Trace.error(Trace.INVALID_ORDER_BY);
+      }
+  
+!     public TableFilter parseSimpleTableFilter(int type)
+      throws HsqlException {
+  
+          String alias  = null;
+***************
+*** 1042,1048 ****
+       * @return a newly constructed TableFilter object
+       * @throws  HsqlException if a parsing error occurs
+       */
+!     private TableFilter parseTableFilter(boolean outerjoin)
+      throws HsqlException {
+  
+          Table          t          = null;
+--- 1042,1048 ----
+       * @return a newly constructed TableFilter object
+       * @throws  HsqlException if a parsing error occurs
+       */
+!     public TableFilter parseTableFilter(boolean outerjoin)
+      throws HsqlException {
+  
+          Table          t          = null;
+***************
+*** 1125,1131 ****
+       * @param  e2
+       * @return
+       */
+!     private static Expression addCondition(Expression e1, Expression e2) {
+  
+          if (e1 == null) {
+              return e2;
+--- 1125,1131 ----
+       * @param  e2
+       * @return
+       */
+!     public static Expression addCondition(Expression e1, Expression e2) {
+  
+          if (e1 == null) {
+              return e2;
+***************
+*** 1149,1155 ****
+       *      in the join
+       * @return a new Expression object; the conjunction of e1 and e2
+       */
+!     private static Expression addJoinCondition(Expression e1, Expression e2,
+              TableFilter tf, boolean outer) throws HsqlException {
+  
+          if (!e2.setForJoin(tf, outer)) {
+--- 1149,1155 ----
+       *      in the join
+       * @return a new Expression object; the conjunction of e1 and e2
+       */
+!     public static Expression addJoinCondition(Expression e1, Expression e2,
+              TableFilter tf, boolean outer) throws HsqlException {
+  
+          if (!e2.setForJoin(tf, outer)) {
+***************
+*** 1176,1182 ****
+          return r;
+      }
+  
+!     private Expression readAggregate() throws HsqlException {
+  
+          boolean distinct = false;
+          boolean all      = false;
+--- 1176,1182 ----
+          return r;
+      }
+  
+!     public Expression readAggregate() throws HsqlException {
+  
+          boolean distinct = false;
+          boolean all      = false;
+***************
+*** 1221,1227 ****
+       * @return a disjuntion, possibly degenerate
+       * @throws  HsqlException
+       */
+!     private Expression readOr() throws HsqlException {
+  
+          Expression r = readAnd();
+  
+--- 1221,1227 ----
+       * @return a disjuntion, possibly degenerate
+       * @throws  HsqlException
+       */
+!     public Expression readOr() throws HsqlException {
+  
+          Expression r = readAnd();
+  
+***************
+*** 1243,1249 ****
+       * @return a conjunction, possibly degenerate
+       * @throws  HsqlException
+       */
+!     private Expression readAnd() throws HsqlException {
+  
+          Expression r = readCondition();
+  
+--- 1243,1249 ----
+       * @return a conjunction, possibly degenerate
+       * @throws  HsqlException
+       */
+!     public Expression readAnd() throws HsqlException {
+  
+          Expression r = readCondition();
+  
+***************
+*** 1265,1271 ****
+       * @return a predicate, possibly composite
+       * @throws  HsqlException
+       */
+!     private Expression readCondition() throws HsqlException {
+  
+          switch (iToken) {
+  
+--- 1265,1271 ----
+       * @return a predicate, possibly composite
+       * @throws  HsqlException
+       */
+!     public Expression readCondition() throws HsqlException {
+  
+          switch (iToken) {
+  
+***************
+*** 1382,1388 ****
+          }
+      }
+  
+!     private Expression parseLikePredicate(Expression a) throws HsqlException {
+  
+          read();
+  
+--- 1382,1388 ----
+          }
+      }
+  
+!     public Expression parseLikePredicate(Expression a) throws HsqlException {
+  
+          read();
+  
+***************
+*** 1420,1426 ****
+          return a;
+      }
+  
+!     private Expression parseBetweenPredicate(Expression a)
+      throws HsqlException {
+  
+          read();
+--- 1420,1426 ----
+          return a;
+      }
+  
+!     public Expression parseBetweenPredicate(Expression a)
+      throws HsqlException {
+  
+          read();
+***************
+*** 1446,1452 ****
+          return new Expression(Expression.AND, l, h);
+      }
+  
+!     private Expression parseInPredicate(Expression a) throws HsqlException {
+  
+          int type = iToken;
+  
+--- 1446,1452 ----
+          return new Expression(Expression.AND, l, h);
+      }
+  
+!     public Expression parseInPredicate(Expression a) throws HsqlException {
+  
+          int type = iToken;
+  
+***************
+*** 1504,1510 ****
+          return new Expression(type, a, b);
+      }
+  
+!     private Expression parseAllAnyPredicate() throws HsqlException {
+  
+          int type = iToken;
+  
+--- 1504,1510 ----
+          return new Expression(type, a, b);
+      }
+  
+!     public Expression parseAllAnyPredicate() throws HsqlException {
+  
+          int type = iToken;
+  
+***************
+*** 1544,1550 ****
+       * @param  type
+       * @throws  HsqlException
+       */
+!     private void readThis(int type) throws HsqlException {
+          Trace.check(iToken == type, Trace.UNEXPECTED_TOKEN);
+          read();
+      }
+--- 1544,1550 ----
+       * @param  type
+       * @throws  HsqlException
+       */
+!     public void readThis(int type) throws HsqlException {
+          Trace.check(iToken == type, Trace.UNEXPECTED_TOKEN);
+          read();
+      }
+***************
+*** 1555,1561 ****
+       * @return a concatenation, possibly degenerate
+       * @throws  HsqlException
+       */
+!     private Expression readConcat() throws HsqlException {
+  
+          Expression r = readSum();
+  
+--- 1555,1561 ----
+       * @return a concatenation, possibly degenerate
+       * @throws  HsqlException
+       */
+!     public Expression readConcat() throws HsqlException {
+  
+          Expression r = readSum();
+  
+***************
+*** 1592,1598 ****
+       * @return  a summation, possibly degenerate
+       * @throws  HsqlException
+       */
+!     private Expression readSum() throws HsqlException {
+  
+          Expression r = readFactor();
+  
+--- 1592,1598 ----
+       * @return  a summation, possibly degenerate
+       * @throws  HsqlException
+       */
+!     public Expression readSum() throws HsqlException {
+  
+          Expression r = readFactor();
+  
+***************
+*** 1623,1629 ****
+       * @return  a product, possibly degenerate
+       * @throws  HsqlException
+       */
+!     private Expression readFactor() throws HsqlException {
+  
+          Expression r = readTerm();
+  
+--- 1623,1629 ----
+       * @return  a product, possibly degenerate
+       * @throws  HsqlException
+       */
+!     public Expression readFactor() throws HsqlException {
+  
+          Expression r = readTerm();
+  
+***************
+*** 1645,1651 ****
+       * @return  a term, possibly composite
+       * @throws  HsqlException
+       */
+!     private Expression readTerm() throws HsqlException {
+  
+          Expression r = null;
+  
+--- 1645,1651 ----
+       * @return  a term, possibly composite
+       * @throws  HsqlException
+       */
+!     public Expression readTerm() throws HsqlException {
+  
+          Expression r = null;
+  
+***************
+*** 1832,1838 ****
+      /**
+       * Reads part of a CASE .. WHEN  expression
+       */
+!     private Expression parseCaseWhen(Expression r) throws HsqlException {
+  
+          readThis(Expression.WHEN);
+  
+--- 1832,1838 ----
+      /**
+       * Reads part of a CASE .. WHEN  expression
+       */
+!     public Expression parseCaseWhen(Expression r) throws HsqlException {
+  
+          readThis(Expression.WHEN);
+  
+***************
+*** 1858,1864 ****
+      /**
+       * reads a CASEWHEN expression
+       */
+!     private Expression readCaseWhenExpression() throws HsqlException {
+  
+          int        type = iToken;
+          Expression r    = null;
+--- 1858,1864 ----
+      /**
+       * reads a CASEWHEN expression
+       */
+!     public Expression readCaseWhenExpression() throws HsqlException {
+  
+          int        type = iToken;
+          Expression r    = null;
+***************
+*** 1886,1892 ****
+      /**
+       * Reads a CAST or CONVERT expression
+       */
+!     private Expression readCastExpression() throws HsqlException {
+  
+          boolean isConvert = iToken == Expression.CONVERT;
+  
+--- 1886,1892 ----
+      /**
+       * Reads a CAST or CONVERT expression
+       */
+!     public Expression readCastExpression() throws HsqlException {
+  
+          boolean isConvert = iToken == Expression.CONVERT;
+  
+***************
+*** 1946,1952 ****
+      /**
+       * reads a Column or Function expression
+       */
+!     private Expression readColumnExpression() throws HsqlException {
+  
+          String     name = sToken;
+          Expression r    = new Expression(sTable, name, wasQuoted);
+--- 1946,1952 ----
+      /**
+       * reads a Column or Function expression
+       */
+!     public Expression readColumnExpression() throws HsqlException {
+  
+          String     name = sToken;
+          Expression r    = new Expression(sTable, name, wasQuoted);
+***************
+*** 1996,2002 ****
+      /**
+       * reads a CONCAT expression
+       */
+!     private Expression readConcatExpression() throws HsqlException {
+  
+          int type = iToken;
+  
+--- 1996,2002 ----
+      /**
+       * reads a CONCAT expression
+       */
+!     public Expression readConcatExpression() throws HsqlException {
+  
+          int type = iToken;
+  
+***************
+*** 2017,2023 ****
+      /**
+       * Reads a NULLIF expression
+       */
+!     private Expression readNullIfExpression() throws HsqlException {
+  
+          // turn into a CASEWHEN
+          read();
+--- 2017,2023 ----
+      /**
+       * Reads a NULLIF expression
+       */
+!     public Expression readNullIfExpression() throws HsqlException {
+  
+          // turn into a CASEWHEN
+          read();
+***************
+*** 2042,2048 ****
+      /**
+       * Reads a COALESE or IFNULL expression
+       */
+!     private Expression readCoalesceExpression() throws HsqlException {
+  
+          Expression r = null;
+  
+--- 2042,2048 ----
+      /**
+       * Reads a COALESE or IFNULL expression
+       */
+!     public Expression readCoalesceExpression() throws HsqlException {
+  
+          Expression r = null;
+  
+***************
+*** 2084,2090 ****
+      /**
+       * Reads an EXTRACT expression
+       */
+!     private Expression readExtractExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+--- 2084,2090 ----
+      /**
+       * Reads an EXTRACT expression
+       */
+!     public Expression readExtractExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+***************
+*** 2111,2117 ****
+      /**
+       * Reads a POSITION expression
+       */
+!     private Expression readPositionExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+--- 2111,2117 ----
+      /**
+       * Reads a POSITION expression
+       */
+!     public Expression readPositionExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+***************
+*** 2130,2136 ****
+      /**
+       * Reads a SUBSTRING expression
+       */
+!     private Expression readSubstringExpression() throws HsqlException {
+  
+          boolean commas = false;
+  
+--- 2130,2136 ----
+      /**
+       * Reads a SUBSTRING expression
+       */
+!     public Expression readSubstringExpression() throws HsqlException {
+  
+          boolean commas = false;
+  
+***************
+*** 2171,2177 ****
+          return new Expression(f);
+      }
+  
+!     private Expression readSequenceExpression() throws HsqlException {
+  
+          tokenizer.getThis(Token.T_VALUE);
+          tokenizer.getThis(Token.T_FOR);
+--- 2171,2177 ----
+          return new Expression(f);
+      }
+  
+!     public Expression readSequenceExpression() throws HsqlException {
+  
+          tokenizer.getThis(Token.T_VALUE);
+          tokenizer.getThis(Token.T_FOR);
+***************
+*** 2195,2201 ****
+      /**
+       * Reads a TRIM expression
+       */
+!     private Expression readTrimExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+--- 2195,2201 ----
+      /**
+       * Reads a TRIM expression
+       */
+!     public Expression readTrimExpression() throws HsqlException {
+  
+          read();
+          readThis(Expression.OPEN);
+***************
+*** 2309,2315 ****
+       *
+       * @throws  HsqlException
+       */
+!     private void read() throws HsqlException {
+  
+          sToken    = tokenizer.getString();
+          wasQuoted = tokenizer.wasQuotedIdentifier();
+--- 2309,2315 ----
+       *
+       * @throws  HsqlException
+       */
+!     public void read() throws HsqlException {
+  
+          sToken    = tokenizer.getString();
+          wasQuoted = tokenizer.wasQuotedIdentifier();
+***************
+*** 2330,2335 ****
+--- 2330,2337 ----
+              } else {
+                  iToken = Expression.COLUMN;
+              }
++         } else if (tokenizer.wasParameter()) {
++             iToken = Expression.PARAM;
+          } else if (sToken.length() == 0) {
+              iToken = Expression.END;
+          } else {
+***************
+*** 2419,2430 ****
+       *
+       * @throws HsqlException if a tokenization error occurs
+       */
+!     private void readToken() throws HsqlException {
+          sToken = tokenizer.getString();
+          iToken = tokenSet.get(sToken, -1);
+      }
+  
+!     private static IntValueHashMap tokenSet = new IntValueHashMap(37);
+  
+      static {
+          tokenSet.put(Token.T_COMMA, Expression.COMMA);
+--- 2421,2432 ----
+       *
+       * @throws HsqlException if a tokenization error occurs
+       */
+!     public void readToken() throws HsqlException {
+          sToken = tokenizer.getString();
+          iToken = tokenSet.get(sToken, -1);
+      }
+  
+!     public static IntValueHashMap tokenSet = new IntValueHashMap(37);
+  
+      static {
+          tokenSet.put(Token.T_COMMA, Expression.COMMA);
+***************
+*** 2490,2497 ****
+  // boucherb@users 20030411 - patch 1.7.2 - for prepared statements
+  // ---------------------------------------------------------------
+      HsqlArrayList                     parameters   = new HsqlArrayList();
+!     private static final Expression[] noParameters = new Expression[0];
+!     private static final SubQuery[]   noSubqueries = new SubQuery[0];
+  
+      /**
+       *  Destructive get method
+--- 2492,2499 ----
+  // boucherb@users 20030411 - patch 1.7.2 - for prepared statements
+  // ---------------------------------------------------------------
+      HsqlArrayList                     parameters   = new HsqlArrayList();
+!     public static final Expression[] noParameters = new Expression[0];
+!     public static final SubQuery[]   noSubqueries = new SubQuery[0];
+  
+      /**
+       *  Destructive get method
+***************
+*** 2590,2596 ****
+          return cs;
+      }
+  
+!     private void getInsertColumnValueExpressions(Table t, Expression[] acve,
+              int len) throws HsqlException {
+  
+          boolean    enclosed;
+--- 2592,2598 ----
+          return cs;
+      }
+  
+!     public void getInsertColumnValueExpressions(Table t, Expression[] acve,
+              int len) throws HsqlException {
+  
+          boolean    enclosed;
+***************
+*** 2789,2795 ****
+  
+              if (tablename != null
+                      &&!tableFilter.getName().equals(tablename)) {
+!                 throw Trace.error(Trace.TABLE_NOT_FOUND);
+              }
+  
+              tokenizer.getThis(Token.T_EQUALS);
+--- 2791,2797 ----
+  
+              if (tablename != null
+                      &&!tableFilter.getName().equals(tablename)) {
+!                 throw Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ tablename });
+              }
+  
+              tokenizer.getThis(Token.T_EQUALS);
+diff -crN misc/hsqldb/src/org/hsqldb/persist/Cache.java misc/build/hsqldb/src/org/hsqldb/persist/Cache.java
+*** misc/hsqldb/src/org/hsqldb/persist/Cache.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/Cache.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 54,68 ****
+  public class Cache {
+  
+      final DataFileCache                  dataFileCache;
+!     private int                          capacity;         // number of Rows
+!     private long                         bytesCapacity;    // number of bytes
+!     private final CachedObjectComparator rowComparator;
+  
+  //
+!     private CachedObject[] rowTable;
+  
+  //
+!     private final ObjectCacheHashMap cacheMap;
+      long                             cacheBytesLength;
+  
+      // for testing
+--- 54,68 ----
+  public class Cache {
+  
+      final DataFileCache                  dataFileCache;
+!     public int                          capacity;         // number of Rows
+!     public long                         bytesCapacity;    // number of bytes
+!     public final CachedObjectComparator rowComparator;
+  
+  //
+!     public CachedObject[] rowTable;
+  
+  //
+!     public final ObjectCacheHashMap cacheMap;
+      long                             cacheBytesLength;
+  
+      // for testing
+***************
+*** 148,154 ****
+       * in the cache.
+       *
+       */
+!     private synchronized void cleanUp() throws IOException {
+  
+          int removeCount = cacheMap.size() / 2;
+          int accessTarget = cacheMap.getAccessCountCeiling(removeCount,
+--- 148,154 ----
+       * in the cache.
+       *
+       */
+!     public synchronized void cleanUp() throws IOException {
+  
+          int removeCount = cacheMap.size() / 2;
+          int accessTarget = cacheMap.getAccessCountCeiling(removeCount,
+***************
+*** 246,252 ****
+          static final int COMPARE_LAST_ACCESS = 0;
+          static final int COMPARE_POSITION    = 1;
+          static final int COMPARE_SIZE        = 2;
+!         private int      compareType;
+  
+          CachedObjectComparator() {}
+  
+--- 246,252 ----
+          static final int COMPARE_LAST_ACCESS = 0;
+          static final int COMPARE_POSITION    = 1;
+          static final int COMPARE_SIZE        = 2;
+!         public int      compareType;
+  
+          CachedObjectComparator() {}
+  
+diff -crN misc/hsqldb/src/org/hsqldb/persist/DataFileBlockManager.java misc/build/hsqldb/src/org/hsqldb/persist/DataFileBlockManager.java
+*** misc/hsqldb/src/org/hsqldb/persist/DataFileBlockManager.java	2005-10-23 17:40:16.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/DataFileBlockManager.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 42,57 ****
+   */
+  public class DataFileBlockManager {
+  
+!     private DoubleIntIndex lookup;
+!     private final int      capacity;
+!     private int            midSize;
+!     private final int      scale;
+!     private long           releaseCount;
+!     private long           requestCount;
+!     private long           requestSize;
+  
+      // reporting vars
+!     long lostFreeBlockSize;
+  
+      /**
+       *
+--- 42,58 ----
+   */
+  public class DataFileBlockManager {
+  
+!     public DoubleIntIndex lookup;
+!     public final int      capacity;
+!     public int            midSize;
+!     public final int      scale;
+!     public long           releaseCount;
+!     public long           requestCount;
+!     public long           requestSize;
+  
+      // reporting vars
+!     long    lostFreeBlockSize;
+!     boolean isModified;
+  
+      /**
+       *
+***************
+*** 72,77 ****
+--- 73,80 ----
+       */
+      void add(int pos, int rowSize) {
+  
++         isModified = true;
++ 
+          if (capacity == 0) {
+              lostFreeBlockSize += rowSize;
+  
+***************
+*** 133,139 ****
+          return lostFreeBlockSize;
+      }
+  
+!     private void resetList() {
+  
+          if (requestCount != 0) {
+              midSize = (int) (requestSize / requestCount);
+--- 136,146 ----
+          return lostFreeBlockSize;
+      }
+  
+!     boolean isModified() {
+!         return isModified;
+!     }
+! 
+!     public void resetList() {
+  
+          if (requestCount != 0) {
+              midSize = (int) (requestSize / requestCount);
+***************
+*** 148,154 ****
+          removeBlocks(first);
+      }
+  
+!     private void removeBlocks(int blocks) {
+  
+          for (int i = 0; i < blocks; i++) {
+              lostFreeBlockSize += lookup.getValue(i);
+--- 155,161 ----
+          removeBlocks(first);
+      }
+  
+!     public void removeBlocks(int blocks) {
+  
+          for (int i = 0; i < blocks; i++) {
+              lostFreeBlockSize += lookup.getValue(i);
+***************
+*** 157,161 ****
+          lookup.removeRange(0, blocks);
+      }
+  
+!     private void checkIntegrity() throws NullPointerException {}
+  }
+--- 164,168 ----
+          lookup.removeRange(0, blocks);
+      }
+  
+!     public void checkIntegrity() throws NullPointerException {}
+  }
+diff -crN misc/hsqldb/src/org/hsqldb/persist/DataFileCache.java misc/build/hsqldb/src/org/hsqldb/persist/DataFileCache.java
+*** misc/hsqldb/src/org/hsqldb/persist/DataFileCache.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/DataFileCache.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 39,44 ****
+--- 39,45 ----
+  import org.hsqldb.Trace;
+  import org.hsqldb.lib.FileAccess;
+  import org.hsqldb.lib.FileUtil;
++ import org.hsqldb.lib.SimpleLog;
+  import org.hsqldb.lib.StopWatch;
+  import org.hsqldb.lib.Storage;
+  import org.hsqldb.lib.ZipUnzipFile;
+***************
+*** 62,68 ****
+   */
+  public class DataFileCache {
+  
+!     private FileAccess fa;
+  
+      // flags
+      public static final int FLAG_ISSAVED = 2;
+--- 63,69 ----
+   */
+  public class DataFileCache {
+  
+!     public FileAccess fa;
+  
+      // flags
+      public static final int FLAG_ISSAVED = 2;
+***************
+*** 76,115 ****
+  
+      //
+      DataFileBlockManager     freeBlocks;
+!     private static final int FREE_BLOCKS_COUNT = 512;
+  
+      //
+!     protected String   fileName;
+!     protected String   backupFileName;
+!     protected Database database;
+  
+      // this flag is used externally to determine if a backup is required
+!     protected boolean fileModified;
+!     protected int     cacheFileScale;
+  
+      // post openning constant fields
+!     protected boolean cacheReadonly;
+  
+      // cache operation mode
+!     protected boolean storeOnInsert;
+  
+      //
+!     protected int     cachedRowPadding = 8;
+!     protected boolean hasRowInfo       = false;
+  
+      // reusable input / output streams
+!     protected RowInputInterface  rowIn;
+!     protected RowOutputInterface rowOut;
+  
+      //
+      public long maxDataFileSize;
+  
+      //
+!     protected Storage dataFile;
+!     protected long    fileFreePosition;
+!     protected int     maxCacheSize;             // number of Rows
+!     protected long    maxCacheBytes;            // number of bytes
+!     protected Cache   cache;
+  
+      public DataFileCache(Database db, String fileName,
+                           String backupName) throws HsqlException {
+--- 77,116 ----
+  
+      //
+      DataFileBlockManager     freeBlocks;
+!     public static final int FREE_BLOCKS_COUNT = 512;
+  
+      //
+!     public String   fileName;
+!     public String   backupFileName;
+!     public Database database;
+  
+      // this flag is used externally to determine if a backup is required
+!     public boolean fileModified;
+!     public int     cacheFileScale;
+  
+      // post openning constant fields
+!     public boolean cacheReadonly;
+  
+      // cache operation mode
+!     public boolean storeOnInsert;
+  
+      //
+!     public int     cachedRowPadding = 8;
+!     public boolean hasRowInfo       = false;
+  
+      // reusable input / output streams
+!     public RowInputInterface  rowIn;
+!     public RowOutputInterface rowOut;
+  
+      //
+      public long maxDataFileSize;
+  
+      //
+!     public Storage dataFile;
+!     public long    fileFreePosition;
+!     public int     maxCacheSize;             // number of Rows
+!     public long    maxCacheBytes;            // number of bytes
+!     public Cache   cache;
+  
+      public DataFileCache(Database db, String fileName,
+                           String backupName) throws HsqlException {
+***************
+*** 127,133 ****
+      /**
+       * initial external parameters are set here.
+       */
+!     protected void initParams() throws HsqlException {
+  
+          int cacheScale = database.getProperties().getIntegerProperty(
+              HsqlDatabaseProperties.hsqldb_cache_scale, 14, 8, 18);
+--- 128,134 ----
+      /**
+       * initial external parameters are set here.
+       */
+!     public void initParams() throws HsqlException {
+  
+          int cacheScale = database.getProperties().getIntegerProperty(
+              HsqlDatabaseProperties.hsqldb_cache_scale, 14, 8, 18);
+***************
+*** 275,302 ****
+                  cache.saveAll();
+                  Trace.printSystemOut("saveAll: " + sw.elapsedTime());
+  
+!                 // set empty
+!                 dataFile.seek(LONG_EMPTY_SIZE);
+!                 dataFile.writeLong(freeBlocks.getLostBlocksSize());
+  
+!                 // set end
+!                 dataFile.seek(LONG_FREE_POS_POS);
+!                 dataFile.writeLong(fileFreePosition);
+  
+!                 // set saved flag;
+!                 dataFile.seek(FLAGS_POS);
+  
+!                 int flag = BitMap.set(0, FLAG_ISSAVED);
+  
+!                 if (hasRowInfo) {
+!                     flag = BitMap.set(flag, FLAG_ROWINFO);
+!                 }
+  
+!                 dataFile.writeInt(flag);
+  
+!                 //
+!                 dataFile.seek(fileFreePosition);
+!                 Trace.printSystemOut("pos and flags: " + sw.elapsedTime());
+              }
+  
+              if (dataFile != null) {
+--- 276,310 ----
+                  cache.saveAll();
+                  Trace.printSystemOut("saveAll: " + sw.elapsedTime());
+  
+!                 if (fileModified || freeBlocks.isModified()) {
+  
+!                     // set empty
+!                     dataFile.seek(LONG_EMPTY_SIZE);
+!                     dataFile.writeLong(freeBlocks.getLostBlocksSize());
+  
+!                     // set end
+!                     dataFile.seek(LONG_FREE_POS_POS);
+!                     dataFile.writeLong(fileFreePosition);
+  
+!                     // set saved flag;
+!                     dataFile.seek(FLAGS_POS);
+  
+!                     int flag = BitMap.set(0, FLAG_ISSAVED);
+  
+!                     if (hasRowInfo) {
+!                         flag = BitMap.set(flag, FLAG_ROWINFO);
+!                     }
+  
+!                     dataFile.writeInt(flag);
+! 
+!                     //
+!                     if (dataFile.length() != fileFreePosition) {
+!                         dataFile.seek(fileFreePosition);
+!                     }
+! 
+!                     Trace.printSystemOut("pos and flags: "
+!                                          + sw.elapsedTime());
+!                 }
+              }
+  
+              if (dataFile != null) {
+***************
+*** 350,356 ****
+          }
+      }
+  
+!     protected void initBuffers() {
+  
+          if (rowOut == null
+                  || ((RowOutputBinary) rowOut).getBuffer().length > 256) {
+--- 358,364 ----
+          }
+      }
+  
+!     public void initBuffers() {
+  
+          if (rowOut == null
+                  || ((RowOutputBinary) rowOut).getBuffer().length > 256) {
+***************
+*** 455,461 ****
+       * Free space is requested from the block manager if it exists.
+       * Otherwise the file is grown to accommodate it.
+       */
+!     private int setFilePos(CachedObject r) throws IOException {
+  
+          int rowSize = r.getStorageSize();
+          int i       = freeBlocks == null ? -1
+--- 463,469 ----
+       * Free space is requested from the block manager if it exists.
+       * Otherwise the file is grown to accommodate it.
+       */
+!     public int setFilePos(CachedObject r) throws IOException {
+  
+          int rowSize = r.getStorageSize();
+          int i       = freeBlocks == null ? -1
+***************
+*** 557,563 ****
+  
+              return object;
+          } catch (IOException e) {
+!             database.logger.appLog.logContext("" + cache + " pos: " + i);
+              database.logger.appLog.logContext(e);
+  
+              throw Trace.error(Trace.DATA_FILE_ERROR,
+--- 565,572 ----
+  
+              return object;
+          } catch (IOException e) {
+!             database.logger.appLog.logContext(SimpleLog.LOG_ERROR,
+!                                               "" + cache + " pos: " + i);
+              database.logger.appLog.logContext(e);
+  
+              throw Trace.error(Trace.DATA_FILE_ERROR,
+***************
+*** 571,584 ****
+          return readObject(i);
+      }
+  
+!     protected synchronized int readSize(int pos) throws IOException {
+  
+          dataFile.seek((long) pos * cacheFileScale);
+  
+          return dataFile.readInt();
+      }
+  
+!     protected synchronized RowInputInterface readObject(int pos)
+      throws IOException {
+  
+          dataFile.seek((long) pos * cacheFileScale);
+--- 580,593 ----
+          return readObject(i);
+      }
+  
+!     public synchronized int readSize(int pos) throws IOException {
+  
+          dataFile.seek((long) pos * cacheFileScale);
+  
+          return dataFile.readInt();
+      }
+  
+!     public synchronized RowInputInterface readObject(int pos)
+      throws IOException {
+  
+          dataFile.seek((long) pos * cacheFileScale);
+***************
+*** 599,605 ****
+       * This is called internally when old rows need to be removed from the
+       * cache.
+       */
+!     protected synchronized void saveRows(CachedObject[] rows, int offset,
+                                           int count) throws IOException {
+  
+          for (int i = offset; i < offset + count; i++) {
+--- 608,614 ----
+       * This is called internally when old rows need to be removed from the
+       * cache.
+       */
+!     public synchronized void saveRows(CachedObject[] rows, int offset,
+                                           int count) throws IOException {
+  
+          for (int i = offset; i < offset + count; i++) {
+***************
+*** 745,751 ****
+          return fileModified;
+      }
+  
+!     protected synchronized void setFileModified() throws IOException {
+  
+          if (!fileModified) {
+  
+--- 754,760 ----
+          return fileModified;
+      }
+  
+!     public synchronized void setFileModified() throws IOException {
+  
+          if (!fileModified) {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/persist/DataFileDefrag.java misc/build/hsqldb/src/org/hsqldb/persist/DataFileDefrag.java
+*** misc/hsqldb/src/org/hsqldb/persist/DataFileDefrag.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/DataFileDefrag.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 37,42 ****
+--- 37,43 ----
+  
+  import org.hsqldb.Database;
+  import org.hsqldb.HsqlException;
++ import org.hsqldb.Session;
+  import org.hsqldb.Table;
+  import org.hsqldb.Trace;
+  import org.hsqldb.index.RowIterator;
+***************
+*** 202,207 ****
+--- 203,209 ----
+      int[] writeTableToDataFile(Table table)
+      throws IOException, HsqlException {
+  
++         Session session        = database.getSessionManager().getSysSession();
+          RowOutputBinary rowOut = new RowOutputBinary();
+          DoubleIntIndex pointerLookup =
+              new DoubleIntIndex(table.getPrimaryIndex().sizeEstimate(), false);
+***************
+*** 212,218 ****
+          pointerLookup.setKeysSearchTarget();
+          Trace.printSystemOut("lookup begins: " + stopw.elapsedTime());
+  
+!         RowIterator it = table.rowIterator(null);
+  
+          for (; it.hasNext(); count++) {
+              CachedObject row = (CachedObject) it.next();
+--- 214,220 ----
+          pointerLookup.setKeysSearchTarget();
+          Trace.printSystemOut("lookup begins: " + stopw.elapsedTime());
+  
+!         RowIterator it = table.rowIterator(session);
+  
+          for (; it.hasNext(); count++) {
+              CachedObject row = (CachedObject) it.next();
+***************
+*** 231,237 ****
+                               stopw.elapsedTime());
+  
+          count = 0;
+!         it    = table.rowIterator(null);
+  
+          for (; it.hasNext(); count++) {
+              CachedObject row = it.next();
+--- 233,239 ----
+                               stopw.elapsedTime());
+  
+          count = 0;
+!         it    = table.rowIterator(session);
+  
+          for (; it.hasNext(); count++) {
+              CachedObject row = it.next();
+diff -crN misc/hsqldb/src/org/hsqldb/persist/HsqlDatabaseProperties.java misc/build/hsqldb/src/org/hsqldb/persist/HsqlDatabaseProperties.java
+*** misc/hsqldb/src/org/hsqldb/persist/HsqlDatabaseProperties.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/HsqlDatabaseProperties.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 59,69 ****
+      public static final int FILES_NEW          = 2;
+  
+      // sets of properties
+!     private static HashSet fullyProtectedProperties = new HashSet();
+!     private static HashSet setProtectedProperties   = new HashSet();
+!     private static HashSet booleanProperties        = new HashSet();
+!     private static HashSet integralProperties       = new HashSet();
+!     private static HashSet stringProperties         = new HashSet();
+  
+      // versions
+      public static final String VERSION_STRING_1_7_0     = "1.7.0";
+--- 59,69 ----
+      public static final int FILES_NEW          = 2;
+  
+      // sets of properties
+!     public static HashSet fullyProtectedProperties = new HashSet();
+!     public static HashSet setProtectedProperties   = new HashSet();
+!     public static HashSet booleanProperties        = new HashSet();
+!     public static HashSet integralProperties       = new HashSet();
+!     public static HashSet stringProperties         = new HashSet();
+  
+      // versions
+      public static final String VERSION_STRING_1_7_0     = "1.7.0";
+***************
+*** 77,87 ****
+  
+      //
+      public static final String  db_version  = "version";
+!     private static final String db_readonly = "readonly";
+!     private static final String db_modified = "modified";
+  
+      //
+!     private static final String runtime_gc_interval = "runtime.gc_interval";
+      public static final String  hsqldb_applog       = "hsqldb.applog";
+      public static final String  hsqldb_cache_scale  = "hsqldb.cache_scale";
+      public static final String hsqldb_cache_file_scale =
+--- 77,87 ----
+  
+      //
+      public static final String  db_version  = "version";
+!     public static final String db_readonly = "readonly";
+!     public static final String db_modified = "modified";
+  
+      //
+!     public static final String runtime_gc_interval = "runtime.gc_interval";
+      public static final String  hsqldb_applog       = "hsqldb.applog";
+      public static final String  hsqldb_cache_scale  = "hsqldb.cache_scale";
+      public static final String hsqldb_cache_file_scale =
+***************
+*** 89,113 ****
+      public static final String hsqldb_cache_size_scale =
+          "hsqldb.cache_size_scale";
+      public static final String  hsqldb_cache_version = "hsqldb.cache_version";
+!     private static final String hsqldb_catalogs      = "hsqldb.catalogs";
+      public static final String hsqldb_compatible_version =
+          "hsqldb.compatible_version";
+      public static final String hsqldb_default_table_type =
+          "hsqldb.default_table_type";
+      public static final String hsqldb_defrag_limit = "hsqldb.defrag_limit";
+!     private static final String hsqldb_files_readonly =
+          "hsqldb.files_readonly";
+      public static final String  hsqldb_log_size      = "hsqldb.log_size";
+      public static final String  hsqldb_nio_data_file = "hsqldb.nio_data_file";
+!     private static final String hsqldb_max_nio_scale = "hsqldb.max_nio_scale";
+!     private static final String hsqldb_original_version =
+          "hsqldb.original_version";
+      public static final String hsqldb_script_format = "hsqldb.script_format";
+  
+      //
+!     private static final String sql_compare_in_locale =
+          "sql.compare_in_locale";
+!     private static final String sql_enforce_strict_size =
+          "sql.enforce_strict_size";
+      public static final String sql_tx_no_multi_write =
+          "sql.tx_no_multi_rewrite";
+--- 89,113 ----
+      public static final String hsqldb_cache_size_scale =
+          "hsqldb.cache_size_scale";
+      public static final String  hsqldb_cache_version = "hsqldb.cache_version";
+!     public static final String hsqldb_catalogs      = "hsqldb.catalogs";
+      public static final String hsqldb_compatible_version =
+          "hsqldb.compatible_version";
+      public static final String hsqldb_default_table_type =
+          "hsqldb.default_table_type";
+      public static final String hsqldb_defrag_limit = "hsqldb.defrag_limit";
+!     public static final String hsqldb_files_readonly =
+          "hsqldb.files_readonly";
+      public static final String  hsqldb_log_size      = "hsqldb.log_size";
+      public static final String  hsqldb_nio_data_file = "hsqldb.nio_data_file";
+!     public static final String hsqldb_max_nio_scale = "hsqldb.max_nio_scale";
+!     public static final String hsqldb_original_version =
+          "hsqldb.original_version";
+      public static final String hsqldb_script_format = "hsqldb.script_format";
+  
+      //
+!     public static final String sql_compare_in_locale =
+          "sql.compare_in_locale";
+!     public static final String sql_enforce_strict_size =
+          "sql.enforce_strict_size";
+      public static final String sql_tx_no_multi_write =
+          "sql.tx_no_multi_rewrite";
+***************
+*** 173,179 ****
+          stringProperties.addAll(stringPropertiesNames);
+      }
+  
+!     private Database database;
+  
+      public HsqlDatabaseProperties(Database db) {
+  
+--- 173,179 ----
+          stringProperties.addAll(stringPropertiesNames);
+      }
+  
+!     public Database database;
+  
+      public HsqlDatabaseProperties(Database db) {
+  
+***************
+*** 300,306 ****
+  
+          boolean exists;
+  
+!         if (database.getType().equals(DatabaseURL.S_MEM)) {
+              return true;
+          }
+  
+--- 300,306 ----
+  
+          boolean exists;
+  
+!         if (!DatabaseURL.isFileBasedDatabaseType(database.getType())) {
+              return true;
+          }
+  
+***************
+*** 366,372 ****
+  
+      public void save() throws HsqlException {
+  
+!         if (database.getType().equals(DatabaseURL.S_MEM)
+                  || database.isFilesReadOnly() || database.isFilesInJar()) {
+              return;
+          }
+--- 366,372 ----
+  
+      public void save() throws HsqlException {
+  
+!         if (!DatabaseURL.isFileBasedDatabaseType(database.getType())
+                  || database.isFilesReadOnly() || database.isFilesInJar()) {
+              return;
+          }
+diff -crN misc/hsqldb/src/org/hsqldb/persist/HsqlProperties.java misc/build/hsqldb/src/org/hsqldb/persist/HsqlProperties.java
+*** misc/hsqldb/src/org/hsqldb/persist/HsqlProperties.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/HsqlProperties.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 57,68 ****
+  public class HsqlProperties {
+  
+      public static final int NO_VALUE_FOR_KEY = 1;
+!     protected String        fileName;
+!     protected Properties    stringProps;
+!     protected int[]         errorCodes = new int[0];
+!     protected String[]      errorKeys  = new String[0];
+!     protected boolean       resource   = false;
+!     protected FileAccess    fa;
+  
+      public HsqlProperties() {
+          stringProps = new Properties();
+--- 57,68 ----
+  public class HsqlProperties {
+  
+      public static final int NO_VALUE_FOR_KEY = 1;
+!     public String        fileName;
+!     public Properties    stringProps;
+!     public int[]         errorCodes = new int[0];
+!     public String[]      errorKeys  = new String[0];
+!     public boolean       resource   = false;
+!     public FileAccess    fa;
+  
+      public HsqlProperties() {
+          stringProps = new Properties();
+***************
+*** 279,285 ****
+       * is populated during construction or addition of elements and is used
+       * outside this class to act upon the errors.
+       */
+!     private void addError(int code, String key) {
+  
+          errorCodes = (int[]) ArrayUtil.resizeArray(errorCodes,
+                  errorCodes.length + 1);
+--- 279,285 ----
+       * is populated during construction or addition of elements and is used
+       * outside this class to act upon the errors.
+       */
+!     public void addError(int code, String key) {
+  
+          errorCodes = (int[]) ArrayUtil.resizeArray(errorCodes,
+                  errorCodes.length + 1);
+diff -crN misc/hsqldb/src/org/hsqldb/persist/LockFile.java misc/build/hsqldb/src/org/hsqldb/persist/LockFile.java
+*** misc/hsqldb/src/org/hsqldb/persist/LockFile.java	2005-10-23 18:26:26.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/LockFile.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 101,107 ****
+   *    </ul>
+   * </ol> <p>
+   *
+!  * In addition to the generic lock and release rules, the protected methods
+   * {@link #lockImpl() lockImpl()} and {@link #releaseImpl() releaseImpl()}
+   * are called during lock and release attempts, respectively.  This allows
+   * transparent, JDK 1.1 compliant integration of extended strategies for
+--- 101,107 ----
+   *    </ul>
+   * </ol> <p>
+   *
+!  * In addition to the generic lock and release rules, the public methods
+   * {@link #lockImpl() lockImpl()} and {@link #releaseImpl() releaseImpl()}
+   * are called during lock and release attempts, respectively.  This allows
+   * transparent, JDK 1.1 compliant integration of extended strategies for
+***************
+*** 156,165 ****
+  public class LockFile {
+  
+      /** Canonical reference to this object's lock file. */
+!     protected File f;
+  
+      /** Cached value of the lock file's canonical path. */
+!     private String cpath = null;
+  
+      /**
+       * A RandomAccessFile constructed from this object's reference, f, to its
+--- 156,165 ----
+  public class LockFile {
+  
+      /** Canonical reference to this object's lock file. */
+!     public File f;
+  
+      /** Cached value of the lock file's canonical path. */
+!     public String cpath = null;
+  
+      /**
+       * A RandomAccessFile constructed from this object's reference, f, to its
+***************
+*** 168,174 ****
+       * This RandomAccessFile is used to periodically write out the heartbeat
+       * timestamp to this object's lock file.
+       */
+!     protected RandomAccessFile raf;
+  
+      /**
+       * The period, in milliseconds, at which heartbeat timestamps are written
+--- 168,174 ----
+       * This RandomAccessFile is used to periodically write out the heartbeat
+       * timestamp to this object's lock file.
+       */
+!     public RandomAccessFile raf;
+  
+      /**
+       * The period, in milliseconds, at which heartbeat timestamps are written
+***************
+*** 183,200 ****
+      public static final byte[] MAGIC = "HSQLLOCK".getBytes();
+  
+      /** Indicates whether this object has a lock condition on its lock file. */
+!     protected boolean locked;
+  
+      /**
+       * The timed scheduler with which to register this object's
+       * heartbeat task.
+       */
+!     protected static final HsqlTimer timer = DatabaseManager.getTimer();
+  
+      /**
+       * An opaque reference to this object's heatbeat task.
+       */
+!     private Object timerTask;
+  
+      /**
+       * Attempts to read the hearbeat timestamp from this object's lock file
+--- 183,200 ----
+      public static final byte[] MAGIC = "HSQLLOCK".getBytes();
+  
+      /** Indicates whether this object has a lock condition on its lock file. */
+!     public boolean locked;
+  
+      /**
+       * The timed scheduler with which to register this object's
+       * heartbeat task.
+       */
+!     public static final HsqlTimer timer = DatabaseManager.getTimer();
+  
+      /**
+       * An opaque reference to this object's heatbeat task.
+       */
+!     public Object timerTask;
+  
+      /**
+       * Attempts to read the hearbeat timestamp from this object's lock file
+***************
+*** 219,225 ****
+       *        or isolated class loader context currently has a
+       *        lock condition on this object's lock file
+       */
+!     private void checkHeartbeat() throws Exception {
+  
+          long   lastHeartbeat;
+          String mn;
+--- 219,225 ----
+       *        or isolated class loader context currently has a
+       *        lock condition on this object's lock file
+       */
+!     public void checkHeartbeat() throws Exception {
+  
+          long   lastHeartbeat;
+          String mn;
+***************
+*** 270,276 ****
+       *
+       * @throws Exception if an IOException occurs
+       */
+!     private void closeRAF() throws Exception {
+  
+          String mn;
+  
+--- 270,276 ----
+       *
+       * @throws Exception if an IOException occurs
+       */
+!     public void closeRAF() throws Exception {
+  
+          String mn;
+  
+***************
+*** 300,306 ****
+       * @param file a reference to the file this object is to use as its
+       *      lock file
+       */
+!     private void setFile(File file) throws Exception {
+  
+          if (isLocked()) {
+              try {
+--- 300,306 ----
+       * @param file a reference to the file this object is to use as its
+       *      lock file
+       */
+!     public void setFile(File file) throws Exception {
+  
+          if (isLocked()) {
+              try {
+***************
+*** 355,361 ****
+       *        actions are taken or the actions succeed,
+       *        else <code>false</code>.
+       */
+!     protected boolean lockImpl() throws Exception {
+  
+          String mn;
+  
+--- 355,361 ----
+       *        actions are taken or the actions succeed,
+       *        else <code>false</code>.
+       */
+!     public boolean lockImpl() throws Exception {
+  
+          String mn;
+  
+***************
+*** 372,378 ****
+       *
+       * @throws Exception if an IOException occurs
+       */
+!     private void openRAF() throws Exception {
+  
+          trace("openRAF(): entered.");
+  
+--- 372,378 ----
+       *
+       * @throws Exception if an IOException occurs
+       */
+!     public void openRAF() throws Exception {
+  
+          trace("openRAF(): entered.");
+  
+***************
+*** 394,400 ****
+       *      file does not exist, Long.MIN_VALUE, the earliest time
+       *      representable as a long in Java,
+       */
+!     private long readHeartbeat() throws Exception {
+  
+          DataInputStream dis;
+          long            heartbeat;
+--- 394,400 ----
+       *      file does not exist, Long.MIN_VALUE, the earliest time
+       *      representable as a long in Java,
+       */
+!     public long readHeartbeat() throws Exception {
+  
+          DataInputStream dis;
+          long            heartbeat;
+***************
+*** 447,453 ****
+       *        to be determined. (e.g. an IO exception
+       *        occurs here).
+       */
+!     protected boolean releaseImpl() throws Exception {
+  
+          trace("releaseImpl(): no action: returning true");
+  
+--- 447,453 ----
+       *        to be determined. (e.g. an IO exception
+       *        occurs here).
+       */
+!     public boolean releaseImpl() throws Exception {
+  
+          trace("releaseImpl(): no action: returning true");
+  
+***************
+*** 455,461 ****
+      }
+  
+      /** Schedules the lock heartbeat task. */
+!     private void startHeartbeat() {
+  
+          Runnable r;
+  
+--- 455,461 ----
+      }
+  
+      /** Schedules the lock heartbeat task. */
+!     public void startHeartbeat() {
+  
+          Runnable r;
+  
+***************
+*** 475,481 ****
+      }
+  
+      /** Cancels the lock heartbeat task. */
+!     private void stopHeartbeat() {
+  
+          String mn = "stopHeartbeat(): ";
+  
+--- 475,481 ----
+      }
+  
+      /** Cancels the lock heartbeat task. */
+!     public void stopHeartbeat() {
+  
+          String mn = "stopHeartbeat(): ";
+  
+***************
+*** 497,503 ****
+       * @throws Exception if the magic value cannot be written to
+       *      the lock file
+       */
+!     private void writeMagic() throws Exception {
+  
+          String mn   = "writeMagic(): ";
+          String path = "lock file [" + cpath + "]";
+--- 497,503 ----
+       * @throws Exception if the magic value cannot be written to
+       *      the lock file
+       */
+!     public void writeMagic() throws Exception {
+  
+          String mn   = "writeMagic(): ";
+          String path = "lock file [" + cpath + "]";
+***************
+*** 517,523 ****
+       * @throws Exception if the current heartbeat timestamp value
+       *      cannot be written
+       */
+!     private void writeHeartbeat() throws Exception {
+  
+          long   time;
+          String mn   = "writeHeartbeat(): ";
+--- 517,523 ----
+       * @throws Exception if the current heartbeat timestamp value
+       *      cannot be written
+       */
+!     public void writeHeartbeat() throws Exception {
+  
+          long   time;
+          String mn   = "writeHeartbeat(): ";
+***************
+*** 752,758 ****
+       * This Runnable class provides the implementation for the timed task
+       * that periodically writes out a heartbeat timestamp to the lock file.<p>
+       */
+!     protected class HeartbeatRunner implements Runnable {
+  
+          public void run() {
+  
+--- 752,758 ----
+       * This Runnable class provides the implementation for the timed task
+       * that periodically writes out a heartbeat timestamp to the lock file.<p>
+       */
+!     public class HeartbeatRunner implements Runnable {
+  
+          public void run() {
+  
+***************
+*** 797,803 ****
+       * @return an implementation-specific tail value for the toString() method
+       * @see #toString
+       */
+!     protected String toStringImpl() {
+          return "";
+      }
+  
+--- 797,803 ----
+       * @return an implementation-specific tail value for the toString() method
+       * @see #toString
+       */
+!     public String toStringImpl() {
+          return "";
+      }
+  
+***************
+*** 954,960 ****
+       *
+       * @param o the value to print
+       */
+!     protected void trace(Object o) {
+  
+          if (Trace.TRACE) {
+              Trace.printSystemOut("[" + super.toString() + "]: " + o);
+--- 954,960 ----
+       *
+       * @param o the value to print
+       */
+!     public void trace(Object o) {
+  
+          if (Trace.TRACE) {
+              Trace.printSystemOut("[" + super.toString() + "]: " + o);
+***************
+*** 969,975 ****
+       *        trying to release the lock condition,
+       *        if any, that it has on its lock file.
+       */
+!     protected void finalize() throws Throwable {
+          trace("finalize(): calling tryRelease()");
+          tryRelease();
+      }
+--- 969,975 ----
+       *        trying to release the lock condition,
+       *        if any, that it has on its lock file.
+       */
+!     public void finalize() throws Throwable {
+          trace("finalize(): calling tryRelease()");
+          tryRelease();
+      }
+diff -crN misc/hsqldb/src/org/hsqldb/persist/Logger.java misc/build/hsqldb/src/org/hsqldb/persist/Logger.java
+*** misc/hsqldb/src/org/hsqldb/persist/Logger.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/Logger.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 98,106 ****
+          appLog = new SimpleLog(path + ".app.log", loglevel,
+                                 !db.isFilesReadOnly());
+  
+!         appLog.sendLine("Database (re)opened: "
+!                         + db.getFileAccess().getClass().getName() + " "
+!                         + HsqlDateTime.getSytemTimeString());
+  
+          logStatements = false;
+  
+--- 98,104 ----
+          appLog = new SimpleLog(path + ".app.log", loglevel,
+                                 !db.isFilesReadOnly());
+  
+!         appLog.sendLine(SimpleLog.LOG_ERROR, "Database (re)opened");
+  
+          logStatements = false;
+  
+***************
+*** 142,149 ****
+  
+          if (log == null) {
+              if (appLog != null) {
+!                 appLog.sendLine("Database closed: "
+!                                 + HsqlDateTime.getSytemTimeString());
+                  appLog.close();
+              }
+  
+--- 140,146 ----
+  
+          if (log == null) {
+              if (appLog != null) {
+!                 appLog.sendLine(SimpleLog.LOG_ERROR, "Database closed");
+                  appLog.close();
+              }
+  
+***************
+*** 168,175 ****
+              }
+          } catch (Throwable e) {
+              if (appLog != null) {
+!                 appLog.sendLine("Database closed: "
+!                                 + HsqlDateTime.getSytemTimeString());
+                  appLog.close();
+              }
+  
+--- 165,171 ----
+              }
+          } catch (Throwable e) {
+              if (appLog != null) {
+!                 appLog.sendLine(SimpleLog.LOG_NORMAL, "Database closed");
+                  appLog.close();
+              }
+  
+***************
+*** 179,186 ****
+          }
+  
+          if (appLog != null) {
+!             appLog.sendLine("Database closed: "
+!                             + HsqlDateTime.getSytemTimeString());
+              appLog.close();
+          }
+  
+--- 175,181 ----
+          }
+  
+          if (appLog != null) {
+!             appLog.sendLine(SimpleLog.LOG_ERROR, "Database closed");
+              appLog.close();
+          }
+  
+diff -crN misc/hsqldb/src/org/hsqldb/persist/Log.java misc/build/hsqldb/src/org/hsqldb/persist/Log.java
+*** misc/hsqldb/src/org/hsqldb/persist/Log.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/Log.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 125,144 ****
+   */
+  public class Log {
+  
+!     private HsqlDatabaseProperties properties;
+!     private String                 fileName;
+!     private Database               database;
+!     private FileAccess             fa;
+!     private ScriptWriterBase       dbLogWriter;
+!     private String                 scriptFileName;
+!     private String                 cacheFileName;
+!     private String                 backupFileName;
+!     private String                 logFileName;
+!     private boolean                filesReadOnly;
+!     private long                   maxLogSize;
+!     private int                    writeDelay;
+!     private int                    scriptFormat;
+!     private DataFileCache          cache;
+  
+      Log(Database db) throws HsqlException {
+  
+--- 125,144 ----
+   */
+  public class Log {
+  
+!     public HsqlDatabaseProperties properties;
+!     public String                 fileName;
+!     public Database               database;
+!     public FileAccess             fa;
+!     public ScriptWriterBase       dbLogWriter;
+!     public String                 scriptFileName;
+!     public String                 cacheFileName;
+!     public String                 backupFileName;
+!     public String                 logFileName;
+!     public boolean                filesReadOnly;
+!     public long                   maxLogSize;
+!     public int                    writeDelay;
+!     public int                    scriptFormat;
+!     public DataFileCache          cache;
+  
+      Log(Database db) throws HsqlException {
+  
+***************
+*** 550,556 ****
+       * Wrappers for openning-starting / stoping-closing the log file and
+       * writer.
+       */
+!     private void openLog() throws HsqlException {
+  
+          if (filesReadOnly) {
+              return;
+--- 550,556 ----
+       * Wrappers for openning-starting / stoping-closing the log file and
+       * writer.
+       */
+!     public void openLog() throws HsqlException {
+  
+          if (filesReadOnly) {
+              return;
+***************
+*** 568,574 ****
+          }
+      }
+  
+!     private synchronized void closeLog() throws HsqlException {
+  
+          if (dbLogWriter != null) {
+              dbLogWriter.close();
+--- 568,574 ----
+          }
+      }
+  
+!     public synchronized void closeLog() throws HsqlException {
+  
+          if (dbLogWriter != null) {
+              dbLogWriter.close();
+***************
+*** 578,584 ****
+      /**
+       * Write the .script file as .script.new.
+       */
+!     private void writeScript(boolean full) throws HsqlException {
+  
+          String sNewName = scriptFileName + ".new";
+  
+--- 578,584 ----
+      /**
+       * Write the .script file as .script.new.
+       */
+!     public void writeScript(boolean full) throws HsqlException {
+  
+          String sNewName = scriptFileName + ".new";
+  
+***************
+*** 601,607 ****
+      /**
+       * Performs all the commands in the .script file.
+       */
+!     private void processScript() throws HsqlException {
+  
+          ScriptReaderBase scr = null;
+  
+--- 601,607 ----
+      /**
+       * Performs all the commands in the .script file.
+       */
+!     public void processScript() throws HsqlException {
+  
+          ScriptReaderBase scr = null;
+  
+***************
+*** 644,650 ****
+      /**
+       * Defrag large data files when the sum of .log and .data files is large.
+       */
+!     private void processDataFile() throws HsqlException {
+  
+          if (cache == null || filesReadOnly || database.isStoredFileAccess()
+                  ||!fa.isStreamElement(logFileName)) {
+--- 644,650 ----
+      /**
+       * Defrag large data files when the sum of .log and .data files is large.
+       */
+!     public void processDataFile() throws HsqlException {
+  
+          if (cache == null || filesReadOnly || database.isStoredFileAccess()
+                  ||!fa.isStreamElement(logFileName)) {
+***************
+*** 663,669 ****
+      /**
+       * Performs all the commands in the .log file.
+       */
+!     private void processLog() throws HsqlException {
+  
+          if (!database.isFilesInJar() && fa.isStreamElement(logFileName)) {
+              ScriptRunner.runScript(database, logFileName,
+--- 663,669 ----
+      /**
+       * Performs all the commands in the .log file.
+       */
+!     public void processLog() throws HsqlException {
+  
+          if (!database.isFilesInJar() && fa.isStreamElement(logFileName)) {
+              ScriptRunner.runScript(database, logFileName,
+***************
+*** 674,680 ****
+      /**
+       * Restores a compressed backup or the .data file.
+       */
+!     private void restoreBackup() throws HsqlException {
+  
+          // in case data file cannot be deleted, reset it
+          DataFileCache.deleteOrResetFreePos(database, cacheFileName);
+--- 674,680 ----
+      /**
+       * Restores a compressed backup or the .data file.
+       */
+!     public void restoreBackup() throws HsqlException {
+  
+          // in case data file cannot be deleted, reset it
+          DataFileCache.deleteOrResetFreePos(database, cacheFileName);
+***************
+*** 691,697 ****
+      }
+  
+  // fredt@users 20020221 - patch 513005 by sqlbob@users (RMP) - text tables
+!     private HashMap textCacheList = new HashMap();
+  
+      DataFileCache openTextCache(Table table, String source,
+                                  boolean readOnlyData,
+--- 691,697 ----
+      }
+  
+  // fredt@users 20020221 - patch 513005 by sqlbob@users (RMP) - text tables
+!     public HashMap textCacheList = new HashMap();
+  
+      DataFileCache openTextCache(Table table, String source,
+                                  boolean readOnlyData,
+***************
+*** 738,744 ****
+          }
+      }
+  
+!     private void closeAllTextCaches(boolean compact) throws HsqlException {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+--- 738,744 ----
+          }
+      }
+  
+!     public void closeAllTextCaches(boolean compact) throws HsqlException {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+***************
+*** 751,757 ****
+          }
+      }
+  
+!     private void reopenAllTextCaches() throws HsqlException {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+--- 751,757 ----
+          }
+      }
+  
+!     public void reopenAllTextCaches() throws HsqlException {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+***************
+*** 760,766 ****
+          }
+      }
+  
+!     private boolean isAnyTextCacheModified() {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+--- 760,766 ----
+          }
+      }
+  
+!     public boolean isAnyTextCacheModified() {
+  
+          Iterator it = textCacheList.values().iterator();
+  
+diff -crN misc/hsqldb/src/org/hsqldb/persist/NIOLockFile.java misc/build/hsqldb/src/org/hsqldb/persist/NIOLockFile.java
+*** misc/hsqldb/src/org/hsqldb/persist/NIOLockFile.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/NIOLockFile.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 61,73 ****
+       * The <code>fc</code> attribute is used to obtain this object's
+       * {@link #fl FileLock} attribute.
+       */
+!     private FileChannel fc;
+  
+      /**
+       * The <code>FileLock</code> object used to lock this object's
+       * lock file.
+       */
+!     private FileLock fl;
+  
+      /**
+       * Tries to obtain a valid NIO lock upon this object's lock file using
+--- 61,73 ----
+       * The <code>fc</code> attribute is used to obtain this object's
+       * {@link #fl FileLock} attribute.
+       */
+!     public FileChannel fc;
+  
+      /**
+       * The <code>FileLock</code> object used to lock this object's
+       * lock file.
+       */
+!     public FileLock fl;
+  
+      /**
+       * Tries to obtain a valid NIO lock upon this object's lock file using
+***************
+*** 77,83 ****
+       * @throws Exception if an error occurs while attempting to obtain the lock
+       *
+       */
+!     protected boolean lockImpl() throws Exception {
+  
+          boolean isValid;
+  
+--- 77,83 ----
+       * @throws Exception if an error occurs while attempting to obtain the lock
+       *
+       */
+!     public boolean lockImpl() throws Exception {
+  
+          boolean isValid;
+  
+***************
+*** 154,160 ****
+       * @return true if a valid lock is released, else false
+       * @throws Exception if na error occurs while attempting to release the lock
+       */
+!     protected boolean releaseImpl() throws Exception {
+  
+          // PRE: we know that this method is only called
+          // if isLocked() is true.
+--- 154,160 ----
+       * @return true if a valid lock is released, else false
+       * @throws Exception if na error occurs while attempting to release the lock
+       */
+!     public boolean releaseImpl() throws Exception {
+  
+          // PRE: we know that this method is only called
+          // if isLocked() is true.
+***************
+*** 200,206 ****
+       * Retrieves the String value: "fl =" + fl
+       * @return the String value: "fl =" + fl
+       */
+!     protected String toStringImpl() {
+          return "fl =" + fl;
+      }
+  }
+--- 200,206 ----
+       * Retrieves the String value: "fl =" + fl
+       * @return the String value: "fl =" + fl
+       */
+!     public String toStringImpl() {
+          return "fl =" + fl;
+      }
+  }
+diff -crN misc/hsqldb/src/org/hsqldb/persist/NIOScaledRAFile.java misc/build/hsqldb/src/org/hsqldb/persist/NIOScaledRAFile.java
+*** misc/hsqldb/src/org/hsqldb/persist/NIOScaledRAFile.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/NIOScaledRAFile.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 53,64 ****
+   */
+  class NIOScaledRAFile extends ScaledRAFile {
+  
+!     MappedByteBuffer  buffer;
+!     FileChannel       channel;
+!     long              bufferLength;
+!     private boolean   wasNio;
+!     private boolean   bufferModified;
+!     static final long MAX_NIO_LENGTH = (1L << 28);
+  
+      /**
+       * Public constructor for access by reflection
+--- 53,63 ----
+   */
+  class NIOScaledRAFile extends ScaledRAFile {
+  
+!     MappedByteBuffer buffer;
+!     FileChannel      channel;
+!     long             bufferLength;
+!     public boolean  wasNio;
+!     public boolean  bufferModified;
+  
+      /**
+       * Public constructor for access by reflection
+***************
+*** 84,90 ****
+      }
+  
+      /** @todo fredt - better message */
+!     private long newBufferSize(long newsize) throws IOException {
+  
+          long bufsize;
+  
+--- 83,89 ----
+      }
+  
+      /** @todo fredt - better message */
+!     public long newBufferSize(long newsize) throws IOException {
+  
+          long bufsize;
+  
+***************
+*** 99,105 ****
+          return bufsize;
+      }
+  
+!     private void enlargeBuffer(long offset, int size) throws IOException {
+  
+          int position = 0;
+  
+--- 98,104 ----
+          return bufsize;
+      }
+  
+!     public void enlargeBuffer(long offset, int size) throws IOException {
+  
+          int position = 0;
+  
+diff -crN misc/hsqldb/src/org/hsqldb/persist/ScaledRAFileInJar.java misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFileInJar.java
+*** misc/hsqldb/src/org/hsqldb/persist/ScaledRAFileInJar.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFileInJar.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 92,98 ****
+          return seekPosition;
+      }
+  
+!     private void readIntoBuffer() throws IOException {
+  
+          long filePos = seekPosition;
+  
+--- 92,98 ----
+          return seekPosition;
+      }
+  
+!     public void readIntoBuffer() throws IOException {
+  
+          long filePos = seekPosition;
+  
+***************
+*** 206,212 ****
+          return false;
+      }
+  
+!     private void resetStream() throws IOException {
+  
+          if (file != null) {
+              file.close();
+--- 206,212 ----
+          return false;
+      }
+  
+!     public void resetStream() throws IOException {
+  
+          if (file != null) {
+              file.close();
+***************
+*** 217,223 ****
+          file = new DataInputStream(fis);
+      }
+  
+!     private void fileSeek(long position) throws IOException {
+  
+          long skipPosition = realPosition;
+  
+--- 217,223 ----
+          file = new DataInputStream(fis);
+      }
+  
+!     public void fileSeek(long position) throws IOException {
+  
+          long skipPosition = realPosition;
+  
+diff -crN misc/hsqldb/src/org/hsqldb/persist/ScaledRAFile.java misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFile.java
+*** misc/hsqldb/src/org/hsqldb/persist/ScaledRAFile.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFile.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 53,63 ****
+   */
+  class ScaledRAFile implements Storage {
+  
+!     static final int         DATA_FILE_RAF = 0;
+!     static final int         DATA_FILE_NIO = 1;
+!     static final int         DATA_FILE_JAR = 2;
+      final RandomAccessFile   file;
+!     private final boolean    readOnly;
+      final String             fileName;
+      boolean                  isNio;
+      boolean                  bufferDirty = true;
+--- 53,64 ----
+   */
+  class ScaledRAFile implements Storage {
+  
+!     static final int         DATA_FILE_RAF  = 0;
+!     static final int         DATA_FILE_NIO  = 1;
+!     static final int         DATA_FILE_JAR  = 2;
+!     static final long        MAX_NIO_LENGTH = (1L << 28);
+      final RandomAccessFile   file;
+!     public final boolean    readOnly;
+      final String             fileName;
+      boolean                  isNio;
+      boolean                  bufferDirty = true;
+***************
+*** 107,112 ****
+--- 108,122 ----
+          } else if (type == DATA_FILE_RAF) {
+              return new ScaledRAFile(name, readonly);
+          } else {
++             RandomAccessFile file = new RandomAccessFile(name, readonly ? "r"
++                                                                         : "rw");
++ 
++             if (file.length() > MAX_NIO_LENGTH) {
++                 return new ScaledRAFile(name, file, readonly);
++             } else {
++                 file.close();
++             }
++ 
+              try {
+                  Class.forName("java.nio.MappedByteBuffer");
+  
+***************
+*** 124,129 ****
+--- 134,147 ----
+          }
+      }
+  
++     ScaledRAFile(String name, RandomAccessFile file,
++                  boolean readonly) throws FileNotFoundException, IOException {
++ 
++         this.readOnly = readonly;
++         fileName      = name;
++         this.file     = file;
++     }
++ 
+      ScaledRAFile(String name,
+                   boolean readonly) throws FileNotFoundException, IOException {
+  
+***************
+*** 159,165 ****
+          return seekPosition;
+      }
+  
+!     private void readIntoBuffer() throws IOException {
+  
+          long filePos = seekPosition;
+  
+--- 177,183 ----
+          return seekPosition;
+      }
+  
+!     public void readIntoBuffer() throws IOException {
+  
+          long filePos = seekPosition;
+  
+diff -crN misc/hsqldb/src/org/hsqldb/persist/ScriptRunner.java misc/build/hsqldb/src/org/hsqldb/persist/ScriptRunner.java
+*** misc/hsqldb/src/org/hsqldb/persist/ScriptRunner.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/ScriptRunner.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 38,43 ****
+--- 38,44 ----
+  import org.hsqldb.Session;
+  import org.hsqldb.Trace;
+  import org.hsqldb.lib.IntKeyHashMap;
++ import org.hsqldb.lib.SimpleLog;
+  import org.hsqldb.lib.StopWatch;
+  import org.hsqldb.scriptio.ScriptReaderBase;
+  import org.hsqldb.scriptio.ScriptWriterBase;
+***************
+*** 103,109 ****
+                      continue;
+                  }
+  
+-                 String schema = current.currentSchema.name;
+                  Result result = null;
+  
+                  switch (scr.getStatementType()) {
+--- 104,109 ----
+***************
+*** 164,170 ****
+                  message = "out of memory processing " + logFilename
+                            + " line: " + scr.getLineNumber();
+  
+!                 database.logger.appLog.logContext(message);
+  
+                  throw Trace.error(Trace.OUT_OF_MEMORY);
+              }
+--- 164,171 ----
+                  message = "out of memory processing " + logFilename
+                            + " line: " + scr.getLineNumber();
+  
+!                 database.logger.appLog.logContext(SimpleLog.LOG_ERROR,
+!                                                   message);
+  
+                  throw Trace.error(Trace.OUT_OF_MEMORY);
+              }
+***************
+*** 173,179 ****
+              message = logFilename + " line: " + scr.getLineNumber() + " "
+                        + e.getMessage();
+  
+!             database.logger.appLog.logContext(message);
+              Trace.printSystemOut(message);
+          } finally {
+              if (scr != null) {
+--- 174,180 ----
+              message = logFilename + " line: " + scr.getLineNumber() + " "
+                        + e.getMessage();
+  
+!             database.logger.appLog.logContext(SimpleLog.LOG_ERROR, message);
+              Trace.printSystemOut(message);
+          } finally {
+              if (scr != null) {
+diff -crN misc/hsqldb/src/org/hsqldb/persist/TextCache.java misc/build/hsqldb/src/org/hsqldb/persist/TextCache.java
+*** misc/hsqldb/src/org/hsqldb/persist/TextCache.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/persist/TextCache.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 74,82 ****
+      public boolean             isQuoted;
+      public boolean             isAllQuoted;
+      public boolean             ignoreFirst;
+!     protected String           header;
+!     protected Table            table;
+!     private ObjectCacheHashMap uncommittedCache;
+  
+      //
+  
+--- 74,82 ----
+      public boolean             isQuoted;
+      public boolean             isAllQuoted;
+      public boolean             ignoreFirst;
+!     public String           header;
+!     public Table            table;
+!     public ObjectCacheHashMap uncommittedCache;
+  
+      //
+  
+***************
+*** 96,102 ****
+          uncommittedCache = new ObjectCacheHashMap(5);
+      }
+  
+!     protected void initParams() throws HsqlException {
+  
+          // fredt - this used to write rows as soon as they are inserted
+          // but now this is subject to session autoCommit / or commit
+--- 96,102 ----
+          uncommittedCache = new ObjectCacheHashMap(5);
+      }
+  
+!     public void initParams() throws HsqlException {
+  
+          // fredt - this used to write rows as soon as they are inserted
+          // but now this is subject to session autoCommit / or commit
+***************
+*** 175,181 ****
+          cacheFileScale   = 1;
+      }
+  
+!     protected void initBuffers() {
+  
+          if (isQuoted || isAllQuoted) {
+              rowIn = new RowInputTextQuoted(fs, vs, lvs, isAllQuoted);
+--- 175,181 ----
+          cacheFileScale   = 1;
+      }
+  
+!     public void initBuffers() {
+  
+          if (isQuoted || isAllQuoted) {
+              rowIn = new RowInputTextQuoted(fs, vs, lvs, isAllQuoted);
+***************
+*** 187,193 ****
+          }
+      }
+  
+!     private String translateSep(String sep) {
+          return translateSep(sep, false);
+      }
+  
+--- 187,193 ----
+          }
+      }
+  
+!     public String translateSep(String sep) {
+          return translateSep(sep, false);
+      }
+  
+***************
+*** 195,201 ****
+       * Translates the escaped characters in a separator string and returns
+       * the non-escaped string.
+       */
+!     private String translateSep(String sep, boolean isProperty) {
+  
+          if (sep == null) {
+              return (null);
+--- 195,201 ----
+       * Translates the escaped characters in a separator string and returns
+       * the non-escaped string.
+       */
+!     public String translateSep(String sep, boolean isProperty) {
+  
+          if (sep == null) {
+              return (null);
+***************
+*** 392,398 ****
+          release(pos);
+      }
+  
+!     private void clearRowImage(CachedObject row) throws IOException {
+  
+          int length = row.getStorageSize()
+                       - ScriptWriterText.BYTES_LINE_SEP.length;
+--- 392,398 ----
+          release(pos);
+      }
+  
+!     public void clearRowImage(CachedObject row) throws IOException {
+  
+          int length = row.getStorageSize()
+                       - ScriptWriterText.BYTES_LINE_SEP.length;
+***************
+*** 422,428 ****
+      }
+  
+      // sqlbob -- Allow line breaks in quoted fields.
+!     protected synchronized RowInputInterface readObject(int pos)
+      throws IOException {
+  
+          ByteArray    buffer    = new ByteArray(80);
+--- 422,428 ----
+      }
+  
+      // sqlbob -- Allow line breaks in quoted fields.
+!     public synchronized RowInputInterface readObject(int pos)
+      throws IOException {
+  
+          ByteArray    buffer    = new ByteArray(80);
+***************
+*** 618,624 ****
+       * uncommitted cache until such time that they are committed or rolled
+       * back- fredt
+       */
+!     protected synchronized void saveRows(CachedObject[] rows, int offset,
+                                           int count) throws IOException {
+  
+          if (count == 0) {
+--- 618,624 ----
+       * uncommitted cache until such time that they are committed or rolled
+       * back- fredt
+       */
+!     public synchronized void saveRows(CachedObject[] rows, int offset,
+                                           int count) throws IOException {
+  
+          if (count == 0) {
+***************
+*** 666,672 ****
+          throw Trace.error(Trace.TEXT_TABLE_HEADER);
+      }
+  
+!     private void writeHeader(String header) throws IOException {
+  
+          byte[] buf       = null;
+          String firstLine = header + NL;
+--- 666,672 ----
+          throw Trace.error(Trace.TEXT_TABLE_HEADER);
+      }
+  
+!     public void writeHeader(String header) throws IOException {
+  
+          byte[] buf       = null;
+          String firstLine = header + NL;
+***************
+*** 682,691 ****
+          fileFreePosition = firstLine.length();
+      }
+  
+!     private class ByteArray {
+  
+!         private byte[] buffer;
+!         private int    buflen;
+  
+          public ByteArray(int n) {
+              buffer = new byte[n];
+--- 682,691 ----
+          fileFreePosition = firstLine.length();
+      }
+  
+!     public class ByteArray {
+  
+!         public byte[] buffer;
+!         public int    buflen;
+  
+          public ByteArray(int n) {
+              buffer = new byte[n];
+***************
+*** 729,735 ****
+          return ((RowInputText) rowIn).getLineNumber();
+      }
+  
+!     protected void setFileModified() throws IOException {
+          fileModified = true;
+      }
+  }
+--- 729,735 ----
+          return ((RowInputText) rowIn).getLineNumber();
+      }
+  
+!     public void setFileModified() throws IOException {
+          fileModified = true;
+      }
+  }
+diff -crN misc/hsqldb/src/org/hsqldb/PointerNode.java misc/build/hsqldb/src/org/hsqldb/PointerNode.java
+*** misc/hsqldb/src/org/hsqldb/PointerNode.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/PointerNode.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 87,94 ****
+  class PointerNode extends BaseMemoryNode {
+  
+      int           iData = NO_POS;
+!     private Table tTable;
+!     private Node  nPrimary;    // node of key / primary index for this row
+  
+      PointerNode(CachedRow r, int id) {
+  
+--- 87,94 ----
+  class PointerNode extends BaseMemoryNode {
+  
+      int           iData = NO_POS;
+!     public Table tTable;
+!     public Node  nPrimary;    // node of key / primary index for this row
+  
+      PointerNode(CachedRow r, int id) {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/resources/BundleHandler.java misc/build/hsqldb/src/org/hsqldb/resources/BundleHandler.java
+*** misc/hsqldb/src/org/hsqldb/resources/BundleHandler.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/resources/BundleHandler.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 58,85 ****
+  public final class BundleHandler {
+  
+      /** Used to synchronize access */
+!     private static final Object mutex = new Object();
+  
+      /** The Locale used internally to fetch resource bundles. */
+!     private static Locale locale = Locale.getDefault();
+  
+      /** Map:  Integer object handle => <code>ResourceBundle</code> object. */
+!     private static HashMap bundleHandleMap = new HashMap();
+  
+      /** List whose elements are <code>ResourceBundle</code> objects */
+!     private static HsqlArrayList bundleList = new HsqlArrayList();
+  
+      /**
+       * The resource path prefix of the <code>ResourceBundle</code> objects
+       * handled by this class.
+       */
+!     private static final String prefix = "org/hsqldb/resources/";
+  
+      /** JDK 1.1 compliance */
+!     private static final Method newGetBundleMethod = getNewGetBundleMethod();
+  
+      /** Pure utility class: external construction disabled. */
+!     private BundleHandler() {}
+  
+      /**
+       * Getter for property locale. <p>
+--- 58,85 ----
+  public final class BundleHandler {
+  
+      /** Used to synchronize access */
+!     public static final Object mutex = new Object();
+  
+      /** The Locale used internally to fetch resource bundles. */
+!     public static Locale locale = Locale.getDefault();
+  
+      /** Map:  Integer object handle => <code>ResourceBundle</code> object. */
+!     public static HashMap bundleHandleMap = new HashMap();
+  
+      /** List whose elements are <code>ResourceBundle</code> objects */
+!     public static HsqlArrayList bundleList = new HsqlArrayList();
+  
+      /**
+       * The resource path prefix of the <code>ResourceBundle</code> objects
+       * handled by this class.
+       */
+!     public static final String prefix = "org/hsqldb/resources/";
+  
+      /** JDK 1.1 compliance */
+!     public static final Method newGetBundleMethod = getNewGetBundleMethod();
+  
+      /** Pure utility class: external construction disabled. */
+!     public BundleHandler() {}
+  
+      /**
+       * Getter for property locale. <p>
+***************
+*** 197,203 ****
+       * One-shot initialization of JDK 1.2+ ResourceBundle.getBundle() method
+       * having ClassLoader in the signature.
+       */
+!     private static Method getNewGetBundleMethod() {
+  
+          Class   clazz;
+          Class[] args;
+--- 197,203 ----
+       * One-shot initialization of JDK 1.2+ ResourceBundle.getBundle() method
+       * having ClassLoader in the signature.
+       */
+!     public static Method getNewGetBundleMethod() {
+  
+          Class   clazz;
+          Class[] args;
+diff -crN misc/hsqldb/src/org/hsqldb/resources/sql-error-messages_it.properties misc/build/hsqldb/src/org/hsqldb/resources/sql-error-messages_it.properties
+*** misc/hsqldb/src/org/hsqldb/resources/sql-error-messages_it.properties	2006-11-03 20:01:50.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/resources/sql-error-messages_it.properties	2006-11-03 20:05:44.000000000 +0100
+***************
+*** 1,6 ****
+  # Copyright 2005 HSQL Developers Group
+  # can be distributed and used according to HSQLDB License
+! # see http://hsqldb.sourceforge.net
+  # Italian translation by Nicola Pedot (http://www.jugtrento.org/)
+  # JRC-Editor by http://zavel.org
+  000=NOT USED
+--- 1,6 ----
+  # Copyright 2005 HSQL Developers Group
+  # can be distributed and used according to HSQLDB License
+! # see http://hsqldb.org
+  # Italian translation by Nicola Pedot (http://www.jugtrento.org/)
+  # JRC-Editor by http://zavel.org
+  000=NOT USED
+***************
+*** 108,114 ****
+  102=colonna duplicata nella lista
+  103=tabella senza chiave primaria
+  104=23000 Violazione del vincolo di unicit\u00e0
+! 105=manca il valore DEFAULT sulla colonna $$
+  106=S1000 valore NULL come BOOLEAN
+  107=tentativo di connessione mentre l'archivio si stava aprendo/chiudendo
+  108=NA
+--- 108,114 ----
+  102=colonna duplicata nella lista
+  103=tabella senza chiave primaria
+  104=23000 Violazione del vincolo di unicit\u00e0
+! 105=S2001 manca il valore DEFAULT sulla colonna $$
+  106=S1000 valore NULL come BOOLEAN
+  107=tentativo di connessione mentre l'archivio si stava aprendo/chiudendo
+  108=NA
+***************
+*** 200,206 ****
+  194=23000 Tabella referenziata dalla vista
+  195=NA
+  196=S1000 Testo sorgente gi\u00e0 esistente
+! 197=23000 Colonna referenziata nel vincolo
+  198=S1000 Errore nella chiamata alla funzione
+  199=27000 Violazione nel cambio di dati da trigger
+  200=37000 Argomento non valido
+--- 200,206 ----
+  194=23000 Tabella referenziata dalla vista
+  195=NA
+  196=S1000 Testo sorgente gi\u00e0 esistente
+! 197=23000 Colonna referenziata nel vincolo o vista
+  198=S1000 Errore nella chiamata alla funzione
+  199=27000 Violazione nel cambio di dati da trigger
+  200=37000 Argomento non valido
+diff -crN misc/hsqldb/src/org/hsqldb/resources/sql-error-messages.properties misc/build/hsqldb/src/org/hsqldb/resources/sql-error-messages.properties
+*** misc/hsqldb/src/org/hsqldb/resources/sql-error-messages.properties	2005-11-06 23:07:20.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/resources/sql-error-messages.properties	2006-11-03 20:05:44.000000000 +0100
+***************
+*** 23,29 ****
+  019=40001 Transfer corrupted
+  020=IM001 This function is not supported
+  021=S0001 Table already exists
+! 022=S0002 Table not found
+  023=S0011 Index already exists
+  024=S0011 Attempt to define a second primary key
+  025=S0011 Attempt to drop the primary key
+--- 23,29 ----
+  019=40001 Transfer corrupted
+  020=IM001 This function is not supported
+  021=S0001 Table already exists
+! 022=S0002 Table '$$' not found
+  023=S0011 Index already exists
+  024=S0011 Attempt to define a second primary key
+  025=S0011 Attempt to drop the primary key
+***************
+*** 54,60 ****
+  050=S0011 Attempt to drop a foreign key index
+  051=S1000 ResultSet was set to forward only
+  052=S0003 View already exists
+! 053=S0004 View not found
+  054=S0005 NA
+  055=S0005 Not a Table
+  056=S0011 Attempt to drop or rename a system index
+--- 54,60 ----
+  050=S0011 Attempt to drop a foreign key index
+  051=S1000 ResultSet was set to forward only
+  052=S0003 View already exists
+! 053=S0004 View '$$' not found
+  054=S0005 NA
+  055=S0005 Not a Table
+  056=S0011 Attempt to drop or rename a system index
+***************
+*** 106,112 ****
+  102=duplicate column in list
+  103=table has no primary key
+  104=23000 Unique constraint violation
+! 105=missing DEFAULT value on column $$
+  106=S1000 NULL value as BOOLEAN
+  107=attempt to connect while db opening /closing
+  108=NA
+--- 106,112 ----
+  102=duplicate column in list
+  103=table has no primary key
+  104=23000 Unique constraint violation
+! 105=S0021 missing DEFAULT value on column $$
+  106=S1000 NULL value as BOOLEAN
+  107=attempt to connect while db opening /closing
+  108=NA
+***************
+*** 139,145 ****
+  135=properties name is null or empty
+  136=Server certificate has no Common Name
+  137=Server certificate has empty Common Name
+! 138=Unknown JDBC escape sequence: {
+  139=Certificate Common Name[$$] does not match host name[$$]
+  140=NA
+  141=NA
+--- 139,145 ----
+  135=properties name is null or empty
+  136=Server certificate has no Common Name
+  137=Server certificate has empty Common Name
+! 138=Unknown JDBC escape sequence: $$
+  139=Certificate Common Name[$$] does not match host name[$$]
+  140=NA
+  141=NA
+***************
+*** 198,204 ****
+  194=23000 Table is referenced by view
+  195=NA
+  196=S1000 Text source file already exists
+! 197=23000 Column is referenced in constraint
+  198=S1000 Error calling function
+  199=27000 Triggered data change violation
+  200=37000 Invalid argument
+--- 198,204 ----
+  194=23000 Table is referenced by view
+  195=NA
+  196=S1000 Text source file already exists
+! 197=23000 Column is referenced in constraint or view
+  198=S1000 Error calling function
+  199=27000 Triggered data change violation
+  200=37000 Invalid argument
+diff -crN misc/hsqldb/src/org/hsqldb/ResultBase.java misc/build/hsqldb/src/org/hsqldb/ResultBase.java
+*** misc/hsqldb/src/org/hsqldb/ResultBase.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/ResultBase.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 41,48 ****
+  public class ResultBase {
+  
+      public Record    rRoot;
+!     protected Record rTail;
+!     protected int    iSize;
+  
+      public ResultBase() {}
+  
+--- 41,48 ----
+  public class ResultBase {
+  
+      public Record    rRoot;
+!     public Record rTail;
+!     public int    iSize;
+  
+      public ResultBase() {}
+  
+diff -crN misc/hsqldb/src/org/hsqldb/Result.java misc/build/hsqldb/src/org/hsqldb/Result.java
+*** misc/hsqldb/src/org/hsqldb/Result.java	2005-10-23 17:40:16.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Result.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 102,112 ****
+  
+      // record list
+      public Record  rRoot;
+!     private Record rTail;
+!     private int    size;
+  
+      // transient - number of significant columns
+!     private int significantColumns;
+  
+      // type of result
+      public int mode;
+--- 102,112 ----
+  
+      // record list
+      public Record  rRoot;
+!     public Record rTail;
+!     public int    size;
+  
+      // transient - number of significant columns
+!     public int significantColumns;
+  
+      // type of result
+      public int mode;
+***************
+*** 126,132 ****
+      String subSubString;
+  
+      // the exception if this is an error
+!     private Throwable exception;
+  
+      // prepared statement id / error vendor code
+      int statementID;
+--- 126,132 ----
+      String subSubString;
+  
+      // the exception if this is an error
+!     public Throwable exception;
+  
+      // prepared statement id / error vendor code
+      int statementID;
+***************
+*** 174,180 ****
+           *
+           * @param  columns
+           */
+!         private void prepareData(int columns) {
+  
+              colLabels     = new String[columns];
+              tableNames    = new String[columns];
+--- 174,180 ----
+           *
+           * @param  columns
+           */
+!         public void prepareData(int columns) {
+  
+              colLabels     = new String[columns];
+              tableNames    = new String[columns];
+***************
+*** 200,213 ****
+                     && colNames[i] != null && colNames[i].length() > 0;
+          }
+  
+!         private void decodeTableColumnAttrs(int in, int i) {
+  
+              colNullable[i] = in & 0x0000000f;
+              isIdentity[i]  = (in & 0x00000010) != 0;
+              isWritable[i]  = (in & 0x00000020) != 0;
+          }
+  
+!         private void writeTableColumnAttrs(RowOutputBinary out,
+                                             int i)
+                                             throws IOException, HsqlException {
+  
+--- 200,213 ----
+                     && colNames[i] != null && colNames[i].length() > 0;
+          }
+  
+!         public void decodeTableColumnAttrs(int in, int i) {
+  
+              colNullable[i] = in & 0x0000000f;
+              isIdentity[i]  = (in & 0x00000010) != 0;
+              isWritable[i]  = (in & 0x00000020) != 0;
+          }
+  
+!         public void writeTableColumnAttrs(RowOutputBinary out,
+                                             int i)
+                                             throws IOException, HsqlException {
+  
+***************
+*** 255,261 ****
+                                                     : schemaNames[i]);
+          }
+  
+!         private int encodeTableColumnAttrs(int i) {
+  
+              int out = colNullable[i];    // always between 0x00 and 0x02
+  
+--- 255,261 ----
+                                                     : schemaNames[i]);
+          }
+  
+!         public int encodeTableColumnAttrs(int i) {
+  
+              int out = colNullable[i];    // always between 0x00 and 0x02
+  
+***************
+*** 270,276 ****
+              return out;
+          }
+  
+!         private void readTableColumnAttrs(RowInputBinary in,
+                                            int i)
+                                            throws IOException, HsqlException {
+  
+--- 270,276 ----
+              return out;
+          }
+  
+!         public void readTableColumnAttrs(RowInputBinary in,
+                                            int i)
+                                            throws IOException, HsqlException {
+  
+***************
+*** 1082,1088 ****
+       * @return -1, 0, +1
+       * @throws  HsqlException
+       */
+!     private int compareRecord(Session session, Object[] a, final Object[] b,
+                                final int[] order,
+                                int[] way) throws HsqlException {
+  
+--- 1082,1088 ----
+       * @return -1, 0, +1
+       * @throws  HsqlException
+       */
+!     public int compareRecord(Session session, Object[] a, final Object[] b,
+                                final int[] order,
+                                int[] way) throws HsqlException {
+  
+***************
+*** 1112,1118 ****
+       * @return -1, 0, +1
+       * @throws  HsqlException
+       */
+!     private int compareRecord(Session session, Object[] a, Object[] b,
+                                int len) throws HsqlException {
+  
+          for (int j = 0; j < len; j++) {
+--- 1112,1118 ----
+       * @return -1, 0, +1
+       * @throws  HsqlException
+       */
+!     public int compareRecord(Session session, Object[] a, Object[] b,
+                                int len) throws HsqlException {
+  
+          for (int j = 0; j < len; j++) {
+***************
+*** 1306,1312 ****
+          }
+      }
+  
+!     private void writeMulti(RowOutputBinary out)
+      throws IOException, HsqlException {
+  
+          int startPos = out.size();
+--- 1306,1312 ----
+          }
+      }
+  
+!     public void writeMulti(RowOutputBinary out)
+      throws IOException, HsqlException {
+  
+          int startPos = out.size();
+***************
+*** 1489,1495 ****
+          return new ResultIterator();
+      }
+  
+!     private class ResultIterator implements Iterator {
+  
+          boolean removed;
+          int     counter;
+--- 1489,1495 ----
+          return new ResultIterator();
+      }
+  
+!     public class ResultIterator implements Iterator {
+  
+          boolean removed;
+          int     counter;
+diff -crN misc/hsqldb/src/org/hsqldb/rowio/RowInputBase.java misc/build/hsqldb/src/org/hsqldb/rowio/RowInputBase.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowInputBase.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowInputBase.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 58,65 ****
+      static final int NO_POS = -1;
+  
+      // fredt - initialisation may be unnecessary as it's done in resetRow()
+!     protected int filePos = NO_POS;
+!     protected int size;
+  
+      public RowInputBase() {
+          this(new byte[4]);
+--- 58,65 ----
+      static final int NO_POS = -1;
+  
+      // fredt - initialisation may be unnecessary as it's done in resetRow()
+!     public int filePos = NO_POS;
+!     public int size;
+  
+      public RowInputBase() {
+          this(new byte[4]);
+***************
+*** 99,135 ****
+      public abstract String readString() throws IOException;
+  
+  // fredt@users - comment - methods used for SQL types
+!     protected abstract boolean checkNull() throws IOException;
+  
+!     protected abstract String readChar(int type)
+      throws IOException, HsqlException;
+  
+!     protected abstract Integer readSmallint()
+      throws IOException, HsqlException;
+  
+!     protected abstract Integer readInteger()
+      throws IOException, HsqlException;
+  
+!     protected abstract Long readBigint() throws IOException, HsqlException;
+  
+!     protected abstract Double readReal(int type)
+      throws IOException, HsqlException;
+  
+!     protected abstract BigDecimal readDecimal()
+      throws IOException, HsqlException;
+  
+!     protected abstract Boolean readBit() throws IOException, HsqlException;
+  
+!     protected abstract Time readTime() throws IOException, HsqlException;
+  
+!     protected abstract Date readDate() throws IOException, HsqlException;
+  
+!     protected abstract Timestamp readTimestamp()
+      throws IOException, HsqlException;
+  
+!     protected abstract Object readOther() throws IOException, HsqlException;
+  
+!     protected abstract Binary readBinary(int type)
+      throws IOException, HsqlException;
+  
+      /**
+--- 99,135 ----
+      public abstract String readString() throws IOException;
+  
+  // fredt@users - comment - methods used for SQL types
+!     public abstract boolean checkNull() throws IOException;
+  
+!     public abstract String readChar(int type)
+      throws IOException, HsqlException;
+  
+!     public abstract Integer readSmallint()
+      throws IOException, HsqlException;
+  
+!     public abstract Integer readInteger()
+      throws IOException, HsqlException;
+  
+!     public abstract Long readBigint() throws IOException, HsqlException;
+  
+!     public abstract Double readReal(int type)
+      throws IOException, HsqlException;
+  
+!     public abstract BigDecimal readDecimal()
+      throws IOException, HsqlException;
+  
+!     public abstract Boolean readBit() throws IOException, HsqlException;
+  
+!     public abstract Time readTime() throws IOException, HsqlException;
+  
+!     public abstract Date readDate() throws IOException, HsqlException;
+  
+!     public abstract Timestamp readTimestamp()
+      throws IOException, HsqlException;
+  
+!     public abstract Object readOther() throws IOException, HsqlException;
+  
+!     public abstract Binary readBinary(int type)
+      throws IOException, HsqlException;
+  
+      /**
+diff -crN misc/hsqldb/src/org/hsqldb/rowio/RowInputBinary.java misc/build/hsqldb/src/org/hsqldb/rowio/RowInputBinary.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowInputBinary.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowInputBinary.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 58,64 ****
+  public class RowInputBinary extends RowInputBase
+  implements org.hsqldb.rowio.RowInputInterface {
+  
+!     private RowOutputBinary out;
+  
+      public RowInputBinary() {
+          super();
+--- 58,64 ----
+  public class RowInputBinary extends RowInputBase
+  implements org.hsqldb.rowio.RowInputInterface {
+  
+!     public RowOutputBinary out;
+  
+      public RowInputBinary() {
+          super();
+***************
+*** 79,85 ****
+          this.out = out;
+      }
+  
+!     protected byte[] readByteArray() throws IOException {
+  
+          byte[] b = new byte[readInt()];
+  
+--- 79,85 ----
+          this.out = out;
+      }
+  
+!     public byte[] readByteArray() throws IOException {
+  
+          byte[] b = new byte[readInt()];
+  
+***************
+*** 115,121 ****
+          return s;
+      }
+  
+!     protected boolean checkNull() throws IOException {
+  
+          int b = readByte();
+  
+--- 115,121 ----
+          return s;
+      }
+  
+!     public boolean checkNull() throws IOException {
+  
+          int b = readByte();
+  
+***************
+*** 123,149 ****
+                        : false;
+      }
+  
+!     protected String readChar(int type) throws IOException {
+          return readString();
+      }
+  
+!     protected Integer readSmallint() throws IOException, HsqlException {
+          return ValuePool.getInt(readShort());
+      }
+  
+!     protected Integer readInteger() throws IOException, HsqlException {
+          return ValuePool.getInt(readInt());
+      }
+  
+!     protected Long readBigint() throws IOException, HsqlException {
+          return ValuePool.getLong(readLong());
+      }
+  
+!     protected Double readReal(int type) throws IOException, HsqlException {
+          return ValuePool.getDouble(readLong());
+      }
+  
+!     protected BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          byte[]     bytes  = readByteArray();
+          int        scale  = readInt();
+--- 123,149 ----
+                        : false;
+      }
+  
+!     public String readChar(int type) throws IOException {
+          return readString();
+      }
+  
+!     public Integer readSmallint() throws IOException, HsqlException {
+          return ValuePool.getInt(readShort());
+      }
+  
+!     public Integer readInteger() throws IOException, HsqlException {
+          return ValuePool.getInt(readInt());
+      }
+  
+!     public Long readBigint() throws IOException, HsqlException {
+          return ValuePool.getLong(readLong());
+      }
+  
+!     public Double readReal(int type) throws IOException, HsqlException {
+          return ValuePool.getDouble(readLong());
+      }
+  
+!     public BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          byte[]     bytes  = readByteArray();
+          int        scale  = readInt();
+***************
+*** 152,182 ****
+          return ValuePool.getBigDecimal(new BigDecimal(bigint, scale));
+      }
+  
+!     protected Boolean readBit() throws IOException, HsqlException {
+          return readBoolean() ? Boolean.TRUE
+                               : Boolean.FALSE;
+      }
+  
+!     protected Time readTime() throws IOException, HsqlException {
+          return new Time(HsqlDateTime.getNormalisedTime(readLong()));
+      }
+  
+!     protected Date readDate() throws IOException, HsqlException {
+  
+          long date = HsqlDateTime.getNormalisedDate(readLong());
+  
+          return ValuePool.getDate(date);
+      }
+  
+!     protected Timestamp readTimestamp() throws IOException, HsqlException {
+          return HsqlDateTime.timestampValue(readLong(), readInt());
+      }
+  
+!     protected Object readOther() throws IOException, HsqlException {
+          return new JavaObject(readByteArray());
+      }
+  
+!     protected Binary readBinary(int type) throws IOException, HsqlException {
+          return new Binary(readByteArray(), false);
+      }
+  
+--- 152,182 ----
+          return ValuePool.getBigDecimal(new BigDecimal(bigint, scale));
+      }
+  
+!     public Boolean readBit() throws IOException, HsqlException {
+          return readBoolean() ? Boolean.TRUE
+                               : Boolean.FALSE;
+      }
+  
+!     public Time readTime() throws IOException, HsqlException {
+          return new Time(HsqlDateTime.getNormalisedTime(readLong()));
+      }
+  
+!     public Date readDate() throws IOException, HsqlException {
+  
+          long date = HsqlDateTime.getNormalisedDate(readLong());
+  
+          return ValuePool.getDate(date);
+      }
+  
+!     public Timestamp readTimestamp() throws IOException, HsqlException {
+          return HsqlDateTime.timestampValue(readLong(), readInt());
+      }
+  
+!     public Object readOther() throws IOException, HsqlException {
+          return new JavaObject(readByteArray());
+      }
+  
+!     public Binary readBinary(int type) throws IOException, HsqlException {
+          return new Binary(readByteArray(), false);
+      }
+  
+diff -crN misc/hsqldb/src/org/hsqldb/rowio/RowInputText.java misc/build/hsqldb/src/org/hsqldb/rowio/RowInputText.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowInputText.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowInputText.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 55,75 ****
+  public class RowInputText extends RowInputBase implements RowInputInterface {
+  
+      // text table specific
+!     private String    fieldSep;
+!     private String    varSep;
+!     private String    longvarSep;
+!     private int       fieldSepLen;
+!     private int       varSepLen;
+!     private int       longvarSepLen;
+!     private boolean   fieldSepEnd;
+!     private boolean   varSepEnd;
+!     private boolean   longvarSepEnd;
+!     private int       textLen;
+!     protected String  text;
+!     protected int     line;
+!     protected int     field;
+!     protected int     next = 0;
+!     protected boolean allQuoted;
+  
+      /**
+       * fredt@users - comment - in future may use a custom subclasse of
+--- 55,75 ----
+  public class RowInputText extends RowInputBase implements RowInputInterface {
+  
+      // text table specific
+!     public String    fieldSep;
+!     public String    varSep;
+!     public String    longvarSep;
+!     public int       fieldSepLen;
+!     public int       varSepLen;
+!     public int       longvarSepLen;
+!     public boolean   fieldSepEnd;
+!     public boolean   varSepEnd;
+!     public boolean   longvarSepEnd;
+!     public int       textLen;
+!     public String  text;
+!     public int     line;
+!     public int     field;
+!     public int     next = 0;
+!     public boolean allQuoted;
+  
+      /**
+       * fredt@users - comment - in future may use a custom subclasse of
+***************
+*** 120,126 ****
+          field = 0;
+      }
+  
+!     protected String getField(String sep, int sepLen,
+                                boolean isEnd) throws IOException {
+  
+          String s = null;
+--- 120,126 ----
+          field = 0;
+      }
+  
+!     public String getField(String sep, int sepLen,
+                                boolean isEnd) throws IOException {
+  
+          String s = null;
+***************
+*** 168,178 ****
+          return getField(fieldSep, fieldSepLen, fieldSepEnd);
+      }
+  
+!     private String readVarString() throws IOException {
+          return getField(varSep, varSepLen, varSepEnd);
+      }
+  
+!     private String readLongVarString() throws IOException {
+          return getField(longvarSep, longvarSepLen, longvarSepEnd);
+      }
+  
+--- 168,178 ----
+          return getField(fieldSep, fieldSepLen, fieldSepEnd);
+      }
+  
+!     public String readVarString() throws IOException {
+          return getField(varSep, varSepLen, varSepEnd);
+      }
+  
+!     public String readLongVarString() throws IOException {
+          return getField(longvarSep, longvarSepLen, longvarSepEnd);
+      }
+  
+***************
+*** 205,217 ****
+          return 0;
+      }
+  
+!     protected boolean checkNull() {
+  
+          // Return null on each column read instead.
+          return false;
+      }
+  
+!     protected String readChar(int type) throws IOException {
+  
+          switch (type) {
+  
+--- 205,217 ----
+          return 0;
+      }
+  
+!     public boolean checkNull() {
+  
+          // Return null on each column read instead.
+          return false;
+      }
+  
+!     public String readChar(int type) throws IOException {
+  
+          switch (type) {
+  
+***************
+*** 228,234 ****
+          }
+      }
+  
+!     protected Integer readSmallint() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 228,234 ----
+          }
+      }
+  
+!     public Integer readSmallint() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+***************
+*** 245,251 ****
+          return Integer.valueOf(s);
+      }
+  
+!     protected Integer readInteger() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 245,251 ----
+          return Integer.valueOf(s);
+      }
+  
+!     public Integer readInteger() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+***************
+*** 262,268 ****
+          return Integer.valueOf(s);
+      }
+  
+!     protected Long readBigint() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 262,268 ----
+          return Integer.valueOf(s);
+      }
+  
+!     public Long readBigint() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+***************
+*** 279,285 ****
+          return Long.valueOf(s);
+      }
+  
+!     protected Double readReal(int type) throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 279,285 ----
+          return Long.valueOf(s);
+      }
+  
+!     public Double readReal(int type) throws IOException, HsqlException {
+  
+          String s = readString();
+  
+***************
+*** 296,302 ****
+          return Double.valueOf(s);
+      }
+  
+!     protected BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 296,302 ----
+          return Double.valueOf(s);
+      }
+  
+!     public BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+***************
+*** 313,319 ****
+          return new BigDecimal(s);
+      }
+  
+!     protected Time readTime() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 313,319 ----
+          return new BigDecimal(s);
+      }
+  
+!     public Time readTime() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+***************
+*** 330,336 ****
+          return HsqlDateTime.timeValue(s);
+      }
+  
+!     protected Date readDate() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 330,336 ----
+          return HsqlDateTime.timeValue(s);
+      }
+  
+!     public Date readDate() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+***************
+*** 347,353 ****
+          return HsqlDateTime.dateValue(s);
+      }
+  
+!     protected Timestamp readTimestamp() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 347,353 ----
+          return HsqlDateTime.dateValue(s);
+      }
+  
+!     public Timestamp readTimestamp() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+***************
+*** 364,370 ****
+          return HsqlDateTime.timestampValue(s);
+      }
+  
+!     protected Boolean readBit() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 364,370 ----
+          return HsqlDateTime.timestampValue(s);
+      }
+  
+!     public Boolean readBit() throws IOException, HsqlException {
+  
+          String s = readString();
+  
+***************
+*** 382,388 ****
+                                            : Boolean.FALSE;
+      }
+  
+!     protected Object readOther() throws IOException, HsqlException {
+  
+          byte[] data;
+          String s = readString();
+--- 382,388 ----
+                                            : Boolean.FALSE;
+      }
+  
+!     public Object readOther() throws IOException, HsqlException {
+  
+          byte[] data;
+          String s = readString();
+***************
+*** 402,408 ****
+          return new JavaObject(data);
+      }
+  
+!     protected Binary readBinary(int type) throws IOException, HsqlException {
+  
+          String s = readString();
+  
+--- 402,408 ----
+          return new JavaObject(data);
+      }
+  
+!     public Binary readBinary(int type) throws IOException, HsqlException {
+  
+          String s = readString();
+  
+diff -crN misc/hsqldb/src/org/hsqldb/rowio/RowInputTextLog.java misc/build/hsqldb/src/org/hsqldb/rowio/RowInputTextLog.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowInputTextLog.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowInputTextLog.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 115,121 ****
+          return schemaName;
+      }
+  
+!     protected String readField() throws IOException {
+  
+          try {
+              tokenizer.getString();
+--- 115,121 ----
+          return schemaName;
+      }
+  
+!     public String readField() throws IOException {
+  
+          try {
+              tokenizer.getString();
+***************
+*** 137,143 ****
+          }
+      }
+  
+!     protected String readNumberField() throws IOException {
+  
+          try {
+              tokenizer.getString();
+--- 137,143 ----
+          }
+      }
+  
+!     public String readNumberField() throws IOException {
+  
+          try {
+              tokenizer.getString();
+***************
+*** 205,221 ****
+          return 0;
+      }
+  
+!     protected boolean checkNull() {
+  
+          // Return null on each column read instead.
+          return false;
+      }
+  
+!     protected String readChar(int type) throws IOException {
+          return readString();
+      }
+  
+!     protected Integer readSmallint() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+--- 205,221 ----
+          return 0;
+      }
+  
+!     public boolean checkNull() {
+  
+          // Return null on each column read instead.
+          return false;
+      }
+  
+!     public String readChar(int type) throws IOException {
+          return readString();
+      }
+  
+!     public Integer readSmallint() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+***************
+*** 228,234 ****
+          return ValuePool.getInt(i);
+      }
+  
+!     protected Integer readInteger() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+--- 228,234 ----
+          return ValuePool.getInt(i);
+      }
+  
+!     public Integer readInteger() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+***************
+*** 241,247 ****
+          return ValuePool.getInt(i);
+      }
+  
+!     protected Long readBigint() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+--- 241,247 ----
+          return ValuePool.getInt(i);
+      }
+  
+!     public Long readBigint() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+***************
+*** 254,260 ****
+          return ValuePool.getLong(i);
+      }
+  
+!     protected Double readReal(int type) throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+--- 254,260 ----
+          return ValuePool.getLong(i);
+      }
+  
+!     public Double readReal(int type) throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+***************
+*** 282,288 ****
+          return ValuePool.getDouble(Double.doubleToLongBits(i));
+      }
+  
+!     protected BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+--- 282,288 ----
+          return ValuePool.getDouble(Double.doubleToLongBits(i));
+      }
+  
+!     public BigDecimal readDecimal() throws IOException, HsqlException {
+  
+          String s = readNumberField();
+  
+***************
+*** 295,301 ****
+          return ValuePool.getBigDecimal(i);
+      }
+  
+!     protected Time readTime() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+--- 295,301 ----
+          return ValuePool.getBigDecimal(i);
+      }
+  
+!     public Time readTime() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+***************
+*** 306,312 ****
+          return HsqlDateTime.timeValue(s);
+      }
+  
+!     protected Date readDate() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+--- 306,312 ----
+          return HsqlDateTime.timeValue(s);
+      }
+  
+!     public Date readDate() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+***************
+*** 317,323 ****
+          return HsqlDateTime.dateValue(s);
+      }
+  
+!     protected Timestamp readTimestamp() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+--- 317,323 ----
+          return HsqlDateTime.dateValue(s);
+      }
+  
+!     public Timestamp readTimestamp() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+***************
+*** 328,334 ****
+          return HsqlDateTime.timestampValue(s);
+      }
+  
+!     protected Boolean readBit() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+--- 328,334 ----
+          return HsqlDateTime.timestampValue(s);
+      }
+  
+!     public Boolean readBit() throws IOException, HsqlException {
+  
+          String s = readField();
+  
+***************
+*** 340,346 ****
+                                            : Boolean.FALSE;
+      }
+  
+!     protected Object readOther() throws IOException, HsqlException {
+  
+          byte[] data;
+          String s = readField();
+--- 340,346 ----
+                                            : Boolean.FALSE;
+      }
+  
+!     public Object readOther() throws IOException, HsqlException {
+  
+          byte[] data;
+          String s = readField();
+***************
+*** 354,360 ****
+          return new JavaObject(data);
+      }
+  
+!     protected Binary readBinary(int type) throws IOException, HsqlException {
+  
+          String s = readField();
+  
+--- 354,360 ----
+          return new JavaObject(data);
+      }
+  
+!     public Binary readBinary(int type) throws IOException, HsqlException {
+  
+          String s = readField();
+  
+diff -crN misc/hsqldb/src/org/hsqldb/rowio/RowInputTextQuoted.java misc/build/hsqldb/src/org/hsqldb/rowio/RowInputTextQuoted.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowInputTextQuoted.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowInputTextQuoted.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 46,55 ****
+   */
+  public class RowInputTextQuoted extends RowInputText {
+  
+!     private static final int NORMAL_FIELD   = 0;
+!     private static final int NEED_END_QUOTE = 1;
+!     private static final int FOUND_QUOTE    = 2;
+!     private char[]           qtext;
+  
+      public RowInputTextQuoted(String fieldSep, String varSep,
+                                String longvarSep, boolean allQuoted) {
+--- 46,55 ----
+   */
+  public class RowInputTextQuoted extends RowInputText {
+  
+!     public static final int NORMAL_FIELD   = 0;
+!     public static final int NEED_END_QUOTE = 1;
+!     public static final int FOUND_QUOTE    = 2;
+!     public char[]           qtext;
+  
+      public RowInputTextQuoted(String fieldSep, String varSep,
+                                String longvarSep, boolean allQuoted) {
+***************
+*** 63,69 ****
+          qtext = text.toCharArray();
+      }
+  
+!     protected String getField(String sep, int sepLen,
+                                boolean isEnd) throws IOException {
+  
+          //fredt - now the only supported behaviour is emptyIsNull
+--- 63,69 ----
+          qtext = text.toCharArray();
+      }
+  
+!     public String getField(String sep, int sepLen,
+                                boolean isEnd) throws IOException {
+  
+          //fredt - now the only supported behaviour is emptyIsNull
+***************
+*** 120,125 ****
+--- 120,126 ----
+                          } else {
+  
+                              //-- End of field.
++                             // todo - bug here as it throws when there are line terminators after the last field
+                              if (((next + 1) != qtext.length)
+                                      && (text.indexOf(sep, next) != next)) {
+                                  throw Trace
+diff -crN misc/hsqldb/src/org/hsqldb/rowio/RowOutputBase.java misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputBase.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowOutputBase.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputBase.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 62,68 ****
+      public static final int CACHED_ROW_170 = 1;
+  
+      // the last column in a table is an ID that should not be written to file
+!     protected boolean skipSystemId = false;
+  
+      /**
+       *  Constructor used for persistent storage of a Table row
+--- 62,68 ----
+      public static final int CACHED_ROW_170 = 1;
+  
+      // the last column in a table is an ID that should not be written to file
+!     public boolean skipSystemId = false;
+  
+      /**
+       *  Constructor used for persistent storage of a Table row
+***************
+*** 107,141 ****
+      public abstract void writeString(String s);
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     protected void writeFieldPrefix() {}
+  
+!     protected abstract void writeFieldType(int type);
+  
+!     protected abstract void writeNull(int type);
+  
+!     protected abstract void writeChar(String s, int t);
+  
+!     protected abstract void writeSmallint(Number o);
+  
+!     protected abstract void writeInteger(Number o);
+  
+!     protected abstract void writeBigint(Number o);
+  
+!     protected abstract void writeReal(Double o, int type);
+  
+!     protected abstract void writeDecimal(BigDecimal o);
+  
+!     protected abstract void writeBit(Boolean o);
+  
+!     protected abstract void writeDate(Date o);
+  
+!     protected abstract void writeTime(Time o);
+  
+!     protected abstract void writeTimestamp(Timestamp o);
+  
+!     protected abstract void writeOther(JavaObject o);
+  
+!     protected abstract void writeBinary(Binary o, int t);
+  
+      public void writeRow(Object[] data, Table t) {
+  
+--- 107,141 ----
+      public abstract void writeString(String s);
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     public void writeFieldPrefix() {}
+  
+!     public abstract void writeFieldType(int type);
+  
+!     public abstract void writeNull(int type);
+  
+!     public abstract void writeChar(String s, int t);
+  
+!     public abstract void writeSmallint(Number o);
+  
+!     public abstract void writeInteger(Number o);
+  
+!     public abstract void writeBigint(Number o);
+  
+!     public abstract void writeReal(Double o, int type);
+  
+!     public abstract void writeDecimal(BigDecimal o);
+  
+!     public abstract void writeBit(Boolean o);
+  
+!     public abstract void writeDate(Date o);
+  
+!     public abstract void writeTime(Time o);
+  
+!     public abstract void writeTimestamp(Timestamp o);
+  
+!     public abstract void writeOther(JavaObject o);
+  
+!     public abstract void writeBinary(Binary o, int t);
+  
+      public void writeRow(Object[] data, Table t) {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/rowio/RowOutputBinary.java misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputBinary.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowOutputBinary.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputBinary.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 57,63 ****
+   */
+  public class RowOutputBinary extends RowOutputBase {
+  
+!     private static final int INT_STORE_SIZE = 4;
+      int                      storageSize;
+  
+      public RowOutputBinary() {
+--- 57,63 ----
+   */
+  public class RowOutputBinary extends RowOutputBase {
+  
+!     public static final int INT_STORE_SIZE = 4;
+      int                      storageSize;
+  
+      public RowOutputBinary() {
+***************
+*** 160,194 ****
+      }
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     protected void writeFieldType(int type) {
+          write(1);
+      }
+  
+!     protected void writeNull(int type) {
+          write(0);
+      }
+  
+!     protected void writeChar(String s, int t) {
+          writeString(s);
+      }
+  
+!     protected void writeSmallint(Number o) {
+          writeShort(o.intValue());
+      }
+  
+!     protected void writeInteger(Number o) {
+          writeInt(o.intValue());
+      }
+  
+!     protected void writeBigint(Number o) {
+          writeLong(o.longValue());
+      }
+  
+!     protected void writeReal(Double o, int type) {
+          writeLong(Double.doubleToLongBits((o.doubleValue())));
+      }
+  
+!     protected void writeDecimal(BigDecimal o) {
+  
+          int        scale   = o.scale();
+          BigInteger bigint  = JavaSystem.getUnscaledValue(o);
+--- 160,194 ----
+      }
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     public void writeFieldType(int type) {
+          write(1);
+      }
+  
+!     public void writeNull(int type) {
+          write(0);
+      }
+  
+!     public void writeChar(String s, int t) {
+          writeString(s);
+      }
+  
+!     public void writeSmallint(Number o) {
+          writeShort(o.intValue());
+      }
+  
+!     public void writeInteger(Number o) {
+          writeInt(o.intValue());
+      }
+  
+!     public void writeBigint(Number o) {
+          writeLong(o.longValue());
+      }
+  
+!     public void writeReal(Double o, int type) {
+          writeLong(Double.doubleToLongBits((o.doubleValue())));
+      }
+  
+!     public void writeDecimal(BigDecimal o) {
+  
+          int        scale   = o.scale();
+          BigInteger bigint  = JavaSystem.getUnscaledValue(o);
+***************
+*** 198,231 ****
+          writeInt(scale);
+      }
+  
+!     protected void writeBit(Boolean o) {
+          write(o.booleanValue() ? 1
+                                 : 0);
+      }
+  
+!     protected void writeDate(Date o) {
+          writeLong(o.getTime());
+      }
+  
+!     protected void writeTime(Time o) {
+          writeLong(o.getTime());
+      }
+  
+!     protected void writeTimestamp(Timestamp o) {
+          writeLong(o.getTime());
+          writeInt(o.getNanos());
+      }
+  
+!     protected void writeOther(JavaObject o) {
+          writeByteArray(o.getBytes());
+      }
+  
+!     protected void writeBinary(Binary o, int t) {
+          writeByteArray(o.getBytes());
+      }
+  
+  // fredt@users - comment - helper and conversion methods
+!     protected void writeByteArray(byte[] b) {
+          writeInt(b.length);
+          write(b, 0, b.length);
+      }
+--- 198,231 ----
+          writeInt(scale);
+      }
+  
+!     public void writeBit(Boolean o) {
+          write(o.booleanValue() ? 1
+                                 : 0);
+      }
+  
+!     public void writeDate(Date o) {
+          writeLong(o.getTime());
+      }
+  
+!     public void writeTime(Time o) {
+          writeLong(o.getTime());
+      }
+  
+!     public void writeTimestamp(Timestamp o) {
+          writeLong(o.getTime());
+          writeInt(o.getNanos());
+      }
+  
+!     public void writeOther(JavaObject o) {
+          writeByteArray(o.getBytes());
+      }
+  
+!     public void writeBinary(Binary o, int t) {
+          writeByteArray(o.getBytes());
+      }
+  
+  // fredt@users - comment - helper and conversion methods
+!     public void writeByteArray(byte[] b) {
+          writeInt(b.length);
+          write(b, 0, b.length);
+      }
+***************
+*** 239,245 ****
+       * @return size of byte array
+       * @exception  HsqlException when data is inconsistent
+       */
+!     private static int getSize(Object[] data, int l, int[] type) {
+  
+          int s = 0;
+  
+--- 239,245 ----
+       * @return size of byte array
+       * @exception  HsqlException when data is inconsistent
+       */
+!     public static int getSize(Object[] data, int l, int[] type) {
+  
+          int s = 0;
+  
+diff -crN misc/hsqldb/src/org/hsqldb/rowio/RowOutputText.java misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputText.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowOutputText.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputText.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 54,69 ****
+   */
+  public class RowOutputText extends RowOutputBase {
+  
+!     protected String  fieldSep;
+!     protected String  varSep;
+!     protected String  longvarSep;
+!     private boolean   fieldSepEnd;
+!     private boolean   varSepEnd;
+!     private boolean   longvarSepEnd;
+!     private String    nextSep = "";
+!     private boolean   nextSepEnd;
+!     protected boolean allQuoted;
+!     private String    encoding;
+  
+      public RowOutputText(String fieldSep, String varSep, String longvarSep,
+                           boolean allQuoted, String encoding) {
+--- 54,69 ----
+   */
+  public class RowOutputText extends RowOutputBase {
+  
+!     public String  fieldSep;
+!     public String  varSep;
+!     public String  longvarSep;
+!     public boolean   fieldSepEnd;
+!     public boolean   varSepEnd;
+!     public boolean   longvarSepEnd;
+!     public String    nextSep = "";
+!     public boolean   nextSepEnd;
+!     public boolean allQuoted;
+!     public String    encoding;
+  
+      public RowOutputText(String fieldSep, String varSep, String longvarSep,
+                           boolean allQuoted, String encoding) {
+***************
+*** 74,80 ****
+                                    encoding);
+      }
+  
+!     private void initTextDatabaseRowOutput(String fieldSep, String varSep,
+                                             String longvarSep,
+                                             boolean allQuoted,
+                                             String encoding) {
+--- 74,80 ----
+                                    encoding);
+      }
+  
+!     public void initTextDatabaseRowOutput(String fieldSep, String varSep,
+                                             String longvarSep,
+                                             boolean allQuoted,
+                                             String encoding) {
+***************
+*** 142,148 ****
+          nextSepEnd = fieldSepEnd;
+      }
+  
+!     protected void writeVarString(String s) {
+  
+          s = checkConvertString(s, varSep);
+  
+--- 142,148 ----
+          nextSepEnd = fieldSepEnd;
+      }
+  
+!     public void writeVarString(String s) {
+  
+          s = checkConvertString(s, varSep);
+  
+***************
+*** 159,165 ****
+          nextSepEnd = varSepEnd;
+      }
+  
+!     protected void writeLongVarString(String s) {
+  
+          s = checkConvertString(s, longvarSep);
+  
+--- 159,165 ----
+          nextSepEnd = varSepEnd;
+      }
+  
+!     public void writeLongVarString(String s) {
+  
+          s = checkConvertString(s, longvarSep);
+  
+***************
+*** 176,182 ****
+          nextSepEnd = longvarSepEnd;
+      }
+  
+!     protected String checkConvertString(String s, String sep) {
+  
+          if (s.indexOf('\n') != -1 || s.indexOf('\r') != -1) {
+              throw new IllegalArgumentException(
+--- 176,182 ----
+          nextSepEnd = longvarSepEnd;
+      }
+  
+!     public String checkConvertString(String s, String sep) {
+  
+          if (s.indexOf('\n') != -1 || s.indexOf('\r') != -1) {
+              throw new IllegalArgumentException(
+***************
+*** 188,194 ****
+          return s;
+      }
+  
+!     private byte[] getBytes(String s) {
+  
+          byte[] bytes = null;
+  
+--- 188,194 ----
+          return s;
+      }
+  
+!     public byte[] getBytes(String s) {
+  
+          byte[] bytes = null;
+  
+***************
+*** 201,207 ****
+          return bytes;
+      }
+  
+!     protected void writeByteArray(byte[] b) {
+  
+          ensureRoom(b.length * 2);
+          StringConverter.writeHex(this.getBuffer(), count, b);
+--- 201,207 ----
+          return bytes;
+      }
+  
+!     public void writeByteArray(byte[] b) {
+  
+          ensureRoom(b.length * 2);
+          StringConverter.writeHex(this.getBuffer(), count, b);
+***************
+*** 231,237 ****
+      }
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     protected void writeFieldType(int type) {
+  
+          writeBytes(nextSep);
+  
+--- 231,237 ----
+      }
+  
+  // fredt@users - comment - methods used for writing each SQL type
+!     public void writeFieldType(int type) {
+  
+          writeBytes(nextSep);
+  
+***************
+*** 255,265 ****
+          }
+      }
+  
+!     protected void writeNull(int type) {
+          writeFieldType(type);
+      }
+  
+!     protected void writeChar(String s, int t) {
+  
+          switch (t) {
+  
+--- 255,265 ----
+          }
+      }
+  
+!     public void writeNull(int type) {
+          writeFieldType(type);
+      }
+  
+!     public void writeChar(String s, int t) {
+  
+          switch (t) {
+  
+***************
+*** 282,331 ****
+          }
+      }
+  
+!     protected void writeSmallint(Number o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeInteger(Number o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeBigint(Number o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeReal(Double o, int type) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeDecimal(BigDecimal o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeBit(Boolean o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeDate(Date o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeTime(Time o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeTimestamp(Timestamp o) {
+          writeString(o.toString());
+      }
+  
+!     protected void writeOther(JavaObject o) {
+  
+          byte[] ba = o.getBytes();
+  
+          writeByteArray(ba);
+      }
+  
+!     protected void writeBinary(Binary o, int t) {
+          writeByteArray(o.getBytes());
+      }
+  
+--- 282,331 ----
+          }
+      }
+  
+!     public void writeSmallint(Number o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeInteger(Number o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeBigint(Number o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeReal(Double o, int type) {
+          writeString(o.toString());
+      }
+  
+!     public void writeDecimal(BigDecimal o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeBit(Boolean o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeDate(Date o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeTime(Time o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeTimestamp(Timestamp o) {
+          writeString(o.toString());
+      }
+  
+!     public void writeOther(JavaObject o) {
+  
+          byte[] ba = o.getBytes();
+  
+          writeByteArray(ba);
+      }
+  
+!     public void writeBinary(Binary o, int t) {
+          writeByteArray(o.getBytes());
+      }
+  
+diff -crN misc/hsqldb/src/org/hsqldb/rowio/RowOutputTextLog.java misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputTextLog.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowOutputTextLog.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputTextLog.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 57,101 ****
+      static final byte[]     BYTES_IS    = " IS ".getBytes();
+      public static final int MODE_DELETE = 1;
+      public static final int MODE_INSERT = 0;
+!     private boolean         isWritten;
+!     private int             logMode;
+  
+      public void setMode(int mode) {
+          logMode = mode;
+      }
+  
+!     protected void writeFieldPrefix() {
+  
+          if (logMode == MODE_DELETE && isWritten) {
+              write(BYTES_AND);
+          }
+      }
+  
+!     protected void writeChar(String s, int t) {
+  
+          write('\'');
+          StringConverter.unicodeToAscii(this, s, true);
+          write('\'');
+      }
+  
+!     protected void writeReal(Double o, int type) {
+          writeBytes(Column.createSQLString(((Number) o).doubleValue()));
+      }
+  
+!     protected void writeSmallint(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+      public void writeEnd() {}
+  
+!     protected void writeTime(Time o) {
+  
+          write('\'');
+          writeBytes(o.toString());
+          write('\'');
+      }
+  
+!     protected void writeBinary(Binary o, int t) {
+  
+          ensureRoom(o.getBytesLength() * 2 + 2);
+          write('\'');
+--- 57,101 ----
+      static final byte[]     BYTES_IS    = " IS ".getBytes();
+      public static final int MODE_DELETE = 1;
+      public static final int MODE_INSERT = 0;
+!     public boolean         isWritten;
+!     public int             logMode;
+  
+      public void setMode(int mode) {
+          logMode = mode;
+      }
+  
+!     public void writeFieldPrefix() {
+  
+          if (logMode == MODE_DELETE && isWritten) {
+              write(BYTES_AND);
+          }
+      }
+  
+!     public void writeChar(String s, int t) {
+  
+          write('\'');
+          StringConverter.unicodeToAscii(this, s, true);
+          write('\'');
+      }
+  
+!     public void writeReal(Double o, int type) {
+          writeBytes(Column.createSQLString(((Number) o).doubleValue()));
+      }
+  
+!     public void writeSmallint(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+      public void writeEnd() {}
+  
+!     public void writeTime(Time o) {
+  
+          write('\'');
+          writeBytes(o.toString());
+          write('\'');
+      }
+  
+!     public void writeBinary(Binary o, int t) {
+  
+          ensureRoom(o.getBytesLength() * 2 + 2);
+          write('\'');
+***************
+*** 110,116 ****
+  
+      public void writeSize(int size) {}
+  
+!     protected void writeDate(Date o) {
+  
+          write('\'');
+          this.writeBytes(o.toString());
+--- 110,116 ----
+  
+      public void writeSize(int size) {}
+  
+!     public void writeDate(Date o) {
+  
+          write('\'');
+          this.writeBytes(o.toString());
+***************
+*** 121,136 ****
+          return 0;
+      }
+  
+!     protected void writeInteger(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+!     protected void writeBigint(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+  //fredt@users - patch 1108647 by nkowalcz@users (NataliaK) fix for IS NULL
+!     protected void writeNull(int type) {
+  
+          if (logMode == MODE_DELETE) {
+              write(BYTES_IS);
+--- 121,136 ----
+          return 0;
+      }
+  
+!     public void writeInteger(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+!     public void writeBigint(Number o) {
+          this.writeBytes(o.toString());
+      }
+  
+  //fredt@users - patch 1108647 by nkowalcz@users (NataliaK) fix for IS NULL
+!     public void writeNull(int type) {
+  
+          if (logMode == MODE_DELETE) {
+              write(BYTES_IS);
+***************
+*** 143,149 ****
+          write(BYTES_NULL);
+      }
+  
+!     protected void writeOther(JavaObject o) {
+  
+          ensureRoom(o.getBytesLength() * 2 + 2);
+          write('\'');
+--- 143,149 ----
+          write(BYTES_NULL);
+      }
+  
+!     public void writeOther(JavaObject o) {
+  
+          ensureRoom(o.getBytesLength() * 2 + 2);
+          write('\'');
+***************
+*** 158,173 ****
+          StringConverter.unicodeToAscii(this, value, false);
+      }
+  
+!     protected void writeBit(Boolean o) {
+          write(o.booleanValue() ? BYTES_TRUE
+                                 : BYTES_FALSE);
+      }
+  
+!     protected void writeDecimal(BigDecimal o) {
+          this.writeBytes(o.toString());
+      }
+  
+!     protected void writeFieldType(int type) {
+  
+          if (logMode == MODE_DELETE) {
+              write('=');
+--- 158,173 ----
+          StringConverter.unicodeToAscii(this, value, false);
+      }
+  
+!     public void writeBit(Boolean o) {
+          write(o.booleanValue() ? BYTES_TRUE
+                                 : BYTES_FALSE);
+      }
+  
+!     public void writeDecimal(BigDecimal o) {
+          this.writeBytes(o.toString());
+      }
+  
+!     public void writeFieldType(int type) {
+  
+          if (logMode == MODE_DELETE) {
+              write('=');
+***************
+*** 184,190 ****
+  
+      public void writeIntData(int i, int position) {}
+  
+!     protected void writeTimestamp(Timestamp o) {
+  
+          write('\'');
+          this.writeBytes(HsqlDateTime.getTimestampString(o));
+--- 184,190 ----
+  
+      public void writeIntData(int i, int position) {}
+  
+!     public void writeTimestamp(Timestamp o) {
+  
+          write('\'');
+          this.writeBytes(HsqlDateTime.getTimestampString(o));
+diff -crN misc/hsqldb/src/org/hsqldb/rowio/RowOutputTextQuoted.java misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputTextQuoted.java
+*** misc/hsqldb/src/org/hsqldb/rowio/RowOutputTextQuoted.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/rowio/RowOutputTextQuoted.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 49,55 ****
+          super(fieldSep, varSep, longvarSep, allQuoted, encoding);
+      }
+  
+!     protected String checkConvertString(String s, String sep) {
+  
+          if (allQuoted || s.length() == 0 || s.indexOf('\"') != -1
+                  || (sep.length() > 0 && s.indexOf(sep) != -1)
+--- 49,55 ----
+          super(fieldSep, varSep, longvarSep, allQuoted, encoding);
+      }
+  
+!     public String checkConvertString(String s, String sep) {
+  
+          if (allQuoted || s.length() == 0 || s.indexOf('\"') != -1
+                  || (sep.length() > 0 && s.indexOf(sep) != -1)
+***************
+*** 60,66 ****
+          return s;
+      }
+  
+!     private boolean hasUnprintable(String s) {
+  
+          for (int i = 0, len = s.length(); i < len; i++) {
+              if (Character.isISOControl(s.charAt(i))) {
+--- 60,66 ----
+          return s;
+      }
+  
+!     public boolean hasUnprintable(String s) {
+  
+          for (int i = 0, len = s.length(); i < len; i++) {
+              if (Character.isISOControl(s.charAt(i))) {
+diff -crN misc/hsqldb/src/org/hsqldb/Row.java misc/build/hsqldb/src/org/hsqldb/Row.java
+*** misc/hsqldb/src/org/hsqldb/Row.java	2005-10-23 17:40:16.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Row.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 89,101 ****
+  
+      int                tableId;
+      int                iPos;
+!     protected Object[] oData;
+!     protected Node     nPrimaryNode;
+  
+      /**
+       *  Default constructor used only in subclasses.
+       */
+!     Row() {}
+  
+      /**
+       *  Constructor for MEMORY table Row. The result is a Row with Nodes that
+--- 89,101 ----
+  
+      int                tableId;
+      int                iPos;
+!     public Object[] oData;
+!     public Node     nPrimaryNode;
+  
+      /**
+       *  Default constructor used only in subclasses.
+       */
+!     public Row() {}
+  
+      /**
+       *  Constructor for MEMORY table Row. The result is a Row with Nodes that
+diff -crN misc/hsqldb/src/org/hsqldb/sample/TriggerSample.java misc/build/hsqldb/src/org/hsqldb/sample/TriggerSample.java
+*** misc/hsqldb/src/org/hsqldb/sample/TriggerSample.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/sample/TriggerSample.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 211,217 ****
+          }
+      }
+  
+!     private static void doAssert(boolean b,
+                                   String msg) throws RuntimeException {
+  
+          if (b) {
+--- 211,217 ----
+          }
+      }
+  
+!     public static void doAssert(boolean b,
+                                   String msg) throws RuntimeException {
+  
+          if (b) {
+***************
+*** 224,230 ****
+          }
+      }
+  
+!     private static void doAuditStep(int typ, String tn, String ors,
+                                      String nrs) {
+  
+          Connection        conn;
+--- 224,230 ----
+          }
+      }
+  
+!     public static void doAuditStep(int typ, String tn, String ors,
+                                      String nrs) {
+  
+          Connection        conn;
+***************
+*** 373,379 ****
+          return sb.toString();
+      }
+  
+!     private static Connection getConnection() throws SQLException {
+  
+          try {
+              Class.forName(drv).newInstance();
+--- 373,379 ----
+          return sb.toString();
+      }
+  
+!     public static Connection getConnection() throws SQLException {
+  
+          try {
+              Class.forName(drv).newInstance();
+***************
+*** 386,397 ****
+          }
+      }
+  
+!     private static void createTrigger(Statement stmt, String trn,
+                                        int typ) throws SQLException {
+          stmt.execute(getTriggerDDL(trn, typ, tn, 0, impl));
+      }
+  
+!     private static void setup() throws SQLException {
+  
+          Connection conn = getConnection();
+          Statement  stmt = conn.createStatement();
+--- 386,397 ----
+          }
+      }
+  
+!     public static void createTrigger(Statement stmt, String trn,
+                                        int typ) throws SQLException {
+          stmt.execute(getTriggerDDL(trn, typ, tn, 0, impl));
+      }
+  
+!     public static void setup() throws SQLException {
+  
+          Connection conn = getConnection();
+          Statement  stmt = conn.createStatement();
+***************
+*** 416,422 ****
+          conn.close();
+      }
+  
+!     private static void doSomeWork() throws SQLException {
+  
+          Connection conn = getConnection();
+          Statement  stmt = conn.createStatement();
+--- 416,422 ----
+          conn.close();
+      }
+  
+!     public static void doSomeWork() throws SQLException {
+  
+          Connection conn = getConnection();
+          Statement  stmt = conn.createStatement();
+***************
+*** 448,454 ****
+          conn.close();
+      }
+  
+!     private static void dumpTable(String tn) throws SQLException {
+  
+          Connection        conn  = getConnection();
+          Statement         stmt  = conn.createStatement();
+--- 448,454 ----
+          conn.close();
+      }
+  
+!     public static void dumpTable(String tn) throws SQLException {
+  
+          Connection        conn  = getConnection();
+          Statement         stmt  = conn.createStatement();
+***************
+*** 483,489 ****
+          conn.close();
+      }
+  
+!     private static void runSample() throws SQLException {
+  
+          setup();
+          doSomeWork();
+--- 483,489 ----
+          conn.close();
+      }
+  
+!     public static void runSample() throws SQLException {
+  
+          setup();
+          doSomeWork();
+diff -crN misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBase.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBase.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBase.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBase.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 82,98 ****
+          openFile();
+      }
+  
+!     protected abstract void openFile() throws IOException;
+  
+      public void readAll(Session session) throws IOException, HsqlException {
+          readDDL(session);
+          readExistingData(session);
+      }
+  
+!     protected abstract void readDDL(Session session)
+      throws IOException, HsqlException;
+  
+!     protected abstract void readExistingData(Session session)
+      throws IOException, HsqlException;
+  
+      public abstract boolean readLoggedStatement(Session session)
+--- 82,98 ----
+          openFile();
+      }
+  
+!     public abstract void openFile() throws IOException;
+  
+      public void readAll(Session session) throws IOException, HsqlException {
+          readDDL(session);
+          readExistingData(session);
+      }
+  
+!     public abstract void readDDL(Session session)
+      throws IOException, HsqlException;
+  
+!     public abstract void readExistingData(Session session)
+      throws IOException, HsqlException;
+  
+      public abstract boolean readLoggedStatement(Session session)
+diff -crN misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBinary.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBinary.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBinary.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderBinary.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 56,63 ****
+   */
+  class ScriptReaderBinary extends ScriptReaderBase {
+  
+!     private RowInputBinary    rowIn;
+!     protected DataInputStream dataStreamIn;
+  
+      ScriptReaderBinary(Database db,
+                         String file) throws HsqlException, IOException {
+--- 56,63 ----
+   */
+  class ScriptReaderBinary extends ScriptReaderBase {
+  
+!     public RowInputBinary    rowIn;
+!     public DataInputStream dataStreamIn;
+  
+      ScriptReaderBinary(Database db,
+                         String file) throws HsqlException, IOException {
+***************
+*** 67,73 ****
+          rowIn = new RowInputBinary();
+      }
+  
+!     protected void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+--- 67,73 ----
+          rowIn = new RowInputBinary();
+      }
+  
+!     public void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+***************
+*** 77,83 ****
+                  1 << 13));
+      }
+  
+!     protected void readDDL(Session session)
+      throws IOException, HsqlException {
+  
+          Result   r  = Result.read(rowIn, dataStreamIn);
+--- 77,83 ----
+                  1 << 13));
+      }
+  
+!     public void readDDL(Session session)
+      throws IOException, HsqlException {
+  
+          Result   r  = Result.read(rowIn, dataStreamIn);
+***************
+*** 97,103 ****
+          }
+      }
+  
+!     protected void readExistingData(Session session)
+      throws IOException, HsqlException {
+  
+          for (;;) {
+--- 97,103 ----
+          }
+      }
+  
+!     public void readExistingData(Session session)
+      throws IOException, HsqlException {
+  
+          for (;;) {
+***************
+*** 131,137 ****
+  
+      // int : row size (0 if no more rows) ,
+      // BinaryServerRowInput : row (column values)
+!     protected boolean readRow(Table t) throws IOException, HsqlException {
+  
+          boolean more = readRow(rowIn, 0);
+  
+--- 131,137 ----
+  
+      // int : row size (0 if no more rows) ,
+      // BinaryServerRowInput : row (column values)
+!     public boolean readRow(Table t) throws IOException, HsqlException {
+  
+          boolean more = readRow(rowIn, 0);
+  
+***************
+*** 147,159 ****
+      }
+  
+      // int : rowcount
+!     protected int readTableTerm() throws IOException, HsqlException {
+          return dataStreamIn.readInt();
+      }
+  
+      // int : headersize (0 if no more tables), String : tablename, int : operation,
+      // String : schemaname
+!     protected String readTableInit() throws IOException, HsqlException {
+  
+          boolean more = readRow(rowIn, 0);
+  
+--- 147,159 ----
+      }
+  
+      // int : rowcount
+!     public int readTableTerm() throws IOException, HsqlException {
+          return dataStreamIn.readInt();
+      }
+  
+      // int : headersize (0 if no more tables), String : tablename, int : operation,
+      // String : schemaname
+!     public String readTableInit() throws IOException, HsqlException {
+  
+          boolean more = readRow(rowIn, 0);
+  
+diff -crN misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderText.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderText.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderText.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderText.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 70,76 ****
+          rowIn = new RowInputTextLog();
+      }
+  
+!     protected void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+--- 70,76 ----
+          rowIn = new RowInputTextLog();
+      }
+  
+!     public void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+***************
+*** 80,86 ****
+              new InputStreamReader(new BufferedInputStream(d)));
+      }
+  
+!     protected void readDDL(Session session)
+      throws IOException, HsqlException {
+  
+          for (; readLoggedStatement(session); ) {
+--- 80,86 ----
+              new InputStreamReader(new BufferedInputStream(d)));
+      }
+  
+!     public void readDDL(Session session)
+      throws IOException, HsqlException {
+  
+          for (; readLoggedStatement(session); ) {
+***************
+*** 105,111 ****
+          }
+      }
+  
+!     protected void readExistingData(Session session)
+      throws IOException, HsqlException {
+  
+          try {
+--- 105,111 ----
+          }
+      }
+  
+!     public void readExistingData(Session session)
+      throws IOException, HsqlException {
+  
+          try {
+***************
+*** 165,171 ****
+          return true;
+      }
+  
+!     private void processStatement(Session session) throws IOException {
+  
+          try {
+              if (statement.startsWith("/*C")) {
+--- 165,171 ----
+          return true;
+      }
+  
+!     public void processStatement(Session session) throws IOException {
+  
+          try {
+              if (statement.startsWith("/*C")) {
+diff -crN misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderZipped.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderZipped.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptReaderZipped.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptReaderZipped.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 54,60 ****
+          super(db, file);
+      }
+  
+!     protected void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+--- 54,60 ----
+          super(db, file);
+      }
+  
+!     public void openFile() throws IOException {
+  
+          InputStream d = db.isFilesInJar()
+                          ? getClass().getResourceAsStream(fileName)
+diff -crN misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBase.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBase.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBase.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBase.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 101,107 ****
+      volatile boolean needsSync;
+      volatile boolean forceSync;
+      volatile boolean busyWriting;
+!     private int      syncCount;
+      static final int INSERT             = 0;
+      static final int INSERT_WITH_SCHEMA = 1;
+  
+--- 101,107 ----
+      volatile boolean needsSync;
+      volatile boolean forceSync;
+      volatile boolean busyWriting;
+!     public int      syncCount;
+      static final int INSERT             = 0;
+      static final int INSERT_WITH_SCHEMA = 1;
+  
+***************
+*** 167,173 ****
+          openFile();
+      }
+  
+!     protected abstract void initBuffers();
+  
+      /**
+       *  Called internally or externally in write delay intervals.
+--- 167,173 ----
+          openFile();
+      }
+  
+!     public abstract void initBuffers();
+  
+      /**
+       *  Called internally or externally in write delay intervals.
+***************
+*** 233,239 ****
+       *  File is opened in append mode although in current usage the file
+       *  never pre-exists
+       */
+!     protected void openFile() throws HsqlException {
+  
+          try {
+              FileAccess   fa  = isDump ? new FileUtil()
+--- 233,239 ----
+       *  File is opened in append mode although in current usage the file
+       *  never pre-exists
+       */
+!     public void openFile() throws HsqlException {
+  
+          try {
+              FileAccess   fa  = isDump ? new FileUtil()
+***************
+*** 254,262 ****
+       * This is not really useful in the current usage but may be if this
+       * class is used in a different way.
+       */
+!     protected void finishStream() throws IOException {}
+  
+!     protected void writeDDL() throws IOException, HsqlException {
+  
+          Result ddlPart = DatabaseScript.getScript(database,
+              !includeCachedData);
+--- 254,262 ----
+       * This is not really useful in the current usage but may be if this
+       * class is used in a different way.
+       */
+!     public void finishStream() throws IOException {}
+  
+!     public void writeDDL() throws IOException, HsqlException {
+  
+          Result ddlPart = DatabaseScript.getScript(database,
+              !includeCachedData);
+***************
+*** 264,270 ****
+          writeSingleColumnResult(ddlPart);
+      }
+  
+!     protected void writeExistingData() throws HsqlException, IOException {
+  
+          // start with blank schema - SET SCHEMA to log
+          currentSession.loggedSchema = null;
+--- 264,270 ----
+          writeSingleColumnResult(ddlPart);
+      }
+  
+!     public void writeExistingData() throws HsqlException, IOException {
+  
+          // start with blank schema - SET SCHEMA to log
+          currentSession.loggedSchema = null;
+***************
+*** 305,311 ****
+  
+                          writeTableInit(t);
+  
+!                         RowIterator it = t.rowIterator(null);
+  
+                          while (it.hasNext()) {
+                              writeRow(currentSession, t, it.next().getData());
+--- 305,311 ----
+  
+                          writeTableInit(t);
+  
+!                         RowIterator it = t.rowIterator(currentSession);
+  
+                          while (it.hasNext()) {
+                              writeRow(currentSession, t, it.next().getData());
+***************
+*** 322,331 ****
+          writeDataTerm();
+      }
+  
+!     protected void writeTableInit(Table t)
+      throws HsqlException, IOException {}
+  
+!     protected void writeTableTerm(Table t) throws HsqlException, IOException {
+  
+          if (t.isDataReadOnly() &&!t.isTemp() &&!t.isText()) {
+              StringBuffer a = new StringBuffer("SET TABLE ");
+--- 322,331 ----
+          writeDataTerm();
+      }
+  
+!     public void writeTableInit(Table t)
+      throws HsqlException, IOException {}
+  
+!     public void writeTableTerm(Table t) throws HsqlException, IOException {
+  
+          if (t.isDataReadOnly() &&!t.isTemp() &&!t.isText()) {
+              StringBuffer a = new StringBuffer("SET TABLE ");
+***************
+*** 336,342 ****
+          }
+      }
+  
+!     protected void writeSingleColumnResult(Result r)
+      throws HsqlException, IOException {
+  
+          Iterator it = r.iterator();
+--- 336,342 ----
+          }
+      }
+  
+!     public void writeSingleColumnResult(Result r)
+      throws HsqlException, IOException {
+  
+          Iterator it = r.iterator();
+***************
+*** 351,359 ****
+      abstract void writeRow(Session session, Table table,
+                             Object[] data) throws HsqlException, IOException;
+  
+!     protected abstract void writeDataTerm() throws IOException;
+  
+!     protected abstract void addSessionId(Session session) throws IOException;
+  
+      public abstract void writeLogStatement(Session session,
+                                             String s)
+--- 351,359 ----
+      abstract void writeRow(Session session, Table table,
+                             Object[] data) throws HsqlException, IOException;
+  
+!     public abstract void writeDataTerm() throws IOException;
+  
+!     public abstract void addSessionId(Session session) throws IOException;
+  
+      public abstract void writeLogStatement(Session session,
+                                             String s)
+***************
+*** 372,381 ****
+      throws HsqlException, IOException;
+  
+      //
+!     private Object timerTask;
+  
+      // long write delay for scripts : 60s
+!     protected volatile int writeDelay = 60000;
+  
+      public void run() {
+  
+--- 372,381 ----
+      throws HsqlException, IOException;
+  
+      //
+!     public Object timerTask;
+  
+      // long write delay for scripts : 60s
+!     public volatile int writeDelay = 60000;
+  
+      public void run() {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBinary.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBinary.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBinary.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBinary.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 55,72 ****
+          super(db, file, includeCached, newFile, false);
+      }
+  
+!     protected void initBuffers() {
+          rowOut = new RowOutputBinary();
+      }
+  
+!     protected void writeSingleColumnResult(Result r)
+      throws IOException, HsqlException {
+          Result.write(r, rowOut, fileStreamOut);
+      }
+  
+      // int : row size (0 if no more rows) ,
+      // RowInput/OutputBinary : row (column values)
+!     protected void writeRow(Session session, Table t,
+                              Object[] data) throws IOException, HsqlException {
+  
+          rowOut.reset();
+--- 55,72 ----
+          super(db, file, includeCached, newFile, false);
+      }
+  
+!     public void initBuffers() {
+          rowOut = new RowOutputBinary();
+      }
+  
+!     public void writeSingleColumnResult(Result r)
+      throws IOException, HsqlException {
+          Result.write(r, rowOut, fileStreamOut);
+      }
+  
+      // int : row size (0 if no more rows) ,
+      // RowInput/OutputBinary : row (column values)
+!     public void writeRow(Session session, Table t,
+                              Object[] data) throws IOException, HsqlException {
+  
+          rowOut.reset();
+***************
+*** 77,83 ****
+      }
+  
+      // int : headersize (0 if no more tables), String : tablename, int : operation,
+!     protected void writeTableInit(Table t) throws HsqlException, IOException {
+  
+          tableRowCount = 0;
+  
+--- 77,83 ----
+      }
+  
+      // int : headersize (0 if no more tables), String : tablename, int : operation,
+!     public void writeTableInit(Table t) throws HsqlException, IOException {
+  
+          tableRowCount = 0;
+  
+***************
+*** 90,96 ****
+          fileStreamOut.write(rowOut.getBuffer(), 0, rowOut.size());
+      }
+  
+!     protected void writeTableTerm(Table t) throws IOException {
+  
+          rowOut.reset();
+          rowOut.writeSize(0);
+--- 90,96 ----
+          fileStreamOut.write(rowOut.getBuffer(), 0, rowOut.size());
+      }
+  
+!     public void writeTableTerm(Table t) throws IOException {
+  
+          rowOut.reset();
+          rowOut.writeSize(0);
+***************
+*** 98,104 ****
+          fileStreamOut.write(rowOut.getBuffer(), 0, rowOut.size());
+      }
+  
+!     protected void writeDataTerm() throws IOException {
+  
+          rowOut.reset();
+          rowOut.writeSize(0);
+--- 98,104 ----
+          fileStreamOut.write(rowOut.getBuffer(), 0, rowOut.size());
+      }
+  
+!     public void writeDataTerm() throws IOException {
+  
+          rowOut.reset();
+          rowOut.writeSize(0);
+***************
+*** 109,115 ****
+                                    String s)
+                                    throws IOException, HsqlException {}
+  
+!     protected void addSessionId(Session session) throws IOException {}
+  
+      public void writeDeleteStatement(Session session, Table table,
+                                       Object[] ddata)
+--- 109,115 ----
+                                    String s)
+                                    throws IOException, HsqlException {}
+  
+!     public void addSessionId(Session session) throws IOException {}
+  
+      public void writeDeleteStatement(Session session, Table table,
+                                       Object[] ddata)
+diff -crN misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterText.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterText.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterText.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterText.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 96,108 ****
+          super(db, file, includeCachedData, newFile, isDump);
+      }
+  
+!     protected void initBuffers() {
+          rowOut = new RowOutputTextLog();
+      }
+  
+!     protected void writeDataTerm() throws IOException {}
+  
+!     protected void addSessionId(Session session) throws IOException {
+  
+          if (session == null) {
+              return;
+--- 96,108 ----
+          super(db, file, includeCachedData, newFile, isDump);
+      }
+  
+!     public void initBuffers() {
+          rowOut = new RowOutputTextLog();
+      }
+  
+!     public void writeDataTerm() throws IOException {}
+  
+!     public void addSessionId(Session session) throws IOException {
+  
+          if (session == null) {
+              return;
+***************
+*** 123,129 ****
+          }
+      }
+  
+!     private void writeSchemaStatement(HsqlName schema) {
+  
+          rowOut.write(BYTES_SCHEMA);
+          rowOut.writeString(schema.statementName);
+--- 123,129 ----
+          }
+      }
+  
+!     public void writeSchemaStatement(HsqlName schema) {
+  
+          rowOut.write(BYTES_SCHEMA);
+          rowOut.writeString(schema.statementName);
+***************
+*** 152,158 ****
+          }
+      }
+  
+!     protected void writeRow(Session session, Table table,
+                              Object[] data) throws HsqlException, IOException {
+  
+          busyWriting = true;
+--- 152,158 ----
+          }
+      }
+  
+!     public void writeRow(Session session, Table table,
+                              Object[] data) throws HsqlException, IOException {
+  
+          busyWriting = true;
+***************
+*** 177,183 ****
+          }
+      }
+  
+!     protected void writeTableInit(Table t) throws HsqlException, IOException {
+  
+          if (t.isEmpty(currentSession)) {
+              return;
+--- 177,183 ----
+          }
+      }
+  
+!     public void writeTableInit(Table t) throws HsqlException, IOException {
+  
+          if (t.isEmpty(currentSession)) {
+              return;
+***************
+*** 275,281 ****
+          }
+      }
+  
+!     protected void finalize() {
+          sync();
+      }
+  }
+--- 275,281 ----
+          }
+      }
+  
+!     public void finalize() {
+          sync();
+      }
+  }
+diff -crN misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterZipped.java misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterZipped.java
+*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterZipped.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterZipped.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 48,54 ****
+   */
+  class ScriptWriterZipped extends ScriptWriterBinary {
+  
+!     private static final int bufferSize = 1 << 15;
+  
+      ScriptWriterZipped(Database db, String file, boolean includeCached,
+                         boolean newFile) throws HsqlException {
+--- 48,54 ----
+   */
+  class ScriptWriterZipped extends ScriptWriterBinary {
+  
+!     public static final int bufferSize = 1 << 15;
+  
+      ScriptWriterZipped(Database db, String file, boolean includeCached,
+                         boolean newFile) throws HsqlException {
+***************
+*** 60,66 ****
+       */
+      public void sync() {}
+  
+!     protected void openFile() throws HsqlException {
+  
+          try {
+              FileAccess           fa  = database.getFileAccess();
+--- 60,66 ----
+       */
+      public void sync() {}
+  
+!     public void openFile() throws HsqlException {
+  
+          try {
+              FileAccess           fa  = database.getFileAccess();
+***************
+*** 81,87 ****
+       * This may not really be necessary, unless we add implementations where
+       * non-compressed data is added to the end of the copressed part.
+       */
+!     protected void finishStream() throws IOException {
+          ((DeflaterOutputStream) fileStreamOut).finish();
+          fileStreamOut.flush();
+      }
+--- 81,87 ----
+       * This may not really be necessary, unless we add implementations where
+       * non-compressed data is added to the end of the copressed part.
+       */
+!     public void finishStream() throws IOException {
+          ((DeflaterOutputStream) fileStreamOut).finish();
+          fileStreamOut.flush();
+      }
+diff -crN misc/hsqldb/src/org/hsqldb/Select.java misc/build/hsqldb/src/org/hsqldb/Select.java
+*** misc/hsqldb/src/org/hsqldb/Select.java	2005-10-23 17:40:16.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Select.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 101,108 ****
+  
+      boolean               isDistinctSelect;
+      boolean               isAggregated;
+!     private boolean       isGrouped;
+!     private HashSet       groupColumnNames;
+      TableFilter[]         tFilter;
+      Expression            limitCondition;
+      Expression            queryCondition;     // null means no condition
+--- 101,108 ----
+  
+      boolean               isDistinctSelect;
+      boolean               isAggregated;
+!     public boolean       isGrouped;
+!     public HashSet       groupColumnNames;
+      TableFilter[]         tFilter;
+      Expression            limitCondition;
+      Expression            queryCondition;     // null means no condition
+***************
+*** 127,133 ****
+                            UNIONALL  = 2,
+                            INTERSECT = 3,
+                            EXCEPT    = 4;
+!     private boolean       simpleLimit;        // true if maxrows can be uses as is
+      Result.ResultMetaData resultMetaData;
+  
+      /**
+--- 127,133 ----
+                            UNIONALL  = 2,
+                            INTERSECT = 3,
+                            EXCEPT    = 4;
+!     public boolean       simpleLimit;        // true if maxrows can be uses as is
+      Result.ResultMetaData resultMetaData;
+  
+      /**
+***************
+*** 171,177 ****
+       *
+       * @throws HsqlException
+       */
+!     private void resolveTables() throws HsqlException {
+  
+          // replace the aliases with expressions
+          for (int i = iResultLen; i < exprColumns.length; i++) {
+--- 171,177 ----
+       *
+       * @throws HsqlException
+       */
+!     public void resolveTables() throws HsqlException {
+  
+          // replace the aliases with expressions
+          for (int i = iResultLen; i < exprColumns.length; i++) {
+***************
+*** 253,259 ****
+          }
+      }
+  
+!     private void setFilterConditions(Session session) throws HsqlException {
+  
+          if (queryCondition == null) {
+              return;
+--- 253,259 ----
+          }
+      }
+  
+!     public void setFilterConditions(Session session) throws HsqlException {
+  
+          if (queryCondition == null) {
+              return;
+***************
+*** 508,514 ****
+          return r;
+      }
+  
+!     private Result getResultMain(Session session) throws HsqlException {
+  
+          Result[] unionResults = new Result[unionArray.length];
+  
+--- 508,514 ----
+          return r;
+      }
+  
+!     public Result getResultMain(Session session) throws HsqlException {
+  
+          Result[] unionResults = new Result[unionArray.length];
+  
+***************
+*** 563,569 ****
+       * Merges the second result into the first using the unionMode
+       * set operation.
+       */
+!     private void mergeResults(Session session, Result first,
+                                Result second) throws HsqlException {
+  
+          switch (unionType) {
+--- 563,569 ----
+       * Merges the second result into the first using the unionMode
+       * set operation.
+       */
+!     public void mergeResults(Session session, Result first,
+                                Result second) throws HsqlException {
+  
+          switch (unionType) {
+***************
+*** 652,658 ****
+          return rowCount;
+      }
+  
+!     private Result getSingleResult(Session session,
+                                     int rowCount) throws HsqlException {
+  
+          if (resultMetaData == null) {
+--- 652,658 ----
+          return rowCount;
+      }
+  
+!     public Result getSingleResult(Session session,
+                                     int rowCount) throws HsqlException {
+  
+          if (resultMetaData == null) {
+***************
+*** 676,682 ****
+          return r;
+      }
+  
+!     private void prepareSort() {
+  
+          if (iOrderLen == 0) {
+              return;
+--- 676,682 ----
+          return r;
+      }
+  
+!     public void prepareSort() {
+  
+          if (iOrderLen == 0) {
+              return;
+***************
+*** 702,708 ****
+          }
+      }
+  
+!     private void sortResult(Session session, Result r) throws HsqlException {
+  
+          if (iOrderLen == 0) {
+              return;
+--- 702,708 ----
+          }
+      }
+  
+!     public void sortResult(Session session, Result r) throws HsqlException {
+  
+          if (iOrderLen == 0) {
+              return;
+***************
+*** 716,722 ****
+       * If any result column is aggregated, then all result columns need to be
+       * aggregated, unless it is included in the group by clause.
+       */
+!     private void checkAggregateOrGroupByColumns(int start,
+              int end) throws HsqlException {
+  
+          if (start < end) {
+--- 716,722 ----
+       * If any result column is aggregated, then all result columns need to be
+       * aggregated, unless it is included in the group by clause.
+       */
+!     public void checkAggregateOrGroupByColumns(int start,
+              int end) throws HsqlException {
+  
+          if (start < end) {
+***************
+*** 756,762 ****
+       * <LI>All the columns in the expression are defined in the group by clause;
+       * </UL)
+       */
+!     private boolean inAggregateOrGroupByClause(Expression exp) {
+  
+          if (isGrouped) {
+              return isSimilarIn(exp, iResultLen, iResultLen + iGroupLen)
+--- 756,762 ----
+       * <LI>All the columns in the expression are defined in the group by clause;
+       * </UL)
+       */
+!     public boolean inAggregateOrGroupByClause(Expression exp) {
+  
+          if (isGrouped) {
+              return isSimilarIn(exp, iResultLen, iResultLen + iGroupLen)
+***************
+*** 774,780 ****
+       * Check if the given expression is similar to any of the eColumn
+       * expressions within the given range.
+       */
+!     private boolean isSimilarIn(Expression exp, int start, int end) {
+  
+          for (int i = start; i < end; i++) {
+              if (exp.similarTo(exprColumns[i])) {
+--- 774,780 ----
+       * Check if the given expression is similar to any of the eColumn
+       * expressions within the given range.
+       */
+!     public boolean isSimilarIn(Expression exp, int start, int end) {
+  
+          for (int i = start; i < end; i++) {
+              if (exp.similarTo(exprColumns[i])) {
+***************
+*** 812,818 ****
+      }
+  
+  // fredt@users 20030810 - patch 1.7.2 - OUTER JOIN rewrite
+!     private Result buildResult(Session session,
+                                 int limitcount) throws HsqlException {
+  
+          GroupedResult gResult   = new GroupedResult(this, resultMetaData);
+--- 812,818 ----
+      }
+  
+  // fredt@users 20030810 - patch 1.7.2 - OUTER JOIN rewrite
+!     public Result buildResult(Session session,
+                                 int limitcount) throws HsqlException {
+  
+          GroupedResult gResult   = new GroupedResult(this, resultMetaData);
+diff -crN misc/hsqldb/src/org/hsqldb/ServerConfiguration.java misc/build/hsqldb/src/org/hsqldb/ServerConfiguration.java
+*** misc/hsqldb/src/org/hsqldb/ServerConfiguration.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/ServerConfiguration.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 49,55 ****
+   */
+  public final class ServerConfiguration implements ServerConstants {
+  
+!     private ServerConfiguration() {}
+  
+      /**
+       * Retrieves the default port that a Server will try to use in the
+--- 49,55 ----
+   */
+  public final class ServerConfiguration implements ServerConstants {
+  
+!     public ServerConfiguration() {}
+  
+      /**
+       * Retrieves the default port that a Server will try to use in the
+diff -crN misc/hsqldb/src/org/hsqldb/ServerConnection.java misc/build/hsqldb/src/org/hsqldb/ServerConnection.java
+*** misc/hsqldb/src/org/hsqldb/ServerConnection.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/ServerConnection.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 85,91 ****
+   *  and removed by this class when closed.<p>
+   *
+   *  When the database or server is shutdown, the signalClose() method is called
+!  *  for all current ServerConnection instances. This will call the private
+   *  close() method unless the ServerConnection thread itself has caused the
+   *  shutdown. In this case, the keepAlive flag is set to false, allowing the
+   *  thread to terminate once it has returned the result of the operation to
+--- 85,91 ----
+   *  and removed by this class when closed.<p>
+   *
+   *  When the database or server is shutdown, the signalClose() method is called
+!  *  for all current ServerConnection instances. This will call the public
+   *  close() method unless the ServerConnection thread itself has caused the
+   *  shutdown. In this case, the keepAlive flag is set to false, allowing the
+   *  thread to terminate once it has returned the result of the operation to
+***************
+*** 102,117 ****
+  class ServerConnection implements Runnable {
+  
+      boolean                      keepAlive;
+!     private String               user;
+!     private String               password;
+      int                          dbID;
+!     private volatile Session     session;
+!     private Socket               socket;
+!     private Server               server;
+!     private DataInputStream      dataInput;
+!     private BufferedOutputStream dataOutput;
+!     private static int           mCurrentThread = 0;
+!     private int                  mThread;
+      static final int             BUFFER_SIZE = 0x1000;
+      final byte[]                 mainBuffer  = new byte[BUFFER_SIZE];
+      RowOutputBinary              rowOut = new RowOutputBinary(BUFFER_SIZE);
+--- 102,117 ----
+  class ServerConnection implements Runnable {
+  
+      boolean                      keepAlive;
+!     public String               user;
+!     public String               password;
+      int                          dbID;
+!     public volatile Session     session;
+!     public Socket               socket;
+!     public Server               server;
+!     public DataInputStream      dataInput;
+!     public BufferedOutputStream dataOutput;
+!     public static int           mCurrentThread = 0;
+!     public int                  mThread;
+      static final int             BUFFER_SIZE = 0x1000;
+      final byte[]                 mainBuffer  = new byte[BUFFER_SIZE];
+      RowOutputBinary              rowOut = new RowOutputBinary(BUFFER_SIZE);
+***************
+*** 157,163 ****
+      /**
+       * Closes this connection.
+       */
+!     private void close() {
+  
+          if (session != null) {
+              session.close();
+--- 157,163 ----
+      /**
+       * Closes this connection.
+       */
+!     public void close() {
+  
+          if (session != null) {
+              session.close();
+***************
+*** 178,184 ****
+      /**
+       * Initializes this connection.
+       */
+!     private void init() {
+  
+          runnerThread = Thread.currentThread();
+          keepAlive    = true;
+--- 178,184 ----
+      /**
+       * Initializes this connection.
+       */
+!     public void init() {
+  
+          runnerThread = Thread.currentThread();
+          keepAlive    = true;
+***************
+*** 276,282 ****
+       * Used by pooled connections to close the existing SQL session and open
+       * a new one.
+       */
+!     private Result resetSession() {
+  
+          Result resultOut;
+  
+--- 276,282 ----
+       * Used by pooled connections to close the existing SQL session and open
+       * a new one.
+       */
+!     public Result resetSession() {
+  
+          Result resultOut;
+  
+diff -crN misc/hsqldb/src/org/hsqldb/Server.java misc/build/hsqldb/src/org/hsqldb/Server.java
+*** misc/hsqldb/src/org/hsqldb/Server.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Server.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 212,218 ****
+  public class Server implements HsqlSocketRequestHandler {
+  
+  //
+!     protected static final int serverBundleHandle =
+          BundleHandler.getBundleHandle("org_hsqldb_Server_messages", null);
+  
+  //
+--- 212,218 ----
+  public class Server implements HsqlSocketRequestHandler {
+  
+  //
+!     public static final int serverBundleHandle =
+          BundleHandler.getBundleHandle("org_hsqldb_Server_messages", null);
+  
+  //
+***************
+*** 229,250 ****
+      int[]            dbID;
+  
+  //  Currently unused
+!     private int maxConnections;
+  
+  //
+!     protected String            serverId;
+!     protected int               serverProtocol;
+!     protected ThreadGroup       serverConnectionThreadGroup;
+!     protected HsqlSocketFactory socketFactory;
+!     protected ServerSocket      socket;
+  
+  //
+!     private Thread           serverThread;
+!     private Throwable        serverError;
+!     private volatile int     serverState;
+!     private volatile boolean isSilent;
+!     private PrintWriter      logWriter;
+!     private PrintWriter      errWriter;
+  
+  //
+  
+--- 229,250 ----
+      int[]            dbID;
+  
+  //  Currently unused
+!     public int maxConnections;
+  
+  //
+!     public String            serverId;
+!     public int               serverProtocol;
+!     public ThreadGroup       serverConnectionThreadGroup;
+!     public HsqlSocketFactory socketFactory;
+!     public ServerSocket      socket;
+  
+  //
+!     public Thread           serverThread;
+!     public Throwable        serverError;
+!     public volatile int     serverState;
+!     public volatile boolean isSilent;
+!     public PrintWriter      logWriter;
+!     public PrintWriter      errWriter;
+  
+  //
+  
+***************
+*** 252,258 ****
+       * A specialized Thread inner class in which the run() method of this
+       * server executes.
+       */
+!     private class ServerThread extends Thread {
+  
+          /**
+           * Constructs a new thread in which to execute the run method
+--- 252,258 ----
+       * A specialized Thread inner class in which the run() method of this
+       * server executes.
+       */
+!     public class ServerThread extends Thread {
+  
+          /**
+           * Constructs a new thread in which to execute the run method
+***************
+*** 296,302 ****
+       * @param protocol the ServerConstants code indicating which
+       *      connection protocol to handle
+       */
+!     protected Server(int protocol) {
+          init(protocol);
+      }
+  
+--- 296,302 ----
+       * @param protocol the ServerConstants code indicating which
+       *      connection protocol to handle
+       */
+!     public Server(int protocol) {
+          init(protocol);
+      }
+  
+***************
+*** 416,422 ****
+          printWithThread("signalCloseAllServerConnections() exited");
+      }
+  
+!     protected void finalize() throws Throwable {
+  
+          if (serverThread != null) {
+              releaseServerSocket();
+--- 416,422 ----
+          printWithThread("signalCloseAllServerConnections() exited");
+      }
+  
+!     public void finalize() throws Throwable {
+  
+          if (serverThread != null) {
+              releaseServerSocket();
+***************
+*** 1284,1290 ****
+       *
+       * @param socket the socket to test.
+       */
+!     protected boolean allowConnection(Socket socket) {
+          return true;
+      }
+  
+--- 1284,1290 ----
+       *
+       * @param socket the socket to test.
+       */
+!     public boolean allowConnection(Socket socket) {
+          return true;
+      }
+  
+***************
+*** 1293,1299 ****
+       *
+       * @param protocol typically either SC_PROTOCOL_HTTP or SC_PROTOCOL_HSQL
+       */
+!     protected void init(int protocol) {
+  
+          // PRE:  This method is only called from the constructor
+          serverState      = ServerConstants.SERVER_STATE_SHUTDOWN;
+--- 1293,1299 ----
+       *
+       * @param protocol typically either SC_PROTOCOL_HTTP or SC_PROTOCOL_HSQL
+       */
+!     public void init(int protocol) {
+  
+          // PRE:  This method is only called from the constructor
+          serverState      = ServerConstants.SERVER_STATE_SHUTDOWN;
+***************
+*** 1313,1319 ****
+       *
+       * @param state the new value
+       */
+!     protected synchronized void setState(int state) {
+          serverState = state;
+      }
+  
+--- 1313,1319 ----
+       *
+       * @param state the new value
+       */
+!     public synchronized void setState(int state) {
+          serverState = state;
+      }
+  
+***************
+*** 1389,1395 ****
+       *
+       * @param msg The message to print
+       */
+!     protected synchronized void print(String msg) {
+  
+          PrintWriter writer = logWriter;
+  
+--- 1389,1395 ----
+       *
+       * @param msg The message to print
+       */
+!     public synchronized void print(String msg) {
+  
+          PrintWriter writer = logWriter;
+  
+***************
+*** 1434,1440 ****
+       *
+       * @param t the Throwable whose stack trace is to be printed
+       */
+!     protected synchronized void printStackTrace(Throwable t) {
+  
+          if (errWriter != null) {
+              t.printStackTrace(errWriter);
+--- 1434,1440 ----
+       *
+       * @param t the Throwable whose stack trace is to be printed
+       */
+!     public synchronized void printStackTrace(Throwable t) {
+  
+          if (errWriter != null) {
+              t.printStackTrace(errWriter);
+***************
+*** 1460,1466 ****
+       *
+       * @param msg the message to print
+       */
+!     protected void printWithThread(String msg) {
+  
+          if (!isSilent()) {
+              print("[" + Thread.currentThread() + "]: " + msg);
+--- 1460,1466 ----
+       *
+       * @param msg the message to print
+       */
+!     public void printWithThread(String msg) {
+  
+          if (!isSilent()) {
+              print("[" + Thread.currentThread() + "]: " + msg);
+***************
+*** 1474,1480 ****
+       *
+       * @param msg the message to print
+       */
+!     protected synchronized void printError(String msg) {
+  
+          PrintWriter writer = errWriter;
+  
+--- 1474,1480 ----
+       *
+       * @param msg the message to print
+       */
+!     public synchronized void printError(String msg) {
+  
+          PrintWriter writer = errWriter;
+  
+***************
+*** 1722,1728 ****
+      /**
+       * Initialises the database attributes lists from the server properties object.
+       */
+!     private void setDBInfoArrays() {
+  
+          dbAlias = getDBNameArray();
+          dbPath  = new String[dbAlias.length];
+--- 1722,1728 ----
+      /**
+       * Initialises the database attributes lists from the server properties object.
+       */
+!     public void setDBInfoArrays() {
+  
+          dbAlias = getDBNameArray();
+          dbPath  = new String[dbAlias.length];
+***************
+*** 1761,1767 ****
+       * Returns a possibly sparse array of all server.dbname.n values
+       * from the properties object.
+       */
+!     private String[] getDBNameArray() {
+  
+          final String prefix    = ServerConstants.SC_KEY_DBNAME + ".";
+          final int    prefixLen = prefix.length();
+--- 1761,1767 ----
+       * Returns a possibly sparse array of all server.dbname.n values
+       * from the properties object.
+       */
+!     public String[] getDBNameArray() {
+  
+          final String prefix    = ServerConstants.SC_KEY_DBNAME + ".";
+          final int    prefixLen = prefix.length();
+***************
+*** 1802,1808 ****
+       * @throws Exception if it is not possible to construct and install
+       *      a new ServerSocket
+       */
+!     private void openServerSocket() throws Exception {
+  
+          String    address;
+          int       port;
+--- 1802,1808 ----
+       * @throws Exception if it is not possible to construct and install
+       *      a new ServerSocket
+       */
+!     public void openServerSocket() throws Exception {
+  
+          String    address;
+          int       port;
+***************
+*** 1866,1872 ****
+      }
+  
+      /** Prints a timestamped message indicating that this server is online */
+!     private void printServerOnlineMessage() {
+  
+          String s = getProductName() + " " + getProductVersion()
+                     + " is online";
+--- 1866,1872 ----
+      }
+  
+      /** Prints a timestamped message indicating that this server is online */
+!     public void printServerOnlineMessage() {
+  
+          String s = getProductName() + " " + getProductVersion()
+                     + " is online";
+***************
+*** 1878,1884 ****
+      /**
+       * Prints a description of the server properties iff !isSilent().
+       */
+!     protected void printProperties() {
+  
+          Enumeration e;
+          String      key;
+--- 1878,1884 ----
+      /**
+       * Prints a description of the server properties iff !isSilent().
+       */
+!     public void printProperties() {
+  
+          Enumeration e;
+          String      key;
+***************
+*** 1906,1912 ****
+       * this method exists immediately, otherwise, the result is to fully
+       * shut down the server.
+       */
+!     private void releaseServerSocket() {
+  
+          printWithThread("releaseServerSocket() entered");
+  
+--- 1906,1912 ----
+       * this method exists immediately, otherwise, the result is to fully
+       * shut down the server.
+       */
+!     public void releaseServerSocket() {
+  
+          printWithThread("releaseServerSocket() entered");
+  
+***************
+*** 1935,1941 ****
+       * If any part of the process fails, then this server enters
+       * its shutdown sequence.
+       */
+!     private void run() {
+  
+          StopWatch   sw;
+          ThreadGroup tg;
+--- 1935,1941 ----
+       * If any part of the process fails, then this server enters
+       * its shutdown sequence.
+       */
+!     public void run() {
+  
+          StopWatch   sw;
+          ThreadGroup tg;
+***************
+*** 2019,2025 ****
+       *
+       * @param t The new value for the server error
+       */
+!     protected void setServerError(Throwable t) {
+          serverError = t;
+      }
+  
+--- 2019,2025 ----
+       *
+       * @param t The new value for the server error
+       */
+!     public void setServerError(Throwable t) {
+          serverError = t;
+      }
+  
+***************
+*** 2036,2042 ****
+       * @param error true if shutdown is in response to an error
+       *      state, else false
+       */
+!     protected void shutdown(boolean error) {
+  
+          StopWatch sw;
+  
+--- 2036,2042 ----
+       * @param error true if shutdown is in response to an error
+       *      state, else false
+       */
+!     public void shutdown(boolean error) {
+  
+          StopWatch sw;
+  
+***************
+*** 2115,2121 ****
+       *
+       * @param key for message
+       */
+!     protected static void printHelp(String key) {
+          System.out.print(BundleHandler.getString(serverBundleHandle, key));
+      }
+  }
+--- 2115,2121 ----
+       *
+       * @param key for message
+       */
+!     public static void printHelp(String key) {
+          System.out.print(BundleHandler.getString(serverBundleHandle, key));
+      }
+  }
+diff -crN misc/hsqldb/src/org/hsqldb/Servlet.java misc/build/hsqldb/src/org/hsqldb/Servlet.java
+*** misc/hsqldb/src/org/hsqldb/Servlet.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Servlet.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 127,139 ****
+   */
+  public class Servlet extends javax.servlet.http.HttpServlet {
+  
+!     private static final int BUFFER_SIZE = 256;
+!     private String           dbType;
+!     private String           dbPath;
+!     private String           errorStr;
+!     private RowOutputBinary  rowOut;
+!     private RowInputBinary   rowIn;
+!     private int              iQueries;
+  
+      /**
+       * Method declaration
+--- 127,139 ----
+   */
+  public class Servlet extends javax.servlet.http.HttpServlet {
+  
+!     public static final int BUFFER_SIZE = 256;
+!     public String           dbType;
+!     public String           dbPath;
+!     public String           errorStr;
+!     public RowOutputBinary  rowOut;
+!     public RowInputBinary   rowIn;
+!     public int              iQueries;
+  
+      /**
+       * Method declaration
+***************
+*** 190,196 ****
+          log("Initialization completed.");
+      }
+  
+!     private static long lModified = 0;
+  
+      /**
+       * Method declaration
+--- 190,196 ----
+          log("Initialization completed.");
+      }
+  
+!     public static long lModified = 0;
+  
+      /**
+       * Method declaration
+***************
+*** 200,206 ****
+       *
+       * @return
+       */
+!     protected long getLastModified(HttpServletRequest req) {
+  
+          // this is made so that the cache of the http server is not used
+          // maybe there is some other way
+--- 200,206 ----
+       *
+       * @return
+       */
+!     public long getLastModified(HttpServletRequest req) {
+  
+          // this is made so that the cache of the http server is not used
+          // maybe there is some other way
+diff -crN misc/hsqldb/src/org/hsqldb/Session.java misc/build/hsqldb/src/org/hsqldb/Session.java
+*** misc/hsqldb/src/org/hsqldb/Session.java	2005-11-04 20:36:52.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Session.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 112,156 ****
+  public class Session implements SessionInterface {
+  
+      //
+!     private volatile boolean isAutoCommit;
+!     private volatile boolean isReadOnly;
+!     private volatile boolean isClosed;
+  
+      //
+      Database          database;
+!     private User      user;
+!     HsqlArrayList     transactionList;
+!     private boolean   isNestedTransaction;
+!     private int       nestedOldTransIndex;
+      int               isolationMode = SessionInterface.TX_READ_COMMITTED;
+      long              actionTimestamp;
+      long              transactionTimestamp;
+!     private int       currentMaxRows;
+!     private int       sessionMaxRows;
+!     private Number    lastIdentity = ValuePool.getInt(0);
+!     private final int sessionId;
+      HashMappedList    savepoints;
+!     private boolean   script;
+!     private Tokenizer tokenizer;
+!     private Parser    parser;
+      static final Result emptyUpdateCount =
+          new Result(ResultConstants.UPDATECOUNT);
+  
+      //
+!     private jdbcConnection intConnection;
+  
+      // schema
+      public HsqlName  currentSchema;
+      public HsqlName  loggedSchema;
+!     private HsqlName oldSchema;
+  
+      // query processing
+      boolean isProcessingScript;
+      boolean isProcessingLog;
+  
+      // two types of temp tables
+!     private IntKeyHashMap indexArrayMap;
+!     private IntKeyHashMap indexArrayKeepMap;
+  
+      /** @todo fredt - clarify in which circumstances Session has to disconnect */
+      Session getSession() {
+--- 112,156 ----
+  public class Session implements SessionInterface {
+  
+      //
+!     public volatile boolean isAutoCommit;
+!     public volatile boolean isReadOnly;
+!     public volatile boolean isClosed;
+  
+      //
+      Database          database;
+!     public User      user;
+!     HsqlArrayList     rowActionList;
+!     public boolean   isNestedTransaction;
+!     public int       nestedOldTransIndex;
+      int               isolationMode = SessionInterface.TX_READ_COMMITTED;
+      long              actionTimestamp;
+      long              transactionTimestamp;
+!     public int       currentMaxRows;
+!     public int       sessionMaxRows;
+!     public Number    lastIdentity = ValuePool.getInt(0);
+!     public final int sessionId;
+      HashMappedList    savepoints;
+!     public boolean   script;
+!     public Tokenizer tokenizer;
+!     public Parser    parser;
+      static final Result emptyUpdateCount =
+          new Result(ResultConstants.UPDATECOUNT);
+  
+      //
+!     public jdbcConnection intConnection;
+  
+      // schema
+      public HsqlName  currentSchema;
+      public HsqlName  loggedSchema;
+!     public HsqlName oldSchema;
+  
+      // query processing
+      boolean isProcessingScript;
+      boolean isProcessingLog;
+  
+      // two types of temp tables
+!     public IntKeyHashMap indexArrayMap;
+!     public IntKeyHashMap indexArrayKeepMap;
+  
+      /** @todo fredt - clarify in which circumstances Session has to disconnect */
+      Session getSession() {
+***************
+*** 172,178 ****
+          sessionId                 = id;
+          database                  = db;
+          this.user                 = user;
+!         transactionList           = new HsqlArrayList(true);
+          savepoints                = new HashMappedList(4);
+          isAutoCommit              = autocommit;
+          isReadOnly                = readonly;
+--- 172,178 ----
+          sessionId                 = id;
+          database                  = db;
+          this.user                 = user;
+!         rowActionList             = new HsqlArrayList(true);
+          savepoints                = new HashMappedList(4);
+          isAutoCommit              = autocommit;
+          isReadOnly                = readonly;
+***************
+*** 228,234 ****
+  
+              database                  = null;
+              user                      = null;
+!             transactionList           = null;
+              savepoints                = null;
+              intConnection             = null;
+              compiledStatementExecutor = null;
+--- 228,234 ----
+  
+              database                  = null;
+              user                      = null;
+!             rowActionList             = null;
+              savepoints                = null;
+              intConnection             = null;
+              compiledStatementExecutor = null;
+***************
+*** 386,398 ****
+       * @param  row the deleted row
+       * @throws  HsqlException
+       */
+!     boolean addTransactionDelete(Table table, Row row) throws HsqlException {
+  
+          if (!isAutoCommit || isNestedTransaction) {
+              Transaction t = new Transaction(true, table, row,
+                                              actionTimestamp);
+  
+!             transactionList.add(t);
+              database.txManager.addTransaction(this, t);
+  
+              return true;
+--- 386,398 ----
+       * @param  row the deleted row
+       * @throws  HsqlException
+       */
+!     boolean addDeleteAction(Table table, Row row) throws HsqlException {
+  
+          if (!isAutoCommit || isNestedTransaction) {
+              Transaction t = new Transaction(true, table, row,
+                                              actionTimestamp);
+  
+!             rowActionList.add(t);
+              database.txManager.addTransaction(this, t);
+  
+              return true;
+***************
+*** 410,422 ****
+       * @param  row the inserted row
+       * @throws  HsqlException
+       */
+!     boolean addTransactionInsert(Table table, Row row) throws HsqlException {
+  
+          if (!isAutoCommit || isNestedTransaction) {
+              Transaction t = new Transaction(false, table, row,
+                                              actionTimestamp);
+  
+!             transactionList.add(t);
+              database.txManager.addTransaction(this, t);
+  
+              return true;
+--- 410,422 ----
+       * @param  row the inserted row
+       * @throws  HsqlException
+       */
+!     boolean addInsertAction(Table table, Row row) throws HsqlException {
+  
+          if (!isAutoCommit || isNestedTransaction) {
+              Transaction t = new Transaction(false, table, row,
+                                              actionTimestamp);
+  
+!             rowActionList.add(t);
+              database.txManager.addTransaction(this, t);
+  
+              return true;
+***************
+*** 469,475 ****
+          }
+  
+          synchronized (database) {
+!             if (!transactionList.isEmpty()) {
+                  try {
+                      database.logger.writeCommitStatement(this);
+                  } catch (HsqlException e) {}
+--- 469,475 ----
+          }
+  
+          synchronized (database) {
+!             if (!rowActionList.isEmpty()) {
+                  try {
+                      database.logger.writeCommitStatement(this);
+                  } catch (HsqlException e) {}
+***************
+*** 492,498 ****
+          }
+  
+          synchronized (database) {
+!             if (transactionList.size() != 0) {
+                  try {
+                      database.logger.writeToLog(this, Token.T_ROLLBACK);
+                  } catch (HsqlException e) {}
+--- 492,498 ----
+          }
+  
+          synchronized (database) {
+!             if (rowActionList.size() != 0) {
+                  try {
+                      database.logger.writeToLog(this, Token.T_ROLLBACK);
+                  } catch (HsqlException e) {}
+***************
+*** 520,526 ****
+      void savepoint(String name) throws HsqlException {
+  
+          savepoints.remove(name);
+!         savepoints.add(name, ValuePool.getInt(transactionList.size()));
+  
+          try {
+              database.logger.writeToLog(this, Token.T_SAVEPOINT + " " + name);
+--- 520,526 ----
+      void savepoint(String name) throws HsqlException {
+  
+          savepoints.remove(name);
+!         savepoints.add(name, ValuePool.getInt(rowActionList.size()));
+  
+          try {
+              database.logger.writeToLog(this, Token.T_SAVEPOINT + " " + name);
+***************
+*** 580,586 ****
+              Trace.doAssert(false, "beginNestedTransaction");
+          }
+  
+!         nestedOldTransIndex = transactionList.size();
+          isNestedTransaction = true;
+      }
+  
+--- 580,586 ----
+              Trace.doAssert(false, "beginNestedTransaction");
+          }
+  
+!         nestedOldTransIndex = rowActionList.size();
+          isNestedTransaction = true;
+      }
+  
+***************
+*** 703,709 ****
+  
+  // boucherb@users 20020810 metadata 1.7.2
+  //----------------------------------------------------------------
+!     private final long connectTime = System.currentTimeMillis();
+  
+  // more effecient for MetaData concerns than checkAdmin
+  
+--- 703,709 ----
+  
+  // boucherb@users 20020810 metadata 1.7.2
+  //----------------------------------------------------------------
+!     public final long connectTime = System.currentTimeMillis();
+  
+  // more effecient for MetaData concerns than checkAdmin
+  
+***************
+*** 731,737 ****
+       * @return the current value
+       */
+      int getTransactionSize() {
+!         return transactionList.size();
+      }
+  
+      /**
+--- 731,737 ----
+       * @return the current value
+       */
+      int getTransactionSize() {
+!         return rowActionList.size();
+      }
+  
+      /**
+***************
+*** 750,756 ****
+      CompiledStatementExecutor  compiledStatementExecutor;
+      CompiledStatementManager   compiledStatementManager;
+  
+!     private CompiledStatement sqlCompileStatement(String sql)
+      throws HsqlException {
+  
+          parser.reset(sql);
+--- 750,756 ----
+      CompiledStatementExecutor  compiledStatementExecutor;
+      CompiledStatementManager   compiledStatementManager;
+  
+!     public CompiledStatement sqlCompileStatement(String sql)
+      throws HsqlException {
+  
+          parser.reset(sql);
+***************
+*** 961,967 ****
+          }
+      }
+  
+!     private Result performPostExecute(Result r) {
+  
+          try {
+              if (database != null) {
+--- 961,967 ----
+          }
+      }
+  
+!     public Result performPostExecute(Result r) {
+  
+          try {
+              if (database != null) {
+***************
+*** 1015,1021 ****
+       * @throws HsqlException is a database access error occurs
+       * @return a MULTI Result describing the compiled statement.
+       */
+!     private Result sqlPrepare(String sql) {
+  
+          int csid =
+              database.compiledStatementManager.getStatementID(currentSchema,
+--- 1015,1021 ----
+       * @throws HsqlException is a database access error occurs
+       * @return a MULTI Result describing the compiled statement.
+       */
+!     public Result sqlPrepare(String sql) {
+  
+          int csid =
+              database.compiledStatementManager.getStatementID(currentSchema,
+***************
+*** 1067,1073 ****
+          return Result.newPrepareResponse(csid, rmd, pmd);
+      }
+  
+!     private Result sqlExecuteBatch(Result cmd) {
+  
+          int               csid;
+          Record            record;
+--- 1067,1073 ----
+          return Result.newPrepareResponse(csid, rmd, pmd);
+      }
+  
+!     public Result sqlExecuteBatch(Result cmd) {
+  
+          int               csid;
+          Record            record;
+***************
+*** 1130,1136 ****
+          return out;
+      }
+  
+!     private Result sqlExecuteBatchDirect(Result cmd) {
+  
+          Record record;
+          Result out;
+--- 1130,1136 ----
+          return out;
+      }
+  
+!     public Result sqlExecuteBatchDirect(Result cmd) {
+  
+          Record record;
+          Result out;
+***************
+*** 1191,1197 ****
+       *
+       * @return the result of executing the statement
+       */
+!     private Result sqlExecute(Result cmd) {
+  
+          int               csid = cmd.getStatementID();
+          CompiledStatement cs   = compiledStatementManager.getStatement(csid);
+--- 1191,1197 ----
+       *
+       * @return the result of executing the statement
+       */
+!     public Result sqlExecute(Result cmd) {
+  
+          int               csid = cmd.getStatementID();
+          CompiledStatement cs   = compiledStatementManager.getStatement(csid);
+***************
+*** 1213,1226 ****
+          return sqlExecute(cs, pvals);
+      }
+  
+!     private Result sqlExecute(CompiledStatement cs, Object[] pvals) {
+          return sqlExecuteCompiledNoPreChecks(cs, pvals);
+      }
+  
+      /**
+       * Recompile a prepard statement or free it if no longer valid
+       */
+!     private CompiledStatement recompileStatement(CompiledStatement cs,
+              int csid) {
+  
+          String sql = database.compiledStatementManager.getSql(csid);
+--- 1213,1226 ----
+          return sqlExecute(cs, pvals);
+      }
+  
+!     public Result sqlExecute(CompiledStatement cs, Object[] pvals) {
+          return sqlExecuteCompiledNoPreChecks(cs, pvals);
+      }
+  
+      /**
+       * Recompile a prepard statement or free it if no longer valid
+       */
+!     public CompiledStatement recompileStatement(CompiledStatement cs,
+              int csid) {
+  
+          String sql = database.compiledStatementManager.getSql(csid);
+***************
+*** 1249,1255 ****
+       *
+       * @param csid the numeric identifier of the statement
+       */
+!     private Result sqlFreeStatement(int csid) {
+  
+          Result result;
+  
+--- 1249,1255 ----
+       *
+       * @param csid the numeric identifier of the statement
+       */
+!     public Result sqlFreeStatement(int csid) {
+  
+          Result result;
+  
+diff -crN misc/hsqldb/src/org/hsqldb/SessionManager.java misc/build/hsqldb/src/org/hsqldb/SessionManager.java
+*** misc/hsqldb/src/org/hsqldb/SessionManager.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/SessionManager.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 45,52 ****
+  public class SessionManager {
+  
+      int                   sessionIdCount = 1;
+!     private IntKeyHashMap sessionMap     = new IntKeyHashMap();
+!     private Session       sysSession;
+  
+  // TODO:
+  //
+--- 45,52 ----
+  public class SessionManager {
+  
+      int                   sessionIdCount = 1;
+!     public IntKeyHashMap sessionMap     = new IntKeyHashMap();
+!     public Session       sysSession;
+  
+  // TODO:
+  //
+diff -crN misc/hsqldb/src/org/hsqldb/SetFunction.java misc/build/hsqldb/src/org/hsqldb/SetFunction.java
+*** misc/hsqldb/src/org/hsqldb/SetFunction.java	2005-10-23 18:26:28.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/SetFunction.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 51,74 ****
+   */
+  public class SetFunction {
+  
+!     private HashSet distinctValues;
+!     private boolean isDistinct;
+  
+      //
+!     private int setType;
+!     private int type;
+  
+      //
+!     private int count;
+  
+      //
+!     private boolean    hasNull;
+!     private boolean    every = true;
+!     private boolean    some  = false;
+!     private long       currentLong;
+!     private double     currentDouble;
+!     private BigDecimal currentBigDecimal;
+!     private Object     currentValue;
+  
+      SetFunction(int setType, int type, boolean isDistinct) {
+  
+--- 51,74 ----
+   */
+  public class SetFunction {
+  
+!     public HashSet distinctValues;
+!     public boolean isDistinct;
+  
+      //
+!     public int setType;
+!     public int type;
+  
+      //
+!     public int count;
+  
+      //
+!     public boolean    hasNull;
+!     public boolean    every = true;
+!     public boolean    some  = false;
+!     public long       currentLong;
+!     public double     currentDouble;
+!     public BigDecimal currentBigDecimal;
+!     public Object     currentValue;
+  
+      SetFunction(int setType, int type, boolean isDistinct) {
+  
+***************
+*** 423,435 ****
+      // end long sum
+      // statistics support - written by Campbell
+      // this section was orginally an independent class
+!     private double  sk;
+!     private double  vk;
+!     private long    n;
+!     private boolean initialized;
+!     private boolean sample;
+  
+!     private void addDataPoint(Number x) {    // optimized
+  
+          double xi;
+          double xsi;
+--- 423,435 ----
+      // end long sum
+      // statistics support - written by Campbell
+      // this section was orginally an independent class
+!     public double  sk;
+!     public double  vk;
+!     public long    n;
+!     public boolean initialized;
+!     public boolean sample;
+  
+!     public void addDataPoint(Number x) {    // optimized
+  
+          double xi;
+          double xsi;
+***************
+*** 458,464 ****
+          sk  += xi;
+      }
+  
+!     private Number getVariance() {
+  
+          if (!initialized) {
+              return null;
+--- 458,464 ----
+          sk  += xi;
+      }
+  
+!     public Number getVariance() {
+  
+          if (!initialized) {
+              return null;
+***************
+*** 469,475 ****
+                        : new Double(vk / (double) (n));
+      }
+  
+!     private Number getStdDev() {
+  
+          if (!initialized) {
+              return null;
+--- 469,475 ----
+                        : new Double(vk / (double) (n));
+      }
+  
+!     public Number getStdDev() {
+  
+          if (!initialized) {
+              return null;
+diff -crN misc/hsqldb/src/org/hsqldb/SchemaManager.java misc/build/hsqldb/src/org/hsqldb/SchemaManager.java
+*** misc/hsqldb/src/org/hsqldb/SchemaManager.java	2005-10-23 17:40:16.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/SchemaManager.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 350,356 ****
+  
+          if (t == null) {
+              if (!"INFORMATION_SCHEMA".equals(schema)) {
+!                 throw Trace.error(Trace.TABLE_NOT_FOUND);
+              }
+  
+              if (database.dbInfo != null) {
+--- 350,356 ----
+  
+          if (t == null) {
+              if (!"INFORMATION_SCHEMA".equals(schema)) {
+!                 throw Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ name });
+              }
+  
+              if (database.dbInfo != null) {
+***************
+*** 359,365 ****
+          }
+  
+          if (t == null) {
+!             throw Trace.error(Trace.TABLE_NOT_FOUND, name);
+          }
+  
+          return t;
+--- 359,365 ----
+          }
+  
+          if (t == null) {
+!             throw Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ name });
+          }
+  
+          return t;
+***************
+*** 377,383 ****
+          Table t = findUserTable(session, name, schema);
+  
+          if (t == null) {
+!             throw Trace.error(Trace.TABLE_NOT_FOUND, name);
+          }
+  
+          return t;
+--- 377,383 ----
+          Table t = findUserTable(session, name, schema);
+  
+          if (t == null) {
+!             throw Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ name });
+          }
+  
+          return t;
+***************
+*** 718,724 ****
+                  return;
+              } else {
+                  throw Trace.error(isView ? Trace.VIEW_NOT_FOUND
+!                                          : Trace.TABLE_NOT_FOUND, name);
+              }
+          }
+  
+--- 718,724 ----
+                  return;
+              } else {
+                  throw Trace.error(isView ? Trace.VIEW_NOT_FOUND
+!                                          : Trace.TABLE_NOT_FOUND, new Object[]{ name });
+              }
+          }
+  
+***************
+*** 728,734 ****
+  // ft - concurrent
+          session.commit();
+          dropTable(table, cascade);
+!         session.setScripting(!table.isTemp());
+      }
+  
+      void dropTable(Table table, boolean cascade) throws HsqlException {
+--- 728,734 ----
+  // ft - concurrent
+          session.commit();
+          dropTable(table, cascade);
+!         session.setScripting(true);
+      }
+  
+      void dropTable(Table table, boolean cascade) throws HsqlException {
+***************
+*** 775,781 ****
+      /**
+       * Throws if the table is referenced in a foreign key constraint.
+       */
+!     private void checkCascadeDropReferenced(Table table,
+              boolean cascade) throws HsqlException {
+  
+          Constraint[] constraints       = table.getConstraints();
+--- 775,781 ----
+      /**
+       * Throws if the table is referenced in a foreign key constraint.
+       */
+!     public void checkCascadeDropReferenced(Table table,
+              boolean cascade) throws HsqlException {
+  
+          Constraint[] constraints       = table.getConstraints();
+***************
+*** 898,904 ****
+      /**
+       * Returns an array of views that reference another view.
+       */
+!     private View[] getViewsWithView(View view) {
+  
+          HsqlArrayList list   = null;
+          Schema        schema = (Schema) schemaMap.get(view.getSchemaName());
+--- 898,904 ----
+      /**
+       * Returns an array of views that reference another view.
+       */
+!     public View[] getViewsWithView(View view) {
+  
+          HsqlArrayList list   = null;
+          Schema        schema = (Schema) schemaMap.get(view.getSchemaName());
+***************
+*** 927,933 ****
+       * Returns an array of views that reference the specified table or
+       * the specified column if column parameter is not null.
+       */
+!     private View[] getViewsWithTable(Table table, String column) {
+  
+          HsqlArrayList list = null;
+          Iterator      it   = allTablesIterator();
+--- 927,933 ----
+       * Returns an array of views that reference the specified table or
+       * the specified column if column parameter is not null.
+       */
+!     public View[] getViewsWithTable(Table table, String column) {
+  
+          HsqlArrayList list = null;
+          Iterator      it   = allTablesIterator();
+diff -crN misc/hsqldb/src/org/hsqldb/store/BaseHashMap.java misc/build/hsqldb/src/org/hsqldb/store/BaseHashMap.java
+*** misc/hsqldb/src/org/hsqldb/store/BaseHashMap.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/store/BaseHashMap.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 88,104 ****
+      boolean isObjectValue;
+  
+      //
+!     protected HashIndex hashIndex;
+  
+      //
+!     protected int[]    intKeyTable;
+!     protected Object[] objectKeyTable;
+!     protected long[]   longKeyTable;
+  
+      //
+!     protected int[]    intValueTable;
+!     protected Object[] objectValueTable;
+!     protected long[]   longValueTable;
+  
+      //
+      int   accessMin;
+--- 88,104 ----
+      boolean isObjectValue;
+  
+      //
+!     public HashIndex hashIndex;
+  
+      //
+!     public int[]    intKeyTable;
+!     public Object[] objectKeyTable;
+!     public long[]   longKeyTable;
+  
+      //
+!     public int[]    intValueTable;
+!     public Object[] objectValueTable;
+!     public long[]   longValueTable;
+  
+      //
+      int   accessMin;
+***************
+*** 110,135 ****
+      final int         initialCapacity;
+      int               threshold;
+      int               maxCapacity;
+!     protected int     purgePolicy = NO_PURGE;
+!     protected boolean minimizeOnEmpty;
+  
+      //
+      boolean hasZeroKey;
+      int     zeroKeyIndex = -1;
+  
+      // keyOrValueTypes
+!     protected static final int noKeyOrValue     = 0;
+!     protected static final int intKeyOrValue    = 1;
+!     protected static final int longKeyOrValue   = 2;
+!     protected static final int objectKeyOrValue = 3;
+  
+      // purgePolicy
+!     protected static final int NO_PURGE      = 0;
+!     protected static final int PURGE_ALL     = 1;
+!     protected static final int PURGE_HALF    = 2;
+!     protected static final int PURGE_QUARTER = 3;
+  
+!     protected BaseHashMap(int initialCapacity, float loadFactor, int keyType,
+                            int valueType,
+                            boolean hasAccessCount)
+                            throws IllegalArgumentException {
+--- 110,135 ----
+      final int         initialCapacity;
+      int               threshold;
+      int               maxCapacity;
+!     public int     purgePolicy = NO_PURGE;
+!     public boolean minimizeOnEmpty;
+  
+      //
+      boolean hasZeroKey;
+      int     zeroKeyIndex = -1;
+  
+      // keyOrValueTypes
+!     public static final int noKeyOrValue     = 0;
+!     public static final int intKeyOrValue    = 1;
+!     public static final int longKeyOrValue   = 2;
+!     public static final int objectKeyOrValue = 3;
+  
+      // purgePolicy
+!     public static final int NO_PURGE      = 0;
+!     public static final int PURGE_ALL     = 1;
+!     public static final int PURGE_HALF    = 2;
+!     public static final int PURGE_QUARTER = 3;
+  
+!     public BaseHashMap(int initialCapacity, float loadFactor, int keyType,
+                            int valueType,
+                            boolean hasAccessCount)
+                            throws IllegalArgumentException {
+***************
+*** 185,191 ****
+          }
+      }
+  
+!     protected int getLookup(Object key, int hash) {
+  
+          int    lookup = hashIndex.getLookup(hash);
+          Object tempKey;
+--- 185,191 ----
+          }
+      }
+  
+!     public int getLookup(Object key, int hash) {
+  
+          int    lookup = hashIndex.getLookup(hash);
+          Object tempKey;
+***************
+*** 201,207 ****
+          return lookup;
+      }
+  
+!     protected int getLookup(int key) {
+  
+          int lookup = hashIndex.getLookup(key);
+          int tempKey;
+--- 201,207 ----
+          return lookup;
+      }
+  
+!     public int getLookup(int key) {
+  
+          int lookup = hashIndex.getLookup(key);
+          int tempKey;
+***************
+*** 217,223 ****
+          return lookup;
+      }
+  
+!     protected int getLookup(long key) {
+  
+          int  lookup = hashIndex.getLookup((int) key);
+          long tempKey;
+--- 217,223 ----
+          return lookup;
+      }
+  
+!     public int getLookup(long key) {
+  
+          int  lookup = hashIndex.getLookup((int) key);
+          long tempKey;
+***************
+*** 236,242 ****
+      /**
+       * generic method for adding or removing keys
+       */
+!     protected Object addOrRemove(long longKey, long longValue,
+                                   Object objectKey, Object objectValue,
+                                   boolean remove) {
+  
+--- 236,242 ----
+      /**
+       * generic method for adding or removing keys
+       */
+!     public Object addOrRemove(long longKey, long longValue,
+                                   Object objectKey, Object objectValue,
+                                   boolean remove) {
+  
+***************
+*** 384,390 ****
+      /**
+       * type-specific method for adding or removing keys in int->Object maps
+       */
+!     protected Object addOrRemove(int intKey, Object objectValue,
+                                   boolean remove) {
+  
+          int    hash        = intKey;
+--- 384,390 ----
+      /**
+       * type-specific method for adding or removing keys in int->Object maps
+       */
+!     public Object addOrRemove(int intKey, Object objectValue,
+                                   boolean remove) {
+  
+          int    hash        = intKey;
+***************
+*** 466,472 ****
+      /**
+       * type specific method for Object sets or Object->Object maps
+       */
+!     protected Object removeObject(Object objectKey) {
+  
+          if (objectKey == null) {
+              return null;
+--- 466,472 ----
+      /**
+       * type specific method for Object sets or Object->Object maps
+       */
+!     public Object removeObject(Object objectKey) {
+  
+          if (objectKey == null) {
+              return null;
+***************
+*** 499,505 ****
+          return returnValue;
+      }
+  
+!     protected boolean reset() {
+  
+          if (maxCapacity == 0 || maxCapacity > threshold) {
+              rehash(hashIndex.hashTable.length * 2);
+--- 499,505 ----
+          return returnValue;
+      }
+  
+!     public boolean reset() {
+  
+          if (maxCapacity == 0 || maxCapacity > threshold) {
+              rehash(hashIndex.hashTable.length * 2);
+***************
+*** 531,537 ****
+       *
+       * newCapacity must be larger or equal to existing number of elements.
+       */
+!     protected void rehash(int newCapacity) {
+  
+          int     limitLookup     = hashIndex.newNodePointer;
+          boolean oldZeroKey      = hasZeroKey;
+--- 531,537 ----
+       *
+       * newCapacity must be larger or equal to existing number of elements.
+       */
+!     public void rehash(int newCapacity) {
+  
+          int     limitLookup     = hashIndex.newNodePointer;
+          boolean oldZeroKey      = hasZeroKey;
+***************
+*** 584,590 ****
+      /**
+       * resize the arrays contianing the key / value data
+       */
+!     private void resizeElementArrays(int dataLength, int newLength) {
+  
+          Object temp;
+          int    usedLength = newLength > dataLength ? dataLength
+--- 584,590 ----
+      /**
+       * resize the arrays contianing the key / value data
+       */
+!     public void resizeElementArrays(int dataLength, int newLength) {
+  
+          Object temp;
+          int    usedLength = newLength > dataLength ? dataLength
+***************
+*** 643,649 ****
+      /**
+       * clear all the key / value data in a range.
+       */
+!     private void clearElementArrays(final int from, final int to) {
+  
+          if (isIntKey) {
+              int counter = to;
+--- 643,649 ----
+      /**
+       * clear all the key / value data in a range.
+       */
+!     public void clearElementArrays(final int from, final int to) {
+  
+          if (isIntKey) {
+              int counter = to;
+***************
+*** 826,837 ****
+      /**
+       * row must already been freed of key / element
+       */
+!     protected void removeRow(int lookup) {
+          hashIndex.removeEmptyNode(lookup);
+          removeFromElementArrays(lookup);
+      }
+  
+!     protected Object removeLookup(int lookup) {
+  
+          if (isObjectKey) {
+              return addOrRemove(0, 0, objectKeyTable[lookup], null, true);
+--- 826,837 ----
+      /**
+       * row must already been freed of key / element
+       */
+!     public void removeRow(int lookup) {
+          hashIndex.removeEmptyNode(lookup);
+          removeFromElementArrays(lookup);
+      }
+  
+!     public Object removeLookup(int lookup) {
+  
+          if (isObjectKey) {
+              return addOrRemove(0, 0, objectKeyTable[lookup], null, true);
+***************
+*** 862,868 ****
+       * Return the max accessCount value for count elements with the lowest
+       * access count. Always return at least accessMin + 1
+       */
+!     protected int getAccessCountCeiling(int count, int margin) {
+          return ArrayCounter.rank(accessTable, hashIndex.newNodePointer,
+                                   count, accessMin + 1, accessCount, margin);
+      }
+--- 862,868 ----
+       * Return the max accessCount value for count elements with the lowest
+       * access count. Always return at least accessMin + 1
+       */
+!     public int getAccessCountCeiling(int count, int margin) {
+          return ArrayCounter.rank(accessTable, hashIndex.newNodePointer,
+                                   count, accessMin + 1, accessCount, margin);
+      }
+***************
+*** 873,879 ****
+       *
+       * Only for maps with Object key table
+       */
+!     protected void clear(int count, int margin) {
+  
+          if (margin < 64) {
+              margin = 64;
+--- 873,879 ----
+       *
+       * Only for maps with Object key table
+       */
+!     public void clear(int count, int margin) {
+  
+          if (margin < 64) {
+              margin = 64;
+***************
+*** 917,923 ****
+          return hashIndex.elementCount == 0;
+      }
+  
+!     protected boolean containsKey(Object key) {
+  
+          if (key == null) {
+              return false;
+--- 917,923 ----
+          return hashIndex.elementCount == 0;
+      }
+  
+!     public boolean containsKey(Object key) {
+  
+          if (key == null) {
+              return false;
+***************
+*** 929,935 ****
+                              : true;
+      }
+  
+!     protected boolean containsKey(int key) {
+  
+          int lookup = getLookup(key);
+  
+--- 929,935 ----
+                              : true;
+      }
+  
+!     public boolean containsKey(int key) {
+  
+          int lookup = getLookup(key);
+  
+***************
+*** 937,943 ****
+                              : true;
+      }
+  
+!     protected boolean containsKey(long key) {
+  
+          int lookup = getLookup(key);
+  
+--- 937,943 ----
+                              : true;
+      }
+  
+!     public boolean containsKey(long key) {
+  
+          int lookup = getLookup(key);
+  
+***************
+*** 945,951 ****
+                              : true;
+      }
+  
+!     protected boolean containsValue(Object value) {
+  
+          int lookup = 0;
+  
+--- 945,951 ----
+                              : true;
+      }
+  
+!     public boolean containsValue(Object value) {
+  
+          int lookup = 0;
+  
+***************
+*** 986,992 ****
+       * Iterator returns Object, int or long and is used both for keys and
+       * values
+       */
+!     protected class BaseHashIterator implements org.hsqldb.lib.Iterator {
+  
+          boolean keys;
+          int     lookup = -1;
+--- 986,992 ----
+       * Iterator returns Object, int or long and is used both for keys and
+       * values
+       */
+!     public class BaseHashIterator implements org.hsqldb.lib.Iterator {
+  
+          boolean keys;
+          int     lookup = -1;
+diff -crN misc/hsqldb/src/org/hsqldb/store/BitMap.java misc/build/hsqldb/src/org/hsqldb/store/BitMap.java
+*** misc/hsqldb/src/org/hsqldb/store/BitMap.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/store/BitMap.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 141,147 ****
+                                   : true;
+      }
+  
+!     private void doubleCapacity() {
+  
+          int[] newmap = new int[capacity * 2];
+  
+--- 141,147 ----
+                                   : true;
+      }
+  
+!     public void doubleCapacity() {
+  
+          int[] newmap = new int[capacity * 2];
+  
+diff -crN misc/hsqldb/src/org/hsqldb/store/ValuePoolHashMap.java misc/build/hsqldb/src/org/hsqldb/store/ValuePoolHashMap.java
+*** misc/hsqldb/src/org/hsqldb/store/ValuePoolHashMap.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/store/ValuePoolHashMap.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 98,104 ****
+          this.purgePolicy = newPolicy;
+      }
+  
+!     protected Integer getOrAddInteger(int intKey) {
+  
+          Integer testValue;
+          int     index      = hashIndex.getHashIndex(intKey);
+--- 98,104 ----
+          this.purgePolicy = newPolicy;
+      }
+  
+!     public Integer getOrAddInteger(int intKey) {
+  
+          Integer testValue;
+          int     index      = hashIndex.getHashIndex(intKey);
+***************
+*** 140,146 ****
+          return testValue;
+      }
+  
+!     protected Long getOrAddLong(long longKey) {
+  
+          Long testValue;
+          int index = hashIndex.getHashIndex((int) (longKey
+--- 140,146 ----
+          return testValue;
+      }
+  
+!     public Long getOrAddLong(long longKey) {
+  
+          Long testValue;
+          int index = hashIndex.getHashIndex((int) (longKey
+***************
+*** 199,205 ****
+       * and hashCode().
+       * @return String from map or a new String
+       */
+!     protected String getOrAddString(Object key) {
+  
+          String testValue;
+          int    index      = hashIndex.getHashIndex(key.hashCode());
+--- 199,205 ----
+       * and hashCode().
+       * @return String from map or a new String
+       */
+!     public String getOrAddString(Object key) {
+  
+          String testValue;
+          int    index      = hashIndex.getHashIndex(key.hashCode());
+***************
+*** 241,247 ****
+          return testValue;
+      }
+  
+!     protected Date getOrAddDate(long longKey) {
+  
+          Date testValue;
+          int  hash       = (int) longKey ^ (int) (longKey >>> 32);
+--- 241,247 ----
+          return testValue;
+      }
+  
+!     public Date getOrAddDate(long longKey) {
+  
+          Date testValue;
+          int  hash       = (int) longKey ^ (int) (longKey >>> 32);
+***************
+*** 284,290 ****
+          return testValue;
+      }
+  
+!     protected Double getOrAddDouble(long longKey) {
+  
+          Double testValue;
+          int index = hashIndex.getHashIndex((int) (longKey
+--- 284,290 ----
+          return testValue;
+      }
+  
+!     public Double getOrAddDouble(long longKey) {
+  
+          Double testValue;
+          int index = hashIndex.getHashIndex((int) (longKey
+***************
+*** 327,333 ****
+          return testValue;
+      }
+  
+!     protected Object getOrAddObject(Object key) {
+  
+          Object testValue;
+          int    index      = hashIndex.getHashIndex(key.hashCode());
+--- 327,333 ----
+          return testValue;
+      }
+  
+!     public Object getOrAddObject(Object key) {
+  
+          Object testValue;
+          int    index      = hashIndex.getHashIndex(key.hashCode());
+diff -crN misc/hsqldb/src/org/hsqldb/store/ValuePool.java misc/build/hsqldb/src/org/hsqldb/store/ValuePool.java
+*** misc/hsqldb/src/org/hsqldb/store/ValuePool.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/store/ValuePool.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 77,83 ****
+          initPool();
+      }
+  
+!     private static void initPool() {
+  
+          int[] sizeArray  = defaultPoolLookupSize;
+          int   sizeFactor = defaultSizeFactor;
+--- 77,83 ----
+          initPool();
+      }
+  
+!     public static void initPool() {
+  
+          int[] sizeArray  = defaultPoolLookupSize;
+          int   sizeFactor = defaultSizeFactor;
+diff -crN misc/hsqldb/src/org/hsqldb/TableFilter.java misc/build/hsqldb/src/org/hsqldb/TableFilter.java
+*** misc/hsqldb/src/org/hsqldb/TableFilter.java	2005-11-02 14:05:02.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/TableFilter.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 94,105 ****
+      static final int   CONDITION_END       = 3;    // candidate for eEnd
+      static final int   CONDITION_OUTER     = 4;    // add to this
+      Table              filterTable;
+!     private String     tableAlias;
+      HashMappedList     columnAliases;
+      Index              filterIndex;
+!     private Object[]   emptyData;
+      boolean[]          usedColumns;
+!     private Expression eStart, eEnd;
+  
+      //
+      Expression eAnd;
+--- 94,105 ----
+      static final int   CONDITION_END       = 3;    // candidate for eEnd
+      static final int   CONDITION_OUTER     = 4;    // add to this
+      Table              filterTable;
+!     public String     tableAlias;
+      HashMappedList     columnAliases;
+      Index              filterIndex;
+!     public Object[]   emptyData;
+      boolean[]          usedColumns;
+!     public Expression eStart, eEnd;
+  
+      //
+      Expression eAnd;
+***************
+*** 111,117 ****
+      Expression[] findFirstExpressions;             // expressions for column values
+  
+      //
+!     private RowIterator it;
+      Object[]            currentData;
+      Row                 currentRow;
+  
+--- 111,117 ----
+      Expression[] findFirstExpressions;             // expressions for column values
+  
+      //
+!     public RowIterator it;
+      Object[]            currentData;
+      Row                 currentRow;
+  
+***************
+*** 329,335 ****
+          }
+      }
+  
+!     private void setCondition(Session session,
+                                Expression e) throws HsqlException {
+  
+          int        type = e.getType();
+--- 329,335 ----
+          }
+      }
+  
+!     public void setCondition(Session session,
+                                Expression e) throws HsqlException {
+  
+          int        type = e.getType();
+***************
+*** 649,655 ****
+       *
+       * @param e the condition to add
+       */
+!     private void addAndCondition(Expression e) {
+  
+          Expression e2 = new Expression(e);
+  
+--- 649,655 ----
+       *
+       * @param e the condition to add
+       */
+!     public void addAndCondition(Expression e) {
+  
+          Expression e2 = new Expression(e);
+  
+diff -crN misc/hsqldb/src/org/hsqldb/Table.java misc/build/hsqldb/src/org/hsqldb/Table.java
+*** misc/hsqldb/src/org/hsqldb/Table.java	2005-11-05 19:09:56.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Table.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 134,142 ****
+      // main properties
+  // boucherb@users - access changed in support of metadata 1.7.2
+      public HashMappedList columnList;                 // columns in table
+!     private int[]         primaryKeyCols;             // column numbers for primary key
+!     private int[]         primaryKeyTypes;            // types for primary key
+!     private int[]         primaryKeyColsSequence;     // {0,1,2,...}
+      int[]                 bestRowIdentifierCols;      // column set for best index
+      boolean               bestRowIdentifierStrict;    // true if it has no nullable column
+      int[]                 bestIndexForColumn;         // index of the 'best' index for each column
+--- 134,142 ----
+      // main properties
+  // boucherb@users - access changed in support of metadata 1.7.2
+      public HashMappedList columnList;                 // columns in table
+!     public int[]         primaryKeyCols;             // column numbers for primary key
+!     public int[]         primaryKeyTypes;            // types for primary key
+!     public int[]         primaryKeyColsSequence;     // {0,1,2,...}
+      int[]                 bestRowIdentifierCols;      // column set for best index
+      boolean               bestRowIdentifierStrict;    // true if it has no nullable column
+      int[]                 bestIndexForColumn;         // index of the 'best' index for each column
+***************
+*** 148,177 ****
+  // -----------------------------------------------------------------------
+      Constraint[]      constraintList;                 // constrainst for the table
+      HsqlArrayList[]   triggerLists;                   // array of trigger lists
+!     private int[]     colTypes;                       // fredt - types of columns
+!     private int[]     colSizes;                       // fredt - copy of SIZE values for columns
+!     private int[]     colScales;                      // fredt - copy of SCALE values for columns
+!     private boolean[] colNullable;                    // fredt - modified copy of isNullable() values
+!     private Expression[] colDefaults;                 // fredt - expressions of DEFAULT values
+!     private int[]        defaultColumnMap;            // fred - holding 0,1,2,3,...
+!     private boolean      hasDefaultValues;            //fredt - shortcut for above
+      boolean              sqlEnforceSize;              // inherited from the database -
+  
+      // properties for subclasses
+!     protected int           columnCount;              // inclusive the hidden primary key
+      public Database         database;
+!     protected DataFileCache cache;
+!     protected HsqlName      tableName;                // SQL name
+!     private int             tableType;
+!     protected boolean       isReadOnly;
+!     protected boolean       isTemp;
+!     protected boolean       isCached;
+!     protected boolean       isText;
+!     protected boolean       isMemory;
+!     private boolean         isView;
+!     protected boolean       isLogged;
+!     protected int           indexType;                // fredt - type of index used
+!     protected boolean       onCommitPreserve;         // for temp tables
+  
+      //
+      PersistentStore rowStore;
+--- 148,177 ----
+  // -----------------------------------------------------------------------
+      Constraint[]      constraintList;                 // constrainst for the table
+      HsqlArrayList[]   triggerLists;                   // array of trigger lists
+!     public int[]     colTypes;                       // fredt - types of columns
+!     public int[]     colSizes;                       // fredt - copy of SIZE values for columns
+!     public int[]     colScales;                      // fredt - copy of SCALE values for columns
+!     public boolean[] colNullable;                    // fredt - modified copy of isNullable() values
+!     public Expression[] colDefaults;                 // fredt - expressions of DEFAULT values
+!     public int[]        defaultColumnMap;            // fred - holding 0,1,2,3,...
+!     public boolean      hasDefaultValues;            //fredt - shortcut for above
+      boolean              sqlEnforceSize;              // inherited from the database -
+  
+      // properties for subclasses
+!     public int           columnCount;              // inclusive the hidden primary key
+      public Database         database;
+!     public DataFileCache cache;
+!     public HsqlName      tableName;                // SQL name
+!     public int             tableType;
+!     public boolean       isReadOnly;
+!     public boolean       isTemp;
+!     public boolean       isCached;
+!     public boolean       isText;
+!     public boolean       isMemory;
+!     public boolean         isView;
+!     public boolean       isLogged;
+!     public int           indexType;                // fredt - type of index used
+!     public boolean       onCommitPreserve;         // for temp tables
+  
+      //
+      PersistentStore rowStore;
+***************
+*** 353,374 ****
+      /**
+       * For text tables
+       */
+!     protected void setDataSource(Session s, String source, boolean isDesc,
+                                   boolean newFile) throws HsqlException {
+!         throw (Trace.error(Trace.TABLE_NOT_FOUND));
+      }
+  
+      /**
+       * For text tables
+       */
+!     protected String getDataSource() {
+          return null;
+      }
+  
+      /**
+       * For text tables.
+       */
+!     protected boolean isDescDataSource() {
+          return false;
+      }
+  
+--- 353,374 ----
+      /**
+       * For text tables
+       */
+!     public void setDataSource(Session s, String source, boolean isDesc,
+                                   boolean newFile) throws HsqlException {
+!         throw (Trace.error(Trace.TABLE_NOT_FOUND, new Object[]{ tableName.name }));
+      }
+  
+      /**
+       * For text tables
+       */
+!     public String getDataSource() {
+          return null;
+      }
+  
+      /**
+       * For text tables.
+       */
+!     public boolean isDescDataSource() {
+          return false;
+      }
+  
+***************
+*** 613,619 ****
+      /**
+       * returns a basic duplicate of the table without the data structures.
+       */
+!     protected Table duplicate() throws HsqlException {
+  
+          Table t = (new Table(database, tableName, tableType));
+  
+--- 613,619 ----
+      /**
+       * returns a basic duplicate of the table without the data structures.
+       */
+!     public Table duplicate() throws HsqlException {
+  
+          Table t = (new Table(database, tableName, tableType));
+  
+***************
+*** 748,754 ****
+          return null;
+      }
+  
+!     private Table newDuplicate() throws HsqlException {
+  
+          Table tn = duplicate();
+  
+--- 748,754 ----
+          return null;
+      }
+  
+!     public Table newDuplicate() throws HsqlException {
+  
+          Table tn = duplicate();
+  
+***************
+*** 765,771 ****
+          return tn;
+      }
+  
+!     private void copyIndexes(Table tn, int removeIndex, int colIndex,
+                               int adjust) throws HsqlException {
+  
+          for (int i = 1; i < getIndexCount(); i++) {
+--- 765,771 ----
+          return tn;
+      }
+  
+!     public void copyIndexes(Table tn, int removeIndex, int colIndex,
+                               int adjust) throws HsqlException {
+  
+          for (int i = 1; i < getIndexCount(); i++) {
+***************
+*** 875,881 ****
+          }
+      }
+  
+!     private void recompileCheckConstraints(Session session)
+      throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+--- 875,881 ----
+          }
+      }
+  
+!     public void recompileCheckConstraints(Session session)
+      throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+***************
+*** 890,896 ****
+      /**
+       * Used after adding columns or indexes to the table.
+       */
+!     private void recompileCheckConstraint(Session session,
+                                            Constraint c) throws HsqlException {
+  
+          String     ddl       = c.core.check.getDDL();
+--- 890,896 ----
+      /**
+       * Used after adding columns or indexes to the table.
+       */
+!     public void recompileCheckConstraint(Session session,
+                                            Constraint c) throws HsqlException {
+  
+          String     ddl       = c.core.check.getDDL();
+***************
+*** 951,957 ****
+      /**
+       * Used for rename column.
+       */
+!     private void renameColumnInCheckConstraints(String oldname,
+              String newname, boolean isquoted) throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+--- 951,957 ----
+      /**
+       * Used for rename column.
+       */
+!     public void renameColumnInCheckConstraints(String oldname,
+              String newname, boolean isquoted) throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+***************
+*** 978,984 ****
+      /**
+       * Used for drop column.
+       */
+!     private void renameTableInCheckConstraints(Session session,
+              String oldname, String newname) throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+--- 978,984 ----
+      /**
+       * Used for drop column.
+       */
+!     public void renameTableInCheckConstraints(Session session,
+              String oldname, String newname) throws HsqlException {
+  
+          for (int i = 0, size = constraintList.length; i < size; i++) {
+***************
+*** 1097,1103 ****
+       * the first non-unique index. NULL if there is no user-defined index.
+       *
+       */
+!     private void setBestRowIdentifiers() {
+  
+          int[]   briCols      = null;
+          int     briColsCount = 0;
+--- 1097,1103 ----
+       * the first non-unique index. NULL if there is no user-defined index.
+       *
+       */
+!     void setBestRowIdentifiers() {
+  
+          int[]   briCols      = null;
+          int     briColsCount = 0;
+***************
+*** 1333,1339 ****
+       */
+      public void setIndexRoots(int[] roots) throws HsqlException {
+  
+!         Trace.check(isCached, Trace.TABLE_NOT_FOUND);
+  
+          for (int i = 0; i < getIndexCount(); i++) {
+              int p = roots[i];
+--- 1333,1339 ----
+       */
+      public void setIndexRoots(int[] roots) throws HsqlException {
+  
+!         Trace.check(isCached, Trace.TABLE_NOT_FOUND, new Object[]{ tableName.name });
+  
+          for (int i = 0; i < getIndexCount(); i++) {
+              int p = roots[i];
+***************
+*** 1359,1365 ****
+      void setIndexRoots(String s) throws HsqlException {
+  
+          // the user may try to set this; this is not only internal problem
+!         Trace.check(isCached, Trace.TABLE_NOT_FOUND);
+  
+          Tokenizer t     = new Tokenizer(s);
+          int[]     roots = new int[getIndexCount()];
+--- 1359,1365 ----
+      void setIndexRoots(String s) throws HsqlException {
+  
+          // the user may try to set this; this is not only internal problem
+!         Trace.check(isCached, Trace.TABLE_NOT_FOUND, new Object[]{ tableName.name });
+  
+          Tokenizer t     = new Tokenizer(s);
+          int[]     roots = new int[getIndexCount()];
+***************
+*** 1487,1493 ****
+       *  Create new index taking into account removal or addition of a column
+       *  to the table.
+       */
+!     private Index createAdjustedIndex(Index index, int colindex,
+                                        int adjust) throws HsqlException {
+  
+          int[] indexcolumns = (int[]) ArrayUtil.resizeArray(index.getColumns(),
+--- 1487,1493 ----
+       *  Create new index taking into account removal or addition of a column
+       *  to the table.
+       */
+!     public Index createAdjustedIndex(Index index, int colindex,
+                                        int adjust) throws HsqlException {
+  
+          int[] indexcolumns = (int[]) ArrayUtil.resizeArray(index.getColumns(),
+***************
+*** 1608,1614 ****
+          return indexNo;
+      }
+  
+!     private int addIndex(Index index) {
+  
+          int i = 0;
+  
+--- 1608,1614 ----
+          return indexNo;
+      }
+  
+!     public int addIndex(Index index) {
+  
+          int i = 0;
+  
+***************
+*** 1709,1715 ****
+      /**
+       * Returns empty Object array for a new row.
+       */
+!     Object[] getEmptyRowData() {
+          return new Object[columnCount];
+      }
+  
+--- 1709,1715 ----
+      /**
+       * Returns empty Object array for a new row.
+       */
+!     public Object[] getEmptyRowData() {
+          return new Object[columnCount];
+      }
+  
+***************
+*** 1854,1860 ****
+       *  Mid level method for inserting rows. Performs constraint checks and
+       *  fires row level triggers.
+       */
+!     private void insertRow(Session session,
+                             Object[] data) throws HsqlException {
+  
+          if (triggerLists[Trigger.INSERT_BEFORE_ROW] != null) {
+--- 1854,1860 ----
+       *  Mid level method for inserting rows. Performs constraint checks and
+       *  fires row level triggers.
+       */
+!     public void insertRow(Session session,
+                             Object[] data) throws HsqlException {
+  
+          if (triggerLists[Trigger.INSERT_BEFORE_ROW] != null) {
+***************
+*** 1901,1907 ****
+       *  UNIQUE or PRIMARY constraints are enforced by attempting to
+       *  add the row to the indexes.
+       */
+!     private void insertNoCheck(Session session,
+                                 Object[] data) throws HsqlException {
+  
+          Row row = newRow(data);
+--- 1901,1907 ----
+       *  UNIQUE or PRIMARY constraints are enforced by attempting to
+       *  add the row to the indexes.
+       */
+!     public void insertNoCheck(Session session,
+                                 Object[] data) throws HsqlException {
+  
+          Row row = newRow(data);
+***************
+*** 1910,1916 ****
+          indexRow(session, row);
+  
+          if (session != null) {
+!             session.addTransactionInsert(this, row);
+          }
+  
+          if (isLogged) {
+--- 1910,1916 ----
+          indexRow(session, row);
+  
+          if (session != null) {
+!             session.addInsertAction(this, row);
+          }
+  
+          if (isLogged) {
+***************
+*** 1930,1936 ****
+          indexRow(session, r);
+  
+          if (session != null) {
+!             session.addTransactionInsert(this, r);
+          }
+      }
+  
+--- 1930,1936 ----
+          indexRow(session, r);
+  
+          if (session != null) {
+!             session.addInsertAction(this, r);
+          }
+      }
+  
+***************
+*** 2032,2038 ****
+       * Used by TextCache to insert a row into the indexes when the source
+       * file is first read.
+       */
+!     protected void insertFromTextSource(CachedRow row) throws HsqlException {
+  
+          Object[] data = row.getData();
+  
+--- 2032,2038 ----
+       * Used by TextCache to insert a row into the indexes when the source
+       * file is first read.
+       */
+!     public void insertFromTextSource(CachedRow row) throws HsqlException {
+  
+          Object[] data = row.getData();
+  
+***************
+*** 2062,2068 ****
+      /**
+       * Checks a row against NOT NULL constraints on columns.
+       */
+!     protected void enforceNullConstraints(Object[] data)
+      throws HsqlException {
+  
+          for (int i = 0; i < columnCount; i++) {
+--- 2062,2068 ----
+      /**
+       * Checks a row against NOT NULL constraints on columns.
+       */
+!     public void enforceNullConstraints(Object[] data)
+      throws HsqlException {
+  
+          for (int i = 0; i < columnCount; i++) {
+***************
+*** 2078,2084 ****
+       * If there is an identity column (visible or hidden) on the table, sets
+       * the value and/or adjusts the iIdentiy value for the table.
+       */
+!     protected void setIdentityColumn(Session session,
+                                       Object[] data) throws HsqlException {
+  
+          if (identityColumn != -1) {
+--- 2078,2084 ----
+       * If there is an identity column (visible or hidden) on the table, sets
+       * the value and/or adjusts the iIdentiy value for the table.
+       */
+!     public void setIdentityColumn(Session session,
+                                       Object[] data) throws HsqlException {
+  
+          if (identityColumn != -1) {
+***************
+*** 2106,2112 ****
+       * If there is an identity column (visible or hidden) on the table, sets
+       * the max identity value.
+       */
+!     protected void updateIdentityValue(Object[] data) throws HsqlException {
+  
+          if (identityColumn != -1) {
+              Number id = (Number) data[identityColumn];
+--- 2106,2112 ----
+       * If there is an identity column (visible or hidden) on the table, sets
+       * the max identity value.
+       */
+!     public void updateIdentityValue(Object[] data) throws HsqlException {
+  
+          if (identityColumn != -1) {
+              Number id = (Number) data[identityColumn];
+***************
+*** 2778,2784 ****
+       *  Mid level row delete method. Fires triggers but no integrity
+       *  constraint checks.
+       */
+!     private void deleteNoRefCheck(Session session,
+                                    Row row) throws HsqlException {
+  
+          Object[] data = row.getData();
+--- 2778,2784 ----
+       *  Mid level row delete method. Fires triggers but no integrity
+       *  constraint checks.
+       */
+!     public void deleteNoRefCheck(Session session,
+                                    Row row) throws HsqlException {
+  
+          Object[] data = row.getData();
+***************
+*** 2794,2800 ****
+       * Low level row delete method. Removes the row from the indexes and
+       * from the Cache.
+       */
+!     private void deleteNoCheck(Session session, Row row,
+                                 boolean log) throws HsqlException {
+  
+          if (row.isCascadeDeleted()) {
+--- 2794,2800 ----
+       * Low level row delete method. Removes the row from the indexes and
+       * from the Cache.
+       */
+!     public void deleteNoCheck(Session session, Row row,
+                                 boolean log) throws HsqlException {
+  
+          if (row.isCascadeDeleted()) {
+***************
+*** 2814,2820 ****
+          row.delete();
+  
+          if (session != null) {
+!             boolean tx = session.addTransactionDelete(this, row);
+          }
+  
+          if (log && isLogged) {
+--- 2814,2820 ----
+          row.delete();
+  
+          if (session != null) {
+!             session.addDeleteAction(this, row);
+          }
+  
+          if (log && isLogged) {
+***************
+*** 2896,2902 ****
+          row.delete();
+  
+          if (session != null) {
+!             session.addTransactionDelete(this, row);
+          }
+      }
+  
+--- 2896,2902 ----
+          row.delete();
+  
+          if (session != null) {
+!             session.addDeleteAction(this, row);
+          }
+      }
+  
+diff -crN misc/hsqldb/src/org/hsqldb/TableWorks.java misc/build/hsqldb/src/org/hsqldb/TableWorks.java
+*** misc/hsqldb/src/org/hsqldb/TableWorks.java	2005-10-23 17:40:18.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/TableWorks.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 46,53 ****
+   */
+  class TableWorks {
+  
+!     private Table   table;
+!     private Session session;
+  
+      TableWorks(Session session, Table table) {
+          this.table   = table;
+--- 46,53 ----
+   */
+  class TableWorks {
+  
+!     public Table   table;
+!     public Session session;
+  
+      TableWorks(Session session, Table table) {
+          this.table   = table;
+diff -crN misc/hsqldb/src/org/hsqldb/test/ExecHarness.java misc/build/hsqldb/src/org/hsqldb/test/ExecHarness.java
+*** misc/hsqldb/src/org/hsqldb/test/ExecHarness.java	2005-10-23 19:25:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/ExecHarness.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 78,86 ****
+       * target program by a file, so that's all I'm implementing for stdin
+       * right now.
+       */
+!     private static final String SYNTAX_MSG =
+          "SYNTAX:  java org.hsqldb.test.ExecHarness targetprogram [args...]";
+!     private static final int MAX_PROG_OUTPUT = 10240;
+  
+      /**
+       * To test the ExecHarness class itself.
+--- 78,86 ----
+       * target program by a file, so that's all I'm implementing for stdin
+       * right now.
+       */
+!     public static final String SYNTAX_MSG =
+          "SYNTAX:  java org.hsqldb.test.ExecHarness targetprogram [args...]";
+!     public static final int MAX_PROG_OUTPUT = 10240;
+  
+      /**
+       * To test the ExecHarness class itself.
+***************
+*** 155,164 ****
+  
+      // The extra 1 is so we can request 1 more byte than we want.
+      // If that read is satisfied, we know that we read > MAX_PROG_OUTPUT.
+!     private byte[]              ba = new byte[MAX_PROG_OUTPUT + 1];
+!     private String              stdout          = null;
+!     private String              errout          = null;
+!     private static final String DEFAULT_CHARSET = "US-ASCII";
+  
+      /*
+       * Execute associated program synchronously, but in a separate process.
+--- 155,164 ----
+  
+      // The extra 1 is so we can request 1 more byte than we want.
+      // If that read is satisfied, we know that we read > MAX_PROG_OUTPUT.
+!     public byte[]              ba = new byte[MAX_PROG_OUTPUT + 1];
+!     public String              stdout          = null;
+!     public String              errout          = null;
+!     public static final String DEFAULT_CHARSET = "US-ASCII";
+  
+      /*
+       * Execute associated program synchronously, but in a separate process.
+diff -crN misc/hsqldb/src/org/hsqldb/test/SqlToolHarness.java misc/build/hsqldb/src/org/hsqldb/test/SqlToolHarness.java
+*** misc/hsqldb/src/org/hsqldb/test/SqlToolHarness.java	2005-10-23 19:25:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/SqlToolHarness.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 47,54 ****
+   */
+  public class SqlToolHarness {
+  
+!     private static final int MAX_SQLFILE_LEN = 10240;
+!     private static final String SYNTAX_MSG =
+          "SYNTAX:  java org.hsqldb.test.SqlToolHarness file1.sql [file2.sq...]";
+  
+      /**
+--- 47,54 ----
+   */
+  public class SqlToolHarness {
+  
+!     public static final int MAX_SQLFILE_LEN = 10240;
+!     public static final String SYNTAX_MSG =
+          "SYNTAX:  java org.hsqldb.test.SqlToolHarness file1.sql [file2.sq...]";
+  
+      /**
+***************
+*** 97,103 ****
+          Verbose = (tmp != null) && (tmp.trim().length() > 0);
+      }
+  
+!     private boolean Verbose = false;
+  
+      /**
+       * Run SqlTool according to metacommands embedded in given SQL file.
+--- 97,103 ----
+          Verbose = (tmp != null) && (tmp.trim().length() > 0);
+      }
+  
+!     public boolean Verbose = false;
+  
+      /**
+       * Run SqlTool according to metacommands embedded in given SQL file.
+***************
+*** 219,230 ****
+          return true;
+      }
+  
+!     private static String[]  mtString  = {};
+!     private static Pattern[] mtPattern = {};
+  
+!     private class Metadata {
+  
+!         private byte[] ba = new byte[MAX_SQLFILE_LEN + 1];
+  
+          public Metadata(File inFile)
+          throws FileNotFoundException, IOException {
+--- 219,230 ----
+          return true;
+      }
+  
+!     public static String[]  mtString  = {};
+!     public static Pattern[] mtPattern = {};
+  
+!     public class Metadata {
+  
+!         public byte[] ba = new byte[MAX_SQLFILE_LEN + 1];
+  
+          public Metadata(File inFile)
+          throws FileNotFoundException, IOException {
+***************
+*** 284,297 ****
+              }
+          }
+  
+!         private String[]  toolargs              = mtString;
+!         private String[]  jvmargs               = mtString;
+!         private Pattern[] requireStdoutPatterns = mtPattern;
+!         private Pattern[] rejectStdoutPatterns  = mtPattern;
+!         private Pattern[] requireErroutPatterns = mtPattern;
+!         private Pattern[] rejectErroutPatterns  = mtPattern;
+!         private boolean   inputAsFile           = false;
+!         private Integer   exitValue             = new Integer(0);
+  
+          public String toString() {
+  
+--- 284,297 ----
+              }
+          }
+  
+!         public String[]  toolargs              = mtString;
+!         public String[]  jvmargs               = mtString;
+!         public Pattern[] requireStdoutPatterns = mtPattern;
+!         public Pattern[] rejectStdoutPatterns  = mtPattern;
+!         public Pattern[] requireErroutPatterns = mtPattern;
+!         public Pattern[] rejectErroutPatterns  = mtPattern;
+!         public boolean   inputAsFile           = false;
+!         public Integer   exitValue             = new Integer(0);
+  
+          public String toString() {
+  
+***************
+*** 315,321 ****
+              return sb.toString();
+          }
+  
+!         private String getHarnessMetaBlock(File inFile)
+          throws FileNotFoundException, IOException {
+  
+              // The extra 1 is so we can request 1 more byte than we want.
+--- 315,321 ----
+              return sb.toString();
+          }
+  
+!         public String getHarnessMetaBlock(File inFile)
+          throws FileNotFoundException, IOException {
+  
+              // The extra 1 is so we can request 1 more byte than we want.
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestAllTypes.java misc/build/hsqldb/src/org/hsqldb/test/TestAllTypes.java
+*** misc/hsqldb/src/org/hsqldb/test/TestAllTypes.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestAllTypes.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 48,59 ****
+   */
+  public class TestAllTypes {
+  
+!     protected String url = "jdbc:hsqldb:";
+  
+! //    protected String filepath = ".";
+!     protected String filepath = "/hsql/testalltypes/test";
+  
+! //    protected String filepath = "hsql://localhost/yourtest";
+      boolean    network = true;
+      String     user;
+      String     password;
+--- 48,59 ----
+   */
+  public class TestAllTypes {
+  
+!     public String url = "jdbc:hsqldb:";
+  
+! //    public String filepath = ".";
+!     public String filepath = "/hsql/testalltypes/test";
+  
+! //    public String filepath = "hsql://localhost/yourtest";
+      boolean    network = true;
+      String     user;
+      String     password;
+***************
+*** 79,85 ****
+      //
+      int bigrows = 1000;
+  
+!     protected void setUp() {
+  
+          user     = "sa";
+          password = "";
+--- 79,85 ----
+      //
+      int bigrows = 1000;
+  
+!     public void setUp() {
+  
+          user     = "sa";
+          password = "";
+***************
+*** 266,274 ****
+          }
+      }
+  
+!     protected void tearDown() {}
+  
+!     protected void checkResults() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+--- 266,274 ----
+          }
+      }
+  
+!     public void tearDown() {}
+  
+!     public void checkResults() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+***************
+*** 313,319 ****
+          }
+      }
+  
+!     private void checkSelects() {
+  
+          StopWatch        sw        = new StopWatch();
+          int              smallrows = 0xfff;
+--- 313,319 ----
+          }
+      }
+  
+!     public void checkSelects() {
+  
+          StopWatch        sw        = new StopWatch();
+          int              smallrows = 0xfff;
+***************
+*** 368,374 ****
+                             + (i * 1000 / sw.elapsedTime()));
+      }
+  
+!     private void checkUpdates() {
+  
+          StopWatch        sw        = new StopWatch();
+          int              smallrows = 0xfff;
+--- 368,374 ----
+                             + (i * 1000 / sw.elapsedTime()));
+      }
+  
+!     public void checkUpdates() {
+  
+          StopWatch        sw        = new StopWatch();
+          int              smallrows = 0xfff;
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestBase.java misc/build/hsqldb/src/org/hsqldb/test/TestBase.java
+*** misc/hsqldb/src/org/hsqldb/test/TestBase.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestBase.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 59,65 ****
+          super(name);
+      }
+  
+!     protected void setUp() {
+  
+          if (isNetwork) {
+              url    = "jdbc:hsqldb:hsql://localhost/test";
+--- 59,65 ----
+          super(name);
+      }
+  
+!     public void setUp() {
+  
+          if (isNetwork) {
+              url    = "jdbc:hsqldb:hsql://localhost/test";
+***************
+*** 83,89 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          if (isNetwork) {
+              server.stop();
+--- 83,89 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          if (isNetwork) {
+              server.stop();
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestBugBase.java misc/build/hsqldb/src/org/hsqldb/test/TestBugBase.java
+*** misc/hsqldb/src/org/hsqldb/test/TestBugBase.java	2005-06-08 19:09:54.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestBugBase.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 59,65 ****
+          super(name);
+      }
+  
+!     protected void setUp() {
+  
+          server = new Server();
+  
+--- 59,65 ----
+          super(name);
+      }
+  
+!     public void setUp() {
+  
+          server = new Server();
+  
+***************
+*** 76,82 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          server.stop();
+  
+--- 76,82 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          server.stop();
+  
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestCacheSize.java misc/build/hsqldb/src/org/hsqldb/test/TestCacheSize.java
+*** misc/hsqldb/src/org/hsqldb/test/TestCacheSize.java	2005-10-27 21:46:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestCacheSize.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 70,86 ****
+  public class TestCacheSize {
+  
+      // program can edit the *.properties file to set cache_size, old files are deleted
+!     protected boolean filedb = true;
+  
+      // shutdown performed mid operation - not for mem: or hsql: URL's
+!     protected boolean shutdown = true;
+  
+      // fixed
+!     protected String url = "jdbc:hsqldb:";
+  
+! //    protected String  filepath = "hsql://localhost/mytest";
+! //    protected String filepath = "mem:test";
+!     protected String filepath = "/hsql/testcache/test";
+  
+      // frequent reporting of progress
+      boolean reportProgress = false;
+--- 70,86 ----
+  public class TestCacheSize {
+  
+      // program can edit the *.properties file to set cache_size, old files are deleted
+!     public boolean filedb = true;
+  
+      // shutdown performed mid operation - not for mem: or hsql: URL's
+!     public boolean shutdown = true;
+  
+      // fixed
+!     public String url = "jdbc:hsqldb:";
+  
+! //    public String  filepath = "hsql://localhost/mytest";
+! //    public String filepath = "mem:test";
+!     public String filepath = "/hsql/testcache/test";
+  
+      // frequent reporting of progress
+      boolean reportProgress = false;
+***************
+*** 124,137 ****
+      Connection cConnection;
+      FileWriter writer;
+  
+!     private void checkSelects() {
+  
+          countTestID();
+          selectID();
+          selectZipTable();
+      }
+  
+!     private void checkUpdates() {
+  
+          updateIDLinear();
+          updateID();
+--- 124,137 ----
+      Connection cConnection;
+      FileWriter writer;
+  
+!     public void checkSelects() {
+  
+          countTestID();
+          selectID();
+          selectZipTable();
+      }
+  
+!     public void checkUpdates() {
+  
+          updateIDLinear();
+          updateID();
+***************
+*** 141,147 ****
+          countZip();
+      }
+  
+!     protected void setUp() {
+  
+          try {
+              writer = new FileWriter("speedtests.html", true);
+--- 141,147 ----
+          countZip();
+      }
+  
+!     public void setUp() {
+  
+          try {
+              writer = new FileWriter("speedtests.html", true);
+***************
+*** 313,319 ****
+          }
+      }
+  
+!     private void fillUpBigTable(String filler,
+                                  Random randomgen) throws SQLException {
+  
+          StopWatch sw = new StopWatch();
+--- 313,319 ----
+          }
+      }
+  
+!     public void fillUpBigTable(String filler,
+                                  Random randomgen) throws SQLException {
+  
+          StopWatch sw = new StopWatch();
+***************
+*** 415,421 ****
+                             + " ms -- " + rate + " tps");
+      }
+  
+!     private void fillUpMultiTable(String filler,
+                                    Random randomgen) throws SQLException {
+  
+          StopWatch sw = new StopWatch();
+--- 415,421 ----
+                             + " ms -- " + rate + " tps");
+      }
+  
+!     public void fillUpMultiTable(String filler,
+                                    Random randomgen) throws SQLException {
+  
+          StopWatch sw = new StopWatch();
+***************
+*** 468,474 ****
+                             + (i * 1000 / (sw.elapsedTime() + 1)));
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              writer.write("\n</table>\n");
+--- 468,474 ----
+                             + (i * 1000 / (sw.elapsedTime() + 1)));
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              writer.write("\n</table>\n");
+***************
+*** 476,482 ****
+          } catch (Exception e) {}
+      }
+  
+!     protected void checkResults() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+--- 476,482 ----
+          } catch (Exception e) {}
+      }
+  
+!     public void checkResults() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+***************
+*** 623,629 ****
+                             + " rows  -- " + time + " ms -- " + rate + " tps");
+      }
+  
+!     private void countTestID() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+--- 623,629 ----
+                             + " rows  -- " + time + " ms -- " + rate + " tps");
+      }
+  
+!     public void countTestID() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+***************
+*** 646,652 ****
+          } catch (SQLException e) {}
+      }
+  
+!     private void countTestZip() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+--- 646,652 ----
+          } catch (SQLException e) {}
+      }
+  
+!     public void countTestZip() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+***************
+*** 667,673 ****
+          } catch (SQLException e) {}
+      }
+  
+!     private void countZip() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+--- 667,673 ----
+          } catch (SQLException e) {}
+      }
+  
+!     public void countZip() {
+  
+          try {
+              StopWatch sw = new StopWatch();
+***************
+*** 682,688 ****
+          } catch (SQLException e) {}
+      }
+  
+!     private void updateZip() {
+  
+          StopWatch        sw        = new StopWatch();
+          java.util.Random randomgen = new java.util.Random();
+--- 682,688 ----
+          } catch (SQLException e) {}
+      }
+  
+!     public void updateZip() {
+  
+          StopWatch        sw        = new StopWatch();
+          java.util.Random randomgen = new java.util.Random();
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestCascade.java misc/build/hsqldb/src/org/hsqldb/test/TestCascade.java
+*** misc/hsqldb/src/org/hsqldb/test/TestCascade.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestCascade.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 59,65 ****
+          super(name);
+      }
+  
+!     protected void setUp() {
+  
+          try {
+              Class.forName("org.hsqldb.jdbcDriver");
+--- 59,65 ----
+          super(name);
+      }
+  
+!     public void setUp() {
+  
+          try {
+              Class.forName("org.hsqldb.jdbcDriver");
+***************
+*** 72,78 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              con.close();
+--- 72,78 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              con.close();
+***************
+*** 109,115 ****
+          }
+      }
+  
+!     private static void createDatabase() throws SQLException {
+  
+          new File("testdb.backup").delete();
+          new File("testdb.data").delete();
+--- 109,115 ----
+          }
+      }
+  
+!     public static void createDatabase() throws SQLException {
+  
+          new File("testdb.backup").delete();
+          new File("testdb.data").delete();
+***************
+*** 141,147 ****
+       * the CA table has 12 records. After, it should have 9, but instead it has
+       * 0.
+       */
+!     private static void deleteXBRecord(Connection con) throws SQLException {
+  
+          Statement stmt = con.createStatement();
+  
+--- 141,147 ----
+       * the CA table has 12 records. After, it should have 9, but instead it has
+       * 0.
+       */
+!     public static void deleteXBRecord(Connection con) throws SQLException {
+  
+          Statement stmt = con.createStatement();
+  
+***************
+*** 150,156 ****
+          stmt.close();
+      }    // deleteXBRecord
+  
+!     private static void insertData(Connection con) throws SQLException {
+  
+          String[] saData = {
+              "INSERT INTO XB VALUES('T850','LEAA','00','P',NULL,'LCN NAME','sa',NOW)",
+--- 150,156 ----
+          stmt.close();
+      }    // deleteXBRecord
+  
+!     public static void insertData(Connection con) throws SQLException {
+  
+          String[] saData = {
+              "INSERT INTO XB VALUES('T850','LEAA','00','P',NULL,'LCN NAME','sa',NOW)",
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestCollation.java misc/build/hsqldb/src/org/hsqldb/test/TestCollation.java
+*** misc/hsqldb/src/org/hsqldb/test/TestCollation.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestCollation.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 54,60 ****
+          super.isNetwork = false;
+      }
+  
+!     protected void setUp() {
+  
+          super.setUp();
+  
+--- 54,60 ----
+          super.isNetwork = false;
+      }
+  
+!     public void setUp() {
+  
+          super.setUp();
+  
+***************
+*** 68,74 ****
+          localeIterator = collation.getLocalesIterator();
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              statement = connection.createStatement();
+--- 68,74 ----
+          localeIterator = collation.getLocalesIterator();
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              statement = connection.createStatement();
+***************
+*** 192,198 ****
+      /**
+       * returns an SQL statement to set the database collation
+       */
+!     protected final String getSetCollationStmt(String collationName) {
+  
+          final String setCollationStmtPre  = "SET DATABASE COLLATION \"";
+          final String setCollationStmtPost = "\"";
+--- 192,198 ----
+      /**
+       * returns an SQL statement to set the database collation
+       */
+!     public final String getSetCollationStmt(String collationName) {
+  
+          final String setCollationStmtPre  = "SET DATABASE COLLATION \"";
+          final String setCollationStmtPost = "\"";
+***************
+*** 203,209 ****
+      /**
+       * checks sorting a table with according to a given collation
+       */
+!     protected String checkSorting(String collationName) {
+  
+          String prepareStmt =
+              "DROP TABLE WORDLIST IF EXISTS;"
+--- 203,209 ----
+      /**
+       * checks sorting a table with according to a given collation
+       */
+!     public String checkSorting(String collationName) {
+  
+          String prepareStmt =
+              "DROP TABLE WORDLIST IF EXISTS;"
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestDataStructures.java misc/build/hsqldb/src/org/hsqldb/test/TestDataStructures.java
+*** misc/hsqldb/src/org/hsqldb/test/TestDataStructures.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestDataStructures.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 51,69 ****
+   */
+  public class TestDataStructures extends TestCase {
+  
+!     private static final int NUMBER_OF_TEST_RUNS          = 100000;
+!     private static final int NUMBER_OF_ITERATIONS_PER_RUN = 80;
+!     private Random           randomGenerator;
+  
+      //Commands
+!     private static final int ADD        = 1;
+!     private static final int ADD_AT     = 2;
+!     private static final int GET        = 3;
+!     private static final int REMOVE     = 4;
+!     private static final int SET        = 5;
+!     private static final int OPTIMIZE   = 6;
+!     private static final int REMOVE_ALL = 7;
+!     private Vector           listCommandsCalled;
+  
+      /** Creates a new instance of TestDataStructures */
+      public TestDataStructures(String s) {
+--- 51,69 ----
+   */
+  public class TestDataStructures extends TestCase {
+  
+!     public static final int NUMBER_OF_TEST_RUNS          = 100000;
+!     public static final int NUMBER_OF_ITERATIONS_PER_RUN = 80;
+!     public Random           randomGenerator;
+  
+      //Commands
+!     public static final int ADD        = 1;
+!     public static final int ADD_AT     = 2;
+!     public static final int GET        = 3;
+!     public static final int REMOVE     = 4;
+!     public static final int SET        = 5;
+!     public static final int OPTIMIZE   = 6;
+!     public static final int REMOVE_ALL = 7;
+!     public Vector           listCommandsCalled;
+  
+      /** Creates a new instance of TestDataStructures */
+      public TestDataStructures(String s) {
+***************
+*** 323,329 ****
+      }
+  
+      /** Returns whether three objects are equal */
+!     private boolean objectEquals(Object lObject, Object aObject,
+                                   Object vObject) {
+  
+          if (lObject == null && aObject == null && vObject == null) {
+--- 323,329 ----
+      }
+  
+      /** Returns whether three objects are equal */
+!     public boolean objectEquals(Object lObject, Object aObject,
+                                   Object vObject) {
+  
+          if (lObject == null && aObject == null && vObject == null) {
+***************
+*** 348,354 ****
+      }
+  
+      /** Returns a random integer in the range of the lowBound and highBound */
+!     private int getRandomInt(int lowBound, int highBound) {
+  
+          double random = randomGenerator.nextDouble();
+  
+--- 348,354 ----
+      }
+  
+      /** Returns a random integer in the range of the lowBound and highBound */
+!     public int getRandomInt(int lowBound, int highBound) {
+  
+          double random = randomGenerator.nextDouble();
+  
+***************
+*** 359,371 ****
+       * Returns an Integer object with a value between Integer.MIN_VALUE and
+       * Integer.MAX_VALUE
+       */
+!     private Integer getRandomInteger() {
+          return new Integer(getRandomInt(0, (int) (Integer.MAX_VALUE
+                  / 100.0)));
+      }
+  
+      /** Tells whether the given list contains the same data as the vector */
+!     private boolean equalsVector(HsqlList list, Vector vector) {
+  
+          if (list.size() != vector.size()) {
+              return false;
+--- 359,371 ----
+       * Returns an Integer object with a value between Integer.MIN_VALUE and
+       * Integer.MAX_VALUE
+       */
+!     public Integer getRandomInteger() {
+          return new Integer(getRandomInt(0, (int) (Integer.MAX_VALUE
+                  / 100.0)));
+      }
+  
+      /** Tells whether the given list contains the same data as the vector */
+!     public boolean equalsVector(HsqlList list, Vector vector) {
+  
+          if (list.size() != vector.size()) {
+              return false;
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestDateTime.java misc/build/hsqldb/src/org/hsqldb/test/TestDateTime.java
+*** misc/hsqldb/src/org/hsqldb/test/TestDateTime.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestDateTime.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 51,57 ****
+          super(s);
+      }
+  
+!     protected void setUp() {
+  
+          super.setUp();
+  
+--- 51,57 ----
+          super(s);
+      }
+  
+!     public void setUp() {
+  
+          super.setUp();
+  
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestGroupByHaving.java misc/build/hsqldb/src/org/hsqldb/test/TestGroupByHaving.java
+*** misc/hsqldb/src/org/hsqldb/test/TestGroupByHaving.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestGroupByHaving.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 54,69 ****
+      //------------------------------------------------------------
+      // Class variables
+      //------------------------------------------------------------
+!     private static final String databaseDriver   = "org.hsqldb.jdbcDriver";
+!     private static final String databaseURL      = "jdbc:hsqldb:mem:.";
+!     private static final String databaseUser     = "sa";
+!     private static final String databasePassword = "";
+  
+      //------------------------------------------------------------
+      // Instance variables
+      //------------------------------------------------------------
+!     private Connection conn;
+!     private Statement  stmt;
+  
+      //------------------------------------------------------------
+      // Constructors
+--- 54,69 ----
+      //------------------------------------------------------------
+      // Class variables
+      //------------------------------------------------------------
+!     public static final String databaseDriver   = "org.hsqldb.jdbcDriver";
+!     public static final String databaseURL      = "jdbc:hsqldb:mem:.";
+!     public static final String databaseUser     = "sa";
+!     public static final String databasePassword = "";
+  
+      //------------------------------------------------------------
+      // Instance variables
+      //------------------------------------------------------------
+!     public Connection conn;
+!     public Statement  stmt;
+  
+      //------------------------------------------------------------
+      // Constructors
+***************
+*** 79,90 ****
+      //------------------------------------------------------------
+      // Class methods
+      //------------------------------------------------------------
+!     protected static Connection getJDBCConnection() throws SQLException {
+          return DriverManager.getConnection(databaseURL, databaseUser,
+                                             databasePassword);
+      }
+  
+!     protected void setUp() throws Exception {
+  
+          super.setUp();
+  
+--- 79,90 ----
+      //------------------------------------------------------------
+      // Class methods
+      //------------------------------------------------------------
+!     public static Connection getJDBCConnection() throws SQLException {
+          return DriverManager.getConnection(databaseURL, databaseUser,
+                                             databasePassword);
+      }
+  
+!     public void setUp() throws Exception {
+  
+          super.setUp();
+  
+***************
+*** 127,133 ****
+          addEmployee(23, "Barbara", "Hood", 30000, 2);
+      }
+  
+!     protected void tearDown() throws Exception {
+  
+          super.tearDown();
+  
+--- 127,133 ----
+          addEmployee(23, "Barbara", "Hood", 30000, 2);
+      }
+  
+!     public void tearDown() throws Exception {
+  
+          super.tearDown();
+  
+***************
+*** 152,158 ****
+          }
+      }
+  
+!     private void addEmployee(int id, String firstName, String lastName,
+                               double salary, int superiorId) throws Exception {
+  
+          stmt.execute("insert into employee values(" + id + ", '" + firstName
+--- 152,158 ----
+          }
+      }
+  
+!     public void addEmployee(int id, String firstName, String lastName,
+                               double salary, int superiorId) throws Exception {
+  
+          stmt.execute("insert into employee values(" + id + ", '" + firstName
+***************
+*** 294,300 ****
+      //------------------------------------------------------------
+      // Helper methods
+      //------------------------------------------------------------
+!     private void compareResults(String sql, Object[][] rows,
+                                  int errorCode) throws SQLException {
+  
+          ResultSet rs = null;
+--- 294,300 ----
+      //------------------------------------------------------------
+      // Helper methods
+      //------------------------------------------------------------
+!     public void compareResults(String sql, Object[][] rows,
+                                  int errorCode) throws SQLException {
+  
+          ResultSet rs = null;
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestJDBCSavepoints.java misc/build/hsqldb/src/org/hsqldb/test/TestJDBCSavepoints.java
+*** misc/hsqldb/src/org/hsqldb/test/TestJDBCSavepoints.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestJDBCSavepoints.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 75,81 ****
+          super(name);
+      }
+  
+!     protected void setUp() {
+  
+          user     = "sa";
+          password = "";
+--- 75,81 ----
+          super(name);
+      }
+  
+!     public void setUp() {
+  
+          user     = "sa";
+          password = "";
+***************
+*** 103,109 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              conn1.close();
+--- 103,109 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              conn1.close();
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestMultipleConnections.java misc/build/hsqldb/src/org/hsqldb/test/TestMultipleConnections.java
+*** misc/hsqldb/src/org/hsqldb/test/TestMultipleConnections.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestMultipleConnections.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 85,91 ****
+      /**
+       * create a connection and wait
+       */
+!     protected Connection createObject() {
+  
+          try {
+              Class.forName("org.hsqldb.jdbcDriver");
+--- 85,91 ----
+      /**
+       * create a connection and wait
+       */
+!     public Connection createObject() {
+  
+          try {
+              Class.forName("org.hsqldb.jdbcDriver");
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestPreparedSubQueries.java misc/build/hsqldb/src/org/hsqldb/test/TestPreparedSubQueries.java
+*** misc/hsqldb/src/org/hsqldb/test/TestPreparedSubQueries.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestPreparedSubQueries.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 40,48 ****
+   */
+  class TestPreparedSubQueries {
+  
+!     private Connection con = null;
+  
+!     private class sqlStmt {
+  
+          boolean prepare;
+          boolean update;
+--- 40,48 ----
+   */
+  class TestPreparedSubQueries {
+  
+!     public Connection con = null;
+  
+!     public class sqlStmt {
+  
+          boolean prepare;
+          boolean update;
+***************
+*** 57,63 ****
+      }
+      ;
+  
+!     private sqlStmt[] stmtArray = {
+          new sqlStmt("drop table a if exists", false, false),
+          new sqlStmt("create cached table a (a int identity,b int)", false,
+                      false),
+--- 57,63 ----
+      }
+      ;
+  
+!     public sqlStmt[] stmtArray = {
+          new sqlStmt("drop table a if exists", false, false),
+          new sqlStmt("create cached table a (a int identity,b int)", false,
+                      false),
+***************
+*** 77,83 ****
+              "update a set b=300 where b>(select b from a X where X.a=?)",
+              true, true)
+      };
+!     private Object[][] stmtArgs = {
+          {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { new Integer(2) },
+          { new Integer(2) }
+      };
+--- 77,83 ----
+              "update a set b=300 where b>(select b from a X where X.a=?)",
+              true, true)
+      };
+!     public Object[][] stmtArgs = {
+          {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, { new Integer(2) },
+          { new Integer(2) }
+      };
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestQuotes.java misc/build/hsqldb/src/org/hsqldb/test/TestQuotes.java
+*** misc/hsqldb/src/org/hsqldb/test/TestQuotes.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestQuotes.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 50,63 ****
+   */
+  public class TestQuotes extends TestCase {
+  
+!     private static final String CREATETABLE =
+          "create table quotetest (test varchar)";
+!     private static final String DELETE = "delete from quotetest";
+!     private static final String TESTSTRING =
+          "insert into quotetest (test) values (?)";
+!     private static final String NOQUOTES = "the house of the dog of kevin";
+!     private static final String QUOTES   = "kevin's dog's house";
+!     private static final String RESULT   = "select * from quotetest";
+  
+      public TestQuotes(String testName) {
+          super(testName);
+--- 50,63 ----
+   */
+  public class TestQuotes extends TestCase {
+  
+!     public static final String CREATETABLE =
+          "create table quotetest (test varchar)";
+!     public static final String DELETE = "delete from quotetest";
+!     public static final String TESTSTRING =
+          "insert into quotetest (test) values (?)";
+!     public static final String NOQUOTES = "the house of the dog of kevin";
+!     public static final String QUOTES   = "kevin's dog's house";
+!     public static final String RESULT   = "select * from quotetest";
+  
+      public TestQuotes(String testName) {
+          super(testName);
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestSchemaParse.java misc/build/hsqldb/src/org/hsqldb/test/TestSchemaParse.java
+*** misc/hsqldb/src/org/hsqldb/test/TestSchemaParse.java	2005-10-23 18:26:30.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestSchemaParse.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 42,50 ****
+  
+      Connection                  con = null;
+      Statement                   statement;
+!     private static final String ipref = "INFORMATION_SCHEMA.";
+  
+!     protected void setUp() throws Exception {
+  
+          org.hsqldb.jdbcDriver.class.getName();
+  
+--- 42,50 ----
+  
+      Connection                  con = null;
+      Statement                   statement;
+!     public static final String ipref = "INFORMATION_SCHEMA.";
+  
+!     public void setUp() throws Exception {
+  
+          org.hsqldb.jdbcDriver.class.getName();
+  
+***************
+*** 96,104 ****
+  
+      // Want to permit the SHUTDOWN SQL command in tearDown() to fail iff
+      // the test method run has tested SHUTDOWN.
+!     private boolean shutdownTested = false;
+  
+!     protected void tearDown() throws Exception {
+  
+          // Shut down to destroy all of the DB objects (only works because
+          // it's an in-memory instance.
+--- 96,104 ----
+  
+      // Want to permit the SHUTDOWN SQL command in tearDown() to fail iff
+      // the test method run has tested SHUTDOWN.
+!     public boolean shutdownTested = false;
+  
+!     public void tearDown() throws Exception {
+  
+          // Shut down to destroy all of the DB objects (only works because
+          // it's an in-memory instance.
+***************
+*** 931,941 ****
+      }
+  
+  /** @todo fredt - need to define additional identifiers to use for all cases of expect */
+!     private static final int SQL_ABORT   = -1234;
+!     private static final int SQL_INITIAL = -1233;
+!     private static final int SQL_FAIL    = -1;
+  
+!     private void execSQL(String s, boolean ignoreError) throws SQLException {
+  
+          try {
+              statement.execute(s);
+--- 931,941 ----
+      }
+  
+  /** @todo fredt - need to define additional identifiers to use for all cases of expect */
+!     public static final int SQL_ABORT   = -1234;
+!     public static final int SQL_INITIAL = -1233;
+!     public static final int SQL_FAIL    = -1;
+  
+!     public void execSQL(String s, boolean ignoreError) throws SQLException {
+  
+          try {
+              statement.execute(s);
+***************
+*** 949,955 ****
+          }
+      }
+  
+!     private void execSQL(String m, String s, int expect) {
+  
+          int retval = SQL_INITIAL;
+  
+--- 949,955 ----
+          }
+      }
+  
+!     public void execSQL(String m, String s, int expect) {
+  
+          int retval = SQL_INITIAL;
+  
+***************
+*** 965,975 ****
+      }
+  
+  /** @todo fredt - this method body seems to be incorrect */
+!     private void execSQL(String s, int expect) {
+          execSQL(s, s, expect);
+      }
+  
+!     private int queryRowCount(String query) throws SQLException {
+  
+          int count = 0;
+  
+--- 965,975 ----
+      }
+  
+  /** @todo fredt - this method body seems to be incorrect */
+!     public void execSQL(String s, int expect) {
+          execSQL(s, s, expect);
+      }
+  
+!     public int queryRowCount(String query) throws SQLException {
+  
+          int count = 0;
+  
+***************
+*** 990,996 ****
+          return count;
+      }
+  
+!     private int tableRowCount(String tableName) throws SQLException {
+  
+          String query = "SELECT count(*) FROM " + tableName;
+  
+--- 990,996 ----
+          return count;
+      }
+  
+!     public int tableRowCount(String tableName) throws SQLException {
+  
+          String query = "SELECT count(*) FROM " + tableName;
+  
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestSql.java misc/build/hsqldb/src/org/hsqldb/test/TestSql.java
+*** misc/hsqldb/src/org/hsqldb/test/TestSql.java	2005-10-27 21:45:52.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestSql.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 58,64 ****
+          super(name);
+      }
+  
+!     protected void setUp() {
+  
+          super.setUp();
+  
+--- 58,64 ----
+          super(name);
+      }
+  
+!     public void setUp() {
+  
+          super.setUp();
+  
+***************
+*** 662,668 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              connection.close();
+--- 662,668 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              connection.close();
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestSqlPersistent.java misc/build/hsqldb/src/org/hsqldb/test/TestSqlPersistent.java
+*** misc/hsqldb/src/org/hsqldb/test/TestSqlPersistent.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestSqlPersistent.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 63,69 ****
+          super(name);
+      }
+  
+!     protected void setUp() {
+  
+          user        = "sa";
+          password    = "";
+--- 63,69 ----
+          super(name);
+      }
+  
+!     public void setUp() {
+  
+          user        = "sa";
+          password    = "";
+***************
+*** 426,432 ****
+          }
+      }
+  
+!     protected void tearDown() {
+  
+          try {
+              cConnection.close();
+--- 426,432 ----
+          }
+      }
+  
+!     public void tearDown() {
+  
+          try {
+              cConnection.close();
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestSqlTool.java misc/build/hsqldb/src/org/hsqldb/test/TestSqlTool.java
+*** misc/hsqldb/src/org/hsqldb/test/TestSqlTool.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestSqlTool.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 45,51 ****
+       * Does not have getters/setters.  No purpose would be served by
+       * getters and setters, other than over-engineering.
+       */
+!     private class TestSqlFile {
+  
+          public File   file;
+          public String description;
+--- 45,51 ----
+       * Does not have getters/setters.  No purpose would be served by
+       * getters and setters, other than over-engineering.
+       */
+!     public class TestSqlFile {
+  
+          public File   file;
+          public String description;
+***************
+*** 66,72 ****
+      /**
+       * List of SQL files, with a description of the purpose.
+       */
+!     private class SqlFileList extends ArrayList {
+  
+          /**
+           * Loads a list of SQL files and descriptions for the specified
+--- 66,72 ----
+      /**
+       * List of SQL files, with a description of the purpose.
+       */
+!     public class SqlFileList extends ArrayList {
+  
+          /**
+           * Loads a list of SQL files and descriptions for the specified
+***************
+*** 109,115 ****
+  
+      SqlToolHarness harness = new SqlToolHarness();
+  
+!     private void runTestsInList(String testList) throws Exception {
+  
+          SqlFileList fileList = new SqlFileList(testList);
+          TestSqlFile sqlFile;
+--- 109,115 ----
+  
+      SqlToolHarness harness = new SqlToolHarness();
+  
+!     public void runTestsInList(String testList) throws Exception {
+  
+          SqlFileList fileList = new SqlFileList(testList);
+          TestSqlFile sqlFile;
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestSubselect.java misc/build/hsqldb/src/org/hsqldb/test/TestSubselect.java
+*** misc/hsqldb/src/org/hsqldb/test/TestSubselect.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestSubselect.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 52,67 ****
+      //------------------------------------------------------------
+      // Class variables
+      //------------------------------------------------------------
+!     private static final String databaseDriver = "org.hsqldb.jdbcDriver";
+!     private static final String databaseURL =
+          "jdbc:hsqldb:/hsql/test/subselect";
+!     private static final String databaseUser     = "sa";
+!     private static final String databasePassword = "";
+  
+      //------------------------------------------------------------
+      // Instance variables
+      //------------------------------------------------------------
+!     private Connection jdbcConnection;
+  
+      //------------------------------------------------------------
+      // Constructors
+--- 52,67 ----
+      //------------------------------------------------------------
+      // Class variables
+      //------------------------------------------------------------
+!     public static final String databaseDriver = "org.hsqldb.jdbcDriver";
+!     public static final String databaseURL =
+          "jdbc:hsqldb:/hsql/test/subselect";
+!     public static final String databaseUser     = "sa";
+!     public static final String databasePassword = "";
+  
+      //------------------------------------------------------------
+      // Instance variables
+      //------------------------------------------------------------
+!     public Connection jdbcConnection;
+  
+      //------------------------------------------------------------
+      // Constructors
+***************
+*** 77,88 ****
+      //------------------------------------------------------------
+      // Class methods
+      //------------------------------------------------------------
+!     protected static Connection getJDBCConnection() throws SQLException {
+          return DriverManager.getConnection(databaseURL, databaseUser,
+                                             databasePassword);
+      }
+  
+!     protected void setUp() throws Exception {
+  
+          super.setUp();
+          Class.forName(databaseDriver);
+--- 77,88 ----
+      //------------------------------------------------------------
+      // Class methods
+      //------------------------------------------------------------
+!     public static Connection getJDBCConnection() throws SQLException {
+          return DriverManager.getConnection(databaseURL, databaseUser,
+                                             databasePassword);
+      }
+  
+!     public void setUp() throws Exception {
+  
+          super.setUp();
+          Class.forName(databaseDriver);
+***************
+*** 92,98 ****
+          createDataset();
+      }
+  
+!     protected void tearDown() throws Exception {
+  
+          super.tearDown();
+          jdbcConnection.close();
+--- 92,98 ----
+          createDataset();
+      }
+  
+!     public void tearDown() throws Exception {
+  
+          super.tearDown();
+          jdbcConnection.close();
+***************
+*** 137,143 ****
+      //------------------------------------------------------------
+      // Helper methods
+      //------------------------------------------------------------
+!     private static void compareResults(String sql, String[] expected,
+                                         Connection jdbcConnection)
+                                         throws SQLException {
+  
+--- 137,143 ----
+      //------------------------------------------------------------
+      // Helper methods
+      //------------------------------------------------------------
+!     public static void compareResults(String sql, String[] expected,
+                                         Connection jdbcConnection)
+                                         throws SQLException {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestTimestamp.java misc/build/hsqldb/src/org/hsqldb/test/TestTimestamp.java
+*** misc/hsqldb/src/org/hsqldb/test/TestTimestamp.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestTimestamp.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 57,63 ****
+          super(testName);
+      }
+  
+!     private void initOracle() throws Exception {
+  
+          Class.forName("oracle.jdbc.driver.OracleDriver");
+  
+--- 57,63 ----
+          super(testName);
+      }
+  
+!     public void initOracle() throws Exception {
+  
+          Class.forName("oracle.jdbc.driver.OracleDriver");
+  
+***************
+*** 67,73 ****
+          conn.setAutoCommit(false);
+      }
+  
+!     private void initHypersonic() throws Exception {
+  
+          Class.forName("org.hsqldb.jdbcDriver");
+  
+--- 67,73 ----
+          conn.setAutoCommit(false);
+      }
+  
+!     public void initHypersonic() throws Exception {
+  
+          Class.forName("org.hsqldb.jdbcDriver");
+  
+***************
+*** 102,110 ****
+  //        dropTestTable();
+      }
+  */
+!     private void checkExceptionTableExistsOracle(SQLException e) {}
+  
+!     private void checkExceptionTableExistsHsql(SQLException e) {
+  
+          Assert.assertTrue("Error code of SQLException is wrong",
+                            e.getErrorCode()
+--- 102,110 ----
+  //        dropTestTable();
+      }
+  */
+!     public void checkExceptionTableExistsOracle(SQLException e) {}
+  
+!     public void checkExceptionTableExistsHsql(SQLException e) {
+  
+          Assert.assertTrue("Error code of SQLException is wrong",
+                            e.getErrorCode()
+***************
+*** 151,157 ****
+  //        dropTestTable();
+      }
+  
+!     private void dropAllTables() throws Exception {
+  
+          dropTestTable(nameTable);
+          dropTestTable("\"SITE_LIST_SITE\"");
+--- 151,157 ----
+  //        dropTestTable();
+      }
+  
+!     public void dropAllTables() throws Exception {
+  
+          dropTestTable(nameTable);
+          dropTestTable("\"SITE_LIST_SITE\"");
+***************
+*** 161,169 ****
+          dropTestTable("\"CASH_CURR_VALUE\"");
+      }
+  
+!     private String nameTable = null;
+  
+!     private void doTest() throws Exception {
+  
+          PreparedStatement ps = conn.prepareStatement("select max(T) T1 from "
+              + nameTable + " where ID=?");
+--- 161,169 ----
+          dropTestTable("\"CASH_CURR_VALUE\"");
+      }
+  
+!     public String nameTable = null;
+  
+!     public void doTest() throws Exception {
+  
+          PreparedStatement ps = conn.prepareStatement("select max(T) T1 from "
+              + nameTable + " where ID=?");
+***************
+*** 217,226 ****
+          }
+      }
+  
+!     private static Timestamp testTS =
+          new Timestamp(System.currentTimeMillis());
+  
+!     private void insertTestData() throws Exception {
+  
+  //        conn.createStatement().executeUpdate("INSERT INTO \"SITE_LIST_SITE\" VALUES(23,1,'ru','RU',NULL,'\u041f\u0440\u043e\u0431\u043d\u044b\u0439 \u0441\u0430\u0439\u0442',NULL,0,'''/front_styles.css''',1,NULL,0)");
+  //        conn.createStatement().executeUpdate("INSERT INTO \"SITE_VIRTUAL_HOST\" VALUES(36,23,'test-host')");
+--- 217,226 ----
+          }
+      }
+  
+!     public static Timestamp testTS =
+          new Timestamp(System.currentTimeMillis());
+  
+!     public void insertTestData() throws Exception {
+  
+  //        conn.createStatement().executeUpdate("INSERT INTO \"SITE_LIST_SITE\" VALUES(23,1,'ru','RU',NULL,'\u041f\u0440\u043e\u0431\u043d\u044b\u0439 \u0441\u0430\u0439\u0442',NULL,0,'''/front_styles.css''',1,NULL,0)");
+  //        conn.createStatement().executeUpdate("INSERT INTO \"SITE_VIRTUAL_HOST\" VALUES(36,23,'test-host')");
+***************
+*** 245,251 ****
+          conn.commit();
+      }
+  
+!     private void createTestTable(String sql) throws Exception {
+  
+          Statement ps = conn.createStatement();
+  
+--- 245,251 ----
+          conn.commit();
+      }
+  
+!     public void createTestTable(String sql) throws Exception {
+  
+          Statement ps = conn.createStatement();
+  
+***************
+*** 255,261 ****
+          ps = null;
+      }
+  
+!     private void dropTestTable(String nameTableDrop) throws Exception {
+  
+          String    sql = "drop table " + nameTableDrop;
+          Statement ps  = conn.createStatement();
+--- 255,261 ----
+          ps = null;
+      }
+  
+!     public void dropTestTable(String nameTableDrop) throws Exception {
+  
+          String    sql = "drop table " + nameTableDrop;
+          Statement ps  = conn.createStatement();
+***************
+*** 269,282 ****
+          ps = null;
+      }
+  
+!     private void setTimeZone() {
+  
+          timeZone = TimeZone.getTimeZone("Asia/Irkutsk");
+  
+          TimeZone.setDefault(timeZone);
+      }
+  
+!     private Timestamp getCurrentCurs() throws Exception {
+  
+          long idCurrency = 134;
+          long idSite     = 23;
+--- 269,282 ----
+          ps = null;
+      }
+  
+!     public void setTimeZone() {
+  
+          timeZone = TimeZone.getTimeZone("Asia/Irkutsk");
+  
+          TimeZone.setDefault(timeZone);
+      }
+  
+!     public Timestamp getCurrentCurs() throws Exception {
+  
+          long idCurrency = 134;
+          long idSite     = 23;
+diff -crN misc/hsqldb/src/org/hsqldb/test/TestUtil.java misc/build/hsqldb/src/org/hsqldb/test/TestUtil.java
+*** misc/hsqldb/src/org/hsqldb/test/TestUtil.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/test/TestUtil.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 174,180 ****
+       * SQL for the statement).
+       * @param line line of the script file where this section started
+       */
+!     private static void testSection(Statement stat, HsqlArrayList section,
+                                      int line) {
+  
+          //create an appropriate instance of ParsedSection
+--- 174,180 ----
+       * SQL for the statement).
+       * @param line line of the script file where this section started
+       */
+!     public static void testSection(Statement stat, HsqlArrayList section,
+                                      int line) {
+  
+          //create an appropriate instance of ParsedSection
+***************
+*** 198,204 ****
+       * @param aSection Vector containing the section of script
+       * @return a ParesedSection object
+       */
+!     private static ParsedSection parsedSectionFactory(
+              HsqlArrayList aSection) {
+  
+          //type of the section
+--- 198,204 ----
+       * @param aSection Vector containing the section of script
+       * @return a ParesedSection object
+       */
+!     public static ParsedSection parsedSectionFactory(
+              HsqlArrayList aSection) {
+  
+          //type of the section
+***************
+*** 292,317 ****
+       * Type of this test.
+       * @see isValidCase() for allowed values
+       */
+!     protected char type = ' ';
+  
+      /** error message for this section */
+      String message = null;
+  
+      /** contents of the section as an array of Strings, one for each line in the section. */
+!     protected String[] lines = null;
+  
+      /** number of the last row containing results in sectionLines */
+!     protected int resEndRow = 0;
+  
+      /** SQL query to be submitted to the database. */
+!     protected String sqlString = null;
+  
+      /**
+       * Common constructor functions for this family.
+       * @param aLines Array of the script lines containing the section of script.
+       * database
+       */
+!     protected ParsedSection(String[] aLines) {
+  
+          lines = aLines;
+  
+--- 292,317 ----
+       * Type of this test.
+       * @see isValidCase() for allowed values
+       */
+!     public char type = ' ';
+  
+      /** error message for this section */
+      String message = null;
+  
+      /** contents of the section as an array of Strings, one for each line in the section. */
+!     public String[] lines = null;
+  
+      /** number of the last row containing results in sectionLines */
+!     public int resEndRow = 0;
+  
+      /** SQL query to be submitted to the database. */
+!     public String sqlString = null;
+  
+      /**
+       * Common constructor functions for this family.
+       * @param aLines Array of the script lines containing the section of script.
+       * database
+       */
+!     public ParsedSection(String[] aLines) {
+  
+          lines = aLines;
+  
+***************
+*** 388,401 ****
+       * returns a String representation of the expected result for the test
+       * @return The expected result(s) for the test
+       */
+!     protected abstract String getResultString();
+  
+      /**
+       *  returns the error message for the section
+       *
+       * @return message
+       */
+!     protected String getMessage() {
+          return message;
+      }
+  
+--- 388,401 ----
+       * returns a String representation of the expected result for the test
+       * @return The expected result(s) for the test
+       */
+!     public abstract String getResultString();
+  
+      /**
+       *  returns the error message for the section
+       *
+       * @return message
+       */
+!     public String getMessage() {
+          return message;
+      }
+  
+***************
+*** 403,409 ****
+       * returns the type of this section
+       * @return type of this section
+       */
+!     protected char getType() {
+          return type;
+      }
+  
+--- 403,409 ----
+       * returns the type of this section
+       * @return type of this section
+       */
+!     public char getType() {
+          return type;
+      }
+  
+***************
+*** 411,417 ****
+       * returns the SQL statement for this section
+       * @return SQL statement for this section
+       */
+!     protected String getSql() {
+          return sqlString;
+      }
+  
+--- 411,417 ----
+       * returns the SQL statement for this section
+       * @return SQL statement for this section
+       */
+!     public String getSql() {
+          return sqlString;
+      }
+  
+***************
+*** 420,426 ****
+       * @param aStatement Statement object
+       * @return true if the result(s) are as expected, otherwise false
+       */
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+--- 420,426 ----
+       * @param aStatement Statement object
+       * @return true if the result(s) are as expected, otherwise false
+       */
+!     public boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+***************
+*** 438,444 ****
+       * @param aCode type code to validate.
+       * @return true if the type code is valid, otherwise false.
+       */
+!     protected static boolean isValidCode(char aCode) {
+  
+          /* Allowed values for test codes are:
+           * (note that UPPERCASE codes, while valid are only processed if the
+--- 438,444 ----
+       * @param aCode type code to validate.
+       * @return true if the type code is valid, otherwise false.
+       */
+!     public static boolean isValidCode(char aCode) {
+  
+          /* Allowed values for test codes are:
+           * (note that UPPERCASE codes, while valid are only processed if the
+***************
+*** 471,485 ****
+  /** Represents a ParsedSection for a ResultSet test */
+  class ResultSetParsedSection extends ParsedSection {
+  
+!     private String delim = System.getProperty("TestUtilFieldDelimiter", ",");
+!     private String[] expectedRows = null;
+  
+      /**
+       * constructs a new instance of ResultSetParsedSection, interpreting
+       * the supplied results as one or more lines of delimited field values
+       * @param lines String[]
+       */
+!     protected ResultSetParsedSection(String[] lines) {
+  
+          super(lines);
+  
+--- 471,485 ----
+  /** Represents a ParsedSection for a ResultSet test */
+  class ResultSetParsedSection extends ParsedSection {
+  
+!     public String delim = System.getProperty("TestUtilFieldDelimiter", ",");
+!     public String[] expectedRows = null;
+  
+      /**
+       * constructs a new instance of ResultSetParsedSection, interpreting
+       * the supplied results as one or more lines of delimited field values
+       * @param lines String[]
+       */
+!     public ResultSetParsedSection(String[] lines) {
+  
+          super(lines);
+  
+***************
+*** 495,501 ****
+          }
+      }
+  
+!     protected String getResultString() {
+  
+          StringBuffer printVal = new StringBuffer();
+  
+--- 495,501 ----
+          }
+      }
+  
+!     public String getResultString() {
+  
+          StringBuffer printVal = new StringBuffer();
+  
+***************
+*** 506,512 ****
+          return printVal.toString();
+      }
+  
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+              try {
+--- 506,512 ----
+          return printVal.toString();
+      }
+  
+!     public boolean test(Statement aStatement) {
+  
+          try {
+              try {
+***************
+*** 606,612 ****
+          return true;
+      }
+  
+!     private String[] getExpectedRows() {
+          return expectedRows;
+      }
+  }
+--- 606,612 ----
+          return true;
+      }
+  
+!     public String[] getExpectedRows() {
+          return expectedRows;
+      }
+  }
+***************
+*** 617,623 ****
+      //expected update count
+      int countWeWant;
+  
+!     protected UpdateParsedSection(String[] lines) {
+  
+          super(lines);
+  
+--- 617,623 ----
+      //expected update count
+      int countWeWant;
+  
+!     public UpdateParsedSection(String[] lines) {
+  
+          super(lines);
+  
+***************
+*** 625,639 ****
+          countWeWant = Integer.parseInt(lines[0]);
+      }
+  
+!     protected String getResultString() {
+          return Integer.toString(getCountWeWant());
+      }
+  
+!     private int getCountWeWant() {
+          return countWeWant;
+      }
+  
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+              try {
+--- 625,639 ----
+          countWeWant = Integer.parseInt(lines[0]);
+      }
+  
+!     public String getResultString() {
+          return Integer.toString(getCountWeWant());
+      }
+  
+!     public int getCountWeWant() {
+          return countWeWant;
+      }
+  
+!     public boolean test(Statement aStatement) {
+  
+          try {
+              try {
+***************
+*** 666,683 ****
+  /** Represents a ParsedSection for silent execution */
+  class SilentParsedSection extends ParsedSection {
+  
+!     protected SilentParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = 's';
+      }
+  
+!     protected String getResultString() {
+          return null;
+      }
+  
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+--- 666,683 ----
+  /** Represents a ParsedSection for silent execution */
+  class SilentParsedSection extends ParsedSection {
+  
+!     public SilentParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = 's';
+      }
+  
+!     public String getResultString() {
+          return null;
+      }
+  
+!     public boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+***************
+*** 691,699 ****
+  class CountParsedSection extends ParsedSection {
+  
+      //expected row count
+!     private int countWeWant;
+  
+!     protected CountParsedSection(String[] lines) {
+  
+          super(lines);
+  
+--- 691,699 ----
+  class CountParsedSection extends ParsedSection {
+  
+      //expected row count
+!     public int countWeWant;
+  
+!     public CountParsedSection(String[] lines) {
+  
+          super(lines);
+  
+***************
+*** 701,715 ****
+          countWeWant = Integer.parseInt(lines[0]);
+      }
+  
+!     protected String getResultString() {
+          return Integer.toString(getCountWeWant());
+      }
+  
+!     private int getCountWeWant() {
+          return countWeWant;
+      }
+  
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+  
+--- 701,715 ----
+          countWeWant = Integer.parseInt(lines[0]);
+      }
+  
+!     public String getResultString() {
+          return Integer.toString(getCountWeWant());
+      }
+  
+!     public int getCountWeWant() {
+          return countWeWant;
+      }
+  
+!     public boolean test(Statement aStatement) {
+  
+          try {
+  
+***************
+*** 760,777 ****
+  /** Represents a ParsedSection for an Exception test */
+  class ExceptionParsedSection extends ParsedSection {
+  
+!     protected ExceptionParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = 'e';
+      }
+  
+!     protected String getResultString() {
+          return "SQLException";
+      }
+  
+!     protected boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+--- 760,777 ----
+  /** Represents a ParsedSection for an Exception test */
+  class ExceptionParsedSection extends ParsedSection {
+  
+!     public ExceptionParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = 'e';
+      }
+  
+!     public String getResultString() {
+          return "SQLException";
+      }
+  
+!     public boolean test(Statement aStatement) {
+  
+          try {
+              aStatement.execute(getSql());
+***************
+*** 790,803 ****
+  /** Represents a ParsedSection for a section with blank type */
+  class BlankParsedSection extends ParsedSection {
+  
+!     protected BlankParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = ' ';
+      }
+  
+!     protected String getResultString() {
+          return "No result specified for this section";
+      }
+  }
+--- 790,803 ----
+  /** Represents a ParsedSection for a section with blank type */
+  class BlankParsedSection extends ParsedSection {
+  
+!     public BlankParsedSection(String[] lines) {
+  
+          super(lines);
+  
+          type = ' ';
+      }
+  
+!     public String getResultString() {
+          return "No result specified for this section";
+      }
+  }
+***************
+*** 805,818 ****
+  /** Represents a ParsedSection that is to be ignored */
+  class IgnoreParsedSection extends ParsedSection {
+  
+!     protected IgnoreParsedSection(String[] lines, char aType) {
+  
+          super(lines);
+  
+          type = aType;
+      }
+  
+!     protected String getResultString() {
+          return "This section, of type '" + getType() + "' was ignored";
+      }
+  }
+--- 805,818 ----
+  /** Represents a ParsedSection that is to be ignored */
+  class IgnoreParsedSection extends ParsedSection {
+  
+!     public IgnoreParsedSection(String[] lines, char aType) {
+  
+          super(lines);
+  
+          type = aType;
+      }
+  
+!     public String getResultString() {
+          return "This section, of type '" + getType() + "' was ignored";
+      }
+  }
+diff -crN misc/hsqldb/src/org/hsqldb/TextTable.java misc/build/hsqldb/src/org/hsqldb/TextTable.java
+*** misc/hsqldb/src/org/hsqldb/TextTable.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/TextTable.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 48,55 ****
+   */
+  class TextTable extends org.hsqldb.Table {
+  
+!     private String  dataSource = "";
+!     private boolean isReversed = false;
+  
+      /**
+       *  Constructs a new TextTable from the given arguments.
+--- 48,55 ----
+   */
+  class TextTable extends org.hsqldb.Table {
+  
+!     public String  dataSource = "";
+!     public boolean isReversed = false;
+  
+      /**
+       *  Constructs a new TextTable from the given arguments.
+***************
+*** 72,78 ****
+       *
+       * Better clarification of the role of the methods is needed.
+       */
+!     private void openCache(String dataSourceNew, boolean isReversedNew,
+                             boolean isReadOnlyNew) throws HsqlException {
+  
+          if (dataSourceNew == null) {
+--- 72,78 ----
+       *
+       * Better clarification of the role of the methods is needed.
+       */
+!     public void openCache(String dataSourceNew, boolean isReversedNew,
+                             boolean isReadOnlyNew) throws HsqlException {
+  
+          if (dataSourceNew == null) {
+***************
+*** 149,155 ****
+       * High level command to assign a data source to the table definition.
+       * Reassigns only if the data source or direction has changed.
+       */
+!     protected void setDataSource(Session s, String dataSourceNew,
+                                   boolean isReversedNew,
+                                   boolean newFile) throws HsqlException {
+  
+--- 149,155 ----
+       * High level command to assign a data source to the table definition.
+       * Reassigns only if the data source or direction has changed.
+       */
+!     public void setDataSource(Session s, String dataSourceNew,
+                                   boolean isReversedNew,
+                                   boolean newFile) throws HsqlException {
+  
+***************
+*** 176,186 ****
+          }
+      }
+  
+!     protected String getDataSource() {
+          return dataSource;
+      }
+  
+!     protected boolean isDescDataSource() {
+          return isReversed;
+      }
+  
+--- 176,186 ----
+          }
+      }
+  
+!     public String getDataSource() {
+          return dataSource;
+      }
+  
+!     public boolean isDescDataSource() {
+          return isReversed;
+      }
+  
+***************
+*** 235,241 ****
+          return false;
+      }
+  
+!     protected Table duplicate() throws HsqlException {
+          return new TextTable(database, tableName, getTableType());
+      }
+  
+--- 235,241 ----
+          return false;
+      }
+  
+!     public Table duplicate() throws HsqlException {
+          return new TextTable(database, tableName, getTableType());
+      }
+  
+diff -crN misc/hsqldb/src/org/hsqldb/Tokenizer.java misc/build/hsqldb/src/org/hsqldb/Tokenizer.java
+*** misc/hsqldb/src/org/hsqldb/Tokenizer.java	2005-11-04 21:20:40.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Tokenizer.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 98,141 ****
+   */
+  public class Tokenizer {
+  
+!     private static final int NO_TYPE   = 0,
+!                              NAME      = 1,
+!                              LONG_NAME = 2,
+!                              SPECIAL   = 3,
+!                              NUMBER    = 4,
+!                              FLOAT     = 5,
+!                              STRING    = 6,
+!                              LONG      = 7,
+!                              DECIMAL   = 8,
+!                              BOOLEAN   = 9,
+!                              DATE      = 10,
+!                              TIME      = 11,
+!                              TIMESTAMP = 12,
+!                              NULL      = 13;
+  
+      // used only internally
+!     private static final int QUOTED_IDENTIFIER = 14,
+!                              REMARK_LINE       = 15,
+!                              REMARK            = 16;
+!     private String           sCommand;
+!     private int              iLength;
+!     private int              iIndex;
+!     private int              tokenIndex;
+!     private int              nextTokenIndex;
+!     private int              beginIndex;
+!     private int              iType;
+!     private String           sToken;
+!     private String           sLongNameFirst = null;
+!     private int              typeLongNameFirst;
+  
+      // getToken() will clear LongNameFirst unless retainFirst is set.
+!     private boolean retainFirst = false;
+  
+! //    private String           sLongNameLast;
+      // WAIT.  Don't do anything before popping another Token (because the
+      // state variables aren't set properly due to a call of wait()).
+!     private boolean bWait;
+!     private boolean lastTokenQuotedID;
+  
+      // literals that are values
+      static IntValueHashMap valueTokens;
+--- 98,142 ----
+   */
+  public class Tokenizer {
+  
+!     public static final int NO_TYPE     = 0,
+!                              NAME        = 1,
+!                              LONG_NAME   = 2,
+!                              SPECIAL     = 3,
+!                              NUMBER      = 4,
+!                              FLOAT       = 5,
+!                              STRING      = 6,
+!                              LONG        = 7,
+!                              DECIMAL     = 8,
+!                              BOOLEAN     = 9,
+!                              DATE        = 10,
+!                              TIME        = 11,
+!                              TIMESTAMP   = 12,
+!                              NULL        = 13,
+!                              NAMED_PARAM = 14;
+  
+      // used only internally
+!     public static final int QUOTED_IDENTIFIER = 15,
+!                              REMARK_LINE       = 16,
+!                              REMARK            = 17;
+!     public String           sCommand;
+!     public int              iLength;
+!     public int              iIndex;
+!     public int              tokenIndex;
+!     public int              nextTokenIndex;
+!     public int              beginIndex;
+!     public int              iType;
+!     public String           sToken;
+!     public String           sLongNameFirst = null;
+!     public int              typeLongNameFirst;
+  
+      // getToken() will clear LongNameFirst unless retainFirst is set.
+!     public boolean retainFirst = false;
+  
+! //    public String           sLongNameLast;
+      // WAIT.  Don't do anything before popping another Token (because the
+      // state variables aren't set properly due to a call of wait()).
+!     public boolean bWait;
+!     public boolean lastTokenQuotedID;
+  
+      // literals that are values
+      static IntValueHashMap valueTokens;
+***************
+*** 342,347 ****
+--- 343,359 ----
+          return !Token.isKeyword(sToken);
+      }
+  
++     /** checks whether the previously obtained token was a (named) parameter
++      *
++      * @return true if the previously obtained token was a (named) parameter
++      */
++     boolean wasParameter() throws HsqlException {
++ 
++         Trace.doAssert(!bWait, "Querying state when in Wait mode");
++ 
++         return ( iType == NAMED_PARAM );
++     }
++ 
+      /**
+       * Name means all quoted and unquoted identifiers plus any word not in the
+       * hKeyword list.
+***************
+*** 386,400 ****
+  
+      boolean wasSimpleToken() throws HsqlException {
+          return iType != QUOTED_IDENTIFIER && iType != LONG_NAME
+!                && iType != STRING;
+      }
+  
+      String getSimpleToken() throws HsqlException {
+  
+          getToken();
+  
+!         if (iType == QUOTED_IDENTIFIER || iType == LONG_NAME
+!                 || iType == STRING) {
+              String token = iType == LONG_NAME ? sLongNameFirst
+                                                : sToken;
+  
+--- 398,411 ----
+  
+      boolean wasSimpleToken() throws HsqlException {
+          return iType != QUOTED_IDENTIFIER && iType != LONG_NAME
+!                && iType != STRING && iType != NAMED_PARAM;
+      }
+  
+      String getSimpleToken() throws HsqlException {
+  
+          getToken();
+  
+!         if (!wasSimpleToken()) {
+              String token = iType == LONG_NAME ? sLongNameFirst
+                                                : sToken;
+  
+***************
+*** 485,491 ****
+  
+          getToken();
+  
+!         if (sToken.equals(Token.T_MINUS)) {
+              minus = true;
+  
+              getToken();
+--- 496,502 ----
+  
+          getToken();
+  
+!         if (sToken.equals("-")) {
+              minus = true;
+  
+              getToken();
+***************
+*** 717,723 ****
+       *
+       * @throws HsqlException
+       */
+!     private void getToken() throws HsqlException {
+  
+          if (bWait) {
+              bWait  = false;
+--- 728,734 ----
+       *
+       * @throws HsqlException
+       */
+!     public void getToken() throws HsqlException {
+  
+          if (bWait) {
+              bWait  = false;
+***************
+*** 835,840 ****
+--- 846,861 ----
+  
+                      return;
+  
++                 case ':' :
++                     Trace.check(++iIndex < iLength, Trace.UNEXPECTED_END_OF_COMMAND);
++ 
++                     c = sCommand.charAt(iIndex);
++                     Trace.check(Character.isJavaIdentifierStart(c), Trace.INVALID_IDENTIFIER, ":" + c);
++ 
++                     iType = NAMED_PARAM;
++ 
++                     break;
++ 
+                  case '\"' :
+                      lastTokenQuotedID = true;
+                      iType             = QUOTED_IDENTIFIER;
+***************
+*** 916,921 ****
+--- 937,943 ----
+  
+              switch (iType) {
+  
++                 case NAMED_PARAM :
+                  case NAME :
+                      if (Character.isJavaIdentifierPart(c)) {
+                          break;
+***************
+*** 925,930 ****
+--- 947,956 ----
+                      sToken = sCommand.substring(start, iIndex).toUpperCase(
+                          Locale.ENGLISH);
+  
++                     // the following only for NAME, not for NAMED_PARAM
++                     if ( iType == NAMED_PARAM )
++                         return;
++ 
+                      if (c == '.') {
+                          typeLongNameFirst = iType;
+                          sLongNameFirst    = sToken;
+***************
+*** 1079,1085 ****
+  // because these strings might end up as part of internal data structures
+  // or table elements.
+  // we may consider using pools to avoid recreating the strings
+!     private String getString(char quoteChar) throws HsqlException {
+  
+          try {
+              int     nextIndex   = iIndex;
+--- 1105,1111 ----
+  // because these strings might end up as part of internal data structures
+  // or table elements.
+  // we may consider using pools to avoid recreating the strings
+!     public String getString(char quoteChar) throws HsqlException {
+  
+          try {
+              int     nextIndex   = iIndex;
+diff -crN misc/hsqldb/src/org/hsqldb/Token.java misc/build/hsqldb/src/org/hsqldb/Token.java
+*** misc/hsqldb/src/org/hsqldb/Token.java	2005-10-23 17:40:20.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Token.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 45,51 ****
+   */
+  public class Token {
+  
+!     private static IntValueHashMap commandSet;
+  
+      //
+      static final String        T_ASTERISK     = "*";
+--- 45,51 ----
+   */
+  public class Token {
+  
+!     public static IntValueHashMap commandSet;
+  
+      //
+      static final String        T_ASTERISK     = "*";
+***************
+*** 716,722 ****
+       *
+       * @return a new map for the database command token set
+       */
+!     private static IntValueHashMap newCommandSet() {
+  
+          IntValueHashMap commandSet;
+  
+--- 716,722 ----
+       *
+       * @return a new map for the database command token set
+       */
+!     public static IntValueHashMap newCommandSet() {
+  
+          IntValueHashMap commandSet;
+  
+***************
+*** 798,804 ****
+          return commandSet.get(token, -1);
+      }
+  
+!     private static HashSet keywords;
+      static IntValueHashMap valueTokens;
+  
+      static {
+--- 798,804 ----
+          return commandSet.get(token, -1);
+      }
+  
+!     public static HashSet keywords;
+      static IntValueHashMap valueTokens;
+  
+      static {
+diff -crN misc/hsqldb/src/org/hsqldb/Trace.java misc/build/hsqldb/src/org/hsqldb/Trace.java
+*** misc/hsqldb/src/org/hsqldb/Trace.java	2005-11-04 20:36:56.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/Trace.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 111,371 ****
+          null);
+  
+      //
+!     public static final int DATABASE_ALREADY_IN_USE                 = 1,
+!                             CONNECTION_IS_CLOSED                    = 2,
+!                             CONNECTION_IS_BROKEN                    = 3,
+!                             DATABASE_IS_SHUTDOWN                    = 4,
+!                             COLUMN_COUNT_DOES_NOT_MATCH             = 5,
+!                             DIVISION_BY_ZERO                        = 6,
+!                             INVALID_ESCAPE                          = 7,
+!                             INTEGRITY_CONSTRAINT_VIOLATION          = 8,
+!                             VIOLATION_OF_UNIQUE_INDEX               = 9,
+!                             TRY_TO_INSERT_NULL                      = 10,
+!                             UNEXPECTED_TOKEN                        = 11,
+!                             UNEXPECTED_END_OF_COMMAND               = 12,
+!                             UNKNOWN_FUNCTION                        = 13,
+!                             NEED_AGGREGATE                          = 14,
+!                             SUM_OF_NON_NUMERIC                      = 15,
+!                             WRONG_DATA_TYPE                         = 16,
+!                             CARDINALITY_VIOLATION_NO_SUBCLASS       = 17,
+!                             SERIALIZATION_FAILURE                   = 18,
+!                             TRANSFER_CORRUPTED                      = 19,
+!                             FUNCTION_NOT_SUPPORTED                  = 20,
+!                             TABLE_ALREADY_EXISTS                    = 21,
+!                             TABLE_NOT_FOUND                         = 22,
+!                             INDEX_ALREADY_EXISTS                    = 23,
+!                             SECOND_PRIMARY_KEY                      = 24,
+!                             DROP_PRIMARY_KEY                        = 25,
+!                             INDEX_NOT_FOUND                         = 26,
+!                             COLUMN_ALREADY_EXISTS                   = 27,
+!                             COLUMN_NOT_FOUND                        = 28,
+!                             FILE_IO_ERROR                           = 29,
+!                             WRONG_DATABASE_FILE_VERSION             = 30,
+!                             DATABASE_IS_READONLY                    = 31,
+!                             DATA_IS_READONLY                        = 32,
+!                             ACCESS_IS_DENIED                        = 33,
+!                             INPUTSTREAM_ERROR                       = 34,
+!                             NO_DATA_IS_AVAILABLE                    = 35,
+!                             USER_ALREADY_EXISTS                     = 36,
+!                             USER_NOT_FOUND                          = 37,
+!                             ASSERT_FAILED                           = 38,
+!                             EXTERNAL_STOP                           = 39,
+!                             GENERAL_ERROR                           = 40,
+!                             WRONG_OUT_PARAMETER                     = 41,
+!                             FUNCTION_NOT_FOUND                      = 42,
+!                             TRIGGER_NOT_FOUND                       = 43,
+!                             SAVEPOINT_NOT_FOUND                     = 44,
+!                             LABEL_REQUIRED                          = 45,
+!                             WRONG_DEFAULT_CLAUSE                    = 46,
+!                             FOREIGN_KEY_NOT_ALLOWED                 = 47,
+!                             UNKNOWN_DATA_SOURCE                     = 48,
+!                             BAD_INDEX_CONSTRAINT_NAME               = 49,
+!                             DROP_FK_INDEX                           = 50,
+!                             RESULTSET_FORWARD_ONLY                  = 51,
+!                             VIEW_ALREADY_EXISTS                     = 52,
+!                             VIEW_NOT_FOUND                          = 53,
+!                             NOT_USED_54                             = 54,
+!                             NOT_A_TABLE                             = 55,
+!                             SYSTEM_INDEX                            = 56,
+!                             COLUMN_TYPE_MISMATCH                    = 57,
+!                             BAD_ADD_COLUMN_DEFINITION               = 58,
+!                             DROP_SYSTEM_CONSTRAINT                  = 59,
+!                             CONSTRAINT_ALREADY_EXISTS               = 60,
+!                             CONSTRAINT_NOT_FOUND                    = 61,
+!                             INVALID_JDBC_ARGUMENT                   = 62,
+!                             DATABASE_IS_MEMORY_ONLY                 = 63,
+!                             OUTER_JOIN_CONDITION                    = 64,
+!                             NUMERIC_VALUE_OUT_OF_RANGE              = 65,
+!                             MISSING_SOFTWARE_MODULE                 = 66,
+!                             NOT_IN_AGGREGATE_OR_GROUP_BY            = 67,
+!                             INVALID_GROUP_BY                        = 68,
+!                             INVALID_HAVING                          = 69,
+!                             INVALID_ORDER_BY                        = 70,
+!                             INVALID_ORDER_BY_IN_DISTINCT_SELECT     = 71,
+!                             OUT_OF_MEMORY                           = 72,
+!                             OPERATION_NOT_SUPPORTED                 = 73,
+!                             INVALID_IDENTIFIER                      = 74,
+!                             TEXT_TABLE_SOURCE                       = 75,
+!                             TEXT_FILE                               = 76,
+!                             NOT_USED_77                             = 77,
+!                             ERROR_IN_SCRIPT_FILE                    = 78,
+!                             NULL_IN_VALUE_LIST                      = 79,
+!                             SOCKET_ERROR                            = 80,
+!                             INVALID_CHARACTER_ENCODING              = 81,
+!                             NOT_USED_82                             = 82,
+!                             NOT_USED_83                             = 83,
+!                             NOT_USED_84                             = 84,
+!                             UNEXPECTED_EXCEPTION                    = 85,
+!                             NOT_USED_86                             = 86,
+!                             NOT_USED_87                             = 87,
+!                             NOT_USED_88                             = 88,
+!                             NOT_USED_89                             = 89,
+!                             NOT_USED_90                             = 90,
+!                             NOT_USED_91                             = 91,
+!                             NOT_USED_92                             = 92,
+!                             NOT_USED_93                             = 93,
+!                             DATABASE_NOT_EXISTS                     = 94,
+!                             INVALID_CONVERSION                      = 95,
+!                             ERROR_IN_BINARY_SCRIPT_1                = 96,
+!                             ERROR_IN_BINARY_SCRIPT_2                = 97,
+!                             GENERAL_IO_ERROR                        = 98,
+!                             EXPRESSION_NOT_SUPPORTED                = 99,
+!                             Constraint_violation                    = 100,
+!                             Database_dropTable                      = 101,
+!                             ERROR_IN_CONSTRAINT_COLUMN_LIST         = 102,
+!                             TABLE_HAS_NO_PRIMARY_KEY                = 103,
+!                             VIOLATION_OF_UNIQUE_CONSTRAINT          = 104,
+!                             NO_DEFAULT_VALUE_FOR_COLUMN             = 105,
+!                             NULL_VALUE_AS_BOOLEAN                   = 106,
+!                             DatabaseManager_getDatabase             = 107,
+!                             NOT_USED_108                            = 108,
+!                             NOT_USED_109                            = 109,
+!                             NOT_USED_110                            = 110,
+!                             NOT_USED_111                            = 111,
+!                             NOT_USED_112                            = 112,
+!                             DatabaseScriptReader_readDDL            = 113,
+!                             DatabaseScriptReader_readExistingData   = 114,
+!                             Message_Pair                            = 115,
+!                             LOAD_SAVE_PROPERTIES                    = 116,
+!                             INVALID_TRANSACTION_STATE_NO_SUBCLASS   = 117,
+!                             JDBC_INVALID_BRI_SCOPE                  = 118,
+!                             JDBC_NO_RESULT_SET_METADATA             = 119,
+!                             JDBC_NO_RESULT_SET                      = 120,
+!                             MISSING_CLOSEBRACKET                    = 121,
+!                             ITSNS_OVERWRITE                         = 122,
+!                             COLUMN_IS_IN_INDEX                      = 123,
+!                             STRING_DATA_TRUNCATION                  = 124,
+!                             QUOTED_IDENTIFIER_REQUIRED              = 125,
+!                             STATEMENT_IS_CLOSED                     = 126,
+!                             DatabaseRowInput_skipBytes              = 127,
+!                             DatabaseRowInput_readLine               = 128,
+!                             DATA_FILE_ERROR                         = 129,
+!                             NOT_USED_130                            = 130,
+!                             HsqlDateTime_null_string                = 131,
+!                             NOT_USED_132                            = 132,
+!                             HsqlDateTime_null_date                  = 133,
+!                             NOT_USED_134                            = 134,
+!                             HsqlProperties_load                     = 135,
+!                             HsqlSocketFactorySecure_verify          = 136,
+!                             HsqlSocketFactorySecure_verify2         = 137,
+!                             jdbcConnection_nativeSQL                = 138,
+!                             HsqlSocketFactorySecure_verify3         = 139,
+!                             NOT_USED_140                            = 140,
+!                             NOT_USED_141                            = 141,
+!                             jdbcStatement_executeUpdate             = 142,
+!                             LockFile_checkHeartbeat                 = 143,
+!                             LockFile_checkHeartbeat2                = 144,
+!                             TEXT_STRING_HAS_NEWLINE                 = 145,
+!                             Result_Result                           = 146,
+!                             SERVER_NO_DATABASE                      = 147,
+!                             Server_openServerSocket                 = 148,
+!                             Server_openServerSocket2                = 149,
+!                             TEXT_TABLE_HEADER                       = 150,
+!                             NOT_USED_151                            = 151,
+!                             TextDatabaseRowOutput_writeIntData      = 152,
+!                             INVALID_LIMIT                           = 153,
+!                             JDBC_STATEMENT_NOT_ROW_COUNT            = 154,
+!                             JDBC_STATEMENT_NOT_RESULTSET            = 155,
+!                             AMBIGUOUS_COLUMN_REFERENCE              = 156,
+!                             CHECK_CONSTRAINT_VIOLATION              = 157,
+!                             JDBC_RESULTSET_IS_CLOSED                = 158,
+!                             SINGLE_COLUMN_EXPECTED                  = 159,
+!                             TOKEN_REQUIRED                          = 160,
+!                             NOT_USED_161                            = 161,
+!                             NOT_USED_162                            = 162,
+!                             ORDER_LIMIT_REQUIRED                    = 163,
+!                             TRIGGER_ALREADY_EXISTS                  = 164,
+!                             ASSERT_DIRECT_EXEC_WITH_PARAM           = 165,
+!                             NOT_USED_166                            = 166,
+!                             Expression_compareValues                = 167,
+!                             INVALID_LIMIT_EXPRESSION                = 168,
+!                             INVALID_TOP_EXPRESSION                  = 169,
+!                             SQL_CONSTRAINT_REQUIRED                 = 170,
+!                             TableWorks_dropConstraint               = 171,
+!                             TEXT_TABLE_SOURCE_FILENAME              = 172,
+!                             TEXT_TABLE_SOURCE_VALUE_MISSING         = 173,
+!                             TEXT_TABLE_SOURCE_SEPARATOR             = 174,
+!                             UNSUPPORTED_PARAM_CLASS                 = 175,
+!                             JDBC_NULL_STREAM                        = 176,
+!                             INTEGRITY_CONSTRAINT_VIOLATION_NOPARENT = 177,
+!                             NOT_USED_178                            = 178,
+!                             NOT_USED_179                            = 179,
+!                             QuotedTextDatabaseRowInput_getField     = 180,
+!                             QuotedTextDatabaseRowInput_getField2    = 181,
+!                             TextDatabaseRowInput_getField           = 182,
+!                             TextDatabaseRowInput_getField2          = 183,
+!                             TextDatabaseRowInput_getField3          = 184,
+!                             Parser_ambiguous_between1               = 185,
+!                             SEQUENCE_REFERENCED_BY_VIEW             = 186,
+!                             NOT_USED_187                            = 187,
+!                             TextCache_openning_file_error           = 188,
+!                             TextCache_closing_file_error            = 189,
+!                             TextCache_purging_file_error            = 190,
+!                             SEQUENCE_NOT_FOUND                      = 191,
+!                             SEQUENCE_ALREADY_EXISTS                 = 192,
+!                             TABLE_REFERENCED_CONSTRAINT             = 193,
+!                             TABLE_REFERENCED_VIEW                   = 194,
+!                             NOT_USED_195                            = 195,
+!                             TEXT_SOURCE_EXISTS                      = 196,
+!                             COLUMN_IS_REFERENCED                    = 197,
+!                             FUNCTION_CALL_ERROR                     = 198,
+!                             TRIGGERED_DATA_CHANGE                   = 199,
+!                             INVALID_FUNCTION_ARGUMENT               = 200,
+!                             INTERNAL_UNSUPPORTED_OPERATION          = 201,
+!                             NOT_USED_202                            = 202,
+!                             INVALID_PREPARED_STATEMENT              = 203,
+!                             CREATE_TRIGGER_COMMAND_1                = 204,
+!                             TRIGGER_FUNCTION_CLASS_NOT_FOUND        = 205,
+!                             NOT_USED_206                            = 206,
+!                             NOT_USED_207                            = 207,
+!                             INVALID_COLLATION_NAME_NO_SUBCLASS      = 208,
+!                             DataFileCache_makeRow                   = 209,
+!                             DataFileCache_open                      = 210,
+!                             DataFileCache_close                     = 211,
+!                             Expression_resolveTypes1                = 212,
+!                             Expression_resolveTypes2                = 213,
+!                             Expression_resolveTypes3                = 214,
+!                             Expression_resolveTypes4                = 215,
+!                             UNRESOLVED_PARAMETER_TYPE               = 216,
+!                             Expression_resolveTypes6                = 217,
+!                             Expression_resolveTypes7                = 218,
+!                             Expression_resolveTypeForLike           = 219,
+!                             NOT_USED_220                            = 220,
+!                             Expression_resolveTypeForIn2            = 221,
+!                             Session_execute                         = 222,
+!                             NOT_USED_223                            = 223,
+!                             NOT_USED_224                            = 224,
+!                             DATA_FILE_IS_FULL                       = 225,
+!                             THREE_PART_IDENTIFIER                   = 226,
+!                             INVALID_SCHEMA_NAME_NO_SUBCLASS         = 227,
+!                             DEPENDENT_DATABASE_OBJECT_EXISTS        = 228,
+!                             NO_SUCH_ROLE_GRANT                      = 229,
+!                             NO_SUCH_ROLE_REVOKE                     = 230,
+!                             NONMOD_ACCOUNT                          = 231,
+!                             NO_SUCH_GRANTEE                         = 232,
+!                             MISSING_SYSAUTH                         = 233,
+!                             MISSING_GRANTEE                         = 234,
+!                             CHANGE_GRANTEE                          = 235,
+!                             NULL_NAME                               = 236,
+!                             ILLEGAL_ROLE_NAME                       = 237,
+!                             ROLE_ALREADY_EXISTS                     = 238,
+!                             NO_SUCH_ROLE                            = 239,
+!                             MISSING_ROLEMANAGER                     = 240,
+!                             GRANTEE_ALREADY_EXISTS                  = 241,
+!                             MISSING_PUBLIC_GRANTEE                  = 242,
+!                             NONMOD_GRANTEE                          = 243,
+!                             CIRCULAR_GRANT                          = 244,
+!                             ALREADY_HAVE_ROLE                       = 245,
+!                             DONT_HAVE_ROLE                          = 246,
+!                             NOT_USED_247                            = 247,
+!                             RETRIEVE_NEST_ROLE_FAIL                 = 248,
+!                             NO_SUCH_RIGHT                           = 249,
+!                             IN_SCHEMA_DEFINITION                    = 250,
+!                             PRIMARY_KEY_NOT_ALLOWED                 = 251,
+!                             COLUMN_IS_IN_CONSTRAINT                 = 252,
+!                             COLUMN_SIZE_REQUIRED                    = 253,
+!                             INVALID_SIZE_PRECISION                  = 254,
+!                             LAST_ERROR_HANDLE                       = 255;
+  
+      //
+      static String MESSAGE_TAG = "$$";
+--- 111,374 ----
+          null);
+  
+      //
+!     public static final int
+! 
+!     //
+!     DATABASE_ALREADY_IN_USE                 = 1,
+!     CONNECTION_IS_CLOSED                    = 2,
+!     CONNECTION_IS_BROKEN                    = 3,
+!     DATABASE_IS_SHUTDOWN                    = 4,
+!     COLUMN_COUNT_DOES_NOT_MATCH             = 5,
+!     DIVISION_BY_ZERO                        = 6,
+!     INVALID_ESCAPE                          = 7,
+!     INTEGRITY_CONSTRAINT_VIOLATION          = 8,
+!     VIOLATION_OF_UNIQUE_INDEX               = 9,
+!     TRY_TO_INSERT_NULL                      = 10,
+!     UNEXPECTED_TOKEN                        = 11,
+!     UNEXPECTED_END_OF_COMMAND               = 12,
+!     UNKNOWN_FUNCTION                        = 13,
+!     NEED_AGGREGATE                          = 14,
+!     SUM_OF_NON_NUMERIC                      = 15,
+!     WRONG_DATA_TYPE                         = 16,
+!     CARDINALITY_VIOLATION_NO_SUBCLASS       = 17,
+!     SERIALIZATION_FAILURE                   = 18,
+!     TRANSFER_CORRUPTED                      = 19,
+!     FUNCTION_NOT_SUPPORTED                  = 20,
+!     TABLE_ALREADY_EXISTS                    = 21,
+!     TABLE_NOT_FOUND                         = 22,
+!     INDEX_ALREADY_EXISTS                    = 23,
+!     SECOND_PRIMARY_KEY                      = 24,
+!     DROP_PRIMARY_KEY                        = 25,
+!     INDEX_NOT_FOUND                         = 26,
+!     COLUMN_ALREADY_EXISTS                   = 27,
+!     COLUMN_NOT_FOUND                        = 28,
+!     FILE_IO_ERROR                           = 29,
+!     WRONG_DATABASE_FILE_VERSION             = 30,
+!     DATABASE_IS_READONLY                    = 31,
+!     DATA_IS_READONLY                        = 32,
+!     ACCESS_IS_DENIED                        = 33,
+!     INPUTSTREAM_ERROR                       = 34,
+!     NO_DATA_IS_AVAILABLE                    = 35,
+!     USER_ALREADY_EXISTS                     = 36,
+!     USER_NOT_FOUND                          = 37,
+!     ASSERT_FAILED                           = 38,
+!     EXTERNAL_STOP                           = 39,
+!     GENERAL_ERROR                           = 40,
+!     WRONG_OUT_PARAMETER                     = 41,
+!     FUNCTION_NOT_FOUND                      = 42,
+!     TRIGGER_NOT_FOUND                       = 43,
+!     SAVEPOINT_NOT_FOUND                     = 44,
+!     LABEL_REQUIRED                          = 45,
+!     WRONG_DEFAULT_CLAUSE                    = 46,
+!     FOREIGN_KEY_NOT_ALLOWED                 = 47,
+!     UNKNOWN_DATA_SOURCE                     = 48,
+!     BAD_INDEX_CONSTRAINT_NAME               = 49,
+!     DROP_FK_INDEX                           = 50,
+!     RESULTSET_FORWARD_ONLY                  = 51,
+!     VIEW_ALREADY_EXISTS                     = 52,
+!     VIEW_NOT_FOUND                          = 53,
+!     NOT_USED_54                             = 54,
+!     NOT_A_TABLE                             = 55,
+!     SYSTEM_INDEX                            = 56,
+!     COLUMN_TYPE_MISMATCH                    = 57,
+!     BAD_ADD_COLUMN_DEFINITION               = 58,
+!     DROP_SYSTEM_CONSTRAINT                  = 59,
+!     CONSTRAINT_ALREADY_EXISTS               = 60,
+!     CONSTRAINT_NOT_FOUND                    = 61,
+!     INVALID_JDBC_ARGUMENT                   = 62,
+!     DATABASE_IS_MEMORY_ONLY                 = 63,
+!     OUTER_JOIN_CONDITION                    = 64,
+!     NUMERIC_VALUE_OUT_OF_RANGE              = 65,
+!     MISSING_SOFTWARE_MODULE                 = 66,
+!     NOT_IN_AGGREGATE_OR_GROUP_BY            = 67,
+!     INVALID_GROUP_BY                        = 68,
+!     INVALID_HAVING                          = 69,
+!     INVALID_ORDER_BY                        = 70,
+!     INVALID_ORDER_BY_IN_DISTINCT_SELECT     = 71,
+!     OUT_OF_MEMORY                           = 72,
+!     OPERATION_NOT_SUPPORTED                 = 73,
+!     INVALID_IDENTIFIER                      = 74,
+!     TEXT_TABLE_SOURCE                       = 75,
+!     TEXT_FILE                               = 76,
+!     NOT_USED_77                             = 77,
+!     ERROR_IN_SCRIPT_FILE                    = 78,
+!     NULL_IN_VALUE_LIST                      = 79,
+!     SOCKET_ERROR                            = 80,
+!     INVALID_CHARACTER_ENCODING              = 81,
+!     NOT_USED_82                             = 82,
+!     NOT_USED_83                             = 83,
+!     NOT_USED_84                             = 84,
+!     UNEXPECTED_EXCEPTION                    = 85,
+!     NOT_USED_86                             = 86,
+!     NOT_USED_87                             = 87,
+!     NOT_USED_88                             = 88,
+!     NOT_USED_89                             = 89,
+!     NOT_USED_90                             = 90,
+!     NOT_USED_91                             = 91,
+!     NOT_USED_92                             = 92,
+!     NOT_USED_93                             = 93,
+!     DATABASE_NOT_EXISTS                     = 94,
+!     INVALID_CONVERSION                      = 95,
+!     ERROR_IN_BINARY_SCRIPT_1                = 96,
+!     ERROR_IN_BINARY_SCRIPT_2                = 97,
+!     GENERAL_IO_ERROR                        = 98,
+!     EXPRESSION_NOT_SUPPORTED                = 99,
+!     Constraint_violation                    = 100,
+!     Database_dropTable                      = 101,
+!     ERROR_IN_CONSTRAINT_COLUMN_LIST         = 102,
+!     TABLE_HAS_NO_PRIMARY_KEY                = 103,
+!     VIOLATION_OF_UNIQUE_CONSTRAINT          = 104,
+!     NO_DEFAULT_VALUE_FOR_COLUMN             = 105,
+!     NULL_VALUE_AS_BOOLEAN                   = 106,
+!     DatabaseManager_getDatabase             = 107,
+!     NOT_USED_108                            = 108,
+!     NOT_USED_109                            = 109,
+!     NOT_USED_110                            = 110,
+!     NOT_USED_111                            = 111,
+!     NOT_USED_112                            = 112,
+!     DatabaseScriptReader_readDDL            = 113,
+!     DatabaseScriptReader_readExistingData   = 114,
+!     Message_Pair                            = 115,
+!     LOAD_SAVE_PROPERTIES                    = 116,
+!     INVALID_TRANSACTION_STATE_NO_SUBCLASS   = 117,
+!     JDBC_INVALID_BRI_SCOPE                  = 118,
+!     JDBC_NO_RESULT_SET_METADATA             = 119,
+!     JDBC_NO_RESULT_SET                      = 120,
+!     MISSING_CLOSEBRACKET                    = 121,
+!     ITSNS_OVERWRITE                         = 122,
+!     COLUMN_IS_IN_INDEX                      = 123,
+!     STRING_DATA_TRUNCATION                  = 124,
+!     QUOTED_IDENTIFIER_REQUIRED              = 125,
+!     STATEMENT_IS_CLOSED                     = 126,
+!     DatabaseRowInput_skipBytes              = 127,
+!     DatabaseRowInput_readLine               = 128,
+!     DATA_FILE_ERROR                         = 129,
+!     NOT_USED_130                            = 130,
+!     HsqlDateTime_null_string                = 131,
+!     NOT_USED_132                            = 132,
+!     HsqlDateTime_null_date                  = 133,
+!     NOT_USED_134                            = 134,
+!     HsqlProperties_load                     = 135,
+!     HsqlSocketFactorySecure_verify          = 136,
+!     HsqlSocketFactorySecure_verify2         = 137,
+!     jdbcConnection_nativeSQL                = 138,
+!     HsqlSocketFactorySecure_verify3         = 139,
+!     NOT_USED_140                            = 140,
+!     NOT_USED_141                            = 141,
+!     jdbcStatement_executeUpdate             = 142,
+!     LockFile_checkHeartbeat                 = 143,
+!     LockFile_checkHeartbeat2                = 144,
+!     TEXT_STRING_HAS_NEWLINE                 = 145,
+!     Result_Result                           = 146,
+!     SERVER_NO_DATABASE                      = 147,
+!     Server_openServerSocket                 = 148,
+!     Server_openServerSocket2                = 149,
+!     TEXT_TABLE_HEADER                       = 150,
+!     NOT_USED_151                            = 151,
+!     TextDatabaseRowOutput_writeIntData      = 152,
+!     INVALID_LIMIT                           = 153,
+!     JDBC_STATEMENT_NOT_ROW_COUNT            = 154,
+!     JDBC_STATEMENT_NOT_RESULTSET            = 155,
+!     AMBIGUOUS_COLUMN_REFERENCE              = 156,
+!     CHECK_CONSTRAINT_VIOLATION              = 157,
+!     JDBC_RESULTSET_IS_CLOSED                = 158,
+!     SINGLE_COLUMN_EXPECTED                  = 159,
+!     TOKEN_REQUIRED                          = 160,
+!     NOT_USED_161                            = 161,
+!     NOT_USED_162                            = 162,
+!     ORDER_LIMIT_REQUIRED                    = 163,
+!     TRIGGER_ALREADY_EXISTS                  = 164,
+!     ASSERT_DIRECT_EXEC_WITH_PARAM           = 165,
+!     NOT_USED_166                            = 166,
+!     Expression_compareValues                = 167,
+!     INVALID_LIMIT_EXPRESSION                = 168,
+!     INVALID_TOP_EXPRESSION                  = 169,
+!     SQL_CONSTRAINT_REQUIRED                 = 170,
+!     TableWorks_dropConstraint               = 171,
+!     TEXT_TABLE_SOURCE_FILENAME              = 172,
+!     TEXT_TABLE_SOURCE_VALUE_MISSING         = 173,
+!     TEXT_TABLE_SOURCE_SEPARATOR             = 174,
+!     UNSUPPORTED_PARAM_CLASS                 = 175,
+!     JDBC_NULL_STREAM                        = 176,
+!     INTEGRITY_CONSTRAINT_VIOLATION_NOPARENT = 177,
+!     NOT_USED_178                            = 178,
+!     NOT_USED_179                            = 179,
+!     QuotedTextDatabaseRowInput_getField     = 180,
+!     QuotedTextDatabaseRowInput_getField2    = 181,
+!     TextDatabaseRowInput_getField           = 182,
+!     TextDatabaseRowInput_getField2          = 183,
+!     TextDatabaseRowInput_getField3          = 184,
+!     Parser_ambiguous_between1               = 185,
+!     SEQUENCE_REFERENCED_BY_VIEW             = 186,
+!     NOT_USED_187                            = 187,
+!     TextCache_openning_file_error           = 188,
+!     TextCache_closing_file_error            = 189,
+!     TextCache_purging_file_error            = 190,
+!     SEQUENCE_NOT_FOUND                      = 191,
+!     SEQUENCE_ALREADY_EXISTS                 = 192,
+!     TABLE_REFERENCED_CONSTRAINT             = 193,
+!     TABLE_REFERENCED_VIEW                   = 194,
+!     NOT_USED_195                            = 195,
+!     TEXT_SOURCE_EXISTS                      = 196,
+!     COLUMN_IS_REFERENCED                    = 197,
+!     FUNCTION_CALL_ERROR                     = 198,
+!     TRIGGERED_DATA_CHANGE                   = 199,
+!     INVALID_FUNCTION_ARGUMENT               = 200,
+!     INTERNAL_UNSUPPORTED_OPERATION          = 201,
 !     NOT_USED_202                            = 202,
 !     INVALID_PREPARED_STATEMENT              = 203,
 !     CREATE_TRIGGER_COMMAND_1                = 204,
@@ -3000,1130 +20525,4854 @@
 !     INVALID_SIZE_PRECISION                  = 254,
 !     LAST_ERROR_HANDLE                       = 255;
   
-      //
-      static String MESSAGE_TAG = "$$";
+      //
+      static String MESSAGE_TAG = "$$";
+***************
+*** 660,665 ****
+--- 663,685 ----
+      }
+  
+      /**
++      *     Throws exception if condition is false
++      *
++      *     @param condition
++      *     @param code
++      *     @param add
++      *
++      * @throws HsqlException
++      */
++     public static void check(boolean condition, int code,
++                              final Object[] add) throws HsqlException {
++ 
++         if (!condition) {
++             throw error(code, add);
++         }
++     }
++ 
++     /**
+       * Method declaration
+       *
+       *
+***************
+*** 703,709 ****
+      /**
+       * Returns the stack trace for doAssert()
+       */
+!     private static String getStackTrace() {
+  
+          try {
+              Exception e = new Exception();
+--- 723,729 ----
+      /**
+       * Returns the stack trace for doAssert()
+       */
+!     public static String getStackTrace() {
+  
+          try {
+              Exception e = new Exception();
+diff -crN misc/hsqldb/src/org/hsqldb/TransactionManager.java misc/build/hsqldb/src/org/hsqldb/TransactionManager.java
+*** misc/hsqldb/src/org/hsqldb/TransactionManager.java	2005-10-27 21:40:18.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/TransactionManager.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 102,109 ****
+  
+      void commit(Session session) {
+  
+!         Object[] list = session.transactionList.getArray();
+!         int      size = session.transactionList.size();
+  
+          for (int i = 0; i < size; i++) {
+              Transaction tx    = (Transaction) list[i];
+--- 102,109 ----
+  
+      void commit(Session session) {
+  
+!         Object[] list = session.rowActionList.getArray();
+!         int      size = session.rowActionList.size();
+  
+          for (int i = 0; i < size; i++) {
+              Transaction tx    = (Transaction) list[i];
+***************
+*** 113,119 ****
+              rowSessionMap.remove(rowid);
+          }
+  
+!         session.transactionList.clear();
+          session.savepoints.clear();
+      }
+  
+--- 113,119 ----
+              rowSessionMap.remove(rowid);
+          }
+  
+!         session.rowActionList.clear();
+          session.savepoints.clear();
+      }
+  
+***************
+*** 143,155 ****
+  
+      void rollbackTransactions(Session session, int limit, boolean log) {
+  
+!         Object[] list = session.transactionList.getArray();
+!         int      size = session.transactionList.size();
+  
+          for (int i = size - 1; i >= limit; i--) {
+              Transaction tx = (Transaction) list[i];
+  
+!             tx.rollback(session, false);
+          }
+  
+          for (int i = limit; i < size; i++) {
+--- 143,155 ----
+  
+      void rollbackTransactions(Session session, int limit, boolean log) {
+  
+!         Object[] list = session.rowActionList.getArray();
+!         int      size = session.rowActionList.size();
+  
+          for (int i = size - 1; i >= limit; i--) {
+              Transaction tx = (Transaction) list[i];
+  
+!             tx.rollback(session, log);
+          }
+  
+          for (int i = limit; i < size; i++) {
+***************
+*** 159,165 ****
+              rowSessionMap.remove(rowid);
+          }
+  
+!         session.transactionList.setSize(limit);
+      }
+  
+      void addTransaction(Session session, Transaction transaction) {
+--- 159,165 ----
+              rowSessionMap.remove(rowid);
+          }
+  
+!         session.rowActionList.setSize(limit);
+      }
+  
+      void addTransaction(Session session, Transaction transaction) {
+***************
+*** 169,175 ****
+          }
+      }
+  
+!     private long globalActionTimestamp = 0;
+  
+      /**
+       * gets the next timestamp for an action
+--- 169,175 ----
+          }
+      }
+  
+!     public long globalActionTimestamp = 0;
+  
+      /**
+       * gets the next timestamp for an action
+***************
+*** 212,218 ****
+  
+                  if (tIndex[i] < tSize) {
+                      Transaction current =
+!                         (Transaction) sessions[i].transactionList.get(
+                              tIndex[i]);
+  
+                      if (current.SCN < minChangeNo) {
+--- 212,218 ----
+  
+                  if (tIndex[i] < tSize) {
+                      Transaction current =
+!                         (Transaction) sessions[i].rowActionList.get(
+                              tIndex[i]);
+  
+                      if (current.SCN < minChangeNo) {
+***************
+*** 228,235 ****
+                  break;
+              }
+  
+!             HsqlArrayList currentList =
+!                 sessions[sessionIndex].transactionList;
+  
+              for (; tIndex[sessionIndex] < currentList.size(); ) {
+                  Transaction current =
+--- 228,234 ----
+                  break;
+              }
+  
+!             HsqlArrayList currentList = sessions[sessionIndex].rowActionList;
+  
+              for (; tIndex[sessionIndex] < currentList.size(); ) {
+                  Transaction current =
+***************
+*** 264,270 ****
+          lookup.setKeysSearchTarget();
+  
+          for (int i = 0; i < sessions.length; i++) {
+!             HsqlArrayList tlist = sessions[i].transactionList;
+  
+              for (int j = 0, size = tlist.size(); j < size; j++) {
+                  Transaction tx = (Transaction) tlist.get(j);
+--- 263,269 ----
+          lookup.setKeysSearchTarget();
+  
+          for (int i = 0; i < sessions.length; i++) {
+!             HsqlArrayList tlist = sessions[i].rowActionList;
+  
+              for (int j = 0, size = tlist.size(); j < size; j++) {
+                  Transaction tx = (Transaction) tlist.get(j);
+***************
+*** 286,292 ****
+          Session[] sessions = database.sessionManager.getAllSessions();
+  
+          for (int i = 0; i < sessions.length; i++) {
+!             HsqlArrayList tlist = sessions[i].transactionList;
+  
+              for (int j = 0, size = tlist.size(); j < size; j++) {
+                  Transaction tx = (Transaction) tlist.get(j);
+--- 285,291 ----
+          Session[] sessions = database.sessionManager.getAllSessions();
+  
+          for (int i = 0; i < sessions.length; i++) {
+!             HsqlArrayList tlist = sessions[i].rowActionList;
+  
+              for (int j = 0, size = tlist.size(); j < size; j++) {
+                  Transaction tx = (Transaction) tlist.get(j);
+diff -crN misc/hsqldb/src/org/hsqldb/TriggerDef.java misc/build/hsqldb/src/org/hsqldb/TriggerDef.java
+*** misc/hsqldb/src/org/hsqldb/TriggerDef.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/TriggerDef.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 84,100 ****
+          return defaultQueueSize;
+      }
+  
+!     protected static int defaultQueueSize = 1024;
+      Table                table;
+      Trigger              trigger;
+      String               triggerClassName;
+      int                  vectorIndex;               // index into HsqlArrayList[]
+  
+!     //protected boolean busy;               // firing trigger in progress
+!     protected HsqlDeque        pendingQueue;        // row triggers pending
+!     protected int              rowsQueued;          // rows in pendingQueue
+!     protected boolean          valid     = true;    // parsing valid
+!     protected volatile boolean keepGoing = true;
+  
+      /**
+       *  Constructs a new TriggerDef object to represent an HSQLDB trigger
+--- 84,100 ----
+          return defaultQueueSize;
+      }
+  
+!     public static int defaultQueueSize = 1024;
+      Table                table;
+      Trigger              trigger;
+      String               triggerClassName;
+      int                  vectorIndex;               // index into HsqlArrayList[]
+  
+!     //public boolean busy;               // firing trigger in progress
+!     public HsqlDeque        pendingQueue;        // row triggers pending
+!     public int              rowsQueued;          // rows in pendingQueue
+!     public boolean          valid     = true;    // parsing valid
+!     public volatile boolean keepGoing = true;
+  
+      /**
+       *  Constructs a new TriggerDef object to represent an HSQLDB trigger
+diff -crN misc/hsqldb/src/org/hsqldb/types/Binary.java misc/build/hsqldb/src/org/hsqldb/types/Binary.java
+*** misc/hsqldb/src/org/hsqldb/types/Binary.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/types/Binary.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 46,52 ****
+   */
+  public class Binary {
+  
+!     private byte[] data;
+      int            hash;
+  
+      /**
+--- 46,52 ----
+   */
+  public class Binary {
+  
+!     public byte[] data;
+      int            hash;
+  
+      /**
+diff -crN misc/hsqldb/src/org/hsqldb/types/JavaObject.java misc/build/hsqldb/src/org/hsqldb/types/JavaObject.java
+*** misc/hsqldb/src/org/hsqldb/types/JavaObject.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/types/JavaObject.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 65,71 ****
+   */
+  public class JavaObject {
+  
+!     private byte[] data;
+  
+      /**
+       * Constructor used inside the engine when an already serialized
+--- 65,71 ----
+   */
+  public class JavaObject {
+  
+!     public byte[] data;
+  
+      /**
+       * Constructor used inside the engine when an already serialized
+diff -crN misc/hsqldb/src/org/hsqldb/Types.java misc/build/hsqldb/src/org/hsqldb/Types.java
+*** misc/hsqldb/src/org/hsqldb/Types.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/Types.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 461,467 ****
+  //                   Function.java whose number class is
+  //                   narrower than the corresponding internal
+  //                   wrapper
+!     private static org.hsqldb.lib.HashSet illegalParameterClasses;
+  
+      static {
+          typeAliases = new IntValueHashMap(67, 1);
+--- 461,467 ----
+  //                   Function.java whose number class is
+  //                   narrower than the corresponding internal
+  //                   wrapper
+!     public static org.hsqldb.lib.HashSet illegalParameterClasses;
+  
+      static {
+          typeAliases = new IntValueHashMap(67, 1);
+***************
+*** 1073,1079 ****
+      //
+      // 1.) refusing to directly display such columns in graphical query results
+      // 2.) providing other means to retrieve and display such values
+!     private static int MAX_CHAR_OR_VARCHAR_DISPLAY_SIZE() {
+  
+          try {
+              return Integer.getInteger(
+--- 1073,1079 ----
+      //
+      // 1.) refusing to directly display such columns in graphical query results
+      // 2.) providing other means to retrieve and display such values
+!     public static int MAX_CHAR_OR_VARCHAR_DISPLAY_SIZE() {
+  
+          try {
+              return Integer.getInteger(
+diff -crN misc/hsqldb/src/org/hsqldb/User.java misc/build/hsqldb/src/org/hsqldb/User.java
+*** misc/hsqldb/src/org/hsqldb/User.java	2005-10-29 18:30:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/User.java	2006-11-03 20:08:11.000000000 +0100
+***************
+*** 91,112 ****
+  public class User {
+  
+      /** true if this user is the sys user. */
+!     private boolean isSys;
+  
+      /** true if this user is the public user. */
+!     private boolean isPublic;
+  
+      /** user name. */
+!     private String sName;
+  
+      /** password. */
+!     private String sPassword;
+  
+      /** default schema when new Sessions started (defaults to PUBLIC schema) */
+!     private HsqlName initialSchema = null;
+  
+      /** grantee object. */
+!     private Grantee grantee;
+  
+      /**
+       * Constructor
+--- 91,112 ----
+  public class User {
+  
+      /** true if this user is the sys user. */
+!     public boolean isSys;
+  
+      /** true if this user is the public user. */
+!     public boolean isPublic;
+  
+      /** user name. */
+!     public String sName;
+  
+      /** password. */
+!     public String sPassword;
+  
+      /** default schema when new Sessions started (defaults to PUBLIC schema) */
+!     public HsqlName initialSchema = null;
+  
+      /** grantee object. */
+!     public Grantee grantee;
+  
+      /**
+       * Constructor
+diff -crN misc/hsqldb/src/org/hsqldb/UserManager.java misc/build/hsqldb/src/org/hsqldb/UserManager.java
+*** misc/hsqldb/src/org/hsqldb/UserManager.java	2005-10-29 18:30:36.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/UserManager.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 110,117 ****
+       * User object is kept in the list because it's needed by MetaData
+       * routines via "listVisibleUsers(x, true)".
+       */
+!     private HashMappedList userList;
+!     private GranteeManager granteeManager;
+  
+      /**
+       * Construction happens once for each Database object.
+--- 110,117 ----
+       * User object is kept in the list because it's needed by MetaData
+       * routines via "listVisibleUsers(x, true)".
+       */
+!     public HashMappedList userList;
+!     public GranteeManager granteeManager;
+  
+      /**
+       * Construction happens once for each Database object.
+diff -crN misc/hsqldb/src/org/hsqldb/util/CodeSwitcher.java misc/build/hsqldb/src/org/hsqldb/util/CodeSwitcher.java
+*** misc/hsqldb/src/org/hsqldb/util/CodeSwitcher.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/CodeSwitcher.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 109,121 ****
+   */
+  public class CodeSwitcher {
+  
+!     private static final String ls = System.getProperty("line.separator",
+          "\n");
+!     private Vector           vList;
+!     private Vector           vSwitchOn;
+!     private Vector           vSwitchOff;
+!     private Vector           vSwitches;
+!     private static final int MAX_LINELENGTH = 82;
+  
+      /**
+       * Method declaration
+--- 109,121 ----
+   */
+  public class CodeSwitcher {
+  
+!     public static final String ls = System.getProperty("line.separator",
+          "\n");
+!     public Vector           vList;
+!     public Vector           vSwitchOn;
+!     public Vector           vSwitchOff;
+!     public Vector           vSwitches;
+!     public static final int MAX_LINELENGTH = 82;
+  
+      /**
+       * Method declaration
+diff -crN misc/hsqldb/src/org/hsqldb/util/CommonSwing.java misc/build/hsqldb/src/org/hsqldb/util/CommonSwing.java
+*** misc/hsqldb/src/org/hsqldb/util/CommonSwing.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/CommonSwing.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 86,97 ****
+   */
+  class CommonSwing {
+  
+!     protected static String messagerHeader = "Database Manager Swing Error";
+!     protected static String Native         = "Native";
+!     protected static String Java           = "Java";
+!     protected static String Motif          = "Motif";
+!     protected static String plaf           = "plaf";
+!     protected static String GTK            = "GTK";
+  
+      // (ulrivo): An actual Image.
+      static Image getIcon(String target) {
+--- 86,97 ----
+   */
+  class CommonSwing {
+  
+!     public static String messagerHeader = "Database Manager Swing Error";
+!     public static String Native         = "Native";
+!     public static String Java           = "Java";
+!     public static String Motif          = "Motif";
+!     public static String plaf           = "plaf";
+!     public static String GTK            = "GTK";
+  
+      // (ulrivo): An actual Image.
+      static Image getIcon(String target) {
+***************
+*** 135,141 ****
+      }
+  
+      // (weconsultants@users: Callable errorMessage method
+!     protected static void errorMessage(String errorMessage) {
+  
+          /**
+           * Display Jpanel Error messages any text Errors. Overloads
+--- 135,141 ----
+      }
+  
+      // (weconsultants@users: Callable errorMessage method
+!     public static void errorMessage(String errorMessage) {
+  
+          /**
+           * Display Jpanel Error messages any text Errors. Overloads
+diff -crN misc/hsqldb/src/org/hsqldb/util/ConnectionDialogCommon.java misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialogCommon.java
+*** misc/hsqldb/src/org/hsqldb/util/ConnectionDialogCommon.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialogCommon.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 59,66 ****
+   */
+  class ConnectionDialogCommon {
+  
+!     private static String[][]       connTypes;
+!     private static final String[][] sJDBCTypes = {
+          {
+              "HSQL Database Engine In-Memory", "org.hsqldb.jdbcDriver",
+              "jdbc:hsqldb:mem:."
+--- 59,66 ----
+   */
+  class ConnectionDialogCommon {
+  
+!     public static String[][]       connTypes;
+!     public static final String[][] sJDBCTypes = {
+          {
+              "HSQL Database Engine In-Memory", "org.hsqldb.jdbcDriver",
+              "jdbc:hsqldb:mem:."
+***************
+*** 160,167 ****
+   */
+      }
+  
+!     private static final String fileName       = "hsqlprefs.dat";
+!     private static File         recentSettings = null;
+  
+      static Hashtable loadRecentConnectionSettings() throws IOException {
+  
+--- 160,167 ----
+   */
+      }
+  
+!     public static final String fileName       = "hsqlprefs.dat";
+!     public static File         recentSettings = null;
+  
+      static Hashtable loadRecentConnectionSettings() throws IOException {
+  
+***************
+*** 246,252 ****
+       * @param settings ConnectionSetting[]
+       * @throw IOException if something goes wrong while writing
+       */
+!     private static void storeRecentConnectionSettings(Hashtable settings) {
+  
+          try {
+              if (recentSettings == null) {
+--- 246,252 ----
+       * @param settings ConnectionSetting[]
+       * @throw IOException if something goes wrong while writing
+       */
+!     public static void storeRecentConnectionSettings(Hashtable settings) {
+  
+          try {
+              if (recentSettings == null) {
+***************
+*** 311,317 ****
+          } catch (Throwable t) {}
+      }
+  
+!     private static String homedir = null;
+  
+      public static void setHomeDir() {
+  
+--- 311,317 ----
+          } catch (Throwable t) {}
+      }
+  
+!     public static String homedir = null;
+  
+      public static void setHomeDir() {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/util/ConnectionDialog.java misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialog.java
+*** misc/hsqldb/src/org/hsqldb/util/ConnectionDialog.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialog.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 67,78 ****
+  class ConnectionDialog extends Dialog
+  implements ActionListener, ItemListener {
+  
+!     protected Connection mConnection;
+!     protected TextField  mName, mDriver, mURL, mUser, mPassword;
+!     protected Label      mError;
+!     private String[][]   connTypes;
+!     private Hashtable    settings;
+!     private Choice       types, recent;
+  
+      /**
+       * Method declaration
+--- 67,78 ----
+  class ConnectionDialog extends Dialog
+  implements ActionListener, ItemListener {
+  
+!     public Connection mConnection;
+!     public TextField  mName, mDriver, mURL, mUser, mPassword;
+!     public Label      mError;
+!     public String[][]   connTypes;
+!     public Hashtable    settings;
+!     public Choice       types, recent;
+  
+      /**
+       * Method declaration
+***************
+*** 110,116 ****
+       * Method declaration
+       *
+       */
+!     private void create() {
+  
+          Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
+  
+--- 110,116 ----
+       * Method declaration
+       *
+       */
+!     public void create() {
+  
+          Dimension d = Toolkit.getDefaultToolkit().getScreenSize();
+  
+***************
+*** 305,311 ****
+       *
+       * @return
+       */
+!     protected static Label createLabel(String s) {
+  
+          Label l = new Label(s);
+  
+--- 305,311 ----
+       *
+       * @return
+       */
+!     public static Label createLabel(String s) {
+  
+          Label l = new Label(s);
+  
+***************
+*** 322,328 ****
+       *
+       * @return
+       */
+!     protected static Panel createBorderPanel(Component center) {
+  
+          Panel p = new Panel();
+  
+--- 322,328 ----
+       *
+       * @return
+       */
+!     public static Panel createBorderPanel(Component center) {
+  
+          Panel p = new Panel();
+  
+diff -crN misc/hsqldb/src/org/hsqldb/util/ConnectionDialogSwing.java misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialogSwing.java
+*** misc/hsqldb/src/org/hsqldb/util/ConnectionDialogSwing.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ConnectionDialogSwing.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 82,95 ****
+      /**
+       * Comment for <code>serialVersionUID</code>
+       */
+!     private static final long serialVersionUID = 1L;
+!     private Connection        mConnection;
+!     private JTextField        mName, mDriver, mURL, mUser;
+!     private JPasswordField    mPassword;
+!     private String[][]        connTypes;
+!     private Hashtable         settings;
+!     private JButton           okCancel, clear;
+!     private JComboBox mSettingName =
+          new JComboBox(loadRecentConnectionSettings());
+  
+      public static Connection createConnection(String driver, String url,
+--- 82,95 ----
+      /**
+       * Comment for <code>serialVersionUID</code>
+       */
+!     public static final long serialVersionUID = 1L;
+!     public Connection        mConnection;
+!     public JTextField        mName, mDriver, mURL, mUser;
+!     public JPasswordField    mPassword;
+!     public String[][]        connTypes;
+!     public Hashtable         settings;
+!     public JButton           okCancel, clear;
+!     public JComboBox mSettingName =
+          new JComboBox(loadRecentConnectionSettings());
+  
+      public static Connection createConnection(String driver, String url,
+***************
+*** 104,110 ****
+          super(owner, title, true);
+      }
+  
+!     private void create() {
+  
+          Box main     = Box.createHorizontalBox();
+          Box labels   = Box.createVerticalBox();
+--- 104,110 ----
+          super(owner, title, true);
+      }
+  
+!     public void create() {
+  
+          Box main     = Box.createHorizontalBox();
+          Box labels   = Box.createVerticalBox();
+***************
+*** 271,277 ****
+          return dialog.mConnection;
+      }
+  
+!     private static JLabel createLabel(String s) {
+  
+          JLabel l = new JLabel(s);
+  
+--- 271,277 ----
+          return dialog.mConnection;
+      }
+  
+!     public static JLabel createLabel(String s) {
+  
+          JLabel l = new JLabel(s);
+  
+diff -crN misc/hsqldb/src/org/hsqldb/util/ConnectionSetting.java misc/build/hsqldb/src/org/hsqldb/util/ConnectionSetting.java
+*** misc/hsqldb/src/org/hsqldb/util/ConnectionSetting.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ConnectionSetting.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 39,45 ****
+   */
+  public class ConnectionSetting implements java.io.Serializable {
+  
+!     private String name, driver, url, user, pw;
+  
+      String getName() {
+          return name;
+--- 39,45 ----
+   */
+  public class ConnectionSetting implements java.io.Serializable {
+  
+!     public String name, driver, url, user, pw;
+  
+      String getName() {
+          return name;
+***************
+*** 62,68 ****
+      }
+  
+      // Constructors
+!     private ConnectionSetting() {}
+      ;
+  
+      ConnectionSetting(String name, String driver, String url, String user,
+--- 62,68 ----
+      }
+  
+      // Constructors
+!     public ConnectionSetting() {}
+      ;
+  
+      ConnectionSetting(String name, String driver, String url, String user,
+diff -crN misc/hsqldb/src/org/hsqldb/util/CSVWriter.java misc/build/hsqldb/src/org/hsqldb/util/CSVWriter.java
+*** misc/hsqldb/src/org/hsqldb/util/CSVWriter.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/CSVWriter.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 49,58 ****
+   */
+  public class CSVWriter {
+  
+!     private String             newline = System.getProperty("line.separator");
+!     private OutputStreamWriter writer  = null;
+!     private int                nbrCols = 0;
+!     private int                nbrRows = 0;
+  
+      /**
+       * constructor.
+--- 49,58 ----
+   */
+  public class CSVWriter {
+  
+!     public String             newline = System.getProperty("line.separator");
+!     public OutputStreamWriter writer  = null;
+!     public int                nbrCols = 0;
+!     public int                nbrRows = 0;
+  
+      /**
+       * constructor.
+***************
+*** 100,106 ****
+          this.writer.close();
+      }
+  
+!     private void doWriteData(String[] values) throws IOException {
+  
+          for (int i = 0; i < values.length; i++) {
+              if (i > 0) {
+--- 100,106 ----
+          this.writer.close();
+      }
+  
+!     public void doWriteData(String[] values) throws IOException {
+  
+          for (int i = 0; i < values.length; i++) {
+              if (i > 0) {
+***************
+*** 119,125 ****
+          this.nbrRows++;
+      }
+  
+!     private String toCsvValue(String str) {
+  
+          StringBuffer sb = new StringBuffer();
+  
+--- 119,125 ----
+          this.nbrRows++;
+      }
+  
+!     public String toCsvValue(String str) {
+  
+          StringBuffer sb = new StringBuffer();
+  
+diff -crN misc/hsqldb/src/org/hsqldb/util/DatabaseManagerCommon.java misc/build/hsqldb/src/org/hsqldb/util/DatabaseManagerCommon.java
+*** misc/hsqldb/src/org/hsqldb/util/DatabaseManagerCommon.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/DatabaseManagerCommon.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 92,98 ****
+   */
+  class DatabaseManagerCommon {
+  
+!     private static Random rRandom    = new Random(100);
+      static String[]       selectHelp = {
+          "SELECT * FROM ",
+          "SELECT [LIMIT n m] [DISTINCT] \n"
+--- 92,98 ----
+   */
+  class DatabaseManagerCommon {
+  
+!     public static Random rRandom    = new Random(100);
+      static String[]       selectHelp = {
+          "SELECT * FROM ",
+          "SELECT [LIMIT n m] [DISTINCT] \n"
+***************
+*** 405,409 ****
+          return (System.currentTimeMillis() - start);
+      }
+  
+!     private DatabaseManagerCommon() {}
+  }
+--- 405,409 ----
+          return (System.currentTimeMillis() - start);
+      }
+  
+!     public DatabaseManagerCommon() {}
+  }
+diff -crN misc/hsqldb/src/org/hsqldb/util/DatabaseManager.java misc/build/hsqldb/src/org/hsqldb/util/DatabaseManager.java
+*** misc/hsqldb/src/org/hsqldb/util/DatabaseManager.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/DatabaseManager.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 98,104 ****
+  public class DatabaseManager extends Applet
+  implements ActionListener, WindowListener, KeyListener {
+  
+!     private static final String DEFAULT_RCFILE =
+          System.getProperty("user.home") + "/dbmanager.rc";
+      static final String NL         = System.getProperty("line.separator");
+      static final int    iMaxRecent = 24;
+--- 98,104 ----
+  public class DatabaseManager extends Applet
+  implements ActionListener, WindowListener, KeyListener {
+  
+!     public static final String DEFAULT_RCFILE =
+          System.getProperty("user.home") + "/dbmanager.rc";
+      static final String NL         = System.getProperty("line.separator");
+      static final int    iMaxRecent = 24;
+***************
+*** 289,295 ****
+          m.connect(c);
+      }
+  
+!     private static void showUsage() {
+  
+          System.out.println(
+              "Usage: java DatabaseManager [--options]\n"
+--- 289,295 ----
+          m.connect(c);
+      }
+  
+!     public static void showUsage() {
+  
+          System.out.println(
+              "Usage: java DatabaseManager [--options]\n"
+***************
+*** 1149,1155 ****
+       *
+       * @param s
+       */
+!     private void addToRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+--- 1149,1155 ----
+       *
+       * @param s
+       */
+!     public void addToRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+***************
+*** 1180,1186 ****
+       * Method declaration
+       *
+       */
+!     private void initGUI() {
+  
+          Panel pQuery   = new Panel();
+          Panel pCommand = new Panel();
+--- 1180,1186 ----
+       * Method declaration
+       *
+       */
+!     public void initGUI() {
+  
+          Panel pQuery   = new Panel();
+          Panel pCommand = new Panel();
+***************
+*** 1240,1246 ****
+       * Method declaration
+       *
+       */
+!     protected void refreshTree() {
+  
+          tTree.removeAll();
+  
+--- 1240,1246 ----
+       * Method declaration
+       *
+       */
+!     public void refreshTree() {
+  
+          tTree.removeAll();
+  
+diff -crN misc/hsqldb/src/org/hsqldb/util/DatabaseManagerSwing.java misc/build/hsqldb/src/org/hsqldb/util/DatabaseManagerSwing.java
+*** misc/hsqldb/src/org/hsqldb/util/DatabaseManagerSwing.java	2005-10-27 21:55:48.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/DatabaseManagerSwing.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 193,199 ****
+       * be reserved for single-letter switches which can be mixed like
+       * "-u -r -l" = "-url".  -blaine
+       */
+!     private static String homedir = null;
+  
+      static {
+          try {
+--- 193,199 ----
+       * be reserved for single-letter switches which can be mixed like
+       * "-u -r -l" = "-url".  -blaine
+       */
+!     public static String homedir = null;
+  
+      static {
+          try {
+***************
+*** 239,252 ****
+      }
+  
+      ArrayList                   localActionList = new ArrayList();
+!     private JFrame              jframe          = null;
+!     private static final String DEFAULT_RCFILE  = homedir + "/dbmanager.rc";
+!     private static final String HELP_TEXT =
+          "See the forums, mailing lists, and HSQLDB User Guide\n"
+          + "at http://hsqldb.org.\n\n"
+          + "Please paste the following version identifier with any\n"
+          + "problem reports or help requests:  $Revision: 1.65 $";
+!     private static final String ABOUT_TEXT =
+          "$Revision: 1.65 $ of DatabaseManagerSwing\n\n"
+          + "Copyright (c) 1995-2000, The Hypersonic SQL Group.\n"
+          + "Copyright (c) 2001-2005, The HSQL Development Group.\n"
+--- 239,252 ----
+      }
+  
+      ArrayList                   localActionList = new ArrayList();
+!     public JFrame              jframe          = null;
+!     public static final String DEFAULT_RCFILE  = homedir + "/dbmanager.rc";
+!     public static final String HELP_TEXT =
+          "See the forums, mailing lists, and HSQLDB User Guide\n"
+          + "at http://hsqldb.org.\n\n"
+          + "Please paste the following version identifier with any\n"
+          + "problem reports or help requests:  $Revision: 1.65 $";
+!     public static final String ABOUT_TEXT =
+          "$Revision: 1.65 $ of DatabaseManagerSwing\n\n"
+          + "Copyright (c) 1995-2000, The Hypersonic SQL Group.\n"
+          + "Copyright (c) 2001-2005, The HSQL Development Group.\n"
+***************
+*** 297,306 ****
+      /** Value of this variable only retained if huge input script read in. */
+      String          sqlScriptBuffer = null;
+      JToolBar        jtoolbar;
+!     private boolean showSchemas  = true;
+!     private boolean showTooltips = true;
+!     private boolean autoRefresh  = true;
+!     private boolean gridFormat   = true;
+  
+      // Added: (weconsultants@users)
+      static DatabaseManagerSwing refForFontDialogSwing;
+--- 297,306 ----
+      /** Value of this variable only retained if huge input script read in. */
+      String          sqlScriptBuffer = null;
+      JToolBar        jtoolbar;
+!     public boolean showSchemas  = true;
+!     public boolean showTooltips = true;
+!     public boolean autoRefresh  = true;
+!     public boolean gridFormat   = true;
+  
+      // Added: (weconsultants@users)
+      static DatabaseManagerSwing refForFontDialogSwing;
+***************
+*** 336,349 ****
+          new JRadioButtonMenuItem("Motif Look & Feel");
+      JLabel                      jStatusLine;
+      static String               READY_STATUS         = "Ready";
+!     private static final String AUTOCOMMIT_BOX_TEXT  = "Autocommit mode";
+!     private static final String LOGGING_BOX_TEXT     = "Logging mode";
+!     private static final String SHOWSCHEMAS_BOX_TEXT = "Show schemas";
+!     private static final String AUTOREFRESH_BOX_TEXT = "Auto-refresh tree";
+!     private static final String SHOWTIPS_BOX_TEXT    = "Show Tooltips";
+!     private static final String ROWCOUNTS_BOX_TEXT   = "Show row counts";
+!     private static final String SHOWSYS_BOX_TEXT     = "Show system tables";
+!     private static final String GRID_BOX_TEXT =
+          "Show results in Grid (a.o.t. Text)";
+  
+      // variables to hold the default cursors for these top level swing objects
+--- 336,349 ----
+          new JRadioButtonMenuItem("Motif Look & Feel");
+      JLabel                      jStatusLine;
+      static String               READY_STATUS         = "Ready";
+!     public static final String AUTOCOMMIT_BOX_TEXT  = "Autocommit mode";
+!     public static final String LOGGING_BOX_TEXT     = "Logging mode";
+!     public static final String SHOWSCHEMAS_BOX_TEXT = "Show schemas";
+!     public static final String AUTOREFRESH_BOX_TEXT = "Auto-refresh tree";
+!     public static final String SHOWTIPS_BOX_TEXT    = "Show Tooltips";
+!     public static final String ROWCOUNTS_BOX_TEXT   = "Show row counts";
+!     public static final String SHOWSYS_BOX_TEXT     = "Show system tables";
+!     public static final String GRID_BOX_TEXT =
+          "Show results in Grid (a.o.t. Text)";
+  
+      // variables to hold the default cursors for these top level swing objects
+***************
+*** 352,365 ****
+      Cursor        txtCommandCursor;
+      Cursor        txtResultCursor;
+      HashMap       tipMap     = new HashMap();
+!     private JMenu mnuSchemas = new JMenu("Schemas");
+  
+      /**
+       * Wait Cursor
+       */
+  
+      // Changed: (weconsultants@users): commonted out the, out of the box, cursor to use a custom cursor
+!     private final Cursor waitCursor = new Cursor(Cursor.WAIT_CURSOR);
+  
+      //getToolkit().createCustomCursor(CommonSwing.getIcon("SystemCursor"),
+      //                                new Point(4, 4), "HourGlass cursor");
+--- 352,365 ----
+      Cursor        txtCommandCursor;
+      Cursor        txtResultCursor;
+      HashMap       tipMap     = new HashMap();
+!     public JMenu mnuSchemas = new JMenu("Schemas");
+  
+      /**
+       * Wait Cursor
+       */
+  
+      // Changed: (weconsultants@users): commonted out the, out of the box, cursor to use a custom cursor
+!     public final Cursor waitCursor = new Cursor(Cursor.WAIT_CURSOR);
+  
+      //getToolkit().createCustomCursor(CommonSwing.getIcon("SystemCursor"),
+      //                                new Point(4, 4), "HourGlass cursor");
+***************
+*** 370,376 ****
+      static String  defPassword = "";
+      static String  defScript;
+      static String  defDirectory;
+!     private String schemaFilter = null;
+  
+      public DatabaseManagerSwing() {
+          jframe = new JFrame("dummy");
+--- 370,376 ----
+      static String  defPassword = "";
+      static String  defScript;
+      static String  defDirectory;
+!     public String schemaFilter = null;
+  
+      public DatabaseManagerSwing() {
+          jframe = new JFrame("dummy");
+***************
+*** 627,633 ****
+          }
+      }
+  
+!     private static void showUsage() {
+  
+          System.out.println(
+              "Usage: java DatabaseManagerSwing [--options]\n"
+--- 627,633 ----
+          }
+      }
+  
+!     public static void showUsage() {
+  
+          System.out.println(
+              "Usage: java DatabaseManagerSwing [--options]\n"
+***************
+*** 644,650 ****
+              + "(Single-hypen switches like '-driver' are also supported)");
+      }
+  
+!     private void insertTestData() {
+  
+          try {
+              DatabaseManagerCommon.createTestTables(sStatement);
+--- 644,650 ----
+              + "(Single-hypen switches like '-driver' are also supported)");
+      }
+  
+!     public void insertTestData() {
+  
+          try {
+              DatabaseManagerCommon.createTestTables(sStatement);
+***************
+*** 668,674 ****
+          this.bMustExit = b;
+      }
+  
+!     private DBMPrefs prefs = null;
+  
+      public void main() {
+  
+--- 668,674 ----
+          this.bMustExit = b;
+      }
+  
+!     public DBMPrefs prefs = null;
+  
+      public void main() {
+  
+***************
+*** 945,951 ****
+          txtCommand.requestFocus();
+      }
+  
+!     private JMenu addMenu(JMenuBar b, String name, Object[] items) {
+  
+          JMenu menu = new JMenu(name);
+  
+--- 945,951 ----
+          txtCommand.requestFocus();
+      }
+  
+!     public JMenu addMenu(JMenuBar b, String name, Object[] items) {
+  
+          JMenu menu = new JMenu(name);
+  
+***************
+*** 956,962 ****
+          return menu;
+      }
+  
+!     private void addMenuItems(JMenu f, Object[] m) {
+  
+          /*
+           * This method needs to be completely written or just
+--- 956,962 ----
+          return menu;
+      }
+  
+!     public void addMenuItems(JMenu f, Object[] m) {
+  
+          /*
+           * This method needs to be completely written or just
+***************
+*** 1261,1267 ****
+          }
+      }
+  
+!     private void displayResults() {
+  
+          if (gridFormat) {
+              setResultsInGrid();
+--- 1261,1267 ----
+          }
+      }
+  
+!     public void displayResults() {
+  
+          if (gridFormat) {
+              setResultsInGrid();
+***************
+*** 1270,1276 ****
+          }
+      }
+  
+!     private void setResultsInGrid() {
+  
+          pResult.removeAll();
+          pResult.add(gScrollPane, BorderLayout.CENTER);
+--- 1270,1276 ----
+          }
+      }
+  
+!     public void setResultsInGrid() {
+  
+          pResult.removeAll();
+          pResult.add(gScrollPane, BorderLayout.CENTER);
+***************
+*** 1279,1285 ****
+          pResult.repaint();
+      }
+  
+!     private void setResultsInText() {
+  
+          pResult.removeAll();
+          pResult.add(txtResultScroll, BorderLayout.CENTER);
+--- 1279,1285 ----
+          pResult.repaint();
+      }
+  
+!     public void setResultsInText() {
+  
+          pResult.removeAll();
+          pResult.add(txtResultScroll, BorderLayout.CENTER);
+***************
+*** 1288,1294 ****
+          pResult.repaint();
+      }
+  
+!     private void showHelp(String[] help) {
+  
+          txtCommand.setText(help[0]);
+  
+--- 1288,1294 ----
+          pResult.repaint();
+      }
+  
+!     public void showHelp(String[] help) {
+  
+          txtCommand.setText(help[0]);
+  
+***************
+*** 1350,1356 ****
+          }
+      }
+  
+!     private void clear() {
+  
+          sqlScriptBuffer = null;
+  
+--- 1350,1356 ----
+          }
+      }
+  
+!     public void clear() {
+  
+          sqlScriptBuffer = null;
+  
+***************
+*** 1358,1366 ****
+          txtCommand.setEnabled(true);
+      }
+  
+!     private String busyText = null;
+  
+!     private void backgroundIt(Runnable r, String description) {
+  
+          if (busyText != null) {
+              Toolkit.getDefaultToolkit().beep();
+--- 1358,1366 ----
+          txtCommand.setEnabled(true);
+      }
+  
+!     public String busyText = null;
+  
+!     public void backgroundIt(Runnable r, String description) {
+  
+          if (busyText != null) {
+              Toolkit.getDefaultToolkit().beep();
+***************
+*** 1374,1380 ****
+          SwingUtilities.invokeLater(r);
+      }
+  
+!     private void clearResultPanel() {
+  
+          gResult.setHead(new Object[0]);
+          gResult.clear();
+--- 1374,1380 ----
+          SwingUtilities.invokeLater(r);
+      }
+  
+!     public void clearResultPanel() {
+  
+          gResult.setHead(new Object[0]);
+          gResult.clear();
+***************
+*** 1431,1453 ****
+                                                      : 0));
+      }
+  
+!     private Runnable enableButtonRunnable = new Runnable() {
+  
+          public void run() {
+              jbuttonClear.setEnabled(true);
+              jbuttonExecute.setEnabled(true);
+          }
+      };
+!     private Runnable disableButtonRunnable = new Runnable() {
+  
+          public void run() {
+              jbuttonClear.setEnabled(false);
+              jbuttonExecute.setEnabled(false);
+          }
+      };
+!     private Thread           buttonUpdaterThread = null;
+!     private static final int BUTTON_CHECK_PERIOD = 500;
+!     private Runnable         buttonUpdater       = new Runnable() {
+  
+          public void run() {
+  
+--- 1431,1453 ----
+                                                      : 0));
+      }
+  
+!     public Runnable enableButtonRunnable = new Runnable() {
+  
+          public void run() {
+              jbuttonClear.setEnabled(true);
+              jbuttonExecute.setEnabled(true);
+          }
+      };
+!     public Runnable disableButtonRunnable = new Runnable() {
+  
+          public void run() {
+              jbuttonClear.setEnabled(false);
+              jbuttonExecute.setEnabled(false);
+          }
+      };
+!     public Thread           buttonUpdaterThread = null;
+!     public static final int BUTTON_CHECK_PERIOD = 500;
+!     public Runnable         buttonUpdater       = new Runnable() {
+  
+          public void run() {
+  
+***************
+*** 1471,1478 ****
+              }
+          }
+      };
+!     private JButton jbuttonClear;
+!     private JButton jbuttonExecute;
+  
+      public void start() {
+  
+--- 1471,1478 ----
+              }
+          }
+      };
+!     public JButton jbuttonClear;
+!     public JButton jbuttonExecute;
+  
+      public void start() {
+  
+***************
+*** 1490,1496 ****
+          buttonUpdaterThread = null;
+      }
+  
+!     private Runnable treeRefreshRunnable = new Runnable() {
+  
+          public void run() {
+  
+--- 1490,1496 ----
+          buttonUpdaterThread = null;
+      }
+  
+!     public Runnable treeRefreshRunnable = new Runnable() {
+  
+          public void run() {
+  
+***************
+*** 1509,1515 ****
+      /**
+       * Schedules to run in a Gui-safe thread
+       */
+!     protected void executeCurrentSQL() {
+  
+          if (txtCommand.getText().length() < 1) {
+              CommonSwing.errorMessage("No SQL to execute");
+--- 1509,1515 ----
+      /**
+       * Schedules to run in a Gui-safe thread
+       */
+!     public void executeCurrentSQL() {
+  
+          if (txtCommand.getText().length() < 1) {
+              CommonSwing.errorMessage("No SQL to execute");
+***************
+*** 1520,1526 ****
+          backgroundIt(new StatementExecRunnable(), "Executing SQL");
+      }
+  
+!     protected class StatementExecRunnable implements Runnable {
+  
+          public void run() {
+  
+--- 1520,1526 ----
+          backgroundIt(new StatementExecRunnable(), "Executing SQL");
+      }
+  
+!     public class StatementExecRunnable implements Runnable {
+  
+          public void run() {
+  
+***************
+*** 1548,1554 ****
+      }
+      ;
+  
+!     private void executeSQL() {
+  
+          String[] g   = new String[1];
+          String   sql = null;
+--- 1548,1554 ----
+      }
+      ;
+  
+!     public void executeSQL() {
+  
+          String[] g   = new String[1];
+          String   sql = null;
+***************
+*** 1626,1632 ****
+       * results only if gridFormat is off (seems like it  does
+       * nothing otherwise, except for clearing help text and moving focus).
+       */
+!     private void updateResult() {
+  
+          if (gridFormat) {
+  
+--- 1626,1632 ----
+       * results only if gridFormat is off (seems like it  does
+       * nothing otherwise, except for clearing help text and moving focus).
+       */
+!     public void updateResult() {
+  
+          if (gridFormat) {
+  
+***************
+*** 1654,1660 ****
+       * VARCHARs, because this is the only class where there is any
+       * ambiguity about whether there is a null stored or not.
+       */
+!     private void formatResultSet(ResultSet r) {
+  
+          if (r == null) {
+              String[] g = new String[1];
+--- 1654,1660 ----
+       * VARCHARs, because this is the only class where there is any
+       * ambiguity about whether there is a null stored or not.
+       */
+!     public void formatResultSet(ResultSet r) {
+  
+          if (r == null) {
+              String[] g = new String[1];
+***************
+*** 1707,1713 ****
+          }
+      }
+  
+!     private void testPerformance() {
+  
+          String       all   = txtCommand.getText();
+          StringBuffer b     = new StringBuffer();
+--- 1707,1713 ----
+          }
+      }
+  
+!     public void testPerformance() {
+  
+          String       all   = txtCommand.getText();
+          StringBuffer b     = new StringBuffer();
+***************
+*** 1791,1797 ****
+       * Method declaration
+       *
+       */
+!     private void showResultInText() {
+  
+          Object[] col   = gResult.getHead();
+          int      width = col.length;
+--- 1791,1797 ----
+       * Method declaration
+       *
+       */
+!     public void showResultInText() {
+  
+          Object[] col   = gResult.getHead();
+          int      width = col.length;
+***************
+*** 1866,1872 ****
+          txtResult.setText(b.toString());
+      }
+  
+!     private void addToRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+--- 1866,1872 ----
+          txtResult.setText(b.toString());
+      }
+  
+!     public void addToRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+***************
+*** 1893,1899 ****
+          iRecent = (iRecent + 1) % iMaxRecent;
+      }
+  
+!     private void initGUI() {
+  
+          JPanel pCommand = new JPanel();
+  
+--- 1893,1899 ----
+          iRecent = (iRecent + 1) % iMaxRecent;
+      }
+  
+!     public void initGUI() {
+  
+          JPanel pCommand = new JPanel();
+  
+***************
+*** 1985,1991 ****
+  
+      /* Simple tree node factory method - set's parent and user object.
+       */
+!     private DefaultMutableTreeNode makeNode(Object userObject,
+              MutableTreeNode parent) {
+  
+          DefaultMutableTreeNode node = new DefaultMutableTreeNode(userObject);
+--- 1985,1991 ----
+  
+      /* Simple tree node factory method - set's parent and user object.
+       */
+!     public DefaultMutableTreeNode makeNode(Object userObject,
+              MutableTreeNode parent) {
+  
+          DefaultMutableTreeNode node = new DefaultMutableTreeNode(userObject);
+***************
+*** 1997,2010 ****
+          return node;
+      }
+  
+!     private static final String[] usertables       = {
+          "TABLE", "GLOBAL TEMPORARY", "VIEW", "SYSTEM TABLE"
+      };
+!     private static final String[] nonSystables     = {
+          "TABLE", "GLOBAL TEMPORARY", "VIEW"
+      };
+!     private static final HashSet  oracleSysUsers   = new HashSet();
+!     private static final String[] oracleSysSchemas = {
+          "SYS", "SYSTEM", "OUTLN", "DBSNMP", "OUTLN", "MDSYS", "ORDSYS",
+          "ORDPLUGINS", "CTXSYS", "DSSYS", "PERFSTAT", "WKPROXY", "WKSYS",
+          "WMSYS", "XDB", "ANONYMOUS", "ODM", "ODM_MTR", "OLAPSYS", "TRACESVR",
+--- 1997,2010 ----
+          return node;
+      }
+  
+!     public static final String[] usertables       = {
+          "TABLE", "GLOBAL TEMPORARY", "VIEW", "SYSTEM TABLE"
+      };
+!     public static final String[] nonSystables     = {
+          "TABLE", "GLOBAL TEMPORARY", "VIEW"
+      };
+!     public static final HashSet  oracleSysUsers   = new HashSet();
+!     public static final String[] oracleSysSchemas = {
+          "SYS", "SYSTEM", "OUTLN", "DBSNMP", "OUTLN", "MDSYS", "ORDSYS",
+          "ORDPLUGINS", "CTXSYS", "DSSYS", "PERFSTAT", "WKPROXY", "WKSYS",
+          "WMSYS", "XDB", "ANONYMOUS", "ODM", "ODM_MTR", "OLAPSYS", "TRACESVR",
+***************
+*** 2020,2026 ****
+      /**
+       * Schedules to run in a Gui-safe thread
+       */
+!     protected void refreshTree() {
+          backgroundIt(treeRefreshRunnable, "Refreshing object tree");
+      }
+  
+--- 2020,2026 ----
+      /**
+       * Schedules to run in a Gui-safe thread
+       */
+!     public void refreshTree() {
+          backgroundIt(treeRefreshRunnable, "Refreshing object tree");
+      }
+  
+***************
+*** 2029,2035 ****
+       *
+       * This method executes in current thread
+       */
+!     protected void directRefreshTree() {
+  
+          int[]                  rowCounts;
+          DefaultMutableTreeNode propertiesNode;
+--- 2029,2035 ----
+       *
+       * This method executes in current thread
+       */
+!     public void directRefreshTree() {
+  
+          int[]                  rowCounts;
+          DefaultMutableTreeNode propertiesNode;
+***************
+*** 2254,2260 ****
+      }
+  
+      // Added: (weconsultants@users) Needed to aggragate counts per table in jTree
+!     protected int[] getRowCounts(Vector inTable,
+                                   Vector inSchema) throws Exception {
+  
+          if (!displayRowCounts) {
+--- 2254,2260 ----
+      }
+  
+      // Added: (weconsultants@users) Needed to aggragate counts per table in jTree
+!     public int[] getRowCounts(Vector inTable,
+                                   Vector inSchema) throws Exception {
+  
+          if (!displayRowCounts) {
+***************
+*** 2298,2304 ****
+          return (counts);
+      }
+  
+!     protected JToolBar createToolBar() {
+  
+          // Build jtoolbar and jtoolbar Buttons
+          JToolBar jtoolbar = new JToolBar();
+--- 2298,2304 ----
+          return (counts);
+      }
+  
+!     public JToolBar createToolBar() {
+  
+          // Build jtoolbar and jtoolbar Buttons
+          JToolBar jtoolbar = new JToolBar();
+***************
+*** 2363,2369 ****
+          }
+      }
+  
+!     private void setLF(String newLAF) {
+  
+          if (currentLAF != null && currentLAF == newLAF) {    // No change
+              return;
+--- 2363,2369 ----
+          }
+      }
+  
+!     public void setLF(String newLAF) {
+  
+          if (currentLAF != null && currentLAF == newLAF) {    // No change
+              return;
+***************
+*** 2404,2410 ****
+          }
+      }
+  
+!     private void updateSchemaList() {
+  
+          ButtonGroup group = new ButtonGroup();
+          ArrayList   list  = new ArrayList();
+--- 2404,2410 ----
+          }
+      }
+  
+!     public void updateSchemaList() {
+  
+          ButtonGroup group = new ButtonGroup();
+          ArrayList   list  = new ArrayList();
+***************
+*** 2651,2656 ****
+          }
+      }
+  
+!     private static final String tString = Boolean.TRUE.toString();
+!     private static final String fString = Boolean.FALSE.toString();
+  }
+--- 2651,2656 ----
+          }
+      }
+  
+!     public static final String tString = Boolean.TRUE.toString();
+!     public static final String fString = Boolean.FALSE.toString();
+  }
+diff -crN misc/hsqldb/src/org/hsqldb/util/FontDialogSwing.java misc/build/hsqldb/src/org/hsqldb/util/FontDialogSwing.java
+*** misc/hsqldb/src/org/hsqldb/util/FontDialogSwing.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/FontDialogSwing.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 56,84 ****
+  //        for JComboBox fontSizesComboBox and String fontSizes[];
+  public class FontDialogSwing extends JDialog {
+  
+!     private static boolean      isRunning   = false;
+!     private static final String BACKGROUND  = "Background";
+!     private static String       defaultFont = "Dialog";
+!     private static final String FOREGROUND  = "Foreground";
+!     private static JButton      bgColorButton;
+!     private static JCheckBox    ckbbold;
+!     private static JButton      closeButton;
+!     private static JButton      fgColorButton;
+!     private static JComboBox    fontsComboBox;
+  
+      //  weconsultants@users 20050215 - Added for Compatbilty fix for JDK 1.3
+!     private static JComboBox      fontSizesComboBox;
+!     private static final String[] fontSizes = {
+          "8", "9", "10", "11", "12", "13", "14", "16", "18", "24", "36"
+      };
+  
+      // weconsultants@users 20050215 - Commented out for Compatbilty fix for JDK 1.3
+!     //  private static JSpinner           spinnerFontSizes;
+!     //  private static SpinnerNumberModel spinnerModelSizes;
+!     private static DatabaseManagerSwing fOwner;
+!     private static JFrame frame =
+          new JFrame("DataBaseManagerSwing Font Selection Dialog");
+!     private static JCheckBox ckbitalic;
+  
+      /**
+       * Create and display FontDialogSwing Dialog.
+--- 56,84 ----
+  //        for JComboBox fontSizesComboBox and String fontSizes[];
+  public class FontDialogSwing extends JDialog {
+  
+!     public static boolean      isRunning   = false;
+!     public static final String BACKGROUND  = "Background";
+!     public static String       defaultFont = "Dialog";
+!     public static final String FOREGROUND  = "Foreground";
+!     public static JButton      bgColorButton;
+!     public static JCheckBox    ckbbold;
+!     public static JButton      closeButton;
+!     public static JButton      fgColorButton;
+!     public static JComboBox    fontsComboBox;
+  
+      //  weconsultants@users 20050215 - Added for Compatbilty fix for JDK 1.3
+!     public static JComboBox      fontSizesComboBox;
+!     public static final String[] fontSizes = {
+          "8", "9", "10", "11", "12", "13", "14", "16", "18", "24", "36"
+      };
+  
+      // weconsultants@users 20050215 - Commented out for Compatbilty fix for JDK 1.3
+!     //  public static JSpinner           spinnerFontSizes;
+!     //  public static SpinnerNumberModel spinnerModelSizes;
+!     public static DatabaseManagerSwing fOwner;
+!     public static JFrame frame =
+          new JFrame("DataBaseManagerSwing Font Selection Dialog");
+!     public static JCheckBox ckbitalic;
+  
+      /**
+       * Create and display FontDialogSwing Dialog.
+diff -crN misc/hsqldb/src/org/hsqldb/util/Grid.java misc/build/hsqldb/src/org/hsqldb/util/Grid.java
+*** misc/hsqldb/src/org/hsqldb/util/Grid.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/Grid.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 90,129 ****
+  class Grid extends Panel {
+  
+      // drawing
+!     private Dimension dMinimum;
+  
+  // boucherb@users changed access for databasemanager2
+!     protected Font fFont;
+  
+  // --------------------------------------------------
+!     private FontMetrics fMetrics;
+!     private Graphics    gImage;
+!     private Image       iImage;
+  
+      // height / width
+!     private int iWidth, iHeight;
+!     private int iRowHeight, iFirstRow;
+!     private int iGridWidth, iGridHeight;
+!     private int iX, iY;
+  
+      // data
+  // boucherb@users changed access for databasemanager2
+!     protected String[] sColHead = new String[0];
+!     protected Vector   vData    = new Vector();
+  
+  // --------------------------------------------------
+!     private int[] iColWidth;
+!     private int   iColCount;
+  
+  // boucherb@users changed access for databasemanager2
+!     protected int iRowCount;
+  
+  // --------------------------------------------------
+      // scrolling
+!     private Scrollbar sbHoriz, sbVert;
+!     private int       iSbWidth, iSbHeight;
+!     private boolean   bDrag;
+!     private int       iXDrag, iColDrag;
+  
+      /**
+       * Constructor declaration
+--- 90,129 ----
+  class Grid extends Panel {
+  
+      // drawing
+!     public Dimension dMinimum;
+  
+  // boucherb@users changed access for databasemanager2
+!     public Font fFont;
+  
+  // --------------------------------------------------
+!     public FontMetrics fMetrics;
+!     public Graphics    gImage;
+!     public Image       iImage;
+  
+      // height / width
+!     public int iWidth, iHeight;
+!     public int iRowHeight, iFirstRow;
+!     public int iGridWidth, iGridHeight;
+!     public int iX, iY;
+  
+      // data
+  // boucherb@users changed access for databasemanager2
+!     public String[] sColHead = new String[0];
+!     public Vector   vData    = new Vector();
+  
+  // --------------------------------------------------
+!     public int[] iColWidth;
+!     public int   iColCount;
+  
+  // boucherb@users changed access for databasemanager2
+!     public int iRowCount;
+  
+  // --------------------------------------------------
+      // scrolling
+!     public Scrollbar sbHoriz, sbVert;
+!     public int       iSbWidth, iSbHeight;
+!     public boolean   bDrag;
+!     public int       iXDrag, iColDrag;
+  
+      /**
+       * Constructor declaration
+***************
+*** 587,593 ****
+       *
+       * @param i
+       */
+!     private void calcAutoWidth(int i) {
+  
+          int w = 10;
+  
+--- 587,593 ----
+       *
+       * @param i
+       */
+!     public void calcAutoWidth(int i) {
+  
+          int w = 10;
+  
+***************
+*** 611,617 ****
+       *
+       * @return
+       */
+!     private String getDisplay(int x, int y) {
+          return (((String[]) (vData.elementAt(y)))[x]);
+      }
+  
+--- 611,617 ----
+       *
+       * @return
+       */
+!     public String getDisplay(int x, int y) {
+          return (((String[]) (vData.elementAt(y)))[x]);
+      }
+  
+***************
+*** 624,630 ****
+       *
+       * @return
+       */
+!     private String get(int x, int y) {
+          return (((String[]) (vData.elementAt(y)))[x]);
+      }
+  
+--- 624,630 ----
+       *
+       * @return
+       */
+!     public String get(int x, int y) {
+          return (((String[]) (vData.elementAt(y)))[x]);
+      }
+  
+***************
+*** 636,642 ****
+       *
+       * @return
+       */
+!     private static int getMaxHeight(FontMetrics f) {
+          return f.getHeight() + 4;
+      }
+  }
+--- 636,642 ----
+       *
+       * @return
+       */
+!     public static int getMaxHeight(FontMetrics f) {
+          return f.getHeight() + 4;
+      }
+  }
+diff -crN misc/hsqldb/src/org/hsqldb/util/JDBCTypes.java misc/build/hsqldb/src/org/hsqldb/util/JDBCTypes.java
+*** misc/hsqldb/src/org/hsqldb/util/JDBCTypes.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/JDBCTypes.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 48,55 ****
+      public static final int BLOB        = 2004;
+      public static final int CLOB        = 2005;
+      public static final int REF         = 2006;
+!     private Hashtable       hStringJDBCtypes;
+!     private Hashtable       hIntJDBCtypes;
+  
+      JDBCTypes() {
+  
+--- 48,55 ----
+      public static final int BLOB        = 2004;
+      public static final int CLOB        = 2005;
+      public static final int REF         = 2006;
+!     public Hashtable       hStringJDBCtypes;
+!     public Hashtable       hIntJDBCtypes;
+  
+      JDBCTypes() {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/util/MainInvoker.java misc/build/hsqldb/src/org/hsqldb/util/MainInvoker.java
+*** misc/hsqldb/src/org/hsqldb/util/MainInvoker.java	2005-10-23 19:25:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/MainInvoker.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 51,59 ****
+       * It may or may not make sense to make this into a class with real
+       * instances that can keep track of status of stuff invoked by it.
+       */
+!     private static String[] emptyStringArray = new String[0];
+  
+!     private static void syntaxFailure() {
+          System.err.println(SYNTAX_MSG);
+          System.exit(2);
+      }
+--- 51,59 ----
+       * It may or may not make sense to make this into a class with real
+       * instances that can keep track of status of stuff invoked by it.
+       */
+!     public static String[] emptyStringArray = new String[0];
+  
+!     public static void syntaxFailure() {
+          System.err.println(SYNTAX_MSG);
+          System.exit(2);
+      }
+***************
+*** 108,114 ****
+          }
+      }
+  
+!     private static final String SYNTAX_MSG =
+          "    java org.hsqldb.util.MainInvoker "
+          + "[package1.Class1 [arg1a arg1b...] \"\"]... \\\n"
+          + "    packageX.ClassX [argXa argXb...]\nOR\n"
+--- 108,114 ----
+          }
+      }
+  
+!     public static final String SYNTAX_MSG =
+          "    java org.hsqldb.util.MainInvoker "
+          + "[package1.Class1 [arg1a arg1b...] \"\"]... \\\n"
+          + "    packageX.ClassX [argXa argXb...]\nOR\n"
+diff -crN misc/hsqldb/src/org/hsqldb/util/OracleTransferHelper.java misc/build/hsqldb/src/org/hsqldb/util/OracleTransferHelper.java
+*** misc/hsqldb/src/org/hsqldb/util/OracleTransferHelper.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/OracleTransferHelper.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 46,53 ****
+   */
+  class OracleTransferHelper extends TransferHelper {
+  
+!     private final int ORACLE = 0;
+!     private final int HSQLDB = 1;
+      String[][]        Funcs  = {
+          {
+              "now()", "\'now\'"
+--- 46,53 ----
+   */
+  class OracleTransferHelper extends TransferHelper {
+  
+!     public final int ORACLE = 0;
+!     public final int HSQLDB = 1;
+      String[][]        Funcs  = {
+          {
+              "now()", "\'now\'"
+diff -crN misc/hsqldb/src/org/hsqldb/util/PostgresTransferHelper.java misc/build/hsqldb/src/org/hsqldb/util/PostgresTransferHelper.java
+*** misc/hsqldb/src/org/hsqldb/util/PostgresTransferHelper.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/PostgresTransferHelper.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 47,54 ****
+   */
+  class PostgresTransferHelper extends TransferHelper {
+  
+!     private final int PostgreSQL = 0;
+!     private final int HSQLDB     = 1;
+      String[][]        Funcs      = {
+          {
+              "now()", "\'now\'"
+--- 47,54 ----
+   */
+  class PostgresTransferHelper extends TransferHelper {
+  
+!     public final int PostgreSQL = 0;
+!     public final int HSQLDB     = 1;
+      String[][]        Funcs      = {
+          {
+              "now()", "\'now\'"
+diff -crN misc/hsqldb/src/org/hsqldb/util/QueryTool.java misc/build/hsqldb/src/org/hsqldb/util/QueryTool.java
+*** misc/hsqldb/src/org/hsqldb/util/QueryTool.java	2005-10-23 18:26:32.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/QueryTool.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 410,416 ****
+      /**
+       * Adds a String to the Listbox of recent commands.
+       */
+!     private void setRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+--- 410,416 ----
+      /**
+       * Adds a String to the Listbox of recent commands.
+       */
+!     public void setRecent(String s) {
+  
+          for (int i = 0; i < iMaxRecent; i++) {
+              if (s.equals(sRecent[i])) {
+***************
+*** 440,446 ****
+      /**
+       * Create the graphical user interface. This is AWT code.
+       */
+!     private void initGUI() {
+  
+          // all panels
+          Panel pQuery       = new Panel();
+--- 440,446 ----
+      /**
+       * Create the graphical user interface. This is AWT code.
+       */
+!     public void initGUI() {
+  
+          // all panels
+          Panel pQuery       = new Panel();
+diff -crN misc/hsqldb/src/org/hsqldb/util/ScriptTool.java misc/build/hsqldb/src/org/hsqldb/util/ScriptTool.java
+*** misc/hsqldb/src/org/hsqldb/util/ScriptTool.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ScriptTool.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 54,66 ****
+   */
+  public class ScriptTool {
+  
+!     private static Properties pProperties = new Properties();
+!     private Connection        cConn;
+!     private Statement         sStatement;
+!     private boolean           BATCH = true;
+!     private String            EKW   = new String("go");
+!     private boolean           EOF   = false;
+!     private int               ln    = 0;
+  
+      /**
+       * Main method
+--- 54,66 ----
+   */
+  public class ScriptTool {
+  
+!     public static Properties pProperties = new Properties();
+!     public Connection        cConn;
+!     public Statement         sStatement;
+!     public boolean           BATCH = true;
+!     public String            EKW   = new String("go");
+!     public boolean           EOF   = false;
+!     public int               ln    = 0;
+  
+      /**
+       * Main method
+***************
+*** 180,186 ****
+       * Translate ResultSet to String representation
+       * @param r
+       */
+!     private String toString(ResultSet r) {
+  
+          try {
+              if (r == null) {
+--- 180,186 ----
+       * Translate ResultSet to String representation
+       * @param r
+       */
+!     public String toString(ResultSet r) {
+  
+          try {
+              if (r == null) {
+***************
+*** 218,224 ****
+      /**
+       * Read file and convert it to string.
+       */
+!     private String fileToString(BufferedReader in) {
+  
+          if (EOF) {
+              return null;
+--- 218,224 ----
+      /**
+       * Read file and convert it to string.
+       */
+!     public String fileToString(BufferedReader in) {
+  
+          if (EOF) {
+              return null;
+***************
+*** 268,274 ****
+       *
+       * @param s
+       */
+!     private void trace(String s) {
+          System.out.println(s);
+      }
+  
+--- 268,274 ----
+       *
+       * @param s
+       */
+!     public void trace(String s) {
+          System.out.println(s);
+      }
+  
+***************
+*** 276,282 ****
+       * Method declaration
+       *
+       */
+!     private static void printHelp() {
+  
+          System.out.println(
+              "Usage: java ScriptTool [-options]\n"
+--- 276,282 ----
+       * Method declaration
+       *
+       */
+!     public static void printHelp() {
+  
+          System.out.println(
+              "Usage: java ScriptTool [-options]\n"
+diff -crN misc/hsqldb/src/org/hsqldb/util/SqlFile.java misc/build/hsqldb/src/org/hsqldb/util/SqlFile.java
+*** misc/hsqldb/src/org/hsqldb/util/SqlFile.java	2005-11-06 23:06:20.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/util/SqlFile.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 110,135 ****
+   */
+  public class SqlFile {
+  
+!     private static final int DEFAULT_HISTORY_SIZE = 20;
+!     private File             file;
+!     private boolean          interactive;
+!     private String           primaryPrompt    = "sql> ";
+!     private String           chunkPrompt      = "raw> ";
+!     private String           contPrompt       = "  +> ";
+!     private Connection       curConn          = null;
+!     private boolean          htmlMode         = false;
+!     private HashMap          userVars         = null;
+!     private String[]         statementHistory = null;
+!     private boolean          chunking         = false;
+!     private String           csvNullRep       = null;
+  
+      /**
+       * Private class to "share" a variable among a family of SqlFile
+       * instances.
+       */
+!     private static class BooleanBucket {
+  
+!         private boolean bPriv = false;
+  
+          public void set(boolean bIn) {
+              bPriv = bIn;
+--- 110,135 ----
+   */
+  public class SqlFile {
+  
+!     public static final int DEFAULT_HISTORY_SIZE = 20;
+!     public File             file;
+!     public boolean          interactive;
+!     public String           primaryPrompt    = "sql> ";
+!     public String           chunkPrompt      = "raw> ";
+!     public String           contPrompt       = "  +> ";
+!     public Connection       curConn          = null;
+!     public boolean          htmlMode         = false;
+!     public HashMap          userVars         = null;
+!     public String[]         statementHistory = null;
+!     public boolean          chunking         = false;
+!     public String           csvNullRep       = null;
+  
+      /**
+       * Private class to "share" a variable among a family of SqlFile
+       * instances.
+       */
+!     public static class BooleanBucket {
+  
+!         public boolean bPriv = false;
+  
+          public void set(boolean bIn) {
+              bPriv = bIn;
+***************
+*** 146,166 ****
+      BooleanBucket possiblyUncommitteds = new BooleanBucket();
+  
+      // Ascii field separator blanks
+!     private static final int SEP_LEN = 2;
+!     private static final String DIVIDER =
+          "-----------------------------------------------------------------"
+          + "-----------------------------------------------------------------";
+!     private static final String SPACES =
+          "                                                                 "
+          + "                                                                 ";
+!     private static String revnum = null;
+  
+      static {
+          revnum = "$Revision: 1.130 $".substring("$Revision: ".length(),
+                  "$Revision: 1.130 $".length() - 2);
+      }
+  
+!     private static String BANNER =
+          "(SqlFile processor v. " + revnum + ")\n"
+          + "Distribution is permitted under the terms of the HSQLDB license.\n"
+          + "(c) 2004-2005 Blaine Simpson and the HSQLDB Development Group.\n\n"
+--- 146,166 ----
+      BooleanBucket possiblyUncommitteds = new BooleanBucket();
+  
+      // Ascii field separator blanks
+!     public static final int SEP_LEN = 2;
+!     public static final String DIVIDER =
+          "-----------------------------------------------------------------"
+          + "-----------------------------------------------------------------";
+!     public static final String SPACES =
+          "                                                                 "
+          + "                                                                 ";
+!     public static String revnum = null;
+  
+      static {
+          revnum = "$Revision: 1.130 $".substring("$Revision: ".length(),
+                  "$Revision: 1.130 $".length() - 2);
+      }
+  
+!     public static String BANNER =
+          "(SqlFile processor v. " + revnum + ")\n"
+          + "Distribution is permitted under the terms of the HSQLDB license.\n"
+          + "(c) 2004-2005 Blaine Simpson and the HSQLDB Development Group.\n\n"
+***************
+*** 176,182 ****
+          + "  statement into the buffer without executing) or a line ending with ';'\n"
+          + "  (which executes the statement).\n"
+          + "  SQL Statements may begin with '/PLVARNAME' and/or contain *{PLVARNAME}s.\n";
+!     private static final String BUFFER_HELP_TEXT =
+          "BUFFER Commands (only \":;\" is available for non-interactive use).\n"
+          + "    :?                Help\n"
+          + "    :;                Execute current buffer as an SQL Statement\n"
+--- 176,182 ----
+          + "  statement into the buffer without executing) or a line ending with ';'\n"
+          + "  (which executes the statement).\n"
+          + "  SQL Statements may begin with '/PLVARNAME' and/or contain *{PLVARNAME}s.\n";
+!     public static final String BUFFER_HELP_TEXT =
+          "BUFFER Commands (only \":;\" is available for non-interactive use).\n"
+          + "    :?                Help\n"
+          + "    :;                Execute current buffer as an SQL Statement\n"
+***************
+*** 198,204 ****
+          + "                       2:  Narrows substitution to specified buffer line number\n"
+          + "                           (Use any line number in place of '2').\n"
+      ;
+!     private static final String HELP_TEXT = "SPECIAL Commands.\n"
+          + "* commands only available for interactive use.\n"
+          + "In place of \"3\" below, you can use nothing for the previous command, or\n"
+          + "an integer \"X\" to indicate the Xth previous command.\n"
+--- 198,204 ----
+          + "                       2:  Narrows substitution to specified buffer line number\n"
+          + "                           (Use any line number in place of '2').\n"
+      ;
+!     public static final String HELP_TEXT = "SPECIAL Commands.\n"
+          + "* commands only available for interactive use.\n"
+          + "In place of \"3\" below, you can use nothing for the previous command, or\n"
+          + "an integer \"X\" to indicate the Xth previous command.\n"
+***************
+*** 226,232 ****
+          + "    \\m file/path.csv     iMport CSV text file records into a table\n"
+          + "    \\q [abort message]   Quit (or end input like Ctrl-Z or Ctrl-D)\n"
+      ;
+!     private static final String PL_HELP_TEXT = "PROCEDURAL LANGUAGE Commands.\n"
+          + "    *?                            Help\n"
+          + "    *                             Expand PL variables from now on.\n"
+          + "                                  (this is also implied by all the following).\n"
+--- 226,232 ----
+          + "    \\m file/path.csv     iMport CSV text file records into a table\n"
+          + "    \\q [abort message]   Quit (or end input like Ctrl-Z or Ctrl-D)\n"
+      ;
+!     public static final String PL_HELP_TEXT = "PROCEDURAL LANGUAGE Commands.\n"
+          + "    *?                            Help\n"
+          + "    *                             Expand PL variables from now on.\n"
+          + "                                  (this is also implied by all the following).\n"
+***************
+*** 328,349 ****
+  
+      // So we can tell how to handle quit and break commands.
+      public boolean      recursed     = false;
+!     private String      curCommand   = null;
+!     private int         curLinenum   = -1;
+!     private int         curHist      = -1;
+!     private PrintStream psStd        = null;
+!     private PrintStream psErr        = null;
+!     private PrintWriter pwQuery      = null;
+!     private PrintWriter pwCsv        = null;
+      StringBuffer        stringBuffer = new StringBuffer();
+      /*
+       * This is reset upon each execute() invocation (to true if interactive,
+       * false otherwise).
+       */
+!     private boolean             continueOnError = false;
+!     private static final String DEFAULT_CHARSET = "US-ASCII";
+!     private BufferedReader      br              = null;
+!     private String              charset         = null;
+  
+      /**
+       * Process all the commands in the file (or stdin) associated with
+--- 328,349 ----
+  
+      // So we can tell how to handle quit and break commands.
+      public boolean      recursed     = false;
+!     public String      curCommand   = null;
+!     public int         curLinenum   = -1;
+!     public int         curHist      = -1;
+!     public PrintStream psStd        = null;
+!     public PrintStream psErr        = null;
+!     public PrintWriter pwQuery      = null;
+!     public PrintWriter pwCsv        = null;
+      StringBuffer        stringBuffer = new StringBuffer();
+      /*
+       * This is reset upon each execute() invocation (to true if interactive,
+       * false otherwise).
+       */
+!     public boolean             continueOnError = false;
+!     public static final String DEFAULT_CHARSET = "US-ASCII";
+!     public BufferedReader      br              = null;
+!     public String              charset         = null;
+  
+      /**
+       * Process all the commands in the file (or stdin) associated with
+***************
+*** 736,742 ****
+       * @param inString Base String, which will not be modified (because
+       *                 a "copy" will be returned).
+       */
+!     private static String deTerminated(String inString) {
+  
+          int index = inString.lastIndexOf(';');
+  
+--- 736,742 ----
+       * @param inString Base String, which will not be modified (because
+       *                 a "copy" will be returned).
+       */
+!     public static String deTerminated(String inString) {
+  
+          int index = inString.lastIndexOf(';');
+  
+***************
+*** 756,768 ****
+      /**
+       * Utility nested Exception class for internal use.
+       */
+!     private class BadSpecial extends Exception {
+  
+          // Special-purpose constructor
+!         private BadSpecial() {}
+  
+          // Normal use constructor
+!         private BadSpecial(String s) {
+              super(s);
+          }
+      }
+--- 756,768 ----
+      /**
+       * Utility nested Exception class for internal use.
+       */
+!     public class BadSpecial extends Exception {
+  
+          // Special-purpose constructor
+!         public BadSpecial() {}
+  
+          // Normal use constructor
+!         public BadSpecial(String s) {
+              super(s);
+          }
+      }
+***************
+*** 775,781 ****
+       * thrown.
+       * SqlTool.execute() on throws a QuitNow if it is in a recursive call.
+       */
+!     private class QuitNow extends SqlToolError {
+  
+          public QuitNow(String s) {
+              super(s);
+--- 775,781 ----
+       * thrown.
+       * SqlTool.execute() on throws a QuitNow if it is in a recursive call.
+       */
+!     public class QuitNow extends SqlToolError {
+  
+          public QuitNow(String s) {
+              super(s);
+***************
+*** 790,796 ****
+       * Utility nested Exception class for internal use.
+       * Very similar to QuitNow.
+       */
+!     private class BreakException extends SqlToolError {
+  
+          public BreakException() {
+              super();
+--- 790,796 ----
+       * Utility nested Exception class for internal use.
+       * Very similar to QuitNow.
+       */
+!     public class BreakException extends SqlToolError {
+  
+          public BreakException() {
+              super();
+***************
+*** 805,811 ****
+       * Utility nested Exception class for internal use.
+       * Very similar to QuitNow.
+       */
+!     private class ContinueException extends SqlToolError {
+  
+          public ContinueException() {
+              super();
+--- 805,811 ----
+       * Utility nested Exception class for internal use.
+       * Very similar to QuitNow.
+       */
+!     public class ContinueException extends SqlToolError {
+  
+          public ContinueException() {
+              super();
+***************
+*** 819,827 ****
+      /**
+       * Utility nested Exception class for internal use.
+       */
+!     private class BadSwitch extends Exception {
+  
+!         private BadSwitch(int i) {
+              super(Integer.toString(i));
+          }
+      }
+--- 819,827 ----
+      /**
+       * Utility nested Exception class for internal use.
+       */
+!     public class BadSwitch extends Exception {
+  
+!         public BadSwitch(int i) {
+              super(Integer.toString(i));
+          }
+      }
+***************
+*** 836,842 ****
+       * @throws SQLException Passed through from processSQL()
+       * @throws BadSpecial Runtime error()
+       */
+!     private void processBuffer(String inString)
+      throws BadSpecial, SQLException {
+  
+          int    index = 0;
+--- 836,842 ----
+       * @throws SQLException Passed through from processSQL()
+       * @throws BadSpecial Runtime error()
+       */
+!     public void processBuffer(String inString)
+      throws BadSpecial, SQLException {
+  
+          int    index = 0;
+***************
+*** 1065,1075 ****
+          throw new BadSpecial("Unknown Buffer Command");
+      }
+  
+!     private boolean doPrepare   = false;
+!     private String  prepareVar  = null;
+!     private String  csvColDelim = null;
+!     private String  csvRowDelim = null;
+!     private static final String CSV_SYNTAX_MSG =
+          "Export syntax:  x table_or_view_anme "
+          + "[column_delimiter [record_delimiter]]";
+  
+--- 1065,1075 ----
+          throw new BadSpecial("Unknown Buffer Command");
+      }
+  
+!     public boolean doPrepare   = false;
+!     public String  prepareVar  = null;
+!     public String  csvColDelim = null;
+!     public String  csvRowDelim = null;
+!     public static final String CSV_SYNTAX_MSG =
+          "Export syntax:  x table_or_view_anme "
+          + "[column_delimiter [record_delimiter]]";
+  
+***************
+*** 1081,1087 ****
+       * @throws BadSpecial Runtime error()
+       * @throws QuitNot Command execution (but not the JVM!) should stop
+       */
+!     private void processSpecial(String inString)
+      throws BadSpecial, QuitNow, SQLException, SqlToolError {
+  
+          int    index = 0;
+--- 1081,1087 ----
+       * @throws BadSpecial Runtime error()
+       * @throws QuitNot Command execution (but not the JVM!) should stop
+       */
+!     public void processSpecial(String inString)
+      throws BadSpecial, QuitNow, SQLException, SqlToolError {
+  
+          int    index = 0;
+***************
+*** 1526,1532 ****
+          throw new BadSpecial("Unknown Special Command");
+      }
+  
+!     private static final char[] nonVarChars = {
+          ' ', '\t', '=', '}', '\n', '\r'
+      };
+  
+--- 1526,1532 ----
+          throw new BadSpecial("Unknown Special Command");
+      }
+  
+!     public static final char[] nonVarChars = {
+          ' ', '\t', '=', '}', '\n', '\r'
+      };
+  
+***************
+*** 1560,1566 ****
+       * @throws SQLException  This is really an inappropriate exception
+       * type.  Only using it because I don't have time to do things properly.
+       */
+!     private String dereference(String inString,
+                                 boolean permitAlias) throws SQLException {
+  
+          String       varName, varValue;
+--- 1560,1566 ----
+       * @throws SQLException  This is really an inappropriate exception
+       * type.  Only using it because I don't have time to do things properly.
+       */
+!     public String dereference(String inString,
+                                 boolean permitAlias) throws SQLException {
+  
+          String       varName, varValue;
+***************
+*** 1627,1635 ****
+      public boolean plMode = false;
+  
+      //  PL variable name currently awaiting query output.
+!     private String  fetchingVar = null;
+!     private boolean silentFetch = false;
+!     private boolean fetchBinary = false;
+  
+      /**
+       * Process a Process Language Command.
+--- 1627,1635 ----
+      public boolean plMode = false;
+  
+      //  PL variable name currently awaiting query output.
+!     public String  fetchingVar = null;
+!     public boolean silentFetch = false;
+!     public boolean fetchBinary = false;
+  
+      /**
+       * Process a Process Language Command.
+***************
+*** 1638,1644 ****
+       * @param inString Complete command, less the leading '\' character.
+       * @throws BadSpecial Runtime error()
+       */
+!     private void processPL(String inString)
+      throws BadSpecial, SqlToolError, SQLException {
+  
+          if (inString.length() < 1) {
+--- 1638,1644 ----
+       * @param inString Complete command, less the leading '\' character.
+       * @throws BadSpecial Runtime error()
+       */
+!     public void processPL(String inString)
+      throws BadSpecial, SqlToolError, SQLException {
+  
+          if (inString.length() < 1) {
+***************
+*** 2061,2067 ****
+       * new SqlFile.execute() with a mode whereby commands are written
+       * to a separate history but not executed.
+       */
+!     private File plBlockFile(String type) throws IOException, SqlToolError {
+  
+          String          s;
+          StringTokenizer toker;
+--- 2061,2067 ----
+       * new SqlFile.execute() with a mode whereby commands are written
+       * to a separate history but not executed.
+       */
+!     public File plBlockFile(String type) throws IOException, SqlToolError {
+  
+          String          s;
+          StringTokenizer toker;
+***************
+*** 2149,2163 ****
+      /**
+       * Wrapper methods so don't need to call x(..., false) in most cases.
+       */
+!     private void stdprintln() {
+          stdprintln(false);
+      }
+  
+!     private void stdprint(String s) {
+          stdprint(s, false);
+      }
+  
+!     private void stdprintln(String s) {
+          stdprintln(s, false);
+      }
+  
+--- 2149,2163 ----
+      /**
+       * Wrapper methods so don't need to call x(..., false) in most cases.
+       */
+!     public void stdprintln() {
+          stdprintln(false);
+      }
+  
+!     public void stdprint(String s) {
+          stdprint(s, false);
+      }
+  
+!     public void stdprintln(String s) {
+          stdprintln(s, false);
+      }
+  
+***************
+*** 2166,2172 ****
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     private void stdprintln(boolean queryOutput) {
+  
+          if (htmlMode) {
+              psStd.println("<BR>");
+--- 2166,2172 ----
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     public void stdprintln(boolean queryOutput) {
+  
+          if (htmlMode) {
+              psStd.println("<BR>");
+***************
+*** 2190,2196 ****
+       *
+       * Conditionally HTML-ifies error output.
+       */
+!     private void errprint(String s) {
+  
+          psErr.print(htmlMode
+                      ? ("<DIV style='color:white; background: red; "
+--- 2190,2196 ----
+       *
+       * Conditionally HTML-ifies error output.
+       */
+!     public void errprint(String s) {
+  
+          psErr.print(htmlMode
+                      ? ("<DIV style='color:white; background: red; "
+***************
+*** 2203,2209 ****
+       *
+       * Conditionally HTML-ifies error output.
+       */
+!     private void errprintln(String s) {
+  
+          psErr.println(htmlMode
+                        ? ("<DIV style='color:white; background: red; "
+--- 2203,2209 ----
+       *
+       * Conditionally HTML-ifies error output.
+       */
+!     public void errprintln(String s) {
+  
+          psErr.println(htmlMode
+                        ? ("<DIV style='color:white; background: red; "
+***************
+*** 2216,2222 ****
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     private void stdprint(String s, boolean queryOutput) {
+  
+          psStd.print(htmlMode ? ("<P>" + s + "</P>")
+                               : s);
+--- 2216,2222 ----
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     public void stdprint(String s, boolean queryOutput) {
+  
+          psStd.print(htmlMode ? ("<P>" + s + "</P>")
+                               : s);
+***************
+*** 2233,2239 ****
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     private void stdprintln(String s, boolean queryOutput) {
+  
+          psStd.println(htmlMode ? ("<P>" + s + "</P>")
+                                 : s);
+--- 2233,2239 ----
+       *
+       * Conditionally HTML-ifies output.
+       */
+!     public void stdprintln(String s, boolean queryOutput) {
+  
+          psStd.println(htmlMode ? ("<P>" + s + "</P>")
+                                 : s);
+***************
+*** 2248,2270 ****
+      // Just because users may be used to seeing "[null]" in normal
+      // SqlFile output, we use the same default value for null in CSV
+      // files, but this CSV null representation can be changed to anything.
+!     private static final String DEFAULT_NULL_REP = "[null]";
+!     private static final String DEFAULT_ROW_DELIM =
+          System.getProperty("line.separator");
+!     private static final String DEFAULT_COL_DELIM = "|";
+!     private static final int    DEFAULT_ELEMENT   = 0,
+                                  HSQLDB_ELEMENT    = 1,
+                                  ORACLE_ELEMENT    = 2
+      ;
+  
+      // These do not specify order listed, just inclusion.
+!     private static final int[] listMDSchemaCols = { 1 };
+!     private static final int[] listMDIndexCols  = {
+          2, 6, 3, 9, 4, 10, 11
+      };
+  
+      /** Column numbering starting at 1. */
+!     private static final int[][] listMDTableCols = {
+          {
+              2, 3
+          },    // Default
+--- 2248,2270 ----
+      // Just because users may be used to seeing "[null]" in normal
+      // SqlFile output, we use the same default value for null in CSV
+      // files, but this CSV null representation can be changed to anything.
+!     public static final String DEFAULT_NULL_REP = "[null]";
+!     public static final String DEFAULT_ROW_DELIM =
+          System.getProperty("line.separator");
+!     public static final String DEFAULT_COL_DELIM = "|";
+!     public static final int    DEFAULT_ELEMENT   = 0,
+                                  HSQLDB_ELEMENT    = 1,
+                                  ORACLE_ELEMENT    = 2
+      ;
+  
+      // These do not specify order listed, just inclusion.
+!     public static final int[] listMDSchemaCols = { 1 };
+!     public static final int[] listMDIndexCols  = {
+          2, 6, 3, 9, 4, 10, 11
+      };
+  
+      /** Column numbering starting at 1. */
+!     public static final int[][] listMDTableCols = {
+          {
+              2, 3
+          },    // Default
+***************
+*** 2297,2303 ****
+       * SCOTT, ADAMS, JONES, CLARK, BLAKE, OE, PM, SH, QS, QS_*, these
+       * contain sample data and the schemas can safely be removed.
+       */
+!     private static final String[] oracleSysSchemas = {
+          "SYS", "SYSTEM", "OUTLN", "DBSNMP", "OUTLN", "MDSYS", "ORDSYS",
+          "ORDPLUGINS", "CTXSYS", "DSSYS", "PERFSTAT", "WKPROXY", "WKSYS",
+          "WMSYS", "XDB", "ANONYMOUS", "ODM", "ODM_MTR", "OLAPSYS", "TRACESVR",
+--- 2297,2303 ----
+       * SCOTT, ADAMS, JONES, CLARK, BLAKE, OE, PM, SH, QS, QS_*, these
+       * contain sample data and the schemas can safely be removed.
+       */
+!     public static final String[] oracleSysSchemas = {
+          "SYS", "SYSTEM", "OUTLN", "DBSNMP", "OUTLN", "MDSYS", "ORDSYS",
+          "ORDPLUGINS", "CTXSYS", "DSSYS", "PERFSTAT", "WKPROXY", "WKSYS",
+          "WMSYS", "XDB", "ANONYMOUS", "ODM", "ODM_MTR", "OLAPSYS", "TRACESVR",
+***************
+*** 2313,2319 ****
+       *
+       * @throws BadSpecial
+       */
+!     private void listTables(char c, String inFilter) throws BadSpecial {
+  
+          String   schema  = null;
+          int[]    listSet = null;
+--- 2313,2319 ----
+       *
+       * @throws BadSpecial
+       */
+!     public void listTables(char c, String inFilter) throws BadSpecial {
+  
+          String   schema  = null;
+          int[]    listSet = null;
+***************
+*** 2632,2643 ****
+          }
+      }
+  
+!     private boolean excludeSysSchemas = false;
+  
+      /**
+       * Process the current command as an SQL Statement
+       */
+!     private void processSQL() throws SQLException {
+  
+          // Really don't know whether to take the network latency hit here
+          // in order to check autoCommit in order to set
+--- 2632,2643 ----
+          }
+      }
+  
+!     public boolean excludeSysSchemas = false;
+  
+      /**
+       * Process the current command as an SQL Statement
+       */
+!     public void processSQL() throws SQLException {
+  
+          // Really don't know whether to take the network latency hit here
+          // in order to check autoCommit in order to set
+***************
+*** 2715,2721 ****
+       * @param incFilter Optional case-insensitive substring.
+       *                  Rows are skipped which to not contain this substring.
+       */
+!     private void displayResultSet(Statement statement, ResultSet r,
+                                    int[] incCols,
+                                    String filter) throws SQLException {
+  
+--- 2715,2721 ----
+       * @param incFilter Optional case-insensitive substring.
+       *                  Rows are skipped which to not contain this substring.
+       */
+!     public void displayResultSet(Statement statement, ResultSet r,
+                                    int[] incCols,
+                                    String filter) throws SQLException {
+  
+***************
+*** 3084,3095 ****
+          }
+      }
+  
+!     private static final int    COL_HEAD = 0,
+                                  COL_ODD  = 1,
+                                  COL_EVEN = 2
+      ;
+!     private static final String PRE_TR   = spaces(4);
+!     private static final String PRE_TD   = spaces(8);
+  
+      /**
+       * Print a properly formatted HTML &lt;TR&gt; command for the given
+--- 3084,3095 ----
+          }
+      }
+  
+!     public static final int    COL_HEAD = 0,
+                                  COL_ODD  = 1,
+                                  COL_EVEN = 2
+      ;
+!     public static final String PRE_TR   = spaces(4);
+!     public static final String PRE_TD   = spaces(8);
+  
+      /**
+       * Print a properly formatted HTML &lt;TR&gt; command for the given
+***************
+*** 3097,3103 ****
+       *
+       * @param colType Column type:  COL_HEAD, COL_ODD or COL_EVEN.
+       */
+!     private static String htmlRow(int colType) {
+  
+          switch (colType) {
+  
+--- 3097,3103 ----
+       *
+       * @param colType Column type:  COL_HEAD, COL_ODD or COL_EVEN.
+       */
+!     public static String htmlRow(int colType) {
+  
+          switch (colType) {
+  
+***************
+*** 3123,3129 ****
+       *
+       * @param len Length of output String.
+       */
+!     private static String divider(int len) {
+          return (len > DIVIDER.length()) ? DIVIDER
+                                          : DIVIDER.substring(0, len);
+      }
+--- 3123,3129 ----
+       *
+       * @param len Length of output String.
+       */
+!     public static String divider(int len) {
+          return (len > DIVIDER.length()) ? DIVIDER
+                                          : DIVIDER.substring(0, len);
+      }
+***************
+*** 3133,3139 ****
+       *
+       * @param len Length of output String.
+       */
+!     private static String spaces(int len) {
+          return (len > SPACES.length()) ? SPACES
+                                         : SPACES.substring(0, len);
+      }
+--- 3133,3139 ----
+       *
+       * @param len Length of output String.
+       */
+!     public static String spaces(int len) {
+          return (len > SPACES.length()) ? SPACES
+                                         : SPACES.substring(0, len);
+      }
+***************
+*** 3146,3152 ****
+       * @param fulllen  Output String length.
+       * @param rightJustify  True to right justify, false to left justify.
+       */
+!     private static String pad(String inString, int fulllen,
+                                boolean rightJustify, boolean doPad) {
+  
+          if (!doPad) {
+--- 3146,3152 ----
+       * @param fulllen  Output String length.
+       * @param rightJustify  True to right justify, false to left justify.
+       */
+!     public static String pad(String inString, int fulllen,
+                                boolean rightJustify, boolean doPad) {
+  
+          if (!doPad) {
+***************
+*** 3170,3176 ****
+       * Display command history, which consists of complete or incomplete SQL
+       * commands.
+       */
+!     private void showHistory() {
+  
+          int      ctr = -1;
+          String   s;
+--- 3170,3176 ----
+       * Display command history, which consists of complete or incomplete SQL
+       * commands.
+       */
+!     public void showHistory() {
+  
+          int      ctr = -1;
+          String   s;
+***************
+*** 3218,3224 ****
+      /**
+       * Return a SQL Command from command history.
+       */
+!     private String commandFromHistory(int commandsAgo) throws BadSpecial {
+  
+          if (commandsAgo >= statementHistory.length) {
+              throw new BadSpecial("History can only hold up to "
+--- 3218,3224 ----
+      /**
+       * Return a SQL Command from command history.
+       */
+!     public String commandFromHistory(int commandsAgo) throws BadSpecial {
+  
+          if (commandsAgo >= statementHistory.length) {
+              throw new BadSpecial("History can only hold up to "
+***************
+*** 3239,3245 ****
+       * Push a command onto the history array (the first element of which
+       * is the "Buffer").
+       */
+!     private void setBuf(String inString) {
+  
+          curHist++;
+  
+--- 3239,3245 ----
+       * Push a command onto the history array (the first element of which
+       * is the "Buffer").
+       */
+!     public void setBuf(String inString) {
+  
+          curHist++;
+  
+***************
+*** 3256,3262 ****
+       * @param tableName  Table that will be described.
+       * @param filter  Substring to filter by
+       */
+!     private void describe(String tableName,
+                            String inFilter) throws SQLException {
+  
+          /*
+--- 3256,3262 ----
+       * @param tableName  Table that will be described.
+       * @param filter  Substring to filter by
+       */
+!     public void describe(String tableName,
+                            String inFilter) throws SQLException {
+  
+          /*
+***************
+*** 3405,3411 ****
+          return sa;
+      }
+  
+!     private boolean eval(String[] inTokens) throws BadSpecial {
+  
+          // dereference *VARNAME variables.
+          // N.b. we work with a "copy" of the tokens.
+--- 3405,3411 ----
+          return sa;
+      }
+  
+!     public boolean eval(String[] inTokens) throws BadSpecial {
+  
+          // dereference *VARNAME variables.
+          // N.b. we work with a "copy" of the tokens.
+***************
+*** 3458,3464 ****
+          throw new BadSpecial("Unrecognized logical operation");
+      }
+  
+!     private void closeQueryOutputStream() {
+  
+          if (pwQuery == null) {
+              return;
+--- 3458,3464 ----
+          throw new BadSpecial("Unrecognized logical operation");
+      }
+  
+!     public void closeQueryOutputStream() {
+  
+          if (pwQuery == null) {
+              return;
 ***************
-*** 660,665 ****
---- 663,685 ----
+*** 3478,3484 ****
+       * Print to psStd and possibly pwQuery iff current HTML mode matches
+       * supplied printHtml.
+       */
+!     private void condlPrintln(String s, boolean printHtml) {
+  
+          if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {
+              return;
+--- 3478,3484 ----
+       * Print to psStd and possibly pwQuery iff current HTML mode matches
+       * supplied printHtml.
+       */
+!     public void condlPrintln(String s, boolean printHtml) {
+  
+          if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {
+              return;
+***************
+*** 3496,3502 ****
+       * Print to psStd and possibly pwQuery iff current HTML mode matches
+       * supplied printHtml.
+       */
+!     private void condlPrint(String s, boolean printHtml) {
+  
+          if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {
+              return;
+--- 3496,3502 ----
+       * Print to psStd and possibly pwQuery iff current HTML mode matches
+       * supplied printHtml.
+       */
+!     public void condlPrint(String s, boolean printHtml) {
+  
+          if ((printHtml &&!htmlMode) || (htmlMode &&!printHtml)) {
+              return;
+***************
+*** 3510,3516 ****
+          }
       }
   
+!     private static String formatNicely(Map map, boolean withValues) {
+  
+          String       key;
+          StringBuffer sb = new StringBuffer();
+--- 3510,3516 ----
+          }
+      }
+  
+!     public static String formatNicely(Map map, boolean withValues) {
+  
+          String       key;
+          StringBuffer sb = new StringBuffer();
+***************
+*** 3540,3546 ****
       /**
-+      *     Throws exception if condition is false
-+      *
-+      *     @param condition
-+      *     @param code
-+      *     @param add
-+      *
-+      * @throws HsqlException
-+      */
-+     public static void check(boolean condition, int code,
-+                              final Object[] add) throws HsqlException {
-+ 
-+         if (!condition) {
-+             throw error(code, add);
-+         }
-+     }
-+ 
-+     /**
-       * Method declaration
-       *
-       *
-*** misc/hsqldb/src/org/hsqldb/TransactionManager.java	Thu Oct 27 21:40:18 2005
---- misc/build/hsqldb/src/org/hsqldb/TransactionManager.java	Tue May 30 16:22:33 2006
+       * Ascii file dump.
+       */
+!     private void dump(String varName,
+                        File dumpFile) throws IOException, BadSpecial {
+  
+          String val = (String) userVars.get(varName);
+--- 3540,3546 ----
+      /**
+       * Ascii file dump.
+       */
+!     public void dump(String varName,
+                        File dumpFile) throws IOException, BadSpecial {
+  
+          String val = (String) userVars.get(varName);
 ***************
-*** 102,109 ****
+*** 3581,3587 ****
+      /**
+       * Binary file dump
+       */
+!     private void dump(File dumpFile) throws IOException, BadSpecial {
   
-      void commit(Session session) {
+          if (binBuffer == null) {
+              throw new BadSpecial("Binary SqlFile buffer is currently empty");
+--- 3581,3587 ----
+      /**
+       * Binary file dump
+       */
+!     public void dump(File dumpFile) throws IOException, BadSpecial {
   
-!         Object[] list = session.transactionList.getArray();
-!         int      size = session.transactionList.size();
+          if (binBuffer == null) {
+              throw new BadSpecial("Binary SqlFile buffer is currently empty");
+***************
+*** 3600,3606 ****
+          stdprintln("Saved " + len + " bytes to '" + dumpFile + "'");
+      }
   
-          for (int i = 0; i < size; i++) {
-              Transaction tx    = (Transaction) list[i];
---- 102,109 ----
+!     private String streamToString(InputStream is) throws IOException {
   
-      void commit(Session session) {
+          char[]            xferBuffer   = new char[10240];
+          StringWriter      stringWriter = new StringWriter();
+--- 3600,3606 ----
+          stdprintln("Saved " + len + " bytes to '" + dumpFile + "'");
+      }
   
-!         Object[] list = session.rowActionList.getArray();
-!         int      size = session.rowActionList.size();
+!     public String streamToString(InputStream is) throws IOException {
   
-          for (int i = 0; i < size; i++) {
-              Transaction tx    = (Transaction) list[i];
+          char[]            xferBuffer   = new char[10240];
+          StringWriter      stringWriter = new StringWriter();
 ***************
-*** 113,119 ****
-              rowSessionMap.remove(rowid);
-          }
+*** 3614,3620 ****
+          return stringWriter.toString();
+      }
   
-!         session.transactionList.clear();
-          session.savepoints.clear();
+!     private byte[] streamToBytes(InputStream is) throws IOException {
+  
+          byte[]                xferBuffer = new byte[10240];
+          ByteArrayOutputStream baos       = new ByteArrayOutputStream();
+--- 3614,3620 ----
+          return stringWriter.toString();
       }
   
---- 113,119 ----
-              rowSessionMap.remove(rowid);
-          }
+!     public byte[] streamToBytes(InputStream is) throws IOException {
   
-!         session.rowActionList.clear();
-          session.savepoints.clear();
+          byte[]                xferBuffer = new byte[10240];
+          ByteArrayOutputStream baos       = new ByteArrayOutputStream();
+***************
+*** 3630,3636 ****
+      /**
+       * Ascii file load.
+       */
+!     private void load(String varName, File asciiFile) throws IOException {
+  
+          char[]       xferBuffer   = new char[10240];
+          StringWriter stringWriter = new StringWriter();
+--- 3630,3636 ----
+      /**
+       * Ascii file load.
+       */
+!     public void load(String varName, File asciiFile) throws IOException {
+  
+          char[]       xferBuffer   = new char[10240];
+          StringWriter stringWriter = new StringWriter();
+***************
+*** 3649,3655 ****
+      /**
+       * Binary file load
+       */
+!     private void load(File binFile) throws IOException {
+  
+          byte[]                xferBuffer = new byte[10240];
+          ByteArrayOutputStream baos       = new ByteArrayOutputStream();
+--- 3649,3655 ----
+      /**
+       * Binary file load
+       */
+!     public void load(File binFile) throws IOException {
+  
+          byte[]                xferBuffer = new byte[10240];
+          ByteArrayOutputStream baos       = new ByteArrayOutputStream();
+***************
+*** 3709,3716 ****
+      }
+  
+      // won't compile with JDK 1.3 without these
+!     private static final int JDBC3_BOOLEAN  = 16;
+!     private static final int JDBC3_DATALINK = 70;
+  
+      public static String sqlTypeToString(int i) {
+  
+--- 3709,3716 ----
       }
   
+      // won't compile with JDK 1.3 without these
+!     public static final int JDBC3_BOOLEAN  = 16;
+!     public static final int JDBC3_DATALINK = 70;
+  
+      public static String sqlTypeToString(int i) {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/util/SqlServerTransferHelper.java misc/build/hsqldb/src/org/hsqldb/util/SqlServerTransferHelper.java
+*** misc/hsqldb/src/org/hsqldb/util/SqlServerTransferHelper.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/SqlServerTransferHelper.java	2006-11-03 20:08:10.000000000 +0100
 ***************
-*** 143,155 ****
+*** 42,49 ****
+   */
+  class SqlServerTransferHelper extends TransferHelper {
   
-      void rollbackTransactions(Session session, int limit, boolean log) {
+!     private boolean firstTinyintRow;
+!     private boolean firstSmallintRow;
   
-!         Object[] list = session.transactionList.getArray();
-!         int      size = session.transactionList.size();
+      SqlServerTransferHelper() {
+          super();
+--- 42,49 ----
+   */
+  class SqlServerTransferHelper extends TransferHelper {
   
-          for (int i = size - 1; i >= limit; i--) {
-              Transaction tx = (Transaction) list[i];
+!     public boolean firstTinyintRow;
+!     public boolean firstSmallintRow;
   
-!             tx.rollback(session, false);
-          }
+      SqlServerTransferHelper() {
+          super();
+diff -crN misc/hsqldb/src/org/hsqldb/util/SqlTool.java misc/build/hsqldb/src/org/hsqldb/util/SqlTool.java
+*** misc/hsqldb/src/org/hsqldb/util/SqlTool.java	2005-10-23 19:25:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/SqlTool.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 55,67 ****
+   */
+  public class SqlTool {
   
-          for (int i = limit; i < size; i++) {
---- 143,155 ----
+!     private static final String DEFAULT_RCFILE =
+          System.getProperty("user.home") + "/sqltool.rc";
+!     private static Connection conn;
+  
+      // N.b. the following is static!
+!     private static boolean noexit;    // Whether System.exit() may be called.
+!     private static String  revnum = null;
+  
+      static {
+          revnum = "$Revision: 1.50 $".substring("$Revision: ".length(),
+--- 55,67 ----
+   */
+  public class SqlTool {
   
-      void rollbackTransactions(Session session, int limit, boolean log) {
+!     public static final String DEFAULT_RCFILE =
+          System.getProperty("user.home") + "/sqltool.rc";
+!     public static Connection conn;
   
-!         Object[] list = session.rowActionList.getArray();
-!         int      size = session.rowActionList.size();
+      // N.b. the following is static!
+!     public static boolean noexit;    // Whether System.exit() may be called.
+!     public static String  revnum = null;
   
-          for (int i = size - 1; i >= limit; i--) {
-              Transaction tx = (Transaction) list[i];
+      static {
+          revnum = "$Revision: 1.50 $".substring("$Revision: ".length(),
+***************
+*** 69,75 ****
+                                                 - 2);
+      }
   
-!             tx.rollback(session, log);
-          }
+!     private static final String SYNTAX_MESSAGE =
+          "Usage: java [-Dsqlfile.X=Y...] org.hsqldb.util.SqlTool \\\n"
+          + "    [--optname [optval...]] urlid [file1.sql...]\n"
+          + "where arguments are:\n"
+--- 69,75 ----
+                                                 - 2);
+      }
+  
+!     public static final String SYNTAX_MESSAGE =
+          "Usage: java [-Dsqlfile.X=Y...] org.hsqldb.util.SqlTool \\\n"
+          + "    [--optname [optval...]] urlid [file1.sql...]\n"
+          + "where arguments are:\n"
+***************
+*** 98,108 ****
+          + "SqlTool v. " + revnum + ".";
+  
+      /** Utility nested class for internal use. */
+!     private static class BadCmdline extends Exception {}
+      ;
+  
+      /** Utility object for internal use. */
+!     private static BadCmdline bcl = new BadCmdline();
+  
+      /** Nested class for external callers of SqlTool.main() */
+      public static class SqlToolException extends Exception {
+--- 98,108 ----
+          + "SqlTool v. " + revnum + ".";
+  
+      /** Utility nested class for internal use. */
+!     public static class BadCmdline extends Exception {}
+      ;
+  
+      /** Utility object for internal use. */
+!     public static BadCmdline bcl = new BadCmdline();
+  
+      /** Nested class for external callers of SqlTool.main() */
+      public static class SqlToolException extends Exception {
+***************
+*** 122,128 ****
+       * Call return() right after you call this method, because this method
+       * will not exit if (noexit is true && retval == 0).
+       */
+!     private static void exitMain(int retval) throws SqlToolException {
+          exitMain(retval, null);
+      }
+  
+--- 122,128 ----
+       * Call return() right after you call this method, because this method
+       * will not exit if (noexit is true && retval == 0).
+       */
+!     public static void exitMain(int retval) throws SqlToolException {
+          exitMain(retval, null);
+      }
   
-          for (int i = limit; i < size; i++) {
 ***************
-*** 159,165 ****
-              rowSessionMap.remove(rowid);
+*** 132,138 ****
+       * Call return() right after you call this method, because this method
+       * will not exit if (noexit is true && retval == 0).
+       */
+!     private static void exitMain(int retval,
+                                   String msg) throws SqlToolException {
+  
+          if (noexit) {
+--- 132,138 ----
+       * Call return() right after you call this method, because this method
+       * will not exit if (noexit is true && retval == 0).
+       */
+!     public static void exitMain(int retval,
+                                   String msg) throws SqlToolException {
+  
+          if (noexit) {
+diff -crN misc/hsqldb/src/org/hsqldb/util/SqlToolSprayer.java misc/build/hsqldb/src/org/hsqldb/util/SqlToolSprayer.java
+*** misc/hsqldb/src/org/hsqldb/util/SqlToolSprayer.java	2005-10-23 19:25:14.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/SqlToolSprayer.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 59,65 ****
+   */
+  public class SqlToolSprayer {
+  
+!     private static final String SYNTAX_MSG =
+          "SYNTAX:  java [-D...] SqlToolSprayer 'SQL;' [urlid1 urlid2...]\n"
+          + "System properties you may use [default values]:\n"
+          + "    sqltoolsprayer.period (in ms.) [500]\n"
+--- 59,65 ----
+   */
+  public class SqlToolSprayer {
+  
+!     public static final String SYNTAX_MSG =
+          "SYNTAX:  java [-D...] SqlToolSprayer 'SQL;' [urlid1 urlid2...]\n"
+          + "System properties you may use [default values]:\n"
+          + "    sqltoolsprayer.period (in ms.) [500]\n"
+***************
+*** 184,190 ****
+          System.exit(0);
+      }
+  
+!     private static void getUrlsFromPropFile(String fileName,
+              ArrayList al) throws Exception {
+  
+          Properties p = new Properties();
+--- 184,190 ----
+          System.exit(0);
+      }
+  
+!     public static void getUrlsFromPropFile(String fileName,
+              ArrayList al) throws Exception {
+  
+          Properties p = new Properties();
+diff -crN misc/hsqldb/src/org/hsqldb/util/TableSorter.java misc/build/hsqldb/src/org/hsqldb/util/TableSorter.java
+*** misc/hsqldb/src/org/hsqldb/util/TableSorter.java	2004-11-24 21:50:56.000000000 +0100
+--- misc/build/hsqldb/src/org/hsqldb/util/TableSorter.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 78,88 ****
+   */
+  public class TableSorter extends AbstractTableModel {
+  
+!     protected TableModel           tableModel;
+      public static final int        DESCENDING            = -1;
+      public static final int        NOT_SORTED            = 0;
+      public static final int        ASCENDING             = 1;
+!     private static Directive EMPTY_DIRECTIVE = new Directive(-1, NOT_SORTED);
+      public static final Comparator COMPARABLE_COMPARATOR = new Comparator() {
+  
+          public int compare(Object o1, Object o2) {
+--- 78,88 ----
+   */
+  public class TableSorter extends AbstractTableModel {
+  
+!     public TableModel           tableModel;
+      public static final int        DESCENDING            = -1;
+      public static final int        NOT_SORTED            = 0;
+      public static final int        ASCENDING             = 1;
+!     public static Directive EMPTY_DIRECTIVE = new Directive(-1, NOT_SORTED);
+      public static final Comparator COMPARABLE_COMPARATOR = new Comparator() {
+  
+          public int compare(Object o1, Object o2) {
+***************
+*** 112,124 ****
+              return o1.toString().compareTo(o2.toString());
+          }
+      };
+!     private Row[]              viewToModel;
+!     private int[]              modelToView;
+!     private JTableHeader       tableHeader;
+!     private MouseListener      mouseListener;
+!     private TableModelListener tableModelListener;
+!     private Map                columnComparators = new HashMap();
+!     private List               sortingColumns    = new ArrayList();
+  
+      public TableSorter() {
+          this.mouseListener      = new MouseHandler();
+--- 112,124 ----
+              return o1.toString().compareTo(o2.toString());
           }
+      };
+!     public Row[]              viewToModel;
+!     public int[]              modelToView;
+!     public JTableHeader       tableHeader;
+!     public MouseListener      mouseListener;
+!     public TableModelListener tableModelListener;
+!     public Map                columnComparators = new HashMap();
+!     public List               sortingColumns    = new ArrayList();
   
-!         session.transactionList.setSize(limit);
+      public TableSorter() {
+          this.mouseListener      = new MouseHandler();
+***************
+*** 140,146 ****
+          setTableModel(tableModel);
       }
   
-      void addTransaction(Session session, Transaction transaction) {
---- 159,165 ----
-              rowSessionMap.remove(rowid);
+!     private void clearSortingState() {
+          viewToModel = null;
+          modelToView = null;
+      }
+--- 140,146 ----
+          setTableModel(tableModel);
+      }
+  
+!     public void clearSortingState() {
+          viewToModel = null;
+          modelToView = null;
+      }
+***************
+*** 198,204 ****
+          return sortingColumns.size() != 0;
+      }
+  
+!     private Directive getDirective(int column) {
+  
+          for (int i = 0; i < sortingColumns.size(); i++) {
+              Directive directive = (Directive) sortingColumns.get(i);
+--- 198,204 ----
+          return sortingColumns.size() != 0;
+      }
+  
+!     public Directive getDirective(int column) {
+  
+          for (int i = 0; i < sortingColumns.size(); i++) {
+              Directive directive = (Directive) sortingColumns.get(i);
+***************
+*** 215,221 ****
+          return getDirective(column).direction;
+      }
+  
+!     private void sortingStatusChanged() {
+  
+          clearSortingState();
+          fireTableDataChanged();
+--- 215,221 ----
+          return getDirective(column).direction;
+      }
+  
+!     public void sortingStatusChanged() {
+  
+          clearSortingState();
+          fireTableDataChanged();
+***************
+*** 240,246 ****
+          sortingStatusChanged();
+      }
+  
+!     protected Icon getHeaderRendererIcon(int column, int size) {
+  
+          Directive directive = getDirective(column);
+  
+--- 240,246 ----
+          sortingStatusChanged();
+      }
+  
+!     public Icon getHeaderRendererIcon(int column, int size) {
+  
+          Directive directive = getDirective(column);
+  
+***************
+*** 252,258 ****
+                           sortingColumns.indexOf(directive));
+      }
+  
+!     private void cancelSorting() {
+          sortingColumns.clear();
+          sortingStatusChanged();
+      }
+--- 252,258 ----
+                           sortingColumns.indexOf(directive));
+      }
+  
+!     public void cancelSorting() {
+          sortingColumns.clear();
+          sortingStatusChanged();
+      }
+***************
+*** 266,272 ****
           }
+      }
   
-!         session.rowActionList.setSize(limit);
+!     protected Comparator getComparator(int column) {
+  
+          Class columnType = tableModel.getColumnClass(column);
+          Comparator comparator =
+--- 266,272 ----
+          }
       }
   
-      void addTransaction(Session session, Transaction transaction) {
+!     public Comparator getComparator(int column) {
+  
+          Class columnType = tableModel.getColumnClass(column);
+          Comparator comparator =
 ***************
-*** 212,218 ****
+*** 283,289 ****
+          return LEXICAL_COMPARATOR;
+      }
   
-                  if (tIndex[i] < tSize) {
-                      Transaction current =
-!                         (Transaction) sessions[i].transactionList.get(
-                              tIndex[i]);
+!     private Row[] getViewToModel() {
   
-                      if (current.SCN < minChangeNo) {
---- 212,218 ----
+          if (viewToModel == null) {
+              int tableModelRowCount = tableModel.getRowCount();
+--- 283,289 ----
+          return LEXICAL_COMPARATOR;
+      }
   
-                  if (tIndex[i] < tSize) {
-                      Transaction current =
-!                         (Transaction) sessions[i].rowActionList.get(
-                              tIndex[i]);
+!     public Row[] getViewToModel() {
+  
+          if (viewToModel == null) {
+              int tableModelRowCount = tableModel.getRowCount();
+***************
+*** 306,312 ****
+          return getViewToModel()[viewIndex].modelIndex;
+      }
+  
+!     private int[] getModelToView() {
+  
+          if (modelToView == null) {
+              int n = getViewToModel().length;
+--- 306,312 ----
+          return getViewToModel()[viewIndex].modelIndex;
+      }
+  
+!     public int[] getModelToView() {
+  
+          if (modelToView == null) {
+              int n = getViewToModel().length;
+***************
+*** 353,361 ****
+      }
+  
+      // Helper classes
+!     private class Row implements Comparable {
+  
+!         private int modelIndex;
+  
+          public Row(int index) {
+              this.modelIndex = index;
+--- 353,361 ----
+      }
+  
+      // Helper classes
+!     public class Row implements Comparable {
+  
+!         public int modelIndex;
+  
+          public Row(int index) {
+              this.modelIndex = index;
+***************
+*** 394,400 ****
+          }
+      }
+  
+!     private class TableModelHandler implements TableModelListener {
+  
+          public void tableChanged(TableModelEvent e) {
+  
+--- 394,400 ----
+          }
+      }
+  
+!     public class TableModelHandler implements TableModelListener {
+  
+          public void tableChanged(TableModelEvent e) {
   
-                      if (current.SCN < minChangeNo) {
 ***************
-*** 228,235 ****
-                  break;
-              }
+*** 457,463 ****
+          }
+      }
   
-!             HsqlArrayList currentList =
-!                 sessions[sessionIndex].transactionList;
+!     private class MouseHandler extends MouseAdapter {
   
-              for (; tIndex[sessionIndex] < currentList.size(); ) {
-                  Transaction current =
---- 228,234 ----
-                  break;
-              }
+          public void mouseClicked(MouseEvent e) {
   
-!             HsqlArrayList currentList = sessions[sessionIndex].rowActionList;
+--- 457,463 ----
+          }
+      }
+  
+!     public class MouseHandler extends MouseAdapter {
+  
+          public void mouseClicked(MouseEvent e) {
   
-              for (; tIndex[sessionIndex] < currentList.size(); ) {
-                  Transaction current =
 ***************
-*** 264,270 ****
-          lookup.setKeysSearchTarget();
+*** 484,494 ****
+          }
+      }
   
-          for (int i = 0; i < sessions.length; i++) {
-!             HsqlArrayList tlist = sessions[i].transactionList;
+!     private static class Arrow implements Icon {
   
-              for (int j = 0, size = tlist.size(); j < size; j++) {
-                  Transaction tx = (Transaction) tlist.get(j);
---- 263,269 ----
-          lookup.setKeysSearchTarget();
+!         private boolean descending;
+!         private int     size;
+!         private int     priority;
   
-          for (int i = 0; i < sessions.length; i++) {
-!             HsqlArrayList tlist = sessions[i].rowActionList;
+          public Arrow(boolean descending, int size, int priority) {
   
-              for (int j = 0, size = tlist.size(); j < size; j++) {
-                  Transaction tx = (Transaction) tlist.get(j);
-***************
-*** 286,292 ****
-          Session[] sessions = database.sessionManager.getAllSessions();
+--- 484,494 ----
+          }
+      }
   
-          for (int i = 0; i < sessions.length; i++) {
-!             HsqlArrayList tlist = sessions[i].transactionList;
+!     public static class Arrow implements Icon {
   
-              for (int j = 0, size = tlist.size(); j < size; j++) {
-                  Transaction tx = (Transaction) tlist.get(j);
---- 285,291 ----
-          Session[] sessions = database.sessionManager.getAllSessions();
+!         public boolean descending;
+!         public int     size;
+!         public int     priority;
   
-          for (int i = 0; i < sessions.length; i++) {
-!             HsqlArrayList tlist = sessions[i].rowActionList;
+          public Arrow(boolean descending, int size, int priority) {
   
-              for (int j = 0, size = tlist.size(); j < size; j++) {
-                  Transaction tx = (Transaction) tlist.get(j);
-*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcConnection.java	Sun Nov  6 23:05:18 2005
---- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcConnection.java	Fri Jun  9 16:26:49 2006
 ***************
-*** 755,794 ****
-                      } else if (c == '"') {
-                          state = outside_escape_inside_double_quotes;
-                      } else if (c == '{') {
--                         sb.setCharAt(i++, ' ');
+*** 548,556 ****
+          }
+      }
   
-!                         i = StringUtil.skipSpaces(sql, i);
-! 
-!                         if (sql.regionMatches(true, i, "fn ", 0, 3)
-!                                 || sql.regionMatches(true, i, "oj ", 0, 3)
-!                                 || sql.regionMatches(true, i, "ts ", 0, 3)) {
-!                             sb.setCharAt(i++, ' ');
-!                             sb.setCharAt(i++, ' ');
-!                         } else if (sql.regionMatches(true, i, "d ", 0, 2)
-!                                    || sql.regionMatches(true, i, "t ", 0,
-!                                                         2)) {
-!                             sb.setCharAt(i++, ' ');
-!                         } else if (sql.regionMatches(true, i, "call ", 0,
-!                                                      5)) {
-!                             i += 4;
-!                         } else if (sql.regionMatches(true, i, "?= call ", 0,
-!                                                      8)) {
-!                             sb.setCharAt(i++, ' ');
-!                             sb.setCharAt(i++, ' ');
-! 
-!                             i += 5;
-!                         } else if (sql.regionMatches(true, i, "escape ", 0,
-!                                                      7)) {
-!                             i += 6;
-!                         } else {
-!                             i--;
-! 
-!                             throw new SQLException(Trace
-!                                 .getMessage(Trace
-!                                     .jdbcConnection_nativeSQL, true, new Object[]{ sql
-!                                         .substring(i) }), "S0010", Trace
-!                                             .INVALID_JDBC_ARGUMENT);
-!                         }
+!     private class SortableHeaderRenderer implements TableCellRenderer {
   
-                          // changed = true;
-                          nest++;
---- 755,762 ----
-                      } else if (c == '"') {
-                          state = outside_escape_inside_double_quotes;
-                      } else if (c == '{') {
+!         private TableCellRenderer tableCellRenderer;
   
-!                         i = onStartEscapeSequence(sql, sb, i);
+          public SortableHeaderRenderer(TableCellRenderer tableCellRenderer) {
+              this.tableCellRenderer = tableCellRenderer;
+--- 548,556 ----
+          }
+      }
   
-                          // changed = true;
-                          nest++;
+!     public class SortableHeaderRenderer implements TableCellRenderer {
+  
+!         public TableCellRenderer tableCellRenderer;
+  
+          public SortableHeaderRenderer(TableCellRenderer tableCellRenderer) {
+              this.tableCellRenderer = tableCellRenderer;
 ***************
-*** 825,862 ****
-                          state = (nest == 0) ? outside_all
-                                              : inside_escape;
-                      } else if (c == '{') {
--                         sb.setCharAt(i++, ' ');
+*** 579,588 ****
+          }
+      }
   
-!                         if (sql.regionMatches(true, i, "fn ", 0, 3)
-!                                 || sql.regionMatches(true, i, "oj ", 0, 3)
-!                                 || sql.regionMatches(true, i, "ts ", 0, 3)) {
-!                             sb.setCharAt(i++, ' ');
-!                             sb.setCharAt(i++, ' ');
-!                         } else if (sql.regionMatches(true, i, "d ", 0, 2)
-!                                    || sql.regionMatches(true, i, "t ", 0,
-!                                                         2)) {
-!                             sb.setCharAt(i++, ' ');
-!                         } else if (sql.regionMatches(true, i, "call ", 0,
-!                                                      5)) {
-!                             i += 4;
-!                         } else if (sql.regionMatches(true, i, "?= call ", 0,
-!                                                      8)) {
-!                             sb.setCharAt(i++, ' ');
-!                             sb.setCharAt(i++, ' ');
-! 
-!                             i += 5;
-!                         } else if (sql.regionMatches(true, i, "escape ", 0,
-!                                                      7)) {
-!                             i += 6;
-!                         } else {
-!                             i--;
-! 
-!                             throw new SQLException(Trace
-!                                 .getMessage(Trace
-!                                     .jdbcConnection_nativeSQL, true, new Object[]{ sql
-!                                         .substring(i) }), "S0010", Trace
-!                                             .INVALID_JDBC_ARGUMENT);
-!                         }
+!     private static class Directive {
   
-                          // changed = true;
-                          nest++;
---- 793,800 ----
-                          state = (nest == 0) ? outside_all
-                                              : inside_escape;
-                      } else if (c == '{') {
+!         private int column;
+!         private int direction;
   
-!                         i = onStartEscapeSequence(sql, sb, i);
+          public Directive(int column, int direction) {
+              this.column    = column;
+--- 579,588 ----
+          }
+      }
   
-                          // changed = true;
-                          nest++;
+!     public static class Directive {
+  
+!         public int column;
+!         public int direction;
+  
+          public Directive(int column, int direction) {
+              this.column    = column;
+diff -crN misc/hsqldb/src/org/hsqldb/util/TransferCommon.java misc/build/hsqldb/src/org/hsqldb/util/TransferCommon.java
+*** misc/hsqldb/src/org/hsqldb/util/TransferCommon.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/TransferCommon.java	2006-11-03 20:08:10.000000000 +0100
 ***************
-*** 2702,2705 ****
---- 2640,2685 ----
-                                     + e.getMessage());
-          }
+*** 148,152 ****
+          return (tTable);
       }
-+ 
-+     /** is called from within nativeSQL when the start of an JDBC escape sequence is encountered
-+      */
-+     private int onStartEscapeSequence( String sql, StringBuffer sb, int i ) throws SQLException {
-+ 
-+         sb.setCharAt(i++, ' ');
-+ 
-+         i = StringUtil.skipSpaces(sql, i);
-+ 
-+         if (sql.regionMatches(true, i, "fn ", 0, 3)
-+                 || sql.regionMatches(true, i, "oj ", 0, 3)
-+                 || sql.regionMatches(true, i, "ts ", 0, 3)) {
-+             sb.setCharAt(i++, ' ');
-+             sb.setCharAt(i++, ' ');
-+         } else if (sql.regionMatches(true, i, "d ", 0, 2)
-+                    || sql.regionMatches(true, i, "t ", 0,
-+                                         2)) {
-+             sb.setCharAt(i++, ' ');
-+         } else if (sql.regionMatches(true, i, "call ", 0,
-+                                      5)) {
-+             i += 4;
-+         } else if (sql.regionMatches(true, i, "?= call ", 0,
-+                                      8)) {
-+             sb.setCharAt(i++, ' ');
-+             sb.setCharAt(i++, ' ');
-+ 
-+             i += 5;
-+         } else if (sql.regionMatches(true, i, "escape ", 0,
-+                                      7)) {
-+             i += 6;
-+         } else {
-+             i--;
-+ 
-+             throw new SQLException(Trace
-+                 .getMessage(Trace
-+                     .jdbcConnection_nativeSQL, true, new Object[]{ sql
-+                         .substring(i) }), "S0010", Trace
-+                             .INVALID_JDBC_ARGUMENT);
-+         }
-+ 
-+         return i;
-+     }
+  
+!     private TransferCommon() {}
+  }
+--- 148,152 ----
+          return (tTable);
+      }
+  
+!     public TransferCommon() {}
   }
-*** misc/hsqldb/src/org/hsqldb/jdbc/jdbcResultSet.java	Sun Oct 23 17:40:14 2005
---- misc/build/hsqldb/src/org/hsqldb/jdbc/jdbcResultSet.java	Fri Jun  9 16:25:34 2006
+diff -crN misc/hsqldb/src/org/hsqldb/util/TransferDb.java misc/build/hsqldb/src/org/hsqldb/util/TransferDb.java
+*** misc/hsqldb/src/org/hsqldb/util/TransferDb.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/TransferDb.java	2006-11-03 20:08:10.000000000 +0100
 ***************
-*** 4950,4956 ****
-          }
+*** 55,61 ****
   
-          if (t != type) {
-!             if (o instanceof Binary) {
-                  throw Util.sqlException(Trace.WRONG_DATA_TYPE);
-              }
+      Connection          conn;
+      DatabaseMetaData    meta;
+!     protected Statement srcStatement = null;
   
---- 4950,4956 ----
-          }
+      TransferDb(Connection c, Traceable t) throws DataAccessPointException {
   
-          if (t != type) {
-!             if (o instanceof Binary && type != Types.CHAR) {
-                  throw Util.sqlException(Trace.WRONG_DATA_TYPE);
-              }
+--- 55,61 ----
+  
+      Connection          conn;
+      DatabaseMetaData    meta;
+!     public Statement srcStatement = null;
+  
+      TransferDb(Connection c, Traceable t) throws DataAccessPointException {
   
-*** misc/hsqldb/src/org/hsqldb/lib/SimpleLog.java	Sun Oct 23 18:26:26 2005
---- misc/build/hsqldb/src/org/hsqldb/lib/SimpleLog.java	Tue May 30 16:22:33 2006
 ***************
-*** 35,43 ****
-  import java.io.FileWriter;
-  import java.io.PrintWriter;
+*** 243,249 ****
+      }
   
-  /**
-   * Simple log for recording abnormal events in persistence<p>
-!  * Log levels, 0 and 1 are currently supported.
-   *
-   * @author fredt@users
-   * @version 1.8.0
---- 35,49 ----
-  import java.io.FileWriter;
-  import java.io.PrintWriter;
+  /*
+!     private void transferRow(TransferResultSet r,
+                               PreparedStatement p)
+                               throws DataAccessPointException, SQLException {
+          // TODO
+--- 243,249 ----
+      }
   
-+ import org.hsqldb.HsqlDateTime;
-+ 
-  /**
-   * Simple log for recording abnormal events in persistence<p>
-!  * Log levels, LOG_NONE, LOG_ERROR, and LOG_NORMAL are currently supported.<p>
-!  * LOG_ERROR corresponds to property value 1 and logs main database events plus
-!  * any major errors encountered in operation.
-!  * LOG_NORMAL corresponds to property value 2 and logs additional normal events
-!  * and minor errors.
-   *
-   * @author fredt@users
-   * @version 1.8.0
+  /*
+!     public void transferRow(TransferResultSet r,
+                               PreparedStatement p)
+                               throws DataAccessPointException, SQLException {
+          // TODO
 ***************
-*** 45,50 ****
---- 51,59 ----
+*** 904,910 ****
+       *
+       * @throws SQLException
+       */
+!     private void transferRow(TransferResultSet r, PreparedStatement p,
+                               int len,
+                               int[] types)
+                               throws DataAccessPointException, SQLException {
+--- 904,910 ----
+       *
+       * @throws SQLException
+       */
+!     public void transferRow(TransferResultSet r, PreparedStatement p,
+                               int len,
+                               int[] types)
+                               throws DataAccessPointException, SQLException {
+diff -crN misc/hsqldb/src/org/hsqldb/util/TransferHelper.java misc/build/hsqldb/src/org/hsqldb/util/TransferHelper.java
+*** misc/hsqldb/src/org/hsqldb/util/TransferHelper.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/TransferHelper.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 44,54 ****
    */
-  public class SimpleLog {
+  class TransferHelper {
+  
+!     protected TransferDb db;
+!     protected Traceable  tracer;
+!     protected String     sSchema;
+!     protected JDBCTypes  JDBCT;
+!     private String       quote;
+  
+      TransferHelper() {
+  
+--- 44,54 ----
+   */
+  class TransferHelper {
+  
+!     public TransferDb db;
+!     public Traceable  tracer;
+!     public String     sSchema;
+!     public JDBCTypes  JDBCT;
+!     public String       quote;
+  
+      TransferHelper() {
+  
+diff -crN misc/hsqldb/src/org/hsqldb/util/Transfer.java misc/build/hsqldb/src/org/hsqldb/util/Transfer.java
+*** misc/hsqldb/src/org/hsqldb/util/Transfer.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/Transfer.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 203,209 ****
+          work(arg);
+      }
+  
+!     private boolean CatalogToSelect() {
   
-+     public static int   LOG_NONE   = 0;
-+     public static int   LOG_ERROR  = 1;
-+     public static int   LOG_NORMAL = 2;
-      private PrintWriter writer;
-      private int         level;
+          Vector result = null;
+  
+--- 203,209 ----
+          work(arg);
+      }
+  
+!     public boolean CatalogToSelect() {
+  
+          Vector result = null;
   
 ***************
-*** 52,58 ****
+*** 283,289 ****
+          return (lTable.getItemCount() > 0);
+      }
   
-          this.level = level;
+!     private boolean SchemaToSelect() {
   
-!         if (level != 0) {
-              if (useFile) {
-                  File file = new File(path);
+          Vector result = null;
   
---- 61,67 ----
+--- 283,289 ----
+          return (lTable.getItemCount() > 0);
+      }
   
-          this.level = level;
+!     public boolean SchemaToSelect() {
   
-!         if (level != LOG_NONE) {
-              if (useFile) {
-                  File file = new File(path);
+          Vector result = null;
   
 ***************
-*** 88,115 ****
-          return writer;
+*** 490,496 ****
+          return;
       }
   
-!     public synchronized void sendLine(String message) {
+!     private void RefreshMainDisplay() {
   
-!         if (level != 0) {
-!             writer.println(message);
-          }
+          lTable.removeAll();
+          lTable.repaint();
+--- 490,496 ----
+          return;
       }
   
-!     public synchronized void logContext(String message) {
+!     public void RefreshMainDisplay() {
   
-!         if (level == 0) {
-              return;
-          }
+          lTable.removeAll();
+          lTable.repaint();
+***************
+*** 530,536 ****
+       * @param f
+       * @param m
+       */
+!     private void addMenuItems(Menu f, String[] m) {
   
-!         String info = "";
+          for (int i = 0; i < m.length; i++) {
+              if (m[i].equals("-")) {
+--- 530,536 ----
+       * @param f
+       * @param m
+       */
+!     public void addMenuItems(Menu f, String[] m) {
   
-  //#ifdef JDBC3
-          Throwable           t        = new Throwable();
-          StackTraceElement[] elements = t.getStackTrace();
+          for (int i = 0; i < m.length; i++) {
+              if (m[i].equals("-")) {
+***************
+*** 585,591 ****
+       * Method declaration
+       *
+       */
+!     private void saveTable() {
   
-          if (elements.length > 1) {
-!             info = elements[1].getClassName() + "."
-!                    + elements[1].getMethodName();
-          }
+          if (tCurrent == null) {
+              return;
+--- 585,591 ----
+       * Method declaration
+       *
+       */
+!     public void saveTable() {
   
-  //#endif
---- 97,124 ----
-          return writer;
-      }
+          if (tCurrent == null) {
+              return;
+***************
+*** 643,649 ****
+       *
+       * @param t
+       */
+!     private void displayTable(TransferTable t) {
   
-!     public synchronized void sendLine(int atLevel, String message) {
+          tCurrent = t;
   
-!         if (level >= atLevel) {
-!             writer.println(HsqlDateTime.getSytemTimeString() + " " + message);
-          }
-      }
+--- 643,649 ----
+       *
+       * @param t
+       */
+!     public void displayTable(TransferTable t) {
   
-!     public synchronized void logContext(int atLevel, String message) {
+          tCurrent = t;
   
-!         if (level < atLevel) {
-              return;
-          }
+***************
+*** 679,685 ****
+       *
+       * @param and
+       */
+!     private void updateEnabled(boolean and) {
   
-!         String info = HsqlDateTime.getSytemTimeString();
+          boolean b = cTransfer.getState();
   
-  //#ifdef JDBC3
-          Throwable           t        = new Throwable();
-          StackTraceElement[] elements = t.getStackTrace();
+--- 679,685 ----
+       *
+       * @param and
+       */
+!     public void updateEnabled(boolean and) {
   
-          if (elements.length > 1) {
-!             info += " " + elements[1].getClassName() + "."
-!                     + elements[1].getMethodName();
-          }
+          boolean b = cTransfer.getState();
   
-  //#endif
 ***************
-*** 118,135 ****
+*** 711,717 ****
+      /**
+       * Method ProcessNextStep
+       */
+!     private void ProcessNextStep() {
   
-      public synchronized void logContext(Throwable t) {
+          switch (iSelectionStep) {
   
-!         if (level == 0) {
-              return;
-          }
+--- 711,717 ----
+      /**
+       * Method ProcessNextStep
+       */
+!     public void ProcessNextStep() {
   
-!         String info = t.getClass().getName();
+          switch (iSelectionStep) {
   
-  //#ifdef JDBC3
-          StackTraceElement[] elements = t.getStackTrace();
+***************
+*** 901,907 ****
+       */
+      public void windowClosed(WindowEvent e) {}
   
-          if (elements.length > 0) {
-!             info = elements[0].getClassName() + "."
-!                    + elements[0].getMethodName();
-          }
+!     private void cleanup() {
   
-  //#endif
---- 127,144 ----
+          try {
+              if (sourceDb != null) {
+--- 901,907 ----
+       */
+      public void windowClosed(WindowEvent e) {}
   
-      public synchronized void logContext(Throwable t) {
+!     public void cleanup() {
   
-!         if (level == LOG_NONE) {
-              return;
-          }
+          try {
+              if (sourceDb != null) {
+***************
+*** 957,963 ****
+       * Method declaration
+       *
+       */
+!     private void initGUI() {
   
-!         String info = HsqlDateTime.getSytemTimeString();
+          Font fFont = new Font("Dialog", Font.PLAIN, 12);
   
-  //#ifdef JDBC3
-          StackTraceElement[] elements = t.getStackTrace();
+--- 957,963 ----
+       * Method declaration
+       *
+       */
+!     public void initGUI() {
   
-          if (elements.length > 0) {
-!             info += " " + elements[0].getClassName() + "."
-!                     + elements[0].getMethodName();
-          }
+          Font fFont = new Font("Dialog", Font.PLAIN, 12);
   
-  //#endif
-*** misc/hsqldb/src/org/hsqldb/persist/DataFileBlockManager.java	Sun Oct 23 17:40:16 2005
---- misc/build/hsqldb/src/org/hsqldb/persist/DataFileBlockManager.java	Tue May 30 16:22:33 2006
 ***************
-*** 51,57 ****
-      private long           requestSize;
+*** 1119,1125 ****
+       *
+       * @return
+       */
+!     private Panel createBorderPanel(Component center) {
   
-      // reporting vars
-!     long lostFreeBlockSize;
+          Panel p = new Panel();
   
-      /**
+--- 1119,1125 ----
        *
---- 51,58 ----
-      private long           requestSize;
+       * @return
+       */
+!     public Panel createBorderPanel(Component center) {
   
-      // reporting vars
-!     long    lostFreeBlockSize;
-!     boolean isModified;
+          Panel p = new Panel();
   
-      /**
-       *
 ***************
-*** 72,77 ****
---- 73,80 ----
+*** 1142,1148 ****
+       *
+       * @return
        */
-      void add(int pos, int rowSize) {
+!     private Label createLabel(String s) {
   
-+         isModified = true;
-+ 
-          if (capacity == 0) {
-              lostFreeBlockSize += rowSize;
+          Label l = new Label(s);
+  
+--- 1142,1148 ----
+       *
+       * @return
+       */
+!     public Label createLabel(String s) {
+  
+          Label l = new Label(s);
   
 ***************
-*** 133,138 ****
---- 136,145 ----
-          return lostFreeBlockSize;
+*** 1151,1162 ****
+          return l;
       }
   
-+     boolean isModified() {
-+         return isModified;
-+     }
-+ 
-      private void resetList() {
+!     private void SavePrefs(String f) {
+          saveTable();
+          TransferCommon.savePrefs(f, sourceDb, targetDb, this, tTable);
+      }
+  
+!     private void LoadPrefs(String f) {
+  
+          TransferTable t;
+  
+--- 1151,1162 ----
+          return l;
+      }
+  
+!     public void SavePrefs(String f) {
+          saveTable();
+          TransferCommon.savePrefs(f, sourceDb, targetDb, this, tTable);
+      }
+  
+!     public void LoadPrefs(String f) {
+  
+          TransferTable t;
   
-          if (requestCount != 0) {
-*** misc/hsqldb/src/org/hsqldb/persist/DataFileCache.java	Sun Oct 23 18:26:26 2005
---- misc/build/hsqldb/src/org/hsqldb/persist/DataFileCache.java	Tue May 30 16:22:33 2006
-***************
-*** 39,44 ****
---- 39,45 ----
-  import org.hsqldb.Trace;
-  import org.hsqldb.lib.FileAccess;
-  import org.hsqldb.lib.FileUtil;
-+ import org.hsqldb.lib.SimpleLog;
-  import org.hsqldb.lib.StopWatch;
-  import org.hsqldb.lib.Storage;
-  import org.hsqldb.lib.ZipUnzipFile;
 ***************
-*** 275,302 ****
-                  cache.saveAll();
-                  Trace.printSystemOut("saveAll: " + sw.elapsedTime());
+*** 1207,1213 ****
+       * Method declaration
+       *
+       */
+!     private void transfer() {
   
-!                 // set empty
-!                 dataFile.seek(LONG_EMPTY_SIZE);
-!                 dataFile.writeLong(freeBlocks.getLostBlocksSize());
+          saveTable();
+          updateEnabled(false);
+--- 1207,1213 ----
+       * Method declaration
+       *
+       */
+!     public void transfer() {
   
-!                 // set end
-!                 dataFile.seek(LONG_FREE_POS_POS);
-!                 dataFile.writeLong(fileFreePosition);
+          saveTable();
+          updateEnabled(false);
+***************
+*** 1270,1276 ****
+          System.gc();
+      }
   
-!                 // set saved flag;
-!                 dataFile.seek(FLAGS_POS);
+!     protected void Exit() {
   
-!                 int flag = BitMap.set(0, FLAG_ISSAVED);
+          cleanup();
+          fMain.dispose();
+--- 1270,1276 ----
+          System.gc();
+      }
   
-!                 if (hasRowInfo) {
-!                     flag = BitMap.set(flag, FLAG_ROWINFO);
-!                 }
+!     public void Exit() {
   
-!                 dataFile.writeInt(flag);
+          cleanup();
+          fMain.dispose();
+diff -crN misc/hsqldb/src/org/hsqldb/util/TransferSQLText.java misc/build/hsqldb/src/org/hsqldb/util/TransferSQLText.java
+*** misc/hsqldb/src/org/hsqldb/util/TransferSQLText.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/TransferSQLText.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 52,60 ****
+      String              sFileName              = null;
+      BufferedWriter      WTextWrite             = null;
+      BufferedReader      WTextRead              = null;
+!     protected boolean   StructureAlreadyParsed = false;
+      Hashtable           DbStmts                = null;
+!     protected JDBCTypes JDBCT                  = null;
+  
+      TransferSQLText(String _FileName,
+                      Traceable t) throws DataAccessPointException {
+--- 52,60 ----
+      String              sFileName              = null;
+      BufferedWriter      WTextWrite             = null;
+      BufferedReader      WTextRead              = null;
+!     public boolean   StructureAlreadyParsed = false;
+      Hashtable           DbStmts                = null;
+!     public JDBCTypes JDBCT                  = null;
   
-!                 //
-!                 dataFile.seek(fileFreePosition);
-!                 Trace.printSystemOut("pos and flags: " + sw.elapsedTime());
-              }
+      TransferSQLText(String _FileName,
+                      Traceable t) throws DataAccessPointException {
+***************
+*** 159,165 ****
+       *
+       * @throws SQLException
+       */
+!     private void transferRow(TransferResultSet r) throws Exception {
   
-              if (dataFile != null) {
---- 276,310 ----
-                  cache.saveAll();
-                  Trace.printSystemOut("saveAll: " + sw.elapsedTime());
+          String sLast = "";
+          int    len   = r.getColumnCount();
+--- 159,165 ----
+       *
+       * @throws SQLException
+       */
+!     public void transferRow(TransferResultSet r) throws Exception {
   
-!                 if (fileModified || freeBlocks.isModified()) {
+          String sLast = "";
+          int    len   = r.getColumnCount();
+diff -crN misc/hsqldb/src/org/hsqldb/util/TransferTable.java misc/build/hsqldb/src/org/hsqldb/util/TransferTable.java
+*** misc/hsqldb/src/org/hsqldb/util/TransferTable.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/TransferTable.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 471,477 ****
+          }
+      }
   
-!                     // set empty
-!                     dataFile.seek(LONG_EMPTY_SIZE);
-!                     dataFile.writeLong(freeBlocks.getLostBlocksSize());
+!     private void initTypes() throws SQLException {
   
-!                     // set end
-!                     dataFile.seek(LONG_FREE_POS_POS);
-!                     dataFile.writeLong(fileFreePosition);
+          if (hTypes != null) {
+              return;
+--- 471,477 ----
+          }
+      }
   
-!                     // set saved flag;
-!                     dataFile.seek(FLAGS_POS);
+!     public void initTypes() throws SQLException {
   
-!                     int flag = BitMap.set(0, FLAG_ISSAVED);
+          if (hTypes != null) {
+              return;
+diff -crN misc/hsqldb/src/org/hsqldb/util/Tree.java misc/build/hsqldb/src/org/hsqldb/util/Tree.java
+*** misc/hsqldb/src/org/hsqldb/util/Tree.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/Tree.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 88,117 ****
+  class Tree extends Panel {
+  
+      // static
+!     private static Font        fFont;
+!     private static FontMetrics fMetrics;
+!     private static int         iRowHeight;
+!     private static int         iIndentWidth;
+!     private int                iMaxTextLength;
+  
+      // drawing
+!     private Dimension dMinimum;
+!     private Graphics  gImage;
+!     private Image     iImage;
+  
+      // height / width
+!     private int iWidth, iHeight;
+!     private int iFirstRow;
+!     private int iTreeWidth, iTreeHeight;
+!     private int iX, iY;
+  
+      // data
+!     private Vector vData;
+!     private int    iRowCount;
+  
+      // scrolling
+!     private Scrollbar sbHoriz, sbVert;
+!     private int       iSbWidth, iSbHeight;
+  
+      static {
+          fFont        = new Font("Dialog", Font.PLAIN, 12);
+--- 88,117 ----
+  class Tree extends Panel {
+  
+      // static
+!     public static Font        fFont;
+!     public static FontMetrics fMetrics;
+!     public static int         iRowHeight;
+!     public static int         iIndentWidth;
+!     public int                iMaxTextLength;
+  
+      // drawing
+!     public Dimension dMinimum;
+!     public Graphics  gImage;
+!     public Image     iImage;
+  
+      // height / width
+!     public int iWidth, iHeight;
+!     public int iFirstRow;
+!     public int iTreeWidth, iTreeHeight;
+!     public int iX, iY;
+  
+      // data
+!     public Vector vData;
+!     public int    iRowCount;
+  
+      // scrolling
+!     public Scrollbar sbHoriz, sbVert;
+!     public int       iSbWidth, iSbHeight;
   
-!                     if (hasRowInfo) {
-!                         flag = BitMap.set(flag, FLAG_ROWINFO);
-!                     }
+      static {
+          fFont        = new Font("Dialog", Font.PLAIN, 12);
+***************
+*** 543,549 ****
+       *
+       * @return
+       */
+!     private static int getMaxHeight(FontMetrics f) {
+          return f.getHeight() + 2;
+      }
+  }
+--- 543,549 ----
+       *
+       * @return
+       */
+!     public static int getMaxHeight(FontMetrics f) {
+          return f.getHeight() + 2;
+      }
+  }
+diff -crN misc/hsqldb/src/org/hsqldb/util/ZaurusConnectionDialog.java misc/build/hsqldb/src/org/hsqldb/util/ZaurusConnectionDialog.java
+*** misc/hsqldb/src/org/hsqldb/util/ZaurusConnectionDialog.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ZaurusConnectionDialog.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 251,257 ****
+       *
+       *
+       */
+!     protected void finishCreate() {
   
-!                     dataFile.writeInt(flag);
-! 
-!                     //
-!                     if (dataFile.length() != fileFreePosition) {
-!                         dataFile.seek(fileFreePosition);
-!                     }
-! 
-!                     Trace.printSystemOut("pos and flags: "
-!                                          + sw.elapsedTime());
-!                 }
-              }
+          try {
+              mConnection = createConnection(mDriver.getText(), mURL.getText(),
+--- 251,257 ----
+       *
+       *
+       */
+!     public void finishCreate() {
   
-              if (dataFile != null) {
+          try {
+              mConnection = createConnection(mDriver.getText(), mURL.getText(),
+diff -crN misc/hsqldb/src/org/hsqldb/util/ZaurusDatabaseManager.java misc/build/hsqldb/src/org/hsqldb/util/ZaurusDatabaseManager.java
+*** misc/hsqldb/src/org/hsqldb/util/ZaurusDatabaseManager.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ZaurusDatabaseManager.java	2006-11-03 20:08:10.000000000 +0100
 ***************
-*** 557,563 ****
+*** 247,253 ****
+          m.connect(c);
+      }
   
-              return object;
-          } catch (IOException e) {
-!             database.logger.appLog.logContext("" + cache + " pos: " + i);
-              database.logger.appLog.logContext(e);
+!     private static void showUsage() {
   
-              throw Trace.error(Trace.DATA_FILE_ERROR,
---- 565,572 ----
+          System.out.println(
+              "Usage: java org.hsqldb.util.ZaurusDatabaseManager [options]");
+--- 247,253 ----
+          m.connect(c);
+      }
   
-              return object;
-          } catch (IOException e) {
-!             database.logger.appLog.logContext(SimpleLog.LOG_ERROR,
-!                                               "" + cache + " pos: " + i);
-              database.logger.appLog.logContext(e);
+!     public static void showUsage() {
   
-              throw Trace.error(Trace.DATA_FILE_ERROR,
-*** misc/hsqldb/src/org/hsqldb/persist/DataFileDefrag.java	Sun Oct 23 18:26:26 2005
---- misc/build/hsqldb/src/org/hsqldb/persist/DataFileDefrag.java	Tue May 30 16:22:33 2006
+          System.out.println(
+              "Usage: java org.hsqldb.util.ZaurusDatabaseManager [options]");
 ***************
-*** 37,42 ****
---- 37,43 ----
+*** 587,593 ****
+       * Method declaration
+       *
+       */
+!     private void initGUI() {
   
-  import org.hsqldb.Database;
-  import org.hsqldb.HsqlException;
-+ import org.hsqldb.Session;
-  import org.hsqldb.Table;
-  import org.hsqldb.Trace;
-  import org.hsqldb.index.RowIterator;
+          Panel pQuery   = new Panel();
+          Panel pCommand = new Panel();
+--- 587,593 ----
+       * Method declaration
+       *
+       */
+!     public void initGUI() {
+  
+          Panel pQuery   = new Panel();
+          Panel pCommand = new Panel();
 ***************
-*** 202,207 ****
---- 203,209 ----
-      int[] writeTableToDataFile(Table table)
-      throws IOException, HsqlException {
+*** 663,669 ****
+          fMain.pack();
+      }
   
-+         Session session        = database.getSessionManager().getSysSession();
-          RowOutputBinary rowOut = new RowOutputBinary();
-          DoubleIntIndex pointerLookup =
-              new DoubleIntIndex(table.getPrimaryIndex().sizeEstimate(), false);
+!     protected void refreshTree() {
+          super.refreshTree();
+          eEditor.refresh(cConn);
+      }
+--- 663,669 ----
+          fMain.pack();
+      }
+  
+!     public void refreshTree() {
+          super.refreshTree();
+          eEditor.refresh(cConn);
+      }
+diff -crN misc/hsqldb/src/org/hsqldb/util/ZaurusEditor.java misc/build/hsqldb/src/org/hsqldb/util/ZaurusEditor.java
+*** misc/hsqldb/src/org/hsqldb/util/ZaurusEditor.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ZaurusEditor.java	2006-11-03 20:08:10.000000000 +0100
 ***************
-*** 212,218 ****
-          pointerLookup.setKeysSearchTarget();
-          Trace.printSystemOut("lookup begins: " + stopw.elapsedTime());
+*** 401,407 ****
+          }
+      }
   
-!         RowIterator it = table.rowIterator(null);
+!     private void initGUI() {
   
-          for (; it.hasNext(); count++) {
-              CachedObject row = (CachedObject) it.next();
---- 214,220 ----
-          pointerLookup.setKeysSearchTarget();
-          Trace.printSystemOut("lookup begins: " + stopw.elapsedTime());
+          // without connection there are no tables
+          // vAllTables is a local variable with all table names in the database
+--- 401,407 ----
+          }
+      }
   
-!         RowIterator it = table.rowIterator(session);
+!     public void initGUI() {
   
-          for (; it.hasNext(); count++) {
-              CachedObject row = (CachedObject) it.next();
+          // without connection there are no tables
+          // vAllTables is a local variable with all table names in the database
 ***************
-*** 231,237 ****
-                               stopw.elapsedTime());
+*** 565,575 ****
   
-          count = 0;
-!         it    = table.rowIterator(null);
+      // process the buttons events
+      // *******************************************************
+!     // private methods
+      // *******************************************************
+      // read all table names over the current database connection
+      // exclude tables without primary key
+!     private Vector getAllTables() {
   
-          for (; it.hasNext(); count++) {
-              CachedObject row = it.next();
---- 233,239 ----
-                               stopw.elapsedTime());
+          Vector result = new Vector(20);
   
-          count = 0;
-!         it    = table.rowIterator(session);
+--- 565,575 ----
+  
+      // process the buttons events
+      // *******************************************************
+!     // public methods
+      // *******************************************************
+      // read all table names over the current database connection
+      // exclude tables without primary key
+!     public Vector getAllTables() {
+  
+          Vector result = new Vector(20);
   
-          for (; it.hasNext(); count++) {
-              CachedObject row = it.next();
-*** misc/hsqldb/src/org/hsqldb/persist/HsqlDatabaseProperties.java	Sun Oct 23 18:26:26 2005
---- misc/build/hsqldb/src/org/hsqldb/persist/HsqlDatabaseProperties.java	Tue May 30 16:22:33 2006
 ***************
-*** 300,306 ****
+*** 608,614 ****
   
-          boolean exists;
+      // determine the index of the choosen table in Vector vHoldTableNames
+      // if the table name is not in vHoldTableNames, create a ZaurusTableForm for it
+!     private int getChoosenTableIndex() {
   
-!         if (database.getType().equals(DatabaseURL.S_MEM)) {
-              return true;
-          }
+          String tableName = cTables.getSelectedItem();
   
---- 300,306 ----
+--- 608,614 ----
   
-          boolean exists;
+      // determine the index of the choosen table in Vector vHoldTableNames
+      // if the table name is not in vHoldTableNames, create a ZaurusTableForm for it
+!     public int getChoosenTableIndex() {
   
-!         if (!DatabaseURL.isFileBasedDatabaseType(database.getType())) {
-              return true;
-          }
+          String tableName = cTables.getSelectedItem();
   
 ***************
-*** 366,372 ****
+*** 633,639 ****
   
-      public void save() throws HsqlException {
+      // determine the index of the given tableName in Vector vHoldTableNames
+      // if the name is not in vHoldTableNames, answer -1
+!     private int getTableIndex(String tableName) {
   
-!         if (database.getType().equals(DatabaseURL.S_MEM)
-                  || database.isFilesReadOnly() || database.isFilesInJar()) {
-              return;
-          }
---- 366,372 ----
+          int index;
   
-      public void save() throws HsqlException {
+--- 633,639 ----
   
-!         if (!DatabaseURL.isFileBasedDatabaseType(database.getType())
-                  || database.isFilesReadOnly() || database.isFilesInJar()) {
-              return;
-          }
-*** misc/hsqldb/src/org/hsqldb/persist/Logger.java	Sun Oct 23 18:26:28 2005
---- misc/build/hsqldb/src/org/hsqldb/persist/Logger.java	Tue May 30 16:22:33 2006
-***************
-*** 98,106 ****
-          appLog = new SimpleLog(path + ".app.log", loglevel,
-                                 !db.isFilesReadOnly());
+      // determine the index of the given tableName in Vector vHoldTableNames
+      // if the name is not in vHoldTableNames, answer -1
+!     public int getTableIndex(String tableName) {
   
-!         appLog.sendLine("Database (re)opened: "
-!                         + db.getFileAccess().getClass().getName() + " "
-!                         + HsqlDateTime.getSytemTimeString());
+          int index;
   
-          logStatements = false;
+***************
+*** 650,656 ****
+      }
   
---- 98,104 ----
-          appLog = new SimpleLog(path + ".app.log", loglevel,
-                                 !db.isFilesReadOnly());
+      // convert the search words in the textfield to an array of words
+!     private String[] getWords() {
   
-!         appLog.sendLine(SimpleLog.LOG_ERROR, "Database (re)opened");
+          StringTokenizer tokenizer =
+              new StringTokenizer(fSearchWords.getText());
+--- 650,656 ----
+      }
   
-          logStatements = false;
+      // convert the search words in the textfield to an array of words
+!     public String[] getWords() {
   
+          StringTokenizer tokenizer =
+              new StringTokenizer(fSearchWords.getText());
 ***************
-*** 142,149 ****
+*** 665,671 ****
+      }
   
-          if (log == null) {
-              if (appLog != null) {
-!                 appLog.sendLine("Database closed: "
-!                                 + HsqlDateTime.getSytemTimeString());
-                  appLog.close();
-              }
+      // init the three boxes for buttons
+!     private void initButtons() {
   
---- 140,146 ----
+          // the buttons for the search form
+          bSearchRow = new Button("Search Rows");
+--- 665,671 ----
+      }
   
-          if (log == null) {
-              if (appLog != null) {
-!                 appLog.sendLine(SimpleLog.LOG_ERROR, "Database closed");
-                  appLog.close();
-              }
+      // init the three boxes for buttons
+!     public void initButtons() {
   
+          // the buttons for the search form
+          bSearchRow = new Button("Search Rows");
 ***************
-*** 168,175 ****
-              }
-          } catch (Throwable e) {
-              if (appLog != null) {
-!                 appLog.sendLine("Database closed: "
-!                                 + HsqlDateTime.getSytemTimeString());
-                  appLog.close();
-              }
+*** 722,728 ****
   
---- 165,171 ----
-              }
-          } catch (Throwable e) {
-              if (appLog != null) {
-!                 appLog.sendLine(SimpleLog.LOG_NORMAL, "Database closed");
-                  appLog.close();
-              }
+      // check whether the last button pressed was delete
+      // if so, clear status line and reset the flag
+!     private void resetLastButtonDelete() {
+  
+          if (lastButtonDelete) {
+              ZaurusEditor.printStatus("");
+--- 722,728 ----
   
+      // check whether the last button pressed was delete
+      // if so, clear status line and reset the flag
+!     public void resetLastButtonDelete() {
+  
+          if (lastButtonDelete) {
+              ZaurusEditor.printStatus("");
 ***************
-*** 179,186 ****
-          }
+*** 732,738 ****
+      }
   
-          if (appLog != null) {
-!             appLog.sendLine("Database closed: "
-!                             + HsqlDateTime.getSytemTimeString());
-              appLog.close();
-          }
+      // reset  everything after changes in the database
+!     private void resetTableForms() {
   
---- 175,181 ----
-          }
+          lForm.show(pForm, "search");
+          lButton.show(pButton, "search");
+--- 732,738 ----
+      }
   
-          if (appLog != null) {
-!             appLog.sendLine(SimpleLog.LOG_ERROR, "Database closed");
-              appLog.close();
-          }
+      // reset  everything after changes in the database
+!     public void resetTableForms() {
   
-*** misc/hsqldb/src/org/hsqldb/persist/NIOScaledRAFile.java	Sun Oct 23 18:26:28 2005
---- misc/build/hsqldb/src/org/hsqldb/persist/NIOScaledRAFile.java	Tue May 30 16:22:33 2006
+          lForm.show(pForm, "search");
+          lButton.show(pButton, "search");
+diff -crN misc/hsqldb/src/org/hsqldb/util/ZaurusChoice.java misc/build/hsqldb/src/org/hsqldb/util/ZaurusChoice.java
+*** misc/hsqldb/src/org/hsqldb/util/ZaurusChoice.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ZaurusChoice.java	2006-11-03 20:08:10.000000000 +0100
 ***************
-*** 53,64 ****
-   */
-  class NIOScaledRAFile extends ScaledRAFile {
+*** 52,58 ****
+  // getContent() answers the value !!
+  public class ZaurusChoice extends Choice implements ZaurusComponent {
   
-!     MappedByteBuffer  buffer;
-!     FileChannel       channel;
-!     long              bufferLength;
-!     private boolean   wasNio;
-!     private boolean   bufferModified;
-!     static final long MAX_NIO_LENGTH = (1L << 28);
+!     private static final int MaxLenInZChoice = 15;
+      Vector                   values;
+      int                      countChanges;
   
-      /**
-       * Public constructor for access by reflection
---- 53,63 ----
-   */
-  class NIOScaledRAFile extends ScaledRAFile {
+--- 52,58 ----
+  // getContent() answers the value !!
+  public class ZaurusChoice extends Choice implements ZaurusComponent {
   
-!     MappedByteBuffer buffer;
-!     FileChannel      channel;
-!     long             bufferLength;
-!     private boolean  wasNio;
-!     private boolean  bufferModified;
+!     public static final int MaxLenInZChoice = 15;
+      Vector                   values;
+      int                      countChanges;
   
-      /**
-       * Public constructor for access by reflection
-*** misc/hsqldb/src/org/hsqldb/persist/ScaledRAFile.java	Sun Oct 23 18:26:28 2005
---- misc/build/hsqldb/src/org/hsqldb/persist/ScaledRAFile.java	Tue May 30 16:22:33 2006
 ***************
-*** 53,61 ****
-   */
-  class ScaledRAFile implements Storage {
+*** 118,124 ****
+      }
   
-!     static final int         DATA_FILE_RAF = 0;
-!     static final int         DATA_FILE_NIO = 1;
-!     static final int         DATA_FILE_JAR = 2;
-      final RandomAccessFile   file;
-      private final boolean    readOnly;
-      final String             fileName;
---- 53,62 ----
-   */
-  class ScaledRAFile implements Storage {
+      // find for a given value the index in values
+!     private int findValue(String s) {
   
-!     static final int         DATA_FILE_RAF  = 0;
-!     static final int         DATA_FILE_NIO  = 1;
-!     static final int         DATA_FILE_JAR  = 2;
-!     static final long        MAX_NIO_LENGTH = (1L << 28);
-      final RandomAccessFile   file;
-      private final boolean    readOnly;
-      final String             fileName;
-***************
-*** 107,112 ****
---- 108,122 ----
-          } else if (type == DATA_FILE_RAF) {
-              return new ScaledRAFile(name, readonly);
-          } else {
-+             RandomAccessFile file = new RandomAccessFile(name, readonly ? "r"
-+                                                                         : "rw");
-+ 
-+             if (file.length() > MAX_NIO_LENGTH) {
-+                 return new ScaledRAFile(name, file, readonly);
-+             } else {
-+                 file.close();
-+             }
-+ 
-              try {
-                  Class.forName("java.nio.MappedByteBuffer");
+          for (int i = 0; i < values.size(); i++) {
+              if (s.equals(values.elementAt(i))) {
+--- 118,124 ----
+      }
   
+      // find for a given value the index in values
+!     public int findValue(String s) {
+  
+          for (int i = 0; i < values.size(); i++) {
+              if (s.equals(values.elementAt(i))) {
+diff -crN misc/hsqldb/src/org/hsqldb/util/ZaurusTableForm.java misc/build/hsqldb/src/org/hsqldb/util/ZaurusTableForm.java
+*** misc/hsqldb/src/org/hsqldb/util/ZaurusTableForm.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/util/ZaurusTableForm.java	2006-11-03 20:08:10.000000000 +0100
 ***************
-*** 124,129 ****
---- 134,147 ----
-          }
+*** 542,551 ****
       }
   
-+     ScaledRAFile(String name, RandomAccessFile file,
-+                  boolean readonly) throws FileNotFoundException, IOException {
-+ 
-+         this.readOnly = readonly;
-+         fileName      = name;
-+         this.file     = file;
-+     }
-+ 
-      ScaledRAFile(String name,
-                   boolean readonly) throws FileNotFoundException, IOException {
+      // ******************************************************
+!     // private methods
+      // ******************************************************
+      // set all fields for primary keys to not editable
+!     private void disablePKFields() {
+  
+          for (int i = 0; i < primaryKeys.length; i++) {
+              komponente[pkColIndex[i]].setEditable(false);
+--- 542,551 ----
+      }
+  
+      // ******************************************************
+!     // public methods
+      // ******************************************************
+      // set all fields for primary keys to not editable
+!     public void disablePKFields() {
+  
+          for (int i = 0; i < primaryKeys.length; i++) {
+              komponente[pkColIndex[i]].setEditable(false);
+***************
+*** 555,561 ****
+      // fetch all values from a table and a column
+      // fill the ZaurusChoice zc with the row values for the Choice
+      // and the column values as values
+!     private void fillZChoice(ZaurusChoice zc, String tab, String col) {
   
-*** misc/hsqldb/src/org/hsqldb/persist/ScriptRunner.java	Sun Oct 23 18:26:28 2005
---- misc/build/hsqldb/src/org/hsqldb/persist/ScriptRunner.java	Tue May 30 16:22:33 2006
+          try {
+              if (cConn == null) {
+--- 555,561 ----
+      // fetch all values from a table and a column
+      // fill the ZaurusChoice zc with the row values for the Choice
+      // and the column values as values
+!     public void fillZChoice(ZaurusChoice zc, String tab, String col) {
+  
+          try {
+              if (cConn == null) {
 ***************
-*** 38,43 ****
---- 38,44 ----
-  import org.hsqldb.Session;
-  import org.hsqldb.Trace;
-  import org.hsqldb.lib.IntKeyHashMap;
-+ import org.hsqldb.lib.SimpleLog;
-  import org.hsqldb.lib.StopWatch;
-  import org.hsqldb.scriptio.ScriptReaderBase;
-  import org.hsqldb.scriptio.ScriptWriterBase;
+*** 590,596 ****
+      }
+  
+      // fetch all column names
+!     private void fetchColumns() {
+  
+          Vector temp     = new Vector(20);
+          Vector tempType = new Vector(20);
+--- 590,596 ----
+      }
+  
+      // fetch all column names
+!     public void fetchColumns() {
+  
+          Vector temp     = new Vector(20);
+          Vector tempType = new Vector(20);
 ***************
-*** 103,109 ****
-                      continue;
-                  }
+*** 628,634 ****
+      }
+  
+      // fetch the imported keys i.e. columns which reference to foreign keys in other tables
+!     private void fetchImportedKeys() {
+  
+          Vector imKeys      = new Vector(20);
+          Vector imKeyNames  = null;
+--- 628,634 ----
+      }
   
--                 String schema = current.currentSchema.name;
-                  Result result = null;
+      // fetch the imported keys i.e. columns which reference to foreign keys in other tables
+!     public void fetchImportedKeys() {
   
-                  switch (scr.getStatementType()) {
---- 104,109 ----
+          Vector imKeys      = new Vector(20);
+          Vector imKeyNames  = null;
 ***************
-*** 164,170 ****
-                  message = "out of memory processing " + logFilename
-                            + " line: " + scr.getLineNumber();
+*** 714,720 ****
+          }
+      }
   
-!                 database.logger.appLog.logContext(message);
+!     private void fetchPrimaryKeys() {
   
-                  throw Trace.error(Trace.OUT_OF_MEMORY);
-              }
---- 164,171 ----
-                  message = "out of memory processing " + logFilename
-                            + " line: " + scr.getLineNumber();
+          Vector temp = new Vector(20);
   
-!                 database.logger.appLog.logContext(SimpleLog.LOG_ERROR,
-!                                                   message);
+--- 714,720 ----
+          }
+      }
+  
+!     public void fetchPrimaryKeys() {
+  
+          Vector temp = new Vector(20);
   
-                  throw Trace.error(Trace.OUT_OF_MEMORY);
-              }
 ***************
-*** 173,179 ****
-              message = logFilename + " line: " + scr.getLineNumber() + " "
-                        + e.getMessage();
+*** 749,755 ****
+          }    // end of for (int i=0; i<primaryKeys.length; i++)
+      }
   
-!             database.logger.appLog.logContext(message);
-              Trace.printSystemOut(message);
-          } finally {
-              if (scr != null) {
---- 174,180 ----
-              message = logFilename + " line: " + scr.getLineNumber() + " "
-                        + e.getMessage();
+!     private String generatePKWhere() {
+  
+          String stmtString = " WHERE ";
+  
+--- 749,755 ----
+          }    // end of for (int i=0; i<primaryKeys.length; i++)
+      }
+  
+!     public String generatePKWhere() {
+  
+          String stmtString = " WHERE ";
   
-!             database.logger.appLog.logContext(SimpleLog.LOG_ERROR, message);
-              Trace.printSystemOut(message);
-          } finally {
-              if (scr != null) {
-*** misc/hsqldb/src/org/hsqldb/resources/sql-error-messages.properties	Sun Nov  6 23:07:20 2005
---- misc/build/hsqldb/src/org/hsqldb/resources/sql-error-messages.properties	Tue May 30 16:24:12 2006
 ***************
-*** 23,29 ****
-  019=40001 Transfer corrupted
-  020=IM001 This function is not supported
-  021=S0001 Table already exists
-! 022=S0002 Table not found
-  023=S0011 Index already exists
-  024=S0011 Attempt to define a second primary key
-  025=S0011 Attempt to drop the primary key
---- 23,29 ----
-  019=40001 Transfer corrupted
-  020=IM001 This function is not supported
-  021=S0001 Table already exists
-! 022=S0002 Table '$$' not found
-  023=S0011 Index already exists
-  024=S0011 Attempt to define a second primary key
-  025=S0011 Attempt to drop the primary key
+*** 765,771 ****
+      }
+  
+      // generate the Where-condition for the words
+!     private String generateWhere(String[] words, boolean allWords,
+                                   boolean ignoreCase, boolean noMatchWhole) {
+  
+          String result = "";
+--- 765,771 ----
+      }
+  
+      // generate the Where-condition for the words
+!     public String generateWhere(String[] words, boolean allWords,
+                                   boolean ignoreCase, boolean noMatchWhole) {
+  
+          String result = "";
 ***************
-*** 54,60 ****
-  050=S0011 Attempt to drop a foreign key index
-  051=S1000 ResultSet was set to forward only
-  052=S0003 View already exists
-! 053=S0004 View not found
-  054=S0005 NA
-  055=S0005 Not a Table
-  056=S0011 Attempt to drop or rename a system index
---- 54,60 ----
-  050=S0011 Attempt to drop a foreign key index
-  051=S1000 ResultSet was set to forward only
-  052=S0003 View already exists
-! 053=S0004 View '$$' not found
-  054=S0005 NA
-  055=S0005 Not a Table
-  056=S0011 Attempt to drop or rename a system index
+*** 822,828 ****
+      }
+  
+      // answer the index of the column named name in the actual table
+!     private int getColIndex(String name) {
+  
+          for (int i = 0; i < columns.length; i++) {
+              if (name.equals(columns[i])) {
+--- 822,828 ----
+      }
+  
+      // answer the index of the column named name in the actual table
+!     public int getColIndex(String name) {
+  
+          for (int i = 0; i < columns.length; i++) {
+              if (name.equals(columns[i])) {
 ***************
-*** 106,112 ****
-  102=duplicate column in list
-  103=table has no primary key
-  104=23000 Unique constraint violation
-! 105=missing DEFAULT value on column $$
-  106=S1000 NULL value as BOOLEAN
-  107=attempt to connect while db opening /closing
-  108=NA
---- 106,112 ----
-  102=duplicate column in list
-  103=table has no primary key
-  104=23000 Unique constraint violation
-! 105=S0021 missing DEFAULT value on column $$
-  106=S1000 NULL value as BOOLEAN
-  107=attempt to connect while db opening /closing
-  108=NA
+*** 834,840 ****
+      }
+  
+      // answer the index of the column named colName in the table tabName
+!     private int getColIndex(String colName, String tabName) {
+  
+          int ordPos = 0;
+  
+--- 834,840 ----
+      }
+  
+      // answer the index of the column named colName in the table tabName
+!     public int getColIndex(String colName, String tabName) {
+  
+          int ordPos = 0;
+  
 ***************
-*** 139,145 ****
-  135=properties name is null or empty
-  136=Server certificate has no Common Name
-  137=Server certificate has empty Common Name
-! 138=Unknown JDBC escape sequence: {
-  139=Certificate Common Name[$$] does not match host name[$$]
-  140=NA
-  141=NA
---- 139,145 ----
-  135=properties name is null or empty
-  136=Server certificate has no Common Name
-  137=Server certificate has empty Common Name
-! 138=Unknown JDBC escape sequence: $$
-  139=Certificate Common Name[$$] does not match host name[$$]
-  140=NA
-  141=NA
+*** 864,870 ****
+  
+      // answer the index of the constraint for the column index
+      // answer -1, if the column is not part of any constraint
+!     private int getConstraintIndex(int colIndex) {
+  
+          for (int i = 0; i < imColIndex.length; i++) {
+              for (int j = 0; j < imColIndex[i].length; j++) {
+--- 864,870 ----
+  
+      // answer the index of the constraint for the column index
+      // answer -1, if the column is not part of any constraint
+!     public int getConstraintIndex(int colIndex) {
+  
+          for (int i = 0; i < imColIndex.length; i++) {
+              for (int j = 0; j < imColIndex[i].length; j++) {
 ***************
-*** 198,204 ****
-  194=23000 Table is referenced by view
-  195=NA
-  196=S1000 Text source file already exists
-! 197=23000 Column is referenced in constraint
-  198=S1000 Error calling function
-  199=27000 Triggered data change violation
-  200=37000 Invalid argument
---- 198,204 ----
-  194=23000 Table is referenced by view
-  195=NA
-  196=S1000 Text source file already exists
-! 197=23000 Column is referenced in constraint or view
-  198=S1000 Error calling function
-  199=27000 Triggered data change violation
-  200=37000 Invalid argument
-*** misc/hsqldb/src/org/hsqldb/resources/sql-error-messages_it.properties	Sun Nov  6 23:07:32 2005
---- misc/build/hsqldb/src/org/hsqldb/resources/sql-error-messages_it.properties	Tue May 30 16:22:33 2006
+*** 877,883 ****
+          return -1;
+      }
+  
+!     private void initGUI() {
+  
+          Panel pEntry = new Panel();
+  
+--- 877,883 ----
+          return -1;
+      }
+  
+!     public void initGUI() {
+  
+          Panel pEntry = new Panel();
+  
 ***************
-*** 1,6 ****
-  # Copyright 2005 HSQL Developers Group
-  # can be distributed and used according to HSQLDB License
-! # see http://hsqldb.sourceforge.net
-  # Italian translation by Nicola Pedot (http://www.jugtrento.org/)
-  # JRC-Editor by http://zavel.org
-  000=NOT USED
---- 1,6 ----
-  # Copyright 2005 HSQL Developers Group
-  # can be distributed and used according to HSQLDB License
-! # see http://hsqldb.org
-  # Italian translation by Nicola Pedot (http://www.jugtrento.org/)
-  # JRC-Editor by http://zavel.org
-  000=NOT USED
+*** 940,946 ****
+      }
+  
+      // get and show the values of the actual row in the GUI
+!     private void showAktRow() {
+  
+          try {
+              pStmt.clearParameters();
+--- 940,946 ----
+      }
+  
+      // get and show the values of the actual row in the GUI
+!     public void showAktRow() {
+  
+          try {
+              pStmt.clearParameters();
+diff -crN misc/hsqldb/src/org/hsqldb/View.java misc/build/hsqldb/src/org/hsqldb/View.java
+*** misc/hsqldb/src/org/hsqldb/View.java	2005-10-23 17:40:22.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/View.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 50,57 ****
+  
+      Select             viewSelect;
+      SubQuery           viewSubQuery;
+!     private String     statement;
+!     private HsqlName[] colList;
+  
+      /** schema at the time of compilation */
+      HsqlName compileTimeSchema;
+--- 50,57 ----
+  
+      Select             viewSelect;
+      SubQuery           viewSubQuery;
+!     public String     statement;
+!     public HsqlName[] colList;
+  
+      /** schema at the time of compilation */
+      HsqlName compileTimeSchema;
+diff -crN misc/hsqldb/src/org/hsqldb/WebServerConnection.java misc/build/hsqldb/src/org/hsqldb/WebServerConnection.java
+*** misc/hsqldb/src/org/hsqldb/WebServerConnection.java	2005-10-23 18:26:34.000000000 +0200
+--- misc/build/hsqldb/src/org/hsqldb/WebServerConnection.java	2006-11-03 20:08:10.000000000 +0100
+***************
+*** 76,95 ****
+  class WebServerConnection implements Runnable {
+  
+      static final String         ENCODING = "8859_1";
+!     private Socket              socket;
+!     private WebServer           server;
+!     private static final int    REQUEST_TYPE_BAD  = 0;
+!     private static final int    REQUEST_TYPE_GET  = 1;
+!     private static final int    REQUEST_TYPE_HEAD = 2;
+!     private static final int    REQUEST_TYPE_POST = 3;
+!     private static final String HEADER_OK         = "HTTP/1.0 200 OK";
+!     private static final String HEADER_BAD_REQUEST =
+          "HTTP/1.0 400 Bad Request";
+!     private static final String HEADER_NOT_FOUND = "HTTP/1.0 404 Not Found";
+!     private static final String HEADER_FORBIDDEN = "HTTP/1.0 403 Forbidden";
+      static final int            BUFFER_SIZE      = 256;
+!     private RowOutputBinary     rowOut = new RowOutputBinary(BUFFER_SIZE);
+!     private RowInputBinary      rowIn            = new RowInputBinary(rowOut);
+  
+      //
+      static final byte[] BYTES_GET        = "GET".getBytes();
+--- 76,95 ----
+  class WebServerConnection implements Runnable {
+  
+      static final String         ENCODING = "8859_1";
+!     public Socket              socket;
+!     public WebServer           server;
+!     public static final int    REQUEST_TYPE_BAD  = 0;
+!     public static final int    REQUEST_TYPE_GET  = 1;
+!     public static final int    REQUEST_TYPE_HEAD = 2;
+!     public static final int    REQUEST_TYPE_POST = 3;
+!     public static final String HEADER_OK         = "HTTP/1.0 200 OK";
+!     public static final String HEADER_BAD_REQUEST =
+          "HTTP/1.0 400 Bad Request";
+!     public static final String HEADER_NOT_FOUND = "HTTP/1.0 404 Not Found";
+!     public static final String HEADER_FORBIDDEN = "HTTP/1.0 403 Forbidden";
+      static final int            BUFFER_SIZE      = 256;
+!     public RowOutputBinary     rowOut = new RowOutputBinary(BUFFER_SIZE);
+!     public RowInputBinary      rowIn            = new RowInputBinary(rowOut);
+  
+      //
+      static final byte[] BYTES_GET        = "GET".getBytes();
 ***************
-*** 108,114 ****
-  102=colonna duplicata nella lista
-  103=tabella senza chiave primaria
-  104=23000 Violazione del vincolo di unicit\u00e0
-! 105=manca il valore DEFAULT sulla colonna $$
-  106=S1000 valore NULL come BOOLEAN
-  107=tentativo di connessione mentre l'archivio si stava aprendo/chiudendo
-  108=NA
---- 108,114 ----
-  102=colonna duplicata nella lista
-  103=tabella senza chiave primaria
-  104=23000 Violazione del vincolo di unicit\u00e0
-! 105=S2001 manca il valore DEFAULT sulla colonna $$
-  106=S1000 valore NULL come BOOLEAN
-  107=tentativo di connessione mentre l'archivio si stava aprendo/chiudendo
-  108=NA
+*** 101,107 ****
+      };
+  
+      // default mime type mappings
+!     private static final int hnd_content_types =
+          BundleHandler.getBundleHandle("content_types", null);
+  
+      /**
+--- 101,107 ----
+      };
+  
+      // default mime type mappings
+!     public static final int hnd_content_types =
+          BundleHandler.getBundleHandle("content_types", null);
+  
+      /**
 ***************
-*** 200,206 ****
-  194=23000 Tabella referenziata dalla vista
-  195=NA
-  196=S1000 Testo sorgente gi\u00e0 esistente
-! 197=23000 Colonna referenziata nel vincolo
-  198=S1000 Errore nella chiamata alla funzione
-  199=27000 Violazione nel cambio di dati da trigger
-  200=37000 Argomento non valido
---- 200,206 ----
-  194=23000 Tabella referenziata dalla vista
-  195=NA
-  196=S1000 Testo sorgente gi\u00e0 esistente
-! 197=23000 Colonna referenziata nel vincolo o vista
-  198=S1000 Errore nella chiamata alla funzione
-  199=27000 Violazione nel cambio di dati da trigger
-  200=37000 Argomento non valido
-*** misc/hsqldb/src/org/hsqldb/rowio/RowInputTextQuoted.java	Sun Oct 23 18:26:28 2005
---- misc/build/hsqldb/src/org/hsqldb/rowio/RowInputTextQuoted.java	Tue May 30 16:22:33 2006
+*** 125,131 ****
+       * @return a best-guess mime-type string using the file extention
+       *      of the name argument.
+       */
+!     private String getMimeTypeString(String name) {
+  
+          int    pos;
+          String key;
+--- 125,131 ----
+       * @return a best-guess mime-type string using the file extention
+       *      of the name argument.
+       */
+!     public String getMimeTypeString(String name) {
+  
+          int    pos;
+          String key;
 ***************
-*** 120,125 ****
---- 120,126 ----
-                          } else {
+*** 240,246 ****
+       * POST is used only for database access. So we can assume the strings
+       * are those generated by HTTPClientConnection
+       */
+!     private void processPost(InputStream inStream,
+                               String name) throws HsqlException, IOException {
   
-                              //-- End of field.
-+                             // todo - bug here as it throws when there are line terminators after the last field
-                              if (((next + 1) != qtext.length)
-                                      && (text.indexOf(sep, next) != next)) {
-                                  throw Trace
-*** misc/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBase.java	Sun Oct 23 18:26:28 2005
---- misc/build/hsqldb/src/org/hsqldb/scriptio/ScriptWriterBase.java	Tue May 30 16:22:33 2006
+          // fredt - parsing in this block is not actually necessary
+--- 240,246 ----
+       * POST is used only for database access. So we can assume the strings
+       * are those generated by HTTPClientConnection
+       */
+!     public void processPost(InputStream inStream,
+                               String name) throws HsqlException, IOException {
+  
+          // fredt - parsing in this block is not actually necessary
 ***************
-*** 305,311 ****
+*** 350,356 ****
+       * @param  name the name of the content to get
+       * @param  send whether to send the content as well, or just the header
+       */
+!     private void processGet(String name, boolean send) {
   
-                          writeTableInit(t);
+          try {
+              String       hdr;
+--- 350,356 ----
+       * @param  name the name of the content to get
+       * @param  send whether to send the content as well, or just the header
+       */
+!     public void processGet(String name, boolean send) {
   
-!                         RowIterator it = t.rowIterator(null);
+          try {
+              String       hdr;
+***************
+*** 452,458 ****
+       *
+       * @param code the error condition code
+       */
+!     private void processError(int code) {
   
-                          while (it.hasNext()) {
-                              writeRow(currentSession, t, it.next().getData());
---- 305,311 ----
+          String msg;
   
-                          writeTableInit(t);
+--- 452,458 ----
+       *
+       * @param code the error condition code
+       */
+!     public void processError(int code) {
   
-!                         RowIterator it = t.rowIterator(currentSession);
+          String msg;
   
-                          while (it.hasNext()) {
-                              writeRow(currentSession, t, it.next().getData());
