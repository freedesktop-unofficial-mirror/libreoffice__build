--- connectivity/source/drivers/evoab2/EApi.cxx.evo2~	2005-09-23 16:05:13.000000000 +0000
+++ connectivity/source/drivers/evoab2/EApi.cxx	2005-12-19 19:53:12.000000000 +0000
@@ -36,7 +36,7 @@
 #include <rtl/ustring.hxx>
 #include <osl/module.h>
 #include <stdio.h>
-#define _EVOLUTION_ALREADY_DEFINED_ 1
+#define  DECLARE_FN_POINTERS 1
 #ifndef _CONNECTIVITY_EVOAB_EVOLUTION_API_HXX_
 #include "EApi.h"
 #endif
@@ -56,6 +56,8 @@
 	const char *sym_name;
 	SymbolFunc *ref_value;
     } aApiMap[] = {
+	SYM_MAP( e_contact_field_name ),
+	SYM_MAP( e_contact_get ),
 	SYM_MAP( e_contact_get_type ),
 	SYM_MAP( e_contact_field_id ),
 	SYM_MAP( e_source_peek_name ),
@@ -110,8 +112,10 @@
 				  SAL_LOADMODULE_DEFAULT );
 	if( aModule)
 	{
-	    if ( tryLink( aModule, eBookLibNames[ j ] ) )
+	    if ( tryLink( aModule, eBookLibNames[ j ] ) ) {
+		if (j==1) bIsEVO_2_2 = true;
 		return true;
+		}
 	    osl_unloadModule( aModule );
 	}
     }
--- connectivity/source/drivers/evoab2/EApi.h.evo2~	2005-09-23 16:05:13.000000000 +0000
+++ connectivity/source/drivers/evoab2/EApi.h	2005-12-19 19:53:12.000000000 +0000
@@ -51,52 +51,42 @@
 // We attempt to define a minimum API that we use:
 
 // e-contact.h
+#ifdef DECLARE_FN_POINTERS
+#define EAPI_EXTERN
+#else
+#define EAPI_EXTERN extern
+#endif
+
+
+EAPI_EXTERN bool bIsEVO_2_2;
 typedef void EContact;
 #define E_CONTACT(a) ((EContact *)(a))
 #define E_TYPE_CONTACT (e_contact_get_type())
 typedef int EContactField;
 
+EAPI_EXTERN const char      *(*e_contact_field_name)   ( EContactField field_id);
+EAPI_EXTERN gpointer      	(*e_contact_get)   (EContact *contact, EContactField field_id);
+EAPI_EXTERN const gpointer  (*e_contact_get_const)   (EContact *contact, EContactField field_id);
 // e-source.h
 typedef void ESource;
 #define E_SOURCE(a) ((ESource *)(a))
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-const char  *(*e_source_peek_name)    (ESource *source);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-const gchar *(*e_source_get_property) (ESource *source,
+EAPI_EXTERN const char  *(*e_source_peek_name)    (ESource *source);
+EAPI_EXTERN const gchar *(*e_source_get_property) (ESource *source,
 				       const gchar *property);
 
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-GType         (*e_contact_get_type) (void);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-EContactField (*e_contact_field_id) (const char *field_name);
+EAPI_EXTERN GType         (*e_contact_get_type) (void);
+EAPI_EXTERN EContactField (*e_contact_field_id) (const char *field_name);
 
 // e-source-list.h
 typedef void ESourceList;
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-GSList *(*e_source_list_peek_groups) (ESourceList *list);
+EAPI_EXTERN GSList *(*e_source_list_peek_groups) (ESourceList *list);
 
 // e-source-group.h
 typedef void ESourceGroup;
 #define E_SOURCE_GROUP(a) ((ESourceGroup *)(a))
 
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-GSList  *(*e_source_group_peek_sources) (ESourceGroup *group);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-const char *(*e_source_group_peek_base_uri)  (ESourceGroup *group);
+EAPI_EXTERN GSList  *(*e_source_group_peek_sources) (ESourceGroup *group);
+EAPI_EXTERN const char *(*e_source_group_peek_base_uri)  (ESourceGroup *group);
 // e-book.h
 typedef enum {
   E_BOOK_QUERY_IS,
@@ -108,76 +98,53 @@
 typedef void EBook;
 typedef void EBookQuery;
 
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-EBook      *(*e_book_new)                     (ESource      *source,
-					       GError      **error);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-gboolean    (*e_book_open)                    (EBook       *book,
-					       gboolean     only_if_exists,
-					       GError     **error);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-const char *(*e_book_get_uri)                 (EBook        *book);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-ESource    *(*e_book_get_source)              (EBook        *book);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-gboolean    (*e_book_get_addressbooks)        (ESourceList **addressbook_sources,
-					       GError      **error);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-gboolean    (*e_book_get_contacts)            (EBook        *book,
-					       EBookQuery   *query,
-					       GList       **contacts,
-					       GError      **error);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-gboolean    (*e_book_authenticate_user)       (EBook        *book,
-					       const char   *user,
-					       const char   *passwd,
-					       const char   *auth_method,
-					       GError      **error);
+EAPI_EXTERN EBook      *(*e_book_new) 		(ESource      *source,
+								       		 GError      **error);
+
+EAPI_EXTERN gboolean    (*e_book_open)		(EBook       *book,
+					       				 	 gboolean     only_if_exists,
+				                         	 GError     **error);
+
+EAPI_EXTERN const char *(*e_book_get_uri)	(EBook        *book);
+EAPI_EXTERN ESource    *(*e_book_get_source)(EBook        *book);
+
+EAPI_EXTERN gboolean    (*e_book_get_addressbooks)        (ESourceList **addressbook_sources,
+													       GError      **error);
+
+EAPI_EXTERN gboolean    (*e_book_get_contacts)            (EBook        *book,
+													       EBookQuery   *query,
+													       GList       **contacts,
+													       GError      **error);
+
+EAPI_EXTERN gboolean    (*e_book_authenticate_user)       (EBook        *book,
+													       const char   *user,
+													       const char   *passwd,
+													       const char   *auth_method,
+													       GError      **error);
 
 // e-book-query.h
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-EBookQuery* (*e_book_query_field_exists) (EContactField   field);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-EBookQuery* (*e_book_query_field_test)   (EContactField   field,
-					  EBookQueryTest     test,
-					  const char        *value);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-EBookQuery* (*e_book_query_and)          (int nqs, EBookQuery **qs, gboolean unref);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-EBookQuery* (*e_book_query_or)           (int nqs, EBookQuery **qs, gboolean unref);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-EBookQuery* (*e_book_query_not)          (EBookQuery *q, gboolean unref);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-void        (*e_book_query_unref)        (EBookQuery *q);
-#ifndef _EVOLUTION_ALREADY_DEFINED_
-extern
-#endif
-char*       (*e_book_query_to_string)    (EBookQuery *q);
+EAPI_EXTERN EBookQuery* (*e_book_query_field_exists) (EContactField   field);
+EAPI_EXTERN EBookQuery* (*e_book_query_field_test)   (EContactField   field,
+					  								  EBookQueryTest     test,
+													  const char        *value);
+EAPI_EXTERN EBookQuery* (*e_book_query_and)          (int nqs, EBookQuery **qs, gboolean unref);
+EAPI_EXTERN EBookQuery* (*e_book_query_or)           (int nqs, EBookQuery **qs, gboolean unref);
+EAPI_EXTERN EBookQuery* (*e_book_query_not)          (EBookQuery *q, gboolean unref);
+EAPI_EXTERN void        (*e_book_query_unref)        (EBookQuery *q);
+EAPI_EXTERN char*       (*e_book_query_to_string)    (EBookQuery *q);
+
+typedef struct {
+        char *address_format; /* the two letter country code that
+                                 determines the format/meaning of the
+                                 following fields */
+        char *po;
+        char *ext;
+        char *street;
+        char *locality;
+        char *region;
+        char *code;
+        char *country;
+} EContactAddress;
 G_END_DECLS
 #endif
+
--- connectivity/source/drivers/evoab2/NDatabaseMetaData.cxx.evo2~	2005-09-23 16:05:13.000000000 +0000
+++ connectivity/source/drivers/evoab2/NDatabaseMetaData.cxx	2005-12-19 19:53:12.000000000 +0000
@@ -89,129 +89,174 @@
 		static sal_Int32    const s_nNULLABLE = 1;
 		static sal_Int32 const s_nCHAR_OCTET_LENGTH = 65535;
 
-static GParamSpec **pFields = NULL;
-static guint        nFields = 0;
+		static ColumnProperty **pFields=NULL;
+		static guint        nFields = 0;
 
-static const char *pBlackList[] = {
-		"id",
-		"list-show-addresses"
-};
-
-static void
-initFields()
-{
-	if( !pFields )
-	{
-		::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
-		if( !pFields )
-		{
-			guint        nProps;
-			GParamSpec **pProps;
-			GParamSpec **pToBeFields;
-			pProps = g_object_class_list_properties
-					( (GObjectClass *) g_type_class_ref( E_TYPE_CONTACT ),
-					  &nProps );
-			pToBeFields = g_new0( GParamSpec *, nProps );
-
-			for ( guint i = 0; i < nProps; i++ )
-			{
-				switch (pProps[i]->value_type)
-				{
-				case G_TYPE_STRING:
-				case G_TYPE_BOOLEAN:
-				{
-					bool bAdd = true;
-					const char *pName = g_param_spec_get_name( pProps[i] );
-					for (int j = 0; j < G_N_ELEMENTS( pBlackList ); j++ )
-					{
-						if( !strcmp( pBlackList[j], pName ) )
-						{
-							bAdd = false;
-							break;
-						}
-					}
-					if( bAdd )
-						pToBeFields[ nFields++ ] = g_param_spec_ref( pProps[i] );
-					break;
-				}
-				default:
-					break;
-				}
-			}
-			pFields = pToBeFields;
-		}
-	}
-}
-
-guint
-getFieldCount()
-{
-	initFields();
-	return nFields;
-}
-
-const GParamSpec *
-getField(guint n)
-{
-	initFields();
-	if( n < nFields )
-		return pFields[n];
-	else
-		return NULL;
-}
-
-sal_Int32
-getFieldType( sal_Int32 nCol )
-{
-	sal_Int32 nType = DataType::VARCHAR;
-	initFields();
-	if (nCol >= 0 && nCol < nFields )
-	{
-		if( pFields[nCol]->value_type == G_TYPE_STRING )
-			nType = DataType::VARCHAR;
-		else 
-			nType = DataType::BIT;
-	}
-	return nType;
-}
+        static const char *pBlackList[] = 
+        {
+            "id",
+            "list-show-addresses",
+            "address-label-home",
+            "address-label-work",
+            "address-label-other"
+        };
+
+    static void 
+    splitColumn (ColumnProperty **pToBeFields)
+    {
+        for (int i = 0; i < OTHER_ZIP; i++) 
+        {
+            pToBeFields[nFields] = g_new0(ColumnProperty,1);
+            pToBeFields[nFields]->bIsSplittedValue = true;
+            pToBeFields[nFields]->pField = g_param_spec_ref(g_param_spec_string (evo_addr[i].pColumnName,evo_addr[i].pColumnName,"",NULL,G_PARAM_WRITABLE));
+            nFields++;
+        }
+    }
+
+    static void
+    initFields()
+    {
+        if( !pFields )
+        {
+            ::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+            if( !pFields )
+            {
+                guint        nProps;
+                ColumnProperty **pToBeFields;
+                GParamSpec **pProps;
+                nFields = 0;
+                pProps = g_object_class_list_properties
+                    ( (GObjectClass *) g_type_class_ref( E_TYPE_CONTACT ),
+                         &nProps );
+                pToBeFields = g_new0(ColumnProperty  *, (nProps + OTHER_ZIP)/* new column(s)*/ );
+                for ( guint i = 0; i < nProps; i++ )
+                {
+                    switch (pProps[i]->value_type)
+                    {
+                        case G_TYPE_STRING:
+                        case G_TYPE_BOOLEAN:
+                        {
+                            bool bAdd = true;
+                            const char *pName = g_param_spec_get_name( pProps[i] );
+                            for (int j = 0; j < G_N_ELEMENTS( pBlackList ); j++ )
+                            {
+                                if( !strcmp( pBlackList[j], pName ) )
+                                {
+                                    bAdd = false;
+                                    break;
+                                }
+                            }
+                            if( bAdd ) 
+                            {
+                                pToBeFields[nFields]= g_new0(ColumnProperty,1);
+                                pToBeFields[nFields]->bIsSplittedValue=false;
+                                pToBeFields[ nFields++ ]->pField = g_param_spec_ref( pProps[i] );
+                            }
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+			
+                splitColumn(pToBeFields);
+                pFields = pToBeFields;
+            }
+        }
+    }
+
+
+    guint
+    getFieldCount()
+    {
+        initFields();
+        return nFields;
+    }
+
+    const ColumnProperty *
+    getField(guint n)
+    {
+        initFields();
+        if( n < nFields )
+            return pFields[n];
+    	else
+            return NULL;
+    }
+
+    sal_Int32
+    getFieldType( sal_Int32 nCol )
+    {
+        sal_Int32 nType = DataType::VARCHAR;
+        initFields();
+        if (nCol >= 0 && nCol < nFields )
+        {
+            if( ((GParamSpec *)pFields[nCol]->pField)->value_type == G_TYPE_STRING )
+                nType = DataType::VARCHAR;
+            else 
+                nType = DataType::BIT;
+        }
+        return nType;
+    }
+
+    rtl::OUString
+    getFieldTypeName( sal_Int32 nCol )
+    {
+        switch( getFieldType( nCol ) )
+        {
+            case DataType::BIT:
+                return ::rtl::OUString::createFromAscii( "BIT" );
+            case DataType::VARCHAR:
+                return ::rtl::OUString::createFromAscii( "VARCHAR" );
+            default:
+                break;
+        }
+        return ::rtl::OUString();
+    }
+
+    rtl::OUString
+    getFieldName( sal_Int32 nCol )
+    {
+        const GParamSpec *pSpec = getField( nCol )->pField;
+        rtl::OUString aName;
+        initFields();
 
-rtl::OUString
-getFieldTypeName( sal_Int32 nCol )
-{
-	switch( getFieldType( nCol ) )
-	{
-	case DataType::BIT:
-			return ::rtl::OUString::createFromAscii( "BIT" );
-	case DataType::VARCHAR:
-			return ::rtl::OUString::createFromAscii( "VARCHAR" );
-	default:
-			break;
-	}
-	return ::rtl::OUString();
-}
+        if( pSpec )
+            aName = rtl::OStringToOUString( g_param_spec_get_name( ( GParamSpec * )pSpec ),
+											RTL_TEXTENCODING_UTF8 );
+            aName = aName.replace( '-', '_' );
+        return aName;
+    }
+
+    void  
+    free_column_resources()
+    {
+        for (int i=nFields-1;i > 0;i--) 
+        {
+            if (pFields && pFields[i] ) 
+            {
+                if (pFields[i]->pField) 
+                    g_param_spec_unref(pFields[i]->pField);
+                g_free(pFields[i]);
+            }
+        }
+       if(pFields) 
+        {
+            g_free(pFields);
+            pFields=NULL;
+        }
+	
+    }
 
-rtl::OUString
-getFieldName( sal_Int32 nCol )
-{
-	const GParamSpec *pSpec = getField( nCol );
-	rtl::OUString aName;
 
-	if( pSpec )
-			aName = rtl::OStringToOUString( g_param_spec_get_name( ( GParamSpec * )pSpec ),
-											RTL_TEXTENCODING_UTF8 );
-	aName = aName.replace( '-', '_' );
-	return aName;
+    }
 }
 
-	}
-}
 
 OEvoabDatabaseMetaData::OEvoabDatabaseMetaData(OEvoabConnection* _pCon)
 	: ::connectivity::ODatabaseMetaDataBase(_pCon)
 	,m_pConnection(_pCon)
 {
 	OSL_ENSURE(m_pConnection,"OEvoabDatabaseMetaData::OEvoabDatabaseMetaData: No connection set!");
-	//construct();
 }
 void OEvoabDatabaseMetaData::construct()
 {
@@ -272,7 +317,7 @@
 			aRow[5] = new ORowSetValueDecorator( static_cast<sal_Int16>( getFieldType( i ) ) );
 			aRow[6] = new ORowSetValueDecorator( getFieldTypeName( i ) );
 
-			OSL_TRACE( "   ColumnName = '%s'", g_param_spec_get_name( pFields[i] ) );
+			OSL_TRACE( "   ColumnName = '%s'", g_param_spec_get_name( pFields[i]->pField ) );
 			// COLUMN_NAME
 			aRow[4] = new ORowSetValueDecorator( getFieldName( i ) );
 			// ORDINAL_POSITION
--- connectivity/source/drivers/evoab2/NDatabaseMetaData.hxx.evo2~	2005-12-19 19:38:21.000000000 +0000
+++ connectivity/source/drivers/evoab2/NDatabaseMetaData.hxx	2005-12-19 19:56:49.000000000 +0000
@@ -60,13 +60,38 @@
 		//**************************************************************
 		//************ Class: OEvoabDatabaseMetaData
 		//**************************************************************
+		typedef struct{
+			gboolean bIsSplittedValue;
+			GParamSpec *pField;
+		}ColumnProperty;
 
-		const GParamSpec *getField(guint n);
-		guint             getFieldCount();
-		sal_Int32		 getFieldType(sal_Int32 nCol);
-		rtl::OUString	 getFieldTypeName(sal_Int32 nCol);
-		rtl::OUString     getFieldName(sal_Int32 nCol);
+		typedef enum {
+			DEFAULT_ADDR_LINE1=1,DEFAULT_ADDR_LINE2,DEFAULT_CITY,DEFAULT_STATE,DEFAULT_COUNTRY,DEFAULT_ZIP,
+			WORK_ADDR_LINE1,WORK_ADDR_LINE2,WORK_CITY,WORK_STATE,WORK_COUNTRY,WORK_ZIP,
+			HOME_ADDR_LINE1,HOME_ADDR_LINE2,HOME_CITY,HOME_STATE,HOME_COUNTRY,HOME_ZIP,
+			OTHER_ADDR_LINE1,OTHER_ADDR_LINE2,OTHER_CITY,OTHER_STATE,OTHER_COUNTRY,OTHER_ZIP
+		}ColumnNumber;
+
+		typedef struct {
+			const gchar *pColumnName;
+			ColumnNumber value;
+		}SplitEvoColumns;
+
+		static SplitEvoColumns evo_addr[] = {
+			{"addr-line1",DEFAULT_ADDR_LINE1},{"addr-line2",DEFAULT_ADDR_LINE2},{"city",DEFAULT_CITY},{"state",DEFAULT_STATE},{"country",DEFAULT_COUNTRY},{"zip",DEFAULT_ZIP},
+			{"work-addr-line1",WORK_ADDR_LINE1},{"work-addr-line2",WORK_ADDR_LINE2},{"work-city",WORK_CITY},{"work-state",WORK_STATE},{"work-country",WORK_COUNTRY},{"work-zip",WORK_ZIP},
+			{"home-addr-line1",HOME_ADDR_LINE1},{"home-addr-line2",HOME_ADDR_LINE2},{"home-addr-City",HOME_CITY},{"home-state",HOME_STATE},{"home-country",HOME_COUNTRY},{"home-zip",HOME_ZIP},
+			{"other-addr-line1",OTHER_ADDR_LINE1},{"other-addr-line2",OTHER_ADDR_LINE2},{"other-addr-city",OTHER_CITY},{"other-addr-state",OTHER_STATE},{"other-addr-country",OTHER_COUNTRY},{"other-addr-zip",OTHER_ZIP}
+		};
+
+		const ColumnProperty *getField(guint n);
+		guint             getFieldCount() G_GNUC_CONST;
+		sal_Int32		 getFieldType(sal_Int32 nCol) G_GNUC_CONST;
+		rtl::OUString	 getFieldTypeName(sal_Int32 nCol) G_GNUC_CONST;
+		rtl::OUString     getFieldName(sal_Int32 nCol) G_GNUC_CONST;
 		
+		void free_column_resources();
+
 		class OEvoabDatabaseMetaData : public ODatabaseMetaDataBase
 		{
 			OEvoabConnection*	                   m_pConnection;
--- connectivity/source/drivers/evoab2/NPreparedStatement.cxx.evo2~	2005-09-23 16:05:13.000000000 +0000
+++ connectivity/source/drivers/evoab2/NPreparedStatement.cxx	2005-12-19 19:53:12.000000000 +0000
@@ -121,9 +121,8 @@
 	::osl::MutexGuard aGuard( m_aMutex );
 	checkDisposed(OStatement_BASE::rBHelper.bDisposed);
 		
-
+	free_column_resources();
 	// Reset last warning message
-
 	try {
 		clearWarnings ();
 		OStatement_BASE2::close();
@@ -132,8 +131,6 @@
 		// If we get an error, ignore
 	}
 
-	// Remove this Statement object from the Connection object's
-	// list
 }
 // -------------------------------------------------------------------------
 
--- connectivity/source/drivers/evoab2/NResultSet.cxx.evo2~	2005-09-23 16:05:13.000000000 +0000
+++ connectivity/source/drivers/evoab2/NResultSet.cxx	2005-12-19 19:53:12.000000000 +0000
@@ -289,7 +289,7 @@
 	::osl::MutexGuard aGuard(m_aMutex);
 
 	m_pStatement	= NULL;
-	m_xMetaData		= NULL;
+	m_xMetaData	= NULL;
 }
 // -------------------------------------------------------------------------
 Any SAL_CALL OEvoabResultSet::queryInterface( const Type & rType ) throw(RuntimeException)
@@ -310,25 +310,167 @@
 	return ::comphelper::concatSequences(aTypes.getTypes(),OResultSet_BASE::getTypes());
 }
 
+static int 
+whichAddress(int value)
+{
+	int fieldEnum;
+	switch (value) 
+	{
+		case HOME_ADDR_LINE1:
+		case HOME_ADDR_LINE2:
+		case HOME_CITY:
+		case HOME_STATE:
+		case HOME_COUNTRY:
+		case HOME_ZIP:
+			bIsEVO_2_2 ? fieldEnum=89:fieldEnum=88/*E_CONTACT_ADDRESS_HOME*/;break; 
+		case WORK_ADDR_LINE1:
+		case WORK_ADDR_LINE2:
+		case WORK_CITY:
+		case WORK_STATE:
+		case WORK_COUNTRY:
+		case WORK_ZIP: 
+			bIsEVO_2_2 ? fieldEnum = 90:fieldEnum=89/*E_CONTACT_ADDRESS_WORK*/;break;
+		case OTHER_ADDR_LINE1:
+		case OTHER_ADDR_LINE2:
+		case OTHER_CITY:
+		case OTHER_STATE:
+		case OTHER_COUNTRY:
+		case OTHER_ZIP:
+			bIsEVO_2_2 ? fieldEnum=91:fieldEnum= 90/*E_	CONTACT_ADDRESS_OTHER*/; break;
+    	default: fieldEnum=89;        
+	  }
+	return fieldEnum;
+}
+
+/*
+* This function decides the default column values based on the first field of EContactAddress.
+* The search order is Work->Home->other(defaults).
+*/
+static EContactAddress * 
+getDefaultContactAddress(EContact *pContact,int *value) 
+{
+	EContactAddress *ec = (EContactAddress *)e_contact_get(pContact,whichAddress(WORK_ADDR_LINE1));
+	if ( ec && (strlen(ec->street)>0) ) 
+	{
+		*value= *value +WORK_ADDR_LINE1 -1;
+		return ec;	
+	}
+	else  
+		{
+			ec = (EContactAddress *)e_contact_get(pContact,whichAddress(HOME_ADDR_LINE1));
+			if ( ec && (strlen(ec->street)>0) ) 
+			{ 
+				*value=*value+HOME_ADDR_LINE1-1;
+				return ec;
+			}
+		}
+
+	*value=*value+OTHER_ADDR_LINE1-1;
+	return (EContactAddress *)e_contact_get(pContact,whichAddress(OTHER_ADDR_LINE1));
+}
+
+static EContactAddress* 
+getContactAddress(EContact *pContact, int * address_enum) 
+{ 
+	EContactAddress *ec = NULL;
+    switch (*address_enum) {
+	
+        case DEFAULT_ADDR_LINE1:
+        case DEFAULT_ADDR_LINE2:
+        case DEFAULT_CITY:
+        case DEFAULT_STATE:
+        case DEFAULT_COUNTRY:
+        case DEFAULT_ZIP:
+			ec = getDefaultContactAddress(pContact,address_enum);break;
+   		default:
+			ec = (EContactAddress *)e_contact_get(pContact,whichAddress(*address_enum));
+    }
+	return ec;
+}
+
+static bool 
+handleSplitAddress(EContact *pContact,GValue *pStackValue,int value) 
+{
+
+	EContactAddress *ec = getContactAddress(pContact,&value) ;
+
+	if (ec==NULL)
+		return true;
+
+	switch (value) {
+    	case WORK_ADDR_LINE1:
+		    g_value_set_string(pStackValue,ec->street ); break;
+	    case WORK_ADDR_LINE2:
+		    g_value_set_string(pStackValue,ec->po ); break;
+    	case WORK_CITY: 
+	    	g_value_set_string(pStackValue,ec->locality ); break;
+    	case WORK_STATE:
+ 	    	g_value_set_string(pStackValue,ec->region ); break;
+    	case WORK_COUNTRY:
+	    	g_value_set_string(pStackValue,ec->country ); break;
+    	case WORK_ZIP:
+	    	g_value_set_string(pStackValue,ec->code ); break;
+
+        case HOME_ADDR_LINE1:
+			g_value_set_string(pStackValue,ec->street ); break;
+        case HOME_ADDR_LINE2:
+			g_value_set_string(pStackValue,ec->po ); break;
+        case HOME_CITY:
+			g_value_set_string(pStackValue,ec->locality ); break;
+        case HOME_STATE:
+			g_value_set_string(pStackValue,ec->region ); break;
+        case HOME_COUNTRY:
+			g_value_set_string(pStackValue,ec->country ); break;
+        case HOME_ZIP:
+			g_value_set_string(pStackValue,ec->code ); break;
+
+        case OTHER_ADDR_LINE1:
+			g_value_set_string(pStackValue,ec->street ); break;
+        case OTHER_ADDR_LINE2:
+			g_value_set_string(pStackValue,ec->po ); break;
+        case OTHER_CITY:
+			g_value_set_string(pStackValue,ec->locality ); break;
+        case OTHER_STATE:
+			g_value_set_string(pStackValue,ec->region ); break;
+        case OTHER_COUNTRY:
+			g_value_set_string(pStackValue,ec->country ); break;
+        case OTHER_ZIP:
+			g_value_set_string(pStackValue,ec->code ); break;
+
+	}
+
+return false;
+}
 // -------------------------------------------------------------------------
 // XRow Interface 
 
 bool
 OEvoabResultSet::getValue( sal_Int32 nColumnNum, GType nType, GValue *pStackValue)
 {
-	const GParamSpec *pSpec = evoab::getField (nColumnNum - 1);
+	const ColumnProperty * pSpecs = evoab::getField (nColumnNum - 1);
+	GParamSpec *pSpec = pSpecs->pField;
+	gboolean bIsSplittedColumn=pSpecs->bIsSplittedValue;
 	EContact *pContact = getCur();
-	
+
 	m_bWasNull = true;
-	if (!pSpec || !pContact)
+	if (!pSpec || !pContact) {
 		return false;
-
+		}
 	if (G_PARAM_SPEC_VALUE_TYPE (pSpec) != nType)
 	{
 		g_warning ("Wrong type");
 		return false;
 	}
 	g_value_init (pStackValue, nType);
+	if (bIsSplittedColumn) {
+		for (int i=0;i<OTHER_ZIP;i++) {
+			if (0==strcmp(g_param_spec_get_name(( GParamSpec * )pSpec),evo_addr[i].pColumnName)) {
+				m_bWasNull = handleSplitAddress(pContact,pStackValue,evo_addr[i].value);
+				return true;
+			}
+		}
+	}
+	else {
 	g_object_get_property (G_OBJECT (pContact),
 						   g_param_spec_get_name ((GParamSpec *) pSpec),
 						   pStackValue);
@@ -338,7 +480,7 @@
 		g_value_unset (pStackValue);
 		return false;
 	}
-
+	}
 	m_bWasNull = false;
 	return true;
 }
@@ -606,6 +748,7 @@
 	checkDisposed(OResultSet_BASE::rBHelper.bDisposed);
 
 	m_nIndex = 0;
+	return true;
 }
 // -------------------------------------------------------------------------
 
@@ -615,6 +758,7 @@
 	checkDisposed(OResultSet_BASE::rBHelper.bDisposed);
 
 	m_nIndex = m_nLength - 1;
+	return true;
 }
 // -------------------------------------------------------------------------
 sal_Bool SAL_CALL OEvoabResultSet::absolute( sal_Int32 row ) throw(SQLException, RuntimeException)
@@ -711,7 +855,6 @@
 	{
 		::osl::MutexGuard aGuard( m_aMutex );
 		checkDisposed(OResultSet_BASE::rBHelper.bDisposed);
-
 	}
 	OSL_TRACE("In/Out: OEvoabResultSet::close" );
 	dispose();
--- connectivity/source/drivers/evoab2/NResultSetMetaData.cxx.evo2~	2005-09-23 16:05:13.000000000 +0000
+++ connectivity/source/drivers/evoab2/NResultSetMetaData.cxx	2005-12-19 19:53:12.000000000 +0000
@@ -104,7 +104,8 @@
 // -------------------------------------------------------------------------
 ::rtl::OUString SAL_CALL OEvoabResultSetMetaData::getColumnLabel( sal_Int32 nColumnNum ) throw(SQLException, RuntimeException)
 {
-	const GParamSpec *pSpec = getField( nColumnNum - 1 );
+	const ColumnProperty *pSpecs = getField(nColumnNum - 1); 
+	GParamSpec *pSpec = pSpecs->pField;
 	rtl::OUString aLabel;
 
 	if( pSpec )
