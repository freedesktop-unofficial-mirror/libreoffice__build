diff -ru -x CVS -x '*.orig' solenv.bak/bin/make_installer.pl solenv/bin/make_installer.pl
--- solenv.bak/bin/make_installer.pl	2008-01-14 20:07:21.000000000 +0100
+++ solenv/bin/make_installer.pl	2008-03-31 13:36:23.072121200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: make_installer.pl,v $
 #
-#   $Revision: 1.98.14.1 $
+#   $Revision: 1.92 $
 #
-#   last change: $Author: rt $ $Date: 2008/01/14 19:07:21 $
+#   last change: $Author: rt $ $Date: 2007/07/26 08:47:55 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -85,7 +85,6 @@
 use installer::windows::inifile;
 use installer::windows::java;
 use installer::windows::media;
-use installer::windows::mergemodule;
 use installer::windows::msiglobal;
 use installer::windows::patch;
 use installer::windows::property;
@@ -159,6 +158,18 @@
 my $current_install_number = "";
 
 ######################################
+# Checking the package list
+######################################
+
+my $packages;
+
+if ((!($installer::globals::iswindowsbuild)) && (!($installer::globals::is_copy_only_project)))
+{
+	$packages = installer::control::read_packagelist($installer::globals::packagelist);
+	installer::control::check_packagelist($packages);
+}
+
+######################################
 # Checking the system requirements
 ######################################
 
@@ -177,6 +188,10 @@
 # Analyzing the settings and variables in zip.lst
 ###################################################
 
+# if the ziplistname is not defined on the command line, it is defaulted
+
+if ($installer::globals::use_default_ziplist) { installer::ziplist::set_ziplist_name($pathvariableshashref); }
+
 installer::logger::globallog("zip list file: $installer::globals::ziplistname");
 
 my $ziplistref = installer::files::read_file($installer::globals::ziplistname);
@@ -235,7 +250,6 @@
 if ( $installer::globals::globallogging ) { installer::files::save_hash($loggingdir . "allvariables3a.log", $allvariableshashref); }
 
 installer::ziplist::add_variables_to_allvariableshashref($allvariableshashref);
-installer::servicesfile::set_defaults_in_allvariableshashref($allvariableshashref);
 if ( $installer::globals::globallogging ) { installer::files::save_hash($loggingdir . "allvariables3b.log", $allvariableshashref); }
 
 ########################################################
@@ -244,14 +258,6 @@
 
 installer::simplepackage::check_simple_packager_project($allvariableshashref);
 
-####################################################################
-# setting global variables
-####################################################################
-
-installer::control::set_addchildprojects($allvariableshashref);
-installer::control::set_addjavainstaller($allvariableshashref);
-installer::control::set_addsystemintegration($allvariableshashref);
-
 ########################################################
 # Re-define logging dir, after all variables are set
 ########################################################
@@ -309,9 +315,10 @@
 
 ##############################################
 # Analyzing languages in zip.lst if required
-# Probably no longer used.
 ##############################################
 
+# Now get info about the languages and the setup script (defined on command line or in product list) 
+
 if ($installer::globals::languages_defined_in_productlist) { installer::languages::get_info_about_languages($allsettingsarrayref); }
 
 #####################################
@@ -371,10 +378,6 @@
 installer::setupscript::add_installationobject_to_variables($allvariableshashref, $allscriptvariablesref);
 if ( $installer::globals::globallogging ) { installer::files::save_hash($loggingdir . "allvariables4.log", $allvariableshashref); }
 
-# Adding also all variables, that must be included into the $allvariableshashref.
-installer::setupscript::add_forced_properties($allvariableshashref);
-if ( $installer::globals::globallogging ) { installer::files::save_hash($loggingdir . "allvariables5.log", $allvariableshashref); }
-
 installer::logger::log_hashref($allvariableshashref);
 
 installer::logger::print_message( "... analyzing directories ... \n" );
@@ -464,7 +467,6 @@
 my $folderitemsinproductarrayref;
 my $registryitemsinproductarrayref;
 my $windowscustomactionsarrayref;
-my $mergemodulesarrayref;
 
 if ( $installer::globals::iswindowsbuild )	# Windows specific items: Folder, FolderItem, RegistryItem, WindowsCustomAction
 {
@@ -496,11 +498,6 @@
 
 	$windowscustomactionsarrayref = installer::setupscript::get_all_items_from_script($setupscriptref, "WindowsCustomAction");
 	if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "windowscustomactions1.log", $windowscustomactionsarrayref); }
-
-	installer::logger::print_message( "... analyzing Windows merge modules ... \n" );
-
-	$mergemodulesarrayref = installer::setupscript::get_all_items_from_script($setupscriptref, "MergeModule");
-	if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "mergemodules1.log", $mergemodulesarrayref); }
 }
 
 my $modulesinproductarrayref;
@@ -535,7 +532,7 @@
 #################################################
 
 # Now starts the language dependent part, if more than one product is defined on the command line
-# Example -l en-US,de#es,fr,it defines two multilingual products
+# Example -l 01,33,49#81,82,86,88 defines two multilingual products
 
 ###############################################################################
 # Beginning of language dependent part
@@ -580,6 +577,9 @@
 			installer::logger::include_header_into_logfile("$infoline");
 			installer::logger::print_message( "$infoline" );
 
+			$packages = installer::control::read_packagelist($installer::globals::addpackagelist); # reading the addon packagelist (which should be the languagepack package list)
+			installer::control::check_packagelist($packages);
+
 			if ( $n == 1 )	# packing the language packs, after the office is created
 			{
 				$installer::globals::languagepack = 1;		# !!! Setting languagepack variable after finishing the first language
@@ -595,6 +595,7 @@
 
 	if ( $installer::globals::patch )
 	{
+		$installer::globals::addchildprojects = 0;	# no child projects for patches
 		$installer::globals::addlicensefile = 0;	# no license files for patches	
 		$installer::globals::makedownload = 0;
 		$installer::globals::makejds = 0;
@@ -844,7 +845,7 @@
 			{
 				installer::logger::print_message( "... creating preregistered services.rdb ...\n" );
 
-				installer::servicesfile::create_services_rdb($allvariableshashref, $filesinproductlanguageresolvedarrayref, $includepatharrayref, $languagestringref);
+				installer::servicesfile::create_services_rdb($filesinproductlanguageresolvedarrayref, $includepatharrayref, $languagestringref);
 				if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "productfiles14.log", $filesinproductlanguageresolvedarrayref); }
 			}
 		}
@@ -860,7 +861,7 @@
 		{		
 			installer::logger::print_message( "... merging files into registry database ...\n" );
 
-			installer::regmerge::merge_registration_files($filesinproductlanguageresolvedarrayref, $includepatharrayref, $languagestringref, $allvariableshashref);
+			installer::regmerge::merge_registration_files($filesinproductlanguageresolvedarrayref, $includepatharrayref, $languagestringref);
 			if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "productfiles14b.log", $filesinproductlanguageresolvedarrayref); }
 		}
 	}
@@ -975,7 +976,7 @@
 		installer::scriptitems::replace_setup_variables($profileitemsinproductlanguageresolvedarrayref, $languagestringref, $allvariableshashref);
 		if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "profileitems4.log", $profileitemsinproductlanguageresolvedarrayref); }
 
-		if ( $installer::globals::patch_user_dir )
+		if ( $installer::globals::is_simple_packager_project )
 		{
 			installer::scriptitems::replace_userdir_variable($profileitemsinproductlanguageresolvedarrayref);
 			if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "profileitems4a.log", $profileitemsinproductlanguageresolvedarrayref); }		
@@ -986,7 +987,7 @@
 
 		# Now the Profiles can be created
 
-		installer::profiles::create_profiles($profilesinproductlanguageresolvedarrayref, $profileitemsinproductlanguageresolvedarrayref, $filesinproductlanguageresolvedarrayref, $languagestringref, $allvariableshashref);
+		installer::profiles::create_profiles($profilesinproductlanguageresolvedarrayref, $profileitemsinproductlanguageresolvedarrayref, $filesinproductlanguageresolvedarrayref, $languagestringref);
 		if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "productfiles15.log", $filesinproductlanguageresolvedarrayref); }
 	}
 
@@ -1158,29 +1159,6 @@
 		next; # ! leaving the current loop, because no further packaging required.
 	}
 
-	###########################################################
-	# Analyzing the package structure
-	###########################################################
-
-	installer::logger::print_message( "... analyzing package list ...\n" );
-	
-	my $packages = installer::packagelist::collectpackages($modulesinproductlanguageresolvedarrayref, $languagesarrayref);
-	installer::packagelist::check_packagelist($packages);
-
-	if ( ! $installer::globals::languagepack )
-	{
-		$packages = installer::packagelist::analyze_list($packages, $modulesinproductlanguageresolvedarrayref);
-		installer::packagelist::remove_multiple_modules_packages($packages);
-	}
-
-	if ( $installer::globals::languagepack )	# language pack has its own module structure
-	{
-		$packages = installer::packagelist::analyze_list_languagepack($packages);
-	}
-
-	# printing packages content:
-	installer::packagelist::log_packages_content($packages);
-
 	if ( $installer::globals::debug ) { installer::logger::debuginfo("\nEnd of part 1b: The language dependent part\n"); }
 
 	# saving debug info, before starting part 2
@@ -1225,6 +1203,26 @@
 		my $installlogdir = installer::systemactions::create_directory_next_to_directory($installdir, "log");
 		# my $installchecksumdir = installer::systemactions::create_directory_next_to_directory($installdir, "checksum");
 
+		############################################################################
+		# Investigating the different RPMs, Packages, ... that shall be created.
+		# The module GIDs are defined in the input file
+		# Only for non-Windows platforms
+		############################################################################
+
+		installer::logger::print_message( "... analyzing package list ...\n" );
+
+		if ( ! $installer::globals::languagepack )	# language pack has its own module structure
+		{
+			$packages = installer::packagelist::analyze_list($packages, $modulesinproductlanguageresolvedarrayref);
+
+			installer::packagelist::remove_multiple_modules_packages($packages);
+		}
+
+		if ( $installer::globals::languagepack )	# language pack has its own module structure
+		{
+			$packages = installer::packagelist::analyze_list_languagepack($packages);
+		}
+		
 		my $epmexecutable = "";
 		my $found_epm = 0;
 
@@ -1440,7 +1438,7 @@
 			# Simple installation mechanism
 			###########################################
 
-			if ( $installer::globals::simple ) { installer::worker::install_simple($onepackagename, $$languagestringref, $dirsinpackage, $filesinpackage, $linksinpackage, $unixlinksinpackage); }
+			if ( $installer::globals::simple ) { installer::worker::install_simple($onepackagename, $$languagestringref, $dirsinpackage, $filesinpackage, $linksinpackage); }
 
 			###########################################
 			# Creating epm list file
@@ -1762,15 +1760,6 @@
 		# my $installchecksumdir = installer::systemactions::create_directory_next_to_directory($installdir, "checksum");
 
 		#################################################################################
-		# Preparing cabinet files from package definitions
-		#################################################################################
-
-		# installer::packagelist::prepare_cabinet_files($packages, $allvariableshashref, $$languagestringref);
-		installer::packagelist::prepare_cabinet_files($packages, $allvariableshashref);
-		# printing packages content:
-		installer::packagelist::log_cabinet_assignments();
-
-		#################################################################################
 		# Begin of functions that are used for the creation of idt files (Windows only)
 		#################################################################################
 		
@@ -1796,17 +1785,12 @@
 		my $inifiletableentries = installer::worker::collect_all_items_with_special_flag($profileitemsinproductlanguageresolvedarrayref ,"INIFILETABLE");
 
 		# Creating the important dynamic idt files
+
 		installer::windows::msiglobal::set_msiproductversion($allvariableshashref);
 		installer::windows::msiglobal::put_msiproductversion_into_bootstrapfile($filesinproductlanguageresolvedarrayref);
 
-		# Add cabinet assignments to files
-		installer::windows::file::assign_cab_to_files($filesinproductlanguageresolvedarrayref);
-		if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "productfiles17a.log", $filesinproductlanguageresolvedarrayref); }
-		installer::windows::file::assign_sequencenumbers_to_files($filesinproductlanguageresolvedarrayref);
-		if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "productfiles17b.log", $filesinproductlanguageresolvedarrayref); }
-
 		$filesinproductlanguageresolvedarrayref = installer::windows::file::create_files_table($filesinproductlanguageresolvedarrayref, \@allfilecomponents, $newidtdir, $allvariableshashref);
-		if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "productfiles17c.log", $filesinproductlanguageresolvedarrayref); }
+		if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "productfiles17a.log", $filesinproductlanguageresolvedarrayref); }
 
 		installer::windows::directory::create_directory_table($directoriesforepmarrayref, $newidtdir, $allvariableshashref);
 		if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "productfiles18.log", $filesinproductlanguageresolvedarrayref); }
@@ -1825,11 +1809,6 @@
 		if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "productfiles19b.log", $filesinproductlanguageresolvedarrayref); }
 
 		# Attention: The table "Feature.idt" contains language specific strings -> parameter: $languagesarrayref !
-		if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "modules4.log", $modulesinproductlanguageresolvedarrayref); }
-		installer::windows::feature::add_uniquekey($modulesinproductlanguageresolvedarrayref);
-		if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "modules4a.log", $modulesinproductlanguageresolvedarrayref); }
-		$modulesinproductlanguageresolvedarrayref = installer::windows::feature::sort_feature($modulesinproductlanguageresolvedarrayref);
-		if ( $installer::globals::globallogging ) { installer::files::save_array_of_hashes($loggingdir . "modules4b.log", $modulesinproductlanguageresolvedarrayref); }
 		installer::windows::feature::create_feature_table($modulesinproductlanguageresolvedarrayref, $newidtdir, $languagesarrayref, $allvariableshashref);
 
 		installer::windows::featurecomponent::create_featurecomponent_table($filesinproductlanguageresolvedarrayref, $registryitemsinproductlanguageresolvedarrayref, $newidtdir);
@@ -2003,9 +1982,6 @@
 
 				installer::windows::msiglobal::write_summary_into_msi_database($msifilename, $onelanguage, $languagefile, $allvariableshashref);
 				
-				# if there are Merge Modules, they have to be integrated now
-				installer::windows::mergemodule::merge_mergemodules_into_msi_database($mergemodulesarrayref, $msifilename, $languagestringref, $onelanguage, $languagefile, $allvariableshashref, $includepatharrayref);
-				
 				# copy msi database into installation directory
 
 				my $msidestfilename = $installdir . $installer::globals::separator . $msidatabasename;
@@ -2027,11 +2003,9 @@
 
 			installer::windows::msiglobal::rename_msi_database_in_installset($defaultlanguage, $installdir, $allvariableshashref);
 
-			if ( $allvariableshashref->{'ADDLANGUAGEINDATABASENAME'} ) { installer::windows::msiglobal::add_language_to_msi_database($defaultlanguage, $installdir, $allvariableshashref); }
-
 			installer::logger::print_message( "... generating setup.ini ...\n" );
-			
-			if ( ! $allvariableshashref->{'NOLOADERREQUIRED'} ) { installer::windows::msiglobal::create_setup_ini($languagesarrayref, $defaultlanguage, $installdir, $allvariableshashref); }
+
+			installer::windows::msiglobal::create_setup_ini($languagesarrayref, $defaultlanguage, $installdir, $allvariableshashref);
 		}
 
 		# Analyzing the ScpActions and copying the files into the installation set
@@ -2044,11 +2018,7 @@
 
 		# ... copying the setup.exe, instmsia.exe and instmsiw.exe
 
-		installer::windows::msiglobal::copy_windows_installer_files_into_installset($installdir, $includepatharrayref, $allvariableshashref);
-
-		# ... copying MergeModules into installation set
-
-		installer::windows::msiglobal::copy_merge_modules_into_installset($installdir);
+		installer::windows::msiglobal::copy_windows_installer_files_into_installset($installdir, $includepatharrayref);
 
 		# ... copying the child projects
 
@@ -2067,7 +2037,7 @@
 		$installer::globals::packjobref = installer::windows::msiglobal::generate_cab_file_list($filesinproductlanguageresolvedarrayref, $installdir, $ddfdir, $allvariableshashref);
 
 		# Update and patch reasons the pack order needs to be saved
-		installer::windows::msiglobal::save_packorder();
+		installer::windows::msiglobal::save_packorder($filesinproductlanguageresolvedarrayref);
 
 		$infoline = "\n"; 
 		push(@installer::globals::logfileinfo, $infoline);
@@ -2130,9 +2100,6 @@
 
 	if ( $installer::globals::debug ) { installer::logger::debuginfo("\nEnd of part 2b: The Windows platform\n"); }
 
-	# saving file_info file for later analysis
-	my $speciallogfilename = "fileinfo_" . $installer::globals::product . "\.log";
-	installer::files::save_array_of_hashes($loggingdir . $speciallogfilename, $filesinproductlanguageresolvedarrayref);
 
 }	# end of iteration for one language group
 
--- solenv.bak/bin/par2script.pl	2008-04-04 09:53:22.108750000 +0200
+++ solenv/bin/par2script.pl	2008-04-04 09:53:58.343125000 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: par2script.pl,v $
 #
-#   $Revision: 1.8 $
+#   $Revision: 1.7 $
 #
-#   last change: $Author: ihi $ $Date: 2007/08/20 15:25:05 $
+#   last change: $Author: ihi $ $Date: 2007/03/26 12:44:11 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -41,6 +41,7 @@
 use par2script::globals;
 use par2script::parameter;
 use par2script::module;
+use par2script::shortcut;
 use par2script::undefine;
 use par2script::work;
 
@@ -57,63 +58,37 @@
 
 par2script::work::make_complete_pathes_for_parfiles($parfiles, $includes);
 
-print "Reading par files\n";
 my $parfilecontent = par2script::work::read_all_parfiles($parfiles);
 
-print "Collecting items\n";
-par2script::work::collect_definitions($parfilecontent);
+my $setupscript = par2script::work::collect_all_items($parfilecontent);
 
-print "Collecting assigned items\n";
-par2script::work::collect_assigned_gids();
+par2script::undefine::undefine_gids($setupscript, $parfilecontent);
 
-# print "First control of multiple assignments\n";
-# par2script::check::check_multiple_assignments();
+par2script::undefine::remove_complete_dirs($setupscript, $parfilecontent);
+par2script::undefine::remove_complete_profile($setupscript, $parfilecontent);
 
-print "Searching for Undefinitions\n";
-par2script::undefine::undefine_gids($parfilecontent);
-par2script::undefine::remove_complete_item("Directory", $parfilecontent);
-par2script::undefine::remove_complete_item("Profile", $parfilecontent);
+par2script::shortcut::shift_shortcut_positions($setupscript);
+par2script::module::remove_from_modules($setupscript);
+par2script::module::add_to_root_module($setupscript);
+par2script::module::shorten_lines_at_modules($setupscript);
 
-print "Removing assigned GIDs without definitions\n";
-par2script::module::remove_undefined_gids_from_modules();
-
-print "Adding definitions without assignment to the root\n";
-par2script::module::add_to_root_module();
+# checking the setup script
 
-print "Control of multiple assignments\n";
-par2script::check::check_multiple_assignments();
+par2script::check::check_needed_directories($setupscript);
+par2script::check::check_directories_in_item_definitions($setupscript, "File");
+par2script::check::check_directories_in_item_definitions($setupscript, "Shortcut");
+par2script::check::check_directories_in_item_definitions($setupscript, "Profile");
+par2script::check::check_module_existence($setupscript);
+# par2script::check::check_registry_at_files($setupscript);
+par2script::check::check_moduleid_at_items($setupscript);
+par2script::check::check_semicolon($setupscript);
 
-print "Control of definitions with missing assignments\n";
-par2script::check::check_missing_assignments();
+# saving the script
 
-# checking the setup script
-print "Checking directory definitions ...\n";
-par2script::check::check_needed_directories();
-par2script::check::check_directories_in_item_definitions();
-print "Checking module definitions ...\n";
-par2script::check::check_module_existence();
-print "Checking module assignments ...\n";
-par2script::check::check_moduleid_at_items();
-print "Checking StarRegistry ...\n";
-par2script::check::check_registry_at_files();
-print "Checking Root Module ...";
-par2script::check::check_rootmodule();
-print "Checking Shortcut assignments ...\n";
-par2script::check::check_shortcut_assignments();
-print "Checking missing parents ...\n";
-par2script::check::check_missing_parents();
-
-print "Shorten lines at modules\n";
-par2script::module::shorten_lines_at_modules();
-
-# Now the script can be created
-print "Creating setup script\n";
-my $setupscript = par2script::work::create_script();
-
-print "Saving script\n";
 par2script::files::save_file($par2script::globals::scriptname, $setupscript);
 
 # logging, if set
+
 if ($par2script::globals::logging)
 {
 	par2script::files::save_file($par2script::globals::logfilename, \@par2script::globals::logfileinfo);
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/Cws.pm solenv/bin/modules/Cws.pm
--- solenv.bak/bin/modules/Cws.pm	2008-03-07 14:23:20.000000000 +0100
+++ solenv/bin/modules/Cws.pm	2008-03-31 14:09:36.333592400 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: Cws.pm,v $
 #
-#   $Revision: 1.21.138.1 $
+#   $Revision: 1.20 $
 #
-#   last change: $Author: rt $ $Date: 2008/03/07 13:23:20 $
+#   last change: $Author: kz $ $Date: 2007/02/12 15:09:38 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -301,18 +301,6 @@
     return uc($master) . '_' . lc($milestone);
 };
 
-sub get_master_branch_tag {
-    my ($self, $master) = @_;
-    $master = $self->master() if (!defined $master);
-    # check in environment if master is on the the HEAD branch
-    my $cvs_head = get_cvs_head();
-    if ( $master eq $cvs_head ) {
-        return undef;
-    }
-    else {
-        return 'mws_' . lc($master);
-    }
-};
 
 sub get_mws {
     my $self = shift;
@@ -653,11 +641,8 @@
     my $master    = shift;
     my $milestone = shift;
 
-    my $childworkspaces_arrref = $self->get_childworkspaces_for_milestone($master, $milestone);
-    if ( !$childworkspaces_arrref ) {
-        $childworkspaces_arrref = [];
-    }
-    return wantarray ? @$childworkspaces_arrref : $childworkspaces_arrref;
+    return wantarray ? @{$self->get_childworkspaces_for_milestone($master, $milestone)}
+                     :   $self->get_childworkspaces_for_milestone($master, $milestone);
 }
 
 
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/archivefiles.pm solenv/bin/modules/installer/archivefiles.pm
--- solenv.bak/bin/modules/installer/archivefiles.pm	2007-12-05 18:36:00.000000000 +0100
+++ solenv/bin/modules/installer/archivefiles.pm	2008-03-31 14:09:36.349217000 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: archivefiles.pm,v $
 #
-#   $Revision: 1.17 $
+#   $Revision: 1.14 $
 #
-#   last change: $Author: vg $ $Date: 2007/12/05 17:36:00 $
+#   last change: $Author: hr $ $Date: 2007/01/02 15:02:21 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -318,8 +318,6 @@
 							$newfile{'destination'} = $destination . $zipname;
 							$newfile{'sourcepath'} = $unzipdir . $zipname;
 							$newfile{'zipfilename'} = $onefile->{'Name'};
-							$newfile{'zipfilesource'} = $onefile->{'sourcepath'};
-							$newfile{'zipfiledestination'} = $onefile->{'destination'};
 
 							if (( $use_internal_rights ) && ( ! $installer::globals::iswin ))
 							{
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/control.pm solenv/bin/modules/installer/control.pm
--- solenv.bak/bin/modules/installer/control.pm	2007-12-12 16:33:26.000000000 +0100
+++ solenv/bin/modules/installer/control.pm	2008-03-31 14:09:36.349217000 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: control.pm,v $
 #
-#   $Revision: 1.36 $
+#   $Revision: 1.33 $
 #
-#   last change: $Author: kz $ $Date: 2007/12/12 15:33:26 $
+#   last change: $Author: rt $ $Date: 2007/07/03 11:45:26 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -63,7 +63,7 @@
 	
 	if( $^O =~ /cygwin/i )
 	{	# When using cygwin's perl the PATH variable is POSIX style and ...
-		$pathvariable = qx{guw.exe echo "$pathvariable"} ;
+		$pathvariable = qx{guw.pl echo "$pathvariable"} ;
 		# has to be converted to DOS style for further use.
 		$local_pathseparator = ';';
 	}
@@ -111,9 +111,7 @@
 		else
 		{
 			installer::logger::print_message( "\tFound: $$fileref\n" );
-			# Saving the absolut path for msitran.exe. This is required for the determination of the checksum.
-			if ( $onefile eq "msitran.exe" ) { $installer::globals::msitranpath = $$fileref; }
-		}		
+		}
 	}
 
 	if ( $error )
@@ -291,6 +289,101 @@
 }
 
 #############################################################
+# Reading the packagelist
+#############################################################
+
+sub read_packagelist
+{
+	my ($packagelistname) = @_;
+
+	my @packages = ();
+
+	my $packagelist	= installer::files::read_file($packagelistname);
+	
+	for ( my $i = 0; $i <= $#{$packagelist}; $i++ )
+	{
+		my $line = ${$packagelist}[$i];
+
+		if ( $line =~ /^\s*\#/ ) { next; }	# this is a comment line
+
+		if ( $line =~ /^\s*Start\s*$/i ) 	# a new package definition
+		{
+			my %onepackage = ();
+
+			my $counter = $i + 1;
+
+			while (!( ${$packagelist}[$counter] =~ /^\s*End\s*$/i ))
+			{
+				if ( ${$packagelist}[$counter] =~ /^\s*(\S+)\s*\=\s*\"(.*)\"/ )
+				{
+					my $key = $1;
+					my $value = $2;
+					$onepackage{$key} = $value;							
+				}
+				
+				$counter++;	
+			}
+					
+			push(@packages, \%onepackage);	
+		}
+	}
+
+	return \@packages;
+}
+
+##################################################################
+# Controlling the content of the packagelist
+# 1. Items in @installer::globals::packagelistitems must exist
+# 2. If a shellscript file is defined, it must exist
+##################################################################
+
+sub check_packagelist
+{
+	my ($packages) = @_;
+	
+	my $packagepath = $installer::globals::packagelist;
+	installer::pathanalyzer::get_path_from_fullqualifiedname(\$packagepath);
+
+	for ( my $i = 0; $i <= $#{$packages}; $i++ )
+	{
+		my $onepackage = ${$packages}[$i];
+		
+		my $element;
+
+		# checking all items that must be defined
+		
+		foreach $element (@installer::globals::packagelistitems)
+		{	
+			my $value = "";
+			
+			if ( $onepackage->{$element} )
+			{
+				$value = $onepackage->{$element};
+			}
+
+			# Checking the value. All values must not be empty.
+
+			if ( $value eq "" )
+			{
+				installer::logger::print_error( "ERROR in package list: No value for $element !" );
+				usage();
+				exit(-1);
+			}			
+		}
+
+		# checking the existence of the script file, if defined
+
+		if ( $onepackage->{'script'} )
+		{
+			# adding the path to the script name and checking existence
+			my $script = $packagepath . $onepackage->{'script'};
+			installer::files::check_file($script);
+			$onepackage->{'script'} = $script;
+		}
+	}
+}
+
+#############################################################
 # Controlling the log file at the end of the
 # packaging process
 #############################################################
@@ -633,62 +726,4 @@
 	if ( ! $installer::globals::solarjavaset ) { $allvariables->{'XPDINSTALLER'} = 0; }
 }
 
-####################################################################
-# Setting global variable "$installer::globals::addchildprojects"
-####################################################################
-
-sub set_addchildprojects
-{
-	($allvariables) = @_;
-
-	if (( $allvariables->{'JAVAPRODUCT'} ) || 
-		( $allvariables->{'ADAPRODUCT'} ) || 
-		( $allvariables->{'UREPRODUCT'} ) || 
-		( $allvariables->{'ADDREQUIREDPACKAGES'} )) { $installer::globals::addchildprojects = 1; }
-		
-	if ( $installer::globals::patch )
-	{
-		$installer::globals::addchildprojects = 0;	# no child projects for patches
-	}	
-
-	my $infoline = "Value of \$installer::globals::addchildprojects: $installer::globals::addchildprojects\n";
-	push( @installer::globals::globallogfileinfo, $infoline);
-
-}
-
-####################################################################
-# Setting global variable "$installer::globals::addjavainstaller"
-####################################################################
-
-sub set_addjavainstaller
-{
-	($allvariables) = @_;
-
-	if ( $allvariables->{'JAVAINSTALLER'} ) { $installer::globals::addjavainstaller = 1; }
-		
-	if ( $installer::globals::patch ) {	$installer::globals::addjavainstaller = 0; }
-	if ( ( $installer::globals::languagepack ) && ( ! $installer::globals::is_unix_multi ) ) { $installer::globals::addjavainstaller = 0; }
-	if ( $allvariableshashref->{'XPDINSTALLER'} ) {	$installer::globals::addjavainstaller = 0; }
-
-	my $infoline = "Value of \$installer::globals::addjavainstaller: $installer::globals::addjavainstaller\n";
-	push( @installer::globals::globallogfileinfo, $infoline);
-}
-
-#######################################################################
-# Setting global variable "$installer::globals::addsystemintegration"
-#######################################################################
-
-sub set_addsystemintegration
-{
-	($allvariables) = @_;
-
-	if ( $allvariables->{'ADDSYSTEMINTEGRATION'} ) { $installer::globals::addsystemintegration = 1; }
-		
-	if ( $installer::globals::patch ) {	$installer::globals::addsystemintegration = 0; }
-	if ( ( $installer::globals::languagepack ) && ( ! $installer::globals::is_unix_multi ) ) { $installer::globals::addsystemintegration = 0; }
-
-	my $infoline = "Value of \$installer::globals::addsystemintegration: $installer::globals::addsystemintegration\n";
-	push( @installer::globals::globallogfileinfo, $infoline);
-}
-
 1;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/download.pm solenv/bin/modules/installer/download.pm
--- solenv.bak/bin/modules/installer/download.pm	2007-12-12 15:54:35.000000000 +0100
+++ solenv/bin/modules/installer/download.pm	2008-03-31 14:09:36.364841600 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: download.pm,v $
 #
-#   $Revision: 1.34 $
+#   $Revision: 1.31 $
 #
-#   last change: $Author: kz $ $Date: 2007/12/12 14:54:35 $
+#   last change: $Author: hr $ $Date: 2007/06/27 17:48:32 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -423,8 +423,7 @@
 		$languages = "";
 	}	
 
-
-	if ( length ($languages) > $installer::globals::max_lang_length )
+	if ( length ($languages) > 50 )
 	{
 		$languages = 'multi';
 	}
@@ -770,21 +769,6 @@
 }
 
 ##################################################################
-# Windows: Including the Java file name into nsi template 
-##################################################################
-
-sub put_javafilename_into_template
-{
-	my ($templatefile, $variableshashref) = @_;
-	
-	my $javaversion = "";
-	
-	if ( $variableshashref->{'WINDOWSJAVAFILENAME'} ) { $javaversion = $variableshashref->{'WINDOWSJAVAFILENAME'}; }
-	
-	replace_one_variable($templatefile, "WINDOWSJAVAFILENAMEPLACEHOLDER", $javaversion);
-}
-
-##################################################################
 # Windows: Including the product version into nsi template 
 ##################################################################
 
@@ -803,14 +787,10 @@
 
 sub put_windows_productpath_into_template
 {
-	my ($templatefile, $variableshashref, $languagestringref) = @_;
+	my ($templatefile, $variableshashref) = @_;
 	
 	my $productpath = $variableshashref->{'PROPERTYTABLEPRODUCTNAME'};
 	
-	my $locallangs = $$languagestringref;
-	$locallangs =~ s/_/ /g;
-	if ( ! $installer::globals::languagepack ) { $productpath = $productpath . " (" . $locallangs . ")"; }
-	
 	replace_one_variable($templatefile, "PRODUCTPATHPLACEHOLDER", $productpath);
 }
 
@@ -975,7 +955,7 @@
 
 	my $alllangstring = "";
 	my %nsislangs;
- 
+
 	for ( my $i = 0; $i <= $#{$languagesarrayref}; $i++ )
 	{
 		my $onelanguage = ${$languagesarrayref}[$i];
@@ -1566,9 +1546,8 @@
 		put_setup_ico_into_template($templatefile, $includepatharrayref, $allvariableshashref);
 		put_publisher_into_template($templatefile);
 		put_website_into_template($templatefile);
-		put_javafilename_into_template($templatefile, $allvariableshashref);
 		put_windows_productversion_into_template($templatefile, $allvariableshashref);
-		put_windows_productpath_into_template($templatefile, $allvariableshashref, $languagestringref);
+		put_windows_productpath_into_template($templatefile, $allvariableshashref);
 		put_outputfilename_into_template($templatefile, $downloadname);
 		put_filelist_into_template($templatefile, $installationdir);
 		put_language_list_into_template($templatefile, $languagesarrayref);
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/epmfile.pm solenv/bin/modules/installer/epmfile.pm
--- solenv.bak/bin/modules/installer/epmfile.pm	2008-01-14 16:35:21.000000000 +0100
+++ solenv/bin/modules/installer/epmfile.pm	2008-03-31 14:09:36.364841600 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: epmfile.pm,v $
 #
-#   $Revision: 1.74.2.1 $
+#   $Revision: 1.66.36.1 $
 #
-#   last change: $Author: rt $ $Date: 2008/01/14 15:35:21 $
+#   last change: $Author: obo $ $Date: 2007/08/17 07:13:41 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -46,9 +46,7 @@
 use installer::pathanalyzer;
 use installer::remover;
 use installer::scriptitems;
-use installer::systemactions;
 use installer::worker;
-use POSIX;
 
 ############################################################################
 # The header file contains the strings for the epm header in all languages
@@ -157,7 +155,13 @@
 sub put_files_into_epmfile
 {
 	my ($filesinproductarrayref, $epmfileref) = @_;
-
+	my $group = "bin";
+	
+	if ( $installer::globals::islinuxbuild )
+	{
+		$group = "root";
+	}
+	
 	for ( my $i = 0; $i <= $#{$filesinproductarrayref}; $i++ )
 	{
 		my $onefile = ${$filesinproductarrayref}[$i];
@@ -170,14 +174,9 @@
 		my $styles = "";
 		if ( $onefile->{'Styles'} ) { $styles = $onefile->{'Styles'}; }
 		if ( $styles =~ /\bCONFIGFILE\b/ ) { $filetype = "c"; }
-
-		my $group = "bin";
-		if ( $installer::globals::islinuxbuild ) { $group = "root"; }
-		if (( $installer::globals::issolarisbuild ) && ( $onefile->{'SolarisGroup'} )) { $group = $onefile->{'SolarisGroup'}; }
-
 		my $line = "$filetype $unixrights root $group $destination $sourcepath\n";
 			
-		push(@{$epmfileref}, $line);
+		push(@{$epmfileref}, $line)  
 	}
 }
 
@@ -239,7 +238,6 @@
 	my $foundreadmefile = 0;
 
 	my $line = "";
-	my $infoline = "";
 		
 	# %product OpenOffice.org Software
 	# %version 2.0
@@ -353,16 +351,17 @@
 
 	if ( $license_in_package_defined )
 	{
-		my $fileref = installer::scriptitems::get_sourcepath_from_filename_and_includepath(\$licensefilename, "" , 0);
-
-		if ( $$fileref eq "" ) { installer::exiter::exit_program("ERROR: Could not find license file $licensefilename!", "create_epm_header"); }
-
-		$infoline = "Using license file: \"$$fileref\"!\n";
-		push(@installer::globals::logfileinfo, $infoline);
-
-		$foundlicensefile = 1;
-		$line = "%license" . " " . $$fileref . "\n";
-		push(@epmheader, $line);
+		# Copyright file has to be located next to the package list
+		my $path = $installer::globals::absolutepackagelistpath;
+		installer::pathanalyzer::get_path_from_fullqualifiedname(\$path);
+		$licensefilename = $path . $licensefilename;
+		
+		if ( -f $licensefilename )
+		{
+			$foundlicensefile = 1;
+			$line = "%license" . " " . $licensefilename . "\n";
+			push(@epmheader, $line);
+		}	
 	}
 	else
 	{
@@ -432,7 +431,7 @@
 				}
 			}
 
-			if ( $installer::globals::debian && $variableshashref->{'UNIXPRODUCTNAME'} eq 'openoffice.org' )
+			if ( $installer::globals::debian )
 			{
 				$line = "%provides" . " openoffice.org-unbundled\n";
 				push(@epmheader, $line);
@@ -813,11 +812,8 @@
 	my $ldpreloadstring = "";
 	
 	if ( $installer::globals::debian ) { $ldpreloadstring = get_ld_preload_string($includepatharrayref) . " "; }
-
-	my $extraflags = "";
-        if ($ENV{'EPM_FLAGS'}) { $extraflags = $ENV{'EPM_FLAGS'}; }
 	
-	my $systemcall = $ldpreloadstring . $epmname . " -f " . $packageformat . " " . $extraflags . " " . $localpackagename . " " . $epmlistfilename . $outdirstring . " -v " . " 2\>\&1 |";
+	my $systemcall = $ldpreloadstring . $epmname . " -f " . $packageformat . " " . $localpackagename . " " . $epmlistfilename . $outdirstring . " -v " . " 2\>\&1 |";
 
 	installer::logger::print_message( "... $systemcall ...\n" );
 
@@ -1207,29 +1203,6 @@
 }
 
 #####################################################################
-# Setting the requirements in the spec file (i81494)
-# Syntax: PreReq: "requirements" (only for shared extensions)
-#####################################################################
-
-sub set_prereq_in_specfile
-{
-	my ($changefile) = @_;
-
-	my $prereq = "PreReq:"; 
-
-	for ( my $i = 0; $i <= $#{$changefile}; $i++ )
-	{
-		if ( ${$changefile}[$i] =~ /^\s*Requires:\s*(.+?)\s*$/ )
-		{
-			my $oldstring = ${$changefile}[$i];
-			${$changefile}[$i] =~ s/Requires:/$prereq/;
-			my $infoline = "Info: Changed requirements in spec file from $oldstring to ${$changefile}[$i]!\n";
-			push( @installer::globals::logfileinfo, $infoline);			
-		}	
-	}
-}
-
-#####################################################################
 # Setting the Auto[Req]Prov line and __find_requires
 #####################################################################
 
@@ -1339,28 +1312,6 @@
 }
 
 #########################################################################
-# Replacing the variables in the Solaris patch shell scripts.
-# Taking care, that multiple slashes are not always removed.
-#########################################################################
-
-sub replace_variables_in_shellscripts_for_patch
-{
-	my ($scriptfile, $scriptfilename, $oldstring, $newstring) = @_;
-
-	for ( my $i = 0; $i <= $#{$scriptfile}; $i++ )
-	{
-		if ( ${$scriptfile}[$i] =~ /\Q$oldstring\E/ )
-		{
-			my $oldline = ${$scriptfile}[$i];
-			if (( $oldstring eq "PRODUCTDIRECTORYNAME" ) && ( $newstring eq "" )) { $oldstring = $oldstring . "/"; }
-			${$scriptfile}[$i] =~ s/\Q$oldstring\E/$newstring/g;
-			my $infoline = "Info: Substituting in $scriptfilename $oldstring by $newstring\n";
-			push(@installer::globals::logfileinfo, $infoline);
-		}
-	}	
-}
-
-#########################################################################
 # Replacing the variables in the shell scripts or in the epm list file
 # Linux: spec file
 # Solaris: preinstall, postinstall, preremove, postremove
@@ -1530,65 +1481,13 @@
 	}
 }
 
-##########################################################################################
-# Checking, if an extension is included into the package (Linux).
-# All extension files have to be installed into directory
-# share/extension/install
-# %attr(0444,root,root) "/opt/staroffice8/share/extension/install/SunSearchToolbar.oxt"
-##########################################################################################
-
-sub is_extension_package
-{
-	my ($specfile) = @_;
-	
-	my $is_extension_package = 0;
-
-	for ( my $i = 0; $i <= $#{$specfile}; $i++ )
-	{
-		my $line = ${$specfile}[$i];
-		if ( $line =~ /share\/extension\/install\/(\w+?)\.oxt\"\s*$/ )
-		{
-			$is_extension_package = 1;
-			last;
-		}
-	}
-
-	return $is_extension_package;
-}
-
-######################################################################
-# Checking, if an extension is included into the package (Solaris).
-# All extension files have to be installed into directory
-# share/extension/install
-######################################################################
-
-sub get_extension_name
-{
-	my ($prototypefile) = @_;
-	
-	my $extensionName = "";
-
-	for ( my $i = 0; $i <= $#{$prototypefile}; $i++ )
-	{
-		my $line = ${$prototypefile}[$i];
-		if ( $line =~ /^\s*f\s+none\s+share\/extension\/install\/(\w+?\.oxt)\s*\=/ )
-		{
-			$extensionName = $1;
-			last;
-		}
-	}
-	
-	return $extensionName;
-}
-
-
 ############################################################
 # A Solaris patch contains 7 specific scripts
 ############################################################
 
 sub add_scripts_into_prototypefile
 {
-	my ($prototypefile, $prototypefilename, $languagestringref, $staticpath) = @_;
+	my ($prototypefile) = @_;
 	
 	# The files are stored in the directory $installer::globals::patchincludepath
 	# The file names are available via @installer::globals::solarispatchscripts
@@ -1598,52 +1497,11 @@
 	$path = $path . $installer::globals::separator;
 
 	my @newlines = ();
-	my $extensionname = get_extension_name($prototypefile);
-
-	if ( $extensionname ne "" )
-	{	
-		for ( my $i = 0; $i <= $#installer::globals::solarispatchscriptsforextensions; $i++ )
-		{
-			my $sourcefilename = $path . $installer::globals::solarispatchscriptsforextensions[$i];
-			my $destfile = $installer::globals::solarispatchscriptsforextensions[$i];
-
-			# If the sourcepath has "_extension" in its name, this has to be removed
-			$destfile =~ s/_extensions\s*$//;  # hard coded renaming of script name
-
-			# Creating unique directory name with $prototypefilename
-			my $extensiondir = installer::systemactions::create_directories("extensionscripts", $languagestringref);
-
-			if ( $prototypefilename =~ /\/(\S*?)\s*$/ ) { $prototypefilename = $1; }
-			$prototypefilename =~ s/\./_/g;
-			my $destdir = $extensiondir . $installer::globals::separator . $prototypefilename;
-			if ( ! -d $destdir ) { installer::systemactions::create_directory($destdir); }
-			my $destpath = $destdir . $installer::globals::separator . $destfile;
-			if ( -f $destpath ) { unlink($destpath); }
-			
-			# Reading file
-			my $scriptfile = installer::files::read_file($sourcefilename);
-
-			# Replacing variables
-			my $oldstring = "\$\{OXTFILENAME\}";
-			replace_variables_in_shellscripts_for_patch($scriptfile, $destpath, $oldstring, $extensionname);
-			$oldstring = "PRODUCTDIRECTORYNAME";
-			replace_variables_in_shellscripts_for_patch($scriptfile, $destpath, $oldstring, $staticpath);
-			
-			# Saving file
-			installer::files::save_file($destpath, $scriptfile);
-			
-			# Writing file destination into prototype file
-			my $line = "i $destfile=" . $destpath . "\n";
-			push(@newlines, $line);
-		}		
-	}
-	else
+	
+	for ( my $i = 0; $i <= $#installer::globals::solarispatchscripts; $i++ )
 	{
-		for ( my $i = 0; $i <= $#installer::globals::solarispatchscripts; $i++ )
-		{
-			my $line = "i $installer::globals::solarispatchscripts[$i]=" . $path . $installer::globals::solarispatchscripts[$i] . "\n";
-			push(@newlines, $line);
-		}
+		my $line = "i $installer::globals::solarispatchscripts[$i]=" . $path . $installer::globals::solarispatchscripts[$i] . "\n";
+		push(@newlines, $line);
 	}	
 	
 	# Including the new lines after the last line starting with "i"
@@ -1862,7 +1720,6 @@
 
 	if ( $installer::globals::islinuxrpmbuild )
 	{
-		if ( $localrelocatablepath =~ /^\s*$/ ) { $localrelocatablepath = "/"; }; # at least the "/"
 		$filename =  $packagename . ".spec";
 		$newline = "Prefix\:\ " . $localrelocatablepath . "\n";
 	}	
@@ -1884,7 +1741,6 @@
 		set_topdir_in_specfile($changefile, $filename, $newepmdir);
 		set_autoprovreq_in_specfile($changefile, $onepackage->{'findrequires'}, "$installer::globals::unpackpath" . "/bin");
 		set_packager_in_specfile($changefile);
-		if ( is_extension_package($changefile) ) { set_prereq_in_specfile($changefile); }
 		set_license_in_specfile($changefile, $variableshashref);
 		set_tab_into_datafile($changefile, $filesref);
 		# check_requirements_in_specfile($changefile);
@@ -1918,7 +1774,7 @@
 			installer::files::save_file($completefilename, $changefile);
 		}
 
-		if ( $installer::globals::patch ) { add_scripts_into_prototypefile($prototypefile, $prototypefilename, $languagestringref, $staticpath); }
+		if ( $installer::globals::patch ) { add_scripts_into_prototypefile($prototypefile); }
 		
 		installer::files::save_file($prototypefilename, $prototypefile);
 		if ( $installer::globals::patch ) { collect_patch_files($prototypefile, $packagename, ""); }
@@ -2248,7 +2104,6 @@
 		elsif ( $installer::globals::compiler =~ /unxlngs/) { $target = "sparc"; }
 		elsif ( $installer::globals::compiler =~ /unxlngppc64/) {$target = "ppc64"; }
 		elsif ( $installer::globals::compiler =~ /unxlngppc/) {$target = "ppc"; }
-		elsif ( $installer::globals::compiler =~ /unxlng/) {$target = (POSIX::uname())[4]; }
 		
 		my $systemcall = "$rpmcommand -bb $specfilename --target $target 2\>\&1 |";
 
@@ -2427,17 +2282,11 @@
 	if ( $installer::globals::islinuxrpmbuild )
 	{
 		my $rpmdir;
-                my $machine = "";
 		if ( $installer::globals::compiler =~ /unxlngi/) { $rpmdir = "$installer::globals::epmoutpath/RPMS/i586"; }
 		elsif ( $installer::globals::compiler =~ /unxlngx/) { $rpmdir = "$installer::globals::epmoutpath/RPMS/x86_64"; }
 		elsif ( $installer::globals::compiler =~ /unxlngs/) { $rpmdir = "$installer::globals::epmoutpath/RPMS/sparc"; }
 		elsif ( $installer::globals::compiler =~ /unxlngppc64/) { $rpmdir = "$installer::globals::epmoutpath/RPMS/ppc64"; }
 		elsif ( $installer::globals::compiler =~ /unxlngppc/) { $rpmdir = "$installer::globals::epmoutpath/RPMS/ppc"; }
-		elsif ( $installer::globals::compiler =~ /unxlng/) { 
-                    $machine = (POSIX::uname())[4]; 
-                    $rpmdir = "$installer::globals::epmoutpath/RPMS/$machine"; 
-                }
-                else { installer::exiter::exit_program("ERROR: rpmdir undefined !", "create_new_directory_structure"); }
 
 		my $systemcall = "mv $rpmdir/* $newdir";	# moving the rpms into the directory "RPMS"
 
@@ -2459,10 +2308,6 @@
 
 		# and removing the empty directory
 
-		if ( $machine ne "" )
-		{
-			installer::systemactions::remove_empty_directory("$installer::globals::epmoutpath/RPMS/$machine");
-		}
 		installer::systemactions::remove_empty_directory("$installer::globals::epmoutpath/RPMS/x86_64");
 		installer::systemactions::remove_empty_directory("$installer::globals::epmoutpath/RPMS/i586");
 		installer::systemactions::remove_empty_directory("$installer::globals::epmoutpath/RPMS/i386");
@@ -2590,7 +2435,7 @@
 		my $onemodule = ${$allmodules}[$i];
 		my $packagename = $onemodule->{'PackageName'};
 		$sourcefile = $sopackpath . $installer::globals::separator . $installer::globals::compiler . $installer::globals::separator . $subdir . $installer::globals::separator . $packagename;
-		if ( ! -f $sourcefile ) { installer::exiter::exit_program("ERROR: File not found: $sourcefile !", "copy_childproject_files"); }
+		if ( ! -f $sourcefile ) { installer::exiter::exit_program("ERROR: File not found: $sourcefile !", "put_childprojects_into_installset"); }
 		installer::systemactions::copy_one_file($sourcefile, $destdir);
 		# Solaris: unpacking tar.gz files and setting new packagename
 		if ( $installer::globals::issolarispkgbuild ) { $packagename = unpack_tar_gz_file($packagename, $destdir); }
@@ -2628,7 +2473,7 @@
 
 	my $sopackpath = "";
 	if ( $ENV{'SO_PACK'} ) { $sopackpath  = $ENV{'SO_PACK'}; }
-	else { installer::exiter::exit_program("ERROR: Environment variable SO_PACK not set!", "put_childprojects_into_installset"); }
+	else { installer::exiter::exit_program("ERROR: Environment variable SO_PACK not set!", "add_childprojects"); }
 
 	my $destdir = "$newdir";
 
@@ -2763,6 +2608,7 @@
 		{
 			installer::xpdinstaller::create_xpd_file_for_systemintegration($onemodule, $newcontent, $modulesarrayref, $subdir);
 		}
+
 	}
 }
 
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/files.pm solenv/bin/modules/installer/files.pm
--- solenv.bak/bin/modules/installer/files.pm	2008-01-02 18:32:14.000000000 +0100
+++ solenv/bin/modules/installer/files.pm	2008-03-31 14:09:36.364841600 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: files.pm,v $
 #
-#   $Revision: 1.6.920.1 $
+#   $Revision: 1.6 $
 #
-#   last change: $Author: hr $ $Date: 2008/01/02 17:32:14 $
+#   last change: $Author: rt $ $Date: 2005/09/08 09:03:17 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -57,19 +57,11 @@
 sub read_file
 {
 	my ($localfile) = @_;
-	my @localfile = ();
 
 	if ( $installer::globals::debug ) { installer::logger::debuginfo("installer::files::read_file : $localfile"); }
 
 	open( IN, "<$localfile" ) || installer::exiter::exit_program("ERROR: Cannot open file $localfile for reading", "read_file");
-
-#	Don't use "my @localfile = <IN>" here, because
-#	perl has a problem with the internal "large_and_huge_malloc" function
-#	when calling perl using MacOS 10.5 with a perl built with MacOS 10.4
-	while ( $line = <IN> ) {
-		push @localfile, $line;
-	}
-
+	my @localfile = <IN>;
 	close( IN );
 
 	return \@localfile;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/globals.pm solenv/bin/modules/installer/globals.pm
--- solenv.bak/bin/modules/installer/globals.pm	2008-03-26 20:30:18.930875000 +0100
+++ solenv/bin/modules/installer/globals.pm	2008-03-31 14:49:55.209167600 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: globals.pm,v $
 #
-#   $Revision: 1.81.2.2 $
+#   $Revision: 1.71 $
 #
-#   last change: $Author: rt $ $Date: 2008/01/14 19:07:35 $
+#   last change: $Author: ihi $ $Date: 2007/07/11 14:40:26 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -44,8 +44,7 @@
 	$prog="make_installer.pl";
 
 	@noMSLocaleLangs = ( "br", "dz", "km", "nr", "ns", "rw", "ss", "st", "tg", "ts", "tn", "ve", "xh", "zu" , "ne" , "bn", "bn-BD", "bn-IN", "lo", "cy" , "ku" , "as-IN" , "te-IN" , "ml-IN" , "mr-IN", "ur-IN", "ta-IN", "or-IN" , "ti-ER" , "eo" , "ka" ,"ga" , "uk"  );
-	@asianlanguages = ("ja", "ko", "zh-CN", "zh-TW");
-	
+
 	$ziplistname = "";
 	$pathfilename = "";
 	$setupscriptname = "";
@@ -70,6 +69,7 @@
 	$dounzip = 1;
 	$languages_defined_in_productlist = 0;
 	$setupscript_defined_in_productlist = 0;
+	$use_default_ziplist = 0;
 	$services_rdb_created = 0;
 	$servicesrdb_can_be_created = 0;
 	$islinux = 0;	
@@ -96,12 +96,7 @@
 	$officefolder = "OfficeFolder";
 	$officemenufolder = "OfficeMenuFolder";
 	$startupfolder = "StartupFolder";
-	$startmenufolder = "StartMenuFolder";
-	$desktopfolder = "DesktopFolder";
 	$programfilesfolder = "ProgramFilesFolder";
-	$commonfilesfolder = "CommonFilesFolder";
-	$commonappdatafolder = "CommonAppDataFolder";
-	$localappdatafolder = "LocalAppDataFolder";
 	$templatefolder = "TemplateFolder";
 	$templatefoldername = "Templates";
 	$programmenufolder = "ProgramMenuFolder";
@@ -125,7 +120,6 @@
 	$saved_packages_path = "";
 	$max_lang_length = 50;
 	$globalblock = "Globals";
-	$rootmodulegid = "";
 	
 	$is_special_epm = 0;
 	$epm_in_path = 0;
@@ -139,6 +133,7 @@
 	$packageformat = "";
 	$packagename = "";
 	$packagelist = "";
+	$absolutepackagelistpath = "";
 	$addpackagelist = "";
 	$is_unix_multi = 0;
 	$unixmultipath = "";
@@ -154,7 +149,6 @@
 	$linuxlibrarypatchlevel = "1.1";
 	@linuxlinks = ();
 	@linkrpms = ();
-        $archiveformat = "";
 	
 	$strip = 1;
 	$solarjava = 0;
@@ -196,16 +190,8 @@
 	@allddffiles = ();
 	$infodirectory = "";
 	$currentcontent = "";
-
-	%mergemodules = ();
-	%merge_media_line = ();
-	%merge_allfeature_hash = ();
-	%merge_alldirectory_hash = ();
-	%copy_msm_files = ();
-	$mergefeaturecollected = 0;
-	$mergedirectoriescollected = 0;
-	$lastsequence_before_merge = 0;
 	
+	$addjavainstaller = 0;
 	$createdxpddefaultlang = 0;
 	$xpddir = "";
 	$productxpdfile = "setup.xpd";
@@ -219,11 +205,10 @@
 	$javasettozero = 0;
 	$addlicensefile = 1;
 	$addsystemintegration = 0;
-	$addjavainstaller = 0;
 	$added_directories = 0;
 	$makedownload = 1;
 	$makejds = 1;
-	$jdsexcludefilename = "";
+	$jdsexcludefilename ="";
 	$jds_language_controlled = 0;
 	$correct_jds_language = 0;
 	$islanguagepackinunixmulti = 0;
@@ -236,11 +221,9 @@
 	$downloadfilename = "";
 	$downloadfileextension = "";
 	$oooversionstring = "";
-	$shellnewfilesadded = 0;
 
 	$is_copy_only_project = 0;
 	$is_simple_packager_project = 0;
-	$patch_user_dir = 0;
 	$addchildprojects = 0;
 	$languagepack = 0;
 	$tab = 0;
@@ -262,12 +245,10 @@
 	$cabfilecompressionlevel = 2;
 	$number_of_cabfiles = 1;	# only for $fix_number_of_cab_files = 1 
 	$include_cab_in_msi = 0;
-	$use_packages_for_cabs = 0;
 	$msidatabasename = "";
 	$prepare_winpatch = 1;
 	$previous_idt_dir = "";	
 	$updatepack = 0;
-	$msitranpath = "";
 
 	$saveinstalldir = "";
 	$csp_installdir = "";       # global installdir of createsimplepackage() in simplepackage.pm
@@ -287,12 +268,10 @@
 	$subdir = "";
 	$postprocess_specialepm = 0;
 	$postprocess_standardepm = 0;
-	$mergemodules_analyzed = 0;
 	
 	$starttime = "";
 
 	@solarispatchscripts = ("checkinstall", "copyright", "patch_checkinstall", "patch_postinstall", "postinstall", "preinstall", "i.none");
-	@solarispatchscriptsforextensions = ("checkinstall", "copyright", "patch_checkinstall", "patch_postinstall_extensions", "postinstall_extensions", "preinstall", "i.none");
 	@solarispatchfiles = (".diPatch", "patchinfo");
 	@environmentvariables = ( "SOLARVERSION", "GUI", "WORK_STAMP", "OUTPATH", "LOCAL_OUT", "LOCAL_COMMON_OUT" );
 	@packagelistitems = ("module", "solarispackagename", "packagename", "copyright", "vendor", "description" );
@@ -307,14 +286,7 @@
 	@languagenames = ();
 	@requiredpackages = ();
 	%componentconditions = ();
-	%allcabinets = ();
-	%allcabinetassigns = ();
-	%cabfilecounter = ();
-	%lastsequence = ();
-	%dontdeletecomponents = ();
 
-	@forced_properties = ("SERVICETAG_PRODUCTNAME", "SERVICETAG_PRODUCTVERSION", "SERVICETAG_PARENTNAME", "SERVICETAG_SOURCE", "SERVICETAG_URN");
-	
 	@removedirs = ();
 	@jdsremovedirs = ();
 	@emptypackages = ();
@@ -343,7 +315,6 @@
 		$libextension = "\.dll";
 		$isunix = 0;
 		$iswin = 1;
-                $archiveformat = ".zip";
 		$wrapcmd = "";
 		%savedmapping = ();
 		%savedrevmapping = ();
@@ -368,7 +339,6 @@
 		} else {
 		    $wrapcmd = "";
 		}
-                $archiveformat = ".zip";
 		%savedmapping = ();
 		%savedrevmapping = ();
 		%savedrev83mapping = ();
@@ -385,12 +355,10 @@
 		if ( $plat =~ /darwin/i )
 		{
 			$libextension = "\.dylib";
-			$archiveformat = ".dmg";
 		}
 		else
 		{
 			$libextension = "\.so";  
-			$archiveformat = ".tar.gz";
 		}
 		$quote = "\'";
 		$isunix = 1;
Only in solenv/bin/modules/installer: globals.pm~
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/javainstaller.pm solenv/bin/modules/installer/javainstaller.pm
--- solenv.bak/bin/modules/installer/javainstaller.pm	2008-01-08 16:12:53.000000000 +0100
+++ solenv/bin/modules/installer/javainstaller.pm	2008-03-31 14:09:36.364841600 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: javainstaller.pm,v $
 #
-#   $Revision: 1.26.514.1 $
+#   $Revision: 1.26 $
 #
-#   last change: $Author: rt $ $Date: 2008/01/08 15:12:53 $
+#   last change: $Author: vg $ $Date: 2006/09/08 08:05:23 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -631,9 +631,6 @@
 			my $line = ${$xmlfile}[$startline];
 			if (($line =~ /^\s*\Q$namestring\E\s*\=/) && ($line =~ /\-\Q$searchstring\E/)) { $do_delete = 1; }
 			
-			# but not deleting fonts package in language packs
-			if ( $line =~ /-ONELANGUAGE-/ ) { $do_delete = 0; }
-			
 			my $endcounter = 0;
 			
 			while ((!( $line =~ /\/\>/ )) && ( $startline <= $#{$xmlfile} ))
@@ -648,8 +645,6 @@
 			
 			if ( $do_delete )
 			{
-				my $infoline = "\tReally removing package $packagename from xml file.\n";
-				push( @installer::globals::logfileinfo, $infoline);
 				splice(@{$xmlfile},$i, $linecounter);	# removing $linecounter lines, beginning in line $i
 				last;
 			}
@@ -816,7 +811,6 @@
 
 	my $unit = remove_component($xmlfile, "languagepack_ONELANGUAGE");	
 	my $startline = find_component_line($xmlfile, "module_languagepacks");
-	my $infoline = "";
 	$startline = $startline + 1;
 	
 	for ( my $i = 1; $i <= $#installer::globals::languageproducts; $i++ )	# starting at "1", because "0" (first language) is no languagepack!
@@ -830,7 +824,7 @@
 		# not for all languages exist a font package
 		if ( ! $installer::globals::fontpackageexists{$onelanguage} )
 		{
-			$infoline = "Java installer: Removing font package for language $onelanguage\n";
+			my $infoline = "Java installer: Removing font package for language $onelanguage\n";
 			push( @installer::globals::logfileinfo, $infoline);
 			remove_font_package_from_unit($unitcopy, $onelanguage);
 		}
@@ -868,9 +862,9 @@
 	for ( my $i = 0; $i <= $#installer::globals::emptypackages; $i++ )
 	{
 		my $packagename = $installer::globals::emptypackages[$i];
-		my $infoline = "Try to remove package $packagename from xml file.\n";
-		push( @installer::globals::logfileinfo, $infoline);
 		remove_package($xmlfile, $packagename);
+		my $infoline = "Removing package $packagename from xml file.\n";
+		push( @installer::globals::logfileinfo, $infoline);
 	}
 }
 
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/languagepack.pm solenv/bin/modules/installer/languagepack.pm
--- solenv.bak/bin/modules/installer/languagepack.pm	2007-09-06 11:52:02.000000000 +0200
+++ solenv/bin/modules/installer/languagepack.pm	2008-03-31 14:09:36.364841600 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: languagepack.pm,v $
 #
-#   $Revision: 1.13 $
+#   $Revision: 1.11 $
 #
-#   last change: $Author: kz $ $Date: 2007/09/06 09:52:02 $
+#   last change: $Author: rt $ $Date: 2007/02/19 13:48:44 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -82,29 +82,25 @@
 		for ( my $j = 0; $j <= $#{$languagesarrayref}; $j++ )	# iterating over all languages
 		{
 			my $onelanguage = ${$languagesarrayref}[$j];
-			my $locallang = $onelanguage;
-			$locallang =~ s/-/_/;
 			
 			if ( $specificlanguage eq $onelanguage )
 			{
-				# $oneitem->{'modules'} = $installer::globals::rootmodulegid; 	 # all files in a language pack are root files
-				# Using $installer::globals::languagemodulesbase (?)
-				$oneitem->{'modules'} = $installer::globals::rootmodulegid . "_$locallang"; 	 # all files in a language pack are root files
+				$oneitem->{'modules'} = "gid_Module_Root"; 	 # all files in a language pack are root files
 
 				if (( $installer::globals::islinuxbuild ) || ( $installer::globals::issolarispkgbuild ))
 				{
 					if ( $oneitem->{'Dir'} )
 					{
-						if ( $oneitem->{'Dir'} eq "gid_Dir_Fonts_Truetype" ) { $oneitem->{'modules'} = "gid_Module_Langpack_Fonts_$locallang"; }
-						if ( $oneitem->{'Dir'} eq "gid_Dir_Resource" ) { $oneitem->{'modules'} = "gid_Module_Langpack_Resource_$locallang"; }
-						if ( $oneitem->{'Dir'} eq "gid_Dir_Help_Isolanguage" ) { $oneitem->{'modules'} = "gid_Module_Langpack_Help_$locallang"; }
+						if ( $oneitem->{'Dir'} eq "gid_Dir_Fonts_Truetype" ) { $oneitem->{'modules'} = "gid_Module_Langpack_Fonts"; }
+						if ( $oneitem->{'Dir'} eq "gid_Dir_Resource" ) { $oneitem->{'modules'} = "gid_Module_Langpack_Resource"; }
+						if ( $oneitem->{'Dir'} eq "gid_Dir_Help_Isolanguage" ) { $oneitem->{'modules'} = "gid_Module_Langpack_Help"; }
 					}
 				}
 
 				# preparing different modules for Windows Installer language packs
-				# my $underlinelanguage = $specificlanguage;
-				# $underlinelanguage =~ s/-/_/;
-				# if ( $installer::globals::iswindowsbuild ) { $oneitem->{'modules'} = $installer::globals::languagemodulesbase . $underlinelanguage; }
+				my $underlinelanguage = $specificlanguage;
+				$underlinelanguage =~ s/-/_/;
+				if ( $installer::globals::iswindowsbuild ) { $oneitem->{'modules'} = $installer::globals::languagemodulesbase . $underlinelanguage; }
 				
 				if (! installer::existence::exists_in_array($oneitem->{'modules'}, \@installer::globals::languagepackfeature))
 				{
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/languages.pm solenv/bin/modules/installer/languages.pm
--- solenv.bak/bin/modules/installer/languages.pm	2007-10-15 15:34:48.000000000 +0200
+++ solenv/bin/modules/installer/languages.pm	2008-03-31 14:09:36.364841600 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: languages.pm,v $
 #
-#   $Revision: 1.12 $
+#   $Revision: 1.10 $
 #
-#   last change: $Author: vg $ $Date: 2007/10/15 13:34:48 $
+#   last change: $Author: rt $ $Date: 2007/07/06 12:25:24 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -52,19 +52,6 @@
 	
 	$first =~ s/\_/\,/g;	# substituting "_" by ",", in case of dmake definition 01_49
 
-	# Checking if this is a multilingual installation set on Unix (languagelist contains ",")
-	# Products are separated by a "#", if defined in zip-list by a "|". But "get_info_about_languages" 
-	# substitutes already "|" to "#". This procedure only knows "#" as product separator.
-	# Different languages for one product are separated by ",". But on the command line the "_" is used.
-	# Therefore "_" is replaced by "," at the beginning of this procedure.
-	
-	if (( $installer::globals::compiler =~ /unx/ ) && ( $first =~ /\,/ ))
-	{
-		$installer::globals::is_unix_multi = 1;
-		my $infoline = "This is a multilingual unix product (\$installer::globals::is_unix_multi set true)\n";
-		push(@installer::globals::globallogfileinfo, $infoline);
-	}
-
 	if ( $installer::globals::is_unix_multi )
 	{
 		if ( $installer::globals::languagelist =~ /\#/ )
@@ -286,14 +273,17 @@
 	return ${$languagesref}[0];		# ToDo, only returning the first language
 }
 
-#############################################################
-# Contains the installation set one of the asian languages?
-#############################################################
+##########################################################
+# Contains the installation set one of the languages
+# ja, ko, zh-CH, or zh-TW ?
+##########################################################
 
 sub detect_asian_language
 {
 	my ($languagesref) = @_;
 
+	my @asianlanguages = ("ja", "ko", "zh-CN", "zh-TW");	
+
 	my $containsasia = 0;
 
 	for ( my $i = 0; $i <= $#{$languagesref}; $i++ )
@@ -301,9 +291,9 @@
 		my $onelang = ${$languagesref}[$i];
 		$onelang =~ s/\s*$//;
 
-		for ( my $j = 0; $j <= $#installer::globals::asianlanguages; $j++ )
+		for ( my $j = 0; $j <= $#asianlanguages; $j++ )
 		{
-			my $asialang = $installer::globals::asianlanguages[$j];
+			my $asialang = $asianlanguages[$j];
 			$asialang =~ s/\s*$//;
 			
 			if ( $onelang eq $asialang )
@@ -319,43 +309,39 @@
 	return $containsasia;
 }
 
-#############################################################
-# Contains the installation set only asian languages?
-#############################################################
+################################################################
+# Contains the installation set one of the western languages
+# ja, ko, zh-CH, or zh-TW ?
+################################################################
 
-sub contains_only_asian_languages
+sub detect_western_language
 {
 	my ($languagesref) = @_;
 
-	my $onlyasian = 1;
+	my @westernlanguages = ("en-US","pt","ru","el","nl","fr","es","fi","hu","ca","sl","it","cs","sk","en-GB","da","sv","no","pl","de","pt-BR","th","et","tr","hi-IN","ar","he");	
+
+	my $containswestern = 0;
 
 	for ( my $i = 0; $i <= $#{$languagesref}; $i++ )
 	{
 		my $onelang = ${$languagesref}[$i];
 		$onelang =~ s/\s*$//;
 
-		if (! installer::existence::exists_in_array($onelang, \@installer::globals::asianlanguages))		
+		for ( my $j = 0; $j <= $#westernlanguages; $j++ )
 		{
-			$onlyasian = 0;
-			last;
+			my $westernlang = $westernlanguages[$j];
+			$westernlang =~ s/\s*$//;
+			
+			if ( $onelang eq $westernlang )
+			{
+				$containswestern = 1;
+				last;
+			}
 		}
+		
+		if ( $containswestern ) { last; }
 	}
 
-	return $onlyasian;
-}
-
-################################################################
-# Contains the installation set one of the western languages
-################################################################
-
-sub detect_western_language
-{
-	my ($languagesref) = @_;
-
-	my $containswestern = 1;
-	
-	if ( contains_only_asian_languages($languagesref) ) { $containswestern = 0; }
-
 	return $containswestern;
 }
 
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/mail.pm solenv/bin/modules/installer/mail.pm
--- solenv.bak/bin/modules/installer/mail.pm	2008-01-15 12:17:52.000000000 +0100
+++ solenv/bin/modules/installer/mail.pm	2008-03-31 14:09:36.380466200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: mail.pm,v $
 #
-#   $Revision: 1.6.920.1 $
+#   $Revision: 1.6 $
 #
-#   last change: $Author: rt $ $Date: 2008/01/15 11:17:52 $
+#   last change: $Author: rt $ $Date: 2005/09/08 09:05:38 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -71,8 +71,6 @@
 
 	my @message = ();
 	
-	my $recipient_string = join ',', @listener;
-	push(@message, "To: $recipient_string\n");
 	push(@message, "Subject: $subject");
 	push(@message, "\n");
 	push(@message, "Located at $destdir");
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/packagelist.pm solenv/bin/modules/installer/packagelist.pm
--- solenv.bak/bin/modules/installer/packagelist.pm	2007-09-07 12:56:57.000000000 +0200
+++ solenv/bin/modules/installer/packagelist.pm	2008-03-31 14:09:36.380466200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: packagelist.pm,v $
 #
-#   $Revision: 1.13 $
+#   $Revision: 1.10 $
 #
-#   last change: $Author: vg $ $Date: 2007/09/07 10:56:57 $
+#   last change: $Author: ihi $ $Date: 2007/07/12 11:15:50 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -36,10 +36,7 @@
 package installer::packagelist;
 
 use installer::converter;
-use installer::exiter;
-use installer::globals;
 use installer::remover;
-use installer::scriptitems;
 
 ########################################
 # Check existence of module
@@ -380,8 +377,7 @@
 # Directories are included into the package, if they are needed
 # by a file or a link included into the package. 
 # Attention: A directory with the flag CREATE, is only included
-# into the root module:
-# ($packagename eq $installer::globals::rootmodulegid)
+# into the root module ($packagename eq gid_Module_Root)
 #####################################################################
 
 sub find_dirs_for_package
@@ -452,9 +448,9 @@
 			}		
 		}
 
-		# also investigating the flag CREATE (only added to $installer::globals::rootmodulegid)
+		# also investigating the flag CREATE (only added to gid_Module_Root)
 		
-		if (( ! $includedir ) && ( $packagename eq $installer::globals::rootmodulegid ))
+		if (( ! $includedir ) && ( $packagename eq "gid_Module_Root" ))
 		{
 			my $styles = "";
 			
@@ -493,327 +489,4 @@
 	}
 }
 
-#####################################################################
-# New packages system.
-#####################################################################
-
-##################################################################
-# Controlling the content of the packagelist
-# 1. Items in @installer::globals::packagelistitems must exist
-# 2. If a shellscript file is defined, it must exist
-##################################################################
-
-sub check_packagelist
-{
-	my ($packages) = @_;
-	
-	if ( ! ( $#{$packages} > -1 )) { installer::exiter::exit_program("ERROR: No packages defined!", "check_packagelist"); }
-
-	for ( my $i = 0; $i <= $#{$packages}; $i++ )
-	{
-		my $onepackage = ${$packages}[$i];
-		
-		my $element;
-
-		# checking all items that must be defined
-		
-		foreach $element (@installer::globals::packagelistitems)
-		{	
-			if ( ! exists($onepackage->{$element}) )
-			{
-				installer::exiter::exit_program("ERROR in package list: No value for $element !", "check_packagelist");
-			}			
-		}
-
-		# checking the existence of the script file, if defined
-
-		if ( $onepackage->{'script'} )
-		{
-			my $scriptfile = $onepackage->{'script'};
-			my $gid =  $onepackage->{'module'};
-			my $fileref = installer::scriptitems::get_sourcepath_from_filename_and_includepath(\$scriptfile, "" , 0);
-
-			if ( $$fileref eq "" ) { installer::exiter::exit_program("ERROR: Could not find script file $scriptfile for module $gid!", "check_packagelist"); }
-
-			my $infoline = "$gid: Using script file: \"$$fileref\"!\n";
-			push( @installer::globals::logfileinfo, $infoline);
-
-			$onepackage->{'script'} = $$fileref;
-		}
-	}
-}
-
-#####################################################################
-# Reading pack info for one module from packinfo file.
-#####################################################################
-
-sub get_packinfo
-{
-	my ($gid, $filename, $packages, $onelanguage, $scplanguage) = @_;
-
-	my $packagelist	= installer::files::read_file($filename);
-	
-	my @allpackages = ();
-	
-	for ( my $i = 0; $i <= $#{$packagelist}; $i++ )
-	{
-		my $line = ${$packagelist}[$i];
-
-		if ( $line =~ /^\s*\#/ ) { next; }	# this is a comment line
-
-		if ( $line =~ /^\s*Start\s*$/i ) 	# a new package definition
-		{
-			my %onepackage = ();
-
-			my $counter = $i + 1;
-
-			while (!( ${$packagelist}[$counter] =~ /^\s*End\s*$/i ))
-			{
-				if ( ${$packagelist}[$counter] =~ /^\s*(\S+)\s*\=\s*\"(.*)\"/ )
-				{
-					my $key = $1;
-					my $value = $2;
-					$onepackage{$key} = $value;							
-				}
-				
-				$counter++;	
-			}
-					
-			push(@allpackages, \%onepackage);	
-		}
-	}
-	
-	# looking for the packinfo with the correct gid
-	
-	my $foundgid = 0;
-	my $onepackage;
-	foreach $onepackage (@allpackages)
-	{
-		# Adding the language to the module gid for LanguagePacks !
-		# Making the module gid language specific: gid_Module_Root -> gir_Module_Root_pt_BR (as defined in scp2)
-		if ( $installer::globals::languagepack ) { $onepackage->{'module'} = $onepackage->{'module'} . "_$scplanguage"; }
-
-		# Resolving the language identifier
-		$onepackage->{'packagename'} =~ s/\%LANGUAGESTRING/$onelanguage/;
-
-		if ( $onepackage->{'module'} eq $gid )
-		{
-			push(@{$packages}, $onepackage);
-			$foundgid = 1;
-			last;
-		}
-	}
-	
-	if ( ! $foundgid )
-	{
-		installer::exiter::exit_program("ERROR: Could not find package info for module $gid in file \"$filename\"!", "get_packinfo");
-	}	
-}
-
-#####################################################################
-# Collecting all packages from scp project.
-#####################################################################
-
-sub do_collect_packages
-{
-	my ( $allmodules, $onelanguage, $packagesref ) = @_;
-
-	my %gid_analyzed = ();
-
-    my $scplanguage = $onelanguage;
-	$scplanguage =~ s/-/_/g; # pt-BR -> pt_BR in scp
-
-	my $onemodule;
-	foreach $onemodule ( @{$allmodules} )
-	{
-		my $packageinfo = "PackageInfo";
-		if ( $installer::globals::languagepack ) { $packageinfo = "LanguagePackageInfo" }
-		if (( $installer::globals::tab ) && ( $onemodule->{"TabPackageInfo"} )) { $packageinfo = "TabPackageInfo" }
-	
-		if ( $onemodule->{$packageinfo} )	# this is a package module!
-		{
-			my $modulegid = $onemodule->{'gid'};
-			
-			# Only collecting modules with correct language for language packs
-			if ( $installer::globals::languagepack ) {
-				if ( ! ( $modulegid =~ /_$scplanguage\s*$/ )) { next; }
-			}
-
-			# Ignoring packages, if they are marked to be ignored. Otherwise OOo 2.x update will break.
-			# Style OOOIGNORE has to be removed for OOo 3.x
-			my $styles = "";
-			if ( $onemodule->{'Styles'} ) { $styles = $onemodule->{'Styles'}; }
-			if (( $styles =~ /\bOOOIGNORE\b/ ) && ( $installer::globals::isopensourceproduct )) { next; }
-			
-			# Modules in different languages are listed more than once in multilingual installation sets
-			if ( exists($gid_analyzed{$modulegid}) ) { next; }
-			$gid_analyzed{$modulegid} = 1;
-
-			my $packinfofile = $onemodule->{$packageinfo};
-			
-			# The file with package information has to be found in path list
-			my $fileref = installer::scriptitems::get_sourcepath_from_filename_and_includepath(\$packinfofile, "" , 0);
-
-			if ( $$fileref eq "" ) { installer::exiter::exit_program("ERROR: Could not find file $packinfofile for module $modulegid!", "do_collect_packages"); }
-
-			my $infoline = "$modulegid: Using packinfo: \"$$fileref\"!\n";
-			push( @installer::globals::logfileinfo, $infoline);
-			
-			get_packinfo($modulegid, $$fileref, $packagesref, $onelanguage, $scplanguage);
-		}
-	}
-	
-}
-
-#####################################################################
-# Collecting all packages from scp project.
-#####################################################################
-
-sub collectpackages
-{
-	my ( $allmodules, $languagesarrayref ) = @_;
-
-	installer::logger::include_header_into_logfile("Collecting packages:");
-	
-	# Attention: Special handling for Windows LanguagePacks with more than one language
-
-	my @packages = ();
-
-	if ( $installer::globals::languagepack )
-	{
-		my $onelang;
-		foreach $onelang ( @{$languagesarrayref} )
-		{
-			do_collect_packages($allmodules, $onelang, \@packages);			
-		}
-	}
-	else
-	{
-		do_collect_packages($allmodules, "", \@packages);	
-	}
-	
-	return \@packages;
-}
-
-#####################################################################
-# Printing packages content for debugging purposes
-#####################################################################
-
-sub log_packages_content
-{
-	my ($packages) = @_;
-	
-	if ( ! ( $#{$packages} > -1 )) { installer::exiter::exit_program("ERROR: No packages defined!", "print_content"); }
-
-	installer::logger::include_header_into_logfile("Logging packages content:");
-
-	my $infoline = "";
-
-	for ( my $i = 0; $i <= $#{$packages}; $i++ )
-	{
-		my $onepackage = ${$packages}[$i];
-
-		# checking all items that must be defined
-
-		$infoline = "Package $onepackage->{'module'}\n";
-		push(@installer::globals::logfileinfo, $infoline);
-
-		my $key;
-		foreach $key (sort keys %{$onepackage})
-		{
-			if ( $key =~ /^\s*\;/ ) { next; }
-			
-			if ( $key eq "allmodules" )
-			{
-				$infoline = "\t$key:\n";
-				push(@installer::globals::logfileinfo, $infoline);
-				my $onemodule;
-				foreach $onemodule ( @{$onepackage->{$key}} )
-				{
-					$infoline = "\t\t$onemodule\n";
-					push(@installer::globals::logfileinfo, $infoline);
-				}
-			}
-			else
-			{
-				$infoline = "\t$key: $onepackage->{$key}\n";
-				push(@installer::globals::logfileinfo, $infoline);
-			}
-		}
-
-		$infoline = "\n";
-		push(@installer::globals::logfileinfo, $infoline);
-
-	}
-}
-
-#####################################################################
-# Creating list of cabinet files from packages
-#####################################################################
-
-sub prepare_cabinet_files
-{
-	my ($packages, $allvariables) = @_;
-	
-	if ( ! ( $#{$packages} > -1 )) { installer::exiter::exit_program("ERROR: No packages defined!", "print_content"); }
-
-	installer::logger::include_header_into_logfile("Preparing cabinet files:");
-
-	my $infoline = "";
-
-	for ( my $i = 0; $i <= $#{$packages}; $i++ )
-	{
-		my $onepackage = ${$packages}[$i];
-		
-		my $cabinetfile = "$onepackage->{'packagename'}\.cab";
-		
-		resolve_packagevariables(\$cabinetfile, $allvariables, 0);
-			
-		$installer::globals::allcabinets{$cabinetfile} = 1;
-
-		# checking all items that must be defined
-
-		$infoline = "Package $onepackage->{'module'}\n";
-		push(@installer::globals::logfileinfo, $infoline);
-
-		# Assigning the cab file to the module and also to all corresponding sub modules
-
-		my $onemodule;
-		foreach $onemodule ( @{$onepackage->{'allmodules'}} )
-		{
-			if ( ! exists($installer::globals::allcabinetassigns{$onemodule}) )
-			{
-				$installer::globals::allcabinetassigns{$onemodule} = $cabinetfile;
-			}
-			else
-			{
-				my $infoline = "Warning: Already existing assignment: $onemodule : $installer::globals::allcabinetassigns{$onemodule}\n";
-				push(@installer::globals::logfileinfo, $infoline);				
-				$infoline = "Ignoring further assignment: $onemodule : $cabinetfile\n";
-				push(@installer::globals::logfileinfo, $infoline);				
-			}
-		}
-	}
-}
-
-#####################################################################
-# Logging assignments of cabinet files
-#####################################################################
-
-sub log_cabinet_assignments
-{
-	installer::logger::include_header_into_logfile("Logging cabinet files:");
-
-	my $infoline = "List of cabinet files:\n";
-	push(@installer::globals::logfileinfo, $infoline);				
-
-	my $key;
-	foreach $key ( sort keys %installer::globals::allcabinets ) { push(@installer::globals::logfileinfo, "\t$key\n"); }
-	
-	$infoline = "\nList of assignments from modules to cabinet files:\n";
-	push(@installer::globals::logfileinfo, $infoline);				
-	
-	foreach $key ( sort keys %installer::globals::allcabinetassigns ) { push(@installer::globals::logfileinfo, "\t$key : $installer::globals::allcabinetassigns{$key}\n"); }
-}
-
 1;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/parameter.pm solenv/bin/modules/installer/parameter.pm
--- solenv.bak/bin/modules/installer/parameter.pm	2008-03-26 20:29:05.680875000 +0100
+++ solenv/bin/modules/installer/parameter.pm	2008-03-31 14:09:36.380466200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: parameter.pm,v $
 #
-#   $Revision: 1.46 $
+#   $Revision: 1.44 $
 #
-#   last change: $Author: kz $ $Date: 2007/12/12 15:33:09 $
+#   last change: $Author: ihi $ $Date: 2007/07/12 11:16:03 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -55,7 +55,7 @@
 --------------------------------------------------------------------------------
 $installer::globals::prog V1.0 (c) Ingo Schmidt 2003
 The following parameter are needed:
--f: Path to the product list (required)
+-f: Path to the product list (zip.lst) (optional, defaulted to zip.lst)
 -s: Path to the setup script (optional, if defined in product list)
 -i: Install path of the product (/opt/openofficeorg20) (optional)
 -p: Product from product list to be created (required)
@@ -67,6 +67,8 @@
 -u: Path, in which zipfiles are unpacked (optional)
 -msitemplate: Source of the msi file templates (Windows compiler only)
 -msilanguage: Source of the msi file templates (Windows compiler only)
+-msichild: Source of the child products (Windows only)
+-javafiles: Source of the Java installer files  (opt., non-Windows only)
 -javalanguage: Source of the Java language files (opt., non-Windows only)
 -buildid: Current BuildID (optional)
 -pro: Product version
@@ -76,6 +78,9 @@
 -dontstrip : do not strip binaries, keep the debugging symbols
 -dontcallepm : do not call epm to create install sets (opt., non-Windows only)
 -ispatchedepm : Usage of a patched (non-standard) epm (opt., non-Windows only)
+-packagelist : file, containing a list of module gids (opt., non-Windows only)
+-addpackagelist : additional packlist, only multilingual unix
+-addsystemintegration : adding system integration packages (opt., Unix only)
 -copyproject : is set for projects that are only used for copying (optional)
 -languagepack : do create a languagepack, no product pack (optional)
 -patch : do create a patch (optional)
@@ -86,15 +91,16 @@
   
 Examples for Windows:
 
-perl make_epmlist.pl -f zip.lst -p OfficeFAT -l en-US
+perl make_epmlist.pl -f zip.lst -s setup.inf -p OfficeFAT -l 01
                      -u /export/unpack -buildid 8712 
                      -msitemplate /export/msi_files
                      -msilanguage /export/msi_languages
 
 Examples for Non-Windows:
 
-perl make_epmlist.pl -f zip.lst -p OfficeFAT -l en-US -format rpm
-                     -u /export/unpack -buildid 8712 -ispatchedepm
+perl make_epmlist.pl -f zip.lst -s setup.inf -p OfficeFAT -l 01 -format rpm
+                     -u /export/unpack -buildid 8712 -i /opt/openofficeorg20
+                     -packagelist packagelist.txt -ispatchedepm
 --------------------------------------------------------------------------------
 Ende
 	exit(-1);
@@ -158,12 +164,17 @@
 		elsif ($param eq "-msitemplate") { $installer::globals::idttemplatepath = shift(@ARGV); }
 		elsif ($param eq "-msilanguage") { $installer::globals::idtlanguagepath = shift(@ARGV); }
 		elsif ($param eq "-patchinc") { $installer::globals::patchincludepath = shift(@ARGV); }
+		elsif ($param eq "-addjavainstaller") { $installer::globals::addjavainstaller = 1; }
 		elsif ($param eq "-javalanguage") { $installer::globals::javalanguagepath = shift(@ARGV); }
 		elsif ($param eq "-buildid") { $installer::globals::buildid = shift(@ARGV); }
+		elsif ($param eq "-packagelist") { $installer::globals::packagelist = shift(@ARGV); }
+		elsif ($param eq "-addpackagelist") { $installer::globals::addpackagelist = shift(@ARGV); }
 		elsif ($param eq "-copyproject") { $installer::globals::is_copy_only_project = 1; }
 		elsif ($param eq "-languagepack") { $installer::globals::languagepack = 1; }
 		elsif ($param eq "-patch") { $installer::globals::patch = 1; }
 		elsif ($param eq "-debian") { $installer::globals::debian = 1; }
+		elsif ($param eq "-addchildprojects") { $installer::globals::addchildprojects = 1; }
+		elsif ($param eq "-addsystemintegration") { $installer::globals::addsystemintegration = 1; }
 		elsif ($param eq "-dontstrip") { $installer::globals::strip = 0; }
 		elsif ($param eq "-destdir")	# new parameter for simple installer
 		{
@@ -192,6 +203,7 @@
 	# Usage of simple installer (not for Windows):
 	# $PERL -w $SOLARENV/bin/make_installer.pl \
 	# -f openoffice.lst -l en-US -p OpenOffice \
+	# -packagelist ../inc_openoffice/unix/packagelist.txt \
 	# -buildid $BUILD -rpm \
 	# -destdir /tmp/nurk -simple $INSTALL_PATH
 }
@@ -309,8 +321,10 @@
 	if ( $installer::globals::compiler =~ /unxso[lg]s/ ) { $installer::globals::issolarissparcbuild = 1; }
 	
 	if ( $installer::globals::compiler =~ /unxso[lg]i/ ) { $installer::globals::issolarisx86build = 1; }
+	
+	if (( $installer::globals::compiler =~ /unx/ ) && ( $installer::globals::addpackagelist )) { $installer::globals::is_unix_multi = 1; }
 
-	if ( $installer::globals::compiler =~ /unxlng/ )
+	if ( $installer::globals::compiler =~ /unxlngi/ || $installer::globals::compiler =~ /unxlngx/ || $installer::globals::compiler =~ /unxlngs/ || $installer::globals::compiler =~ /unxlngppc/ )
 	{
 		$installer::globals::islinuxbuild = 1;
 		if ( $installer::globals::packageformat eq "rpm" )
@@ -452,6 +466,36 @@
 
 	if (!($installer::globals::is_copy_only_project))
 	{
+
+		############################################################################
+		# Non Windows: Checking $installer::globals::packagelist
+		############################################################################
+	
+		if (($installer::globals::packagelist eq "") && (!($installer::globals::iswindowsbuild)))
+		{
+			installer::logger::print_error( "Package list file not set (-packagelist)!\n;
+			                                 This package list is required for non-Windows builds!" );
+			usage();
+			exit(-1);
+		}
+
+		# Testing existence of packagelist file. Only needed for non-Windows compilers.
+
+		if (!($installer::globals::iswindowsbuild))
+		{
+			installer::files::check_file($installer::globals::packagelist);
+
+			$installer::globals::absolutepackagelistpath = $installer::globals::packagelist;
+			make_path_absolute(\$installer::globals::absolutepackagelistpath);
+
+			# If an additional packagelist is defined (Unix, multilingual installation set), it has to exist.
+
+			if ( $installer::globals::addpackagelist )
+			{
+				installer::files::check_file($installer::globals::packagelist);			
+			}
+		}
+
 		##############################################################################################
 		# idt template path. Only required for Windows build ($installer::globals::compiler =~ /wntmsci/)
 		# for the creation of the msi database.
@@ -538,16 +582,8 @@
 	# also for copy-only projects
 	#######################################
 
-	if ($installer::globals::ziplistname eq "")
-	{
-		installer::logger::print_error( "ERROR: Zip list file has to be defined (Parameter -f) !" );
-		usage();
-		exit(-1);
-	}
-	else
-	{
-		installer::files::check_file($installer::globals::ziplistname);
-	}
+	if ($installer::globals::ziplistname eq "")	{ $installer::globals::use_default_ziplist = 1;	}
+	else { installer::files::check_file($installer::globals::ziplistname); }  # if the ziplist file is defined, it has to exist
 
 	if ($installer::globals::setupscriptname eq "")	{ $installer::globals::setupscript_defined_in_productlist = 1; }
 	else { installer::files::check_file($installer::globals::setupscriptname); } # if the setupscript file is defined, it has to exist
@@ -568,7 +604,14 @@
 	
 	push(@output, "\n########################################################\n");
 	push(@output, "$installer::globals::prog, version 1.0\n");
-	push(@output, "Product list file: $installer::globals::ziplistname\n");
+	if (!($installer::globals::use_default_ziplist))
+	{
+		push(@output, "Product list file: $installer::globals::ziplistname\n");
+	}
+	else
+	{
+		push(@output, "Product list file: Defaulted\n");		# to b_server/zip/zip.lst
+	}
 	if (!($installer::globals::setupscript_defined_in_productlist))
 	{
 		push(@output, "Setup script: $installer::globals::setupscriptname\n");
@@ -589,16 +632,23 @@
 	if ( $installer::globals::rootpath eq "" ) { push(@output, "Using default installpath\n"); }
 	else { push(@output, "Installpath: $installer::globals::rootpath\n"); }
 	push(@output, "Package format: $installer::globals::packageformat\n");
+	if (!($installer::globals::packagelist eq ""))	{ push(@output, "Package list file: $installer::globals::packagelist\n"); }
+	if ((!($installer::globals::packagelist eq "")) && ($installer::globals::iswindowsbuild)) { push(@output, "Package list file will be ignored for Windows!\n"); }
+	if (!($installer::globals::addpackagelist eq ""))	{ push(@output, "Addon-Package list file: $installer::globals::addpackagelist\n"); }
+	if ((!($installer::globals::addpackagelist eq "")) && ($installer::globals::iswindowsbuild)) { push(@output, "Addon-Package list file will be ignored for Windows!\n"); }
 	if (!($installer::globals::idttemplatepath eq ""))	{ push(@output, "msi templatepath: $installer::globals::idttemplatepath\n"); }
 	if ((!($installer::globals::idttemplatepath eq "")) && (!($installer::globals::iswindowsbuild))) { push(@output, "msi template path will be ignored for non Windows builds!\n"); }
 	if (!($installer::globals::idtlanguagepath eq ""))	{ push(@output, "msi languagepath: $installer::globals::idtlanguagepath\n"); }
 	if ((!($installer::globals::idtlanguagepath eq "")) && (!($installer::globals::iswindowsbuild))) { push(@output, "msi language path will be ignored for non Windows builds!\n"); }
 	if ((!($installer::globals::iswindowsbuild)) && ( $installer::globals::call_epm )) { push(@output, "Calling epm\n"); }
 	if ((!($installer::globals::iswindowsbuild)) && (!($installer::globals::call_epm))) { push(@output, "Not calling epm\n"); }
+	if ( $installer::globals::addjavainstaller ) { push(@output, "Adding Java installer\n"); }
 	if (!($installer::globals::javalanguagepath eq "")) { push(@output, "Java language path: $installer::globals::javalanguagepath\n"); }
 	if ((!($installer::globals::javalanguagepath eq "")) && ($installer::globals::iswindowsbuild)) { push(@output, "Java language path will be ignored for Windows builds!\n"); }
 	if ( $installer::globals::patchincludepath ) { push(@output, "Patch include path: $installer::globals::patchincludepath\n"); }
+	if (($installer::globals::iswindowsbuild) && ($installer::globals::addchildprojects )) { push(@output, "Adding child projects into installation set\n"); }
 	if ( $installer::globals::globallogging ) { push(@output, "Complete logging activated\n"); }
+	if ( $installer::globals::addsystemintegration ) { push(@output, "Adding system integration packages\n"); }
 	if ( $installer::globals::debug ) { push(@output, "Debug is activated\n"); }
 	if ( $installer::globals::tab ) { push(@output, "TAB version\n"); }
 	if ( $installer::globals::strip ) { push(@output, "Stripping files\n"); }
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/profiles.pm solenv/bin/modules/installer/profiles.pm
--- solenv.bak/bin/modules/installer/profiles.pm	2007-11-26 17:18:16.000000000 +0100
+++ solenv/bin/modules/installer/profiles.pm	2008-03-31 14:09:36.380466200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: profiles.pm,v $
 #
-#   $Revision: 1.7 $
+#   $Revision: 1.6 $
 #
-#   last change: $Author: ihi $ $Date: 2007/11/26 16:18:16 $
+#   last change: $Author: hr $ $Date: 2006/04/19 15:08:57 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -97,14 +97,13 @@
 
 sub add_profile_into_filelist
 {
-	my ($filesarrayref, $oneprofile, $completeprofilename, $allvariables) = @_;
+	my ($filesarrayref, $oneprofile, $completeprofilename) = @_;
 
 	my %profile = ();
 
 	# Taking the base data from the "gid_File_Lib_Vcl"
 
 	my $vclgid = "gid_File_Lib_Vcl";
-	if ( $allvariables->{'GLOBALFILEGID'} ) { $vclgid = $allvariables->{'GLOBALFILEGID'}; }
 	my $vclfile = installer::existence::get_specified_file($filesarrayref, $vclgid);
 
 	# copying all base data	
@@ -147,7 +146,7 @@
 
 sub create_profiles
 {
-	my ($profilesref, $profileitemsref, $filesarrayref, $languagestringref, $allvariables) = @_;
+	my ($profilesref, $profileitemsref, $filesarrayref, $languagestringref) = @_;
 
 	my $infoline;
 
@@ -222,7 +221,7 @@
 		
 		# Adding the file to the filearray
 		# Some data are set now, others are taken from the file "soffice.exe" ("soffice.bin")
-		add_profile_into_filelist($filesarrayref, $oneprofile, $completeprofilename, $allvariables);
+		add_profile_into_filelist($filesarrayref, $oneprofile, $completeprofilename);
 
 		$infoline = "Created Profile: $completeprofilename\n";
 		push( @installer::globals::logfileinfo, $infoline);
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/regmerge.pm solenv/bin/modules/installer/regmerge.pm
--- solenv.bak/bin/modules/installer/regmerge.pm	2007-10-15 14:38:06.000000000 +0200
+++ solenv/bin/modules/installer/regmerge.pm	2008-03-31 14:09:36.380466200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: regmerge.pm,v $
 #
-#   $Revision: 1.5 $
+#   $Revision: 1.3 $
 #
-#   last change: $Author: vg $ $Date: 2007/10/15 12:38:06 $
+#   last change: $Author: rt $ $Date: 2005/09/08 09:09:09 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -213,7 +213,7 @@
 
 sub merge_files
 {
-	my ($regmergefile, $databasefile, $registerfiles, $databasedir, $allvariableshashref) = @_;
+	my ($regmergefile, $databasefile, $registerfiles, $databasedir) = @_;
 
 	my $databasesource = $databasefile->{'sourcepath'};
 	my $databasename = $databasefile->{'Name'};
@@ -223,26 +223,12 @@
 	$databasefile->{'sourcepath'} = $databasedest;	# new sourcepath for the StarRegistry file
 
 	# One call for every merge particle. This is only possible, if there are only a few merge particles.
-
-    my $prefix = $allvariableshashref->{'NATIVESERVICESURLPREFIX'};
-        # TODO: NATIVESERVICESURLPREFIX or JAVASERVICESURLPREFIX
 	
 	my $error_occured = 0;
 
 	for ( my $i = 0; $i <= $#{$registerfiles}; $i++ )
 	{	
-        my $registerfile = $databasedir . $installer::globals::separator . $i . ".tmp";
-        open (IN, '<', $registerfiles->[$i]) or $error_occured = 1;
-        open (OUT, '>', $registerfile) or $error_occured = 1;
-        while (<IN>)
-        {
-            s/^ComponentName=/ComponentName=$prefix/;
-            print OUT $_ or $error_occured = 1;
-        }
-        close IN or $error_occured = 1;
-        close OUT or $error_occured = 1;
-
-		my $systemcall = $regmergefile . " -v " . $databasedest . " " . $registerfile . " 2\>\&1 |";
+		my $systemcall = $regmergefile . " -v " . $databasedest . " " . ${$registerfiles}[$i] . " 2\>\&1 |";
 		
 		my @regmergeoutput = ();
 
@@ -280,7 +266,7 @@
 
 sub merge_registration_files
 {
-	my ($filesarrayref, $includepatharrayref, $languagestringref, $allvariableshashref) = @_;
+	my ($filesarrayref, $includepatharrayref, $languagestringref) = @_;
 
 	installer::logger::include_header_into_logfile("Creating starregistry databases:");
 
@@ -293,6 +279,10 @@
 	{
 		# prepare registration
 
+		my $databasename = "starregistryrdb";
+		my $databasedir = installer::systemactions::create_directories($databasename, $languagestringref);
+		push(@installer::globals::removedirs, $databasedir);
+
 		my $regmergefile = get_regmerge_file($includepatharrayref);	# searching for regmerge (regcomplazy.exe)
 
 		my $databasegids = collect_all_database_gids($regmergefiles);
@@ -304,12 +294,6 @@
 		for ( my $i = 0; $i <= $#{$databasegids}; $i++ )
 		{
 			$databasegid = ${$databasegids}[$i];
-
-			# my $databasedirname = "starregistryrdb"; <- not unique!
-			my $databasedirname = $databasegid . "_rdb"; # <- unique!
-			my $databasedir = installer::systemactions::create_directories($databasedirname, $languagestringref);
-			push(@installer::globals::removedirs, $databasedir);
-
 			my $databasefile = get_database_file($databasegid, $filesarrayref);
 			my $databaseregisterfiles = collect_all_files_for_one_registry($regmergefiles, $databasegid); 
 
@@ -317,7 +301,7 @@
 			{
 				my $regmergeparticles = collect_all_regmerge_particles($databaseregisterfiles);
 				$regmergeparticles = get_all_source_pathes($regmergeparticles, $includepatharrayref);
-				my $oneregmergeerror = merge_files($regmergefile, $databasefile, $regmergeparticles, $databasedir, $allvariableshashref);
+				my $oneregmergeerror = merge_files($regmergefile, $databasefile, $regmergeparticles, $databasedir);
 				if ($oneregmergeerror) { $regmergeerror = 1; }
 			}
 		}
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/scppatchsoname.pm solenv/bin/modules/installer/scppatchsoname.pm
--- solenv.bak/bin/modules/installer/scppatchsoname.pm	2007-12-05 18:36:39.000000000 +0100
+++ solenv/bin/modules/installer/scppatchsoname.pm	2008-03-31 14:09:36.380466200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: scppatchsoname.pm,v $
 #
-#   $Revision: 1.6 $
+#   $Revision: 1.5 $
 #
-#   last change: $Author: vg $ $Date: 2007/12/05 17:36:39 $
+#   last change: $Author: rt $ $Date: 2005/09/08 09:09:57 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -167,9 +167,6 @@
 			}
 
 			# }		
-
-			# Saving the original source, where the file was found
-			$onefile->{'originalsourcepath'} = $onefile->{'sourcepath'};
 	
 			# Writing the new sourcepath into the hashref, even if it was no copied
 				
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/scpzipfiles.pm solenv/bin/modules/installer/scpzipfiles.pm
--- solenv.bak/bin/modules/installer/scpzipfiles.pm	2007-12-05 18:36:52.000000000 +0100
+++ solenv/bin/modules/installer/scpzipfiles.pm	2008-03-31 14:09:36.380466200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: scpzipfiles.pm,v $
 #
-#   $Revision: 1.11 $
+#   $Revision: 1.10 $
 #
-#   last change: $Author: vg $ $Date: 2007/12/05 17:36:52 $
+#   last change: $Author: rt $ $Date: 2005/09/08 09:10:27 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -180,9 +180,6 @@
 					replace_all_ziplistvariables_in_file($onefileref, $variableshashref);
 					installer::files::save_file($destinationpath ,$onefileref);
 				}
-
-				# Saving the original source, where the file was found
-				$onefile->{'originalsourcepath'} = $onefile->{'sourcepath'};
 		
 				# Writing the new sourcepath into the hashref, even if it was no copied
 					
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/scriptitems.pm solenv/bin/modules/installer/scriptitems.pm
--- solenv.bak/bin/modules/installer/scriptitems.pm	2008-03-26 20:29:04.884000000 +0100
+++ solenv/bin/modules/installer/scriptitems.pm	2008-03-31 14:09:36.380466200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: scriptitems.pm,v $
 #
-#   $Revision: 1.40 $
+#   $Revision: 1.37 $
 #
-#   last change: $Author: ihi $ $Date: 2007/11/26 13:16:53 $
+#   last change: $Author: rt $ $Date: 2007/07/03 11:46:07 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -66,7 +66,7 @@
 		my $gid = $directoryhashref-> {'gid'};
 		my $parentid = $directoryhashref-> {'ParentID'};
 		
-		if ( $parentid ne "PREDEFINED_PROGDIR" )
+		if (!( $parentid eq "PREDEFINED_PROGDIR" ))
 		{
 			# find the array of the parentid, which has to be defined before in setup script
 			# and is therefore listed before in this array
@@ -479,7 +479,6 @@
 		$value =~ s/\<productupdate\>/$productupdatestring/;
 		$value =~ s/\<updateid\>/$updateid/;
 		$value =~ s/\<useragent\>/$useragent/;
-		$value =~ s/\<pkgformat\>/$installer::globals::packageformat/;
 		$value =~ s/\<vendor\>/$ENV{'OOO_VENDOR'}/;
 		$value =~ s/\<buildversion\>/$ENV{'BUILD_VER_STRING'}/;
 
@@ -892,19 +891,18 @@
 				my $oldname = $onefile->{'Name'};
 				my $oldlanguage = $onefile->{'specificlanguage'};
 				my $newlanguage = "en-US";
-				# $onefile->{'Name'} =~ s/$oldlanguage\./$newlanguage\./;	# Example: tplwizfax_it.zip -> tplwizfax_en-US.zip
+				$onefile->{'Name'} =~ s/$oldlanguage\./$newlanguage\./;	# Example: tplwizfax_it.zip -> tplwizfax_en-US.zip
 				$onefilename = $onefile->{'Name'};
-				$onefilename =~ s/$oldlanguage\./$newlanguage\./;	# Example: tplwizfax_it.zip -> tplwizfax_en-US.zip
 				$onefilename =~ s/^\s*\Q$installer::globals::separator\E//;		# filename begins with a slash, for instance /registry/schema/org/openoffice/VCL.xcs
 				$sourcepathref = get_sourcepath_from_filename_and_includepath(\$onefilename, $includepatharrayref, 1);
 				$onefile->{'sourcepath'} = $$sourcepathref;						# This $$sourcepathref is empty, if no source was found
 				
 				if ($onefile->{'sourcepath'})	# defaulting to english was successful
 				{
-					$infoline = "WARNING: Using $onefilename instead of $oldname\n";
+					$infoline = "WARNING: Using $onefile->{'Name'} instead of $oldname\n";
 					push( @installer::globals::logfileinfo, $infoline);
 					print "    $infoline";
-					# if ( $onefile->{'destination'} ) { $onefile->{'destination'} =~ s/\Q$oldname\E/$onefile->{'Name'}/; }
+					if ( $onefile->{'destination'} ) { $onefile->{'destination'} =~ s/\Q$oldname\E/$onefile->{'Name'}/; }
 
 					# If the directory, in which the new file is installed, is not language dependent,
 					# the filename has to be changed to avoid installation conflicts
@@ -1686,7 +1684,6 @@
 	{
 		my $onedir = ${$directoryarrayref}[$i];
 		my $styles = "";
-		$newdirincluded = 0;
 		
 		if ( $onedir->{'Styles'} ) { $styles = $onedir->{'Styles'}; }
 	
@@ -1731,36 +1728,7 @@
 						# $directoryhash{'Styles'} = $onedir->{'Styles'};
 						if ( ! $installer::globals::iswindowsbuild ) { $directoryhash{'Styles'} = "(CREATE)"; }
 
-						push(@{$directoriesforepmarrayref}, \%directoryhash);	
-						
-						$newdirincluded = 1;		
-					}
-				}
-			}
-		}
-
-		if (( ! $newdirincluded ) && ( $styles ne "" )) # saving the styles for already added directories
-		{
-			$styles =~ s/\bWORKSTATION\b//;
-			$styles =~ s/\bCREATE\b//;
-
-			if (( ! ( $styles =~ /^\s*\(\s*\)\s*$/ )) && ( ! ( $styles =~ /^\s*\(\s*\,\s*\)\s*$/ )) && ( ! ( $styles =~ /^\s*$/ ))) # checking, if there are styles left
-			{
-				my $directoryname = "";			
-				if ( $onedir->{'HostName'} ) { $directoryname = $onedir->{'HostName'}; }
-				else { installer::exiter::exit_program("ERROR: No directory name (HostName) set for specified language in gid $onedir->{'gid'}", "assigning_modules_to_items"); }
-
-				my $alreadyincluded = installer::existence::exists_in_array_of_hashes($searchkey, $directoryname, $directoriesforepmarrayref); 
-
-				if ( $alreadyincluded )
-				{
-					for ( my $j = 0; $j <= $#{$directoriesforepmarrayref}; $j++ )
-					{
-						if ( ${$directoriesforepmarrayref}[$j]->{'HostName'} eq $directoryname )
-						{
-							${$directoriesforepmarrayref}[$j]->{'Styles'} = $styles;
-							last;
-						}
+						push(@{$directoriesforepmarrayref}, \%directoryhash);			
 					}
 				}
 			}
@@ -2093,8 +2061,6 @@
 
 	my @allparents = ();
 	
-	my $found_root_module = 0;
-	
 	for ( my $i = 0; $i <= $#{$modulesref}; $i++ )
 	{
 		my $onefeature = ${$modulesref}[$i];
@@ -2112,20 +2078,6 @@
 				push(@allparents, $parentgid);		
 			}
 		}
-		
-		# Setting the global root module
-		
-		if ( $parentgid eq "" )
-		{
-			if ( $found_root_module ) { installer::exiter::exit_program("ERROR: Only one module without ParentID or with empty ParentID allowed ($installer::globals::rootmodulegid, $onefeature->{'gid'}).", "collect_all_parent_feature"); }
-			$installer::globals::rootmodulegid = $onefeature->{'gid'};
-			$found_root_module = 1;
-			$infoline = "Setting Root Module: $installer::globals::rootmodulegid\n";
-			push( @installer::globals::globallogfileinfo, $infoline);			
-		}
-		
-		if ( ! $found_root_module ) { installer::exiter::exit_program("ERROR: Could not define root module. No module without ParentID or with empty ParentID exists.", "collect_all_parent_feature"); }
-
 	}
 	
 	return \@allparents;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/servicesfile.pm solenv/bin/modules/installer/servicesfile.pm
--- solenv.bak/bin/modules/installer/servicesfile.pm	2008-03-28 10:37:48.993375000 +0100
+++ solenv/bin/modules/installer/servicesfile.pm	2008-04-01 10:24:11.467941200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: servicesfile.pm,v $
 #
-#   $Revision: 1.30 $
+#   $Revision: 1.23 $
 #
-#   last change: $Author: kz $ $Date: 2007/12/12 15:34:05 $
+#   last change: $Author: obo $ $Date: 2006/07/10 18:51:00 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -133,93 +133,50 @@
 
 sub register_unocomponents
 {
-	my ($allvariableshashref, $unocomponents, $regcompfileref, $servicesfile) = @_;
+	my ($unocomponents, $regcompfileref, $servicesfile) = @_;
 
 	installer::logger::include_header_into_logfile("Registering UNO components:");
 
-    my $error_occured = 0;
-    my $filestring = "";
-    for ( my $i = 0; $i <= $#{$unocomponents}; )
-    {
-        my $sourcepath = ${$unocomponents}[$i++]->{'sourcepath'};
-
-        $filestring = $filestring . make_file_url($sourcepath);
-
-        if ( $i % $installer::globals::unomaxservices == 0 || $i > $#{$unocomponents} )    # limiting to $installer::globals::maxservices files
-        {
-            my @regcompoutput = ();
-
-            my $systemcall = "$installer::globals::wrapcmd $$regcompfileref -register -r ".fix_cygwin_path($servicesfile)." -c "  . $installer::globals::quote . $filestring . $installer::globals::quote . " -wop=" . $installer::globals::quote . $allvariableshashref->{'NATIVESERVICESURLPREFIX'} . $installer::globals::quote . " 2\>\&1 |";
-
-            open (REG, "$systemcall");
-            while (<REG>) {push(@regcompoutput, $_); }
-            close (REG);
-
-            my $returnvalue = $?;   # $? contains the return value of the systemcall
-
-            my $infoline = "Systemcall: $systemcall\n";
-            push( @installer::globals::logfileinfo, $infoline);
-
-            for ( my $j = 0; $j <= $#regcompoutput; $j++ ) { push( @installer::globals::logfileinfo, "$regcompoutput[$j]"); }
-
-            if ($returnvalue)
-            {
-                $infoline = "ERROR: $systemcall\n";
-                push( @installer::globals::logfileinfo, $infoline);
-                $error_occured = 1;
-            }
-            else
-            {
-                $infoline = "SUCCESS: $systemcall\n";
-                push( @installer::globals::logfileinfo, $infoline);
-            }
-
-            $filestring = "";
-        }
-        else
-        {
-            $filestring = $filestring . ";";
-        }
-	}
-	
-	return $error_occured;
-}
-
-################################################################
-# Registering all java component files in the services.rdb
-################################################################
-
-sub register_javacomponents
-{
-	my ($allvariableshashref, $javacomponents, $regcompfileref, $servicesfile, $regcomprdb) = @_;
-
-	installer::logger::include_header_into_logfile("Registering Java components:");
-
-	my $ridljar_ref = "ridl.jar";
-	my $ure_internal_java_dir_ref = installer::scriptitems::get_sourcepath_from_filename_and_includepath(\$ridljar_ref, "", 1);
-	installer::pathanalyzer::get_path_from_fullqualifiedname($ure_internal_java_dir_ref);
-	if ( $$ure_internal_java_dir_ref eq "" ) { installer::exiter::exit_program("Could not determine URE_INTERNAL_JAVA_DIR when registering Java components!", "register_javacomponents"); }
-
 	my $error_occured = 0;
+	my $counter = 0;
 
-	my $do_register = 1;
-	if (!( $installer::globals::solarjava )) { $do_register = 0; }
+	my $systemcall = "";
+	
+	my $allsourcepathes = get_all_sourcepathes($unocomponents);
 
-	if ( $do_register )
+	for ( my $j = 0; $j <= $#{$allsourcepathes}; $j++ )
 	{
 		my $filestring = "";
+		my $onesourcepath = ${$allsourcepathes}[$j];
+		my $to = "";
+		my $from = cwd();
+		if ( $installer::globals::iswin ) { $from =~ s/\//\\/g; }
 
-		for ( my $i = 0; $i <= $#{$javacomponents}; )
+		for ( my $i = 0; $i <= $#{$unocomponents}; $i++ )
 		{
-			my $sourcepath = ${$javacomponents}[$i++]->{'sourcepath'};
+			my $doinclude = 1;
+			my $sourcepath = ${$unocomponents}[$i]->{'sourcepath'};
 
-			$filestring = $filestring . make_file_url($sourcepath);
+			$to = $sourcepath;				
+			installer::pathanalyzer::get_path_from_fullqualifiedname(\$to);
+
+			if (!($to eq $onesourcepath)) { $doinclude = 0; }
+
+			if ( $doinclude )
+			{
+				my $filename = ${$unocomponents}[$i]->{'Name'};
+				$filestring = $filestring . $filename . "\;";
+				$counter++;
+			}
 			
-			if ( $i % $installer::globals::javamaxservices == 0 || $i > $#{$javacomponents} )	# limiting to $installer::globals::maxservices files
+			if ((( $counter > 0 ) && ( $counter%$installer::globals::unomaxservices == 0 )) || (( $counter > 0 ) && ( $i == $#{$unocomponents} )))	# limiting to $installer::globals::maxservices files
 			{
+				$filestring =~ s/\;\s*$//;
+				chdir($onesourcepath);
+				
 				my @regcompoutput = ();
 
-				my $systemcall = "$installer::globals::wrapcmd $$regcompfileref -register -br ".fix_cygwin_path($regcomprdb)." -r ".fix_cygwin_path($servicesfile)." -c " . $installer::globals::quote . $filestring . $installer::globals::quote . " -l com.sun.star.loader.Java2 -wop=" . $installer::globals::quote . $allvariableshashref->{'JAVASERVICESURLPREFIX'} . $installer::globals::quote ." -env:URE_INTERNAL_JAVA_DIR=" . $installer::globals::quote . make_file_url($$ure_internal_java_dir_ref) . $installer::globals::quote . " 2\>\&1 |";
+				$systemcall = "$installer::globals::wrapcmd $$regcompfileref -register -r ".fix_cygwin_path($servicesfile)." -c "  . $installer::globals::quote . $filestring . $installer::globals::quote . " 2\>\&1 |";
 
 				open (REG, "$systemcall");
 				while (<REG>) {push(@regcompoutput, $_); }
@@ -230,49 +187,121 @@
 				my $infoline = "Systemcall: $systemcall\n";
 				push( @installer::globals::logfileinfo, $infoline);
 
-				for ( my $k = 0; $k <= $#regcompoutput; $k++ ) { push( @installer::globals::logfileinfo, "$regcompoutput[$k]"); }
+				for ( my $j = 0; $j <= $#regcompoutput; $j++ ) { push( @installer::globals::logfileinfo, "$regcompoutput[$j]"); }
 
 				if ($returnvalue)
 				{
 					$infoline = "ERROR: $systemcall\n";
+					push( @installer::globals::logfileinfo, $infoline);
 					$error_occured = 1;
 				}
 				else
 				{
 					$infoline = "SUCCESS: $systemcall\n";
+					push( @installer::globals::logfileinfo, $infoline);
 				}
 
-				push( @installer::globals::logfileinfo, $infoline);
-
+				chdir($from);
+				
+				$counter = 0;
 				$filestring = "";
 			}
-            else
-            {
-				$filestring = $filestring . ";";
-			}
 		}
 	}
 	
 	return $error_occured;
 }
 
-
-
 ################################################################
-# Helper routine to change cygwin (POSIX) path to DOS notation
-# if needed
+# Registering all java component files in the services.rdb
 ################################################################
-sub fix_cygwin_path
+
+sub register_javacomponents
 {
-    my ( $path ) = @_;
+	my ($javacomponents, $regcompfileref, $servicesfile, $regcomprdb) = @_;
 
-    if ( $installer::globals::iswin eq 1 && $ENV{'USE_SHELL'} ne "4nt" && $installer::globals::wrapcmd eq "" )
-    {
-	$path = qx{cygpath -m "$path"};
-	chomp($path);
-    }
+	installer::logger::include_header_into_logfile("Registering Java components:");
 
-    return $path;
+	my $error_occured = 0;
+	my $systemcall;
+
+	my $do_register = 1;
+	if (!( $installer::globals::solarjava )) { $do_register = 0; }
+
+	if ( $do_register )
+	{
+		my $allsourcepathes = get_all_sourcepathes($javacomponents);
+
+		for ( my $j = 0; $j <= $#{$allsourcepathes}; $j++ )
+		{
+			my $filestring = "";
+			my $onesourcepath = ${$allsourcepathes}[$j];
+			my $to = "";
+			my $from = cwd();
+			if ( $installer::globals::iswin ) { $from =~ s/\//\\/g; }
+
+			for ( my $i = 0; $i <= $#{$javacomponents}; $i++ )
+			{
+				my $doinclude = 1;
+				my $sourcepath = ${$javacomponents}[$i]->{'sourcepath'};
+
+				$to = $sourcepath;				
+				installer::pathanalyzer::get_path_from_fullqualifiedname(\$to);
+
+				if (!($to eq $onesourcepath)) { $doinclude = 0; }
+	
+				if ( $doinclude )
+				{
+					my $filename = ${$javacomponents}[$i]->{'Name'};
+					$filename = "vnd.sun.star.expand\:\$UNO_JAVA_COMPONENT_PATH\/$filename";
+					$filestring = $filestring . $filename . "\;";
+					$counter++;
+				}
+			
+				if ((( $counter > 0 ) && ( $counter%$installer::globals::javamaxservices == 0 )) || (( $counter > 0 ) && ( $i == $#{$javacomponents} )))	# limiting to $installer::globals::maxservices files
+				{
+					$filestring =~ s/\;\s*$//;
+					chdir($onesourcepath);
+
+					my $fileurl = make_file_url($onesourcepath);
+
+					my @regcompoutput = ();
+
+					$systemcall = "$installer::globals::wrapcmd $$regcompfileref -register -br ".fix_cygwin_path($regcomprdb)." -r ".fix_cygwin_path($servicesfile)." -c " . $installer::globals::quote . $filestring . $installer::globals::quote . " -l com.sun.star.loader.Java2 -env:UNO_JAVA_COMPONENT_PATH=" . $installer::globals::quote . $fileurl . $installer::globals::quote . " -env:URE_INTERNAL_JAVA_DIR=" . $installer::globals::quote . $fileurl . $installer::globals::quote . " 2\>\&1 |";
+
+					open (REG, "$systemcall");
+					while (<REG>) {push(@regcompoutput, $_); }
+					close (REG);
+
+					my $returnvalue = $?;	# $? contains the return value of the systemcall
+
+					my $infoline = "Systemcall: $systemcall\n";
+					push( @installer::globals::logfileinfo, $infoline);
+
+					for ( my $k = 0; $k <= $#regcompoutput; $k++ ) { push( @installer::globals::logfileinfo, "$regcompoutput[$k]"); }
+
+					if ($returnvalue)
+					{
+						$infoline = "ERROR: $systemcall\n";
+						$error_occured = 1;
+					}
+					else
+					{
+						$infoline = "SUCCESS: $systemcall\n";
+					}
+
+					push( @installer::globals::logfileinfo, $infoline);
+
+					chdir($from);
+				
+					$counter = 0;
+					$filestring = "";
+				}
+			}
+		}
+	}
+	
+	return $error_occured;
 }
 
 
@@ -289,7 +318,7 @@
     {
 	if( substr( $$ret, 1,1 ) eq ":" )
 	{
-	    chomp($$ret = qx{cygpath -u "$$ret"});
+	    $$ret = "/cygdrive/" . substr($$ret,0,1) .  substr($$ret,2);
 	}
     }
     return $ret;
@@ -317,9 +346,6 @@
 		if ( $installer::globals::iswin ) { $from =~ s/\//\\/g; }
 
 		my $typesrdbname = "types.rdb";
-		# FIXME: Remove the unneeded
-		# get_source_path_cygwin_safe() -> fix_cygwin_path()
-		# when WRAPCMD is gone
 		my $typesrdbref =
 		    get_source_path_cygwin_safe($typesrdbname, $includepatharrayref, 1);
 
@@ -360,11 +386,8 @@
 				my @regcompoutput = ();
 
 
-				$systemcall = "$installer::globals::wrapcmd $$regcompfileref -register"
-				. " -br " . fix_cygwin_path($$typesrdbref)
-				. " -br " . fix_cygwin_path($$pyunoservicesrdbref)
-				. " -r " . fix_cygwin_path($servicesfile)
-				. " -c vnd.openoffice.pymodule:" . $filestring . " -l com.sun.star.loader.Python 2\>\&1 |";
+                                $systemcall = "$installer::globals::wrapcmd $$regcompfileref -register -br " . fix_cygwin_path($$typesrdbref) . " -br " . fix_cygwin_path($$pyunoservicesrdbref) . " -r ".fix_cygwin_path($servicesfile)." -c vnd.openoffice.pymodule:" . $filestring . " -l com.sun.star.loader.Python 2\>\&1 |";
+
 				open (REG, "$systemcall");
 				while (<REG>) {push(@regcompoutput, $_); }
 				close (REG);
@@ -406,7 +429,7 @@
 
 sub register_all_components
 {
-	my ( $allvariableshashref, $servicesgid, $filesarrayref, $regcompfileref, $servicesfile, $regcomprdb, $includepatharrayref ) = @_;
+	my ( $filesarrayref, $regcompfileref, $servicesfile, $regcomprdb, $includepatharrayref ) = @_;
 
 	my $registererrorflag = 0;
 	
@@ -419,11 +442,6 @@
 		my $onefile = ${$filesarrayref}[$i];
 		my $styles = "";
 		my $regmergefile = "";
-		my $registryid = "";
-
-		if ( $onefile->{'RegistryID'} ) { $registryid = $onefile->{'RegistryID'}; }
-		
-		if ( $servicesgid ne $registryid ) { next; } # only registration for the current $servicesgid
 		
 		if ( $onefile->{'Regmergefile'} ) { $regmergefile = $onefile->{'Regmergefile'}; }
 		
@@ -439,11 +457,11 @@
 			}
 			elsif( $filename =~ /\.py\s*$/ )	# python_component
 			{
-				push(@pythoncomponents, $onefile); 
+			        push(@pythoncomponents, $onefile); 
 			}
 			else                            # uno component
 			{
-				push(@unocomponents, $onefile);				
+			        push(@unocomponents, $onefile);				
 			}
 		}
 	}
@@ -452,8 +470,8 @@
 	$java_error_occured = 0;
 	$python_error_occured = 0;
 
-	if ( $#unocomponents > -1 ) { $uno_error_occured = register_unocomponents($allvariableshashref, \@unocomponents, $regcompfileref, $servicesfile); }
-	if ( $#javacomponents > -1 ) { $java_error_occured = register_javacomponents($allvariableshashref, \@javacomponents, $regcompfileref, $servicesfile, $regcomprdb); }
+	if ( $#unocomponents > -1 ) { $uno_error_occured = register_unocomponents(\@unocomponents, $regcompfileref, $servicesfile); }
+	if ( $#javacomponents > -1 ) { $java_error_occured = register_javacomponents(\@javacomponents, $regcompfileref, $servicesfile, $regcomprdb); }
 	if ( $#pythoncomponents > -1 ) { $python_error_occured = register_pythoncomponents(\@pythoncomponents, $regcompfileref, $servicesfile, $includepatharrayref); }
 		
 	if ( $uno_error_occured || $java_error_occured || $python_error_occured ) { $registererrorflag = 1; }
@@ -699,7 +717,7 @@
 
 		chdir($to);
 
-		my $systemcall = "$installer::globals::wrapcmd $regcompfile -register -s -r " . fix_cygwin_path($regcomprdb) . " -c $libfilename";
+		my $systemcall = "$installer::globals::wrapcmd $regcompfile -register -s -r ".fix_cygwin_path($regcomprdb)." -c $libfilename";
 
 		my $returnvalue = system($systemcall);
 
@@ -716,322 +734,159 @@
 }
 
 ################################################################
-# Collecting all gids of the databases, that are part of
-# the file definition
+# Creating services.rdb file by registering all uno components
 ################################################################
 
-sub collect_all_services_gids
-{
-	my ($filesarrayref) = @_;
-
-	my @databasegids = ();
-	my $error_occured = 0;
-	my @error_files = ();
-
-	for ( my $i = 0; $i <= $#{$filesarrayref}; $i++ )
-	{
-		my $onefile = ${$filesarrayref}[$i];
-
-		if ( $onefile->{'RegistryID'} )
-		{
-			my $databasegid = $onefile->{'RegistryID'};
-			if (! installer::existence::exists_in_array($databasegid, \@databasegids)) { push(@databasegids, $databasegid); }
-		}
-		else
-		{
-			push(@error_files, $onefile->{'gid'});
-			$error_occured = 1;
-		}
-	}
-	
-	if ( $error_occured )
-	{
-		my $infoline = "ERROR: Style UNO_COMPONENT is set, but no RegistryID is assigned!\n";
-		push( @installer::globals::logfileinfo, $infoline);
-		print $infoline;
-
-		for ( my $j = 0; $j <= $#error_files; $j++ )
-		{
-			$infoline = "$error_files[$j]\n";
-			push( @installer::globals::logfileinfo, $infoline);
-			print $infoline;			
-		}
-
-		installer::exiter::exit_program("ERROR: File defintion error.", "collect_all_services_gids");
-	}
-		
-	return \@databasegids;
-}
-
-######################################################################
-# All gids in $databasegids are as RegistryID assigned to files.
-# For all this Registry Files a definition has to exist.
-######################################################################
-
-sub check_defintion_of_databasegids
+sub create_services_rdb
 {
-	my ($databasegids, $registryfiles) = @_;
+	my ($filesarrayref, $includepatharrayref, $languagestringref) = @_;
 	
-	my @registryfiles = ();
-
-	# First check: For all assigned Registry files, a definition of
-	# a file with flag STARREGISTRY has to exist.
+	my $servicesname = "services.rdb";
 
-	for ( my $i = 0; $i <= $#{$databasegids}; $i++ )
-	{
-		my $onegid = ${$databasegids}[$i];
-		my $gid_defined = 0;
-		
-		for ( my $j = 0; $j <= $#{$registryfiles}; $j++ )
-		{
-			my $registrygid = ${$registryfiles}[$j]->{'gid'};
+	installer::logger::include_header_into_logfile("Creating $servicesname:");
 
-			if ( $onegid eq $registrygid )
-			{
-				$gid_defined = 1;
-				last;	
-			}
-		}
+	my $servicesdir = installer::systemactions::create_directories($servicesname, $languagestringref);
 
-		if ( ! $gid_defined )
-		{
-			installer::exiter::exit_program("ERROR: Gid $onegid is assigned to file(s), but not defined!", "check_defintion_of_databasegids");			
-		}
+	if ( $^O =~ /cygwin/i && $ENV{'USE_SHELL'} eq "4nt" )
+	{	# $servicesdir is used as a parameter for regcomp and has to be DOS style
+		$servicesdir = qx{guw.pl echo "$servicesdir"};
+		chomp($servicesdir);
+		$servicesdir =~ s/\\/\//g;
 	}
 
-	# Second check: If there is a file defined as StarRegistry, is a file with flag UNO_COMPONENT assigned?
-	
-	for ( my $j = 0; $j <= $#{$registryfiles}; $j++ )
-	{
-		my $onefile = ${$registryfiles}[$j];
-		my $registrygid = $onefile->{'gid'};
-
-		my $gid_assigned = 0;
-
-		for ( my $i = 0; $i <= $#{$databasegids}; $i++ )
-		{
-			my $onegid = ${$databasegids}[$i];
-
-			if ( $onegid eq $registrygid )
-			{
-				$gid_assigned = 1;
-				last;	
-			}
-		}
+	push(@installer::globals::removedirs, $servicesdir);
 
-		if ( ! $gid_assigned )
-		{
-			my $infoline = "Warning: $registrygid is defined with flag STARREGISTRY, but no file is assigned to the registry.\n";
-			push( @installer::globals::logfileinfo, $infoline);
-		}
-		else
-		{
-			push(@registryfiles, $onefile);
-		}
-	}
+	my $servicesfile = $servicesdir . $installer::globals::separator . $servicesname;
 	
-	return \@registryfiles;
-}
-
-################################################################
-# Some files have flag UNO_COMPONENT, but are not registered
-# with regcomp. This files use the regmerge mechanism, that
-# is not used in this perl-file. Therefore this files
-# have to be filtered out here.
-################################################################
-
-sub filter_regmergefiles
-{
-	my ($unocomponentfiles) = @_;
-
-	my @regcompfiles = ();
-
-	for ( my $i = 0; $i <= $#{$unocomponentfiles}; $i++ )
-	{
-		my $onefile = ${$unocomponentfiles}[$i];
-		my $regmergefile = "";
-		
-		if ( $onefile->{'Regmergefile'} ) { $regmergefile = $onefile->{'Regmergefile'}; }
-		if ( $regmergefile ne "" ) { next; }
-		
-		push(@regcompfiles, $onefile);
-	}
+	# If there is an older version of this file, it has to be removed
+	if ( -f $servicesfile ) { unlink($servicesfile); }
 	
-	return \@regcompfiles;
-}
-
-################################################################
-# Creating services.rdb file by registering all uno components
-################################################################
-
-sub create_services_rdb
-{
-	my ($allvariableshashref, $filesarrayref, $includepatharrayref, $languagestringref) = @_;
-
-	# collecting all services files
-	my $unocomponentfiles = installer::worker::collect_all_items_with_special_flag($filesarrayref, "UNO_COMPONENT");
-	$unocomponentfiles = filter_regmergefiles($unocomponentfiles);
+	# if ((-f $servicesfile) && (!($installer::globals::services_rdb_created))) { $installer::globals::services_rdb_created = 1; }
 	
-	if ( $#{$unocomponentfiles} > -1 )	# not empty -> at least one file with flag UNO_COMPONENT
+	# if ((!($installer::globals::services_rdb_created)) && $installer::globals::servicesrdb_can_be_created )	# This has to be done once
+	if ( $installer::globals::servicesrdb_can_be_created )	# This has to be done always
 	{
-		my $databasegids = collect_all_services_gids($unocomponentfiles);
-	
-		my $registryfiles = installer::worker::collect_all_items_with_special_flag($filesarrayref, "STARREGISTRY");
-
-		$registryfiles = check_defintion_of_databasegids($databasegids, $registryfiles);
-
-		# Now the creation of all files with flag STARREGISTRY can begin
-		
-		for ( my $i = 0; $i <= $#{$registryfiles}; $i++ )
-		{
-			my $registryfile = ${$registryfiles}[$i];
-
-			# my $servicesname = "services.rdb";
-			my $servicesname = $registryfile->{'Name'};  # not unique!
-			my $servicesgid = $registryfile->{'gid'};  # unique
-			my $uniquedirname = $servicesgid . "_servicesrdb";
-			# my $uniquedirname = $servicesgid;
-
-			installer::logger::include_header_into_logfile("Creating $servicesname ($servicesgid):");
-
-			# my $servicesdir = installer::systemactions::create_directories($servicesname, $languagestringref);
-			my $servicesdir = installer::systemactions::create_directories($uniquedirname, $languagestringref);
-
-			if ( $^O =~ /cygwin/i && $ENV{'USE_SHELL'} eq "4nt" )
-			{      # $servicesdir is used as a parameter for regcomp and has to be DOS style
-			    $servicesdir = qx{guw.exe echo "$servicesdir"};
-			    chomp($servicesdir);
-			    $servicesdir =~ s/\\/\//g;
-			}
+		# Creating the services.rdb in directory "inprogress"
+		my $origservicesdir = $servicesdir;
+		$servicesdir = installer::systemactions::make_numbered_dir("inprogress", $servicesdir);
+		$servicesfile = $servicesdir . $installer::globals::separator . $servicesname;
 
-			push(@installer::globals::removedirs, $servicesdir);
-
-			my $servicesfile = $servicesdir . $installer::globals::separator . $servicesname;
-	
-			# If there is an older version of this file, it has to be removed
-			if ( -f $servicesfile ) { unlink($servicesfile); }
-	
-			# if ((-f $servicesfile) && (!($installer::globals::services_rdb_created))) { $installer::globals::services_rdb_created = 1; }
-			# if ((!($installer::globals::services_rdb_created)) && $installer::globals::servicesrdb_can_be_created )	# This has to be done once
-			if ( $installer::globals::servicesrdb_can_be_created )	# This has to be done always
-			{
-				# Creating the services.rdb in directory "inprogress"
-				my $origservicesdir = $servicesdir;
-				$servicesdir = installer::systemactions::make_numbered_dir("inprogress", $servicesdir);
-				$servicesfile = $servicesdir . $installer::globals::separator . $servicesname;
-
-				# determining the location of the file regcomp
-				# Because the program regcomp.exe (regcomp) is used now, it has to be taken the version
-				# from the platform, this script is running. It is not important, for which platform the
-				# product is built.
+		# determining the location of the file regcomp
+		# Because the program regcomp.exe (regcomp) is used now, it has to be taken the version
+		# from the platform, this script is running. It is not important, for which platform the
+		# product is built.
 		
-				my $searchname;
+		my $searchname;
 		
-				if ($installer::globals::isunix) { $searchname = "regcomp"; }
-				else { $searchname = "regcomp.exe"; } 
+		if ($installer::globals::isunix) { $searchname = "regcomp"; }
+		else { $searchname = "regcomp.exe"; } 
 	
-				$regcompfileref = get_source_path_cygwin_safe($searchname, $includepatharrayref, 1);
-				if ( $$regcompfileref eq "" ) { installer::exiter::exit_program("ERROR: Could not find file $searchname for registering uno components!", "create_services_rdb"); }
+		$regcompfileref = installer::scriptitems::get_sourcepath_from_filename_and_includepath(\$searchname, $includepatharrayref, 1);
+		if ( $$regcompfileref eq "" ) { installer::exiter::exit_program("ERROR: Could not find file $searchname for registering uno components!", "create_services_rdb"); }
 
 		if ($installer::globals::isunix) { $searchname = "regmerge"; }
 		else { $searchname = "regmerge.exe"; } 
 	
 		$regmergefileref = installer::scriptitems::get_sourcepath_from_filename_and_includepath(\$searchname, $includepatharrayref, 1);
 		if ( $$regmergefileref eq "" ) { installer::exiter::exit_program("ERROR: Could not find file $searchname for registering uno components!", "create_services_rdb"); }
-				# For Windows the libraries included into the mozruntime.zip have to be added to the path
-				if ($installer::globals::iswin) { add_path_to_pathvariable_directory($filesarrayref, "mozruntime_zip"); }
-				if ($installer::globals::iswin) { add_path_to_pathvariable($filesarrayref, "msvcr70.dll"); }
+		# For Windows the libraries included into the mozruntime.zip have to be added to the path
+		if ($installer::globals::iswin) { add_path_to_pathvariable_directory($filesarrayref, "mozruntime_zip"); }
+		if ($installer::globals::iswin) { add_path_to_pathvariable($filesarrayref, "msvcr70.dll"); }
 
-				# setting the LD_LIBRARY_PATH, needed by regcomp
-				# Linux: Take care of the lock daemon. He has to be started!
-				# For windows it is necessary that "msvcp7x.dll" and "msvcr7x.dll" are included into the path !
+		# setting the LD_LIBRARY_PATH, needed by regcomp
+		# Linux: Take care of the lock daemon. He has to be started!
+		# For windows it is necessary that "msvcp7x.dll" and "msvcr7x.dll" are included into the path !
 
-				if ( $installer::globals::isunix ) { include_regcomp_into_ld_library_path($regcompfileref); }
+		if ( $installer::globals::isunix ) { include_regcomp_into_ld_library_path($regcompfileref); }
 
-				my $regcomprdb = "";
+		my $regcomprdb = "";
 
-				if ( $installer::globals::solarjava )	 # this is needed to register Java components
-				{
-					prepare_classpath_for_java_registration($includepatharrayref);
+		if ( $installer::globals::solarjava )	 # this is needed to register Java components
+		{
+			prepare_classpath_for_java_registration($includepatharrayref);
 			
-					if ( $installer::globals::isunix ) { add_jdklib_into_ld_library_path(); }
-					else { add_jrepath_into_path(); }
+			if ( $installer::globals::isunix ) { add_jdklib_into_ld_library_path(); }
+			else { add_jrepath_into_path(); }
 
-					# Preparing a registry which regcomp can work on (types+java services).
-					# Copying the "udkapi.rdb", renaming it to "regcomp.rdb" and registering the 
-					# libraries $(REGISTERLIBS_JAVA), which are javavm.uno.so and javaloader.uno.so
-					# or javavm.uno.dll and javaloader.uno.dll
+			# Preparing a registry which regcomp can work on (types+java services).
+			# Copying the "udkapi.rdb", renaming it to "regcomp.rdb" and registering the 
+			# libraries $(REGISTERLIBS_JAVA), which are javavm.uno.so and javaloader.uno.so
+			# or javavm.uno.dll and javaloader.uno.dll
 
-					$regcomprdb = prepare_regcomp_rdb($$regcompfileref, $servicesdir, $includepatharrayref);
-				}
+			$regcomprdb = prepare_regcomp_rdb($$regcompfileref, $servicesdir, $includepatharrayref);
+		}
 	
-				# and now iteration over all files
+		# and now iteration over all files
 		
-				# my $error_during_registration = register_all_components($filesarrayref, $regcompfileref, $servicesfile, $regcomprdb, $includepatharrayref);
-				my $error_during_registration = register_all_components($allvariableshashref, $servicesgid, $unocomponentfiles, $regcompfileref, $servicesfile, $regcomprdb, $includepatharrayref);
+		my $error_during_registration = register_all_components($filesarrayref, $regcompfileref, $servicesfile, $regcomprdb, $includepatharrayref);
 
-				# Dependent from the success, the registration directory can be renamed.
+		# Dependent from the success, the registration directory can be renamed.
 		
-				if ( $error_during_registration )
-				{
-					$servicesdir = installer::systemactions::rename_string_in_directory($servicesdir, "inprogress", "witherror");
-					push(@installer::globals::removedirs, $servicesdir);
-					# and exiting the packaging process
-					installer::exiter::exit_program("ERROR: Could not register all components for file $servicesname ($servicesgid)!", "create_services_rdb");
-				}
-				else
-				{
-			system ("$installer::globals::wrapcmd $$regmergefileref -i " . fix_cygwin_path ("${servicesfile}.internal") . " / " . fix_cygwin_path (${servicesfile}));
+		if ( $error_during_registration )
+		{
+			$servicesdir = installer::systemactions::rename_string_in_directory($servicesdir, "inprogress", "witherror");
+			push(@installer::globals::removedirs, $servicesdir);
+			# and exiting the packaging process
+			installer::exiter::exit_program("ERROR: Could not register all components!", "create_services_rdb");
+		}
+		else
+		{
+			system ("$installer::globals::wrapcmd $$regmergefileref -i ".fix_cygwin_path("${servicesfile}.internal")." / ".fix_cygwin_path(${servicesfile}));
+			sleep(10);
 			installer::systemactions::rename_one_file ("${servicesfile}.internal", ${servicesfile});
-					$servicesdir = installer::systemactions::rename_directory($servicesdir, $origservicesdir);
-				}
+			$servicesdir = installer::systemactions::rename_directory($servicesdir, $origservicesdir);
+		}
 
-				$servicesfile = $servicesdir . $installer::globals::separator . $servicesname;
-			}
-			else
-			{
-				my $infoline;
+		$servicesfile = $servicesdir . $installer::globals::separator . $servicesname;
+	}
+	else
+	{
+		my $infoline;
 
-				if (!($installer::globals::servicesrdb_can_be_created))
-				{
-					$infoline = "Warning: $servicesname was not created. Build platform and compiler do not match. Build platform: $installer::globals::plat, compiler : $installer::globals::compiler\n";
-					push( @installer::globals::logfileinfo, $infoline);
-				}
+		if (!($installer::globals::servicesrdb_can_be_created))
+		{
+			$infoline = "Warning: $servicesname was not created. Build platform and compiler do not match. Build platform: $installer::globals::plat, compiler : $installer::globals::compiler\n";
+			push( @installer::globals::logfileinfo, $infoline);
+		}
 		
-				if ( $installer::globals::services_rdb_created )
-				{
-					$infoline = "Info: $servicesname was not created. $servicesfile already exists.\n";
-					push( @installer::globals::logfileinfo, $infoline);
-				}	
+		if ( $installer::globals::services_rdb_created )
+		{
+			$infoline = "Info: $servicesname was not created. $servicesfile already exists.\n";
+			push( @installer::globals::logfileinfo, $infoline);
+		}	
 
-				if ((!($installer::globals::servicesrdb_can_be_created)) && (!($installer::globals::services_rdb_created)))
-				{
-					$infoline = "ERROR: $servicesname was not created and does not exist!\n";
-					push( @installer::globals::logfileinfo, $infoline);
-				}
-			}
-		
-			# Adding the new services file source path to the filearray
-			$registryfile->{'sourcepath'} = $servicesfile;	# setting the sourcepath!
-			# add_services_sourcepath_into_filearray( $filesarrayref, $servicesfile, $servicesname );
+		if ((!($installer::globals::servicesrdb_can_be_created)) && (!($installer::globals::services_rdb_created)))
+		{
+			$infoline = "ERROR: $servicesname was not created and does not exist!\n";
+			push( @installer::globals::logfileinfo, $infoline);
 		}
 	}
+		
+	# Adding the services.rdb to the filearray
+	
+	add_services_sourcepath_into_filearray( $filesarrayref, $servicesfile, $servicesname );
 
 	# Setting the global variable $installer::globals::services_rdb_created  
 	
 	$installer::globals::services_rdb_created = 1;
+
 }
 
-sub set_defaults_in_allvariableshashref
+################################################################
+# Helper routine to change cygwin (POSIX) path to DOS notation
+# if needed
+################################################################
+sub fix_cygwin_path
 {
-    my $allvariableshashref = shift;
+    my ( $path ) = @_;
 
-    $allvariableshashref->{'NATIVESERVICESURLPREFIX'} =
-        "vnd.sun.star.expand:\$ORIGIN/"
-        unless exists $allvariableshashref->{'NATIVESERVICESURLPREFIX'};
-    $allvariableshashref->{'JAVASERVICESURLPREFIX'} =
-        "vnd.sun.star.expand:\$UNO_JAVA_COMPONENT_PATH/"
-        unless exists $allvariableshashref->{'JAVASERVICESURLPREFIX'};
+    if ( $installer::globals::iswin eq 1 && $ENV{'USE_SHELL'} ne "4nt" && $installer::globals::wrapcmd eq "" )
+    {
+	$path = qx{cygpath -m "$path"};
+	chomp($path);
+    }
+
+    return $path;
 }
 
 1;
Only in solenv/bin/modules/installer: servicesfile.pm~
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/setupscript.pm solenv/bin/modules/installer/setupscript.pm
--- solenv.bak/bin/modules/installer/setupscript.pm	2007-11-30 14:22:58.000000000 +0100
+++ solenv/bin/modules/installer/setupscript.pm	2008-03-31 14:09:36.396090800 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: setupscript.pm,v $
 #
-#   $Revision: 1.15 $
+#   $Revision: 1.12 $
 #
-#   last change: $Author: rt $ $Date: 2007/11/30 13:22:58 $
+#   last change: $Author: rt $ $Date: 2007/07/27 14:29:17 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -284,9 +284,6 @@
 						
 			while  (!( $line =~ /^\s*End\s*$/ ))
 			{
-				if ( $counter > $#{$scriptref} ) {
-					installer::exiter::exit_program("Invalid setup script file. End of file reached before 'End' line of '$searchitem' section.", "get_all_items_from_script");
-				}
 				$line = ${$scriptref}[$counter];
 				$counter++;
 
@@ -330,8 +327,12 @@
 								$line = ${$scriptref}[$valuecounter];
 								installer::remover::remove_leading_and_ending_whitespaces(\$line);
 								$itemvalue = $itemvalue . $line;
-							}
-
+							}	
+	
+							# Not including these to itemvalues, makes the module collection readable in editor
+							# if (($gid eq "gid_Module_Root") && ($itemkey eq "Files")) { $itemvalue = "rootfiles"; }
+							# if (($gid eq "gid_Module_Root") && ($itemkey eq "Dirs")) { $itemvalue = "rootdirs"; }
+				
 							# removing ending ";"
 							$itemvalue =~ s/\;\s*$//;
 							
@@ -440,20 +441,4 @@
 	}
 }
 
-#####################################################################################
-# Adding all variables, that must be defined, but are not defined until now.
-# List of this varibles: @installer::globals::forced_properties
-#####################################################################################
-
-sub add_forced_properties
-{
-	my ($allvariables) = @_;
-
-	my $property;
-	foreach $property ( @installer::globals::forced_properties )
-	{
-		if ( ! exists($allvariables->{$property}) ) { $allvariables->{$property} = ""; }	
-	}
-}
-
 1;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/simplepackage.pm solenv/bin/modules/installer/simplepackage.pm
--- solenv.bak/bin/modules/installer/simplepackage.pm	2008-01-14 20:07:48.000000000 +0100
+++ solenv/bin/modules/installer/simplepackage.pm	2008-03-31 14:09:36.396090800 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: simplepackage.pm,v $
 #
-#   $Revision: 1.9.14.1 $
+#   $Revision: 1.6 $
 #
-#   last change: $Author: rt $ $Date: 2008/01/14 19:07:48 $
+#   last change: $Author: ihi $ $Date: 2007/07/12 11:16:19 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -59,11 +59,6 @@
 		( $installer::globals::packageformat eq "archive" ))
 	{
 		$installer::globals::is_simple_packager_project = 1;
-		$installer::globals::patch_user_dir = 1;
-	}
-	elsif( $installer::globals::packageformat eq "dmg" )
-	{
-		$installer::globals::is_simple_packager_project = 1;
 	}
 }
 
@@ -151,13 +146,12 @@
 #############################################
 # Creating the "simple" package.
 # "zip" for Windows
-# "dmg" on Mac OS X
 # "tar.gz" for all other platforms
 #############################################
 
 sub create_package
 {
-	my ( $installdir, $packagename, $allvariables, $includepatharrayref ) = @_;
+	my ( $installdir, $packagename, $includepatharrayref ) = @_;
 	
 	# moving dir into temporary directory
 	my $pid = $$; # process id
@@ -170,24 +164,24 @@
 	# creating new directory with original name
 	installer::systemactions::create_directory($installdir);
 	
-        my $archive =  $installdir . $installer::globals::separator . $packagename . $installer::globals::archiveformat;
-
-	if ( $archive =~ /zip$/ ) 
+	if ( $installer::globals::iswindowsbuild )	# Windows specific part
 	{
+		$fileextension = ".zip";
+		my $zipfilename = $packagename . $fileextension;
+		$zipfilename = $installdir . $installer::globals::separator . $zipfilename;
+
 		$from = cwd();
 		$return_to_start = 1;
 		chdir($tempdir);		
-		$systemcall = "$installer::globals::zippath -qr $archive .";
-		# $systemcall = "$installer::globals::zippath -r $archive .";
+		$systemcall = "$installer::globals::zippath -qr $zipfilename .";
+		# $systemcall = "$installer::globals::zippath -r $zipfilename .";
 	}
- 	elsif ( $archive =~ /dmg$/ )
-	{
-		installer::worker::put_scpactions_into_installset("$tempdir/$packagename");
-		my $folder = ( -l "$tempdir/$packagename/Applications" ) ? $packagename : "\.";
-		$systemcall = "cd $tempdir && hdiutil makehybrid -hfs -hfs-openfolder $folder $folder -hfs-volume-name $allvariables->{'PRODUCTNAME'} -ov -o $installdir/tmp && hdiutil convert -ov -format UDZO $installdir/tmp.dmg -o $archive && rm -f $installdir/tmp.dmg";
-	}
-	else
+	else	# Non-Windows specific part
 	{
+		$fileextension = ".tar.gz";
+		my $targzname = $packagename . $fileextension;
+		$targzname = $installdir . $installer::globals::separator . $targzname;
+
 		# getting the path of the getuid.so (only required for Solaris and Linux)
 		my $getuidlibrary = "";
 		my $ldpreloadstring = "";
@@ -197,7 +191,7 @@
 			if ( $getuidlibrary ne "" ) { $ldpreloadstring = "LD_PRELOAD=" . $getuidlibrary; }
 		}
 
-		$systemcall = "cd $tempdir; $ldpreloadstring tar -cf - . | gzip > $archive";
+		$systemcall = "cd $tempdir; $ldpreloadstring tar -cf - . | gzip > $targzname";
 	}
 
 	print "... $systemcall ...\n";
@@ -256,8 +250,7 @@
 	# Setting package name (similar to the download name)
 	my $packagename = "";
 
-	if ( $installer::globals::packageformat eq "archive"  ||
-		$installer::globals::packageformat eq "dmg" )
+	if ( $installer::globals::packageformat eq "archive" )
 	{
 		if ( $isfirstrun )
 		{
@@ -325,18 +318,13 @@
 
 		installer::systemactions::copy_one_file($source, $destination);
 
-		if (( ! $installer::globals::iswindowsbuild ) ||
-			(( $^O =~ /cygwin/i ) && ( $ENV{'USE_SHELL'} ne "4nt" )))
+		if ( ! $installer::globals::iswindowsbuild )
 		{
 			my $unixrights = "";
 			if ( $onefile->{'UnixRights'} )
 			{
 				$unixrights = $onefile->{'UnixRights'};
-				
-				# special unix rights "555" on cygwin
-				if (( $^O =~ /cygwin/i ) && ( $ENV{'USE_SHELL'} ne "4nt" ) && ( $unixrights =~ /444/ )) { $unixrights = "555"; }
-				
-				my $localcall = "$installer::globals::wrapcmd chmod $unixrights \'$destination\' \>\/dev\/null 2\>\&1";
+				my $localcall = "chmod $unixrights $destination \>\/dev\/null 2\>\&1";
 				system($localcall);
 			}
 		}
@@ -354,7 +342,7 @@
 		$destination = $subfolderdir . $installer::globals::separator . $destination;
 		my $destinationfile = $onelink->{'destinationfile'};
 	
-		my $localcall = "ln -sf \'$destinationfile\' \'$destination\' \>\/dev\/null 2\>\&1";
+		my $localcall = "ln -sf $destinationfile $destination \>\/dev\/null 2\>\&1";
 		system($localcall);
 
 		$infoline = "Creating link: \"ln -sf $destinationfile $destination\"\n"; 
@@ -367,7 +355,7 @@
 		my $target = $onelink->{'Target'};
 		my $destination = $subfolderdir . $installer::globals::separator . $onelink->{'destination'};
 	
-		my $localcall = "ln -sf \'$target\' \'$destination\' \>\/dev\/null 2\>\&1";
+		my $localcall = "ln -sf $target $destination \>\/dev\/null 2\>\&1";
 		system($localcall);
 
 		$infoline = "Creating Unix link: \"ln -sf $target $destination\"\n"; 
@@ -387,15 +375,14 @@
 
 	if ( $islastrun )
 	{
-		if ( $installer::globals::packageformat eq "archive" ||
-			$installer::globals::packageformat eq "dmg" )
+		if ( $installer::globals::packageformat eq "archive" )
 		{
 			# creating a package 
 			# -> zip for Windows
 			# -> tar.gz for all other platforms
-			installer::logger::print_message( "... creating $installer::globals::packageformat file ...\n" );
-			installer::logger::include_header_into_logfile("Creating $installer::globals::packageformat file:");
-			create_package($installdir, $packagename, $allvariables, $includepatharrayref);
+			installer::logger::print_message( "... creating archive file ...\n" );
+			installer::logger::include_header_into_logfile("Creating archive file:");
+			create_package($installdir, $packagename, $includepatharrayref);
 		}
 	}
 	
@@ -408,4 +395,4 @@
 	}
 }
 
-1;
+1;
\ No newline at end of file
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/sorter.pm solenv/bin/modules/installer/sorter.pm
--- solenv.bak/bin/modules/installer/sorter.pm	2007-09-06 11:53:39.000000000 +0200
+++ solenv/bin/modules/installer/sorter.pm	2008-03-31 14:09:36.396090800 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: sorter.pm,v $
 #
-#   $Revision: 1.5 $
+#   $Revision: 1.4 $
 #
-#   last change: $Author: kz $ $Date: 2007/09/06 09:53:39 $
+#   last change: $Author: rt $ $Date: 2005/09/08 09:11:55 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -65,36 +65,6 @@
 	}	
 }
 
-######################################################
-# Sorting an array of hashes with a numerical value
-######################################################
-
-sub sort_array_of_hashes_numerically
-{
-	my ($arrayref, $sortkey) = @_;
-	
-	for ( my $i = 0; $i <= $#{$arrayref}; $i++ )
-	{
-		my $onehashunder = ${$arrayref}[$i];
-		my $sortvalueunder = $onehashunder->{$sortkey};
-
-		for ( my $j = $i + 1; $j <= $#{$arrayref}; $j++ )
-		{
-			my $onehashover = ${$arrayref}[$j];
-			my $sortvalueover = $onehashover->{$sortkey};
-
-			if ( $sortvalueunder > $sortvalueover)
-			{				
-				${$arrayref}[$i] = $onehashover;
-				${$arrayref}[$j] = $onehashunder;
-				
-				$onehashunder = $onehashover;
-				$sortvalueunder = $sortvalueover;
-			}
-		}
-	}	
-}
-
 #########################################
 # Sorting an array of of strings
 #########################################
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/systemactions.pm solenv/bin/modules/installer/systemactions.pm
--- solenv.bak/bin/modules/installer/systemactions.pm	2007-11-21 19:49:57.000000000 +0100
+++ solenv/bin/modules/installer/systemactions.pm	2008-03-31 14:09:36.396090800 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: systemactions.pm,v $
 #
-#   $Revision: 1.35 $
+#   $Revision: 1.32 $
 #
-#   last change: $Author: ihi $ $Date: 2007/11/21 18:49:57 $
+#   last change: $Author: ihi $ $Date: 2007/07/12 11:16:33 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -60,10 +60,10 @@
 
 		if ($returnvalue)
 		{
-			$infoline = "\nCreated directory: $directory\n";
+			$infoline = "\nCreated directory: $directory\n"; 
 			push(@installer::globals::logfileinfo, $infoline);
 	
-			if ( defined $ENV{'USE_SHELL'} && $ENV{'USE_SHELL'} ne "4nt" )
+			if ($installer::globals::isunix)
 			{
 				my $localcall = "chmod 775 $directory \>\/dev\/null 2\>\&1";
 				system($localcall);
@@ -74,88 +74,21 @@
 			# New solution in parallel packing: It is possible, that the directory now exists, although it
 			# was not created in this process. There is only an important error, if the directory does not
 			# exist now. 
-
-			$infoline = "\nDid not succeed in creating directory: \"$directory\". Further attempts will follow.\n";
-			push(@installer::globals::logfileinfo, $infoline);
 			
 			if (!(-d $directory))
 			{
-				# Problem with parallel packaging? -> Try a little harder, before exiting.
-				# Did someone else remove the parent directory in the meantime?
-				my $parentdir = $directory;
-				installer::pathanalyzer::get_path_from_fullqualifiedname(\$parentdir);
-				if (!(-d $parentdir))
-				{
-					$returnvalue = mkdir($parentdir, 0775);
-
-					if ($returnvalue)
-					{
-						$infoline = "\nAttention: Successfully created parent directory (should already be created before): $parentdir\n";
-						push(@installer::globals::logfileinfo, $infoline);
-	
-						if ( defined $ENV{'USE_SHELL'} && $ENV{'USE_SHELL'} ne "4nt" )
-						{
-							my $localcall = "chmod 775 $parentdir \>\/dev\/null 2\>\&1";
-							system($localcall);
-						}			
-					}
-					else
-					{
-						$infoline = "\Error: \"$directory\" could not be created. Even the parent directory \"$parentdir\" does not exist and could not be created.\n";
-						push(@installer::globals::logfileinfo, $infoline);
-						if ( -d $parentdir )
-						{
-							$infoline = "\nAttention: Finally the parent directory \"$parentdir\" exists, but I could not create it.\n";
-							push(@installer::globals::logfileinfo, $infoline);
-						}
-						else
-						{
-							# Now it is time to exit, even the parent could not be created.
-							installer::exiter::exit_program("ERROR: Could not create parent directory \"$parentdir\"", "create_directory");
-						}
-					}		
-				}
-			
-				# At this point we have to assume, that the parent directory exist.
-				# Trying once more to create the desired directory
-
-				$returnvalue = mkdir($directory, 0775);
-
-				if ($returnvalue)
-				{
-					$infoline = "\nAttention: Created directory \"$directory\" in the second try.\n";
-					push(@installer::globals::logfileinfo, $infoline);
-	
-					if ( defined $ENV{'USE_SHELL'} && $ENV{'USE_SHELL'} ne "4nt" )
-					{
-						my $localcall = "chmod 775 $directory \>\/dev\/null 2\>\&1";
-						system($localcall);
-					}			
-				}
-				else
-				{
-					if ( -d $directory )
-					{
-						$infoline = "\nAttention: Finally the directory \"$directory\" exists, but I could not create it.\n";
-						push(@installer::globals::logfileinfo, $infoline);
-					}
-					else
-					{
-						# It is time to exit, even the second try failed.
-						installer::exiter::exit_program("ERROR: Failed to create the directory: $directory", "create_directory");
-					}	
-				}				
+				installer::exiter::exit_program("ERROR: Could not create directory: $directory", "create_directory");
 			}
 			else
 			{
-				$infoline = "\nAnother process created this directory in exactly this moment :-) : $directory\n";
-				push(@installer::globals::logfileinfo, $infoline);
+				$infoline = "\nAnother process created this directory in exactly this moment :-) : $directory\n"; 
+				push(@installer::globals::logfileinfo, $infoline);		
 			}
 		}
 	}
 	else
 	{
-		$infoline = "\nAlready existing directory, did not create: $directory\n";
+		$infoline = "\nAlready existing directory, did not create: $directory\n"; 
 		push(@installer::globals::logfileinfo, $infoline);
 	}
 }
@@ -173,15 +106,15 @@
 
 	if (!(-d $directory))
 	{
-		my $localprivileges = oct("0".$privileges); # changes "777" to 0777
+		my $localprivileges = "0" . $privileges;
 		$returnvalue = mkdir($directory, $localprivileges);
 
 		if ($returnvalue)
 		{
-			$infoline = "\nCreated directory: $directory\n";
+			$infoline = "\nCreated directory: $directory\n"; 
 			push(@installer::globals::logfileinfo, $infoline);
 	
-            if ( defined $ENV{'USE_SHELL'} && $ENV{'USE_SHELL'} ne "4nt" )
+			if ($installer::globals::isunix)
 			{
 				my $localcall = "chmod $privileges $directory \>\/dev\/null 2\>\&1";
 				system($localcall);
@@ -192,91 +125,24 @@
 			# New solution in parallel packing: It is possible, that the directory now exists, although it
 			# was not created in this process. There is only an important error, if the directory does not
 			# exist now. 
-
-			$infoline = "\nDid not succeed in creating directory: \"$directory\". Further attempts will follow.\n";
-			push(@installer::globals::logfileinfo, $infoline);
 			
 			if (!(-d $directory))
 			{
-				# Problem with parallel packaging? -> Try a little harder, before exiting.
-				# Did someone else remove the parent directory in the meantime?
-				my $parentdir = $directory;
-				installer::pathanalyzer::get_path_from_fullqualifiedname(\$parentdir);
-				if (!(-d $parentdir))
-				{
-					$returnvalue = mkdir($directory, $localprivileges);
-
-					if ($returnvalue)
-					{
-						$infoline = "\nAttention: Successfully created parent directory (should already be created before): $parentdir\n";
-						push(@installer::globals::logfileinfo, $infoline);
-	
-			            if ( defined $ENV{'USE_SHELL'} && $ENV{'USE_SHELL'} ne "4nt" )
-						{
-							my $localcall = "chmod $privileges $parentdir \>\/dev\/null 2\>\&1";
-							system($localcall);
-						}			
-					}
-					else
-					{
-						$infoline = "\Error: \"$directory\" could not be created. Even the parent directory \"$parentdir\" does not exist and could not be created.\n";
-						push(@installer::globals::logfileinfo, $infoline);
-						if ( -d $parentdir )
-						{
-							$infoline = "\nAttention: Finally the parent directory \"$parentdir\" exists, but I could not create it.\n";
-							push(@installer::globals::logfileinfo, $infoline);
-						}
-						else
-						{
-							# Now it is time to exit, even the parent could not be created.
-							installer::exiter::exit_program("ERROR: Could not create parent directory \"$parentdir\"", "create_directory_with_privileges");
-						}
-					}		
-				}
-			
-				# At this point we have to assume, that the parent directory exist.
-				# Trying once more to create the desired directory
-
-				$returnvalue = mkdir($directory, $localprivileges);
-
-				if ($returnvalue)
-				{
-					$infoline = "\nAttention: Created directory \"$directory\" in the second try.\n";
-					push(@installer::globals::logfileinfo, $infoline);
-	
-		            if ( defined $ENV{'USE_SHELL'} && $ENV{'USE_SHELL'} ne "4nt" )
-					{
-						my $localcall = "chmod $privileges $directory \>\/dev\/null 2\>\&1";
-						system($localcall);
-					}			
-				}
-				else
-				{
-					if ( -d $directory )
-					{
-						$infoline = "\nAttention: Finally the directory \"$directory\" exists, but I could not create it.\n";
-						push(@installer::globals::logfileinfo, $infoline);
-					}
-					else
-					{
-						# It is time to exit, even the second try failed.
-						installer::exiter::exit_program("ERROR: Failed to create the directory: $directory", "create_directory_with_privileges");
-					}	
-				}				
+				installer::exiter::exit_program("ERROR: Could not create directory: $directory", "create_directory");
 			}
 			else
 			{
-				$infoline = "\nAnother process created this directory in exactly this moment :-) : $directory\n";
-				push(@installer::globals::logfileinfo, $infoline);
+				$infoline = "\nAnother process created this directory in exactly this moment :-) : $directory\n"; 
+				push(@installer::globals::logfileinfo, $infoline);		
 			}
 		}
 	}
 	else
 	{
-		$infoline = "\nAlready existing directory, did not create: $directory\n";
+		$infoline = "\nAlready existing directory, did not create: $directory\n"; 
 		push(@installer::globals::logfileinfo, $infoline);
 
-		if ( defined $ENV{'USE_SHELL'} && $ENV{'USE_SHELL'} ne "4nt" )
+		if ($installer::globals::isunix)
 		{
 			my $localcall = "chmod $privileges $directory \>\/dev\/null 2\>\&1";
 			system($localcall);
@@ -328,7 +194,7 @@
 
 	my $path = "";
 
-	if (( $newdirectory eq "zip" ) || ( $newdirectory =~ /rdb\s*$/i ))	# special handling for zip files and services file because of performance reasons
+	if (( $newdirectory eq "zip" ) || ( $newdirectory =~ /rdb\s*$/ ))	# special handling for zip files and services file because of performance reasons
 	{
 		if ( $installer::globals::temppathdefined ) { $path = $installer::globals::temppath; }
 		else { $path = $installer::globals::unpackpath; }
@@ -341,7 +207,7 @@
 		else { $path = $installer::globals::unpackpath; }
 		$path =~ s/\Q$installer::globals::separator\E\s*$//;	# removing ending slashes and backslashes
 		$path = $path . $installer::globals::separator;
-		installer::systemactions::create_directory($path);
+		installer::systemactions::create_directory($path);		
 	}
 	else
 	{
@@ -404,7 +270,7 @@
 
 			if ($installer::globals::is_unix_multi) { $languagestring = $installer::globals::unixmultipath; }
 			$path = $path . $languagestring  . $installer::globals::separator;
-			create_directory($path);
+			create_directory($path);			
 		}
 	}
 	
@@ -965,7 +831,7 @@
 		}
 	}
 	
-	return \@allfiles;
+	return \@allfiles;	
 }
 
 ##############################################################
@@ -1003,15 +869,15 @@
 
 	if ( move($olddir, $newdir) )
 	{
-		$infoline = "\nMoved directory from $olddir to $newdir\n";
+		$infoline = "\nMoved directory from $olddir to $newdir\n"; 
 		push(@installer::globals::logfileinfo, $infoline);
-		$returndir = $newdir;
+		$returndir = $newdir; 
 	}
 	else
 	{
-		$infoline = "\nATTENTION: Could not move directory from $olddir to $newdir, \"make_numbered_dir\"\n";
+		$infoline = "\nATTENTION: Could not move directory from $olddir to $newdir, \"make_numbered_dir\"\n"; 
 		push(@installer::globals::logfileinfo, $infoline);
-		$returndir = $olddir;
+		$returndir = $olddir; 
 	}
 	
 	return $returndir;
@@ -1049,7 +915,7 @@
 		
 		if ( $onedir =~ /^\s*\Q$installer::globals::build\E\_\Q$installer::globals::lastminor\E\_(.*?)\-(\d+)\_(.*?)\.\Q$installer::globals::buildid\E\s*$/ )
 		{
-			my $number = $2;
+			my $number = $2;			
 			if ( $number > $maxnumber ) { $maxnumber = $number; }
 			push(@correctbuildiddirs, $onedir);
 		}
@@ -1067,7 +933,7 @@
 
 		if ( $onedir =~ /^\s*(.*?)\-(\d+)\_(.*?)\.(.*?)\s*$/ )
 		{
-			my $number = $2;
+			my $number = $2;			
 			
 			if ( $number == $maxnumber )
 			{
@@ -1088,7 +954,7 @@
 
 		if ( $onedir =~ /^\s*(.*?)\-(\d+)\_(.*?)\.(.*?)\s*$/ )
 		{
-			my $number = $2;
+			my $number = $2;			
 			my $languagestring = $3;
 			
 			if ( $languagestring eq $$languagestringref )
@@ -1122,12 +988,12 @@
 	
 	if ( move($olddir, $newdir) )
 	{
-		$infoline = "\nMoved directory from $olddir to $newdir\n";
+		$infoline = "\nMoved directory from $olddir to $newdir\n"; 
 		push(@installer::globals::logfileinfo, $infoline);
 	}
 	else
 	{
-		$infoline = "\nATTENTION: Could not move directory from $olddir to $newdir, \"rename_string_in_directory\"\n";
+		$infoline = "\nATTENTION: Could not move directory from $olddir to $newdir, \"rename_string_in_directory\"\n"; 
 		push(@installer::globals::logfileinfo, $infoline);
 	}
 	
@@ -1166,7 +1032,7 @@
 
 	if ( ! $founddir ) { installer::exiter::exit_program("ERROR: Did not find directory beginning with $startstring in directory $searchdir", "get_directoryname"); }
 	
-	return $dirname;
+	return $dirname;	
 }
 
 
@@ -1182,13 +1048,13 @@
 	
 	if ( move($olddir, $newdir) )
 	{
-		$infoline = "\nMoved directory from $olddir to $newdir\n";
+		$infoline = "\nMoved directory from $olddir to $newdir\n"; 
 		push(@installer::globals::logfileinfo, $infoline);
 	}
 	else
 	{
 		installer::exiter::exit_program("ERROR: Could not move directory from $olddir to $newdir", "rename_directory");
-		# $infoline = "\nATTENTION: Could not move directory from $olddir to $newdir, \"rename_directory\"\n";
+		# $infoline = "\nATTENTION: Could not move directory from $olddir to $newdir, \"rename_directory\"\n"; 
 		# push(@installer::globals::logfileinfo, $infoline);
 	}
 	
@@ -1212,7 +1078,7 @@
 	
 	create_directory($newdir);
 	
-	return $newdir;
+	return $newdir;	
 }
 
 ##############################################################
@@ -1423,10 +1289,10 @@
 		if ($returnvalue)
 		{
 			$created_directory = 1;
-			$infoline = "\nCreated directory: $directory\n";
+			$infoline = "\nCreated directory: $directory\n"; 
 			push(@installer::globals::logfileinfo, $infoline);
 	
-            if ( defined $ENV{'USE_SHELL'} && $ENV{'USE_SHELL'} ne "4nt" )
+			if ($installer::globals::isunix)
 			{
 				my $localcall = "chmod 775 $directory \>\/dev\/null 2\>\&1";
 				system($localcall);
@@ -1439,7 +1305,7 @@
 	}
 	else
 	{
-		$created_directory = 1;
+		$created_directory = 1;	
 	}
 
 	return $created_directory;
@@ -1523,7 +1389,7 @@
 		if ( ! $returnvalue )
 		{
 			$infoline = "Warning: Problem with removing empty dir $directory\n";
-			push(@installer::globals::logfileinfo, $infoline);
+			push(@installer::globals::logfileinfo, $infoline);	
 		}
 		
 		# try a little bit harder (sometimes there is a performance problem)
@@ -1543,10 +1409,10 @@
 					if ( $returnvalue )
 					{
 						$infoline = "Successfully removed empty dir $directory\n";
-						push(@installer::globals::logfileinfo, $infoline);
+						push(@installer::globals::logfileinfo, $infoline);	
 					} else {
 						$infoline = "Warning: rmdir $directory failed.\n";
-						push(@installer::globals::logfileinfo, $infoline);
+						push(@installer::globals::logfileinfo, $infoline);	
 					}
 				}
 			}
@@ -1567,18 +1433,18 @@
 	
 	my $counter = 1;
 	my $created = 0;
-	my $localdirectory = "";
+	my $localdirectory = "";	
 
 	do
 	{
-		$localdirectory = $directory;
+		$localdirectory = $directory; 
 		$localdirectory =~ s/INCREASINGNUMBER/$counter/;
-		$counter++;
+		$counter++;			
 		
 		if ( ! -d $localdirectory )
 		{
 			create_directory($localdirectory);
-			$created = 1;
+			$created = 1;	
 		}		
 	}
 	while ( ! $created );
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/windows/component.pm solenv/bin/modules/installer/windows/component.pm
--- solenv.bak/bin/modules/installer/windows/component.pm	2008-03-28 10:37:50.212125000 +0100
+++ solenv/bin/modules/installer/windows/component.pm	2008-03-31 14:09:36.396090800 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: component.pm,v $
 #
-#   $Revision: 1.11 $
+#   $Revision: 1.10 $
 #
-#   last change: $Author: ihi $ $Date: 2007/11/26 16:18:42 $
+#   last change: $Author: rt $ $Date: 2007/07/26 08:48:21 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -231,8 +231,6 @@
 	
 	$attributes = 4;
 	
-	if ( exists($installer::globals::dontdeletecomponents{$componentname}) ) { $attributes = $attributes + 16; } 
-	
 	return $attributes	
 }
 
@@ -247,11 +245,6 @@
 	my ($componentname, $filesref) = @_;
 	
 	my $condition = "";
-
-	if (exists($installer::globals::componentcondition{$componentname}))
-	{
-		$condition = $installer::globals::componentcondition{$componentname};
-	}
 	
 	return $condition	
 }
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/windows/directory.pm solenv/bin/modules/installer/windows/directory.pm
--- solenv.bak/bin/modules/installer/windows/directory.pm	2008-03-28 10:37:50.227750000 +0100
+++ solenv/bin/modules/installer/windows/directory.pm	2008-03-31 14:09:36.411715400 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: directory.pm,v $
 #
-#   $Revision: 1.25.50.1 $
+#   $Revision: 1.22 $
 #
-#   last change: $Author: rt $ $Date: 2008/01/14 15:29:09 $
+#   last change: $Author: gm $ $Date: 2007/05/10 10:59:51 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -41,20 +41,6 @@
 use installer::windows::idtglobal;
 
 ##############################################################
-# Overwriting global programfilesfolder, if required
-##############################################################
-
-sub overwrite_programfilesfolder
-{
-	my ( $allvariables ) = @_;
-	
-	if ( $allvariables->{'PROGRAMFILESFOLDERNAME'} )
-	{
-		$installer::globals::programfilesfolder = $allvariables->{'PROGRAMFILESFOLDERNAME'};
-	}
-}
-
-##############################################################
 # Adding unique directory names to the directory collection
 ##############################################################
 
@@ -66,8 +52,6 @@
 	{
 		my $onedir = ${$directoryref}[$i];
 		my $uniquename = $onedir->{'HostName'};
-		my $styles = "";
-		if ( $onedir->{'Styles'} ) { $styles = $onedir->{'Styles'}; }
 		# get_path_from_fullqualifiedname(\$uniqueparentname);
 		# making /registry/schema/org/openoffice/VCL.xcs to VCL.xcs 
 
@@ -86,12 +70,6 @@
 			$uniqueparentname = "INSTALLLOCATION";
 		}
 
-		if ( $styles =~ /\bPROGRAMFILESFOLDER\b/ ) { $uniqueparentname = $installer::globals::programfilesfolder; }
-		if ( $styles =~ /\bCOMMONFILESFOLDER\b/ ) { $uniqueparentname = $installer::globals::commonfilesfolder; }
-		if ( $styles =~ /\bCOMMONAPPDATAFOLDER\b/ ) { $uniqueparentname = $installer::globals::commonappdatafolder; }
-		if ( $styles =~ /\bLOCALAPPDATAFOLDER\b/ ) { $uniqueparentname = $installer::globals::localappdatafolder; }
-
-
 		$uniquename =~ s/\-/\_/g;			# making "-" to "_"
 		$uniqueparentname =~ s/\-/\_/g;		# making "-" to "_"
 		
@@ -243,21 +221,9 @@
 		my $realproductkey = $productname . " " . $productversion;
 		my $productkey = $productname . " " . $baseproductversion;
 		
-		if (( $allvariableshashref->{'POSTVERSIONEXTENSION'} ) && ( ! $allvariableshashref->{'DONTUSEEXTENSIONINDEFAULTDIR'} )) 
-		{
-			$productkey = $productkey . " " . $allvariableshashref->{'POSTVERSIONEXTENSION'}; 
-			$realproductkey = $realproductkey . " " . $allvariableshashref->{'POSTVERSIONEXTENSION'}; 
-		}
-		if ( $allvariableshashref->{'NOVERSIONINDIRNAME'} ) 
-		{ 
-			$productkey = $productname; 
-			$realproductkey = $realproductname; 
-		}
-		if ( $allvariableshashref->{'NOSPACEINDIRECTORYNAME'} ) 
-		{
-			$productkey =~ s/\ /\_/g; 
-			$realproductkey =~ s/\ /\_/g; 
-		}
+		if (( $allvariableshashref->{'POSTVERSIONEXTENSION'} ) && ( ! $allvariableshashref->{'DONTUSEEXTENSIONINDEFAULTDIR'} )) { $productkey = $productkey . " " . $allvariableshashref->{'POSTVERSIONEXTENSION'}; }
+		if ( $allvariableshashref->{'NOVERSIONINDIRNAME'} ) { $productkey = $productname; }
+		if ( $allvariableshashref->{'NOSPACEINDIRECTORYNAME'} ) { $productkey =~ s/\ /\_/g; }
 		
 		my $shortproductkey = installer::windows::idtglobal::make_eight_three_conform($productkey, "dir");		# third parameter not used
 		$shortproductkey =~ s/\s/\_/g;									# changing empty space to underline
@@ -288,21 +254,6 @@
 		$oneline = "$installer::globals::startupfolder\tTARGETDIR\t.\n";
 		push(@{$directorytableref}, $oneline);
 
-		$oneline = "$installer::globals::desktopfolder\tTARGETDIR\t.\n";
-		push(@{$directorytableref}, $oneline);
-
-		$oneline = "$installer::globals::startmenufolder\tTARGETDIR\t.\n";
-		push(@{$directorytableref}, $oneline);
-
-		$oneline = "$installer::globals::commonfilesfolder\tTARGETDIR\t.\n";
-		push(@{$directorytableref}, $oneline);
-
-		$oneline = "$installer::globals::commonappdatafolder\tTARGETDIR\t.\n";
-		push(@{$directorytableref}, $oneline);
-
-		$oneline = "$installer::globals::localappdatafolder\tTARGETDIR\t.\n";
-		push(@{$directorytableref}, $oneline);
-
 		my $localtemplatefoldername = $installer::globals::templatefoldername;
 		my $directorytableentry = $localtemplatefoldername;
 		my $shorttemplatefoldername = installer::windows::idtglobal::make_eight_three_conform($localtemplatefoldername, "dir");
@@ -348,8 +299,7 @@
 
 	my @directorytable = ();
 	my $infoline;
-	
-	overwrite_programfilesfolder($allvariableshashref);
+
 	create_unique_directorynames($directoryref);
 	create_defaultdir_directorynames($directoryref);	# only destdir!
 	installer::windows::idtglobal::write_idt_header(\@directorytable, "directory");
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/windows/feature.pm solenv/bin/modules/installer/windows/feature.pm
--- solenv.bak/bin/modules/installer/windows/feature.pm	2007-09-06 11:54:50.000000000 +0200
+++ solenv/bin/modules/installer/windows/feature.pm	2008-03-31 14:09:36.411715400 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: feature.pm,v $
 #
-#   $Revision: 1.19 $
+#   $Revision: 1.17 $
 #
-#   last change: $Author: kz $ $Date: 2007/09/06 09:54:50 $
+#   last change: $Author: rt $ $Date: 2007/07/06 12:25:37 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -39,7 +39,6 @@
 use installer::exiter;
 use installer::files;
 use installer::globals;
-use installer::sorter;
 use installer::worker;
 use installer::windows::idtglobal;
 use installer::windows::language;
@@ -80,7 +79,7 @@
 	# Only then it is possible to make the "real" root module invisible by 
 	# setting the display to "0". 
 	
-	if ( $parentgid eq $installer::globals::rootmodulegid ) { $parentgid = ""; }
+	if ( $parentgid eq "gid_Module_Root" ) { $parentgid = ""; }
 
 	# Attention: Maximum feature length is 38!
 	installer::windows::idtglobal::shorten_feature_gid(\$parentgid);
@@ -122,7 +121,7 @@
 	my $styles = "";
 	if ( $onefeature->{'Styles'} ) { $styles = $onefeature->{'Styles'}; }
 	
-	if (( $parentid eq $installer::globals::rootmodulegid ) && ( $styles =~ /\bHIDDEN_ROOT\b/ ))
+	if (( $parentid eq "gid_Module_Root" ) && ( $styles =~ /\bHIDDEN_ROOT\b/ ))
 	{
 		$display = "0";
 	}
@@ -176,7 +175,18 @@
 	
 	my $directory;
 	
-	$directory = "INSTALLLOCATION";
+	# my $parentid = "";
+	
+	# if ( $onefeature->{'ParentID'} ) { $parentid = $onefeature->{'ParentID'}; }
+
+	# if (( $parentid eq "" ) || ( $parentid eq "gid_Module_Root" ))	# This is the root module and the modules directly below the root
+	# {
+		$directory = "INSTALLLOCATION";
+	# }
+	# else
+	# {
+	#	$directory = "";
+	# }	
 	
 	return $directory	
 }
@@ -197,7 +207,7 @@
 	my $parentgid = "";
 	if ( $onefeature->{'ParentID'} ) { $parentgid = $onefeature->{'ParentID'}; }
 
-	if (( $parentgid eq "" ) || ( $parentgid eq $installer::globals::rootmodulegid )) { $attributes = "8"; }
+	if (( $parentgid eq "" ) || ( $parentgid eq "gid_Module_Root" )) { $attributes = "8"; }
 	else { $attributes = "10"; }
 	
 	return $attributes	
@@ -252,7 +262,6 @@
 
 		# $languagemodules contains all modules with flag LANGUAGEMODULE
 		# Now it is time to find the correct feature using the gid.
-		
 		my $onefeature = installer::worker::find_item_by_gid($languagemodules, $gid);
 		if ( $onefeature eq "" ) { installer::exiter::exit_program("ERROR: Language feature not found: $gid !", "add_language_pack_feature"); }
 
@@ -368,141 +377,6 @@
 }
 
 #################################################################################
-# Collecting the feature recursively.
-#################################################################################
-
-sub collect_modules_recursive
-{
-	my ($modulesref, $parentid, $feature, $directaccess, $directgid, $directparent, $directsortkey, $sorted) = @_;
-
-	my @allchildren = ();
-	my $childrenexist = 0;
-
-	# Collecting children from Module $parentid
-	
-	my $modulegid;
-	foreach $modulegid ( keys %{$directparent})
-	{		
-		if ( $directparent->{$modulegid} eq $parentid )
-		{
-			my %childhash = ( "gid" => "$modulegid", "Sortkey" => "$directsortkey->{$modulegid}");
-			push(@allchildren, \%childhash);
-			$childrenexist = 1;
-		}
-	}
-
-	# Sorting children
-	
-	if ( $childrenexist )
-	{	
-		# Sort children
-		installer::sorter::sort_array_of_hashes_numerically(\@allchildren, "Sortkey");
-
-		# Adding children to new array
-		my $childhashref;
-		foreach $childhashref ( @allchildren )
-		{
-			my $gid = $childhashref->{'gid'};
-
-			# Saving all lines, that have this 'gid'
-			
-			my $unique;
-			foreach $unique ( keys %{$directgid} )
-			{
-				if ( $directgid->{$unique} eq $gid )
-				{
-					push(@{$feature}, ${$modulesref}[$directaccess->{$unique}]);
-					if ( $sorted->{$unique} == 1 ) { installer::exiter::exit_program("ERROR: Sorting feature failed! \"$unique\" already sorted.", "sort_feature"); }
-					$sorted->{$unique} = 1;
-				}
-			}
-
-			collect_modules_recursive($modulesref, $gid, $feature, $directaccess, $directgid, $directparent, $directsortkey, $sorted);
-		}
-	}
-}
-
-#################################################################################
-# Sorting the feature in specified order. Evaluated is the key "Sortkey", that
-# is set in scp2 projects.
-# The display order of modules in Windows Installer is dependent from the order
-# in the idt file. Therefore the order of the modules array has to be adapted 
-# to the Sortkey order, before the idt file is created.
-#################################################################################
-
-sub sort_feature
-{
-	my ($modulesref) = @_;
-	
-	my @feature = ();
-	
-	my %directaccess = ();
-	my %directparent = ();
-	my %directgid = ();
-	my %directsortkey = ();
-	my %sorted = ();
-
-	for ( my $i = 0; $i <= $#{$modulesref}; $i++ )
-	{
-		my $onefeature = ${$modulesref}[$i];
-
-		my $uniquekey = $onefeature->{'uniquekey'};
-		my $modulegid = $onefeature->{'gid'};
-		
-		$directaccess{$uniquekey} = $i;
-		
-		$directgid{$uniquekey} = $onefeature->{'gid'};
-		
-		# ParentID and Sortkey are not saved for the 'uniquekey', but only for the 'gid'
-
-		if ( $onefeature->{'ParentID'} ) { $directparent{$modulegid} = $onefeature->{'ParentID'}; }
-		else { $directparent{$modulegid} = ""; }
-
-		if ( $onefeature->{'Sortkey'} ) { $directsortkey{$modulegid} = $onefeature->{'Sortkey'}; }
-		else { $directsortkey{$modulegid} = "9999"; }
-		
-		# Bookkeeping:
-		$sorted{$uniquekey} = 0;
-	}
-
-	# Searching all feature recursively, beginning with ParentID = ""
-	my $parentid = "";
-	collect_modules_recursive($modulesref, $parentid, \@feature, \%directaccess, \%directgid, \%directparent, \%directsortkey, \%sorted);
-
-	# Bookkeeping
-	my $modulekey;
-	foreach $modulekey ( keys %sorted )
-	{
-		if ( $sorted{$modulekey} == 0 )
-		{
-			my $infoline = "Warning: Module \"$modulekey\" could not be sorted. Added to the end of the module array.\n";
-			push(@installer::globals::logfileinfo, $infoline);
-			push(@feature, ${$modulesref}[$directaccess{$modulekey}]);
-		}
-	}
-
-	return \@feature;
-}
-
-#################################################################################
-# Adding a unique key to the modules array. The gid is not unique for 
-# multilingual modules. Only the combination from gid and specific language
-# is unique. Uniqueness is required for sorting mechanism.
-#################################################################################
-
-sub add_uniquekey
-{
-	my ( $modulesref ) = @_;
-
-	for ( my $i = 0; $i <= $#{$modulesref}; $i++ )
-	{
-		my $uniquekey = ${$modulesref}[$i]->{'gid'};
-		if ( ${$modulesref}[$i]->{'specificlanguage'} ) { $uniquekey = $uniquekey . "_" . ${$modulesref}[$i]->{'specificlanguage'}; }
-		${$modulesref}[$i]->{'uniquekey'} = $uniquekey;
-	}
-}
-
-#################################################################################
 # Creating the file Feature.idt dynamically
 # Content: 
 # Feature Feature_Parent Title Description Display Level Directory_ Attributes
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/windows/file.pm solenv/bin/modules/installer/windows/file.pm
--- solenv.bak/bin/modules/installer/windows/file.pm	2008-03-26 20:30:18.930875000 +0100
+++ solenv/bin/modules/installer/windows/file.pm	2008-03-31 14:09:36.411715400 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: file.pm,v $
 #
-#   $Revision: 1.17 $
+#   $Revision: 1.14 $
 #
-#   last change: $Author: kz $ $Date: 2007/12/12 14:54:52 $
+#   last change: $Author: rt $ $Date: 2007/07/26 08:48:33 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -46,137 +46,6 @@
 use installer::windows::idtglobal;
 use installer::windows::language;
 
-##########################################################################
-# Assigning one cabinet file to each file. This is requrired,
-# if cabinet files shall be equivalent to packages.
-##########################################################################
-
-sub assign_cab_to_files
-{
-	my ( $filesref ) = @_;
-	
-	my $infoline = "";
-
-	for ( my $i = 0; $i <= $#{$filesref}; $i++ )
-	{
-		if ( ! exists(${$filesref}[$i]->{'modules'}) ) { installer::exiter::exit_program("ERROR: No module assignment found for ${$filesref}[$i]->{'gid'} !", "assign_cab_to_files"); }
-		my $module = ${$filesref}[$i]->{'modules'};
-		# If modules contains a list of modules, only taking the first one.
-		if ( $module =~ /^\s*(.*?)\,/ ) { $module = $1; }
-
-		if ( ! exists($installer::globals::allcabinetassigns{$module}) ) { installer::exiter::exit_program("ERROR: No cabinet file assigned to module \"$module\" !", "assign_cab_to_files"); }
-		${$filesref}[$i]->{'assignedcabinetfile'} = $installer::globals::allcabinetassigns{$module};
-
-		# Counting the files in each cabinet file
-		if ( ! exists($installer::globals::cabfilecounter{${$filesref}[$i]->{'assignedcabinetfile'}}) )
-		{
-			$installer::globals::cabfilecounter{${$filesref}[$i]->{'assignedcabinetfile'}} = 1;
-		}
-		else
-		{
-			$installer::globals::cabfilecounter{${$filesref}[$i]->{'assignedcabinetfile'}}++;
-		}
-	}
-
-	# logging the number of files in each cabinet file
-
-	$infoline = "\nCabinet file content:\n"; 
-	push(@installer::globals::logfileinfo, $infoline);
-	my $cabfile;
-	foreach $cabfile ( sort keys %installer::globals::cabfilecounter )
-	{
-		$infoline = "$cabfile : $installer::globals::cabfilecounter{$cabfile} files\n";
-		push(@installer::globals::logfileinfo, $infoline);
-	}
-	
-	# assigning startsequencenumbers for each cab file
-	
-	my $offset = 1;
-	foreach $cabfile ( sort keys %installer::globals::cabfilecounter )
-	{
-		my $filecount = $installer::globals::cabfilecounter{$cabfile};
-		$installer::globals::cabfilecounter{$cabfile} = $offset;
-		$offset = $offset + $filecount;
-		
-		$installer::globals::lastsequence{$cabfile} = $offset - 1;
-	}
-	
-	# logging the start sequence numbers
-
-	$infoline = "\nCabinet file start sequences:\n"; 
-	push(@installer::globals::logfileinfo, $infoline);
-	foreach $cabfile ( sort keys %installer::globals::cabfilecounter )
-	{
-		$infoline = "$cabfile : $installer::globals::cabfilecounter{$cabfile}\n";
-		push(@installer::globals::logfileinfo, $infoline);
-	}
-
-	# logging the last sequence numbers
-
-	$infoline = "\nCabinet file last sequences:\n"; 
-	push(@installer::globals::logfileinfo, $infoline);
-	foreach $cabfile ( sort keys %installer::globals::lastsequence )
-	{
-		$infoline = "$cabfile : $installer::globals::lastsequence{$cabfile}\n";
-		push(@installer::globals::logfileinfo, $infoline);
-	}
-}
-
-##########################################################################
-# Assigning sequencenumbers to files. This is requrired,
-# if cabinet files shall be equivalent to packages.
-##########################################################################
-
-sub assign_sequencenumbers_to_files
-{
-	my ( $filesref ) = @_;
-	
-	my %directaccess = ();
-	my %allassigns = ();
-	
-	for ( my $i = 0; $i <= $#{$filesref}; $i++ )
-	{
-		my $onefile = ${$filesref}[$i];
-		
-		# Keeping order in cabinet files
-		# -> collecting all files in one cabinet file
-		# -> sorting files and assigning numbers
-
-		# Saving counter $i for direct access into files array
-		# "destination" of the file is a unique identifier ('Name' is not unique!)
-		if ( exists($directaccess{$onefile->{'destination'}}) ) { installer::exiter::exit_program("ERROR: 'destination' at file not unique: $onefile->{'destination'}", "assign_sequencenumbers_to_files"); }
-		$directaccess{$onefile->{'destination'}} = $i;
-
-		my $cabfilename = $onefile->{'assignedcabinetfile'};
-		# collecting files in cabinet files
-		if ( ! exists($allassigns{$cabfilename}) )
-		{
-			my %onecabfile = ();
-			$onecabfile{$onefile->{'destination'}} = 1;			
-			$allassigns{$cabfilename} = \%onecabfile;
-		}
-		else
-		{
-			$allassigns{$cabfilename}->{$onefile->{'destination'}} = 1;
-		}
-	}
-	
-	# Sorting each hash and assigning numbers
-	# The destination of the file determines the sort order, not the filename! 
-	my $cabfile;
-	foreach $cabfile ( sort keys %allassigns )
-	{
-		my $counter = $installer::globals::cabfilecounter{$cabfile};
-		my $dest;
-		foreach $dest ( sort keys %{$allassigns{$cabfile}} ) # <- sorting the destination!
-		{
-			my $directaccessnumber = $directaccess{$dest};
-			${$filesref}[$directaccessnumber]->{'assignedsequencenumber'} = $counter;			
-			$counter++;
-		}
-	}
-}
-
 ###############################################
 # Generating the component name from a file
 ###############################################
@@ -417,7 +286,7 @@
 	
 	if ( -f $file )	# test of existence. For instance services.rdb does not always exist
 	{
-		$filesize = ( -s $file );	# file size can be "0"
+		$filesize = (stat($file))[7];	# file size can be "0"
 	}
 	else
 	{
@@ -467,28 +336,19 @@
 
 sub get_sequence_for_file
 {
-	my ($number, $onefile) = @_;
+	my ($number) = @_;
 
-	my $sequence = "";
+	my $sequence = $number;
+	# my $sequence = $number + 1;
 	
-	if (( $onefile->{'assignedsequencenumber'} ) && ( $installer::globals::use_packages_for_cabs ))
-	{
-		$sequence = $onefile->{'assignedsequencenumber'};		
-	}
-	else
-	{
-		$sequence = $number;
-		# my $sequence = $number + 1;
-
-		# Idea: Each component is packed into a cab file.
-		# This requires that all files in one cab file have sequences directly follwing each other, 
-		# for instance from 1456 to 1466. Then in the media table the LastSequence for this cab file
-		# is 1466.
-		# Because all files belonging to one component are directly behind each other in the file 
-		# collector, it is possible to use simply an increasing number as sequence value. 
-		# If files belonging to one component are not directly behind each other in the files collector
-		# this mechanism will no longer work.
-	}
+	# Idea: Each component is packed into a cab file.
+	# This requires that all files in one cab file have sequences directly follwing each other, 
+	# for instance from 1456 to 1466. Then in the media table the LastSequence for this cab file
+	# is 1466.
+	# Because all files belonging to one component are directly behind each other in the file 
+	# collector, it is possible to use simply an increasing number as sequence value. 
+	# If files belonging to one component are not directly behind each other in the files collector
+	# this mechanism will no longer work.
 	
 	return $sequence;	
 }
@@ -600,7 +460,7 @@
 		# $file{'Attributes'} = "8192"; 	# Sourcefile is unpacked
 
 		$counter++;
-		$file{'Sequence'} = get_sequence_for_file($counter, $onefile);
+		$file{'Sequence'} = get_sequence_for_file($counter);
 
 		$onefile->{'sequencenumber'} = $file{'Sequence'};
 
@@ -612,15 +472,6 @@
 
 		push(@allfiles, $onefile);
 
-		# Collecting all component conditions
-		if ( $onefile->{'ComponentCondition'} )
-		{			
-			if ( ! exists($installer::globals::componentcondition{$file{'Component_'}}))
-			{
-				$installer::globals::componentcondition{$file{'Component_'}} = $onefile->{'ComponentCondition'};
-			}
-		}
-
 		if ( $installer::globals::prepare_winpatch )
 		{
 			my $path = $onefile->{'sourcepath'};
Only in solenv/bin/modules/installer/windows: file.pm~
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/windows/idtglobal.pm solenv/bin/modules/installer/windows/idtglobal.pm
--- solenv.bak/bin/modules/installer/windows/idtglobal.pm	2008-01-31 10:54:40.000000000 +0100
+++ solenv/bin/modules/installer/windows/idtglobal.pm	2008-03-31 14:09:36.411715400 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: idtglobal.pm,v $
 #
-#   $Revision: 1.38.2.1 $
+#   $Revision: 1.35 $
 #
-#   last change: $Author: obo $ $Date: 2008/01/31 09:54:40 $
+#   last change: $Author: ihi $ $Date: 2007/07/11 14:41:02 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -1580,7 +1580,7 @@
 
 	if (( $installer::globals::javafile eq "" ) && ( $allvariables->{'JAVAPRODUCT'} )) { installer::exiter::exit_program("ERROR: No JAVAFILE found in files collector!", "add_childprojects"); }
 	if (( $installer::globals::adafile eq "" ) && ( $allvariables->{'ADAPRODUCT'} )) { installer::exiter::exit_program("ERROR: No ADAFILE found in files collector!", "add_childprojects"); }
-	if (( $installer::globals::urefile eq "" ) && ( $allvariables->{'UREPRODUCT'} )) { installer::exiter::exit_program("ERROR: No UREFILE found in files collector!", "add_childprojects"); }
+	if (( $installer::globals::urefile eq "" ) && ( $allvariables->{'UREPRODUCT'} )) { installer::exiter::exit_program("ERROR: No ADAFILE found in files collector!", "add_childprojects"); }
 
 	# Content for Directory table	
 	# SystemFolder TARGETDIR .
@@ -1643,7 +1643,7 @@
 	
 	if ( $allvariables->{'JAVAPRODUCT'} ) { include_subdir_into_componenttable($subjavadir, $installer::globals::javafile, $componenttable); }
 	if ( $allvariables->{'ADAPRODUCT'} ) { include_subdir_into_componenttable($subadadir, $installer::globals::adafile, $componenttable); }
-	if ( $allvariables->{'UREPRODUCT'} ) { include_subdir_into_componenttable($suburedir, $installer::globals::urefile, $componenttable); }
+	if ( $allvariables->{'UERPRODUCT'} ) { include_subdir_into_componenttable($suburedir, $installer::globals::urefile, $componenttable); }
 
 	# Content for CustomAction table
 
@@ -1658,7 +1658,7 @@
 	
 	if ( $allvariables->{'JAVAPRODUCT'} )
 	{
-		$line = "InstallJava\t98\tSystemFolder\t[SourceDir]$installer::globals::javafile->{'Subdir'}\\$installer::globals::javafile->{'Name'} \/qb REBOOT=Suppress SPONSORS=0 DISABLEAD=1\n";
+		$line = "InstallJava\t98\tSystemFolder\t[SourceDir]$installer::globals::javafile->{'Subdir'}\\$installer::globals::javafile->{'Name'} \/s \/v\"\/qr REBOOT=Suppress\"\n";
 		push(@{$customactiontable} ,$line);
 		installer::remover::remove_leading_and_ending_whitespaces(\$line);
 		$infoline = "Added $line into table $customactiontablename\n";
@@ -1685,7 +1685,7 @@
 	
 	if ( $allvariables->{'JAVAPRODUCT'} )
 	{
-		$line = "MaintenanceJava\t82\t$installer::globals::javafile->{'uniquename'}\t\/qb REBOOT=Suppress SPONSORS=0 DISABLEAD=1\n";
+		$line = "MaintenanceJava\t82\t$installer::globals::javafile->{'uniquename'}\t\/s \/v\"\/qr REBOOT=Suppress\"\n";
 		push(@{$customactiontable} ,$line);
 		installer::remover::remove_leading_and_ending_whitespaces(\$line);
 		$infoline = "Added $line into table $customactiontablename\n";
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/windows/media.pm solenv/bin/modules/installer/windows/media.pm
--- solenv.bak/bin/modules/installer/windows/media.pm	2007-11-26 17:30:34.000000000 +0100
+++ solenv/bin/modules/installer/windows/media.pm	2008-03-31 14:09:36.427340000 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: media.pm,v $
 #
-#   $Revision: 1.10 $
+#   $Revision: 1.8 $
 #
-#   last change: $Author: ihi $ $Date: 2007/11/26 16:30:34 $
+#   last change: $Author: ihi $ $Date: 2007/03/26 12:45:16 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -159,20 +159,6 @@
 }
 
 #################################################
-# Creating the cab file name for cab files
-# defined in packages.
-#################################################
-
-sub get_cabfilename
-{
-	my ($name) = @_;
-	
-	if ( $installer::globals::include_cab_in_msi ) { $name = "\#" . $name; }
-
-	return $name;	
-}
-
-#################################################
 # Creating the cab file name dynamically
 #################################################
 
@@ -231,30 +217,10 @@
 
 	installer::windows::idtglobal::write_idt_header(\@mediatable, "media");
 	
-	if ( $allvariables->{'INCLUDE_CAB_IN_MSI'} ) { $installer::globals::include_cab_in_msi = 1; }
-
-	if ( $installer::globals::use_packages_for_cabs )
-	{
-		my $cabfile;
-		foreach $cabfile ( sort keys %installer::globals::lastsequence )
-		{
-			my %media = ();
-			$diskid++;
-		
-			$media{'DiskId'} = get_media_diskid($diskid);
-			$media{'LastSequence'} = $installer::globals::lastsequence{$cabfile};
-			$media{'DiskPrompt'} = get_media_diskprompt();
-			$media{'Cabinet'} = get_cabfilename($cabfile);
-			$media{'VolumeLabel'} = get_media_volumelabel();
-			$media{'Source'} = get_media_source();
-
-			my $oneline = $media{'DiskId'} . "\t" . $media{'LastSequence'} . "\t" . $media{'DiskPrompt'} . "\t"  
-						. $media{'Cabinet'} . "\t" . $media{'VolumeLabel'} . "\t" . $media{'Source'} . "\n";
+	if ( $installer::globals::product =~ /ada/i ) { $installer::globals::include_cab_in_msi = 1; }
+	if ( $installer::globals::product =~ /4ms/i ) { $installer::globals::include_cab_in_msi = 1; }
 
-			push(@mediatable, $oneline);
-		}
-	}
-	elsif ( $installer::globals::cab_file_per_component )
+	if ( $installer::globals::cab_file_per_component )
 	{
 		for ( my $i = 0; $i <= $#{$filesref}; $i++ )
 		{
@@ -397,4 +363,4 @@
 	push(@installer::globals::logfileinfo, $infoline);
 }
 
-1;
+1;
\ No newline at end of file
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/windows/msiglobal.pm solenv/bin/modules/installer/windows/msiglobal.pm
--- solenv.bak/bin/modules/installer/windows/msiglobal.pm	2007-12-12 15:55:30.000000000 +0100
+++ solenv/bin/modules/installer/windows/msiglobal.pm	2008-03-31 14:09:36.427340000 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: msiglobal.pm,v $
 #
-#   $Revision: 1.44 $
+#   $Revision: 1.40 $
 #
-#   last change: $Author: kz $ $Date: 2007/12/12 14:55:30 $
+#   last change: $Author: ihi $ $Date: 2007/07/12 11:17:01 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -141,26 +141,6 @@
 }
 
 ##########################################################################
-# Returning the order of the sequences in the files array.
-##########################################################################
-
-sub get_sequenceorder
-{
-	my ($filesref) = @_;
-
-	my %order = ();
-	
-	for ( my $i = 0; $i <= $#{$filesref}; $i++ )
-	{
-		my $onefile = ${$filesref}[$i];
-		if ( ! $onefile->{'assignedsequencenumber'} ) { installer::exiter::exit_program("ERROR: Sequence number assigned to $onefile->{'gid'}!", "get_sequenceorder"); }
-		$order{$onefile->{'assignedsequencenumber'}} = $i;
-	}
-	
-	return \%order;
-}
-
-##########################################################################
 # Generation the list, in which the source of the files is connected
 # with the cabinet destination file. Because more than one file needs
 # to be included into a cab file, this has to be done via ddf files.
@@ -178,93 +158,7 @@
 
 	if ( $^O =~ /cygwin/i ) { installer::worker::generate_cygwin_pathes($filesref); }
 
-	if ( $installer::globals::use_packages_for_cabs )
-	{
-		my $sequenceorder = get_sequenceorder($filesref);
-		
-		my $counter = 1;
-		my $currentcabfile = "";
-		
-		while ( exists($sequenceorder->{$counter}) )
-		{
-			# Files with increasing sequencerorder are included in one cab file
-			my $onefile = ${$filesref}[$sequenceorder->{$counter}];
-			my $cabinetfile = $onefile->{'assignedcabinetfile'};
-			my $sourcepath =  $onefile->{'sourcepath'};
-			if ( $^O =~ /cygwin/i ) { $sourcepath = $onefile->{'cyg_sourcepath'}; }
-			my $uniquename =  $onefile->{'uniquename'};
-
-			my $styles = "";
-			my $doinclude = 1;
-			if ( $onefile->{'Styles'} ) { $styles = $onefile->{'Styles'}; };
-			if ( $styles =~ /\bDONT_PACK\b/ ) { $doinclude = 0; }
-			
-			# to avoid lines with more than 256 characters, it can be useful to use relative pathes
-			if ( $allvariables->{'RELATIVE_PATHES_IN_DDF'} ) { $sourcepath = make_relative_ddf_path($sourcepath); }
-
-			# all files with the same cabinetfile have increasing sequencenumbers
-
-			my @ddffile = ();
-
-			write_ddf_file_header(\@ddffile, $cabinetfile, $installdir);
-	
-			my $ddfline = "\"" . $sourcepath . "\"" . " " . $uniquename . "\n";
-			if ( $doinclude ) { push(@ddffile, $ddfline); }
-			
-			$counter++;	# increasing the counter
-			my $nextfile = "";
-			my $nextcabinetfile = "";
-			if ( exists($sequenceorder->{$counter}) ) { $nextfile = ${$filesref}[$sequenceorder->{$counter}]; }		
-			if ( $nextfile->{'assignedcabinetfile'} ) { $nextcabinetfile = $nextfile->{'assignedcabinetfile'}; }
-		
-			while ( $nextcabinetfile eq $cabinetfile )
-			{
-				$sourcepath =  $nextfile->{'sourcepath'};
-				if ( $^O =~ /cygwin/i ) { $sourcepath = $nextfile->{'cyg_sourcepath'}; }
-				# to avoid lines with more than 256 characters, it can be useful to use relative pathes
-				if ( $allvariables->{'RELATIVE_PATHES_IN_DDF'} ) { $sourcepath = make_relative_ddf_path($sourcepath); }
-				$uniquename =  $nextfile->{'uniquename'};
-				my $localdoinclude = 1;
-				my $nextfilestyles = "";				
-				if ( $nextfile->{'Styles'} ) { $nextfilestyles = $nextfile->{'Styles'}; }
-				if ( $nextfilestyles =~ /\bDONT_PACK\b/ ) { $localdoinclude = 0; }
-				$ddfline = "\"" . $sourcepath . "\"" . " " . $uniquename . "\n";
-				if ( $localdoinclude ) { push(@ddffile, $ddfline); }
-				
-				$counter++;	# increasing the counter!
-				$nextcabinetfile = "_lastfile_";
-				if ( exists($sequenceorder->{$counter}) )
-				{
-					$nextfile = ${$filesref}[$sequenceorder->{$counter}];
-					$nextcabinetfile = $nextfile->{'assignedcabinetfile'};
-				}
-			}
-		
-			# creating the DDF file
-
-			my $ddffilename = $cabinetfile;
-			$ddffilename =~ s/.cab/.ddf/;
-			$ddfdir =~ s/\Q$installer::globals::separator\E\s*$//;
-			$ddffilename = $ddfdir . $installer::globals::separator . $ddffilename;
-
-			installer::files::save_file($ddffilename ,\@ddffile);
-			my $infoline = "Created ddf file: $ddffilename\n"; 
-			push(@installer::globals::logfileinfo, $infoline);
-
-			# lines in ddf files must not be longer than 256 characters
-			check_ddf_file(\@ddffile, $ddffilename);
-
-			# Writing the makecab system call
-
-			my $oneline = "makecab.exe /V3 /F " . $ddffilename . " 2\>\&1 |" . "\n";
-		
-			push(@cabfilelist, $oneline);
-
-			# collecting all ddf files
-			push(@installer::globals::allddffiles, $ddffilename);
-		}
-	}
-	elsif (( $installer::globals::cab_file_per_component ) || ( $installer::globals::fix_number_of_cab_files ))
+	if (( $installer::globals::cab_file_per_component ) || ( $installer::globals::fix_number_of_cab_files ))
 	{
 		for ( my $i = 0; $i <= $#{$filesref}; $i++ )
 		{	
@@ -440,6 +334,8 @@
 
 sub save_packorder
 {
+	my ( $filesref ) = @_;
+
 	installer::logger::include_header_into_logfile("Saving pack order");
 
 	installer::logger::include_timestamp_into_logfile("Performance Info: saving pack order start");
@@ -506,10 +402,7 @@
 	$databasename =~ s/\s//g;
 
 	# possibility to overwrite the name with variable DATABASENAME
-	if ( $allvariableshashref->{'DATABASENAME'} )
-	{
-		$databasename = $allvariableshashref->{'DATABASENAME'};
-	}
+	if ( $allvariableshashref->{'DATABASENAME'} ) { $databasename = $allvariableshashref->{'DATABASENAME'}; }
 	
 	if ( $language )
 	{
@@ -861,7 +754,7 @@
 			$infoline = "WARNING: Returnvalue of $msitran is not 0. Checking version of $msitran!\n";
 			push( @installer::globals::logfileinfo, $infoline);
 
-			open(FILE, "<$installer::globals::msitranpath") or die "ERROR: Can't open $installer::globals::msitranpath for creating file hash";
+			open(FILE, "<$msitran") or die "ERROR: Can't open $msitran for creating file hash";
 			binmode(FILE);
 			my $digest = Digest::MD5->new->addfile(*FILE)->hexdigest;			
 			close(FILE);
@@ -880,7 +773,7 @@
 				{
 					$infoline = "File $transformfile exists.\n";
 					push( @installer::globals::logfileinfo, $infoline);
-					my $filesize = ( -s $transformfile );
+					my $filesize = (stat($transformfile))[7];
 					$infoline = "Size of $transformfile: $filesize\n";
 					push( @installer::globals::logfileinfo, $infoline);
 
@@ -950,9 +843,6 @@
 	$olddatabasename = $installdir . $installer::globals::separator . $olddatabasename;
 
 	my $newdatabasename = get_msidatabasename($allvariableshashref);	
-
-	$installer::globals::shortmsidatabasename = $newdatabasename;
-
 	$newdatabasename = $installdir . $installer::globals::separator . $newdatabasename;
 
 	installer::systemactions::rename_one_file($olddatabasename, $newdatabasename);
@@ -960,29 +850,6 @@
 	$installer::globals::msidatabasename = $newdatabasename;
 }
 
-#########################################################################
-# Adding the language to the name of the msi databasename,
-# if this is required (ADDLANGUAGEINDATABASENAME)
-#########################################################################
-
-sub add_language_to_msi_database
-{
-	my ($defaultlanguage, $installdir, $allvariables) = @_;
-
-	my $languagestring = $defaultlanguage;
-	if ( $allvariables->{'USELANGUAGECODE'} ) { $languagestring = installer::windows::language::get_windows_language($defaultlanguage); } 
-	my $newdatabasename = $installer::globals::shortmsidatabasename;
-	$newdatabasename =~ s/\.msi\s*$/_$languagestring\.msi/;
-	$installer::globals::shortmsidatabasename = $newdatabasename;
-	$newdatabasename = $installdir . $installer::globals::separator . $newdatabasename;
-
-	my $olddatabasename = $installer::globals::msidatabasename;
-	
-	installer::systemactions::rename_one_file($olddatabasename, $newdatabasename);
-	
-	$installer::globals::msidatabasename = $newdatabasename;	
-}
-
 ##########################################################################
 # Writing the databasename into the setup.ini.
 ##########################################################################
@@ -1189,7 +1056,7 @@
 {
 	my ($defaultlanguage, $installdir, $allscpactions) = @_;	
 
-	installer::logger::include_header_into_logfile("Copying ScpAction files into installation set");
+	installer::logger::include_header_into_logfile("Copying files into installation set");
 
 	for ( my $i = 0; $i <= $#{$allscpactions}; $i++ )
 	{
@@ -1218,17 +1085,13 @@
 
 sub copy_windows_installer_files_into_installset
 {
-	my ($installdir, $includepatharrayref, $allvariables) = @_;
-
-    installer::logger::include_header_into_logfile("Copying Windows installer files into installation set");
+	my ($installdir, $includepatharrayref) = @_;
 	
 	@copyfile = ();
 	push(@copyfile, "instmsia.exe");
 	push(@copyfile, "instmsiw.exe");
 	push(@copyfile, "loader2.exe");
 	
-	if ( $allvariables->{'NOLOADERREQUIRED'} ) { @copyfile = (); }
-	
 	for ( my $i = 0; $i <= $#copyfile; $i++ )
 	{
 		my $filename = $copyfile[$i];
@@ -1247,28 +1110,6 @@
 }
 
 #################################################################
-# Copying MergeModules for the Windows installer into the 
-# installation set. The list of MergeModules is located
-# in %installer::globals::copy_msm_files
-#################################################################
-
-sub copy_merge_modules_into_installset
-{
-	my ($installdir) = @_;
-
-	installer::logger::include_header_into_logfile("Copying Merge files into installation set");
-	
-	my $cabfile;
-	foreach $cabfile ( keys  %installer::globals::copy_msm_files )
-	{
-		my $sourcefile  = $installer::globals::copy_msm_files{$cabfile};
-		my $destfile = $installdir . $installer::globals::separator . $cabfile;
-
-		installer::systemactions::copy_one_file($sourcefile, $destfile);
-	}
-}
-
-#################################################################
 # Copying the child projects into the 
 # installation set
 #################################################################
@@ -1604,7 +1445,6 @@
 	$ENV{'TMP'} = $installer::globals::temppath;	# setting TMP to the new unique directory!
 
 	my $maxmakecabcalls = 3;
-	my $allmakecabcalls = $#{$localpackjobref} + 1;
 
 	for ( my $i = 0; $i <= $#{$localpackjobref}; $i++ )
 	{	
@@ -1612,7 +1452,7 @@
 		
 		my $callscounter = $i + 1;
 		
-		installer::logger::print_message( "... makecab.exe ($callscounter/$allmakecabcalls) ... \n" );
+		installer::logger::print_message( "... makecab.exe ($callscounter) ... \n" );
 
 		# my $returnvalue = system($systemcall);
 
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/windows/property.pm solenv/bin/modules/installer/windows/property.pm
--- solenv.bak/bin/modules/installer/windows/property.pm	2008-03-26 20:30:18.946500000 +0100
+++ solenv/bin/modules/installer/windows/property.pm	2008-03-31 14:09:36.427340000 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: property.pm,v $
 #
-#   $Revision: 1.18 $
+#   $Revision: 1.17 $
 #
-#   last change: $Author: vg $ $Date: 2007/12/05 17:37:04 $
+#   last change: $Author: kz $ $Date: 2006/07/05 21:13:37 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -253,9 +253,6 @@
 	if ( $installer::globals::patch )
 	{
 		my $onepropertyline = "ISPATCH" . "\t" . "1" . "\n";
-		push(@{$propertyfile}, $onepropertyline);
-
-		$onepropertyline = "SETUP_USED" . "\t" . "0" . "\n";
 		push(@{$propertyfile}, $onepropertyline);	
 	}
 
@@ -267,6 +264,7 @@
 
 	my $languagesline = "PRODUCTALLLANGUAGES" . "\t" . $$languagestringref . "\n";
 	push(@{$propertyfile}, $languagesline);	
+	
 }
 
 ####################################################################################
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/windows/registry.pm solenv/bin/modules/installer/windows/registry.pm
--- solenv.bak/bin/modules/installer/windows/registry.pm	2008-03-26 20:28:56.493375000 +0100
+++ solenv/bin/modules/installer/windows/registry.pm	2008-03-31 14:09:36.427340000 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: registry.pm,v $
 #
-#   $Revision: 1.13 $
+#   $Revision: 1.11 $
 #
-#   last change: $Author: ihi $ $Date: 2007/11/26 16:20:03 $
+#   last change: $Author: rt $ $Date: 2007/07/26 08:48:44 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -280,7 +280,7 @@
 			$registry{'Key'} = get_registry_key($oneregistry, $allvariableshashref); 		
 			$registry{'Name'} = get_registry_name($oneregistry, $allvariableshashref);
 			$registry{'Value'} = get_registry_value($oneregistry, $allvariableshashref);
-			$registry{'Component_'} = get_registry_component($oneregistry);	
+			$registry{'Component_'} = get_registry_component($oneregistry); 		
 	
 			# Collecting all components
 			if (!(installer::existence::exists_in_array($registry{'Component_'}, $allregistrycomponentsref))) 
@@ -288,11 +288,6 @@
 				push(@{$allregistrycomponentsref}, $registry{'Component_'}); 
 			}
 
-			# Collecting all components with DONT_DELETE style
-			my $style = "";
-			if ( $oneregistry->{'Styles'} ) { $style = $oneregistry->{'Styles'}; }
-			if ( $style =~ /\bDONT_DELETE\b/ ) { $installer::globals::dontdeletecomponents{$registry{'Component_'}} = 1; }
-
 			# Collecting all component conditions
 			if ( $oneregistry->{'ComponentCondition'} )
 			{			
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/windows/shortcut.pm solenv/bin/modules/installer/windows/shortcut.pm
--- solenv.bak/bin/modules/installer/windows/shortcut.pm	2007-11-26 17:20:21.000000000 +0100
+++ solenv/bin/modules/installer/windows/shortcut.pm	2008-03-31 14:09:36.427340000 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: shortcut.pm,v $
 #
-#   $Revision: 1.12 $
+#   $Revision: 1.11 $
 #
-#   last change: $Author: ihi $ $Date: 2007/11/26 16:20:21 $
+#   last change: $Author: kz $ $Date: 2005/11/11 14:18:42 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -375,16 +375,6 @@
 		$directory = $installer::globals::startupfolder;		
 	}
 
-	if ( $shortcut->{'FolderID'} eq "PREDEFINED_DESKTOP" )
-	{
-		$directory = $installer::globals::desktopfolder;		
-	}
-
-	if ( $shortcut->{'FolderID'} eq "PREDEFINED_STARTMENU" )
-	{
-		$directory = $installer::globals::startmenufolder;		
-	}
-
 	# saving the directory in the folderitems collector
 	
 	$shortcut->{'directory'} = $directory;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/windows/upgrade.pm solenv/bin/modules/installer/windows/upgrade.pm
--- solenv.bak/bin/modules/installer/windows/upgrade.pm	2007-11-02 13:56:50.000000000 +0100
+++ solenv/bin/modules/installer/windows/upgrade.pm	2008-03-31 14:09:36.442964600 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: upgrade.pm,v $
 #
-#   $Revision: 1.12 $
+#   $Revision: 1.11 $
 #
-#   last change: $Author: hr $ $Date: 2007/11/02 12:56:50 $
+#   last change: $Author: rt $ $Date: 2007/04/02 12:23:52 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -99,14 +99,6 @@
 			$newline = $allvariableshashref->{'BETAUPGRADECODE'} . "\t" . "1.0" . "\t" . "\t" . "\t" . "1" . "\t" . "\t" . "BETAPRODUCTS" . "\n";
 			push(@upgradetable, $newline);
 		}
-
-		# also searching for the stub
-		
-		if ( $allvariableshashref->{'STUBUPGRADECODE'} )
-		{
-			$newline = $allvariableshashref->{'STUBUPGRADECODE'} . "\t" . "1.0" . "\t" . "\t" . "\t" . "1" . "\t" . "\t" . "STUBPRODUCTS" . "\n";
-			push(@upgradetable, $newline);
-		}
 	}
 	
 	# Saving the file
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/worker.pm solenv/bin/modules/installer/worker.pm
--- solenv.bak/bin/modules/installer/worker.pm	2007-11-26 14:16:38.000000000 +0100
+++ solenv/bin/modules/installer/worker.pm	2008-03-31 14:09:36.442964600 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: worker.pm,v $
 #
-#   $Revision: 1.57 $
+#   $Revision: 1.51.8.1 $
 #
-#   last change: $Author: ihi $ $Date: 2007/11/26 13:16:38 $
+#   last change: $Author: obo $ $Date: 2007/08/17 17:50:21 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -739,9 +739,9 @@
 # Mechanism for simple installation without packing
 ###########################################################
 
-sub install_simple ($$$$$$)
+sub install_simple ($$$$$)
 {
-	my ($packagename, $languagestring, $directoriesarray, $filesarray, $linksarray, $unixlinksarray) = @_;
+	my ($packagename, $languagestring, $directoriesarray, $filesarray, $linksarray) = @_;
 
         # locate GNU cp on the system
         my $gnucp = 'cp';
@@ -809,17 +809,6 @@
 		push @lines, "$destination\n";
 	}
 
-	for ( my $i = 0; $i <= $#{$unixlinksarray}; $i++ )
-	{
-		my $onelink = ${$unixlinksarray}[$i];
-        my $target = $onelink->{'Target'};
-		my $destination = $onelink->{'destination'};
-	
-		# print "Unix link $target -> $destdir$destination\n";
-		`ln -sf '$target' '$destdir$destination'`;
-		push @lines, "$destination\n";
-	}
-
 	if ( $destdir ne "" )
 	{
 		my $filelist;
@@ -927,7 +916,6 @@
 	# SHELLNEWFILESPLACEHOLDER
 
 	my $rootmodule = 0;
-	# inf files can be assigned to "gid_Module_Root_Files_2"
 	if ( $inffile->{'modules'} =~ /Module_Root/i ) { $rootmodule = 1; }
 
 	if ( $rootmodule )
@@ -942,14 +930,12 @@
 			if ( $directory =~ /\bPREDEFINED_OSSHELLNEWDIR\b/ )
 			{
 				$shellnewstring = $shellnewstring . $onefile->{'Name'} . "\n";
-				if (( $firstlanguage ) && ( ! $installer::globals::shellnewfilesadded )) { add_shellnewfile_into_filesarray($filesref, $onefile, $inffile); }
+				if ( $firstlanguage ) { add_shellnewfile_into_filesarray($filesref, $onefile, $inffile); }
 			}
 		}
 
 		$shellnewstring =~ s/\s*$//;
 		replace_in_template_file($templatefile, "SHELLNEWFILESPLACEHOLDER", $shellnewstring);
-
-		$installer::globals::shellnewfilesadded = 1;
 	}
 
 	# Second part: Start menu entries
@@ -1009,8 +995,7 @@
 		my $moduleid = ${$allmodules}[$j];
 	
 		my $inffilemodule = $inffile->{'modules'};
-		# inf files can be assigned to "gid_Module_Root_Files_2", but RegistryItems to "gid_Module_Root"
-		if ( $inffilemodule =~ /Module_Root/i ) { $inffilemodule = $installer::globals::rootmodulegid; }
+		if ( $inffilemodule =~ /Module_Root/i ) { $inffilemodule = "gid_Module_Root"; }
 
 		if ( ! ( $moduleid eq $inffilemodule )) { next; } 
 		
@@ -1269,7 +1254,7 @@
 		if ( $installer::globals::iswindowsbuild )
 		{
 			# all files of the Windows patch belong to the root module
-			$onefile->{'modules'} = $installer::globals::rootmodulegid;
+			$onefile->{'modules'} = "gid_Module_Root";
 		}
 		
 		push(@filesarray, $onefile);
@@ -1681,7 +1666,7 @@
 	# and finally checking the file size	
 	if ( -f $patchfilename )	# test of existence
 	{
-		my $filesize = ( -s $patchfilename );
+		my $filesize = (stat($patchfilename))[7];	# file size can be "0"
 		$infoline = "Size of patch file list: $filesize\n\n";
 		push( @installer::globals::logfileinfo, $infoline);
 		installer::logger::print_message( "... size of patch list file: $filesize Byte ... \n" );
@@ -2056,19 +2041,23 @@
 
 	# find and read jds files list
 	my $filelistname = $installer::globals::jdsexcludefilename;
+	
+	# File has to be located next to the package list
+	my $path = $installer::globals::packagelist;
+	installer::pathanalyzer::get_path_from_fullqualifiedname(\$path);
+	$filelistname = $path . $filelistname;
+	
+	if ( ! -f $filelistname ) { installer::exiter::exit_program("ERROR: Could not find jds list file $filelistname!", "create_jds_sets"); }
+	my $listfile = installer::files::read_file($filelistname);
 
-	my $filelistnameref = installer::scriptitems::get_sourcepath_from_filename_and_includepath(\$filelistname, "", 0);
-	if ($$filelistnameref eq "") { installer::exiter::exit_program("ERROR: Could not find jds list file $filelistname!", "create_jds_sets"); }
-
-	my $listfile = installer::files::read_file($$filelistnameref);
-
-	my $infoline = "Found jds list file: $$filelistnameref\n";
+	my $infoline = "Found jds list file: $filelistname \n";
 	push( @installer::globals::logfileinfo, $infoline);
 
 	# substituting the variables
 	substitute_dollar_variables($listfile, $allvariableshashref);
 
 	# determining the packages/RPMs to copy
+	# my $allexcludepackages = get_all_files_from_filelist($listfile, "excludefiles");
 	my $allexcludepackages = get_section_from_file($listfile, "excludefiles");
 	my $allcopypackages = get_section_from_file($listfile, "copyfiles");
 
@@ -2249,14 +2238,6 @@
 	{
 		$platformname = "Win32Intel";
 	}
-	elsif ( $installer::globals::compiler =~ /^unxmacxi/ )
-	{
-		$platformname = "MacOSXIntel";
-	}
-	elsif ( $installer::globals::compiler =~ /^unxmacxp/ )
-	{
-		$platformname = "MacOSXPowerPC";
-	}
 	else
 	{
 		# $platformname = $installer::globals::packageformat;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/xpdinstaller.pm solenv/bin/modules/installer/xpdinstaller.pm
--- solenv.bak/bin/modules/installer/xpdinstaller.pm	2007-08-20 17:27:24.000000000 +0200
+++ solenv/bin/modules/installer/xpdinstaller.pm	2008-03-31 14:09:36.442964600 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: xpdinstaller.pm,v $
 #
-#   $Revision: 1.5 $
+#   $Revision: 1.4 $
 #
-#   last change: $Author: ihi $ $Date: 2007/08/20 15:27:24 $
+#   last change: $Author: ihi $ $Date: 2007/07/12 11:16:47 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -158,7 +158,7 @@
 	if ( $styles =~ /\bHIDDEN_ROOT\b/ ) { $type = "hidden"; }
 	else { $type = "show"; }
 	
-	# special handling for the root module, which has no parent
+	# special handling for "gid_Module_Root", which has no parent
 	my $parentgid = "";
 	if ( $module->{'ParentID'} ) { $parentgid = $module->{'ParentID'}; }
 	if ( $parentgid eq "" ) { $type = "hidden"; }
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/installer/ziplist.pm solenv/bin/modules/installer/ziplist.pm
--- solenv.bak/bin/modules/installer/ziplist.pm	2007-09-06 11:54:27.000000000 +0200
+++ solenv/bin/modules/installer/ziplist.pm	2008-03-31 14:09:36.442964600 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: ziplist.pm,v $
 #
-#   $Revision: 1.19 $
+#   $Revision: 1.18 $
 #
-#   last change: $Author: kz $ $Date: 2007/09/06 09:54:27 $
+#   last change: $Author: ihi $ $Date: 2007/07/11 15:03:46 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -455,6 +455,22 @@
 	return \$searchstring;
 }
 
+#######################################################
+# Set zip list file name, if not defined as parameter
+#######################################################
+
+sub set_ziplist_name
+{
+	my ( $pathvariableshashref ) = @_;
+
+	my $solarenvpath = $pathvariableshashref->{'solarenvpath'};
+
+	$solarenvpath =~ s/solenv\Q$installer::globals::separator\Einst//;
+	
+	$installer::globals::ziplistname = $solarenvpath . "b_server" . $installer::globals::separator . "zip" . $installer::globals::separator . "zip.lst";
+
+}
+
 ####################################################
 # Replacing variables in include path
 ####################################################
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/par2script/check.pm solenv/bin/modules/par2script/check.pm
--- solenv.bak/bin/modules/par2script/check.pm	2007-08-20 17:28:06.000000000 +0200
+++ solenv/bin/modules/par2script/check.pm	2008-03-31 14:09:36.458589200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: check.pm,v $
 #
-#   $Revision: 1.7 $
+#   $Revision: 1.6 $
 #
-#   last change: $Author: ihi $ $Date: 2007/08/20 15:28:06 $
+#   last change: $Author: rt $ $Date: 2005/09/08 09:24:49 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -33,9 +33,12 @@
 #
 #*************************************************************************
 
+
 package par2script::check;
 
+use par2script::existence;
 use par2script::globals;
+use par2script::work;
 
 ################################
 # Checks of the setup script
@@ -47,103 +50,151 @@
 
 sub check_needed_directories
 {
-	my $allfiles = $par2script::globals::definitions{'File'};
-	my $alldirs = $par2script::globals::definitions{'Directory'};
+	my ($setupscript) = @_;
+
+	print "Checking directories ... ";
+
+	my $allfiles = par2script::work::get_all_items_from_script($setupscript, "File");
+	my $alldirs = par2script::work::get_all_items_from_script($setupscript, "Directory");
 
 	# checking if all defined directories are needed
 
-	my $dir;
-	foreach $dir ( keys %{$alldirs} )
+	for ( my $i = 0; $i <= $#{$alldirs}; $i++ )
 	{
+		my $onedir = ${$alldirs}[$i];
+		
 		# I. directory has create flag
-		if (( exists($alldirs->{$dir}->{'Styles'}) ) && ( $alldirs->{$dir}->{'Styles'} =~ /\bCREATE\b/ )) { next; }
+		
+		my $styles = "";
+		if ( $onedir->{'Styles'} ) { $styles = $onedir->{'Styles'} }
+		
+		if ( $styles =~ /\bCREATE\b/ ) { next; }	# this is okay
+		
+		my $dirgid = $onedir->{'gid'};
+		my $directory_required = 0;
 
-		# II. there is at least one file in the directory
-		my $fileinside = 0;
-		my $file;
-		foreach $file ( keys %{$allfiles} )
+		# II. there are files in the directory
+		
+		for ( my $j = 0; $j <= $#{$allfiles}; $j++ )
 		{
-			if (( $allfiles->{$file}->{'Dir'} eq $dir ) || ( $allfiles->{$file}->{'NetDir'} eq $dir ))
+			my $onefile = ${$allfiles}[$j];
+			
+			
+			my $filedir = "";
+			if ( $onefile->{'Dir'} ) { $filedir = $onefile->{'Dir'} }
+			my $filenetdir = "";
+			if ( $onefile->{'NetDir'} )  { $filedir = $onefile->{'NetDir'} }
+			
+			if (( $dirgid eq $filedir ) || ( $dirgid eq $filenetdir ))
 			{
-				$fileinside = 1;
-				last;
+				$directory_required = 1;
+				last;	
 			}
 		}
-		if ( $fileinside ) { next; }	
+
+		if ( $directory_required ) { next; };
 
 		# III. the directory is parent for another directory
-		my $isparent = 0;
-		my $onedir;
-		foreach $onedir ( keys %{$alldirs} )
+
+		for ( my $j = 0; $j <= $#{$alldirs}; $j++ )
 		{
-			if ( $alldirs->{$onedir}->{'ParentID'} eq $dir )
+			my $onedir = ${$alldirs}[$j];
+			
+			my $parentid = $onedir->{'ParentID'};
+			
+			if ( $dirgid eq $parentid )
 			{
-				$isparent = 1;
-				last;
+				$directory_required = 1;
+				last;	
 			}
 		}
-		if ( $isparent ) { next; }	
 
-		# no condition is true -> directory definition is superfluous
-		my $infoline = "\tINFO: Directory definition $dir is superfluous\n";
-		# print $infoline;
-		push(@par2script::globals::logfileinfo, $infoline);
+		if (! $directory_required)
+		{
+			my $infoline = "INFO: Directory definition $dirgid is superfluous\n";
+			# print $infoline;
+			push(@par2script::globals::logfileinfo, $infoline);
+		}
 	}
+
+	print "Done\n";
 }
 
 ##################################################
-# Checking if the directories in the item
+# Checking if the directories in the file
 # definitions are defined.
 ##################################################
 
 sub check_directories_in_item_definitions
 {
-	my $item;
-	foreach $item ( @par2script::globals::items_with_directories )
+	my ($setupscript, $item) = @_;
+
+	print "Checking $item ... ";
+	
+	my $allfiles = par2script::work::get_all_items_from_script($setupscript, $item);
+	my $alldirectorygids = par2script::work::get_all_gids_from_script($setupscript, "Directory");
+
+	for ( my $i = 0; $i <= $#{$allfiles}; $i++ )
 	{
-		my $allitems = $par2script::globals::definitions{$item};
-		
-		my $onegid;
-		foreach $onegid ( keys %{$allitems} )
-		{
-			if ( ! exists($allitems->{$onegid}->{'Dir'}) ) { die "\nERROR: No directory defined for item: $onegid!\n\n"; }
-			my $dir = $allitems->{$onegid}->{'Dir'};
-			if (( $dir eq "PD_PROGDIR" ) || ( $dir =~ /PREDEFINED_/ )) { next; }
+		my $onefile = ${$allfiles}[$i];
+
+		my $filedir = $onefile->{'Dir'};
+
+		# checking if $filedir is not empty or not defined
 			
-			# checking if this directoryid is defined
-			if ( ! exists($par2script::globals::definitions{'Directory'}->{$dir}) )
-			{
-				die "\nERROR: Directory $dir in item $onegid not defined!\n\n";
-			}
-		}
+		if ( $filedir eq "" ) { die "ERROR: No directory defined for file: $onefile->{'gid'}!\n"; }
+
+		if (( $filedir eq "PD_PROGDIR" ) || ( $filedir =~ /PREDEFINED_/ )) { next; }
+
+		# now checking if this directoryid exists
+	
+		if ( ! par2script::existence::exists_in_array($filedir, $alldirectorygids) )
+		{
+			die "ERROR: Directory $filedir in $item $onefile->{'gid'} not defined!\n";
+		}		
 	}
+		
+	print "Done\n";
 }
 
 ########################################################
 # Checking for all Items, that know their modules,
-# whether these modules exist.
+# whether these modules exist. If not, this is a
+# script error.
 ########################################################
 
 sub check_module_existence
 {
-	my $item;
-	foreach $item ( @par2script::globals::items_with_moduleid )
+	my ($script) = @_;
+
+	print "Checking modules ... ";
+	
+	my $allmodulegids = par2script::work::get_all_gids_from_script($script, "Module");
+	
+	for ( my $i = 0; $i <= $#par2script::globals::items_with_moduleid; $i++ )
 	{
-		my $allitems = $par2script::globals::definitions{$item};
+		my $oneitem = $par2script::globals::items_with_moduleid[$i];
 
-		my $onegid;
-		foreach $onegid ( keys %{$allitems} )
+		my $allitems = par2script::work::get_all_items_from_script($script, $oneitem);
+
+		for ( my $j = 0; $j <= $#{$allitems}; $j++ )
 		{
-			if ( ! exists($allitems->{$onegid}->{'ModuleID'}) ) { die "\nERROR: No ModuleID defined for item: $onegid!\n\n"; }
-			my $moduleid = $allitems->{$onegid}->{'ModuleID'};
+			my $oneitem = ${$allitems}[$j];
+
+			my $moduleid = $oneitem ->{'ModuleID'};
 			
-			# checking if this directoryid is defined
-			if ( ! exists($par2script::globals::definitions{'Module'}->{$moduleid}) )
+			if ( $moduleid eq "" )  { die "ERROR: No ModuleID defined for item: $oneitem->{'gid'}!\n"; } 
+			
+			# now checking if this moduleid exists
+	
+			if ( ! par2script::existence::exists_in_array($moduleid, $allmodulegids) )
 			{
-				die "\nERROR: ModuleID $moduleid in item $onegid not defined!\n\n";
-			}
-		}
+				die "ERROR: ModuleID $moduleid in $oneitem->{'gid'} not defined!\n";
+			}	
+		}	
 	}
+
+	print "Done\n";	
 }
 
 ########################################################
@@ -153,252 +204,127 @@
 
 sub check_registry_at_files
 {
-	my %starregistrygid = ();
+	my ($script) = @_;
 
-	my $item;
-	foreach $item ( keys %{$par2script::globals::definitions{'File'}} )
-	{
-		if (( exists($par2script::globals::definitions{'File'}->{$item}->{'Styles'}) ) &&
-			( $par2script::globals::definitions{'File'}->{$item}->{'Styles'} =~ /\bSTARREGISTRY\b/ ))
-		{
-			$starregistrygid{$item} = 1;
-		}
-	}
+	print "Checking StarRegistry ... ";
+	
+	my $allstarregistrygids = par2script::work::get_all_gids_from_script($script, "StarRegistry");
+	my $isfile = 0;
 
-	foreach $item ( keys %{$par2script::globals::definitions{'File'}} )
+	for ( my $i = 0; $i <= $#{$script}; $i++ )
 	{
-		if ( exists($par2script::globals::definitions{'File'}->{$item}->{'RegistryID'}) )
-		{
-			my $registryid = $par2script::globals::definitions{'File'}->{$item}->{'RegistryID'};
-			if ( ! exists($starregistrygid{$registryid}) )
-			{
-				die "\nERROR: No definition found for $registryid at file $item\n\n";
-			}
+		if ( ${$script}[$i] =~ /^\s*File\s+\w+\s*$/ ) {	$isfile = 1; }
 
-			# if ( ! ( $par2script::globals::definitions{'File'}->{$item}->{'Styles'} =~ /\bUNO_COMPONENT\b/ ))
-			# {
-			#	die "\nERROR: Flag UNO_COMPONENT required for file $item\n\n";
-			# }
-			# -> also possible, that Regmergefile is defined (does not require flag UNO_COMPONENT)
-		}
-		
-		# and also vice versa
-		
-		if (( exists($par2script::globals::definitions{'File'}->{$item}->{'Styles'}) ) &&
-			( $par2script::globals::definitions{'File'}->{$item}->{'Styles'} =~ /\bUNO_COMPONENT\b/ ))
+		if (( $isfile ) && ( ${$script}[$i] =~ /^\s*End\s*$/i )) { $isfile = 0; }
+
+		if (( $isfile ) && ( ${$script}[$i] =~ /^\s*RegistryID\s+\=\s+(\w+)\s*\;\s*$/ )) 
 		{
-			if ( ! exists($par2script::globals::definitions{'File'}->{$item}->{'RegistryID'}) )
+			my $registry = $1;
+			my $isdefinedregistry = 0;
+
+			for ( my $j = 0; $j <= $#{$allstarregistrygids}; $j++ )
 			{
-				die "\nERROR: Flag UNO_COMPONENT defined, but no file as \"RegistryID\" at file $item !\n\n";				
+				if ( $registry eq ${$allstarregistrygids}[$j] ) { $isdefinedregistry = 1; }				
 			}
-		}
-	}
-}
-
-########################################################
-# Every script has to contain exactly one root module.
-# This module has no ParentID or an empty ParentID.
-########################################################
 
-sub check_rootmodule
-{
-	my $rootgid = "";
-	my $foundroot = 0;
+			# if no definition was found, the line "RegistryID = ..." can be removed
 
-	my $allmodules = $par2script::globals::definitions{'Module'};
-	
-	my $modulegid = "";
-	foreach $modulegid (keys %{$allmodules} )
-	{
-		if (( ! exists($allmodules->{$modulegid}->{'ParentID'}) ) || ( $allmodules->{$modulegid}->{'ParentID'} eq "" ))
-		{
-			if ( $foundroot )
-			{
-				die "\nERROR: More than one Root module. Only one module without ParentID or with empty ParentID allowed ($rootgid and $modulegid).\n";
-			}
-			$rootgid = $modulegid;
-			$foundroot = 1;
+			if (! $isdefinedregistry) { splice(@{$script}, $i, 1); }
 		}
 	}
-	
-	if ( ! $foundroot )
-	{
-		die "\nERROR: Could not find Root module. Did not find module without ParentID or with empty ParentID.\n";
-	}
-	
-	print " $rootgid\n";	
 
+	print "Done\n";	
 }
 
 ########################################################
-# File, Shortcut, Directory, Unixlink must not 
+# File, Shortcut, Directory, Procedure must not 
 # contain a ModuleID
 ########################################################
 
 sub check_moduleid_at_items
 {
-	my $item;
-	foreach $item ( @par2script::globals::items_without_moduleid )
-	{
-		my $allitems = $par2script::globals::definitions{$item};
+	my ($script) = @_;
 
-		my $onegid;
-		foreach $onegid ( keys %{$allitems} )
+	print "Checking module assignments ... ";
+	
+	my @items = ("File", "Directory", "Shortcut", "Procedure");
+
+	for ( my $i = 0; $i <= $#items; $i++ )
+	{
+		my $oneitem = $items[$i];
+		my $isitem = 0;
+		
+		for ( my $j = 0; $j <= $#{$script}; $j++ )
 		{
-			if ( exists($allitems->{$onegid}->{'ModuleID'}) )
+			if ( ${$script}[$j] =~ /^\s*$oneitem\s+(\w+)\s*$/ )
 			{
-				die "\nERROR: ModuleID assigned to $onegid! No module assignment to $item!\n\n";
+				$gid = $1;
+				$isitem = 1;
 			}
-		}
-	}
-}
 
-########################################################
-# Controlling existence of multi assignments
-########################################################
+			if (( $isitem ) && ( ${$script}[$j] =~ /^\s*End\s*$/i )) { $isitem = 0; }
 
-sub check_multiple_assignments
-{
-	my @multiassignments = ();
-	my $error;
-	
-	my $topitem;
-	foreach $topitem ( keys %par2script::globals::assignedgids )
-	{
-		my $item;
-		foreach $item ( keys %{$par2script::globals::assignedgids{$topitem}} )
-		{
-			if ( $par2script::globals::assignedgids{$topitem}->{$item} > 1 )
+			if (( $isitem ) && ( ${$script}[$j] =~ /^\s*ModuleID\s+\=/ )) 
 			{
-				$error = 1;
-				my $string = "\tGID: $item Assignments: $par2script::globals::assignedgids{$topitem}->{$item}";
-				push(@multiassignments, $string);
+				die "\nERROR: ModuleID assigned to $gid! No module assignment to $oneitem!\n\n";
 			}
 		}
 	}
 
-	if ( $error ) { par2script::exiter::multiassignmenterror(\@multiassignments); }
-}
-
-########################################################
-# Check, if a defined directory has a flag CREATE
-########################################################
-
-sub contains_create_flag
-{
-	my ($gid) = @_;
-	
-	my $createflag = 0;
-	
-	if (( exists($par2script::globals::definitions{'Directory'}->{$gid}->{'Styles'}) ) &&
-		( $par2script::globals::definitions{'Directory'}->{$gid}->{'Styles'} =~ /\bCREATE\b/ ))
-	{
-		$createflag = 1;
-	}
-
-	return $createflag;
+	print "Done\n";	
 }
 
 ########################################################
-# Controlling existence of definitions without
-# any assignment
+# File, Shortcut, Directory, Procedure must not 
+# contain a ModuleID
 ########################################################
 
-sub check_missing_assignments
+sub check_semicolon
 {
-	# If defined gids for "File", "Directory" or "Unixlink" are not assigned, 
-	# this causes an error.
-	# Directories only have to be assigned, if they have the flag "CREATE". 
+	my ($script) = @_;
 
-	my @missingassignments = ();
-	$error = 0;
+	print "Checking syntax ... ";
 
-	my $item;
-	foreach $item ( @par2script::globals::items_assigned_at_modules )
+	for ( my $i = 0; $i <= $#par2script::globals::allitems; $i++ )
 	{
-		my $assignedgids = $par2script::globals::assignedgids{$item};
-		my $definedgids = $par2script::globals::definitions{$item};
-
-		my $gid;
-		foreach $gid ( keys %{$definedgids} )
+		my $oneitem = $par2script::globals::allitems[$i];
+		
+		if ( $oneitem eq "Procedure" ) { next; }	# no syntax check for Procedure
+		if ( $oneitem eq "Custom" ) { next; }		# no syntax check for Custom
+		if ( $oneitem eq "Module" ) { next; }		# no syntax check for Module
+		
+		my $isinsideitem = 0;
+		my $gid = "";
+		my $isstartline = 0;
+		
+		for ( my $j = 0; $j <= $#{$script}; $j++ )
 		{
-			if ( $item eq "Directory" ) { if ( ! contains_create_flag($gid) ) { next; }	}
-
-			if ( ! exists( $assignedgids->{$gid} ))
+			my $scriptline = ${$script}[$j];
+			
+			if ( $isstartline )
 			{
-				$error = 1;
-				push(@missingassignments, $gid);
+				$isstartline = 0;
+				$isinsideitem = 1;
 			}
-		}
-	}
 
-	if ( $error ) { par2script::exiter::missingassignmenterror(\@missingassignments); }
-}
-
-#############################################################
-# Controlling if for all shortcuts with file assignment
-# the file is defined. And for all shortcuts with
-# shortcut assignment the shortcut has to be defined.
-#############################################################
+			if ( $scriptline =~ /^\s*$oneitem\s+(\w+)\s*$/ )
+			{
+				$gid = $1;
+				$isstartline = 1;
+			}
 
-sub check_shortcut_assignments
-{
-	my $allshortcuts = $par2script::globals::definitions{'Shortcut'};
-	my $allfiles = $par2script::globals::definitions{'File'};
-	
-	my $shortcut;
-	foreach $shortcut ( keys %{$allshortcuts} )
-	{
-		if (( exists($allshortcuts->{$shortcut}->{'FileID'}) ) &&
-			( ! exists($allfiles->{$allshortcuts->{$shortcut}->{'FileID'}}) ))
-		{
-			# die "\nERROR: FileID $allshortcuts->{$shortcut}->{'FileID'} has no definition at shortcut $shortcut !\n";
-			print "\n\tWARNING: FileID $allshortcuts->{$shortcut}->{'FileID'} has no definition at shortcut $shortcut !\n";
-		}
+			if (( $isinsideitem ) && ( $scriptline =~ /^\s*End\s*$/i ))
+			{
+				$isinsideitem = 0;
+			}
 
-		if (( exists($allshortcuts->{$shortcut}->{'ShortcutID'}) ) &&
-			( ! exists($allshortcuts->{$allshortcuts->{$shortcut}->{'ShortcutID'}}) ))
-		{
-			die "\nERROR: ShortcutID $allshortcuts->{$shortcut}->{'ShortcutID'} has no definition at shortcut $shortcut !\n";
+			# checking semicolon
+			if ( ($isinsideitem) && (!($scriptline =~ /\;\s*$/)) ) { die "\nERROR: Syntax error (missing semicolon) in $gid:\n$scriptline\n\n"; }
+			if ( ($isinsideitem) && ($scriptline =~ /\;\;\s*$/) ) { die "\nERROR: Syntax error (double semicolon) in $gid:\n$scriptline\n\n"; }
 		}
-		
-		if (( ! exists($allshortcuts->{$shortcut}->{'ShortcutID'}) ) &&
-			( ! exists($allshortcuts->{$shortcut}->{'FileID'}) ))
-		{
-			die "\nERROR: Shortcut requires assignment to \"ShortcutID\" or \"FileID\". Missing at shortcut $shortcut !\n";
-		}		
 	}
-}
-
-#############################################################
-# Controlling if for Modules and Directories, the parents
-# are defined. If not, this can lead to a problem during
-# script creation, because only recursively added 
-# Modules or Directories are added to the script.
-#############################################################
 
-sub check_missing_parents
-{
-	my @parentitems = ("Module", "Directory");
-	my %rootparents = ("PREDEFINED_PROGDIR" => "1");
-	
-	my $oneitem;
-	foreach $oneitem ( @parentitems )
-	{
-		my $alldefinitions = $par2script::globals::definitions{$oneitem};
-		
-		my $onegid;
-		foreach $onegid ( keys %{$alldefinitions} )
-		{
-			# If there is a ParentID used, it must be defined
-			if (( exists($alldefinitions->{$onegid}->{'ParentID'}) ) &&
-				( ! exists($alldefinitions->{$alldefinitions->{$onegid}->{'ParentID'}}) ) &&
-				( ! exists($rootparents{$alldefinitions->{$onegid}->{'ParentID'}}) ))
-			{
-				die "\nERROR: Parent \"$alldefinitions->{$onegid}->{'ParentID'}\" at $oneitem \"$onegid\" is not defined!\n";				
-			}	
-		}
-	} 	
+	print "Done\n";	
 }
 
 1;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/par2script/converter.pm solenv/bin/modules/par2script/converter.pm
--- solenv.bak/bin/modules/par2script/converter.pm	2007-08-20 17:28:19.000000000 +0200
+++ solenv/bin/modules/par2script/converter.pm	2008-03-31 14:09:36.458589200 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: converter.pm,v $
 #
-#   $Revision: 1.4 $
+#   $Revision: 1.3 $
 #
-#   last change: $Author: ihi $ $Date: 2007/08/20 15:28:19 $
+#   last change: $Author: rt $ $Date: 2005/09/08 09:25:06 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -82,30 +82,6 @@
 	return \@array
 }
 
-sub convert_stringlist_into_array_2
-{
-	my ( $input, $separator ) = @_;
-	
-	my @newarray = ();
-	my $first = "";
-	my $last = "";
-
-	$last = $input;
-
-	while ( $last =~ /^\s*(.+?)\s*\Q$separator\E\s*(.+)\s*$/)	# "$" for minimal matching
-	{
-		$first = $1;
-		$last = $2;
-		par2script::remover::remove_leading_and_ending_whitespaces(\$first);
-		if ( $first ) { push(@newarray, $first); }
-	}	
-
-	par2script::remover::remove_leading_and_ending_whitespaces(\$last);
-	if ( $last ) { push(@newarray, $last); }	
-	
-	return \@newarray;
-}
-
 sub convert_stringlist_into_array
 {
 	my ( $includestringref, $separator ) = @_;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/par2script/exiter.pm solenv/bin/modules/par2script/exiter.pm
--- solenv.bak/bin/modules/par2script/exiter.pm	2007-08-20 17:28:32.000000000 +0200
+++ solenv/bin/modules/par2script/exiter.pm	2008-03-31 14:09:36.474213800 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: exiter.pm,v $
 #
-#   $Revision: 1.5 $
+#   $Revision: 1.4 $
 #
-#   last change: $Author: ihi $ $Date: 2007/08/20 15:28:32 $
+#   last change: $Author: rt $ $Date: 2005/09/08 09:25:52 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -83,47 +83,17 @@
 
 sub multidefinitionerror
 {
-	my ( $multidefinitiongids ) = @_;
+	my ($errorgids) = @_;
+
 	print "************************************************\n";	
 	print "ERROR: multiple definition of gids:\n";
 	print "************************************************\n";	
 
-	my $gid;
-	foreach $gid ( @{$multidefinitiongids} ) { print "\t$gid\n"; }
-	exit(-1);	
-}
-
-#####################################
-# Error, because a gid is assigned
-# more than once
-#####################################
-
-sub multiassignmenterror
-{
-	my ( $multiassignmentgids ) = @_;
-	#print "************************************************\n";	
-	#print "ERROR: multiple assignments of gids:\n";
-	#print "************************************************\n";	
-
-	my $line;
-	foreach $line ( @{$multiassignmentgids} ) { print "\t$line\n"; }
-	# exit(-1);
-}
-
-#####################################
-# Error, because a defined gid
-# is not assigned
-#####################################
-
-sub missingassignmenterror
-{
-	my ( $missingassignmentgids ) = @_;
-	print "********************************************************\n";	
-	print "ERROR: Missing assignments for the following GIDs:\n";
-	print "********************************************************\n";	
+	for ( my $i = 0; $i <= $#par2script::globals::multidefinitiongids; $i++ )
+	{
+		print "$par2script::globals::multidefinitiongids[$i]\n";
+	}
 
-	my $gid;
-	foreach $gid ( @{$missingassignmentgids} ) { print "\t$gid\n"; }
 	exit(-1);	
 }
 
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/par2script/globals.pm solenv/bin/modules/par2script/globals.pm
--- solenv.bak/bin/modules/par2script/globals.pm	2007-11-23 14:34:55.000000000 +0100
+++ solenv/bin/modules/par2script/globals.pm	2008-03-31 14:09:36.474213800 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: globals.pm,v $
 #
-#   $Revision: 1.10 $
+#   $Revision: 1.8 $
 #
-#   last change: $Author: ihi $ $Date: 2007/11/23 13:34:55 $
+#   last change: $Author: ihi $ $Date: 2007/07/12 11:17:14 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -49,28 +49,20 @@
 	$parfilelistorig = "";
 	$parfilelist = "";
 
-	@allitems = ("Installation", "ScpAction", "Directory", "File",
-				 "Shortcut", "Unixlink", "Module", "Profile", "ProfileItem",
-				 "Folder", "FolderItem", "RegistryItem", "WindowsCustomAction",
-				 "MergeModule");
-
-	@items_assigned_at_modules = ("File", "Directory", "Unixlink");
-	@items_with_directories = ("File", "Profile", "Shortcut", "Unixlink");
-	@items_with_moduleid = ("Profile", "ProfileItem", "FolderItem", "RegistryItem");
-	@items_without_moduleid = ("File", "Directory", "Shortcut", "Unixlink");
+	@allitems = ("Installation", "ScpAction", "HelpText", "Directory", "DataCarrier", "StarRegistry", "File",
+				 "Shortcut", "Custom", "Unixlink" ,"Procedure", "Module", "Profile", "ProfileItem",
+				 "Folder", "FolderItem", "RegistryItem", "StarRegistryItem", "WindowsCustomAction");
 
-	%searchkeys = ("File" => "Files", "Directory" => "Dirs", "Unixlink" => "Unixlinks");
+	@items_with_moduleid = ("Profile", "ProfileItem",
+				 			"FolderItem", "RegistryItem", "StarRegistryItem");
 
 	$logging = 0;
 	$logfilename = "logfile.log";	# the default logfile name for global errors
 	@logfileinfo = ();
-
+	
 	$multidefinitionerror = 0;
-	$multiassignmenterror = 0;
-
-	%definitions;
-	%assignedgids;
-		
+	@multidefinitiongids = ();
+	
 	$plat = $^O;
 
 	if (( $plat =~ /MSWin/i ) || (( $plat =~ /cygwin/i ) && ( $ENV{'USE_SHELL'} eq "4nt" )))
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/par2script/module.pm solenv/bin/modules/par2script/module.pm
--- solenv.bak/bin/modules/par2script/module.pm	2007-08-20 17:29:05.000000000 +0200
+++ solenv/bin/modules/par2script/module.pm	2008-03-31 14:09:36.474213800 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: module.pm,v $
 #
-#   $Revision: 1.7 $
+#   $Revision: 1.6 $
 #
-#   last change: $Author: ihi $ $Date: 2007/08/20 15:29:05 $
+#   last change: $Author: ihi $ $Date: 2007/07/12 11:17:28 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -33,240 +33,343 @@
 #
 #*************************************************************************
 
+
 package par2script::module;
 
 use par2script::converter;
-use par2script::exiter;
+use par2script::work;
 
 ###########################################
-# Removing undefined gids 
+# Removing undefined gids automatically
 # from modules
 ###########################################
 
 sub remove_from_modules
 {
-	my ($gid, $item) = @_;
+	my ($script) = @_;
 
-	my $counter = 0;
+	# if these 5 gids are not defined, they are automatically removed from the module
+		
+	my $allfilegids = par2script::work::get_all_gids_from_script($script, "File");
+	my $allproceduregids = par2script::work::get_all_gids_from_script($script, "Procedure");
+	my $allcustomgids = par2script::work::get_all_gids_from_script($script, "Custom");
+	my $alldirectorygids = par2script::work::get_all_gids_from_script($script, "Directory");
+	my $allunixlinkgids = par2script::work::get_all_gids_from_script($script, "Unixlink");
+	
+	for ( my $i = 0; $i <= $#{$script}; $i++ )
+	{
+		my $oneline = ${$script}[$i];
+		
+		my $modulename;
+		
+		if ( $oneline =~ /^\s*Module\s+(\w+)\s*$/ )
+		{		
+			$modulegid = $1;
+			next;
+		}
+		
+		if ( $oneline =~ /^\s*(\w+?)\s*\=\s*\((.*?)\)\s*\;\s*$/ )
+		{
+			my $key = $1;
+			my $allassigneditemsstring = $2;
+			my $defineditemgids;
+
+			if ( $key eq "Files" ) { $defineditemgids = $allfilegids; }
+			elsif ( $key eq "Dirs" ) { $defineditemgids = $alldirectorygids; }
+			elsif ( $key eq "Procedures" ) { $defineditemgids = $allproceduregids; }
+			elsif ( $key eq "Customs" ) { $defineditemgids = $allcustomgids; }
+			elsif ( $key eq "Unixlinks" ) { $defineditemgids = $allunixlinkgids; }
+			else { next; }	# for instance "Styles"
 
-	if ( ! exists($par2script::globals::searchkeys{$item}) ) { par2script::exiter::exit_program("ERROR: Unknown type \"$item\" at modules.", "remove_from_modules"); }
-	my $searchkey = $par2script::globals::searchkeys{$item};
+			my $allassigneditems = par2script::converter::convert_stringlist_into_array(\$allassigneditemsstring, ",");
 
-	my $allmodules = $par2script::globals::definitions{'Module'};
+			for ( my $j = 0; $j <= $#{$allassigneditems}; $j++ )
+			{
+				my $oneassigneditem = ${$allassigneditems}[$j];
 
-	my $onemodule;
-	foreach $onemodule (keys %{$allmodules})
-	{
-		if (( exists($allmodules->{$onemodule}->{$searchkey}) ) && ( $allmodules->{$onemodule}->{$searchkey} =~ /\b$gid\b/ ))
-		{
-			my $infoline = "WARNING: Removing $gid because of missing definition\n";
-			# print $infoline;
-			push(@par2script::globals::logfileinfo, $infoline);
+				# is there a definition for this assigned item?
+
+				my $itemisdefined = 0;
 
-			$allmodules->{$onemodule}->{$searchkey} =~ s/\b$gid\b//;
-			$allmodules->{$onemodule}->{$searchkey} =~ s/\,\s*\,/\,/;
-			$allmodules->{$onemodule}->{$searchkey} =~ s/\(\s*\,\s*/\(/;
-			$allmodules->{$onemodule}->{$searchkey} =~ s/\s*\,\s*\)/\)/;
+				for ( my $k = 0; $k <= $#{$defineditemgids}; $k++ )
+				{
+					if ( $oneassigneditem eq ${$defineditemgids}[$k] )
+					{
+						$itemisdefined = 1;
+						last;	
+					}
+				}
+				
+				if (! $itemisdefined)
+				{
+					my $infoline = "WARNING: Removing $oneassigneditem from Module $modulegid\n";
+					# print $infoline;
+					push(@par2script::globals::logfileinfo, $infoline);
+
+					${$script}[$i] =~ s/\b$oneassigneditem\b//;
+					${$script}[$i] =~ s/\,\s*\,/\,/;
+					${$script}[$i] =~ s/\(\s*\,\s*/\(/;
+					${$script}[$i] =~ s/\s*\,\s*\)/\)/;
 					
-			if (( $allmodules->{$onemodule}->{$searchkey} =~ /\(\s*\,\s*\)/ ) || 
-				( $allmodules->{$onemodule}->{$searchkey} =~ /\(\s*\)/ ))
-			{
-				delete($allmodules->{$onemodule}->{$searchkey});
-			}
-			
-			$counter++;			
+					if (( ${$script}[$i] =~ /\(\s*\,\s*\)/ ) || ( ${$script}[$i] =~ /\(\s*\)/ ))
+					{
+						# this line can be removed
+						splice(@{$script}, $i, 1);
+						$i--;		# decreasing the counter!
+					}					
+				}			
+			}		
 		}
 	}
-	
-	return $counter;	
 }
 
 ###########################################
-# Removing undefined gids automatically
-# from modules
+# Adding the collectors
+# to the root module
 ###########################################
 
-sub remove_undefined_gids_from_modules
+sub	create_rootmodule
 {
-	# If assigned gids for "File", "Directory" or "Unixlink" are not defined, 
-	# they are automatically removed from the module
-
-	foreach $item ( @par2script::globals::items_assigned_at_modules )
+	my ($rootmodule, $allitemgids, $itemname) = @_;
+	
+	if ( $#{$allitemgids} > -1 )
 	{
-		my $assignedgids = $par2script::globals::assignedgids{$item};
-		my $definedgids = $par2script::globals::definitions{$item};
-
-		my $gid;
-		foreach $gid ( keys %{$assignedgids} )
+		my $oneline = "\t$itemname \= \(";
+		
+		for ( my $i = 0; $i <= $#{$allitemgids}; $i++ )
 		{
-			if ( ! exists( $definedgids->{$gid} ))
-			{
-				# deleting entry in module definition
-				my $number_of_removals = remove_from_modules($gid, $item);
-				# decreasing counter in assignments
-				if ( $assignedgids->{$gid} > $number_of_removals ) { $assignedgids->{$gid} = $assignedgids->{$gid} - $number_of_removals; }
-				else { delete($assignedgids->{$gid}); }								
-			}
-		}
-	}
-}
+			my $onegid = ${$allitemgids}[$i];
 
-############################################
-# Getting the gid of the root module. The 
-# root module has no ParentID or an empty
-# ParentID.
-############################################
-
-sub get_rootmodule_gid
-{
-	my $rootgid = "";
-	my $foundroot = 0;
+			my $infoline = "WARNING: Adding $onegid to root module\n";
+			# print $infoline;
 
-	my $allmodules = $par2script::globals::definitions{'Module'};
+			if ($oneline eq "")	{ $oneline = "\t\t\t\t"; }	
+			
+			$oneline .= $onegid;
+			
+			if ( $i == $#{$allitemgids} ) { $oneline .= "\)\;"; }
+			else { $oneline .= "\,"; } 
 	
-	my $modulegid = "";
-	foreach $modulegid (keys %{$allmodules} )
-	{
-		# print "Module $modulegid\n";
-		# my $content = "";
-		# foreach $content (sort keys %{$allmodules->{$modulegid}}) { print "\t$content = $allmodules->{$modulegid}->{$content};\n"; }
-		# print "End\n";
-		# print "\n";
+			if ( length($oneline) > 100 )
+			{
+				$oneline .= "\n";
+				push(@{$rootmodule}, $oneline);
+				$oneline = "";	
+			}
+		
+		}
 
-		if (( ! exists($allmodules->{$modulegid}->{'ParentID'})) || ( $allmodules->{$modulegid}->{'ParentID'} eq "" ))
+		if (! $oneline =~ /^\s*$/ )
 		{
-			if ( $foundroot ) { par2script::exiter::exit_program("ERROR: More than one Root module. Only one module without ParentID or with empty ParentID allowed ($rootgid and $modulegid).", "get_rootmodule_gid"); }
-			$rootgid = $modulegid;
-			$foundroot = 1;
+			$oneline .= "\n";
+			push(@{$rootmodule}, $oneline);
 		}
 	}
-	
-	if ( ! $foundroot ) { par2script::exiter::exit_program("ERROR: Could not find Root module. Did not find module without ParentID or with empty ParentID.", "get_rootmodule_gid"); }
-	
-	return $rootgid;	
 }
 
-####################################
-# Adding defined items without 
-# assignment to the root module.
-####################################
+######################################################
+# Splitting one long line into several short lines
+######################################################
 
-sub add_to_root_module
+sub make_multiliner
 {
-	# If defined gids for "File", "Directory" or "Unixlink" are not assigned, 
-	# they are automatically assigned to the root module
-	
-	my $rootmodulegid = get_rootmodule_gid();
+	my ($itemname, $allgidstring) = @_;
 
-	my $item;
-	foreach $item ( @par2script::globals::items_assigned_at_modules )
-	{
-		my $assignedgids = $par2script::globals::assignedgids{$item};
-		my $definedgids = $par2script::globals::definitions{$item};
+	my @newblock = ();
 
-		my $gidstring = "";
+	my $allitemgids = par2script::converter::convert_stringlist_into_array(\$allgidstring, ",");
+
+	if ( $#{$allitemgids} > -1 )
+	{
+		my $oneline = "\t$itemname \= \(";
 		
-		# Perhaps there are already items assigned to the root
-		if ( ! exists($par2script::globals::searchkeys{$item}) ) { par2script::exiter::exit_program("ERROR: Unknown type \"$item\" at modules.", "remove_from_modules"); }
-		my $modulekey = $par2script::globals::searchkeys{$item};
-		if ( exists($par2script::globals::definitions{'Module'}->{$rootmodulegid}->{$modulekey}) )
+		for ( my $i = 0; $i <= $#{$allitemgids}; $i++ )
 		{
-			$gidstring = $par2script::globals::definitions{'Module'}->{$rootmodulegid}->{$modulekey};
-			$gidstring =~ s/\(//;
-			$gidstring =~ s/\)//;
-		}
+			my $onegid = ${$allitemgids}[$i];
 
-		my $gid;
-		foreach $gid ( keys %{$definedgids} )
-		{
-			if ( ! exists( $assignedgids->{$gid} ))
+			if ($oneline eq "")	{ $oneline = "\t\t\t\t"; }	
+			
+			$oneline .= $onegid;
+			
+			if ( $i == $#{$allitemgids} ) { $oneline .= "\)\;"; }
+			else { $oneline .= "\,"; } 
+	
+			if ( length($oneline) > 100 )
 			{
-				if ( $gidstring eq "" )
-				{
-					$gidstring = $gid;
-				}
-				else
-				{
-					$gidstring = "$gidstring,$gid";
-				}
-				
-				$assignedgids->{$gid} = 1;
+				$oneline .= "\n";
+				push(@newblock, $oneline);
+				$oneline = "";	
 			}
 		}
 
-		if ( $gidstring ne "" )
+		if (! $oneline =~ /^\s*$/ )
 		{
-			$gidstring = "\($gidstring\)";
-			$par2script::globals::definitions{'Module'}->{$rootmodulegid}->{$modulekey} = $gidstring;
+			$oneline .= "\n";
+			push(@newblock, $oneline);
 		}
 	}	
+
+	return \@newblock;
 }
 
 ###################################################
-# Including \n in a very long string
+# Shorten the lines that belong to modules, if
+# the length of the line is greater 100
 ###################################################
 
-sub include_linebreaks
+sub shorten_lines_at_modules
 {
-	my ($allgidstring) = @_;
+	my ($script) = @_;
 
-	my $newline = "";
-	my $newlength = 0;
-
-	$allgidstring =~ s/\(//;
-	$allgidstring =~ s/\)//;
-	
-	my $allgids = par2script::converter::convert_stringlist_into_array_2($allgidstring, ",");
+	my $ismoduleblock = 0;
 
-	if ( $#{$allgids} > -1 )
+	for ( my $i = 0; $i <= $#{$script}; $i++ )
 	{
-		my $onegid;
-		foreach $onegid ( @{$allgids} )
-		{
-			$newline = "$newline$onegid,";
-			$newlength = $newlength + length($onegid) + 1; # +1 for the comma
+		my $oneline = ${$script}[$i];
 
-			if ( $newlength > 80 )
+		if ( $oneline =~ /^\s*Module\s+\w+\s*$/ ) { $ismoduleblock = 1; }		
+		if (( $oneline =~ /^\s*End\s*$/ ) && ( $ismoduleblock )) { $ismoduleblock = 0; }
+		
+		if ( $ismoduleblock )
+		{
+			if (( $oneline =~ /^\s*(\w+)\s*\=\s*\((.*)\)\s*\;\s*$/ ) && ( length($oneline) > 100 ))
 			{
-				$newline = $newline . "\n\t\t\t\t";
-				$newlength = 0;	
+				# this line has to be splitted in several lines
+				my $item = $1;
+				my $allgidstring = $2;
+				
+				my $multilines = make_multiliner($item, $allgidstring);
+				splice(@{$script}, $i, 1, @{$multilines});				 
 			}
 		}
-	}	
-
-	$newline =~ s/,\s*$//;
-	$newline = "($newline)";
-
-	return $newline;
+	}
 }
 
-###################################################
-# Shorten the lines that belong to modules, if
-# the length of the line is greater 100
-###################################################
+###########################################
+# Adding defined gids automatically
+# to the root module
+###########################################
 
-sub shorten_lines_at_modules
+sub add_to_root_module
 {
-	my $item;
-	foreach $item ( @par2script::globals::items_assigned_at_modules )
+	my ($script) = @_;
+
+	my $rootmodulestartline = "";
+
+	# if these 4 gids are defined and not added to another module, they are automatically added to the root module
+		
+	my $allfilegids = par2script::work::get_all_gids_from_script($script, "File");
+	my $allproceduregids = par2script::work::get_all_gids_from_script($script, "Procedure");
+	my $allcustomgids = par2script::work::get_all_gids_from_script($script, "Custom");
+	my $alldirectorygids = par2script::work::get_all_gids_from_script($script, "Directory");
+	my $allunixlinkgids = par2script::work::get_all_gids_from_script($script, "Unixlink");
+	
+	for ( my $i = 0; $i <= $#{$script}; $i++ )
 	{
-		if ( ! exists($par2script::globals::searchkeys{$item}) ) { par2script::exiter::exit_program("ERROR: Unknown type \"$item\" at modules.", "shorten_lines_at_modules"); }
-		my $searchkey = $par2script::globals::searchkeys{$item};
+		my $oneline = ${$script}[$i];
 
-		my $allmodules = $par2script::globals::definitions{'Module'};
+		if (( $oneline =~ /^\s*Module\s+\w+\s*$/ ) && ( $rootmodulestartline eq "" ))	# the first module is the root module
+		{
+			$rootmodulestartline = $i;			
+		}
 
-		my $onemodule;
-		foreach $onemodule (keys %{$allmodules})
+		if ( $oneline =~ /^\s*(\w+?)\s*\=\s*\((.*?)\)\s*\;\s*$/ )
 		{
-			if (( exists($allmodules->{$onemodule}->{$searchkey}) ) && 
-				( length($allmodules->{$onemodule}->{$searchkey}) > 100 ))
+			my $key = $1;
+			my $allassigneditemsstring = $2;
+			my $defineditemgids;
+
+			if ( $key eq "Files" ) { $defineditemgids = $allfilegids; }
+			elsif ( $key eq "Dirs" ) { $defineditemgids = $alldirectorygids; }
+			elsif ( $key eq "Procedures" ) { $defineditemgids = $allproceduregids; }
+			elsif ( $key eq "Customs" ) { $defineditemgids = $allcustomgids; }
+			elsif ( $key eq "Unixlinks" ) { $defineditemgids = $allunixlinkgids; }
+			else { next; }	# for instance "Styles"
+
+			my $allassigneditems = par2script::converter::convert_stringlist_into_array(\$allassigneditemsstring, ",");
+
+			for ( my $j = 0; $j <= $#{$allassigneditems}; $j++ )
 			{
-				# including "\n\t\t\t\t"
-				my $newstring = include_linebreaks($allmodules->{$onemodule}->{$searchkey});
-				$allmodules->{$onemodule}->{$searchkey} = $newstring;
+				my $oneassigneditem = ${$allassigneditems}[$j];
+
+				# this can be removed for the list for the root module
+
+				for ( my $k = 0; $k <= $#{$defineditemgids}; $k++ )
+				{
+					if ( $oneassigneditem eq ${$defineditemgids}[$k] )
+					{
+						splice(@{$defineditemgids}, $k, 1);
+						last;	
+					}
+				}
+			}		
+		}
+	}
+	
+	# Now the four collectors contain only gids, that have to be added to the root module
+	# The module begins at $rootmodulestartline
+
+	for ( my $i = $rootmodulestartline; $i <= $#{$script}; $i++ )
+	{
+		my $oneline = ${$script}[$i];
+
+		if ( $oneline =~ /^\s*End\s*$/ ) { last; }
+
+		if ( $oneline =~ /^\s*(\w+)\s+\=\s+\((.*)\)\s*\;\s*$/ )
+		{
+			my $key = $1;
+			my $allassigneditemsstring = $2;
+			my $defineditemgids;
+			
+			if ( $key eq "Files" ) { $defineditemgids = $allfilegids; }
+			elsif ( $key eq "Dirs" ) { $defineditemgids = $alldirectorygids; }
+			elsif ( $key eq "Procedures" ) { $defineditemgids = $allproceduregids; }
+			elsif ( $key eq "Customs" ) { $defineditemgids = $allcustomgids; }
+			elsif ( $key eq "Unixlinks" ) { $defineditemgids = $allunixlinkgids; }
+			else { next; }	# for instance "Styles"
+
+			my $allassigneditems = par2script::converter::convert_stringlist_into_array(\$allassigneditemsstring, "\,");
+			
+			# adding the root module items to the collectors
+			
+			for ( my $j = 0; $j <= $#{$allassigneditems}; $j++ )
+			{
+				push(@{$defineditemgids}, ${$allassigneditems}[$j]);
 			}
+			
+			# then the existing lines can be removed
+
+			splice(@{$script}, $i, 1);
+			$i--;		# decreasing the counter!							
+		}
+	}
+
+	# creation of the new block
+	
+	my @rootmodule = ();
+	my $rootmoduleref = \@rootmodule;
+	
+	create_rootmodule($rootmoduleref, $alldirectorygids, "Dirs");
+	create_rootmodule($rootmoduleref, $allfilegids, "Files");
+	create_rootmodule($rootmoduleref, $allproceduregids, "Procedures");
+	create_rootmodule($rootmoduleref, $allcustomgids, "Customs");
+	create_rootmodule($rootmoduleref, $allunixlinkgids, "Unixlinks");
+
+	# and finally the new blocks can be inserted into the root module
+
+	my $insertline;
+
+	for ( my $i = $rootmodulestartline; $i <= $#{$script}; $i++ )
+	{		
+		if ( ${$script}[$i] =~ /^\s*End\s*$/i )
+		{
+			$insertline = $i;
+			last;
 		}
 	}
+	
+	splice(@{$script}, $insertline, 0, @{$rootmoduleref});
+
 }
 
 1;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/par2script/parameter.pm solenv/bin/modules/par2script/parameter.pm
--- solenv.bak/bin/modules/par2script/parameter.pm	2007-08-20 17:29:18.000000000 +0200
+++ solenv/bin/modules/par2script/parameter.pm	2008-03-31 14:09:36.474213800 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: parameter.pm,v $
 #
-#   $Revision: 1.5 $
+#   $Revision: 1.4 $
 #
-#   last change: $Author: ihi $ $Date: 2007/08/20 15:29:18 $
+#   last change: $Author: rt $ $Date: 2005/09/08 09:27:14 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -144,6 +144,35 @@
 	par2script::files::check_file($par2script::globals::parfilelist);
 }
 
+##########################################################
+# The path parameters can be relative or absolute.
+# This function creates absolute pathes.
+##########################################################
+
+sub make_path_absolute
+{
+	my ($pathref) = @_;
+
+	if ( $par2script::globals::isunix )
+	{
+		if (!($$pathref =~ /^\s*\//))	# this is a relative unix path
+		{
+			$$pathref = cwd() . $par2script::globals::separator . $$pathref;
+		}
+	}
+
+	if ( $par2script::globals::iswin )
+	{
+		if (!($$pathref =~ /^\s*\w\:/))	# this is a relative windows path
+		{
+			$$pathref = cwd() . $par2script::globals::separator . $$pathref;
+			$$pathref =~ s/\//\\/g;
+		}
+	}
+
+	$$pathref =~ s/\Q$par2script::globals::separator\E\s*$//;	# removing ending slashes	
+}
+
 #####################################
 # Writing parameter to shell
 #####################################
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/par2script/undefine.pm solenv/bin/modules/par2script/undefine.pm
--- solenv.bak/bin/modules/par2script/undefine.pm	2007-08-20 17:29:32.000000000 +0200
+++ solenv/bin/modules/par2script/undefine.pm	2008-03-31 14:09:36.474213800 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: undefine.pm,v $
 #
-#   $Revision: 1.5 $
+#   $Revision: 1.4 $
 #
-#   last change: $Author: ihi $ $Date: 2007/08/20 15:29:32 $
+#   last change: $Author: ihi $ $Date: 2007/03/26 12:46:08 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -35,7 +35,41 @@
 
 package par2script::undefine;
 
+use par2script::existence;
 use par2script::globals;
+use par2script::remover;
+use par2script::work;
+
+##########################################################
+# Collecting all undefines, that are listed 
+# in one par file
+##########################################################
+
+sub get_list_of_undefines
+{
+	my ($item, $parfile) = @_;
+
+	my @collector  =();
+	
+	for ( my $i = 0; $i <= $#{$parfile}; $i++ )
+	{	
+		if ( ${$parfile}[$i] =~ /^\s*$item\s*(\w+)\s*$/ )
+		{
+			my $gid = $1;
+			
+			my $oneitem = $item;
+			$oneitem =~ s/^\s*Un//;	# removing the "Un"
+
+			my %removeitem = ();
+			$removeitem{'gid'} = $gid;
+			$removeitem{'item'} = $oneitem;
+
+			push(@collector, \%removeitem);	
+		}
+	}
+	
+	return \@collector;
+}
 
 ##########################################################
 # Removing in the script all the gids, that are listed 
@@ -44,48 +78,119 @@
 
 sub undefine_gids
 {
-	my ($parfilecontent) = @_;
+	my ($script, $parfile) = @_;
 
-	my $item;
-	foreach $item ( @par2script::globals::allitems )
-	{
-		my $unitem = "Un$item";
+	my @allundefines = ();
 
-		for ( my $i = 0; $i <= $#{$parfilecontent}; $i++ )
-		{	
-			if ( ${$parfilecontent}[$i] =~ /^\s*$unitem\s*(\w+?)\s*$/ )
-			{
-				my $gid = $1;
-				delete($par2script::globals::definitions{$item}->{$gid});
-			}
+	for ( my $i = 0; $i <= $#par2script::globals::allitems; $i++ )
+	{
+		my $oneitem = "Un" . $par2script::globals::allitems[$i];
+		
+		my $collector = get_list_of_undefines($oneitem, $parfile);
+						
+		if ($#{$collector} > -1 ) { par2script::work::add_array_into_array(\@allundefines, $collector); }
+	}
+		
+	if ($#allundefines > -1 )
+	{
+		for ( my $i = 0; $i <= $#allundefines; $i++ )
+		{
+			my $gid = $allundefines[$i]->{'gid'};
+			par2script::remover::remove_leading_and_ending_whitespaces(\$gid);
+			par2script::work::remove_definitionblock_from_script($script, $gid);
 		}
 	}
 }
 
 ##########################################################
-# Collecting all subdirectories of a specified directory 
+# Collecting all RemoveDirectories, that are listed 
+# in the par files
 ##########################################################
 
-sub collect_children_dirs
+sub get_list_of_removeitems
 {
-	my ($gid, $collector) = @_;
+	my ($removeitem, $parfile) = @_;
+
+	my @collector  =();
 	
-	my $diritem = "Directory";
-	my $parentkey = "ParentID";
+	for ( my $i = 0; $i <= $#{$parfile}; $i++ )
+	{	
+		if ( ${$parfile}[$i] =~ /^\s*\Q$removeitem\E\s+(\w+)\s*$/ )
+		{
+			my $gid = $1;
+			my $item = $removeitem;
+			$item =~ s/Remove//;
+
+			my %removeitem = ();
+			$removeitem{'gid'} = $gid;
+			$removeitem{'item'} = $oneitem;
 
-	if ( exists($par2script::globals::definitions{$diritem}) )
+			push(@collector, \%removeitem);	
+		}
+	}
+	
+	return \@collector;
+}
+
+##########################################################
+# Removing in the script complete directories. 
+# This includes subdirectories, files and shortcuts.
+##########################################################
+
+sub remove_complete_dirs
+{
+	my ($script, $parfile) = @_;
+
+	my $removeitem = "RemoveDirectory";
+	my @allundefines = ();
+	my @alldirs = ();
+	my @removeitems = ("File", "Shortcut");
+
+	# Collecting all definitions of "RemoveDirectory"
+	my $oneremoveitem = "RemoveDirectory";
+	my $directremovedirs = get_list_of_removeitems($oneremoveitem, $parfile);
+
+	if ($#{$directremovedirs} > -1 )
 	{
-		my $onedefinition;
-				
-		foreach $onedefinition (keys %{$par2script::globals::definitions{$diritem}})
+		par2script::work::add_array_into_array(\@allundefines, $directremovedirs);
+		par2script::work::add_array_into_array(\@alldirs, $directremovedirs);
+
+		# Collecting all subdirectories
+		for ( my $i = 0; $i <= $#{$directremovedirs}; $i++ )
+		{
+			my @collector = ();
+			my $dir = ${$directremovedirs}[$i];
+			my $directorygid = $dir->{'gid'};
+			par2script::work::collect_subdirectories($parfile, $directorygid, \@collector);
+			par2script::work::add_array_into_array(\@allundefines, \@collector);
+			par2script::work::add_array_into_array(\@alldirs, \@collector);
+		}
+
+		# Collecting Files and ShortCuts, that are installed in the collected directories
+		for ( my $i = 0; $i <= $#removeitems; $i++ )
 		{
-			if ( $par2script::globals::definitions{$diritem}->{$onedefinition}->{$parentkey} eq $gid )
+			for ( my $j = 0; $j <= $#alldirs; $j++ )
 			{
-				push(@{$collector}, $onedefinition);
-				collect_children_dirs($onedefinition, $collector);
+				my @collector = ();
+				my $item = $removeitems[$i];
+				my $dir = $alldirs[$j];
+				my $directorygid = $dir->{'gid'};
+				par2script::work::get_all_items_in_directories($parfile, $directorygid, $item, \@collector);
+				par2script::work::add_array_into_array(\@allundefines, \@collector);
 			}
 		}
 	}
+
+	if ($#allundefines > -1 )
+	{
+		for ( my $i = 0; $i <= $#allundefines; $i++ )
+		{
+			my $gid = $allundefines[$i]->{'gid'};
+			print "Removing gid from script: $gid \n";
+			par2script::remover::remove_leading_and_ending_whitespaces(\$gid);
+			par2script::work::remove_definitionblock_from_script($script, $gid);
+		}
+	}
 }
 
 ##########################################################
@@ -93,60 +198,49 @@
 # This includes the Profile and its ProfileItems.
 ##########################################################
 
-sub remove_complete_item
+sub remove_complete_profile
 {
-	my ($item, $parfilecontent) = @_;
+	my ($script, $parfile) = @_;
 
-	my $removeitem = "Remove$item";
-	my $dependentkey = "";
-	my $collect_children = 0;
-	my @gidcollector = ();
-	my @dependentitems = ();
+	my $removeitem = "RemoveProfile";
+	my @allundefines = ();
+	my @alldirs = ();
+	my @removeitems = ("ProfileItem");
+
+	# Collecting all definitions of "RemoveProfile"
+	my $oneremoveitem = "RemoveProfile";
+	my $directremoveprofiles = get_list_of_removeitems($oneremoveitem, $parfile);
 
-	if ( $item eq "Profile" )
-	{
-		@dependentitems = ("ProfileItem");
-		$dependentkey = "ProfileID";
-	}
-	elsif ( $item eq "Directory" )
+	if ($#{$directremoveprofiles} > -1 )
 	{
-		@dependentitems = ("File", "Shortcut", "Unixlink");
-		$dependentkey = "Dir";
-		$collect_children = 1;
-	}
+		par2script::work::add_array_into_array(\@allundefines, $directremoveprofiles);
+		par2script::work::add_array_into_array(\@allprofiles, $directremoveprofiles);
 
-	for ( my $i = 0; $i <= $#{$parfilecontent}; $i++ )
-	{	
-		if ( ${$parfilecontent}[$i] =~ /^\s*$removeitem\s*(\w+?)\s*$/ )
+		# Collecting ProfileItems, that are written in the collected Profiles
+		for ( my $i = 0; $i <= $#removeitems; $i++ )
 		{
-			my $onegid = $1;
-			push(@gidcollector, $onegid);
-			if ( $collect_children ) { collect_children_dirs($onegid, \@gidcollector); }
-
-			my $gid;
-			foreach $gid (@gidcollector)
+			for ( my $j = 0; $j <= $#allprofiles; $j++ )
 			{
-				delete($par2script::globals::definitions{$item}->{$gid});
-
-				# also deleting all dependent items, for example "ProfileItems" whose "ProfileID" is this "Profile"
-				my $depitem;
-				foreach $depitem ( @dependentitems )
-				{
-					if ( exists($par2script::globals::definitions{$depitem}) )
-					{
-						my $onedefinition;				
-						foreach $onedefinition (keys %{$par2script::globals::definitions{$depitem}})
-						{
-							if ( $par2script::globals::definitions{$depitem}->{$onedefinition}->{$dependentkey} eq $gid )
-							{
-								delete($par2script::globals::definitions{$depitem}->{$onedefinition});
-							}
-						}
-					}
-				}
+				my @collector = ();
+				my $item = $removeitems[$i];
+				my $profile = $allprofiles[$j];
+				my $profilegid = $profile->{'gid'};
+				par2script::work::get_all_items_in_profile($parfile, $profilegid, $item, \@collector);
+				par2script::work::add_array_into_array(\@allundefines, \@collector);
 			}
 		}
 	}
+
+	if ($#allundefines > -1 )
+	{
+		for ( my $i = 0; $i <= $#allundefines; $i++ )
+		{
+			my $gid = $allundefines[$i]->{'gid'};
+			print "Removing gid from script: $gid \n";
+			par2script::remover::remove_leading_and_ending_whitespaces(\$gid);
+			par2script::work::remove_definitionblock_from_script($script, $gid);
+		}
+	}
 }
 
 1;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/par2script/work.pm solenv/bin/modules/par2script/work.pm
--- solenv.bak/bin/modules/par2script/work.pm	2007-08-20 17:29:46.000000000 +0200
+++ solenv/bin/modules/par2script/work.pm	2008-03-31 14:09:36.474213800 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: work.pm,v $
 #
-#   $Revision: 1.7 $
+#   $Revision: 1.6 $
 #
-#   last change: $Author: ihi $ $Date: 2007/08/20 15:29:46 $
+#   last change: $Author: ihi $ $Date: 2007/03/26 12:46:22 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -95,18 +95,23 @@
 sub setparfiles
 {
 	my ($filename) = @_;
-
+	
 	# input is the name of the list file
+
 	$filename =~ s/\@//;	# removing the leading \@
 
 	my $filecontent = par2script::files::read_file($filename);
 	
 	my @parfiles = ();
 	my $parfilesref = \@parfiles;
-
-	foreach ( @{$filecontent} ) { $parfilesref = analyze_comma_separated_list($_, $parfilesref); }
-
-	return $parfilesref;	
+	
+	for ( my $i = 0; $i <= $#{$filecontent}; $i++ )
+	{
+		my $oneline = ${$filecontent}[$i];
+		my $parfilesref = analyze_comma_separated_list($oneline, $parfilesref);
+	}
+	
+	return \@parfiles;
 }
 
 ############################################
@@ -117,26 +122,23 @@
 sub make_complete_pathes_for_parfiles
 {
 	my ($parfiles, $includes) = @_;
-
-	my $oneparfile;
-
-	foreach $oneparfile ( @{$parfiles} )
+	
+	for ( my $i = 0; $i <= $#{$parfiles}; $i++ )
 	{
 		my $foundparfile = 0;
-		my $includepath;
 		
-		foreach $includepath ( @{$includes} )
+		for ( my $j = 0; $j <= $#{$includes}; $j++ )
 		{
-			my $parfile = "$includepath/$oneparfile"; 
-
+			my $parfile = ${$includes}[$j] . $par2script::globals::separator . ${$parfiles}[$i]; 
+			
 			if ( -f $parfile )
 			{
 				$foundparfile = 1;
-				$oneparfile = $parfile;
+				${$parfiles}[$i] = $parfile;
 				last;
 			}
 		}
-
+		
 		if ( ! $foundparfile )
 		{
 			die "ERROR: Could not find parfile ${$parfiles}[$i] in includes pathes: $par2script::globals::includepathlist !\n"; 	
@@ -145,258 +147,546 @@
 }
 
 ######################################################
-# collecting one special item in the par files and 
-# including it into the "definitions" hash
+# collecting one special item in all par files and 
+# including it into the script file
 ######################################################
 
-sub collect_definitions
+sub put_item_into_collector
 {
-	my ($parfilecontent) = @_;
+	my ( $item, $parfile, $collector ) = @_;
+
+	my $include = 0;
 	
-	my $multidefinitionerror = 0;
-	my @multidefinitiongids = ();
+	for ( my $i = 0; $i <= $#{$parfile}; $i++ )
+	{	
+		if ( ${$parfile}[$i] =~ /^\s*$item\s*\w+\s*$/ )
+		{
+			$include = 1;
+		}
 
+		if ( $include )
+		{
+			push(@{$collector}, ${$parfile}[$i]);	
+		}
 
-	foreach $oneitem ( @par2script::globals::allitems )
-	{
-		my $docollect = 0;
-		my $gid = "";
-		my %allitemhash = ();
+		if (( $include ) && ( ${$parfile}[$i] =~ /^\s*End\s*$/i ))
+		{
+			$include = 0;
+			push(@{$collector}, "\n");	# empty line at the end	
+		}
+	}
+}
+
+######################################################
+# putting all collected items of one type
+# into the script file 
+######################################################
+
+sub put_item_into_script
+{
+	my ($script, $itemcollector) = @_;
+		
+	for ( my $i = 0; $i <= $#{$itemcollector}; $i++ )
+	{	
+		push(@{$script}, ${$itemcollector}[$i]);
+	}
+}
+
+#######################################################################
+# Collecting all gids of the type "searchitem" from the setup script
+#######################################################################
+
+sub get_all_gids_from_script
+{
+	my ($itemcollector, $oneitem) = @_;
+
+	my @allgidarray = ();
+
+	for ( my $i = 0; $i <= $#{$itemcollector}; $i++ )
+	{		
+		if ( ${$itemcollector}[$i] =~ /^\s*\Q$oneitem\E\s+(\S+)\s*$/ )
+		{
+			my $gid = $1;
+			push(@allgidarray, $gid);
+		}
+	}	
 	
-		for ( my $i = 0; $i <= $#{$parfilecontent}; $i++ )
+	return \@allgidarray;
+}
+
+#######################################################################
+# Collecting all items of the type "searchitem" from the setup script
+#######################################################################
+
+sub get_all_items_from_script
+{
+	my ($scriptref, $searchitem) = @_;
+
+	my @allitemarray = ();
+	
+	my ($line, $gid, $counter, $itemkey, $itemvalue, $valuecounter);
+
+	for ( my $i = 0; $i <= $#{$scriptref}; $i++ )
+	{
+		$line = ${$scriptref}[$i];
+		
+		if ( $line =~ /^\s*\Q$searchitem\E\s+(\S+)\s*$/ )
 		{
-			my $line = ${$parfilecontent}[$i];
+			$gid = $1;
+			$counter = $i + 1;
 			
-			if ( $line =~ /^\s*$oneitem\s+(\w+)\s*$/ )
-			{
-				$gid = $1;
-				$docollect = 1;
-			}
-			else
+			my %oneitemhash = ();
+			$oneitemhash{'gid'} = $gid;			
+						
+			while  (!( $line =~ /^\s*End\s*$/ ))
 			{
-				$docollect = 0;			
-			}
+				$line = ${$scriptref}[$counter];
+				$counter++;
 
-			if ( $docollect )
-			{
-				my $currentline = $i;
-				my %oneitemhash;
-			
-				while (! ( ${$parfilecontent}[$currentline] =~ /^\s*End\s*$/i ) )
+				if ( $line =~ /^\s*(.+?)\s*\=\s*(.+?)\s*\;\s*$/ )	# only oneliner!
 				{
-					if ( ${$parfilecontent}[$currentline] =~ /^\s*(.+?)\s*\=\s*(.+?)\s*\;\s*$/ )	# only oneliner!
-					{
-						$itemkey = $1;
-						$itemvalue = $2;
-					
-						if ( $oneitem eq "Directory" ) { if ( $itemkey =~ "DosName" ) { $itemkey =~ s/DosName/HostName/; } }
-						if (( $oneitem eq "Directory" ) || ( $oneitem eq "File" ) || ( $oneitem eq "Unixlink" )) { if ( $itemvalue eq "PD_PROGDIR" ) { $itemvalue = "PREDEFINED_PROGDIR"; }}
-						if (( $itemkey eq "Styles" ) && ( $itemvalue =~ /^\s*(\w+)(\s*\;\s*)$/ )) { $itemvalue = "($1)$2"; }
+					$itemkey = $1;
+					$itemvalue = $2;
 
-						$oneitemhash{$itemkey} = $itemvalue;
-					}
-						
-					$currentline++;
-				}
+					par2script::remover::remove_leading_and_ending_quotationmarks(\$itemvalue);
 
-				# no hyphen allowed in gids -> cannot happen here because (\w+) is required for gids
-				if ( $gid =~ /-/ ) { par2script::exiter::exit_program("ERROR: No hyphen allowed in global id: $gid", "test_of_hyphen"); }
+					$oneitemhash{$itemkey} = $itemvalue;
 
-				# test of uniqueness
-				if ( exists($allitemhash{$gid}) )
-				{
-					$multidefinitionerror = 1;
-					push(@multidefinitiongids, $gid);			
 				}
-
-				$allitemhash{$gid} = \%oneitemhash;
 			}
+			
+			push(@allitemarray, \%oneitemhash);
 		}
-
-		$par2script::globals::definitions{$oneitem} = \%allitemhash;
 	}
+		
+	return \@allitemarray;
+}
+
+########################################################
+# Recursively defined procedure to order 
+# modules and directories
+########################################################
 
-	if ( $multidefinitionerror ) {	par2script::exiter::multidefinitionerror(\@multidefinitiongids); }
+sub get_children
+{
+	my ($allitems, $startparent, $newitemorder) = @_;
+
+	for ( my $i = 0; $i <= $#{$allitems}; $i++ )
+	{
+		my $gid = ${$allitems}[$i]->{'gid'};
+		my $parent = "";
+		if ( ${$allitems}[$i]->{'ParentID'} ) { $parent = ${$allitems}[$i]->{'ParentID'}; }
 	
-	# foreach $key (keys %par2script::globals::definitions)
-	# {
-	#	print "Key: $key \n";
-	#
-	#	foreach $key (keys %{$par2script::globals::definitions{$key}})
-	#	{
-	#		print "\t$key \n";			
-	#	}
-	# }
+		if ( $parent eq $startparent )
+		{
+			push(@{$newitemorder}, $gid);
+			my $parent = $gid;
+			get_children($allitems, $parent, $newitemorder);	# recursive!
+		}
+	}
 }
 
-######################################################
-# Filling content into the script
-######################################################
+########################################################
+# Module and Directory have to be in the correct order
+# in the setup script. This is an requirement by the
+# old setup
+########################################################
 
-sub put_oneitem_into_script
+sub create_treestructure
 {
-	my ( $script, $item, $itemhash, $itemkey ) = @_;
+	my ($item, $allitems) = @_;
+
+	my @itemorder = ();
 	
-	push(@{$script}, "$item $itemkey\n" );
-	my $content = "";
-	foreach $content (sort keys %{$itemhash->{$itemkey}}) { push(@{$script}, "\t$content = $itemhash->{$itemkey}->{$content};\n" ); }
-	push(@{$script}, "End\n" );
-	push(@{$script}, "\n" );
+	my @startparents = ();
+
+	if ( $item eq "Module" ) { push(@startparents, ""); }
+	if ( $item eq "Directory" )
+	{
+		push(@startparents, "PREDEFINED_PROGDIR");
+		push(@startparents, "PREDEFINED_KDEHOME");
+		push(@startparents, "PREDEFINED_HOMEDIR");
+	}
+
+	for ( my $i = 0; $i <= $#startparents; $i++ )	# if there is more than one toplevel item
+	{
+		get_children($allitems, $startparents[$i], \@itemorder);
+	}
+	
+	return \@itemorder;
 }
 
-######################################################
-# Creating the script
-######################################################
+########################################################
+# Creating the item collector for Module and
+# Directory in the new sorted order
+########################################################
 
-sub create_script
+sub create_sorted_itemcollector
 {
-	my @script = ();
-	my $oneitem;
+	my ($newitemorder, $collector, $oneitem) = @_;
+
+	@newitemcollector = ();
 	
-	foreach $oneitem ( @par2script::globals::allitems )
+	for ( my $i = 0; $i <= $#{$newitemorder}; $i++ )
 	{
-		if ( exists($par2script::globals::definitions{$oneitem}) )
+		my $gid = ${$newitemorder}[$i];
+		
+		for ( my $j = 0; $j <= $#{$collector}; $j++ )
 		{
-			if ( $oneitem eq "Shortcut" ) { next; } # "Shortcuts" after "Files"
+			my $line = ${$collector}[$j];
+			
+			if ( $line =~ /^\s*$oneitem\s+$gid\s*$/ )
+			{
+				$include = 1;	
+			}
+
+			if ( $include )
+			{
+				push(@newitemcollector, $line);	
+			}
+			
+			if (($include) && ( $line =~ /^\s*End\s*$/i ))
+			{
+				$include = 0;
+				push(@newitemcollector, "\n");	# empty line at the end	
+				last;
+			}
+		}	
+	}
+		
+	return \@newitemcollector;
+}
+
+############################################
+# Every gid has to defined only once
+# in the par files
+############################################
+
+sub test_of_gid_uniqueness
+{
+	my ($allitems) = @_;
+
+	my @allgids = ();
+
+	for ( my $i = 0; $i <= $#{$allitems}; $i++ )
+	{
+		my $gid = ${$allitems}[$i];
+		
+		if (! par2script::existence::exists_in_array($gid, \@allgids))
+		{
+			push(@allgids, $gid);
+		}
+		else
+		{
+			$par2script::globals::multidefinitionerror = 1;
+			push(@par2script::globals::multidefinitiongids, $gid);
+		}
+	}	
+}
 
-			if (( $oneitem eq "Module" ) || ( $oneitem eq "Directory" )) { write_sorted_items(\@script, $oneitem); }
-			else { write_unsorted_items(\@script, $oneitem); }
+############################################
+# gids must not cotain hyphens
+############################################
+
+sub test_of_hyphen
+{
+	my ($allitems) = @_;
+
+	for ( my $i = 0; $i <= $#{$allitems}; $i++ )
+	{
+		my $gid = ${$allitems}[$i];
+		
+		if ( $gid =~ /\-/ )
+		{
+			par2script::exiter::exit_program("ERROR: No hyphen allowed in global id: $gid", "test_of_hyphen");
 		}
+	}	
+}
+
+######################################################
+# This function exists for compatibility reasons:
+# In scp the string "DosName" is used, in the 
+# created script this is "HostName"
+######################################################
+
+sub convert_dosname_to_hostname
+{
+	my ($collector) = @_;
+
+	for ( my $i = 0; $i <= $#{$collector}; $i++ )
+	{
+		${$collector}[$i] =~ s/\bDosName\b/HostName/;
 	}
+}
+
+###########################################################
+# This function exists for compatibility reasons:
+# In scp the string "PD_PROGDIR" is often used, in the 
+# created script this is "PREDEFINED_PROGDIR"
+###########################################################
+
+sub convert_pdprogdir_to_predefinedprogdir
+{
+	my ($collector) = @_;
 
-	return \@script;	
+	for ( my $i = 0; $i <= $#{$collector}; $i++ )
+	{
+		${$collector}[$i] =~ s/\bPD_PROGDIR\b/PREDEFINED_PROGDIR/;		
+	}
 }
 
 ######################################################
-# Adding script content for the unsorted items
+# Single styles are in scp sometimes defined as:
+# "Styles = cfg_string;". This has to be replaced
+# in the script to
+# "Styles = (cfg_string);"
 ######################################################
 
-sub write_unsorted_items
+sub setting_brackets_around_single_styles
 {
-	my ( $script, $oneitem ) = @_;
-	
-	my $itemhash = $par2script::globals::definitions{$oneitem};
+	my ($collector) = @_;
 
-	my $itemkey = "";
-	foreach $itemkey (sort keys %{$itemhash})
+	for ( my $i = 0; $i <= $#{$collector}; $i++ )
 	{
-		put_oneitem_into_script($script, $oneitem, $itemhash, $itemkey);
-			
-		# special handling for Shortcuts after Files
-		if (( $oneitem eq "File" ) && ( exists($par2script::globals::definitions{"Shortcut"}) ))
+		if ( ${$collector}[$i] =~ /^(\s*styles\s*\=\s*)(\w+)(\s*\;\s*)$/i )
 		{
-			my $shortcutkey;
-			foreach $shortcutkey ( keys %{$par2script::globals::definitions{"Shortcut"}} )
-			{
-				if ( $par2script::globals::definitions{"Shortcut"}->{$shortcutkey}->{'FileID'} eq $itemkey )
-				{
-					put_oneitem_into_script($script, "Shortcut", $par2script::globals::definitions{"Shortcut"}, $shortcutkey);
-
-					# and Shortcut to Shortcut also
-					my $internshortcutkey;
-					foreach $internshortcutkey ( keys %{$par2script::globals::definitions{"Shortcut"}} )
-					{
-						if ( $par2script::globals::definitions{"Shortcut"}->{$internshortcutkey}->{'ShortcutID'} eq $shortcutkey )
-						{
-							put_oneitem_into_script($script, "Shortcut", $par2script::globals::definitions{"Shortcut"}, $internshortcutkey);
-						}
-					}
-				}
-			}
+			my $start = $1;
+			my $styles = $2;
+			my $end = $3;
+			
+			my $newline = $start . "\(" . $styles . "\)" . $end; 
+			${$collector}[$i] = $newline;
 		}
 	}
 }
 
 ######################################################
-# Collecting all children of a specified parent
+# The scpzip and the setup require a script version
+# in the Installation object. This has to be included
+# for compatibility reasons. It will always be:
+# "ScriptVersion = 100;"
 ######################################################
 
-sub collect_children
+sub set_scriptversion_into_installation_object
 {
-	my ( $itemhash, $parent, $order ) = @_;
+	my ($collector) = @_;
+
+	my $newline = "\tScriptVersion = 100\;\n";
 	
-	my $item;
-	foreach $item ( keys %{$itemhash} )
+	# determining the last line
+
+	my $lastline;
+		
+	for ( my $i = 0; $i <= $#{$collector}; $i++ )
 	{
-		if ( $itemhash->{$item}->{'ParentID'} eq $parent )
+		if ( ${$collector}[$i] =~ /^\s*End\s*$/i )
 		{
-			push(@{$order}, $item);
-			my $newparent = $item;
-			collect_children($itemhash, $newparent, $order);
-		}	
+			$lastline = $i;
+			last;
+		}
 	}
+	
+	splice(@{$collector}, $lastline, 0, $newline);
+	
 }
 
-######################################################
-# Adding script content for the sorted items
-######################################################
+############################################
+# transferring the par file content
+# into the script file
+############################################
 
-sub write_sorted_items
+sub collect_all_items
 {
-	my ( $script, $oneitem ) = @_;
+	my ($parfile) = @_;
+	
+	my @setupscript = ();
+	my $setupscript = \@setupscript;
 	
-	my $itemhash = $par2script::globals::definitions{$oneitem};
+	for ( my $i = 0; $i <= $#par2script::globals::allitems; $i++ )
+	{
+		my $oneitem = $par2script::globals::allitems[$i];
 
-	my @itemorder = ();
-	my @startparents = ();
+		my @itemcollector = ();
+		my $itemcollector = \@itemcollector;
+
+		put_item_into_collector($oneitem, $parfile, $itemcollector);
 
-	if ( $oneitem eq "Module" ) { push(@startparents, ""); }
-	elsif ( $oneitem eq "Directory" ) { push(@startparents, "PREDEFINED_PROGDIR"); }
-	else { die "ERROR: No root parent defined for item type $oneitem !\n"; }
-
-	# supporting more than one toplevel item
-	my $parent;
-	foreach $parent ( @startparents ) { collect_children($itemhash, $parent, \@itemorder); }
+		# testing uniqueness of each gid
+
+		my $allgids = get_all_gids_from_script($itemcollector, $oneitem);
 	
-	my $itemkey;
-	foreach $itemkey ( @itemorder ) { put_oneitem_into_script($script, $oneitem, $itemhash, $itemkey); }
+		test_of_gid_uniqueness($allgids);
+
+		test_of_hyphen($allgids);
+		
+		# renaming at directories "DosName" to "HostName" and "PD_PROGDIR" to "PREDEFINED_PROGDIR" (only for compatibility reasons)
+		if ( $oneitem eq "Directory" ) { convert_dosname_to_hostname($itemcollector); }
+		if (( $oneitem eq "Directory" ) || ( $oneitem eq "File" )) { convert_pdprogdir_to_predefinedprogdir($itemcollector); }
+		
+		# sorting directories and modules (modules are also oneliner after pre2par!)
+		
+		if (( $oneitem eq "Module" ) || ( $oneitem eq "Directory" ))
+		{
+			my $allitems = get_all_items_from_script($itemcollector, $oneitem);
+			$newitemorder = create_treestructure($oneitem, $allitems);
+			$itemcollector = create_sorted_itemcollector($newitemorder, $itemcollector, $oneitem);
+		}
+
+		# setting brackets around single styles: "styles = cfg_string;" -> "styles = (cfg_string);"
+
+		setting_brackets_around_single_styles($itemcollector);
+		
+		# Installation objects need to get the script version (only for compatibility reasons)
+		
+		if ( $oneitem eq "Installation" ) { set_scriptversion_into_installation_object($itemcollector); }
+		
+		# putting the collector content into the setup script
+		
+		put_item_into_script($setupscript, $itemcollector);
+			
+	}
+
+	if ( $par2script::globals::multidefinitionerror ) {	par2script::exiter::multidefinitionerror(); }
+	
+	return $setupscript;
 }
 
-#######################################################################
-# Collecting all assigned gids of the type "item" from the modules
-# in the par files. Using a hash!
-#######################################################################
+############################################
+# Returning a complete definition block
+# from the script
+############################################
 
-sub collect_assigned_gids
+sub get_definitionblock_from_script
 {
-	my $allmodules = $par2script::globals::definitions{'Module'};
+	my ($script, $gid) = @_;	
 
-	my $item;	
-	foreach $item ( @par2script::globals::items_assigned_at_modules )
-	{		
-		if ( ! exists($par2script::globals::searchkeys{$item}) ) { par2script::exiter::exit_program("ERROR: Unknown type \"$item\" at modules.", "collect_assigned_gids"); }
+	my @codeblock = ();
+	my $startline = -1;
 
-		my $searchkey = $par2script::globals::searchkeys{$item};
-		
-		my %assignitems = ();
-		my $modulegid = "";
+	for ( my $i = 0; $i <= $#{$script}; $i++ )
+	{
+		if ( ${$script}[$i] =~ /^\s*\w+\s+$gid\s*$/ )
+		{
+			$startline = $i;
+			last;	
+		}
+	}
+	
+	if ( $startline != -1 )
+	{
+		while (! ( ${$script}[$startline] =~ /^\s*End\s*$/i ) )
+		{
+			push(@codeblock, ${$script}[$startline]);
+			$startline++;
+		}
+
+		push(@codeblock, ${$script}[$startline]);
+	}
+	
+	return \@codeblock;
+}
+
+############################################
+# Adding a complete definition block
+# into the script
+############################################
+
+sub add_definitionblock_into_script
+{
+	my ($script, $newblock, $gid) = @_;	
+	
+	# adding the new block behind the block defined by $gid
+	
+	my $insertline = -1;
+	my $count = 0; 
+	
+	for ( my $i = 0; $i <= $#{$script}; $i++ )
+	{
+		if ( ${$script}[$i] =~ /^\s*\w+\s+$gid\s*$/ ) 
+		{
+			$count = 1;
+		}
 		
-		foreach $modulegid (keys %{$allmodules} )
+		if (( $count ) && ( ${$script}[$i] =~ /^\s*End\s*$/i ))
 		{
-			# print "Module $modulegid\n";
-			# my $content = "";
-			# foreach $content (sort keys %{$allmodules->{$modulegid}}) { print "\t$content = $allmodules->{$modulegid}->{$content};\n"; }
-			# print "End\n";
-			# print "\n";
-						
-			if ( exists($allmodules->{$modulegid}->{$searchkey}) )
-			{
-				my $list = $allmodules->{$modulegid}->{$searchkey};
-				if ( $list =~ /^\s*\((.*?)\)\s*(.*?)\s*$/ ) { $list = $1; }
-				else { par2script::exiter::exit_program("ERROR: Invalid module list: $list", "collect_assigned_gids"); }
-				my $allassigneditems = par2script::converter::convert_stringlist_into_array_2($list, ",");
+			$insertline = $i;
+			last;			
+		}
+	}
 
-				my $gid;
-				foreach $gid ( @{$allassigneditems} )
-				{
-					if ( exists($assignitems{$gid}) ) { $assignitems{$gid} = $assignitems{$gid} + 1; }
-					else { $assignitems{$gid} = 1; }
-				}				
-			}
+	if ( $insertline != -1 )
+	{
+		$insertline = $insertline + 2;
+		# inserting an empty line at the end of the block if required	
+		if (!(${$newblock}[$#{$newblock}] =~ /^\s*$/)) { push(@{$newblock}, "\n"); }
+		# inserting the new block
+		splice( @{$script}, $insertline, 0, @{$newblock} );
+	}
+	else
+	{
+		die "ERROR: Could not include definition block. Found no definition of $gid!\n"; 	
+	}
+	
+}
+
+############################################
+# Removing a complete definition block
+# from the script
+############################################
+
+sub remove_definitionblock_from_script
+{
+	my ($script, $gid) = @_;	
+
+	my $startline = -1;
+	
+	for ( my $i = 0; $i <= $#{$script}; $i++ )
+	{
+		if ( ${$script}[$i] =~ /^\s*\w+\s+$gid\s*$/i )
+		{
+			$startline = $i;
+			last;	
 		}
+	}
+
+	if ( $startline != -1 )
+	{
+		my $endline = $startline;
 		
-		$par2script::globals::assignedgids{$item} = \%assignitems;
-	}	
+		while (! ( ${$script}[$endline] =~ /^\s*End\s*$/i ) )
+		{
+			$endline++;
+		}
+
+		my $blocklength = $endline - $startline + 2;	# "+2" because of endline and emptyline
+		splice(@{$script}, $startline, $blocklength);
+	}
+}
+
+############################################
+# Returning the value for a given key
+# from a definition block
+############################################
+
+sub get_value_from_definitionblock
+{
+	my ($block, $key) = @_;	
+
+	my $value = "";
+
+	for ( my $i = 0; $i <= $#{$block}; $i++ )
+	{
+		if ( ${$block}[$i] =~ /^\s*$key\s*\=\s*(.*?)\s*$/ )
+		{
+			$value = $1;
+			last;	
+		}
+	}
+
+	par2script::remover::remove_leading_and_ending_whitespaces(\$value);
+	$value =~ s/\;\s*$//;	# removing ending semicolons
+
+	return $value;
 }
 
 ##################################################
@@ -409,16 +699,167 @@
 	my ($parfiles) = @_;
 
 	my @parfilecontent = ();
-	my $parfilename;
-
-	foreach $parfilename ( @{$parfiles} )
+	
+	for ( my $i = 0; $i <= $#{$parfiles}; $i++ )
 	{
-		my $parfile = par2script::files::read_file($parfilename);
-		foreach ( @{$parfile} ) { push(@parfilecontent, $_); }
+		my $parfile = par2script::files::read_file(${$parfiles}[$i]);
+		add_array_into_array(\@parfilecontent, $parfile);
 		push(@parfilecontent, "\n");
 	}
 
 	return \@parfilecontent;	
 }
 
+##########################################################
+# Add the content of an array to another array 
+##########################################################
+
+sub add_array_into_array
+{
+	my ($basearray, $newarray) = @_;
+		
+	for ( my $i = 0; $i <= $#{$newarray}; $i++ )
+	{	
+		push(@{$basearray}, ${$newarray}[$i]);
+	}
+}
+
+##########################################################
+# Collecting all subdirectories of a specified directory 
+##########################################################
+
+sub collect_subdirectories
+{
+	my ($parfile, $directorygid, $collector) = @_;
+
+	my $isdirectory = 0;
+	my $currentgid = "";
+	
+	for ( my $i = 0; $i <= $#{$parfile}; $i++ )
+	{	
+		my $oneline = ${$parfile}[$i];
+		
+		if ( $oneline =~ /^\s*Directory\s+(\w+)\s*$/ )
+		{
+			$currentgid = $1;
+			$isdirectory = 1;
+		}
+		
+		if (( $isdirectory ) && ( $oneline =~ /^\s*End\s*$/ )) { $isdirectory = 0; }
+			
+		if ( $isdirectory )
+		{
+			if ( $oneline =~ /^\s*ParentID\s*=\s*(\w+)\s*\;\s*$/ )
+			{
+				my $parentgid = $1;
+				
+				if ( $parentgid eq $directorygid )
+				{
+					# Found a child of the directory, that shall be removed
+
+					my %removeitem = ();
+					my $item = "Directory";
+					$removeitem{'gid'} = $currentgid;
+					$removeitem{'item'} = $item;
+					
+					push(@{$collector}, \%removeitem);
+					
+					# recursively checking additional children
+					collect_subdirectories($parfile, $currentgid, $collector);
+				}
+			}
+		}
+	}
+}
+
+##########################################################
+# Collecting all items (Files and Shortcuts), that
+# are located in the list of directories. 
+##########################################################
+
+sub get_all_items_in_directories
+{
+	my ($parfile, $directorygid, $item, $collector) = @_;
+
+	my $isitem = 0;
+	my $currentgid = "";
+	
+	for ( my $i = 0; $i <= $#{$parfile}; $i++ )
+	{	
+		my $oneline = ${$parfile}[$i];
+		
+		if ( $oneline =~ /^\s*\Q$item\E\s+(\w+)\s*$/ )
+		{
+			$currentgid = $1;
+			$isitem = 1;
+		}
+		
+		if (( $isitem ) && ( $oneline =~ /^\s*End\s*$/ )) { $isitem = 0; }
+			
+		if ( $isitem )
+		{
+			if ( $oneline =~ /^\s*Dir\s*=\s*(\w+)\s*\;\s*$/ )
+			{
+				my $installdir = $1;
+				
+				if ( $installdir eq $directorygid )
+				{
+					# Found an item, that shall be installed in the specific directory
+
+					my %removeitem = ();
+					$removeitem{'gid'} = $currentgid;
+					$removeitem{'item'} = $item;
+
+					push(@{$collector}, \%removeitem);
+				}
+			}
+		}
+	}	
+}
+
+##########################################################
+# Collecting all items (ProfileItems), that
+# are located in the list of Profiles. 
+##########################################################
+
+sub get_all_items_in_profile
+{
+	my ($parfile, $profilegid, $item, $collector) = @_;
+
+	my $isitem = 0;
+	my $currentgid = "";
+	
+	for ( my $i = 0; $i <= $#{$parfile}; $i++ )
+	{	
+		my $oneline = ${$parfile}[$i];
+		
+		if ( $oneline =~ /^\s*\Q$item\E\s+(\w+)\s*$/ )
+		{
+			$currentgid = $1;
+			$isitem = 1;
+		}
+		
+		if (( $isitem ) && ( $oneline =~ /^\s*End\s*$/ )) { $isitem = 0; }
+			
+		if ( $isitem )
+		{
+			if ( $oneline =~ /^\s*ProfileID\s*=\s*(\w+)\s*\;\s*$/ )
+			{
+				my $profilename = $1;
+				
+				if ( $profilename eq $profilegid )
+				{
+					# Found an item, that shall be installed in the specific directory
+
+					my %removeitem = ();
+					$removeitem{'gid'} = $currentgid;
+					$removeitem{'item'} = $item;
+
+					push(@{$collector}, \%removeitem);
+				}
+			}
+		}
+	}	
+}
+
 1;
diff -ru -x CVS -x '*.orig' solenv.bak/bin/modules/pre2par/globals.pm solenv/bin/modules/pre2par/globals.pm
--- solenv.bak/bin/modules/pre2par/globals.pm	2007-11-23 14:35:13.000000000 +0100
+++ solenv/bin/modules/pre2par/globals.pm	2008-03-31 14:09:36.489838400 +0200
@@ -4,9 +4,9 @@
 #
 #   $RCSfile: globals.pm,v $
 #
-#   $Revision: 1.12 $
+#   $Revision: 1.11 $
 #
-#   last change: $Author: ihi $ $Date: 2007/11/23 13:35:13 $
+#   last change: $Author: ihi $ $Date: 2007/07/12 11:17:41 $
 #
 #   The Contents of this file are made available subject to
 #   the terms of GNU Lesser General Public License Version 2.1.
@@ -50,8 +50,7 @@
 
 	@allitems = ("Installation", "ScpAction", "HelpText", "Directory", "DataCarrier", "StarRegistry", "File",
 				 "Shortcut", "Custom", "Unixlink", "Procedure", "Module", "Profile", "ProfileItem",
-				 "Folder", "FolderItem", "RegistryItem", "StarRegistryItem", "WindowsCustomAction",
-				 "MergeModule");
+				 "Folder", "FolderItem", "RegistryItem", "StarRegistryItem", "WindowsCustomAction");
 
     $logging     = 0;
 	$logfilename = "logfile.log";	# the default logfile name for global errors
