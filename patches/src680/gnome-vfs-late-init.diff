diff --git a/desktop/source/app/appinit.cxx b/desktop/source/app/appinit.cxx
index e8e06b6..6c231fa 100644
--- desktop/source/app/appinit.cxx
+++ desktop/source/app/appinit.cxx
@@ -213,7 +213,6 @@ static bool configureUcb(bool bServer, rtl::OUString const & rPortalConnect)
                 {
                     Reference<XContentProviderManager> xCPM =
                         cb->getContentProviderManagerInterface();
-#if 0
 
                     Reference<XContentProviderFactory> xCPF(
                         xServiceFactory->createInstance(
@@ -229,24 +228,6 @@ static bool configureUcb(bool bServer, rtl::OUString const & rPortalConnect)
                             ),
                             rtl::OUString::createFromAscii(".*"),
                             false);
-#else
-
-		    // Workaround for P1 #124597#.  Instanciate GNOME-VFS-UCP in the thread that initialized
- 		    // GNOME in order to avoid a deadlock that may occure in case UCP gets initialized from
-		    // a different thread. The latter may happen when calling the Office remotely via UNO.  
-		    // THIS IS NOT A FIX, JUST A WORKAROUND!
-
-                    Reference<XContentProvider> xCP(
-                        xServiceFactory->createInstance(
-                            rtl::OUString::createFromAscii(
-                                "com.sun.star.ucb.GnomeVFSContentProvider")),
-                        UNO_QUERY);
-                    if(xCP.is())
-                        xCPM->registerContentProvider(
-                            xCP,
-                            rtl::OUString::createFromAscii(".*"),
-                            false);
-#endif
                 }
             }
         } catch (RuntimeException e) {
diff --git a/ucb/source/ucp/gvfs/makefile.mk b/ucb/source/ucp/gvfs/makefile.mk
index b071745..074a9fa 100644
--- ucb/source/ucp/gvfs/makefile.mk
+++ ucb/source/ucp/gvfs/makefile.mk
@@ -88,6 +88,7 @@ SHL1STDLIBS=\
 	$(CPPULIB) \
 	$(SALLIB)  \
 	$(SALHELPERLIB)  \
+	$(VCLLIB)  \
 	$(UCBHELPERLIB)
 
 SHL1STDLIBS+=$(PKGCONFIG_LIBS)
diff --git a/ucb/source/ucp/gvfs/provider.cxx b/ucb/source/ucp/gvfs/provider.cxx
index 99cbb9e..12430a5 100644
--- ucb/source/ucp/gvfs/provider.cxx
+++ ucb/source/ucp/gvfs/provider.cxx
@@ -37,6 +37,9 @@
 #include "precompiled_ucb.hxx"
 
 #include <ucbhelper/contentidentifier.hxx>
+#include <osl/mutex.hxx>
+#include <vcl/svapp.hxx>
+
 #include <libgnomevfs/gnome-vfs-init.h>
 #include "provider.hxx"
 #include "content.hxx"
@@ -202,6 +205,55 @@ component_writeInfo( void */*pServiceManager*/,
 			   ::gvfs::ContentProvider::getImplementationName_Static(),
 			   ::gvfs::ContentProvider::getSupportedServiceNames_Static() );
 }
+
+/* This class is here to be able to initialize gnome-vfs in the main thread */
+class GnomeVFSInitializator
+{
+private:
+    osl::Mutex m_aLock;
+    bool m_bInitialized;
+
+public:
+    GnomeVFSInitializator() : m_bInitialized( false ) {}
+
+    void init()
+    {
+        Application::PostUserEvent( LINK( this, GnomeVFSInitializator, ImplInitializeGnomeVFS ) );
+
+        // cannot use a condition variable here, leads to a deadlock
+        while (1)
+        {
+            {
+                osl::MutexGuard aGuard( m_aLock );
+                if ( m_bInitialized )
+                    break;
+            }
+            Application::Yield();
+        }
+    }
+
+private:
+    DECL_LINK( ImplInitializeGnomeVFS, void* );
+};
+
+IMPL_LINK( GnomeVFSInitializator, ImplInitializeGnomeVFS, void*, EMPTYARG )
+{
+    osl::MutexGuard aGuard( osl::Mutex::getGlobalMutex() );
+
+    // this must be performed in the same thread where we initialized
+    // Gtk+ (if we did)
+    if ( !gnome_vfs_initialized () )
+        gnome_vfs_init ();
+    if ( !auth_queue )
+        auth_queue = g_private_new( auth_queue_destroy );
+
+    m_aLock.acquire();
+    m_bInitialized = true;
+    m_aLock.release();
+
+    return 0;
+}
+
 extern "C" void * SAL_CALL
 component_getFactory( const sal_Char *pImplName,
 		      void           *pServiceManager,
@@ -209,13 +261,8 @@ component_getFactory( const sal_Char *pImplName,
 {
 	void * pRet = 0;
 
-	{
-		osl::Guard< osl::Mutex > aGuard( osl::Mutex::getGlobalMutex() );
-		if (!gnome_vfs_initialized ())
-			gnome_vfs_init ();
-		if (!auth_queue)
-			auth_queue = g_private_new( auth_queue_destroy );
-	}
+	GnomeVFSInitializator aInitializator;
+	aInitializator.init();
 
 	uno::Reference< lang::XMultiServiceFactory > xSMgr
 		(reinterpret_cast< lang::XMultiServiceFactory * >( pServiceManager ) );
