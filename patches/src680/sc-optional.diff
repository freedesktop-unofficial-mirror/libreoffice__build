Only in sc/inc: address.hxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/inc/cell.hxx sc/inc/cell.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/inc/cell.hxx	2006-09-22 15:39:57.000000000 +0100
+++ sc/inc/cell.hxx	2006-09-23 21:38:35.000000000 +0100
@@ -279,6 +279,9 @@
                         SCITP_CLOSE_ITERATION_CIRCLE
                     };
 	void			InterpretTail( ScInterpretTailParameter );
+	void            DoEnglishCompile( rtl::OUStringBuffer &rBuffer,
+									  const ScAddress &rPos,
+									  BOOL bCompileXML ) const;
 
 public:
 
Only in sc/inc: cell.hxx~
Only in sc/inc: compiler.hxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/data/cell2.cxx sc/source/core/data/cell2.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/data/cell2.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/data/cell2.cxx	2006-09-28 21:30:26.000000000 +0100
@@ -245,59 +245,34 @@
 void ScFormulaCell::GetEnglishFormula( String& rFormula, BOOL bCompileXML,
 									   ScAddress::Convention conv ) const
 {
-    //! mit GetFormula zusammenfassen !!!
+	rtl::OUStringBuffer rBuffer( rFormula );
+	GetEnglishFormula( rBuffer, bCompileXML, conv );
+	rFormula = rBuffer;
+}
+
+static bool          NeedsPofRewrite( ScTokenArray *pCode );
+static ScTokenArray *ReWriteMissingToPof( ScTokenArray *pCode );
+
+void ScFormulaCell::DoEnglishCompile( rtl::OUStringBuffer &rBuffer,
+									  const ScAddress &rPos, 
+									  BOOL bCompileXML ) const
+{
+	ScTokenArray *pCompileCode = pCode;
+	if (bCompileXML)
+	{
+		 /* Scan pCode [ token array ! ] for missing args &
+			re-write if present */
+		if ( NeedsPofRewrite( pCode ) )
+			pCompileCode = ReWriteMissingToPof( pCode );
+	}
+
+	ScCompiler aComp( pDocument, rPos, *pCompileCode );
+	aComp.SetCompileEnglish( TRUE );
+	aComp.SetCompileXML( bCompileXML );
+	aComp.CreateStringFromTokenArray( rBuffer );
 
-    if( pCode->GetError() && !pCode->GetLen() )
-    {
-        rFormula = ScGlobal::GetErrorString( pCode->GetError() ); return;
-    }
-    else if( cMatrixFlag == MM_REFERENCE )
-    {
-        // Referenz auf eine andere Zelle, die eine Matrixformel enthaelt
-        pCode->Reset();
-        ScToken* p = pCode->GetNextReferenceRPN();
-        if( p )
-        {
-            ScBaseCell* pCell;
-            SingleRefData& rRef = p->GetSingleRef();
-            rRef.CalcAbsIfRel( aPos );
-            if ( rRef.Valid() )
-                pCell = pDocument->GetCell( ScAddress( rRef.nCol,
-                    rRef.nRow, rRef.nTab ) );
-            else
-                pCell = NULL;
-            if (pCell && pCell->GetCellType() == CELLTYPE_FORMULA)
-            {
-                ((ScFormulaCell*)pCell)->GetEnglishFormula(rFormula, bCompileXML, conv);
-                return;
-            }
-            else
-            {
-                ScCompiler aComp( pDocument, aPos, *pCode );
-                aComp.SetCompileEnglish( TRUE );
-                aComp.SetCompileXML( bCompileXML );
-                aComp.CreateStringFromTokenArray( rFormula );
-            }
-        }
-        else
-        {
-            DBG_ERROR("ScFormulaCell::GetEnglishFormula: Keine Matrix");
-        }
-    }
-    else
-    {
-        ScCompiler aComp( pDocument, aPos, *pCode );
-        aComp.SetCompileEnglish( TRUE );
-        aComp.SetCompileXML( bCompileXML );
-        aComp.CreateStringFromTokenArray( rFormula );
-    }
-
-    rFormula.Insert( '=',0 );
-    if( cMatrixFlag )
-    {
-        rFormula.Insert('{', 0);
-        rFormula += '}';
-    }
+	if ( pCompileCode != pCode )
+		delete pCompileCode;
 }
 
 void ScFormulaCell::GetEnglishFormula( rtl::OUStringBuffer& rBuffer, BOOL bCompileXML,
@@ -330,12 +305,7 @@
                 return;
             }
             else
-            {
-                ScCompiler aComp( pDocument, aPos, *pCode );
-                aComp.SetCompileEnglish( TRUE );
-                aComp.SetCompileXML( bCompileXML );
-                aComp.CreateStringFromTokenArray( rBuffer );
-            }
+				DoEnglishCompile( rBuffer, aPos, bCompileXML );
         }
         else
         {
@@ -343,12 +313,7 @@
         }
     }
     else
-    {
-        ScCompiler aComp( pDocument, aPos, *pCode );
-        aComp.SetCompileEnglish( TRUE );
-        aComp.SetCompileXML( bCompileXML );
-        aComp.CreateStringFromTokenArray( rBuffer );
-    }
+		DoEnglishCompile( rBuffer, aPos, bCompileXML );
 
     sal_Unicode ch('=');
     rBuffer.insert( 0, &ch, 1 );
@@ -1555,6 +1520,172 @@
 }
 
 
+// ---- Move me to a more sensible place ----
+// a more sensible place would prolly be (with a little
+// re-factoring) the ScCompiler constructor [ which should
+// take an 'Convention' on which this code lives as a
+// virtual method (?)
 
 
+static void DumpTokArr( ScTokenArray *pCode )
+{
+	fprintf (stderr, "TokenArr: ");
+	for ( ScToken *pCur = pCode->First(); pCur; pCur = pCode->Next() )
+		fprintf( stderr, "t%d,o%d ",
+				 pCur->GetType(), pCur->GetOpCode() );
+	fprintf (stderr, "\n");
+}
+
+/*
+ * Determines if this formula needs any changes to convert it to
+ * something previous versions of OO.o could consume.
+ */
+static bool NeedsPofRewrite( ScTokenArray *pCode )
+{
+	for ( ScToken *pCur = pCode->First(); pCur; pCur = pCode->Next() )
+		if (pCur->GetOpCode() == ocMissing ||
+			pCur->GetOpCode() == ocLog)
+			return true;
+	return false;
+}
+
+struct MissingContext {
+		ScToken *pFunc;
+		int      nCurArg;
+};
+
+#define DEFAULT_ARG(arr,n,d) \
+		if (rCtx.nCurArg == (n)) \
+		{ \
+			(arr)->AddDouble( d ); \
+			return true; \
+		}
+
+static bool AddMissingExternal( const MissingContext &rCtx, ScTokenArray *pNewArr )
+{
+	const String &rName = rCtx.pFunc->GetExternal();
+
+	// initial (fast) check:
+	sal_Unicode nLastChar = rName.GetChar( rName.Len() - 1);
+	if ( nLastChar != 't' && nLastChar != 'm' )
+		return false;
+
+	if (rName.EqualsIgnoreCaseAscii(
+			"com.sun.star.sheet.addin.Analysis.getAccrint" ))
+	{
+		DEFAULT_ARG( pNewArr, 4, 1000.0 );
+	}
+	if (rName.EqualsIgnoreCaseAscii(
+			"com.sun.star.sheet.addin.Analysis.getAccrintm" ))
+	{
+		DEFAULT_ARG( pNewArr, 3, 1000.0 );
+	}
+// FIXME: when we implement EUROCONVERT
+//	if (rName.EqualsIgnoreCaseAscii( "EUROCONVERT" ))
+//		DEFAULT_ARG( pNewArr, 3, 0.0 );
+}
+
+static bool AddMissing( const MissingContext &rCtx,
+						ScTokenArray *pNewArr )
+{
+	if ( !rCtx.pFunc )
+		return false;
+
+	switch ( rCtx.pFunc->GetOpCode() ) 
+	{
+	case ocFixed:
+		DEFAULT_ARG( pNewArr, 1, 2.0 );
+		break;
+	case ocBetaDist:
+	case ocBetaInv:
+	case ocRMZ:  // PMT 
+		DEFAULT_ARG( pNewArr, 3, 0.0 );
+		break;
+	case ocZinsZ: // IPMT
+	case ocKapz:  // PPMT
+		DEFAULT_ARG( pNewArr, 4, 0.0 );
+		break;
+	case ocBW: // PV
+	case ocZW: // FV
+		DEFAULT_ARG( pNewArr, 2, 0.0 ); // pmt
+		DEFAULT_ARG( pNewArr, 3, 0.0 ); // [fp]v
+		break;
+	case ocZins: // RATE
+		DEFAULT_ARG( pNewArr, 1, 0.0 ); // pmt
+		DEFAULT_ARG( pNewArr, 3, 0.0 ); // fv
+		DEFAULT_ARG( pNewArr, 4, 0.0 ); // type
+		break;
+	case ocExternal:
+		return AddMissingExternal( rCtx, pNewArr );
+		break;
+
+	// --- more complex cases ---
+
+	case ocOffset:
+		// FIXME: rather tough.
+		// if arg 3 (height) ommitted, export arg1 (rows)
+		break;
+	case ocAdress:
+		// FIXME - should we adjust 'ADDRESS_XL(?)' at this point?
+		// (arg 4 -> 'TRUE' ? [ or no arg. 4 ;-] )
+		break;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static void AddMoreArgs( const MissingContext &rCtx,
+						 ScTokenArray *pNewArr )
+{
+	if ( !rCtx.pFunc )
+		return;
+
+	// Log
+	if ( rCtx.pFunc->GetOpCode() == ocLog &&
+		 rCtx.nCurArg < 1 )
+	{
+		pNewArr->AddOpCode( ocSep );
+		pNewArr->AddDouble( 10.0 );
+	}
+}
+
+#undef EXPECT
+
+static ScTokenArray *ReWriteMissingToPof( ScTokenArray *pCode )
+{
+	MissingContext aCtx[ pCode->GetLen() ];
+	int nFn = -1;
+
+	ScTokenArray *pNewArr = new ScTokenArray();
+
+	for ( ScToken *pCur = pCode->First(); pCur;
+		  pCur = pCode->NextNoSpaces() )
+	{
+		bool bAdd = true;
+		switch ( pCur->GetOpCode() )
+		{
+			case ocOpen:
+				aCtx[ ++nFn ].pFunc = pCode->PeekPrevNoSpaces();
+				aCtx[ nFn ].nCurArg = 0;
+				break;
+			case ocClose:
+				AddMoreArgs( aCtx[ nFn ], pNewArr );
+				--nFn;
+				break;
+			case ocSep:
+				aCtx[ nFn ].nCurArg++;
+				break;
+			case ocMissing:
+				bAdd = !AddMissing( aCtx[ nFn ], pNewArr );
+				break;
+			default:
+				break;
+		}
+		if ( bAdd )
+			pNewArr->AddToken( *pCur );
+	}
 
+	return pNewArr;
+}
Only in sc/source/core/data: cell2.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/inc/interpre.hxx sc/source/core/inc/interpre.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/inc/interpre.hxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/inc/interpre.hxx	2006-09-27 11:02:58.000000000 +0100
@@ -269,6 +269,8 @@
 // generiert aus DoubleRef positionsabhaengige SingleRef
 BOOL DoubleRefToPosSingleRef( const ScRange& rRange, ScAddress& rAdr );
 double GetDouble();
+double GetDoubleWithDefault(double nDefault);
+BOOL IsMissing();
 BOOL GetBool() { return GetDouble() != 0.0; }
 const String& GetString();
 // pop matrix and obtain one element, upper left or according to jump matrix
Only in sc/source/core/inc: interpre.hxx~
Only in sc/source/core/tool: addincol.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/compiler.cxx sc/source/core/tool/compiler.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/compiler.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/tool/compiler.cxx	2006-09-28 21:31:56.000000000 +0100
@@ -2096,6 +2096,10 @@
 BOOL ScCompiler::NextNewToken()
 {
     xub_StrLen nSpaces = NextSymbol();
+
+//	fprintf( stderr, "NextNewToken '%s' (?) ",
+//			 rtl::OUStringToOString( cSymbol, RTL_TEXTENCODING_UTF8 ).getStr() );
+
     ScRawToken aToken;
     if( cSymbol[0] )
     {
@@ -2176,6 +2180,8 @@
 ScTokenArray* ScCompiler::CompileString( const String& rFormula,
 										 ScAddress::Convention eConv )
 {
+//	fprintf( stderr, "CompileString '%s'\n",
+//			 rtl::OUStringToOString( rFormula, RTL_TEXTENCODING_UTF8 ).getStr() );
     ScTokenArray aArr;
     pArr = &aArr;
     aFormula = rFormula;
@@ -2226,6 +2232,16 @@
             else
                 nBrackets--;
         }
+		if( eLastOp == ocSep &&
+			pRawToken->GetOpCode() == ocSep )
+		{
+			// FIXME: should we check for known functions with
+			// optional args so the correction dialog can do better ?
+			ScRawToken aMissingToken;
+			aMissingToken.SetOpCode( ocMissing );
+			if ( !pArr->AddToken( aMissingToken ) )
+				SetError(errCodeOverflow); break;
+		}
         if( !pArr->Add( pRawToken->CreateToken() ) )
         {
             SetError(errCodeOverflow); break;
@@ -3117,14 +3136,10 @@
             SetError( errParameterExpected );
         }
         else if ( eOp == ocMissing )
-        {   // #84460# May occur if imported from Xcl.
-            // The real value for missing parameters depends on the function
-            // where it is used, interpreter would have to handle this.
-            // If it does remove this error case here, that could also be the
-            // time to generate ocMissing in between subsequent ocSep.
-            // Xcl import should map missings to values if possible.
-            SetError( errParameterExpected );
-        }
+		{
+			PutCode( pToken );
+			NextToken();
+		}
         else if ( eOp == ocSep )
         {   // Subsequent ocSep
             SetError( errParameterExpected );
Only in sc/source/core/tool: compiler.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr1.cxx sc/source/core/tool/interpr1.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr1.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/tool/interpr1.cxx	2006-09-27 11:39:29.000000000 +0100
@@ -5529,11 +5529,11 @@
 	BYTE nParamCount = GetByte();
 	if ( MustHaveParamCount( nParamCount, 3, 5 ) )
 	{
-		long nColNew, nRowNew, nColPlus, nRowPlus;
+		long nColNew = -1, nRowNew = -1, nColPlus, nRowPlus;
 		if (nParamCount == 5)
 			nColNew = (long) ::rtl::math::approxFloor(GetDouble());
 		if (nParamCount >= 4)
-			nRowNew = (long) ::rtl::math::approxFloor(GetDouble());
+			nRowNew = (long) ::rtl::math::approxFloor(GetDoubleWithDefault( -1.0 ));
 		nColPlus = (long) ::rtl::math::approxFloor(GetDouble());
 		nRowPlus = (long) ::rtl::math::approxFloor(GetDouble());
         SCCOL nCol1;
@@ -5542,8 +5542,7 @@
         SCCOL nCol2;
         SCROW nRow2;
         SCTAB nTab2;
-		if ( (nParamCount == 5 && nColNew == 0)
-		  || (nParamCount >= 4 && nRowNew == 0) )
+		if (nColNew == 0 || nRowNew == 0)
 		{
 			SetIllegalParameter();
 			return;
@@ -5551,7 +5550,7 @@
 		if (GetStackType() == svSingleRef)
 		{
 			PopSingleRef(nCol1, nRow1, nTab1);
-			if (nParamCount == 3)
+			if (nParamCount == 3 || (nColNew < 0 && nRowNew < 0))
 			{
 				nCol1 = (SCCOL)((long) nCol1 + nColPlus);
 				nRow1 = (SCROW)((long) nRow1 + nRowPlus);
@@ -5562,8 +5561,10 @@
 			}
 			else
 			{
-				if (nParamCount == 4)
+				if (nColNew < 0)
 					nColNew = 1;
+				if (nRowNew < 0)
+					nRowNew = 1;
 				nCol1 = (SCCOL)((long)nCol1+nColPlus);		// ! nCol1 wird veraendert!
 				nRow1 = (SCROW)((long)nRow1+nRowPlus);
 				nCol2 = (SCCOL)((long)nCol1+nColNew-1);
@@ -5578,9 +5579,9 @@
 		else if (GetStackType() == svDoubleRef)
 		{
 			PopDoubleRef(nCol1, nRow1, nTab1, nCol2, nRow2, nTab2);
-			if (nParamCount < 5)
+			if (nColNew < 0)
 				nColNew = nCol2 - nCol1 + 1;
-			if (nParamCount < 4)
+			if (nRowNew < 0)
 				nRowNew = nRow2 - nRow1 + 1;
 			nCol1 = (SCCOL)((long)nCol1+nColPlus);
 			nRow1 = (SCROW)((long)nRow1+nRowPlus);
@@ -5926,7 +5927,7 @@
 			bThousand = TRUE;
 		if (nParamCount >= 2)
 		{
-			fDec = ::rtl::math::approxFloor(GetDouble());
+			fDec = ::rtl::math::approxFloor(GetDoubleWithDefault( 2.0 ));
 			if (fDec < -15.0 || fDec > 15.0)
 			{
 				SetIllegalArgument();
Only in sc/source/core/tool: interpr1.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr2.cxx sc/source/core/tool/interpr2.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr2.cxx	2006-09-22 15:39:57.000000000 +0100
+++ sc/source/core/tool/interpr2.cxx	2006-09-28 21:32:07.000000000 +0100
@@ -542,9 +542,14 @@
 
 void ScInterpreter::ScLog()
 {
-	if ( MustHaveParamCount( GetByte(), 2 ) )
+	BYTE nParamCount = GetByte();
+	if ( MustHaveParamCount( nParamCount, 1, 2 ) )
 	{
-		double nBase = GetDouble();
+		double nBase;
+		if (nParamCount == 2)
+			nBase = GetDouble();
+		else
+			nBase = 10.0;
 		double nVal = GetDouble();
 		if (nVal > 0.0 && nBase > 0.0 && nBase != 1.0)
 			PushDouble(log(nVal) / log(nBase));
Only in sc/source/core/tool: interpr2.cxx~
Only in sc/source/core/tool: interpr3.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr4.cxx sc/source/core/tool/interpr4.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/core/tool/interpr4.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/tool/interpr4.cxx	2006-09-28 21:32:42.000000000 +0100
@@ -1313,6 +1313,12 @@
 }
 
 
+BOOL ScInterpreter::IsMissing()
+{
+	return sp && pStack[sp - 1]->GetType() == svMissing;
+}
+
+
 StackVar ScInterpreter::GetStackType()
 {
 	StackVar eRes;
@@ -1497,6 +1503,9 @@
             }
         }
         break;
+		case svMissing:
+			nVal = 0.0;
+		break;
 		default:
 			Pop();
 			SetError(errIllegalParameter);
@@ -1508,6 +1517,16 @@
 }
 
 
+double ScInterpreter::GetDoubleWithDefault(double nDefault)
+{
+	bool bMissing = IsMissing();
+	double nResult = GetDouble();
+	if ( bMissing )
+		nResult = nDefault;
+	return nResult;
+}
+
+
 const String& ScInterpreter::GetString()
 {
 	StackVar eRes = (StackVar) GetStackType();
@@ -2122,6 +2141,8 @@
 					break;
 
 				case SC_ADDINARG_VALUE_OR_ARRAY:
+					if ( IsMissing() )
+						nStackType = svMissing;
 					switch( nStackType )
 					{
 						case svDouble:
@@ -2159,6 +2180,10 @@
 							if (!ScRangeToSequence::FillMixedArray( aParam, PopMatrix() ))
 								SetError(errIllegalParameter);
 							break;
+						case svMissing:
+							Pop();
+							aParam.clear();
+							break;
 						default:
 							Pop();
 							SetError(errIllegalParameter);
Only in sc/source/core/tool: interpr4.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/filter/excel/excform8.cxx sc/source/filter/excel/excform8.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/filter/excel/excform8.cxx	2006-09-22 15:39:57.000000000 +0100
+++ sc/source/filter/excel/excform8.cxx	2006-09-28 16:26:09.000000000 +0100
@@ -408,7 +408,7 @@
                 aIn >> nParamCount >> nXclFunc;
                 nParamCount &= 0x7F;
                 if( const XclFunctionInfo* pFuncInfo = maFuncProv.GetFuncInfoFromXclFunc( nXclFunc ) )
-                    DoMulArgs( pFuncInfo->meOpCode, nParamCount );
+                    DoMulArgs( pFuncInfo->meOpCode, nParamCount, pFuncInfo->mnMinParamCount );
                 else
                     DoMulArgs( ocNoName, 0 );
 			}
Only in sc/source/filter/excel: excform8.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/filter/excel/excform.cxx sc/source/filter/excel/excform.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/filter/excel/excform.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/filter/excel/excform.cxx	2006-09-28 21:32:59.000000000 +0100
@@ -491,7 +491,7 @@
                 else
                     aIn >> nXclFunc;
                 if( const XclFunctionInfo* pFuncInfo = maFuncProv.GetFuncInfoFromXclFunc( nXclFunc ) )
-                    DoMulArgs( pFuncInfo->meOpCode, pFuncInfo->mnMaxParamCount );
+                    DoMulArgs( pFuncInfo->meOpCode, pFuncInfo->mnMaxParamCount, pFuncInfo->mnMinParamCount );
                 else
                     DoMulArgs( ocNoName, 0 );
             }
@@ -509,7 +509,7 @@
                 else
                     aIn >> nXclFunc;
                 if( const XclFunctionInfo* pFuncInfo = maFuncProv.GetFuncInfoFromXclFunc( nXclFunc ) )
-                    DoMulArgs( pFuncInfo->meOpCode, nParamCount );
+                    DoMulArgs( pFuncInfo->meOpCode, nParamCount, pFuncInfo->mnMinParamCount );
                 else
                     DoMulArgs( ocNoName, 0 );
             }
@@ -1324,14 +1324,13 @@
     return false;
 }
 
-void ExcelToSc::DoMulArgs( DefTokenId eId, BYTE nAnz )
+void ExcelToSc::DoMulArgs( DefTokenId eId, sal_uInt8 nAnz,
+						   sal_uInt8 nMinParamCount )
 {
 	TokenId					eParam[ 256 ];
 	INT32					nLauf;
 
-    if( eId == ocLog && nAnz == 1 )
-        eId = ocLog10;
-	else if( eId == ocCeil || eId == ocFloor )
+	if( eId == ocCeil || eId == ocFloor )
 	{
 		aStack << aPool.Store( 1.0 );	// default, da in Excel nicht vorhanden
 		nAnz++;
@@ -1387,10 +1386,19 @@
 			}
 		}
 
+		// FIXME: ideally we'd want to import all missing args, but this
+		// conflicts with lots of fn's understanding of nParams - we need
+		// a function table, and pre-call argument normalisation 1st.
+		INT16 nLastRemovable = nLast - nMinParamCount;
+
 		// #84453# skip missing parameters at end of parameter list
-		while( (nSkipEnd < nLast) && aPool.IsSingleOp( eParam[ nSkipEnd + 1 ], ocMissing ) )
+		while( nSkipEnd < nLastRemovable &&
+			   aPool.IsSingleOp( eParam[ nSkipEnd + 1 ], ocMissing ) )
 			nSkipEnd++;
 
+//		fprintf (stderr, "Fn %d nSkipEnd %d nLast %d nMinParamCnt %d %d\n",
+//				 eId, nSkipEnd, nLast, nMinParamCount, nLastRemovable);
+
 		// [Parameter{;Parameter}]
 		if( nLast > nSkipEnd )
 		{
Only in sc/source/filter/excel: excform.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/filter/excel/xlformula.cxx sc/source/filter/excel/xlformula.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/filter/excel/xlformula.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/filter/excel/xlformula.cxx	2006-09-28 18:08:10.000000000 +0100
@@ -90,7 +90,7 @@
     { ocNBW,                11,     2,  30, V, { V, R } },
     { ocStDev,              12,     1,  30, V, { R } },
     { ocCurrency,           13,     1,  2,  V, { V } },
-    { ocFixed,              14,     2,  2,  V, { V, V, C, I } },
+    { ocFixed,              14,     1,  2,  V, { V, V, C, I } },
     { ocSin,                15,     1,  1,  V, { V } },
     { ocCos,                16,     1,  1,  V, { V } },
     { ocTan,                17,     1,  1,  V, { V } },
@@ -240,7 +240,7 @@
 /** Functions new in BIFF4. */
 static const XclFunctionInfo saFuncTable_4[] =
 {
-    { ocFixed,              14,     2,  3,  V, { V } },     // BIFF2-3: 2, BIFF4: 2-3
+    { ocFixed,              14,     1,  3,  V, { V } },     // BIFF2-3: 2, BIFF4: 2-3
     { ocRank,               216,    2,  3,  V, { V, R, V } },
     { ocGDA2,               247,    4,  5,  V, { V } },
     { ocFrequency,          252,    2,  2,  A, { R } },
Only in sc/source/filter/excel: xlformula.cxx~
diff -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/filter/inc/excform.hxx sc/source/filter/inc/excform.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/sc/source/filter/inc/excform.hxx	2006-09-22 15:39:57.000000000 +0100
+++ sc/source/filter/inc/excform.hxx	2006-09-28 16:23:41.000000000 +0100
@@ -63,7 +63,7 @@
     const XclBiff       meBiff;
 
 	// ---------------------------------------------------------------
-	void				DoMulArgs( DefTokenId, BYTE );
+	void				DoMulArgs( DefTokenId eId, sal_uInt8 nNumArgs, sal_uInt8 mnMinParamCount = 0 );
 
 	void				ExcRelToScRel( UINT16 nRow, UINT8 nCol, SingleRefData&, const BOOL bName );
 
Only in sc/source/filter/inc: excform.hxx~
