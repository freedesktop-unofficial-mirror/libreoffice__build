diff -u -r -x 'unxlng*' sc/inc/cell.hxx sc/inc/cell.hxx
--- sc/inc/cell.hxx	2006-09-22 15:39:57.000000000 +0100
+++ sc/inc/cell.hxx	2006-09-23 21:38:35.000000000 +0100
@@ -279,6 +279,9 @@
                         SCITP_CLOSE_ITERATION_CIRCLE
                     };
 	void			InterpretTail( ScInterpretTailParameter );
+	void            DoEnglishCompile( rtl::OUStringBuffer &rBuffer,
+									  const ScAddress &rPos,
+									  BOOL bCompileXML ) const;
 
 public:
 
diff -u -r -x 'unxlng*' sc/source/core/data/cell2.cxx sc/source/core/data/cell2.cxx
--- sc/source/core/data/cell2.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/data/cell2.cxx	2006-09-25 18:01:29.000000000 +0100
@@ -245,59 +245,41 @@
 void ScFormulaCell::GetEnglishFormula( String& rFormula, BOOL bCompileXML,
 									   ScAddress::Convention conv ) const
 {
-    //! mit GetFormula zusammenfassen !!!
+	rtl::OUStringBuffer rBuffer( rFormula );
+	GetEnglishFormula( rBuffer, bCompileXML, conv );
+	rFormula = rBuffer;
+}
+
+static bool HasMissing( ScTokenArray *pCode );
+static ScTokenArray *ReWriteMissingForSXW( ScTokenArray *pCode );
+
+void ScFormulaCell::DoEnglishCompile( rtl::OUStringBuffer &rBuffer,
+									  const ScAddress &rPos, 
+									  BOOL bCompileXML ) const
+{
+	ScTokenArray *pCompileCode = pCode;
+	if (bCompileXML)
+	{
+		 /* Scan pCode [ token array ! ] for missing args &
+			re-write if present */
+		if ( HasMissing( pCode ) )
+			pCompileCode = ReWriteMissingForSXW( pCode );
+	}
+
+	ScCompiler aComp( pDocument, rPos, *pCompileCode );
+	aComp.SetCompileEnglish( TRUE );
+	aComp.SetCompileXML( bCompileXML );
+	aComp.CreateStringFromTokenArray( rBuffer );
+	if( bCompileXML )
+	{
+		rtl::OUStringBuffer aTmp( rBuffer );
+		fprintf( stderr, "English '%s'\n",
+				 rtl::OUStringToOString( aTmp.makeStringAndClear(),
+										 RTL_TEXTENCODING_UTF8 ).getStr() );
+	}
 
-    if( pCode->GetError() && !pCode->GetLen() )
-    {
-        rFormula = ScGlobal::GetErrorString( pCode->GetError() ); return;
-    }
-    else if( cMatrixFlag == MM_REFERENCE )
-    {
-        // Referenz auf eine andere Zelle, die eine Matrixformel enthaelt
-        pCode->Reset();
-        ScToken* p = pCode->GetNextReferenceRPN();
-        if( p )
-        {
-            ScBaseCell* pCell;
-            SingleRefData& rRef = p->GetSingleRef();
-            rRef.CalcAbsIfRel( aPos );
-            if ( rRef.Valid() )
-                pCell = pDocument->GetCell( ScAddress( rRef.nCol,
-                    rRef.nRow, rRef.nTab ) );
-            else
-                pCell = NULL;
-            if (pCell && pCell->GetCellType() == CELLTYPE_FORMULA)
-            {
-                ((ScFormulaCell*)pCell)->GetEnglishFormula(rFormula, bCompileXML, conv);
-                return;
-            }
-            else
-            {
-                ScCompiler aComp( pDocument, aPos, *pCode );
-                aComp.SetCompileEnglish( TRUE );
-                aComp.SetCompileXML( bCompileXML );
-                aComp.CreateStringFromTokenArray( rFormula );
-            }
-        }
-        else
-        {
-            DBG_ERROR("ScFormulaCell::GetEnglishFormula: Keine Matrix");
-        }
-    }
-    else
-    {
-        ScCompiler aComp( pDocument, aPos, *pCode );
-        aComp.SetCompileEnglish( TRUE );
-        aComp.SetCompileXML( bCompileXML );
-        aComp.CreateStringFromTokenArray( rFormula );
-    }
-
-    rFormula.Insert( '=',0 );
-    if( cMatrixFlag )
-    {
-        rFormula.Insert('{', 0);
-        rFormula += '}';
-    }
+	if ( pCompileCode != pCode )
+		delete pCompileCode;
 }
 
 void ScFormulaCell::GetEnglishFormula( rtl::OUStringBuffer& rBuffer, BOOL bCompileXML,
@@ -330,12 +312,7 @@
                 return;
             }
             else
-            {
-                ScCompiler aComp( pDocument, aPos, *pCode );
-                aComp.SetCompileEnglish( TRUE );
-                aComp.SetCompileXML( bCompileXML );
-                aComp.CreateStringFromTokenArray( rBuffer );
-            }
+				DoEnglishCompile( rBuffer, aPos, bCompileXML );
         }
         else
         {
@@ -343,12 +320,7 @@
         }
     }
     else
-    {
-        ScCompiler aComp( pDocument, aPos, *pCode );
-        aComp.SetCompileEnglish( TRUE );
-        aComp.SetCompileXML( bCompileXML );
-        aComp.CreateStringFromTokenArray( rBuffer );
-    }
+		DoEnglishCompile( rBuffer, aPos, bCompileXML );
 
     sal_Unicode ch('=');
     rBuffer.insert( 0, &ch, 1 );
@@ -1555,6 +1527,168 @@
 }
 
 
+// ---- Move me to a more sensible place ----
 
 
+static void DumpTokArr( ScTokenArray *pCode )
+{
+	fprintf (stderr, "HasMissing: ");
+	for ( ScToken *pCur = pCode->First(); pCur; pCur = pCode->Next() )
+		fprintf( stderr, "t%d,o%d ",
+				 pCur->GetType(), pCur->GetOpCode() );
+	fprintf (stderr, "\n");
+}
+
+static bool HasMissing( ScTokenArray *pCode )
+{
+	for ( ScToken *pCur = pCode->First(); pCur; pCur = pCode->Next() )
+		if (pCur->GetOpCode() == ocMissing)
+			return true;
+	return false;
+}
+
+struct MissingContext {
+		ScToken *pFunc;
+		int      nCurArg;
+};
+
+#define DEFAULT_ARG(arr,n,d) \
+		if (rCtx.nCurArg == (n)) \
+		{ \
+			(arr)->AddDouble( d ); \
+			return true; \
+		}
+
+static bool AddMissingExternal( const MissingContext &rCtx, ScTokenArray *pNewArr )
+{
+	const String &rName = rCtx.pFunc->GetExternal();
+
+	// initial (fast) check:
+	sal_Unicode nLastChar = rName.GetChar( rName.Len() - 1);
+	if ( nLastChar != 't' && nLastChar != 'm' )
+		return false;
+
+	if (rName.EqualsIgnoreCaseAscii(
+			"com.sun.star.sheet.addin.Analysis.getAccrint" ))
+	{
+		DEFAULT_ARG( pNewArr, 4, 1000.0 );
+	}
+	if (rName.EqualsIgnoreCaseAscii(
+			"com.sun.star.sheet.addin.Analysis.getAccrintm" ))
+	{
+		DEFAULT_ARG( pNewArr, 3, 1000.0 );
+	}
+// FIXME: when we implement EUROCONVERT
+//	if (rName.EqualsIgnoreCaseAscii( "EUROCONVERT" ))
+//		DEFAULT_ARG( pNewArr, 3, 0.0 );
+}
+
+static bool AddMissing( const MissingContext &rCtx,
+						ScTokenArray *pNewArr )
+{
+	if ( !rCtx.pFunc )
+		return false;
+
+	switch ( rCtx.pFunc->GetOpCode() ) 
+	{
+	case ocFixed:
+		DEFAULT_ARG( pNewArr, 1, 2.0 );
+		break;
+	case ocBetaDist:
+	case ocBetaInv:
+	case ocRMZ:  // PMT 
+		DEFAULT_ARG( pNewArr, 3, 0.0 );
+		break;
+	case ocZinsZ: // IPMT
+	case ocKapz:  // PPMT
+		DEFAULT_ARG( pNewArr, 4, 0.0 );
+		break;
+	case ocBW: // PV
+	case ocZW: // FV
+		DEFAULT_ARG( pNewArr, 2, 0.0 ); // pmt
+		DEFAULT_ARG( pNewArr, 3, 0.0 ); // [fp]v
+		break;
+	case ocZins: // RATE
+		DEFAULT_ARG( pNewArr, 1, 0.0 ); // pmt
+		DEFAULT_ARG( pNewArr, 3, 0.0 ); // fv
+		DEFAULT_ARG( pNewArr, 4, 0.0 ); // type
+		break;
+	case ocExternal:
+		return AddMissingExternal( rCtx, pNewArr );
+		break;
+
+	// --- more complex cases ---
+
+	case ocOffset:
+		// FIXME: rather tough.
+		// if arg 3 (height) ommitted, export sizeof base-area
+		break;
+	case ocAdress:
+		// FIXME - should we adjust 'ADDRESS_XL(?)' at this point?
+		// (arg 4 -> 'TRUE' ? [ or no arg. 4 ;-] )
+		break;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static void AddMoreArgs( const MissingContext &rCtx,
+						 ScTokenArray *pNewArr )
+{
+	if ( !rCtx.pFunc )
+		return;
+
+	// Log
+	if ( rCtx.pFunc->GetOpCode() == ocLog &&
+		 rCtx.nCurArg < 1 )
+		pNewArr->AddDouble( 10.0 );
+}
+
+#undef EXPECT
+
+static ScTokenArray *ReWriteMissingForSXW( ScTokenArray *pCode )
+{
+	MissingContext aCtx[ pCode->GetLen() ];
+	int nFn = -1;
+
+	ScTokenArray *pNewArr = new ScTokenArray();
+
+	for ( ScToken *pCur = pCode->First(); pCur;
+		  pCur = pCode->NextNoSpaces() )
+	{
+		bool bAdd = true;
+		switch ( pCur->GetOpCode() )
+		{
+			case ocOpen:
+				aCtx[ ++nFn ].pFunc = pCode->PeekPrevNoSpaces();
+				aCtx[ nFn ].nCurArg = 0;
+				break;
+			case ocClose:
+				AddMoreArgs( aCtx[ nFn ], pNewArr );
+				--nFn;
+				break;
+			case ocSep:
+				aCtx[ nFn ].nCurArg++;
+				break;
+			case ocMissing:
+			{
+	//			fprintf( stderr, "Missing arg %d on fn t%d,o%d\n",
+	//					 aCtx[ nFn ].nCurArg, 
+	//					 aCtx[ nFn ].pFunc->GetType(),
+	//					 aCtx[ nFn ].pFunc->GetOpCode() );
+				// FIXME: if we didn't know about this, should we
+				// simply elide it [ a var-arg case ? ]
+				bAdd = !AddMissing( aCtx[ nFn ], pNewArr );
+				break;
+			}
+			default:
+				break;
+		}
+		if ( bAdd )
+			pNewArr->AddToken( *pCur );
+	}
 
+	return pNewArr;
+}
diff -u -r -x 'unxlng*' sc/source/core/inc/interpre.hxx sc/source/core/inc/interpre.hxx
--- sc/source/core/inc/interpre.hxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/inc/interpre.hxx	2006-09-27 11:02:58.000000000 +0100
@@ -269,6 +269,8 @@
 // generiert aus DoubleRef positionsabhaengige SingleRef
 BOOL DoubleRefToPosSingleRef( const ScRange& rRange, ScAddress& rAdr );
 double GetDouble();
+double GetDoubleWithDefault(double nDefault);
+BOOL IsMissing();
 BOOL GetBool() { return GetDouble() != 0.0; }
 const String& GetString();
 // pop matrix and obtain one element, upper left or according to jump matrix

diff -u -r -x 'unxlng*' sc/source/core/tool/compiler.cxx sc/source/core/tool/compiler.cxx
--- sc/source/core/tool/compiler.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/tool/compiler.cxx	2006-09-26 17:30:31.000000000 +0100
@@ -3117,14 +3117,10 @@
             SetError( errParameterExpected );
         }
         else if ( eOp == ocMissing )
-        {   // #84460# May occur if imported from Xcl.
-            // The real value for missing parameters depends on the function
-            // where it is used, interpreter would have to handle this.
-            // If it does remove this error case here, that could also be the
-            // time to generate ocMissing in between subsequent ocSep.
-            // Xcl import should map missings to values if possible.
-            SetError( errParameterExpected );
-        }
+		{
+			PutCode( pToken );
+			NextToken();
+		}
         else if ( eOp == ocSep )
         {   // Subsequent ocSep
             SetError( errParameterExpected );
Only in sc/source/core/tool: compiler.cxx~
diff -u -r -x 'unxlng*' sc/source/core/tool/interpr1.cxx sc/source/core/tool/interpr1.cxx
--- sc/source/core/tool/interpr1.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/tool/interpr1.cxx	2006-09-27 11:39:29.000000000 +0100
@@ -5529,11 +5529,11 @@
 	BYTE nParamCount = GetByte();
 	if ( MustHaveParamCount( nParamCount, 3, 5 ) )
 	{
-		long nColNew, nRowNew, nColPlus, nRowPlus;
+		long nColNew = -1, nRowNew = -1, nColPlus, nRowPlus;
 		if (nParamCount == 5)
 			nColNew = (long) ::rtl::math::approxFloor(GetDouble());
 		if (nParamCount >= 4)
-			nRowNew = (long) ::rtl::math::approxFloor(GetDouble());
+			nRowNew = (long) ::rtl::math::approxFloor(GetDoubleWithDefault( -1.0 ));
 		nColPlus = (long) ::rtl::math::approxFloor(GetDouble());
 		nRowPlus = (long) ::rtl::math::approxFloor(GetDouble());
         SCCOL nCol1;
@@ -5542,8 +5542,7 @@
         SCCOL nCol2;
         SCROW nRow2;
         SCTAB nTab2;
-		if ( (nParamCount == 5 && nColNew == 0)
-		  || (nParamCount >= 4 && nRowNew == 0) )
+		if (nColNew == 0 || nRowNew == 0)
 		{
 			SetIllegalParameter();
 			return;
@@ -5551,7 +5550,7 @@
 		if (GetStackType() == svSingleRef)
 		{
 			PopSingleRef(nCol1, nRow1, nTab1);
-			if (nParamCount == 3)
+			if (nParamCount == 3 || (nColNew < 0 && nRowNew < 0))
 			{
 				nCol1 = (SCCOL)((long) nCol1 + nColPlus);
 				nRow1 = (SCROW)((long) nRow1 + nRowPlus);
@@ -5562,8 +5561,10 @@
 			}
 			else
 			{
-				if (nParamCount == 4)
+				if (nColNew < 0)
 					nColNew = 1;
+				if (nRowNew < 0)
+					nRowNew = 1;
 				nCol1 = (SCCOL)((long)nCol1+nColPlus);		// ! nCol1 wird veraendert!
 				nRow1 = (SCROW)((long)nRow1+nRowPlus);
 				nCol2 = (SCCOL)((long)nCol1+nColNew-1);
@@ -5578,9 +5579,9 @@
 		else if (GetStackType() == svDoubleRef)
 		{
 			PopDoubleRef(nCol1, nRow1, nTab1, nCol2, nRow2, nTab2);
-			if (nParamCount < 5)
+			if (nColNew < 0)
 				nColNew = nCol2 - nCol1 + 1;
-			if (nParamCount < 4)
+			if (nRowNew < 0)
 				nRowNew = nRow2 - nRow1 + 1;
 			nCol1 = (SCCOL)((long)nCol1+nColPlus);
 			nRow1 = (SCROW)((long)nRow1+nRowPlus);
@@ -5926,7 +5927,7 @@
 			bThousand = TRUE;
 		if (nParamCount >= 2)
 		{
-			fDec = ::rtl::math::approxFloor(GetDouble());
+			fDec = ::rtl::math::approxFloor(GetDoubleWithDefault( 2.0 ));
 			if (fDec < -15.0 || fDec > 15.0)
 			{
 				SetIllegalArgument();

diff -u -r -x 'unxlng*' sc/source/core/tool/interpr2.cxx sc/source/core/tool/interpr2.cxx
--- sc/source/core/tool/interpr2.cxx	2006-09-22 15:39:57.000000000 +0100
+++ sc/source/core/tool/interpr2.cxx	2006-09-26 16:14:37.000000000 +0100
@@ -542,9 +542,14 @@
 
 void ScInterpreter::ScLog()
 {
-	if ( MustHaveParamCount( GetByte(), 2 ) )
+	BYTE nParamCount = GetByte();
+	if ( MustHaveParamCount( nParamCount, 1, 2 ) )
 	{
-		double nBase = GetDouble();
+		double nBase;
+		if (nParamCount == 2)
+			nBase = GetDouble();
+		else
+			nBase = 10.0;
 		double nVal = GetDouble();
 		if (nVal > 0.0 && nBase > 0.0 && nBase != 1.0)
 			PushDouble(log(nVal) / log(nBase));

diff -u -r -x 'unxlng*' sc/source/core/tool/interpr4.cxx sc/source/core/tool/interpr4.cxx
--- sc/source/core/tool/interpr4.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/core/tool/interpr4.cxx	2006-09-27 14:51:32.000000000 +0100
@@ -1313,6 +1313,12 @@
 }
 
 
+BOOL ScInterpreter::IsMissing()
+{
+	return sp && pStack[sp - 1]->GetType() == svMissing;
+}
+
+
 StackVar ScInterpreter::GetStackType()
 {
 	StackVar eRes;
@@ -1497,6 +1502,9 @@
             }
         }
         break;
+		case svMissing:
+			nVal = 0.0;
+		break;
 		default:
 			Pop();
 			SetError(errIllegalParameter);
@@ -1508,6 +1516,16 @@
 }
 
 
+double ScInterpreter::GetDoubleWithDefault(double nDefault)
+{
+	bool bMissing = IsMissing();
+	double nResult = GetDouble();
+	if ( bMissing )
+		nResult = nDefault;
+	return nResult;
+}
+
+
 const String& ScInterpreter::GetString()
 {
 	StackVar eRes = (StackVar) GetStackType();
@@ -2122,6 +2140,8 @@
 					break;
 
 				case SC_ADDINARG_VALUE_OR_ARRAY:
+					if ( IsMissing() )
+						nStackType = svMissing;
 					switch( nStackType )
 					{
 						case svDouble:
@@ -2159,6 +2179,10 @@
 							if (!ScRangeToSequence::FillMixedArray( aParam, PopMatrix() ))
 								SetError(errIllegalParameter);
 							break;
+						case svMissing:
+							Pop();
+							aParam.clear();
+							break;
 						default:
 							Pop();
 							SetError(errIllegalParameter);

diff -u -r -x 'unxlng*' sc/source/filter/excel/excform.cxx sc/source/filter/excel/excform.cxx
--- sc/source/filter/excel/excform.cxx	2006-09-22 15:39:59.000000000 +0100
+++ sc/source/filter/excel/excform.cxx	2006-09-25 18:21:21.000000000 +0100
@@ -1329,9 +1329,7 @@
 	TokenId					eParam[ 256 ];
 	INT32					nLauf;
 
-    if( eId == ocLog && nAnz == 1 )
-        eId = ocLog10;
-	else if( eId == ocCeil || eId == ocFloor )
+	if( eId == ocCeil || eId == ocFloor )
 	{
 		aStack << aPool.Store( 1.0 );	// default, da in Excel nicht vorhanden
 		nAnz++;

