cvs diff: Diffing fpicker
cvs diff: Diffing fpicker/prj
cvs diff: Diffing fpicker/source
cvs diff: Diffing fpicker/source/generic
cvs diff: Diffing fpicker/source/office
cvs diff: Diffing fpicker/source/unx
cvs diff: Diffing fpicker/source/unx/gnome
Index: fpicker/source/unx/gnome/FPentry.cxx
===================================================================
RCS file: /cvs/gsl/fpicker/source/unx/gnome/FPentry.cxx,v
retrieving revision 1.4
retrieving revision 1.4.26.1
diff -u -p -r1.4 -r1.4.26.1
--- fpicker/source/unx/gnome/FPentry.cxx	8 Sep 2005 23:34:31 -0000	1.4
+++ fpicker/source/unx/gnome/FPentry.cxx	7 Dec 2005 14:37:07 -0000	1.4.26.1
@@ -158,8 +158,7 @@ void* SAL_CALL component_getFactory( 
 	{
 			if (
 				 /* crude gtkplug check */ !g_type_from_name( "GdkDisplay" ) || 
-				 /* old version */ !( gtk_major_version >= 2 && gtk_minor_version >= 4 ) ||
-				 /* #i42429# */ Application::GetSettings().GetMiscSettings().GetEnableATToolSupport()
+				 /* old version */ !( gtk_major_version >= 2 && gtk_minor_version >= 4 ) 
 			   )
 			{
 					return 0;
cvs diff: Diffing fpicker/source/win32
cvs diff: Diffing fpicker/source/win32/filepicker
cvs diff: Diffing fpicker/source/win32/filepicker/workbench
cvs diff: Diffing fpicker/source/win32/folderpicker
cvs diff: Diffing fpicker/source/win32/folderpicker/workbench
cvs diff: Diffing fpicker/source/win32/misc
cvs diff: Diffing fpicker/util
cvs diff: Diffing svtools
cvs diff: Diffing svtools/bmpmaker
cvs diff: Diffing svtools/inc
cvs diff: Diffing svtools/inc/svtools
cvs diff: Diffing svtools/prj
cvs diff: Diffing svtools/qa
cvs diff: Diffing svtools/qa/unoapi
cvs diff: Diffing svtools/source
cvs diff: Diffing svtools/source/Accessibility
Index: svtools/source/Accessibility/accessibleiconchoicectrlentry.cxx
===================================================================
RCS file: /cvs/util/svtools/source/Accessibility/accessibleiconchoicectrlentry.cxx,v
retrieving revision 1.16
retrieving revision 1.15.106.2
diff -u -p -r1.16 -r1.15.106.2
--- svtools/source/Accessibility/accessibleiconchoicectrlentry.cxx	31 Jan 2006 18:46:28 -0000	1.16
+++ svtools/source/Accessibility/accessibleiconchoicectrlentry.cxx	6 Feb 2006 10:26:28 -0000	1.15.106.2
@@ -441,6 +441,7 @@ throw(RuntimeException)
 	       	pStateSetHelper->AddState( AccessibleStateType::TRANSIENT );
 	       	pStateSetHelper->AddState( AccessibleStateType::SELECTABLE );
 	       	pStateSetHelper->AddState( AccessibleStateType::ENABLED );
+            pStateSetHelper->AddState( AccessibleStateType::SENSITIVE );
 			if ( IsShowing_Impl() )
 			{
 	        	pStateSetHelper->AddState( AccessibleStateType::SHOWING );
Index: svtools/source/Accessibility/accessiblelistboxentry.cxx
===================================================================
RCS file: /cvs/util/svtools/source/Accessibility/accessiblelistboxentry.cxx,v
retrieving revision 1.25
retrieving revision 1.25.106.1
diff -u -p -r1.25 -r1.25.106.1
--- svtools/source/Accessibility/accessiblelistboxentry.cxx	8 Sep 2005 14:25:58 -0000	1.25
+++ svtools/source/Accessibility/accessiblelistboxentry.cxx	6 Dec 2005 08:41:55 -0000	1.25.106.1
@@ -503,6 +503,7 @@ namespace svt
 	       	pStateSetHelper->AddState( AccessibleStateType::TRANSIENT );
 	       	pStateSetHelper->AddState( AccessibleStateType::SELECTABLE );
 	       	pStateSetHelper->AddState( AccessibleStateType::ENABLED );
+            pStateSetHelper->AddState( AccessibleStateType::SENSITIVE );
 			if ( getListBox()->IsInplaceEditingEnabled() )
 		       	pStateSetHelper->AddState( AccessibleStateType::EDITABLE );
 			if ( IsShowing_Impl() )
Index: svtools/source/Accessibility/accessibletabbar.cxx
===================================================================
RCS file: /cvs/util/svtools/source/Accessibility/accessibletabbar.cxx,v
retrieving revision 1.12
retrieving revision 1.11.84.2
diff -u -p -r1.12 -r1.11.84.2
--- svtools/source/Accessibility/accessibletabbar.cxx	31 Jan 2006 18:30:03 -0000	1.12
+++ svtools/source/Accessibility/accessibletabbar.cxx	6 Feb 2006 10:26:01 -0000	1.11.84.2
@@ -115,6 +115,8 @@ namespace svt
 		{
 			case VCLEVENT_WINDOW_ENABLED:
 			{
+                aNewValue <<= AccessibleStateType::SENSITIVE;
+                NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
 				aNewValue <<= AccessibleStateType::ENABLED;
 				NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
 			}
@@ -123,6 +125,8 @@ namespace svt
 			{
 				aOldValue <<= AccessibleStateType::ENABLED;
 				NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
+                aOldValue <<= AccessibleStateType::SENSITIVE;
+                NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
 			}
 			break;
 			case VCLEVENT_WINDOW_GETFOCUS:
@@ -164,7 +168,10 @@ namespace svt
 		if ( m_pTabBar )
 		{
 			if ( m_pTabBar->IsEnabled() )
-				rStateSet.AddState( AccessibleStateType::ENABLED );
+            {
+                rStateSet.AddState( AccessibleStateType::ENABLED );
+                rStateSet.AddState( AccessibleStateType::SENSITIVE );
+            }
 
 			rStateSet.AddState( AccessibleStateType::FOCUSABLE );
 
Index: svtools/source/Accessibility/accessibletabbarpage.cxx
===================================================================
RCS file: /cvs/util/svtools/source/Accessibility/accessibletabbarpage.cxx,v
retrieving revision 1.11
retrieving revision 1.10.106.2
diff -u -p -r1.11 -r1.10.106.2
--- svtools/source/Accessibility/accessibletabbarpage.cxx	31 Jan 2006 18:30:28 -0000	1.11
+++ svtools/source/Accessibility/accessibletabbarpage.cxx	6 Feb 2006 10:26:47 -0000	1.10.106.2
@@ -142,13 +142,21 @@ namespace svt
 	{
 		if ( m_bEnabled != bEnabled )
 		{
-			Any aOldValue, aNewValue;
+            Any aOldValue[2], aNewValue[2];
 			if ( m_bEnabled )
-				aOldValue <<= AccessibleStateType::ENABLED;
-			else
-				aNewValue <<= AccessibleStateType::ENABLED;
+            {
+                aOldValue[0] <<= AccessibleStateType::SENSITIVE;
+                aOldValue[1] <<= AccessibleStateType::ENABLED;
+            }
+            else
+            {
+
+                aNewValue[0] <<= AccessibleStateType::ENABLED;
+                aNewValue[1] <<= AccessibleStateType::SENSITIVE;
+            }
 			m_bEnabled = bEnabled;
-			NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
+            NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue[0], aNewValue[0] );
+            NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue[1], aNewValue[1] );
 		}
 	}
 
@@ -203,7 +211,10 @@ namespace svt
 	void AccessibleTabBarPage::FillAccessibleStateSet( utl::AccessibleStateSetHelper& rStateSet )
 	{
 		if ( IsEnabled() )
+        {
 			rStateSet.AddState( AccessibleStateType::ENABLED );
+            rStateSet.AddState( AccessibleStateType::SENSITIVE );
+        }
 
 		rStateSet.AddState( AccessibleStateType::VISIBLE );
 
Index: svtools/source/Accessibility/accessibletabbarpagelist.cxx
===================================================================
RCS file: /cvs/util/svtools/source/Accessibility/accessibletabbarpagelist.cxx,v
retrieving revision 1.17
retrieving revision 1.16.72.2
diff -u -p -r1.17 -r1.16.72.2
--- svtools/source/Accessibility/accessibletabbarpagelist.cxx	31 Jan 2006 18:30:44 -0000	1.17
+++ svtools/source/Accessibility/accessibletabbarpagelist.cxx	6 Feb 2006 10:26:54 -0000	1.16.72.2
@@ -251,19 +251,21 @@ namespace svt
 
 		switch ( rVclWindowEvent.GetId() )
 		{
-			case VCLEVENT_WINDOW_ENABLED:
+            case VCLEVENT_WINDOW_ENABLED:
 			{
-				Any aOldValue, aNewValue;
-				aNewValue <<= AccessibleStateType::ENABLED;
-				NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );				
-			}
-			break;
-			case VCLEVENT_WINDOW_DISABLED:
-			{
-				Any aOldValue, aNewValue;
-				aOldValue <<= AccessibleStateType::ENABLED;
-				NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
-			}
+                aNewValue <<= AccessibleStateType::SENSITIVE;
+                NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
+                aNewValue <<= AccessibleStateType::ENABLED;
+                NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
+            }
+            break;
+            case VCLEVENT_WINDOW_DISABLED:
+            {
+                aOldValue <<= AccessibleStateType::ENABLED;
+                NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
+                aOldValue <<= AccessibleStateType::SENSITIVE;
+                NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
+            }
 			break;
 			case VCLEVENT_WINDOW_SHOW:
 			{
@@ -395,7 +397,10 @@ namespace svt
 		if ( m_pTabBar )
 		{
 			if ( m_pTabBar->IsEnabled() )
-				rStateSet.AddState( AccessibleStateType::ENABLED );
+            {
+                rStateSet.AddState( AccessibleStateType::ENABLED );
+                rStateSet.AddState( AccessibleStateType::SENSITIVE );
+            }
 
 			rStateSet.AddState( AccessibleStateType::VISIBLE );
 
cvs diff: Diffing svtools/source/brwbox
Index: svtools/source/brwbox/brwbox3.cxx
===================================================================
RCS file: /cvs/util/svtools/source/brwbox/brwbox3.cxx,v
retrieving revision 1.16
retrieving revision 1.16.106.1
diff -u -p -r1.16 -r1.16.106.1
--- svtools/source/brwbox/brwbox3.cxx	8 Sep 2005 14:29:19 -0000	1.16
+++ svtools/source/brwbox/brwbox3.cxx	6 Dec 2005 11:50:53 -0000	1.16.106.1
@@ -357,7 +357,10 @@ void BrowseBox::FillAccessibleStateSet(
 			if ( GetUpdateMode() )
 				rStateSet.AddState( AccessibleStateType::EDITABLE );
 			if ( IsEnabled() )
+            {
 				rStateSet.AddState( AccessibleStateType::ENABLED );
+                rStateSet.AddState( AccessibleStateType::SENSITIVE );
+            }
 			if ( IsReallyVisible() )
 				rStateSet.AddState( AccessibleStateType::VISIBLE );
 			if ( eObjType == ::svt::BBTYPE_TABLE )
cvs diff: Diffing svtools/source/cmdparse
cvs diff: Diffing svtools/source/config
cvs diff: Diffing svtools/source/config/test
cvs diff: Diffing svtools/source/contnr
Index: svtools/source/contnr/svtabbx.cxx
===================================================================
RCS file: /cvs/util/svtools/source/contnr/svtabbx.cxx,v
retrieving revision 1.18
retrieving revision 1.16.106.3
diff -u -p -r1.18 -r1.16.106.3
--- svtools/source/contnr/svtabbx.cxx	6 Feb 2006 13:37:19 -0000	1.18
+++ svtools/source/contnr/svtabbx.cxx	16 Feb 2006 13:38:08 -0000	1.16.106.3
@@ -1206,7 +1206,10 @@ void SvHeaderTabListBox::FillAccessibleS
 			if ( IsActive() )
 				_rStateSet.AddState( AccessibleStateType::ACTIVE );
 			if ( IsEnabled() )
+            {
 				_rStateSet.AddState( AccessibleStateType::ENABLED );
+                _rStateSet.AddState( AccessibleStateType::SENSITIVE );
+            }
 			if ( IsReallyVisible() )
 				_rStateSet.AddState( AccessibleStateType::VISIBLE );
 			if ( _eType == ::svt::BBTYPE_TABLE )
cvs diff: Diffing svtools/source/control
Index: svtools/source/control/valueacc.cxx
===================================================================
RCS file: /cvs/util/svtools/source/control/valueacc.cxx,v
retrieving revision 1.17
retrieving revision 1.17.108.1
diff -u -p -r1.17 -r1.17.108.1
--- svtools/source/control/valueacc.cxx	8 Sep 2005 15:08:48 -0000	1.17
+++ svtools/source/control/valueacc.cxx	6 Dec 2005 11:50:54 -0000	1.17.108.1
@@ -319,6 +319,7 @@ uno::Reference< accessibility::XAccessib
 
     // Set some states.
     pStateSet->AddState (accessibility::AccessibleStateType::ENABLED);
+    pStateSet->AddState (accessibility::AccessibleStateType::SENSITIVE);
     pStateSet->AddState (accessibility::AccessibleStateType::SHOWING);
     pStateSet->AddState (accessibility::AccessibleStateType::VISIBLE);
     pStateSet->AddState (accessibility::AccessibleStateType::MANAGES_DESCENDANTS);
@@ -991,6 +992,7 @@ uno::Reference< accessibility::XAccessib
     if( mpParent )
     {
         pStateSet->AddState (accessibility::AccessibleStateType::ENABLED);
+        pStateSet->AddState (accessibility::AccessibleStateType::SENSITIVE);
         pStateSet->AddState (accessibility::AccessibleStateType::SHOWING);
         pStateSet->AddState (accessibility::AccessibleStateType::VISIBLE);
         pStateSet->AddState (accessibility::AccessibleStateType::TRANSIENT);
cvs diff: Diffing svtools/source/dialogs
cvs diff: Diffing svtools/source/edit
Index: svtools/source/edit/textwindowaccessibility.cxx
===================================================================
RCS file: /cvs/util/svtools/source/edit/textwindowaccessibility.cxx,v
retrieving revision 1.26
retrieving revision 1.24.104.3
diff -u -p -r1.26 -r1.24.104.3
--- svtools/source/edit/textwindowaccessibility.cxx	1 Feb 2006 14:40:09 -0000	1.26
+++ svtools/source/edit/textwindowaccessibility.cxx	6 Feb 2006 10:27:37 -0000	1.24.104.3
@@ -1421,6 +1421,8 @@ Document::retrieveParagraphNumber(Paragr
           = (static_cast< ::sal_Int64 >(1)
              << ::css::accessibility::AccessibleStateType::ENABLED)
           | (static_cast< ::sal_Int64 >(1)
+             << ::css::accessibility::AccessibleStateType::SENSITIVE)
+          | (static_cast< ::sal_Int64 >(1)
              << ::css::accessibility::AccessibleStateType::FOCUSABLE)
           | (static_cast< ::sal_Int64 >(1)
              << ::css::accessibility::AccessibleStateType::MULTI_LINE);
cvs diff: Diffing svtools/source/filepicker
cvs diff: Diffing svtools/source/filerec
cvs diff: Diffing svtools/source/filter.vcl
cvs diff: Diffing svtools/source/filter.vcl/filter
cvs diff: Diffing svtools/source/filter.vcl/igif
cvs diff: Diffing svtools/source/filter.vcl/ixbm
cvs diff: Diffing svtools/source/filter.vcl/ixpm
cvs diff: Diffing svtools/source/filter.vcl/jpeg
cvs diff: Diffing svtools/source/filter.vcl/wmf
cvs diff: Diffing svtools/source/fsstor
cvs diff: Diffing svtools/source/hatchwindow
cvs diff: Diffing svtools/source/inc
cvs diff: Diffing svtools/source/items
cvs diff: Diffing svtools/source/items1
cvs diff: Diffing svtools/source/java
cvs diff: Diffing svtools/source/memtools
cvs diff: Diffing svtools/source/misc
cvs diff: Diffing svtools/source/misc1
cvs diff: Diffing svtools/source/notify
cvs diff: Diffing svtools/source/numbers
cvs diff: Diffing svtools/source/passwordcontainer
cvs diff: Diffing svtools/source/plugapp
cvs diff: Diffing svtools/source/productregistration
cvs diff: Diffing svtools/source/svdde
cvs diff: Diffing svtools/source/svhtml
cvs diff: Diffing svtools/source/svrtf
cvs diff: Diffing svtools/source/svsql
cvs diff: Diffing svtools/source/syslocale
cvs diff: Diffing svtools/source/undo
cvs diff: Diffing svtools/source/uno
cvs diff: Diffing svtools/source/urlobj
cvs diff: Diffing svtools/uno
cvs diff: Diffing svtools/unx
cvs diff: Diffing svtools/unx/inc
cvs diff: Diffing svtools/unx/source
cvs diff: Diffing svtools/unx/source/svdde
cvs diff: Diffing svtools/util
cvs diff: Diffing svtools/util/defs
Index: toolkit/source/awt/accessiblemenubasecomponent.cxx
===================================================================
RCS file: /cvs/gsl/toolkit/source/awt/accessiblemenubasecomponent.cxx,v
retrieving revision 1.21
retrieving revision 1.21.30.1
diff -u -p -r1.21 -r1.21.30.1
--- toolkit/source/awt/accessiblemenubasecomponent.cxx	9 Sep 2005 13:01:15 -0000	1.21
+++ toolkit/source/awt/accessiblemenubasecomponent.cxx	5 Dec 2005 14:27:11 -0000	1.21.30.1
@@ -196,13 +196,20 @@ void OAccessibleMenuBaseComponent::SetEn
 {
 	if ( m_bEnabled != bEnabled )
 	{
-		Any aOldValue, aNewValue;
+		Any aOldValue[2], aNewValue[2];
 		if ( m_bEnabled )
-			aOldValue <<= AccessibleStateType::ENABLED;
+        {
+            aOldValue[0] <<= AccessibleStateType::SENSITIVE;
+            aOldValue[1] <<= AccessibleStateType::ENABLED;
+        }
 		else
-			aNewValue <<= AccessibleStateType::ENABLED;
+        {
+            aNewValue[0] <<= AccessibleStateType::ENABLED;
+            aNewValue[1] <<= AccessibleStateType::SENSITIVE;
+        }
 		m_bEnabled = bEnabled;
-		NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
+        NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue[0], aNewValue[0] );
+        NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue[1], aNewValue[1] );
 	}
 }
 
Index: toolkit/source/awt/accessiblemenucomponent.cxx
===================================================================
RCS file: /cvs/gsl/toolkit/source/awt/accessiblemenucomponent.cxx,v
retrieving revision 1.13
retrieving revision 1.13.32.1
diff -u -p -r1.13 -r1.13.32.1
--- toolkit/source/awt/accessiblemenucomponent.cxx	9 Sep 2005 13:01:32 -0000	1.13
+++ toolkit/source/awt/accessiblemenucomponent.cxx	5 Dec 2005 14:27:12 -0000	1.13.32.1
@@ -128,7 +128,10 @@ sal_Bool OAccessibleMenuComponent::IsSho
 void OAccessibleMenuComponent::FillAccessibleStateSet( utl::AccessibleStateSetHelper& rStateSet )
 {
 	if ( IsEnabled() )
+    {
 		rStateSet.AddState( AccessibleStateType::ENABLED );
+        rStateSet.AddState( AccessibleStateType::SENSITIVE );
+    }
 
 	rStateSet.AddState( AccessibleStateType::FOCUSABLE );
 
Index: toolkit/source/awt/accessiblemenuitemcomponent.cxx
===================================================================
RCS file: /cvs/gsl/toolkit/source/awt/accessiblemenuitemcomponent.cxx,v
retrieving revision 1.14
retrieving revision 1.14.32.1
diff -u -p -r1.14 -r1.14.32.1
--- toolkit/source/awt/accessiblemenuitemcomponent.cxx	9 Sep 2005 13:01:57 -0000	1.14
+++ toolkit/source/awt/accessiblemenuitemcomponent.cxx	5 Dec 2005 14:27:12 -0000	1.14.32.1
@@ -274,7 +274,10 @@ void OAccessibleMenuItemComponent::SetIt
 void OAccessibleMenuItemComponent::FillAccessibleStateSet( utl::AccessibleStateSetHelper& rStateSet )
 {
 	if ( IsEnabled() )
+    {
 		rStateSet.AddState( AccessibleStateType::ENABLED );
+        rStateSet.AddState( AccessibleStateType::SENSITIVE );
+    }
 
 	rStateSet.AddState( AccessibleStateType::VISIBLE );
 
Index: toolkit/source/awt/vclxaccessiblecomponent.cxx
===================================================================
RCS file: /cvs/gsl/toolkit/source/awt/vclxaccessiblecomponent.cxx,v
retrieving revision 1.53
retrieving revision 1.52.32.2
diff -u -p -r1.53 -r1.52.32.2
--- toolkit/source/awt/vclxaccessiblecomponent.cxx	31 Jan 2006 18:21:29 -0000	1.53
+++ toolkit/source/awt/vclxaccessiblecomponent.cxx	6 Feb 2006 10:28:37 -0000	1.52.32.2
@@ -391,12 +391,17 @@ void VCLXAccessibleComponent::ProcessWin
 		{
 			aNewValue <<= accessibility::AccessibleStateType::ENABLED;
 			NotifyAccessibleEvent( accessibility::AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
+            aNewValue <<= accessibility::AccessibleStateType::SENSITIVE;
+            NotifyAccessibleEvent( accessibility::AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
 		}
 		break;
 		case VCLEVENT_WINDOW_DISABLED:
 		{
-			aOldValue <<= accessibility::AccessibleStateType::ENABLED;
+            aOldValue <<= accessibility::AccessibleStateType::SENSITIVE;
 			NotifyAccessibleEvent( accessibility::AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
+
+            aOldValue <<= accessibility::AccessibleStateType::ENABLED;
+            NotifyAccessibleEvent( accessibility::AccessibleEventId::STATE_CHANGED, aOldValue, aNewValue );
 		}
 		break;
 		case VCLEVENT_WINDOW_MOVE:
@@ -510,7 +515,10 @@ void VCLXAccessibleComponent::FillAccess
 		}
 
 		if ( pWindow->IsEnabled() )
+        {
 			rStateSet.AddState( accessibility::AccessibleStateType::ENABLED );
+            rStateSet.AddState( accessibility::AccessibleStateType::SENSITIVE );
+        }
 
         if ( pWindow->HasChildPathFocus() &&
              ( getAccessibleRole() == accessibility::AccessibleRole::FRAME || 
Index: toolkit/source/awt/vclxaccessiblelistitem.cxx
===================================================================
RCS file: /cvs/gsl/toolkit/source/awt/vclxaccessiblelistitem.cxx,v
retrieving revision 1.27
retrieving revision 1.27.32.1
diff -u -p -r1.27 -r1.27.32.1
--- toolkit/source/awt/vclxaccessiblelistitem.cxx	9 Sep 2005 13:06:59 -0000	1.27
+++ toolkit/source/awt/vclxaccessiblelistitem.cxx	5 Dec 2005 14:27:13 -0000	1.27.32.1
@@ -373,6 +373,7 @@ Reference< XAccessibleStateSet > SAL_CAL
         pStateSetHelper->AddState( AccessibleStateType::TRANSIENT );
         pStateSetHelper->AddState( AccessibleStateType::SELECTABLE );
         pStateSetHelper->AddState( AccessibleStateType::ENABLED );
+        pStateSetHelper->AddState( AccessibleStateType::SENSITIVE );
         if ( m_bSelected )
 			pStateSetHelper->AddState( AccessibleStateType::SELECTED );
 		if ( m_bVisible )
Index: toolkit/source/awt/vclxaccessiblemenuitem.cxx
===================================================================
RCS file: /cvs/gsl/toolkit/source/awt/vclxaccessiblemenuitem.cxx,v
retrieving revision 1.35
retrieving revision 1.35.32.1
diff -u -p -r1.35 -r1.35.32.1
--- toolkit/source/awt/vclxaccessiblemenuitem.cxx	9 Sep 2005 13:07:49 -0000	1.35
+++ toolkit/source/awt/vclxaccessiblemenuitem.cxx	16 Nov 2005 15:59:22 -0000	1.35.32.1
@@ -114,12 +114,8 @@ sal_Bool VCLXAccessibleMenuItem::IsHighl
 {
 	sal_Bool bHighlighted = sal_False;
 
-	if ( m_pParent )
-	{
-		sal_uInt16 nItemId = m_pParent->GetItemId( m_nItemPos );
-		if ( nItemId == m_pParent->GetCurItemId() )
-			bHighlighted = sal_True;
-	}
+    if ( m_pParent && m_pParent->IsHighlighted( m_nItemPos ) )
+        bHighlighted = sal_True;
 
 	return bHighlighted;
 }
Index: toolkit/source/awt/vclxaccessiblestatusbaritem.cxx
===================================================================
RCS file: /cvs/gsl/toolkit/source/awt/vclxaccessiblestatusbaritem.cxx,v
retrieving revision 1.6
retrieving revision 1.6.32.1
diff -u -p -r1.6 -r1.6.32.1
--- toolkit/source/awt/vclxaccessiblestatusbaritem.cxx	9 Sep 2005 13:09:29 -0000	1.6
+++ toolkit/source/awt/vclxaccessiblestatusbaritem.cxx	5 Dec 2005 14:27:13 -0000	1.6.32.1
@@ -203,6 +203,7 @@ void VCLXAccessibleStatusBarItem::SetIte
 void VCLXAccessibleStatusBarItem::FillAccessibleStateSet( utl::AccessibleStateSetHelper& rStateSet )
 {
 	rStateSet.AddState( AccessibleStateType::ENABLED );
+    rStateSet.AddState( AccessibleStateType::SENSITIVE );
 
 	rStateSet.AddState( AccessibleStateType::VISIBLE );
 
Index: toolkit/source/awt/vclxaccessibletabpage.cxx
===================================================================
RCS file: /cvs/gsl/toolkit/source/awt/vclxaccessibletabpage.cxx,v
retrieving revision 1.17
retrieving revision 1.17.32.1
diff -u -p -r1.17 -r1.17.32.1
--- toolkit/source/awt/vclxaccessibletabpage.cxx	9 Sep 2005 13:09:58 -0000	1.17
+++ toolkit/source/awt/vclxaccessibletabpage.cxx	5 Dec 2005 14:27:14 -0000	1.17.32.1
@@ -228,6 +228,7 @@ void VCLXAccessibleTabPage::Update( bool
 void VCLXAccessibleTabPage::FillAccessibleStateSet( utl::AccessibleStateSetHelper& rStateSet )
 {
 	rStateSet.AddState( AccessibleStateType::ENABLED );
+    rStateSet.AddState( AccessibleStateType::SENSITIVE );
 
 	rStateSet.AddState( AccessibleStateType::FOCUSABLE );
 
Index: toolkit/source/awt/vclxaccessibletoolboxitem.cxx
===================================================================
RCS file: /cvs/gsl/toolkit/source/awt/vclxaccessibletoolboxitem.cxx,v
retrieving revision 1.39
retrieving revision 1.38.32.2
diff -u -p -r1.39 -r1.38.32.2
--- toolkit/source/awt/vclxaccessibletoolboxitem.cxx	26 Jan 2006 17:54:59 -0000	1.39
+++ toolkit/source/awt/vclxaccessibletoolboxitem.cxx	30 Jan 2006 15:06:05 -0000	1.38.32.2
@@ -274,13 +274,21 @@ void VCLXAccessibleToolBoxItem::ToggleEn
 {
 	if ( m_pToolBox )
 	{
-		Any aOldValue, aNewValue;
+		Any aOldValue[2], aNewValue[2];
 	    const XubString& sText = m_pToolBox->GetItemText( m_nItemId );
 		if ( m_pToolBox->IsItemEnabled( m_nItemId ) )
-			aNewValue <<= AccessibleStateType::ENABLED;
+        {
+            aNewValue[0] <<= AccessibleStateType::SENSITIVE;
+            aNewValue[1] <<= AccessibleStateType::ENABLED;
+        }
 		else
-			aOldValue <<= AccessibleStateType::ENABLED;
-		NotifyAccessibleEvent( AccessibleEventId::NAME_CHANGED, aOldValue, aNewValue );
+        {
+            aOldValue[0] <<= AccessibleStateType::ENABLED;
+            aOldValue[1] <<= AccessibleStateType::SENSITIVE;
+        }
+
+        NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue[0], aNewValue[0] );
+        NotifyAccessibleEvent( AccessibleEventId::STATE_CHANGED, aOldValue[1], aNewValue[1] );
 	}
 }
 // -----------------------------------------------------------------------------
@@ -458,7 +466,10 @@ Reference< XAccessibleStateSet > SAL_CAL
         if ( m_bIndeterminate )
 	        pStateSetHelper->AddState( AccessibleStateType::INDETERMINATE );
 		if ( m_pToolBox->IsItemEnabled( m_nItemId ) )
+        {
 	        pStateSetHelper->AddState( AccessibleStateType::ENABLED );
+            pStateSetHelper->AddState( AccessibleStateType::SENSITIVE );
+        }
 		if ( m_pToolBox->IsItemVisible( m_nItemId ) )
 		{
 	        pStateSetHelper->AddState( AccessibleStateType::VISIBLE );
Index: toolkit/source/awt/vclxwindow.cxx
===================================================================
RCS file: /cvs/gsl/toolkit/source/awt/vclxwindow.cxx,v
retrieving revision 1.57
retrieving revision 1.57.10.1
diff -u -p -r1.57 -r1.57.10.1
--- toolkit/source/awt/vclxwindow.cxx	6 Feb 2006 13:00:26 -0000	1.57
+++ toolkit/source/awt/vclxwindow.cxx	17 Feb 2006 11:13:21 -0000	1.57.10.1
@@ -88,6 +88,9 @@
 #ifndef _TOOLKIT_AWT_VCLXACCESSIBLETABPAGEWINDOW_HXX_
 #include <toolkit/awt/vclxaccessibletabpagewindow.hxx>
 #endif
+#ifndef _TOOLKIT_AWT_VCLXACCESSIBLEFIXEDTEXT_HXX_
+#include <toolkit/awt/vclxaccessiblefixedtext.hxx>
+#endif
 #ifndef _TOOLKIT_HELPER_MACROS_HXX_
 #include <toolkit/helper/macros.hxx>
 #endif
@@ -133,12 +136,15 @@
 #include <toolkit/helper/solarrelease.hxx>
 #endif
 
+using namespace ::com::sun::star;
+
 using ::com::sun::star::style::VerticalAlignment;
 using ::com::sun::star::style::VerticalAlignment_TOP;
 using ::com::sun::star::style::VerticalAlignment_MIDDLE;
 using ::com::sun::star::style::VerticalAlignment_BOTTOM;
 using ::com::sun::star::style::VerticalAlignment_MAKE_FIXED_SIZE;
 
+
 //#define SYNCHRON_NOTIFICATION
     // define this for notifying mouse events synchronously when they happen
     // disadvantage: potential of deadlocks, since this means that the
@@ -876,47 +882,51 @@ void VCLXWindow::ProcessWindowEvent( con
     }
 }
 
-::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessibleContext > VCLXWindow::CreateAccessibleContext()
+uno::Reference< accessibility::XAccessibleContext > VCLXWindow::CreateAccessibleContext()
 {
-	::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessibleContext > xContext;
+    uno::Reference< accessibility::XAccessibleContext > xContext;
 
-	Window* pWindow = GetWindow();
-	if ( pWindow )
-	{
-		WindowType nType = pWindow->GetType();
+    Window* pWindow = GetWindow();
+    if ( pWindow )
+    {
+        WindowType nType = pWindow->GetType();
 
-		if ( nType == WINDOW_MENUBARWINDOW || pWindow->IsMenuFloatingWindow() || pWindow->IsToolbarFloatingWindow() )
-		{
-			::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > xAcc( pWindow->GetAccessible() );
-			if ( xAcc.is() )
-			{
-				::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessibleContext > xCont( xAcc->getAccessibleContext() );
-				if ( pWindow->GetType() == WINDOW_MENUBARWINDOW
-				     || ( xCont.is() && xCont->getAccessibleRole() == ::com::sun::star::accessibility::AccessibleRole::POPUP_MENU ) )
-				{
-					xContext = xCont;
-				}
-			}
-		}
-		else if ( nType == WINDOW_STATUSBAR )
-		{
-			xContext = (::com::sun::star::accessibility::XAccessibleContext*) new VCLXAccessibleStatusBar( this );
-		}
-		else if ( nType == WINDOW_TABCONTROL )
-		{
-			xContext = (::com::sun::star::accessibility::XAccessibleContext*) new VCLXAccessibleTabControl( this );
-		}
+        if ( nType == WINDOW_MENUBARWINDOW || pWindow->IsMenuFloatingWindow() || pWindow->IsToolbarFloatingWindow() )
+        {
+            uno::Reference< accessibility::XAccessible > xAcc( pWindow->GetAccessible() );
+            if ( xAcc.is() )
+            {
+                uno::Reference< accessibility::XAccessibleContext > xCont( xAcc->getAccessibleContext() );
+                if ( pWindow->GetType() == WINDOW_MENUBARWINDOW ||
+                     ( xCont.is() && xCont->getAccessibleRole() == accessibility::AccessibleRole::POPUP_MENU ) )
+                {
+                    xContext = xCont;
+                }
+            }
+        }
+        else if ( nType == WINDOW_STATUSBAR )
+        {
+            xContext = (accessibility::XAccessibleContext*) new VCLXAccessibleStatusBar( this );
+        }
+        else if ( nType == WINDOW_TABCONTROL )
+        {
+            xContext = (accessibility::XAccessibleContext*) new VCLXAccessibleTabControl( this );
+        }
         else if ( nType == WINDOW_TABPAGE && pWindow->GetAccessibleParentWindow() && pWindow->GetAccessibleParentWindow()->GetType() == WINDOW_TABCONTROL )
         {
-			xContext = (::com::sun::star::accessibility::XAccessibleContext*) new VCLXAccessibleTabPageWindow( this );
+            xContext = (accessibility::XAccessibleContext*) new VCLXAccessibleTabPageWindow( this );
         }
-		else
-		{
-			xContext = (::com::sun::star::accessibility::XAccessibleContext*) new VCLXAccessibleComponent( this );
-		}
-	}
+        else if ( nType == WINDOW_HELPTEXTWINDOW )
+        {
+            xContext = (accessibility::XAccessibleContext*) new VCLXAccessibleFixedText( this );  
+        }
+        else
+        {
+            xContext = (accessibility::XAccessibleContext*) new VCLXAccessibleComponent( this );
+        }
+    }
 
-	return xContext;
+    return xContext;
 }
 
 /*
cvs diff: Diffing toolkit/source/controls
cvs diff: Diffing toolkit/source/helper
cvs diff: Diffing toolkit/test
cvs diff: Diffing toolkit/test/accessibility
cvs diff: Diffing toolkit/test/accessibility/ov
cvs diff: Diffing toolkit/test/accessibility/tools
cvs diff: Diffing toolkit/util
cvs diff: Diffing toolkit/util/defs
Index: svx/source/accessibility/AccessibleContextBase.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/accessibility/AccessibleContextBase.cxx,v
retrieving revision 1.21
retrieving revision 1.21.172.1
diff -u -p -r1.21 -r1.21.172.1
--- svx/source/accessibility/AccessibleContextBase.cxx	8 Sep 2005 20:13:15 -0000	1.21
+++ svx/source/accessibility/AccessibleContextBase.cxx	6 Dec 2005 11:51:38 -0000	1.21.172.1
@@ -108,6 +108,7 @@ AccessibleContextBase::AccessibleContext
     if (pStateSet != NULL)
     {
         pStateSet->AddState (AccessibleStateType::ENABLED);
+        pStateSet->AddState (AccessibleStateType::SENSITIVE);
         pStateSet->AddState (AccessibleStateType::SHOWING);
         pStateSet->AddState (AccessibleStateType::VISIBLE);
         pStateSet->AddState (AccessibleStateType::FOCUSABLE);
Index: svx/source/accessibility/AccessibleControlShape.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/accessibility/AccessibleControlShape.cxx,v
retrieving revision 1.21
retrieving revision 1.21.168.1
diff -u -p -r1.21 -r1.21.168.1
--- svx/source/accessibility/AccessibleControlShape.cxx	8 Sep 2005 20:13:41 -0000	1.21
+++ svx/source/accessibility/AccessibleControlShape.cxx	6 Dec 2005 11:51:38 -0000	1.21.168.1
@@ -885,6 +885,7 @@ void AccessibleControlShape::initializeC
 	// we need to reset some states of the composed set, because they either do not apply
 	// for controls in alive mode, or are in the responsibility of the UNO-control, anyway
 	pComposedStates->RemoveState( AccessibleStateType::ENABLED );		// this is controlled by the UNO-control
+    pComposedStates->RemoveState( AccessibleStateType::SENSITIVE );		// this is controlled by the UNO-control
 	pComposedStates->RemoveState( AccessibleStateType::FOCUSABLE );		// this is controlled by the UNO-control
 	pComposedStates->RemoveState( AccessibleStateType::SELECTABLE );	// this does not hold for an alive UNO-control
 #if OSL_DEBUG_LEVEL > 0
Index: svx/source/accessibility/AccessibleEditableTextPara.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/accessibility/AccessibleEditableTextPara.cxx,v
retrieving revision 1.45
retrieving revision 1.43.172.3
diff -u -p -r1.45 -r1.43.172.3
--- svx/source/accessibility/AccessibleEditableTextPara.cxx	1 Feb 2006 14:59:29 -0000	1.45
+++ svx/source/accessibility/AccessibleEditableTextPara.cxx	6 Feb 2006 10:33:18 -0000	1.43.172.3
@@ -197,6 +197,7 @@ namespace accessibility
             pStateSet->AddState( AccessibleStateType::VISIBLE );
             pStateSet->AddState( AccessibleStateType::SHOWING );
             pStateSet->AddState( AccessibleStateType::ENABLED );
+            pStateSet->AddState( AccessibleStateType::SENSITIVE );
         }
         catch( const uno::Exception& ) {}
     }
Index: svx/source/accessibility/AccessibleFrameSelector.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/accessibility/AccessibleFrameSelector.cxx,v
retrieving revision 1.3
retrieving revision 1.3.172.1
diff -u -p -r1.3 -r1.3.172.1
--- svx/source/accessibility/AccessibleFrameSelector.cxx	8 Sep 2005 20:15:10 -0000	1.3
+++ svx/source/accessibility/AccessibleFrameSelector.cxx	6 Dec 2005 11:51:38 -0000	1.3.172.1
@@ -292,7 +292,10 @@ Reference< XAccessibleStateSet > AccFram
             pStateSetHelper->AddState(aStandardStates[nState++]);
         }
         if(mpFrameSel->IsEnabled())
+        {
             pStateSetHelper->AddState(AccessibleStateType::ENABLED);
+            pStateSetHelper->AddState(AccessibleStateType::SENSITIVE);
+        }
 
         sal_Bool bIsParent = meBorder == FRAMEBORDER_NONE;
         if(mpFrameSel->HasFocus() &&
Index: svx/source/accessibility/AccessibleImageBullet.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/accessibility/AccessibleImageBullet.cxx,v
retrieving revision 1.17
retrieving revision 1.17.172.1
diff -u -p -r1.17 -r1.17.172.1
--- svx/source/accessibility/AccessibleImageBullet.cxx	8 Sep 2005 20:15:49 -0000	1.17
+++ svx/source/accessibility/AccessibleImageBullet.cxx	6 Dec 2005 11:51:39 -0000	1.17.172.1
@@ -145,6 +145,7 @@ namespace accessibility
             pStateSet->AddState( AccessibleStateType::VISIBLE );
             pStateSet->AddState( AccessibleStateType::SHOWING );
             pStateSet->AddState( AccessibleStateType::ENABLED );
+            pStateSet->AddState( AccessibleStateType::SENSITIVE );
         }
         catch( const uno::Exception& ) {}
     }
Index: svx/source/accessibility/GraphCtlAccessibleContext.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/accessibility/GraphCtlAccessibleContext.cxx,v
retrieving revision 1.18
retrieving revision 1.18.168.1
diff -u -p -r1.18 -r1.18.168.1
--- svx/source/accessibility/GraphCtlAccessibleContext.cxx	8 Sep 2005 20:21:42 -0000	1.18
+++ svx/source/accessibility/GraphCtlAccessibleContext.cxx	6 Dec 2005 11:51:39 -0000	1.18.168.1
@@ -482,6 +482,7 @@ Reference< XAccessibleStateSet > SAL_CAL
 	else
 	{
 		// pStateSetHelper->AddState( AccessibleStateType::ENABLED );
+        // pStateSetHelper->AddState( AccessibleStateType::SENSITIVE );
 		pStateSetHelper->AddState( AccessibleStateType::FOCUSABLE );
 		if( mpControl->HasFocus() )
 			pStateSetHelper->AddState( AccessibleStateType::FOCUSED );
Index: svx/source/accessibility/charmapacc.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/accessibility/charmapacc.cxx,v
retrieving revision 1.9
retrieving revision 1.9.172.1
diff -u -p -r1.9 -r1.9.172.1
--- svx/source/accessibility/charmapacc.cxx	8 Sep 2005 20:23:00 -0000	1.9
+++ svx/source/accessibility/charmapacc.cxx	6 Dec 2005 11:51:39 -0000	1.9.172.1
@@ -251,7 +251,10 @@ Reference< XAccessibleStateSet > SAL_CAL
 		if ( mpParent->IsActive() )
 			pStateSet->AddState( AccessibleStateType::ACTIVE );
 		if ( mpParent->IsEnabled() )
+        {
 			pStateSet->AddState( AccessibleStateType::ENABLED );
+            pStateSet->AddState( AccessibleStateType::SENSITIVE );
+        }
 		if ( mpParent->IsReallyVisible() )
 			pStateSet->AddState( AccessibleStateType::VISIBLE );
     }
@@ -483,7 +486,10 @@ uno::Reference< accessibility::XAccessib
 		if ( m_pParent->getCharSetControl()->IsActive() )
 			pStateSet->AddState( AccessibleStateType::ACTIVE );
 		if ( m_pParent->getCharSetControl()->IsEnabled() )
-			pStateSet->AddState( AccessibleStateType::ENABLED );
+        {
+            pStateSet->AddState( AccessibleStateType::ENABLED );
+            pStateSet->AddState( AccessibleStateType::SENSITIVE );
+        }
 		if ( m_pParent->getCharSetControl()->IsReallyVisible() )
 			pStateSet->AddState( AccessibleStateType::VISIBLE );
 
Index: svx/source/accessibility/svxrectctaccessiblecontext.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/accessibility/svxrectctaccessiblecontext.cxx,v
retrieving revision 1.18
retrieving revision 1.18.172.1
diff -u -p -r1.18 -r1.18.172.1
--- svx/source/accessibility/svxrectctaccessiblecontext.cxx	8 Sep 2005 20:23:56 -0000	1.18
+++ svx/source/accessibility/svxrectctaccessiblecontext.cxx	6 Dec 2005 11:51:39 -0000	1.18.172.1
@@ -434,6 +434,7 @@ Reference< XAccessibleStateSet > SAL_CAL
 	if( IsAlive() )
 	{
 		// pStateSetHelper->AddState( AccessibleStateType::ENABLED );
+        // pStateSetHelper->AddState( AccessibleStateType::SENSITIVE );
 		pStateSetHelper->AddState( AccessibleStateType::FOCUSABLE );
 		if( mpRepr->HasFocus() )
 			pStateSetHelper->AddState( AccessibleStateType::FOCUSED );
@@ -1039,6 +1040,7 @@ Reference< XAccessibleStateSet > SAL_CAL
 		}
 
 		pStateSetHelper->AddState( AccessibleStateType::ENABLED );
+        pStateSetHelper->AddState( AccessibleStateType::SENSITIVE );
 		pStateSetHelper->AddState( AccessibleStateType::OPAQUE );
 		pStateSetHelper->AddState( AccessibleStateType::SELECTABLE );
 		pStateSetHelper->AddState( AccessibleStateType::SHOWING );
cvs diff: Diffing svx/source/customshapes
cvs diff: Diffing svx/source/dialog
cvs diff: Diffing svx/source/editeng
cvs diff: Diffing svx/source/engine3d
cvs diff: Diffing svx/source/fmcomp
cvs diff: Diffing svx/source/form
cvs diff: Diffing svx/source/gallery2
cvs diff: Diffing svx/source/gengal
cvs diff: Diffing svx/source/inc
cvs diff: Diffing svx/source/init
cvs diff: Diffing svx/source/intro
cvs diff: Diffing svx/source/items
cvs diff: Diffing svx/source/mnuctrls
cvs diff: Diffing svx/source/msfilter
cvs diff: Diffing svx/source/options
cvs diff: Diffing svx/source/outliner
cvs diff: Diffing svx/source/sdr
cvs diff: Diffing svx/source/sdr/animation
cvs diff: Diffing svx/source/sdr/contact
cvs diff: Diffing svx/source/sdr/event
cvs diff: Diffing svx/source/sdr/mixer
cvs diff: Diffing svx/source/sdr/properties
cvs diff: Diffing svx/source/src
cvs diff: Diffing svx/source/stbctrls
cvs diff: Diffing svx/source/svdraw
cvs diff: Diffing svx/source/svrtf
cvs diff: Diffing svx/source/svxlink
cvs diff: Diffing svx/source/tbxctrls
cvs diff: Diffing svx/source/toolbars
cvs diff: Diffing svx/source/unodialogs
cvs diff: Diffing svx/source/unodialogs/inc
cvs diff: Diffing svx/source/unodialogs/textconversiondlgs
cvs diff: Diffing svx/source/unodraw
cvs diff: Diffing svx/source/unoedit
cvs diff: Diffing svx/source/unogallery
cvs diff: Diffing svx/source/xml
cvs diff: Diffing svx/source/xoutdev
cvs diff: Diffing svx/uiconfig
cvs diff: Diffing svx/uiconfig/accelerator
cvs diff: Diffing svx/uiconfig/accelerator/en-GB
cvs diff: Diffing svx/uiconfig/accelerator/en-US
cvs diff: Diffing svx/uiconfig/accelerator/es
cvs diff: Diffing svx/util
cvs diff: Diffing svx/util/defs
Index: comphelper/source/misc/accessiblewrapper.cxx
===================================================================
RCS file: /cvs/util/comphelper/source/misc/accessiblewrapper.cxx,v
retrieving revision 1.9
retrieving revision 1.8.156.3
diff -u -p -r1.9 -r1.8.156.3
--- comphelper/source/misc/accessiblewrapper.cxx	8 Sep 2005 02:48:04 -0000	1.9
+++ comphelper/source/misc/accessiblewrapper.cxx	1 Mar 2006 12:12:20 -0000	1.8.156.3
@@ -151,6 +151,12 @@ namespace comphelper
 	{
 		Reference< XAccessible > xValue;
 
+		if( !_rxKey.is() )
+		{
+			// fprintf( stderr, "It was this path that was crashing stuff\n" );
+			return xValue;
+		}
+
 		// do we have this child in the cahce?
 		AccessibleMap::const_iterator aPos = m_aChildrenMap.find( _rxKey );
 		if ( m_aChildrenMap.end() != aPos )
cvs diff: Diffing comphelper/source/officeinstdir
cvs diff: Diffing comphelper/source/processfactory
cvs diff: Diffing comphelper/source/property
cvs diff: Diffing comphelper/source/streaming
cvs diff: Diffing comphelper/util
cvs diff: Diffing comphelper/util/defs
Index: vcl/inc/menu.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/menu.hxx,v
retrieving revision 1.35
retrieving revision 1.35.12.1
diff -u -p -r1.35 -r1.35.12.1
--- vcl/inc/menu.hxx	9 Sep 2005 11:09:19 -0000	1.35
+++ vcl/inc/menu.hxx	16 Nov 2005 15:57:55 -0000	1.35.12.1
@@ -379,6 +379,9 @@ public:
 
 	void				SetAccessibleDescription( USHORT nItemId, const XubString& rStr );
 	XubString			GetAccessibleDescription( USHORT nItemId ) const;
+    
+    // returns whether the item a position nItemPos is highlighted or not.
+    bool  IsHighlighted( USHORT nItemPos ) const;
 };
 
 // -----------
Index: vcl/inc/svapp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/svapp.hxx,v
retrieving revision 1.35
retrieving revision 1.35.12.1
diff -u -p -r1.35 -r1.35.12.1
--- vcl/inc/svapp.hxx	9 Sep 2005 11:29:11 -0000	1.35
+++ vcl/inc/svapp.hxx	20 Oct 2005 07:07:01 -0000	1.35.12.1
@@ -349,7 +349,7 @@ public:
     static void                 AddKeyListener( const Link& rKeyListener );
     static void                 RemoveKeyListener( const Link& rKeyListener );
     static void                 ImplCallEventListeners( ULONG nEvent, Window* pWin, void* pData );
-    static void                 ImplCallEventListeners( VclWindowEvent* pEvent );
+    static void                 ImplCallEventListeners( VclSimpleEvent* pEvent );
     static BOOL                 HandleKey( ULONG nEvent, Window *pWin, KeyEvent* pKeyEvent );
     
 	static ULONG                PostKeyEvent( ULONG nEvent, Window *pWin, KeyEvent* pKeyEvent );
cvs diff: Diffing vcl/prj
Index: vcl/prj/build.lst
===================================================================
RCS file: /cvs/gsl/vcl/prj/build.lst,v
retrieving revision 1.42
retrieving revision 1.41.72.2
diff -u -p -r1.42 -r1.41.72.2
--- vcl/prj/build.lst	30 Aug 2005 09:37:21 -0000	1.42
+++ vcl/prj/build.lst	21 Sep 2005 07:13:26 -0000	1.41.72.2
@@ -18,6 +18,7 @@ vc	vcl\unx\source\gdi						nmake	-	u	vc_
 vc	vcl\unx\source\window					nmake	-	u	vc__winu vc_unot NULL
 vc	vcl\unx\source\src						nmake	-	u	vc__srcu vc_unot NULL
 vc  vcl\unx\dummy							nmake   -   u   vc__du   vc_unot NULL
+vc  vcl\unx\gtk\a11y							nmake   -   u   vc__gtky vc_unot NULL
 vc  vcl\unx\gtk\app							nmake   -   u   vc__gtka vc_unot NULL
 vc  vcl\unx\gtk\window						nmake   -   u   vc__gtkw vc_unot NULL
 vc  vcl\unx\gtk\gdi 						nmake   -   u   vc__gtkg vc_unot NULL
@@ -30,5 +31,5 @@ vc	vcl\mac\source\app						nmake	-	m	vc_
 vc	vcl\mac\source\gdi						nmake	-	m	vc__gdim vc_unot NULL
 vc	vcl\mac\source\window					nmake	-	m	vc__winm vc_unot NULL
 vc	vcl\mac\source\src						nmake	-	m	vc__srcm vc_unot NULL
-vc	vcl\util								nmake	-	all	vc_util vc__plug.u vc__appa.u vc__appm.m vc__appu.u vc__appw.w vc__gdim.m vc__gdiu.u vc__gdiw.w vc__srcm.m vc__srcu.u vc__srcw.w vc__wina.u vc__winm.m vc__winu.u vc__winw.w vc__du.u vc__gtka.u vc__gtkw.u vc__gtkg.u vc__kde.u vc_app vc_ctrl vc_gdi vc_hlp vc_src vc_win vc_glyphs NULL
+vc	vcl\util								nmake	-	all	vc_util vc__plug.u vc__appa.u vc__appm.m vc__appu.u vc__appw.w vc__gdim.m vc__gdiu.u vc__gdiw.w vc__srcm.m vc__srcu.u vc__srcw.w vc__wina.u vc__winm.m vc__winu.u vc__winw.w vc__du.u vc__gtka.u vc__gtky.u vc__gtkw.u vc__gtkg.u vc__kde.u vc_app vc_ctrl vc_gdi vc_hlp vc_src vc_win vc_glyphs NULL
 vc	vcl\workben								nmake	-	all	vc_wrkb vc_util NULL
cvs diff: Diffing vcl/qa
cvs diff: Diffing vcl/qa/complex
cvs diff: Diffing vcl/qa/complex/memCheck
cvs diff: Diffing vcl/qa/complex/persistent_window_states
cvs diff: Diffing vcl/qa/testdocuments
cvs diff: Diffing vcl/source
cvs diff: Diffing vcl/source/app
Index: vcl/source/app/svapp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/svapp.cxx,v
retrieving revision 1.61
retrieving revision 1.58.10.7
diff -u -p -r1.61 -r1.58.10.7
--- vcl/source/app/svapp.cxx	7 Feb 2006 10:21:10 -0000	1.61
+++ vcl/source/app/svapp.cxx	16 Feb 2006 13:51:32 -0000	1.58.10.7
@@ -867,7 +867,7 @@ void Application::ImplCallEventListeners
 
 // -----------------------------------------------------------------------
 
-void Application::ImplCallEventListeners( VclWindowEvent* pEvent )
+void Application::ImplCallEventListeners( VclSimpleEvent* pEvent )
 {
     ImplSVData* pSVData = ImplGetSVData();
 
@@ -1227,7 +1227,7 @@ long    Application::GetTopWindowCount()
 {
     long nRet = 0;
     ImplSVData* pSVData = ImplGetSVData();
-    Window *pWin = pSVData->maWinData.mpFirstFrame;
+    Window *pWin = pSVData ? pSVData->maWinData.mpFirstFrame : NULL;
     while( pWin )
     {
         if( pWin->ImplGetWindow()->IsTopWindow() )
@@ -1243,7 +1243,7 @@ Window* Application::GetTopWindow( long 
 {
     long nIdx = 0;
     ImplSVData* pSVData = ImplGetSVData();
-    Window *pWin = pSVData->maWinData.mpFirstFrame;
+    Window *pWin = pSVData ? pSVData->maWinData.mpFirstFrame : NULL;
     while( pWin )
     {
         if( pWin->ImplGetWindow()->IsTopWindow() )
@@ -1868,10 +1868,12 @@ BOOL Application::IsAccessibilityEnabled
 
 BOOL InitAccessBridge( BOOL bShowCancel, BOOL &rCancelled )
 {
-    BOOL bRet = ImplInitAccessBridge( bShowCancel, rCancelled );
+    BOOL bRet = true;
 
-// There is no GUI to re-enable accessibility on Unix ..
+// Disable Java bridge on UNIX
 #ifndef UNX
+    bRet = ImplInitAccessBridge( bShowCancel, rCancelled );
+    
     if( !bRet && bShowCancel && !rCancelled )
     {
         // disable accessibility if the user chooses to continue
@@ -1881,7 +1883,7 @@ BOOL InitAccessBridge( BOOL bShowCancel,
         aSettings.SetMiscSettings( aMisc );
         Application::SetSettings( aSettings );
     }
-#endif
+#endif // !UNX
 
     return bRet;
 }
cvs diff: Diffing vcl/source/control
cvs diff: Diffing vcl/source/ex
cvs diff: Diffing vcl/source/gdi
cvs diff: Diffing vcl/source/glyphs
cvs diff: Diffing vcl/source/helper
cvs diff: Diffing vcl/source/src
cvs diff: Diffing vcl/source/unotypes
cvs diff: Diffing vcl/source/window
Index: vcl/source/window/menu.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/menu.cxx,v
retrieving revision 1.132
retrieving revision 1.127.12.6
diff -u -p -r1.132 -r1.127.12.6
--- vcl/source/window/menu.cxx	26 Jan 2006 18:10:24 -0000	1.132
+++ vcl/source/window/menu.cxx	30 Jan 2006 16:17:33 -0000	1.127.12.6
@@ -577,7 +577,6 @@ public:
     USHORT          GetPosInParent() const { return nPosInParent; }
 
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > CreateAccessible();
-    BOOL            IsTopmostApplicationMenu();
 };
 
 // To get the transparent mouse-over look, the closer is actually a toolbox
@@ -1112,6 +1111,13 @@ void Menu::ImplCallEventListeners( ULONG
 {
     VclMenuEvent aEvent( this, nEvent, nPos );
 
+    // This is needed by atk accessibility bridge
+    if ( nEvent == VCLEVENT_MENU_HIGHLIGHT )
+    {
+        ImplSVData* pSVData = ImplGetSVData();
+        pSVData->mpApp->ImplCallEventListeners( &aEvent );
+    }
+    
     if ( !maEventListeners.empty() )
         maEventListeners.Call( &aEvent );
 
@@ -2884,7 +2890,20 @@ BOOL Menu::GetSystemMenuData( SystemMenu
         return FALSE;
 }
 
-
+bool Menu::IsHighlighted( USHORT nItemPos ) const
+{
+    bool bRet = false;
+    
+    if( pWindow )
+    {
+        if( bIsMenuBar )
+            bRet = ( nItemPos == static_cast< MenuBarWindow * > (pWindow)->GetHighlightedItem() );
+        else
+            bRet = ( nItemPos == static_cast< MenuFloatingWindow * > (pWindow)->GetHighlightedItem() );
+    }
+    
+    return bRet;
+}
 
 // -----------
 // - MenuBar -
@@ -4406,9 +4425,11 @@ void MenuFloatingWindow::KeyInput( const
             else
             {
 				StopExecute();
-                MenuFloatingWindow* pFloat = ((PopupMenu*)pMenu->pStartedFrom)->ImplGetFloatingWindow();
+                PopupMenu* pPopupMenu = (PopupMenu*)pMenu->pStartedFrom;
+                MenuFloatingWindow* pFloat = pPopupMenu->ImplGetFloatingWindow();
                 pFloat->GrabFocus();
                 pFloat->KillActivePopup();
+                pPopupMenu->pStartedFrom->ImplCallHighlight(pFloat->nHighlightedItem);
             }
 		}
 		break;
@@ -4622,18 +4643,12 @@ void MenuFloatingWindow::Command( const 
 {
 	::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > xAcc;
 
-	if ( pMenu )
+	if ( pMenu && !pMenu->pStartedFrom )
 		xAcc = pMenu->GetAccessible();
 
 	return xAcc;
 }
 
-
-BOOL MenuFloatingWindow::IsTopmostApplicationMenu()
-{
-    return (!pMenu->pStartedFrom) ? TRUE : FALSE;
-}
-
 MenuBarWindow::MenuBarWindow( Window* pParent ) :
     Window( pParent, 0 ),
     aCloser( this ),
cvs diff: Diffing vcl/test
cvs diff: Diffing vcl/unx
cvs diff: Diffing vcl/unx/dummy
cvs diff: Diffing vcl/unx/gtk
cvs diff: Diffing vcl/unx/gtk/a11y
Index: vcl/unx/gtk/a11y/TODO
===================================================================
RCS file: vcl/unx/gtk/a11y/TODO
diff -N vcl/unx/gtk/a11y/TODO
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/TODO	31 May 2005 14:08:21 -0000	1.1.2.6
@@ -0,0 +1,49 @@
+cws 'atkbridge'
+#Issue number: i#47890#
+Submitted by: mmeeks
+
+Hacked up prototype of atk bridge
+
+
+Serious problems
+    + Threading/locking:
+	+ incoming CORBA calls & the GDK lock
+		+ how are these being processed & on what thread ?
+		+ are we holding the GDK_THREADS lock ?
+		+ can we even do that ?
+		+ is it really necessary to be thread safe ?
+		+ how does this work in combination with the (unsafe) GAIL code ?
+		+ what should incoming CORBA calls be doing ?
+			+ esp. since we can't tell if they're coming from
+			  in-proc or not either [ though this is unlikely ]
+
+
+Test:
+	+ in-line text editing, does the TEXT_CHANGED signal get it right,
+	+ why not copy/paste/delete etc. ?
+		+ check vs. writer & other bits ...
+	+ AtkSelection
+	+ AtkHyper*
+
+* At-poke
+	+ implement non-gui mode - for to-console event logging
+	+ logging
+		+ more detail from remaining events
+	+ add a Tree navigation thing instead (?)
+		+ poke a sub-child (?)
+		+ embed a tree widget inside the tree view ?
+	+ AtkHyperText testing (?)
+
+
+Known bugs:
+	+ AtkText
+		+ selection interface - multiple selections ?
+		+ word boundary issues
+			+ copy AccessibleTextImpl.java's getAfterIndex eg.
+	+ the 'getFoo' methods need to use UNO_QUERY_THROW &
+	  throw an exception to avoid null pointer dereferences.
+	+ AtkAttributeSet (etc.)
+	+ AtkEditableText
+	+ finish/test AtkTable
+	+ HyperLink 'link_activated', HyperText 'link_selected' (?)
+	+ tooltips create new toplevels with broken roles.
Index: vcl/unx/gtk/a11y/atkaction.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkaction.cxx
diff -N vcl/unx/gtk/a11y/atkaction.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkaction.cxx	15 Feb 2006 10:59:20 -0000	1.1.2.7
@@ -0,0 +1,287 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "atkwrapper.hxx"
+
+#include <com/sun/star/accessibility/XAccessibleAction.hpp>
+#include <com/sun/star/accessibility/XAccessibleKeyBinding.hpp>
+
+#include <com/sun/star/awt/Key.hpp>
+#include <com/sun/star/awt/KeyModifier.hpp>
+
+#include <rtl/strbuf.hxx>
+#include <algorithm>
+#include <map>
+
+#include <stdio.h>
+
+using namespace ::com::sun::star;
+
+// FIXME
+static G_CONST_RETURN gchar *
+getAsConst( const rtl::OString& rString )
+{
+    static const int nMax = 10;
+    static rtl::OString aUgly[nMax];
+    static int nIdx = 0;
+    nIdx = (nIdx + 1) % nMax;
+    aUgly[nIdx] = rString;
+    return aUgly[ nIdx ];
+}
+
+static accessibility::XAccessibleAction*
+        getAction( AtkAction *action ) throw (uno::RuntimeException)
+{
+    AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( action );
+    
+    if( pWrap )
+    {
+        if( !pWrap->mpAction && pWrap->mpContext )
+        {
+            uno::Any any = pWrap->mpContext->queryInterface( accessibility::XAccessibleAction::static_type(NULL) );
+            pWrap->mpAction = reinterpret_cast< accessibility::XAccessibleAction * > (any.pReserved);
+            pWrap->mpAction->acquire();
+        }
+
+        return pWrap->mpAction;
+    }
+
+    return NULL;
+}
+
+extern "C" {
+
+static gboolean
+action_wrapper_do_action (AtkAction *action,
+                          gint       i)
+{
+    try {
+        accessibility::XAccessibleAction* pAction = getAction( action );
+        if( pAction )
+            return pAction->doAccessibleAction( i );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in doAccessibleAction()" );
+    }
+
+    return FALSE;
+}
+
+static gint
+action_wrapper_get_n_actions (AtkAction *action)
+{
+    try {
+        accessibility::XAccessibleAction* pAction = getAction( action );
+        if( pAction )
+            return pAction->getAccessibleActionCount();
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleActionCount()" );
+    }
+
+    return 0;
+}
+
+static G_CONST_RETURN gchar *
+action_wrapper_get_description (AtkAction *action,
+                                gint       i)
+{
+    // GAIL implement this only for cells
+    g_warning( "Not implemented: get_description()" );
+    return "";
+}
+
+static G_CONST_RETURN gchar *
+action_wrapper_get_localized_name (AtkAction *action,
+                                   gint       i)
+{
+    // GAIL doesn't implement this as well
+    g_warning( "Not implemented: get_localized_name()" );
+    return "";
+}
+
+#define ACTION_NAME_PAIR( OOoName, AtkName ) \
+    std::pair< const rtl::OUString, const gchar * > ( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( OOoName ) ), AtkName )
+
+static G_CONST_RETURN gchar *
+action_wrapper_get_name (AtkAction *action,
+                         gint       i)
+{
+    static std::map< rtl::OUString, const gchar * > aNameMap;
+    
+    if( aNameMap.empty() )
+    {
+        aNameMap.insert( ACTION_NAME_PAIR( "click", "click" ) );
+        aNameMap.insert( ACTION_NAME_PAIR( "select", "click" ) );
+        aNameMap.insert( ACTION_NAME_PAIR( "togglePopup", "push" ) );
+    }
+
+    try {
+        accessibility::XAccessibleAction* pAction = getAction( action );
+        if( pAction )
+        {
+            std::map< rtl::OUString, const gchar * >::iterator iter;
+            
+            rtl::OUString aDesc( pAction->getAccessibleActionDescription( i ) );
+            
+            iter = aNameMap.find( aDesc );
+            if( iter != aNameMap.end() )
+                return iter->second;
+            
+            std::pair< const rtl::OUString, const gchar * > aNewVal( aDesc, 
+                g_strdup( OUStringToConstGChar(aDesc) ) );
+            
+            if( aNameMap.insert( aNewVal ).second );
+                return aNewVal.second;
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleActionDescription()" );
+    }
+
+    return "";
+}
+
+/* 
+*  GNOME Expects a string in the format:
+*  
+*  <nmemonic>;<full-path>;<accelerator>
+*  
+*  The keybindings in <full-path> should be separated by ":"
+*/
+
+static inline void
+appendKeyStrokes(rtl::OStringBuffer& rBuffer, const uno::Sequence< awt::KeyStroke >& rKeyStrokes)
+{
+    for( sal_Int32 i = 0; i < rKeyStrokes.getLength(); i++ )
+    {
+        if( rKeyStrokes[i].Modifiers &  awt::KeyModifier::SHIFT )
+            rBuffer.append("<Shift>");
+        if( rKeyStrokes[i].Modifiers &  awt::KeyModifier::MOD1 )
+            rBuffer.append("<Control>");
+        if( rKeyStrokes[i].Modifiers &  awt::KeyModifier::MOD2 )
+            rBuffer.append("<Alt>");
+        
+        if( ( rKeyStrokes[i].KeyCode >= awt::Key::A ) && ( rKeyStrokes[i].KeyCode <= awt::Key::Z ) )
+            rBuffer.append( (sal_Char) ( 'a' + ( rKeyStrokes[i].KeyCode - awt::Key::A ) ) );
+        else
+        {
+            sal_Char c = '\0';
+            
+            switch( rKeyStrokes[i].KeyCode )
+            {
+                case awt::Key::TAB:      c = '\t'; break;
+                case awt::Key::SPACE:    c = ' '; break;
+                case awt::Key::ADD:      c = '+'; break;
+                case awt::Key::SUBTRACT: c = '-'; break;
+                case awt::Key::MULTIPLY: c = '*'; break;
+                case awt::Key::DIVIDE:   c = '/'; break;
+                case awt::Key::POINT:    c = '.'; break;
+                case awt::Key::COMMA:    c = ','; break;
+                case awt::Key::LESS:     c = '<'; break;
+                case awt::Key::GREATER:  c = '>'; break;
+                case awt::Key::EQUAL:    c = '='; break;
+                case 0:
+                    break;
+                default:
+                    g_warning( "Unmapped KeyCode: %d", rKeyStrokes[i].KeyCode );
+                    break;
+            }
+            
+            if( c != '\0' )
+                rBuffer.append( c );
+        }
+    }
+}
+
+
+static G_CONST_RETURN gchar *
+action_wrapper_get_keybinding (AtkAction *action,
+                               gint       i)
+{
+    try {
+        accessibility::XAccessibleAction* pAction = getAction( action );
+        if( pAction )
+        {
+            uno::Reference< accessibility::XAccessibleKeyBinding > xBinding( pAction->getAccessibleActionKeyBinding( i ));
+            
+            if( xBinding.is() )
+            {
+                rtl::OStringBuffer aRet;
+                
+                sal_Int32 nmax = std::min( xBinding->getAccessibleKeyBindingCount(), (sal_Int32) 3 );
+                for( sal_Int32 n = 0; n < nmax; n++ )
+                {
+                    appendKeyStrokes( aRet,  xBinding->getAccessibleKeyBinding( n ) );
+                    
+                    if( n < 2 )
+                        aRet.append( (sal_Char) ';' );
+                }
+                
+                // !! FIXME !! remember keystroke in wrapper object ?
+                return getAsConst( aRet.makeStringAndClear() );
+            }
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in get_keybinding()" );
+    }
+
+    return "";
+}
+
+static gboolean
+action_wrapper_set_description (AtkAction   *action,
+                                gint         i,
+                                const gchar *desc)
+{
+    return FALSE;
+}
+
+} // extern "C"
+
+void
+actionIfaceInit (AtkActionIface *iface)
+{
+  g_return_if_fail (iface != NULL);
+
+  iface->do_action = action_wrapper_do_action;
+  iface->get_n_actions = action_wrapper_get_n_actions;
+//  iface->get_description = action_wrapper_get_description;
+  iface->get_keybinding = action_wrapper_get_keybinding;
+  iface->get_name = action_wrapper_get_name;
+//  iface->get_localized_name = action_wrapper_get_localized_name;
+  iface->set_description = action_wrapper_set_description;
+}
Index: vcl/unx/gtk/a11y/atkbridge.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkbridge.cxx
diff -N vcl/unx/gtk/a11y/atkbridge.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkbridge.cxx	15 Feb 2006 10:59:21 -0000	1.1.2.2
@@ -0,0 +1,56 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include <plugins/gtk/atkbridge.hxx>
+#include <plugins/gtk/gtkframe.hxx>
+
+#include "atkfactory.hxx"
+#include "atkutil.hxx"
+#include "atkwindow.hxx"
+
+void InitAtkBridge(void)
+{
+    /* Initialize the AtkUtilityWrapper class */
+    g_type_class_unref( g_type_class_ref( OOO_TYPE_ATK_UTIL ) );
+    
+    /* Initialize the GailWindow wrapper class */
+    g_type_class_unref( g_type_class_ref( OOO_TYPE_WINDOW_WRAPPER ) );
+    
+    /* Register AtkObject wrapper factory */
+    AtkRegistry * registry = atk_get_default_registry();
+    if( registry)
+        atk_registry_set_factory_type( registry, OOO_TYPE_FIXED, OOO_TYPE_WRAPPER_FACTORY );
+}
+
Index: vcl/unx/gtk/a11y/atkcomponent.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkcomponent.cxx
diff -N vcl/unx/gtk/a11y/atkcomponent.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkcomponent.cxx	15 Feb 2006 10:58:57 -0000	1.1.2.8
@@ -0,0 +1,397 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "atkwrapper.hxx"
+
+#include <com/sun/star/accessibility/XAccessibleComponent.hpp>
+
+#ifdef ENABLE_TRACING
+#include <stdio.h>
+#endif
+
+using namespace ::com::sun::star;
+
+static accessibility::XAccessibleComponent*
+    getComponent( AtkComponent *pComponent ) throw (uno::RuntimeException)
+{
+    AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( pComponent );
+    if( pWrap )
+    {
+        if( !pWrap->mpComponent && pWrap->mpContext )
+        {
+            uno::Any any = pWrap->mpContext->queryInterface( accessibility::XAccessibleComponent::static_type(NULL) );
+            pWrap->mpComponent = reinterpret_cast< accessibility::XAccessibleComponent * > (any.pReserved);
+            pWrap->mpComponent->acquire();
+        }
+        
+        return pWrap->mpComponent;
+    }
+    
+    return NULL;
+}
+
+/*****************************************************************************/
+
+static awt::Point
+translatePoint( accessibility::XAccessibleComponent *pComponent, 
+                gint x, gint y, AtkCoordType t)
+{
+    awt::Point aOrigin( 0, 0 );
+    if( t == ATK_XY_SCREEN )
+        awt::Point aOrigin = pComponent->getLocationOnScreen();
+
+#ifdef ENABLE_TRACING
+    fprintf(stderr, "coordinates ( %u, %u ) translated to: ( %u, %u )\n", 
+        x, y, x - aOrigin.X, y - aOrigin.Y);
+#endif
+
+    return awt::Point( x - aOrigin.X, y - aOrigin.Y );
+}
+
+/*****************************************************************************/
+
+extern "C" {
+
+static gboolean
+component_wrapper_grab_focus (AtkComponent *component)
+{
+    try
+    {
+        accessibility::XAccessibleComponent* pComponent = getComponent( component );
+        if( pComponent )
+        {
+            pComponent->grabFocus();
+            return TRUE;
+        }
+    }
+    catch( const uno::Exception &e )
+    {
+        g_warning( "Exception in grabFocus()" );
+    }
+    
+    return FALSE;
+}
+
+/*****************************************************************************/
+
+static gboolean
+component_wrapper_contains (AtkComponent *component,
+                            gint          x,
+                            gint          y,
+                            AtkCoordType  coord_type)
+{
+    try
+    {
+        accessibility::XAccessibleComponent* pComponent = getComponent( component );
+        if( pComponent )
+            return pComponent->containsPoint( translatePoint( pComponent, x, y, coord_type ) );
+    }
+    catch( const uno::Exception &e )
+    {
+        g_warning( "Exception in containsPoint()" );
+    }
+    
+    return FALSE;
+}
+
+/*****************************************************************************/
+
+static AtkObject *
+component_wrapper_ref_accessible_at_point (AtkComponent *component,
+                                           gint          x,
+                                           gint          y,
+                                           AtkCoordType  coord_type)
+{
+    try
+    {
+        accessibility::XAccessibleComponent* pComponent = getComponent( component );
+        
+        if( pComponent )
+        {
+            uno::Reference< accessibility::XAccessible > xAccessible;
+            xAccessible = pComponent->getAccessibleAtPoint(
+                translatePoint( pComponent, x, y, coord_type ) );
+            
+#ifdef ENABLE_TRACING
+            fprintf(stderr, "getAccessibleAtPoint( %u, %u ) returned %p\n",
+              x, y, xAccessible.get());
+            
+            uno::Reference< accessibility::XAccessibleComponent > xComponent(
+                xAccessible->getAccessibleContext(), uno::UNO_QUERY );
+            
+            if( xComponent.is() )
+            {
+                awt::Rectangle rect = xComponent->getBounds();
+                fprintf(stderr, "%p->getBounds() returned: ( %u, %u, %u, %u )\n",
+                    xAccessible.get(), rect.X, rect.Y, rect.Width, rect.Height );
+            }
+#endif
+
+            return atk_object_wrapper_ref( xAccessible );
+        }
+    }
+    catch( const uno::Exception &e ) 
+    {
+        g_warning( "Exception in getAccessibleAtPoint()" );
+    }
+    
+    return NULL;
+}
+
+/*****************************************************************************/
+
+static void
+component_wrapper_get_position (AtkComponent   *component,
+                                gint           *x,
+                                gint           *y,
+                                AtkCoordType   coord_type)
+{
+    try
+    {
+        accessibility::XAccessibleComponent* pComponent = getComponent( component );
+        if( pComponent )
+        {
+            awt::Point aPos;
+            
+            if( coord_type == ATK_XY_SCREEN )
+                aPos = pComponent->getLocationOnScreen();
+            else
+                aPos = pComponent->getLocation();
+            
+            *x = aPos.X;
+            *y = aPos.Y;
+            
+#ifdef ENABLE_TRACING
+            fprintf(stderr, "getLocation[OnScreen]() returned: ( %u, %u )\n", *x, *y );
+#endif
+        }
+    }
+    catch( const uno::Exception &e ) 
+    {
+        g_warning( "Exception in getLocation[OnScreen]()" );
+    }
+}
+
+/*****************************************************************************/
+
+static void
+component_wrapper_get_size (AtkComponent   *component,
+                            gint           *width,
+                            gint           *height)
+{
+    try
+    {
+        accessibility::XAccessibleComponent* pComponent = getComponent( component );
+        if( pComponent )
+        {
+            awt::Size aSize = pComponent->getSize();
+            *width = aSize.Width;
+            *height = aSize.Height;
+            
+#ifdef ENABLE_TRACING
+            fprintf(stderr, "getSize() returned: ( %u, %u )\n", *width, *height );
+#endif
+        }
+    }
+    catch( const uno::Exception &e ) 
+    {
+        g_warning( "Exception in getSize()" );
+    }
+}
+
+/*****************************************************************************/
+
+static void
+component_wrapper_get_extents (AtkComponent *component,
+                               gint         *x,
+                               gint         *y,
+                               gint         *width,
+                               gint         *height,
+                               AtkCoordType  coord_type)
+{
+    component_wrapper_get_position( component, x, y, coord_type );
+    component_wrapper_get_size( component, width, height );
+}
+
+/*****************************************************************************/
+
+static gboolean
+component_wrapper_set_extents (AtkComponent   *component,
+                     gint           x,
+                     gint           y,
+                     gint           width,
+                     gint           height,
+                     AtkCoordType   coord_type)
+{
+    g_warning( "AtkComponent::set_extents unimplementable" );
+    return FALSE;
+}
+
+/*****************************************************************************/
+
+static gboolean
+component_wrapper_set_position (AtkComponent   *component,
+                      gint           x,
+                      gint           y,
+                      AtkCoordType   coord_type)
+{
+    g_warning( "AtkComponent::set_position unimplementable" );
+    return FALSE;
+}
+
+/*****************************************************************************/
+
+static gboolean
+component_wrapper_set_size (AtkComponent   *component,
+                  gint           width,
+                  gint           height)
+{
+    g_warning( "AtkComponent::set_size unimplementable" );
+    return FALSE;
+}
+
+/*****************************************************************************/
+
+static AtkLayer
+component_wrapper_get_layer (AtkComponent   *component)
+{
+    AtkRole role = atk_object_get_role( ATK_OBJECT( component ) );
+    AtkLayer layer = ATK_LAYER_WIDGET;
+    
+    switch (role)
+    {
+        case ATK_ROLE_POPUP_MENU:
+        case ATK_ROLE_MENU_ITEM:
+        case ATK_ROLE_CHECK_MENU_ITEM:
+        case ATK_ROLE_SEPARATOR:
+        case ATK_ROLE_LIST_ITEM:
+            layer = ATK_LAYER_POPUP;
+            break;
+        case ATK_ROLE_MENU:
+            {
+                AtkObject * parent = atk_object_get_parent( ATK_OBJECT( component ) );
+                if( atk_object_get_role( parent ) != ATK_ROLE_MENU_BAR )
+                    layer = ATK_LAYER_POPUP;
+            }
+            break;
+        
+        case ATK_ROLE_LIST:
+            {
+                AtkObject * parent = atk_object_get_parent( ATK_OBJECT( component ) );
+                if( atk_object_get_role( parent ) == ATK_ROLE_COMBO_BOX )
+                    layer = ATK_LAYER_POPUP;
+            }
+            break;
+        
+        default:
+            ;
+    }
+    
+    return layer;
+}
+
+/*****************************************************************************/
+
+static gint
+component_wrapper_get_mdi_zorder (AtkComponent   *component)
+{
+    // only needed for ATK_LAYER_MDI (not used) or ATK_LAYER_WINDOW (inherited from GAIL)
+    return G_MININT;
+}
+
+/*****************************************************************************/
+
+// This code is mostly stolen from libgail ..
+
+static guint
+component_wrapper_add_focus_handler (AtkComponent    *component,
+                                     AtkFocusHandler  handler)
+{
+    GSignalMatchType match_type;
+    gulong ret;
+    guint signal_id;
+
+    match_type = (GSignalMatchType) (G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC);
+    signal_id = g_signal_lookup( "focus-event", ATK_TYPE_OBJECT );
+
+    ret = g_signal_handler_find( component, match_type, signal_id, 0, NULL,
+                                 (gpointer) handler, NULL);
+    if (!ret)
+    {
+        return g_signal_connect_closure_by_id (component,
+                                               signal_id, 0,
+                                               g_cclosure_new (
+                                               G_CALLBACK (handler), NULL,
+                                               (GClosureNotify) NULL),
+                                               FALSE);
+    }
+    else
+    {
+        return 0;
+    }
+}
+
+/*****************************************************************************/
+
+static void
+component_wrapper_remove_focus_handler (AtkComponent  *component,
+                                        guint         handler_id)
+{
+    g_signal_handler_disconnect (component, handler_id);
+}
+
+/*****************************************************************************/
+
+} // extern "C"
+
+void
+componentIfaceInit (AtkComponentIface *iface)
+{
+  g_return_if_fail (iface != NULL);
+
+  iface->add_focus_handler = component_wrapper_add_focus_handler;
+  iface->contains = component_wrapper_contains;
+  iface->get_extents = component_wrapper_get_extents;
+  iface->get_layer = component_wrapper_get_layer;
+  iface->get_mdi_zorder = component_wrapper_get_mdi_zorder;
+  iface->get_position = component_wrapper_get_position;
+  iface->get_size = component_wrapper_get_size;
+  iface->grab_focus = component_wrapper_grab_focus;
+  iface->ref_accessible_at_point = component_wrapper_ref_accessible_at_point;
+  iface->remove_focus_handler = component_wrapper_remove_focus_handler;
+  iface->set_extents = component_wrapper_set_extents;
+  iface->set_position = component_wrapper_set_position;
+  iface->set_size = component_wrapper_set_size;
+}
Index: vcl/unx/gtk/a11y/atkeditabletext.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkeditabletext.cxx
diff -N vcl/unx/gtk/a11y/atkeditabletext.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkeditabletext.cxx	15 Feb 2006 10:59:21 -0000	1.1.2.7
@@ -0,0 +1,207 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "atkwrapper.hxx"
+#include "atktextattributes.hxx"
+
+#include <com/sun/star/accessibility/XAccessibleEditableText.hpp>
+#include <com/sun/star/accessibility/TextSegment.hpp>
+
+// #include <functional>
+// #include <hash_map>
+
+#include <stdio.h>
+#include <string.h>
+
+using namespace ::com::sun::star;
+
+static accessibility::XAccessibleEditableText*
+    getEditableText( AtkEditableText *pEditableText ) throw (uno::RuntimeException)
+{
+    AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( pEditableText );
+    if( pWrap )
+    {
+        if( !pWrap->mpEditableText && pWrap->mpContext )
+        {
+            uno::Any any = pWrap->mpContext->queryInterface( accessibility::XAccessibleEditableText::static_type(NULL) );
+            pWrap->mpEditableText = reinterpret_cast< accessibility::XAccessibleEditableText * > (any.pReserved);
+            pWrap->mpEditableText->acquire();
+        }
+        
+        return pWrap->mpEditableText;
+    }
+    
+    return NULL;
+}
+
+
+/*****************************************************************************/
+
+extern "C" { 
+
+static gboolean
+editable_text_wrapper_set_run_attributes( AtkEditableText  *text,
+                                          AtkAttributeSet  *attribute_set,
+                                          gint              nStartOffset,
+                                          gint              nEndOffset)
+{
+    try {
+        accessibility::XAccessibleEditableText* pEditableText = getEditableText( text );
+        if( pEditableText )
+        {
+            uno::Sequence< beans::PropertyValue > aAttributeList;
+
+            if( attribute_set_map_to_property_values( attribute_set, aAttributeList ) )
+                return pEditableText->setAttributes(nStartOffset, nEndOffset, aAttributeList);
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in setAttributes()" );
+    }
+
+    return FALSE;
+}
+
+static void
+editable_text_wrapper_set_text_contents( AtkEditableText  *text,
+                                         const gchar      *string )
+{
+    try {
+        accessibility::XAccessibleEditableText* pEditableText = getEditableText( text );
+        if( pEditableText )
+        {
+            rtl::OUString aString ( string, strlen(string), RTL_TEXTENCODING_UTF8 );
+            pEditableText->setText( aString );
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in setText()" );
+    }
+}
+
+static void
+editable_text_wrapper_insert_text( AtkEditableText  *text,
+                                   const gchar      *string,
+                                   gint             length,
+                                   gint             *pos )
+{
+    try {
+        accessibility::XAccessibleEditableText* pEditableText = getEditableText( text );
+        if( pEditableText )
+        {
+            rtl::OUString aString ( string, length, RTL_TEXTENCODING_UTF8 );
+            if( pEditableText->insertText( aString, *pos ) )
+                *pos += length;
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in insertText()" );
+    }
+}
+
+static void
+editable_text_wrapper_cut_text( AtkEditableText  *text,
+                                gint             start,
+                                gint             end )
+{
+    try {
+        accessibility::XAccessibleEditableText* pEditableText = getEditableText( text );
+        if( pEditableText )
+            pEditableText->cutText( start, end );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in cutText()" );
+    }
+}
+
+static void
+editable_text_wrapper_delete_text( AtkEditableText  *text,
+                                   gint             start,
+                                   gint             end )
+{
+    try {
+        accessibility::XAccessibleEditableText* pEditableText = getEditableText( text );
+        if( pEditableText )
+            pEditableText->deleteText( start, end );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in deleteText()" );
+    }
+}
+
+static void
+editable_text_wrapper_paste_text( AtkEditableText  *text,
+                                  gint             pos )
+{
+    try {
+        accessibility::XAccessibleEditableText* pEditableText = getEditableText( text );
+        if( pEditableText )
+            pEditableText->pasteText( pos );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in pasteText()" );
+    }
+}
+
+static void
+editable_text_wrapper_copy_text( AtkEditableText  *text,
+                                 gint             start,
+                                 gint             end )
+{
+    try {
+        accessibility::XAccessibleEditableText* pEditableText = getEditableText( text );
+        if( pEditableText )
+            pEditableText->copyText( start, end );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in copyText()" );
+    }
+}
+
+} // extern "C"
+
+void
+editableTextIfaceInit (AtkEditableTextIface *iface)
+{
+  g_return_if_fail (iface != NULL);
+
+  iface->set_text_contents = editable_text_wrapper_set_text_contents;
+  iface->insert_text = editable_text_wrapper_insert_text;
+  iface->copy_text = editable_text_wrapper_copy_text;
+  iface->cut_text = editable_text_wrapper_cut_text;
+  iface->delete_text = editable_text_wrapper_delete_text;
+  iface->paste_text = editable_text_wrapper_paste_text;
+  iface->set_run_attributes = editable_text_wrapper_set_run_attributes;
+}
Index: vcl/unx/gtk/a11y/atkfactory.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkfactory.cxx
diff -N vcl/unx/gtk/a11y/atkfactory.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkfactory.cxx	15 Feb 2006 10:59:22 -0000	1.1.2.9
@@ -0,0 +1,166 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include <plugins/gtk/gtkframe.hxx>
+#include "atkwrapper.hxx"
+#include "atkfactory.hxx"
+
+using namespace ::com::sun::star;
+
+extern "C" {
+
+/*
+ *  Instances of this dummy object class are returned whenever we have to 
+ *  create an AtkObject, but can't touch the OOo object anymore since it
+ *  is already disposed.
+ */
+ 
+static AtkStateSet *
+noop_wrapper_ref_state_set( AtkObject *pObject )
+{
+    AtkStateSet *state_set = atk_state_set_new();
+    atk_state_set_add_state( state_set, ATK_STATE_DEFUNCT );
+    return state_set;
+}
+
+static void
+atk_noop_object_wrapper_class_init(AtkNoOpObjectClass *klass)
+{
+    AtkObjectClass *atk_class = ATK_OBJECT_CLASS( klass );
+    atk_class->ref_state_set = noop_wrapper_ref_state_set;
+}
+
+static GType
+atk_noop_object_wrapper_get_type(void)
+{
+    static GType type = 0;
+
+    if (!type)
+    {
+        static const GTypeInfo typeInfo =
+        {
+            sizeof (AtkNoOpObjectClass),
+            (GBaseInitFunc) NULL,
+            (GBaseFinalizeFunc) NULL,
+            (GClassInitFunc) atk_noop_object_wrapper_class_init,
+            (GClassFinalizeFunc) NULL,
+            NULL,
+            sizeof (AtkObjectWrapper),
+            0,
+            (GInstanceInitFunc) NULL,
+        } ;
+        
+        type = g_type_register_static (ATK_TYPE_OBJECT, "OOoAtkNoOpObj", &typeInfo, (GTypeFlags)0) ;
+  }
+  return type;
+}
+    
+AtkObject*
+atk_noop_object_wrapper_new()
+{
+  AtkObject *accessible;
+
+  accessible = (AtkObject *) g_object_new (atk_noop_object_wrapper_get_type(), NULL);
+  g_return_val_if_fail (accessible != NULL, NULL);
+
+  accessible->role = ATK_ROLE_INVALID;
+  accessible->layer = ATK_LAYER_INVALID;
+
+  return accessible;
+}
+
+/*
+ * The wrapper factory
+ */
+
+static GType
+wrapper_factory_get_accessible_type(void)
+{
+  return atk_object_wrapper_get_type();
+}
+
+static AtkObject*
+wrapper_factory_create_accessible( GObject *pObj )
+{
+    GtkWidget* parent_widget = gtk_widget_get_parent( GTK_WIDGET( pObj ) );
+    
+    // gail_container_real_remove_gtk tries to re-instanciate an accessible
+    // for a widget that is about to vanish ..
+    if( ! parent_widget )
+        return atk_noop_object_wrapper_new();
+    
+    GtkSalFrame* pFrame = GtkSalFrame::getFromWindow( GTK_WINDOW( parent_widget ) );
+    g_return_val_if_fail( pFrame != NULL, NULL );
+    
+    AtkObject* parent_accessible = gtk_widget_get_accessible(parent_widget);
+    
+    uno::Reference< accessibility::XAccessible > xAccessible(pFrame->getAccessible( true ));
+    
+    if( xAccessible.is() )
+        return atk_object_wrapper_new( xAccessible, parent_accessible );
+    
+    return NULL;
+}
+
+static void
+wrapper_factory_class_init( AtkObjectFactoryClass *klass )
+{
+  klass->create_accessible   = wrapper_factory_create_accessible;
+  klass->get_accessible_type = wrapper_factory_get_accessible_type;
+}
+
+GType
+wrapper_factory_get_type (void)
+{
+  static GType t = 0;
+
+  if (!t) {
+    static const GTypeInfo tinfo =
+    {
+      sizeof (AtkObjectFactoryClass),
+      NULL, NULL, (GClassInitFunc) wrapper_factory_class_init,
+      NULL, NULL, sizeof (AtkObjectFactory), 0, NULL, NULL
+    };
+
+    t = g_type_register_static (
+        ATK_TYPE_OBJECT_FACTORY, "OOoAtkObjectWrapperFactory",
+        &tinfo, (GTypeFlags) 0);
+  }                                     
+                                        
+  return t;                                 
+}
+
+}; // extern C
+
Index: vcl/unx/gtk/a11y/atkfactory.hxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkfactory.hxx
diff -N vcl/unx/gtk/a11y/atkfactory.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkfactory.hxx	5 Jan 2006 14:06:31 -0000	1.1.2.1
@@ -0,0 +1,49 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __ATK_FACTORY_HXX__
+#define __ATK_FACTORY_HXX__
+
+#include <atk/atk.h>
+
+#define OOO_TYPE_WRAPPER_FACTORY wrapper_factory_get_type()
+
+extern "C" {
+    
+GType wrapper_factory_get_type (void);
+
+} // extern "C"
+
+#endif
Index: vcl/unx/gtk/a11y/atkhypertext.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkhypertext.cxx
diff -N vcl/unx/gtk/a11y/atkhypertext.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkhypertext.cxx	15 Feb 2006 10:59:22 -0000	1.1.2.8
@@ -0,0 +1,295 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "atkwrapper.hxx"
+
+#include <com/sun/star/accessibility/XAccessibleHypertext.hpp>
+
+#include <stdio.h>
+
+using namespace ::com::sun::star;
+
+ 
+// ---------------------- AtkHyperlink ----------------------
+
+typedef struct {
+    AtkHyperlink atk_hyper_link;
+
+    uno::Reference< accessibility::XAccessibleHyperlink > xLink;
+} HyperLink;
+
+static uno::Reference< accessibility::XAccessibleHyperlink >
+    getHyperlink( AtkHyperlink *pHyperlink )
+{
+    HyperLink *pLink = (HyperLink *) pHyperlink;
+    return pLink->xLink;
+}
+
+static GObjectClass *hyper_parent_class = NULL;
+
+extern "C" {
+
+static void
+hyper_link_finalize (GObject *obj)
+{
+    HyperLink *hl = (HyperLink *) obj;
+    hl->xLink.clear();
+    hyper_parent_class->finalize (obj);
+}
+
+static gchar *
+hyper_link_get_uri( AtkHyperlink *pLink,
+                    gint          i )
+{
+    try {
+        uno::Any aAny = getHyperlink( pLink )->getAccessibleActionObject( i );
+        rtl::OUString aUri = aAny.get< rtl::OUString > ();
+        return OUStringToGChar(aUri);
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in hyper_link_get_uri" );
+    }
+    return NULL;
+}
+
+static AtkObject *
+hyper_link_get_object( AtkHyperlink *pLink,
+                       gint          i)
+{
+    try {
+        uno::Any aAny = getHyperlink( pLink )->getAccessibleActionObject( i );
+        uno::Reference< accessibility::XAccessible > xObj( aAny, uno::UNO_QUERY_THROW );
+        return atk_object_wrapper_ref( xObj );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in hyper_link_get_object" );
+    }
+    return NULL;
+}
+static gint
+hyper_link_get_end_index( AtkHyperlink *pLink )
+{
+    try {
+        return getHyperlink( pLink )->getEndIndex();
+    } 
+    catch(const uno::Exception& e) {
+    }
+    return -1;
+}
+static gint
+hyper_link_get_start_index( AtkHyperlink *pLink )
+{
+    try {
+        return getHyperlink( pLink )->getStartIndex();
+    } 
+    catch(const uno::Exception& e) {
+    }
+    return -1;
+}
+static gboolean
+hyper_link_is_valid( AtkHyperlink *pLink )
+{
+    try {
+        return getHyperlink( pLink )->isValid();
+    }
+    catch(const uno::Exception& e) {
+    }
+    return FALSE;
+}
+static gint
+hyper_link_get_n_anchors( AtkHyperlink *pLink )
+{
+    try {
+        return getHyperlink( pLink )->getAccessibleActionCount();
+    }
+    catch(const uno::Exception& e) {
+    }
+    return 0;
+}
+static guint
+hyper_link_link_state( AtkHyperlink *pLink )
+{
+    g_warning( "FIXME: hyper_link_link_state unimplemented" );
+    return 0;
+}
+static gboolean
+hyper_link_is_selected_link( AtkHyperlink *pLink )
+{
+    g_warning( "FIXME: hyper_link_is_selected_link unimplemented" );
+    return FALSE;
+}
+
+static void
+hyper_link_class_init (AtkHyperlinkClass *klass)
+{
+    GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+    gobject_class->finalize = hyper_link_finalize;
+
+    hyper_parent_class = (GObjectClass *)g_type_class_peek_parent (klass);
+
+    klass->get_uri = hyper_link_get_uri;
+    klass->get_object = hyper_link_get_object;
+    klass->get_end_index = hyper_link_get_end_index;
+    klass->get_start_index = hyper_link_get_start_index;
+    klass->is_valid = hyper_link_is_valid;
+    klass->get_n_anchors = hyper_link_get_n_anchors;
+    klass->link_state = hyper_link_link_state;
+    klass->is_selected_link = hyper_link_is_selected_link;
+}
+
+static GType
+hyper_link_get_type (void)
+{
+    static GType type = 0;
+
+    if (!type) {
+        static const GTypeInfo tinfo = {
+            sizeof (HyperLink),
+            NULL,               /* base init */
+            NULL,               /* base finalize */
+            (GClassInitFunc) hyper_link_class_init,
+            NULL,               /* class finalize */
+            NULL,               /* class data */
+            sizeof (HyperLink), /* instance size */
+            0,                  /* nb preallocs */
+            NULL,               /* instance init */
+            NULL                /* value table */
+        };
+
+        static const GInterfaceInfo atk_action_info = {
+            (GInterfaceInitFunc) actionIfaceInit,
+            (GInterfaceFinalizeFunc) NULL,
+            NULL
+        };
+
+        type = g_type_register_static (ATK_TYPE_HYPERLINK,
+                                       "OOoAtkObjHyperLink", &tinfo,
+                                       (GTypeFlags)0);
+        g_type_add_interface_static (type, ATK_TYPE_ACTION,
+                                     &atk_action_info);
+    }
+
+    return type;
+}
+
+// ---------------------- AtkHyperText ----------------------
+
+static accessibility::XAccessibleHypertext*
+    getHypertext( AtkHypertext *pHypertext ) throw (uno::RuntimeException)
+{
+    AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( pHypertext );
+    if( pWrap )
+    {
+        if( !pWrap->mpHypertext && pWrap->mpContext )
+        {
+            uno::Any any = pWrap->mpContext->queryInterface( accessibility::XAccessibleHypertext::static_type(NULL) );
+            pWrap->mpHypertext = reinterpret_cast< accessibility::XAccessibleHypertext * > (any.pReserved);
+            pWrap->mpHypertext->acquire();
+        }
+        
+        return pWrap->mpHypertext;
+    }
+    
+    return NULL;
+}
+
+
+static AtkHyperlink *
+hypertext_get_link( AtkHypertext *hypertext,
+                    gint          link_index)
+{
+    try {
+        accessibility::XAccessibleHypertext* pHypertext = getHypertext( hypertext );
+        if( pHypertext )
+        {
+            HyperLink *pLink = (HyperLink *)g_object_new( hyper_link_get_type(), NULL );
+            pLink->xLink = pHypertext->getHyperLink( link_index );
+            if( !pLink->xLink.is() ) {
+                g_object_unref( G_OBJECT( pLink ) );
+                pLink = NULL;
+            }
+            return ATK_HYPERLINK( pLink );
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getHyperLink()" );
+    }
+    
+    return NULL;
+}
+
+static gint
+hypertext_get_n_links( AtkHypertext *hypertext )
+{
+    try {
+        accessibility::XAccessibleHypertext* pHypertext = getHypertext( hypertext );
+        if( pHypertext )
+            return pHypertext->getHyperLinkCount();
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getHyperLinkCount()" );
+    }
+    
+    return 0;
+}
+
+static gint
+hypertext_get_link_index( AtkHypertext *hypertext,
+                          gint          index)
+{
+    try {
+        accessibility::XAccessibleHypertext* pHypertext = getHypertext( hypertext );
+        if( pHypertext )
+            return pHypertext->getHyperLinkIndex( index );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getHyperLinkIndex()" );
+    }
+    
+    return 0;
+}
+
+} // extern "C"
+
+void
+hypertextIfaceInit (AtkHypertextIface *iface)
+{
+  g_return_if_fail (iface != NULL);
+
+  iface->get_link = hypertext_get_link;
+  iface->get_n_links = hypertext_get_n_links;
+  iface->get_link_index = hypertext_get_link_index;
+}
Index: vcl/unx/gtk/a11y/atkimage.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkimage.cxx
diff -N vcl/unx/gtk/a11y/atkimage.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkimage.cxx	15 Feb 2006 10:59:23 -0000	1.1.2.4
@@ -0,0 +1,144 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "atkwrapper.hxx"
+
+#include <com/sun/star/accessibility/XAccessibleImage.hpp>
+
+#include <stdio.h>
+
+using namespace ::com::sun::star;
+
+// FIXME
+static G_CONST_RETURN gchar *
+getAsConst( rtl::OUString rString )
+{
+    static const int nMax = 10;
+    static rtl::OString aUgly[nMax];
+    static int nIdx = 0;
+    nIdx = (nIdx + 1) % nMax;
+    aUgly[nIdx] = rtl::OUStringToOString( rString, RTL_TEXTENCODING_UTF8 );
+    return aUgly[ nIdx ];
+}
+
+static accessibility::XAccessibleImage*
+    getImage( AtkImage *pImage ) throw (uno::RuntimeException)
+{
+    AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( pImage );
+    if( pWrap )
+    {
+        if( !pWrap->mpImage && pWrap->mpContext )
+        {
+            uno::Any any = pWrap->mpContext->queryInterface( accessibility::XAccessibleImage::static_type(NULL) );
+            pWrap->mpImage = reinterpret_cast< accessibility::XAccessibleImage * > (any.pReserved);
+            pWrap->mpImage->acquire();
+        }
+        
+        return pWrap->mpImage;
+    }
+    
+    return NULL;
+}
+
+extern "C" {
+
+static G_CONST_RETURN gchar *
+image_get_image_description( AtkImage *image )
+{
+    try {
+        accessibility::XAccessibleImage* pImage = getImage( image );
+        if( pImage )    
+            return getAsConst( pImage->getAccessibleImageDescription() );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleImageDescription()" );
+    }
+    
+    return NULL;
+}
+
+static void
+image_get_image_position( AtkImage     *image,
+                          gint         *x,
+                          gint         *y,
+                          AtkCoordType  coord_type )
+{
+    *x = *y = 0;
+    if( ATK_IS_COMPONENT( image ) )
+        atk_component_get_position( ATK_COMPONENT( image ), x, y, coord_type );
+    else
+        g_warning( "FIXME: no image position information" );
+}
+
+static void
+image_get_image_size( AtkImage *image,
+                      gint     *width,
+                      gint     *height )
+{
+    *width = 0;
+    *height = 0;
+    try {
+        accessibility::XAccessibleImage* pImage = getImage( image );
+        if( pImage )
+        {
+            *width = pImage->getAccessibleImageWidth();
+            *height = pImage->getAccessibleImageHeight();
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleImageHeight() or Width" );
+    }
+}
+
+static gboolean
+image_set_image_description( AtkImage    *image,
+                                  const gchar *description )
+{
+    g_warning ("FIXME: no set image description");
+    return FALSE;
+}
+
+} // extern "C"
+
+void
+imageIfaceInit (AtkImageIface *iface)
+{
+  g_return_if_fail (iface != NULL);
+
+  iface->set_image_description = image_set_image_description;
+  iface->get_image_description = image_get_image_description;
+  iface->get_image_position = image_get_image_position;
+  iface->get_image_size = image_get_image_size;
+}
Index: vcl/unx/gtk/a11y/atklistener.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atklistener.cxx
diff -N vcl/unx/gtk/a11y/atklistener.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atklistener.cxx	1 Mar 2006 12:00:16 -0000	1.1.2.17
@@ -0,0 +1,474 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include <com/sun/star/accessibility/TextSegment.hpp>
+#include <com/sun/star/accessibility/AccessibleEventId.hpp>
+#include <com/sun/star/accessibility/AccessibleStateType.hpp>
+#include <com/sun/star/accessibility/AccessibleTableModelChange.hpp>
+#include <com/sun/star/accessibility/AccessibleTableModelChangeType.hpp>
+#include <com/sun/star/accessibility/XAccessibleEventBroadcaster.hpp>
+
+#include "atklistener.hxx"
+#include "atkwrapper.hxx"
+
+#include <rtl/ref.hxx>
+#include <stdio.h>
+
+using namespace com::sun::star;
+
+
+#define CSTRING_FROM_ANY(i) rtl::OUStringToOString( i.get< rtl::OUString >(), RTL_TEXTENCODING_UTF8 ).getStr()
+
+AtkListener::AtkListener( AtkObjectWrapper* pWrapper )
+{
+    if( pWrapper )
+    {
+        mpAccessible = ATK_OBJECT( g_object_ref( pWrapper ) );
+        updateChildList( pWrapper->mpContext );
+    }
+}
+
+AtkListener::~AtkListener()
+{
+}
+
+/*****************************************************************************/
+
+AtkStateType mapState( const uno::Any &rAny )
+{
+    sal_Int16 nState = accessibility::AccessibleStateType::INVALID;
+    rAny >>= nState;
+    return mapAtkState( nState );
+}
+
+/*****************************************************************************/
+
+// XEventListener implementation
+void AtkListener::disposing( const lang::EventObject& aEvent ) throw (uno::RuntimeException)
+{
+    if( mpAccessible )
+    {
+        // Release all interface references to avoid shutdown problems with
+        // global mutex
+        atk_object_wrapper_dispose( ATK_OBJECT_WRAPPER( mpAccessible ) );
+        
+        // This is an equivalent to a state change to DEFUNC(T).
+        atk_object_notify_state_change( mpAccessible, ATK_STATE_DEFUNCT, TRUE );
+
+        if( atk_get_focus_object() == mpAccessible )
+            atk_focus_tracker_notify( NULL );
+        
+        // Release the wrapper object so that it can vanish ..
+        g_object_unref( mpAccessible );
+        mpAccessible = NULL;
+    }
+}
+
+/*****************************************************************************/
+
+static AtkObject *getObjFromAny( const uno::Any &rAny )
+{
+    uno::Reference< accessibility::XAccessible > xAccessible;
+    rAny >>= xAccessible;
+    return xAccessible.is() ? atk_object_wrapper_ref( xAccessible ) : NULL;
+}
+
+/*****************************************************************************/
+
+// Updates the child list held to provide the old IndexInParent on children_changed::remove
+void AtkListener::updateChildList(accessibility::XAccessibleContext* pContext)
+{
+     m_aChildList.clear();
+     
+     uno::Reference< accessibility::XAccessibleStateSet > xStateSet = pContext->getAccessibleStateSet();
+     if( xStateSet.is()
+         && !xStateSet->contains(accessibility::AccessibleStateType::DEFUNC)
+         && !xStateSet->contains(accessibility::AccessibleStateType::MANAGES_DESCENDANTS) )
+     {
+         sal_Int32 nChildren = pContext->getAccessibleChildCount();
+         m_aChildList.resize(nChildren);
+         for(sal_Int32 n = 0; n < nChildren; n++)
+         {
+             m_aChildList[n] = pContext->getAccessibleChild(n);
+         }
+     }
+}
+
+/*****************************************************************************/
+
+void AtkListener::handleChildAdded(
+    const uno::Reference< accessibility::XAccessibleContext >& rxParent,
+    const uno::Reference< accessibility::XAccessible>& rxAccessible)
+{
+    AtkObject * pChild = atk_object_wrapper_ref( rxAccessible );
+    
+    if( pChild )
+    {
+        updateChildList(rxParent.get());
+        g_signal_emit_by_name( mpAccessible, "children_changed::add", 
+            atk_object_get_index_in_parent( pChild ), pChild, NULL );
+        g_object_unref( pChild );
+    }
+}
+
+/*****************************************************************************/
+
+void AtkListener::handleChildRemoved(
+    const uno::Reference< accessibility::XAccessibleContext >& rxParent,
+    const uno::Reference< accessibility::XAccessible>& rxChild)
+{
+    sal_Int32 nIndex = -1;
+
+    // Locate the child in the children list
+    size_t n, nmax = m_aChildList.size();
+    for( n = 0; n < nmax; ++n )
+    {
+        if( rxChild == m_aChildList[n] )
+        {
+            nIndex = n;
+            break;
+        }
+    }
+
+    // FIXME: two problems here:
+    // a) we get child-removed events for objects that are no real childs
+    //    in the accessibility hierarchy
+    // b) spi_atk_bridge_signal_listener ignores the given parameters
+    //    for children_changed events and always asks the parent for the 
+    //    0. child, which breaks somehow on vanishing list boxes.
+    // Ignoring "remove" events for objects not in the m_aChildList
+    // for now.
+    if( nIndex >= 0 )
+    {
+        updateChildList(rxParent.get());
+
+        AtkObject * pChild = atk_object_wrapper_ref( rxChild, false );
+        if( pChild )
+        {
+            g_signal_emit_by_name( mpAccessible, "children_changed::remove", nIndex, pChild, NULL );
+            g_object_unref( pChild );
+        }
+    }
+}
+
+/*****************************************************************************/
+
+void AtkListener::handleInvalidateChildren(
+    const uno::Reference< accessibility::XAccessibleContext >& rxParent)
+{
+    // Send notifications for all previous children 
+    size_t n = m_aChildList.size();
+    while( n-- > 0 )
+    {
+        AtkObject * pChild = atk_object_wrapper_ref( m_aChildList[n], false );
+        if( pChild )
+        {
+            g_signal_emit_by_name( mpAccessible, "children_changed::remove", n, pChild, NULL );
+            g_object_unref( pChild );
+        }
+    }
+    
+    updateChildList(rxParent.get());
+    
+    // Send notifications for all new children
+    size_t nmax = m_aChildList.size();
+    for( n = 0; n < nmax; ++n )
+    {
+        AtkObject * pChild = atk_object_wrapper_ref( m_aChildList[n] );
+    
+        if( pChild )
+        {
+            g_signal_emit_by_name( mpAccessible, "children_changed::add", n, pChild, NULL );
+            g_object_unref( pChild );
+        }
+    }
+}
+
+/*****************************************************************************/
+
+static uno::Reference< accessibility::XAccessibleContext >
+getAccessibleContextFromSource( const uno::Reference< uno::XInterface >& rxSource )
+{
+    uno::Reference< accessibility::XAccessibleContext > xContext(rxSource, uno::UNO_QUERY);
+    if( ! xContext.is() )
+    {
+         g_warning( "ERROR: Event source does not implement XAccessibleContext" );
+
+         // Second try - query for XAccessible, which should give us access to
+         // XAccessibleContext.
+         uno::Reference< accessibility::XAccessible > xAccessible(rxSource, uno::UNO_QUERY);
+         if( xAccessible.is() )
+             xContext = xAccessible->getAccessibleContext();
+    }
+    
+    return xContext;
+}
+
+/*****************************************************************************/
+
+// XAccessibleEventListener
+void AtkListener::notifyEvent( const accessibility::AccessibleEventObject& aEvent ) throw( uno::RuntimeException )
+{
+    AtkPropertyValues aValues = { NULL };
+
+    if( !mpAccessible )
+        return;
+    
+    switch( aEvent.EventId )
+    {
+    // AtkObject signals:
+        // Hierarchy signals
+        case accessibility::AccessibleEventId::CHILD:
+        {
+            uno::Reference< accessibility::XAccessibleContext > xParent;
+            uno::Reference< accessibility::XAccessible > xChild;
+            
+            xParent = getAccessibleContextFromSource(aEvent.Source);
+            g_return_if_fail( xParent.is() );
+            
+            if( aEvent.OldValue >>= xChild )
+                handleChildRemoved(xParent, xChild);
+            
+            if( aEvent.NewValue >>= xChild )
+                handleChildAdded(xParent, xChild);
+        }
+            break;
+            
+        case accessibility::AccessibleEventId::INVALIDATE_ALL_CHILDREN:
+        {
+            uno::Reference< accessibility::XAccessibleContext > xParent;
+            
+            xParent = getAccessibleContextFromSource(aEvent.Source);
+            g_return_if_fail( xParent.is() );
+            
+            handleInvalidateChildren(xParent);
+        }
+            break;
+            
+        case accessibility::AccessibleEventId::NAME_CHANGED:
+            g_object_notify( G_OBJECT( mpAccessible ), "accessible-name" );
+            break;
+            
+        case accessibility::AccessibleEventId::DESCRIPTION_CHANGED:
+            g_object_notify( G_OBJECT( mpAccessible ), "accessible-description" );
+            break;
+            
+        case accessibility::AccessibleEventId::STATE_CHANGED:
+        {
+            AtkStateType eOldState = mapState( aEvent.OldValue );
+            AtkStateType eNewState = mapState( aEvent.NewValue );
+
+            gboolean bState = eNewState != ATK_STATE_INVALID;
+            AtkStateType eRealState = bState ? eNewState : eOldState;
+
+            atk_object_notify_state_change( mpAccessible, eRealState, bState );
+            break;
+        }
+        
+        case accessibility::AccessibleEventId::BOUNDRECT_CHANGED:
+        
+            if( ATK_IS_COMPONENT( mpAccessible ) )
+            {
+                AtkRectangle rect;
+            
+                atk_component_get_extents( ATK_COMPONENT( mpAccessible ), 
+                                           &rect.x,
+                                           &rect.y,
+                                           &rect.width,
+                                           &rect.height,
+                                           ATK_XY_SCREEN );
+                                           
+                g_signal_emit_by_name( mpAccessible, "bounds_changed", &rect );
+            }
+            else
+                g_warning( "bounds_changed event for object not implementing AtkComponent\n");
+            
+            break;
+        
+        case accessibility::AccessibleEventId::VISIBLE_DATA_CHANGED:
+            g_signal_emit_by_name( mpAccessible, "visible-data-changed" );
+            break;
+            
+        case accessibility::AccessibleEventId::ACTIVE_DESCENDANT_CHANGED:
+        {
+            AtkObject *pChild = getObjFromAny( aEvent.NewValue );
+            if( pChild )
+            {
+                g_signal_emit_by_name( mpAccessible, "active-descendant-changed", pChild );
+                g_object_unref( pChild );
+            }
+            break;
+        }
+
+        // AtkAction signals ...
+        case accessibility::AccessibleEventId::ACTION_CHANGED:
+            g_signal_emit_by_name( G_OBJECT( mpAccessible ), "property_change::accessible-actions");
+            break;
+
+        // AtkText
+        case accessibility::AccessibleEventId::CARET_CHANGED:
+        {
+            sal_Int32 nPos;
+            aEvent.NewValue >>= nPos;
+            g_signal_emit_by_name( mpAccessible, "text_caret_moved", nPos );
+            break;
+        }
+        case accessibility::AccessibleEventId::TEXT_CHANGED:
+        {
+            // TESTME: and remove this comment:
+            // cf. comphelper/source/misc/accessibletexthelper.cxx (implInitTextChangedEvent)
+            accessibility::TextSegment aDeletedText;
+            accessibility::TextSegment aInsertedText;
+
+            // TODO: when GNOME starts to send "update" kind of events, change 
+            // we need to re-think this implementation as well
+            if( aEvent.OldValue >>= aDeletedText )
+                g_signal_emit_by_name( mpAccessible, "text_changed::delete",
+                                       (gint) aDeletedText.SegmentStart,
+                                       (gint)( aDeletedText.SegmentEnd - aDeletedText.SegmentStart ) );
+            if( aEvent.NewValue >>= aInsertedText )
+                g_signal_emit_by_name( mpAccessible, "text_changed::insert",
+                                       (gint) aInsertedText.SegmentStart,
+                                       (gint)( aInsertedText.SegmentEnd - aInsertedText.SegmentStart ) );
+            break;
+        }
+        
+        case accessibility::AccessibleEventId::TEXT_SELECTION_CHANGED:
+        {
+            g_signal_emit_by_name( mpAccessible, "text-selection-changed" );
+            break;
+        }
+        
+        case accessibility::AccessibleEventId::TEXT_ATTRIBUTE_CHANGED:
+            g_signal_emit_by_name( mpAccessible, "text-attributes-changed" );
+            break;
+
+        // AtkValue
+        case accessibility::AccessibleEventId::VALUE_CHANGED:
+            g_object_notify( G_OBJECT( mpAccessible ), "accessible-value" );
+            break;
+
+        case accessibility::AccessibleEventId::CONTENT_FLOWS_FROM_RELATION_CHANGED:
+        case accessibility::AccessibleEventId::CONTENT_FLOWS_TO_RELATION_CHANGED:
+        case accessibility::AccessibleEventId::CONTROLLED_BY_RELATION_CHANGED:
+        case accessibility::AccessibleEventId::CONTROLLER_FOR_RELATION_CHANGED:
+        case accessibility::AccessibleEventId::LABEL_FOR_RELATION_CHANGED:
+        case accessibility::AccessibleEventId::LABELED_BY_RELATION_CHANGED:
+        case accessibility::AccessibleEventId::MEMBER_OF_RELATION_CHANGED:
+        case accessibility::AccessibleEventId::SUB_WINDOW_OF_RELATION_CHANGED:
+            // FIXME: ask Bill how Atk copes with this little lot ...
+            break;
+
+        // AtkTable 
+        case accessibility::AccessibleEventId::TABLE_MODEL_CHANGED:
+        {
+            accessibility::AccessibleTableModelChange aChange;
+            aEvent.NewValue >>= aChange;
+
+            g_warning( "Test me: table model change event" );
+            sal_Int32 nRowsChanged = aChange.LastRow - aChange.FirstRow + 1;
+            sal_Int32 nColumnsChanged = aChange.LastColumn - aChange.FirstColumn + 1;
+            
+            static const struct {
+                    const char *row;
+                    const char *col;
+            } aSignalNames[] = 
+            {
+                { NULL, NULL }, // dummy
+                { "row_inserted", "column_inserted" }, // INSERT = 1
+                { "row_deleted", "column_deleted" } // DELETE = 2
+            };
+            switch( aChange.Type )
+            {
+            case accessibility::AccessibleTableModelChangeType::INSERT:
+            case accessibility::AccessibleTableModelChangeType::DELETE:
+                if( nRowsChanged > 0 )
+                    g_signal_emit_by_name( G_OBJECT( mpAccessible ),
+                                           aSignalNames[aChange.Type].row,
+                                           aChange.FirstRow, nRowsChanged );
+                if( nColumnsChanged > 0 )
+                    g_signal_emit_by_name( G_OBJECT( mpAccessible ),
+                                           aSignalNames[aChange.Type].col,
+                                           aChange.FirstColumn, nColumnsChanged );
+                break;
+                
+            case accessibility::AccessibleTableModelChangeType::UPDATE:
+                // This is not really a model change, is it ?
+                break;
+            default:
+                g_warning( "TESTME: unusual table model change %d\n", aChange.Type );
+                break;
+            }
+            g_signal_emit_by_name( G_OBJECT( mpAccessible ), "model-changed" );
+            break;
+        }
+
+        case accessibility::AccessibleEventId::TABLE_COLUMN_HEADER_CHANGED:
+            g_signal_emit_by_name( G_OBJECT( mpAccessible ), "property_change::accessible-table-column-header");
+            break;
+
+        case accessibility::AccessibleEventId::TABLE_CAPTION_CHANGED:
+            g_signal_emit_by_name( G_OBJECT( mpAccessible ), "property_change::accessible-table-caption");
+            break;
+            
+        case accessibility::AccessibleEventId::TABLE_COLUMN_DESCRIPTION_CHANGED:
+            g_signal_emit_by_name( G_OBJECT( mpAccessible ), "property_change::accessible-table-column-description");
+            break;
+            
+        case accessibility::AccessibleEventId::TABLE_ROW_DESCRIPTION_CHANGED:
+            g_signal_emit_by_name( G_OBJECT( mpAccessible ), "property_change::accessible-table-row-description");
+            break;
+            
+        case accessibility::AccessibleEventId::TABLE_ROW_HEADER_CHANGED:
+            g_signal_emit_by_name( G_OBJECT( mpAccessible ), "property_change::accessible-table-row-header");
+            break;
+            
+        case accessibility::AccessibleEventId::TABLE_SUMMARY_CHANGED:
+            g_signal_emit_by_name( G_OBJECT( mpAccessible ), "property_change::accessible-table-summary");
+            break;
+
+        case accessibility::AccessibleEventId::SELECTION_CHANGED:
+            g_signal_emit_by_name( G_OBJECT( mpAccessible ), "selection_changed");
+            break;
+            
+        case accessibility::AccessibleEventId::HYPERTEXT_CHANGED:
+            g_signal_emit_by_name( G_OBJECT( mpAccessible ), "property_change::accessible-hypertext-offset");
+            break;
+
+    default:
+            g_warning( "Unknown event notification" );
+            break;
+    }
+}
Index: vcl/unx/gtk/a11y/atklistener.hxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atklistener.hxx
diff -N vcl/unx/gtk/a11y/atklistener.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atklistener.hxx	15 Feb 2006 10:59:24 -0000	1.1.2.7
@@ -0,0 +1,92 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _ATK_LISTENER_HXX_
+#define _ATK_LISTENER_HXX_
+
+#ifndef _COM_SUN_STAR_ACCESSIBILITY_XACCESSIBLEEVENTLISTENER_HPP_
+#include <com/sun/star/accessibility/XAccessibleEventListener.hpp>
+#endif
+
+#ifndef _CPPUHELPER_IMPLBASE1_HXX_
+#include <cppuhelper/implbase1.hxx>
+#endif
+
+#include <vector>
+
+#include "atkwrapper.hxx"
+
+typedef std::vector< ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > > AccessibleVector;
+
+class AtkListener : public ::cppu::WeakImplHelper1< ::com::sun::star::accessibility::XAccessibleEventListener >
+{
+public:
+    AtkListener(AtkObjectWrapper * pWrapper);
+    
+    // XEventListener
+    virtual void disposing( const ::com::sun::star::lang::EventObject& Source ) 
+        throw (::com::sun::star::uno::RuntimeException);
+
+    // XAccessibleEventListener
+    virtual void notifyEvent( const ::com::sun::star::accessibility::AccessibleEventObject& aEvent ) 
+        throw( ::com::sun::star::uno::RuntimeException );
+    
+    AtkObject *mpAccessible;
+    AccessibleVector m_aChildList;
+
+private:
+
+    virtual ~AtkListener();
+
+    // Updates the child list held to provide the old IndexInParent on children_changed::remove
+    void updateChildList(::com::sun::star::accessibility::XAccessibleContext* pContext);
+    
+    // Process CHILD_EVENT notifications with a new child added
+    void handleChildAdded(
+        const ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessibleContext >& rxParent,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible>& rxChild);
+    
+    // Process CHILD_EVENT notifications with a child removed
+    void handleChildRemoved(
+        const ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessibleContext >& rxParent,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible>& rxChild);
+    
+    // Process INVALIDATE_ALL_CHILDREN notification
+    void handleInvalidateChildren(
+        const ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessibleContext >& rxParent);    
+};
+
+#endif /* _ATK_LISTENER_HXX_ */
+
Index: vcl/unx/gtk/a11y/atkselection.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkselection.cxx
diff -N vcl/unx/gtk/a11y/atkselection.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkselection.cxx	15 Feb 2006 10:59:24 -0000	1.1.2.6
@@ -0,0 +1,200 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "atkwrapper.hxx"
+
+#include <com/sun/star/accessibility/XAccessibleSelection.hpp>
+
+#include <stdio.h>
+
+using namespace ::com::sun::star;
+
+static accessibility::XAccessibleSelection*
+    getSelection( AtkSelection *pSelection ) throw (uno::RuntimeException)
+{
+    AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( pSelection );
+    if( pWrap )
+    {
+        if( !pWrap->mpSelection && pWrap->mpContext )
+        {
+            uno::Any any = pWrap->mpContext->queryInterface( accessibility::XAccessibleSelection::static_type(NULL) );
+            pWrap->mpSelection = reinterpret_cast< accessibility::XAccessibleSelection * > (any.pReserved);
+            pWrap->mpSelection->acquire();
+        }
+        
+        return pWrap->mpSelection;
+    }
+    
+    return NULL;
+}
+
+extern "C" {
+
+static gboolean
+selection_add_selection( AtkSelection *selection,
+                         gint          i )
+{
+    try {
+        accessibility::XAccessibleSelection* pSelection = getSelection( selection );
+        if( pSelection )
+        {
+            pSelection->selectAccessibleChild( i );
+            return TRUE;
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in selectAccessibleChild()" );
+    }
+    
+    return FALSE;
+}
+
+static gboolean
+selection_clear_selection( AtkSelection *selection )
+{
+    try {
+        accessibility::XAccessibleSelection* pSelection = getSelection( selection );
+        if( pSelection )
+        {
+            pSelection->clearAccessibleSelection();
+            return TRUE;
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in selectAccessibleChild()" );
+    }
+    
+    return FALSE;
+}
+
+static AtkObject*
+selection_ref_selection( AtkSelection *selection,
+                         gint          i )
+{
+    try {
+        accessibility::XAccessibleSelection* pSelection = getSelection( selection );
+        if( pSelection )
+            return atk_object_wrapper_ref( pSelection->getSelectedAccessibleChild( i ) );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getSelectedAccessibleChild()" );
+    }
+    
+    return NULL;
+}
+
+static gint
+selection_get_selection_count( AtkSelection   *selection)
+{
+    try {
+        accessibility::XAccessibleSelection* pSelection = getSelection( selection );
+        if( pSelection )
+            return pSelection->getSelectedAccessibleChildCount();
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getSelectedAccessibleChildCount()" );
+    }
+    
+    return -1;
+}
+
+static gboolean
+selection_is_child_selected( AtkSelection   *selection,
+                              gint           i)
+{
+    try {
+        accessibility::XAccessibleSelection* pSelection = getSelection( selection );
+        if( pSelection )
+            return pSelection->isAccessibleChildSelected( i );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getSelectedAccessibleChildCount()" );
+    }
+
+    return FALSE;
+}
+
+static gboolean
+selection_remove_selection( AtkSelection *selection,
+                            gint           i )
+{
+    try {
+        accessibility::XAccessibleSelection* pSelection = getSelection( selection );
+        if( pSelection )
+        {
+            pSelection->deselectAccessibleChild( i );
+            return TRUE;
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getSelectedAccessibleChildCount()" );
+    }
+    
+    return FALSE;
+}
+
+static gboolean
+selection_select_all_selection( AtkSelection   *selection)
+{
+    try {
+        accessibility::XAccessibleSelection* pSelection = getSelection( selection );
+        if( pSelection )
+        {
+            pSelection->selectAllAccessibleChildren();
+            return TRUE;
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getSelectedAccessibleChildCount()" );
+    }
+    
+    return FALSE;
+}
+
+} // extern "C"
+
+void
+selectionIfaceInit( AtkSelectionIface *iface)
+{
+  g_return_if_fail (iface != NULL);
+
+  iface->add_selection = selection_add_selection;
+  iface->clear_selection = selection_clear_selection;
+  iface->ref_selection = selection_ref_selection;
+  iface->get_selection_count = selection_get_selection_count;
+  iface->is_child_selected = selection_is_child_selected;
+  iface->remove_selection = selection_remove_selection;
+  iface->select_all_selection = selection_select_all_selection;
+}
Index: vcl/unx/gtk/a11y/atktable.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atktable.cxx
diff -N vcl/unx/gtk/a11y/atktable.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atktable.cxx	15 Feb 2006 10:58:28 -0000	1.1.2.7
@@ -0,0 +1,737 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "atkwrapper.hxx"
+
+#include <com/sun/star/accessibility/XAccessibleTable.hpp>
+
+#ifdef ENABLE_TRACING
+#include <stdio.h>
+#endif
+
+using namespace ::com::sun::star;
+
+static inline AtkObject *
+atk_object_wrapper_conditional_ref( const uno::Reference< accessibility::XAccessible >& rxAccessible )
+{
+#ifdef ENABLE_TRACING
+    fprintf( stderr, ": %p\n", rxAccessible.get() );
+#endif
+    
+    if( rxAccessible.is() )
+        return atk_object_wrapper_ref( rxAccessible );
+    
+    return NULL;
+}
+
+/*****************************************************************************/
+
+// FIXME
+static G_CONST_RETURN gchar *
+getAsConst( rtl::OUString rString )
+{
+    static const int nMax = 10;
+    static rtl::OString aUgly[nMax];
+    static int nIdx = 0;
+    nIdx = (nIdx + 1) % nMax;
+    aUgly[nIdx] = rtl::OUStringToOString( rString, RTL_TEXTENCODING_UTF8 );
+    return aUgly[ nIdx ];
+}
+
+/*****************************************************************************/
+
+static accessibility::XAccessibleTable*
+    getTable( AtkTable *pTable ) throw (uno::RuntimeException)
+{
+    AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( pTable );
+    if( pWrap )
+    {
+        if( !pWrap->mpTable && pWrap->mpContext )
+        {
+            uno::Any any = pWrap->mpContext->queryInterface( accessibility::XAccessibleTable::static_type(NULL) );
+            pWrap->mpTable = reinterpret_cast< accessibility::XAccessibleTable * > (any.pReserved);
+            pWrap->mpTable->acquire();
+        }
+        
+        return pWrap->mpTable;
+    }
+    
+    return NULL;
+}
+
+/*****************************************************************************/
+
+extern "C" {
+
+static AtkObject*
+table_wrapper_ref_at (AtkTable *table,
+                      gint      row,
+                      gint      column)
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getAccessibleCellAt( %u, %u ) returns", row, column );
+        
+        if( column >= 255 )
+            fprintf(stderr, "getAccessibleCellAt( %u, %u ) returns", row, column );
+            
+#endif
+
+        if( pTable )
+            return atk_object_wrapper_conditional_ref( pTable->getAccessibleCellAt( row, column ) );
+    }
+        
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleCellAt()" );
+    }
+
+    return NULL;
+}
+
+/*****************************************************************************/
+
+static gint
+table_wrapper_get_index_at (AtkTable      *table,
+                            gint          row,
+                            gint          column)
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getAccessibleIndex( %u, %u ) returns %u\n", 
+                row, column, pTable->getAccessibleIndex( row, column ) );
+#endif
+        
+        if( pTable )
+            return pTable->getAccessibleIndex( row, column );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleIndex()" );
+    }
+
+    return -1;
+}
+
+/*****************************************************************************/
+
+static gint
+table_wrapper_get_column_at_index (AtkTable      *table,
+                                   gint          nIndex)
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getAccessibleColumn( %u ) returns %u\n", 
+                nIndex, pTable->getAccessibleColumn( nIndex ) );
+#endif
+        
+        if( pTable )
+            return pTable->getAccessibleColumn( nIndex );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleColumn()" );
+    }
+
+    return -1;
+}
+
+/*****************************************************************************/
+
+static gint
+table_wrapper_get_row_at_index( AtkTable *table,
+                                gint      nIndex )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getAccessibleRow( %u ) returns %u\n", 
+                nIndex, pTable->getAccessibleRow( nIndex ) );
+#endif
+
+        if( pTable )
+            return pTable->getAccessibleRow( nIndex );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleRow()" );
+    }
+
+    return -1;
+}
+
+/*****************************************************************************/
+
+static gint
+table_wrapper_get_n_columns( AtkTable *table )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "XAccessibleTable::getAccessibleColumnCount returns %u\n", 
+                pTable->getAccessibleColumnCount() );
+#endif
+
+        if( pTable )
+            return pTable->getAccessibleColumnCount();
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleColumnCount()" );
+    }
+
+    return -1;
+}
+
+/*****************************************************************************/
+
+static gint
+table_wrapper_get_n_rows( AtkTable *table )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getAccessibleRowCount() returns %u\n", 
+                pTable->getAccessibleRowCount() );
+#endif
+
+        if( pTable )
+            return pTable->getAccessibleRowCount();
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleRowCount()" );
+    }
+
+    return -1;
+}
+
+/*****************************************************************************/
+
+static gint
+table_wrapper_get_column_extent_at( AtkTable *table,
+                                    gint      row,
+                                    gint      column )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getAccessibleColumnExtentAt( %u, %u ) returns %u\n", 
+                row, column, pTable->getAccessibleColumnExtentAt( row, column ) );
+#endif
+
+        if( pTable )
+            return pTable->getAccessibleColumnExtentAt( row, column );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleColumnExtentAt()" );
+    }
+
+    return -1;
+}
+
+/*****************************************************************************/
+
+static gint
+table_wrapper_get_row_extent_at( AtkTable *table,
+                                 gint      row,
+                                 gint      column )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getAccessibleRowExtentAt( %u, %u ) returns %u\n", 
+                row, column, pTable->getAccessibleRowExtentAt( row, column ) );
+#endif
+
+        if( pTable )
+            return pTable->getAccessibleRowExtentAt( row, column );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleRowExtentAt()" );
+    }
+
+    return -1;
+}
+
+/*****************************************************************************/
+
+static AtkObject *
+table_wrapper_get_caption( AtkTable *table )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getAccessibleCaption() returns" );
+#endif
+
+        if( pTable )
+            return atk_object_wrapper_conditional_ref( pTable->getAccessibleCaption() );
+    }
+        
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleCaption()" );
+    }
+
+    return NULL;
+}
+
+/*****************************************************************************/
+
+static G_CONST_RETURN gchar *
+table_wrapper_get_row_description( AtkTable *table,
+                                   gint      row )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getAccessibleRowDescription( %u ) returns %s\n", 
+                row, getAsConst( pTable->getAccessibleRowDescription( row ) ) );
+#endif
+
+        if( pTable )
+            return getAsConst( pTable->getAccessibleRowDescription( row ) );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleRowDescription()" );
+    }
+
+    return NULL;
+}
+
+/*****************************************************************************/
+
+static G_CONST_RETURN gchar *
+table_wrapper_get_column_description( AtkTable *table,
+                                      gint      column )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getAccessibleColumnDescription( %u ) returns %s\n", 
+                column, getAsConst( pTable->getAccessibleColumnDescription( column ) ) );
+#endif
+
+        if( pTable )
+            return getAsConst( pTable->getAccessibleColumnDescription( column ) );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleColumnDescription()" );
+    }
+
+    return NULL;
+}
+
+/*****************************************************************************/
+
+static AtkObject *
+table_wrapper_get_row_header( AtkTable *table,
+                              gint      row )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        if( pTable )
+        {
+            uno::Reference< accessibility::XAccessibleTable > xRowHeaders( pTable->getAccessibleRowHeaders() );
+
+#ifdef ENABLE_TRACING
+            if( xRowHeaders.is() )
+                fprintf(stderr, "getAccessibleRowHeader( %u )->getAccessibleCellAt( 0, %u ) returns",
+                    row, row );
+            else
+                fprintf(stderr, "getAccessibleRowHeader( %u ) returns %p\n", row, xRowHeaders.get() );
+#endif
+
+            if( xRowHeaders.is() )
+                return atk_object_wrapper_conditional_ref( xRowHeaders->getAccessibleCellAt( row, 0 ) );
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleRowHeaders()" );
+    }
+
+    return NULL;
+}
+
+/*****************************************************************************/
+
+static AtkObject *
+table_wrapper_get_column_header( AtkTable *table,
+                                 gint      column )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+        if( pTable )
+        {
+            uno::Reference< accessibility::XAccessibleTable > xColumnHeaders( pTable->getAccessibleColumnHeaders() );
+
+#ifdef ENABLE_TRACING
+            if( xColumnHeaders.is() )
+                fprintf(stderr, "getAccessibleColumnHeader( %u )->getAccessibleCellAt( 0, %u ) returns",
+                    column, column );
+            else
+                fprintf(stderr, "getAccessibleColumnHeader( %u ) returns %p\n", column, xColumnHeaders.get() );
+#endif
+
+            if( xColumnHeaders.is() )
+                return atk_object_wrapper_conditional_ref( xColumnHeaders->getAccessibleCellAt( 0, column ) );
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleColumnHeaders()" );
+    }
+
+    return NULL;
+}
+
+/*****************************************************************************/
+
+static AtkObject *
+table_wrapper_get_summary( AtkTable *table )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getAccessibleSummary() returns" );
+#endif
+
+        if( pTable )
+        {
+    // FIXME: Summary ??
+            AtkObject* summary;
+            return atk_object_wrapper_conditional_ref( pTable->getAccessibleSummary() );
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleSummary()" );
+    }
+
+    return NULL;
+}
+
+/*****************************************************************************/
+
+static gint
+convertToGIntArray( const uno::Sequence< ::sal_Int32 >& aSequence, gint **pSelected )
+{
+    if( aSequence.getLength() )
+    {
+        *pSelected = g_new( gint, aSequence.getLength() );
+
+        for( sal_Int32 i = 0; i < aSequence.getLength(); i++ )
+            (*pSelected) [i] = aSequence[i];
+    }
+
+    return aSequence.getLength();
+}
+
+/*****************************************************************************/
+
+static gint
+table_wrapper_get_selected_columns( AtkTable      *table,
+                                    gint          **pSelected )
+{
+    *pSelected = NULL;
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getSelectedAccessibleColumns() \n" );
+#endif
+        
+        if( pTable )
+            return convertToGIntArray( pTable->getSelectedAccessibleColumns(), pSelected );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getSelectedAccessibleColumns()" );
+    }
+
+    return 0;
+}
+
+/*****************************************************************************/
+
+static gint
+table_wrapper_get_selected_rows( AtkTable      *table,
+                                 gint          **pSelected )
+{
+    *pSelected = NULL;
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "getSelectedAccessibleRows() \n" );
+#endif
+        
+        if( pTable )
+            return convertToGIntArray( pTable->getSelectedAccessibleRows(), pSelected );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getSelectedAccessibleRows()" );
+    }
+
+    return 0;
+}
+
+/*****************************************************************************/
+
+static gboolean
+table_wrapper_is_column_selected( AtkTable      *table,
+                                  gint          column )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "isAccessibleColumnSelected( %u ) returns %s\n", 
+                column, pTable->isAccessibleColumnSelected( column ) ? "true" : "false" );
+#endif
+        
+        if( pTable )
+            return pTable->isAccessibleColumnSelected( column );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in isAccessibleColumnSelected()" );
+    }
+
+    return 0;
+}
+
+/*****************************************************************************/
+
+static gboolean
+table_wrapper_is_row_selected( AtkTable      *table,
+                               gint          row )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "isAccessibleRowSelected( %u ) returns %s\n", 
+                row, pTable->isAccessibleRowSelected( row ) ? "true" : "false" );
+#endif
+        
+        if( pTable )
+            return pTable->isAccessibleRowSelected( row );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in isAccessibleRowSelected()" );
+    }
+
+    return FALSE;
+}
+
+/*****************************************************************************/
+
+static gboolean
+table_wrapper_is_selected( AtkTable      *table,
+                           gint          row,
+                           gint          column )
+{
+    try {
+        accessibility::XAccessibleTable* pTable = getTable( table );
+        
+#ifdef ENABLE_TRACING
+        if( pTable )
+            fprintf(stderr, "isAccessibleSelected( %u, %u ) returns %s\n", 
+                row, column, pTable->isAccessibleSelected( row , column ) ? "true" : "false" );
+#endif
+        
+        if( pTable )
+            return pTable->isAccessibleSelected( row, column );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in isAccessibleSelected()" );
+    }
+
+    return FALSE;
+}
+
+/*****************************************************************************/
+
+static gboolean
+table_wrapper_add_row_selection( AtkTable      *table,
+                                 gint          row )
+{
+    g_warning( "FIXME: no simple analogue for add_row_selection" );
+    return 0;
+}
+
+
+/*****************************************************************************/
+
+static gboolean
+table_wrapper_remove_row_selection( AtkTable      *table,
+                                    gint          row )
+{
+    g_warning( "FIXME: no simple analogue for remove_row_selection" );
+    return 0;
+}
+
+/*****************************************************************************/
+
+static gboolean
+table_wrapper_add_column_table( AtkTable      *table,
+                                gint          column )
+{
+    g_warning( "FIXME: no simple analogue for add_column_table" );
+    return 0;
+}
+
+/*****************************************************************************/
+
+static gboolean
+table_wrapper_remove_column_table( AtkTable      *table,
+                                   gint          column)
+{
+    g_warning( "FIXME: no simple analogue for remove_column_table" );
+    return 0;
+}
+
+/*****************************************************************************/
+
+static void
+table_wrapper_set_caption( AtkTable  *table,
+                           AtkObject *caption )
+{ // meaningless helper
+}
+
+/*****************************************************************************/
+
+static void
+table_wrapper_set_column_description( AtkTable    *table,
+                                      gint         column,
+                                      const gchar *description )
+{ // meaningless helper
+}
+
+
+/*****************************************************************************/
+
+static void
+table_wrapper_set_column_header( AtkTable      *table,
+                                 gint          column,
+                                 AtkObject     *header )
+{ // meaningless helper
+}
+
+
+/*****************************************************************************/
+
+static void
+table_wrapper_set_row_description( AtkTable      *table,
+                                   gint          row,
+                                   const gchar   *description )
+{ // meaningless helper
+}
+
+/*****************************************************************************/
+
+static void
+table_wrapper_set_row_header( AtkTable      *table,
+                              gint          row,
+                              AtkObject     *header )
+{ // meaningless helper
+}
+
+/*****************************************************************************/
+
+static void
+table_wrapper_set_summary( AtkTable      *table,
+                           AtkObject     *accessible )
+{ // meaningless helper
+}
+
+/*****************************************************************************/
+
+} // extern "C"
+
+void
+tableIfaceInit (AtkTableIface *iface)
+{
+  g_return_if_fail (iface != NULL);
+
+  iface->ref_at = table_wrapper_ref_at;
+  iface->get_n_rows = table_wrapper_get_n_rows; 
+  iface->get_n_columns = table_wrapper_get_n_columns;   
+  iface->get_index_at = table_wrapper_get_index_at; 
+  iface->get_column_at_index = table_wrapper_get_column_at_index;   
+  iface->get_row_at_index = table_wrapper_get_row_at_index; 
+  iface->is_row_selected = table_wrapper_is_row_selected;
+  iface->is_selected = table_wrapper_is_selected;
+  iface->get_selected_rows = table_wrapper_get_selected_rows;
+  iface->add_row_selection = table_wrapper_add_row_selection;
+  iface->remove_row_selection = table_wrapper_remove_row_selection;
+  iface->get_column_extent_at = table_wrapper_get_column_extent_at;
+  iface->get_row_extent_at = table_wrapper_get_row_extent_at;
+  iface->get_row_header = table_wrapper_get_row_header;
+  iface->set_row_header = table_wrapper_set_row_header;
+  iface->get_column_header = table_wrapper_get_column_header;
+  iface->set_column_header = table_wrapper_set_column_header;
+  iface->get_caption = table_wrapper_get_caption;
+  iface->set_caption = table_wrapper_set_caption;
+  iface->get_summary = table_wrapper_get_summary;
+  iface->set_summary = table_wrapper_set_summary;
+  iface->get_row_description = table_wrapper_get_row_description;
+  iface->set_row_description = table_wrapper_set_row_description;
+  iface->get_column_description = table_wrapper_get_column_description;
+  iface->set_column_description = table_wrapper_set_column_description;
+}
Index: vcl/unx/gtk/a11y/atktext.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atktext.cxx
diff -N vcl/unx/gtk/a11y/atktext.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atktext.cxx	15 Feb 2006 10:59:25 -0000	1.1.2.12
@@ -0,0 +1,547 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "atkwrapper.hxx"
+#include "atktextattributes.hxx"
+
+#include <com/sun/star/accessibility/AccessibleTextType.hpp>
+#include <com/sun/star/accessibility/TextSegment.hpp>
+#include <com/sun/star/accessibility/XAccessibleText.hpp>
+
+using namespace ::com::sun::star;
+
+static sal_Int16
+text_type_from_boundary(AtkTextBoundary boundary_type)
+{
+    switch(boundary_type)
+    {
+        case ATK_TEXT_BOUNDARY_CHAR:
+            return accessibility::AccessibleTextType::CHARACTER;
+        case ATK_TEXT_BOUNDARY_WORD_START:
+        case ATK_TEXT_BOUNDARY_WORD_END:
+            return accessibility::AccessibleTextType::WORD;
+        case ATK_TEXT_BOUNDARY_SENTENCE_START:
+        case ATK_TEXT_BOUNDARY_SENTENCE_END:
+            return accessibility::AccessibleTextType::SENTENCE;
+        case ATK_TEXT_BOUNDARY_LINE_START:
+        case ATK_TEXT_BOUNDARY_LINE_END:
+            return accessibility::AccessibleTextType::LINE;
+        default:
+            return -1;
+    }
+}
+
+/*****************************************************************************/
+
+static gchar *
+adjust_boundaries( accessibility::XAccessibleText* pText,
+                   accessibility::TextSegment& rTextSegment, 
+                   AtkTextBoundary  boundary_type, 
+                   gint * start_offset, gint * end_offset )
+{
+    accessibility::TextSegment aTextSegment;
+    rtl::OUString aString;
+    gint start = 0, end = 0;
+    
+    if( rTextSegment.SegmentText.getLength() > 0 )
+    {
+        switch(boundary_type)
+        {
+        case ATK_TEXT_BOUNDARY_CHAR:
+            start = rTextSegment.SegmentStart;
+            end = rTextSegment.SegmentEnd;
+            aString = rTextSegment.SegmentText;
+            break;
+                
+        case ATK_TEXT_BOUNDARY_WORD_START:
+        case ATK_TEXT_BOUNDARY_SENTENCE_START:
+        case ATK_TEXT_BOUNDARY_LINE_START:
+            start = rTextSegment.SegmentStart;
+            
+            // Determine the start index of the next segment
+            aTextSegment = pText->getTextBehindIndex(rTextSegment.SegmentEnd, 
+                                                     text_type_from_boundary(boundary_type));
+            if( aTextSegment.SegmentText.getLength() > 0 )
+                end = aTextSegment.SegmentStart - 1;
+            else
+                end = pText->getCharacterCount();
+            
+            aString = pText->getTextRange(start, end);
+            break;
+                
+        case ATK_TEXT_BOUNDARY_WORD_END:
+        case ATK_TEXT_BOUNDARY_SENTENCE_END:
+        case ATK_TEXT_BOUNDARY_LINE_END:
+            end = rTextSegment.SegmentEnd;
+            
+            // Determine the end index of the previous segment
+            aTextSegment = pText->getTextBeforeIndex(rTextSegment.SegmentStart, 
+                                                     text_type_from_boundary(boundary_type));
+            if( aTextSegment.SegmentText.getLength() > 0 )
+                start = aTextSegment.SegmentEnd + 1;
+            else
+                start = 0;
+            
+            aString = pText->getTextRange(start, end);
+            break;
+        
+        default:
+            return NULL;
+        }
+    }
+    
+    *start_offset = start;
+    *end_offset   = end;
+    return OUStringToGChar(aString);
+}
+
+/*****************************************************************************/
+
+static accessibility::XAccessibleText*
+    getText( AtkText *pText ) throw (uno::RuntimeException)
+{
+    AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( pText );
+    if( pWrap )
+    {
+        if( !pWrap->mpText && pWrap->mpContext )
+        {
+            uno::Any any = pWrap->mpContext->queryInterface( accessibility::XAccessibleText::static_type(NULL) );
+            pWrap->mpText = reinterpret_cast< accessibility::XAccessibleText * > (any.pReserved);
+            pWrap->mpText->acquire();
+        }
+        
+        return pWrap->mpText;
+    }
+    
+    return NULL;
+}
+
+/*****************************************************************************/
+
+extern "C" {
+
+static gchar *
+text_wrapper_get_text (AtkText *text,
+                       gint     start_offset,
+                       gint     end_offset)
+{
+    gchar * ret = NULL;
+    
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+        {
+            rtl::OString aUtf8 = rtl::OUStringToOString( pText->getText(), RTL_TEXTENCODING_UTF8 );
+            if( -1 == end_offset )
+                ret = g_strdup( aUtf8.getStr() );
+            else
+                ret = g_strndup( aUtf8.getStr() + start_offset, end_offset - start_offset );
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getText()" );
+    }
+    
+    return ret;
+}
+
+static gchar *
+text_wrapper_get_text_after_offset (AtkText          *text,
+                                    gint             offset,
+                                    AtkTextBoundary  boundary_type,
+                                    gint             *start_offset,
+                                    gint             *end_offset)
+{
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+        {
+            accessibility::TextSegment aTextSegment = pText->getTextBehindIndex(offset, text_type_from_boundary(boundary_type));
+            return adjust_boundaries(pText, aTextSegment, boundary_type, start_offset, end_offset);
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in get_text_after_offset()" );
+    }
+    
+    return NULL;
+}
+
+static gchar *
+text_wrapper_get_text_at_offset (AtkText          *text,
+                                 gint             offset,
+                                 AtkTextBoundary  boundary_type,
+                                 gint             *start_offset,
+                                 gint             *end_offset)
+{
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+        {
+            accessibility::TextSegment aTextSegment = pText->getTextAtIndex(offset, text_type_from_boundary(boundary_type));
+            return adjust_boundaries(pText, aTextSegment, boundary_type, start_offset, end_offset);
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in get_text_at_offset()" );
+    }
+    
+    return NULL;
+}
+
+static gunichar
+text_wrapper_get_character_at_offset (AtkText          *text,
+                                      gint             offset)
+{
+    gint start, end;
+    gunichar uc = 0;
+    
+    gchar * char_as_string = 
+        text_wrapper_get_text_at_offset(text, offset, ATK_TEXT_BOUNDARY_CHAR, 
+                                        &start, &end);
+    if( char_as_string )
+    {
+        uc = g_utf8_get_char( char_as_string );
+        g_free( char_as_string );
+    }
+    
+    return uc;
+}
+
+static gchar *
+text_wrapper_get_text_before_offset (AtkText          *text,
+                                     gint             offset,
+                                     AtkTextBoundary  boundary_type,
+                                     gint             *start_offset,
+                                     gint             *end_offset)
+{
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+        {
+            accessibility::TextSegment aTextSegment = pText->getTextBeforeIndex(offset, text_type_from_boundary(boundary_type));
+            return adjust_boundaries(pText, aTextSegment, boundary_type, start_offset, end_offset);
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in text_before_offset()" );
+    }
+    
+    return NULL;
+}
+
+static gint
+text_wrapper_get_caret_offset (AtkText          *text)
+{
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+            return pText->getCaretPosition();
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getCaretPosition()" );
+    }
+    
+    return -1;
+}
+
+static gboolean
+text_wrapper_set_caret_offset (AtkText *text,
+                               gint     offset)
+{
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+            return pText->setCaretPosition( offset );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in setCaretPosition()" );
+    }
+    
+    return FALSE;
+}
+
+static AtkAttributeSet *
+text_wrapper_get_run_attributes( AtkText        *text,
+                                 gint           offset,
+                                 gint           *start_offset,
+                                 gint           *end_offset)
+{
+    AtkAttributeSet *pSet = NULL;
+    
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+        {
+            uno::Sequence< beans::PropertyValue > aAttributeList = 
+                pText->getCharacterAttributes( offset, uno::Sequence< rtl::OUString > () );
+            
+            pSet = attribute_set_new_from_property_values( aAttributeList, beans::PropertyState_DIRECT_VALUE );
+            
+            accessibility::TextSegment aTextSegment = 
+                pText->getTextAtIndex(offset, accessibility::AccessibleTextType::ATTRIBUTE_RUN);
+            
+            *start_offset = aTextSegment.SegmentStart;
+            *end_offset = aTextSegment.SegmentEnd + 1; // FIXME: TESTME
+        }
+    }
+    catch(const uno::Exception& e) {
+        
+        g_warning( "Exception in get_run_attributes()" );
+        
+        if( pSet )
+        {
+            atk_attribute_set_free( pSet );
+            pSet = NULL;
+        }
+    }
+    
+    return pSet;
+}
+
+static AtkAttributeSet *
+text_wrapper_get_default_attributes( AtkText *text )
+{
+    // currently there is no way to determine the default values. Maybe getCharacterAttributes
+    // should return default and direct values ??
+    g_warning( "FIXME: get_default_attributes unimplemented - needs new UNO API semantic" );
+    return NULL;
+}
+
+static void
+text_wrapper_get_character_extents( AtkText          *text,
+                                    gint             offset,
+                                    gint             *x,
+                                    gint             *y,
+                                    gint             *width,
+                                    gint             *height,
+                                    AtkCoordType      coords )
+{
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+        {
+            *x = *y = *width = *height = 0;
+            awt::Rectangle aRect = pText->getCharacterBounds( offset );
+            
+            gint origin_x = 0;
+            gint origin_y = 0;
+            
+            if( coords == ATK_XY_SCREEN )
+            {
+                g_return_if_fail( ATK_IS_COMPONENT( text ) );
+                atk_component_get_position( ATK_COMPONENT( text ), &origin_x, &origin_y, coords);
+            }
+            
+            *x = aRect.X + origin_x;
+            *y = aRect.Y + origin_y;
+            *width = aRect.Width;
+            *height = aRect.Height;
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getCharacterBounds" );
+    }
+}
+
+static gint
+text_wrapper_get_character_count (AtkText *text)
+{
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+            return pText->getCharacterCount();
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getCharacterCount" );
+    }
+    
+    return 0;
+}
+
+static gint
+text_wrapper_get_offset_at_point (AtkText     *text,
+                                  gint         x,
+                                  gint         y,
+                                  AtkCoordType coords)
+{
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+        {
+            gint origin_x = 0;
+            gint origin_y = 0;
+            
+            if( coords == ATK_XY_SCREEN )
+            {
+                g_return_val_if_fail( ATK_IS_COMPONENT( text ), -1 );
+                atk_component_get_position( ATK_COMPONENT( text ), &origin_x, &origin_y, coords);
+            }
+            
+            return pText->getIndexAtPoint( awt::Point(x - origin_x, y - origin_y) );
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getIndexAtPoint" );
+    }
+    
+    return -1;
+}
+
+// FIXME: the whole series of selections API is problematic ...
+
+static gint
+text_wrapper_get_n_selections (AtkText *text)
+{
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+            return ( pText->getSelectionEnd() > pText->getSelectionStart() ) ? 1 : 0;
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getSelectionEnd() or getSelectionStart()" );
+    }
+    
+    return 0;
+}
+
+static gchar *
+text_wrapper_get_selection (AtkText *text,
+                            gint     selection_num,
+                            gint    *start_offset,
+                            gint    *end_offset)
+{
+    g_return_val_if_fail( selection_num == 0, FALSE );
+
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+        {
+            *start_offset = pText->getSelectionStart();
+            *end_offset   = pText->getSelectionEnd();
+
+            return OUStringToGChar( pText->getSelectedText() );
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getSelectionEnd(), getSelectionStart() or getSelectedText()" );
+    }
+    
+    return NULL;
+}       
+
+static gboolean
+text_wrapper_add_selection (AtkText *text,
+                            gint     start_offset,
+                            gint     end_offset)
+{
+    // FIXME: can we try to be more compatible by expanding an
+    //        existing adjacent selection ?
+
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+            return pText->setSelection( start_offset, end_offset ); // ?
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in setSelection()" );
+    }
+    
+    return FALSE;
+}
+
+static gboolean
+text_wrapper_remove_selection (AtkText *text,
+                               gint     selection_num)
+{
+    g_return_val_if_fail( selection_num == 0, FALSE );
+
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+            return pText->setSelection( 0, 0 ); // ?
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in setSelection()" );
+    }
+    
+    return FALSE;
+}
+
+static gboolean
+text_wrapper_set_selection (AtkText *text,
+                            gint     selection_num,
+                            gint     start_offset,
+                            gint     end_offset)
+{
+    g_return_val_if_fail( selection_num == 0, FALSE );
+    
+    try {
+        accessibility::XAccessibleText* pText = getText( text );
+        if( pText )
+            return pText->setSelection( 0, 0 ); // ?
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in setSelection()" );
+    }
+    
+    return FALSE;
+}
+
+} // extern "C"
+
+void
+textIfaceInit (AtkTextIface *iface)
+{
+  g_return_if_fail (iface != NULL);
+
+  iface->get_text = text_wrapper_get_text;
+  iface->get_character_at_offset = text_wrapper_get_character_at_offset;
+  iface->get_text_before_offset = text_wrapper_get_text_before_offset;
+  iface->get_text_at_offset = text_wrapper_get_text_at_offset;
+  iface->get_text_after_offset = text_wrapper_get_text_after_offset;
+  iface->get_caret_offset = text_wrapper_get_caret_offset;
+  iface->set_caret_offset = text_wrapper_set_caret_offset;
+  iface->get_character_count = text_wrapper_get_character_count;
+  iface->get_n_selections = text_wrapper_get_n_selections;
+  iface->get_selection = text_wrapper_get_selection;
+  iface->add_selection = text_wrapper_add_selection;
+  iface->remove_selection = text_wrapper_remove_selection;
+  iface->set_selection = text_wrapper_set_selection;
+  iface->get_run_attributes = text_wrapper_get_run_attributes;
+  iface->get_default_attributes = text_wrapper_get_default_attributes;
+  iface->get_character_extents = text_wrapper_get_character_extents;
+  iface->get_offset_at_point = text_wrapper_get_offset_at_point;
+}
Index: vcl/unx/gtk/a11y/atktextattributes.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atktextattributes.cxx
diff -N vcl/unx/gtk/a11y/atktextattributes.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atktextattributes.cxx	14 Feb 2006 12:42:40 -0000	1.1.2.2
@@ -0,0 +1,572 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "atktextattributes.hxx"
+
+#include <com/sun/star/awt/FontSlant.hpp>
+#include <com/sun/star/awt/FontStrikeout.hpp>
+#include <com/sun/star/awt/FontUnderline.hpp>
+
+#include <com/sun/star/style/ParagraphAdjust.hpp>
+
+#include <svapp.hxx>
+#include <outdev.hxx>
+
+#include <stdio.h>
+#include <string.h>
+
+using namespace ::com::sun::star;
+
+typedef gchar* (* AtkTextAttrFunc)       ( const uno::Any& rAny );
+typedef bool   (* TextPropertyValueFunc) ( uno::Any& rAny, const gchar * value );
+
+#define STRNCMP_PARAM( s )  s,sizeof( s )-1
+
+/*****************************************************************************/
+
+static gchar* 
+NullString(const uno::Any& rAny)
+{
+    return NULL;
+}
+
+static bool 
+InvalidValue( uno::Any& rAny, const gchar * value )
+{
+    return false;
+}
+
+/*****************************************************************************/
+
+static gchar* 
+Float2String(const uno::Any& rAny)
+{
+    return g_strdup_printf( "%.0f", rAny.get<float>() );
+}
+
+static bool 
+String2Float( uno::Any& rAny, const gchar * value )
+{
+    float fval;
+    
+    if( 1 != sscanf( value, "%f", &fval ) )
+        return false;
+    
+    rAny = uno::makeAny( fval );
+    return true;
+}
+
+/*****************************************************************************/
+
+static gchar*
+Long2String(const uno::Any& rAny)
+{
+    return g_strdup_printf( "%d", rAny.get<sal_Int32>() );
+}
+
+static bool 
+String2Long( uno::Any& rAny, const gchar * value )
+{
+    sal_Int32 lval;
+    
+    if( 1 != sscanf( value, "%d", &lval ) )
+        return false;
+    
+    rAny = uno::makeAny( lval );
+    return true;
+}
+
+/*****************************************************************************/
+
+static gchar* 
+Color2String(const uno::Any& rAny)
+{
+    sal_Int32 nColor = rAny.get<sal_Int32>();
+    
+    if( nColor != 0xFFFFFFFF ) // AUTOMATIC
+    {
+        sal_uInt8 blue  = nColor & 0xFF;
+        sal_uInt8 green = (nColor >> 8) & 0xFF;
+        sal_uInt8 red   = (nColor >> 16) & 0xFF;
+        
+        return g_strdup_printf( "%u,%u,%u", red, green, blue );
+    }
+    
+    return NULL;
+}
+
+static bool 
+String2Color( uno::Any& rAny, const gchar * value )
+{
+    sal_uInt8 red, green, blue;
+    
+    if( 3 != sscanf( value, "%u,%u,%u", &red, &green, &blue ) )
+        return false;
+    
+    sal_Int32 nColor = (sal_Int32) blue | ( (sal_Int32) green << 8 ) | ( ( sal_Int32 ) red << 16 );
+    rAny = uno::makeAny( nColor );
+    return true;
+}
+
+/*****************************************************************************/
+
+static gchar* 
+FontSlant2Style(const uno::Any& rAny)
+{            
+    const gchar * value = NULL;
+    
+    switch( rAny.get<awt::FontSlant>() )
+    {
+        case awt::FontSlant_NONE:
+            value = "normal";
+            break;
+            
+        case awt::FontSlant_OBLIQUE:
+            value = "oblique";
+            break;
+            
+        case awt::FontSlant_ITALIC:
+            value = "italic";
+            break;
+            
+        case awt::FontSlant_REVERSE_OBLIQUE:
+            value = "reverse oblique";
+            break;
+            
+        case awt::FontSlant_REVERSE_ITALIC:
+            value = "reverse italic";
+            break;
+            
+        default:
+            break;
+    }
+    
+    if( value )
+         return g_strdup( value );
+    
+    return NULL;
+}
+
+static bool 
+Style2FontSlant( uno::Any& rAny, const gchar * value )
+{
+    awt::FontSlant aFontSlant;
+    
+    if( strncmp( value, STRNCMP_PARAM( "normal" ) ) )
+        aFontSlant = awt::FontSlant_NONE;
+    else if( strncmp( value, STRNCMP_PARAM( "oblique" ) ) )
+        aFontSlant = awt::FontSlant_OBLIQUE;
+    else if( strncmp( value, STRNCMP_PARAM( "italic" ) ) )
+        aFontSlant = awt::FontSlant_ITALIC;
+    else if( strncmp( value, STRNCMP_PARAM( "reverse oblique" ) ) )
+        aFontSlant = awt::FontSlant_REVERSE_OBLIQUE;
+    else if( strncmp( value, STRNCMP_PARAM( "reverse italic" ) ) )
+        aFontSlant = awt::FontSlant_REVERSE_ITALIC;
+    else
+        return false;
+    
+    rAny = uno::makeAny( aFontSlant );
+    return true;
+}
+
+/*****************************************************************************/
+
+static gchar* 
+Weight2String(const uno::Any& rAny)
+{
+    return g_strdup_printf( "%.0f", rAny.get<float>() * 4 );
+}
+
+static bool 
+String2Weight( uno::Any& rAny, const gchar * value )
+{
+    float weight;
+    
+    if( 1 != sscanf( value, "%f", &weight ) )
+        return false;
+    
+    rAny = uno::makeAny( weight / 4 );
+    return true;
+}
+
+
+/*****************************************************************************/
+
+static gchar* 
+Adjust2Justification(const uno::Any& rAny)
+{
+    const gchar * value = NULL;
+    
+    switch( rAny.get<short>() )
+    {
+        case style::ParagraphAdjust_LEFT:
+            value = "left";
+            break;
+        
+        case style::ParagraphAdjust_RIGHT:
+            value = "right";
+            break;
+            
+        case style::ParagraphAdjust_BLOCK:
+        case style::ParagraphAdjust_STRETCH:
+            value = "fill";
+            break;
+            
+        case style::ParagraphAdjust_CENTER:
+            value = "center";
+            break;
+            
+        default:
+            break;
+    }
+    
+    if( value )
+        return g_strdup( value );
+    
+    return NULL;
+}
+
+static bool 
+Justification2Adjust( uno::Any& rAny, const gchar * value )
+{
+    short nParagraphAdjust;
+    
+    if( strncmp( value, STRNCMP_PARAM( "left" ) ) )
+        nParagraphAdjust = style::ParagraphAdjust_LEFT;
+    else if( strncmp( value, STRNCMP_PARAM( "right" ) ) )
+        nParagraphAdjust = style::ParagraphAdjust_RIGHT;
+    else if( strncmp( value, STRNCMP_PARAM( "fill" ) ) )
+        nParagraphAdjust = style::ParagraphAdjust_BLOCK;
+    else if( strncmp( value, STRNCMP_PARAM( "center" ) ) )
+        nParagraphAdjust = style::ParagraphAdjust_CENTER;
+    else
+        return false;
+    
+    rAny = uno::makeAny( nParagraphAdjust );
+    return true;
+}
+
+/*****************************************************************************/
+
+static gchar* 
+Strikeout2String(const uno::Any& rAny)
+{
+    sal_Int16 nStrikeout = rAny.get<sal_Int16>();
+    
+    if( nStrikeout != 3 ) // DONTKNOW
+        return g_strdup( nStrikeout ? "true" : "false" );
+    
+    return NULL;
+}
+
+static bool 
+String2Strikeout( uno::Any& rAny, const gchar * value )
+{
+    sal_Int16 nStrikeout;
+    
+    if( strncmp( value, STRNCMP_PARAM( "true" ) ) )
+        nStrikeout = awt::FontStrikeout::SINGLE;
+    else if( strncmp( value, STRNCMP_PARAM( "false" ) ) )
+        nStrikeout = awt::FontStrikeout::NONE;
+    else
+        return false;
+    
+    rAny = uno::makeAny( nStrikeout );
+    return true;
+}
+
+/*****************************************************************************/
+
+static gchar* 
+Underline2String(const uno::Any& rAny)
+{
+    const gchar * value = NULL;
+    
+    switch( rAny.get<short>() )
+    {
+        case awt::FontUnderline::NONE:
+            value = "none";
+            break;
+
+        case awt::FontUnderline::SINGLE:
+            value = "single";
+            break;
+                    
+        case awt::FontUnderline::DOUBLE:
+            value = "double";
+            break;
+                    
+        default:
+            break;
+    }
+    
+    if( value )
+        return g_strdup( value );
+    
+    return NULL;
+}
+
+static bool 
+String2Underline( uno::Any& rAny, const gchar * value )
+{
+    short nUnderline;
+    
+    if( strncmp( value, STRNCMP_PARAM( "none" ) ) )
+        nUnderline = awt::FontUnderline::NONE;
+    else if( strncmp( value, STRNCMP_PARAM( "single" ) ) )
+        nUnderline = awt::FontUnderline::SINGLE;
+    else if( strncmp( value, STRNCMP_PARAM( "double" ) ) )
+        nUnderline = awt::FontUnderline::DOUBLE;
+    else
+        return false;
+    
+    rAny = uno::makeAny( nUnderline );
+    return true;
+}
+
+/*****************************************************************************/
+
+static inline Size
+LogicToPixel( long margin_x, long margin_y )
+{
+    OutputDevice * pOutputDevice = Application::GetDefaultDevice();
+    return pOutputDevice->LogicToPixel( Size( margin_x, margin_y ), MapMode( MAP_100TH_MM ) );
+}
+
+static inline Size
+PixelToLogic( long margin_x, long margin_y )
+{
+    OutputDevice * pOutputDevice = Application::GetDefaultDevice();
+    return pOutputDevice->PixelToLogic( Size( margin_x, margin_y ), MapMode( MAP_100TH_MM ) );
+}
+
+static gchar* 
+MarginHeight2Pixel(const uno::Any& rAny)
+{
+    Size aMargin = LogicToPixel( 0, rAny.get<sal_Int32>() );
+    return g_strdup_printf( "%d",  aMargin.getHeight() );
+}
+
+static bool 
+Pixel2MarginHeight( uno::Any& rAny, const gchar * value )
+{
+    sal_Int32 nHeight;
+    
+    if( 1 != sscanf( value, "%d", &nHeight ) )
+        return false;
+    
+    Size aMargin = PixelToLogic( 0, nHeight );
+    rAny = uno::makeAny( (sal_Int32) aMargin.getHeight() );
+    return true;
+}
+
+static gchar* 
+MarginWidth2Pixel(const uno::Any& rAny)
+{
+    Size aMargin = LogicToPixel( rAny.get<sal_Int32>(), 0 );
+    return g_strdup_printf( "%d",  aMargin.getWidth() );
+}
+
+static bool 
+Pixel2MarginWidth( uno::Any& rAny, const gchar * value )
+{
+    sal_Int32 nWidth;
+    
+    if( 1 != sscanf( value, "%d", &nWidth ) )
+        return false;
+    
+    Size aMargin = PixelToLogic( nWidth, 0 );
+    rAny = uno::makeAny( (sal_Int32) aMargin.getWidth() );
+    return true;
+}
+
+/*****************************************************************************/
+
+struct AtkTextAttrMapping
+{
+    const char *          name;
+    AtkTextAttrFunc       toAtkTextAttr;
+    TextPropertyValueFunc toPropertyValue;
+};
+
+const AtkTextAttrMapping g_TextAttrMap[] =
+{
+    { "", NullString,   InvalidValue },                             // ATK_TEXT_ATTR_INVALID = 0
+    { "ParaLeftMargin", MarginWidth2Pixel, Pixel2MarginWidth },     // ATK_TEXT_ATTR_LEFT_MARGIN
+    { "ParaRightMargin", MarginWidth2Pixel, Pixel2MarginWidth },    // ATK_TEXT_ATTR_RIGHT_MARGIN
+    { "ParaFirstLineIndent", Long2String, String2Long },            // ATK_TEXT_ATTR_INDENT
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_INVISIBLE
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_EDITABLE
+    { "ParaTopMargin", MarginHeight2Pixel, Pixel2MarginHeight },    // ATK_TEXT_ATTR_PIXELS_ABOVE_LINES
+    { "ParaBottomMargin", MarginHeight2Pixel, Pixel2MarginHeight }, // ATK_TEXT_ATTR_PIXELS_BELOW_LINES
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_PIXELS_INSIDE_WRAP
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_BG_FULL_HEIGHT
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_RISE
+    { "CharUnderline", Underline2String, String2Underline },        // ATK_TEXT_ATTR_UNDERLINE
+    { "CharStrikeout", Strikeout2String, String2Strikeout },        // ATK_TEXT_ATTR_STRIKETHROUGH
+    { "CharHeight", Float2String, String2Float },                   // ATK_TEXT_ATTR_SIZE
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_SCALE
+    { "CharWeight", Weight2String, String2Weight },                 // ATK_TEXT_ATTR_WEIGHT
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_LANGUAGE
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_FAMILY_NAME
+    { "CharBackColor", Color2String, String2Color },                // ATK_TEXT_ATTR_BG_COLOR
+    { "CharColor", Color2String, String2Color },                    // ATK_TEXT_ATTR_FG_COLOR
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_BG_STIPPLE
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_FG_STIPPLE
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_WRAP_MODE
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_DIRECTION
+    { "ParaAdjust", Adjust2Justification, Justification2Adjust },   // ATK_TEXT_ATTR_JUSTIFICATION
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_STRETCH
+    { "", NullString,   InvalidValue },      // ATK_TEXT_ATTR_VARIANT
+    { "CharPosture", FontSlant2Style, Style2FontSlant }             // ATK_TEXT_ATTR_STYLE
+};
+
+//
+//        FIXME !!
+//        "ParaLineSpacing" => ATK_TEXT_ATTR_PIXELS_INSIDE_WRAP ?
+
+static const sal_Int32 g_TextAttrMapSize = sizeof( g_TextAttrMap ) / sizeof( AtkTextAttrMapping );
+
+/*****************************************************************************/
+
+static AtkAttributeSet*
+attribute_set_prepend( AtkAttributeSet* attribute_set, 
+                       AtkTextAttribute attribute,
+                       gchar * value )
+{
+    AtkAttribute *at = (AtkAttribute *) g_malloc( sizeof (AtkAttribute) );
+    at->name  = g_strdup( atk_text_attribute_get_name( attribute ) );
+    at->value = value;
+    
+    return g_slist_prepend(attribute_set, at);
+}
+
+/*****************************************************************************/
+
+AtkAttributeSet* 
+attribute_set_new_from_property_values( 
+    const uno::Sequence< beans::PropertyValue >& rAttributeList,
+    const beans::PropertyState ePropertyState )
+{
+    AtkAttributeSet* attribute_set = NULL;
+    
+    for( sal_Int32 i = 0; i < rAttributeList.getLength(); i++ )
+    {
+        if( rAttributeList[i].State != ePropertyState )
+            continue;
+        
+        gint j = 0;
+        for( ; j < g_TextAttrMapSize; ++j )
+        {
+            if( 0 == rAttributeList[i].Name.compareToAscii( g_TextAttrMap[j].name ) )
+            {
+                gchar * value = g_TextAttrMap[j].toAtkTextAttr(rAttributeList[i].Value);
+                if( value )
+                    attribute_set = attribute_set_prepend( attribute_set, static_cast < AtkTextAttribute > (j), value );
+                
+                break;
+            }
+        }
+
+/*
+        if( j == g_TextAttrMapSize )
+        {
+            const char * state = "unknown";
+            switch( rAttributeList[i].State )
+            {
+                case beans::PropertyState_DIRECT_VALUE:
+                    state = "direct value";
+                    break;
+                    
+                case beans::PropertyState_DEFAULT_VALUE:
+                    state = "default value";
+                    break;
+                    
+                case beans::PropertyState_AMBIGUOUS_VALUE:
+                    state = "ambigues value";
+                    break;
+                    
+                default:
+                    break;
+            }
+            
+            fprintf(stderr, "Property %s (%s)\n", OUStringToOString( rAttributeList[i].Name, RTL_TEXTENCODING_UTF8 ).getStr(), state);
+        }
+*/
+    }
+    
+    return attribute_set;
+}
+
+/*****************************************************************************/
+
+bool
+attribute_set_map_to_property_values(
+    AtkAttributeSet* attribute_set, 
+    uno::Sequence< beans::PropertyValue >& rValueList )
+{
+    // Ensure enough space ..
+    uno::Sequence< beans::PropertyValue > aAttributeList (g_TextAttrMapSize);
+
+    sal_Int32 nIndex = 0;
+    for( GSList * item = attribute_set; item != NULL; item = g_slist_next( item ) )
+    {
+        AtkAttribute* attribute = (AtkAttribute *) item;
+        
+        AtkTextAttribute text_attr = atk_text_attribute_for_name( attribute->name );
+        if( text_attr < g_TextAttrMapSize )
+        {
+            if( g_TextAttrMap[text_attr].name[0] != '\0' )
+            {
+                if( ! g_TextAttrMap[text_attr].toPropertyValue( aAttributeList[nIndex].Value, attribute->value) )
+                    return false;
+                
+                aAttributeList[nIndex].Name = rtl::OUString::createFromAscii( g_TextAttrMap[text_attr].name );
+                aAttributeList[nIndex].State = beans::PropertyState_DIRECT_VALUE;
+                ++nIndex;
+            }
+        }
+        else
+        {
+            // Unsupported text attribute
+            return false;
+        }
+    }
+
+    aAttributeList.realloc( nIndex );
+    rValueList = aAttributeList;
+    return true;
+}
+
Index: vcl/unx/gtk/a11y/atktextattributes.hxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atktextattributes.hxx
diff -N vcl/unx/gtk/a11y/atktextattributes.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atktextattributes.hxx	22 Dec 2005 08:24:30 -0000	1.1.2.1
@@ -0,0 +1,60 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __ATK_ATKTEXTATTRIBUTES_HXX__
+#define __ATK_ATKTEXTATTRIBUTES_HXX__
+
+#ifndef _COM_SUN_STAR_UNO_SEQUENCE_HXX_
+#include <com/sun/star/uno/Sequence.hxx>
+#endif
+
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_
+#include <com/sun/star/beans/PropertyValue.hpp>
+#endif
+
+#include <atk/atk.h>
+
+AtkAttributeSet* 
+attribute_set_new_from_property_values( 
+    const com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue >& rAttributeList,
+    const com::sun::star::beans::PropertyState ePropertyState );
+
+bool
+attribute_set_map_to_property_values( 
+    AtkAttributeSet* attribute_set, 
+    com::sun::star::uno::Sequence< com::sun::star::beans::PropertyValue >& rValueList );
+
+
+#endif
Index: vcl/unx/gtk/a11y/atkutil.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkutil.cxx
diff -N vcl/unx/gtk/a11y/atkutil.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkutil.cxx	3 Mar 2006 11:07:09 -0000	1.1.2.14
@@ -0,0 +1,625 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _COM_SUN_STAR_ACCESSIBILITY_XACCESSIBLECONTEXT_HPP_
+#include <com/sun/star/accessibility/XAccessibleContext.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_ACCESSIBILITY_XACCESSIBLEEVENTBROADCASTER_HPP_
+#include <com/sun/star/accessibility/XAccessibleEventBroadcaster.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_ACCESSIBILITY_XACCESSIBLESELECTION_HPP_
+#include <com/sun/star/accessibility/XAccessibleSelection.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_ACCESSIBILITY_ACCESSIBLEEVENTID_HPP_
+#include <com/sun/star/accessibility/AccessibleEventId.hpp>
+#endif
+
+#ifndef _COM_SUN_STAR_ACCESSIBILITY_ACCESSIBLESTATETYPE_HPP_
+#include <com/sun/star/accessibility/AccessibleStateType.hpp>
+#endif
+
+#ifndef _CPPUHELPER_IMPLBASE1_HXX_
+#include <cppuhelper/implbase1.hxx>
+#endif
+
+#ifndef _VOS_MUTEX_HXX_
+#include <vos/mutex.hxx>
+#endif
+
+#ifndef _RTL_REF_HXX_
+#include <rtl/ref.hxx>
+#endif
+
+#ifndef _SV_SVAPP_HXX
+#include "svapp.hxx"
+#endif
+
+#include <window.hxx>
+#include <menu.hxx>
+
+#include "atkwrapper.hxx"
+#include "atkutil.hxx"
+
+#include <set>
+#include <stdio.h>
+
+using namespace ::com::sun::star;
+
+static AtkObject *last_focused_object = NULL;
+
+/*****************************************************************************/
+
+extern "C" {
+
+static gint
+atk_wrapper_focus_idle_handler (gpointer data)
+{
+    vos::OGuard aGuard( Application::GetSolarMutex() );
+    
+    if( data == last_focused_object )
+        atk_focus_tracker_notify( ATK_OBJECT( data ) );
+    
+    if( data )
+        g_object_unref( G_OBJECT(data) );
+
+    return FALSE;
+}
+
+} // extern "C"
+
+/*****************************************************************************/
+
+static void                   
+atk_wrapper_focus_tracker_notify_when_idle( const uno::Reference< accessibility::XAccessible > &rAccessible )
+{
+    AtkObject *accessible = NULL;
+    
+    if( rAccessible.is() )
+        accessible = atk_object_wrapper_ref( rAccessible );
+    
+    last_focused_object = accessible;
+    g_idle_add (atk_wrapper_focus_idle_handler, accessible);
+}
+
+/*****************************************************************************/
+
+class DocumentFocusListener :  
+    public ::cppu::WeakImplHelper1< accessibility::XAccessibleEventListener >
+{
+    
+    std::set< uno::Reference< uno::XInterface > > m_aRefList;
+    
+public:
+    void attachRecursive(
+        const uno::Reference< accessibility::XAccessible >& xAccessible
+    ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException);
+    
+    void attachRecursive(
+        const uno::Reference< accessibility::XAccessible >& xAccessible,
+        const uno::Reference< accessibility::XAccessibleContext >& xContext
+    ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException);
+
+    void attachRecursive(
+        const uno::Reference< accessibility::XAccessible >& xAccessible,
+        const uno::Reference< accessibility::XAccessibleContext >& xContext,
+        const uno::Reference< accessibility::XAccessibleStateSet >& xStateSet
+    ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException);
+
+    void detachRecursive(
+        const uno::Reference< accessibility::XAccessible >& xAccessible
+    ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException);
+    
+    void detachRecursive(
+        const uno::Reference< accessibility::XAccessible >& xAccessible,
+        const uno::Reference< accessibility::XAccessibleContext >& xContext
+    ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException);
+
+    void detachRecursive(
+        const uno::Reference< accessibility::XAccessible >& xAccessible,
+        const uno::Reference< accessibility::XAccessibleContext >& xContext,
+        const uno::Reference< accessibility::XAccessibleStateSet >& xStateSet
+    ) throw (lang::IndexOutOfBoundsException, uno::RuntimeException);
+
+    static uno::Reference< accessibility::XAccessible > getAccessible(const lang::EventObject& aEvent )
+        throw (lang::IndexOutOfBoundsException, uno::RuntimeException);
+    
+    // XEventListener
+    virtual void disposing( const lang::EventObject& Source ) throw (uno::RuntimeException);
+
+    // XAccessibleEventListener
+    virtual void notifyEvent( const accessibility::AccessibleEventObject& aEvent ) throw( uno::RuntimeException );
+};
+
+/*****************************************************************************/
+
+void DocumentFocusListener::disposing( const lang::EventObject& aEvent ) 
+    throw (uno::RuntimeException)
+{
+//    fprintf(stderr, "In DocumentFocusListener::disposing (%p)\n", this);
+//    fprintf(stderr, "m_aRefList has %d entries\n", m_aRefList.size());
+    
+    // Unref the object here, but do not remove as listener since the object 
+    // might no longer be in a state that safely allows this.
+    if( aEvent.Source.is() )
+        m_aRefList.erase(aEvent.Source);
+    
+//    fprintf(stderr, "m_aRefList has %d entries\n", m_aRefList.size());
+
+}
+
+/*****************************************************************************/
+
+void DocumentFocusListener::notifyEvent( const accessibility::AccessibleEventObject& aEvent ) 
+    throw( uno::RuntimeException )
+{
+    switch( aEvent.EventId )
+    {
+        case accessibility::AccessibleEventId::STATE_CHANGED:
+            try 
+            {
+                sal_Int16 nState = accessibility::AccessibleStateType::INVALID;
+                aEvent.NewValue >>= nState;
+            
+                if( accessibility::AccessibleStateType::FOCUSED == nState )
+                    atk_wrapper_focus_tracker_notify_when_idle( getAccessible(aEvent) );
+            }
+            catch(lang::IndexOutOfBoundsException e)
+            {
+                g_warning("Focused object has invalid index in parent");
+            }
+            break;
+            
+        case accessibility::AccessibleEventId::CHILD:
+        {
+            uno::Reference< accessibility::XAccessible > xChild;
+            if( (aEvent.OldValue >>= xChild) && xChild.is() )
+                detachRecursive(xChild);
+            
+            if( (aEvent.NewValue >>= xChild) && xChild.is() )
+                attachRecursive(xChild);
+        }
+            break;
+            
+        case accessibility::AccessibleEventId::INVALIDATE_ALL_CHILDREN:
+/*        {
+            uno::Reference< accessibility::XAccessible > xAccessible( getAccessible(aEvent) );
+            detachRecursive(xAccessible);
+            attachRecursive(xAccessible);
+        }
+*/
+            fprintf(stderr, "Invalidate all children called\n" );
+            break;
+        default:
+            break;
+    }
+}
+
+/*****************************************************************************/
+
+uno::Reference< accessibility::XAccessible > DocumentFocusListener::getAccessible(const lang::EventObject& aEvent )
+    throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+{
+    uno::Reference< accessibility::XAccessible > xAccessible(aEvent.Source, uno::UNO_QUERY);
+    
+    if( xAccessible.is() )
+        return xAccessible;
+    
+    uno::Reference< accessibility::XAccessibleContext > xContext(aEvent.Source, uno::UNO_QUERY);
+
+    if( xContext.is() )
+    {
+        uno::Reference< accessibility::XAccessible > xParent( xContext->getAccessibleParent() );
+        if( xParent.is() )
+        {
+            uno::Reference< accessibility::XAccessibleContext > xParentContext( xParent->getAccessibleContext() );
+            if( xParentContext.is() )
+            {
+                return xParentContext->getAccessibleChild( xContext->getAccessibleIndexInParent() );
+            }
+        }
+    }
+    
+    return uno::Reference< accessibility::XAccessible >();
+}
+
+/*****************************************************************************/
+
+void DocumentFocusListener::attachRecursive(
+    const uno::Reference< accessibility::XAccessible >& xAccessible 
+) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+{
+    uno::Reference< accessibility::XAccessibleContext > xContext =
+        xAccessible->getAccessibleContext();
+
+    if( xContext.is() )
+        attachRecursive(xAccessible, xContext);
+}
+
+/*****************************************************************************/
+
+void DocumentFocusListener::attachRecursive(
+    const uno::Reference< accessibility::XAccessible >& xAccessible, 
+    const uno::Reference< accessibility::XAccessibleContext >& xContext 
+)  throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+{
+    uno::Reference< accessibility::XAccessibleStateSet > xStateSet =
+        xContext->getAccessibleStateSet();
+
+    if( xStateSet.is() )
+        attachRecursive(xAccessible, xContext, xStateSet);
+}
+
+/*****************************************************************************/
+
+void DocumentFocusListener::attachRecursive(
+    const uno::Reference< accessibility::XAccessible >& xAccessible, 
+    const uno::Reference< accessibility::XAccessibleContext >& xContext,
+    const uno::Reference< accessibility::XAccessibleStateSet >& xStateSet 
+) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+{
+    if( xStateSet->contains(accessibility::AccessibleStateType::FOCUSED ) )
+        atk_wrapper_focus_tracker_notify_when_idle( xAccessible );       
+
+    uno::Reference< accessibility::XAccessibleEventBroadcaster > xBroadcaster =
+        uno::Reference< accessibility::XAccessibleEventBroadcaster >(xContext, uno::UNO_QUERY);
+
+    // If not already done, add the broadcaster to the list and attach as listener.
+    if( xBroadcaster.is() && m_aRefList.insert(xBroadcaster).second )
+        xBroadcaster->addEventListener(static_cast< accessibility::XAccessibleEventListener *>(this));
+
+    if( ! xStateSet->contains(accessibility::AccessibleStateType::MANAGES_DESCENDANTS ) )
+    {
+        sal_Int32 n, nmax = xContext->getAccessibleChildCount();
+        for( n = 0; n < nmax; n++ )
+        {
+            uno::Reference< accessibility::XAccessible > xChild( xContext->getAccessibleChild( n ) );
+            
+            if( xChild.is() )
+                attachRecursive(xChild);
+        }
+    }
+}
+
+/*****************************************************************************/
+
+void DocumentFocusListener::detachRecursive(
+    const uno::Reference< accessibility::XAccessible >& xAccessible 
+) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+{
+    uno::Reference< accessibility::XAccessibleContext > xContext =
+        xAccessible->getAccessibleContext();
+
+    if( xContext.is() )
+        detachRecursive(xAccessible, xContext);
+}
+
+/*****************************************************************************/
+
+void DocumentFocusListener::detachRecursive(
+    const uno::Reference< accessibility::XAccessible >& xAccessible, 
+    const uno::Reference< accessibility::XAccessibleContext >& xContext 
+)  throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+{
+    uno::Reference< accessibility::XAccessibleStateSet > xStateSet =
+        xContext->getAccessibleStateSet();
+
+    if( xStateSet.is() )
+        detachRecursive(xAccessible, xContext, xStateSet);
+}
+
+/*****************************************************************************/
+
+void DocumentFocusListener::detachRecursive(
+    const uno::Reference< accessibility::XAccessible >& xAccessible, 
+    const uno::Reference< accessibility::XAccessibleContext >& xContext,
+    const uno::Reference< accessibility::XAccessibleStateSet >& xStateSet 
+) throw (lang::IndexOutOfBoundsException, uno::RuntimeException)
+{
+    if( ! xStateSet->contains(accessibility::AccessibleStateType::MANAGES_DESCENDANTS ) )
+    {
+        sal_Int32 n, nmax = xContext->getAccessibleChildCount();
+        for( n = 0; n < nmax; n++ )
+        {
+            uno::Reference< accessibility::XAccessible > xChild( xContext->getAccessibleChild( n ) );
+            
+            if( xChild.is() )
+                detachRecursive(xChild);
+        }
+    }
+
+    uno::Reference< accessibility::XAccessibleEventBroadcaster > xBroadcaster =
+        uno::Reference< accessibility::XAccessibleEventBroadcaster >(xContext, uno::UNO_QUERY);
+
+    if( xBroadcaster.is() && 0 < m_aRefList.erase(xBroadcaster) )
+        xBroadcaster->removeEventListener(static_cast< accessibility::XAccessibleEventListener *>(this));
+}
+
+/*****************************************************************************/
+
+/*
+ * page tabs in gtk are widgets, so we need to simulate focus events for those
+ */
+
+static void handle_tabpage_activated(Window *pWindow)
+{
+    uno::Reference< accessibility::XAccessible > xAccessible = 
+        pWindow->GetAccessible();
+    
+    if( ! xAccessible.is() )
+        return;
+    
+    uno::Reference< accessibility::XAccessibleSelection > xSelection(
+        xAccessible->getAccessibleContext(), uno::UNO_QUERY);
+        
+    if( xSelection.is() )
+        atk_wrapper_focus_tracker_notify_when_idle( xSelection->getSelectedAccessibleChild(0) );
+}
+
+/*****************************************************************************/
+
+static std::set< Window * > g_aWindowList;
+
+static void handle_get_focus(::VclWindowEvent const * pEvent)
+{
+    static rtl::Reference< DocumentFocusListener > aDocumentFocusListener = 
+        new DocumentFocusListener();
+    
+    Window *pWindow = pEvent->GetWindow();
+    
+    // The menu bar is handled through VCLEVENT_MENU_HIGHLIGHTED
+    if( ! pWindow || !pWindow->IsVisible() || pWindow->GetType() == WINDOW_MENUBARWINDOW )
+        return;
+    
+    if( pWindow->GetType() == WINDOW_TABCONTROL )
+    {
+        handle_tabpage_activated( pWindow );
+        return;
+    }
+    
+    uno::Reference< accessibility::XAccessible > xAccessible = 
+        pWindow->GetAccessible();
+    
+    if( ! xAccessible.is() )
+        return;
+    
+    uno::Reference< accessibility::XAccessibleContext > xContext = 
+        xAccessible->getAccessibleContext();
+        
+    if( ! xContext.is() )
+        return;
+    
+    uno::Reference< accessibility::XAccessibleStateSet > xStateSet = 
+        xContext->getAccessibleStateSet();
+        
+    if( ! xStateSet.is() )
+        return;
+    
+    if( xStateSet->contains(accessibility::AccessibleStateType::FOCUSED) &&
+        ( pWindow->GetType() != WINDOW_TREELISTBOX ) )
+    {
+        atk_wrapper_focus_tracker_notify_when_idle( xAccessible );
+    }
+    else
+    {
+        if( g_aWindowList.find(pWindow) == g_aWindowList.end() )
+        {
+            g_aWindowList.insert(pWindow);
+            aDocumentFocusListener->attachRecursive(xAccessible, xContext, xStateSet);
+        }
+    }
+}
+
+/*****************************************************************************/
+
+static void handle_menu_highlighted(::VclMenuEvent const * pEvent)
+{
+    try
+    {
+        Menu* pMenu = pEvent->GetMenu();
+        USHORT nPos = pEvent->GetItemPos();
+
+        if( pMenu &&  nPos != 0xFFFF)
+        {
+            uno::Reference< accessibility::XAccessible > xAccessible ( pMenu->GetAccessible() );
+
+            if( xAccessible.is() )
+            {
+                uno::Reference< accessibility::XAccessibleContext > xContext ( xAccessible->getAccessibleContext() );
+
+                if( xContext.is() )
+                    atk_wrapper_focus_tracker_notify_when_idle( xContext->getAccessibleChild( nPos ) );
+            }
+        }
+    } 
+    catch( uno::Exception e )
+    {
+        g_warning( "Exception caught processing menu highlight events" );
+    }
+}
+
+/*****************************************************************************/
+
+long WindowEventHandler(void * not_used, ::VclSimpleEvent const * pEvent)
+{
+    switch (pEvent->GetId())
+    {
+    case VCLEVENT_OBJECT_DYING:
+//        fprintf(stderr, "got VCLEVENT_OBJECT_DYING for %p\n", 
+//            static_cast< ::VclWindowEvent const * >(pEvent)->GetWindow());
+        break;
+    case VCLEVENT_WINDOW_SHOW:
+//        fprintf(stderr, "got VCLEVENT_WINDOW_SHOW for %p\n", 
+//            static_cast< ::VclWindowEvent const * >(pEvent)->GetWindow());
+        break;
+    case VCLEVENT_WINDOW_HIDE:
+//        fprintf(stderr, "got VCLEVENT_WINDOW_HIDE for %p\n", 
+//            static_cast< ::VclWindowEvent const * >(pEvent)->GetWindow());
+        break;
+    case VCLEVENT_WINDOW_CLOSE:
+//        fprintf(stderr, "got VCLEVENT_WINDOW_CLOSE for %p\n", 
+//            static_cast< ::VclWindowEvent const * >(pEvent)->GetWindow());
+        break;
+    case VCLEVENT_WINDOW_GETFOCUS:
+        handle_get_focus(static_cast< ::VclWindowEvent const * >(pEvent));
+        break;
+    case VCLEVENT_WINDOW_DEACTIVATE:
+        atk_wrapper_focus_tracker_notify_when_idle(NULL);
+        break;
+    case VCLEVENT_WINDOW_LOSEFOCUS:
+//        fprintf(stderr, "got VCLEVENT_WINDOW_LOSEFOCUS for %p\n", 
+//            static_cast< ::VclWindowEvent const * >(pEvent)->GetWindow());
+        break;
+    case VCLEVENT_WINDOW_MINIMIZE:
+//        fprintf(stderr, "got VCLEVENT_WINDOW_MINIMIZE for %p\n", 
+//            static_cast< ::VclWindowEvent const * >(pEvent)->GetWindow());
+        break;
+    case VCLEVENT_WINDOW_NORMALIZE:
+//        fprintf(stderr, "got VCLEVENT_WINDOW_NORMALIZE for %p\n", 
+//            static_cast< ::VclWindowEvent const * >(pEvent)->GetWindow());
+        break;
+    case VCLEVENT_WINDOW_KEYINPUT:
+    case VCLEVENT_WINDOW_KEYUP:
+    case VCLEVENT_WINDOW_COMMAND:
+        break;
+ /*
+        fprintf(stderr, "got VCLEVENT_WINDOW_COMMAND (%d) for %p\n", 
+            static_cast< ::CommandEvent const * > ( 
+                static_cast< ::VclWindowEvent const * >(pEvent)->GetData())->GetCommand(),
+            static_cast< ::VclWindowEvent const * >(pEvent)->GetWindow());
+ */
+    case VCLEVENT_MENU_HIGHLIGHT:
+        handle_menu_highlighted(static_cast< ::VclMenuEvent const * >(pEvent));
+        break;
+        
+    case VCLEVENT_TABPAGE_ACTIVATE:
+        handle_tabpage_activated(static_cast< ::VclWindowEvent const * >(pEvent)->GetWindow());
+        break;
+    default:
+        //fprintf(stderr, "got event %d \n", pEvent->GetId());
+        break;
+    }
+    return 0;
+}
+
+static Link g_aEventListenerLink( NULL, (PSTUB) WindowEventHandler );
+
+/*****************************************************************************/
+
+extern "C" {
+
+static G_CONST_RETURN gchar *
+ooo_atk_util_get_toolkit_name (void)
+{
+    return "VCL";
+}
+
+/*****************************************************************************/
+
+static G_CONST_RETURN gchar *
+ooo_atk_util_get_toolkit_version (void)
+{
+    /*
+     * Version is passed in as a -D flag when this file is
+     * compiled.
+     */
+     
+    return VERSION;
+}
+
+/*****************************************************************************/
+
+/*
+ * GObject inheritance 
+ */
+
+static void
+ooo_atk_util_class_init (AtkUtilClass *klass)
+{
+    AtkUtilClass *atk_class;
+    gpointer data;
+
+    data = g_type_class_peek (ATK_TYPE_UTIL);
+    atk_class = ATK_UTIL_CLASS (data);
+
+    atk_class->get_toolkit_name = ooo_atk_util_get_toolkit_name;
+    atk_class->get_toolkit_version = ooo_atk_util_get_toolkit_version;
+    
+    Application::AddEventListener( g_aEventListenerLink );
+}
+
+} // extern "C"
+
+/*****************************************************************************/
+
+GType
+ooo_atk_util_get_type (void)
+{
+    static GType type = 0;
+
+    if (!type)
+    {
+        GType parent_type = g_type_from_name( "GailUtil" );
+        
+        if( ! parent_type )
+        {
+            g_warning( "Unknown type: GailUtil" );
+            parent_type = ATK_TYPE_UTIL;
+        }
+        
+        GTypeQuery type_query;
+        g_type_query( parent_type, &type_query );
+        
+        static const GTypeInfo typeInfo =
+        {
+            type_query.class_size,
+            (GBaseInitFunc) NULL,
+            (GBaseFinalizeFunc) NULL,
+            (GClassInitFunc) ooo_atk_util_class_init,
+            (GClassFinalizeFunc) NULL,
+            NULL,
+            type_query.instance_size,
+            0,
+            (GInstanceInitFunc) NULL,
+        } ;
+        
+        type = g_type_register_static (parent_type, "OOoUtil", &typeInfo, (GTypeFlags)0) ;
+  }
+  
+  return type;
+}
+
Index: vcl/unx/gtk/a11y/atkutil.hxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkutil.hxx
diff -N vcl/unx/gtk/a11y/atkutil.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkutil.hxx	5 Jan 2006 14:06:32 -0000	1.1.2.4
@@ -0,0 +1,45 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __ATK_UTIL_HXX__
+#define __ATK_UTIL_HXX__ 
+
+#include <atk/atk.h>
+
+#define OOO_TYPE_ATK_UTIL ooo_atk_util_get_type()
+
+GType ooo_atk_util_get_type (void);
+
+#endif
Index: vcl/unx/gtk/a11y/atkvalue.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkvalue.cxx
diff -N vcl/unx/gtk/a11y/atkvalue.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkvalue.cxx	15 Feb 2006 10:59:25 -0000	1.1.2.4
@@ -0,0 +1,152 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "atkwrapper.hxx"
+
+#include <com/sun/star/accessibility/XAccessibleValue.hpp>
+
+#include <stdio.h>
+#include <string.h>
+
+using namespace ::com::sun::star;
+
+static accessibility::XAccessibleValue*
+    getValue( AtkValue *pValue ) throw (uno::RuntimeException)
+{
+    AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( pValue );
+    if( pWrap )
+    {
+        if( !pWrap->mpValue && pWrap->mpContext )
+        {
+            uno::Any any = pWrap->mpContext->queryInterface( accessibility::XAccessibleValue::static_type(NULL) );
+            pWrap->mpValue = reinterpret_cast< accessibility::XAccessibleValue * > (any.pReserved);
+            pWrap->mpValue->acquire();
+        }
+        
+        return pWrap->mpValue;
+    }
+    
+    return NULL;
+}
+
+static void anyToGValue( uno::Any aAny, GValue *pValue )
+{
+    // FIXME: expand to lots of types etc.
+    double aDouble;
+    aAny >>= aDouble;
+
+    memset( pValue,  0, sizeof( GValue ) );
+    g_value_init( pValue, G_TYPE_DOUBLE );
+    g_value_set_double( pValue, aDouble );
+}
+
+extern "C" {
+
+static void
+value_wrapper_get_current_value( AtkValue *value,
+                                 GValue   *gval )
+{
+    try {
+        accessibility::XAccessibleValue* pValue = getValue( value );
+        if( pValue )
+            anyToGValue( pValue->getCurrentValue(), gval );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getCurrentValue()" );
+    }
+}
+
+static void
+value_wrapper_get_maximum_value( AtkValue *value,
+                                 GValue   *gval )
+{
+    try {
+        accessibility::XAccessibleValue* pValue = getValue( value );
+        if( pValue )
+            anyToGValue( pValue->getMaximumValue(), gval );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getCurrentValue()" );
+    }
+}
+
+static void
+value_wrapper_get_minimum_value( AtkValue *value,
+                                 GValue   *gval )
+{
+    try {
+        accessibility::XAccessibleValue* pValue = getValue( value );
+        if( pValue )
+            anyToGValue( pValue->getMinimumValue(), gval );
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getCurrentValue()" );
+    }
+}
+
+static gboolean
+value_wrapper_set_current_value( AtkValue     *value,
+                                 const GValue *gval )
+{
+    try {
+        accessibility::XAccessibleValue* pValue = getValue( value );
+        if( pValue )
+        {
+            // FIXME - this needs expanding
+            double aDouble = g_value_get_double( gval );
+            uno::Any aAny;
+            aAny <<= aDouble;
+            return pValue->setCurrentValue( aAny );
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getCurrentValue()" );
+    }
+
+    return FALSE;
+}
+
+} // extern "C"
+
+void
+valueIfaceInit (AtkValueIface *iface)
+{
+  g_return_if_fail (iface != NULL);
+
+  iface->get_current_value = value_wrapper_get_current_value;
+  iface->get_maximum_value = value_wrapper_get_maximum_value;
+  iface->get_minimum_value = value_wrapper_get_minimum_value;
+  iface->set_current_value = value_wrapper_set_current_value;
+}
Index: vcl/unx/gtk/a11y/atkwindow.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkwindow.cxx
diff -N vcl/unx/gtk/a11y/atkwindow.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkwindow.cxx	17 Feb 2006 11:10:56 -0000	1.1.2.3
@@ -0,0 +1,138 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+ 
+#include "atkwindow.hxx"
+
+#include <plugins/gtk/gtkframe.hxx>
+
+extern "C" {
+
+static void (* window_real_initialize) (AtkObject *obj, gpointer data);
+static G_CONST_RETURN gchar* (* window_real_get_name) (AtkObject *accessible);
+
+/*****************************************************************************/
+
+static void
+ooo_window_wrapper_real_initialize(AtkObject *obj, gpointer data)
+{
+    window_real_initialize(obj, data);
+    obj->role = GtkSalFrame::GetAtkRole( GTK_WINDOW( data ) );
+}
+
+/*****************************************************************************/
+
+static G_CONST_RETURN gchar*
+ooo_window_wrapper_real_get_name(AtkObject *accessible)
+{
+    G_CONST_RETURN gchar* name = NULL;
+    
+    if( accessible->role == ATK_ROLE_TOOL_TIP )
+    {
+        AtkObject *child = atk_object_ref_accessible_child(accessible, 0);
+        if( child )
+        {
+            name = atk_object_get_name(child);
+            g_object_unref(child);
+        }
+
+        return name;
+    }
+    
+    return window_real_get_name(accessible);
+}
+
+/*****************************************************************************/
+
+static void
+ooo_window_wrapper_class_init (AtkObjectClass *klass)
+{
+    AtkObjectClass *atk_class;
+    gpointer data;
+    
+    /* 
+     * Patch the gobject vtable of GailWindow to refer to our instance of
+     * "initialize" and "get_name".
+     */
+    
+    data = g_type_class_peek_parent( klass );
+    atk_class = ATK_OBJECT_CLASS (data);
+    
+    window_real_initialize = atk_class->initialize;
+    atk_class->initialize = ooo_window_wrapper_real_initialize;
+    
+    window_real_get_name = atk_class->get_name;
+    atk_class->get_name = ooo_window_wrapper_real_get_name;
+}
+
+} // extern "C"
+
+/*****************************************************************************/
+
+GType 
+ooo_window_wrapper_get_type (void)
+{
+    static GType type = 0;
+
+    if (!type)
+    {
+        GType parent_type = g_type_from_name( "GailWindow" );
+        
+        if( ! parent_type )
+        {
+            g_warning( "Unknown type: GailWindow" );
+            parent_type = ATK_TYPE_OBJECT;
+        }
+        
+        GTypeQuery type_query;
+        g_type_query( parent_type, &type_query );
+        
+        static const GTypeInfo typeInfo =
+        {
+            type_query.class_size,
+            (GBaseInitFunc) NULL,
+            (GBaseFinalizeFunc) NULL,
+            (GClassInitFunc) ooo_window_wrapper_class_init,
+            (GClassFinalizeFunc) NULL,
+            NULL,
+            type_query.instance_size,
+            0,
+            (GInstanceInitFunc) NULL,
+        } ;
+        
+        type = g_type_register_static (parent_type, "OOoWindowAtkObject", &typeInfo, (GTypeFlags)0) ;
+    }
+    
+    return type;
+}
Index: vcl/unx/gtk/a11y/atkwindow.hxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkwindow.hxx
diff -N vcl/unx/gtk/a11y/atkwindow.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkwindow.hxx	5 Jan 2006 14:06:34 -0000	1.1.2.1
@@ -0,0 +1,45 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __ATK_WINDOW_HXX__
+#define __ATK_WINDOW_HXX__ 
+
+#include <atk/atk.h>
+
+#define OOO_TYPE_WINDOW_WRAPPER ooo_window_wrapper_get_type()
+
+GType ooo_window_wrapper_get_type (void);
+
+#endif
Index: vcl/unx/gtk/a11y/atkwrapper.cxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkwrapper.cxx
diff -N vcl/unx/gtk/a11y/atkwrapper.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkwrapper.cxx	15 Feb 2006 10:58:57 -0000	1.1.2.21
@@ -0,0 +1,819 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include <com/sun/star/uno/Any.hxx>
+#include <com/sun/star/uno/Type.hxx>
+#include <com/sun/star/uno/Sequence.hxx>
+#include <com/sun/star/accessibility/AccessibleRole.hpp>
+#include <com/sun/star/accessibility/AccessibleRelation.hpp>
+#include <com/sun/star/accessibility/AccessibleRelationType.hpp>
+#include <com/sun/star/accessibility/AccessibleStateType.hpp>
+#include <com/sun/star/accessibility/XAccessible.hpp>
+#include <com/sun/star/accessibility/XAccessibleText.hpp>
+#include <com/sun/star/accessibility/XAccessibleValue.hpp>
+#include <com/sun/star/accessibility/XAccessibleAction.hpp>
+#include <com/sun/star/accessibility/XAccessibleContext.hpp>
+#include <com/sun/star/accessibility/XAccessibleComponent.hpp>
+#include <com/sun/star/accessibility/XAccessibleEventBroadcaster.hpp>
+#include <com/sun/star/accessibility/XAccessibleStateSet.hpp>
+#include <com/sun/star/accessibility/XAccessibleRelationSet.hpp>
+#include <com/sun/star/accessibility/XAccessibleTable.hpp>
+#include <com/sun/star/accessibility/XAccessibleEditableText.hpp>
+#include <com/sun/star/accessibility/XAccessibleImage.hpp>
+#include <com/sun/star/accessibility/XAccessibleHyperlink.hpp>
+#include <com/sun/star/accessibility/XAccessibleHypertext.hpp>
+#include <com/sun/star/accessibility/XAccessibleSelection.hpp>
+#include <com/sun/star/awt/XExtendedToolkit.hpp>
+#include <com/sun/star/awt/XTopWindow.hpp>
+#include <com/sun/star/awt/XTopWindowListener.hpp>
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/lang/XComponent.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/lang/XSingleServiceFactory.hpp>
+#include <com/sun/star/beans/Property.hpp>
+
+#include <rtl/ref.hxx>
+#include <cppuhelper/factory.hxx>
+#include <cppuhelper/queryinterface.hxx>
+
+#include "atkwrapper.hxx"
+#include "atklistener.hxx"
+
+#ifdef ENABLE_TRACING
+#include <stdio.h>
+#endif
+
+#include <string.h>
+
+using namespace ::com::sun::star;
+
+static GObjectClass *parent_class = NULL;
+static GHashTable   *uno_to_gobject = NULL;
+
+static G_CONST_RETURN gchar *
+getAsConst( rtl::OUString rString )
+{
+    static const int nMax = 10;
+    static rtl::OString aUgly[nMax];
+    static int nIdx = 0;
+    nIdx = (nIdx + 1) % nMax;
+    aUgly[nIdx] = rtl::OUStringToOString( rString, RTL_TEXTENCODING_UTF8 );
+    return aUgly[ nIdx ];
+}
+
+static AtkRelationType mapRelationType( sal_Int16 nRelation )
+{
+    AtkRelationType type = ATK_RELATION_NULL;
+    
+    switch( nRelation )
+    {
+        case accessibility::AccessibleRelationType::CONTENT_FLOWS_FROM:
+            type = ATK_RELATION_FLOWS_FROM;
+            break;
+        
+        case accessibility::AccessibleRelationType::CONTENT_FLOWS_TO:
+            type = ATK_RELATION_FLOWS_TO;
+            break;
+
+        case accessibility::AccessibleRelationType::CONTROLLED_BY:
+            type = ATK_RELATION_CONTROLLED_BY;
+            break;
+
+        case accessibility::AccessibleRelationType::CONTROLLER_FOR:
+            type = ATK_RELATION_CONTROLLER_FOR;
+            break;
+
+        case accessibility::AccessibleRelationType::LABEL_FOR:
+            type = ATK_RELATION_LABEL_FOR;
+            break;
+
+        case accessibility::AccessibleRelationType::LABELED_BY:
+            type = ATK_RELATION_LABELLED_BY;
+            break;
+
+        case accessibility::AccessibleRelationType::MEMBER_OF:
+            type = ATK_RELATION_MEMBER_OF;
+            break;
+
+        case accessibility::AccessibleRelationType::SUB_WINDOW_OF:
+            type = ATK_RELATION_SUBWINDOW_OF;
+            break;
+
+        default:
+            break;
+    }
+#if 0
+  ATK_RELATION_NODE_CHILD_OF,
+  ATK_RELATION_EMBEDS, 
+  ATK_RELATION_EMBEDDED_BY, 
+  ATK_RELATION_POPUP_FOR, 
+#endif
+    return type;
+}
+
+AtkStateType mapAtkState( sal_Int16 nState )
+{
+    // A perfect / complete mapping ...
+    switch( nState )
+    {
+#define MAP_DIRECT( a ) \
+    case accessibility::AccessibleStateType::a: \
+        return ATK_STATE_##a; break
+
+        MAP_DIRECT( INVALID );
+        MAP_DIRECT( ACTIVE );
+        MAP_DIRECT( ARMED );
+        MAP_DIRECT( BUSY );
+        MAP_DIRECT( CHECKED );
+        MAP_DIRECT( EDITABLE );
+        MAP_DIRECT( ENABLED );
+        MAP_DIRECT( EXPANDABLE );
+        MAP_DIRECT( EXPANDED );
+        MAP_DIRECT( FOCUSABLE );
+        MAP_DIRECT( FOCUSED );
+        MAP_DIRECT( HORIZONTAL );
+        MAP_DIRECT( ICONIFIED );
+        MAP_DIRECT( INDETERMINATE );
+        MAP_DIRECT( MANAGES_DESCENDANTS );
+        MAP_DIRECT( MODAL );
+        MAP_DIRECT( MULTI_LINE );
+        MAP_DIRECT( OPAQUE );
+        MAP_DIRECT( PRESSED );
+        MAP_DIRECT( RESIZABLE );
+        MAP_DIRECT( SELECTABLE );
+        MAP_DIRECT( SELECTED );
+        MAP_DIRECT( SENSITIVE );
+        MAP_DIRECT( SHOWING );
+        MAP_DIRECT( SINGLE_LINE );
+        MAP_DIRECT( STALE );
+        MAP_DIRECT( TRANSIENT );
+        MAP_DIRECT( VERTICAL );
+        MAP_DIRECT( VISIBLE );
+        // a spelling error ...
+        case accessibility::AccessibleStateType::DEFUNC:
+            return ATK_STATE_DEFUNCT; break;
+        case accessibility::AccessibleStateType::MULTI_SELECTABLE:
+            return ATK_STATE_MULTISELECTABLE; break;
+    default:
+        return ATK_STATE_INVALID;
+        break;
+    }
+}
+
+static AtkRole mapToAtkRole( sal_Int16 nRole )
+{
+    switch( nRole )
+    {
+#define MAP(a,b) \
+        case a: return b; break
+            
+        MAP( ::accessibility::AccessibleRole::UNKNOWN, ATK_ROLE_UNKNOWN );
+        MAP( ::accessibility::AccessibleRole::ALERT, ATK_ROLE_ALERT );
+        MAP( ::accessibility::AccessibleRole::COLUMN_HEADER, ATK_ROLE_COLUMN_HEADER );
+        MAP( ::accessibility::AccessibleRole::CANVAS, ATK_ROLE_CANVAS );
+        MAP( ::accessibility::AccessibleRole::CHECK_BOX, ATK_ROLE_CHECK_BOX );
+        MAP( ::accessibility::AccessibleRole::CHECK_MENU_ITEM, ATK_ROLE_CHECK_MENU_ITEM );
+        MAP( ::accessibility::AccessibleRole::COLOR_CHOOSER, ATK_ROLE_COLOR_CHOOSER );
+        MAP( ::accessibility::AccessibleRole::COMBO_BOX, ATK_ROLE_COMBO_BOX );
+        MAP( ::accessibility::AccessibleRole::DATE_EDITOR, ATK_ROLE_DATE_EDITOR );
+        MAP( ::accessibility::AccessibleRole::DESKTOP_ICON, ATK_ROLE_DESKTOP_ICON );
+        MAP( ::accessibility::AccessibleRole::DESKTOP_PANE, ATK_ROLE_DESKTOP_FRAME ); // ? pane
+        MAP( ::accessibility::AccessibleRole::DIRECTORY_PANE, ATK_ROLE_DIRECTORY_PANE );
+        MAP( ::accessibility::AccessibleRole::DIALOG, ATK_ROLE_DIALOG );
+        MAP( ::accessibility::AccessibleRole::DOCUMENT, ATK_ROLE_UNKNOWN ); // - FIXME -
+        MAP( ::accessibility::AccessibleRole::EMBEDDED_OBJECT, ATK_ROLE_UNKNOWN ); // - FIXME -
+        MAP( ::accessibility::AccessibleRole::END_NOTE, ATK_ROLE_UNKNOWN ); // - FIXME -
+        MAP( ::accessibility::AccessibleRole::FILE_CHOOSER, ATK_ROLE_FILE_CHOOSER );
+        MAP( ::accessibility::AccessibleRole::FILLER, ATK_ROLE_FILLER );
+        MAP( ::accessibility::AccessibleRole::FONT_CHOOSER, ATK_ROLE_FONT_CHOOSER );
+        MAP( ::accessibility::AccessibleRole::FOOTER, ATK_ROLE_FOOTER );
+        MAP( ::accessibility::AccessibleRole::FOOTNOTE, ATK_ROLE_TEXT ); // - FIXME -
+        MAP( ::accessibility::AccessibleRole::FRAME, ATK_ROLE_FRAME );
+        MAP( ::accessibility::AccessibleRole::GLASS_PANE, ATK_ROLE_GLASS_PANE );
+        MAP( ::accessibility::AccessibleRole::GRAPHIC, ATK_ROLE_UNKNOWN ); // - FIXME -
+        MAP( ::accessibility::AccessibleRole::GROUP_BOX, ATK_ROLE_UNKNOWN ); // - FIXME -
+        MAP( ::accessibility::AccessibleRole::HEADER, ATK_ROLE_HEADER );
+        MAP( ::accessibility::AccessibleRole::HEADING, ATK_ROLE_HEADER ); // - FIXME -
+        MAP( ::accessibility::AccessibleRole::HYPER_LINK, ATK_ROLE_TEXT ); // - FIXME -
+        MAP( ::accessibility::AccessibleRole::ICON, ATK_ROLE_ICON );
+        MAP( ::accessibility::AccessibleRole::INTERNAL_FRAME, ATK_ROLE_INTERNAL_FRAME );
+        MAP( ::accessibility::AccessibleRole::LABEL, ATK_ROLE_LABEL );
+        MAP( ::accessibility::AccessibleRole::LAYERED_PANE, ATK_ROLE_LAYERED_PANE );
+        MAP( ::accessibility::AccessibleRole::LIST, ATK_ROLE_LIST );
+        MAP( ::accessibility::AccessibleRole::LIST_ITEM, ATK_ROLE_LIST_ITEM );
+        MAP( ::accessibility::AccessibleRole::MENU, ATK_ROLE_MENU );
+        MAP( ::accessibility::AccessibleRole::MENU_BAR, ATK_ROLE_MENU_BAR );
+        MAP( ::accessibility::AccessibleRole::MENU_ITEM, ATK_ROLE_MENU_ITEM );
+        MAP( ::accessibility::AccessibleRole::OPTION_PANE, ATK_ROLE_OPTION_PANE );
+        MAP( ::accessibility::AccessibleRole::PAGE_TAB, ATK_ROLE_PAGE_TAB );
+        MAP( ::accessibility::AccessibleRole::PAGE_TAB_LIST, ATK_ROLE_PAGE_TAB_LIST );
+        MAP( ::accessibility::AccessibleRole::PANEL, ATK_ROLE_PANEL );
+        MAP( ::accessibility::AccessibleRole::PARAGRAPH, ATK_ROLE_PARAGRAPH );
+        MAP( ::accessibility::AccessibleRole::PASSWORD_TEXT, ATK_ROLE_PASSWORD_TEXT );
+        MAP( ::accessibility::AccessibleRole::POPUP_MENU, ATK_ROLE_POPUP_MENU );
+        MAP( ::accessibility::AccessibleRole::PUSH_BUTTON, ATK_ROLE_PUSH_BUTTON );
+        MAP( ::accessibility::AccessibleRole::PROGRESS_BAR, ATK_ROLE_PROGRESS_BAR );
+        MAP( ::accessibility::AccessibleRole::RADIO_BUTTON, ATK_ROLE_RADIO_BUTTON );
+        MAP( ::accessibility::AccessibleRole::RADIO_MENU_ITEM, ATK_ROLE_RADIO_MENU_ITEM );
+        MAP( ::accessibility::AccessibleRole::ROW_HEADER, ATK_ROLE_ROW_HEADER );
+        MAP( ::accessibility::AccessibleRole::ROOT_PANE, ATK_ROLE_ROOT_PANE );
+        MAP( ::accessibility::AccessibleRole::SCROLL_BAR, ATK_ROLE_SCROLL_BAR );
+        MAP( ::accessibility::AccessibleRole::SCROLL_PANE, ATK_ROLE_SCROLL_PANE );
+        MAP( ::accessibility::AccessibleRole::SHAPE, ATK_ROLE_UNKNOWN ); // - FIXME -
+        MAP( ::accessibility::AccessibleRole::SEPARATOR, ATK_ROLE_SEPARATOR );
+        MAP( ::accessibility::AccessibleRole::SLIDER, ATK_ROLE_SLIDER );
+        MAP( ::accessibility::AccessibleRole::SPIN_BOX, ATK_ROLE_SPIN_BUTTON ); // ?
+        MAP( ::accessibility::AccessibleRole::SPLIT_PANE, ATK_ROLE_SPLIT_PANE );
+        MAP( ::accessibility::AccessibleRole::STATUS_BAR, ATK_ROLE_STATUSBAR );
+        MAP( ::accessibility::AccessibleRole::TABLE, ATK_ROLE_TABLE );
+        MAP( ::accessibility::AccessibleRole::TABLE_CELL, ATK_ROLE_TABLE_CELL );
+        MAP( ::accessibility::AccessibleRole::TEXT, ATK_ROLE_TEXT );
+        MAP( ::accessibility::AccessibleRole::TEXT_FRAME, ATK_ROLE_UNKNOWN ); // - FIXME -
+        MAP( ::accessibility::AccessibleRole::TOGGLE_BUTTON, ATK_ROLE_TOGGLE_BUTTON );
+        MAP( ::accessibility::AccessibleRole::TOOL_BAR, ATK_ROLE_TOOL_BAR );
+        MAP( ::accessibility::AccessibleRole::TOOL_TIP, ATK_ROLE_TOOL_TIP );
+        MAP( ::accessibility::AccessibleRole::TREE, ATK_ROLE_TREE );
+        MAP( ::accessibility::AccessibleRole::VIEW_PORT, ATK_ROLE_VIEWPORT );
+        MAP( ::accessibility::AccessibleRole::WINDOW, ATK_ROLE_WINDOW );
+#undef MAP
+    }
+/* Roles unimplemented by OO.o / a11y:
+  ATK_ROLE_INVALID,      ATK_ROLE_ACCEL_LABEL,    ATK_ROLE_ANIMATION,
+  ATK_ROLE_ARROW,        ATK_ROLE_CALENDAR,       ATK_ROLE_DIAL,
+  ATK_ROLE_DRAWING_AREA, ATK_ROLE_HTML_CONTAINER, ATK_ROLE_IMAGE,
+  ATK_ROLE_TABLE_COLUMN_HEADER, ATK_ROLE_TABLE_ROW_HEADER, ATK_ROLE_TEAR_OFF_MENU_ITEM,
+  ATK_ROLE_TERMINAL,            ATK_ROLE_TREE_TABLE,       ATK_ROLE_RULER,
+  ATK_ROLE_APPLICATION,         ATK_ROLE_AUTOCOMPLETE,     ATK_ROLE_EDITBAR */
+
+    return ATK_ROLE_UNKNOWN;
+}
+
+static gchar *
+mapToGChar( rtl::OUString aString )
+{
+    rtl::OString aUtf8 = rtl::OUStringToOString( aString, RTL_TEXTENCODING_UTF8 );
+    return g_strdup( aUtf8 );
+}
+
+static accessibility::XAccessibleContext*
+        getContext( AtkObject* obj ) throw (uno::RuntimeException)
+{
+    AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( obj );
+    
+    if( pWrap )
+    {
+        if( !pWrap->mpContext && pWrap->mpContext )
+        {
+            uno::Any any = pWrap->mpContext->queryInterface( accessibility::XAccessibleContext::static_type(NULL) );
+            pWrap->mpContext = reinterpret_cast< accessibility::XAccessibleContext * > (any.pReserved);
+            pWrap->mpContext->acquire();
+        }
+
+        return pWrap->mpContext;
+    }
+
+    return NULL;
+}
+
+/*****************************************************************************/
+
+extern "C" {
+
+/*****************************************************************************/
+
+static G_CONST_RETURN gchar*
+wrapper_get_name( AtkObject *pObject )
+{
+    G_CONST_RETURN gchar* name;
+
+    name = ATK_OBJECT_CLASS (parent_class)->get_name( pObject );
+    if (name == NULL)
+    {
+        try {
+            accessibility::XAccessibleContext* pContext = getContext( pObject );
+            if( pContext )
+                name = getAsConst( pContext->getAccessibleName() );
+        }
+        catch(const uno::Exception& e) {
+            g_warning( "Exception in getAccessibleName()" );
+        }
+    }
+    
+    return name;
+}
+
+/*****************************************************************************/
+
+static G_CONST_RETURN gchar*
+wrapper_get_description( AtkObject *pObject )
+{
+    G_CONST_RETURN gchar* desc;
+
+    desc = ATK_OBJECT_CLASS (parent_class)->get_description( pObject );
+    if (desc == NULL)
+    {
+        try {
+            accessibility::XAccessibleContext* pContext = getContext( pObject );
+            if( pContext )
+                desc = getAsConst( pContext->getAccessibleDescription() );
+        }
+        catch(const uno::Exception& e) {
+            g_warning( "Exception in getAccessibleDescription()" );
+        }
+    }
+    
+    return desc;
+}
+
+/*****************************************************************************/
+
+static gint
+wrapper_get_n_children( AtkObject *pObject )
+{
+    try {
+        accessibility::XAccessibleContext* pContext = getContext( pObject );
+        if( pContext )
+            return pContext->getAccessibleChildCount();
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleChildCount()" );
+    }
+    
+    return 0;
+}
+
+/*****************************************************************************/
+
+static AtkObject *
+wrapper_ref_child( AtkObject *pObject,
+                   gint       i )
+{
+    try {
+        accessibility::XAccessibleContext* pContext = getContext( pObject );
+        if( pContext )
+        {
+//    fprintf(stderr, "wrapper_ref_child %d of (%d)\n", i,
+//        getContext( pObject )->getAccessibleChildCount());
+            if( i >= 0 && i <  getContext( pObject )->getAccessibleChildCount())
+            {
+                uno::Reference< accessibility::XAccessible > xAccessible = 
+                    pContext->getAccessibleChild( i );
+        
+                AtkObject* child = atk_object_wrapper_ref( xAccessible );
+                return child;
+            }
+        }
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleChildCount()" );
+    }
+        
+    return NULL;
+}
+
+static gint
+wrapper_get_index_in_parent( AtkObject *pObject )
+{
+    try {
+        accessibility::XAccessibleContext* pContext = getContext( pObject );
+        
+#ifdef ENABLE_TRACING
+        if( pContext )
+            fprintf(stderr, "%p->getAccessibleIndexInParent() returned: %u\n",
+                ATK_OBJECT_WRAPPER( pObject )->mpAccessible,
+                pContext->getAccessibleIndexInParent());
+#endif
+        if( pContext )
+            return pContext->getAccessibleIndexInParent();
+    }
+    catch(const uno::Exception& e) {
+        g_warning( "Exception in getAccessibleIndexInParent()" );
+    }
+    return -1;
+}
+
+static AtkRelationSet *
+wrapper_ref_relation_set( AtkObject *pObject )
+{
+    AtkRelationSet *pSet = atk_relation_set_new();
+    try {
+        accessibility::XAccessibleContext* pContext = getContext( pObject );
+        if( pContext )
+        {
+            uno::Reference< accessibility::XAccessibleRelationSet > xRelationSet;
+
+            xRelationSet = pContext->getAccessibleRelationSet();
+
+            sal_Int32 nRelations = xRelationSet.is() ? xRelationSet->getRelationCount() : 0;
+            for( sal_Int32 n = 0; n < nRelations; n++ )
+            {
+                accessibility::AccessibleRelation aRelation = xRelationSet->getRelation( n );
+                sal_uInt32 nTargetCount = aRelation.TargetSet.getLength();
+                AtkObject **pTargets = (AtkObject **) alloca( nTargetCount * sizeof(AtkObject *) );
+            
+                for( sal_uInt32 n = 0; n < nTargetCount; n++ )
+                {
+                    uno::Reference< accessibility::XAccessible > xAccessible(
+                            aRelation.TargetSet[n], uno::UNO_QUERY );
+                    pTargets[n] = atk_object_wrapper_ref( xAccessible );
+                }
+        
+                AtkRelation *pRel = atk_relation_new
+                    ( pTargets, nTargetCount,
+                          mapRelationType( aRelation.RelationType ) );
+                atk_relation_set_add( pSet, pRel );
+                g_object_unref( G_OBJECT( pRel ) );
+            }
+        }
+    }
+    catch(const uno::Exception &e)
+    {
+        g_object_unref( G_OBJECT( pSet ) );
+        pSet = NULL;
+    }
+
+    return pSet;
+}
+
+static AtkStateSet *
+wrapper_ref_state_set( AtkObject *pObject )
+{
+    AtkStateSet *pSet = atk_state_set_new();
+    try {
+        accessibility::XAccessibleContext* pContext = getContext( pObject );
+        if( pContext )
+        {
+            uno::Reference< accessibility::XAccessibleStateSet > xStateSet = 
+                pContext->getAccessibleStateSet();
+
+            uno::Sequence< sal_Int16 > aStates;
+            
+            if( xStateSet.is() )
+            {
+                uno::Sequence< sal_Int16 > aStates = xStateSet->getStates();
+            
+                for( sal_uInt32 n = 0; n < aStates.getLength(); n++ )
+                    atk_state_set_add_state( pSet, mapAtkState( aStates[n] ) );
+
+                // We need to emulate FOCUS state for menus, menu-items etc.
+                if( pObject == atk_get_focus_object() )
+                    atk_state_set_add_state( pSet, ATK_STATE_FOCUSED );
+/* FIXME - should we do this ?
+                else
+                    atk_state_set_remove_state( pSet, ATK_STATE_FOCUSED );
+*/
+            }
+        }
+    }
+    
+    catch(const uno::Exception &e)
+    {
+        g_warning( "Exception in wrapper_ref_state_set" );
+        
+        g_object_unref( G_OBJECT( pSet ) );
+        pSet = NULL;
+    }
+
+    return pSet;
+}
+
+static void
+atk_object_wrapper_finalize (GObject *obj)
+{
+    AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER (obj);
+
+    if( pWrap->mpAccessible )
+    {
+        g_hash_table_remove( uno_to_gobject, pWrap->mpAccessible );
+        pWrap->mpAccessible->release();
+        pWrap->mpAccessible = NULL;
+    }
+    
+    atk_object_wrapper_dispose( pWrap );
+    
+    parent_class->finalize( obj );
+}
+
+static void
+atk_object_wrapper_class_init (AtkObjectWrapperClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS( klass );
+  AtkObjectClass *atk_class = ATK_OBJECT_CLASS( klass );
+
+  parent_class = (GObjectClass *) g_type_class_peek_parent (klass);
+
+  // GObject methods
+  gobject_class->finalize = atk_object_wrapper_finalize;
+
+  // AtkObject methods
+  atk_class->get_name = wrapper_get_name;
+  atk_class->get_description = wrapper_get_description;
+  atk_class->get_n_children = wrapper_get_n_children;
+  atk_class->ref_child = wrapper_ref_child;
+  atk_class->get_index_in_parent = wrapper_get_index_in_parent;
+  atk_class->ref_relation_set = wrapper_ref_relation_set;
+  atk_class->ref_state_set = wrapper_ref_state_set;
+}
+
+static void
+atk_object_wrapper_init (AtkObjectWrapper      *wrapper,
+                         AtkObjectWrapperClass *klass)
+{
+   wrapper->mpAction = NULL;
+   wrapper->mpComponent = NULL;
+   wrapper->mpEditableText = NULL;
+   wrapper->mpHypertext = NULL;
+   wrapper->mpImage = NULL;
+   wrapper->mpSelection = NULL;
+   wrapper->mpTable = NULL;
+   wrapper->mpText = NULL;
+   wrapper->mpValue = NULL;    
+}
+
+} // extern "C"
+
+GType
+atk_object_wrapper_get_type (void)
+{
+  static GType type = 0;
+
+  if (!type)
+    {
+      static const GTypeInfo typeInfo =
+      {
+        sizeof (AtkObjectWrapperClass),
+        (GBaseInitFunc) NULL,
+        (GBaseFinalizeFunc) NULL,
+        (GClassInitFunc) atk_object_wrapper_class_init,
+        (GClassFinalizeFunc) NULL,
+        NULL,
+        sizeof (AtkObjectWrapper),
+        0,
+        (GInstanceInitFunc) atk_object_wrapper_init,
+      } ;
+      type = g_type_register_static (ATK_TYPE_OBJECT,
+                                     "OOoAtkObj",
+                                     &typeInfo, (GTypeFlags)0) ;
+    }
+  return type;
+}
+
+static bool
+isOfType( uno::XInterface *pInterface, const uno::Type & rType )
+{
+    g_return_val_if_fail( pInterface != NULL, false );
+
+    bool bIs = false;
+    try {
+        uno::Any aRet = pInterface->queryInterface( rType );
+
+        bIs = ( ( typelib_TypeClass_INTERFACE == aRet.pType->eTypeClass ) &&
+                ( aRet.pReserved != NULL ) );
+    } catch( const uno::Exception &e) { }
+    
+    return bIs;
+}
+
+extern "C" {
+typedef  GType (* GetGIfaceType ) (void);
+} 
+const struct {
+        const char          *name;
+        GInterfaceInitFunc   aInit;
+        GetGIfaceType        aGetGIfaceType;
+        const uno::Type &  (*aGetUnoType) (void *);
+} aTypeTable[] = {
+// re-location heaven:
+    {
+        "Comp", (GInterfaceInitFunc) componentIfaceInit,
+        atk_component_get_type,
+        accessibility::XAccessibleComponent::static_type
+    },
+    {
+        "Act",  (GInterfaceInitFunc) actionIfaceInit,
+        atk_action_get_type,
+        accessibility::XAccessibleAction::static_type
+    },
+    {
+        "Txt",  (GInterfaceInitFunc) textIfaceInit,
+        atk_text_get_type,
+        accessibility::XAccessibleText::static_type
+    },
+    {
+        "Val",  (GInterfaceInitFunc) valueIfaceInit,
+        atk_value_get_type,
+        accessibility::XAccessibleValue::static_type
+    },
+    {
+        "Tab",  (GInterfaceInitFunc) tableIfaceInit,
+        atk_table_get_type,
+        accessibility::XAccessibleTable::static_type
+    },
+    {
+        "Edt",  (GInterfaceInitFunc) editableTextIfaceInit,
+        atk_editable_text_get_type,
+        accessibility::XAccessibleEditableText::static_type
+    },
+    {
+        "Img",  (GInterfaceInitFunc) imageIfaceInit,
+        atk_image_get_type,
+        accessibility::XAccessibleImage::static_type
+    },
+    {
+        "Hyp",  (GInterfaceInitFunc) hypertextIfaceInit,
+        atk_hypertext_get_type,
+        accessibility::XAccessibleHypertext::static_type
+    },
+    {
+        "Sel",  (GInterfaceInitFunc) selectionIfaceInit,
+        atk_selection_get_type,
+        accessibility::XAccessibleSelection::static_type
+    }
+    // AtkDocument is a nastily broken interface (so far)
+    //  we could impl. get_document_type perhaps though.
+};
+
+const int aTypeTableSize = G_N_ELEMENTS( aTypeTable );
+
+static GType
+ensureTypeFor( uno::XInterface *pAccessible )
+{
+    int i;
+    int bTypes[ aTypeTableSize ] = { 0, };
+    rtl::OString aTypeName( "OOoAtkObj" );
+
+    for( i = 0; i < aTypeTableSize; i++ )
+    {
+        if( isOfType( pAccessible, aTypeTable[i].aGetUnoType(0) ) )
+        {
+            aTypeName += aTypeTable[i].name;
+            bTypes[i] = TRUE;
+        }
+//      g_message( "Accessible %p has type '%s' (%d)",
+//                 pAccessible, aTypeTable[i].name, bTypes[i] );
+    }
+
+    GType nType = g_type_from_name( aTypeName );
+    if( nType == G_TYPE_INVALID )
+    {
+        GTypeInfo aTypeInfo = {
+            sizeof( AtkObjectWrapperClass ),
+            NULL, NULL, NULL, NULL, NULL,
+            sizeof( AtkObjectWrapper ),
+            0, NULL
+        } ;
+        nType = g_type_register_static( ATK_TYPE_OBJECT_WRAPPER,
+                                        aTypeName, &aTypeInfo, (GTypeFlags)0 ) ;
+
+        for( int i = 0; i < aTypeTableSize; i++ )
+            if( bTypes[i] )
+            {
+                GInterfaceInfo aIfaceInfo = { NULL, NULL, NULL };
+                aIfaceInfo.interface_init = aTypeTable[i].aInit;
+                g_type_add_interface_static (nType, aTypeTable[i].aGetGIfaceType(),
+                                             &aIfaceInfo);
+            }
+    }
+    return nType;
+}
+
+AtkObject *
+atk_object_wrapper_ref( const uno::Reference< accessibility::XAccessible > &rxAccessible, bool create )
+{
+    g_return_val_if_fail( rxAccessible.get() != NULL, NULL );
+
+    if( uno_to_gobject )
+    {
+        gpointer cached = 
+            g_hash_table_lookup(uno_to_gobject, (gpointer) rxAccessible.get());
+
+        if( cached )
+            return ATK_OBJECT( g_object_ref( cached ) );
+    }
+    
+    if( create )
+        return atk_object_wrapper_new( rxAccessible );
+    
+    return NULL;
+}
+
+
+AtkObject *            
+atk_object_wrapper_new( const ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible >& rxAccessible,
+                        AtkObject* parent )
+{
+    g_return_val_if_fail( rxAccessible.get() != NULL, NULL );
+    
+    AtkObjectWrapper *pWrap = NULL;
+    
+    try {
+        uno::Reference< accessibility::XAccessibleContext > xContext(rxAccessible->getAccessibleContext());
+        
+        g_return_val_if_fail( xContext.get() != NULL, NULL );
+        
+        GType nType = ensureTypeFor( xContext.get() );
+        gpointer obj = g_object_new( nType, NULL);
+        
+        if( !uno_to_gobject )
+            uno_to_gobject = g_hash_table_new (NULL, NULL);
+        
+        // We assume direct pointer comparison is sufficient...
+        g_hash_table_insert( uno_to_gobject, (gpointer) rxAccessible.get(), obj );
+        rxAccessible->acquire();
+
+        pWrap = ATK_OBJECT_WRAPPER( obj );
+        pWrap->mpAccessible = rxAccessible.get();
+        
+        xContext->acquire();
+        pWrap->mpContext = xContext.get();
+
+        AtkObject* atk_obj = ATK_OBJECT(pWrap);
+        atk_obj->role = mapToAtkRole( xContext->getAccessibleRole() );
+        
+        if( parent )
+        {
+            atk_obj->accessible_parent = parent;
+            g_object_ref( atk_obj->accessible_parent );
+        }
+        else
+        {
+            uno::Reference< accessibility::XAccessible > xParent(xContext->getAccessibleParent());
+            if( xParent.is() )
+            {
+                atk_obj->accessible_parent = atk_object_wrapper_ref( xParent );
+            }
+            else
+            {
+                atk_object_set_parent( atk_obj, atk_get_root() );
+                g_object_ref( atk_obj->accessible_parent );
+            }
+        }
+        
+        // Attach a listener to the UNO object if it's not TRANSIENT
+        uno::Reference< accessibility::XAccessibleStateSet > xStateSet( xContext->getAccessibleStateSet() );
+        if( xStateSet.is() && ! xStateSet->contains( accessibility::AccessibleStateType::TRANSIENT ) )
+        {
+            uno::Reference< accessibility::XAccessibleEventBroadcaster > xBroadcaster( xContext, uno::UNO_QUERY_THROW );
+            xBroadcaster->addEventListener( static_cast< accessibility::XAccessibleEventListener * > ( new AtkListener( pWrap ) ) );
+        }
+
+        return ATK_OBJECT( pWrap );
+    } 
+    catch (const uno::Exception &e) 
+    {
+        if( pWrap )
+            g_object_unref( pWrap );
+        
+        return NULL;
+    }
+}
+
+#define RELEASE(i) if( i ) { i->release(); i = NULL; }
+
+void atk_object_wrapper_dispose(AtkObjectWrapper* wrapper)
+{
+    RELEASE( wrapper->mpContext )
+    RELEASE( wrapper->mpAction )
+    RELEASE( wrapper->mpComponent )
+    RELEASE( wrapper->mpEditableText )
+    RELEASE( wrapper->mpHypertext )
+    RELEASE( wrapper->mpImage )
+    RELEASE( wrapper->mpSelection )
+    RELEASE( wrapper->mpTable )
+    RELEASE( wrapper->mpText )
+    RELEASE( wrapper->mpValue )
+}
Index: vcl/unx/gtk/a11y/atkwrapper.hxx
===================================================================
RCS file: vcl/unx/gtk/a11y/atkwrapper.hxx
diff -N vcl/unx/gtk/a11y/atkwrapper.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/atkwrapper.hxx	15 Feb 2006 10:59:26 -0000	1.1.2.8
@@ -0,0 +1,125 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __ATK_WRAPPER_HXX__
+#define __ATK_WRAPPER_HXX__
+
+#include <atk/atk.h>
+
+#ifndef _COM_SUN_STAR_ACCESSIBILITY_XACCESSIBLE_HPP_
+#include <com/sun/star/accessibility/XAccessible.hpp>
+#endif
+
+extern "C" {
+
+typedef struct _AtkObjectWrapper      AtkObjectWrapper;
+typedef struct _AtkObjectWrapperClass AtkObjectWrapperClass;
+
+namespace com { namespace sun { namespace star { namespace accessibility {
+    class XAccessibleAction;
+    class XAccessibleComponent;
+    class XAccessibleEditableText;
+    class XAccessibleHypertext;
+    class XAccessibleImage;
+    class XAccessibleSelection;
+    class XAccessibleTable;
+    class XAccessibleText;
+    class XAccessibleValue;
+} } } }
+
+
+struct _AtkObjectWrapper
+{
+    AtkObject aParent;
+
+    ::com::sun::star::accessibility::XAccessible             *mpAccessible;
+    ::com::sun::star::accessibility::XAccessibleContext      *mpContext;
+    ::com::sun::star::accessibility::XAccessibleAction       *mpAction;
+    ::com::sun::star::accessibility::XAccessibleComponent    *mpComponent;
+    ::com::sun::star::accessibility::XAccessibleEditableText *mpEditableText;
+    ::com::sun::star::accessibility::XAccessibleHypertext    *mpHypertext;
+    ::com::sun::star::accessibility::XAccessibleImage        *mpImage;
+    ::com::sun::star::accessibility::XAccessibleSelection    *mpSelection;
+    ::com::sun::star::accessibility::XAccessibleTable        *mpTable;
+    ::com::sun::star::accessibility::XAccessibleText         *mpText;
+    ::com::sun::star::accessibility::XAccessibleValue        *mpValue;
+    
+//    ::rtl::OString * m_pKeyBindings
+};
+
+struct _AtkObjectWrapperClass
+{
+    AtkObjectClass aParentClass;
+};
+
+GType                  atk_object_wrapper_get_type (void) G_GNUC_CONST;
+AtkObject *            atk_object_wrapper_ref(
+    const ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible >& rxAccessible,
+    bool create = true );
+    
+AtkObject *            atk_object_wrapper_new(
+    const ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible >& rxAccessible,
+    AtkObject* parent = NULL );
+
+void                   atk_object_wrapper_dispose(AtkObjectWrapper* wrapper);
+
+AtkStateType mapAtkState( sal_Int16 nState );
+
+void                   actionIfaceInit(AtkActionIface *iface);
+void                   componentIfaceInit(AtkComponentIface *iface);
+void                   editableTextIfaceInit(AtkEditableTextIface *iface);
+void                   hypertextIfaceInit(AtkHypertextIface *iface);
+void                   imageIfaceInit(AtkImageIface *iface);
+void                   selectionIfaceInit(AtkSelectionIface *iface);
+void                   tableIfaceInit(AtkTableIface *iface);
+void                   textIfaceInit(AtkTextIface *iface);
+void                   valueIfaceInit(AtkValueIface *iface);
+
+}; // extern "C"
+
+#define ATK_TYPE_OBJECT_WRAPPER atk_object_wrapper_get_type()
+#define ATK_OBJECT_WRAPPER(obj) \
+    (G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_OBJECT_WRAPPER, AtkObjectWrapper))
+
+static inline gchar *
+OUStringToGChar(const rtl::OUString& rString )
+{
+    rtl::OString aUtf8 = rtl::OUStringToOString( rString, RTL_TEXTENCODING_UTF8 );
+    return g_strdup( aUtf8 );
+}
+
+#define OUStringToConstGChar( string ) rtl::OUStringToOString( string, RTL_TEXTENCODING_UTF8 ).getStr() 
+
+#endif /* __ATK_WRAPPER_HXX__ */
Index: vcl/unx/gtk/a11y/makefile.mk
===================================================================
RCS file: vcl/unx/gtk/a11y/makefile.mk
diff -N vcl/unx/gtk/a11y/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/a11y/makefile.mk	17 Feb 2006 06:09:46 -0000	1.1.2.12
@@ -0,0 +1,96 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=vcl
+TARGET=gtka11y
+ENABLE_EXCEPTIONS=TRUE
+
+# workaround for makedepend hang
+MKDEPENDSOLVER=
+LIBTARGET=NO
+NO_DEFAULT_STL=YES
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(GUIBASE)"!="unx"
+
+dummy:
+	@echo "Nothing to build for GUIBASE $(GUIBASE)"
+
+.ELSE		# "$(GUIBASE)"!="unx"
+
+.IF "$(ENABLE_GTK)" != ""
+
+PKGCONFIG_MODULES=gtk+-2.0
+.INCLUDE : pkg_config.mk
+
+CFLAGS+=-DVERSION=\"$(UPD)$(LAST_MINOR)\"
+
+LIB1TARGET=$(SLB)$/$(TARGET).lib
+LIB1OBJFILES=\
+	$(SLO)$/atkaction.obj \
+	$(SLO)$/atkbridge.obj \
+	$(SLO)$/atkcomponent.obj \
+	$(SLO)$/atkeditabletext.obj \
+	$(SLO)$/atkfactory.obj \
+	$(SLO)$/atkhypertext.obj \
+	$(SLO)$/atkimage.obj \
+	$(SLO)$/atklistener.obj \
+	$(SLO)$/atkselection.obj \
+	$(SLO)$/atktable.obj \
+	$(SLO)$/atktext.obj \
+	$(SLO)$/atktextattributes.obj \
+	$(SLO)$/atkutil.obj \
+	$(SLO)$/atkvalue.obj \
+	$(SLO)$/atkwindow.obj \
+	$(SLO)$/atkwrapper.obj
+
+.ELSE # "$(ENABLE_GTK)" != ""
+
+dummy:
+	@echo GTK disabled - nothing to build
+.ENDIF
+.ENDIF		# "$(GUIBASE)"!="unx"
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
cvs diff: Diffing vcl/unx/gtk/app
Index: vcl/unx/gtk/app/gtkinst.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/gtk/app/gtkinst.cxx,v
retrieving revision 1.11
retrieving revision 1.9.6.9
diff -u -p -r1.11 -r1.9.6.9
--- vcl/unx/gtk/app/gtkinst.cxx	2 Nov 2005 13:32:37 -0000	1.11
+++ vcl/unx/gtk/app/gtkinst.cxx	16 Feb 2006 11:08:15 -0000	1.9.6.9
@@ -40,6 +40,7 @@
 #include <salobj.h>
 #include <plugins/gtk/gtkframe.hxx>
 #include <plugins/gtk/gtkobject.hxx>
+#include <plugins/gtk/atkbridge.hxx>
 
 #include <rtl/strbuf.hxx>
 
@@ -47,6 +48,8 @@
 #include <stdio.h>
 #endif
 
+#include <dlfcn.h>
+
 GtkHookedYieldMutex::GtkHookedYieldMutex()
 {
 }
@@ -140,29 +143,6 @@ extern "C" 
 #endif
             return NULL;
         }
-        /*  #i47797# as long as we do not have a working atk bridge
-         *  prevent atk from interfering with the java accessibility bridge
-         */
-        #if ! defined HAVE_ATK_ACCESSIBILITY_BRIDGE
-        const char* pGtkModules = getenv( "GTK_MODULES" );
-        if( pGtkModules )
-        {
-            rtl::OString aModules( pGtkModules );
-            rtl::OStringBuffer aModulesOut( aModules.getLength() + 11 );
-            aModulesOut.append( "GTK_MODULES=" );
-            sal_Int32 nIndex = 0;
-            while( nIndex >= 0 )
-            {
-                rtl::OString aToken = aModules.getToken( 0, ':', nIndex );
-                if( aToken.equals( "gail" ) ||
-                    aToken.equals( "atk-bridge" ) )
-                    continue;
-                aModulesOut.append( ':' );
-                aModulesOut.append( aToken );
-            }
-            putenv( strdup( aModulesOut.getStr() ) );
-        }
-        #endif
 
 		GtkYieldMutex *pYieldMutex;
 
@@ -189,6 +169,22 @@ extern "C" 
         pSalData->Init();
         pSalData->initNWF();
 
+        const char* pGtkModules = getenv( "GTK_MODULES" );
+        if( pGtkModules )
+        {
+            rtl::OString aModules( pGtkModules );
+            sal_Int32 nIndex = 0;
+            while( nIndex >= 0 )
+            {
+                rtl::OString aToken = aModules.getToken( 0, ':', nIndex );
+                if( aToken.equals( "gail" ) || aToken.equals( "atk-bridge" ) )
+                {
+                    InitAtkBridge();
+                    break;
+                }
+            }
+        }
+
         return pInstance;
     }
 }
cvs diff: Diffing vcl/unx/gtk/gdi
cvs diff: Diffing vcl/unx/gtk/window
Index: vcl/unx/gtk/window/gtkframe.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/gtk/window/gtkframe.cxx,v
retrieving revision 1.42
retrieving revision 1.28.6.19
diff -u -p -r1.42 -r1.28.6.19
--- vcl/unx/gtk/window/gtkframe.cxx	25 Jan 2006 11:40:22 -0000	1.42
+++ vcl/unx/gtk/window/gtkframe.cxx	17 Feb 2006 11:10:57 -0000	1.28.6.19
@@ -45,6 +45,7 @@
 #include <floatwin.hxx>
 #include <salprn.h>
 #include <svapp.hxx>
+#include <window.hxx>
 
 #include <prex.h>
 #include <X11/Xatom.h>
@@ -60,6 +61,11 @@
 #include <cstdio>
 #endif
 
+#include <com/sun/star/accessibility/XAccessibleContext.hpp>
+#include <com/sun/star/accessibility/AccessibleRole.hpp>
+
+using namespace com::sun::star;
+
 int GtkSalFrame::m_nFloats = 0;
 
 static USHORT GetKeyModCode( guint state )
@@ -405,13 +411,49 @@ GtkSalFrame::~GtkSalFrame()
     if( m_pFixedContainer )
         gtk_widget_destroy( GTK_WIDGET(m_pFixedContainer) );
     if( m_pWindow )
+	{
+		g_object_set_data( G_OBJECT( m_pWindow ), "SalFrame", NULL );
         gtk_widget_destroy( GTK_WIDGET(m_pWindow) );
+	}
     if( m_pForeignParent )
         g_object_unref( G_OBJECT(m_pForeignParent) );
     if( m_pForeignTopLevel )
         g_object_unref(G_OBJECT( m_pForeignTopLevel) );
 }
 
+/*
+ * Always use a sub-class of GtkFixed we can tag for a11y. This allows us to
+ * utilize GAIL for the toplevel window and toolkit implementation incl. 
+ * key event listener support ..
+ */
+  
+GType
+ooo_fixed_get_type()
+{
+    static GType type = 0;
+
+    if (!type) {
+        static const GTypeInfo tinfo =
+        {
+            sizeof (GtkFixedClass),
+            (GBaseInitFunc) NULL,      /* base init */
+            (GBaseFinalizeFunc) NULL,  /* base finalize */
+            (GClassInitFunc) NULL,     /* class init */
+            (GClassFinalizeFunc) NULL, /* class finalize */
+            NULL,                      /* class data */
+            sizeof (GtkFixed),         /* instance size */
+            0,                         /* nb preallocs */
+            (GInstanceInitFunc) NULL,  /* instance init */
+            NULL                       /* value table */
+        };
+
+        type = g_type_register_static( GTK_TYPE_FIXED, "OOoFixed", 
+                                       &tinfo, (GTypeFlags) 0);
+    }
+
+    return type;									
+}
+
 void GtkSalFrame::InitCommon()
 {
     // connect signals
@@ -459,7 +501,7 @@ void GtkSalFrame::InitCommon()
 
     // add the fixed container child,
     // fixed is needed since we have to position plugin windows
-    m_pFixedContainer = GTK_FIXED(gtk_fixed_new());
+    m_pFixedContainer = GTK_FIXED(g_object_new( ooo_fixed_get_type(), NULL ));
     gtk_container_add( GTK_CONTAINER(m_pWindow), GTK_WIDGET(m_pFixedContainer) );
     gtk_widget_show( GTK_WIDGET(m_pFixedContainer) );
 
@@ -581,6 +623,102 @@ static void lcl_set_accept_focus( GtkWin
     }
 }
 
+GtkSalFrame *GtkSalFrame::getFromWindow( GtkWindow *pWindow )
+{
+	return (GtkSalFrame *) g_object_get_data( G_OBJECT( pWindow ), "SalFrame" );
+}
+
+AtkRole
+GtkSalFrame::GetAtkRole( GtkWindow* window )
+{
+    static AtkRole aDefaultRole = ATK_ROLE_INVALID;
+    
+    // Special role for sub-menu and combo-box popups that are exposed directly
+    // by their parents already.
+    if( aDefaultRole == ATK_ROLE_INVALID )
+        aDefaultRole = atk_role_register( "redundant object" );
+    
+    AtkRole role = aDefaultRole;
+    
+    GtkSalFrame * pFrame = getFromWindow( window );
+    if( pFrame )
+    {
+        Window *pWindow = static_cast <Window *> (pFrame->GetInstance());
+        if( pWindow )
+        {
+            // Determine the appropriate role for the GtkWindow
+            switch( pWindow->GetAccessibleRole() )
+            {
+                case accessibility::AccessibleRole::ALERT:
+                    role = ATK_ROLE_ALERT;
+                    break;
+                    
+                case accessibility::AccessibleRole::DIALOG:
+                    role = ATK_ROLE_DIALOG;
+                    break;
+            
+                case accessibility::AccessibleRole::FRAME:
+                    role = ATK_ROLE_FRAME;
+                    break;
+            
+                // Ignore window objects for sub-menus, which are exposed 
+                // as children of their parent menu
+                case accessibility::AccessibleRole::WINDOW:
+                {
+                    Window *pChild = pWindow->GetChild( 0 );
+                    if( pChild )
+                    {
+                        uno::Reference< accessibility::XAccessible > xAccessible( pChild->GetAccessible( true ) );
+                        if( xAccessible.is() )            
+                            role = ATK_ROLE_WINDOW;
+                    }
+                }
+                break;
+                
+                default:
+                {
+                    Window *pChild = pWindow->GetChild( 0 );
+                    if( pChild )
+                    {
+                        if( WINDOW_HELPTEXTWINDOW == pChild->GetType() )
+                        {
+                            role = ATK_ROLE_TOOL_TIP;
+                            pChild->SetAccessibleRole( accessibility::AccessibleRole::LABEL );
+                        }
+                    }
+                    break;
+                }
+            }
+        }
+    }
+    
+    return role;
+}
+
+
+// FIXME: rename as appropriate
+uno::Reference< accessibility::XAccessible >
+GtkSalFrame::getAccessible( bool bCreate )
+{
+	// Yes - this is a hack - but: this abstraction seems totally useless to me
+	Window *pWindow = static_cast<Window *>(GetInstance());
+    
+    g_return_val_if_fail( pWindow != NULL, NULL );
+    
+    // skip the border window accessible
+    if( pWindow->GetType() == WINDOW_BORDERWINDOW )
+    {
+        pWindow = pWindow->GetAccessibleChildWindow( 0 );
+        g_return_val_if_fail( pWindow != NULL, NULL );
+    }
+    // replace the top-level role Dialog with something more appropriate ..
+    else if( pWindow->GetAccessibleRole() == accessibility::AccessibleRole::ALERT || 
+             pWindow->GetAccessibleRole() == accessibility::AccessibleRole::DIALOG )
+        pWindow->SetAccessibleRole(accessibility::AccessibleRole::OPTION_PANE);
+    
+    return pWindow->GetAccessible( bCreate );
+}
+
 void GtkSalFrame::Init( SalFrame* pParent, ULONG nStyle )
 {
     if( nStyle & SAL_FRAME_STYLE_DEFAULT ) // ensure default style
@@ -590,6 +728,8 @@ void GtkSalFrame::Init( SalFrame* pParen
     }
 
     m_pWindow = GTK_WINDOW( gtk_widget_new( GTK_TYPE_WINDOW, "type", ((nStyle & SAL_FRAME_STYLE_FLOAT) && ! (nStyle & SAL_FRAME_STYLE_OWNERDRAWDECORATION)) ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL, "visible", FALSE, NULL ) );
+	g_object_set_data( G_OBJECT( m_pWindow ), "SalFrame", this );
+
     m_pParent = static_cast<GtkSalFrame*>(pParent);
     m_pForeignParent = NULL;
     m_aForeignParentWindow = None;
cvs diff: Diffing vcl/unx/inc
cvs diff: Diffing vcl/unx/inc/plugins
cvs diff: Diffing vcl/unx/inc/plugins/gtk
Index: vcl/unx/inc/plugins/gtk/atkbridge.hxx
===================================================================
RCS file: vcl/unx/inc/plugins/gtk/atkbridge.hxx
diff -N vcl/unx/inc/plugins/gtk/atkbridge.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/inc/plugins/gtk/atkbridge.hxx	12 Jan 2006 13:57:32 -0000	1.1.2.3
@@ -0,0 +1,45 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __ATK_BRIDGE_HXX__
+#define __ATK_BRIDGE_HXX__
+
+#ifndef _VCL_DLLAPI_H
+#include <dllapi.h>
+#endif
+
+void VCL_DLLPUBLIC InitAtkBridge(void);
+
+#endif
Index: vcl/unx/inc/plugins/gtk/gtkframe.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/plugins/gtk/gtkframe.hxx,v
retrieving revision 1.21
retrieving revision 1.14.22.11
diff -u -p -r1.21 -r1.14.22.11
--- vcl/unx/inc/plugins/gtk/gtkframe.hxx	19 Jan 2006 18:27:42 -0000	1.21
+++ vcl/unx/inc/plugins/gtk/gtkframe.hxx	16 Feb 2006 11:08:18 -0000	1.14.22.11
@@ -43,6 +43,9 @@
 #include <gdk/gdkkeysyms.h>
 #include <postx.h>
 
+#include <com/sun/star/uno/Reference.hxx>
+#include <com/sun/star/accessibility/XAccessible.hdl>
+
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
@@ -355,7 +358,20 @@ public:
     virtual bool                SetPluginParent( SystemParentData* pNewParent );
 
     virtual void                SetBackgroundBitmap( SalBitmap* );
+
+	static GtkSalFrame         *getFromWindow( GtkWindow *pWindow );
+	::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > getAccessible( bool bCreate = true );
+    
+    static AtkRole              GetAtkRole( GtkWindow* window );
 };
 
 
+#define OOO_TYPE_FIXED ooo_fixed_get_type()
+
+extern "C" {
+
+GType ooo_fixed_get_type( void );
+
+} // extern "C"
+
 #endif //_VCL_GTKFRAME_HXX
cvs diff: Diffing vcl/unx/inc/plugins/kde
cvs diff: Diffing vcl/unx/kde
cvs diff: Diffing vcl/unx/source
cvs diff: Diffing vcl/unx/source/app
cvs diff: Diffing vcl/unx/source/gdi
cvs diff: Diffing vcl/unx/source/inc
cvs diff: Diffing vcl/unx/source/plugadapt
cvs diff: Diffing vcl/unx/source/src
cvs diff: Diffing vcl/unx/source/window
cvs diff: Diffing vcl/util
Index: vcl/util/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/util/makefile.mk,v
retrieving revision 1.77
retrieving revision 1.65.110.11
diff -u -p -r1.77 -r1.65.110.11
--- vcl/util/makefile.mk	19 Dec 2005 17:21:56 -0000	1.77
+++ vcl/util/makefile.mk	16 Feb 2006 11:08:19 -0000	1.65.110.11
@@ -357,8 +357,10 @@ PKGCONFIG_MODULES=gtk+-2.0 gthread-2.0
 LIB4TARGET=$(SLB)$/igtk_plug_
 LIB4FILES=\
 			$(SLB)$/gtkapp.lib\
+			$(SLB)$/gtka11y.lib \
 			$(SLB)$/gtkgdi.lib\
 			$(SLB)$/gtkwin.lib
+
 SHL4TARGET=vclplug_gtk$(UPD)$(DLLPOSTFIX)
 SHL4IMPLIB=igtk_plug_
 SHL4LIBS=$(LIB4TARGET)
