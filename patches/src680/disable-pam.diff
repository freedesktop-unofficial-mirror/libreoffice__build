--- config_office/configure.in.orig	2006-04-30 13:19:54.000000000 +0200
+++ config_office/configure.in	2006-04-30 13:45:32.000000000 +0200
@@ -223,6 +223,9 @@
 AC_ARG_ENABLE(pasf,
 [  --disable-pasf          disable support for sound using portaudio/sndfile
 ],,enable_pasf=yes)
+AC_ARG_ENABLE(pam,
+[  --disable-pam           Disable pam support.
+],,)
 AC_ARG_ENABLE(pam-link,
 [  --enable-pam-link       link with libpam instead of dynamically open it
 ],,)
@@ -1563,6 +1566,10 @@
 dnl Check if PAM/pam_appl.h is available on Linux or FreeBSD
 dnl ===================================================================
 if test "$_os" = "Linux" -o "$_os" = "FreeBSD" -o "$_os" = "GNU"; then
+  AC_MSG_CHECKING([whether to enable pam support])
+  if test -z "$enable_pam" || test "$enable_pam" != "no"; then
+    AC_MSG_RESULT([yes])
+    PAM=YES
     AC_CHECK_HEADER(security/pam_appl.h, [],
                     [AC_MSG_ERROR([pam_appl.h could not be found. libpam-dev or pam-devel missing?])], [])
     AC_MSG_CHECKING([whether to link to libpam])
@@ -1575,7 +1582,15 @@
       AC_MSG_RESULT([no, dynamically open it])
       PAM_LINK=NO
     fi
+  else
+    AC_MSG_RESULT([no])
+    PAM=NO
+    PAM_LINK=NO
+    dnl check getspnam_r for needed args (4 or 5)
+    AX_FUNC_WHICH_GETSPNAM_R
+  fi
 fi
+AC_SUBST(PAM)
 AC_SUBST(PAM_LINK)
 
 if test "$_os" = "Linux"; then
--- config_office/set_soenv.in.orig	2006-04-30 13:45:44.000000000 +0200
+++ config_office/set_soenv.in	2006-04-30 13:46:11.000000000 +0200
@@ -1823,6 +1823,8 @@
 ToFile( "HUNSPELL_CFLAGS",   "@HUNSPELL_CFLAGS@",  "e" );
 ToFile( "SYSTEM_HYPH",       "@SYSTEM_HYPH@",      "e" );
 ToFile( "SYSTEM_MYTHES",     "@SYSTEM_MYTHES@",    "e" );
+ToFile( "PAM",               "@PAM@",              "e" );
+ToFile( "NEW_SHADOW_API",    "@NEW_SHADOW_API@",   "e" );
 ToFile( "PAM_LINK",          "@PAM_LINK@",         "e" );
 ToFile( "CRYPT_LINK",        "@CRYPT_LINK@",       "e" );
 ToFile( "GXX_INCLUDE_PATH",  "@GXX_INCLUDE_PATH@", "e" );
--- sal/osl/unx/makefile.mk.orig	2006-04-30 13:47:44.000000000 +0200
+++ sal/osl/unx/makefile.mk	2006-04-30 15:37:51.000000000 +0200
@@ -122,6 +122,12 @@
 .ENDIF
 
 .IF "$(OS)" == "LINUX"
+.IF "$(PAM)" == "NO"
+CFLAGS+=-DNOPAM
+.ENDIF
+.IF "$(NEW_SHADOW_API)" == "YES"
+CFLAGS+=-DNEW_SHADOW_API
+.ENDIF
 .IF "$(PAM_LINK)" == "YES"
 CFLAGS+=-DPAM_LINK
 .ENDIF
--- sal/osl/unx/security.c.orig	2006-04-30 13:09:11.000000000 +0200
+++ sal/osl/unx/security.c	2006-04-30 15:25:52.000000000 +0200
@@ -53,9 +53,11 @@
 
 #include "secimpl.h"
 
+#ifndef NOPAM
 #ifndef PAM_BINARY_MSG
 #define PAM_BINARY_MSG 6
 #endif
+#endif
 
 extern oslModule SAL_CALL osl_psz_loadModule(const sal_Char *pszModuleName, sal_Int32 nRtldMode);
 extern void* SAL_CALL osl_psz_getSymbol(oslModule hModule, const sal_Char* pszSymbolName);
@@ -100,7 +102,7 @@
 }
 
 
-#ifdef LINUX
+#if defined LINUX && !defined NOPAM
 
 /*
  *
@@ -402,7 +404,7 @@
 	return success;
 }
 
-#endif
+#endif /* defined LINUX && !defined NOPAM */
 oslSecurityError SAL_CALL osl_loginUser(
     rtl_uString *ustrUserName,
 	rtl_uString *ustrPassword,
@@ -482,7 +484,7 @@
                 if (found == NULL) {
                     nError = osl_Security_E_UserUnknown;
                 } else {
-#if defined LINUX
+#if defined LINUX && !defined NOPAM
                     /* only root is able to read the /etc/shadow passwd, a
                        normal user even can't read his own encrypted passwd */
                     if (osl_equalPasswords(p->m_pPasswd.pw_passwd, pszPasswd) ||
@@ -537,9 +539,11 @@
                     char buffer[1024];
                     struct spwd spwdStruct;
                     buffer[0] = '\0';
-                    if (getspnam_r(
-                            pszUserName, &spwdStruct, buffer, sizeof buffer) !=
-                        NULL)
+#ifndef NEW_SHADOW_API
+                    if (getspnam_r(pszUserName, &spwdStruct, buffer, sizeof buffer) != NULL)
+#else
+                    if (getspnam_r(pszUserName, &spwdStruct, buffer, sizeof buffer, NULL) == 0)
+#endif
                     {
                         char salt[3];
                         char * cryptPasswd;
@@ -549,10 +553,11 @@
                         if (strcmp(spwdStruct.sp_pwdp, cryptPasswd) == 0) {
                             nError = osl_Security_E_None;
                         } else if (getuid() == 0 &&
-                                   (getspnam_r(
-                                       "root", &spwdStruct, buffer,
-                                       sizeof buffer)
-                                    != NULL))
+#ifndef NEW_SHADOW_API
+                                   (getspnam_r("root", &spwdStruct, buffer, sizeof buffer) != NULL))
+#else
+                                   (getspnam_r("root", &spwdStruct, buffer, sizeof buffer, NULL) == 0))
+#endif
                         {
                             /* if current process is running as root, allow to
                                logon as any other user */
--- /dev/null	2006-05-01 20:47:14.000000000 +0200
+++ config_office/acinclude.m4	2006-05-01 22:18:47.000000000 +0200
@@ -0,0 +1,120 @@
+dnl @synopsis AX_FUNC_WHICH_GETSPNAM_R
+dnl
+dnl Determines which historical variant of the getspnam_r() call
+dnl (taking four or five arguments) is available on the system
+dnl and sets NEW_SHADOW_API=YES if there are five arguments.
+dnl
+dnl Originally named "AX_FUNC_WHICH_GETHOSTBYNAME_R". Rewritten
+dnl for AX_FUNC_WHICH_GETSPNAM_R
+dnl
+dnl @author Caolan McNamara <caolan@skynet.ie>
+dnl @author Daniel Richard G. <skunk@iskunk.org>
+dnl @version 2006-05-01
+dnl @license GPLWithACException
+
+AC_DEFUN([AX_FUNC_WHICH_GETSPNAM_R], [
+
+    AC_LANG_PUSH(C)
+    AC_MSG_CHECKING([how many arguments getspnam_r() takes])
+
+    AC_CACHE_VAL(ac_cv_func_which_getspnam_r, [
+
+################################################################
+
+ac_cv_func_which_getspnam_r=unknown
+
+#
+# ONE ARGUMENT (sanity check)
+#
+
+# This should fail, as there is no variant of getspnam_r() that takes
+# a single argument. If it actually compiles, then we can assume that
+# netdb.h is not declaring the function, and the compiler is thereby
+# assuming an implicit prototype. In which case, we're out of luck.
+#
+AC_COMPILE_IFELSE(
+    AC_LANG_PROGRAM(
+	[[
+	    #include <sys/types.h>
+	    #include <shadow.h>
+	]],
+	[[
+	    const char *name = "myname";
+	    getspnam_r(name) /* ; */
+	]]),
+    ac_cv_func_which_getspnam_r=no)
+
+#
+# FIVE ARGUMENTS
+#
+
+if test "$ac_cv_func_which_getspnam_r" = "unknown"; then
+
+AC_COMPILE_IFELSE(
+    AC_LANG_PROGRAM(
+	[[
+	    #include <sys/types.h>
+	    #include <shadow.h>
+	]],
+	[[
+	    char buffer[[]] = { '\0' };
+	    struct spwd spwdStruct;
+	    const char *name = "myname";
+	    getspnam_r(name, &spwdStruct, buffer, sizeof buffer, 0) /* ; */
+	]]),
+    ac_cv_func_which_getspnam_r=five)
+
+fi
+
+#
+# FOUR ARGUMENTS
+#
+
+if test "$ac_cv_func_which_getspnam_r" = "unknown"; then
+
+AC_COMPILE_IFELSE(
+    AC_LANG_PROGRAM(
+	[[
+	    #include <sys/types.h>
+	    #include <shadow.h>
+	]],
+	[[
+	    char buffer[[]] = { '\0' };
+	    struct spwd spwdStruct;
+	    const char *name = "myname";
+	    getspnam_r(name, &spwdStruct, buffer, sizeof buffer) /* ; */
+	]]),
+    ac_cv_func_which_getspnam_r=four)
+
+fi
+
+################################################################
+
+]) dnl end AC_CACHE_VAL
+
+case "$ac_cv_func_which_getspnam_r" in
+    five)
+    AC_MSG_RESULT([five])
+    AC_SUBST(NEW_SHADOW_API, YES)
+    ;;
+
+    four)
+    AC_MSG_RESULT([four])
+    ;;
+
+    no)
+    AC_MSG_RESULT([cannot find function declaration in shadow.h])
+    ;;
+
+    unknown)
+    AC_MSG_RESULT([can't tell])
+    ;;
+
+    *)
+    AC_MSG_ERROR([internal error])
+    ;;
+esac
+
+AC_LANG_POP(C)
+
+]) dnl end AC_DEFUN
