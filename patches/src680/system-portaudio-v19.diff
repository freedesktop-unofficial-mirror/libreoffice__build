--- config_office/configure.in.orig	2007-04-13 21:56:44.000000000 +0200
+++ config_office/configure.in	2007-04-13 22:34:12.000000000 +0200
@@ -4288,6 +4288,7 @@
 	   SYSTEM_SNDFILE=NO
 	    BUILD_TYPE="$BUILD_TYPE SNDFILE"
 	fi
+   PA_VER=18
 	AC_MSG_CHECKING([which portaudio to use])
 	if test -n "$with_system_portaudio" -o -n "$with_system_libs" && \
 		test "$with_system_portaudio" != "no"; then
@@ -4298,11 +4299,9 @@
 		[AC_MSG_ERROR(portaudio library not found or functional)], [])
 	   AC_MSG_CHECKING(portaudio version)
 	   AC_TRY_LINK([#include <portaudio.h>], [
-void main(int argc, char **argv) {
 	 /* Pa_GetVersion() only exists in v19, so this fails to build with v18 */
         int v = Pa_GetVersion();
-}
-	   ], [AC_MSG_ERROR([portaudio too new. you need v18])], [AC_MSG_RESULT([OK, v18])])
+	   ], [PA_VER=19; AC_MSG_RESULT([OK, v$PA_VER])], [AC_MSG_RESULT([OK, v$PA_VER])])
       SYSTEM_PORTAUDIO=YES
 	else
 	   AC_MSG_RESULT([internal])
@@ -4313,6 +4312,7 @@
 	AC_MSG_RESULT([no])
 fi
 AC_SUBST(ENABLE_PASF)
+AC_SUBST(PA_VER)
 AC_SUBST(SYSTEM_PORTAUDIO)
 AC_SUBST(SYSTEM_SNDFILE)
 AC_SUBST(BUILD_TYPE)
--- config_office/set_soenv.in.orig	2007-04-13 22:04:42.000000000 +0200
+++ config_office/set_soenv.in	2007-04-13 22:31:22.000000000 +0200
@@ -1882,6 +1882,7 @@
 ToFile( "ENABLE_PASF",       "@ENABLE_PASF@",      "e" );
 ToFile( "SYSTEM_SNDFILE",    "@SYSTEM_SNDFILE@",   "e" );
 ToFile( "SYSTEM_PORTAUDIO",  "@SYSTEM_PORTAUDIO@", "e" );
+ToFile( "PA_VER",            "@PA_VER@",           "e" );
 ToFile( "SYSTEM_NEON",       "@SYSTEM_NEON@",      "e" );
 ToFile( "NEON_VERSION",      "@NEON_VERSION@",     "e" );
 ToFile( "NEON_LIBS",         "@NEON_LIBS@",        "e" );
--- vcl/unx/source/app/makefile.mk.orig	2007-04-13 22:12:44.000000000 +0200
+++ vcl/unx/source/app/makefile.mk	2007-04-13 22:36:04.000000000 +0200
@@ -94,7 +94,7 @@
 .ENDIF
 
 .IF "$(ENABLE_PASF)" != ""
-CDEFS+=-DUSE_PASF
+CDEFS+=-DUSE_PASF -DPA_VER=$(PA_VER)
 SLOFILES+=$(SLO)$/pasfsound.obj
 .IF "$(SYSTEM_SNDFILE)" == "YES"
 CDEFS+=-DSYSTEM_SNDFILE
--- vcl/unx/source/app/salimpsound.hxx.orig	2007-04-13 21:20:55.000000000 +0200
+++ vcl/unx/source/app/salimpsound.hxx	2007-04-13 22:31:22.000000000 +0200
@@ -190,7 +190,11 @@
 
 typedef struct
 {       
+#if PA_VER == 18
     PaDeviceID       device;
+#else
+    PaDeviceIndex    device;
+#endif
     PaSampleFormat   format;
     unsigned int     bufsize;
     SNDFILE          *sndfile;
--- vcl/unx/source/app/pasfsound.cxx.orig	2007-04-13 21:21:06.000000000 +0200
+++ vcl/unx/source/app/pasfsound.cxx	2007-04-13 22:31:22.000000000 +0200
@@ -63,15 +63,22 @@
 {
     
     /* callback that takes data from sound file and converts it and loads it */
-    
+#if PA_VER == 18
     static int pasf_in_out_callback (void *inputBuffer, void * outputBuffer,
     unsigned long framesPerBuffer, PaTimestamp outTime, void * userData )
+#else
+    static int pasf_in_out_callback (const void *inputBuffer, void *outputBuffer,
+    unsigned long framesPerBuffer, const PaStreamCallbackTimeInfo *outTime, PaStreamCallbackFlags cbFlags, void *userData )
+#endif
     {	
         PASFAudioData*	paudio_data;
         unsigned int	read_count, bufoff, bytecnt; 
         float*          buffer  = (float *) outputBuffer;
         
         /* prevent warnings for unused variables */
+#if PA_VER > 18
+        cbFlags = cbFlags;
+#endif
         inputBuffer = inputBuffer;
         outTime = outTime;
         
@@ -142,7 +149,11 @@
     m_pData->bufsize = PASF_BUFFER_LEN;
     
     // Using the default output device for this
+#if PA_VER == 18
     m_pData->device = Pa_GetDefaultOutputDeviceID();
+#else
+    m_pData->device = Pa_GetDefaultOutputDevice();
+#endif
     
     // the size of a frame in bytes is the number of channels of data * the size of the 
     // underlying data type type being used to store data for each for each channel
@@ -159,7 +170,9 @@
     m_pData->format,               // 32 bit floating point format for each item
     m_pData->sfinfo.samplerate,    // get desired sampling rate from file
     framesPerBuffer,               // frames per buffer
+#if PA_VER == 18
     0,                             // number of buffers, if zero then use optimal number as determined by Pa
+#endif
     pasf_in_out_callback,          // call back to load data into the stream
     m_pData );                     // pass along m_pData pointer so that callback can get access to info
     
