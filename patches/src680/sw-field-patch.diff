? sw/source/out.diff
? sw/source/core/unocore/out.txt
? sw/source/filter/ww8/out.txt
? sw/source/ui/docvw/edtwin.cxx.save
Index: sw/inc/IDocumentBookmarkAccess.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/IDocumentBookmarkAccess.hxx,v
retrieving revision 1.3
diff -c -r1.3 IDocumentBookmarkAccess.hxx
*** sw/inc/IDocumentBookmarkAccess.hxx	11 Oct 2006 08:41:22 -0000	1.3
--- sw/inc/IDocumentBookmarkAccess.hxx	21 Jan 2008 08:32:23 -0000
***************
*** 41,50 ****
--- 41,52 ----
  #endif
  
  class SwBookmark;
+ class SwFieldBookmark;
  class SwBookmarks;
  class SwPaM;
  class KeyCode;
  class String;
+ class SwPosition;
  
   /** Provides access to the bookmarks of a document.
   */
***************
*** 57,63 ****
          MARK, 
          DDE_BOOKMARK, 
          UNO_BOOKMARK,
!         HIDDEN_BOOKMARK
      };
      
   public:    
--- 59,68 ----
          MARK, 
          DDE_BOOKMARK, 
          UNO_BOOKMARK,
!         HIDDEN_BOOKMARK,
! //		FIELDMARK, // for future use...
! 		FORM_FIELDMARK_TEXT,
! 		FORM_FIELDMARK_NO_TEXT
      };
      
   public:    
***************
*** 147,153 ****
         the bookmark.
      */
      virtual SwBookmark& getBookmark(  /*[in]*/sal_uInt16 nPos, /*[in]*/bool bBkmrk) = 0;
!     
  protected:
      virtual ~IDocumentBookmarkAccess() {};
   };
--- 152,162 ----
         the bookmark.
      */
      virtual SwBookmark& getBookmark(  /*[in]*/sal_uInt16 nPos, /*[in]*/bool bBkmrk) = 0;
! 
!     virtual SwBookmark* getFieldBookmarkFor(const SwPosition &pos) const = 0;    
!     virtual SwFieldBookmark* getFormFieldBookmarkFor(const SwPosition &pos) const = 0;    
!     virtual SwBookmark* getNextFieldBookmarkFor(const SwPosition &pos) const = 0;    
!     virtual SwBookmark* getPrevFieldBookmarkFor(const SwPosition &pos) const = 0;    
  protected:
      virtual ~IDocumentBookmarkAccess() {};
   };
Index: sw/inc/IDocumentSettingAccess.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/IDocumentSettingAccess.hxx,v
retrieving revision 1.6
diff -c -r1.6 IDocumentSettingAccess.hxx
*** sw/inc/IDocumentSettingAccess.hxx	20 Jun 2007 10:10:38 -0000	1.6
--- sw/inc/IDocumentSettingAccess.hxx	21 Jan 2008 08:32:23 -0000
***************
*** 91,96 ****
--- 91,97 ----
           UNIX_FORCE_ZERO_EXT_LEADING,
           USE_OLD_PRINTER_METRICS,
           TABS_RELATIVE_TO_INDENT,
+          PROTECT_FORM,
           // COMPATIBILITY FLAGS END
  
           BROWSE_MODE,
Index: sw/inc/bookmrk.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/bookmrk.hxx,v
retrieving revision 1.8
diff -c -r1.8 bookmrk.hxx
*** sw/inc/bookmrk.hxx	8 Nov 2006 13:20:14 -0000	1.8
--- sw/inc/bookmrk.hxx	21 Jan 2008 08:32:24 -0000
***************
*** 108,118 ****
  	// falls man wirklich auf gleiche Position abfragen will.
  	BOOL IsEqualPos( const SwBookmark &rBM ) const;
  
! 	BOOL IsBookMark() const 	{ return IDocumentBookmarkAccess::BOOKMARK == eMarkType; }
  	BOOL IsMark() const 		{ return IDocumentBookmarkAccess::MARK == eMarkType; }
      BOOL IsDDEMark() const      { return IDocumentBookmarkAccess::DDE_BOOKMARK == eMarkType; }
  	BOOL IsUNOMark() const 		{ return IDocumentBookmarkAccess::UNO_BOOKMARK == eMarkType; }
      BOOL IsHiddenBookMark() const { return IDocumentBookmarkAccess::HIDDEN_BOOKMARK == eMarkType; }
  	void SetType( IDocumentBookmarkAccess::BookmarkType eNewType ) 	{ eMarkType = eNewType; }
  	IDocumentBookmarkAccess::BookmarkType GetType() const 	{ return eMarkType; }
  
--- 108,119 ----
  	// falls man wirklich auf gleiche Position abfragen will.
  	BOOL IsEqualPos( const SwBookmark &rBM ) const;
  
! 	BOOL IsBookMark() const 	{ return IDocumentBookmarkAccess::BOOKMARK == eMarkType || IDocumentBookmarkAccess::FORM_FIELDMARK_TEXT == eMarkType || IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT == eMarkType; }
  	BOOL IsMark() const 		{ return IDocumentBookmarkAccess::MARK == eMarkType; }
      BOOL IsDDEMark() const      { return IDocumentBookmarkAccess::DDE_BOOKMARK == eMarkType; }
  	BOOL IsUNOMark() const 		{ return IDocumentBookmarkAccess::UNO_BOOKMARK == eMarkType; }
      BOOL IsHiddenBookMark() const { return IDocumentBookmarkAccess::HIDDEN_BOOKMARK == eMarkType; }
+ 	BOOL IsFormFieldMark() const 	{ return IDocumentBookmarkAccess::FORM_FIELDMARK_TEXT == eMarkType || IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT == eMarkType; }
  	void SetType( IDocumentBookmarkAccess::BookmarkType eNewType ) 	{ eMarkType = eNewType; }
  	IDocumentBookmarkAccess::BookmarkType GetType() const 	{ return eMarkType; }
  
***************
*** 160,164 ****
--- 161,217 ----
  		const String& rName, const String& rShortName);
  };
  
+ class SwFieldBookmark : public SwBookmark
+ {
+ private:
+ 	int fftype; // Type: 0 = Text, 1 = Check Box, 2 = List
+ 	int ffres;
+     bool ffprot;
+ 	bool ffsize; // 0 = Auto, 1=Exact (see ffhps)
+ 	int fftypetxt; // Type of text field: 0 = Regular text, 1 = Number, 2 = Date, 3 = Current date, 4 = Current time, 5 = Calculation
+ 	bool ffrecalc; 
+ 	int ffmaxlen; // Number of characters for text field. Zero means unlimited.
+ 	int ffhps; // Check box size (half-point sizes).
+ 
+ 	String ffname;
+ 	String ffhelptext;
+ 
+ public:
+     SwFieldBookmark(const SwPosition& aPos,
+ 	       const KeyCode& rCode,
+ 	       const String& rName, const String& rShortName,
+ 		   IDocumentBookmarkAccess::BookmarkType eMark);
+ 
+ 	void SetType(int fftype);
+ 	int GetType();
+ 
+ 	void SetChecked(bool checked);
+ 	bool IsChecked();
+ 
+ 	void SetFFName(String ffname) {
+ 		this->ffname=ffname;
+ 	}
+ 
+ 	String GetFFName()
+ 	{
+ 		return ffname;
+ 	}
+ 
+ 	int GetFFRes() {
+ 		return ffres;
+ 	}
+ 
+ 	void SetFFRes(int ffres) {
+ 		this->ffres=ffres;
+ 	}
+ 
+ 	void SetFFHelpText(String ffhelptext) {
+ 		this->ffhelptext=ffhelptext;
+ 	}
+ 
+ 	String GetFFHelpText() {
+ 		return ffhelptext;
+ 	}
+ };
  
  #endif
Index: sw/inc/crsrsh.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/crsrsh.hxx,v
retrieving revision 1.37
diff -c -r1.37 crsrsh.hxx
*** sw/inc/crsrsh.hxx	27 Jun 2007 13:13:02 -0000	1.37
--- sw/inc/crsrsh.hxx	21 Jan 2008 08:32:24 -0000
***************
*** 83,94 ****
--- 83,96 ----
  #include <IDocumentBookmarkAccess.hxx>
  #endif
  
+ 
  // einige Forward Deklarationen
  
  class KeyCode;
  class SfxItemSet;
  class SfxPoolItem;
  class SwBookmark;
+ class SwFieldBookmark;
  class SwCntntFrm;
  class SwCrsrShell;
  class SwCursor;
***************
*** 619,624 ****
--- 621,633 ----
  		// werden, es wird dann bei gleichen Namen nur durchnumeriert.
  	void MakeUniqueBookmarkName( String& rNm );
  
+         bool IsFormProtected();
+         SwBookmark* IsInFieldBookmark();
+         SwFieldBookmark* IsInFormFieldBookmark();
+         SwBookmark* GetNextFieldBookmark();
+         SwBookmark* GetPrevFieldBookmark();
+         bool GotoFieldBookmark(SwBookmark *pBkmk);
+ 
  	// aktualisiere den Crsrs, d.H. setze ihn wieder in den Content.
  	// Das sollte nur aufgerufen werden, wenn der Cursor z.B. beim
  	// Loeschen von Rahmen irgendwohin gesetzt wurde. Die Position
Index: sw/inc/doc.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/doc.hxx,v
retrieving revision 1.140
diff -c -r1.140 doc.hxx
*** sw/inc/doc.hxx	18 Jul 2007 12:54:37 -0000	1.140
--- sw/inc/doc.hxx	21 Jan 2008 08:32:24 -0000
***************
*** 619,624 ****
--- 619,625 ----
      bool mbUnixForceZeroExtLeading                  : 1;   // FME 2006-10-09 #i60945#
      bool mbOldPrinterMetrics                        : 1;   // FME 2007-05-14 #147385#
      bool mbTabRelativeToIndent;                            // #i24363# tab stops relative to indent
+     bool mbProtectForm                              : 1;
  
  	// #i78591#
  	sal_uInt32  n32DummyCompatabilityOptions1;
***************
*** 778,783 ****
--- 778,787 ----
      virtual void makeUniqueBookmarkName( /*[in/out]*/String& rName );
      virtual sal_uInt16 getBookmarkCount( /*[in]*/ bool bBkmrk ) const;
      virtual SwBookmark& getBookmark( /*[in]*/sal_uInt16 nPos, /*[in]*/bool bBkmrk );
+     SwBookmark* getFieldBookmarkFor(const SwPosition &pos) const;
+     SwBookmark* getNextFieldBookmarkFor(const SwPosition &pos) const;
+     SwBookmark* getPrevFieldBookmarkFor(const SwPosition &pos) const;
+     SwFieldBookmark* getFormFieldBookmarkFor(const SwPosition &pos) const;
  
      /** IDocumentRedlineAccess
      */
***************
*** 961,966 ****
--- 965,971 ----
  	/** IDocumentState
  	*/
  	virtual void SetModified();
+         virtual void SetModified(SwPaM &rPaM);
  	virtual void ResetModified();
  	virtual bool IsModified() const;
  	virtual bool IsLoaded() const;
Index: sw/inc/hintids.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/hintids.hxx,v
retrieving revision 1.34
diff -c -r1.34 hintids.hxx
*** sw/inc/hintids.hxx	18 Jul 2007 13:29:01 -0000	1.34
--- sw/inc/hintids.hxx	21 Jan 2008 08:32:24 -0000
***************
*** 52,58 ****
  #define CH_TXTATR_INWORD		((sal_Unicode)0x02)
  #define CH_TXTATR_TAB           ((sal_Unicode)'\t')
  #define CH_TXTATR_NEWLINE       ((sal_Unicode)'\n')
! 
  /*
   * Hier kommen erst mal die enums fuer die Hints
   */
--- 52,67 ----
  #define CH_TXTATR_INWORD		((sal_Unicode)0x02)
  #define CH_TXTATR_TAB           ((sal_Unicode)'\t')
  #define CH_TXTATR_NEWLINE       ((sal_Unicode)'\n')
! #define CH_TXT_ATR_FIELDSTART ((sal_Unicode)0x04)
! #define CH_TXT_ATR_FIELDEND ((sal_Unicode)0x05)
! #define CH_TXT_ATR_SUBST_FIELDSTART ("[")
! #define CH_TXT_ATR_SUBST_FIELDEND ("]")
! //#define CH_TXT_ATR_FORMELEMENT ((sal_Unicode)'#')
! #define CH_TXT_ATR_FORMELEMENT ((sal_Unicode)0x06)
! /*
! #define FIELD_BOOKMARK_PREFIX "__"
! #define FIELD_FORM_BOOKMARK_PREFIX "__FORM"
! */
  /*
   * Hier kommen erst mal die enums fuer die Hints
   */
Index: sw/inc/unocoll.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/unocoll.hxx,v
retrieving revision 1.21
diff -c -r1.21 unocoll.hxx
*** sw/inc/unocoll.hxx	22 May 2007 16:21:18 -0000	1.21
--- sw/inc/unocoll.hxx	21 Jan 2008 08:32:25 -0000
***************
*** 220,227 ****
  #define SW_SERVICE_IMAP_POLYGON                         104
  #define SW_SERVICE_TYPE_TEXT_GRAPHIC                    105
  #define SW_SERVICE_CHART2_DATA_PROVIDER                 106
  
! #define SW_SERVICE_LAST                 SW_SERVICE_FIELDTYPE_DOCINFO_CUSTOM
  
  #define SW_SERVICE_INVALID			USHRT_MAX
  
--- 220,229 ----
  #define SW_SERVICE_IMAP_POLYGON                         104
  #define SW_SERVICE_TYPE_TEXT_GRAPHIC                    105
  #define SW_SERVICE_CHART2_DATA_PROVIDER                 106
+ #define SW_SERVICE_TYPE_FIELDMARK                                     107 
+ #define SW_SERVICE_TYPE_FORMFIELDMARK                                 108 
  
! #define SW_SERVICE_LAST                 SW_SERVICE_TYPE_FORMFIELDMARK
  
  #define SW_SERVICE_INVALID			USHRT_MAX
  
***************
*** 499,504 ****
--- 501,509 ----
  	static SwXBookmark* 	GetObject( SwBookmark& rBkm, SwDoc* pDoc );
  };
  
+ class SwXFieldmarks : public SwXBookmarks
+ {
+ };
  
  class SwXNumberingRulesCollection : public cppu::WeakImplHelper1
  <
Index: sw/inc/unoobj.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/unoobj.hxx,v
retrieving revision 1.44
diff -c -r1.44 unoobj.hxx
*** sw/inc/unoobj.hxx	18 Jul 2007 12:55:39 -0000	1.44
--- sw/inc/unoobj.hxx	21 Jan 2008 08:32:25 -0000
***************
*** 151,156 ****
--- 151,159 ----
  #ifndef _CPPUHELPER_FACTORY_HXX_
  #include <cppuhelper/factory.hxx>	// helper for factories
  #endif
+ #ifndef _CPPUHELPER_IMPLBASE1_HXX_
+ #include <cppuhelper/implbase1.hxx>	// helper for implementations
+ #endif
  #ifndef _CPPUHELPER_IMPLBASE3_HXX_
  #include <cppuhelper/implbase3.hxx>	// helper for implementations
  #endif
***************
*** 184,189 ****
--- 184,192 ----
  #ifndef _CPPUHELPER_WEAKREF_HXX_
  #include <cppuhelper/weakref.hxx>
  #endif
+ #ifndef _COM_SUN_STAR_TEXT_XFORMFIELD_HPP_ 
+ #include <com/sun/star/text/XFormField.hpp> 
+ #endif 
  
  #include <unomid.h>
  
***************
*** 191,196 ****
--- 194,203 ----
  #include <tools/link.hxx>
  #endif
  
+ #ifndef IDOCUMENTBOOKMARKACCESS_HXX_INCLUDED 
+ #include <IDocumentBookmarkAccess.hxx> 
+ #endif 
+ 
  class SwUnoCrsr;
  class SwCursor;
  class SwBookmark;
***************
*** 680,685 ****
--- 689,695 ----
  class SwXBookmark : public SwRefBookmarkBaseClass,
  	public SwClient
  {
+ protected:
  	SwEventListenerContainer	aLstnrCntnr;
  	SwDoc*						pDoc;
  	String 						m_aName;
***************
*** 723,729 ****
      virtual void SAL_CALL addVetoableChangeListener( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XVetoableChangeListener >& aListener ) throw(::com::sun::star::beans::UnknownPropertyException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException);
      virtual void SAL_CALL removeVetoableChangeListener( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XVetoableChangeListener >& aListener ) throw(::com::sun::star::beans::UnknownPropertyException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException);
  
! 	void attachToRange(const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > & xTextRange)throw( ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException );
  
  	//SwClient
  	virtual void 	Modify( SfxPoolItem *pOld, SfxPoolItem *pNew);
--- 733,740 ----
      virtual void SAL_CALL addVetoableChangeListener( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XVetoableChangeListener >& aListener ) throw(::com::sun::star::beans::UnknownPropertyException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException);
      virtual void SAL_CALL removeVetoableChangeListener( const ::rtl::OUString& PropertyName, const ::com::sun::star::uno::Reference< ::com::sun::star::beans::XVetoableChangeListener >& aListener ) throw(::com::sun::star::beans::UnknownPropertyException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException);
  
! 	void attachToRangeEx(const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > & xTextRange, IDocumentBookmarkAccess::BookmarkType eMark)throw( ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException );
! 	virtual void attachToRange(const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > & xTextRange)throw( ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException );
  
  	//SwClient
  	virtual void 	Modify( SfxPoolItem *pOld, SfxPoolItem *pNew);
***************
*** 732,737 ****
--- 743,770 ----
  	SwDoc*			GetDoc(){return pDoc;}
  };
  
+ typedef cppu::ImplInheritanceHelper1< SwXBookmark, ::com::sun::star::text::XFormField > SwXFieldmark_BASE;
+ 
+ class SwXFieldmark : public SwXFieldmark_BASE 
+ {
+ private:
+ 	bool isReplacementObject;
+ public:
+ 	SwXFieldmark(bool isReplacementObject, SwBookmark* pBkm = 0, SwDoc* pDoc = 0);
+ 
+ 	virtual void attachToRange(const ::com::sun::star::uno::Reference< ::com::sun::star::text::XTextRange > & xTextRange)throw( ::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::uno::RuntimeException );
+ 	virtual ::rtl::OUString SAL_CALL getDescription(void)  throw( ::com::sun::star::uno::RuntimeException );
+     virtual ::sal_Int16 SAL_CALL getType(  ) throw (::com::sun::star::uno::RuntimeException);
+     virtual ::sal_Int16 SAL_CALL getRes(  ) throw (::com::sun::star::uno::RuntimeException);
+ 
+     virtual void SAL_CALL setType( ::sal_Int16 fieldType ) throw (::com::sun::star::uno::RuntimeException);
+     virtual void SAL_CALL setRes( ::sal_Int16 res ) throw (::com::sun::star::uno::RuntimeException);
+     virtual void SAL_CALL setDescription( const ::rtl::OUString& description ) throw (::com::sun::star::uno::RuntimeException);
+ 
+ //    virtual ::com::sun::star::uno::Any SAL_CALL queryInterface( ::com::sun::star::uno::Type const & rType ) throw (::com::sun::star::uno::RuntimeException);
+ 
+ };
+ 
  /*-----------------23.02.98 10:45-------------------
  
  --------------------------------------------------*/
Index: sw/inc/unoport.hxx
===================================================================
RCS file: /cvs/sw/sw/inc/unoport.hxx,v
retrieving revision 1.18
diff -c -r1.18 unoport.hxx
*** sw/inc/unoport.hxx	6 Jul 2007 12:16:27 -0000	1.18
--- sw/inc/unoport.hxx	21 Jan 2008 08:32:26 -0000
***************
*** 107,113 ****
  	PORTION_REDLINE_END,
  	PORTION_RUBY_START,
  	PORTION_RUBY_END,
!     PORTION_SOFT_PAGEBREAK
  };
  
  class SwXRubyPortion;
--- 107,116 ----
  	PORTION_REDLINE_END,
  	PORTION_RUBY_START,
  	PORTION_RUBY_END,
!     PORTION_SOFT_PAGEBREAK,
! 	PORTION_FIELD_START,
! 	PORTION_FIELD_END,
! 	PORTION_FIELD_START_END
  };
  
  class SwXRubyPortion;
Index: sw/source/core/crsr/crbm.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/crsr/crbm.cxx,v
retrieving revision 1.5
diff -c -r1.5 crbm.cxx
*** sw/source/core/crsr/crbm.cxx	16 Sep 2006 20:44:51 -0000	1.5
--- sw/source/core/crsr/crbm.cxx	21 Jan 2008 08:32:26 -0000
***************
*** 47,52 ****
--- 47,53 ----
  #include "callnk.hxx"
  #include "swcrsr.hxx"
  #include <IDocumentBookmarkAccess.hxx>
+ #include <IDocumentSettingAccess.hxx>
  
  /*
   * Methoden der SwCrsrShell fuer Bookmark
***************
*** 154,159 ****
--- 155,219 ----
  	return TRUE;
  }
  
+ bool SwCrsrShell::IsFormProtected() {
+     return getIDocumentSettingAccess()->get(IDocumentSettingAccess::PROTECT_FORM);
+ }
+ 
+ SwBookmark* SwCrsrShell::IsInFieldBookmark() {
+ // Refactor
+     SwPosition pos(*GetCrsr()->GetPoint());
+     return getIDocumentBookmarkAccess()->getFieldBookmarkFor(pos);
+ }
+ 
+ SwFieldBookmark* SwCrsrShell::IsInFormFieldBookmark() {
+ // Refactor
+     SwPosition pos(*GetCrsr()->GetPoint());
+     return (SwFieldBookmark*)getIDocumentBookmarkAccess()->getFormFieldBookmarkFor(pos);
+ }
+ 
+ SwBookmark* SwCrsrShell::GetNextFieldBookmark() {
+     SwPosition pos(*GetCrsr()->GetPoint());
+     return getIDocumentBookmarkAccess()->getNextFieldBookmarkFor(pos);
+ }
+ 
+ SwBookmark* SwCrsrShell::GetPrevFieldBookmark() {
+     SwPosition pos(*GetCrsr()->GetPoint());
+     return getIDocumentBookmarkAccess()->getPrevFieldBookmarkFor(pos);
+ }
+ 
+ bool SwCrsrShell::GotoFieldBookmark(SwBookmark *pBkmk) 
+ {
+         if(pBkmk==NULL)
+ 	    return false;
+ 	// Crsr-Moves ueberwachen, evt. Link callen
+ 	bool bRet = true;
+ 	SwCallLink aLk( *this );
+ 	SwCursor* pCrsr = GetSwCrsr();
+ 	SwCrsrSaveState aSaveState( *pCrsr );
+ 	
+ 	*pCrsr->GetPoint() = pBkmk->GetPos();
+ 	if( pBkmk->GetOtherPos() )
+ 	{
+ 		pCrsr->SetMark();
+ 		*pCrsr->GetMark() = *pBkmk->GetOtherPos();
+ 		if( *pCrsr->GetMark() > *pCrsr->GetPoint() )
+ 			pCrsr->Exchange();
+ 	}
+ 	pCrsr->GetPoint()->nContent--;
+ 	pCrsr->GetMark()->nContent++;
+ 
+ 
+ 	if( pCrsr->IsSelOvr( SELOVER_CHECKNODESSECTION | SELOVER_TOGGLE ) )
+ 	{
+ 		pCrsr->DeleteMark();
+ 		pCrsr->RestoreSavePos();
+ 		bRet = false;
+ 	}
+ 	else
+ 	    UpdateCrsr(SwCrsrShell::SCROLLWIN|SwCrsrShell::CHKRANGE|SwCrsrShell::READONLY);
+ 
+ 	return bRet;
+ }
  
  FASTBOOL SwCrsrShell::GoPrevBookmark()
  {
Index: sw/source/core/crsr/pam.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/crsr/pam.cxx,v
retrieving revision 1.19
diff -c -r1.19 pam.cxx
*** sw/source/core/crsr/pam.cxx	16 Sep 2006 20:46:49 -0000	1.19
--- sw/source/core/crsr/pam.cxx	21 Jan 2008 08:32:27 -0000
***************
*** 101,106 ****
--- 101,110 ----
  #include <ndtxt.hxx> // #111827#
  #endif
  
+ #ifndef _BOOKMRK_HXX
+ #include <bookmrk.hxx>
+ #endif
+ 
  // fuer den dummen ?MSC-? Compiler
  inline xub_StrLen GetSttOrEnd( BOOL bCondition, const SwCntntNode& rNd )
  {
***************
*** 811,816 ****
--- 815,843 ----
  			}
  		}
  	}
+ 	if (!bRet) {
+ 	    const SwDoc *pDoc=GetDoc();
+ 	    SwBookmark *pA=(pDoc&&pPoint?pDoc->getFieldBookmarkFor(*pPoint):NULL);
+ 	    /* debugging stuff, will remove later
+ 	    if (pA) {
+ 		rtl::OUString s(pA->GetName());
+ 		rtl::OString aOString = ::rtl::OUStringToOString (s, RTL_TEXTENCODING_UTF8);
+ 		printf("IN BOOKMARK(A): %s\n", aOString.getStr());
+ 	    }
+ 	    */
+ 	    SwBookmark *pB=(pDoc&&pMark?pDoc->getFieldBookmarkFor(*pMark):pA);
+             /* debugging stuff, will remove later
+ 	    if (pB) {
+ 		rtl::OUString s(pB->GetName());
+ 		rtl::OString aOString = ::rtl::OUStringToOString (s, RTL_TEXTENCODING_UTF8);
+ 		printf("IN BOOKMARK(B): %s\n", aOString.getStr());
+ 	    }
+ 	    */
+ 	    bRet = (pA!=pB);
+ 	    bool bProtectForm=pDoc->get(IDocumentSettingAccess::PROTECT_FORM );
+ 	    if (bProtectForm)
+ 		bRet|=(pA==NULL || pB==NULL);
+ 	}
  	return bRet;
  }
  
Index: sw/source/core/doc/doc.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/doc/doc.cxx,v
retrieving revision 1.59
diff -c -r1.59 doc.cxx
*** sw/source/core/doc/doc.cxx	3 Aug 2007 10:59:51 -0000	1.59
--- sw/source/core/doc/doc.cxx	21 Jan 2008 08:32:27 -0000
***************
*** 300,305 ****
--- 300,306 ----
          case UNIX_FORCE_ZERO_EXT_LEADING: return mbUnixForceZeroExtLeading;
          case USE_OLD_PRINTER_METRICS: return mbOldPrinterMetrics;
          case TABS_RELATIVE_TO_INDENT : return mbTabRelativeToIndent;
+         case PROTECT_FORM: return mbProtectForm;
           // COMPATIBILITY FLAGS END
  
          case BROWSE_MODE: return mbBrowseMode;
***************
*** 410,415 ****
--- 411,419 ----
          case USE_OLD_PRINTER_METRICS:            
              mbOldPrinterMetrics = value;
              break;
+ 	case PROTECT_FORM:
+ 	    mbProtectForm = value;
+ 	    break;
  
           // COMPATIBILITY FLAGS END
  
Index: sw/source/core/doc/docbm.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/doc/docbm.cxx,v
retrieving revision 1.20
diff -c -r1.20 docbm.cxx
*** sw/source/core/doc/docbm.cxx	16 Sep 2006 20:50:01 -0000	1.20
--- sw/source/core/doc/docbm.cxx	21 Jan 2008 08:32:27 -0000
***************
*** 100,106 ****
--- 100,112 ----
  #ifndef _NDTXT_HXX
  #include "ndtxt.hxx" // for lcl_FixPosition
  #endif
+ #ifndef _SWUNDO_HXX
+ #include "swundo.hxx"
+ #endif
+ 
+ #include "hintids.hxx"
  
+ static bool _checkFieldBookmarkSanity(const SwDoc *pDoc);
  
  SV_IMPL_OP_PTRARR_SORT(SwBookmarks, SwBookmarkPtr)
  
***************
*** 156,162 ****
                                   /*[in]*/IDocumentBookmarkAccess::BookmarkType eMark )
  {
  	SwBookmark *pBM;
! 	if( MARK == eMark )
  		pBM = new SwMark( *rPaM.GetPoint(), rCode, rName, rShortName );
  	else if( BOOKMARK == eMark || HIDDEN_BOOKMARK == eMark)
  	{
--- 162,184 ----
                                   /*[in]*/IDocumentBookmarkAccess::BookmarkType eMark )
  {
  	SwBookmark *pBM;
! 	if (FORM_FIELDMARK_TEXT == eMark || FORM_FIELDMARK_NO_TEXT == eMark /* rName.CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))==0 */) {
! 	    pBM = new SwFieldBookmark(*rPaM.GetPoint(), rCode, rName, rShortName, eMark);
! 	    if( rPaM.HasMark() )
! 		pBM->pPos2 = new SwPosition( *rPaM.GetMark() );
! 	    else
! 		pBM->pPos2 = new SwPosition( *pBM->pPos1 );
! 
! 	    lcl_FixPosition( *pBM->pPos1 );
! 	    lcl_FixPosition( *pBM->pPos2 );
! 	    if (*pBM->pPos2<*pBM->pPos1) {
! 		SwPosition *_pos=pBM->pPos1;
! 		pBM->pPos1=pBM->pPos2;
! 		pBM->pPos2=_pos;
! 	    }
! 	    ASSERT(*PBM->pPos1<=*pBM->pPos2, "");
! 	}
! 	else if( MARK == eMark )
  		pBM = new SwMark( *rPaM.GetPoint(), rCode, rName, rShortName );
  	else if( BOOKMARK == eMark || HIDDEN_BOOKMARK == eMark)
  	{
***************
*** 171,180 ****
  			pBM->pPos2 = new SwPosition( *rPaM.GetMark() );
  	}
  
!     // fix bookmark positions if they are invalid
!     lcl_FixPosition( *pBM->pPos1 );
!     if( pBM->pPos2 != NULL )
!         lcl_FixPosition( *pBM->pPos2 );
  
  	if( !pBookmarkTbl->Insert( pBM ) )
  		delete pBM, pBM = 0;
--- 193,227 ----
  			pBM->pPos2 = new SwPosition( *rPaM.GetMark() );
  	}
  
! 	if (FORM_FIELDMARK_TEXT == eMark || FORM_FIELDMARK_NO_TEXT == eMark /* pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))==0 */) {
! 	    StartUndo(UIUNDO_REPLACE, NULL);
! 	    ASSERT(*PBM->pPos1<=*pBM->pPos2, "Bookmark positions not normalized!!!!");
! 	    const SwTxtNode* pStartTxtNode=this->GetNodes()[pBM->GetPos().nNode]->GetTxtNode();
! 	    const SwTxtNode* pEndTxtNode=this->GetNodes()[pBM->GetOtherPos()->nNode]->GetTxtNode();
! 	    sal_Unicode ch_start=pStartTxtNode->GetTxt().GetChar(pBM->GetPos().nContent.GetIndex());
! 	    sal_Unicode ch_end=pEndTxtNode->GetTxt().GetChar(pBM->GetOtherPos()->nContent.GetIndex()-1);
! 	    bool form=(IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT==eMark);  /*(pBM->GetName().CompareToAscii(FIELD_FORM_BOOKMARK_PREFIX, strlen(FIELD_FORM_BOOKMARK_PREFIX))==0);*/
! 	    if (form) {
! 		if (ch_start!=CH_TXT_ATR_FORMELEMENT) {
! 			const SwPaM rRg(*pBM->pPos1);
! 		    Insert(rRg, CH_TXT_ATR_FORMELEMENT);
! 		    pBM->pPos1->nContent--;
! 		}
! 	    } else {
! 		if (ch_start!=CH_TXT_ATR_FIELDSTART) {
! 		    Insert(*pBM->pPos1, CH_TXT_ATR_FIELDSTART);
! 		    pBM->pPos1->nContent--;
! 		}
! 		if (ch_end!=CH_TXT_ATR_FIELDEND) {
! 		    Insert(*pBM->pPos2, CH_TXT_ATR_FIELDEND);
! 		}
! 	    }
! 	} else {
! 	    // fix bookmark positions if they are invalid
! 	    lcl_FixPosition( *pBM->pPos1 );
! 	    if( pBM->pPos2 != NULL )
! 		lcl_FixPosition( *pBM->pPos2 );
! 	}
  
  	if( !pBookmarkTbl->Insert( pBM ) )
  		delete pBM, pBM = 0;
***************
*** 194,200 ****
--- 241,350 ----
  			    SetModified();
  	    }
  	}
+ 	if (FORM_FIELDMARK_TEXT == eMark || FORM_FIELDMARK_NO_TEXT == eMark /*pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))==0*/) {
+ 	    EndUndo(UIUNDO_REPLACE, NULL);
+ 	}
+ 	return pBM;
+ }
+ 
+ SwBookmark* SwDoc::getFieldBookmarkFor(const SwPosition &pos) const {
+ //@TODO make impl recursive
+     int nCount=pBookmarkTbl->Count();
+     while(--nCount>=0) {
+ 	SwBookmark *pBM=(*pBookmarkTbl)[nCount];
+ 	if (pBM->GetOtherPos()!=NULL 
+ 	    && FORM_FIELDMARK_TEXT==pBM->GetType() /* pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))==0 */
+ 	    && pBM->GetPos()<pos 
+ 	    && pos < *(pBM->GetOtherPos())) {
+ 	    return pBM;
+ 	}
+     }
+     return NULL;
+ }
+ 
+ SwFieldBookmark* SwDoc::getFormFieldBookmarkFor(const SwPosition &pos) const {
+ //@TODO make impl recursive
+     int nCount=pBookmarkTbl->Count();
+     while(--nCount>=0) {
+ 	SwBookmark *pBM=(*pBookmarkTbl)[nCount];
+ 	if (pBM->GetOtherPos()!=NULL 
+ 	    && FORM_FIELDMARK_NO_TEXT==pBM->GetType() /* pBM->GetName().CompareToAscii(FIELD_FORM_BOOKMARK_PREFIX, strlen(FIELD_FORM_BOOKMARK_PREFIX))==0 */
+ 	    && pBM->GetPos()<=pos 
+ 	    && pos <= *(pBM->GetOtherPos())) {
+ 	    return (SwFieldBookmark*)pBM;
+ 	}
+     }
+     return NULL;
+ }
+ 
+ SwBookmark* SwDoc::getNextFieldBookmarkFor(const SwPosition &pos) const {
+     int i=0;
+     int nCount=pBookmarkTbl->Count();
+     SwBookmark *pBM=NULL;
+     while(i<nCount
+ 	  && ((pBM=(*pBookmarkTbl)[i])==NULL
+ 	  || !pBM->IsFormFieldMark() /* pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))!=0 */
+ 	  || pos >= pBM->GetPos() )) i++;
+ 
+     if (i<nCount) {
+ 	return pBM;
+     } else {
+ 	i=0; 
+ 	while(i<nCount && (
+ 	     (pBM=(*pBookmarkTbl)[i])==NULL
+ 	     ||  !pBM->IsFormFieldMark() /*pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))!=0*/ )) i++;
+ 	return (i<nCount?pBM:NULL);
+     }
+ }
+ 
+ SwBookmark* SwDoc::getPrevFieldBookmarkFor(const SwPosition &pos) const {
+     int nCount=pBookmarkTbl->Count();
+     int i=nCount-1;
+     SwBookmark *pBM=NULL;
+     while(i>=0
+ 	  && ((pBM=(*pBookmarkTbl)[i])==NULL
+ 	  || !pBM->IsFormFieldMark() /*pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))!=0*/
+ 	  || pBM->GetOtherPos()==NULL
+ 	  || pos <= *pBM->GetOtherPos() )) i--;
+ 
+     if (i>=0) {
  	return pBM;
+     } else {
+ 	i=nCount-1; 
+ 	while(i>=0 && (
+ 	     (pBM=(*pBookmarkTbl)[i])==NULL
+ 	     ||  !pBM->IsFormFieldMark() /*pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))!=0*/ )) i--;
+ 	return (i>=0?pBM:NULL);
+     }
+ }
+ 
+ /*
+ bool SwDoc::isValidSelectionWrtFieldBookmarks(const SwPosition &posA, const SwPostion &posB) {
+ //@TODO optimize this
+     SwBookmark *pA=getFieldBookmarkFor(posA);
+     SwBookmark *pB=getFieldBookmarkFor(posB);
+     return pA==pB;    
+ }
+ */
+ 
+ // not finished yet, still neet to add this check
+ bool _checkFieldBookmarkSanity(const SwDoc *pDoc) {
+     int nCount=pDoc->getBookmarks().Count();
+     while(--nCount>=0) {
+ 	SwBookmark *pBM=pDoc->getBookmarks()[nCount];
+ 	if (pBM->IsFormFieldMark() /* pBM->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))==0 */) {
+ 	    {
+ 		rtl::OUString s(pBM->GetName());
+ 		rtl::OString aOString = ::rtl::OUStringToOString (s, RTL_TEXTENCODING_UTF8);
+ 		const SwTxtNode* pStartTxtNode=pDoc->GetNodes()[pBM->GetPos().nNode]->GetTxtNode();
+ 		const SwTxtNode* pEndTxtNode=pDoc->GetNodes()[pBM->GetOtherPos()->nNode]->GetTxtNode();
+ 		sal_Unicode ch_start=pStartTxtNode->GetTxt().GetChar(pBM->GetPos().nContent.GetIndex());
+ 		sal_Unicode ch_end=pEndTxtNode->GetTxt().GetChar(pBM->GetOtherPos()->nContent.GetIndex()-1);
+ 		printf("CHECK(%s %p[%i/'%c'] %p[%i/'%c']);\n", aOString.getStr(), pStartTxtNode, ch_start, ch_start, pEndTxtNode, ch_end, ch_end);
+ 	    }	    
+ 	}
+     }
+     return true;
  }
  
  void SwDoc::deleteBookmark( /*[in]*/sal_uInt16 nPos )
***************
*** 701,707 ****
  		}
  
  		if( pBkmk->GetOtherPos() && pBkmk->GetOtherPos()->nNode.GetIndex() ==
! 			nNode && pBkmk->GetOtherPos()->nContent.GetIndex() < nCntnt )
  		{
  			aSave.SetContent( pBkmk->GetOtherPos()->nContent.GetIndex() );
  			aSave.IncType();
--- 851,857 ----
  		}
  
  		if( pBkmk->GetOtherPos() && pBkmk->GetOtherPos()->nNode.GetIndex() ==
! 			nNode && pBkmk->GetOtherPos()->nContent.GetIndex() <= nCntnt )
  		{
  			aSave.SetContent( pBkmk->GetOtherPos()->nContent.GetIndex() );
  			aSave.IncType();
***************
*** 1165,1167 ****
--- 1315,1355 ----
  }
  
  
+ SwFieldBookmark::SwFieldBookmark(const SwPosition& aPos,
+ 		const KeyCode& rCode,
+ 		const String& rName, const String& rShortName,
+ 		IDocumentBookmarkAccess::BookmarkType eMark)
+     : SwBookmark(aPos, rCode, rName, rShortName),
+ 		fftype(0), // Type: 0 = Text, 1 = Check Box, 2 = List
+ 		ffres(0),
+ 		ffprot(0),
+ 		ffsize(0), // 0 = Auto, 1=Exact (see ffhps)
+ 		fftypetxt(0), // Type of text field: 0 = Regular text, 1 = Number, 2 = Date, 3 = Current date, 4 = Current time, 5 = Calculation
+ 		ffrecalc(0), 
+ 		ffmaxlen(0), // Number of characters for text field. Zero means unlimited.
+ 		ffhps(24) // Check box size (half-point sizes).
+ {
+ 	eMarkType = eMark;
+ }
+ 
+ void SwFieldBookmark::SetChecked(bool checked)
+ {
+ 	ASSERT(fftype==1, "This method is for checkboxes only...");
+ 	ffres=(checked?1:0);
+ }
+ 
+ bool SwFieldBookmark::IsChecked()
+ {
+ 	ASSERT(fftype==1, "This method is for checkboxes only...");
+ 	return ffres!=0;
+ }
+ 
+ void SwFieldBookmark::SetType(int fftype)
+ {
+ 	this->fftype=fftype;
+ }
+ 
+ int SwFieldBookmark::GetType()
+ {
+ 	return fftype;
+ }
Index: sw/source/core/doc/docedt.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/doc/docedt.cxx,v
retrieving revision 1.35
diff -c -r1.35 docedt.cxx
*** sw/source/core/doc/docedt.cxx	25 May 2007 13:00:52 -0000	1.35
--- sw/source/core/doc/docedt.cxx	21 Jan 2008 08:32:29 -0000
***************
*** 903,908 ****
--- 903,914 ----
  |*	  Beschreibung		Zeichen ueberschreiben
  *************************************************************************/
  
+ void SwDoc::SetModified(SwPaM &rPaM)
+ {
+     SwDataChanged aTmp( rPaM, 0 );
+     SetModified();
+ }
+ 
  bool SwDoc::Overwrite( const SwPaM &rRg, sal_Unicode c )
  {
  	SwPosition& rPt = *(SwPosition*)rRg.GetPoint();
Index: sw/source/core/doc/docnew.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/doc/docnew.cxx,v
retrieving revision 1.77
diff -c -r1.77 docnew.cxx
*** sw/source/core/doc/docnew.cxx	18 Jul 2007 13:29:46 -0000	1.77
--- sw/source/core/doc/docnew.cxx	21 Jan 2008 08:32:30 -0000
***************
*** 419,424 ****
--- 419,425 ----
      mbUnixForceZeroExtLeading               = false;        // hidden
      mbOldPrinterMetrics                     = false;        // hidden
      mbTabRelativeToIndent                   = true;         // hidden
+     mbProtectForm                           = false;        // hidden
  
      //
      // COMPATIBILITY FLAGS END
Index: sw/source/core/layout/trvlfrm.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/layout/trvlfrm.cxx,v
retrieving revision 1.55
diff -c -r1.55 trvlfrm.cxx
*** sw/source/core/layout/trvlfrm.cxx	26 Apr 2007 09:39:16 -0000	1.55
--- sw/source/core/layout/trvlfrm.cxx	21 Jan 2008 08:32:35 -0000
***************
*** 1670,1675 ****
--- 1670,1682 ----
  |*************************************************************************/
  BOOL SwFrm::IsProtected() const
  {
+ 	if (this->IsCntntFrm() && ((SwCntntFrm*)this)->GetNode()) {
+ 		const SwDoc *pDoc=((SwCntntFrm*)this)->GetNode()->GetDoc();
+ 		bool isFormProtected=pDoc->get(IDocumentSettingAccess::PROTECT_FORM );
+ 		if (isFormProtected) {
+ 			return FALSE; // a hack for now, well deal with it laster, I we return true here we have a "double" locking 
+ 		}
+ 	}
  	//Der Frm kann in Rahmen, Zellen oder Bereichen geschuetzt sein.
  	//Geht auch FlyFrms rekursiv hoch. Geht auch von Fussnoten zum Anker.
  	const SwFrm *pFrm = this;
Index: sw/source/core/text/inftxt.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/inftxt.cxx,v
retrieving revision 1.110
diff -c -r1.110 inftxt.cxx
*** sw/source/core/text/inftxt.cxx	27 Jun 2007 13:19:34 -0000	1.110
--- sw/source/core/text/inftxt.cxx	21 Jan 2008 08:32:36 -0000
***************
*** 157,162 ****
--- 157,165 ----
  #endif
  // <--
  
+ #include <doc.hxx>
+ #include <pam.hxx>
+ 
  using namespace ::com::sun::star;
  using namespace ::com::sun::star::linguistic2;
  using namespace ::com::sun::star::uno;
***************
*** 1188,1193 ****
--- 1191,1229 ----
  {
  	ASSERT( pFnt->GetBackColor(), "DrawBackBrush: Lost Color" );
  
+     {
+ 	SwRect aIntersect;
+ 	CalcRect( rPor, &aIntersect, 0 );
+ 	SwTxtNode *pNd = pFrm->GetTxtNode();
+ 	SwBookmark *pBM=NULL;	
+ 	if ( aIntersect.HasArea() )
+ 	{
+ 	    if (pNd) {
+ 		const SwDoc *doc=pNd->GetDoc();
+ 		if (doc!=NULL) {
+ 		    SwIndex aIndex( pNd, GetIdx() );
+ 		    SwPosition aPosition(*pNd, aIndex);
+ 		    pBM=doc->getFieldBookmarkFor(aPosition);
+ 		}
+ 	    }
+ 	    bool bIsStartMark=(1==GetLen() && CH_TXT_ATR_FIELDSTART==GetTxt().GetChar(GetIdx()));
+ 	    if (OnWin() && (pBM!=NULL || bIsStartMark)) {
+ 		OutputDevice* pOut = (OutputDevice*)GetOut();
+ 		pOut->Push( PUSH_LINECOLOR | PUSH_FILLCOLOR );
+ 		pOut->SetLineColor( Color(220, 233, 245));
+ 		pOut->SetFillColor( Color(220, 233, 245));
+ 		pOut->DrawRect( aIntersect.SVRect() );
+ 		pOut->Pop();
+ 	    }
+ 	}
+ 
+     }
+ 
+ 
+ 
+     if( !pFnt->GetBackColor() )
+ 	return;
+ 
      SwRect aIntersect;
      CalcRect( rPor, 0, &aIntersect );
  
***************
*** 1210,1215 ****
--- 1246,1279 ----
      }
  }
  
+ 
+ void SwTxtPaintInfo::DrawCheckBox( const SwFieldFormPortion &rPor, bool checked) const
+ {
+     SwRect aIntersect;
+     CalcRect( rPor, &aIntersect, 0 );
+     if ( aIntersect.HasArea() ) {
+ 	if (OnWin()) {
+ 	    OutputDevice* pOut = (OutputDevice*)GetOut();
+ 	    pOut->Push( PUSH_LINECOLOR | PUSH_FILLCOLOR );
+ 	    pOut->SetLineColor( Color(220, 233, 245));
+ 	    pOut->SetFillColor( Color(220, 233, 245));
+ 	    pOut->DrawRect( aIntersect.SVRect() );
+ 	    pOut->Pop();
+ 	}
+ 	const int delta=10;
+ 	Rectangle r(aIntersect.Left()+delta, aIntersect.Top()+delta, aIntersect.Right()-delta, aIntersect.Bottom()-delta);
+ 	pOut->Push( PUSH_LINECOLOR | PUSH_FILLCOLOR );	    
+ 	pOut->SetLineColor( Color(0, 0, 0));
+ 	pOut->SetFillColor();
+ 	pOut->DrawRect( r );
+ 	if (checked) {
+ 	    pOut->DrawLine(r.TopLeft(), r.BottomRight());
+ 	    pOut->DrawLine(r.TopRight(), r.BottomLeft());
+ 	    pOut->Pop();
+ 	}
+     }
+ }
+ 
  /*************************************************************************
   *					   SwTxtPaintInfo::DrawViewOpt()
   *************************************************************************/
***************
*** 1247,1253 ****
  				break;
  			}
  		}
! 		if ( bDraw )
  			DrawBackground( rPor );
  	}
  }
--- 1311,1317 ----
  				break;
  			}
  		}
! //		if ( bDraw )
  			DrawBackground( rPor );
  	}
  }
Index: sw/source/core/text/inftxt.hxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/inftxt.hxx,v
retrieving revision 1.53
diff -c -r1.53 inftxt.hxx
*** sw/source/core/text/inftxt.hxx	29 Jan 2007 16:56:15 -0000	1.53
--- sw/source/core/text/inftxt.hxx	21 Jan 2008 08:32:36 -0000
***************
*** 456,462 ****
  	void DrawBackground( const SwLinePortion &rPor ) const;
  	void DrawViewOpt( const SwLinePortion &rPor, const MSHORT nWhich ) const;
  	inline void DrawBackBrush( const SwLinePortion &rPor ) const
! 		{ if( pFnt->GetBackColor() ) _DrawBackBrush( rPor ); }
  
  	inline void NotifyURL( const SwLinePortion &rPor ) const
  		{ if( URLNotify() ) _NotifyURL( rPor ); }
--- 456,464 ----
  	void DrawBackground( const SwLinePortion &rPor ) const;
  	void DrawViewOpt( const SwLinePortion &rPor, const MSHORT nWhich ) const;
  	inline void DrawBackBrush( const SwLinePortion &rPor ) const
! 	{ /*if( pFnt->GetBackColor() )*/ _DrawBackBrush( rPor ); }
! 
!         void DrawCheckBox( const SwFieldFormPortion &rPor, bool checked) const;
  
  	inline void NotifyURL( const SwLinePortion &rPor ) const
  		{ if( URLNotify() ) _NotifyURL( rPor ); }
Index: sw/source/core/text/itratr.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/itratr.cxx,v
retrieving revision 1.37
diff -c -r1.37 itratr.cxx
*** sw/source/core/text/itratr.cxx	10 May 2007 16:01:48 -0000	1.37
--- sw/source/core/text/itratr.cxx	21 Jan 2008 08:32:36 -0000
***************
*** 417,422 ****
--- 417,433 ----
  			if ( nNextEnd<nNext ) nNext = nNextEnd; // Wer ist naeher?
  		}
  	}
+ 	if (m_pTxtNode!=NULL) {
+ 	    //TODO maybe use hints like FieldHints for this instead of looking at the text...
+ 	    int l=(nNext<m_pTxtNode->Len()?nNext:m_pTxtNode->Len());
+ 	    int p=nPos;
+ 	    const sal_Unicode *txt=m_pTxtNode->GetTxt().GetBuffer();
+ 	    while(p<l && txt[p]!=CH_TXT_ATR_FIELDSTART && txt[p]!=CH_TXT_ATR_FIELDEND && txt[p]!=CH_TXT_ATR_FORMELEMENT) p++;
+ 	    if ((p<l && p>nPos) || nNext<=p)
+ 		nNext=p;
+ 	    else
+ 		nNext=p+1;
+ 	}	
      if( pRedln )
  		return pRedln->GetNextRedln( nNext );
  	return nNext;
Index: sw/source/core/text/itratr.hxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/itratr.hxx,v
retrieving revision 1.18
diff -c -r1.18 itratr.hxx
*** sw/source/core/text/itratr.hxx	14 Aug 2006 16:38:20 -0000	1.18
--- sw/source/core/text/itratr.hxx	21 Jan 2008 08:32:36 -0000
***************
*** 82,99 ****
  	inline void SetFnt( SwFont* pNew ) { pFnt = pNew; }
  	const void* aMagicNo[ SW_SCRIPTS ];
  	MSHORT aFntIdx[ SW_SCRIPTS ];
  
  protected:
  	void Chg( SwTxtAttr *pHt );
  	void Rst( SwTxtAttr *pHt );
      void CtorInitAttrIter( SwTxtNode& rTxtNode, SwScriptInfo& rScrInf, SwTxtFrm* pFrm = 0 );
!     inline SwAttrIter()
! 		: pShell(0), pFnt(0), pLastOut(0),	nChgCnt(0), pRedln(0), nPropFont(0) {}
  
  public:
  	// Konstruktor, Destruktor
      inline SwAttrIter( SwTxtNode& rTxtNode, SwScriptInfo& rScrInf )
! 		: pShell(0), pFnt(0), pHints(0), pScriptInfo(0), pLastOut(0), nChgCnt(0), pRedln(0),nPropFont(0)
          { CtorInitAttrIter( rTxtNode, rScrInf ); }
  
  	virtual ~SwAttrIter();
--- 82,100 ----
  	inline void SetFnt( SwFont* pNew ) { pFnt = pNew; }
  	const void* aMagicNo[ SW_SCRIPTS ];
  	MSHORT aFntIdx[ SW_SCRIPTS ];
+ 	const SwTxtNode* m_pTxtNode;
  
  protected:
  	void Chg( SwTxtAttr *pHt );
  	void Rst( SwTxtAttr *pHt );
      void CtorInitAttrIter( SwTxtNode& rTxtNode, SwScriptInfo& rScrInf, SwTxtFrm* pFrm = 0 );
!     inline SwAttrIter(SwTxtNode* pTxtNode) 
! 		: pShell(0), pFnt(0), pLastOut(0),	nChgCnt(0), pRedln(0), nPropFont(0), m_pTxtNode(pTxtNode) {}
  
  public:
  	// Konstruktor, Destruktor
      inline SwAttrIter( SwTxtNode& rTxtNode, SwScriptInfo& rScrInf )
! 		: pShell(0), pFnt(0), pHints(0), pScriptInfo(0), pLastOut(0), nChgCnt(0), pRedln(0),nPropFont(0), m_pTxtNode(&rTxtNode)
          { CtorInitAttrIter( rTxtNode, rScrInf ); }
  
  	virtual ~SwAttrIter();
Index: sw/source/core/text/itrform2.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/itrform2.cxx,v
retrieving revision 1.99
diff -c -r1.99 itrform2.cxx
*** sw/source/core/text/itrform2.cxx	23 Jan 2007 08:31:48 -0000	1.99
--- sw/source/core/text/itrform2.cxx	21 Jan 2008 08:32:36 -0000
***************
*** 893,906 ****
  			// Erst zum Schluss !
  			// Wenn pCurr keine Breite hat, kann sie trotzdem schon Inhalt haben,
  			// z.B. bei nicht darstellbaren Zeichen.
  			if( !rInf.X() && !pCurr->GetPortion() && !pCurr->GetLen() &&
! 				!GetFnt()->IsURL() )
! 				pPor = pCurr;
! 			else
  			{
  				pPor = new SwTxtPortion;
! 				if( GetFnt()->IsURL() )
! 					pPor->SetWhichPor( POR_URL );
  			}
  		}
  	}
--- 893,915 ----
  			// Erst zum Schluss !
  			// Wenn pCurr keine Breite hat, kann sie trotzdem schon Inhalt haben,
  			// z.B. bei nicht darstellbaren Zeichen.
+ if (rInf.GetLen()>0 && rInf.GetTxt().GetChar(rInf.GetIdx())==CH_TXT_ATR_FIELDSTART) {
+ 				pPor = new SwFieldMarkPortion();
+ 			    } else if (rInf.GetLen()>0 && rInf.GetTxt().GetChar(rInf.GetIdx())==CH_TXT_ATR_FIELDEND) {
+ 				pPor = new SwFieldMarkPortion();
+ 			    } else if (rInf.GetLen()>0 && rInf.GetTxt().GetChar(rInf.GetIdx())==CH_TXT_ATR_FORMELEMENT) {
+ 				pPor = new SwFieldFormPortion();
+ 			    } else
  			if( !rInf.X() && !pCurr->GetPortion() && !pCurr->GetLen() &&
! 			    !GetFnt()->IsURL() ) {
! 			    pPor = pCurr;
! 			 } else
  			{
+ 			     {
  				pPor = new SwTxtPortion;
! 			    }   
! 			    if( GetFnt()->IsURL() )
! 				pPor->SetWhichPor( POR_URL );
  			}
  		}
  	}
Index: sw/source/core/text/itrform2.hxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/itrform2.hxx,v
retrieving revision 1.16
diff -c -r1.16 itrform2.hxx
*** sw/source/core/text/itrform2.hxx	14 Aug 2006 16:39:01 -0000	1.16
--- sw/source/core/text/itrform2.hxx	21 Jan 2008 08:32:36 -0000
***************
*** 144,150 ****
  	sal_Bool CalcOnceMore();
  
  	void CtorInitTxtFormatter( SwTxtFrm *pFrm, SwTxtFormatInfo *pInf );
!     inline SwTxtFormatter( SwTxtFrm *pTxtFrm, SwTxtFormatInfo *pTxtFmtInf )
             { CtorInitTxtFormatter( pTxtFrm, pTxtFmtInf ); }
  	~SwTxtFormatter();
  
--- 144,150 ----
  	sal_Bool CalcOnceMore();
  
  	void CtorInitTxtFormatter( SwTxtFrm *pFrm, SwTxtFormatInfo *pInf );
!     inline SwTxtFormatter( SwTxtFrm *pTxtFrm, SwTxtFormatInfo *pTxtFmtInf ) : SwTxtPainter(pTxtFrm!=NULL?pTxtFrm->GetTxtNode():NULL)
             { CtorInitTxtFormatter( pTxtFrm, pTxtFmtInf ); }
  	~SwTxtFormatter();
  
Index: sw/source/core/text/itrpaint.hxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/itrpaint.hxx,v
retrieving revision 1.8
diff -c -r1.8 itrpaint.hxx
*** sw/source/core/text/itrpaint.hxx	14 Aug 2006 16:39:25 -0000	1.8
--- sw/source/core/text/itrpaint.hxx	21 Jan 2008 08:32:36 -0000
***************
*** 52,60 ****
                                  long nAdjustBaseLine = 0 );
  protected:
  	void CtorInitTxtPainter( SwTxtFrm *pFrm, SwTxtPaintInfo *pInf );
! 	inline SwTxtPainter() { }
  public:
!     inline SwTxtPainter( SwTxtFrm *pTxtFrm, SwTxtPaintInfo *pTxtPaintInf )
             { CtorInitTxtPainter( pTxtFrm, pTxtPaintInf ); }
  	void DrawTextLine( const SwRect &rPaint, SwSaveClip &rClip,
  					   const sal_Bool bUnderSz );
--- 52,61 ----
                                  long nAdjustBaseLine = 0 );
  protected:
  	void CtorInitTxtPainter( SwTxtFrm *pFrm, SwTxtPaintInfo *pInf );
! 	inline SwTxtPainter(SwTxtNode* pTxtNode) : SwTxtCursor(pTxtNode) { }
! 
  public:
! 	inline SwTxtPainter( SwTxtFrm *pTxtFrm, SwTxtPaintInfo *pTxtPaintInf ) : SwTxtCursor(pTxtFrm!=NULL?pTxtFrm->GetTxtNode():NULL)
             { CtorInitTxtPainter( pTxtFrm, pTxtPaintInf ); }
  	void DrawTextLine( const SwRect &rPaint, SwSaveClip &rClip,
  					   const sal_Bool bUnderSz );
Index: sw/source/core/text/itrtxt.hxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/itrtxt.hxx,v
retrieving revision 1.18
diff -c -r1.18 itrtxt.hxx
*** sw/source/core/text/itrtxt.hxx	14 Aug 2006 16:39:49 -0000	1.18
--- sw/source/core/text/itrtxt.hxx	21 Jan 2008 08:32:36 -0000
***************
*** 73,82 ****
  	// Zuruecksetzen in die erste Zeile.
  	void Init();
  	void CtorInitTxtIter( SwTxtFrm *pFrm, SwTxtInfo *pInf );
! 	inline SwTxtIter() { }
  
  public:
!     inline SwTxtIter( SwTxtFrm *pTxtFrm, SwTxtInfo *pTxtInf )
             { CtorInitTxtIter( pTxtFrm, pTxtInf ); }
  	inline const SwLineLayout *GetCurr() const { return pCurr; } // niemals 0!
  	inline const SwLineLayout *GetNext() const { return pCurr->GetNext(); }
--- 73,82 ----
  	// Zuruecksetzen in die erste Zeile.
  	void Init();
  	void CtorInitTxtIter( SwTxtFrm *pFrm, SwTxtInfo *pInf );
! 	inline SwTxtIter(SwTxtNode* pTxtNode) : SwAttrIter(pTxtNode) { }
  
  public:
!     inline SwTxtIter( SwTxtFrm *pTxtFrm, SwTxtInfo *pTxtInf ) : SwAttrIter(pTxtFrm!=NULL?pTxtFrm->GetTxtNode():NULL)
             { CtorInitTxtIter( pTxtFrm, pTxtInf ); }
  	inline const SwLineLayout *GetCurr() const { return pCurr; } // niemals 0!
  	inline const SwLineLayout *GetNext() const { return pCurr->GetNext(); }
***************
*** 159,167 ****
  	inline void SetDropLeft( const KSHORT nNew ) { nDropLeft = nNew; }
  
  	void CtorInitTxtMargin( SwTxtFrm *pFrm, SwTxtSizeInfo *pInf );
! 	inline SwTxtMargin() { }
  public:
!     inline SwTxtMargin( SwTxtFrm *pTxtFrm, SwTxtSizeInfo *pTxtSizeInf )
             { CtorInitTxtMargin( pTxtFrm, pTxtSizeInf ); }
  	inline SwTwips GetLeftMargin() const;
  	inline SwTwips Left() const;
--- 159,167 ----
  	inline void SetDropLeft( const KSHORT nNew ) { nDropLeft = nNew; }
  
  	void CtorInitTxtMargin( SwTxtFrm *pFrm, SwTxtSizeInfo *pInf );
! 	inline SwTxtMargin(SwTxtNode* pTxtNode) : SwTxtIter(pTxtNode) { }
  public:
!     inline SwTxtMargin( SwTxtFrm *pTxtFrm, SwTxtSizeInfo *pTxtSizeInf ) : SwTxtIter(pTxtFrm!=NULL?pTxtFrm->GetTxtNode():NULL)
             { CtorInitTxtMargin( pTxtFrm, pTxtSizeInf ); }
  	inline SwTwips GetLeftMargin() const;
  	inline SwTwips Left() const;
***************
*** 223,235 ****
  								  const SwRect &rCurrRect );
  
  protected:
! 	inline SwTxtAdjuster() { }
  	// spannt beim Blocksatz die Glues auf.
  	void CalcNewBlock( SwLineLayout *pCurr, const SwLinePortion *pStopAt,
  		SwTwips nReal = 0 );
      SwTwips CalcKanaAdj( SwLineLayout *pCurr );
  public:
!     inline SwTxtAdjuster( SwTxtFrm *pTxtFrm, SwTxtSizeInfo *pTxtSizeInf )
             { CtorInitTxtMargin( pTxtFrm, pTxtSizeInf ); }
  
  	// wird von SwTxtFormatter wegen UpdatePos ueberladen
--- 223,235 ----
  								  const SwRect &rCurrRect );
  
  protected:
! 	inline SwTxtAdjuster(SwTxtNode* pTxtNode) : SwTxtMargin(pTxtNode) { }
  	// spannt beim Blocksatz die Glues auf.
  	void CalcNewBlock( SwLineLayout *pCurr, const SwLinePortion *pStopAt,
  		SwTwips nReal = 0 );
      SwTwips CalcKanaAdj( SwLineLayout *pCurr );
  public:
!     inline SwTxtAdjuster( SwTxtFrm *pTxtFrm, SwTxtSizeInfo *pTxtSizeInf ) : SwTxtMargin(pTxtFrm!=NULL?pTxtFrm->GetTxtNode():NULL)
             { CtorInitTxtMargin( pTxtFrm, pTxtSizeInf ); }
  
  	// wird von SwTxtFormatter wegen UpdatePos ueberladen
***************
*** 262,270 ****
  	void _GetCharRect(SwRect *, const xub_StrLen, SwCrsrMoveState* );
  protected:
  	void CtorInitTxtCursor( SwTxtFrm *pFrm, SwTxtSizeInfo *pInf );
! 	inline SwTxtCursor() { }
  public:
!     inline SwTxtCursor( SwTxtFrm *pTxtFrm, SwTxtSizeInfo *pTxtSizeInf )
             { CtorInitTxtCursor( pTxtFrm, pTxtSizeInf ); }
  	sal_Bool GetCharRect(SwRect *, const xub_StrLen, SwCrsrMoveState* = 0,
  		const long nMax = 0 );
--- 262,270 ----
  	void _GetCharRect(SwRect *, const xub_StrLen, SwCrsrMoveState* );
  protected:
  	void CtorInitTxtCursor( SwTxtFrm *pFrm, SwTxtSizeInfo *pInf );
! 	inline SwTxtCursor(SwTxtNode* pTxtNode) : SwTxtAdjuster(pTxtNode) { }
  public:
!     inline SwTxtCursor( SwTxtFrm *pTxtFrm, SwTxtSizeInfo *pTxtSizeInf ) : SwTxtAdjuster(pTxtFrm!=NULL?pTxtFrm->GetTxtNode():NULL)
             { CtorInitTxtCursor( pTxtFrm, pTxtSizeInf ); }
  	sal_Bool GetCharRect(SwRect *, const xub_StrLen, SwCrsrMoveState* = 0,
  		const long nMax = 0 );
Index: sw/source/core/text/portxt.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/portxt.cxx,v
retrieving revision 1.47
diff -c -r1.47 portxt.cxx
*** sw/source/core/text/portxt.cxx	12 Jul 2007 10:43:24 -0000	1.47
--- sw/source/core/text/portxt.cxx	21 Jan 2008 08:32:37 -0000
***************
*** 85,90 ****
--- 85,94 ----
  #include <viewopt.hxx>  // SwViewOptions
  #endif
  
+ #include <bookmrk.hxx>
+ #include <pam.hxx>
+ #include <doc.hxx>
+ 
  #if OSL_DEBUG_LEVEL > 1
  const sal_Char *GetLangName( const MSHORT nLang );
  #endif
***************
*** 596,602 ****
  
  void SwTxtPortion::Paint( const SwTxtPaintInfo &rInf ) const
  {
! 	if( GetLen() )
  	{
          rInf.DrawBackBrush( *this );
  
--- 600,616 ----
  
  void SwTxtPortion::Paint( const SwTxtPaintInfo &rInf ) const
  {
! 	if (rInf.OnWin() && 1==rInf.GetLen() && CH_TXT_ATR_FIELDEND==rInf.GetTxt().GetChar(rInf.GetIdx())) {
! 	    rInf.DrawBackBrush( *this );
! 	    const XubString aTxt = XubString::CreateFromAscii(CH_TXT_ATR_SUBST_FIELDEND);
! 	    rInf.DrawText( aTxt, *this, 0, aTxt.Len(), false );	  
! 	}
! 	else if (rInf.OnWin() && 1==rInf.GetLen() && CH_TXT_ATR_FIELDSTART==rInf.GetTxt().GetChar(rInf.GetIdx())) {
! 	    rInf.DrawBackBrush( *this );
! 	    const XubString aTxt = XubString::CreateFromAscii(CH_TXT_ATR_SUBST_FIELDSTART);
! 	    rInf.DrawText( aTxt, *this, 0, aTxt.Len(), false );	  
! 	}
! 	else if( GetLen() )
  	{
          rInf.DrawBackBrush( *this );
  
***************
*** 780,782 ****
--- 794,841 ----
      rPH.Text( GetLen(), GetWhichPor() );
  }
  
+ 
+ void SwFieldMarkPortion::Paint( const SwTxtPaintInfo &rInf ) const
+ {
+ //	SwTxtPortion::Paint(rInf);
+ }
+ 
+ sal_Bool SwFieldMarkPortion::Format( SwTxtFormatInfo &rInf ) 
+ {
+     sal_Bool ret=0;
+ 	Width(0);
+     return ret;
+ }
+ 
+ 
+ void SwFieldFormPortion::Paint( const SwTxtPaintInfo &rInf ) const
+ {
+ //	SwTxtPortion::Paint(rInf);
+     SwTxtNode *pNd=const_cast<SwTxtNode*>(rInf.GetTxtFrm()->GetTxtNode());
+     const SwDoc *doc=pNd->GetDoc();
+     SwIndex aIndex( pNd, rInf.GetIdx() );
+     SwPosition aPosition(*pNd, aIndex);
+     SwFieldBookmark *pBM=doc->getFormFieldBookmarkFor(aPosition);
+     ASSERT(pBM!=NULL, "Where is my form field bookmark???");
+     bool checked=(pBM!=NULL?pBM->IsChecked():false);
+     rInf.DrawCheckBox( *this , checked);
+ //    const XubString aTxt = XubString::CreateFromAscii("[ ]");
+ //    rInf.DrawText( aTxt, *this, 0, aTxt.Len(), false );	  
+ }
+ 
+ sal_Bool SwFieldFormPortion::Format( SwTxtFormatInfo &rInf ) 
+ {
+     sal_Bool ret=0;
+ //	ret=SwTxtPortion::Format(rInf);
+ 
+ 	Width(rInf.GetTxtHeight());
+ 	Height(rInf.GetTxtHeight());
+ 	SetAscent(rInf.GetAscent());
+ 	int h=rInf.GetTxtHeight();
+ 	
+ /*
+ 	Height(100);
+ 	SetAscent(100);
+ */
+     return ret;
+ }
Index: sw/source/core/text/portxt.hxx
===================================================================
RCS file: /cvs/sw/sw/source/core/text/portxt.hxx,v
retrieving revision 1.9
diff -c -r1.9 portxt.hxx
*** sw/source/core/text/portxt.hxx	14 Aug 2006 16:42:42 -0000	1.9
--- sw/source/core/text/portxt.hxx	21 Jan 2008 08:32:37 -0000
***************
*** 103,110 ****
--- 103,132 ----
  	DECL_FIXEDMEMPOOL_NEWDEL(SwHolePortion)
  };
  
+ class SwFieldMarkPortion : public SwTxtPortion {
+ public:
+     inline SwFieldMarkPortion() : SwTxtPortion() {
+ 	Width(100);
+     }
+     virtual void Paint( const SwTxtPaintInfo &rInf ) const;
+     virtual sal_Bool Format( SwTxtFormatInfo &rInf );
+ };
+ 
+ class SwFieldFormPortion : public SwTxtPortion {
+ public:
+     inline SwFieldFormPortion() : SwTxtPortion() {
+ //	Width(100);
+     }
+     virtual void Paint( const SwTxtPaintInfo &rInf ) const;
+     virtual sal_Bool Format( SwTxtFormatInfo &rInf );
+ };
+ 
+ 
  CLASSIO( SwTxtPortion )
  CLASSIO( SwHolePortion )
  
  
+ 
+ 
+ 
  #endif
Index: sw/source/core/txtnode/swfont.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/txtnode/swfont.cxx,v
retrieving revision 1.56
diff -c -r1.56 swfont.cxx
*** sw/source/core/txtnode/swfont.cxx	14 Mar 2007 08:07:23 -0000	1.56
--- sw/source/core/txtnode/swfont.cxx	21 Jan 2008 08:32:37 -0000
***************
*** 869,874 ****
--- 869,900 ----
  		}
  	}
  
+ 
+ 	if (1==rInf.GetLen() && CH_TXT_ATR_FIELDSTART==rInf.GetText().GetChar(rInf.GetIdx())) {
+ 	    xub_StrLen nOldIdx(rInf.GetIdx());
+ 	    xub_StrLen nOldLen(rInf.GetLen());
+ 	    String aNewText=String::CreateFromAscii(CH_TXT_ATR_SUBST_FIELDSTART);
+ 	    rInf.SetText( aNewText );
+ 	    rInf.SetIdx( 0 );
+ 	    rInf.SetLen( aNewText.Len() );
+ 	    aTxtSize = pLastFont->GetTextSize( rInf );	    
+ 	    rInf.SetIdx( nOldIdx );
+ 	    rInf.SetLen( nOldLen );
+ 	}
+ 	else
+ 	if (1==rInf.GetLen() && CH_TXT_ATR_FIELDEND==rInf.GetText().GetChar(rInf.GetIdx())) {
+ 	    xub_StrLen nOldIdx(rInf.GetIdx());
+ 	    xub_StrLen nOldLen(rInf.GetLen());
+ 	    String aNewText=String::CreateFromAscii(CH_TXT_ATR_SUBST_FIELDEND);
+ 	    rInf.SetText( aNewText );
+ 	    rInf.SetIdx( 0 );
+ 	    rInf.SetLen( aNewText.Len() );
+ 	    aTxtSize = pLastFont->GetTextSize( rInf );	    
+ 	    rInf.SetIdx( nOldIdx );
+ 	    rInf.SetLen( nOldLen );	
+ 	}
+ 
+ 
  	return aTxtSize;
  }
  
Index: sw/source/core/unocore/unobkm.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/unocore/unobkm.cxx,v
retrieving revision 1.12
diff -c -r1.12 unobkm.cxx
*** sw/source/core/unocore/unobkm.cxx	16 Sep 2006 21:55:18 -0000	1.12
--- sw/source/core/unocore/unobkm.cxx	21 Jan 2008 08:32:37 -0000
***************
*** 126,132 ****
  /*-- 10.12.98 10:14:39---------------------------------------------------
  
    -----------------------------------------------------------------------*/
! void SwXBookmark::attachToRange(const uno::Reference< text::XTextRange > & xTextRange)
  										throw( lang::IllegalArgumentException, uno::RuntimeException )
  {
  	if(!bIsDescriptor)
--- 126,132 ----
  /*-- 10.12.98 10:14:39---------------------------------------------------
  
    -----------------------------------------------------------------------*/
! void SwXBookmark::attachToRangeEx(const uno::Reference< text::XTextRange > & xTextRange, IDocumentBookmarkAccess::BookmarkType eMark)
  										throw( lang::IllegalArgumentException, uno::RuntimeException )
  {
  	if(!bIsDescriptor)
***************
*** 160,166 ****
              if( USHRT_MAX != pDoc->findBookmark(m_aName) )
                  pDoc->makeUniqueBookmarkName( m_aName );
  			KeyCode aCode;
!             pBkm = pDoc->makeBookmark( aPam, aCode, m_aName, aEmptyStr, IDocumentBookmarkAccess::BOOKMARK);
  			pBkm->Add(this);
  			bIsDescriptor = sal_False;
  		}
--- 160,166 ----
              if( USHRT_MAX != pDoc->findBookmark(m_aName) )
                  pDoc->makeUniqueBookmarkName( m_aName );
  			KeyCode aCode;
!             pBkm = pDoc->makeBookmark( aPam, aCode, m_aName, aEmptyStr, eMark);
  			pBkm->Add(this);
  			bIsDescriptor = sal_False;
  		}
***************
*** 168,173 ****
--- 168,285 ----
  	else
  		throw lang::IllegalArgumentException();
  }
+ 
+ void SwXBookmark::attachToRange(const uno::Reference< text::XTextRange > & xTextRange)
+ 										throw( lang::IllegalArgumentException, uno::RuntimeException )
+ {
+ 	attachToRangeEx(xTextRange, IDocumentBookmarkAccess::BOOKMARK);
+ }
+ 
+ SwXFieldmark::SwXFieldmark(bool isReplacementObject, SwBookmark* pBkm, SwDoc* pDc) : SwXFieldmark_BASE(pBkm, pDc),
+ isReplacementObject(isReplacementObject)
+ {
+ }
+ 
+ 
+ void SwXFieldmark::attachToRange(const uno::Reference< text::XTextRange > & xTextRange)
+ 										throw( lang::IllegalArgumentException, uno::RuntimeException )
+ {
+ 	attachToRangeEx(xTextRange, (isReplacementObject?IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT:IDocumentBookmarkAccess::FORM_FIELDMARK_TEXT));
+ }
+ 
+ ::rtl::OUString SwXFieldmark::getDescription(void) throw( ::com::sun::star::uno::RuntimeException )
+ {
+ 	vos::OGuard aGuard(Application::GetSolarMutex());
+ 	SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
+ 	OUString sRet;
+ 	if(pBkm)
+ 		sRet = pBkm->GetFFHelpText();
+ 	/* //@TODO implement...
+ 	else if(bIsDescriptor)
+ 		sRet = m_aName;
+ 		*/
+ 	else
+ 		throw uno::RuntimeException();
+ 	return sRet;
+ }
+ 
+ ::sal_Int16 SAL_CALL SwXFieldmark::getType(  ) throw (::com::sun::star::uno::RuntimeException)
+ {
+ 	vos::OGuard aGuard(Application::GetSolarMutex());
+ 	SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
+ 	::sal_Int16 sRet;
+ 	if(pBkm)
+ 		sRet = pBkm->GetType();
+ 	/* //@TODO implement...
+ 	else if(bIsDescriptor)
+ 		sRet = m_aName;
+ 		*/
+ 	else
+ 		throw uno::RuntimeException();
+ 	return sRet;
+ }
+ 
+ ::sal_Int16 SAL_CALL SwXFieldmark::getRes(  ) throw (::com::sun::star::uno::RuntimeException)
+ {
+ 	vos::OGuard aGuard(Application::GetSolarMutex());
+ 	SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
+ 	::sal_Int16 sRet;
+ 	if(pBkm)
+ 		sRet = pBkm->GetFFRes();
+ 	/* //@TODO implement...
+ 	else if(bIsDescriptor)
+ 		sRet = m_aName;
+ 		*/
+ 	else
+ 		throw uno::RuntimeException();
+ 	return sRet;
+ }
+ 
+ 
+ void SAL_CALL SwXFieldmark::setType( ::sal_Int16 fieldType ) throw (::com::sun::star::uno::RuntimeException)
+ {
+ 	vos::OGuard aGuard(Application::GetSolarMutex());
+ 	SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
+ 	if (pBkm) {
+ 		pBkm->SetType(fieldType);
+ 	} else {
+ 		throw uno::RuntimeException();
+ 	}
+ }
+ 
+ void SAL_CALL SwXFieldmark::setRes( ::sal_Int16 res ) throw (::com::sun::star::uno::RuntimeException)
+ {
+ 	vos::OGuard aGuard(Application::GetSolarMutex());
+ 	SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
+ 	if (pBkm) {
+ 		pBkm->SetFFRes(res);
+ 	} else {
+ 		throw uno::RuntimeException();
+ 	}
+ }
+ 
+ void SAL_CALL SwXFieldmark::setDescription( const ::rtl::OUString& description ) throw (::com::sun::star::uno::RuntimeException)
+ {
+ 	vos::OGuard aGuard(Application::GetSolarMutex());
+ 	SwFieldBookmark* pBkm = (SwFieldBookmark*)GetBookmark();
+ 	if (pBkm) {
+ 		pBkm->SetFFHelpText(description);
+ 	} else {
+ 		throw uno::RuntimeException();
+ 	}
+ }
+ 
+ 
+ 
+ /*
+ 
+ ::com::sun::star::uno::Any SAL_CALL SwXFieldmark::queryInterface( ::com::sun::star::uno::Type const & rType ) throw (::com::sun::star::uno::RuntimeException)
+ {
+ 		return SwXBookmark::queryInterface(rType);
+ }
+ */
+ 
+ 
  /* -----------------18.02.99 13:31-------------------
   *
   * --------------------------------------------------*/
Index: sw/source/core/unocore/unocoll.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/unocore/unocoll.cxx,v
retrieving revision 1.34
diff -c -r1.34 unocoll.cxx
*** sw/source/core/unocore/unocoll.cxx	22 May 2007 16:33:55 -0000	1.34
--- sw/source/core/unocore/unocoll.cxx	21 Jan 2008 08:32:37 -0000
***************
*** 20,26 ****
   *    This library is free software; you can redistribute it and/or
   *    modify it under the terms of the GNU Lesser General Public
   *    License version 2.1, as published by the Free Software Foundation.
!  *
   *    This library is distributed in the hope that it will be useful,
   *    but WITHOUT ANY WARRANTY; without even the implied warranty of
   *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--- 20,26 ----
   *    This library is free software; you can redistribute it and/or
   *    modify it under the terms of the GNU Lesser General Public
   *    License version 2.1, as published by the Free Software Foundation.
!  *	
   *    This library is distributed in the hope that it will be useful,
   *    but WITHOUT ANY WARRANTY; without even the implied warranty of
   *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
***************
*** 271,276 ****
--- 271,278 ----
      { "com.sun.star.image.ImageMapPolygonObject",             SW_SERVICE_IMAP_POLYGON },
      { "com.sun.star.text.TextGraphicObject",                  SW_SERVICE_TYPE_TEXT_GRAPHIC },
      { "com.sun.star.chart2.data.DataProvider",                SW_SERVICE_CHART2_DATA_PROVIDER },
+     { "org.go-oo.text.Fieldmark",                             SW_SERVICE_TYPE_FIELDMARK },
+     { "org.go-oo.text.FormFieldmark",                         SW_SERVICE_TYPE_FORMFIELDMARK },
  
      // case-correct versions of the service names (see #i67811)
      { CSS_TEXT_TEXTFIELD_DATE_TIME,                   SW_SERVICE_FIELDTYPE_DATETIME },
***************
*** 441,446 ****
--- 443,460 ----
  			xRet =  (cppu::OWeakObject*)pBookmark;
  		}
  		break;
+ 		case  SW_SERVICE_TYPE_FIELDMARK :
+ 		{
+ 			SwXFieldmark* pFieldmark = new SwXFieldmark(false);
+ 			xRet =  (cppu::OWeakObject*)pFieldmark;
+ 		}
+ 		break;
+ 		case  SW_SERVICE_TYPE_FORMFIELDMARK :
+ 		{
+ 			SwXFieldmark* pFieldmark = new SwXFieldmark(true);
+ 			xRet =  (cppu::OWeakObject*)pFieldmark;
+ 		}
+ 		break;
  		case  SW_SERVICE_TYPE_FOOTNOTE :
  			xRet =  (cppu::OWeakObject*)new SwXFootnote(sal_False);
  		break;
***************
*** 1630,1637 ****
  {
  	SwXBookmark* pBkm = (SwXBookmark*)SwClientIter( rBkm ).
  									First( TYPE( SwXBookmark ));
! 	if( !pBkm )
! 		pBkm = new SwXBookmark(&rBkm, pDoc);
  	return pBkm;
  }
  /******************************************************************
--- 1644,1658 ----
  {
  	SwXBookmark* pBkm = (SwXBookmark*)SwClientIter( rBkm ).
  									First( TYPE( SwXBookmark ));
! 	if( !pBkm ) {
! 		if (IDocumentBookmarkAccess::FORM_FIELDMARK_TEXT==rBkm.GetType()) {
! 			pBkm = new SwXFieldmark(false, &rBkm, pDoc);
! 		} else if (IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT==rBkm.GetType()) {
! 			pBkm = new SwXFieldmark(true, &rBkm, pDoc);
! 		} else {
! 			pBkm = new SwXBookmark(&rBkm, pDoc);
! 		}
! 	}
  	return pBkm;
  }
  /******************************************************************
Index: sw/source/core/unocore/unoport.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/unocore/unoport.cxx,v
retrieving revision 1.39
diff -c -r1.39 unoport.cxx
*** sw/source/core/unocore/unoport.cxx	6 Jul 2007 12:17:24 -0000	1.39
--- sw/source/core/unocore/unoport.cxx	21 Jan 2008 08:32:38 -0000
***************
*** 350,355 ****
--- 350,358 ----
                  case PORTION_RUBY_START:
                  case PORTION_RUBY_END:      pRet = "Ruby";break;
                  case PORTION_SOFT_PAGEBREAK:pRet = "SoftPageBreak";break;
+                 case PORTION_FIELD_START:pRet = "TextFieldStart";break;
+                 case PORTION_FIELD_END:pRet = "TextFieldEnd";break;
+                 case PORTION_FIELD_START_END:pRet = "TextFieldStartEnd";break;
                  default:
                      pRet = 0;
                  }
***************
*** 393,398 ****
--- 396,403 ----
                      case PORTION_REDLINE_END :
                      case PORTION_RUBY_START:
                      case PORTION_RUBY_END:
+                     case PORTION_FIELD_START:
+                     case PORTION_FIELD_END:
                          rVal.setValue(&bIsCollapsed, ::getBooleanCppuType());
                      break;
                      default:
***************
*** 410,415 ****
--- 415,421 ----
                      case PORTION_TOXMARK_START:
                      case PORTION_REDLINE_START:
                      case PORTION_RUBY_START:
+                     case PORTION_FIELD_START:
                      break;
  
                      case PORTION_REFMARK_END:
***************
*** 417,422 ****
--- 423,429 ----
                      case PORTION_BOOKMARK_END:
                      case PORTION_REDLINE_END:
                      case PORTION_RUBY_END:
+                     case PORTION_FIELD_END:
                          bStart = FALSE;
                      break;
                      default:
Index: sw/source/core/unocore/unoportenum.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/unocore/unoportenum.cxx,v
retrieving revision 1.36
diff -c -r1.36 unoportenum.cxx
*** sw/source/core/unocore/unoportenum.cxx	6 Jul 2007 12:17:39 -0000	1.36
--- sw/source/core/unocore/unoportenum.cxx	21 Jan 2008 08:32:38 -0000
***************
*** 688,693 ****
--- 688,706 ----
  			if( !pMark->IsBookMark() )
  				continue;
  
+ 			/*
+ 			if (pMark!=NULL && pMark->GetName().CompareToAscii(FIELD_BOOKMARK_PREFIX, strlen(FIELD_BOOKMARK_PREFIX))==0) {
+ 				continue;
+ 			}
+ 
+ 			if (pMark!=NULL && pMark->GetName().CompareToAscii(FIELD_FORM_BOOKMARK_PREFIX, strlen(FIELD_FORM_BOOKMARK_PREFIX))==0) {
+ 				continue;
+ 			}
+ 			*/
+ 			if (pMark!=NULL && pMark->IsFormFieldMark()) {
+ 				continue;
+ 			}
+ 
  			const SwPosition& rPos1 = pMark->GetPos();
  			const SwPosition* pPos2 = pMark->GetOtherPos();
  			BOOL bBackward = pPos2 ? rPos1 > *pPos2: FALSE;
***************
*** 995,1002 ****
  							}
  						}
  					}
! 					if(!xRef.is() && pUnoCrsr->HasMark() )
!                         xRef = new SwXTextPortion(pUnoCrsr, xParent, ePortionType);
  					if(xRef.is())
  						aPortionArr.Insert(new Reference<XTextRange>(xRef), aPortionArr.Count());
  				}
--- 1008,1085 ----
  							}
  						}
  					}
! 					if(!xRef.is() && pUnoCrsr->HasMark() ) {
! 						//flr: maybe its a good idea to add a special hint to the hints array and rely on the hint segmentation....
! 						xub_StrLen start=pUnoCrsr->GetMark()->nContent.GetIndex();
! 						xub_StrLen end=pUnoCrsr->GetPoint()->nContent.GetIndex();
! 						ASSERT(start<=end, "hmm --- why is this different");
! 						xub_StrLen startMarkerPos=pTxtNode->GetTxt().Search(CH_TXT_ATR_FIELDSTART, start);
! 						xub_StrLen endMarkerPos=pTxtNode->GetTxt().Search(CH_TXT_ATR_FIELDEND, start);
! 						xub_StrLen formMarkerPos=pTxtNode->GetTxt().Search(CH_TXT_ATR_FORMELEMENT, start);
! 						xub_StrLen markerPos=STRING_LEN;
! 						if (startMarkerPos>=start && startMarkerPos<end) {
! 							markerPos=startMarkerPos;
! 						}
! 						if (endMarkerPos>=start && endMarkerPos<end) {
! 							if (endMarkerPos<markerPos) {
! 								markerPos=endMarkerPos;
! 							}
! 						}
! 						if (formMarkerPos>=start && formMarkerPos<end) {
! 							if (formMarkerPos<markerPos) {
! 								markerPos=formMarkerPos;
! 							}
! 						}
! 						if (markerPos<end) {
! 							if (start==markerPos)
! 								end = markerPos+1;
! 							else
! 								end = markerPos;
! 							bAtEnd = sal_False;
! 							pUnoCrsr->GetPoint()->nContent = end;
! 						}
! 						if (start+1==end && pTxtNode->GetTxt().GetChar(start)==CH_TXT_ATR_FIELDSTART) {
! 						    SwDoc* pDoc = pUnoCrsr->GetDoc();
! 							SwBookmark* pFieldmark=NULL;
! 							if (pDoc && pUnoCrsr->GetPoint()) {
! 								pFieldmark=pDoc->getFieldBookmarkFor(*pUnoCrsr->GetPoint());
! 							}
! 							SwXTextPortion* pPortion=NULL;
! 							xRef = (pPortion=new SwXTextPortion(pUnoCrsr, xParent, PORTION_FIELD_START));
! 							if (pPortion && pFieldmark && pDoc) {
! 								pPortion->SetBookmark(new SwXFieldmark(false, pFieldmark, pDoc));
! 							}
! 						} else if (start+1==end && pTxtNode->GetTxt().GetChar(start)==CH_TXT_ATR_FIELDEND) {
! 						    SwDoc* pDoc = pUnoCrsr->GetDoc();
! 							SwBookmark* pFieldmark=NULL;
! 							if (pDoc && pUnoCrsr->GetPoint()) {
! 								SwPosition aPos(*pUnoCrsr->GetPoint());
! 								aPos.nContent=markerPos;
! 								pFieldmark=pDoc->getFieldBookmarkFor(aPos);
! 							}
! 							SwXTextPortion* pPortion=NULL;
! 							xRef = (pPortion = new SwXTextPortion(pUnoCrsr, xParent, PORTION_FIELD_END));
! 							if (pPortion && pFieldmark && pDoc) {
! 								pPortion->SetBookmark(new SwXFieldmark(false, pFieldmark, pDoc));
! 							}
! 						} else if (start+1==end && pTxtNode->GetTxt().GetChar(start)==CH_TXT_ATR_FORMELEMENT) {
! 						    SwDoc* pDoc = pUnoCrsr->GetDoc();
! 							SwFieldBookmark* pFieldmark=NULL;
! 							if (pDoc && pUnoCrsr->GetPoint()) {
! 								SwPosition aPos(*pUnoCrsr->GetPoint());
! 								aPos.nContent=markerPos;
! 								pFieldmark=pDoc->getFormFieldBookmarkFor(aPos);
! 							}
! 							SwXTextPortion* pPortion=NULL;							
! 							xRef = (pPortion = new SwXTextPortion(pUnoCrsr, xParent, PORTION_FIELD_START_END));
! 							if (pPortion && pFieldmark && pDoc) {
! 								pPortion->SetBookmark(new SwXFieldmark(true, pFieldmark, pDoc));
! 							}
! 						} else {
! 							xRef = new SwXTextPortion(pUnoCrsr, xParent, ePortionType);
! 						}
! 						
! 					}
  					if(xRef.is())
  						aPortionArr.Insert(new Reference<XTextRange>(xRef), aPortionArr.Count());
  				}
Index: sw/source/filter/inc/fltshell.hxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/inc/fltshell.hxx,v
retrieving revision 1.16
diff -c -r1.16 fltshell.hxx
*** sw/source/filter/inc/fltshell.hxx	5 Feb 2007 10:53:37 -0000	1.16
--- sw/source/filter/inc/fltshell.hxx	21 Jan 2008 08:32:39 -0000
***************
*** 89,94 ****
--- 89,95 ----
  	BOOL bOld;			// to mark Attributes *before* skipping field results
  	BOOL bLocked;
  	BOOL bCopied;
+ 	BOOL bConsumedByField;
  
  	SwFltStackEntry(const SwPosition & rStartPos, SfxPoolItem* pHt );
  	SwFltStackEntry(const SwFltStackEntry& rEntry);
***************
*** 144,150 ****
  
  	void NewAttr(const SwPosition& rPos, const SfxPoolItem & rAttr );
  
! 	virtual void SetAttr(const SwPosition& rPos, USHORT nAttrId=0, BOOL bTstEnde=TRUE, long nHand = LONG_MAX);
  
  	void StealAttr(const SwPosition* pPos, USHORT nAttrId = 0);
  	void MarkAllAttrsOld();
--- 144,150 ----
  
  	void NewAttr(const SwPosition& rPos, const SfxPoolItem & rAttr );
  
! 	virtual void SetAttr(const SwPosition& rPos, USHORT nAttrId=0, BOOL bTstEnde=TRUE, long nHand = LONG_MAX, BOOL consumedByField=FALSE);
  
  	void StealAttr(const SwPosition* pPos, USHORT nAttrId = 0);
  	void MarkAllAttrsOld();
Index: sw/source/filter/ww1/fltshell.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww1/fltshell.cxx,v
retrieving revision 1.23
diff -c -r1.23 fltshell.cxx
*** sw/source/filter/ww1/fltshell.cxx	10 May 2007 16:08:44 -0000	1.23
--- sw/source/filter/ww1/fltshell.cxx	21 Jan 2008 08:32:39 -0000
***************
*** 187,192 ****
--- 187,193 ----
  	bOld	= FALSE;	// used for marking Attributes *before* skipping field results
  	bLocked = TRUE; 	// locke das Attribut --> darf erst
  	bCopied = FALSE;	// gesetzt werden, wenn es wieder geunlocked ist
+ 	bConsumedByField = FALSE;
  }
  
  SwFltStackEntry::SwFltStackEntry(const SwFltStackEntry& rEntry) :
***************
*** 197,202 ****
--- 198,204 ----
  	nMkCntnt= rEntry.nMkCntnt;
  	bOld	= rEntry.bOld;
  	bLocked	= bCopied = TRUE; // when rEntry were NOT bLocked we would never have been called
+ 	bConsumedByField = rEntry.bConsumedByField;
  }
  
  
***************
*** 383,389 ****
  // Returned, ob das gesuchte Attribut / die gesuchten Attribute
  // ueberhaupt auf dem Stack standen
  void SwFltControlStack::SetAttr(const SwPosition& rPos, USHORT nAttrId,
! 								BOOL bTstEnde, long nHand )
  {
  	ASSERT(!nAttrId ||
  		(POOLATTR_BEGIN <= nAttrId && POOLATTR_END > nAttrId) ||
--- 385,391 ----
  // Returned, ob das gesuchte Attribut / die gesuchten Attribute
  // ueberhaupt auf dem Stack standen
  void SwFltControlStack::SetAttr(const SwPosition& rPos, USHORT nAttrId,
! 								BOOL bTstEnde, long nHand, BOOL consumedByField )
  {
  	ASSERT(!nAttrId ||
  		(POOLATTR_BEGIN <= nAttrId && POOLATTR_END > nAttrId) ||
***************
*** 411,418 ****
  					bF = true;
  				}
  			}
! 			if (bF)
  				pEntry->SetEndPos(rPos);
  			continue;
  		}
  
--- 413,422 ----
  					bF = true;
  				}
  			}
! 			if (bF) {
! 				pEntry->bConsumedByField = consumedByField;
  				pEntry->SetEndPos(rPos);
+ 			}
  			continue;
  		}
  
***************
*** 581,587 ****
  				}
  			}
  			if( !pB->IsOnlyRef() &&
! 				( !IsFlagSet(HYPO) || IsFlagSet(BOOK_AND_REF) ) )
  			{
  				MakeBookRegionOrPoint(pEntry, pDoc, aRegion, TRUE);
                  pDoc->makeBookmark( aRegion, aEmptyKeyCode, rName, aEmptyStr, IDocumentBookmarkAccess::BOOKMARK);
--- 585,591 ----
  				}
  			}
  			if( !pB->IsOnlyRef() &&
! 				( !IsFlagSet(HYPO) || IsFlagSet(BOOK_AND_REF) ) && !pEntry->bConsumedByField)
  			{
  				MakeBookRegionOrPoint(pEntry, pDoc, aRegion, TRUE);
                  pDoc->makeBookmark( aRegion, aEmptyKeyCode, rName, aEmptyStr, IDocumentBookmarkAccess::BOOKMARK);
Index: sw/source/filter/ww8/wrtw8nds.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/wrtw8nds.cxx,v
retrieving revision 1.100
diff -c -r1.100 wrtw8nds.cxx
*** sw/source/filter/ww8/wrtw8nds.cxx	26 Jun 2007 10:44:02 -0000	1.100
--- sw/source/filter/ww8/wrtw8nds.cxx	21 Jan 2008 08:32:40 -0000
***************
*** 216,221 ****
--- 216,225 ----
  #include "ww8par.hxx"
  #endif
  
+ #ifndef _BOOKMRK_HXX
+ #include <bookmrk.hxx>
+ #endif
+ 
  using namespace ::com::sun::star;
  using namespace ::com::sun::star::i18n;
  using namespace sw::util;
***************
*** 394,405 ****
      xub_StrLen nMinPos = STRING_MAXLEN;
      xub_StrLen i=0;
  
      // first the redline, then the attributes
      if( pCurRedline )
      {
          const SwPosition* pEnd = pCurRedline->End();
          if (pEnd->nNode == rNd && ((i = pEnd->nContent.GetIndex()) >= nStartPos))
!             nMinPos = i;
      }
  
      if( nCurRedlinePos < rWrt.pDoc->GetRedlineTbl().Count() )
--- 398,419 ----
      xub_StrLen nMinPos = STRING_MAXLEN;
      xub_StrLen i=0;
  
+ 	const String aTxt = rNd.GetTxt();
+ 	xub_StrLen pos=aTxt.Search(CH_TXT_ATR_FIELDSTART, nStartPos);
+ 	if (pos==STRING_NOTFOUND) 
+ 		pos=aTxt.Search(CH_TXT_ATR_FIELDEND, nStartPos);
+ 	if (pos==STRING_NOTFOUND) 
+ 		pos=aTxt.Search(CH_TXT_ATR_FORMELEMENT, nStartPos);
+ 	if (pos!=STRING_NOTFOUND)  
+ 		nMinPos=pos;
+ 
      // first the redline, then the attributes
      if( pCurRedline )
      {
          const SwPosition* pEnd = pCurRedline->End();
          if (pEnd->nNode == rNd && ((i = pEnd->nContent.GetIndex()) >= nStartPos))
! 			if (i<nMinPos)
! 				nMinPos = i;
      }
  
      if( nCurRedlinePos < rWrt.pDoc->GetRedlineTbl().Count() )
***************
*** 519,525 ****
      }
  
  	// #i46087# patch from james_clark; complex texts needs the undocumented SPRM 0x0882 with param 0x81.
! 	if (rWrt.bWrtWW8 && GetScript() == ScriptType::COMPLEX && !IsCharRTL())
      {
  		rWrt.InsUInt16(0x882);
  		rWrt.pO->Insert((BYTE)0x81, rWrt.pO->Count());
--- 533,539 ----
      }
  
  	// #i46087# patch from james_clark; complex texts needs the undocumented SPRM 0x0882 with param 0x81.
! 	if (rWrt.bWrtWW8 && GetScript() == com::sun::star::i18n::ScriptType::COMPLEX && !IsCharRTL())
      {
  		rWrt.InsUInt16(0x882);
  		rWrt.pO->Insert((BYTE)0x81, rWrt.pO->Count());
***************
*** 813,819 ****
          if( pBreakIt->xBreak.is() )
              nRubyScript = pBreakIt->xBreak->getScriptType( rRuby.GetText(), 0);
          else
!             nRubyScript = ScriptType::ASIAN;
  
          const SwTxtRuby* pRubyTxt = rRuby.GetTxtRuby();
          const SwCharFmt* pFmt = pRubyTxt ? pRubyTxt->GetCharFmt() : 0;
--- 827,833 ----
          if( pBreakIt->xBreak.is() )
              nRubyScript = pBreakIt->xBreak->getScriptType( rRuby.GetText(), 0);
          else
!             nRubyScript = com::sun::star::i18n::ScriptType::ASIAN;
  
          const SwTxtRuby* pRubyTxt = rRuby.GetTxtRuby();
          const SwCharFmt* pFmt = pRubyTxt ? pRubyTxt->GetCharFmt() : 0;
***************
*** 864,870 ****
              nRubyScript = pBreakIt->xBreak->getScriptType( rNd.GetTxt(),
                  *(pRubyTxt->GetStart()));
          else
!             nRubyScript = ScriptType::ASIAN;
  
          const SwAttrSet& rSet = rNd.GetSwAttrSet();
          const SvxFontHeightItem &rHeightItem  =
--- 878,884 ----
              nRubyScript = pBreakIt->xBreak->getScriptType( rNd.GetTxt(),
                  *(pRubyTxt->GetStart()));
          else
!             nRubyScript = com::sun::star::i18n::ScriptType::ASIAN;
  
          const SwAttrSet& rSet = rNd.GetSwAttrSet();
          const SvxFontHeightItem &rHeightItem  =
***************
*** 1452,1471 ****
  
      if (SVX_CASEMAP_TITEL == ((const SvxCaseMapItem&)rItem).GetValue())
      {
!         sal_uInt16 nScriptType = ScriptType::LATIN;
          if (pBreakIt->xBreak.is())
              nScriptType = pBreakIt->xBreak->getScriptType(aSnippet, 0);
  
          LanguageType nLanguage;
          switch (nScriptType)
          {
!             case ScriptType::ASIAN:
                  nLanguage = ((const SvxLanguageItem&)GetItem(RES_CHRATR_CJK_LANGUAGE)).GetLanguage();
                  break;
!             case ScriptType::COMPLEX:
                  nLanguage = ((const SvxLanguageItem&)GetItem(RES_CHRATR_CTL_LANGUAGE)).GetLanguage();
                  break;
!             case ScriptType::LATIN:
              default:
                  nLanguage = ((const SvxLanguageItem&)GetItem(RES_CHRATR_LANGUAGE)).GetLanguage();
                  break;
--- 1466,1485 ----
  
      if (SVX_CASEMAP_TITEL == ((const SvxCaseMapItem&)rItem).GetValue())
      {
!         sal_uInt16 nScriptType = com::sun::star::i18n::ScriptType::LATIN;
          if (pBreakIt->xBreak.is())
              nScriptType = pBreakIt->xBreak->getScriptType(aSnippet, 0);
  
          LanguageType nLanguage;
          switch (nScriptType)
          {
!             case com::sun::star::i18n::ScriptType::ASIAN:
                  nLanguage = ((const SvxLanguageItem&)GetItem(RES_CHRATR_CJK_LANGUAGE)).GetLanguage();
                  break;
!             case com::sun::star::i18n::ScriptType::COMPLEX:
                  nLanguage = ((const SvxLanguageItem&)GetItem(RES_CHRATR_CTL_LANGUAGE)).GetLanguage();
                  break;
!             case com::sun::star::i18n::ScriptType::LATIN:
              default:
                  nLanguage = ((const SvxLanguageItem&)GetItem(RES_CHRATR_LANGUAGE)).GetLanguage();
                  break;
***************
*** 1603,1610 ****
          xub_StrLen nLen = nNextAttr - nAktPos;
          if (!bTxtAtr && nLen)
          {
!             String aSnippet(aAttrIter.GetSnippet(aStr, nAktPos, nLen));
!             if ((rWW8Wrt.nTxtTyp == TXT_EDN || rWW8Wrt.nTxtTyp == TXT_FTN) && nAktPos ==0)
              {
                  // Insert tab for aesthetic puposes #i24762#
                  if (aSnippet.GetChar(0) != 0x09)
--- 1617,1666 ----
          xub_StrLen nLen = nNextAttr - nAktPos;
          if (!bTxtAtr && nLen)
          {
! 			sal_Unicode ch=aStr.GetChar(nAktPos);
! 			int ofs=(ch==CH_TXT_ATR_FIELDSTART || ch==CH_TXT_ATR_FIELDEND || ch==CH_TXT_ATR_FORMELEMENT?1:0);
! 
! 			if (ch==CH_TXT_ATR_FIELDSTART) {
! 				SwPosition aPosition( *pNd, SwIndex( (SwTxtNode*)pNd, nAktPos+1 ) );
! 				SwFieldBookmark* pFieldmark=(SwFieldBookmark*)rWW8Wrt.pDoc->getFieldBookmarkFor( aPosition );
! 				ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
! 
! 				if (pFieldmark!=NULL) {
! 					rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 1);
! 				}
! 				rWW8Wrt.OutField(NULL, ww::eFORMTEXT, String::CreateFromAscii(" FORMTEXT "), WRITEFIELD_START | WRITEFIELD_CMD_START);	
! 				if (pFieldmark!=NULL) {
! 					rWW8Wrt.WriteFormData( *pFieldmark );
! 				}
! 				rWW8Wrt.OutField(NULL, ww::eFORMTEXT, String(), WRITEFIELD_CMD_END);
! 			} else if (ch==CH_TXT_ATR_FIELDEND) {
! 				SwPosition aPosition( *pNd, SwIndex( (SwTxtNode*)pNd, nAktPos ) );
! 				SwFieldBookmark* pFieldmark=(SwFieldBookmark*)rWW8Wrt.pDoc->getFieldBookmarkFor( aPosition );
! 				ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
! 				rWW8Wrt.OutField(NULL, ww::eFORMTEXT, String(), WRITEFIELD_CLOSE);
! 				if (pFieldmark!=NULL) {
! 					rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
! 				}
! 			} else if (ch==CH_TXT_ATR_FORMELEMENT) {
! 				SwPosition aPosition( *pNd, SwIndex( (SwTxtNode*)pNd, nAktPos ) );
! 				SwFieldBookmark* pFieldmark=rWW8Wrt.pDoc->getFormFieldBookmarkFor( aPosition );
! 				ASSERT(pFieldmark!=NULL, "Looks like this doc is broken...; where is the Fieldmark for the FIELDSTART??");
! 				if (pFieldmark!=NULL) {
! 					rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 1);
! 				}
! 				rWW8Wrt.OutField(NULL, ww::eFORMCHECKBOX, String::CreateFromAscii(" FORMCHECKBOX "), WRITEFIELD_START | WRITEFIELD_CMD_START);
! 				if (pFieldmark!=NULL) {
! 
! 					rWW8Wrt.WriteFormData( *pFieldmark );
! 				}
! 				rWW8Wrt.OutField(NULL, ww::eFORMCHECKBOX, String(), WRITEFIELD_CMD_END | WRITEFIELD_CLOSE);
! 				if (pFieldmark!=NULL) {
! 					rWW8Wrt.AppendBookmark( pFieldmark->GetName(), 0);
! 				}
! 			}
! 			nLen-=ofs;
! 			String aSnippet(aAttrIter.GetSnippet(aStr, nAktPos+ofs, nLen));
!             if ((rWW8Wrt.nTxtTyp == TXT_EDN || rWW8Wrt.nTxtTyp == TXT_FTN) && nAktPos ==0 && nLen>0)
              {
                  // Insert tab for aesthetic puposes #i24762#
                  if (aSnippet.GetChar(0) != 0x09)
***************
*** 1612,1618 ****
                      nLen++;
                      aSnippet.Insert(0x09,0);
                  }
!             }
              rWW8Wrt.OutSwString(aSnippet, 0, nLen, bUnicode, eChrSet );
          }
  
--- 1668,1674 ----
                      nLen++;
                      aSnippet.Insert(0x09,0);
                  }
! 			}
              rWW8Wrt.OutSwString(aSnippet, 0, nLen, bUnicode, eChrSet );
          }
  
Index: sw/source/filter/ww8/wrtww8.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/wrtww8.cxx,v
retrieving revision 1.83
diff -c -r1.83 wrtww8.cxx
*** sw/source/filter/ww8/wrtww8.cxx	17 Jul 2007 13:09:18 -0000	1.83
--- sw/source/filter/ww8/wrtww8.cxx	21 Jan 2008 08:32:41 -0000
***************
*** 204,209 ****
--- 204,213 ----
  #include "writerwordglue.hxx"
  #endif
  
+ #ifndef IDOCUMENTBOOKMARKACCESS_HXX_INCLUDED
+ #include <IDocumentBookmarkAccess.hxx>
+ #endif
+ 
  using namespace sw::util;
  using namespace sw::types;
  
***************
*** 286,292 ****
      WW8_WrtBookmarks();
      ~WW8_WrtBookmarks();
  
!     void Append( WW8_CP nStartCp, const String& rNm );
      void Write( SwWW8Writer& rWrt );
      void MoveFieldBookmarks(ULONG nFrom,ULONG nTo);
  
--- 290,296 ----
      WW8_WrtBookmarks();
      ~WW8_WrtBookmarks();
  
!     void Append( WW8_CP nStartCp, const String& rNm, const SwBookmark* pBkmk=NULL );
      void Write( SwWW8Writer& rWrt );
      void MoveFieldBookmarks(ULONG nFrom,ULONG nTo);
  
***************
*** 1303,1309 ****
  {
  }
  
! void WW8_WrtBookmarks::Append( WW8_CP nStartCp, const String& rNm )
  {
      USHORT nPos = GetPos( rNm );
      if( USHRT_MAX == nPos )
--- 1307,1313 ----
  {
  }
  
! void WW8_WrtBookmarks::Append( WW8_CP nStartCp, const String& rNm,  const SwBookmark* pBkmk)
  {
      USHORT nPos = GetPos( rNm );
      if( USHRT_MAX == nPos )
***************
*** 1335,1341 ****
          if (aFieldBookmarks[nPos])
              --nStartCp;
  
!         aEndCps.Replace( nStartCp, nPos );
      }
  }
  
--- 1339,1345 ----
          if (aFieldBookmarks[nPos])
              --nStartCp;
  
! 		aEndCps.Replace( nStartCp, nPos );
      }
  }
  
***************
*** 1433,1438 ****
--- 1437,1447 ----
          for( USHORT n = 0; n < aArr.Count(); ++n )
          {
              const SwBookmark& rBkmk = *(SwBookmark*)aArr[ n ];
+ 
+ 			if (rBkmk.IsFormFieldMark()) {
+ 				continue;
+ 			}
+ 
              const SwPosition* pPos = &rBkmk.GetPos(),
                              * pOPos = rBkmk.GetOtherPos();
              if( pOPos && pOPos->nNode == pPos->nNode &&
***************
*** 1447,1460 ****
                  nCntnt < nAktEnd ) )
              {
                  ULONG nCp = nSttCP + pPos->nContent.GetIndex() - nAktPos;
!                 pBkmks->Append(nCp, BookmarkToWord(rBkmk.GetName()));
              }
!             if( pOPos && nNd == pOPos->nNode.GetIndex() &&
                  ( nCntnt = pOPos->nContent.GetIndex() ) >= nAktPos &&
                  nCntnt < nAktEnd )
              {
                  ULONG nCp = nSttCP + pOPos->nContent.GetIndex() - nAktPos;
!                 pBkmks->Append(nCp, BookmarkToWord(rBkmk.GetName()));
              }
          }
      }
--- 1456,1469 ----
                  nCntnt < nAktEnd ) )
              {
                  ULONG nCp = nSttCP + pPos->nContent.GetIndex() - nAktPos;
!                 pBkmks->Append(nCp, BookmarkToWord(rBkmk.GetName()), &rBkmk);
              }
! 			if( pOPos && nNd == pOPos->nNode.GetIndex() &&
                  ( nCntnt = pOPos->nContent.GetIndex() ) >= nAktPos &&
                  nCntnt < nAktEnd )
              {
                  ULONG nCp = nSttCP + pOPos->nContent.GetIndex() - nAktPos;
!                 pBkmks->Append(nCp, BookmarkToWord(rBkmk.GetName()), &rBkmk);
              }
          }
      }
***************
*** 1646,1651 ****
--- 1655,1671 ----
          rStrm.Write(&aBytes[0], aBytes.size());
  }
  
+ void SwWW8Writer::WriteString_xstz(SvStream& rStrm, const String& rStr, bool bAddZero)
+ {
+     ww::bytes aBytes;
+     SwWW8Writer::InsUInt16(aBytes, rStr.Len());
+     SwWW8Writer::InsAsString16(aBytes, rStr);
+ 	if (bAddZero) 
+ 		SwWW8Writer::InsUInt16(aBytes, 0);
+ 	rStrm.Write(&aBytes[0], aBytes.size());
+ }
+ 
+ 
  void SwWW8Writer::WriteString8(SvStream& rStrm, const String& rStr,
      bool bAddZero, rtl_TextEncoding eCodeSet)
  {
***************
*** 2647,2651 ****
--- 2667,2763 ----
      pFib->lcbCmds = pTableStrm->Tell() - pFib->fcCmds;
  }
  
+ void SwWW8Writer::WriteFormData(SwFieldBookmark &rFieldmark)
+ {
+ 	ASSERT(bWrtWW8, "No 95 export yet");
+ 	if (!bWrtWW8) return;
+ 
+ 	int type=rFieldmark.GetType();
+ 	const String ffname=rFieldmark.GetFFName();
+ 
+ 	ULONG nDataStt = pDataStrm->Tell();
+     pChpPlc->AppendFkpEntry( Strm().Tell() );
+ 
+     WriteChar( 0x01 );
+     static BYTE aArr1[] = {
+         0x03, 0x6a, 0,0,0,0,    // sprmCPicLocation
+ 
+         0x06, 0x08, 0x01,       // sprmCFData
+         0x55, 0x08, 0x01,       // sprmCFSpec
+         0x02, 0x08, 0x01        // sprmCFFldVanish
+     };
+     BYTE* pDataAdr = aArr1 + 2;
+     Set_UInt32( pDataAdr, nDataStt );
+ 
+     pChpPlc->AppendFkpEntry(Strm().Tell(),
+                 sizeof( aArr1 ), aArr1 );
+ 
+ 	sal_uInt8 aFldHeader[] = 
+ 	{
+ 		0xFF, 0xFF, 0xFF, 0xFF, // Unicode Marker...
+ 		0, 0, 0, 0, 0, 0 //, 0, 0
+ 	};
+ 
+ 	aFldHeader[4] |= (type & 0x03);
+ 	int ffres=rFieldmark.GetFFRes();
+ 	aFldHeader[4] |= ((ffres<<2) & 0x7C);
+ 
+ 	const String ffdeftext;
+ 	const String ffformat;
+ 	const String ffhelptext;
+ 	const String ffstattext;
+ 	const String ffentrymcr;
+ 	const String ffexitmcr;
+ 
+     const sal_uInt8 aFldData[] =
+     {
+         0,0,0,0,        // len of struct
+         0x44,0,         // the start of "next" data             
+         0,0,0,0,0,0,0,0,0,0,                // PIC-Structure!  /10
+         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    //  |              /16
+         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    //  |              /16
+         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    //  |              /16
+         0,0,0,0,                            // /               /4
+     };
+ 	int slen=sizeof(aFldData)
+ 		+sizeof(aFldHeader)
+ 		+2*ffname.Len()+4
+ 		+2*ffdeftext.Len()+4
+ 		+2*ffformat.Len()+4
+ 		+2*ffhelptext.Len()+4
+ 		+2*ffstattext.Len()+4
+ 		+2*ffentrymcr.Len()+4
+ 		+2*ffexitmcr.Len()+4;
+ #ifdef OSL_BIGENDIAN
+ 	slen=SWAPLONG(slen);
+ #endif // OSL_BIGENDIAN
+ 	*((sal_uInt32 *)aFldData)=slen;
+ 	int len=sizeof(aFldData) ;
+ 	assert(len==0x44);
+     pDataStrm->Write( aFldData, len);
+ 
+ 	len=sizeof(aFldHeader);
+ 	assert(len==8);
+     pDataStrm->Write( aFldHeader, len);
+ 
+     WriteString_xstz( *pDataStrm, ffname, true); // Form field name
+ 
+ 	if (type==0) {
+ 		WriteString_xstz( *pDataStrm, ffdeftext, true);
+ 	} else {
+ 		pDataStrm->WriteNumber((sal_uInt16)0);
+ 	}	
+ 	WriteString_xstz( *pDataStrm, ffformat, true);
+ 	WriteString_xstz( *pDataStrm, ffhelptext, true);
+ 	WriteString_xstz( *pDataStrm, ffstattext, true);
+ 	WriteString_xstz( *pDataStrm, ffentrymcr, true);
+ 	WriteString_xstz( *pDataStrm, ffexitmcr, true);
+ 	if (type==2) {
+ 		// 0xFF, 0xFF
+ 		// sal_uInt32 number of strings
+ 		// (sal_uInt16 len; sal_uInt16 unicode char[len])*num of strings
+ 	}
+ 
+ }
  
  /* vi:set tabstop=4 shiftwidth=4 expandtab: */
Index: sw/source/filter/ww8/wrtww8.hxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/wrtww8.hxx,v
retrieving revision 1.72
diff -c -r1.72 wrtww8.hxx
*** sw/source/filter/ww8/wrtww8.hxx	12 Jun 2007 05:56:09 -0000	1.72
--- sw/source/filter/ww8/wrtww8.hxx	21 Jan 2008 08:32:41 -0000
***************
*** 677,682 ****
--- 677,683 ----
      static void WriteString8(SvStream& rStrm, const String& rStr,
          bool bAddZero, rtl_TextEncoding eCodeSet);
  
+ 	static void WriteString_xstz(SvStream& rStrm, const String& rStr, bool bAddZero);
  #if 1
      //Prefer ww::bytes to WW8Bytes, migrate away from the other ones.
      static void InsUInt16(ww::bytes &rO, sal_uInt16 n);
***************
*** 733,738 ****
--- 734,741 ----
      void AddLinkTarget(const String& rURL);
      void CollectOutlineBookmarks(const SwDoc &rDoc);
      void AddBookmark(String sBkmkName);
+ 
+ 	void WriteFormData(SwFieldBookmark &rFieldmark);
  private:
      //No copying
      SwWW8Writer(const SwWW8Writer&);
Index: sw/source/filter/ww8/ww8par.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8par.cxx,v
retrieving revision 1.180
diff -c -r1.180 ww8par.cxx
*** sw/source/filter/ww8/ww8par.cxx	18 Jul 2007 14:46:00 -0000	1.180
--- sw/source/filter/ww8/ww8par.cxx	21 Jan 2008 08:32:44 -0000
***************
*** 286,291 ****
--- 286,293 ----
  #   include <svtools/itemiter.hxx>  //SfxItemIter
  #endif
  
+ #include <stdio.h>
+ 
  #define MM_250 1417             // WW-Default fuer Hor. Seitenraender: 2.5 cm
  #define MM_200 1134             // WW-Default fuer u.Seitenrand: 2.0 cm
  
***************
*** 1655,1660 ****
--- 1657,1666 ----
          }
      }
  
+     if (pWDop->fProtEnabled) {
+ 	rDoc.set(IDocumentSettingAccess::PROTECT_FORM, true );
+     }
+ 
      maTracer.LeaveEnvironment(sw::log::eDocumentProperties);
  }
  
***************
*** 1751,1756 ****
--- 1757,1763 ----
      maOldApos.push_back(false);
      maOldApos.swap(pRdr->maApos);
      maOldFieldStack.swap(pRdr->maFieldStack);
+ 	maFieldCtxStack.swap(pRdr->maNewFieldCtxStack);
  }
  
  void WW8ReaderSave::Restore( SwWW8ImplReader* pRdr )
***************
*** 1797,1802 ****
--- 1804,1810 ----
          pRdr->pPlcxMan->RestoreAllPLCFx(maPLCFxSave);
      pRdr->maApos.swap(maOldApos);
      pRdr->maFieldStack.swap(maOldFieldStack);
+ 	pRdr->maNewFieldCtxStack.swap(maFieldCtxStack);
  }
  
  void SwWW8ImplReader::Read_HdFtFtnText( const SwNodeIndex* pSttIdx,
***************
*** 2753,2758 ****
--- 2761,2781 ----
          case 0x15:
              if( !bSpec )        // Juristenparagraph
                  cInsert = '\xa7';
+ 			else { //0x15 is special --> so it's our field end mark...; hmmm what about field marks not handled by us??, maybe a problem with nested fields; probably an area of bugs... [well release quick and release often....]
+ 				if (!maNewFieldCtxStack.empty() && pPaM!=NULL && pPaM->GetPoint()!=NULL) {
+ 					WW8NewFieldCtx *pFieldCtx=maNewFieldCtxStack.back();
+ 					maNewFieldCtxStack.pop_back();
+ 					SwPaM aFldPam(pFieldCtx->GetRange(*pPaM->GetPoint()));
+ 					SwFieldBookmark *pFieldmark=(SwFieldBookmark*)rDoc.makeBookmark(aFldPam, KeyCode(), pFieldCtx->GetBookmarkName(), String(), IDocumentBookmarkAccess::FORM_FIELDMARK_TEXT);
+ 					ASSERT(pFieldmark!=NULL, "hmmm; why was the bookmark not created?");
+ 					if (pFieldmark!=NULL) {
+ 						pFieldmark->SetType(0); // 0==Text
+ 						// set field data here...
+ 						pFieldCtx->SetCurrentFieldParamsTo(*pFieldmark);
+ 					}
+ 					delete pFieldCtx;
+ 				}
+ 			}
              break;
          case 0x9:
              cInsert = '\x9';    // Tab
***************
*** 3528,3534 ****
  
          bool bInsertSection = aIter != aStart ? aIter->IsContinous() : false;
          bool bInsertPageDesc = !bInsertSection;
!         bool bProtected = SectionIsProtected(*aIter);
  
          if (bInsertPageDesc)
          {
--- 3551,3557 ----
  
          bool bInsertSection = aIter != aStart ? aIter->IsContinous() : false;
          bool bInsertPageDesc = !bInsertSection;
!         bool bProtected = false; //SectionIsProtected(*aIter);
  
          if (bInsertPageDesc)
          {
Index: sw/source/filter/ww8/ww8par.hxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8par.hxx,v
retrieving revision 1.150
diff -c -r1.150 ww8par.hxx
*** sw/source/filter/ww8/ww8par.hxx	18 Jul 2007 14:46:14 -0000	1.150
--- sw/source/filter/ww8/ww8par.hxx	21 Jan 2008 08:32:44 -0000
***************
*** 385,390 ****
--- 385,414 ----
      void Swap(FieldEntry &rOther) throw();
  };
  
+ class WW8NewFieldCtx
+ {
+ private:
+ 	SwNodeIndex maPtNode;
+     xub_StrLen mnPtCntnt;
+ 	::rtl::OUString sBookmarkName;
+ 	::rtl::OUString sBookmarkType;
+ 	typedef ::std::pair< ::rtl::OUString, ::rtl::OUString> Param_t;
+ 	typedef ::std::vector< Param_t > Params_t;
+ 	Params_t maParams;
+ 
+ public:
+ 	WW8NewFieldCtx(SwPosition &aStartPos, ::rtl::OUString sBookmarkName, ::rtl::OUString sBookmarkType);
+ 	~WW8NewFieldCtx();
+ 
+ 	SwPaM GetRange(SwPosition &aEndPos);
+ 	::rtl::OUString GetBookmarkName();
+ 	::rtl::OUString GetBookmarkType();
+ 	void AddParam(::rtl::OUString name, ::rtl::OUString value);
+ 	void SetCurrentFieldParamsTo(SwFieldBookmark &rFieldBookmark);
+ 
+ };
+ 
+ 
  //-----------------------------------------
  //    Mini-Merker fuer einige Flags
  //-----------------------------------------
***************
*** 417,422 ****
--- 441,447 ----
      bool mbWasParaEnd;
      bool mbHasBorder;
      bool mbFirstPara;
+ 	std::deque<WW8NewFieldCtx *> maFieldCtxStack;
  public:
      WW8ReaderSave(SwWW8ImplReader* pRdr, WW8_CP nStart=-1);
      void Restore(SwWW8ImplReader* pRdr);
***************
*** 863,868 ****
--- 888,896 ----
      std::deque<FieldEntry> maFieldStack;
      typedef std::deque<FieldEntry>::const_iterator mycFieldIter;
  
+ 	typedef std::deque<WW8NewFieldCtx *> WW8NewFieldCtxStack_t;
+ 	WW8NewFieldCtxStack_t maNewFieldCtxStack;
+ 
      /*
      A stack of open footnotes. Should only be one in it at any time.
      */
Index: sw/source/filter/ww8/ww8par3.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8par3.cxx,v
retrieving revision 1.83
diff -c -r1.83 ww8par3.cxx
*** sw/source/filter/ww8/ww8par3.cxx	10 May 2007 16:11:30 -0000	1.83
--- sw/source/filter/ww8/ww8par3.cxx	21 Jan 2008 08:32:45 -0000
***************
*** 221,229 ****
--- 221,283 ----
  #include "ww8par2.hxx"  // wg. Listen-Attributen in Styles
  #endif
  
+ #include <bookmrk.hxx>	
+ 
+ #include <stdio.h>
+ 
  using namespace com::sun::star;
  using namespace sw::util;
  using namespace sw::types;
+ 
+ WW8NewFieldCtx::WW8NewFieldCtx(SwPosition &aStartPos, ::rtl::OUString sBookmarkName, ::rtl::OUString sBookmarkType)
+ : maPtNode(aStartPos.nNode), mnPtCntnt(aStartPos.nContent.GetIndex()), 
+   sBookmarkName(sBookmarkName),
+   sBookmarkType(sBookmarkType)
+ {
+ }
+ 
+ 
+ WW8NewFieldCtx::~WW8NewFieldCtx()
+ {
+ }
+ 
+ 
+ SwPaM WW8NewFieldCtx::GetRange(SwPosition &aEndPos)
+ {
+ 	SwPosition aStartPos( maPtNode );
+ 	return SwPaM( maPtNode, mnPtCntnt, aEndPos.nNode, aEndPos.nContent.GetIndex());
+ }
+ 
+ ::rtl::OUString WW8NewFieldCtx::GetBookmarkName()
+ {
+ 	return sBookmarkName;
+ }
+ 
+ ::rtl::OUString WW8NewFieldCtx::GetBookmarkType()
+ {
+ 	return sBookmarkType;
+ }
+ 
+ void WW8NewFieldCtx::AddParam(::rtl::OUString name, ::rtl::OUString value)
+ {
+ 	maParams.push_back( Param_t(name, value) );
+ }
+ 
+ void WW8NewFieldCtx::SetCurrentFieldParamsTo(SwFieldBookmark &rFieldBookmark)
+ {
+ 	for(Params_t::iterator i=maParams.begin();i!=maParams.end();i++) {
+ 		::rtl::OUString aName=i->first;
+ 		::rtl::OUString aValue=i->second;
+ 		if (aName.compareToAscii("Description")==0) {
+ 			rFieldBookmark.SetFFHelpText(aValue);
+ 		} else if (aName.compareToAscii("Name")==0) {
+ 			rFieldBookmark.SetFFName(aValue);
+ 		} else if (aName.compareToAscii("Result")==0) {
+ 			rFieldBookmark.SetFFRes( aValue.toInt32() );
+ 		}
+ 	}
+ }
+ 
  //-----------------------------------------
  //            UNO-Controls
  //-----------------------------------------
***************
*** 239,248 ****
  
  eF_ResT SwWW8ImplReader::Read_F_FormTextBox( WW8FieldDesc* pF, String& rStr )
  {
      WW8FormulaEditBox aFormula(*this);
  
!     if (0x01 == rStr.GetChar(writer_cast<xub_StrLen>(pF->nLCode-1)))
          ImportFormulaControl(aFormula,pF->nSCode+pF->nLCode-1, WW8_CT_EDIT);
  
      /* #80205#
      Here we have a small complication. This formula control contains
--- 293,305 ----
  
  eF_ResT SwWW8ImplReader::Read_F_FormTextBox( WW8FieldDesc* pF, String& rStr )
  {
+     ::rtl::OUString us(rStr);
+     ::rtl::OString os=::rtl::OUStringToOString(us, RTL_TEXTENCODING_UTF8);
      WW8FormulaEditBox aFormula(*this);
  
!     if (0x01 == rStr.GetChar(writer_cast<xub_StrLen>(pF->nLCode-1))) {
          ImportFormulaControl(aFormula,pF->nSCode+pF->nLCode-1, WW8_CT_EDIT);
+     }
  
      /* #80205#
      Here we have a small complication. This formula control contains
***************
*** 254,263 ****
      the field result into the formula here in place of the default
      text.
      */
      aFormula.sDefault = GetFieldResult(pF);
  
      //substituting Unicode spacing 0x2002 with double space for layout
- #if 0
      aFormula.sDefault.SearchAndReplaceAll(
          String(static_cast< sal_Unicode >(0x2002)),
          CREATE_CONST_ASC("  "));
--- 311,322 ----
      the field result into the formula here in place of the default
      text.
      */
+ #if 0 // not needed any longer...
      aFormula.sDefault = GetFieldResult(pF);
  
+     ::rtl::OUString fdlResult(GetFieldResult(pF));
+     
      //substituting Unicode spacing 0x2002 with double space for layout
      aFormula.sDefault.SearchAndReplaceAll(
          String(static_cast< sal_Unicode >(0x2002)),
          CREATE_CONST_ASC("  "));
***************
*** 268,276 ****
      aFld.SetHelp(aFormula.sHelp);
      aFld.SetToolTip(aFormula.sToolTip);
  
!     rDoc.Insert(*pPaM, SwFmtFld(aFld), 0);
  
!     return FLD_OK;
  }
  
  eF_ResT SwWW8ImplReader::Read_F_FormCheckBox( WW8FieldDesc* pF, String& rStr )
--- 327,364 ----
      aFld.SetHelp(aFormula.sHelp);
      aFld.SetToolTip(aFormula.sToolTip);
  
! //    rDoc.Insert(*pPaM, SwFmtFld(aFld), 0); not needed any longer... // enable this if you want legacy fields..
  
! 	WW8PLCFx_Book* pB = pPlcxMan->GetBook();
! 	String aBookmarkName;
! 	if (pB!=NULL) {
! 		WW8_CP currentCP=pF->nSCode;
! 		WW8_CP currentLen=pF->nLen;
! 
! 		USHORT bkmFindIdx;
! 		String aBookmarkFind=pB->GetBookmark(currentCP-1, currentCP+currentLen-1, bkmFindIdx);
! 
! 		if (aBookmarkFind.Len()>0) { 
! 			pB->SetStatus(bkmFindIdx, BOOK_FIELD); // mark bookmark as consumed, such that tl'll not get inserted as a "normal" bookmark again
! 			if (aBookmarkFind.Len()>0) {
! 				aBookmarkName=aBookmarkFind;
! 			}
! 		}
! 	}
! 
! 	if (pB!=NULL && aBookmarkName.Len()==0) {
! 		aBookmarkName=pB->GetUniqueBookmarkName(aFormula.sTitle);
! 	}
! 
! 
! 	if (aBookmarkName.Len()>0) {
! 		WW8NewFieldCtx *pFieldCtx=new WW8NewFieldCtx(*pPaM->GetPoint(), aBookmarkName, ::rtl::OUString::createFromAscii("ecma.office-open-xml.field.FORMTEXT"));
! 		maNewFieldCtxStack.push_back(pFieldCtx);
! 		pFieldCtx->AddParam(::rtl::OUString::createFromAscii("Description"), aFormula.sToolTip);
! 		pFieldCtx->AddParam(::rtl::OUString::createFromAscii("Name"), aFormula.sTitle);
! 	}
! 
!     return FLD_TEXT; //FLD_OK;
  }
  
  eF_ResT SwWW8ImplReader::Read_F_FormCheckBox( WW8FieldDesc* pF, String& rStr )
***************
*** 283,289 ****
      if (0x01 == rStr.GetChar(writer_cast<xub_StrLen>(pF->nLCode-1)))
          ImportFormulaControl(aFormula,pF->nSCode+pF->nLCode-1, WW8_CT_CHECKBOX);
  
!     pFormImpl->InsertFormula(aFormula);
      return FLD_OK;
  }
  
--- 371,410 ----
      if (0x01 == rStr.GetChar(writer_cast<xub_StrLen>(pF->nLCode-1)))
          ImportFormulaControl(aFormula,pF->nSCode+pF->nLCode-1, WW8_CT_CHECKBOX);
  
! //    pFormImpl->InsertFormula(aFormula); not needed anymore; enable this if you want legacy field support
! 
! 	String aBookmarkName;
!     WW8PLCFx_Book* pB = pPlcxMan->GetBook();
! 	if (pB!=NULL) {
! 		WW8_CP currentCP=pF->nSCode;
! 		WW8_CP currentLen=pF->nLen;
! 
! 		USHORT bkmFindIdx;
! 		String aBookmarkFind=pB->GetBookmark(currentCP-1, currentCP+currentLen-1, bkmFindIdx);
! 
! 		if (aBookmarkFind.Len()>0) { 
! 			pB->SetStatus(bkmFindIdx, BOOK_FIELD); // mark as consumed by field
! 			if (aBookmarkFind.Len()>0) {
! 				aBookmarkName=aBookmarkFind;
! 			}
! 		}
! 	}
! 
! 	if (pB!=NULL && aBookmarkName.Len()==0) {
! 		aBookmarkName=pB->GetUniqueBookmarkName(aFormula.sTitle);
! 	}
! 
! 	if (aBookmarkName.Len()>0) {
! 		SwFieldBookmark *pFieldmark=(SwFieldBookmark*)rDoc.makeBookmark(*pPaM, KeyCode(), aBookmarkName, String(), IDocumentBookmarkAccess::FORM_FIELDMARK_NO_TEXT);
! 		ASSERT(pFieldmark!=NULL, "hmmm; why was the bookmark not created?");
! 		if (pFieldmark!=NULL) {
! 			pFieldmark->SetType(1); // 0==Checkbox
! 			pFieldmark->SetFFName(aFormula.sTitle);
! 			pFieldmark->SetFFHelpText(aFormula.sToolTip);
! 			pFieldmark->SetChecked(aFormula.nChecked!=0);
! 			// set field data here...
! 		}
! 	}
      return FLD_OK;
  }
  
***************
*** 2041,2046 ****
--- 2162,2171 ----
      if((aPic.lcb > 0x3A) && !pDataStream->GetError() )
      {
          pDataStream->Seek( nPicLocFc + aPic.cbHeader );
+ 		int len=aPic.lcb-aPic.cbHeader;
+ 		char *pBuf=(char*)malloc(len);
+ 		pDataStream->Read( pBuf, len);
+         pDataStream->Seek( nPicLocFc + aPic.cbHeader );
          aFormula.FormulaRead(nWhich,pDataStream);
          bRet = true;
      }
Index: sw/source/filter/ww8/ww8par5.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8par5.cxx,v
retrieving revision 1.103
diff -c -r1.103 ww8par5.cxx
*** sw/source/filter/ww8/ww8par5.cxx	18 Jul 2007 14:46:57 -0000	1.103
--- sw/source/filter/ww8/ww8par5.cxx	21 Jan 2008 08:32:46 -0000
***************
*** 415,421 ****
      if (pB->GetIsEnd())
      {
          pReffedStck->SetAttr(*pPaM->GetPoint(), RES_FLTR_BOOKMARK, true,
!             pB->GetHandle());
          return 0;
      }
  
--- 415,421 ----
      if (pB->GetIsEnd())
      {
          pReffedStck->SetAttr(*pPaM->GetPoint(), RES_FLTR_BOOKMARK, true,
!             pB->GetHandle(), (eB & BOOK_FIELD)!=0);
          return 0;
      }
  
Index: sw/source/filter/ww8/ww8scan.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8scan.cxx,v
retrieving revision 1.132
diff -c -r1.132 ww8scan.cxx
*** sw/source/filter/ww8/ww8scan.cxx	25 May 2007 13:03:35 -0000	1.132
--- sw/source/filter/ww8/ww8scan.cxx	21 Jan 2008 08:32:48 -0000
***************
*** 3955,3961 ****
  }
  
  WW8PLCFx_Book::WW8PLCFx_Book(SvStream* pTblSt, const WW8Fib& rFib)
!     : WW8PLCFx(rFib.GetFIBVersion(), false), pStatus(0), nIsEnd(0)
  {
      if( !rFib.fcPlcfbkf || !rFib.lcbPlcfbkf || !rFib.fcPlcfbkl ||
          !rFib.lcbPlcfbkl || !rFib.fcSttbfbkmk || !rFib.lcbSttbfbkmk )
--- 3955,3961 ----
  }
  
  WW8PLCFx_Book::WW8PLCFx_Book(SvStream* pTblSt, const WW8Fib& rFib)
!     : WW8PLCFx(rFib.GetFIBVersion(), false), pStatus(0), nIsEnd(0), nBookmarkId(1)
  {
      if( !rFib.fcPlcfbkf || !rFib.lcbPlcfbkf || !rFib.fcPlcfbkl ||
          !rFib.lcbPlcfbkl || !rFib.fcSttbfbkmk || !rFib.lcbSttbfbkmk )
***************
*** 4166,4171 ****
--- 4166,4191 ----
      return bFound ? aBookNames[i] : aEmptyStr;
  }
  
+ String WW8PLCFx_Book::GetUniqueBookmarkName(String &suggestedName)
+ {
+ 	String aRet=(suggestedName.Len()==0?String::CreateFromAscii("Unnamed"):suggestedName);
+ 	int i=0;
+ 	while(i<aBookNames.size()) {
+ 		String &s=aBookNames[i];
+ 		if (aRet.CompareTo(s)==0) {
+ 			int len=aRet.Len();
+ 			int p=len-1;
+ 			while(p>0 && aRet.GetChar(p)>='0' && aRet.GetChar(p)<='9') p--;
+ 			aRet=String(aRet, 0, p+1);
+ 			aRet += String::CreateFromInt32( nBookmarkId++ );
+ 			i=0; // start search from beginning
+ 		} else {
+ 			i++;
+ 		}
+ 	}
+ 	return aRet;
+ }
+ 
  bool WW8PLCFx_Book::MapName(String& rName)
  {
      if( !pBook[0] || !pBook[1] )
Index: sw/source/filter/ww8/ww8scan.hxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8scan.hxx,v
retrieving revision 1.79
diff -c -r1.79 ww8scan.hxx
*** sw/source/filter/ww8/ww8scan.hxx	3 Jan 2007 11:32:33 -0000	1.79
--- sw/source/filter/ww8/ww8scan.hxx	21 Jan 2008 08:32:50 -0000
***************
*** 732,738 ****
      bool GetPara(long nIdx, WW8FieldDesc& rF);
  };
  
! enum eBookStatus { BOOK_NORMAL = 0, BOOK_IGNORE = 0x1 };
  
  // Iterator for Booknotes
  class WW8PLCFx_Book : public WW8PLCFx
--- 732,738 ----
      bool GetPara(long nIdx, WW8FieldDesc& rF);
  };
  
! enum eBookStatus { BOOK_NORMAL = 0, BOOK_IGNORE = 0x1, BOOK_FIELD = 0x2 };
  
  // Iterator for Booknotes
  class WW8PLCFx_Book : public WW8PLCFx
***************
*** 743,748 ****
--- 743,749 ----
      eBookStatus* pStatus;
      long nIMax;                         // Number of Booknotes
      USHORT nIsEnd;
+ 	int nBookmarkId; // counter incremented by GetUniqueBookmarkName.
      
      //No copying
      WW8PLCFx_Book(const WW8PLCFx_Book&);
***************
*** 769,774 ****
--- 770,776 ----
      bool MapName(String& rName);
      String GetBookmark(long nStart,long nEnd, USHORT &nIndex);
      eBookStatus GetStatus() const;
+ 	String GetUniqueBookmarkName(String &suggestedName);
  };
  
  /*
Index: sw/source/ui/docvw/edtwin.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/docvw/edtwin.cxx,v
retrieving revision 1.144
diff -c -r1.144 edtwin.cxx
*** sw/source/ui/docvw/edtwin.cxx	25 Jul 2007 09:37:59 -0000	1.144
--- sw/source/ui/docvw/edtwin.cxx	21 Jan 2008 08:32:51 -0000
***************
*** 322,327 ****
--- 322,330 ----
  #include <vcl/svapp.hxx>
  #endif
  
+ #include <bookmrk.hxx>
+ #include <doc.hxx>
+ 
  //JP 11.10.2001: enable test code for bug fix 91313
  #if !defined( PRODUCT ) && (OSL_DEBUG_LEVEL > 1)
  //#define TEST_FOR_BUG91313
***************
*** 1559,1564 ****
--- 1562,1571 ----
                         KS_Fly_Change, KS_Draw_Change,
                         KS_SpecialInsert,
                         KS_EnterCharCell,
+ 
+ 		       KS_GotoNextFieldBookmark,
+ 		       KS_GotoPrevFieldBookmark,
+ 
                         KS_Ende };
  
  	SW_KeyState eKeyState = bIsDocReadOnly ? KS_CheckDocReadOnlyKeys
***************
*** 1977,1986 ****
  					break;
                  case KEY_TAB:
  				{
  #ifdef SW_CRSR_TIMER
  					BOOL bOld = rSh.ChgCrsrTimerFlag( FALSE );
  #endif
! 					if( rSh.GetCurNumRule() && rSh.IsSttOfPara() &&
  						!rSh.HasReadonlySel() )
                      {
                          if (rSh.IsFirstOfNumRule()) // #i23725#
--- 1984,1998 ----
  					break;
                  case KEY_TAB:
  				{
+ 				    sal_Unicode ch=rSh.GetChar();
+ 
  #ifdef SW_CRSR_TIMER
  					BOOL bOld = rSh.ChgCrsrTimerFlag( FALSE );
  #endif
! 					if (rSh.IsFormProtected() || rSh.IsInFieldBookmark()!=NULL || rSh.GetChar(FALSE)==CH_TXT_ATR_FORMELEMENT) {
! 					    eKeyState=KS_GotoNextFieldBookmark; 
! 					}
! 					else if( rSh.GetCurNumRule() && rSh.IsSttOfPara() &&
  						!rSh.HasReadonlySel() )
                      {
                          if (rSh.IsFirstOfNumRule()) // #i23725#
***************
*** 2025,2032 ****
  #ifdef SW_CRSR_TIMER
  					BOOL bOld = rSh.ChgCrsrTimerFlag( FALSE );
  #endif
! 					if( rSh.GetCurNumRule() && rSh.IsSttOfPara() &&
! 						!rSh.HasReadonlySel() )
                      {
                          if (rSh.IsFirstOfNumRule()) // #i23725#
                              eKeyState = KS_NumIndentDec;
--- 2037,2047 ----
  #ifdef SW_CRSR_TIMER
  					BOOL bOld = rSh.ChgCrsrTimerFlag( FALSE );
  #endif
! 					if (rSh.IsFormProtected() || rSh.IsInFieldBookmark()!=NULL || rSh.GetChar(FALSE)==CH_TXT_ATR_FORMELEMENT) {
! 					    eKeyState=KS_GotoPrevFieldBookmark; 
! 					}
! 					else if( rSh.GetCurNumRule() && rSh.IsSttOfPara() &&
! 						 !rSh.HasReadonlySel() )
                      {
                          if (rSh.IsFirstOfNumRule()) // #i23725#
                              eKeyState = KS_NumIndentDec;
***************
*** 2269,2275 ****
  			aCh = '\t';
  			// kein break!
  		case KS_InsChar:
! 		if( !rSh.HasReadonlySel() )
  		{
  			BOOL bIsNormalChar = GetAppCharClass().isLetterNumeric(
  														String( aCh ), 0 );
--- 2284,2312 ----
  			aCh = '\t';
  			// kein break!
  		case KS_InsChar:
! 		if (rSh.GetChar(FALSE)==CH_TXT_ATR_FORMELEMENT) {
! 		    SwFieldBookmark *fieldBM=rSh.IsInFormFieldBookmark(); //$flr refactor!!!
!    		    ASSERT(fieldBM!=NULL, "Where is my FieldBookmark??");
! 		    if (fieldBM!=NULL) {
! 			fieldBM->SetChecked(!fieldBM->IsChecked());
! 			SwDocShell* pDocSh = rView.GetDocShell();
! 			SwDoc *pDoc=pDocSh->GetDoc();
! 			ASSERT(fieldBM->GetOtherPos()!=NULL, "where is the otherpos?");
! 			if (fieldBM->GetOtherPos()!=NULL) {
! 			    SwPaM aPaM(fieldBM->GetPos(), *fieldBM->GetOtherPos());
! 			    if (0) {
! 				rSh.StartAllAction();  //$flr TODO: understand why this not works
! 				pDoc->SetModified(aPaM);
! 				rSh.EndAllAction();
! 			    } else {
! 				rSh.CalcLayout(); // workaround
! 			    }
! 			}
! 			
! 		    }
! //		    rSh.Overwrite(String('X'));
! 		    eKeyState = KS_Ende;
! 		} else if( !rSh.HasReadonlySel() )
  		{
  			BOOL bIsNormalChar = GetAppCharClass().isLetterNumeric(
  														String( aCh ), 0 );
***************
*** 2378,2383 ****
--- 2415,2438 ----
                  nKS_NUMINDENTINC_Count = 2;
                  break;
  
+ 	    case KS_GotoNextFieldBookmark:	    
+ 	    {
+ 		SwBookmark *pBM=rSh.GetNextFieldBookmark();
+ 		if (pBM!=NULL) {
+ 		    rSh.GotoFieldBookmark(pBM);
+ 		}
+ 	    }
+ 	        break;
+ 
+ 	    case KS_GotoPrevFieldBookmark:	    
+ 	    {
+ 		SwBookmark *pBM=rSh.GetPrevFieldBookmark();
+ 		if (pBM!=NULL) {
+ 		    rSh.GotoFieldBookmark(pBM);
+ 		}
+ 	    }
+ 	        break;
+ 
              case KS_NumIndentDec:
                  rSh.NumIndent(-360);
                  break;
Index: sw/source/ui/inc/wrtsh.hxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/inc/wrtsh.hxx,v
retrieving revision 1.38
diff -c -r1.38 wrtsh.hxx
*** sw/source/ui/inc/wrtsh.hxx	5 Jul 2007 13:13:40 -0000	1.38
--- sw/source/ui/inc/wrtsh.hxx	21 Jan 2008 08:32:52 -0000
***************
*** 399,404 ****
--- 399,406 ----
  	FASTBOOL GoNextBookmark(); // TRUE, wenn's noch eine gab
  	FASTBOOL GoPrevBookmark();
  
+         bool GotoFieldBookmark(SwBookmark *pBkmk);
+ 
  	// jump to the next / previous hyperlink - inside text and also
  	// on graphics
  	FASTBOOL SelectNextPrevHyperlink( BOOL bNext = TRUE );
Index: sw/source/ui/uno/SwXDocumentSettings.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/uno/SwXDocumentSettings.cxx,v
retrieving revision 1.56
diff -c -r1.56 SwXDocumentSettings.cxx
*** sw/source/ui/uno/SwXDocumentSettings.cxx	17 Jul 2007 13:12:39 -0000	1.56
--- sw/source/ui/uno/SwXDocumentSettings.cxx	21 Jan 2008 08:32:55 -0000
***************
*** 160,166 ****
      HANDLE_CLIP_AS_CHARACTER_ANCHORED_WRITER_FLY_FRAMES,
      HANDLE_UNIX_FORCE_ZERO_EXT_LEADING,
      HANDLE_USE_OLD_PRINTER_METRICS,
!     HANDLE_TABS_RELATIVE_TO_INDENT
  };
  
  MasterPropertySetInfo * lcl_createSettingsInfo()
--- 160,167 ----
      HANDLE_CLIP_AS_CHARACTER_ANCHORED_WRITER_FLY_FRAMES,
      HANDLE_UNIX_FORCE_ZERO_EXT_LEADING,
      HANDLE_USE_OLD_PRINTER_METRICS,
!     HANDLE_TABS_RELATIVE_TO_INDENT,
!     HANDLE_PROTECT_FORM
  };
  
  MasterPropertySetInfo * lcl_createSettingsInfo()
***************
*** 211,216 ****
--- 212,218 ----
          { RTL_CONSTASCII_STRINGPARAM("UnxForceZeroExtLeading"), HANDLE_UNIX_FORCE_ZERO_EXT_LEADING, CPPUTYPE_BOOLEAN, 0, 0},
          { RTL_CONSTASCII_STRINGPARAM("UseOldPrinterMetrics"), HANDLE_USE_OLD_PRINTER_METRICS, CPPUTYPE_BOOLEAN, 0, 0},
          { RTL_CONSTASCII_STRINGPARAM("TabsRelativeToIndent"), HANDLE_TABS_RELATIVE_TO_INDENT, CPPUTYPE_BOOLEAN, 0, 0},
+         { RTL_CONSTASCII_STRINGPARAM("ProtectForm"), HANDLE_PROTECT_FORM, CPPUTYPE_BOOLEAN, 0, 0},
  
  /*
   * As OS said, we don't have a view when we need to set this, so I have to
***************
*** 683,688 ****
--- 685,696 ----
              mpDoc->set(IDocumentSettingAccess::USE_OLD_PRINTER_METRICS, bTmp);
          }
          break;
+         case HANDLE_PROTECT_FORM:
+         {
+             sal_Bool bTmp = *(sal_Bool*)rValue.getValue();
+             mpDoc->set(IDocumentSettingAccess::PROTECT_FORM, bTmp);
+         }
+         break;
  
          default:
  			throw UnknownPropertyException();
***************
*** 977,982 ****
--- 985,996 ----
              rValue.setValue( &bTmp, ::getBooleanCppuType() );
          }
          break;
+         case HANDLE_PROTECT_FORM:
+         {
+             sal_Bool bTmp = mpDoc->get(IDocumentSettingAccess::PROTECT_FORM);
+             rValue.setValue( &bTmp, ::getBooleanCppuType() );
+         }
+         break;
  
          default:
  			throw UnknownPropertyException();
Index: sw/source/ui/wrtsh/wrtsh3.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/wrtsh/wrtsh3.cxx,v
retrieving revision 1.12
diff -c -r1.12 wrtsh3.cxx
*** sw/source/ui/wrtsh/wrtsh3.cxx	16 Sep 2006 23:40:25 -0000	1.12
--- sw/source/ui/wrtsh/wrtsh3.cxx	21 Jan 2008 08:32:56 -0000
***************
*** 116,121 ****
--- 116,139 ----
  }
  
  
+ bool SwWrtShell::GotoFieldBookmark(SwBookmark *pBkmk)
+ {
+    (this->*fnKillSel)( 0, sal_False );
+ 
+     bool bRet = SwCrsrShell::GotoFieldBookmark(pBkmk);
+     if( bRet && IsSelFrmMode() )
+     {
+         UnSelectFrm();
+         LeaveSelFrmMode();
+     }
+     if( IsSelection() )
+     {
+         fnKillSel = &SwWrtShell::ResetSelect;
+         fnSetCrsr = &SwWrtShell::SetCrsrKillSel;
+     }
+     return bRet;
+ }
+ 
  /*--------------------------------------------------------------------
      Beschreibung: FontWork-Slots invalidieren
   --------------------------------------------------------------------*/
