--- /dev/null	2005-03-20 01:06:14.000000000 +0530
+++ connectivity/source/drivers/mdb/mdb_preparedstatement.cxx	2005-06-29 11:18:53.000000000 +0530
@@ -0,0 +1,737 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+
+#include "mdb_preparedstatement.hxx"
+#include "mdb_resultset.hxx"
+
+#include <rtl/strbuf.hxx>
+#include <rtl/ustrbuf.hxx>
+
+
+#include <cppuhelper/typeprovider.hxx>
+#include <cppuhelper/queryinterface.hxx>
+
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+#include <com/sun/star/sdbc/ResultSetConcurrency.hpp>
+#include <com/sun/star/sdbc/ResultSetType.hpp>
+
+using osl::Mutex;
+using osl::MutexGuard;
+
+using rtl::OUString;
+using rtl::OUStringToOString;
+using rtl::OStringToOUString;
+using rtl::OUStringBuffer;
+using rtl::OStringBuffer;
+using rtl::OString;
+
+using com::sun::star::uno::Any;
+using com::sun::star::uno::makeAny;
+using com::sun::star::uno::Type;
+using com::sun::star::uno::RuntimeException;
+using com::sun::star::uno::Exception;
+using com::sun::star::uno::Sequence;
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::XInterface;
+
+using com::sun::star::lang::IllegalArgumentException;
+
+using com::sun::star::sdbc::XWarningsSupplier;
+using com::sun::star::sdbc::XCloseable;
+using com::sun::star::sdbc::XPreparedStatement;
+using com::sun::star::sdbc::XParameters;
+using com::sun::star::sdbc::XResultSet;
+using com::sun::star::sdbc::XRef;
+using com::sun::star::sdbc::XBlob;
+using com::sun::star::sdbc::XClob;
+using com::sun::star::sdbc::XArray;
+using com::sun::star::sdbc::XConnection;
+using com::sun::star::sdbc::SQLException;
+
+using com::sun::star::beans::Property;
+using com::sun::star::beans::XPropertySetInfo;
+using com::sun::star::beans::XPropertySet;
+using com::sun::star::beans::XMultiPropertySet;
+using com::sun::star::beans::XFastPropertySet;
+
+#define ASCII_STR(x) OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+namespace mdb_sdbc_driver
+{
+static ::cppu::IPropertyArrayHelper & getPreparedStatementPropertyArrayHelper()
+{
+    static ::cppu::IPropertyArrayHelper *pArrayHelper;
+	if( ! pArrayHelper )
+    {
+		MutexGuard guard( Mutex::getGlobalMutex() );
+		if( ! pArrayHelper )
+        {
+            static Property aTable[] =
+                {
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("CursorName") ), 0,
+                        ::getCppuType( (OUString *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("EscapeProcessing") ), 0,
+                        ::getBooleanCppuType() , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("FetchDirection") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("FetchSize") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("MaxFieldSize") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("MaxRows") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("QueryTimeOut") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("ResultSetConcurrency") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("ResultSetType") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 )
+                };
+            OSL_ASSERT( sizeof(aTable)/ sizeof(Property)  == PREPARED_STATEMENT_SIZE );
+			static ::cppu::OPropertyArrayHelper arrayHelper( aTable, PREPARED_STATEMENT_SIZE, sal_True );
+            pArrayHelper = &arrayHelper;
+        }
+    }
+    return *pArrayHelper;
+}
+
+PreparedStatement::PreparedStatement(
+    const ::rtl::Reference< RefCountedMutex > & refMutex,
+    const Reference< XConnection > & conn,
+    struct ConnectionSettings *pSettings,
+    const ::rtl::OString & stmt )
+    : OComponentHelper( refMutex->mutex ),
+      OPropertySetHelper( OComponentHelper::rBHelper ),
+      m_refMutex( refMutex ),
+      m_connection( conn ), 
+      m_pSettings( pSettings ),
+      m_stmt( stmt )
+{
+    m_props[PREPARED_STATEMENT_QUERY_TIME_OUT] = makeAny( (sal_Int32)0 );
+    m_props[PREPARED_STATEMENT_MAX_ROWS] = makeAny( (sal_Int32)0 );
+    m_props[PREPARED_STATEMENT_RESULT_SET_CONCURRENCY] = makeAny(
+        com::sun::star::sdbc::ResultSetConcurrency::READ_ONLY );
+    m_props[PREPARED_STATEMENT_RESULT_SET_TYPE] = makeAny(
+        com::sun::star::sdbc::ResultSetType::SCROLL_INSENSITIVE );
+
+    int elements = 0;
+    for ( int i = m_stmt.indexOf( '?' ) ; i != -1 ; i = m_stmt.indexOf( '?' , i +1)  )
+    {
+        elements ++;
+    }
+    m_vars = OStringVector ( elements );
+}
+
+PreparedStatement::~PreparedStatement()
+{
+    POSTGRE_TRACE( "dtor PreparedStatement" );
+}
+
+void PreparedStatement::checkColumnIndex( sal_Int32 parameterIndex )
+{
+    if( parameterIndex < 1 || parameterIndex > (sal_Int32) m_vars.size() )
+    {
+        OUStringBuffer buf( 128 );
+        buf.appendAscii( "mdb_preparedstatement: parameter index out of range (expected 1 to " );
+        buf.append( (sal_Int32 ) m_vars.size() );
+        buf.appendAscii( ", got " );
+        buf.append( parameterIndex );
+        buf.appendAscii( ")" );
+        throw SQLException( buf.makeStringAndClear(), *this, OUString(), 1, Any () );
+    }
+}
+void PreparedStatement::checkClosed() throw (SQLException, RuntimeException )
+{
+    if( ! m_pSettings || ! m_pSettings->pConnection )
+        throw SQLException(
+            ASCII_STR("mdb_driver: PreparedStatement or connection has already been closed !" ),
+            *this, OUString(),1,Any());
+}
+
+Any PreparedStatement::queryInterface( const Type & reqType ) throw (RuntimeException)
+{
+    Any ret;
+
+    ret = OComponentHelper::queryInterface( reqType );
+    if( ! ret.hasValue() )
+        ret = ::cppu::queryInterface( reqType,
+                                    static_cast< XWarningsSupplier * > ( this  ),
+                                    static_cast< XPreparedStatement * > ( this ),
+                                    static_cast< XParameters * > ( this ),
+                                    static_cast< XCloseable * > ( this ),
+                                    static_cast< XPropertySet * > ( this ),
+                                    static_cast< XMultiPropertySet * > ( this ),
+                                    static_cast< XFastPropertySet * > ( this ) );
+    return ret;
+}
+
+
+Sequence< Type > PreparedStatement::getTypes() throw ( RuntimeException )
+{
+    static cppu::OTypeCollection *pCollection;
+    if( ! pCollection )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        if( !pCollection )
+        {
+            static cppu::OTypeCollection collection(
+                getCppuType( (Reference< XWarningsSupplier> *) 0 ),
+                getCppuType( (Reference< XPreparedStatement> *) 0 ),
+                getCppuType( (Reference< XParameters> *) 0 ),
+                getCppuType( (Reference< XCloseable> *) 0 ),
+                getCppuType( (Reference< XPropertySet >*) 0 ),
+                getCppuType( (Reference< XFastPropertySet > *) 0 ),
+                getCppuType( (Reference< XMultiPropertySet > *) 0 ),
+                OComponentHelper::getTypes());
+            pCollection = &collection;
+        }
+    }
+    return pCollection->getTypes();
+}
+
+Sequence< sal_Int8> PreparedStatement::getImplementationId() throw ( RuntimeException )
+{
+    static cppu::OImplementationId *pId;
+    if( ! pId )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        if( ! pId )
+        {
+            static cppu::OImplementationId id(sal_False);
+            pId = &id;
+        }
+    }
+    return pId->getImplementationId();
+}
+
+void PreparedStatement::close(  ) throw (SQLException, RuntimeException)
+{
+    // let the connection die without acquired mutex !
+    Reference< XConnection > r;
+    Reference< XCloseable > resultSet;
+    {
+        MutexGuard guard( m_refMutex->mutex );
+        m_pSettings = 0;
+        r = m_connection;
+        m_connection.clear();
+        
+        resultSet = m_lastResultset;
+        m_lastResultset.clear();
+    }
+    if( resultSet.is() )
+    {
+        resultSet->close();
+        POSTGRE_TRACE( "statement closed" );
+    }
+}
+
+// void PreparedStatement::raiseSQLException(
+//     const OUString & sql, const char * errorMsg, const char *errorType )
+//     throw( SQLException )
+// {
+//     OUStringBuffer buf(128);
+//     buf.appendAscii( "mdb_driver: ");
+//     if( errorType )
+//     {
+//         buf.appendAscii( "[" );
+//         buf.appendAscii( errorType );
+//         buf.appendAscii( "]" );
+//     }
+//     buf.append(
+//         rtl::OStringToOUString( errorMsg, strlen(errorMsg) , m_pSettings->encoding ) );
+//     buf.appendAscii( " (caused by statement '" );
+//     buf.append( sql );
+//     buf.appendAscii( "')" );
+//     throw SQLException( buf.makeStringAndClear(), *this, OUString(), 1, Any() );
+// }
+
+
+Reference< XResultSet > PreparedStatement::mdbExecute( OString *pQuery )
+{
+    OStringBuffer buf( m_stmt.getLength() *2 );
+
+    int element = 0;
+    int before = 0;
+    for ( int i = m_stmt.indexOf( '?' ) ; i != -1 ; i = m_stmt.indexOf( '?' , i +1)  )
+    {
+        buf.append( m_stmt.getStr() +  before, i - before );
+        buf.append( m_vars[element] );
+        before = i+1;
+        element ++;
+    }
+    buf.append( m_stmt.getStr() + before );
+
+    *pQuery = buf.makeStringAndClear();
+    
+    osl::ClearableMutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+	AnyVector aRows;
+    Sequence< OUString > seqColumns;
+	::rtl::OString o = *pQuery;
+	if (!mdb_ExecuteQuery(
+			m_pSettings->pConnection,o,aRows,seqColumns)
+		)
+	{
+ 	   return new ResultSet(
+    	    m_refMutex, *this, Sequence< OUString >(), Sequence< Sequence< Any > > (), m_pSettings->tc );
+	}
+
+    return new ResultSet(
+        m_refMutex, *this,    seqColumns,
+        Sequence< Sequence< Any > > ( &aRows[0],aRows.size() ), m_pSettings->tc );
+}
+
+Reference< XResultSet > PreparedStatement::executeQuery( )
+        throw (SQLException, RuntimeException)
+{
+    osl::ClearableMutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    OString query;
+    return mdbExecute( &query );
+}
+
+sal_Int32 PreparedStatement::executeUpdate( )
+        throw (SQLException, RuntimeException)
+{
+    osl::ClearableMutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+
+    OString query;
+	Reference< XResultSet > result = mdbExecute( &query);
+/*
+    ExecStatusType state = PQresultStatus( result );
+    switch( state )
+    {
+    case PGRES_COMMAND_OK: // success
+        break; 
+    case PGRES_TUPLES_OK: 
+    {
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_preparedstatement: statment is not a command, use executeQuery() instead (" );
+        buf.append( OStringToOUString( query , m_pSettings->encoding ) );
+        buf.appendAscii( ")" );
+        throw SQLException(buf.makeStringAndClear(), *this, OUString() , 1 , Any() );
+    }
+    case PGRES_EMPTY_QUERY:
+    case PGRES_COPY_OUT:
+    case PGRES_COPY_IN:
+    case PGRES_BAD_RESPONSE:
+    case PGRES_NONFATAL_ERROR:
+    case PGRES_FATAL_ERROR:
+    default:
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_preparedstatement: " );
+        buf.appendAscii( PQresultErrorMessage( result ) );
+        buf.appendAscii( " during command '" );
+        buf.append( OStringToOUString( query, m_pSettings->encoding ) );
+        buf.appendAscii( "')" );
+        throw SQLException(buf.makeStringAndClear(), *this, OUString() , 1 , Any() );
+    }
+
+    Reference< XCloseable > lastResultSet = m_lastResultset;
+    m_lastResultset.clear();
+    sal_Int32 affectedTuples = atoi( PQcmdTuples(result) );
+    PQclear( result );
+    guard.clear();
+
+    if( lastResultSet.is())
+        lastResultSet->close();
+    return affectedTuples;
+*/
+return 0;
+}
+
+sal_Bool PreparedStatement::execute( )
+        throw (SQLException, RuntimeException)
+{
+    throw SQLException( ASCII_STR( "mdb_statement: execute() method is not supported, use executeUpdate or executeQuery instead" ),
+                        *this, OUString() , 1 , Any () );
+    return sal_False;
+}
+
+Reference< XConnection > PreparedStatement::getConnection(  )
+        throw (SQLException, RuntimeException)
+{
+    Reference< XConnection > ret;
+    {
+        MutexGuard guard( m_refMutex->mutex );
+        checkClosed();
+        ret = m_connection;
+    }
+    return ret;
+}
+
+
+void PreparedStatement::setNull( sal_Int32 parameterIndex, sal_Int32 sqlType )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    m_vars[parameterIndex-1] = OString( "NULL" );
+}
+
+void PreparedStatement::setObjectNull(
+    sal_Int32 parameterIndex, sal_Int32 sqlType, const ::rtl::OUString& typeName )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    m_vars[parameterIndex-1] = OString( "NULL" );
+}
+
+
+void PreparedStatement::setBoolean( sal_Int32 parameterIndex, sal_Bool x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    if( x )
+        m_vars[parameterIndex-1] = OString( "'t'" );
+    else
+        m_vars[parameterIndex-1] = OString( "'f'" );
+}
+
+void PreparedStatement::setByte( sal_Int32 parameterIndex, sal_Int8 x )
+    throw (SQLException, RuntimeException)
+{
+    setInt(parameterIndex,x);
+}
+
+void PreparedStatement::setShort( sal_Int32 parameterIndex, sal_Int16 x )
+    throw (SQLException, RuntimeException)
+{
+    setInt(parameterIndex, x );
+}
+
+void PreparedStatement::setInt( sal_Int32 parameterIndex, sal_Int32 x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    OStringBuffer buf( 20 );
+    buf.append( "'" );
+    buf.append( (sal_Int32) x );
+    buf.append( "'" );
+    m_vars[parameterIndex-1] = buf.makeStringAndClear();
+}
+
+void PreparedStatement::setLong( sal_Int32 parameterIndex, sal_Int64 x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    OStringBuffer buf( 20 );
+    buf.append( "'" );
+    buf.append( (sal_Int64) x );
+    buf.append( "'" );
+    m_vars[parameterIndex-1] = buf.makeStringAndClear();    
+}
+
+void PreparedStatement::setFloat( sal_Int32 parameterIndex, float x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    OStringBuffer buf( 20 );
+    buf.append( "'" );
+    buf.append( x );
+    buf.append( "'" );
+    m_vars[parameterIndex-1] = buf.makeStringAndClear();
+}
+
+void PreparedStatement::setDouble( sal_Int32 parameterIndex, double x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    OStringBuffer buf( 20 );
+    buf.append( "'" );
+    buf.append( x );
+    buf.append( "'" );
+    m_vars[parameterIndex-1] = buf.makeStringAndClear();
+}
+
+void PreparedStatement::setString( sal_Int32 parameterIndex, const ::rtl::OUString& x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    OStringBuffer buf( 20 );
+    buf.append( "'" );
+    OString y = OUStringToOString( x, m_pSettings->encoding );
+    buf.ensureCapacity( y.getLength() * 2 + 2 );
+    int len = 1;//PQescapeString( ((char*)buf.getStr())+1, y.getStr() , y.getLength() );
+    buf.setLength( 1 + len );
+    buf.append( "'" );
+    m_vars[parameterIndex-1] = buf.makeStringAndClear();
+}
+
+void PreparedStatement::setBytes(
+    sal_Int32 parameterIndex, const Sequence< sal_Int8 >& x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    OStringBuffer buf( 20 );
+    buf.append( "'" );
+    size_t len;
+    unsigned char * escapedString = NULL;
+//        PQescapeBytea( (unsigned char *)x.getConstArray(), x.getLength(), &len);
+    if( ! escapedString )
+    {
+        throw SQLException(
+            ASCII_STR("mdb_preparedstatement.setBytes: Error during converting bytesequence to an SQL conform string" ),
+            *this, OUString(), 1, Any() );
+    }
+    buf.append( (const sal_Char *)escapedString, len -1 );
+    free( escapedString );
+    buf.append( "'" );
+    m_vars[parameterIndex-1] = buf.makeStringAndClear();
+}
+
+void PreparedStatement::setDate( sal_Int32 parameterIndex, const ::com::sun::star::util::Date& x )
+    throw (SQLException, RuntimeException)
+{
+}
+
+void PreparedStatement::setTime( sal_Int32 parameterIndex, const ::com::sun::star::util::Time& x )
+    throw (SQLException, RuntimeException)
+{
+}
+
+void PreparedStatement::setTimestamp(
+    sal_Int32 parameterIndex, const ::com::sun::star::util::DateTime& x )
+    throw (SQLException, RuntimeException)
+{
+}
+
+void PreparedStatement::setBinaryStream(
+    sal_Int32 parameterIndex,
+    const Reference< ::com::sun::star::io::XInputStream >& x,
+    sal_Int32 length )
+    throw (SQLException, RuntimeException)
+{
+}
+
+void PreparedStatement::setCharacterStream(
+    sal_Int32 parameterIndex,
+    const Reference< ::com::sun::star::io::XInputStream >& x,
+    sal_Int32 length )
+    throw (SQLException, RuntimeException)
+{
+}
+
+void PreparedStatement::setObject( sal_Int32 parameterIndex, const Any& x )
+    throw (SQLException, RuntimeException)
+{
+}
+
+void PreparedStatement::setObjectWithInfo(
+    sal_Int32 parameterIndex,
+    const Any& x,
+    sal_Int32 targetSqlType,
+    sal_Int32 scale )
+    throw (SQLException, RuntimeException)
+{
+}
+
+void PreparedStatement::setRef(
+    sal_Int32 parameterIndex,
+    const Reference< XRef >& x )
+    throw (SQLException, RuntimeException)
+{
+}
+
+void PreparedStatement::setBlob(
+    sal_Int32 parameterIndex,
+    const Reference< XBlob >& x )
+    throw (SQLException, RuntimeException)
+{
+}
+
+void PreparedStatement::setClob(
+    sal_Int32 parameterIndex,
+    const Reference< XClob >& x )
+    throw (SQLException, RuntimeException)
+{
+}
+
+void PreparedStatement::setArray(
+    sal_Int32 parameterIndex,
+    const Reference< XArray >& x )
+    throw (SQLException, RuntimeException)
+{
+}
+
+void PreparedStatement::clearParameters(  )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    m_vars = OStringVector ( m_vars.size() );
+}
+
+Any PreparedStatement::getWarnings(  )
+        throw (SQLException,RuntimeException)
+{
+    return Any();
+}
+
+void PreparedStatement::clearWarnings(  )
+        throw (SQLException, RuntimeException)
+{
+}
+
+::cppu::IPropertyArrayHelper & PreparedStatement::getInfoHelper()
+{
+    return getPreparedStatementPropertyArrayHelper(); 
+}
+
+
+sal_Bool PreparedStatement::convertFastPropertyValue(
+		Any & rConvertedValue, Any & rOldValue, sal_Int32 nHandle, const Any& rValue )
+		throw (IllegalArgumentException)
+{
+    sal_Bool bRet;
+    switch( nHandle )
+    {
+    case PREPARED_STATEMENT_CURSOR_NAME:
+    {
+        OUString val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    case PREPARED_STATEMENT_ESCAPE_PROCESSING:
+    {
+        sal_Bool val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    case PREPARED_STATEMENT_FETCH_DIRECTION:
+    case PREPARED_STATEMENT_FETCH_SIZE:
+    case PREPARED_STATEMENT_MAX_FIELD_SIZE:
+    case PREPARED_STATEMENT_MAX_ROWS:
+    case PREPARED_STATEMENT_QUERY_TIME_OUT:
+    case PREPARED_STATEMENT_RESULT_SET_CONCURRENCY:
+    case PREPARED_STATEMENT_RESULT_SET_TYPE:
+    {
+        sal_Int32 val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    default:
+    {
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_statement: Invalid property handle (" );
+        buf.append( nHandle );
+        buf.appendAscii( ")" );
+        throw IllegalArgumentException( buf.makeStringAndClear(), *this, 2 );
+    }
+    }
+    return bRet;
+}
+    
+
+void PreparedStatement::setFastPropertyValue_NoBroadcast(
+    sal_Int32 nHandle,const Any& rValue ) throw (Exception)
+{
+    m_props[nHandle] = rValue;
+}
+
+void PreparedStatement::getFastPropertyValue( Any& rValue, sal_Int32 nHandle ) const
+{
+    rValue = m_props[nHandle];
+}
+
+Reference < XPropertySetInfo >  PreparedStatement::getPropertySetInfo()
+        throw(RuntimeException)
+{
+    return OPropertySetHelper::createPropertySetInfo( getPreparedStatementPropertyArrayHelper() );
+}
+
+void PreparedStatement::disposing()
+{
+    close();
+}
+
+
+}
+
