Index: bridges/inc/bridges/cpp_uno/shared/types.hxx
===================================================================
RCS file: /cvs/udk/bridges/inc/bridges/cpp_uno/shared/types.hxx,v
retrieving revision 1.3
diff -u -r1.3 types.hxx
--- bridges/inc/bridges/cpp_uno/shared/types.hxx	21 Feb 2005 12:08:58 -0000	1.3
+++ bridges/inc/bridges/cpp_uno/shared/types.hxx	14 Apr 2005 15:26:25 -0000
@@ -72,16 +72,6 @@
  * UNSIGNED SHORT, LONG, UNSIGNED LONG, HYPER, UNSIGNED HYPER, FLOAT, DOUBLE,
  * CHAR, or an enum type).
  *
- * @param typeClass a type class
- * @return true if the given type is "simple"
- */
-bool isSimpleType(typelib_TypeClass typeClass);
-
-/**
- * Determines whether a type is a "simple" type (VOID, BOOLEAN, BYTE, SHORT,
- * UNSIGNED SHORT, LONG, UNSIGNED LONG, HYPER, UNSIGNED HYPER, FLOAT, DOUBLE,
- * CHAR, or an enum type).
- *
  * @param type a non-null pointer to a type description reference
  * @return true if the given type is "simple"
  */
Index: bridges/source/cpp_uno/gcc3_linux_intel/cpp2uno.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_intel/cpp2uno.cxx,v
retrieving revision 1.7
diff -u -r1.7 cpp2uno.cxx
--- bridges/source/cpp_uno/gcc3_linux_intel/cpp2uno.cxx	21 Feb 2005 12:13:28 -0000	1.7
+++ bridges/source/cpp_uno/gcc3_linux_intel/cpp2uno.cxx	14 Apr 2005 15:26:26 -0000
@@ -77,7 +77,7 @@
 {
 
 //==================================================================================================
-void cpp2uno_call(
+static typelib_TypeClass cpp2uno_call(
 	bridges::cpp_uno::shared::CppInterfaceProxy * pThis,
 	const typelib_TypeDescription * pMemberTypeDescr,
 	typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
@@ -209,6 +209,8 @@
 		CPPU_CURRENT_NAMESPACE::raiseException(
             &aUnoExc, pThis->getBridge()->getUno2Cpp() );
             // has to destruct the any
+		// is here for dummy
+		return typelib_TypeClass_VOID;
 	}
 	else // else no exception occured...
 	{
@@ -245,16 +247,22 @@
 		}
 		if (pReturnTypeDescr)
 		{
+			typelib_TypeClass eRet = (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
 			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+			return eRet;
 		}
+		else
+			return typelib_TypeClass_VOID;
 	}
 }
 
 
 //==================================================================================================
-extern "C" void cpp_vtable_call(
-    int nFunctionIndex, int nVtableOffset, void** pCallStack,
-    sal_Int64 nRegReturn )
+static typelib_TypeClass cpp_mediate(
+	sal_Int32 nFunctionIndex,
+    sal_Int32 nVtableOffset,
+	void ** pCallStack,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
 {
 	OSL_ENSURE( sizeof(sal_Int32)==sizeof(void *), "### unexpected!" );
 	
@@ -290,6 +298,7 @@
 
 	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
     
+	typelib_TypeClass eRet;
 	switch (aMemberDescr.get()->eTypeClass)
 	{
 	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
@@ -297,11 +306,11 @@
 		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nFunctionIndex)
 		{
 			// is GET method
-			cpp2uno_call(
+			eRet = cpp2uno_call(
 				pCppI, aMemberDescr.get(),
 				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
 				0, 0, // no params
-				pCallStack, &nRegReturn );
+				pCallStack, pRegisterReturn );
 		}
 		else
 		{
@@ -312,11 +321,11 @@
 			aParam.bIn		= sal_True;
 			aParam.bOut		= sal_False;
 			
-			cpp2uno_call(
+			eRet = cpp2uno_call(
 				pCppI, aMemberDescr.get(),
 				0, // indicates void return
 				1, &aParam,
-				pCallStack, &nRegReturn );
+				pCallStack, pRegisterReturn );
 		}
 		break;
 	}
@@ -327,9 +336,11 @@
 		{
 		case 1: // acquire()
 			pCppI->acquireProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
 			break;
 		case 2: // release()
 			pCppI->releaseProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
 			break;
 		case 0: // queryInterface() opt
 		{
@@ -350,19 +361,20 @@
                         &pInterface, pTD, cpp_acquire );
                     pInterface->release();
                     TYPELIB_DANGER_RELEASE( pTD );
-                    *(void **)&nRegReturn = pCallStack[1];
+                    *(void **)pRegisterReturn = pCallStack[1];
+                    eRet = typelib_TypeClass_ANY;
                     break;
                 }
                 TYPELIB_DANGER_RELEASE( pTD );
             }
 		} // else perform queryInterface()
 		default:
-			cpp2uno_call(
+			eRet = cpp2uno_call(
 				pCppI, aMemberDescr.get(),
 				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
 				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
 				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
-				pCallStack, &nRegReturn );
+				pCallStack, pRegisterReturn );
 		}
 		break;
 	}
@@ -371,55 +383,72 @@
 		throw RuntimeException(
             rtl::OUString::createFromAscii("no member description found!"),
             (XInterface *)pThis );
+		// is here for dummy
+		eRet = typelib_TypeClass_VOID;
 	}
 	}
+
+	return eRet;
 }
 
 //==================================================================================================
-extern "C" void privateSnippetExecutorGeneral();
-extern "C" void privateSnippetExecutorVoid();
-extern "C" void privateSnippetExecutorHyper();
-extern "C" void privateSnippetExecutorFloat();
-extern "C" void privateSnippetExecutorDouble();
-extern "C" void privateSnippetExecutorClass();
-extern "C" typedef void (*PrivateSnippetExecutor)();
+/**
+ * is called on incoming vtable calls
+ * (called by asm snippets)
+ */
+static void cpp_vtable_call(
+    int nFunctionIndex, int nVtableOffset, void** pCallStack )
+    __attribute__((regparm(3)));
+
+void cpp_vtable_call( int nFunctionIndex, int nVtableOffset, void** pCallStack )
+{
+	volatile long nRegReturn[2];
+	typelib_TypeClass aType = cpp_mediate(
+        nFunctionIndex, nVtableOffset, pCallStack, (sal_Int64*)nRegReturn );
+    
+	switch( aType )
+	{
+		case typelib_TypeClass_HYPER:
+		case typelib_TypeClass_UNSIGNED_HYPER:
+			__asm__( "movl %1, %%edx\n\t"
+					 "movl %0, %%eax\n"
+					 : : "m"(nRegReturn[0]), "m"(nRegReturn[1]) );
+			break;
+		case typelib_TypeClass_FLOAT:
+			__asm__( "flds %0\n\t"
+					 "fstp %%st(0)\n\t"
+					 "flds %0\n"
+					 : : "m"(*(float *)nRegReturn) );
+			break;
+		case typelib_TypeClass_DOUBLE:
+			__asm__( "fldl %0\n\t"
+					 "fstp %%st(0)\n\t"
+					 "fldl %0\n"
+					 : : "m"(*(double *)nRegReturn) );
+			break;
+// 		case typelib_TypeClass_UNSIGNED_SHORT:
+// 		case typelib_TypeClass_SHORT:
+// 			__asm__( "movswl %0, %%eax\n"
+// 					 : : "m"(nRegReturn) );
+// 		break;
+		default:
+			__asm__( "movl %0, %%eax\n"
+					 : : "m"(nRegReturn[0]) );
+			break;
+	}
+}
+
 
-int const codeSnippetSize = 16;
+//==================================================================================================
+int const codeSnippetSize = 20;
 
 unsigned char * codeSnippet(
     unsigned char * code, sal_Int32 functionIndex, sal_Int32 vtableOffset,
-    typelib_TypeClass returnTypeClass)
+    bool simpleRetType)
 {
-    if (!bridges::cpp_uno::shared::isSimpleType(returnTypeClass)) {
+    if (!simpleRetType) {
         functionIndex |= 0x80000000;
     }
-    PrivateSnippetExecutor exec;
-    switch (returnTypeClass) {
-    case typelib_TypeClass_VOID:
-        exec = privateSnippetExecutorVoid;
-        break;
-    case typelib_TypeClass_HYPER:
-    case typelib_TypeClass_UNSIGNED_HYPER:
-        exec = privateSnippetExecutorHyper;
-        break;
-    case typelib_TypeClass_FLOAT:
-        exec = privateSnippetExecutorFloat;
-        break;
-    case typelib_TypeClass_DOUBLE:
-        exec = privateSnippetExecutorDouble;
-        break;
-    case typelib_TypeClass_STRING:
-    case typelib_TypeClass_TYPE:
-    case typelib_TypeClass_ANY:
-    case typelib_TypeClass_SEQUENCE:
-    case typelib_TypeClass_STRUCT:
-    case typelib_TypeClass_INTERFACE:
-        exec = privateSnippetExecutorClass;
-        break;
-    default:
-        exec = privateSnippetExecutorGeneral;
-        break;
-    }
     unsigned char * p = code;
     OSL_ASSERT(sizeof (sal_Int32) == 4);
     // mov function_index, %eax:
@@ -430,10 +459,13 @@
     *p++ = 0xBA;
     *reinterpret_cast< sal_Int32 * >(p) = vtableOffset;
     p += sizeof (sal_Int32);
-    // jmp privateSnippetExecutor:
+    // mov %esp, %ecx:
+    *p++ = 0x89;
+    *p++ = 0xE1;
+    // jmp cpp_vtable_call:
     *p++ = 0xE9;
     *reinterpret_cast< sal_Int32 * >(p)
-        = ((unsigned char *) exec) - p - sizeof (sal_Int32);
+        = ((unsigned char *) cpp_vtable_call) - p - sizeof (sal_Int32);
     p += sizeof (sal_Int32);
     OSL_ASSERT(p - code <= codeSnippetSize);
     return code + codeSnippetSize;
@@ -472,17 +504,17 @@
             *slots++ = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
-                reinterpret_cast< typelib_InterfaceAttributeTypeDescription * >(
-                    member)->pAttributeTypeRef->eTypeClass);
+                bridges::cpp_uno::shared::isSimpleType(
+                    reinterpret_cast<
+                    typelib_InterfaceAttributeTypeDescription * >(
+                        member)->pAttributeTypeRef));
             // Setter:
             if (!reinterpret_cast<
                 typelib_InterfaceAttributeTypeDescription * >(
                     member)->bReadOnly)
             {
                 *slots++ = code;
-                code = codeSnippet(
-                    code, functionOffset++, vtableOffset,
-                    typelib_TypeClass_VOID);
+                code = codeSnippet(code, functionOffset++, vtableOffset, true);
             }
             break;
 
@@ -490,8 +522,10 @@
             *slots++ = code;
             code = codeSnippet(
                 code, functionOffset++, vtableOffset,
-                reinterpret_cast< typelib_InterfaceMethodTypeDescription * >(
-                    member)->pReturnTypeRef->eTypeClass);
+                bridges::cpp_uno::shared::isSimpleType(
+                    reinterpret_cast<
+                    typelib_InterfaceMethodTypeDescription * >(
+                        member)->pReturnTypeRef));
             break;
 
         default:
Index: bridges/source/cpp_uno/gcc3_linux_intel/makefile.mk
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/gcc3_linux_intel/makefile.mk,v
retrieving revision 1.4
diff -u -r1.4 makefile.mk
--- bridges/source/cpp_uno/gcc3_linux_intel/makefile.mk	21 Feb 2005 12:13:46 -0000	1.4
+++ bridges/source/cpp_uno/gcc3_linux_intel/makefile.mk	14 Apr 2005 15:26:26 -0000
@@ -87,8 +87,7 @@
 SLOFILES= \
 	$(SLO)$/except.obj		\
 	$(SLO)$/cpp2uno.obj		\
-    $(SLO)$/uno2cpp.obj \
-    $(SLO)$/call.obj
+	$(SLO)$/uno2cpp.obj
 
 SHL1TARGET= $(TARGET)
 
@@ -109,6 +108,3 @@
 
 .INCLUDE :  target.mk
 
-$(SLO)$/%.obj: %.s
-    $(CC) -c -o $(SLO)$/$(@:b).o $<
-    touch $@
Index: bridges/source/cpp_uno/shared/types.cxx
===================================================================
RCS file: /cvs/udk/bridges/source/cpp_uno/shared/types.cxx,v
retrieving revision 1.3
diff -u -r1.3 types.cxx
--- bridges/source/cpp_uno/shared/types.cxx	21 Feb 2005 12:15:30 -0000	1.3
+++ bridges/source/cpp_uno/shared/types.cxx	14 Apr 2005 15:26:26 -0000
@@ -65,19 +65,23 @@
 #include "typelib/typeclass.h"
 #include "typelib/typedescription.h"
 
-namespace bridges { namespace cpp_uno { namespace shared {
+namespace {
 
-bool isSimpleType(typelib_TypeClass typeClass) {
+bool isSimpleTypeClass(typelib_TypeClass typeClass) {
     return typeClass <= typelib_TypeClass_DOUBLE
         || typeClass == typelib_TypeClass_ENUM;
 }
 
+}
+
+namespace bridges { namespace cpp_uno { namespace shared {
+
 bool isSimpleType(typelib_TypeDescriptionReference const * type) {
-    return isSimpleType(type->eTypeClass);
+    return isSimpleTypeClass(type->eTypeClass);
 }
 
 bool isSimpleType(typelib_TypeDescription const * type) {
-    return isSimpleType(type->eTypeClass);
+    return isSimpleTypeClass(type->eTypeClass);
 }
 
 bool relatesToInterfaceType(typelib_TypeDescription const * type) {
