diff --git a/ucb/source/ucp/webdav/NeonSession.cxx b/ucb/source/ucp/webdav/NeonSession.cxx
index f1ddbf0..eb85c85 100644
--- ucb/source/ucp/webdav/NeonSession.cxx
+++ ucb/source/ucp/webdav/NeonSession.cxx
@@ -213,6 +213,12 @@ static sal_uInt16 makeStatusCode( const rtl::OUString & rStatusText )
     return sal_uInt16( rStatusText.copy( 0, nPos ).toInt32() );
 }
 
+static sal_uInt16 getStatusCode( HttpSession *pSession )
+{
+    rtl::OUString aText = rtl::OUString::createFromAscii( ne_get_error( pSession ) );
+    return makeStatusCode( aText );
+}
+
 // -------------------------------------------------------------------
 struct NeonRequestContext
 {
@@ -1405,14 +1411,7 @@ void NeonSession::LOCK( ucb::Lock & rLock,
 
     m_aEnv = rEnv;
 
-    if ( !Lockit( rLock, true ) )
-    {
-        ucbhelper::cancelCommandExecution( ucb::IOErrorCode_LOCKING_VIOLATION,
-                uno::Sequence< uno::Any >( 0 ), // FIXME more info about the file?
-                rEnv.m_xEnv,
-                rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "a locking error occured" ) ),
-                uno::Reference< ucb::XCommandProcessor >() );
-    }
+    Lockit( rLock, true );
 }
 
 // -------------------------------------------------------------------
@@ -1428,14 +1427,7 @@ void NeonSession::UNLOCK( ucb::Lock & rLock,
 
     m_aEnv = rEnv;
 
-    if ( !Lockit( rLock, false ) )
-    {
-        ucbhelper::cancelCommandExecution( ucb::IOErrorCode_LOCKING_VIOLATION,
-                uno::Sequence< uno::Any >( 0 ), // FIXME more info about the file?
-                rEnv.m_xEnv,
-                rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "a locking error occured" ) ),
-                uno::Reference< ucb::XCommandProcessor >() );
-    }
+    Lockit( rLock, false );
 }
 
 // -------------------------------------------------------------------
@@ -1475,7 +1467,7 @@ void NeonSession::HandleError( int nError )
         case NE_ERROR:        // Generic error
         {
             rtl::OUString aText = rtl::OUString::createFromAscii(
-		ne_get_error( m_pHttpSession ) );
+                    ne_get_error( m_pHttpSession ) );
             throw DAVException( DAVException::DAV_HTTP_ERROR,
                                 aText,
                                 makeStatusCode( aText ) );
@@ -1532,7 +1524,7 @@ void NeonSession::HandleError( int nError )
     }
 }
 
-sal_Bool NeonSession::Lockit( ucb::Lock & rLock, bool bLockit )
+void NeonSession::Lockit( ucb::Lock & rLock, bool bLockit )
 	throw ( DAVException )
 {
     osl::Guard< osl::Mutex > theGuard( m_aMutex );
@@ -1587,20 +1579,31 @@ sal_Bool NeonSession::Lockit( ucb::Lock & rLock, bool bLockit )
         ne_lockstore_add( m_NeonLockStore, theLock );
     }
 
-    int theRetVal;
     if ( bLockit )
     {
-        theRetVal = ne_lock( m_pHttpSession, theLock );
-
-        if ( theRetVal != NE_OK )
-            return sal_False;
+        int nRet = ne_lock( m_pHttpSession, theLock );
 
-        uno::Sequence< rtl::OUString > aTokens( 1 );
-        aTokens[0] = rtl::OUString::createFromAscii( theLock->token );
-        rLock.LockTokens = aTokens;
+        if ( nRet == NE_OK )
+        {
+            uno::Sequence< rtl::OUString > aTokens( 1 );
+            aTokens[0] = rtl::OUString::createFromAscii( theLock->token );
+            rLock.LockTokens = aTokens;
 
 #if OSL_DEBUG_LEVEL > 0
-        fprintf( stderr, "WebDAV: locked the URL, the token is: %s\n", theLock->token );
+            fprintf( stderr, "WebDAV: locked the URL, the token is: %s\n", theLock->token );
+#endif
+        }
+        else if ( ( nRet == NE_ERROR ) && ( getStatusCode( m_pHttpSession ) == 423 ) )
+        {
+            ucbhelper::cancelCommandExecution( ucb::IOErrorCode_LOCKING_VIOLATION,
+                    uno::Sequence< uno::Any >( 0 ), // FIXME more info about the file?
+                    m_aEnv.m_xEnv,
+                    rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "a locking error occured" ) ),
+                    uno::Reference< ucb::XCommandProcessor >() );
+        }
+#if OSL_DEBUG_LEVEL > 0
+        else
+            fprintf( stderr, "WebDAV: failed to lock the file, status code is: %d\n", getStatusCode( m_pHttpSession ) );
 #endif
     }
     else
@@ -1614,14 +1617,10 @@ sal_Bool NeonSession::Lockit( ucb::Lock & rLock, bool bLockit )
 #if OSL_DEBUG_LEVEL > 0
             fprintf( stderr, "WebDAV: going to unlock the URL, the token is: %s\n", theLock->token );
 #endif
-        }
 
-        theRetVal = ne_unlock( m_pHttpSession, theLock );
+            ne_unlock( m_pHttpSession, theLock );
+        }
     }
-
-    HandleError( theRetVal );
-
-    return sal_True;
 }
 
 // -------------------------------------------------------------------
diff --git a/ucb/source/ucp/webdav/NeonSession.hxx b/ucb/source/ucp/webdav/NeonSession.hxx
index f35468a..4f1798f 100644
--- ucb/source/ucp/webdav/NeonSession.hxx
+++ ucb/source/ucp/webdav/NeonSession.hxx
@@ -253,7 +253,7 @@ class NeonSession : public DAVSession
 
         const ucbhelper::InternetProxyServer & getProxySettings() const;
 
-		sal_Bool Lockit( com::sun::star::ucb::Lock & rLock, bool bLockit )
+		void Lockit( com::sun::star::ucb::Lock & rLock, bool bLockit )
 			throw ( DAVException );
 
         // low level GET implementation, used by public GET implementations
