Index: sc/inc/compiler.hrc
===================================================================
RCS file: /cvs/sc/sc/inc/compiler.hrc,v
retrieving revision 1.13
retrieving revision 1.13.148.1
diff -u -w -p -u -p -r1.13 -r1.13.148.1
--- sc/inc/compiler.hrc	18 Oct 2006 12:16:24 -0000	1.13
+++ sc/inc/compiler.hrc	26 Apr 2007 12:25:58 -0000	1.13.148.1
@@ -59,43 +59,46 @@
 #define	SC_OPCODE_COL_ROW_NAME		 16
 #define	SC_OPCODE_COL_ROW_NAME_AUTO	 17
 #define SC_OPCODE_PERCENT_SIGN            18     /* operator _follows_ value */
-#define	SC_OPCODE_END_DIV			 20
+#define SC_OPCODE_ARRAY_OPEN         19
+#define SC_OPCODE_ARRAY_CLOSE        20
+#define SC_OPCODE_ARRAY_ROW_SEP      21
+#define SC_OPCODE_END_DIV            22
 
 /*** Binaere Operatoren ***/
-#define	SC_OPCODE_ADD				 21
-#define	SC_OPCODE_SUB				 22
-#define	SC_OPCODE_MUL				 23
-#define	SC_OPCODE_DIV				 24
-#define	SC_OPCODE_AMPERSAND			 25
-#define	SC_OPCODE_POW				 26
-#define	SC_OPCODE_EQUAL				 27
-#define	SC_OPCODE_NOT_EQUAL			 28
-#define	SC_OPCODE_LESS				 29
-#define	SC_OPCODE_GREATER			 30
-#define	SC_OPCODE_LESS_EQUAL		 31
-#define	SC_OPCODE_GREATER_EQUAL		 32
-#define	SC_OPCODE_AND				 33
-#define	SC_OPCODE_OR				 34
-#define	SC_OPCODE_INTERSECT			 35
-#define	SC_OPCODE_UNION				 36
-#define	SC_OPCODE_RANGE				 37
-#define	SC_OPCODE_END_BIN_OP		 40
+#define SC_OPCODE_ADD                25
+#define SC_OPCODE_SUB                26
+#define SC_OPCODE_MUL                27
+#define SC_OPCODE_DIV                28
+#define SC_OPCODE_AMPERSAND          29
+#define SC_OPCODE_POW                30
+#define SC_OPCODE_EQUAL              31
+#define SC_OPCODE_NOT_EQUAL          32
+#define SC_OPCODE_LESS               33
+#define SC_OPCODE_GREATER            34
+#define SC_OPCODE_LESS_EQUAL         35
+#define SC_OPCODE_GREATER_EQUAL      36
+#define SC_OPCODE_AND                37
+#define SC_OPCODE_OR                 38
+#define SC_OPCODE_INTERSECT          39
+#define SC_OPCODE_UNION              40
+#define SC_OPCODE_RANGE              41
+#define SC_OPCODE_END_BIN_OP         44
 
 /*** Unaere Operatoren ***/
-#define	SC_OPCODE_NOT				 41
-#define	SC_OPCODE_NEG				 42
-#define	SC_OPCODE_NEG_SUB			 43
-#define	SC_OPCODE_END_UN_OP			 45
+#define SC_OPCODE_NOT                45
+#define SC_OPCODE_NEG                46
+#define SC_OPCODE_NEG_SUB            47
+#define SC_OPCODE_END_UN_OP          48
 
 /*** Funktionen ohne Parameter ***/
-#define	SC_OPCODE_PI				 46
-#define	SC_OPCODE_RANDOM			 47
-#define	SC_OPCODE_TRUE				 48
-#define	SC_OPCODE_FALSE				 49
-#define	SC_OPCODE_GET_ACT_DATE		 50
-#define	SC_OPCODE_GET_ACT_TIME		 51
-#define	SC_OPCODE_NO_VALUE			 52
-#define	SC_OPCODE_CURRENT			 53
+#define SC_OPCODE_PI                 50
+#define SC_OPCODE_RANDOM             51
+#define SC_OPCODE_TRUE               52
+#define SC_OPCODE_FALSE              53
+#define SC_OPCODE_GET_ACT_DATE       54
+#define SC_OPCODE_GET_ACT_TIME       55
+#define SC_OPCODE_NO_VALUE           56
+#define SC_OPCODE_CURRENT            57
 #define	SC_OPCODE_END_NO_PAR		 60
 
 /*** Funktionen mit einem Parameter ***/
Index: sc/inc/compiler.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/compiler.hxx,v
retrieving revision 1.29
retrieving revision 1.29.54.2
diff -u -w -p -u -p -r1.29 -r1.29.54.2
--- sc/inc/compiler.hxx	27 Feb 2007 11:53:56 -0000	1.29
+++ sc/inc/compiler.hxx	8 May 2007 21:16:01 -0000	1.29.54.2
@@ -289,7 +289,7 @@ private:
 	BOOL		bImportXML;
 
 	BOOL   GetToken();
-	BOOL   NextNewToken();
+	BOOL   NextNewToken(bool bAllowBooleans = false);
 	OpCode NextToken();
 	void PutCode( ScTokenRef& );
 	void Factor();
@@ -315,11 +315,17 @@ private:
 	BOOL IsNamedRange( const String& );
 	BOOL IsDBRange( const String& );
 	BOOL IsColRowName( const String& );
+	BOOL IsBoolean( const String& );
 	void AutoCorrectParsedSymbol();
 	void AdjustReference( SingleRefData& r );
 	void PushTokenArray( ScTokenArray*, BOOL = FALSE );
 	void PopTokenArray();
 	void SetRelNameReference();
+	void CreateStringFromScMatrix( rtl::OUStringBuffer& rBuffer, const ScMatrix* pMatrix );
+
+    void AppendBoolean( rtl::OUStringBuffer& rBuffer, bool bVal );
+    void AppendDouble( rtl::OUStringBuffer& rBuffer, double fVal );
+    void AppendString( rtl::OUStringBuffer& rBuffer, const String & rStr );
 
 public:
 	ScCompiler(ScDocument* pDocument, const ScAddress& );
Index: sc/inc/errorcodes.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/errorcodes.hxx,v
retrieving revision 1.3
retrieving revision 1.3.420.1
diff -u -w -p -u -p -r1.3 -r1.3.420.1
--- sc/inc/errorcodes.hxx	8 Sep 2005 17:39:17 -0000	1.3
+++ sc/inc/errorcodes.hxx	26 Apr 2007 12:25:58 -0000	1.3.420.1
@@ -82,6 +82,8 @@ const USHORT errCellNoValue          = 5
 const USHORT errNoAddin              = 530;
 // Interpreter: needed Macro not found
 const USHORT errNoMacro              = 531;
+// Compiler: a non-simple (str,err,val) value was put in an array
+const USHORT errNestedArray          = 533;
 
 // Interpreter: NA() not available condition, not a real error
 const USHORT NOVALUE                 = 0x7fff;
Index: sc/inc/globstr.hrc
===================================================================
RCS file: /cvs/sc/sc/inc/globstr.hrc,v
retrieving revision 1.15
retrieving revision 1.15.148.1
diff -u -w -p -u -p -r1.15 -r1.15.148.1
--- sc/inc/globstr.hrc	18 Oct 2006 12:17:08 -0000	1.15
+++ sc/inc/globstr.hrc	26 Apr 2007 12:25:58 -0000	1.15.148.1
@@ -555,7 +555,9 @@
 
 #define STR_UNDO_TAB_R1C1           418
 
-#define STR_COUNT                   419
+#define STR_ERR_LONG_NESTED_ARRAY   419
+
+#define STR_COUNT                   420
 
 #endif
 
Index: sc/inc/opcode.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/opcode.hxx,v
retrieving revision 1.15
retrieving revision 1.15.148.1
diff -u -w -p -u -p -r1.15 -r1.15.148.1
--- sc/inc/opcode.hxx	18 Oct 2006 12:17:24 -0000	1.15
+++ sc/inc/opcode.hxx	26 Apr 2007 12:25:59 -0000	1.15.148.1
@@ -58,6 +58,10 @@ enum OpCodeEnum
 		ocOpen				= SC_OPCODE_OPEN,
 		ocClose				= SC_OPCODE_CLOSE,
 		ocSep				= SC_OPCODE_SEP,
+        ocArrayOpen         = SC_OPCODE_ARRAY_OPEN,
+        ocArrayClose        = SC_OPCODE_ARRAY_CLOSE,
+        ocArrayRowSep       = SC_OPCODE_ARRAY_ROW_SEP,
+
 	// Spezial-Opcodes
 		ocMissing			= SC_OPCODE_MISSING,
 		ocBad				= SC_OPCODE_BAD,
Index: sc/inc/scmatrix.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/scmatrix.hxx,v
retrieving revision 1.7
retrieving revision 1.7.408.1
diff -u -w -p -u -p -r1.7 -r1.7.408.1
--- sc/inc/scmatrix.hxx	28 Sep 2005 11:27:33 -0000	1.7
+++ sc/inc/scmatrix.hxx	8 May 2007 21:16:02 -0000	1.7.408.1
@@ -56,9 +56,10 @@ class SvNumberFormatter;
 
 typedef BYTE ScMatValType;
 const ScMatValType SC_MATVAL_VALUE     = 0x00;
-const ScMatValType SC_MATVAL_STRING    = 0x01;
-const ScMatValType SC_MATVAL_EMPTY     = SC_MATVAL_STRING | 0x02; // STRING plus flag
-const ScMatValType SC_MATVAL_EMPTYPATH = SC_MATVAL_EMPTY | 0x04;  // EMPTY plus flag
+const ScMatValType SC_MATVAL_BOOLEAN   = 0x01;
+const ScMatValType SC_MATVAL_STRING    = 0x02;
+const ScMatValType SC_MATVAL_EMPTY     = SC_MATVAL_STRING | 0x04; // STRING plus flag
+const ScMatValType SC_MATVAL_EMPTYPATH = SC_MATVAL_EMPTY | 0x08;  // EMPTY plus flag
 
 union ScMatrixValue
 {
@@ -100,7 +101,8 @@ union ScMatrixValue
 class ScMatrix
 {
     ScMatrixValue*  pMat;
-    ScMatValType*   bIsString;
+    ScMatValType*   mnValType;
+    ULONG           mnNonValue; // how many strings and empties
     ScInterpreter*  pErrorInterpreter;
     ULONG           nRefCnt;     // reference count
     SCSIZE          nColCount;
@@ -191,12 +193,14 @@ public:
         { PutDouble( CreateDoubleError( nErrorCode ), nC, nR ); }
     void PutError( USHORT nErrorCode, SCSIZE nIndex )
         { PutDouble( CreateDoubleError( nErrorCode ), nIndex ); }
+    void PutBoolean( bool bVal, SCSIZE nC, SCSIZE nR);
+    void PutBoolean( bool bVal, SCSIZE nIndex);
+
     void FillDouble( double fVal,
             SCSIZE nC1, SCSIZE nR1, SCSIZE nC2, SCSIZE nR2 );
     /// lower left triangle
     void FillDoubleLowerLeft( double fVal, SCSIZE nC2 );
 
-private:
     /** May be used before obtaining the double value of an element to avoid
         passing its NAN around.
         @ATTENTION: MUST NOT be used if the element is a string!
@@ -204,7 +208,7 @@ private:
     USHORT GetError( SCSIZE nC, SCSIZE nR) const;
     USHORT GetError( SCSIZE nIndex) const
         { return pMat[nIndex].GetError(); }
-public:
+
     /** Use in ScInterpreter to obtain the error code, if any.
         @returns 0 if no error or string element, else one of err... constants */
     USHORT GetErrorIfNotString( SCSIZE nC, SCSIZE nR) const
@@ -238,37 +242,32 @@ public:
 
     /// @return <TRUE/> if string or empty
     BOOL IsString( SCSIZE nIndex ) const
-        { return bIsString && bIsString[nIndex]; }
+        { return mnValType && mnValType[nIndex] > SC_MATVAL_BOOLEAN; }
     /// @return <TRUE/> if string or empty
     BOOL IsString( SCSIZE nC, SCSIZE nR ) const
-        { return bIsString && bIsString[ nC * nRowCount + nR ]; }
+        { return mnValType && mnValType[ nC * nRowCount + nR ] > SC_MATVAL_BOOLEAN; }
     BOOL IsEmpty( SCSIZE nIndex ) const
-        { return bIsString && ((bIsString[nIndex] & SC_MATVAL_EMPTY) ==
-                SC_MATVAL_EMPTY); }
+        { return mnValType && ((mnValType[nIndex] & SC_MATVAL_EMPTY) == SC_MATVAL_EMPTY); }
     BOOL IsEmptyPath( SCSIZE nC, SCSIZE nR ) const
-        { return bIsString && ((bIsString[ nC * nRowCount + nR ] &
-                    SC_MATVAL_EMPTYPATH) == SC_MATVAL_EMPTYPATH); }
+        { return mnValType && ((mnValType[ nC * nRowCount + nR ] & SC_MATVAL_EMPTYPATH) == SC_MATVAL_EMPTYPATH); }
     BOOL IsEmptyPath( SCSIZE nIndex ) const
-        { return bIsString && ((bIsString[nIndex] & SC_MATVAL_EMPTYPATH) ==
-                SC_MATVAL_EMPTYPATH); }
+        { return mnValType && ((mnValType[nIndex] & SC_MATVAL_EMPTYPATH) == SC_MATVAL_EMPTYPATH); }
     BOOL IsEmpty( SCSIZE nC, SCSIZE nR ) const
-        { return bIsString && ((bIsString[ nC * nRowCount + nR ] &
-                    SC_MATVAL_EMPTY) == SC_MATVAL_EMPTY); }
+        { return mnValType && ((mnValType[ nC * nRowCount + nR ] & SC_MATVAL_EMPTY) == SC_MATVAL_EMPTY); }
     BOOL IsValue( SCSIZE nIndex ) const
-        { return !bIsString || !bIsString[nIndex]; }
+        { return !mnValType || mnValType[nIndex] <= SC_MATVAL_BOOLEAN; }
     BOOL IsValue( SCSIZE nC, SCSIZE nR ) const
-        { return !bIsString || !bIsString[ nC * nRowCount + nR ]; }
+        { return !mnValType || mnValType[ nC * nRowCount + nR ] <= SC_MATVAL_BOOLEAN; }
     BOOL IsValueOrEmpty( SCSIZE nIndex ) const
-        { return !bIsString || !bIsString[nIndex] || ((bIsString[nIndex] &
-                    SC_MATVAL_EMPTY) == SC_MATVAL_EMPTY); }
+        { return !mnValType || mnValType[nIndex] <= SC_MATVAL_BOOLEAN || ((mnValType[nIndex] & SC_MATVAL_EMPTY) == SC_MATVAL_EMPTY); }
     BOOL IsValueOrEmpty( SCSIZE nC, SCSIZE nR ) const
-        { return !bIsString || !bIsString[ nC * nRowCount + nR ] ||
-            ((bIsString[ nC * nRowCount + nR ] & SC_MATVAL_EMPTY) ==
+        { return !mnValType || !mnValType[ nC * nRowCount + nR ] <= SC_MATVAL_BOOLEAN ||
+            ((mnValType[ nC * nRowCount + nR ] & SC_MATVAL_EMPTY) ==
              SC_MATVAL_EMPTY); }
 
-    /// @return <TRUE/> if entire matrix is numeric and no strings are contained
+    /// @return <TRUE/> if entire matrix is numeric with no strings, bools, or empties
     BOOL IsNumeric() const
-        { return bIsString == NULL; }
+        { return 0 == mnNonValue; }
 
     void MatTrans( ScMatrix& mRes) const;
     void MatCopy ( ScMatrix& mRes) const;
Index: sc/inc/tokenarray.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/tokenarray.hxx,v
retrieving revision 1.7
retrieving revision 1.7.102.1
diff -u -w -p -u -p -r1.7 -r1.7.102.1
--- sc/inc/tokenarray.hxx	19 Dec 2006 13:15:38 -0000	1.7
+++ sc/inc/tokenarray.hxx	26 Apr 2007 12:25:59 -0000	1.7.102.1
@@ -224,6 +224,7 @@ public:
     ScToken* AddColRowName( const SingleRefData& rRef );
     ScToken* AddBad( const sal_Unicode* pStr );     /// ocBad with String
     ScToken* AddBad( const String& rStr );          /// ocBad with String
+    ScToken* MergeArray( );
 
     /// Assignment with references to ScToken entries (not copied!)
     ScTokenArray& operator=( const ScTokenArray& );
Index: sc/source/core/data/global.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/global.cxx,v
retrieving revision 1.49
retrieving revision 1.49.54.1
diff -u -w -p -u -p -r1.49 -r1.49.54.1
--- sc/source/core/data/global.cxx	27 Feb 2007 12:06:20 -0000	1.49
+++ sc/source/core/data/global.cxx	26 Apr 2007 12:25:59 -0000	1.49.54.1
@@ -482,6 +482,9 @@ String ScGlobal::GetLongErrorString(USHO
         case errNoMacro:
             nErrNumber = STR_LONG_ERR_NO_MACRO;
 		break;
+        case errNestedArray:
+            nErrNumber = STR_ERR_LONG_NESTED_ARRAY;
+        break;
 		case errNoValue:
 			nErrNumber = STR_LONG_ERR_NO_VALUE;
 		break;
Index: sc/source/core/src/compiler.src
===================================================================
RCS file: /cvs/sc/sc/source/core/src/compiler.src,v
retrieving revision 1.51
retrieving revision 1.51.6.1
diff -u -w -p -u -p -r1.51 -r1.51.6.1
--- sc/source/core/src/compiler.src	19 Apr 2007 16:23:51 -0000	1.51
+++ sc/source/core/src/compiler.src	26 Apr 2007 12:26:00 -0000	1.51.6.1
@@ -47,6 +47,9 @@ Resource RID_SC_FUNCTION_NAMES
 	};
 	String SC_OPCODE_OPEN { Text = "(" ; };
 	String SC_OPCODE_CLOSE { Text = ")" ; };
+    String SC_OPCODE_ARRAY_OPEN { Text = "{" ; };
+    String SC_OPCODE_ARRAY_CLOSE { Text = "}" ; };
+    String SC_OPCODE_ARRAY_ROW_SEP { Text = "|" ; };
 	String SC_OPCODE_SEP { Text = ";" ; };
     String SC_OPCODE_PERCENT_SIGN { Text = "%" ; };
 	String SC_OPCODE_ADD { Text = "+" ; };
@@ -1159,6 +1162,9 @@ Resource RID_SC_FUNCTION_NAMES_ENGLISH
 	String SC_OPCODE_CHOSE { Text = "CHOOSE" ; };
 	String SC_OPCODE_OPEN { Text = "(" ; };
 	String SC_OPCODE_CLOSE { Text = ")" ; };
+    String SC_OPCODE_ARRAY_OPEN { Text = "{" ; };
+    String SC_OPCODE_ARRAY_CLOSE { Text = "}" ; };
+    String SC_OPCODE_ARRAY_ROW_SEP { Text = "|" ; };
 	String SC_OPCODE_SEP { Text = ";" ; };
     String SC_OPCODE_PERCENT_SIGN { Text = "%" ; };
 	String SC_OPCODE_ADD { Text = "+" ; };
Index: sc/source/core/tool/compiler.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/compiler.cxx,v
retrieving revision 1.68
retrieving revision 1.68.52.3
diff -u -w -p -u -p -r1.68 -r1.68.52.3
--- sc/source/core/tool/compiler.cxx	27 Feb 2007 12:13:57 -0000	1.68
+++ sc/source/core/tool/compiler.cxx	8 May 2007 21:17:26 -0000	1.68.52.3
@@ -351,9 +351,9 @@ for (i = 65; i < 91; i++)
 /* ` */     // FREI
 for (i = 97; i < 123; i++)
 /* a-z */   t[i] = SC_COMPILER_C_CHAR_WORD | SC_COMPILER_C_WORD | SC_COMPILER_C_CHAR_IDENT | SC_COMPILER_C_IDENT;
-/* { */     // FREI
-/* | */     // FREI
-/* } */     // FREI
+/* { */     t[123] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP; // array open
+/* | */     t[124] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP; // array row sep (Should be OOo specific)
+/* } */     t[125] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP; // array close
 /* ~ */     // FREI
 /* 127 */   // FREI
     if( ScAddress::CONV_XL_A1 == meConv || ScAddress::CONV_XL_R1C1 == meConv )
@@ -1369,7 +1369,8 @@ BOOL ScCompiler::IsOpCode( const String&
         }
     }
     if ( bFound && pRawToken->GetOpCode() == ocSub &&
-            (eLastOp == ocOpen || eLastOp == ocSep || eLastOp == ocNegSub ||
+            (eLastOp == ocOpen || eLastOp == ocArrayOpen ||
+             eLastOp == ocSep || eLastOp == ocNegSub ||
              (eLastOp > ocEndDiv && eLastOp < ocEndBinOp)))
         pRawToken->NewOpCode( ocNegSub );
         //! if ocNegSub had ForceArray we'd have to set it here
@@ -1900,6 +1901,21 @@ BOOL ScCompiler::IsColRowName( const Str
         return FALSE;
 }
 
+BOOL ScCompiler::IsBoolean( const String& rName )
+{
+    ScOpCodeHashMap::const_iterator iLook( pSymbolHashMap->find( rName ) );
+    if( iLook != pSymbolHashMap->end() &&
+        (iLook->second == ocTrue ||
+         iLook->second == ocFalse) )
+    {
+        ScRawToken aToken;
+        aToken.SetOpCode( iLook->second );
+        pRawToken = aToken.Clone();
+        return TRUE;
+    }
+    return FALSE;
+}
+
 //---------------------------------------------------------------------------
 
 void ScCompiler::AutoCorrectParsedSymbol()
@@ -2094,12 +2108,14 @@ void ScCompiler::AutoCorrectParsedSymbol
     }
 }
 
-BOOL ScCompiler::NextNewToken()
+BOOL ScCompiler::NextNewToken( bool bAllowBooleans )
 {
     xub_StrLen nSpaces = NextSymbol();
 
-//  fprintf( stderr, "NextNewToken '%s' (?) ",
-//           rtl::OUStringToOString( cSymbol, RTL_TEXTENCODING_UTF8 ).getStr() );
+#if 0
+    fprintf( stderr, "NextNewToken '%s' (spaces = %d)\n",
+             rtl::OUStringToOString( cSymbol, RTL_TEXTENCODING_UTF8 ).getStr(), nSpaces );
+#endif
 
     ScRawToken aToken;
     if( cSymbol[0] )
@@ -2142,12 +2158,19 @@ BOOL ScCompiler::NextNewToken()
 
             String aOrg( cSymbol ); // preserve file names in IsReference()
             String aUpper( ScGlobal::pCharClass->upper( aOrg ) );
+#if 0
+            fprintf( stderr, "Token '%s'\n",
+                     rtl::OUStringToOString( aUpper, RTL_TEXTENCODING_UTF8 ).getStr() );
+#endif
             // Column 'DM' ("Deutsche Mark", German currency) couldn't be
             // referred to => IsReference() before IsValue().
             // #42016# Italian ARCTAN.2 resulted in #REF! => IsOpcode() before
             // IsReference().
+            // IsBoolean before isValue to catch inline bools without the kludge
+            //    for inline arrays.
             if ( !(bMayBeFuncName && IsOpCode( aUpper ))
               && !IsReference( aOrg )
+              && !(bAllowBooleans && IsBoolean( aUpper ))
               && !IsValue( aUpper )
               && !IsNamedRange( aUpper )
               && !IsDBRange( aUpper )
@@ -2181,8 +2204,11 @@ BOOL ScCompiler::NextNewToken()
 ScTokenArray* ScCompiler::CompileString( const String& rFormula,
                                          ScAddress::Convention eConv )
 {
-//  fprintf( stderr, "CompileString '%s'\n",
-//           rtl::OUStringToOString( rFormula, RTL_TEXTENCODING_UTF8 ).getStr() );
+#if 0
+    fprintf( stderr, "CompileString '%s'\n",
+             rtl::OUStringToOString( rFormula, RTL_TEXTENCODING_UTF8 ).getStr() );
+#endif
+
     ScTokenArray aArr;
     pArr = &aArr;
     aFormula = rFormula;
@@ -2214,8 +2240,9 @@ ScTokenArray* ScCompiler::CompileString(
             aCorrectedFormula += '=';
     }
     short nBrackets = 0;
+    bool bInArray = false;
     eLastOp = ocOpen;
-    while( NextNewToken() )
+    while( NextNewToken( bInArray ) )
     {
         if( pRawToken->GetOpCode() == ocOpen )
             nBrackets++;
@@ -2233,7 +2260,35 @@ ScTokenArray* ScCompiler::CompileString(
             else
                 nBrackets--;
         }
-        if( eLastOp == ocSep && pRawToken->GetOpCode() == ocSep )
+        else if( pRawToken->GetOpCode() == ocArrayOpen )
+        {
+            if( bInArray )
+                SetError( errNestedArray );
+            else
+                bInArray = true;
+        }
+        else if( pRawToken->GetOpCode() == ocArrayClose )
+        {
+            if( bInArray )
+            {
+                bInArray = false;
+            }
+            else
+            {
+                SetError( errPairExpected );
+                if ( bAutoCorrect )
+                {
+                    bCorrected = TRUE;
+                    aCorrectedSymbol.Erase();
+                }
+            }
+        }
+        if( (eLastOp == ocSep ||
+             eLastOp == ocArrayRowSep ||
+             eLastOp == ocArrayOpen) &&
+            (pRawToken->GetOpCode() == ocSep ||
+             pRawToken->GetOpCode() == ocArrayRowSep ||
+             pRawToken->GetOpCode() == ocArrayClose) )
         {
             // FIXME: should we check for known functions with optional empty
             // args so the correction dialog can do better?
@@ -2253,6 +2308,17 @@ ScTokenArray* ScCompiler::CompileString(
     }
     if ( eLastOp != ocBad )
     {
+        if( bInArray )
+        {
+            ScByteToken aToken( ocArrayClose );
+            if( !pArr->AddToken( aToken ) )
+            {
+                SetError(errCodeOverflow);
+            }
+            else if ( bAutoCorrect )
+                aCorrectedFormula += pSymbolTable[ocArrayClose];
+        }
+
         // With ocBad the remaining formula is a string, too many parentheses
         // would be shown.
         ScByteToken aToken( ocClose );
@@ -4321,51 +4387,14 @@ ScToken* ScCompiler::CreateStringFromTok
     if( bNext ) switch( t->GetType() )
     {
         case svDouble:
-        {
-            if ( pSymbolTable == pSymbolTableEnglish )
-            {   // Don't go via number formatter, slows down XML export
-                // significantly because on every formula the number formatter
-                // has to switch to/from English/native language.
-                ::rtl::math::doubleToUStringBuffer( rBuffer, t->GetDouble(),
-                        rtl_math_StringFormat_Automatic,
-                        rtl_math_DecimalPlaces_Max, '.', TRUE );
-            }
-            else
-            {
-                ::rtl::math::doubleToUStringBuffer( rBuffer, t->GetDouble(),
-                        rtl_math_StringFormat_Automatic,
-                        rtl_math_DecimalPlaces_Max,
-                        ScGlobal::pLocaleData->getNumDecimalSep().GetChar(0),
-                        TRUE );
-            }
-        }
+            AppendDouble( rBuffer, t->GetDouble() );
         break;
+
         case svString:
             if( eOp == ocBad )
                 rBuffer.append(t->GetString());
             else
-            {
-                if (bImportXML)
-                    rBuffer.append(t->GetString());
-                else
-                {
-                    rBuffer.append(sal_Unicode('"'));
-                    if ( ScGlobal::UnicodeStrChr( t->GetString().GetBuffer(), '"' ) == NULL )
-                        rBuffer.append(t->GetString());
-                    else
-                    {
-                        String aStr( t->GetString() );
-                        xub_StrLen nPos = 0;
-                        while ( (nPos = aStr.Search( '"', nPos)) != STRING_NOTFOUND )
-                        {
-                            aStr.Insert( '"', nPos );
-                            nPos += 2;
-                        }
-                        rBuffer.append(aStr);
-                    }
-                    rBuffer.append(sal_Unicode('"'));
-                }
-            }
+                AppendString( rBuffer, t->GetString() );
             break;
         case svSingleRef:
         {
@@ -4395,6 +4424,10 @@ ScToken* ScCompiler::CreateStringFromTok
         case svDoubleRef:
             pConv->MakeRefStr( rBuffer, *this, t->GetDoubleRef(), FALSE );
             break;
+        case svMatrix:
+            CreateStringFromScMatrix( rBuffer, t->GetMatrix() );
+            break;
+
         case svIndex:
         {
             rtl::OUStringBuffer aBuffer;
@@ -4458,6 +4491,99 @@ ScToken* ScCompiler::CreateStringFromTok
     return pTokenP;
 }
 
+void ScCompiler::CreateStringFromScMatrix( rtl::OUStringBuffer& rBuffer,
+                                           const ScMatrix* pMatrix )
+{
+    SCSIZE nC, nMaxC, nR, nMaxR;
+
+    pMatrix->GetDimensions( nMaxC, nMaxR);
+
+    rBuffer.append( pSymbolTable[ocArrayOpen] );
+    for( nR = 0 ; nR < nMaxR ; nR++)
+    {
+        if( nR > 0)
+        {
+            rBuffer.append( pSymbolTable[ocArrayRowSep] );
+        }
+
+        for( nC = 0 ; nC < nMaxC ; nC++)
+        {
+            if( nC > 0)
+            {
+                rBuffer.append( pSymbolTable[ocSep] );
+            }
+
+            if( pMatrix->IsValue( nC, nR ) )
+            {
+                ScMatValType nType;
+                const ScMatrixValue* pVal = pMatrix->Get( nC, nR, nType);
+
+                if( nType == SC_MATVAL_BOOLEAN )
+                    AppendBoolean( rBuffer, ! ::rtl::math::approxEqual( pVal->fVal, 0. ) );
+                else
+                {
+                    USHORT nErr = pVal->GetError();
+                    if( nErr )
+                        rBuffer.append( ScGlobal::GetErrorString( nErr ) );
+                    else
+                        AppendDouble( rBuffer, pVal->fVal );
+                }
+            }
+            else if( pMatrix->IsEmpty( nC, nR ) )
+                ;
+            else if( pMatrix->IsString( nC, nR ) )
+                AppendString( rBuffer, pMatrix->GetString( nC, nR ) );
+        }
+    }
+    rBuffer.append( pSymbolTable[ocArrayClose] );
+}
+void ScCompiler::AppendBoolean( rtl::OUStringBuffer& rBuffer, bool bVal )
+{
+    rBuffer.append( pSymbolTable[bVal ? ocTrue : ocFalse] );
+}
+
+void ScCompiler::AppendDouble( rtl::OUStringBuffer& rBuffer, double fVal )
+{
+    if ( pSymbolTable == pSymbolTableEnglish )
+    {
+        ::rtl::math::doubleToUStringBuffer( rBuffer, fVal,
+                rtl_math_StringFormat_Automatic,
+                rtl_math_DecimalPlaces_Max, '.', TRUE );
+    }
+    else
+    {
+        ::rtl::math::doubleToUStringBuffer( rBuffer, fVal,
+                rtl_math_StringFormat_Automatic,
+                rtl_math_DecimalPlaces_Max,
+                ScGlobal::pLocaleData->getNumDecimalSep().GetChar(0),
+                TRUE );
+    }
+}
+
+void ScCompiler::AppendString( rtl::OUStringBuffer& rBuffer, const String & rStr )
+{
+    if (bImportXML)
+        rBuffer.append( rStr );
+    else
+    {
+        rBuffer.append(sal_Unicode('"'));
+        if ( ScGlobal::UnicodeStrChr( rStr.GetBuffer(), '"' ) == NULL )
+            rBuffer.append( rStr );
+        else
+        {
+            String aStr( rStr );
+            xub_StrLen nPos = 0;
+            while ( (nPos = aStr.Search( '"', nPos)) != STRING_NOTFOUND )
+            {
+                aStr.Insert( '"', nPos );
+                nPos += 2;
+            }
+            rBuffer.append(aStr);
+        }
+        rBuffer.append(sal_Unicode('"'));
+    }
+}
+
 void ScCompiler::CreateStringFromTokenArray( String& rFormula )
 {
     rtl::OUStringBuffer aBuffer( pArr->GetLen() * 2 );
Index: sc/source/core/tool/interpr4.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/interpr4.cxx,v
retrieving revision 1.45
retrieving revision 1.45.50.1
diff -u -w -p -u -p -r1.45 -r1.45.50.1
--- sc/source/core/tool/interpr4.cxx	27 Feb 2007 12:16:42 -0000	1.45
+++ sc/source/core/tool/interpr4.cxx	8 May 2007 21:16:02 -0000	1.45.50.1
@@ -1642,6 +1642,11 @@ ScMatValType ScInterpreter::GetDoubleOrS
                 }
                 else if (nMatValType == SC_MATVAL_VALUE)
                     rDouble = pMatVal->fVal;
+                else if (nMatValType == SC_MATVAL_BOOLEAN)
+                {
+                    rDouble = pMatVal->fVal;
+                    nMatValType = SC_MATVAL_VALUE;
+                }
                 else
                     rString = pMatVal->GetString();
             }
@@ -3738,7 +3743,7 @@ StackVar ScInterpreter::Interpret()
 						const ScMatrixValue* pMatVal = pResult->Get(0, 0, nMatValType);
 						if ( pMatVal )
 						{
-							if (nMatValType != SC_MATVAL_VALUE)
+							if (nMatValType > SC_MATVAL_BOOLEAN)
 							{
                                 if ( pResult->IsEmptyPath( 0, 0))
                                 {   // result of empty FALSE jump path
Index: sc/source/core/tool/scmatrix.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/scmatrix.cxx,v
retrieving revision 1.14
retrieving revision 1.14.52.1
diff -u -w -p -u -p -r1.14 -r1.14.52.1
--- sc/source/core/tool/scmatrix.cxx	27 Feb 2007 12:18:59 -0000	1.14
+++ sc/source/core/tool/scmatrix.cxx	8 May 2007 21:16:02 -0000	1.14.52.1
@@ -73,7 +73,8 @@ void ScMatrix::CreateMatrix(SCSIZE nC, S
 	}
 	else
 		pMat = new ScMatrixValue[nCount];
-	bIsString = NULL;
+	mnValType = NULL;
+    mnNonValue = 0;
 }
 
 ScMatrix::~ScMatrix()
@@ -141,9 +142,10 @@ ScMatrix::ScMatrix(SvStream& /* rStream 
 
 			if ( i < nCount )
 			{
-				if (!bIsString)
+				if (!mnValType)
 					ResetIsString();		// init string flags
-				bIsString[i] = ( nType == CELLTYPE_NONE ? SC_MATVAL_EMPTY : SC_MATVAL_STRING );
+				mnValType[i] = ( nType == CELLTYPE_NONE ? SC_MATVAL_EMPTY : SC_MATVAL_STRING );
+                mnNonValue++;
 
 				if ( nType == CELLTYPE_STRING )
 					pMat[i].pS = new String(aMatStr);
@@ -190,14 +192,14 @@ void ScMatrix::Store(SvStream& /* rStrea
 	for (SCSIZE i=0; i<nCount; i++)
 	{
 		BYTE nType = CELLTYPE_VALUE;
-		if ( bIsString && bIsString[i] )
+		if ( mnValType && mnValType[i] > SC_MATVAL_BOOLEAN)
 		{
 			if ( pMat[i].pS )
 				aMatStr = *pMat[i].pS;
 			else
 				aMatStr.Erase();
 
-			if ( bIsString[i] == SC_MATVAL_STRING )
+			if ( mnValType[i] == SC_MATVAL_STRING )
 				nType = CELLTYPE_STRING;
 			else
 				nType = CELLTYPE_NONE;
@@ -214,31 +216,33 @@ void ScMatrix::Store(SvStream& /* rStrea
 void ScMatrix::ResetIsString()
 {
 	SCSIZE nCount = nColCount * nRowCount;
-	if (bIsString)
+	if (mnValType)
 	{
 		for (SCSIZE i = 0; i < nCount; i++)
 		{
-			if ( bIsString[i] )
+			if ( mnValType[i] > SC_MATVAL_BOOLEAN)
 				delete pMat[i].pS;
 		}
 	}
 	else
-		bIsString = new BYTE[nCount];
-	memset( bIsString, 0, nCount * sizeof( BYTE ) );
+		mnValType = new BYTE[nCount];
+	memset( mnValType, 0, nCount * sizeof( BYTE ) );
+    mnNonValue = 0;
 }
 
 void ScMatrix::DeleteIsString()
 {
-	if ( bIsString )
+	if ( mnValType )
 	{
 		SCSIZE nCount = nColCount * nRowCount;
 		for ( SCSIZE i = 0; i < nCount; i++ )
 		{
-			if ( bIsString[i] )
+			if ( mnValType[i] > SC_MATVAL_BOOLEAN)
 				delete pMat[i].pS;
 		}
-		delete [] bIsString;
-		bIsString = NULL;
+		delete [] mnValType;
+		mnValType = NULL;
+        mnNonValue = 0;
 	}
 }
 
@@ -263,7 +267,8 @@ void ScMatrix::PutDoubleAndResetString( 
 	if ( IsString( nIndex ) )
 	{
 		delete pMat[nIndex].pS;
-		bIsString[nIndex] = 0;
+		mnValType[nIndex] = 0;
+        mnNonValue--;
 	}
 	PutDouble( fVal, nIndex );
 }
@@ -278,19 +283,22 @@ void ScMatrix::PutString(const String& r
 
 void ScMatrix::PutString(const String& rStr, SCSIZE nIndex)
 {
-	if (bIsString == NULL)
+	if (mnValType == NULL)
 		ResetIsString();
-	if ( bIsString[nIndex] && pMat[nIndex].pS )
+	if ( mnValType[nIndex] > SC_MATVAL_BOOLEAN && pMat[nIndex].pS )
 		*(pMat[nIndex].pS) = rStr;
 	else
+    {
 		pMat[nIndex].pS = new String(rStr);
-	bIsString[nIndex] = SC_MATVAL_STRING;
+        mnNonValue++;
+    }
+	mnValType[nIndex] = SC_MATVAL_STRING;
 }
 
 void ScMatrix::PutStringEntry( const String* pStr, BYTE bFlag, SCSIZE nIndex )
 {
 	DBG_ASSERT( bFlag, "ScMatrix::PutStringEntry: bFlag == 0" );
-	if (bIsString == NULL)
+	if (mnValType == NULL)
 		ResetIsString();
     // Make sure all bytes of the union are initialized to be able to access
     // the value with if (IsValueOrEmpty()) GetDouble(). Backup pS first.
@@ -299,7 +307,7 @@ void ScMatrix::PutStringEntry( const Str
     // An EMPTY entry must not have a string pointer therefor.
     DBG_ASSERT( (((bFlag & SC_MATVAL_EMPTY) == SC_MATVAL_EMPTY) && !pStr) || TRUE,
             "ScMatrix::PutStringEntry: pStr passed though EMPTY entry");
-	if ( bIsString[nIndex] && pS )
+	if ( mnValType[nIndex] > SC_MATVAL_BOOLEAN && pS )
 	{
         if ((bFlag & SC_MATVAL_EMPTY) == SC_MATVAL_EMPTY)
             delete pS, pS = NULL;
@@ -310,8 +318,11 @@ void ScMatrix::PutStringEntry( const Str
         pMat[nIndex].pS = pS;
 	}
 	else
+    {
 		pMat[nIndex].pS = (pStr ? new String(*pStr) : NULL);
-	bIsString[nIndex] = bFlag;
+        mnNonValue++;
+    }
+	mnValType[nIndex] = bFlag;
 }
 
 void ScMatrix::PutEmpty(SCSIZE nC, SCSIZE nR)
@@ -324,11 +335,17 @@ void ScMatrix::PutEmpty(SCSIZE nC, SCSIZ
 
 void ScMatrix::PutEmpty(SCSIZE nIndex)
 {
-	if (bIsString == NULL)
+	if (mnValType == NULL)
 		ResetIsString();
-	if ( bIsString[nIndex] && pMat[nIndex].pS )
+	if ( mnValType[nIndex] > SC_MATVAL_BOOLEAN && pMat[nIndex].pS )
+    {
 		delete pMat[nIndex].pS;
-	bIsString[nIndex] = SC_MATVAL_EMPTY;
+    }
+    else
+    {
+        mnNonValue++;
+    }
+	mnValType[nIndex] = SC_MATVAL_EMPTY;
 	pMat[nIndex].pS = NULL;
 	pMat[nIndex].fVal = 0.0;
 }
@@ -343,15 +360,44 @@ void ScMatrix::PutEmptyPath(SCSIZE nC, S
 
 void ScMatrix::PutEmptyPath(SCSIZE nIndex)
 {
-    if (bIsString == NULL)
+    if (mnValType == NULL)
         ResetIsString();
-    if ( bIsString[nIndex] && pMat[nIndex].pS )
+    if ( mnValType[nIndex] > SC_MATVAL_BOOLEAN && pMat[nIndex].pS )
+    {
         delete pMat[nIndex].pS;
-    bIsString[nIndex] = SC_MATVAL_EMPTYPATH;
+    }
+    else
+    {
+        mnNonValue++;
+    }
+    mnValType[nIndex] = SC_MATVAL_EMPTYPATH;
     pMat[nIndex].pS = NULL;
     pMat[nIndex].fVal = 0.0;
 }
 
+void ScMatrix::PutBoolean(bool bVal, SCSIZE nC, SCSIZE nR)
+{
+	if (ValidColRow( nC, nR))
+		PutBoolean( bVal, CalcOffset( nC, nR) );
+	else
+		DBG_ERRORFILE("ScMatrix::PutBoolean: dimension error");
+}
+
+void ScMatrix::PutBoolean( bool bVal, SCSIZE nIndex)
+{
+    if (mnValType == NULL)
+        ResetIsString();
+    if ( mnValType[nIndex] > SC_MATVAL_BOOLEAN && pMat[nIndex].pS )
+    {
+        delete pMat[nIndex].pS;
+        mnNonValue--;
+    }
+
+    mnValType[nIndex] = SC_MATVAL_BOOLEAN;
+    pMat[nIndex].pS = NULL;
+    pMat[nIndex].fVal = bVal ? 1. : 0.;
+}
+
 USHORT ScMatrix::GetError( SCSIZE nC, SCSIZE nR) const
 {
     if (ValidColRow( nC, nR))
@@ -443,8 +489,8 @@ const ScMatrixValue* ScMatrix::Get(SCSIZ
 	if (ValidColRow( nC, nR))
 	{
 		SCSIZE nIndex = CalcOffset( nC, nR);
-		if (bIsString)
-			nType = bIsString[nIndex];
+		if (mnValType)
+			nType = mnValType[nIndex];
 		else
 			nType = SC_MATVAL_VALUE;
 		return &pMat[nIndex];
@@ -463,19 +509,22 @@ void ScMatrix::MatCopy(ScMatrix& mRes) c
 	}
 	else
 	{
-		if (bIsString)
+		if (mnValType)
 		{
+            ScMatValType nType;
 			mRes.ResetIsString();
 			for (SCSIZE i = 0; i < nColCount; i++)
 			{
 				SCSIZE nStart = i * nRowCount;
 				for (SCSIZE j = 0; j < nRowCount; j++)
 				{
-					if ( bIsString[nStart+j] )
-						mRes.PutStringEntry( pMat[nStart+j].pS,
-							bIsString[nStart+j], nStart+j );
+					if ( (nType = mnValType[nStart+j]) > SC_MATVAL_BOOLEAN)
+						mRes.PutStringEntry( pMat[nStart+j].pS, nType, nStart+j );
 					else
+                    {
 						mRes.pMat[nStart+j].fVal = pMat[nStart+j].fVal;
+                        mRes.mnValType[nStart+j] = nType;
+                    }
 				}
 			}
 		}
@@ -497,19 +546,22 @@ void ScMatrix::MatTrans(ScMatrix& mRes) 
 	}
 	else
 	{
-		if (bIsString)
+		if (mnValType)
 		{
+            ScMatValType nType;
 			mRes.ResetIsString();
 			for ( SCSIZE i = 0; i < nColCount; i++ )
 			{
 				SCSIZE nStart = i * nRowCount;
 				for ( SCSIZE j = 0; j < nRowCount; j++ )
 				{
-					if ( bIsString[nStart+j] )
-						mRes.PutStringEntry( pMat[nStart+j].pS,
-							bIsString[nStart+j], j*mRes.nRowCount+i );
+					if ( (nType = mnValType[nStart+j]) > SC_MATVAL_BOOLEAN )
+						mRes.PutStringEntry( pMat[nStart+j].pS, nType, j*mRes.nRowCount+i );
 					else
+                    {
 						mRes.pMat[j*mRes.nRowCount+i].fVal = pMat[nStart+j].fVal;
+						mRes.mnValType[j*mRes.nRowCount+i] = nType;
+                    }
 				}
 			}
 		}
@@ -536,19 +588,23 @@ void ScMatrix::MatCopyUpperLeft(ScMatrix
 	}
 	else
 	{
-		if (bIsString)
+		if (mnValType)
 		{
+            ScMatValType nType;
 			mRes.ResetIsString();
 			for ( SCSIZE i = 0; i < mRes.nColCount; i++ )
 			{
 				SCSIZE nStart = i * nRowCount;
 				for ( SCSIZE j = 0; j < mRes.nRowCount; j++ )
 				{
-					if ( bIsString[nStart+j] )
-						mRes.PutStringEntry( pMat[nStart+j].pS, bIsString[nStart+j],
+					if ( (nType = mnValType[nStart+j]) > SC_MATVAL_BOOLEAN )
+						mRes.PutStringEntry( pMat[nStart+j].pS, nType,
 							i*mRes.nRowCount+j );
 					else
+                    {
 						mRes.pMat[i*mRes.nRowCount+j].fVal = pMat[nStart+j].fVal;
+						mRes.mnValType[i*mRes.nRowCount+j] = nType;
+                    }
 				}
 			}
 		}
@@ -611,10 +667,10 @@ void ScMatrix::FillDoubleLowerLeft( doub
 void ScMatrix::CompareEqual()
 {
 	SCSIZE n = nColCount * nRowCount;
-	if ( bIsString )
+	if ( mnValType )
 	{
 		for ( SCSIZE j=0; j<n; j++ )
-			if ( !bIsString[j])		// else: #WERT!
+			if ( mnValType[j] <= SC_MATVAL_BOOLEAN )		// else: #WERT!
                 if ( ::rtl::math::isFinite( pMat[j].fVal))  // else: DoubleError
                     pMat[j].fVal = (pMat[j].fVal == 0.0);
 	}
@@ -629,10 +685,10 @@ void ScMatrix::CompareEqual()
 void ScMatrix::CompareNotEqual()
 {
 	SCSIZE n = nColCount * nRowCount;
-	if ( bIsString )
+	if ( mnValType )
 	{
 		for ( SCSIZE j=0; j<n; j++ )
-			if ( !bIsString[j])		// else: #WERT!
+			if ( mnValType[j] <= SC_MATVAL_BOOLEAN )		// else: #WERT!
                 if ( ::rtl::math::isFinite( pMat[j].fVal))  // else: DoubleError
                     pMat[j].fVal = (pMat[j].fVal != 0.0);
 	}
@@ -647,10 +703,10 @@ void ScMatrix::CompareNotEqual()
 void ScMatrix::CompareLess()
 {
 	SCSIZE n = nColCount * nRowCount;
-	if ( bIsString )
+	if ( mnValType )
 	{
 		for ( SCSIZE j=0; j<n; j++ )
-			if ( !bIsString[j])		// else: #WERT!
+			if ( mnValType[j] <= SC_MATVAL_BOOLEAN )		// else: #WERT!
                 if ( ::rtl::math::isFinite( pMat[j].fVal))  // else: DoubleError
                     pMat[j].fVal = (pMat[j].fVal < 0.0);
 	}
@@ -665,10 +721,10 @@ void ScMatrix::CompareLess()
 void ScMatrix::CompareGreater()
 {
 	SCSIZE n = nColCount * nRowCount;
-	if ( bIsString )
+	if ( mnValType )
 	{
 		for ( SCSIZE j=0; j<n; j++ )
-			if ( !bIsString[j])		// else: #WERT!
+			if ( mnValType[j] <= SC_MATVAL_BOOLEAN )		// else: #WERT!
                 if ( ::rtl::math::isFinite( pMat[j].fVal))  // else: DoubleError
                     pMat[j].fVal = (pMat[j].fVal > 0.0);
 	}
@@ -683,10 +739,10 @@ void ScMatrix::CompareGreater()
 void ScMatrix::CompareLessEqual()
 {
 	SCSIZE n = nColCount * nRowCount;
-	if ( bIsString )
+	if ( mnValType )
 	{
 		for ( SCSIZE j=0; j<n; j++ )
-			if ( !bIsString[j])		// else: #WERT!
+			if ( mnValType[j] <= SC_MATVAL_BOOLEAN )		// else: #WERT!
                 if ( ::rtl::math::isFinite( pMat[j].fVal))  // else: DoubleError
                     pMat[j].fVal = (pMat[j].fVal <= 0.0);
 	}
@@ -701,10 +757,10 @@ void ScMatrix::CompareLessEqual()
 void ScMatrix::CompareGreaterEqual()
 {
 	SCSIZE n = nColCount * nRowCount;
-	if ( bIsString )
+	if ( mnValType )
 	{
 		for ( SCSIZE j=0; j<n; j++ )
-			if ( !bIsString[j])		// else: #WERT!
+			if ( mnValType[j] <= SC_MATVAL_BOOLEAN )		// else: #WERT!
                 if ( ::rtl::math::isFinite( pMat[j].fVal))  // else: DoubleError
                     pMat[j].fVal = (pMat[j].fVal >= 0.0);
 	}
@@ -720,11 +776,11 @@ double ScMatrix::And()
 {
 	SCSIZE n = nColCount * nRowCount;
 	bool bAnd = true;
-	if ( bIsString )
+	if ( mnValType )
 	{
 		for ( SCSIZE j=0; bAnd && j<n; j++ )
         {
-			if ( bIsString[j] )
+			if ( mnValType[j] > SC_MATVAL_BOOLEAN )
             {   // assuming a CompareMat this is an error
                 return CreateDoubleError( errIllegalArgument );
             }
@@ -751,10 +807,10 @@ double ScMatrix::Or()
 {
 	SCSIZE n = nColCount * nRowCount;
 	bool bOr = false;
-	if ( bIsString )
+	if ( mnValType )
 	{
 		for ( SCSIZE j=0; !bOr && j<n; j++ )
-            if ( bIsString[j] )
+            if ( mnValType[j] > SC_MATVAL_BOOLEAN )
             {   // assuming a CompareMat this is an error
                 return CreateDoubleError( errIllegalArgument );
             }
Index: sc/source/core/tool/token.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/token.cxx,v
retrieving revision 1.26
retrieving revision 1.26.54.3
diff -u -w -p -u -p -r1.26 -r1.26.54.3
--- sc/source/core/tool/token.cxx	27 Feb 2007 12:19:23 -0000	1.26
+++ sc/source/core/tool/token.cxx	8 May 2007 21:17:26 -0000	1.26.54.3
@@ -1455,6 +1455,162 @@ ScToken* ScTokenArray::AddToken( const S
 	return Add( r.Clone() );
 }
 
+// Utility function to ensure that there is strict alternation of values and
+// seperators.
+static bool
+checkArraySep( bool & bPrevWasSep, bool bNewVal )
+{
+    bool bResult = (bPrevWasSep == bNewVal);
+    bPrevWasSep = bNewVal;
+    return bResult;
+}
+
+ScToken* ScTokenArray::MergeArray( )
+{
+    int nCol = -1, nRow = 0;
+    int i, nPrevRowSep = -1, nStart = 0;
+    bool bPrevWasSep = false; // top of stack is ocArrayClose
+    ScToken* t;
+
+    // (1) Iterate from the end to the start to find matrix dims
+    // and do basic validation.
+    for ( i = nLen ; i-- > nStart ; )
+    {
+        t = pCode[i];
+        switch ( t->GetOpCode() )
+        {
+            case ocPush :
+                if( checkArraySep( bPrevWasSep, false ) )
+                {
+                    return NULL;
+                }
+
+                // no references or nested arrays
+                if ( t->GetType() != svDouble  && t->GetType() != svString )
+                {
+                    return NULL;
+                }
+            break;
+
+            case ocMissing :
+            case ocTrue :
+            case ocFalse :
+                if( checkArraySep( bPrevWasSep, false ) )
+                {
+                    return NULL;
+                }
+            break;
+
+            case ocSep :
+                if( checkArraySep( bPrevWasSep, true ) )
+                {
+                    return NULL;
+                }
+            break;
+
+            case ocArrayClose :
+                // not possible with the , but check just in case
+                // something changes in the future
+                if( i != (nLen-1))
+                {
+                    return NULL;
+                }
+
+                if( checkArraySep( bPrevWasSep, true ) )
+                {
+                    return NULL;
+                }
+
+                nPrevRowSep = i;
+            break;
+
+            case ocArrayOpen :
+                nStart = i; // stop iteration
+                // fall through to ArrayRowSep
+
+            case ocArrayRowSep :
+                if( checkArraySep( bPrevWasSep, true ) )
+                {
+                    return NULL;
+                }
+                
+                if( nPrevRowSep < 0 ||              // missing ocArrayClose
+                    ((nPrevRowSep - i) % 2) == 1)   // no complex elements
+                {
+                    return NULL;
+                }
+
+                if( nCol < 0 )
+                {
+                    nCol = (nPrevRowSep - i) / 2;
+                }
+                else if( (nPrevRowSep - i)/2 != nCol)   // irregular array
+                {
+                    return NULL;
+                }
+
+                nPrevRowSep = i;
+                nRow++;
+            break;
+
+            default :
+                // no functions or operators
+                return NULL;
+        }
+    }
+    if( nCol <= 0 || nRow <= 0 )
+        return NULL;
+
+    // fprintf (stderr, "Array (cols = %d, rows = %d)\n", nCol, nRow );
+
+    ScMatrix* pArray = new ScMatrix( nCol, nRow );
+    for ( i = nStart, nCol = 0, nRow = 0 ; i < nLen ; i++ )
+    {
+        t = pCode[i];
+
+        switch ( t->GetOpCode() )
+        {
+            case ocPush :
+                if ( t->GetType() == svDouble )
+                {
+                    pArray->PutDouble( t->GetDouble(), nCol, nRow );
+                }
+                else if ( t->GetType() == svString )
+                {
+                    pArray->PutString( t->GetString(), nCol, nRow );
+                }
+            break;
+
+            case ocMissing :
+                pArray->PutEmpty( nCol, nRow );
+            break;
+
+            case ocTrue :
+                pArray->PutBoolean( true, nCol, nRow );
+            break;
+
+            case ocFalse :
+                pArray->PutBoolean( false, nCol, nRow );
+            break;
+
+            case ocSep :
+                nCol++;
+            break;
+
+            case ocArrayRowSep :
+                nRow++; nCol = 0;
+            break;
+
+            default :
+                break;
+        }
+        pCode[i] = NULL;
+        t->DecRef();
+    }
+    nLen = nStart;
+    return AddMatrix( pArray );
+}
+
 // Wird auch vom Compiler genutzt. Das Token ist per new angelegt!
 
 ScToken* ScTokenArray::Add( ScToken* t )
@@ -1463,11 +1619,14 @@ ScToken* ScTokenArray::Add( ScToken* t )
 		pCode = new ScToken*[ MAXCODE ];
 	if( nLen < MAXCODE-1 )
 	{
+        // fprintf (stderr, "Add : %d\n", t->GetOpCode());
 		pCode[ nLen++ ] = t;
 		if( t->GetOpCode() == ocPush
 			&& ( t->GetType() == svSingleRef || t->GetType() == svDoubleRef ) )
 			nRefs++;
 		t->IncRef();
+        if( t->GetOpCode() == ocArrayClose )
+            return MergeArray();
 		return t;
 	}
 	else
Index: sc/source/filter/excel/excform.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excform.cxx,v
retrieving revision 1.45
retrieving revision 1.45.52.2
diff -u -w -p -u -p -r1.45 -r1.45.52.2
--- sc/source/filter/excel/excform.cxx	27 Feb 2007 12:21:35 -0000	1.45
+++ sc/source/filter/excel/excform.cxx	8 May 2007 21:16:02 -0000	1.45.52.2
@@ -152,7 +152,7 @@ void ImportExcel::Formula( const XclAddr
 			bConvert = TRUE;
 
 		if( bConvert )
-            eErr = pFormConv->Convert( pErgebnis, maStrm, nFormLen );
+            eErr = pFormConv->Convert( pErgebnis, maStrm, nFormLen, true, FT_CellFormula);
 
 		ScFormulaCell*		pZelle = NULL;
 
@@ -210,8 +210,10 @@ void ExcelToSc::GetDummy( const ScTokenA
 }
 
 
-// stream seeks to first byte after <nFormulaLen>
-ConvErr ExcelToSc::Convert( const ScTokenArray*& pErgebnis, XclImpStream& aIn, sal_Size nFormulaLen, const FORMULA_TYPE eFT )
+// if bAllowArrays is false stream seeks to first byte after <nFormulaLen>
+// otherwise it will seek to the first byte after the additional content (eg
+// inline arrays) following <nFormulaLen>
+ConvErr ExcelToSc::Convert( const ScTokenArray*& pErgebnis, XclImpStream& aIn, sal_Size nFormulaLen, bool bAllowArrays, const FORMULA_TYPE eFT )
 {
     RootData&       rR = GetOldRoot();
 	BYTE			nOp, nLen, nByte;
@@ -228,6 +230,7 @@ ConvErr ExcelToSc::Convert( const ScToke
 
 	SingleRefData	aSRD;
 	ComplRefData	aCRD;
+    ExtensionTypeVec    aExtensions;
 
 	bExternName = FALSE;
 
@@ -474,9 +477,23 @@ ConvErr ExcelToSc::Convert( const ScToke
 			case 0x40:
 			case 0x60:
 			case 0x20: // Array Constant						[317 268]
+                if( bAllowArrays )
+                {
+                    aIn >> nByte >> nUINT16;
+                    aIn.Ignore( 4 );
+
+                    SCSIZE nC = nByte + 1;
+                    SCSIZE nR = nUINT16 + 1;
+
+                    aStack << aPool.StoreMatrix( nC, nR );
+                    aExtensions.push_back( EXTENSION_ARRAY );
+                }
+                else
+                {
                 aIn.Ignore( 7 );
 				aPool << ocBad;
 				aPool >> aStack;
+                }
 				break;
 			case 0x41:
 			case 0x61:
@@ -606,6 +623,9 @@ ConvErr ExcelToSc::Convert( const ScToke
 			case 0x46:
 			case 0x66:
 			case 0x26: // Constant Reference Subexpression		[321 271]
+                aExtensions.push_back( EXTENSION_MEMAREA );
+                // fall through
+
 			case 0x47:
 			case 0x67:
 			case 0x27: // Erroneous Constant Reference Subexpr.	[322 272]
@@ -885,6 +905,10 @@ ConvErr ExcelToSc::Convert( const ScToke
 	}
 
     aIn.Seek( nEndPos );
+
+    if( eRet == ConvOK )
+        ReadExtensions( aExtensions, aIn );
+
 	return eRet;
 }
 
@@ -1681,5 +1705,153 @@ void ExcelToSc::SetComplRow( ComplRefDat
 		rSRD.nRow = MAXROW;
 }
 
+void ExcelToSc::ReadExtensionArray( unsigned int n, XclImpStream& aIn )
+{
+    // printf( "inline array;\n" );
+
+    BYTE        nByte;
+    UINT16      nUINT16;
+    double      fDouble;
+    String      aString;
+    ScMatrix*   pMatrix;
+
+    aIn >> nByte >> nUINT16;
+
+    SCSIZE nC, nCols;
+    SCSIZE nR, nRows;
+    if( GetBiff() == EXC_BIFF8 )
+    {
+        nCols = nByte + 1;
+        nRows = nUINT16 + 1;
+    }
+    else
+    {
+        nCols = nByte ? nByte : 256;
+        nRows = nUINT16;
+    }
+
+    pMatrix = aPool.GetMatrix( n );
+
+    if( NULL != pMatrix )
+    {
+        pMatrix->GetDimensions( nC, nR);
+        if( nC != nCols || nR != nRows )
+        {
+            DBG_ERRORFILE( "ExcelToSc::ReadExtensionArray - matrix size mismatch" );
+            pMatrix = NULL;
+        }
+    }
+    else
+    {
+        DBG_ERRORFILE( "ExcelToSc::ReadExtensionArray - missing matrix" );
+    }
+
+    for( nR = 0 ; nR < nRows; nR++ )
+    {
+        for( nC = 0 ; nC < nCols; nC++ )
+        {
+            aIn >> nByte;
+            switch( nByte )
+            {
+                case EXC_CACHEDVAL_EMPTY:
+                    aIn.Ignore( 8 );
+                    if( NULL != pMatrix )
+                    {
+                        pMatrix->PutEmpty( nC, nR );
+                    }
+                    break;
+
+                case EXC_CACHEDVAL_DOUBLE:
+                    aIn >> fDouble;
+                    if( NULL != pMatrix )
+                    {
+                        pMatrix->PutDouble( fDouble, nC, nR );
+                    }
+                    break;
+
+                case EXC_CACHEDVAL_STRING:
+                    if( GetBiff() == EXC_BIFF8 )
+                    {
+                        aIn >> nUINT16;
+                        aString = aIn.ReadUniString( nUINT16 );
+                    }
+                    else
+                    {
+                        aIn >> nByte;
+                        aString = aIn.ReadRawByteString( nByte );
+                    }
+                    if( NULL != pMatrix )
+                    {
+                        pMatrix->PutString( aString, nC, nR );
+                    }
+                    break;
+
+                case EXC_CACHEDVAL_BOOL:
+                    aIn >> nByte;
+                    aIn.Ignore( 7 );
+                    if( NULL != pMatrix )
+                    {
+                        pMatrix->PutBoolean( nByte != 0, nC, nR );
+                    }
+                    break;
+
+                case EXC_CACHEDVAL_ERROR:
+                    aIn >> nByte;
+                    aIn.Ignore( 7 );
+                    if( NULL != pMatrix )
+                    {
+                        pMatrix->PutError( XclTools::GetScErrorCode( nByte ), nC, nR );
+                    }
+                    break;
+            }
+        }
+    }
+}
 
+void ExcelToSc::ReadExtensionNlr( XclImpStream& aIn )
+{
+    // printf( "natural lang fmla;\n" );
+
+    sal_uInt32 nFlags;
+    aIn >> nFlags;
+
+    sal_uInt32 nCount = nFlags & EXC_TOK_NLR_ADDMASK;
+    aIn.Ignore( nCount * (4 + 2) ); // Drop the cell positions
+}
+
+void ExcelToSc::ReadExtensionMemArea( XclImpStream& aIn )
+{
+    // printf( "mem area;\n" );
+
+    sal_uInt16 nCount;
+    aIn >> nCount;
+
+    aIn.Ignore( nCount * (4 + 4 + 2 + 2) ); // drop the ranges
+}
+
+void ExcelToSc::ReadExtensions( const ExtensionTypeVec& rExtensions,
+                                XclImpStream& aIn )
+{
+    unsigned int nArray = 0;
+
+    for( unsigned int i = 0 ; i < rExtensions.size() ; i++ )
+    {
+        ExtensionType eType = rExtensions[i];
+
+        switch( eType )
+        {
+            case EXTENSION_ARRAY:
+                ReadExtensionArray( nArray++, aIn );
+                break;
+
+            case EXTENSION_NLR:
+                ReadExtensionNlr( aIn );
+                break;
+
+            case EXTENSION_MEMAREA:
+                ReadExtensionMemArea( aIn );
+                break;
+        }
+    }
+}
 
Index: sc/source/filter/excel/excform8.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excform8.cxx,v
retrieving revision 1.42
retrieving revision 1.42.52.1
diff -u -w -p -u -p -r1.42 -r1.42.52.1
--- sc/source/filter/excel/excform8.cxx	27 Feb 2007 12:21:47 -0000	1.42
+++ sc/source/filter/excel/excform8.cxx	26 Apr 2007 12:26:04 -0000	1.42.52.1
@@ -81,8 +81,9 @@ BOOL ExcelToSc8::Read3DTabReference( Xcl
 }
 
 
-// stream seeks to first byte after <nFormulaLen>
-ConvErr ExcelToSc8::Convert( const ScTokenArray*& rpTokArray, XclImpStream& aIn, sal_Size nFormulaLen, const FORMULA_TYPE eFT )
+// if bAllowArrays is false stream seeks to first byte after <nFormulaLen>
+// otherwise it will seek to the first byte past additional content after <nFormulaLen>
+ConvErr ExcelToSc8::Convert( const ScTokenArray*& rpTokArray, XclImpStream& aIn, sal_Size nFormulaLen, bool bAllowArrays, const FORMULA_TYPE eFT )
 {
 	BYTE					nOp, nLen, nByte;
     UINT16                  nUINT16;
@@ -94,10 +95,10 @@ ConvErr ExcelToSc8::Convert( const ScTok
 	const BOOL				bRangeName = eFT == FT_RangeName;
 	const BOOL				bSharedFormula = eFT == FT_SharedFormula;
 	const BOOL				bRNorSF = bRangeName || bSharedFormula;
-	UINT32					nExtCnt = 0;
 
 	SingleRefData			aSRD;
 	ComplRefData			aCRD;
+    ExtensionTypeVec		aExtensions;
 
 	if( eStatus != ConvOK )
 	{
@@ -288,7 +289,7 @@ ConvErr ExcelToSc8::Convert( const ScTok
 						break;
 					case 0x0B:				//	RadicalS	13		x		ref
                         aIn.Ignore( 13 );
-						nExtCnt++;
+                        aExtensions.push_back( EXTENSION_NLR );
                         aPool << ocBad;
                         aPool >> aStack;
                     break;
@@ -297,7 +298,7 @@ ConvErr ExcelToSc8::Convert( const ScTok
                     case 0x0E:              //  RwSV        4       x       val
                     case 0x0F:              //  ColSV       4       x       val
                         aIn.Ignore( 4 );
-						nExtCnt++;
+                        aExtensions.push_back( EXTENSION_NLR );
                         aPool << ocBad;
                         aPool >> aStack;
                     break;
@@ -371,9 +372,23 @@ ConvErr ExcelToSc8::Convert( const ScTok
 			case 0x40:
 			case 0x60:
 			case 0x20: // Array Constant						[317 268]
+                if( bAllowArrays )
+                {
+                    aIn >> nByte >> nUINT16;
+                    aIn.Ignore( 4 );
+
+                    SCSIZE nC = nByte + 1;
+                    SCSIZE nR = nUINT16 + 1;
+
+                    aStack << aPool.StoreMatrix( nC, nR );
+                    aExtensions.push_back( EXTENSION_ARRAY );
+                }
+                else
+                {
                 aIn.Ignore( 7 );
 				aPool << ocBad;
 				aPool >> aStack;
+                }
 				break;
 			case 0x41:
 			case 0x61:
@@ -493,6 +508,7 @@ ConvErr ExcelToSc8::Convert( const ScTok
 			case 0x46:
 			case 0x66:
 			case 0x26: // Constant Reference Subexpression		[321 271]
+				aExtensions.push_back( EXTENSION_MEMAREA );
                 aIn.Ignore( 6 );       // mehr steht da nicht!
 				break;
 			case 0x47:
@@ -788,6 +804,10 @@ ConvErr ExcelToSc8::Convert( const ScTok
 	}
 
     aIn.Seek( nEndPos );
+
+	if( eRet == ConvOK)
+		ReadExtensions( aExtensions, aIn );
+
 	return eRet;
 }
 
Index: sc/source/filter/excel/impop.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/impop.cxx,v
retrieving revision 1.86
retrieving revision 1.86.50.1
diff -u -w -p -u -p -r1.86 -r1.86.50.1
--- sc/source/filter/excel/impop.cxx	27 Feb 2007 12:23:20 -0000	1.86
+++ sc/source/filter/excel/impop.cxx	26 Apr 2007 12:26:04 -0000	1.86.50.1
@@ -538,7 +538,7 @@ void ImportExcel::Array25( void )
 
         pFormConv->Reset( ScAddress( static_cast<SCCOL>(nFirstCol),
                     static_cast<SCROW>(nFirstRow), GetCurrScTab() ) );
-        pFormConv->Convert( pErgebnis, maStrm, nFormLen );
+        pFormConv->Convert( pErgebnis, maStrm, nFormLen, true, FT_CellFormula);
 
 		DBG_ASSERT( pErgebnis, "*ImportExcel::Array25(): ScTokenArray ist NULL!" );
 
@@ -833,7 +833,7 @@ void ImportExcel::Shrfmla( void )
 	const ScTokenArray*	pErgebnis;
 
 	pFormConv->Reset();
-    pFormConv->Convert( pErgebnis, maStrm, nLenExpr, FT_SharedFormula );
+    pFormConv->Convert( pErgebnis, maStrm, nLenExpr, true, FT_SharedFormula );
 
 
 	DBG_ASSERT( pErgebnis, "+ImportExcel::Shrfmla(): ScTokenArray ist NULL!" );
@@ -1009,7 +1009,7 @@ void ImportExcel::Array34( void )
 
         pFormConv->Reset( ScAddress( static_cast<SCCOL>(nFirstCol),
                     static_cast<SCROW>(nFirstRow), GetCurrScTab() ) );
-        pFormConv->Convert( pErgebnis, maStrm, nFormLen );
+        pFormConv->Convert( pErgebnis, maStrm, nFormLen, true, FT_CellFormula);
 
 		DBG_ASSERT( pErgebnis, "+ImportExcel::Array34(): ScTokenArray ist NULL!" );
 
Index: sc/source/filter/excel/tokstack.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/tokstack.cxx,v
retrieving revision 1.11
retrieving revision 1.11.212.1
diff -u -w -p -u -p -r1.11 -r1.11.212.1
--- sc/source/filter/excel/tokstack.cxx	21 Jul 2006 11:52:00 -0000	1.11
+++ sc/source/filter/excel/tokstack.cxx	26 Apr 2007 12:26:04 -0000	1.11.212.1
@@ -111,6 +111,10 @@ TokenPool::TokenPool( void )
 	ppP_Nlf = new NLFCONT*[ nP_Nlf ];
 	memset( ppP_Nlf, 0, sizeof( NLFCONT* ) * nP_Nlf );
 
+    nP_Matrix = 16;
+    ppP_Matrix = new ScMatrix*[ nP_Matrix ];
+    memset( ppP_Matrix, 0, sizeof( ScMatrix* ) * nP_Matrix );
+
 	pScToken = new ScTokenArray;
 
 	Reset();
@@ -155,6 +159,13 @@ TokenPool::~TokenPool()
 	}
 	delete[] ppP_Nlf;
 
+    for( n = 0 ; n < nP_Matrix ; n++ )
+    {
+        if( ppP_Matrix[ n ] )
+            ppP_Matrix[ n ]->DecRef( );
+    }
+    delete[] ppP_Matrix;
+
 	delete pScToken;
 }
 
@@ -285,6 +296,20 @@ void TokenPool::GrowNlf( void )
 }
 
 
+void TokenPool::GrowMatrix( void )
+{
+    UINT16      nNewSize = nP_Matrix * 2;
+
+    ScMatrix**  ppNew = new ScMatrix*[ nNewSize ];
+
+    memset( ppNew, 0, sizeof( ScMatrix* ) * nNewSize );
+    memcpy( ppNew, ppP_Matrix, sizeof( ScMatrix* ) * nP_Matrix );
+
+    delete[] ppP_Matrix;
+    ppP_Matrix = ppNew;
+    nP_Matrix = nNewSize;
+}
+
 void TokenPool::GetElement( const UINT16 nId )
 {
 	DBG_ASSERT( nId < nElementAkt, "*TokenPool::GetElement(): Id zu gross!?" );
@@ -341,6 +366,15 @@ void TokenPool::GetElement( const UINT16
 						pScToken->AddColRowName( p->aRef );
 				}
 				break;
+            case T_Matrix:
+                {
+                UINT16          n = pElement[ nId ];
+                ScMatrix*       p = ( n < nP_Matrix )? ppP_Matrix[ n ] : NULL;
+
+                if( p )
+                        pScToken->AddMatrix( p );
+                }
+                break;
 			default:
 				DBG_ERROR("-TokenPool::GetElement(): Zustand undefiniert!?");
 		}
@@ -412,6 +446,15 @@ void TokenPool::GetElementRek( const UIN
 						pScToken->AddColRowName( p->aRef );
 					}
 					break;
+                case T_Matrix:
+                    {
+                    UINT16          n = pElement[ *pAkt ];
+                    ScMatrix*       p = ( n < nP_Matrix )? ppP_Matrix[ n ] : NULL;
+
+                    if( p )
+                            pScToken->AddMatrix( p );
+                    }
+                    break;
 				default:
 					DBG_ERROR("-TokenPool::GetElementRek(): Zustand undefiniert!?");
 			}
@@ -613,10 +656,33 @@ const TokenId TokenPool::StoreNlf( const
 	return ( const TokenId ) nElementAkt;
 }
 
+const TokenId TokenPool::StoreMatrix( SCSIZE nC, SCSIZE nR )
+{
+    ScMatrix* pM;
+
+    if( nElementAkt >= nElement )
+        GrowElement();
+
+    if( nP_MatrixAkt >= nP_Matrix )
+        GrowMatrix();
+
+    pElement[ nElementAkt ] = nP_MatrixAkt;
+    pType[ nElementAkt ] = T_Matrix;
+
+    pM = new ScMatrix( nC, nR );
+    pM->FillDouble( 0., 0,0, nC-1, nR-1 );
+    pM->IncRef( );
+    ppP_Matrix[ nP_MatrixAkt ] = pM;
+
+    nElementAkt++;
+    nP_MatrixAkt++;
+
+    return ( const TokenId ) nElementAkt;
+}
 
 void TokenPool::Reset( void )
 {
-	nP_IdAkt = nP_IdLast = nElementAkt = nP_StrAkt = nP_DblAkt = nP_RefTrAkt = nP_ExtAkt = nP_NlfAkt = 0;
+	nP_IdAkt = nP_IdLast = nElementAkt = nP_StrAkt = nP_DblAkt = nP_RefTrAkt = nP_ExtAkt = nP_NlfAkt = nP_MatrixAkt = 0;
 }
 
 
@@ -672,3 +738,12 @@ const String* TokenPool::GetString( cons
 	return p;
 }
 
+ScMatrix* TokenPool::GetMatrix( unsigned int n ) const
+{
+    if( n < nP_MatrixAkt )
+        return ppP_Matrix[ n ];
+    else
+        printf ("GETMATRIX %d >= %d\n", n, nP_MatrixAkt);
+    return NULL;
+}
+
Index: sc/source/filter/excel/xeformula.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xeformula.cxx,v
retrieving revision 1.15
retrieving revision 1.15.52.2
diff -u -w -p -u -p -r1.15 -r1.15.52.2
--- sc/source/filter/excel/xeformula.cxx	27 Feb 2007 12:24:32 -0000	1.15
+++ sc/source/filter/excel/xeformula.cxx	8 May 2007 21:16:03 -0000	1.15.52.2
@@ -106,6 +106,7 @@ struct XclExpCompConfig
     bool                mbFromCell;     /// True = Any kind of cell formula (cell, array, shared).
     bool                mb3DRefOnly;    /// True = Only 3D references allowed (e.g. names).
     bool                mbStopAtSep;    /// True = Stop compilation at ocSep in root level.
+    bool                mbAllowArrays;  /// True = Allow inline arrays
 };
 
 // ----------------------------------------------------------------------------
@@ -113,6 +114,8 @@ struct XclExpCompConfig
 /** Working data of the formula compiler. Used to push onto a stack for recursive calls. */
 struct XclExpCompData
 {
+    typedef ::std::list< const ScMatrix * > ScMatrixList;
+    typedef ScfRef< ScMatrixList > ScMatrixListRef;
     typedef ScfRef< ScTokenArray > ScTokenArrayRef;
 
     XclExpCompConfig    maCfg;          /// Configuration for current formula type.
@@ -121,6 +124,8 @@ struct XclExpCompData
     XclTokenArrayIterator maTokArrIt;   /// Iterator in Calc token array.
     XclExpLinkManager*  mpLinkMgr;      /// Link manager for current context (local/global).
     XclExpRefLog*       mpRefLog;       /// Log for external references.
+    ScMatrixListRef     maInlineArr;    /// List of inline arrays (in reverse order)
+
     const ScAddress*    mpScBasePos;    /// Current cell position of the formula.
 
     // processing data during compilation
@@ -281,8 +286,9 @@ private:
                             const ScAddress* pScBasePos, XclExpRefLog* pRefLog );
 
     void                LeaveRecursive();
-    void                FinalizeFormula();
-    XclTokenArrayRef    CreateTokenArray();
+    void                FinalizeFormula( ScfUInt8Vec & rExtensionTokens );
+    void                AppendInlineArrays( ScfUInt8Vec & rExtensionTokens );
+    XclTokenArrayRef    CreateTokenArray( ScfUInt8Vec* pExtensionTokens = NULL );
 
     // compiler ---------------------------------------------------------------
     // XclExpTokenData: pass-by-value and return-by-value is intended
@@ -347,6 +353,7 @@ private:
     XclExpRefLogEntry*  GetNewRefLogEntry();
     void                ProcessCellRef( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
     void                ProcessRangeRef( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
+    void                ProcessMatrix (const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
     void                ProcessDefinedName( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
     void                ProcessDatabaseArea( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
 
@@ -375,6 +382,7 @@ private:
 
     void                AppendAddress( const XclAddress& rXclPos );
     void                AppendRange( const XclRange& rXclRange );
+    void                AppendMatrixPlaceHolder( const ScMatrix* rMatrix );
 
     void                AppendSpaceToken( sal_uInt8 nType, sal_uInt8 nCount );
     void                AppendIntToken( sal_uInt16 nValue, sal_uInt8 nSpaces = 0 );
@@ -423,17 +431,17 @@ namespace {
 /** The table containing configuration data for all formula types. */
 static const XclExpCompConfig spConfigTable[] =
 {
-    // formula type         token class type      link manager type       inCell 3dOnly StopAtSep
-    { EXC_FMLATYPE_CELL,    EXC_CLASSTYPE_CELL,   EXC_LINKMGRTYPE_LOCAL,  true,  false, true  },
-    { EXC_FMLATYPE_SHARED,  EXC_CLASSTYPE_CELL,   EXC_LINKMGRTYPE_LOCAL,  true,  false, true  },
-    { EXC_FMLATYPE_MATRIX,  EXC_CLASSTYPE_ARRAY,  EXC_LINKMGRTYPE_LOCAL,  true,  false, true  },
-    { EXC_FMLATYPE_CONDFMT, EXC_CLASSTYPE_ARRAY,  EXC_LINKMGRTYPE_NONE,   false, false, true  },
-    { EXC_FMLATYPE_DATAVAL, EXC_CLASSTYPE_ARRAY,  EXC_LINKMGRTYPE_NONE,   false, false, true  },
-    { EXC_FMLATYPE_NAME,    EXC_CLASSTYPE_NAME,   EXC_LINKMGRTYPE_GLOBAL, false, true,  false },
-    { EXC_FMLATYPE_CHART,   EXC_CLASSTYPE_NAME,   EXC_LINKMGRTYPE_LOCAL,  false, true,  false },
-    { EXC_FMLATYPE_CONTROL, EXC_CLASSTYPE_NAME,   EXC_LINKMGRTYPE_LOCAL,  false, false, true  },
-    { EXC_FMLATYPE_WQUERY,  EXC_CLASSTYPE_NAME,   EXC_LINKMGRTYPE_LOCAL,  false, true,  false },
-    { EXC_FMLATYPE_LISTVAL, EXC_CLASSTYPE_NAME,   EXC_LINKMGRTYPE_NONE,   false, false, true  }
+    // formula type         token class type      link manager type       inCell 3dOnly StopAtSep allowArray
+    { EXC_FMLATYPE_CELL,    EXC_CLASSTYPE_CELL,   EXC_LINKMGRTYPE_LOCAL,  true,  false, true,       true  },
+    { EXC_FMLATYPE_SHARED,  EXC_CLASSTYPE_CELL,   EXC_LINKMGRTYPE_LOCAL,  true,  false, true,       true  },
+    { EXC_FMLATYPE_MATRIX,  EXC_CLASSTYPE_ARRAY,  EXC_LINKMGRTYPE_LOCAL,  true,  false, true,       true  },
+    { EXC_FMLATYPE_CONDFMT, EXC_CLASSTYPE_ARRAY,  EXC_LINKMGRTYPE_NONE,   false, false, true,       false  },
+    { EXC_FMLATYPE_DATAVAL, EXC_CLASSTYPE_ARRAY,  EXC_LINKMGRTYPE_NONE,   false, false, true,       false  },
+    { EXC_FMLATYPE_NAME,    EXC_CLASSTYPE_NAME,   EXC_LINKMGRTYPE_GLOBAL, false, true,  false,      true },
+    { EXC_FMLATYPE_CHART,   EXC_CLASSTYPE_NAME,   EXC_LINKMGRTYPE_LOCAL,  false, true,  false,      true },
+    { EXC_FMLATYPE_CONTROL, EXC_CLASSTYPE_NAME,   EXC_LINKMGRTYPE_LOCAL,  false, false, true,       false  },
+    { EXC_FMLATYPE_WQUERY,  EXC_CLASSTYPE_NAME,   EXC_LINKMGRTYPE_LOCAL,  false, true,  false,      false },
+    { EXC_FMLATYPE_LISTVAL, EXC_CLASSTYPE_NAME,   EXC_LINKMGRTYPE_NONE,   false, false, true,       false  }
 };
 
 } // namespace
@@ -497,10 +505,11 @@ XclTokenArrayRef XclExpFmlaCompImpl::Cre
         }
     }
 
-    // finalizing, e.g. add tAttr-volatile token
-    FinalizeFormula();
+    // finalizing, e.g. add tAttr-volatile token, and storing any inline arrays
+    ScfUInt8Vec aExtensionTokens;
+    FinalizeFormula( aExtensionTokens );
 
-    return CreateTokenArray();
+    return CreateTokenArray( &aExtensionTokens );
 }
 
 XclTokenArrayRef XclExpFmlaCompImpl::CreateErrorFormula( sal_uInt8 nErrCode )
@@ -570,6 +579,9 @@ void XclExpFmlaCompImpl::Init( XclFormul
         maTokArrIt.Init();
         mpLinkMgr = 0;
         mpRefLog = 0;
+
+    maInlineArr.reset( NULL );
+
         mpScBasePos = 0;
 
         // init processing data used during compilation
@@ -635,7 +647,98 @@ void XclExpFmlaCompImpl::LeaveRecursive(
     }
 }
 
-void XclExpFmlaCompImpl::FinalizeFormula()
+void XclExpFmlaCompImpl::AppendInlineArrays( ScfUInt8Vec & rExtensionTokens )
+{
+    const ScMatrixList::reverse_iterator end = maInlineArr->rend();
+    ScMatrixList::reverse_iterator i = maInlineArr->rbegin();
+    for( ;  i != end ; i++ )
+    {
+        const ScMatrix *pMatrix = *i;
+        SCSIZE nC, nMaxC, nR, nMaxR;
+
+        pMatrix->GetDimensions( nMaxC, nMaxR);
+
+        if( meBiff == EXC_BIFF8 )
+        {
+            rExtensionTokens.push_back( nMaxC - 1 );
+            rExtensionTokens.resize( rExtensionTokens.size() + 2 );
+            ShortToSVBT16( nMaxR - 1, &*(rExtensionTokens.end() - 2) );
+        }
+        else
+        {
+            rExtensionTokens.push_back( nMaxC == 256 ? 0 : nMaxC );
+            rExtensionTokens.resize( rExtensionTokens.size() + 2 );
+            ShortToSVBT16( nMaxR, &*(rExtensionTokens.end() - 2) );
+        }
+
+        for( nR = 0 ; nR < nMaxR ; nR++)
+        {
+            for( nC = 0 ; nC < nMaxC ; nC++)
+            {
+                if( pMatrix->IsValue( nC, nR ) )
+                {
+                    ScMatValType nType;
+                    const ScMatrixValue* pVal = pMatrix->Get( nC, nR, nType);
+
+                    if( nType == SC_MATVAL_BOOLEAN )
+                    {
+                        rExtensionTokens.push_back( EXC_CACHEDVAL_BOOL );
+
+                        rExtensionTokens.resize( rExtensionTokens.size() + 8 );
+                        const bool bVal = ! ::rtl::math::approxEqual( pVal->fVal, 0. );
+                        UInt32ToSVBT32( bVal ? 1 : 0, &*(rExtensionTokens.end() - 8) );
+                        UInt32ToSVBT32( 0, &*(rExtensionTokens.end() - 4) );
+                    }
+                    else
+                    {
+                        USHORT nErr = pVal->GetError();
+                        if( nErr )
+                        {
+                            rExtensionTokens.push_back( EXC_CACHEDVAL_ERROR );
+
+                            rExtensionTokens.resize( rExtensionTokens.size() + 8 );
+                            UInt32ToSVBT32( XclTools::GetXclErrorCode ( nErr ),
+                                            &*(rExtensionTokens.end() - 8) );
+                            UInt32ToSVBT32( 0, &*(rExtensionTokens.end() - 4) );
+                        }
+                        else
+                        {
+                            rExtensionTokens.push_back( EXC_CACHEDVAL_DOUBLE );
+
+                            const double nVal = pMatrix->GetDouble( nC, nR );
+                            rExtensionTokens.resize( rExtensionTokens.size() + 8 );
+                            DoubleToSVBT64( nVal, &*(rExtensionTokens.end() - 8) );
+                        }
+                    }
+                }
+                else if( pMatrix->IsEmpty( nC, nR ) )
+                {
+                    rExtensionTokens.push_back( EXC_CACHEDVAL_EMPTY );
+
+                    rExtensionTokens.resize( rExtensionTokens.size() + 8 );
+                    UInt32ToSVBT32( 0, &*(rExtensionTokens.end() - 8) );
+                    UInt32ToSVBT32( 0, &*(rExtensionTokens.end() - 4) );
+                }
+                else if( pMatrix->IsString( nC, nR ) )
+                {
+                    rExtensionTokens.push_back( EXC_CACHEDVAL_STRING );
+
+                    const String & rString = pMatrix->GetString( nC, nR );
+                    XclExpStringRef xXclStr = XclExpStringHelper::CreateString(
+                        GetRoot(), rString,
+                        ((meBiff == EXC_BIFF8) ? EXC_STR_DEFAULT : EXC_STR_8BITLENGTH),
+                        EXC_TOK_STR_MAXLEN );
+                    size_t nSize = rExtensionTokens.size();
+                    rExtensionTokens.resize( nSize + xXclStr->GetSize() );
+                    xXclStr->WriteToMem( &rExtensionTokens[ nSize ] );
+                }
+
+            }
+        }
+    }
+}
+ 
+void XclExpFmlaCompImpl::FinalizeFormula( ScfUInt8Vec & rExtensionTokens )
 {
     if( mbOk )
     {
@@ -653,6 +756,12 @@ void XclExpFmlaCompImpl::FinalizeFormula
 
         // Token array too long? -> error
         mbOk = maTokVec.size() <= EXC_TOKARR_MAXLEN;
+
+        // Store any inline arrays
+        if( mbOk && maInlineArr.is() )
+        {
+            AppendInlineArrays( rExtensionTokens );
+        }
     }
 
     if( !mbOk )
@@ -664,10 +773,10 @@ void XclExpFmlaCompImpl::FinalizeFormula
     }
 }
 
-XclTokenArrayRef XclExpFmlaCompImpl::CreateTokenArray()
+XclTokenArrayRef XclExpFmlaCompImpl::CreateTokenArray( ScfUInt8Vec* pExtensionTokens )
 {
     // create the Excel token array object before calling LeaveRecursive()
-    XclTokenArrayRef xTokArr( new XclTokenArray( maTokVec, mbVolatile ) );
+    XclTokenArrayRef xTokArr( new XclTokenArray( maTokVec, mbVolatile, pExtensionTokens ) );
 
     // compiler invoked recursively? - restore old working data
     LeaveRecursive();
@@ -1042,6 +1151,7 @@ XclExpTokenData XclExpFmlaCompImpl::Fact
         case svString:      ProcessString( aTokData );              break;
         case svSingleRef:   ProcessCellRef( aTokData, nExpClass );  break;
         case svDoubleRef:   ProcessRangeRef( aTokData, nExpClass ); break;
+        case svMatrix:      ProcessMatrix (aTokData, nExpClass );   break;
         case svExternal:    ProcessExternal( aTokData, nExpClass ); break;
 
         default:
@@ -1842,6 +1952,9 @@ void XclExpFmlaCompImpl::UpdateArrExpFla
         case EXC_CLASSTYPE_NAME:
             bNewIsArrExp = ((nParamExpClass != EXC_TOKCLASS_VAL) || (nFuncRetClass != EXC_TOKCLASS_REF));
         break;
+
+        default :
+        break;
     }
     SetArrExpFlag( mbIsArrExp || bNewIsArrExp );
 }
@@ -2018,6 +2131,20 @@ void XclExpFmlaCompImpl::AppendSpaceToke
     }
 }
 
+void XclExpFmlaCompImpl::AppendMatrixPlaceHolder( const ScMatrix* pMatrix )
+{
+    SCSIZE cols, rows;
+
+    if( !maInlineArr )
+        maInlineArr.reset( new ScMatrixList );
+    maInlineArr->push_front( pMatrix ); // save it for later
+
+    pMatrix->GetDimensions( cols, rows);
+    Append( static_cast< sal_uInt8 >( cols-1 ) );
+    Append( static_cast< sal_uInt16 >( rows-1 ) );
+    Append( static_cast< sal_uInt32 >( 0 ) );   // undocumented
+}
+
 void XclExpFmlaCompImpl::AppendIntToken( sal_uInt16 nValue, sal_uInt8 nSpaces )
 {
     AppendOpTokenId( EXC_TOKID_INT, EXC_TOKCLASS_NONE, nSpaces );
@@ -2259,6 +2386,20 @@ XclTokenArrayRef XclExpFormulaCompiler::
 {
     return mxImpl->CreateNameXFormula( nExtSheet, nExtName );
 }
+void XclExpFmlaCompImpl::ProcessMatrix ( const XclExpTokenData& rTokData, sal_uInt8 nExpClass )
+{
+    if( maCfg.mbAllowArrays )
+    {
+        AppendOpTokenId( GetTokenId( EXC_TOKID_ARRAY, EXC_TOKCLASS_ARR ),
+             nExpClass, rTokData.mnSpaces );
+        AppendMatrixPlaceHolder( rTokData.mpScToken->GetMatrix() );
+    }
+    else
+    {
+        // Array in places that do not allow it (cond fmts, data validation)
+        AppendErrorToken( EXC_ERR_NA, rTokData.mnSpaces );
+    }
+}
 
 // ============================================================================
 
Index: sc/source/filter/excel/xichart.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xichart.cxx,v
retrieving revision 1.11
retrieving revision 1.11.52.1
diff -u -w -p -u -p -r1.11 -r1.11.52.1
--- sc/source/filter/excel/xichart.cxx	27 Feb 2007 12:26:10 -0000	1.11
+++ sc/source/filter/excel/xichart.cxx	26 Apr 2007 12:26:05 -0000	1.11.52.1
@@ -1033,7 +1033,7 @@ void XclImpChSourceLink::ReadChSourceLin
         rStrm >> aXclTokArr;
         // convert token array to range list
         ScRangeList aScRanges;
-        GetFormulaCompiler().CreateRangeList( aScRanges, EXC_FMLATYPE_CHART, aXclTokArr, rStrm );
+        GetFormulaCompiler().CreateRangeList( aScRanges, EXC_FMLATYPE_CHART, aXclTokArr, rStrm );	// JEG : This is wrong.  It should be a formula
         // process range list
         CalcOrientation( aScRanges );
     }
Index: sc/source/filter/excel/xicontent.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xicontent.cxx,v
retrieving revision 1.23
retrieving revision 1.23.52.1
diff -u -w -p -u -p -r1.23 -r1.23.52.1
--- sc/source/filter/excel/xicontent.cxx	27 Feb 2007 12:26:20 -0000	1.23
+++ sc/source/filter/excel/xicontent.cxx	26 Apr 2007 12:26:05 -0000	1.23.52.1
@@ -596,7 +596,7 @@ void XclImpCondFormat::ReadCF( XclImpStr
     {
         const ScTokenArray* pTokArr = 0;
         rFmlaConv.Reset( rPos );
-        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize1, FT_RangeName );
+        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize1, false, FT_RangeName );
         // formula converter owns pTokArr -> create a copy of the token array
         if( pTokArr )
             xTokArr1.reset( pTokArr->Clone() );
@@ -607,7 +607,7 @@ void XclImpCondFormat::ReadCF( XclImpStr
     {
         const ScTokenArray* pTokArr = 0;
         rFmlaConv.Reset( rPos );
-        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize2, FT_RangeName );
+        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize2, false, FT_RangeName );
         // formula converter owns pTokArr -> create a copy of the token array
         if( pTokArr )
             pTokArr2.reset( pTokArr->Clone() );
@@ -730,7 +730,7 @@ void XclImpValidation::ReadDV( XclImpStr
         {
             const ScTokenArray* pTokArr = 0;
             rFmlaConv.Reset();
-            rFmlaConv.Convert( pTokArr, rStrm, nLen, FT_RangeName );
+            rFmlaConv.Convert( pTokArr, rStrm, nLen, false, FT_RangeName );
             // formula converter owns pTokArr -> create a copy of the token array
             if( pTokArr )
                 xTokArr1.reset( pTokArr->Clone() );
@@ -745,7 +745,7 @@ void XclImpValidation::ReadDV( XclImpStr
         {
             const ScTokenArray* pTokArr = 0;
             rFmlaConv.Reset();
-            rFmlaConv.Convert( pTokArr, rStrm, nLen, FT_RangeName );
+            rFmlaConv.Convert( pTokArr, rStrm, nLen, false, FT_RangeName );
             // formula converter owns pTokArr -> create a copy of the token array
             if( pTokArr )
                 xTokArr2.reset( pTokArr->Clone() );
Index: sc/source/filter/excel/xiname.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xiname.cxx,v
retrieving revision 1.8
retrieving revision 1.8.52.1
diff -u -w -p -u -p -r1.8 -r1.8.52.1
--- sc/source/filter/excel/xiname.cxx	27 Feb 2007 12:27:18 -0000	1.8
+++ sc/source/filter/excel/xiname.cxx	26 Apr 2007 12:26:05 -0000	1.8.52.1
@@ -190,7 +190,9 @@ XclImpName::XclImpName( XclImpStream& rS
         rStrm.PopPosition();
 
         // --- name formula ---
-        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize, FT_RangeName );
+        // JEG : double check this.  It is clearly false for normal names
+        //  but some of the builtins (sheettitle?) might be able to handle arrays
+        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize, false, FT_RangeName );
 
         // --- auto or advanced filter ---
         if( (GetBiff() == EXC_BIFF8) && pTokArr && bBuiltIn )
@@ -218,7 +220,7 @@ XclImpName::XclImpName( XclImpStream& rS
     else if( nFmlaSize > 0 )
     {
         // regular defined name
-        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize, FT_RangeName );
+        rFmlaConv.Convert( pTokArr, rStrm, nFmlaSize, true, FT_RangeName );
     }
 
     // 4) *** create a defined name in the Calc document *** ------------------
Index: sc/source/filter/excel/xldumper.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xldumper.cxx,v
retrieving revision 1.13
retrieving revision 1.13.52.1
diff -u -w -p -u -p -r1.13 -r1.13.52.1
--- sc/source/filter/excel/xldumper.cxx	27 Feb 2007 12:28:41 -0000	1.13
+++ sc/source/filter/excel/xldumper.cxx	26 Apr 2007 12:26:05 -0000	1.13.52.1
@@ -92,7 +92,8 @@ const sal_Unicode SCF_DUMP_LISTSEP      
 const sal_Unicode SCF_DUMP_ADDRABS      = '$';
 const sal_Unicode SCF_DUMP_RANGESEP     = ':';
 const sal_Unicode SCF_DUMP_TABSEP       = '!';
-const sal_Unicode SCF_DUMP_ARRAYSEP     = ';';
+const sal_Unicode SCF_DUMP_ARRAY_COL    = ';';
+const sal_Unicode SCF_DUMP_ARRAY_ROW    = '|';
 const sal_Unicode SCF_DUMP_EMPTYVALUE   = '~';
 const sal_Unicode SCF_DUMP_CMDPROMPT    = '?';
 const sal_Unicode SCF_DUMP_PLACEHOLDER  = '\x01';
@@ -1604,8 +1605,8 @@ void FormulaObject::DumpAddDataArray( si
     {
         String aArrayLine;
         for( sal_uInt32 nCol = 0; nCol < nCols; ++nCol )
-            StringHelper::AppendToken( aArrayLine, DumpConstValue(), SCF_DUMP_LISTSEP );
-        StringHelper::AppendToken( aOp, aArrayLine, SCF_DUMP_ARRAYSEP );
+            StringHelper::AppendToken( aArrayLine, DumpConstValue(), SCF_DUMP_ARRAY_COL );
+        StringHelper::AppendToken( aOp, aArrayLine, SCF_DUMP_ARRAY_ROW );
     }
     StringHelper::Enclose( aOp, '{', '}' );
     mxStack->ReplaceOnTop( CreatePlaceHolder( nIdx ), aOp );
Index: sc/source/filter/excel/xlformula.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xlformula.cxx,v
retrieving revision 1.19
retrieving revision 1.19.50.1
diff -u -w -p -u -p -r1.19 -r1.19.50.1
--- sc/source/filter/excel/xlformula.cxx	27 Feb 2007 12:28:54 -0000	1.19
+++ sc/source/filter/excel/xlformula.cxx	26 Apr 2007 12:26:06 -0000	1.19.50.1
@@ -451,10 +451,16 @@ XclTokenArray::XclTokenArray( bool bVola
 {
 }
 
-XclTokenArray::XclTokenArray( ScfUInt8Vec& rTokVec, bool bVolatile ) :
+XclTokenArray::XclTokenArray( ScfUInt8Vec& rTokVec, bool bVolatile,
+                              ScfUInt8Vec* pExtensionTokens) :
     mbVolatile( bVolatile )
 {
     maTokVec.swap( rTokVec );
+    if( NULL != pExtensionTokens)
+    {
+        DBG_ASSERT( maTokVec.size() <= 0xFFFF, "XclTokenArray::XclTokenArray - extension array too long" );
+        maExtensions.swap( *pExtensionTokens );
+    }
 }
 
 sal_uInt16 XclTokenArray::GetSize() const
@@ -491,6 +497,8 @@ void XclTokenArray::WriteArray( XclExpSt
 {
     if( !maTokVec.empty() )
         rStrm.Write( &maTokVec.front(), GetSize() );
+    if( !maExtensions.empty() )
+        rStrm.Write( &maExtensions.front(), limit_cast< sal_uInt16 >(maExtensions.size() ) );
 }
 
 void XclTokenArray::Write( XclExpStream& rStrm ) const
Index: sc/source/filter/inc/excform.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/excform.hxx,v
retrieving revision 1.18
retrieving revision 1.18.52.1
diff -u -w -p -u -p -r1.18 -r1.18.52.1
--- sc/source/filter/inc/excform.hxx	27 Feb 2007 12:32:19 -0000	1.18
+++ sc/source/filter/inc/excform.hxx	26 Apr 2007 12:26:06 -0000	1.18.52.1
@@ -55,6 +55,9 @@ class ScRangeList;
 class ExcelToSc : public ExcelConverterBase, protected XclImpRoot
 {
 protected:
+    enum ExtensionType { EXTENSION_ARRAY, EXTENSION_NLR, EXTENSION_MEMAREA };
+    typedef ::std::vector< ExtensionType >          ExtensionTypeVec;
+
 	BOOL				bExternName;	// wenn External Name gefunden wurde
 	static const UINT16	nRowMask;
 	static const UINT16	nLastInd;		// letzter Index fuer Excel->SC-
@@ -72,7 +75,8 @@ protected:
 public:
                         ExcelToSc( const XclImpRoot& rRoot );
 	virtual				~ExcelToSc();
-    virtual ConvErr     Convert( const ScTokenArray*&, XclImpStream& rStrm, sal_Size nFormulaLen, const FORMULA_TYPE eFT = FT_CellFormula );
+    virtual ConvErr     Convert( const ScTokenArray*&, XclImpStream& rStrm, sal_Size nFormulaLen,
+                                 bool bAllowArrays, const FORMULA_TYPE eFT = FT_CellFormula );
 
     virtual ConvErr     Convert( _ScRangeListTabs&, XclImpStream& rStrm, sal_Size nFormulaLen, const FORMULA_TYPE eFT = FT_CellFormula );
     virtual BOOL        GetAbsRefs( ScRangeList& rRangeList, XclImpStream& rStrm, sal_Size nLen );
@@ -90,6 +94,13 @@ public:
 
 	void				SetComplCol( ComplRefData& );
 	void				SetComplRow( ComplRefData& );
+
+    void                ReadExtensions( const ExtensionTypeVec& rExtensions,
+                                        XclImpStream& aIn );
+    void                ReadExtensionArray( unsigned int n,
+                                            XclImpStream& aIn );
+    void                ReadExtensionNlr( XclImpStream& aIn );
+    void                ReadExtensionMemArea( XclImpStream& aIn );
 };
 
 
@@ -122,7 +133,7 @@ public:
                         ExcelToSc8( const XclImpRoot& rRoot );
 	virtual				~ExcelToSc8();
 
-    virtual ConvErr     Convert( const ScTokenArray*& rpTokArray, XclImpStream& rStrm, sal_Size nFormulaLen, const FORMULA_TYPE eFT = FT_CellFormula );
+    virtual ConvErr     Convert( const ScTokenArray*& rpTokArray, XclImpStream& rStrm, sal_Size nFormulaLen, bool bAllowArrays, const FORMULA_TYPE eFT = FT_CellFormula );
 
     virtual ConvErr     Convert( _ScRangeListTabs&, XclImpStream& rStrm, sal_Size nFormulaLen, const FORMULA_TYPE eFT = FT_CellFormula );
 
Index: sc/source/filter/inc/formel.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/formel.hxx,v
retrieving revision 1.9
retrieving revision 1.9.52.1
diff -u -w -p -u -p -r1.9 -r1.9.52.1
--- sc/source/filter/inc/formel.hxx	27 Feb 2007 12:33:39 -0000	1.9
+++ sc/source/filter/inc/formel.hxx	26 Apr 2007 12:26:06 -0000	1.9.52.1
@@ -237,7 +237,7 @@ public:
     void                Reset( const ScAddress& rEingPos );
 
     virtual ConvErr     Convert( const ScTokenArray*& rpErg, XclImpStream& rStrm, sal_Size nFormulaLen,
-									const FORMULA_TYPE eFT = FT_CellFormula ) = 0;
+                                 bool bAllowArrays, const FORMULA_TYPE eFT = FT_CellFormula ) = 0;
     virtual ConvErr     Convert( _ScRangeListTabs&, XclImpStream& rStrm, sal_Size nFormulaLen,
 									const FORMULA_TYPE eFT = FT_CellFormula ) = 0;
 };
Index: sc/source/filter/inc/tokstack.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/tokstack.hxx,v
retrieving revision 1.11
retrieving revision 1.11.38.1
diff -u -w -p -u -p -r1.11 -r1.11.38.1
--- sc/source/filter/inc/tokstack.hxx	5 Mar 2007 14:43:28 -0000	1.11
+++ sc/source/filter/inc/tokstack.hxx	26 Apr 2007 12:26:06 -0000	1.11.38.1
@@ -89,6 +89,7 @@ enum E_TYPE
 	T_RN,	// Range Name
 	T_Ext,	// irgendwas Unbekanntes mit Funktionsnamen
 	T_Nlf,	// token for natural language formula
+	T_Matrix,	// token for inline arrays
 	T_Error	// fuer Abfrage im Fehlerfall
 };
 
@@ -137,6 +138,10 @@ class TokenPool
 		UINT16						nP_Nlf;
 		UINT16						nP_NlfAkt;
 
+		ScMatrix**					ppP_Matrix;		// Pool fuer Matricies
+		UINT16						nP_Matrix;
+		UINT16						nP_MatrixAkt;
+
 		UINT16*						pElement;	// Array mit Indizes fuer Elemente
 		E_TYPE*						pType;		// ...mit Typ-Info
 		UINT16*						pSize;		// ...mit Laengenangabe (Anz. UINT16)
@@ -156,6 +161,7 @@ class TokenPool
 		void						GrowElement( void );
 		void						GrowExt( void );
 		void						GrowNlf( void );
+		void						GrowMatrix( void );
 		void						GetElement( const UINT16 nId );
 		void						GetElementRek( const UINT16 nId );
 	public:
@@ -179,6 +185,8 @@ class TokenPool
 		const TokenId				Store( const DefTokenId eId, const String& rName );
 										// 4 externals (e.g. AddIns, Makros...)
 		const TokenId				StoreNlf( const SingleRefData& rTr );
+		const TokenId				StoreMatrix( SCSIZE nC, SCSIZE nR );
+
 		inline const TokenId		LastId( void ) const;
 		inline const ScTokenArray*	operator []( const TokenId nId );
 		void						Reset( void );
@@ -187,6 +195,7 @@ class TokenPool
 		BOOL						IsSingleOp( const TokenId& nId, const DefTokenId eId ) const;
         const String*               GetExternal( const TokenId& nId ) const;
 		const String*				GetString( const TokenId& nId ) const;
+		ScMatrix*					GetMatrix( unsigned int n ) const;
 };
 
 
Index: sc/source/filter/inc/xlformula.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlformula.hxx,v
retrieving revision 1.10
retrieving revision 1.10.52.1
diff -u -w -p -u -p -r1.10 -r1.10.52.1
--- sc/source/filter/inc/xlformula.hxx	27 Feb 2007 12:37:41 -0000	1.10
+++ sc/source/filter/inc/xlformula.hxx	26 Apr 2007 12:26:06 -0000	1.10.52.1
@@ -291,7 +291,8 @@ public:
     /** Creates an empty token array. */
     explicit            XclTokenArray( bool bVolatile = false );
     /** Creates a token array, swaps passed token vector into own data. */
-    explicit            XclTokenArray( ScfUInt8Vec& rTokVec, bool bVolatile = false );
+    explicit            XclTokenArray( ScfUInt8Vec& rTokVec, bool bVolatile = false, 
+                                       ScfUInt8Vec* pExtensionTokens = NULL);
 
     /** Returns true, if the token array is empty. */
     inline bool         Empty() const { return maTokVec.empty(); }
@@ -302,9 +303,6 @@ public:
     /** Returns true, if the formula contains a volatile function. */
     inline bool         IsVolatile() const { return mbVolatile; }
 
-    /** Swaps own token vector with passed token vector. */
-    inline void         SwapTokenVec( ScfUInt8Vec& rTokVec ) { maTokVec.swap( rTokVec ); }
-
     /** Reads the size field of the token array. */
     void                ReadSize( XclImpStream& rStrm );
     /** Reads the tokens of the token array (without size field). */
@@ -324,6 +322,7 @@ public:
 
 private:
     ScfUInt8Vec         maTokVec;       /// Byte vector containing token data.
+    ScfUInt8Vec         maExtensions;   /// Byte vector of extensions (eg inline arrays)
     bool                mbVolatile;     /// True = Formula contains volatile function.
 };
 
Index: sc/source/filter/xcl97/XclImpChangeTrack.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xcl97/XclImpChangeTrack.cxx,v
retrieving revision 1.30
retrieving revision 1.30.210.1
diff -u -w -p -u -p -r1.30 -r1.30.210.1
--- sc/source/filter/xcl97/XclImpChangeTrack.cxx	21 Jul 2006 12:36:36 -0000	1.30
+++ sc/source/filter/xcl97/XclImpChangeTrack.cxx	26 Apr 2007 12:26:07 -0000	1.30.210.1
@@ -232,7 +232,7 @@ void XclImpChangeTrack::ReadFormula( ScT
 	// read the formula, 3D tab refs from extended data
 	const ScTokenArray* pArray = NULL;
 	aFmlConv.Reset( rPosition );
-    BOOL bOK = (aFmlConv.Convert( pArray, aFmlaStrm, nFmlSize ) == ConvOK);
+    BOOL bOK = (aFmlConv.Convert( pArray, aFmlaStrm, nFmlSize, false, FT_CellFormula) == ConvOK);	// JEG : Check This
 	rpTokenArray = (bOK && pArray) ? new ScTokenArray( *pArray ) : NULL;
     pStrm->Ignore( 1 );
 }
Index: sc/source/ui/src/globstr.src
===================================================================
RCS file: /cvs/sc/sc/source/ui/src/globstr.src,v
retrieving revision 1.66
retrieving revision 1.66.8.1
diff -u -w -p -u -p -r1.66 -r1.66.8.1
--- sc/source/ui/src/globstr.src	19 Apr 2007 16:37:44 -0000	1.66
+++ sc/source/ui/src/globstr.src	26 Apr 2007 12:26:12 -0000	1.66.8.1
@@ -1801,5 +1801,9 @@ Resource RID_GLOBSTR
     {
         Text [ en-US ] = "Automatic";
     };
+    String STR_ERR_LONG_NESTED_ARRAY
+    {
+	Text [ en-US ] = "Nested arrays are not supported." ;
+    };
 };
 
