--- sw/source/filter/ww8/ww8scan.hxx.orig	2006-02-03 13:26:03.000000000 -0800
+++ sw/source/filter/ww8/ww8scan.hxx	2006-02-02 23:46:15.000000000 -0800
@@ -63,6 +63,10 @@
 #include <errhdl.hxx>       // ASSERT()
 #endif
 
+#ifndef WW_HASH_WRAP_HXX
+#include "hash_wrap.hxx"
+#endif
+
 #ifndef WW_SORTEDARRAY_HXX
 #include "sortedarray.hxx"
 #endif
@@ -124,10 +128,10 @@
     unsigned int nVari : 2;
 };
 
-//a managed sorted sequence of sprminfos
-typedef ww::SortedArray<SprmInfo> wwSprmSearcher;
-//a managed sorted sequence of sprms
-typedef ww::SortedArray<sal_uInt16> wwSprmSequence;
+inline bool operator==(const SprmInfo &rFirst, const SprmInfo &rSecond);
+
+typedef ww::WrappedHash<SprmInfo> wwSprmSearcher;
+typedef ww::WrappedHash<sal_uInt16> wwSprmSequence;
 
 //wwSprmParser knows how to take a sequence of bytes and split it up into
 //sprms and their arguments
--- sw/source/filter/ww8/ww8scan.cxx.orig	2006-02-03 13:26:12.000000000 -0800
+++ sw/source/filter/ww8/ww8scan.cxx	2006-02-02 23:46:15.000000000 -0800
@@ -121,11 +121,22 @@
     return bRet;
 }
 
-bool operator==(const SprmInfo &rFirst, const SprmInfo &rSecond)
+inline bool operator==(const SprmInfo &rFirst, const SprmInfo &rSecond)
 {
     return (rFirst.nId == rSecond.nId);
 }
 
+namespace std
+{
+	template<> struct hash<SprmInfo> 
+	{
+		size_t operator()(const SprmInfo &a) const  
+			{ 
+				return a.nId;  
+			}
+	};
+}
+
 bool operator<(const SprmInfo &rFirst, const SprmInfo &rSecond)
 {
     return (rFirst.nId < rSecond.nId);
@@ -135,7 +146,7 @@
 {
     //double lock me
     // WW7- Sprms
-    static SprmInfo aSprms[] =
+    static const SprmInfo aSprms[] =
     {
         {  0, 0, L_FIX}, // "Default-sprm",  wird uebersprungen
         {  2, 1, L_FIX}, // "sprmPIstd",  pap.istd (style code)
@@ -287,7 +298,7 @@
 {
     //double lock me
     // WW7- Sprms
-    static SprmInfo aSprms[] =
+    static const SprmInfo aSprms[] =
     {
         {  0, 0, L_FIX}, // "Default-sprm",  wird uebersprungen
         {  2, 2, L_FIX}, // "sprmPIstd",  pap.istd (style code)
@@ -469,7 +480,7 @@
 {
     //double lock me
     //WW8+ Sprms
-    static SprmInfo aSprms[] =
+    static const SprmInfo aSprms[] =
     {
         {     0, 0, L_FIX}, // "Default-sprm"/ wird uebersprungen
         {0x4600, 2, L_FIX}, // "sprmPIstd" pap.istd;istd (style code);short;
--- /dev/null	2006-01-30 08:23:25.064242500 -0800
+++ sw/source/filter/ww8/hash_wrap.hxx	2006-02-03 13:11:27.000000000 -0800
@@ -0,0 +1,136 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil -*- */
+
+//this is a shameless rip from sortedarray.hxx but changed to hash_set
+
+#ifndef WW_HASH_WRAP_HXX
+#define WW_HASH_WRAP_HXX
+
+#include <hash_set>
+
+#ifndef _TOOLS_DEBUG_HXX    // DBG_ERROR
+#include <tools/debug.hxx>
+#endif
+
+#ifndef _ERRHDL_HXX
+#include <errhdl.hxx>       // ASSERT()
+#endif
+
+//simple wrapper around hash_set to behave like sorted array
+namespace ww
+{
+    /** simple template that manages a hash
+
+
+        @author
+        <a href="mailto:mikeleib@openoffice.org">Michael Leibowitz</a>
+    */
+    template<class C> class WrappedHash
+    {
+    private:
+        std::hash_set<C> mHashSet;
+
+        //No copying
+        WrappedHash(const WrappedHash&);
+        WrappedHash& operator=(const WrappedHash&);
+    public:
+        //Find an entry, return its address if found and 0 if not
+        const C* search(C aSrch) const
+        {
+            typename std::hash_set<C>::const_iterator it;
+            it= mHashSet.find(aSrch);
+            if (it != mHashSet.end())
+                return &(*it);
+            else
+                return 0;
+        }
+
+        WrappedHash(const C *pWwSprmTab, const size_t nNoElems)
+        {
+            ASSERT(nNoElems && pWwSprmTab, "WW8: empty Array: Don't do that");
+            const C *pIter = pWwSprmTab;
+            const C *pEnd  = pWwSprmTab + nNoElems;
+            while (pIter < pEnd)
+            {
+                mHashSet.insert(*pIter);
+                pIter++;
+            }
+#if OSL_DEBUG_LEVEL > 1
+            bool bBroken=false;
+            rtl::OUString sError;
+            pIter = pWwSprmTab;
+            const C *pBeforeEnd = pWwSprmTab + nNoElems - 1;
+            while (pIter < pBeforeEnd)
+            {
+                if (*pIter == *(pIter+1))
+                {
+                    if (!bBroken)
+                    {
+                        sError = rtl::OUString::createFromAscii(
+                            "WW8: Duplicate in list, almost certainly don't "
+                            "want that!\n"
+                            "(You will not see this message again unless you "
+                            "restart)\n"
+                            "Extra entries are...\n");
+                        bBroken=true;
+                    }
+
+                    size_t nSize = sizeof(C);
+                    const sal_uInt8 *pHack =
+                        reinterpret_cast<const sal_uInt8 *>(&(*pIter));
+                    for (size_t i=0; i < nSize; ++i)
+                    {
+                        sError += rtl::OUString::valueOf(
+                            static_cast<sal_Int32>(pHack[i]), 16);
+                        sError += rtl::OUString::valueOf(sal_Unicode(' '));
+                    }
+                    sError += rtl::OUString::valueOf(sal_Unicode('\n'));
+                    while (*pIter == *(pIter+1) && pIter < pBeforeEnd)
+                        ++pIter;
+                }
+                else
+                    ++pIter;
+            }
+            if (bBroken)
+               DBG_ERROR(rtl::OUStringToOString(sError, RTL_TEXTENCODING_ASCII_US));
+#endif
+        }
+    };
+}
+#endif
+
+/* vi:set tabstop=4 shiftwidth=4 expandtab: */
