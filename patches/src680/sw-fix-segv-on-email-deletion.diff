Index: ndtxt.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/txtnode/ndtxt.cxx,v
retrieving revision 1.72
retrieving revision 1.72.12.1
diff -u -r1.72 -r1.72.12.1
--- sw/source/core/txtnode/ndtxt.cxx	26 Jul 2007 08:19:40 -0000	1.72
+++ sw/source/core/txtnode/ndtxt.cxx	17 Oct 2007 10:04:41 -0000	1.72.12.1
@@ -957,8 +957,8 @@
 					}
 				}
             }
-            if ( !pSwpHints->MergePortions( *this ) )
-    			static_cast<SwpHintsArr*>(pSwpHints)->Resort();
+
+            pSwpHints->MergePortions( *this );
         }
 		else
 		{
Index: thints.cxx
===================================================================
RCS file: /cvs/sw/sw/source/core/txtnode/thints.cxx,v
retrieving revision 1.52.114.1
retrieving revision 1.52.114.1.24.1
diff -u -r1.52.114.1 -r1.52.114.1.24.1
--- sw/source/core/txtnode/thints.cxx	30 Aug 2007 15:00:08 -0000	1.52.114.1
+++ sw/source/core/txtnode/thints.cxx	17 Oct 2007 10:04:40 -0000	1.52.114.1.24.1
@@ -1823,6 +1823,12 @@
 
 bool SwpHints::MergePortions( SwTxtNode& rNode )
 {
+    if ( !Count() )
+        return false;
+
+    // sort before merging
+    SwpHintsArr::Resort();
+
     bool bRet = false;
     typedef std::multimap< int, SwTxtAttr* > PortionMap;
     PortionMap aPortionMap;
@@ -1858,7 +1864,7 @@
         PortionMap::iterator aIter2 = aRange2.first;
 
         bool bMerge = true;
-       const USHORT nAttributesInPor1  = std::distance( aRange1.first, aRange1.second );
+        const USHORT nAttributesInPor1  = std::distance( aRange1.first, aRange1.second );
         const USHORT nAttributesInPor2 = std::distance( aRange2.first, aRange2.second );
 
         if ( nAttributesInPor1 == nAttributesInPor2 && nAttributesInPor1 != 0 )
@@ -1889,8 +1895,13 @@
             {
                 SwTxtAttr* p2 = (*aIter2).second;
                 nNewPortionEnd = *p2->GetEnd();
+
+                const USHORT nCountBeforeDelete = Count();
                 Delete( p2 );
-                rNode.DestroyAttr( p2 );
+
+                // robust: check if deletion actually took place before destroying attribute:
+                if ( Count() < nCountBeforeDelete )
+                    rNode.DestroyAttr( p2 );
             }
             aPortionMap.erase( aRange2.first, aRange2.second );
             ++j;
