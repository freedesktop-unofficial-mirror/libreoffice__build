diff -pur sal.orig/inc/osl/file.h sal/inc/osl/file.h
--- sal.orig/inc/osl/file.h	2006-12-01 18:56:14.000000000 +0100
+++ sal/inc/osl/file.h	2007-01-17 13:55:57.000000000 +0100
@@ -666,6 +666,7 @@ typedef	void *oslFileHandle;
 #define osl_File_OpenFlag_Read		0x00000001L
 #define osl_File_OpenFlag_Write		0x00000002L
 #define osl_File_OpenFlag_Create	0x00000004L
+#define osl_File_OpenFlag_NoLock	0x00000008L
 
 /** Open a regular file.
 
@@ -706,8 +707,10 @@ typedef	void *oslFileHandle;
 	osl_File_E_MULTIHOP multihop attempted<br>
 	osl_File_E_NOLINK link has been severed<br>
 	osl_File_E_EOVERFLOW value too large for defined data type<br>
+	osl_File_E_NOLCK too many segment locks open, lock table is full, or a remote locking protocol failed (e.g. locking over NFS)<br>
 
 	@see osl_closeFile()
+	@see osl_lockFile()
 	@see osl_setFilePos()
 	@see osl_getFilePos()
 	@see osl_readFile()
@@ -718,6 +721,27 @@ typedef	void *oslFileHandle;
 
 oslFileError SAL_CALL osl_openFile( rtl_uString *pustrFileURL, oslFileHandle *pHandle, sal_uInt32 uFlags );
 
+/** Lock a file.
+
+    Lock an open file.
+    
+	@param Handle [in] 
+	Handle to a file received by a previous call to osl_openFile().
+	
+	@param bLock [in]
+	Lock, or unlock?
+	
+	@return 
+	osl_File_E_None on success<br> 
+	osl_File_E_ACCES permission denied<br>
+	osl_File_E_AGAIN a write lock could not be established<br>
+	osl_File_E_NOLCK too many segment locks open, lock table is full, or a remote locking protocol failed (e.g. locking over NFS)<br>
+
+	@see osl_openFile()
+*/
+
+oslFileError SAL_CALL osl_lockFile( oslFileHandle Handle, sal_Bool bLock );
+
 #define osl_Pos_Absolut 1
 #define osl_Pos_Current 2
 #define osl_Pos_End     3
diff -pur sal.orig/inc/osl/file.hxx sal/inc/osl/file.hxx
--- sal.orig/inc/osl/file.hxx	2006-12-01 18:56:14.000000000 +0100
+++ sal/inc/osl/file.hxx	2007-01-17 13:56:45.000000000 +0100
@@ -951,6 +951,7 @@ public:
     #define OpenFlag_Read   osl_File_OpenFlag_Read
     #define OpenFlag_Write  osl_File_OpenFlag_Write
     #define OpenFlag_Create osl_File_OpenFlag_Create
+    #define OpenFlag_NoLock osl_File_OpenFlag_NoLock
 
 	/** Open a regular file.
 
@@ -1027,6 +1028,24 @@ public:
 		return (RC) Error;
     }
 
+	/** Lock an open file.
+
+		@param bLock [in]
+		Lock, or unlock?
+
+		@return 
+		osl_File_E_None on success<br> 
+		osl_File_E_ACCES permission denied<br>
+		osl_File_E_AGAIN a write lock could not be established<br>
+		osl_File_E_NOLCK too many segment locks open, lock table is full, or a remote locking protocol failed (e.g. locking over NFS)<br>
+
+		@see open()
+	*/
+
+    inline RC lock( sal_Bool bLock )
+	{
+		return (RC) osl_lockFile( _pData, bLock );
+	}
 
     #define Pos_Absolut osl_Pos_Absolut
     #define Pos_Current osl_Pos_Current
diff -pur sal.orig/osl/unx/file.cxx sal/osl/unx/file.cxx
--- sal.orig/osl/unx/file.cxx	2007-01-11 13:55:33.000000000 +0100
+++ sal/osl/unx/file.cxx	2007-01-12 17:57:44.000000000 +0100
@@ -327,37 +327,6 @@ static sal_Bool       osl_getFloppyMount
 static void           osl_printFloppyHandle(oslVolumeDeviceHandleImpl* hFloppy);
 #endif
 
-#ifdef MACOSX
-
-/*******************************************************************
- *	adjustLockFlags
- ******************************************************************/
-
-/* The AFP implementation of MacOS X 10.4 treats O_EXLOCK in a way 
- * that makes it impossible for OOo to create a backup copy of the
- * file it keeps opened. OTOH O_SHLOCK for AFP behaves as desired by
- * the OOo file handling, so we need to check the path of the file
- * for the filesystem name.
- */
- 
-static int adjustLockFlags(const char * path, int flags)
-{
-    struct statfs s;
-  
-    if( 0 <= statfs( path, &s ) )
-    {
-        if( 0 == strncmp("afpfs", s.f_fstypename, 5) )
-        {
-            flags &= ~O_EXLOCK;
-            flags |= O_SHLOCK;
-        }    
-    }
-
-    return flags;
-}
-
-#endif
-
 
 /*******************************************************************
  *	osl_openDirectory
@@ -648,17 +617,54 @@ oslFileHandle osl_createFileHandleFromFD
 }
 
 
-/****************************************************************************
- *	osl_openFile
- ***************************************************************************/
+/******************************************************************/
+/*	impl_oslToSystemFlags */
+/******************************************************************/
+
+static int impl_oslToSystemFlags( const char * path, sal_Int32 uFlags )
+{
+    int flags = O_RDONLY;
+
+    if ( uFlags & osl_File_OpenFlag_Write )
+        flags = O_RDWR;
+
+    if ( uFlags & osl_File_OpenFlag_Create )
+        flags = O_CREAT | O_EXCL | O_RDWR;
 
 #ifdef HAVE_O_EXLOCK
-#define OPEN_WRITE_FLAGS ( O_RDWR | O_EXLOCK | O_NONBLOCK )
-#define OPEN_CREATE_FLAGS ( O_CREAT | O_EXCL | O_RDWR | O_EXLOCK | O_NONBLOCK )
-#else
-#define OPEN_WRITE_FLAGS ( O_RDWR )
-#define OPEN_CREATE_FLAGS ( O_CREAT | O_EXCL | O_RDWR )
-#endif
+    if ( !( uFlags & osl_File_OpenFlag_NoLock ) )
+    {
+#ifdef MACOSX
+        /* The AFP implementation of MacOS X 10.4 treats O_EXLOCK in a way 
+         * that makes it impossible for OOo to create a backup copy of the
+         * file it keeps opened. OTOH O_SHLOCK for AFP behaves as desired by
+         * the OOo file handling, so we need to check the path of the file
+         * for the filesystem name.
+         */
+        struct statfs s;
+
+        if( 0 <= statfs( path, &s ) )
+        {
+            if( 0 == strncmp("afpfs", s.f_fstypename, 5) )
+                flags |= O_SHLOCK | O_NONBLOCK;
+            else
+                flags |= O_EXLOCK | O_NONBLOCK;
+        }
+#else /* MACOSX */
+        flags |= O_EXLOCK | O_NONBLOCK;
+
+        /* warning free (unused variable) */
+        (void) path;
+#endif /* MACOSX */
+    }
+#endif /* HAVE_O_EXLOCK */
+
+    return flags;
+}
+
+/****************************************************************************/
+/*	osl_openFile */
+/****************************************************************************/
 
 oslFileError osl_openFile( rtl_uString* ustrFileURL, oslFileHandle* pHandle, sal_uInt32 uFlags )
 {
@@ -671,14 +677,6 @@ oslFileError osl_openFile( rtl_uString* 
     int  mode  = S_IRUSR | S_IRGRP | S_IROTH;
     int  flags = O_RDONLY;
 
-    struct flock aflock;
-
-    /* locking the complete file */
-    aflock.l_type = 0;
-	aflock.l_whence = SEEK_SET;
-    aflock.l_start = 0;
-	aflock.l_len = 0;
-
     OSL_ASSERT( ustrFileURL );
     OSL_ASSERT( pHandle );
 
@@ -719,87 +717,65 @@ oslFileError osl_openFile( rtl_uString* 
 
         if( osl_File_E_None == eRet )
         {
-            /*
-             * set flags and mode
-             */
-
-            if ( uFlags & osl_File_OpenFlag_Write )
-            {
-                mode |= S_IWUSR | S_IWGRP | S_IWOTH;
-                flags = OPEN_WRITE_FLAGS;
-#ifdef MACOSX
-                flags = adjustLockFlags(buffer, flags);
-#endif
-                aflock.l_type = F_WRLCK;
-            }
-
-            if ( uFlags & osl_File_OpenFlag_Create )
+            /* flags and mode (defaults are for the read-only case ) */
+            if ( uFlags & ( osl_File_OpenFlag_Write | osl_File_OpenFlag_Create ) )
             {
                 mode |= S_IWUSR | S_IWGRP | S_IWOTH;
-                flags = OPEN_CREATE_FLAGS;
-#ifdef MACOSX
-                flags = adjustLockFlags(buffer, flags);
-#endif
+                flags = impl_oslToSystemFlags( buffer, uFlags );
             }
 
             /* open the file */
             fd = open( buffer, flags, mode );
             if ( fd >= 0 )
             {
-#ifndef HAVE_O_EXLOCK
-                /* check if file lock is enabled and clear l_type member of flock otherwise */
-                if( (char *) -1 == pFileLockEnvVar )
+                /* allocate memory for impl structure */
+                pHandleImpl = (oslFileHandleImpl*) rtl_allocateMemory( sizeof(oslFileHandleImpl) );
+                if( pHandleImpl )
                 {
-                    /* FIXME: this is not MT safe */
-                    pFileLockEnvVar = getenv("SAL_ENABLE_FILE_LOCKING");
-
-                    if( NULL == pFileLockEnvVar)
-                        pFileLockEnvVar = getenv("STAR_ENABLE_FILE_LOCKING");
+                    pHandleImpl->ustrFilePath = ustrFilePath;
+                    pHandleImpl->fd = fd;
                 }
-#else
+                else
+                    eRet = oslTranslateFileError( OSL_FET_ERROR, ENOMEM );
+
+                /* lock the file when opened for writing? */
+                sal_Bool bWriteLock = ( osl_File_OpenFlag_Write == ( uFlags & ( osl_File_OpenFlag_Write | osl_File_OpenFlag_NoLock ) ) )? sal_True: sal_False;
+
+#ifdef HAVE_O_EXLOCK
                 /* disable range based locking */
-                pFileLockEnvVar = NULL;
+                bWriteLock = sal_False;
                 
                 /* remove the NONBLOCK flag again */
                 flags = fcntl(fd, F_GETFL, NULL);
                 flags &= ~O_NONBLOCK;
-                if( 0 > fcntl(fd, F_GETFL, flags) )
-                    return oslTranslateFileError(OSL_FET_ERROR, errno);
+                if( ( osl_File_E_None == eRet ) && ( 0 > fcntl(fd, F_GETFL, flags) ) )
+                    eRet = oslTranslateFileError( OSL_FET_ERROR, errno);
 #endif
-                if( NULL == pFileLockEnvVar )
-                    aflock.l_type = 0;
 
-                /* lock the file if flock.l_type is set */
-                if( F_WRLCK != aflock.l_type || -1 != fcntl( fd, F_SETLK, &aflock ) )
+                if( ( osl_File_E_None == eRet ) && bWriteLock )
+                    eRet = osl_lockFile( pHandleImpl, sal_True );
+
+                if( osl_File_E_None == eRet )
                 {
-                    /* allocate memory for impl structure */
-                    pHandleImpl = (oslFileHandleImpl*) rtl_allocateMemory( sizeof(oslFileHandleImpl) );
-                    if( pHandleImpl )
-                    {
-                        pHandleImpl->ustrFilePath = ustrFilePath;
-                        pHandleImpl->fd = fd;
-
-                        *pHandle = (oslFileHandle) pHandleImpl;
-
-                        return osl_File_E_None;
-                    }
-                    else
-                    {
-                        errno = ENOMEM;
-                    }
+                    *pHandle = (oslFileHandle) pHandleImpl;
+                    return osl_File_E_None;
                 }
 
                 close( fd );
             }
 
             PERROR( "osl_openFile", buffer );
-            eRet = oslTranslateFileError(OSL_FET_ERROR, errno );
+            /* error can be set while acquiring the lock */
+            if( osl_File_E_None == eRet )
+                eRet = oslTranslateFileError( OSL_FET_ERROR, errno );
         }
     }
     else
         eRet = osl_File_E_INVAL;
 
     rtl_uString_release( ustrFilePath );
+    if( pHandleImpl )
+        rtl_freeMemory( pHandleImpl );
     return eRet;
 }
 
@@ -818,23 +794,9 @@ oslFileError osl_closeFile( oslFileHandl
     {
         rtl_uString_release( pHandleImpl->ustrFilePath );
 
-        /* release file lock if locking is enabled */
-        if( pFileLockEnvVar )
-        {
-            struct flock aflock;
-
-            aflock.l_type = F_UNLCK;
-            aflock.l_whence = SEEK_SET;
-            aflock.l_start = 0;
-            aflock.l_len = 0;
-
-            /* FIXME: check if file is really locked ?  */
-
-            /* release the file share lock on this file */
-            if( -1 == fcntl( pHandleImpl->fd, F_SETLK, &aflock ) )
-                PERROR( "osl_closeFile", "unlock failed" );
-        }
-
+        /* release file lock */
+        osl_lockFile( Handle, sal_False );
+        
         if( 0 > close( pHandleImpl->fd ) )
         {
             eRet = oslTranslateFileError(OSL_FET_ERROR, errno );
@@ -848,6 +810,45 @@ oslFileError osl_closeFile( oslFileHandl
     return eRet;
 }
 
+/***************************************************************************/
+/*	osl_lockFile */
+/***************************************************************************/
+
+oslFileError SAL_CALL osl_lockFile( oslFileHandle Handle, sal_Bool bLock )
+{
+    if( (char *) -1 == pFileLockEnvVar )
+    {
+        /* FIXME: this is not MT safe */
+        pFileLockEnvVar = getenv("SAL_ENABLE_FILE_LOCKING");
+
+        if( NULL == pFileLockEnvVar)
+            pFileLockEnvVar = getenv("STAR_ENABLE_FILE_LOCKING");
+    }
+
+    /* locking not supported => never fail */
+    if( NULL == pFileLockEnvVar)
+        return osl_File_E_None;
+
+    /* implementation of the handle */
+    oslFileHandleImpl* pHandleImpl = (oslFileHandleImpl *) Handle;
+    if( !pHandleImpl )
+        return osl_File_E_INVAL;
+
+    struct flock aflock;
+
+    /* locking/unlocking the complete file */
+    aflock.l_type = bLock? F_WRLCK: F_UNLCK;
+	aflock.l_whence = SEEK_SET;
+    aflock.l_start = 0;
+	aflock.l_len = 0;
+
+    /* lock the file */
+    if( -1 == fcntl( pHandleImpl->fd, F_SETLK, &aflock ) )
+        return oslTranslateFileError( OSL_FET_ERROR, errno );
+    
+    return osl_File_E_None;
+}
+
 /****************************************************************************/
 /*	osl_isEndOfFile */
 /****************************************************************************/
diff -pur sal.orig/osl/w32/file.cxx sal/osl/w32/file.cxx
--- sal.orig/osl/w32/file.cxx	2006-12-01 18:56:16.000000000 +0100
+++ sal/osl/w32/file.cxx	2007-01-12 17:44:09.000000000 +0100
@@ -2466,7 +2466,11 @@ oslFileError SAL_CALL osl_openFile(
 			dwAccess |= GENERIC_READ;
 
 		if ( uFlags & osl_File_OpenFlag_Write )
+		{
 			dwAccess |= GENERIC_WRITE;
+			if ( uFlags & osl_File_OpenFile_NoLock )
+				dwShare |= FILE_SHARE_WRITE;
+		}
 		else
 			dwShare  |= FILE_SHARE_WRITE;
 
@@ -2489,6 +2493,34 @@ oslFileError SAL_CALL osl_openFile(
 }
 
 //#############################################
+oslFileError SAL_CALL osl_lockFile( oslFileHandle Handle, sal_Bool bLock )
+{
+	HANDLE hFile = (HANDLE)Handle;
+
+	DWORD nBytesToLockL = (DWORD)-1;
+	DWORD nBytesToLockH = (DWORD)-1;
+
+	BOOL bSuccess = FALSE;
+
+	if ( GetVersion() >= 0x80000000 )
+	{
+		// to avoid errors on FAT16
+		nBytesToLockL = (DWORD)0x7FFFFFFF;
+		nBytesToLockH = 0;
+	}
+
+	if ( bLock )
+		bSuccess = LockFile( hFile, 0, 0, nBytesToLockL, nBytesToLockH );
+	else
+		bSuccess = UnlockFile( hFile, 0, 0, nBytesToLockL, nBytesToLockH );
+
+	if ( !bSuccess )
+		return MapError( GetLastError() );
+
+    return osl_File_E_None;
+}
+
+//#############################################
 oslFileError SAL_CALL osl_syncFile(oslFileHandle Handle)
 {
     if (!IsValidHandle((HANDLE)Handle))
