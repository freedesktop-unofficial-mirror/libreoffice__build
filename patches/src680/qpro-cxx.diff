--- /dev/null	2004-07-26 17:21:14.000000000 +0530
+++ sc/source/filter/qpro/qpro.cxx	2005-05-31 12:57:52.000000000 +0530
@@ -0,0 +1,256 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <sal/config.h>
+#include <stdio.h>
+#include <sfx2/docfile.hxx>
+
+#include "qproform.hxx"
+#include "qpro.hxx"
+#include "qprostyle.hxx"
+
+#include "global.hxx"
+#include "scerrors.hxx"
+#include "docpool.hxx" 
+#include "patattr.hxx"
+#include "filter.hxx"
+#include "document.hxx"
+#include "cell.hxx"
+#include "biff.hxx"
+#include <tools/stream.hxx>
+
+FltError ScQProReader::readSheet( sal_uInt16 nTab, ScDocument* pDoc )
+{
+	sal_uInt8  nCol, nDummy;
+	sal_uInt16 nRow;
+	sal_uInt16 nStyle;
+    bool bEndOfSheet = false;
+
+#ifdef DEBUG
+    fprintf( stderr, "Read sheet (%d)\n", nTab );
+#endif
+
+    while( !bEndOfSheet && nextRecord() ) 
+    {
+        switch( getId() )
+        {
+            case 0x000f:{ // Label cell
+                String aLabel;
+                *mpStream >> nCol >> nDummy >> nRow >> nStyle >> nDummy;
+                readString( aLabel, getLength() - 7 );
+                nStyle = nStyle >> 3;
+                getStyleElement()->SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+                pDoc->PutCell( nCol, nRow, nTab, new ScStringCell( aLabel ), (BOOL) TRUE );
+                }
+                break;
+               	
+            case 0x00cb: // End of sheet
+                bEndOfSheet = true;
+                break;
+	
+            case 0x000c: // Blank cell
+                *mpStream >> nCol >> nDummy >> nRow >> nStyle;
+                nStyle = nStyle >> 3; 
+                getStyleElement()->SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+                break; 
+             
+            case 0x000d:{ // Integer cell
+                sal_Int16 nValue;
+                *mpStream >> nCol >> nDummy >> nRow >> nStyle >> nValue;	
+                ScValueCell* pInteger = new ScValueCell( ( double ) nValue ); 
+                nStyle = nStyle >> 3;
+                getStyleElement()->SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+                pDoc->PutCell(nCol ,nRow, nTab ,pInteger,(BOOL) TRUE);
+                }
+                break;
+
+            case 0x000e:{ // Floating point cell
+                double nValue;
+                *mpStream >> nCol >> nDummy >> nRow >> nStyle >> nValue;
+                ScValueCell* pFloat = new ScValueCell( nValue );
+                nStyle = nStyle >> 3;
+                getStyleElement()->SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+                pDoc->PutCell( nCol, nRow, nTab, pFloat, (BOOL) TRUE ); 
+                }
+                break;
+
+            case 0x0010:{ // Formula cell
+                double nValue;
+                sal_uInt16 nState, nLen; 
+                *mpStream >> nCol >> nDummy >> nRow >> nStyle >> nValue >> nState >> nLen;
+                ScAddress aAddr( nCol, nRow, nTab );
+                const ScTokenArray *pArray;
+                QProToSc aConv( *mpStream );
+                aConv.Convert( pArray, nLen );
+                ScFormulaCell *pFormula = new ScFormulaCell( pDoc, aAddr, pArray );
+                nStyle = nStyle >> 3;
+                pFormula->AddRecalcMode( RECALCMODE_ONLOAD_ONCE );
+                getStyleElement()->SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+                pDoc->PutCell( nCol, nRow, nTab, pFormula, ( BOOL ) TRUE );
+                }
+                break;
+        }
+    }
+    return eERR_OK;
+}
+
+FltError ScImportQuattroPro( SfxMedium &rMedium, ScDocument *pDoc )
+{
+    FltError   eRet = eERR_OK;
+    ScQProReader aReader( rMedium, pDoc );
+    eRet = aReader.import( pDoc );
+    return eRet;
+}
+
+ScQProReader::ScQProReader( SfxMedium &rMedium, ScDocument *pDoc ):
+    ScBiffReader( rMedium ),
+    aStyle()
+{
+}
+
+FltError ScQProReader::import( ScDocument *pDoc )
+{
+    FltError eRet = eERR_OK;
+    sal_uInt16 nVersion;
+    int i = 1 , j = 1;
+    int nTab = 0;
+    SetEof( FALSE );
+
+    if( !recordsLeft() )
+        return eERR_OPEN;
+
+    while( nextRecord() && eRet == eERR_OK) 
+    {
+        switch( getId() )
+        {
+            case 0x0000: // Begginning of file
+                *mpStream >> nVersion;
+                break;
+
+            case 0x00ca: // Beginning of sheet
+                if( nTab < 26 )
+                {
+                    String aName;
+                    aName.Append( sal_Unicode( 'A' + nTab ) );
+                    pDoc->InsertTab( nTab, aName );
+                }
+                eRet = readSheet( nTab, pDoc );
+                nTab++;
+                break;
+
+            case 0x0001: // End of file
+                SetEof( TRUE );
+                break;
+         
+            case 0x00ce:{ // Attribute cell
+                sal_uInt8 nFormat, nAlign, nFont;
+                sal_Int16 nColor;
+                *mpStream >> nFormat >> nAlign >> nColor >> nFont;
+                getStyleElement()->setAlign( i, nAlign );
+                getStyleElement()->setFont( i, nFont );
+                i++;
+                }
+                break;
+                                                                                                                  
+            case 0x00cf:{ // Font description
+                sal_uInt16 nPtSize, nFontAttr;
+                String aLabel;
+                *mpStream >> nPtSize >> nFontAttr;
+                getStyleElement()->setFontRecord( j, nFontAttr );
+                readString( aLabel, getLength() - 4 );
+                getStyleElement()->setFontType( j, aLabel );
+                j++;
+                }
+                break;
+        }
+    }
+    getStyleElement()->setFontLimit( j );
+    getStyleElement()->setAlignLimit( i );
+    pDoc->CalcAfterLoad();
+    return eRet;
+}
+
+bool ScQProReader::recordsLeft()
+{
+    bool bValue = ScBiffReader::recordsLeft();
+    return bValue;
+}
+
+bool ScQProReader::IsEndOfFile()
+{
+    bool bValue = ScBiffReader::mbEndOfFile;
+    return bValue;
+}
+
+bool ScQProReader::nextRecord()
+{
+    bool bValue = ScBiffReader::nextRecord();
+    return bValue;
+}
+
+void ScQProReader::readString( String &rString, sal_uInt16 nLength )
+{
+    sal_Char* pText = new sal_Char[ nLength + 1 ];
+    mpStream->Read( pText, nLength );
+    pText[ nLength ] = 0;
+    rString = String( pText, mpStream->GetStreamCharSet() );
+    delete [] pText;
+}
