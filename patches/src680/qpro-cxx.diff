--- /dev/null	2004-07-26 17:21:14.000000000 +0530
+++ sc/source/filter/qpro/qpro.cxx	2005-03-28 13:40:17.000000000 +0530
@@ -0,0 +1,338 @@
+#include <stdio.h>
+#include <sfx2/docfile.hxx>
+
+#include "qproform.hxx"
+#include "qpro.hxx"
+
+#include <tools/color.hxx>
+#include "scitems.hxx"
+#include <svx/algitem.hxx>
+#include <svx/udlnitem.hxx>
+#include <svx/wghtitem.hxx>
+#include <svx/postitem.hxx>
+#include <svx/crsditem.hxx>
+#include <svx/fontitem.hxx>
+#include <map>
+
+#include "global.hxx"
+#include "scerrors.hxx"
+#include "docpool.hxx" 
+#include "patattr.hxx"
+#include "filter.hxx"
+#include "document.hxx"
+#include "cell.hxx"
+
+BiffReader::BiffReader( SfxMedium & rMedium ) :
+    mnId(0),
+    mnLength(0),
+    mnOffset(0),
+    meCharSet( RTL_TEXTENCODING_ISO_8859_1 )
+{
+    mpStream = rMedium.GetInStream();
+    if( mpStream )
+        mpStream->SetBufferSize( 65536 );
+}
+
+BiffReader::~BiffReader()
+{
+    if( mpStream )
+       	mpStream->SetBufferSize( 0 );
+}
+
+SvStream& BiffReader::operator>>( sal_uInt8 &rByte )
+{
+    return *mpStream >> rByte;
+}
+
+SvStream& BiffReader::operator>>( sal_Int8 &rByte )
+{
+    return *mpStream >> rByte;
+}
+
+SvStream& BiffReader::operator>>( sal_uInt16 &rWord )
+{
+    return *mpStream >> rWord;
+}
+
+SvStream& BiffReader::operator>>( double &rDouble )
+{
+    return *mpStream >> rDouble;
+}
+
+bool BiffReader::nextRecord()
+{
+    if( !recordsLeft() )
+      	return false;
+
+    if( EndOfFile )
+        return false;
+
+    sal_uInt32 nPos = mpStream->Tell();
+    if( nPos != mnOffset + mnLength )
+        mpStream->Seek( mnOffset + mnLength );
+
+    mnLength = mnId = 0;
+    *mpStream >> mnId >> mnLength;
+
+    mnOffset = mpStream->Tell();
+#ifdef DEBUG
+    fprintf( stderr, "Read record 0x%x length 0x%x at offset 0x%x\n",
+        mnId, mnLength, mnOffset );
+
+#if 1  // rather verbose
+    int len = mnLength;
+    while (len > 0) {
+        int i, chunk = len < 16 ? len : 16;
+        unsigned char data[16];
+        mpStream->Read( data, chunk );
+
+        for (i = 0; i < chunk; i++)
+            fprintf( stderr, "%.2x ", data[i] );
+        fprintf( stderr, "| " );
+        for (i = 0; i < chunk; i++)
+            fprintf( stderr, "%c", data[i] < 127 && data[i] > 30 ? data[i] : '.' );
+        fprintf( stderr, "\n" );
+
+        len -= chunk;
+    }
+    mpStream->Seek( mnOffset );
+#endif 
+#endif
+    return true;
+}
+
+void BiffReader::readString( String &rString, sal_uInt16 nLength )
+{
+    sal_Char* pText = new sal_Char[ nLength + 1 ];
+    mpStream->Read( pText, nLength );
+    pText[ nLength ] = 0;
+    rString = String( pText, meCharSet );
+}
+
+void BiffReader::SetFormat( ScDocument *pDoc, sal_uInt8 nCol, sal_uInt16 nRow, sal_uInt8 nTab, sal_uInt16 nStyle )
+{
+    ScPatternAttr aPattern(pDoc->GetPool()); 
+    SfxItemSet& rItemSet = aPattern.GetItemSet();
+       
+    sal_uInt8 nTmp = Align[ nStyle ];
+    sal_uInt8 nHor = ( nTmp & 0x07 );
+    sal_uInt8 nVer = ( nTmp & 0x18 );
+    sal_uInt8 nOrient = ( nTmp & 0x60 );
+ 
+    // Horizontal Alignment
+    SvxHorJustifyItem ejustify = SVX_HOR_JUSTIFY_STANDARD;
+    switch( nHor )
+    {
+	case 0x00:
+            ejustify = SVX_HOR_JUSTIFY_STANDARD;
+            break;
+  
+        case 0x01: 
+            ejustify = SVX_HOR_JUSTIFY_LEFT;
+            break;
+  
+       	case 0x02: 
+            ejustify = SVX_HOR_JUSTIFY_CENTER;
+            break;
+
+       	case 0x03:
+            ejustify = SVX_HOR_JUSTIFY_RIGHT;
+            break;
+ 
+       	case 0x04: 
+            ejustify = SVX_HOR_JUSTIFY_BLOCK;
+            break;
+    }
+    rItemSet.Put( ejustify );
+
+    // Vertical Alignment
+    SvxVerJustifyItem verJustify = SVX_VER_JUSTIFY_STANDARD;
+    switch( nVer )
+    {
+        case 0x00:
+            verJustify = SVX_VER_JUSTIFY_BOTTOM;
+            break;
+            
+        case 0x08:
+            verJustify = SVX_VER_JUSTIFY_CENTER;
+            break; 
+        
+        case 0x10:
+            verJustify = SVX_VER_JUSTIFY_TOP;
+            break;
+    }
+    rItemSet.Put( verJustify ); 
+         
+    // Orientation
+    SvxOrientationItem orientItem = SVX_ORIENTATION_STANDARD;
+    switch( nOrient )
+    {
+    	case 0x20: 
+      	    orientItem = SVX_ORIENTATION_TOPBOTTOM;
+            break;
+ 
+    } 
+    rItemSet.Put( orientItem );
+
+    // Wrap cell contents
+    if( nTmp & 0x80 )
+    {
+        SfxBoolItem WrapItem( ATTR_LINEBREAK );
+        WrapItem.SetValue( TRUE );
+        rItemSet.Put( WrapItem );
+    }
+
+    // Font Attributes
+    sal_uInt16 nTmpFnt = FontRecord[ Font[ nStyle ] ];
+    BOOL bIsBold, bIsItalic, bIsUnderLine, bIsStrikeThrough;
+
+    bIsBold = ( nTmpFnt & 0x0001 );
+    bIsItalic = ( nTmpFnt & 0x0002 );
+    bIsUnderLine = ( nTmpFnt & 0x0004 );
+    bIsStrikeThrough = (nTmpFnt & 0x0020 );
+
+    if( bIsBold )
+        rItemSet.Put( SvxWeightItem( WEIGHT_BOLD,ATTR_FONT_WEIGHT) );
+    if( bIsItalic )
+        rItemSet.Put( SvxPostureItem( ITALIC_NORMAL, ATTR_FONT_POSTURE ) );
+    if( bIsUnderLine )
+        rItemSet.Put( SvxUnderlineItem( UNDERLINE_SINGLE, ATTR_FONT_UNDERLINE ) );
+     
+    String fntName = FontType[ Font[ nStyle ] ];
+    rItemSet.Put( SvxFontItem( FAMILY_SYSTEM, fntName, EMPTY_STRING ) );
+
+    pDoc->ApplyPattern( nCol, nRow, nTab, aPattern );
+} 
+
+FltError readQProSheet( BiffReader &rReader, ScDocument *pDoc, sal_uInt16 nTab )
+{
+    sal_uInt8  nCol, nDummy;
+    sal_uInt16 nRow;
+    sal_uInt16 nStyle;
+    bool bEndOfSheet = false;
+
+#ifdef DEBUG
+    fprintf( stderr, "Read sheet (%d)\n", nTab );
+#endif
+
+    while( !bEndOfSheet && rReader.nextRecord() ) {
+       	switch( rReader.getId() )
+        {
+       	    case 0x000f: { // Label cell
+                String aLabel;
+               	rReader >> nCol >> nDummy >> nRow >> nStyle >> nDummy;
+               	rReader.readString( aLabel, rReader.getLength() - 7 );
+               	nStyle = ( nStyle & 0xfff8 ) >> 3;
+               	rReader.SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+               	pDoc->PutCell( nCol, nRow, nTab, new ScStringCell( aLabel ), (BOOL) TRUE );
+		}
+               	break;
+               	
+            case 0x00cb: // End of sheet;
+            	bEndOfSheet = true;
+                break;
+		
+            case 0x000c: // Blank cell
+               	rReader >> nCol >> nDummy >> nRow >> nStyle; 
+              	rReader.SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+		break; 
+             
+            case 0x000d:  { // Integer cell
+		sal_Int16 nValue;
+		rReader >> nCol >> nDummy >> nRow >> nStyle >> nValue;	
+ 		ScValueCell* aInteger = new ScValueCell( ( double ) nValue ); 
+		nStyle = ( nStyle & 0xfff8 ) >> 3;
+		rReader.SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+		pDoc->PutCell(nCol ,nRow, nTab ,aInteger,(BOOL) TRUE);
+		}
+               	break;
+
+   	    case 0x000e: { // Floating point cell
+               	double nValue;
+               	rReader >> nCol >> nDummy >> nRow >> nStyle >> nValue;
+               	ScValueCell* aFloat = new ScValueCell( nValue );
+		nStyle = ( nStyle & 0xfff8 ) >> 3;
+               	rReader.SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+		pDoc->PutCell( nCol, nRow, nTab, aFloat, (BOOL) TRUE ); 
+		}
+		break;
+
+	    case 0x0010: { // Formula cell
+               	double nValue;
+               	sal_uInt16 nState, nLen; 
+               	rReader >> nCol >> nDummy >> nRow >> nStyle >> nValue >> nState >> nLen;
+               	ScAddress aAddr( nCol, nRow, nTab );
+               	const ScTokenArray *pErg;
+               	QProToSc aConv( rReader );
+               	aConv.Convert( pErg, nLen );
+               	ScFormulaCell *pZelle = new ScFormulaCell( pDoc, aAddr, pErg );
+	        nStyle = ( nStyle & 0xfff8 ) >> 3;
+                pZelle->AddRecalcMode( RECALCMODE_ONLOAD_ONCE );
+		rReader.SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+                pDoc->PutCell( nCol, nRow, nTab, pZelle, ( BOOL ) TRUE );
+		}
+		break;
+	}
+    }
+    return eERR_OK;
+}
+
+FltError ScImportQuattroPro( SfxMedium &rMedium, ScDocument *pDoc )
+{
+    FltError   eRet = eERR_OK;
+    BiffReader aReader( rMedium );
+    sal_uInt16 nVersion, i = 1, j = 1;
+    int nTab = 0;
+    aReader.EndOfFile = FALSE;
+
+    if( !aReader.recordsLeft() )
+        return eERR_OPEN;
+
+    while( aReader.nextRecord() && eRet == eERR_OK) {
+        switch( aReader.getId() )
+        {
+            case 0x0000: // Begginning of file
+                aReader >> nVersion;
+                break;
+
+            case 0x00ca: // Beginning of sheet
+                if( nTab < 26 )
+                {
+                    String aName;
+                    aName.Append( sal_Unicode( 'A' + nTab ) );
+                    pDoc->InsertTab( nTab, aName );
+                }
+                eRet = readQProSheet( aReader, pDoc, nTab );
+                nTab++;
+                break;
+
+            case 0x0001: // End of file
+                aReader.EndOfFile = TRUE;
+                break;
+          
+            case 0x00ce: { // Attribute cell
+                sal_uInt8 nFormat, nAlign, nFont;
+                sal_Int16 nColor;
+                aReader >> nFormat >> nAlign >> nColor >> nFont;
+                aReader.Align[ i ] = nAlign;
+                aReader.Font[ i ] = nFont;
+                i++;
+		}
+                break;
+                                                                                                                  
+            case 0x00cf: { // Font description
+                sal_uInt16 nPtSize, nFontAttr;
+	        String Label;
+                aReader >> nPtSize >> nFontAttr;
+                aReader.FontRecord[ j ] = nFontAttr;
+                aReader.readString( Label, aReader.getLength() - 4 );
+                aReader.FontType[ j ] = Label;
+                j++;
+		}
+                break;
+
+        }
+    }
+    pDoc->CalcAfterLoad();
+    return eRet;
+}
