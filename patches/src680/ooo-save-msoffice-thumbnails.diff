2005-11-01  Federico Mena Quintero  <federico@ximian.com>

	Add support for the VT_CF property to the serializer:

	* build-hack/ooo680-m2/sfx2/source/doc/docinf.cxx (VT_CF): New
	constant for VT_CF = 71.
	(PID_THUMBNAIL): New property id (0x11).
	(class SfxPSThumbnailProperty_Impl): New class, derived from
	SfxPSProperty_Impl.  We use this to hold a VT_CF thumbnail.
	(SfxPSThumbnailPropertySfxThumbnailProperty_Impl): Implement.  We
	take in a metafile, convert it to BMP, serialize the BMP, and keep
	the serialization around for when we are asked to ::Save() it in a
	stream.
	(SfxPSThumbnailProperty_Impl::~SfxPSThumbnailProperty_Impl):
	Implement; free our serialized data.
	(SfxPSThumbnailProperty_Impl::Save): Implement; serialize the
	headers and the precomputed bitmap data.
	(SfxPSThumbnailProperty_Impl::Len): Implement; just return the
	size of the precomputed data.
	(SfxPSThumbnailProperty_Impl::IsValid): Implement; return whether
	we were able to render the data to a bitmap and serialize it.
	(SfxDocumentInfo::SavePropertySet): Create a thumbnail property.
	If we are successful, add the property to the property set.

	Add a thumbnail metafile property to SfxDoccumentInfo:

	* build/ooo680-m2/sfx2/source/doc/graphhelp.hxx (class
	GraphicHelper): Make createThumb_Impl public.  I don't like this
	at all, but there's doesn't seem to be a "turn this metafile into
	a Bitmap" function that I can use.

	* build-hack/ooo680-m2/sfx2/inc/docinf.hxx (class
	SfxDocumentInfo): Added an aThumbnailMetaFile private field.  Added
	GetThumbnailMetaFile() and SetThumbnailMetaFile() public methods.

	* build-hack/ooo680-m2/sfx2/source/doc/docinf.cxx
	(SfxDocumentInfo::SetThumbnailMetaFile): Implement.

	* build/ooo680-m2/sw/inc/doc.hxx (class SwDoc): Make the GetInfo()
	method non-const.

	* build/ooo680-m2/sw/source/core/doc/docnew.cxx (SwDoc::GetInfo):
	Make this non-const.

	Generate the thumbnails:

	* build-hack/ooo680-m2/sw/source/filter/ww8/wrtww8.cxx
	(SwWW8Writer::PrepareStorage): Generate the thumbnail metafile,
	and put it in the SfxDocumentInfo before serializing the info.
	Also, our info is now non-const.

	* build/ooo680-m2/sc/source/filter/excel/expop2.cxx
	(ExportBiff5::Write): Generate the thumbnail metafile, and put it
	in the SfxDocumentInfo before serializing the info.

--- sfx2/inc/docinf.hxx	2005-09-07 11:50:53.000000000 -0500
+++ sfx2/inc/docinf.hxx	2005-10-27 14:00:59.000000000 -0500
@@ -69,6 +69,10 @@ class SvStream;
 #include <tools/timestamp.hxx>
 #endif
 
+#ifndef _SV_GDIMTF_HXX
+#include <vcl/gdimtf.hxx>
+#endif
+
 // SfxStamp changed to "tools/TimeStamp" !!!
 typedef TimeStamp SfxStamp ;
 
@@ -136,6 +140,8 @@ private:
 	String   aComment;
 	String   aKeywords;
 
+	GDIMetaFile aThumbnailMetaFile;
+
 	SfxDocUserKey aUserKeys[MAXDOCUSERKEYS];
 
 	String   aTemplateName;             // Name der Dokumentvorlage
@@ -219,11 +225,15 @@ public:
 	const String&  GetComment() const   { return aComment;  }
 	const String&  GetKeywords()const   { return aKeywords; }
 
+	const GDIMetaFile &GetThumbnailMetaFile() const { return aThumbnailMetaFile; }
+
 	void  SetTitle( const String& rVal );
 	void  SetTheme( const String& rVal );
 	void  SetComment( const String& rVal );
 	void  SetKeywords( const String& rVal );
 
+	void  SetThumbnailMetaFile (const GDIMetaFile &aMetaFile);
+
 	void  SetChanged( const String& rChanger ) { SetChanged( SfxStamp( rChanger ) ); }
 	void  SetCreated( const String& rCreator ) { SetCreated( SfxStamp( rCreator ) ); }
 
--- sfx2/source/doc/docinf.cxx	2005-09-07 13:39:29.000000000 -0500
+++ sfx2/source/doc/docinf.cxx	2005-10-27 14:01:34.000000000 -0500
@@ -40,11 +40,13 @@
 #include <svtools/sfxecode.hxx>
 #endif
 #include <tools/urlobj.hxx>
+#include <tools/new.hxx>
 #include <svtools/saveopt.hxx>
 #include <tools/tenccvt.hxx>
 #include <svtools/useroptions.hxx>
 #include <sot/exchange.hxx>
 #include <sot/storage.hxx>
+#include <vcl/bitmapex.hxx>
 #include "rtl/tencinfo.h"
 
 #include "docfilt.hxx"
@@ -54,6 +56,7 @@
 #include "docinf.hxx"
 #include "docfile.hxx"
 #include "sfxtypes.hxx"
+#include "graphhelp.hxx"
 
 //========================================================================
 
@@ -68,6 +71,7 @@ static const char __FAR_DATA pDocInfoHea
 #define VT_LPSTR      30
 #define VT_LPWSTR     31
 #define VT_FILETIME   64
+#define VT_CF         71
 
 #define PID_TITLE              0x02
 #define PID_SUBJECT            0x03
@@ -81,6 +85,7 @@ static const char __FAR_DATA pDocInfoHea
 #define PID_LASTPRINTED_DTM    0x0b
 #define PID_CREATE_DTM         0x0c
 #define PID_LASTSAVED_DTM      0x0d
+#define PID_THUMBNAIL          0x11
 
 //=========================================================================
 
@@ -411,6 +416,111 @@ ULONG SfxPSDateTimeProperty_Impl::Len()
 
 //=========================================================================
 
+class SfxPSThumbnailProperty_Impl : public SfxPSProperty_Impl
+{
+private:
+	SvMemoryStream aMemStream;
+	sal_Bool bHaveBitmap;
+	sal_Size nBitmapDataSize;
+
+public:
+	SfxPSThumbnailProperty_Impl (UINT32 nIdP, const GDIMetaFile &rThumbnailMetaFile);
+	virtual ~SfxPSThumbnailProperty_Impl();
+
+	virtual ULONG Save (SvStream &rStream);
+	virtual ULONG Len ();
+
+	sal_Bool IsValid ();
+};
+
+//#include <stdio.h>
+
+#define CF_DIB 8				// this is the clip_data format identifier for a DIB
+
+SfxPSThumbnailProperty_Impl::SfxPSThumbnailProperty_Impl (UINT32 nIdP, const GDIMetaFile &rThumbnailMetaFile) :
+	SfxPSProperty_Impl (nIdP, VT_CF)
+{
+	BitmapEx aBitmap;
+
+	if (!rThumbnailMetaFile.CreateThumbnail ( 160, /* magic value taken from GraphicHelper::getThumbnailFormatFromGDI_Impl() */
+					          aBitmap))
+	{
+	    bHaveBitmap = sal_False;
+	    nBitmapDataSize = 0;
+	    return;
+	}
+
+	aBitmap.GetBitmap().Write( aMemStream, FALSE, FALSE );
+	nBitmapDataSize = aMemStream.Tell ();
+	bHaveBitmap = sal_True;
+	//fprintf (stderr, "ThumbnailProperty::constructor wrote %ld bytes for the bitmap\n", (long) nBitmapDataSize);
+}
+
+SfxPSThumbnailProperty_Impl::~SfxPSThumbnailProperty_Impl ()
+{
+    bHaveBitmap = sal_False;
+    nBitmapDataSize = 0;
+}
+
+ULONG
+SfxPSThumbnailProperty_Impl::Save (SvStream &rStream)
+{
+	/* clipboard size          uint32       sizeof (clipboard format tag) + sizeof (clipboard data)
+	 * clipboard format tag    int32        see below
+	 * clipboard data          byte[]       see below
+	 *
+	 * Clipboard format tag:
+	 * -1 - Windows clipboard format
+	 * -2 - Macintosh clipboard format
+	 * -3 - GUID that contains a format identifier (FMTID)
+	 * >0 - custom clipboard format name plus data (see msdn site below)
+	 *  0 - No data
+	 *
+	 * References:
+	 * http://msdn.microsoft.com/library/default.asp?url=/library/en-us/stg/stg/propvariant.asp
+	 * http://jakarta.apache.org/poi/hpsf/thumbnails.html
+	 * http://linux.com.hk/docs/poi/org/apache/poi/hpsf/Thumbnail.html
+	 * http://sparks.discreet.com/knowledgebase/public/solutions/ExtractThumbnailImg.htm
+	 */
+
+	UINT32 nClipSize;
+	INT32 nClipFormat;
+	INT32 nDataFormat;
+
+	if (!IsValid ())
+	    return SVSTREAM_INVALID_ACCESS;
+
+	nClipSize = 4 + 4 + nBitmapDataSize; /* clip_format_tag + data_format_tag + bitmap_len */
+	nClipFormat = -1; /* Windows clipboard format; we'll say "it's a BMP" in the data section */
+	nDataFormat = CF_DIB;
+#if 0
+	fprintf (stderr, "ThumbnailProperty::Save() writing clip_size %d, clip_format %d, data_format %d, bitmap_data_bytes %ld\n",
+			 (int) nClipSize,
+			 (int) nClipFormat,
+			 (int) nDataFormat,
+			 (long) nBitmapDataSize);
+#endif
+	rStream << nClipSize << nClipFormat << nDataFormat;
+	rStream.Write (aMemStream.GetData (), nBitmapDataSize);
+
+	return rStream.GetErrorCode ();
+}
+
+ULONG
+SfxPSThumbnailProperty_Impl::Len ()
+{
+	//fprintf (stderr, "ThumbnailProperty::Len() returns %ld\n", (long) 4 + 4 + 4 + nBitmapDataSize);
+    return 4 + 4 + 4 + nBitmapDataSize; /* total property size field + clip_format_tag + data_format_tag + bitmap_len */
+}
+
+sal_Bool
+SfxPSThumbnailProperty_Impl::IsValid ()
+{
+    return (bHaveBitmap && nBitmapDataSize != 0);
+}
+
+//=========================================================================
+
 typedef SfxPSProperty_Impl *SfxPSPropertyPtr_Impl;
 SV_DECL_PTRARR_DEL(SfxPSPropertyArr_Impl, SfxPSPropertyPtr_Impl, 10, 10);
 SV_IMPL_PTRARR(SfxPSPropertyArr_Impl, SfxPSPropertyPtr_Impl);
@@ -997,6 +1108,8 @@ BOOL SfxDocumentInfo::SavePropertySet( S
 	SfxPS_Impl* pPS = new SfxPS_Impl;
 	SotStorageStreamRef aStrPropSet = pStorage->OpenSotStream(
 		String::CreateFromAscii( pPropSlot ), STREAM_TRUNC | STREAM_STD_WRITE );
+	SfxPSThumbnailProperty_Impl *thumb_prop;
+
 	if ( !aStrPropSet.Is() )
 	{
 		DBG_ERRORFILE( "can not open the property set" );
@@ -1022,6 +1135,13 @@ BOOL SfxDocumentInfo::SavePropertySet( S
 	pPS->AddProperty( new SfxPSStringProperty_Impl(
 		PID_REVNUMBER, String::CreateFromInt32( GetDocumentNumber() ) ) );
 	pPS->AddProperty( new SfxPSCodePageProperty_Impl( RTL_TEXTENCODING_UTF8 ));
+
+	thumb_prop = new SfxPSThumbnailProperty_Impl (PID_THUMBNAIL, GetThumbnailMetaFile());
+	if (thumb_prop->IsValid ())
+	    pPS->AddProperty (thumb_prop);
+	else
+	    delete thumb_prop;
+
 	pPS->Save( *aStrPropSet );
 	delete pPS;
 	return ( aStrPropSet->GetErrorCode() == 0 );
@@ -1631,6 +1751,12 @@ void SfxDocumentInfo::SetKeywords( const
 {
 	aKeywords = AdjustTextLen_Impl( rVal, SFXDOCINFO_KEYWORDLENMAX );
 }
+//------------------------------------------------------------------------
+
+void SfxDocumentInfo::SetThumbnailMetaFile (const GDIMetaFile &aMetaFile)
+{
+	aThumbnailMetaFile = aMetaFile;
+}
 
 void SfxDocumentInfo::DeleteUserData( BOOL bUseAuthor )
 {
--- sw/source/core/doc/docnew.cxx	2005-09-08 22:13:48.000000000 -0500
+++ sw/source/core/doc/docnew.cxx	2005-10-25 22:29:10.000000000 -0500
@@ -873,7 +873,7 @@ void SwDoc::SetPersist( SfxObjectShell* 
 
 
 
-const SfxDocumentInfo* SwDoc::GetInfo()
+SfxDocumentInfo* SwDoc::GetInfo()
 {
 	if( !pSwgInfo )
 		// Pointer-Members initialisieren
--- sw/inc/doc.hxx	2005-09-08 20:40:43.000000000 -0500
+++ sw/inc/doc.hxx	2005-10-25 22:29:23.000000000 -0500
@@ -1469,7 +1469,7 @@ public:
 
         // Dokument - Info
 			// legt sie auf jedenfall an!
-	const SfxDocumentInfo* GetInfo();
+	SfxDocumentInfo* GetInfo();
 			// kann auch 0 sein !!!
 	const SfxDocumentInfo* GetpInfo() const { return pSwgInfo; }
 
--- sw/source/filter/ww8/wrtww8.cxx	2005-09-09 01:08:46.000000000 -0500
+++ sw/source/filter/ww8/wrtww8.cxx	2005-10-27 19:46:46.000000000 -0500
@@ -2460,6 +2460,9 @@ void SwWW8Writer::PrepareStorage()
     const BYTE* pData;
     const char* pName;
     UINT32 nId1;
+    const SwDocShell* pDocShell;
+    SfxDocumentInfo* pInfo;
+    
 
     if (bWrtWW8)
     {
@@ -2518,8 +2521,23 @@ void SwWW8Writer::PrepareStorage()
     pStg->SetClass( aGName, 0, String::CreateFromAscii( pName ));
     SvStorageStreamRef xStor( pStg->OpenSotStream(sCompObj) );
     xStor->Write( pData, nLen );
-                // noch mal ueberplaetten, um auch Clipboardformat zu setzen
-    pDoc->GetInfo()->SavePropertySet( pStg );   // DocInfo
+
+    pInfo = pDoc->GetInfo ();
+    pDocShell = pDoc->GetDocShell ();
+
+    if (pDocShell)
+    {
+		GDIMetaFile *pMetaFile;
+
+		pMetaFile = pDocShell->GetPreviewMetaFile (sal_False);
+		if (pMetaFile)
+		{
+			pInfo->SetThumbnailMetaFile (*pMetaFile);
+			delete pMetaFile;
+		}
+    }
+
+    pInfo->SavePropertySet( pStg );   // DocInfo
 }
 
 ULONG SwWW8Writer::WriteStorage()
--- sc/source/filter/excel/expop2.cxx	2005-09-08 13:57:15.000000000 -0500
+++ sc/source/filter/excel/expop2.cxx	2005-10-27 19:41:33.000000000 -0500
@@ -120,7 +120,17 @@ FltError ExportBiff5::Write()
 
     if( pDocShell && xRootStrg.Is() )
     {
+		GDIMetaFile *pMetaFile;
+
         SfxDocumentInfo& rInfo = pDocShell->GetDocInfo();
+
+		pMetaFile = pDocShell->GetPreviewMetaFile (sal_False);
+		if (pMetaFile)
+		{
+			rInfo.SetThumbnailMetaFile (*pMetaFile);
+			delete pMetaFile;
+		}
+
         rInfo.SavePropertySet( xRootStrg );
     }
 
--- vcl/source/gdi/gdimtf.cxx	2005-10-19 14:38:32 +02:00
+++ vcl/source/gdi/gdimtf.cxx	2006-02-02 10:51:41 +01:00
@@ -2364,3 +2364,119 @@ SvStream& GDIMetaFile::Write( SvStream& 
 
 	return rOStm;
 }
+
+// ------------------------------------------------------------------------
+
+const BOOL GDIMetaFile::CreateThumbnail( sal_uInt32 nMaximumExtent,
+									BitmapEx& rBmpEx, 
+									const BitmapEx* pOverlay,
+									const Rectangle* pOverlayRect )
+{
+	// the implementation is provided by KA
+
+	// initialization seems to be complicated but is used to avoid rounding errors
+	VirtualDevice	aVDev;
+	const Point     aNullPt;
+	const Point     aTLPix( aVDev.LogicToPixel( aNullPt, GetPrefMapMode() ) );
+	const Point     aBRPix( aVDev.LogicToPixel( Point( GetPrefSize().Width() - 1, GetPrefSize().Height() - 1 ), GetPrefMapMode() ) );
+	Size            aDrawSize( aVDev.LogicToPixel( GetPrefSize(), GetPrefMapMode() ) );
+	Size			aSizePix( labs( aBRPix.X() - aTLPix.X() ) + 1, labs( aBRPix.Y() - aTLPix.Y() ) + 1 );
+	Point			aPosPix;
+	
+	if ( !rBmpEx.IsEmpty() )
+		rBmpEx.SetEmpty();
+
+	// determine size that has the same aspect ratio as image size and
+	// fits into the rectangle determined by nMaximumExtent
+	if ( aSizePix.Width() && aSizePix.Height()
+	  && ( aSizePix.Width() > nMaximumExtent || aSizePix.Height() > nMaximumExtent ) )
+	{
+		const Size  aOldSizePix( aSizePix );
+		double      fWH = static_cast< double >( aSizePix.Width() ) / aSizePix.Height();
+
+		if ( fWH <= 1.0 )
+		{
+			aSizePix.Width() = FRound( nMaximumExtent * fWH );
+			aSizePix.Height() = nMaximumExtent;
+		}
+		else
+		{
+			aSizePix.Width() = nMaximumExtent;
+			aSizePix.Height() = FRound(  nMaximumExtent / fWH );
+		}
+		
+		aDrawSize.Width() = FRound( ( static_cast< double >( aDrawSize.Width() ) * aSizePix.Width() ) / aOldSizePix.Width() );
+		aDrawSize.Height() = FRound( ( static_cast< double >( aDrawSize.Height() ) * aSizePix.Height() ) / aOldSizePix.Height() );
+	}
+	
+	Size 		aFullSize;
+	Point		aBackPosPix;
+	Rectangle 	aOverlayRect;
+
+	// calculate addigtional positions and sizes if an overlay image is used
+	if (  pOverlay )
+	{
+		aFullSize = Size( nMaximumExtent, nMaximumExtent );
+		aOverlayRect = Rectangle( aNullPt, aFullSize  );
+		
+		aOverlayRect.Intersection( pOverlayRect ? *pOverlayRect : Rectangle( aNullPt, pOverlay->GetSizePixel() ) );
+ 		
+		if ( !aOverlayRect.IsEmpty() )
+			aBackPosPix = Point( ( nMaximumExtent - aSizePix.Width() ) >> 1, ( nMaximumExtent - aSizePix.Height() ) >> 1 );
+		else
+			pOverlay = NULL;
+	}
+	else
+	{
+		aFullSize = aSizePix;
+		pOverlay = NULL;
+	}
+		
+	// draw image(s) into VDev and get resulting image
+	if ( aVDev.SetOutputSizePixel( aFullSize ) )
+	{
+		// draw metafile into VDev
+		WindStart();
+		Play( &aVDev, aBackPosPix, aDrawSize );
+		
+		// draw overlay if neccessary
+		if ( pOverlay )
+			aVDev.DrawBitmapEx( aOverlayRect.TopLeft(), aOverlayRect.GetSize(), *pOverlay );
+		
+		// get paint bitmap
+		Bitmap aBmp( aVDev.GetBitmap( aNullPt, aVDev.GetOutputSizePixel() ) );
+		
+		// assure that we have a true color image
+		if ( aBmp.GetBitCount() != 24 )
+			aBmp.Convert( BMP_CONVERSION_24BIT );
+			
+		// create resulting mask bitmap with metafile output set to black
+		GDIMetaFile aMonchromeMtf( GetMonochromeMtf( COL_BLACK ) );
+		aVDev.DrawWallpaper( Rectangle( aNullPt, aSizePix ), Wallpaper( Color( COL_WHITE ) ) );
+		aMonchromeMtf.WindStart();
+		aMonchromeMtf.Play( &aVDev, aBackPosPix, aDrawSize );
+		
+		// watch for overlay mask
+		if ( pOverlay  )
+		{
+			Bitmap aOverlayMergeBmp( aVDev.GetBitmap( aOverlayRect.TopLeft(), aOverlayRect.GetSize() ) );
+			
+			// create ANDed resulting mask at overlay area
+			if ( pOverlay->IsTransparent() )
+				aVDev.DrawBitmap( aOverlayRect.TopLeft(), aOverlayRect.GetSize(), pOverlay->GetMask() );
+			else
+			{
+				aVDev.SetLineColor( COL_BLACK );
+				aVDev.SetFillColor( COL_BLACK );
+				aVDev.DrawRect( aOverlayRect);
+			}			
+				
+			aOverlayMergeBmp.CombineSimple( aVDev.GetBitmap( aOverlayRect.TopLeft(), aOverlayRect.GetSize() ), BMP_COMBINE_AND );
+			aVDev.DrawBitmap( aOverlayRect.TopLeft(), aOverlayRect.GetSize(), aOverlayMergeBmp );
+		}
+		
+		rBmpEx = BitmapEx( aBmp, aVDev.GetBitmap( aNullPt, aVDev.GetOutputSizePixel() ) );
+	}
+	
+	return !rBmpEx.IsEmpty();
+}
--- sd/source/ui/unoidl/unopage.cxx	2006-01-19 14:03:42 +01:00
+++ sd/source/ui/unoidl/unopage.cxx	2006-02-02 13:46:26 +01:00
@@ -187,7 +187,7 @@ enum WID_PAGE
 	WID_PAGE_LEFT, WID_PAGE_RIGHT, WID_PAGE_TOP, WID_PAGE_BOTTOM, WID_PAGE_WIDTH,
 	WID_PAGE_HEIGHT, WID_PAGE_EFFECT, WID_PAGE_CHANGE, WID_PAGE_SPEED, WID_PAGE_NUMBER,
 	WID_PAGE_ORIENT, WID_PAGE_LAYOUT, WID_PAGE_DURATION, WID_PAGE_LDNAME, WID_PAGE_LDBITMAP,
-	WID_PAGE_BACK, WID_PAGE_PREVIEW, WID_PAGE_VISIBLE, WID_PAGE_SOUNDFILE, WID_PAGE_BACKFULL,
+	WID_PAGE_BACK, WID_PAGE_PREVIEW, WID_PAGE_PREVIEWBITMAP, WID_PAGE_VISIBLE, WID_PAGE_SOUNDFILE, WID_PAGE_BACKFULL,
 	WID_PAGE_BACKVIS, WID_PAGE_BACKOBJVIS, WID_PAGE_USERATTRIBS, WID_PAGE_BOOKMARK, WID_PAGE_ISDARK,
 	WID_PAGE_HEADERVISIBLE, WID_PAGE_HEADERTEXT, WID_PAGE_FOOTERVISIBLE, WID_PAGE_FOOTERTEXT,
 	WID_PAGE_PAGENUMBERVISIBLE, WID_PAGE_DATETIMEVISIBLE, WID_PAGE_DATETIMEFIXED, 
@@ -227,6 +227,7 @@ const SfxItemPropertyMap* ImplGetDrawPag
 		{ MAP_CHAR_LEN(UNO_NAME_PAGE_SPEED),			WID_PAGE_SPEED,		&::getCppuType((const presentation::AnimationSpeed*)0),	0,	0},
 		{ MAP_CHAR_LEN(UNO_NAME_PAGE_WIDTH),			WID_PAGE_WIDTH,		&::getCppuType((const sal_Int32*)0),			0,	0},
 		{ MAP_CHAR_LEN(UNO_NAME_PAGE_PREVIEW),			WID_PAGE_PREVIEW,	SEQTYPE(::getCppuType((::com::sun::star::uno::Sequence<sal_Int8>*)0)), ::com::sun::star::beans::PropertyAttribute::READONLY, 0},
+		{ MAP_CHAR_LEN(UNO_NAME_PAGE_PREVIEWBITMAP),	WID_PAGE_PREVIEWBITMAP,	SEQTYPE(::getCppuType((::com::sun::star::uno::Sequence<sal_Int8>*)0)), ::com::sun::star::beans::PropertyAttribute::READONLY, 0},
 		{ MAP_CHAR_LEN(UNO_NAME_PAGE_VISIBLE),			WID_PAGE_VISIBLE,	&::getBooleanCppuType(),						0, 0},
 		{ MAP_CHAR_LEN(UNO_NAME_OBJ_SOUNDFILE),			WID_PAGE_SOUNDFILE,	&::getCppuType((const OUString*)0),				0, 0},
 		{ MAP_CHAR_LEN(sUNO_Prop_IsBackgroundVisible),	WID_PAGE_BACKVIS,	&::getBooleanCppuType(),						0, 0},
@@ -293,6 +294,7 @@ const SfxItemPropertyMap* ImplGetDrawPag
 		{ MAP_CHAR_LEN(UNO_NAME_PAGE_ORIENTATION),		WID_PAGE_ORIENT,	&::getCppuType((const view::PaperOrientation*)0),0,	0},
 		{ MAP_CHAR_LEN(UNO_NAME_PAGE_WIDTH),			WID_PAGE_WIDTH,		&::getCppuType((const sal_Int32*)0),			0,	0},
 		{ MAP_CHAR_LEN(UNO_NAME_PAGE_PREVIEW),			WID_PAGE_PREVIEW,	SEQTYPE(::getCppuType((::com::sun::star::uno::Sequence<sal_Int8>*)0)), ::com::sun::star::beans::PropertyAttribute::READONLY, 0},
+		{ MAP_CHAR_LEN(UNO_NAME_PAGE_PREVIEWBITMAP),	WID_PAGE_PREVIEWBITMAP,	SEQTYPE(::getCppuType((::com::sun::star::uno::Sequence<sal_Int8>*)0)), ::com::sun::star::beans::PropertyAttribute::READONLY, 0},
 		{ MAP_CHAR_LEN(sUNO_Prop_UserDefinedAttributes),WID_PAGE_USERATTRIBS, &::getCppuType((const Reference< ::com::sun::star::container::XNameContainer >*)0)  , 		0,     0},
 		{ MAP_CHAR_LEN(sUNO_Prop_BookmarkURL),			WID_PAGE_BOOKMARK,	&::getCppuType((const OUString*)0),				0,	0},
 		{ MAP_CHAR_LEN("IsBackgroundDark" ),			WID_PAGE_ISDARK,	&::getBooleanCppuType(),						beans::PropertyAttribute::READONLY, 0},
@@ -1030,6 +1032,38 @@ Any SAL_CALL SdGenericDrawPage::getPrope
 						SvMemoryStream aDestStrm( 65535, 65535 );
 						ConvertGDIMetaFileToWMF( *pMetaFile, aDestStrm, NULL, NULL, sal_False );
 						uno::Sequence<sal_Int8> aSeq( (sal_Int8*)aDestStrm.GetData(), aDestStrm.Tell() );
+						aAny <<= aSeq;
+						delete pMetaFile;
+					}
+				}
+			}
+		}
+		break;
+
+	case WID_PAGE_PREVIEWBITMAP :
+		{
+			SdDrawDocument* pDoc = (SdDrawDocument*)GetPage()->GetModel();
+			if ( pDoc )
+			{
+				::sd::DrawDocShell* pDocShell = pDoc->GetDocSh();
+				if ( pDocShell )
+				{
+					sal_uInt16 nPgNum = 0;
+					sal_uInt16 nPageCount = pDoc->GetSdPageCount( PK_STANDARD );
+					sal_uInt16 nPageNumber = (sal_uInt16)( ( GetPage()->GetPageNum() - 1 ) >> 1 );
+					while( nPgNum < nPageCount )
+					{
+						pDoc->SetSelected( pDoc->GetSdPage( nPgNum, PK_STANDARD ), nPgNum == nPageNumber );
+						nPgNum++;
+					}
+					GDIMetaFile* pMetaFile = pDocShell->GetPreviewMetaFile();
+					BitmapEx aBitmap;
+					if ( pMetaFile && pMetaFile->CreateThumbnail( 160, /* magic value taken from GraphicHelper::getThumbnailFormatFromGDI_Impl() */
+																  aBitmap ) )
+					{
+						SvMemoryStream aMemStream;
+						aBitmap.GetBitmap().Write( aMemStream, FALSE, FALSE );
+						uno::Sequence<sal_Int8> aSeq( (sal_Int8*)aMemStream.GetData(), aMemStream.Tell() );
 						aAny <<= aSeq;
 						delete pMetaFile;
 					}
--- sd/source/ui/inc/unoprnms.hxx	2005-09-09 07:59:49 +02:00
+++ sd/source/ui/inc/unoprnms.hxx	2006-01-31 09:44:55 +01:00
@@ -54,6 +54,7 @@
 #define UNO_NAME_PAGE_SPEED				"Speed"
 #define UNO_NAME_PAGE_WIDTH				"Width"
 #define UNO_NAME_PAGE_PREVIEW			"Preview"
+#define UNO_NAME_PAGE_PREVIEWBITMAP		"PreviewBitmap"
 #define UNO_NAME_PAGE_VISIBLE			"Visible"
 
 #define UNO_NAME_OBJ_BOOKMARK			"Bookmark"
--- vcl/inc/gdimtf.hxx	2005-10-19 14:37:57 +02:00
+++ vcl/inc/gdimtf.hxx	2006-02-01 19:30:35 +01:00
@@ -251,6 +251,8 @@ public:
 	// und lesen sowohl das alte wie auch das neue Format
     friend VCL_DLLPUBLIC SvStream& operator>>( SvStream& rIStm, GDIMetaFile& rGDIMetaFile );
     friend VCL_DLLPUBLIC SvStream& operator<<( SvStream& rOStm, const GDIMetaFile& rGDIMetaFile );
+
+	const BOOL           CreateThumbnail( sal_uInt32 nMaximumExtent, BitmapEx& rBmpEx, const BitmapEx* pOverlay = NULL, const Rectangle* pOverlayRect = NULL );
 };
 
 #endif // _SV_GDIMTF_HXX
--- sd/source/filter/eppt/eppt.cxx	2005-09-09 05:18:36 +02:00
+++ sd/source/filter/eppt/eppt.cxx	2006-02-01 18:17:44 +01:00
@@ -468,23 +468,8 @@ sal_Bool PPTWriter::ImplCreateSummaryInf
                     }
                 }
 
-                if ( ImplGetPageByIndex( 0, NORMAL ) && ImplGetPropertyValue( mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "Preview" ) ) ) )
+                if ( ImplGetPageByIndex( 0, NORMAL ) && ImplGetPropertyValue( mXPagePropSet, String( RTL_CONSTASCII_USTRINGPARAM( "PreviewBitmap" ) ) ) )
                 {
-                    sal_uInt16 nWidth = 4233;
-                    sal_uInt16 nHeight = ( (sal_uInt16)( (double)4233.0 /
-                                                (double)maDestPageSize.Width *
-                                                    (double)maDestPageSize.Height ) );
-                    aPropItem.Clear();
-                    aPropItem << (UINT32)VT_CF
-                              << (UINT32)0;
-
-                    aPropItem << (sal_uInt32)0xfffffff
-                              << (sal_uInt32)3
-                              << (sal_uInt16)8
-                              << nWidth
-                              << nHeight
-                              << (sal_uInt16)0;
-
                     ::com::sun::star::uno::Sequence<sal_uInt8> aSeq;
                     aSeq = *(::com::sun::star::uno::Sequence<sal_uInt8>*)mAny.getValue();
 
@@ -493,15 +478,19 @@ sal_Bool PPTWriter::ImplCreateSummaryInf
 
                     if ( pAry && nAryLen )
                     {
-                        if ( nAryLen < 0x20000 )    // we will not generate preview pics greater than 128kb
-                        {
-                            aPropItem.Write( pAry, nAryLen );
-                            sal_uInt32 nSize = aPropItem.Tell() - 8;
-                            aPropItem.Seek( 4 );
-                            aPropItem << nSize;
-                            aPropSet.AddProperty( PID_PREVIEW, aPropItem );
-                            aDInfo.AddSection( aPropSet );
-                        }
+						aPropItem.Clear();
+						aPropItem << (sal_uInt32)VT_CF
+								  << (sal_uInt32)0            /* size - filled later */
+								  << (sal_uInt32)0xffffffff   /* windows clipboard format */
+								  << (sal_uInt32)8;           /* CF_DIB data format DIB */
+
+						aPropItem.Write( pAry, nAryLen );
+
+						sal_uInt32 nSize = aPropItem.Tell() - 8;
+						aPropItem.Seek( 4 );
+						aPropItem << nSize;
+						aPropSet.AddProperty( PID_PREVIEW, aPropItem );
+						aDInfo.AddSection( aPropSet );
                     }
                 }
                 aDInfo.Write();
