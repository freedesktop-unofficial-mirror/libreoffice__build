--- /dev/null	2004-07-26 17:21:14.000000000 +0530
+++ sc/source/filter/qpro/qproform.cxx	2005-02-28 10:21:55.000000000 +0530
@@ -0,0 +1,538 @@
+#ifdef PCH
+#include "filt_pch.hxx"
+#endif
+                                                                                                                  
+#pragma hdrstop
+                                                                                                                  
+//------------------------------------------------------------------------
+                                                                                                                  
+#include "decl.h"
+
+#ifndef _QPRO_HXX
+#include "qpro.hxx"
+#endif
+
+#include "qproform.hxx"
+#include "compiler.hxx"
+#include "namebuff.hxx"
+#include "root.hxx"
+#include "ftools.hxx"
+#include "tool.h"
+#include <math.h>
+
+void QProToSc::ReadSRD( SingleRefData& rSRD, sal_Int8 nPage, sal_Int8 nCol, sal_uInt16 nRelBit )
+{
+
+    UINT16 nTmp = nRelBit & 0x1fff;
+    rSRD.InitAddress( ScAddress( nCol, (~nTmp + 1), 0 ) );
+    if( nRelBit & 0x4000 )
+    {
+	rSRD.nRelCol = nCol;
+	rSRD.SetColRel( TRUE );
+    }
+    else
+    {
+	rSRD.nCol = nCol;
+	rSRD.SetColRel( FALSE );
+    }
+    if( nRelBit & 0x2000 )
+    {
+	rSRD.nRelRow = (~nTmp + 1);
+	rSRD.nRelRow = (INT16)(nTmp << 3);
+	rSRD.nRelRow /= 8;
+
+	rSRD.SetRowRel( TRUE );
+    }
+    else
+    {
+	rSRD.nRow = nTmp;
+	rSRD.SetRowRel( FALSE );
+    }
+    if( nRelBit & 0x8000 )
+    {
+	rSRD.nRelTab = nPage;
+	rSRD.SetTabRel( TRUE );
+    }
+    else
+    {
+	rSRD.nTab = nPage;
+	rSRD.SetTabRel( FALSE );
+    }
+       
+}
+  
+QProToSc::QProToSc( BiffReader& rStream ) :
+    ConverterBase( 128 ),
+    aIn( rStream )
+{
+}
+
+void QProToSc::DoFunc( DefTokenId eOc, BYTE nArgs, const sal_Char* pExtString )
+{
+    TokenId  eParam[ 256 ];
+    INT32    nCount;
+    TokenId  nPush, nPush1;
+                                                                                                                 
+    BOOL bAddIn = FALSE;
+    BOOL bNeg = FALSE;
+                                                                                                                  
+    if( eOc == ocNoName )
+    {
+	bAddIn = TRUE;
+	nPush = aPool.Store( eOc );
+	aPool << nPush;
+    }
+        
+    for( nCount = 0 ; nCount < nArgs; nCount++ )
+    aStack >> eParam[ nCount ];
+                                                                                                                  
+    switch( eOc )
+    {
+	case ocIndex:
+	    nPush = eParam[ 0 ];
+	    eParam[ 0 ] = eParam[ 1 ];
+	    eParam[ 1 ] = nPush;
+	    IncToken( eParam[ 0 ] );
+	    IncToken( eParam[ 1 ] );
+	    break;
+
+	case ocIKV:
+	    nPush = eParam[ 0 ];
+	    eParam[ 0 ] = eParam[ 1 ];
+	    eParam[ 1 ] = nPush;
+	    break;
+
+	case ocGetYear:
+	    nPush = aPool.Store( 1900.0 );
+	    aPool << ocOpen;
+	    break;
+
+	case ocChose:
+	    IncToken( eParam[ nArgs- 1 ] );
+	    break;
+
+	case ocFind:
+	case ocHLookup:
+	case ocVLookup:
+	    IncToken( eParam[ 0 ] );
+	    break;
+
+	case ocMid:
+	case ocReplace:
+	    IncToken( eParam[ nArgs- 2 ] );
+	    break;
+
+	case ocZins:
+	    nArgs= 4;
+	    eParam[ 3 ] = eParam[ 0 ];      
+	    eParam[ 0 ] = eParam[ 2 ];     
+	    NegToken( eParam[ 1 ] );      
+	    eParam[ 2 ] = n0Token;      
+	    break;
+    }
+                                                                                                                 
+    if( !bAddIn )
+	aPool << eOc;
+
+    aPool << ocOpen;
+                                                                                                          
+    if( nArgs> 0 )
+    {
+	INT16 nNull = -1;       
+	INT16 nLast = nArgs- 1;
+                                                                                                  
+	if( eOc == ocRMZ )
+	{ 
+	    aPool << eParam[ 1 ] << ocSep << eParam[ 0 ] << ocSep
+		<< ocNegSub << eParam[ 2 ];
+	}
+	else
+	{       
+	    aPool << eParam[ nLast ];
+	    for( nCount = nLast - 1 ; nCount >= 0 ; nCount-- )
+	    {
+		if( nCount != nNull )
+		    aPool << ocSep << eParam[ nCount ];
+	    }
+	}
+    }
+                                                                                                
+    if( eOc == ocGetYear )
+	aPool << ocClose << ocSub << nPush;
+    else if( eOc == ocFixed )
+	aPool << ocSep << ocTrue << ocOpen << ocClose;
+    else if( eOc == ocFind )
+    {
+	nPush1 = aPool.Store();
+	DecToken( nPush1 );
+	aPool << nPush1;
+    }
+                                                                                                                 
+    aPool << ocClose;
+    aPool >> aStack;
+                                                                                                               
+    if( bNeg )
+    {
+	aPool << ocOpen << ocSub << aStack << ocClose;
+	aPool >> aStack;
+    }
+}
+
+void QProToSc::IncToken( TokenId &rParam )
+{
+    aPool << ocOpen << rParam << nAddToken;
+    rParam = aPool.Store();
+}
+                                                                                                                  
+void QProToSc::DecToken( TokenId &rParam )
+{
+    aPool << ocOpen << rParam << nSubToken;
+    rParam = aPool.Store();
+}
+                                                                                                                  
+void QProToSc::NegToken( TokenId &rParam )
+{
+    aPool << ocNegSub << ocOpen << rParam << ocClose;
+    rParam = aPool.Store();
+}
+                                                                                                                  
+BOOL Valid( sal_uInt16 nInt )
+{
+    BOOL Flag = TRUE;
+
+    if( nInt > 256 )
+	 Flag = FALSE;
+
+    return Flag;
+}
+
+ConvErr QProToSc::Convert( const ScTokenArray*& rpErg, sal_uInt16 nLen, const FORMULA_TYPE eFT ) 
+{
+    sal_uInt8 nFmla[ 256 ], i;
+    sal_Int8 nCol, nPage;
+    sal_uInt16 nInt, nIntCount = 0, nFloatCount = 0, nIntArray[ 256 ];
+    sal_uInt16 nNote, nRef, nRelBits;
+    TokenId nPush;
+    ComplRefData aCRD;
+    SingleRefData aSRD;
+    FUNC_TYPE eType;
+    DefTokenId eOc;
+    const sal_Char* pExtName;
+    double nFloatArray[ 256 ], nFloat;
+    BOOL nCheck;
+ 
+    aCRD.InitFlags();
+    aSRD.InitFlags();
+    aIn >> nRef;
+        
+    if( nRef < 256 )
+    { 
+	for( i=0; i < nRef; i++)
+	{
+    	    aIn >> nFmla[i];
+		
+	    if( nFmla[ i ] == 0x05 )
+	    {
+	        aIn >> nInt;
+		nIntArray[ nIntCount ] = nInt;
+		nRef-=2;
+		nIntCount++;
+	    }
+			
+	    if( nFmla[ i ] == 0x00 )
+	    {
+		aIn >> nFloat;
+		nFloatArray[ nFloatCount ] = nFloat;
+		nRef-=8;
+		nFloatCount++;
+	    }
+	}
+    }
+    else
+	return ConvErrCount;
+			
+    i = 0, nIntCount = 0;
+        
+    while( i < nRef && ( nFmla[ i ] != 0x03 ) )
+    { 
+        eType = IndexToType( nFmla[ i ] );
+    	eOc = IndexToToken( nFmla[ i ] );
+    	if( eOc == ocNoName )
+    	pExtName = GetAddInName( eOc );
+                           
+    	switch( eType )
+    	{
+            case FT_NotImpl:
+            case FT_FuncFix0: DoFunc( eOc, 0, pExtName ); break;
+            case FT_FuncFix1: DoFunc( eOc, 1, pExtName ); break;
+            case FT_FuncFix2: DoFunc( eOc, 2, pExtName ); break;
+            case FT_FuncFix3: DoFunc( eOc, 3, pExtName ); break;
+            case FT_FuncFix4: DoFunc( eOc, 4, pExtName ); break;
+
+ 	    case FT_Cref : { // Single cell reference
+		aIn >> nNote >> nCol >> nPage >> nRelBits;  
+                ReadSRD( aSRD, nPage, nCol, nRelBits );
+                aStack << aPool.Store( aSRD );
+		}
+                break;
+    
+    	    case FT_Range: { // Block reference
+		aIn >> nNote >> nCol >> nPage >> nRelBits;
+               	ReadSRD( aCRD.Ref1, nPage, nCol, nRelBits );
+               	aIn >> nCol >> nPage >> nRelBits;
+               	ReadSRD( aCRD.Ref2, nPage, nCol, nRelBits );
+               	aStack << aPool.Store( aCRD );
+		}
+               	break;
+   
+       	    case FT_FuncVar: { // Sum of a sequence of numbers
+               	sal_uInt8 nArg;
+                i++;
+                nArg = nFmla[ i ];
+               	DoFunc( eOc, nArg , pExtName );
+		}
+               	break;
+
+       	    case FT_Op: { // operators
+               	aStack >> nPush;
+               	aPool << aStack << eOc << nPush;
+               	aPool >> aStack;
+		}
+               	break; 
+                  		
+       	    case FT_Braces: 
+            	aPool << ocOpen << aStack << ocClose;
+               	aPool >> aStack;
+               	break;
+
+   	    case FT_ConstInt:{
+               	sal_uInt16 nVal;
+		nCheck = Valid( nIntCount );
+		if( !nCheck )
+	    	    return ConvErrCount;
+		nVal = nIntArray[ nIntCount ];
+                aStack << aPool.Store( ( double ) nVal );
+		nIntCount++;
+                }
+		break;
+
+	    case FT_ConstFloat:{
+		double nVal;
+		nCheck = Valid( nFloatCount );
+		if( !nCheck )
+	            return ConvErrCount;
+		nVal = nFloatArray[ nFloatCount ];
+		aStack << aPool.Store( nVal );
+		nFloatCount++;
+		}
+		break;
+     
+    	    case FT_Erref:
+   	       	aPool << ocBad;
+                aPool >> aStack;
+                break;
+
+       	    case FT_Ecref:
+                aPool << ocBad;
+                aPool >> aStack;
+                break;
+
+   	    case FT_Econstant:
+                aPool << ocBad;
+                aPool >> aStack;
+                break;
+	}
+	i++;
+    }	
+    rpErg = aPool[ aStack.Get() ];
+    return ConvOK;
+}
+
+static const struct {
+    DefTokenId nToken;
+    FUNC_TYPE   nType;
+    const sal_Char *addInName;
+} aFuncMap[] = {
+    { ocPush, FT_ConstFloat, NULL },                       
+    { ocPush, FT_Cref, NULL },                        
+    { ocPush, FT_Range, NULL },                        
+    { ocPush, FT_Return, NULL },                        
+    { ocPush, FT_Braces, NULL },                       
+    { ocPush, FT_ConstInt, NULL },                       
+    { ocPush, FT_ConstString, NULL },
+    { ocPush, FT_NOP, NULL },
+    { ocNegSub, FT_Neg, NULL },                       
+    { ocAdd, FT_Op, NULL },                           
+    { ocSub, FT_Op, NULL },                         
+    { ocMul, FT_Op, NULL },                         
+    { ocDiv, FT_Op, NULL },                         
+    { ocPow, FT_Op, NULL },                         
+    { ocEqual, FT_Op, NULL },                        
+    { ocNotEqual, FT_Op, NULL },                    
+    { ocLessEqual, FT_Op, NULL },           
+    { ocGreaterEqual, FT_Op, NULL },        
+    { ocLess, FT_Op, NULL },                
+    { ocGreater, FT_Op, NULL },             
+    { ocAnd, FT_Op, NULL },                 
+    { ocOr, FT_Op, NULL },                  
+    { ocNot, FT_FuncFix1, NULL },                 
+    { ocPush, FT_NOP, NULL }, 	// Unary plus
+    { ocNoName, FT_NotImpl, NULL }, // Address of             
+    { ocNoName, FT_NotImpl, NULL }, // Halt function              
+    { ocNoName, FT_NotImpl, NULL }, // DLL function
+    { ocNoName, FT_NotImpl, NULL }, // Extended operands             
+    { ocNoName, FT_NotImpl, NULL }, // Extended operands             
+    { ocNoName, FT_NotImpl, NULL }, // Reserved              
+    { ocNoName, FT_NotImpl, NULL }, // Reserved             
+    { ocNoValue, FT_FuncFix0, NULL }, // NA              
+    { ocNoName, FT_FuncFix0, NULL }, // Error              
+    { ocAbs, FT_FuncFix1, NULL },                  
+    { ocInt, FT_FuncFix1, NULL },                 
+    { ocSqrt, FT_FuncFix1, NULL },                
+    { ocLog10, FT_FuncFix1, NULL },               
+    { ocLn, FT_FuncFix1, NULL },                  
+    { ocPi, FT_FuncFix0, NULL },                   
+    { ocSin, FT_FuncFix1, NULL },                   
+    { ocCos, FT_FuncFix1, NULL },                 
+    { ocTan, FT_FuncFix1, NULL },                 
+    { ocArcTan2, FT_FuncFix2, NULL },              
+    { ocArcTan, FT_FuncFix1, NULL },              
+    { ocArcSin, FT_FuncFix1, NULL },              
+    { ocArcCos, FT_FuncFix1, NULL },              
+    { ocExp, FT_FuncFix1, NULL },                  
+    { ocMod, FT_FuncFix2, NULL },    
+    { ocChose, FT_FuncVar, NULL },                
+    { ocIsNV, FT_FuncFix1, NULL },                
+    { ocIsError, FT_FuncFix1, NULL },              
+    { ocFalse, FT_FuncFix0, NULL },               
+    { ocTrue, FT_FuncFix0, NULL },                
+    { ocRandom, FT_FuncFix0, NULL },                      
+    { ocGetDate, FT_FuncFix3, NULL },                    
+    { ocGetActTime, FT_FuncFix0, NULL },          
+    { ocNoName, FT_FuncFix3, NULL },                
+    { ocNoName, FT_FuncFix3, NULL },               
+    { ocNoName, FT_FuncFix3, NULL },            
+    { ocIf, FT_FuncFix3, NULL },          
+    { ocGetDay, FT_FuncFix1, NULL },                     
+    { ocGetMonth, FT_FuncFix1, NULL },                   
+    { ocGetYear, FT_FuncFix1, NULL },                    
+    { ocRound, FT_FuncFix2, NULL },                      
+    { ocGetTime, FT_FuncFix3, NULL },                    
+    { ocGetHour, FT_FuncFix1, NULL },                    
+    { ocGetMin, FT_FuncFix1, NULL },                      
+    { ocGetSec, FT_FuncFix1, NULL },                     
+    { ocIsValue, FT_FuncFix1, NULL },                     
+    { ocIsString, FT_FuncFix1, NULL },                    
+    { ocLen, FT_FuncFix1, NULL },                        
+    { ocValue, FT_FuncFix1, NULL },    
+    { ocFixed, FT_FuncFix2, NULL },                      
+    { ocMid, FT_FuncFix3, NULL },                         
+    { ocChar, FT_FuncFix1, NULL },                        
+    { ocCode, FT_FuncFix1, NULL },                       
+    { ocFind, FT_FuncFix3, NULL },                       
+    { ocGetDateValue, FT_FuncFix1, NULL },        
+    { ocGetTimeValue, FT_FuncFix1, NULL },        
+    { ocNoName, FT_FuncFix1, "CELLPOINTER" },              
+    { ocSum, FT_FuncVar, NULL },                 
+    { ocAverage, FT_FuncVar, NULL },              
+    { ocCount, FT_FuncVar, NULL },               
+    { ocMin, FT_FuncVar, NULL },                  
+    { ocMax, FT_FuncVar, NULL },                 
+    { ocVLookup, FT_FuncFix3, NULL },             
+    { ocNBW, FT_FuncFix2, NULL },                 
+    { ocVar, FT_FuncVar, NULL },                 
+    { ocNormDist, FT_FuncVar, NULL },           
+    { ocIKV, FT_FuncFix2, NULL },                  
+    { ocHLookup, FT_FuncFix3, NULL },              
+    { ocDBSum, FT_FuncFix3, NULL },                
+    { ocDBAverage, FT_FuncFix3, NULL },           
+    { ocDBCount, FT_FuncFix3, NULL },             
+    { ocDBMin, FT_FuncFix3, NULL },                
+    { ocDBMax, FT_FuncFix3, NULL }, 
+    { ocDBVar, FT_FuncFix3, NULL },               
+    { ocDBStdDev, FT_FuncFix3, NULL },            
+    { ocIndex, FT_FuncFix3, NULL },               
+    { ocColumns, FT_FuncFix1, NULL },             
+    { ocRows, FT_FuncFix1, NULL },                 
+    { ocRept, FT_FuncFix2, NULL },                 
+    { ocUpper, FT_FuncFix1, NULL },               
+    { ocLower, FT_FuncFix1, NULL },               
+    { ocLeft, FT_FuncFix2, NULL },                
+    { ocRight, FT_FuncFix2, NULL },               
+    { ocReplace, FT_FuncFix4, NULL },              
+    { ocPropper, FT_FuncFix1, NULL },              
+    { ocCell, FT_FuncFix1, "CELL" },              
+    { ocTrim, FT_FuncFix1, NULL },                
+    { ocClean, FT_FuncFix1, NULL },               
+    { ocNoName, FT_FuncFix1, "F" },               
+    { ocNoName, FT_FuncFix1, "W" },                 
+    { ocExact, FT_FuncFix2, NULL },               
+    { ocNoName, FT_NotImpl, NULL }, // Call()               
+    { ocIndirect, FT_FuncFix1, NULL },             
+    { ocZins, FT_FuncFix3, "RATE" }, // Interest               
+    { ocNoName, FT_FuncFix1, "TERM" },              
+    { ocNoName, FT_FuncFix1, "CTERM" },              
+    { ocLIA, FT_FuncFix3, NULL },
+    { ocDIA, FT_FuncFix4, NULL },                  
+    { ocGDA, FT_FuncFix4, NULL },                 
+    { ocStDevP, FT_FuncVar,NULL },         
+    { ocVarP, FT_FuncVar, NULL },          
+    { ocDBStdDevP, FT_FuncVar, NULL },              
+    { ocDBVarP, FT_FuncVar, NULL },              
+    { ocBW, FT_FuncFix3, NULL },              
+    { ocRMZ, FT_FuncFix3, NULL },              
+    { ocZW, FT_FuncFix3, NULL },              
+    { ocNoName, FT_NotImpl, "NPER" },              
+    { ocNoName, FT_NotImpl, "IRATE" },              
+    { ocNoName, FT_NotImpl, "IPAYMT" },              
+    { ocNoName, FT_NotImpl, "PPAYMT" },              
+    { ocSumProduct, FT_FuncVar, "SUMPRODUCT" },              
+    { ocNoName, FT_NotImpl, "MEMAVAIL" }, // Functions pertaining to QPro.             
+    { ocNoName, FT_NotImpl, "MEMEMSAVAIL" },              
+    { ocNoName, FT_NotImpl, "FILEEXISTS" },              
+    { ocCurrent, FT_FuncFix0, "CURVALUE" },              
+    { ocDeg, FT_FuncFix1, "DEGREES" },              
+    { ocRad, FT_FuncFix1, "RADIANS" },              
+    { ocNoName, FT_NotImpl, "HEXTONUM" }, // hexadecimal to decimal             
+    { ocNoName, FT_NotImpl, "NUMTOHEX" }, // decimal to hexadecimal             
+    { ocGetActDate, FT_FuncFix0, "TODAY" },              
+    { ocNBW, FT_FuncFix2, NULL },   
+    { ocNoName, FT_NotImpl, "CELLINDEX2D" }, 
+    { ocNoName, FT_NotImpl, "VERSION" }, 
+    { ocNoName, FT_NotImpl, NULL }, // 146 - 153 opcodes do not represent any function. 
+    { ocNoName, FT_NotImpl, NULL }, // 147
+    { ocNoName, FT_NotImpl, NULL }, // 148
+    { ocNoName, FT_NotImpl, NULL }, // 149
+    { ocNoName, FT_NotImpl, NULL }, // 150
+    { ocNoName, FT_NotImpl, NULL }, // 151
+    { ocNoName, FT_NotImpl, NULL }, // 152
+    { ocNoName, FT_NotImpl, NULL }, // 153
+    { ocNoName, FT_FuncFix1,"SHEETS" }, 
+    { ocNoName, FT_NotImpl, NULL }, // 155 - opcodes do not represent any function.
+    { ocNoName, FT_NotImpl, NULL }, // 156 
+    { ocIndex, FT_FuncFix4, "INDEX3D" },
+    { ocNoName, FT_NotImpl, "CELLINDEX3D" }, 
+    { ocNoName, FT_NotImpl, "PROPERTY" }, // Gives the property of the particular object
+    { ocNoName, FT_NotImpl, "DDELINK" },  // Dynamic Data Exchange Link
+    { ocNoName, FT_NotImpl, "COMMAND" }   // gives properties of DOS menus
+};
+
+const int nIndexCount = sizeof( aFuncMap ) / sizeof( aFuncMap[ 0 ] );
+
+DefTokenId QProToSc::IndexToToken( sal_uInt16 nIndex )
+{
+    if( nIndex <= nIndexCount )
+    	return aFuncMap[ nIndex ].nToken;
+}
+                                                                                                                  
+FUNC_TYPE QProToSc::IndexToType( sal_uInt8 nIndex )
+{
+    if( nIndex <= nIndexCount )	
+    	return aFuncMap[ nIndex ].nType;
+}
+
+const sal_Char* QProToSc::GetAddInName( const UINT8 nIndex )
+{
+    if( nIndex <= nIndexCount )
+	return aFuncMap[ nIndex ].addInName;
+}
