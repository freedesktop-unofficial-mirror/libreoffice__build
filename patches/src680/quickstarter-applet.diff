--- /dev/null	2005-09-21 14:49:37.496144500 +0530
+++ eggtray/prj/build.lst	2005-10-14 14:48:50.000000000 +0530
@@ -0,0 +1,2 @@
+eg  eggtray   :  NULL
+eg	eggtray\source			    nmake	-	u	eg_src NULL
--- /dev/null	2005-09-21 14:49:37.496144500 +0530
+++ eggtray/prj/d.lst	2005-10-14 15:55:07.000000000 +0530
@@ -0,0 +1,3 @@
+hedabu: ..\inc\eggtrayicon.h %_DEST%\inc%_EXT%\eggtray\eggtrayicon.h
+
+..\%__SRC%\lib\lib*.* %_DEST%\lib%_EXT%\lib*.*
--- /dev/null	2005-09-21 14:49:37.496144500 +0530
+++ eggtray/inc/eggtrayicon.h	2005-10-05 13:42:52.000000000 +0530
@@ -0,0 +1,80 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/* eggtrayicon.h
+ * Copyright (C) 2002 Anders Carlsson <andersca@gnu.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __EGG_TRAY_ICON_H__
+#define __EGG_TRAY_ICON_H__
+
+#include <gtk/gtkplug.h>
+#ifdef GDK_WINDOWING_X11
+#include <gdk/gdkx.h>
+#endif
+
+G_BEGIN_DECLS
+
+#define EGG_TYPE_TRAY_ICON		(egg_tray_icon_get_type ())
+#define EGG_TRAY_ICON(obj)		(G_TYPE_CHECK_INSTANCE_CAST ((obj), EGG_TYPE_TRAY_ICON, EggTrayIcon))
+#define EGG_TRAY_ICON_CLASS(klass)	(G_TYPE_CHECK_CLASS_CAST ((klass), EGG_TYPE_TRAY_ICON, EggTrayIconClass))
+#define EGG_IS_TRAY_ICON(obj)		(G_TYPE_CHECK_INSTANCE_TYPE ((obj), EGG_TYPE_TRAY_ICON))
+#define EGG_IS_TRAY_ICON_CLASS(klass)	(G_TYPE_CHECK_CLASS_TYPE ((klass), EGG_TYPE_TRAY_ICON))
+#define EGG_TRAY_ICON_GET_CLASS(obj)	(G_TYPE_INSTANCE_GET_CLASS ((obj), EGG_TYPE_TRAY_ICON, EggTrayIconClass))
+	
+typedef struct _EggTrayIcon	  EggTrayIcon;
+typedef struct _EggTrayIconClass  EggTrayIconClass;
+
+struct _EggTrayIcon
+{
+  GtkPlug parent_instance;
+
+  guint stamp;
+  
+#ifdef GDK_WINDOWING_X11
+  Atom selection_atom;
+  Atom manager_atom;
+  Atom system_tray_opcode_atom;
+  Atom orientation_atom;
+  Window manager_window;
+#endif
+  GtkOrientation orientation;
+};
+
+struct _EggTrayIconClass
+{
+  GtkPlugClass parent_class;
+};
+
+GType        egg_tray_icon_get_type       (void);
+
+EggTrayIcon *egg_tray_icon_new_for_screen (GdkScreen   *screen,
+					   const gchar *name);
+
+EggTrayIcon *egg_tray_icon_new            (const gchar *name);
+
+guint        egg_tray_icon_send_message   (EggTrayIcon *icon,
+					   gint         timeout,
+					   const char  *message,
+					   gint         len);
+void         egg_tray_icon_cancel_message (EggTrayIcon *icon,
+					   guint        id);
+
+GtkOrientation egg_tray_icon_get_orientation (EggTrayIcon *icon);
+					    
+G_END_DECLS
+
+#endif /* __EGG_TRAY_ICON_H__ */
--- /dev/null	2005-09-21 14:49:37.496144500 +0530
+++ eggtray/source/eggtrayicon.c	2005-10-05 13:45:57.000000000 +0530
@@ -0,0 +1,514 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
+/* eggtrayicon.c
+ * Copyright (C) 2002 Anders Carlsson <andersca@gnu.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+//#include <config.h>
+#include <string.h>
+#include <libintl.h>
+
+#include "eggtrayicon.h"
+
+#include <gdkconfig.h>
+#if defined (GDK_WINDOWING_X11)
+#include <gdk/gdkx.h>
+#include <X11/Xatom.h>
+#elif defined (GDK_WINDOWING_WIN32)
+#include <gdk/gdkwin32.h>
+#endif
+
+#define EGG_COMPILATION
+#ifndef EGG_COMPILATION
+#ifndef _
+#define _(x) dgettext (GETTEXT_PACKAGE, x)
+#define N_(x) x
+#endif
+#else
+#define _(x) x
+#define N_(x) x
+#endif
+
+#define SYSTEM_TRAY_REQUEST_DOCK    0
+#define SYSTEM_TRAY_BEGIN_MESSAGE   1
+#define SYSTEM_TRAY_CANCEL_MESSAGE  2
+
+#define SYSTEM_TRAY_ORIENTATION_HORZ 0
+#define SYSTEM_TRAY_ORIENTATION_VERT 1
+
+enum {
+  PROP_0,
+  PROP_ORIENTATION
+};
+         
+static GtkPlugClass *parent_class = NULL;
+
+static void egg_tray_icon_init (EggTrayIcon *icon);
+static void egg_tray_icon_class_init (EggTrayIconClass *klass);
+
+static void egg_tray_icon_get_property (GObject    *object,
+					guint       prop_id,
+					GValue     *value,
+					GParamSpec *pspec);
+
+static void egg_tray_icon_realize   (GtkWidget *widget);
+static void egg_tray_icon_unrealize (GtkWidget *widget);
+
+#ifdef GDK_WINDOWING_X11
+static void egg_tray_icon_update_manager_window    (EggTrayIcon *icon,
+						    gboolean     dock_if_realized);
+static void egg_tray_icon_manager_window_destroyed (EggTrayIcon *icon);
+#endif
+
+GType
+egg_tray_icon_get_type (void)
+{
+  static GType our_type = 0;
+
+  if (our_type == 0)
+    {
+      static const GTypeInfo our_info =
+      {
+	sizeof (EggTrayIconClass),
+	(GBaseInitFunc) NULL,
+	(GBaseFinalizeFunc) NULL,
+	(GClassInitFunc) egg_tray_icon_class_init,
+	NULL, /* class_finalize */
+	NULL, /* class_data */
+	sizeof (EggTrayIcon),
+	0,    /* n_preallocs */
+	(GInstanceInitFunc) egg_tray_icon_init
+      };
+
+      our_type = g_type_register_static (GTK_TYPE_PLUG, "EggTrayIcon", &our_info, 0);
+    }
+
+  return our_type;
+}
+
+static void
+egg_tray_icon_init (EggTrayIcon *icon)
+{
+  icon->stamp = 1;
+  icon->orientation = GTK_ORIENTATION_HORIZONTAL;
+  
+  gtk_widget_add_events (GTK_WIDGET (icon), GDK_PROPERTY_CHANGE_MASK);
+}
+
+static void
+egg_tray_icon_class_init (EggTrayIconClass *klass)
+{
+  GObjectClass *gobject_class = (GObjectClass *)klass;
+  GtkWidgetClass *widget_class = (GtkWidgetClass *)klass;
+
+  parent_class = g_type_class_peek_parent (klass);
+
+  gobject_class->get_property = egg_tray_icon_get_property;
+
+  widget_class->realize   = egg_tray_icon_realize;
+  widget_class->unrealize = egg_tray_icon_unrealize;
+
+  g_object_class_install_property (gobject_class,
+				   PROP_ORIENTATION,
+				   g_param_spec_enum ("orientation",
+						      _("Orientation"),
+						      _("The orientation of the tray."),
+						      GTK_TYPE_ORIENTATION,
+						      GTK_ORIENTATION_HORIZONTAL,
+						      G_PARAM_READABLE));
+
+#if defined (GDK_WINDOWING_X11)
+  /* Nothing */
+#elif defined (GDK_WINDOWING_WIN32)
+  g_warning ("Port eggtrayicon to Win32");
+#else
+  g_warning ("Port eggtrayicon to this GTK+ backend");
+#endif
+}
+
+static void
+egg_tray_icon_get_property (GObject    *object,
+			    guint       prop_id,
+			    GValue     *value,
+			    GParamSpec *pspec)
+{
+  EggTrayIcon *icon = EGG_TRAY_ICON (object);
+
+  switch (prop_id)
+    {
+    case PROP_ORIENTATION:
+      g_value_set_enum (value, icon->orientation);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+#ifdef GDK_WINDOWING_X11
+
+static void
+egg_tray_icon_get_orientation_property (EggTrayIcon *icon)
+{
+  Display *xdisplay;
+  Atom type;
+  int format;
+  union {
+	gulong *prop;
+	guchar *prop_ch;
+  } prop = { NULL };
+  gulong nitems;
+  gulong bytes_after;
+  int error, result;
+
+  g_assert (icon->manager_window != None);
+  
+  xdisplay = GDK_DISPLAY_XDISPLAY (gtk_widget_get_display (GTK_WIDGET (icon)));
+
+  gdk_error_trap_push ();
+  type = None;
+  result = XGetWindowProperty (xdisplay,
+			       icon->manager_window,
+			       icon->orientation_atom,
+			       0, G_MAXLONG, FALSE,
+			       XA_CARDINAL,
+			       &type, &format, &nitems,
+			       &bytes_after, &(prop.prop_ch));
+  error = gdk_error_trap_pop ();
+
+  if (error || result != Success)
+    return;
+
+  if (type == XA_CARDINAL)
+    {
+      GtkOrientation orientation;
+
+      orientation = (prop.prop [0] == SYSTEM_TRAY_ORIENTATION_HORZ) ?
+					GTK_ORIENTATION_HORIZONTAL :
+					GTK_ORIENTATION_VERTICAL;
+
+      if (icon->orientation != orientation)
+	{
+	  icon->orientation = orientation;
+
+	  g_object_notify (G_OBJECT (icon), "orientation");
+	}
+    }
+
+  if (prop.prop)
+    XFree (prop.prop);
+}
+
+static GdkFilterReturn
+egg_tray_icon_manager_filter (GdkXEvent *xevent, GdkEvent *event, gpointer user_data)
+{
+  EggTrayIcon *icon = user_data;
+  XEvent *xev = (XEvent *)xevent;
+
+  if (xev->xany.type == ClientMessage &&
+      xev->xclient.message_type == icon->manager_atom &&
+      xev->xclient.data.l[1] == icon->selection_atom)
+    {
+      egg_tray_icon_update_manager_window (icon, TRUE);
+    }
+  else if (xev->xany.window == icon->manager_window)
+    {
+      if (xev->xany.type == PropertyNotify &&
+	  xev->xproperty.atom == icon->orientation_atom)
+	{
+	  egg_tray_icon_get_orientation_property (icon);
+	}
+      if (xev->xany.type == DestroyNotify)
+	{
+	  egg_tray_icon_manager_window_destroyed (icon);
+	}
+    }
+  return GDK_FILTER_CONTINUE;
+}
+
+#endif  
+
+static void
+egg_tray_icon_unrealize (GtkWidget *widget)
+{
+#ifdef GDK_WINDOWING_X11
+  EggTrayIcon *icon = EGG_TRAY_ICON (widget);
+  GdkWindow *root_window;
+
+  if (icon->manager_window != None)
+    {
+      GdkWindow *gdkwin;
+
+      gdkwin = gdk_window_lookup_for_display (gtk_widget_get_display (widget),
+                                              icon->manager_window);
+
+      gdk_window_remove_filter (gdkwin, egg_tray_icon_manager_filter, icon);
+    }
+
+  root_window = gdk_screen_get_root_window (gtk_widget_get_screen (widget));
+
+  gdk_window_remove_filter (root_window, egg_tray_icon_manager_filter, icon);
+
+  if (GTK_WIDGET_CLASS (parent_class)->unrealize)
+    (* GTK_WIDGET_CLASS (parent_class)->unrealize) (widget);
+#endif
+}
+
+#ifdef GDK_WINDOWING_X11
+
+static void
+egg_tray_icon_send_manager_message (EggTrayIcon *icon,
+				    long         message,
+				    Window       window,
+				    long         data1,
+				    long         data2,
+				    long         data3)
+{
+  XClientMessageEvent ev;
+  Display *display;
+  
+  ev.type = ClientMessage;
+  ev.window = window;
+  ev.message_type = icon->system_tray_opcode_atom;
+  ev.format = 32;
+  ev.data.l[0] = gdk_x11_get_server_time (GTK_WIDGET (icon)->window);
+  ev.data.l[1] = message;
+  ev.data.l[2] = data1;
+  ev.data.l[3] = data2;
+  ev.data.l[4] = data3;
+
+  display = GDK_DISPLAY_XDISPLAY (gtk_widget_get_display (GTK_WIDGET (icon)));
+  
+  gdk_error_trap_push ();
+  XSendEvent (display,
+	      icon->manager_window, False, NoEventMask, (XEvent *)&ev);
+  XSync (display, False);
+  gdk_error_trap_pop ();
+}
+
+static void
+egg_tray_icon_send_dock_request (EggTrayIcon *icon)
+{
+  egg_tray_icon_send_manager_message (icon,
+				      SYSTEM_TRAY_REQUEST_DOCK,
+				      icon->manager_window,
+				      gtk_plug_get_id (GTK_PLUG (icon)),
+				      0, 0);
+}
+
+static void
+egg_tray_icon_update_manager_window (EggTrayIcon *icon,
+				     gboolean     dock_if_realized)
+{
+  Display *xdisplay;
+  
+  if (icon->manager_window != None)
+    return;
+
+  xdisplay = GDK_DISPLAY_XDISPLAY (gtk_widget_get_display (GTK_WIDGET (icon)));
+  
+  XGrabServer (xdisplay);
+  
+  icon->manager_window = XGetSelectionOwner (xdisplay,
+					     icon->selection_atom);
+
+  if (icon->manager_window != None)
+    XSelectInput (xdisplay,
+		  icon->manager_window, StructureNotifyMask|PropertyChangeMask);
+
+  XUngrabServer (xdisplay);
+  XFlush (xdisplay);
+  
+  if (icon->manager_window != None)
+    {
+      GdkWindow *gdkwin;
+
+      gdkwin = gdk_window_lookup_for_display (gtk_widget_get_display (GTK_WIDGET (icon)),
+					      icon->manager_window);
+      
+      gdk_window_add_filter (gdkwin, egg_tray_icon_manager_filter, icon);
+
+      if (dock_if_realized && GTK_WIDGET_REALIZED (icon))
+	egg_tray_icon_send_dock_request (icon);
+
+      egg_tray_icon_get_orientation_property (icon);
+    }
+}
+
+static void
+egg_tray_icon_manager_window_destroyed (EggTrayIcon *icon)
+{
+  GdkWindow *gdkwin;
+  
+  g_return_if_fail (icon->manager_window != None);
+
+  gdkwin = gdk_window_lookup_for_display (gtk_widget_get_display (GTK_WIDGET (icon)),
+					  icon->manager_window);
+      
+  gdk_window_remove_filter (gdkwin, egg_tray_icon_manager_filter, icon);
+
+  icon->manager_window = None;
+
+  egg_tray_icon_update_manager_window (icon, TRUE);
+}
+
+#endif
+
+static void
+egg_tray_icon_realize (GtkWidget *widget)
+{
+#ifdef GDK_WINDOWING_X11
+  EggTrayIcon *icon = EGG_TRAY_ICON (widget);
+  GdkScreen *screen;
+  GdkDisplay *display;
+  Display *xdisplay;
+  char buffer[256];
+  GdkWindow *root_window;
+
+  if (GTK_WIDGET_CLASS (parent_class)->realize)
+    GTK_WIDGET_CLASS (parent_class)->realize (widget);
+
+  screen = gtk_widget_get_screen (widget);
+  display = gdk_screen_get_display (screen);
+  xdisplay = gdk_x11_display_get_xdisplay (display);
+
+  /* Now see if there's a manager window around */
+  g_snprintf (buffer, sizeof (buffer),
+	      "_NET_SYSTEM_TRAY_S%d",
+	      gdk_screen_get_number (screen));
+
+  icon->selection_atom = XInternAtom (xdisplay, buffer, False);
+  
+  icon->manager_atom = XInternAtom (xdisplay, "MANAGER", False);
+  
+  icon->system_tray_opcode_atom = XInternAtom (xdisplay,
+						   "_NET_SYSTEM_TRAY_OPCODE",
+						   False);
+
+  icon->orientation_atom = XInternAtom (xdisplay,
+					"_NET_SYSTEM_TRAY_ORIENTATION",
+					False);
+
+  egg_tray_icon_update_manager_window (icon, FALSE);
+  egg_tray_icon_send_dock_request (icon);
+
+  root_window = gdk_screen_get_root_window (screen);
+  
+  /* Add a root window filter so that we get changes on MANAGER */
+  gdk_window_add_filter (root_window,
+			 egg_tray_icon_manager_filter, icon);
+#endif
+}
+
+EggTrayIcon *
+egg_tray_icon_new_for_screen (GdkScreen *screen, const char *name)
+{
+  g_return_val_if_fail (GDK_IS_SCREEN (screen), NULL);
+
+  return g_object_new (EGG_TYPE_TRAY_ICON, "screen", screen, "title", name, NULL);
+}
+
+EggTrayIcon*
+egg_tray_icon_new (const gchar *name)
+{
+  return g_object_new (EGG_TYPE_TRAY_ICON, "title", name, NULL);
+}
+
+guint
+egg_tray_icon_send_message (EggTrayIcon *icon,
+			    gint         timeout,
+			    const gchar *message,
+			    gint         len)
+{
+  guint stamp;
+  
+  g_return_val_if_fail (EGG_IS_TRAY_ICON (icon), 0);
+  g_return_val_if_fail (timeout >= 0, 0);
+  g_return_val_if_fail (message != NULL, 0);
+		     
+#ifdef GDK_WINDOWING_X11
+  if (icon->manager_window == None)
+    return 0;
+#endif
+
+  if (len < 0)
+    len = strlen (message);
+
+  stamp = icon->stamp++;
+  
+#ifdef GDK_WINDOWING_X11
+  /* Get ready to send the message */
+  egg_tray_icon_send_manager_message (icon, SYSTEM_TRAY_BEGIN_MESSAGE,
+				      (Window)gtk_plug_get_id (GTK_PLUG (icon)),
+				      timeout, len, stamp);
+
+  /* Now to send the actual message */
+  gdk_error_trap_push ();
+  while (len > 0)
+    {
+      XClientMessageEvent ev;
+      Display *xdisplay;
+
+      xdisplay = GDK_DISPLAY_XDISPLAY (gtk_widget_get_display (GTK_WIDGET (icon)));
+      
+      ev.type = ClientMessage;
+      ev.window = (Window)gtk_plug_get_id (GTK_PLUG (icon));
+      ev.format = 8;
+      ev.message_type = XInternAtom (xdisplay,
+				     "_NET_SYSTEM_TRAY_MESSAGE_DATA", False);
+      if (len > 20)
+	{
+	  memcpy (&ev.data, message, 20);
+	  len -= 20;
+	  message += 20;
+	}
+      else
+	{
+	  memcpy (&ev.data, message, len);
+	  len = 0;
+	}
+
+      XSendEvent (xdisplay,
+		  icon->manager_window, False, StructureNotifyMask, (XEvent *)&ev);
+      XSync (xdisplay, False);
+    }
+  gdk_error_trap_pop ();
+#endif
+
+  return stamp;
+}
+
+void
+egg_tray_icon_cancel_message (EggTrayIcon *icon,
+			      guint        id)
+{
+  g_return_if_fail (EGG_IS_TRAY_ICON (icon));
+  g_return_if_fail (id > 0);
+#ifdef GDK_WINDOWING_X11  
+  egg_tray_icon_send_manager_message (icon, SYSTEM_TRAY_CANCEL_MESSAGE,
+				      (Window)gtk_plug_get_id (GTK_PLUG (icon)),
+				      id, 0, 0);
+#endif
+}
+
+GtkOrientation
+egg_tray_icon_get_orientation (EggTrayIcon *icon)
+{
+  g_return_val_if_fail (EGG_IS_TRAY_ICON (icon), GTK_ORIENTATION_HORIZONTAL);
+
+  return icon->orientation;
+}
--- /dev/null	2005-09-21 14:49:37.496144500 +0530
+++ eggtray/source/makefile.mk	2005-10-14 15:55:26.000000000 +0530
@@ -0,0 +1,26 @@
+
+PRJ=..
+PRJNAME=eggtray
+TARGET=eggtray
+
+
+# --- Settings ----------------------------------
+
+.INCLUDE : settings.mk
+PKGCONFIG_MODULES=gtk+-2.0
+.INCLUDE: pkg_config.mk
+CFLAGS+=$(PKGCONFIG_CFLAGS)
+
+# --- Files -------------------------------------
+
+SLOFILES=\
+	$(SLO)$/eggtrayicon.obj
+
+SHL1STDLIBS+=$(PKGCONFIG_LIBS)
+
+SHL1TARGET= 	eggtray$(UPD)$(DLLPOSTFIX)
+SHL1LIBS=       $(SLB)$/eggtray.lib
+
+# --- Targets ----------------------------------
+
+.INCLUDE : target.mk
--- scp2/source/ooo/file_library_ooo.scp	2005-09-21 16:59:29.000000000 +0530
+++ scp2/source/ooo/file_library_ooo.scp	2005-10-14 15:40:03.000000000 +0530
@@ -482,6 +482,15 @@ End
 
 #endif
 
+#ifdef UNX
+File gid_File_Lib_Egg_Tray
+ TXT_FILE_BODY;
+ Styles = (PACKED);
+ Dir = gid_Dir_Program;
+ Name = STRING(CONCAT4(libeggtray,OFFICEUPD,DLLSUFFIX,UNXSUFFIX));
+End
+#endif
+
 STD_UNO_LIB_FILE_PATCH( gid_File_Lib_Dba, dba)
 
 STD_UNO_LIB_FILE( gid_File_Lib_Dbacfg, dbacfg)
--- solenv/inc/libs.mk	2005-08-05 20:34:49.000000000 +0530
+++ solenv/inc/libs.mk	2005-10-14 15:47:46.000000000 +0530
@@ -228,6 +228,7 @@ BERKELEYCPPLIB=-ldb_cxx-4.2
 CURLLIB=-lcurl
 SFX2LIB=-lsfx$(OFFICEUPD)$(DLLPOSTFIX)
 SFXLIB=-lsfx$(OFFICEUPD)$(DLLPOSTFIX)
+EGGTRAYLIB=-leggtray$(OFFICEUPD)$(DLLPOSTFIX)
 SFXDEBUGLIB=
 FWELIB=-lfwe$(OFFICEUPD)$(DLLPOSTFIX)
 FWILIB=-lfwi$(OFFICEUPD)$(DLLPOSTFIX)
--- vcl/prj/d.lst	2005-03-10 18:45:19.000000000 +0530
+++ vcl/prj/d.lst	2005-10-14 16:01:14.000000000 +0530
@@ -113,6 +113,8 @@ hedabu: ..\inc\salotype.hxx %_DEST%\inc%
 hedabu: ..\inc\salstype.hxx %_DEST%\inc%_EXT%\vcl\salstype.hxx
 hedabu: ..\inc\salnativewidgets.hxx %_DEST%\inc%_EXT%\vcl\salnativewidgets.hxx
 hedabu: ..\unx\inc\salnativewidgets.h %_DEST%\inc%_EXT%\vcl\salnativewidgets.h
+hedabu: ..\unx\inc\prex.h %_DEST%\inc%_EXT%\vcl\prex.h
+hedabu: ..\unx\inc\postx.h %_DEST%\inc%_EXT%\vcl\postx.h
 hedabu: ..\inc\scrbar.hxx %_DEST%\inc%_EXT%\vcl\scrbar.hxx
 hedabu: ..\inc\seleng.hxx %_DEST%\inc%_EXT%\vcl\seleng.hxx
 hedabu: ..\inc\settings.hxx %_DEST%\inc%_EXT%\vcl\settings.hxx
@@ -128,6 +130,7 @@ hedabu: ..\inc\status.hxx %_DEST%\inc%_E
 hedabu: ..\inc\stdtext.hxx %_DEST%\inc%_EXT%\vcl\stdtext.hxx
 hedabu: ..\inc\sv.h %_DEST%\inc%_EXT%\vcl\sv.h
 hedabu: ..\inc\svapp.hxx %_DEST%\inc%_EXT%\vcl\svapp.hxx
+hedabu: ..\inc\svids.hrc %_DEST%\inc%_EXT%\vcl\svids.hrc
 hedabu: ..\inc\svsys.h %_DEST%\inc%_EXT%\vcl\svsys.h
 hedabu: ..\inc\symbol.hxx %_DEST%\inc%_EXT%\vcl\symbol.hxx
 hedabu: ..\inc\syschild.hxx %_DEST%\inc%_EXT%\vcl\syschild.hxx
--- sfx2/source/appl/makefile.mk	2005-01-18 21:33:45.000000000 +0530
+++ sfx2/source/appl/makefile.mk	2005-10-14 15:21:06.000000000 +0530
@@ -74,10 +74,17 @@ ENABLE_EXCEPTIONS=TRUE
 # w.g. compilerbugs
 .IF "$(GUI)"=="WNT"
 CFLAGS+=-Od
+CFLAGS+=-DENABLE_QUICKSTART_APPLET
 .ENDIF
 
 .IF "$(GUI)"=="UNX"
         CDEFS+=-DDLL_NAME=libsfx$(UPD)$(DLLPOSTFIX)$(DLLPOST)
+.IF "$(ENABLE_QUICKSTART_APPLET)"=="TRUE"
+        PKGCONFIG_MODULES=gtk+-2.0
+        .INCLUDE: pkg_config.mk
+        CFLAGS+=$(PKGCONFIG_CFLAGS)
+        CFLAGS+=-DENABLE_QUICKSTART_APPLET
+.ENDIF # "$(ENABLE_QUICKSTART_APPLET)"=="TRUE"
 .ELSE
         CDEFS+=-DDLL_NAME=sfx$(UPD)$(DLLPOSTFIX)$(DLLPOST)
 .ENDIF
@@ -123,6 +130,7 @@ SLOFILES =  \
 	$(SLO)$/helpinterceptor.obj \
 	$(SLO)$/shutdownicon.obj \
 	$(SLO)$/shutdowniconw32.obj \
+	$(SLO)$/shutdowniconunx.obj \
 	$(SLO)$/sfxpicklist.obj \
 	$(SLO)$/helpdispatch.obj \
     $(SLO)$/imestatuswindow.obj \
--- sfx2/source/appl/shutdownicon.cxx	2005-03-29 20:27:28.000000000 +0530
+++ sfx2/source/appl/shutdownicon.cxx	2005-10-14 15:35:34.000000000 +0530
@@ -152,7 +152,7 @@ public:
 
 void SAL_CALL SfxNotificationListener_Impl::dispatchFinished( const DispatchResultEvent& aEvent ) throw( RuntimeException )
 {
-#ifdef WNT
+#ifdef ENABLE_QUICKSTART_APPLET
 	ShutdownIcon::LeaveModalMode();
 #endif
 }
@@ -176,7 +176,7 @@ ShutdownIcon::ShutdownIcon( Reference< X
 
 ShutdownIcon::~ShutdownIcon()
 {
-#ifdef WNT
+#ifdef ENABLE_QUICKSTART_APPLET
     deInitSystray();
 #endif
 }
@@ -185,7 +185,8 @@ ShutdownIcon::~ShutdownIcon()
 
 void ShutdownIcon::SetAutostart( bool bActivate )
 {
-#ifdef WNT
+#ifdef ENABLE_QUICKSTART_APPLET
+
     OUString aShortcutName( RTL_CONSTASCII_USTRINGPARAM( "StarOffice 6.0" ) );
 	ResMgr* pMgr = SfxResId::GetResMgr();
     if( pMgr )
@@ -195,15 +196,20 @@ void ShutdownIcon::SetAutostart( bool bA
         aShortcutName = OUString( aRes );
     }
 
+#ifdef WNT
     aShortcutName += OUString( RTL_CONSTASCII_USTRINGPARAM( ".lnk" ) );
-
     SetAutostartW32( aShortcutName, bActivate );
+#else
+    SetAutostartUnx( bActivate );
+#endif
+
 #endif
 }
 
 bool ShutdownIcon::GetAutostart( )
 {
-#ifdef WNT
+#ifdef ENABLE_QUICKSTART_APPLET
+
     OUString aShortcutName( RTL_CONSTASCII_USTRINGPARAM( "StarOffice 6.0" ) );
 	ResMgr* pMgr = SfxResId::GetResMgr();
     if( pMgr )
@@ -212,10 +218,15 @@ bool ShutdownIcon::GetAutostart( )
         UniString aRes( SfxResId( STR_QUICKSTART_LNKNAME ) );
         aShortcutName = OUString( aRes );
     }
-    aShortcutName += OUString( RTL_CONSTASCII_USTRINGPARAM( ".lnk" ) );
 
+#ifdef WNT
+    aShortcutName += OUString( RTL_CONSTASCII_USTRINGPARAM( ".lnk" ) );
     return GetAutostartW32( aShortcutName );
 #else
+    return GetAutostartUnx();
+#endif
+
+#else
     return false;
 #endif
 }
@@ -257,7 +268,7 @@ void ShutdownIcon::FileOpen()
     if ( getInstance() && getInstance()->m_xDesktop.is() )
     {
         ::vos::OGuard aGuard( Application::GetSolarMutex() );
-#ifdef WNT
+#ifdef ENABLE_QUICKSTART_APPLET
 		EnterModalMode();
 #endif
 		// use ctor for filling up filters automatically! #89169#
@@ -383,7 +394,7 @@ void ShutdownIcon::FileOpen()
 			{
 			}
 		}
-#ifdef WNT
+#ifdef ENABLE_QUICKSTART_APPLET
 		LeaveModalMode();
 #endif
     }
@@ -421,7 +432,7 @@ void ShutdownIcon::FromTemplate()
             Reference< ::com::sun::star::frame::XNotifyingDispatch > xNotifyer( xDisp, UNO_QUERY );
             if ( xNotifyer.is() )
 			{
-#ifdef WNT
+#ifdef ENABLE_QUICKSTART_APPLET
 				EnterModalMode();
 #endif
                 xNotifyer->dispatchWithNotification( aTargetURL, aArgs, new SfxNotificationListener_Impl() );
@@ -571,8 +582,12 @@ void SAL_CALL ShutdownIcon::initialize( 
 					return;
 
 				ShutdownIcon::pShutdownIcon = this;
-#ifdef WNT
+#ifdef ENABLE_QUICKSTART_APPLET
 				initSystray();
+#else
+				// disable shutdown
+				getInstance()->SetVeto( true );
+				getInstance()->addTerminateListener();
 #endif
 			}
 			catch(const ::com::sun::star::lang::IllegalArgumentException&)
--- sfx2/source/appl/shutdownicon.hxx	2005-03-30 14:11:34.000000000 +0530
+++ sfx2/source/appl/shutdownicon.hxx	2005-10-14 15:49:09.000000000 +0530
@@ -49,6 +49,16 @@ typedef ::cppu::WeakComponentImplHelper3
 	::com::sun::star::frame::XTerminateListener,
 	::com::sun::star::lang::XServiceInfo > ShutdownIconServiceBase;
 
+#if defined(USE_APP_SHORTCUTS)
+#define WRITER_URL      "private:factory/swriter"
+#define CALC_URL        "private:factory/scalc"
+#define IMPRESS_URL     "private:factory/simpress"
+#define IMPRESS_WIZARD_URL     "private:factory/simpress?slot=10425"
+#define DRAW_URL        "private:factory/sdraw"
+#define MATH_URL        "private:factory/smath"
+#define BASE_URL        "private:factory/sdatabase?Interactive"
+#endif
+
 class ShutdownIcon :	public ShutdownIconServiceBase
 {
 		::osl::Mutex	m_aMutex;
@@ -58,16 +68,21 @@ class ShutdownIcon :	public ShutdownIcon
 
         static ShutdownIcon *pShutdownIcon; // one instance
 
-#ifdef WNT
+#ifdef ENABLE_QUICKSTART_APPLET
         void initSystray();
         void deInitSystray();
+#ifdef WNT
         static void SetAutostartW32( const ::rtl::OUString& aShortcutName, bool bActivate );
         static bool GetAutostartW32( const ::rtl::OUString& aShortcutName );
+#else
+        static void SetAutostartUnx( bool bActivate );
+        static bool GetAutostartUnx();
+#endif
 		static void EnterModalMode();
 		static void LeaveModalMode();
 
 		friend class SfxNotificationListener_Impl;
-#endif
+#endif // ENABLE_QUICKSTARTER
 
 	public:
 		ShutdownIcon( ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > aSMgr );
@@ -99,7 +114,7 @@ class ShutdownIcon :	public ShutdownIcon
         void SetVeto( bool bVeto )  { m_bVeto = bVeto;}
         bool GetVeto()              { return m_bVeto; }
 
-#ifdef WNT
+#ifdef ENABLE_QUICKSTART_APPLET
         static bool IsQuickstarterInstalled();
 #endif
 
--- sfx2/source/appl/shutdowniconw32.cxx	2005-06-21 15:16:31.000000000 +0530
+++ sfx2/source/appl/shutdowniconw32.cxx	2005-09-29 20:01:05.000000000 +0530
@@ -128,16 +128,6 @@ using namespace ::osl;
 #define IDM_UNINSTALL               11
 
 
-#if defined(USE_APP_SHORTCUTS)
-#define WRITER_URL      "private:factory/swriter"
-#define CALC_URL        "private:factory/scalc"
-#define IMPRESS_URL     "private:factory/simpress"
-#define IMPRESS_WIZARD_URL     "private:factory/simpress?slot=10425"
-#define DRAW_URL        "private:factory/sdraw"
-#define MATH_URL        "private:factory/smath"
-#define BASE_URL        "private:factory/sdatabase?Interactive"
-#endif
-
 #define ICON_SO_DEFAULT 				1
 #define ICON_TEXT_DOCUMENT				2
 #define ICON_TEXT_TEMPLATE				3
--- sfx2/util/makefile.mk	2005-02-21 22:39:33.000000000 +0530
+++ sfx2/util/makefile.mk	2005-10-17 13:53:26.000000000 +0530
@@ -75,6 +75,9 @@ USE_DEFFILE=TRUE
 .INCLUDE :  settings.mk
 .INCLUDE :  $(PRJ)$/util$/makefile.pmk
 
+PKGCONFIG_MODULES=gtk+-2.0
+.INCLUDE: pkg_config.mk
+
 # --- Allgemein ----------------------------------------------------
 
 LIB1TARGET= $(SLB)$/$(TARGET).lib
@@ -137,6 +140,11 @@ SHL1STDLIBS+=\
 
 .ENDIF # WNT
 
+.IF "$(GUI)"=="UNX"
+SHL1STDLIBS+=$(PKGCONFIG_LIBS) \
+		$(EGGTRAYLIB)
+.ENDIF # UNX
+
 
 .IF "$(GUI)"!="MAC"
 SHL1DEPN += $(shell $(FIND) $(SLO) -type f -name "*.OBJ" -print)
--- /dev/null	2005-09-21 14:49:37.496144500 +0530
+++ sfx2/source/appl/shutdowniconunx.cxx	2005-10-17 15:09:27.000000000 +0530
@@ -0,0 +1,403 @@
+
+#ifdef ENABLE_QUICKSTART_APPLET
+
+#define OU2A(rtlOUString)  (::rtl::OUStringToOString((rtlOUString), RTL_TEXTENCODING_ASCII_US).getStr())
+
+#ifndef _UTL_BOOTSTRAP_HXX
+#include <unotools/bootstrap.hxx>
+#endif
+
+#include <vcl/prex.h>
+#include <gtk/gtk.h>
+#include <glib.h>
+#include <eggtray/eggtrayicon.h>
+#include <vcl/postx.h>
+
+#include <unistd.h>
+
+#ifndef _SV_BITMAPEX_HXX
+#include <vcl/bitmapex.hxx>
+#endif
+#ifndef _SV_BMPACC_HXX
+#include <vcl/bmpacc.hxx>
+#endif
+#ifndef _SV_SVIDS_HRC
+#include <vcl/svids.hrc>
+#endif
+#ifndef _OSL_FILE_HXX_
+#include <osl/file.hxx>
+#endif
+#ifndef _SFXAPP_HXX
+#include "app.hxx"
+#endif
+#ifndef _SFX_APP_HRC
+#include "app.hrc"
+#endif
+#ifndef __SHUTDOWNICON_HXX__
+#define USE_APP_SHORTCUTS
+#include "shutdownicon.hxx"
+#endif
+
+using namespace ::rtl;
+using namespace ::osl;
+
+static bool bModalMode = FALSE;
+
+EggTrayIcon *tray_icon;
+GtkWidget *button, *icon_image, *menu;
+ResMgr *pVCLResMgr;
+USHORT nResMgrOffset;
+
+GdkPixbuf *writer_pixbuf, *calc_pixbuf, *impress_pixbuf, *draw_pixbuf, *template_pixbuf;
+OUString writer_label, calc_label, impress_label, draw_label;
+OUString template_label, fileopen_label, prelaunch_label, exit_label;
+OUString aWriterURL, aCalcURL, aImpressURL, aDrawURL;
+
+static void open_url_cb( GtkWidget *button, gpointer *data )
+{
+	ShutdownIcon::OpenURL( *(OUString *)data, OUString( RTL_CONSTASCII_USTRINGPARAM( "_default" ) ) );
+}
+
+static void open_file_cb( GtkWidget *button )
+{
+	if ( !bModalMode )
+		ShutdownIcon::FileOpen();
+}
+
+static void open_template_cb( GtkWidget *button )
+{
+	if ( !bModalMode )
+		ShutdownIcon::FromTemplate();
+}
+
+static void prelaunch_toggled_cb( GtkWidget *button )
+{
+	ShutdownIcon::SetAutostart( !ShutdownIcon::GetAutostart() );
+}
+
+static void exit_quickstarter_cb( GtkWidget *button, EggTrayIcon *icon )
+{
+	egg_tray_icon_cancel_message (icon, 1 );
+
+	ShutdownIcon::getInstance()->terminateDesktop();
+}
+
+static void reset_toggle_cb( GtkWidget *menu )
+{
+	gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON( button ), FALSE );
+
+	gtk_menu_popdown( GTK_MENU( menu ) );
+}
+
+static void remove_menu_item( gpointer child, gpointer menu )
+{
+	gtk_container_remove( GTK_CONTAINER( menu ), GTK_WIDGET( child ) );
+}
+
+static void populate_menu( void )
+{
+	GtkWidget *menuitem, *image;
+
+	g_list_foreach( GTK_MENU_SHELL( menu)->children,
+			remove_menu_item, menu );
+
+	image = gtk_image_new_from_pixbuf( writer_pixbuf );
+	menuitem = gtk_image_menu_item_new_with_label( OU2A( writer_label ) );
+	gtk_image_menu_item_set_image( ( GtkImageMenuItem * ) menuitem, image );
+	gtk_menu_shell_append( GTK_MENU_SHELL( menu ), menuitem );
+	g_signal_connect( menuitem, "activate", G_CALLBACK( open_url_cb ), &aWriterURL );
+
+	image = gtk_image_new_from_pixbuf( calc_pixbuf );
+	menuitem = gtk_image_menu_item_new_with_label( OU2A( calc_label ) );
+	gtk_image_menu_item_set_image( ( GtkImageMenuItem * ) menuitem, image );
+	gtk_menu_shell_append( GTK_MENU_SHELL( menu ), menuitem );
+	g_signal_connect( menuitem, "activate", G_CALLBACK( open_url_cb ), &aCalcURL );
+
+	image = gtk_image_new_from_pixbuf( impress_pixbuf );
+	menuitem = gtk_image_menu_item_new_with_label( OU2A( impress_label ) );
+	gtk_image_menu_item_set_image( ( GtkImageMenuItem * ) menuitem, image );
+	gtk_menu_shell_append( GTK_MENU_SHELL( menu ), menuitem );
+	g_signal_connect( menuitem, "activate", G_CALLBACK( open_url_cb ), &aImpressURL );
+
+	image = gtk_image_new_from_pixbuf( draw_pixbuf );
+	menuitem = gtk_image_menu_item_new_with_label( OU2A( draw_label ) );
+	gtk_image_menu_item_set_image( ( GtkImageMenuItem * ) menuitem, image );
+	gtk_menu_shell_append( GTK_MENU_SHELL( menu ), menuitem);
+	g_signal_connect( menuitem, "activate", G_CALLBACK( open_url_cb ), &aDrawURL );
+
+	image = gtk_image_new_from_pixbuf( template_pixbuf );
+	menuitem = gtk_image_menu_item_new_with_label( OU2A( template_label ) );
+	gtk_image_menu_item_set_image( ( GtkImageMenuItem * ) menuitem, image );
+	gtk_menu_shell_append(GTK_MENU_SHELL( menu ), menuitem );
+	gtk_widget_set_sensitive( menuitem, bModalMode ? FALSE : TRUE );
+	g_signal_connect( menuitem, "activate", G_CALLBACK( open_template_cb ), NULL );
+
+	menuitem = gtk_separator_menu_item_new();
+	gtk_menu_shell_append( GTK_MENU_SHELL( menu ), menuitem );
+
+	image = gtk_image_new_from_stock( GTK_STOCK_OPEN, GTK_ICON_SIZE_MENU );
+	menuitem = gtk_image_menu_item_new_with_label( OU2A( fileopen_label ) );
+	gtk_image_menu_item_set_image( ( GtkImageMenuItem * ) menuitem, image );
+	gtk_menu_shell_append( GTK_MENU_SHELL( menu ), menuitem );
+	gtk_widget_set_sensitive( menuitem, bModalMode ? FALSE : TRUE );
+	g_signal_connect( menuitem, "activate", G_CALLBACK( open_file_cb ), NULL );
+
+	menuitem = gtk_separator_menu_item_new();
+	gtk_menu_shell_append( GTK_MENU_SHELL( menu ), menuitem );
+
+	menuitem = gtk_check_menu_item_new_with_label( OU2A( prelaunch_label ) );
+	gtk_check_menu_item_set_active( ( GtkCheckMenuItem * ) menuitem,
+		ShutdownIcon::GetAutostart() );
+	gtk_menu_shell_append( GTK_MENU_SHELL( menu ), menuitem);
+	g_signal_connect( menuitem, "activate", G_CALLBACK( prelaunch_toggled_cb ), NULL );
+
+	menuitem = gtk_separator_menu_item_new();
+	gtk_menu_shell_append( GTK_MENU_SHELL( menu ), menuitem );
+
+	image = gtk_image_new_from_stock( GTK_STOCK_QUIT,  GTK_ICON_SIZE_MENU );
+	menuitem = gtk_image_menu_item_new_with_label( OU2A( exit_label ) );
+	gtk_image_menu_item_set_image( GTK_IMAGE_MENU_ITEM( menuitem ), image );
+	gtk_menu_shell_append( GTK_MENU_SHELL( menu ), menuitem );
+	gtk_widget_set_sensitive( menuitem, bModalMode ? FALSE : TRUE );
+	g_signal_connect( menuitem, "activate", G_CALLBACK( exit_quickstarter_cb ), tray_icon );
+
+	gtk_widget_show_all( menu );
+}
+
+static void display_menu_cb( GtkWidget *button )
+{
+	populate_menu();
+
+	gtk_menu_popup( GTK_MENU( menu ), NULL, NULL,
+		NULL, NULL, 0, gtk_get_current_event_time() );
+}
+
+static inline BYTE * getRow( BitmapReadAccess *pBuffer, ULONG nRow )
+{
+    if( BMP_SCANLINE_ADJUSTMENT( pBuffer->GetScanlineFormat() ) == BMP_FORMAT_TOP_DOWN )
+        return pBuffer->GetBuffer() + nRow * pBuffer->GetScanlineSize();
+    else
+        return pBuffer->GetBuffer() + ( pBuffer->Height() - nRow - 1 ) * pBuffer->GetScanlineSize();
+}
+
+static GdkPixbuf * ResIdToPixbuf( USHORT nResId )
+{
+	ResId aResId( nResMgrOffset + nResId, pVCLResMgr );
+	BitmapEx aIcon( aResId );
+	Bitmap pInSalBitmap = aIcon.GetBitmap();
+	AlphaMask pInSalAlpha = aIcon.GetAlpha();
+
+	BitmapReadAccess* pSalBitmap = pInSalBitmap.AcquireReadAccess();
+	BitmapReadAccess* pSalAlpha = pInSalAlpha.AcquireReadAccess();
+
+	g_return_val_if_fail( pSalBitmap != NULL, NULL );
+	g_return_val_if_fail( pSalAlpha != NULL, NULL );
+
+	g_return_val_if_fail( pSalBitmap->GetBitCount() == 24, NULL );
+	g_return_val_if_fail( pSalAlpha->GetBitCount() == 8, NULL );
+
+	Size aSize( pSalBitmap->Width(), pSalBitmap->Height() );
+	g_return_val_if_fail( Size( pSalAlpha->Width(), pSalAlpha->Height() ) == aSize, NULL );
+
+	int nX, nY;
+	guchar *pPixbufData = ( guchar * )g_malloc( 4 * aSize.Width() * aSize.Height() );
+	guchar *pDestData = pPixbufData;
+
+	for( nY = 0; nY < pSalBitmap->Height(); nY++ )
+	{
+		BYTE *pData = getRow( pSalBitmap, nY );
+		BYTE *pAlphaData = getRow( pSalAlpha, nY );
+
+		for( nX = 0; nX < pSalBitmap->Width(); nX++ )
+		{
+			if( pSalBitmap->GetScanlineFormat() == BMP_FORMAT_24BIT_TC_BGR )
+			{
+				pDestData[2] = *pData++;
+				pDestData[1] = *pData++;
+				pDestData[0] = *pData++;
+			}
+			else // BMP_FORMAT_24BIT_TC_RGB
+			{
+				pDestData[0] = *pData++;
+				pDestData[1] = *pData++;
+				pDestData[2] = *pData++;
+			}
+			pDestData += 3;
+			*pDestData++ = 255 - *pAlphaData++;
+		}
+	}
+
+	if( pSalBitmap )
+		pInSalBitmap.ReleaseAccess( pSalBitmap );
+	if( pSalAlpha )
+		pInSalAlpha.ReleaseAccess( pSalAlpha );
+
+	return gdk_pixbuf_new_from_data( pPixbufData,
+		GDK_COLORSPACE_RGB, TRUE, 8,
+		aSize.Width(), aSize.Height(),
+		aSize.Width() * 4,
+		(GdkPixbufDestroyNotify) g_free,
+		NULL );
+}
+
+
+void ShutdownIcon::initSystray()
+{
+	if( !g_type_from_name( "GdkDisplay" ) )
+		return;
+
+	ShutdownIcon *pShutdownIcon = ShutdownIcon::getInstance();
+
+	tray_icon = egg_tray_icon_new(
+		OU2A( pShutdownIcon->GetResString( STR_QUICKSTART_TIP ) ) );
+
+	button = gtk_toggle_button_new();
+	GtkTooltips *tooltips = gtk_tooltips_new();
+	gtk_tooltips_set_tip( GTK_TOOLTIPS( tooltips ), button, 
+		OU2A( pShutdownIcon->GetResString( STR_QUICKSTART_TIP ) ), NULL );
+
+	icon_image = gtk_image_new();
+	gtk_container_add( GTK_CONTAINER( button ), icon_image );
+
+	// Use high contrast icons where appropriate
+	if( Application::GetSettings().GetStyleSettings().GetFaceColor().IsDark() )
+		nResMgrOffset = SV_ICON_SMALL_HC_START;
+	else
+		nResMgrOffset = SV_ICON_SMALL_START;
+
+	pVCLResMgr = CREATEVERSIONRESMGR( vcl );
+
+	GdkPixbuf *buffer = ResIdToPixbuf( SV_ICON_ID_OFFICE ); 
+	gtk_image_set_from_pixbuf( GTK_IMAGE( icon_image ), buffer );
+	g_object_unref( buffer );
+
+	writer_pixbuf	= ResIdToPixbuf( SV_ICON_ID_TEXT );
+	calc_pixbuf		= ResIdToPixbuf( SV_ICON_ID_SPREADSHEET );
+	impress_pixbuf	= ResIdToPixbuf( SV_ICON_ID_PRESENTATION );
+	draw_pixbuf		= ResIdToPixbuf( SV_ICON_ID_DRAWING );
+	template_pixbuf	= ResIdToPixbuf( SV_ICON_ID_TEMPLATE );
+
+	writer_label	= pShutdownIcon->GetUrlDescription(
+		OUString( RTL_CONSTASCII_USTRINGPARAM( WRITER_URL ) ) );
+	calc_label		= pShutdownIcon->GetUrlDescription(
+		OUString( RTL_CONSTASCII_USTRINGPARAM( CALC_URL ) ) );
+	impress_label	= pShutdownIcon->GetUrlDescription(
+		OUString( RTL_CONSTASCII_USTRINGPARAM( IMPRESS_URL ) ) );
+	draw_label		= pShutdownIcon->GetUrlDescription(
+		OUString( RTL_CONSTASCII_USTRINGPARAM( DRAW_URL ) ) );
+
+	template_label	= pShutdownIcon->GetResString( STR_QUICKSTART_FROMTEMPLATE );
+	fileopen_label	= pShutdownIcon->GetResString( STR_QUICKSTART_FILEOPEN );
+	prelaunch_label	= pShutdownIcon->GetResString( STR_QUICKSTART_PRELAUNCH );
+	exit_label		= pShutdownIcon->GetResString( STR_QUICKSTART_EXIT );
+
+	aWriterURL	= OUString( RTL_CONSTASCII_USTRINGPARAM( WRITER_URL ) ) ;
+	aCalcURL	= OUString( RTL_CONSTASCII_USTRINGPARAM( CALC_URL ) ) ;
+	aImpressURL	= OUString( RTL_CONSTASCII_USTRINGPARAM( IMPRESS_URL ) ) ;
+	aDrawURL	= OUString( RTL_CONSTASCII_USTRINGPARAM( DRAW_URL ) ) ;
+
+	g_signal_connect( button, "clicked",
+		G_CALLBACK( display_menu_cb ), tray_icon );
+
+	gtk_container_add( GTK_CONTAINER( tray_icon ), button );
+	gtk_widget_show_all( GTK_WIDGET( tray_icon ) );
+
+	menu = gtk_menu_new();
+	g_signal_connect (menu, "deactivate",
+		G_CALLBACK (reset_toggle_cb), NULL);
+
+	populate_menu();
+
+	// disable shutdown
+	pShutdownIcon->SetVeto( true );
+	pShutdownIcon->addTerminateListener();
+}
+
+void ShutdownIcon::deInitSystray()
+{
+	if( !tray_icon )
+		return;
+
+	g_object_unref( writer_pixbuf );
+	g_object_unref( calc_pixbuf );
+	g_object_unref( impress_pixbuf );
+	g_object_unref( draw_pixbuf );
+	g_object_unref( template_pixbuf );
+
+	g_list_foreach( GTK_MENU_SHELL( menu)->children,
+			remove_menu_item, menu );
+	gtk_widget_destroy( menu );
+	gtk_widget_destroy( icon_image );
+	gtk_widget_destroy( button );
+	gtk_widget_destroy( GTK_WIDGET( tray_icon ) );
+}
+
+// -------------------------------
+
+void ShutdownIcon::EnterModalMode()
+{
+	bModalMode = TRUE;
+}
+
+// -------------------------------
+
+void ShutdownIcon::LeaveModalMode()
+{
+	bModalMode = FALSE;
+}
+
+// -------------------------------
+
+bool ShutdownIcon::IsQuickstarterInstalled()
+{
+	// FIXME: Windows version checks for the registry key... this is called from other places eg. appcfg.cxx
+	return true;
+}
+
+void ShutdownIcon::SetAutostartUnx( bool bActivate )
+{
+	OUString aShortcut( rtl::OStringToOUString(
+		g_get_home_dir(), osl_getThreadTextEncoding() ) ); 
+	aShortcut += OUString( RTL_CONSTASCII_USTRINGPARAM( "/ooqstart.desktop" ) );
+
+	if( bActivate && IsQuickstarterInstalled() )
+	{
+		OUString aPath;
+		::utl::Bootstrap::locateBaseInstallation(aPath);
+
+		OUString aDesktopFile;
+		::osl::File::getSystemPathFromFileURL( aPath, aDesktopFile );
+		aDesktopFile += OUString( RTL_CONSTASCII_USTRINGPARAM( "/share/xdg/qstart.desktop" ) );
+
+		// FIXME: 1) Create .desktop file and 2) link aShortcut to aDesktopFile 3) currently umask = 777 ?
+
+		symlink( OU2A(aDesktopFile), OU2A(aShortcut) );
+	}
+	else
+	{
+		OUString aShortcutUrl;
+		::osl::File::getFileURLFromSystemPath( aShortcut, aShortcutUrl );
+		::osl::File::remove( aShortcutUrl );
+	}
+}
+
+bool ShutdownIcon::GetAutostartUnx()
+{
+	OUString aShortcut( rtl::OStringToOUString(
+		g_get_home_dir(), osl_getThreadTextEncoding() ) ); 
+	aShortcut += OUString( RTL_CONSTASCII_USTRINGPARAM( "/ooqstart.desktop" ) );
+
+	OUString aShortcutUrl;
+	File::getFileURLFromSystemPath( aShortcut, aShortcutUrl );
+	File f( aShortcutUrl );
+	File::RC error = f.open( OpenFlag_Read );
+	if( error == File::E_None )
+	{
+		f.close();
+		return true;
+	}
+
+	return false;
+}
+
+#endif // ENABLE_QUICKSTART_APPLET
