diff --git ucb/source/ucp/webdav/NeonSession.cxx ucb/source/ucp/webdav/NeonSession.cxx
index 6ca255b..3f99123 100644
--- ucb/source/ucp/webdav/NeonSession.cxx
+++ ucb/source/ucp/webdav/NeonSession.cxx
@@ -1607,8 +1607,6 @@ void NeonSession::Lockit( ucb::Lock & rLock, bool bLockit )
         // Note: Neon ignores the timeout
         //theLock->timeout = rLock.timeout;
         theLock->timeout = -1;
-
-        ne_lockstore_add( s_aNeonLockStore, theLock );
     }
 
     if ( bLockit )
@@ -1617,6 +1615,8 @@ void NeonSession::Lockit( ucb::Lock & rLock, bool bLockit )
 
         if ( nRet == NE_OK )
         {
+            ne_lockstore_add( s_aNeonLockStore, theLock );
+
             uno::Sequence< rtl::OUString > aTokens( 1 );
             aTokens[0] = rtl::OUString::createFromAscii( theLock->token );
             rLock.LockTokens = aTokens;
@@ -1633,13 +1633,10 @@ void NeonSession::Lockit( ucb::Lock & rLock, bool bLockit )
                     rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "a locking error occured" ) ),
                     uno::Reference< ucb::XCommandProcessor >() );
         }
-        else
-        {
 #if OSL_DEBUG_LEVEL > 0
+        else
             fprintf( stderr, "WebDAV: failed to lock the file, status code is: %d\n", getStatusCode( m_pHttpSession ) );
 #endif
-            ne_lockstore_remove( s_aNeonLockStore, theLock );
-        }
     }
     else
     {
@@ -1654,6 +1651,8 @@ void NeonSession::Lockit( ucb::Lock & rLock, bool bLockit )
 #endif
 
             ne_unlock( m_pHttpSession, theLock );
+            ne_lockstore_remove( s_aNeonLockStore, theLock );
+            // FIXME even ne_lock_destroy( theLock )?
         }
     }
 }
