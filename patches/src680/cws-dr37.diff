Index: svtools/source/numbers/zformat.cxx
===================================================================
RCS file: /cvs/util/svtools/source/numbers/zformat.cxx,v
retrieving revision 1.62
retrieving revision 1.62.156.1
diff -u -p -u -p -r1.62 -r1.62.156.1
--- svtools/source/numbers/zformat.cxx	9 Nov 2004 11:41:16 -0000	1.62
+++ svtools/source/numbers/zformat.cxx	23 Mar 2005 18:29:20 -0000	1.62.156.1
@@ -3789,7 +3789,7 @@ void SvNumberformat::GetNumForInfo( USHO
                 while ( *p++ == '0' )
                     nAnzLeading++;
             }
-            else if (nType == NF_SYMBOLTYPE_DECSEP)
+            else if (nType == NF_SYMBOLTYPE_DECSEP || nType == NF_SYMBOLTYPE_EXP)
                 bStop = TRUE;
             i++;
         }
Index: svtools/source/numbers/zforscan.cxx
===================================================================
RCS file: /cvs/util/svtools/source/numbers/zforscan.cxx,v
retrieving revision 1.38
retrieving revision 1.37.156.2
diff -u -p -u -p -r1.38 -r1.37.156.2
--- svtools/source/numbers/zforscan.cxx	9 Jun 2005 14:31:15 -0000	1.38
+++ svtools/source/numbers/zforscan.cxx	14 Jun 2005 17:13:16 -0000	1.37.156.2
@@ -1775,21 +1775,15 @@ xub_StrLen ImpSvNumberformatScan::FinalS
 									}
 									else
 									{
-										nTypeArray[i] = NF_SYMBOLTYPE_THSEP;
-										String& rStr = sStrArray[i];
-										nPos += rStr.Len();
-										i++;
-										nThousand++;
-										while ( i < nAnzStrings &&
-											sStrArray[i] ==	sOldThousandSep )
-										{
-											nThousand++;
-                                            rStr += pFormatter->GetNumThousandSep();
-											nPos += sStrArray[i].Len();
-											nTypeArray[i] = NF_SYMBOLTYPE_EMPTY;
-											nAnzResStrings--;
-											i++;
-										}
+                                        do
+                                        {
+                                            nThousand++;
+                                            nTypeArray[i] = NF_SYMBOLTYPE_THSEP;
+                                            nPos += sStrArray[i].Len();
+                                            sStrArray[i] = pFormatter->GetNumThousandSep();
+                                            i++;
+                                        } while (i < nAnzStrings &&
+                                                sStrArray[i] == sOldThousandSep);
 									}
 								}
 								else 					// any grsep
Index: xmloff/source/chart/PropertyMap.hxx
===================================================================
RCS file: /cvs/xml/xmloff/source/chart/PropertyMap.hxx,v
retrieving revision 1.19
retrieving revision 1.19.188.1
diff -u -p -u -p -r1.19 -r1.19.188.1
--- xmloff/source/chart/PropertyMap.hxx	20 Aug 2004 08:11:53 -0000	1.19
+++ xmloff/source/chart/PropertyMap.hxx	11 May 2005 09:06:04 -0000	1.19.188.1
@@ -118,6 +118,7 @@
 #define XML_SCH_CONTEXT_MAX							( XML_SCH_CTF_START + 2 )
 #define XML_SCH_CONTEXT_STEP_MAIN					( XML_SCH_CTF_START + 3 )
 #define XML_SCH_CONTEXT_ORIGIN						( XML_SCH_CTF_START + 4 )
+#define XML_SCH_CONTEXT_LOGARITHMIC					( XML_SCH_CTF_START + 5 )
 
 #define XML_SCH_CONTEXT_SPECIAL_TICKS_MAJ_INNER		( XML_SCH_CTF_START + 10 )
 #define XML_SCH_CONTEXT_SPECIAL_TICKS_MAJ_OUTER		( XML_SCH_CTF_START + 11 )
@@ -190,7 +191,7 @@ const XMLPropertyMapEntry aXMLChartPropM
 	MAP_SPECIAL( "Marks", CHART, XML_TICK_MARKS_MAJOR_OUTER, XML_TYPE_NUMBER | MID_FLAG_MERGE_PROPERTY, TICKS_MAJ_OUTER ),			// to two bools
 	MAP_SPECIAL( "HelpMarks", CHART, XML_TICK_MARKS_MINOR_INNER, XML_TYPE_NUMBER | MID_FLAG_MERGE_PROPERTY, TICKS_MIN_INNER ),		// see above
 	MAP_SPECIAL( "HelpMarks", CHART, XML_TICK_MARKS_MINOR_OUTER, XML_TYPE_NUMBER | MID_FLAG_MERGE_PROPERTY, TICKS_MIN_OUTER ),
-	MAP_ENTRY( "Logarithmic", CHART, XML_LOGARITHMIC, XML_TYPE_BOOL ),
+	MAP_CONTEXT( "Logarithmic", CHART, XML_LOGARITHMIC, XML_TYPE_BOOL, LOGARITHMIC ),
 	MAP_CONTEXT( "Min", CHART, XML_MINIMUM, XML_TYPE_DOUBLE, MIN ),
 	MAP_CONTEXT( "Max", CHART, XML_MAXIMUM, XML_TYPE_DOUBLE, MAX ),
 	MAP_CONTEXT( "Origin", CHART, XML_ORIGIN, XML_TYPE_DOUBLE, ORIGIN ),
Index: xmloff/source/chart/PropertyMaps.cxx
===================================================================
RCS file: /cvs/xml/xmloff/source/chart/PropertyMaps.cxx,v
retrieving revision 1.40
retrieving revision 1.40.188.1
diff -u -p -u -p -r1.40 -r1.40.188.1
--- xmloff/source/chart/PropertyMaps.cxx	20 Aug 2004 08:12:06 -0000	1.40
+++ xmloff/source/chart/PropertyMaps.cxx	11 May 2005 09:06:05 -0000	1.40.188.1
@@ -304,13 +304,18 @@ void XMLChartExportPropertyMapper::Conte
                     property->mnIndex = -1;
                 else
                 {
-                    double fValue, fMainStep;
+                    double fValue, fMainStep = 0.0;
+                    sal_Bool bIsLogarithmic = sal_False;
                     (*property).maValue >>= fValue;
-                    sal_Int32 nDivisor = 0;
-                    if( rPropSet->getPropertyValue(
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "StepMain" ))) >>= fMainStep )
+                    sal_Int32 nDivisor = static_cast< sal_Int32 >( fValue );
+                    if( (rPropSet->getPropertyValue(
+                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Logarithmic" ))) >>= bIsLogarithmic) &&
+                        (rPropSet->getPropertyValue(
+                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "StepMain" ))) >>= fMainStep) )
                     {
-                        if( fValue <= fMainStep &&
+                        // for logarithmic scaling the help steps are already divisors
+                        if( ! bIsLogarithmic &&
+                            (fValue <= fMainStep) &&
                             (fValue != 0.0) )
                         {
                             nDivisor = static_cast< sal_Int32 >(
@@ -631,6 +636,9 @@ sal_Bool XMLChartImportPropertyMapper::h
             {
                 double fStepHelp = 0.0;
                 double fStepMain = 0.0;
+                sal_Bool bIsLogarithmic = sal_False;
+                bool bHelpStepValid = false;
+                bool bAutoMainStep = true;
                 sal_Int32 nDivisor = 0;
                 SvXMLUnitConverter::convertNumber( nDivisor, rValue );
 
@@ -640,22 +648,47 @@ sal_Bool XMLChartImportPropertyMapper::h
                          aIt != rProperties.end();
                          aIt++ )
                     {
-                        if( (*aIt).mnIndex != -1 &&
-                            getPropertySetMapper()->GetEntryContextId( (*aIt).mnIndex ) ==
-                            XML_SCH_CONTEXT_STEP_MAIN )
+                        if( (*aIt).mnIndex != -1 )
                         {
-                            (*aIt).maValue >>= fStepMain;
+                            switch( getPropertySetMapper()->GetEntryContextId( (*aIt).mnIndex ))
+                            {
+                                case XML_SCH_CONTEXT_STEP_MAIN:
+                                    (*aIt).maValue >>= fStepMain;
+                                    bAutoMainStep = false;
+                                    break;
+                                case XML_SCH_CONTEXT_LOGARITHMIC:
+                                    (*aIt).maValue >>= bIsLogarithmic;
+                                    break;
+                            }
                         }
                     }
 
-                    if( fStepMain != 0.0 )
+                    if( bIsLogarithmic )
+                    {
+                        fStepHelp = static_cast< double >( nDivisor );
+                        bHelpStepValid = true;
+                    }
+                    else if( !bAutoMainStep && nDivisor != 0 )
+                    {
                         fStepHelp = fStepMain / static_cast< double >( nDivisor );
+                        bHelpStepValid = true;
+                    }
+                    else
+                    {
+                        // no logarithmic scaling, the divisor is 0 (which
+                        // doesn't make sense) or we have an auto main step,
+                        // where the concrete value cannot be determined unless
+                        // the data is attached to the cahrt.  This is some more
+                        // or less unspecific point of time in the
+                        // future. Therefore we fall back to auto help step here
+                        bHelpStepValid = false;
+                    }
                 }
 
-                if( fStepHelp == 0.0 )
-                    rProperty.mnIndex = -1;
-                else
+                if( bHelpStepValid )
                     rProperty.maValue <<= fStepHelp;
+                else
+                    rProperty.mnIndex = -1;
             }
             break;
 
Index: xmloff/source/chart/transporttypes.hxx
===================================================================
RCS file: /cvs/xml/xmloff/source/chart/transporttypes.hxx,v
retrieving revision 1.5
retrieving revision 1.4.122.2
diff -u -p -u -p -r1.5 -r1.4.122.2
--- xmloff/source/chart/transporttypes.hxx	5 Jul 2005 10:56:28 -0000	1.5
+++ xmloff/source/chart/transporttypes.hxx	10 Aug 2005 16:02:59 -0000	1.4.122.2
@@ -61,9 +61,7 @@
 #ifndef SCH_XML_TRANSPORTTYPES_HXX_
 #define SCH_XML_TRANSPORTTYPES_HXX_
 
-#ifndef __SGI_STL_VECTOR
 #include <vector>
-#endif
 
 enum SchXMLCellType
 {
Index: xmloff/source/style/xmlnumfe.cxx
===================================================================
RCS file: /cvs/xml/xmloff/source/style/xmlnumfe.cxx,v
retrieving revision 1.40
retrieving revision 1.40.136.2
diff -u -p -u -p -r1.40 -r1.40.136.2
--- xmloff/source/style/xmlnumfe.cxx	9 Nov 2004 11:44:03 -0000	1.40
+++ xmloff/source/style/xmlnumfe.cxx	31 Mar 2005 12:58:22 -0000	1.40.136.2
@@ -1469,7 +1469,10 @@ void SvXMLNumFmtExport::ExportPart_Impl(
 								}
 								break;
 							case NUMBERFORMAT_SCIENTIFIC:
-								WriteScientificElement_Impl( nPrecision, nLeading, bThousand, nExpDigits );
+                                // #i43959# for scientific numbers, count all integer symbols ("0" and "#")
+                                // as integer digits: use nIntegerSymbols instead of nLeading
+                                // (use of '#' to select multiples in exponent might be added later)
+                                WriteScientificElement_Impl( nPrecision, nIntegerSymbols, bThousand, nExpDigits );
 								bAnyContent = sal_True;
 								break;
 							case NUMBERFORMAT_FRACTION:
@@ -1491,6 +1494,17 @@ void SvXMLNumFmtExport::ExportPart_Impl(
 						bNumWritten = sal_True;
 					}
 					break;
+                case NF_SYMBOLTYPE_DECSEP:
+                    if ( pElemStr && nPrecision == 0 )
+                    {
+                        //  A decimal separator after the number, without following decimal digits,
+                        //  isn't modelled as part of the number element, so it's written as text
+                        //  (the distinction between a quoted and non-quoted, locale-dependent
+                        //  character is lost here).
+
+                        AddToTextElement_Impl( *pElemStr );
+                    }
+                    break;
 				case NF_SYMBOLTYPE_DEL:
 					if ( pElemStr && *pElemStr == XubString('@') )
 					{
Index: xmloff/source/style/xmlnumfi.cxx
===================================================================
RCS file: /cvs/xml/xmloff/source/style/xmlnumfi.cxx,v
retrieving revision 1.37
retrieving revision 1.37.24.3
diff -u -p -u -p -r1.37 -r1.37.24.3
--- xmloff/source/style/xmlnumfi.cxx	8 Mar 2005 15:37:26 -0000	1.37
+++ xmloff/source/style/xmlnumfi.cxx	26 Jul 2005 14:56:12 -0000	1.37.24.3
@@ -804,8 +804,24 @@ void SvXMLNumFmtEmbeddedTextContext::End
 
 //-------------------------------------------------------------------------
 
-sal_Bool lcl_ValidChar( sal_Unicode cChar, sal_uInt16 nFormatType )
+sal_Bool lcl_ValidChar( sal_Unicode cChar, const SvXMLNumFormatContext& rParent )
 {
+    sal_uInt16 nFormatType = rParent.GetType();
+
+    if ( ( nFormatType == XML_TOK_STYLES_NUMBER_STYLE ||
+           nFormatType == XML_TOK_STYLES_CURRENCY_STYLE ||
+           nFormatType == XML_TOK_STYLES_PERCENTAGE_STYLE ) &&
+         cChar == rParent.GetLocaleData().getNumThousandSep().GetChar(0) )
+    {
+        //  #i22394# Extra occurrences of thousands separator must be quoted, so they
+        //  aren't mis-interpreted as display-factor.
+        //  This must be limited to the format types that can contain a number element,
+        //  because the same character can be a date separator that should not be quoted
+        //  in date formats.
+
+        return sal_False;   // force quotes
+    }
+
 	//	see ImpSvNumberformatScan::Next_Symbol
 	if ( cChar == ' ' ||
 		 cChar == '-' ||
@@ -830,22 +846,22 @@ sal_Bool lcl_ValidChar( sal_Unicode cCha
 	return sal_False;
 }
 
-void lcl_EnquoteIfNecessary( rtl::OUStringBuffer& rContent, sal_uInt16 nFormatType )
+void lcl_EnquoteIfNecessary( rtl::OUStringBuffer& rContent, const SvXMLNumFormatContext& rParent )
 {
 	sal_Bool bQuote = sal_True;
 	sal_Int32 nLength = rContent.getLength();
 	
 	if ( ( nLength == 1 &&
-			lcl_ValidChar( rContent.charAt(0), nFormatType ) ) ||
+			lcl_ValidChar( rContent.charAt(0), rParent ) ) ||
 		 ( nLength == 2 &&
-		 	lcl_ValidChar( rContent.charAt(0), nFormatType ) &&
+		 	lcl_ValidChar( rContent.charAt(0), rParent ) &&
 		 	rContent.charAt(1) == ' ' ) )
 	{
 		//	don't quote single separator characters like space or percent,
 		//	or separator characters followed by space (used in date formats)
 		bQuote = sal_False;
 	}
-	else if ( nFormatType == XML_TOK_STYLES_PERCENTAGE_STYLE && nLength > 1 )
+	else if ( rParent.GetType() == XML_TOK_STYLES_PERCENTAGE_STYLE && nLength > 1 )
 	{
 		//	the percent character in percentage styles must be left out of quoting
 		//	(one occurence is enough even if there are several percent characters in the string)
@@ -856,7 +872,7 @@ void lcl_EnquoteIfNecessary( rtl::OUStri
 		{
 			if ( nPos + 1 < nLength )
 			{
-				if ( nPos + 2 == nLength && lcl_ValidChar( rContent.charAt(nPos + 1), nFormatType ) )
+				if ( nPos + 2 == nLength && lcl_ValidChar( rContent.charAt(nPos + 1), rParent ) )
 				{
 					//	single character that doesn't need quoting
 				}
@@ -869,7 +885,7 @@ void lcl_EnquoteIfNecessary( rtl::OUStri
 			}
 			if ( nPos > 0 )
 			{
-				if ( nPos == 1 && lcl_ValidChar( rContent.charAt(0), nFormatType ) )
+				if ( nPos == 1 && lcl_ValidChar( rContent.charAt(0), rParent ) )
 				{
 					//	single character that doesn't need quoting
 				}
@@ -1061,7 +1077,7 @@ void SvXMLNumFmtElementContext::EndEleme
 			}
 			if ( aContent.getLength() )
 			{
-				lcl_EnquoteIfNecessary( aContent, rParent.GetType() );
+				lcl_EnquoteIfNecessary( aContent, rParent );
 				rParent.AddToCode( aContent.makeStringAndClear() );
 			}
 			break;
@@ -1534,7 +1550,7 @@ sal_Int32 SvXMLNumFormatContext::Private
 
 sal_Int32 SvXMLNumFormatContext::CreateAndInsert( com::sun::star::uno::Reference< com::sun::star::util::XNumberFormatsSupplier >& xFormatsSupplier )
 {
-    if (!nKey > -1)
+    if (nKey <= -1)
     {
         SvNumberFormatter* pFormatter = NULL;
 	    SvNumberFormatsSupplierObj* pObj =
@@ -1843,6 +1859,14 @@ void SvXMLNumFormatContext::AddNumber( c
 	pFormatter->GenerateFormat( aNumStr, nStdIndex, nFormatLang,
 								bGrouping, sal_False, nGenPrec, nLeading );
 
+    if ( rInfo.nExpDigits >= 0 && nLeading == 0 && !bGrouping && nEmbeddedCount == 0 )
+    {
+        // #i43959# For scientific numbers, "#" in the integer part forces a digit,
+        // so it has to be removed if nLeading is 0 (".00E+0", not "#.00E+0").
+
+        aNumStr.EraseLeadingChars( (sal_Unicode)'#' );
+    }
+
 	if ( nEmbeddedCount )
 	{
 		//	insert embedded strings into number string
Index: sch/source/core/chaxis.cxx
===================================================================
RCS file: /cvs/graphics/sch/source/core/chaxis.cxx,v
retrieving revision 1.39
retrieving revision 1.39.18.1
diff -u -p -u -p -r1.39 -r1.39.18.1
--- sch/source/core/chaxis.cxx	18 Mar 2005 09:47:50 -0000	1.39
+++ sch/source/core/chaxis.cxx	25 May 2005 11:40:28 -0000	1.39.18.1
@@ -2581,7 +2581,7 @@ void ChartAxis::DrawGrids()
         // occur, because in the following loop the current value is achieved by
         // repeatedly adding the main step value where small errors might
         // accumulate
-        double fThreshold = ::std::min( mfMax, ::std::min( mfStep, mfStepHelp )) / 1000.0;
+        double fThreshold = ::std::min( mfStep, mfStepHelp ) / 1000.0;
 
         if( ::rtl::math::isInf( mfMax ) || ::rtl::math::isInf( mfMin ))
         {
Index: sch/source/ui/dlg/tplabel.cxx
===================================================================
RCS file: /cvs/graphics/sch/source/ui/dlg/tplabel.cxx,v
retrieving revision 1.4
retrieving revision 1.4.102.1
diff -u -p -u -p -r1.4 -r1.4.102.1
--- sch/source/ui/dlg/tplabel.cxx	2 Aug 2004 17:58:14 -0000	1.4
+++ sch/source/ui/dlg/tplabel.cxx	25 May 2005 11:42:08 -0000	1.4.102.1
@@ -153,7 +153,7 @@ SfxTabPage* SchAxisLabelTabPage::Create(
 
 BOOL SchAxisLabelTabPage::FillItemSet( SfxItemSet& rOutAttrs )
 {
-	SvxChartTextOrient eOrient;
+	SvxChartTextOrient eOrient=CHTXTORIENT_AUTOMATIC;
     sal_Int32 nDegrees = aCtrlDial.GetRotation();
 
     if( nDegrees != m_nInitialDegrees )
Index: sc/inc/dbcolect.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dbcolect.hxx,v
retrieving revision 1.8
retrieving revision 1.8.84.1
diff -u -p -u -p -r1.8 -r1.8.84.1
--- sc/inc/dbcolect.hxx	14 Jan 2005 11:58:41 -0000	1.8
+++ sc/inc/dbcolect.hxx	22 Apr 2005 14:37:06 -0000	1.8.84.1
@@ -279,6 +279,7 @@ public:
 
 	BOOL	SearchName( const String& rName, USHORT& rIndex ) const;
 
+    void    DeleteOnTab( SCTAB nTab );
 	void	UpdateReference(UpdateRefMode eUpdateRefMode,
 								SCCOL nCol1, SCROW nRow1, SCTAB nTab1,
 								SCCOL nCol2, SCROW nRow2, SCTAB nTab2,
Index: sc/inc/detdata.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/detdata.hxx,v
retrieving revision 1.3
retrieving revision 1.3.346.1
diff -u -p -u -p -r1.3 -r1.3.346.1
--- sc/inc/detdata.hxx	4 Jun 2004 10:06:42 -0000	1.3
+++ sc/inc/detdata.hxx	22 Apr 2005 14:37:07 -0000	1.3.346.1
@@ -132,6 +132,7 @@ public:
 		ScDetOpList(const ScDetOpList& rList);
 		~ScDetOpList() {}
 
+    void    DeleteOnTab( SCTAB nTab );
 	void	UpdateReference( ScDocument* pDoc, UpdateRefMode eUpdateRefMode,
 								const ScRange& rRange, SCsCOL nDx, SCsROW nDy, SCsTAB nDz );
 
Index: sc/inc/document.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/document.hxx,v
retrieving revision 1.86
retrieving revision 1.86.18.2
diff -u -p -u -p -r1.86 -r1.86.18.2
--- sc/inc/document.hxx	8 Mar 2005 11:28:07 -0000	1.86
+++ sc/inc/document.hxx	10 May 2005 16:28:47 -0000	1.86.18.2
@@ -281,7 +281,7 @@ private:
 
 	ScFieldEditEngine*	pEditEngine;					// uses pEditPool from xPoolHelper
 	ScNoteEditEngine*	pNoteEngine;					// uses pEditPool from xPoolHelper
-	SfxItemPool*	pNoteItemPool; // SfxItemPool to be used if pDrawLayer not created. 					
+	SfxItemPool*	pNoteItemPool; // SfxItemPool to be used if pDrawLayer not created.
 	SfxObjectShell*		pShell;
 	SfxPrinter*			pPrinter;
 	ScDrawLayer*		pDrawLayer;						// SdrModel
@@ -569,6 +569,7 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
 	void			SnapVisArea( Rectangle& rRect ) const;			// 1/100 mm
 
 	SC_DLLPUBLIC BOOL			ValidTabName( const String& rName ) const;
+    static void      ConvertToValidTabName( String& rName, sal_Unicode cReplaceChar );
 	SC_DLLPUBLIC BOOL			ValidNewTabName( const String& rName ) const;
 	SC_DLLPUBLIC void			CreateValidTabName(String& rName) const;
 	BOOL			InsertTab( SCTAB nPos, const String& rName,
@@ -1679,6 +1680,7 @@ private: // CLOOK-Impl-Methoden
 	void	LoadAreaLinks(SvStream& rStream);
 	void	SaveAreaLinks(SvStream& rStream) const;
 
+    void    DeleteAreaLinksOnTab( SCTAB nTab );
 	void	UpdateRefAreaLinks( UpdateRefMode eUpdateRefMode,
 							 const ScRange& r, SCsCOL nDx, SCsROW nDy, SCsTAB nDz );
 
Index: sc/inc/dpobject.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpobject.hxx,v
retrieving revision 1.9
retrieving revision 1.9.68.1
diff -u -p -u -p -r1.9 -r1.9.68.1
--- sc/inc/dpobject.hxx	28 Jan 2005 17:18:28 -0000	1.9
+++ sc/inc/dpobject.hxx	22 Apr 2005 14:37:07 -0000	1.9.68.1
@@ -281,6 +281,7 @@ public:
 
 	void		ConvertOldTables( ScPivotCollection& rOldColl );
 
+    void        DeleteOnTab( SCTAB nTab );
 	void		UpdateReference( UpdateRefMode eUpdateRefMode,
 								 const ScRange& r, SCsCOL nDx, SCsROW nDy, SCsTAB nDz );
 
Index: sc/inc/rangelst.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/rangelst.hxx,v
retrieving revision 1.3
retrieving revision 1.3.346.1
diff -u -p -u -p -r1.3 -r1.3.346.1
--- sc/inc/rangelst.hxx	4 Jun 2004 10:12:59 -0000	1.3
+++ sc/inc/rangelst.hxx	22 Apr 2005 14:37:08 -0000	1.3.346.1
@@ -137,6 +137,7 @@ public:
 	BOOL 			UpdateReference( UpdateRefMode, ScDocument*,
 									const ScRange& rWhere,
 									SCsCOL nDx, SCsROW nDy, SCsTAB nDz );
+    void            DeleteOnTab( SCTAB nTab );
 	ScRangePair*	Find( const ScAddress& ) const;
 	ScRangePair*	Find( const ScRange& ) const;
 	BOOL			Load( SvStream&, USHORT nVer );
Index: sc/inc/scmatrix.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/scmatrix.hxx,v
retrieving revision 1.5
retrieving revision 1.5.18.1
diff -u -p -u -p -r1.5 -r1.5.18.1
--- sc/inc/scmatrix.hxx	8 Mar 2005 11:28:36 -0000	1.5
+++ sc/inc/scmatrix.hxx	31 May 2005 18:48:30 -0000	1.5.18.1
@@ -222,12 +222,21 @@ public:
     /// lower left triangle
     void FillDoubleLowerLeft( double fVal, SCSIZE nC2 );
 
-    /** Use outside ScInterpreter before obtaining the double value of an
-        element and passing it's NAN around.
+private:
+    /** May be used before obtaining the double value of an element to avoid
+        passing its NAN around.
+        @ATTENTION: MUST NOT be used if the element is a string!
         @returns 0 if no error, else one of err... constants */
     USHORT GetError( SCSIZE nC, SCSIZE nR) const;
     USHORT GetError( SCSIZE nIndex) const
-        { return GetDoubleErrorValue( pMat[nIndex].fVal); }
+        { return pMat[nIndex].GetError(); }
+public:
+    /** Use in ScInterpreter to obtain the error code, if any.
+        @returns 0 if no error or string element, else one of err... constants */
+    USHORT GetErrorIfNotString( SCSIZE nC, SCSIZE nR) const
+        { return IsValue( nC, nR) ? GetError( nC, nR) : 0; }
+    USHORT GetErrorIfNotString( SCSIZE nIndex) const
+        { return IsValue( nIndex) ? GetError( nIndex) : 0; }
 
     /// @return 0.0 if empty
     double GetDouble( SCSIZE nC, SCSIZE nR) const;
Index: sc/inc/validat.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/validat.hxx,v
retrieving revision 1.8
retrieving revision 1.8.18.1
diff -u -p -u -p -r1.8 -r1.8.18.1
--- sc/inc/validat.hxx	8 Mar 2005 11:29:11 -0000	1.8
+++ sc/inc/validat.hxx	15 Jul 2005 16:36:23 -0000	1.8.18.1
@@ -236,6 +236,7 @@ public:
 	void	CompileXML();
 	void	UpdateReference( UpdateRefMode eUpdateRefMode,
 								const ScRange& rRange, SCsCOL nDx, SCsROW nDy, SCsTAB nDz );
+    void    UpdateMoveTab( SCTAB nOldPos, SCTAB nNewPos );
 
 	BOOL	operator==( const ScValidationDataList& r ) const;		// fuer Ref-Undo
 };
Index: sc/source/core/data/column.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/column.cxx,v
retrieving revision 1.16
retrieving revision 1.16.4.1
diff -u -p -u -p -r1.16 -r1.16.4.1
--- sc/source/core/data/column.cxx	29 Mar 2005 13:30:36 -0000	1.16
+++ sc/source/core/data/column.cxx	27 Apr 2005 18:20:39 -0000	1.16.4.1
@@ -1881,7 +1881,8 @@ void ScColumn::UpdateGrow( const ScRange
 
 void ScColumn::UpdateInsertTab( SCTAB nTable)
 {
-	if (nTab >= nTable) nTab++;
+    if (nTab >= nTable)
+        pAttrArray->SetTab(++nTab);
 	if( pItems )
 		UpdateInsertTabOnlyCells( nTable );
 }
Index: sc/source/core/data/column3.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/column3.cxx,v
retrieving revision 1.16
retrieving revision 1.16.88.1
diff -u -p -u -p -r1.16 -r1.16.88.1
--- sc/source/core/data/column3.cxx	11 Jan 2005 12:38:02 -0000	1.16
+++ sc/source/core/data/column3.cxx	26 Jul 2005 16:35:54 -0000	1.16.88.1
@@ -912,14 +912,22 @@ ScBaseCell* ScColumn::CloneCell(SCSIZE n
 						}
 					}
 					if ( pNew && pSource->GetNotePtr() && ( nFlags & IDF_NOTE ) )
-						pNew->SetNote(*pSource->GetNotePtr());
+                    {
+                        // #i52342# the note must be constructed with the destination document pointer
+                        ScPostIt aNewNote( *pSource->GetNotePtr(), pDestDoc );
+                        pNew->SetNote( aNewNote );
+                    }
 				}
 			}
 			break;
 	}
 
 	if ( !pNew && pSource->GetNotePtr() && ( nFlags & IDF_NOTE ) )
-		pNew = new ScNoteCell(*pSource->GetNotePtr());
+    {
+        // #i52342# the note must be constructed with the destination document pointer
+        ScPostIt aNewNote( *pSource->GetNotePtr(), pDestDoc );
+        pNew = new ScNoteCell( aNewNote );
+    }
 
 	return pNew;
 }
Index: sc/source/core/data/documen2.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/documen2.cxx,v
retrieving revision 1.50
retrieving revision 1.50.18.1
diff -u -p -u -p -r1.50 -r1.50.18.1
--- sc/source/core/data/documen2.cxx	8 Mar 2005 15:41:15 -0000	1.50
+++ sc/source/core/data/documen2.cxx	15 Jul 2005 16:36:23 -0000	1.50.18.1
@@ -1544,6 +1544,8 @@ BOOL ScDocument::MoveTab( SCTAB nOldPos,
 				UpdateRefAreaLinks( URM_REORDER, aSourceRange, 0,0,nDz );
 				if ( pCondFormList )
 					pCondFormList->UpdateMoveTab( nOldPos, nNewPos );
+				if ( pValidationList )
+					pValidationList->UpdateMoveTab( nOldPos, nNewPos );
 				if ( pUnoBroadcaster )
 					pUnoBroadcaster->Broadcast( ScUpdateRefHint( URM_REORDER,
 									aSourceRange, 0,0,nDz ) );
@@ -1657,6 +1659,8 @@ BOOL ScDocument::CopyTab( SCTAB nOldPos,
 				//	update conditional formats after table is inserted
 				if ( pCondFormList )
 					pCondFormList->UpdateReference( URM_INSDEL, aRange, 0,0,1 );
+				if ( pValidationList )
+					pValidationList->UpdateReference( URM_INSDEL, aRange, 0,0,1 );
 				// #81844# sheet names of references may not be valid until sheet is copied
 				pChartListenerCollection->UpdateScheduledSeriesRanges();
 			}
Index: sc/source/core/data/documen3.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/documen3.cxx,v
retrieving revision 1.27
retrieving revision 1.27.36.1
diff -u -p -u -p -r1.27 -r1.27.36.1
--- sc/source/core/data/documen3.cxx	21 Feb 2005 13:20:39 -0000	1.27
+++ sc/source/core/data/documen3.cxx	15 Jul 2005 16:36:23 -0000	1.27.36.1
@@ -861,6 +861,8 @@ void ScDocument::UpdateReference( Update
 			UpdateRefAreaLinks( eUpdateRefMode, aRange, nDx, nDy, nDz );
 			if ( pCondFormList )
 				pCondFormList->UpdateReference( eUpdateRefMode, aRange, nDx, nDy, nDz );
+			if ( pValidationList )
+				pValidationList->UpdateReference( eUpdateRefMode, aRange, nDx, nDy, nDz );
 			if ( pDetOpList )
 				pDetOpList->UpdateReference( this, eUpdateRefMode, aRange, nDx, nDy, nDz );
 			if ( pUnoBroadcaster )
Index: sc/source/core/data/documen8.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/documen8.cxx,v
retrieving revision 1.38
retrieving revision 1.38.108.3
diff -u -p -u -p -r1.38 -r1.38.108.3
--- sc/source/core/data/documen8.cxx	23 Dec 2004 10:43:45 -0000	1.38
+++ sc/source/core/data/documen8.cxx	28 Jul 2005 08:42:59 -0000	1.38.108.3
@@ -872,6 +872,11 @@ BOOL ScDocument::ContinueOnlineSpelling(
 	if ( bIdleDisabled || !pDocOptions->IsAutoSpell() || (pShell && pShell->IsReadOnly()) )
 		return FALSE;
 
+    // #i48433# set bInsertingFromOtherDoc flag so there are no broadcasts when PutCell is called
+    // (same behavior as in RemoveAutoSpellObj: just transfer the broadcaster)
+    BOOL bOldInserting = IsInsertingFromOtherDoc();
+    SetInsertingFromOtherDoc( TRUE );
+
 	//!	use one EditEngine for both calls
 
 	//	#41504# first check visible range
@@ -892,6 +897,9 @@ BOOL ScDocument::ContinueOnlineSpelling(
 		ScRange aTotalRange( 0,0,0, MAXCOL,MAXROW,MAXTAB );
 		bResult = OnlineSpellInRange( aTotalRange, aOnlineSpellPos, SPELL_MAXTEST_ALL );
 	}
+
+    SetInsertingFromOtherDoc( bOldInserting );
+
 	return bResult;
 }
 
@@ -1339,11 +1347,31 @@ void ScDocument::UpdateAreaLinks()
     }
 }
 
+void ScDocument::DeleteAreaLinksOnTab( SCTAB nTab )
+{
+    if (pLinkManager)
+    {
+        const ::sfx2::SvBaseLinks& rLinks = pLinkManager->GetLinks();
+        USHORT nPos = 0;
+        while ( nPos < rLinks.Count() )
+        {
+            const ::sfx2::SvBaseLink* pBase = *rLinks[nPos];
+            if ( pBase->ISA(ScAreaLink) &&
+                 static_cast<const ScAreaLink*>(pBase)->GetDestArea().aStart.Tab() == nTab )
+                pLinkManager->Remove( nPos );
+            else
+                ++nPos;
+        }
+    }
+}
+
 void ScDocument::UpdateRefAreaLinks( UpdateRefMode eUpdateRefMode,
 							 const ScRange& rRange, SCsCOL nDx, SCsROW nDy, SCsTAB nDz )
 {
     if (pLinkManager)
     {
+        bool bAnyUpdate = false;
+
         const ::sfx2::SvBaseLinks& rLinks = pLinkManager->GetLinks();
         USHORT nCount = rLinks.Count();
         for (USHORT i=0; i<nCount; i++)
@@ -1367,7 +1395,42 @@ void ScDocument::UpdateRefAreaLinks( Upd
                         rRange.aEnd.Col(), rRange.aEnd.Row(), rRange.aEnd.Tab(), nDx, nDy, nDz,
                         nCol1, nRow1, nTab1, nCol2, nRow2, nTab2 );
                 if ( eRes != UR_NOTHING )
+                {
                     pLink->SetDestArea( ScRange( nCol1, nRow1, nTab1, nCol2, nRow2, nTab2 ) );
+                    bAnyUpdate = true;
+                }
+            }
+        }
+
+        if ( bAnyUpdate )
+        {
+            // #i52120# Look for duplicates (after updating all positions).
+            // If several links start at the same cell, the one with the lower index is removed
+            // (file format specifies only one link definition for a cell).
+
+            USHORT nFirstIndex = 0;
+            while ( nFirstIndex < nCount )
+            {
+                bool bFound = false;
+                ::sfx2::SvBaseLink* pFirst = *rLinks[nFirstIndex];
+                if ( pFirst->ISA(ScAreaLink) )
+                {
+                    ScAddress aFirstPos = static_cast<ScAreaLink*>(pFirst)->GetDestArea().aStart;
+                    for ( USHORT nSecondIndex = nFirstIndex + 1; nSecondIndex < nCount && !bFound; ++nSecondIndex )
+                    {
+                        ::sfx2::SvBaseLink* pSecond = *rLinks[nSecondIndex];
+                        if ( pSecond->ISA(ScAreaLink) &&
+                             static_cast<ScAreaLink*>(pSecond)->GetDestArea().aStart == aFirstPos )
+                        {
+                            // remove the first link, exit the inner loop, don't increment nFirstIndex
+                            pLinkManager->Remove( pFirst );
+                            nCount = rLinks.Count();
+                            bFound = true;
+                        }
+                    }
+                }
+                if (!bFound)
+                    ++nFirstIndex;
             }
         }
     }
Index: sc/source/core/data/document.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/document.cxx,v
retrieving revision 1.65
retrieving revision 1.64.44.6
diff -u -p -u -p -r1.65 -r1.64.44.6
--- sc/source/core/data/document.cxx	29 Mar 2005 13:31:19 -0000	1.65
+++ sc/source/core/data/document.cxx	15 Jul 2005 16:36:24 -0000	1.64.44.6
@@ -211,16 +211,40 @@ BOOL ScDocument::GetTable( const String&
 
 BOOL ScDocument::ValidTabName( const String& rName ) const
 {
-    /*  If changed, ScfTools::ConvertToScSheetName (sc/source/filter/ftools/ftools.cxx)
-        needs to be changed too. */
+    // behaviour must be equal to ConvertToValidTabName(), see below
 	using namespace ::com::sun::star::i18n;
 	sal_Int32 nStartFlags = KParseTokens::ANY_LETTER_OR_NUMBER |
 		KParseTokens::ASC_UNDERSCORE;
 	sal_Int32 nContFlags = nStartFlags;
 	String aContChars( RTL_CONSTASCII_USTRINGPARAM(" ") );
-	ParseResult rRes = ScGlobal::pCharClass->parsePredefinedToken( KParseType::IDENTNAME, rName, 0,
-		nStartFlags, EMPTY_STRING, nContFlags, aContChars );
-	return (rRes.TokenType & KParseType::IDENTNAME) && rRes.EndPos == rName.Len();
+    ParseResult aRes = ScGlobal::pCharClass->parsePredefinedToken(
+        KParseType::IDENTNAME, rName, 0, nStartFlags, EMPTY_STRING, nContFlags, aContChars );
+    return (aRes.TokenType & KParseType::IDENTNAME) && aRes.EndPos == rName.Len();
+}
+
+
+void ScDocument::ConvertToValidTabName( String& rName, sal_Unicode cReplaceChar )
+{
+    // behaviour must be equal to ValidTabName(), see above
+    using namespace ::com::sun::star::i18n;
+    sal_Int32 nStartFlags = KParseTokens::ANY_LETTER_OR_NUMBER |
+        KParseTokens::ASC_UNDERSCORE;
+    sal_Int32 nContFlags = nStartFlags;
+    String aStartChars;
+    String aContChars( RTL_CONSTASCII_USTRINGPARAM(" ") );
+    sal_Int32 nStartPos = 0;
+    while( nStartPos < rName.Len() )
+    {
+        ParseResult aRes = ScGlobal::pCharClass->parsePredefinedToken( KParseType::IDENTNAME,
+            rName, nStartPos, nStartFlags, aStartChars, nContFlags, aContChars );
+        if( aRes.EndPos < rName.Len() )
+        {
+            rName.SetChar( static_cast< xub_StrLen >( aRes.EndPos ), cReplaceChar );
+            nStartFlags = nContFlags;
+            aStartChars = aContChars;
+        }
+        nStartPos = aRes.EndPos + 1;
+    }
 }
 
 
@@ -347,6 +371,8 @@ BOOL ScDocument::InsertTab( SCTAB nPos, 
 				//	update conditional formats after table is inserted
 				if ( pCondFormList )
 					pCondFormList->UpdateReference( URM_INSDEL, aRange, 0,0,1 );
+				if ( pValidationList )
+					pValidationList->UpdateReference( URM_INSDEL, aRange, 0,0,1 );
 				// #81844# sheet names of references are not valid until sheet is inserted
 				if ( pChartListenerCollection )
 					pChartListenerCollection->UpdateScheduledSeriesRanges();
@@ -377,6 +403,20 @@ BOOL ScDocument::DeleteTab( SCTAB nTab, 
 				ScRange aRange( 0, 0, nTab, MAXCOL, MAXROW, nTab );
 				DelBroadcastAreasInRange( aRange );
 
+                // #i8180# remove database ranges etc. that are on the deleted tab
+                // (restored in undo with ScRefUndoData)
+
+                xColNameRanges->DeleteOnTab( nTab );
+                xRowNameRanges->DeleteOnTab( nTab );
+                pDBCollection->DeleteOnTab( nTab );
+                if (pDPCollection)
+                    pDPCollection->DeleteOnTab( nTab );
+                if (pDetOpList)
+                    pDetOpList->DeleteOnTab( nTab );
+                DeleteAreaLinksOnTab( nTab );
+
+                // normal reference update
+
 				aRange.aEnd.SetTab( MAXTAB );
 				xColNameRanges->UpdateReference( URM_INSDEL, this, aRange, 0,0,-1 );
 				xRowNameRanges->UpdateReference( URM_INSDEL, this, aRange, 0,0,-1 );
@@ -394,6 +434,8 @@ BOOL ScDocument::DeleteTab( SCTAB nTab, 
 				UpdateRefAreaLinks( URM_INSDEL, aRange, 0,0,-1 );
 				if ( pCondFormList )
 					pCondFormList->UpdateReference( URM_INSDEL, aRange, 0,0,-1 );
+				if ( pValidationList )
+					pValidationList->UpdateReference( URM_INSDEL, aRange, 0,0,-1 );
 				if ( pUnoBroadcaster )
 					pUnoBroadcaster->Broadcast( ScUpdateRefHint( URM_INSDEL, aRange, 0,0,-1 ) );
 
@@ -2782,7 +2824,7 @@ SCCOL ScDocument::GetNextDifferentChange
 				((nStartFlags & CR_HIDDEN) != (pTab[nTab]->GetColFlags(nCol) & CR_HIDDEN)) )
 				return nCol;
 		}
-		return MAXCOL;
+		return MAXCOL+1;
 	}
 	return 0;
 }
@@ -2802,7 +2844,7 @@ SCROW ScDocument::GetNextDifferentChange
                 (!bCareManualSize && ((nStartHeight != pTab[nTab]->GetOriginalHeight(nRow)))))
 				return nRow;
 		}
-		return MAXROW;
+		return MAXROW+1;
 	}
 	return 0;
 }
Index: sc/source/core/data/dpobject.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpobject.cxx,v
retrieving revision 1.15
retrieving revision 1.15.68.1
diff -u -p -u -p -r1.15 -r1.15.68.1
--- sc/source/core/data/dpobject.cxx	28 Jan 2005 17:19:25 -0000	1.15
+++ sc/source/core/data/dpobject.cxx	22 Apr 2005 14:37:34 -0000	1.15.68.1
@@ -2107,6 +2107,19 @@ BOOL ScDPCollection::LoadNew( SvStream& 
 	return bSuccess;
 }
 
+void ScDPCollection::DeleteOnTab( SCTAB nTab )
+{
+    USHORT nPos = 0;
+    while ( nPos < nCount )
+    {
+        // look for output positions on the deleted sheet
+        if ( static_cast<const ScDPObject*>(At(nPos))->GetOutRange().aStart.Tab() == nTab )
+            AtFree(nPos);
+        else
+            ++nPos;
+    }
+}
+
 void ScDPCollection::UpdateReference( UpdateRefMode eUpdateRefMode,
 										 const ScRange& r, SCsCOL nDx, SCsROW nDy, SCsTAB nDz )
 {
@@ -2135,7 +2148,41 @@ void ScDPCollection::WriteRefsTo( ScDPCo
 			((const ScDPObject*)At(i))->WriteRefsTo( *((ScDPObject*)r.At(i)) );
 	}
 	else
-		DBG_ERROR("WriteRefsTo: different count");
+    {
+        // #i8180# If data pilot tables were deleted with their sheet,
+        // this collection contains extra entries that must be restored.
+        // Matching objects are found by their names.
+
+        DBG_ASSERT( nCount >= r.nCount, "WriteRefsTo: missing entries in document" );
+        for (USHORT nSourcePos=0; nSourcePos<nCount; nSourcePos++)
+        {
+            const ScDPObject* pSourceObj = static_cast<const ScDPObject*>(At(nSourcePos));
+            String aName = pSourceObj->GetName();
+            bool bFound = false;
+            for (USHORT nDestPos=0; nDestPos<r.nCount && !bFound; nDestPos++)
+            {
+                ScDPObject* pDestObj = static_cast<ScDPObject*>(r.At(nDestPos));
+                if ( pDestObj->GetName() == aName )
+                {
+                    pSourceObj->WriteRefsTo( *pDestObj );     // found object, copy refs
+                    bFound = true;
+                }
+            }
+            if ( !bFound )
+            {
+                // none found, re-insert deleted object (see ScUndoDataPilot::Undo)
+
+                ScDPObject* pDestObj = new ScDPObject( *pSourceObj );
+                pDestObj->SetAlive(TRUE);
+                if ( !r.Insert(pDestObj) )
+                {
+                    DBG_ERROR("cannot insert DPObject");
+                    DELETEZ( pDestObj );
+                }
+            }
+        }
+        DBG_ASSERT( nCount == r.nCount, "WriteRefsTo: couldn't restore all entries" );
+    }
 }
 
 String ScDPCollection::CreateNewName( USHORT nMin ) const
Index: sc/source/core/data/dptabsrc.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabsrc.cxx,v
retrieving revision 1.11
retrieving revision 1.11.68.1
diff -u -p -u -p -r1.11 -r1.11.68.1
--- sc/source/core/data/dptabsrc.cxx	28 Jan 2005 17:19:41 -0000	1.11
+++ sc/source/core/data/dptabsrc.cxx	28 Jul 2005 12:30:40 -0000	1.11.68.1
@@ -1335,7 +1335,8 @@ long ScDPDimension::getUsedHierarchy() c
 
 void ScDPDimension::setUsedHierarchy(long nNew)
 {
-	nUsedHier = nNew;
+    // #i52547# don't use the incomplete date hierarchy implementation - ignore the call
+    // nUsedHier = nNew;
 }
 
 ScDPDimension* ScDPDimension::CreateCloneObject()
@@ -1573,12 +1574,17 @@ ScDPHierarchies::ScDPHierarchies( ScDPSo
 {
 	//!	hold pSource
 
+#if 0
 	//	date columns have 3 hierarchies (flat/quarter/week), other columns only one
 	long nSrcDim = pSource->GetSourceDim( nDim );
 	if ( pSource->IsDateDimension( nSrcDim ) )
 		nHierCount = SC_DAPI_DATE_HIERARCHIES;
 	else
 		nHierCount = 1;
+#endif
+
+    // #i52547# don't offer the incomplete date hierarchy implementation
+    nHierCount = 1;
 }
 
 ScDPHierarchies::~ScDPHierarchies()
Index: sc/source/core/data/table1.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/table1.cxx,v
retrieving revision 1.12
retrieving revision 1.12.4.1
diff -u -p -u -p -r1.12 -r1.12.4.1
--- sc/source/core/data/table1.cxx	29 Mar 2005 11:47:14 -0000	1.12
+++ sc/source/core/data/table1.cxx	7 Jun 2005 12:29:53 -0000	1.12.4.1
@@ -1103,12 +1103,12 @@ void ScTable::UpdateReference( UpdateRef
 
 	if ( nTab >= nTab1 && nTab <= nTab2 && nDz == 0 )		// print ranges: only within the table
 	{
-        SCTAB nSTab;
-        SCTAB nETab;
-        SCCOL nSCol;
-        SCROW nSRow;
-        SCCOL nECol;
-        SCROW nERow;
+        SCTAB nSTab = nTab;
+        SCTAB nETab = nTab;
+        SCCOL nSCol = 0;
+        SCROW nSRow = 0;
+        SCCOL nECol = 0;
+        SCROW nERow = 0;
 		BOOL bRecalcPages = FALSE;
 
         for ( ScRangeVec::iterator aIt = aPrintRanges.begin(), aEnd = aPrintRanges.end(); aIt != aEnd; ++aIt )
@@ -1118,7 +1118,7 @@ void ScTable::UpdateReference( UpdateRef
             nECol = aIt->aEnd.Col();
             nERow = aIt->aEnd.Row();
 
-            // do not try to modify sheet index of repeat range
+            // do not try to modify sheet index of print range
             if ( ScRefUpdate::Update( pDocument, eUpdateRefMode,
                                       nCol1,nRow1,nTab, nCol2,nRow2,nTab,
                                       nDx,nDy,0,
Index: sc/source/core/data/table2.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/table2.cxx,v
retrieving revision 1.32
retrieving revision 1.32.4.1
diff -u -p -u -p -r1.32 -r1.32.4.1
--- sc/source/core/data/table2.cxx	29 Mar 2005 13:31:34 -0000	1.32
+++ sc/source/core/data/table2.cxx	4 Jul 2005 13:31:04 -0000	1.32.4.1
@@ -1136,7 +1136,10 @@ const ScPatternAttr* ScTable::GetPattern
 	if (ValidColRow(nCol,nRow))
 		return aCol[nCol].GetPattern( nRow );
 	else
-		return NULL;
+    {
+        DBG_ERROR("wrong column or row");
+        return pDocument->GetDefPattern();      // for safety
+    }
 }
 
 
Index: sc/source/core/data/table4.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/table4.cxx,v
retrieving revision 1.11
retrieving revision 1.11.150.1
diff -u -p -u -p -r1.11 -r1.11.150.1
--- sc/source/core/data/table4.cxx	9 Nov 2004 17:56:27 -0000	1.11
+++ sc/source/core/data/table4.cxx	27 Apr 2005 18:19:38 -0000	1.11.150.1
@@ -786,16 +786,21 @@ void ScTable::FillAuto( SCCOL nCol1, SCR
 					case CELLTYPE_EDIT:
 						if ( nHeadNoneTail )
 						{
+                            // #i48009# with the "nStringValue+(long)nDelta" expression within the
+                            // lcl_ValueString calls, gcc 3.4.1 makes wrong optimizations (ok in 3.4.3),
+                            // so nNextValue is now calculated ahead.
+                            long nNextValue = nStringValue+(long)nDelta;
+
 							String aStr;
 							if ( nHeadNoneTail < 0 )
 							{
-								aStr = lcl_ValueString( nStringValue+(long)nDelta, nCellDigits );
+                                aStr = lcl_ValueString( nNextValue, nCellDigits );
 								aStr += aValue;
 							}
 							else
 							{
 								aStr = aValue;
-								aStr += lcl_ValueString( nStringValue+(long)nDelta, nCellDigits );
+                                aStr += lcl_ValueString( nNextValue, nCellDigits );
 							}
 							aCol[nCol].Insert(static_cast<SCROW>(nRow), new ScStringCell( aStr ) );
 						}
Index: sc/source/core/data/validat.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/validat.cxx,v
retrieving revision 1.13
retrieving revision 1.13.8.1
diff -u -p -u -p -r1.13 -r1.13.8.1
--- sc/source/core/data/validat.cxx	13 Apr 2005 12:18:40 -0000	1.13
+++ sc/source/core/data/validat.cxx	15 Jul 2005 16:36:24 -0000	1.13.8.1
@@ -1029,7 +1029,16 @@ void ScValidationDataList::CompileXML()
 void ScValidationDataList::UpdateReference( UpdateRefMode eUpdateRefMode,
 								const ScRange& rRange, SCsCOL nDx, SCsROW nDy, SCsTAB nDz )
 {
-	DBG_ERROR("ScValidationDataList::UpdateReference");
+    USHORT nCount = Count();
+    for (USHORT i=0; i<nCount; i++)
+        (*this)[i]->UpdateReference( eUpdateRefMode, rRange, nDx, nDy, nDz);
+}
+
+void ScValidationDataList::UpdateMoveTab( SCTAB nOldPos, SCTAB nNewPos )
+{
+    USHORT nCount = Count();
+    for (USHORT i=0; i<nCount; i++)
+		(*this)[i]->UpdateMoveTab( nOldPos, nNewPos );
 }
 
 BOOL ScValidationDataList::operator==( const ScValidationDataList& r ) const
Index: sc/source/core/inc/interpre.hxx
===================================================================
RCS file: /cvs/sc/sc/source/core/inc/interpre.hxx,v
retrieving revision 1.21
retrieving revision 1.20.4.2
diff -u -p -u -p -r1.21 -r1.20.4.2
--- sc/source/core/inc/interpre.hxx	13 May 2005 07:33:07 -0000	1.21
+++ sc/source/core/inc/interpre.hxx	18 May 2005 11:15:39 -0000	1.20.4.2
@@ -581,10 +581,6 @@ void MEMat(ScMatrix* mM, SCSIZE n);
 void MFastMult(ScMatrix* pA, ScMatrix* pB, ScMatrix* pR, SCSIZE n, SCSIZE m, SCSIZE l);
 void MFastSub(ScMatrix* pA, ScMatrix* pB, ScMatrix* pR, SCSIZE n, SCSIZE m);
 void MFastTrans(ScMatrix* pA, ScMatrix* pR, SCSIZE n, SCSIZE m);
-BOOL MFastBackSubst(ScMatrix* pA, ScMatrix* pR, SCSIZE n, BOOL bIsUpper);
-BOOL ScMatLUP(ScMatrix* mA, SCSIZE m, SCSIZE p,
-			  ScMatrix* mL, ScMatrix* mU, ScMatrix* mP,
-			  ULONG& rPermutCounter, BOOL& bIsInvertable);
 void ScMatDet();
 void ScMatInv();
 void ScMatMult();
Index: sc/source/core/inc/refupdat.hxx
===================================================================
RCS file: /cvs/sc/sc/source/core/inc/refupdat.hxx,v
retrieving revision 1.2
retrieving revision 1.2.346.1
diff -u -p -u -p -r1.2 -r1.2.346.1
--- sc/source/core/inc/refupdat.hxx	4 Jun 2004 10:31:47 -0000	1.2
+++ sc/source/core/inc/refupdat.hxx	15 Jul 2005 10:15:10 -0000	1.2.346.1
@@ -79,6 +79,14 @@ enum ScRefUpdateRes {
 class ScRefUpdate
 {
 public:
+
+    /// What type of reference is to be updated.
+    enum WhatType
+    {
+        ALL,        /// all references
+        ABSOLUTE    /// only absolute references
+    };
+
 	static ScRefUpdateRes Update
 		( ScDocument* pDoc, UpdateRefMode eUpdateRefMode,
 							SCCOL nCol1, SCROW nRow1, SCTAB nTab1,
@@ -92,23 +100,30 @@ public:
 								INT32 nDx, INT32 nDy, INT32 nDz,
 								ScBigRange& rWhat );
 
+    /// Before calling, the absolute references must be up-to-date!
 	static ScRefUpdateRes Update( ScDocument* pDoc,
 								  UpdateRefMode eUpdateRefMode,
 								  const ScAddress& rPos, const ScRange& rRange,
 								  SCsCOL nDx, SCsROW nDy, SCsTAB nDz,
-								  ComplRefData& rRef );
+								  ComplRefData& rRef, WhatType eWhat = ALL );
+
+    /// Before calling, the absolute references must be up-to-date!
 	static ScRefUpdateRes Move( ScDocument* pDoc, const ScAddress& rPos,
 								SCsCOL nDx, SCsROW nDy, SCsTAB nDz,
 								ComplRefData& rRef, BOOL bWrap, BOOL bAbsolute );
+
 	static void MoveRelWrap( ScDocument* pDoc, const ScAddress& rPos,
 								ComplRefData& rRef );
 
+    /// Before calling, the absolute references must be up-to-date!
 	static ScRefUpdateRes UpdateTranspose( ScDocument* pDoc,
 								const ScRange& rSource, const ScAddress& rDest,
 								ComplRefData& rRef );
+
 	static void DoTranspose( SCsCOL& rCol, SCsROW& rRow, SCsTAB& rTab, ScDocument* pDoc,
 								const ScRange& rSource, const ScAddress& rDest );
 
+    /// Before calling, the absolute references must be up-to-date!
 	static ScRefUpdateRes UpdateGrow(
 								const ScRange& rArea, SCCOL nGrowX, SCROW nGrowY,
 								ComplRefData& rRef );
Index: sc/source/core/tool/compiler.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/compiler.cxx,v
retrieving revision 1.52
retrieving revision 1.52.136.1
diff -u -p -u -p -r1.52 -r1.52.136.1
--- sc/source/core/tool/compiler.cxx	15 Nov 2004 15:10:14 -0000	1.52
+++ sc/source/core/tool/compiler.cxx	15 Jul 2005 10:15:10 -0000	1.52.136.1
@@ -59,12 +59,6 @@
  *
  ************************************************************************/
 
-#ifdef PCH
-#include "core_pch.hxx"
-#endif
-
-#pragma hdrstop
-
 // INCLUDE ---------------------------------------------------------------
 
 #include <sfx2/app.hxx>
@@ -752,6 +746,9 @@ xub_StrLen ScCompiler::NextSymbol()
                 if( nMask & SC_COMPILER_C_STRING_SEP )
                     eState = ssStop;
                 break;
+            case ssStop:
+                ;   // nothing, prevent warning
+                break;
         }
         cLast = c;
         c = *pSrc;
@@ -1158,6 +1155,13 @@ BOOL ScCompiler::IsColRowName( const Str
                             case CELLTYPE_EDIT:
                                 ((ScEditCell*)pCell)->GetString( aStr );
                             break;
+                            case CELLTYPE_NONE:
+                            case CELLTYPE_VALUE:
+                            case CELLTYPE_NOTE:
+                            case CELLTYPE_SYMBOLS:
+                            case CELLTYPE_DESTROYED:
+                                ;   // nothing, prevent compiler warning
+                            break;
                         }
                         if ( ScGlobal::pTransliteration->isEqual( aStr, aName ) )
                         {
@@ -1212,6 +1216,13 @@ BOOL ScCompiler::IsColRowName( const Str
                     case CELLTYPE_EDIT:
                         ((ScEditCell*)pCell)->GetString( aStr );
                     break;
+                    case CELLTYPE_NONE:
+                    case CELLTYPE_VALUE:
+                    case CELLTYPE_NOTE:
+                    case CELLTYPE_SYMBOLS:
+                    case CELLTYPE_DESTROYED:
+                        ;   // nothing, prevent compiler warning
+                    break;
                 }
                 if ( ScGlobal::pTransliteration->isEqual( aStr, aName ) )
                 {
@@ -2141,6 +2152,8 @@ OpCode ScCompiler::NextToken()
                                     bCorrected = TRUE;
                                 }
                             break;
+                            default:
+                                ;   // nothing
                         }
                     }
                 }
@@ -2322,6 +2335,8 @@ void ScCompiler::Factor()
             case ocHyperLink :
                 pArr->SetHyperLink(TRUE);
             break;
+            default:
+                ;   // nothing
         }
         if( eOp > ocEndUnOp && eOp < ocEndNoPar)
         {
@@ -2982,7 +2997,7 @@ BOOL ScCompiler::UpdateNameReference(Upd
                                      SCsCOL nDx, SCsROW nDy, SCsTAB nDz,
                                      BOOL& rChanged, BOOL bSharedFormula)
 {
-    BOOL bRet = FALSE;                      // set if relative reference
+    BOOL bRelRef = FALSE;   // set if relative reference
     rChanged = FALSE;
     pArr->Reset();
     for( ScToken* t = pArr->GetNextReference(); t;
@@ -2990,23 +3005,40 @@ BOOL ScCompiler::UpdateNameReference(Upd
     {
         SingleDoubleRefModifier aMod( *t );
         ComplRefData& rRef = aMod.Ref();
-        if (!rRef.Ref1.IsColRel() && !rRef.Ref1.IsRowRel() &&
-                (!rRef.Ref1.IsTabRel() || (bSharedFormula &&
-                                           !rRef.Ref1.IsFlag3D())) &&
-                (t->GetType() == svSingleRef || (!rRef.Ref2.IsColRel() &&
-                                                 !rRef.Ref2.IsRowRel() &&
-                                                 (!rRef.Ref2.IsTabRel() ||
-                                                  (bSharedFormula &&
-                                                   !rRef.Ref2.IsFlag3D())))))
+        bRelRef = rRef.Ref1.IsColRel() || rRef.Ref1.IsRowRel() ||
+            rRef.Ref1.IsTabRel();
+        if (!bRelRef && t->GetType() == svDoubleRef)
+            bRelRef = rRef.Ref2.IsColRel() || rRef.Ref2.IsRowRel() ||
+                rRef.Ref2.IsTabRel();
+        bool bUpdate;
+        if (bSharedFormula)
         {
-            if (ScRefUpdate::Update( pDoc, eUpdateRefMode, aPos,
-                                     r, nDx, nDy, nDz, rRef ) != UR_NOTHING )
-                rChanged = TRUE;
+            bUpdate = !rRef.Ref1.IsColRel() || !rRef.Ref1.IsRowRel() ||
+                !rRef.Ref1.IsTabRel();
+            if (bUpdate)
+                rRef.Ref1.CalcAbsIfRel( aPos);
+            if (t->GetType() == svDoubleRef)
+            {
+                if (!bUpdate)
+                    bUpdate = !rRef.Ref2.IsColRel() || !rRef.Ref2.IsRowRel() ||
+                        !rRef.Ref2.IsTabRel();
+                if (bUpdate)
+                    rRef.Ref2.CalcAbsIfRel( aPos);
+            }
         }
         else
-            bRet = TRUE;
+        {
+            bUpdate = !bRelRef;
+        }
+        if (bUpdate)
+        {
+            if (ScRefUpdate::Update( pDoc, eUpdateRefMode, aPos, r,
+                        nDx, nDy, nDz, rRef, ScRefUpdate::ABSOLUTE)
+                    != UR_NOTHING )
+                rChanged = TRUE;
+        }
     }
-    return bRet;
+    return bRelRef;
 }
 
 
@@ -3729,6 +3761,8 @@ ScToken* ScCompiler::CreateStringFromTok
                         aBuffer.append(pDBData->GetName());
                 }
                 break;
+                default:
+                    ;   // nothing
             }
             if ( aBuffer.getLength() )
                 rBuffer.append(aBuffer);
Index: sc/source/core/tool/dbcolect.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/dbcolect.cxx,v
retrieving revision 1.12
retrieving revision 1.12.84.1
diff -u -p -u -p -r1.12 -r1.12.84.1
--- sc/source/core/tool/dbcolect.cxx	14 Jan 2005 11:59:07 -0000	1.12
+++ sc/source/core/tool/dbcolect.cxx	22 Apr 2005 14:37:56 -0000	1.12.84.1
@@ -1142,6 +1142,24 @@ BOOL ScDBCollection::Store( SvStream& rS
 	return bSuccess;
 }
 
+void ScDBCollection::DeleteOnTab( SCTAB nTab )
+{
+    USHORT nPos = 0;
+    while ( nPos < nCount )
+    {
+        // look for output positions on the deleted sheet
+
+        SCCOL nEntryCol1, nEntryCol2;
+        SCROW nEntryRow1, nEntryRow2;
+        SCTAB nEntryTab;
+        static_cast<const ScDBData*>(At(nPos))->GetArea( nEntryTab, nEntryCol1, nEntryRow1, nEntryCol2, nEntryRow2 );
+        if ( nEntryTab == nTab )
+            AtFree(nPos);
+        else
+            ++nPos;
+    }
+}
+
 void ScDBCollection::UpdateReference(UpdateRefMode eUpdateRefMode,
 								SCCOL nCol1, SCROW nRow1, SCTAB nTab1,
 								SCCOL nCol2, SCROW nRow2, SCTAB nTab2,
Index: sc/source/core/tool/detdata.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/detdata.cxx,v
retrieving revision 1.3
retrieving revision 1.3.346.1
diff -u -p -u -p -r1.3 -r1.3.346.1
--- sc/source/core/tool/detdata.cxx	4 Jun 2004 10:35:22 -0000	1.3
+++ sc/source/core/tool/detdata.cxx	22 Apr 2005 14:37:56 -0000	1.3.346.1
@@ -88,6 +88,20 @@ ScDetOpList::ScDetOpList(const ScDetOpLi
 		Append( new ScDetOpData(*rList[i]) );
 }
 
+void ScDetOpList::DeleteOnTab( SCTAB nTab )
+{
+    USHORT nPos = 0;
+    while ( nPos < Count() )
+    {
+        // look for operations on the deleted sheet
+
+        if ( (*this)[nPos]->GetPos().Tab() == nTab )
+            Remove(nPos);
+        else
+            ++nPos;
+    }
+}
+
 void ScDetOpList::UpdateReference( ScDocument* pDoc, UpdateRefMode eUpdateRefMode,
 								const ScRange& rRange, SCsCOL nDx, SCsROW nDy, SCsTAB nDz )
 {
Index: sc/source/core/tool/interpr1.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/interpr1.cxx,v
retrieving revision 1.34
retrieving revision 1.34.4.2
diff -u -p -u -p -r1.34 -r1.34.4.2
--- sc/source/core/tool/interpr1.cxx	29 Mar 2005 13:32:52 -0000	1.34
+++ sc/source/core/tool/interpr1.cxx	8 Aug 2005 12:38:09 -0000	1.34.4.2
@@ -210,7 +210,6 @@ void ScInterpreter::ScIfJump()
             {   // TRUE
                 if( nJumpCount >= 2 )
                 {   // THEN path
-                    nFuncFmtType = NUMBERFORMAT_UNDEFINED;
                     aCode.Jump( pJump[ 1 ], pJump[ nJumpCount ] );
                 }
                 else
@@ -224,7 +223,6 @@ void ScInterpreter::ScIfJump()
             {   // FALSE
                 if( nJumpCount == 3 )
                 {   // ELSE path
-                    nFuncFmtType = NUMBERFORMAT_UNDEFINED;
                     aCode.Jump( pJump[ 2 ], pJump[ nJumpCount ] );
                 }
                 else
@@ -3262,7 +3260,23 @@ void ScInterpreter::ScColumn()
 	{
 		double nVal;
 		if (nParamCount == 0)
+        {
 			nVal = aPos.Col() + 1;
+            if (bMatrixFormula)
+            {
+                SCCOL nCols;
+                SCROW nRows;
+                pMyFormulaCell->GetMatColsRows( nCols, nRows);
+                ScMatrixRef pResMat = GetNewMat( static_cast<SCSIZE>(nCols), 1);
+                if (pResMat)
+                {
+                    for (SCCOL i=0; i < nCols; ++i)
+                        pResMat->PutDouble( nVal + i, static_cast<SCSIZE>(i), 0);
+                    PushMatrix( pResMat);
+                    return;
+                }
+            }
+        }
 		else
 		{
 			switch ( GetStackType() )
@@ -3321,7 +3335,23 @@ void ScInterpreter::ScRow()
 	{
 		double nVal;
 		if (nParamCount == 0)
+        {
 			nVal = aPos.Row() + 1;
+            if (bMatrixFormula)
+            {
+                SCCOL nCols;
+                SCROW nRows;
+                pMyFormulaCell->GetMatColsRows( nCols, nRows);
+                ScMatrixRef pResMat = GetNewMat( 1, static_cast<SCSIZE>(nRows));
+                if (pResMat)
+                {
+                    for (SCROW i=0; i < nRows; i++)
+                        pResMat->PutDouble( nVal + i, 0, static_cast<SCSIZE>(i));
+                    PushMatrix( pResMat);
+                    return;
+                }
+            }
+        }
 		else
 		{
 			switch ( GetStackType() )
Index: sc/source/core/tool/interpr3.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/interpr3.cxx,v
retrieving revision 1.12
retrieving revision 1.12.136.1
diff -u -p -u -p -r1.12 -r1.12.136.1
--- sc/source/core/tool/interpr3.cxx	15 Nov 2004 16:35:44 -0000	1.12
+++ sc/source/core/tool/interpr3.cxx	20 Jul 2005 15:20:22 -0000	1.12.136.1
@@ -1084,7 +1084,12 @@ void ScInterpreter::ScPoissonDist()
 			if (lambda == 0.0)
 				PushInt(0);
 			else
-				PushDouble(exp(-lambda)*pow(lambda,x)/Fakultaet(x));
+			{
+				double fPoissonVar = 1.0;
+				for ( double f = 0.0; f < x; ++f )
+					fPoissonVar *= lambda / ( f + 1.0 );
+				PushDouble( fPoissonVar*exp( -lambda ) );
+			}
 		}
 		else											// Verteilung
 		{
Index: sc/source/core/tool/interpr5.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/interpr5.cxx,v
retrieving revision 1.15
retrieving revision 1.15.4.2
diff -u -p -u -p -r1.15 -r1.15.4.2
--- sc/source/core/tool/interpr5.cxx	29 Mar 2005 13:33:22 -0000	1.15
+++ sc/source/core/tool/interpr5.cxx	31 May 2005 18:48:31 -0000	1.15.4.2
@@ -77,10 +77,7 @@
 #include "scmatrix.hxx"
 #include "globstr.hrc"
 
-// STATIC DATA -----------------------------------------------------------
-
-#define SCdEpsilon                1.0E-7
-
+const double fInvEpsilon = 1.0E-7;
 
 // -----------------------------------------------------------------------
 
@@ -898,188 +895,160 @@ void ScInterpreter::MFastTrans(ScMatrix*
 			pR->PutDouble(pA->GetDouble(i, j), j, i);
 }
 
-BOOL ScInterpreter::MFastBackSubst(ScMatrix* pA, ScMatrix* pR, SCSIZE n, BOOL bIsUpper)
-        // Fuehrt Rueckwaertsersetzung der Dreickesmatrix Mat a nach Mat r durch
-		// 2 Versionen fuer obere (U)  oder untere (L- Unit) Dreiecksmatrizen
-{
-    if (!n)
-        return TRUE;
-        // Strange? that's how it was implemented with short i,j,k until
-        // 2004-03-17 (r1.8.202.4), provided that GetDouble(-1,-1) and
-        // PutDouble(...,-1,-1) silently did nothing..
 
-	if (!bIsUpper)							// L-Matrix, immer invertierbar
-	{
-		MEMat(pR, n);
-		for (SCSIZE i = 1; i < n; i++)
-		{
-			for (SCSIZE j = 0; j < i; j++)
-			{
-				double fSum = 0.0;
-				for (SCSIZE k = 0; k < i; k++)
-					fSum += pA->GetDouble(i,k) * pR->GetDouble(k,j);
-				pR->PutDouble(-fSum, i, j);
-			}
-		}
-	}
-	else									// U-Matrix
-	{
-        SCSIZE i, j, k;
-		for (i = 0; i < n; i++)							// Ist invertierbar?
-			if (fabs(pA->GetDouble(i,i)) < SCdEpsilon)
-				return FALSE;
-		pR->FillDoubleLowerLeft(0.0, n-1);                      // untere Haelfte
-		pR->PutDouble(1.0/pA->GetDouble(n-1, n-1), n-1, n-1);	// n-1, n-1
-		for (i = n-1; i-- > 0; )
-		{
-			for (j = n-1; j > i; j--)
-			{
-				double fSum = 0.0;
-				for (k = n-1; k > i; k--)
-					fSum += pA->GetDouble(i, k) * pR->GetDouble(k, j);
-				pR->PutDouble(-fSum/pA->GetDouble(i, i), i, j);
-			}
-			double fSum = 0.0;											// Hauptdiagonale:
-			for (k = n-1; k > i; k--)
-				fSum += pA->GetDouble(i, k) * pR->GetDouble(k, j);
-			pR->PutDouble((1.0-fSum)/pA->GetDouble(i, i), i, i);
-		}
-	}
-	return TRUE;
+/* Matrix LUP decomposition according to the pseudocode of "Introduction to
+ * Algorithms" by Cormen, Leiserson, Rivest, Stein.
+ *
+ * Added scaling for numeric stability.
+ *
+ * Given an n x n nonsingular matrix A, find a permutation matrix P, a unit
+ * lower-triangular matrix L, and an upper-triangular matrix U such that PA=LU.
+ * Compute L and U "in place" in the matrix A, the original content is
+ * destroyed. Note that the diagonal elements of the U triangular matrix
+ * replace the diagonal elements of the L-unit matrix (that are each ==1). The
+ * permutation matrix P is an array, where P[i]=j means that the i-th row of P
+ * contains a 1 in column j. Additionally keep track of the number of
+ * permutations (row exchanges).
+ *
+ * Returns 0 if a singular matrix is encountered, else +1 if an even number of
+ * permutations occured, or -1 if odd, which is the sign of the determinant.
+ * This may be used to calculate the determinant by multiplying the sign with
+ * the product of the diagonal elements of the LU matrix.
+ */
+static int lcl_LUP_decompose( ScMatrix* mA, const SCSIZE n,
+        ::std::vector< SCSIZE> & P )
+{
+    int nSign = 1;
+    // Find scale of each row.
+    ::std::vector< double> aScale(n);
+    for (SCSIZE i=0; i < n; ++i)
+    {
+        double fMax = 0.0;
+        for (SCSIZE j=0; j < n; ++j)
+        {
+            double fTmp = fabs( mA->GetDouble( j, i));
+            if (fMax < fTmp)
+                fMax = fTmp;
+        }
+        if (fMax == 0.0)
+            return 0;       // singular matrix
+        aScale[i] = 1.0 / fMax;
+    }
+    // Represent identity permutation, P[i]=i
+    for (SCSIZE i=0; i < n; ++i)
+        P[i] = i;
+    // "Recursion" on the diagonale.
+    SCSIZE l = n - 1;
+    for (SCSIZE k=0; k < l; ++k)
+    {
+        // Implicit pivoting. With the scale found for a row, compare values of
+        // a column and pick largest.
+        double fMax = 0.0;
+        double fScale = aScale[k];
+        SCSIZE kp = k;
+        for (SCSIZE i = k; i < n; ++i)
+        {
+            double fTmp = fScale * fabs( mA->GetDouble( k, i));
+            if (fMax < fTmp)
+            {
+                fMax = fTmp;
+                kp = i;
+            }
+        }
+        if (fMax == 0.0)
+            return 0;       // singular matrix
+        // Swap rows. The pivot element will be at mA[k,kp] (row,col notation)
+        if (k != kp)
+        {
+            // permutations
+            SCSIZE nTmp = P[k];
+            P[k]        = P[kp];
+            P[kp]       = nTmp;
+            nSign       = -nSign;
+            // scales
+            double fTmp = aScale[k];
+            aScale[k]   = aScale[kp];
+            aScale[kp]  = fTmp;
+            // elements
+            for (SCSIZE i=0; i < n; ++i)
+            {
+                double fTmp = mA->GetDouble( i, k);
+                mA->PutDouble( mA->GetDouble( i, kp), i, k);
+                mA->PutDouble( fTmp, i, kp);
+            }
+        }
+        // Compute Schur complement.
+        for (SCSIZE i = k+1; i < n; ++i)
+        {
+            double fTmp = mA->GetDouble( k, i) / mA->GetDouble( k, k);
+            mA->PutDouble( fTmp, k, i);
+            for (SCSIZE j = k+1; j < n; ++j)
+                mA->PutDouble( mA->GetDouble( j, i) - fTmp * mA->GetDouble( j,
+                            k), j, i);
+        }
+    }
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "\n%s\n", "lcl_LUP_decompose(): LU");
+    for (SCSIZE i=0; i < n; ++i)
+    {
+        for (SCSIZE j=0; j < n; ++j)
+            fprintf( stderr, "%8.2g  ", mA->GetDouble( j, i));
+        fprintf( stderr, "\n%s\n", "");
+    }
+    fprintf( stderr, "\n%s\n", "lcl_LUP_decompose(): P");
+    for (SCSIZE j=0; j < n; ++j)
+        fprintf( stderr, "%5u ", P[j]);
+    fprintf( stderr, "\n%s\n", "");
+#endif
+    return nSign;
 }
 
-BOOL ScInterpreter::ScMatLUP(ScMatrix* mA, SCSIZE m, SCSIZE p,
-							 ScMatrix* mL, ScMatrix* mU, ScMatrix* mP,
-							 ULONG& rPermutCounter, BOOL& bIsInvertable)
-	// Returnwert = False <=> Matrixarray voll
-	// BIsInvertable = False: <= mA hat nicht Rang m
-{
-	SCSIZE i, j;
-	if (m == 1)
-	{
-		mL->PutDouble(1.0,0,0);
-		for (j = 0; j < p; j++)
-			if (fabs(mA->GetDouble(0, j)) >= SCdEpsilon)
-				break;
-		if (j == p)
-		{
-			bIsInvertable = FALSE;
-			return TRUE;
-		}
-		MEMat(mP, p);
-		if (j > 0 && j < p)
-		{
-			mP->PutDouble(0.0, 0, 0);
-			mP->PutDouble(1.0, j, 0);
-			mP->PutDouble(0.0, j, j);
-			mP->PutDouble(1.0, 0, j);
-			rPermutCounter++;
-		}
-		MFastMult(mA, mP, mU, m, p, p);
-	}
-	else
-	{
-		SCSIZE md2 = m/2;
-		ScMatrixRef mB = GetNewMat(md2, p);
-		ScMatrixRef mC = GetNewMat(md2, p);
-		ScMatrixRef mL1 = GetNewMat(md2, md2);
-		ScMatrixRef mU1 = GetNewMat(md2, p);
-		ScMatrixRef mP1 = GetNewMat(p, p);
-		if (!mB || !mC || !mL1 || !mU1 || !mP1 )
-			return FALSE;
-		for (i = 0; i < md2; i++)
-		{
-			for (j = 0; j < p; j++)
-			{
-				mB->PutDouble(mA->GetDouble(i, j), i, j);
-				mC->PutDouble(mA->GetDouble(md2+i,j), i, j);
-			}
-		}
-		if (!ScMatLUP(mB, md2, p, mL1, mU1, mP1, rPermutCounter, bIsInvertable))
-			return FALSE;
-		if (!bIsInvertable)
-			return TRUE;
-
-		ScMatrixRef mE    = GetNewMat(md2, md2);
-		ScMatrixRef mF    = GetNewMat(md2, md2);
-		ScMatrixRef mEInv = GetNewMat(md2, md2);
-		ScMatrixRef mG    = GetNewMat(md2, p);
-		ScMatrixRef mGs   = GetNewMat(md2, p - md2);
-		ScMatrixRef mU2   = GetNewMat(md2, p - md2);
-		ScMatrixRef mP2   = GetNewMat(p - md2, p - md2);
-		if (!mP2 || !mU2 || !mGs|| !mG || !mEInv || !mF || !mE)
-			return FALSE;
-		MFastTrans(mP1, mP, p, p);				// mP = mP1 hoch  -1
-		ScMatrixRef mD = mB;						// mB wird nicht mehr gebraucht
-		MFastMult(mC, mP, mD, md2, p, p);
-		for (i = 0; i < md2; i++)
-		{
-			for (j = 0; j < md2; j++)
-			{
-				mE->PutDouble(mU1->GetDouble(i, j), i, j);
-				mF->PutDouble(mD->GetDouble(i, j), i, j);
-			}
-		}
-		BOOL bEInvok = MFastBackSubst(mE, mEInv, md2, TRUE); // MeInv = E hoch -1
-		if (!bEInvok)
-		{
-			bIsInvertable = FALSE;
-			return TRUE;
-		}
-		ScMatrixRef mFEInv = mE;				// mE wird nicht mehr gebraucht.
-		MFastMult(mF, mEInv, mFEInv, md2, md2, md2);
-		ScMatrixRef mFEInvU1 = mC;			// mC wird nicht mehr gebraucht
-		MFastMult(mFEInv, mU1, mFEInvU1, md2, md2, p);
-		MFastSub(mD, mFEInvU1, mG, md2, p);
-		for (i = 0; i < md2; i++)
-		{
-			for (j = 0; j < p-md2; j++)
-				mGs->PutDouble(mG->GetDouble(i, md2+j), i, j);
-		}
-		ScMatrixRef mL2 = mF;					// mF wird nicht mehr gebraucht
-		if (!ScMatLUP(mGs, md2, p - md2, mL2, mU2, mP2, rPermutCounter, bIsInvertable))
-			return FALSE;
-		if (!bIsInvertable)
-			return TRUE;
-
-		ScMatrixRef mP3 =  GetNewMat(p, p);
-		if (!mP3)
-			return FALSE;
-		MEMat(mP3, p);
-		for (i = md2; i < p; i++)
-		{
-			for (j = md2; j < p; j++)
-				mP3->PutDouble(mP2->GetDouble(i-md2, j-md2), i, j);
-		}
-		MFastMult(mP3, mP1, mP, p, p, p);		// Ergebnis P !!
-		ScMatrixRef mP3Inv = mP1;					// mP1 wird nicht mehr gebraucht;
-		MFastTrans(mP3, mP3Inv, p, p);
-		ScMatrixRef mH = mD;						// mD wird nicht mehr gebraucht
-		MFastMult(mU1, mP3Inv, mH, md2, p, p);
-		MEMat(mL, m);							// Ergebnis L :
-		for (i = 0; i < md2; i++)
-		{
-			for (j = 0; j < i; j++)
-				mL->PutDouble(mL1->GetDouble(i, j), i, j);
-		}
-		for (i = md2; i < m; i++)
-			for (j = md2; j < i; j++)
-				mL->PutDouble(mL2->GetDouble(i-md2, j-md2), i, j);
-		for (i = md2; i < m; i++)
-			for (j = 0; j < md2; j++)
-				mL->PutDouble(mFEInv->GetDouble(i-md2, j), i, j);
-												// Ergebnis U:
-		mU->FillDoubleLowerLeft(0.0, m-1);
-		for (i = 0; i < md2; i++)
-			for (j = i; j < p; j++)
-				mU->PutDouble(mH->GetDouble(i, j), i, j);
-		for (i = md2; i < m; i++)
-			for (j = i; j < p; j++)
-				mU->PutDouble(mU2->GetDouble(i - md2, j - md2), i, j);
-	}
-	return TRUE;
+
+/* Solve a LUP decomposed equation Ax=b. LU is a combined matrix of L and U
+ * triangulars and P the permutation vector as obtained from
+ * lcl_LUP_decompose(). B is the right-hand side input vector, X is used to
+ * return the solution vector.
+ */
+static void lcl_LUP_solve( const ScMatrix* mLU, const SCSIZE n,
+        const ::std::vector< SCSIZE> & P, const ::std::vector< double> & B,
+        ::std::vector< double> & X )
+{
+    SCSIZE nFirst = SCSIZE_MAX;
+    // Ax=b => PAx=Pb, with decomposition LUx=Pb.
+    // Define y=Ux and solve for y in Ly=Pb using forward substitution.
+    for (SCSIZE i=0; i < n; ++i)
+    {
+        double fSum = B[P[i]];
+        // Matrix inversion comes with a lot of zeros in the B vectors, we
+        // don't have to do all the computing with results multiplied by zero.
+        // Until then, simply lookout for the position of the first nonzero
+        // value.
+        if (nFirst != SCSIZE_MAX)
+        {
+            for (SCSIZE j = nFirst; j < i; ++j)
+                fSum -= mLU->GetDouble( j, i) * X[j];   // X[j] === y[j]
+        }
+        else if (fSum)
+            nFirst = i;
+        X[i] = fSum;                                    // X[i] === y[i]
+    }
+    // Solve for x in Ux=y using back substitution.
+    for (SCSIZE i = n; i--; )
+    {
+        double fSum = X[i];                             // X[i] === y[i]
+        for (SCSIZE j = i+1; j < n; ++j)
+            fSum -= mLU->GetDouble( j, i) * X[j];       // X[j] === x[j]
+        X[i] = fSum / mLU->GetDouble( i, i);            // X[i] === x[i]
+    }
+#if OSL_DEBUG_LEVEL >1
+    fprintf( stderr, "\n%s\n", "lcl_LUP_solve():");
+    for (SCSIZE i=0; i < n; ++i)
+        fprintf( stderr, "%8.2g  ", X[i]);
+    fprintf( stderr, "%s\n", "");
+#endif
 }
 
+
 void ScInterpreter::ScMatDet()
 {
 	if ( MustHaveParamCount( GetByte(), 1 ) )
@@ -1101,49 +1070,30 @@ void ScInterpreter::ScMatDet()
 			SetIllegalParameter();
 		else
 		{
-			double fVal = log((double)nC) / log(2.0);
-			if (fVal - floor(fVal) != 0.0)
-				fVal = floor(fVal) + 1.0;
-			SCSIZE nDim = static_cast<SCSIZE>(pow(2.0, fVal));
-			ScMatrixRef pU = GetNewMat(nDim, nDim);
-			ScMatrixRef pL = GetNewMat(nDim, nDim);
-			ScMatrixRef pP = GetNewMat(nDim, nDim);
-			ScMatrixRef pA;
-			if (nC == nDim)
-				pA = pMat;
-			else
-			{
-				pA = GetNewMat(nDim, nDim);
-				MEMat(pA, nDim);
-				for (SCSIZE i = 0; i < nC; i++)
-					for (SCSIZE j = 0; j < nC; j++)
-					{
-						pA->PutDouble(pMat->GetDouble(i, j), i, j);
-					}
-			}
-			ULONG nPermutCounter = 0;
-			BOOL bIsInvertable = TRUE;
-			BOOL bOk = ScMatLUP(pA, nDim, nDim, pL, pU, pP,
-								nPermutCounter, bIsInvertable);
-			if (bOk)
-			{
-				if (!bIsInvertable)
-					PushInt(0);
-				else
-				{
-					double fDet = 1.0;
-					for (SCSIZE i = 0; i < nC; i++)
-						fDet *= pU->GetDouble(i, i);
-					if (nPermutCounter % 2 != 0)
-						fDet *= -1.0;
-					PushDouble(fDet);
-				}
-			}
-			else
+            // LUP decomposition is done inplace, use copy.
+            ScMatrixRef xLU = pMat->Clone();
+            if (!xLU)
 			{
 				SetError(errCodeOverflow);
 				PushInt(0);
 			}
+            else
+            {
+                ::std::vector< SCSIZE> P(nR);
+                int nDetSign = lcl_LUP_decompose( xLU, nR, P);
+                if (!nDetSign)
+                    PushError();
+                else
+                {
+                    // In an LU matrix the determinant is simply the product of
+                    // all diagonal elements.
+                    double fDet = nDetSign;
+                    ScMatrix* pLU = xLU;
+                    for (SCSIZE i=0; i < nR; ++i)
+                        fDet *= pLU->GetDouble( i, i);
+                    PushDouble( fDet);
+                }
+            }
 		}
 	}
 }
@@ -1169,71 +1119,85 @@ void ScInterpreter::ScMatInv()
 			SetIllegalParameter();
 		else
 		{
-			double fVal = log((double)nC) / log(2.0);
-			if (fVal - floor(fVal) != 0.0)
-				fVal = floor(fVal) + 1.0;
-			SCSIZE nDim = static_cast<SCSIZE>(pow(2.0, fVal));
-			ScMatrixRef pU = GetNewMat(nDim, nDim);
-			ScMatrixRef pL = GetNewMat(nDim, nDim);
-			ScMatrixRef pP = GetNewMat(nDim, nDim);
-			ScMatrixRef pA;
-			if (nC == nDim)
-				pA = pMat;
-			else
-			{
-				pA = GetNewMat(nDim, nDim);
-				MEMat(pA, nDim);
-				for (SCSIZE i = 0; i < nC; i++)
-					for (SCSIZE j = 0; j < nC; j++)
-					{
-						pA->PutDouble(pMat->GetDouble(i, j), i, j);
-					}
-			}
-			ULONG nPermutCounter = 0;
-			BOOL bIsInvertable = TRUE;
-			BOOL bOk = ScMatLUP(pA, nDim, nDim, pL, pU, pP,
-								nPermutCounter, bIsInvertable);
-			if (bOk)
-			{
-				if (!bIsInvertable)
-					SetNoValue();
-				else
-				{
-					ScMatrixRef pUInv = GetNewMat(nDim, nDim);
-					if (!pUInv)
-						PushError();
-					else
-					{
-						bOk = MFastBackSubst(pU, pUInv, nDim, TRUE);
-						if (!bOk)
-							SetNoValue();
-						else
-						{
-							ScMatrixRef pPInv = pU;
-							MFastTrans(pP, pPInv, nDim, nDim);
-							ScMatrixRef pPInvUInv = pP;
-							MFastMult(pPInv, pUInv, pPInvUInv, nDim, nDim, nDim);
-							ScMatrixRef pLInv = pPInv;
-							MFastBackSubst(pL, pLInv, nDim, FALSE);
-							if (nDim == nC)
-								MFastMult(pPInvUInv, pLInv, pMat, nDim, nDim, nDim);
-							else
-							{
-								MFastMult(pPInvUInv, pLInv, pL, nDim, nDim, nDim);
-								for (SCSIZE i = 0; i < nC; i++)
-									for (SCSIZE j = 0; j < nC; j++)
-										pMat->PutDouble(pL->GetDouble(i, j), i, j);
-							}
-							PushMatrix(pMat);
-						}
-					}
-				}
-			}
-			else
+            // LUP decomposition is done inplace, use copy.
+            ScMatrixRef xLU = pMat->Clone();
+            // The result matrix.
+            ScMatrixRef xY = GetNewMat( nR, nR);
+            if (!xLU || !xY)
 			{
 				SetError(errCodeOverflow);
 				PushInt(0);
 			}
+            else
+            {
+                ::std::vector< SCSIZE> P(nR);
+                int nDetSign = lcl_LUP_decompose( xLU, nR, P);
+                if (!nDetSign)
+                    PushError();
+                else
+                {
+                    // Solve equation for each column.
+                    ScMatrix* pY = xY;
+                    ::std::vector< double> B(nR);
+                    ::std::vector< double> X(nR);
+                    for (SCSIZE j=0; j < nR; ++j)
+                    {
+                        for (SCSIZE i=0; i < nR; ++i)
+                            B[i] = 0.0;
+                        B[j] = 1.0;
+                        lcl_LUP_solve( xLU, nR, P, B, X);
+                        for (SCSIZE i=0; i < nR; ++i)
+                            pY->PutDouble( X[i], j, i);
+                    }
+#if 0
+                    /* Possible checks for ill-condition:
+                     * 1. Scale matrix, invert scaled matrix. If there are
+                     *    elements of the inverted matrix that are several
+                     *    orders of magnitude greater than 1 =>
+                     *    ill-conditioned.
+                     *    Just how much is "several orders"?
+                     * 2. Invert the inverted matrix and assess whether the
+                     *    result is sufficiently close to the original matrix.
+                     *    If not => ill-conditioned.
+                     *    Just what is sufficient?
+                     * 3. Multiplying the inverse by the original matrix should
+                     *    produce a result sufficiently close to the identity
+                     *    matrix.
+                     *    Just what is sufficient?
+                     *
+                     * The following is #3.
+                     */
+                    ScMatrixRef xR = GetNewMat( nR, nR);
+                    if (xR)
+                    {
+                        ScMatrix* pR = xR;
+                        MFastMult( pMat, pY, pR, nR, nR, nR);
+#if OSL_DEBUG_LEVEL > 1
+                        fprintf( stderr, "\n%s\n", "ScMatInv(): mult-identity");
+#endif
+                        for (SCSIZE i=0; i < nR; ++i)
+                        {
+                            for (SCSIZE j=0; j < nR; ++j)
+                            {
+                                double fTmp = pR->GetDouble( j, i);
+#if OSL_DEBUG_LEVEL > 1
+                                fprintf( stderr, "%8.2g  ", fTmp);
+#endif
+                                if (fabs( fTmp - (i == j)) > fInvEpsilon)
+                                    SetError( errIllegalArgument);
+                            }
+#if OSL_DEBUG_LEVEL > 1
+                        fprintf( stderr, "\n%s\n", "");
+#endif
+                        }
+                    }
+#endif
+                    if (nGlobalError)
+                        PushInt(0);
+                    else
+                        PushMatrix( pY);
+                }
+            }
 		}
 	}
 }
@@ -1509,9 +1473,9 @@ ScMatrixRef ScInterpreter::MatConcat(ScM
 		{
 			for (j = 0; j < nMinR; j++)
 			{
-                USHORT nErr = pMat1->GetError( i, j);
+                USHORT nErr = pMat1->GetErrorIfNotString( i, j);
                 if (!nErr)
-                    nErr = pMat2->GetError( i, j);
+                    nErr = pMat2->GetErrorIfNotString( i, j);
                 if (nErr)
                     pResMat->PutError( nErr, i, j);
                 else
@@ -1711,7 +1675,7 @@ void ScInterpreter::ScAmpersand()
             {
                 for ( SCSIZE i = 0; i < nCount; i++ )
                 {
-                    USHORT nErr = pMat->GetError( i);
+                    USHORT nErr = pMat->GetErrorIfNotString( i);
                     if (nErr)
                         pResMat->PutError( nErr, i);
                     else
@@ -1726,7 +1690,7 @@ void ScInterpreter::ScAmpersand()
             {
                 for ( SCSIZE i = 0; i < nCount; i++ )
                 {
-                    USHORT nErr = pMat->GetError( i);
+                    USHORT nErr = pMat->GetErrorIfNotString( i);
                     if (nErr)
                         pResMat->PutError( nErr, i);
                     else
Index: sc/source/core/tool/rangelst.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/rangelst.cxx,v
retrieving revision 1.5
retrieving revision 1.5.346.1
diff -u -p -u -p -r1.5 -r1.5.346.1
--- sc/source/core/tool/rangelst.cxx	4 Jun 2004 10:38:10 -0000	1.5
+++ sc/source/core/tool/rangelst.cxx	22 Apr 2005 14:37:56 -0000	1.5.346.1
@@ -674,6 +674,28 @@ BOOL ScRangePairList::UpdateReference( U
 }
 
 
+void ScRangePairList::DeleteOnTab( SCTAB nTab )
+{
+    // Delete entries that have the labels (first range) on nTab
+
+    ULONG nCount = Count();
+    ULONG nPos = 0;
+    while ( nPos < nCount )
+    {
+        ScRangePair* pR = GetObject( nPos );
+        ScRange aRange = pR->GetRange(0);
+        if ( aRange.aStart.Tab() == nTab && aRange.aEnd.Tab() == nTab )
+        {
+            Remove( nPos );
+            delete pR;
+            nCount = Count();
+        }
+        else
+            ++nPos;
+    }
+}
+
+
 ScRangePair* ScRangePairList::Find( const ScAddress& rAdr ) const
 {
 	ULONG nCount = Count();
Index: sc/source/core/tool/refupdat.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/refupdat.cxx,v
retrieving revision 1.3
retrieving revision 1.3.346.1
diff -u -p -u -p -r1.3 -r1.3.346.1
--- sc/source/core/tool/refupdat.cxx	4 Jun 2004 10:39:25 -0000	1.3
+++ sc/source/core/tool/refupdat.cxx	15 Jul 2005 10:15:11 -0000	1.3.346.1
@@ -59,12 +59,6 @@
  *
  ************************************************************************/
 
-#ifdef PCH
-#include "core_pch.hxx"
-#endif
-
-#pragma hdrstop
-
 // INCLUDE ---------------------------------------------------------------
 
 #include <tools/debug.hxx>
@@ -183,8 +177,8 @@ void lcl_MoveItWrap( R& rRef, S nDelta, 
 }
 
 template< typename R, typename S, typename U >
-BOOL lcl_MoveRefPart( R& rRef1Val, BOOL& rRef1Del,
-					  R& rRef2Val, BOOL& rRef2Del,
+BOOL lcl_MoveRefPart( R& rRef1Val, BOOL& rRef1Del, BOOL bDo1,
+					  R& rRef2Val, BOOL& rRef2Del, BOOL bDo2,
 					  U nStart, U nEnd, S nDelta, U nMask )
 {
 	if ( nDelta )
@@ -192,35 +186,44 @@ BOOL lcl_MoveRefPart( R& rRef1Val, BOOL&
 		BOOL bDel, bCut1, bCut2;
 		bDel = bCut1 = bCut2 = FALSE;
 		S n;
-		if ( nDelta < 0 )
-		{
-			n = nStart + nDelta;
-			if ( n <= rRef1Val && rRef1Val < nStart
-			  && n <= rRef2Val && rRef2Val < nStart )
-				bDel = TRUE;
-		}
-		else
-		{
-			n = nEnd + nDelta;
-			if ( nEnd < rRef1Val && rRef1Val <= n
-			  && nEnd < rRef2Val && rRef2Val <= n )
-				bDel = TRUE;
-		}
+        if (bDo1 && bDo2)
+        {
+            if ( nDelta < 0 )
+            {
+                n = nStart + nDelta;
+                if ( n <= rRef1Val && rRef1Val < nStart
+                  && n <= rRef2Val && rRef2Val < nStart )
+                    bDel = TRUE;
+            }
+            else
+            {
+                n = nEnd + nDelta;
+                if ( nEnd < rRef1Val && rRef1Val <= n
+                  && nEnd < rRef2Val && rRef2Val <= n )
+                    bDel = TRUE;
+            }
+        }
 		if ( bDel )
-		{	// geloeschte mitverschieben
-			rRef1Val += nDelta;
-			rRef2Val += nDelta;
+		{	// move deleted along
+            rRef1Val += nDelta;
+            rRef2Val += nDelta;
 		}
 		else
 		{
-			if ( rRef1Del )
-				rRef1Val += nDelta;
-			else
-				bCut1 = lcl_MoveStart( rRef1Val, nStart, nDelta, nMask );
-			if ( rRef2Del )
-				rRef2Val += nDelta;
-			else
-				bCut2 = lcl_MoveEnd( rRef2Val, nStart, nDelta, nMask );
+            if (bDo1)
+            {
+                if ( rRef1Del )
+                    rRef1Val += nDelta;
+                else
+                    bCut1 = lcl_MoveStart( rRef1Val, nStart, nDelta, nMask );
+            }
+            if (bDo2)
+            {
+                if ( rRef2Del )
+                    rRef2Val += nDelta;
+                else
+                    bCut2 = lcl_MoveEnd( rRef2Val, nStart, nDelta, nMask );
+            }
 		}
 		if ( bDel || (bCut1 && bCut2) )
 			rRef1Del = rRef2Del = TRUE;
@@ -524,11 +527,10 @@ ScRefUpdateRes ScRefUpdate::Update( Upda
 }
 
 
-// vor dem Aufruf muessen die Abs-Refs aktualisiert werden!
 ScRefUpdateRes ScRefUpdate::Update( ScDocument* pDoc, UpdateRefMode eMode,
 									const ScAddress& rPos, const ScRange& r,
 									SCsCOL nDx, SCsROW nDy, SCsTAB nDz,
-									ComplRefData& rRef )
+									ComplRefData& rRef, WhatType eWhat )
 {
 	ScRefUpdateRes eRet = UR_NOTHING;
 
@@ -571,8 +573,12 @@ ScRefUpdateRes ScRefUpdate::Update( ScDo
 		{
 			BOOL bExp = (bExpand && !bInDeleteUndo && IsExpand( rRef.Ref1.nCol,
 				rRef.Ref2.nCol, nCol1, nDx ));
-			if ( lcl_MoveRefPart( rRef.Ref1.nCol, bRef1ColDel,
-								  rRef.Ref2.nCol, bRef2ColDel,
+            BOOL bDo1 = (eWhat == ScRefUpdate::ALL || (eWhat ==
+                        ScRefUpdate::ABSOLUTE && !rRef.Ref1.IsColRel()));
+            BOOL bDo2 = (eWhat == ScRefUpdate::ALL || (eWhat ==
+                        ScRefUpdate::ABSOLUTE && !rRef.Ref2.IsColRel()));
+			if ( lcl_MoveRefPart( rRef.Ref1.nCol, bRef1ColDel, bDo1,
+								  rRef.Ref2.nCol, bRef2ColDel, bDo2,
 								  nCol1, nCol2, nDx, MAXCOL ) )
 			{
 				eRet = UR_UPDATED;
@@ -609,8 +615,12 @@ ScRefUpdateRes ScRefUpdate::Update( ScDo
 		{
 			BOOL bExp = (bExpand && !bInDeleteUndo && IsExpand( rRef.Ref1.nRow,
 				rRef.Ref2.nRow, nRow1, nDy ));
-			if ( lcl_MoveRefPart( rRef.Ref1.nRow, bRef1RowDel,
-								rRef.Ref2.nRow, bRef2RowDel,
+            BOOL bDo1 = (eWhat == ScRefUpdate::ALL || (eWhat ==
+                        ScRefUpdate::ABSOLUTE && !rRef.Ref1.IsRowRel()));
+            BOOL bDo2 = (eWhat == ScRefUpdate::ALL || (eWhat ==
+                        ScRefUpdate::ABSOLUTE && !rRef.Ref2.IsRowRel()));
+			if ( lcl_MoveRefPart( rRef.Ref1.nRow, bRef1RowDel, bDo1,
+								rRef.Ref2.nRow, bRef2RowDel, bDo2,
 								nRow1, nRow2, nDy, MAXROW ) )
 			{
 				eRet = UR_UPDATED;
@@ -648,8 +658,12 @@ ScRefUpdateRes ScRefUpdate::Update( ScDo
 			BOOL bExp = (bExpand && !bInDeleteUndo && IsExpand( rRef.Ref1.nTab,
 				rRef.Ref2.nTab, nTab1, nDz ));
 			SCTAB nMaxTab = pDoc->GetTableCount() - 1;
-			if ( lcl_MoveRefPart( rRef.Ref1.nTab, bRef1TabDel,
-								  rRef.Ref2.nTab, bRef2TabDel,
+            BOOL bDo1 = (eWhat == ScRefUpdate::ALL || (eWhat ==
+                        ScRefUpdate::ABSOLUTE && !rRef.Ref1.IsTabRel()));
+            BOOL bDo2 = (eWhat == ScRefUpdate::ALL || (eWhat ==
+                        ScRefUpdate::ABSOLUTE && !rRef.Ref2.IsTabRel()));
+			if ( lcl_MoveRefPart( rRef.Ref1.nTab, bRef1TabDel, bDo1,
+								  rRef.Ref2.nTab, bRef2TabDel, bDo2,
 								  nTab1, nTab2, nDz, nMaxTab ) )
 			{
 				eRet = UR_UPDATED;
@@ -687,7 +701,8 @@ ScRefUpdateRes ScRefUpdate::Update( ScDo
 				)
 				eRet = UR_UPDATED;
 		}
-		rRef.CalcRelFromAbs( rPos );
+        if (eWhat != ScRefUpdate::ABSOLUTE)
+            rRef.CalcRelFromAbs( rPos );
 	}
 	else
 	{
@@ -707,21 +722,22 @@ ScRefUpdateRes ScRefUpdate::Update( ScDo
 				rRef.Ref1.SetFlag3D( TRUE );
 				rRef.Ref2.SetFlag3D( TRUE );
 				eRet = UR_UPDATED;
-				rRef.CalcRelFromAbs( rPos );
+                if (eWhat != ScRefUpdate::ABSOLUTE)
+                    rRef.CalcRelFromAbs( rPos );
 			}
-			else
+			else if (eWhat != ScRefUpdate::ABSOLUTE)
 				rRef.CalcRelFromAbs( rPos );
 		}
 		else if( eMode == URM_COPY && r.In( rPos ) )
 			eRet = Move( pDoc, rPos, nDx, nDy, nDz, rRef, FALSE, FALSE );		// nur relative
 			// sollte nicht mehr verwendet werden muessen
-		else
+		else if (eWhat != ScRefUpdate::ABSOLUTE)
 			rRef.CalcRelFromAbs( rPos );
 	}
 	return eRet;
 }
 
-// vor dem Aufruf muessen die Abs-Refs aktualisiert werden!
+
 ScRefUpdateRes ScRefUpdate::Move( ScDocument* pDoc, const ScAddress& rPos,
 								  SCsCOL nDx, SCsROW nDy, SCsTAB nDz,
 								  ComplRefData& rRef, BOOL bWrap, BOOL bAbsolute )
@@ -896,7 +912,7 @@ void ScRefUpdate::DoTranspose( SCsCOL& r
             static_cast<SCsCOLROW>(nRelX));
 }
 
-// vor dem Aufruf muessen die Abs-Refs aktualisiert werden!
+
 ScRefUpdateRes ScRefUpdate::UpdateTranspose( ScDocument* pDoc,
 								const ScRange& rSource, const ScAddress& rDest,
 								ComplRefData& rRef )
@@ -918,7 +934,7 @@ ScRefUpdateRes ScRefUpdate::UpdateTransp
 //	UpdateGrow - erweitert Referenzen, die genau auf den Bereich zeigen
 //	kommt ohne Dokument aus
 
-// vor dem Aufruf muessen die Abs-Refs aktualisiert werden!
+
 ScRefUpdateRes ScRefUpdate::UpdateGrow( const ScRange& rArea, SCCOL nGrowX, SCROW nGrowY,
 										ComplRefData& rRef )
 {
Index: sc/source/filter/excel/biffdump.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/biffdump.cxx,v
retrieving revision 1.78
retrieving revision 1.78.4.7
diff -u -p -u -p -r1.78 -r1.78.4.7
--- sc/source/filter/excel/biffdump.cxx	29 Mar 2005 13:35:36 -0000	1.78
+++ sc/source/filter/excel/biffdump.cxx	10 Aug 2005 14:41:40 -0000	1.78.4.7
@@ -280,7 +280,7 @@ inline static void __AddDec( ByteString&
 	__AddDec( r, ( INT32 ) n );
 }
 
-inline static void __AddDec( ByteString& r, INT8 n )
+inline static void __AddDec( ByteString& r, sal_Int8 n )
 {
     __AddDec( r, ( INT32 ) n );
 }
@@ -1114,25 +1114,34 @@ void Biff8RecDumper::RecDump( BOOL bSubS
             break;
 			case 0x17:
 			{
-				UINT16	n;
-				rIn >> n;
-				ADDTEXT( "# of XTI: " );
-				__AddDec( t, n );
-				PRINT();
-				UINT16	nSB, nF, nL;
-                while( n && rIn.IsValid() )
-				{
-					LINESTART();
-					rIn >> nSB >> nF >> nL;
-					ADDTEXT( "Supbook = " );
-					__AddDec( t, nSB );
-					ADDTEXT( "    Tab = " );
-					__AddDec( t, nF );
-					ADDTEXT( " ... " );
-					__AddDec( t, nL );
-					PRINT();
-					n--;
-				}
+                if( mnSubstream == EXC_BOF_WORKSPACE )
+                {
+                    ADDTEXT( "filename=" );
+                    AddUNICODEString( t, rIn );
+                    PRINT();
+                }
+                else
+                {
+                    UINT16  n;
+                    rIn >> n;
+                    ADDTEXT( "# of XTI: " );
+                    __AddDec( t, n );
+                    PRINT();
+                    UINT16  nSB, nF, nL;
+                    while( n && rIn.IsValid() )
+                    {
+                        LINESTART();
+                        rIn >> nSB >> nF >> nL;
+                        ADDTEXT( "Supbook = " );
+                        __AddDec( t, nSB );
+                        ADDTEXT( "    Tab = " );
+                        __AddDec( t, nF );
+                        ADDTEXT( " ... " );
+                        __AddDec( t, nL );
+                        PRINT();
+                        n--;
+                    }
+                }
 			}
 			break;
             case 0x0018:
@@ -1511,6 +1520,32 @@ void Biff8RecDumper::RecDump( BOOL bSubS
 				PRINT();
 			}
 			break;
+            case 0x003D:        // WINDOW1
+            {
+                LINESTART();
+                ADDTEXT( "pos-x=" );            ADDDEC( 2 );
+                ADDTEXT( "   pos-y=" );         ADDDEC( 2 );
+                ADDTEXT( "   width=" );         ADDDEC( 2 );
+                ADDTEXT( "   height=" );        ADDDEC( 2 );
+                PRINT();
+                LINESTART();
+                rIn >> __nFlags;
+                STARTFLAG();
+                ADDFLAG( 0x0001, "hide-window" );
+                ADDFLAG( 0x0002, "min-window" );
+                ADDFLAG( 0x0008, "show-hscroll" );
+                ADDFLAG( 0x0010, "show-vscroll" );
+                ADDFLAG( 0x0020, "show-tabbar" );
+                ADDRESERVED( 0xFFC4 );
+                PRINT();
+                LINESTART();
+                ADDTEXT( "active-tab=" );       ADDDEC( 2 );
+                ADDTEXT( "   first-vis-tab=" ); ADDDEC( 2 );
+                ADDTEXT( "   selected-tabs=" ); ADDDEC( 2 );
+                ADDTEXT( "   tabbar-width=" );  ADDDEC( 2 );
+                PRINT();
+            }
+            break;
             case 0x0041:        // PANE
             {
                 LINESTART();
@@ -2635,7 +2670,7 @@ void Biff8RecDumper::RecDump( BOOL bSubS
 			case 0xEB:
 			case 0xEC:
 			case 0xED:
-				EscherDump( nL );
+                EscherDump( nL, true );
 			break;
             case 0x00F6:        // SXNAME
             {
@@ -4140,11 +4175,10 @@ void Biff8RecDumper::RecDump( BOOL bSubS
 				PRINT();
 				LINESTART();
 				ADDTEXT( "substream type:      " );
-				UINT16	n;
-				rIn >> n;
-				__AddHex( t, n );
+                rIn >> mnSubstream;
+                __AddHex( t, mnSubstream );
 				ADDTEXT( " (" );
-				switch( n )
+                switch( mnSubstream )
 				{
 					case 0x0005:	p = "Workbook globals";				break;
 					case 0x0006:	p = "Visual Basic module";			break;
@@ -4158,6 +4192,7 @@ void Biff8RecDumper::RecDump( BOOL bSubS
 				ADDTEXT( ")" );
 				PRINT();
 				LINESTART();
+                UINT16  n;
 				rIn >> n;
 				ADDTEXT( "build identifier:    ");
 				__AddHex( t, n );
@@ -4829,12 +4864,34 @@ void Biff8RecDumper::RecDump( BOOL bSubS
 			case 0x1048:		// ChartSbaseref
 				ContDump( nL );
 				break;
-			case 0x104A:		// ChartSerparent
-				ContDump( nL );
-				break;
-			case 0x104B:		// ChartSerauxtrend
-				ContDump( nL );
-				break;
+            case 0x104A:        // CHSERPARENT
+                LINESTART();
+                ADDTEXT( "parent-index=" );     ADDDEC( 2 );
+                ADDTEXT( " (one-based)" );
+                PRINT();
+            break;
+            case 0x104B:        // CHSERTRENDLINE
+            {
+                static const sal_Char* const ppcType[] =
+                    { "poynomial", "exponential", "logarithmic", "power", "moving-avg" };
+                sal_uInt8 nType;
+                rIn >> nType;
+                LINESTART();
+                ADDTEXT( "line-type=" );        __AddDec( t, nType );
+                lcl_AddEnum( t, nType, ppcType, STATIC_TABLE_SIZE( ppcType ) );
+                ADDTEXT( "   order=" );         ADDDEC( 1 );
+                ADDTEXT( "   intercept=" );     ADDDOUBLE();
+                PRINT();
+                LINESTART();
+                ADDTEXT( "show-equation=" );    ADDDEC( 1 );
+                ADDTEXT( "   show-r-sqr=" );    ADDDEC( 1 );
+                PRINT();
+                LINESTART();
+                ADDTEXT( "forecast-for=" );     ADDDOUBLE();
+                ADDTEXT( "   forecast-back=" ); ADDDOUBLE();
+                PRINT();
+            }
+            break;
 			case 0x104E:		// ChartIfmt
 				ContDump( nL );
 				break;
@@ -4916,9 +4973,28 @@ void Biff8RecDumper::RecDump( BOOL bSubS
 				FormulaDump( n, FT_CellFormula );
 			}
 				break;
-			case 0x105B:		// ChartSerauxerrbar
-				ContDump( nL );
-				break;
+            case 0x105B:        // CHSERERRORBAR
+            {
+                static const sal_Char* const ppcType[] = { 0, "x-plus", "x-minus", "y-plus", "y-minus" };
+                static const sal_Char* const ppcSource[] = { 0, "percent", "fixed", "std-dev", "custom", "std-error" };
+                static const sal_Char* const ppcLineEnd[] = { "blank", "t-shape" };
+                sal_uInt8 nType, nSource, nLineEnd;
+                rIn >> nType >> nSource >> nLineEnd;
+                LINESTART();
+                ADDTEXT( "bar-type=" );         __AddDec( t, nType );
+                lcl_AddEnum( t, nType, ppcType, STATIC_TABLE_SIZE( ppcType ) );
+                ADDTEXT( "   value-source=" );  __AddDec( t, nSource );
+                lcl_AddEnum( t, nSource, ppcSource, STATIC_TABLE_SIZE( ppcSource ) );
+                ADDTEXT( "   line-end=" );      __AddDec( t, nLineEnd );
+                lcl_AddEnum( t, nLineEnd, ppcLineEnd, STATIC_TABLE_SIZE( ppcLineEnd ) );
+                PRINT();
+                LINESTART();
+                ADDTEXT( "reserved=" );         ADDHEX( 1 );
+                ADDTEXT( "   value=" );         ADDDOUBLE();
+                ADDTEXT( "   ref-count=" );     ADDDEC( 2 );
+                PRINT();
+            }
+            break;
 			case 0x105D:		// ChartSerfmt
 				ContDump( nL );
 				break;
@@ -5035,7 +5111,7 @@ void Biff8RecDumper::RecDump( BOOL bSubS
 				ContDump( nL );
 				break;
 			case 0x1066:		// ChartGelframe
-                EscherDump( nL );
+                EscherDump( nL, false );
 				break;
 			case 0x1067:		// ChartBoppcustom
 				ContDump( nL );
@@ -5148,7 +5224,7 @@ static const sal_Char* GetBlipType( UINT
 	}
 }
 
-void Biff8RecDumper::EscherDump( const ULONG nMaxLen )
+void Biff8RecDumper::EscherDump( const ULONG nMaxLen, bool bDumpOffset )
 {
 	ULONG			n = nMaxLen;
 	UINT16			nPre, nR;
@@ -5159,8 +5235,10 @@ void Biff8RecDumper::EscherDump( const U
 
 	aT += pLevelPre;
 
+    ULONG nStartPos = pIn->GetSvStreamPos();
     while( pIn->IsValid() && (n > 0) )
 	{
+        ULONG nCurrPos = pIn->GetSvStreamPos();
 		*pIn >> nPre >> nR >> nL;
 		n -= sizeof( nPre ) + sizeof( nR ) + sizeof( nL );
 
@@ -5215,6 +5293,11 @@ void Biff8RecDumper::EscherDump( const U
 		__AddHex( aT, nL );
 		aT += "]  instance: ";
 		__AddDec( aT, (UINT16)(nPre >> 4) );
+        if( bDumpOffset )
+        {
+            aT.Append( "   pos=" );
+            __AddHex( aT, static_cast< sal_uInt32 >( mnEscherPos + nCurrPos - nStartPos ) );
+        }
 		Print( aT );
 
 		if ( nR == 0xF007 && 36 <= n && 36 <= nL )
@@ -5319,6 +5402,17 @@ void Biff8RecDumper::EscherDump( const U
 			n -= nC;
 			nL -= nC;
 		}
+        else if ( nR == 0xF00A )
+        {
+            sal_uInt32 nId, nFlags;
+            *pIn >> nId >> nFlags;
+            aT.Assign( "    shape-id=" );
+            __AddHex( aT, nId );
+            aT.Append( "   flags=" );
+            __AddHex( aT, nFlags );
+            Print( aT );
+            nL -= 8; n -= 8;
+        }
         else if ( nR == 0xF00B || nR == 0xF122 )
 		{	// OPT
             sal_uInt32 nComplex = 0;
@@ -5400,6 +5494,8 @@ void Biff8RecDumper::EscherDump( const U
 
 		aT.Erase();
 	}
+    if( bDumpOffset )
+        mnEscherPos += nMaxLen;
 }
 
 
@@ -8604,11 +8700,13 @@ void Biff8RecDumper::AddError( const UIN
 Biff8RecDumper::Biff8RecDumper( const XclImpRoot& rRoot, BOOL _bBIFF8 ) :
     XclImpRoot( rRoot ),
     bBIFF8( _bBIFF8 ),
-    bEncrypted( false )
+    bEncrypted( false ),
+    mnEscherPos( 0 )
 {
 	nXFCount = 0;
 	nFontIndex = 0;
 	nInstances++;
+    mnSubstream = EXC_BOF_UNKNOWN;
 
 	if( !pCharType )
 	{
@@ -8808,7 +8906,7 @@ BOOL Biff8RecDumper::Dump( XclImpStream&
 
 		while( r.StartNextRecord() )
 		{
-            pProgress->Progress( r.GetSvStreamPos() );
+            pProgress->ProgressAbs( r.GetSvStreamPos() );
 
             if( HasModeDump( r.GetRecId() ) )
                 RecDump();
Index: sc/source/filter/excel/colrowst.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/colrowst.cxx,v
retrieving revision 1.27
retrieving revision 1.27.4.1
diff -u -p -u -p -r1.27 -r1.27.4.1
--- sc/source/filter/excel/colrowst.cxx	29 Mar 2005 13:36:04 -0000	1.27
+++ sc/source/filter/excel/colrowst.cxx	19 Apr 2005 14:53:26 -0000	1.27.4.1
@@ -288,6 +288,10 @@ void XclImpColRowSettings::SetHiddenFlag
                 rDoc.SetRowFlags( nScRow, nScTab, rDoc.GetRowFlags( nScRow, nScTab ) | CR_FILTERED );
         }
     }
+
+    // #i47438# if default row format is hidden, hide remaining rows
+    if( (nDefHeight == 0) && (nMaxRow < MAXROW) )
+        rDoc.ShowRows( nMaxRow + 1, MAXROW, nScTab, FALSE );
 }
 
 
Index: sc/source/filter/excel/excdoc.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excdoc.cxx,v
retrieving revision 1.59
retrieving revision 1.59.36.1
diff -u -p -u -p -r1.59 -r1.59.36.1
--- sc/source/filter/excel/excdoc.cxx	21 Feb 2005 13:22:53 -0000	1.59
+++ sc/source/filter/excel/excdoc.cxx	6 Jun 2005 15:06:49 -0000	1.59.36.1
@@ -251,6 +251,7 @@ void ExcTable::FillAsHeader( ExcBoundshe
     else
     {
         Add( new Exc1904( rDoc ) );
+        Add( new XclExpBoolRecord( 0x000E, !rDoc.GetDocOptions().IsCalcAsShown() ) );
         Add( new ExcDummy8_041 );
     }
 
Index: sc/source/filter/excel/excform.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excform.cxx,v
retrieving revision 1.34
retrieving revision 1.34.36.3
diff -u -p -u -p -r1.34 -r1.34.36.3
--- sc/source/filter/excel/excform.cxx	21 Feb 2005 13:23:38 -0000	1.34
+++ sc/source/filter/excel/excform.cxx	20 Jun 2005 13:18:34 -0000	1.34.36.3
@@ -378,43 +378,7 @@ ConvErr ExcelToSc::Convert( const ScToke
 				aPool >> aStack;
 				break;
 			case 0x11: // Range									[314 265]
-			{
-                aStack >> nMerk0;
-                aPool << aStack << ocRange << nMerk0;
-                aPool >> aStack;
-#if 0
-				// wenn erster und zweiter Ausdruck auf'm Stack Single Referenzen
-				// sind, dann Area Reference erzeugen, ansonsten Fehlerhaften Aus-
-				// druck generieren
-				BOOL	bErrorToken = TRUE;
-				TokenId	nMerk1;
-
-				aStack >> nMerk0;
-				aStack >> nMerk1;
-
-				if( aPool.GetType( nMerk0 ) == T_RefC &&
-					aPool.GetType( nMerk1 ) == T_RefC )
-				{
-					register const SingleRefData *pRef1 = aPool.GetSRD( nMerk1 );
-					register const SingleRefData *pRef2 = aPool.GetSRD( nMerk0 );
-					if( pRef1 && pRef2 )
-					{
-						aCRD.Ref1 = *pRef1;
-						aCRD.Ref2 = *pRef2;
-						aStack << aPool.Store( aCRD );
-						bErrorToken = FALSE;
-					}
-				}
-
-				if( bErrorToken )
-				{
-					aPool << ocNoName << ocOpen << nMerk1 << ocSep
-						<< nMerk0 << ocClose;
-
-					aPool >> aStack;
-				}
-#endif
-			}
+                PushRangeOperator();
 				break;
 			case 0x12: // Unary Plus							[312 264]
                 aPool << ocAdd << aStack;
@@ -500,14 +464,14 @@ ConvErr ExcelToSc::Convert( const ScToke
 				DefTokenId			eOc;
 				switch( nByte )
 				{
-					case 0x00:
-					case 0x07:
-					case 0x17:
-					case 0x1D:
-					case 0x24:		eOc = ocStop;		break;
-					case 0x0F:
-					case 0x2A:		eOc = ocNoValue;	break;
-					default:		eOc = ocNoName;
+                    case EXC_ERR_NULL:
+                    case EXC_ERR_DIV0:
+                    case EXC_ERR_VALUE:
+                    case EXC_ERR_REF:
+                    case EXC_ERR_NAME:
+                    case EXC_ERR_NUM:   eOc = ocStop;       break;
+                    case EXC_ERR_NA:    eOc = ocNoValue;    break;
+                    default:            eOc = ocNoName;
 				}
 				aPool << eOc;
 				if( eOc != ocStop )
@@ -1535,6 +1499,37 @@ void ExcelToSc::ExcRelToScRel( UINT16 nR
 }
 
 
+void ExcelToSc::PushRangeOperator()
+{
+    // #i48496# try to convert the term singleref:singleref to a range reference
+    bool bIsConstRange = false;
+    TokenId nTokId0, nTokId1;
+    aStack >> nTokId0;
+    aStack >> nTokId1;
+
+    if( (aPool.GetType( nTokId0 ) == T_RefC) && (aPool.GetType( nTokId1 ) == T_RefC) )
+    {
+        const SingleRefData* pRef1 = aPool.GetSRD( nTokId1 );
+        const SingleRefData* pRef2 = aPool.GetSRD( nTokId0 );
+        if( pRef1 && pRef2 )
+        {
+            ComplRefData aRangeRef;
+            aRangeRef.InitFlags();
+            aRangeRef.Ref1 = *pRef1;
+            aRangeRef.Ref2 = *pRef2;
+            aStack << aPool.Store( aRangeRef );
+            bIsConstRange = true;
+        }
+    }
+
+    if( !bIsConstRange )
+    {
+        aPool << nTokId1 << ocRange << nTokId0;
+        aPool >> aStack;
+    }
+}
+
+
 const ScTokenArray* ExcelToSc::GetBoolErr( XclBoolError eType )
 {
 	UINT16					nError;
@@ -1547,7 +1542,7 @@ const ScTokenArray* ExcelToSc::GetBoolEr
 	{
         case xlErrNull:     eOc = ocStop;       nError = errNoCode;             break;
         case xlErrDiv0:     eOc = ocStop;       nError = errIllegalFPOperation; break;
-        case xlErrValue:    eOc = ocNoValue;    nError = NOVALUE;               break;
+        case xlErrValue:    eOc = ocStop;       nError = errNoValue;            break;
         case xlErrRef:      eOc = ocStop;       nError = errNoRef;              break;
         case xlErrName:     eOc = ocStop;       nError = errNoName;             break;
         case xlErrNum:      eOc = ocStop;       nError = errIllegalFPOperation; break;
@@ -1658,20 +1653,7 @@ BOOL ExcelToSc::SetCurVal( ScFormulaCell
 				rCell.SetDouble( rfCurVal );
 				break;
 			case 2:		// Error
-			{
-				switch( nVal )
-				{// nInd temp. missbrauchen
-					case 0x00:	nInd = errNoCode; break;			// #NULL!
-					case 0x07:	nInd = errIllegalFPOperation; break;// #DIV/0!
-					case 0x0F:	nInd = NOVALUE; break;				// #VALUE!
-					case 0x17:	nInd = errNoRef; break;				// #REF!
-					case 0x1D:	nInd = errNoName; break;			// #NAME?
-					case 0x24:	nInd = errIllegalFPOperation; break;// #NUM!
-					case 0x2A:	nInd = NOVALUE; break;				// #N/A
-					default:	nInd = errIllegalArgument;
-				}
-				rCell.SetErrCode( nInd );
-			}
+                rCell.SetErrCode( XclTools::GetScErrorCode( nVal ) );
 				break;
 		}
 	}
Index: sc/source/filter/excel/excform8.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excform8.cxx,v
retrieving revision 1.35
retrieving revision 1.34.36.3
diff -u -p -u -p -r1.35 -r1.34.36.3
--- sc/source/filter/excel/excform8.cxx	28 Jun 2005 15:28:40 -0000	1.35
+++ sc/source/filter/excel/excform8.cxx	20 Jun 2005 13:12:30 -0000	1.34.36.3
@@ -233,43 +233,7 @@ ConvErr ExcelToSc8::Convert( const ScTok
 				aPool >> aStack;
 				break;
 			case 0x11: // Range									[314 265]
-			{
-                aStack >> nMerk0;
-                aPool << aStack << ocRange << nMerk0;
-                aPool >> aStack;
-#if 0
-				// wenn erster und zweiter Ausdruck auf'm Stack Single Referenzen
-				// sind, dann Area Reference erzeugen, ansonsten Fehlerhaften Aus-
-				// druck generieren
-				BOOL	bErrorToken = TRUE;
-				TokenId	nMerk1;
-
-				aStack >> nMerk0;
-				aStack >> nMerk1;
-
-				if( aPool.GetType( nMerk0 ) == T_RefC &&
-					aPool.GetType( nMerk1 ) == T_RefC )
-				{
-					register const SingleRefData *pRef1 = aPool.GetSRD( nMerk1 );
-					register const SingleRefData *pRef2 = aPool.GetSRD( nMerk0 );
-					if( pRef1 && pRef2 )
-					{
-						aCRD.Ref1 = *pRef1;
-						aCRD.Ref2 = *pRef2;
-						aStack << aPool.Store( aCRD );
-						bErrorToken = FALSE;
-					}
-				}
-
-				if( bErrorToken )
-				{
-					aPool << ocNoName << ocOpen << nMerk1 << ocSep
-						<< nMerk0 << ocClose;
-
-					aPool >> aStack;
-				}
-#endif
-			}
+                PushRangeOperator();
 				break;
 			case 0x12: // Unary Plus							[312 264]
                 aPool << ocAdd << aStack;
@@ -401,14 +365,14 @@ ConvErr ExcelToSc8::Convert( const ScTok
 				DefTokenId			eOc;
 				switch( nByte )
 				{
-					case 0x00:
-					case 0x07:
-					case 0x17:
-					case 0x1D:
-					case 0x24:		eOc = ocStop;		break;
-					case 0x0F:
-					case 0x2A:		eOc = ocNoValue;	break;
-					default:		eOc = ocNoName;
+                    case EXC_ERR_NULL:
+                    case EXC_ERR_DIV0:
+                    case EXC_ERR_VALUE:
+                    case EXC_ERR_REF:
+                    case EXC_ERR_NAME:
+                    case EXC_ERR_NUM:   eOc = ocStop;       break;
+                    case EXC_ERR_NA:    eOc = ocNoValue;    break;
+                    default:            eOc = ocNoName;
 				}
 				aPool << eOc;
 				if( eOc != ocStop )
Index: sc/source/filter/excel/excimp8.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excimp8.cxx,v
retrieving revision 1.106
retrieving revision 1.106.4.2
diff -u -p -u -p -r1.106 -r1.106.4.2
--- sc/source/filter/excel/excimp8.cxx	29 Mar 2005 13:36:39 -0000	1.106
+++ sc/source/filter/excel/excimp8.cxx	9 Aug 2005 16:29:35 -0000	1.106.4.2
@@ -200,6 +200,14 @@ void ImportExcel8::Calccount( void )
 }
 
 
+void ImportExcel8::Precision( void )
+{
+    ScDocOptions aOpt = pD->GetDocOptions();
+    aOpt.SetCalcAsShown( aIn.ReaduInt16() == 0 );
+    pD->SetDocOptions( aOpt );
+}
+
+
 void ImportExcel8::Delta( void )
 {
 	ScDocOptions	aOpt = pD->GetDocOptions();
@@ -215,6 +223,7 @@ void ImportExcel8::Iteration( void )
 	pD->SetDocOptions( aOpt );
 }
 
+
 void ImportExcel8:: WinProtection( void )
 {
     if( aIn.ReaduInt16() != 0 )
@@ -223,37 +232,7 @@ void ImportExcel8:: WinProtection( void 
 
 void ImportExcel8::Note( void )
 {
-    XclAddress aXclPos;
-    sal_uInt16 nFlags, nObjId;
-    aIn >> aXclPos >> nFlags >> nObjId;
-
-    ScAddress aScNotePos( ScAddress::UNINITIALIZED );
-    SCTAB nScTab = GetCurrScTab();
-    if( GetAddressConverter().ConvertAddress( aScNotePos, aXclPos, nScTab, true ) )
-	{
-        if( nObjId != EXC_OBJ_INVALID_ID )
-		{
-            XclImpObjectManager& rObjManager = GetObjectManager();
-            if( XclImpEscherObj* pEscherObj = rObjManager.GetEscherObjAcc( nScTab, nObjId ) )
-            {
-                if( XclImpEscherNote* pNoteObj = PTR_CAST( XclImpEscherNote, pEscherObj ) )
-                {
-                    pNoteObj->SetScPos( aScNotePos );
-                    if( const XclImpString* pString = pNoteObj->GetString() )
-                    {
-                        ::std::auto_ptr< EditTextObject > pEditObj(
-                            XclImpStringHelper::CreateNoteObject( GetRoot(), *pString ) );
-                        bool bVisible = ::get_flag( nFlags, EXC_NOTE_VISIBLE );
-
-                        ScDocument* pDoc = GetDocPtr();
-                        ScPostIt aNote( pEditObj.get(), pDoc );
-                        aNote.SetShown( bVisible );
-                        GetDoc().SetNote( aScNotePos.Col(), aScNotePos.Row(), nScTab, aNote );
-                    }
-                }
-            }
-        }
-    }
+    GetObjectManager().ReadNote( maStrm );
 	pLastFormCell = NULL;
 }
 
@@ -261,7 +240,7 @@ void ImportExcel8::Note( void )
 void ImportExcel8::Cont( void )
 {
     if( bObjSection )
-        GetObjectManager().ReadMsodrawing( aIn );
+        GetObjectManager().ReadMsoDrawing( aIn );
 }
 
 
@@ -343,19 +322,19 @@ void ImportExcel8::Cellmerging( void )
 
 void ImportExcel8::Msodrawinggroup( void )
 {
-    GetObjectManager().ReadMsodrawinggroup( maStrm );
+    GetObjectManager().ReadMsoDrawingGroup( maStrm );
 }
 
 
 void ImportExcel8::Msodrawing( void )
 {
-    GetObjectManager().ReadMsodrawing( maStrm );
+    GetObjectManager().ReadMsoDrawing( maStrm );
 }
 
 
 void ImportExcel8::Msodrawingselection( void )
 {
-    GetObjectManager().ReadMsodrawingselection( maStrm );
+    GetObjectManager().ReadMsoDrawingSelection( maStrm );
 }
 
 void ImportExcel8::Labelsst( void )
@@ -502,44 +481,7 @@ void ImportExcel8::PostDocLoad( void )
 
 void ImportExcel8::ApplyEscherObjects()
 {
-    XclImpObjectManager& rObjManager = GetObjectManager();
-
-    ScfProgressBar aProgress( GetDocShell(), STR_PROGRESS_CALCULATING );
-    sal_Int32 nSegApply = aProgress.AddSegment( 1000 );
-
-    if( rObjManager.HasEscherStream() )
-    {
-        XclImpDffManager& rDffManager = rObjManager.GetDffManager();
-        if( const SvxMSDffShapeInfos* pShapeInfos = rDffManager.GetShapeInfos() )
-        {
-            if( USHORT nInfoCount = pShapeInfos->Count() )
-            {
-                sal_Int32 nSegSetObj = aProgress.AddSegment( 200 );
-
-                ScfProgressBar& rSubProgress = aProgress.GetSegmentProgressBar( nSegSetObj );
-                sal_Int32 nSubSeg = rSubProgress.AddSegment( nInfoCount );
-                rSubProgress.ActivateSegment( nSubSeg );
-
-                for( USHORT nInfo = 0; nInfo < nInfoCount; ++nInfo )
-                {
-                    if( const SvxMSDffShapeInfo* pShapeInfo = pShapeInfos->GetObject( nInfo ) )
-                    {
-                        sal_uInt32 nShapeId = pShapeInfo->nShapeId;
-                        XclImpEscherObj* pEscherObj = rObjManager.GetEscherObjAcc( pShapeInfo->nFilePos );
-                        if( pEscherObj && !pEscherObj->GetIsSkip() && !pEscherObj->GetSdrObj() )
-                        {
-                            SvxMSDffImportData aDffImportData;
-                            rDffManager.SetSdrObject( pEscherObj, nShapeId, aDffImportData );
-                        }
-                    }
-                    rSubProgress.Progress();
-                }
-            }
-        }
-    }
-
-    ScfProgressBar& rApplyProgress = aProgress.GetSegmentProgressBar( nSegApply );
-    rObjManager.Apply( rApplyProgress );
+    GetObjectManager().ConvertObjects();
 }
 
 
Index: sc/source/filter/excel/exctools.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/exctools.cxx,v
retrieving revision 1.54
retrieving revision 1.54.4.1
diff -u -p -u -p -r1.54 -r1.54.4.1
--- sc/source/filter/excel/exctools.cxx	29 Mar 2005 13:37:10 -0000	1.54
+++ sc/source/filter/excel/exctools.cxx	10 Aug 2005 11:56:25 -0000	1.54.4.1
@@ -192,14 +192,14 @@ void XclImpOutlineBuffer::MakeScOutline(
 	const UINT16	nNumLev			= 8;
 	BOOL			bPreOutedLevel	= FALSE;
 	BYTE			nCurrLevel		= 0;
-	UINT16			nC;
 	BOOL			bMakeHidden[ nNumLev ];
 	BOOL			bMakeVisible[ nNumLev + 1 ];
 
-	for( nC = 0; nC < nNumLev; nC++ )
-		bMakeHidden[ nC ] = FALSE;
-	for( nC = 0; nC <= nNumLev; nC++ )
-		bMakeVisible[ nC ] = TRUE;
+    sal_uInt16 nLevel;
+    for( nLevel = 0; nLevel < nNumLev; ++nLevel )
+        bMakeHidden[ nLevel ] = FALSE;
+    for( nLevel = 0; nLevel <= nNumLev; ++nLevel )
+        bMakeVisible[ nLevel ] = TRUE;
 	if( nLast < (nSize - 1) )
 		nLast++;
 
@@ -212,12 +212,12 @@ void XclImpOutlineBuffer::MakeScOutline(
 			BYTE	nCurrLevel	= 0;
 			BYTE	nPrevLevel	= 0;
 
-			for( UINT16 nC = 0 ; nC <= nLast ; nC++ )
+            for( SCSIZE nC = 0 ; nC <= nLast ; nC++ )
 			{
 				nPrevLevel = nCurrLevel;
 				nCurrLevel = pLevel[ nC ];
 				if( (nPrevLevel < nWorkLevel) && (nCurrLevel >= nWorkLevel) )
-					nStartPos = nC;
+                    nStartPos = static_cast< sal_uInt16 >( nC );
 				else if( (nPrevLevel >= nWorkLevel) && (nCurrLevel < nWorkLevel) )
 				{
 					if( pOuted[ nC ] && pHidden[ nStartPos ] )
@@ -243,11 +243,11 @@ void XclImpOutlineBuffer::MakeScOutline(
 	BOOL	bCurrHidden = FALSE;
 	BOOL	bPrevHidden = FALSE;
 
-	for( nC = 0; nC <= nLast; nC++ )
+    for( SCSIZE nC = 0; nC <= nLast; nC++ )
 	{
 		BYTE nWorkLevel = pLevel[ nC ];
 
-		nPrevC		= nC ? nC - 1 : 0;
+        nPrevC      = static_cast< sal_uInt16 >( nC ? nC - 1 : 0 );
 		bPrevHidden	= bCurrHidden;
 		bCurrHidden	= pHidden[ nC ];
 
@@ -258,7 +258,7 @@ void XclImpOutlineBuffer::MakeScOutline(
 			bMakeHidden[ nCurrLevel ] = bPrevOuted;
 			bMakeVisible[ nCurrLevel + 1 ] =
 				bMakeVisible[ nCurrLevel ] && !bMakeHidden[ nCurrLevel ];
-			nStart[ nCurrLevel ] = nC;
+            nStart[ nCurrLevel ] = static_cast< sal_uInt16 >( nC );
 		}
 		// close levels
 		while( nWorkLevel < nCurrLevel )
Index: sc/source/filter/excel/impop.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/impop.cxx,v
retrieving revision 1.74
retrieving revision 1.74.4.2
diff -u -p -u -p -r1.74 -r1.74.4.2
--- sc/source/filter/excel/impop.cxx	29 Mar 2005 13:37:32 -0000	1.74
+++ sc/source/filter/excel/impop.cxx	10 Aug 2005 14:41:41 -0000	1.74.4.2
@@ -139,6 +139,9 @@
 #ifndef SC_XIPAGE_HXX
 #include "xipage.hxx"
 #endif
+#ifndef SC_XIVIEW_HXX
+#include "xiview.hxx"
+#endif
 #ifndef SC_XILINK_HXX
 #include "xilink.hxx"
 #endif
@@ -250,20 +253,7 @@ void ImportExcel::Dimensions( void )
 
 void ImportExcel::Window1()
 {
-    sal_uInt16 nFlags, nTabBarSize;
-    maStrm.Ignore( 8 );
-    maStrm >> nFlags;
-    maStrm.Ignore( 6 );
-    maStrm >> nTabBarSize;
-
-    ScViewOptions aViewOpt( GetDoc().GetViewOptions() );
-    aViewOpt.SetOption( VOPT_HSCROLL,       ::get_flag( nFlags, EXC_WIN1_HOR_SCROLLBAR ) );
-    aViewOpt.SetOption( VOPT_VSCROLL,       ::get_flag( nFlags, EXC_WIN1_VER_SCROLLBAR ) );
-    aViewOpt.SetOption( VOPT_TABCONTROLS,   ::get_flag( nFlags, EXC_WIN1_TABBAR ) );
-    GetDoc().SetViewOptions( aViewOpt );
-
-    if( nTabBarSize <= 1000 )
-        GetExtDocOptions().GetDocSettings().mfTabBarWidth = static_cast< double >( nTabBarSize ) / 1000.0;
+    GetDocViewSettings().ReadWindow1( maStrm );
 }
 
 
@@ -1471,6 +1461,8 @@ void ImportExcel::PostDocLoad( void )
     for(XclImpOutlineDataBuffer* pBuffer = pOutlineListBuffer->First(); pBuffer; pBuffer = pOutlineListBuffer->Next() )
         pBuffer->Apply(pD);
 
+    // document view settings (before visible OLE area)
+    GetDocViewSettings().Finalize();
 
     // visible area if embedded OLE
     if( ScModelObj* pDocObj = GetDocModelObj() )
@@ -1494,7 +1486,11 @@ void ImportExcel::PostDocLoad( void )
                     aScOleSize = pTabSett->maUsedArea;
                 // add all valid drawing objects (object manager only available in BIFF8)
                 if( GetBiff() == EXC_BIFF8 )
-                    GetObjectManager().ExtendUsedArea( aScOleSize, nDisplScTab );
+                {
+                    ScRange aScObjArea = GetObjectManager().GetUsedArea( nDisplScTab );
+                    if( aScObjArea.IsValid() )
+                        aScOleSize.ExtendTo( aScObjArea );
+                }
             }
 
             // valid size found - set it at the document
Index: sc/source/filter/excel/namebuff.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/namebuff.cxx,v
retrieving revision 1.20
retrieving revision 1.20.36.1
diff -u -p -u -p -r1.20 -r1.20.36.1
--- sc/source/filter/excel/namebuff.cxx	21 Feb 2005 13:27:22 -0000	1.20
+++ sc/source/filter/excel/namebuff.cxx	7 Jun 2005 18:52:25 -0000	1.20.36.1
@@ -161,75 +161,56 @@ UINT16	nShrCnt;
 #endif
 
 
-ShrfmlaBuffer::ShrfmlaBuffer( RootData* pRD ) :
-	ExcRoot( pRD )
+size_t
+ShrfmlaBuffer::ScAddressHashFunc::operator() (const ScAddress &addr) const
 {
-	nBase = 16384;	// Range~ und Shared~ Dingens mit jeweils der Haelfte Ids
+	// Use something simple, it is just a hash.
+	return (static_cast <UINT16> (addr.Row()) << 0) |
+		   (static_cast <UINT8> (addr.Col()) << 16) |
+		   (static_cast <UINT8> (addr.Tab()) << 24);
+}
 
+static const UINT16 nBase = 16384;	// Range~ und Shared~ Dingens mit jeweils der Haelfte Ids
+ShrfmlaBuffer::ShrfmlaBuffer( RootData* pRD ) :
+	ExcRoot( pRD ),
+	cur_index (nBase)
+{
 #ifdef DBG_UTIL
 	nShrCnt = 0;
 #endif
 }
 
-
 ShrfmlaBuffer::~ShrfmlaBuffer()
 {
-	register ScAddress*	pDel = ( ScAddress* ) List::First();
-
-	while( pDel )
-	{
-		delete pDel;
-		pDel = ( ScAddress* ) List::Next();
-	}
 }
 
-
 void ShrfmlaBuffer::Store( const ScRange& rRange, const ScTokenArray& rToken )
 {
 	String			aName( CreateName( rRange.aStart ) );
 
-	DBG_ASSERT( List::Count() + nBase <= 0xFFFF, "*ShrfmlaBuffer::Store(): Gleich wird mir schlecht...!" );
+	DBG_ASSERT( cur_index <= 0xFFFF, "*ShrfmlaBuffer::Store(): Gleich wird mir schlecht...!" );
 
     ScRangeData* pData = new ScRangeData( pExcRoot->pIR->GetDocPtr(), aName, rToken, rRange.aStart, RT_SHARED );
-
-	pData->SetIndex( ( UINT16 ) ( List::Count() + nBase ) );
-
+	pData->SetIndex (cur_index);
     pExcRoot->pIR->GetNamedRanges().Insert( pData );
-
-	ScRange*		pNew = new ScRange( rRange );
-	Insert( pNew, LIST_APPEND );
+	index_hash[rRange.aStart] = cur_index;
+	index_list.push_front (rRange);
+	cur_index++;
 }
 
 
-UINT16 ShrfmlaBuffer::Find( const ScAddress aAddr )
+UINT16 ShrfmlaBuffer::Find( const ScAddress & aAddr ) const
 {
-	register ScRange*	pAkt = ( ScRange* ) List::First();
-	ScAddress			aSearchAddr( aAddr );
-
-	register UINT16		nPos = nBase;
-
-	while( pAkt )
-	{
-		if( pAkt->aStart == aSearchAddr )
-			return nPos;
-
-		nPos++;
-		pAkt = ( ScRange* ) List::Next();
-	}
-
-	nPos = nBase;
-	pAkt = ( ScRange* ) List::First();
-
-	while( pAkt )
-	{
-		if( pAkt->In( aSearchAddr ) )
-			return nPos;
-
-		nPos++;
-		pAkt = ( ScRange* ) List::Next();
-	}
+	ShrfmlaHash::const_iterator hash = index_hash.find (aAddr);
+	if (hash != index_hash.end())
+		return hash->second;
 
-	return nPos;
+	// It was not hashed on the top left corner ?  do a brute force search
+	unsigned int ind = nBase;
+	for (ShrfmlaList::const_iterator ptr = index_list.end(); ptr != index_list.begin() ; ind++)
+		if ((--ptr)->In (aAddr))
+			return ind;
+	return cur_index;
 }
 
 
Index: sc/source/filter/excel/read.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/read.cxx,v
retrieving revision 1.53
retrieving revision 1.53.4.2
diff -u -p -u -p -r1.53 -r1.53.4.2
--- sc/source/filter/excel/read.cxx	29 Mar 2005 13:37:54 -0000	1.53
+++ sc/source/filter/excel/read.cxx	9 Aug 2005 16:29:36 -0000	1.53.4.2
@@ -71,10 +71,6 @@
 #include <stdio.h>
 
 #include "document.hxx"
-#include "docoptio.hxx"
-#include "globstr.hrc"
-#include "stlsheet.hxx"
-#include "stlpool.hxx"
 #ifndef _SCERRORS_HXX
 #include "scerrors.hxx"
 #endif
@@ -186,7 +182,7 @@ FltError ImportExcel::Read( void )
 		}
 
 		if( eAkt != Z_Biff5Pre && eAkt != Z_Biff5WPre )
-            pProgress->Progress( aIn.GetSvStreamPos() );
+            pProgress->ProgressAbs( aIn.GetSvStreamPos() );
 
 		switch( eAkt )
 		{
@@ -1035,7 +1031,7 @@ FltError ImportExcel8::Read( void )
 		}
 
         if( eAkt != EXC_STATE_SHEET_PRE && eAkt != EXC_STATE_GLOBALS_PRE )
-            pProgress->Progress( aIn.GetSvStreamPos() );
+            pProgress->ProgressAbs( aIn.GetSvStreamPos() );
 
         if( nRecId != EXC_ID_CONT )
         {
@@ -1120,6 +1116,7 @@ FltError ImportExcel8::Read( void )
                         rXFBfr.CreateUserStyles();
                         eAkt = EXC_STATE_BEFORE_SHEET;
 						break;
+                    case 0x0E:  Precision(); break;     // PRECISION
 					case 0x22:	Rec1904(); break;		// 1904			[ 2345   ]
 					case 0x25:	Defrowheight2(); break;	// DEFAULTROWHEI[ 2      ]
 					case 0x42:	Codepage(); break;		// CODEPAGE		[ 2345   ]
@@ -1176,10 +1173,6 @@ FltError ImportExcel8::Read( void )
                     {
                         Bof5();
                         NeueTabelle();
-
-                        // insert leading dummy object for the new sheet
-                        rObjMgr.InsertDummyObj();
-
                         switch( pExcRoot->eDateiTyp )
                         {
                             case Biff8:     // worksheet
@@ -1188,8 +1181,7 @@ FltError ImportExcel8::Read( void )
                                 aIn.StoreGlobalPosition();
                             break;
                             case Biff8C:    // chart sheet
-                                rObjMgr.StartNewChartObj();
-                                rObjMgr.ReadChartSubStream( maStrm );
+                                rObjMgr.ReadTabChart( maStrm );
                                 EndSheet();
                                 IncCurrScTab();
                                 GetTracer().TraceChartOnlySheet();
@@ -1368,10 +1360,8 @@ FltError ImportExcel8::Read( void )
 						case 0x0809:									// BOF			[    5   ]
 						{
 							Bof5();
-                            if( pExcRoot->eDateiTyp == Biff8C && bWithDrawLayer )
-                                rObjMgr.ReadChartSubStream( maStrm );
-							else
-                                XclTools::SkipSubStream( maStrm );
+                            DBG_ASSERT( pExcRoot->eDateiTyp == Biff8C, "unknown BOF" );
+                            XclTools::SkipSubStream( maStrm );
                             // still in Escher objects
                             bObjSection = TRUE;
 						}
Index: sc/source/filter/excel/xeescher.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xeescher.cxx,v
retrieving revision 1.11
retrieving revision 1.11.4.1
diff -u -p -u -p -r1.11 -r1.11.4.1
--- sc/source/filter/excel/xeescher.cxx	29 Mar 2005 13:38:11 -0000	1.11
+++ sc/source/filter/excel/xeescher.cxx	9 Aug 2005 16:29:36 -0000	1.11.4.1
@@ -399,8 +399,8 @@ XclExpObjTbxCtrl::XclExpObjTbxCtrl(
         }
 
         pTxo = new XclTxo( aString, nXclFont );
-        pTxo->SetHorAlign( (mnObjType == EXC_OBJ_CMO_BUTTON) ? xlTxoHAlignCenter : xlTxoHAlignLeft );
-        pTxo->SetVerAlign( xlTxoVAlignCenter );
+        pTxo->SetHorAlign( (mnObjType == EXC_OBJ_CMO_BUTTON) ? EXC_TXO_HOR_CENTER : EXC_TXO_HOR_LEFT );
+        pTxo->SetVerAlign( EXC_TXO_VER_CENTER );
     }
 
     rEscherEx.CloseContainer();  // ESCHER_SpContainer
Index: sc/source/filter/excel/xeformula.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xeformula.cxx,v
retrieving revision 1.5
retrieving revision 1.5.36.5
diff -u -p -u -p -r1.5 -r1.5.36.5
--- sc/source/filter/excel/xeformula.cxx	21 Feb 2005 13:28:29 -0000	1.5
+++ sc/source/filter/excel/xeformula.cxx	25 Jul 2005 12:18:21 -0000	1.5.36.5
@@ -180,7 +180,7 @@ struct XclExpCompConfig
     XclExpTokenClassType meClassType;   /// Token class handling type.
     XclExpLinkMgrType   meLinkMgrType;  /// Link manager to be used.
     bool                mbFromCell;     /// True = Any kind of cell formula (cell, array, shared).
-    bool                mb3DRefOnly;    /// True = Only 3D references allowed (i.e. names).
+    bool                mb3DRefOnly;    /// True = Only 3D references allowed (e.g. names).
     bool                mbStopAtSep;    /// True = Stop compilation at ocSep in root level.
 };
 
@@ -343,6 +343,7 @@ private:
     // XclExpTokenData: pass-by-value and return-by-value is intended
 
     const ScToken*      GetNextRawToken();
+    const ScToken*      PeekNextRawToken( bool bSkipSpaces ) const;
 
     bool                GetNextToken( XclExpTokenData& rTokData );
     XclExpTokenData     GetNextToken();
@@ -373,6 +374,7 @@ private:
     void                ProcessParentheses( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
     void                ProcessBoolean( const XclExpTokenData& rTokData );
     void                ProcessDdeLink( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
+    void                ProcessExternal( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
 
     void                ProcessFunction( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
     void                FinishFunction( XclExpFuncData& rFuncData, sal_uInt8 nCloseSpaces );
@@ -434,6 +436,7 @@ private:
     void                AppendErrorToken( sal_uInt8 nErrCode, sal_uInt8 nSpaces = 0 );
     void                AppendMissingToken( sal_uInt8 nSpaces = 0 );
     void                AppendNameToken( sal_uInt16 nNameIdx, sal_uInt8 nExpClass, sal_uInt8 nSpaces = 0 );
+    void                AppendMissingNameToken( const String& rName, sal_uInt8 nExpClass, sal_uInt8 nSpaces = 0 );
     void                AppendMacroCallToken( const String& rFuncName, sal_uInt8 nExpClass, sal_uInt8 nSpaces = 0 );
     void                AppendAddInFuncToken( const String& rFuncName, sal_uInt8 nExpClass, sal_uInt8 nSpaces = 0 );
     void                AppendNameXToken( sal_uInt16 nExtSheet, sal_uInt16 nExtName, sal_uInt8 nExpClass, sal_uInt8 nSpaces = 0 );
@@ -516,18 +519,38 @@ XclExpTokenArrayRef XclExpFmlaCompImpl::
     // start compilation, if initialization didn't fail
     if( mbOk )
     {
-        // expected class is VAL in cell and array formulas, and REF in names
-        sal_uInt8 nExpClass = (maCfg.meClassType == EXC_CLASSTYPE_NAME) ? EXC_TOKCLASS_REF : EXC_TOKCLASS_VAL;
-        XclExpTokenData aTokData( Expression( GetNextToken(), nExpClass, maCfg.mbStopAtSep ) );
+        XclExpTokenData aTokData( GetNextToken() );
+        USHORT nScError = rScTokArr.GetError();
+        if( (nScError != 0) && (!aTokData.Is() || (aTokData.GetOpCode() == ocStop)) )
+        {
+            // #i50253# convert simple ocStop token to error code formula (e.g. =#VALUE!)
+            AppendErrorToken( XclTools::GetXclErrorCode( nScError ), aTokData.mnSpaces );
+        }
+        else if( aTokData.Is() )
+        {
+            // expected class is VAL in cell and array formulas, and REF in names
+            sal_uInt8 nExpClass = (maCfg.meClassType == EXC_CLASSTYPE_NAME) ? EXC_TOKCLASS_REF : EXC_TOKCLASS_VAL;
+            aTokData = Expression( aTokData, nExpClass, maCfg.mbStopAtSep );
+        }
+        else
+        {
+            DBG_ERRORFILE( "XclExpFmlaCompImpl::CreateFormula - empty token array" );
+            mbOk = false;
+        }
 
         /*  Do unknown tokens follow? Calc accepts "comments" following a formula,
-            i.e.: =1+1;"This is a comment". Ignore this without error. */
-        bool bUnknownTail = aTokData.Is() && (aTokData.GetOpCode() != ocSep);
-        // Tokens left? -> error
-        mbOk = mbOk && !bUnknownTail;
+            e.g.: =1+1;"This is a comment". Ignore this without error. */
+        if( mbOk )
+        {
+            // #i44907# auto-generated SUBTOTAL formula cells have trailing ocStop token
+            bool bUnknownTail = aTokData.Is() && (aTokData.GetOpCode() != ocSep) && (aTokData.GetOpCode() != ocStop);
+            DBG_ASSERT( !bUnknownTail, "XclExpFmlaCompImpl::CreateFormula - unknown garbage behind formula" );
+            // Tokens left? -> error
+            mbOk = !bUnknownTail;
+        }
     }
 
-    // finalizing, i.e. add tAttr-volatile token
+    // finalizing, e.g. add tAttr-volatile token
     FinalizeFormula();
 
     return CreateTokenArray();
@@ -713,6 +736,19 @@ const ScToken* XclExpFmlaCompImpl::GetNe
     return pScToken;
 }
 
+const ScToken* XclExpFmlaCompImpl::PeekNextRawToken( bool bSkipSpaces ) const
+{
+    /*  Returns pointer to next raw token in the token array. The token array
+        iterator already points to the next token (A call to GetNextToken()
+        always increases the iterator), so this function just returns the token
+        the iterator points to. To skip space tokens, a copy of the iterator is
+        created and set to the passed skip-spaces mode. If spaces have to be
+        skipped, and the iterator currently points to a space token, the
+        constructor will move it to the next non-space token. */
+    XclTokenArrayIterator aTempIt( maTokArrIt, bSkipSpaces );
+    return aTempIt.Get();
+}
+
 bool XclExpFmlaCompImpl::GetNextToken( XclExpTokenData& rTokData )
 {
     rTokData.mpScToken = GetNextRawToken();
@@ -1054,6 +1090,7 @@ XclExpTokenData XclExpFmlaCompImpl::Fact
         case svString:      ProcessString( aTokData );              break;
         case svSingleRef:   ProcessCellRef( aTokData, nExpClass );  break;
         case svDoubleRef:   ProcessRangeRef( aTokData, nExpClass ); break;
+        case svExternal:    ProcessExternal( aTokData, nExpClass ); break;
 
         default:
         {
@@ -1154,6 +1191,19 @@ void XclExpFmlaCompImpl::ProcessDdeLink(
     }
 }
 
+void XclExpFmlaCompImpl::ProcessExternal( const XclExpTokenData& rTokData, sal_uInt8 nExpClass )
+{
+    /*  #i47228# Excel import generates svExternal/ocMacro tokens for invalid
+        names and for external/invalid function calls. This function looks for
+        the next token in the token array. If it is an opening parenthesis, the
+        token is processed as external function call, otherwise as undefined name. */
+    const ScToken* pNextScToken = PeekNextRawToken( true );
+    if( !pNextScToken || (pNextScToken->GetOpCode() != ocOpen) )
+        AppendMissingNameToken( rTokData.mpScToken->GetExternal(), nExpClass, rTokData.mnSpaces );
+    else
+        ProcessFunction( rTokData, nExpClass );
+}
+
 void XclExpFmlaCompImpl::ProcessFunction( const XclExpTokenData& rTokData, sal_uInt8 nExpClass )
 {
     OpCode eOpCode = rTokData.GetOpCode();
@@ -1225,7 +1275,7 @@ void XclExpFmlaCompImpl::FinishFunction(
         AppendSpaceToken( EXC_TOK_ATTR_SPACE_SP, rFuncData.GetSpaces() );
         // cache the start position of the function token (without spaces)
         sal_uInt16 nFuncTokPos = GetSize();
-        // put the tFunc or tFuncVar token (or another special token, i.e. tAttr-sum)
+        // put the tFunc or tFuncVar token (or another special token, e.g. tAttr-sum)
         sal_uInt8 nRetClass = rFuncData.GetReturnClass();
         sal_uInt8 nExpRetClass = rFuncData.GetExpReturnClass();
         if( (rFuncData.GetOpCode() == ocSum) && (nParamCount == 1) )
@@ -1349,7 +1399,7 @@ XclExpTokenData XclExpFmlaCompImpl::Proc
         }
         // restore old expected ARR class mode
         SetArrExpFlag( bOldIsArrExp );
-        // finalize the parameter and add special tokens, i.e. for IF or CHOOSE parameters
+        // finalize the parameter and add special tokens, e.g. for IF or CHOOSE parameters
         if( mbOk ) FinishParam( rFuncData, nParamPos );
     }
     return aTokData;
@@ -1780,7 +1830,7 @@ void XclExpFmlaCompImpl::AdjustTokenClas
         else
         {
             /*  If a REF token is part of a value operator, it behaves like a VAL token.
-                i.e.:   =SUM(A1)    -> SUM() expects REF, A1 is REF.
+                e.g.:   =SUM(A1)    -> SUM() expects REF, A1 is REF.
                         =SUM(A1+A1) -> SUM() expects REF, but both A1 are handled like VAL tokens. */
             if( (nIsClass == EXC_TOKCLASS_REF) && ::get_flag( nExpClass, EXC_TOKCLASS_INOP_FLAG ) )
             {
@@ -1825,7 +1875,7 @@ void XclExpFmlaCompImpl::AdjustLastToken
         formula =OR(A1:A2,0). The Excel OR function expects REF parameters to
         be able to process all cells in a range reference. Since this compiler
         didn't know this when processing the (A1:A2) subexpression, it may
-        create a tAreaV token from the reference (i.e. if in cell context).
+        create a tAreaV token from the reference (e.g. if in cell context).
         This would cause Excel to only evaluate cell A1, and to ignore cell A2,
         if the formula is located in cell B1.
         So this function changes the last token back to its default class and
@@ -1980,6 +2030,12 @@ void XclExpFmlaCompImpl::AppendNameToken
         AppendErrorToken( EXC_ERR_NAME );
 }
 
+void XclExpFmlaCompImpl::AppendMissingNameToken( const String& rName, sal_uInt8 nExpClass, sal_uInt8 nSpaces )
+{
+    sal_uInt16 nNameIdx = GetNameManager().InsertRawName( rName );
+    AppendNameToken( nNameIdx, nExpClass, nSpaces );
+}
+
 void XclExpFmlaCompImpl::AppendNameXToken( sal_uInt16 nExtSheet, sal_uInt16 nExtName, sal_uInt8 nExpClass, sal_uInt8 nSpaces )
 {
     AppendOpTokenId( GetTokenId( EXC_TOKID_NAMEX, EXC_TOKCLASS_REF ), nExpClass, nSpaces );
Index: sc/source/filter/excel/xename.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xename.cxx,v
retrieving revision 1.3
retrieving revision 1.3.36.1
diff -u -p -u -p -r1.3 -r1.3.36.1
--- sc/source/filter/excel/xename.cxx	21 Feb 2005 13:29:17 -0000	1.3
+++ sc/source/filter/excel/xename.cxx	19 Apr 2005 14:47:16 -0000	1.3.36.1
@@ -174,6 +174,8 @@ public:
     sal_uInt16          InsertBuiltInName( sal_Unicode cBuiltIn, XclExpTokenArrayRef xTokArr, SCTAB nScTab );
     /** Inserts a new defined name. Sets another unused name, if rName already exists. */
     sal_uInt16          InsertUniqueName( const String& rName, XclExpTokenArrayRef xTokArr, SCTAB nScTab );
+    /** Returns index of an existing name, or creates a name without definition. */
+    sal_uInt16          InsertRawName( const String& rName );
     /** Searches or inserts a defined name describing a macro name.
         @param bFunc  true = Macro function; false = Macro procedure. */
     sal_uInt16          InsertMacroCall( const String& rMacroName, bool bFunc );
@@ -404,6 +406,25 @@ sal_uInt16 XclExpNameManagerImpl::Insert
     return Append( xName );
 }
 
+sal_uInt16 XclExpNameManagerImpl::InsertRawName( const String& rName )
+{
+    // empty name? may occur in broken external Calc tokens
+    if( !rName.Len() )
+        return 0;
+
+    // try to find an existing NAME record, regardless of its type
+    for( size_t nListIdx = mnFirstUserIdx, nListSize = maNameList.Size(); nListIdx < nListSize; ++nListIdx )
+    {
+        XclExpNameRef xName = maNameList.GetRecord( nListIdx );
+        if( xName->IsGlobal() && (xName->GetOrigName() == rName) )
+            return static_cast< sal_uInt16 >( nListIdx + 1 );
+    }
+
+    // create a new NAME record
+    XclExpNameRef xName( new XclExpName( GetRoot(), rName ) );
+    return Append( xName );
+}
+
 sal_uInt16 XclExpNameManagerImpl::InsertMacroCall( const String& rMacroName, bool bFunc )
 {
     // empty name? may occur in broken external Calc tokens
@@ -697,6 +718,11 @@ sal_uInt16 XclExpNameManager::InsertUniq
     return mxImpl->InsertUniqueName( rName, xTokArr, nScTab );
 }
 
+sal_uInt16 XclExpNameManager::InsertRawName( const String& rName )
+{
+    return mxImpl->InsertRawName( rName );
+}
+
 sal_uInt16 XclExpNameManager::InsertMacroCall( const String& rMacroName, bool bFunc )
 {
     return mxImpl->InsertMacroCall( rMacroName, bFunc );
Index: sc/source/filter/excel/xestyle.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xestyle.cxx,v
retrieving revision 1.18
retrieving revision 1.18.34.1
diff -u -p -u -p -r1.18 -r1.18.34.1
--- sc/source/filter/excel/xestyle.cxx	21 Feb 2005 13:30:50 -0000	1.18
+++ sc/source/filter/excel/xestyle.cxx	10 May 2005 14:19:27 -0000	1.18.34.1
@@ -2429,7 +2429,7 @@ void XclExpXFBuffer::InsertDefaultRecord
 
     /*  Insert the real default hard cell format -> 0 is document default pattern.
         Do it here (and not already above) to really have all built-in styles. */
-    Insert( 0, ::com::sun::star::i18n::ScriptType::WEAK );
+    Insert( 0, GetDefApiScript() );
 }
 
 void XclExpXFBuffer::AppendXFIndex( sal_uInt32 nXFId )
Index: sc/source/filter/excel/xetable.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xetable.cxx,v
retrieving revision 1.8
retrieving revision 1.8.4.3
diff -u -p -u -p -r1.8 -r1.8.4.3
--- sc/source/filter/excel/xetable.cxx	29 Mar 2005 13:38:48 -0000	1.8
+++ sc/source/filter/excel/xetable.cxx	12 Jul 2005 14:53:56 -0000	1.8.4.3
@@ -720,7 +720,6 @@ void XclExpLabelCell::Init( const XclExp
 
     // create the cell format
     sal_uInt16 nXclFont = mxText->RemoveLeadingFont();
-    DBG_ASSERT( nXclFont != EXC_FONT_NOTFOUND, "XclExpLabelCell::Init - missing first font" );
     if( GetXFId() == EXC_XFID_NOTFOUND )
     {
         bool bForceLineBreak = mxText->IsWrapped();
@@ -1127,15 +1126,14 @@ XclExpBlankCell::XclExpBlankCell(
     XclExpMultiCellBase( EXC_ID_BLANK, EXC_ID_MULBLANK, 0, rXclPos )
 {
     DBG_ASSERT( rXclPos.mnCol <= nLastXclCol, "XclExpBlankCell::XclExpBlankCell - invalid column range" );
-    AppendXFId( rRoot, pPattern, ApiScriptType::WEAK, nForcedXFId, nLastXclCol - rXclPos.mnCol + 1 );
+    // #i46627# use default script type instead of ApiScriptType::WEAK
+    AppendXFId( rRoot, pPattern, rRoot.GetDefApiScript(), nForcedXFId, nLastXclCol - rXclPos.mnCol + 1 );
 }
 
 bool XclExpBlankCell::TryMerge( const XclExpCellBase& rCell )
 {
-    if( const XclExpBlankCell* pBlankCell = dynamic_cast< const XclExpBlankCell* >( &rCell ) )
-        if( TryMergeXFIds( *pBlankCell ) )
-            return true;
-    return false;
+    const XclExpBlankCell* pBlankCell = dynamic_cast< const XclExpBlankCell* >( &rCell );
+    return pBlankCell && TryMergeXFIds( *pBlankCell );
 }
 
 void XclExpBlankCell::GetBlankXFIndexes( ScfUInt16Vec& rXFIndexes ) const
@@ -1168,13 +1166,11 @@ XclExpRkCell::XclExpRkCell(
 
 bool XclExpRkCell::TryMerge( const XclExpCellBase& rCell )
 {
-    if( const XclExpRkCell* pRkCell = dynamic_cast< const XclExpRkCell* >( &rCell ) )
+    const XclExpRkCell* pRkCell = dynamic_cast< const XclExpRkCell* >( &rCell );
+    if( pRkCell && TryMergeXFIds( *pRkCell ) )
     {
-        if( TryMergeXFIds( *pRkCell ) )
-        {
-            maRkValues.insert( maRkValues.end(), pRkCell->maRkValues.begin(), pRkCell->maRkValues.end() );
-            return true;
-        }
+        maRkValues.insert( maRkValues.end(), pRkCell->maRkValues.begin(), pRkCell->maRkValues.end() );
+        return true;
     }
     return false;
 }
@@ -1374,7 +1370,7 @@ XclExpColinfo::XclExpColinfo( const XclE
 
     // column default format
     maXFId.mnXFId = GetXFBuffer().Insert(
-        rDoc.GetMostUsedPattern( nScCol, 0, nLastScRow, nScTab ), ApiScriptType::WEAK );
+        rDoc.GetMostUsedPattern( nScCol, 0, nLastScRow, nScTab ), GetDefApiScript() );
 
     // column width
     USHORT nScWidth = rDoc.GetColWidth( nScCol, nScTab );
Index: sc/source/filter/excel/xichart.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xichart.cxx,v
retrieving revision 1.3
retrieving revision 1.2.4.11
diff -u -p -u -p -r1.3 -r1.2.4.11
--- sc/source/filter/excel/xichart.cxx	22 Apr 2005 11:33:03 -0000	1.3
+++ sc/source/filter/excel/xichart.cxx	9 Aug 2005 16:29:36 -0000	1.2.4.11
@@ -63,7 +63,6 @@
 #include "xichart.hxx"
 #endif
 
-#include <set>
 #include <algorithm>
 
 #ifndef _COM_SUN_STAR_LANG_XMULTISERVICEFACTORY_HPP_
@@ -146,6 +145,9 @@
 #ifndef SC_XIPAGE_HXX
 #include "xipage.hxx"
 #endif
+#ifndef SC_XIVIEW_HXX
+#include "xiview.hxx"
+#endif
 #ifndef SC_XIESCHER_HXX
 #include "xiescher.hxx"
 #endif
@@ -263,6 +265,17 @@ void XclImpChPos::ReadChPos( XclImpStrea
 
 // ----------------------------------------------------------------------------
 
+XclImpChLineFormat::XclImpChLineFormat( sal_uInt16 nObjId )
+{
+    switch( nObjId )
+    {
+        case EXC_ID_CHPLOTFRAME:
+            ::set_flag( maData.mnFlags, EXC_CHLINEFORMAT_AUTO, false );
+            maData.mnPattern = EXC_CHLINEFORMAT_NONE;
+        break;
+    }
+}
+
 void XclImpChLineFormat::ReadChLineFormat( XclImpStream& rStrm )
 {
     rStrm >> maData.maColor >> maData.mnPattern >> maData.mnWeight >> maData.mnFlags;
@@ -276,21 +289,22 @@ void XclImpChLineFormat::ReadChLineForma
     }
 }
 
-void XclImpChLineFormat::Convert( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet ) const
+void XclImpChLineFormat::Convert( const XclImpChRoot& rRoot,
+        ScfPropertySet& rPropSet, sal_uInt16 nAutoWeight ) const
 {
     if( IsAuto() )
     {
         XclChLineFormat aLineFmt;
         aLineFmt.maColor = rRoot.GetPalette().GetColor( EXC_COLOR_CHBORDERAUTO );
         aLineFmt.mnPattern = EXC_CHLINEFORMAT_SOLID;
-        aLineFmt.mnWeight = EXC_CHLINEFORMAT_SINGLE;
+        aLineFmt.mnWeight = nAutoWeight;
         rRoot.GetPropSetHelper().WriteToPropertySet( rPropSet, aLineFmt );
     }
     else
         rRoot.GetPropSetHelper().WriteToPropertySet( rPropSet, maData );
 }
 
-void XclImpChLineFormat::Convert( const XclImpChRoot& rRoot,
+void XclImpChLineFormat::ConvertSeries( const XclImpChRoot& rRoot,
         ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const
 {
     if( IsAuto() )
@@ -329,6 +343,17 @@ void XclImpChLineFormat::Convert( const 
 
 // ----------------------------------------------------------------------------
 
+XclImpChAreaFormat::XclImpChAreaFormat( sal_uInt16 nObjId )
+{
+    switch( nObjId )
+    {
+        case EXC_ID_CHPLOTFRAME:
+            ::set_flag( maData.mnFlags, EXC_CHAREAFORMAT_AUTO, false );
+            maData.mnPattern = EXC_CHAREAFORMAT_NONE;
+        break;
+    }
+}
+
 void XclImpChAreaFormat::ReadChAreaFormat( XclImpStream& rStrm )
 {
     rStrm >> maData.maForeColor >> maData.maBackColor >> maData.mnPattern >> maData.mnFlags;
@@ -357,7 +382,7 @@ void XclImpChAreaFormat::Convert( const 
         rRoot.GetPropSetHelper().WriteToPropertySet( rPropSet, maData );
 }
 
-void XclImpChAreaFormat::Convert( const XclImpChRoot& rRoot,
+void XclImpChAreaFormat::ConvertSeries( const XclImpChRoot& rRoot,
         ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const
 {
     if( IsAuto() )
@@ -465,17 +490,22 @@ void XclImpChFrameBase::ConvertFrame( co
 
 // ----------------------------------------------------------------------------
 
-void XclImpChFrame::ReadHeaderRecord( XclImpStream& rStrm )
+XclImpChFrame::XclImpChFrame( sal_uInt16 nObjId )
 {
-    rStrm >> maData.mnFormat >> maData.mnFlags;
+    switch( nObjId )
+    {
+        case EXC_ID_CHLEGEND:
+        case EXC_ID_CHPLOTFRAME:
+            // legend and plot frame need existing objects due to different defaults
+            mxLineFmt.reset( new XclImpChLineFormat( nObjId ) );
+            mxAreaFmt.reset( new XclImpChAreaFormat( nObjId ) );
+        break;
+    }
 }
 
-void XclImpChFrame::CreateMissingFormats()
+void XclImpChFrame::ReadHeaderRecord( XclImpStream& rStrm )
 {
-    if( !mxLineFmt )
-        mxLineFmt.reset( new XclImpChLineFormat );
-    if( !mxAreaFmt && !mxEscherFmt )
-        mxAreaFmt.reset( new XclImpChAreaFormat );
+    rStrm >> maData.mnFormat >> maData.mnFlags;
 }
 
 void XclImpChFrame::Convert( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet ) const
@@ -676,7 +706,7 @@ void XclImpChText::ReadSubRecord( XclImp
             mxFrame->ReadRecordGroup( rStrm );
         break;
         case EXC_ID_CHOBJECTLINK:
-            rStrm >> maObjLink.mnTarget >> maObjLink.mnSeriesIdx >> maObjLink.mnPointIdx;
+            rStrm >> maObjLink.mnTarget >> maObjLink.maPos.mnSeriesIdx >> maObjLink.maPos.mnPointIdx;
         break;
     }
 }
@@ -755,8 +785,8 @@ void XclImpChText::ConvertDataLabel( Scf
 
     bool bShowNone    = ::get_flag( maData.mnFlags, EXC_CHTEXT_DELETED );
     bool bShowCateg   = !bShowNone && ::get_flag( maData.mnFlags, EXC_CHTEXT_SHOWANYCATEG );
-    bool bShowValue   = !bShowNone && !bShowCateg && !bIsRound && ::get_flag( maData.mnFlags, EXC_CHTEXT_SHOWANYVALUE );
     bool bShowPercent = !bShowNone && bIsRound && ::get_flag( maData.mnFlags, EXC_CHTEXT_SHOWANYPERCENT );
+    bool bShowValue   = !bShowNone && !bShowPercent && ::get_flag( maData.mnFlags, EXC_CHTEXT_SHOWANYVALUE );
     bool bShowAny     = bShowValue || bShowPercent || bShowCateg;
     bool bShowSymbol  = bShowAny && ::get_flag( maData.mnFlags, EXC_CHTEXT_SHOWSYMBOL );
 
@@ -801,193 +831,6 @@ void lclUpdateTitle( XclImpChTextRef& rx
 
 // Linked source data =========================================================
 
-XclImpChAttachedLabel::XclImpChAttachedLabel( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot ),
-    mnFlags( 0 )
-{
-}
-
-void XclImpChAttachedLabel::ReadChAttachedLabel( XclImpStream& rStrm )
-{
-    rStrm >> mnFlags;
-}
-
-XclImpChTextRef XclImpChAttachedLabel::CreateDataLabel( XclImpChTextRef xParent ) const
-{
-    const sal_uInt16 EXC_CHATTLABEL_SHOWANYVALUE = EXC_CHATTLABEL_SHOWVALUE;
-    const sal_uInt16 EXC_CHATTLABEL_SHOWANYPERCENT = EXC_CHATTLABEL_SHOWPERCENT | EXC_CHATTLABEL_SHOWCATEGPERC;
-    const sal_uInt16 EXC_CHATTLABEL_SHOWANYCATEG = EXC_CHATTLABEL_SHOWCATEG | EXC_CHATTLABEL_SHOWCATEGPERC;
-
-    XclImpChTextRef xLabel( xParent.is() ? new XclImpChText( *xParent ) : new XclImpChText( GetChRoot() ) );
-    xLabel->UpdateDataLabel(
-        ::get_flag( mnFlags, EXC_CHATTLABEL_SHOWANYCATEG ),
-        ::get_flag( mnFlags, EXC_CHATTLABEL_SHOWANYVALUE ),
-        ::get_flag( mnFlags, EXC_CHATTLABEL_SHOWANYPERCENT ) );
-    return xLabel;
-}
-
-// ----------------------------------------------------------------------------
-
-XclImpChDataFormat::XclImpChDataFormat( const XclImpChRoot& rRoot ) :
-    XclImpChRoot( rRoot )
-{
-}
-
-void XclImpChDataFormat::ReadHeaderRecord( XclImpStream& rStrm )
-{
-    rStrm >> maData.mnPointIdx >> maData.mnSeriesIdx >> maData.mnFormatIdx >> maData.mnFlags;
-}
-
-void XclImpChDataFormat::ReadSubRecord( XclImpStream& rStrm )
-{
-    switch( rStrm.GetRecId() )
-    {
-        case EXC_ID_CHMARKERFORMAT:
-            mxMarkerFmt.reset( new XclImpChMarkerFormat );
-            mxMarkerFmt->ReadChMarkerFormat( rStrm );
-        break;
-        case EXC_ID_CHPIEFORMAT:
-            mxPieFmt.reset( new XclImpChPieFormat );
-            mxPieFmt->ReadChPieFormat( rStrm );
-        break;
-        case EXC_ID_CHSERIESFORMAT:
-            mxSeriesFmt.reset( new XclImpChSeriesFormat );
-            mxSeriesFmt->ReadChSeriesFormat( rStrm );
-        break;
-        case EXC_ID_CH3DDATAFORMAT:
-            mx3dDataFmt.reset( new XclImpCh3dDataFormat );
-            mx3dDataFmt->ReadCh3dDataFormat( rStrm );
-        break;
-        case EXC_ID_CHATTACHEDLABEL:
-            mxAttLabel.reset( new XclImpChAttachedLabel( GetChRoot() ) );
-            mxAttLabel->ReadChAttachedLabel( rStrm );
-        break;
-        default:
-            XclImpChFrameBase::ReadSubRecord( rStrm );
-    }
-}
-
-void XclImpChDataFormat::UpdateGlobalFormat()
-{
-    // remove formats not used for the current chart type
-    RemoveUnusedFormats();
-}
-
-void XclImpChDataFormat::UpdateSeriesFormat( const XclImpChDataFormat* pGlobalFmt )
-{
-    // update missing formats from passed global format
-    if( pGlobalFmt )
-    {
-        if( !mxLineFmt )
-            mxLineFmt = pGlobalFmt->mxLineFmt;
-        if( !mxAreaFmt && !mxEscherFmt )
-        {
-            mxAreaFmt = pGlobalFmt->mxAreaFmt;
-            mxEscherFmt = pGlobalFmt->mxEscherFmt;
-        }
-        if( !mxMarkerFmt )
-            mxMarkerFmt = pGlobalFmt->mxMarkerFmt;
-        if( !mxPieFmt )
-            mxPieFmt = pGlobalFmt->mxPieFmt;
-        if( !mxSeriesFmt )
-            mxSeriesFmt = pGlobalFmt->mxSeriesFmt;
-        if( !mx3dDataFmt )
-            mx3dDataFmt = pGlobalFmt->mx3dDataFmt;
-        if( !mxAttLabel )
-            mxAttLabel = pGlobalFmt->mxAttLabel;
-    }
-
-    /*  Create missing but required formats. Existing line, area, and marker
-        format objects are needed to create automatic series formatting. */
-    if( !mxLineFmt )
-        mxLineFmt.reset( new XclImpChLineFormat );
-    if( !mxAreaFmt && !mxEscherFmt )
-        mxAreaFmt.reset( new XclImpChAreaFormat );
-    if( !mxMarkerFmt )
-        mxMarkerFmt.reset( new XclImpChMarkerFormat );
-
-    // remove formats not used for the current chart type
-    RemoveUnusedFormats();
-    // update data label
-    UpdateDataLabel( pGlobalFmt );
-}
-
-void XclImpChDataFormat::UpdatePointFormat( const XclImpChDataFormat* pSeriesFmt )
-{
-    // remove formats if they are automatic in this and in the passed series format
-    if( pSeriesFmt )
-    {
-        if( IsAutoLine() && pSeriesFmt->IsAutoLine() )
-            mxLineFmt.reset();
-        if( IsAutoArea() && pSeriesFmt->IsAutoArea() )
-            mxAreaFmt.reset();
-        if( IsAutoMarker() && pSeriesFmt->IsAutoMarker() )
-            mxMarkerFmt.reset();
-        mxSeriesFmt.reset();
-    }
-
-    // remove formats not used for the current chart type
-    RemoveUnusedFormats();
-    // update data label
-    UpdateDataLabel( pSeriesFmt );
-}
-
-void XclImpChDataFormat::Convert( ScfPropertySet& rPropSet ) const
-{
-    if( mxLineFmt.is() )
-        mxLineFmt->Convert( GetChRoot(), rPropSet, maData.mnFormatIdx );
-    // area format - CHESCHERFORMAT overrides CHAREAFORMAT
-    if( mxEscherFmt.is() )
-        mxEscherFmt->Convert( GetChRoot(), rPropSet );
-    else if( mxAreaFmt.is() )
-        mxAreaFmt->Convert( GetChRoot(), rPropSet, maData.mnFormatIdx );
-    if( mxMarkerFmt.is() )
-        mxMarkerFmt->Convert( GetChRoot(), rPropSet, maData.mnFormatIdx, GetLineWeight() );
-    if( mxPieFmt.is() )
-        mxPieFmt->Convert( rPropSet );
-    if( mx3dDataFmt.is() )
-        mx3dDataFmt->Convert( rPropSet );
-    if( mxLabel.is() )
-        mxLabel->ConvertDataLabel( rPropSet );
-}
-
-void XclImpChDataFormat::ConvertVarPoint( ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const
-{
-    if( mxAreaFmt.is() && IsAutoArea() )
-        mxAreaFmt->Convert( GetChRoot(), rPropSet, nFormatIdx );
-}
-
-void XclImpChDataFormat::RemoveUnusedFormats()
-{
-    sal_uInt16 nTypeId = GetChartData().GetChartTypeId();
-    // pie format only in pie charts (not supported in OOChart donut charts)
-    if( nTypeId != EXC_ID_CHPIE )
-        mxPieFmt.reset();
-    // 3D format only in 3D bar charts
-    if( !GetChartData().Is3dChart() || (nTypeId != EXC_ID_CHBAR) )
-        mx3dDataFmt.reset();
-}
-
-void XclImpChDataFormat::UpdateDataLabel( const XclImpChDataFormat* pParentFmt )
-{
-    /*  CHTEXT groups linked to data labels override existing CHATTACHEDLABEL
-        records. Only if there is a CHATTACHEDLABEL record without a CHTEXT
-        group, the contents of the CHATTACHEDLABEL record are used. In this
-        case a new CHTEXT group is created and filled with the settings from
-        the CHATTACHEDLABEL record. */
-    XclImpChTextRef xDefText;
-    if( pParentFmt )
-        xDefText = pParentFmt->GetDataLabel();
-    if( !xDefText )
-        xDefText = GetChartData().GetDefaultText( EXC_CHDEFTEXT_LABEL );
-    if( mxLabel.is() )
-        mxLabel->UpdateText( xDefText.get() );
-    else if( mxAttLabel.is() )
-        mxLabel = mxAttLabel->CreateDataLabel( xDefText );
-}
-
-// ----------------------------------------------------------------------------
-
 namespace {
 
 XclChOrientation lclGetOrientation( const ScRange& rScRange )
@@ -1249,103 +1092,303 @@ void XclImpChSourceLink::CalcOrientation
     }
 }
 
-void XclImpChSourceLink::AppendSingleCell( SCCOL nScCol, SCROW nScRow )
-{
-    if( (mnScCol == nScCol) && (mnScRow < nScRow) )
-        AppendColumnRange( nScCol, nScRow, nScRow );
-    else if( (mnScRow == nScRow) && (mnScCol < nScCol) )
-        AppendRowRange( nScCol, nScCol, nScRow );
-    else
-        meOrient = EXC_CHORIENT_COMPLEX;
+void XclImpChSourceLink::AppendSingleCell( SCCOL nScCol, SCROW nScRow )
+{
+    if( (mnScCol == nScCol) && (mnScRow < nScRow) )
+        AppendColumnRange( nScCol, nScRow, nScRow );
+    else if( (mnScRow == nScRow) && (mnScCol < nScCol) )
+        AppendRowRange( nScCol, nScCol, nScRow );
+    else
+        meOrient = EXC_CHORIENT_COMPLEX;
+}
+
+void XclImpChSourceLink::AppendColumnRange( SCCOL nScCol, SCROW nScRow1, SCROW nScRow2 )
+{
+    switch( meOrient )
+    {
+        // Append column to single cell: Column indexes must be equal.
+        case EXC_CHORIENT_SINGLE:
+            if( (mnScCol == nScCol) && (mnScRow < nScRow1) )
+                UpdateOrientation( EXC_CHORIENT_VERTICAL, nScRow1, nScRow2 );
+            else
+                meOrient = EXC_CHORIENT_COMPLEX;
+        break;
+        // Append column to column: Column indexes must be equal.
+        case EXC_CHORIENT_VERTICAL:
+            if( (maMainPos.mnScPos == nScCol) && (maIntervals.back().mnScPos2 < nScRow1) )
+                AppendInterval( nScRow1, nScRow2 );
+            else
+                meOrient = EXC_CHORIENT_COMPLEX;
+        break;
+        // Append column to row: Give up.
+        case EXC_CHORIENT_HORIZONTAL:
+            meOrient = EXC_CHORIENT_COMPLEX;
+        break;
+    }
+}
+
+void XclImpChSourceLink::AppendRowRange( SCCOL nScCol1, SCCOL nScCol2, SCROW nScRow )
+{
+    switch( meOrient )
+    {
+        // Append row to single cell: Row indexes must be equal.
+        case EXC_CHORIENT_SINGLE:
+            if( (mnScRow == nScRow) && (mnScCol < nScCol1) )
+                UpdateOrientation( EXC_CHORIENT_HORIZONTAL, nScCol1, nScCol2 );
+            else
+                meOrient = EXC_CHORIENT_COMPLEX;
+        break;
+        // Append row to column: Give up.
+        case EXC_CHORIENT_VERTICAL:
+            meOrient = EXC_CHORIENT_COMPLEX;
+        break;
+        // Append row to row: Row indexes must be equal.
+        case EXC_CHORIENT_HORIZONTAL:
+            if( (maMainPos.mnScPos == nScRow) && (maIntervals.back().mnScPos2 < nScCol1) )
+                AppendInterval( nScCol1, nScCol2 );
+            else
+                meOrient = EXC_CHORIENT_COMPLEX;
+        break;
+    }
+}
+
+void XclImpChSourceLink::UpdateOrientation( XclChOrientation eOrient, SCCOLROW nScPos1, SCCOLROW nScPos2 )
+{
+    SetFinalOrientation( eOrient );
+    AppendInterval( nScPos1, nScPos2 );
+}
+
+void XclImpChSourceLink::AppendInterval( SCCOLROW nScPos1, SCCOLROW nScPos2 )
+{
+    DBG_ASSERT( nScPos1 <= nScPos2, "XclImpChSourceLink::AppendInterval - invalid interval" );
+    if( maIntervals.empty() )
+    {
+        // empty interval list: insert the new interval
+        maIntervals.push_back( XclImpChInterval( nScPos1, nScPos2 ) );
+    }
+    else if( maIntervals.back().mnScPos2 < nScPos1 )
+    {
+        // extend last interval if possible
+        if( maIntervals.back().mnScPos2 + 1 == nScPos1 )
+            maIntervals.back().mnScPos2 = nScPos2;
+        else
+            maIntervals.push_back( XclImpChInterval( nScPos1, nScPos2 ) );
+    }
+    else
+        DBG_ERRORFILE( "XclImpChSourceLink::AppendInterval - invalid interval" );
+
+    // count number of cells
+    mnCells += static_cast< sal_uInt16 >( nScPos2 - nScPos1 + 1 );
+}
+
+// ----------------------------------------------------------------------------
+
+XclImpChAttachedLabel::XclImpChAttachedLabel( const XclImpChRoot& rRoot ) :
+    XclImpChRoot( rRoot ),
+    mnFlags( 0 )
+{
+}
+
+void XclImpChAttachedLabel::ReadChAttachedLabel( XclImpStream& rStrm )
+{
+    rStrm >> mnFlags;
+}
+
+XclImpChTextRef XclImpChAttachedLabel::CreateDataLabel( XclImpChTextRef xParent ) const
+{
+    const sal_uInt16 EXC_CHATTLABEL_SHOWANYVALUE = EXC_CHATTLABEL_SHOWVALUE;
+    const sal_uInt16 EXC_CHATTLABEL_SHOWANYPERCENT = EXC_CHATTLABEL_SHOWPERCENT | EXC_CHATTLABEL_SHOWCATEGPERC;
+    const sal_uInt16 EXC_CHATTLABEL_SHOWANYCATEG = EXC_CHATTLABEL_SHOWCATEG | EXC_CHATTLABEL_SHOWCATEGPERC;
+
+    XclImpChTextRef xLabel( xParent.is() ? new XclImpChText( *xParent ) : new XclImpChText( GetChRoot() ) );
+    xLabel->UpdateDataLabel(
+        ::get_flag( mnFlags, EXC_CHATTLABEL_SHOWANYCATEG ),
+        ::get_flag( mnFlags, EXC_CHATTLABEL_SHOWANYVALUE ),
+        ::get_flag( mnFlags, EXC_CHATTLABEL_SHOWANYPERCENT ) );
+    return xLabel;
+}
+
+// ----------------------------------------------------------------------------
+
+XclImpChDataFormat::XclImpChDataFormat( const XclImpChRoot& rRoot ) :
+    XclImpChRoot( rRoot )
+{
+}
+
+void XclImpChDataFormat::ReadHeaderRecord( XclImpStream& rStrm )
+{
+    rStrm >> maData.maPos.mnPointIdx >> maData.maPos.mnSeriesIdx >> maData.mnFormatIdx >> maData.mnFlags;
+}
+
+void XclImpChDataFormat::ReadSubRecord( XclImpStream& rStrm )
+{
+    switch( rStrm.GetRecId() )
+    {
+        case EXC_ID_CHMARKERFORMAT:
+            mxMarkerFmt.reset( new XclImpChMarkerFormat );
+            mxMarkerFmt->ReadChMarkerFormat( rStrm );
+        break;
+        case EXC_ID_CHPIEFORMAT:
+            mxPieFmt.reset( new XclImpChPieFormat );
+            mxPieFmt->ReadChPieFormat( rStrm );
+        break;
+        case EXC_ID_CHSERIESFORMAT:
+            mxSeriesFmt.reset( new XclImpChSeriesFormat );
+            mxSeriesFmt->ReadChSeriesFormat( rStrm );
+        break;
+        case EXC_ID_CH3DDATAFORMAT:
+            mx3dDataFmt.reset( new XclImpCh3dDataFormat );
+            mx3dDataFmt->ReadCh3dDataFormat( rStrm );
+        break;
+        case EXC_ID_CHATTACHEDLABEL:
+            mxAttLabel.reset( new XclImpChAttachedLabel( GetChRoot() ) );
+            mxAttLabel->ReadChAttachedLabel( rStrm );
+        break;
+        default:
+            XclImpChFrameBase::ReadSubRecord( rStrm );
+    }
+}
+
+void XclImpChDataFormat::SetPointPos( sal_uInt16 nSeriesIdx, sal_uInt16 nPointIdx, sal_uInt16 nFormatIdx )
+{
+    maData.maPos.mnSeriesIdx = nSeriesIdx;
+    maData.maPos.mnPointIdx = nPointIdx;
+    maData.mnFormatIdx = nFormatIdx;
+}
+
+void XclImpChDataFormat::UpdateGlobalFormat()
+{
+    // remove formats not used for the current chart type
+    RemoveUnusedFormats();
+}
+
+void XclImpChDataFormat::UpdateSeriesFormat( const XclImpChDataFormat* pGlobalFmt )
+{
+    // update missing formats from passed global format
+    if( pGlobalFmt )
+    {
+        if( !mxLineFmt )
+            mxLineFmt = pGlobalFmt->mxLineFmt;
+        if( !mxAreaFmt && !mxEscherFmt )
+        {
+            mxAreaFmt = pGlobalFmt->mxAreaFmt;
+            mxEscherFmt = pGlobalFmt->mxEscherFmt;
+        }
+        if( !mxMarkerFmt )
+            mxMarkerFmt = pGlobalFmt->mxMarkerFmt;
+        if( !mxPieFmt )
+            mxPieFmt = pGlobalFmt->mxPieFmt;
+        if( !mxSeriesFmt )
+            mxSeriesFmt = pGlobalFmt->mxSeriesFmt;
+        if( !mx3dDataFmt )
+            mx3dDataFmt = pGlobalFmt->mx3dDataFmt;
+        if( !mxAttLabel )
+            mxAttLabel = pGlobalFmt->mxAttLabel;
+    }
+
+    /*  Create missing but required formats. Existing line, area, and marker
+        format objects are needed to create automatic series formatting. */
+    if( !mxLineFmt )
+        mxLineFmt.reset( new XclImpChLineFormat );
+    if( !mxAreaFmt && !mxEscherFmt )
+        mxAreaFmt.reset( new XclImpChAreaFormat );
+    if( !mxMarkerFmt )
+        mxMarkerFmt.reset( new XclImpChMarkerFormat );
+
+    // remove formats not used for the current chart type
+    RemoveUnusedFormats();
+    // update data label
+    UpdateDataLabel( pGlobalFmt );
 }
 
-void XclImpChSourceLink::AppendColumnRange( SCCOL nScCol, SCROW nScRow1, SCROW nScRow2 )
+void XclImpChDataFormat::UpdatePointFormat( const XclImpChDataFormat* pSeriesFmt )
 {
-    switch( meOrient )
+    // remove formats if they are automatic in this and in the passed series format
+    if( pSeriesFmt )
     {
-        // Append column to single cell: Column indexes must be equal.
-        case EXC_CHORIENT_SINGLE:
-            if( (mnScCol == nScCol) && (mnScRow < nScRow1) )
-                UpdateOrientation( EXC_CHORIENT_VERTICAL, nScRow1, nScRow2 );
-            else
-                meOrient = EXC_CHORIENT_COMPLEX;
-        break;
-        // Append column to column: Column indexes must be equal.
-        case EXC_CHORIENT_VERTICAL:
-            if( (maMainPos.mnScPos == nScCol) && (maIntervals.back().mnScPos2 < nScRow1) )
-                AppendInterval( nScRow1, nScRow2 );
-            else
-                meOrient = EXC_CHORIENT_COMPLEX;
-        break;
-        // Append column to row: Give up.
-        case EXC_CHORIENT_HORIZONTAL:
-            meOrient = EXC_CHORIENT_COMPLEX;
-        break;
+        if( IsAutoLine() && pSeriesFmt->IsAutoLine() )
+            mxLineFmt.reset();
+        if( IsAutoArea() && pSeriesFmt->IsAutoArea() )
+            mxAreaFmt.reset();
+        if( IsAutoMarker() && pSeriesFmt->IsAutoMarker() )
+            mxMarkerFmt.reset();
+        mxSeriesFmt.reset();
     }
+
+    // remove formats not used for the current chart type
+    RemoveUnusedFormats();
+    // update data label
+    UpdateDataLabel( pSeriesFmt );
 }
 
-void XclImpChSourceLink::AppendRowRange( SCCOL nScCol1, SCCOL nScCol2, SCROW nScRow )
+void XclImpChDataFormat::Convert( ScfPropertySet& rPropSet ) const
 {
-    switch( meOrient )
-    {
-        // Append row to single cell: Row indexes must be equal.
-        case EXC_CHORIENT_SINGLE:
-            if( (mnScRow == nScRow) && (mnScCol < nScCol1) )
-                UpdateOrientation( EXC_CHORIENT_HORIZONTAL, nScCol1, nScCol2 );
-            else
-                meOrient = EXC_CHORIENT_COMPLEX;
-        break;
-        // Append row to column: Give up.
-        case EXC_CHORIENT_VERTICAL:
-            meOrient = EXC_CHORIENT_COMPLEX;
-        break;
-        // Append row to row: Row indexes must be equal.
-        case EXC_CHORIENT_HORIZONTAL:
-            if( (maMainPos.mnScPos == nScRow) && (maIntervals.back().mnScPos2 < nScCol1) )
-                AppendInterval( nScCol1, nScCol2 );
-            else
-                meOrient = EXC_CHORIENT_COMPLEX;
-        break;
-    }
+    if( mxLineFmt.is() )
+        mxLineFmt->ConvertSeries( GetChRoot(), rPropSet, maData.mnFormatIdx );
+    // area format - CHESCHERFORMAT overrides CHAREAFORMAT
+    if( mxEscherFmt.is() )
+        mxEscherFmt->Convert( GetChRoot(), rPropSet );
+    else if( mxAreaFmt.is() )
+        mxAreaFmt->ConvertSeries( GetChRoot(), rPropSet, maData.mnFormatIdx );
+    if( mxMarkerFmt.is() )
+        mxMarkerFmt->Convert( GetChRoot(), rPropSet, maData.mnFormatIdx, GetLineWeight() );
+    if( mxPieFmt.is() )
+        mxPieFmt->Convert( rPropSet );
+    if( mx3dDataFmt.is() )
+        mx3dDataFmt->Convert( rPropSet );
+    if( mxLabel.is() )
+        mxLabel->ConvertDataLabel( rPropSet );
 }
 
-void XclImpChSourceLink::UpdateOrientation( XclChOrientation eOrient, SCCOLROW nScPos1, SCCOLROW nScPos2 )
+void XclImpChDataFormat::ConvertVarPoint( ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const
 {
-    SetFinalOrientation( eOrient );
-    AppendInterval( nScPos1, nScPos2 );
+    if( mxAreaFmt.is() && IsAutoArea() )
+        mxAreaFmt->ConvertSeries( GetChRoot(), rPropSet, nFormatIdx );
 }
 
-void XclImpChSourceLink::AppendInterval( SCCOLROW nScPos1, SCCOLROW nScPos2 )
+void XclImpChDataFormat::ConvertLine( ScfPropertySet& rPropSet, sal_uInt16 nAutoWeight ) const
 {
-    DBG_ASSERT( nScPos1 <= nScPos2, "XclImpChSourceLink::AppendInterval - invalid interval" );
-    if( maIntervals.empty() )
-    {
-        // empty interval list: insert the new interval
-        maIntervals.push_back( XclImpChInterval( nScPos1, nScPos2 ) );
-    }
-    else if( maIntervals.back().mnScPos2 < nScPos1 )
-    {
-        // extend last interval if possible
-        if( maIntervals.back().mnScPos2 + 1 == nScPos1 )
-            maIntervals.back().mnScPos2 = nScPos2;
-        else
-            maIntervals.push_back( XclImpChInterval( nScPos1, nScPos2 ) );
-    }
-    else
-        DBG_ERRORFILE( "XclImpChSourceLink::AppendInterval - invalid interval" );
+    if( mxLineFmt.is() )
+        mxLineFmt->Convert( GetChRoot(), rPropSet, nAutoWeight );
+}
 
-    // count number of cells
-    mnCells += static_cast< sal_uInt16 >( nScPos2 - nScPos1 + 1 );
+void XclImpChDataFormat::RemoveUnusedFormats()
+{
+    sal_uInt16 nTypeId = GetChartData().GetChartTypeId();
+    // pie format only in pie charts (not supported in OOChart donut charts)
+    if( nTypeId != EXC_ID_CHPIE )
+        mxPieFmt.reset();
+    // 3D format only in 3D bar charts
+    if( !GetChartData().Is3dChart() || (nTypeId != EXC_ID_CHBAR) )
+        mx3dDataFmt.reset();
+}
+
+void XclImpChDataFormat::UpdateDataLabel( const XclImpChDataFormat* pParentFmt )
+{
+    /*  CHTEXT groups linked to data labels override existing CHATTACHEDLABEL
+        records. Only if there is a CHATTACHEDLABEL record without a CHTEXT
+        group, the contents of the CHATTACHEDLABEL record are used. In this
+        case a new CHTEXT group is created and filled with the settings from
+        the CHATTACHEDLABEL record. */
+    XclImpChTextRef xDefText;
+    if( pParentFmt )
+        xDefText = pParentFmt->GetDataLabel();
+    if( !xDefText )
+        xDefText = GetChartData().GetDefaultText( EXC_CHDEFTEXT_LABEL );
+    if( mxLabel.is() )
+        mxLabel->UpdateText( xDefText.get() );
+    else if( mxAttLabel.is() )
+        mxLabel = mxAttLabel->CreateDataLabel( xDefText );
 }
 
 // ----------------------------------------------------------------------------
 
-XclImpChSeries::XclImpChSeries( const XclImpChRoot& rRoot ) :
+XclImpChSeries::XclImpChSeries( const XclImpChRoot& rRoot, sal_uInt16 nSeriesIdx ) :
     XclImpChRoot( rRoot ),
     meOrient( EXC_CHORIENT_EMPTY ),
     mnGroupIdx( EXC_CHSERGROUP_NONE ),
-    mnSeriesIdx( EXC_CHSERIES_INVALID ),
-    mbHasParent( false ),
+    mnSeriesIdx( nSeriesIdx ),
+    mnParentIdx( EXC_CHSERIES_INVALID ),
     mbHasValue( false ),
     mbHasCateg( false ),
     mbHasTitle( false )
@@ -1373,13 +1416,13 @@ void XclImpChSeries::ReadSubRecord( XclI
             rStrm >> mnGroupIdx;
         break;
         case EXC_ID_CHSERPARENT:
-            mbHasParent = true;
+            ReadChSerParent( rStrm );
         break;
         case EXC_ID_CHSERTRENDLINE:
             GetTracer().TraceChartTrendLines();
         break;
         case EXC_ID_CHEND:
-            CalcOrientation();
+            ReadChEnd( rStrm );
         break;
     }
 }
@@ -1488,40 +1531,63 @@ void XclImpChSeries::AddTitleToValues()
     }
 }
 
+void XclImpChSeries::SetDataFormat( XclImpChDataFormatRef xDataFmt )
+{
+    if( xDataFmt.is() )
+    {
+        XclImpChDataFormatRef* pxDataFmt = GetDataFormatRef( xDataFmt->GetPointPos().mnPointIdx );
+        // do not overwrite existing data format
+        if( pxDataFmt && !*pxDataFmt )
+        {
+            *pxDataFmt = xDataFmt;
+            // #i51639# register series format index at chart group
+            if( pxDataFmt == &mxSeriesFmt )
+                GetChartData().GetDefChartGroup( mnGroupIdx ).SetUsedFormatIndex( xDataFmt->GetFormatIdx() );
+        }
+    }
+}
+
 void XclImpChSeries::SetDataLabel( XclImpChTextRef xLabel )
 {
     if( xLabel.is() )
     {
-        sal_uInt16 nPointIdx = xLabel->GetPointIdx();
+        XclImpChTextRef* pxLabel = GetDataLabelRef( xLabel->GetPointPos().mnPointIdx );
+        if( pxLabel && !*pxLabel )
+            *pxLabel = xLabel;
+    }
+}
 
-        // find the variable that stores the reference to the data format
-        XclImpChDataFormatRef* pxDataFmt = 0;
-        if( nPointIdx == EXC_CHDATAFORMAT_ALLPOINTS )
-            pxDataFmt = &mxSeriesFmt;
-        else if( nPointIdx <= EXC_CHDATAFORMAT_MAXPOINT )
-            pxDataFmt = &maPointFmts[ nPointIdx ];
+void XclImpChSeries::FinalizeDataFormats()
+{
+    // create missing series format
+    if( !mxSeriesFmt && !HasParentSeries() )
+    {
+        // #i51639# use a new unused format index to create series default format
+        sal_uInt16 nFormatIdx = GetChartData().GetDefChartGroup( mnGroupIdx ).PopUnusedFormatIndex();
+        mxSeriesFmt = CreateDataFormat( EXC_CHDATAFORMAT_ALLPOINTS, nFormatIdx );
+    }
 
-        if( pxDataFmt )
+    // set text labels to data formats
+    for( XclImpChTextMap::iterator aTIt = maLabels.begin(), aTEnd = maLabels.end(); aTIt != aTEnd; ++aTIt )
+    {
+        if( XclImpChDataFormatRef* pxDataFmt = GetDataFormatRef( aTIt->first ) )
         {
-            // create new CHDATAFORMAT group, if still missing
             if( !*pxDataFmt )
-                pxDataFmt->reset( new XclImpChDataFormat( GetChRoot() ) );
-            (*pxDataFmt)->SetDataLabel( xLabel );
+                *pxDataFmt = CreateDataFormat( aTIt->first, EXC_CHDATAFORMAT_DEFAULT );
+            (*pxDataFmt)->SetDataLabel( aTIt->second );
         }
     }
-}
 
-void XclImpChSeries::UpdateSeriesFormat()
-{
     // update series format (copy missing formatting from global format)
     if( mxSeriesFmt.is() )
     {
-        XclImpChDataFormatRef xGlobalFmt = GetChartData().GetChartFormat( mnGroupIdx ).GetGlobalFormat();
+        XclImpChDataFormatRef xGlobalFmt = GetChartData().GetDefChartGroup( mnGroupIdx ).GetGlobalFormat();
         mxSeriesFmt->UpdateSeriesFormat( xGlobalFmt.get() );
     }
+
     // update data point formats (removes unchanged automatic formatting)
-    for( XclImpChDataFormatMap::iterator aIt = maPointFmts.begin(), aEnd = maPointFmts.end(); aIt != aEnd; ++aIt )
-        aIt->second->UpdatePointFormat( mxSeriesFmt.get() );
+    for( XclImpChDataFormatMap::iterator aFIt = maPointFmts.begin(), aFEnd = maPointFmts.end(); aFIt != aFEnd; ++aFIt )
+        aFIt->second->UpdatePointFormat( mxSeriesFmt.get() );
 }
 
 bool XclImpChSeries::HasEqualCategories( const XclImpChSeries& rSeries ) const
@@ -1610,7 +1676,7 @@ void XclImpChSeries::Convert( XChartDocR
 
     // chart type and number of series on the axes set
     sal_uInt16 nTypeId = GetChartData().GetChartTypeId();
-    sal_uInt16 nSeriesCount = GetChartData().GetSeriesCount( mnGroupIdx );
+    sal_uInt16 nSeriesCount = GetChartData().GetChartGroupSeriesCount( mnGroupIdx );
     sal_uInt16 nPointCount = GetPointCount();
 
     // don't set any formatting on additional pie series (may change formats of first series)
@@ -1618,7 +1684,7 @@ void XclImpChSeries::Convert( XChartDocR
         return;
 
     // variable automatic point colors in a series
-    bool bVarPoints = GetChartData().GetChartFormat( mnGroupIdx ).IsVarPointFormat();
+    bool bVarPoints = GetChartData().GetDefChartGroup( mnGroupIdx ).IsVarPointFormat();
 
     // ------------------------------------------------------------------------
     // write global series formatting and assign series to correct axes set
@@ -1649,22 +1715,20 @@ void XclImpChSeries::Convert( XChartDocR
         ScfPropertySet aSeriesProp( lclGetSeriesPropSet( xDiagram, nTypeId, nSeriesIdx ) );
         // attach series to correct axes set
         using namespace ::com::sun::star::chart::ChartAxisAssign;
-        bool bSecondary = GetChartData().GetAxesSetId( mnGroupIdx ) == EXC_CHAXESSET_SECONDARY;
+        bool bSecondary = GetChartData().GetChartGroupAxesSetId( mnGroupIdx ) == EXC_CHAXESSET_SECONDARY;
         aSeriesProp.SetProperty( EXC_CHPROP_AXIS, bSecondary ? SECONDARY_Y : PRIMARY_Y );
         // set the series formatting
         if( mxSeriesFmt.is() )
-        {
             mxSeriesFmt->Convert( aSeriesProp );
-            // own area formatting for every data point
-            if( bVarPoints && (nSeriesCount == 1) && mxSeriesFmt->IsAutoArea() )
+        // own area formatting for every data point
+        if( bVarPoints && (nSeriesCount == 1) && mxSeriesFmt.is() && mxSeriesFmt->IsAutoArea() )
+        {
+            for( sal_uInt16 nPointIdx = 0; nPointIdx < nPointCount; ++nPointIdx )
             {
-                for( sal_uInt16 nPointIdx = 0; nPointIdx < nPointCount; ++nPointIdx )
-                {
-                    // get the data point property set from the chart
-                    ScfPropertySet aPointProp( lclGetPointPropSet( xDiagram, nTypeId, nSeriesIdx, nPointIdx ) );
-                    // set the data point formatting, nPointIdx used as automatic format index
-                    mxSeriesFmt->ConvertVarPoint( aPointProp, nPointIdx );
-                }
+                // get the data point property set from the chart
+                ScfPropertySet aPointProp( lclGetPointPropSet( xDiagram, nTypeId, nSeriesIdx, nPointIdx ) );
+                // set the data point formatting, nPointIdx used as automatic format index
+                mxSeriesFmt->ConvertVarPoint( aPointProp, nPointIdx );
             }
         }
     }
@@ -1695,17 +1759,24 @@ void XclImpChSeries::ReadChSourceLink( X
 
 void XclImpChSeries::ReadChDataFormat( XclImpStream& rStrm )
 {
-    XclImpChDataFormatRef xDataFmt( new XclImpChDataFormat( GetChRoot() ) );
-    xDataFmt->ReadRecordGroup( rStrm );
+    // #i51639# chart stores all data formats and assigns them later to the series
+    GetChartData().ReadChDataFormat( rStrm );
+}
 
-    sal_uInt16 nPointIdx = xDataFmt->GetPointIdx();
-    if( nPointIdx == EXC_CHDATAFORMAT_ALLPOINTS )
-        mxSeriesFmt = xDataFmt;
-    else if( nPointIdx <= EXC_CHDATAFORMAT_MAXPOINT )
-        maPointFmts[ nPointIdx ] = xDataFmt;
+void XclImpChSeries::ReadChSerParent( XclImpStream& rStrm )
+{
+    rStrm >> mnParentIdx;
+    // index to parent series is 1-based, convert it to 0-based
+    if( mnParentIdx > 0 )
+        --mnParentIdx;
+    else
+        mnParentIdx = EXC_CHSERIES_INVALID;
+}
 
-    if( mnSeriesIdx == EXC_CHSERIES_INVALID )
-        mnSeriesIdx = xDataFmt->GetSeriesIdx();
+void XclImpChSeries::ReadChEnd( XclImpStream& rStrm )
+{
+    // calculate the orientation of this series
+    CalcOrientation();
 }
 
 void XclImpChSeries::CalcOrientation()
@@ -1714,7 +1785,7 @@ void XclImpChSeries::CalcOrientation()
     mbHasValue = mbHasCateg = mbHasTitle = false;
 
     // range for values (ignore child series, e.g. trend lines and error bars)
-    if( !mbHasParent && mxValueLink.is() && mxValueLink->HasValidOrientation() )
+    if( !HasParentSeries() && mxValueLink.is() && mxValueLink->HasValidOrientation() )
     {
         meOrient = mxValueLink->GetOrientation();
         mbHasValue = true;
@@ -1744,6 +1815,29 @@ void XclImpChSeries::CalcOrientation()
         GetTracer().TraceChartRange();
 }
 
+XclImpChDataFormatRef XclImpChSeries::CreateDataFormat( sal_uInt16 nPointIdx, sal_uInt16 nFormatIdx )
+{
+    XclImpChDataFormatRef xDataFmt( new XclImpChDataFormat( GetChRoot() ) );
+    xDataFmt->SetPointPos( mnSeriesIdx, nPointIdx, nFormatIdx );
+    return xDataFmt;
+}
+
+XclImpChDataFormatRef* XclImpChSeries::GetDataFormatRef( sal_uInt16 nPointIdx )
+{
+    if( nPointIdx == EXC_CHDATAFORMAT_ALLPOINTS )
+        return &mxSeriesFmt;
+    if( nPointIdx <= EXC_CHDATAFORMAT_MAXPOINT )
+        return &maPointFmts[ nPointIdx ];
+    return 0;
+}
+
+XclImpChTextRef* XclImpChSeries::GetDataLabelRef( sal_uInt16 nPointIdx )
+{
+    if( (nPointIdx == EXC_CHDATAFORMAT_ALLPOINTS) || (nPointIdx <= EXC_CHDATAFORMAT_MAXPOINT) )
+        return &maLabels[ nPointIdx ];
+    return 0;
+}
+
 // ----------------------------------------------------------------------------
 
 /** Binary predicate to compare two series by main position.
@@ -1790,6 +1884,12 @@ void XclImpChType::ReadChType( XclImpStr
                 maData.mnFlags = 0;
         break;
 
+        case EXC_ID_CHPIEEXT:
+            maData.mnRotation = 0;
+            maData.mnPieHole = 0;
+            maData.mnFlags = 0;
+        break;
+
         case EXC_ID_CHSCATTER:
             if( eBiff == EXC_BIFF8 )
                 rStrm >> maData.mnBubbleSize >> maData.mnBubbleType >> maData.mnFlags;
@@ -1807,7 +1907,7 @@ void XclImpChType::ReadChType( XclImpStr
 
 void XclImpChType::Finalize()
 {
-    bool bIsPrimary = GetChartData().GetAxesSetId( mnGroupIdx ) == EXC_CHAXESSET_PRIMARY;
+    bool bIsPrimary = GetChartData().GetChartGroupAxesSetId( mnGroupIdx ) == EXC_CHAXESSET_PRIMARY;
     switch( mnTypeId )
     {
         case EXC_ID_CHLINE:
@@ -1821,6 +1921,10 @@ void XclImpChType::Finalize()
             if( maData.mnPieHole > 0 )
                 mnTypeId = EXC_ID_CHDONUT;
         break;
+        case EXC_ID_CHPIEEXT:
+            // #i49241# pie-to-pie and pie-to-bar not supported - convert to pie chart
+            mnTypeId = EXC_ID_CHPIE;
+        break;
         case EXC_ID_CHSCATTER:
             // bubble chart - imported as XY chart
             if( ::get_flag( maData.mnFlags, EXC_CHSCATTER_BUBBLES ) )
@@ -1843,7 +1947,7 @@ void XclImpChType::Finalize()
 
 void XclImpChType::CreateDiagram( XChartDocRef xChartDoc ) const
 {
-    bool bIsPrimary = GetChartData().GetAxesSetId( mnGroupIdx ) == EXC_CHAXESSET_PRIMARY;
+    bool bIsPrimary = GetChartData().GetChartGroupAxesSetId( mnGroupIdx ) == EXC_CHAXESSET_PRIMARY;
     DBG_ASSERT( bIsPrimary, "XclImpChType::CreateDiagram - not allowed for secondary axes" );
     Reference< XMultiServiceFactory > xFactory( xChartDoc, UNO_QUERY );
     if( !bIsPrimary || !xFactory.is() ) return;
@@ -1878,7 +1982,7 @@ void XclImpChType::CreateDiagram( XChart
 
 void XclImpChType::Convert( XChartDocRef xChartDoc ) const
 {
-    bool bIsPrimary = GetChartData().GetAxesSetId( mnGroupIdx ) == EXC_CHAXESSET_PRIMARY;
+    bool bIsPrimary = GetChartData().GetChartGroupAxesSetId( mnGroupIdx ) == EXC_CHAXESSET_PRIMARY;
     Reference< XDiagram > xDiagram( xChartDoc->getDiagram() );
     ScfPropertySet aDiaProp( xDiagram );
 
@@ -1982,14 +2086,13 @@ void XclImpChLegend::ReadSubRecord( XclI
             mxText->ReadRecordGroup( rStrm );
         break;
         case EXC_ID_CHFRAME:
-            mxFrame.reset( new XclImpChFrame );
+            mxFrame.reset( new XclImpChFrame( EXC_ID_CHLEGEND ) );
             mxFrame->ReadRecordGroup( rStrm );
         break;
         case EXC_ID_CHEND:
             // legend default formatting differs in OOChart and Excel
             if( !mxFrame )
-                mxFrame.reset( new XclImpChFrame );
-            mxFrame->CreateMissingFormats();
+                mxFrame.reset( new XclImpChFrame( EXC_ID_CHLEGEND ) );
         break;
     }
 }
@@ -2057,6 +2160,10 @@ XclImpChChartFormat::XclImpChChartFormat
     maType( rRoot )
 {
     maType.SetGroupIndex( maData.mnGroupIdx );
+
+    // Initialize unused format indexes set. At this time, all formats are unused.
+    for( sal_uInt16 nFormatIdx = 0; nFormatIdx <= EXC_CHSERIES_MAXSERIES; ++nFormatIdx )
+        maUnusedFormats.insert( maUnusedFormats.end(), nFormatIdx );
 }
 
 void XclImpChChartFormat::ReadHeaderRecord( XclImpStream& rStrm )
@@ -2095,27 +2202,30 @@ void XclImpChChartFormat::Finalize()
 {
     // check and set valid chart type
     maType.Finalize();
-    // update legend text formatting
-    if( mxLegend.is() )
-        mxLegend->Finalize();
     // update global series format
     if( mxGlobalFmt.is() )
         mxGlobalFmt->UpdateGlobalFormat();
 }
 
-void XclImpChChartFormat::CreateDiagram( XChartDocRef xChartDoc ) const
+void XclImpChChartFormat::SetUsedFormatIndex( sal_uInt16 nFormatIdx )
 {
-    // chart type (must be done before first getDiagram() call)
-    maType.CreateDiagram( xChartDoc );
+    maUnusedFormats.erase( nFormatIdx );
 }
 
-void XclImpChChartFormat::ConvertInitial( XChartDocRef xChartDoc ) const
+sal_uInt16 XclImpChChartFormat::PopUnusedFormatIndex()
 {
-    // legend on/off
-    ScfPropertySet aChartProp( xChartDoc );
-    aChartProp.SetBoolProperty( EXC_CHPROP_HASLEGEND, mxLegend.is() );
+    DBG_ASSERT( !maUnusedFormats.empty(), "XclImpChChartFormat::PopUnusedFormatIndex - no more format indexes available" );
+    sal_uInt16 nFormatIdx = maUnusedFormats.empty() ? 0 : *maUnusedFormats.begin();
+    SetUsedFormatIndex( nFormatIdx );
+    return nFormatIdx;
+}
+
+void XclImpChChartFormat::CreateDiagram( XChartDocRef xChartDoc ) const
+{
+    // chart type (must be done before first getDiagram() call)
+    maType.CreateDiagram( xChartDoc );
 
-    // 3D mode
+    // 3d mode
     if( mxChart3d.is() )
     {
         ScfPropertySet aDiaProp( xChartDoc->getDiagram() );
@@ -2128,13 +2238,6 @@ void XclImpChChartFormat::Convert( XChar
     // type dependent settings
     maType.Convert( xChartDoc );
 
-    // legend properties
-    if( (GetChartData().GetAxesSetId( maData.mnGroupIdx ) == EXC_CHAXESSET_PRIMARY) && mxLegend.is() )
-    {
-        ScfPropertySet aLegProp( xChartDoc->getLegend() );
-        mxLegend->Convert( aLegProp );
-    }
-
     // stock chart properties
     if( (GetChartData().GetChartTypeId() == EXC_ID_CHSTOCK) && HasHiLoLine() )
     {
@@ -2195,7 +2298,8 @@ void XclImpChChartFormat::ReadChDataForm
     // global series and data point format
     XclImpChDataFormatRef xDataFmt( new XclImpChDataFormat( GetChRoot() ) );
     xDataFmt->ReadRecordGroup( rStrm );
-    if( (xDataFmt->GetSeriesIdx() == 0) && (xDataFmt->GetPointIdx() == 0) &&
+    const XclChPoint& rPos = xDataFmt->GetPointPos();
+    if( (rPos.mnSeriesIdx == 0) && (rPos.mnPointIdx == 0) &&
             (xDataFmt->GetFormatIdx() == EXC_CHDATAFORMAT_DEFAULT) )
         mxGlobalFmt = xDataFmt;
 }
@@ -2566,6 +2670,11 @@ void XclImpChAxesSet::ReadSubRecord( Xcl
         case EXC_ID_CHCHARTFORMAT:
             ReadChChartFormat( rStrm );
         break;
+        case EXC_ID_CHEND:
+            // #i47745# missing plot frame -> invisible border and area
+            if( !mxPlotFrame )
+                mxPlotFrame.reset( new XclImpChFrame( EXC_ID_CHPLOTFRAME ) );
+        break;
     }
 }
 
@@ -2582,27 +2691,26 @@ void XclImpChAxesSet::Finalize()
     lclUpdateTitle( mxZAxisTitle, xDefText );
 }
 
-void XclImpChAxesSet::CreateDiagram( XChartDocRef xChartDoc ) const
+XclImpChLegendRef XclImpChAxesSet::GetLegend() const
 {
-    if( GetAxesSetId() == EXC_CHAXESSET_PRIMARY )
-        GetChartFormat().CreateDiagram( xChartDoc );
+    XclImpChLegendRef xLegend;
+    for( XclImpChChartFormatMap::const_iterator aIt = maChartFmts.begin(), aEnd = maChartFmts.end(); !xLegend && (aIt != aEnd); ++aIt )
+        xLegend = aIt->second->GetLegend();
+    return xLegend;
 }
 
-void XclImpChAxesSet::ConvertInitial( XChartDocRef xChartDoc ) const
+void XclImpChAxesSet::CreateDiagram( XChartDocRef xChartDoc ) const
 {
-    switch( GetAxesSetId() )
+    // create diagram type from first chart group in primary axes set
+    if( GetAxesSetId() == EXC_CHAXESSET_PRIMARY )
     {
-        case EXC_CHAXESSET_PRIMARY:
-        {
-            // legend on/off, 3D mode
-            GetChartFormat().ConvertInitial( xChartDoc );
-            // axis titles on/off
-            ScfPropertySet aDiaProp( xChartDoc->getDiagram() );
-            aDiaProp.SetBoolProperty( EXC_CHPROP_HASXAXISTIT, mxXAxisTitle.is() );
-            aDiaProp.SetBoolProperty( EXC_CHPROP_HASYAXISTIT, mxYAxisTitle.is() );
-            aDiaProp.SetBoolProperty( EXC_CHPROP_HASZAXISTIT, mxZAxisTitle.is() );
-        }
-        break;
+        // create the diagram object (chart type)
+        GetDefChartGroup().CreateDiagram( xChartDoc );
+        // axis titles on/off
+        ScfPropertySet aDiaProp( xChartDoc->getDiagram() );
+        aDiaProp.SetBoolProperty( EXC_CHPROP_HASXAXISTIT, mxXAxisTitle.is() );
+        aDiaProp.SetBoolProperty( EXC_CHPROP_HASYAXISTIT, mxYAxisTitle.is() );
+        aDiaProp.SetBoolProperty( EXC_CHPROP_HASZAXISTIT, mxZAxisTitle.is() );
     }
 }
 
@@ -2620,7 +2728,7 @@ void XclImpChAxesSet::Convert( XChartDoc
             // background area formatting
             ConvertBackground( xDiagram );
             // global chart format
-            GetChartFormat().Convert( xChartDoc );
+            GetDefChartGroup().Convert( xChartDoc );
         }
         break;
 
@@ -2628,7 +2736,7 @@ void XclImpChAxesSet::Convert( XChartDoc
         {
             ConvertSecYAxis( xDiagram );
             // global chart format
-            GetChartFormat().Convert( xChartDoc );
+            GetDefChartGroup().Convert( xChartDoc );
         }
         break;
     }
@@ -2664,7 +2772,7 @@ void XclImpChAxesSet::ReadChPlotFrame( X
 {
     if( (rStrm.GetNextRecId() == EXC_ID_CHFRAME) && rStrm.StartNextRecord() )
     {
-        mxPlotFrame.reset( new XclImpChFrame );
+        mxPlotFrame.reset( new XclImpChFrame( EXC_ID_CHPLOTFRAME ) );
         mxPlotFrame->ReadRecordGroup( rStrm );
     }
 }
@@ -2763,7 +2871,7 @@ void XclImpChAxesSet::ConvertBackground(
         ScfPropertySet aWallProp( x3DDisplay->getWall() );
         ScfPropertySet aFloorProp( x3DDisplay->getFloor() );
 
-        if( GetChartFormat().Is3dChart() )
+        if( GetDefChartGroup().Is3dChart() )
         {
             // wall/floor formatting (3D charts)
             if( mxXAxis.is() )
@@ -2796,7 +2904,7 @@ void lclUnlockChartDoc( Reference< XChar
     Reference< XModel > xModel( xChartDoc, UNO_QUERY );
     if( xModel.is() )
         xModel->unlockControllers();
-    rProgress.Progress();
+    rProgress.Progress( EXC_CHART_PROGRESS_SIZE );
 }
 
 } // namespace
@@ -2812,7 +2920,7 @@ XclImpChChart::XclImpChChart( const XclI
     SetChartData( this );
     // called after SetChartData(), to have a valid chart data object
     mxPrimAxesSet.reset( new XclImpChAxesSet( rRoot, EXC_CHAXESSET_PRIMARY ) );
-    mxSecAxesSet.reset( new XclImpChAxesSet( rRoot, EXC_CHAXESSET_SECONDARY ) );
+    mxSecnAxesSet.reset( new XclImpChAxesSet( rRoot, EXC_CHAXESSET_SECONDARY ) );
 }
 
 XclImpChChart::~XclImpChChart()
@@ -2855,6 +2963,20 @@ void XclImpChChart::ReadSubRecord( XclIm
     }
 }
 
+void XclImpChChart::ReadChDataFormat( XclImpStream& rStrm )
+{
+    XclImpChDataFormatRef xDataFmt( new XclImpChDataFormat( GetChRoot() ) );
+    xDataFmt->ReadRecordGroup( rStrm );
+    if( xDataFmt->GetPointPos().mnSeriesIdx <= EXC_CHSERIES_MAXSERIES )
+    {
+        XclImpChDataFormatRef& rxMapFmt = maDataFmts[ xDataFmt->GetPointPos() ];
+        /*  Do not overwrite existing data format group, Excel always uses the
+            first data format group occuring in any CHSERIES group. */
+        if( !rxMapFmt )
+            rxMapFmt = xDataFmt;
+    }
+}
+
 bool XclImpChChart::UpdateScatterXRanges()
 {
     bool bValid = mbHasValue && mbHasCateg;
@@ -2908,45 +3030,54 @@ bool XclImpChChart::HasHeaderRow() const
 
 bool XclImpChChart::IsStockChart() const
 {
-    const XclImpChChartFormat& rPrimFmt = mxPrimAxesSet->GetChartFormat();
-    const XclImpChChartFormat& rSecFmt = mxSecAxesSet->GetChartFormat();
+    const XclImpChChartFormat& rPrimGroup = mxPrimAxesSet->GetDefChartGroup();
+    const XclImpChChartFormat& rSecnGroup = mxSecnAxesSet->GetDefChartGroup();
 
     bool bHasPrim = mxPrimAxesSet->IsAlive();
-    bool bPrimHiLo = bHasPrim && (rPrimFmt.GetChartTypeId() == EXC_ID_CHLINE) && rPrimFmt.HasHiLoLine();
-    bool bPrimDrop = bHasPrim && (rPrimFmt.GetChartTypeId() == EXC_ID_CHLINE) && rPrimFmt.HasDropBars();
-    bool bPrimBar = bHasPrim && rPrimFmt.GetChartTypeId() == EXC_ID_CHBAR;
-
-    bool bHasSec = mxSecAxesSet->IsAlive();
-    bool bSecHiLo = bHasSec && (rSecFmt.GetChartTypeId() == EXC_ID_CHLINE) && rSecFmt.HasHiLoLine();
-    bool bSecDrop = bHasSec && (rSecFmt.GetChartTypeId() == EXC_ID_CHLINE) && rSecFmt.HasDropBars();
-    bool bSecBar = bHasSec && (rSecFmt.GetChartTypeId() == EXC_ID_CHBAR);
+    bool bPrimHiLo = bHasPrim && (rPrimGroup.GetChartTypeId() == EXC_ID_CHLINE) && rPrimGroup.HasHiLoLine();
+    bool bPrimDrop = bHasPrim && (rPrimGroup.GetChartTypeId() == EXC_ID_CHLINE) && rPrimGroup.HasDropBars();
+    bool bPrimBar = bHasPrim && (rPrimGroup.GetChartTypeId() == EXC_ID_CHBAR);
+
+    bool bHasSecn = mxSecnAxesSet->IsAlive();
+    bool bSecnHiLo = bHasSecn && (rSecnGroup.GetChartTypeId() == EXC_ID_CHLINE) && rSecnGroup.HasHiLoLine();
+    bool bSecnDrop = bHasSecn && (rSecnGroup.GetChartTypeId() == EXC_ID_CHLINE) && rSecnGroup.HasDropBars();
+    bool bSecnBar = bHasSecn && (rSecnGroup.GetChartTypeId() == EXC_ID_CHBAR);
 
     size_t nSeriesCnt = maValidSeries.size();
 
     return
-        (bPrimHiLo && (nSeriesCnt == (bSecBar ? (bPrimDrop ? 5 : 4) : (bPrimDrop ? 4 : 3)))) ||
-        (bSecHiLo && (nSeriesCnt == (bPrimBar ? (bSecDrop ? 5 : 4) : (bSecDrop ? 4 : 3))));
+        (bPrimHiLo && (nSeriesCnt == (bSecnBar ? (bPrimDrop ? 5 : 4) : (bPrimDrop ? 4 : 3)))) ||
+        (bSecnHiLo && (nSeriesCnt == (bPrimBar ? (bSecnDrop ? 5 : 4) : (bSecnDrop ? 4 : 3))));
 }
 
 bool XclImpChChart::HasAxesSet( sal_uInt16 nAxesSetId ) const
 {
     return
         ((nAxesSetId == EXC_CHAXESSET_PRIMARY) && mxPrimAxesSet->IsAlive()) ||
-        ((nAxesSetId == EXC_CHAXESSET_SECONDARY) && mxSecAxesSet->IsAlive());
+        ((nAxesSetId == EXC_CHAXESSET_SECONDARY) && mxSecnAxesSet->IsAlive());
+}
+
+XclImpChAxesSet& XclImpChChart::GetChartGroupAxesSet( sal_uInt16 nGroupIdx ) const
+{
+    return mxSecnAxesSet->HasChartGroup( nGroupIdx ) ? *mxSecnAxesSet : *mxPrimAxesSet;
+}
+
+sal_uInt16 XclImpChChart::GetChartGroupAxesSetId( sal_uInt16 nGroupIdx ) const
+{
+    return GetChartGroupAxesSet( nGroupIdx ).GetAxesSetId();
 }
 
-sal_uInt16 XclImpChChart::GetAxesSetId( sal_uInt16 nGroupIdx ) const
+XclImpChChartFormatRef XclImpChChart::GetChartGroup( sal_uInt16 nGroupIdx ) const
 {
-    return mxSecAxesSet->HasChartGroup( nGroupIdx ) ? EXC_CHAXESSET_SECONDARY : EXC_CHAXESSET_PRIMARY;
+    return GetChartGroupAxesSet( nGroupIdx ).GetChartGroup( nGroupIdx );
 }
 
-const XclImpChChartFormat& XclImpChChart::GetChartFormat( sal_uInt16 nGroupIdx ) const
+XclImpChChartFormat& XclImpChChart::GetDefChartGroup( sal_uInt16 nGroupIdx ) const
 {
-    return mxSecAxesSet->HasChartGroup( nGroupIdx ) ?
-        mxSecAxesSet->GetChartFormat() : mxPrimAxesSet->GetChartFormat();
+    return GetChartGroupAxesSet( nGroupIdx ).GetDefChartGroup();
 }
 
-sal_uInt16 XclImpChChart::GetSeriesCount( sal_uInt16 nGroupIdx ) const
+sal_uInt16 XclImpChChart::GetChartGroupSeriesCount( sal_uInt16 nGroupIdx ) const
 {
     /*  Count all series that are contained in the same axes set that contains
         the chart group with the passed index nGroupIdx.
@@ -2955,7 +3086,7 @@ sal_uInt16 XclImpChChart::GetSeriesCount
         groups 2 and 3. Chart group 2 is contained in secondary axes set, so
         this function will return the number of series contained in secondary
         axes set, i.e. all series with group index 2 and 3. */
-    const XclImpChAxesSet& rAxesSet = (GetAxesSetId( nGroupIdx ) == EXC_CHAXESSET_PRIMARY) ? *mxPrimAxesSet : *mxSecAxesSet;
+    const XclImpChAxesSet& rAxesSet = GetChartGroupAxesSet( nGroupIdx );
     sal_uInt16 nSeriesCnt = 0;
     for( XclImpChSeriesVec::const_iterator aIt = maValidSeries.begin(), aEnd = maValidSeries.end(); aIt != aEnd; ++aIt )
         if( rAxesSet.HasChartGroup( (*aIt)->GetGroupIdx() ) )
@@ -2963,6 +3094,15 @@ sal_uInt16 XclImpChChart::GetSeriesCount
     return nSeriesCnt;
 }
 
+XclImpChLegendRef XclImpChChart::GetLegend() const
+{
+    // #i49218# legend may be attached to primary or secondary axes set
+    XclImpChLegendRef xLegend = mxPrimAxesSet->GetLegend();
+    if( !xLegend )
+        xLegend = mxSecnAxesSet->GetLegend();
+    return xLegend;
+}
+
 XclImpChTextRef XclImpChChart::GetDefaultText( sal_uInt16 nTextId ) const
 {
     return maDefTexts.get( nTextId );
@@ -2971,8 +3111,8 @@ XclImpChTextRef XclImpChChart::GetDefaul
 bool XclImpChChart::HasAnySeriesLine() const
 {
     bool bHasLine = false;
-    for( XclImpChSeriesMap::const_iterator aIt = maSeries.begin(), aEnd = maSeries.end(); !bHasLine && (aIt != aEnd); ++aIt )
-        bHasLine = aIt->second->HasLine();
+    for( XclImpChSeriesVec::const_iterator aIt = maSeries.begin(), aEnd = maSeries.end(); !bHasLine && (aIt != aEnd); ++aIt )
+        bHasLine = (*aIt)->HasLine();
     return bHasLine;
 }
 
@@ -2981,16 +3121,15 @@ void XclImpChChart::Convert( XChartDocRe
     // lock the model to suppress any internal updates
     lclLockChartDoc( xChartDoc );
 
-    // chart type, creates the XDiagram in the chart document (must be called first)
+    /*  chart type, creates the XDiagram in the chart document (must be called
+        first), 3d mode, axes on/off, axis titles on/off */
     mxPrimAxesSet->CreateDiagram( xChartDoc );
 
-    // axes on/off, titles on/off, legend on/off, 3D mode
-    mxPrimAxesSet->ConvertInitial( xChartDoc );
-    mxSecAxesSet->ConvertInitial( xChartDoc );
-
-    // chart title on/off
+    // chart title on/off, legend on/off
+    XclImpChLegendRef xLegend = GetLegend();
     ScfPropertySet aChartProp( xChartDoc );
     aChartProp.SetBoolProperty( EXC_CHPROP_HASMAINTIT, mxTitle.is() );
+    aChartProp.SetBoolProperty( EXC_CHPROP_HASLEGEND, xLegend.is() );
 
     // source data orientation
     if( mbHasValue )
@@ -3009,7 +3148,14 @@ void XclImpChChart::Convert( XChartDocRe
 
     // axes settings
     mxPrimAxesSet->Convert( xChartDoc );
-    mxSecAxesSet->Convert( xChartDoc );
+    mxSecnAxesSet->Convert( xChartDoc );
+
+    // legend properties
+    if( xLegend.is() )
+    {
+        ScfPropertySet aLegProp( xChartDoc->getLegend() );
+        xLegend->Convert( aLegProp );
+    }
 
     // series formatting and order
     ConvertSeries( xChartDoc );
@@ -3033,12 +3179,10 @@ void XclImpChChart::Convert( XChartDocRe
 
 void XclImpChChart::ReadChSeries( XclImpStream& rStrm )
 {
-    XclImpChSeriesRef xSeries( new XclImpChSeries( GetChRoot() ) );
+    sal_uInt16 nNewSeriesIdx = static_cast< sal_uInt16 >( maSeries.size() );
+    XclImpChSeriesRef xSeries( new XclImpChSeries( GetChRoot(), nNewSeriesIdx ) );
     xSeries->ReadRecordGroup( rStrm );
-
-    sal_uInt16 nSeriesIdx = xSeries->GetSeriesIdx();
-    if( nSeriesIdx != EXC_CHSERIES_INVALID )
-        maSeries[ nSeriesIdx ] = xSeries;
+    maSeries.push_back( xSeries );
 }
 
 void XclImpChChart::ReadChDefaultText( XclImpStream& rStrm )
@@ -3059,7 +3203,7 @@ void XclImpChChart::ReadChAxesSet( XclIm
     switch( xAxesSet->GetAxesSetId() )
     {
         case EXC_CHAXESSET_PRIMARY:     mxPrimAxesSet = xAxesSet;   break;
-        case EXC_CHAXESSET_SECONDARY:   mxSecAxesSet = xAxesSet;    break;
+        case EXC_CHAXESSET_SECONDARY:   mxSecnAxesSet = xAxesSet;   break;
     }
 }
 
@@ -3074,9 +3218,9 @@ void XclImpChChart::ReadChText( XclImpSt
         break;
         case EXC_CHOBJLINK_DATA:
         {
-            XclImpChSeriesRef xSeries = maSeries.get( xText->GetSeriesIdx() );
-            if( xSeries.is() )
-                xSeries->SetDataLabel( xText );
+            sal_uInt16 nSeriesIdx = xText->GetPointPos().mnSeriesIdx;
+            if( nSeriesIdx < maSeries.size() )
+                maSeries[ nSeriesIdx ]->SetDataLabel( xText );
         }
         break;
     }
@@ -3084,23 +3228,19 @@ void XclImpChChart::ReadChText( XclImpSt
 
 void XclImpChChart::Finalize()
 {
-    // *** finalize source data and default texts ***
-
-    // finalize source data
+    // finalize source data (must be done first)
     CalcOrientation();
-
-    // *** additional processing that needs final source data and final default texts ***
-
     // chart title (may reset mxTitle, if it does not contain a string)
     lclUpdateTitle( mxTitle, GetDefaultText( EXC_CHDEFTEXT_TITLE ) );
-
-    // axes sets (updates global series formats -> must be called before UpdateSeriesFormat())
+    // axes sets, updates global series formats -> must be called before FinalizeDataFormats()
     mxPrimAxesSet->Finalize();
-    mxSecAxesSet->Finalize();
-
+    mxSecnAxesSet->Finalize();
     // formatting of all series
-    for( XclImpChSeriesVec::iterator aBeg = maValidSeries.begin(), aEnd = maValidSeries.end(), aIt = aBeg; aIt != aEnd; ++aIt )
-        (*aIt)->UpdateSeriesFormat();
+    FinalizeDataFormats();
+    // legend
+    XclImpChLegendRef xLegend = GetLegend();
+    if( xLegend.is() )
+        xLegend->Finalize();
 }
 
 void XclImpChChart::CalcOrientation()
@@ -3115,16 +3255,16 @@ void XclImpChChart::CalcOrientation()
         data. Store all valid series in aUsedSeries. It will be used to fill
         maValidSeries after additional checks (e.g. double main position). */
     XclImpChSeriesVec aUsedSeries;
-    for( XclImpChSeriesMap::iterator aMIt = maSeries.begin(), aMEnd = maSeries.end(); aMIt != aMEnd; ++aMIt )
+    for( XclImpChSeriesVec::iterator aSIt = maSeries.begin(), aSEnd = maSeries.end(); aSIt != aSEnd; ++aSIt )
     {
-        XclImpChSeriesRef xSeries = aMIt->second;
-        bool bValid = xSeries->HasValidValues() && !xSeries->HasParentSeries();
-        // compare following valid series with first valid series
-        if( bValid && !aUsedSeries.empty() )
-            bValid = aUsedSeries.front()->CheckAndUpdateOrientation( *xSeries );
-        // push valid series into the temporary vector
-        if( bValid )
-            aUsedSeries.push_back( xSeries );
+        XclImpChSeriesRef xSeries = *aSIt;
+        if( !xSeries->HasParentSeries() && xSeries->HasValidValues() )
+        {
+            /*  Compare following valid series with first valid series, push
+                all valid series into the temporary vector. */
+            if( aUsedSeries.empty() || aUsedSeries.front()->CheckAndUpdateOrientation( *xSeries ) )
+                aUsedSeries.push_back( xSeries );
+        }
     }
 
     // nothing to do, if no valid series found
@@ -3197,6 +3337,30 @@ void XclImpChChart::CalcOrientation()
     }
 }
 
+void XclImpChChart::FinalizeDataFormats()
+{
+    /*  #i51639# (part 1): CHDATAFORMAT groups are part of CHSERIES groups.
+        Each CHDATAFORMAT group specifies the series and data point it is
+        assigned to. This makes it possible to have a data format that is
+        related to another series, e.g. a CHDATAFORMAT group for series 2 is
+        part of a CHSERIES group that describes series 1. Therefore the chart
+        itself has collected all CHDATAFORMAT groups to be able to collect data
+        format groups for series that have not been imported at that time. This
+        loop finally assigns these groups to the related series. */
+    for( XclImpChDataFormatMap::const_iterator aMIt = maDataFmts.begin(), aMEnd = maDataFmts.end(); aMIt != aMEnd; ++aMIt )
+    {
+        sal_uInt16 nSeriesIdx = aMIt->first.mnSeriesIdx;
+        if( nSeriesIdx < maSeries.size() )
+            maSeries[ nSeriesIdx ]->SetDataFormat( aMIt->second );
+    }
+
+    /*  #i51639# (part 2): Finalize data formats of all series. This adds for
+        example missing CHDATAFORMAT groups for entire series that are needed
+        for automatic colors of lines and areas. */
+    for( XclImpChSeriesVec::iterator aVIt = maSeries.begin(), aVEnd = maSeries.end(); aVIt != aVEnd; ++aVIt )
+        (*aVIt)->FinalizeDataFormats();
+}
+
 void XclImpChChart::ConvertSeries( XChartDocRef xChartDoc ) const
 {
     if( !maValidSeries.empty() )
@@ -3314,6 +3478,7 @@ XclImpChart::XclImpChart( const XclImpRo
 void XclImpChart::ReadChartSubStream( XclImpStream& rStrm )
 {
     XclImpPageSettings& rPageSett = GetPageSettings();
+    XclImpTabViewSettings& rTabViewSett = GetTabViewSettings();
 
     bool bLoop = true;
     while( bLoop && rStrm.StartNextRecord() )
@@ -3339,6 +3504,9 @@ void XclImpChart::ReadChartSubStream( Xc
             case EXC_ID_VCENTER:        rPageSett.ReadCenter( rStrm );          break;
             case EXC_ID_SETUP:          rPageSett.ReadSetup( rStrm );           break;
             case EXC_ID_BITMAP:         rPageSett.ReadBitmap( rStrm );          break;
+
+            case EXC_ID_WINDOW2:        rTabViewSett.ReadWindow2( rStrm );      break;
+            case EXC_ID_SCL:            rTabViewSett.ReadScl( rStrm );          break;
         }
 
         switch( rStrm.GetRecId() )
Index: sc/source/filter/excel/xicontent.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xicontent.cxx,v
retrieving revision 1.17
retrieving revision 1.17.4.1
diff -u -p -u -p -r1.17 -r1.17.4.1
--- sc/source/filter/excel/xicontent.cxx	29 Mar 2005 11:48:27 -0000	1.17
+++ sc/source/filter/excel/xicontent.cxx	9 Aug 2005 16:29:37 -0000	1.17.4.1
@@ -705,7 +705,7 @@ void XclImpValidation::ReadDval( XclImpS
     if( nObjId != EXC_DVAL_NOOBJ )
     {
         DBG_ASSERT( nObjId <= 0xFFFF, "XclImpValidation::ReadDval - invalid object ID" );
-        rRoot.GetObjectManager().SetSkipObj( rRoot.GetCurrScTab(), static_cast< sal_uInt16 >( nObjId ) );
+        rRoot.GetObjectManager().SetInvalidObj( rRoot.GetCurrScTab(), static_cast< sal_uInt16 >( nObjId ) );
     }
 }
 
Index: sc/source/filter/excel/xiescher.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xiescher.cxx,v
retrieving revision 1.36
retrieving revision 1.35.4.7
diff -u -p -u -p -r1.36 -r1.35.4.7
--- sc/source/filter/excel/xiescher.cxx	12 Jul 2005 12:22:35 -0000	1.36
+++ sc/source/filter/excel/xiescher.cxx	11 Aug 2005 08:31:10 -0000	1.35.4.7
@@ -107,6 +107,16 @@
 #include <toolkit/helper/vclunohelper.hxx>
 #endif
 
+#ifndef _SB_SBSTAR_HXX
+#include <basic/sbstar.hxx>
+#endif
+#ifndef _SB_SBMOD_HXX
+#include <basic/sbmod.hxx>
+#endif
+#ifndef _SB_SBMETH_HXX
+#include <basic/sbmeth.hxx>
+#endif
+
 #ifndef _SVDOBJ_HXX
 #include <svx/svdobj.hxx>
 #endif
@@ -216,354 +226,382 @@ using ::com::sun::star::embed::XEmbedPer
 using ::com::sun::star::chart::XChartDocument;
 using ::com::sun::star::script::ScriptEventDescriptor;
 
-// Escher stream consumer =====================================================
+typedef ::std::auto_ptr< SdrObject > SdrObjectPtr;
 
-XclImpStreamConsumer::XclImpStreamConsumer() :
-    mpNode( 0 ),
-    mnBytesLeft( 0 )
+// Text box data ==============================================================
+
+namespace {
+
+SvxAdjust lclGetSvxHorAlignment( sal_uInt8 nXclAlign )
 {
+    SvxAdjust eHorAlign = SVX_ADJUST_LEFT;
+    switch( nXclAlign )
+    {
+        case EXC_TXO_HOR_LEFT:      eHorAlign = SVX_ADJUST_LEFT;    break;
+        case EXC_TXO_HOR_CENTER:    eHorAlign = SVX_ADJUST_CENTER;  break;
+        case EXC_TXO_HOR_RIGHT:     eHorAlign = SVX_ADJUST_RIGHT;   break;
+        case EXC_TXO_HOR_JUSTIFY:   eHorAlign = SVX_ADJUST_BLOCK;   break;
+    }
+    return eHorAlign;
 }
 
-XclImpStreamConsumer::~XclImpStreamConsumer()
+SdrTextVertAdjust lclGetSvxVerAlignment( sal_uInt8 nXclAlign )
 {
-    while( mpNode )
-        RemoveNode();
+    SdrTextVertAdjust eVerAlign = SDRTEXTVERTADJUST_TOP;
+    switch( nXclAlign )
+    {
+        case EXC_TXO_VER_TOP:       eVerAlign = SDRTEXTVERTADJUST_TOP;      break;
+        case EXC_TXO_VER_CENTER:    eVerAlign = SDRTEXTVERTADJUST_CENTER;   break;
+        case EXC_TXO_VER_BOTTOM:    eVerAlign = SDRTEXTVERTADJUST_BOTTOM;   break;
+        case EXC_TXO_VER_JUSTIFY:   eVerAlign = SDRTEXTVERTADJUST_BLOCK;    break;
+    }
+    return eVerAlign;
 }
 
-void XclImpStreamConsumer::UpdateNode( const DffRecordHeader& rHd )
+::com::sun::star::text::WritingMode lclGetApiWritingMode( sal_uInt16 nXclOrient )
 {
-    while( mpNode && ((mpNode->mnPos + mpNode->mnSize) <= rHd.nFilePos) )
-        RemoveNode();
-    XclImpStreamNode* pTemp = mpNode;
-    mpNode = new XclImpStreamNode;
-    mpNode->mnPos = rHd.nFilePos;
-    mpNode->mnSize = rHd.nRecLen + 8;
-    mpNode->mpPrev = pTemp;
+    // this is only a fake, drawing does not support real text orientation
+    namespace csst = ::com::sun::star::text;
+    csst::WritingMode eWriteMode = csst::WritingMode_LR_TB;
+    switch( nXclOrient )
+    {
+        case EXC_TXO_TEXTROT_NONE:      eWriteMode = csst::WritingMode_LR_TB;   break;
+        case EXC_TXO_TEXTROT_STACKED:   eWriteMode = csst::WritingMode_TB_RL;   break;
+        case EXC_TXO_TEXTROT_90_CCW:    eWriteMode = csst::WritingMode_TB_RL;   break;
+        case EXC_TXO_TEXTROT_90_CW:     eWriteMode = csst::WritingMode_TB_RL;   break;
+    }
+    return eWriteMode;
 }
 
-void XclImpStreamConsumer::RemoveNode()
+} // namespace
+
+// ----------------------------------------------------------------------------
+
+XclImpTxoData::XclImpTxoData( const XclImpRoot& rRoot ) :
+    XclImpRoot( rRoot )
 {
-    XclImpStreamNode* pTemp = mpNode;
-    mpNode = mpNode->mpPrev;
-    delete pTemp;
 }
 
-const DffRecordHeader* XclImpStreamConsumer::ConsumeRecord( XclImpStream& rSrcStrm )
+void XclImpTxoData::ReadTxo( XclImpStream& rStrm )
 {
-    ULONG nEntry = maStrm.Tell();
-    ULONG nSrcSize = rSrcStrm.GetRecSize();
-    if( !nSrcSize )
-        return 0;
+    rStrm.ResetRecord( false );     // disable internal CONTINUE handling
+    mxString.reset();
 
-    rSrcStrm.Seek( EXC_REC_SEEK_TO_BEGIN );
-    sal_Char* pBuf = new sal_Char[ nSrcSize ];
-    rSrcStrm.Read( pBuf, nSrcSize );
-    maStrm.Write( pBuf, nSrcSize );
-    delete[] pBuf;
-
-    ULONG nPos = maStrm.Tell();
-    maStrm.Seek( nEntry );
-    if( mnBytesLeft )
+    // Step 1: TXO record
+    rStrm >> maData;
+
+    // Step 2: First CONTINUE with string
+    bool bValid = true;
+    if( maData.mnTextLen > 0 )
     {
-        if( nSrcSize < mnBytesLeft )
-        {
-            maStrm.SeekRel( nSrcSize );
-            mnBytesLeft -= nSrcSize;
-        }
-        else
+        bValid = rStrm.GetNextRecId() == EXC_ID_CONT;
+        DBG_ASSERT( bValid, "XclImpTxoData::ReadTxo - missing CONTINUE record" );
+        if( bValid )
         {
-            maStrm.SeekRel( mnBytesLeft );
-            mnBytesLeft = 0;
+            rStrm.StartNextRecord();
+            rStrm.ResetRecord( false );
+            mxString.reset( new XclImpString( rStrm.ReadUniString( maData.mnTextLen ) ) );
         }
     }
-    while( maStrm.Tell() < nPos )
+
+    // Step 3: Second CONTINUE with formatting runs
+    if( maData.mnFormatSize > 0 )
     {
-        maStrm >> maHd;
-        if( maHd.nRecType == DFF_msofbtSolverContainer )
-        {
-            maStrm.Seek( nEntry );
-            return &maHd;
-        }
-        else if( maHd.IsContainer() )
-            UpdateNode( maHd );
-        else if( (maStrm.Tell() + maHd.nRecLen) <= nPos )
-            maStrm.SeekRel( maHd.nRecLen );
-        else
+        bValid = rStrm.GetNextRecId() == EXC_ID_CONT;
+        DBG_ASSERT( bValid, "XclImpTxoData::ReadTxo - missing CONTINUE record" );
+        if( bValid )
         {
-            mnBytesLeft = maStrm.Tell() + maHd.nRecLen - nPos;
-            maStrm.Seek( nPos );
+            rStrm.StartNextRecord();
+            rStrm.ResetRecord( false );
+            if( mxString.is() )
+            {
+                // number of formatting runs, each takes 8 bytes, but ignore last run
+                sal_uInt16 nFormatRuns = maData.mnFormatSize / 8 - 1;
+                for( sal_uInt16 nRun = 0; nRun < nFormatRuns; ++nRun )
+                {
+                    sal_uInt16 nChar, nFont;
+                    rStrm >> nChar >> nFont;
+                    rStrm.Ignore( 4 );
+                    mxString->AppendFormat( nChar, nFont );
+                }
+            }
         }
     }
-    maStrm.Seek( nPos );
-
-    return mnBytesLeft ? 0 : &maHd;
 }
 
-bool XclImpStreamConsumer::AppendData( sal_Char* pBuf, ULONG nLen )
+void XclImpTxoData::ProcessSdrObject( SdrObject& rSdrObj ) const
 {
-    if ( (maHd.nRecType != 0) && !maHd.IsContainer() && (mnBytesLeft == 0) )
+    if( SdrTextObj* pTextObj = dynamic_cast< SdrTextObj* >( &rSdrObj ) )
     {
-        while( mpNode && ((mpNode->mnPos + mpNode->mnSize) <= maHd.nFilePos) )
-            RemoveNode();
-        XclImpStreamNode* pTemp = mpNode;
-        while( pTemp )
+        if( mxString.is() )
         {
-            pTemp->mnSize += nLen;               // updating container sizes
-            maStrm.Seek( pTemp->mnPos + 4 );
-            maStrm << pTemp->mnSize - 8;
-            pTemp = pTemp->mpPrev;
+            if( mxString->IsRich() )
+            {
+                // rich text
+                ::std::auto_ptr< EditTextObject > xEditObj(
+                    XclImpStringHelper::CreateTextObject( GetRoot(), *mxString ) );
+                OutlinerParaObject* pOutlineObj = new OutlinerParaObject( *xEditObj );
+                pOutlineObj->SetOutlinerMode( OUTLINERMODE_TEXTOBJECT );
+                // text object takes ownership of the outliner object
+                pTextObj->NbcSetOutlinerParaObject( pOutlineObj );
+            }
+            else
+            {
+                // plain text
+                pTextObj->SetText( mxString->GetText() );
+            }
         }
-        maHd.nRecLen += nLen;
-        maStrm.Seek( maHd.nFilePos + 4 );        // updating atom size
-        maStrm << maHd.nRecLen;
-        maStrm.Seek( STREAM_SEEK_TO_END );
-        maStrm.Write( pBuf, nLen );
-        return true;
+
+        // #i12188# text alignment not stored in Escher stream, but in TXO record
+        SvxAdjust eHorAlign = lclGetSvxHorAlignment( maData.GetXclHorAlignment() );
+        pTextObj->SetMergedItem( SvxAdjustItem( eHorAlign, EE_PARA_JUST ) );
+        SdrTextVertAdjust eVerAlign = lclGetSvxVerAlignment( maData.GetXclVerAlignment() );
+        pTextObj->SetMergedItem( SdrTextVertAdjustItem( eVerAlign ) );
+        ::com::sun::star::text::WritingMode eWriteMode = lclGetApiWritingMode( GetOrientation() );
+        pTextObj->SetMergedItem( SvxWritingModeItem( eWriteMode ) );
     }
-    return false;
 }
 
 // Escher objects =============================================================
 
-TYPEINIT0( XclImpEscherObj );
-
-XclImpEscherObj::XclImpEscherObj( const XclImpRoot& rRoot ) :
+XclImpDrawObjBase::XclImpDrawObjBase( const XclImpRoot& rRoot ) :
     XclImpRoot( rRoot ),
-    mnStrmBegin( 0 ),
-    mnStrmEnd( 0 ),
-    mnScTab( rRoot.GetCurrScTab() ),
-    mnObjId( EXC_OBJ_INVALID_ID ),
+    maObjId( rRoot.GetCurrScTab(), EXC_OBJ_INVALID_ID ),
+    mnObjType( EXC_OBJ_CMO_UNKNOWN ),
+    mnObjFlags( 0 ),
+    mnShapeId( 0 ),
+    mnShapeFlags( 0 ),
+    mnShapeBlipId( 0 ),
     mbAreaObj( false ),
-    mbSkip( false ),
-    mbPrintable( true )
+    mbValid( true ),
+    mbInsSdr( true ),
+    mbProcSdr( true )
 {
 }
 
-XclImpEscherObj::XclImpEscherObj( const XclImpRoot& rRoot, ULONG nStrmBegin, ULONG nStrmEnd ) :
-    XclImpRoot( rRoot ),
-    mnStrmBegin( nStrmBegin ),
-    mnStrmEnd( nStrmEnd ),
-    mnScTab( rRoot.GetCurrScTab() ),
-    mnObjId( EXC_OBJ_INVALID_ID ),
-    mbAreaObj( false ),
-    mbSkip( false ),
-    mbPrintable( true )
+XclImpDrawObjBase::~XclImpDrawObjBase()
 {
 }
 
-XclImpEscherObj::XclImpEscherObj( XclImpEscherObj& rSrcObj ) :
-    XclImpRoot( rSrcObj.GetRoot() ),
-    maAnchorRect( rSrcObj.maAnchorRect ),
-    mxSdrObj( rSrcObj.mxSdrObj ),          // rSrc.mxSdrObj releases the object
-    mnStrmBegin( rSrcObj.mnStrmBegin ),
-    mnStrmEnd( rSrcObj.mnStrmEnd ),
-    mnScTab( rSrcObj.mnScTab ),
-    mnObjId( rSrcObj.mnObjId ),
-    mbAreaObj( rSrcObj.mbAreaObj ),
-    mbSkip( rSrcObj.mbSkip ),
-    mbPrintable( rSrcObj.mbPrintable )
+XclImpDrawObjRef XclImpDrawObjBase::ReadObjCmo( XclImpStream& rStrm )
 {
-}
+    XclImpDrawObjRef xDrawObj;
 
-XclImpEscherObj::~XclImpEscherObj()
-{
+    sal_uInt16 nObjType, nObjId, nFlags;
+    rStrm >> nObjType >> nObjId >> nFlags;
+
+    switch( nObjType )
+    {
+        case EXC_OBJ_CMO_GROUP:
+        case EXC_OBJ_CMO_LINE:
+        case EXC_OBJ_CMO_ARC:
+            xDrawObj.reset( new XclImpDrawingObj( rStrm.GetRoot(), false ) );
+        break;
+        case EXC_OBJ_CMO_RECTANGLE:
+        case EXC_OBJ_CMO_ELLIPSE:
+        case EXC_OBJ_CMO_POLYGON:
+        case EXC_OBJ_CMO_DRAWING:
+        case EXC_OBJ_CMO_TEXT:
+            xDrawObj.reset( new XclImpDrawingObj( rStrm.GetRoot(), true ) );
+        break;
+        case EXC_OBJ_CMO_NOTE:
+            xDrawObj.reset( new XclImpNoteObj( rStrm.GetRoot() ) );
+        break;
+        case EXC_OBJ_CMO_BUTTON:
+        case EXC_OBJ_CMO_CHECKBOX:
+        case EXC_OBJ_CMO_OPTIONBUTTON:
+        case EXC_OBJ_CMO_LABEL:
+        case EXC_OBJ_CMO_GROUPBOX:
+        case EXC_OBJ_CMO_LISTBOX:
+        case EXC_OBJ_CMO_COMBOBOX:
+        case EXC_OBJ_CMO_SPIN:
+        case EXC_OBJ_CMO_SCROLLBAR:
+            xDrawObj.reset( new XclImpTbxControlObj( rStrm.GetRoot() ) );
+        break;
+        case EXC_OBJ_CMO_PICTURE:
+            xDrawObj.reset( new XclImpOleObj( rStrm.GetRoot() ) );
+        break;
+        case EXC_OBJ_CMO_CHART:
+            xDrawObj.reset( new XclImpChartObj( rStrm.GetRoot(), false ) );
+        break;
+        case EXC_OBJ_CMO_EDIT:          // only in dialogs
+        case EXC_OBJ_CMO_DIALOG:        // not supported
+        break;
+        default:
+            DBG_ERROR1( "XclImpDrawObjBase::ReadObjCmo - unknown object type 0x%04hX", nObjType );
+            xDrawObj.reset( new XclImpDrawingObj( rStrm.GetRoot(), true ) );
+    }
+
+    if( xDrawObj.is() )
+        xDrawObj->SetObjData( nObjType, nObjId, nFlags );
+    return xDrawObj;
 }
 
-bool XclImpEscherObj::IsValidSize( const Rectangle& rRect ) const
+void XclImpDrawObjBase::ReadSubRecord( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize )
 {
-    // XclEscherAnchor rounds up the width, width of 3 is the result of an Excel width of 0
-    return mbAreaObj ?
-        ((rRect.GetWidth() > 3) && (rRect.GetHeight() > 1)) :
-        ((rRect.GetWidth() > 3) || (rRect.GetHeight() > 1));
 }
 
-bool XclImpEscherObj::IsValidSize() const
+Rectangle XclImpDrawObjBase::ReadClientAnchor( SvStream& rEscherStrm, const DffRecordHeader& rHeader )
 {
-    return IsValidSize( maAnchorRect );
+    DBG_ASSERT( rHeader.nRecType == DFF_msofbtClientAnchor, "XclImpDrawObjBase::ReadClientAnchor - no client anchor record" );
+    mxAnchor.reset( new XclEscherAnchor( GetScTab() ) );
+    rHeader.SeekToContent( rEscherStrm );
+    rEscherStrm.SeekRel( 2 );
+    rEscherStrm >> *mxAnchor;
+    return mxAnchor->GetRect( GetDoc(), MAP_100TH_MM );
 }
 
-bool XclImpEscherObj::IsValid() const
+void XclImpDrawObjBase::SetObjData( sal_uInt16 nObjType, sal_uInt16 nObjId, sal_uInt16 nObjFlags )
 {
-    return !mbSkip && mxSdrObj.get() && IsValidSize();
+    maObjId.mnObjId = nObjId;
+    mnObjType = nObjType;
+    mnObjFlags = nObjFlags;
 }
 
-void XclImpEscherObj::SetSdrObj( SdrObject* pSdrObj )
+void XclImpDrawObjBase::SetShapeData( sal_uInt32 nShapeId, sal_uInt32 nShapeFlags, sal_uInt32 nShapeBlipId )
 {
-    mxSdrObj.reset( pSdrObj );
+    mnShapeId = nShapeId;
+    mnShapeFlags = nShapeFlags;
+    mnShapeBlipId = nShapeBlipId;
 }
 
-sal_uInt32 XclImpEscherObj::GetProgressSize() const
+bool XclImpDrawObjBase::IsValidSize( const Rectangle& rAnchorRect ) const
 {
-    return 1;
+    // XclEscherAnchor rounds up the width, width of 3 is the result of an Excel width of 0
+    return mbAreaObj ?
+        ((rAnchorRect.GetWidth() > 3) && (rAnchorRect.GetHeight() > 1)) :
+        ((rAnchorRect.GetWidth() > 3) || (rAnchorRect.GetHeight() > 1));
 }
 
-bool XclImpEscherObj::Apply( ScfProgressBar& rProgress )
+ScRange XclImpDrawObjBase::GetUsedArea() const
 {
-    bool bInserted = false;
-    if( IsValid() )
+    ScRange aScUsedArea( ScAddress::INITIALIZE_INVALID );
+    if( mxAnchor.is() )
     {
-        if( SdrPage* pPage = GetSdrPage( mnScTab ) )
-        {
-            pPage->InsertObject( mxSdrObj.release() );
-            bInserted = true;
-        }
-        // Trace if object is not printable.
-        if( !GetPrintable() && !ISA( XclImpEscherTbxCtrl ) )
+        // #i44077# object inserted -> update used area for OLE object import
+        if( GetAddressConverter().ConvertRange( aScUsedArea, mxAnchor->maXclRange, GetScTab(), GetScTab(), false ) )
         {
-            bool bOcxCtrl = false;
-            if( XclImpEscherOle* pOleObj = PTR_CAST( XclImpEscherOle, this ) )
-                bOcxCtrl = pOleObj->IsControl();
-            if( !bOcxCtrl )
-                GetTracer().TraceObjectNotPrintable();
+            // reduce range, if object ends directly on borders between two columns or rows
+            if( (mxAnchor->mnRX == 0) && (aScUsedArea.aStart.Col() < aScUsedArea.aEnd.Col()) )
+                aScUsedArea.aEnd.IncCol( -1 );
+            if( (mxAnchor->mnBY == 0) && (aScUsedArea.aStart.Row() < aScUsedArea.aEnd.Row()) )
+                aScUsedArea.aEnd.IncRow( -1 );
         }
     }
-    rProgress.Progress();
-    return bInserted;
+    return aScUsedArea;
 }
 
-// ----------------------------------------------------------------------------
-
-TYPEINIT1( XclImpEscherDrawing, XclImpEscherObj );
-
-XclImpEscherDrawing::XclImpEscherDrawing( XclImpEscherObj& rSrcObj, bool bAreaObj ) :
-    XclImpEscherObj( rSrcObj )
+sal_uInt32 XclImpDrawObjBase::GetProgressSize() const
 {
-    SetAreaObj( bAreaObj );
+    return DoGetProgressSize();
 }
 
-bool XclImpEscherDrawing::Apply( ScfProgressBar& rProgress )
+void XclImpDrawObjBase::ProcessSdrObject( SdrObject& rSdrObj ) const
 {
-    // #119010# - allow for the possibility that valid connectors
-    // may have no height or width set.
-    if( !GetIsSkip() && GetSdrObj() && GetSdrObj()->ISA(SdrEdgeObj) && !IsValidSize() )
-        SetAreaObj( false );
-    return XclImpEscherObj::Apply( rProgress );
+    // call virtual function for object type specific processing
+    if( IsProcessSdr() )
+        DoProcessSdrObj( rSdrObj );
 }
 
-// ----------------------------------------------------------------------------
-
-TYPEINIT1( XclImpEscherTxo, XclImpEscherDrawing );
-
-XclImpEscherTxo::XclImpEscherTxo( XclImpEscherObj& rSrcObj ) :
-    XclImpEscherDrawing( rSrcObj, true ),
-    meHorAlign( xlTxoHAlign_Default ),
-    meVerAlign( xlTxoVAlign_Default ),
-    meRotation( xlTxoRot_Default )
+void XclImpDrawObjBase::CreateEscherAnchor( const Rectangle& rAnchorRect )
 {
+    mxAnchor.reset( new XclEscherAnchor( GetScTab() ) );
+    mxAnchor->SetRect( GetDoc(), rAnchorRect, MAP_100TH_MM );
 }
 
-void XclImpEscherTxo::SetAlignment( sal_uInt16 nAlign )
+sal_uInt32 XclImpDrawObjBase::DoGetProgressSize() const
 {
-    ::extract_value( meHorAlign, nAlign, 1, 3 );
-    ::extract_value( meVerAlign, nAlign, 4, 3 );
+    return 1;
 }
 
-void XclImpEscherTxo::SetRotation( sal_uInt16 nOrient )
+void XclImpDrawObjBase::DoProcessSdrObj( SdrObject& rSdrObj ) const
 {
-    meRotation = static_cast<XclTxoRotation>(nOrient);
+    // trace if object is not printable
+    if( !IsPrintable() )
+        GetTracer().TraceObjectNotPrintable();
 }
 
-void XclImpEscherTxo::ApplyTextOnSdrObj( SdrObject& rSdrObj ) const
-{
-    if( SdrTextObj* pTextObj = PTR_CAST( SdrTextObj, &rSdrObj ) )
-    {
-        if( mxString.get() )
-        {
-            if( mxString->IsRich() )
-            {
-                // rich text
-                ::std::auto_ptr< EditTextObject > pEditObj(
-                XclImpStringHelper::CreateTextObject( GetRoot(), *mxString ) );
-                OutlinerParaObject* pOPO = new OutlinerParaObject( *pEditObj );
-                pOPO->SetOutlinerMode( OUTLINERMODE_TEXTOBJECT );
-                pTextObj->NbcSetOutlinerParaObject( pOPO );
-            }
-            else
-            {
-                // plain text
-                pTextObj->SetText( mxString->GetText() );
-            }
-        }
+// ----------------------------------------------------------------------------
 
-        // horizontal text alignment (#i12188# not stored in Escher stream, but in TXO)
-        SvxAdjust eEEHorAlign = SVX_ADJUST_LEFT;
-        switch( meHorAlign )
-        {
-            case xlTxoHAlignLeft:      eEEHorAlign = SVX_ADJUST_LEFT;     break;
-            case xlTxoHAlignCenter:    eEEHorAlign = SVX_ADJUST_CENTER;   break;
-            case xlTxoHAlignRight:     eEEHorAlign = SVX_ADJUST_RIGHT;    break;
-            case xlTxoHAlignJustify:   eEEHorAlign = SVX_ADJUST_BLOCK;    break;
-        }
-        pTextObj->SetMergedItem( SvxAdjustItem( eEEHorAlign, EE_PARA_JUST ) );
-
-        // vertical text alignment (#i12188# not stored in Escher stream, but in TXO)
-        SdrTextVertAdjust eSdrVerAlign = SDRTEXTVERTADJUST_TOP;
-        switch( meVerAlign )
-        {
-            case xlTxoVAlignTop:        eSdrVerAlign = SDRTEXTVERTADJUST_TOP;       break;
-            case xlTxoHAlignCenter:     eSdrVerAlign = SDRTEXTVERTADJUST_CENTER;    break;
-            case xlTxoVAlignBottom:     eSdrVerAlign = SDRTEXTVERTADJUST_BOTTOM;    break;
-            case xlTxoVAlignJustify:    eSdrVerAlign = SDRTEXTVERTADJUST_BLOCK;     break;
-        }
-        pTextObj->SetMergedItem( SdrTextVertAdjustItem( eSdrVerAlign ) );
+XclImpDrawingObj::XclImpDrawingObj( const XclImpRoot& rRoot, bool bAreaObj ) :
+    XclImpDrawObjBase( rRoot )
+{
+    SetAreaObj( bAreaObj );
+}
 
-    }
+void XclImpDrawingObj::DoProcessSdrObj( SdrObject& rSdrObj ) const
+{
+    // set text data
+    if( mxTxoData.is() )
+        mxTxoData->ProcessSdrObject( rSdrObj );
+    // base class processing
+    XclImpDrawObjBase::DoProcessSdrObj( rSdrObj );
 }
 
 // ----------------------------------------------------------------------------
 
-TYPEINIT1( XclImpEscherNote, XclImpEscherTxo );
+XclImpNoteObj::XclImpNoteObj( const XclImpRoot& rRoot ) :
+    XclImpDrawingObj( rRoot, true ),
+    maScPos( ScAddress::INITIALIZE_INVALID ),
+    mnNoteFlags( 0 )
+{
+    // note object will be processed, but not inserted into the draw page
+    SetSkipInsertSdr();
+}
 
-XclImpEscherNote::XclImpEscherNote( XclImpEscherObj& rSrcObj ) :
-    XclImpEscherTxo( rSrcObj ),
-    maScPos( ScAddress::UNINITIALIZED )
+void XclImpNoteObj::SetNoteData( const ScAddress& rScPos, sal_uInt16 nNoteFlags )
 {
+    maScPos = rScPos;
+    mnNoteFlags = nNoteFlags;
 }
 
-bool XclImpEscherNote::Apply( ScfProgressBar& rProgress )
+void XclImpNoteObj::DoProcessSdrObj( SdrObject& rSdrObj ) const
 {
-    if( IsValid() && maScPos.IsValid() )
+    if( maScPos.IsValid() )
     {
-        ScPostIt aNote( GetDocPtr() );
-        if( GetDoc().GetNote( maScPos.Col(), maScPos.Row(), mnScTab, aNote ) )
+        if( const XclImpString* pString = GetString() )
         {
-            aNote.SetRectangle( maAnchorRect );
-            SdrObject* pObj = mxSdrObj.get();
+            SCCOL nScCol = maScPos.Col();
+            SCROW nScRow = maScPos.Row();
+            SCTAB nScTab = GetScTab();
+            bool bVisible = ::get_flag( mnNoteFlags, EXC_NOTE_VISIBLE );
+
+            // create the note object
+            ::std::auto_ptr< EditTextObject > pEditObj(
+                XclImpStringHelper::CreateNoteObject( GetRoot(), *pString ) );
+            // ScPostIt does not take ownership of the passed note
+            ScPostIt aNote( pEditObj.get(), GetDocPtr() );
+            aNote.SetRectangle( rSdrObj.GetSnapRect() );
+            aNote.SetShown( bVisible );
 
-            // get the actual container from this group object.
-            if( pObj->IsGroupObject() )
+            // get the actual container from this group object
+            SdrObject* pBoxSdrObj = &rSdrObj;
+            if( rSdrObj.IsGroupObject() && rSdrObj.GetSubList() )
             {
-                SdrObjListIter aIter( *pObj->GetSubList() );
-                pObj = aIter.Next();
+                SdrObjListIter aIt( *rSdrObj.GetSubList() );
+                pBoxSdrObj = aIt.Next();
             }
-            if( pObj )
+
+            // set textbox properties
+            if( pBoxSdrObj )
             {
-                namespace csst = ::com::sun::star::text;
-                csst::WritingMode eWriteMode = csst::WritingMode_LR_TB;
-                switch( GetRotation() )
-                {
-                    case xlTxoNoRot:        eWriteMode = csst::WritingMode_LR_TB;   break;
-                    case xlTxoRotStacked:   eWriteMode = csst::WritingMode_TB_RL;   break;
-                    case xlTxoRot90ccw:     eWriteMode = csst::WritingMode_TB_RL;   break;
-                    case xlTxoRot90cw:      eWriteMode = csst::WritingMode_TB_RL;   break;
-                }
-                pObj->SetMergedItem( SvxWritingModeItem( eWriteMode ) );
-                pObj->SetMergedItem( SdrTextAutoGrowWidthItem( false ) );
-                pObj->SetMergedItem( SdrTextAutoGrowHeightItem( false ) );
-                aNote.SetAndApplyItemSet( pObj->GetMergedItemSet() );
+                XclImpDrawingObj::DoProcessSdrObj( *pBoxSdrObj );
+                pBoxSdrObj->SetMergedItem( SdrTextAutoGrowWidthItem( false ) );
+                pBoxSdrObj->SetMergedItem( SdrTextAutoGrowHeightItem( false ) );
+                aNote.SetAndApplyItemSet( pBoxSdrObj->GetMergedItemSet() );
             }
-            GetDoc().SetNote( maScPos.Col(), maScPos.Row(), mnScTab, aNote );
 
-            if( aNote.IsShown() )
+            // insert the note into the document
+            GetDoc().SetNote( nScCol, nScRow, nScTab, aNote );
+
+            // make the note visible via ScDetectiveFunc
+            if( bVisible )
             {
-                ScDetectiveFunc aDetFunc( GetDocPtr(), mnScTab );
-                aDetFunc.ShowComment( maScPos.Col(), maScPos.Row(), TRUE );
+                ScDetectiveFunc aDetFunc( GetDocPtr(), nScTab );
+                aDetFunc.ShowComment( nScCol, nScRow, TRUE );
             }
         }
     }
-    rProgress.Progress();
-    // notes are not inserted into the drawing layer -> return false
-    return false;
 }
 
 // ----------------------------------------------------------------------------
@@ -582,9 +620,9 @@ void XclImpCtrlLinkHelper::ReadCellLinkF
     if( rStrm.GetRoot().GetFmlaConverter().GetAbsRefs( aRangeList, nFmlaSize ) )
     {
         // Use first cell of first range
-        ::std::auto_ptr< ScRange > pRange( aRangeList.Remove( 0UL ) );
-        if( pRange.get() )
-            mxCellLink.reset( new ScAddress( pRange->aStart ) );
+        ::std::auto_ptr< ScRange > xRange( aRangeList.Remove( 0UL ) );
+        if( xRange.get() )
+            mxCellLink.reset( new ScAddress( xRange->aStart ) );
     }
 }
 
@@ -601,12 +639,9 @@ void XclImpCtrlLinkHelper::ReadSrcRangeF
 
 // ----------------------------------------------------------------------------
 
-TYPEINIT1( XclImpEscherTbxCtrl, XclImpEscherTxo );
-
-XclImpEscherTbxCtrl::XclImpEscherTbxCtrl( XclImpEscherObj& rSrcObj, sal_uInt16 nCtrlType ) :
-    XclImpEscherTxo( rSrcObj ),
+XclImpTbxControlObj::XclImpTbxControlObj( const XclImpRoot& rRoot ) :
+    XclImpDrawingObj( rRoot, true ),
     XclImpCtrlLinkHelper( xlBindPosition ),
-    mnCtrlType( nCtrlType ),
     mnState( EXC_OBJ_CBLS_STATE_UNCHECK ),
     mnSelEntry( 0 ),
     mnSelType( EXC_OBJ_LBS_SEL_SIMPLE ),
@@ -620,114 +655,47 @@ XclImpEscherTbxCtrl::XclImpEscherTbxCtrl
     mbFlatBorder( false ),
     mbScrollHor( false )
 {
+    /*  Do not process the SdrObject (skips setting textbox data and tracing
+        that the object is not printable). */
+    SetSkipProcessSdr();
 }
 
-void XclImpEscherTbxCtrl::ReadCbls( XclImpStream& rStrm )
-{
-    sal_uInt16 nStyle;
-    rStrm >> mnState;
-    rStrm.Ignore( 8 );
-    rStrm >> nStyle;
-    mnState &= EXC_OBJ_CBLS_STATEMASK;
-    mbFlatButton = ::get_flag( nStyle, EXC_OBJ_CBLS_FLAT );
-}
-
-void XclImpEscherTbxCtrl::ReadCblsFmla( XclImpStream& rStrm )
-{
-    ReadCellLinkFormula( rStrm );
-}
-
-void XclImpEscherTbxCtrl::ReadLbsData( XclImpStream& rStrm )
+void XclImpTbxControlObj::ReadSubRecord( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize )
 {
-    sal_uInt16 nSubSize;
-    rStrm >> nSubSize;
-    if( nSubSize )
-    {
-        // read the address of the data source range
-        rStrm.PushPosition();
-        ReadSrcRangeFormula( rStrm );
-        rStrm.PopPosition();
-        rStrm.Ignore( nSubSize );
-    }
-
-    // other list box settings
-    sal_Int16 nEntryCount;
-    sal_uInt16 nStyle, nComboStyle;
-    rStrm >> nEntryCount >> mnSelEntry >> nStyle;
-    rStrm.Ignore( 2 );  // linked edit field
-
-    mnSelType = nStyle & EXC_OBJ_LBS_SELMASK;
-    mbFlatBorder = ::get_flag( nStyle, EXC_OBJ_LBS_FLAT );
-
-    switch( mnCtrlType )
+    switch( nSubRecId )
     {
-        case EXC_OBJ_CMO_LISTBOX:
-            if( mnSelType != EXC_OBJ_LBS_SEL_SIMPLE )
-                for( sal_Int16 nEntry = 0; nEntry < nEntryCount; ++nEntry )
-                    if( rStrm.ReaduInt8() != 0 )
-                        maMultiSel.push_back( nEntry );
+        case EXC_ID_OBJ_FTCBLS:
+            ReadCbls( rStrm );
         break;
-        case EXC_OBJ_CMO_COMBOBOX:
-            rStrm >> nComboStyle >> mnLineCount;
-            // comboboxes of auto-filters have 'simple' style, they don't have an edit area
-            if( (nComboStyle & EXC_OBJ_LBS_COMBOMASK) == EXC_OBJ_LBS_COMBO_SIMPLE )
-                SetSkip();
+        case EXC_ID_OBJ_FTLBSDATA:
+            ReadLbsData( rStrm );
         break;
-    }
-
-}
-
-void XclImpEscherTbxCtrl::ReadSbs( XclImpStream& rStrm )
-{
-    sal_uInt16 nOrient, nStyle;
-    rStrm.Ignore( 4 );
-    rStrm >> mnScrollValue >> mnScrollMin >> mnScrollMax >> mnScrollStep >> mnScrollPage >> nOrient;
-    rStrm.Ignore( 2 );
-    rStrm >> nStyle;
-
-    mbScrollHor = ::get_flag( nOrient, EXC_OBJ_SBS_HORIZONTAL );
-    mbFlatButton = ::get_flag( nStyle, EXC_OBJ_SBS_FLAT );
-}
-
-void XclImpEscherTbxCtrl::ReadGboData( XclImpStream& rStrm )
-{
-    sal_uInt16 nStyle;
-    rStrm.Ignore( 4 );
-    rStrm >> nStyle;
-    mbFlatBorder = ::get_flag( nStyle, EXC_OBJ_GBO_FLAT );
-}
-
-void XclImpEscherTbxCtrl::ReadMacro( XclImpStream& rStrm )
-{
-    maMacroName.Erase();
-    if( rStrm.GetRecLeft() > 6 )
-    {
-        // macro is stored in a tNameXR token containing a link to a defined name
-        sal_uInt16 nFmlaSize;
-        rStrm >> nFmlaSize;
-        rStrm.Ignore( 4 );
-        DBG_ASSERT( nFmlaSize == 7, "XclImpEscherTbxCtrl::ReadMacro - unexpected formula size" );
-        if( nFmlaSize == 7 )
-        {
-            sal_uInt8 nTokenId;
-            sal_uInt16 nExtSheet, nExtName;
-            rStrm >> nTokenId >> nExtSheet >> nExtName;
-            DBG_ASSERT( nTokenId == XclTokenArrayHelper::GetTokenId( EXC_TOKID_NAMEX, EXC_TOKCLASS_REF ),
-                "XclImpEscherTbxCtrl::ReadMacro - tNameXR token expected" );
-            if( nTokenId == XclTokenArrayHelper::GetTokenId( EXC_TOKID_NAMEX, EXC_TOKCLASS_REF ) )
-                maMacroName = GetLinkManager().GetMacroName( nExtSheet, nExtName );
-        }
+        case EXC_ID_OBJ_FTSBSFMLA:  // equal to ftCblsFmla
+        case EXC_ID_OBJ_FTCBLSFMLA:
+            ReadCblsFmla( rStrm );
+        break;
+        case EXC_ID_OBJ_FTSBS:
+            ReadSbs( rStrm );
+        break;
+        case EXC_ID_OBJ_FTGBODATA:
+            ReadGboData( rStrm );
+        break;
+        case EXC_ID_OBJ_FTMACRO:
+            ReadMacro( rStrm );
+        break;
+        default:
+            XclImpDrawObjBase::ReadSubRecord( rStrm, nSubRecId, nSubRecSize );
     }
 }
 
-OUString XclImpEscherTbxCtrl::GetServiceName() const
+OUString XclImpTbxControlObj::GetServiceName() const
 {
-    return XclTbxControlHelper::GetServiceName( mnCtrlType );
+    return XclTbxControlHelper::GetServiceName( GetObjType() );
 }
 
-void XclImpEscherTbxCtrl::WriteToPropertySet( ScfPropertySet& rPropSet ) const
+void XclImpTbxControlObj::WriteToPropertySet( ScfPropertySet& rPropSet ) const
 {
-    rPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), GetPrintable() );
+    rPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), IsPrintable() );
 
     namespace AwtVisualEffect = ::com::sun::star::awt::VisualEffect;
     namespace AwtScrollOrient = ::com::sun::star::awt::ScrollBarOrientation;
@@ -735,7 +703,7 @@ void XclImpEscherTbxCtrl::WriteToPropert
 
     // control name -----------------------------------------------------------
 
-    OUString aName = XclTbxControlHelper::GetControlName( mnCtrlType );
+    OUString aName = XclTbxControlHelper::GetControlName( GetObjType() );
     if( aName.getLength() )
         rPropSet.SetProperty( CREATE_OUSTRING( "Name" ), aName );
 
@@ -769,14 +737,14 @@ void XclImpEscherTbxCtrl::WriteToPropert
 
     // special control contents -----------------------------------------------
 
-    switch( mnCtrlType )
+    switch( GetObjType() )
     {
         // checkbox/option button
 
         case EXC_OBJ_CMO_CHECKBOX:
         case EXC_OBJ_CMO_OPTIONBUTTON:
         {
-            bool bCheckBox = mnCtrlType == EXC_OBJ_CMO_CHECKBOX;
+            bool bCheckBox = GetObjType() == EXC_OBJ_CMO_CHECKBOX;
 
             sal_Int16 nApiState = 0;
             switch( mnState )
@@ -807,7 +775,7 @@ void XclImpEscherTbxCtrl::WriteToPropert
 
             Sequence< sal_Int16 > aSelection;
 
-            switch( mnCtrlType )
+            switch( GetObjType() )
             {
                 case EXC_OBJ_CMO_LISTBOX:
                 {
@@ -889,13 +857,13 @@ void XclImpEscherTbxCtrl::WriteToPropert
     }
 }
 
-bool XclImpEscherTbxCtrl::FillMacroDescriptor( ScriptEventDescriptor& rEvent ) const
+bool XclImpTbxControlObj::FillMacroDescriptor( ScriptEventDescriptor& rEvent ) const
 {
     if( maMacroName.Len() )
     {
         // type of action is dependent on control type
-        rEvent.ListenerType = XclTbxControlHelper::GetListenerType( mnCtrlType );
-        rEvent.EventMethod = XclTbxControlHelper::GetEventMethod( mnCtrlType );
+        rEvent.ListenerType = XclTbxControlHelper::GetListenerType( GetObjType() );
+        rEvent.EventMethod = XclTbxControlHelper::GetEventMethod( GetObjType() );
         if( rEvent.ListenerType.getLength() && rEvent.EventMethod.getLength() )
         {
             // set the macro name
@@ -907,63 +875,200 @@ bool XclImpEscherTbxCtrl::FillMacroDescr
     return false;
 }
 
-bool XclImpEscherTbxCtrl::Apply( ScfProgressBar& rProgress )
-{
-    bool bInserted = false;
-    // do not use IsValid() - the SdrObject is still missing
-    if( !GetIsSkip() && IsValidSize() )
-    {
-        if( GetObjectManager().CreateSdrObj( *this ) )
-        {
-            // form controls: set bound rect explicitly
-            mxSdrObj->NbcSetSnapRect( maAnchorRect );
-            // #i30543# insert into control layer
-            mxSdrObj->NbcSetLayer( SC_LAYER_CONTROLS );
-            // insert the SdrObj into the draw page
-            bInserted = XclImpEscherObj::Apply( rProgress );
-        }
-        else
-        {
-            // no success to create a control -> create a text box
-            bInserted = XclImpEscherTxo::Apply( rProgress );
-        }
-    }
-    else
-    {
-        rProgress.Progress();   // invalid objects are included in progress bar
-    }
-    return bInserted;
-}
-
-// ----------------------------------------------------------------------------
-
-TYPEINIT1( XclImpEscherOle, XclImpEscherObj );
-
-XclImpEscherOle::XclImpEscherOle( XclImpEscherObj& rSrcObj ):
-    XclImpEscherObj( rSrcObj ),
-    XclImpCtrlLinkHelper( xlBindContent ),
-    mnCtrlStrmPos( 0 ),
-    mnBlipId( 0 ),
-    mbAsSymbol( false ),
-    mbLinked( false ),
-    mbControl( false )
+void XclImpTbxControlObj::ReadCbls( XclImpStream& rStrm )
 {
-    SetAreaObj( true );
+    sal_uInt16 nStyle;
+    rStrm >> mnState;
+    rStrm.Ignore( 8 );
+    rStrm >> nStyle;
+    mnState &= EXC_OBJ_CBLS_STATEMASK;
+    mbFlatButton = ::get_flag( nStyle, EXC_OBJ_CBLS_FLAT );
 }
 
-void XclImpEscherOle::ReadPioGrbit( XclImpStream& rStrm )
+void XclImpTbxControlObj::ReadCblsFmla( XclImpStream& rStrm )
 {
-    sal_uInt16 nFlags;
-    rStrm >> nFlags;
-    mbAsSymbol = ::get_flag( nFlags, EXC_OBJ_PIO_SYMBOL );
-    mbLinked = ::get_flag( nFlags, EXC_OBJ_PIO_LINKED );
+    ReadCellLinkFormula( rStrm );
 }
 
-void XclImpEscherOle::ReadPictFmla( XclImpStream& rStrm, sal_uInt16 nRecSize )
+void XclImpTbxControlObj::ReadLbsData( XclImpStream& rStrm )
 {
-    sal_uInt32 nStorageId;
-    sal_uInt16 nFmlaLen;
-    rStrm >> nFmlaLen;
+    sal_uInt16 nSubSize;
+    rStrm >> nSubSize;
+    if( nSubSize )
+    {
+        // read the address of the data source range
+        rStrm.PushPosition();
+        ReadSrcRangeFormula( rStrm );
+        rStrm.PopPosition();
+        rStrm.Ignore( nSubSize );
+    }
+
+    // other list box settings
+    sal_Int16 nEntryCount;
+    sal_uInt16 nStyle, nComboStyle;
+    rStrm >> nEntryCount >> mnSelEntry >> nStyle;
+    rStrm.Ignore( 2 );  // linked edit field
+
+    mnSelType = nStyle & EXC_OBJ_LBS_SELMASK;
+    mbFlatBorder = ::get_flag( nStyle, EXC_OBJ_LBS_FLAT );
+
+    switch( GetObjType() )
+    {
+        case EXC_OBJ_CMO_LISTBOX:
+            if( mnSelType != EXC_OBJ_LBS_SEL_SIMPLE )
+                for( sal_Int16 nEntry = 0; nEntry < nEntryCount; ++nEntry )
+                    if( rStrm.ReaduInt8() != 0 )
+                        maMultiSel.push_back( nEntry );
+        break;
+        case EXC_OBJ_CMO_COMBOBOX:
+            rStrm >> nComboStyle >> mnLineCount;
+            // comboboxes of auto-filters have 'simple' style, they don't have an edit area
+            if( (nComboStyle & EXC_OBJ_LBS_COMBOMASK) == EXC_OBJ_LBS_COMBO_SIMPLE )
+                SetInvalid();
+        break;
+    }
+
+}
+
+void XclImpTbxControlObj::ReadSbs( XclImpStream& rStrm )
+{
+    sal_uInt16 nOrient, nStyle;
+    rStrm.Ignore( 4 );
+    rStrm >> mnScrollValue >> mnScrollMin >> mnScrollMax >> mnScrollStep >> mnScrollPage >> nOrient;
+    rStrm.Ignore( 2 );
+    rStrm >> nStyle;
+
+    mbScrollHor = ::get_flag( nOrient, EXC_OBJ_SBS_HORIZONTAL );
+    mbFlatButton = ::get_flag( nStyle, EXC_OBJ_SBS_FLAT );
+}
+
+void XclImpTbxControlObj::ReadGboData( XclImpStream& rStrm )
+{
+    sal_uInt16 nStyle;
+    rStrm.Ignore( 4 );
+    rStrm >> nStyle;
+    mbFlatBorder = ::get_flag( nStyle, EXC_OBJ_GBO_FLAT );
+}
+
+void XclImpTbxControlObj::ReadMacro( XclImpStream& rStrm )
+{
+    maMacroName.Erase();
+    if( rStrm.GetRecLeft() > 6 )
+    {
+        // macro is stored in a tNameXR token containing a link to a defined name
+        sal_uInt16 nFmlaSize;
+        rStrm >> nFmlaSize;
+        rStrm.Ignore( 4 );
+        DBG_ASSERT( nFmlaSize == 7, "XclImpTbxControlObj::ReadMacro - unexpected formula size" );
+        if( nFmlaSize == 7 )
+        {
+            sal_uInt8 nTokenId;
+            sal_uInt16 nExtSheet, nExtName;
+            rStrm >> nTokenId >> nExtSheet >> nExtName;
+            DBG_ASSERT( nTokenId == XclTokenArrayHelper::GetTokenId( EXC_TOKID_NAMEX, EXC_TOKCLASS_REF ),
+                "XclImpTbxControlObj::ReadMacro - tNameXR token expected" );
+            if( nTokenId == XclTokenArrayHelper::GetTokenId( EXC_TOKID_NAMEX, EXC_TOKCLASS_REF ) )
+            {
+                maMacroName = GetLinkManager().GetMacroName( nExtSheet, nExtName );
+                // #i38718# missing module name - try to find the macro in the imported modules
+                if( maMacroName.Len() && (maMacroName.Search( '.' ) == STRING_NOTFOUND) )
+                    if( SfxObjectShell* pDocShell = GetDocShell() )
+                        if( StarBASIC* pBasic = pDocShell->GetBasic() )
+                            if( SbMethod* pMethod = dynamic_cast< SbMethod* >( pBasic->Find( maMacroName, SbxCLASS_METHOD ) ) )
+                                if( SbModule* pModule = pMethod->GetModule() )
+                                    maMacroName.Insert( '.', 0 ).Insert( pModule->GetName(), 0 );
+            }
+        }
+    }
+}
+
+// ----------------------------------------------------------------------------
+
+XclImpOleObj::XclImpOleObj( const XclImpRoot& rRoot ) :
+    XclImpDrawObjBase( rRoot ),
+    XclImpCtrlLinkHelper( xlBindContent ),
+    mnCtrlStrmPos( 0 ),
+    mbAsSymbol( false ),
+    mbLinked( false ),
+    mbControl( false )
+{
+    SetAreaObj( true );
+}
+
+void XclImpOleObj::ReadSubRecord( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize )
+{
+    switch( nSubRecId )
+    {
+        case EXC_ID_OBJ_FTPIOGRBIT:
+            ReadPioGrbit( rStrm );
+        break;
+        case EXC_ID_OBJ_FTPICTFMLA:
+            ReadPictFmla( rStrm, nSubRecSize );
+        break;
+        default:
+            XclImpDrawObjBase::ReadSubRecord( rStrm, nSubRecId, nSubRecSize );
+    }
+}
+
+void XclImpOleObj::WriteToPropertySet( ScfPropertySet& rPropSet ) const
+{
+    rPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), IsPrintable() );
+    // #118053 set internal name of the control
+    if( maCtrlName.Len() > 0 )
+        rPropSet.SetStringProperty( CREATE_OUSTRING( "Name" ), maCtrlName );
+}
+
+void XclImpOleObj::DoProcessSdrObj( SdrObject& rSdrObj ) const
+{
+    if( !IsControl() )
+    {
+        // controls do have the "Printable" property
+        if( !IsPrintable() )
+            GetTracer().TraceObjectNotPrintable();
+
+        SfxObjectShell* pDocShell = GetDocShell();
+        SdrOle2Obj* pOleSdrObj = dynamic_cast< SdrOle2Obj* >( &rSdrObj );
+        if( pOleSdrObj && pDocShell )
+        {
+            comphelper::EmbeddedObjectContainer& rEmbObjCont = pDocShell->GetEmbeddedObjectContainer();
+            Reference< XEmbeddedObject > xEmbObj = pOleSdrObj->GetObjRef();
+            OUString aOldName( pOleSdrObj->GetPersistName() );
+
+            /*  The object persistence should be already in the storage, but
+                the object still might not be inserted into the container. */
+            if( rEmbObjCont.HasEmbeddedObject( aOldName ) )
+            {
+                if( !rEmbObjCont.HasEmbeddedObject( xEmbObj ) )
+                    // filter code is allowed to call the following method
+                    rEmbObjCont.AddEmbeddedObject( xEmbObj, aOldName );
+            }
+            else
+            {
+                /*  If the object is still not in container it must be iserted
+                    there, the name must be generated in this case. */
+                OUString aNewName;
+                rEmbObjCont.InsertEmbeddedObject( xEmbObj, aNewName );
+                if( aOldName != aNewName )
+                    // #95381# SetPersistName, not SetName
+                    pOleSdrObj->SetPersistName( aNewName );
+            }
+        }
+    }
+}
+
+void XclImpOleObj::ReadPioGrbit( XclImpStream& rStrm )
+{
+    sal_uInt16 nFlags;
+    rStrm >> nFlags;
+    mbAsSymbol = ::get_flag( nFlags, EXC_OBJ_PIO_SYMBOL );
+    mbLinked = ::get_flag( nFlags, EXC_OBJ_PIO_LINKED );
+}
+
+void XclImpOleObj::ReadPictFmla( XclImpStream& rStrm, sal_uInt16 nRecSize )
+{
+    sal_uInt32 nStorageId;
+    sal_uInt16 nFmlaLen;
+    rStrm >> nFmlaLen;
 
     String aUserName;
     sal_uInt32 nPos0 = rStrm.GetRecPos();        // fmla start
@@ -973,14 +1078,13 @@ void XclImpEscherOle::ReadPictFmla( XclI
 
     if( mbLinked )
     {
-        bool bSizeOk = (sizeof(nFmlaLen) + nFmlaLen == nRecSize);
-        DBG_ASSERT( bSizeOk, "XclImpEscherOle::ReadPictFmla - bad linked size" );
+        DBG_ASSERT( nFmlaLen + 2 == nRecSize, "XclImpOleObj::ReadPictFmla - bad linked size" );
         rStrm.Ignore( 7 );
         sal_uInt16 nXti, nExtName;
         rStrm >> nXti >> nExtName;
         const XclImpExtName* pExtName = GetLinkManager().GetExternName( nXti, nExtName );
         bOk = (pExtName && (pExtName->GetType() == xlExtOLE));
-        DBG_ASSERT( bOk, "XclImpEscherOle::ReadPictFmla - EXTERNNAME not found or not OLE" );
+        DBG_ASSERT( bOk, "XclImpOleObj::ReadPictFmla - EXTERNNAME not found or not OLE" );
         if( bOk )
             nStorageId = pExtName->GetStorageId();
     }
@@ -991,13 +1095,13 @@ void XclImpEscherOle::ReadPictFmla( XclI
     {
         sal_uInt16 n16;
         rStrm >> n16;     // should be 5 but who knows ...
-        DBG_ASSERT( n16 + 4 <= nFmlaLen, "XclImpEscherOle::ReadPictFmla - embedded length mismatch" );
+        DBG_ASSERT( n16 + 4 <= nFmlaLen, "XclImpOleObj::ReadPictFmla - embedded length mismatch" );
         if( n16 + 4 <= nFmlaLen )
         {
             rStrm.Ignore( n16 + 4 );
             sal_uInt8 n8;
             rStrm >> n8;
-            DBG_ASSERT( n8 == 0x03, "XclImpEscherOle::ReadPictFmla - no name start" );
+            DBG_ASSERT( n8 == 0x03, "XclImpOleObj::ReadPictFmla - no name start" );
             if( n8 == 0x03 )
             {
                 rStrm >> n16;     // string length
@@ -1007,7 +1111,7 @@ void XclImpEscherOle::ReadPictFmla( XclI
                     // 0:= ID follows, 1:= pad byte + ID
 #ifndef PRODUCT
                     sal_Int32 nLeft = sal_Int32(nFmlaLen) - (rStrm.GetRecPos() - nPos0);
-                    DBG_ASSERT( nLeft == 0 || nLeft == 1, "XclImpEscherOle::ReadPictFmla - unknown left over" );
+                    DBG_ASSERT( nLeft == 0 || nLeft == 1, "XclImpOleObj::ReadPictFmla - unknown left over" );
 #endif
 
                     // is it a form control?
@@ -1025,7 +1129,7 @@ void XclImpEscherOle::ReadPictFmla( XclI
             if( aUserName.EqualsAscii( "Forms.HTML:Hidden.1" ) )
             {
                 // #i26521# form controls to be ignored
-                SetSkip();
+                SetInvalid();
             }
             else if( rStrm.GetRecLeft() > 8 )
             {
@@ -1053,10 +1157,9 @@ void XclImpEscherOle::ReadPictFmla( XclI
                 }
             }
         }
-        else if( nStorageId )
+        else if( nStorageId > 0 )
         {
-            bool bSizeOk = sizeof(nFmlaLen) + nFmlaLen + sizeof(nStorageId) == nRecSize;
-            DBG_ASSERT( bSizeOk, "XclImpEscherOle::ReadPictFmla - bad embedded size" );
+            DBG_ASSERT( nFmlaLen + 6 == nRecSize, "XclImpOleObj::ReadPictFmla - bad embedded size" );
         }
         else
             bOk = false;    // no storage, internal
@@ -1064,157 +1167,46 @@ void XclImpEscherOle::ReadPictFmla( XclI
 
     if( bOk )
     {
-        maStorageName.AssignAscii( mbLinked ? "LNK" : "MBD" );
+        if( mbLinked )
+            maStorageName = EXC_STORAGE_OLE_LINKED;
+        else
+            maStorageName = EXC_STORAGE_OLE_EMBEDDED;
         sal_Char aBuf[ 2 * sizeof( sal_uInt32 ) + 1 ];
         sprintf( aBuf, "%08X", nStorageId );    // #100211# - checked
         maStorageName.AppendAscii( aBuf );
     }
 }
 
-void XclImpEscherOle::WriteToPropertySet( ScfPropertySet& rPropSet ) const
-{
-    rPropSet.SetBoolProperty( CREATE_OUSTRING( "Printable" ), GetPrintable() );
-    // #118053 set control name
-    if( maName.getLength() > 0 )
-        rPropSet.SetProperty( CREATE_OUSTRING( "Name" ), maName );
-}
-
-bool XclImpEscherOle::Apply( ScfProgressBar& rProgress )
-{
-    // do not use IsValid() - the SdrObject is still missing
-    if( !GetIsSkip() && IsValidSize() && GetObjectManager().CreateSdrObj( *this ) )
-    {
-        SfxObjectShell* pDocShell = GetDocShell();
-        SdrOle2Obj* pOleSdrObj = PTR_CAST( SdrOle2Obj, mxSdrObj.get() );
-        if( pOleSdrObj && pDocShell )
-        {
-			Reference< XEmbeddedObject > xObj = pOleSdrObj->GetObjRef();
-            OUString aOldName( pOleSdrObj->GetPersistName() );
-
-			if ( pDocShell->GetEmbeddedObjectContainer().HasEmbeddedObject( aOldName ) )
-			{
-				// the object persistence should be already in the storage,
-				// but the object still might not be inserted into the container
-				if ( !pDocShell->GetEmbeddedObjectContainer().HasEmbeddedObject( xObj ) )
-				{
-					// a filter code is allowed to call the following method
-					pDocShell->GetEmbeddedObjectContainer().AddEmbeddedObject( xObj, aOldName );
-				}
-			}
-			else
-			{
-				// if the object is still not in container it must be iserted there, the name must be generated in this case
-				OUString aNewName;
-				pDocShell->GetEmbeddedObjectContainer().InsertEmbeddedObject( xObj, aNewName );
-				if ( aOldName != aNewName )
-					// #95381# SetPersistName, not SetName
-					pOleSdrObj->SetPersistName( aNewName );
-			}
-        }
-        else if( mxSdrObj->ISA( SdrUnoObj ) )
-        {
-            // form controls: set bound rect explicitly
-            mxSdrObj->NbcSetSnapRect( maAnchorRect );
-            // #i30543# insert into control layer
-            mxSdrObj->NbcSetLayer( SC_LAYER_CONTROLS );
-        }
-    }
-    return XclImpEscherObj::Apply( rProgress );
-}
-
 // ----------------------------------------------------------------------------
 
-TYPEINIT1( XclImpEscherChart, XclImpEscherObj );
-
-XclImpEscherChart::XclImpEscherChart( XclImpEscherObj& rSrcObj, bool bOwnTab ) :
-    XclImpEscherObj( rSrcObj ),
+XclImpChartObj::XclImpChartObj( const XclImpRoot& rRoot, bool bOwnTab ) :
+    XclImpDrawObjBase( rRoot ),
     mbOwnTab( bOwnTab )
 {
     SetAreaObj( true );
 }
 
-void XclImpEscherChart::ReadChartSubStream( XclImpStream& rStrm )
+void XclImpChartObj::ReadChartSubStream( XclImpStream& rStrm )
 {
-    DBG_ASSERT( rStrm.GetRecId() == EXC_ID5_BOF, "XclImpEscherChart::ReadChartSubStream - no BOF record found" );
+    DBG_ASSERT( rStrm.GetRecId() == EXC_ID5_BOF, "XclImpChartObj::ReadChartSubStream - no BOF record found" );
     if( rStrm.GetRecId() == EXC_ID5_BOF )
     {
         mxChart.reset( new XclImpChart( GetRoot(), mbOwnTab ) );
         mxChart->ReadChartSubStream( rStrm );
+
+        /*  #i44077# Calculate anchor for sheet charts. Needed to get used area
+            if this chart is inserted as OLE object. */
         if( mbOwnTab )
-            SetTabChartAnchor();
+            CalcTabChartAnchor();
     }
 }
 
-sal_uInt32 XclImpEscherChart::GetProgressSize() const
+sal_uInt32 XclImpChartObj::DoGetProgressSize() const
 {
     return mxChart.is() ? mxChart->GetProgressSize() : 0;
 }
 
-bool XclImpEscherChart::Apply( ScfProgressBar& rProgress )
-{
-    // do not use IsValid() - the SdrObject is still missing
-    if( !mxChart || GetIsSkip() || !IsValidSize() )
-        return false;
-
-    // Trace if chart object is not printable.
-    if( !GetPrintable() )
-        GetTracer().TraceObjectNotPrintable();
-
-    SfxObjectShell* pDocShell = GetDocShell();
-    if( !pDocShell ) return false;
-
-    bool bInserted = false;
-    if( SvtModuleOptions().IsChart() )
-    {
-        OUString aName;
-        Reference< XEmbeddedObject > xObj = pDocShell->GetEmbeddedObjectContainer().
-                CreateEmbeddedObject( SvGlobalName( SO3_SCH_CLASSID ).GetByteSequence(), aName );
-
-        sal_Int64 nAspect = ::com::sun::star::embed::Aspects::MSOLE_CONTENT;
-        ::com::sun::star::awt::Size aAwtSize = xObj->getVisualAreaSize( nAspect );
-        Size aSize( aAwtSize.Width, aAwtSize.Height );
-        if( (aSize.Height() < 1) || (aSize.Width() < 1) )
-        {
-            MapUnit aUnit = VCLUnoHelper::UnoEmbed2VCLMapUnit( xObj->getMapUnit( nAspect ) );
-            aSize.Width() = aSize.Height() = 5000;
-            aSize = Window::LogicToLogic( aSize, MapMode( MAP_100TH_MM ), MapMode( aUnit ) );
-            aAwtSize.Width = aSize.Width();
-            aAwtSize.Height = aSize.Height();
-            xObj->setVisualAreaSize( nAspect, aAwtSize );
-        }
-
-        SdrOle2Obj* pSdrObj = new SdrOle2Obj( svt::EmbeddedObjectRef( xObj, nAspect ), aName, maAnchorRect );
-        pSdrObj->NbcSetLayer( SC_LAYER_FRONT );
-        if( SdrPage* pPage = GetSdrPage( GetScTab() ) )
-        {
-            pPage->InsertObject( pSdrObj );
-            bInserted = true;
-        }
-        pSdrObj->NbcSetLogicRect( maAnchorRect );
-
-        // create the chart array (core representation of source data)
-        ScChartArray aChartObj( GetDocPtr(), mxChart->GetSourceData(), aName );
-        aChartObj.SetHeaders( mxChart->HasHeaderRow(), mxChart->HasHeaderColumn() );
-
-        SchMemChart* pMemChart = aChartObj.CreateMemChart();
-        SchDLL::Update( xObj, pMemChart );
-		pSdrObj->GetNewReplacement();
-        delete pMemChart;
-
-        if( svt::EmbeddedObjectRef::TryRunningState( xObj ) )
-        {
-            Reference< XChartDocument > xChartDoc( xObj->getComponent(), UNO_QUERY );
-            mxChart->Convert( xChartDoc, rProgress );
-
-            Reference< XEmbedPersist > xPers( xObj, UNO_QUERY );
-            if( xPers.is() )
-                xPers->storeOwn();
-        }
-    }
-    return bInserted;
-}
-
-void XclImpEscherChart::SetTabChartAnchor()
+void XclImpChartObj::CalcTabChartAnchor()
 {
     // set uninitialized page to landscape
     if ( !GetPageSettings().GetPageData().mbValid )
@@ -1238,207 +1230,73 @@ void XclImpEscherChart::SetTabChartAncho
         nHeight -= 1000;
     }
 
-    SetAnchor( Rectangle( 500, 500, nWidth, nHeight ) );
+    maAnchorRect = Rectangle( 500, 500, nWidth, nHeight );
+    CreateEscherAnchor( maAnchorRect );
 }
 
-// Escher object data =========================================================
-
-XclImpObjData::XclImpObjData( XclImpEscherObj* pEscherObj ) :
-    maAnchor( 0 ),
-    mbInserted( false )
-{
-    SetObj( pEscherObj );
-}
-
-void XclImpObjData::SetObj( XclImpEscherObj* pEscherObj )
-{
-    mxEscherObj.reset( pEscherObj );
-    maAnchor.mnScTab = pEscherObj ? pEscherObj->GetScTab() : 0;
-}
+// Escher stream conversion ===================================================
 
-bool XclImpObjData::ContainsStrmPos( ULONG nStrmPos ) const
+void XclImpSolverContainer::ReadSolverContainer( SvStream& rEscherStrm )
 {
-    return mxEscherObj.get() && (mxEscherObj->GetStrmBegin() <= nStrmPos) && (nStrmPos < mxEscherObj->GetStrmEnd());
+    rEscherStrm >> *this;
 }
 
-sal_uInt32 XclImpObjData::GetProgressSize() const
+void XclImpSolverContainer::InsertSdrObjectInfo( const XclImpDrawObjBase& rDrawObj, SdrObject* pSdrObj )
 {
-    return mxEscherObj.get() ? mxEscherObj->GetProgressSize() : 0;
+    sal_uInt32 nShapeId = rDrawObj.GetShapeId();
+    if( (nShapeId != 0) && pSdrObj )
+        maSdrInfoMap[ nShapeId ].Set( pSdrObj, rDrawObj.GetShapeFlags() );
 }
 
-void XclImpObjData::Apply( ScfProgressBar& rProgress )
+void XclImpSolverContainer::RemoveSdrObjectInfo( const XclImpDrawObjBase& rDrawObj )
 {
-    mbInserted = mxEscherObj.get() && mxEscherObj->Apply( rProgress );
+    maSdrInfoMap.erase( rDrawObj.GetShapeId() );
 }
 
-void XclImpObjData::ExtendUsedArea( const XclImpRoot& rRoot, ScRange& rScUsedArea, SCTAB nScTab ) const
+void XclImpSolverContainer::UpdateConnectorRules()
 {
-    if( mbInserted && mxEscherObj.get() && (mxEscherObj->GetScTab() == nScTab) )
+    for( SvxMSDffConnectorRule* pRule = GetFirstRule(); pRule; pRule = GetNextRule() )
     {
-        // #i44077# object inserted -> update used area for OLE object import
-        ScRange aScRange( ScAddress::UNINITIALIZED );
-        if( rRoot.GetAddressConverter().ConvertRange( aScRange, maAnchor.maXclRange, nScTab, nScTab, false ) )
-        {
-            // reduce range, if object ends directly on borders between two columns or rows
-            if( (maAnchor.mnRX == 0) && (aScRange.aStart.Col() < aScRange.aEnd.Col()) )
-                aScRange.aEnd.IncCol( -1 );
-            if( (maAnchor.mnBY == 0) && (aScRange.aStart.Row() < aScRange.aEnd.Row()) )
-                aScRange.aEnd.IncRow( -1 );
-            rScUsedArea.ExtendTo( aScRange );
-        }
+        UpdateConnection( pRule->nShapeA, pRule->pAObj, &pRule->nSpFlagsA );
+        UpdateConnection( pRule->nShapeB, pRule->pBObj, &pRule->nSpFlagsB );
+        UpdateConnection( pRule->nShapeC, pRule->pCObj );
     }
 }
 
-// ----------------------------------------------------------------------------
-
-XclImpEscherObjList::XclImpEscherObjList( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot )
-{
-}
-
-void XclImpEscherObjList::AppendObj( XclImpEscherObj* pEscherObj )
+void XclImpSolverContainer::RemoveConnectorRules()
 {
-    DBG_ASSERT( pEscherObj, "XclImpEscherObjList::AppendObj - missing object" );
-    maObjDataList.Append( new XclImpObjData( pEscherObj ) );
-    UpdateCache();
+    // base class from SVX uses plain untyped tools/List
+    for( SvxMSDffConnectorRule* pRule = GetFirstRule(); pRule; pRule = GetNextRule() )
+        delete pRule;
+    aCList.Clear();
 }
 
-void XclImpEscherObjList::AppendDummyObj( XclImpEscherObj* pEscherObj )
+SvxMSDffConnectorRule* XclImpSolverContainer::GetFirstRule()
 {
-    // do not modify the cache
-    maObjDataList.Append( new XclImpObjData( pEscherObj ) );
-    if( pEscherObj )
-        pEscherObj->SetSkip();
+    return static_cast< SvxMSDffConnectorRule* >( aCList.First() );
 }
 
-void XclImpEscherObjList::ReplaceLastObj( XclImpEscherObj* pEscherObj )
+SvxMSDffConnectorRule* XclImpSolverContainer::GetNextRule()
 {
-    if( XclImpObjData* pObjData = maObjDataList.Last() )
-    {
-        DBG_ASSERT( pEscherObj, "XclImpEscherObjList::ReplaceLastObj - missing object" );
-        pObjData->SetObj( pEscherObj );
-        UpdateCache();
-    }
-    else
-        AppendObj( pEscherObj );
+    return static_cast< SvxMSDffConnectorRule* >( aCList.Next() );
 }
 
-XclImpEscherObj* XclImpEscherObjList::GetObj( SCTAB nScTab, sal_uInt16 nObjId ) const
+void XclImpSolverContainer::UpdateConnection( sal_uInt32 nShapeId, SdrObject*& rpSdrObj, sal_uInt32* pnShapeFlags )
 {
-    if( (nObjId != EXC_OBJ_INVALID_ID) && (nScTab >= 0) )
+    XclImpSdrInfoMap::const_iterator aIt = maSdrInfoMap.find( nShapeId );
+    if( aIt != maSdrInfoMap.end() )
     {
-        // objects are ordered by sheet index
-        size_t nCacheSize = maObjCache.size();
-        size_t nCacheIdx = static_cast< size_t >( nScTab );
-        if( nCacheIdx < nCacheSize )
-        {
-            ULONG nEnd = (nCacheIdx + 1 < nCacheSize) ? maObjCache[ nCacheIdx + 1 ].mnListIdx : maObjDataList.Count();
-            for( ULONG nListIdx = maObjCache[ nCacheIdx ].mnListIdx; nListIdx < nEnd; ++nListIdx )
-                if( XclImpEscherObj* pEscherObj = maObjDataList.GetObject( nListIdx )->GetObj() )
-                    if( (pEscherObj->GetScTab() == nScTab) && (pEscherObj->GetObjId() == nObjId) )
-                        return pEscherObj;
-        }
-    }
-    return 0;
-}
-
-XclImpEscherObj* XclImpEscherObjList::GetLastObj() const
-{
-    if( XclImpObjData* pObjData = maObjDataList.Last() )
-        return pObjData->GetObj();
-    return 0;
-}
-
-XclImpEscherObj* XclImpEscherObjList::GetObj( ULONG nStrmPos ) const
-{
-    XclImpObjData* pObjData = FindObjData( nStrmPos );
-    return pObjData ? pObjData->GetObj() : 0;
-}
-
-XclEscherAnchor* XclImpEscherObjList::GetAnchor( ULONG nStrmPos ) const
-{
-    XclImpObjData* pObjData = FindObjData( nStrmPos );
-    return pObjData ? &pObjData->GetAnchor() : 0;
-}
-
-void XclImpEscherObjList::Apply( ScfProgressBar& rProgress )
-{
-    DBG_ASSERT( !rProgress.IsStarted(), "XclImpEscherObjList::InitProgress - progress already started" );
-    XclImpObjData* pData = 0;
-
-    // initialize progress bar
-    sal_uInt32 nSegSize = 0;
-    for( pData = maObjDataList.First(); pData; pData = maObjDataList.Next() )
-        nSegSize += pData->GetProgressSize();
-
-    // insert the objects into the drawing layer
-    sal_Int32 nSeg = rProgress.AddSegment( std::max< sal_uInt32 >( nSegSize, 1 ) );
-    rProgress.ActivateSegment( nSeg );
-    for( pData = maObjDataList.First(); pData; pData = maObjDataList.Next() )
-        pData->Apply( rProgress );
-}
-
-void XclImpEscherObjList::ExtendUsedArea( ScRange& rScUsedArea, SCTAB nScTab ) const
-{
-    for( const XclImpObjData* pData = maObjDataList.First(); pData; pData = maObjDataList.Next() )
-        pData->ExtendUsedArea( GetRoot(), rScUsedArea, nScTab );
-}
-
-void XclImpEscherObjList::UpdateCache()
-{
-    if( const XclImpEscherObj* pEscherObj = GetLastObj() )
-    {
-        SCTAB nScTab = pEscherObj->GetScTab();
-        ULONG nStrmPos = pEscherObj->GetStrmBegin();
-
-        // #110252# ignore faked objects without corresponding Escher data (i.e. sheet-charts)
-        if( (nScTab >= 0) && (nStrmPos != 0) )
-        {
-            size_t nCacheIdx = static_cast< size_t >( nScTab );
-            if( nCacheIdx >= maObjCache.size() )
-                maObjCache.resize( nCacheIdx + 1, XclCacheEntry( GetObjCount() - 1, nStrmPos ) );
-            else if( maObjCache[ nCacheIdx ].mnStrmPos > nStrmPos )
-                maObjCache[ nCacheIdx ].mnStrmPos = nStrmPos;
-            DBG_ASSERT( (nCacheIdx == 0) || (maObjCache[ nCacheIdx - 1 ].mnStrmPos <= nStrmPos), "XclImpEscherObjList::UpdateCache - cache corrupted" );
-        }
-    }
-}
-
-XclImpObjData* XclImpEscherObjList::FindObjData( ULONG nStrmPos ) const
-{
-    size_t nCacheSize = maObjCache.size();
-    size_t nFoundIdx = 0;
-    bool bFound = false;
-
-    // find the correct cache entry
-    for( size_t nCacheIdx = 0; !bFound && (nCacheIdx < nCacheSize); ++nCacheIdx )
-    {
-        ULONG nStrmEnd = (nCacheIdx + 1 < nCacheSize) ? maObjCache[ nCacheIdx + 1 ].mnStrmPos : STREAM_SEEK_TO_END;
-        bFound = (maObjCache[ nCacheIdx ].mnStrmPos <= nStrmPos) && (nStrmPos < nStrmEnd);
-        if( bFound )
-            nFoundIdx = nCacheIdx;
-    }
-
-    // find the object in the found list range
-    if( bFound )
-    {
-        ULONG nListEnd = (nFoundIdx + 1 < nCacheSize) ? maObjCache[ nFoundIdx + 1 ].mnListIdx : maObjDataList.Count();
-        for( ULONG nListIdx = maObjCache[ nFoundIdx ].mnListIdx; nListIdx < nListEnd; ++nListIdx )
-        {
-            XclImpObjData* pObjData = maObjDataList.GetObject( nListIdx );
-            if( pObjData->ContainsStrmPos( nStrmPos ) )
-                return pObjData;
-        }
+        rpSdrObj = aIt->second.mpSdrObj;
+        if( pnShapeFlags )
+            *pnShapeFlags = aIt->second.mnShapeFlags;
     }
-    return 0;
 }
 
-// Escher stream conversion ===================================================
+// ----------------------------------------------------------------------------
 
 XclImpDffManager::XclImpDffManager(
-        const XclImpRoot& rRoot, XclImpObjectManager& rObjManager,
-        long nOffsDgg, SvStream* pStData, SdrModel* pSdrModel, long nApplicationScale ) :
-    SvxMSDffManager( rObjManager.GetEscherStream(), rRoot.GetBasePath(), nOffsDgg, pStData, pSdrModel, nApplicationScale, COL_DEFAULT, 24, 0, &rRoot.GetTracer().GetBaseTracer() ),
+        const XclImpRoot& rRoot, XclImpObjectManager& rObjManager, SvStream& rEscherStrm ) :
+    SvxMSDffManager( rEscherStrm, rRoot.GetBasePath(), 0, 0, rRoot.GetDoc().GetDrawLayer(), 1440, COL_DEFAULT, 24, 0, &rRoot.GetTracer().GetBaseTracer() ),
     XclImpRoot( rRoot ),
     mrObjManager( rObjManager ),
     mnOleImpFlags( 0 )
@@ -1456,126 +1314,172 @@ XclImpDffManager::XclImpDffManager(
     }
 }
 
-void XclImpDffManager::SetSdrObject( XclImpEscherObj* pEscherObj, ULONG nId, SvxMSDffImportData& rData )
+XclImpDffManager::~XclImpDffManager()
 {
-    SdrObject* pSdrObj = 0;
-    bool bRet = GetShape( nId, pSdrObj, rData );
-    if( bRet )
-        pEscherObj->SetSdrObj( pSdrObj );
-    else
-        delete pSdrObj;
 }
 
-bool XclImpDffManager::CreateSdrOleObj( XclImpEscherOle& rOleObj )
+void XclImpDffManager::StartProgressBar( sal_uInt32 nProgressSize )
 {
-    SfxObjectShell* pDocShell = GetDocShell();
-    const Rectangle& rAnchor = rOleObj.GetAnchor();
-    const String& rStorageName = rOleObj.GetStorageName();
+    mxProgress.reset( new ScfProgressBar( GetDocShell(), STR_PROGRESS_CALCULATING ) );
+    mxProgress->AddSegment( nProgressSize );
+    mxProgress->Activate();
+}
 
-    if( pDocShell && !rAnchor.IsEmpty() && rStorageName.Len() )
+void XclImpDffManager::ProcessEscherStream( SvStream& rEscherStrm )
+{
+    rEscherStrm.Seek( STREAM_SEEK_TO_END );
+    ULONG nStrmSize = rEscherStrm.Tell();
+    rEscherStrm.Seek( STREAM_SEEK_TO_BEGIN );
+    while( rEscherStrm.Tell() < nStrmSize )
     {
-        Graphic aGraph;
-        if( GetBLIP( rOleObj.GetBlipId(), aGraph ) )
+        DffRecordHeader aHeader;
+        rEscherStrm >> aHeader;
+        switch( aHeader.nRecType )
         {
-            ErrCode nError = ERRCODE_NONE;
-            SotStorageRef xSrc = GetRootStorage();
-            if( SdrOle2Obj* pOleSdrObj = CreateSdrOLEFromStorage(
-                    rStorageName, xSrc, pDocShell->GetStorage(), aGraph, rAnchor, NULL, nError, mnOleImpFlags ) )
-            {
-                rOleObj.SetSdrObj( pOleSdrObj );
-                return true;
-            }
+            case DFF_msofbtDggContainer:
+                ProcessDggContainer( rEscherStrm, aHeader );
+            break;
+            case DFF_msofbtDgContainer:
+                ProcessDgContainer( rEscherStrm, aHeader );
+            break;
+            default:
+                aHeader.SeekToEndOfRecord( rEscherStrm );
         }
     }
-    return false;
 }
 
-void XclImpDffManager::ProcessClientAnchor2( SvStream& rStrm, DffRecordHeader& rHeader, void*, DffObjData& rObjData )
+void XclImpDffManager::ProcessTabChart( const XclImpChartObj& rChartObj )
+{
+    // sheet charts store their anchor rectangle internally
+    const Rectangle& rAnchorRect = rChartObj.GetAnchorRect();
+    if( rChartObj.IsValidSize( rAnchorRect ) )
+    {
+        SdrObjectPtr xSdrObj( CreateSdrObject( rChartObj, rAnchorRect ) );
+        InsertSdrObject( rChartObj, xSdrObj.release() );
+        UpdateUsedArea( rChartObj );
+    }
+}
+
+ScRange XclImpDffManager::GetUsedArea( SCTAB nScTab ) const
 {
-    rHeader.SeekToContent( rStrm );
-    rStrm.SeekRel( 2 );
-    ULONG nFilePos = rStrm.Tell();
+    ScRange aScUsedArea( ScAddress::INITIALIZE_INVALID );
+    ScRangeMap::const_iterator aIt = maUsedAreaMap.find( nScTab );
+    if( aIt != maUsedAreaMap.end() )
+        aScUsedArea = aIt->second;
+    return aScUsedArea;
+}
+
+// virtual functions ----------------------------------------------------------
 
-    if( XclEscherAnchor* pAnchor = mrObjManager.GetEscherAnchorAcc( nFilePos ) )
+void XclImpDffManager::ProcessClientAnchor2( SvStream& rEscherStrm,
+        DffRecordHeader& rHeader, void* pClientData, DffObjData& rObjData )
+{
+    // find the OBJ record data related to the processed shape
+    if( XclImpDrawObjBase* pDrawObj = mrObjManager.FindDrawObj( rObjData.rSpHd ).get() )
     {
-        rStrm >> *pAnchor;
-        rObjData.aChildAnchor = pAnchor->GetRect( GetDoc(), MAP_100TH_MM );
+        rObjData.aChildAnchor = pDrawObj->ReadClientAnchor( rEscherStrm, rHeader );
         rObjData.bChildAnchor = sal_True;
-
-        if( XclImpEscherObj* pEscherObj = mrObjManager.GetEscherObjAcc( nFilePos ) )
-        {
-            pEscherObj->SetAnchor( rObjData.aChildAnchor );
-            if( XclImpEscherOle* pOleObj = PTR_CAST( XclImpEscherOle, pEscherObj ) )
-                pOleObj->SetBlipId( GetPropertyValue( DFF_Prop_pib ) );
-        }
     }
 }
 
-SdrObject* XclImpDffManager::ProcessObj(
-    SvStream& rStrm, DffObjData& rObjData, void*, Rectangle& rTextRect, SdrObject* pRetSdrObj )
+SdrObject* XclImpDffManager::ProcessObj( SvStream& rEscherStrm,
+        DffObjData& rObjData, void* pClientData, Rectangle& rTextRect, SdrObject* pOldSdrObj )
 {
-    // #118052# import control name
-    XclImpEscherObj* pObj = mrObjManager.GetEscherObjAcc( rObjData.rSpHd.nFilePos );
-    if( XclImpEscherOle* pOleObj = PTR_CAST( XclImpEscherOle, pObj ) )
+    /*  pOldSdrObj passes a generated SdrObject. This function owns this object
+        and can modify it. The function has either to return it back to caller
+        or to delete it by itself. */
+    SdrObjectPtr xSdrObj( pOldSdrObj );
+
+    // find the OBJ record data related to the processed shape
+    XclImpDrawObjRef xDrawObj = mrObjManager.FindDrawObj( rObjData.rSpHd );
+    const Rectangle& rAnchorRect = rObjData.aChildAnchor;
+
+    // #102378# Do not process the global page group shape (flag SP_FPATRIARCH)
+    bool bGlobalPageGroup = ::get_flag< sal_uInt32 >( rObjData.nSpFlags, SP_FPATRIARCH );
+    if( !xDrawObj || !xDrawObj->IsValid() || bGlobalPageGroup )
+        return 0;   // simply return, xSdrObj will be destroyed
+
+    // #119010# connectors don't have to be area objects
+    if( dynamic_cast< SdrEdgeObj* >( xSdrObj.get() ) )
+        xDrawObj->SetAreaObj( false );
+
+    // check for valid size for all objects (#i30816# objects embedded in groups)
+    if( !xDrawObj->IsValidSize( rAnchorRect ) )
+        return 0;   // simply return, xSdrObj will be destroyed
+
+    // set shape information from Escher stream
+    xDrawObj->SetShapeData( rObjData.nShapeId, rObjData.nSpFlags, GetPropertyValue( DFF_Prop_pib ) );
+
+    /*  Connect textbox data (string, alignment, text orientation) to object.
+        #98132# don't ask for a text-ID, Escher export doesn't set one. */
+    if( XclImpDrawingObj* pDrawingObj = dynamic_cast< XclImpDrawingObj* >( xDrawObj.get() ) )
+        pDrawingObj->SetTxoData( mrObjManager.FindTxoData( rObjData.rSpHd ) );
+
+    // #118052# import internal name of a control
+    if( XclImpOleObj* pOleObj = dynamic_cast< XclImpOleObj* >( xDrawObj.get() ) )
     {
-        sal_uInt32 nNameLen = GetPropertyValue( DFF_Prop_wzName );
-        if( nNameLen > 0 )
-        {
-            SeekToContent( DFF_Prop_wzName, mrObjManager.GetEscherStream() );
-            sal_Int32 nStrLen = nNameLen / 2;
-            OUStringBuffer aNameBfr( nStrLen );
-            sal_uInt16 cChar = 0;
-            for( sal_Int32 nIdx = 0; nIdx < nStrLen; ++nIdx )
-            {
-                mrObjManager.GetEscherStream() >> cChar;
-                aNameBfr.append( static_cast< sal_Unicode >( cChar ) );
-            }
-            OUString aName( aNameBfr.makeStringAndClear() );
-            pOleObj->SetName( aName );
-        }
+        String aName( ReadStringProperty( rEscherStrm, DFF_Prop_wzName ) );
+        if( aName.Len() )
+            pOleObj->SetControlName( aName );
     }
 
-    /*  #102378# Do not process the omnipresent first dummy shape in the table
-        (it has the flag SP_FPATRIARCH set). */
-    if( pRetSdrObj && !::get_flag< sal_uInt32 >( rObjData.nSpFlags, SP_FPATRIARCH ) )
+    // try to create a custom SdrObject that overwrites the passed object
+    SdrObjectPtr xNewSdrObj( CreateCustomSdrObject( *xDrawObj, rAnchorRect ) );
+    if( xNewSdrObj.get() )
+        xSdrObj = xNewSdrObj;   // transfer ownership to xSdrObj
+
+    // process the SdrObject
+    if( xSdrObj.get() )
     {
-        // #i30816# objects in groups need manual check for valid size
-        if( rObjData.nCalledByGroup > 0 )
-            if( const XclImpEscherObj* pEscherObj = mrObjManager.GetEscherObj( rObjData.rSpHd.nFilePos ) )
-                if( !pEscherObj->IsValidSize( rObjData.aChildAnchor ) )
-                    DELETEZ( pRetSdrObj );
+        // maybe if there is no color, we could do this in ApplyAttributes (writer?, calc?)
+        if( GetPropertyBool( DFF_Prop_fFilled ) && !IsProperty( DFF_Prop_fillColor ) )
+            xSdrObj->SetMergedItem( XFillColorItem( EMPTY_STRING, Color( COL_WHITE ) ) );
 
-        if( pRetSdrObj )
+        // automatic margin is handled by host
+        if( GetPropertyBool( DFF_Prop_AutoTextMargin ) )
         {
-            // maybe if there is no color, we could do this in ApplyAttributes (writer?, calc?)
-            if( GetPropertyBool( DFF_Prop_fFilled ) && !IsProperty( DFF_Prop_fillColor ) )
-                pRetSdrObj->SetMergedItem( XFillColorItem( EMPTY_STRING, Color( COL_WHITE ) ) );
+            long nMargin = EXC_ESCHER_AUTOMARGIN;
+            ScaleEmu( nMargin );
+            xSdrObj->SetMergedItem( SdrTextLeftDistItem( nMargin ) );
+            xSdrObj->SetMergedItem( SdrTextRightDistItem( nMargin ) );
+            xSdrObj->SetMergedItem( SdrTextUpperDistItem( nMargin ) );
+            xSdrObj->SetMergedItem( SdrTextLowerDistItem( nMargin ) );
+        }
 
-            // automatic margin is handled by host
-            if( GetPropertyBool( DFF_Prop_AutoTextMargin ) )
-            {
-                long nMargin = EXC_ESCHER_AUTOMARGIN;
-                ScaleEmu( nMargin );
-                pRetSdrObj->SetMergedItem( SdrTextLeftDistItem( nMargin ) );
-                pRetSdrObj->SetMergedItem( SdrTextRightDistItem( nMargin ) );
-                pRetSdrObj->SetMergedItem( SdrTextUpperDistItem( nMargin ) );
-                pRetSdrObj->SetMergedItem( SdrTextLowerDistItem( nMargin ) );
-            }
-            // #i39167# always default to "full width" for text & textless
-            // objects regardless of alignment.
-            pRetSdrObj->SetMergedItem( SdrTextHorzAdjustItem( SDRTEXTHORZADJUST_BLOCK ) );
+        // #i39167# full width for text and textless objects regardless of alignment
+        xSdrObj->SetMergedItem( SdrTextHorzAdjustItem( SDRTEXTHORZADJUST_BLOCK ) );
 
-            // text data and text alignment properties
-            // #98132# don't ask for a text-ID, Escher export doesn't set one
-            if( const XclImpEscherTxo* pTxoObj = mrObjManager.GetEscherTxo( rObjData.rSpHd.nFilePos ) )
-                pTxoObj->ApplyTextOnSdrObj( *pRetSdrObj );
+        // additional processing on the SdrObject
+        xDrawObj->ProcessSdrObject( *xSdrObj );
 
-            // connector rules
-            mrObjManager.UpdateConnectorRules( rObjData, *pRetSdrObj );
-        }
+        // add the area used by this object to the internal map of used areas
+        UpdateUsedArea( *xDrawObj );
+
+        /*  If the SdrObject will not be inserted into the draw page, delete it
+            here. Happens e.g. for notes: The ProcessSdrObject() call above has
+            inserted the note into the document, and the SdrObject is not
+            needed anymore. */
+        if( !xDrawObj->IsInsertSdr() )
+            xSdrObj.reset();
     }
 
-    return pRetSdrObj;
+    /*  Store the relation between shape ID and SdrObject for connectors. Must
+        be done here (and not in InsertSdrObject() function), otherwise all
+        SdrObjects embedded in groups would be lost. */
+    if( xSdrObj.get() )
+        maSolverCont.InsertSdrObjectInfo( *xDrawObj, xSdrObj.get() );
+
+    // pass the pointer to the processed draw object back to caller
+    if( pClientData )
+    {
+        XclImpDrawObjBase** ppDrawObj = reinterpret_cast< XclImpDrawObjBase** >( pClientData );
+        /*  If a group object is processed, the pointer is already set to the
+            group parent object. */
+        if( !*ppDrawObj )
+            *ppDrawObj = xDrawObj.get();
+    }
+
+    return xSdrObj.release();
 }
 
 ULONG XclImpDffManager::Calc_nBLIPPos( ULONG nOrgVal, ULONG nStreamPos ) const
@@ -1594,466 +1498,483 @@ FASTBOOL XclImpDffManager::GetColorFromP
     return TRUE;
 }
 
-sal_Bool XclImpDffManager::ShapeHasText( ULONG nShapeId, ULONG nFilePos ) const
+// private --------------------------------------------------------------------
+
+String XclImpDffManager::ReadStringProperty( SvStream& rEscherStrm, sal_uInt32 nPropId ) const
 {
-    const XclImpEscherTxo* pTxoObj = mrObjManager.GetEscherTxo( nFilePos );
-    return pTxoObj && pTxoObj->GetString();
+    String aString;
+    sal_uInt32 nBufferSize = GetPropertyValue( nPropId );
+    if( (nBufferSize > 0) && SeekToContent( nPropId, rEscherStrm ) )
+    {
+        for( sal_Int32 nCharIdx = 0, nStrLen = nBufferSize / 2; nCharIdx < nStrLen; ++nCharIdx )
+        {
+            sal_uInt16 nChar = 0;
+            rEscherStrm >> nChar;
+            aString.Append( static_cast< sal_Unicode >( nChar ) );
+        }
+    }
+    return aString;
 }
 
-// The object manager =========================================================
-
-XclImpObjectManager::XclImpObjectManager( const XclImpRoot& rRoot ) :
-    XclImpRoot( rRoot ),
-    maEscherObjList( rRoot ),
-    mbStartWithDummy( true )
+void XclImpDffManager::ProcessDggContainer( SvStream& rEscherStrm, const DffRecordHeader& rDggHeader )
 {
+    // seek to end of drawing group container
+    rDggHeader.SeekToEndOfRecord( rEscherStrm );
 }
 
-XclImpObjectManager::~XclImpObjectManager()
+void XclImpDffManager::ProcessDgContainer( SvStream& rEscherStrm, const DffRecordHeader& rDgHeader )
 {
+    ULONG nEndPos = rDgHeader.GetRecEndFilePos();
+    while( rEscherStrm.Tell() < nEndPos )
+    {
+        DffRecordHeader aHeader;
+        rEscherStrm >> aHeader;
+        switch( aHeader.nRecType )
+        {
+            case DFF_msofbtSolverContainer:
+                ProcessSolverContainer( rEscherStrm, aHeader );
+            break;
+            case DFF_msofbtSpgrContainer:
+                ProcessShGrContainer( rEscherStrm, aHeader );
+            break;
+            default:
+                aHeader.SeekToEndOfRecord( rEscherStrm );
+        }
+    }
+    // seek to end of drawing page container
+    rDgHeader.SeekToEndOfRecord( rEscherStrm );
+
+    // #i12638# #i37900# connector rules
+    maSolverCont.UpdateConnectorRules();
+    SolveSolver( maSolverCont );
+    maSolverCont.RemoveConnectorRules();
 }
 
-const XclImpEscherObj* XclImpObjectManager::GetEscherObj( SCTAB nScTab, sal_uInt16 nObjId ) const
+void XclImpDffManager::ProcessShGrContainer( SvStream& rEscherStrm, const DffRecordHeader& rShGrHeader )
 {
-    return maEscherObjList.GetObj( nScTab, nObjId );
+    ULONG nEndPos = rShGrHeader.GetRecEndFilePos();
+    while( rEscherStrm.Tell() < nEndPos )
+    {
+        DffRecordHeader aHeader;
+        rEscherStrm >> aHeader;
+        switch( aHeader.nRecType )
+        {
+            case DFF_msofbtSpgrContainer:
+            case DFF_msofbtSpContainer:
+                ProcessShContainer( rEscherStrm, aHeader );
+            break;
+            default:
+                aHeader.SeekToEndOfRecord( rEscherStrm );
+        }
+    }
+    // seek to end of shape group container
+    rShGrHeader.SeekToEndOfRecord( rEscherStrm );
 }
 
-XclImpEscherObj* XclImpObjectManager::GetEscherObjAcc( SCTAB nScTab, sal_uInt16 nObjId )
+void XclImpDffManager::ProcessSolverContainer( SvStream& rEscherStrm, const DffRecordHeader& rSolverHeader )
 {
-    return maEscherObjList.GetObj( nScTab, nObjId );
+    // solver container wants to read the solver container header again
+    rSolverHeader.SeekToBegOfRecord( rEscherStrm );
+    // read the entire solver container
+    rEscherStrm >> maSolverCont;
+    // seek to end of solver container
+    rSolverHeader.SeekToEndOfRecord( rEscherStrm );
 }
 
-const XclImpEscherObj* XclImpObjectManager::GetEscherObj( ULONG nStrmPos ) const
+void XclImpDffManager::ProcessShContainer( SvStream& rEscherStrm, const DffRecordHeader& rShHeader )
 {
-    return maEscherObjList.GetObj( nStrmPos );
+    rShHeader.SeekToBegOfRecord( rEscherStrm );
+    Rectangle aDummy;
+    const XclImpDrawObjBase* pDrawObj = 0;
+    /*  The call to ImportObj() creates and returns a new SdrObject for the
+        processed shape. This function takes ownership of the returned object.
+        If the shape is a group object, all embedded objects are created
+        recursively, and the returned group object contains them all.
+        ImportObj() calls the virtual functions ProcessClientAnchor2() and
+        ProcessObj() of the XclImpDffManager class. it writes the pointer to
+        the related draw object data (OBJ record) into pDrawObj. */
+    SdrObjectPtr xSdrObj( ImportObj( rEscherStrm, &pDrawObj, aDummy, aDummy, 0, 0 ) );
+    if( pDrawObj && xSdrObj.get() )
+        InsertSdrObject( *pDrawObj, xSdrObj.release() );
+    rShHeader.SeekToEndOfRecord( rEscherStrm );
 }
 
-XclImpEscherObj* XclImpObjectManager::GetEscherObjAcc( ULONG nStrmPos )
+XclImpOcxConverter& XclImpDffManager::GetOcxConverter()
 {
-    return maEscherObjList.GetObj( nStrmPos );
+    if( !mxOcxConverter )
+        mxOcxConverter.reset( new XclImpOcxConverter( GetRoot() ) );
+    return *mxOcxConverter;
 }
 
-const XclImpEscherObj* XclImpObjectManager::GetLastEscherObj() const
+void XclImpDffManager::InsertSdrObject( const XclImpDrawObjBase& rDrawObj, SdrObject* pSdrObj )
 {
-    return maEscherObjList.GetLastObj();
+    /*  Take ownership of the passed object. If insertion fails (e.g. rDrawObj
+        states to skip insertion, or missing draw page), the object is
+        automatically deleted. */
+    SdrObjectPtr xSdrObj( pSdrObj );
+    if( xSdrObj.get() && rDrawObj.IsInsertSdr() )
+        if( SdrPage* pSdrPage = GetSdrPage( rDrawObj.GetScTab() ) )
+            pSdrPage->InsertObject( xSdrObj.release() );
+    // SdrObject still here? Insertion failed, remove data from shape ID map.
+    if( xSdrObj.get() )
+        maSolverCont.RemoveSdrObjectInfo( rDrawObj );
+}
+
+SdrObject* XclImpDffManager::CreateCustomSdrObject( const XclImpDrawObjBase& rDrawObj, const Rectangle& rAnchorRect )
+{
+    SdrObjectPtr xSdrObj;
+    if( const XclImpOleObj* pOleObj = dynamic_cast< const XclImpOleObj* >( &rDrawObj ) )
+        xSdrObj.reset( CreateSdrObject( *pOleObj, rAnchorRect ) );
+    else if( const XclImpTbxControlObj* pTbxCtrlObj = dynamic_cast< const XclImpTbxControlObj* >( &rDrawObj ) )
+        xSdrObj.reset( CreateSdrObject( *pTbxCtrlObj, rAnchorRect ) );
+    else if( const XclImpChartObj* pChartObj = dynamic_cast< const XclImpChartObj* >( &rDrawObj ) )
+        xSdrObj.reset( CreateSdrObject( *pChartObj, rAnchorRect ) );
+    else
+        mxProgress->Progress();
+    return xSdrObj.release();
 }
 
-XclImpEscherObj* XclImpObjectManager::GetLastEscherObjAcc()
+SdrObject* XclImpDffManager::CreateSdrObject( const XclImpOleObj& rOleObj, const Rectangle& rAnchorRect )
 {
-    return maEscherObjList.GetLastObj();
+    SdrObjectPtr xSdrObj;
+    if( rOleObj.IsControl() )
+    {
+        // form control objects are created by the XclImpOcxConverter class
+        xSdrObj.reset( GetOcxConverter().CreateSdrObject( rOleObj, rAnchorRect ) );
+    }
+    else
+    {
+        // it is a normal OLE object
+        SfxObjectShell* pDocShell = GetDocShell();
+        const String& rStorageName = rOleObj.GetStorageName();
+        if( pDocShell && rStorageName.Len() )
+        {
+            Graphic aGraph;
+            if( GetBLIP( rOleObj.GetShapeBlipId(), aGraph ) )
+            {
+                SotStorageRef xSrcStrg = GetRootStorage();
+                ErrCode nError = ERRCODE_NONE;
+                xSdrObj.reset( CreateSdrOLEFromStorage( rStorageName, xSrcStrg,
+                    pDocShell->GetStorage(), aGraph, rAnchorRect, 0, nError, mnOleImpFlags ) );
+            }
+        }
+    }
+    mxProgress->Progress();
+    return xSdrObj.release();
 }
 
-const XclEscherAnchor* XclImpObjectManager::GetEscherAnchor( ULONG nStrmPos ) const
+SdrObject* XclImpDffManager::CreateSdrObject( const XclImpTbxControlObj& rTbxCtrlObj, const Rectangle& rAnchorRect )
 {
-    return maEscherObjList.GetAnchor( nStrmPos );
+    SdrObjectPtr xSdrObj( GetOcxConverter().CreateSdrObject( rTbxCtrlObj, rAnchorRect ) );
+    mxProgress->Progress();
+    return xSdrObj.release();
 }
 
-XclEscherAnchor* XclImpObjectManager::GetEscherAnchorAcc( ULONG nStrmPos )
+SdrObject* XclImpDffManager::CreateSdrObject( const XclImpChartObj& rChartObj, const Rectangle& rAnchorRect )
 {
-    return maEscherObjList.GetAnchor( nStrmPos );
-}
+    SfxObjectShell* pDocShell = GetDocShell();
+    const XclImpChart* pChart = rChartObj.GetChart();
+    if( !SvtModuleOptions().IsChart() || !pDocShell || !pChart )
+        return 0;
 
-// *** Text boxes *** ---------------------------------------------------------
+    ScRangeListRef xScRanges = pChart->GetSourceData();
+    if( !xScRanges.Is() )
+        return 0;
 
-const XclImpEscherTxo* XclImpObjectManager::GetEscherTxo( ULONG nStrmPos ) const
-{
-    const XclImpEscherObj* pEscherObj = GetEscherObj( nStrmPos );
-    return PTR_CAST( XclImpEscherTxo, pEscherObj );
-}
+    OUString aEmbObjName;
+    Reference< XEmbeddedObject > xEmbObj = pDocShell->GetEmbeddedObjectContainer().
+            CreateEmbeddedObject( SvGlobalName( SO3_SCH_CLASSID ).GetByteSequence(), aEmbObjName );
 
-XclImpEscherTxo* XclImpObjectManager::GetEscherTxoAcc( ULONG nStrmPos )
-{
-    return const_cast< XclImpEscherTxo* >( GetEscherTxo( nStrmPos ) );
-}
+    /*  Set the size to the embedded object, this prevents that font sizes of
+        text objects are changed in the chart when the object is inserted into
+        the draw page. */
+    sal_Int64 nAspect = ::com::sun::star::embed::Aspects::MSOLE_CONTENT;
+    MapUnit aUnit = VCLUnoHelper::UnoEmbed2VCLMapUnit( xEmbObj->getMapUnit( nAspect ) );
+    Size aSize( Window::LogicToLogic( rAnchorRect.GetSize(), MapMode( MAP_100TH_MM ), MapMode( aUnit ) ) );
+    ::com::sun::star::awt::Size aAwtSize;
+    aAwtSize.Width = aSize.Width();
+    aAwtSize.Height = aSize.Height();
+    xEmbObj->setVisualAreaSize( nAspect, aAwtSize );
 
-const XclImpEscherNote* XclImpObjectManager::GetEscherNote( SCTAB nScTab, sal_uInt16 nObjId ) const
-{
-    const XclImpEscherObj* pEscherObj = GetEscherObj( nScTab, nObjId );
-    return PTR_CAST( XclImpEscherNote, pEscherObj );
-}
+    // create the container OLE object
+    SdrOle2Obj* pSdrOleObj = new SdrOle2Obj( svt::EmbeddedObjectRef( xEmbObj, nAspect ), aEmbObjName, rAnchorRect );
+    SdrObjectPtr xSdrObj( pSdrOleObj );
+    xSdrObj->NbcSetLayer( SC_LAYER_FRONT );
 
-// *** Chart *** --------------------------------------------------------------
+    // create the chart array (core representation of source data)
+    ScChartArray aChartArray( GetDocPtr(), xScRanges, aEmbObjName );
+    aChartArray.SetHeaders( pChart->HasHeaderRow(), pChart->HasHeaderColumn() );
 
-void XclImpObjectManager::StartNewChartObj()
+    ::std::auto_ptr< SchMemChart > xMemChart( aChartArray.CreateMemChart() );
+    SchDLL::Update( xEmbObj, xMemChart.get() );
+    pSdrOleObj->GetNewReplacement();
+
+    // convert Excel chart to OOo Chart
+    if( svt::EmbeddedObjectRef::TryRunningState( xEmbObj ) )
+    {
+        Reference< XChartDocument > xChartDoc( xEmbObj->getComponent(), UNO_QUERY );
+        pChart->Convert( xChartDoc, *mxProgress );
+
+        Reference< XEmbedPersist > xPers( xEmbObj, UNO_QUERY );
+        if( xPers.is() )
+            xPers->storeOwn();
+    }
+
+    return xSdrObj.release();
+}
+
+void XclImpDffManager::UpdateUsedArea( const XclImpDrawObjBase& rDrawObj )
 {
-    XclImpEscherObj aTmp( GetRoot() );
-    AppendEscherObj( new XclImpEscherChart( aTmp, true ) );
+    ScRange aScObjArea( rDrawObj.GetUsedArea() );
+    if( aScObjArea.IsValid() )
+    {
+        ScRange* pScTabArea = 0;
+        ScRangeMap::iterator aIt = maUsedAreaMap.find( rDrawObj.GetScTab() );
+        if( aIt == maUsedAreaMap.end() )
+        {
+            pScTabArea = &maUsedAreaMap[ rDrawObj.GetScTab() ];
+            pScTabArea->SetInvalid();
+        }
+        else
+            pScTabArea = &aIt->second;
+
+        if( pScTabArea )
+            pScTabArea->ExtendTo( aScObjArea );
+    }
 }
 
-// *** OLE / controls *** -----------------------------------------------------
+// The object manager =========================================================
 
-bool XclImpObjectManager::CreateSdrObj( XclImpEscherOle& rOleObj )
+XclImpObjectManager::XclImpObjectManager( const XclImpRoot& rRoot ) :
+    XclImpRoot( rRoot )
 {
-    return rOleObj.IsControl() ?
-        GetOcxConverter().CreateSdrUnoObj( rOleObj ) :
-        GetDffManager().CreateSdrOleObj( rOleObj );
 }
 
-bool XclImpObjectManager::CreateSdrObj( XclImpEscherTbxCtrl& rCtrlObj )
+XclImpObjectManager::~XclImpObjectManager()
 {
-    return GetOcxConverter().CreateSdrUnoObj( rCtrlObj );
 }
 
 // *** Read Excel records *** -------------------------------------------------
 
-void XclImpObjectManager::ReadMsodrawinggroup( XclImpStream& rStrm )
+void XclImpObjectManager::ReadMsoDrawingGroup( XclImpStream& rStrm )
 {
-    maStreamConsumer.ConsumeRecord( rStrm );
+    // Excel continues this record with MSODRAWINGGROUP and CONTINUE records, hmm.
+    rStrm.ResetRecord( true, EXC_ID_MSODRAWINGGROUP );
+    ReadEscherRecord( rStrm );
 }
 
-void XclImpObjectManager::ReadMsodrawing( XclImpStream& rStrm )
+void XclImpObjectManager::ReadMsoDrawing( XclImpStream& rStrm )
 {
     rStrm.ResetRecord( false );     // disable internal CONTINUE handling
-
-    if( !maStreamConsumer.HasData() )
-        return;
-
-    sal_uInt32 nRecSize = rStrm.GetRecSize();
-    ULONG nStrmPos = maStreamConsumer.Tell();
-    bool bClientTextBox = false;
-
-    static sal_Char aBuf[ 0x0200 ];
-
-    if( nRecSize )
-    {
-        const DffRecordHeader* pLatestRecHd = maStreamConsumer.ConsumeRecord( rStrm );
-        if( pLatestRecHd )
-        {
-            switch( pLatestRecHd->nRecType )
-            {
-                case DFF_msofbtClientData:
-                    maStreamConsumer.AppendData( aBuf, 0x0100 );
-                break;
-                case DFF_msofbtClientTextbox:
-                    maStreamConsumer.AppendData( aBuf, 0x0200 );
-                    if( nRecSize == 8 )
-                        bClientTextBox = true;
-                break;
-                case DFF_msofbtSolverContainer:
-                    maStreamConsumer.GetStream() >> GetSolverContainer();
-                break;
-            }
-        }
-    }
-
-    // create a new escher object, if this MSODRAWING is not a client text box
-    if( !bClientTextBox )
-        AppendEscherObj( new XclImpEscherObj( GetRoot(), nStrmPos, maStreamConsumer.Tell() ) );
+    ReadEscherRecord( rStrm );
 }
 
-void XclImpObjectManager::ReadMsodrawingselection( XclImpStream& rStrm )
+void XclImpObjectManager::ReadMsoDrawingSelection( XclImpStream& rStrm )
 {
-    // not supported
+    ReadEscherRecord( rStrm );
 }
 
 void XclImpObjectManager::ReadObj( XclImpStream& rStrm )
 {
     rStrm.ResetRecord( false );     // disable internal CONTINUE handling
 
-    sal_uInt16 nSubRecId, nSubRecSize;
+    XclImpDrawObjRef xDrawObj;
     bool bLoop = true;
     while( bLoop && (rStrm.GetRecLeft() >= 4) )
     {
+        sal_uInt16 nSubRecId, nSubRecSize;
         rStrm >> nSubRecId >> nSubRecSize;
         rStrm.PushPosition();
 
         switch( nSubRecId )
         {
-            case EXC_ID_OBJ_FTEND:      bLoop = false;                              break;
-            case EXC_ID_OBJ_FTCMO:      ReadObjFtCmo( rStrm );                      break;
-            case EXC_ID_OBJ_FTPIOGRBIT: ReadObjFtPioGrbit( rStrm );                 break;
-            case EXC_ID_OBJ_FTPICTFMLA: ReadObjFtPictFmla( rStrm, nSubRecSize );    break;
-            // TBX form control subrecords
-            case EXC_ID_OBJ_FTCBLS:
-            case EXC_ID_OBJ_FTSBSFMLA:
-            case EXC_ID_OBJ_FTLBSDATA:
-            case EXC_ID_OBJ_FTCBLSFMLA:
-            case EXC_ID_OBJ_FTSBS:
-            case EXC_ID_OBJ_FTGBODATA:
-            case EXC_ID_OBJ_FTMACRO:    ReadObjTbxSubRec( rStrm, nSubRecId );       break;
+            case EXC_ID_OBJ_FTEND:
+                bLoop = false;
+            break;
+            case EXC_ID_OBJ_FTCMO:
+                DBG_ASSERT( !xDrawObj, "XclImpObjectManager::ReadObj - multiple FTCMO subrecords" );
+                xDrawObj = XclImpDrawObjBase::ReadObjCmo( rStrm );
+            break;
+            default:
+                DBG_ASSERT( xDrawObj.is(), "XclImpObjectManager::ReadObj - missing leading FTCMO subrecord" );
+                if( xDrawObj.is() )
+                    xDrawObj->ReadSubRecord( rStrm, nSubRecId, nSubRecSize );
         }
 
         rStrm.PopPosition();
         // sometimes the last subrecord has an invalid length -> min()
         rStrm.Ignore( ::std::min< sal_uInt32 >( nSubRecSize, rStrm.GetRecLeft() ) );
     }
-}
-
-void XclImpObjectManager::ReadTxo( XclImpStream& rStrm )
-{
-    rStrm.ResetRecord( false );     // disable internal CONTINUE handling
-
-    sal_uInt16 nAlign, nOrient, nTextLen, nFormCnt;
-    ::std::auto_ptr< XclImpString > pString;
-
-    /*  Let this function read all records in every case, even if text cannot be
-        applied to the current object - this skips all CONTINUE records. */
-
-    // step 1: read TXO record
-    rStrm >> nAlign;
-    rStrm >> nOrient;
-    rStrm.Ignore( 6 );
-    rStrm >> nTextLen >> nFormCnt;
-    nFormCnt /= 8;
-
-    // step 2: read 1st CONTINUE with string
-    bool bValid = true;
-    if( nTextLen )
-    {
-        rStrm.StartNextRecord();
-        bValid = rStrm.IsValid() && (rStrm.GetRecId() == EXC_ID_CONT);
-        DBG_ASSERT( bValid, "XclImpObjectManager::ReadTxo - missing CONTINUE record" );
-        if( bValid )
-        {
-            rStrm.ResetRecord( false );
-            String aText( rStrm.ReadUniString( nTextLen ) );
-            pString.reset( new XclImpString( aText ) );
-        }
-    }
 
-    // step 3: read 2nd CONTINUE with format runs
-    if( bValid && pString.get() && nFormCnt )
+    // try to read the chart substream
+    if( XclImpChartObj* pChartObj = dynamic_cast< XclImpChartObj* >( xDrawObj.get() ) )
     {
-        rStrm.StartNextRecord();
-        bValid = rStrm.IsValid() && (rStrm.GetRecId() == EXC_ID_CONT);
-        DBG_ASSERT( bValid, "XclImpObjectManager::ReadTxo - missing CONTINUE record" );
-        if( bValid )
+        bool bChartSubStrm = (rStrm.GetNextRecId() == EXC_ID5_BOF) && rStrm.StartNextRecord();
+        DBG_ASSERT( bChartSubStrm, "XclImpObjectManager::ReadObj - missing chart substream" );
+        if( bChartSubStrm )
         {
-            rStrm.ResetRecord( false );
-
-            sal_uInt16 nChar, nFont;
-            sal_uInt16 nCount = nFormCnt - 1;
-
-            for( sal_uInt16 nIndex = 0; nIndex < nCount; ++nIndex )
-            {
-                rStrm >> nChar >> nFont;
-                rStrm.Ignore( 4 );
-                pString->AppendFormat( nChar, nFont );
-            }
+            sal_uInt16 nBofType;
+            rStrm.Ignore( 2 );
+            rStrm >> nBofType;
+            DBG_ASSERT( nBofType == EXC_BOF_CHART, "XclImpObjectManager::ReadObj - no chart BOF record" );
+            // try to read the substream anyway
+            pChartObj->ReadChartSubStream( rStrm );
         }
     }
 
-    if( XclImpEscherObj* pEscherObj = GetLastEscherObjAcc() )
+    // store the new object in the internal containers
+    if( xDrawObj.is() )
     {
-        // only Escher Drawing objects can have text (Charts, OLE cannot)
-        if( bValid && pString.get() && pEscherObj->ISA( XclImpEscherDrawing ) )
-        {
-            XclImpEscherTxo* pTxoObj = PTR_CAST( XclImpEscherTxo, pEscherObj );
-            if( !pTxoObj )
-                // not yet a text object - create it
-                ReplaceEscherObj( pTxoObj = new XclImpEscherTxo( *pEscherObj ) );
-
-            pTxoObj->SetString( pString.release() );
-            pTxoObj->SetAlignment( nAlign );
-            pTxoObj->SetRotation( nOrient );
-        }
+        maObjMap[ maEscherStrm.Tell() ] = xDrawObj;
+        maObjMapId[ xDrawObj->GetObjId() ] = xDrawObj;
     }
 }
 
-void XclImpObjectManager::ReadChartSubStream( XclImpStream& rStrm )
+void XclImpObjectManager::ReadTxo( XclImpStream& rStrm )
 {
-    if( XclImpEscherChart* pChartObj = PTR_CAST( XclImpEscherChart, GetLastEscherObj() ) )
-        pChartObj->ReadChartSubStream( rStrm );
-    else
-        XclTools::SkipSubStream( rStrm );
+    XclImpTxoDataRef xTxo( new XclImpTxoData( GetRoot() ) );
+    xTxo->ReadTxo( rStrm );
+    maTxoMap[ maEscherStrm.Tell() ] = xTxo;
 }
 
-// *** Misc *** ---------------------------------------------------------------
-
-XclImpDffManager& XclImpObjectManager::GetDffManager()
+void XclImpObjectManager::ReadNote( XclImpStream& rStrm )
 {
-    //TODO/MBA: needs to be fixed!
-    if( !mxDffManager.get() )
-        mxDffManager.reset( new XclImpDffManager( GetRoot(), *this, 0, 0, GetDoc().GetDrawLayer(), 1440 ) );
-    return *mxDffManager;
-}
+    XclAddress aXclPos;
+    sal_uInt16 nFlags, nObjId;
+    rStrm >> aXclPos >> nFlags >> nObjId;
 
-void XclImpObjectManager::UpdateConnectorRules( const DffObjData& rObjData, SdrObject& rSdrObj )
-{
-    for( SvxMSDffConnectorRule* pRule = GetFirstConnectorRule(); pRule; pRule = GetNextConnectorRule() )
+    if( nObjId != EXC_OBJ_INVALID_ID )
     {
-        if( rObjData.nShapeId == pRule->nShapeC )
-        {
-            pRule->pCObj = &rSdrObj;
-        }
-        else
-        {
-            // #i37900# - remove fix for #i12638#
-            if( rObjData.nShapeId == pRule->nShapeA )
-            {
-                pRule->pAObj = &rSdrObj;
-                pRule->nSpFlagsA = rObjData.nSpFlags;
-            }
-            if( rObjData.nShapeId == pRule->nShapeB )
-            {
-                pRule->pBObj = &rSdrObj;
-                pRule->nSpFlagsB = rObjData.nSpFlags;
-            }
-        }
+        SCTAB nScTab = GetCurrScTab();
+        ScAddress aScNotePos( ScAddress::UNINITIALIZED );
+        if( GetAddressConverter().ConvertAddress( aScNotePos, aXclPos, nScTab, true ) )
+            if( XclImpNoteObj* pNoteObj = dynamic_cast< XclImpNoteObj* >( FindDrawObj( XclObjId( nScTab, nObjId ) ).get() ) )
+                pNoteObj->SetNoteData( aScNotePos, nFlags );
     }
 }
 
-void XclImpObjectManager::SetSkipObj( SCTAB nScTab, sal_uInt16 nObjId )
+void XclImpObjectManager::ReadTabChart( XclImpStream& rStrm )
 {
-    maSkipObjVec.push_back( XclSkipObj( nScTab, nObjId ) );
+    XclImpChartObjRef xChartObj( new XclImpChartObj( GetRoot(), true ) );
+    xChartObj->ReadChartSubStream( rStrm );
+    maTabCharts.push_back( xChartObj );
 }
 
-void XclImpObjectManager::Apply( ScfProgressBar& rProgress )
-{
-    RTL_LOGFILE_CONTEXT_AUTHOR( aLog, "sc", "dr104026", "XclImpObjectManager::Apply" );
-
-    // mark objects to be skipped
-    for( XclSkipObjVec::const_iterator aIt = maSkipObjVec.begin(), aEnd = maSkipObjVec.end(); aIt != aEnd; ++aIt )
-        if( XclImpEscherObj* pEscherObj = maEscherObjList.GetObj( aIt->mnScTab, aIt->mnObjId ) )
-            pEscherObj->SetSkip();
-
-    // insert the objects into the drawing layer
-    maEscherObjList.Apply( rProgress );
+// *** Drawing objects *** ----------------------------------------------------
 
-    // connector rules
-    if( mxSolverContainer.get() )
-        GetDffManager().SolveSolver( *mxSolverContainer );
+XclImpDrawObjRef XclImpObjectManager::FindDrawObj( const DffRecordHeader& rHeader ) const
+{
+    /*  maObjMap stores objects by position of the client data (OBJ record) in
+        the Escher stream, which is always behind shape start position of the
+        passed header. The function upper_bound() finds the first element in
+        the map whose key is greater then the start position of the header. Its
+        end position is used to test whether the found object is really related
+        to the shape. */
+    XclImpDrawObjRef xDrawObj;
+    XclImpObjMap::const_iterator aIt = maObjMap.upper_bound( rHeader.GetRecBegFilePos() );
+    if( (aIt != maObjMap.end()) && (aIt->first <= rHeader.GetRecEndFilePos()) )
+        xDrawObj = aIt->second;
+    return xDrawObj;
 }
 
-void XclImpObjectManager::ExtendUsedArea( ScRange& rScUsedArea, SCTAB nScTab ) const
+XclImpDrawObjRef XclImpObjectManager::FindDrawObj( const XclObjId& rObjId ) const
 {
-    maEscherObjList.ExtendUsedArea( rScUsedArea, nScTab );
+    XclImpDrawObjRef xDrawObj;
+    XclImpObjMapById::const_iterator aIt = maObjMapId.find( rObjId );
+    if( aIt != maObjMapId.end() )
+        xDrawObj = aIt->second;
+    return xDrawObj;
 }
 
-// private --------------------------------------------------------------------
-
-void XclImpObjectManager::AppendEscherObj( XclImpEscherObj* pEscherObj )
+XclImpTxoDataRef XclImpObjectManager::FindTxoData( const DffRecordHeader& rHeader ) const
 {
-    if( mbStartWithDummy )    // insert dummy object for invalid first shape
-    {
-        maEscherObjList.AppendDummyObj( new XclImpEscherObj( GetRoot() ) );
-        mbStartWithDummy = false;
-    }
-    maEscherObjList.AppendObj( pEscherObj );
+    /*  maTxoMap stores textbox data by position of the client data (TXO record)
+        in the Escher stream, which is always behind shape start position of
+        the passed header. The function upper_bound() finds the first element
+        in the map whose key is greater then the start position of the header.
+        Its end position is used to test whether the found object is really
+        related to the shape. */
+    XclImpTxoDataRef xTxoData;
+    XclImpTxoMap::const_iterator aIt = maTxoMap.upper_bound( rHeader.GetRecBegFilePos() );
+    if( (aIt != maTxoMap.end()) && (aIt->first <= rHeader.GetRecEndFilePos()) )
+        xTxoData = aIt->second;
+    return xTxoData;
 }
 
-void XclImpObjectManager::ReplaceEscherObj( XclImpEscherObj* pEscherObj )
+void XclImpObjectManager::SetInvalidObj( SCTAB nScTab, sal_uInt16 nObjId )
 {
-    maEscherObjList.ReplaceLastObj( pEscherObj );
+    maInvalidObjs.push_back( XclObjId( nScTab, nObjId ) );
 }
 
-void XclImpObjectManager::ReadObjFtCmo( XclImpStream& rStrm )
+// *** Drawing object conversion *** ------------------------------------------
+
+XclImpDffManager& XclImpObjectManager::GetDffManager()
 {
-    XclImpEscherObj* pEscherObj = GetLastEscherObjAcc();
-    if( !pEscherObj )
-        return;
+    if( !mxDffManager )
+        mxDffManager.reset( new XclImpDffManager( GetRoot(), *this, maEscherStrm ) );
+    return *mxDffManager;
+}
 
-    sal_uInt16 nObjType, nObjId, nFlags;
-    rStrm >> nObjType >> nObjId >> nFlags;
+void XclImpObjectManager::ConvertObjects()
+{
+    RTL_LOGFILE_CONTEXT_AUTHOR( aLog, "sc", "dr104026", "XclImpObjectManager::ConvertObjects" );
 
-    pEscherObj->SetObjId( nObjId );
-    pEscherObj->SetPrintable(::get_flag( nFlags, EXC_OBJ_CMO_PRINTABLE) );
+    // process list of identifiers of invalid objects
+    for( XclObjIdVec::const_iterator aVIt = maInvalidObjs.begin(), aVEnd = maInvalidObjs.end(); aVIt != aVEnd; ++aVIt )
+        if( XclImpDrawObjBase* pDrawObj = FindDrawObj( *aVIt ).get() )
+            pDrawObj->SetInvalid();
 
-    switch( nObjType )
+    sal_uInt32 nProgressSize = GetProgressSize();
+    if( nProgressSize > 0 )
     {
-        case EXC_OBJ_CMO_GROUP:
-        case EXC_OBJ_CMO_LINE:
-        case EXC_OBJ_CMO_ARC:
-            ReplaceEscherObj( new XclImpEscherDrawing( *pEscherObj, false ) );
-        break;
-        case EXC_OBJ_CMO_RECTANGLE:
-        case EXC_OBJ_CMO_ELLIPSE:
-        case EXC_OBJ_CMO_POLYGON:
-        case EXC_OBJ_CMO_DRAWING:
-            ReplaceEscherObj( new XclImpEscherDrawing( *pEscherObj, true ) );
-        break;
-        case EXC_OBJ_CMO_TEXT:
-            ReplaceEscherObj( new XclImpEscherTxo( *pEscherObj ) );
-        break;
-        case EXC_OBJ_CMO_NOTE:
-            ReplaceEscherObj( new XclImpEscherNote( *pEscherObj ) );
-        break;
-        case EXC_OBJ_CMO_BUTTON:
-        case EXC_OBJ_CMO_CHECKBOX:
-        case EXC_OBJ_CMO_OPTIONBUTTON:
-        case EXC_OBJ_CMO_LABEL:
-        case EXC_OBJ_CMO_GROUPBOX:
-        case EXC_OBJ_CMO_LISTBOX:
-        case EXC_OBJ_CMO_COMBOBOX:
-        case EXC_OBJ_CMO_SPIN:
-        case EXC_OBJ_CMO_SCROLLBAR:
-            ReplaceEscherObj( new XclImpEscherTbxCtrl( *pEscherObj, nObjType ) );
-        break;
-        case EXC_OBJ_CMO_PICTURE:
-            ReplaceEscherObj( new XclImpEscherOle( *pEscherObj ) );
-        break;
-        case EXC_OBJ_CMO_CHART:
-            ReplaceEscherObj( new XclImpEscherChart( *pEscherObj, false ) );
-        break;
-        case EXC_OBJ_CMO_EDIT:          // only in dialogs
-        case EXC_OBJ_CMO_DIALOG:        // not supported
-            pEscherObj->SetSkip();
-        break;
-        default:
-            DBG_ERROR1( "XclImpObjectManager::ReadObjFtCmo - unknown object type 0x%04hX", nObjType );
-            ReplaceEscherObj( new XclImpEscherDrawing( *pEscherObj, true ) );
+        XclImpDffManager& rDffManager = GetDffManager();
+        rDffManager.StartProgressBar( nProgressSize );
+        // process the Escher stream, this inserts the objects into the drawing layer
+        rDffManager.ProcessEscherStream( maEscherStrm );
+        // chart sheets
+        for( XclImpChartObjList::const_iterator aLIt = maTabCharts.begin(), aLEnd = maTabCharts.end(); aLIt != aLEnd; ++aLIt )
+            rDffManager.ProcessTabChart( **aLIt );
     }
 }
 
-void XclImpObjectManager::ReadObjFtPioGrbit( XclImpStream& rStrm )
+ScRange XclImpObjectManager::GetUsedArea( SCTAB nScTab ) const
 {
-    if( XclImpEscherOle* pOleObj = PTR_CAST( XclImpEscherOle, GetLastEscherObj() ) )
-        pOleObj->ReadPioGrbit( rStrm );
-    else
-        DBG_ERRORFILE( "XclImpObjectManager::ReadObjFtPioGrbit - no OLE object" );
+    ScRange aScUsedArea( ScAddress::INITIALIZE_INVALID );
+    if( mxDffManager.is() )
+        aScUsedArea = mxDffManager->GetUsedArea( nScTab );
+    return aScUsedArea;
 }
 
-void XclImpObjectManager::ReadObjFtPictFmla( XclImpStream& rStrm, sal_uInt16 nRecSize )
-{
-    if( XclImpEscherOle* pOleObj = PTR_CAST( XclImpEscherOle, GetLastEscherObj() ) )
-        pOleObj->ReadPictFmla( rStrm, nRecSize );
-    else
-        DBG_ERRORFILE( "XclImpObjectManager::ReadObjFtPictFmla - no OLE object" );
-}
+// private --------------------------------------------------------------------
 
-void XclImpObjectManager::ReadObjTbxSubRec( XclImpStream& rStrm, sal_uInt16 nSubRecId )
+void XclImpObjectManager::ReadEscherRecord( XclImpStream& rStrm )
 {
-    if( XclImpEscherTbxCtrl* pCtrlObj = PTR_CAST( XclImpEscherTbxCtrl, GetLastEscherObj() ) )
+    sal_uInt32 nRecSize = rStrm.GetRecSize();
+    if( nRecSize > 0 )
     {
-        switch( nSubRecId )
-        {
-            case EXC_ID_OBJ_FTCBLS:     pCtrlObj->ReadCbls( rStrm );        break;
-            case EXC_ID_OBJ_FTLBSDATA:  pCtrlObj->ReadLbsData( rStrm );     break;
-            case EXC_ID_OBJ_FTSBSFMLA:  // equal to ftCblsFmla
-            case EXC_ID_OBJ_FTCBLSFMLA: pCtrlObj->ReadCblsFmla( rStrm );    break;
-            case EXC_ID_OBJ_FTSBS:      pCtrlObj->ReadSbs( rStrm );         break;
-            case EXC_ID_OBJ_FTGBODATA:  pCtrlObj->ReadGboData( rStrm );     break;
-            case EXC_ID_OBJ_FTMACRO:    pCtrlObj->ReadMacro( rStrm );       break;
-
-            default:    DBG_ERRORFILE( "XclImpObjectManager::ReadObjTbxSubRec - unknown subrecord" );
-        }
+        ScfUInt8Vec aBuffer( nRecSize );
+        // read from input stream
+        rStrm.Seek( EXC_REC_SEEK_TO_BEGIN );
+        rStrm.Read( &aBuffer.front(), nRecSize );
+        // write to Escher stream
+        maEscherStrm.Seek( STREAM_SEEK_TO_END );
+        maEscherStrm.Write( &aBuffer.front(), nRecSize );
     }
 }
 
-XclImpOcxConverter& XclImpObjectManager::GetOcxConverter()
-{
-    if( !mxOcxConverter.get() )
-        mxOcxConverter.reset( new XclImpOcxConverter( GetRoot() ) );
-    return *mxOcxConverter;
-}
-
-SvxMSDffSolverContainer& XclImpObjectManager::GetSolverContainer()
-{
-    if( !mxSolverContainer.get() )
-        mxSolverContainer.reset( new SvxMSDffSolverContainer );
-    return *mxSolverContainer;
-}
-
-SvxMSDffConnectorRule* XclImpObjectManager::GetFirstConnectorRule()
+void XclImpObjectManager::ReadChartSubStream( XclImpStream& rStrm, XclImpChartObj& rChartObj )
 {
-    void* pRule = mxSolverContainer.get() ? mxSolverContainer->aCList.First() : 0;
-    return static_cast< SvxMSDffConnectorRule* >( pRule );
+    rChartObj.ReadChartSubStream( rStrm );
 }
 
-SvxMSDffConnectorRule* XclImpObjectManager::GetNextConnectorRule()
+sal_uInt32 XclImpObjectManager::GetProgressSize() const
 {
-    void* pRule = mxSolverContainer.get() ? mxSolverContainer->aCList.Next() : 0;
-    return static_cast< SvxMSDffConnectorRule* >( pRule );
+    sal_uInt32 nProgressSize = 0;
+    for( XclImpObjMap::const_iterator aMIt = maObjMap.begin(), aMEnd = maObjMap.end(); aMIt != aMEnd; ++aMIt )
+        nProgressSize += aMIt->second->GetProgressSize();
+    for( XclImpChartObjList::const_iterator aLIt = maTabCharts.begin(), aLEnd = maTabCharts.end(); aLIt != aLEnd; ++aLIt )
+        nProgressSize += (*aLIt)->GetProgressSize();
+    return nProgressSize;
 }
 
 // Escher property set helper =================================================
Index: sc/source/filter/excel/xihelper.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xihelper.cxx,v
retrieving revision 1.19
retrieving revision 1.19.4.1
diff -u -p -u -p -r1.19 -r1.19.4.1
--- sc/source/filter/excel/xihelper.cxx	29 Mar 2005 13:39:38 -0000	1.19
+++ sc/source/filter/excel/xihelper.cxx	12 Jul 2005 15:28:29 -0000	1.19.4.1
@@ -331,19 +331,17 @@ void XclImpString::Read( XclImpStream& r
             sal_uInt16 nRunCount;
             sal_uInt32 nExtInf;
             rStrm.ReadUniStringExtHeader( b16Bit, bRich, bFarEast, nRunCount, nExtInf, nFlagField );
+            // #122185# ignore the flags, they may be wrong
 
             // --- character array ---
             maString = rStrm.ReadRawUniString( nChars, b16Bit );
 
             // --- formatting ---
-            DBG_ASSERT( bRich == (nRunCount != 0), "XclImpString::Read - corrupt formatting info" );
-            if( bRich )
+            if( nRunCount > 0 )
                 ReadFormats( rStrm, nRunCount );
 
             // --- extended (FarEast) information ---
-            DBG_ASSERT( bFarEast == (nExtInf != 0), "XclImpString::Read - corrupt far-east info" );
-            if( bFarEast )
-                rStrm.SkipUniStringExtData( nExtInf );
+            rStrm.SkipUniStringExtData( nExtInf );
         }
         break;
 
Index: sc/source/filter/excel/xiname.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xiname.cxx,v
retrieving revision 1.3
retrieving revision 1.3.36.3
diff -u -p -u -p -r1.3 -r1.3.36.3
--- sc/source/filter/excel/xiname.cxx	21 Feb 2005 13:32:36 -0000	1.3
+++ sc/source/filter/excel/xiname.cxx	19 Jul 2005 10:18:15 -0000	1.3.36.3
@@ -77,14 +77,10 @@
 #include "excimp8.hxx"
 
 // ============================================================================
-// *** Helper classes ***
-// ============================================================================
-
-// ============================================================================
 // *** Implementation ***
 // ============================================================================
 
-XclImpName::XclImpName( XclImpStream& rStrm, sal_uInt16 nScIndex ) :
+XclImpName::XclImpName( XclImpStream& rStrm, sal_uInt16 nXclNameIdx ) :
     XclImpRoot( rStrm.GetRoot() ),
     mpScData( 0 ),
     mcBuiltIn( EXC_BUILTIN_UNKNOWN ),
@@ -96,7 +92,7 @@ XclImpName::XclImpName( XclImpStream& rS
 
     // 1) *** read data from stream *** ---------------------------------------
 
-    sal_uInt16 nFlags = 0, nFmlaSize, nExtSheet = EXC_NAME_GLOBAL;
+    sal_uInt16 nFlags = 0, nFmlaSize, nExtSheet = EXC_NAME_GLOBAL, nXclTab = EXC_NAME_GLOBAL;
     sal_uInt8 nNameLen, nShortCut;
 
     switch( GetBiff() )
@@ -122,9 +118,7 @@ XclImpName::XclImpName( XclImpStream& rS
         case EXC_BIFF5:
         case EXC_BIFF8:
         {
-            rStrm >> nFlags >> nShortCut >> nNameLen >> nFmlaSize;
-            rStrm.Ignore( 2 );
-            rStrm >> nExtSheet;
+            rStrm >> nFlags >> nShortCut >> nNameLen >> nFmlaSize >> nExtSheet >> nXclTab;
             rStrm.Ignore( 4 );
         }
         break;
@@ -175,10 +169,12 @@ XclImpName::XclImpName( XclImpStream& rS
     }
 
     // add index for local names
-    if( nExtSheet != EXC_NAME_GLOBAL )
+    if( nXclTab != EXC_NAME_GLOBAL )
     {
-        maScName.Append( '_' ).Append( String::CreateFromInt32( nExtSheet ) );
-        mnScTab = static_cast< SCTAB >( nExtSheet - 1 );
+        sal_uInt16 nUsedTab = (GetBiff() == EXC_BIFF8) ? nXclTab : nExtSheet;
+        maScName.Append( '_' ).Append( String::CreateFromInt32( nUsedTab ) );
+        // TODO: may not work for BIFF5, handle skipped sheets (all BIFF)
+        mnScTab = static_cast< SCTAB >( nUsedTab - 1 );
     }
 
     // find an unused name
@@ -194,8 +190,7 @@ XclImpName::XclImpName( XclImpStream& rS
     const ScTokenArray* pTokArr = 0; // pointer to token array, owned by rFmlaConv
     RangeType nNameType = RT_NAME;
 
-    const sal_uInt16 nUnsupported = EXC_NAME_VB | EXC_NAME_PROC | EXC_NAME_BIG;
-    if( ::get_flag( nFlags, nUnsupported ) )
+    if( ::get_flag( nFlags, EXC_NAME_BIG ) )
     {
         // special, unsupported name
         rFmlaConv.GetDummy( pTokArr );
@@ -255,8 +250,8 @@ XclImpName::XclImpName( XclImpStream& rS
     {
         // create the Calc name data
         ScRangeData* pData = new ScRangeData( GetDocPtr(), maScName, *pTokArr, ScAddress(), nNameType );
-        pData->GuessPosition();
-        pData->SetIndex( nScIndex );
+        pData->GuessPosition();             // calculate base position for relative refs
+        pData->SetIndex( nXclNameIdx );     // used as unique identifier in formulas
         rRangeNames.Insert( pData );        // takes ownership of pData
         mpScData = pData;                   // cache for later use
     }
Index: sc/source/filter/excel/xipivot.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xipivot.cxx,v
retrieving revision 1.8
retrieving revision 1.8.36.1
diff -u -p -u -p -r1.8 -r1.8.36.1
--- sc/source/filter/excel/xipivot.cxx	21 Feb 2005 13:33:14 -0000	1.8
+++ sc/source/filter/excel/xipivot.cxx	9 Aug 2005 16:29:38 -0000	1.8.36.1
@@ -1151,7 +1151,7 @@ void XclImpPivotTable::ReadSxpi( XclImpS
             maPageFields.push_back( aPageInfo.mnField );
             pField->SetPageFieldInfo( aPageInfo );
         }
-        GetObjectManager().SetSkipObj( GetCurrScTab(), aPageInfo.mnObjId );
+        GetObjectManager().SetInvalidObj( GetCurrScTab(), aPageInfo.mnObjId );
     }
 }
 
Index: sc/source/filter/excel/xiroot.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xiroot.cxx,v
retrieving revision 1.15
retrieving revision 1.15.36.1
diff -u -p -u -p -r1.15 -r1.15.36.1
--- sc/source/filter/excel/xiroot.cxx	21 Feb 2005 13:33:30 -0000	1.15
+++ sc/source/filter/excel/xiroot.cxx	10 Aug 2005 14:41:41 -0000	1.15.36.1
@@ -138,6 +138,7 @@ XclImpRoot::XclImpRoot( XclImpRootData& 
     }
 
     mrImpData.mxPageSett.reset( new XclImpPageSettings( GetRoot() ) );
+    mrImpData.mxDocViewSett.reset( new XclImpDocViewSettings( GetRoot() ) );
     mrImpData.mxTabViewSett.reset( new XclImpTabViewSettings( GetRoot() ) );
 }
 
@@ -261,6 +262,11 @@ XclImpPageSettings& XclImpRoot::GetPageS
     return *mrImpData.mxPageSett;
 }
 
+XclImpDocViewSettings& XclImpRoot::GetDocViewSettings() const
+{
+    return *mrImpData.mxDocViewSett;
+}
+
 XclImpTabViewSettings& XclImpRoot::GetTabViewSettings() const
 {
     return *mrImpData.mxTabViewSett;
Index: sc/source/filter/excel/xistream.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xistream.cxx,v
retrieving revision 1.12
retrieving revision 1.12.4.1
diff -u -p -u -p -r1.12 -r1.12.4.1
--- sc/source/filter/excel/xistream.cxx	29 Mar 2005 13:40:08 -0000	1.12
+++ sc/source/filter/excel/xistream.cxx	9 Aug 2005 16:29:38 -0000	1.12.4.1
@@ -1079,9 +1079,7 @@ bool XclImpStream::IsContinueId( sal_uIn
 
 bool XclImpStream::JumpToNextContinue()
 {
-    mbValid = mbValid && (mbCont || IsContinueId( mnRecId ));
-    if( mbValid )
-        mbValid = ReadNextRawRecHeader() && IsContinueId( mnRawRecId );
+    mbValid = mbValid && mbCont && ReadNextRawRecHeader() && IsContinueId( mnRawRecId );
     if( mbValid )   // do not setup a following non-CONTINUE record
         SetupRawRecord();
     return mbValid;
Index: sc/source/filter/excel/xiview.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xiview.cxx,v
retrieving revision 1.2
retrieving revision 1.2.36.2
diff -u -p -u -p -r1.2 -r1.2.36.2
--- sc/source/filter/excel/xiview.cxx	21 Feb 2005 13:34:11 -0000	1.2
+++ sc/source/filter/excel/xiview.cxx	10 Aug 2005 14:41:41 -0000	1.2.36.2
@@ -83,6 +83,53 @@
 #include "xistyle.hxx"
 #endif
 
+// Document view settings =====================================================
+
+XclImpDocViewSettings::XclImpDocViewSettings( const XclImpRoot& rRoot ) :
+    XclImpRoot( rRoot )
+{
+}
+
+void XclImpDocViewSettings::ReadWindow1( XclImpStream& rStrm )
+{
+    rStrm   >> maData.mnWinX
+            >> maData.mnWinY
+            >> maData.mnWinWidth
+            >> maData.mnWinHeight
+            >> maData.mnFlags;
+    if( GetBiff() >= EXC_BIFF5 )
+    {
+        rStrm   >> maData.mnDisplXclTab
+                >> maData.mnFirstVisXclTab
+                >> maData.mnXclSelectCnt
+                >> maData.mnTabBarWidth;
+    }
+}
+
+SCTAB XclImpDocViewSettings::GetDisplScTab() const
+{
+    /*  Simply cast Excel index to Calc index.
+        TODO: This may fail if the document contains scenarios. */
+    sal_uInt16 nMaxXclTab = static_cast< sal_uInt16 >( GetMaxPos().Tab() );
+    return static_cast< SCTAB >( (maData.mnDisplXclTab <= nMaxXclTab) ? maData.mnDisplXclTab : 0 );
+}
+
+void XclImpDocViewSettings::Finalize()
+{
+    ScViewOptions aViewOpt( GetDoc().GetViewOptions() );
+    aViewOpt.SetOption( VOPT_HSCROLL,       ::get_flag( maData.mnFlags, EXC_WIN1_HOR_SCROLLBAR ) );
+    aViewOpt.SetOption( VOPT_VSCROLL,       ::get_flag( maData.mnFlags, EXC_WIN1_VER_SCROLLBAR ) );
+    aViewOpt.SetOption( VOPT_TABCONTROLS,   ::get_flag( maData.mnFlags, EXC_WIN1_TABBAR ) );
+    GetDoc().SetViewOptions( aViewOpt );
+
+    // displayed sheet
+    GetExtDocOptions().GetDocSettings().mnDisplTab = GetDisplScTab();
+
+    // width of the tabbar with sheet names
+    if( maData.mnTabBarWidth <= 1000 )
+        GetExtDocOptions().GetDocSettings().mfTabBarWidth = static_cast< double >( maData.mnTabBarWidth ) / 1000.0;
+}
+
 // Sheet view settings ========================================================
 
 namespace {
@@ -135,8 +182,12 @@ void XclImpTabViewSettings::ReadWindow2(
         {
             sal_uInt16 nGridColorIdx;
             rStrm >> nGridColorIdx;
-            rStrm.Ignore( 2 );
-            rStrm >> maData.mnPageZoom >> maData.mnNormalZoom;
+            // zoom data not included in chart sheets
+            if( rStrm.GetRecLeft() >= 6 )
+            {
+                rStrm.Ignore( 2 );
+                rStrm >> maData.mnPageZoom >> maData.mnNormalZoom;
+            }
 
             if( !maData.mbDefGridColor )
                 maData.maGridColor = GetPalette().GetColor( nGridColorIdx );
@@ -180,12 +231,13 @@ void XclImpTabViewSettings::Finalize()
     ScDocument& rDoc = GetDoc();
     XclImpAddressConverter& rAddrConv = GetAddressConverter();
     ScExtTabSettings& rTabSett = GetExtDocOptions().GetOrCreateTabSettings( nScTab );
+    bool bDisplayed = GetDocViewSettings().GetDisplScTab() == nScTab;
 
     // *** sheet options: cursor, selection, splits, zoom ***
 
     // sheet flags
     rDoc.SetLayoutRTL( nScTab, maData.mbMirrored );
-    rTabSett.mbSelected = maData.mbSelected || maData.mbDisplayed;
+    rTabSett.mbSelected = maData.mbSelected || bDisplayed;
 
     // first visible cell in top-left pane and in additional pane(s)
     rTabSett.maFirstVis = rAddrConv.CreateValidAddress( maData.maFirstXclPos, nScTab, false );
@@ -240,11 +292,8 @@ void XclImpTabViewSettings::Finalize()
 
     // *** additional handling for displayed sheet ***
 
-    if( maData.mbDisplayed )
+    if( bDisplayed )
     {
-        // displayed sheet
-        GetExtDocOptions().GetDocSettings().mnDisplTab = nScTab;
-
         // set Excel sheet settings globally at Calc document, take settings from displayed sheet
         ScViewOptions aViewOpt( rDoc.GetViewOptions() );
         aViewOpt.SetOption( VOPT_FORMULAS, maData.mbShowFormulas );
Index: sc/source/filter/excel/xladdress.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xladdress.cxx,v
retrieving revision 1.2
retrieving revision 1.2.36.1
diff -u -p -u -p -r1.2 -r1.2.36.1
--- sc/source/filter/excel/xladdress.cxx	21 Feb 2005 13:34:22 -0000	1.2
+++ sc/source/filter/excel/xladdress.cxx	9 Aug 2005 16:29:39 -0000	1.2.36.1
@@ -126,7 +126,7 @@ void XclRange::Write( XclExpStream& rStr
 
 XclRange XclRangeList::GetEnclosingRange() const
 {
-    XclRange aXclRange( ScAddress::UNINITIALIZED );
+    XclRange aXclRange;
     if( !empty() )
     {
         const_iterator aIt = begin(), aEnd = end();
Index: sc/source/filter/excel/xlchart.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xlchart.cxx,v
retrieving revision 1.2
retrieving revision 1.2.4.1
diff -u -p -u -p -r1.2 -r1.2.4.1
--- sc/source/filter/excel/xlchart.cxx	29 Mar 2005 13:40:20 -0000	1.2
+++ sc/source/filter/excel/xlchart.cxx	6 Jul 2005 15:43:31 -0000	1.2.4.1
@@ -85,6 +85,9 @@
 #include <com/sun/star/chart/ChartSymbolType.hpp>
 #endif
 
+#ifndef INCLUDED_RTL_MATH_HXX
+#include <rtl/math.hxx>
+#endif
 #ifndef _SFXITEMSET_HXX
 #include <svtools/itemset.hxx>
 #endif
@@ -120,6 +123,31 @@ typedef ::com::sun::star::drawing::LineD
 typedef ::com::sun::star::drawing::FillStyle    ApiFillStyle;
 typedef ::com::sun::star::drawing::BitmapMode   ApiBitmapMode;
 
+// Common =====================================================================
+
+XclChPoint::XclChPoint() :
+    mnSeriesIdx( EXC_CHSERIES_INVALID ),
+    mnPointIdx( EXC_CHDATAFORMAT_ALLPOINTS )
+{
+}
+
+XclChPoint::XclChPoint( sal_uInt16 nSeriesIdx, sal_uInt16 nPointIdx ) :
+    mnSeriesIdx( nSeriesIdx ),
+    mnPointIdx( nPointIdx )
+{
+}
+
+bool operator==( const XclChPoint& rL, const XclChPoint& rR )
+{
+    return (rL.mnSeriesIdx == rR.mnSeriesIdx) && (rL.mnPointIdx == rR.mnPointIdx);
+}
+
+bool operator<( const XclChPoint& rL, const XclChPoint& rR )
+{
+    return (rL.mnSeriesIdx < rR.mnSeriesIdx) ||
+        ((rL.mnSeriesIdx == rR.mnSeriesIdx) && (rL.mnPointIdx < rR.mnPointIdx));
+}
+
 // Formatting =================================================================
 
 XclChPos::XclChPos() :
@@ -190,9 +218,7 @@ XclChFrame::XclChFrame() :
 // Text =======================================================================
 
 XclChObjectLink::XclChObjectLink() :
-    mnTarget( EXC_CHOBJLINK_NONE ),
-    mnSeriesIdx( 0 ),
-    mnPointIdx( 0 )
+    mnTarget( EXC_CHOBJLINK_NONE )
 {
 }
 
@@ -222,8 +248,6 @@ XclChSourceLink::XclChSourceLink() :
 // ----------------------------------------------------------------------------
 
 XclChDataFormat::XclChDataFormat() :
-    mnPointIdx( 0 ),
-    mnSeriesIdx( 0 ),
     mnFormatIdx( EXC_CHDATAFORMAT_DEFAULT ),
     mnFlags( 0 )
 {
Index: sc/source/filter/excel/xlescher.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xlescher.cxx,v
retrieving revision 1.8
retrieving revision 1.8.4.2
diff -u -p -u -p -r1.8 -r1.8.4.2
--- sc/source/filter/excel/xlescher.cxx	29 Mar 2005 13:40:35 -0000	1.8
+++ sc/source/filter/excel/xlescher.cxx	9 Aug 2005 16:29:40 -0000	1.8.4.2
@@ -76,7 +76,9 @@
 
 using ::rtl::OUString;
 
-// Escher client anchor =======================================================
+// Structs and classes ========================================================
+
+// Escher client anchor -------------------------------------------------------
 
 namespace {
 
@@ -246,7 +248,79 @@ XclExpStream& operator<<( XclExpStream& 
         << rAnchor.maXclRange.maLast.mnRow  << rAnchor.mnBY;
 }
 
-// ============================================================================
+// ----------------------------------------------------------------------------
+
+XclObjId::XclObjId() :
+    mnScTab( SCTAB_INVALID ),
+    mnObjId( EXC_OBJ_INVALID_ID )
+{
+}
+
+XclObjId::XclObjId( SCTAB nScTab, sal_uInt16 nObjId ) :
+    mnScTab( nScTab ),
+    mnObjId( nObjId )
+{
+}
+
+bool operator==( const XclObjId& rL, const XclObjId& rR )
+{
+    return (rL.mnScTab == rR.mnScTab) && (rL.mnObjId == rR.mnObjId);
+}
+
+bool operator<( const XclObjId& rL, const XclObjId& rR )
+{
+    return (rL.mnScTab < rR.mnScTab) || ((rL.mnScTab == rR.mnScTab) && (rL.mnObjId < rR.mnObjId));
+}
+
+// ----------------------------------------------------------------------------
+
+XclTxoData::XclTxoData() :
+    mnFlags( 0 ),
+    mnOrient( EXC_TXO_TEXTROT_NONE ),
+    mnTextLen( 0 ),
+    mnFormatSize( 0 )
+{
+}
+
+sal_uInt8 XclTxoData::GetXclHorAlignment() const
+{
+    sal_uInt8 nXclAlign = 0;
+    ::extract_value( nXclAlign, mnFlags, 1, 3 );
+    return nXclAlign;
+}
+
+void XclTxoData::SetXclHorAlignment( sal_uInt8 nXclAlign )
+{
+    ::insert_value( mnFlags, nXclAlign, 1, 3 );
+}
+
+sal_uInt8 XclTxoData::GetXclVerAlignment() const
+{
+    sal_uInt8 nXclAlign = 0;
+    ::extract_value( nXclAlign, mnFlags, 4, 3 );
+    return nXclAlign;
+}
+
+void XclTxoData::SetXclVerAlignment( sal_uInt8 nXclAlign )
+{
+    ::insert_value( mnFlags, nXclAlign, 4, 3 );
+}
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclTxoData& rData )
+{
+    rStrm >> rData.mnFlags >> rData.mnOrient;
+    rStrm.Ignore( 6 );
+    return rStrm >> rData.mnTextLen >> rData.mnFormatSize;
+}
+
+XclExpStream& operator<<( XclExpStream& rStrm, const XclTxoData& rData )
+{
+    rStrm << rData.mnFlags << rData.mnOrient;
+    rStrm.WriteZeroBytes( 6 );
+    return rStrm << rData.mnTextLen << rData.mnFormatSize << sal_uInt32( 0 );
+}
+
+// ----------------------------------------------------------------------------
 
 OUString XclTbxControlHelper::GetServiceName( sal_uInt16 nCtrlType )
 {
@@ -354,8 +428,6 @@ OUString XclTbxControlHelper::GetScriptT
 
 OUString XclTbxControlHelper::GetScMacroName( const String& rXclMacroName )
 {
-    // TODO #i38718#: find missing module name
-//    DBG_ASSERT( rXclMacroName.Search( '.' ) != STRING_NOTFOUND, "XclTbxControlHelper::GetScMacroName - missing module name" );
     return CREATE_OUSTRING( EXC_TBX_MACRONAME_PRE ) + rXclMacroName + CREATE_OUSTRING( EXC_TBX_MACRONAME_SUF );
 }
 
Index: sc/source/filter/excel/xlformula.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xlformula.cxx,v
retrieving revision 1.8
retrieving revision 1.8.36.1
diff -u -p -u -p -r1.8 -r1.8.36.1
--- sc/source/filter/excel/xlformula.cxx	21 Feb 2005 13:34:35 -0000	1.8
+++ sc/source/filter/excel/xlformula.cxx	19 Apr 2005 14:47:16 -0000	1.8.36.1
@@ -443,6 +443,15 @@ XclTokenArrayIterator::XclTokenArrayIter
     Init( rScTokArr, bSkipSpaces );
 }
 
+XclTokenArrayIterator::XclTokenArrayIterator( const XclTokenArrayIterator& rTokArrIt, bool bSkipSpaces ) :
+    mppScTokenBeg( rTokArrIt.mppScTokenBeg ),
+    mppScTokenEnd( rTokArrIt.mppScTokenEnd ),
+    mppScToken( rTokArrIt.mppScToken ),
+    mbSkipSpaces( bSkipSpaces )
+{
+    SkipSpaces();
+}
+
 void XclTokenArrayIterator::Init()
 {
     mppScTokenBeg = mppScTokenEnd = mppScToken = 0;
Index: sc/source/filter/excel/xlocx.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xlocx.cxx,v
retrieving revision 1.14
retrieving revision 1.14.4.1
diff -u -p -u -p -r1.14 -r1.14.4.1
--- sc/source/filter/excel/xlocx.cxx	29 Mar 2005 13:40:51 -0000	1.14
+++ sc/source/filter/excel/xlocx.cxx	9 Aug 2005 16:29:40 -0000	1.14.4.1
@@ -234,16 +234,16 @@ XclImpOcxConverter::XclImpOcxConverter( 
     mxStrm = OpenStream( EXC_STREAM_CTLS );
 }
 
-bool XclImpOcxConverter::CreateSdrUnoObj( XclImpEscherOle& rOcxCtrl )
+SdrObject* XclImpOcxConverter::CreateSdrObject( const XclImpOleObj& rOcxCtrlObj, const Rectangle& rAnchorRect )
 {
-    DBG_ASSERT( rOcxCtrl.IsControl(), "XclOcxConverter::CreateSdrUnoObj - no control object" );
-    if( mxStrm.Is() && rOcxCtrl.IsControl() )
+    DBG_ASSERT( rOcxCtrlObj.IsControl(), "XclOcxConverter::CreateSdrObject - no control object" );
+    if( mxStrm.Is() && rOcxCtrlObj.IsControl() )
     {
         // virtual call of GetDrawPage() needs current sheet index
-        SetScTab( rOcxCtrl.GetScTab() );
+        SetScTab( rOcxCtrlObj.GetScTab() );
 
         // stream position of the extra data for this control
-        sal_uInt32 nStrmPos = rOcxCtrl.GetCtrlStreamPos();
+        sal_uInt32 nStrmPos = rOcxCtrlObj.GetCtrlStreamPos();
         mxStrm->Seek( static_cast< ULONG >( nStrmPos ) );
 
         // the shape to fill
@@ -257,12 +257,12 @@ bool XclImpOcxConverter::CreateSdrUnoObj
         }
         catch( Exception& )
         {
-            DBG_ERRORFILE( "XclImpOcxConverter::CreateSdrUnoObj - unexpected exception caught" );
+            DBG_ERRORFILE( "XclImpOcxConverter::CreateSdrObject - unexpected exception caught" );
         }
 
         if( bReadSuccess )
         {
-            if( SdrObject* pSdrObj = ::GetSdrObjectFromXShape( xShape ) )
+            if( SdrObject* pSdrObj = GetSdrObject( xShape, rAnchorRect ) )
             {
                 Reference< XControlShape > xControlShape( xShape, UNO_QUERY );
                 if( xControlShape.is() )
@@ -271,62 +271,57 @@ bool XclImpOcxConverter::CreateSdrUnoObj
                     if( xModel.is() )
                     {
                         // set the spreadsheet links
-                        ConvertSheetLinks( xModel, rOcxCtrl );
+                        ConvertSheetLinks( xModel, rOcxCtrlObj );
                         // set additional control properties
                         ScfPropertySet aPropSet( xModel );
                         if( aPropSet.Is() )
-                            rOcxCtrl.WriteToPropertySet( aPropSet );
+                            rOcxCtrlObj.WriteToPropertySet( aPropSet );
                     }
                 }
-
-                rOcxCtrl.SetSdrObj( pSdrObj );
-                return true;
+                return pSdrObj;
             }
         }
     }
-    return false;
+    return 0;
 }
 
-bool XclImpOcxConverter::CreateSdrUnoObj( XclImpEscherTbxCtrl& rTbxCtrl )
+SdrObject* XclImpOcxConverter::CreateSdrObject( const XclImpTbxControlObj& rTbxCtrlObj, const Rectangle& rAnchorRect )
 {
     // virtual call of GetDrawPage() needs current sheet index
-    SetScTab( rTbxCtrl.GetScTab() );
+    SetScTab( rTbxCtrlObj.GetScTab() );
 
     const Reference< XMultiServiceFactory >& rxServiceFactory = GetServiceFactory();
     if( rxServiceFactory.is() )
     {
-        Reference< XInterface > xInt( rxServiceFactory->createInstance( rTbxCtrl.GetServiceName() ) );
+        Reference< XInterface > xInt( rxServiceFactory->createInstance( rTbxCtrlObj.GetServiceName() ) );
         Reference< XFormComponent > xFormComp( xInt, UNO_QUERY );
         Reference< XControlModel > xModel( xInt, UNO_QUERY );
         if( xFormComp.is() && xModel.is() )
         {
             // the shape to fill
             Reference< XShape > xShape;
-            // dummy size -> is done in XclImpEscherTbxCtrl::Apply
+            // dummy size
             ::com::sun::star::awt::Size aSize;
 
             // try to insert the control into the form
             if( InsertControl( xFormComp, aSize, &xShape, TRUE ) )
             {
-                if( SdrObject* pSdrObj = ::GetSdrObjectFromXShape( xShape ) )
+                if( SdrObject* pSdrObj = GetSdrObject( xShape, rAnchorRect ) )
                 {
-                    // store the created SdrObject in the object
-                    rTbxCtrl.SetSdrObj( pSdrObj );
                     // set the links to the spreadsheet
-                    ConvertSheetLinks( xModel, rTbxCtrl );
+                    ConvertSheetLinks( xModel, rTbxCtrlObj );
                     // set the control properties
                     ScfPropertySet aPropSet( xModel );
                     if( aPropSet.Is() )
-                        rTbxCtrl.WriteToPropertySet( aPropSet );
+                        rTbxCtrlObj.WriteToPropertySet( aPropSet );
                     // try to attach a macro to the control
-                    RegisterTbxMacro( rTbxCtrl );
-
-                    return true;
+                    RegisterTbxMacro( rTbxCtrlObj );
+                    return pSdrObj;
                 }
             }
         }
     }
-    return false;
+    return 0;
 }
 
 sal_Bool XclImpOcxConverter::InsertControl(
@@ -351,7 +346,6 @@ sal_Bool XclImpOcxConverter::InsertContr
             CREATE_OUSTRING( "com.sun.star.drawing.ControlShape" ) ), UNO_QUERY );
         if( xShape.is() )
         {
-            xShape->setSize( rSize );
             // set control model at the shape
             Reference< XControlShape > xControlShape( xShape, UNO_QUERY );
             Reference< XControlModel > xControlModel( rxFormComp, UNO_QUERY );
@@ -368,6 +362,18 @@ sal_Bool XclImpOcxConverter::InsertContr
     return bRet;
 }
 
+SdrObject* XclImpOcxConverter::GetSdrObject( const Reference< XShape >& rxShape, const Rectangle& rAnchorRect ) const
+{
+    SdrObject* pSdrObj = ::GetSdrObjectFromXShape( rxShape );
+    if( pSdrObj )
+    {
+        pSdrObj->NbcSetSnapRect( rAnchorRect );
+        // #i30543# insert into control layer
+        pSdrObj->NbcSetLayer( SC_LAYER_CONTROLS );
+    }
+    return pSdrObj;
+}
+
 void XclImpOcxConverter::ConvertSheetLinks(
         const Reference< XControlModel >& rxModel, const XclImpCtrlLinkHelper& rControl ) const
 {
@@ -453,10 +459,10 @@ void XclImpOcxConverter::ConvertSheetLin
     }
 }
 
-void XclImpOcxConverter::RegisterTbxMacro( XclImpEscherTbxCtrl& rTbxCtrl )
+void XclImpOcxConverter::RegisterTbxMacro( const XclImpTbxControlObj& rTbxCtrlObj )
 {
     ScriptEventDescriptor aEvent;
-    if( (mnLastIndex >= 0) && rTbxCtrl.FillMacroDescriptor( aEvent ) )
+    if( (mnLastIndex >= 0) && rTbxCtrlObj.FillMacroDescriptor( aEvent ) )
     {
         Reference< XEventAttacherManager > xEventMgr( GetFormComps(), UNO_QUERY );
         if( xEventMgr.is() )
@@ -597,7 +603,7 @@ void XclExpOcxConverter::ConvertSheetLin
 #if !EXC_EXP_OCX_CTRL
 
 void XclExpOcxConverter::ConvertTbxMacro(
-    XclExpObjTbxCtrl& rTbxCtrl, const Reference< XControlModel >& rxModel )
+    XclExpObjTbxCtrl& rTbxCtrlObj, const Reference< XControlModel >& rxModel )
 {
     // *** 1) try to find the index of the processed control in the form ***
 
@@ -648,7 +654,7 @@ void XclExpOcxConverter::ConvertTbxMacro
                     !bFound && (nEventIdx < nEventCount); ++nEventIdx )
             {
                 // try to set the event data at the Excel control object, returns true on success
-                bFound = rTbxCtrl.SetMacroLink( aEventSeq[ nEventIdx ] );
+                bFound = rTbxCtrlObj.SetMacroLink( aEventSeq[ nEventIdx ] );
             }
         }
     }
Index: sc/source/filter/excel/xlroot.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xlroot.cxx,v
retrieving revision 1.22
retrieving revision 1.21.36.2
diff -u -p -u -p -r1.22 -r1.21.36.2
--- sc/source/filter/excel/xlroot.cxx	28 Jun 2005 15:28:53 -0000	1.22
+++ sc/source/filter/excel/xlroot.cxx	14 Jun 2005 13:50:52 -0000	1.21.36.2
@@ -63,12 +63,19 @@
 #include "xlroot.hxx"
 #endif
 
+#ifndef _COM_SUN_STAR_I18N_SCRIPTTYPE_HPP_
+#include <com/sun/star/i18n/ScriptType.hpp>
+#endif
+
 #ifndef _SV_SVAPP_HXX
 #include <vcl/svapp.hxx>
 #endif
 #ifndef _SFXSTRITEM_HXX
 #include <svtools/stritem.hxx>
 #endif
+#ifndef _SVTOOLS_LANGUAGEOPTIONS_HXX
+#include <svtools/languageoptions.hxx>
+#endif
 #ifndef _SFX_OBJSH_HXX
 #include <sfx2/objsh.hxx>
 #endif
@@ -131,6 +138,8 @@
 
 namespace com { namespace sun { namespace star { namespace frame { class XModel; } } } }
 
+namespace ApiScriptType = ::com::sun::star::i18n::ScriptType;
+
 using ::rtl::OUString;
 using ::com::sun::star::uno::Reference;
 using ::com::sun::star::frame::XModel;
@@ -158,6 +167,7 @@ XclRootData::XclRootData( XclBiff eBiff,
     meSysLang( Application::GetSettings().GetLanguage() ),
     meDocLang( Application::GetSettings().GetLanguage() ),
     meUILang( Application::GetSettings().GetUILanguage() ),
+    mnDefApiScript( ApiScriptType::LATIN ),
     maScMaxPos( MAXCOL, MAXROW, MAXTAB ),
     maXclMaxPos( EXC_MAXCOL2, EXC_MAXROW2, EXC_MAXTAB2 ),
     maMaxPos( EXC_MAXCOL2, EXC_MAXROW2, EXC_MAXTAB2 ),
@@ -167,6 +177,15 @@ XclRootData::XclRootData( XclBiff eBiff,
     mbHasPassw( false ),
     mxRD( new RootData )//!
 {
+    // default script type, e.g. for empty cells
+    switch( ScGlobal::GetDefaultScriptType() )
+    {
+        case SCRIPTTYPE_LATIN:      mnDefApiScript = ApiScriptType::LATIN;      break;
+        case SCRIPTTYPE_ASIAN:      mnDefApiScript = ApiScriptType::ASIAN;      break;
+        case SCRIPTTYPE_COMPLEX:    mnDefApiScript = ApiScriptType::COMPLEX;    break;
+        default:    DBG_ERRORFILE( "XclRootData::XclRootData - unknown script type" );
+    }
+
     // maximum cell position
     switch( meBiff )
     {
Index: sc/source/filter/excel/xltools.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xltools.cxx,v
retrieving revision 1.22
retrieving revision 1.22.4.1
diff -u -p -u -p -r1.22 -r1.22.4.1
--- sc/source/filter/excel/xltools.cxx	29 Mar 2005 13:41:24 -0000	1.22
+++ sc/source/filter/excel/xltools.cxx	17 Jun 2005 10:02:35 -0000	1.22.4.1
@@ -223,7 +223,7 @@ sal_uInt8 XclTools::GetXclErrorCode( USH
     switch( nScError )
     {
         case errIllegalArgument:        return EXC_ERR_VALUE;
-        case errIllegalFPOperation:     return EXC_ERR_DIV0;    // maybe DIV/0 or NUM...
+        case errIllegalFPOperation:     return EXC_ERR_NUM;     // maybe DIV/0 or NUM...
         case errIllegalParameter:       return EXC_ERR_VALUE;
         case errPairExpected:           return EXC_ERR_VALUE;
         case errOperatorExpected:       return EXC_ERR_VALUE;
Index: sc/source/filter/excel/xlview.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xlview.cxx,v
retrieving revision 1.2
retrieving revision 1.2.36.1
diff -u -p -u -p -r1.2 -r1.2.36.1
--- sc/source/filter/excel/xlview.cxx	21 Feb 2005 13:35:52 -0000	1.2
+++ sc/source/filter/excel/xlview.cxx	10 Aug 2005 14:41:42 -0000	1.2.36.1
@@ -67,7 +67,22 @@
 #include "ftools.hxx"
 #endif
 
-// View settings ==============================================================
+// Structs ====================================================================
+
+XclDocViewData::XclDocViewData() :
+    mnWinX( 0 ),
+    mnWinY( 0 ),
+    mnWinWidth( 0 ),
+    mnWinHeight( 0 ),
+    mnFlags( 0 ),
+    mnDisplXclTab( 0 ),
+    mnFirstVisXclTab( 0 ),
+    mnXclSelectCnt( 0 ),
+    mnTabBarWidth( 0 )
+{
+}
+
+// ----------------------------------------------------------------------------
 
 XclTabViewData::XclTabViewData() :
     maFirstXclPos( ScAddress::UNINITIALIZED ),
Index: sc/source/filter/ftools/fprogressbar.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/ftools/fprogressbar.cxx,v
retrieving revision 1.4
retrieving revision 1.4.222.1
diff -u -p -u -p -r1.4 -r1.4.222.1
--- sc/source/filter/ftools/fprogressbar.cxx	8 Sep 2004 15:40:45 -0000	1.4
+++ sc/source/filter/ftools/fprogressbar.cxx	9 Aug 2005 16:30:08 -0000	1.4.222.1
@@ -168,7 +168,7 @@ void ScfProgressBar::IncreaseProgressBar
         // calculate new position of parent progress bar
         sal_uInt32 nParentPos = static_cast< sal_uInt32 >(
             static_cast< double >( nNewPos ) * mpParentSegment->mnSize / mnTotalSize );
-        mpParentProgress->Progress( nParentPos );
+        mpParentProgress->ProgressAbs( nParentPos );
     }
     // modify system progress bar
     else if( mxSysProgress.get() )
@@ -222,7 +222,7 @@ void ScfProgressBar::ActivateSegment( sa
         SetCurrSegment( GetSegment( nSegment ) );
 }
 
-void ScfProgressBar::Progress( sal_uInt32 nPos )
+void ScfProgressBar::ProgressAbs( sal_uInt32 nPos )
 {
     DBG_ASSERT( mbInProgress && mpCurrSegment, "ScfProgressBar::Progress - no segment started" );
     if( mpCurrSegment )
@@ -237,9 +237,9 @@ void ScfProgressBar::Progress( sal_uInt3
     }
 }
 
-void ScfProgressBar::Progress()
+void ScfProgressBar::Progress( sal_uInt32 nDelta )
 {
-    Progress( mpCurrSegment ? (mpCurrSegment->mnPos + 1) : 0 );
+    ProgressAbs( mpCurrSegment ? (mpCurrSegment->mnPos + nDelta) : 0 );
 }
 
 // ============================================================================
@@ -279,7 +279,7 @@ ScfStreamProgressBar::ScfStreamProgressB
 
 void ScfStreamProgressBar::Progress()
 {
-    mxProgress->Progress( mrStrm.Tell() );
+    mxProgress->ProgressAbs( mrStrm.Tell() );
 }
 
 void ScfStreamProgressBar::Init( SfxObjectShell* pDocShell, const String& rText )
Index: sc/source/filter/ftools/ftools.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/ftools/ftools.cxx,v
retrieving revision 1.11
retrieving revision 1.11.196.2
diff -u -p -u -p -r1.11 -r1.11.196.2
--- sc/source/filter/ftools/ftools.cxx	18 Oct 2004 15:17:23 -0000	1.11
+++ sc/source/filter/ftools/ftools.cxx	10 May 2005 16:42:01 -0000	1.11.196.2
@@ -86,6 +86,9 @@
 #ifndef SC_SCGLOB_HXX
 #include "global.hxx"
 #endif
+#ifndef SC_DOCUMENT_HXX
+#include "document.hxx"
+#endif
 #ifndef SC_STLPOOL_HXX
 #include "stlpool.hxx"
 #endif
@@ -211,13 +214,7 @@ Color ScfTools::GetMixedColor( const Col
 
 void ScfTools::ConvertToScSheetName( String& rName )
 {
-    for( xub_StrLen nPos = 0, nLen = rName.Len(); nPos < nLen; ++nPos )
-    {
-        sal_Unicode cChar = rName.GetChar( nPos );
-        bool bSpace = (cChar == ' ');
-        if( (!ScGlobal::pCharClass->isLetterNumeric( rName, nPos ) && !bSpace) || (!nPos && bSpace) )
-            rName.SetChar( nPos, '_' );
-    }
+    ScDocument::ConvertToValidTabName( rName, '_' );
 }
 
 void ScfTools::ConvertToScDefinedName( String& rName )
Index: sc/source/filter/html/htmlpars.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/html/htmlpars.cxx,v
retrieving revision 1.24
retrieving revision 1.24.34.1
diff -u -p -u -p -r1.24 -r1.24.34.1
--- sc/source/filter/html/htmlpars.cxx	21 Feb 2005 13:36:40 -0000	1.24
+++ sc/source/filter/html/htmlpars.cxx	5 Aug 2005 13:22:08 -0000	1.24.34.1
@@ -59,14 +59,6 @@
  *
  ************************************************************************/
 
-#ifdef PCH
-#include "filt_pch.hxx"
-#endif
-
-#pragma hdrstop
-
-//------------------------------------------------------------------------
-
 #include <boost/shared_ptr.hpp>
 
 #define SC_HTMLPARS_CXX
@@ -158,6 +150,7 @@ ScHTMLLayoutParser::ScHTMLLayoutParser( 
         nColOffset(0),
         nColOffsetStart(0),
         nMetaCnt(0),
+        nOffsetTolerance( SC_HTML_OFFSET_TOLERANCE_SMALL ),
         bTabInTabCell( FALSE ),
         bFirstRow( TRUE ),
         bInCell( FALSE ),
@@ -511,7 +504,7 @@ void ScHTMLLayoutParser::Adjust()
             }
         }
         // echte Col
-        SeekOffset( pColOffset, pE->nOffset, &pE->nCol );
+        SeekOffset( pColOffset, pE->nOffset, &pE->nCol, nOffsetTolerance );
         SCCOL nColBeforeSkip = pE->nCol;
         SkipLocked( pE, FALSE );
         if ( pE->nCol != nColBeforeSkip )
@@ -520,7 +513,7 @@ void ScHTMLLayoutParser::Adjust()
             if ( nCount <= pE->nCol )
             {
                 pE->nOffset = (USHORT) (*pColOffset)[nCount-1];
-                MakeCol( pColOffset, pE->nOffset, pE->nWidth );
+                MakeCol( pColOffset, pE->nOffset, pE->nWidth, nOffsetTolerance, nOffsetTolerance );
             }
             else
             {
@@ -528,7 +521,7 @@ void ScHTMLLayoutParser::Adjust()
             }
         }
         SCCOL nPos;
-        if ( pE->nWidth && SeekOffset( pColOffset, pE->nOffset + pE->nWidth, &nPos ) )
+        if ( pE->nWidth && SeekOffset( pColOffset, pE->nOffset + pE->nWidth, &nPos, nOffsetTolerance ) )
             pE->nColOverlap = (nPos > pE->nCol ? nPos - pE->nCol : 1);
         else
         {
@@ -714,7 +707,7 @@ void ScHTMLLayoutParser::SetWidths()
                 pE->nWidth = GetWidth( pE );
                 DBG_ASSERT( pE->nWidth, "SetWidths: pE->nWidth == 0" );
             }
-            MakeCol( pColOffset, pE->nOffset, pE->nWidth );
+            MakeCol( pColOffset, pE->nOffset, pE->nWidth, nOffsetTolerance, nOffsetTolerance );
         }
         pE = pList->Next();
     }
@@ -737,7 +730,7 @@ void ScHTMLLayoutParser::Colonize( ScEEP
     }
     pE->nOffset = nColOffset;
     USHORT nWidth = GetWidth( pE );
-    MakeCol( pLocalColOffset, pE->nOffset, nWidth );
+    MakeCol( pLocalColOffset, pE->nOffset, nWidth, nOffsetTolerance, nOffsetTolerance );
     if ( pE->nWidth )
         pE->nWidth = nWidth;
     nColOffset = pE->nOffset + nWidth;
@@ -1157,6 +1150,9 @@ void ScHTMLLayoutParser::TableOn( Import
             nColCnt, nRowCnt, nColCntStart, nMaxCol, nTable,
             nTableWidth, nColOffset, nColOffsetStart,
             bFirstRow ) );
+        // As soon as we have multiple tables we need to be tolerant with the offsets.
+        if (nMaxTable > 0)
+            nOffsetTolerance = SC_HTML_OFFSET_TOLERANCE_LARGE;
         nTableWidth = 0;
         if ( pInfo->nToken == HTML_TABLE_ON )
         {   // es kann auch TD oder TH sein, wenn es vorher kein TABLE gab
@@ -1211,7 +1207,6 @@ void ScHTMLLayoutParser::TableOff( Impor
             SCROW nRows = nRowCnt - pS->nRowCnt;
             if ( nRows > 1 )
             {   // Groesse der Tabelle an dieser Position eintragen
-                SCCOL nCol = nColCntStart;
                 SCROW nRow = pS->nRowCnt;
                 USHORT nTab = pS->nTable;
                 if ( !pTables )
@@ -1306,7 +1301,7 @@ void ScHTMLLayoutParser::TableOff( Impor
             {
                 USHORT nOldOffset = pE->nOffset + pE->nWidth;
                 USHORT nNewOffset = pE->nOffset + nTableWidth;
-                ModifyOffset( pS->pLocalColOffset, nOldOffset, nNewOffset );
+                ModifyOffset( pS->pLocalColOffset, nOldOffset, nNewOffset, nOffsetTolerance );
                 USHORT nTmp = nNewOffset - pE->nOffset - pE->nWidth;
                 pE->nWidth = nNewOffset - pE->nOffset;
                 pS->nTableWidth += nTmp;
Index: sc/source/filter/inc/biffdump.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/biffdump.hxx,v
retrieving revision 1.15
retrieving revision 1.15.108.2
diff -u -p -u -p -r1.15 -r1.15.108.2
--- sc/source/filter/inc/biffdump.hxx	23 Dec 2004 10:46:28 -0000	1.15
+++ sc/source/filter/inc/biffdump.hxx	9 Aug 2005 16:29:53 -0000	1.15.108.2
@@ -205,7 +205,9 @@ protected:
 	UINT32						nFieldCnt;
 	UINT32						nItemCnt;
 	UINT32						nTabIndexCnt;
+    sal_uInt32                  mnEscherPos;
 	UINT16						nFontIndex;
+    sal_uInt16                  mnSubstream;
 
 	static const UINT16			nRecCnt;
 	UINT16*						pDumpModes;
@@ -234,7 +236,7 @@ protected:
 	UINT16						DumpXF( XclImpStream& rIn, const sal_Char* pPre );
 	void						DumpValidPassword( XclImpStream& rIn, const sal_Char* pPre );
 	void						RecDump( BOOL bSubStream = FALSE );
-	void						EscherDump( const ULONG nL );
+    void                        EscherDump( const ULONG nL, bool bDumpOffset );
 	void						ObjDump( const ULONG nL );
 	void						ContDump( const ULONG nL );
 	void						ContDumpStream( SvStream& rStrm, const ULONG nL );
Index: sc/source/filter/inc/eeparser.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/eeparser.hxx,v
retrieving revision 1.4
retrieving revision 1.4.88.1
diff -u -p -u -p -r1.4 -r1.4.88.1
--- sc/source/filter/inc/eeparser.hxx	11 Jan 2005 13:17:58 -0000	1.4
+++ sc/source/filter/inc/eeparser.hxx	5 Aug 2005 13:20:16 -0000	1.4.88.1
@@ -97,8 +97,8 @@ struct ScHTMLImage
 	sal_Char			nDir;			// 1==hori, 2==verti, 3==beides
 
 						ScHTMLImage() :
-							pGraphic( NULL ),
-							aSize( 0, 0 ), aSpace( 0, 0 ), nDir( nHorizontal )
+                            aSize( 0, 0 ), aSpace( 0, 0 ), pGraphic( NULL ),
+                            nDir( nHorizontal )
 							{}
 						~ScHTMLImage()
 							{ if ( pGraphic ) delete pGraphic; }
Index: sc/source/filter/inc/excform.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/excform.hxx,v
retrieving revision 1.13
retrieving revision 1.13.36.1
diff -u -p -u -p -r1.13 -r1.13.36.1
--- sc/source/filter/inc/excform.hxx	21 Feb 2005 13:38:48 -0000	1.13
+++ sc/source/filter/inc/excform.hxx	20 Jun 2005 13:12:40 -0000	1.13.36.1
@@ -93,6 +93,8 @@ protected:
 
 	void				ExcRelToScRel( UINT16 nRow, UINT8 nCol, SingleRefData&, const BOOL bName );
 
+    void                PushRangeOperator();
+
 public:
                         ExcelToSc( XclImpStream& rStrm );
 	virtual				~ExcelToSc();
Index: sc/source/filter/inc/excimp8.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/excimp8.hxx,v
retrieving revision 1.60
retrieving revision 1.60.4.1
diff -u -p -u -p -r1.60 -r1.60.4.1
--- sc/source/filter/inc/excimp8.hxx	29 Mar 2005 13:43:11 -0000	1.60
+++ sc/source/filter/inc/excimp8.hxx	6 Jun 2005 15:07:18 -0000	1.60.4.1
@@ -103,6 +103,7 @@ class ImportExcel8 : public ImportExcel
 
 		void					RecString( void );				// 0x07
 		void					Calccount( void );				// 0x0C
+        void                    Precision( void );              // 0x0E
 		void					Delta( void );					// 0x10
 		void					Iteration( void );				// 0x11
 		void					Note( void );					// 0x1C
Index: sc/source/filter/inc/fprogressbar.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/fprogressbar.hxx,v
retrieving revision 1.4
retrieving revision 1.4.222.1
diff -u -p -u -p -r1.4 -r1.4.222.1
--- sc/source/filter/inc/fprogressbar.hxx	8 Sep 2004 15:43:00 -0000	1.4
+++ sc/source/filter/inc/fprogressbar.hxx	9 Aug 2005 16:29:54 -0000	1.4.222.1
@@ -108,7 +108,7 @@ const sal_Int32 SCF_INV_SEGMENT = -1;
 
         aProgress.ActivateSegment( nSeg );                  // start segment nSeg
         aProgress.Progress();                               // 0->1; display: 2%
-        aProgress.Progress( 9 );                            // 1->9; display: 18%
+        aProgress.ProgressAbs( 9 );                         // 1->9; display: 18%
 
     Example 2: Progress bar with 2 segments.
 
@@ -119,7 +119,7 @@ const sal_Int32 SCF_INV_SEGMENT = -1;
 
         aProgress.ActivateSegment( nSeg1 );                 // start first segment
         aProgress.Progress();                               // 0->1, display: 1%
-        aProgress.Progress( 3 );                            // 1->3, display: 3%
+        aProgress.Progress( 2 );                            // 1->3, display: 3%
         aProgress.ActivateSegment( nSeg2 );                 // start second segment
         aProgress.Progress( 5 );                            // 0->5, display: 8% (5+3 steps)
         aProgress.ActivateSegment( nSeg1 );                 // continue with first segment
@@ -171,10 +171,10 @@ public:
     void                ActivateSegment( sal_Int32 nSegment );
     /** Starts the progress bar (with first segment). */
     inline void         Activate() { ActivateSegment( 0 ); }
-    /** Set current segment to the specified position. */
-    void                Progress( sal_uInt32 nPos );
-    /** Increase current segment by 1. */
-    void                Progress();
+    /** Set current segment to the specified absolute position. */
+    void                ProgressAbs( sal_uInt32 nPos );
+    /** Increase current segment by the passed value. */
+    void                Progress( sal_uInt32 nDelta = 1 );
 
 private:
     struct ScfProgressSegment;
@@ -238,9 +238,9 @@ public:
     explicit            ScfSimpleProgressBar( sal_uInt32 nSize, SfxObjectShell* pDocShell, USHORT nResId );
 
     /** Set progress bar to the specified position. */
-    inline void         Progress( sal_uInt32 nPos ) { maProgress.Progress( nPos ); }
+    inline void         ProgressAbs( sal_uInt32 nPos ) { maProgress.ProgressAbs( nPos ); }
     /** Increase progress bar by 1. */
-    inline void         Progress() { maProgress.Progress(); }
+    inline void         Progress( sal_uInt32 nDelta = 1 ) { maProgress.Progress( nDelta ); }
 
 private:
     /** Initializes and starts the progress bar. */
Index: sc/source/filter/inc/htmlpars.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/htmlpars.hxx,v
retrieving revision 1.11
retrieving revision 1.11.88.1
diff -u -p -u -p -r1.11 -r1.11.88.1
--- sc/source/filter/inc/htmlpars.hxx	11 Jan 2005 13:18:25 -0000	1.11
+++ sc/source/filter/inc/htmlpars.hxx	5 Aug 2005 13:22:10 -0000	1.11.88.1
@@ -75,7 +75,10 @@
 #include "eeparser.hxx"
 
 const sal_uInt32 SC_HTML_FONTSIZES = 7;        // wie Export, HTML-Options
-#define SC_HTML_OFFSET_TOL 10	// Pixeltoleranz fuer SeekOffset
+
+// Pixel tolerance for SeekOffset and related.
+const USHORT SC_HTML_OFFSET_TOLERANCE_SMALL = 1;    // single table
+const USHORT SC_HTML_OFFSET_TOLERANCE_LARGE = 10;   // nested
 
 // ============================================================================
 // BASE class for HTML parser classes
@@ -127,7 +130,7 @@ struct ScHTMLTableStackEntry
 								SCCOL nStart, SCCOL nMax, USHORT nTab,
 								USHORT nTW, USHORT nCO, USHORT nCOS,
 								BOOL bFR )
-							: pCellEntry( pE ), xLockedList( rL ),
+							: xLockedList( rL ), pCellEntry( pE ),
 							pLocalColOffset( pTO ),
 							nFirstTableCell( nFTC ),
 							nColCnt( nCol ), nRowCnt( nRow ),
@@ -181,6 +184,7 @@ private:
 	USHORT				nColOffset;			// aktuell, Pixel
 	USHORT				nColOffsetStart;	// Startwert je Table, in Pixel
 	USHORT				nMetaCnt;			// fuer ParseMetaOptions
+    USHORT              nOffsetTolerance;   // for use with SeekOffset and related
 	BOOL				bCalcWidthHeight;	// TRUE: calculate real column width
 											// FALSE: 1 html-col = 1 sc-col
 	BOOL				bTabInTabCell;
@@ -196,19 +200,15 @@ private:
 	void				NextRow(  ImportInfo*  );
 	void				SkipLocked( ScEEParseEntry*, BOOL bJoin = TRUE );
 	static BOOL 		SeekOffset( ScHTMLColOffset*, USHORT nOffset,
-									SCCOL* pCol,
-									USHORT nOffsetTol = SC_HTML_OFFSET_TOL );
+									SCCOL* pCol, USHORT nOffsetTol );
 	static void			MakeCol( ScHTMLColOffset*, USHORT& nOffset,
-								USHORT& nWidth,
-								USHORT nOffsetTol = SC_HTML_OFFSET_TOL,
-								USHORT nWidthTol = SC_HTML_OFFSET_TOL );
+								USHORT& nWidth, USHORT nOffsetTol,
+                                USHORT nWidthTol );
 	static void			MakeColNoRef( ScHTMLColOffset*, USHORT nOffset,
-								USHORT nWidth,
-								USHORT nOffsetTol = SC_HTML_OFFSET_TOL,
-								USHORT nWidthTol = SC_HTML_OFFSET_TOL );
+								USHORT nWidth, USHORT nOffsetTol,
+                                USHORT nWidthTol );
 	static void 		ModifyOffset( ScHTMLColOffset*, USHORT& nOldOffset,
-									USHORT& nNewOffset,
-									USHORT nOffsetTol = SC_HTML_OFFSET_TOL );
+									USHORT& nNewOffset, USHORT nOffsetTol );
 	void				Colonize( ScEEParseEntry* );
 	USHORT				GetWidth( ScEEParseEntry* );
 	void				SetWidths();
Index: sc/source/filter/inc/namebuff.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/namebuff.hxx,v
retrieving revision 1.9
retrieving revision 1.9.150.1
diff -u -p -u -p -r1.9 -r1.9.150.1
--- sc/source/filter/inc/namebuff.hxx	9 Nov 2004 15:06:47 -0000	1.9
+++ sc/source/filter/inc/namebuff.hxx	7 Jun 2005 18:52:33 -0000	1.9.150.1
@@ -78,6 +78,8 @@
 #endif
 
 #include "rangenam.hxx"
+#include <hash_map>
+#include <list>
 
 class ScDocument;
 class ScTokenArray;
@@ -212,15 +214,24 @@ inline void NameBuffer::SetBase( UINT16 
 
 
 
-class ShrfmlaBuffer : private List, public ExcRoot
+class ShrfmlaBuffer : public ExcRoot
 {
-private:
-	UINT16					nBase;			// Startwert Indizierung
+	struct ScAddressHashFunc : public std::unary_function< const ScAddress &, size_t >
+	{
+		size_t operator() (const ScAddress &addr) const;
+	};
+	typedef	std::hash_map <ScAddress, UINT16, ScAddressHashFunc> ShrfmlaHash;
+	typedef	std::list <ScRange>									 ShrfmlaList;
+
+	ShrfmlaHash	 index_hash;
+	ShrfmlaList	 index_list;
+	unsigned int cur_index;
+
 public:
 							ShrfmlaBuffer( RootData* pRD );
 	virtual					~ShrfmlaBuffer();
 	void					Store( const ScRange& rRange, const ScTokenArray& );
-	UINT16					Find( const ScAddress aAdress );
+	UINT16					Find (const ScAddress & aAdress ) const;
 
 	static String			CreateName( const ScRange& );
 	};
Index: sc/source/filter/inc/xcl97rec.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xcl97rec.hxx,v
retrieving revision 1.42
retrieving revision 1.42.36.1
diff -u -p -u -p -r1.42 -r1.42.36.1
--- sc/source/filter/inc/xcl97rec.hxx	21 Feb 2005 13:41:19 -0000	1.42
+++ sc/source/filter/inc/xcl97rec.hxx	9 Aug 2005 16:29:54 -0000	1.42.36.1
@@ -281,8 +281,8 @@ public:
                                 XclTxo( const XclExpRoot& rRoot, const SdrTextObj& rEditObj );
                                 XclTxo( const XclExpRoot& rRoot, const EditTextObject& rEditObj, SdrObject* pCaption );
 
-    inline void                 SetHorAlign( XclTxoHorAlign eHorAlign ) { meHorAlign = eHorAlign; }
-    inline void                 SetVerAlign( XclTxoVerAlign eVerAlign ) { meVerAlign = eVerAlign; }
+    inline void                 SetHorAlign( sal_uInt8 nHorAlign ) { mnHorAlign = nHorAlign; }
+    inline void                 SetVerAlign( sal_uInt8 nVerAlign ) { mnVerAlign = nVerAlign; }
 
 	virtual	void				Save( XclExpStream& rStrm );
 
@@ -294,9 +294,9 @@ private:
 
 private:
     XclExpStringRef             mpString;       /// Text and formatting data.
-    XclTxoHorAlign              meHorAlign;     /// Horizontal alignment.
-    XclTxoVerAlign              meVerAlign;     /// Vertical alignment.
-    XclTxoRotation              meRotation;     /// Text rotation.
+    sal_uInt16                  mnRotation;     /// Text rotation.
+    sal_uInt8                   mnHorAlign;     /// Horizontal alignment.
+    sal_uInt8                   mnVerAlign;     /// Vertical alignment.
 };
 
 
Index: sc/source/filter/inc/xename.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xename.hxx,v
retrieving revision 1.3
retrieving revision 1.3.36.1
diff -u -p -u -p -r1.3 -r1.3.36.1
--- sc/source/filter/inc/xename.hxx	21 Feb 2005 13:42:33 -0000	1.3
+++ sc/source/filter/inc/xename.hxx	19 Apr 2005 14:47:16 -0000	1.3.36.1
@@ -101,6 +101,8 @@ public:
 
     /** Inserts a new defined name. Sets another unused name, if rName already exists. */
     sal_uInt16          InsertUniqueName( const String& rName, XclExpTokenArrayRef xTokArr, SCTAB nScTab );
+    /** Returns index of an existing name, or creates a name without definition. */
+    sal_uInt16          InsertRawName( const String& rName );
     /** Searches or inserts a defined name describing a macro name.
         @param bFunc  true = Macro function; false = Macro procedure. */
     sal_uInt16          InsertMacroCall( const String& rMacroName, bool bFunc );
Index: sc/source/filter/inc/xichart.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xichart.hxx,v
retrieving revision 1.2
retrieving revision 1.2.4.7
diff -u -p -u -p -r1.2 -r1.2.4.7
--- sc/source/filter/inc/xichart.hxx	29 Mar 2005 13:45:33 -0000	1.2
+++ sc/source/filter/inc/xichart.hxx	9 Aug 2005 16:29:54 -0000	1.2.4.7
@@ -64,6 +64,7 @@
 
 #include <vector>
 #include <map>
+#include <set>
 
 #ifndef _SFXITEMSET_HXX
 #include <svtools/itemset.hxx>
@@ -200,6 +201,10 @@ typedef ScfRef< XclImpChPos > XclImpChPo
 class XclImpChLineFormat
 {
 public:
+    /** Creates a new line format object with specific default formatting.
+        @param nObjId  Optional record identifier for a special default format. */
+    explicit            XclImpChLineFormat( sal_uInt16 nObjId = EXC_ID_CHUNKNOWN );
+
     /** Reads the CHLINEFORMAT record (basic line properties). */
     void                ReadChLineFormat( XclImpStream& rStrm );
 
@@ -211,9 +216,9 @@ public:
     inline sal_uInt16   GetWeight() const { return (IsAuto() || !HasLine()) ? EXC_CHLINEFORMAT_SINGLE : maData.mnWeight; }
 
     /** Converts and writes the contained data to the passed property set. */
-    void                Convert( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet ) const;
+    void                Convert( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet, sal_uInt16 nAutoWeight = EXC_CHLINEFORMAT_SINGLE ) const;
     /** Converts and writes the contained data to the passed property set of a series or data point. */
-    void                Convert( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const;
+    void                ConvertSeries( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const;
 
 private:
     XclChLineFormat     maData;             /// Contents of the CHLINEFORMAT record.
@@ -226,6 +231,10 @@ typedef ScfRef< XclImpChLineFormat > Xcl
 class XclImpChAreaFormat
 {
 public:
+    /** Creates a new area format object with specific default formatting.
+        @param nObjId  Optional record identifier for a special default format. */
+    explicit            XclImpChAreaFormat( sal_uInt16 nObjId = EXC_ID_CHUNKNOWN );
+
     /** Reads the CHAREAFORMAT record (basic fill properties, e.g. transparent or colored). */
     void                ReadChAreaFormat( XclImpStream& rStrm );
 
@@ -237,7 +246,7 @@ public:
     /** Converts and writes the contained data to the passed property set. */
     void                Convert( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet ) const;
     /** Converts and writes the contained data to the passed property set of a series or data point. */
-    void                Convert( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const;
+    void                ConvertSeries( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const;
 
 private:
     XclChAreaFormat     maData;             /// Contents of the CHAREAFORMAT record.
@@ -313,10 +322,12 @@ protected:
 class XclImpChFrame : public XclImpChFrameBase
 {
 public:
+    /** Creates a new frame object with specific default formatting.
+        @param nObjId  Optional record identifier for a special default format. */
+    explicit            XclImpChFrame( sal_uInt16 nObjId = EXC_ID_CHUNKNOWN );
+
     /** Reads the CHFRAME record (called by base class). */
     virtual void        ReadHeaderRecord( XclImpStream& rStrm );
-    /** Constructs all missing formats (line and/or area) to default settings. */
-    void                CreateMissingFormats();
 
     /** Converts and writes the contained data to the passed property set. */
     void                Convert( const XclImpChRoot& rRoot, ScfPropertySet& rPropSet ) const;
@@ -475,11 +486,9 @@ public:
 
     /** Returns the target object this text is linked to. */
     inline sal_uInt16   GetLinkTarget() const { return maObjLink.mnTarget; }
-    /** Returns the index of the series this text is linked to. */
-    inline sal_uInt16   GetSeriesIdx() const { return maObjLink.mnSeriesIdx; }
-    /** Returns the index of the data point this text is linked to. */
-    inline sal_uInt16   GetPointIdx() const { return maObjLink.mnPointIdx; }
-    /** Returns true,m if this text group contains string data. */
+    /** Returns the position of the data point label this text is linked to. */
+    inline const XclChPoint& GetPointPos() const { return maObjLink.maPos; }
+    /** Returns true, if this text group contains string data. */
     inline bool         HasString() const { return mxString.is(); }
 
     /** Converts and writes the contained font settings to the passed property set. */
@@ -508,88 +517,6 @@ typedef ScfRef< XclImpChText > XclImpChT
 
 // Linked source data =========================================================
 
-class XclImpChAttachedLabel : protected XclImpChRoot
-{
-public:
-    explicit            XclImpChAttachedLabel( const XclImpChRoot& rRoot );
-    /** Reads the CHATTACHEDLABEL record (data series/point labels). */
-    void                ReadChAttachedLabel( XclImpStream& rStrm );
-    /** Creates a CHTEXT group for the label. Clones xParentText and sets additional label settings */
-    XclImpChTextRef     CreateDataLabel( XclImpChTextRef xParent ) const;
-
-private:
-    sal_uInt16          mnFlags;            /// Additional flags.
-};
-
-typedef ScfRef< XclImpChAttachedLabel > XclImpChAttLabelRef;
-
-// ----------------------------------------------------------------------------
-
-/** Represents the CHDATAFORMAT record group containing data point properties.
-
-    The CHDATAFORMAT group consists of: CHDATAFORMAT, CHBEGIN, CHFRAME group,
-    CHMARKERFORMAT, CHPIEFORMAT, CH3DDATAFORMAT, CHSERIESFORMAT,
-    CHATTACHEDLABEL, CHEND.
- */
-class XclImpChDataFormat : public XclImpChFrameBase, protected XclImpChRoot
-{
-public:
-    explicit            XclImpChDataFormat( const XclImpChRoot& rRoot );
-
-    /** Reads the CHDATAFORMAT record (called by base class). */
-    virtual void        ReadHeaderRecord( XclImpStream& rStrm );
-    /** Reads a record from the CHDATAFORMAT group (called by base class). */
-    virtual void        ReadSubRecord( XclImpStream& rStrm );
-    /** Sets type and text formatting for a data point label (CHTEXT group). */
-    inline void         SetDataLabel( XclImpChTextRef xLabel ) { mxLabel = xLabel; }
-
-    /** Updates global data format. */
-    void                UpdateGlobalFormat();
-    /** Updates missing series settings from the passed global format. */
-    void                UpdateSeriesFormat( const XclImpChDataFormat* pGlobalFmt );
-    /** Updates missing data point settings from the passed series format. */
-    void                UpdatePointFormat( const XclImpChDataFormat* pSeriesFmt );
-
-    /** Returns the 0-based series index described by this group. */
-    inline sal_uInt16   GetSeriesIdx() const { return maData.mnSeriesIdx; }
-    /** Returns the format index described by this group. */
-    inline sal_uInt16   GetFormatIdx() const { return maData.mnFormatIdx; }
-    /** Returns the data point index described by this group. */
-    inline sal_uInt16   GetPointIdx() const { return maData.mnPointIdx; }
-    /** Returns true, if markers are set to automatic format. */
-    inline bool         IsAutoMarker() const { return !mxMarkerFmt || mxMarkerFmt->IsAuto(); }
-    /** Returns true, if markers are enabled. */
-    inline bool         HasMarker() const { return !mxMarkerFmt || mxMarkerFmt->HasMarker(); }
-    /** Returns true, if the series line is smoothed. */
-    inline bool         HasSpline() const { return mxSeriesFmt.is() && mxSeriesFmt->HasSpline(); }
-    /** Returns the data label text object. */
-    inline XclImpChTextRef GetDataLabel() const { return mxLabel; }
-
-    /** Converts and writes the contained data to the passed property set. */
-    void                Convert( ScfPropertySet& rPropSet ) const;
-    /** Writes the area format for a data point in a series with automatic point colors. */
-    void                ConvertVarPoint( ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const;
-
-private:
-    /** Removes unused formatting (e.g. pie distance in a bar chart). */
-    void                RemoveUnusedFormats();
-    /** Updates or creates the data point label. */
-    void                UpdateDataLabel( const XclImpChDataFormat* pParentFmt );
-
-private:
-    XclChDataFormat     maData;             /// Contents of the CHDATAFORMAT record.
-    XclImpChMarkerFormatRef mxMarkerFmt;    /// Data point marker (CHMARKERFORMAT record).
-    XclImpChPieFormatRef mxPieFmt;          /// Pie segment format (CHPIEFORMAT record).
-    XclImpChSeriesFormatRef mxSeriesFmt;    /// Series properties (CHSERIESFORMAT record).
-    XclImpCh3dDataFormatRef mx3dDataFmt;    /// 3D bar format (CH3DDATAFORMAT record).
-    XclImpChAttLabelRef mxAttLabel;         /// Data point label type (CHATTACHEDLABEL record).
-    XclImpChTextRef     mxLabel;            /// Data point label formatting (CHTEXT group).
-};
-
-typedef ScfRef< XclImpChDataFormat > XclImpChDataFormatRef;
-
-// ----------------------------------------------------------------------------
-
 /** Represents the main position of a source range.
     @descr  The main position always contains the sheet index. For vertical
         ranges it will contain the column index, and for horizontal ranges the
@@ -694,6 +621,91 @@ typedef ScfRef< XclImpChSourceLink > Xcl
 
 // ----------------------------------------------------------------------------
 
+class XclImpChAttachedLabel : protected XclImpChRoot
+{
+public:
+    explicit            XclImpChAttachedLabel( const XclImpChRoot& rRoot );
+    /** Reads the CHATTACHEDLABEL record (data series/point labels). */
+    void                ReadChAttachedLabel( XclImpStream& rStrm );
+    /** Creates a CHTEXT group for the label. Clones xParentText and sets additional label settings */
+    XclImpChTextRef     CreateDataLabel( XclImpChTextRef xParent ) const;
+
+private:
+    sal_uInt16          mnFlags;            /// Additional flags.
+};
+
+typedef ScfRef< XclImpChAttachedLabel > XclImpChAttLabelRef;
+
+// ----------------------------------------------------------------------------
+
+/** Represents the CHDATAFORMAT record group containing data point properties.
+
+    The CHDATAFORMAT group consists of: CHDATAFORMAT, CHBEGIN, CHFRAME group,
+    CHMARKERFORMAT, CHPIEFORMAT, CH3DDATAFORMAT, CHSERIESFORMAT,
+    CHATTACHEDLABEL, CHEND.
+ */
+class XclImpChDataFormat : public XclImpChFrameBase, protected XclImpChRoot
+{
+public:
+    explicit            XclImpChDataFormat( const XclImpChRoot& rRoot );
+
+    /** Reads the CHDATAFORMAT record (called by base class). */
+    virtual void        ReadHeaderRecord( XclImpStream& rStrm );
+    /** Reads a record from the CHDATAFORMAT group (called by base class). */
+    virtual void        ReadSubRecord( XclImpStream& rStrm );
+
+    /** Sets this object to the specified data point position. */
+    void                SetPointPos( sal_uInt16 nSeriesIdx, sal_uInt16 nPointIdx, sal_uInt16 nFormatIdx );
+    /** Sets type and text formatting for a data point label (CHTEXT group). */
+    inline void         SetDataLabel( XclImpChTextRef xLabel ) { mxLabel = xLabel; }
+
+    /** Updates global data format. */
+    void                UpdateGlobalFormat();
+    /** Updates missing series settings from the passed global format. */
+    void                UpdateSeriesFormat( const XclImpChDataFormat* pGlobalFmt );
+    /** Updates missing data point settings from the passed series format. */
+    void                UpdatePointFormat( const XclImpChDataFormat* pSeriesFmt );
+
+    /** Returns the position of the data point described by this group. */
+    inline const XclChPoint& GetPointPos() const { return maData.maPos; }
+    /** Returns the format index of the data point described by this group. */
+    inline sal_uInt16   GetFormatIdx() const { return maData.mnFormatIdx; }
+    /** Returns true, if markers are set to automatic format. */
+    inline bool         IsAutoMarker() const { return !mxMarkerFmt || mxMarkerFmt->IsAuto(); }
+    /** Returns true, if markers are enabled. */
+    inline bool         HasMarker() const { return !mxMarkerFmt || mxMarkerFmt->HasMarker(); }
+    /** Returns true, if the series line is smoothed. */
+    inline bool         HasSpline() const { return mxSeriesFmt.is() && mxSeriesFmt->HasSpline(); }
+    /** Returns the data label text object. */
+    inline XclImpChTextRef GetDataLabel() const { return mxLabel; }
+
+    /** Converts and writes the contained data to the passed property set. */
+    void                Convert( ScfPropertySet& rPropSet ) const;
+    /** Writes the area format for a data point in a series with automatic point colors. */
+    void                ConvertVarPoint( ScfPropertySet& rPropSet, sal_uInt16 nFormatIdx ) const;
+    /** Writes the line format only, e.g. for trend lines or error bars. */
+    void                ConvertLine( ScfPropertySet& rPropSet, sal_uInt16 nAutoWeight ) const;
+
+private:
+    /** Removes unused formatting (e.g. pie distance in a bar chart). */
+    void                RemoveUnusedFormats();
+    /** Updates or creates the data point label. */
+    void                UpdateDataLabel( const XclImpChDataFormat* pParentFmt );
+
+private:
+    XclChDataFormat     maData;             /// Contents of the CHDATAFORMAT record.
+    XclImpChMarkerFormatRef mxMarkerFmt;    /// Data point marker (CHMARKERFORMAT record).
+    XclImpChPieFormatRef mxPieFmt;          /// Pie segment format (CHPIEFORMAT record).
+    XclImpChSeriesFormatRef mxSeriesFmt;    /// Series properties (CHSERIESFORMAT record).
+    XclImpCh3dDataFormatRef mx3dDataFmt;    /// 3D bar format (CH3DDATAFORMAT record).
+    XclImpChAttLabelRef mxAttLabel;         /// Data point label type (CHATTACHEDLABEL record).
+    XclImpChTextRef     mxLabel;            /// Data point label formatting (CHTEXT group).
+};
+
+typedef ScfRef< XclImpChDataFormat > XclImpChDataFormatRef;
+
+// ----------------------------------------------------------------------------
+
 /** Represents the CHSERIES record group describing a data series in a chart.
 
     The CHSERIES group consists of: CHSERIES, CHBEGIN, CHSOURCELINK groups,
@@ -706,15 +718,15 @@ public:
     typedef ::com::sun::star::uno::Reference< ::com::sun::star::chart::XChartDocument > XChartDocRef;
 
 public:
-    explicit            XclImpChSeries( const XclImpChRoot& rRoot );
+    explicit            XclImpChSeries( const XclImpChRoot& rRoot, sal_uInt16 nSeriesIdx );
 
     /** Reads the CHSERIES record (called by base class). */
     virtual void        ReadHeaderRecord( XclImpStream& rStrm );
     /** Reads a record from the CHSERIES group (called by base class). */
     virtual void        ReadSubRecord( XclImpStream& rStrm );
 
-        /** If own orientation is single-cell, tries to update it from the passed series.
-        @return  True, if the passed series has compatible value ranges. */
+    /** If own orientation is single-cell, tries to update it from the passed series.
+    @return  True, if the passed series has compatible value ranges. */
     bool                CheckAndUpdateOrientation( const XclImpChSeries& rSeries );
     /** Sets the final orientation of the chart. Removes invalid titles and categories. */
     void                SetFinalOrientation( XclChOrientation eOrient );
@@ -725,22 +737,28 @@ public:
     /** Adds the title cell to the value ranges. */
     void                AddTitleToValues();
 
+    /** Sets a data point or series format (CHDATAFORMAT group) for this series. */
+    void                SetDataFormat( XclImpChDataFormatRef xDataFmt );
     /** Sets a label text (CHTEXT group) attached  to a series or data point. */
     void                SetDataLabel( XclImpChTextRef xLabel );
     /** Updates missing series formatting by using default formatting from axes sets. */
-    void                UpdateSeriesFormat();
+    void                FinalizeDataFormats();
 
     /** Returns the axes set identifier this series is assigned to (primary/secondary). */
     inline sal_uInt16   GetGroupIdx() const { return mnGroupIdx; }
     /** Returns the 0-based series index described by this series. */
     inline sal_uInt16   GetSeriesIdx() const { return mnSeriesIdx; }
+    /** Returns the 0-based index of the parent series (e.g. of a trend line). */
+    inline sal_uInt16   GetParentIdx() const { return mnParentIdx; }
+    /** Returns the format index of the series used for automatic line and area colors. */
+    inline sal_uInt16   GetFormatIdx() const { return mxSeriesFmt.is() ? mxSeriesFmt->GetFormatIdx() : EXC_CHSERIES_INVALID; }
     /** Returns the number of data points of this series. */
     inline sal_uInt16   GetPointCount() const { return mbHasValue ? mxValueLink->GetCellCount() : 0; }
 
     /** Returns the orientation of the linked range. */
     inline XclChOrientation GetOrientation() const { return meOrient; }
     /** Returns true, if the series is child of another series (e.g. trend line). */
-    inline bool         HasParentSeries() const { return mbHasParent; }
+    inline bool         HasParentSeries() const { return mnParentIdx != EXC_CHSERIES_INVALID; }
     /** Returns true, if the series has a valid source link for the values. */
     inline bool         HasValidValues() const { return mbHasValue; }
     /** Returns true, if the series has a valid source link for the categories. */
@@ -773,10 +791,21 @@ private:
     void                ReadChSourceLink( XclImpStream& rStrm );
     /** Reads a CHDATAFORMAT group containing series and point formatting. */
     void                ReadChDataFormat( XclImpStream& rStrm );
+    /** Reads a CHSERPARENT record specifying the parent series of this series. */
+    void                ReadChSerParent( XclImpStream& rStrm );
+    /** Finalizes the series after reading the CHSERIES group. */
+    void                ReadChEnd( XclImpStream& rStrm );
 
     /** Calculates the orientation of the series source ranges. */
     void                CalcOrientation();
 
+    /** Creates a new CHDATAFORMAT group with the specified point index. */
+    XclImpChDataFormatRef CreateDataFormat( sal_uInt16 nPointIdx, sal_uInt16 nFormatIdx );
+    /** Returns the pointer to a CHDATAFORMAT group reference or 0 for invalid pointer index. */
+    XclImpChDataFormatRef* GetDataFormatRef( sal_uInt16 nPointIdx );
+    /** Returns the pointer to a CHTEXT group reference or 0 for invalid pointer index. */
+    XclImpChTextRef*    GetDataLabelRef( sal_uInt16 nPointIdx );
+
 private:
     typedef XclImpChMap< sal_uInt16, XclImpChDataFormat >   XclImpChDataFormatMap;
     typedef XclImpChMap< sal_uInt16, XclImpChText >         XclImpChTextMap;
@@ -787,10 +816,11 @@ private:
     XclImpChSourceLinkRef mxTitleLink;      /// Link data for series title.
     XclImpChDataFormatRef mxSeriesFmt;      /// CHDATAFORMAT group for series format.
     XclImpChDataFormatMap maPointFmts;      /// CHDATAFORMAT groups for data point formats.
+    XclImpChTextMap     maLabels;           /// All text labels for series and points (CHTEXT groups).
     XclChOrientation    meOrient;           /// Orientation of the series.
     sal_uInt16          mnGroupIdx;         /// Chart group (CHCHARTFORMAT group) this series is assigned to.
     sal_uInt16          mnSeriesIdx;        /// 0-based series index.
-    bool                mbHasParent;        /// true = Series is child of a series (e.g. trend line).
+    sal_uInt16          mnParentIdx;        /// 0-based index of parent series (trend lines and error bars).
     bool                mbHasValue;         /// true = Has valid series values.
     bool                mbHasCateg;         /// true = Has valid category range.
     bool                mbHasTitle;         /// true = Has valid series title.
@@ -922,6 +952,11 @@ public:
     /** Final processing after reading the entire chart. */
     void                Finalize();
 
+    /** Marks the passed format index as used. PopUnusedFormatIndex() will not return this index. */
+    void                SetUsedFormatIndex( sal_uInt16 nFormatIdx );
+    /** Returns the next unused format index and marks it as used. */
+    sal_uInt16          PopUnusedFormatIndex();
+
     /** Returns the chart group index of this chart group format. */
     inline sal_uInt16   GetGroupIdx() const { return maData.mnGroupIdx; }
     /** Returns the record identifier of the chart type record. */
@@ -932,6 +967,8 @@ public:
     inline bool         HasHiLoLine() const { return maChartLines.has( EXC_CHCHARTLINE_HILO ); }
     /** Returns true, if the chart group contains drop bar formats. */
     inline bool         HasDropBars() const { return !maDropBars.empty(); }
+    /** Looks for a legend in all chart groups and returns it. */
+    inline XclImpChLegendRef GetLegend() const { return mxLegend; }
 
     /** Returns true, if points of a single series are colored like series (automatic background color). */
     inline bool         IsVarPointFormat() const { return ::get_flag( maData.mnFlags, EXC_CHCHARTFORMAT_VARIED ); }
@@ -940,8 +977,6 @@ public:
 
     /** Creates the diagram with the correct type in the passed chart. */
     void                CreateDiagram( XChartDocRef xChartDoc ) const;
-    /** Writes initial settings (chart type, legend on/off, 3D mode) to the passed chart. */
-    void                ConvertInitial( XChartDocRef xChartDoc ) const;
     /** Converts and writes all remaining formatting to the passed chart. */
     void                Convert( XChartDocRef xChartDoc ) const;
 
@@ -959,6 +994,7 @@ private:
 private:
     typedef XclImpChMap< sal_uInt16, XclImpChDropBar >      XclImpChDropBarMap;
     typedef XclImpChMap< sal_uInt16, XclImpChLineFormat >   XclImpChLineFormatMap;
+    typedef ::std::set< sal_uInt16 >                        UInt16Set;
 
     XclChChartFormat    maData;             /// Contents of the CHCHARTFORMAT record.
     XclImpChType        maType;             /// Chart type (e.g. CHBAR, CHLINE, ...).
@@ -967,6 +1003,7 @@ private:
     XclImpChDropBarMap  maDropBars;         /// Dropbars (CHDROPBAR group).
     XclImpChLineFormatMap maChartLines;     /// Global line formats (CHCHARTLINE group).
     XclImpChDataFormatRef mxGlobalFmt;      /// Global format for series (CHDATAFORMAT group).
+    UInt16Set           maUnusedFormats;    /// Contains unused format indexes for automatic colors.
 };
 
 typedef ScfRef< XclImpChChartFormat > XclImpChChartFormatRef;
@@ -1135,15 +1172,17 @@ public:
     inline bool         IsAlive() const { return mbAlive; }
     /** Returns the index of the axes set (primary/secondary). */
     inline sal_uInt16   GetAxesSetId() const { return maData.mnAxesSetId; }
-    /** Returns the chart format data of this axes set. */
-    inline const XclImpChChartFormat& GetChartFormat() const { return *maChartFmts.begin()->second; }
     /** Returns true, if the axes set contains the specified chart group. */
     inline bool         HasChartGroup( sal_uInt16 nGroupIdx ) const { return maChartFmts.has( nGroupIdx ); }
+    /** Returns the specified chart format group. */
+    inline XclImpChChartFormatRef GetChartGroup( sal_uInt16 nGroupIdx ) const { return maChartFmts.get( nGroupIdx ); }
+    /** Returns the default chart format group of this axes set. */
+    inline XclImpChChartFormat& GetDefChartGroup() const { return *maChartFmts.begin()->second; }
+    /** Looks for a legend in all chart groups and returns it. */
+    XclImpChLegendRef   GetLegend() const;
 
     /** Creates the diagram with the correct type in the passed chart. */
     void                CreateDiagram( XChartDocRef xChartDoc ) const;
-    /** Converts and writes initial settings (titles on/off, legend on/off, 3D mode) to the passed chart. */
-    void                ConvertInitial( XChartDocRef xChartDoc ) const;
     /** Converts and writes all axes formatting to the passed chart. */
     void                Convert( XChartDocRef xChartDoc ) const;
 
@@ -1212,6 +1251,9 @@ public:
     virtual void        ReadHeaderRecord( XclImpStream& rStrm );
     /** Reads a record from the CHCHART group (called by base class). */
     virtual void        ReadSubRecord( XclImpStream& rStrm );
+    /** Reads a CHDATAFORMAT group describing a series format or a data point format. */
+    void                ReadChDataFormat( XclImpStream& rStrm );
+
     /** Checks validity of scatter X value ranges (must be equal for all series).
         @return  true = chart contains valid X value ranges for all series. */
     bool                UpdateScatterXRanges();
@@ -1229,29 +1271,36 @@ public:
     bool                HasHeaderRow() const;
 
     /** Returns the final chart type identifier. */
-    inline sal_uInt16   GetChartTypeId() const { return mxPrimAxesSet->GetChartFormat().GetChartTypeId(); }
+    inline sal_uInt16   GetChartTypeId() const { return mxPrimAxesSet->GetDefChartGroup().GetChartTypeId(); }
     /** Returns true, if the chart is a three-dimensional chart. */
-    inline bool         Is3dChart() const { return mxPrimAxesSet->GetChartFormat().Is3dChart(); }
+    inline bool         Is3dChart() const { return mxPrimAxesSet->GetDefChartGroup().Is3dChart(); }
     /** Returns true, the chart is a stock chart. */
     bool                IsStockChart() const;
 
     /** Returns true, if the specified axes set is alive. */
     bool                HasAxesSet( sal_uInt16 nAxesSetId ) const;
 
+    /** Returns the axes set that contains the passed chart group. */
+    XclImpChAxesSet&    GetChartGroupAxesSet( sal_uInt16 nGroupIdx ) const;
     /** Returns the axes set identifier of the passed chart group. */
-    sal_uInt16          GetAxesSetId( sal_uInt16 nGroupIdx ) const;
+    sal_uInt16          GetChartGroupAxesSetId( sal_uInt16 nGroupIdx ) const;
+
     /** Returns the specified chart format group. */
-    const XclImpChChartFormat& GetChartFormat( sal_uInt16 nGroupIdx ) const;
+    XclImpChChartFormatRef GetChartGroup( sal_uInt16 nGroupIdx ) const;
+    /** Returns the default chart format group from one of the axes sets. */
+    XclImpChChartFormat& GetDefChartGroup( sal_uInt16 nGroupIdx ) const;
     /** Returns the number of series for the specified chart format group. */
-    sal_uInt16          GetSeriesCount( sal_uInt16 nGroupIdx ) const;
+    sal_uInt16          GetChartGroupSeriesCount( sal_uInt16 nGroupIdx ) const;
 
+    /** Looks for a legend in all chart groups and returns it. */
+    XclImpChLegendRef   GetLegend() const;
     /** Returns the specified default text. */
     XclImpChTextRef     GetDefaultText( sal_uInt16 nTextId ) const;
 
     /** Returns true, if at least one series contains a visible line format. */
     bool                HasAnySeriesLine() const;
     /** Returns the number of units on the progress bar needed for the chart. */
-    inline sal_uInt32   GetProgressSize() const { return 2; }
+    inline sal_uInt32   GetProgressSize() const { return 2 * EXC_CHART_PROGRESS_SIZE; }
 
     /** Converts and writes all properties to the passed chart. */
     void                Convert( XChartDocRef xChartDoc, ScfProgressBar& rProgress ) const;
@@ -1270,6 +1319,8 @@ private:
     void                Finalize();
     /** Calculates the orientation of all series source ranges. */
     void                CalcOrientation();
+    /** Assigns all imported CHDATAFORMAT groups to the respective series. */
+    void                FinalizeDataFormats();
 
     /** Converts and writes all series and data point formatting to the passed chart. */
     void                ConvertSeries( XChartDocRef xChartDoc ) const;
@@ -1277,20 +1328,21 @@ private:
     void                ConvertSeriesOrder( XChartDocRef xChartDoc ) const;
 
 private:
-    typedef XclImpChMap< sal_uInt16, XclImpChSeries >   XclImpChSeriesMap;
-    typedef XclImpChMap< sal_uInt16, XclImpChText >     XclImpChTextMap;
-    typedef ::std::vector< XclImpChSeriesRef >          XclImpChSeriesVec;
+    typedef ::std::vector< XclImpChSeriesRef >              XclImpChSeriesVec;
+    typedef XclImpChMap< XclChPoint, XclImpChDataFormat >   XclImpChDataFormatMap;
+    typedef XclImpChMap< sal_uInt16, XclImpChText >         XclImpChTextMap;
 
     XclChPos            maPos;              /// Position of the chart on the sheet (CHCHART record).
-    XclImpChSeriesMap   maSeries;           /// List of series data (CHSERIES groups).
+    XclImpChSeriesVec   maSeries;           /// List of series data (CHSERIES groups).
+    XclImpChSeriesVec   maValidSeries;      /// All valid series (in original order).
+    XclImpChDataFormatMap maDataFmts;       /// All series and point formats (CHDATAFORMAT groups).
     XclImpChFrameRef    mxFrame;            /// Chart frame format (CHFRAME group).
     XclImpChTextRef     mxTitle;            /// Chart title (CHTEXT group).
     XclChProperties     maProps;            /// Chart properties (CHPROPERTIES record).
     XclImpChTextMap     maDefTexts;         /// Default text objects (CHDEFAULTTEXT groups).
     XclImpChAxesSetRef  mxPrimAxesSet;      /// Primary axes set (CHAXESSET group).
-    XclImpChAxesSetRef  mxSecAxesSet;       /// Secondary axes set (CHAXESSET group).
+    XclImpChAxesSetRef  mxSecnAxesSet;      /// Secondary axes set (CHAXESSET group).
     XclChOrientation    meOrient;           /// Final orientation of the series.
-    XclImpChSeriesVec   maValidSeries;      /// All valid series (in original order).
     bool                mbHasValue;         /// true = Has valid series values.
     bool                mbHasCateg;         /// true = Has valid category ranges.
     bool                mbHasTitle;         /// true = Has valid series titles.
Index: sc/source/filter/inc/xiescher.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xiescher.hxx,v
retrieving revision 1.17
retrieving revision 1.17.4.1
diff -u -p -u -p -r1.17 -r1.17.4.1
--- sc/source/filter/inc/xiescher.hxx	29 Mar 2005 13:45:46 -0000	1.17
+++ sc/source/filter/inc/xiescher.hxx	9 Aug 2005 16:29:55 -0000	1.17.4.1
@@ -62,9 +62,10 @@
 #ifndef SC_XIESCHER_HXX
 #define SC_XIESCHER_HXX
 
-#ifndef _RTTI_HXX
-#include <tools/rtti.hxx>
-#endif
+#include <vector>
+#include <list>
+#include <map>
+
 #ifndef _MSDFFIMP_HXX
 #include <svx/msdffimp.hxx>
 #endif
@@ -83,192 +84,165 @@ namespace com { namespace sun { namespac
 class ScfProgressBar;
 class ScfPropertySet;
 
-// Escher stream consumer =====================================================
-
-struct XclImpStreamNode
-{
-    ULONG               mnPos;
-    ULONG               mnSize;
-    XclImpStreamNode*   mpPrev;
-};
-
-// ----------------------------------------------------------------------------
+// Text box data ==============================================================
 
-class XclImpStreamConsumer : ScfNoCopy
+class XclImpTxoData : protected XclImpRoot
 {
 public:
-    explicit            XclImpStreamConsumer();
-                        ~XclImpStreamConsumer();
+    explicit            XclImpTxoData( const XclImpRoot& rRoot );
 
-    const DffRecordHeader* ConsumeRecord( XclImpStream& rSrcStrm );
-    bool                AppendData( sal_Char* pBuf, ULONG nLen );
+    /** Reads a TXO record and following CONTINUE records for string and formatting data. */
+    void                ReadTxo( XclImpStream& rStrm );
 
-    inline bool         HasData() const { return maStrm.Tell() > 0; }
-    inline ULONG        Tell() const { return maStrm.Tell(); }
-    inline SvStream&    GetStream() { return maStrm; }
+    /** Returns the text orientation. */
+    inline sal_uInt16   GetOrientation() const { return maData.mnOrient; }
+    /** Returns the string data, if there is any. */
+    inline const XclImpString* GetString() const { return mxString.get(); }
 
-private:
-    void                UpdateNode( const DffRecordHeader& rHd );
-    void                RemoveNode();
+    /** Sets the text to the passed SdrObject, if it can take text. */
+    void                ProcessSdrObject( SdrObject& rSdrObj ) const;
 
 private:
-    SvMemoryStream      maStrm;
-    DffRecordHeader     maHd;
-    XclImpStreamNode*   mpNode;
-    ULONG               mnBytesLeft;
+    XclTxoData          maData;         /// Data from the TXO record.
+    XclImpStringRef     mxString;       /// Plain or rich string.
 };
 
+typedef ScfRef< XclImpTxoData > XclImpTxoDataRef;
+
 // Escher objects =============================================================
 
-/** Base class for Escher objects. Does not contain any specialized data. */
-class XclImpEscherObj : protected XclImpRoot, ScfNoCopy
+class XclImpDrawObjBase;
+typedef ScfRef< XclImpDrawObjBase > XclImpDrawObjRef;
+
+/** Base class for drawing objects (OBJ records). */
+class XclImpDrawObjBase : protected XclImpRoot, ScfNoCopy
 {
 public:
-    TYPEINFO();
-
-    /** Constructs a dummy Escher object with an invalid Escher stream position. */
-    explicit            XclImpEscherObj( const XclImpRoot& rRoot );
-    /** Constructs a new Escher object at the specified Escher stream position. */
-    explicit            XclImpEscherObj(
-                            const XclImpRoot& rRoot,
-                            ULONG nStrmBegin, ULONG nStrmEnd );
-    /** Constructor takes ownership of the members of rSrcObj, which will be invalidated. */
-    explicit            XclImpEscherObj( XclImpEscherObj& rSrcObj );
-
-    virtual             ~XclImpEscherObj();
-
-    /** Returns the SdrObj of this Escher object. */
-    inline const SdrObject* GetSdrObj() const { return mxSdrObj.get(); }
-    /** Returns the position of the object in the draw page. */
-    inline const Rectangle& GetAnchor() const { return maAnchorRect; }
-    /** Returns the start position in the Escher stream of this object. */
-    inline ULONG        GetStrmBegin() const { return mnStrmBegin; }
-    /** Returns the end position in the Escher stream of this object (last position + 1). */
-    inline ULONG        GetStrmEnd() const { return mnStrmEnd; }
-    /** Returns the Calc sheet index of this object. */
-    inline SCTAB        GetScTab() const { return mnScTab; }
-    /** Returns the Excel object identifier. */
-    inline sal_uInt16   GetObjId() const { return mnObjId; }
-    /** Returns true, if Escher object will be skipped on creating the draw page. */
-    inline bool         GetIsSkip() const { return mbSkip; }
-    /** Returns true, if Escher object is printable. */
-    inline bool         GetPrintable() const { return mbPrintable; }
-
-    /** Returns true, if the passed width and height would be valid for this object. */
-    bool                IsValidSize( const Rectangle& rRect ) const;
-
-    /** Returns true, if the width and height of the object are valid. */
-    bool                IsValidSize() const;
-    /** Returns true, if this Escher object contains an SdrObj and a valid anchor position. */
-    bool                IsValid() const;
-
-    /** Sets the position of this object in the draw page. */
-    inline void         SetAnchor( const Rectangle& rRect ) { maAnchorRect = rRect; }
-    /** Sets the Excel object identifier (unique per sheet). */
-    inline void         SetObjId( sal_uInt16 nObjId ) { mnObjId = nObjId; }
+    explicit            XclImpDrawObjBase( const XclImpRoot& rRoot );
+    virtual             ~XclImpDrawObjBase();
+
+    /** Reads the FTCMO subrecord (common object data) in an OBJ record, returns a new object. */
+    static XclImpDrawObjRef ReadObjCmo( XclImpStream& rStrm );
+    /** Reads the contents of the specified subrecord of an OBJ record from stream. */
+    virtual void        ReadSubRecord( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize );
+    /** Reads the client anchor from an msofbtClientAnchor Escher record. */
+    Rectangle           ReadClientAnchor( SvStream& rEscherStrm, const DffRecordHeader& rHeader );
+
+    /** Sets common object data from FTCMO subrecord. */
+    void                SetObjData( sal_uInt16 nObjType, sal_uInt16 nObjId, sal_uInt16 nObjFlags );
+    /** Sets shape data from Escher stream. */
+    void                SetShapeData( sal_uInt32 nShapeId, sal_uInt32 nShapeFlags, sal_uInt32 nShapeBlipId );
     /** Sets whether this is an area object (then its width and height must be greater than 0). */
     inline void         SetAreaObj( bool bAreaObj ) { mbAreaObj = bAreaObj; }
-    /** Marks this Esher object to be skipped on export. */
-    inline void         SetSkip() { mbSkip = true; }
 
-    /** Sets a new SdrObj for this Escher object. This object owns the passed SdrObj. */
-    virtual void        SetSdrObj( SdrObject* pSdrObj );
-    /** Set true if Escher object is printable. */
-    inline void         SetPrintable( bool bPrint ) { mbPrintable = bPrint; }
+    /** If set, the SdrObject will not be created, processed, or inserted into the draw page. */
+    inline void         SetInvalid() { mbValid = false; }
+    /** If set, the SdrObject will not be processed, but created and inserted into the draw page. */
+    inline void         SetSkipProcessSdr() { mbProcSdr = false; }
+    /** If set, the SdrObject will be created or processed, but not be inserted into the draw page. */
+    inline void         SetSkipInsertSdr() { mbInsSdr = false; }
 
-    /** Returns the needed size on the progress bar. */
-    virtual sal_uInt32  GetProgressSize() const;
-    /** Inserts the contained SdrObj into the draw page.
-        @return  true = object converted and inserted. */
-    virtual bool        Apply( ScfProgressBar& rProgress );
-
-protected:
-    typedef ::std::auto_ptr< SdrObject > SdrObjectPtr;
+    /** Returns the Calc sheet index of this object. */
+    inline SCTAB        GetScTab() const { return maObjId.mnScTab; }
+    /** Returns the sheet index and Excel object identifier from OBJ record. */
+    inline const XclObjId& GetObjId() const { return maObjId; }
+    /** Returns the Excel object type from OBJ record. */
+    inline sal_uInt16   GetObjType() const { return mnObjType; }
+
+    /** Returns the shape identifier used in the Escher stream. */
+    inline sal_uInt32   GetShapeId() const { return mnShapeId; }
+    /** Returns the shape flags from the Escher stream. */
+    inline sal_uInt32   GetShapeFlags() const { return mnShapeFlags; }
+    /** Returns the BLIP identifier for the meta file. */
+    inline sal_uInt32   GetShapeBlipId() const { return mnShapeBlipId; }
 
-    Rectangle           maAnchorRect;   /// Location of the object in the draw page.
-    SdrObjectPtr        mxSdrObj;       /// SdrObj representing this Escher object.
-    ULONG               mnStrmBegin;    /// Start position in Escher stream.
-    ULONG               mnStrmEnd;      /// End position in Escher stream (last + 1).
-    SCTAB               mnScTab;        /// Calc sheet index of the object.
-    sal_uInt16          mnObjId;        /// The Excel object identifier (from OBJ record).
-    bool                mbAreaObj;      /// true = Width and height must be greater than 0.
-    bool                mbSkip;         /// true = Skip creation (ignore this object).
-    bool                mbPrintable;    /// true = Print this object.
-};
+    /** Returns true, if the object is valid and will be processed.. */
+    inline bool         IsValid() const { return mbValid; }
+    /** Returns true, if the SdrObject will be processed (ProcessSdrObject() will be called). */
+    inline bool         IsProcessSdr() const { return mbProcSdr; }
+    /** Returns true, if the SdrObject will be created or processed, but not be inserted into the draw page. */
+    inline bool         IsInsertSdr() const { return mbInsSdr; }
+    /** Returns true, if Escher object is printable. */
+    inline bool         IsPrintable() const { return ::get_flag( mnObjFlags, EXC_OBJ_CMO_PRINTABLE ); }
 
-// ----------------------------------------------------------------------------
+    /** Returns true, if the passed size is valid for this object. */
+    bool                IsValidSize( const Rectangle& rAnchorRect ) const;
+    /** Returns the area in the sheet used by this object. */
+    ScRange             GetUsedArea() const;
 
-/** A simple drawing object, i.e. line, rectangle, or bitmap. */
-class XclImpEscherDrawing : public XclImpEscherObj
-{
-public:
-    TYPEINFO();
+    /** Returns the needed size on the progress bar (calls virtual DoGetProgressSize() function). */
+    sal_uInt32          GetProgressSize() const;
+    /** Additional processing for the passed SdrObject (calls virtual DoProcessSdrObj() function). */
+    void                ProcessSdrObject( SdrObject& rSdrObj ) const;
 
-    /** Constructor takes ownership of the members of rSrcObj, which will be invalidated.
-        @param bAreaObj  true = Width and height of the object must be greater than 0. */
-    explicit            XclImpEscherDrawing( XclImpEscherObj& rSrcObj, bool bAreaObj );
-    /** Inserts the contained SdrObj into the draw page. */
-    virtual bool        Apply( ScfProgressBar& rProgress );
+protected:
+    /** Derived classes may return a progress bar size different from 1. */
+    virtual sal_uInt32  DoGetProgressSize() const;
+    /** Derived classes may perform additional processing for the passed SdrObject. */
+    virtual void        DoProcessSdrObj( SdrObject& rSdrObj ) const;
+
+    /** Creates an Escher anchor from the passed position (used for sheet charts). */
+    void                CreateEscherAnchor( const Rectangle& rAnchorRect );
+
+private:
+    typedef ScfRef< XclEscherAnchor > XclEscherAnchorRef;
+
+    XclEscherAnchorRef  mxAnchor;       /// The position of the object in the containing sheet.
+    XclObjId            maObjId;        /// Sheet index and object identifier.
+    sal_uInt16          mnObjType;      /// The Excel object type from OBJ record.
+    sal_uInt16          mnObjFlags;     /// Additional flags from OBJ record.
+    sal_uInt32          mnShapeId;      /// Shape ID from Escher stream.
+    sal_uInt32          mnShapeFlags;   /// Shape flags from Escher stream.
+    sal_uInt32          mnShapeBlipId;  /// The BLIP identifier (meta file).
+    bool                mbValid;        /// true = Object is valid, do processing and insertion.
+    bool                mbAreaObj;      /// true = Width and height must be greater than 0.
+    bool                mbProcSdr;      /// true = Process the SdrObject.
+    bool                mbInsSdr;       /// true = Insert the SdrObject into draw page.
 };
 
 // ----------------------------------------------------------------------------
 
-/** A common text box object. */
-class XclImpEscherTxo : public XclImpEscherDrawing
+/** A simple drawing object, e.g. line, rectangle, textbox, or bitmap. */
+class XclImpDrawingObj : public XclImpDrawObjBase
 {
 public:
-    TYPEINFO();
+    /** @param bAreaObj  true = Width and height of the object must be greater than 0. */
+    explicit            XclImpDrawingObj( const XclImpRoot& rRoot, bool bAreaObj );
 
-    /** Constructor takes ownership of the members of rSrcObj, which will be invalidated. */
-    explicit            XclImpEscherTxo( XclImpEscherObj& rSrcObj );
+    /** Stores the passed textbox data from a TXO record. */
+    inline void         SetTxoData( XclImpTxoDataRef xTxoData ) { mxTxoData = xTxoData; }
 
-    /** Returns the string data, if there is any. */
-    inline const XclImpString* GetString() const { return mxString.get(); }
-    /** Returns the rotation text alignment. */
-    inline XclTxoRotation GetRotation() const { return meRotation; }
-
-    /** Sets a new plain or rich string. This object will own the string. */
-    inline void         SetString( XclImpString* pString ) { mxString.reset( pString ); }
-    /** Sets the horizontal and vertical text alignment from the passed Excel TXO flags. */
-    void                SetAlignment( sal_uInt16 nAlign );
-    /** Sets the rotation text alignment from the passed Excel TXO orientation flags. */
-    void                SetRotation( sal_uInt16 nOrient );
+    /** Returns the text orientation from the contained textbox data. */
+    inline sal_uInt16   GetOrientation() const { return mxTxoData.is() ? mxTxoData->GetOrientation() : EXC_TXO_TEXTROT_NONE; }
+    /** Returns the string from the contained textbox data. */
+    inline const XclImpString* GetString() const { return mxTxoData.is() ? mxTxoData->GetString() : 0; }
 
-    /** Sets the text of this Escher text object to the passed SdrObj, if it can take text. */
-    void                ApplyTextOnSdrObj( SdrObject& rSdrObj ) const;
-
-private:
-    /** Sets the text of this Escher object to the own SdrObj. */
-    void                ApplyText();
+protected:
+    /** Inserts the contained text data at the passed object. */
+    virtual void        DoProcessSdrObj( SdrObject& rSdrObj ) const;
 
 private:
-    typedef ::std::auto_ptr< XclImpString > XclImpStringPtr;
-
-    XclImpStringPtr     mxString;       /// Plain or rich string.
-    XclTxoHorAlign      meHorAlign;     /// Horizontal alignment.
-    XclTxoVerAlign      meVerAlign;     /// Vertical alignment.
-    XclTxoRotation      meRotation;     /// Text rotation.
+    XclImpTxoDataRef    mxTxoData;      /// Textbox data from TXO record.
 };
 
 // ----------------------------------------------------------------------------
 
 /** A note object, which is a specialized text box objext. */
-class XclImpEscherNote : public XclImpEscherTxo
+class XclImpNoteObj : public XclImpDrawingObj
 {
 public:
-    TYPEINFO();
-
-    /** Constructor takes ownership of the members of rSrcObj, which will be invalidated. */
-    explicit            XclImpEscherNote( XclImpEscherObj& rSrcObj );
+    explicit            XclImpNoteObj( const XclImpRoot& rRoot );
 
-    /** Sets the note position in the Calc sheet. */
-    inline void         SetScPos( const ScAddress& rScPos ) { maScPos = rScPos; }
+    /** Sets note flags and the note position in the Calc sheet. */
+    void                SetNoteData( const ScAddress& rScPos, sal_uInt16 nNoteFlags );
 
-    /** Inserts the note into the document, makes it visible according to the settings. */
-    virtual bool        Apply( ScfProgressBar& rProgress );
+protected:
+    /** Inserts the note into the document, sets visibility. */
+    virtual void        DoProcessSdrObj( SdrObject& rSdrObj ) const;
 
 private:
     ScAddress           maScPos;        /// Cell position of the note object.
+    sal_uInt16          mnNoteFlags;    /// Flags from NOTE record.
 };
 
 // ----------------------------------------------------------------------------
@@ -293,25 +267,33 @@ protected:
     void                ReadSrcRangeFormula( XclImpStream& rStrm );
 
 private:
-    ::std::auto_ptr< ScAddress > mxCellLink;    /// Linked cell in the Calc document.
-    ::std::auto_ptr< ScRange >  mxSrcRange;     /// Source data range in the Calc document.
-    XclCtrlBindMode     meBindMode;             /// Value binding mode.
+    ScfRef< ScAddress > mxCellLink;     /// Linked cell in the Calc document.
+    ScfRef< ScRange >   mxSrcRange;     /// Source data range in the Calc document.
+    XclCtrlBindMode     meBindMode;     /// Value binding mode.
 };
 
 // ----------------------------------------------------------------------------
 
 /** An old form control object (does not use the OLE mechanism, but is a "simple" drawing object). */
-class XclImpEscherTbxCtrl : public XclImpEscherTxo, public XclImpCtrlLinkHelper
+class XclImpTbxControlObj : public XclImpDrawingObj, public XclImpCtrlLinkHelper
 {
 public:
-    TYPEINFO();
+    explicit            XclImpTbxControlObj( const XclImpRoot& rRoot );
 
-    /** Constructor takes ownership of the members of rSrcObj, which will be invalidated. */
-    explicit            XclImpEscherTbxCtrl( XclImpEscherObj& rSrcObj, sal_uInt16 nCtrlType );
+    /** Reads the contents of the specified subrecord of an OBJ record from stream. */
+    virtual void        ReadSubRecord( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize );
 
-    /** Returns the type of the control, which is the object type from the OBJ record. */
-    inline sal_uInt16   GetType() const { return mnCtrlType; }
+    /** Returns the complete component service name for this control. */
+    ::rtl::OUString     GetServiceName() const;
 
+    /** Sets form control specific properties. */
+    void                WriteToPropertySet( ScfPropertySet& rPropSet ) const;
+    /** Tries to fill the passed descriptor with imported macro data.
+        @return  true = Control is associated with a macro, rEvent contains valid data. */
+    bool                FillMacroDescriptor(
+                            ::com::sun::star::script::ScriptEventDescriptor& rEvent ) const;
+
+private:
     /** Reads the contents of the ftCbls sub structure in an OBJ record. */
     void                ReadCbls( XclImpStream& rStrm );
     /** Reads the contents of the ftCblsFmla sub structure in an OBJ record. */
@@ -325,23 +307,9 @@ public:
     /** Reads the contents of the ftMacro sub structure in an OBJ record. */
     void                ReadMacro( XclImpStream& rStrm );
 
-    /** Returns the complete component service name for this control. */
-    ::rtl::OUString     GetServiceName() const;
-
-    /** Sets form control specific properties. */
-    void                WriteToPropertySet( ScfPropertySet& rPropSet ) const;
-    /** Tries to fill the passed descriptor with imported macro data.
-        @return  true = Control is associated with a macro, rEvent contains valid data. */
-    bool                FillMacroDescriptor(
-                            ::com::sun::star::script::ScriptEventDescriptor& rEvent ) const;
-
-    /** Inserts the contained SdrObj into the draw page. */
-    virtual bool        Apply( ScfProgressBar& rProgress );
-
 private:
     ScfInt16Vec         maMultiSel;     /// Indexes of all selected entries in a multi selection.
     String              maMacroName;    /// Name of an attached macro.
-    sal_uInt16          mnCtrlType;     /// Type of the control from OBJ record.
     sal_uInt16          mnState;        /// Checked/unchecked state.
     sal_Int16           mnSelEntry;     /// Index of selected entry (1-based).
     sal_Int16           mnSelType;      /// Selection type.
@@ -358,49 +326,43 @@ private:
 
 // ----------------------------------------------------------------------------
 
-class XclImpDffManager;
-
 /** A common Escher OLE object, or an OLE form control. */
-class XclImpEscherOle : public XclImpEscherObj, public XclImpCtrlLinkHelper
+class XclImpOleObj : public XclImpDrawObjBase, public XclImpCtrlLinkHelper
 {
 public:
-    TYPEINFO();
+    explicit            XclImpOleObj( const XclImpRoot& rRoot );
 
-    /** Constructor takes ownership of the members of rSrcObj, which will be invalidated. */
-    explicit            XclImpEscherOle( XclImpEscherObj& rSrcObj );
+    /** Reads the contents of the specified subrecord of an OBJ record from stream. */
+    virtual void        ReadSubRecord( XclImpStream& rStrm, sal_uInt16 nSubRecId, sal_uInt16 nSubRecSize );
 
     /** Returns true, if this object is a form control, and false, if it is a common OLE object. */
     inline bool         IsControl() const { return mbControl; }
+    /** Sets the internal name for a form control. */
+    inline void         SetControlName( const String& rName ) { maCtrlName = rName; }
 
-    /** Returns control name indicated by MsofbtOPT property DFF_Prop_wzName if present*/
-    inline const ::rtl::OUString& GetName() const { return maName; }
     /** Returns the OLE storage name used in the Excel document. */
     inline const String& GetStorageName() const { return maStorageName; }
-    /** Returns the BLIP identifier for the meta file. */
-    inline sal_uInt32   GetBlipId() const { return mnBlipId; }
     /** Returns the position in Ctrl stream for additional form control data. */
     inline sal_uInt32   GetCtrlStreamPos() const { return mnCtrlStrmPos; }
+    /** Returns the internal name for a form control. */
+    inline const String& GetControlName() const { return maCtrlName; }
+
+    /** Sets form control specific properties. */
+    void                WriteToPropertySet( ScfPropertySet& rPropSet ) const;
 
-    /** Sets name indicated by MsofbtOPT property DFF_Prop_wzName. */
-    inline void         SetName( const ::rtl::OUString& rName ) { maName = rName; }
-    /** Sets the BLIP identifier for the meta file. */
-    inline void         SetBlipId( sal_uInt32 nBlipId ) { mnBlipId = nBlipId; }
+protected:
+    /** Overloaded to do additional processing on the SdrObject. */
+    virtual void        DoProcessSdrObj( SdrObject& rSdrObj ) const;
 
+private:
     /** Reads the contents of the ftPioGrbit sub structure in an OBJ record. */
     void                ReadPioGrbit( XclImpStream& rStrm );
     /** Reads the contents of the ftPictFmla sub structure in an OBJ record. */
     void                ReadPictFmla( XclImpStream& rStrm, sal_uInt16 nRecSize );
 
-    /** Sets form control specific properties. */
-    void                WriteToPropertySet( ScfPropertySet& rPropSet ) const;
-
-    /** Inserts the contained SdrObj into the draw page. */
-    virtual bool        Apply( ScfProgressBar& rProgress );
-
 private:
-    ::rtl::OUString     maName;         /// control name if form control
     String              maStorageName;  /// Name of the OLE storage for this object.
-    sal_uInt32          mnBlipId;       /// The BLIP identifier (meta file).
+    String              maCtrlName;     /// Internal name of a form control.
     sal_uInt32          mnCtrlStrmPos;  /// Position in Ctrl stream for controls.
     bool                mbAsSymbol;     /// true = Show as symbol.
     bool                mbLinked;       /// true = Linked; false = Embedded.
@@ -411,179 +373,172 @@ private:
 
 class XclImpChart;
 
-/** A chart object. This is the Escher object wrapper for the chart data. */
-class XclImpEscherChart : public XclImpEscherObj
+/** A chart object. This is the drawing object wrapper for the chart data. */
+class XclImpChartObj : public XclImpDrawObjBase
 {
 public:
-    TYPEINFO();
-
-    /** Constructor takes ownership of the members of rSrcObj, which will be invalidated.
-        @param bOwnTab  True = chart is on an own sheet; false = chart is an embedded object. */
-    explicit            XclImpEscherChart( XclImpEscherObj& rSrcObj, bool bOwnTab );
+    /** @param bOwnTab  True = chart is on an own sheet; false = chart is an embedded object. */
+    explicit            XclImpChartObj( const XclImpRoot& rRoot, bool bOwnTab );
 
     /** Reads the complete chart substream (BOF/EOF block).
         @descr  The passed stream must be located in the BOF record of the chart substream. */
     void                ReadChartSubStream( XclImpStream& rStrm );
 
+    /** Returns the embedded chart. */
+    inline const XclImpChart* GetChart() const { return mxChart.get(); }
+    /** Returns the object anchor of a sheet chart (chart fills one page). */
+    inline const Rectangle& GetAnchorRect() const { return maAnchorRect; }
+
+protected:
     /** Returns the needed size on the progress bar. */
-    virtual sal_uInt32  GetProgressSize() const;
-    /** Inserts the contained chart into the document. */
-    virtual bool        Apply( ScfProgressBar& rProgress );
+    virtual sal_uInt32  DoGetProgressSize() const;
 
 private:
-    /** Calculates and sets the object anchor of a sheet chart (chart fills one page). */
-    void                SetTabChartAnchor();
+    /** Calculates the anchor position of a sheet chart. */
+    void                CalcTabChartAnchor();
 
 private:
     typedef ScfRef< XclImpChart > XclImpChartRef;
+
     XclImpChartRef      mxChart;        /// The chart itself.
+    Rectangle           maAnchorRect;   /// Anchor position of sheet charts.
     bool                mbOwnTab;       /// true = own sheet; false = embedded object.
 };
 
-// Escher object data =========================================================
-
-/** Contains all information of an Escher object.
-    @descr  This is the Escher object itself (XclImpEscherObj) and the position
-    in the Calc document (XclEscherAnchor). */
-class XclImpObjData
-{
-public:
-    /** Takes ownership of pObj. */
-    explicit            XclImpObjData( XclImpEscherObj* pEscherObj );
-
-    /** Sets the passed Escher object, deletes the old. */
-    void                SetObj( XclImpEscherObj* pEscherObj );
-
-    /** Returns the Escher object, if present. */
-    inline XclImpEscherObj* GetObj() { return mxEscherObj.get(); }
-    /** Returns the anchor data. */
-    inline XclEscherAnchor& GetAnchor() { return maAnchor; }
-
-    /** Returns true, if the passed stream position is part of the current object. */
-    bool                ContainsStrmPos( ULONG nStrmPos ) const;
-    /** Returns the needed size on the progress bar. */
-    sal_uInt32          GetProgressSize() const;
-
-    /** Inserts the object into the Calc document. */
-    void                Apply( ScfProgressBar& rProgress );
-
-    /** Extends the passed range by the position of this object, if valid and on the specified sheet. */
-    void                ExtendUsedArea( const XclImpRoot& rRoot, ScRange& rScUsedArea, SCTAB nScTab ) const;
-
-private:
-    typedef ::std::auto_ptr< XclImpEscherObj > XclImpEscherObjPtr;
-
-    XclEscherAnchor     maAnchor;       /// The sheet position of the object.
-    XclImpEscherObjPtr  mxEscherObj;    /// The Escher object itself.
-    bool                mbInserted;     /// true = object inserted into drawing layer.
-};
-
-// ----------------------------------------------------------------------------
+// Escher stream conversion ===================================================
 
-/** This list contains all read Escher objects with their anchor positions. */
-class XclImpEscherObjList : protected XclImpRoot
+/** The solver container collects all connector rules for connected objects. */
+class XclImpSolverContainer : public SvxMSDffSolverContainer
 {
 public:
-    explicit            XclImpEscherObjList( const XclImpRoot& rRoot );
-
-    /** Returns the number of contained objects. */
-    inline ULONG        GetObjCount() const { return maObjDataList.Count(); }
-
-    /** Appends the passed object to the list. Takes ownership of the object. */
-    void                AppendObj( XclImpEscherObj* pEscherObj );
-    /** Appends the passed object as dummy (does not use it later). Takes ownership of the object. */
-    void                AppendDummyObj( XclImpEscherObj* pEscherObj );
-    /** Replaces the Escher object of the last inserted object data (or appends, if list is empty). */
-    void                ReplaceLastObj( XclImpEscherObj* pEscherObj );
-
-    /** Returns the object in the specified sheet by Excel object identifier. */
-    XclImpEscherObj*    GetObj( SCTAB nScTab, sal_uInt16 nObjId ) const;
-    /** Returns the object at the specified Escher stream position. */
-    XclImpEscherObj*    GetObj( ULONG nStrmPos ) const;
-    /** Returns the last inserted Escher object in the list. */
-    XclImpEscherObj*    GetLastObj() const;
+    /** Reads the entire solver container. Stream must point to begin of container header. */
+    void                ReadSolverContainer( SvStream& rEscherStrm );
 
-    /** Returns the anchor of the object at the passed Escher stream position. */
-    XclEscherAnchor*    GetAnchor( ULONG nStrmPos ) const;
-
-    /** Inserts all objects into the Calc document. */
-    void                Apply( ScfProgressBar& rProgress );
+    /** Inserts a new pointer to an SdrObject by the related shape ID. */
+    void                InsertSdrObjectInfo( const XclImpDrawObjBase& rDrawObj, SdrObject* pSdrObj );
+    /** Removes a pointer to an SdrObject by the related shape ID. */
+    void                RemoveSdrObjectInfo( const XclImpDrawObjBase& rDrawObj );
 
-    /** Extends the passed range by the positions of all valid objects in the specified sheet. */
-    void                ExtendUsedArea( ScRange& rScUsedArea, SCTAB nScTab ) const;
+    /** Inserts the SdrObject pointers into all connector rules. */
+    void                UpdateConnectorRules();
+    /** Removes all contained connector rules. */
+    void                RemoveConnectorRules();
 
 private:
-    /** Updates the cache data with the last inserted object for searching. */
-    void                UpdateCache();
-    /** Returns the object data of the Escher object at the specified Escher stream position. */
-    XclImpObjData*      FindObjData( ULONG nStrmPos ) const;
+    /** Returns the first connector rule from the internal list. */
+    SvxMSDffConnectorRule* GetFirstRule();
+    /** Returns the next connector rule from the internal list. */
+    SvxMSDffConnectorRule* GetNextRule();
+    /** Updates the data of a connected shape in a connector rule. */
+    void                UpdateConnection( sal_uInt32 nShapeId, SdrObject*& rpSdrObj, sal_uInt32* pnShapeFlags = 0 );
 
 private:
-    /** Stores data for each sheet to speed up the search for objects. */
-    struct XclCacheEntry
+    /** Stores data about an SdrObject processed during import. */
+    struct XclImpSdrInfo
     {
-        ULONG               mnListIdx;      /// List index of first object in the sheet.
-        ULONG               mnStrmPos;      /// First Escher stream position of the objects in the sheet.
-        inline explicit     XclCacheEntry( ULONG nListIdx, ULONG nStrmPos ) :
-                                mnListIdx( nListIdx ), mnStrmPos( nStrmPos ) {}
+        SdrObject*          mpSdrObj;       /// Pointer to an SdrObject.
+        sal_uInt32          mnShapeFlags;   /// Shape flags from escher stream.
+        inline explicit     XclImpSdrInfo() : mpSdrObj( 0 ), mnShapeFlags( 0 ) {}
+        inline void         Set( SdrObject* pSdrObj, sal_uInt32 nShapeFlags )
+                                { mpSdrObj = pSdrObj; mnShapeFlags = nShapeFlags; }
     };
+    typedef ::std::map< sal_uInt32, XclImpSdrInfo > XclImpSdrInfoMap;
 
-    typedef ScfDelList< XclImpObjData >     XclImpObjDataList;
-    typedef ::std::vector< XclCacheEntry >  XclCacheVec;
-
-    XclImpObjDataList   maObjDataList;      /// The list of all object data structs.
-    XclCacheVec         maObjCache;         /// Caches data to speed up object search.
+    XclImpSdrInfoMap    maSdrInfoMap;   /// Maps shape IDs to SdrObjects.
 };
 
-// Escher stream conversion ===================================================
+// ----------------------------------------------------------------------------
 
 class XclImpObjectManager;
+class XclImpOcxConverter;
 
 /** Derived from SvxMSDffManager, contains core implementation of Escher stream import. */
 class XclImpDffManager : public SvxMSDffManager, protected XclImpRoot
 {
 public:
     explicit            XclImpDffManager(
-                            const XclImpRoot& rRoot, XclImpObjectManager& rObjManager,
-                            long nOffsDgg, SvStream* pStData, SdrModel* pSdrModel,
-                            long nApplicationScale );
-
-    /** Converts an Escher object and creates and attaches the corresponding SdrObj. */
-    void                SetSdrObject(
-                            XclImpEscherObj* pEscherObj,
-                            ULONG nId,
-                            SvxMSDffImportData& rData );
-
-    /** Creates the SdrOle2Obj for the passed Escher OLE object from the OLE storage in the Excel file.
-        @return  true = SdrOle2Obj successfully created. */
-    bool                CreateSdrOleObj( XclImpEscherOle& rOleObj );
+                            const XclImpRoot& rRoot,
+                            XclImpObjectManager& rObjManager,
+                            SvStream& rEscherStrm );
+    virtual             ~XclImpDffManager();
+
+    /** Initializes the internal progress bar with the passed size and starts it. */
+    void                StartProgressBar( sal_uInt32 nProgressSize );
+    /** Processes the Escher stream, converts all objects. */
+    void                ProcessEscherStream( SvStream& rEscherStrm );
+    /** Processes a chart from an Excel chart sheet, converts it to a chart object. */
+    void                ProcessTabChart( const XclImpChartObj& rChartObj );
+
+    /** Returns the used area in the sheet with the passed index. */
+    ScRange             GetUsedArea( SCTAB nScTab ) const;
 
 protected:
     /** Reads the client anchor from the Escher stream and sets it at the correct Escher object. */
-    virtual void        ProcessClientAnchor2( SvStream& rStrm, DffRecordHeader&, void*, DffObjData& rObjData );
+    virtual void        ProcessClientAnchor2(
+                            SvStream& rEscherStrm,
+                            DffRecordHeader& rHeader,
+                            void* pClientData,
+                            DffObjData& rObjData );
     /** Processes an Escher object, reads properties from Escher stream. */
     virtual SdrObject*  ProcessObj(
-                            SvStream&,
+                            SvStream& rEscherStrm,
                             DffObjData& rObjData,
-                            void* pData,
+                            void* pClientData,
                             Rectangle& rTextRect,
-                            SdrObject* pRetSdrObj = 0 );
+                            SdrObject* pOldSdrObj = 0 );
     /** Returns the BLIP stream position, based on the passed Escher stream position. */
     virtual ULONG       Calc_nBLIPPos( ULONG nOrgVal, ULONG nStreamPos ) const;
     /** Returns a color from the Excel color palette. */
     virtual FASTBOOL    GetColorFromPalette( USHORT nIndex, Color& rColor ) const;
-    /** Returns true, if the object with the passed shape ID contains any text data. */
-    virtual sal_Bool    ShapeHasText( ULONG nShapeId, ULONG nFilePos ) const;
 
 private:
-    XclImpObjectManager& mrObjManager;  /// The Excel object manager.
-    sal_uInt32          mnOleImpFlags;  /// Application OLE import settings.
+    /** Reads a string property from the passed Escher stream. */
+    String              ReadStringProperty( SvStream& rEscherStrm, sal_uInt32 nPropId ) const;
+
+    /** Processes a drawing group container (global drawing data). */
+    void                ProcessDggContainer( SvStream& rEscherStrm, const DffRecordHeader& rDggHeader );
+    /** Processes a drawing container (all drawing data of a sheet). */
+    void                ProcessDgContainer( SvStream& rEscherStrm, const DffRecordHeader& rDgHeader );
+    /** Processes the global shape group container (all shapes of a sheet). */
+    void                ProcessShGrContainer( SvStream& rEscherStrm, const DffRecordHeader& rShGrHeader );
+    /** Processes the solver container (connectors of a sheet). */
+    void                ProcessSolverContainer( SvStream& rEscherStrm, const DffRecordHeader& rSolverHeader );
+    /** Processes a shape or shape group container (one top-level shape). */
+    void                ProcessShContainer( SvStream& rEscherStrm, const DffRecordHeader& rShHeader );
+
+    /** Returns the OCX converter (OCX form controls converter). */
+    XclImpOcxConverter& GetOcxConverter();
+
+    /** Inserts the passed SdrObject into the document. This function takes ownership of pSdrObj! */
+    void                InsertSdrObject( const XclImpDrawObjBase& rDrawObj, SdrObject* pSdrObj );
+
+    /** Tries to create a custom SdrObject for specific object types. */
+    SdrObject*          CreateCustomSdrObject( const XclImpDrawObjBase& rDrawObj, const Rectangle& rAnchorRect );
+    /** Creates the SdrObject for the passed Excel OLE object. */
+    SdrObject*          CreateSdrObject( const XclImpOleObj& rOleObj, const Rectangle& rAnchorRect );
+    /** Creates the SdrObject for the passed Excel textbox control object. */
+    SdrObject*          CreateSdrObject( const XclImpTbxControlObj& rTbxCtrlObj, const Rectangle& rAnchorRect );
+    /** Creates the SdrObject for the passed Excel chart object. */
+    SdrObject*          CreateSdrObject( const XclImpChartObj& rChartObj, const Rectangle& rAnchorRect );
+
+    /** Updates the used area of a sheet with the position and size of the passed object. */
+    void                UpdateUsedArea( const XclImpDrawObjBase& rDrawObj );
+
+private:
+    typedef ::std::map< SCTAB, ScRange >    ScRangeMap;
+    typedef ScfRef< ScfProgressBar >        ScfProgressBarRef;
+    typedef ScfRef< XclImpOcxConverter >    XclImpOcxConvRef;
+
+    XclImpObjectManager& mrObjManager;      /// The Excel object manager.
+    XclImpSolverContainer maSolverCont;     /// The solver container for connector rules.
+    ScRangeMap          maUsedAreaMap;      /// Used ranges for all sheets.
+    ScfProgressBarRef   mxProgress;         /// The progress bar used in ProcessObj().
+    XclImpOcxConvRef    mxOcxConverter;     /// The form controls converter.
+    sal_uInt32          mnOleImpFlags;      /// Application OLE import settings.
 };
 
 // The object manager =========================================================
 
-class XclImpOcxConverter;
-
 /** Stores all drawing and OLE objects and additional data related to these objects. */
 class XclImpObjectManager : protected XclImpRoot
 {
@@ -591,151 +546,76 @@ public:
     explicit            XclImpObjectManager( const XclImpRoot& rRoot );
     virtual             ~XclImpObjectManager();
 
-    // *** Escher stream *** --------------------------------------------------
-
-    /** Returns true, if the Escher stream contains any data. */
-    inline bool         HasEscherStream() { return maStreamConsumer.HasData(); }
-    /** Returns the Escher stream. */
-    inline SvStream&    GetEscherStream() { return maStreamConsumer.GetStream(); }
-
-    // *** Escher objects *** -------------------------------------------------
-
-    /** Returns the number of contained objects. */
-    inline ULONG        GetEscherObjCount() const { return maEscherObjList.GetObjCount(); }
-
-    /** Returns the object in the specified sheet by Excel object identifier. */
-    const XclImpEscherObj* GetEscherObj( SCTAB nScTab, sal_uInt16 nObjId ) const;
-    /** Returns access to the object in the specified sheet by Excel object identifier. */
-    XclImpEscherObj*    GetEscherObjAcc( SCTAB nScTab, sal_uInt16 nObjId );
-
-    /** Returns the object at the specified Escher stream position. */
-    const XclImpEscherObj* GetEscherObj( ULONG nStrmPos ) const;
-    /** Returns access to the object at the specified Escher stream position. */
-    XclImpEscherObj*    GetEscherObjAcc( ULONG nStrmPos );
-
-    /** Returns the last inserted object in the list. */
-    const XclImpEscherObj* GetLastEscherObj() const;
-    /** Returns access to the last inserted object in the list. */
-    XclImpEscherObj*    GetLastEscherObjAcc();
-
-    /** Returns the anchor of the object at the passed Escher stream position. */
-    const XclEscherAnchor* GetEscherAnchor( ULONG nStrmPos ) const;
-    /** Returns access to the anchor of the object at the passed Escher stream position. */
-    XclEscherAnchor*    GetEscherAnchorAcc( ULONG nStrmPos );
-
-    // *** Text boxes *** -----------------------------------------------------
-
-    /** Returns the textbox object at the specified Escher stream position. */
-    const XclImpEscherTxo* GetEscherTxo( ULONG nStrmPos ) const;
-    /** Returns access to the textbox object at the specified Escher stream position. */
-    XclImpEscherTxo*    GetEscherTxoAcc( ULONG nStrmPos );
-
-    /** Returns the note object in the specified sheet by Excel object identifier. */
-    const XclImpEscherNote* GetEscherNote( SCTAB nScTab, sal_uInt16 nObjId ) const;
-
-    // *** Chart *** ----------------------------------------------------------
-
-    /** Inserts a new chart object.
-        @descr  Used to import sheet charts, which do not have a corresponding OBJ record. */
-    void                StartNewChartObj();
-
-    // *** OLE / controls *** -------------------------------------------------
-
-    /** Creates the SdrObj for an OLE Escher object.
-        @descr  The passed object may be a common OLE object, then this function creates
-        the internal OLE stream. Or it is a form control, then this function reads the
-        control formatting data from the 'Ctls' stream. */
-    bool                CreateSdrObj( XclImpEscherOle& rOleObj );
-    /** Creates the SdrObj for an old-fashioned Escher control object. */
-    bool                CreateSdrObj( XclImpEscherTbxCtrl& rCtrlObj );
-
     // *** Read Excel records *** ---------------------------------------------
 
     /** Reads the MSODRAWINGGROUP record. */
-    void                ReadMsodrawinggroup( XclImpStream& rStrm );
+    void                ReadMsoDrawingGroup( XclImpStream& rStrm );
     /** Reads the MSODRAWING record. */
-    void                ReadMsodrawing( XclImpStream& rStrm );
+    void                ReadMsoDrawing( XclImpStream& rStrm );
     /** Reads the MSODRAWINGSELECTION record. */
-    void                ReadMsodrawingselection( XclImpStream& rStrm );
+    void                ReadMsoDrawingSelection( XclImpStream& rStrm );
 
     /** Reads the OBJ record. */
     void                ReadObj( XclImpStream& rStrm );
     /** Reads the TXO record. */
     void                ReadTxo( XclImpStream& rStrm );
+    /** Reads the NOTE record. */
+    void                ReadNote( XclImpStream& rStrm );
 
-    /** Reads a complete chart substream (BOF/EOF block) for the last started chart.
-        @descr  The passed stream must be located in the BOF record of the chart substream. */
-    void                ReadChartSubStream( XclImpStream& rStrm );
-
-    // *** Misc *** -----------------------------------------------------------
+    /** Inserts a new chart object and reads the chart substream (BOF/EOF block).
+        @descr  Used to import sheet charts, which do not have a corresponding OBJ record. */
+    void                ReadTabChart( XclImpStream& rStrm );
 
-    /** Lets the object manager add a dummy object, before the next object is read. */
-    inline void         InsertDummyObj() { mbStartWithDummy = true; }
+    // *** Drawing objects *** ------------------------------------------------
 
-    /** Returns the DFF manager (Escher stream converter). Don't call before the Escher stream is read. */
-    XclImpDffManager&   GetDffManager();
-    /** Updates the connector rules of the passed object in the solver container. */
-    void                UpdateConnectorRules( const DffObjData& rObjData, SdrObject& rSdrObj );
+    /** Finds the OBJ record data related to the Escher shape at the passed position. */
+    XclImpDrawObjRef    FindDrawObj( const DffRecordHeader& rHeader ) const;
+    /** Finds the OBJ record data specified by the passed object identifier. */
+    XclImpDrawObjRef    FindDrawObj( const XclObjId& rObjId ) const;
+    /** Finds the TXO record data related to the Escher shape at the passed position. */
+    XclImpTxoDataRef    FindTxoData( const DffRecordHeader& rHeader ) const;
 
     /** Sets the object with the passed identification to be ignored on import. */
-    void                SetSkipObj( SCTAB nScTab, sal_uInt16 nObjId );
+    void                SetInvalidObj( SCTAB nScTab, sal_uInt16 nObjId );
 
+    // *** Drawing object conversion *** --------------------------------------
+
+    /** Returns the DFF manager (Escher stream converter). Don't call before the Escher stream is read. */
+    XclImpDffManager&   GetDffManager();
     /** Inserts all objects into the Calc document. */
-    void                Apply( ScfProgressBar& rProgress );
+    void                ConvertObjects();
 
-    /** Extends the passed range by the positions of all valid objects in the specified sheet. */
-    void                ExtendUsedArea( ScRange& rScUsedArea, SCTAB nScTab ) const;
+    /** Returns the used area in the sheet with the passed index. */
+    ScRange             GetUsedArea( SCTAB nScTab ) const;
 
     // ------------------------------------------------------------------------
 private:
-    /** Appends the passed object to the list. */
-    void                AppendEscherObj( XclImpEscherObj* pEscherObj );
-    /** Replaces the last object in the list with the passed object. */
-    void                ReplaceEscherObj( XclImpEscherObj* pEscherObj );
-
-    /** Reads the ftCmo sub structure (common object data) in an OBJ record.
-        @return  The new Escher object. */
-    void                ReadObjFtCmo( XclImpStream& rStrm );
-    /** Reads the ftPioGrbit sub structure (object option flags) in an OBJ record. */
-    void                ReadObjFtPioGrbit( XclImpStream& rStrm );
-    /** Reads the ftPictFmla sub structure (OLE link formula) in an OBJ record. */
-    void                ReadObjFtPictFmla( XclImpStream& rStrm, sal_uInt16 nRecSize );
-
-    /** Reads a sub record for TBX form controls in an OBJ record. */
-    void                ReadObjTbxSubRec( XclImpStream& rStrm, sal_uInt16 nSubRecId );
-
-    /** Returns the OCX converter (OCX form controls converter). */
-    XclImpOcxConverter& GetOcxConverter();
-
-    /** Returns the solver container (for connector rules). */
-    SvxMSDffSolverContainer& GetSolverContainer();
-    /** Returns the first connector rule from the solver container. */
-    SvxMSDffConnectorRule* GetFirstConnectorRule();
-    /** Returns the next connector rule from the solver container. */
-    SvxMSDffConnectorRule* GetNextConnectorRule();
-
-    /** Identifies an Escher object to skip on import (will not be inserted into the Calc document). */
-    struct XclSkipObj
-    {
-        SCTAB               mnScTab;        /// Calc sheet index.
-        sal_uInt16          mnObjId;        /// Excel object identifier.
-        inline explicit     XclSkipObj( SCTAB nScTab, sal_uInt16 nObjId ) :
-                                mnScTab( nScTab ), mnObjId( nObjId ) {}
-    };
+    /** Reads contents of an Escher record and append data to internal Escher stream. */
+    void                ReadEscherRecord( XclImpStream& rStrm );
+    /** Reads a complete chart substream (BOF/EOF block) for an embedded chart object.
+        @descr  The passed stream must be located in the BOF record of the chart substream. */
+    void                ReadChartSubStream( XclImpStream& rStrm, XclImpChartObj& rChartObj );
 
-    typedef ::std::auto_ptr< XclImpDffManager >         XclImpDffManagerPtr;
-    typedef ::std::auto_ptr< SvxMSDffSolverContainer >  SolverContainerPtr;
-    typedef ::std::auto_ptr< XclImpOcxConverter >       XclImpOcxConverterPtr;
-    typedef ::std::vector< XclSkipObj >                 XclSkipObjVec;
-
-    XclImpStreamConsumer maStreamConsumer;  /// Collects the entire Escher stream.
-    XclImpEscherObjList maEscherObjList;    /// Contains all Escher objects.
-    SolverContainerPtr  mxSolverContainer;  /// The solver container for connector rules.
-    XclImpDffManagerPtr mxDffManager;       /// The Escher stream converter.
-    XclImpOcxConverterPtr mxOcxConverter;   /// The form controls converter.
-    XclSkipObjVec       maSkipObjVec;       /// All Escher objects to skip.
+    /** Returns the size of the progress bar shown while processing all objects. */
+    sal_uInt32          GetProgressSize() const;
 
-    bool                mbStartWithDummy;   /// true = Insert a dummy object before the next Escher object.
+    // ------------------------------------------------------------------------
+private:
+    typedef ::std::map< ULONG, XclImpDrawObjRef >       XclImpObjMap;
+    typedef ::std::map< XclObjId, XclImpDrawObjRef >    XclImpObjMapById;
+    typedef ::std::map< ULONG, XclImpTxoDataRef >       XclImpTxoMap;
+    typedef ScfRef< XclImpChartObj >                    XclImpChartObjRef;
+    typedef ::std::list< XclImpChartObjRef >            XclImpChartObjList;
+    typedef ScfRef< XclImpDffManager >                  XclImpDffMgrRef;
+    typedef ::std::vector< XclObjId >                   XclObjIdVec;
+
+    SvMemoryStream      maEscherStrm;       /// Copy of Escher stream in memory.
+    XclImpObjMap        maObjMap;           /// Maps drawing objects to Escher stream position.
+    XclImpObjMapById    maObjMapId;         /// Maps drawing objects to sheet index and object ID.
+    XclImpTxoMap        maTxoMap;           /// Maps TXO textbox data to sheet index and object ID.
+    XclImpChartObjList  maTabCharts;        /// Charts imported from Excel chart sheets.
+    XclImpDffMgrRef     mxDffManager;       /// The Escher stream converter.
+    XclObjIdVec         maInvalidObjs;      /// All Escher objects to skip.
 };
 
 // Escher property set helper =================================================
Index: sc/source/filter/inc/xiname.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xiname.hxx,v
retrieving revision 1.2
retrieving revision 1.2.84.1
diff -u -p -u -p -r1.2 -r1.2.84.1
--- sc/source/filter/inc/xiname.hxx	14 Jan 2005 12:12:04 -0000	1.2
+++ sc/source/filter/inc/xiname.hxx	23 Jun 2005 11:48:25 -0000	1.2.84.1
@@ -82,7 +82,7 @@ class ScRangeData;
 class XclImpName : protected XclImpRoot
 {
 public:
-    explicit            XclImpName( XclImpStream& rStrm, sal_uInt16 nScIndex );
+    explicit            XclImpName( XclImpStream& rStrm, sal_uInt16 nXclNameIdx );
 
     inline const String& GetXclName() const { return maXclName; }
     inline const String& GetScName() const { return maScName; }
Index: sc/source/filter/inc/xiroot.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xiroot.hxx,v
retrieving revision 1.16
retrieving revision 1.16.4.1
diff -u -p -u -p -r1.16 -r1.16.4.1
--- sc/source/filter/inc/xiroot.hxx	29 Mar 2005 13:46:25 -0000	1.16
+++ sc/source/filter/inc/xiroot.hxx	10 Aug 2005 14:41:13 -0000	1.16.4.1
@@ -58,6 +58,7 @@
  *
  *
  ************************************************************************/
+
 #ifndef SC_XIROOT_HXX
 #define SC_XIROOT_HXX
 
@@ -92,6 +93,7 @@ class XclImpAutoFilterBuffer;
 class XclImpWebQueryBuffer;
 class XclImpPivotTableManager;
 class XclImpPageSettings;
+class XclImpDocViewSettings;
 class XclImpTabViewSettings;
 
 /** Stores global buffers and data needed for Excel import filter. */
@@ -112,6 +114,7 @@ struct XclImpRootData : public XclRootDa
     typedef ScfRef< XclImpWebQueryBuffer >      XclImpWebQueryBfrRef;
     typedef ScfRef< XclImpPivotTableManager >   XclImpPTableMgrRef;
     typedef ScfRef< XclImpPageSettings >        XclImpPageSettRef;
+    typedef ScfRef< XclImpDocViewSettings >     XclImpDocViewSettRef;
     typedef ScfRef< XclImpTabViewSettings >     XclImpTabViewSettRef;
 
     XclImpAddrConvRef   mxAddrConv;         /// The address converter.
@@ -132,6 +135,7 @@ struct XclImpRootData : public XclRootDa
     XclImpPTableMgrRef  mxPTableMgr;        /// All pivot tables and pivot caches.
 
     XclImpPageSettRef   mxPageSett;         /// Page settings for current sheet.
+    XclImpDocViewSettRef mxDocViewSett;     /// View settings for entire document.
     XclImpTabViewSettRef mxTabViewSett;     /// View settings for current sheet.
 
     explicit            XclImpRootData( XclBiff eBiff, SfxMedium& rMedium,
@@ -199,6 +203,8 @@ public:
 
     /** Returns the page settings of the current sheet. */
     XclImpPageSettings& GetPageSettings() const;
+    /** Returns the view settings of the entire document. */
+    XclImpDocViewSettings& GetDocViewSettings() const;
     /** Returns the view settings of the current sheet. */
     XclImpTabViewSettings& GetTabViewSettings() const;
 
Index: sc/source/filter/inc/xiview.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xiview.hxx,v
retrieving revision 1.2
retrieving revision 1.2.36.1
diff -u -p -u -p -r1.2 -r1.2.36.1
--- sc/source/filter/inc/xiview.hxx	21 Feb 2005 13:46:08 -0000	1.2
+++ sc/source/filter/inc/xiview.hxx	10 Aug 2005 14:41:14 -0000	1.2.36.1
@@ -58,6 +58,7 @@
  *
  *
  ************************************************************************/
+
 #ifndef SC_XIVIEW_HXX
 #define SC_XIVIEW_HXX
 
@@ -68,6 +69,27 @@
 #include "xiroot.hxx"
 #endif
 
+// Document view settings =====================================================
+
+/** Contains document view settings (WINDOW1 record). */
+class XclImpDocViewSettings : protected XclImpRoot
+{
+public:
+    explicit            XclImpDocViewSettings( const XclImpRoot& rRoot );
+
+    /** Reads a WINDOW1 record. */
+    void                ReadWindow1( XclImpStream& rStrm );
+
+    /** Returns the Calc index of the displayed sheet. */
+    SCTAB               GetDisplScTab() const;
+
+    /** Sets the view settings at the document. */
+    void                Finalize();
+
+private:
+    XclDocViewData      maData;         /// Document view settings data.
+};
+
 // Sheet view settings ========================================================
 
 /** Contains all view settings for a single sheet.
Index: sc/source/filter/inc/xlchart.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlchart.hxx,v
retrieving revision 1.2
retrieving revision 1.2.4.3
diff -u -p -u -p -r1.2 -r1.2.4.3
--- sc/source/filter/inc/xlchart.hxx	29 Mar 2005 13:46:49 -0000	1.2
+++ sc/source/filter/inc/xlchart.hxx	9 Aug 2005 16:29:55 -0000	1.2.4.3
@@ -159,6 +159,10 @@
 
 // Constants and Enumerations =================================================
 
+const sal_uInt32 EXC_CHART_PROGRESS_SIZE        = 10;
+
+// ----------------------------------------------------------------------------
+
 /** Enumerates possible orientations for a source range. */
 enum XclChOrientation
 {
@@ -607,6 +611,10 @@ const sal_uInt8 EXC_CH3DDATAFORMAT_STRAI
 const sal_uInt8 EXC_CH3DDATAFORMAT_SHARP        = 1;        /// Sharp top.
 const sal_uInt8 EXC_CH3DDATAFORMAT_TRUNC        = 2;        /// Shart top, truncated.
 
+// (0x1061) CHPIEEXT ----------------------------------------------------------
+
+const sal_uInt16 EXC_ID_CHPIEEXT                = 0x1061;
+
 // (0x1066) CHESCHERFORMAT ----------------------------------------------------
 
 const sal_uInt16 EXC_ID_CHESCHERFORMAT          = 0x1066;
@@ -624,6 +632,21 @@ const sal_uInt16 EXC_ID_CHUNKNOWN       
 // Structs and classes
 // ============================================================================
 
+// Common =====================================================================
+
+/** Specifies the position of a data point or of an entire series. */
+struct XclChPoint
+{
+    sal_uInt16          mnSeriesIdx;        /// Series index of a data point.
+    sal_uInt16          mnPointIdx;         /// Point index of a data point.
+
+    explicit            XclChPoint();
+    explicit            XclChPoint( sal_uInt16 nSeriesIdx, sal_uInt16 nPointIdx );
+};
+
+bool operator==( const XclChPoint& rL, const XclChPoint& rR );
+bool operator<( const XclChPoint& rL, const XclChPoint& rR );
+
 // Formatting =================================================================
 
 struct XclChPos
@@ -714,9 +737,8 @@ struct XclChFrame
 
 struct XclChObjectLink
 {
+    XclChPoint          maPos;              /// Position of the data point.
     sal_uInt16          mnTarget;           /// Target of the link.
-    sal_uInt16          mnSeriesIdx;        /// Series index for series/point labels.
-    sal_uInt16          mnPointIdx;         /// Point index for series/point labels.
 
     explicit            XclChObjectLink();
 };
@@ -754,8 +776,7 @@ struct XclChSourceLink
 
 struct XclChDataFormat
 {
-    sal_uInt16          mnPointIdx;         /// 0-based data point index.
-    sal_uInt16          mnSeriesIdx;        /// 0-based series index.
+    XclChPoint          maPos;              /// Position of the data point or series.
     sal_uInt16          mnFormatIdx;        /// Formatting index for automatic colors.
     sal_uInt16          mnFlags;            /// Additional flags.
 
Index: sc/source/filter/inc/xlconst.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlconst.hxx,v
retrieving revision 1.24
retrieving revision 1.24.36.2
diff -u -p -u -p -r1.24 -r1.24.36.2
--- sc/source/filter/inc/xlconst.hxx	21 Feb 2005 13:46:35 -0000	1.24
+++ sc/source/filter/inc/xlconst.hxx	9 Aug 2005 16:29:55 -0000	1.24.36.2
@@ -108,6 +108,8 @@ const SCTAB SCTAB_GLOBAL                
 
 // Storage/stream names -------------------------------------------------------
 
+#define EXC_STORAGE_OLE_LINKED              CREATE_STRING( "LNK" )
+#define EXC_STORAGE_OLE_EMBEDDED            CREATE_STRING( "MBD" )
 #define EXC_STORAGE_VBA_PROJECT             CREATE_STRING( "_VBA_PROJECT_CUR" )
 #define EXC_STORAGE_VBA                     CREATE_STRING( "VBA" )
 
@@ -186,10 +188,11 @@ const sal_uInt16 EXC_BOF_BIFF8          
 
 const sal_uInt16 EXC_BOF_GLOBALS            = 0x0005;   /// BIFF5-BIFF8 workbook globals.
 const sal_uInt16 EXC_BOF_VBMODULE           = 0x0006;   /// BIFF5-BIFF8 Visual BASIC module.
-const sal_uInt16 EXC_BOF_SHEET              = 0x0010;   /// Simple worksheet.
-const sal_uInt16 EXC_BOF_CHART              = 0x0020;   /// Chart-only sheet.
-const sal_uInt16 EXC_BOF_MACROSHEET         = 0x0040;   /// BIFF2-BIFF4 macro sheet.
-const sal_uInt16 EXC_BOF_WORKSPACE          = 0x0100;   /// BIFF3-BIFF8 workspace file.
+const sal_uInt16 EXC_BOF_SHEET              = 0x0010;   /// Regular worksheet.
+const sal_uInt16 EXC_BOF_CHART              = 0x0020;   /// Chart sheet.
+const sal_uInt16 EXC_BOF_MACROSHEET         = 0x0040;   /// Macro sheet.
+const sal_uInt16 EXC_BOF_WORKSPACE          = 0x0100;   /// Workspace.
+const sal_uInt16 EXC_BOF_UNKNOWN            = 0xFFFF;   /// Internal use only.
 
 // (0x000A) EOF ---------------------------------------------------------------
 
Index: sc/source/filter/inc/xlescher.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlescher.hxx,v
retrieving revision 1.15
retrieving revision 1.15.4.1
diff -u -p -u -p -r1.15 -r1.15.4.1
--- sc/source/filter/inc/xlescher.hxx	29 Mar 2005 13:47:03 -0000	1.15
+++ sc/source/filter/inc/xlescher.hxx	9 Aug 2005 16:29:56 -0000	1.15.4.1
@@ -65,7 +65,6 @@
 #ifndef _VCL_MAPUNIT_HXX
 #include <vcl/mapunit.hxx>
 #endif
-
 #ifndef SC_XLADDRESS_HXX
 #include "xladdress.hxx"
 #endif
@@ -129,7 +128,7 @@ const sal_uInt16 EXC_OBJ_CMO_NOTE       
 const sal_uInt16 EXC_OBJ_CMO_DRAWING        = 0x001E;
 const sal_uInt16 EXC_OBJ_CMO_UNKNOWN        = 0xFFFF;   /// For internal use only.
 
-// ftCmoGrbit: flags
+// ftCmo: flags
 const sal_uInt16 EXC_OBJ_CMO_PRINTABLE      = 0x0010;   /// Object printable
 
 // ftPioGrbit: flags
@@ -169,9 +168,13 @@ const sal_Int16 EXC_OBJ_SBS_MAXSCROLL   
 enum XclCtrlBindMode
 {
     xlBindContent,      /// Binds cell to content of control.
-    xlBindPosition      /// Binds cell to position in control (i.e. listbox selection index).
+    xlBindPosition      /// Binds cell to position in control (e.g. listbox selection index).
 };
 
+// (0x00EB) MSODRAWINGGROUP ---------------------------------------------------
+
+const sal_uInt16 EXC_ID_MSODRAWINGGROUP     = 0x00EB;
+
 // (0x00EC) MSODRAWING --------------------------------------------------------
 
 const sal_uInt16 EXC_ID_MSODRAWING          = 0x00EC;
@@ -181,43 +184,32 @@ const sal_uInt16 EXC_ESC_ANCHOR_POSLOCKE
 const sal_uInt16 EXC_ESC_ANCHOR_SIZELOCKED  = 0x0002;
 const sal_uInt16 EXC_ESC_ANCHOR_LOCKED      = EXC_ESC_ANCHOR_POSLOCKED|EXC_ESC_ANCHOR_SIZELOCKED;
 
-// (0x01B6) TXO ---------------------------------------------------------------
+// (0x00ED) MSODRAWINGSELECTION -----------------------------------------------
 
-const sal_uInt16 EXC_ID_TXO                 = 0x01B6;
+const sal_uInt16 EXC_ID_MSODRAWINGSEL       = 0x00ED;
 
-/** Horizontal alignment flags. */
-enum XclTxoHorAlign
-{
-    xlTxoHAlignLeft                         = 0x01,
-    xlTxoHAlignCenter                       = 0x02,
-    xlTxoHAlignRight                        = 0x03,
-    xlTxoHAlignJustify                      = 0x04,
-    xlTxoHAlign_Default                     = xlTxoHAlignLeft
-};
+// (0x01B6) TXO ---------------------------------------------------------------
 
-/** Vertical alignment flags. */
-enum XclTxoVerAlign
-{
-    xlTxoVAlignTop                          = 0x01,
-    xlTxoVAlignCenter                       = 0x02,
-    xlTxoVAlignBottom                       = 0x03,
-    xlTxoVAlignJustify                      = 0x04,
-    xlTxoVAlign_Default                     = xlTxoVAlignTop
-};
+const sal_uInt16 EXC_ID_TXO                 = 0x01B6;
 
-/** Rotation. */
-enum XclTxoRotation
-{
-    xlTxoNoRot                              = 0x0000,       /// Not rotated.
-    xlTxoRotStacked                         = 0x0001,       /// characters stacked.
-    xlTxoRot90ccw                           = 0x0002,       /// 90 degr. counterclockwise.
-    xlTxoRot90cw                            = 0x0003,       /// 90 degr. clockwise.
-    xlTxoRot_Default                        = xlTxoNoRot
-};
+const sal_uInt8 EXC_TXO_HOR_LEFT            = 0x01;
+const sal_uInt8 EXC_TXO_HOR_CENTER          = 0x02;
+const sal_uInt8 EXC_TXO_HOR_RIGHT           = 0x03;
+const sal_uInt8 EXC_TXO_HOR_JUSTIFY         = 0x04;
+
+const sal_uInt8 EXC_TXO_VER_TOP             = 0x01;
+const sal_uInt8 EXC_TXO_VER_CENTER          = 0x02;
+const sal_uInt8 EXC_TXO_VER_BOTTOM          = 0x03;
+const sal_uInt8 EXC_TXO_VER_JUSTIFY         = 0x04;
+
+const sal_uInt16 EXC_TXO_TEXTROT_NONE       = 0x0000;
+const sal_uInt16 EXC_TXO_TEXTROT_STACKED    = 0x0001;      /// Stacked top to bottom.
+const sal_uInt16 EXC_TXO_TEXTROT_90_CCW     = 0x0002;      /// 90 degr. counterclockwise.
+const sal_uInt16 EXC_TXO_TEXTROT_90_CW      = 0x0003;      /// 90 degr. clockwise.
 
 // Structs and classes ========================================================
 
-// Escher client anchor =======================================================
+// Escher client anchor -------------------------------------------------------
 
 class Rectangle;
 class ScDocument;
@@ -249,7 +241,44 @@ SvStream& operator<<( SvStream& rStrm, c
 XclImpStream& operator>>( XclImpStream& rStrm, XclEscherAnchor& rAnchor );
 XclExpStream& operator<<( XclExpStream& rStrm, const XclEscherAnchor& rAnchor );
 
-// ============================================================================
+// ----------------------------------------------------------------------------
+
+/** Identifies an Escher object by sheet index and object identifier. */
+struct XclObjId
+{
+    SCTAB               mnScTab;        /// Calc sheet index.
+    sal_uInt16          mnObjId;        /// Excel object identifier.
+
+    explicit            XclObjId();
+    explicit            XclObjId( SCTAB nScTab, sal_uInt16 nObjId );
+};
+
+bool operator==( const XclObjId& rL, const XclObjId& rR );
+bool operator<( const XclObjId& rL, const XclObjId& rR );
+
+// ----------------------------------------------------------------------------
+
+/** Contains data of a TXO record for text boxes. */
+struct XclTxoData
+{
+    sal_uInt16          mnFlags;        /// Option flags and alignment.
+    sal_uInt16          mnOrient;       /// Text orientation.
+    sal_uInt16          mnTextLen;      /// Length of the string.
+    sal_uInt16          mnFormatSize;   /// Size of the format run buffer (bytes).
+
+    explicit            XclTxoData();
+
+    sal_uInt8           GetXclHorAlignment() const;
+    void                SetXclHorAlignment( sal_uInt8 nXclAlign );
+
+    sal_uInt8           GetXclVerAlignment() const;
+    void                SetXclVerAlignment( sal_uInt8 nXclAlign );
+};
+
+XclImpStream& operator>>( XclImpStream& rStrm, XclTxoData& rData );
+XclExpStream& operator<<( XclExpStream& rStrm, const XclTxoData& rData );
+
+// ----------------------------------------------------------------------------
 
 /** Provides static helper functions for textbox (TBX) form controls. */
 class XclTbxControlHelper
Index: sc/source/filter/inc/xlformula.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlformula.hxx,v
retrieving revision 1.4
retrieving revision 1.4.150.1
diff -u -p -u -p -r1.4 -r1.4.150.1
--- sc/source/filter/inc/xlformula.hxx	9 Nov 2004 15:09:01 -0000	1.4
+++ sc/source/filter/inc/xlformula.hxx	19 Apr 2005 14:47:17 -0000	1.4.150.1
@@ -282,6 +282,8 @@ class XclTokenArrayIterator
 public:
     explicit            XclTokenArrayIterator();
     explicit            XclTokenArrayIterator( const ScTokenArray& rScTokArr, bool bSkipSpaces );
+    /** Copy constructor that allowa to change the skip-spaces mode. */
+    explicit            XclTokenArrayIterator( const XclTokenArrayIterator& rTokArrIt, bool bSkipSpaces );
 
     void                Init();
     void                Init( const ScTokenArray& rScTokArr, bool bSkipSpaces );
Index: sc/source/filter/inc/xlocx.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlocx.hxx,v
retrieving revision 1.11
retrieving revision 1.11.84.1
diff -u -p -u -p -r1.11 -r1.11.84.1
--- sc/source/filter/inc/xlocx.hxx	14 Jan 2005 12:13:23 -0000	1.11
+++ sc/source/filter/inc/xlocx.hxx	9 Aug 2005 16:29:56 -0000	1.11.84.1
@@ -105,8 +105,10 @@ private:
 
 // ----------------------------------------------------------------------------
 
-class XclImpEscherOle;
-class XclImpEscherTbxCtrl;
+class Rectangle;
+class SdrObject;
+class XclImpOleObj;
+class XclImpTbxControlObj;
 class XclImpCtrlLinkHelper;
 
 /** Converter for import of OXC controls. */
@@ -115,16 +117,13 @@ class XclImpOcxConverter : public XclOcx
 public:
     explicit            XclImpOcxConverter( const XclImpRoot& rRoot );
 
-    /** Reads the control formatting data for the passed object and creates the SdrUnoObj.
-        @return  true = SdrUnoObj successfully created. */
-    bool                CreateSdrUnoObj( XclImpEscherOle& rOleObj );
-
-    /** Creates the SdrUnoObj for the passed TBX form control object.
-        @return  true = SdrUnoObj successfully created. */
-    bool                CreateSdrUnoObj( XclImpEscherTbxCtrl& rTbxCtrl );
+    /** Reads the control formatting data for the passed object and creates the SdrUnoObj. */
+    SdrObject*          CreateSdrObject( const XclImpOleObj& rOcxCtrlObj, const Rectangle& rAnchorRect );
+    /** Creates the SdrUnoObj for the passed TBX form control object. */
+    SdrObject*          CreateSdrObject( const XclImpTbxControlObj& rTbxCtrlObj, const Rectangle& rAnchorRect );
 
 private:
-    /** Inserts the passed control rxFComp into the document. */
+    /** Inserts the passed control rxFComp into the form. */
     virtual sal_Bool    InsertControl(
                             const ::com::sun::star::uno::Reference<
                                 ::com::sun::star::form::XFormComponent >& rxFComp,
@@ -133,13 +132,18 @@ private:
                                 ::com::sun::star::drawing::XShape >* pxShape,
                             BOOL bFloatingCtrl );
 
+    /** Returns the SdrObject from the passed shape. Sets the passed anchor rectangle. */
+    SdrObject*          GetSdrObject(
+                            const ::com::sun::star::uno::Reference<
+                                ::com::sun::star::drawing::XShape >& rxShape,
+                            const Rectangle& rAnchorRect ) const;
     /** Tries to set a spreadsheet cell link and source range link at the passed form control. */
     void                ConvertSheetLinks(
                             const ::com::sun::star::uno::Reference<
                                 ::com::sun::star::awt::XControlModel >& rxModel,
                             const XclImpCtrlLinkHelper& rControl ) const;
     /** Tries to register a Basic macro for the control. */
-    void                RegisterTbxMacro( XclImpEscherTbxCtrl& rTbxCtrl );
+    void                RegisterTbxMacro( const XclImpTbxControlObj& rTbxCtrlObj );
 
 private:
     ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >
@@ -185,7 +189,7 @@ private:
 #if !EXC_EXP_OCX_CTRL
     /** Tries to get the name of a Basic macro from a control. */
     void                ConvertTbxMacro(
-                            XclExpObjTbxCtrl& rTbxCtrl,
+                            XclExpObjTbxCtrl& rTbxCtrlObj,
                             const ::com::sun::star::uno::Reference<
                                 ::com::sun::star::awt::XControlModel >& rxModel );
 #endif
Index: sc/source/filter/inc/xlroot.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlroot.hxx,v
retrieving revision 1.21
retrieving revision 1.21.4.1
diff -u -p -u -p -r1.21 -r1.21.4.1
--- sc/source/filter/inc/xlroot.hxx	29 Mar 2005 13:47:15 -0000	1.21
+++ sc/source/filter/inc/xlroot.hxx	19 Apr 2005 14:25:48 -0000	1.21.4.1
@@ -58,6 +58,7 @@
  *
  *
  ************************************************************************/
+
 #ifndef SC_XLROOT_HXX
 #define SC_XLROOT_HXX
 
@@ -125,6 +126,7 @@ struct XclRootData
     LanguageType        meSysLang;      /// System language.
     LanguageType        meDocLang;      /// Document language (import: from file, export: from system).
     LanguageType        meUILang;       /// UI language (import: from file, export: from system).
+    sal_Int16           mnDefApiScript; /// Default script type for blank cells (API constant).
     ScAddress           maScMaxPos;     /// Highest Calc cell position.
     ScAddress           maXclMaxPos;    /// Highest Excel cell position.
     ScAddress           maMaxPos;       /// Highest position valid in Calc and Excel.
@@ -183,14 +185,16 @@ public:
     inline bool         IsImport() const { return !mrData.mbExport; }
     /** Returns true, if currently a document is exported. */
     inline bool         IsExport() const { return mrData.mbExport; }
+    /** Returns the character set to import/export byte strings. */
+    inline CharSet      GetCharSet() const { return mrData.meCharSet; }
     /** Returns the system language, i.e. for number formats. */
     inline LanguageType GetSysLanguage() const { return mrData.meSysLang; }
     /** Returns the document language. */
     inline LanguageType GetDocLanguage() const { return mrData.meDocLang; }
     /** Returns the UI language. */
     inline LanguageType GetUILanguage() const { return mrData.meUILang; }
-    /** Returns the character set to import/export byte strings. */
-    inline CharSet      GetCharSet() const { return mrData.meCharSet; }
+    /** Returns the default script type, e.g. for blank cells. */
+    inline sal_Int16    GetDefApiScript() const { return mrData.mnDefApiScript; }
     /** Returns the width of the '0' character (default font) for the current printer (twips). */
     inline long         GetCharWidth() const { return mrData.mnCharWidth; }
     /** Returns the current Calc sheet index. */
Index: sc/source/filter/inc/xlview.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xlview.hxx,v
retrieving revision 1.2
retrieving revision 1.2.36.1
diff -u -p -u -p -r1.2 -r1.2.36.1
--- sc/source/filter/inc/xlview.hxx	21 Feb 2005 13:48:02 -0000	1.2
+++ sc/source/filter/inc/xlview.hxx	10 Aug 2005 14:41:14 -0000	1.2.36.1
@@ -58,6 +58,7 @@
  *
  *
  ************************************************************************/
+
 #ifndef SC_XLVIEW_HXX
 #define SC_XLVIEW_HXX
 
@@ -126,9 +127,25 @@ const sal_uInt8 EXC_PANE_TOPLEFT        
 
 const sal_uInt16 EXC_ID_SCL                 = 0x00A0;
 
-// ============================================================================
+// Structs ====================================================================
+
+/** Contains all view settings for the entire document. */
+struct XclDocViewData
+{
+    sal_uInt16          mnWinX;             /// X position of the document window (twips).
+    sal_uInt16          mnWinY;             /// Y position of the document window (twips).
+    sal_uInt16          mnWinWidth;         /// Width of the document window (twips).
+    sal_uInt16          mnWinHeight;        /// Height of the document window (twips).
+    sal_uInt16          mnFlags;            /// Additional flags.
+    sal_uInt16          mnDisplXclTab;      /// Displayed (active) sheet.
+    sal_uInt16          mnFirstVisXclTab;   /// First visible sheet.
+    sal_uInt16          mnXclSelectCnt;     /// Number of selected sheets.
+    sal_uInt16          mnTabBarWidth;      /// Width of sheet tabbar (1/1000 of window width).
 
-// View settings ==============================================================
+    explicit            XclDocViewData();
+};
+
+// ----------------------------------------------------------------------------
 
 /** Contains all settings for a selection in a single pane of a sheet. */
 struct XclSelectionData
Index: sc/source/filter/xcl97/xcl97dum.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xcl97/xcl97dum.cxx,v
retrieving revision 1.15
retrieving revision 1.15.36.1
diff -u -p -u -p -r1.15 -r1.15.36.1
--- sc/source/filter/xcl97/xcl97dum.cxx	21 Feb 2005 13:49:34 -0000	1.15
+++ sc/source/filter/xcl97/xcl97dum.cxx	6 Jun 2005 15:07:41 -0000	1.15.36.1
@@ -118,7 +118,6 @@ const ULONG ExcDummy8_040::nMyLen = size
 
 
 const BYTE ExcDummy8_041::pMyData[] = {
-	0x0e, 0x00, 0x02, 0x00, 0x01, 0x00,						// PRECISION
 	0xb7, 0x01, 0x02, 0x00, 0x00, 0x00,						// REFRESHALL (8+)
 	0xda, 0x00, 0x02, 0x00, 0x00, 0x00						// BOOKBOOL
 };
Index: sc/source/filter/xcl97/xcl97rec.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xcl97/xcl97rec.cxx,v
retrieving revision 1.76
retrieving revision 1.76.34.1
diff -u -p -u -p -r1.76 -r1.76.34.1
--- sc/source/filter/xcl97/xcl97rec.cxx	21 Feb 2005 13:50:03 -0000	1.76
+++ sc/source/filter/xcl97/xcl97rec.cxx	9 Aug 2005 16:30:18 -0000	1.76.34.1
@@ -674,39 +674,39 @@ void XclObjDropDown::WriteSubRecs( XclEx
 
 // --- class XclTxo --------------------------------------------------
 
-XclTxoHorAlign lcl_GetHorAlignFromItemSet( const SfxItemSet& rItemSet )
+sal_uInt8 lcl_GetHorAlignFromItemSet( const SfxItemSet& rItemSet )
 {
-    XclTxoHorAlign eHorAlign = xlTxoHAlign_Default;
+    sal_uInt8 nHorAlign = EXC_TXO_HOR_LEFT;
 
     switch( static_cast< const SvxAdjustItem& >( rItemSet.Get( EE_PARA_JUST ) ).GetAdjust() )
     {
-        case SVX_ADJUST_LEFT:           eHorAlign = xlTxoHAlignLeft;       break;
-        case SVX_ADJUST_CENTER:         eHorAlign = xlTxoHAlignCenter;     break;
-        case SVX_ADJUST_RIGHT:          eHorAlign = xlTxoHAlignRight;      break;
-        case SVX_ADJUST_BLOCK:          eHorAlign = xlTxoHAlignJustify;    break;
+        case SVX_ADJUST_LEFT:   nHorAlign = EXC_TXO_HOR_LEFT;      break;
+        case SVX_ADJUST_CENTER: nHorAlign = EXC_TXO_HOR_CENTER;    break;
+        case SVX_ADJUST_RIGHT:  nHorAlign = EXC_TXO_HOR_RIGHT;     break;
+        case SVX_ADJUST_BLOCK:  nHorAlign = EXC_TXO_HOR_JUSTIFY;   break;
     }
-    return eHorAlign;
+    return nHorAlign;
 }
 
-XclTxoVerAlign lcl_GetVerAlignFromItemSet( const SfxItemSet& rItemSet )
+sal_uInt8 lcl_GetVerAlignFromItemSet( const SfxItemSet& rItemSet )
 {
-    XclTxoVerAlign eVerAlign = xlTxoVAlign_Default;
+    sal_uInt8 nVerAlign = EXC_TXO_VER_TOP;
 
     switch( static_cast< const SdrTextVertAdjustItem& >( rItemSet.Get( SDRATTR_TEXT_VERTADJUST ) ).GetValue() )
     {
-        case SDRTEXTVERTADJUST_TOP:     eVerAlign = xlTxoVAlignTop;     break;
-        case SDRTEXTVERTADJUST_CENTER:  eVerAlign = xlTxoVAlignCenter;  break;
-        case SDRTEXTVERTADJUST_BOTTOM:  eVerAlign = xlTxoVAlignBottom;  break;
-        case SDRTEXTVERTADJUST_BLOCK:   eVerAlign = xlTxoVAlignJustify; break;
+        case SDRTEXTVERTADJUST_TOP:     nVerAlign = EXC_TXO_VER_TOP;        break;
+        case SDRTEXTVERTADJUST_CENTER:  nVerAlign = EXC_TXO_VER_CENTER;     break;
+        case SDRTEXTVERTADJUST_BOTTOM:  nVerAlign = EXC_TXO_VER_BOTTOM;     break;
+        case SDRTEXTVERTADJUST_BLOCK:   nVerAlign = EXC_TXO_VER_JUSTIFY;    break;
     }
-    return eVerAlign;
+    return nVerAlign;
 }
 
 XclTxo::XclTxo( const String& rString, sal_uInt16 nFontIx ) :
     mpString( new XclExpString( rString ) ),
-    meHorAlign( xlTxoHAlign_Default ),
-    meVerAlign( xlTxoVAlign_Default ),
-    meRotation( xlTxoRot_Default )
+    mnRotation( EXC_TXO_TEXTROT_NONE ),
+    mnHorAlign( EXC_TXO_HOR_LEFT ),
+    mnVerAlign( EXC_TXO_VER_TOP )
 {
     if( mpString->Len() )
     {
@@ -718,34 +718,34 @@ XclTxo::XclTxo( const String& rString, s
 
 XclTxo::XclTxo( const XclExpRoot& rRoot, const SdrTextObj& rTextObj ) :
     mpString( XclExpStringHelper::CreateString( rRoot, rTextObj ) ),
-    meHorAlign( xlTxoHAlign_Default ),
-    meVerAlign( xlTxoVAlign_Default ),
-    meRotation( xlTxoRot_Default )
+    mnRotation( EXC_TXO_TEXTROT_NONE ),
+    mnHorAlign( EXC_TXO_HOR_LEFT ),
+    mnVerAlign( EXC_TXO_VER_TOP )
 {
     // additional alignment and orientation items
     const SfxItemSet& rItemSet = rTextObj.GetMergedItemSet();
 
     // horizontal alignment
-    SetHorAlign(lcl_GetHorAlignFromItemSet(rItemSet));
+    SetHorAlign( lcl_GetHorAlignFromItemSet( rItemSet ) );
 
     // vertical alignment
-    SetVerAlign(lcl_GetVerAlignFromItemSet(rItemSet));
+    SetVerAlign( lcl_GetVerAlignFromItemSet( rItemSet ) );
 
     // rotation
     long nAngle = rTextObj.GetRotateAngle();
     if( (4500 < nAngle) && (nAngle < 13500) )
-        meRotation = xlTxoRot90ccw;
+        mnRotation = EXC_TXO_TEXTROT_90_CCW;
     else if( (22500 < nAngle) && (nAngle < 31500) )
-        meRotation = xlTxoRot90cw;
+        mnRotation = EXC_TXO_TEXTROT_90_CW;
     else
-        meRotation = xlTxoNoRot;
+        mnRotation = EXC_TXO_TEXTROT_NONE;
 }
 
 XclTxo::XclTxo( const XclExpRoot& rRoot, const EditTextObject& rEditObj, SdrObject* pCaption ) :
     mpString( XclExpStringHelper::CreateString( rRoot, rEditObj ) ),
-    meHorAlign( xlTxoHAlign_Default ),
-    meVerAlign( xlTxoVAlign_Default ),
-    meRotation( xlTxoRot_Default )
+    mnRotation( EXC_TXO_TEXTROT_NONE ),
+    mnHorAlign( EXC_TXO_HOR_LEFT ),
+    mnVerAlign( EXC_TXO_VER_TOP )
 {
     if(pCaption)
     {
@@ -757,25 +757,24 @@ XclTxo::XclTxo( const XclExpRoot& rRoot,
         {
             SfxItemSet aSet( rEditObj.GetParaAttribs( 0));
             const SfxPoolItem* pItem = NULL;
-            if (aSet.GetItemState(EE_PARA_JUST,TRUE,&pItem) == SFX_ITEM_SET)
+            if( aSet.GetItemState( EE_PARA_JUST, TRUE, &pItem ) == SFX_ITEM_SET )
             {
-                SvxAdjust eEEAlign = static_cast< const SvxAdjustItem& >( *pItem).GetAdjust();
-                pCaption->SetMergedItem( SvxAdjustItem( eEEAlign, EE_PARA_JUST));
+                SvxAdjust eEEAlign = static_cast< const SvxAdjustItem& >( *pItem ).GetAdjust();
+                pCaption->SetMergedItem( SvxAdjustItem( eEEAlign, EE_PARA_JUST ) );
             }
         }
         const SfxItemSet& rItemSet = pCaption->GetMergedItemSet();
 
         // horizontal alignment
-        SetHorAlign(lcl_GetHorAlignFromItemSet(rItemSet));
+        SetHorAlign( lcl_GetHorAlignFromItemSet( rItemSet ) );
 
         // vertical alignment
-        SetVerAlign(lcl_GetVerAlignFromItemSet(rItemSet));
+        SetVerAlign( lcl_GetVerAlignFromItemSet( rItemSet ) );
 
         // orientation alignment
-        const SvxWritingModeItem& rItem = static_cast<const SvxWritingModeItem&>
-            (rItemSet.Get (SDRATTR_TEXTDIRECTION));
-        if (rItem.GetValue() == com::sun::star::text::WritingMode_TB_RL)
-            meRotation = xlTxoRot90cw;
+        const SvxWritingModeItem& rItem = static_cast< const SvxWritingModeItem& >( rItemSet.Get( SDRATTR_TEXTDIRECTION ) );
+        if( rItem.GetValue() == com::sun::star::text::WritingMode_TB_RL )
+            mnRotation = EXC_TXO_TEXTROT_90_CW;
     }
 }
 
@@ -786,10 +785,10 @@ void XclTxo::SaveCont( XclExpStream& rSt
     sal_uInt16 nRunLen = 8 * mpString->GetFormatsCount();
     // alignment
     sal_uInt16 nFlags = 0;
-    ::insert_value( nFlags, meHorAlign, 1, 3 );
-    ::insert_value( nFlags, meVerAlign, 4, 3 );
+    ::insert_value( nFlags, mnHorAlign, 1, 3 );
+    ::insert_value( nFlags, mnVerAlign, 4, 3 );
 
-    rStrm << nFlags << static_cast< sal_uInt16 >( meRotation );
+    rStrm << nFlags << mnRotation;
     rStrm.WriteZeroBytes( 6 );
     rStrm << mpString->Len() << nRunLen << sal_uInt32( 0 );
 }
Index: sc/source/filter/xml/XMLExportIterator.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/XMLExportIterator.cxx,v
retrieving revision 1.39
retrieving revision 1.39.4.1
diff -u -p -u -p -r1.39 -r1.39.4.1
--- sc/source/filter/xml/XMLExportIterator.cxx	23 Mar 2005 12:50:05 -0000	1.39
+++ sc/source/filter/xml/XMLExportIterator.cxx	20 Jul 2005 13:30:24 -0000	1.39.4.1
@@ -389,7 +389,19 @@ void ScMyAreaLinksContainer::SetCellData
 		{
 			rMyCell.bHasAreaLink = sal_True;
 			rMyCell.aAreaLink = *aItr;
-			aAreaLinkList.erase( aItr );
+			aItr = aAreaLinkList.erase( aItr );
+            sal_Bool bFound = sal_True;
+            while (aItr != aAreaLinkList.end() && bFound)
+            {
+        		ScUnoConversion::FillApiStartAddress( aAddress, aItr->aDestRange );
+                if (aAddress == rMyCell.aCellAddress)
+                {
+                    DBG_ERROR("more than one linked range on one cell");
+                    aItr = aAreaLinkList.erase( aItr );
+                }
+                else
+                    bFound = sal_False;
+            }
 		}
 	}
 }
Index: sc/source/filter/xml/xmlcelli.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlcelli.cxx,v
retrieving revision 1.83
retrieving revision 1.83.4.1
diff -u -p -u -p -r1.83 -r1.83.4.1
--- sc/source/filter/xml/xmlcelli.cxx	23 Mar 2005 12:55:37 -0000	1.83
+++ sc/source/filter/xml/xmlcelli.cxx	21 Jul 2005 15:34:19 -0000	1.83.4.1
@@ -805,7 +805,7 @@ void ScXMLTableRowCellContext::SetAnnota
                 if (pMyAnnotation->pRect)
                     aNote.SetRectangle(*pMyAnnotation->pRect);
                 else
-                    aNote.SetRectangle(aNote.DefaultRectangle(ScAddress(static_cast<SCCOL>(aCellAddress.Column), static_cast<SCROW>(aCellAddress.Row), aCellAddress.Sheet)));
+                    rXMLImport.AddDefaultNote(aCellAddress);
                 if (pMyAnnotation->pItemSet)
                     aNote.SetItemSet(*(pMyAnnotation->pItemSet));
                 else
@@ -835,8 +835,6 @@ void ScXMLTableRowCellContext::SetAnnota
 				}
                 if (pMyAnnotation->pRect)
                     aNote.SetRectangle(*pMyAnnotation->pRect);
-                else
-                    aNote.SetRectangle(aNote.MimicOldRectangle(ScAddress(static_cast<SCCOL>(aCellAddress.Column), static_cast<SCROW>(aCellAddress.Row), aCellAddress.Sheet)));
 				pDoc->SetNote(static_cast<SCCOL>(aCellAddress.Column), static_cast<SCROW>(aCellAddress.Row), aCellAddress.Sheet, aNote);
 				if (pMyAnnotation->bDisplay)
 				{
Index: sc/source/filter/xml/xmlexprt.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlexprt.cxx,v
retrieving revision 1.194
retrieving revision 1.190.18.3
diff -u -p -u -p -r1.194 -r1.190.18.3
--- sc/source/filter/xml/xmlexprt.cxx	24 Jun 2005 14:02:56 -0000	1.194
+++ sc/source/filter/xml/xmlexprt.cxx	4 Jul 2005 13:57:31 -0000	1.190.18.3
@@ -2024,8 +2024,6 @@ void ScXMLExport::_ExportAutoStyles()
 										    }
 										    sal_Int32 nOld(nColumn);
                                             nColumn = pDoc->GetNextDifferentChangedCol(nTable, static_cast<USHORT>(nColumn));
-										    if (nColumn == MAXCOL)
-											    ++nColumn;
 										    for (sal_Int32 i = nOld + 1; i < nColumn; ++i)
 											    pColumnStyles->AddFieldStyleName(nTable, i, nIndex, bIsVisible);
 									    }
@@ -2076,8 +2074,6 @@ void ScXMLExport::_ExportAutoStyles()
 										    }
 										    sal_Int32 nOld(nRow);
                                             nRow = pDoc->GetNextDifferentChangedRow(nTable, static_cast<USHORT>(nRow), false);
-										    if (nRow == MAXROW)
-											    ++nRow;
 										    for (sal_Int32 i = nOld + 1; i < nRow; ++i)
 											    pRowStyles->AddFieldStyleName(nTable, i, nIndex);
 									    }
Index: sc/source/filter/xml/xmlimprt.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlimprt.cxx,v
retrieving revision 1.114
retrieving revision 1.114.4.1
diff -u -p -u -p -r1.114 -r1.114.4.1
--- sc/source/filter/xml/xmlimprt.cxx	29 Mar 2005 12:54:13 -0000	1.114
+++ sc/source/filter/xml/xmlimprt.cxx	21 Jul 2005 15:34:19 -0000	1.114.4.1
@@ -1548,6 +1548,7 @@ ScXMLImport::ScXMLImport(
 	pMyNamedExpressions(NULL),
     pMyLabelRanges(NULL),
 	pValidations(NULL),
+    pDefaultNotes(NULL),
 	pDetectiveOpArray(NULL),
 //	pScAutoStylePool(new SvXMLAutoStylePoolP),
 	bRemoveLastChar(sal_False),
@@ -1670,6 +1671,8 @@ ScXMLImport::~ScXMLImport() throw()
         delete pMyLabelRanges;
 	if (pValidations)
 		delete pValidations;
+    if (pDefaultNotes)
+        delete pDefaultNotes;
 	if (pDetectiveOpArray)
 		delete pDetectiveOpArray;
 }
@@ -2538,6 +2541,8 @@ void SAL_CALL ScXMLImport::endDocument(v
 			pDoc->CompileXML();
 		aTables.UpdateRowHeights();
 		aTables.ResizeShapes();
+
+        SetDefaultNotes();
 	}
 	if (GetModel().is())
 	{
@@ -2555,6 +2560,33 @@ void SAL_CALL ScXMLImport::endDocument(v
     UnlockSolarMutex();
 }
 
+void ScXMLImport::AddDefaultNote(const table::CellAddress& aCell) 
+{
+    if (!pDefaultNotes)
+        pDefaultNotes = new ScMyDefaultNotes();
+
+    pDefaultNotes->push_back(aCell);
+}
+
+void ScXMLImport::SetDefaultNotes()
+{
+    if (pDefaultNotes && pDoc)
+    {
+        ScMyDefaultNotes::iterator aItr(pDefaultNotes->begin());
+        ScMyDefaultNotes::iterator aEndItr(pDefaultNotes->end());
+        ScPostIt aNote(pDoc);
+        while(aItr != aEndItr)
+        {
+            if (pDoc->GetNote(static_cast<SCCOL>(aItr->Column), static_cast<SCROW>(aItr->Row), aItr->Sheet, aNote))
+            {
+                aNote.SetRectangle(aNote.MimicOldRectangle(ScAddress(static_cast<SCCOL>(aItr->Column), static_cast<SCROW>(aItr->Row), aItr->Sheet)));
+                pDoc->SetNote(static_cast<SCCOL>(aItr->Column), static_cast<SCROW>(aItr->Row), aItr->Sheet, aNote);
+            }
+            ++aItr;
+        }
+    }
+}
+
 // XEventListener
 void ScXMLImport::DisposingModel()
 {
Index: sc/source/filter/xml/xmlimprt.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlimprt.hxx,v
retrieving revision 1.87
retrieving revision 1.87.4.1
diff -u -p -u -p -r1.87 -r1.87.4.1
--- sc/source/filter/xml/xmlimprt.hxx	29 Mar 2005 12:54:36 -0000	1.87
+++ sc/source/filter/xml/xmlimprt.hxx	21 Jul 2005 15:34:20 -0000	1.87.4.1
@@ -694,6 +694,7 @@ struct ScMyImportValidation
 
 typedef std::vector<ScMyImportValidation>			ScMyImportValidations;
 typedef std::list<SvXMLImportContext*>				ScMyViewContextList;
+typedef std::list<com::sun::star::table::CellAddress> ScMyDefaultNotes;
 class ScMyStylesImportHelper;
 
 class ScXMLImport: public SvXMLImport
@@ -791,6 +792,7 @@ class ScXMLImport: public SvXMLImport
     ScMyLabelRanges*        pMyLabelRanges;
 	ScMyImportValidations*	pValidations;
 	ScMyImpDetectiveOpArray*	pDetectiveOpArray;
+    ScMyDefaultNotes*       pDefaultNotes;
 	ScUnoGuard*				pScUnoGuard;
 
 	std::vector<rtl::OUString>			aTableStyles;
@@ -990,6 +992,8 @@ public:
 private:
 	void AddStyleRange(const com::sun::star::table::CellRangeAddress& rCellRange);
 	void SetStyleToRanges();
+
+    void SetDefaultNotes();
 public:
 	void SetStyleToRange(const ScRange& rRange, const rtl::OUString* pStyleName,
 		const sal_Int16 nCellType, const rtl::OUString* pCurrency);
@@ -1021,6 +1025,7 @@ public:
 	sal_Int32 	GetRangeType(const rtl::OUString sRangeType) const;
     void SetNamedRanges();
     void SetLabelRanges();
+    void AddDefaultNote( const com::sun::star::table::CellAddress& aCell );
 };
 
 #endif
Index: sc/source/filter/xml/xmlstyli.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlstyli.cxx,v
retrieving revision 1.55
retrieving revision 1.54.4.2
diff -u -p -u -p -r1.55 -r1.54.4.2
--- sc/source/filter/xml/xmlstyli.cxx	18 Jul 2005 14:15:07 -0000	1.55
+++ sc/source/filter/xml/xmlstyli.cxx	18 Jul 2005 14:43:16 -0000	1.54.4.2
@@ -645,7 +645,8 @@ void XMLTableStyleContext::FillPropertyS
 				if (pStyle)
 				{
 					//rPropSet->setPropertyValue(rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(SC_NUMBERFORMAT)), aNumberFormat);
-                    AddProperty(CTF_SC_NUMBERFORMAT, uno::makeAny(pStyle->GetKey()));
+					nNumberFormat = pStyle->GetKey();
+                    AddProperty(CTF_SC_NUMBERFORMAT, uno::makeAny(nNumberFormat));
 				}
 			}
 			if (!bConditionalFormatCreated && (aMaps.size() > 0))
Index: sc/source/filter/xml/xmlwrap.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlwrap.cxx,v
retrieving revision 1.56
retrieving revision 1.55.8.2
diff -u -p -u -p -r1.56 -r1.55.8.2
--- sc/source/filter/xml/xmlwrap.cxx	23 Mar 2005 13:04:11 -0000	1.56
+++ sc/source/filter/xml/xmlwrap.cxx	6 Apr 2005 09:03:31 -0000	1.55.8.2
@@ -779,6 +779,8 @@ sal_Bool ScXMLImportWrapper::Export(sal_
         { MAP_LEN( "BaseURI" ), 0, &::getCppuType( (rtl::OUString *)0 ), ::com::sun::star::beans::PropertyAttribute::MAYBEVOID, 0 },
         { MAP_LEN( "StreamRelPath" ), 0, &::getCppuType( (rtl::OUString *)0 ), ::com::sun::star::beans::PropertyAttribute::MAYBEVOID, 0 },
         { MAP_LEN( "StreamName" ), 0, &::getCppuType( (rtl::OUString *)0 ), ::com::sun::star::beans::PropertyAttribute::MAYBEVOID, 0 },
+        { MAP_LEN( "StyleNames" ), 0, &::getCppuType( (uno::Sequence<rtl::OUString>*)0 ), ::com::sun::star::beans::PropertyAttribute::MAYBEVOID, 0 },
+        { MAP_LEN( "StyleFamilies" ), 0, &::getCppuType( (uno::Sequence<sal_Int32>*)0 ), ::com::sun::star::beans::PropertyAttribute::MAYBEVOID, 0 },
 		{ NULL, 0, 0, NULL, 0, 0 }
 	};
 	uno::Reference< beans::XPropertySet > xInfoSet( comphelper::GenericPropertySet_CreateInstance( new comphelper::PropertySetInfo( aExportInfoMap ) ) );
Index: sc/source/ui/dbgui/scuiasciiopt.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/dbgui/scuiasciiopt.cxx,v
retrieving revision 1.6
retrieving revision 1.6.202.1
diff -u -p -u -p -r1.6 -r1.6.202.1
--- sc/source/ui/dbgui/scuiasciiopt.cxx	11 Oct 2004 12:29:02 -0000	1.6
+++ sc/source/ui/dbgui/scuiasciiopt.cxx	23 Mar 2005 11:56:05 -0000	1.6.202.1
@@ -449,6 +449,13 @@ IMPL_LINK( ScImportAsciiDlg, SeparatorHd
     DBG_ASSERT( pCtrl, "ScImportAsciiDlg::SeparatorHdl - missing sender" );
     DBG_ASSERT( !aRbFixed.IsChecked(), "ScImportAsciiDlg::SeparatorHdl - not allowed in fixed width" );
 
+    /*  #i41550# First update state of the controls. The GetSeparators()
+        function needs final state of the check boxes. */
+    if( (pCtrl == &aCkbOther) && aCkbOther.IsChecked() )
+        aEdOther.GrabFocus();
+    else if( pCtrl == &aEdOther )
+        aCkbOther.Check( aEdOther.GetText().Len() > 0 );
+
     String aOldFldSeps( maFieldSeparators);
     maFieldSeparators = GetSeparators();
     sal_Unicode cOldSep = mcTextSep;
@@ -458,10 +465,6 @@ IMPL_LINK( ScImportAsciiDlg, SeparatorHd
     if (cOldSep != mcTextSep || aOldFldSeps != maFieldSeparators)
         UpdateVertical();
 
-    if( (pCtrl == &aCkbOther) && aCkbOther.IsChecked() )
-        aEdOther.GrabFocus();
-    else if( pCtrl == &aEdOther )
-        aCkbOther.Check( aEdOther.GetText().Len() > 0 );
     maTableBox.Execute( CSVCMD_NEWCELLTEXTS );
 	return 0;
 }
Index: sc/source/ui/docshell/docfunc.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/docshell/docfunc.cxx,v
retrieving revision 1.53
retrieving revision 1.53.18.4
diff -u -p -u -p -r1.53 -r1.53.18.4
--- sc/source/ui/docshell/docfunc.cxx	8 Mar 2005 15:43:55 -0000	1.53
+++ sc/source/ui/docshell/docfunc.cxx	28 Jul 2005 08:42:43 -0000	1.53.18.4
@@ -1524,7 +1524,7 @@ BOOL ScDocFunc::DeleteCells( const ScRan
 	if (pDoc->HasAttrib( nUndoStartX,nUndoStartY,nTab, nMergeTestEndX,nMergeTestEndY,nTab,
 							HASATTR_MERGED | HASATTR_OVERLAPPED ))
 	{
-		if (eCmd==DEL_CELLSLEFT)
+        if ( eCmd==DEL_CELLSLEFT || eCmd==DEL_CELLSUP )
 			bNeedRefresh = TRUE;
 
 		SCCOL nMergeStartX = nUndoStartX;
@@ -1642,20 +1642,22 @@ BOOL ScDocFunc::DeleteCells( const ScRan
 
 	if (bNeedRefresh)
 	{
-		if ( eCmd==DEL_DELCOLS || eCmd==DEL_DELROWS )
-		{
-			if (eCmd==DEL_DELCOLS) nMergeTestEndX = MAXCOL;
-			if (eCmd==DEL_DELROWS) nMergeTestEndY = MAXROW;
-			ScPatternAttr aPattern( pDoc->GetPool() );
-			aPattern.GetItemSet().Put( ScMergeFlagAttr() );
-
-			ScMarkData aMark;							// nur fuer Tabellen
-			for (SCTAB i=nStartTab; i<=nEndTab; i++)
-				aMark.SelectTable( i, TRUE );
-			pDoc->ApplyPatternArea( nUndoStartX, nUndoStartY, nMergeTestEndX, nMergeTestEndY,
-										aMark, aPattern );
-		}
-		pDoc->ExtendMerge( nUndoStartX, nUndoStartY, nMergeTestEndX, nMergeTestEndY, nTab, TRUE );
+        // #i51445# old merge flag attributes must be deleted also for single cells,
+        // not only for whole columns/rows
+
+        if ( eCmd==DEL_DELCOLS || eCmd==DEL_CELLSLEFT ) nMergeTestEndX = MAXCOL;
+        if ( eCmd==DEL_DELROWS || eCmd==DEL_CELLSUP ) nMergeTestEndY = MAXROW;
+		ScPatternAttr aPattern( pDoc->GetPool() );
+		aPattern.GetItemSet().Put( ScMergeFlagAttr() );
+
+        ScMarkData aMark;							// only contains the sheets
+        for (SCTAB i=nStartTab; i<=nEndTab; i++)
+            aMark.SelectTable( i, TRUE );
+        pDoc->ApplyPatternArea( nUndoStartX, nUndoStartY, nMergeTestEndX, nMergeTestEndY,
+                                    aMark, aPattern );
+
+        ScRange aMergedRange( nUndoStartX, nUndoStartY, nStartTab, nMergeTestEndX, nMergeTestEndY, nEndTab );
+        pDoc->ExtendMerge( aMergedRange, TRUE );
 	}
 
 	if ( eCmd == DEL_DELCOLS || eCmd == DEL_DELROWS )
@@ -1684,6 +1686,8 @@ BOOL ScDocFunc::DeleteCells( const ScRan
 //!	pDocSh->UpdateOle(GetViewData());	// muss an der View bleiben
 //!	CellContentChanged();				// muss an der View bleiben
 
+    SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
+
 	return TRUE;
 }
 
@@ -2024,6 +2028,8 @@ BOOL ScDocFunc::MoveBlock( const ScRange
 
 	aModificator.SetDocumentModified();
 
+    SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
+
 	delete pClipDoc;
 	return TRUE;
 }
@@ -2139,7 +2145,12 @@ BOOL ScDocFunc::DeleteTable( SCTAB nTab,
 
 		rDocShell.PostPaintExtras();
 		aModificator.SetDocumentModified();
-		SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
+
+        SfxApplication* pSfxApp = SFX_APP();                                // Navigator
+        pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
+        pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_DBAREAS_CHANGED ) );
+        pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
+
 		bSuccess = TRUE;
 	}
 	else
@@ -3902,6 +3913,44 @@ BOOL ScDocFunc::InsertAreaLink( const St
 	ScDocument* pDoc = rDocShell.GetDocument();
 	BOOL bUndo (pDoc->IsUndoEnabled());
 
+    SvxLinkManager* pLinkManager = pDoc->GetLinkManager();
+
+    //  #i52120# if other area links exist at the same start position,
+    //  remove them first (file format specifies only one link definition
+    //  for a cell)
+
+    USHORT nLinkCount = pLinkManager->GetLinks().Count();
+    USHORT nRemoved = 0;
+    USHORT nLinkPos = 0;
+    while (nLinkPos<nLinkCount)
+    {
+        ::sfx2::SvBaseLink* pBase = *pLinkManager->GetLinks()[nLinkPos];
+        if ( pBase->ISA(ScAreaLink) &&
+             static_cast<ScAreaLink*>(pBase)->GetDestArea().aStart == rDestRange.aStart )
+        {
+            if ( bUndo )
+            {
+                if ( !nRemoved )
+                {
+                    // group all remove and the insert action
+                    String aUndo = ScGlobal::GetRscString( STR_UNDO_INSERTAREALINK );
+                    rDocShell.GetUndoManager()->EnterListAction( aUndo, aUndo );
+                }
+
+                ScAreaLink* pOldArea = static_cast<ScAreaLink*>(pBase);
+                rDocShell.GetUndoManager()->AddUndoAction(
+                    new ScUndoRemoveAreaLink( &rDocShell,
+                        pOldArea->GetFile(), pOldArea->GetFilter(), pOldArea->GetOptions(),
+                        pOldArea->GetSource(), pOldArea->GetDestArea(), pOldArea->GetRefreshDelay() ) );
+            }
+            pLinkManager->Remove( pBase );
+            nLinkCount = pLinkManager->GetLinks().Count();
+            ++nRemoved;
+        }
+        else
+            ++nLinkPos;
+    }
+
 	String aFilterName = rFilter;
 	String aNewOptions = rOptions;
 	if (!aFilterName.Len())
@@ -3911,8 +3960,6 @@ BOOL ScDocFunc::InsertAreaLink( const St
 	//	aren't reset when the filter name is changed in ScAreaLink::DataChanged
 	ScDocumentLoader::RemoveAppPrefix( aFilterName );
 
-	SvxLinkManager* pLinkManager = pDoc->GetLinkManager();
-
 	ScAreaLink* pLink = new ScAreaLink( &rDocShell, rFile, aFilterName,
 										aNewOptions, rSource, rDestRange, nRefresh );
 	pLinkManager->InsertFileLink( *pLink, OBJECT_CLIENT_FILE, rFile, &aFilterName, &rSource );
@@ -3920,9 +3967,13 @@ BOOL ScDocFunc::InsertAreaLink( const St
 	//	Undo fuer den leeren Link
 
 	if (bUndo)
+    {
 		rDocShell.GetUndoManager()->AddUndoAction( new ScUndoInsertAreaLink( &rDocShell,
 													rFile, aFilterName, aNewOptions,
 													rSource, rDestRange, nRefresh ) );
+        if ( nRemoved )
+            rDocShell.GetUndoManager()->LeaveListAction();  // undo for link update is still separate
+    }
 
 	//	Update hat sein eigenes Undo
 
Index: sc/source/ui/docshell/docsh8.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/docshell/docsh8.cxx,v
retrieving revision 1.18
retrieving revision 1.18.18.1
diff -u -p -u -p -r1.18 -r1.18.18.1
--- sc/source/ui/docshell/docsh8.cxx	8 Mar 2005 11:31:09 -0000	1.18
+++ sc/source/ui/docshell/docsh8.cxx	19 Jul 2005 11:24:29 -0000	1.18.18.1
@@ -785,7 +785,8 @@ ULONG ScDocShell::DBaseExport( const Str
 	INetURLObject aURL;
 	aURL.SetSmartProtocol( INET_PROT_FILE );
 	aURL.SetSmartURL( rFullFileName );
-	String aTabName = aURL.getBase();
+    String aTabName = aURL.getBase( INetURLObject::LAST_SEGMENT, true,
+            INetURLObject::DECODE_UNAMBIGUOUS );
 	String aExtension = aURL.getExtension();
 	aURL.removeSegment();
 	aURL.removeFinalSlash();
Index: sc/source/ui/drawfunc/drawsh2.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/drawfunc/drawsh2.cxx,v
retrieving revision 1.16
retrieving revision 1.16.66.1
diff -u -p -u -p -r1.16 -r1.16.66.1
--- sc/source/ui/drawfunc/drawsh2.cxx	28 Jan 2005 17:23:02 -0000	1.16
+++ sc/source/ui/drawfunc/drawsh2.cxx	19 Jul 2005 10:11:45 -0000	1.16.66.1
@@ -332,43 +332,50 @@ void ScDrawShell::GetDrawAttrState( SfxI
 	else
 		rSet.Put( pDrView->GetDefaultAttr() );
 
-	//	Items for position and size (see ScGridWindow::UpdateStatusPosSize, #108137#)
-
-    // #i34458# The SvxSizeItem in SID_TABLE_CELL is no longer needed by
-    // SvxPosSizeStatusBarControl, it's enough to have it in SID_ATTR_SIZE.
-
-	BOOL bActionItem = FALSE;
-	if ( pDrView->IsAction() )				// action rectangle
-	{
-		Rectangle aRect;
-		pDrView->TakeActionRect( aRect );
-		if ( !aRect.IsEmpty() )
-		{
-			pDrView->GetPageViewPvNum(0)->LogicToPagePos(aRect);
-			rSet.Put( SfxPointItem( SID_ATTR_POSITION, aRect.TopLeft() ) );
-			Size aSize( aRect.Right() - aRect.Left(), aRect.Bottom() - aRect.Top() );
-			rSet.Put( SvxSizeItem( SID_ATTR_SIZE, aSize ) );
-			bActionItem = TRUE;
-		}
-	}
-	if ( !bActionItem )
-	{
-		if ( pDrView->AreObjectsMarked() )		// selected objects
-		{
-			Rectangle aRect = pDrView->GetAllMarkedRect();
-			pDrView->GetPageViewPvNum(0)->LogicToPagePos(aRect);
-			rSet.Put( SfxPointItem( SID_ATTR_POSITION, aRect.TopLeft() ) );
-			Size aSize( aRect.Right() - aRect.Left(), aRect.Bottom() - aRect.Top() );
-			rSet.Put( SvxSizeItem( SID_ATTR_SIZE, aSize ) );
-		}
-		else								// mouse position
-		{
-			// aPos is initialized above
-			pDrView->GetPageViewPvNum(0)->LogicToPagePos(aPos);
-			rSet.Put( SfxPointItem( SID_ATTR_POSITION, aPos ) );
-			rSet.Put( SvxSizeItem( SID_ATTR_SIZE, Size( 0, 0 ) ) );
-		}
-	}
+    SdrPageView* pPV = pDrView->GetPageViewPvNum(0);
+    if ( pPV )
+    {
+        // #i52073# when a sheet with an active OLE object is deleted,
+        // the slot state is queried without an active page view
+
+        //  Items for position and size (see ScGridWindow::UpdateStatusPosSize, #108137#)
+
+        // #i34458# The SvxSizeItem in SID_TABLE_CELL is no longer needed by
+        // SvxPosSizeStatusBarControl, it's enough to have it in SID_ATTR_SIZE.
+
+        BOOL bActionItem = FALSE;
+        if ( pDrView->IsAction() )              // action rectangle
+        {
+            Rectangle aRect;
+            pDrView->TakeActionRect( aRect );
+            if ( !aRect.IsEmpty() )
+            {
+                pPV->LogicToPagePos(aRect);
+                rSet.Put( SfxPointItem( SID_ATTR_POSITION, aRect.TopLeft() ) );
+                Size aSize( aRect.Right() - aRect.Left(), aRect.Bottom() - aRect.Top() );
+                rSet.Put( SvxSizeItem( SID_ATTR_SIZE, aSize ) );
+                bActionItem = TRUE;
+            }
+        }
+        if ( !bActionItem )
+        {
+            if ( pDrView->AreObjectsMarked() )      // selected objects
+            {
+                Rectangle aRect = pDrView->GetAllMarkedRect();
+                pPV->LogicToPagePos(aRect);
+                rSet.Put( SfxPointItem( SID_ATTR_POSITION, aRect.TopLeft() ) );
+                Size aSize( aRect.Right() - aRect.Left(), aRect.Bottom() - aRect.Top() );
+                rSet.Put( SvxSizeItem( SID_ATTR_SIZE, aSize ) );
+            }
+            else                                // mouse position
+            {
+                // aPos is initialized above
+                pPV->LogicToPagePos(aPos);
+                rSet.Put( SfxPointItem( SID_ATTR_POSITION, aPos ) );
+                rSet.Put( SvxSizeItem( SID_ATTR_SIZE, Size( 0, 0 ) ) );
+            }
+        }
+    }
 }
 
 void ScDrawShell::GetAttrFuncState(SfxItemSet &rSet)
Index: sc/source/ui/drawfunc/fudraw.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/drawfunc/fudraw.cxx,v
retrieving revision 1.14
retrieving revision 1.14.36.1
diff -u -p -u -p -r1.14 -r1.14.36.1
--- sc/source/ui/drawfunc/fudraw.cxx	21 Feb 2005 16:00:55 -0000	1.14
+++ sc/source/ui/drawfunc/fudraw.cxx	12 May 2005 15:20:19 -0000	1.14.36.1
@@ -204,7 +204,7 @@ BOOL __EXPORT FuDraw::MouseButtonDown(co
 	SetMouseButtonCode(rMEvt.GetButtons());
 
 	DoModifiers( rMEvt );
-	if(!IsReSizingNote( rMEvt ))
+    if( !IsSizingOrMovingNote( rMEvt ) )
 	    CheckVisibleNote();
 	return FALSE;
 }
@@ -324,7 +324,7 @@ BOOL __EXPORT FuDraw::KeyInput(const Key
 			}
 			else if ( pView->AreObjectsMarked() )
 			{
-	                    
+
 				// #97016# III
 				const SdrHdlList& rHdlList = pView->GetHdlList();
 				SdrHdl* pHdl = rHdlList.GetFocusHdl();
@@ -924,29 +924,30 @@ void FuDraw::ForcePointer(const MouseEve
 	}
 }
 
-BOOL FuDraw::IsReSizingNote( const MouseEvent& rMEvt) const
+BOOL FuDraw::IsSizingOrMovingNote( const MouseEvent& rMEvt ) const
 {
-    BOOL bReSizingNote = FALSE;
-    const SdrMarkList& rNoteMarkList = pView->GetMarkedObjectList();
-    if(rNoteMarkList.GetMarkCount() == 1)
+    BOOL bIsSizingOrMoving = FALSE;
+    if ( rMEvt.IsLeft() )
     {
-        SdrObject* pObj = rNoteMarkList.GetMark( 0 )->GetObj();
-        if ( pObj && pObj->GetLayer() == SC_LAYER_INTERN && pObj->ISA(SdrCaptionObj) )
+        const SdrMarkList& rNoteMarkList = pView->GetMarkedObjectList();
+        if(rNoteMarkList.GetMarkCount() == 1)
         {
-            if ( rMEvt.IsLeft() )
+            SdrObject* pObj = rNoteMarkList.GetMark( 0 )->GetObj();
+            if ( pObj && pObj->GetLayer() == SC_LAYER_INTERN && pObj->ISA(SdrCaptionObj) )
             {
                 Point aMPos = pWindow->PixelToLogic( rMEvt.GetPosPixel() );
-                if(SdrHdl* pHdl = pView->HitHandle(aMPos, *pWindow))
-                    bReSizingNote= TRUE;
+                bIsSizingOrMoving =
+                    pView->HitHandle( aMPos, *pWindow ) ||      // handles to resize the note
+                    pView->IsTextEditFrameHit( aMPos );         // frame for moving the note
             }
         }
     }
-    return bReSizingNote;
+    return bIsSizingOrMoving;
 }
 
-// we can arrive here if a Note set to 'not shown' has changed its 
-// text alignment leaving the note in resize/draw mode. The next mouse 
-// button-down action or ESC  should remove this note. 
+// we can arrive here if a Note set to 'not shown' has changed its
+// text alignment leaving the note in resize/draw mode. The next mouse
+// button-down action or ESC  should remove this note.
 void FuDraw::CheckVisibleNote() const
 {
     const SdrMarkList& rNoteMarkList = pView->GetMarkedObjectList();
Index: sc/source/ui/drawfunc/futext.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/drawfunc/futext.cxx,v
retrieving revision 1.20
retrieving revision 1.20.34.1
diff -u -p -u -p -r1.20 -r1.20.34.1
--- sc/source/ui/drawfunc/futext.cxx	21 Feb 2005 16:01:26 -0000	1.20
+++ sc/source/ui/drawfunc/futext.cxx	12 May 2005 15:20:20 -0000	1.20.34.1
@@ -178,7 +178,7 @@ BOOL __EXPORT FuText::MouseButtonDown(co
 
 	if ( pView->IsTextEdit() )
 	{
-		if(!IsReSizingNote(rMEvt))
+        if( !IsSizingOrMovingNote(rMEvt) )
 		    StopEditMode();			   // Danebengeklickt, Ende mit Edit
 		pView->SetCreateMode();
 	}
Index: sc/source/ui/inc/areasave.hxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/inc/areasave.hxx,v
retrieving revision 1.2
retrieving revision 1.2.346.1
diff -u -p -u -p -r1.2 -r1.2.346.1
--- sc/source/ui/inc/areasave.hxx	4 Jun 2004 11:29:55 -0000	1.2
+++ sc/source/ui/inc/areasave.hxx	22 Apr 2005 14:38:30 -0000	1.2.346.1
@@ -86,6 +86,7 @@ private:
 	String		aOptions;
 	String		aSourceArea;
 	ScRange		aDestArea;
+    ULONG       nRefresh;
 
 public:
 				ScAreaLinkSaver( const ScAreaLink& rSource );
@@ -98,6 +99,7 @@ public:
 	BOOL		IsEqualSource( const ScAreaLink& rCompare ) const;
 
 	void		WriteToLink( ScAreaLink& rLink ) const;
+	void        InsertNewLink( ScDocument* pDoc ) const;
 };
 
 
Index: sc/source/ui/inc/fudraw.hxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/inc/fudraw.hxx,v
retrieving revision 1.3
retrieving revision 1.3.36.1
diff -u -p -u -p -r1.3 -r1.3.36.1
--- sc/source/ui/inc/fudraw.hxx	21 Feb 2005 16:02:17 -0000	1.3
+++ sc/source/ui/inc/fudraw.hxx	12 May 2005 15:20:07 -0000	1.3.36.1
@@ -104,7 +104,7 @@ class FuDraw : public FuPoor
 	// #97016# II
 	virtual void SelectionHasChanged();
 
-	BOOL IsReSizingNote(const MouseEvent& rMEvt) const;
+    BOOL IsSizingOrMovingNote( const MouseEvent& rMEvt ) const;
 	void CheckVisibleNote() const;
 
  private:
Index: sc/source/ui/inc/tabvwsh.hxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/inc/tabvwsh.hxx,v
retrieving revision 1.21
retrieving revision 1.21.36.1
diff -u -p -u -p -r1.21 -r1.21.36.1
--- sc/source/ui/inc/tabvwsh.hxx	21 Feb 2005 16:03:15 -0000	1.21
+++ sc/source/ui/inc/tabvwsh.hxx	19 Jul 2005 10:11:04 -0000	1.21.36.1
@@ -430,6 +430,8 @@ public:
 	void			ConnectObject( SdrOle2Obj* pObj );
 	BOOL			ActivateObject( SdrOle2Obj* pObj, long nVerb );
 
+    void            DeactivateOle();
+
 	static ScTabViewShell* GetActiveViewShell();
 	SfxModelessDialog*	CreateRefDialog( SfxBindings* pB, SfxChildWindow* pCW,
 										SfxChildWinInfo* pInfo,
Index: sc/source/ui/undo/areasave.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/undo/areasave.cxx,v
retrieving revision 1.3
retrieving revision 1.3.220.1
diff -u -p -u -p -r1.3 -r1.3.220.1
--- sc/source/ui/undo/areasave.cxx	4 Oct 2004 20:20:00 -0000	1.3
+++ sc/source/ui/undo/areasave.cxx	22 Apr 2005 14:38:43 -0000	1.3.220.1
@@ -83,7 +83,8 @@ ScAreaLinkSaver::ScAreaLinkSaver( const 
 	aFilterName	( rSource.GetFilter() ),
 	aOptions	( rSource.GetOptions() ),
 	aSourceArea	( rSource.GetSource() ),
-	aDestArea	( rSource.GetDestArea() )
+	aDestArea	( rSource.GetDestArea() ),
+    nRefresh    ( rSource.GetRefreshDelay() )       // seconds
 {
 }
 
@@ -92,7 +93,8 @@ ScAreaLinkSaver::ScAreaLinkSaver( const 
 	aFilterName	( rCopy.aFilterName ),
 	aOptions	( rCopy.aOptions ),
 	aSourceArea	( rCopy.aSourceArea ),
-	aDestArea	( rCopy.aDestArea )
+	aDestArea	( rCopy.aDestArea ),
+    nRefresh    ( rCopy.nRefresh )
 {
 }
 
@@ -110,7 +112,8 @@ BOOL ScAreaLinkSaver::IsEqualSource( con
 	return ( aFileName	 == rCompare.GetFile() &&
 			 aFilterName == rCompare.GetFilter() &&
 			 aOptions	 == rCompare.GetOptions() &&
-			 aSourceArea == rCompare.GetSource() );
+			 aSourceArea == rCompare.GetSource() &&
+             nRefresh    == rCompare.GetRefreshDelay() );
 }
 
 BOOL ScAreaLinkSaver::IsEqual( const ScAreaLink& rCompare ) const
@@ -124,6 +127,25 @@ void ScAreaLinkSaver::WriteToLink( ScAre
 	rLink.SetDestArea( aDestArea );
 }
 
+void ScAreaLinkSaver::InsertNewLink( ScDocument* pDoc ) const
+{
+    // (see ScUndoRemoveAreaLink::Undo)
+
+    SvxLinkManager* pLinkManager = pDoc->GetLinkManager();
+    SfxObjectShell* pObjSh = pDoc->GetDocumentShell();
+
+    if ( pLinkManager && pObjSh )
+    {
+        ScAreaLink* pLink = new ScAreaLink( pObjSh, aFileName, aFilterName, aOptions,
+                                            aSourceArea, aDestArea.aStart, nRefresh );
+        pLink->SetInCreate( TRUE );
+        pLink->SetDestArea( aDestArea );
+        pLinkManager->InsertFileLink( *pLink, OBJECT_CLIENT_FILE, aFileName, &aFilterName, &aSourceArea );
+        pLink->Update();
+        pLink->SetInCreate( FALSE );
+    }
+}
+
 // -----------------------------------------------------------------------
 
 ScAreaLinkSaveCollection::ScAreaLinkSaveCollection()
@@ -146,6 +168,9 @@ DataObject*	ScAreaLinkSaveCollection::Cl
 
 BOOL ScAreaLinkSaveCollection::IsEqual( const ScDocument* pDoc ) const
 {
+    // IsEqual can be checked in sequence.
+    // Neither ref-update nor removing links will change the order.
+
 	SvxLinkManager* pLinkManager = const_cast<ScDocument*>(pDoc)->GetLinkManager();
 	if (pLinkManager)
 	{
@@ -163,42 +188,50 @@ BOOL ScAreaLinkSaveCollection::IsEqual( 
 				++nPos;
 			}
 		}
+        if ( nPos < GetCount() )
+            return FALSE;           // fewer links in the document than in the save collection
 	}
 
 	return TRUE;
 }
 
+ScAreaLink* lcl_FindLink( const ::sfx2::SvBaseLinks& rLinks, const ScAreaLinkSaver& rSaver )
+{
+    USHORT nLinkCount = rLinks.Count();
+    for (USHORT i=0; i<nLinkCount; i++)
+    {
+        ::sfx2::SvBaseLink* pBase = *rLinks[i];
+    	if ( pBase->ISA(ScAreaLink) &&
+    	     rSaver.IsEqualSource( *static_cast<ScAreaLink*>(pBase) ) )
+    	{
+    	    return static_cast<ScAreaLink*>(pBase);     // found
+    	}
+    }
+    return NULL;    // not found
+}
+
 void ScAreaLinkSaveCollection::Restore( ScDocument* pDoc ) const
 {
-	BOOL bError = FALSE;
-	SvxLinkManager* pLinkManager = pDoc->GetLinkManager();
-	if (pLinkManager)
-	{
-		USHORT nPos = 0;
+    // The save collection may contain additional entries that are not in the document.
+    // They must be inserted again.
+    // Entries from the save collection must be searched via source data, as the order
+    // of links changes if deleted entries are re-added to the link manager (always at the end).
+
+    SvxLinkManager* pLinkManager = pDoc->GetLinkManager();
+    if (pLinkManager)
+    {
         const ::sfx2::SvBaseLinks& rLinks = pLinkManager->GetLinks();
-		USHORT nLinkCount = rLinks.Count();
-		for (USHORT i=0; i<nLinkCount; i++)
-		{
-            ::sfx2::SvBaseLink* pBase = *rLinks[i];
-			if (pBase->ISA(ScAreaLink))
-			{
-				ScAreaLink* pLink = (ScAreaLink*)pBase;
-				if ( nPos < GetCount() )
-				{
-					ScAreaLinkSaver* pSaver = (*this)[nPos];
-					if ( pSaver->IsEqualSource( *pLink ) )
-						pSaver->WriteToLink( *pLink );
-					else
-						bError = TRUE;
-				}
-				else
-					bError = TRUE;
-
-				++nPos;
-			}
-		}
-	}
-	DBG_ASSERT( !bError, "ScAreaLinkSaveCollection: wrong links" );
+        USHORT nCount = GetCount();
+        for (USHORT nPos=0; nPos<nCount; nPos++)
+        {
+            ScAreaLinkSaver* pSaver = (*this)[nPos];
+            ScAreaLink* pLink = lcl_FindLink( rLinks, *pSaver );
+            if ( pLink )
+                pSaver->WriteToLink( *pLink );          // restore output position
+            else
+                pSaver->InsertNewLink( pDoc );          // re-insert deleted link
+        }
+    }
 }
 
 // static
Index: sc/source/ui/undo/undoblk.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/undo/undoblk.cxx,v
retrieving revision 1.17
retrieving revision 1.17.36.2
diff -u -p -u -p -r1.17 -r1.17.36.2
--- sc/source/ui/undo/undoblk.cxx	21 Feb 2005 16:03:32 -0000	1.17
+++ sc/source/ui/undo/undoblk.cxx	28 Jul 2005 08:43:51 -0000	1.17.36.2
@@ -73,6 +73,7 @@
 #include <vcl/virdev.hxx>
 #include <vcl/waitobj.hxx>
 #include <svx/boxitem.hxx>
+#include <sfx2/app.hxx>
 
 #include "undoblk.hxx"
 #include "undoutil.hxx"
@@ -95,6 +96,7 @@
 #include "transobj.hxx"
 #include "refundo.hxx"
 #include "undoolk.hxx"
+#include "sc.hrc"
 
 
 // STATIC DATA -----------------------------------------------------------
@@ -385,6 +387,10 @@ void ScUndoDeleteCells::DoChange( const 
 	else
 		SetChangeTrack();
 
+    // are there merged cells?
+    ScRange aWorkRange( aEffRange );
+    BOOL bMergeBefore = pDoc->HasAttrib( aWorkRange, HASATTR_MERGED );
+
 	// Ausfuehren
 	switch (eCmd)
 	{
@@ -410,14 +416,15 @@ void ScUndoDeleteCells::DoChange( const 
 
 //?	Datenbank muss vor ExtendMerge sein ?????
 
-	// Zusammengefasste Zellen?
-	ScRange aWorkRange( aEffRange );
-	if ( pDoc->HasAttrib( aWorkRange, HASATTR_MERGED ) )
-	{
-/*?		if ( !bUndo && ( eCmd==DEL_DELCOLS || eCmd==DEL_DELROWS ) )
+    if ( bMergeBefore || pDoc->HasAttrib( aWorkRange, HASATTR_MERGED ) )
+    {
+        // #i51445# old merge flag attributes must be deleted also for single cells,
+        // not only for whole columns/rows
+
+        if ( !bUndo )
 		{
-			if (eCmd==DEL_DELCOLS) aWorkRange.aEnd.SetCol(MAXCOL);
-			if (eCmd==DEL_DELROWS) aWorkRange.aEnd.SetRow(MAXROW);
+            if ( eCmd==DEL_DELCOLS || eCmd==DEL_CELLSLEFT ) aWorkRange.aEnd.SetCol(MAXCOL);
+            if ( eCmd==DEL_DELROWS || eCmd==DEL_CELLSUP ) aWorkRange.aEnd.SetRow(MAXROW);
 			ScMarkData aMarkData;
 			aMarkData.SelectOneTable( aWorkRange.aStart.Tab() );
 			ScPatternAttr aPattern( pDoc->GetPool() );
@@ -426,7 +433,7 @@ void ScUndoDeleteCells::DoChange( const 
 									aWorkRange.aEnd.Col(),   aWorkRange.aEnd.Row(),
 									aMarkData, aPattern );
 		}
-?*/
+
 		pDoc->ExtendMerge( aWorkRange, TRUE );
 	}
 
@@ -477,6 +484,7 @@ void __EXPORT ScUndoDeleteCells::Undo()
 	BeginUndo();
 	DoChange( TRUE );
 	EndUndo();
+    SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 
 	// Markierung erst nach EndUndo
 	ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
@@ -490,6 +498,7 @@ void __EXPORT ScUndoDeleteCells::Redo()
 	BeginRedo();
 	DoChange( FALSE);
 	EndRedo();
+    SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 
 	ScTabViewShell* pViewShell = ScTabViewShell::GetActiveViewShell();
 	if (pViewShell)
@@ -631,6 +640,7 @@ void __EXPORT ScUndoDeleteMulti::Undo()
 	//!	geht im Moment nicht, da keine Daten fuer Markierung vorhanden!
 
 	EndUndo();
+    SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 }
 
 void __EXPORT ScUndoDeleteMulti::Redo()
@@ -662,6 +672,7 @@ void __EXPORT ScUndoDeleteMulti::Redo()
 //!		DoneBlockMode();
 
 	EndRedo();
+    SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 }
 
 void __EXPORT ScUndoDeleteMulti::Repeat(SfxRepeatTarget& rTarget)
@@ -998,6 +1009,7 @@ void __EXPORT ScUndoPaste::Undo()
 	DoChange( TRUE );
 	ShowTable( aBlockRange );
 	EndUndo();
+    SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 }
 
 void __EXPORT ScUndoPaste::Redo()
@@ -1008,6 +1020,7 @@ void __EXPORT ScUndoPaste::Redo()
 	DoChange( FALSE );
 	EnableDrawAdjust( pDoc, TRUE );					//! include in ScBlockUndo?
 	EndRedo();
+    SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 }
 
 void __EXPORT ScUndoPaste::Repeat(SfxRepeatTarget& rTarget)
@@ -1180,6 +1193,7 @@ void __EXPORT ScUndoDragDrop::Undo()
 	if (bCut)
 		DoUndo(aSrcRange);
 	EndUndo();
+    SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 }
 
 void __EXPORT ScUndoDragDrop::Redo()
@@ -1240,6 +1254,7 @@ void __EXPORT ScUndoDragDrop::Redo()
 	EnableDrawAdjust( pDoc, TRUE );				//! include in ScBlockUndo?
 
 	EndRedo();
+    SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 }
 
 void __EXPORT ScUndoDragDrop::Repeat(SfxRepeatTarget& rTarget)
Index: sc/source/ui/undo/undotab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/undo/undotab.cxx,v
retrieving revision 1.10
retrieving revision 1.10.346.1
diff -u -p -u -p -r1.10 -r1.10.346.1
--- sc/source/ui/undo/undotab.cxx	4 Jun 2004 11:52:20 -0000	1.10
+++ sc/source/ui/undo/undotab.cxx	22 Apr 2005 14:38:43 -0000	1.10.346.1
@@ -469,7 +469,10 @@ void __EXPORT ScUndoDeleteTab::Undo()
 	{
 		pDocShell->Broadcast( ScTablesHint( SC_TAB_INSERTED, theTabs[i]) );
 	}
-	SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );	// Navigator
+    SfxApplication* pSfxApp = SFX_APP();                                // Navigator
+    pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
+    pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_DBAREAS_CHANGED ) );
+    pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 
 	pDocShell->PostPaint(0,0,0, MAXCOL,MAXROW,MAXTAB, PAINT_ALL );	// incl. Extras
 
Index: sc/source/ui/unoobj/styleuno.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/unoobj/styleuno.cxx,v
retrieving revision 1.32
retrieving revision 1.32.4.1
diff -u -p -u -p -r1.32 -r1.32.4.1
--- sc/source/ui/unoobj/styleuno.cxx	23 Mar 2005 13:12:39 -0000	1.32
+++ sc/source/ui/unoobj/styleuno.cxx	21 Apr 2005 10:37:20 -0000	1.32.4.1
@@ -1750,6 +1750,9 @@ void ScStyleObj::SetOnePropertyValue( co
 						case ATTR_PAGE_SCALETOPAGES:
 						case ATTR_PAGE_FIRSTPAGENO:
 							{
+                                rSet.ClearItem(ATTR_PAGE_SCALETOPAGES);
+                                rSet.ClearItem(ATTR_PAGE_SCALE);
+                                rSet.ClearItem(ATTR_PAGE_SCALETO);
 								sal_Int16 nVal;
 								*pValue >>= nVal;
 								rSet.Put( SfxUInt16Item( pMap->nWID, nVal ) );
@@ -1810,6 +1813,8 @@ void ScStyleObj::SetOnePropertyValue( co
                                     else
                                         aItem.SetHeight(static_cast<sal_uInt16>(nPages));
                                     rSet.Put( aItem );
+                                    rSet.ClearItem(ATTR_PAGE_SCALETOPAGES);
+                                    rSet.ClearItem(ATTR_PAGE_SCALE);
                                 }
                             }
                             break;
Index: sc/source/ui/view/gridwin.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/gridwin.cxx,v
retrieving revision 1.70
retrieving revision 1.68.16.2
diff -u -p -u -p -r1.70 -r1.68.16.2
--- sc/source/ui/view/gridwin.cxx	12 Jul 2005 14:22:10 -0000	1.70
+++ sc/source/ui/view/gridwin.cxx	10 Aug 2005 16:25:22 -0000	1.68.16.2
@@ -1270,9 +1270,16 @@ void ScGridWindow::FilterSelect( ULONG n
 
 void ScGridWindow::ExecDataSelect( SCCOL nCol, SCROW nRow, const String& rStr )
 {
-	SCTAB nTab = pViewData->GetTabNo();
-	if ( rStr.Len() )
-		pViewData->GetView()->EnterData( nCol, nRow, nTab, rStr );
+    if ( rStr.Len() )
+    {
+        SCTAB nTab = pViewData->GetTabNo();
+        ScViewFunc* pView = pViewData->GetView();
+        pView->EnterData( nCol, nRow, nTab, rStr );
+
+        // #i52307# CellContentChanged is not in EnterData so it isn't called twice
+        // if the cursor is moved afterwards.
+        pView->CellContentChanged();
+    }
 }
 
 void ScGridWindow::ExecFilter( ULONG nSel,
Index: sc/source/ui/view/gridwin3.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/gridwin3.cxx,v
retrieving revision 1.11
retrieving revision 1.11.260.1
diff -u -p -u -p -r1.11 -r1.11.260.1
--- sc/source/ui/view/gridwin3.cxx	2 Aug 2004 10:15:02 -0000	1.11
+++ sc/source/ui/view/gridwin3.cxx	19 Jul 2005 10:11:24 -0000	1.11.260.1
@@ -506,6 +506,10 @@ void ScGridWindow::UpdateStatusPosSize()
 	if (!pDrView)
 		return;			// shouldn't be called in that case
 
+    SdrPageView* pPV = pDrView->GetPageViewPvNum(0);
+    if (!pPV)
+        return;         // shouldn't be called in that case either
+
 	SfxItemSet aSet(pViewData->GetViewShell()->GetPool(), SID_ATTR_POSITION, SID_ATTR_SIZE);
 
 	//	Fill items for position and size:
@@ -520,7 +524,7 @@ void ScGridWindow::UpdateStatusPosSize()
 		pDrView->TakeActionRect( aRect );
 		if ( !aRect.IsEmpty() )
 		{
-			pDrView->GetPageViewPvNum(0)->LogicToPagePos(aRect);
+			pPV->LogicToPagePos(aRect);
 			aSet.Put( SfxPointItem( SID_ATTR_POSITION, aRect.TopLeft() ) );
 			aSet.Put( SvxSizeItem( SID_ATTR_SIZE,
 					Size( aRect.Right() - aRect.Left(), aRect.Bottom() - aRect.Top() ) ) );
@@ -532,7 +536,7 @@ void ScGridWindow::UpdateStatusPosSize()
 		if ( pDrView->AreObjectsMarked() )		// selected objects
 		{
 			Rectangle aRect = pDrView->GetAllMarkedRect();
-			pDrView->GetPageViewPvNum(0)->LogicToPagePos(aRect);
+			pPV->LogicToPagePos(aRect);
 			aSet.Put( SfxPointItem( SID_ATTR_POSITION, aRect.TopLeft() ) );
 			aSet.Put( SvxSizeItem( SID_ATTR_SIZE,
 					Size( aRect.Right() - aRect.Left(), aRect.Bottom() - aRect.Top() ) ) );
@@ -540,7 +544,7 @@ void ScGridWindow::UpdateStatusPosSize()
 		else								// mouse position
 		{
 			Point aPos = PixelToLogic(aCurMousePos);
-			pDrView->GetPageViewPvNum(0)->LogicToPagePos(aPos);
+			pPV->LogicToPagePos(aPos);
 			aSet.Put( SfxPointItem( SID_ATTR_POSITION, aPos ) );
 			aSet.Put( SvxSizeItem( SID_ATTR_SIZE, Size( 0, 0 ) ) );
 		}
Index: sc/source/ui/view/gridwin4.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/gridwin4.cxx,v
retrieving revision 1.26
retrieving revision 1.26.216.1
diff -u -p -u -p -r1.26 -r1.26.216.1
--- sc/source/ui/view/gridwin4.cxx	4 Oct 2004 20:23:40 -0000	1.26
+++ sc/source/ui/view/gridwin4.cxx	12 May 2005 09:39:11 -0000	1.26.216.1
@@ -544,6 +544,9 @@ void ScGridWindow::Draw( SCCOL nX1, SCRO
 
 	aOutputData.SetMirrorWidth( nMirrorWidth );			// needed for RTL
 
+    std::auto_ptr< VirtualDevice > xFmtVirtDev;
+    BOOL bLogicText = bTextWysiwyg;                     // call DrawStrings in logic MapMode?
+
 	if ( bTextWysiwyg )
 	{
 		//	use printer for text formatting
@@ -552,6 +555,17 @@ void ScGridWindow::Draw( SCCOL nX1, SCRO
 		pFmtDev->SetMapMode( pViewData->GetLogicMode(eWhich) );
 		aOutputData.SetFmtDevice( pFmtDev );
 	}
+    else if ( aZoomX != aZoomY && pViewData->IsOle() )
+    {
+        //  #i45033# For OLE inplace editing with different zoom factors,
+        //  use a virtual device with 1/100th mm as text formatting reference
+
+        xFmtVirtDev.reset( new VirtualDevice );
+        xFmtVirtDev->SetMapMode( MAP_100TH_MM );
+        aOutputData.SetFmtDevice( xFmtVirtDev.get() );
+
+        bLogicText = TRUE;                      // use logic MapMode
+    }
 
     const svtools::ColorConfig& rColorCfg = pScMod->GetColorConfig();
     Color aGridColor( rColorCfg.GetColorValue( svtools::CALCGRID, FALSE ).nColor );
@@ -648,7 +662,7 @@ void ScGridWindow::Draw( SCCOL nX1, SCRO
 	}
 	aOutputData.DrawShadow();
 	aOutputData.DrawFrame();
-	if ( !bTextWysiwyg )
+	if ( !bLogicText )
 		aOutputData.DrawStrings(FALSE);		// in pixel MapMode
 
 		// Autofilter- und Pivot-Buttons
@@ -663,7 +677,7 @@ void ScGridWindow::Draw( SCCOL nX1, SCRO
 		// Edit-Zellen
 
 	SetMapMode(pViewData->GetLogicMode(eWhich));
-	if ( bTextWysiwyg )
+	if ( bLogicText )
 		aOutputData.DrawStrings(TRUE);		// in logic MapMode if bTextWysiwyg is set
 	aOutputData.DrawEdit(TRUE);
 
Index: sc/source/ui/view/olinewin.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/olinewin.cxx,v
retrieving revision 1.10
retrieving revision 1.10.2.1
diff -u -p -u -p -r1.10 -r1.10.2.1
--- sc/source/ui/view/olinewin.cxx	22 Apr 2005 11:33:22 -0000	1.10
+++ sc/source/ui/view/olinewin.cxx	15 Jul 2005 14:43:14 -0000	1.10.2.1
@@ -299,8 +299,9 @@ size_t ScOutlineWindow::GetLevelCount() 
 
 long ScOutlineWindow::GetLevelPos( size_t nLevel ) const
 {
+    // #i51970# must always return the *left* edge of the area used by a level
     long nPos = static_cast< long >( SC_OL_POSOFFSET + nLevel * SC_OL_BITMAPSIZE );
-    return mbMirrorLevels ? (GetOutputSizeLevel() - nPos - 1) : nPos;
+    return mbMirrorLevels ? (GetOutputSizeLevel() - nPos - SC_OL_BITMAPSIZE) : nPos;
 }
 
 size_t ScOutlineWindow::GetLevelFromPos( long nLevelPos ) const
Index: sc/source/ui/view/tabcont.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/tabcont.cxx,v
retrieving revision 1.10
retrieving revision 1.10.220.1
diff -u -p -u -p -r1.10 -r1.10.220.1
--- sc/source/ui/view/tabcont.cxx	4 Oct 2004 20:24:41 -0000	1.10
+++ sc/source/ui/view/tabcont.cxx	19 Jul 2005 10:11:25 -0000	1.10.220.1
@@ -425,6 +425,10 @@ void ScTabControl::Command( const Comman
                     Select();
                 }
 			}
+
+            // #i52073# OLE inplace editing has to be stopped before showing the sheet tab context menu
+            pViewSh->DeactivateOle();
+
 			//	Popup-Menu:
 			//	get Dispatcher from ViewData (ViewFrame) instead of Shell (Frame), so it can't be null
 			pViewData->GetDispatcher().ExecutePopup( ScResId(RID_POPUP_TAB) );
Index: sc/source/ui/view/tabview.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/tabview.cxx,v
retrieving revision 1.25
retrieving revision 1.25.34.1
diff -u -p -u -p -r1.25 -r1.25.34.1
--- sc/source/ui/view/tabview.cxx	21 Feb 2005 13:54:44 -0000	1.25
+++ sc/source/ui/view/tabview.cxx	27 Apr 2005 18:16:10 -0000	1.25.34.1
@@ -944,9 +944,18 @@ void ScTabView::RepeatResize( BOOL bUpda
 {
 	if ( bUpdateFix )
 	{
-		if ( aViewData.GetHSplitMode() == SC_SPLIT_FIX )
+        ScSplitMode eHSplit = aViewData.GetHSplitMode();
+        ScSplitMode eVSplit = aViewData.GetVSplitMode();
+
+        // #i46796# UpdateFixX / UpdateFixY uses GetGridOffset, which requires the
+        // outline windows to be available. So UpdateShow has to be called before
+        // (also called from DoResize).
+        if ( eHSplit == SC_SPLIT_FIX || eVSplit == SC_SPLIT_FIX )
+            UpdateShow();
+
+        if ( eHSplit == SC_SPLIT_FIX )
 			aViewData.UpdateFixX();
-		if ( aViewData.GetVSplitMode() == SC_SPLIT_FIX )
+        if ( eVSplit == SC_SPLIT_FIX )
 			aViewData.UpdateFixY();
 	}
 
Index: sc/source/ui/view/tabvwshb.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/tabvwshb.cxx,v
retrieving revision 1.24
retrieving revision 1.24.8.1
diff -u -p -u -p -r1.24 -r1.24.8.1
--- sc/source/ui/view/tabvwshb.cxx	15 Mar 2005 11:43:57 -0000	1.24
+++ sc/source/ui/view/tabvwshb.cxx	19 Jul 2005 10:11:25 -0000	1.24.8.1
@@ -78,6 +78,7 @@
 // INCLUDE ---------------------------------------------------------------
 
 #include <com/sun/star/embed/EmbedMisc.hpp>
+#include <com/sun/star/embed/EmbedStates.hpp>
 
 #include <toolkit/helper/vclunohelper.hxx>
 #include <svx/svxdlg.hxx>
@@ -330,6 +331,18 @@ ErrCode __EXPORT ScTabViewShell::DoVerb(
 	return nErr;
 }
 
+void ScTabViewShell::DeactivateOle()
+{
+    // deactivate inplace editing if currently active
+
+    ScClient* pClient = (ScClient*) GetIPClient();
+    if ( pClient && pClient->IsObjectInPlaceActive() )
+    {
+        pClient->GetObject()->changeState( embed::EmbedStates::RUNNING );
+        SFX_APP()->SetViewFrame(GetViewFrame());
+    }
+}
+
 void ScTabViewShell::ExecDrawIns(SfxRequest& rReq)
 {
 	USHORT nSlot = rReq.GetSlot();
Index: sc/source/ui/view/tabvwshh.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/tabvwshh.cxx,v
retrieving revision 1.9
retrieving revision 1.9.8.1
diff -u -p -u -p -r1.9 -r1.9.8.1
--- sc/source/ui/view/tabvwshh.cxx	13 Apr 2005 12:21:02 -0000	1.9
+++ sc/source/ui/view/tabvwshh.cxx	19 Jul 2005 10:11:25 -0000	1.9.8.1
@@ -76,10 +76,6 @@
 #include <basic/sbxcore.hxx>
 #include <svtools/whiter.hxx>
 
-#ifndef _COM_SUN_STAR_EMBED_EMBEDSTATES_HPP_
-#include <com/sun/star/embed/EmbedStates.hpp>
-#endif
-
 #include "tabvwsh.hxx"
 #include "client.hxx"
 #include "document.hxx"
@@ -141,14 +137,7 @@ void ScTabViewShell::ExecuteObject( SfxR
 			}
 			break;
 		case SID_OLE_DEACTIVATE:
-			{
-				ScClient* pClient = (ScClient*) pVisibleSh->GetIPClient();
-                if ( pClient && pClient->IsObjectInPlaceActive() )
-				{
-                    pClient->GetObject()->changeState( embed::EmbedStates::RUNNING );
-					SFX_APP()->SetViewFrame(pVisibleSh->GetViewFrame());
-				}
-			}
+            pVisibleSh->DeactivateOle();
 			break;
 
 		case SID_OBJECT_LEFT:
Index: sc/source/ui/view/viewdata.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/viewdata.cxx,v
retrieving revision 1.52
retrieving revision 1.51.4.3
diff -u -p -u -p -r1.52 -r1.51.4.3
--- sc/source/ui/view/viewdata.cxx	13 May 2005 07:33:42 -0000	1.52
+++ sc/source/ui/view/viewdata.cxx	19 Apr 2005 14:52:14 -0000	1.51.4.3
@@ -2517,9 +2517,14 @@ void ScViewData::ReadExtOptions( const S
 //                if( (rSel.Count() >= 2) || ((rSel.Count() == 1) && (*rSel.GetObject( 0 ) != ScRange( rCursor ))) )
 //                    rMarkData.MarkFromRangeList( rTabSett.maSelection, FALSE );
 
-                // grid color
-                if( pOptions && (rTabSett.maGridColor.GetColor() != COL_AUTO) )
-                    pOptions->SetGridColor( rTabSett.maGridColor, EMPTY_STRING );
+                // grid color -- #i47435# set automatic grid color explicitly
+                if( pOptions )
+                {
+                    Color aGridColor( rTabSett.maGridColor );
+                    if( aGridColor.GetColor() == COL_AUTO )
+                        aGridColor.SetColor( SC_STD_GRIDCOLOR );
+                    pOptions->SetGridColor( aGridColor, EMPTY_STRING );
+                }
 
                 // view mode and zoom
                 if( rTabSett.mnNormalZoom )
@@ -2766,6 +2771,9 @@ void ScViewData::ReadUserDataSequence(co
 	}
 	if (nCount)
 		SetPagebreakMode( bPageMode );
+
+    // #i47426# write view options to document, needed e.g. for Excel export
+    pDoc->SetViewOptions( *pOptions );
 }
 
 void ScViewData::SetOptions( const ScViewOptions& rOpt )
Index: sc/source/ui/view/viewfun2.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/viewfun2.cxx,v
retrieving revision 1.26
retrieving revision 1.26.46.2
diff -u -p -u -p -r1.26 -r1.26.46.2
--- sc/source/ui/view/viewfun2.cxx	16 Feb 2005 18:12:00 -0000	1.26
+++ sc/source/ui/view/viewfun2.cxx	28 Jul 2005 08:43:29 -0000	1.26.46.2
@@ -94,7 +94,6 @@
 #include "sc.hrc"
 #include "globstr.hrc"
 
-#include "arealink.hxx"
 #include "attrib.hxx"
 #include "autoform.hxx"
 #include "cell.hxx"					// EnterAutoSum
@@ -1891,7 +1890,11 @@ BOOL ScViewFunc::DeleteTables(const SvSh
 
 		pDocSh->PostPaintExtras();
 		pDocSh->SetDocumentModified();
-		SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
+
+        SfxApplication* pSfxApp = SFX_APP();                                // Navigator
+        pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_TABLES_CHANGED ) );
+        pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_DBAREAS_CHANGED ) );
+        pSfxApp->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 	}
 	else
 	{
@@ -1925,42 +1928,12 @@ void ScViewFunc::InsertAreaLink( const S
 									const String& rSource, ULONG nRefresh )
 {
 	ScDocShell* pDocSh = GetViewData()->GetDocShell();
-	ScDocument* pDoc = pDocSh->GetDocument();
 	SCCOL nPosX = GetViewData()->GetCurX();
 	SCROW nPosY = GetViewData()->GetCurY();
 	SCTAB nTab = GetViewData()->GetTabNo();
 	ScAddress aPos( nPosX, nPosY, nTab );
-	BOOL bUndo (pDoc->IsUndoEnabled());
-
-	String aFilterName = rFilter;
-	String aNewOptions = rOptions;
-	if (!aFilterName.Len())
-        ScDocumentLoader::GetFilterName( rFile, aFilterName, aNewOptions, TRUE );
-
-	SvxLinkManager* pLinkManager = pDoc->GetLinkManager();
-
-	ScAreaLink* pLink = new ScAreaLink( pDocSh, rFile, aFilterName, aNewOptions, rSource, aPos, nRefresh );
-	pLinkManager->InsertFileLink( *pLink, OBJECT_CLIENT_FILE, rFile, &aFilterName, &rSource );
-
-	//	Undo fuer den leeren Link
-
-	if (bUndo)
-	{
-		pDocSh->GetUndoManager()->AddUndoAction( new ScUndoInsertAreaLink( pDocSh,
-													rFile, aFilterName, aNewOptions,
-													rSource, ScRange(aPos), nRefresh ) );
-	}
-
-	//	Update hat sein eigenes Undo
-
-	pLink->SetDoInsert(FALSE);	// beim ersten Update nichts einfuegen
-	pLink->Update();			// kein SetInCreate -> Update ausfuehren
-	pLink->SetDoInsert(TRUE);	// Default = TRUE
-
-	SfxBindings& rBindings = GetViewData()->GetBindings();
-	rBindings.Invalidate( SID_LINKS );
 
-	SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );		// Navigator
+    pDocSh->GetDocFunc().InsertAreaLink( rFile, rFilter, rOptions, rSource, aPos, nRefresh, FALSE, FALSE );
 }
 
 
Index: sc/source/ui/view/viewfunc.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/viewfunc.cxx,v
retrieving revision 1.27
retrieving revision 1.27.222.1
diff -u -p -u -p -r1.27 -r1.27.222.1
--- sc/source/ui/view/viewfunc.cxx	9 Sep 2004 09:31:12 -0000	1.27
+++ sc/source/ui/view/viewfunc.cxx	28 Jul 2005 08:43:28 -0000	1.27.222.1
@@ -1698,6 +1698,8 @@ void ScViewFunc::DeleteMulti( BOOL bRows
 	SetCursor( nCurX, nCurY );
 
 	delete[] pRanges;
+
+    SFX_APP()->Broadcast( SfxSimpleHint( SC_HINT_AREALINKS_CHANGED ) );
 }
 
 //	Inhalte loeschen
Index: shell/source/backends/localebe/localebackend.cxx
===================================================================
RCS file: /cvs/gsl/shell/source/backends/localebe/localebackend.cxx,v
retrieving revision 1.3
retrieving revision 1.3.56.1
diff -u -p -u -p -r1.3 -r1.3.56.1
--- shell/source/backends/localebe/localebackend.cxx	22 Oct 2004 08:13:51 -0000	1.3
+++ shell/source/backends/localebe/localebackend.cxx	16 Jun 2005 12:34:23 -0000	1.3.56.1
@@ -87,11 +87,11 @@
  * especially interfere with the stuff VCL is doing, so make sure this
  * is called from the main thread only.
  */
- 
+
 static rtl::OUString ImplGetLocale(int category)
 {
     const char *locale = setlocale(category, "");
-    
+
     // Return "en-US" for C locales
     if( (locale == NULL) || ( locale[0] == 'C' && locale[1] == '\0' ) )
         return rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "en-US" ) );
@@ -110,9 +110,9 @@ static rtl::OUString ImplGetLocale(int c
         if (*cp == '.' || *cp == '@')
             break;
     }
-    
+
     rtl::OUStringBuffer aLocaleBuffer;
-    if( uscore != NULL ) 
+    if( uscore != NULL )
     {
         aLocaleBuffer.appendAscii(locale, uscore++ - locale);
         aLocaleBuffer.appendAscii("-");
@@ -122,7 +122,7 @@ static rtl::OUString ImplGetLocale(int c
     {
         aLocaleBuffer.appendAscii(locale, cp - locale);
     }
-    
+
     return aLocaleBuffer.makeStringAndClear();
 }
 
@@ -143,16 +143,17 @@ rtl::OUString ImplGetLocale(LCID lcid)
 {
     TCHAR buffer[8];
     LPTSTR cp = buffer;
-    
+
     cp += GetLocaleInfo( lcid, LOCALE_SISO639LANGNAME , buffer, 4 );
     if( cp > buffer )
     {
         if( 0 < GetLocaleInfo( lcid, LOCALE_SISO3166CTRYNAME, cp, buffer + 8 - cp) )
-          *cp = '-';
-        
+            // #i50822# minus character must be written before cp
+            *(cp - 1) = '-';
+
         return rtl::OUString::createFromAscii(buffer);
     }
-    
+
     return rtl::OUString();
 }
 
@@ -164,19 +165,19 @@ LocaleBackend::LocaleBackend(const uno::
     throw (backend::BackendAccessException) :
     ::cppu::WeakImplHelper2 < backend::XSingleLayerStratum, lang::XServiceInfo > (),
     m_xContext(xContext)
-    
+
 {
 }
 
 //------------------------------------------------------------------------------
 
-LocaleBackend::~LocaleBackend(void) 
+LocaleBackend::~LocaleBackend(void)
 {
 }
 
 //------------------------------------------------------------------------------
 
-LocaleBackend* LocaleBackend::createInstance( 
+LocaleBackend* LocaleBackend::createInstance(
     const uno::Reference<uno::XComponentContext>& xContext
 )
 {
@@ -185,7 +186,7 @@ LocaleBackend* LocaleBackend::createInst
 
 // ---------------------------------------------------------------------------------------
 
-rtl::OUString LocaleBackend::getLocale(void) 
+rtl::OUString LocaleBackend::getLocale(void)
 {
 #ifdef UNX
     return ImplGetLocale(LC_CTYPE);
@@ -196,7 +197,7 @@ rtl::OUString LocaleBackend::getLocale(v
 
 //------------------------------------------------------------------------------
 
-rtl::OUString LocaleBackend::getUILocale(void) 
+rtl::OUString LocaleBackend::getUILocale(void)
 {
 #ifdef UNX
     return ImplGetLocale(LC_MESSAGES);
