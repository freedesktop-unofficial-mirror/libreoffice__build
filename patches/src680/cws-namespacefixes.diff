Index: filter/source/svg/svgexport.cxx
===================================================================
RCS file: /cvs/framework/filter/source/svg/svgexport.cxx,v
retrieving revision 1.15
retrieving revision 1.15.44.1
diff -u -p -u -p -r1.15 -r1.15.44.1
--- filter/source/svg/svgexport.cxx	18 Jan 2007 14:10:00 -0000	1.15
+++ filter/source/svg/svgexport.cxx	30 May 2007 11:57:18 -0000	1.15.44.1
@@ -49,7 +49,8 @@
 #include <svx/flditem.hxx>
 #include <svx/numitem.hxx>
 
-using namespace ::rtl;
+using ::rtl::OUString;
+
 // -------------
 // - SVGExport -
 // -------------
Index: filter/source/svg/svgfilter.cxx
===================================================================
RCS file: /cvs/framework/filter/source/svg/svgfilter.cxx,v
retrieving revision 1.11
retrieving revision 1.11.72.1
diff -u -p -u -p -r1.11 -r1.11.72.1
--- filter/source/svg/svgfilter.cxx	1 Dec 2006 14:30:29 -0000	1.11
+++ filter/source/svg/svgfilter.cxx	30 May 2007 11:57:18 -0000	1.11.72.1
@@ -53,7 +53,7 @@
 #include <vos/mutex.hxx>
 #endif
 
-using namespace ::rtl;
+using ::rtl::OUString;
 using namespace ::com::sun::star;
 
 // -------------
Index: filter/source/svg/svguno.cxx
===================================================================
RCS file: /cvs/framework/filter/source/svg/svguno.cxx,v
retrieving revision 1.4
retrieving revision 1.4.72.1
diff -u -p -u -p -r1.4 -r1.4.72.1
--- filter/source/svg/svguno.cxx	1 Dec 2006 14:31:27 -0000	1.4
+++ filter/source/svg/svguno.cxx	30 May 2007 11:57:18 -0000	1.4.72.1
@@ -47,7 +47,7 @@
 
 #include <svgfilter.hxx>
 
-using namespace ::rtl;
+using ::rtl::OUString;
 using namespace ::cppu;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::lang;
Index: unoxml/prj/build.lst
===================================================================
RCS file: /cvs/framework/unoxml/prj/build.lst,v
retrieving revision 1.8
retrieving revision 1.8.28.1
diff -u -p -u -p -r1.8 -r1.8.28.1
--- unoxml/prj/build.lst	5 May 2006 12:40:55 -0000	1.8
+++ unoxml/prj/build.lst	31 May 2007 10:10:48 -0000	1.8.28.1
@@ -2,4 +2,6 @@ ux	unoxml	:	offuh cppuhelper LIBXML2:lib
 ux	unoxml\source\dom			nmake	-	all	ux_dom      NULL
 ux	unoxml\source\xpath			nmake	-	all	ux_xpath    ux_dom NULL
 ux	unoxml\source\events		nmake	-	all	ux_events   ux_dom NULL
-ux	unoxml\source\service		nmake	-	all ux_service  ux_dom ux_xpath ux_events NULL
+ux  unoxml\source\fastsax\api	nmake   -   all ux_fapi		NULL
+ux  unoxml\source\fastsax		nmake	-	all ux_fastsax ux_fapi NULL
+ux	unoxml\source\service		nmake	-	all ux_service  ux_dom ux_xpath ux_events ux_fapi ux_fastsax NULL
Index: unoxml/prj/d.lst
===================================================================
RCS file: /cvs/framework/unoxml/prj/d.lst,v
retrieving revision 1.2
retrieving revision 1.2.44.1
diff -u -p -u -p -r1.2 -r1.2.44.1
--- unoxml/prj/d.lst	9 Sep 2005 09:53:32 -0000	1.2
+++ unoxml/prj/d.lst	4 Jun 2007 12:31:20 -0000	1.2.44.1
@@ -1,3 +1,14 @@
 ..\%__SRC%\lib\lib*.so %_DEST%\lib%_EXT%\lib*.so
 ..\%__SRC%\lib\lib*.dylib %_DEST%\lib%_EXT%\lib*.dylib
 ..\%__SRC%\bin\*.dll %_DEST%\bin%_EXT%\*.dll
+
+mkdir: %_DEST%\inc%_EXT%\com
+mkdir: %_DEST%\inc%_EXT%\com\sun
+mkdir: %_DEST%\inc%_EXT%\com\sun\star
+mkdir: %_DEST%\inc%_EXT%\com\sun\star\xml
+mkdir: %_DEST%\inc%_EXT%\com\sun\star\xml\sax
+
+..\%__SRC%\inc\com\sun\star\xml\*.hdl %_DEST%\inc%_EXT%\com\sun\star\xml\*.hdl
+..\%__SRC%\inc\com\sun\star\xml\*.hpp %_DEST%\inc%_EXT%\com\sun\star\xml\*.hpp
+..\%__SRC%\inc\com\sun\star\xml\sax\*.hdl %_DEST%\inc%_EXT%\com\sun\star\xml\sax\*.hdl
+..\%__SRC%\inc\com\sun\star\xml\sax\*.hpp %_DEST%\inc%_EXT%\com\sun\star\xml\sax\*.hpp
Index: unoxml/source/fastsax/fastattribs.cxx
===================================================================
RCS file: unoxml/source/fastsax/fastattribs.cxx
diff -N unoxml/source/fastsax/fastattribs.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/fastattribs.cxx	31 May 2007 10:16:34 -0000	1.1.2.1
@@ -0,0 +1,177 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include <algorithm>
+#include <boost/bind.hpp>
+
+#include "fastattribs.hxx"
+
+using ::rtl::OUString;
+using ::rtl::OString;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::xml;
+using namespace ::com::sun::star::xml::sax;
+namespace sax_fastparser
+{
+
+struct UnknownAttribute
+{
+	OUString maNamespaceURL;
+	OString maName;
+	OString maValue;
+
+	UnknownAttribute( const OUString& rNamespaceURL, const OString& rName, const OString& rValue )
+		: maNamespaceURL( rNamespaceURL ), maName( rName ), maValue( rValue ) {}
+
+	UnknownAttribute( const OString& rName, const OString& rValue )
+		: maName( rName ), maValue( rValue ) {}
+
+/*
+	UnknownAttribute( const UnknownAttribute& r )
+		: maNamespaceURL( r.maNamespaceURL ), maName( r.maName ), maValue( r.maValue ) {}
+
+	const UnknownAttribute& operator=( const UnknownAttribute& r )
+	{
+		maNamespaceURL = r.maNamespaceURL;
+		maName = r.maName;
+		maValue = r.maValue;
+		return *this;
+	}
+*/
+	void FillAttribute( Attribute* pAttrib ) const
+	{
+		if( pAttrib )
+		{
+			pAttrib->Name = OStringToOUString( maName, RTL_TEXTENCODING_UTF8 );
+			pAttrib->NamespaceURL = maNamespaceURL;
+			pAttrib->Value = OStringToOUString( maValue, RTL_TEXTENCODING_UTF8 );
+		}
+	}
+};
+
+FastAttributeList::FastAttributeList( const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastTokenHandler >& xTokenHandler )
+: mxTokenHandler( xTokenHandler )
+{
+	maLastIter = maAttributes.end();
+}
+
+FastAttributeList::~FastAttributeList()
+{
+}
+
+void FastAttributeList::clear()
+{
+	maAttributes.clear();
+	maUnknownAttributes.clear();
+	maLastIter = maAttributes.end();
+}
+
+void FastAttributeList::add( sal_Int32 nToken, const OString& rValue )
+{
+	maAttributes[nToken] = rValue;
+}
+
+void FastAttributeList::addUnknown( const OUString& rNamespaceURL, const OString& rName, const OString& rValue )
+{
+	maUnknownAttributes.push_back( UnknownAttribute( rNamespaceURL, rName, rValue ) );
+}
+
+void FastAttributeList::addUnknown( const OString& rName, const OString& rValue )
+{
+	maUnknownAttributes.push_back( UnknownAttribute( rName, rValue ) );
+}
+
+// XFastAttributeList
+sal_Bool FastAttributeList::hasAttribute( ::sal_Int32 Token ) throw (RuntimeException)
+{
+	maLastIter = maAttributes.find( Token );
+	return ( maLastIter != maAttributes.end() ) ? sal_True : sal_False;
+}
+
+sal_Int32 FastAttributeList::getValueToken( ::sal_Int32 Token ) throw (SAXException, RuntimeException)
+{
+	if( ( maLastIter == maAttributes.end() ) || ( ( *maLastIter ).first != Token ) )
+		maLastIter = maAttributes.find( Token );
+
+	if( maLastIter == maAttributes.end() )
+		throw SAXException();
+
+	Sequence< sal_Int8 > aSeq( (sal_Int8*)(*maLastIter).second.getStr(), (*maLastIter).second.getLength() ) ;
+	return mxTokenHandler->getTokenFromUTF8( aSeq );
+}
+
+sal_Int32 FastAttributeList::getOptionalValueToken( ::sal_Int32 Token, ::sal_Int32 Default ) throw (RuntimeException)
+{
+	if( ( maLastIter == maAttributes.end() ) || ( ( *maLastIter ).first != Token ) )
+		maLastIter = maAttributes.find( Token );
+
+	if( maLastIter == maAttributes.end() )
+		return Default;
+
+	Sequence< sal_Int8 > aSeq( (sal_Int8*)(*maLastIter).second.getStr(), (*maLastIter).second.getLength() ) ;
+	return mxTokenHandler->getTokenFromUTF8( aSeq );
+}
+
+OUString FastAttributeList::getValue( ::sal_Int32 Token ) throw (SAXException, RuntimeException)
+{
+	if( ( maLastIter == maAttributes.end() ) || ( ( *maLastIter ).first != Token ) )
+		maLastIter = maAttributes.find( Token );
+
+	if( maLastIter == maAttributes.end() )
+		throw SAXException();
+
+	return OStringToOUString( (*maLastIter).second, RTL_TEXTENCODING_UTF8 );
+}
+
+OUString FastAttributeList::getOptionalValue( ::sal_Int32 Token ) throw (RuntimeException)
+{
+	if( ( maLastIter == maAttributes.end() ) || ( ( *maLastIter ).first != Token ) )
+		maLastIter = maAttributes.find( Token );
+
+	OUString aRet;
+	if( maLastIter != maAttributes.end() )
+		aRet = OStringToOUString( (*maLastIter).second, RTL_TEXTENCODING_UTF8 );
+
+	return aRet;
+}
+Sequence< Attribute > FastAttributeList::getUnknownAttributes(  ) throw (RuntimeException)
+{
+	Sequence< Attribute > aSeq( maUnknownAttributes.size() );
+	Attribute* pAttr = aSeq.getArray();
+	std::for_each( maUnknownAttributes.begin(), maUnknownAttributes.end(), bind(&UnknownAttribute::FillAttribute, _1, pAttr++ ) );
+	return aSeq;
+}
+
+}
Index: unoxml/source/fastsax/fastattribs.hxx
===================================================================
RCS file: unoxml/source/fastsax/fastattribs.hxx
diff -N unoxml/source/fastsax/fastattribs.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/fastattribs.hxx	31 May 2007 10:16:43 -0000	1.1.2.1
@@ -0,0 +1,85 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _SAX_FASTATTRIBS_HXX_
+#define _SAX_FASTATTRIBS_HXX_
+
+#include <com/sun/star/xml/sax/XFastAttributeList.hpp>
+#include <com/sun/star/xml/sax/XFastTokenHandler.hpp>
+#include <com/sun/star/xml/Attribute.hpp>
+
+#include <cppuhelper/implbase1.hxx>
+
+#include <map>
+#include <vector>
+
+namespace sax_fastparser
+{
+
+struct UnknownAttribute;
+
+typedef std::map< sal_Int32, ::rtl::OString > FastAttributeMap;
+typedef std::vector< UnknownAttribute > UnknownAttributeList;
+
+class FastAttributeList : public ::cppu::WeakImplHelper1< ::com::sun::star::xml::sax::XFastAttributeList > 
+{
+public:
+	FastAttributeList( const ::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastTokenHandler >& xTokenHandler );
+	virtual ~FastAttributeList();
+
+	void clear();
+	void add( sal_Int32 nToken, const ::rtl::OString& rValue );
+	void addUnknown( const ::rtl::OUString& rNamespaceURL, const ::rtl::OString& rName, const ::rtl::OString& rValue );
+	void addUnknown( const ::rtl::OString& rName, const ::rtl::OString& rValue );
+
+    // XFastAttributeList
+    virtual ::sal_Bool SAL_CALL hasAttribute( ::sal_Int32 Token ) throw (::com::sun::star::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getValueToken( ::sal_Int32 Token ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
+    virtual ::sal_Int32 SAL_CALL getOptionalValueToken( ::sal_Int32 Token, ::sal_Int32 Default ) throw (::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getValue( ::sal_Int32 Token ) throw (::com::sun::star::xml::sax::SAXException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getOptionalValue( ::sal_Int32 Token ) throw (::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::xml::Attribute > SAL_CALL getUnknownAttributes(  ) throw (::com::sun::star::uno::RuntimeException);
+
+private:
+	FastAttributeMap maAttributes;
+	UnknownAttributeList maUnknownAttributes;
+	FastAttributeMap::iterator maLastIter;
+	::com::sun::star::uno::Reference< ::com::sun::star::xml::sax::XFastTokenHandler > mxTokenHandler;
+
+};
+
+}
+
+#endif
Index: unoxml/source/fastsax/fastparser.cxx
===================================================================
RCS file: unoxml/source/fastsax/fastparser.cxx
diff -N unoxml/source/fastsax/fastparser.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/fastparser.cxx	31 May 2007 10:16:52 -0000	1.1.2.1
@@ -0,0 +1,1079 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+//#include <stdlib.h>
+//#include <sal/alloca.h>
+
+#include <stack>
+#include <vector>
+#include <hash_map>
+#include <boost/scoped_ptr.hpp>
+#include <boost/shared_ptr.hpp>
+
+#include <osl/diagnose.h>
+#include <rtl/ref.hxx>
+
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/DisposedException.hpp>
+#include <com/sun/star/xml/sax/XFastDocumentHandler.hpp>
+#include <com/sun/star/xml/sax/XFastParser.hpp>
+#include <com/sun/star/xml/sax/XFastContextHandler.hpp>
+#include <com/sun/star/xml/sax/SAXParseException.hpp>
+#include <com/sun/star/xml/sax/FastToken.hpp>
+
+#include <cppuhelper/factory.hxx>
+#include <cppuhelper/weak.hxx>
+#include <cppuhelper/implbase2.hxx>
+
+#include "fastattribs.hxx"
+#include "xml2utf.hxx"
+
+#ifdef SYSTEM_EXPAT
+#include <expat.h>
+#else
+#include "expat/xmlparse.h"
+#endif
+
+using ::rtl::OUString;
+using ::rtl::OString;
+using namespace ::std;
+using namespace ::osl;
+using namespace ::cppu;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::lang;
+using namespace ::com::sun::star::registry;
+using namespace ::com::sun::star::xml::sax;
+//using namespace ::com::sun::star::util;
+using namespace ::com::sun::star::io;
+namespace sax_fastparser
+{
+	
+// --------------------------------------------------------------------
+
+struct SaxContextImpl;
+typedef boost::shared_ptr< SaxContextImpl > SaxContextImplPtr;
+
+// --------------------------------------------------------------------
+
+struct SaxContextImpl
+{
+	Reference< XFastContextHandler >	mxContext;
+	sal_uInt32		mnNamespaceCount;
+	sal_Int32		mnElementToken;
+	OUString		maNamespace;
+	OUString		maElementName;
+
+	SaxContextImpl() { mnNamespaceCount = 0; mnElementToken = 0; }
+	SaxContextImpl( const SaxContextImplPtr& p ) { mnNamespaceCount = p->mnNamespaceCount; mnElementToken = p->mnElementToken; maNamespace = p->maNamespace; }
+};
+
+// --------------------------------------------------------------------
+
+// Entity binds all information neede for a single file
+struct Entity
+{
+	InputSource			maStructSource;
+	XML_Parser			mpParser;	
+	sax_expatwrap::XMLFile2UTFConverter maConverter;
+};
+
+// --------------------------------------------------------------------
+
+struct NamespaceDefine
+{
+	OString		maPrefix;
+	sal_Int32	mnToken;
+	OUString	maNamespaceURL;
+
+	NamespaceDefine( const OString& rPrefix, sal_Int32 nToken, const OUString& rNamespaceURL ) : maPrefix( rPrefix ), mnToken( nToken ), maNamespaceURL( rNamespaceURL ) {}
+};
+
+typedef ::std::hash_map< ::rtl::OUString, sal_Int32,
+						 ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString >
+					   > NamespaceMap;
+
+// --------------------------------------------------------------------
+// FastLocatorImpl
+// --------------------------------------------------------------------
+
+class FastSaxParser;
+
+class FastLocatorImpl : public WeakImplHelper1< XLocator > 
+{
+public:
+	FastLocatorImpl( FastSaxParser *p ) : mpParser(p) {}
+	
+	void dispose() { mpParser = 0; }
+	void checkDispose() throw (RuntimeException) { if( !mpParser ) throw DisposedException(); }
+
+	//XLocator
+    virtual sal_Int32 SAL_CALL getColumnNumber(void) throw (RuntimeException);
+	virtual sal_Int32 SAL_CALL getLineNumber(void) throw (RuntimeException);
+    virtual OUString SAL_CALL getPublicId(void) throw (RuntimeException);
+    virtual OUString SAL_CALL getSystemId(void) throw (RuntimeException);
+
+private:
+	FastSaxParser *mpParser;
+};		
+
+// --------------------------------------------------------------------
+// FastSaxParser
+// --------------------------------------------------------------------
+
+#define IMPLEMENTATION_NAME	"com.sun.star.comp.extensions.xml.sax.FastParser"
+#define SERVICE_NAME		"com.sun.star.xml.sax.FastParser"
+
+
+// This class implements the external Parser interface
+class FastSaxParser : public WeakImplHelper2< XFastParser, XServiceInfo >
+{
+public:	
+	FastSaxParser();
+	~FastSaxParser();
+
+	// The implementation details
+    static Sequence< OUString > 	getSupportedServiceNames_Static(void);
+	static OUString 				getImplementationName_Static();
+
+	// XFastParser
+    virtual void SAL_CALL parseStream( const InputSource& aInputSource ) throw (SAXException, IOException, RuntimeException);
+    virtual void SAL_CALL setFastDocumentHandler( const Reference< XFastDocumentHandler >& Handler ) throw (RuntimeException);
+    virtual void SAL_CALL setTokenHandler( const Reference< XFastTokenHandler >& Handler ) throw (RuntimeException);
+    virtual void SAL_CALL registerNamespace( const OUString& NamespaceURL, sal_Int32 NamespaceToken ) throw (IllegalArgumentException, RuntimeException);
+    virtual void SAL_CALL setErrorHandler( const Reference< XErrorHandler >& Handler ) throw (RuntimeException);
+    virtual void SAL_CALL setEntityResolver( const Reference< XEntityResolver >& Resolver ) throw (RuntimeException);
+    virtual void SAL_CALL setLocale( const Locale& Locale ) throw (RuntimeException);
+
+	// XServiceInfo
+    virtual OUString SAL_CALL getImplementationName(  ) throw (RuntimeException);
+    virtual sal_Bool SAL_CALL supportsService( const OUString& ServiceName ) throw (RuntimeException);
+    virtual Sequence< OUString > SAL_CALL getSupportedServiceNames(  ) throw (RuntimeException);
+
+public:	
+	// the C-Callbacks for the expat parser
+	void static callbackStartElement(void *userData, const XML_Char *name , const XML_Char **atts);
+	void static callbackEndElement(void *userData, const XML_Char *name);
+	void static callbackCharacters( void *userData , const XML_Char *s , int nLen );
+	int static callbackExternalEntityRef( XML_Parser parser, const XML_Char *openEntityNames, const XML_Char *base, const XML_Char *systemId, const XML_Char *publicId);
+
+public:
+	void pushEntity( const struct Entity &entity )	{ vecEntity.push_back( entity ); }
+	void popEntity()								{ vecEntity.pop_back( ); }
+	struct Entity &getEntity()						{ return vecEntity.back(); }
+
+private:
+	void parse();
+
+	sal_Int32 GetToken( const sal_Char* pToken, sal_Int32 nTokenLen = 0 );
+	sal_Int32 GetTokenWithPrefix( const sal_Char*pPrefix, int nPrefixLen, const sal_Char* pName, int nNameLen ) throw (SAXException);
+	OUString  GetNamespaceURL( const sal_Char*pPrefix, int nPrefixLen ) throw (SAXException);
+	sal_Int32 GetNamespaceToken( const OUString& rNamespaceURL );
+	sal_Int32 GetTokenWithNamespaceURL( const OUString& rNamespaceURL, const sal_Char* pName, int nNameLen );
+	void DefineNamespace( const OString& rPrefix, const sal_Char* pNamespaceURL );
+	sal_Int32 CreateCustomToken( const sal_Char* pToken, int len = 0 );
+
+	void pushContext();
+	void popContext();
+
+	void splitName( const XML_Char *pwName, const XML_Char *&rpPrefix, sal_Int32 &rPrefixLen, const XML_Char *&rpName, sal_Int32 &rNameLen );
+
+private:
+	Mutex				maMutex;
+
+	Reference< XFastDocumentHandler >		mxDocumentHandler;
+	Reference< XFastTokenHandler >			mxTokenHandler;
+	Reference< XErrorHandler >				mxErrorHandler;
+	Reference< XEntityResolver >			mxEntityResolver;
+	rtl::Reference < FastLocatorImpl >		mxDocumentLocator;
+
+	rtl::Reference < FastAttributeList >	mxAttributes;
+
+	// External entity stack 
+	vector<struct Entity> 	vecEntity;
+
+	// Exception cannot be thrown through the C-XmlParser (possible resource leaks), 
+	// therefor the maSavedException must be saved somewhere.
+	Any				 	maSavedException;
+	sal_Bool 			mbExceptionWasThrown;
+
+	Locale				maLocale;
+
+	std::stack< SaxContextImplPtr >	maContextStack;
+	std::vector< boost::shared_ptr< NamespaceDefine > >	maNamespaceDefines;
+	NamespaceMap maNamespaceMap;
+};
+
+//--------------------------------------
+// the extern interface 
+//---------------------------------------
+Reference< XInterface > SAL_CALL FastSaxParser_CreateInstance( const Reference< XMultiServiceFactory  >  & ) throw(Exception)
+{	
+	FastSaxParser *p = new FastSaxParser;
+	return Reference< XInterface > ( (OWeakObject * ) p );
+}
+
+Sequence< OUString > FastSaxParser_getSupportedServiceNames()
+{
+	Sequence<OUString> aRet(1);
+	aRet.getArray()[0] = ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(SERVICE_NAME) );
+	return aRet;
+}
+
+OUString FastSaxParser_getImplementationName()
+{
+	return ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( IMPLEMENTATION_NAME ) );
+}
+
+Sequence< OUString > FastSaxParser::getSupportedServiceNames_Static(void)
+{
+	return FastSaxParser_getSupportedServiceNames();
+}
+
+
+//---------------------------------------------
+// the implementation part
+//---------------------------------------------
+
+extern "C"
+{
+    static void call_callbackStartElement(void *userData, const XML_Char *name , const XML_Char **atts)
+    {
+        FastSaxParser::callbackStartElement(userData,name,atts);
+    }
+	static void call_callbackEndElement(void *userData, const XML_Char *name)
+    {
+        FastSaxParser::callbackEndElement(userData,name);
+    }
+	static void call_callbackCharacters( void *userData , const XML_Char *s , int nLen )
+    {
+        FastSaxParser::callbackCharacters(userData,s,nLen);
+    }
+	static int call_callbackExternalEntityRef(XML_Parser parser,
+					    					  const XML_Char *openEntityNames,
+                                              const XML_Char *base,
+                                              const XML_Char *systemId,
+                                              const XML_Char *publicId)
+    {
+        return FastSaxParser::callbackExternalEntityRef(parser,openEntityNames,base,systemId,publicId);
+    }
+}
+
+// --------------------------------------------------------------------
+// FastLocatorImpl implementation
+// --------------------------------------------------------------------
+
+sal_Int32 SAL_CALL FastLocatorImpl::getColumnNumber(void) throw (RuntimeException)
+{
+	checkDispose();
+	return XML_GetCurrentColumnNumber( mpParser->getEntity().mpParser );
+}
+
+// --------------------------------------------------------------------
+
+sal_Int32 SAL_CALL FastLocatorImpl::getLineNumber(void) throw (RuntimeException)
+{
+	checkDispose();
+	return XML_GetCurrentLineNumber( mpParser->getEntity().mpParser );
+}
+
+// --------------------------------------------------------------------
+
+OUString SAL_CALL FastLocatorImpl::getPublicId(void) throw (RuntimeException)
+{
+	checkDispose();
+	return mpParser->getEntity().maStructSource.sPublicId;
+}
+// --------------------------------------------------------------------
+
+OUString SAL_CALL FastLocatorImpl::getSystemId(void) throw (RuntimeException)
+{
+	checkDispose();
+	return mpParser->getEntity().maStructSource.sSystemId;
+}
+
+// --------------------------------------------------------------------
+// FastSaxParser implementation
+// --------------------------------------------------------------------
+
+FastSaxParser::FastSaxParser(  )
+{
+	mxDocumentLocator.set( new FastLocatorImpl( this ) );
+	 
+	// performance-Improvment. Reference is needed when calling the startTag callback.
+	// Handing out the same object with every call is allowed (see sax-specification)
+	mxAttributes.set( new FastAttributeList( mxTokenHandler ) );
+	
+	mbExceptionWasThrown = sal_False;
+}
+
+// --------------------------------------------------------------------
+
+FastSaxParser::~FastSaxParser()
+{
+	if( mxDocumentLocator.is() )
+		mxDocumentLocator->dispose();
+}
+
+// --------------------------------------------------------------------
+
+void FastSaxParser::pushContext()
+{
+	bool bRootContext = false;
+	SaxContextImplPtr p;
+	if( maContextStack.empty() )
+	{
+		p.reset( new SaxContextImpl() );
+		bRootContext = true;
+	}
+	else
+	{ 
+		p.reset( new SaxContextImpl( maContextStack.top() ) );
+	}
+	maContextStack.push( p );
+
+	if( bRootContext )
+		DefineNamespace( OString("xml"), "http://www.w3.org/XML/1998/namespace");
+}
+
+// --------------------------------------------------------------------
+
+void FastSaxParser::popContext()
+{
+	OSL_ENSURE( !maContextStack.empty(), "sax::FastSaxParser::popContext(), pop without push?" );
+	if( !maContextStack.empty() )
+		maContextStack.pop();
+}
+
+// --------------------------------------------------------------------
+
+void FastSaxParser::DefineNamespace( const OString& rPrefix, const sal_Char* pNamespaceURL )
+{
+	OSL_ENSURE( !maContextStack.empty(), "sax::FastSaxParser::DefineNamespace(), I need a context!" );
+	if( !maContextStack.empty() )
+	{
+		sal_uInt32 nOffset = maContextStack.top()->mnNamespaceCount++;
+
+		if( maNamespaceDefines.size() <= nOffset )
+			maNamespaceDefines.resize( maNamespaceDefines.size() + 64 );
+
+		const OUString aNamespaceURL( pNamespaceURL, strlen( pNamespaceURL ), RTL_TEXTENCODING_UTF8 );
+		maNamespaceDefines[nOffset].reset( new NamespaceDefine( rPrefix, GetNamespaceToken( aNamespaceURL ), aNamespaceURL ) );
+	}
+}
+
+// --------------------------------------------------------------------
+
+sal_Int32 FastSaxParser::GetToken( const sal_Char* pToken, sal_Int32 nLen /* = 0 */ )
+{
+	if( !nLen )
+		nLen = strlen( pToken );
+
+	Sequence< sal_Int8 > aSeq( (sal_Int8*)pToken, nLen );
+
+	return mxTokenHandler->getTokenFromUTF8( aSeq );
+}
+
+// --------------------------------------------------------------------
+
+sal_Int32 FastSaxParser::GetTokenWithPrefix( const sal_Char*pPrefix, int nPrefixLen, const sal_Char* pName, int nNameLen ) throw (SAXException)
+{
+	sal_Int32 nNamespaceToken = FastToken::DONTKNOW;
+
+	sal_uInt32 nNamespace = maContextStack.top()->mnNamespaceCount;
+	while( nNamespace-- )
+	{
+		const OString& rPrefix( maNamespaceDefines[nNamespace]->maPrefix );
+		if( (rPrefix.getLength() == nPrefixLen) &&
+			(strncmp( rPrefix.getStr(), pPrefix, nPrefixLen ) == 0 ) )
+		{
+			nNamespaceToken = maNamespaceDefines[nNamespace]->mnToken;
+			break;
+		}
+
+		if( !nNamespace )
+			throw SAXException(); // prefix that has no defined namespace url
+	}
+
+	if( nNamespaceToken != FastToken::DONTKNOW )
+	{
+		sal_Int32 nNameToken = GetToken( pName, nNameLen );
+		if( nNameToken != FastToken::DONTKNOW )
+			return nNamespaceToken | nNameToken;
+	}
+
+	return FastToken::DONTKNOW;
+}
+
+// --------------------------------------------------------------------
+
+sal_Int32 FastSaxParser::GetNamespaceToken( const OUString& rNamespaceURL )
+{
+	NamespaceMap::iterator aIter( maNamespaceMap.find( rNamespaceURL ) );
+	if( aIter != maNamespaceMap.end() )
+		return (*aIter).second;
+	else
+		return FastToken::DONTKNOW;
+}
+
+// --------------------------------------------------------------------
+
+OUString FastSaxParser::GetNamespaceURL( const sal_Char*pPrefix, int nPrefixLen ) throw(SAXException)
+{
+	if( pPrefix && !maContextStack.empty() )
+	{
+		sal_uInt32 nNamespace = maContextStack.top()->mnNamespaceCount;
+		while( nNamespace-- )
+		{
+			const OString& rPrefix( maNamespaceDefines[nNamespace]->maPrefix );
+			if( (rPrefix.getLength() == nPrefixLen) &&
+				(strncmp( rPrefix.getStr(), pPrefix, nPrefixLen ) == 0 ) )
+			{
+				return maNamespaceDefines[nNamespace]->maNamespaceURL;
+			}
+		}
+	}
+
+	throw SAXException(); // prefix that has no defined namespace url
+}
+
+// --------------------------------------------------------------------
+
+sal_Int32 FastSaxParser::GetTokenWithNamespaceURL( const OUString& rNamespaceURL, const sal_Char* pName, int nNameLen )
+{
+	sal_Int32 nNamespaceToken = GetNamespaceToken( rNamespaceURL );
+
+	if( nNamespaceToken != FastToken::DONTKNOW )
+	{
+		sal_Int32 nNameToken = GetToken( pName, nNameLen );
+		if( nNameToken != FastToken::DONTKNOW )
+			return nNamespaceToken | nNameToken;
+	}
+
+	return FastToken::DONTKNOW;
+}
+
+// --------------------------------------------------------------------
+
+void FastSaxParser::splitName( const XML_Char *pwName, const XML_Char *&rpPrefix, sal_Int32 &rPrefixLen, const XML_Char *&rpName, sal_Int32 &rNameLen )
+{
+	XML_Char *p;
+	for( p = const_cast< XML_Char* >( pwName ), rNameLen = 0, rPrefixLen = 0; *p; p++ )
+	{
+		if( *p == ':' )
+		{
+			rPrefixLen = p - pwName;
+			rNameLen = 0;
+		}
+		else
+		{
+			rNameLen++;
+		}
+	}
+	if( rPrefixLen )
+	{
+		rpPrefix = pwName;
+		rpName = &pwName[ rPrefixLen + 1 ];
+	}
+	else
+	{
+		rpPrefix = 0;
+		rpName = pwName;
+	}
+}
+
+/***************
+*
+* parseStream does Parser-startup initializations. The FastSaxParser::parse() method does
+* the file-specific initialization work. (During a parser run, external files may be opened)
+* 
+****************/
+void FastSaxParser::parseStream( const InputSource& maStructSource)	throw (SAXException, IOException, RuntimeException)
+{
+	// Only one text at one time
+	MutexGuard guard( maMutex );
+	
+	struct Entity entity;
+	entity.maStructSource = maStructSource;
+
+	if( ! entity.maStructSource.aInputStream.is() )
+	{
+		throw SAXException( OUString::createFromAscii( "No input source" ), Reference< XInterface > () , Any() );
+	}
+
+	entity.maConverter.setInputStream( entity.maStructSource.aInputStream );
+	if( entity.maStructSource.sEncoding.getLength() )
+	{
+		entity.maConverter.setEncoding(	OUStringToOString( entity.maStructSource.sEncoding , RTL_TEXTENCODING_ASCII_US ) );	
+	}
+	
+	// create parser with proper encoding
+	entity.mpParser = XML_ParserCreate( 0 );
+	if( ! entity.mpParser )
+	{
+		throw SAXException( OUString::createFromAscii( "Couldn't create parser" ), Reference< XInterface > (), Any() );
+	}
+
+	// set all necessary C-Callbacks 
+	XML_SetUserData( entity.mpParser , this );
+	XML_SetElementHandler( 	entity.mpParser , 
+							call_callbackStartElement , 
+							call_callbackEndElement );
+	XML_SetCharacterDataHandler( entity.mpParser , call_callbackCharacters );
+	XML_SetExternalEntityRefHandler( 	entity.mpParser, 
+										call_callbackExternalEntityRef);	
+
+	maSavedException.clear();
+	pushEntity( entity );
+	try
+	{
+		// start the document
+		if( mxDocumentHandler.is() )
+		{
+			Reference< XLocator > xLoc( mxDocumentLocator.get() );
+			mxDocumentHandler->setDocumentLocator( xLoc );
+			mxDocumentHandler->startDocument();
+		}
+
+		parse();
+
+		// finish document
+		if( mxDocumentHandler.is() )
+		{
+			mxDocumentHandler->endDocument();	
+		}
+	}
+	catch( SAXException & )
+	{
+		popEntity();
+		XML_ParserFree( entity.mpParser );
+  		throw;
+	}
+	catch( IOException & )
+	{
+		popEntity();
+		XML_ParserFree( entity.mpParser );
+		throw;
+	}
+	catch( RuntimeException & )
+	{
+		popEntity();
+		XML_ParserFree( entity.mpParser );
+		throw;
+	}
+
+	popEntity();
+	XML_ParserFree( entity.mpParser );
+}
+    																			
+void FastSaxParser::setFastDocumentHandler( const Reference< XFastDocumentHandler >& Handler ) throw (RuntimeException)
+{
+	mxDocumentHandler = Handler;
+}
+
+void SAL_CALL FastSaxParser::setTokenHandler( const Reference< XFastTokenHandler >& Handler ) throw (RuntimeException)
+{
+	mxTokenHandler = Handler;
+	mxAttributes.set( new FastAttributeList( mxTokenHandler ) );
+}
+
+void SAL_CALL FastSaxParser::registerNamespace( const OUString& NamespaceURL, sal_Int32 NamespaceToken ) throw (IllegalArgumentException, RuntimeException)
+{
+	if( NamespaceToken >= FastToken::NAMESPACE )
+	{
+		if( GetNamespaceToken( NamespaceURL ) == FastToken::DONTKNOW )
+		{
+			maNamespaceMap[ NamespaceURL ] = NamespaceToken;
+			return;
+		}
+	}
+	throw IllegalArgumentException();
+}
+
+void FastSaxParser::setErrorHandler(const Reference< XErrorHandler > & Handler) throw (RuntimeException)
+{
+	mxErrorHandler = Handler;
+}
+
+void FastSaxParser::setEntityResolver(const Reference < XEntityResolver > & Resolver) throw (RuntimeException)
+{
+	mxEntityResolver = Resolver;
+}
+
+void FastSaxParser::setLocale( const Locale & Locale ) throw (RuntimeException)
+{
+	maLocale = Locale;	
+}
+
+OUString FastSaxParser::getImplementationName_Static()
+{
+	return OUString::createFromAscii( IMPLEMENTATION_NAME );
+}
+
+// XServiceInfo
+OUString FastSaxParser::getImplementationName() throw (RuntimeException)
+{
+    return OUString::createFromAscii( IMPLEMENTATION_NAME );
+}
+
+// XServiceInfo
+sal_Bool FastSaxParser::supportsService(const OUString& ServiceName) throw (RuntimeException)
+{
+    Sequence< OUString > aSNL = getSupportedServiceNames();
+    const OUString * pArray = aSNL.getConstArray();
+
+    for( sal_Int32 i = 0; i < aSNL.getLength(); i++ )
+        if( pArray[i] == ServiceName )
+            return sal_True;
+
+    return sal_False;
+}
+
+// XServiceInfo
+Sequence< OUString > FastSaxParser::getSupportedServiceNames(void) throw (RuntimeException)
+{
+    
+    Sequence<OUString> seq(1);
+    seq.getArray()[0] = OUString::createFromAscii( SERVICE_NAME );
+    return seq;
+}
+
+
+/*---------------------------------------
+*
+* Helper functions and classes
+*
+*-------------------------------------------*/
+OUString getErrorMessage( XML_Error xmlE, OUString sSystemId , sal_Int32 nLine )
+{
+	OUString Message;
+	if( XML_ERROR_NONE == xmlE ) {
+		Message = OUString::createFromAscii( "No" );
+	}
+	else if( XML_ERROR_NO_MEMORY == xmlE ) {
+		Message = OUString::createFromAscii( "no memory" );
+	}
+	else if( XML_ERROR_SYNTAX == xmlE ) {
+		Message = OUString::createFromAscii( "syntax" );
+	}
+	else if( XML_ERROR_NO_ELEMENTS == xmlE ) {
+		Message = OUString::createFromAscii( "no elements" );
+	}
+	else if( XML_ERROR_INVALID_TOKEN == xmlE ) {
+		Message = OUString::createFromAscii( "invalid token" );
+	}
+	else if( XML_ERROR_UNCLOSED_TOKEN == xmlE ) {
+		Message = OUString::createFromAscii( "unclosed token" );
+	}
+	else if( XML_ERROR_PARTIAL_CHAR == xmlE ) {
+		Message = OUString::createFromAscii( "partial char" );
+	}
+	else if( XML_ERROR_TAG_MISMATCH == xmlE ) {
+		Message = OUString::createFromAscii( "tag mismatch" );
+	}
+	else if( XML_ERROR_DUPLICATE_ATTRIBUTE == xmlE ) {
+		Message = OUString::createFromAscii( "duplicate attribute" );
+	}
+	else if( XML_ERROR_JUNK_AFTER_DOC_ELEMENT == xmlE ) {
+		Message = OUString::createFromAscii( "junk after doc element" );
+	}
+	else if( XML_ERROR_PARAM_ENTITY_REF == xmlE ) {
+		Message = OUString::createFromAscii( "parameter entity reference" );
+	}
+	else if( XML_ERROR_UNDEFINED_ENTITY == xmlE ) {
+		Message = OUString::createFromAscii( "undefined entity" );
+	}
+	else if( XML_ERROR_RECURSIVE_ENTITY_REF == xmlE ) {
+		Message = OUString::createFromAscii( "recursive entity reference" );
+	}
+	else if( XML_ERROR_ASYNC_ENTITY == xmlE ) {
+		Message = OUString::createFromAscii( "async entity" );
+	}
+	else if( XML_ERROR_BAD_CHAR_REF == xmlE ) {
+		Message = OUString::createFromAscii( "bad char reference" );
+	}
+	else if( XML_ERROR_BINARY_ENTITY_REF == xmlE ) {
+		Message = OUString::createFromAscii( "binary entity reference" );
+	}
+	else if( XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF == xmlE ) {
+		Message = OUString::createFromAscii( "attribute external entity reference" );
+	}
+	else if( XML_ERROR_MISPLACED_XML_PI == xmlE ) {
+		Message = OUString::createFromAscii( "misplaced xml processing instruction" );
+	}
+	else if( XML_ERROR_UNKNOWN_ENCODING == xmlE ) {
+		Message = OUString::createFromAscii( "unknown encoding" );
+	}
+	else if( XML_ERROR_INCORRECT_ENCODING == xmlE ) {
+		Message = OUString::createFromAscii( "incorrect encoding" );
+	}
+	else if( XML_ERROR_UNCLOSED_CDATA_SECTION == xmlE ) {
+		Message = OUString::createFromAscii( "unclosed cdata section" );
+	}
+	else if( XML_ERROR_EXTERNAL_ENTITY_HANDLING == xmlE ) {
+		Message = OUString::createFromAscii( "external entity reference" );
+	}
+	else if( XML_ERROR_NOT_STANDALONE == xmlE ) {
+		Message = OUString::createFromAscii( "not standalone" );	
+	}
+
+	OUString str = OUString::createFromAscii( "[" );
+	str += sSystemId;
+	str += OUString::createFromAscii( " line " );
+	str += OUString::valueOf( nLine );
+	str += OUString::createFromAscii( "]: " );
+	str += Message;
+	str += OUString::createFromAscii( "error" );
+
+	return str;
+}
+
+
+// starts parsing with actual parser !
+void FastSaxParser::parse( )
+{
+	const int nBufSize = 16*1024;
+
+	int nRead = nBufSize;
+	Sequence< sal_Int8 > seqOut(nBufSize);
+
+	while( nRead )
+	{
+		nRead = getEntity().maConverter.readAndConvert( seqOut, nBufSize );
+
+		if( ! nRead )
+		{				
+			XML_Parse( getEntity().mpParser, ( const char * ) seqOut.getArray(), 0 , 1 );	
+			break;
+		}		
+
+		sal_Bool bContinue = ( XML_Parse( getEntity().mpParser, (const char *) seqOut.getArray(), nRead, 0 ) != 0 );
+		
+		if( !bContinue || mbExceptionWasThrown )
+		{
+			// Error during parsing !
+			XML_Error xmlE = XML_GetErrorCode( getEntity().mpParser );
+			OUString sSystemId = mxDocumentLocator->getSystemId();
+			sal_Int32 nLine = mxDocumentLocator->getLineNumber();
+
+			SAXParseException aExcept( 	
+				getErrorMessage(xmlE , sSystemId, nLine) , 
+				Reference< XInterface >(), 
+				Any( &maSavedException , getCppuType( &maSavedException) ),
+				mxDocumentLocator->getPublicId(),
+				mxDocumentLocator->getSystemId(),
+				mxDocumentLocator->getLineNumber(),
+				mxDocumentLocator->getColumnNumber()
+				);
+			
+			if( mxErrorHandler.is() )
+			{
+				// error handler is set, so the handler may throw the maSavedException
+				mxErrorHandler->fatalError( Any( aExcept ) );
+			}
+
+			// Error handler has not thrown an maSavedException, but parsing cannot go on,
+			// so an maSavedException MUST be thrown.
+			throw aExcept;
+		}
+	}
+}
+
+//------------------------------------------
+//
+// The C-Callbacks
+//
+//-----------------------------------------
+void FastSaxParser::callbackStartElement( void *pvThis, const XML_Char *pwName, const XML_Char **awAttributes )
+{
+ 	FastSaxParser *pThis = (FastSaxParser*)pvThis;
+
+	Reference< XFastContextHandler > xParentContext;
+	if( !pThis->maContextStack.empty() )
+	{
+		xParentContext = pThis->maContextStack.top()->mxContext;
+		if( !xParentContext.is() )
+		{
+			// we ignore current elements, so no processing needed
+			pThis->pushContext();
+			return;
+		}
+	}
+
+	pThis->pushContext();
+
+	pThis->mxAttributes->clear();
+
+	// create attribute map and process namespace instructions
+	int i = 0;
+	sal_Int32 nNameLen, nPrefixLen;
+	const XML_Char *pName;
+	const XML_Char *pPrefix;
+	for( ; awAttributes[i]; i += 2 )
+	{
+		OSL_ASSERT( awAttributes[i+1] );
+
+		pThis->splitName( awAttributes[i], pPrefix, nPrefixLen, pName, nNameLen );
+		if( nPrefixLen )
+		{
+			if( (nPrefixLen == 5) && (strncmp( pPrefix, "xmlns", 5 ) == 0) )
+			{
+				pThis->DefineNamespace( OString( pName, nNameLen ), awAttributes[i+1] );
+			}
+			else
+			{
+				const sal_Int32 nAttributeToken = pThis->GetTokenWithPrefix( pPrefix, nPrefixLen, pName, nNameLen );
+				if( nAttributeToken != FastToken::DONTKNOW )
+				{
+					pThis->mxAttributes->add( nAttributeToken, OString( awAttributes[i+1] ) );
+				}
+				else
+				{
+					pThis->mxAttributes->addUnknown( pThis->GetNamespaceURL( pPrefix, nPrefixLen ), OString( pName, nNameLen ), OString( awAttributes[i+1] ) );
+				}
+			}
+		}
+		else
+		{
+			if( (nNameLen == 5) && (strcmp( pName, "xmlns" ) == 0) )
+			{
+				// namespace of the element found
+				pThis->maContextStack.top()->maNamespace = OUString( awAttributes[i+1], strlen( awAttributes[i+1] ), RTL_TEXTENCODING_UTF8 );
+			}
+			else
+			{
+				const sal_Int32 nAttributeToken = pThis->GetToken( pName, nNameLen );
+				if( nAttributeToken != FastToken::DONTKNOW )
+				{
+					pThis->mxAttributes->add( nAttributeToken, OString( awAttributes[i+1] ) );
+				}
+				else
+				{
+					pThis->mxAttributes->addUnknown( OString( pName, nNameLen ), OString( awAttributes[i+1] ) );
+				}
+			}
+		}
+	}
+
+	sal_Int32 nElementToken;
+	pThis->splitName( pwName, pPrefix, nPrefixLen, pName, nNameLen );
+	if( nPrefixLen )
+	{
+		nElementToken = pThis->GetTokenWithPrefix( pPrefix, nPrefixLen, pName, nNameLen );
+	}
+	else if( pThis->maContextStack.top()->maNamespace.getLength() )
+	{
+		nElementToken = pThis->GetTokenWithNamespaceURL( pThis->maContextStack.top()->maNamespace, pName, nNameLen );
+	}
+	else
+	{
+		nElementToken = pThis->GetToken( pName );
+	}
+	pThis->maContextStack.top()->mnElementToken = nElementToken;
+	
+	try
+	{
+		Reference< XFastAttributeList > xAttr( pThis->mxAttributes.get() );
+		Reference< XFastContextHandler > xContext;
+		if( nElementToken == FastToken::DONTKNOW )
+		{
+			if( nPrefixLen )
+			{
+				pThis->maContextStack.top()->maNamespace = pThis->GetNamespaceURL( pPrefix, nPrefixLen );
+			}
+
+			const OUString aNamespace( pThis->maContextStack.top()->maNamespace );
+			const OUString aElementName( pPrefix, nPrefixLen, RTL_TEXTENCODING_UTF8 );
+			pThis->maContextStack.top()->maElementName = aElementName;
+
+			if( xParentContext.is() )
+				xContext = xParentContext->createUnknownChildContext( aNamespace, aElementName, xAttr );
+			else
+				xContext = pThis->mxDocumentHandler->createUnknownChildContext( aNamespace, aElementName, xAttr );
+
+			if( xContext.is() )
+			{
+				pThis->maContextStack.top()->mxContext = xContext;
+				xContext->startUnknownElement( aNamespace, aElementName, xAttr );
+			}
+		}
+		else
+		{
+			if( xParentContext.is() )
+				xContext = xParentContext->createFastChildContext( nElementToken, xAttr );
+			else
+				xContext = pThis->mxDocumentHandler->createFastChildContext( nElementToken, xAttr );
+
+
+			if( xContext.is() )
+			{
+				pThis->maContextStack.top()->mxContext = xContext;
+				xContext->startFastElement( nElementToken, xAttr );
+			}
+		}
+	}
+	catch( Exception& e )
+	{
+		pThis->maSavedException <<= e;
+	}
+}
+
+void FastSaxParser::callbackEndElement( void *pvThis , const XML_Char *  )
+{
+	FastSaxParser *pThis = (FastSaxParser*)pvThis;
+
+	if( !pThis->maContextStack.empty() )
+	{
+		SaxContextImplPtr pContext( pThis->maContextStack.top() );
+		const Reference< XFastContextHandler >& xContext( pContext->mxContext );
+		if( xContext.is() ) try
+		{
+			sal_Int32 nElementToken = pContext->mnElementToken;
+			if( nElementToken != FastToken::DONTKNOW )
+			{
+				xContext->endFastElement( nElementToken );
+			}
+			else
+			{
+				xContext->endUnknownElement( pContext->maNamespace, pContext->maElementName );
+			}
+		}
+		catch( Exception& e )
+		{
+			pThis->maSavedException <<= e;
+		}
+
+		pThis->popContext();
+	}
+	else
+	{
+		OSL_ENSURE( false, "no context on sax::FastSaxParser::callbackEndElement() ??? ");
+	}
+}
+
+
+void FastSaxParser::callbackCharacters( void *pvThis , const XML_Char *s , int nLen )
+{
+	FastSaxParser *pThis = (FastSaxParser*)pvThis;
+
+	const Reference< XFastContextHandler >& xContext( pThis->maContextStack.top()->mxContext );
+	if( xContext.is() ) try
+	{
+		xContext->characters( OUString( s, nLen, RTL_TEXTENCODING_UTF8 ) );
+	}
+	catch( Exception& e )
+	{
+		pThis->maSavedException <<= e;
+	}
+}		      					
+
+int FastSaxParser::callbackExternalEntityRef( XML_Parser parser,
+                                                    const XML_Char *context,
+                                                    const XML_Char * /*base*/,
+                                                    const XML_Char *systemId,
+                                                    const XML_Char *publicId)
+{
+	bool bOK = true;
+	InputSource source;
+	FastSaxParser *pImpl = ((FastSaxParser*)XML_GetUserData( parser ));
+
+	struct Entity entity;
+	
+	if( pImpl->mxEntityResolver.is() ) {
+		try
+		{
+	    	entity.maStructSource = pImpl->mxEntityResolver->resolveEntity(
+				OUString( publicId, strlen( publicId ), RTL_TEXTENCODING_UTF8 ) ,
+				OUString( systemId, strlen( systemId ), RTL_TEXTENCODING_UTF8 ) );
+	    }
+	    catch( SAXParseException & e )
+		{
+	    	pImpl->maSavedException <<= e;
+	    	bOK = false;
+	    }
+	    catch( SAXException & e )
+		{
+	    	pImpl->maSavedException <<= SAXParseException(
+				e.Message , e.Context , e.WrappedException ,
+				pImpl->mxDocumentLocator->getPublicId(),
+				pImpl->mxDocumentLocator->getSystemId(),
+				pImpl->mxDocumentLocator->getLineNumber(),
+				pImpl->mxDocumentLocator->getColumnNumber() );
+			bOK = false;
+	    }
+	}
+
+	if( entity.maStructSource.aInputStream.is() )
+	{
+		entity.mpParser = XML_ExternalEntityParserCreate( parser , context, 0 );
+		if( ! entity.mpParser )
+		{
+			return false;
+		}
+
+		entity.maConverter.setInputStream( entity.maStructSource.aInputStream );
+		pImpl->pushEntity( entity );
+		try
+		{
+			pImpl->parse();
+		}
+		catch( SAXParseException & e )
+		{
+			pImpl->maSavedException <<= e;
+			bOK = false;
+		}
+		catch( IOException &e )
+		{
+			SAXException aEx;
+			aEx.WrappedException <<= e;
+			pImpl->maSavedException <<= aEx;
+			bOK = false;
+		}
+		catch( RuntimeException &e )
+		{
+			SAXException aEx;
+			aEx.WrappedException <<= e;
+			pImpl->maSavedException <<= aEx;
+			bOK = false;
+		}
+
+		pImpl->popEntity();
+		
+		XML_ParserFree( entity.mpParser );
+	}
+
+	return bOK;
+}
+
+}
Index: unoxml/source/fastsax/makefile.mk
===================================================================
RCS file: unoxml/source/fastsax/makefile.mk
diff -N unoxml/source/fastsax/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/makefile.mk	31 May 2007 10:17:01 -0000	1.1.2.1
@@ -0,0 +1,66 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+PRJ=..$/..
+
+PRJNAME=unoxml
+TARGET=fastsax
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+DLLPRE =
+
+.IF "$(SYSTEM_ZLIB)" == "YES"
+CFLAGS+=-DSYSTEM_ZLIB
+.ENDIF
+
+.IF "$(SYSTEM_EXPAT)" == "YES"
+CFLAGS+=-DSYSTEM_EXPAT
+.ENDIF
+
+#-----------------------------------------------------------
+
+SLOFILES =\
+		$(SLO)$/fastparser.obj\
+		$(SLO)$/fastattribs.obj\
+		$(SLO)$/xml2utf.obj
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :	target.mk
+
+
+
Index: unoxml/source/fastsax/xml2utf.cxx
===================================================================
RCS file: unoxml/source/fastsax/xml2utf.cxx
diff -N unoxml/source/fastsax/xml2utf.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/xml2utf.cxx	31 May 2007 10:17:10 -0000	1.1.2.1
@@ -0,0 +1,597 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#include <string.h>
+
+#include <sal/types.h>
+
+#include <rtl/textenc.h>
+#include <rtl/tencinfo.h>
+
+
+#include <com/sun/star/io/XInputStream.hpp>
+
+using namespace rtl;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::io;
+
+#include "xml2utf.hxx"
+
+namespace sax_expatwrap {
+
+sal_Int32 XMLFile2UTFConverter::readAndConvert( Sequence<sal_Int8> &seq , sal_Int32 nMaxToRead )
+	throw ( IOException, NotConnectedException , BufferSizeExceededException , RuntimeException )
+{
+
+	Sequence<sal_Int8> seqIn;
+
+	if( ! m_in.is() ) {
+		throw NotConnectedException();
+	}
+	if( ! m_bStarted ) {
+		nMaxToRead = Max( 512 , nMaxToRead );  	// it should be possible to find the encoding attribute
+						     					// within the first 512 bytes == 128 chars in UCS-4
+	}
+
+	sal_Int32 nRead;
+	Sequence< sal_Int8 > seqStart;
+	while( sal_True )
+	{
+		nRead = m_in->readSomeBytes( seq , nMaxToRead );
+
+		if( nRead + seqStart.getLength())
+		{
+			// if nRead is 0, the file is already eof.
+			if( ! m_bStarted && nRead )
+			{
+				// ensure that enough data is available to parse encoding
+				if( seqStart.getLength() )
+				{
+				  // prefix with what we had so far.
+				  sal_Int32 nLength = seq.getLength();
+				  seq.realloc( seqStart.getLength() + nLength );
+
+				  memmove (seq.getArray() + seqStart.getLength(),
+					   seq.getConstArray(),
+					   nLength);
+				  memcpy  (seq.getArray(),
+					   seqStart.getConstArray(),
+					   seqStart.getLength());
+				}
+
+				// autodetection with the first bytes
+				if( ! isEncodingRecognizable( seq ) )
+				{
+				  // remember what we have so far.
+				  seqStart = seq;
+
+				  // read more !
+				  continue;
+				}
+				if( scanForEncoding( seq ) || m_sEncoding.getLength() ) {
+					// initialize decoding
+					initializeDecoding();
+				}
+				nRead = seq.getLength();
+				seqStart = Sequence < sal_Int8 > ();
+			}
+
+			// do the encoding
+			if( m_pText2Unicode && m_pUnicode2Text &&
+				m_pText2Unicode->canContinue() && m_pUnicode2Text->canContinue() ) {
+
+				Sequence<sal_Unicode> seqUnicode = m_pText2Unicode->convert( seq );
+				seq = m_pUnicode2Text->convert(	seqUnicode.getConstArray(),	seqUnicode.getLength() );
+			}
+
+			if( ! m_bStarted )
+			{
+				// it must now be ensured, that no encoding attribute exist anymore
+				// ( otherwise the expat-Parser will crash )
+				// This must be done after decoding !
+				// ( e.g. Files decoded in ucs-4 cannot be read properly )
+				m_bStarted = sal_True;
+				removeEncoding( seq );
+			}
+			nRead = seq.getLength();
+		}
+
+		break;
+	}
+	return nRead;
+}
+
+
+XMLFile2UTFConverter::~XMLFile2UTFConverter()
+{
+	if( m_pText2Unicode )
+		delete m_pText2Unicode;
+	if( m_pUnicode2Text )
+		delete m_pUnicode2Text;
+}
+
+
+void XMLFile2UTFConverter::removeEncoding( Sequence<sal_Int8> &seq )
+{
+	const sal_Int8 *pSource = seq.getArray();
+	if( ! strncmp( (const char * ) pSource , "<?xml" , 4) )
+	{
+
+		// scan for encoding
+		OString str( (sal_Char * ) pSource , seq.getLength() );
+
+		// cut sequence to first line break
+		// find first line break;
+		int nMax = str.indexOf( 10 );
+		if( nMax >= 0 )
+		{
+			str = str.copy( 0 , nMax );
+		}
+
+		int nFound = str.indexOf( " encoding" );
+		if( nFound >= 0 ) {
+			int nStop;
+			int nStart = str.indexOf( "\"" , nFound );
+			if( nStart < 0 || str.indexOf( "'" , nFound ) < nStart )
+			{
+				nStart = str.indexOf( "'" , nFound );
+				nStop  = str.indexOf( "'" , nStart +1 );
+			}
+			else
+			{
+				nStop  = str.indexOf( "\"" , nStart +1);
+			}
+
+			if( nStart >= 0 && nStop >= 0 && nStart+1 < nStop )
+			{
+				// remove encoding tag from file
+				memmove(        &( seq.getArray()[nFound] ) ,
+								&( seq.getArray()[nStop+1]) ,
+								seq.getLength() - nStop -1);
+				seq.realloc( seq.getLength() - ( nStop+1 - nFound ) );
+//				str = String( (char * ) seq.getArray() , seq.getLen() );
+			}
+		}
+	}
+}
+
+// Checks, if enough data has been accumulated to recognize the encoding
+sal_Bool XMLFile2UTFConverter::isEncodingRecognizable( const Sequence< sal_Int8 > &seq)
+{
+	const sal_Int8 *pSource = seq.getConstArray();
+	sal_Bool bCheckIfFirstClosingBracketExsists = sal_False;
+
+	if( seq.getLength() < 8 ) {
+		// no recognition possible, when less than 8 bytes are available
+		return sal_False;
+	}
+
+	if( ! strncmp( (const char * ) pSource , "<?xml" , 4 ) ) {
+		// scan if the <?xml tag finishes within this buffer
+		bCheckIfFirstClosingBracketExsists = sal_True;
+	}
+	else if( ('<' == pSource[0] || '<' == pSource[2] ) &&
+			 ( ('?' == pSource[4] || '?' == pSource[6] ) ) )
+	{
+		// check for utf-16
+		bCheckIfFirstClosingBracketExsists = sal_True;
+	}
+	else if( ( '<' == pSource[1] || '<' == pSource[3] ) &&
+		     ( '?' == pSource[5] || '?' == pSource[7] ) )
+	{
+		// check for
+		bCheckIfFirstClosingBracketExsists = sal_True;
+	}
+
+	if( bCheckIfFirstClosingBracketExsists )
+	{
+		for( sal_Int32 i = 0; i < seq.getLength() ; i ++ )
+		{
+			// whole <?xml tag is valid
+			if( '>' == pSource[ i ] )
+			{
+				return sal_True;
+			}
+		}
+		return sal_False;
+	}
+
+	// No <? tag in front, no need for a bigger buffer
+	return sal_True;
+}
+
+sal_Bool XMLFile2UTFConverter::scanForEncoding( Sequence< sal_Int8 > &seq )
+{
+	const sal_uInt8 *pSource = reinterpret_cast<const sal_uInt8*>( seq.getConstArray() );
+	sal_Bool bReturn = sal_True;
+
+	if( seq.getLength() < 4 ) {
+		// no recognition possible, when less than 4 bytes are available
+		return sal_False;
+	}
+
+	// first level : detect possible file formats
+	if( ! strncmp( (const char * ) pSource , "<?xml" , 4 ) ) {
+
+		// scan for encoding
+		OString str( (const sal_Char *) pSource , seq.getLength() );
+
+		// cut sequence to first line break
+		//find first line break;
+		int nMax = str.indexOf( 10 );
+		if( nMax >= 0 )
+		{
+			str = str.copy( 0 , nMax );
+		}
+
+		int nFound = str.indexOf( " encoding" );
+		if( nFound < str.getLength() ) {
+			int nStop;
+			int nStart = str.indexOf( "\"" , nFound );
+			if( nStart < 0 || str.indexOf( "'" , nFound ) < nStart )
+			{
+				nStart = str.indexOf( "'" , nFound );
+				nStop  = str.indexOf( "'" , nStart +1 );
+			}
+			else
+			{
+				nStop  = str.indexOf( "\"" , nStart +1);
+			}
+			if( nStart >= 0 && nStop >= 0 && nStart+1 < nStop )
+			{
+				// encoding found finally
+				m_sEncoding = str.copy( nStart+1 , nStop - nStart - 1 );
+			}
+		}
+	}
+	else if( 0xFE == pSource[0] &&
+	         0xFF == pSource[1] ) {
+		// UTF-16 big endian
+		// conversion is done so that encoding information can be easily extracted
+		m_sEncoding = "utf-16";
+	}
+	else if( 0xFF == pSource[0] &&
+	         0xFE == pSource[1] ) {
+		// UTF-16 little endian
+		// conversion is done so that encoding information can be easily extracted
+		m_sEncoding = "utf-16";
+	}
+	else if( 0x00 == pSource[0] && 0x3c == pSource[1]  && 0x00 == pSource[2] && 0x3f == pSource[3] ) {
+		// UTF-16 big endian without byte order mark (this is (strictly speaking) an error.)
+		// The byte order mark is simply added
+
+		// simply add the byte order mark !
+		seq.realloc( seq.getLength() + 2 );
+		memmove( &( seq.getArray()[2] ) , seq.getArray() , seq.getLength() - 2 );
+		((sal_uInt8*)seq.getArray())[0] = 0xFE;
+		((sal_uInt8*)seq.getArray())[1] = 0xFF;
+
+		m_sEncoding = "utf-16";
+	}
+	else if( 0x3c == pSource[0] && 0x00 == pSource[1]  && 0x3f == pSource[2] && 0x00 == pSource[3] ) {
+		// UTF-16 little endian without byte order mark (this is (strictly speaking) an error.)
+		// The byte order mark is simply added
+
+		seq.realloc( seq.getLength() + 2 );
+		memmove( &( seq.getArray()[2] ) , seq.getArray() , seq.getLength() - 2 );
+		((sal_uInt8*)seq.getArray())[0] = 0xFF;
+		((sal_uInt8*)seq.getArray())[1] = 0xFE;
+
+		m_sEncoding = "utf-16";
+	}
+    else if( 0xEF == pSource[0] && 
+             0xBB == pSource[1] &&
+             0xBF == pSource[2] )
+    {
+        // UTF-8 BOM (byte order mark); signifies utf-8, and not byte order
+        // The BOM is removed.
+        memmove( seq.getArray(), &( seq.getArray()[3] ), seq.getLength()-3 );
+        seq.realloc( seq.getLength() - 3 );
+        m_sEncoding = "utf-8";
+    }
+	else if( 0x00 == pSource[0] && 0x00 == pSource[1]  && 0x00 == pSource[2] && 0x3c == pSource[3] ) {
+		// UCS-4 big endian
+		m_sEncoding = "ucs-4";
+	}
+	else if( 0x3c == pSource[0] && 0x00 == pSource[1]  && 0x00 == pSource[2] && 0x00 == pSource[3] ) {
+		// UCS-4 little endian
+		m_sEncoding = "ucs-4";
+	}
+	else if( 0x4c == pSource[0] && 0x6f == pSource[1]  &&
+	         0xa7 == static_cast<unsigned char> (pSource[2]) &&
+	         0x94 == static_cast<unsigned char> (pSource[3]) ) {
+		// EBCDIC
+		bReturn = sal_False;   // must be extended
+	}
+	else {
+		// other
+		// UTF8 is directly recognized by the parser.
+		bReturn = sal_False;
+	}
+
+	return bReturn;
+}
+
+void XMLFile2UTFConverter::initializeDecoding()
+{
+
+	if( m_sEncoding.getLength() )
+	{
+		rtl_TextEncoding encoding = rtl_getTextEncodingFromMimeCharset( m_sEncoding.getStr() );
+		if( encoding != RTL_TEXTENCODING_UTF8 )
+		{
+			m_pText2Unicode = new Text2UnicodeConverter( m_sEncoding );
+			m_pUnicode2Text = new Unicode2TextConverter( RTL_TEXTENCODING_UTF8 );
+		}
+	}
+}
+
+
+//----------------------------------------------
+//
+// Text2UnicodeConverter
+//
+//----------------------------------------------
+Text2UnicodeConverter::Text2UnicodeConverter( const OString &sEncoding )
+{
+	rtl_TextEncoding encoding = rtl_getTextEncodingFromMimeCharset( sEncoding.getStr() );
+	if( RTL_TEXTENCODING_DONTKNOW == encoding )
+	{
+		m_bCanContinue = sal_False;
+		m_bInitialized = sal_False;
+	}
+	else
+	{
+		init( encoding );
+	}
+}
+
+Text2UnicodeConverter::Text2UnicodeConverter( rtl_TextEncoding encoding )
+{
+	init( encoding );
+}
+
+
+Text2UnicodeConverter::~Text2UnicodeConverter()
+{
+	if( m_bInitialized )
+	{
+		rtl_destroyTextToUnicodeContext( m_convText2Unicode , m_contextText2Unicode );
+		rtl_destroyUnicodeToTextConverter( m_convText2Unicode );
+	}
+}
+
+void Text2UnicodeConverter::init( rtl_TextEncoding encoding )
+{
+	m_bCanContinue = sal_True;
+	m_bInitialized = sal_True;
+
+	m_convText2Unicode 	= rtl_createTextToUnicodeConverter(encoding);
+	m_contextText2Unicode = rtl_createTextToUnicodeContext( m_convText2Unicode );
+	m_rtlEncoding = encoding;
+}
+
+
+Sequence<sal_Unicode> Text2UnicodeConverter::convert( const Sequence<sal_Int8> &seqText )
+{
+	sal_uInt32 uiInfo;
+	sal_Size nSrcCvtBytes 	= 0;
+	sal_Size nTargetCount 	= 0;
+	sal_Size nSourceCount   = 0;
+
+	// the whole source size
+	sal_Int32 	nSourceSize = seqText.getLength() + m_seqSource.getLength();
+	Sequence<sal_Unicode> 	seqUnicode ( nSourceSize );
+
+	const sal_Int8 *pbSource = seqText.getConstArray();
+	sal_Int8 *pbTempMem = 0;
+
+	if( m_seqSource.getLength() ) {
+		// put old rest and new byte sequence into one array
+		pbTempMem = new sal_Int8[ nSourceSize ];
+		memcpy( pbTempMem , m_seqSource.getConstArray() , m_seqSource.getLength() );
+		memcpy( &(pbTempMem[ m_seqSource.getLength() ]) , seqText.getConstArray() , seqText.getLength() );
+		pbSource = pbTempMem;
+
+		// set to zero again
+		m_seqSource = Sequence< sal_Int8 >();
+	}
+
+	while( sal_True ) {
+
+		/* All invalid characters are transformed to the unicode undefined char */
+		nTargetCount += 	rtl_convertTextToUnicode(
+									m_convText2Unicode,
+									m_contextText2Unicode,
+									( const sal_Char * ) &( pbSource[nSourceCount] ),
+									nSourceSize - nSourceCount ,
+									&( seqUnicode.getArray()[ nTargetCount ] ),
+									seqUnicode.getLength() - nTargetCount,
+									RTL_TEXTTOUNICODE_FLAGS_UNDEFINED_DEFAULT   |
+									RTL_TEXTTOUNICODE_FLAGS_MBUNDEFINED_DEFAULT |
+									RTL_TEXTTOUNICODE_FLAGS_INVALID_DEFAULT,
+									&uiInfo,
+									&nSrcCvtBytes );
+		nSourceCount += nSrcCvtBytes;
+
+		if( uiInfo & RTL_TEXTTOUNICODE_INFO_DESTBUFFERTOSMALL ) {
+			// save necessary bytes for next conversion
+			seqUnicode.realloc( seqUnicode.getLength() * 2 );
+			continue;
+		}
+		break;
+	}
+	if( uiInfo & RTL_TEXTTOUNICODE_INFO_SRCBUFFERTOSMALL ) {
+		m_seqSource.realloc( nSourceSize - nSourceCount );
+		memcpy( m_seqSource.getArray() , &(pbSource[nSourceCount]) , nSourceSize-nSourceCount );
+	}
+
+
+	if( pbTempMem ) {
+		delete pbTempMem;
+	}
+
+	// set to correct unicode size
+	seqUnicode.realloc( nTargetCount );
+
+	return seqUnicode;
+}
+
+
+
+//----------------------------------------------
+//
+// Unicode2TextConverter
+//
+//----------------------------------------------
+Unicode2TextConverter::Unicode2TextConverter( const OString &sEncoding )
+{
+	rtl_TextEncoding encoding = rtl_getTextEncodingFromMimeCharset( sEncoding.getStr() );
+	if( RTL_TEXTENCODING_DONTKNOW == encoding ) {
+		m_bCanContinue = sal_False;
+		m_bInitialized = sal_False;
+	}
+	else {
+		init( encoding );
+	}
+
+}
+
+Unicode2TextConverter::Unicode2TextConverter( rtl_TextEncoding encoding )
+{
+	init( encoding );
+}
+
+
+Unicode2TextConverter::~Unicode2TextConverter()
+{
+	if( m_bInitialized ) {
+		rtl_destroyUnicodeToTextContext( m_convUnicode2Text , m_contextUnicode2Text );
+		rtl_destroyUnicodeToTextConverter( m_convUnicode2Text );
+	}
+}
+
+
+Sequence<sal_Int8> Unicode2TextConverter::convert(const sal_Unicode *puSource , sal_Int32 nSourceSize)
+{
+	sal_Unicode *puTempMem = 0;
+
+	if( m_seqSource.getLength() ) {
+		// For surrogates !
+		// put old rest and new byte sequence into one array
+		// In general when surrogates are used, they should be rarely
+		// cut off between two convert()-calls. So this code is used
+		// rarely and the extra copy is acceptable.
+		puTempMem = new sal_Unicode[ nSourceSize + m_seqSource.getLength()];
+		memcpy( puTempMem ,
+				m_seqSource.getConstArray() ,
+				m_seqSource.getLength() * sizeof( sal_Unicode ) );
+		memcpy(
+			&(puTempMem[ m_seqSource.getLength() ]) ,
+			puSource ,
+			nSourceSize*sizeof( sal_Unicode ) );
+		puSource = puTempMem;
+		nSourceSize += m_seqSource.getLength();
+
+		m_seqSource = Sequence< sal_Unicode > ();
+	}
+
+
+	sal_Size nTargetCount = 0;
+	sal_Size nSourceCount = 0;
+
+	sal_uInt32 uiInfo;
+	sal_Size nSrcCvtChars;
+
+	// take nSourceSize * 3 as preference
+	// this is an upper boundary for converting to utf8,
+	// which most often used as the target.
+	sal_Int32 nSeqSize =  nSourceSize * 3;
+
+	Sequence<sal_Int8> 	seqText( nSeqSize );
+	sal_Char *pTarget = (sal_Char *) seqText.getArray();
+	while( sal_True ) {
+
+		nTargetCount += rtl_convertUnicodeToText(
+									m_convUnicode2Text,
+									m_contextUnicode2Text,
+									&( puSource[nSourceCount] ),
+									nSourceSize - nSourceCount ,
+									&( pTarget[nTargetCount] ),
+									nSeqSize - nTargetCount,
+									RTL_UNICODETOTEXT_FLAGS_UNDEFINED_DEFAULT |
+									RTL_UNICODETOTEXT_FLAGS_INVALID_DEFAULT ,
+									&uiInfo,
+									&nSrcCvtChars);
+		nSourceCount += nSrcCvtChars;
+
+		if( uiInfo & RTL_UNICODETOTEXT_INFO_DESTBUFFERTOSMALL ) {
+			nSeqSize = nSeqSize *2;
+			seqText.realloc( nSeqSize );  // double array size
+			pTarget = ( sal_Char * ) seqText.getArray();
+			continue;
+		}
+		break;
+	}
+
+	// for surrogates
+	if( uiInfo & RTL_UNICODETOTEXT_INFO_SRCBUFFERTOSMALL ) {
+		m_seqSource.realloc( nSourceSize - nSourceCount );
+		memcpy( m_seqSource.getArray() ,
+				&(puSource[nSourceCount]),
+				(nSourceSize - nSourceCount) * sizeof( sal_Unicode ) );
+	}
+
+	if( puTempMem ) {
+		delete puTempMem;
+	}
+
+	// reduce the size of the buffer (fast, no copy necessary)
+	seqText.realloc( nTargetCount );
+
+	return seqText;
+}
+
+void Unicode2TextConverter::init( rtl_TextEncoding encoding )
+{
+	m_bCanContinue = sal_True;
+	m_bInitialized = sal_True;
+
+	m_convUnicode2Text 	= rtl_createUnicodeToTextConverter( encoding );
+	m_contextUnicode2Text = rtl_createUnicodeToTextContext( m_convUnicode2Text );
+	m_rtlEncoding = encoding;
+};
+
+
+}
Index: unoxml/source/fastsax/xml2utf.hxx
===================================================================
RCS file: unoxml/source/fastsax/xml2utf.hxx
diff -N unoxml/source/fastsax/xml2utf.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/xml2utf.hxx	31 May 2007 10:17:19 -0000	1.1.2.1
@@ -0,0 +1,157 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+// TODO: Woher?
+#define Max( a, b )		(((a)>(b)) ? (a) : (b) )
+#define Min( a, b )		(((a)<(b)) ? (a) : (b) )
+
+/*
+* 
+* Text2UnicodeConverter
+*
+**/
+namespace sax_expatwrap {
+	
+class Text2UnicodeConverter 
+{
+
+public:
+	Text2UnicodeConverter( const ::rtl::OString & sEncoding );
+	Text2UnicodeConverter( rtl_TextEncoding encoding );
+	~Text2UnicodeConverter();
+
+	::com::sun::star::uno::Sequence < sal_Unicode > convert( const ::com::sun::star::uno::Sequence<sal_Int8> & );
+	sal_Bool canContinue() {  return m_bCanContinue; }
+
+private:
+	void init( rtl_TextEncoding encoding );
+
+	rtl_TextToUnicodeConverter 	m_convText2Unicode;
+	rtl_TextToUnicodeContext   	m_contextText2Unicode;
+	sal_Bool					m_bCanContinue;
+	sal_Bool					m_bInitialized;
+	rtl_TextEncoding			m_rtlEncoding;
+	::com::sun::star::uno::Sequence<sal_Int8> m_seqSource;
+};
+
+/*----------------------------------------
+*
+* Unicode2TextConverter
+*
+**-----------------------------------------*/
+class Unicode2TextConverter 
+{
+public:
+	Unicode2TextConverter( const ::rtl::OString & sEncoding );
+	Unicode2TextConverter( rtl_TextEncoding encoding );
+	~Unicode2TextConverter();
+
+	inline ::com::sun::star::uno::Sequence<sal_Int8> convert( const ::rtl::OUString &s )
+		{
+			return convert( s.getStr() , s.getLength() );
+		}
+	::com::sun::star::uno::Sequence<sal_Int8> convert( const sal_Unicode * , sal_Int32 nLength );
+	sal_Bool canContinue() {  return m_bCanContinue; }
+
+private:
+	void init( rtl_TextEncoding encoding );
+
+	rtl_UnicodeToTextConverter 	m_convUnicode2Text;
+	rtl_UnicodeToTextContext   	m_contextUnicode2Text;
+	sal_Bool					m_bCanContinue;
+	sal_Bool					m_bInitialized;
+	rtl_TextEncoding			m_rtlEncoding;
+	::com::sun::star::uno::Sequence<sal_Unicode>		m_seqSource;
+};
+
+
+
+/*----------------------------------------
+*
+* XMLFile2UTFConverter
+*
+**-----------------------------------------*/
+class XMLFile2UTFConverter
+{
+public:
+	XMLFile2UTFConverter( ):
+		m_bStarted( sal_False ),
+		m_pText2Unicode( 0 ),
+		m_pUnicode2Text( 0 )
+		{}
+
+	~XMLFile2UTFConverter();
+	
+	void setInputStream( ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream > &r ) { m_in = r; }
+	void setEncoding( const ::rtl::OString &s ) { m_sEncoding = s; }
+
+
+	
+	// @param nMaxToRead The number of chars, that should be read. Note that this is no exact number. There
+	//                   may be returned less or more bytes than ordered.
+	sal_Int32 readAndConvert( ::com::sun::star::uno::Sequence<sal_Int8> &seq , sal_Int32 nMaxToRead ) 
+		throw ( ::com::sun::star::io::IOException,
+				::com::sun::star::io::NotConnectedException ,
+				::com::sun::star::io::BufferSizeExceededException ,
+				::com::sun::star::uno::RuntimeException );
+
+private:
+
+	// Called only on first Sequence of bytes. Tries to figure out file format and encoding information.
+	// @return TRUE, when encoding information could be retrieved
+	// @return FALSE, when no encoding information was found in file
+	sal_Bool scanForEncoding( ::com::sun::star::uno::Sequence<sal_Int8> &seq );
+
+	// Called only on first Sequence of bytes. Tries to figure out
+	// if enough data is available to scan encoding
+	// @return TRUE, when encoding is retrievable
+	// @return FALSE, when more data is needed
+	sal_Bool isEncodingRecognizable( const ::com::sun::star::uno::Sequence< sal_Int8 > & seq );
+
+	// When encoding attribute is within the text (in the first line), it is removed.
+	void removeEncoding( ::com::sun::star::uno::Sequence<sal_Int8> &seq );
+	
+	// Initializes decoding depending on m_sEncoding setting
+	void initializeDecoding();
+private:
+	::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream >  m_in;
+		
+	sal_Bool m_bStarted;
+	::rtl::OString m_sEncoding;
+
+	Text2UnicodeConverter *m_pText2Unicode;
+	Unicode2TextConverter *m_pUnicode2Text;	
+};
+}
Index: unoxml/source/fastsax/api/makefile.mk
===================================================================
RCS file: unoxml/source/fastsax/api/makefile.mk
diff -N unoxml/source/fastsax/api/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/api/makefile.mk	31 May 2007 10:16:01 -0000	1.1.2.1
@@ -0,0 +1,80 @@
+#*************************************************************************
+#
+#   OpenOffice.org - a multi-platform office productivity suite
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+#
+#
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+#
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+#
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=unoxml
+TARGET=fastsaxapi
+ENABLE_EXCEPTIONS=TRUE
+
+
+# --- Settings -----------------------------------------------------------
+
+.INCLUDE :	settings.mk
+
+# --- Private UNO ----------------------------------------------------------
+
+PRIVATERDB = localtypes.rdb
+UNOUCRRDB = $(BIN)$/fastsaxapi.rdb
+UNOUCRDEP = $(UNOUCRRDB)
+UNOUCROUT = $(OUT)$/inc
+
+CPPUMAKERFLAGS += -C -X$(SOLARBINDIR)$/types.rdb
+
+UNOTYPES = \
+	com.sun.star.xml.Attribute \
+	com.sun.star.xml.sax.FastToken \
+	com.sun.star.xml.sax.XFastParser \
+	com.sun.star.xml.sax.XFastAttributeList \
+	com.sun.star.xml.sax.XFastContextHandler \
+	com.sun.star.xml.sax.XFastTokenHandler \
+	com.sun.star.xml.sax.XFastDocumentHandler
+
+ALLIDLFILES = $(foreach,i,$(UNOTYPES) $(subst,.,$/ $i).idl)
+
+# ==========================================================================
+
+.INCLUDE :	target.mk
+
+# --- Private UNO ----------------------------------------------------------
+
+ALLTAR : $(UNOUCRRDB)
+
+$(BIN)$/$(PRIVATERDB) : $(ALLIDLFILES)
+	$(IDLC) -I. -I$(SOLARIDLDIR) -O$(UCR) $(ALLIDLFILES)
+	$(REGMERGE) $@ /UCR $(UCR)$/{$(?:f:s/.idl/.urd/)}
+
+$(UNOUCRRDB) : $(BIN)$/$(PRIVATERDB)
+	$(COPY) $< $@ 
Index: unoxml/source/fastsax/api/com/sun/star/xml/Attribute.idl
===================================================================
RCS file: unoxml/source/fastsax/api/com/sun/star/xml/Attribute.idl
diff -N unoxml/source/fastsax/api/com/sun/star/xml/Attribute.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/api/com/sun/star/xml/Attribute.idl	31 May 2007 10:15:31 -0000	1.1.2.1
@@ -0,0 +1,69 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_xml_Attribute_idl__ 
+#define __com_sun_star_xml_Attribute_idl__ 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module xml { 
+ 
+//============================================================================= 
+ 
+/**
+ * A struct to keep information of an element's attribute.
+ */
+struct Attribute
+{
+	/**
+	 * the attribute name
+	 */
+	string Name;
+
+	/**
+	 * the attribute namespace URL
+	 */
+	string NamespaceURL;
+	
+	/**
+	 * the attribute value
+	 */
+	string Value;
+};
+ 
+//============================================================================= 
+ 
+}; }; }; };  
+
+#endif 
Index: unoxml/source/fastsax/api/com/sun/star/xml/sax/FastToken.idl
===================================================================
RCS file: unoxml/source/fastsax/api/com/sun/star/xml/sax/FastToken.idl
diff -N unoxml/source/fastsax/api/com/sun/star/xml/sax/FastToken.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/api/com/sun/star/xml/sax/FastToken.idl	31 May 2007 10:14:24 -0000	1.1.2.1
@@ -0,0 +1,67 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_xml_sax_XFastToken_idl__ 
+#define __com_sun_star_xml_sax_XFastToken_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module xml {  module sax {  
+ 
+//============================================================================ 
+
+constants FastToken
+{ 
+	//------------------------------------------------------------------------- 
+		
+	/** specifies an unknown token.
+	 */
+	const long DONTKNOW = -1;
+
+	//------------------------------------------------------------------------- 
+
+	/** specifies the first namespace token
+	*/
+	const long NAMESPACE = 0x00010000;
+};
+
+//============================================================================= 
+ 
+}; }; }; }; };  
+ 
+#endif 
Index: unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastAttributeList.idl
===================================================================
RCS file: unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastAttributeList.idl
diff -N unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastAttributeList.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastAttributeList.idl	31 May 2007 10:14:33 -0000	1.1.2.1
@@ -0,0 +1,179 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_xml_sax_XFastAttributeList_idl__ 
+#define __com_sun_star_xml_sax_XFastAttributeList_idl__ 
+
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+
+#ifndef __com_sun_star_xml_Attribute_idl__
+#include <com/sun/star/xml/Attribute.idl>
+#endif
+
+#ifndef __com_sun_star_xml_sax_SAXException_idl__
+#include <com/sun/star/xml/sax/SAXException.idl>
+#endif
+
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module xml {  module sax {  
+ 
+//============================================================================= 
+ 
+/** a container for the attributes of an xml element. 
+
+	<br>Attributes are seperated into known attributes and unknown attributes.
+	<p>Known attributes have a local name that is known to the <type>XFastTokenHandler</token>
+	registered at the <type>XFastParser</type> which created the sax event containing
+	this attributes. If an attribute also has a namespace, that must be registered
+	at the <type>XFastParser</type>, else this attribute is also unknown even if
+	the local name is known.
+ */
+interface XFastAttributeList: com::sun::star::uno::XInterface
+{
+	/** checks if an attribute is available.<br>
+
+		@param Token
+			contains the integer token from the <type>XFastTokenHandler</type>
+			registered at the <type>XFastParser</type>.<br>
+
+			If the attribute name has a namespace that was registered with the
+			<type>XFastParser</type>, Token contains the integer token of the
+			attributes local name from the <type>XFastTokenHandler</type> and
+			the integer token of the namespace combined with an arithmetic
+			<b>or</b> operation.
+
+		@returns
+			<TRUE/>, if the attribute is available
+	*/
+	boolean hasAttribute( [in] long Token );
+
+	/** retrieves the token of an attributes value.<br>
+
+		@param Token
+			contains the integer token from the <type>XFastTokenHandler</type>
+			registered at the <type>XFastParser</type>.<br>
+
+			If the attribute name has a namespace that was registered with the
+			<type>XFastParser</type>, Token contains the integer token of the
+			attributes local name from the <type>XFastTokenHandler</type> and
+			the integer token of the namespace combined with an arithmetic
+			<b>or</b> operation.
+
+		@returns
+			The integer token of the value from the attribute or <const>FastToken::Invalid</const>
+
+		@raises SAXEXception
+			if the attribute is not available
+
+	*/
+	long getValueToken( [in] long Token )
+		raises( SAXException );
+
+	/**retrieves the token of an attributes value.<br>
+
+		@param Token
+			contains the integer token from the <type>XFastTokenHandler</type>
+			registered at the <type>XFastParser</type>.<br>
+
+			If the attribute name has a namespace that was registered with the
+			<type>XFastParser</type>, Token contains the integer token of the
+			attributes local name from the <type>XFastTokenHandler</type> and
+			the integer token of the namespace combined with an arithmetic
+			<b>or</b> operation.
+
+		@param Default
+			This value will be returned if the attribute is not available
+
+		@returns
+			If the attribute is available it returns the integer token of the value
+			from the attribute or <const>FastToken::Invalid</const>.
+			If not the value of <param>Default</param> is returned.
+
+	*/
+	long getOptionalValueToken( [in] long Token, [in] long Default );
+
+	/** retrieves the value of an attributes.<br>
+
+		@param Token
+			contains the integer token from the <type>XFastTokenHandler</type>
+			registered at the <type>XFastParser</type>.<br>
+
+			If the attribute name has a namespace that was registered with the
+			<type>XFastParser</type>, Token contains the integer token of the
+			attributes local name from the <type>XFastTokenHandler</type> and
+			the integer token of the namespace combined with an arithmetic
+			<b>or</b> operation.
+
+		@returns
+			The string value from the attribute.
+
+		@raises SAXEXception
+			if the attribute is not available
+
+	*/
+	string getValue( [in] long Token )
+		raises( SAXException );
+
+	/** retrieves the value of an attributes.<br>
+
+		@param Token
+			contains the integer token from the <type>XFastTokenHandler</type>
+			registered at the <type>XFastParser</type>.<br>
+
+			If the attribute name has a namespace that was registered with the
+			<type>XFastParser</type>, Token contains the integer token of the
+			attributes local name from the <type>XFastTokenHandler</type> and
+			the integer token of the namespace combined with an arithmetic
+			<b>or</b> operation.
+
+		@returns
+			The string value from the attribute or an empty string if the
+			attribute is not available.
+	*/
+	string getOptionalValue( [in] long Token );
+
+	/** returns a sequence of attributes which names and or namespaces URLS
+		can not be translated to tokens.
+	*/
+	sequence< ::com::sun::star::xml::Attribute > getUnknownAttributes();
+};
+
+//============================================================================= 
+ 
+}; }; }; }; };  
+ 
+#endif 
Index: unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastContextHandler.idl
===================================================================
RCS file: unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastContextHandler.idl
diff -N unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastContextHandler.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastContextHandler.idl	31 May 2007 10:14:41 -0000	1.1.2.1
@@ -0,0 +1,169 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_xml_sax_XFastContextHandler_idl__ 
+#define __com_sun_star_xml_sax_XFastContextHandler_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_xml_sax_SAXException_idl__ 
+#include <com/sun/star/xml/sax/SAXException.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_xml_sax_XFastAttributeList_idl__ 
+#include <com/sun/star/xml/sax/XFastAttributeList.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_xml_sax_XLocator_idl__ 
+#include <com/sun/star/xml/sax/XLocator.idl> 
+#endif 
+ 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module xml {  module sax {  
+ 
+//============================================================================= 
+ 
+/** receives notification of sax document events from a
+	<type>XFastParser</type>.
+	
+	@see XFastDocumentHandler
+ */
+interface XFastContextHandler: com::sun::star::uno::XInterface
+{ 
+	//------------------------------------------------------------------------- 
+	 
+	/** receives notification of the beginning of an element .
+
+		@param Element
+			contains the integer token from the <type>XFastTokenHandler</type>
+			registered at the <type>XFastParser</type>.<br>
+
+			If the element has a namespace that was registered with the
+			<type>XFastParser</type>, <param>Element</param> contains the integer
+			token of the elements local name from the <type>XFastTokenHandler</type>
+			and the integer token of the namespace combined with an arithmetic
+			<b>or</b> operation.
+
+		@param Attribs
+			Contains a <type>XFastAttrbitueList</type> to access the attributes
+			from the element.
+
+	*/
+	void startFastElement( [in] long Element, [in] XFastAttributeList Attribs ) 
+			raises( com::sun::star::xml::sax::SAXException ); 
+
+	//------------------------------------------------------------------------- 
+
+	/** receives notification of the beginning of an unknown element .
+
+		@param Namespace
+			contains the namespace url (not the prefix!) of this element.
+		@param Name
+			contains the elements local name.
+		@param Attribs
+			Contains a <type>XFastAttrbitueList</type> to access the attributes
+			from the element.
+	 */
+	void startUnknownElement( [in] string Namespace, [in] string Name, [in] XFastAttributeList Attribs ) 
+			raises( com::sun::star::xml::sax::SAXException ); 
+
+	//------------------------------------------------------------------------- 
+
+	/** receives notification of the end of an known element.
+		@see startFastElement
+	 */
+	void endFastElement( [in] long Element ) 
+			raises( com::sun::star::xml::sax::SAXException ); 
+
+	//------------------------------------------------------------------------- 
+
+	/** receives notification of the end of an kown element.
+		@see startUnknownElement
+	 */
+	void endUnknownElement( [in] string Namespace, [in] string Name ) 
+			raises( com::sun::star::xml::sax::SAXException ); 
+ 
+	//------------------------------------------------------------------------- 
+	 
+	/** receives notification of the beginning of a known child element.
+
+		@param Element
+			contains the integer token from the <type>XFastTokenHandler</type>
+			registered at the <type>XFastParser</type>.
+
+			<br>If the element has a namespace that was registered with the
+			<type>XFastParser</type>, <param>Element</param> contains the
+			integer token of the elements local name from the
+			<type>XFastTokenHandler</type> and the integer token of the
+			namespace combined with an arithmetic <b>or</b> operation.
+
+		@param Attribs
+			Contains a <type>XFastAttrbitueList</type> to access the attributes
+			from the element.
+	 */
+	XFastContextHandler createFastChildContext( [in] long Element, [in] XFastAttributeList Attribs ) 
+			raises( com::sun::star::xml::sax::SAXException ); 
+
+	//------------------------------------------------------------------------- 
+	 
+	/** receives notification of the beginning of a unknown child element .
+
+		@param Namespace
+			contains the namespace url (not the prefix!) of this element.
+		@param Name
+			contains the elements local name.
+		@param Attribs
+			Contains a <type>XFastAttrbitueList</type> to access the attributes
+			the element.
+	 */
+	XFastContextHandler createUnknownChildContext( [in] string Namespace, [in] string Name, [in] XFastAttributeList Attribs ) 
+			raises( com::sun::star::xml::sax::SAXException ); 
+
+	//------------------------------------------------------------------------- 
+	 
+	/** receives notification of character data.
+	 */
+	void characters( [in] string aChars ) 
+			raises( com::sun::star::xml::sax::SAXException ); 
+  }; 
+ 
+//============================================================================= 
+ 
+}; }; }; }; };  
+ 
+#endif 
Index: unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastDocumentHandler.idl
===================================================================
RCS file: unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastDocumentHandler.idl
diff -N unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastDocumentHandler.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastDocumentHandler.idl	31 May 2007 10:14:49 -0000	1.1.2.1
@@ -0,0 +1,97 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_xml_sax_XFastDocumentHandler_idl__ 
+#define __com_sun_star_xml_sax_XFastDocumentHandler_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_xml_sax_SAXException_idl__ 
+#include <com/sun/star/xml/sax/SAXException.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_xml_sax_XFastAttributeList_idl__ 
+#include <com/sun/star/xml/sax/XFastAttributeList.idl> 
+#endif 
+
+#ifndef __com_sun_star_xml_sax_XFastContextHandler_idl__ 
+#include <com/sun/star/xml/sax/XFastContextHandler.idl> 
+#endif 
+
+#ifndef __com_sun_star_xml_sax_XLocator_idl__ 
+#include <com/sun/star/xml/sax/XLocator.idl> 
+#endif 
+ 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module xml {  module sax {  
+ 
+//============================================================================= 
+ 
+/** receives notification of sax document events from a
+	<type>XFastParser</type>
+ */
+interface XFastDocumentHandler: XFastContextHandler
+{ 
+	//------------------------------------------------------------------------- 
+	 
+	/** called by the parser when parsing of an xml stream is started.
+	 */
+	void startDocument() 
+			raises( com::sun::star::xml::sax::SAXException ); 
+ 
+	//------------------------------------------------------------------------- 
+	 
+	/** called by the parser after the last xml element of a stream is processed.
+	 */
+	void endDocument() 
+			raises( com::sun::star::xml::sax::SAXException ); 
+
+	//------------------------------------------------------------------------- 
+	 
+	/** receives an object for locating the origin of SAX document events.
+	 */
+	void setDocumentLocator( [in] com::sun::star::xml::sax::XLocator xLocator ) 
+			raises( com::sun::star::xml::sax::SAXException ); 
+ 
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; }; };  
+ 
+#endif 
Index: unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastParser.idl
===================================================================
RCS file: unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastParser.idl
diff -N unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastParser.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastParser.idl	31 May 2007 10:14:58 -0000	1.1.2.1
@@ -0,0 +1,204 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_xml_sax_XFastParser_idl__ 
+#define __com_sun_star_xml_sax_XFastParser_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_xml_sax_InputSource_idl__ 
+#include <com/sun/star/xml/sax/InputSource.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_xml_sax_SAXException_idl__ 
+#include <com/sun/star/xml/sax/SAXException.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_io_IOException_idl__ 
+#include <com/sun/star/io/IOException.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_xml_sax_XFastDocumentHandler_idl__ 
+#include <com/sun/star/xml/sax/XFastDocumentHandler.idl> 
+#endif 
+
+#ifndef __com_sun_star_xml_sax_XFastTokenHandler_idl__ 
+#include <com/sun/star/xml/sax/XFastTokenHandler.idl> 
+#endif 
+
+#ifndef __com_sun_star_xml_sax_XErrorHandler_idl__ 
+#include <com/sun/star/xml/sax/XErrorHandler.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_xml_sax_XDTDHandler_idl__ 
+#include <com/sun/star/xml/sax/XDTDHandler.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_xml_sax_XEntityResolver_idl__ 
+#include <com/sun/star/xml/sax/XEntityResolver.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_lang_Locale_idl__ 
+#include <com/sun/star/lang/Locale.idl> 
+#endif 
+ 
+#ifndef __com_sun_star_lang_IllegalArgumentException_idl__ 
+#include <com/sun/star/lang/IllegalArgumentException.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module xml {  module sax {  
+ 
+//============================================================================= 
+ 
+/** specifies a SAX parser that uses integer values for known xml names
+	(elements, attributes and attribute values). The parser also handles
+	namespaces and allows to have individual contexts for each xml element.
+
+	<p>Before parsing is possible you have to set your
+	<type>XFastDocumentHandler</type> using <member>setFastDocumentHandler</member>.
+	
+	<p>Parsing starts with calling <member>parseStream</member>. If the parser
+	finds a valid xml file with the given <type>InputSource</type>, it calls
+	<member>XFastDocumentHandler::startDocument</member> first.
+
+	<p>This parser generates either 'fast' events that use integer token
+	values for namespaces, elements and attributes or 'unknown' events for
+	elements that are unknown.
+
+	<p>A namespace is unknown if the namespace URL was not registered with
+	<member>registerNamespace</member>.
+
+	<p>An element is unknown if no <type>XFastTokenHandler</type> is set
+	or if the <type>XFastTokenHandler</type> does not return a valid
+	identifier for the elements local name. An element is also unknown if
+	the elements local name is known but it uses a namespace that is unknown.
+
+	<p>Setting a <type>XFastTokenHandler</type> with <member>setTokenHandler</member>
+	is optional, but without a <type>XFastTokenHandler</type> you will only
+	get unknown sax events. This can be usefull if you are only interested
+	in the namespace handling and/or the context feature.
+
+	<p>For each element the parser sends a create child element event to the
+	elements parent context by calling 
+	<member>XFastContextHandler::createFastChildContext</member> for known
+	elements or <member>XFastContextHandler::createUnknownChildContext</member>
+	for unknown elements.
+	<br>The parent context for the root element is the <type>XFastDocumentHandler</type>
+	itself.
+	
+	<p>If the parent context returns an empty reference, no further events for
+	the element and all of its childs are created.
+
+	<p>If a valid context is returned this context gets a start event by a call to
+	<member>XFastContextHandler::startFastElement</member> for known elements or
+	<member>XFastContextHandler::startUnknownElement</member> for unknown elements.
+
+	<p>After processing all its child elements the context gets an end event by a call to
+	<member>XFastContextHandler::endFastElement</member> for known elements or
+	<member>XFastContextHandler::endUnknownElement</member> for unknown elements.
+
+	<p>It is valid to return one instance of <type>XFastContextHandler</type> more
+	than once. It is even possible to only use the <type>XFastDocumentHandler</type>
+	by always returning a reference to itself for each create child context event.
+
+	<p>After the last element is processed the parser generates an end document
+	event at the <type>XFastDocumentHandler</type> by calling
+	<member>XFastDocumentHandler::endDocument</member>.
+
+	@see http://wiki.services.openoffice.org/wiki/FastParser
+*/
+interface XFastParser: com::sun::star::uno::XInterface
+{ 
+	//------------------------------------------------------------------------- 
+	/** parses an XML document from a stream. 
+		
+		<p>Set the desired handlers before calling this method.</p>
+	 */
+	void parseStream( [in] InputSource aInputSource ) 
+			raises( SAXException, com::sun::star::io::IOException ); 
+ 
+	//------------------------------------------------------------------------- 
+	
+	/** Application must register a document event handler to get
+		sax events for the parsed stream.
+	 */
+	void setFastDocumentHandler( [in] XFastDocumentHandler Handler ); 
+
+	//------------------------------------------------------------------------- 
+	
+	/** must be registered to translate known xml names to integer tokens.
+	 */
+	void setTokenHandler( [in] XFastTokenHandler Handler ); 
+
+	//------------------------------------------------------------------------- 
+
+	/** registers a known namespace url with the given integer token.<br>
+		@param NamespaceToken
+			an integer token that must be greater than FastToken::NAMESPACE.
+	 */
+	void registerNamespace( [in] string NamespaceURL, [in] long NamespaceToken )
+		raises( com::sun::star::lang::IllegalArgumentException ); 
+
+	//------------------------------------------------------------------------- 
+	/** allows an application to register an error event handler. 
+		
+		<p>Note that the error handler can throw an exception when an error or 
+		warning occurs.  Note that an exception is thrown by the parser when 
+		an unrecoverable (fatal) error occurs.</p>
+	 */
+	void setErrorHandler( [in] XErrorHandler Handler ); 
+ 
+	//------------------------------------------------------------------------- 
+	/** allows an application to register a DTD-Handler.
+	 */
+	void setEntityResolver( [in] XEntityResolver Resolver ); 
+ 
+	//------------------------------------------------------------------------- 
+	/** sets a locale specified for localization of warnings and error messages.
+		
+		<p>Set the language of the error messages. Useful when the parsing 
+		errors will be presented to the user.</p>
+	 */
+	void setLocale( [in] com::sun::star::lang::Locale locale ); 
+}; 
+ 
+//============================================================================= 
+ 
+}; }; }; }; };  
+ 
+#endif 
Index: unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastTokenHandler.idl
===================================================================
RCS file: unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastTokenHandler.idl
diff -N unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastTokenHandler.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ unoxml/source/fastsax/api/com/sun/star/xml/sax/XFastTokenHandler.idl	31 May 2007 10:15:07 -0000	1.1.2.1
@@ -0,0 +1,94 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_xml_sax_XFastTokenHandler_idl__ 
+#define __com_sun_star_xml_sax_XFastTokenHandler_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module xml {  module sax {  
+ 
+//============================================================================ 
+ 
+/** interface to translate xml strings to integer tokens.
+
+	<p>An instance of this interface can be registered at a <type>XFastParser</type>.
+	It should be able to translate all xml names (element local names,
+	attribute local names and constant attribute values) to integer tokens.
+
+	A token value must be greater or equal to zero and less than 
+	<const>FastToken::NAMESPACE</const>. If a string identifier is not known
+	to this instance, <const>FastToken::DONTKNOW</const> is returned.
+ */
+interface XFastTokenHandler: com::sun::star::uno::XInterface
+{ 
+	//------------------------------------------------------------------------- 
+
+	/**	returns a integer token for the given string identifier.
+
+		@returns
+			a unique integer token for the given String or <const>FastToken::DONTKNOW</const
+			if the identifier is not known to this instance.
+	*/
+	long getToken( [in] string Identifier );
+
+	//------------------------------------------------------------------------- 
+
+	/** returns a string identifier for the given integer token.
+	*/
+	string getIdentifier( [in] long Token );
+
+	//------------------------------------------------------------------------- 
+
+	/** returns a integer token for the given string
+
+		@param Identifier
+			the string given as a byte sequence encoded in UTF8
+
+		@returns
+			a unique integer token for the given String or <const>FastToken::DONTKNOW</const>
+			if the identifier is not known to this instance.
+	*/
+	long getTokenFromUTF8( [in] sequence< byte > Identifier );
+}; 
+
+//============================================================================ 
+
+}; }; }; }; };  
+ 
+#endif 
Index: unoxml/source/service/makefile.mk
===================================================================
RCS file: /cvs/framework/unoxml/source/service/makefile.mk,v
retrieving revision 1.6
retrieving revision 1.6.44.1
diff -u -p -u -p -r1.6 -r1.6.44.1
--- unoxml/source/service/makefile.mk	9 Sep 2005 10:07:17 -0000	1.6
+++ unoxml/source/service/makefile.mk	31 May 2007 10:11:05 -0000	1.6.44.1
@@ -68,7 +68,8 @@ DEF1NAME=$(SHL1TARGET)
 SHL1LIBS= \
     $(SLB)$/domimpl.lib \
     $(SLB)$/xpathimpl.lib \
-    $(SLB)$/eventsimpl.lib
+    $(SLB)$/eventsimpl.lib \
+    $(SLB)$/fastsax.lib
 
 SHL1STDLIBS= \
     $(XML2LIB) \
@@ -76,7 +77,8 @@ SHL1STDLIBS= \
 	$(COMPHELPERLIB)	\
 	$(CPPUHELPERLIB)	\
 	$(CPPULIB)	\
-	$(SALLIB)
+	$(SALLIB)\
+	$(EXPATASCII3RDLIB)
 
 # --- Targets ------------------------------------------------------
 
Index: unoxml/source/service/services.cxx
===================================================================
RCS file: /cvs/framework/unoxml/source/service/services.cxx,v
retrieving revision 1.6
retrieving revision 1.6.24.1
diff -u -p -u -p -r1.6 -r1.6.24.1
--- unoxml/source/service/services.cxx	20 Jun 2006 00:49:41 -0000	1.6
+++ unoxml/source/service/services.cxx	31 May 2007 10:11:05 -0000	1.6.24.1
@@ -51,16 +51,24 @@
 #include "../xpath/xpathapi.hxx"
 #include "../events/testlistener.hxx"
 
-extern "C"
-{
 using namespace ::DOM;
 using namespace ::DOM::events;
 using namespace ::XPath;
-using namespace ::rtl;
+using ::rtl::OUString;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::registry;
 
+namespace sax_fastparser
+{
+extern Reference< XInterface > SAL_CALL FastSaxParser_CreateInstance( const Reference< XMultiServiceFactory  >  & ) throw(Exception);
+extern Sequence< OUString > FastSaxParser_getSupportedServiceNames();
+extern OUString FastSaxParser_getImplementationName();
+}
+
+extern "C"
+{
+
 void SAL_CALL
 component_getImplementationEnvironment(const sal_Char **ppEnvironmentTypeName, uno_Environment ** /*ppEnvironment */)
 {
@@ -102,6 +110,13 @@ component_writeInfo(void * /*pServiceMan
     xNewKey = xKey->createKey(aImpl);
 	xNewKey->createKey(CTestListener::_getSupportedServiceNames()[0]);
 
+    // register fast sax parser service
+    aImpl = OUString(RTL_CONSTASCII_USTRINGPARAM("/"));
+    aImpl += sax_fastparser::FastSaxParser_getImplementationName();
+    aImpl += ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("/UNO/SERVICES"));
+    xNewKey = xKey->createKey(aImpl);
+	xNewKey->createKey(sax_fastparser::FastSaxParser_getSupportedServiceNames()[0]);
+
 
 	return sal_True;
 }
@@ -145,6 +160,13 @@ component_getFactory(const sal_Char *pIm
 					xServiceManager, CTestListener::_getImplementationName(),
 					CTestListener::_getInstance, CTestListener::_getSupportedServiceNames()));
 		}
+        else if (sax_fastparser::FastSaxParser_getImplementationName().compareToAscii( pImplementationName ) == 0 )
+		{
+			xFactory = Reference< XSingleServiceFactory >(
+				cppu::createSingleFactory(
+					xServiceManager, sax_fastparser::FastSaxParser_getImplementationName(),
+					sax_fastparser::FastSaxParser_CreateInstance, sax_fastparser::FastSaxParser_getSupportedServiceNames()));
+		}
 
 		// Factory is valid - service was found.
 		if ( xFactory.is() )
Index: sw/source/ui/app/docsh2.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/app/docsh2.cxx,v
retrieving revision 1.91
retrieving revision 1.90.14.2
diff -u -p -u -p -r1.91 -r1.90.14.2
--- sw/source/ui/app/docsh2.cxx	10 May 2007 16:13:26 -0000	1.91
+++ sw/source/ui/app/docsh2.cxx	30 May 2007 13:04:27 -0000	1.90.14.2
@@ -278,7 +278,7 @@ using namespace com::sun::star::ui::dial
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star;
-using namespace ::rtl;
+using ::rtl::OUString;
 using namespace ::sfx2;
 
 extern FASTBOOL FindPhyStyle( SwDoc& , const String& , SfxStyleFamily );
Index: sw/source/ui/uiview/view.cxx
===================================================================
RCS file: /cvs/sw/sw/source/ui/uiview/view.cxx,v
retrieving revision 1.101
retrieving revision 1.100.36.2
diff -u -p -u -p -r1.101 -r1.100.36.2
--- sw/source/ui/uiview/view.cxx	22 May 2007 16:40:02 -0000	1.101
+++ sw/source/ui/uiview/view.cxx	30 May 2007 13:17:43 -0000	1.100.36.2
@@ -267,7 +267,8 @@ using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::lang;
 using namespace ::com::sun::star::scanner;
-using namespace ::rtl;
+using ::rtl::OUString;
+using ::rtl::OUStringBuffer;
 
 #define C2U(cChar) OUString::createFromAscii(cChar)
 #define C2S(cChar) String::CreateFromAscii(cChar)
