--- config_office/configure.in.before	2008-04-28 10:31:26.000000000 +0200
+++ config_office/configure.in	2008-04-28 10:32:01.000000000 +0200
@@ -274,6 +274,9 @@
 AC_ARG_ENABLE(xrender-link,
 [  --enable-xrender-link   link with libXrender instead of dynamically open it
 ],,)
+AC_ARG_ENABLE(randr,
+[  --disable-randr          disable RandR support in the vcl project
+],,enable_randr=yes)
 AC_ARG_WITH(myspell-dicts,
 [  --without-myspell-dicts Removes myspell dictionaries from openoffice.org
                           installation set, for people building for specific
@@ -838,6 +841,7 @@
 		build_gstreamer=yes
 		test_kde=yes
 		test_cups=yes
+        test_randr=yes
 		_os=SunOS
 
 		dnl ===========================================================
@@ -865,6 +869,7 @@
 		build_gstreamer=yes
 		test_kde=yes
 		test_cups=yes
+        test_randr=yes
 		if getconf GNU_LIBPTHREAD_VERSION |grep -q NPTL; then
 			PTHREAD_CFLAGS="-DNPTL"
 		fi
@@ -884,6 +889,7 @@
 		test_gtk=yes
 		build_cairo=no
 		build_gstreamer=no
+        test_randr=no
 		_os=Darwin
       if test "$enable_systray" = "yes" && test "$enable_gtk" != "no"; then
          AC_MSG_WARN([Disabling gtk-quickstarter - not supported on Mac. Use --disable-systray])
@@ -894,6 +900,7 @@
 	os2*)
 		test_x=no
 		test_cups=no
+        test_randr=no
 		test_gtk=no
 		_os=OS2
 		;;
@@ -903,6 +910,7 @@
 		build_gstreamer=yes
 		test_kde=yes
 		test_cups=yes
+        test_randr=yes
 		AC_MSG_CHECKING([the FreeBSD operating system release])
 		if test -n "$with_os_version"; then
 			OSVERSION="$with_os_version"
@@ -926,6 +934,7 @@
 		;;
 	osf)
 		test_cups=no
+        test_randr=no
 		_os=OSF1
 		;;
 	netbsd)
@@ -934,16 +943,19 @@
 		build_gstreamer=yes
 		test_kde=yes
 		test_cups=no
+        test_randr=yes
 		PTHREAD_CFLAGS="-pthread"
 		PTHREAD_LIBS="-pthread -lpthread"
 		_os=NetBSD
 		;;
 	irix*)
 		test_cups=no
+        test_randr=no
 		_os=IRIX
 		;;
 	aix*)
 		test_cups=no
+        test_randr=no
 	   PTHREAD_LIBS=-pthread
 		echo "AIX is an alpha port --- Use at own risk" >> warn
 		_os=AIX
@@ -1123,6 +1135,19 @@
 AC_SUBST(ENABLE_FONTCONFIG)
 
 dnl ===================================================================
+dnl Build options
+dnl ===================================================================
+AC_MSG_CHECKING([whether to enable RandR support])
+if test "$test_randr" = "yes" -a \( "$enable_randr" = "yes" -o "$enable_randr" = "TRUE" \) ; then
+   ENABLE_RANDR="TRUE"
+   AC_MSG_RESULT([yes])
+else
+   ENABLE_RANDR=""
+   AC_MSG_RESULT([no])
+fi
+AC_SUBST(ENABLE_RANDR)
+
+dnl ===================================================================
 dnl Disable legacy binary file formats filters
 dnl ===================================================================
 AC_MSG_CHECKING([whether to enable filters for legacy binary file formats (StarOffice 5.2)])
@@ -1915,7 +1940,15 @@
 fi
 
 dnl ===================================================================
+dnl Check if X11/extensions/Xrandr.h is available 
+dnl ===================================================================
+if test "$test_randr" = "yes" -a "$ENABLE_RANDR" = "TRUE" ; then
+    AC_CHECK_HEADER(X11/extensions/Xrandr.h, [],
+                    [AC_MSG_ERROR([X11/extensions/Xrandr.h could not be found. X11 dev missing?])], [])
+fi
+
+dnl ===================================================================
 dnl Check if PAM/pam_appl.h is available on Linux or FreeBSD
 dnl ===================================================================
 if test "$_os" = "Linux" -o "$_os" = "FreeBSD" -o "$_os" = "GNU"; then

--- vcl/unx/gtk/app/gtkdata.cxx	29 Jan 2008 16:20:56 -0000	1.36
+++ vcl/unx/gtk/app/gtkdata.cxx	7 Mar 2008 16:59:00 -0000	1.36.16.1
@@ -191,6 +191,7 @@ GdkFilterReturn GtkSalDisplay::filterGdk
             }
         }
         X11SalObject::Dispatch( pEvent );
+        pDisplay->processRandREvent( pEvent );
     }
 
     return aFilterReturn;
--- vcl/unx/inc/saldisp.hxx	27 Feb 2008 10:32:35 -0000	1.44
+++ vcl/unx/inc/saldisp.hxx	12 Mar 2008 09:39:09 -0000	1.43.16.2
@@ -418,6 +418,9 @@ protected:	
     void			DestroyFontCache();
     virtual long	Dispatch( XEvent *pEvent ) = 0;
     void			InitXinerama();
+    void            InitRandR( XLIB_Window aRoot ) const;
+    void            DeInitRandR();
+    int             processRandREvent( XEvent* );
 
     void			doDestruct();
 public:
--- vcl/unx/source/app/makefile.mk	7 Mar 2008 17:12:23 -0000	1.30
+++ vcl/unx/source/app/makefile.mk	1 Apr 2008 10:31:13 -0000	1.29.16.3
@@ -64,6 +64,7 @@ SLOFILES=\
 			$(SLO)$/saldata.obj			\
 			$(SLO)$/saltimer.obj		\
 			$(SLO)$/saldisp.obj			\
+			$(SLO)$/randrwrapper.obj	\
 			$(SLO)$/salinst.obj			\
 			$(SLO)$/salsys.obj			\
 			$(SLO)$/soicon.obj			\
@@ -81,6 +82,12 @@ EXCEPTIONSFILES=\
             $(SLO)$/salsys.obj
 
 
+.IF "$(ENABLE_RANDR)" != ""
+.IF "$(OS)" != "SOLARIS"
+CDEFS+=-DUSE_RANDR
+.ENDIF
+.ENDIF
+
 .IF "$(USE_XINERAMA)" != "NO"
 CDEFS+=-DUSE_XINERAMA
 .IF "$(USE_XINERAMA_VERSION)" == "Xorg"
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/source/app/randrwrapper.cxx	15 Mar 2008 14:29:42 -0000	1.1.2.2
@@ -0,0 +1,250 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifdef USE_RANDR
+
+#include "prex.h"
+#include <X11/extensions/Xrandr.h>
+#include "postx.h"
+
+#include "osl/module.h"
+#include "rtl/ustring.hxx"
+
+namespace
+{
+class RandRWrapper
+{
+    oslModule m_pRandRLib;
+    
+    // function pointers
+    Bool(*m_pXRRQueryExtension)(Display*,int*,int*);
+    Status(*m_pXRRQueryVersion)(Display*,int*,int*);
+    XRRScreenConfiguration*(*m_pXRRGetScreenInfo)(Display*,Drawable);
+    void(*m_pXRRFreeScreenConfigInfo)(XRRScreenConfiguration*);
+    void(*m_pXRRSelectInput)(Display*,XLIB_Window,int);
+    int(*m_pXRRUpdateConfiguration)(XEvent*);
+    XRRScreenSize*(*m_pXRRSizes)(Display*,int,int*);
+    XRRScreenSize*(*m_pXRRConfigSizes)(XRRScreenConfiguration*,int*);
+    SizeID(*m_pXRRConfigCurrentConfiguration)(XRRScreenConfiguration*,Rotation*);
+    
+    bool m_bValid;
+    
+    void initFromModule();
+    
+    RandRWrapper(Display*);
+    ~RandRWrapper();
+public:
+    static RandRWrapper& get(Display*);
+    static void releaseWrapper();
+    
+    Bool XRRQueryExtension(Display* i_pDisp, int* o_event_base, int* o_error_base )
+    {
+        Bool bRet = False;
+        if( m_bValid )
+            bRet = m_pXRRQueryExtension( i_pDisp, o_event_base, o_error_base );
+        return bRet;
+    }
+    Status XRRQueryVersion( Display* i_pDisp, int* o_major, int* o_minor )
+    {
+        return m_bValid ? m_pXRRQueryVersion( i_pDisp, o_major, o_minor ) : 0;
+    }
+    XRRScreenConfiguration* XRRGetScreenInfo( Display* i_pDisp, Drawable i_aDrawable )
+    {
+        return m_bValid ? m_pXRRGetScreenInfo( i_pDisp, i_aDrawable ) : NULL;
+    }
+    void XRRFreeScreenConfigInfo( XRRScreenConfiguration* i_pConfig )
+    {
+        if( m_bValid )
+            m_pXRRFreeScreenConfigInfo( i_pConfig );
+    }
+    void XRRSelectInput( Display* i_pDisp, XLIB_Window i_window, int i_nMask )
+    {
+        if( m_bValid )
+            m_pXRRSelectInput( i_pDisp, i_window, i_nMask );
+    }
+    int XRRUpdateConfiguration( XEvent* i_pEvent )
+    {
+        return m_bValid ? m_pXRRUpdateConfiguration( i_pEvent ) : 0;
+    }
+    XRRScreenSize* XRRSizes( Display* i_pDisp, int i_screen, int* o_nscreens )
+    {
+        return m_bValid ? m_pXRRSizes( i_pDisp, i_screen, o_nscreens ) : NULL;
+    }
+    XRRScreenSize* XRRConfigSizes( XRRScreenConfiguration* i_pConfig, int* o_nSizes )
+    {
+        return m_bValid ? m_pXRRConfigSizes( i_pConfig, o_nSizes ) : NULL;
+    }
+    SizeID XRRConfigCurrentConfiguration( XRRScreenConfiguration* i_pConfig, Rotation* o_pRot )
+    {
+        return m_bValid ? m_pXRRConfigCurrentConfiguration( i_pConfig, o_pRot ) : 0;
+    }
+};
+}
+
+void RandRWrapper::initFromModule()
+{
+    m_pXRRQueryExtension = (Bool(*)(Display*,int*,int*))osl_getAsciiFunctionSymbol( m_pRandRLib, "XRRQueryExtension" );
+    m_pXRRQueryVersion = (Status(*)(Display*,int*,int*))osl_getAsciiFunctionSymbol( m_pRandRLib, "XRRQueryVersion" );
+    m_pXRRGetScreenInfo = (XRRScreenConfiguration*(*)(Display*,Drawable))osl_getAsciiFunctionSymbol( m_pRandRLib, "XRRGetScreenInfo" );
+    m_pXRRFreeScreenConfigInfo = (void(*)(XRRScreenConfiguration*))osl_getAsciiFunctionSymbol( m_pRandRLib, "XRRFreeScreenConfigInfo" );
+    m_pXRRSelectInput = (void(*)(Display*,XLIB_Window,int))osl_getAsciiFunctionSymbol( m_pRandRLib, "XRRSelectInput" );
+    m_pXRRUpdateConfiguration = (int(*)(XEvent*))osl_getAsciiFunctionSymbol( m_pRandRLib, "XRRUpdateConfiguration" );
+    m_pXRRSizes = (XRRScreenSize*(*)(Display*,int,int*))osl_getAsciiFunctionSymbol( m_pRandRLib, "XRRSizes" );
+    m_pXRRConfigSizes = (XRRScreenSize*(*)(XRRScreenConfiguration*,int*))osl_getAsciiFunctionSymbol( m_pRandRLib, "XRRConfigSizes" );
+    m_pXRRConfigCurrentConfiguration = (SizeID(*)(XRRScreenConfiguration*,Rotation*))osl_getAsciiFunctionSymbol( m_pRandRLib, "XRRConfigCurrentConfiguration" );
+    
+    m_bValid = m_pXRRQueryExtension             &&
+               m_pXRRQueryVersion               &&
+               m_pXRRGetScreenInfo              &&
+               m_pXRRFreeScreenConfigInfo       &&
+               m_pXRRSelectInput                &&
+               m_pXRRUpdateConfiguration        &&
+               m_pXRRSizes                      &&
+               m_pXRRConfigSizes                &&
+               m_pXRRConfigCurrentConfiguration
+               ;
+}
+
+RandRWrapper::RandRWrapper( Display* pDisplay ) :
+        m_pRandRLib( NULL ),
+        m_pXRRQueryExtension( NULL ),
+        m_pXRRQueryVersion( NULL ),
+        m_pXRRGetScreenInfo( NULL ),
+        m_pXRRFreeScreenConfigInfo( NULL ),
+        m_pXRRSelectInput( NULL ),
+        m_pXRRUpdateConfiguration( NULL ),
+        m_pXRRSizes( NULL ),
+        m_pXRRConfigSizes( NULL ),
+        m_pXRRConfigCurrentConfiguration( NULL ),
+        m_bValid( false )
+{
+    // first try in process space (e.g. gtk links that ?)
+    initFromModule();
+    if( ! m_bValid )
+    {
+        rtl::OUString aLibName( RTL_CONSTASCII_USTRINGPARAM( "libXrandr.so.2" ) );
+        m_pRandRLib = osl_loadModule( aLibName.pData, SAL_LOADMODULE_DEFAULT );
+        initFromModule();
+    }
+    if( m_bValid )
+    {
+        int nEventBase = 0, nErrorBase = 0;
+        if( ! m_pXRRQueryExtension( pDisplay, &nEventBase, &nErrorBase ) )
+            m_bValid = false;
+    }
+}
+
+RandRWrapper::~RandRWrapper()
+{
+    if( m_pRandRLib )
+        osl_unloadModule( m_pRandRLib );
+}
+
+static RandRWrapper* pWrapper = NULL;
+
+RandRWrapper& RandRWrapper::get( Display* i_pDisplay )
+{
+    if( ! pWrapper )
+        pWrapper = new RandRWrapper( i_pDisplay );
+    return *pWrapper;
+}
+
+void RandRWrapper::releaseWrapper()
+{
+    delete pWrapper;
+    pWrapper = NULL;
+}
+
+#endif
+
+#include "saldisp.hxx"
+
+void SalDisplay::InitRandR( XLIB_Window aRoot ) const
+{
+    #ifdef USE_RANDR
+    RandRWrapper::get( GetDisplay() ).XRRSelectInput( GetDisplay(), aRoot, RRScreenChangeNotifyMask );
+    #else
+    (void)aRoot;
+    #endif
+}
+
+void SalDisplay::DeInitRandR()
+{
+    #ifdef USE_RANDR
+    RandRWrapper::releaseWrapper();
+    #endif
+}
+
+int SalDisplay::processRandREvent( XEvent* pEvent )
+{
+    int nRet = 0;
+    #ifdef USE_RANDR
+    if( pWrapper )
+    {
+        nRet = pWrapper->XRRUpdateConfiguration( pEvent );
+        if( nRet == 1 && pEvent->type != ConfigureNotify) // this should then be a XRRScreenChangeNotifyEvent
+        {
+            // update screens
+            for( size_t i = 0; i < m_aScreens.size(); i++ )
+            {
+                if( m_aScreens[i].m_bInit )
+                {
+                    XRRScreenConfiguration *pConfig = NULL;
+                    XRRScreenSize *pSizes = NULL;
+                    int nSizes = 0;
+                    Rotation nRot = 0;
+                    SizeID nId = 0;
+                
+                    pConfig = pWrapper->XRRGetScreenInfo( GetDisplay(), m_aScreens[i].m_aRoot );
+                    nId = pWrapper->XRRConfigCurrentConfiguration( pConfig, &nRot );
+                    pSizes = pWrapper->XRRConfigSizes( pConfig, &nSizes );
+                    XRRScreenSize *pTargetSize = pSizes + nId;
+                
+                    m_aScreens[i].m_aSize = Size( pTargetSize->width, pTargetSize->height );
+    
+                    pWrapper->XRRFreeScreenConfigInfo( pConfig );
+
+                    #if OSL_DEBUG_LEVEL > 1
+                    fprintf( stderr, "screen %d changed to size %dx%d\n", i, pTargetSize->width, pTargetSize->height );
+                    #endif
+                }
+            }
+        }
+    }
+    #else
+    (void)pEvent;
+    #endif
+    return nRet;
+}
--- vcl/unx/source/app/saldisp.cxx	29 Jan 2008 16:22:34 -0000	1.93
+++ vcl/unx/source/app/saldisp.cxx	31 Mar 2008 16:44:44 -0000	1.93.16.2
@@ -70,7 +70,7 @@
 
 #ifdef USE_XINERAMA
 #ifdef USE_XINERAMA_XORG
-#if defined(X86) || defined(MACOSX)
+#if defined(X86) || defined(X86_64) || defined(MACOSX)
 #include <X11/extensions/Xinerama.h>
 #endif
 #elif defined USE_XINERAMA_XSUN
@@ -715,6 +715,9 @@ SalX11Display::~SalX11Display()
 		XCloseDisplay( pDisp_ );
 		pDisp_ = NULL;
 	}
+    // don't do this in doDestruct since RandR extension adds hooks into Display
+    // that is XCloseDisplay still needs the RandR library if it was used
+    DeInitRandR();
 }
 
 void SalDisplay::initScreen( int nScreen ) const
@@ -743,6 +746,9 @@ void SalDisplay::initScreen( int nScreen
     rSD.m_aRoot = RootWindow( pDisp_, nScreen );
     rSD.m_aVisual = SalVisual( &aVI );
     rSD.m_aColormap = SalColormap( this, aColMap, nScreen );
+    
+    // we're interested in configure notification of root windows
+    InitRandR( rSD.m_aRoot );
 
     // - - - - - - - - - - Reference Window/Default Drawable - -
     XSetWindowAttributes aXWAttributes;
@@ -2416,10 +2422,13 @@ long SalX11Display::Dispatch( XEvent *pE
 			return pFrame->Dispatch( pEvent );
 		}
     }
-
+    
 	// dispatch to salobjects
 	X11SalObject::Dispatch( pEvent );
 
+    // is this perhaps a root window that changed size ?
+    processRandREvent( pEvent );
+
     return 0;
 }
 
@@ -2688,7 +2833,7 @@ void SalDisplay::InitXinerama()
         }
     }
 #elif defined(USE_XINERAMA_XORG)
-#if defined( X86 ) || defined( MACOSX )
+#if defined(X86) || defined(X86_64) || defined(MACOSX)
 if( XineramaIsActive( pDisp_ ) )
 {
     int nFramebuffers = 1;
