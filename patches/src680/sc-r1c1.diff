Index: officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu
===================================================================
RCS file: /cvs/util/officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu,v
retrieving revision 1.14
diff -u -w -p -r1.14 CalcCommands.xcu
--- officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu	15 Mar 2005 12:42:05 -0000	1.14
+++ officecfg/registry/data/org/openoffice/Office/UI/CalcCommands.xcu	28 Nov 2005 19:35:06 -0000
@@ -1418,6 +1418,19 @@
 					<value xml:lang="en-US">R~ight-To-Left</value>
 				</prop>
 			</node>
+			<node oor:name=".uno:SheetUseR1C1" oor:op="replace">
+				<prop oor:name="Label" oor:type="xs:string">
+					<value xml:lang="en-US">Use R1~C1</value>
+					<value xml:lang="de">R1~C1 verwenden</value>
+					<value xml:lang="es">Usar R1~C1</value>
+					<value xml:lang="fr">Utiliser R1~C1</value>
+					<value xml:lang="it">Utilizza R1~C1</value>
+					<value xml:lang="ja">R1~C1を使用する</value>
+					<value xml:lang="pt-BR">Usar R1~C1</value>
+					<value xml:lang="zh-CN">使用 R1C1(~C)</value>
+					<value xml:lang="zh-TW">使用 R1C1(~C)</value>
+				</prop>
+			</node>
             <node oor:name=".uno:SetAnchorToPage" oor:op="replace">
                 <prop oor:name="Label" oor:type="xs:string">
                     <value xml:lang="de">An der Seite</value>
Index: sc/uiconfig/scalc/menubar/menubar.xml
===================================================================
RCS file: sc/uiconfig/scalc/menubar/menubar.xml,v
diff -cpr sc/uiconfig/scalc/menubar/menubar.xml sc/uiconfig/scalc/menubar/menubar.xml
*** sc/uiconfig/scalc/menubar/menubar.xml	Thu Aug 24 09:25:40 2006
--- sc/uiconfig/scalc/menubar/menubar.xml	Thu Aug 24 10:45:05 2006
***************
*** 213,218 ****
--- 213,219 ----
                      <menu:menuitem menu:id=".uno:Hide"/>
                      <menu:menuitem menu:id=".uno:Show"/>
                      <menu:menuitem menu:id=".uno:SheetRightToLeft"/>
+                     <menu:menuitem menu:id=".uno:SheetUseR1C1"/>
                  </menu:menupopup>
              </menu:menu>
              <menu:menu menu:id=".uno:MergeCellsMenu">
Index: sc/inc/sc.hrc
===================================================================
RCS file: /cvs/sc/inc/sc.hrc,v
diff -cpr sc/inc/sc.hrc sc/inc/sc.hrc
*** sc/inc/sc.hrc	Wed Aug 23 16:41:37 2006
--- sc/inc/sc.hrc	Thu Aug 24 10:45:04 2006
***************
*** 805,810 ****
--- 805,811 ----
  #define FID_TAB_APPEND			(TAB_POPUP_START+5)
  #define FID_TAB_INDEX			(TAB_POPUP_START+6)
  #define FID_TAB_RTL				(TAB_POPUP_START+7)
+ #define FID_TAB_USE_R1C1		(TAB_POPUP_START+8)
  
  #define TAB_POPUP_END			(DATA_MENU_END + 20)
  
Index: sc/inc/scfuncs.hrc
===================================================================
RCS file: /cvs/sc/inc/scfuncs.hrc,v
diff -cpr sc/inc/scfuncs.hrc sc/inc/scfuncs.hrc
*** sc/inc/scfuncs.hrc	Wed Aug 23 16:41:35 2006
--- sc/inc/scfuncs.hrc	Thu Aug 24 10:47:20 2006
***************
*** 300,305 ****
--- 300,307 ----
  #define HID_FUNC_TABELLEN			(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TABLE*ID_FUNCTION_OFFSET)+19)
  #define HID_FUNC_HYPERLINK			(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TABLE*ID_FUNCTION_OFFSET)+20)
  #define HID_FUNC_GETPIVOTDATA		(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TABLE*ID_FUNCTION_OFFSET)+21)
+ #define HID_FUNC_INDIREKT_XL			(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TABLE*ID_FUNCTION_OFFSET)+22)
+ #define HID_FUNC_ADRESSE_XL			(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TABLE*ID_FUNCTION_OFFSET)+23)
  
  #define HID_FUNC_CODE				(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TEXT*ID_FUNCTION_OFFSET)+1)
  #define HID_FUNC_DM					(HID_SC_FUNC_DUMMY+(ID_FUNCTION_GRP_TEXT*ID_FUNCTION_OFFSET)+2)
Index: sc/sdi/docsh.sdi
===================================================================
RCS file: /cvs/sc/sdi/docsh.sdi,v
diff -cpr sc/sdi/docsh.sdi sc/sdi/docsh.sdi
*** sc/sdi/docsh.sdi	Tue May  2 11:42:35 2006
--- sc/sdi/docsh.sdi	Thu Aug 24 10:45:04 2006
*************** interface TableSelection
*** 68,73 ****
--- 68,74 ----
  	FID_DELETE_TABLE	[ ExecMethod = ExecuteTable; StateMethod = GetStateTable; ]
  	FID_TAB_RENAME		[ ExecMethod = ExecuteTable; StateMethod = GetStateTable; ]
  	FID_TAB_RTL			[ ExecMethod = ExecuteTable; StateMethod = GetStateTable; ]
+ 	FID_TAB_USE_R1C1	[ ExecMethod = ExecuteTable; StateMethod = GetStateTable; ]
  
  	SID_TABLE_ACTIVATE	[ ExecMethod = Execute; ]
  }
Index: sc/sdi/scalc.sdi
===================================================================
RCS file: /cvs/sc/sdi/scalc.sdi,v
diff -cpr sc/sdi/scalc.sdi sc/sdi/scalc.sdi
*** sc/sdi/scalc.sdi	Wed Aug 23 16:41:36 2006
--- sc/sdi/scalc.sdi	Thu Aug 24 10:45:04 2006
*************** SfxBoolItem SheetRightToLeft FID_TAB_RTL
*** 7754,7756 ****
--- 7754,7783 ----
  ]
  
  
+ //--------------------------------------------------------------------------
+ SfxBoolItem SheetUseR1C1	FID_TAB_USE_R1C1
+ 
+ [
+ 	/* flags */
+ 	AutoUpdate	= FALSE,
+ 	Cachable = Cachable,
+ 	FastCall = FALSE,
+ 	HasCoreId = FALSE,
+ 	HasDialog = FALSE,
+ 	ReadOnlyDoc = TRUE,
+ 	Toggle = FALSE,
+ 	Container = FALSE,
+ 	RecordAbsolute = FALSE,
+ 	RecordPerSet;
+ 	Synchron;
+ 
+ 	Readonly = FALSE,
+ 
+ 	/* config */
+ 	AccelConfig = TRUE,
+ 	MenuConfig = TRUE,
+ 	StatusBarConfig = FALSE,
+ 	ToolBoxConfig = TRUE,
+ 	GroupId = GID_FORMAT;
+ ]
+ 
Index: sc/source/filter/excel/excform.cxx
===================================================================
RCS file: /cvs/sc/source/filter/excel/excform.cxx,v
diff -cpr sc/source/filter/excel/excform.cxx sc/source/filter/excel/excform.cxx
*** sc/source/filter/excel/excform.cxx	Wed Aug 23 16:33:09 2006
--- sc/source/filter/excel/excform.cxx	Thu Aug 24 10:45:05 2006
*************** void ExcelToSc::DoMulArgs( DefTokenId eI
*** 1372,1383 ****
  		if( eId == ocPercentrank && nAnz == 3 )
  			nSkipEnd = 0;		// letzten Parameter bei Bedarf weglassen
  
- 		else if( eId == ocIndirect && nAnz == 2 )
- 			nSkipEnd = 0;
- 
- 		else if( eId == ocAdress && nAnz > 3 )
- 			nNull = nAnz - 4;
- 
  		// Joost-Spezialfaelle
  		else if( eId == ocIf )
  		{
--- 1372,1377 ----
Index: sc/source/filter/excel/xlformula.cxx
===================================================================
RCS file: /cvs/sc/source/filter/excel/xlformula.cxx,v
diff -cpr sc/source/filter/excel/xlformula.cxx sc/source/filter/excel/xlformula.cxx
*** sc/source/filter/excel/xlformula.cxx	Wed Aug 23 16:41:36 2006
--- sc/source/filter/excel/xlformula.cxx	Thu Aug 24 10:45:05 2006
*************** static const XclFunctionInfo saFuncTable
*** 187,193 ****
      { ocLIA,                142,    3,  3,  V, { V } },
      { ocDIA,                143,    4,  4,  V, { V } },
      { ocGDA,                144,    4,  5,  V, { V } },
!     { ocIndirect,           148,    1,  2,  R, { V }, EXC_FUNCFLAG_VOLATILE },
      { ocClean,              162,    1,  1,  V, { V } },
      { ocMatDet,             163,    1,  1,  V, { A } },
      { ocMatInv,             164,    1,  1,  A, { A } },
--- 187,194 ----
      { ocLIA,                142,    3,  3,  V, { V } },
      { ocDIA,                143,    4,  4,  V, { V } },
      { ocGDA,                144,    4,  5,  V, { V } },
!     { ocIndirectXL,         148,    1,  2,  R, { V }, EXC_FUNCFLAG_VOLATILE },
!     { ocIndirect,           148,    1,  2,  R, { V }, EXC_FUNCFLAG_VOLATILE | EXC_FUNCFLAG_EXPORTONLY },
      { ocClean,              162,    1,  1,  V, { V } },
      { ocMatDet,             163,    1,  1,  V, { A } },
      { ocMatInv,             164,    1,  1,  A, { A } },
*************** static const XclFunctionInfo saFuncTable
*** 219,225 ****
      { ocRKP,                51,     1,  4,  A, { R, R, V, V } },    // BIFF2: 1-2, BIFF3: 1-4
      { ocGrowth,             52,     1,  4,  A, { R, R, R, V } },    // BIFF2: 1-3, BIFF3: 1-4
      { ocTrunc,              197,    1,  2,  V, { V } },             // BIFF2: 1,   BIFF3: 1-2
!     { ocAdress,             219,    2,  5,  V, { V, V, V, E, V } },
      { ocGetDiffDate360,     220,    2,  2,  V, { V, V, C, I } },
      { ocGetActDate,         221,    0,  0,  V, {}, EXC_FUNCFLAG_VOLATILE },
      { ocVBD,                222,    5,  7,  V, { V } },
--- 220,227 ----
      { ocRKP,                51,     1,  4,  A, { R, R, V, V } },    // BIFF2: 1-2, BIFF3: 1-4
      { ocGrowth,             52,     1,  4,  A, { R, R, R, V } },    // BIFF2: 1-3, BIFF3: 1-4
      { ocTrunc,              197,    1,  2,  V, { V } },             // BIFF2: 1,   BIFF3: 1-2
!     { ocAdressXL,           219,    2,  5,  V, { V, V, V, V, V } },
!     { ocAdress,             219,    2,  5,  V, { V, V, V, E, V }, EXC_FUNCFLAG_EXPORTONLY },
      { ocGetDiffDate360,     220,    2,  2,  V, { V, V, C, I } },
      { ocGetActDate,         221,    0,  0,  V, {}, EXC_FUNCFLAG_VOLATILE },
      { ocVBD,                222,    5,  7,  V, { V } },
Index: sc/source/filter/lotus/lotform.cxx
===================================================================
RCS file: /cvs/sc/source/filter/lotus/lotform.cxx,v
diff -cpr sc/source/filter/lotus/lotform.cxx sc/source/filter/lotus/lotform.cxx
*** sc/source/filter/lotus/lotform.cxx	Fri Jul 21 08:27:55 2006
--- sc/source/filter/lotus/lotform.cxx	Thu Aug 24 10:45:05 2006
*************** DefTokenId LotusToSc::IndexToToken( BYTE
*** 1056,1062 ****
  		ocTrue,				//  112 W()
  		ocExact,			//  113 Exact()
  		ocNoName,			//  114 Call()
! 		ocIndirect,			//  115 @@()
  		ocZins,				//  116 Rate()
  		ocNoName,			//  117 Term()
  		ocNoName,			//  118 Cterm()
--- 1056,1062 ----
  		ocTrue,				//  112 W()
  		ocExact,			//  113 Exact()
  		ocNoName,			//  114 Call()
! 		ocIndirectXL,		//  115 @@()
  		ocZins,				//  116 Rate()
  		ocNoName,			//  117 Term()
  		ocNoName,			//  118 Cterm()
*************** DefTokenId LotusToSc::IndexToTokenWK123(
*** 1587,1593 ****
  		ocNoName,			//  112 W()
  		ocExact,			//  113 Exact()
  		ocNoName,			//  114 Call()
! 		ocIndirect,			//  115 @@()
  		ocZins,				//  116 Rate()
  		ocNoName,			//  117 Term()
  		ocNoName,			//  118 Cterm()
--- 1587,1593 ----
  		ocNoName,			//  112 W()
  		ocExact,			//  113 Exact()
  		ocNoName,			//  114 Call()
! 		ocIndirectXL,		//  115 @@()
  		ocZins,				//  116 Rate()
  		ocNoName,			//  117 Term()
  		ocNoName,			//  118 Cterm()
Index: sc/inc/address.hxx
===================================================================
RCS file: /cvs/sc/inc/address.hxx,v
diff -cpr sc/inc/address.hxx sc/inc/address.hxx
*** sc/inc/address.hxx	Fri Apr  7 04:23:39 2006
--- sc/inc/address.hxx	Thu Aug 24 15:29:10 2006
*************** public:
*** 248,253 ****
--- 248,281 ----
  
      enum Uninitialized      { UNINITIALIZED };
      enum InitializeInvalid  { INITIALIZE_INVALID };
+     enum Convention	        {
+ 		CONV_UNSPECIFIED = -1,	/* useful when we want method to chose, must be first */
+ 
+ 		/* elements must be sequential and changes should be reflected in ScCompiler::pCharTables */
+ 		CONV_OOO	 =  0,	/* sheet.A1:sheet2.B2 */
+ 		CONV_XL_A1,			/* sheet:sheet2!A1:B2 */
+ 		CONV_XL_R1C1,		/* sheet:sheet2!R1C1:R2C2 */
+ 
+ 		CONV_LAST	/* for loops, must always be last */
+ 	};
+ 	struct Details {
+ 		Convention	eConv;
+ 		SCROW   	nRow;
+ 		SCCOL   	nCol;
+ 		inline Details( Convention eConvP, SCROW nRowP, SCCOL nColP )
+ 			: eConv( eConvP ), nRow( nRowP ), nCol( nColP )
+ 			{}
+ 		inline Details( Convention eConvP, ScAddress const & rAddr )
+ 			: eConv( eConvP ), nRow( rAddr.Row() ), nCol( rAddr.Col() )
+ 			{}
+ 		inline Details( Convention eConvP)
+ 			: eConv( eConvP ), nRow( 0 ), nCol( 0 )
+ 			{}
+ 		/* Use the convention associated with rAddr::Tab() */
+ 		Details( const ScDocument* pDoc, const ScAddress & rAddr );
+ 		void SetPos( const ScDocument* pDoc, const ScAddress & rAddr );
+ 	};
+ 	static const Details detailsOOOa1;
  
      inline ScAddress() : nRow(0), nCol(0), nTab(0) {}
      inline ScAddress( SCCOL nColP, SCROW nRowP, SCTAB nTabP )
*************** public:
*** 278,285 ****
      inline void IncTab( SCsTAB n=1 ) { nTab += n; }
      inline void GetVars( SCCOL& nColP, SCROW& nRowP, SCTAB& nTabP ) const
      { nColP = nCol; nRowP = nRow; nTabP = nTab; }
!     USHORT Parse( const String&, ScDocument* = NULL );
!     void Format( String&, USHORT = 0, ScDocument* = NULL ) const;
      // The document for the maximum defined sheet number
      bool Move( SCsCOL dx, SCsROW dy, SCsTAB dz, ScDocument* =NULL );
      inline bool operator==( const ScAddress& r ) const;
--- 306,317 ----
      inline void IncTab( SCsTAB n=1 ) { nTab += n; }
      inline void GetVars( SCCOL& nColP, SCROW& nRowP, SCTAB& nTabP ) const
      { nColP = nCol; nRowP = nRow; nTabP = nTab; }
! 
!     USHORT Parse( const String&, ScDocument* = NULL,
! 				  const Details& rDetails = detailsOOOa1);
!     void Format( String&, USHORT = 0, ScDocument* = NULL,
! 				 const Details& rDetails = detailsOOOa1) const;
! 
      // The document for the maximum defined sheet number
      bool Move( SCsCOL dx, SCsROW dy, SCsTAB dz, ScDocument* =NULL );
      inline bool operator==( const ScAddress& r ) const;
*************** public:
*** 292,299 ****
      // moved from ScTripel
      /// "(1,2,3)"
      String GetText() const;
!     /// "A1" or "$A$1"
!     String GetColRowString( bool bAbsolute = FALSE ) const;
  };
  
  inline void ScAddress::PutInOrder( ScAddress& r )
--- 324,332 ----
      // moved from ScTripel
      /// "(1,2,3)"
      String GetText() const;
!     /// "A1" or "$A$1" or R1C1 or R[1]C[1]
!     String GetColRowString( bool bAbsolute = FALSE,
! 							const Details& rDetails = detailsOOOa1) const;
  };
  
  inline void ScAddress::PutInOrder( ScAddress& r )
*************** public:
*** 402,412 ****
      inline bool IsValid() const { return aStart.IsValid() && aEnd.IsValid(); }
      inline bool In( const ScAddress& ) const;   // is Address& in Range?
      inline bool In( const ScRange& ) const;     // is Range& in Range?
!     USHORT Parse( const String&, ScDocument* = NULL );
!     USHORT ParseAny( const String&, ScDocument* = NULL );
      inline void GetVars( SCCOL& nCol1, SCROW& nRow1, SCTAB& nTab1,
          SCCOL& nCol2, SCROW& nRow2, SCTAB& nTab2 ) const;
-     void Format( String&, USHORT = 0, ScDocument* = NULL ) const;
      // The document for the maximum defined sheet number
      bool Move( SCsCOL dx, SCsROW dy, SCsTAB dz, ScDocument* =NULL );
      void Justify();
--- 435,454 ----
      inline bool IsValid() const { return aStart.IsValid() && aEnd.IsValid(); }
      inline bool In( const ScAddress& ) const;   // is Address& in Range?
      inline bool In( const ScRange& ) const;     // is Range& in Range?
! 
!     USHORT Parse( const String&, ScDocument* = NULL,
! 				  const ScAddress::Details& rDetails = ScAddress::detailsOOOa1 );
!     USHORT ParseAny( const String&, ScDocument* = NULL,
! 					 const ScAddress::Details& rDetails = ScAddress::detailsOOOa1 );
!     USHORT ParseCols( const String&, ScDocument* = NULL,
! 					 const ScAddress::Details& rDetails = ScAddress::detailsOOOa1 );
!     USHORT ParseRows( const String&, ScDocument* = NULL,
! 					 const ScAddress::Details& rDetails = ScAddress::detailsOOOa1 );
!     void Format( String&, USHORT = 0, ScDocument* = NULL,
! 				 const ScAddress::Details& rDetails = ScAddress::detailsOOOa1 ) const;
! 
      inline void GetVars( SCCOL& nCol1, SCROW& nRow1, SCTAB& nTab1,
          SCCOL& nCol2, SCROW& nRow2, SCTAB& nTab2 ) const;
      // The document for the maximum defined sheet number
      bool Move( SCsCOL dx, SCsROW dy, SCsTAB dz, ScDocument* =NULL );
      void Justify();
*************** public:
*** 563,569 ****
      inline  int     operator != ( const ScRefAddress& r ) const
                      { return !(operator==(r)); }
  
!             String  GetRefString( ScDocument* pDoc, SCTAB nActTab) const;
  };
  
  inline ScRefAddress& ScRefAddress::operator=( const ScRefAddress& rRef )
--- 605,612 ----
      inline  int     operator != ( const ScRefAddress& r ) const
                      { return !(operator==(r)); }
  
!             String  GetRefString( ScDocument* pDoc, SCTAB nActTab,
! 								  const ScAddress::Details& rDetails = ScAddress::detailsOOOa1) const;
  };
  
  inline ScRefAddress& ScRefAddress::operator=( const ScRefAddress& rRef )
*************** template< typename T > void PutInOrder( 
*** 620,630 ****
  }
  
  bool ConvertSingleRef( ScDocument* pDoc, const String& rRefString,
!         SCTAB nDefTab, ScRefAddress& rRefAddress);
  
  bool ConvertDoubleRef(ScDocument* pDoc, const String& rRefString,
          SCTAB nDefTab, ScRefAddress& rStartRefAddress,
!         ScRefAddress& rEndRefAddress);
  
  /// append alpha representation of column to buffer
  SC_DLLPUBLIC void ColToAlpha( rtl::OUStringBuffer& rBuffer, SCCOL nCol);
--- 663,675 ----
  }
  
  bool ConvertSingleRef( ScDocument* pDoc, const String& rRefString,
!         SCTAB nDefTab, ScRefAddress& rRefAddress,
! 		const ScAddress::Details& rDetails = ScAddress::detailsOOOa1);
  
  bool ConvertDoubleRef(ScDocument* pDoc, const String& rRefString,
          SCTAB nDefTab, ScRefAddress& rStartRefAddress,
!         ScRefAddress& rEndRefAddress,
! 		const ScAddress::Details& rDetails = ScAddress::detailsOOOa1);
  
  /// append alpha representation of column to buffer
  SC_DLLPUBLIC void ColToAlpha( rtl::OUStringBuffer& rBuffer, SCCOL nCol);
Index: sc/inc/cell.hxx
===================================================================
RCS file: /cvs/sc/inc/cell.hxx,v
diff -cpr sc/inc/cell.hxx sc/inc/cell.hxx
*** sc/inc/cell.hxx	Thu Sep  8 13:24:26 2005
--- sc/inc/cell.hxx	Thu Aug 24 10:45:04 2006
*************** class ScFormulaCell : public ScBaseCell,
*** 247,252 ****
--- 247,253 ----
  private:
  	String			aErgString;
  	double			nErgValue;
+ 	ScAddress::Convention nErgConv;
  	ScTokenArray*	pCode; 					// das neue Token-Array
  	ScDocument*		pDocument;
  	ScMatrix*		pMatrix;				// Pointer auf Ergebnis-Matrix
*************** public:
*** 293,300 ****
  	// leere Zelle, ggf. mit fertigem TokenArray
  	ScFormulaCell( ScDocument*, const ScAddress&, const ScTokenArray* = NULL, BYTE=0 );
  	// mit Formel
! 	ScFormulaCell( ScDocument* pDoc, const ScAddress&,
! 				   const String& rFormula, BYTE bMatInd = 0 );
  	// copy-ctor
      // nCopyFlags:  0 := nothing special
      //              0x0001 := readjust 3D references to point to old position even if relative
--- 294,304 ----
  	// leere Zelle, ggf. mit fertigem TokenArray
  	ScFormulaCell( ScDocument*, const ScAddress&, const ScTokenArray* = NULL, BYTE=0 );
  	// mit Formel
! 	ScFormulaCell( ScDocument* pDoc, const ScAddress& aPos,
! 				   const String& rFormula,
! 				   // Use the conv associated with aPos::nTab by default
! 				   ScAddress::Convention eConvP = ScAddress::CONV_UNSPECIFIED,
! 				   BYTE bMatInd = 0 );
  	// copy-ctor
      // nCopyFlags:  0 := nothing special
      //              0x0001 := readjust 3D references to point to old position even if relative
*************** public:
*** 307,315 ****
  	ScBaseCell*		Clone(ScDocument* pDoc, const ScAddress&,
  							BOOL bNoListening = FALSE ) const;
  
! 	void			GetFormula( String& rFormula ) const;
! 	void			GetEnglishFormula( String& rFormula, BOOL bCompileXML = FALSE ) const;
! 	void			GetEnglishFormula( rtl::OUStringBuffer& rBuffer, BOOL bCompileXML = FALSE ) const;
  
  	void			Save( SvStream& rStream, ScMultipleWriteHeader& rHdr ) const;
  
--- 311,322 ----
  	ScBaseCell*		Clone(ScDocument* pDoc, const ScAddress&,
  							BOOL bNoListening = FALSE ) const;
  
! 	void			GetFormula( String& rFormula,
! 								ScAddress::Convention eConv = ScAddress::CONV_OOO) const;
! 	void			GetEnglishFormula( String& rFormula, BOOL bCompileXML = FALSE,
! 									   ScAddress::Convention eConv = ScAddress::CONV_OOO) const;
! 	void			GetEnglishFormula( rtl::OUStringBuffer& rBuffer, BOOL bCompileXML = FALSE,
! 									   ScAddress::Convention eConv = ScAddress::CONV_OOO) const;
  
  	void			Save( SvStream& rStream, ScMultipleWriteHeader& rHdr ) const;
  
*************** public:
*** 321,327 ****
  	BOOL			GetDirty() const { return bDirty; }
      BOOL            NeedsListening() const { return bNeedListening; }
      void            SetNeedsListening( BOOL bVar ) { bNeedListening = bVar; }
! 	void			Compile(const String& rFormula, BOOL bNoListening = FALSE );
  	void			CompileTokenArray( BOOL bNoListening = FALSE );
  	void			CompileXML( ScProgress& rProgress );		// compile temporary string tokens
  	void			CalcAfterLoad();
--- 328,336 ----
  	BOOL			GetDirty() const { return bDirty; }
      BOOL            NeedsListening() const { return bNeedListening; }
      void            SetNeedsListening( BOOL bVar ) { bNeedListening = bVar; }
! 	void			Compile(const String& rFormula,
! 							BOOL bNoListening = FALSE,
! 							ScAddress::Convention eConv = ScAddress::CONV_OOO);
  	void			CompileTokenArray( BOOL bNoListening = FALSE );
  	void			CompileXML( ScProgress& rProgress );		// compile temporary string tokens
  	void			CalcAfterLoad();
*************** public:
*** 408,414 ****
  	// fuer die Importfilter!
  	void 			AddRecalcMode( ScRecalcMode );
  	void			SetDouble( double n )					{ nErgValue = n; bIsValue = TRUE; }
! 	void			SetString( const String& r ) 			{ aErgString = r; bIsValue = FALSE; }
  	void			SetErrCode( USHORT n );
  	inline BOOL		IsHyperLinkCell() const { return pCode && pCode->IsHyperLink(); }
  	EditTextObject*		CreateURLObject() ;
--- 417,425 ----
  	// fuer die Importfilter!
  	void 			AddRecalcMode( ScRecalcMode );
  	void			SetDouble( double n )					{ nErgValue = n; bIsValue = TRUE; }
! 	void			SetString( const String& r,
! 							   ScAddress::Convention eConv = ScAddress::CONV_OOO)
! 						{ aErgString = r; nErgConv = eConv; bIsValue = FALSE; }
  	void			SetErrCode( USHORT n );
  	inline BOOL		IsHyperLinkCell() const { return pCode && pCode->IsHyperLink(); }
  	EditTextObject*		CreateURLObject() ;
Index: sc/inc/cellsuno.hxx
===================================================================
RCS file: /cvs/sc/inc/cellsuno.hxx,v
diff -cpr sc/inc/cellsuno.hxx sc/inc/cellsuno.hxx
*** sc/inc/cellsuno.hxx	Thu Aug 24 09:25:40 2006
--- sc/inc/cellsuno.hxx	Thu Aug 24 11:17:27 2006
*************** public:
*** 874,879 ****
--- 874,882 ----
  	virtual ::com::sun::star::uno::Reference< ::com::sun::star::table::XCellRange > SAL_CALL
  							getCellRangeByName( const ::rtl::OUString& aRange )
  								throw(::com::sun::star::uno::RuntimeException);
+ 	::com::sun::star::uno::Reference< ::com::sun::star::table::XCellRange > 
+ 							getCellRangeByName( const ::rtl::OUString& aRange,  const ScAddress::Details& rDetails )
+ 								throw(::com::sun::star::uno::RuntimeException);
  
  							// XPropertySet ueberladen wegen Range-Properties
  	virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo >
Index: sc/inc/column.hxx
===================================================================
RCS file: /cvs/sc/inc/column.hxx,v
diff -cpr sc/inc/column.hxx sc/inc/column.hxx
*** sc/inc/column.hxx	Thu Sep  8 13:27:42 2005
--- sc/inc/column.hxx	Thu Aug 24 10:45:04 2006
*************** public:
*** 264,270 ****
  	BOOL		HasEditCells(SCROW nStartRow, SCROW nEndRow, SCROW& rFirst) const;
  
  				//	TRUE = Zahlformat gesetzt
! 	BOOL		SetString( SCROW nRow, SCTAB nTab, const String& rString );
  	void		SetValue( SCROW nRow, const double& rVal);
  	void		SetNote( SCROW nRow, const ScPostIt& rNote );
  	void		SetError( SCROW nRow, const USHORT nError);
--- 264,271 ----
  	BOOL		HasEditCells(SCROW nStartRow, SCROW nEndRow, SCROW& rFirst) const;
  
  				//	TRUE = Zahlformat gesetzt
! 	BOOL		SetString( SCROW nRow, SCTAB nTab, const String& rString,
! 						   ScAddress::Convention conv = ScAddress::CONV_OOO );
  	void		SetValue( SCROW nRow, const double& rVal);
  	void		SetNote( SCROW nRow, const ScPostIt& rNote );
  	void		SetError( SCROW nRow, const USHORT nError);
Index: sc/inc/compiler.hrc
===================================================================
RCS file: /cvs/sc/inc/compiler.hrc,v
diff -cpr sc/inc/compiler.hrc sc/inc/compiler.hrc
*** sc/inc/compiler.hrc	Wed Aug 23 16:41:35 2006
--- sc/inc/compiler.hrc	Thu Aug 24 10:46:26 2006
***************
*** 363,371 ****
  #define	SC_OPCODE_ISPMT				386
  #define	SC_OPCODE_HYPERLINK			387
  #define SC_OPCODE_GET_PIVOT_DATA	388
! #define	SC_OPCODE_END_2_PAR			389
  
! #define SC_OPCODE_LAST_OPCODE_ID    388      /* letzter OpCode */
  
  /*** Interna ***/
  #define	SC_OPCODE_INTERNAL_BEGIN   9995
--- 363,373 ----
  #define	SC_OPCODE_ISPMT				386
  #define	SC_OPCODE_HYPERLINK			387
  #define SC_OPCODE_GET_PIVOT_DATA	388
! #define	SC_OPCODE_INDIRECT_XL		389		/* See also INDIRECT for OOO variant */
! #define	SC_OPCODE_ADRESS_XL		    390		/* See also ADRESS for OOO variant */
! #define	SC_OPCODE_END_2_PAR			391
  
! #define SC_OPCODE_LAST_OPCODE_ID    390      /* letzter OpCode */
  
  /*** Interna ***/
  #define	SC_OPCODE_INTERNAL_BEGIN   9995
Index: sc/inc/compiler.hxx
===================================================================
RCS file: /cvs/sc/inc/compiler.hxx,v
diff -cpr sc/inc/compiler.hxx sc/inc/compiler.hxx
*** sc/inc/compiler.hxx	Fri Aug  4 07:33:00 2006
--- sc/inc/compiler.hxx	Thu Aug 24 10:45:04 2006
*************** struct ScStringHashCode
*** 223,242 ****
  };
  typedef ::std::hash_map< String, OpCode, ScStringHashCode, ::std::equal_to< String > > ScOpCodeHashMap;
  
  class ScCompiler
  {
  public:
  	static String*	pSymbolTableNative;				// array of native symbols, offset==OpCode
  	static String*	pSymbolTableEnglish; 			// array of English symbols, offset==OpCode
  	static USHORT	nAnzStrings;					// count of symbols
      static ScOpCodeHashMap* pSymbolHashMapNative;   // hash map of native symbols
      static ScOpCodeHashMap* pSymbolHashMapEnglish;  // hash map of English symbols
      static CharClass* pCharClassEnglish;            // character classification for en_US locale
! private:
!     static ULONG*   pCharTable;						// array of ASCII character flags
  	ScDocument*	pDoc;
  	ScAddress	aPos;
! 	String      cFormula;							// String -> TokenArray
  	String		aCorrectedFormula;					// autocorrected Formula
  	String		aCorrectedSymbol;					// autocorrected Symbol
  	sal_Unicode	cSymbol[MAXSTRLEN];					// current Symbol
--- 223,263 ----
  };
  typedef ::std::hash_map< String, OpCode, ScStringHashCode, ::std::equal_to< String > > ScOpCodeHashMap;
  
+ using namespace ::com::sun::star::i18n;
  class ScCompiler
  {
  public:
+ 	struct Convention
+ 	{
+ 		const ScAddress::Convention meConv;
+ 		const ULONG*   				mpCharTable;
+ 
+ 
+ 		Convention( ScAddress::Convention eConvP );
+ 		~Convention();
+ 
+ 		virtual void MakeRefStr( rtl::OUStringBuffer&	rBuffer,
+ 								 const ScCompiler&		rCompiler,
+ 								 const ComplRefData&	rRef,
+ 								 BOOL bSingleRef ) const = 0;
+ 		virtual ::com::sun::star::i18n::ParseResult
+ 					parseAnyToken( const String& rFormula,
+ 								   xub_StrLen nSrcPos,
+ 								   const CharClass* pCharClass) const = 0;
+ 	};
+ 
  	static String*	pSymbolTableNative;				// array of native symbols, offset==OpCode
  	static String*	pSymbolTableEnglish; 			// array of English symbols, offset==OpCode
  	static USHORT	nAnzStrings;					// count of symbols
      static ScOpCodeHashMap* pSymbolHashMapNative;   // hash map of native symbols
      static ScOpCodeHashMap* pSymbolHashMapEnglish;  // hash map of English symbols
      static CharClass* pCharClassEnglish;            // character classification for en_US locale
! 	static const Convention *pConventions[ ScAddress::CONV_LAST ];
! 
  	ScDocument*	pDoc;
  	ScAddress	aPos;
! 
! private:
  	String		aCorrectedFormula;					// autocorrected Formula
  	String		aCorrectedSymbol;					// autocorrected Symbol
  	sal_Unicode	cSymbol[MAXSTRLEN];					// current Symbol
*************** private:
*** 263,269 ****
  											// will not be resolved
  	BOOL		bIgnoreErrors;				// on AutoCorrect and CompileForFAP
  											// ignore errors and create RPN nevertheless
! 	BOOL		bCompileXML;
  	BOOL		bImportXML;
  
  	BOOL   GetToken();
--- 284,290 ----
  											// will not be resolved
  	BOOL		bIgnoreErrors;				// on AutoCorrect and CompileForFAP
  											// ignore errors and create RPN nevertheless
! 	const Convention *pConv;
  	BOOL		bImportXML;
  
  	BOOL   GetToken();
*************** private:
*** 282,295 ****
  	void NotLine();
  	OpCode Expression();
  
- 	String MakeColStr( SCCOL nCol );
- 	void MakeColStr( rtl::OUStringBuffer& rBuffer, SCCOL nCol );
- 	String MakeRowStr( SCROW nRow );
- 	void MakeRowStr( rtl::OUStringBuffer& rBuffer, SCROW nRow );
- 	String MakeTabStr( SCTAB nTab, String& aDoc );
- 	String MakeRefStr( ComplRefData& rRefData, BOOL bSingleRef );
- 	void MakeRefStr( rtl::OUStringBuffer& rBuffer, ComplRefData& rRefData, BOOL bSingleRef );
- 
  	void SetError(USHORT nError);
  	xub_StrLen NextSymbol();
  	BOOL IsValue( const String& );
--- 303,308 ----
*************** public:
*** 315,327 ****
  
  	static void Init();
  	static void DeInit();
- 	static void CheckTabQuotes( String& );	// for ScAddress::Format()
  
!     // Put quotes around string if non-alphanumeric characters are contained,
!     // quote characters contained within are escaped by '\\'.
! 	static BOOL EnQuote( String& );
! 	// Remove quotes, escaped quotes are unescaped.
! 	static BOOL DeQuote( String& );
  
  	//! _either_ CompileForFAP _or_ AutoCorrection, _not_ both
  	void			SetCompileForFAP( BOOL bVal )
--- 328,342 ----
  
  	static void Init();
  	static void DeInit();
  
! 	// for ScAddress::Format()
! 	static void CheckTabQuotes( String& aTabName,
! 								const ScAddress::Convention eConv = ScAddress::CONV_OOO );
! 
! 	static BOOL EnQuote( String& rStr, 
! 						 const ScAddress::Convention eConv = ScAddress::CONV_OOO );
! 	static BOOL DeQuote( String& rStr,
! 						 const ScAddress::Convention eConv = ScAddress::CONV_OOO );
  
  	//! _either_ CompileForFAP _or_ AutoCorrection, _not_ both
  	void			SetCompileForFAP( BOOL bVal )
*************** public:
*** 329,341 ****
  	void 			SetAutoCorrection( BOOL bVal )
  						{ bAutoCorrect = bVal; bIgnoreErrors = bVal; }
  	void			SetCompileEnglish( BOOL bVal );		// use English SymbolTable
! 	void			SetCompileXML( BOOL bVal )
! 						{ bCompileXML = bVal; }
  	void			SetImportXML( BOOL bVal )
  						{ bImportXML = bVal; }
  	BOOL			IsCorrected() { return bCorrected; }
  	const String&	GetCorrectedFormula() { return aCorrectedFormula; }
! 	ScTokenArray* CompileString( const String& rFormula );
  	BOOL  CompileTokenArray();
  	short GetNumFormatType() { return nNumFmt; }
  
--- 344,361 ----
  	void 			SetAutoCorrection( BOOL bVal )
  						{ bAutoCorrect = bVal; bIgnoreErrors = bVal; }
  	void			SetCompileEnglish( BOOL bVal );		// use English SymbolTable
! 	void			SetRefConvention( const Convention *pConvP );
! 	void			SetRefConvention( const ScAddress::Convention eConv );
! 
! 	void			SetCompileXML( BOOL bVal );	// Deprecate and move to an address conv
  	void			SetImportXML( BOOL bVal )
  						{ bImportXML = bVal; }
  	BOOL			IsCorrected() { return bCorrected; }
  	const String&	GetCorrectedFormula() { return aCorrectedFormula; }
! 
! 	// Use convention from this->aPos by default
! 	ScTokenArray* CompileString( const String& rFormula,
! 								 ScAddress::Convention eConv = ScAddress::CONV_UNSPECIFIED );
  	BOOL  CompileTokenArray();
  	short GetNumFormatType() { return nNumFmt; }
  
*************** public:
*** 374,403 ****
  
  	BOOL HasModifiedRange();
  
- 	/// Is the CharTable initialized? If not call Init() yourself!
- 	static inline BOOL HasCharTable() { return pCharTable != NULL; }
- 
- 	/// Access the CharTable flags
- 	static inline ULONG GetCharTableFlags( sal_Unicode c )
- 		{ return c < 128 ? pCharTable[ UINT8(c) ] : 0; }
- 
  	/// If the character is allowed as first character in sheet names or references
! 	static inline BOOL IsCharWordChar( sal_Unicode c )
  		{
  			return c < 128 ?
! 				((pCharTable[ UINT8(c) ] & SC_COMPILER_C_CHAR_WORD) == SC_COMPILER_C_CHAR_WORD) :
  				ScGlobal::pCharClass->isLetterNumeric( c );
  		}
  
  	/// If the character is allowed in sheet names or references
! 	static inline BOOL IsWordChar( sal_Unicode c )
  		{
  			return c < 128 ?
! 				((pCharTable[ UINT8(c) ] & SC_COMPILER_C_WORD) == SC_COMPILER_C_WORD) :
  				ScGlobal::pCharClass->isLetterNumeric( c );
  		}
  
  private:
      static inline void ForceArrayOperator( ScTokenRef& rCurr, const ScTokenRef& rPrev )
          {
              if ( rPrev.Is() && rPrev->HasForceArray() &&
--- 394,422 ----
  
  	BOOL HasModifiedRange();
  
  	/// If the character is allowed as first character in sheet names or references
! 	static inline BOOL IsCharWordChar( sal_Unicode c,
! 									   const ScAddress::Convention eConv = ScAddress::CONV_OOO )
  		{
  			return c < 128 ?
! 				((pConventions[eConv]->mpCharTable[ UINT8(c) ] & SC_COMPILER_C_CHAR_WORD) == SC_COMPILER_C_CHAR_WORD) :
  				ScGlobal::pCharClass->isLetterNumeric( c );
  		}
  
  	/// If the character is allowed in sheet names or references
! 	static inline BOOL IsWordChar( sal_Unicode c,
! 								   const ScAddress::Convention eConv = ScAddress::CONV_OOO )
  		{
  			return c < 128 ?
! 				((pConventions[eConv]->mpCharTable[ UINT8(c) ] & SC_COMPILER_C_WORD) == SC_COMPILER_C_WORD) :
  				ScGlobal::pCharClass->isLetterNumeric( c );
  		}
  
  private:
+ 	/// Access the CharTable flags
+ 	inline ULONG GetCharTableFlags( sal_Unicode c )
+ 		{ return c < 128 ? pConv->mpCharTable[ UINT8(c) ] : 0; }
+ 
      static inline void ForceArrayOperator( ScTokenRef& rCurr, const ScTokenRef& rPrev )
          {
              if ( rPrev.Is() && rPrev->HasForceArray() &&
Index: sc/inc/document.hxx
===================================================================
RCS file: /cvs/sc/inc/document.hxx,v
diff -cpr sc/inc/document.hxx sc/inc/document.hxx
*** sc/inc/document.hxx	Wed Aug 23 16:41:47 2006
--- sc/inc/document.hxx	Thu Aug 24 10:45:04 2006
*************** private:
*** 401,406 ****
--- 401,407 ----
  
  	BOOL				bInUnoBroadcast;
  	BOOL				bInUnoListenerCall;
+ 	ScAddress::Convention eAddrConv;
  
      mutable BOOL        bStyleSheetUsageInvalid;
  
*************** SC_DLLPUBLIC	ScDBCollection*	GetDBCollec
*** 583,588 ****
--- 584,591 ----
  	void			GetScenarioFlags( SCTAB nTab, USHORT& rFlags ) const;
  	BOOL			IsActiveScenario( SCTAB nTab ) const;
  	void			SetActiveScenario( SCTAB nTab, BOOL bActive );		// nur fuer Undo etc.
+ 	ScAddress::Convention GetAddressConvention() const;
+ 	void	 	    SetAddressConvention( ScAddress::Convention eConv );
  	BYTE			GetLinkMode( SCTAB nTab ) const;
  	BOOL			IsLinked( SCTAB nTab ) const;
  	const String&	GetLinkDoc( SCTAB nTab ) const;
Index: sc/inc/globstr.hrc
===================================================================
RCS file: /cvs/sc/inc/globstr.hrc,v
diff -cpr sc/inc/globstr.hrc sc/inc/globstr.hrc
*** sc/inc/globstr.hrc	Wed Aug 23 16:33:09 2006
--- sc/inc/globstr.hrc	Thu Aug 24 10:45:04 2006
***************
*** 558,564 ****
  #define STR_RECALC_MANUAL           416
  #define STR_RECALC_AUTO             417
  
! #define STR_COUNT                   418
  
  #endif
  
--- 558,566 ----
  #define STR_RECALC_MANUAL           416
  #define STR_RECALC_AUTO             417
  
! #define STR_UNDO_TAB_R1C1           418
! 
! #define STR_COUNT                   419
  
  #endif
  
Index: sc/inc/opcode.hxx
===================================================================
RCS file: /cvs/sc/inc/opcode.hxx,v
diff -cpr sc/inc/opcode.hxx sc/inc/opcode.hxx
*** sc/inc/opcode.hxx	Wed Aug 23 16:41:35 2006
--- sc/inc/opcode.hxx	Thu Aug 24 10:45:04 2006
*************** enum OpCodeEnum
*** 268,274 ****
--- 268,276 ----
  		ocDBVarP			= SC_OPCODE_DB_VAR_P,
  	// Verwaltungsfunktionen
  		ocIndirect			= SC_OPCODE_INDIRECT,
+ 		ocIndirectXL		= SC_OPCODE_INDIRECT_XL,
  		ocAdress			= SC_OPCODE_ADRESS,
+ 		ocAdressXL			= SC_OPCODE_ADRESS_XL,
  		ocMatch				= SC_OPCODE_MATCH,
  		ocCountEmptyCells	= SC_OPCODE_COUNT_EMPTY_CELLS,
  		ocCountIf			= SC_OPCODE_COUNT_IF,
Index: sc/inc/rangelst.hxx
===================================================================
RCS file: /cvs/sc/inc/rangelst.hxx,v
diff -cpr sc/inc/rangelst.hxx sc/inc/rangelst.hxx
*** sc/inc/rangelst.hxx	Wed Sep 28 07:27:12 2005
--- sc/inc/rangelst.hxx	Thu Aug 24 10:45:04 2006
*************** public:
*** 66,73 ****
  						Insert( pR, LIST_APPEND );
  					}
  	USHORT			Parse( const String&, ScDocument* = NULL,
! 							USHORT nMask = SCA_VALID );
! 	void 			Format( String&, USHORT nFlags = 0, ScDocument* = NULL ) const;
  	void			Join( const ScRange&, BOOL bIsInList = FALSE );
  	BOOL 			UpdateReference( UpdateRefMode, ScDocument*,
  									const ScRange& rWhere,
--- 66,75 ----
  						Insert( pR, LIST_APPEND );
  					}
  	USHORT			Parse( const String&, ScDocument* = NULL,
! 						   USHORT nMask = SCA_VALID,
! 						   ScAddress::Convention eConv = ScAddress::CONV_OOO );
! 	void 			Format( String&, USHORT nFlags = 0, ScDocument* = NULL,
! 							ScAddress::Convention eConv = ScAddress::CONV_OOO ) const;
  	void			Join( const ScRange&, BOOL bIsInList = FALSE );
  	BOOL 			UpdateReference( UpdateRefMode, ScDocument*,
  									const ScRange& rWhere,
Index: sc/inc/rangenam.hxx
===================================================================
RCS file: /cvs/sc/inc/rangenam.hxx,v
diff -cpr sc/inc/rangenam.hxx sc/inc/rangenam.hxx
*** sc/inc/rangenam.hxx	Mon Jul 10 09:23:26 2006
--- sc/inc/rangenam.hxx	Thu Aug 24 10:45:04 2006
*************** public:
*** 207,214 ****
  
  	ScRangeName(const ScRangeName& rScRangeName, ScDocument* pDocument);
  
! 	virtual	DataObject* 	Clone(ScDocument* pDoc) const
! 							 { return new ScRangeName(*this, pDoc); }
  	ScRangeData*			operator[]( const USHORT nIndex) const
  							 { return (ScRangeData*)At(nIndex); }
  	virtual	short			Compare(DataObject* pKey1, DataObject* pKey2) const;
--- 207,214 ----
  
  	ScRangeName(const ScRangeName& rScRangeName, ScDocument* pDocument);
  
! 	virtual	DataObject* 	Clone(ScDocument* pDocP ) const
! 							 { return new ScRangeName(*this, pDocP ); }
  	ScRangeData*			operator[]( const USHORT nIndex) const
  							 { return (ScRangeData*)At(nIndex); }
  	virtual	short			Compare(DataObject* pKey1, DataObject* pKey2) const;
Index: sc/inc/rangeutl.hxx
===================================================================
RCS file: /cvs/sc/inc/rangeutl.hxx,v
diff -cpr sc/inc/rangeutl.hxx sc/inc/rangeutl.hxx
*** sc/inc/rangeutl.hxx	Thu Sep  8 13:50:35 2005
--- sc/inc/rangeutl.hxx	Thu Aug 24 10:45:04 2006
*************** public:
*** 71,77 ****
  	BOOL	MakeArea			( const String&		rAreaStr,
  								  ScArea&			rArea,
  								  ScDocument*		pDoc,
! 								  SCTAB			nTab ) const;
  
  	void	CutPosString		( const String&		theAreaStr,
  								  String&			thePosStr ) const;
--- 71,78 ----
  	BOOL	MakeArea			( const String&		rAreaStr,
  								  ScArea&			rArea,
  								  ScDocument*		pDoc,
! 								  SCTAB			nTab,
! 								  ScAddress::Details const & rDetails = ScAddress::detailsOOOa1 ) const;
  
  	void	CutPosString		( const String&		theAreaStr,
  								  String&			thePosStr ) const;
*************** public:
*** 80,93 ****
  								  ScDocument*		pDoc,
  								  ScArea***			pppAreas 	= 0,
  								  USHORT*			pAreaCount	= 0,
! 								  BOOL				bAcceptCellRef = FALSE ) const;
  
  	BOOL	IsAbsArea			( const String& rAreaStr,
  								  ScDocument*	pDoc,
  								  SCTAB		nTab,
  								  String*		pCompleteStr = 0,
  								  ScRefAddress*	pStartPos	 = 0,
! 								  ScRefAddress*	pEndPos		 = 0 ) const;
  
  	BOOL	IsRefArea			( const String& rAreaStr,
  								  ScDocument*	pDoc,
--- 81,96 ----
  								  ScDocument*		pDoc,
  								  ScArea***			pppAreas 	= 0,
  								  USHORT*			pAreaCount	= 0,
! 								  BOOL				bAcceptCellRef = FALSE,
! 								  ScAddress::Details const & rDetails = ScAddress::detailsOOOa1 ) const;
  
  	BOOL	IsAbsArea			( const String& rAreaStr,
  								  ScDocument*	pDoc,
  								  SCTAB		nTab,
  								  String*		pCompleteStr = 0,
  								  ScRefAddress*	pStartPos	 = 0,
! 								  ScRefAddress*	pEndPos		 = 0,
! 								  ScAddress::Details const & rDetails = ScAddress::detailsOOOa1 ) const;
  
  	BOOL	IsRefArea			( const String& rAreaStr,
  								  ScDocument*	pDoc,
*************** public:
*** 100,113 ****
  								  ScDocument*	pDoc,
  								  SCTAB		nTab,
  								  String*		pCompleteStr = 0,
! 								  ScRefAddress*	pPosTripel	 = 0 ) const;
  
  	BOOL	MakeRangeFromName	( const String&	rName,
  									ScDocument*		pDoc,
  									SCTAB			nCurTab,
  									ScRange&		rRange,
! 									RutlNameScope eScope=RUTL_NAMES
! 								  ) const;
  };
  
  //------------------------------------------------------------------------
--- 103,117 ----
  								  ScDocument*	pDoc,
  								  SCTAB		nTab,
  								  String*		pCompleteStr = 0,
! 								  ScRefAddress*	pPosTripel	 = 0,
! 								  ScAddress::Details const & rDetails = ScAddress::detailsOOOa1 ) const;
  
  	BOOL	MakeRangeFromName	( const String&	rName,
  									ScDocument*		pDoc,
  									SCTAB			nCurTab,
  									ScRange&		rRange,
! 								  RutlNameScope eScope=RUTL_NAMES,
! 								  ScAddress::Details const & rDetails = ScAddress::detailsOOOa1 ) const;
  };
  
  //------------------------------------------------------------------------
*************** public:
*** 128,134 ****
  	BOOL	operator==	( const ScArea& r ) const;
  	BOOL	operator!=	( const ScArea& r ) const  { return !( operator==(r) ); }
  	void	GetString	( String& rStr,
! 						  BOOL bAbsolute = TRUE, ScDocument* pDoc = NULL ) const;
  
  public:
  	SCTAB nTab;
--- 132,139 ----
  	BOOL	operator==	( const ScArea& r ) const;
  	BOOL	operator!=	( const ScArea& r ) const  { return !( operator==(r) ); }
  	void	GetString	( String& rStr,
! 						  BOOL bAbsolute = TRUE, ScDocument* pDoc = NULL,
! 						  ScAddress::Details const & rDetails = ScAddress::detailsOOOa1 ) const;
  
  public:
  	SCTAB nTab;
Index: sc/inc/reffind.hxx
===================================================================
RCS file: /cvs/sc/inc/reffind.hxx,v
diff -cpr sc/inc/reffind.hxx sc/inc/reffind.hxx
*** sc/inc/reffind.hxx	Thu Sep  8 13:51:35 2005
--- sc/inc/reffind.hxx	Thu Aug 24 10:45:04 2006
***************
*** 39,44 ****
--- 39,47 ----
  #ifndef _STRING_HXX //autogen
  #include <tools/string.hxx>
  #endif
+ #ifndef SC_ADDRESS_HXX
+ #include "address.hxx"
+ #endif
  
  class ScDocument;
  
*************** class ScRefFinder
*** 48,53 ****
--- 51,57 ----
  {
  private:
  	String		aFormula;
+ 	ScAddress::Convention eConv;
  	ScDocument*	pDoc;
  	xub_StrLen	nFound;
  	xub_StrLen	nSelStart;
*************** private:
*** 56,62 ****
  public:
  	static const sal_Unicode __FAR_DATA pDelimiters[];
  
! 	ScRefFinder( const String& rFormula, ScDocument* pDocument = NULL );
  	~ScRefFinder();
  
  	const String&	GetText() const		{ return aFormula; }
--- 60,68 ----
  public:
  	static const sal_Unicode __FAR_DATA pDelimiters[];
  
! 	ScRefFinder( const String& rFormula,
! 		     ScDocument* pDocument = NULL,
! 		     ScAddress::Convention eConvP = ScAddress::CONV_OOO );
  	~ScRefFinder();
  
  	const String&	GetText() const		{ return aFormula; }
Index: sc/source/core/data/attrib.cxx
===================================================================
RCS file: /cvs/sc/source/core/data/attrib.cxx,v
diff -cpr sc/source/core/data/attrib.cxx sc/source/core/data/attrib.cxx
*** sc/source/core/data/attrib.cxx	Fri Jul 21 06:47:04 2006
--- sc/source/core/data/attrib.cxx	Thu Aug 24 10:45:05 2006
*************** SfxItemPresentation ScRangeItem::GetPres
*** 522,527 ****
--- 522,528 ----
  		case SFX_ITEM_PRESENTATION_NAMELESS:
  		{
  			String aText;
+ 			/* Always use OOo:A1 format */
  			aRange.Format( aText );
  			rText += aText;
  		}
Index: sc/source/core/data/cell.cxx
===================================================================
RCS file: /cvs/sc/source/core/data/cell.cxx,v
diff -cpr sc/source/core/data/cell.cxx sc/source/core/data/cell.cxx
*** sc/source/core/data/cell.cxx	Fri Aug  4 07:33:27 2006
--- sc/source/core/data/cell.cxx	Thu Aug 24 10:45:05 2006
*************** ScFormulaCell::ScFormulaCell() :
*** 542,548 ****
  }
  
  ScFormulaCell::ScFormulaCell( ScDocument* pDoc, const ScAddress& rPos,
! 							  const String& rFormula, BYTE cMatInd ) :
  	ScBaseCell( CELLTYPE_FORMULA ),
  	nErgValue( 0.0 ),
  	pCode( NULL ),
--- 542,550 ----
  }
  
  ScFormulaCell::ScFormulaCell( ScDocument* pDoc, const ScAddress& rPos,
! 							  const String& rFormula,
! 							  ScAddress::Convention eConv,
! 							  BYTE cMatInd ) :
  	ScBaseCell( CELLTYPE_FORMULA ),
  	nErgValue( 0.0 ),
  	pCode( NULL ),
*************** ScFormulaCell::ScFormulaCell( ScDocument
*** 570,576 ****
  	cMatrixFlag ( cMatInd ),
  	aPos( rPos )
  {
! 	Compile( rFormula, TRUE );	// bNoListening, erledigt Insert
  }
  
  // Wird von den Importfiltern verwendet
--- 572,578 ----
  	cMatrixFlag ( cMatInd ),
  	aPos( rPos )
  {
! 	Compile( rFormula, TRUE, eConv );	// bNoListening, erledigt Insert
  }
  
  // Wird von den Importfiltern verwendet
*************** ScFormulaCell::ScFormulaCell( ScDocument
*** 625,630 ****
--- 627,633 ----
  	SvtListener(),
  	aErgString( rScFormulaCell.aErgString ),
  	nErgValue( rScFormulaCell.nErgValue ),
+ 	nErgConv( rScFormulaCell.nErgConv ),
  	pDocument( pDoc ),
  	pPrevious(0),
  	pNext(0),
*************** ScFormulaCell::ScFormulaCell( ScDocument
*** 782,787 ****
--- 785,791 ----
  		if( cFlags & 0x10 )
  		{
  			rStream.ReadByteString( aErgString, rStream.GetStreamCharSet() );
+ 			nErgConv = ScAddress::CONV_OOO;
  			bIsValue = FALSE;
  		}
  		pCode->Load( rStream, nVer, aPos );
*************** ScBaseCell* ScFormulaCell::Clone( ScDocu
*** 917,923 ****
  	return pCell;
  }
  
! void ScFormulaCell::GetFormula( String& rFormula ) const
  {
  	if( pCode->GetError() && !pCode->GetLen() )
  	{
--- 921,927 ----
  	return pCell;
  }
  
! void ScFormulaCell::GetFormula( String& rFormula, ScAddress::Convention eConv ) const
  {
  	if( pCode->GetError() && !pCode->GetLen() )
  	{
*************** void ScFormulaCell::GetFormula( String& 
*** 941,947 ****
  			}
  			if (pCell && pCell->GetCellType() == CELLTYPE_FORMULA)
  			{
! 				((ScFormulaCell*)pCell)->GetFormula(rFormula);
  				return;
  			}
  			else
--- 945,951 ----
  			}
  			if (pCell && pCell->GetCellType() == CELLTYPE_FORMULA)
  			{
! 				((ScFormulaCell*)pCell)->GetFormula(rFormula, eConv);
  				return;
  			}
  			else
*************** void ScFormulaCell::GetResultDimensions(
*** 983,989 ****
  	}
  }
  
! void ScFormulaCell::Compile( const String& rFormula, BOOL bNoListening )
  {
  	if ( pDocument->IsClipOrUndo() ) return;
  	BOOL bWasInFormulaTree = pDocument->IsInFormulaTree( this );
--- 987,994 ----
  	}
  }
  
! void ScFormulaCell::Compile( const String& rFormula, BOOL bNoListening,
! 							 ScAddress::Convention eConv )
  {
  	if ( pDocument->IsClipOrUndo() ) return;
  	BOOL bWasInFormulaTree = pDocument->IsInFormulaTree( this );
*************** void ScFormulaCell::Compile( const Strin
*** 996,1002 ****
  	ScCompiler aComp(pDocument, aPos);
  	if ( pDocument->IsImportingXML() )
  		aComp.SetCompileEnglish( TRUE );
! 	pCode = aComp.CompileString( rFormula );
  	if ( pCodeOld )
  		delete pCodeOld;
  	if( !pCode->GetError() )
--- 1001,1007 ----
  	ScCompiler aComp(pDocument, aPos);
  	if ( pDocument->IsImportingXML() )
  		aComp.SetCompileEnglish( TRUE );
! 	pCode = aComp.CompileString( rFormula, eConv );
  	if ( pCodeOld )
  		delete pCodeOld;
  	if( !pCode->GetError() )
*************** void ScFormulaCell::CompileTokenArray( B
*** 1026,1032 ****
  {
  	// Noch nicht compiliert?
  	if( !pCode->GetLen() && aErgString.Len() )
! 		Compile( aErgString );
  	else if( bCompile && !pDocument->IsClipOrUndo() && !pCode->GetError() )
  	{
  		// RPN-Laenge kann sich aendern
--- 1031,1037 ----
  {
  	// Noch nicht compiliert?
  	if( !pCode->GetLen() && aErgString.Len() )
! 		Compile( aErgString, nErgConv );
  	else if( bCompile && !pDocument->IsClipOrUndo() && !pCode->GetError() )
  	{
  		// RPN-Laenge kann sich aendern
*************** void ScFormulaCell::CalcAfterLoad()
*** 1121,1127 ****
  	// aber kein TokenArray
  	if( !pCode->GetLen() && aErgString.Len() )
  	{
! 		Compile( aErgString, TRUE );
  		aErgString.Erase();
  		bDirty = TRUE;
  		bNewCompiled = TRUE;
--- 1126,1132 ----
  	// aber kein TokenArray
  	if( !pCode->GetLen() && aErgString.Len() )
  	{
! 		Compile( aErgString, TRUE, nErgConv );
  		aErgString.Erase();
  		bDirty = TRUE;
  		bNewCompiled = TRUE;
Index: sc/source/core/data/cell2.cxx
===================================================================
RCS file: /cvs/sc/source/core/data/cell2.cxx,v
diff -cpr sc/source/core/data/cell2.cxx sc/source/core/data/cell2.cxx
*** sc/source/core/data/cell2.cxx	Fri Aug  4 07:33:37 2006
--- sc/source/core/data/cell2.cxx	Thu Aug 24 10:45:05 2006
*************** void ScEditCell::SetTextObject( const Ed
*** 242,248 ****
  
  //---------------------------------------------------------------------
  
! void ScFormulaCell::GetEnglishFormula( String& rFormula, BOOL bCompileXML ) const
  {
      //! mit GetFormula zusammenfassen !!!
  
--- 242,249 ----
  
  //---------------------------------------------------------------------
  
! void ScFormulaCell::GetEnglishFormula( String& rFormula, BOOL bCompileXML,
! 									   ScAddress::Convention conv ) const
  {
      //! mit GetFormula zusammenfassen !!!
  
*************** void ScFormulaCell::GetEnglishFormula( S
*** 267,273 ****
                  pCell = NULL;
              if (pCell && pCell->GetCellType() == CELLTYPE_FORMULA)
              {
!                 ((ScFormulaCell*)pCell)->GetEnglishFormula(rFormula, bCompileXML);
                  return;
              }
              else
--- 268,274 ----
                  pCell = NULL;
              if (pCell && pCell->GetCellType() == CELLTYPE_FORMULA)
              {
!                 ((ScFormulaCell*)pCell)->GetEnglishFormula(rFormula, bCompileXML, conv);
                  return;
              }
              else
*************** void ScFormulaCell::GetEnglishFormula( S
*** 299,305 ****
      }
  }
  
! void ScFormulaCell::GetEnglishFormula( rtl::OUStringBuffer& rBuffer, BOOL bCompileXML ) const
  {
      //! mit GetFormula zusammenfassen !!!
  
--- 300,307 ----
      }
  }
  
! void ScFormulaCell::GetEnglishFormula( rtl::OUStringBuffer& rBuffer, BOOL bCompileXML,
! 									   ScAddress::Convention conv ) const
  {
      //! mit GetFormula zusammenfassen !!!
  
*************** void ScFormulaCell::GetEnglishFormula( r
*** 324,330 ****
                  pCell = NULL;
              if (pCell && pCell->GetCellType() == CELLTYPE_FORMULA)
              {
!                 ((ScFormulaCell*)pCell)->GetEnglishFormula(rBuffer, bCompileXML);
                  return;
              }
              else
--- 326,332 ----
                  pCell = NULL;
              if (pCell && pCell->GetCellType() == CELLTYPE_FORMULA)
              {
! 				((ScFormulaCell*)pCell)->GetEnglishFormula(rBuffer, bCompileXML, conv);
                  return;
              }
              else
*************** void ScFormulaCell::CompileDBFormula( BO
*** 1385,1391 ****
          if ( bRecompile )
          {
              String aFormula;
!             GetFormula( aFormula );
              if ( GetMatrixFlag() != MM_NONE && aFormula.Len() )
              {
                  if ( aFormula.GetChar( aFormula.Len()-1 ) == '}' )
--- 1387,1393 ----
          if ( bRecompile )
          {
              String aFormula;
!             GetFormula( aFormula, ScAddress::CONV_OOO);
              if ( GetMatrixFlag() != MM_NONE && aFormula.Len() )
              {
                  if ( aFormula.GetChar( aFormula.Len()-1 ) == '}' )
*************** void ScFormulaCell::CompileDBFormula( BO
*** 1397,1402 ****
--- 1399,1405 ----
              pDocument->RemoveFromFormulaTree( this );
              pCode->Clear();
              aErgString = aFormula;
+ 			nErgConv = ScAddress::CONV_OOO;
          }
      }
      else if ( !pCode->GetLen() && aErgString.Len() )
*************** void ScFormulaCell::CompileNameFormula( 
*** 1432,1438 ****
          if ( bRecompile )
          {
              String aFormula;
!             GetFormula( aFormula );
              if ( GetMatrixFlag() != MM_NONE && aFormula.Len() )
              {
                  if ( aFormula.GetChar( aFormula.Len()-1 ) == '}' )
--- 1435,1441 ----
          if ( bRecompile )
          {
              String aFormula;
!             GetFormula( aFormula, ScAddress::CONV_OOO);
              if ( GetMatrixFlag() != MM_NONE && aFormula.Len() )
              {
                  if ( aFormula.GetChar( aFormula.Len()-1 ) == '}' )
*************** void ScFormulaCell::CompileNameFormula( 
*** 1444,1449 ****
--- 1447,1453 ----
              pDocument->RemoveFromFormulaTree( this );
              pCode->Clear();
              aErgString = aFormula;
+ 			nErgConv = ScAddress::CONV_OOO;
          }
      }
      else if ( !pCode->GetLen() && aErgString.Len() )
Index: sc/source/core/data/column3.cxx
===================================================================
RCS file: /cvs/sc/source/core/data/column3.cxx,v
diff -cpr sc/source/core/data/column3.cxx sc/source/core/data/column3.cxx
*** sc/source/core/data/column3.cxx	Wed Aug 23 16:41:46 2006
--- sc/source/core/data/column3.cxx	Thu Aug 24 10:45:05 2006
*************** void ScColumn::StartListeningInArea( SCR
*** 1261,1267 ****
  
  
  //	TRUE = Zahlformat gesetzt
! BOOL ScColumn::SetString( SCROW nRow, SCTAB nTab, const String& rString )
  {
  	BOOL bNumFmtSet = FALSE;
  	if (VALIDROW(nRow))
--- 1261,1268 ----
  
  
  //	TRUE = Zahlformat gesetzt
! BOOL ScColumn::SetString( SCROW nRow, SCTAB nTab, const String& rString,
! 						  ScAddress::Convention conv )
  {
  	BOOL bNumFmtSet = FALSE;
  	if (VALIDROW(nRow))
*************** BOOL ScColumn::SetString( SCROW nRow, SC
*** 1298,1304 ****
  					pNewCell = new ScStringCell( rString );
  				else											// =Formel
  					pNewCell = new ScFormulaCell( pDocument,
! 						ScAddress( nCol, nRow, nTab ), rString, 0 );
  			}
  			else if ( cFirstChar == '\'')						// 'Text
  				pNewCell = new ScStringCell( rString.Copy(1) );
--- 1299,1305 ----
  					pNewCell = new ScStringCell( rString );
  				else											// =Formel
  					pNewCell = new ScFormulaCell( pDocument,
! 						ScAddress( nCol, nRow, nTab ), rString, conv, 0 );
  			}
  			else if ( cFirstChar == '\'')						// 'Text
  				pNewCell = new ScStringCell( rString.Copy(1) );
Index: sc/source/core/data/conditio.cxx
===================================================================
RCS file: /cvs/sc/source/core/data/conditio.cxx,v
diff -cpr sc/source/core/data/conditio.cxx sc/source/core/data/conditio.cxx
*** sc/source/core/data/conditio.cxx	Fri Jul 21 06:50:45 2006
--- sc/source/core/data/conditio.cxx	Thu Aug 24 10:45:05 2006
*************** void ScConditionEntry::CompileXML()
*** 536,541 ****
--- 536,543 ----
      if ( aSrcString.Len() )
      {
          ScAddress aNew;
+ 		/* XML is always in OOo:A1 format, although R1C1 would be more amenable
+ 		 * to compression */
          if ( aNew.Parse( aSrcString, pDoc ) & SCA_VALID )
              aSrcPos = aNew;
          // if the position is invalid, there isn't much we can do at this time
Index: sc/source/core/data/documen2.cxx
===================================================================
RCS file: /cvs/sc/source/core/data/documen2.cxx,v
diff -cpr sc/source/core/data/documen2.cxx sc/source/core/data/documen2.cxx
*** sc/source/core/data/documen2.cxx	Fri Jul 21 06:51:42 2006
--- sc/source/core/data/documen2.cxx	Thu Aug 24 10:45:05 2006
*************** ScDocument::ScDocument( ScDocumentMode	e
*** 374,379 ****
--- 374,380 ----
          nInDdeLinkUpdate( 0 ),
          bInUnoBroadcast( FALSE ),
          bInUnoListenerCall( FALSE ),
+         eAddrConv( ScAddress::CONV_OOO ),
          bStyleSheetUsageInvalid( TRUE )
  {
  	eSrcSet = gsl_getSystemTextEncoding();
Index: sc/source/core/data/documen3.cxx
===================================================================
RCS file: /cvs/sc/source/core/data/documen3.cxx,v
diff -cpr sc/source/core/data/documen3.cxx sc/source/core/data/documen3.cxx
*** sc/source/core/data/documen3.cxx	Wed Aug 23 16:41:35 2006
--- sc/source/core/data/documen3.cxx	Thu Aug 24 10:45:05 2006
*************** BOOL ScDocument::IsLinked( SCTAB nTab ) 
*** 399,404 ****
--- 399,414 ----
  	return FALSE;
  }
  
+ ScAddress::Convention ScDocument::GetAddressConvention() const
+ {
+ 	return eAddrConv;
+ }
+ 
+ void ScDocument::SetAddressConvention( ScAddress::Convention eConv )
+ {
+ 	eAddrConv = eConv;
+ }
+ 
  BOOL ScDocument::GetLinkMode( SCTAB nTab ) const
  {
  	if (ValidTab(nTab) && pTab[nTab])
Index: sc/source/core/data/documen4.cxx
===================================================================
RCS file: /cvs/sc/source/core/data/documen4.cxx,v
diff -cpr sc/source/core/data/documen4.cxx sc/source/core/data/documen4.cxx
*** sc/source/core/data/documen4.cxx	Fri Jul 21 06:52:08 2006
--- sc/source/core/data/documen4.cxx	Thu Aug 24 10:45:05 2006
*************** void ScDocument::InsertMatrixFormula(SCC
*** 152,158 ****
  	if (pArr)
  		pCell = new ScFormulaCell( this, aPos, pArr, MM_FORMULA );
  	else
! 		pCell = new ScFormulaCell( this, aPos, rFormula, MM_FORMULA );
  	pCell->SetMatColsRows( nCol2 - nCol1 + 1, nRow2 - nRow1 + 1 );
  	for (i = 0; i <= MAXTAB; i++)
  	{
--- 152,158 ----
  	if (pArr)
  		pCell = new ScFormulaCell( this, aPos, pArr, MM_FORMULA );
  	else
! 		pCell = new ScFormulaCell( this, aPos, rFormula, ScAddress::CONV_UNSPECIFIED, MM_FORMULA );
  	pCell->SetMatColsRows( nCol2 - nCol1 + 1, nRow2 - nRow1 + 1 );
  	for (i = 0; i <= MAXTAB; i++)
  	{
*************** void ScDocument::InsertTableOp(const ScT
*** 283,289 ****
  	}
      aForString += ')';
  
!     ScFormulaCell aRefCell( this, ScAddress( nCol1, nRow1, nTab1 ), aForString, 0l );
      for( j = nCol1; j <= nCol2; j++ )
          for( k = nRow1; k <= nRow2; k++ )
              for (i = 0; i <= MAXTAB; i++)
--- 283,289 ----
  	}
      aForString += ')';
  
!     ScFormulaCell aRefCell( this, ScAddress( nCol1, nRow1, nTab1 ), aForString, ScAddress::CONV_OOO, 0l );
      for( j = nCol1; j <= nCol2; j++ )
          for( k = nRow1; k <= nRow2; k++ )
              for (i = 0; i <= MAXTAB; i++)
Index: sc/source/core/data/table6.cxx
===================================================================
RCS file: /cvs/sc/source/core/data/table6.cxx,v
diff -cpr sc/source/core/data/table6.cxx sc/source/core/data/table6.cxx
*** sc/source/core/data/table6.cxx	Fri Jul 21 07:10:15 2006
--- sc/source/core/data/table6.cxx	Thu Aug 24 10:45:05 2006
*************** BOOL ScTable::SearchCell(const SvxSearch
*** 118,124 ****
  			case SVX_SEARCHIN_FORMULA:
  			{
  				if ( eCellType == CELLTYPE_FORMULA )
! 					((ScFormulaCell*)pCell)->GetFormula( aString );
  				else if ( eCellType == CELLTYPE_EDIT )
  					bMultiLine = lcl_GetTextWithBreaks(
  						*(const ScEditCell*)pCell, pDocument, aString );
--- 118,124 ----
  			case SVX_SEARCHIN_FORMULA:
  			{
  				if ( eCellType == CELLTYPE_FORMULA )
! 					((ScFormulaCell*)pCell)->GetFormula( aString, ScAddress::CONV_OOO );
  				else if ( eCellType == CELLTYPE_EDIT )
  					bMultiLine = lcl_GetTextWithBreaks(
  						*(const ScEditCell*)pCell, pDocument, aString );
*************** BOOL ScTable::SearchCell(const SvxSearch
*** 281,287 ****
  				}
  				ScAddress aAdr( nCol, nRow, nTab );
  				ScFormulaCell* pFCell = new ScFormulaCell( pDocument, aAdr,
! 					aString, cMatrixFlag );
                  SCCOL nMatCols;
                  SCROW nMatRows;
  				((ScFormulaCell*)pCell)->GetMatColsRows( nMatCols, nMatRows );
--- 281,287 ----
  				}
  				ScAddress aAdr( nCol, nRow, nTab );
  				ScFormulaCell* pFCell = new ScFormulaCell( pDocument, aAdr,
! 					aString, ScAddress::CONV_OOO, cMatrixFlag );
                  SCCOL nMatCols;
                  SCROW nMatRows;
  				((ScFormulaCell*)pCell)->GetMatColsRows( nMatCols, nMatRows );
Index: sc/source/core/inc/interpre.hxx
===================================================================
RCS file: /cvs/sc/source/core/inc/interpre.hxx,v
diff -cpr sc/source/core/inc/interpre.hxx sc/source/core/inc/interpre.hxx
*** sc/source/core/inc/interpre.hxx	Wed Aug 23 16:41:35 2006
--- sc/source/core/inc/interpre.hxx	Thu Aug 24 10:45:05 2006
*************** void ScDBStdDevP();
*** 424,430 ****
--- 424,432 ----
  void ScDBVar();
  void ScDBVarP();
  void ScIndirect();
+ void ScIndirectXL();
  void ScAdress();
+ void ScAdressXL();
  void ScOffset();
  void ScIndex();
  void ScMultiArea();
Index: sc/source/core/src/compiler.src
===================================================================
RCS file: /cvs/sc/source/core/src/compiler.src,v
diff -cpr sc/source/core/src/compiler.src sc/source/core/src/compiler.src
*** sc/source/core/src/compiler.src	Wed Aug 23 16:41:35 2006
--- sc/source/core/src/compiler.src	Thu Aug 24 10:45:05 2006
*************** Resource RID_SC_FUNCTION_NAMES
*** 1092,1103 ****
--- 1092,1115 ----
  		Text [ en-US ] = "INDIRECT" ;
  		Text [ x-comment ] = " ";
  	};
+ 	String SC_OPCODE_INDIRECT_XL
+ 	{
+ 		Text [ de ] = "INDIREKT_XL" ;
+ 		Text [ en-US ] = "INDIRECT_XL" ;
+ 		Text [ x-comment ] = " ";
+ 	};
  	String SC_OPCODE_ADRESS
  	{
  		Text [ de ] = "ADRESSE" ;
  		Text [ en-US ] = "ADDRESS" ;
  		Text [ x-comment ] = " ";
  	};
+ 	String SC_OPCODE_ADRESS_XL
+ 	{
+ 		Text [ de ] = "ADRESSE_XL" ;
+ 		Text [ en-US ] = "ADDRESS_XL" ;
+ 		Text [ x-comment ] = " ";
+ 	};
  	String SC_OPCODE_MATCH
  	{
  		Text [ de ] = "VERGLEICH" ;
*************** Resource RID_SC_FUNCTION_NAMES_ENGLISH
*** 1879,1885 ****
--- 1891,1899 ----
  	String SC_OPCODE_DB_VAR { Text = "DVAR" ; };
  	String SC_OPCODE_DB_VAR_P { Text = "DVARP" ; };
  	String SC_OPCODE_INDIRECT { Text = "INDIRECT" ; };
+ 	String SC_OPCODE_INDIRECT_XL { Text = "INDIRECT_XL" ; };
  	String SC_OPCODE_ADRESS { Text = "ADDRESS" ; };
+ 	String SC_OPCODE_ADRESS_XL { Text = "ADDRESS_XL" ; };
  	String SC_OPCODE_MATCH { Text = "MATCH" ; };
  	String SC_OPCODE_COUNT_EMPTY_CELLS { Text = "COUNTBLANK" ; };
  	String SC_OPCODE_COUNT_IF { Text = "COUNTIF" ; };
Index: sc/source/core/tool/address.cxx
===================================================================
RCS file: /cvs/sc/source/core/tool/address.cxx,v
diff -cpr sc/source/core/tool/address.cxx sc/source/core/tool/address.cxx
*** sc/source/core/tool/address.cxx	Fri Jul 21 07:14:45 2006
--- sc/source/core/tool/address.cxx	Thu Aug 24 22:55:23 2006
***************
*** 36,55 ****
  // MARKER(update_precomp.py): autogen include statement, do not remove
  #include "precompiled_sc.hxx"
  
- 
  #include "address.hxx"
  #include "global.hxx"
  #include "compiler.hxx"
  #include "document.hxx"
  
  #include "globstr.hrc"
  
  
! USHORT lcl_ConvertSingleRef( BOOL& bExternal, const sal_Unicode* p,
!             ScDocument* pDoc, ScAddress& rAddr )
  {
!     if ( !*p )
          return 0;
      USHORT  nRes = 0;
      String  aDocName;       // der pure Dokumentenname
      String  aDocTab;        // zusammengesetzt fuer Table
--- 36,591 ----
  // MARKER(update_precomp.py): autogen include statement, do not remove
  #include "precompiled_sc.hxx"
  
  #include "address.hxx"
  #include "global.hxx"
  #include "compiler.hxx"
  #include "document.hxx"
  
  #include "globstr.hrc"
+ #include <sal/alloca.h>
+ 
+ ////////////////////////////////////////////////////////////////////////////
+ const ScAddress::Details ScAddress::detailsOOOa1( CONV_OOO, 0, 0 );
+ 
+ ScAddress::Details::Details ( const ScDocument* pDoc,
+ 							  const ScAddress & rAddr ) :
+ 	eConv( pDoc->GetAddressConvention() ),
+ 	nRow( rAddr.Row() ),
+ 	nCol( rAddr.Col() )
+ {
+ }
+ 
+ void ScAddress::Details::SetPos ( const ScDocument* pDoc,
+ 								  const ScAddress & rAddr )
+ {
+ 	nRow  = rAddr.Row();
+ 	nCol  = rAddr.Col();
+ 	eConv = pDoc->GetAddressConvention();
+ }
+ 
+ ////////////////////////////////////////////////////////////////////////////
  
+ #include <iostream>
+ 
+ static long int
+ sal_Unicode_strtol ( const sal_Unicode*  p,
+ 					 const sal_Unicode** pEnd )
+ {
+ 	long int accum = 0, prev = 0;
+ 	bool is_neg = false;
+ 
+ 	if( *p == '-' )
+ 	{
+ 		is_neg = true;
+ 		p++;
+ 	}
+ 	else if( *p == '+' )
+ 		p++;
+ 
+ 	while (CharClass::isAsciiDigit( *p ))
+ 	{
+ 		accum = accum * 10 + *p - '0';
+ 		if( accum < prev )
+ 		{
+ 			*pEnd = NULL;
+ 			return 0;
+ 		}
+ 		prev = accum;
+ 		p++;
+ 	}
+ 
+ 	*pEnd = p;
+ 	return is_neg ? -accum : accum;
+ }
  
! // Returns NULL if the string should be a sheet name, but is invalid
! // Returns a pointer to the first character after the sheet name
! static const sal_Unicode *
! lcl_XL_ParseSheetRef( const sal_Unicode *start,
! 					  ScAddress *pAddr,
! 					  const ScDocument* pDoc,
! 					  const String& rDocName,
! 					  bool allow_3d )
  {
! 	String aTabName;
! 	SCTAB  nTab;
! 	const sal_Unicode *p = start;
! 
! 	pAddr->SetTab( 0 );
! 	if( *p == '\'' ) // XL only seems to use single quotes for sheet names
! 	{
! 		for( p++; *p ; )
! 		{
! 			if( *p == '\'' )
! 			{
! 				if( p[1] != '\'' )	// end quote
! 					break;
! 				p++;	// 2 quotes in a row are a quote in a the name
! 			}
! 			aTabName += *p++;
! 		}
! 		if( *p++ != '\'' )
! 			return NULL;
! 	}
! 	else
! 	{
! 		bool only_digits = TRUE;
! 
! 		/*
! 		 * Valid: Normal!a1
! 		 * Valid: x.y!a1
! 		 * Invalid: .y!a1
! 		 *
! 		 * Some names starting with digits are actually valid, but
! 		 * unparse quoted. Things are quite tricky: most sheet names
! 		 * starting with a digit are ok, but not those starting with
! 		 * "[0-9]*\." or "[0-9]+[eE]".
! 		 * 
! 		 * Valid: 42!a1
! 		 * Valid: 4x!a1
! 		 * Invalid: 1.!a1
! 		 * Invalid: 1e!a1
! 		 */
! 		while( 1 )
! 		{
! 			const sal_Unicode uc = *p;
! 			if( CharClass::isAsciiAlpha( uc ) || uc == '_' )
! 			{
! 				if( only_digits && p != start &&
! 				   (uc == 'e' || uc == 'E' ) )
! 				{
! 					p = start;
! 					break;
! 				}
! 				only_digits = FALSE;
! 				p++;
! 			}
! 			else if( CharClass::isAsciiDigit( uc ))
! 			{
! 				p++;
! 			}
! 			else if( uc == '.' )
! 			{
! 				if( only_digits ) // Valid, except after only digits.
! 				{
! 					p = start;
! 					break;
! 				}
! 				p++;
! 			} else 
! 				break;
! 		}
! 
! 		if( *p != '!' &&( !allow_3d || *p != ':' ) )
! 			return start;
! 
! 		aTabName.Append( start, p - start );
! 	}
! 
! 	if( pDoc )
! 	{
! 		if( rDocName.Len() > 0 )
! 		{
! 			// TODO : Check with er if this is valid simplification
! 			// 		  The OOo parser constructs aDocTab manually first, and
! 			// 		  only does this lookup if that fails
! 			//
! 			String aDocTab = ScGlobal::GetDocTabName( rDocName, aTabName );
! 			if( !pDoc->GetTable( aDocTab, nTab ) &&
! 				pDoc->ValidTabName( aTabName ) )
! 			{
! 				if( !pDoc->GetTable( aDocTab, nTab ) )
! 				{
! #if 0
! // FIXME FIXME FIXME : Ah!
! // This is what is crashing things for broken refs.
! // Change the interface to do this link later
! 					// erst einfuegen, wenn Rest der Ref ok
! 					if( !pDoc->LinkExternalTab( nTab, rDocName, aTabName ) )
! 						return NULL;
! #endif
! 				}
! 			}
! 		}
! 		else if( !pDoc->GetTable( aTabName, nTab ) )
! 			return start;
! 	}
! 
! 	pAddr->SetTab( nTab );
! 	return p;
! }
! 
! static const sal_Unicode*
! lcl_ScRange_Parse_XL_Header( ScRange& r,
! 							 const sal_Unicode* p,
! 							 const ScDocument* pDoc,
! 							 USHORT& nFlags )
! {
! 	const sal_Unicode* startTabs, *start = p;
! 	String aDocName;
! 
! 	// Is this an external reference ?
! 	if( *p == '[' )
! 	{
! 		p++;
! 		// TODO : Get more detail on how paths are quoted
! 		// 1) I suspect only single quote is correct
! 		// 2) check whether this is another doubled quote rather than a
! 		// 	  backslash
! 		if( *p == '\'' || *p == '\"' )
! 		{
! 			for( const sal_Unicode cQuote = *p++; *p && *p != cQuote ; )
! 			{
! 				if( *p == '\\' && p[1] )
! 					p++;
! 				aDocName += *p++;
! 			}
! 		}
! 		else
! 		{
! 			p = ScGlobal::UnicodeStrChr( start+1, ']' );
! 			if( p == NULL )
! 				return start;
! 			aDocName.Append( start+1, p-(start+1) );
! 		}
! 
! 		aDocName = ScGlobal::GetAbsDocName( aDocName,
! 			pDoc->GetDocumentShell() );
! 		if( *p != ']' )
! 			return start;
! 		p++;
! 	}
! 
! 	startTabs = p;
! 	p = lcl_XL_ParseSheetRef( p, &r.aStart, pDoc, aDocName, TRUE );
! 	if( NULL == p )
! 		return start;		// invalid tab
! 	if( p != startTabs )
! 	{
! 		nFlags |= SCA_VALID_TAB | SCA_TAB_3D | SCA_TAB_ABSOLUTE;
! 		if( *p == ':' )	// 3d ref
! 		{
! 			p = lcl_XL_ParseSheetRef( p+1, &r.aEnd, pDoc, aDocName, FALSE );
! 			if( p == NULL )
! 				return start; // invalid tab
! 			nFlags |= SCA_VALID_TAB2 | SCA_TAB2_3D | SCA_TAB2_ABSOLUTE;
! 		}
! 		else
! 			r.aEnd.SetTab( 0 );
! 
! 		if( *p++ != '!' )
! 			return start;	// syntax error
! 	}
! 	else
! 	{
! 		nFlags |= SCA_VALID_TAB | SCA_VALID_TAB2;
! 		r.aEnd.SetTab( 0 );
! 	}
! 
! 	return p;
! }
! 
! static const sal_Unicode*
! lcl_r1c1_get_col( const sal_Unicode* p,
! 				  const ScAddress::Details& rDetails,
! 				  ScAddress* pAddr, USHORT* nFlags )
! {
! 	const sal_Unicode *pEnd;
! 	long int n;
! 	bool isRelative;
! 
! 	if( p[0] == '\0' )
! 		return NULL;
! 
! 	p++;
! 	if( (isRelative = (*p == '[') ) )
! 		p++;
! 	n = sal_Unicode_strtol( p, &pEnd );
! 	if( NULL == pEnd )
! 		return NULL;
! 
! 	if( p == pEnd )	// C is a relative ref with offset 0
! 	{
! 		if( isRelative )
! 			return NULL;
! 		n = rDetails.nCol;
! 	}
! 	else if( isRelative )
! 	{
! 		if( *pEnd != ']' )
! 			return NULL;
! 		n += rDetails.nCol;
! 		pEnd++;
! 	}
! 	else
! 	{
! 		*nFlags |= SCA_COL_ABSOLUTE;
! 		n--;
! 	}
! 
! 	if( n < 0 || n >= MAXCOLCOUNT )
! 		return NULL;
! 	pAddr->SetCol( static_cast<SCROW>( n ) );
! 	*nFlags |= SCA_VALID_COL;
! 
! 	return pEnd;
! }
! static inline const sal_Unicode*
! lcl_r1c1_get_row( const sal_Unicode* p,
! 				  const ScAddress::Details& rDetails,
! 				  ScAddress* pAddr, USHORT* nFlags )
! {
! 	const sal_Unicode *pEnd;
! 	long int n;
! 	bool isRelative;
! 
! 	if( p[0] == '\0' )
! 		return NULL;
! 
! 	p++;
! 	if( (isRelative = (*p == '[') ) )
! 		p++;
! 	n = sal_Unicode_strtol( p, &pEnd );
! 	if( NULL == pEnd )
! 		return NULL;
! 
! 	if( p == pEnd )	// R is a relative ref with offset 0
! 	{
! 		if( isRelative )
! 			return NULL;
! 		n = rDetails.nRow;
! 	}
! 	else if( isRelative )
! 	{
! 		if( *pEnd != ']' )
! 			return NULL;
! 		n += rDetails.nRow;
! 		pEnd++;
! 	}
! 	else
! 	{
! 		*nFlags |= SCA_ROW_ABSOLUTE;
! 		n--;
! 	}
! 
! 	if( n < 0 || n >= MAXROWCOUNT )
! 		return NULL;
! 	pAddr->SetRow( static_cast<SCROW>( n ) );
! 	*nFlags |= SCA_VALID_ROW;
! 
! 	return pEnd;
! }
! 
! static USHORT
! lcl_ScRange_Parse_XL_R1C1( ScRange& r,
! 						   const sal_Unicode* p,
! 						   const ScDocument* pDoc,
! 						   const ScAddress::Details& rDetails,
! 						   BOOL bOnlyAcceptSingle )
! {
! 	const sal_Unicode* pTmp;
! 	USHORT nFlags = SCA_VALID | SCA_VALID_TAB, nFlags2 = SCA_VALID_TAB2;
! 
! #if 1
! 	{
! 		ByteString	aStr(p, RTL_TEXTENCODING_UTF8);
! 		aStr.Append(static_cast< char >(0));
! 		std::cerr << "parse::XL::R1C1 \'" << aStr.GetBuffer() << '\'' << std::endl;
! 	}
! #endif
! 	p = lcl_ScRange_Parse_XL_Header( r, p, pDoc, nFlags );
! 	if( NULL == p )
! 		return 0;
! 
! 	if( *p == 'R' || *p == 'r' )
! 	{
! 		if( NULL == (p = lcl_r1c1_get_row( p, rDetails, &r.aStart, &nFlags )) )
! 			goto failed;
! 
! 		if( *p != 'C' && *p != 'c' )	// full row R#
! 		{
! 			if( p[0] != ':' || (p[1] != 'R' && p[1] != 'r' ) ||
! 				NULL == (pTmp = lcl_r1c1_get_row( p+1, rDetails, &r.aEnd, &nFlags2 )))
! 			{	// Fallback to just the initial R
! 				nFlags |= (nFlags << 4);
! 				r.aEnd.SetRow( r.aStart.Row() );
! 			} else
! 				nFlags |= (nFlags2 << 4);
! 
! 			nFlags |= 
! 				SCA_VALID_COL | SCA_VALID_COL2 |
! 				SCA_COL_ABSOLUTE | SCA_COL2_ABSOLUTE;
! 			r.aStart.SetCol( 0 );
! 			r.aEnd.SetCol( MAXCOL );
! 
! 			return bOnlyAcceptSingle ? 0 : nFlags;
! 		}
! 		else if( NULL == (p = lcl_r1c1_get_col( p, rDetails, &r.aStart, &nFlags )))
! 			goto failed;
! 
! 		if( p[0] != ':' ||
! 			(p[1] != 'R' && p[1] != 'r') ||
! 		    NULL == (pTmp = lcl_r1c1_get_row( p+1, rDetails, &r.aEnd, &nFlags2 )) ||
! 		    (*pTmp != 'C' && *pTmp != 'c') ||
! 		    NULL == (pTmp = lcl_r1c1_get_col( pTmp, rDetails, &r.aEnd, &nFlags2 )))
! 		{
! 			return bOnlyAcceptSingle ? nFlags : 0;
! 		}
! 
! 		nFlags |= (nFlags2 << 4);
! 		return bOnlyAcceptSingle ? 0 : nFlags;
! 	}
! 	else if( *p == 'C' || *p == 'c' )	// full col C#
! 	{
! 		if( NULL == (p = lcl_r1c1_get_col( p, rDetails, &r.aStart, &nFlags )))
! 			goto failed;
! 
! 		if( p[0] != ':' || (p[1] != 'C' && p[1] != 'c') ||
! 			NULL == (pTmp = lcl_r1c1_get_col( p, rDetails, &r.aEnd, &nFlags2 )))
! 		{	 // Fallback to just the initial C
! 			nFlags |= (nFlags << 4);
! 			r.aEnd.SetCol( r.aStart.Col() );
! 		}
! 		else
! 			nFlags |= (nFlags2 << 4);
! 
! 		nFlags |= 
! 			SCA_VALID_ROW | SCA_VALID_ROW2 |
! 			SCA_ROW_ABSOLUTE | SCA_ROW2_ABSOLUTE;
! 		r.aStart.SetRow( 0 );
! 		r.aEnd.SetRow( MAXROW );
! 
! 		return bOnlyAcceptSingle ? 0 : nFlags;
! 	}
! 
! failed :
! 	return 0;
! }
! 
! static inline const sal_Unicode*
! lcl_a1_get_col( const sal_Unicode* p, ScAddress* pAddr, USHORT* nFlags )
! {
!     SCCOL nCol;
! 
! 	if( *p == '$' )
! 		*nFlags |= SCA_COL_ABSOLUTE, p++;
! 
! 	if( !CharClass::isAsciiAlpha( *p ) )
! 		return NULL;
! 
! 	nCol = toupper( char(*p++) ) - 'A';
! 	while (nCol <= MAXCOL && CharClass::isAsciiAlpha(*p))
! 		nCol = ((nCol + 1) * 26) + toupper( char(*p++) ) - 'A';
! 	if( nCol > MAXCOL || CharClass::isAsciiAlpha( *p ) )
! 		return NULL;
! 
! 	*nFlags |= SCA_VALID_COL;
! 	pAddr->SetCol( nCol );
! 
! 	return p;
! }
! 
! static inline const sal_Unicode*
! lcl_a1_get_row( const sal_Unicode* p, ScAddress* pAddr, USHORT* nFlags )
! {
! 	const sal_Unicode *pEnd;
! 	long int n;
! 
! 	if( *p == '$' )
! 		*nFlags |= SCA_ROW_ABSOLUTE, p++;
! 
! 	n = sal_Unicode_strtol( p, &pEnd ) - 1;
! 	if( NULL == pEnd || p == pEnd || n < 0 || n > MAXROW )
! 		return NULL;
! 
! 	*nFlags |= SCA_VALID_ROW;
! 	pAddr->SetRow( static_cast<SCROW>(n) );
! 
! 	return pEnd;
! }
! 
! static USHORT
! lcl_ScRange_Parse_XL_A1( ScRange& r,
! 						 const sal_Unicode* p,
! 						 const ScDocument* pDoc,
! 						 BOOL bOnlyAcceptSingle )
! {
! 	const sal_Unicode* tmp1, *tmp2;
! 	USHORT nFlags = SCA_VALID | SCA_VALID_TAB, nFlags2 = SCA_VALID_TAB2;
! 
! #if 1
! 	{
! 		ByteString	aStr(p, RTL_TEXTENCODING_UTF8);
! 		aStr.Append(static_cast< char >(0));
! 		std::cerr << "parse::XL::A1 \'" << aStr.GetBuffer() << '\'' << std::endl;
! 	}
! #endif
! 	p = lcl_ScRange_Parse_XL_Header( r, p, pDoc, nFlags );
! 	if( NULL == p )
! 		return 0;
! 
! 	tmp1 = lcl_a1_get_col( p, &r.aStart, &nFlags );
! 	if( tmp1 == NULL )			// Is it a row only reference 3:5
! 	{
! 		if( bOnlyAcceptSingle )	// by definition full row refs are ranges
! 			return 0;
! 
! 		tmp1 = lcl_a1_get_row( p, &r.aStart, &nFlags );
! 		if( !tmp1 || *tmp1++ != ':' ) // Even a singleton requires ':' (eg 2:2)
! 			return 0;
! 		tmp2 = lcl_a1_get_row( tmp1, &r.aEnd, &nFlags2 );
! 		if( !tmp2 )
! 			return 0;
! 
! 		r.aStart.SetCol( 0 ); r.aEnd.SetCol( MAXCOL );
! 		nFlags |= 
! 			SCA_VALID_COL | SCA_VALID_COL2 |
! 			SCA_COL_ABSOLUTE | SCA_COL2_ABSOLUTE;
! 		nFlags |= (nFlags2 << 4);
! 		return nFlags;
! 	}
! 
! 	tmp2 = lcl_a1_get_row( tmp1, &r.aStart, &nFlags );
! 	if( tmp2 == NULL )			// check for col only reference F:H
! 	{
! 		if( bOnlyAcceptSingle )	// by definition full col refs are ranges
! 			return 0;
! 
! 		if( *tmp1++ != ':' )	// Even a singleton requires ':' (eg F:F)
! 			return 0;
! 		tmp2 = lcl_a1_get_col( tmp1, &r.aEnd, &nFlags2 );
! 		if( !tmp2 )
          return 0;
+ 
+ 		r.aStart.SetRow( 0 ); r.aEnd.SetRow( MAXROW );
+ 		nFlags |= 
+ 			SCA_VALID_ROW | SCA_VALID_ROW2 |
+ 			SCA_ROW_ABSOLUTE | SCA_ROW2_ABSOLUTE;
+ 		nFlags |= (nFlags2 << 4);
+ 		return nFlags;
+ 	}
+ 
+ 	// prepare as if it's a singleton, in case we want to fall back */
+ 	r.aEnd = r.aStart;
+ 	if( *tmp2 != ':' )
+ 		return nFlags;
+ 
+ 	p = tmp2;
+ 	tmp1 = lcl_a1_get_col( p+1, &r.aEnd, &nFlags2 );
+ 	if( !tmp1 )
+ 		return nFlags;	// strange, but valid singleton
+ 	tmp2 = lcl_a1_get_row( tmp1, &r.aEnd, &nFlags2 );
+ 	if( !tmp2 )
+ 		return nFlags;	// strange, but valid singleton
+ 
+ 	nFlags |= (nFlags2 << 4);
+ 	return nFlags;
+ }
+ 
+ static USHORT
+ lcl_ScAddress_Parse_OOo( BOOL& bExternal, const sal_Unicode* p,
+ 						 ScDocument* pDoc, ScAddress& rAddr )
+ {
      USHORT  nRes = 0;
      String  aDocName;       // der pure Dokumentenname
      String  aDocTab;        // zusammengesetzt fuer Table
*************** USHORT lcl_ConvertSingleRef( BOOL& bExte
*** 217,229 ****
      return nRes;
  }
  
  
  bool ConvertSingleRef( ScDocument* pDoc, const String& rRefString,
!             SCTAB nDefTab, ScRefAddress& rRefAddress )
  {
      BOOL bExternal = FALSE;
      ScAddress aAddr( 0, 0, nDefTab );
!     USHORT nRes = lcl_ConvertSingleRef( bExternal, rRefString.GetBuffer(), pDoc, aAddr );
      if( nRes & SCA_VALID )
      {
          rRefAddress.Set( aAddr,
--- 753,799 ----
      return nRes;
  }
  
+ static USHORT
+ lcl_ScAddress_Parse ( BOOL& bExternal, const sal_Unicode* p,
+ 					  ScDocument* pDoc, ScAddress& rAddr,
+ 					  const ScAddress::Details& rDetails )
+ {
+     if( !*p )
+         return 0;
+ 
+ 	switch (rDetails.eConv)
+ 	{
+ 	default :
+ 	case ScAddress::CONV_OOO:
+ 		{
+ 			return lcl_ScAddress_Parse_OOo( bExternal, p, pDoc, rAddr );
+ 		}
+ 
+ 	case ScAddress::CONV_XL_A1:
+ 		{
+ 			ScRange r;
+ 			USHORT nFlags = lcl_ScRange_Parse_XL_A1( r, p, pDoc, TRUE );
+ 			rAddr = r.aStart;
+ 			return nFlags;
+ 		}
+ 	case ScAddress::CONV_XL_R1C1:
+ 		{
+ 			ScRange r;
+ 			USHORT nFlags = lcl_ScRange_Parse_XL_R1C1( r, p, pDoc, rDetails, TRUE );
+ 			rAddr = r.aStart;
+ 			return nFlags;
+ 		}
+ 	}
+ }
+ 
  
  bool ConvertSingleRef( ScDocument* pDoc, const String& rRefString,
! 					   SCTAB nDefTab, ScRefAddress& rRefAddress,
! 					   const ScAddress::Details& rDetails )
  {
      BOOL bExternal = FALSE;
      ScAddress aAddr( 0, 0, nDefTab );
!     USHORT nRes = lcl_ScAddress_Parse( bExternal, rRefString.GetBuffer(), pDoc, aAddr, rDetails );
      if( nRes & SCA_VALID )
      {
          rRefAddress.Set( aAddr,
*************** bool ConvertSingleRef( ScDocument* pDoc,
*** 238,244 ****
  
  
  bool ConvertDoubleRef( ScDocument* pDoc, const String& rRefString, SCTAB nDefTab,
!             ScRefAddress& rStartRefAddress, ScRefAddress& rEndRefAddress )
  {
      BOOL bRet = FALSE;
      xub_StrLen nPos = rRefString.Search(':');
--- 808,815 ----
  
  
  bool ConvertDoubleRef( ScDocument* pDoc, const String& rRefString, SCTAB nDefTab,
! 					   ScRefAddress& rStartRefAddress, ScRefAddress& rEndRefAddress,
! 					   const ScAddress::Details& rDetails )
  {
      BOOL bRet = FALSE;
      xub_StrLen nPos = rRefString.Search(':');
*************** bool ConvertDoubleRef( ScDocument* pDoc,
*** 247,266 ****
          String aTmp( rRefString );
          sal_Unicode* p = aTmp.GetBufferAccess();
          p[ nPos ] = 0;
!         if ( ConvertSingleRef( pDoc, p, nDefTab, rStartRefAddress ) )
          {
              nDefTab = rStartRefAddress.Tab();
!             bRet = ConvertSingleRef( pDoc, p + nPos + 1, nDefTab, rEndRefAddress );
          }
      }
      return bRet;
  }
  
  
! USHORT ScAddress::Parse( const String& r, ScDocument* pDoc )
  {
      BOOL bExternal = FALSE;
!     return lcl_ConvertSingleRef( bExternal, r.GetBuffer(), pDoc, *this );
  }
  
  
--- 818,838 ----
          String aTmp( rRefString );
          sal_Unicode* p = aTmp.GetBufferAccess();
          p[ nPos ] = 0;
!         if( ConvertSingleRef( pDoc, p, nDefTab, rStartRefAddress, rDetails ) )
          {
              nDefTab = rStartRefAddress.Tab();
!             bRet = ConvertSingleRef( pDoc, p + nPos + 1, nDefTab, rEndRefAddress, rDetails );
          }
      }
      return bRet;
  }
  
  
! USHORT ScAddress::Parse( const String& r, ScDocument* pDoc,
! 						 const Details& rDetails)
  {
      BOOL bExternal = FALSE;
!     return lcl_ScAddress_Parse( bExternal, r.GetBuffer(), pDoc, *this, rDetails );
  }
  
  
*************** void ScRange::ExtendTo( const ScRange& r
*** 328,339 ****
          *this = rRange;
  }
  
! 
! USHORT ScRange::Parse( const String& r, ScDocument* pDoc )
  {
      USHORT nRes1 = 0, nRes2 = 0;
      xub_StrLen nTmp = 0;
      xub_StrLen nPos = STRING_NOTFOUND;
      while ( (nTmp = r.Search( ':', nTmp )) != STRING_NOTFOUND )
          nPos = nTmp++;      // der letzte zaehlt, koennte 'd:\...'!a1:a2 sein
      if (nPos != STRING_NOTFOUND)
--- 900,913 ----
          *this = rRange;
  }
  
! static USHORT
! lcl_ScRange_Parse_OOo( ScRange &aRange, const String& r, ScDocument* pDoc )
  {
      USHORT nRes1 = 0, nRes2 = 0;
      xub_StrLen nTmp = 0;
      xub_StrLen nPos = STRING_NOTFOUND;
+ 
+ 	// FIXME : why is ScAddress more flexible ?
      while ( (nTmp = r.Search( ':', nTmp )) != STRING_NOTFOUND )
          nPos = nTmp++;      // der letzte zaehlt, koennte 'd:\...'!a1:a2 sein
      if (nPos != STRING_NOTFOUND)
*************** USHORT ScRange::Parse( const String& r, 
*** 342,362 ****
          sal_Unicode* p = aTmp.GetBufferAccess();
          p[ nPos ] = 0;
          BOOL bExternal = FALSE;
!         if( nRes1 = lcl_ConvertSingleRef( bExternal, p, pDoc, aStart ) )
          {
!             aEnd = aStart;  // die Tab _muss_ gleich sein, so ist`s weniger Code
!             if ( nRes2 = lcl_ConvertSingleRef( bExternal, p + nPos+ 1, pDoc, aEnd ) )
              {
!                 if ( bExternal && aStart.Tab() != aEnd.Tab() )
                      nRes2 &= ~SCA_VALID_TAB;    // #REF!
                  else
                  {
                      // PutInOrder / Justify
                      USHORT nMask, nBits1, nBits2;
                      SCCOL nTempCol;
!                     if ( aEnd.Col() < (nTempCol = aStart.Col()) )
                      {
!                         aStart.SetCol(aEnd.Col()); aEnd.SetCol(nTempCol);
                          nMask = (SCA_VALID_COL | SCA_COL_ABSOLUTE);
                          nBits1 = nRes1 & nMask;
                          nBits2 = nRes2 & nMask;
--- 916,936 ----
          sal_Unicode* p = aTmp.GetBufferAccess();
          p[ nPos ] = 0;
          BOOL bExternal = FALSE;
!         if( (nRes1 = lcl_ScAddress_Parse_OOo( bExternal, p, pDoc, aRange.aStart ) ) )
          {
!             aRange.aEnd = aRange.aStart;  // die Tab _muss_ gleich sein, so ist`s weniger Code
!             if ( (nRes2 = lcl_ScAddress_Parse_OOo( bExternal, p + nPos+ 1, pDoc, aRange.aEnd ) ) )
              {
!                 if ( bExternal && aRange.aStart.Tab() != aRange.aEnd.Tab() )
                      nRes2 &= ~SCA_VALID_TAB;    // #REF!
                  else
                  {
                      // PutInOrder / Justify
                      USHORT nMask, nBits1, nBits2;
                      SCCOL nTempCol;
!                     if ( aRange.aEnd.Col() < (nTempCol = aRange.aStart.Col()) )
                      {
!                         aRange.aStart.SetCol(aRange.aEnd.Col()); aRange.aEnd.SetCol(nTempCol);
                          nMask = (SCA_VALID_COL | SCA_COL_ABSOLUTE);
                          nBits1 = nRes1 & nMask;
                          nBits2 = nRes2 & nMask;
*************** USHORT ScRange::Parse( const String& r, 
*** 364,372 ****
                          nRes2 = (nRes2 & ~nMask) | nBits1;
                      }
                      SCROW nTempRow;
!                     if ( aEnd.Row() < (nTempRow = aStart.Row()) )
                      {
!                         aStart.SetRow(aEnd.Row()); aEnd.SetRow(nTempRow);
                          nMask = (SCA_VALID_ROW | SCA_ROW_ABSOLUTE);
                          nBits1 = nRes1 & nMask;
                          nBits2 = nRes2 & nMask;
--- 938,946 ----
                          nRes2 = (nRes2 & ~nMask) | nBits1;
                      }
                      SCROW nTempRow;
!                     if ( aRange.aEnd.Row() < (nTempRow = aRange.aStart.Row()) )
                      {
!                         aRange.aStart.SetRow(aRange.aEnd.Row()); aRange.aEnd.SetRow(nTempRow);
                          nMask = (SCA_VALID_ROW | SCA_ROW_ABSOLUTE);
                          nBits1 = nRes1 & nMask;
                          nBits2 = nRes2 & nMask;
*************** USHORT ScRange::Parse( const String& r, 
*** 374,382 ****
                          nRes2 = (nRes2 & ~nMask) | nBits1;
                      }
                      SCTAB nTempTab;
!                     if ( aEnd.Tab() < (nTempTab = aStart.Tab()) )
                      {
!                         aStart.SetTab(aEnd.Tab()); aEnd.SetTab(nTempTab);
                          nMask = (SCA_VALID_TAB | SCA_TAB_ABSOLUTE | SCA_TAB_3D);
                          nBits1 = nRes1 & nMask;
                          nBits2 = nRes2 & nMask;
--- 948,956 ----
                          nRes2 = (nRes2 & ~nMask) | nBits1;
                      }
                      SCTAB nTempTab;
!                     if ( aRange.aEnd.Tab() < (nTempTab = aRange.aStart.Tab()) )
                      {
!                         aRange.aStart.SetTab(aRange.aEnd.Tab()); aRange.aEnd.SetTab(nTempTab);
                          nMask = (SCA_VALID_TAB | SCA_TAB_ABSOLUTE | SCA_TAB_3D);
                          nBits1 = nRes1 & nMask;
                          nBits2 = nRes2 & nMask;
*************** USHORT ScRange::Parse( const String& r, 
*** 399,422 ****
      return nRes1;
  }
  
  
! USHORT ScRange::ParseAny( const String& r, ScDocument* pDoc )
  {
!     USHORT nRet = Parse( r, pDoc );
      const USHORT nValid = SCA_VALID | SCA_VALID_COL2 | SCA_VALID_ROW2 |
          SCA_VALID_TAB2;
      if ( (nRet & nValid) != nValid )
      {
          ScAddress aAdr;
!         nRet = aAdr.Parse( r, pDoc );
          if ( nRet & SCA_VALID )
              aStart = aEnd = aAdr;
      }
      return nRet;
  }
  
  
! void ScAddress::Format( String& r, USHORT nFlags, ScDocument* pDoc ) const
  {
      r.Erase();
      if( nFlags & SCA_VALID )
--- 973,1088 ----
      return nRes1;
  }
  
+ USHORT ScRange::Parse( const String& r, ScDocument* pDoc,
+ 					   const ScAddress::Details& rDetails )
+ {
+     if ( r.Len() <= 0 )
+         return 0;
  
! 	switch (rDetails.eConv)
! 	{
! 	default :
! 	case ScAddress::CONV_OOO:
! 		return lcl_ScRange_Parse_OOo( *this, r, pDoc );
! 
! 	case ScAddress::CONV_XL_A1:
! 		return lcl_ScRange_Parse_XL_A1( *this, r.GetBuffer(), pDoc, FALSE );
! 
! 	case ScAddress::CONV_XL_R1C1:
! 		return lcl_ScRange_Parse_XL_R1C1( *this, r.GetBuffer(), pDoc, rDetails, FALSE );
! 	}
! }
! 
! 
! // Accept a full range, or an address
! USHORT ScRange::ParseAny( const String& r, ScDocument* pDoc,
! 						  const ScAddress::Details& rDetails )
  {
!     USHORT nRet = Parse( r, pDoc, rDetails );
      const USHORT nValid = SCA_VALID | SCA_VALID_COL2 | SCA_VALID_ROW2 |
          SCA_VALID_TAB2;
+ 
      if ( (nRet & nValid) != nValid )
      {
          ScAddress aAdr;
!         nRet = aAdr.Parse( r, pDoc, rDetails );
          if ( nRet & SCA_VALID )
              aStart = aEnd = aAdr;
      }
      return nRet;
  }
  
+ // Parse only full row references
+ USHORT ScRange::ParseCols( const String& r, ScDocument* pDoc,
+ 						   const ScAddress::Details& rDetails )
+ {
+ 	return 0;
+ }
  
! // Parse only full row references
! USHORT ScRange::ParseRows( const String& r, ScDocument* pDoc,
! 						   const ScAddress::Details& rDetails )
! {
! 	return 0;
! }
! 
! static inline void
! lcl_a1_append_c ( String &r, int nCol, bool bIsAbs )
! {
! 	if( bIsAbs )
! 		r += '$';
! 	ColToAlpha( r, nCol );
! }
! 
! static inline void
! lcl_a1_append_r ( String &r, int nRow, bool bIsAbs )
! {
! 	if ( bIsAbs )
! 		r += '$';
! 	r += String::CreateFromInt32( nRow+1 );
! }
! 
! static inline void
! lcl_r1c1_append_c ( String &r, int nCol, bool bIsAbs,
! 					const ScAddress::Details& rDetails )
! {
! 	r += 'C';
! 	if (bIsAbs)
! 	{
! 		r += String::CreateFromInt32( nCol + 1 );
! 	}
! 	else
! 	{
! 		nCol -= rDetails.nCol;
! 		if (nCol != 0) {
! 			r += '[';
! 			r += String::CreateFromInt32( nCol );
! 			r += ']';
! 		}
! 	}
! }
! static inline void
! lcl_r1c1_append_r ( String &r, int nRow, bool bIsAbs,
! 					const ScAddress::Details& rDetails )
! {
! 	r += 'R';
! 	if (bIsAbs)
! 	{
! 		r += String::CreateFromInt32( nRow + 1 );
! 	}
! 	else
! 	{
! 		nRow -= rDetails.nRow;
! 		if (nRow != 0) {
! 			r += '[';
! 			r += String::CreateFromInt32( nRow );
! 			r += ']';
! 		}
! 	}
! }
! 
! void ScAddress::Format( String& r, USHORT nFlags, ScDocument* pDoc,
! 						const Details& rDetails) const
  {
      r.Erase();
      if( nFlags & SCA_VALID )
*************** void ScAddress::Format( String& r, USHOR
*** 431,441 ****
  //      if( nFlags & ( SCA_TAB_ABSOLUTE | SCA_TAB_3D ) )
          if( nFlags & SCA_TAB_3D )
          {
!             String aTabName;
              pDoc->GetName( nTab, aTabName );
- 
              //  externe Referenzen (wie in ScCompiler::MakeTabStr)
-             String aDoc;
              if ( aTabName.GetChar(0) == '\'' )
              {   // "'Doc'#Tab"
                  xub_StrLen nPos, nLen = 1;
--- 1097,1105 ----
  //      if( nFlags & ( SCA_TAB_ABSOLUTE | SCA_TAB_3D ) )
          if( nFlags & SCA_TAB_3D )
          {
!             String aTabName, aDocName;
              pDoc->GetName( nTab, aTabName );
              //  externe Referenzen (wie in ScCompiler::MakeTabStr)
              if ( aTabName.GetChar(0) == '\'' )
              {   // "'Doc'#Tab"
                  xub_StrLen nPos, nLen = 1;
*************** void ScAddress::Format( String& r, USHOR
*** 444,487 ****
                      nLen = nPos + 1;
                  if ( aTabName.GetChar(nLen) == SC_COMPILER_FILE_TAB_SEP )
                  {
!                     aDoc = aTabName.Copy( 0, nLen + 1 );
                      aTabName.Erase( 0, nLen + 1 );
                  }
              }
!             r += aDoc;
  
!             if( nFlags & SCA_TAB_ABSOLUTE )
!                 r += '$';
!             ScCompiler::CheckTabQuotes( aTabName );
!             r += aTabName;
!             r += '.';
!         }
!     }
!     if( nFlags & SCA_VALID_COL )
!     {
!         if( nFlags & SCA_COL_ABSOLUTE )
!             r += '$';
!         ColToAlpha( r, nCol);
!     }
!     if( nFlags & SCA_VALID_ROW )
!     {
!         if ( nFlags & SCA_ROW_ABSOLUTE )
!             r += '$';
!         r += String::CreateFromInt32( Row()+1 );
      }
  }
  
  
! void ScRange::Format( String& r, USHORT nFlags, ScDocument* pDoc ) const
  {
      if( !( nFlags & SCA_VALID ) )
-         r = ScGlobal::GetRscString( STR_NOREF_STR );
-     else
      {
          BOOL bOneTab = (aStart.Tab() == aEnd.Tab());
          if ( !bOneTab )
              nFlags |= SCA_TAB_3D;
!         aStart.Format( r, nFlags, pDoc );
          if( aStart != aEnd )
          {
              String aName;
--- 1108,1236 ----
                      nLen = nPos + 1;
                  if ( aTabName.GetChar(nLen) == SC_COMPILER_FILE_TAB_SEP )
                  {
! 					aDocName = aTabName.Copy( 0, nLen + 1 );
                      aTabName.Erase( 0, nLen + 1 );
                  }
              }
! 			ScCompiler::CheckTabQuotes( aTabName, rDetails.eConv);
  
! 			switch (rDetails.eConv) {
! 			default :
! 			case CONV_OOO:
! 				r += aDocName;
! 				if( nFlags & SCA_TAB_ABSOLUTE )
! 					r += '$';
! 				r += aTabName;
! 				r += '.';
! 				break;
! 
! 			case CONV_XL_A1:
! 			case CONV_XL_R1C1:
! 				r += '[';
! 				r += aDocName;
! 				r += ']';
! 				r += aTabName;
! 				r += '!';
! 				break;
! 			}
! 		}
!     }
! 	switch (rDetails.eConv) {
! 	default :
! 	case CONV_OOO:
! 	case CONV_XL_A1:
! 		if( nFlags & SCA_VALID_COL )
! 			lcl_a1_append_c ( r, nCol, nFlags & SCA_COL_ABSOLUTE );
! 		if( nFlags & SCA_VALID_ROW )
! 			lcl_a1_append_r ( r, nRow, nFlags & SCA_ROW_ABSOLUTE );
! 		break;
! 
! 	case CONV_XL_R1C1:
! 		if( nFlags & SCA_VALID_ROW )
! 			lcl_r1c1_append_r ( r, nRow, nFlags & SCA_ROW_ABSOLUTE, rDetails );
! 		if( nFlags & SCA_VALID_COL )
! 			lcl_r1c1_append_c ( r, nCol, nFlags & SCA_COL_ABSOLUTE, rDetails );
! 		break;
! 	}
! }
! 
! static void
! lcl_Split_DocTab( const ScDocument* pDoc,  SCTAB nTab,
! 				  const ScAddress::Details& rDetails,
! 				  String& rTabName, String& rDocName )
! {
! 	pDoc->GetName( nTab, rTabName );
! 	rDocName.Erase();
! #if 1
! 	{
! 		ByteString	aStr(rTabName, RTL_TEXTENCODING_UTF8);
! 		aStr.Append(static_cast< char >(0));
! 		std::cerr << "tabname \'" << aStr.GetBuffer() << '\'' << std::endl;
! 	}
! #endif
! 	//  externe Referenzen (wie in ScCompiler::MakeTabStr)
! 	if ( rTabName.GetChar(0) == '\'' )
! 	{   // "'Doc'#Tab"
! 		xub_StrLen nPos, nLen = 1;
! 		while( (nPos = rTabName.Search( '\'', nLen )) != STRING_NOTFOUND )
! 			nLen = nPos + 1;
! 		if ( rTabName.GetChar(nLen) == SC_COMPILER_FILE_TAB_SEP )
! 		{
! 			rDocName = rTabName.Copy( 0, nLen + 1 );
! 			rTabName.Erase( 0, nLen + 1 );
! 		}
      }
+ 	ScCompiler::CheckTabQuotes( rTabName, rDetails.eConv);
  }
  
+ static void
+ lcl_ScRange_Format_XL_Header( String& r, const ScRange& rRange,
+ 							  USHORT nFlags, ScDocument* pDoc,
+ 							  const ScAddress::Details& rDetails )
+ {
+ 	if( nFlags & SCA_TAB_3D )
+ 	{
+ 		String aTabName, aDocName;
+ 		lcl_Split_DocTab( pDoc, rRange.aStart.Tab(), rDetails,
+ 						  aTabName, aDocName );
+ 		if( aDocName.Len() > 0 )
+ 		{
+ 			r += '[';
+ 			r += aDocName;
+ 			r += ']';
+ 		}
+ 		r += aTabName;
+ 
+ 		if( nFlags & SCA_TAB2_3D )
+ 		{
+ 			lcl_Split_DocTab( pDoc, rRange.aEnd.Tab(), rDetails,
+ 							  aTabName, aDocName );
+ 			r += ':';
+ 			r += aTabName;
+ 		}
+ 		r += '!';
+ 	}
+ }
  
! void ScRange::Format( String& r, USHORT nFlags, ScDocument* pDoc,
! 					  const ScAddress::Details& rDetails ) const
  {
      if( !( nFlags & SCA_VALID ) )
      {
+         r = ScGlobal::GetRscString( STR_NOREF_STR );
+ 		return;
+ 	}
+ 
+ #define	absrel_differ(nFlags, mask)	(((nFlags) & (mask)) ^ (((nFlags) >> 4) & (mask)))
+ 	switch( rDetails.eConv ) {
+ 	default :
+ 	case ScAddress::CONV_OOO: {
          BOOL bOneTab = (aStart.Tab() == aEnd.Tab());
          if ( !bOneTab )
              nFlags |= SCA_TAB_3D;
! 		aStart.Format( r, nFlags, pDoc, rDetails );
! 		// BUG BUG BUG
! 		// 	at a minimum I think this should check for abs/rel differences
          if( aStart != aEnd )
          {
              String aName;
*************** void ScRange::Format( String& r, USHORT 
*** 490,502 ****
                  pDoc = NULL;
              else
                  nFlags |= SCA_TAB_3D;
!             aEnd.Format( aName, nFlags, pDoc );
              r += ':';
              r += aName;
          }
      }
! }
  
  
  bool ScAddress::Move( SCsCOL dx, SCsROW dy, SCsTAB dz, ScDocument* pDoc )
  {
--- 1239,1318 ----
                  pDoc = NULL;
              else
                  nFlags |= SCA_TAB_3D;
! 			aEnd.Format( aName, nFlags, pDoc, rDetails );
              r += ':';
              r += aName;
          }
      }
! 	break;
  
+ 	case ScAddress::CONV_XL_A1:
+ 		lcl_ScRange_Format_XL_Header( r, *this, nFlags, pDoc, rDetails );
+ 		if( aStart.Col() == 0 && aEnd.Col() >= MAXCOL )
+ 		{
+ 			// Full col refs always require 2 rows (2:2)
+ 			lcl_a1_append_r( r, aStart.Row(), nFlags & SCA_ROW_ABSOLUTE );
+ 			r += ':';
+ 			lcl_a1_append_r( r, aEnd.Row(), nFlags & SCA_ROW2_ABSOLUTE );
+ 		}
+ 		else if( aStart.Row() == 0 && aEnd.Row() >= MAXROW )
+ 		{
+ 			// Full row refs always require 2 cols (A:A)
+ 			lcl_a1_append_c( r, aStart.Col(), nFlags & SCA_COL_ABSOLUTE );
+ 			r += ':';
+ 			lcl_a1_append_c( r, aEnd.Col(), nFlags & SCA_COL2_ABSOLUTE );
+ 		}
+ 		else
+ 		{
+ 			lcl_a1_append_c ( r, aStart.Col(), nFlags & SCA_COL_ABSOLUTE );
+ 			lcl_a1_append_r ( r, aStart.Row(), nFlags & SCA_ROW_ABSOLUTE );
+ 			if( aStart.Col() != aEnd.Col() ||
+ 				absrel_differ( nFlags, SCA_COL_ABSOLUTE ) ||
+ 				aStart.Row() != aEnd.Row() ||
+ 				absrel_differ( nFlags, SCA_ROW_ABSOLUTE )) {
+ 				r += ':';
+ 				lcl_a1_append_c ( r, aEnd.Col(), nFlags & SCA_COL2_ABSOLUTE );
+ 				lcl_a1_append_r ( r, aEnd.Row(), nFlags & SCA_ROW2_ABSOLUTE );
+ 			}
+ 		}
+ 	break;
+ 
+ 	case ScAddress::CONV_XL_R1C1:
+ 		lcl_ScRange_Format_XL_Header( r, *this, nFlags, pDoc, rDetails );
+ 		if( aStart.Col() == 0 && aEnd.Col() >= MAXCOL )
+ 		{
+ 			lcl_r1c1_append_r( r, aStart.Row(), nFlags & SCA_ROW_ABSOLUTE, rDetails );
+ 			if( aStart.Row() != aEnd.Row() ||
+ 				absrel_differ( nFlags, SCA_ROW_ABSOLUTE )) {
+ 				r += ':';
+ 				lcl_r1c1_append_r( r, aEnd.Row(), nFlags & SCA_ROW2_ABSOLUTE, rDetails );
+ 			}
+ 		}
+ 		else if( aStart.Row() == 0 && aEnd.Row() >= MAXROW )
+ 		{
+ 			lcl_r1c1_append_c( r, aStart.Col(), nFlags & SCA_COL_ABSOLUTE, rDetails );
+ 			if( aStart.Col() != aEnd.Col() ||
+ 				absrel_differ( nFlags, SCA_COL_ABSOLUTE )) {
+ 				r += ':';
+ 				lcl_r1c1_append_c( r, aEnd.Col(), nFlags & SCA_COL2_ABSOLUTE, rDetails );
+ 			}
+ 		}
+ 		else
+ 		{
+ 			lcl_r1c1_append_r( r, aStart.Row(), nFlags & SCA_ROW_ABSOLUTE, rDetails );
+ 			lcl_r1c1_append_c( r, aStart.Col(), nFlags & SCA_COL_ABSOLUTE, rDetails );
+ 			if( aStart.Col() != aEnd.Col() ||
+ 				absrel_differ( nFlags, SCA_COL_ABSOLUTE ) ||
+ 				aStart.Row() != aEnd.Row() ||
+ 				absrel_differ( nFlags, SCA_ROW_ABSOLUTE )) {
+ 				r += ':';
+ 				lcl_r1c1_append_r( r, aEnd.Row(), nFlags & SCA_ROW2_ABSOLUTE, rDetails );
+ 				lcl_r1c1_append_c( r, aEnd.Col(), nFlags & SCA_COL2_ABSOLUTE, rDetails );
+ 			}
+ 		}
+ 	}
+ #undef	absrel_differ
+ }
  
  bool ScAddress::Move( SCsCOL dx, SCsROW dy, SCsTAB dz, ScDocument* pDoc )
  {
*************** String ScAddress::GetText() const
*** 544,552 ****
  }
  
  
! String ScAddress::GetColRowString( bool bAbsolute ) const
  {
      String aString;
      if (bAbsolute)
          aString.Append( '$' );
  
--- 1360,1375 ----
  }
  
  
! String ScAddress::GetColRowString( bool bAbsolute,
! 								   const Details& rDetails ) const
  {
      String aString;
+ 
+ 	switch( rDetails.eConv )
+ 	{
+ 	default :
+ 	case ScAddress::CONV_OOO:
+ 	case ScAddress::CONV_XL_A1:
      if (bAbsolute)
          aString.Append( '$' );
  
*************** String ScAddress::GetColRowString( bool 
*** 556,567 ****
          aString.Append( '$' );
  
      aString += String::CreateFromInt32(nRow+1);
  
      return aString;
  }
  
  
! String ScRefAddress::GetRefString( ScDocument* pDoc, SCTAB nActTab) const
  {
      if ( !pDoc )
          return EMPTY_STRING;
--- 1379,1398 ----
          aString.Append( '$' );
  
      aString += String::CreateFromInt32(nRow+1);
+ 		break;
+ 
+ 	case ScAddress::CONV_XL_R1C1:
+ 		lcl_r1c1_append_r ( aString, nRow, bAbsolute, rDetails );
+ 		lcl_r1c1_append_c ( aString, nCol, bAbsolute, rDetails );
+ 		break;
+ 	}
  
      return aString;
  }
  
  
! String ScRefAddress::GetRefString( ScDocument* pDoc, SCTAB nActTab,
! 								   const ScAddress::Details& rDetails ) const
  {
      if ( !pDoc )
          return EMPTY_STRING;
*************** String ScRefAddress::GetRefString( ScDoc
*** 581,587 ****
      if ( !bRelRow )
          nFlags |= SCA_ROW_ABSOLUTE;
  
!     aAdr.Format( aString, nFlags, pDoc );
  
      return aString;
  }
--- 1412,1418 ----
      if ( !bRelRow )
          nFlags |= SCA_ROW_ABSOLUTE;
  
!     aAdr.Format( aString, nFlags, pDoc, rDetails );
  
      return aString;
  }
Index: sc/source/core/tool/chgtrack.cxx
===================================================================
RCS file: /cvs/sc/source/core/tool/chgtrack.cxx,v
diff -cpr sc/source/core/tool/chgtrack.cxx sc/source/core/tool/chgtrack.cxx
*** sc/source/core/tool/chgtrack.cxx	Fri Jul 21 07:21:56 2006
--- sc/source/core/tool/chgtrack.cxx	Thu Aug 24 10:45:05 2006
*************** void ScChangeActionContent::SetValueStri
*** 1936,1942 ****
  	{
  		rValue.Erase();
  		pCell = new ScFormulaCell(
! 			pDoc, aBigRange.aStart.MakeAddress(), rStr );
  		((ScFormulaCell*)pCell)->SetInChangeTrack( TRUE );
  	}
  	else
--- 1936,1942 ----
  	{
  		rValue.Erase();
  		pCell = new ScFormulaCell(
! 			pDoc, aBigRange.aStart.MakeAddress(), rStr, ScAddress::CONV_OOO );
  		((ScFormulaCell*)pCell)->SetInChangeTrack( TRUE );
  	}
  	else
Index: sc/source/core/tool/compiler.cxx
===================================================================
RCS file: /cvs/sc/source/core/tool/compiler.cxx,v
diff -cpr sc/source/core/tool/compiler.cxx sc/source/core/tool/compiler.cxx
*** sc/source/core/tool/compiler.cxx	Fri Aug  4 07:33:49 2006
--- sc/source/core/tool/compiler.cxx	Thu Aug 24 22:45:33 2006
***************
*** 86,95 ****
  String* ScCompiler::pSymbolTableNative = NULL;
  String* ScCompiler::pSymbolTableEnglish = NULL;
  USHORT  ScCompiler::nAnzStrings = 0;
- ULONG* ScCompiler::pCharTable = 0;
  ScOpCodeHashMap* ScCompiler::pSymbolHashMapNative = NULL;
  ScOpCodeHashMap* ScCompiler::pSymbolHashMapEnglish = NULL;
  CharClass* ScCompiler::pCharClassEnglish = NULL;
  
  enum ScanState
  {
--- 86,95 ----
  String* ScCompiler::pSymbolTableNative = NULL;
  String* ScCompiler::pSymbolTableEnglish = NULL;
  USHORT  ScCompiler::nAnzStrings = 0;
  ScOpCodeHashMap* ScCompiler::pSymbolHashMapNative = NULL;
  ScOpCodeHashMap* ScCompiler::pSymbolHashMapEnglish = NULL;
  CharClass* ScCompiler::pCharClassEnglish = NULL;
+ const ScCompiler::Convention* ScCompiler::pConventions[ ] = { NULL, NULL, NULL };
  
  enum ScanState
  {
*************** struct ScArrayStack
*** 110,116 ****
  
  static sal_Char* pInternal[ 5 ] = { "GAME", "SPEW", "TTT", "STARCALCTEAM", "ANTWORT" };
  
! 
  /////////////////////////////////////////////////////////////////////////
  
  short lcl_GetRetFormat( OpCode eOpCode )
--- 110,116 ----
  
  static sal_Char* pInternal[ 5 ] = { "GAME", "SPEW", "TTT", "STARCALCTEAM", "ANTWORT" };
  
! using namespace ::com::sun::star::i18n;
  /////////////////////////////////////////////////////////////////////////
  
  short lcl_GetRetFormat( OpCode eOpCode )
*************** public:
*** 222,277 ****
  
  void ScCompiler::Init()
  {
      pSymbolTableNative = new String[SC_OPCODE_LAST_OPCODE_ID+1];
      pSymbolHashMapNative = new ScOpCodeHashMap( SC_OPCODE_LAST_OPCODE_ID+1 );
      ScOpCodeList aOpCodeListNative( RID_SC_FUNCTION_NAMES, pSymbolTableNative,
              *pSymbolHashMapNative );
      nAnzStrings = SC_OPCODE_LAST_OPCODE_ID+1;
- 
-     pCharTable = new ULONG [128];
-     USHORT i;
-     for (i = 0; i < 128; i++)
-         pCharTable[i] = SC_COMPILER_C_ILLEGAL;
-     /*   */     pCharTable[32] = SC_COMPILER_C_CHAR_DONTCARE | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     /* ! */     pCharTable[33] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     /* " */     pCharTable[34] = SC_COMPILER_C_CHAR_STRING | SC_COMPILER_C_STRING_SEP;
-     /* # */     pCharTable[35] = SC_COMPILER_C_WORD_SEP;
-     /* $ */     pCharTable[36] = SC_COMPILER_C_CHAR_WORD | SC_COMPILER_C_WORD | SC_COMPILER_C_CHAR_IDENT | SC_COMPILER_C_IDENT;
-     /* % */     pCharTable[37] = SC_COMPILER_C_VALUE;
-     /* & */     pCharTable[38] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     /* ' */     pCharTable[39] = SC_COMPILER_C_NAME_SEP;
-     /* ( */     pCharTable[40] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     /* ) */     pCharTable[41] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     /* * */     pCharTable[42] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     /* + */     pCharTable[43] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_EXP | SC_COMPILER_C_VALUE_SIGN;
-     /* , */     pCharTable[44] = SC_COMPILER_C_CHAR_VALUE | SC_COMPILER_C_VALUE;
-     /* - */     pCharTable[45] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_EXP | SC_COMPILER_C_VALUE_SIGN;
-     /* . */     pCharTable[46] = SC_COMPILER_C_WORD | SC_COMPILER_C_CHAR_VALUE | SC_COMPILER_C_VALUE | SC_COMPILER_C_IDENT;
-     /* / */     pCharTable[47] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     for (i = 48; i < 58; i++)
-     /* 0-9 */   pCharTable[i] = SC_COMPILER_C_CHAR_VALUE | SC_COMPILER_C_WORD | SC_COMPILER_C_VALUE | SC_COMPILER_C_VALUE_EXP | SC_COMPILER_C_VALUE_VALUE | SC_COMPILER_C_IDENT;
-     /* : */     pCharTable[58] = SC_COMPILER_C_WORD | SC_COMPILER_C_IDENT;
-     /* ; */     pCharTable[59] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     /* < */     pCharTable[60] = SC_COMPILER_C_CHAR_BOOL | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     /* = */     pCharTable[61] = SC_COMPILER_C_CHAR | SC_COMPILER_C_BOOL | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     /* > */     pCharTable[62] = SC_COMPILER_C_CHAR_BOOL | SC_COMPILER_C_BOOL | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     /* ? */     pCharTable[63] = SC_COMPILER_C_CHAR_WORD | SC_COMPILER_C_WORD;
-     /* @ */     // FREI
-     for (i = 65; i < 91; i++)
-     /* A-Z */   pCharTable[i] = SC_COMPILER_C_CHAR_WORD | SC_COMPILER_C_WORD | SC_COMPILER_C_CHAR_IDENT | SC_COMPILER_C_IDENT;
-     /* [ */     // FREI
-     /* \ */     // FREI
-     /* ] */     // FREI
-     /* ^ */     pCharTable[94] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
-     /* _ */     pCharTable[95] = SC_COMPILER_C_CHAR_WORD | SC_COMPILER_C_WORD | SC_COMPILER_C_CHAR_IDENT | SC_COMPILER_C_IDENT;
-     /* ` */     // FREI
-     for (i = 97; i < 123; i++)
-     /* a-z */   pCharTable[i] = SC_COMPILER_C_CHAR_WORD | SC_COMPILER_C_WORD | SC_COMPILER_C_CHAR_IDENT | SC_COMPILER_C_IDENT;
-     /* { */     // FREI
-     /* | */     // FREI
-     /* } */     // FREI
-     /* ~ */     // FREI
-     /* 127 */   // FREI
  }
  
  void ScCompiler::DeInit()
--- 222,235 ----
  
  void ScCompiler::Init()
  {
+     if (NULL != pSymbolTableNative)
+ 		return;
+ 
      pSymbolTableNative = new String[SC_OPCODE_LAST_OPCODE_ID+1];
      pSymbolHashMapNative = new ScOpCodeHashMap( SC_OPCODE_LAST_OPCODE_ID+1 );
      ScOpCodeList aOpCodeListNative( RID_SC_FUNCTION_NAMES, pSymbolTableNative,
              *pSymbolHashMapNative );
      nAnzStrings = SC_OPCODE_LAST_OPCODE_ID+1;
  }
  
  void ScCompiler::DeInit()
*************** void ScCompiler::DeInit()
*** 303,310 ****
          delete pCharClassEnglish;
          pCharClassEnglish = NULL;
      }
-     delete [] pCharTable;
-     pCharTable = NULL;
  }
  
  void ScCompiler::SetCompileEnglish( BOOL bCompileEnglish )
--- 261,266 ----
*************** void ScCompiler::SetCompileEnglish( BOOL
*** 341,394 ****
  
  //-----------------------------------------------------------------------------
  
! ScCompiler::ScCompiler( ScDocument* pDocument, const ScAddress& rPos,
!                         const ScTokenArray& rArr )
!         :
!         aPos( rPos ),
!         pSymbolTable( pSymbolTableNative ),
!         pSymbolHashMap( pSymbolHashMapNative ),
!         pCharClass( ScGlobal::pCharClass ),
!         nRecursion(0),
!         bAutoCorrect( FALSE ),
!         bCorrected( FALSE ),
!         bCompileForFAP( FALSE ),
!         bIgnoreErrors( FALSE ),
!         bCompileXML( FALSE ),
!         bImportXML ( FALSE )
  {
!     if (!nAnzStrings)
!         Init();
!     pArr = (ScTokenArray*) &rArr;
!     pDoc = pDocument;
!     nMaxTab = pDoc->GetTableCount() - 1;
!     pStack = NULL;
!     nNumFmt = NUMBERFORMAT_UNDEFINED;
  }
  
! ScCompiler::ScCompiler(ScDocument* pDocument, const ScAddress& rPos )
          :
!         aPos( rPos ),
!         pSymbolTable( pSymbolTableNative ),
!         pSymbolHashMap( pSymbolHashMapNative ),
!         pCharClass( ScGlobal::pCharClass ),
!         nRecursion(0),
!         bAutoCorrect( FALSE ),
!         bCorrected( FALSE ),
!         bCompileForFAP( FALSE ),
!         bIgnoreErrors( FALSE ),
!         bCompileXML( FALSE ),
!         bImportXML ( FALSE )
  {
!     if (!nAnzStrings)
!         Init();
!     pDoc = pDocument;
!     nMaxTab = pDoc ? pDoc->GetTableCount() - 1 : 0;
!     pStack = NULL;
!     nNumFmt = NUMBERFORMAT_UNDEFINED;
  }
  
  
! String ScCompiler::MakeColStr( SCCOL nCol )
  {
      if ( !ValidCol( nCol) )
          return ScGlobal::GetRscString(STR_NO_REF_TABLE);
--- 297,429 ----
  
  //-----------------------------------------------------------------------------
  
! ScCompiler::Convention::~Convention()
  {
! 	delete [] mpCharTable;
! 	mpCharTable = NULL;
  }
  
! ScCompiler::Convention::Convention( ScAddress::Convention eConv )
          :
! 	meConv( eConv )
  {
!     int i;
! 	ULONG *t= new ULONG [128];
! 
! 	ScCompiler::pConventions[ meConv ] = this;
! 	mpCharTable = t;
! 
! 	for (i = 0; i < 128; i++)
! 		t[i] = SC_COMPILER_C_ILLEGAL;
! 
! /*   */     t[32] = SC_COMPILER_C_CHAR_DONTCARE | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! /* ! */     t[33] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! /* " */     t[34] = SC_COMPILER_C_CHAR_STRING | SC_COMPILER_C_STRING_SEP;
! /* # */     t[35] = SC_COMPILER_C_WORD_SEP;
! /* $ */     t[36] = SC_COMPILER_C_CHAR_WORD | SC_COMPILER_C_WORD | SC_COMPILER_C_CHAR_IDENT | SC_COMPILER_C_IDENT;
! /* % */     t[37] = SC_COMPILER_C_VALUE;
! /* & */     t[38] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! /* ' */     t[39] = SC_COMPILER_C_NAME_SEP;
! /* ( */     t[40] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! /* ) */     t[41] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! /* * */     t[42] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! /* + */     t[43] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_EXP | SC_COMPILER_C_VALUE_SIGN;
! /* , */     t[44] = SC_COMPILER_C_CHAR_VALUE | SC_COMPILER_C_VALUE;
! /* - */     t[45] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_EXP | SC_COMPILER_C_VALUE_SIGN;
! /* . */     t[46] = SC_COMPILER_C_WORD | SC_COMPILER_C_CHAR_VALUE | SC_COMPILER_C_VALUE | SC_COMPILER_C_IDENT;
! /* / */     t[47] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! for (i = 48; i < 58; i++)
! /* 0-9 */   t[i] = SC_COMPILER_C_CHAR_VALUE | SC_COMPILER_C_WORD | SC_COMPILER_C_VALUE | SC_COMPILER_C_VALUE_EXP | SC_COMPILER_C_VALUE_VALUE | SC_COMPILER_C_IDENT;
! /* : */     t[58] = SC_COMPILER_C_WORD | SC_COMPILER_C_IDENT;
! /* ; */     t[59] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! /* < */     t[60] = SC_COMPILER_C_CHAR_BOOL | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! /* = */     t[61] = SC_COMPILER_C_CHAR | SC_COMPILER_C_BOOL | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! /* > */     t[62] = SC_COMPILER_C_CHAR_BOOL | SC_COMPILER_C_BOOL | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! /* ? */     t[63] = SC_COMPILER_C_CHAR_WORD | SC_COMPILER_C_WORD;
! /* @ */     // FREI
! for (i = 65; i < 91; i++)
! /* A-Z */   t[i] = SC_COMPILER_C_CHAR_WORD | SC_COMPILER_C_WORD | SC_COMPILER_C_CHAR_IDENT | SC_COMPILER_C_IDENT;
! /* [ */     // FREI
! /* \ */     // FREI
! /* ] */     // FREI
! /* ^ */     t[94] = SC_COMPILER_C_CHAR | SC_COMPILER_C_WORD_SEP | SC_COMPILER_C_VALUE_SEP;
! /* _ */     t[95] = SC_COMPILER_C_CHAR_WORD | SC_COMPILER_C_WORD | SC_COMPILER_C_CHAR_IDENT | SC_COMPILER_C_IDENT;
! /* ` */     // FREI
! for (i = 97; i < 123; i++)
! /* a-z */   t[i] = SC_COMPILER_C_CHAR_WORD | SC_COMPILER_C_WORD | SC_COMPILER_C_CHAR_IDENT | SC_COMPILER_C_IDENT;
! /* { */     // FREI
! /* | */     // FREI
! /* } */     // FREI
! /* ~ */     // FREI
! /* 127 */   // FREI
! 	if( ScAddress::CONV_XL_A1 == meConv || ScAddress::CONV_XL_R1C1 == meConv )
! 	{
! /*   */     t[32] |=   SC_COMPILER_C_WORD;
! /* ! */     t[33] |=   SC_COMPILER_C_IDENT | SC_COMPILER_C_WORD;
! /* " */     t[34] |=   SC_COMPILER_C_WORD;
! /* # */     t[35] &= (~SC_COMPILER_C_WORD_SEP);
! /* # */     t[35] |=   SC_COMPILER_C_WORD;
! /* % */     t[37] |=   SC_COMPILER_C_WORD;
! /* ' */     t[39] |=   SC_COMPILER_C_WORD;
! 
! /* % */     t[37] |=   SC_COMPILER_C_WORD;
! /* & */     t[38] |=   SC_COMPILER_C_WORD;
! /* ' */     t[39] |=   SC_COMPILER_C_WORD;
! /* ( */     t[40] |=   SC_COMPILER_C_WORD;
! /* ) */     t[41] |=   SC_COMPILER_C_WORD;
! /* * */     t[42] |=   SC_COMPILER_C_WORD;
! /* + */     t[43] |=   SC_COMPILER_C_WORD;
! /* , */     t[44] |=   SC_COMPILER_C_WORD;
! /* - */     t[45] |=   SC_COMPILER_C_WORD;
! 
! /* ; */     t[59] |=   SC_COMPILER_C_WORD;
! /* < */     t[60] |=   SC_COMPILER_C_WORD;
! /* = */     t[61] |=   SC_COMPILER_C_WORD;
! /* > */     t[62] |=   SC_COMPILER_C_WORD;
! /* ? */     // question really is not permitted in sheet name
! /* @ */     t[64] |=   SC_COMPILER_C_WORD;
! /* [ */     t[91] |=   SC_COMPILER_C_WORD;
! /* ] */     t[93] |=   SC_COMPILER_C_WORD;
! /* { */     t[123]|=   SC_COMPILER_C_WORD;
! /* | */     t[124]|=   SC_COMPILER_C_WORD;
! /* } */     t[124]|=   SC_COMPILER_C_WORD;
! /* ~ */     t[126]|=   SC_COMPILER_C_WORD;
! 
! 		if( ScAddress::CONV_XL_R1C1 == meConv )
! 		{
! 		/* - */     t[45] |= SC_COMPILER_C_IDENT;
! 		/* [ */     t[91] |= SC_COMPILER_C_IDENT;
! 		/* ] */     t[93] |= SC_COMPILER_C_IDENT;
! }
! 	}
  }
  
+ //-----------------------------------------------------------------------------
  
! struct Convention_A1 : public ScCompiler::Convention
! {
! 	Convention_A1( ScAddress::Convention eConv ) : ScCompiler::Convention( eConv ) { }
! 	static String MakeColStr( SCCOL nCol );
! 	static void MakeColStr( rtl::OUStringBuffer& rBuffer, SCCOL nCol );
! 	static String MakeRowStr( SCROW nRow );
! 	static void MakeRowStr( rtl::OUStringBuffer& rBuffer, SCROW nRow );
! 
! 	ParseResult parseAnyToken( const String& rFormula,
! 							   xub_StrLen nSrcPos,
! 							   const CharClass* pCharClass) const
! 	{
!         static const sal_Int32 nStartFlags = KParseTokens::ANY_LETTER_OR_NUMBER |
!             KParseTokens::ASC_UNDERSCORE | KParseTokens::ASC_DOLLAR;
!         static const sal_Int32 nContFlags = nStartFlags | KParseTokens::ASC_DOT |
!             KParseTokens::ASC_COLON;
!         // '?' allowed in range names because of Xcl :-/
!         static const String aAddAllowed( '?' );
! 		return pCharClass->parseAnyToken( rFormula,
!                 nSrcPos, nStartFlags, aAddAllowed, nContFlags, aAddAllowed );
! 	}
! };
! 
! String Convention_A1::MakeColStr( SCCOL nCol )
  {
      if ( !ValidCol( nCol) )
          return ScGlobal::GetRscString(STR_NO_REF_TABLE);
*************** String ScCompiler::MakeColStr( SCCOL nCo
*** 396,402 ****
          return ::ColToAlpha( nCol);
  }
  
! void ScCompiler::MakeColStr( rtl::OUStringBuffer& rBuffer, SCCOL nCol )
  {
      if ( !ValidCol( nCol) )
          rBuffer.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
--- 431,437 ----
          return ::ColToAlpha( nCol);
  }
  
! void Convention_A1::MakeColStr( rtl::OUStringBuffer& rBuffer, SCCOL nCol )
  {
      if ( !ValidCol( nCol) )
          rBuffer.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
*************** void ScCompiler::MakeColStr( rtl::OUStri
*** 404,410 ****
          ::ColToAlpha( rBuffer, nCol);
  }
  
! String ScCompiler::MakeRowStr( SCROW nRow )
  {
      if ( !ValidRow(nRow) )
          return ScGlobal::GetRscString(STR_NO_REF_TABLE);
--- 439,445 ----
          ::ColToAlpha( rBuffer, nCol);
  }
  
! String Convention_A1::MakeRowStr( SCROW nRow )
  {
      if ( !ValidRow(nRow) )
          return ScGlobal::GetRscString(STR_NO_REF_TABLE);
*************** String ScCompiler::MakeRowStr( SCROW nRo
*** 412,418 ****
          return String::CreateFromInt32( nRow + 1 );
  }
  
! void ScCompiler::MakeRowStr( rtl::OUStringBuffer& rBuffer, SCROW nRow )
  {
      if ( !ValidRow(nRow) )
          rBuffer.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
--- 447,453 ----
          return String::CreateFromInt32( nRow + 1 );
  }
  
! void Convention_A1::MakeRowStr( rtl::OUStringBuffer& rBuffer, SCROW nRow )
  {
      if ( !ValidRow(nRow) )
          rBuffer.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
*************** void ScCompiler::MakeRowStr( rtl::OUStri
*** 420,429 ****
          rBuffer.append(sal_Int32(nRow + 1));
  }
  
! String ScCompiler::MakeTabStr( SCTAB nTab, String& aDoc )
  {
      String aString;
!     if (!pDoc->GetName(nTab, aString))
          aString = ScGlobal::GetRscString(STR_NO_REF_TABLE);
      else
      {
--- 455,469 ----
          rBuffer.append(sal_Int32(nRow + 1));
  }
  
! //-----------------------------------------------------------------------------
! 
! struct ConventionOOO_A1 : public Convention_A1
! {
! 	ConventionOOO_A1() : Convention_A1 (ScAddress::CONV_OOO) { }
! 	static String MakeTabStr( const ScCompiler& rComp, SCTAB nTab, String& aDoc )
  {
      String aString;
! 		if (!rComp.pDoc->GetName( nTab, aString ))
          aString = ScGlobal::GetRscString(STR_NO_REF_TABLE);
      else
      {
*************** String ScCompiler::MakeTabStr( SCTAB nTa
*** 444,486 ****
          }
          else
              aDoc.Erase();
!         CheckTabQuotes( aString );
      }
      aString += '.';
      return aString;
  }
  
! void ScCompiler::CheckTabQuotes( String& rString )
! {
!     register const sal_Unicode* p = rString.GetBuffer();
!     register const sal_Unicode* const pEnd = p + rString.Len();
!     while ( p < pEnd )
!     {
!         if( !IsWordChar( *p ) )
!         {
!             rString.Insert( '\'', 0 );
!             rString += '\'';
!             return ;
!         }
!         p++;
!     }
!     if ( CharClass::isAsciiNumeric( rString ) )
!     {
!         rString.Insert( '\'', 0 );
!         rString += '\'';
!     }
  }
  
- String ScCompiler::MakeRefStr( ComplRefData& rRef, BOOL bSingleRef )
- {
-     rtl::OUStringBuffer aBuffer;
-     MakeRefStr( aBuffer, rRef, bSingleRef );
-     return String( aBuffer );
- }
  
! void ScCompiler::MakeRefStr( rtl::OUStringBuffer& rBuffer, ComplRefData& rRef, BOOL bSingleRef )
  {
-     if (bCompileXML)
          rBuffer.append(sal_Unicode('['));
      ComplRefData aRef( rRef );
      // In case absolute/relative positions weren't separately available:
--- 484,589 ----
          }
          else
              aDoc.Erase();
! 			ScCompiler::CheckTabQuotes( aString, ScAddress::CONV_OOO );
      }
      aString += '.';
      return aString;
  }
  
! 	void MakeRefStr( rtl::OUStringBuffer&	rBuffer,
! 					 const ScCompiler&		rComp,
! 					 const ComplRefData& rRef,
! 					 BOOL bSingleRef ) const
! {
! 		ComplRefData aRef( rRef );
! 		// In case absolute/relative positions weren't separately available:
! 		// transform relative to absolute!
! 		//  AdjustReference( aRef.Ref1 );
! 		//  if( !bSingleRef )
! 		//      AdjustReference( aRef.Ref2 );
! 		aRef.Ref1.CalcAbsIfRel( rComp.aPos );
! 		if( !bSingleRef )
! 			aRef.Ref2.CalcAbsIfRel( rComp.aPos );
! 		if( aRef.Ref1.IsFlag3D() )
!     {
! 			if (aRef.Ref1.IsTabDeleted())
!         {
! 				if (!aRef.Ref1.IsTabRel())
! 					rBuffer.append(sal_Unicode('$'));
! 				rBuffer.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
! 				rBuffer.append(sal_Unicode('.'));
!     }
! 			else
!     {
! 				String aDoc;
! 				String aRefStr( MakeTabStr( rComp, aRef.Ref1.nTab, aDoc ) );
! 				rBuffer.append(aDoc);
! 				if (!aRef.Ref1.IsTabRel()) rBuffer.append(sal_Unicode('$'));
! 				rBuffer.append(aRefStr);
!     }
! }
! 		if (!aRef.Ref1.IsColRel())
! 			rBuffer.append(sal_Unicode('$'));
! 		if ( aRef.Ref1.IsColDeleted() )
! 			rBuffer.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
! 		else
! 			MakeColStr(rBuffer, aRef.Ref1.nCol );
! 		if (!aRef.Ref1.IsRowRel())
! 			rBuffer.append(sal_Unicode('$'));
! 		if ( aRef.Ref1.IsRowDeleted() )
! 			rBuffer.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
! 		else
! 			MakeRowStr( rBuffer, aRef.Ref1.nRow );
! 		if (!bSingleRef)
! {
! 			rBuffer.append(sal_Unicode(':'));
! 			if (aRef.Ref2.IsFlag3D() || aRef.Ref2.nTab != aRef.Ref1.nTab)
! 			{
! 				if (aRef.Ref2.IsTabDeleted())
! 				{
! 					if (!aRef.Ref2.IsTabRel())
! 						rBuffer.append(sal_Unicode('$'));
! 					rBuffer.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
! 					rBuffer.append(sal_Unicode('.'));
! 				}
! 				else
! 				{
! 					String aDoc;
! 					String aRefStr( MakeTabStr( rComp, aRef.Ref2.nTab, aDoc ) );
! 					rBuffer.append(aDoc);
! 					if (!aRef.Ref2.IsTabRel()) rBuffer.append(sal_Unicode('$'));
! 					rBuffer.append(aRefStr);
! 				}
! 			}
! 			if (!aRef.Ref2.IsColRel())
! 				rBuffer.append(sal_Unicode('$'));
! 			if ( aRef.Ref2.IsColDeleted() )
! 				rBuffer.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
! 			else
! 				MakeColStr( rBuffer, aRef.Ref2.nCol );
! 			if (!aRef.Ref2.IsRowRel())
! 				rBuffer.append(sal_Unicode('$'));
! 			if ( aRef.Ref2.IsRowDeleted() )
! 				rBuffer.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
! 			else
! 				MakeRowStr( rBuffer, aRef.Ref2.nRow );
  }
+ 	}
+ };
  
  
! static const ConventionOOO_A1 ConvOOO_A1;
! const ScCompiler::Convention *pConvOOO_A1 = &ConvOOO_A1;
! 
! //-----------------------------------------------------------------------------
! 
! struct ConventionOOO_A1_XML : public ConventionOOO_A1
! {
! 	void MakeRefStr( rtl::OUStringBuffer&	rBuffer,
! 					 const ScCompiler&		rComp,
! 					 const ComplRefData& rRef,
! 					 BOOL bSingleRef ) const
  {
          rBuffer.append(sal_Unicode('['));
      ComplRefData aRef( rRef );
      // In case absolute/relative positions weren't separately available:
*************** void ScCompiler::MakeRefStr( rtl::OUStri
*** 488,496 ****
  //  AdjustReference( aRef.Ref1 );
  //  if( !bSingleRef )
  //      AdjustReference( aRef.Ref2 );
!     aRef.Ref1.CalcAbsIfRel( aPos );
      if( !bSingleRef )
!         aRef.Ref2.CalcAbsIfRel( aPos );
      if( aRef.Ref1.IsFlag3D() )
      {
          if (aRef.Ref1.IsTabDeleted())
--- 591,599 ----
  //  AdjustReference( aRef.Ref1 );
  //  if( !bSingleRef )
  //      AdjustReference( aRef.Ref2 );
! 			aRef.Ref1.CalcAbsIfRel( rComp.aPos );
      if( !bSingleRef )
! 				aRef.Ref2.CalcAbsIfRel( rComp.aPos );
      if( aRef.Ref1.IsFlag3D() )
      {
          if (aRef.Ref1.IsTabDeleted())
*************** void ScCompiler::MakeRefStr( rtl::OUStri
*** 503,515 ****
          else
          {
              String aDoc;
!             String aRefStr( MakeTabStr( aRef.Ref1.nTab, aDoc ) );
              rBuffer.append(aDoc);
              if (!aRef.Ref1.IsTabRel()) rBuffer.append(sal_Unicode('$'));
              rBuffer.append(aRefStr);
          }
      }
!     else if (bCompileXML)
          rBuffer.append(sal_Unicode('.'));
      if (!aRef.Ref1.IsColRel())
          rBuffer.append(sal_Unicode('$'));
--- 606,618 ----
          else
          {
              String aDoc;
! 					String aRefStr( MakeTabStr( rComp, aRef.Ref1.nTab, aDoc ) );
              rBuffer.append(aDoc);
              if (!aRef.Ref1.IsTabRel()) rBuffer.append(sal_Unicode('$'));
              rBuffer.append(aRefStr);
          }
      }
! 			else
          rBuffer.append(sal_Unicode('.'));
      if (!aRef.Ref1.IsColRel())
          rBuffer.append(sal_Unicode('$'));
*************** void ScCompiler::MakeRefStr( rtl::OUStri
*** 538,550 ****
              else
              {
                  String aDoc;
!                 String aRefStr( MakeTabStr( aRef.Ref2.nTab, aDoc ) );
                  rBuffer.append(aDoc);
                  if (!aRef.Ref2.IsTabRel()) rBuffer.append(sal_Unicode('$'));
                  rBuffer.append(aRefStr);
              }
          }
!         else if (bCompileXML)
              rBuffer.append(sal_Unicode('.'));
          if (!aRef.Ref2.IsColRel())
              rBuffer.append(sal_Unicode('$'));
--- 641,653 ----
              else
              {
                  String aDoc;
! 						String aRefStr( MakeTabStr( rComp, aRef.Ref2.nTab, aDoc ) );
                  rBuffer.append(aDoc);
                  if (!aRef.Ref2.IsTabRel()) rBuffer.append(sal_Unicode('$'));
                  rBuffer.append(aRefStr);
              }
          }
! 				else
              rBuffer.append(sal_Unicode('.'));
          if (!aRef.Ref2.IsColRel())
              rBuffer.append(sal_Unicode('$'));
*************** void ScCompiler::MakeRefStr( rtl::OUStri
*** 559,570 ****
          else
              MakeRowStr( rBuffer, aRef.Ref2.nRow );
      }
-     if (bCompileXML)
          rBuffer.append(sal_Unicode(']'));
  }
  
  //---------------------------------------------------------------------------
  
  void ScCompiler::SetError(USHORT nError)
  {
      if( !pArr->GetError() )
--- 662,1084 ----
          else
              MakeRowStr( rBuffer, aRef.Ref2.nRow );
      }
          rBuffer.append(sal_Unicode(']'));
  }
+ };
+ 
+ static const ConventionOOO_A1_XML ConvOOO_A1_XML;
+ static const ScCompiler::Convention *pConvOOO_A1_XML = &ConvOOO_A1_XML;
+ 
+ //-----------------------------------------------------------------------------
+ 
+ struct ConventionXL
+ {
+ 	static bool GetDocAndTab( const ScCompiler& rComp,
+ 							  const SingleRefData& rRef,
+ 							  String& rDocName,
+ 							  String& rTabName )
+ 	{
+ 		bool bHasDoc = false;
+ 
+ 		rDocName.Erase();
+ 		if (rRef.IsTabDeleted() ||
+ 			!rComp.pDoc->GetName( rRef.nTab, rTabName ))
+ 		{
+ 			rTabName = ScGlobal::GetRscString( STR_NO_REF_TABLE );
+ 			return false;
+ 		}
+ 
+ 		// Cheesy hack to unparse the OOO style "'Doc'#Tab"
+ 		if ( rTabName.GetChar(0) == '\'' )
+ 		{
+ 			xub_StrLen nPos, nLen = 1;
+ 
+ 			while( (nPos = rTabName.Search( '\'', nLen )) != STRING_NOTFOUND )
+ 				nLen = nPos + 1;
+ 
+ 			if ( rTabName.GetChar(nLen) == SC_COMPILER_FILE_TAB_SEP )
+ 			{
+ 				rDocName = rTabName.Copy( 0, nLen );
+ 				// TODO : More research into how XL escapes the doc path
+ 				rDocName = INetURLObject::decode( rDocName, INET_HEX_ESCAPE,
+ 					INetURLObject::DECODE_UNAMBIGUOUS );
+ 				rTabName.Erase( 0, nLen + 1 );
+ 				bHasDoc = true;
+ 			}
+ 		}
+ 
+ 		// XL uses the same sheet name quoting conventions in both modes
+ 		// it is safe to use A1 here
+ 		ScCompiler::CheckTabQuotes( rTabName, ScAddress::CONV_XL_A1 );
+ 		return bHasDoc;
+ 	}
+ 
+ 	static void MakeDocStr( rtl::OUStringBuffer& rBuf,
+ 							const ScCompiler& rComp,
+ 							const ComplRefData& rRef,
+ 							bool bSingleRef )
+ 	{
+ 		if( rRef.Ref1.IsFlag3D() )
+ 		{
+ 			String aStartTabName, aStartDocName, aEndTabName, aEndDocName;
+ 			bool bStartHasDoc = false, bEndHasDoc = false;
+ 
+ 			bStartHasDoc = GetDocAndTab( rComp, rRef.Ref1,
+ 										 aStartDocName, aStartTabName);
+ 
+ 			if( !bSingleRef && rRef.Ref2.IsFlag3D() )
+ 			{
+ 				bEndHasDoc = GetDocAndTab( rComp, rRef.Ref2,
+ 										   aEndDocName, aEndTabName);
+ 			}
+ 			else
+ 				bEndHasDoc = bStartHasDoc;
+ 
+ 			if( bStartHasDoc )
+ 			{
+ 				// A ref across multipled workbooks ?
+ 				if( !bEndHasDoc )
+ 					return;
+ 
+ 				rBuf.append( sal_Unicode( '[' ) );
+ 				rBuf.append( aStartDocName );
+ 				rBuf.append( sal_Unicode( ']' ) );
+ 			}
+ 
+ 			rBuf.append( aStartTabName );
+ 			if( !bSingleRef && aStartTabName != aEndTabName )
+ 			{
+ 				rBuf.append( sal_Unicode( ':' ) );
+ 				rBuf.append( aEndTabName );
+ 			}
+ 
+ 			rBuf.append( sal_Unicode( '!' ) );
+ 		}
+ 	}
+ };
+ 
+ struct ConventionXL_A1 : public Convention_A1, public ConventionXL
+ {
+ 	ConventionXL_A1() : Convention_A1( ScAddress::CONV_XL_A1 ) { }
+ 	void MakeRefStr( rtl::OUStringBuffer&	rBuf,
+ 					 const ScCompiler&		rComp,
+ 					 const ComplRefData& rRef,
+ 					 BOOL bSingleRef ) const
+ 	{
+ 		ComplRefData aRef( rRef );
+ 
+ 		MakeDocStr( rBuf, rComp, aRef, bSingleRef );
+ 
+ 		// Play fast and loose with invalid refs.  There is not much point in producing
+ 		// Foo!A1:#REF! versus #REF! at this point
+ 		aRef.Ref1.CalcAbsIfRel( rComp.aPos );
+ 		if( aRef.Ref1.IsColDeleted() || aRef.Ref1.IsRowDeleted() )
+ 		{
+ 			rBuf.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
+ 			return;
+ 		}
+ 
+ 		if( !bSingleRef )
+ 		{
+ 			aRef.Ref2.CalcAbsIfRel( rComp.aPos );
+ 			if( aRef.Ref2.IsColDeleted() || aRef.Ref2.IsRowDeleted() )
+ 			{
+ 				rBuf.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
+ 				return;
+ 			}
+ 
+ 			if( aRef.Ref1.nCol == 0 && aRef.Ref2.nCol >= MAXCOL )
+ 			{
+ 				if (!aRef.Ref1.IsRowRel())
+ 					rBuf.append(sal_Unicode( '$' ));
+ 				MakeRowStr( rBuf, aRef.Ref1.nRow );
+ 				rBuf.append(sal_Unicode( ':' ));
+ 				if (!aRef.Ref2.IsRowRel())
+ 					rBuf.append(sal_Unicode( '$' ));
+ 				MakeRowStr( rBuf, aRef.Ref2.nRow );
+ 				return;
+ 			} 
+ 
+ 			if( aRef.Ref1.nRow == 0 && aRef.Ref2.nRow >= MAXROW )
+ 			{
+ 				if (!aRef.Ref1.IsColRel())
+ 					rBuf.append(sal_Unicode( '$' ));
+ 				MakeColStr(rBuf, aRef.Ref1.nCol );
+ 				rBuf.append(sal_Unicode( ':' ));
+ 				if (!aRef.Ref2.IsColRel())
+ 					rBuf.append(sal_Unicode( '$' ));
+ 				MakeColStr(rBuf, aRef.Ref2.nCol );
+ 				return;
+ 			}
+ 		}
+ 
+ 		if (!aRef.Ref1.IsColRel())
+ 			rBuf.append(sal_Unicode('$'));
+ 		MakeColStr(rBuf, aRef.Ref1.nCol );
+ 		if (!aRef.Ref1.IsRowRel())
+ 			rBuf.append(sal_Unicode('$'));
+ 		MakeRowStr( rBuf, aRef.Ref1.nRow );
+ 
+ 		if (!bSingleRef)
+ 		{
+ 			rBuf.append(sal_Unicode( ':' ));
+ 			if (!aRef.Ref2.IsColRel())
+ 				rBuf.append(sal_Unicode('$'));
+ 			MakeColStr(rBuf, aRef.Ref2.nCol );
+ 			if (!aRef.Ref2.IsRowRel())
+ 				rBuf.append(sal_Unicode('$'));
+ 			MakeRowStr( rBuf, aRef.Ref2.nRow );
+ 		}
+ 	}
+ };
+ 
+ static const ConventionXL_A1 ConvXL_A1;
+ static const ScCompiler::Convention *pConvXL_A1 = &ConvXL_A1;
+ 
+ //-----------------------------------------------------------------------------
+ 
+ static void
+ r1c1_add_col( rtl::OUStringBuffer &rBuf, const SingleRefData& rRef )
+ {
+ 	rBuf.append( sal_Unicode( 'C' ) );
+ 	if( rRef.IsColRel() )
+ 	{
+ 		if (rRef.nRelCol != 0)
+ 		{
+ 			rBuf.append( sal_Unicode( '[' ) );
+ 			rBuf.append( String::CreateFromInt32( rRef.nRelCol ) );
+ 			rBuf.append( sal_Unicode( ']' ) );
+ 		}
+ 	}
+ 	else
+ 		rBuf.append( String::CreateFromInt32( rRef.nCol + 1 ) );
+ }
+ static void
+ r1c1_add_row( rtl::OUStringBuffer &rBuf, const SingleRefData& rRef )
+ {
+ 	rBuf.append( sal_Unicode( 'R' ) );
+ 	if( rRef.IsRowRel() )
+ 	{
+ 		if (rRef.nRelRow != 0)
+ 		{
+ 			rBuf.append( sal_Unicode( '[' ) );
+ 			rBuf.append( String::CreateFromInt32( rRef.nRelRow ) );
+ 			rBuf.append( sal_Unicode( ']' ) );
+ 		}
+ 	}
+ 	else
+ 		rBuf.append( String::CreateFromInt32( rRef.nRow + 1 ) );
+ }
+ 
+ struct ConventionXL_R1C1 : public ScCompiler::Convention, public ConventionXL
+ {
+ 	ConventionXL_R1C1() : ScCompiler::Convention( ScAddress::CONV_XL_R1C1 ) { }
+ 	void MakeRefStr( rtl::OUStringBuffer&	rBuf,
+ 					 const ScCompiler&		rComp,
+ 					 const ComplRefData& rRef,
+ 					 BOOL bSingleRef ) const
+ 	{
+ 		ComplRefData aRef( rRef );
+ 
+ 		MakeDocStr( rBuf, rComp, aRef, bSingleRef );
+ 
+ 		// Play fast and loose with invalid refs.  There is not much point in producing
+ 		// Foo!A1:#REF! versus #REF! at this point
+ 		aRef.Ref1.CalcAbsIfRel( rComp.aPos );
+ 		if( aRef.Ref1.IsColDeleted() || aRef.Ref1.IsRowDeleted() )
+ 		{
+ 			rBuf.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
+ 			return;
+ 		}
+ 
+ 		if( !bSingleRef )
+ 		{
+ 			aRef.Ref2.CalcAbsIfRel( rComp.aPos );
+ 			if( aRef.Ref2.IsColDeleted() || aRef.Ref2.IsRowDeleted() )
+ 			{
+ 				rBuf.append(ScGlobal::GetRscString(STR_NO_REF_TABLE));
+ 				return;
+ 			}
+ 
+ 			if( aRef.Ref1.nCol == 0 && aRef.Ref2.nCol >= MAXCOL )
+ 			{
+ 				r1c1_add_row( rBuf,  rRef.Ref1 );
+ 				if( rRef.Ref1.nRow != rRef.Ref2.nRow ||
+ 					rRef.Ref1.IsRowRel() != rRef.Ref2.IsRowRel() ) {
+ 					rBuf.append (sal_Unicode ( ':' ) );
+ 					r1c1_add_row( rBuf,  rRef.Ref2 );
+ 				}
+ 				return;
+ 
+ 			}
+ 
+ 			if( aRef.Ref1.nRow == 0 && aRef.Ref2.nRow >= MAXROW )
+ 			{
+ 				r1c1_add_col( rBuf, rRef.Ref1 );
+ 				if( rRef.Ref1.nCol != rRef.Ref2.nCol ||
+ 					rRef.Ref1.IsColRel() != rRef.Ref2.IsColRel() )
+ 				{
+ 					rBuf.append (sal_Unicode ( ':' ) );
+ 					r1c1_add_col( rBuf,  rRef.Ref2 );
+ 				}
+ 				return;
+ 			}
+ 		}
+ 
+ 		r1c1_add_row( rBuf, rRef.Ref1 );
+ 		r1c1_add_col( rBuf, rRef.Ref1 );
+ 		if (!bSingleRef)
+ 		{
+ 			rBuf.append (sal_Unicode ( ':' ) );
+ 			r1c1_add_row( rBuf, rRef.Ref2 );
+ 			r1c1_add_col( rBuf, rRef.Ref2 );
+ 		}
+ 	}
+ 
+ 	ParseResult parseAnyToken( const String& rFormula,
+ 							   xub_StrLen nSrcPos,
+ 							   const CharClass* pCharClass) const
+ 	{
+         static const sal_Int32 nStartFlags = KParseTokens::ANY_LETTER_OR_NUMBER |
+             KParseTokens::ASC_UNDERSCORE ;
+         static const sal_Int32 nContFlags = nStartFlags | KParseTokens::ASC_DOT |
+             KParseTokens::ASC_COLON;
+         // '?' allowed in range names because of Xcl :-/
+ 		static const String aAddAllowed = String::CreateFromAscii( "?-[]" );
+ 
+ 		return pCharClass->parseAnyToken( rFormula,
+                 nSrcPos, nStartFlags, aAddAllowed, nContFlags, aAddAllowed );
+ 	}
+ };
+ 
+ static const ConventionXL_R1C1 ConvXL_R1C1;
+ static const ScCompiler::Convention *pConvXL_R1C1 = &ConvXL_R1C1;
+ 
+ //-----------------------------------------------------------------------------
+ ScCompiler::ScCompiler( ScDocument* pDocument, const ScAddress& rPos,
+                         const ScTokenArray& rArr )
+         :
+         aPos( rPos ),
+         pSymbolTable( pSymbolTableNative ),
+         pSymbolHashMap( pSymbolHashMapNative ),
+         pCharClass( ScGlobal::pCharClass ),
+         nRecursion(0),
+         bAutoCorrect( FALSE ),
+         bCorrected( FALSE ),
+         bCompileForFAP( FALSE ),
+         bIgnoreErrors( FALSE ),
+         bImportXML ( FALSE )
+ {
+     if (!nAnzStrings)
+         Init();
+     pArr = (ScTokenArray*) &rArr;
+     pDoc = pDocument;
+ 
+ 	if (NULL != pDoc)
+ 		SetRefConvention( pDoc->GetAddressConvention() );
+ 	else
+ 		SetRefConvention( pConvOOO_A1 );
+ 
+     nMaxTab = pDoc->GetTableCount() - 1;
+     pStack = NULL;
+     nNumFmt = NUMBERFORMAT_UNDEFINED;
+ }
+ 
+ ScCompiler::ScCompiler(ScDocument* pDocument, const ScAddress& rPos )
+         :
+         aPos( rPos ),
+         pSymbolTable( pSymbolTableNative ),
+         pSymbolHashMap( pSymbolHashMapNative ),
+         pCharClass( ScGlobal::pCharClass ),
+         nRecursion(0),
+         bAutoCorrect( FALSE ),
+         bCorrected( FALSE ),
+         bCompileForFAP( FALSE ),
+         bIgnoreErrors( FALSE ),
+         bImportXML ( FALSE )
+ {
+     if (!nAnzStrings)
+         Init();
+     pDoc = pDocument;
+ 
+ 	if (NULL != pDoc)
+ 		SetRefConvention( pDoc->GetAddressConvention() );
+ 	else
+ 		SetRefConvention( pConvOOO_A1 );
+ 
+     nMaxTab = pDoc ? pDoc->GetTableCount() - 1 : 0;
+     pStack = NULL;
+     nNumFmt = NUMBERFORMAT_UNDEFINED;
+ }
+ 
+ void ScCompiler::CheckTabQuotes( String& rString,
+ 								 const ScAddress::Convention eConv )
+ {
+     register const sal_Unicode* p = rString.GetBuffer();
+     register const sal_Unicode* const pEnd = p + rString.Len();
+ 	bool bNeedsQuote = false;
+ 
+     while ( p < pEnd )
+     {
+         if( !IsWordChar( *p ) )
+         {
+ 			bNeedsQuote = true;
+ 			break;
+         }
+         p++;
+     }
+     if ( CharClass::isAsciiNumeric( rString ) )
+     {
+ 			bNeedsQuote = true;
+     }
+ 
+ 	switch ( eConv ) {
+ 	default :
+ 	case ScAddress::CONV_UNSPECIFIED :
+ 	case ScAddress::CONV_OOO :
+ 		break;
+ 	case ScAddress::CONV_XL_A1 :
+ 	case ScAddress::CONV_XL_R1C1 :
+ 		if( bNeedsQuote )
+ 		{
+ 			static const String one_quote = static_cast<sal_Unicode>( '\'' );
+ 			static const String two_quote = String::CreateFromAscii( "''" );
+ 			// escape embedded quotes
+ 			rString.SearchAndReplaceAll( one_quote, two_quote );
+ 		}
+ 		break;
+ 	}
+ 
+ 	if( bNeedsQuote )
+ 	{
+ 		rString.Insert( '\'', 0 );
+ 		rString += '\'';
+ 	}
+ }
  
  //---------------------------------------------------------------------------
  
+ void ScCompiler::SetCompileXML( BOOL bVal )
+ {
+ 	SetRefConvention( bVal ? pConvOOO_A1_XML : pConvOOO_A1 );
+ }
+ void ScCompiler::SetRefConvention( ScAddress::Convention eConv )
+ {
+ 	switch ( eConv ) {
+ 	case ScAddress::CONV_UNSPECIFIED :
+ 		break;
+ 	default :
+ 	case ScAddress::CONV_OOO :		SetRefConvention( pConvOOO_A1 ); break;
+ 	case ScAddress::CONV_XL_A1 :	SetRefConvention( pConvXL_A1 );  break;
+ 	case ScAddress::CONV_XL_R1C1 :	SetRefConvention( pConvXL_R1C1 ); break;
+ 	}
+ }
+ 
+ void ScCompiler::SetRefConvention( const ScCompiler::Convention *pConvP )
+ {
+ 	pConv = pConvP;
+ }
+ 
  void ScCompiler::SetError(USHORT nError)
  {
      if( !pArr->GetError() )
*************** xub_StrLen ScCompiler::NextSymbol()
*** 755,768 ****
      }
      if ( bi18n )
      {
-         using namespace ::com::sun::star::i18n;
          nSrcPos += nSpaces;
-         sal_Int32 nStartFlags = KParseTokens::ANY_LETTER_OR_NUMBER |
-             KParseTokens::ASC_UNDERSCORE | KParseTokens::ASC_DOLLAR;
-         sal_Int32 nContFlags = nStartFlags | KParseTokens::ASC_DOT |
-             KParseTokens::ASC_COLON;
-         // '?' allowed in range names because of Xcl :-/
-         static const String aAddAllowed( '?' );
          String aSymbol;
          USHORT nErr = 0;
          do
--- 1269,1275 ----
*************** xub_StrLen ScCompiler::NextSymbol()
*** 772,779 ****
              if ( pStart[nSrcPos] == '$' && pStart[nSrcPos+1] == '\'' )
                  aSymbol += pStart[nSrcPos++];
  
!             ParseResult aRes = pCharClass->parseAnyToken( aFormula,
!                 nSrcPos, nStartFlags, aAddAllowed, nContFlags, aAddAllowed );
  
              if ( !aRes.TokenType )
                  SetError( nErr = errIllegalChar );      // parsed chars as string
--- 1279,1285 ----
              if ( pStart[nSrcPos] == '$' && pStart[nSrcPos+1] == '\'' )
                  aSymbol += pStart[nSrcPos++];
  
!             ParseResult aRes = pConv->parseAnyToken( aFormula, nSrcPos, pCharClass );
  
              if ( !aRes.TokenType )
                  SetError( nErr = errIllegalChar );      // parsed chars as string
*************** BOOL ScCompiler::IsReference( const Stri
*** 980,986 ****
          }
      }
      ScRange aRange( aPos, aPos );
!     USHORT nFlags = aRange.Parse( rName, pDoc );
      if( nFlags & SCA_VALID )
      {
          ScRawToken aToken;
--- 1486,1493 ----
          }
      }
      ScRange aRange( aPos, aPos );
! 	const ScAddress::Details aDetails( pConv->meConv, aPos );
!     USHORT nFlags = aRange.Parse( rName, pDoc, aDetails );
      if( nFlags & SCA_VALID )
      {
          ScRawToken aToken;
*************** BOOL ScCompiler::IsReference( const Stri
*** 1005,1011 ****
      else
      {
          ScAddress aAddr( aPos );
!         nFlags = aAddr.Parse( rName, pDoc );
          // Something must be valid in order to recognize Sheet1.blah or blah.a1
          // as a (wrong) reference.
          if( nFlags & ( SCA_VALID_COL|SCA_VALID_ROW|SCA_VALID_TAB ) )
--- 1512,1518 ----
      else
      {
          ScAddress aAddr( aPos );
!         nFlags = aAddr.Parse( rName, pDoc, aDetails );
          // Something must be valid in order to recognize Sheet1.blah or blah.a1
          // as a (wrong) reference.
          if( nFlags & ( SCA_VALID_COL|SCA_VALID_ROW|SCA_VALID_TAB ) )
*************** BOOL ScCompiler::IsColRowName( const Str
*** 1112,1118 ****
      BOOL bFound = FALSE;
      SingleRefData aRef;
      String aName( rName );
!     DeQuote( aName );
      SCTAB nThisTab = aPos.Tab();
      for ( short jThisTab = 1; jThisTab >= 0 && !bInList; jThisTab-- )
      {   // #50300# first check ranges on this sheet, in case of duplicated names
--- 1619,1625 ----
      BOOL bFound = FALSE;
      SingleRefData aRef;
      String aName( rName );
!     DeQuote( aName, pConv->meConv );
      SCTAB nThisTab = aPos.Tab();
      for ( short jThisTab = 1; jThisTab >= 0 && !bInList; jThisTab-- )
      {   // #50300# first check ranges on this sheet, in case of duplicated names
*************** BOOL ScCompiler::IsColRowName( const Str
*** 1185,1191 ****
      }
      if ( !bInList && pDoc->GetDocOptions().IsLookUpColRowNames() )
      {   // search in current sheet
!         long nDistance, nMax;
          long nMyCol = (long) aPos.Col();
          long nMyRow = (long) aPos.Row();
          BOOL bTwo = FALSE;
--- 1692,1698 ----
      }
      if ( !bInList && pDoc->GetDocOptions().IsLookUpColRowNames() )
      {   // search in current sheet
!         long nDistance = 0, nMax = 0;
          long nMyCol = (long) aPos.Col();
          long nMyRow = (long) aPos.Row();
          BOOL bTwo = FALSE;
*************** void ScCompiler::AutoCorrectParsedSymbol
*** 1452,1463 ****
          {
              String aSymbol( aCorrectedSymbol );
              String aDoc;
!             xub_StrLen nPos;
              if ( aSymbol.GetChar(0) == '\''
!               && ((nPos = aSymbol.SearchAscii( "'#" )) != STRING_NOTFOUND) )
              {   // Split off 'Doc'#, may be d:\... or whatever
!                 aDoc = aSymbol.Copy( 0, nPos + 2 );
!                 aSymbol.Erase( 0, nPos + 2 );
              }
              xub_StrLen nRefs = aSymbol.GetTokenCount( ':' );
              BOOL bColons;
--- 1959,1970 ----
          {
              String aSymbol( aCorrectedSymbol );
              String aDoc;
!             xub_StrLen nPosition;
              if ( aSymbol.GetChar(0) == '\''
!               && ((nPosition = aSymbol.SearchAscii( "'#" )) != STRING_NOTFOUND) )
              {   // Split off 'Doc'#, may be d:\... or whatever
!                 aDoc = aSymbol.Copy( 0, nPosition + 2 );
!                 aSymbol.Erase( 0, nPosition + 2 );
              }
              xub_StrLen nRefs = aSymbol.GetTokenCount( ':' );
              BOOL bColons;
*************** void ScCompiler::AutoCorrectParsedSymbol
*** 1527,1532 ****
--- 2034,2040 ----
              if ( nRefs && nRefs <= 2 )
              {   // reference twisted? 4A => A4 etc.
                  String aTab[2], aRef[2];
+ 				const ScAddress::Details aDetails( pConv->meConv, aPos );
                  if ( nRefs == 2 )
                  {
                      aRef[0] = aSymbol.GetToken( 0, ':' );
*************** void ScCompiler::AutoCorrectParsedSymbol
*** 1560,1566 ****
                      {
                          bChanged = TRUE;
                          ScAddress aAdr;
!                         bOk &= ((aAdr.Parse( aRef[j], pDoc ) & nMask) == nMask);
                      }
                  }
                  if ( bChanged && bOk )
--- 2068,2074 ----
                      {
                          bChanged = TRUE;
                          ScAddress aAdr;
!                         bOk &= ((aAdr.Parse( aRef[j], pDoc, aDetails ) & nMask) == nMask);
                      }
                  }
                  if ( bChanged && bOk )
*************** BOOL ScCompiler::NextNewToken()
*** 1661,1671 ****
          return FALSE;
  }
  
! ScTokenArray* ScCompiler::CompileString( const String& rFormula )
  {
      ScTokenArray aArr;
      pArr = &aArr;
      aFormula = rFormula;
      aFormula.EraseLeadingChars();
      aFormula.EraseTrailingChars();
      nSrcPos = 0;
--- 2169,2183 ----
          return FALSE;
  }
  
! ScTokenArray* ScCompiler::CompileString( const String& rFormula,
! 										 ScAddress::Convention eConv )
  {
      ScTokenArray aArr;
      pArr = &aArr;
      aFormula = rFormula;
+ 
+ 	SetRefConvention( eConv );
+ 
      aFormula.EraseLeadingChars();
      aFormula.EraseTrailingChars();
      nSrcPos = 0;
*************** BOOL ScCompiler::GetToken()
*** 1856,1863 ****
                  // in short: if it isn't a self-contained expression.
                  ScToken* p1 = pArr->PeekPrevNoSpaces();
                  ScToken* p2 = pArr->PeekNextNoSpaces();
!                 OpCode eOp1 = (p1 ? p1->GetOpCode() : ocSep);
!                 OpCode eOp2 = (p2 ? p2->GetOpCode() : ocSep);
                  BOOL bBorder1 = (eOp1 == ocSep || eOp1 == ocOpen);
                  BOOL bBorder2 = (eOp2 == ocSep || eOp2 == ocClose);
                  BOOL bAddPair = !(bBorder1 && bBorder2);
--- 2368,2375 ----
                  // in short: if it isn't a self-contained expression.
                  ScToken* p1 = pArr->PeekPrevNoSpaces();
                  ScToken* p2 = pArr->PeekNextNoSpaces();
!                 OpCode eOp1 = (p1 ? p1->GetOpCode() : static_cast<OpCode>( ocSep ) );
!                 OpCode eOp2 = (p2 ? p2->GetOpCode() : static_cast<OpCode>( ocSep ) );
                  BOOL bBorder1 = (eOp1 == ocSep || eOp1 == ocOpen);
                  BOOL bBorder2 = (eOp2 == ocSep || eOp2 == ocClose);
                  BOOL bAddPair = !(bBorder1 && bBorder2);
*************** BOOL ScCompiler::GetToken()
*** 2021,2028 ****
                  ScToken* p1 = pArr->PeekPrevNoSpaces();
                  ScToken* p2 = pArr->PeekNextNoSpaces();
                  // begin/end of a formula => single
!                 OpCode eOp1 = p1 ? p1->GetOpCode() : ocAdd;
!                 OpCode eOp2 = p2 ? p2->GetOpCode() : ocAdd;
                  if ( eOp1 != ocColRowName && eOp1 != ocIntersect
                      && eOp2 != ocColRowName && eOp2 != ocIntersect )
                  {
--- 2533,2540 ----
                  ScToken* p1 = pArr->PeekPrevNoSpaces();
                  ScToken* p2 = pArr->PeekNextNoSpaces();
                  // begin/end of a formula => single
!                 OpCode eOp1 = p1 ? p1->GetOpCode() : static_cast<OpCode>( ocAdd );
!                 OpCode eOp2 = p2 ? p2->GetOpCode() : static_cast<OpCode>( ocAdd );
                  if ( eOp1 != ocColRowName && eOp1 != ocIntersect
                      && eOp2 != ocColRowName && eOp2 != ocIntersect )
                  {
*************** void ScCompiler::Factor()
*** 2383,2391 ****
              case ocFormula:
              case ocInfo:
              // more than one parameters:
!                 // ocIndirect otherwise would have to do StopListening and
!                 // StartListening on a reference for every interpreted value.
              case ocIndirect:
                  // ocOffset results in indirect references.
              case ocOffset:
                  pArr->SetRecalcModeAlways();
--- 2895,2905 ----
              case ocFormula:
              case ocInfo:
              // more than one parameters:
! 				// ocIndirect/ocIndirectXL otherwise would have to do
! 				// StopListening and StartListening on a reference for every
! 				// interpreted value.
              case ocIndirect:
+             case ocIndirectXL:
                  // ocOffset results in indirect references.
              case ocOffset:
                  pArr->SetRecalcModeAlways();
*************** const String& ScCompiler::GetStringFromO
*** 3741,3761 ****
      return EMPTY_STRING;
  }
  
! ScToken* ScCompiler::CreateStringFromToken( String& rFormula, ScToken* pToken,
          BOOL bAllowArrAdvance )
  {
      rtl::OUStringBuffer aBuffer;
!     ScToken* p = CreateStringFromToken( aBuffer, pToken, bAllowArrAdvance );
      rFormula += aBuffer;
      return p;
  }
  
! ScToken* ScCompiler::CreateStringFromToken( rtl::OUStringBuffer& rBuffer, ScToken* pToken,
          BOOL bAllowArrAdvance )
  {
      BOOL bNext = TRUE;
      BOOL bSpaces = FALSE;
!     ScToken* t = pToken;
      OpCode eOp = t->GetOpCode();
      if( eOp >= ocAnd && eOp <= ocOr )
      {
--- 4255,4275 ----
      return EMPTY_STRING;
  }
  
! ScToken* ScCompiler::CreateStringFromToken( String& rFormula, ScToken* pTokenP,
          BOOL bAllowArrAdvance )
  {
      rtl::OUStringBuffer aBuffer;
!     ScToken* p = CreateStringFromToken( aBuffer, pTokenP, bAllowArrAdvance );
      rFormula += aBuffer;
      return p;
  }
  
! ScToken* ScCompiler::CreateStringFromToken( rtl::OUStringBuffer& rBuffer, ScToken* pTokenP,
          BOOL bAllowArrAdvance )
  {
      BOOL bNext = TRUE;
      BOOL bSpaces = FALSE;
!     ScToken* t = pTokenP;
      OpCode eOp = t->GetOpCode();
      if( eOp >= ocAnd && eOp <= ocOr )
      {
*************** ScToken* ScCompiler::CreateStringFromTok
*** 3848,3868 ****
                  {
                      String aStr;
                      pDoc->GetString( rRef.nCol, rRef.nRow, rRef.nTab, aStr );
!                     EnQuote( aStr );
                      rBuffer.append(aStr);
                  }
                  else
                  {
                      rBuffer.append(ScGlobal::GetRscString(STR_NO_NAME_REF));
!                     MakeRefStr( rBuffer, aRef, TRUE );
                  }
              }
              else
!                 MakeRefStr( rBuffer, aRef, TRUE );
          }
              break;
          case svDoubleRef:
!             MakeRefStr( rBuffer, t->GetDoubleRef(), FALSE );
              break;
          case svIndex:
          {
--- 4362,4382 ----
                  {
                      String aStr;
                      pDoc->GetString( rRef.nCol, rRef.nRow, rRef.nTab, aStr );
!                     EnQuote( aStr, pConv->meConv );
                      rBuffer.append(aStr);
                  }
                  else
                  {
                      rBuffer.append(ScGlobal::GetRscString(STR_NO_NAME_REF));
! 					pConv->MakeRefStr (rBuffer, *this, aRef, TRUE );
                  }
              }
              else
! 				pConv->MakeRefStr( rBuffer, *this, aRef, TRUE );
          }
              break;
          case svDoubleRef:
! 			pConv->MakeRefStr( rBuffer, *this, t->GetDoubleRef(), FALSE );
              break;
          case svIndex:
          {
*************** ScToken* ScCompiler::CreateStringFromTok
*** 3877,3883 ****
                          if (pData->HasType(RT_SHARED))
                              pData->UpdateSymbol( aBuffer, aPos,
                                          pSymbolTable == pSymbolTableEnglish,
!                                         bCompileXML );
                          else
                              aBuffer.append(pData->GetName());
                      }
--- 4391,4397 ----
                          if (pData->HasType(RT_SHARED))
                              pData->UpdateSymbol( aBuffer, aPos,
                                          pSymbolTable == pSymbolTableEnglish,
!                                         pConv == pConvOOO_A1_XML );
                          else
                              aBuffer.append(pData->GetName());
                      }
*************** ScToken* ScCompiler::CreateStringFromTok
*** 3924,3930 ****
              t = pArr->Next();
          return t;
      }
!     return pToken;
  }
  
  void ScCompiler::CreateStringFromTokenArray( String& rFormula )
--- 4438,4444 ----
              t = pArr->Next();
          return t;
      }
!     return pTokenP;
  }
  
  void ScCompiler::CreateStringFromTokenArray( String& rFormula )
*************** void ScCompiler::CreateStringFromTokenAr
*** 3950,3961 ****
          t = CreateStringFromToken( rBuffer, t, TRUE );
  }
  
! BOOL ScCompiler::EnQuote( String& rStr )
  {
      sal_Int32 nType = ScGlobal::pCharClass->getStringType( rStr, 0, rStr.Len() );
      if ( !CharClass::isNumericType( nType )
              && CharClass::isAlphaNumericType( nType ) )
          return FALSE;
      xub_StrLen nPos = 0;
      while ( (nPos = rStr.Search( '\'', nPos)) != STRING_NOTFOUND )
      {
--- 4464,4479 ----
          t = CreateStringFromToken( rBuffer, t, TRUE );
  }
  
! // Put quotes around string if non-alphanumeric characters are contained,
! // quote characters contained within are escaped by '\\'.
! BOOL ScCompiler::EnQuote( String& rStr,
! 						  const ScAddress::Convention eConv )
  {
      sal_Int32 nType = ScGlobal::pCharClass->getStringType( rStr, 0, rStr.Len() );
      if ( !CharClass::isNumericType( nType )
              && CharClass::isAlphaNumericType( nType ) )
          return FALSE;
+ 
      xub_StrLen nPos = 0;
      while ( (nPos = rStr.Search( '\'', nPos)) != STRING_NOTFOUND )
      {
*************** BOOL ScCompiler::EnQuote( String& rStr )
*** 3967,3974 ****
      return TRUE;
  }
  
! 
! BOOL ScCompiler::DeQuote( String& rStr )
  {
      xub_StrLen nLen = rStr.Len();
      if ( nLen > 1 && rStr.GetChar(0) == '\'' && rStr.GetChar( nLen-1 ) == '\'' )
--- 4485,4493 ----
      return TRUE;
  }
  
! // Remove quotes, escaped quotes are unescaped.
! BOOL ScCompiler::DeQuote( String& rStr,
! 						  const ScAddress::Convention eConv )
  {
      xub_StrLen nLen = rStr.Len();
      if ( nLen > 1 && rStr.GetChar(0) == '\'' && rStr.GetChar( nLen-1 ) == '\'' )
Index: sc/source/core/tool/interpr1.cxx
===================================================================
RCS file: /cvs/sc/source/core/tool/interpr1.cxx,v
diff -cpr sc/source/core/tool/interpr1.cxx sc/source/core/tool/interpr1.cxx
*** sc/source/core/tool/interpr1.cxx	Wed Aug 23 16:33:09 2006
--- sc/source/core/tool/interpr1.cxx	Thu Aug 24 10:45:05 2006
*************** void ScInterpreter::ScDBVarP()
*** 5366,5392 ****
  }
  
  
! void ScInterpreter::ScIndirect()
  {
  	BYTE nParamCount = GetByte();
! /*
! 	if (nParamCount == 2)
! 	{
! 		double fBool = GetDouble();
! 		if (fBool == 0.0)							// nur TRUE erlaubt!!
  		{
! 			SetIllegalParameter();
! 			return;
! 		}
  		else
! 			nParamCount = 1;
  	}
! */
  	if ( MustHaveParamCount( nParamCount, 1 )  )
  	{
  		SCTAB nTab = aPos.Tab();
  		String sRefStr( GetString() );
  		ScRefAddress aRefAd, aRefAd2;
  		if ( ConvertDoubleRef( pDok, sRefStr, nTab, aRefAd, aRefAd2 ) )
  			PushDoubleRef( aRefAd.Col(), aRefAd.Row(), aRefAd.Tab(),
  				aRefAd2.Col(), aRefAd2.Row(), aRefAd2.Tab() );
--- 5366,5403 ----
  }
  
  
! void ScInterpreter::ScIndirectXL()
  {
  	BYTE nParamCount = GetByte();
! 	ScAddress::Convention conv = ScAddress::CONV_XL_A1;
! 
! 	if (nParamCount == 2 && 0. == GetDouble())
! 		conv = ScAddress::CONV_XL_R1C1;
! 
! 	if ( MustHaveParamCount( nParamCount, 1, 2 )  )
  		{
! 		ScAddress::Details const details( conv, aPos );
! 		SCTAB nTab = aPos.Tab();
! 		String sRefStr( GetString() );
! 		ScRefAddress aRefAd, aRefAd2;
! 		if ( ConvertDoubleRef( pDok, sRefStr, nTab, aRefAd, aRefAd2, details ) )
! 			PushDoubleRef( aRefAd.Col(), aRefAd.Row(), aRefAd.Tab(),
! 				aRefAd2.Col(), aRefAd2.Row(), aRefAd2.Tab() );
! 		else if ( ConvertSingleRef ( pDok, sRefStr, nTab, aRefAd, details ) )
! 			PushSingleRef( aRefAd.Col(), aRefAd.Row(), aRefAd.Tab() );
  		else
! 			SetIllegalArgument();
  	}
! }
! void ScInterpreter::ScIndirect()
! {
! 	BYTE nParamCount = GetByte();
  	if ( MustHaveParamCount( nParamCount, 1 )  )
  	{
  		SCTAB nTab = aPos.Tab();
  		String sRefStr( GetString() );
  		ScRefAddress aRefAd, aRefAd2;
+ 		/* Always OOO format which does not require a position */
  		if ( ConvertDoubleRef( pDok, sRefStr, nTab, aRefAd, aRefAd2 ) )
  			PushDoubleRef( aRefAd.Col(), aRefAd.Row(), aRefAd.Tab(),
  				aRefAd2.Col(), aRefAd2.Row(), aRefAd2.Tab() );
*************** void ScInterpreter::ScAdress()
*** 5442,5447 ****
--- 5453,5528 ----
  	}
  }
  
+ void ScInterpreter::ScAdressXL()
+ {
+ 	String	sTabStr;
+ 
+ 	BYTE	nParamCount = GetByte();
+ 	if( !MustHaveParamCount( nParamCount, 2, 5 ) )
+ 		return;
+ 
+ 	if( nParamCount >= 5 )
+ 		sTabStr = GetString();
+ 
+ 	ScAddress::Convention eConv = ScAddress::CONV_XL_A1;	// default
+ 	if( nParamCount >= 4 && (USHORT) ::rtl::math::approxFloor(GetDouble()) == 0 )
+ 		eConv = ScAddress::CONV_XL_R1C1;
+ 
+ 	USHORT	nFlags = SCA_COL_ABSOLUTE | SCA_ROW_ABSOLUTE;	// default
+ 	if( nParamCount >= 3 )
+ 	{
+ 		USHORT n = (USHORT) ::rtl::math::approxFloor(GetDouble());
+ 		switch ( n )
+ 		{
+ 		default :
+ 			SetNoValue();
+ 			return;
+ 
+ 		case 5:
+ 		case 1 : break;	// default
+ 		case 6:
+ 		case 2 : nFlags = SCA_ROW_ABSOLUTE; break;
+ 		case 7:
+ 		case 3 : nFlags = SCA_COL_ABSOLUTE; break;
+ 		case 8:
+ 		case 4 : nFlags = 0; break;	// both relative
+ 		}
+ 	}
+ 	nFlags |= SCA_VALID | SCA_VALID_ROW | SCA_VALID_COL;
+ 
+ 	SCCOL nCol = (SCCOL) ::rtl::math::approxFloor(GetDouble());
+ 	SCROW nRow = (SCROW) ::rtl::math::approxFloor(GetDouble());
+ 	if( eConv == ScAddress::CONV_XL_R1C1 )
+ 	{
+ 		// YUCK!  The XL interface actually treats rel R1C1 refs differently
+ 		// than A1
+ 		if( !(nFlags & SCA_COL_ABSOLUTE) )
+ 			nCol += aPos.Col() + 1;
+ 		if( !(nFlags & SCA_ROW_ABSOLUTE) )
+ 			nRow += aPos.Row() + 1;
+ 	}
+ 
+ 	if( nCol < 1 || nCol > MAXCOL + 1 || nRow < 1 || nRow > MAXROW + 1 )
+ 	{
+ 		SetNoValue();
+ 		return;
+ 	}
+ 
+ 	String aRefStr;
+ 	const ScAddress::Details	aDetails( eConv, aPos );
+ 	const ScAddress aAdr( nCol-1, nRow-1, 0);
+ 	aAdr.Format( aRefStr, nFlags, pDok, aDetails );
+ 
+ 	if( nParamCount >= 5 )
+ 	{	// TODO Do we need to quote this ?
+ 		sTabStr += static_cast<sal_Unicode>('!');
+ 		sTabStr += aRefStr;
+ 		PushString( sTabStr );
+ 	}
+ 	else
+ 		PushString( aRefStr );
+ }
+ 
  
  void ScInterpreter::ScOffset()
  {
Index: sc/source/core/tool/interpr4.cxx
===================================================================
RCS file: /cvs/sc/source/core/tool/interpr4.cxx,v
diff -cpr sc/source/core/tool/interpr4.cxx sc/source/core/tool/interpr4.cxx
*** sc/source/core/tool/interpr4.cxx	Wed Aug 23 16:41:36 2006
--- sc/source/core/tool/interpr4.cxx	Thu Aug 24 10:45:05 2006
*************** StackVar ScInterpreter::Interpret()
*** 3401,3407 ****
--- 3401,3409 ----
                  case ocDBVar            : ScDBVar();                    break;
                  case ocDBVarP           : ScDBVarP();                   break;
                  case ocIndirect         : ScIndirect();                 break;
+                 case ocIndirectXL       : ScIndirectXL();               break;
                  case ocAdress           : ScAdress();                   break;
+                 case ocAdressXL         : ScAdressXL();                 break;
                  case ocMatch            : ScMatch();                    break;
                  case ocCountEmptyCells  : ScCountEmptyCells();          break;
                  case ocCountIf          : ScCountIf();                  break;
Index: sc/source/core/tool/rangelst.cxx
===================================================================
RCS file: /cvs/sc/source/core/tool/rangelst.cxx,v
diff -cpr sc/source/core/tool/rangelst.cxx sc/source/core/tool/rangelst.cxx
*** sc/source/core/tool/rangelst.cxx	Fri Jul 21 07:40:11 2006
--- sc/source/core/tool/rangelst.cxx	Thu Aug 24 10:45:05 2006
*************** void ScRangeList::RemoveAll()
*** 66,72 ****
  	Clear();
  }
  
! USHORT ScRangeList::Parse( const String& rStr, ScDocument* pDoc, USHORT nMask )
  {
  	if ( rStr.Len() )
  	{
--- 66,73 ----
  	Clear();
  }
  
! USHORT ScRangeList::Parse( const String& rStr, ScDocument* pDoc, USHORT nMask,
! 						   ScAddress::Convention eConv )
  {
  	if ( rStr.Len() )
  	{
*************** USHORT ScRangeList::Parse( const String&
*** 93,99 ****
  				aOne += aStrTmp;
  			}
  			aRange.aStart.SetTab( nTab );	// Default Tab wenn nicht angegeben
! 			USHORT nRes = aRange.Parse( aOne, pDoc );
  			if ( (nRes & nMask) == nMask )
  				Append( aRange );
  			nResult &= nRes;		// alle gemeinsamen Bits bleiben erhalten
--- 94,100 ----
  				aOne += aStrTmp;
  			}
  			aRange.aStart.SetTab( nTab );	// Default Tab wenn nicht angegeben
! 			USHORT nRes = aRange.Parse( aOne, pDoc, eConv );
  			if ( (nRes & nMask) == nMask )
  				Append( aRange );
  			nResult &= nRes;		// alle gemeinsamen Bits bleiben erhalten
*************** USHORT ScRangeList::Parse( const String&
*** 105,118 ****
  }
  
  
! void ScRangeList::Format( String& rStr, USHORT nFlags, ScDocument* pDoc ) const
  {
  	rStr.Erase();
  	ULONG nCnt = Count();
  	for ( ULONG nIdx = 0; nIdx < nCnt; nIdx++ )
  	{
  		String aStr;
! 		GetObject( nIdx )->Format( aStr, nFlags, pDoc );
  		if ( nIdx )
  			rStr += ';';
  		rStr += aStr;
--- 106,120 ----
  }
  
  
! void ScRangeList::Format( String& rStr, USHORT nFlags, ScDocument* pDoc,
! 						  ScAddress::Convention eConv ) const
  {
  	rStr.Erase();
  	ULONG nCnt = Count();
  	for ( ULONG nIdx = 0; nIdx < nCnt; nIdx++ )
  	{
  		String aStr;
! 		GetObject( nIdx )->Format( aStr, nFlags, pDoc, eConv );
  		if ( nIdx )
  			rStr += ';';
  		rStr += aStr;
*************** ScRangePairList::QsortNameCompare( const
*** 789,794 ****
--- 791,797 ----
  			}
  			return 0;
  	}
+ 	return 0; // just in case
  }
  
  
Index: sc/source/core/tool/rangenam.cxx
===================================================================
RCS file: /cvs/sc/source/core/tool/rangenam.cxx,v
diff -cpr sc/source/core/tool/rangenam.cxx sc/source/core/tool/rangenam.cxx
*** sc/source/core/tool/rangenam.cxx	Fri Jul 21 07:41:01 2006
--- sc/source/core/tool/rangenam.cxx	Thu Aug 24 10:45:05 2006
*************** void ScRangeData::UpdateTabRef(SCTAB nOl
*** 535,541 ****
  
  void ScRangeData::MakeValidName( String& rName )		// static
  {
- 	if (!ScCompiler::HasCharTable())
  		ScCompiler::Init();
  
  	//	ungueltige Zeichen vorne weglassen
--- 535,540 ----
*************** void ScRangeData::MakeValidName( String&
*** 559,585 ****
  	}
  
  	// Name darf keine Referenz beinhalten, wie in IsNameValid
! 	BOOL bOk;
! 	do
! 	{
! 		bOk = TRUE;
  		ScRange aRange;
! 		if( aRange.Parse( rName, NULL ) )
! 			bOk = FALSE;
! 		else
  		{
! 			ScAddress aAddr;
! 			if ( aAddr.Parse( rName, NULL ) )
! 				bOk = FALSE;
! 		}
! 		if ( !bOk )
! 		{	//! Range Parse auch bei Bereich mit ungueltigem Tabellennamen gueltig
  			//! Address Parse dito, Name erzeugt deswegen bei Compile ein #REF!
  			if ( rName.SearchAndReplace( ':', '_' ) == STRING_NOTFOUND
  			  && rName.SearchAndReplace( '.', '_' ) == STRING_NOTFOUND )
  				rName.Insert('_',0);
  		}
! 	} while ( !bOk );
  }
  
  BOOL ScRangeData::IsNameValid( const String& rName, ScDocument* pDoc )
--- 558,581 ----
  	}
  
  	// Name darf keine Referenz beinhalten, wie in IsNameValid
! 	ScAddress aAddr;
  		ScRange aRange;
! 	int nConv = ScAddress::CONV_UNSPECIFIED; // use int so that op++ works
! 
! 	// Ensure that the proposed name is not an address under any convention
! 	while ( ++nConv != ScAddress::CONV_LAST )
  		{
! 		ScAddress::Details details( static_cast<ScAddress::Convention>( nConv ) );
! 		while( aRange.Parse( rName, NULL, details )
! 			   || aAddr.Parse( rName, NULL, details ) )
! 		{
! 			//! Range Parse auch bei Bereich mit ungueltigem Tabellennamen gueltig
  			//! Address Parse dito, Name erzeugt deswegen bei Compile ein #REF!
  			if ( rName.SearchAndReplace( ':', '_' ) == STRING_NOTFOUND
  			  && rName.SearchAndReplace( '.', '_' ) == STRING_NOTFOUND )
  				rName.Insert('_',0);
  		}
! 	}
  }
  
  BOOL ScRangeData::IsNameValid( const String& rName, ScDocument* pDoc )
*************** BOOL ScRangeData::IsNameValid( const Str
*** 598,609 ****
  	// Parse nicht auf VALID pruefen, es reicht, wenn irgendein Bestandteil
  	// erkannt wurde
  	ScRange aRange;
! 	if( aRange.Parse( rName, pDoc ) )
  		return FALSE;
  	else
  	{
  		ScAddress aAddr;
! 		if ( aAddr.Parse( rName, pDoc ) )
  			return FALSE;
  	}
  	return TRUE;
--- 594,605 ----
  	// Parse nicht auf VALID pruefen, es reicht, wenn irgendein Bestandteil
  	// erkannt wurde
  	ScRange aRange;
! 	if( aRange.Parse( rName, pDoc ) )	// THIS IS WRONG
  		return FALSE;
  	else
  	{
  		ScAddress aAddr;
! 		if ( aAddr.Parse( rName, pDoc ) )	// THIS IS WRONG
  			return FALSE;
  	}
  	return TRUE;
Index: sc/source/core/tool/rangeutl.cxx
===================================================================
RCS file: /cvs/sc/source/core/tool/rangeutl.cxx,v
diff -cpr sc/source/core/tool/rangeutl.cxx sc/source/core/tool/rangeutl.cxx
*** sc/source/core/tool/rangeutl.cxx	Fri Jul 21 07:41:52 2006
--- sc/source/core/tool/rangeutl.cxx	Thu Aug 24 10:45:05 2006
***************
*** 56,65 ****
  BOOL ScRangeUtil::MakeArea( const String&	rAreaStr,
  							ScArea&			rArea,
  							ScDocument*		pDoc,
! 							SCTAB			nTab ) const
  {
  	// Eingabe in rAreaStr: "$Tabelle1.$A1:$D17"
  
  	BOOL		nSuccess	= FALSE;
  	USHORT		nPointPos	= rAreaStr.Search('.');
  	USHORT		nColonPos	= rAreaStr.Search(':');
--- 56,69 ----
  BOOL ScRangeUtil::MakeArea( const String&	rAreaStr,
  							ScArea&			rArea,
  							ScDocument*		pDoc,
! 							SCTAB			nTab,
! 							ScAddress::Details const & rDetails ) const
  {
  	// Eingabe in rAreaStr: "$Tabelle1.$A1:$D17"
  
+ 	// BROKEN BROKEN BROKEN
+ 	// but it is only used in the consolidate dialog.  Ignore for now.
+ 
  	BOOL		nSuccess	= FALSE;
  	USHORT		nPointPos	= rAreaStr.Search('.');
  	USHORT		nColonPos	= rAreaStr.Search(':');
*************** BOOL ScRangeUtil::MakeArea( const String
*** 74,80 ****
  			aStrArea += rAreaStr.Copy( nPointPos+1 ); // '.' nicht mitkopieren
  		}
  
! 	nSuccess = ConvertDoubleRef( pDoc, aStrArea, nTab, startPos, endPos );
  
  	if ( nSuccess )
  		rArea = ScArea( startPos.Tab(),
--- 78,84 ----
  			aStrArea += rAreaStr.Copy( nPointPos+1 ); // '.' nicht mitkopieren
  		}
  
! 	nSuccess = ConvertDoubleRef( pDoc, aStrArea, nTab, startPos, endPos, rDetails );
  
  	if ( nSuccess )
  		rArea = ScArea( startPos.Tab(),
*************** void ScRangeUtil::CutPosString( const St
*** 90,95 ****
--- 94,102 ----
  								String&			thePosStr ) const
  {
  	String	aPosStr;
+ 	// BROKEN BROKEN BROKEN
+ 	// but it is only used in the consolidate dialog.  Ignore for now.
+ 
  	USHORT	nColonPos = theAreaStr.Search(':');
  
  	if ( nColonPos != STRING_NOTFOUND )
*************** BOOL ScRangeUtil::IsAbsTabArea( const St
*** 106,117 ****
  								ScDocument*		pDoc,
  								ScArea***		pppAreas,
  								USHORT*			pAreaCount,
! 								BOOL			bAcceptCellRef ) const
  {
  	DBG_ASSERT( pDoc, "Kein Dokument uebergeben!" );
  	if ( !pDoc )
  		return FALSE;
  
  	/*
  	 * Erwartet wird ein String der Form
  	 *		"$Tabelle1.$A$1:$Tabelle3.$D$17"
--- 113,128 ----
  								ScDocument*		pDoc,
  								ScArea***		pppAreas,
  								USHORT*			pAreaCount,
! 								BOOL			bAcceptCellRef,
! 								ScAddress::Details const & rDetails ) const
  {
  	DBG_ASSERT( pDoc, "Kein Dokument uebergeben!" );
  	if ( !pDoc )
  		return FALSE;
  
+ 	// BROKEN BROKEN BROKEN
+ 	// but it is only used in the consolidate dialog.  Ignore for now.
+ 
  	/*
  	 * Erwartet wird ein String der Form
  	 *		"$Tabelle1.$A$1:$Tabelle3.$D$17"
*************** BOOL ScRangeUtil::IsAbsTabArea( const St
*** 146,154 ****
  		aStartPosStr = aTempAreaStr.Copy( 0,		   nColonPos  );
  		aEndPosStr	 = aTempAreaStr.Copy( nColonPos+1, STRING_LEN );
  
! 		if ( ConvertSingleRef( pDoc, aStartPosStr, 0, aStartPos ) )
  		{
! 			if ( ConvertSingleRef( pDoc, aEndPosStr, aStartPos.Tab(), aEndPos ) )
  			{
  				aStartPos.SetRelCol( FALSE );
  				aStartPos.SetRelRow( FALSE );
--- 157,165 ----
  		aStartPosStr = aTempAreaStr.Copy( 0,		   nColonPos  );
  		aEndPosStr	 = aTempAreaStr.Copy( nColonPos+1, STRING_LEN );
  
! 		if ( ConvertSingleRef( pDoc, aStartPosStr, 0, aStartPos, rDetails ) )
  		{
! 			if ( ConvertSingleRef( pDoc, aEndPosStr, aStartPos.Tab(), aEndPos, rDetails ) )
  			{
  				aStartPos.SetRelCol( FALSE );
  				aStartPos.SetRelRow( FALSE );
*************** BOOL ScRangeUtil::IsAbsArea( const Strin
*** 194,206 ****
  							 SCTAB			nTab,
  							 String*		pCompleteStr,
  							 ScRefAddress*	pStartPos,
! 							 ScRefAddress*	pEndPos ) const
  {
  	BOOL		bIsAbsArea = FALSE;
  	ScRefAddress	startPos;
  	ScRefAddress	endPos;
  
! 	bIsAbsArea = ConvertDoubleRef( pDoc, rAreaStr, nTab, startPos, endPos );
  
  	if ( bIsAbsArea )
  	{
--- 205,218 ----
  							 SCTAB			nTab,
  							 String*		pCompleteStr,
  							 ScRefAddress*	pStartPos,
! 							 ScRefAddress*	pEndPos,
! 							 ScAddress::Details const & rDetails ) const
  {
  	BOOL		bIsAbsArea = FALSE;
  	ScRefAddress	startPos;
  	ScRefAddress	endPos;
  
! 	bIsAbsArea = ConvertDoubleRef( pDoc, rAreaStr, nTab, startPos, endPos, rDetails );
  
  	if ( bIsAbsArea )
  	{
*************** BOOL ScRangeUtil::IsAbsArea( const Strin
*** 213,221 ****
  
  		if ( pCompleteStr )
  		{
! 			*pCompleteStr  = startPos.GetRefString( pDoc, MAXTAB+1 );
  			*pCompleteStr += ':';
! 			*pCompleteStr += endPos  .GetRefString( pDoc, nTab );
  		}
  
  		if ( pStartPos && pEndPos )
--- 225,233 ----
  
  		if ( pCompleteStr )
  		{
! 			*pCompleteStr  = startPos.GetRefString( pDoc, MAXTAB+1, rDetails );
  			*pCompleteStr += ':';
! 			*pCompleteStr += endPos  .GetRefString( pDoc, nTab, rDetails );
  		}
  
  		if ( pStartPos && pEndPos )
*************** BOOL ScRangeUtil::IsAbsPos( const String
*** 234,246 ****
  							ScDocument*		pDoc,
  							SCTAB			nTab,
  							String*			pCompleteStr,
! 							ScRefAddress*	pPosTripel ) const
  {
  	BOOL		bIsAbsPos = FALSE;
  	ScRefAddress	thePos;
  
! 	bIsAbsPos = ConvertSingleRef( pDoc, rPosStr, nTab, thePos );
! 
  	thePos.SetRelCol( FALSE );
  	thePos.SetRelRow( FALSE );
  	thePos.SetRelTab( FALSE );
--- 246,258 ----
  							ScDocument*		pDoc,
  							SCTAB			nTab,
  							String*			pCompleteStr,
! 							ScRefAddress*	pPosTripel,
! 							ScAddress::Details const & rDetails ) const
  {
  	BOOL		bIsAbsPos = FALSE;
  	ScRefAddress	thePos;
  
! 	bIsAbsPos = ConvertSingleRef( pDoc, rPosStr, nTab, thePos, rDetails ); 
  	thePos.SetRelCol( FALSE );
  	thePos.SetRelRow( FALSE );
  	thePos.SetRelTab( FALSE );
*************** BOOL ScRangeUtil::IsAbsPos( const String
*** 250,256 ****
  		if ( pPosTripel )
  			*pPosTripel = thePos;
  		if ( pCompleteStr )
! 			*pCompleteStr = thePos.GetRefString( pDoc, MAXTAB+1 );
  	}
  
  	return bIsAbsPos;
--- 262,268 ----
  		if ( pPosTripel )
  			*pPosTripel = thePos;
  		if ( pCompleteStr )
! 			*pCompleteStr = thePos.GetRefString( pDoc, MAXTAB+1, rDetails );
  	}
  
  	return bIsAbsPos;
*************** BOOL ScRangeUtil::MakeRangeFromName	(
*** 263,270 ****
  	ScDocument*		pDoc,
  	SCTAB			nCurTab,
  	ScRange&		rRange,
! 	RutlNameScope 	eScope
! 								  ) const
  {
  	BOOL bResult=FALSE;
  	ScRangeUtil		aRangeUtil;
--- 275,282 ----
  	ScDocument*		pDoc,
  	SCTAB			nCurTab,
  	ScRange&		rRange,
! 	RutlNameScope 	eScope,
! 	ScAddress::Details const & rDetails ) const
  {
  	BOOL bResult=FALSE;
  	ScRangeUtil		aRangeUtil;
*************** BOOL ScRangeUtil::MakeRangeFromName	(
*** 289,295 ****
  			pData->GetSymbol( aStrArea );
  
  			if ( IsAbsArea( aStrArea, pDoc, nCurTab,
! 									   NULL, &aStartPos, &aEndPos ) )
  			{
  				nTab	   = aStartPos.Tab();
  				nColStart  = aStartPos.Col();
--- 301,307 ----
  			pData->GetSymbol( aStrArea );
  
  			if ( IsAbsArea( aStrArea, pDoc, nCurTab,
! 							NULL, &aStartPos, &aEndPos, rDetails ) )
  			{
  				nTab	   = aStartPos.Tab();
  				nColStart  = aStartPos.Col();
*************** BOOL ScRangeUtil::MakeRangeFromName	(
*** 303,309 ****
  				CutPosString( aStrArea, aStrArea );
  
  				if ( IsAbsPos( aStrArea, pDoc, nCurTab,
! 										  NULL, &aStartPos ) )
  				{
  					nTab	   = aStartPos.Tab();
  					nColStart  = nColEnd = aStartPos.Col();
--- 315,321 ----
  				CutPosString( aStrArea, aStrArea );
  
  				if ( IsAbsPos( aStrArea, pDoc, nCurTab,
! 										  NULL, &aStartPos, rDetails ) )
  				{
  					nTab	   = aStartPos.Tab();
  					nColStart  = nColEnd = aStartPos.Col();
*************** SvStream& operator<< ( SvStream& rStream
*** 424,436 ****
  
  //------------------------------------------------------------------------
  
! void ScArea::GetString( String& rStr, BOOL bAbsolute, ScDocument* pDoc ) const
  {
  	ScRange aRange( ScAddress( nColStart, nRowStart, nTab ),
  					ScAddress( nColEnd,   nRowEnd,   nTab ) );
  	USHORT  nFlags = bAbsolute ? SCA_COL_ABSOLUTE | SCA_ROW_ABSOLUTE : 0;
  
! 	aRange.Format( rStr, nFlags, pDoc );
  }
  
  //------------------------------------------------------------------------
--- 436,449 ----
  
  //------------------------------------------------------------------------
  
! void ScArea::GetString( String& rStr, BOOL bAbsolute, ScDocument* pDoc,
! 						ScAddress::Details const & rDetails ) const
  {
  	ScRange aRange( ScAddress( nColStart, nRowStart, nTab ),
  					ScAddress( nColEnd,   nRowEnd,   nTab ) );
  	USHORT  nFlags = bAbsolute ? SCA_COL_ABSOLUTE | SCA_ROW_ABSOLUTE : 0;
  
! 	aRange.Format( rStr, nFlags, pDoc, rDetails );
  }
  
  //------------------------------------------------------------------------
Index: sc/source/core/tool/reffind.cxx
===================================================================
RCS file: /cvs/sc/source/core/tool/reffind.cxx,v
diff -cpr sc/source/core/tool/reffind.cxx sc/source/core/tool/reffind.cxx
*** sc/source/core/tool/reffind.cxx	Fri Jul 21 07:42:41 2006
--- sc/source/core/tool/reffind.cxx	Thu Aug 24 10:45:05 2006
*************** inline BOOL IsText( BOOL& bQuote, sal_Un
*** 73,81 ****
  	return IsText( c );
  }
  
! ScRefFinder::ScRefFinder(const String& rFormula, ScDocument* pDocument) :
  	aFormula( rFormula ),
! 	pDoc( pDocument )
  {
  	nSelStart = nSelEnd = nFound = 0;
  }
--- 73,83 ----
  	return IsText( c );
  }
  
! ScRefFinder::ScRefFinder(const String& rFormula, ScDocument* pDocument,
! 			 ScAddress::Convention eConvP) :
  	aFormula( rFormula ),
! 	pDoc( pDocument ),
! 	eConv( eConvP )
  {
  	nSelStart = nSelEnd = nFound = 0;
  }
Index: sc/source/filter/excel/excdoc.cxx
===================================================================
RCS file: /cvs/sc/source/filter/excel/excdoc.cxx,v
diff -cpr sc/source/filter/excel/excdoc.cxx sc/source/filter/excel/excdoc.cxx
*** sc/source/filter/excel/excdoc.cxx	Fri Jul 21 07:47:32 2006
--- sc/source/filter/excel/excdoc.cxx	Thu Aug 24 10:45:05 2006
*************** void ExcTable::FillAsTable( size_t nCode
*** 326,332 ****
      {
          Add( new ExcBof8 );
          Add( new XclCalccount( rDoc ) );
!         Add( new XclRefmode() );
          Add( new XclIteration( rDoc ) );
          Add( new XclDelta( rDoc ) );
          Add( new ExcDummy8_02 );
--- 326,332 ----
      {
          Add( new ExcBof8 );
          Add( new XclCalccount( rDoc ) );
!         Add( new XclRefmode( rDoc ) );
          Add( new XclIteration( rDoc ) );
          Add( new XclDelta( rDoc ) );
          Add( new ExcDummy8_02 );
Index: sc/source/filter/excel/excimp8.cxx
===================================================================
RCS file: /cvs/sc/source/filter/excel/excimp8.cxx,v
diff -cpr sc/source/filter/excel/excimp8.cxx sc/source/filter/excel/excimp8.cxx
*** sc/source/filter/excel/excimp8.cxx	Tue Jul 25 05:56:55 2006
--- sc/source/filter/excel/excimp8.cxx	Thu Aug 24 10:45:05 2006
*************** void ImportExcel8::Iteration( void )
*** 190,195 ****
--- 190,201 ----
  }
  
  
+ void ImportExcel8::RefMode( void )
+ {
+ 	pD->SetAddressConvention( (aIn.ReaduInt16() == 0)
+ 				  ? ScAddress::CONV_XL_R1C1
+ 				  : ScAddress::CONV_OOO );
+ }
  void ImportExcel8:: WinProtection( void )
  {
      if( aIn.ReaduInt16() != 0 )
Index: sc/source/filter/excel/impop.cxx
===================================================================
RCS file: /cvs/sc/source/filter/excel/impop.cxx,v
diff -cpr sc/source/filter/excel/impop.cxx sc/source/filter/excel/impop.cxx
*** sc/source/filter/excel/impop.cxx	Tue Jul 25 05:57:13 2006
--- sc/source/filter/excel/impop.cxx	Thu Aug 24 10:45:05 2006
*************** void ImportExcel::Array25( void )
*** 554,561 ****
          aMarkData.SelectOneTable( GetCurrScTab() );
          pD->InsertMatrixFormula( static_cast<SCCOL>(nFirstCol),
                  static_cast<SCROW>(nFirstRow), static_cast<SCCOL>(nLastCol),
!                 static_cast<SCROW>(nLastRow), aMarkData, EMPTY_STRING,
!                 pErgebnis );
  	}
  }
  
--- 554,561 ----
          aMarkData.SelectOneTable( GetCurrScTab() );
          pD->InsertMatrixFormula( static_cast<SCCOL>(nFirstCol),
                  static_cast<SCROW>(nFirstRow), static_cast<SCCOL>(nLastCol),
!                 static_cast<SCROW>(nLastRow), aMarkData,
! 				EMPTY_STRING, pErgebnis );
  	}
  }
  
*************** void ImportExcel::Array34( void )
*** 1014,1021 ****
          aMarkData.SelectOneTable( GetCurrScTab() );
          pD->InsertMatrixFormula( static_cast<SCCOL>(nFirstCol),
                  static_cast<SCROW>(nFirstRow), static_cast<SCCOL>(nLastCol),
!                 static_cast<SCROW>(nLastRow), aMarkData, EMPTY_STRING,
!                 pErgebnis);
  	}
  }
  
--- 1014,1021 ----
          aMarkData.SelectOneTable( GetCurrScTab() );
          pD->InsertMatrixFormula( static_cast<SCCOL>(nFirstCol),
                  static_cast<SCROW>(nFirstRow), static_cast<SCCOL>(nLastCol),
!                 static_cast<SCROW>(nLastRow), aMarkData,
! 				EMPTY_STRING, pErgebnis);
  	}
  }
  
Index: sc/source/filter/excel/read.cxx
===================================================================
RCS file: /cvs/sc/source/filter/excel/read.cxx,v
diff -cpr sc/source/filter/excel/read.cxx sc/source/filter/excel/read.cxx
*** sc/source/filter/excel/read.cxx	Tue Jul 25 05:57:35 2006
--- sc/source/filter/excel/read.cxx	Thu Aug 24 10:45:05 2006
*************** FltError ImportExcel8::Read( void )
*** 1145,1150 ****
--- 1145,1151 ----
                      case 0x0206:
                      case 0x0406:    Formula25();            break;  // FORMULA      [ 2  5   ]
                      case 0x000C:    Calccount();            break;  // CALCCOUNT
+ 					case 0x000F:    RefMode();				break;	// REFMODE
                      case 0x0010:    Delta();                break;  // DELTA
                      case 0x0011:    Iteration();            break;  // ITERATION
                      case 0x001C:    Note();                 break;  // NOTE         [ 2345   ]
Index: sc/source/filter/inc/excimp8.hxx
===================================================================
RCS file: /cvs/sc/source/filter/inc/excimp8.hxx,v
diff -cpr sc/source/filter/inc/excimp8.hxx sc/source/filter/inc/excimp8.hxx
*** sc/source/filter/inc/excimp8.hxx	Tue Jul 25 05:58:58 2006
--- sc/source/filter/inc/excimp8.hxx	Thu Aug 24 10:45:05 2006
*************** class ImportExcel8 : public ImportExcel
*** 76,81 ****
--- 76,82 ----
  
  		void					Calccount( void );				// 0x0C
          void                    Precision( void );              // 0x0E
+ 		void					RefMode( void );				// 0x0F
  		void					Delta( void );					// 0x10
  		void					Iteration( void );				// 0x11
  		void					Note( void );					// 0x1C
Index: sc/source/filter/inc/xcl97dum.hxx
===================================================================
RCS file: /cvs/sc/source/filter/inc/xcl97dum.hxx,v
diff -cpr sc/source/filter/inc/xcl97dum.hxx sc/source/filter/inc/xcl97dum.hxx
*** sc/source/filter/inc/xcl97dum.hxx	Mon Jul 10 09:53:06 2006
--- sc/source/filter/inc/xcl97dum.hxx	Thu Aug 24 10:45:05 2006
*************** public:
*** 97,111 ****
  };
  
  
- class XclRefmode : public ExcDummyRec
- {
- private:
-     static const BYTE       pMyData[];
-     static const sal_Size   nMyLen;
- public:
-     virtual sal_Size        GetLen( void ) const;
-     virtual const BYTE*     GetData( void ) const;
- };
- 
- 
  #endif // _XCL97DUM_HXX
--- 97,100 ----
Index: sc/source/filter/inc/xcl97rec.hxx
===================================================================
RCS file: /cvs/sc/source/filter/inc/xcl97rec.hxx,v
diff -cpr sc/source/filter/inc/xcl97rec.hxx sc/source/filter/inc/xcl97rec.hxx
*** sc/source/filter/inc/xcl97rec.hxx	Mon Jul 10 09:53:17 2006
--- sc/source/filter/inc/xcl97rec.hxx	Thu Aug 24 10:45:05 2006
*************** public:
*** 506,511 ****
--- 506,525 ----
  	virtual	const BYTE*			GetData( void ) const;
  };
  
+ class XclRefmode : public ExcRecord
+ {
+ private:
+ 	UINT16					    eConv;
+ protected:
+ 	virtual void				SaveCont( XclExpStream& rStrm );
+ public:
+ 								XclRefmode( ScDocument& rDoc );
+ 
+ 	virtual	UINT16				GetNum() const;
+ 	virtual	ULONG				GetLen() const;
+ };
+ 
+ 
  
  // -------------------------------------------------------------------
  
Index: sc/source/filter/xcl97/xcl97dum.cxx
===================================================================
RCS file: /cvs/sc/source/filter/xcl97/xcl97dum.cxx,v
diff -cpr sc/source/filter/xcl97/xcl97dum.cxx sc/source/filter/xcl97/xcl97dum.cxx
*** sc/source/filter/xcl97/xcl97dum.cxx	Fri Jul 21 08:36:54 2006
--- sc/source/filter/xcl97/xcl97dum.cxx	Thu Aug 24 10:45:05 2006
*************** const BYTE ExcDummy8_02::pMyData[] = {
*** 104,113 ****
  const sal_Size ExcDummy8_02::nMyLen = sizeof(ExcDummy8_02::pMyData);
  
  
- const BYTE	XclRefmode::pMyData[] = { 0x0f, 0x00, 0x02, 0x00, 0x01, 0x00 };	// REFMODE
- const sal_Size  XclRefmode::nMyLen = sizeof( XclRefmode::pMyData );
- 
- 
  // --- class ExcDummy8_xx --------------------------------------------
  
  sal_Size ExcDummy8_00a::GetLen() const
--- 104,109 ----
*************** const BYTE* ExcDummy8_02::GetData() cons
*** 173,190 ****
  	return pMyData;
  }
  
- 
- 
- sal_Size XclRefmode::GetLen( void ) const
- {
- 	return nMyLen;
- }
- 
- 
- const BYTE* XclRefmode::GetData( void ) const
- {
- 	return pMyData;
- }
- 
- 
- 
--- 169,171 ----
Index: sc/source/filter/xcl97/xcl97rec.cxx
===================================================================
RCS file: /cvs/sc/source/filter/xcl97/xcl97rec.cxx,v
diff -cpr sc/source/filter/xcl97/xcl97rec.cxx sc/source/filter/xcl97/xcl97rec.cxx
*** sc/source/filter/xcl97/xcl97rec.cxx	Fri Jul 21 08:38:20 2006
--- sc/source/filter/xcl97/xcl97rec.cxx	Thu Aug 24 10:45:05 2006
*************** const BYTE* XclProtection::GetData( void
*** 1302,1307 ****
--- 1302,1329 ----
  
  
  
+ void XclRefmode::SaveCont( XclExpStream& rStrm )
+ {
+ 	rStrm << eConv;
+ }
+ 
+ 
+ XclRefmode::XclRefmode( ScDocument& rDoc )
+ {
+ 	eConv = (rDoc.GetAddressConvention() == ScAddress::CONV_XL_R1C1) ? 0 : 1;
+ }
+ 
+ 
+ UINT16 XclRefmode::GetNum() const
+ {
+ 	return 0x000f;
+ }
+ 
+ 
+ ULONG XclRefmode::GetLen() const
+ {
+ 	return 2;
+ }
  
  
  
Index: sc/source/filter/xml/XMLChangeTrackingImportHelper.cxx
===================================================================
RCS file: /cvs/sc/source/filter/xml/XMLChangeTrackingImportHelper.cxx,v
diff -cpr sc/source/filter/xml/XMLChangeTrackingImportHelper.cxx sc/source/filter/xml/XMLChangeTrackingImportHelper.cxx
*** sc/source/filter/xml/XMLChangeTrackingImportHelper.cxx	Fri Jul 21 08:41:17 2006
--- sc/source/filter/xml/XMLChangeTrackingImportHelper.cxx	Thu Aug 24 10:45:05 2006
*************** ScBaseCell* ScMyCellInfo::CreateCell(ScD
*** 111,117 ****
  			ScAddress aPos;
  			sal_Int32 nOffset(0);
  			ScXMLConverter::GetAddressFromString(aPos, sFormulaAddress, pDoc, nOffset);
! 			pCell = new ScFormulaCell(pDoc, aPos, sFormula, nMatrixFlag);
  			static_cast<ScFormulaCell*>(pCell)->SetMatColsRows(static_cast<SCCOL>(nMatrixCols), static_cast<SCROW>(nMatrixRows));
  		}
  
--- 111,117 ----
  			ScAddress aPos;
  			sal_Int32 nOffset(0);
  			ScXMLConverter::GetAddressFromString(aPos, sFormulaAddress, pDoc, nOffset);
! 			pCell = new ScFormulaCell(pDoc, aPos, sFormula, ScAddress::CONV_OOO, nMatrixFlag);
  			static_cast<ScFormulaCell*>(pCell)->SetMatColsRows(static_cast<SCCOL>(nMatrixCols), static_cast<SCROW>(nMatrixRows));
  		}
  
*************** void ScXMLChangeTrackingImportHelper::Se
*** 779,789 ****
  						{
  							sal_uInt8 nMatrixFlag = static_cast<ScFormulaCell*>(pCell)->GetMatrixFlag();
  							String sFormula;
! 							static_cast<ScFormulaCell*>(pCell)->GetFormula(sFormula);
  							rtl::OUString sOUFormula(sFormula);
  							rtl::OUString sOUFormula2(sOUFormula.copy(2, sOUFormula.getLength() - 3));
  							String sFormula2(sOUFormula2);
! 							pNewCell = new ScFormulaCell(pDoc, aAddress, sFormula2, nMatrixFlag);
  							if (pNewCell)
  							{
  								if (nMatrixFlag == MM_FORMULA)
--- 779,789 ----
  						{
  							sal_uInt8 nMatrixFlag = static_cast<ScFormulaCell*>(pCell)->GetMatrixFlag();
  							String sFormula;
! 							static_cast<ScFormulaCell*>(pCell)->GetFormula(sFormula, ScAddress::CONV_OOO);
  							rtl::OUString sOUFormula(sFormula);
  							rtl::OUString sOUFormula2(sOUFormula.copy(2, sOUFormula.getLength() - 3));
  							String sFormula2(sOUFormula2);
! 							pNewCell = new ScFormulaCell(pDoc, aAddress, sFormula2, ScAddress::CONV_OOO, nMatrixFlag);
  							if (pNewCell)
  							{
  								if (nMatrixFlag == MM_FORMULA)
Index: sc/source/filter/xml/XMLConverter.cxx
===================================================================
RCS file: /cvs/sc/source/filter/xml/XMLConverter.cxx,v
diff -cpr sc/source/filter/xml/XMLConverter.cxx sc/source/filter/xml/XMLConverter.cxx
*** sc/source/filter/xml/XMLConverter.cxx	Fri Jul 21 08:42:44 2006
--- sc/source/filter/xml/XMLConverter.cxx	Thu Aug 24 10:45:05 2006
*************** void ScXMLConverter::GetStringFromRange(
*** 361,368 ****
  		ScAddress aEndAddress( rRange.aEnd );
  		String sStartAddress;
  		String sEndAddress;
! 		aStartAddress.Format( sStartAddress, nFormatFlags, (ScDocument*) pDocument );
! 		aEndAddress.Format( sEndAddress, nFormatFlags, (ScDocument*) pDocument );
  		OUString sOUStartAddress( sStartAddress );
  		sOUStartAddress += GetXMLToken( XML__COLON );
  		sOUStartAddress += OUString( sEndAddress );
--- 361,370 ----
  		ScAddress aEndAddress( rRange.aEnd );
  		String sStartAddress;
  		String sEndAddress;
! 		aStartAddress.Format( sStartAddress, nFormatFlags, (ScDocument*) pDocument,
! 							  ScAddress::CONV_OOO );
! 		aEndAddress.Format( sEndAddress, nFormatFlags, (ScDocument*) pDocument,
! 							ScAddress::CONV_OOO );
  		OUString sOUStartAddress( sStartAddress );
  		sOUStartAddress += GetXMLToken( XML__COLON );
  		sOUStartAddress += OUString( sEndAddress );
Index: sc/source/ui/Accessibility/AccessibleCellBase.cxx
===================================================================
RCS file: /cvs/sc/source/ui/Accessibility/AccessibleCellBase.cxx,v
diff -cpr sc/source/ui/Accessibility/AccessibleCellBase.cxx sc/source/ui/Accessibility/AccessibleCellBase.cxx
*** sc/source/ui/Accessibility/AccessibleCellBase.cxx	Fri Jul 21 09:01:04 2006
--- sc/source/ui/Accessibility/AccessibleCellBase.cxx	Thu Aug 24 10:45:05 2006
*************** sal_Int32
*** 271,276 ****
--- 271,277 ----
  	String sName( ScResId(STR_ACC_CELL_NAME) );
  	String sAddress;
  	// Document not needed, because only the cell address, but not the tablename is needed
+ 	// always us OOO notation
  	maCellAddress.Format( sAddress, SCA_VALID, NULL );
  	sName.SearchAndReplaceAscii("%1", sAddress);
      return rtl::OUString(sName);
Index: sc/source/ui/app/inputhdl.cxx
===================================================================
RCS file: /cvs/sc/source/ui/app/inputhdl.cxx,v
diff -cpr sc/source/ui/app/inputhdl.cxx sc/source/ui/app/inputhdl.cxx
*** sc/source/ui/app/inputhdl.cxx	Wed Aug 23 16:33:09 2006
--- sc/source/ui/app/inputhdl.cxx	Thu Aug 24 16:36:55 2006
*************** void ScInputHandler::InitRangeFinder( co
*** 167,179 ****
  
  		//	Text zwischen Trennern
  		nStart = nPos;
  		while ( nPos<nLen && !ScGlobal::UnicodeStrChr( aDelimiters.GetBuffer(), pChar[nPos] ) )
  			++nPos;
  
  		if ( nPos > nStart )
  		{
  			String aTest = rFormula.Copy( nStart, nPos-nStart );
! 			USHORT nFlags = aRange.ParseAny( aTest, pDoc );
  			if ( nFlags & SCA_VALID )
  			{
  				//	Tabelle setzen, wenn nicht angegeben
--- 167,193 ----
  
  		//	Text zwischen Trennern
  		nStart = nPos;
+ handle_r1c1:
  		while ( nPos<nLen && !ScGlobal::UnicodeStrChr( aDelimiters.GetBuffer(), pChar[nPos] ) )
  			++nPos;
  
+ 		// for R1C1 '-' in R[-]... or C[-]... are not delimiters
+ 		// Nothing heroic here to ensure that there are '[]' around a negative
+ 		// integer.  we need to clean up this code.
+ 		if( nPos < nLen && nPos > 0 &&
+ 			'-' == pChar[nPos] && '[' == pChar[nPos-1] &&
+ 			NULL != pDoc &&
+ 			ScAddress::CONV_XL_R1C1 == pDoc->GetAddressConvention() )
+ 		{
+ 			nPos++;
+ 			goto handle_r1c1;
+ 		}
+ 
  		if ( nPos > nStart )
  		{
  			String aTest = rFormula.Copy( nStart, nPos-nStart );
! 			const ScAddress::Details aAddrDetails( pDoc, aCursorPos );
! 			USHORT nFlags = aRange.ParseAny( aTest, pDoc, aAddrDetails );
  			if ( nFlags & SCA_VALID )
  			{
  				//	Tabelle setzen, wenn nicht angegeben
*************** void ScInputHandler::UpdateRange( USHORT
*** 245,251 ****
  		ScRange aJustified = rNew;
  		aJustified.Justify();			// Ref in der Formel immer richtigherum anzeigen
  		String aNewStr;
! 		aJustified.Format( aNewStr, pData->nFlags, pDocView->GetViewData()->GetDocument() );
  		ESelection aOldSel( 0, nOldStart, 0, nOldEnd );
  
  		DataChanging();
--- 259,267 ----
  		ScRange aJustified = rNew;
  		aJustified.Justify();			// Ref in der Formel immer richtigherum anzeigen
  		String aNewStr;
! 		ScDocument* pDoc = pDocView->GetViewData()->GetDocument();
! 		const ScAddress::Details aAddrDetails( pDoc, aCursorPos );
! 		aJustified.Format( aNewStr, pData->nFlags, pDoc, aAddrDetails );
  		ESelection aOldSel( 0, nOldStart, 0, nOldEnd );
  
  		DataChanging();
*************** void ScInputHandler::SetReference( const
*** 2443,2448 ****
--- 2459,2465 ----
  	//	String aus Referenz erzeugen
  
  	String aRefStr;
+ 	const ScAddress::Details aAddrDetails( pDoc, aCursorPos );
  	if (bOtherDoc)
  	{
  		//	Referenz auf anderes Dokument
*************** void ScInputHandler::SetReference( const
*** 2450,2456 ****
  		DBG_ASSERT(rRef.aStart.Tab()==rRef.aEnd.Tab(), "nStartTab!=nEndTab");
  
  		String aTmp;
! 		rRef.Format( aTmp, SCA_VALID|SCA_TAB_3D, pDoc );		// immer 3d
  
  		SfxObjectShell* pObjSh = pDoc->GetDocumentShell();
  		String aFileName = pObjSh->GetMedium()->GetName();
--- 2467,2473 ----
  		DBG_ASSERT(rRef.aStart.Tab()==rRef.aEnd.Tab(), "nStartTab!=nEndTab");
  
  		String aTmp;
! 		rRef.Format( aTmp, SCA_VALID|SCA_TAB_3D, pDoc, aAddrDetails );		// immer 3d
  
  		SfxObjectShell* pObjSh = pDoc->GetDocumentShell();
  		String aFileName = pObjSh->GetMedium()->GetName();
*************** void ScInputHandler::SetReference( const
*** 2464,2472 ****
  	{
  		if ( ( rRef.aStart.Tab() != aCursorPos.Tab() ||
  				rRef.aStart.Tab() != rRef.aEnd.Tab() ) && pDoc )
! 			rRef.Format( aRefStr, SCA_VALID|SCA_TAB_3D, pDoc );
  		else
! 			rRef.Format( aRefStr, SCA_VALID );
  	}
  
  	if (pTableView || pTopView)
--- 2481,2489 ----
  	{
  		if ( ( rRef.aStart.Tab() != aCursorPos.Tab() ||
  				rRef.aStart.Tab() != rRef.aEnd.Tab() ) && pDoc )
! 			rRef.Format( aRefStr, SCA_VALID|SCA_TAB_3D, pDoc, aAddrDetails );
  		else
! 			rRef.Format( aRefStr, SCA_VALID, pDoc, aAddrDetails );
  	}
  
  	if (pTableView || pTopView)
*************** void ScInputHandler::NotifyChange( const
*** 2959,2964 ****
--- 2976,2983 ----
  					const EditTextObject*	pData	= pState->GetEditData();
  					String					aString = pState->GetString();
  					BOOL					bTxtMod = FALSE;
+ 					ScDocShell* pDocSh = pActiveViewSh->GetViewData()->GetDocShell();
+ 					ScDocument* pDoc = pDocSh->GetDocument();
  
  					aCursorPos	= pState->GetPos();
  
*************** void ScInputHandler::NotifyChange( const
*** 2994,2999 ****
--- 3013,3019 ----
  					if ( pInputWin )						// Bereichsanzeige
  					{
  						String aPosStr;
+ 						const ScAddress::Details aAddrDetails( pDoc, aCursorPos );
  
  						//	Ist der Bereich ein Name?
  						//!	per Timer suchen ???
*************** void ScInputHandler::NotifyChange( const
*** 3004,3019 ****
  
  						if ( !aPosStr.Len() )			// kein Name -> formatieren
  						{
  							if ( rSPos != rEPos )
  							{
! 								String aStr;
! 								rSPos.Format( aPosStr, SCA_VALID );
! 								aPosStr += ':';
! 								rEPos.Format( aStr, SCA_VALID );
! 								aPosStr += aStr;
  							}
  							else
! 								aCursorPos.Format( aPosStr, SCA_VALID );
  						}
  
  						pInputWin->SetPosString(aPosStr);
--- 3024,3040 ----
  
  						if ( !aPosStr.Len() )			// kein Name -> formatieren
  						{
+ 							USHORT nFlags = 0;
+ 							if( aAddrDetails.eConv == ScAddress::CONV_XL_R1C1 )
+ 								nFlags |= SCA_COL_ABSOLUTE | SCA_ROW_ABSOLUTE;
  							if ( rSPos != rEPos )
  							{
! 								ScRange r(rSPos, rEPos);
! 								nFlags |= (nFlags << 4);
! 								r.Format( aPosStr, SCA_VALID | nFlags, pDoc, aAddrDetails );
  							}
  							else
! 								aCursorPos.Format( aPosStr, SCA_VALID | nFlags, pDoc, aAddrDetails );
  						}
  
  						pInputWin->SetPosString(aPosStr);
Index: sc/source/ui/attrdlg/condfrmt.cxx
===================================================================
RCS file: /cvs/sc/source/ui/attrdlg/condfrmt.cxx,v
diff -cpr sc/source/ui/attrdlg/condfrmt.cxx sc/source/ui/attrdlg/condfrmt.cxx
*** sc/source/ui/attrdlg/condfrmt.cxx	Fri Jul 21 09:14:12 2006
--- sc/source/ui/attrdlg/condfrmt.cxx	Thu Aug 24 10:45:05 2006
*************** void ScConditionalFormatDlg::SetReferenc
*** 345,351 ****
  			RefInputStart(pEdActive);
  
  		String aStr;
! 		rRef.Format( aStr, SCR_ABS_3D, pDoc );
  		String aVal( pEdActive->GetText() );
  		Selection aSel( pEdActive->GetSelection() );
          aSel.Justify();
--- 345,351 ----
  			RefInputStart(pEdActive);
  
  		String aStr;
! 		rRef.Format( aStr, SCR_ABS_3D, pDoc, pDoc->GetAddressConvention () );
  		String aVal( pEdActive->GetText() );
  		Selection aSel( pEdActive->GetSelection() );
          aSel.Justify();
Index: sc/source/ui/inc/colrowba.hxx
===================================================================
RCS file: /cvs/sc/source/ui/inc/colrowba.hxx,v
diff -cpr sc/source/ui/inc/colrowba.hxx sc/source/ui/inc/colrowba.hxx
*** sc/source/ui/inc/colrowba.hxx	Thu Sep  8 17:15:24 2005
--- sc/source/ui/inc/colrowba.hxx	Thu Aug 24 10:45:05 2006
*************** public:
*** 79,84 ****
--- 79,86 ----
  	virtual void		DrawInvert( long nDragPos );
  
  	virtual String		GetDragHelp( long nVal );
+ 
+ 			BOOL		UseNumericHeader() const;
  };
  
  
Index: sc/source/ui/inc/docfunc.hxx
===================================================================
RCS file: /cvs/sc/source/ui/inc/docfunc.hxx,v
diff -cpr sc/source/ui/inc/docfunc.hxx sc/source/ui/inc/docfunc.hxx
*** sc/source/ui/inc/docfunc.hxx	Thu Aug 24 09:25:39 2006
--- sc/source/ui/inc/docfunc.hxx	Thu Aug 24 10:45:05 2006
*************** public:
*** 127,132 ****
--- 127,134 ----
  
  	BOOL			SetLayoutRTL( SCTAB nTab, BOOL bRTL, BOOL bApi );
  
+ 	BOOL	 	    SetAddressConvention( ScAddress::Convention eConv );
+ 
  	BOOL			SetWidthOrHeight( BOOL bWidth, SCCOLROW nRangeCnt, SCCOLROW* pRanges,
  									SCTAB nTab, ScSizeMode eMode, USHORT nSizeTwips,
  									BOOL bRecord, BOOL bApi );
Index: sc/source/ui/inc/undoblk.hxx
===================================================================
RCS file: /cvs/sc/source/ui/inc/undoblk.hxx,v
diff -cpr sc/source/ui/inc/undoblk.hxx sc/source/ui/inc/undoblk.hxx
*** sc/source/ui/inc/undoblk.hxx	Thu Aug 24 09:25:39 2006
--- sc/source/ui/inc/undoblk.hxx	Thu Aug 24 10:45:05 2006
*************** public:
*** 720,725 ****
--- 720,726 ----
  private:
  	ScDocument*		pUndoDoc;
  	String			aFormula;
+ 	ScAddress::Convention eConv;
  	ULONG			nStartChangeAction;
  	ULONG			nEndChangeAction;
  
Index: sc/source/ui/inc/undotab.hxx
===================================================================
RCS file: /cvs/sc/source/ui/inc/undotab.hxx,v
diff -cpr sc/source/ui/inc/undotab.hxx sc/source/ui/inc/undotab.hxx
*** sc/source/ui/inc/undotab.hxx	Thu Sep  8 18:03:47 2005
--- sc/source/ui/inc/undotab.hxx	Thu Aug 24 10:45:05 2006
*************** private:
*** 478,483 ****
--- 478,503 ----
  };
  
  
+ class ScUndoSetAddressConvention : public ScSimpleUndo
+ {
+ public:
+ 					TYPEINFO();
+ 					ScUndoSetAddressConvention( ScDocShell* pShell,
+ 												ScAddress::Convention eConv );
+ 	virtual			~ScUndoSetAddressConvention();
+ 
+ 	virtual void	Undo();
+ 	virtual void	Redo();
+ 	virtual void	Repeat(SfxRepeatTarget& rTarget);
+ 	virtual BOOL	CanRepeat(SfxRepeatTarget& rTarget) const;
+ 
+ 	virtual String	GetComment() const;
+ 
+ private:
+ 	ScAddress::Convention eNewConv, eOldConv;
+ 
+ 	void DoChange( ScAddress::Convention eConv );
+ };
  
  #endif
  
Index: sc/source/ui/src/globstr.src
===================================================================
RCS file: /cvs/sc/source/ui/src/globstr.src,v
diff -cpr sc/source/ui/src/globstr.src sc/source/ui/src/globstr.src
*** sc/source/ui/src/globstr.src	Wed Aug 23 16:33:09 2006
--- sc/source/ui/src/globstr.src	Thu Aug 24 10:45:05 2006
*************** Resource RID_GLOBSTR
*** 1799,1804 ****
--- 1799,1816 ----
  		Text [ de ] = "Tabelle wenden" ;
  		Text [ en-US ] = "Flip sheet" ;
  	};
+ 	String STR_UNDO_TAB_R1C1
+ 	{
+ 		Text [ en-US ] = "Toggle the use of R1C1 notation" ;
+ 		Text[ de ] = "Verwendung der R1C1-Notation umschalten";
+ 		Text[ es ] = "Alternar el uso de la notación R1C1";
+ 		Text[ fr ] = "Activer/Désactiver l'usage de la notation R1C1";
+ 		Text[ it ] = "Alterna l'utilizzo della notazione R1C1";
+ 		Text[ ja ] = "R1C1表記の使用をトグルする";
+ 		Text[ pt-BR ] = "Alterna o uso da notação R1C1";
+ 		Text[ zh-CN ] = "切换使用 R1C1 表示法";
+ 		Text[ zh-TW ] = "切換使用 R1C1 標記";
+ 	};
  	String STR_CHART_MAINTITLE
  	{
  		Text [ de ] = "Haupttitel" ;
Index: sc/source/ui/src/scfuncs.src
===================================================================
RCS file: /cvs/sc/source/ui/src/scfuncs.src,v
diff -cpr sc/source/ui/src/scfuncs.src sc/source/ui/src/scfuncs.src
*** sc/source/ui/src/scfuncs.src	Wed Aug 23 16:41:36 2006
--- sc/source/ui/src/scfuncs.src	Thu Aug 24 10:45:05 2006
*************** Resource RID_SC_FUNCTION_DESCRIPTIONS2
*** 9047,9052 ****
--- 9047,9141 ----
  			Text [ x-comment ] = " ";
  		};
  	};
+ 	Resource SC_OPCODE_ADRESS_XL
+ 	{
+ 		String 1 // Description
+ 		{
+ 			Text [ en-US ] = "Returns the reference to a cell as text." ;
+ 		Text[ de ] = "Gibt die Referenz auf eine Zelle als Text zurück.";
+ 		Text[ es ] = "Devuelve la referencia a una celda en formato de texto.";
+ 		Text[ fr ] = "Retourne la référence à une cellule sous forme de texte.";
+ 		Text[ it ] = "Restituisce un riferimento a una cella come testo.";
+ 		Text[ ja ] = "セルへの参照をテキストとして戻します。";
+ 		Text[ pt-BR ] = "Retorna a referência a uma célula como texto.";
+ 		Text[ zh-CN ] = "将引用作为文本返回至单元。";
+ 		Text[ zh-TW ] = "以文字方式傳回儲存格參考。";
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		ExtraData =
+ 		{
+ 			ID_FUNCTION_GRP_TABLE;
+ 			U2S( HID_FUNC_ADRESSE_XL );
+ 			5;	0;	0;	1;	1;	1;
+ 		};
+ 		String 2 // Name of Parameter 1
+ 		{
+ 			Text [ de ] = "Zeile" ;
+ 			Text [ en-US ] = "row" ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 3 // Description of Parameter 1
+ 		{
+ 			Text [ de ] = "Die Zeilennummer der Zelle." ;
+ 			Text [ en-US ] = "The row number of the cell." ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 4 // Name of Parameter 2
+ 		{
+ 			Text [ de ] = "Spalte" ;
+ 			Text [ en-US ] = "column" ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 5 // Description of Parameter 2
+ 		{
+ 			Text [ de ] = "Die Spaltennummer der Zelle." ;
+ 			Text [ en-US ] = "The column number of the cell." ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 6 // Name of Parameter 3
+ 		{
+ 			Text [ de ] = "ABS" ;
+ 			Text [ en-US ] = "ABS" ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 7 // Description of Parameter 3
+ 		{
+ 			Text [ de ] = "Gibt an, ob absolute oder relative Referenzierung verwendet wird." ;
+ 			Text [ en-US ] = "Specifies whether absolute or relative referencing is to be used." ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 8 // Name of Parameter 4
+ 		{
+ 			Text [ de ] = " ";
+ 			Text [ en-US ] = "A1";
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 9 // Description of Parameter 4
+ 		{
+ 			Text [ en-US ] = "If TRUE (or 1) or omitted generate A1 style address, otherwise produce R1C1 style address.";
+ 		Text[ de ] = "Wenn TRUE (oder 1) bzw. ausgelassen, A1-Adresse generieren, anderenfalls R1C1-Adresse erstellen.";
+ 		Text[ es ] = "Si el valor es TRUE (o 1) o se omite, genera una dirección del estilo A1; de lo contrario, genera una dirección del estilo R1C1.";
+ 		Text[ fr ] = "Si TRUE (ou 1) ou omis, générer une adresse de style A1. Sinon, produire une adresse de style R1C1.";
+ 		Text[ it ] = "Se impostato su TRUE (o 1) oppure se omesso genera un indirizzo tipo A1, altrimenti genera un indirizzo di tipo R1C1.";
+ 		Text[ ja ] = "TRUE (1)またはA1スタイルアドレスが作成されていない場合、R1C1スタイルアドレスが作成されます。";
+ 		Text[ pt-BR ] = "Se VERDADEIRO (ou 1) ou omitido, gerar endereço em estilo A1; caso contrário produzir endereço em estilo R1C1.";
+ 		Text[ zh-CN ] = "如果为 TRUE（或 1），忽略生成 A1 样式地址，否则生成 R1C1 样式地址。";
+ 		Text[ zh-TW ] = "如果是傳回 TRUE (或 1) 或是省略就會產生 A1 格式位址，傳回其他值則會產生 R1C1 格式位址。";
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 10 // Name of Parameter 5
+ 		{
+ 			Text [ de ] = "Tabelle" ;
+ 			Text [ en-US ] = "sheet" ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 11 // Description of Parameter 5
+ 		{
+ 			Text [ de ] = "Der Tabellenname des Zellbezugs." ;
+ 			Text [ en-US ] = "The spreadsheet name of the cell reference." ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 	};
  	 // -=*# Resource for function BEREICHE #*=-
  	Resource SC_OPCODE_AREAS
  	{
*************** Resource RID_SC_FUNCTION_DESCRIPTIONS2
*** 9512,9517 ****
--- 9601,9653 ----
  			Text [ x-comment ] = " ";
  		};
  	};
+ 	 // -=*# Resource for function INDIREKT_XL #*=-
+ 	Resource SC_OPCODE_INDIRECT_XL
+ 	{
+ 		String 1 // Description
+ 		{
+ 			Text [ de ] = "Bestimmt den Inhalt einer als Bezug in MS Excel (tm) Textform angegebenen Zelle." ;
+ 			Text [ en-US ] = "Returns the contents of a cell that is referenced in MS Excel (tm) text form." ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		ExtraData =
+ 		{
+ 			ID_FUNCTION_GRP_TABLE;
+ 			U2S( HID_FUNC_INDIREKT_XL );
+ 			2;	0;	1;	
+ 		};
+ 		String 2 // Name of Parameter 1
+ 		{
+ 			Text [ de ] = "Bezug" ;
+ 			Text [ en-US ] = "ref " ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 3 // Description of Parameter 1
+ 		{
+ 			Text [ de ] = "Die Zelle, deren Inhalt ausgewertet werden soll als Bezug in MS Excel (tm) Textform (z.B. \"Sheet!A1\")." ;
+ 			Text [ en-US ] = "The cell whose contents are to be evaluated is to be referenced in MS Excel (tm) text form (e.g. \"Sheet!A1\")." ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 4 // Name of Parameter 2
+ 		{
+ 			Text [ de ] = "'Adressformat'" ;
+ 			Text [ en-US ] = "Format" ;
+ 			Text [ x-comment ] = " ";
+ 		};
+ 		String 5 // Description of Parameter 2
+ 		{
+ 			Text [ en-US ] = "What address format to expect.  TRUE for A1, FALSE for R1C1.  Defaults to A1." ;
+ 		Text[ de ] = "Zu erwartendes Adressformat.  TRUE für A1, FALSE für R1C1.  Standardmäßig wird A1 verwendet.";
+ 		Text[ es ] = "Formato de dirección que se debe esperar. TRUE para A1, FALSE para R1C1. El valor por defecto es A1.";
+ 		Text[ fr ] = "Quel format d'adresse attendre.  TRUE pour A1, FALSE pour R1C1.  La valeur par défaut est A1.";
+ 		Text[ it ] = "Formato di indirizzo previsto.  TRUE per A1, FALSE per R1C1.  Il valore predefinito è A1.";
+ 		Text[ ja ] = "作成されるアドレス形式  TRUEの場合はA1、FALSEの場合はR1C1が作成されます。  デフォルトでは、A1になります。";
+ 		Text[ pt-BR ] = "Formato do endereço esperado. VERDADEIRO para A1, FALSO para R1C1. Usa A1 por padrão.";
+ 		Text[ zh-CN ] = "期望何种地址格式。TRUE 代表 A1，FALSE 代表 R1C1。默认值为 A1。";
+ 		Text[ zh-TW ] = "預期會產生的位址格式。TRUE 會產生 A1 格式，FALSE 會產生 R1C1 格式。預設是產生 A1 格式。";
+ 			Text [ x-comment ] = " ";
+ 		};
+ 	};
  	 // -=*# Resource for function VERWEIS #*=-
  	Resource SC_OPCODE_LOOKUP
  	{
Index: sc/source/ui/undo/undotab.cxx
===================================================================
RCS file: /cvs/sc/source/ui/undo/undotab.cxx,v
diff -cpr sc/source/ui/undo/undotab.cxx sc/source/ui/undo/undotab.cxx
*** sc/source/ui/undo/undotab.cxx	Fri Jul 21 10:27:52 2006
--- sc/source/ui/undo/undotab.cxx	Thu Aug 24 10:45:05 2006
*************** TYPEINIT1(ScUndoPrintRange,		SfxUndoActi
*** 95,100 ****
--- 95,101 ----
  TYPEINIT1(ScUndoScenarioFlags,	SfxUndoAction);
  TYPEINIT1(ScUndoRenameObject,	SfxUndoAction);
  TYPEINIT1(ScUndoLayoutRTL,		SfxUndoAction);
+ TYPEINIT1(ScUndoSetAddressConvention,		SfxUndoAction);
  
  
  // -----------------------------------------------------------------------
*************** String __EXPORT ScUndoLayoutRTL::GetComm
*** 1533,1537 ****
--- 1534,1594 ----
  
  
  
+ // -----------------------------------------------------------------------
+ //
+ //		Set the address convention used for the sheet
+ //
+ 
+ ScUndoSetAddressConvention::ScUndoSetAddressConvention( ScDocShell* pShell,
+ 														ScAddress::Convention eConv ) :
+ 	ScSimpleUndo( pShell ),
+ 	eNewConv( eConv )
+ {
+ 	eOldConv = pDocShell->GetDocument()->GetAddressConvention();
+ }
+ 
+ __EXPORT ScUndoSetAddressConvention::~ScUndoSetAddressConvention()
+ {
+ }
+ 
+ void ScUndoSetAddressConvention::DoChange( ScAddress::Convention eConv )
+ {
+ 	pDocShell->SetInUndo( TRUE );
+ 	ScDocument* pDoc = pDocShell->GetDocument();
+ 	pDoc->SetAddressConvention( eConv );
+ 	pDocShell->SetDocumentModified();
+ 	pDocShell->SetInUndo( FALSE );
+ }
+ 
+ void __EXPORT ScUndoSetAddressConvention::Undo()
+ {
+ 	DoChange( eOldConv );
+ }
+ 
+ void __EXPORT ScUndoSetAddressConvention::Redo()
+ {
+ 	DoChange( eNewConv );
+ }
+ 
+ void __EXPORT ScUndoSetAddressConvention::Repeat(SfxRepeatTarget& rTarget)
+ {
+ 	if (rTarget.ISA(ScTabViewTarget))
+ 		((ScTabViewTarget&)rTarget).GetViewShell()->GetViewData()->GetDispatcher().
+ 			Execute( FID_TAB_USE_R1C1, SFX_CALLMODE_SLOT | SFX_CALLMODE_RECORD);
+ }
+ 
+ BOOL __EXPORT ScUndoSetAddressConvention::CanRepeat(SfxRepeatTarget& rTarget) const
+ {
+ 	return (rTarget.ISA(ScTabViewTarget));
+ }
+ 
+ String __EXPORT ScUndoSetAddressConvention::GetComment() const
+ {
+ 	return ScGlobal::GetRscString( STR_UNDO_TAB_R1C1 );
+ }
+ 
+ 
+ 
+ 
  
  
Index: sc/source/ui/unoobj/cellsuno.cxx
===================================================================
RCS file: /cvs/sc/source/ui/unoobj/cellsuno.cxx,v
diff -cpr sc/source/ui/unoobj/cellsuno.cxx sc/source/ui/unoobj/cellsuno.cxx
*** sc/source/ui/unoobj/cellsuno.cxx	Thu Aug 24 09:25:40 2006
--- sc/source/ui/unoobj/cellsuno.cxx	Thu Aug 24 22:23:19 2006
*************** uno::Reference<table::XCellRange> SAL_CA
*** 4914,4922 ****
--- 4914,4929 ----
  	return NULL;
  }
  
+ 
  uno::Reference<table::XCellRange> SAL_CALL ScCellRangeObj::getCellRangeByName(
  						const rtl::OUString& aName ) throw(uno::RuntimeException)
  {
+ 	return getCellRangeByName( aName, ScAddress::detailsOOOa1 ); 
+ }
+ 
+ uno::Reference<table::XCellRange>  ScCellRangeObj::getCellRangeByName(
+ 						const rtl::OUString& aName, const ScAddress::Details& rDetails  ) throw(uno::RuntimeException)
+ {
  	//	name refers to the whole document (with the range's table as default),
  	//	valid only if the range is within this range
  
*************** uno::Reference<table::XCellRange> SAL_CA
*** 4930,4936 ****
  		ScRange aCellRange;
  		BOOL bFound = FALSE;
  		String aString(aName);
! 		USHORT nParse = aCellRange.ParseAny( aString, pDoc );
  		if ( nParse & SCA_VALID )
  		{
  			if ( !(nParse & SCA_TAB_3D) )	// keine Tabelle angegeben -> auf dieser Tabelle
--- 4937,4943 ----
  		ScRange aCellRange;
  		BOOL bFound = FALSE;
  		String aString(aName);
! 		USHORT nParse = aCellRange.ParseAny( aString, pDoc, rDetails );
  		if ( nParse & SCA_VALID )
  		{
  			if ( !(nParse & SCA_TAB_3D) )	// keine Tabelle angegeben -> auf dieser Tabelle
Index: sc/source/ui/view/colrowba.cxx
===================================================================
RCS file: /cvs/sc/source/ui/view/colrowba.cxx,v
diff -cpr sc/source/ui/view/colrowba.cxx sc/source/ui/view/colrowba.cxx
*** sc/source/ui/view/colrowba.cxx	Wed Aug 23 16:33:09 2006
--- sc/source/ui/view/colrowba.cxx	Thu Aug 24 10:45:05 2006
*************** ScColBar::~ScColBar()
*** 95,100 ****
--- 95,105 ----
  {
  }
  
+ inline BOOL ScColBar::UseNumericHeader() const
+ {
+     return pViewData->GetDocument()->GetAddressConvention() == ScAddress::CONV_XL_R1C1;
+ }
+ 
  SCCOLROW ScColBar::GetPos()
  {
  	return pViewData->GetPosX(eWhich);
*************** USHORT ScColBar::GetEntrySize( SCCOLROW 
*** 112,118 ****
  
  String ScColBar::GetEntryText( SCCOLROW nEntryNo )
  {
! 	return ColToAlpha( static_cast<SCCOL>(nEntryNo) );
  }
  
  void ScColBar::SetEntrySize( SCCOLROW nPos, USHORT nNewSize )
--- 117,125 ----
  
  String ScColBar::GetEntryText( SCCOLROW nEntryNo )
  {
! 	return UseNumericHeader()
! 	    ? String::CreateFromInt32( nEntryNo + 1 )
! 	    : ColToAlpha( static_cast<SCCOL>(nEntryNo) );
  }
  
  void ScColBar::SetEntrySize( SCCOLROW nPos, USHORT nNewSize )
Index: sc/source/ui/view/tabvwshf.cxx
===================================================================
RCS file: /cvs/sc/source/ui/view/tabvwshf.cxx,v
diff -cpr sc/source/ui/view/tabvwshf.cxx sc/source/ui/view/tabvwshf.cxx
*** sc/source/ui/view/tabvwshf.cxx	Fri Jul 21 11:18:20 2006
--- sc/source/ui/view/tabvwshf.cxx	Thu Aug 24 10:45:05 2006
*************** void ScTabViewShell::ExecuteTable( SfxRe
*** 687,692 ****
--- 687,703 ----
  			}
  			break;
  
+ 		case FID_TAB_USE_R1C1:
+ 			{
+ 				ScDocFunc aFunc( *pViewData->GetDocShell() );
+ 				const ScAddress::Convention eConv =  
+ 					(pDoc->GetAddressConvention() == ScAddress::CONV_OOO)
+ 						? ScAddress::CONV_XL_R1C1 : ScAddress::CONV_OOO ;
+ 
+ 				aFunc.SetAddressConvention( eConv );
+ 			}
+ 			break;
+ 
  		default:
  			DBG_ERROR("Unbekannte Message bei ViewShell");
  			break;
*************** void ScTabViewShell::GetStateTable( SfxI
*** 806,811 ****
--- 817,829 ----
  						rSet.Put( SfxBoolItem( nWhich, pDoc->IsLayoutRTL( nTab ) ) );
  				}
  				break;
+ 
+ 			case FID_TAB_USE_R1C1:
+ 				{
+ 					const ScAddress::Convention eConv =  pDoc->GetAddressConvention();
+ 					rSet.Put( SfxBoolItem( nWhich, eConv == ScAddress::CONV_XL_R1C1 ) );
+ 				}
+ 				break;
  		}
  		nWhich = aIter.NextWhich();
  	}
Index: sc/source/ui/view/viewfunc.cxx
===================================================================
RCS file: /cvs/sc/source/ui/view/viewfunc.cxx,v
diff -cpr sc/source/ui/view/viewfunc.cxx sc/source/ui/view/viewfunc.cxx
*** sc/source/ui/view/viewfunc.cxx	Wed Aug 23 16:33:09 2006
--- sc/source/ui/view/viewfunc.cxx	Thu Aug 24 10:45:05 2006
*************** void ScViewFunc::EnterMatrix( const Stri
*** 834,840 ****
  		SCCOL nCol = pData->GetCurX();
  		SCROW nRow = pData->GetCurY();
  		SCTAB nTab = pData->GetTabNo();
! 		ScFormulaCell aFormCell( pDoc, ScAddress(nCol,nRow,nTab), rString, MM_FORMULA );
  
          SCSIZE nSizeX;
          SCSIZE nSizeY;
--- 834,840 ----
  		SCCOL nCol = pData->GetCurX();
  		SCROW nRow = pData->GetCurY();
  		SCTAB nTab = pData->GetTabNo();
! 		ScFormulaCell aFormCell( pDoc, ScAddress(nCol,nRow,nTab), rString, ScAddress::CONV_UNSPECIFIED, MM_FORMULA );
  
          SCSIZE nSizeX;
          SCSIZE nSizeY;
*** sc/source/ui/docshell/docfunc.cxx	Thu Aug 24 09:25:39 2006
--- sc/source/ui/docshell/docfunc.cxx	Thu Aug 24 10:45:05 2006
*************** BOOL ScDocFunc::SetLayoutRTL( SCTAB nTab
*** 2226,2231 ****
--- 2226,2267 ----
  	return TRUE;
  }
  
+ BOOL ScDocFunc::SetAddressConvention( ScAddress::Convention eConv )
+ {
+ 	ScDocument* pDoc = rDocShell.GetDocument();
+ 
+ 	if ( pDoc->GetAddressConvention() == eConv )
+ 		return TRUE;
+ 
+ 	BOOL bUndo(pDoc->IsUndoEnabled());
+ 	ScDocShellModificator aModificator( rDocShell );
+ 
+ 	pDoc->SetAddressConvention( eConv );
+ 
+ 	if (bUndo)
+ 	{
+ 		rDocShell.GetUndoManager()->AddUndoAction( new ScUndoSetAddressConvention( &rDocShell, eConv ) );
+ 	}
+ 
+ 	rDocShell.PostPaint( 0,0,0,MAXCOL,MAXROW,MAXTAB, PAINT_ALL );
+ 
+ 	ScTabViewShell* pViewSh = ScTabViewShell::GetActiveViewShell();
+ 	if (NULL != pViewSh)
+ 	{
+ 	    pViewSh->UpdateInputHandler( FALSE, FALSE );
+ 	}
+ 
+ 	aModificator.SetDocumentModified();
+ 
+ 	SfxBindings* pBindings = rDocShell.GetViewBindings();
+ 	if (pBindings)
+ 	{
+ 		pBindings->Invalidate( FID_TAB_USE_R1C1 );
+ 	}
+ 
+ 	return TRUE;
+ }
+ 
  BOOL ScDocFunc::RenameTable( SCTAB nTab, const String& rName, BOOL bRecord, BOOL bApi )
  {
  	ScDocument* pDoc = rDocShell.GetDocument();
