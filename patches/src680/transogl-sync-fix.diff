diff -rup OGLTrans-orig/OGLTrans_TransitionerImpl.cxx OGLTrans/OGLTrans_TransitionerImpl.cxx
--- OGLTrans-orig/OGLTrans_TransitionerImpl.cxx	2008-03-28 10:20:31.000000000 +0100
+++ OGLTrans/OGLTrans_TransitionerImpl.cxx	2008-03-28 11:22:52.000000000 +0100
@@ -183,16 +183,6 @@ void OGLTransitionerImpl::initialize( co
         instance = new OGLTransitionerImpl( NULL );
         instance->initWindowFromSlideShowView( xView, 0, 0 );
 
-        if( instance->GLWin.HasGLXExtension("GLX_SGI_swap_control" ) ) {
-            // enable vsync
-            typedef GLint (*glXSwapIntervalProc)(GLint);
-            glXSwapIntervalProc glXSwapInterval = (glXSwapIntervalProc) unx::glXGetProcAddress( (const GLubyte*) "glXSwapIntervalSGI" );
-            if( glXSwapInterval ) {
-                glXSwapInterval( 1 );
-                OSL_TRACE("set swap interval to 1 (enable vsync)");
-            }
-        }
-
         const GLubyte* version = glGetString( GL_VERSION );
         if( version && version[0] ) {
             cnGLVersion = version[0] - '0';
@@ -209,6 +199,7 @@ void OGLTransitionerImpl::initialize( co
         /* TODO: check for version once the bug in fglrx driver is fixed */
         cbBrokenTexturesATI = (strcmp( (const char *) glGetString( GL_VENDOR ), "ATI Technologies Inc." ) == 0 );
 
+        instance->disposing();
         delete instance;
         initialized = true;
     }
@@ -343,6 +334,20 @@ bool OGLTransitionerImpl::initWindowFrom
         return false;
     }
     glXMakeCurrent( GLWin.dpy, GLWin.win, GLWin.ctx );
+    if( glGetError() != GL_NO_ERROR ) {
+        OSL_TRACE("glError: %s\n", (char *)gluErrorString(glGetError()));
+        return false;
+    }
+
+    if( GLWin.HasGLXExtension("GLX_SGI_swap_control" ) ) {
+        // enable vsync
+        typedef GLint (*glXSwapIntervalProc)(GLint);
+        glXSwapIntervalProc glXSwapInterval = (glXSwapIntervalProc) unx::glXGetProcAddress( (const GLubyte*) "glXSwapIntervalSGI" );
+        if( glXSwapInterval ) {
+            glXSwapInterval( 1 );
+            OSL_TRACE("set swap interval to 1 (enable vsync)");
+        }
+    }
 
     glEnable(GL_CULL_FACE);
     glCullFace(GL_BACK);
@@ -489,7 +494,7 @@ void OGLTransitionerImpl::GLInitSlides()
     
     glGenTextures(1, &GLleavingSlide);
 	glBindTexture(GL_TEXTURE_2D, GLleavingSlide);
-    if( pTransition && !cbBrokenTexturesATI && !pTransition->mbUseMipMapLeaving) {
+    if( ( pTransition && !pTransition->mbUseMipMapLeaving ) || cbBrokenTexturesATI || cbMesa ) {
         glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, SlideSize.Width, SlideSize.Height, 0, Format, GL_UNSIGNED_BYTE, &LeavingBytes[0]);
         glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
         glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
@@ -513,7 +518,7 @@ void OGLTransitionerImpl::GLInitSlides()
 	
 	glGenTextures(1, &GLenteringSlide);
 	glBindTexture(GL_TEXTURE_2D, GLenteringSlide);
-    if( pTransition && !cbBrokenTexturesATI && !pTransition->mbUseMipMapEntering ) {
+    if( ( pTransition && !pTransition->mbUseMipMapLeaving ) || cbBrokenTexturesATI || cbMesa ) {
         glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, SlideSize.Width, SlideSize.Height, 0, Format, GL_UNSIGNED_BYTE, &EnteringBytes[0]);
         glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
         glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
@@ -552,6 +557,10 @@ void SAL_CALL OGLTransitionerImpl::updat
 	unx::glXSwapBuffers(GLWin.dpy, GLWin.win);
 	if( pWindow )
         pWindow->Show();
+
+    /* flush & sync */
+    glFlush();
+    XSync( GLWin.dpy, false );
 }
 
 // we are about to be disposed (someone call dispose() on us)
@@ -566,7 +575,10 @@ void OGLTransitionerImpl::disposing()
 
     if(GLWin.ctx)
 	{
-	    OSL_ENSURE( glXMakeCurrent(GLWin.dpy, None, NULL) , "Error releasing glX context" );
+        glXMakeCurrent(GLWin.dpy, None, NULL);
+        if( glGetError() != GL_NO_ERROR ) {
+            OSL_TRACE("glError: %s\n", (char *)gluErrorString(glGetError()));
+        }
 		glXDestroyContext(GLWin.dpy, GLWin.ctx);
 		GLWin.ctx = NULL;
 	}
@@ -650,7 +662,7 @@ public:
             return uno::Reference< presentation::XTransition >();
             
 
-        OGLTransitionImpl* pTransition;
+        OGLTransitionImpl* pTransition = NULL;
 
         if( transitionType == animations::TransitionType::MISCSHAPEWIPE ) {
             pTransition = new OGLTransitionImpl();
