Index: sc/source/core/tool/interpr1.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/tool/interpr1.cxx,v
retrieving revision 1.53
diff -u -r1.53 interpr1.cxx
--- sc/source/core/tool/interpr1.cxx	1 Nov 2007 16:23:17 -0000	1.53
+++ sc/source/core/tool/interpr1.cxx	13 Feb 2008 17:00:48 -0000
@@ -3815,9 +3815,49 @@
 	}
 }
 
+/** returns -1 when the matrix value is smaller than the query value, 0 when
+    they are equal, and 1 when the matrix value is larger than the query
+    value. */
+static sal_Int8 lcl_CompareMatrix2Query(SCSIZE i, const ScMatrix& rMat, const ScQueryEntry& rEntry)
+{
+    if (rMat.IsValue(i))
+    {
+        const double nVal1 = rMat.GetDouble(i);
+        const double nVal2 = rEntry.nVal;
+        if (nVal1 == nVal2)
+            return 0;
+
+        return nVal1 < nVal2 ? -1 : 1;
+    }
+
+    if (!rEntry.pStr)
+        // this should not happen!
+        return 1;
+
+    const String& rStr1 = rMat.GetString(i);
+    const String& rStr2 = *rEntry.pStr;
+
+    return rStr1.CompareIgnoreCaseToAscii(rStr2); // case-insensitive
+}
+
+/** returns the last item with the identical value as the original item
+    value. */
+static void lcl_GetLastMatch(SCSIZE& rIndex, const ScMatrix& rMat, SCSIZE nMatCount,
+                             bool bReverse)
+{
+    double nVal = rMat.GetDouble(rIndex);
+    if (bReverse)
+        while (rIndex > 0 && nVal == rMat.GetDouble(rIndex-1))
+            --rIndex;
+    else
+        while (rIndex < nMatCount-1 && nVal == rMat.GetDouble(rIndex+1))
+            ++rIndex;
+}
 
 void ScInterpreter::ScMatch()
 {
+    ScMatrixRef pMatSrc = NULL;
+
 	BYTE nParamCount = GetByte();
 	if ( MustHaveParamCount( nParamCount, 2, 3 ) )
 	{
@@ -3841,6 +3881,15 @@
 				return;
 			}
 		}
+        else if (GetStackType() == svMatrix)
+        {
+            pMatSrc = PopMatrix();
+            if (!pMatSrc)
+            {
+                SetIllegalParameter();
+                return;
+            }
+        }
 		else
 		{
 			SetIllegalParameter();
@@ -3918,6 +3967,100 @@
 			}
 			if ( rEntry.bQueryByString )
                 rParam.bRegExp = MayBeRegExp( *rEntry.pStr, pDok );
+
+            if (pMatSrc) // The source data is matrix array.
+            {
+                SCSIZE nC, nR;
+                pMatSrc->GetDimensions(nC, nR);
+                if (nC > 1 && nR > 1)
+                {
+                    // The source matrix must be a vector.
+                    SetIllegalParameter();
+                    return;
+                }
+                SCSIZE nMatCount = (nC == 1) ? nR : nC;
+
+                // simple serial search for equality mode (source data doesn't 
+                // need to be sorted).
+
+                if (rEntry.eOp == SC_EQUAL)
+                {
+                    for (SCSIZE i = 0; i < nMatCount; ++i)
+                    {
+                        if (lcl_CompareMatrix2Query(i, *pMatSrc, rEntry) == 0)
+                        {
+                            PushDouble(i+1); // found !
+                            return;
+                        }
+                    }
+                    SetNA(); // not found
+                    return;
+                }
+
+                // binary search for non-equality mode (the source data is
+                // assumed to be sorted).
+
+                bool bAscOrder = (rEntry.eOp == SC_LESS_EQUAL);
+                SCSIZE nFirst = 0, nLast = nMatCount-1, nHitIndex = 0;
+                for (SCSIZE nLen = nLast-nFirst; nLen > 0; nLen = nLast-nFirst)
+                {
+                    SCSIZE nMid = nFirst + nLen/2;
+                    sal_Int8 nCmp = lcl_CompareMatrix2Query(nMid, *pMatSrc, rEntry);
+                    if (nCmp == 0)
+                    {
+                        // exact match.  find the last item with the same value.
+                        lcl_GetLastMatch(nMid, *pMatSrc, nMatCount, !bAscOrder);
+                        PushDouble(nMid+1);
+                        return;
+                    }
+
+                    if (nLen == 1) // first and last items are next to each other.
+                    {
+                        if (nCmp < 0)
+                            nHitIndex = bAscOrder ? nLast : nFirst;
+                        else
+                            nHitIndex = bAscOrder ? nFirst : nLast;
+                        break;
+                    }
+
+                    if (nCmp < 0)
+                    {
+                        if (bAscOrder)
+                            nFirst = nMid;
+                        else
+                            nLast = nMid;
+                    }
+                    else
+                    {
+                        if (bAscOrder)
+                            nLast = nMid;
+                        else
+                            nFirst = nMid;
+                    }
+                }
+
+                if (nHitIndex == nMatCount-1) // last item
+                {
+                    sal_Int8 nCmp = lcl_CompareMatrix2Query(nHitIndex, *pMatSrc, rEntry);
+                    if ((bAscOrder && nCmp <= 0) || (!bAscOrder && nCmp >= 0))
+                    {
+                        // either the last item is an exact match or the real
+                        // hit is beyond the last item.
+                        PushDouble(nHitIndex+1); 
+                        return;
+                    }
+                }
+
+                if (nHitIndex > 0) // valid hit must be 2nd item or higher
+                {
+                    PushDouble(nHitIndex); // non-exact match
+                    return;
+                }
+
+                SetNA();
+                return;
+            }
+
 			SCCOLROW nDelta = 0;
             if (nCol1 == nCol2)
             {                                           // search row in column
