--- tools/source/generic/fract.cxx	2006-09-27 12:50:16.000000000 +0200
+++ tools/source/generic/fract.cxx	2007-06-13 15:28:43.000000000 +0200
@@ -513,11 +513,10 @@ Fraction& Fraction::operator /= ( const 
 |*
 |*    Beschreibung      FRACT.SDW
 |*    Ersterstellung    JOE 17.09.95
-|*    Letzte Aenderung  JOE 17.09.95
+|*    Letzte Aenderung  kendy 2007-06-13
 |*
 *************************************************************************/
 
-// Funktioniert z.Zt. nur fuer 32-Bit Werte !!!
 // Fehlerbehaftetes Kuerzen einer Fraction.
 // nSignificantBits gibt an, wieviele signifikante Binaerstellen
 // in Zaehler/Nenner mindestens erhalten bleiben sollen.
@@ -528,61 +527,95 @@ Fraction& Fraction::operator /= ( const 
 // = ca.  1.007812499
 // Nach ReduceInaccurate( 8 ) wird daraus 1/1.
 
-void Fraction::ReduceInaccurate( unsigned nSignificantBits )
+// Similar to clz_table that can be googled
+const char nbits_table[32] =
 {
-    if ( !nNumerator || !nDenominator )
-        return;
+    32,  1, 23,  2, 29, 24, 14,  3,
+    30, 27, 25, 18, 20, 15, 10,  4,
+    31, 22, 28, 13, 26, 17, 19,  9,
+    21, 12, 16,  8, 11,  7,  6,  5
+};
+
+static int impl_NumberOfBits( unsigned long nNum )
+{
+    // http://en.wikipedia.org/wiki/De_Bruijn_sequence
+    sal_uInt32 nDeBruijn = 0x7DCD629;
+
+    if ( nNum == 0 )
+        return 0;
 
-    // Zaehler und Nenner auf den Stack fuer schnelleren Zugriff
-    unsigned long nMul;
-    unsigned long nDiv;
-    BOOL   bNeg;
-    if ( nNumerator >= 0 )
+    // Get it to form like 0000001111111111b
+    nNum |= ( nNum >>  1 );
+    nNum |= ( nNum >>  2 );
+    nNum |= ( nNum >>  4 );
+    nNum |= ( nNum >>  8 );
+    nNum |= ( nNum >> 16 );
+
+    sal_uInt32 nNumber;
+    int nBonus = 0;
+
+#if SAL_TYPES_SIZEOFLONG == 4
+    nNumber = nNum;
+#elif SAL_TYPES_SIZEOFLONG == 8
+    nNum |= ( nNum >> 32 );
+
+    if ( nNum & 0x80000000 )
     {
-        nMul = (unsigned long)nNumerator;
-        bNeg = FALSE;
+        nNumber = sal_uInt32( nNum >> 32 );
+        nBonus = 32;
+
+        if ( nNumber == 0 )
+            return 32;
     }
     else
-    {
-        nMul = (unsigned long)(-nNumerator);
-        bNeg = TRUE;
-    }
-    nDiv=(unsigned long)nDenominator;
+        nNumber = sal_uInt32( nNum & 0xFFFFFFFF );
+#else
+#error "Unknown size of long!"
+#endif
+
+    // De facto shift left of nDeBruijn using multiplication
+    nNumber = nDeBruijn + ( nDeBruijn * nNumber );
+
+    // 5-bit window indexes the result
+    return ( nbits_table[nNumber >> 27] ) + nBonus;
+}
+
+void Fraction::ReduceInaccurate( unsigned nSignificantBits )
+{
+    if ( !nNumerator || !nDenominator )
+        return;
+
+    // Count with unsigned longs only
+    sal_Bool bNeg = ( nNumerator < 0 );
+    unsigned long nMul = (unsigned long)( bNeg? -nNumerator: nNumerator );
+    unsigned long nDiv = (unsigned long)( nDenominator );
+
+    // How much bits can we lose?
+    int nMulBitsToLose = Max( ( impl_NumberOfBits( nMul ) - int( nSignificantBits ) ), 0 );
+    int nDivBitsToLose = Max( ( impl_NumberOfBits( nDiv ) - int( nSignificantBits ) ), 0 );
+
+    int nToLose = Min( nMulBitsToLose, nDivBitsToLose );
+
+    // Remove the bits
+    nMul >>= nToLose;
+    nDiv >>= nToLose;
 
-    unsigned long a=nMul; unsigned nMulZ=0; // Fuehrende Nullen zaehlen
-    while (a<0x00800000) { nMulZ+=8; a<<=8; }
-    while (a<0x80000000) { nMulZ++; a<<=1; }
-    a=nDiv; unsigned nDivZ=0; // Fuehrende Nullen zaehlen
-    while (a<0x00800000) { nDivZ+=8; a<<=8; }
-    while (a<0x80000000) { nDivZ++; a<<=1; }
-    // Anzahl der verwendeten Digits bestimmen
-    // Auch hier gehe ich davon aus, dass es sich um 32Bit-Werte handelt
-    int nMulDigits=(sizeof(long) * 8)-nMulZ;
-    int nDivDigits=(sizeof(long) * 8)-nDivZ;
-    // Nun bestimmen, wieviele Stellen hinten weg koennen
-    // Hier koennte man das Ergebnis noch etwas optimieren...
-    int nMulWeg=nMulDigits-nSignificantBits; if (nMulWeg<0) nMulWeg=0;
-    int nDivWeg=nDivDigits-nSignificantBits; if (nDivWeg<0) nDivWeg=0;
-    int nWeg=Min(nMulWeg,nDivWeg);
-    nMul>>=nWeg;
-    nDiv>>=nWeg;
     if ( !nMul || !nDiv )
     {
-        DBG_ERROR( "Oups, beim kuerzen einer Fraction hat sich Joe verrechnet." );
+        // Return without reduction
+        DBG_ERROR( "Oops, we reduced too much..." );
         return;
     }
 
-    // Nun noch kuerzen ueber GGT
-    long n1=GetGGT( nMul, nDiv );
-    if ( n1!=1 )
+    // Reduce
+    long n1 = GetGGT( nMul, nDiv );
+    if ( n1 != 1 )
     {
-        nMul/=n1;
-        nDiv/=n1;
+        nMul /= n1;
+        nDiv /= n1;
     }
-    if ( !bNeg )
-        nNumerator = (long)nMul;
-    else
-        nNumerator = -(long)nMul;
+
+    nNumerator = bNeg? -long( nMul ): long( nMul );
     nDenominator = nDiv;
 }
 
