--- tools/source/generic/fract.cxx	2006-09-27 12:50:16.000000000 +0200
+++ tools/source/generic/fract.cxx	2007-06-13 01:59:10.000000000 +0200
@@ -517,7 +517,6 @@ Fraction& Fraction::operator /= ( const 
 |*
 *************************************************************************/
 
-// Funktioniert z.Zt. nur fuer 32-Bit Werte !!!
 // Fehlerbehaftetes Kuerzen einer Fraction.
 // nSignificantBits gibt an, wieviele signifikante Binaerstellen
 // in Zaehler/Nenner mindestens erhalten bleiben sollen.
@@ -528,6 +527,29 @@ Fraction& Fraction::operator /= ( const 
 // = ca.  1.007812499
 // Nach ReduceInaccurate( 8 ) wird daraus 1/1.
 
+static int NumberOfBits( unsigned long nNum )
+{
+    if ( nNum == 0 )
+        return 0;
+
+    // get it to form like 0000001111111111b
+#if SAL_TYPES_SIZEOFLONG == 8
+    nNum |= ( nNum >> 32 );
+#endif
+    nNum |= ( nNum >> 16 );
+    nNum |= ( nNum >>  8 );
+    nNum |= ( nNum >>  4 );
+    nNum |= ( nNum >>  2 );
+
+    // TODO replace with a lookup in a table
+    // (constant algorithm - it's possible ;-))
+    int nCount = 0;
+    for ( ; nNum > 0; ++nCount )
+        nNum >>= 1;
+
+    return nCount;
+}
+
 void Fraction::ReduceInaccurate( unsigned nSignificantBits )
 {
     if ( !nNumerator || !nDenominator )
@@ -536,36 +558,29 @@ void Fraction::ReduceInaccurate( unsigne
     // Zaehler und Nenner auf den Stack fuer schnelleren Zugriff
     unsigned long nMul;
     unsigned long nDiv;
-    BOOL   bNeg;
+    sal_Bool bNeg;
     if ( nNumerator >= 0 )
     {
         nMul = (unsigned long)nNumerator;
-        bNeg = FALSE;
+        bNeg = sal_False;
     }
     else
     {
         nMul = (unsigned long)(-nNumerator);
-        bNeg = TRUE;
+        bNeg = sal_True;
     }
-    nDiv=(unsigned long)nDenominator;
+    nDiv = (unsigned long)nDenominator;
 
-    unsigned long a=nMul; unsigned nMulZ=0; // Fuehrende Nullen zaehlen
-    while (a<0x00800000) { nMulZ+=8; a<<=8; }
-    while (a<0x80000000) { nMulZ++; a<<=1; }
-    a=nDiv; unsigned nDivZ=0; // Fuehrende Nullen zaehlen
-    while (a<0x00800000) { nDivZ+=8; a<<=8; }
-    while (a<0x80000000) { nDivZ++; a<<=1; }
-    // Anzahl der verwendeten Digits bestimmen
-    // Auch hier gehe ich davon aus, dass es sich um 32Bit-Werte handelt
-    int nMulDigits=(sizeof(long) * 8)-nMulZ;
-    int nDivDigits=(sizeof(long) * 8)-nDivZ;
-    // Nun bestimmen, wieviele Stellen hinten weg koennen
-    // Hier koennte man das Ergebnis noch etwas optimieren...
-    int nMulWeg=nMulDigits-nSignificantBits; if (nMulWeg<0) nMulWeg=0;
-    int nDivWeg=nDivDigits-nSignificantBits; if (nDivWeg<0) nDivWeg=0;
-    int nWeg=Min(nMulWeg,nDivWeg);
-    nMul>>=nWeg;
-    nDiv>>=nWeg;
+    // How much bits can we lose?
+    int nMulBitsToLose = Max( ( NumberOfBits( nMul ) - int( nSignificantBits ) ), 0 );
+    int nDivBitsToLose = Max( ( NumberOfBits( nDiv ) - int( nSignificantBits ) ), 0 );
+
+    int nToLose = Min( nMulBitsToLose, nDivBitsToLose );
+
+    // Remove the bits
+    nMul >>= nToLose;
+    nDiv >>= nToLose;
+    
     if ( !nMul || !nDiv )
     {
         DBG_ERROR( "Oups, beim kuerzen einer Fraction hat sich Joe verrechnet." );
@@ -573,12 +588,13 @@ void Fraction::ReduceInaccurate( unsigne
     }
 
     // Nun noch kuerzen ueber GGT
-    long n1=GetGGT( nMul, nDiv );
-    if ( n1!=1 )
+    long n1 = GetGGT( nMul, nDiv );
+    if ( n1 != 1 )
     {
-        nMul/=n1;
-        nDiv/=n1;
+        nMul /= n1;
+        nDiv /= n1;
     }
+
     if ( !bNeg )
         nNumerator = (long)nMul;
     else
