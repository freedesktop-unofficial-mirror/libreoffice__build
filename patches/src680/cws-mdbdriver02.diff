Index: connectivity/source/drivers/mdb/DataAccess.xcu
===================================================================
RCS file: connectivity/source/drivers/mdb/DataAccess.xcu
diff -N connectivity/source/drivers/mdb/DataAccess.xcu
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/DataAccess.xcu	15 Aug 2005 13:52:53 -0000	1.1.4.1
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<oor:node xmlns:oor="http://openoffice.org/2001/registry" xmlns:xs="http://www.w3.org/2001/XMLSchema" oor:name="DataAccess" oor:package="org.openoffice.Office">
+ <node oor:name="UserDefinedDriverSettings">
+       <node oor:name="MDB Driver" oor:op="replace">
+	     <prop oor:name="DriverPageDisplayName">
+		   <value>MDB-SDBC Driver V 0.1</value>
+	     </prop>
+	     <prop oor:name="DriverTypeDisplayName">
+		   <value>mdb</value>
+	     </prop>
+	     <prop oor:name="DriverDsnPrefix">
+		   <value>sdbc:mdb:</value>
+	     </prop>
+       </node>
+ </node>
+</oor:node>
Index: connectivity/source/drivers/mdb/config.h
===================================================================
RCS file: connectivity/source/drivers/mdb/config.h
diff -N connectivity/source/drivers/mdb/config.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/config.h	22 Aug 2005 14:49:49 -0000	1.1.2.1
@@ -0,0 +1 @@
+/* dummy. mdbtools' header includes config.h... Make it happy */
Index: connectivity/source/drivers/mdb/exports.dxp
===================================================================
RCS file: connectivity/source/drivers/mdb/exports.dxp
diff -N connectivity/source/drivers/mdb/exports.dxp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/exports.dxp	15 Aug 2005 13:52:53 -0000	1.1.4.1
@@ -0,0 +1,3 @@
+component_getImplementationEnvironment
+component_writeInfo
+component_getFactory
Index: connectivity/source/drivers/mdb/makefile.mk
===================================================================
RCS file: connectivity/source/drivers/mdb/makefile.mk
diff -N connectivity/source/drivers/mdb/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/makefile.mk	22 Dec 2005 10:43:06 -0000	1.1.4.4
@@ -0,0 +1,159 @@
+#*************************************************************************
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to
+#   the terms of GNU Lesser General Public License Version 2.1.
+# 
+# 
+#     GNU Lesser General Public License Version 2.1
+#     =============================================
+#     Copyright 2005 by Sun Microsystems, Inc.
+#     901 San Antonio Road, Palo Alto, CA 94303, USA
+# 
+#     This library is free software; you can redistribute it and/or
+#     modify it under the terms of the GNU Lesser General Public
+#     License version 2.1, as published by the Free Software Foundation.
+# 
+#     This library is distributed in the hope that it will be useful,
+#     but WITHOUT ANY WARRANTY; without even the implied warranty of
+#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#     Lesser General Public License for more details.
+# 
+#     You should have received a copy of the GNU Lesser General Public
+#     License along with this library; if not, write to the Free Software
+#     Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#     MA  02111-1307  USA
+# 
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): Alexandre Horst
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+PRJINC=..$/..
+PRJNAME=connectivity
+TARGET=mdb
+
+ENABLE_EXCEPTIONS=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+.INCLUDE :  $(PRJ)$/version.mk
+
+PKGCONFIG_MODULES=glib-2.0 
+.INCLUDE : pkg_config.mk
+
+
+MDB_MAJOR=0
+MDB_MINOR=1
+MDB_MICRO=1
+
+# --- Files -------------------------------------
+
+.IF "$(ENABLE_ACCESS)"=="YES"
+
+.IF "$(OS)"=="LINUX"
+LIB2OBJFILES= \
+		$(SLO)$/mdb_wrapper.obj				\
+		$(SLO)$/mdb_connection.obj			\
+		$(SLO)$/mdb_statement.obj			\
+		$(SLO)$/mdb_resultset.obj			\
+		$(SLO)$/mdb_preparedstatement.obj	\
+		$(SLO)$/mdb_resultsetmetadata.obj	\
+		$(SLO)$/mdb_databasemetadata.obj	\
+		$(SLO)$/mdb_sequenceresultset.obj	\
+		$(SLO)$/mdb_baseresultset.obj
+
+LIB1OBJFILES= \
+		$(SLO)$/mdb_driver.obj
+
+
+# --- Library -----------------------------------
+
+CFLAGS+=\
+	-DSQL=1											\
+	-DMDBTOOLS_MAJOR=$(MDB_MAJOR) \
+	-DMDBTOOLS_MINOR=$(MDB_MINOR) \
+	-DMDBTOOLS_MICRO=$(MDB_MICRO) \
+	-DMDB_MAJOR=$(MDB_MAJOR) \
+	-DMDB_MINOR=$(MDB_MINOR) \
+	-DMDB_MICRO=$(MDB_MICRO) \
+	 $(MDBTOOLS_CFLAGS)
+
+CFLAGS+= $(PKGCONFIG_CFLAGS)
+
+.IF "$(SYSTEM_MDBTOOLS)" == "YES"
+CFLAGS+=-DSYSTEM_MDBTOOLS $(MDBTOOLS_CFLAGS)
+.IF "$(LIBICONV)" != ""
+SHL2STDLIBS+=$(LIBICONV)
+.ENDIF
+.ENDIF
+
+SHL1TARGET=$(TARGET)$(UPD)$(DLLPOSTFIX)
+LIB1TARGET=$(SLB)$/$(SHL1TARGET).lib
+SHL1OBJS=$(LIB1OBJFILES)
+SHL1STDLIBS= \
+		$(CPPULIB)			\
+		$(CPPUHELPERLIB)	\
+		$(SALLIB)\
+		$(PKGCONFIG_LIBS) \
+                -lmdbsql \
+                -lmdb
+
+SHL1DEPN=
+SHL1IMPLIB=	i$(TARGET)
+
+SHL1DEF=	$(MISC)$/$(SHL1TARGET).def
+
+DEF1NAME=	$(SHL1TARGET)
+DEF1EXPORTFILE=exports.dxp
+
+
+SHL2TARGET=$(TARGET)impl$(UPD)$(DLLPOSTFIX)
+LIB2TARGET=$(SLB)$/$(SHL2TARGET).lib
+SHL2OBJS=$(LIB2OBJFILES)
+SHL2STDLIBS= \
+		$(CPPULIB)			\
+		$(CPPUHELPERLIB)	\
+		$(SALLIB)			\
+		$(SALHELPERLIB)		\
+		$(VOSLIB)		\
+		$(DBTOOLSLIB)		\
+		$(PKGCONFIG_LIBS)\
+		-lmdbsql \
+		-lmdb
+
+SHL2DEPN=
+SHL2IMPLIB=	i$(TARGET)impl
+
+SHL2DEF=	$(MISC)$/$(SHL2TARGET).def
+
+DEF2NAME=	$(SHL2TARGET)
+DEF2EXPORTFILE=exports.dxp
+
+
+.ENDIF
+
+# --- Targets ----------------------------------
+
+.INCLUDE : target.mk
+
+.ELSE
+
+dummy:
+       @echo "MS Access SDBC driver disabled in configure"
+
+.ENDIF
Index: connectivity/source/drivers/mdb/mdb.xml
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb.xml
diff -N connectivity/source/drivers/mdb/mdb.xml
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb.xml	15 Aug 2005 13:52:56 -0000	1.1.4.1
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE module-description PUBLIC "-//W3C//DTD HTML 3.2//EN" "module-description.dtd">
+<module-description>
+	<module-name>mdb</module-name>
+	<component-description>
+		<author>Wind Li, Alexandre Horst, Luciano Wolf</author>
+		<name>org.openoffice.comp.connectivity.mdb.Driver</name>
+		<description>This library implements the database driver for mdb file format using mdbtools library.
+</description>
+		<loader-name>com.sun.star.loader.SharedLibrary</loader-name>
+		<language>c++</language>
+		<status value="final"/>
+		<supported-service>com.sun.star.sdbc.Connection</supported-service>
+		<supported-service>com.sun.star.sdbc.Driver</supported-service>
+		<service-dependency>	...	</service-dependency>
+	</component-description>
+	<project-build-dependency>cppuhelper</project-build-dependency>
+	<project-build-dependency>cppu</project-build-dependency>
+	<project-build-dependency>sal</project-build-dependency>
+	<project-build-dependency>vos</project-build-dependency>
+	<runtime-module-dependency>file</runtime-module-dependency>
+	<runtime-module-dependency>cppuhelper</runtime-module-dependency>
+	<runtime-module-dependency>cppu</runtime-module-dependency>
+	<runtime-module-dependency>sal</runtime-module-dependency>
+	<runtime-module-dependency>vos</runtime-module-dependency>
+	<runtime-module-dependency>osl</runtime-module-dependency>
+	<runtime-module-dependency>svtools-light1</runtime-module-dependency>
+	<runtime-module-dependency>svtools</runtime-module-dependency>
+	<runtime-module-dependency>ucbhelper</runtime-module-dependency>
+	<runtime-module-dependency>dbtools</runtime-module-dependency>
+	<runtime-module-dependency>unotools</runtime-module-dependency>
+	<runtime-module-dependency>comphelper</runtime-module-dependency>
+</module-description>
Index: connectivity/source/drivers/mdb/mdb_baseresultset.cxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_baseresultset.cxx
diff -N connectivity/source/drivers/mdb/mdb_baseresultset.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_baseresultset.cxx	12 Jul 2006 10:20:32 -0000	1.1.4.3
@@ -0,0 +1,697 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+
+#include <osl/thread.h>
+
+#include <rtl/ustrbuf.hxx>
+
+#include <cppuhelper/typeprovider.hxx>
+#include <cppuhelper/queryinterface.hxx>
+
+#include <connectivity/dbexception.hxx>
+
+#include "mdb_statement.hxx"
+#include "mdb_baseresultset.hxx"
+#include "mdb_resultsetmetadata.hxx"
+
+#include <com/sun/star/lang/DisposedException.hpp>
+
+using osl::Mutex;
+using osl::MutexGuard;
+
+using rtl::OUString;
+using rtl::OUStringToOString;
+using rtl::OUStringBuffer;
+using rtl::OString;
+
+using com::sun::star::beans::XPropertySetInfo;
+using com::sun::star::beans::XPropertySet;
+using com::sun::star::beans::XMultiPropertySet;
+using com::sun::star::beans::XFastPropertySet;
+
+using com::sun::star::uno::Any;
+using com::sun::star::uno::makeAny;
+using com::sun::star::uno::Type;
+using com::sun::star::uno::RuntimeException;
+using com::sun::star::uno::Exception;
+using com::sun::star::uno::Sequence;
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::XInterface;
+
+using com::sun::star::lang::IllegalArgumentException;
+
+using com::sun::star::sdbc::XWarningsSupplier;
+using com::sun::star::sdbc::XCloseable;
+using com::sun::star::sdbc::XStatement;
+using com::sun::star::sdbc::XResultSet;
+using com::sun::star::sdbc::XConnection;
+using com::sun::star::sdbc::SQLException;
+using com::sun::star::sdbc::XRow;
+using com::sun::star::sdbc::XColumnLocate;
+using com::sun::star::sdbc::XResultSetMetaData;
+using com::sun::star::sdbc::XResultSetMetaDataSupplier;
+
+
+using com::sun::star::beans::Property;
+
+namespace mdb_sdbc_driver
+{
+#define ASCII_STR(x) OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+
+static ::cppu::IPropertyArrayHelper & getResultSetPropertyArrayHelper()
+{
+    static ::cppu::IPropertyArrayHelper *pArrayHelper;
+	if( ! pArrayHelper )
+    {
+		MutexGuard guard( Mutex::getGlobalMutex() );
+		if( ! pArrayHelper )
+        {
+            static Property aTable[] =
+                {
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("CursorName") ), 0,
+                        ::getCppuType( (OUString *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("EscapeProcessing") ), 0,
+                        ::getBooleanCppuType() , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("FetchDirection") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("FetchSize") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("ResultSetConcurrency") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("ResultSetType") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 )
+                };
+            OSL_ASSERT( sizeof(aTable) / sizeof(Property) == BASERESULTSET_SIZE );
+			static ::cppu::OPropertyArrayHelper arrayHelper( aTable, BASERESULTSET_SIZE, sal_True );
+            pArrayHelper = &arrayHelper;
+        }
+    }
+    return *pArrayHelper;
+}
+
+BaseResultSet::BaseResultSet(
+    const ::rtl::Reference< RefCountedMutex > & refMutex,
+    const Reference< XInterface > & owner,
+    sal_Int32 rowCount,
+    sal_Int32 colCount,
+    const Reference< com::sun::star::script::XTypeConverter > & tc )
+    : OComponentHelper( refMutex->mutex ),
+      OPropertySetHelper( OComponentHelper::rBHelper ),
+      m_owner( owner ),
+      m_tc( tc ),
+      m_refMutex( refMutex ),
+      m_row( -1 ),
+      m_rowCount( rowCount ),
+      m_fieldCount( colCount ),
+      m_wasNull( false )
+{
+    POSTGRE_TRACE( "ctor BaseResultSet" );
+}
+
+BaseResultSet::~BaseResultSet()
+{
+    POSTGRE_TRACE( "dtor BaseResultSet" );
+}
+
+Any BaseResultSet::queryInterface( const Type & reqType ) throw (RuntimeException)
+{
+    Any ret;
+
+    ret = OComponentHelper::queryInterface( reqType );
+    if( ! ret.hasValue() )
+        ret = ::cppu::queryInterface( reqType,
+                                    static_cast< XResultSet * > ( this  ),
+                                    static_cast< XResultSetMetaDataSupplier * > ( this ),
+                                    static_cast< XRow * > ( this ),
+                                    static_cast< XColumnLocate * > ( this ),
+                                    static_cast< XCloseable * > ( this ),
+                                    static_cast< XPropertySet * > ( this ),
+                                    static_cast< XMultiPropertySet * > ( this ),
+                                    static_cast< XFastPropertySet * > ( this ) );
+    return ret;
+}
+
+// void BaseResultSet::close(  ) throw (SQLException, RuntimeException)
+// {
+//     Reference< XInterface > owner;
+//     {
+//         ResultSetGuard guard(*this);
+//         if( m_result )
+//         {
+//             PQclear(m_result );
+//             m_result = 0;
+//             m_row = -1;
+//         }
+//         owner = m_owner;
+//         m_owner.clear();
+//     }
+// }
+
+Sequence<Type > BaseResultSet::getTypes() throw( RuntimeException )
+{
+    static cppu::OTypeCollection *pCollection;
+    if( ! pCollection )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        if( !pCollection )
+        {
+            static cppu::OTypeCollection collection(
+                getCppuType( (Reference< XResultSet> *) 0 ),
+                getCppuType( (Reference< XResultSetMetaDataSupplier> *) 0 ),
+                getCppuType( (Reference< XRow> *) 0 ),
+                getCppuType( (Reference< XColumnLocate> *) 0 ),
+                getCppuType( (Reference< XCloseable> *) 0 ),
+                getCppuType( (Reference< XPropertySet >*) 0 ),
+                getCppuType( (Reference< XFastPropertySet > *) 0 ),
+                getCppuType( (Reference< XMultiPropertySet > *) 0 ),
+                OComponentHelper::getTypes());
+            pCollection = &collection;
+        }
+    }
+    return pCollection->getTypes();
+}
+
+Sequence< sal_Int8> BaseResultSet::getImplementationId() throw( RuntimeException )
+{
+    static cppu::OImplementationId *pId;
+    if( ! pId )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        if( ! pId )
+        {
+            static cppu::OImplementationId id(sal_False);
+            pId = &id;
+        }
+    }
+    return pId->getImplementationId();
+}
+
+// Reference< XResultSetMetaData > BaseResultSet::getMetaData(  ) throw (SQLException, RuntimeException)
+// {
+//     ResultSetGuard guard(*this);
+//     checkClosed();
+//     return new ResultSetMetaData( m_refMutex, this, &m_result );
+// }
+
+sal_Bool BaseResultSet::next(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    m_row ++;
+    return m_row < m_rowCount;
+}
+
+sal_Bool BaseResultSet::isBeforeFirst(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_row == -1;
+}
+
+sal_Bool BaseResultSet::isAfterLast(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_row >= m_rowCount;
+}
+    
+sal_Bool BaseResultSet::isFirst(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_row == 0 && m_rowCount;
+}
+
+sal_Bool BaseResultSet::isLast(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_row >= 0 && m_row + 1 == m_rowCount;
+}
+
+void BaseResultSet::beforeFirst(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    m_row = -1;
+}
+
+void BaseResultSet::afterLast(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    m_row = m_rowCount;
+}
+
+sal_Bool BaseResultSet::first(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    sal_Bool bRet = ( m_rowCount > 0 );
+    if( bRet )
+        m_row = 0;
+    return bRet;
+}
+
+sal_Bool BaseResultSet::last(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    sal_Bool bRet = ( m_rowCount > 0 );
+    if( bRet )
+        m_row = m_rowCount -1;
+    return bRet;
+}
+
+sal_Int32 BaseResultSet::getRow(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_row +1;
+}
+
+sal_Bool BaseResultSet::absolute( sal_Int32 row ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    if( row > 0 )
+    {
+        m_row = row -1;
+        if( m_row > m_rowCount )
+            m_row = m_rowCount;
+    }
+    else
+    {
+        m_row = m_rowCount + row;
+        if( m_row < -1 )
+            m_row = -1;
+    }
+    return sal_True;
+}
+
+sal_Bool BaseResultSet::relative( sal_Int32 rows ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    m_row += rows;
+
+    if( m_row > m_rowCount )
+        m_row = m_rowCount;
+    else if ( m_row < -1 )
+        m_row = -1;
+    return sal_True;
+}
+
+sal_Bool BaseResultSet::previous(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    sal_Bool bRet = ( m_row != -1 );
+    if( bRet )
+        m_row --;
+    return bRet;
+}
+
+void BaseResultSet::refreshRow(  ) throw (SQLException, RuntimeException)
+{
+    // TODO: not supported for now
+}
+
+sal_Bool BaseResultSet::rowUpdated(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool BaseResultSet::rowInserted(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool BaseResultSet::rowDeleted(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+Reference< XInterface > BaseResultSet::getStatement() throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_owner;
+}
+
+
+//----------------- XRow interface ----------------------------------------------------
+
+sal_Bool BaseResultSet::wasNull(  ) throw (SQLException, RuntimeException)
+{
+    return m_wasNull;
+}
+
+Any BaseResultSet::convertTo( const OUString & str , const Type & type )
+{
+    Any aRet;
+    try
+    {
+        aRet = m_tc->convertTo( makeAny(str), type );
+    }
+    catch( com::sun::star::lang::IllegalArgumentException & e )
+    {}
+    catch( com::sun::star::script::CannotConvertException & e )
+    {}
+    return aRet;
+}
+
+sal_Bool BaseResultSet::getBoolean( sal_Int32 columnIndex ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+
+    OUString str = getValueAsString( columnIndex );
+
+    if( str.getLength() > 0 )
+    {
+        switch(str[0])
+        {
+        case '1':
+        case 't':
+        case 'T':
+        case 'y':
+        case 'Y':
+
+            return sal_True;
+        }
+    }
+    return sal_False;
+}
+
+sal_Int8 BaseResultSet::getByte( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    sal_Int8 b = 0;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &b )) >>= b;
+    return b;
+}
+
+sal_Int16 BaseResultSet::getShort( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    sal_Int16 i = 0;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &i )) >>= i;
+    return i;
+}
+
+OUString BaseResultSet::getString( sal_Int32 columnIndex ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex);
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    OUString ret = getValueAsString(  columnIndex );
+    return ret;
+}
+
+sal_Int32 BaseResultSet::getInt( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    sal_Int32 i = 0;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &i )) >>= i;
+    return i;
+}
+
+sal_Int64 BaseResultSet::getLong( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    sal_Int64 i = 0;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &i )) >>= i;
+    return i;
+}
+
+float BaseResultSet::getFloat( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    float f = 0.;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &f )) >>= f;
+    return f;
+}
+
+double BaseResultSet::getDouble( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    double d = 0.;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &d )) >>= d;
+    return d;
+}
+
+Sequence< sal_Int8 > BaseResultSet::getBytes( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+
+    // is not supported
+//      m_wasNull = PQgetisnull( m_result, m_row, columnIndex -1 );
+//      size_t length;
+//      char * res = (char*) PQunescapeBytea(
+//          (unsigned char*) PQgetvalue( m_result, m_row, columnIndex -1 ), &length);
+//      Sequence< sal_Int8 > ret( (sal_Int8*)res, length );
+//      if( res )
+//          free( res );
+//      return ret;
+    return Sequence< sal_Int8 > ();
+}
+
+::com::sun::star::util::Date BaseResultSet::getDate( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getDate", *this );
+    return com::sun::star::util::Date();
+}
+
+::com::sun::star::util::Time BaseResultSet::getTime( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getTime", *this );
+    return com::sun::star::util::Time();
+}
+
+::com::sun::star::util::DateTime BaseResultSet::getTimestamp( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getTimestamp", *this );
+    return com::sun::star::util::DateTime();
+}
+
+Reference< ::com::sun::star::io::XInputStream > BaseResultSet::getBinaryStream( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getBinaryStream", *this );
+    return 0;
+}
+
+Reference< ::com::sun::star::io::XInputStream > BaseResultSet::getCharacterStream( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getCharacterStream", *this );
+    return 0;
+}
+
+Any BaseResultSet::getObject(
+        sal_Int32 /*columnIndex*/,
+        const Reference< ::com::sun::star::container::XNameAccess >& /*typeMap*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getObject", *this );
+    return Any();
+}
+
+Reference< ::com::sun::star::sdbc::XRef > BaseResultSet::getRef( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getRef", *this );
+    return Reference< com::sun::star::sdbc::XRef > ();
+}
+
+Reference< ::com::sun::star::sdbc::XBlob > BaseResultSet::getBlob( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getBlob", *this );
+    return Reference< com::sun::star::sdbc::XBlob > ();
+}
+
+Reference< ::com::sun::star::sdbc::XClob > BaseResultSet::getClob( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getClob", *this );
+    return Reference< com::sun::star::sdbc::XClob > ();
+}
+
+Reference< ::com::sun::star::sdbc::XArray > BaseResultSet::getArray( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getArray", *this );
+    return NULL;
+}
+
+
+::cppu::IPropertyArrayHelper & BaseResultSet::getInfoHelper()
+{
+    return getResultSetPropertyArrayHelper(); 
+}
+
+
+sal_Bool BaseResultSet::convertFastPropertyValue(
+		Any & /*rConvertedValue*/, Any & /*rOldValue*/, sal_Int32 nHandle, const Any& rValue )
+		throw (IllegalArgumentException)
+{
+    sal_Bool bRet;
+    switch( nHandle )
+    {
+    case BASERESULTSET_CURSOR_NAME:
+    {
+        OUString val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    case BASERESULTSET_ESCAPE_PROCESSING:
+    {
+        sal_Bool val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    case BASERESULTSET_FETCH_DIRECTION:
+    case BASERESULTSET_FETCH_SIZE:
+    case BASERESULTSET_RESULT_SET_CONCURRENCY:
+    case BASERESULTSET_RESULT_SET_TYPE:
+    {
+        sal_Int32 val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    default:
+    {
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_resultset: Invalid property handle (" );
+        buf.append( nHandle );
+        buf.appendAscii( ")" );
+        throw IllegalArgumentException( buf.makeStringAndClear(), *this, 2 );
+    }
+    }
+    return bRet;
+}
+    
+
+void BaseResultSet::setFastPropertyValue_NoBroadcast(
+    sal_Int32 nHandle,const Any& rValue ) throw (Exception)
+{
+    m_props[nHandle] = rValue;
+}
+
+void BaseResultSet::getFastPropertyValue( Any& rValue, sal_Int32 nHandle ) const
+{
+    rValue = m_props[nHandle];
+}
+
+Reference < XPropertySetInfo >  BaseResultSet::getPropertySetInfo()
+        throw(RuntimeException)
+{
+    return OPropertySetHelper::createPropertySetInfo( getResultSetPropertyArrayHelper() );
+}
+
+void BaseResultSet::disposing()
+{
+    close();
+}
+
+void BaseResultSet::checkColumnIndex(sal_Int32 index ) throw ( SQLException, RuntimeException )
+{
+    if( index < 1 || index > m_fieldCount )
+    {
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_resultset: index out of range (" );
+        buf.append( index );
+        buf.appendAscii( ", allowed range is 1 to " );
+        buf.append( m_fieldCount );
+        buf.appendAscii( ")" );
+        throw SQLException( buf.makeStringAndClear(), *this, OUString(), 1, Any() );
+    }
+
+    if( m_row < 0 || m_row >= m_rowCount )
+    {
+        OUStringBuffer buf( 128 );
+        buf.appendAscii( "mdb_resultset: row index out of range, allowed is 1 to " );
+        buf.append( m_rowCount );
+        buf.appendAscii( ", got " );
+        buf.append( index );
+        throw SQLException( buf.makeStringAndClear(), *this, OUString(),1, Any() );
+    }
+}
+
+
+}
Index: connectivity/source/drivers/mdb/mdb_baseresultset.hxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_baseresultset.hxx
diff -N connectivity/source/drivers/mdb/mdb_baseresultset.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_baseresultset.hxx	12 Dec 2005 10:02:29 -0000	1.1.4.2
@@ -0,0 +1,248 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+
+#ifndef _PG_BASERESULTSET_HXX_
+#define _PG_BASERESULTSET_HXX_
+
+#include <cppuhelper/propshlp.hxx>
+#include <cppuhelper/component.hxx>
+
+#include <com/sun/star/sdbc/XResultSetMetaDataSupplier.hpp>
+#include <com/sun/star/sdbc/XRow.hpp>
+#include <com/sun/star/sdbc/XCloseable.hpp>
+#include <com/sun/star/sdbc/XColumnLocate.hpp>
+#include "mdb_connection.hxx"
+
+namespace mdb_sdbc_driver
+{
+
+static const sal_Int32 BASERESULTSET_CURSOR_NAME = 0;
+static const sal_Int32 BASERESULTSET_ESCAPE_PROCESSING = 1;
+static const sal_Int32 BASERESULTSET_FETCH_DIRECTION = 2;
+static const sal_Int32 BASERESULTSET_FETCH_SIZE = 3;
+static const sal_Int32 BASERESULTSET_RESULT_SET_CONCURRENCY = 4;
+static const sal_Int32 BASERESULTSET_RESULT_SET_TYPE = 5;
+
+#define BASERESULTSET_SIZE 6
+
+class BaseResultSet : public cppu::OComponentHelper,
+                      public cppu::OPropertySetHelper,
+                      public com::sun::star::sdbc::XCloseable,
+                      public com::sun::star::sdbc::XResultSetMetaDataSupplier,
+                      public com::sun::star::sdbc::XResultSet,
+                      public com::sun::star::sdbc::XRow,
+                      public com::sun::star::sdbc::XColumnLocate
+{
+protected:
+    com::sun::star::uno::Any m_props[BASERESULTSET_SIZE];
+    com::sun::star::uno::Reference< com::sun::star::uno::XInterface > m_owner;
+    com::sun::star::uno::Reference< com::sun::star::script::XTypeConverter > m_tc;
+    ::rtl::Reference< RefCountedMutex > m_refMutex;
+    sal_Int32 m_row;
+    sal_Int32 m_rowCount;
+    sal_Int32 m_fieldCount;
+    sal_Bool  m_wasNull;
+
+public:
+    inline cppu::OBroadcastHelper & getRBHelper() { return OComponentHelper::rBHelper;}
+    
+protected:
+    /** mutex should be locked before called
+     */
+    virtual void checkClosed()
+        throw ( com::sun::star::sdbc::SQLException, com::sun::star::uno::RuntimeException ) = 0;
+    virtual void checkColumnIndex( sal_Int32 index )
+        throw ( com::sun::star::sdbc::SQLException, com::sun::star::uno::RuntimeException );
+        
+    virtual ::rtl::OUString getValueAsString( sal_Int32 columnIndex ) = 0;
+    com::sun::star::uno::Any convertTo(
+        const ::rtl::OUString &str, const com::sun::star::uno::Type &type );
+
+protected:
+    BaseResultSet(
+        const ::rtl::Reference< RefCountedMutex > & mutex,
+        const com::sun::star::uno::Reference< com::sun::star::uno::XInterface > &owner,
+        sal_Int32 rowCount,
+        sal_Int32 columnCount,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::script::XTypeConverter > &tc );
+    ~BaseResultSet();
+    
+public: // XInterface
+    virtual void SAL_CALL acquire() throw() { OComponentHelper::acquire(); }
+    virtual void SAL_CALL release() throw() { OComponentHelper::release(); }
+    virtual com::sun::star::uno::Any  SAL_CALL queryInterface(
+        const com::sun::star::uno::Type & reqType )
+        throw (com::sun::star::uno::RuntimeException);
+
+public: // XCloseable
+    virtual void SAL_CALL close(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException) = 0;
+
+public: // XTypeProvider, first implemented by OPropertySetHelper
+    virtual com::sun::star::uno::Sequence< com::sun::star::uno::Type > SAL_CALL getTypes()
+        throw( com::sun::star::uno::RuntimeException );
+    virtual com::sun::star::uno::Sequence< sal_Int8> SAL_CALL getImplementationId()
+        throw( com::sun::star::uno::RuntimeException );
+
+public: // XResultSetMetaDataSupplier
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSetMetaData > SAL_CALL getMetaData(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException) = 0;
+
+public: // XResultSet
+    // Methods
+    virtual sal_Bool SAL_CALL next(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isBeforeFirst(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isAfterLast(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isFirst(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isLast(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL beforeFirst(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL afterLast(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL first(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL last(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getRow(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL absolute( sal_Int32 row )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL relative( sal_Int32 rows )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL previous(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL refreshRow(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL rowUpdated(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL rowInserted(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL rowDeleted(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL getStatement()
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+
+public: // XRow
+    virtual sal_Bool SAL_CALL wasNull(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getString( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getBoolean( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int8 SAL_CALL getByte( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int16 SAL_CALL getShort( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getInt( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int64 SAL_CALL getLong( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual float SAL_CALL getFloat( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual double SAL_CALL getDouble( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL getBytes( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::util::Date SAL_CALL getDate( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::util::Time SAL_CALL getTime( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::util::DateTime SAL_CALL getTimestamp( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream > SAL_CALL getBinaryStream( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream > SAL_CALL getCharacterStream( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Any SAL_CALL getObject(
+        sal_Int32 columnIndex,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::container::XNameAccess >& typeMap )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XRef > SAL_CALL getRef( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XBlob > SAL_CALL getBlob( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XClob > SAL_CALL getClob( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XArray > SAL_CALL getArray( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+public: // XColumnLocate
+    virtual sal_Int32 SAL_CALL findColumn( const ::rtl::OUString& columnName )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException) = 0;
+    
+public: // OPropertySetHelper    
+	virtual cppu::IPropertyArrayHelper & SAL_CALL getInfoHelper();
+
+	virtual sal_Bool SAL_CALL convertFastPropertyValue(
+		::com::sun::star::uno::Any & rConvertedValue,
+		::com::sun::star::uno::Any & rOldValue,
+		sal_Int32 nHandle,
+		const ::com::sun::star::uno::Any& rValue )
+		throw (::com::sun::star::lang::IllegalArgumentException);
+    
+	virtual void SAL_CALL setFastPropertyValue_NoBroadcast(
+		sal_Int32 nHandle,
+		const ::com::sun::star::uno::Any& rValue )
+		throw (::com::sun::star::uno::Exception);
+
+	virtual void SAL_CALL getFastPropertyValue(
+		::com::sun::star::uno::Any& rValue,
+		sal_Int32 nHandle ) const;
+
+	// XPropertySet
+	::com::sun::star::uno::Reference < ::com::sun::star::beans::XPropertySetInfo >  SAL_CALL getPropertySetInfo()
+        throw(com::sun::star::uno::RuntimeException);
+
+public: // OComponentHelper
+    virtual void SAL_CALL disposing();
+
+    
+};
+                  
+}
+#endif
Index: connectivity/source/drivers/mdb/mdb_connection.cxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_connection.cxx
diff -N connectivity/source/drivers/mdb/mdb_connection.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_connection.cxx	12 Jul 2006 10:20:32 -0000	1.1.4.3
@@ -0,0 +1,479 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+
+#include <list>
+#include <string.h>
+
+#include "mdb_connection.hxx"
+#include "mdb_statement.hxx"
+#include "mdb_preparedstatement.hxx"
+#include "mdb_databasemetadata.hxx"
+
+#include <rtl/ustrbuf.hxx>
+#include <rtl/strbuf.hxx>
+#include <rtl/uuid.h>
+
+#include <cppuhelper/implementationentry.hxx>
+#include <cppuhelper/implbase1.hxx>
+
+#include <connectivity/dbexception.hxx>
+
+#include <com/sun/star/beans/PropertyValue.hpp>
+
+using rtl::OUStringBuffer;
+using rtl::OUString;
+using rtl::OString;
+using rtl::OStringBuffer;
+using rtl::OUStringToOString;
+using osl::MutexGuard;
+
+using com::sun::star::container::XNameAccess;
+
+using com::sun::star::lang::XComponent;
+using com::sun::star::lang::XInitialization;
+using com::sun::star::lang::IllegalArgumentException;
+
+using com::sun::star::script::XTypeConverter;
+
+using com::sun::star::uno::RuntimeException;
+using com::sun::star::uno::Exception;
+using com::sun::star::uno::Sequence;
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::XInterface;
+using com::sun::star::uno::UNO_QUERY;
+using com::sun::star::uno::XComponentContext;
+using com::sun::star::uno::Any;
+
+using com::sun::star::beans::PropertyValue;
+
+using com::sun::star::sdbc::XConnection;
+using com::sun::star::sdbc::XCloseable;
+using com::sun::star::sdbc::SQLException;
+using com::sun::star::sdbc::XWarningsSupplier;
+using com::sun::star::sdbc::XPreparedStatement;
+using com::sun::star::sdbc::XStatement;
+using com::sun::star::sdbc::XDatabaseMetaData;
+
+namespace mdb_sdbc_driver
+{
+
+#define ASCII_STR(x) OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+
+
+// ______________________________________________________________________________
+// Helper class for statement lifetime management
+class ClosableReference : public cppu::WeakImplHelper1< com::sun::star::uno::XReference >
+{
+    Connection *m_conn;
+    ::rtl::ByteSequence m_id;
+public:
+    ClosableReference( const ::rtl::ByteSequence & id , Connection *that )
+        : m_conn( that ), m_id( id )
+    {
+        that->acquire();
+    }
+    
+    virtual ~ClosableReference()
+    {
+        if( m_conn )
+            m_conn->release();
+    }
+        
+    virtual void SAL_CALL dispose() throw ()
+    {
+        if( m_conn )
+        {
+            m_conn->removeFromWeakMap(m_id);
+            m_conn->release();
+            m_conn = 0;
+        }
+    }
+};
+
+OUString 	ConnectionGetImplementationName()
+{
+    return OUString( RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.comp.connectivity.mdb.Connection" ) );
+}
+com::sun::star::uno::Sequence<rtl::OUString> ConnectionGetSupportedServiceNames(void)
+{
+    OUString serv( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.sdbc.Connection" ) );
+    return Sequence< OUString> (&serv,1);
+}
+
+Connection::~Connection()
+{
+    POSTGRE_TRACE( "dtor connection" );
+    if( m_settings.pConnection )
+    {
+        //PQfinish( m_settings.pConnection );
+        m_settings.pConnection = 0;
+    }
+}
+typedef ::std::list< ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XCloseable > > CloseableList;
+
+void Connection::close() throw ( SQLException, RuntimeException )
+{
+    CloseableList lst;
+
+    {
+        MutexGuard guard( m_refMutex->mutex );
+        // silently ignore, if the connection has been closed already
+        if( m_settings.pConnection )
+        {
+            //PQfinish( m_settings.pConnection );
+            m_settings.pConnection = 0;
+        }
+
+        for( WeakHashMap::iterator ii = m_myStatements.begin() ;
+             ii != m_myStatements.end() ;
+             ++ii )
+        {
+            Reference< XCloseable > r = ii->second;
+            if( r.is() )
+                lst.push_back( r );
+        }
+    }
+
+    // close all created statements 
+    for( CloseableList::iterator ii = lst.begin(); ii != lst.end() ; ++ii )
+        ii->get()->close();
+}
+
+
+void Connection::removeFromWeakMap( const ::rtl::ByteSequence & id )
+{
+    // shrink the list !
+    MutexGuard guard( m_refMutex->mutex );
+    WeakHashMap::iterator ii = m_myStatements.find( id );
+    if( ii != m_myStatements.end() )
+        m_myStatements.erase( ii );
+}
+
+Reference< XStatement > Connection::createStatement(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+
+    Statement *stmt = new Statement( m_refMutex, this , &m_settings );
+    Reference< XStatement > ret( stmt );
+    ::rtl::ByteSequence id( 16 );
+    rtl_createUuid( (sal_uInt8*) id.getConstArray(), 0 , sal_False );
+    m_myStatements[ id ] = Reference< XCloseable > ( stmt );
+    stmt->queryAdapter()->addReference( new ClosableReference( id, this ) );
+    return ret;
+}
+
+Reference< XPreparedStatement > Connection::prepareStatement( const ::rtl::OUString& sql )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+
+    rtl::OString byteSql = OUStringToOString( sql, RTL_TEXTENCODING_UTF8 );
+    PreparedStatement *stmt = new PreparedStatement( m_refMutex, this, &m_settings, byteSql );
+    Reference< XPreparedStatement > ret = stmt;
+    
+    ::rtl::ByteSequence id( 16 );
+    rtl_createUuid( (sal_uInt8*) id.getConstArray(), 0 , sal_False );
+    m_myStatements[ id ] = Reference< XCloseable > ( stmt );
+    stmt->queryAdapter()->addReference( new ClosableReference( id, this ) );
+    return ret;
+}
+
+Reference< XPreparedStatement > Connection::prepareCall( const ::rtl::OUString& /*sql*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XConnection::prepareCall", *this );
+    return NULL;
+}
+
+
+::rtl::OUString Connection::nativeSQL( const ::rtl::OUString& sql )
+        throw (SQLException, RuntimeException)
+{
+    return sql;
+}
+
+void Connection::setAutoCommit( sal_Bool /*autoCommit*/ ) throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XConnection::setAutoCommit", *this );
+    // UNSUPPORTED
+}
+
+sal_Bool Connection::getAutoCommit(  ) throw (SQLException, RuntimeException)
+{
+    // UNSUPPORTED
+    return sal_True;
+}
+
+void Connection::commit(  ) throw (SQLException, RuntimeException)
+{
+    // UNSUPPORTED
+}
+
+void Connection::rollback(  ) throw (SQLException, RuntimeException)
+{
+    // UNSUPPORTED    
+}
+
+sal_Bool Connection::isClosed(  ) throw (SQLException, RuntimeException)
+{
+    return m_settings.pConnection == 0;
+}
+
+Reference< XDatabaseMetaData > Connection::getMetaData(  )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new DatabaseMetaData( m_refMutex, this, &m_settings );
+}
+
+void  Connection::setReadOnly( sal_Bool /*readOnly*/ ) throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XConnection::setReadOnly", *this );
+    // UNSUPPORTED
+
+}
+
+sal_Bool Connection::isReadOnly(  ) throw (SQLException, RuntimeException)
+{
+    // UNSUPPORTED
+    return sal_False;
+}
+
+void Connection::setCatalog( const ::rtl::OUString& /*catalog*/ )
+        throw (SQLException, RuntimeException)
+{
+    // UNSUPPORTED
+}
+
+::rtl::OUString Connection::getCatalog(  ) throw (SQLException, RuntimeException)
+{
+    OUString ret;
+    MutexGuard ( m_refMutex->mutex );
+    if( m_settings.pConnection == 0 )
+    {
+        throw SQLException( ASCII_STR( "mdb_connection: connection is closed" ), *this,
+                            OUString(), 1, Any() );
+    }
+    char * p = 0;//PQdb(m_settings.pConnection );
+    return OUString( p, strlen(p) ,  m_settings.encoding );
+}
+
+void Connection::setTransactionIsolation( sal_Int32 /*level*/ )
+        throw (SQLException, RuntimeException)
+{
+    // UNSUPPORTED
+}
+
+sal_Int32 Connection::getTransactionIsolation(  ) throw (SQLException, RuntimeException)
+{
+    // UNSUPPORTED
+    return 0;
+}
+
+Reference< XNameAccess > Connection::getTypeMap(  ) throw (SQLException, RuntimeException)
+{
+    Reference< XNameAccess > t;
+    {
+        MutexGuard guard( m_refMutex->mutex );
+        t = m_typeMap;
+    }
+    return t;
+}
+
+void Connection::setTypeMap( const Reference< XNameAccess >& typeMap )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    m_typeMap = typeMap;
+}
+Any Connection::getWarnings(  ) throw (SQLException, RuntimeException)
+{
+    return Any();
+}
+
+void Connection::clearWarnings(  ) throw (SQLException, RuntimeException)
+{
+}
+
+
+void Connection::initialize( const Sequence< Any >& aArguments )
+        throw (Exception, RuntimeException)
+{
+	int i=0;
+	if(i)
+	{
+		return ;
+	}
+    OUString url;
+    Sequence< PropertyValue > args;
+
+    Reference< XTypeConverter > tc( m_ctx->getServiceManager()->createInstanceWithContext(
+        OUString( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.script.Converter" ) ), m_ctx ),
+                                    UNO_QUERY);
+    if( ! tc.is() )
+    {
+        throw RuntimeException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("mdb_driver: Couldn't instantiate converter service" )),
+            Reference< XInterface > () );
+    }
+    if( aArguments.getLength() != 2 )
+    {
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_driver: expected 2 arguments, got " );
+        buf.append( aArguments.getLength( ) );
+        throw IllegalArgumentException(buf.makeStringAndClear(), Reference< XInterface > () , 0 );
+    }
+
+    if( ! (aArguments[0] >>= url) )
+    {
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_driver: expected string as first argument, got " );
+        buf.append( aArguments[0].getValueType().getTypeName() );
+        throw IllegalArgumentException( buf.makeStringAndClear() , *this, 0 );
+    }
+
+    tc->convertTo( aArguments[1], getCppuType( &args ) ) >>= args;
+
+    OString o;
+    int nColon = url.indexOf( ':' );
+    if( nColon != -1 )
+    {
+        nColon = url.indexOf( ':' , 1+ nColon );
+        if( nColon != -1 )
+        {
+             o = OUStringToOString( url.getStr()+nColon+1, RTL_TEXTENCODING_UTF8);
+        }
+    }
+    char *test1 = strdup(o.getStr());
+    m_settings.pConnection = OpenMDB(test1);
+    if( ! m_settings.pConnection )
+        throw RuntimeException( OUString( RTL_CONSTASCII_USTRINGPARAM( "mdb_driver: out of memory" ) ),
+                                Reference< XInterface > () );
+    if( !m_settings.pConnection  )
+    {
+        OUStringBuffer buf( 128 );
+
+//        const char * error = PQerrorMessage( m_settings.pConnection );
+//        OUString errorMessage( error, strlen( error) , RTL_TEXTENCODING_ASCII_US );
+        buf.appendAscii( "Couldn't establish database connection to '" );
+        buf.append( url );
+        buf.appendAscii( "' (" );
+//        buf.append( errorMessage );
+        buf.appendAscii( ")" );
+//        PQfinish( m_settings.pConnection );
+        m_settings.pConnection = 0;
+//        throw SQLException( buf.makeStringAndClear(), *this, errorMessage, CONNECTION_BAD, Any() );
+    }
+//    PQsetClientEncoding( m_settings.pConnection, "UNICODE" );
+    //char *p = 0;//PQuser( m_settings.pConnection );
+    //m_settings.user = OUString( p, strlen(p), RTL_TEXTENCODING_UTF8);
+//    p = PQdb( m_settings.pConnection );
+    //m_settings.catalog = OUString( p, strlen(p), RTL_TEXTENCODING_UTF8); 
+    m_settings.tc = tc;
+	free(test1);
+}
+
+void Connection::disposing()
+{
+    close();
+}
+
+void Connection::checkClosed() throw ( SQLException, RuntimeException )
+{
+    if( !m_settings.pConnection )
+        throw SQLException( ASCII_STR( "mdb_connection: Connection already closed" ),
+                            *this, OUString(), 1, Any() );
+}
+
+Reference< XInterface >  ConnectionCreateInstance(
+    const Reference< XComponentContext > & ctx ) throw (Exception)
+{
+    ::rtl::Reference< RefCountedMutex > ref = new RefCountedMutex();
+    return * new Connection( ref, ctx );
+}
+
+
+}
+
+
+
+
+
+
+static struct cppu::ImplementationEntry g_entries[] =
+{
+	{
+		mdb_sdbc_driver::ConnectionCreateInstance, mdb_sdbc_driver::ConnectionGetImplementationName,
+		mdb_sdbc_driver::ConnectionGetSupportedServiceNames, cppu::createSingleComponentFactory,
+		0 , 0
+	},
+	{ 0, 0, 0, 0, 0, 0 }
+};
+
+
+extern "C"
+{
+
+//==================================================================================================
+void SAL_CALL component_getImplementationEnvironment(
+	const sal_Char ** ppEnvTypeName, uno_Environment ** /*ppEnv*/ )
+{
+	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+}
+//==================================================================================================
+sal_Bool SAL_CALL component_writeInfo(
+	void * pServiceManager, void * pRegistryKey )
+{
+	return cppu::component_writeInfoHelper( pServiceManager, pRegistryKey, g_entries );
+}
+//==================================================================================================
+void * SAL_CALL component_getFactory(
+	const sal_Char * pImplName, void * pServiceManager, void * pRegistryKey )
+{
+	return cppu::component_getFactoryHelper( pImplName, pServiceManager, pRegistryKey , g_entries );
+}
+
+}
+
Index: connectivity/source/drivers/mdb/mdb_connection.hxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_connection.hxx
diff -N connectivity/source/drivers/mdb/mdb_connection.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_connection.hxx	12 Jul 2006 10:20:33 -0000	1.1.4.3
@@ -0,0 +1,201 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+
+#ifndef _MDB_CONNECTION_HXX_
+#define _MDB_CONNECTION_HXX_
+#include <hash_map>
+#include <com/sun/star/uno/XComponentContext.hpp>
+
+#include <com/sun/star/lang/XInitialization.hpp>
+
+#include <com/sun/star/script/XTypeConverter.hpp>
+
+#include <com/sun/star/sdbc/XWarningsSupplier.hpp>
+#include <com/sun/star/sdbc/XConnection.hpp>
+
+#include <rtl/ref.hxx>
+#include <rtl/byteseq.hxx>
+
+#include <salhelper/simplereferenceobject.hxx>
+
+#include <cppuhelper/weakref.hxx>
+#include <cppuhelper/compbase3.hxx>
+
+#include <mdb_wrapper.hxx>
+
+namespace mdb_sdbc_driver
+{
+#ifdef POSTGRE_TRACE
+#define POSTGRE_TRACE( x ) printf( "%s\n" , x )
+#define POSTGRE_TRACE_1( x ,y) printf( "%s %s\n" , x ,y )
+#else
+#define POSTGRE_TRACE(x) ((void)0)
+#define POSTGRE_TRACE_1(x,y) ((void)0)
+#endif
+
+class RefCountedMutex : public salhelper::SimpleReferenceObject
+{
+public:
+    osl::Mutex mutex;
+};
+
+struct ConnectionSettings
+{
+    rtl_TextEncoding encoding;
+    ::MdbHandle *pConnection;
+    //::rtl::OString pConnection;
+    ::com::sun::star::uno::Reference< com::sun::star::script::XTypeConverter > tc;
+    ::rtl::OUString user;
+    ::rtl::OUString catalog;
+};
+
+typedef cppu::WeakComponentImplHelper3<
+    com::sun::star::sdbc::XConnection,
+    com::sun::star::sdbc::XWarningsSupplier,
+    com::sun::star::lang::XInitialization > ConnectionBase;
+
+struct HashByteSequence
+{
+    sal_Int32 operator () ( const ::rtl::ByteSequence & seq ) const
+    {
+        return *(sal_Int32*) seq.getConstArray();
+    }
+};
+
+typedef ::std::hash_map<
+    ::rtl::ByteSequence,
+    ::com::sun::star::uno::WeakReference< com::sun::star::sdbc::XCloseable >,
+    HashByteSequence,
+    ::std::equal_to< ::rtl::ByteSequence >
+> WeakHashMap;
+
+class Connection : public ConnectionBase
+{
+    ::com::sun::star::uno::Reference< com::sun::star::uno::XComponentContext > m_ctx;
+    ::com::sun::star::uno::Reference< com::sun::star::container::XNameAccess > m_typeMap;
+    ConnectionSettings m_settings;
+    ::rtl::Reference< RefCountedMutex > m_refMutex;
+    WeakHashMap m_myStatements;
+    
+private:
+    void checkClosed()
+        throw ( com::sun::star::sdbc::SQLException, com::sun::star::uno::RuntimeException );
+    
+public:
+    Connection(
+        const rtl::Reference< RefCountedMutex > &refMutex,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XComponentContext > & ctx )
+        : ConnectionBase( refMutex->mutex ), m_ctx( ctx ) , m_refMutex( refMutex )
+    {
+        m_settings.encoding = RTL_TEXTENCODING_UTF8;
+        m_settings.pConnection = 0;
+    }
+
+    ~Connection( );
+
+public: // XCloseable
+    virtual void SAL_CALL close()
+        throw ( ::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException );
+    
+public: // XConnection
+    
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XStatement > SAL_CALL createStatement(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException) ;
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XPreparedStatement > SAL_CALL prepareStatement(
+        const ::rtl::OUString& sql )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XPreparedStatement > SAL_CALL prepareCall(
+        const ::rtl::OUString& sql )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL nativeSQL( const ::rtl::OUString& sql )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setAutoCommit( sal_Bool autoCommit )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getAutoCommit(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL commit(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL rollback(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isClosed(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< com::sun::star::sdbc::XDatabaseMetaData > SAL_CALL getMetaData(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setReadOnly( sal_Bool readOnly )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isReadOnly(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setCatalog( const ::rtl::OUString& catalog )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getCatalog(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setTransactionIsolation( sal_Int32 level )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getTransactionIsolation(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< com::sun::star::container::XNameAccess > SAL_CALL getTypeMap(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setTypeMap(
+        const ::com::sun::star::uno::Reference< com::sun::star::container::XNameAccess >& typeMap )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    
+public: // XWarningsSupplier
+    virtual ::com::sun::star::uno::Any SAL_CALL getWarnings(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL clearWarnings(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+public: // XInitialization
+    virtual void SAL_CALL initialize(
+        const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aArguments )
+        throw (com::sun::star::uno::Exception, ::com::sun::star::uno::RuntimeException);
+
+public: 
+    virtual void SAL_CALL disposing();
+
+    
+public: // helper function
+    void removeFromWeakMap( const ::rtl::ByteSequence & seq );
+};
+
+}
+#endif
Index: connectivity/source/drivers/mdb/mdb_databasemetadata.cxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_databasemetadata.cxx
diff -N connectivity/source/drivers/mdb/mdb_databasemetadata.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_databasemetadata.cxx	12 Jul 2006 10:20:33 -0000	1.1.4.3
@@ -0,0 +1,1304 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+#include <hash_map>
+
+#include "mdb_databasemetadata.hxx"
+#include "mdb_driver.hxx"
+#include "mdb_sequenceresultset.hxx"
+
+#include "FDatabaseMetaDataResultSet.hxx"
+
+#include<com/sun/star/sdbc/TransactionIsolation.hpp>
+#include<com/sun/star/sdbc/ResultSetType.hpp>
+#include<com/sun/star/sdbc/XPreparedStatement.hpp>
+#include<com/sun/star/sdbc/XParameters.hpp>
+#include<com/sun/star/sdbc/DataType.hpp>
+#include<com/sun/star/sdbc/ColumnValue.hpp>
+
+using ::osl::MutexGuard;
+
+using ::rtl::OUString;
+
+using com::sun::star::sdbc::SQLException;
+using com::sun::star::sdbc::XStatement;
+using com::sun::star::sdbc::XResultSet;
+using com::sun::star::sdbc::XRow;
+using com::sun::star::sdbc::XCloseable;
+using com::sun::star::sdbc::XParameters;
+using com::sun::star::sdbc::XPreparedStatement;
+
+using com::sun::star::uno::RuntimeException;
+using com::sun::star::uno::Sequence;
+
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::Sequence;
+using com::sun::star::uno::Any;
+using com::sun::star::uno::makeAny;
+using com::sun::star::uno::UNO_QUERY;
+
+using connectivity::ODatabaseMetaDataResultSet;
+
+namespace mdb_sdbc_driver
+{
+
+#define ASCII_STR(x) OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+
+static const int MAX_COLUMNS_IN_GROUPBY = 16;
+static const int MAX_COLUMNS_IN_INDEX = 32;
+static const int MAX_COLUMNS_IN_ORDER_BY = 16;
+static const int MAX_COLUMNS_IN_SELECT = 1024;
+static const int MAX_IDENTIFIER_LENGTH = 63;
+static const int MAX_COLUMNS_IN_TABLE = 1024;
+static const int MAX_CONNECTIONS = 0xffff;
+static const int MAX_STATEMENTS = 0xffff;
+static const int MAX_STATEMENT_LENGTH = -1;
+static const int MAX_TABLES_IN_SELECT = 0xffff;
+static const int MAX_USER_NAME_LENGTH = MAX_IDENTIFIER_LENGTH;
+
+
+// alphabetically ordered !
+static const int PRIVILEGE_CREATE     = 0x1;  
+static const int PRIVILEGE_DELETE     = 0x2;  
+static const int PRIVILEGE_EXECUTE    = 0x4;  
+static const int PRIVILEGE_INSERT     = 0x8;  
+static const int PRIVILEGE_REFERENCES = 0x10; 
+static const int PRIVILEGE_RULE       = 0x20; 
+static const int PRIVILEGE_SELECT     = 0x40; 
+static const int PRIVILEGE_TEMPORARY  = 0x80; 
+static const int PRIVILEGE_TRIGGER    = 0x100;
+static const int PRIVILEGE_UPDATE     = 0x200;
+static const int PRIVILEGE_USAGE      = 0x400;
+static const int PRIVILEGE_MAX = PRIVILEGE_USAGE;
+
+typedef ::std::hash_map
+<
+   OUString,
+   sal_Int32,
+   rtl::OUStringHash,
+   ::std::equal_to< OUString >
+> BaseTypeMap;
+
+typedef std::vector< Sequence< Any > > AnyVector;
+
+struct Strings
+{
+    OUString SYSTEM_TABLE;
+    OUString TABLE;
+    OUString VIEW;
+    OUString UNKNOWN;
+    OUString YES;
+    OUString NO;
+    OUString NO_NULLS;
+    OUString NULABLE;
+    OUString NULLABLE_UNKNOWN;
+    OUString SELECT;
+    OUString UPDATE;
+    OUString INSERT;
+    OUString DELETE;
+    OUString RULE;
+    OUString REFERENCES;
+    OUString TRIGGER;
+    OUString EXECUTE;
+    OUString USAGE;
+    OUString CREATE;
+    OUString TEMPORARY;
+    
+    Sequence< OUString > tablesRowNames;
+    Sequence< OUString > columnRowNames;
+    Sequence< OUString > primaryKeyNames;
+    Sequence< OUString > tablePrivilegesNames;
+    Sequence< OUString > schemaNames;
+    Sequence< OUString > tableTypeNames;
+    Sequence< Sequence< Any > > tableTypeData;
+    
+    BaseTypeMap baseTypeMap;
+};
+
+
+struct BaseTypeDef { const char * typeName; sal_Int32 value; };
+
+static Sequence< OUString > createStringSequence( const char * name[] , int length )
+{
+    Sequence< OUString > seq( length );
+    for( int i = 0; i < length; i ++ )
+    {
+        seq[i] = OUString( name[i] , strlen( name[i] ), RTL_TEXTENCODING_ASCII_US );
+    }
+    return seq;
+}
+const char * typeInfoColumn[] =
+{
+    "TYPE_NAME", "DATA_TYPE", "PRECISION", "LITERAL_PREFIX",
+    "LITERAL_SUFFIX", "CREATE_PARAMS", "NULLABLE", "CASE_SENSITIVE",
+    "SEARCHABLE", "UNSIGNED_ATTRIBUTE", "FIXED_PREC_SCALE", "AUTO_INCREMENT",
+    "LOCAL_TYPE_NAME", "MINIMUM_SCALE", "MAXIMUM_SCALE", "SQL_DATA_TYPE",
+    "SQL_DATETIME_SUB", "NUM_PREC_RADIX"
+};
+
+static Strings & sp()
+{
+    static Strings * p;
+    if( ! p )
+    {
+        ::osl::MutexGuard guard( ::osl::Mutex::getGlobalMutex() );
+        if( ! p )
+        {
+            static Strings statStrings;
+            statStrings.SYSTEM_TABLE = ASCII_STR( "SYSTEM_TABLE" );
+            statStrings.TABLE = ASCII_STR( "TABLE" );
+            statStrings.VIEW = ASCII_STR( "VIEW" );
+            statStrings.UNKNOWN = ASCII_STR( "UNKNOWN" );
+            statStrings.YES = ASCII_STR( "YES" );
+            statStrings.NO = ASCII_STR( "NO" );
+            statStrings.NO_NULLS = ASCII_STR( "NO_NULLS" );
+            statStrings.NULABLE = ASCII_STR( "NULABLE" );
+            statStrings.NULLABLE_UNKNOWN = ASCII_STR( "NULLABLE_UNKNOWN" );
+
+            statStrings.tablesRowNames = Sequence< OUString > ( 5 );
+            statStrings.tablesRowNames[0] = ASCII_STR( "TABLE_CAT" );
+            statStrings.tablesRowNames[1] = ASCII_STR( "TABLE_SCHEM" );
+            statStrings.tablesRowNames[2] = ASCII_STR( "TABLE_NAME" );
+            statStrings.tablesRowNames[3] = ASCII_STR( "TABLE_TYPE" );
+            statStrings.tablesRowNames[4] = ASCII_STR( "REMARKS" );
+
+            statStrings.primaryKeyNames = Sequence< OUString > ( 6 );
+            statStrings.primaryKeyNames[0] = ASCII_STR( "TABLE_CAT" );
+            statStrings.primaryKeyNames[1] = ASCII_STR( "TABLE_SCHEM" );
+            statStrings.primaryKeyNames[2] = ASCII_STR( "TABLE_NAME" );
+            statStrings.primaryKeyNames[3] = ASCII_STR( "COLUMN_NAME" );
+            statStrings.primaryKeyNames[4] = ASCII_STR( "KEY_SEQ" );
+            statStrings.primaryKeyNames[5] = ASCII_STR( "PK_NAME" );
+
+            statStrings.SELECT = ASCII_STR( "SELECT" );
+            statStrings.UPDATE = ASCII_STR( "UPDATE" );
+            statStrings.INSERT = ASCII_STR( "INSERT" );
+            statStrings.DELETE = ASCII_STR( "DELETE" );
+            statStrings.RULE = ASCII_STR( "RULE" );
+            statStrings.REFERENCES = ASCII_STR( "REFERENCES" );
+            statStrings.TRIGGER = ASCII_STR( "TRIGGER" );
+            statStrings.EXECUTE = ASCII_STR( "EXECUTE" );
+            statStrings.USAGE = ASCII_STR( "USAGE" );
+            statStrings.CREATE = ASCII_STR( "CREATE" );
+            statStrings.TEMPORARY = ASCII_STR( "TEMPORARY" );
+
+            statStrings.schemaNames = Sequence< OUString > ( 1 );
+            statStrings.schemaNames[0] = ASCII_STR( "TABLE_SCHEM" );
+
+            statStrings.tableTypeData = Sequence< Sequence< Any > >( 2 );
+            statStrings.tableTypeData[0] = Sequence< Any > ( 1 );
+            statStrings.tableTypeData[1] = Sequence< Any > ( 1 );
+//            statStrings.tableTypeData[2] = Sequence< Any > ( 1 );
+            statStrings.tableTypeData[1][0] <<= ASCII_STR( "SYSTEM TABLE" );
+            statStrings.tableTypeData[0][0] <<= ASCII_STR( "TABLE" );
+//            statStrings.tableTypeData[2][0] <<= ASCII_STR( "VIEW" );
+            statStrings.tableTypeNames = Sequence< OUString > ( 1 );
+            statStrings.tableTypeNames[0] = ASCII_STR( "TABLE_TYPE" );
+        
+            
+            
+    //     1. TABLE_CAT string =&gt; table catalog (may be NULL )
+    //     2. TABLE_SCHEM string =&gt; table schema (may be NULL )
+    //     3. TABLE_NAME string =&gt; table name
+    //     4. GRANTOR =&gt; grantor of access (may be NULL )
+    //     5. GRANTEE string =&gt; grantee of access
+    //     6. PRIVILEGE string =&gt; name of access (SELECT, INSERT, UPDATE, REFERENCES, ...)
+    //     7. IS_GRANTABLE string =&gt; "YES" if grantee is permitted to grant to
+    //        others; "NO" if not; NULL if unknown
+            const char *tablePrivilegesNames[] =
+                {
+                    "TABLE_CAT", "TABLE_SCHEM", "TABLE_NAME", "GRANTOR", "GRANTEE", "PRIVILEGE",
+                    "IS_GRANTABLE" 
+                };
+            statStrings.tablePrivilegesNames =
+                createStringSequence( tablePrivilegesNames, 7 );
+            
+            const char * columnNames[] =
+            {
+                "TABLE_CAT", "TABLE_SCHEM", "TABLE_NAME", "COLUMN_NAME",
+                "DATA_TYPE", "TYPE_NAME", "COLUMN_SIZE", "BUFFER_LENGTH",
+                "DECIMAL_DIGITS", "NUM_PREC_RADIX", "NULLABLE", "REMARKS",
+                "COLUMN_DEF", "SQL_DATA_TYPE", "SQL_DATETIME_SUB", "CHAR_OCTET_LENGTH",
+                "ORDINAL_POSITION", "IS_NULLABLE"
+            };
+            statStrings.columnRowNames =
+                createStringSequence( columnNames, 18 );
+
+            BaseTypeDef baseTypeDefs[] =
+            {
+                { "bool" , com::sun::star::sdbc::DataType::BIT },
+                { "bytea", com::sun::star::sdbc::DataType::VARBINARY },
+                { "char" , com::sun::star::sdbc::DataType::CHAR },
+                { "int8" , com::sun::star::sdbc::DataType::BIGINT },
+                { "int2" , com::sun::star::sdbc::DataType::SMALLINT },
+
+                { "int4" , com::sun::star::sdbc::DataType::INTEGER },
+                { "regproc" , com::sun::star::sdbc::DataType::INTEGER },
+                { "oid" , com::sun::star::sdbc::DataType::INTEGER },
+                { "xid" , com::sun::star::sdbc::DataType::INTEGER },
+                { "cid" , com::sun::star::sdbc::DataType::INTEGER },
+
+                { "text", com::sun::star::sdbc::DataType::VARCHAR },
+                { "bpchar", com::sun::star::sdbc::DataType::VARCHAR },
+                { "varchar", com::sun::star::sdbc::DataType::VARCHAR },
+
+                { "float4", com::sun::star::sdbc::DataType::REAL },
+                { "float8", com::sun::star::sdbc::DataType::DOUBLE },
+
+                { "date",  com::sun::star::sdbc::DataType::CHAR }, // switch to date later
+                { "time",  com::sun::star::sdbc::DataType::CHAR }, // switch to time later
+                { 0, 0 }
+
+            };
+            int i;
+            for( i = 0 ; baseTypeDefs[i].typeName ; i ++ )
+            {
+                statStrings.baseTypeMap[
+                    OUString::createFromAscii( baseTypeDefs[i].typeName) ] =
+                           baseTypeDefs[i].value;
+            }
+            p = &statStrings;
+        }
+    }
+    return *p;
+}
+
+    
+void DatabaseMetaData::checkClosed()
+        throw (SQLException, RuntimeException)
+{
+}
+
+DatabaseMetaData::DatabaseMetaData(
+    const ::rtl::Reference< RefCountedMutex > & refMutex,
+    const ::com::sun::star::uno::Reference< com::sun::star::sdbc::XConnection >  & origin,
+    ConnectionSettings *pSettings )
+    : m_refMutex( refMutex ),
+      m_pSettings( pSettings ),
+      m_origin( origin )
+    
+{
+
+}
+
+sal_Bool DatabaseMetaData::allProceduresAreCallable(  ) throw (SQLException, RuntimeException)
+{
+    // TODO
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::allTablesAreSelectable(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+OUString DatabaseMetaData::getURL(  ) throw (SQLException, RuntimeException)
+{
+    // TODO
+    return OUString();
+}
+
+OUString DatabaseMetaData::getUserName(  ) throw (SQLException, RuntimeException)
+{
+    return m_pSettings->user;
+}
+
+sal_Bool DatabaseMetaData::isReadOnly(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+
+sal_Bool DatabaseMetaData::nullsAreSortedHigh(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::nullsAreSortedLow(  ) throw (SQLException, RuntimeException)
+{
+    return ! nullsAreSortedHigh();
+}
+
+sal_Bool DatabaseMetaData::nullsAreSortedAtStart(  ) throw (SQLException, RuntimeException)
+{
+    return ! nullsAreSortedHigh();
+}
+
+sal_Bool DatabaseMetaData::nullsAreSortedAtEnd(  ) throw (SQLException, RuntimeException)
+{
+    return nullsAreSortedHigh();
+}
+
+OUString DatabaseMetaData::getDatabaseProductName(  ) throw (SQLException, RuntimeException)
+{
+    return ASCII_STR( "mdb");
+}
+
+OUString DatabaseMetaData::getDatabaseProductVersion(  ) throw (SQLException, RuntimeException)
+{
+    return ASCII_STR( MDBTOOLS_VERSION );
+}
+OUString DatabaseMetaData::getDriverName(  ) throw (SQLException, RuntimeException)
+{
+    return ASCII_STR( "mdb-sdbc" );
+}
+
+OUString DatabaseMetaData::getDriverVersion(  ) throw (SQLException, RuntimeException)
+{
+    return ASCII_STR( MDB_SDBC_DRIVER_VERSION );
+}
+
+sal_Int32 DatabaseMetaData::getDriverMajorVersion(  ) throw (RuntimeException)
+{
+    return MDB_MAJOR;
+}
+
+sal_Int32 DatabaseMetaData::getDriverMinorVersion(  ) throw (RuntimeException)
+{
+    return MDB_MINOR;
+}
+
+sal_Bool DatabaseMetaData::usesLocalFiles(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::usesLocalFilePerTable(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsMixedCaseIdentifiers(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::storesUpperCaseIdentifiers(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::storesLowerCaseIdentifiers(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+
+sal_Bool DatabaseMetaData::storesMixedCaseIdentifiers(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+
+sal_Bool DatabaseMetaData::supportsMixedCaseQuotedIdentifiers(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::storesUpperCaseQuotedIdentifiers(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+
+sal_Bool DatabaseMetaData::storesLowerCaseQuotedIdentifiers(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+
+sal_Bool DatabaseMetaData::storesMixedCaseQuotedIdentifiers(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+
+OUString DatabaseMetaData::getIdentifierQuoteString(  ) throw (SQLException, RuntimeException)
+{
+    return ASCII_STR( "\"" );
+}
+
+OUString DatabaseMetaData::getSQLKeywords(  ) throw (SQLException, RuntimeException)
+{
+    return ASCII_STR(
+        "ANALYZE,"
+        "ANALYSE,"
+        "DO,"
+        "ILIKE,"
+        "LIMIT,"
+        "NEW,"
+        "OFFSET,"
+        "OLD,"
+        "PLACING" );
+}
+OUString DatabaseMetaData::getNumericFunctions(  ) throw (SQLException, RuntimeException)
+{
+    // TODO
+    return OUString();
+}
+
+OUString DatabaseMetaData::getStringFunctions(  ) throw (SQLException, RuntimeException)
+{
+    // TODO
+    return OUString();
+}
+
+OUString DatabaseMetaData::getSystemFunctions(  ) throw (SQLException, RuntimeException)
+{
+    // TODO
+    return OUString();
+}
+OUString DatabaseMetaData::getTimeDateFunctions(  ) throw (SQLException, RuntimeException)
+{
+    // TODO
+    return OUString();
+}
+OUString DatabaseMetaData::getSearchStringEscape(  ) throw (SQLException, RuntimeException)
+{
+    return ASCII_STR( "\\" );
+}
+OUString DatabaseMetaData::getExtraNameCharacters(  ) throw (SQLException, RuntimeException)
+{
+    // TODO
+    return OUString();
+}
+
+sal_Bool DatabaseMetaData::supportsAlterTableWithAddColumn(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsAlterTableWithDropColumn(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsColumnAliasing(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::nullPlusNonNullIsNull(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsTypeConversion(  ) throw (SQLException, RuntimeException)     // TODO, DON'T KNOW
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsConvert( sal_Int32 /*fromType*/, sal_Int32 /*toType*/ ) throw (SQLException, RuntimeException)  // TODO
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsTableCorrelationNames(  ) throw (SQLException, RuntimeException)     // TODO, don't know
+{
+    return sal_False;
+}
+
+
+sal_Bool DatabaseMetaData::supportsDifferentTableCorrelationNames(  ) throw (SQLException, RuntimeException) // TODO, don't know
+{
+    return sal_False;
+}
+sal_Bool DatabaseMetaData::supportsExpressionsInOrderBy(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsOrderByUnrelated(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsGroupBy(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsGroupByUnrelated(  ) throw (SQLException, RuntimeException) // TODO, DONT know
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsGroupByBeyondSelect(  ) throw (SQLException, RuntimeException) // TODO, DON'T know
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsLikeEscapeClause(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsMultipleResultSets(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsMultipleTransactions(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsNonNullableColumns(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+
+sal_Bool DatabaseMetaData::supportsMinimumSQLGrammar(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsCoreSQLGrammar(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsExtendedSQLGrammar(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsANSI92EntryLevelSQL(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsANSI92IntermediateSQL(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsANSI92FullSQL(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsIntegrityEnhancementFacility(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsOuterJoins(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsFullOuterJoins(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsLimitedOuterJoins(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+
+OUString DatabaseMetaData::getSchemaTerm(  ) throw (SQLException, RuntimeException)
+{
+    return ASCII_STR( "SCHEMA" );
+}
+
+OUString DatabaseMetaData::getProcedureTerm(  ) throw (SQLException, RuntimeException)
+{
+    // don't know
+    return OUString();
+}
+
+OUString DatabaseMetaData::getCatalogTerm(  ) throw (SQLException, RuntimeException)
+{
+    // TODO is this correct ?
+    return ASCII_STR( "DATABASE" );
+}
+
+sal_Bool DatabaseMetaData::isCatalogAtStart(  ) throw (SQLException, RuntimeException)     // TODO don't know
+{
+
+    return sal_True;
+}
+
+OUString DatabaseMetaData::getCatalogSeparator(  ) throw (SQLException, RuntimeException)
+{
+    // TODO don't know
+    return ASCII_STR( "." );
+}
+
+sal_Bool DatabaseMetaData::supportsSchemasInDataManipulation(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsSchemasInProcedureCalls(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsSchemasInTableDefinitions(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsSchemasInIndexDefinitions(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsSchemasInPrivilegeDefinitions(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsCatalogsInDataManipulation(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsCatalogsInProcedureCalls(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsCatalogsInTableDefinitions(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+
+sal_Bool DatabaseMetaData::supportsCatalogsInIndexDefinitions(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+
+sal_Bool DatabaseMetaData::supportsCatalogsInPrivilegeDefinitions(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+
+sal_Bool DatabaseMetaData::supportsPositionedDelete(  ) throw (SQLException, RuntimeException)
+{
+    // TODO 
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsPositionedUpdate(  ) throw (SQLException, RuntimeException)
+{
+    // TODO 
+    return sal_True;
+}
+
+
+sal_Bool DatabaseMetaData::supportsSelectForUpdate(  ) throw (SQLException, RuntimeException)
+{
+    // TODO 
+    return sal_False;
+}
+
+
+sal_Bool DatabaseMetaData::supportsStoredProcedures(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+
+sal_Bool DatabaseMetaData::supportsSubqueriesInComparisons(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsSubqueriesInExists(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsSubqueriesInIns(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsSubqueriesInQuantifieds(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsCorrelatedSubqueries(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+sal_Bool DatabaseMetaData::supportsUnion(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsUnionAll(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsOpenCursorsAcrossCommit(  ) throw (SQLException, RuntimeException)
+{
+    // TODO, don't know
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsOpenCursorsAcrossRollback(  ) throw (SQLException, RuntimeException)
+{
+    // TODO, don't know
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsOpenStatementsAcrossCommit(  ) throw (SQLException, RuntimeException)
+{
+    // TODO, don't know
+    return sal_False;
+}
+sal_Bool DatabaseMetaData::supportsOpenStatementsAcrossRollback(  ) throw (SQLException, RuntimeException)
+{
+    // TODO, don't know
+    return sal_False;
+}
+
+sal_Int32 DatabaseMetaData::getMaxBinaryLiteralLength(  ) throw (SQLException, RuntimeException)
+{
+    // TODO, don't know
+    return -1;
+}
+
+sal_Int32 DatabaseMetaData::getMaxCharLiteralLength(  ) throw (SQLException, RuntimeException)
+{
+    return -1;
+}
+
+sal_Int32 DatabaseMetaData::getMaxColumnNameLength(  ) throw (SQLException, RuntimeException) //TODO, don't know
+{
+    return MAX_IDENTIFIER_LENGTH;
+}
+
+sal_Int32 DatabaseMetaData::getMaxColumnsInGroupBy(  ) throw (SQLException, RuntimeException) //TODO, don't know
+{
+    return MAX_COLUMNS_IN_GROUPBY;
+}
+
+sal_Int32 DatabaseMetaData::getMaxColumnsInIndex(  ) throw (SQLException, RuntimeException) //TODO, don't know
+{
+    return MAX_COLUMNS_IN_INDEX;
+}
+
+sal_Int32 DatabaseMetaData::getMaxColumnsInOrderBy(  ) throw (SQLException, RuntimeException) //TODO, don't know
+{
+    return MAX_COLUMNS_IN_ORDER_BY;
+}
+
+sal_Int32 DatabaseMetaData::getMaxColumnsInSelect(  ) throw (SQLException, RuntimeException) //TODO, don't know
+{
+    return MAX_COLUMNS_IN_SELECT;
+}
+
+sal_Int32 DatabaseMetaData::getMaxColumnsInTable(  ) throw (SQLException, RuntimeException) //TODO, don't know
+{
+    return MAX_COLUMNS_IN_TABLE;
+}
+
+sal_Int32 DatabaseMetaData::getMaxConnections(  ) throw (SQLException, RuntimeException) //TODO, don't know
+{
+    return MAX_CONNECTIONS;
+}
+
+sal_Int32 DatabaseMetaData::getMaxCursorNameLength(  ) throw (SQLException, RuntimeException) //TODO, don't know
+{
+    return MAX_IDENTIFIER_LENGTH;
+}
+
+sal_Int32 DatabaseMetaData::getMaxIndexLength(  ) throw (SQLException, RuntimeException) //TODO, don't know
+{
+    return MAX_IDENTIFIER_LENGTH;
+}
+
+sal_Int32 DatabaseMetaData::getMaxSchemaNameLength(  ) throw (SQLException, RuntimeException) 
+{
+    return MAX_IDENTIFIER_LENGTH;
+}
+
+sal_Int32 DatabaseMetaData::getMaxProcedureNameLength(  ) throw (SQLException, RuntimeException)
+{
+    return MAX_IDENTIFIER_LENGTH;
+}
+
+sal_Int32 DatabaseMetaData::getMaxCatalogNameLength(  ) throw (SQLException, RuntimeException)
+{
+    return MAX_IDENTIFIER_LENGTH;
+}
+
+sal_Int32 DatabaseMetaData::getMaxRowSize(  ) throw (SQLException, RuntimeException) 
+{
+    return -1;
+}
+
+sal_Bool DatabaseMetaData::doesMaxRowSizeIncludeBlobs(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Int32 DatabaseMetaData::getMaxStatementLength(  ) throw (SQLException, RuntimeException) //TODO, don't know
+{
+    return MAX_STATEMENT_LENGTH;
+}
+
+sal_Int32 DatabaseMetaData::getMaxStatements(  ) throw (SQLException, RuntimeException) //TODO, don't know
+{
+    return MAX_STATEMENTS;
+}
+
+sal_Int32 DatabaseMetaData::getMaxTableNameLength(  ) throw (SQLException, RuntimeException) 
+{
+    return MAX_IDENTIFIER_LENGTH;
+}
+
+sal_Int32 DatabaseMetaData::getMaxTablesInSelect(  ) throw (SQLException, RuntimeException)
+{
+    return MAX_TABLES_IN_SELECT;
+}
+
+sal_Int32 DatabaseMetaData::getMaxUserNameLength(  ) throw (SQLException, RuntimeException)
+{
+    return MAX_USER_NAME_LENGTH;
+}
+
+sal_Int32 DatabaseMetaData::getDefaultTransactionIsolation(  ) throw (SQLException, RuntimeException)
+{
+    return com::sun::star::sdbc::TransactionIsolation::READ_COMMITTED;
+}
+
+sal_Bool DatabaseMetaData::supportsTransactions(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsTransactionIsolationLevel( sal_Int32 /*level*/ ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsDataDefinitionAndDataManipulationTransactions(  )
+    throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::supportsDataManipulationTransactionsOnly(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::dataDefinitionCausesTransactionCommit(  ) throw (SQLException, RuntimeException)
+{
+    // don't know 
+    return sal_True;
+}
+
+sal_Bool DatabaseMetaData::dataDefinitionIgnoredInTransactions(  ) throw (SQLException, RuntimeException)
+{
+    return sal_True;
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getProcedures(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schemaPattern*/,
+    const OUString& /*procedureNamePattern*/ ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new ODatabaseMetaDataResultSet( ODatabaseMetaDataResultSet::eProcedures );
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getProcedureColumns(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schemaPattern*/,
+    const OUString& /*procedureNamePattern*/,
+    const OUString& /*columnNamePattern*/ ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new ODatabaseMetaDataResultSet( ODatabaseMetaDataResultSet::eProcedureColumns );
+}
+
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getTables(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schemaPattern*/,
+    const OUString& tableNamePattern,
+    const ::com::sun::star::uno::Sequence< OUString >& /*types*/ )
+    throw (SQLException, RuntimeException)
+{
+	ODatabaseMetaDataResultSet* pResultSet = new ODatabaseMetaDataResultSet();
+	Reference< XResultSet > xResultSet = pResultSet;
+	pResultSet->setTablesMap();
+
+    ODatabaseMetaDataResultSet::ORows _rRows;
+
+
+    ::std::vector< ::rtl::OUString > tables;
+
+    if ( !getTableStrings( m_pSettings->pConnection, tables,m_pSettings->encoding ) )
+        return sal_False;
+
+
+    ::rtl::OUString aTableType(::rtl::OUString::createFromAscii("TABLE"));
+    for ( size_t i = 0; i < tables.size(); i++ ) 
+    {
+        ODatabaseMetaDataResultSet::ORow aRow(3);
+        ::rtl::OUString aTableName  = tables[i];
+
+
+        // return tables to caller
+        if (match( tableNamePattern, aTableName, '\0' ))
+            if ( aTableName.getLength() == 0 ) 
+            {
+                aTableName = rtl::OUString::createFromAscii("table1");
+            }
+
+
+            aRow.push_back( new ORowSetValueDecorator( aTableName ) ); // Table name
+            aRow.push_back( new ORowSetValueDecorator( aTableType ) ); // Table Type
+            aRow.push_back( ODatabaseMetaDataResultSet::getEmptyValue() );                 // Remarks
+            _rRows.push_back(aRow);
+    }
+
+    pResultSet->setRows( _rRows );
+
+	return xResultSet;
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getSchemas(  )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new SequenceResultSet(
+        m_refMutex, *this, Sequence< OUString >(), Sequence< Sequence< Any > > (), m_pSettings->tc );
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getCatalogs(  )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new SequenceResultSet(
+        m_refMutex, *this, Sequence< OUString >(), Sequence< Sequence< Any > > (), m_pSettings->tc );
+}
+    
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getTableTypes(  )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new SequenceResultSet(
+        m_refMutex, *this, sp().tableTypeNames, sp().tableTypeData,
+        m_pSettings->tc );
+}
+
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getColumns(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schemaPattern*/,
+    const OUString& tableNamePattern,
+    const OUString& /*columnNamePattern*/ ) throw (SQLException, RuntimeException)
+{
+    Strings &strs = sp();
+
+    // TODO: use columNamePattern
+
+    // continue !
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+
+    // ignore catalog, as a single pq connection
+    // does not support multiple catalogs eitherway
+
+    //  1. TABLE_CAT string => table catalog (may be NULL)
+    //               => not supported
+    //  2. TABLE_SCHEM string => table schema (may be NULL)
+    //  3. TABLE_NAME string => table name
+    //  4. COLUMN_NAME string => column name
+    //  5. DATA_TYPE short => SQL type from java.sql.Types 
+    //  6. TYPE_NAME string => Data source dependent type name, for a UDT the
+    //                         type name is fully qualified
+    //  7. COLUMN_SIZE long => column size. For char or date types this is
+    //                         the maximum number of characters, for numeric
+    //                         or decimal types this is precision.
+    //  8. BUFFER_LENGTH is not used.
+    //               => not used
+    //  9. DECIMAL_DIGITS long => the number of fractional digits
+    //               => don't know ! TODO !
+    //  10. NUM_PREC_RADIX long => Radix (typically either 10 or 2)
+    //               => TODO ??
+    //  11. NULLABLE long => is NULL allowed?
+    //                      NO_NULLS - might not allow NULL values
+    //                      NULABLE - definitely allows NULL values
+    //                      NULLABLE_UNKNOWN - nullability unknown
+    //  12. REMARKS string => comment describing column (may be NULL )
+    //  13. COLUMN_DEF string => default value (may be NULL)
+    //  14. SQL_DATA_TYPE long => unused
+    //               => empty
+    //  15. SQL_DATETIME_SUB long => unused
+    //               => empty
+    //  16. CHAR_OCTET_LENGTH long => for char types the maximum number of
+    //                                bytes in the column
+    //  17. ORDINAL_POSITION int => index of column in table (starting at 1)
+    //                              pg_attribute.attnum
+    //  18. IS_NULLABLE string => "NO" means column definitely does not allow
+    //                            NULL values; "YES" means the column might
+    //                            allow NULL values. An empty string means
+    //                            nobody knows.
+    AnyVector vec;
+    if (!getColumnStrings(m_pSettings->pConnection, tableNamePattern,vec,m_pSettings->encoding ))
+    	return NULL;
+
+    // TODO: use a ODatabaseMetaDataResultSet
+
+    return new SequenceResultSet(
+        m_refMutex, *this, strs.columnRowNames,
+        Sequence< Sequence< Any > > ( &vec[0],vec.size() ), m_pSettings->tc );
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getColumnPrivileges(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schema*/,
+    const OUString& /*table*/,
+    const OUString& /*columnNamePattern*/ ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new ODatabaseMetaDataResultSet( ODatabaseMetaDataResultSet::eColumnPrivileges );
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getTablePrivileges(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schemaPattern*/,
+    const OUString& /*tableNamePattern*/ ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new ODatabaseMetaDataResultSet( ODatabaseMetaDataResultSet::eTablePrivileges );
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getBestRowIdentifier(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schema*/,
+    const OUString& /*table*/,
+    sal_Int32 /*scope*/,
+    sal_Bool /*nullable*/ ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new ODatabaseMetaDataResultSet( ODatabaseMetaDataResultSet::eBestRowIdentifier );
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getVersionColumns(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schema*/,
+    const OUString& /*table*/ ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new ODatabaseMetaDataResultSet( ODatabaseMetaDataResultSet::eVersionColumns );
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getPrimaryKeys(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schema*/,
+    const OUString& /*table*/ ) throw (SQLException, RuntimeException)
+{
+
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new ODatabaseMetaDataResultSet( ODatabaseMetaDataResultSet::ePrimaryKeys );
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getImportedKeys(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schema*/,
+    const OUString& /*table*/ ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new ODatabaseMetaDataResultSet( ODatabaseMetaDataResultSet::eImportedKeys );
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getExportedKeys(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schema*/,
+    const OUString& /*table*/ ) throw (SQLException, RuntimeException)
+{
+    return new ODatabaseMetaDataResultSet( ODatabaseMetaDataResultSet::eExportedKeys );
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getCrossReference(
+    const ::com::sun::star::uno::Any& /*primaryCatalog*/,
+    const OUString& /*primarySchema*/,
+    const OUString& /*primaryTable*/,
+    const ::com::sun::star::uno::Any& /*foreignCatalog*/,
+    const OUString& /*foreignSchema*/,
+    const OUString& /*foreignTable*/ ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new ODatabaseMetaDataResultSet( ODatabaseMetaDataResultSet::eCrossReference );
+}
+
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getTypeInfo(  )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+	AnyVector vec;
+	if (!getTypeInfos(vec))
+		return new SequenceResultSet(
+        m_refMutex, *this, Sequence< OUString >(), Sequence< Sequence< Any > > (), m_pSettings->tc );
+	
+	Sequence< OUString > typeRowNames=createStringSequence( typeInfoColumn, 18 );
+	
+	return new SequenceResultSet(
+        m_refMutex, *this, typeRowNames,
+        Sequence< Sequence< Any > > ( &vec[0],vec.size() ), m_pSettings->tc );
+    // TODO: use ODatabaseMetaDataResultSet here
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getIndexInfo(
+    const ::com::sun::star::uno::Any& /*catalog*/,
+    const OUString& /*schema*/,
+    const OUString& /*table*/,
+    sal_Bool /*unique*/,
+    sal_Bool /*approximate*/ ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new ODatabaseMetaDataResultSet( ODatabaseMetaDataResultSet::eIndexInfo );
+}
+
+sal_Bool DatabaseMetaData::supportsResultSetType( sal_Int32 setType )
+    throw (SQLException, RuntimeException)
+{
+    return
+        setType == com::sun::star::sdbc::ResultSetType::SCROLL_INSENSITIVE ||
+        setType == com::sun::star::sdbc::ResultSetType::FORWARD_ONLY;
+}
+
+sal_Bool DatabaseMetaData::supportsResultSetConcurrency(
+    sal_Int32 setType, sal_Int32 concurrency ) throw (SQLException, RuntimeException)
+{
+    return supportsResultSetType( setType ) &&
+        (concurrency == com::sun::star::sdbc::TransactionIsolation::READ_COMMITTED ||
+         concurrency == com::sun::star::sdbc::TransactionIsolation::SERIALIZABLE );
+}
+
+sal_Bool DatabaseMetaData::ownUpdatesAreVisible( sal_Int32 /*setType*/ ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::ownDeletesAreVisible( sal_Int32 /*setType*/ ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::ownInsertsAreVisible( sal_Int32 /*setType*/ ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::othersUpdatesAreVisible( sal_Int32 /*setType*/ ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::othersDeletesAreVisible( sal_Int32 /*setType*/ ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::othersInsertsAreVisible( sal_Int32 /*setType*/ ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::updatesAreDetected( sal_Int32 /*setType*/ ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::deletesAreDetected( sal_Int32 /*setType*/ ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+sal_Bool DatabaseMetaData::insertsAreDetected( sal_Int32 /*setType*/ ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool DatabaseMetaData::supportsBatchUpdates(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+::com::sun::star::uno::Reference< XResultSet > DatabaseMetaData::getUDTs( const ::com::sun::star::uno::Any& /*catalog*/, const OUString& /*schemaPattern*/, const OUString& /*typeNamePattern*/, const ::com::sun::star::uno::Sequence< sal_Int32 >& /*types*/ ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return new SequenceResultSet(
+        m_refMutex, *this, Sequence< OUString >(), Sequence< Sequence< Any > > (), m_pSettings->tc );
+}
+
+::com::sun::star::uno::Reference< com::sun::star::sdbc::XConnection > DatabaseMetaData::getConnection()
+    throw (SQLException, RuntimeException)
+{
+    return m_origin;
+}
+}
+
Index: connectivity/source/drivers/mdb/mdb_databasemetadata.hxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_databasemetadata.hxx
diff -N connectivity/source/drivers/mdb/mdb_databasemetadata.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_databasemetadata.hxx	12 Dec 2005 10:02:30 -0000	1.1.4.2
@@ -0,0 +1,229 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+
+#ifndef _MDB_DATABASEMETADATA_HXX_
+#define _MDB_DATABASEMETADATA_HXX_
+
+#include "mdb_connection.hxx"
+#include <com/sun/star/sdbc/XDatabaseMetaData.hpp>
+
+#include <cppuhelper/implbase1.hxx>
+
+#ifndef _CONNECTIVITY_FDATABASEMETADATARESULTSET_HXX_
+#include <FDatabaseMetaDataResultSet.hxx>
+#endif
+using namespace connectivity;
+namespace mdb_sdbc_driver
+{
+
+class DatabaseMetaData :
+        public ::cppu::WeakImplHelper1 < com::sun::star::sdbc::XDatabaseMetaData >
+{
+    ::rtl::Reference< RefCountedMutex > m_refMutex;
+    ConnectionSettings *m_pSettings;
+    ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XConnection > m_origin;
+
+    void checkClosed()
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+public:
+    DatabaseMetaData(
+        const ::rtl::Reference< RefCountedMutex > & reMutex,
+        const ::com::sun::star::uno::Reference< com::sun::star::sdbc::XConnection >  & origin,
+        ConnectionSettings *pSettings 
+        );
+
+public:
+    // Methods
+    virtual sal_Bool SAL_CALL allProceduresAreCallable(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL allTablesAreSelectable(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getURL(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getUserName(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isReadOnly(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL nullsAreSortedHigh(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL nullsAreSortedLow(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL nullsAreSortedAtStart(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL nullsAreSortedAtEnd(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getDatabaseProductName(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getDatabaseProductVersion(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getDriverName(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getDriverVersion(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getDriverMajorVersion(  ) throw (::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getDriverMinorVersion(  ) throw (::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL usesLocalFiles(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL usesLocalFilePerTable(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsMixedCaseIdentifiers(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL storesUpperCaseIdentifiers(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL storesLowerCaseIdentifiers(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL storesMixedCaseIdentifiers(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsMixedCaseQuotedIdentifiers(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL storesUpperCaseQuotedIdentifiers(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL storesLowerCaseQuotedIdentifiers(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL storesMixedCaseQuotedIdentifiers(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getIdentifierQuoteString(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getSQLKeywords(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getNumericFunctions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getStringFunctions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getSystemFunctions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getTimeDateFunctions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getSearchStringEscape(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getExtraNameCharacters(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsAlterTableWithAddColumn(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsAlterTableWithDropColumn(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsColumnAliasing(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL nullPlusNonNullIsNull(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsTypeConversion(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsConvert( sal_Int32 fromType, sal_Int32 toType ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsTableCorrelationNames(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsDifferentTableCorrelationNames(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsExpressionsInOrderBy(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsOrderByUnrelated(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsGroupBy(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsGroupByUnrelated(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsGroupByBeyondSelect(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsLikeEscapeClause(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsMultipleResultSets(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsMultipleTransactions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsNonNullableColumns(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsMinimumSQLGrammar(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsCoreSQLGrammar(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsExtendedSQLGrammar(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsANSI92EntryLevelSQL(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsANSI92IntermediateSQL(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsANSI92FullSQL(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsIntegrityEnhancementFacility(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsOuterJoins(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsFullOuterJoins(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsLimitedOuterJoins(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getSchemaTerm(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getProcedureTerm(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getCatalogTerm(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isCatalogAtStart(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getCatalogSeparator(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsSchemasInDataManipulation(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsSchemasInProcedureCalls(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsSchemasInTableDefinitions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsSchemasInIndexDefinitions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsSchemasInPrivilegeDefinitions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsCatalogsInDataManipulation(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsCatalogsInProcedureCalls(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsCatalogsInTableDefinitions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsCatalogsInIndexDefinitions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsCatalogsInPrivilegeDefinitions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsPositionedDelete(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsPositionedUpdate(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsSelectForUpdate(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsStoredProcedures(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsSubqueriesInComparisons(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsSubqueriesInExists(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsSubqueriesInIns(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsSubqueriesInQuantifieds(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsCorrelatedSubqueries(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsUnion(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsUnionAll(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsOpenCursorsAcrossCommit(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsOpenCursorsAcrossRollback(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsOpenStatementsAcrossCommit(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsOpenStatementsAcrossRollback(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxBinaryLiteralLength(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxCharLiteralLength(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxColumnNameLength(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxColumnsInGroupBy(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxColumnsInIndex(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxColumnsInOrderBy(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxColumnsInSelect(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxColumnsInTable(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxConnections(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxCursorNameLength(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxIndexLength(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxSchemaNameLength(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxProcedureNameLength(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxCatalogNameLength(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxRowSize(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL doesMaxRowSizeIncludeBlobs(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxStatementLength(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxStatements(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxTableNameLength(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxTablesInSelect(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMaxUserNameLength(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getDefaultTransactionIsolation(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsTransactions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsTransactionIsolationLevel( sal_Int32 level ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsDataDefinitionAndDataManipulationTransactions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsDataManipulationTransactionsOnly(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL dataDefinitionCausesTransactionCommit(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL dataDefinitionIgnoredInTransactions(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getProcedures( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schemaPattern, const ::rtl::OUString& procedureNamePattern ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getProcedureColumns( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schemaPattern, const ::rtl::OUString& procedureNamePattern, const ::rtl::OUString& columnNamePattern ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getTables( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schemaPattern, const ::rtl::OUString& tableNamePattern, const ::com::sun::star::uno::Sequence< ::rtl::OUString >& types ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getSchemas(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getCatalogs(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getTableTypes(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getColumns( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schemaPattern, const ::rtl::OUString& tableNamePattern, const ::rtl::OUString& columnNamePattern ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getColumnPrivileges( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schema, const ::rtl::OUString& table, const ::rtl::OUString& columnNamePattern ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getTablePrivileges( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schemaPattern, const ::rtl::OUString& tableNamePattern ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getBestRowIdentifier( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schema, const ::rtl::OUString& table, sal_Int32 scope, sal_Bool nullable ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getVersionColumns( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schema, const ::rtl::OUString& table ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getPrimaryKeys( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schema, const ::rtl::OUString& table ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getImportedKeys( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schema, const ::rtl::OUString& table ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getExportedKeys( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schema, const ::rtl::OUString& table ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getCrossReference( const ::com::sun::star::uno::Any& primaryCatalog, const ::rtl::OUString& primarySchema, const ::rtl::OUString& primaryTable, const ::com::sun::star::uno::Any& foreignCatalog, const ::rtl::OUString& foreignSchema, const ::rtl::OUString& foreignTable ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getTypeInfo(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getIndexInfo( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schema, const ::rtl::OUString& table, sal_Bool unique, sal_Bool approximate ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsResultSetType( sal_Int32 setType ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsResultSetConcurrency( sal_Int32 setType, sal_Int32 concurrency ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL ownUpdatesAreVisible( sal_Int32 setType ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL ownDeletesAreVisible( sal_Int32 setType ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL ownInsertsAreVisible( sal_Int32 setType ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL othersUpdatesAreVisible( sal_Int32 setType ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL othersDeletesAreVisible( sal_Int32 setType ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL othersInsertsAreVisible( sal_Int32 setType ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL updatesAreDetected( sal_Int32 setType ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL deletesAreDetected( sal_Int32 setType ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL insertsAreDetected( sal_Int32 setType ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsBatchUpdates(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL getUDTs( const ::com::sun::star::uno::Any& catalog, const ::rtl::OUString& schemaPattern, const ::rtl::OUString& typeNamePattern, const ::com::sun::star::uno::Sequence< sal_Int32 >& types ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XConnection > SAL_CALL getConnection(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+};
+
+}
+
+#endif
Index: connectivity/source/drivers/mdb/mdb_driver.cxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_driver.cxx
diff -N connectivity/source/drivers/mdb/mdb_driver.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_driver.cxx	12 Jul 2006 10:20:33 -0000	1.1.4.3
@@ -0,0 +1,368 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+
+#include <stdio.h>
+
+#include <cppuhelper/factory.hxx>
+#include <cppuhelper/compbase1.hxx>
+#include <cppuhelper/implementationentry.hxx>
+
+#include <com/sun/star/beans/XPropertySet.hpp>
+
+#include "mdb_driver.hxx"
+
+using rtl::OUString;
+using rtl::OUStringToOString;
+using osl::MutexGuard;
+
+using cppu::WeakComponentImplHelper2;
+
+using com::sun::star::lang::XSingleComponentFactory;
+using com::sun::star::lang::XServiceInfo;
+using com::sun::star::lang::XComponent;
+
+using com::sun::star::uno::RuntimeException;
+using com::sun::star::uno::Exception;
+using com::sun::star::uno::Sequence;
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::XInterface;
+using com::sun::star::uno::UNO_QUERY;
+using com::sun::star::uno::XComponentContext;
+using com::sun::star::uno::Any;
+
+using com::sun::star::beans::PropertyValue;
+using com::sun::star::beans::XPropertySet;
+
+using com::sun::star::sdbc::XConnection;
+using com::sun::star::sdbc::SQLException;
+using com::sun::star::sdbc::DriverPropertyInfo;
+
+
+namespace mdb_sdbc_driver
+{
+#define ASCII_STR(x) OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+
+OUString DriverGetImplementationName()
+{
+    static OUString *p;
+    if (! p )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        static OUString instance(
+            RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.comp.connectivity.mdb.Driver" ) );
+        p = &instance;
+    }
+    return *p;
+}
+
+Sequence< OUString > DriverGetSupportedServiceNames()
+{
+    static Sequence< OUString > *p;
+    if( ! p )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        OUString tmp( RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.sdbc.Driver" ) );
+        static Sequence< OUString > instance( &tmp,1 );
+        p = &instance;
+    }
+    return *p;
+}
+
+Reference< XConnection > Driver::connect(
+    const OUString& url,const Sequence< PropertyValue >& info )
+    throw (SQLException, RuntimeException) 
+{
+    if( ! acceptsURL( url ) )  // XDriver spec tells me to do so ...
+        return Reference< XConnection > ();
+    Sequence< Any > seq ( 2 );
+    seq[0] <<= url;
+    seq[1] <<= info;
+    return Reference< XConnection> (
+        m_smgr->createInstanceWithArgumentsAndContext(
+            OUString(RTL_CONSTASCII_USTRINGPARAM("org.openoffice.comp.connectivity.mdb.Connection" ) ),
+            seq, m_ctx ),
+        UNO_QUERY );
+}
+
+sal_Bool Driver::acceptsURL( const ::rtl::OUString& url )
+    throw (SQLException, RuntimeException)
+{
+    return url.compareToAscii( RTL_CONSTASCII_STRINGPARAM( "sdbc:mdb:" ) ) == 0;
+}
+    
+Sequence< DriverPropertyInfo > Driver::getPropertyInfo(
+    const OUString& /*url*/,const Sequence< PropertyValue >& /*info*/ )
+    throw (SQLException, RuntimeException)
+{
+    return Sequence< DriverPropertyInfo > ();
+}
+    
+sal_Int32  Driver::getMajorVersion(  ) throw (RuntimeException)
+{
+    return MDB_MAJOR;
+}
+
+    
+sal_Int32 Driver::getMinorVersion(  ) throw (RuntimeException)
+{
+    return MDB_MAJOR;
+}
+
+	// XServiceInfo
+OUString SAL_CALL Driver::getImplementationName()
+    throw(::com::sun::star::uno::RuntimeException)
+{
+    return DriverGetImplementationName();
+}
+
+sal_Bool Driver::supportsService(const OUString& ServiceName)
+    throw(::com::sun::star::uno::RuntimeException)
+{
+    Sequence< OUString > serviceNames = DriverGetSupportedServiceNames();
+    for( int i = 0 ; i < serviceNames.getLength() ; i ++ )
+        if( serviceNames[i] == ServiceName )
+            return sal_True;
+    return sal_False;
+}
+
+Sequence< OUString > Driver::getSupportedServiceNames(void)
+    throw(::com::sun::star::uno::RuntimeException)
+{
+    return DriverGetSupportedServiceNames();
+}
+
+// XComponent
+void Driver::disposing()
+{
+
+}
+
+Reference< XInterface > DriverCreateInstance( const Reference < XComponentContext > & ctx )
+{
+    Reference< XInterface >  ret = * new Driver( ctx );
+    return ret;    
+}
+
+
+
+
+class OOneInstanceComponentFactory :
+    public MutexHolder,
+    public WeakComponentImplHelper2< XSingleComponentFactory, XServiceInfo >
+{
+public:
+	OOneInstanceComponentFactory(
+		const OUString & rImplementationName_,
+        cppu::ComponentFactoryFunc fptr,
+		const Sequence< OUString > & serviceNames,
+        const Reference< XComponentContext > & defaultContext)
+        :WeakComponentImplHelper2< XSingleComponentFactory, XServiceInfo >( this->m_mutex )
+        ,m_create( fptr )
+        ,m_serviceNames( serviceNames )
+        ,m_implName( rImplementationName_ )
+        ,m_defaultContext( defaultContext )
+    {
+    }
+	
+    // XSingleComponentFactory
+    virtual Reference< XInterface > SAL_CALL createInstanceWithContext(
+        Reference< XComponentContext > const & xContext )
+        throw (Exception, RuntimeException);
+    virtual Reference< XInterface > SAL_CALL createInstanceWithArgumentsAndContext(
+        Sequence< Any > const & rArguments,
+        Reference< XComponentContext > const & xContext )
+        throw (Exception, RuntimeException);
+
+	// XServiceInfo
+	OUString SAL_CALL getImplementationName()
+		throw(::com::sun::star::uno::RuntimeException)
+    {
+        return m_implName;
+    }
+    sal_Bool SAL_CALL supportsService(const OUString& ServiceName)
+		throw(::com::sun::star::uno::RuntimeException)
+    {
+        for( int i = 0 ; i < m_serviceNames.getLength() ; i ++ )
+            if( m_serviceNames[i] == ServiceName )
+                return sal_True;
+        return sal_False;
+    }
+    Sequence< OUString > SAL_CALL getSupportedServiceNames(void)
+		throw(::com::sun::star::uno::RuntimeException)
+    {
+        return m_serviceNames;
+    }
+
+    // XComponent
+    virtual void SAL_CALL disposing();
+    
+private:
+	cppu::ComponentFactoryFunc	  m_create;
+	Sequence< OUString >		  m_serviceNames;
+	OUString					  m_implName;
+    Reference< XInterface >       m_theInstance;
+    Reference< XComponentContext > m_defaultContext;
+};
+
+Reference< XInterface > OOneInstanceComponentFactory::createInstanceWithArgumentsAndContext(
+    Sequence< Any > const &/*rArguments*/, const Reference< XComponentContext > & ctx )
+    throw( RuntimeException, Exception )
+{
+    return createInstanceWithContext( ctx );
+}
+
+Reference< XInterface > OOneInstanceComponentFactory::createInstanceWithContext(
+    const Reference< XComponentContext > & ctx )
+    throw( RuntimeException, Exception )
+{
+    if( ! m_theInstance.is() )
+    {
+        // work around the problem in sdbc
+        Reference< XComponentContext > useCtx = ctx;
+        if( ! useCtx.is() )
+            useCtx = m_defaultContext;
+        Reference< XInterface > theInstance = m_create( useCtx );
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        if( ! m_theInstance.is () )
+        {
+            m_theInstance = theInstance;
+        }
+    }
+    return m_theInstance;
+}
+
+void OOneInstanceComponentFactory::disposing()
+{
+    Reference< XComponent > rComp;
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        rComp = Reference< XComponent >( m_theInstance, UNO_QUERY );
+        m_theInstance.clear();
+    }
+    if( rComp.is() )
+        rComp->dispose();
+}
+
+//  Reference< XSingleComponentFactory > createOneInstanceComponentFactory(
+//  	cppu::ComponentFactoryFunc fptr,
+//  	::rtl::OUString const & rImplementationName,
+//  	::com::sun::star::uno::Sequence< ::rtl::OUString > const & rServiceNames,
+//  	rtl_ModuleCount * pModCount = 0 )
+//  	SAL_THROW( () )
+//  {
+//      return new OOneInstanceComponentFactory( rImplementationName, fptr , rServiceNames);
+//  }
+
+}
+
+static struct cppu::ImplementationEntry g_entries[] =
+{
+	{
+		mdb_sdbc_driver::DriverCreateInstance, mdb_sdbc_driver::DriverGetImplementationName,
+ 		mdb_sdbc_driver::DriverGetSupportedServiceNames, 0,
+		0 , 0
+	},
+	{ 0, 0, 0, 0, 0, 0 }
+};
+
+extern "C"
+{
+
+//==================================================================================================
+void SAL_CALL component_getImplementationEnvironment(
+	const sal_Char ** ppEnvTypeName, uno_Environment ** /*ppEnv*/ )
+{
+	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+}
+//==================================================================================================
+sal_Bool SAL_CALL component_writeInfo(
+	void * pServiceManager, void * pRegistryKey )
+{
+	return cppu::component_writeInfoHelper( pServiceManager, pRegistryKey, g_entries );
+}
+//==================================================================================================
+void * SAL_CALL component_getFactory(
+	const sal_Char * pImplName, void * pServiceManager, void * /*pRegistryKey*/ )
+{
+    // need to extract the defaultcontext, because the way, sdbc
+    // bypasses the servicemanager, does not allow to use the
+    // XSingleComponentFactory interface ...
+  	void * pRet = 0;
+	Reference< XSingleComponentFactory > xFactory;
+    Reference< XInterface > xSmgr( (XInterface * ) pServiceManager );
+
+	for( sal_Int32 i = 0 ; g_entries[i].create ; i ++ )
+	{
+		OUString implName = g_entries[i].getImplementationName();
+		if( 0 == implName.compareToAscii( pImplName ) )
+		{
+            Reference< XComponentContext > defaultContext;
+            Reference< XPropertySet > propSet( xSmgr, UNO_QUERY );
+            if( propSet.is() )
+            {
+                try
+                {
+                    propSet->getPropertyValue( ASCII_STR( "DefaultContext" ) ) >>= defaultContext;
+                }
+                catch( com::sun::star::uno::Exception &e )
+                {
+                    // if there is no default context, ignore it
+                }
+            }
+			xFactory = new mdb_sdbc_driver::OOneInstanceComponentFactory(
+				implName,
+				g_entries[i].create,
+				g_entries[i].getSupportedServiceNames(),
+                defaultContext );
+		}
+	}
+
+	if( xFactory.is() )
+	{
+		xFactory->acquire();
+		pRet = xFactory.get();
+	}
+	return pRet;
+}
+
+}
+
Index: connectivity/source/drivers/mdb/mdb_driver.hxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_driver.hxx
diff -N connectivity/source/drivers/mdb/mdb_driver.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_driver.hxx	12 Dec 2005 10:02:31 -0000	1.1.4.2
@@ -0,0 +1,118 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Wind Li
+ *
+ *
+ ************************************************************************/
+#ifndef _MDB_DRIVER_HXX_
+#define _MDB_DRIVER_HXX_
+
+#include <osl/mutex.hxx>
+
+#include <cppuhelper/compbase2.hxx>
+
+#include <com/sun/star/lang/XServiceInfo.hpp>
+
+#include <com/sun/star/sdbc/XDriver.hpp>
+
+#include <com/sun/star/uno/XComponentContext.hpp>
+
+namespace mdb_sdbc_driver
+{
+
+#define MY_STRINGIFY( x ) #x
+
+#define MDB_SDBC_DRIVER_VERSION MY_STRINGIFY(MDB_MAJOR) "."  \
+                               MY_STRINGIFY(MDB_MINOR) "." \
+                               MY_STRINGIFY(MDB_MICRO)
+
+#define MDBTOOLS_VERSION MY_STRINGIFY(MDBTOOLS_MAJOR) "." \
+                           MY_STRINGIFY(MDBTOOLS_MINOR) "." \
+                           MY_STRINGIFY(MDBTOOLS_MICRO)
+
+
+struct MutexHolder { osl::Mutex m_mutex; };
+typedef cppu::WeakComponentImplHelper2< com::sun::star::sdbc::XDriver, com::sun::star::lang::XServiceInfo > DriverBase ;
+class Driver : public MutexHolder, public DriverBase
+{
+    com::sun::star::uno::Reference< com::sun::star::uno::XComponentContext > m_ctx;
+    com::sun::star::uno::Reference< com::sun::star::lang::XMultiComponentFactory > m_smgr;
+    
+public: 
+    Driver ( const com::sun::star::uno::Reference < com::sun::star::uno::XComponentContext > & ctx )
+        : DriverBase( this->m_mutex ),
+          m_ctx( ctx ),
+          m_smgr( ctx->getServiceManager() )
+    {}
+
+public: // XDriver
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XConnection > SAL_CALL connect(
+        const ::rtl::OUString& url,
+        const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& info )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+    virtual sal_Bool SAL_CALL acceptsURL( const ::rtl::OUString& url )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::sdbc::DriverPropertyInfo > SAL_CALL getPropertyInfo(
+        const ::rtl::OUString& url,
+        const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >& info )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    
+    virtual sal_Int32 SAL_CALL getMajorVersion(  ) throw (::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getMinorVersion(  ) throw (::com::sun::star::uno::RuntimeException);
+
+public: // XServiceInfo
+	// XServiceInfo
+	virtual rtl::OUString SAL_CALL getImplementationName()
+		throw(::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL supportsService(const rtl::OUString& ServiceName)
+		throw(::com::sun::star::uno::RuntimeException);
+
+    virtual com::sun::star::uno::Sequence< rtl::OUString > SAL_CALL getSupportedServiceNames(void)
+		throw(::com::sun::star::uno::RuntimeException);
+    
+    // XComponent
+    virtual void SAL_CALL disposing();
+    
+};
+
+
+} 
+
+#endif
Index: connectivity/source/drivers/mdb/mdb_preparedstatement.cxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_preparedstatement.cxx
diff -N connectivity/source/drivers/mdb/mdb_preparedstatement.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_preparedstatement.cxx	12 Jul 2006 10:20:33 -0000	1.1.4.3
@@ -0,0 +1,714 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+
+#include "mdb_preparedstatement.hxx"
+#include "mdb_resultset.hxx"
+
+#include <rtl/strbuf.hxx>
+#include <rtl/ustrbuf.hxx>
+
+
+#include <cppuhelper/typeprovider.hxx>
+#include <cppuhelper/queryinterface.hxx>
+
+#include <connectivity/dbexception.hxx>
+
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+#include <com/sun/star/sdbc/ResultSetConcurrency.hpp>
+#include <com/sun/star/sdbc/ResultSetType.hpp>
+
+using osl::Mutex;
+using osl::MutexGuard;
+
+using rtl::OUString;
+using rtl::OUStringToOString;
+using rtl::OStringToOUString;
+using rtl::OUStringBuffer;
+using rtl::OStringBuffer;
+using rtl::OString;
+
+using com::sun::star::uno::Any;
+using com::sun::star::uno::makeAny;
+using com::sun::star::uno::Type;
+using com::sun::star::uno::RuntimeException;
+using com::sun::star::uno::Exception;
+using com::sun::star::uno::Sequence;
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::XInterface;
+
+using com::sun::star::lang::IllegalArgumentException;
+
+using com::sun::star::sdbc::XWarningsSupplier;
+using com::sun::star::sdbc::XCloseable;
+using com::sun::star::sdbc::XPreparedStatement;
+using com::sun::star::sdbc::XParameters;
+using com::sun::star::sdbc::XResultSet;
+using com::sun::star::sdbc::XRef;
+using com::sun::star::sdbc::XBlob;
+using com::sun::star::sdbc::XClob;
+using com::sun::star::sdbc::XArray;
+using com::sun::star::sdbc::XConnection;
+using com::sun::star::sdbc::SQLException;
+
+using com::sun::star::beans::Property;
+using com::sun::star::beans::XPropertySetInfo;
+using com::sun::star::beans::XPropertySet;
+using com::sun::star::beans::XMultiPropertySet;
+using com::sun::star::beans::XFastPropertySet;
+
+#define ASCII_STR(x) OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+namespace mdb_sdbc_driver
+{
+static ::cppu::IPropertyArrayHelper & getPreparedStatementPropertyArrayHelper()
+{
+    static ::cppu::IPropertyArrayHelper *pArrayHelper;
+	if( ! pArrayHelper )
+    {
+		MutexGuard guard( Mutex::getGlobalMutex() );
+		if( ! pArrayHelper )
+        {
+            static Property aTable[] =
+                {
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("CursorName") ), 0,
+                        ::getCppuType( (OUString *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("EscapeProcessing") ), 0,
+                        ::getBooleanCppuType() , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("FetchDirection") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("FetchSize") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("MaxFieldSize") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("MaxRows") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("QueryTimeOut") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("ResultSetConcurrency") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("ResultSetType") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 )
+                };
+            OSL_ASSERT( sizeof(aTable)/ sizeof(Property)  == PREPARED_STATEMENT_SIZE );
+			static ::cppu::OPropertyArrayHelper arrayHelper( aTable, PREPARED_STATEMENT_SIZE, sal_True );
+            pArrayHelper = &arrayHelper;
+        }
+    }
+    return *pArrayHelper;
+}
+
+PreparedStatement::PreparedStatement(
+    const ::rtl::Reference< RefCountedMutex > & refMutex,
+    const Reference< XConnection > & conn,
+    struct ConnectionSettings *pSettings,
+    const ::rtl::OString & stmt )
+    : OComponentHelper( refMutex->mutex ),
+      OPropertySetHelper( OComponentHelper::rBHelper ),
+      m_connection( conn ), 
+      m_pSettings( pSettings ),
+      m_stmt( stmt ),
+      m_refMutex( refMutex )
+{
+    m_props[PREPARED_STATEMENT_QUERY_TIME_OUT] = makeAny( (sal_Int32)0 );
+    m_props[PREPARED_STATEMENT_MAX_ROWS] = makeAny( (sal_Int32)0 );
+    m_props[PREPARED_STATEMENT_RESULT_SET_CONCURRENCY] = makeAny(
+        com::sun::star::sdbc::ResultSetConcurrency::READ_ONLY );
+    m_props[PREPARED_STATEMENT_RESULT_SET_TYPE] = makeAny(
+        com::sun::star::sdbc::ResultSetType::SCROLL_INSENSITIVE );
+
+    int elements = 0;
+    for ( int i = m_stmt.indexOf( '?' ) ; i != -1 ; i = m_stmt.indexOf( '?' , i +1)  )
+    {
+        elements ++;
+    }
+    m_vars = OStringVector ( elements );
+}
+
+PreparedStatement::~PreparedStatement()
+{
+    POSTGRE_TRACE( "dtor PreparedStatement" );
+}
+
+void PreparedStatement::checkColumnIndex( sal_Int32 parameterIndex )
+{
+    if( parameterIndex < 1 || parameterIndex > (sal_Int32) m_vars.size() )
+    {
+        OUStringBuffer buf( 128 );
+        buf.appendAscii( "mdb_preparedstatement: parameter index out of range (expected 1 to " );
+        buf.append( (sal_Int32 ) m_vars.size() );
+        buf.appendAscii( ", got " );
+        buf.append( parameterIndex );
+        buf.appendAscii( ")" );
+        throw SQLException( buf.makeStringAndClear(), *this, OUString(), 1, Any () );
+    }
+}
+void PreparedStatement::checkClosed() throw (SQLException, RuntimeException )
+{
+    if( ! m_pSettings || ! m_pSettings->pConnection )
+        throw SQLException(
+            ASCII_STR("mdb_driver: PreparedStatement or connection has already been closed !" ),
+            *this, OUString(),1,Any());
+}
+
+Any PreparedStatement::queryInterface( const Type & reqType ) throw (RuntimeException)
+{
+    Any ret;
+
+    ret = OComponentHelper::queryInterface( reqType );
+    if( ! ret.hasValue() )
+        ret = ::cppu::queryInterface( reqType,
+                                    static_cast< XWarningsSupplier * > ( this  ),
+                                    static_cast< XPreparedStatement * > ( this ),
+                                    static_cast< XParameters * > ( this ),
+                                    static_cast< XCloseable * > ( this ),
+                                    static_cast< XPropertySet * > ( this ),
+                                    static_cast< XMultiPropertySet * > ( this ),
+                                    static_cast< XFastPropertySet * > ( this ) );
+    return ret;
+}
+
+
+Sequence< Type > PreparedStatement::getTypes() throw ( RuntimeException )
+{
+    static cppu::OTypeCollection *pCollection;
+    if( ! pCollection )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        if( !pCollection )
+        {
+            static cppu::OTypeCollection collection(
+                getCppuType( (Reference< XWarningsSupplier> *) 0 ),
+                getCppuType( (Reference< XPreparedStatement> *) 0 ),
+                getCppuType( (Reference< XParameters> *) 0 ),
+                getCppuType( (Reference< XCloseable> *) 0 ),
+                getCppuType( (Reference< XPropertySet >*) 0 ),
+                getCppuType( (Reference< XFastPropertySet > *) 0 ),
+                getCppuType( (Reference< XMultiPropertySet > *) 0 ),
+                OComponentHelper::getTypes());
+            pCollection = &collection;
+        }
+    }
+    return pCollection->getTypes();
+}
+
+Sequence< sal_Int8> PreparedStatement::getImplementationId() throw ( RuntimeException )
+{
+    static cppu::OImplementationId *pId;
+    if( ! pId )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        if( ! pId )
+        {
+            static cppu::OImplementationId id(sal_False);
+            pId = &id;
+        }
+    }
+    return pId->getImplementationId();
+}
+
+void PreparedStatement::close(  ) throw (SQLException, RuntimeException)
+{
+    // let the connection die without acquired mutex !
+    Reference< XConnection > r;
+    Reference< XCloseable > resultSet;
+    {
+        MutexGuard guard( m_refMutex->mutex );
+        m_pSettings = 0;
+        r = m_connection;
+        m_connection.clear();
+        
+        resultSet = m_lastResultset;
+        m_lastResultset.clear();
+    }
+    if( resultSet.is() )
+    {
+        resultSet->close();
+        POSTGRE_TRACE( "statement closed" );
+    }
+}
+
+// void PreparedStatement::raiseSQLException(
+//     const OUString & sql, const char * errorMsg, const char *errorType )
+//     throw( SQLException )
+// {
+//     OUStringBuffer buf(128);
+//     buf.appendAscii( "mdb_driver: ");
+//     if( errorType )
+//     {
+//         buf.appendAscii( "[" );
+//         buf.appendAscii( errorType );
+//         buf.appendAscii( "]" );
+//     }
+//     buf.append(
+//         rtl::OStringToOUString( errorMsg, strlen(errorMsg) , m_pSettings->encoding ) );
+//     buf.appendAscii( " (caused by statement '" );
+//     buf.append( sql );
+//     buf.appendAscii( "')" );
+//     throw SQLException( buf.makeStringAndClear(), *this, OUString(), 1, Any() );
+// }
+
+
+Reference< XResultSet > PreparedStatement::mdbExecute( OString *pQuery )
+{
+    OStringBuffer buf( m_stmt.getLength() *2 );
+
+    int element = 0;
+    int before = 0;
+    for ( int i = m_stmt.indexOf( '?' ) ; i != -1 ; i = m_stmt.indexOf( '?' , i +1)  )
+    {
+        buf.append( m_stmt.getStr() +  before, i - before );
+        buf.append( m_vars[element] );
+        before = i+1;
+        element ++;
+    }
+    buf.append( m_stmt.getStr() + before );
+
+    *pQuery = buf.makeStringAndClear();
+    
+    osl::ClearableMutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+	AnyVector aRows;
+    Sequence< OUString > seqColumns;
+	::rtl::OString o = *pQuery;
+	if (!mdb_ExecuteQuery(
+			m_pSettings->pConnection,o,aRows,seqColumns)
+		)
+	{
+ 	   return new ResultSet(
+    	    m_refMutex, *this, Sequence< OUString >(), Sequence< Sequence< Any > > () );
+	}
+
+    return new ResultSet(
+        m_refMutex, *this,    seqColumns,
+        Sequence< Sequence< Any > > ( &aRows[0],aRows.size() ) );
+}
+
+Reference< XResultSet > PreparedStatement::executeQuery( )
+        throw (SQLException, RuntimeException)
+{
+    osl::ClearableMutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    OString query;
+    return mdbExecute( &query );
+}
+
+sal_Int32 PreparedStatement::executeUpdate( )
+        throw (SQLException, RuntimeException)
+{
+    osl::ClearableMutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+
+    OString query;
+	Reference< XResultSet > result = mdbExecute( &query);
+/*
+    ExecStatusType state = PQresultStatus( result );
+    switch( state )
+    {
+    case PGRES_COMMAND_OK: // success
+        break; 
+    case PGRES_TUPLES_OK: 
+    {
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_preparedstatement: statment is not a command, use executeQuery() instead (" );
+        buf.append( OStringToOUString( query , m_pSettings->encoding ) );
+        buf.appendAscii( ")" );
+        throw SQLException(buf.makeStringAndClear(), *this, OUString() , 1 , Any() );
+    }
+    case PGRES_EMPTY_QUERY:
+    case PGRES_COPY_OUT:
+    case PGRES_COPY_IN:
+    case PGRES_BAD_RESPONSE:
+    case PGRES_NONFATAL_ERROR:
+    case PGRES_FATAL_ERROR:
+    default:
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_preparedstatement: " );
+        buf.appendAscii( PQresultErrorMessage( result ) );
+        buf.appendAscii( " during command '" );
+        buf.append( OStringToOUString( query, m_pSettings->encoding ) );
+        buf.appendAscii( "')" );
+        throw SQLException(buf.makeStringAndClear(), *this, OUString() , 1 , Any() );
+    }
+
+    Reference< XCloseable > lastResultSet = m_lastResultset;
+    m_lastResultset.clear();
+    sal_Int32 affectedTuples = atoi( PQcmdTuples(result) );
+    PQclear( result );
+    guard.clear();
+
+    if( lastResultSet.is())
+        lastResultSet->close();
+    return affectedTuples;
+*/
+return 0;
+}
+
+sal_Bool PreparedStatement::execute( )
+        throw (SQLException, RuntimeException)
+{
+    throw SQLException( ASCII_STR( "mdb_statement: execute() method is not supported, use executeUpdate or executeQuery instead" ),
+                        *this, OUString() , 1 , Any () );
+    return sal_False;
+}
+
+Reference< XConnection > PreparedStatement::getConnection(  )
+        throw (SQLException, RuntimeException)
+{
+    Reference< XConnection > ret;
+    {
+        MutexGuard guard( m_refMutex->mutex );
+        checkClosed();
+        ret = m_connection;
+    }
+    return ret;
+}
+
+
+void PreparedStatement::setNull( sal_Int32 parameterIndex, sal_Int32 /*sqlType*/ )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    m_vars[parameterIndex-1] = OString( "NULL" );
+}
+
+void PreparedStatement::setObjectNull(
+    sal_Int32 parameterIndex, sal_Int32 /*sqlType*/, const ::rtl::OUString& /*typeName*/ )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    m_vars[parameterIndex-1] = OString( "NULL" );
+}
+
+
+void PreparedStatement::setBoolean( sal_Int32 parameterIndex, sal_Bool x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    if( x )
+        m_vars[parameterIndex-1] = OString( "'t'" );
+    else
+        m_vars[parameterIndex-1] = OString( "'f'" );
+}
+
+void PreparedStatement::setByte( sal_Int32 parameterIndex, sal_Int8 x )
+    throw (SQLException, RuntimeException)
+{
+    setInt(parameterIndex,x);
+}
+
+void PreparedStatement::setShort( sal_Int32 parameterIndex, sal_Int16 x )
+    throw (SQLException, RuntimeException)
+{
+    setInt(parameterIndex, x );
+}
+
+void PreparedStatement::setInt( sal_Int32 parameterIndex, sal_Int32 x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    OStringBuffer buf( 20 );
+    buf.append( "'" );
+    buf.append( (sal_Int32) x );
+    buf.append( "'" );
+    m_vars[parameterIndex-1] = buf.makeStringAndClear();
+}
+
+void PreparedStatement::setLong( sal_Int32 parameterIndex, sal_Int64 x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    OStringBuffer buf( 20 );
+    buf.append( "'" );
+    buf.append( (sal_Int64) x );
+    buf.append( "'" );
+    m_vars[parameterIndex-1] = buf.makeStringAndClear();    
+}
+
+void PreparedStatement::setFloat( sal_Int32 parameterIndex, float x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    OStringBuffer buf( 20 );
+    buf.append( "'" );
+    buf.append( x );
+    buf.append( "'" );
+    m_vars[parameterIndex-1] = buf.makeStringAndClear();
+}
+
+void PreparedStatement::setDouble( sal_Int32 parameterIndex, double x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    OStringBuffer buf( 20 );
+    buf.append( "'" );
+    buf.append( x );
+    buf.append( "'" );
+    m_vars[parameterIndex-1] = buf.makeStringAndClear();
+}
+
+void PreparedStatement::setString( sal_Int32 parameterIndex, const ::rtl::OUString& x )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( parameterIndex );
+    OStringBuffer buf( 20 );
+    buf.append( "'" );
+    OString y = OUStringToOString( x, m_pSettings->encoding );
+    buf.ensureCapacity( y.getLength() * 2 + 2 );
+    int len = 1;//PQescapeString( ((char*)buf.getStr())+1, y.getStr() , y.getLength() );
+    buf.setLength( 1 + len );
+    buf.append( "'" );
+    m_vars[parameterIndex-1] = buf.makeStringAndClear();
+}
+
+void PreparedStatement::setBytes(
+    sal_Int32 /*parameterIndex*/, const Sequence< sal_Int8 >& /*x*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setBytes", *this );
+}
+
+void PreparedStatement::setDate( sal_Int32 /*parameterIndex*/, const ::com::sun::star::util::Date& /*x*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setDate", *this );
+}
+
+void PreparedStatement::setTime( sal_Int32 /*parameterIndex*/, const ::com::sun::star::util::Time& /*x*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setTime", *this );
+}
+
+void PreparedStatement::setTimestamp(
+    sal_Int32 /*parameterIndex*/, const ::com::sun::star::util::DateTime& /*x*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setTimestamp", *this );
+}
+
+void PreparedStatement::setBinaryStream(
+    sal_Int32 /*parameterIndex*/,
+    const Reference< ::com::sun::star::io::XInputStream >& /*x*/,
+    sal_Int32 /*length*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setBinaryStream", *this );
+}
+
+void PreparedStatement::setCharacterStream(
+    sal_Int32 /*parameterIndex*/,
+    const Reference< ::com::sun::star::io::XInputStream >& /*x*/,
+    sal_Int32 /*length*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setCharacterStream", *this );
+}
+
+void PreparedStatement::setObject( sal_Int32 /*parameterIndex*/, const Any& /*x*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setObject", *this );
+}
+
+void PreparedStatement::setObjectWithInfo(
+    sal_Int32 /*parameterIndex*/,
+    const Any& /*x*/,
+    sal_Int32 /*targetSqlType*/,
+    sal_Int32 /*scale*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setObjectWithInfo", *this );
+}
+
+void PreparedStatement::setRef(
+    sal_Int32 /*parameterIndex*/,
+    const Reference< XRef >& /*x*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setRef", *this );
+}
+
+void PreparedStatement::setBlob(
+    sal_Int32 /*parameterIndex*/,
+    const Reference< XBlob >& /*x*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setBlob", *this );
+}
+
+void PreparedStatement::setClob(
+    sal_Int32 /*parameterIndex*/,
+    const Reference< XClob >& /*x*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setClob", *this );
+}
+
+void PreparedStatement::setArray(
+    sal_Int32 /*parameterIndex*/,
+    const Reference< XArray >& /*x*/ )
+    throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XParameters::setArray", *this );
+}
+
+void PreparedStatement::clearParameters(  )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard(m_refMutex->mutex );
+    m_vars = OStringVector ( m_vars.size() );
+}
+
+Any PreparedStatement::getWarnings(  )
+        throw (SQLException,RuntimeException)
+{
+    return Any();
+}
+
+void PreparedStatement::clearWarnings(  )
+        throw (SQLException, RuntimeException)
+{
+}
+
+::cppu::IPropertyArrayHelper & PreparedStatement::getInfoHelper()
+{
+    return getPreparedStatementPropertyArrayHelper(); 
+}
+
+
+sal_Bool PreparedStatement::convertFastPropertyValue(
+		Any & /*rConvertedValue*/, Any & /*rOldValue*/, sal_Int32 nHandle, const Any& rValue )
+		throw (IllegalArgumentException)
+{
+    sal_Bool bRet;
+    switch( nHandle )
+    {
+    case PREPARED_STATEMENT_CURSOR_NAME:
+    {
+        OUString val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    case PREPARED_STATEMENT_ESCAPE_PROCESSING:
+    {
+        sal_Bool val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    case PREPARED_STATEMENT_FETCH_DIRECTION:
+    case PREPARED_STATEMENT_FETCH_SIZE:
+    case PREPARED_STATEMENT_MAX_FIELD_SIZE:
+    case PREPARED_STATEMENT_MAX_ROWS:
+    case PREPARED_STATEMENT_QUERY_TIME_OUT:
+    case PREPARED_STATEMENT_RESULT_SET_CONCURRENCY:
+    case PREPARED_STATEMENT_RESULT_SET_TYPE:
+    {
+        sal_Int32 val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    default:
+    {
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_statement: Invalid property handle (" );
+        buf.append( nHandle );
+        buf.appendAscii( ")" );
+        throw IllegalArgumentException( buf.makeStringAndClear(), *this, 2 );
+    }
+    }
+    return bRet;
+}
+    
+
+void PreparedStatement::setFastPropertyValue_NoBroadcast(
+    sal_Int32 nHandle,const Any& rValue ) throw (Exception)
+{
+    m_props[nHandle] = rValue;
+}
+
+void PreparedStatement::getFastPropertyValue( Any& rValue, sal_Int32 nHandle ) const
+{
+    rValue = m_props[nHandle];
+}
+
+Reference < XPropertySetInfo >  PreparedStatement::getPropertySetInfo()
+        throw(RuntimeException)
+{
+    return OPropertySetHelper::createPropertySetInfo( getPreparedStatementPropertyArrayHelper() );
+}
+
+void PreparedStatement::disposing()
+{
+    close();
+}
+
+
+}
+
Index: connectivity/source/drivers/mdb/mdb_preparedstatement.hxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_preparedstatement.hxx
diff -N connectivity/source/drivers/mdb/mdb_preparedstatement.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_preparedstatement.hxx	12 Jul 2006 10:20:33 -0000	1.1.4.3
@@ -0,0 +1,235 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+
+#ifndef _MDB_PREPARED_STATEMENT_HXX_
+#define _MDB_PREPARED_STATEMENT_HXX_
+#include <vector>
+
+//#include <mdbtools.h>
+
+#include <cppuhelper/propshlp.hxx>
+#include <cppuhelper/component.hxx>
+
+#include <com/sun/star/sdbc/XParameters.hpp>
+
+#include "mdb_connection.hxx"
+namespace rtl { class OString; } 
+namespace mdb_sdbc_driver
+{
+
+static const sal_Int32 PREPARED_STATEMENT_CURSOR_NAME = 0;
+static const sal_Int32 PREPARED_STATEMENT_ESCAPE_PROCESSING = 1;
+static const sal_Int32 PREPARED_STATEMENT_FETCH_DIRECTION = 2;
+static const sal_Int32 PREPARED_STATEMENT_FETCH_SIZE = 3;
+static const sal_Int32 PREPARED_STATEMENT_MAX_FIELD_SIZE = 4;
+static const sal_Int32 PREPARED_STATEMENT_MAX_ROWS = 5;
+static const sal_Int32 PREPARED_STATEMENT_QUERY_TIME_OUT = 6;
+static const sal_Int32 PREPARED_STATEMENT_RESULT_SET_CONCURRENCY = 7;
+static const sal_Int32 PREPARED_STATEMENT_RESULT_SET_TYPE = 8;
+
+#define PREPARED_STATEMENT_SIZE 9
+class ResultSet;
+
+typedef ::std::vector< rtl::OString > OStringVector;
+class PreparedStatement : public cppu::OComponentHelper,
+                          public cppu::OPropertySetHelper,
+                          public com::sun::star::sdbc::XPreparedStatement,
+                          public com::sun::star::sdbc::XParameters,
+                          public com::sun::star::sdbc::XCloseable,
+                          public com::sun::star::sdbc::XWarningsSupplier
+{
+private:
+    com::sun::star::uno::Any m_props[PREPARED_STATEMENT_SIZE];
+    com::sun::star::uno::Reference< com::sun::star::sdbc::XConnection > m_connection;
+    ConnectionSettings *m_pSettings;
+    ::com::sun::star::uno::Reference< com::sun::star::sdbc::XCloseable > m_lastResultset;
+    ::rtl::OString m_stmt;
+    ::rtl::Reference< RefCountedMutex > m_refMutex;
+    OStringVector m_vars;
+    
+public:
+    /**
+     * @param ppConnection The piece of memory, pConnection points to, is accessisble
+     *                     as long as a reference to paramenter con is held. 
+     */
+    PreparedStatement( const rtl::Reference< RefCountedMutex > & refMutex,
+                       const com::sun::star::uno::Reference< com::sun::star::sdbc::XConnection> & con,
+                       struct ConnectionSettings *pSettings,
+                       const rtl::OString &stmt );
+
+     virtual ~PreparedStatement();
+public: // XInterface
+    virtual void SAL_CALL acquire() throw() { OComponentHelper::acquire(); }
+    virtual void SAL_CALL release() throw() { OComponentHelper::release(); }
+    virtual com::sun::star::uno::Any SAL_CALL queryInterface( const com::sun::star::uno::Type & reqType )
+        throw (com::sun::star::uno::RuntimeException);
+    
+public: // XCloseable
+    virtual void SAL_CALL close(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    
+public: // XPreparedStatement
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL executeQuery()
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL executeUpdate(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL execute(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XConnection > SAL_CALL getConnection(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+public: // XParameters
+    virtual void SAL_CALL setNull( sal_Int32 parameterIndex, sal_Int32 sqlType )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setObjectNull(
+        sal_Int32 parameterIndex, sal_Int32 sqlType, const ::rtl::OUString& typeName )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setBoolean( sal_Int32 parameterIndex, sal_Bool x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setByte( sal_Int32 parameterIndex, sal_Int8 x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setShort( sal_Int32 parameterIndex, sal_Int16 x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setInt( sal_Int32 parameterIndex, sal_Int32 x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setLong( sal_Int32 parameterIndex, sal_Int64 x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setFloat( sal_Int32 parameterIndex, float x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setDouble( sal_Int32 parameterIndex, double x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setString( sal_Int32 parameterIndex, const ::rtl::OUString& x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setBytes(
+        sal_Int32 parameterIndex, const ::com::sun::star::uno::Sequence< sal_Int8 >& x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setDate( sal_Int32 parameterIndex, const ::com::sun::star::util::Date& x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setTime( sal_Int32 parameterIndex, const ::com::sun::star::util::Time& x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setTimestamp(
+        sal_Int32 parameterIndex, const ::com::sun::star::util::DateTime& x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setBinaryStream(
+        sal_Int32 parameterIndex,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream >& x,
+        sal_Int32 length )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setCharacterStream(
+        sal_Int32 parameterIndex,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream >& x,
+        sal_Int32 length )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setObject( sal_Int32 parameterIndex, const ::com::sun::star::uno::Any& x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setObjectWithInfo(
+        sal_Int32 parameterIndex,
+        const ::com::sun::star::uno::Any& x,
+        sal_Int32 targetSqlType,
+        sal_Int32 scale )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setRef(
+        sal_Int32 parameterIndex,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XRef >& x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setBlob(
+        sal_Int32 parameterIndex,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XBlob >& x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setClob(
+        sal_Int32 parameterIndex,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XClob >& x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL setArray(
+        sal_Int32 parameterIndex,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XArray >& x )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL clearParameters(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+public: // XWarningsSupplier
+    virtual ::com::sun::star::uno::Any SAL_CALL getWarnings(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL clearWarnings(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+public: // XTypeProvider, first implemented by OPropertySetHelper
+    virtual com::sun::star::uno::Sequence< com::sun::star::uno::Type > SAL_CALL getTypes()
+        throw( com::sun::star::uno::RuntimeException );
+    virtual com::sun::star::uno::Sequence< sal_Int8> SAL_CALL getImplementationId()
+        throw( com::sun::star::uno::RuntimeException );
+
+public: // OPropertySetHelper    
+	virtual cppu::IPropertyArrayHelper & SAL_CALL getInfoHelper();
+
+	virtual sal_Bool SAL_CALL convertFastPropertyValue(
+		::com::sun::star::uno::Any & rConvertedValue,
+		::com::sun::star::uno::Any & rOldValue,
+		sal_Int32 nHandle,
+		const ::com::sun::star::uno::Any& rValue )
+		throw (::com::sun::star::lang::IllegalArgumentException);
+    
+	virtual void SAL_CALL setFastPropertyValue_NoBroadcast(
+		sal_Int32 nHandle,
+		const ::com::sun::star::uno::Any& rValue )
+		throw (::com::sun::star::uno::Exception);
+
+	virtual void SAL_CALL getFastPropertyValue(
+		::com::sun::star::uno::Any& rValue,
+		sal_Int32 nHandle ) const;
+
+	// XPropertySet
+	::com::sun::star::uno::Reference < ::com::sun::star::beans::XPropertySetInfo >  SAL_CALL getPropertySetInfo()
+        throw(com::sun::star::uno::RuntimeException);
+    
+public: // OComponentHelper
+    virtual void SAL_CALL disposing();
+
+private:
+    void checkColumnIndex( sal_Int32 parameterIndex );
+    void checkClosed() throw (com::sun::star::sdbc::SQLException, com::sun::star::uno::RuntimeException);
+    void raiseSQLException( const ::rtl::OUString & sql, const char * errorMsg, const char *errorType = 0 )
+        throw ( com::sun::star::sdbc::SQLException );
+    Reference< XResultSet > mdbExecute( ::rtl::OString *pQuery );
+};
+
+}
+#endif
Index: connectivity/source/drivers/mdb/mdb_resultset.cxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_resultset.cxx
diff -N connectivity/source/drivers/mdb/mdb_resultset.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_resultset.cxx	12 Jul 2006 10:20:33 -0000	1.1.4.3
@@ -0,0 +1,715 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+#include <osl/thread.h>
+
+#include <rtl/ustrbuf.hxx>
+
+#include <cppuhelper/typeprovider.hxx>
+#include <cppuhelper/queryinterface.hxx>
+
+#include <connectivity/dbexception.hxx>
+
+#include "mdb_statement.hxx"
+#include "mdb_resultset.hxx"
+#include "mdb_resultsetmetadata.hxx"
+
+#include <com/sun/star/lang/DisposedException.hpp>
+
+using osl::Mutex;
+using osl::MutexGuard;
+
+using rtl::OUString;
+using rtl::OUStringToOString;
+using rtl::OUStringBuffer;
+using rtl::OString;
+
+using com::sun::star::beans::XPropertySetInfo;
+using com::sun::star::beans::XPropertySet;
+using com::sun::star::beans::XMultiPropertySet;
+using com::sun::star::beans::XFastPropertySet;
+
+using com::sun::star::uno::Any;
+using com::sun::star::uno::makeAny;
+using com::sun::star::uno::Type;
+using com::sun::star::uno::RuntimeException;
+using com::sun::star::uno::Exception;
+using com::sun::star::uno::Sequence;
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::XInterface;
+
+using com::sun::star::lang::IllegalArgumentException;
+
+using com::sun::star::sdbc::XWarningsSupplier;
+using com::sun::star::sdbc::XCloseable;
+using com::sun::star::sdbc::XStatement;
+using com::sun::star::sdbc::XResultSet;
+using com::sun::star::sdbc::XConnection;
+using com::sun::star::sdbc::SQLException;
+using com::sun::star::sdbc::XRow;
+using com::sun::star::sdbc::XColumnLocate;
+using com::sun::star::sdbc::XResultSetMetaData;
+using com::sun::star::sdbc::XResultSetMetaDataSupplier;
+
+
+using com::sun::star::beans::Property;
+
+namespace mdb_sdbc_driver
+{
+#define ASCII_STR(x) OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+
+static ::cppu::IPropertyArrayHelper & getResultSetPropertyArrayHelper()
+{
+    static ::cppu::IPropertyArrayHelper *pArrayHelper;
+	if( ! pArrayHelper )
+    {
+		MutexGuard guard( Mutex::getGlobalMutex() );
+		if( ! pArrayHelper )
+        {
+            static Property aTable[] =
+                {
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("CursorName") ), 0,
+                        ::getCppuType( (OUString *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("EscapeProcessing") ), 0,
+                        ::getBooleanCppuType() , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("FetchDirection") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("FetchSize") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("ResultSetConcurrency") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("ResultSetType") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 )
+                };
+            OSL_ASSERT( sizeof(aTable) / sizeof(Property) == RESULTSET_SIZE );
+			static ::cppu::OPropertyArrayHelper arrayHelper( aTable, RESULTSET_SIZE, sal_True );
+            pArrayHelper = &arrayHelper;
+        }
+    }
+    return *pArrayHelper;
+}
+
+ResultSet::ResultSet( const ::rtl::Reference< RefCountedMutex > & refMutex,
+                      const Reference< XInterface > & owner,
+                      ConnectionSettings **ppSettings,
+                      void * result )
+    : OComponentHelper( refMutex->mutex ),
+      OPropertySetHelper( OComponentHelper::rBHelper ),
+      m_owner( owner ),
+      m_refMutex( refMutex ),
+      m_ppSettings( ppSettings ),
+      m_result( result ),
+      m_row( -1 )
+{
+    POSTGRE_TRACE( "ctor ResultSet" );
+//    m_rowCount = PQntuples( m_result );
+//    m_fieldCount = PQnfields( m_result );
+    m_row = -1;
+}
+
+ResultSet::ResultSet( const ::rtl::Reference< RefCountedMutex > & refMutex,
+                      const Reference< XInterface > & owner,
+    const Sequence< OUString > &colNames,
+    const Sequence< Sequence< Any > > &data) :
+    OComponentHelper( refMutex->mutex ),
+    OPropertySetHelper( OComponentHelper::rBHelper ),
+    m_owner( owner ),
+    m_refMutex( refMutex ),
+    m_row( -1 ),
+    m_rowCount( data.getLength() ),
+    m_fieldCount( colNames.getLength() ),
+    m_wasNull( false ),
+    m_data(data ),
+    m_columnNames( colNames )
+{
+}
+
+
+ResultSet::~ResultSet()
+{
+}
+
+Any ResultSet::queryInterface( const Type & reqType ) throw (RuntimeException)
+{
+    Any ret;
+
+    ret = OComponentHelper::queryInterface( reqType );
+    if( ! ret.hasValue() )
+        ret = ::cppu::queryInterface( reqType,
+                                    static_cast< XResultSet * > ( this  ),
+                                    static_cast< XResultSetMetaDataSupplier * > ( this ),
+                                    static_cast< XRow * > ( this ),
+                                    static_cast< XColumnLocate * > ( this ),
+                                    static_cast< XCloseable * > ( this ),
+                                    static_cast< XPropertySet * > ( this ),
+                                    static_cast< XMultiPropertySet * > ( this ),
+                                    static_cast< XFastPropertySet * > ( this ) );
+    return ret;
+}
+
+void ResultSet::close(  ) throw (SQLException, RuntimeException)
+{
+    Reference< XInterface > owner;
+    {
+        MutexGuard guard( m_refMutex->mutex );
+        if( m_result )
+        {
+//            PQclear(m_result );
+            m_result = 0;
+            m_row = -1;
+        }
+        owner = m_owner;
+        m_owner.clear();
+    }
+}
+
+Sequence<Type > ResultSet::getTypes() throw( RuntimeException )
+{
+    static cppu::OTypeCollection *pCollection;
+    if( ! pCollection )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        if( !pCollection )
+        {
+            static cppu::OTypeCollection collection(
+                getCppuType( (Reference< XResultSet> *) 0 ),
+                getCppuType( (Reference< XResultSetMetaDataSupplier> *) 0 ),
+                getCppuType( (Reference< XRow> *) 0 ),
+                getCppuType( (Reference< XColumnLocate> *) 0 ),
+                getCppuType( (Reference< XCloseable> *) 0 ),
+                getCppuType( (Reference< XPropertySet >*) 0 ),
+                getCppuType( (Reference< XFastPropertySet > *) 0 ),
+                getCppuType( (Reference< XMultiPropertySet > *) 0 ),
+                OComponentHelper::getTypes());
+            pCollection = &collection;
+        }
+    }
+    return pCollection->getTypes();
+}
+
+Sequence< sal_Int8> ResultSet::getImplementationId() throw( RuntimeException )
+{
+    static cppu::OImplementationId *pId;
+    if( ! pId )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        if( ! pId )
+        {
+            static cppu::OImplementationId id(sal_False);
+            pId = &id;
+        }
+    }
+    return pId->getImplementationId();
+}
+
+Reference< XResultSetMetaData > ResultSet::getMetaData(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+	return
+    	new ResultSetMetaData(m_refMutex, this, m_columnNames);
+}
+
+sal_Bool ResultSet::next(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    m_row ++;
+    return m_row < m_rowCount;
+}
+
+sal_Bool ResultSet::isBeforeFirst(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_row == -1;
+}
+
+sal_Bool ResultSet::isAfterLast(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_row >= m_rowCount;
+}
+    
+sal_Bool ResultSet::isFirst(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_row == 0 && m_rowCount;
+}
+
+sal_Bool ResultSet::isLast(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_row >= 0 && m_row + 1 == m_rowCount;
+}
+
+void ResultSet::beforeFirst(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    m_row = -1;
+}
+
+void ResultSet::afterLast(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    m_row = m_rowCount;
+}
+
+sal_Bool ResultSet::first(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    sal_Bool bRet = ( m_rowCount > 0 );
+    if( bRet )
+        m_row = 0;
+    return bRet;
+}
+
+sal_Bool ResultSet::last(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    sal_Bool bRet = ( m_rowCount > 0 );
+    if( bRet )
+        m_row = m_rowCount -1;
+    return bRet;
+}
+
+sal_Int32 ResultSet::getRow(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_row +1;
+}
+
+sal_Bool ResultSet::absolute( sal_Int32 row ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    if( row > 0 )
+    {
+        m_row = row -1;
+        if( m_row > m_rowCount )
+            m_row = m_rowCount;
+    }
+    else
+    {
+        m_row = m_rowCount + row;
+        if( m_row < -1 )
+            m_row = -1;
+    }
+    return sal_True;
+}
+
+sal_Bool ResultSet::relative( sal_Int32 rows ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    m_row += rows;
+
+    if( m_row > m_rowCount )
+        m_row = m_rowCount;
+    else if ( m_row < -1 )
+        m_row = -1;
+    return sal_True;
+}
+
+sal_Bool ResultSet::previous(  ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    sal_Bool bRet = ( m_row != -1 );
+    if( bRet )
+        m_row --;
+    return bRet;
+}
+
+void ResultSet::refreshRow(  ) throw (SQLException, RuntimeException)
+{
+    // TODO: not supported for now
+}
+
+sal_Bool ResultSet::rowUpdated(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool ResultSet::rowInserted(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+sal_Bool ResultSet::rowDeleted(  ) throw (SQLException, RuntimeException)
+{
+    return sal_False;
+}
+
+Reference< XInterface > ResultSet::getStatement() throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    return m_owner;
+}
+
+
+//----------------- XRow interface ----------------------------------------------------
+
+sal_Bool ResultSet::wasNull(  ) throw (SQLException, RuntimeException)
+{
+    return m_wasNull;
+}
+
+
+OUString ResultSet::getString( sal_Int32 columnIndex ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    return getValueAsString(  columnIndex );
+}
+
+inline Any ResultSet::convertTo( const OUString & str , const Type & type )
+{
+    Any aRet;
+    try
+    {
+        aRet = (*m_ppSettings)->tc->convertTo( makeAny(str), type );
+    }
+    catch( com::sun::star::lang::IllegalArgumentException & e )
+    {}
+    catch( com::sun::star::script::CannotConvertException & e )
+    {}
+    return aRet;
+}
+
+sal_Bool ResultSet::getBoolean( sal_Int32 columnIndex ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getBoolean", *this );
+    // TODO
+    return sal_False;
+}
+
+sal_Int8 ResultSet::getByte( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    sal_Int8 b = 0;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &b )) >>= b;
+    return b;
+}
+
+sal_Int16 ResultSet::getShort( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    sal_Int16 i = 0;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &i )) >>= i;
+    return i;
+}
+
+sal_Int32 ResultSet::getInt( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    sal_Int32 i = 0;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &i )) >>= i;
+    return i;
+}
+
+sal_Int64 ResultSet::getLong( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    sal_Int64 i = 0;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &i )) >>= i;
+    return i;
+}
+
+float ResultSet::getFloat( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    float f = 0.;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &f )) >>= f;
+    return f;
+}
+
+double ResultSet::getDouble( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+    double d = 0.;
+    convertTo( getValueAsString( columnIndex ), getCppuType( &d )) >>= d;
+    return d;
+}
+
+Sequence< sal_Int8 > ResultSet::getBytes( sal_Int32 columnIndex )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( columnIndex );
+
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getBytes", *this );
+    // TODO
+    return Sequence< sal_Int8 >();
+}
+
+::com::sun::star::util::Date ResultSet::getDate( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getDate", *this );
+    return com::sun::star::util::Date();
+}
+
+::com::sun::star::util::Time ResultSet::getTime( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getTime", *this );
+    return com::sun::star::util::Time();
+}
+
+::com::sun::star::util::DateTime ResultSet::getTimestamp( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getTimestamp", *this );
+    return com::sun::star::util::DateTime();
+}
+
+Reference< ::com::sun::star::io::XInputStream > ResultSet::getBinaryStream( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getCharacterStream", *this );
+    return 0;
+}
+
+Reference< ::com::sun::star::io::XInputStream > ResultSet::getCharacterStream( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getCharacterStream", *this );
+    return 0;
+}
+
+Any ResultSet::getObject(
+        sal_Int32 /*columnIndex*/,
+        const Reference< ::com::sun::star::container::XNameAccess >& /*typeMap*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getObject", *this );
+    return Any();
+}
+
+Reference< ::com::sun::star::sdbc::XRef > ResultSet::getRef( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getRef", *this );
+    return Reference< com::sun::star::sdbc::XRef > ();
+}
+
+Reference< ::com::sun::star::sdbc::XBlob > ResultSet::getBlob( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getBlob", *this );
+    return Reference< com::sun::star::sdbc::XBlob > ();
+}
+
+Reference< ::com::sun::star::sdbc::XClob > ResultSet::getClob( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getClob", *this );
+    return Reference< com::sun::star::sdbc::XClob > ();
+}
+
+Reference< ::com::sun::star::sdbc::XArray > ResultSet::getArray( sal_Int32 /*columnIndex*/ )
+        throw (SQLException, RuntimeException)
+{
+    ::dbtools::throwFeatureNotImplementedException( "XRow::getArray", *this );
+    return Reference< com::sun::star::sdbc::XArray > ();
+}
+
+
+sal_Int32 ResultSet::findColumn( const ::rtl::OUString& /*columnName*/ )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    OSL_ENSURE( false, "ResultSet::findColumn: not implemented!" );
+    // TODO
+    return 0;
+}
+
+::cppu::IPropertyArrayHelper & ResultSet::getInfoHelper()
+{
+    return getResultSetPropertyArrayHelper(); 
+}
+
+
+sal_Bool ResultSet::convertFastPropertyValue(
+		Any & /*rConvertedValue*/, Any & /*rOldValue*/, sal_Int32 nHandle, const Any& rValue )
+		throw (IllegalArgumentException)
+{
+    sal_Bool bRet;
+    switch( nHandle )
+    {
+    case RESULTSET_CURSOR_NAME:
+    {
+        OUString val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    case RESULTSET_ESCAPE_PROCESSING:
+    {
+        sal_Bool val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    case RESULTSET_FETCH_DIRECTION:
+    case RESULTSET_FETCH_SIZE:
+    case RESULTSET_RESULT_SET_CONCURRENCY:
+    case RESULTSET_RESULT_SET_TYPE:
+    {
+        sal_Int32 val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    default:
+    {
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_resultset: Invalid property handle (" );
+        buf.append( nHandle );
+        buf.appendAscii( ")" );
+        throw IllegalArgumentException( buf.makeStringAndClear(), *this, 2 );
+    }
+    }
+    return bRet;
+}
+    
+
+void ResultSet::setFastPropertyValue_NoBroadcast(
+    sal_Int32 nHandle,const Any& rValue ) throw (Exception)
+{
+    m_props[nHandle] = rValue;
+}
+
+void ResultSet::getFastPropertyValue( Any& rValue, sal_Int32 nHandle ) const
+{
+    rValue = m_props[nHandle];
+}
+
+Reference < XPropertySetInfo >  ResultSet::getPropertySetInfo()
+        throw(RuntimeException)
+{
+    return OPropertySetHelper::createPropertySetInfo( getResultSetPropertyArrayHelper() );
+}
+
+void ResultSet::disposing()
+{
+    close();
+}
+
+void ResultSet::checkClosed() throw ( SQLException, RuntimeException )
+{
+//    if( ! m_columnNames.getLength() )
+//     {
+//        throw SQLException( ASCII_STR( "mdb_resultset: already closed" ), *this,  OUString(), 1, Any() );
+//    }
+
+//    if( ! m_ppSettings || ! *m_ppSettings || ! (*m_ppSettings)->pConnection )
+//    {
+//        throw SQLException( ASCII_STR( "mdb_resultset: statement has been closed already" ),
+//                            *this, OUString(), 1, Any() );
+//    }
+}
+
+void ResultSet::checkColumnIndex(sal_Int32 index ) throw ( SQLException, RuntimeException )
+{
+    if( index < 1 || index > m_fieldCount )
+    {
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_resultset: index out of range (" );
+        buf.append( index );
+        buf.appendAscii( ", allowed range is 1 to " );
+        buf.append( m_fieldCount );
+        buf.appendAscii( ")" );
+        throw SQLException( buf.makeStringAndClear(), *this, OUString(), 1, Any() );
+    }
+
+    if( m_row < 0 || m_row >= m_rowCount )
+    {
+        OUStringBuffer buf( 128 );
+        buf.appendAscii( "mdb_resultset: row index out of range, allowed is 1 to " );
+        buf.append( m_rowCount );
+        buf.appendAscii( ", got " );
+        buf.append( index );
+        throw SQLException( buf.makeStringAndClear(), *this, OUString(),1, Any() );
+    }
+}
+}
Index: connectivity/source/drivers/mdb/mdb_resultset.hxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_resultset.hxx
diff -N connectivity/source/drivers/mdb/mdb_resultset.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_resultset.hxx	12 Jul 2006 10:20:33 -0000	1.1.4.3
@@ -0,0 +1,263 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+#ifndef _PG_RESULTSET_HXX_
+#define _PG_RESULTSET_HXX_
+
+#include <cppuhelper/propshlp.hxx>
+#include <cppuhelper/component.hxx>
+
+#include <com/sun/star/sdbc/XResultSetMetaDataSupplier.hpp>
+#include <com/sun/star/sdbc/XRow.hpp>
+#include <com/sun/star/sdbc/XCloseable.hpp>
+#include <com/sun/star/sdbc/XColumnLocate.hpp>
+#include "mdb_connection.hxx"
+
+namespace mdb_sdbc_driver
+{
+
+static const sal_Int32 RESULTSET_CURSOR_NAME = 0;
+static const sal_Int32 RESULTSET_ESCAPE_PROCESSING = 1;
+static const sal_Int32 RESULTSET_FETCH_DIRECTION = 2;
+static const sal_Int32 RESULTSET_FETCH_SIZE = 3;
+static const sal_Int32 RESULTSET_RESULT_SET_CONCURRENCY = 4;
+static const sal_Int32 RESULTSET_RESULT_SET_TYPE = 5;
+
+#define RESULTSET_SIZE 6
+
+class RefCountedMutex;
+class ResultSet : public cppu::OComponentHelper,
+                  public cppu::OPropertySetHelper,
+                  public com::sun::star::sdbc::XCloseable,
+                  public com::sun::star::sdbc::XResultSetMetaDataSupplier,
+                  public com::sun::star::sdbc::XResultSet,
+                  public com::sun::star::sdbc::XRow,
+                  public com::sun::star::sdbc::XColumnLocate
+{
+private:
+    com::sun::star::uno::Any m_props[RESULTSET_SIZE];
+    com::sun::star::uno::Reference< com::sun::star::uno::XInterface > m_owner;
+    ::rtl::Reference< RefCountedMutex > m_refMutex;
+    ConnectionSettings **m_ppSettings;
+    void *m_result;
+    sal_Int32 m_row;
+    sal_Int32 m_rowCount;
+    sal_Int32 m_fieldCount;
+    sal_Bool  m_wasNull;
+    ::com::sun::star::uno::Sequence< com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > > m_data;
+
+    ::com::sun::star::uno::Sequence< ::rtl::OUString > m_columnNames;
+
+public:
+    inline cppu::OBroadcastHelper & getRBHelper() { return OComponentHelper::rBHelper;}
+    
+private:
+    /** mutex should be locked before called
+     */
+    void checkClosed() throw ( com::sun::star::sdbc::SQLException, com::sun::star::uno::RuntimeException );
+    void checkColumnIndex( sal_Int32 index )
+        throw ( com::sun::star::sdbc::SQLException, com::sun::star::uno::RuntimeException );
+        
+    /** unchecked !
+     */
+    inline ::rtl::OUString getValueAsString( sal_Int32 columnIndex )
+    {
+	    OUString str;
+	    // currently support only string and void !
+	    m_wasNull = !( m_data[m_row][columnIndex-1]  >>= str );
+	
+	    return str;
+    }
+    inline com::sun::star::uno::Any convertTo(
+        const ::rtl::OUString &str, const com::sun::star::uno::Type &type );
+
+public:
+    ResultSet( const ::rtl::Reference< RefCountedMutex > & mutex,
+               const com::sun::star::uno::Reference< com::sun::star::uno::XInterface > &owner,
+               ConnectionSettings **pSettings,
+               void *result );
+	ResultSet( const ::rtl::Reference< RefCountedMutex > & refMutex,
+                      const Reference< XInterface > & owner,
+    const Sequence< OUString > &colNames,
+    const Sequence< Sequence< Any > > &data);
+    
+    ~ResultSet();
+    
+public: // XInterface
+    virtual void SAL_CALL acquire() throw() { OComponentHelper::acquire(); }
+    virtual void SAL_CALL release() throw() { OComponentHelper::release(); }
+    virtual com::sun::star::uno::Any  SAL_CALL queryInterface(
+        const com::sun::star::uno::Type & reqType )
+        throw (com::sun::star::uno::RuntimeException);
+
+public: // XCloseable
+    virtual void SAL_CALL close(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+public: // XTypeProvider, first implemented by OPropertySetHelper
+    virtual com::sun::star::uno::Sequence< com::sun::star::uno::Type > SAL_CALL getTypes()
+        throw( com::sun::star::uno::RuntimeException );
+    virtual com::sun::star::uno::Sequence< sal_Int8> SAL_CALL getImplementationId()
+        throw( com::sun::star::uno::RuntimeException );
+
+public: // XResultSetMetaDataSupplier
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSetMetaData > SAL_CALL getMetaData(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+public: // XResultSet
+    // Methods
+    virtual sal_Bool SAL_CALL next(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isBeforeFirst(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isAfterLast(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isFirst(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isLast(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL beforeFirst(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL afterLast(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL first(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL last(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getRow(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL absolute( sal_Int32 row )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL relative( sal_Int32 rows )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL previous(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL refreshRow(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL rowUpdated(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL rowInserted(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL rowDeleted(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL getStatement()
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+
+public: // XRow
+    virtual sal_Bool SAL_CALL wasNull(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getString( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL getBoolean( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int8 SAL_CALL getByte( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int16 SAL_CALL getShort( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getInt( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int64 SAL_CALL getLong( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual float SAL_CALL getFloat( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual double SAL_CALL getDouble( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Sequence< sal_Int8 > SAL_CALL getBytes( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::util::Date SAL_CALL getDate( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::util::Time SAL_CALL getTime( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::util::DateTime SAL_CALL getTimestamp( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream > SAL_CALL getBinaryStream( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream > SAL_CALL getCharacterStream( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Any SAL_CALL getObject(
+        sal_Int32 columnIndex,
+        const ::com::sun::star::uno::Reference< ::com::sun::star::container::XNameAccess >& typeMap )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XRef > SAL_CALL getRef( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XBlob > SAL_CALL getBlob( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XClob > SAL_CALL getClob( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XArray > SAL_CALL getArray( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+public: // XColumnLocate
+    virtual sal_Int32 SAL_CALL findColumn( const ::rtl::OUString& columnName )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    
+public: // OPropertySetHelper    
+	virtual cppu::IPropertyArrayHelper & SAL_CALL getInfoHelper();
+
+	virtual sal_Bool SAL_CALL convertFastPropertyValue(
+		::com::sun::star::uno::Any & rConvertedValue,
+		::com::sun::star::uno::Any & rOldValue,
+		sal_Int32 nHandle,
+		const ::com::sun::star::uno::Any& rValue )
+		throw (::com::sun::star::lang::IllegalArgumentException);
+    
+	virtual void SAL_CALL setFastPropertyValue_NoBroadcast(
+		sal_Int32 nHandle,
+		const ::com::sun::star::uno::Any& rValue )
+		throw (::com::sun::star::uno::Exception);
+
+	virtual void SAL_CALL getFastPropertyValue(
+		::com::sun::star::uno::Any& rValue,
+		sal_Int32 nHandle ) const;
+
+	// XPropertySet
+	::com::sun::star::uno::Reference < ::com::sun::star::beans::XPropertySetInfo >  SAL_CALL getPropertySetInfo()
+        throw(com::sun::star::uno::RuntimeException);
+
+public: // OComponentHelper
+    virtual void SAL_CALL disposing();
+
+    
+};
+                  
+}
+#endif
Index: connectivity/source/drivers/mdb/mdb_resultsetmetadata.cxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_resultsetmetadata.cxx
diff -N connectivity/source/drivers/mdb/mdb_resultsetmetadata.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_resultsetmetadata.cxx	12 Jul 2006 10:20:34 -0000	1.1.4.3
@@ -0,0 +1,295 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+#include <rtl/ustrbuf.hxx>
+
+#include "mdb_resultsetmetadata.hxx"
+
+
+using osl::Mutex;
+using osl::MutexGuard;
+
+using rtl::OUString;
+using rtl::OUStringBuffer;
+using rtl::OString;
+
+using com::sun::star::uno::Any;
+using com::sun::star::uno::RuntimeException;
+using com::sun::star::uno::Exception;
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::XInterface;
+
+using com::sun::star::lang::IllegalArgumentException;
+
+using com::sun::star::sdbc::SQLException;
+
+#define ASCII_STR(x) OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+
+namespace mdb_sdbc_driver
+{
+
+ResultSetMetaData::ResultSetMetaData(
+    const ::rtl::Reference< RefCountedMutex > & refMutex,
+    const ::com::sun::star::uno::Reference< com::sun::star::sdbc::XResultSet >  & origin,
+    const Sequence< OUString > &colNames ) :
+    m_refMutex( refMutex ),
+    m_origin( origin ),
+    m_colNames(colNames)
+{
+  	m_ppResult = 0;
+	m_colCount = colNames.getLength();
+	
+}
+
+ResultSetMetaData::ResultSetMetaData(
+    int afieldCount )
+{
+	m_colCount = afieldCount;
+	
+}
+
+
+// Methods
+sal_Int32 ResultSetMetaData::getColumnCount(  )
+    throw (SQLException, RuntimeException)
+{
+    return m_colCount;
+}
+
+sal_Bool ResultSetMetaData::isAutoIncrement( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+	return sal_False;
+//     MutexGuard guard( m_refMutex->mutex );
+    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.isAutoIncrement(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+
+sal_Bool ResultSetMetaData::isCaseSensitive( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+	return sal_False;
+	    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.isCaseSensitive(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+
+sal_Bool ResultSetMetaData::isSearchable( sal_Int32 /*column*/ ) throw (SQLException, RuntimeException)
+{
+	return sal_False;
+	    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.isSearchable(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+
+sal_Bool ResultSetMetaData::isCurrency( sal_Int32 /*column*/ ) throw (SQLException, RuntimeException)
+{
+	return sal_False;
+    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.isCurrency(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+
+sal_Int32 ResultSetMetaData::isNullable( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+	return sal_True;
+    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.isNullable(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+
+sal_Bool ResultSetMetaData::isSigned( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+	return sal_False;
+    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.isSigned(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+    
+sal_Int32 ResultSetMetaData::getColumnDisplaySize( sal_Int32 column )
+    throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( column );
+
+    sal_Int32 size = -1;//PQfsize( *m_ppResult, column -1 );
+    if( size == -1 )
+        size = 25;
+
+    // improvement needed !, possible solution is to iterate once over all
+    // rows !
+    
+    return size;
+}
+
+::rtl::OUString ResultSetMetaData::getColumnLabel( sal_Int32 column )
+    throw (SQLException, RuntimeException)
+{
+    return getColumnName( column);
+}
+
+::rtl::OUString ResultSetMetaData::getColumnName( sal_Int32 column ) throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    checkColumnIndex( column );
+
+    return m_colNames[column-1];
+}
+    
+::rtl::OUString ResultSetMetaData::getSchemaName( sal_Int32 /*column*/ ) throw (SQLException, RuntimeException)
+{
+    // Need meta data therefor
+    return OUString();
+}
+
+sal_Int32 ResultSetMetaData::getPrecision( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+    return 0;
+    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.getPrecision(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+
+sal_Int32 ResultSetMetaData::getScale( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+    return 0;
+    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.getScale(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+
+::rtl::OUString ResultSetMetaData::getTableName( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+    return rtl::OUString();
+    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.getTableName(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+
+::rtl::OUString ResultSetMetaData::getCatalogName( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+    return OUString();
+}
+
+sal_Int32 ResultSetMetaData::getColumnType( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+    return -1;
+    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.getColumnType(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+
+::rtl::OUString ResultSetMetaData::getColumnTypeName( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+    return OUString();
+    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.getColumnTypeName(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+
+
+sal_Bool ResultSetMetaData::isReadOnly( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+    // Hey, that's correct !
+    return sal_True;
+}
+
+sal_Bool ResultSetMetaData::isWritable( sal_Int32 column )
+    throw (SQLException, RuntimeException)
+{
+    return ! isReadOnly( column ); // what's the sense if this method ?
+}
+
+sal_Bool ResultSetMetaData::isDefinitelyWritable( sal_Int32 column )
+    throw (SQLException, RuntimeException)
+{
+    return isWritable(column); // uhh, now it becomes really esoteric ....
+}
+
+::rtl::OUString ResultSetMetaData::getColumnServiceName( sal_Int32 /*column*/ )
+    throw (SQLException, RuntimeException)
+{
+    return OUString();
+    throw SQLException(
+        ASCII_STR( "mdb_resultsetmetadata.getColumnServiceName(): don't know" ),
+        *this, OUString(), 1, Any() );
+}
+
+void ResultSetMetaData::checkClosed()
+    throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException)
+{
+//    if( ! *m_ppResult )
+//    {
+//        throw SQLException(
+//            ASCII_STR( "mdb_resultsetmetadata: resultset is closed already" ),
+//            *this, OUString(), 1, Any() );
+//    }
+}
+
+void ResultSetMetaData::checkColumnIndex(sal_Int32 columnIndex)
+    throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException)
+{
+    if( columnIndex < 1 || columnIndex > m_colCount )
+    {
+        OUStringBuffer buf(128);
+
+        buf.appendAscii( "mdb_resultsetmetadata: index out of range (expected 1 to " );
+        buf.append( m_colCount );
+        buf.appendAscii( ", got " );
+        buf.append( columnIndex );
+        throw SQLException(
+            buf.makeStringAndClear(), *this, OUString(), 1, Any() );
+    }
+}
+
+}
Index: connectivity/source/drivers/mdb/mdb_resultsetmetadata.hxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_resultsetmetadata.hxx
diff -N connectivity/source/drivers/mdb/mdb_resultsetmetadata.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_resultsetmetadata.hxx	12 Dec 2005 10:02:32 -0000	1.1.4.2
@@ -0,0 +1,105 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+#ifndef _MDB_RESULTSETMETADATA_HXX_
+#define _MDB_RESULTSETMETADATA_HXX_
+
+#include "mdb_connection.hxx"
+
+#include <com/sun/star/sdbc/XResultSetMetaData.hpp>
+
+#include <cppuhelper/implbase1.hxx>
+
+namespace mdb_sdbc_driver
+{
+
+class ResultSetMetaData :
+        public ::cppu::WeakImplHelper1 < com::sun::star::sdbc::XResultSetMetaData >
+{
+    ::rtl::Reference< RefCountedMutex > m_refMutex;
+    void **m_ppResult;
+    ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > m_origin;
+    sal_Int32 m_colCount;
+    const Sequence< OUString > m_colNames;
+    
+    void checkClosed()
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    void checkColumnIndex( sal_Int32 columnIndex )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+
+public:
+    ResultSetMetaData(
+        const ::rtl::Reference< RefCountedMutex > & reMutex,
+        const ::com::sun::star::uno::Reference< com::sun::star::sdbc::XResultSet >  & origin,
+	    const Sequence< OUString > &colNames
+        );
+	ResultSetMetaData(
+    int afieldCount );
+
+public:
+    // Methods
+    virtual sal_Int32 SAL_CALL getColumnCount(  ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isAutoIncrement( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isCaseSensitive( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isSearchable( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isCurrency( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL isNullable( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isSigned( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getColumnDisplaySize( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getColumnLabel( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getColumnName( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getSchemaName( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getPrecision( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getScale( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getTableName( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getCatalogName( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL getColumnType( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getColumnTypeName( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isReadOnly( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isWritable( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL isDefinitelyWritable( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::rtl::OUString SAL_CALL getColumnServiceName( sal_Int32 column ) throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+};
+
+}
+
+#endif
Index: connectivity/source/drivers/mdb/mdb_sequenceresultset.cxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_sequenceresultset.cxx
diff -N connectivity/source/drivers/mdb/mdb_sequenceresultset.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_sequenceresultset.cxx	12 Dec 2005 10:02:33 -0000	1.1.4.2
@@ -0,0 +1,126 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+
+#include "mdb_resultsetmetadata.hxx"
+#include "mdb_sequenceresultset.hxx"
+
+using rtl::OUString;
+
+using com::sun::star::sdbc::XResultSetMetaData;
+
+using com::sun::star::uno::Sequence;
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::Any;
+
+namespace mdb_sdbc_driver
+{
+#define ASCII_STR(x) OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+
+void SequenceResultSet::checkClosed()
+    throw ( com::sun::star::sdbc::SQLException,
+            com::sun::star::uno::RuntimeException )
+{
+    // we never close :o)
+}
+        
+
+::rtl::OUString SequenceResultSet::getValueAsString( sal_Int32 columnIndex )
+{
+    OUString str;
+    // currently support only string and void !
+    m_wasNull = !( m_data[m_row][columnIndex-1]  >>= str );
+
+    return str;
+}
+
+SequenceResultSet::SequenceResultSet(
+    const ::rtl::Reference< RefCountedMutex > & mutex,
+    const com::sun::star::uno::Reference< com::sun::star::uno::XInterface > &owner,
+    const Sequence< OUString > &colNames,
+    const Sequence< Sequence< Any > > &data,
+    const Reference< com::sun::star::script::XTypeConverter > & tc) :
+    BaseResultSet( mutex, owner, data.getLength(), colNames.getLength(),tc ),
+    m_data(data ),
+    m_columnNames( colNames )
+{
+}
+
+SequenceResultSet::~SequenceResultSet()
+{
+
+}
+    
+void SequenceResultSet::close(  )
+    throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException)
+{
+    // a noop
+}
+
+Reference< XResultSetMetaData > SAL_CALL SequenceResultSet::getMetaData(  )
+    throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException)
+{
+    // Oh no, not again
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+   
+	return
+    	new ResultSetMetaData(m_refMutex, this, m_columnNames);
+}
+
+
+sal_Int32 SAL_CALL SequenceResultSet::findColumn(
+    const ::rtl::OUString& columnName )
+    throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException)
+{
+    // no need to guard, as all members are readonly !
+    sal_Int32 ret = -1;
+    for( int i = 0 ;i < m_fieldCount ; i ++ )
+    {
+        if( columnName == m_columnNames[i] )
+        {
+            ret = i;
+            break;
+        }
+    }
+    return ret;
+}
+}
Index: connectivity/source/drivers/mdb/mdb_sequenceresultset.hxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_sequenceresultset.hxx
diff -N connectivity/source/drivers/mdb/mdb_sequenceresultset.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_sequenceresultset.hxx	12 Dec 2005 10:02:33 -0000	1.1.4.2
@@ -0,0 +1,107 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+#ifndef _PG_SEQUENCERESULTSET_HXX_
+#define _PG_SEQUENCERESULTSET_HXX_
+
+#include <cppuhelper/propshlp.hxx>
+#include <cppuhelper/component.hxx>
+
+#include <com/sun/star/sdbc/XResultSetMetaDataSupplier.hpp>
+#include <com/sun/star/sdbc/XRow.hpp>
+#include <com/sun/star/sdbc/XCloseable.hpp>
+#include <com/sun/star/sdbc/XColumnLocate.hpp>
+#include "mdb_connection.hxx"
+#include "mdb_baseresultset.hxx"
+
+namespace mdb_sdbc_driver
+{
+
+static const sal_Int32 RESULTSET_CURSOR_NAME = 0;
+static const sal_Int32 RESULTSET_ESCAPE_PROCESSING = 1;
+static const sal_Int32 RESULTSET_FETCH_DIRECTION = 2;
+static const sal_Int32 RESULTSET_FETCH_SIZE = 3;
+static const sal_Int32 RESULTSET_RESULT_SET_CONCURRENCY = 4;
+static const sal_Int32 RESULTSET_RESULT_SET_TYPE = 5;
+
+#define RESULTSET_SIZE 6
+class ResultSetGuard;
+
+class SequenceResultSet : public BaseResultSet
+{
+private:
+    ::com::sun::star::uno::Sequence< com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > > m_data;
+    ::com::sun::star::uno::Sequence< ::rtl::OUString > m_columnNames;
+
+protected:
+    /** mutex should be locked before called
+     */
+    virtual void checkClosed()
+        throw ( com::sun::star::sdbc::SQLException, com::sun::star::uno::RuntimeException );
+        
+    /** unchecked, acquire mutex before calling
+     */
+    virtual ::rtl::OUString getValueAsString( sal_Int32 columnIndex );
+
+public:
+    SequenceResultSet(
+        const ::rtl::Reference< RefCountedMutex > & mutex,
+        const com::sun::star::uno::Reference< com::sun::star::uno::XInterface > &owner,
+        const com::sun::star::uno::Sequence< rtl::OUString > &colNames,
+        const com::sun::star::uno::Sequence< com::sun::star::uno::Sequence< com::sun::star::uno::Any > > &data,
+        const com::sun::star::uno::Reference< com::sun::star::script::XTypeConverter > &tc);
+    ~SequenceResultSet();
+    
+public: // XCloseable
+    virtual void SAL_CALL close(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+public: // XResultSetMetaDataSupplier
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSetMetaData > SAL_CALL getMetaData(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+public: // XColumnLocate
+    virtual sal_Int32 SAL_CALL findColumn( const ::rtl::OUString& columnName )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+};
+
+}
+#endif
Index: connectivity/source/drivers/mdb/mdb_statement.cxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_statement.cxx
diff -N connectivity/source/drivers/mdb/mdb_statement.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_statement.cxx	12 Jul 2006 10:20:34 -0000	1.1.4.3
@@ -0,0 +1,431 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+#include "mdb_statement.hxx"
+//#include "mdb_sequenceresultset.hxx"
+#include "mdb_resultset.hxx"
+
+#include <osl/thread.h>
+
+#include <rtl/ustrbuf.hxx>
+
+#include <cppuhelper/typeprovider.hxx>
+#include <cppuhelper/queryinterface.hxx>
+
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+
+#include <com/sun/star/sdbc/ResultSetConcurrency.hpp>
+#include <com/sun/star/sdbc/ResultSetType.hpp>
+
+using osl::Mutex;
+using osl::MutexGuard;
+
+using rtl::OUString;
+using rtl::OUStringBuffer;
+using rtl::OString;
+
+using com::sun::star::uno::Any;
+using com::sun::star::uno::makeAny;
+using com::sun::star::uno::Type;
+using com::sun::star::uno::RuntimeException;
+using com::sun::star::uno::Exception;
+using com::sun::star::uno::Sequence;
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::XInterface;
+
+using com::sun::star::lang::IllegalArgumentException;
+
+using com::sun::star::sdbc::XWarningsSupplier;
+using com::sun::star::sdbc::XCloseable;
+using com::sun::star::sdbc::XStatement;
+using com::sun::star::sdbc::XResultSet;
+using com::sun::star::sdbc::XConnection;
+using com::sun::star::sdbc::SQLException;
+
+using com::sun::star::beans::Property;
+using com::sun::star::beans::XPropertySetInfo;
+using com::sun::star::beans::XPropertySet;
+using com::sun::star::beans::XFastPropertySet;
+using com::sun::star::beans::XMultiPropertySet;
+
+#define ASCII_STR(x) OUString( RTL_CONSTASCII_USTRINGPARAM( x ) )
+namespace mdb_sdbc_driver
+{
+static ::cppu::IPropertyArrayHelper & getStatementPropertyArrayHelper()
+{
+    static ::cppu::IPropertyArrayHelper *pArrayHelper;
+	if( ! pArrayHelper )
+    {
+		MutexGuard guard( Mutex::getGlobalMutex() );
+		if( ! pArrayHelper )
+        {
+            static Property aTable[] =
+                {
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("CursorName") ), 0,
+                        ::getCppuType( (OUString *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("EscapeProcessing") ), 0,
+                        ::getBooleanCppuType() , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("FetchDirection") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("FetchSize") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("MaxFieldSize") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("MaxRows") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("QueryTimeOut") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("ResultSetConcurrency") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 ),
+                    Property(
+                        OUString( RTL_CONSTASCII_USTRINGPARAM("ResultSetType") ), 0,
+                        ::getCppuType( (sal_Int32 *)0) , 0 )
+                };
+            OSL_ASSERT( sizeof(aTable)/ sizeof(Property)  == STATEMENT_SIZE );
+			static ::cppu::OPropertyArrayHelper arrayHelper( aTable, STATEMENT_SIZE, sal_True );
+            pArrayHelper = &arrayHelper;
+        }
+    }
+    return *pArrayHelper;
+}
+
+Statement::Statement( const ::rtl::Reference< RefCountedMutex > & refMutex,
+                      const Reference< XConnection > & conn,
+                      struct ConnectionSettings *pSettings )
+    : OComponentHelper( refMutex->mutex ),
+      OPropertySetHelper( OComponentHelper::rBHelper ),
+      m_connection( conn ), 
+      m_pSettings( pSettings ),
+      m_refMutex( refMutex )
+{
+    m_props[STATEMENT_QUERY_TIME_OUT] = makeAny( (sal_Int32)0 );
+    m_props[STATEMENT_MAX_ROWS] = makeAny( (sal_Int32)0 );
+    m_props[STATEMENT_RESULT_SET_CONCURRENCY] = makeAny(
+        com::sun::star::sdbc::ResultSetConcurrency::READ_ONLY );
+    m_props[STATEMENT_RESULT_SET_TYPE] = makeAny(
+        com::sun::star::sdbc::ResultSetType::SCROLL_INSENSITIVE );    
+}
+
+Statement::~Statement()
+{
+    POSTGRE_TRACE( "dtor Statement" );
+}
+
+void Statement::checkClosed() throw (SQLException, RuntimeException )
+{
+    if( ! m_pSettings || ! m_pSettings->pConnection )
+        throw SQLException(
+            ASCII_STR("mdb_driver: Statement or connection has already been closed !" ),
+            *this, OUString(),1,Any());
+}
+
+Any Statement::queryInterface( const Type & reqType ) throw (RuntimeException)
+{
+    Any ret;
+
+    ret = OComponentHelper::queryInterface( reqType );
+    if( ! ret.hasValue() )
+        ret = ::cppu::queryInterface( reqType,
+                                    static_cast< XWarningsSupplier * > ( this  ),
+                                    static_cast< XStatement * > ( this ),
+                                    static_cast< XCloseable * > ( this ),
+                                    static_cast< XPropertySet * > ( this ),
+                                    static_cast< XMultiPropertySet * > ( this ),
+                                    static_cast< XFastPropertySet * > ( this ) );
+    return ret;
+}
+
+
+Sequence< Type > Statement::getTypes() throw ( RuntimeException )
+{
+    static cppu::OTypeCollection *pCollection;
+    if( ! pCollection )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        if( !pCollection )
+        {
+            static cppu::OTypeCollection collection(
+                getCppuType( (Reference< XWarningsSupplier> *) 0 ),
+                getCppuType( (Reference< XStatement> *) 0 ),
+                getCppuType( (Reference< XCloseable> *) 0 ),
+                getCppuType( (Reference< XPropertySet >*) 0 ),
+                getCppuType( (Reference< XFastPropertySet > *) 0 ),
+                getCppuType( (Reference< XMultiPropertySet > *) 0 ),
+                OComponentHelper::getTypes());
+            pCollection = &collection;
+        }
+    }
+    return pCollection->getTypes();
+}
+
+Sequence< sal_Int8> Statement::getImplementationId() throw ( RuntimeException )
+{
+    static cppu::OImplementationId *pId;
+    if( ! pId )
+    {
+        MutexGuard guard( osl::Mutex::getGlobalMutex() );
+        if( ! pId )
+        {
+            static cppu::OImplementationId id(sal_False);
+            pId = &id;
+        }
+    }
+    return pId->getImplementationId();
+}
+
+void Statement::close(  ) throw (SQLException, RuntimeException)
+{
+    // let the connection die without acquired mutex !
+    Reference< XConnection > r;
+    Reference< XCloseable > resultSet;
+    {
+        MutexGuard guard( m_refMutex->mutex );
+        m_pSettings = 0;
+        r = m_connection;
+        m_connection.clear();
+        
+        resultSet = m_lastResultset;
+        m_lastResultset.clear();
+    }
+    if( resultSet.is() )
+    {
+        resultSet->close();
+        POSTGRE_TRACE( "statement closed" );
+    }
+
+}
+
+void Statement::raiseSQLException(
+    const OUString & sql, const char * errorMsg, const char *errorType )
+    throw( SQLException )
+{
+    OUStringBuffer buf(128);
+    buf.appendAscii( "mdb_driver: ");
+    if( errorType )
+    {
+        buf.appendAscii( "[" );
+        buf.appendAscii( errorType );
+        buf.appendAscii( "]" );
+    }
+    buf.append(
+        rtl::OStringToOUString( errorMsg, strlen(errorMsg) , m_pSettings->encoding ) );
+    buf.appendAscii( " (caused by statement '" );
+    buf.append( sql );
+    buf.appendAscii( "')" );
+    throw SQLException( buf.makeStringAndClear(), *this, OUString(), 1, Any() );
+}
+    
+::com::sun::star::uno::Reference< XResultSet > Statement::executeQuery(const OUString& sql )
+        throw (SQLException, RuntimeException)
+{
+    osl::ClearableMutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    OString o = rtl::OUStringToOString( sql, RTL_TEXTENCODING_UTF8 );
+	AnyVector aRows;
+    Sequence< OUString > seqColumns;
+	if (!mdb_ExecuteQuery(
+			m_pSettings->pConnection,o,aRows,seqColumns)
+		)
+	{
+ 	   return new ResultSet(
+    	    m_refMutex, *this, Sequence< OUString >(), Sequence< Sequence< Any > > () );
+	}
+
+    return new ResultSet(
+        m_refMutex, *this,    seqColumns,
+        Sequence< Sequence< Any > > ( &aRows[0],aRows.size() ) );
+}
+
+sal_Int32 Statement::executeUpdate( const OUString& sql )
+        throw (SQLException, RuntimeException)
+{
+    MutexGuard guard( m_refMutex->mutex );
+    checkClosed();
+    OString o = rtl::OUStringToOString( sql, RTL_TEXTENCODING_UTF8 );
+
+    POSTGRE_TRACE_1( "mdb_statement: executing update %s\n" , o.getStr() );
+//    PGresult *result = PQexec( m_pSettings->pConnection, o.getStr() );
+//    if( ! result )
+//        raiseSQLException( sql, PQerrorMessage( m_pSettings->pConnection ) );
+
+//    ExecStatusType state = PQresultStatus( result );
+/*
+    switch( state )
+    {
+    case PGRES_COMMAND_OK:
+        break; 
+    case PGRES_TUPLES_OK: // success
+        raiseSQLException( sql, "not a command" );
+        break; 
+    case PGRES_EMPTY_QUERY:
+    case PGRES_COPY_OUT:
+    case PGRES_COPY_IN:
+    case PGRES_BAD_RESPONSE:
+    case PGRES_NONFATAL_ERROR:
+    case PGRES_FATAL_ERROR:
+    default:
+        raiseSQLException( sql, PQresultErrorMessage( result ) , PQresStatus( state ) );
+    }
+    sal_Int32 affectedTuples = atoi( PQcmdTuples(result) );
+    PQclear( result );
+*/
+    sal_Int32 affectedTuples = 1;
+    return affectedTuples;
+}
+
+sal_Bool Statement::execute( const OUString& /*sql*/ )
+        throw (SQLException, RuntimeException)
+{
+    throw SQLException( ASCII_STR( "mdb_statement: execute() method is not supported, use executeUpdate or executeQuery instead" ),
+                        *this, OUString() , 1 , Any () );
+    return sal_False;
+}
+
+Reference< XConnection > Statement::getConnection(  )
+        throw (SQLException, RuntimeException)
+{
+    Reference< XConnection > ret;
+    {
+        MutexGuard guard( m_refMutex->mutex );
+        checkClosed();
+        ret = m_connection;
+    }
+    return ret;
+}
+
+
+Any Statement::getWarnings(  )
+        throw (SQLException,RuntimeException)
+{
+    return Any();
+}
+
+void Statement::clearWarnings(  )
+        throw (SQLException, RuntimeException)
+{
+}
+
+::cppu::IPropertyArrayHelper & Statement::getInfoHelper()
+{
+    return getStatementPropertyArrayHelper(); 
+}
+
+
+sal_Bool Statement::convertFastPropertyValue(
+		Any & /*rConvertedValue*/, Any & /*rOldValue*/, sal_Int32 nHandle, const Any& rValue )
+		throw (IllegalArgumentException)
+{
+    sal_Bool bRet;
+    switch( nHandle )
+    {
+    case STATEMENT_CURSOR_NAME:
+    {
+        OUString val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    case STATEMENT_ESCAPE_PROCESSING:
+    {
+        sal_Bool val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    case STATEMENT_FETCH_DIRECTION:
+    case STATEMENT_FETCH_SIZE:
+    case STATEMENT_MAX_FIELD_SIZE:
+    case STATEMENT_MAX_ROWS:
+    case STATEMENT_QUERY_TIME_OUT:
+    case STATEMENT_RESULT_SET_CONCURRENCY:
+    case STATEMENT_RESULT_SET_TYPE:
+    {
+        sal_Int32 val;
+        bRet = ( rValue >>= val );
+        m_props[nHandle] = makeAny( val );
+        break;
+    }
+    default:
+    {
+        OUStringBuffer buf(128);
+        buf.appendAscii( "mdb_statement: Invalid property handle (" );
+        buf.append( nHandle );
+        buf.appendAscii( ")" );
+        throw IllegalArgumentException( buf.makeStringAndClear(), *this, 2 );
+    }
+    }
+    return bRet;
+}
+    
+
+void Statement::setFastPropertyValue_NoBroadcast(
+    sal_Int32 nHandle,const Any& rValue ) throw (Exception)
+{
+    m_props[nHandle] = rValue;
+}
+
+void Statement::getFastPropertyValue( Any& rValue, sal_Int32 nHandle ) const
+{
+    rValue = m_props[nHandle];
+}
+
+Reference < XPropertySetInfo >  Statement::getPropertySetInfo()
+        throw(RuntimeException)
+{
+    return OPropertySetHelper::createPropertySetInfo( getStatementPropertyArrayHelper() );
+}
+
+void Statement::disposing()
+{
+    close();
+}
+
+
+}
+
Index: connectivity/source/drivers/mdb/mdb_statement.hxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_statement.hxx
diff -N connectivity/source/drivers/mdb/mdb_statement.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_statement.hxx	12 Dec 2005 10:02:33 -0000	1.1.4.2
@@ -0,0 +1,157 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ *  The Initial Developer of the Original Code is: Joerg Budischewski
+ *
+ *   Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *   All Rights Reserved.
+ *
+ *   Contributor(s): Joerg Budischewski
+ *
+ *
+ ************************************************************************/
+#ifndef _MDB_STATEMENT_HXX_
+#define _MDB_STATEMENT_HXX_
+
+#include "mdb_connection.hxx"
+
+#include <cppuhelper/propshlp.hxx>
+#include <cppuhelper/component.hxx>
+
+
+
+namespace mdb_sdbc_driver
+{
+
+static const sal_Int32 STATEMENT_CURSOR_NAME = 0;
+static const sal_Int32 STATEMENT_ESCAPE_PROCESSING = 1;
+static const sal_Int32 STATEMENT_FETCH_DIRECTION = 2;
+static const sal_Int32 STATEMENT_FETCH_SIZE = 3;
+static const sal_Int32 STATEMENT_MAX_FIELD_SIZE = 4;
+static const sal_Int32 STATEMENT_MAX_ROWS = 5;
+static const sal_Int32 STATEMENT_QUERY_TIME_OUT = 6;
+static const sal_Int32 STATEMENT_RESULT_SET_CONCURRENCY = 7;
+static const sal_Int32 STATEMENT_RESULT_SET_TYPE = 8;
+
+#define STATEMENT_SIZE 9
+class ResultSet;
+
+class Statement : public cppu::OComponentHelper,
+                  public cppu::OPropertySetHelper,
+                  public com::sun::star::sdbc::XStatement,
+                  public com::sun::star::sdbc::XCloseable,
+                  public com::sun::star::sdbc::XWarningsSupplier
+{
+private:
+    com::sun::star::uno::Any m_props[STATEMENT_SIZE];
+    com::sun::star::uno::Reference< com::sun::star::sdbc::XConnection > m_connection;
+    ConnectionSettings *m_pSettings;
+    com::sun::star::uno::Reference< com::sun::star::sdbc::XCloseable > m_lastResultset;
+    ::rtl::Reference< RefCountedMutex > m_refMutex;
+    
+public:
+    /**
+     * @param ppConnection The piece of memory, pConnection points to, is accessisble
+     *                     as long as a reference to paramenter con is held. 
+     */
+    Statement( const rtl::Reference< RefCountedMutex > & refMutex,
+               const com::sun::star::uno::Reference< com::sun::star::sdbc::XConnection> & con,
+               struct ConnectionSettings *pSettings );
+
+    virtual ~Statement();
+public: // XInterface
+    virtual void SAL_CALL acquire() throw() { OComponentHelper::acquire(); }
+    virtual void SAL_CALL release() throw() { OComponentHelper::release(); }
+    virtual com::sun::star::uno::Any SAL_CALL queryInterface( const com::sun::star::uno::Type & reqType )
+        throw (com::sun::star::uno::RuntimeException);
+    
+public: // XCloseable
+    virtual void SAL_CALL close(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    
+public: // XStatement
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XResultSet > SAL_CALL executeQuery(
+        const ::rtl::OUString& sql )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Int32 SAL_CALL executeUpdate( const ::rtl::OUString& sql )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual sal_Bool SAL_CALL execute( const ::rtl::OUString& sql )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XConnection > SAL_CALL getConnection(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+public: // XWarningsSupplier
+    virtual ::com::sun::star::uno::Any SAL_CALL getWarnings(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+    virtual void SAL_CALL clearWarnings(  )
+        throw (::com::sun::star::sdbc::SQLException, ::com::sun::star::uno::RuntimeException);
+
+public: // XTypeProvider, first implemented by OPropertySetHelper
+    virtual com::sun::star::uno::Sequence< com::sun::star::uno::Type > SAL_CALL getTypes()
+        throw( com::sun::star::uno::RuntimeException );
+    virtual com::sun::star::uno::Sequence< sal_Int8> SAL_CALL getImplementationId()
+        throw( com::sun::star::uno::RuntimeException );
+
+public: // OPropertySetHelper    
+	virtual cppu::IPropertyArrayHelper & SAL_CALL getInfoHelper();
+
+	virtual sal_Bool SAL_CALL convertFastPropertyValue(
+		::com::sun::star::uno::Any & rConvertedValue,
+		::com::sun::star::uno::Any & rOldValue,
+		sal_Int32 nHandle,
+		const ::com::sun::star::uno::Any& rValue )
+		throw (::com::sun::star::lang::IllegalArgumentException);
+    
+	virtual void SAL_CALL setFastPropertyValue_NoBroadcast(
+		sal_Int32 nHandle,
+		const ::com::sun::star::uno::Any& rValue )
+		throw (::com::sun::star::uno::Exception);
+
+	virtual void SAL_CALL getFastPropertyValue(
+		::com::sun::star::uno::Any& rValue,
+		sal_Int32 nHandle ) const;
+
+	// XPropertySet
+	::com::sun::star::uno::Reference < ::com::sun::star::beans::XPropertySetInfo >  SAL_CALL getPropertySetInfo()
+        throw(com::sun::star::uno::RuntimeException);
+    
+public: // OComponentHelper
+    virtual void SAL_CALL disposing();
+
+private:
+    void checkClosed() throw (com::sun::star::sdbc::SQLException, com::sun::star::uno::RuntimeException);
+    void raiseSQLException( const ::rtl::OUString & sql, const char * errorMsg, const char *errorType = 0 )
+        throw ( com::sun::star::sdbc::SQLException );
+};
+
+}
+#endif
Index: connectivity/source/drivers/mdb/mdb_wrapper.cxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_wrapper.cxx
diff -N connectivity/source/drivers/mdb/mdb_wrapper.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_wrapper.cxx	12 Jul 2006 10:20:34 -0000	1.1.4.6
@@ -0,0 +1,360 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include <mdb_wrapper.hxx>
+
+char *mdb_access_types1[] = 
+	{"Unknown 0x00",
+         "Boolean",
+         "Byte",
+         "Integer",
+         "Long Integer",
+         "Currency",
+         "Single",
+         "Double",
+         "DateTime (Short)",
+         "Unknown 0x09",
+         "Text",
+         "OLE",
+         "Memo/Hyperlink",
+         "Unknown 0x0d",
+         "Unknown 0x0e",
+  	"Replication ID",
+	"Numeric"};
+
+struct BaseTypeDef { const char * typeName; sal_Int32 length; sal_Int32 value; };
+ BaseTypeDef mdb_access_types[] =
+            {
+                { "Unknown 0x00" , 4,	com::sun::star::sdbc::DataType::OTHER },
+                { "Boolean", 		 1,	com::sun::star::sdbc::DataType::BIT },
+                { "Byte" , 		 1,	com::sun::star::sdbc::DataType::SMALLINT },
+                { "Integer" , 		 4,	com::sun::star::sdbc::DataType::INTEGER },
+                { "Long Integer" ,   8,	com::sun::star::sdbc::DataType::BIGINT },
+                { "Currency", 		 8,	com::sun::star::sdbc::DataType::DOUBLE },
+                { "Single", 		 4,	com::sun::star::sdbc::DataType::REAL },
+                { "Double", 		 8,	com::sun::star::sdbc::DataType::DOUBLE },
+                { "DateTime(Short)", 8,	com::sun::star::sdbc::DataType::BIGINT },
+                { "Unknown 0x09" , 4,	com::sun::star::sdbc::DataType::OTHER },
+                { "Text", 		65535,com::sun::star::sdbc::DataType::VARCHAR },
+                { "OLE" , 		0,com::sun::star::sdbc::DataType::OBJECT },
+                { "Memo/Hyperlink", 65535,com::sun::star::sdbc::DataType::VARCHAR },
+
+                { "Unknown 0x0d" , 4, com::sun::star::sdbc::DataType::OTHER },
+                { "Unknown 0x0e" , 4, com::sun::star::sdbc::DataType::OTHER },
+                { "Replication ID" , 16, com::sun::star::sdbc::DataType::INTEGER },
+                { "Numeric" , 	8, com::sun::star::sdbc::DataType::INTEGER },
+
+                { 0,0, 0 }
+
+            };
+
+	::MdbHandle * OpenMDB(char * sFileName)
+	{
+		MdbHandle *mdb;
+	 
+	  	/* initialize the library */
+	 	mdb_init();
+	
+	 	/* open the database */
+	 	
+	 	if (!(mdb = mdb_open (sFileName,MDB_NOFLAGS))) {
+			fprintf(stderr,"Couldn't open database.\n");
+		}
+		OSL_TRACE( "opening %s, handle %p", sFileName, mdb );
+		return mdb;
+	}
+	void CloseMDB(::MdbHandle * mdb)
+	{
+		OSL_TRACE( "closing %p", mdb );
+		mdb_close(mdb);
+		mdb_exit();
+	}
+sal_Bool getTableStrings( MdbHandle *aMdb,
+                         ::std::vector< ::rtl::OUString >&   _rStrings,
+                         rtl_TextEncoding encoding)
+{
+unsigned int i;
+MdbHandle *mdb=aMdb;
+MdbCatalogEntry *entry;
+/*char delimiter[4] = " | ";*/
+int line_break=1;
+int skip_sys=1;
+
+::std::vector< ::rtl::OUString >    m_aTableNames;
+::rtl::OUString aTableName;
+
+
+ 	if (!mdb) {
+		fprintf(stderr,"Couldn't open database.\n");
+		return sal_False;
+	}
+	
+
+ 	/* read the catalog */
+ 	mdb_read_catalog (mdb, MDB_TABLE);
+
+ 	/* loop over each entry in the catalog */
+ 	for (i=0; i < mdb->num_catalog; i++) {
+		entry = (MdbCatalogEntry *) g_ptr_array_index (mdb->catalog, i);
+
+     	/* if it's a table */
+     	if (entry->object_type == MDB_TABLE) {
+	 		/* skip the MSys tables */
+			if (!skip_sys || strncmp (entry->object_name, "MSys", 4))
+			{
+                ::rtl::OString aTableNameEncoded( entry->object_name );
+                aTableName = ::rtl::OUString( aTableNameEncoded.getStr(), aTableNameEncoded.getLength(), encoding );
+				m_aTableNames.push_back( aTableName ); // Table name
+
+	       		/*if (line_break) 
+					fprintf (stdout, "%s\n", entry->object_name);
+				else if (delimiter) 
+					fprintf (stdout, "%s%s", entry->object_name, delimiter);
+				else 
+					fprintf (stdout, "%s ", entry->object_name);*/
+	     	}
+		}
+	}
+	if (!line_break) 
+		fprintf (stdout, "\n");
+
+    _rStrings = m_aTableNames;
+    return( sal_True );
+
+}
+sal_Bool getColumnStrings( ::MdbHandle *aMdb,
+							::rtl::OUString aTableName,
+                         	AnyVector  & aColumns,
+                             rtl_TextEncoding encoding)
+{
+	unsigned int i, k;
+	MdbHandle *mdb=aMdb;
+	MdbCatalogEntry *entry;
+	MdbTableDef *table;
+	MdbColumn *col;
+	
+	::rtl::OUString aColumnName;
+	::rtl::OString sTableNameTemp=
+        ::rtl::OUStringToOString(aTableName, encoding);
+	if (sTableNameTemp.getLength()==0) return sal_False;
+
+	if (!mdb) {
+		fprintf(stderr,"Couldn't open database.\n");
+		return sal_False;
+	}
+	
+
+ 	/* read the catalog */
+ 	mdb_read_catalog (mdb, MDB_TABLE);
+
+ 	/* loop over each entry in the catalog */
+ 	for (i=0; i < mdb->num_catalog; i++)
+ 	{
+		entry = (MdbCatalogEntry*) g_ptr_array_index (mdb->catalog, i);
+     	/* if it's a table */
+     	if (entry->object_type == MDB_TABLE) 
+     	{
+	 		/* is wanted table */
+			if (!strcmp (entry->object_name,sTableNameTemp.getStr()))
+			{
+	    	   table = mdb_read_table (entry);
+
+		       /* get the columns */
+		       mdb_read_columns (table);
+		        Sequence< Any > aRow( 18 );
+
+	    	   /* loop over the columns, dumping the names and types */
+
+	       		for (k = 0; k < table->num_cols; k++)
+			   {
+			    col = (MdbColumn*) g_ptr_array_index (table->columns, k);
+			    // Catalog
+			    aRow[0] <<= ::rtl::OUString::createFromAscii("");
+			    // Schema
+			    aRow[1] <<= ::rtl::OUString::createFromAscii("");
+			    // TABLE_NAME
+				aRow[2] <<= rtl::OUString::createFromAscii(entry->object_name);
+				// COLUMN_NAME
+				aRow[3] <<=  rtl::OUString::createFromAscii(col->name);
+			    // DATA_TYPE
+			    aRow[4] <<= ::rtl::OUString::valueOf( mdb_access_types[col->col_type].value ,10);
+			    // TYPE_NAME, not used
+			    aRow[5] <<= ::rtl::OUString::createFromAscii(mdb_access_types[col->col_type].typeName);
+			    // COLUMN_SIZE
+			    aRow[6] <<= ::rtl::OUString::valueOf((long)col->col_size,10);
+			    // BUFFER_LENGTH, not used
+			    aRow[7] <<=::rtl::OUString::createFromAscii("");
+			    // DECIMAL_DIGITS.
+			    aRow[8] <<= ::rtl::OUString::createFromAscii("0");
+			    // NUM_PREC_RADIX
+			    aRow[9] <<= ::rtl::OUString::createFromAscii("10");
+			    // NULLABLE
+			    aRow[10] <<= ::rtl::OUString::createFromAscii("1");
+			    // REMARKS
+			    aRow[11] <<= ::rtl::OUString::createFromAscii("");
+			    // COULUMN_DEF, not used
+			    aRow[12] <<= ::rtl::OUString::createFromAscii("");
+			    // SQL_DATA_TYPE, not used
+			    aRow[13] <<= ::rtl::OUString::createFromAscii("");
+			    // SQL_DATETIME_SUB, not used
+			    aRow[14] <<= ::rtl::OUString::createFromAscii("");
+			    // CHAR_OCTET_LENGTH
+			    aRow[15] <<= ::rtl::OUString::valueOf((long)mdb_access_types[col->col_type].length,10);
+			    // ORDINAL_POSITION
+			    aRow[16] <<= ::rtl::OUString::valueOf((long)k,10);
+			    // IS_NULLABLE
+			    aRow[17] <<= ::rtl::OUString::createFromAscii("YES");
+			    
+			    aColumns.push_back( aRow );
+				 }
+
+	     	}
+		}
+	}
+
+    return( sal_True );
+
+}
+
+sal_Bool getTypeInfos(AnyVector & aTypes)
+{
+	int   i=0;
+	while(mdb_access_types[i].typeName)
+	{
+	     Sequence< Any > aRow( 18 );
+
+	    // TYPE_NAME
+	    aRow[0] <<= ::rtl::OUString::createFromAscii(mdb_access_types[i].typeName) ;
+	    // DATA_TYPE
+	    aRow[1] <<= ::rtl::OUString::valueOf((long)mdb_access_types[i].value,10);
+	    // PRECISION
+	    aRow[2] <<=  ::rtl::OUString::valueOf((long)mdb_access_types[i].length,10);
+		// LITERAL_PREFIX
+		aRow[3] <<=  ::rtl::OUString::createFromAscii("\"");
+	    // LITERAL_SUFFIX
+	    aRow[4] <<= ::rtl::OUString::createFromAscii("\"");
+	    // CREATE_PARAMS
+	    aRow[5] <<= ::rtl::OUString::createFromAscii(mdb_access_types[i].typeName) ;
+	    // NULLABLE
+	    aRow[6] <<= ::rtl::OUString::createFromAscii("1");
+	    // CASE_SENSITIVE
+	    aRow[7] <<= ::rtl::OUString::createFromAscii("0");
+	    // SEARCHABLE. full
+	    aRow[8] <<= ::rtl::OUString::createFromAscii("3");
+	    // UNSIGNED_ATTRIBUTE
+	    aRow[9] <<= ::rtl::OUString::createFromAscii("0");
+	    // FIXED_PREC_SCALE
+	    aRow[10] <<= ::rtl::OUString::createFromAscii("1");
+	    // AUTO_INCREMENT
+	    aRow[11] <<= ::rtl::OUString::createFromAscii("0");
+	    // LOCAL_TYPE_NAME
+	    aRow[12] <<= ::rtl::OUString::createFromAscii(mdb_access_types[i].typeName) ;
+	    // MINIMUM_SCALE
+	    aRow[13] <<= ::rtl::OUString::createFromAscii("0");
+	    // MAXIMUM_SCALE
+	    aRow[14] <<= ::rtl::OUString::createFromAscii("0");
+	    // SQL_DATA_TYPE
+	    aRow[15] <<= ::rtl::OUString::createFromAscii("0");
+	    // SQL_DATETIME_SUB
+	    aRow[16] <<= ::rtl::OUString::createFromAscii("0");
+	    // NUM_PREC_RADIX
+	    aRow[17] <<= ::rtl::OUString::createFromAscii("10");
+	
+	   aTypes.push_back( aRow );
+	   i++;
+	}
+
+    return( sal_True );
+
+}
+
+sal_Bool mdb_ExecuteQuery(
+							::MdbHandle *aMdb,
+							const OString& aSqlStr,
+							AnyVector & aRows,
+						    Sequence< OUString > &seqColumns )
+{
+	if (!aMdb) return sal_False;
+	MdbSQL *sql=mdb_sql_init();
+	if (!sql) return sal_False;
+	sql->mdb=aMdb;
+	sql->max_rows = -1;
+
+	char * pTempSqlStr=strdup(aSqlStr.getStr()); 
+    if (!mdb_sql_run_query(sql,pTempSqlStr))
+	{
+        mdb_sql_reset( sql );
+            // compared with mdb_sql_exit, this seems to do one additional cleanup (see mdbsql.c)
+        sql->mdb = NULL;
+        mdb_sql_exit( sql );
+    	return sal_False;
+	}
+	free(pTempSqlStr);
+
+    unsigned int j;
+    MdbSQLColumn *sqlcol;
+    long row_count = 0;
+
+	Sequence< OUString > seq( sql->num_columns );
+
+	for (j=0;j<sql->num_columns;j++) {
+		sqlcol = (MdbSQLColumn*) g_ptr_array_index(sql->columns,j);
+		seq[j] = rtl::OUString::createFromAscii(sqlcol->name);
+		//fprintf(stdout, "%s%s", sqlcol->name, "|");
+	}
+	//fprintf(stdout,"\n");
+	
+	seqColumns = seq;
+
+
+	while((sql->max_rows == -1 || row_count < sql->max_rows)
+			&& mdb_fetch_row(sql->cur_table)) 
+	{
+		Sequence< Any > row( sql->num_columns );
+	  	for (j=0;j<sql->num_columns;j++) {
+			sqlcol = (MdbSQLColumn*) g_ptr_array_index(sql->columns,j);
+			row[j] <<= rtl::OUString::createFromAscii(static_cast<char *>(sql->bound_values[j]));
+			//fprintf(stdout, "%s%s", sql->bound_values[j], "|");
+		}
+		//fprintf(stdout,"\n");
+		aRows.push_back(row);
+	}
+    mdb_sql_reset( sql );
+        // compared with mdb_sql_exit, this seems to do one additional cleanup (see mdbsql.c)
+    sql->mdb = NULL;
+    mdb_sql_exit( sql );
+	return sal_True;
+}
+
Index: connectivity/source/drivers/mdb/mdb_wrapper.hxx
===================================================================
RCS file: connectivity/source/drivers/mdb/mdb_wrapper.hxx
diff -N connectivity/source/drivers/mdb/mdb_wrapper.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ connectivity/source/drivers/mdb/mdb_wrapper.hxx	12 Jul 2006 10:20:34 -0000	1.1.4.4
@@ -0,0 +1,119 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef _MDB_WRAPPER_HXX_
+#define _MDB_WRAPPER_HXX_
+
+#include <hash_map>
+
+#ifndef _CONNECTIVITY_FDATABASEMETADATARESULTSET_HXX_
+#include <FDatabaseMetaDataResultSet.hxx>
+#endif
+
+#ifndef _COMPHELPER_PROPERTY_ARRAY_HELPER_HXX_
+#include <comphelper/proparrhlp.hxx>
+#endif
+
+#ifndef _COMPHELPER_PROPERTYCONTAINER_HXX_
+#include <comphelper/propertycontainer.hxx>
+#endif
+
+#include <com/sun/star/lang/XInitialization.hpp>
+
+//#include <rtl/ref.hxx>
+//#include <rtl/byteseq.hxx>
+
+#include<com/sun/star/sdbc/TransactionIsolation.hpp>
+#include<com/sun/star/sdbc/ResultSetType.hpp>
+#include<com/sun/star/sdbc/XPreparedStatement.hpp>
+#include<com/sun/star/sdbc/XParameters.hpp>
+#include<com/sun/star/sdbc/DataType.hpp>
+#include<com/sun/star/sdbc/ColumnValue.hpp>
+
+using ::osl::MutexGuard;
+
+using ::rtl::OUString;
+using ::rtl::OString;
+
+using com::sun::star::sdbc::SQLException;
+using com::sun::star::sdbc::XStatement;
+using com::sun::star::sdbc::XResultSet;
+using com::sun::star::sdbc::XRow;
+using com::sun::star::sdbc::XCloseable;
+using com::sun::star::sdbc::XParameters;
+using com::sun::star::sdbc::XPreparedStatement;
+
+using com::sun::star::uno::RuntimeException;
+using com::sun::star::uno::Sequence;
+
+using com::sun::star::uno::Reference;
+using com::sun::star::uno::Sequence;
+using com::sun::star::uno::Any;
+using com::sun::star::uno::makeAny;
+using com::sun::star::uno::UNO_QUERY;
+
+typedef std::vector< Sequence< Any > > AnyVector;
+
+
+extern "C"
+{
+
+#ifdef SYSTEM_MDBTOOLS
+#include <mdbsql.h>
+//#include <mdbtools.h>
+#else
+#include <mdbtools/mdbsql.h>
+//#include <mdbtools/mdbtools.h>
+#endif
+}
+
+::MdbHandle * OpenMDB(char * sFileName);
+void CloseMDB(::MdbHandle * mdb);
+
+sal_Bool getTableStrings( ::MdbHandle *aMdb,
+                         ::std::vector< ::rtl::OUString >&   _rStrings,
+                             rtl_TextEncoding encoding);
+
+sal_Bool getColumnStrings( ::MdbHandle *aMdb,
+							::rtl::OUString aTableName,
+                         	AnyVector  & aColumns,
+                             rtl_TextEncoding encoding);
+sal_Bool getTypeInfos(AnyVector & aTypes);
+sal_Bool mdb_ExecuteQuery(::MdbHandle *aMdb,
+							const ::rtl::OString& aSqlStr,
+							AnyVector & aRows,
+						    Sequence< OUString > &seqColumns );
+
+#endif //_MDB_WRAPPER_HXX_
Index: solenv/config/ssrc680.ini
===================================================================
RCS file: /cvs/tools/solenv/config/ssrc680.ini,v
retrieving revision 1.100
retrieving revision 1.85.12.7
diff -u -p -u -p -r1.100 -r1.85.12.7
--- solenv/config/ssrc680.ini	5 Jul 2006 21:55:41 -0000	1.100
+++ solenv/config/ssrc680.ini	10 Jul 2006 10:36:03 -0000	1.85.12.7
@@ -105,6 +105,7 @@ common
 			ENABLE_FONTCONFIG TRUE
             ENABLE_GTK TRUE
             ENABLE_GNOMEVFS TRUE
+            ENABLE_ACCESS YES
 			NEW_JAR_PACK TRUE
 			PCLEAN_PATH xxx
 			CONFIG_PROJECT config_office
Index: solenv/inc/pkg_config.mk
===================================================================
RCS file: /cvs/tools/solenv/inc/pkg_config.mk,v
retrieving revision 1.3
retrieving revision 1.3.156.1
diff -u -p -u -p -r1.3 -r1.3.156.1
--- solenv/inc/pkg_config.mk	8 Sep 2005 09:36:07 -0000	1.3
+++ solenv/inc/pkg_config.mk	21 Dec 2005 14:11:59 -0000	1.3.156.1
@@ -38,12 +38,16 @@
 .IF "$(PKGCONFIG_ROOT)"!=""
 PKGCONFIG=$(PKGCONFIG_ROOT)$/bin$/pkg-config
 PKG_CONFIG_PATH:=$(PKGCONFIG_ROOT)$/lib$/pkgconfig
-.EXPORT : PKG_CONFIG_PATH
+PKG_CONFIG:=$(PKGCONFIG)
+LD_LIBRARY_PATH!:=$(LD_LIBRARY_PATH):$(PKGCONFIG_ROOT)$/lib
+.EXPORT : PKG_CONFIG_PATH PKG_CONFIG LD_LIBRARY_PATH
 PKGCONFIG_PREFIX=--define-variable=prefix=$(PKGCONFIG_ROOT)
 .ELSE           # "$(OS)"=="SOLARIS"
 PKGCONFIG=pkg-config
 .ENDIF          # "$(OS)"=="SOLARIS"
 
+.IF "$(PKGCONFIG_MODULES)"!=""
 PKGCONFIG_CFLAGS:=$(shell $(PKGCONFIG) $(PKGCONFIG_PREFIX) --cflags $(PKGCONFIG_MODULES))
 PKGCONFIG_LIBS:=$(shell $(PKGCONFIG) $(PKGCONFIG_PREFIX) --libs $(PKGCONFIG_MODULES))
 CFLAGS+=$(PKGCONFIG_CFLAGS)
+.ENDIF			# "$(PKGCONFIG_MODULES)"!=""
Index: solenv/inc/tg_ext.mk
===================================================================
RCS file: /cvs/tools/solenv/inc/tg_ext.mk,v
retrieving revision 1.69
retrieving revision 1.66.132.3
diff -u -p -u -p -r1.69 -r1.66.132.3
--- solenv/inc/tg_ext.mk	5 Jul 2006 21:58:11 -0000	1.69
+++ solenv/inc/tg_ext.mk	10 Jul 2006 10:38:08 -0000	1.66.132.3
@@ -79,7 +79,7 @@ PATCH_FILE_DEP:=$(PRJ)$/$(NEW_PATCH_FILE
 .ENDIF			# "$(PATCH_FILE_NAME)"=="none" ||	"$(PATCH_FILE_NAME)"==""
 
 .IF "$(TAR_EXCLUDES)"!=""
-TAR_EXCLUDE_SWITCH=--exclude=$(TAR_EXCLUDES)
+TAR_EXCLUDE_SWITCH=$(foreach,i,$(TAR_EXCLUDES) --exclude=$i)
 .ENDIF          # "$(TAR_EXCLUDES)"!=""
 
 # Clean PWD to let a build_action=dmake set it with new value. (See iz61212)
Index: config_office/aclocal.m4
===================================================================
RCS file: /cvs/tools/config_office/aclocal.m4,v
retrieving revision 1.5
retrieving revision 1.5.150.2
diff -u -p -u -p -r1.5 -r1.5.150.2
--- config_office/aclocal.m4	11 Oct 2004 13:47:39 -0000	1.5
+++ config_office/aclocal.m4	31 Oct 2005 11:42:49 -0000	1.5.150.2
@@ -1,7 +1,7 @@
-# generated automatically by aclocal 1.9.1 -*- Autoconf -*-
+# generated automatically by aclocal 1.9.5 -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
-# Free Software Foundation, Inc.
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005  Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -11,11 +11,936 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
+# iconv.m4 serial AM4 (gettext-0.11.3)
+dnl Copyright (C) 2000-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_ICONV_LINKFLAGS_BODY],
+[
+  dnl Prerequisites of AC_LIB_LINKFLAGS_BODY.
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([iconv])
+])
+
+AC_DEFUN([AM_ICONV_LINK],
+[
+  dnl Some systems have iconv in libc, some have it in libiconv (OSF/1 and
+  dnl those with the standalone portable GNU libiconv installed).
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_REQUIRE([AM_ICONV_LINKFLAGS_BODY])
+
+  dnl Add $INCICONV to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed libiconv and not disabled its use
+  dnl via --without-libiconv-prefix, he wants to use it. The first
+  dnl AC_TRY_LINK will then fail, the second AC_TRY_LINK will succeed.
+  am_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INCICONV])
+
+  AC_CACHE_CHECK(for iconv, am_cv_func_iconv, [
+    am_cv_func_iconv="no, consider installing GNU libiconv"
+    am_cv_lib_iconv=no
+    AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+      [iconv_t cd = iconv_open("","");
+       iconv(cd,NULL,NULL,NULL,NULL);
+       iconv_close(cd);],
+      am_cv_func_iconv=yes)
+    if test "$am_cv_func_iconv" != yes; then
+      am_save_LIBS="$LIBS"
+      LIBS="$LIBS $LIBICONV"
+      AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+        [iconv_t cd = iconv_open("","");
+         iconv(cd,NULL,NULL,NULL,NULL);
+         iconv_close(cd);],
+        am_cv_lib_iconv=yes
+        am_cv_func_iconv=yes)
+      LIBS="$am_save_LIBS"
+    fi
+  ])
+  if test "$am_cv_func_iconv" = yes; then
+    AC_DEFINE(HAVE_ICONV, 1, [Define if you have the iconv() function.])
+  fi
+  if test "$am_cv_lib_iconv" = yes; then
+    AC_MSG_CHECKING([how to link with libiconv])
+    AC_MSG_RESULT([$LIBICONV])
+  else
+    dnl If $LIBICONV didn't lead to a usable library, we don't need $INCICONV
+    dnl either.
+    CPPFLAGS="$am_save_CPPFLAGS"
+    LIBICONV=
+    LTLIBICONV=
+  fi
+  AC_SUBST(LIBICONV)
+  AC_SUBST(LTLIBICONV)
+])
+
+AC_DEFUN([AM_ICONV],
+[
+  AM_ICONV_LINK
+  if test "$am_cv_func_iconv" = yes; then
+    AC_MSG_CHECKING([for iconv declaration])
+    AC_CACHE_VAL(am_cv_proto_iconv, [
+      AC_TRY_COMPILE([
+#include <stdlib.h>
+#include <iconv.h>
+extern
+#ifdef __cplusplus
+"C"
+#endif
+#if defined(__STDC__) || defined(__cplusplus)
+size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);
+#else
+size_t iconv();
+#endif
+], [], am_cv_proto_iconv_arg1="", am_cv_proto_iconv_arg1="const")
+      am_cv_proto_iconv="extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);"])
+    am_cv_proto_iconv=`echo "[$]am_cv_proto_iconv" | tr -s ' ' | sed -e 's/( /(/'`
+    AC_MSG_RESULT([$]{ac_t:-
+         }[$]am_cv_proto_iconv)
+    AC_DEFINE_UNQUOTED(ICONV_CONST, $am_cv_proto_iconv_arg1,
+      [Define as const if the declaration of iconv() needs const.])
+  fi
+])
+
+# lib-ld.m4 serial 3 (gettext-0.13)
+dnl Copyright (C) 1996-2003 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl Subroutines of libtool.m4,
+dnl with replacements s/AC_/AC_LIB/ and s/lt_cv/acl_cv/ to avoid collision
+dnl with libtool.m4.
+
+dnl From libtool-1.4. Sets the variable with_gnu_ld to yes or no.
+AC_DEFUN([AC_LIB_PROG_LD_GNU],
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], acl_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU ld's only accept -v.
+case `$LD -v 2>&1 </dev/null` in
+*GNU* | *'with BFD'*)
+  acl_cv_prog_gnu_ld=yes ;;
+*)
+  acl_cv_prog_gnu_ld=no ;;
+esac])
+with_gnu_ld=$acl_cv_prog_gnu_ld
+])
+
+dnl From libtool-1.4. Sets the variable LD.
+AC_DEFUN([AC_LIB_PROG_LD],
+[AC_ARG_WITH(gnu-ld,
+[  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]],
+test "$withval" = no || with_gnu_ld=yes, with_gnu_ld=no)
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+# Prepare PATH_SEPARATOR.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by GCC])
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [[\\/]* | [A-Za-z]:[\\/]*)]
+      [re_direlt='/[^/][^/]*/\.\./']
+      # Canonicalize the path of ld
+      ac_prog=`echo $ac_prog| sed 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| sed "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(acl_cv_path_LD,
+[if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      acl_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      case `"$acl_cv_path_LD" -v 2>&1 < /dev/null` in
+      *GNU* | *'with BFD'*)
+	test "$with_gnu_ld" != no && break ;;
+      *)
+	test "$with_gnu_ld" != yes && break ;;
+      esac
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  acl_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$acl_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+AC_LIB_PROG_LD_GNU
+])
+
+# lib-link.m4 serial 4 (gettext-0.12)
+dnl Copyright (C) 2001-2003 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+dnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and
+dnl augments the CPPFLAGS variable.
+AC_DEFUN([AC_LIB_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  define([Name],[translit([$1],[./-], [___])])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [
+    AC_LIB_LINKFLAGS_BODY([$1], [$2])
+    ac_cv_lib[]Name[]_libs="$LIB[]NAME"
+    ac_cv_lib[]Name[]_ltlibs="$LTLIB[]NAME"
+    ac_cv_lib[]Name[]_cppflags="$INC[]NAME"
+  ])
+  LIB[]NAME="$ac_cv_lib[]Name[]_libs"
+  LTLIB[]NAME="$ac_cv_lib[]Name[]_ltlibs"
+  INC[]NAME="$ac_cv_lib[]Name[]_cppflags"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the
+  dnl results of this search when this library appears as a dependency.
+  HAVE_LIB[]NAME=yes
+  undefine([Name])
+  undefine([NAME])
+])
+
+dnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode)
+dnl searches for libname and the libraries corresponding to explicit and
+dnl implicit dependencies, together with the specified include files and
+dnl the ability to compile and link the specified testcode. If found, it
+dnl sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME} and
+dnl LTLIB${NAME} variables and augments the CPPFLAGS variable, and
+dnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs
+dnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.
+AC_DEFUN([AC_LIB_HAVE_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  define([Name],[translit([$1],[./-], [___])])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+
+  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([$1], [$2])
+
+  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed lib[]Name and not disabled its use
+  dnl via --without-lib[]Name-prefix, he wants to use it.
+  ac_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+
+  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [
+    ac_save_LIBS="$LIBS"
+    LIBS="$LIBS $LIB[]NAME"
+    AC_TRY_LINK([$3], [$4], [ac_cv_lib[]Name=yes], [ac_cv_lib[]Name=no])
+    LIBS="$ac_save_LIBS"
+  ])
+  if test "$ac_cv_lib[]Name" = yes; then
+    HAVE_LIB[]NAME=yes
+    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the $1 library.])
+    AC_MSG_CHECKING([how to link with lib[]$1])
+    AC_MSG_RESULT([$LIB[]NAME])
+  else
+    HAVE_LIB[]NAME=no
+    dnl If $LIB[]NAME didn't lead to a usable library, we don't need
+    dnl $INC[]NAME either.
+    CPPFLAGS="$ac_save_CPPFLAGS"
+    LIB[]NAME=
+    LTLIB[]NAME=
+  fi
+  AC_SUBST([HAVE_LIB]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  undefine([Name])
+  undefine([NAME])
+])
+
+dnl Determine the platform dependent parameters needed to use rpath:
+dnl libext, shlibext, hardcode_libdir_flag_spec, hardcode_libdir_separator,
+dnl hardcode_direct, hardcode_minus_L.
+AC_DEFUN([AC_LIB_RPATH],
+[
+  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS
+  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld
+  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host
+  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir
+  AC_CACHE_CHECK([for shared library run path origin], acl_cv_rpath, [
+    CC="$CC" GCC="$GCC" LDFLAGS="$LDFLAGS" LD="$LD" with_gnu_ld="$with_gnu_ld" \
+    ${CONFIG_SHELL-/bin/sh} "$ac_aux_dir/config.rpath" "$host" > conftest.sh
+    . ./conftest.sh
+    rm -f ./conftest.sh
+    acl_cv_rpath=done
+  ])
+  wl="$acl_cv_wl"
+  libext="$acl_cv_libext"
+  shlibext="$acl_cv_shlibext"
+  hardcode_libdir_flag_spec="$acl_cv_hardcode_libdir_flag_spec"
+  hardcode_libdir_separator="$acl_cv_hardcode_libdir_separator"
+  hardcode_direct="$acl_cv_hardcode_direct"
+  hardcode_minus_L="$acl_cv_hardcode_minus_L"
+  dnl Determine whether the user wants rpath handling at all.
+  AC_ARG_ENABLE(rpath,
+    [  --disable-rpath         do not hardcode runtime library paths],
+    :, enable_rpath=yes)
+])
+
+dnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.
+AC_DEFUN([AC_LIB_LINKFLAGS_BODY],
+[
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_LIB_ARG_WITH([lib$1-prefix],
+[  --with-lib$1-prefix[=DIR]  search for lib$1 in DIR/include and DIR/lib
+  --without-lib$1-prefix     don't search for lib$1 in includedir and libdir],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/lib"
+      fi
+    fi
+])
+  dnl Search the library and its dependencies in $additional_libdir and
+  dnl $LDFLAGS. Using breadth-first-seach.
+  LIB[]NAME=
+  LTLIB[]NAME=
+  INC[]NAME=
+  rpathdirs=
+  ltrpathdirs=
+  names_already_handled=
+  names_next_round='$1 $2'
+  while test -n "$names_next_round"; do
+    names_this_round="$names_next_round"
+    names_next_round=
+    for name in $names_this_round; do
+      already_handled=
+      for n in $names_already_handled; do
+        if test "$n" = "$name"; then
+          already_handled=yes
+          break
+        fi
+      done
+      if test -z "$already_handled"; then
+        names_already_handled="$names_already_handled $name"
+        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS
+        dnl or AC_LIB_HAVE_LINKFLAGS call.
+        uppername=`echo "$name" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`
+        eval value=\"\$HAVE_LIB$uppername\"
+        if test -n "$value"; then
+          if test "$value" = yes; then
+            eval value=\"\$LIB$uppername\"
+            test -z "$value" || LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$value"
+            eval value=\"\$LTLIB$uppername\"
+            test -z "$value" || LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$value"
+          else
+            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined
+            dnl that this library doesn't exist. So just drop it.
+            :
+          fi
+        else
+          dnl Search the library lib$name in $additional_libdir and $LDFLAGS
+          dnl and the already constructed $LIBNAME/$LTLIBNAME.
+          found_dir=
+          found_la=
+          found_so=
+          found_a=
+          if test $use_additional = yes; then
+            if test -n "$shlibext" && test -f "$additional_libdir/lib$name.$shlibext"; then
+              found_dir="$additional_libdir"
+              found_so="$additional_libdir/lib$name.$shlibext"
+              if test -f "$additional_libdir/lib$name.la"; then
+                found_la="$additional_libdir/lib$name.la"
+              fi
+            else
+              if test -f "$additional_libdir/lib$name.$libext"; then
+                found_dir="$additional_libdir"
+                found_a="$additional_libdir/lib$name.$libext"
+                if test -f "$additional_libdir/lib$name.la"; then
+                  found_la="$additional_libdir/lib$name.la"
+                fi
+              fi
+            fi
+          fi
+          if test "X$found_dir" = "X"; then
+            for x in $LDFLAGS $LTLIB[]NAME; do
+              AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+              case "$x" in
+                -L*)
+                  dir=`echo "X$x" | sed -e 's/^X-L//'`
+                  if test -n "$shlibext" && test -f "$dir/lib$name.$shlibext"; then
+                    found_dir="$dir"
+                    found_so="$dir/lib$name.$shlibext"
+                    if test -f "$dir/lib$name.la"; then
+                      found_la="$dir/lib$name.la"
+                    fi
+                  else
+                    if test -f "$dir/lib$name.$libext"; then
+                      found_dir="$dir"
+                      found_a="$dir/lib$name.$libext"
+                      if test -f "$dir/lib$name.la"; then
+                        found_la="$dir/lib$name.la"
+                      fi
+                    fi
+                  fi
+                  ;;
+              esac
+              if test "X$found_dir" != "X"; then
+                break
+              fi
+            done
+          fi
+          if test "X$found_dir" != "X"; then
+            dnl Found the library.
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name"
+            if test "X$found_so" != "X"; then
+              dnl Linking with a shared library. We attempt to hardcode its
+              dnl directory into the executable's runpath, unless it's the
+              dnl standard /usr/lib.
+              if test "$enable_rpath" = no || test "X$found_dir" = "X/usr/lib"; then
+                dnl No hardcoding is needed.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+              else
+                dnl Use an explicit option to hardcode DIR into the resulting
+                dnl binary.
+                dnl Potentially add DIR to ltrpathdirs.
+                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                haveit=
+                for x in $ltrpathdirs; do
+                  if test "X$x" = "X$found_dir"; then
+                    haveit=yes
+                    break
+                  fi
+                done
+                if test -z "$haveit"; then
+                  ltrpathdirs="$ltrpathdirs $found_dir"
+                fi
+                dnl The hardcoding into $LIBNAME is system dependent.
+                if test "$hardcode_direct" = yes; then
+                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the
+                  dnl resulting binary.
+                  LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                else
+                  if test -n "$hardcode_libdir_flag_spec" && test "$hardcode_minus_L" = no; then
+                    dnl Use an explicit option to hardcode DIR into the resulting
+                    dnl binary.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    dnl Potentially add DIR to rpathdirs.
+                    dnl The rpathdirs will be appended to $LIBNAME at the end.
+                    haveit=
+                    for x in $rpathdirs; do
+                      if test "X$x" = "X$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      rpathdirs="$rpathdirs $found_dir"
+                    fi
+                  else
+                    dnl Rely on "-L$found_dir".
+                    dnl But don't add it if it's already contained in the LDFLAGS
+                    dnl or the already constructed $LIBNAME
+                    haveit=
+                    for x in $LDFLAGS $LIB[]NAME; do
+                      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                      if test "X$x" = "X-L$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir"
+                    fi
+                    if test "$hardcode_minus_L" != no; then
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    else
+                      dnl We cannot use $hardcode_runpath_var and LD_RUN_PATH
+                      dnl here, because this doesn't fit in flags passed to the
+                      dnl compiler. So give up. No hardcoding. This affects only
+                      dnl very old systems.
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+                    fi
+                  fi
+                fi
+              fi
+            else
+              if test "X$found_a" != "X"; then
+                dnl Linking with a static library.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_a"
+              else
+                dnl We shouldn't come here, but anyway it's good to have a
+                dnl fallback.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name"
+              fi
+            fi
+            dnl Assume the include files are nearby.
+            additional_includedir=
+            case "$found_dir" in
+              */lib | */lib/)
+                basedir=`echo "X$found_dir" | sed -e 's,^X,,' -e 's,/lib/*$,,'`
+                additional_includedir="$basedir/include"
+                ;;
+            esac
+            if test "X$additional_includedir" != "X"; then
+              dnl Potentially add $additional_includedir to $INCNAME.
+              dnl But don't add it
+              dnl   1. if it's the standard /usr/include,
+              dnl   2. if it's /usr/local/include and we are using GCC on Linux,
+              dnl   3. if it's already present in $CPPFLAGS or the already
+              dnl      constructed $INCNAME,
+              dnl   4. if it doesn't exist as a directory.
+              if test "X$additional_includedir" != "X/usr/include"; then
+                haveit=
+                if test "X$additional_includedir" = "X/usr/local/include"; then
+                  if test -n "$GCC"; then
+                    case $host_os in
+                      linux*) haveit=yes;;
+                    esac
+                  fi
+                fi
+                if test -z "$haveit"; then
+                  for x in $CPPFLAGS $INC[]NAME; do
+                    AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                    if test "X$x" = "X-I$additional_includedir"; then
+                      haveit=yes
+                      break
+                    fi
+                  done
+                  if test -z "$haveit"; then
+                    if test -d "$additional_includedir"; then
+                      dnl Really add $additional_includedir to $INCNAME.
+                      INC[]NAME="${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir"
+                    fi
+                  fi
+                fi
+              fi
+            fi
+            dnl Look for dependencies.
+            if test -n "$found_la"; then
+              dnl Read the .la file. It defines the variables
+              dnl dlname, library_names, old_library, dependency_libs, current,
+              dnl age, revision, installed, dlopen, dlpreopen, libdir.
+              save_libdir="$libdir"
+              case "$found_la" in
+                */* | *\\*) . "$found_la" ;;
+                *) . "./$found_la" ;;
+              esac
+              libdir="$save_libdir"
+              dnl We use only dependency_libs.
+              for dep in $dependency_libs; do
+                case "$dep" in
+                  -L*)
+                    additional_libdir=`echo "X$dep" | sed -e 's/^X-L//'`
+                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.
+                    dnl But don't add it
+                    dnl   1. if it's the standard /usr/lib,
+                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,
+                    dnl   3. if it's already present in $LDFLAGS or the already
+                    dnl      constructed $LIBNAME,
+                    dnl   4. if it doesn't exist as a directory.
+                    if test "X$additional_libdir" != "X/usr/lib"; then
+                      haveit=
+                      if test "X$additional_libdir" = "X/usr/local/lib"; then
+                        if test -n "$GCC"; then
+                          case $host_os in
+                            linux*) haveit=yes;;
+                          esac
+                        fi
+                      fi
+                      if test -z "$haveit"; then
+                        haveit=
+                        for x in $LDFLAGS $LIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LIBNAME.
+                            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                        haveit=
+                        for x in $LDFLAGS $LTLIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LTLIBNAME.
+                            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                      fi
+                    fi
+                    ;;
+                  -R*)
+                    dir=`echo "X$dep" | sed -e 's/^X-R//'`
+                    if test "$enable_rpath" != no; then
+                      dnl Potentially add DIR to rpathdirs.
+                      dnl The rpathdirs will be appended to $LIBNAME at the end.
+                      haveit=
+                      for x in $rpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        rpathdirs="$rpathdirs $dir"
+                      fi
+                      dnl Potentially add DIR to ltrpathdirs.
+                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                      haveit=
+                      for x in $ltrpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        ltrpathdirs="$ltrpathdirs $dir"
+                      fi
+                    fi
+                    ;;
+                  -l*)
+                    dnl Handle this in the next round.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's/^X-l//'`
+                    ;;
+                  *.la)
+                    dnl Handle this in the next round. Throw away the .la's
+                    dnl directory; it is already contained in a preceding -L
+                    dnl option.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\.la$,,'`
+                    ;;
+                  *)
+                    dnl Most likely an immediate library name.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$dep"
+                    LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep"
+                    ;;
+                esac
+              done
+            fi
+          else
+            dnl Didn't find the library; assume it is in the system directories
+            dnl known to the linker and runtime loader. (All the system
+            dnl directories known to the linker should also be known to the
+            dnl runtime loader, otherwise the system is severely misconfigured.)
+            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name"
+          fi
+        fi
+      fi
+    done
+  done
+  if test "X$rpathdirs" != "X"; then
+    if test -n "$hardcode_libdir_separator"; then
+      dnl Weird platform: only the last -rpath option counts, the user must
+      dnl pass all path elements in one option. We can arrange that for a
+      dnl single library, but not when more than one $LIBNAMEs are used.
+      alldirs=
+      for found_dir in $rpathdirs; do
+        alldirs="${alldirs}${alldirs:+$hardcode_libdir_separator}$found_dir"
+      done
+      dnl Note: hardcode_libdir_flag_spec uses $libdir and $wl.
+      acl_save_libdir="$libdir"
+      libdir="$alldirs"
+      eval flag=\"$hardcode_libdir_flag_spec\"
+      libdir="$acl_save_libdir"
+      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+    else
+      dnl The -rpath options are cumulative.
+      for found_dir in $rpathdirs; do
+        acl_save_libdir="$libdir"
+        libdir="$found_dir"
+        eval flag=\"$hardcode_libdir_flag_spec\"
+        libdir="$acl_save_libdir"
+        LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+      done
+    fi
+  fi
+  if test "X$ltrpathdirs" != "X"; then
+    dnl When using libtool, the option that works for both libraries and
+    dnl executables is -R. The -R options are cumulative.
+    for found_dir in $ltrpathdirs; do
+      LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir"
+    done
+  fi
+])
+
+dnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,
+dnl unless already present in VAR.
+dnl Works only for CPPFLAGS, not for LIB* variables because that sometimes
+dnl contains two or three consecutive elements that belong together.
+AC_DEFUN([AC_LIB_APPENDTOVAR],
+[
+  for element in [$2]; do
+    haveit=
+    for x in $[$1]; do
+      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+      if test "X$x" = "X$element"; then
+        haveit=yes
+        break
+      fi
+    done
+    if test -z "$haveit"; then
+      [$1]="${[$1]}${[$1]:+ }$element"
+    fi
+  done
+])
+
+# lib-prefix.m4 serial 3 (gettext-0.13)
+dnl Copyright (C) 2001-2003 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+dnl AC_LIB_ARG_WITH is synonymous to AC_ARG_WITH in autoconf-2.13, and
+dnl similar to AC_ARG_WITH in autoconf 2.52...2.57 except that is doesn't
+dnl require excessive bracketing.
+ifdef([AC_HELP_STRING],
+[AC_DEFUN([AC_LIB_ARG_WITH], [AC_ARG_WITH([$1],[[$2]],[$3],[$4])])],
+[AC_DEFUN([AC_][LIB_ARG_WITH], [AC_ARG_WITH([$1],[$2],[$3],[$4])])])
+
+dnl AC_LIB_PREFIX adds to the CPPFLAGS and LDFLAGS the flags that are needed
+dnl to access previously installed libraries. The basic assumption is that
+dnl a user will want packages to use other packages he previously installed
+dnl with the same --prefix option.
+dnl This macro is not needed if only AC_LIB_LINKFLAGS is used to locate
+dnl libraries, but is otherwise very convenient.
+AC_DEFUN([AC_LIB_PREFIX],
+[
+  AC_BEFORE([$0], [AC_LIB_LINKFLAGS])
+  AC_REQUIRE([AC_PROG_CC])
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_LIB_ARG_WITH([lib-prefix],
+[  --with-lib-prefix[=DIR] search for libraries in DIR/include and DIR/lib
+  --without-lib-prefix    don't search for libraries in includedir and libdir],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/lib"
+      fi
+    fi
+])
+  if test $use_additional = yes; then
+    dnl Potentially add $additional_includedir to $CPPFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/include,
+    dnl   2. if it's already present in $CPPFLAGS,
+    dnl   3. if it's /usr/local/include and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_includedir" != "X/usr/include"; then
+      haveit=
+      for x in $CPPFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-I$additional_includedir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_includedir" = "X/usr/local/include"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux*) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_includedir"; then
+            dnl Really add $additional_includedir to $CPPFLAGS.
+            CPPFLAGS="${CPPFLAGS}${CPPFLAGS:+ }-I$additional_includedir"
+          fi
+        fi
+      fi
+    fi
+    dnl Potentially add $additional_libdir to $LDFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/lib,
+    dnl   2. if it's already present in $LDFLAGS,
+    dnl   3. if it's /usr/local/lib and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_libdir" != "X/usr/lib"; then
+      haveit=
+      for x in $LDFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-L$additional_libdir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_libdir" = "X/usr/local/lib"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux*) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_libdir"; then
+            dnl Really add $additional_libdir to $LDFLAGS.
+            LDFLAGS="${LDFLAGS}${LDFLAGS:+ }-L$additional_libdir"
+          fi
+        fi
+      fi
+    fi
+  fi
+])
+
+dnl AC_LIB_PREPARE_PREFIX creates variables acl_final_prefix,
+dnl acl_final_exec_prefix, containing the values to which $prefix and
+dnl $exec_prefix will expand at the end of the configure script.
+AC_DEFUN([AC_LIB_PREPARE_PREFIX],
+[
+  dnl Unfortunately, prefix and exec_prefix get only finally determined
+  dnl at the end of configure.
+  if test "X$prefix" = "XNONE"; then
+    acl_final_prefix="$ac_default_prefix"
+  else
+    acl_final_prefix="$prefix"
+  fi
+  if test "X$exec_prefix" = "XNONE"; then
+    acl_final_exec_prefix='${prefix}'
+  else
+    acl_final_exec_prefix="$exec_prefix"
+  fi
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  eval acl_final_exec_prefix=\"$acl_final_exec_prefix\"
+  prefix="$acl_save_prefix"
+])
+
+dnl AC_LIB_WITH_FINAL_PREFIX([statement]) evaluates statement, with the
+dnl variables prefix and exec_prefix bound to the values they will have
+dnl at the end of the configure script.
+AC_DEFUN([AC_LIB_WITH_FINAL_PREFIX],
+[
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  $1
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+])
+
 
 dnl PKG_CHECK_MODULES(GSTUFF, gtk+-2.0 >= 1.3 glib = 1.3.4, action-if, action-not)
 dnl defines GSTUFF_LIBS, GSTUFF_CFLAGS, see pkg-config man page
 dnl also defines GSTUFF_PKG_ERRORS on error
-AC_DEFUN(PKG_CHECK_MODULES, [
+AC_DEFUN([PKG_CHECK_MODULES], [
   succeeded=no
 
   if test -z "$PKG_CONFIG"; then
@@ -69,64 +994,50 @@ AC_DEFUN(PKG_CHECK_MODULES, [
 
 
 
-
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
 # Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
 # AM_PATH_PYTHON([MINIMUM-VERSION], [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
-
+# ---------------------------------------------------------------------------
 # Adds support for distributing Python modules and packages.  To
 # install modules, copy them to $(pythondir), using the python_PYTHON
 # automake variable.  To install a package with the same name as the
 # automake package, install to $(pkgpythondir), or use the
 # pkgpython_PYTHON automake variable.
-
+#
 # The variables $(pyexecdir) and $(pkgpyexecdir) are provided as
 # locations to install python extension modules (shared libraries).
 # Another macro is required to find the appropriate flags to compile
 # extension modules.
-
+#
 # If your package is configured with a different prefix to python,
 # users will have to add the install directory to the PYTHONPATH
 # environment variable, or create a .pth file (see the python
 # documentation for details).
-
+#
 # If the MINIMUM-VERSION argument is passed, AM_PATH_PYTHON will
 # cause an error if the version of python installed on the system
 # doesn't meet the requirement.  MINIMUM-VERSION should consist of
 # numbers and dots only.
-
 AC_DEFUN([AM_PATH_PYTHON],
  [
   dnl Find a Python interpreter.  Python versions prior to 1.5 are not
   dnl supported because the default installation locations changed from
   dnl $prefix/lib/site-python in 1.4 to $prefix/lib/python1.5/site-packages
   dnl in 1.5.
-  m4_define([_AM_PYTHON_INTERPRETER_LIST],
-            [python python2 python2.4 python2.3 python2.2 dnl
+  m4_define_default([_AM_PYTHON_INTERPRETER_LIST],
+                    [python python2 python2.4 python2.3 python2.2 dnl
 python2.1 python2.0 python1.6 python1.5])
 
   m4_if([$1],[],[
     dnl No version check is needed.
     # Find any Python interpreter.
     if test -z "$PYTHON"; then
-      PYTHON=:
-      AC_PATH_PROGS([PYTHON], _AM_PYTHON_INTERPRETER_LIST)
+      AC_PATH_PROGS([PYTHON], _AM_PYTHON_INTERPRETER_LIST, :)
     fi
     am_display_PYTHON=python
   ], [
@@ -247,22 +1158,11 @@ for i in xrange(0, 4): minverhex = (minv
 sys.exit(sys.hexversion < minverhex)"
   AS_IF([AM_RUN_LOG([$1 -c "$prog"])], [$3], [$4])])
 
-# Copyright (C) 2001, 2003 Free Software Foundation, Inc.     -*- Autoconf -*-
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2, or (at your option)
-# any later version.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
-# 02111-1307, USA.
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
 
 # AM_RUN_LOG(COMMAND)
 # -------------------
Index: config_office/configure.in
===================================================================
RCS file: /cvs/tools/config_office/configure.in,v
retrieving revision 1.168
retrieving revision 1.129.4.15
diff -u -p -u -p -r1.168 -r1.129.4.15
--- config_office/configure.in	5 Jul 2006 22:32:27 -0000	1.168
+++ config_office/configure.in	10 Jul 2006 10:46:21 -0000	1.129.4.15
@@ -122,6 +122,12 @@ AC_ARG_ENABLE(directx,
 AC_ARG_ENABLE(atlmfc,
 [  --disable-atlmfc        Disable the use of ATL/MFC for windows build.
 ],,)
+AC_ARG_ENABLE(access,
+[  --disable-access        Disable the Access import pieces (*nix only).
+],,)
+AC_ARG_WITH(system-mdbtools,
+[  --with-system-mdbtools  Use mdbtools' libraries from system
+],,)
 
 AC_ARG_ENABLE(symbols,
 [  --enable-symbols        Include debugging symbols in output.
@@ -3348,6 +3354,45 @@ else
 fi
 AC_SUBST(SYSTEM_SANE_HEADER)
 
+dnl ===================================================================
+dnl Disable the Access import pieces?
+dnl ===================================================================
+AC_MSG_CHECKING([whether to enable the Access import pieces])
+if test "$enable_access" = "no"; then
+   AC_MSG_RESULT([no])
+   ENABLE_ACCESS="NO"
+else
+   AC_MSG_RESULT([yes])
+   ENABLE_ACCESS="YES"
+   AC_MSG_CHECKING([which mdbtools to use])
+   if test -n "$with_system_mdbtools" -o -n "$with_system_libs" && \
+        test "$with_system_mdbtools" != "no"; then
+	AC_MSG_RESULT([external])
+	SYSTEM_MDBTOOLS=YES
+	PKG_CHECK_MODULES(GLIB, glib-2.0)
+   	AM_ICONV
+	if test "$am_cv_func_iconv" = "yes"; then
+      MDBTOOLS_CFLAGS=-DHAVE_ICONV
+   fi
+dnl   save_CFLAGS=$CFLAGS
+dnl	CFLAGS="$GLIB_CFLAGS -I. $MDBTOOLS_CFLAGS"
+dnl	export CFLAGS
+dnl    	AC_CHECK_HEADER(mdbsql.h, [],
+dnl        	[AC_MSG_ERROR(mdbsql.h not found. install mdbtools)], [])
+dnl    	AC_CHECK_LIB(mdbsql, mdb_sql_run_query, [],
+dnl        	[AC_MSG_ERROR(libmdbsql not found or functional)], [])
+dnl	CFLAGS=$save_CFLAGS
+dnl	export CFLAGS
+   else
+	AC_MSG_RESULT([internal])
+	SYSTEM_MDBTOOLS=NO
+   fi
+fi
+AC_SUBST(ENABLE_ACCESS)
+AC_SUBST(SYSTEM_MDBTOOLS)
+AC_SUBST(LIBICONV)
+AC_SUBST(MDBTOOLS_CFLAGS)
+
 
 dnl ===================================================================
 dnl Check for system icu
Index: config_office/set_soenv.in
===================================================================
RCS file: /cvs/tools/config_office/set_soenv.in,v
retrieving revision 1.107
retrieving revision 1.71.6.13
diff -u -p -u -p -r1.107 -r1.71.6.13
--- config_office/set_soenv.in.ark	2006-11-02 13:08:52.000000000 +0100
+++ config_office/set_soenv.in	2006-11-02 13:09:24.000000000 +0100
@@ -1775,6 +1775,10 @@ ToFile( "ENABLE_CUPS",       "@ENABLE_CU
 ToFile( "ENABLE_CUPS",       "@ENABLE_CUPS@",       "e" );
 ToFile( "ENABLE_FONTCONFIG", "@ENABLE_FONTCONFIG@", "e" );
 ToFile( "ENABLE_DIRECTX",    "@ENABLE_DIRECTX@",    "e" );
+ToFile( "ENABLE_ACCESS",     "@ENABLE_ACCESS@",    "e" );
+ToFile( "SYSTEM_MDBTOOLS",   "@SYSTEM_MDBTOOLS@",  "e" );
+ToFile( "MDBTOOLS_CFLAGS",   "@MDBTOOLS_CFLAGS@",  "e" );
+ToFile( "LIBICONV",          "@LIBICONV@",         "e" );
 ToFile( "VC_STANDARD",       "@VC_STANDARD@",      "e" );
 ToFile( "WITH_GPC",          "@WITH_GPC@",         "e" );
 ToFile( "WITH_MYSPELL_DICTS","@WITH_MYSPELL_DICTS@","e");
Index: dbaccess/source/ui/dlg/dbwiz.cxx
===================================================================
RCS file: /cvs/dba/dbaccess/source/ui/dlg/dbwiz.cxx,v
retrieving revision 1.11
retrieving revision 1.8.44.4
diff -u -p -u -p -r1.11 -r1.8.44.4
--- dbaccess/source/ui/dlg/dbwiz.cxx	20 Jun 2006 03:06:18 -0000	1.11
+++ dbaccess/source/ui/dlg/dbwiz.cxx	7 Jul 2006 15:11:54 -0000	1.8.44.4
@@ -207,7 +207,7 @@ WizardTypes::WizardState ODbTypeWizDialo
 					nNextState = WZS_INVALID_STATE;
 					break;
                 default:
-			        nNextState = CONNECTION_PAGE;
+		    nNextState = CONNECTION_PAGE;
                     break;
             }
 			break;
Index: dbaccess/source/ui/misc/dbumiscres.hrc
===================================================================
RCS file: /cvs/dba/dbaccess/source/ui/misc/dbumiscres.hrc,v
retrieving revision 1.9
retrieving revision 1.7.44.3
diff -u -p -u -p -r1.9 -r1.7.44.3
--- dbaccess/source/ui/misc/dbumiscres.hrc	28 Feb 2006 10:36:49 -0000	1.9
+++ dbaccess/source/ui/misc/dbumiscres.hrc	3 Mar 2006 14:53:44 -0000	1.7.44.3
@@ -60,8 +60,9 @@
 #define STR_KAB					19
 #define STR_EMBEDDED			20
 #define STR_THUNDERBIRD			21
+#define STR_MDBFILE			22
 
-#define STR_END					STR_THUNDERBIRD + 1
+#define STR_END					STR_MDBFILE + 1
 
 #endif // _DBU_MISCRES_HRC_
 
Index: dbaccess/source/ui/misc/dbumiscres.src
===================================================================
RCS file: /cvs/dba/dbaccess/source/ui/misc/dbumiscres.src,v
retrieving revision 1.71
retrieving revision 1.69.36.3
diff -u -p -u -p -r1.71 -r1.69.36.3
--- dbaccess/source/ui/misc/dbumiscres.src	28 Feb 2006 10:37:01 -0000	1.71
+++ dbaccess/source/ui/misc/dbumiscres.src	3 Mar 2006 14:53:49 -0000	1.69.36.3
@@ -79,6 +79,10 @@ Resource RSC_DATASOURCE_TYPES
 	{
 		Text  ="sdbc:ado:access:PROVIDER=Microsoft.Jet.OLEDB.4.0;DATA SOURCE=";
 	};
+	String STR_MDBFILE
+	{
+		Text  ="sdbc:mdb:";
+	};
 	String STR_FLAT
 	{
 		Text  ="sdbc:flat:";
@@ -177,6 +181,11 @@ Resource RSC_DATASOURCE_TYPE_UINAMES
 		Text [ de ] = "Microsoft Access";
 		Text[ en-US ] = "Microsoft Access";
 	};
+	String STR_MDBFILE
+	{
+		Text [ de ] = "Microsoft Access";
+		Text[ en-US ] = "Microsoft Access";
+	};
 	String STR_FLAT
 	{
 		Text [ de ] = "Text";
Index: dbaccess/source/ui/misc/dsntypes.cxx
===================================================================
RCS file: /cvs/dba/dbaccess/source/ui/misc/dsntypes.cxx,v
retrieving revision 1.30
retrieving revision 1.27.36.7
diff -u -p -u -p -r1.30 -r1.27.36.7
--- dbaccess/source/ui/misc/dsntypes.cxx	20 Jun 2006 03:23:37 -0000	1.30
+++ dbaccess/source/ui/misc/dsntypes.cxx	7 Jul 2006 15:30:47 -0000	1.27.36.7
@@ -399,7 +399,7 @@ sal_Bool ODsnTypeCollection::supportsTab
 			case DST_DBASE:
 			case DST_ADABAS:
 			case DST_ADO:
-            case DST_MSACCESS:
+			case DST_MSACCESS:
 			case DST_MYSQL_ODBC:
 			case DST_ODBC:
 			case DST_MYSQL_JDBC:
@@ -423,7 +423,7 @@ sal_Bool ODsnTypeCollection::supportsBro
 		case DST_CALC:
 		case DST_ADABAS:
 		case DST_ADO:
-        case DST_MSACCESS:
+		case DST_MSACCESS:
 		case DST_MYSQL_ODBC:
 		case DST_ODBC:
 		case DST_MOZILLA:
@@ -473,7 +473,7 @@ sal_Bool ODsnTypeCollection::hasAuthenti
 		case DST_ODBC:
 		case DST_ADO:
 		case DST_LDAP:
-        case DST_CALC:
+        	case DST_CALC:
 			return sal_True;
 		case DST_MSACCESS:
 		case DST_MOZILLA:
@@ -529,7 +529,11 @@ DATASOURCE_TYPE ODsnTypeCollection::impl
 		return DST_ODBC;
 	if (_rDsn.EqualsIgnoreCaseAscii("sdbc:dbase", 0, nSeparator))
 		return DST_DBASE;
-
+#ifdef UNX
+	if (_rDsn.EqualsIgnoreCaseAscii("sdbc:mdb:", 0, nSeparator))
+		return DST_MSACCESS;
+#endif
+#ifdef WNT
 	if (_rDsn.EqualsIgnoreCaseAscii("sdbc:ado:", 0, nSeparator))
 	{
 		nSeparator = _rDsn.Search((sal_Unicode)':', nSeparator + 1);
@@ -537,6 +541,7 @@ DATASOURCE_TYPE ODsnTypeCollection::impl
 			return DST_MSACCESS;
 		return DST_ADO;
 	}
+#endif
 	if (_rDsn.EqualsIgnoreCaseAscii("sdbc:flat:", 0, nSeparator))
 		return DST_FLAT;
 	if (_rDsn.EqualsIgnoreCaseAscii("sdbc:calc:", 0, nSeparator))
