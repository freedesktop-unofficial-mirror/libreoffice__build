Index: sw/source/filter/ww8/ww8par.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8par.cxx,v
retrieving revision 1.136
retrieving revision 1.131.12.4
diff -w -u -r1.136 -r1.131.12.4
--- sw/source/filter/ww8/ww8par.cxx	18 May 2004 15:50:31 -0000	1.136
+++ sw/source/filter/ww8/ww8par.cxx	13 Jul 2004 12:44:07 -0000	1.131.12.4
@@ -73,13 +73,28 @@
 #include <rtl/tencinfo.h>
 #endif
 
-#ifndef _SVSTOR_HXX //autogen
+#ifndef _SVSTOR_HXX
 #include <so3/svstor.hxx>
 #endif
 
-#ifndef _SFXDOCINF_HXX //autogen
+#ifndef _SFXDOCINF_HXX
 #include <sfx2/docinf.hxx>
 #endif
+#ifndef _SFXDOCFILE_HXX
+#include <sfx2/docfile.hxx>
+#endif
+
+#ifndef _URLOBJ_HXX
+#include <tools/urlobj.hxx>
+#endif
+#ifndef _UNOTOOLS_TEMPFILE_HXX
+#include <unotools/tempfile.hxx>
+#endif
+#ifndef _SFXECODE_HXX
+#include <svtools/sfxecode.hxx>
+#endif
+
+#include <svtools/docpasswdrequest.hxx>
 
 #ifndef _HINTIDS_HXX
 #include <hintids.hxx>
@@ -121,6 +136,12 @@
 #ifndef _MSDFFIMP_HXX
 #include <svx/msdffimp.hxx>
 #endif
+#ifndef _SVXERR_HXX
+#include <svx/svxerr.hxx>
+#endif
+#ifndef SVX_MSCODEC_HXX
+#include <svx/mscodec.hxx>
+#endif
 #ifndef _SVDMODEL_HXX
 #include <svx/svdmodel.hxx>
 #endif
@@ -254,6 +274,12 @@
 #ifndef _COM_SUN_STAR_DOCUMENT_PRINTERINDEPENDENTLAYOUT_HPP_
 #include <com/sun/star/document/PrinterIndependentLayout.hpp>
 #endif
+#ifndef _COM_SUN_STAR_TASK_XINTERACTIONHANDLER_HPP_
+#include <com/sun/star/task/XInteractionHandler.hpp>
+#endif
+#ifndef _COM_SUN_STAR_TASK_XINTERACTIONREQUEST_HPP_
+#include <com/sun/star/task/XInteractionRequest.hpp>
+#endif
 #ifndef _COMPHELPER_EXTRACT_HXX_
 #include <comphelper/extract.hxx>
 #endif
@@ -1599,7 +1625,7 @@
 
 void SwWW8ImplReader::ImportDopTypography(const WW8DopTypography &rTypo)
 {
-    using namespace ::com::sun::star;
+    using namespace com::sun::star;
     switch (rTypo.iLevelOfKinsoku)
     {
 #if 0
@@ -3613,14 +3639,14 @@
     }
 }
 
-ULONG SwWW8ImplReader::LoadDoc1( SwPaM& rPaM ,WW8Glossary *pGloss)
+ULONG SwWW8ImplReader::CoreLoad(WW8Glossary *pGloss, const SwPosition &rPos)
 {
     ULONG nErrRet = 0;
 
     if (mbNewDoc && pStg && !pGloss)
         ReadDocInfo();
 
-    pPaM = new SwPaM( *rPaM.GetPoint() );
+    pPaM = new SwPaM(rPos);
 
     pCtrlStck = new SwWW8FltControlStack( &rDoc, nFieldFlags, *this );
 
@@ -3641,92 +3667,14 @@
 
     USHORT eMode = REDLINE_SHOW_INSERT;
 
-    // enum-para mitgeben, welche Versions-Nummern erlaubt sind: ww6, ww8, ...
-
-    if (pGloss)
-        pWwFib = pGloss->GetFib();
-    else
-        pWwFib = new WW8Fib( *pStrm, nWantedVersion );  // Fib einlesen
-
-    if ( pWwFib->nFibError )
-    {           // ERR_NO_WW8_FILE
-        nErrRet = ERR_SWG_READ_ERROR;               // oder ERR_SW6_READ_ERROR
-    }
-    else if( pWwFib->fEncrypted )
-    {
-        nErrRet = ERR_SW6_PASSWD;                   // gecryptet geht nicht
-
-
-
-        // Annotation:  Crypted files  C O U L D  be imported if we used the methods
-        //              provided by Caolan Mc Nammara.
-        //              Written permission (my e-mail) was given by him
-        //              but no special document has been signed...
-        //              27. Sept. 1999, K.-H. Zimmer
-
-
-    }
-    else
-    {
         mpSprmParser = new wwSprmParser(pWwFib->nVersion);
 
         // praktische Hilfsvariablen besetzen:
-        bVer67 = (     (6 == pWwFib->nVersion)
-                                || (7 == pWwFib->nVersion) );   // z.B.: altes Sprm-Id-Format!
-
         bVer6  =  (6 == pWwFib->nVersion);
         bVer7  =  (7 == pWwFib->nVersion);
+    bVer67 = bVer6 || bVer7;
         bVer8  =  (8 == pWwFib->nVersion);
 
-        SvStorageStreamRef xTableStream, xDataStream;
-
-        // Nachdem wir nun den FIB eingelesen haben, wissen wir ja,
-        // welcher Table-Stream gueltig ist.
-        // Diesen oeffnen wir nun.
-
-        // 6 stands for "6 OR 7",  7 stand for "ONLY 7"
-        switch( pWwFib->nVersion )
-        {
-        case 6:
-        case 7: pTableStream = pStrm;
-                pDataStream = pStrm;
-                break;
-
-        case 8:
-            if( !pStg )
-            {
-                ASSERT( pStg, "Version 8 muss immer einen Storage haben!" );
-                nErrRet = ERR_SWG_READ_ERROR;
-                break;
-            }
-
-            xTableStream = pStg->OpenStream( String::CreateFromAscii(
-                pWwFib->fWhichTblStm ? SL::a1Table : SL::a0Table),
-                STREAM_STD_READ );
-
-            pTableStream = &xTableStream;
-            pTableStream->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
-
-            xDataStream = pStg->OpenStream(CREATE_CONST_ASC(SL::aData),
-                STREAM_STD_READ | STREAM_NOCREATE );
-
-            if( xDataStream.Is() && SVSTREAM_OK == xDataStream->GetError() )
-            {
-                pDataStream = &xDataStream;
-                pDataStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);
-            }
-            else
-                pDataStream = pStrm;
-            break;
-        default:
-            // Programm-Fehler!
-            ASSERT( !this, "Es wurde vergessen, nVersion zu kodieren!" );
-            nErrRet = ERR_SWG_READ_ERROR;
-            break;
-        }
-
-        if (ERR_SWG_READ_ERROR != nErrRet)
-        {
             eTextCharSet = WW8Fib::GetFIBCharset(pWwFib->chse);
             eStructCharSet = WW8Fib::GetFIBCharset(pWwFib->chseTables);
 
@@ -3921,8 +3869,7 @@
             // loop for each glossary entry and add dummy section node
             if (pGloss)
             {
-                WW8PLCF aPlc(&xTableStream,pWwFib->fcPlcfglsy,
-                                pWwFib->lcbPlcfglsy,0 );
+        WW8PLCF aPlc(pTableStream, pWwFib->fcPlcfglsy, pWwFib->lcbPlcfglsy, 0);
 
                 WW8_CP nStart, nEnd;
                 void* pDummy;
@@ -4061,13 +4008,10 @@
             DELETEZ( pAuthorInfos );
             delete mpSprmParser;
             ::EndProgress(mpDocShell);
-        }
+
         pDataStream = 0;
         pTableStream = 0;
-    }
 
-    if (!pGloss)
-        DELETEZ(pWwFib);
     DeleteCtrlStk();
     mpRedlineStack->closeall(*pPaM->GetPoint());
     delete mpRedlineStack;
@@ -4086,6 +4030,314 @@
     return nErrRet;
 }
 
+ULONG SwWW8ImplReader::SetSubStreams(SvStorageStreamRef &rTableStream,
+    SvStorageStreamRef &rDataStream)
+{
+    ULONG nErrRet = 0;
+    // 6 stands for "6 OR 7",  7 stand for "ONLY 7"
+    switch (pWwFib->nVersion)
+    {
+        case 6:
+        case 7:
+            pTableStream = pStrm;
+            pDataStream = pStrm;
+            break;
+        case 8:
+            if(!pStg)
+            {
+                ASSERT( pStg, "Version 8 muss immer einen Storage haben!" );
+                nErrRet = ERR_SWG_READ_ERROR;
+                break;
+            }
+
+            rTableStream = pStg->OpenStream(String::CreateFromAscii(
+                pWwFib->fWhichTblStm ? SL::a1Table : SL::a0Table),
+                STREAM_STD_READ);
+
+            pTableStream = &rTableStream;
+            pTableStream->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
+
+            rDataStream = pStg->OpenStream(CREATE_CONST_ASC(SL::aData),
+                STREAM_STD_READ | STREAM_NOCREATE );
+
+            if (rDataStream.Is() && SVSTREAM_OK == rDataStream->GetError())
+            {
+                pDataStream = &rDataStream;
+                pDataStream->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);
+            }
+            else
+                pDataStream = pStrm;
+            break;
+        default:
+            // Programm-Fehler!
+            ASSERT( !this, "Es wurde vergessen, nVersion zu kodieren!" );
+            nErrRet = ERR_SWG_READ_ERROR;
+            break;
+    }
+    return nErrRet;
+}
+
+namespace
+{
+    utl::TempFile *MakeTemp(SvFileStream &rSt)
+    {
+        utl::TempFile *pT = new utl::TempFile;
+        pT->EnableKillingFile();
+        rSt.Open(pT->GetFileName(), STREAM_READWRITE | STREAM_SHARE_DENYWRITE);
+        return pT;
+    }
+
+#define WW_BLOCKSIZE 0x200
+
+    void DecryptRC4(svx::MSCodec_Std97& rCtx, SvStream &rIn, SvStream &rOut)
+    {
+        rIn.Seek(STREAM_SEEK_TO_END);
+        ULONG nLen = rIn.Tell();
+        rIn.Seek(0);
+
+        sal_uInt8 in[WW_BLOCKSIZE];
+        for (ULONG nI = 0, nBlock = 0; nI < nLen; nI += WW_BLOCKSIZE, ++nBlock)
+        {
+            ULONG nBS = (nLen - nI > WW_BLOCKSIZE) ? WW_BLOCKSIZE : nLen - nI;
+            rIn.Read(in, nBS);
+            rCtx.InitCipher(nBlock);
+            rCtx.Decode(in, nBS, in, nBS);
+            rOut.Write(in, nBS);
+        }
+    }
+
+    void DecryptXOR(svx::MSCodec_XorWord95 &rCtx, SvStream &rIn, SvStream &rOut)
+    {
+        ULONG nSt = rIn.Tell();
+        rIn.Seek(STREAM_SEEK_TO_END);
+        ULONG nLen = rIn.Tell();
+        rIn.Seek(nSt);
+
+        rCtx.InitCipher();
+        rCtx.Skip(nSt);
+
+        sal_uInt8 in[0x4096];
+        for (ULONG nI = nSt; nI < nLen; nI += 0x4096)
+        {
+            ULONG nBS = (nLen - nI > 0x4096 ) ? 0x4096 : nLen - nI;
+            rIn.Read(in, nBS);
+            rCtx.Decode(in, nBS);
+            rOut.Write(in, nBS);
+        }
+    }
+
+    //moan, copy and paste :-(
+    String QueryPasswordForMedium(SfxMedium& rMedium)
+    {
+        String aPassw;
+
+        using namespace com::sun::star;
+        try
+        {
+            uno::Reference< task::XInteractionHandler > xHandler( rMedium.GetInteractionHandler() );
+            if( xHandler.is() )
+            {
+                RequestDocumentPassword* pRequest = new RequestDocumentPassword(
+                    task::PasswordRequestMode_PASSWORD_ENTER,
+                    INetURLObject( rMedium.GetOrigURL() ).GetName( INetURLObject::DECODE_WITH_CHARSET ) );
+                uno::Reference< task::XInteractionRequest > xRequest( pRequest );
+
+                xHandler->handle( xRequest );
+
+                if( pRequest->isPassword() )
+                    aPassw = pRequest->getPassword();
+            }
+        }
+        catch( uno::Exception& )
+        {
+        }
+
+        return aPassw;
+    }
+
+}
+
+ULONG SwWW8ImplReader::LoadThroughDecryption(SwPaM& rPaM ,WW8Glossary *pGloss)
+{
+    ULONG nErrRet = 0;
+    if (pGloss)
+        pWwFib = pGloss->GetFib();
+    else
+        pWwFib = new WW8Fib(*pStrm, nWantedVersion);
+
+    if (pWwFib->nFibError)
+        nErrRet = ERR_SWG_READ_ERROR;
+
+    SvStorageStreamRef xTableStream, xDataStream;
+
+    if (!nErrRet)
+        nErrRet = SetSubStreams(xTableStream, xDataStream);
+
+    utl::TempFile *pTempMain = 0;
+    utl::TempFile *pTempTable = 0;
+    utl::TempFile *pTempData = 0;
+    SvFileStream aDecryptMain;
+    SvFileStream aDecryptTable;
+    SvFileStream aDecryptData;
+
+    bool bDecrypt = false;
+    enum {RC4, XOR, Other} eAlgo = Other;
+    if (pWwFib->fEncrypted && !nErrRet)
+    {
+        if (!pGloss)
+        {
+            bDecrypt = true;
+            if (8 != pWwFib->nVersion)
+                eAlgo = XOR;
+            else
+            {
+                if (pWwFib->nKey != 0)
+                    eAlgo = XOR;
+                else
+                {
+                    pTableStream->Seek(0);
+                    sal_uInt32 nEncType;
+                    *pTableStream >> nEncType;
+                    if (nEncType == 0x10001)
+                        eAlgo = RC4;
+                }
+            }
+        }
+    }
+
+    if (bDecrypt)
+    {
+        nErrRet = ERRCODE_SVX_WRONGPASS;
+        switch (eAlgo)
+        {
+            default:
+                nErrRet = ERRCODE_SVX_READ_FILTER_CRYPT;
+                break;
+            case XOR:
+            {
+                String sUniPassword =
+                    QueryPasswordForMedium(*(mpDocShell->GetMedium()));
+
+                ByteString sPassword(sUniPassword,
+                    WW8Fib::GetFIBCharset(pWwFib->chseTables));
+
+                xub_StrLen nLen = sPassword.Len();
+                // DR: do not cut a wrong (too long) password
+                if( nLen <= 15 )
+                {
+                    sal_uInt8 aPassword[16] = {0};
+
+                    for (xub_StrLen nChar = 0; nChar < sPassword.Len(); ++nChar )
+                        aPassword[nChar] = sPassword.GetChar(nChar);
+
+                    svx::MSCodec_XorWord95 aCtx;
+                    aCtx.InitKey(aPassword);
+                    if (aCtx.VerifyKey(pWwFib->nKey, pWwFib->nHash))
+                    {
+                        nErrRet = 0;
+                        pTempMain = MakeTemp(aDecryptMain);
+
+                        pStrm->Seek(0);
+                        size_t nUnencryptedHdr =
+                            (8 == pWwFib->nVersion) ? 0x44 : 0x34;
+                        sal_uInt8 *pIn = new sal_uInt8[nUnencryptedHdr];
+                        pStrm->Read(pIn, nUnencryptedHdr);
+                        aDecryptMain.Write(pIn, nUnencryptedHdr);
+                        delete pIn;
+
+                        DecryptXOR(aCtx, *pStrm, aDecryptMain);
+
+                        if (!pTableStream || pTableStream == pStrm)
+                            pTableStream = &aDecryptMain;
+                        else
+                        {
+                            pTempTable = MakeTemp(aDecryptTable);
+                            DecryptXOR(aCtx, *pTableStream, aDecryptTable);
+                            pTableStream = &aDecryptTable;
+                        }
+
+                        if (!pDataStream || pDataStream == pStrm)
+                            pDataStream = &aDecryptMain;
+                        else
+                        {
+                            pTempData = MakeTemp(aDecryptData);
+                            DecryptXOR(aCtx, *pDataStream, aDecryptData);
+                            pDataStream = &aDecryptData;
+                        }
+                    }
+                }
+            }
+            break;
+            case RC4:
+            {
+                String sUniPassword =
+                    QueryPasswordForMedium(*(mpDocShell->GetMedium()));
+
+                xub_StrLen nLen = sUniPassword.Len();
+                // DR: do not cut a wrong (too long) password
+                if (nLen <= 15)
+                {
+                    sal_Unicode aPassword[16] = {0};
+                    for (xub_StrLen nChar = 0; nChar < nLen; ++nChar )
+                        aPassword[nChar] = sUniPassword.GetChar(nChar);
+
+                    sal_uInt8 aDocId[ 16 ];
+                    pTableStream->Read(aDocId, 16);
+                    sal_uInt8 aSaltData[ 16 ];
+                    pTableStream->Read(aSaltData, 16);
+                    sal_uInt8 aSaltHash[ 16 ];
+                    pTableStream->Read(aSaltHash, 16);
+
+                    svx::MSCodec_Std97 aCtx;
+                    aCtx.InitKey(aPassword, aDocId);
+                    if (aCtx.VerifyKey(aSaltData, aSaltHash))
+                    {
+                        nErrRet = 0;
+
+                        pTempTable = MakeTemp(aDecryptTable);
+                        DecryptRC4(aCtx, *pTableStream, aDecryptTable);
+                        pTableStream = &aDecryptTable;
+
+                        pTempMain = MakeTemp(aDecryptMain);
+                        DecryptRC4(aCtx, *pStrm, aDecryptMain);
+
+                        if (!pDataStream || pDataStream == pStrm)
+                            pDataStream = &aDecryptMain;
+                        else
+                        {
+                            pTempData = MakeTemp(aDecryptData);
+                            DecryptRC4(aCtx, *pDataStream, aDecryptData);
+                            pDataStream = &aDecryptData;
+                        }
+                    }
+                }
+            }
+            break;
+        }
+
+        if (nErrRet == 0)
+        {
+            pStrm = &aDecryptMain;
+
+            delete pWwFib;
+            pWwFib = new WW8Fib(*pStrm, nWantedVersion);
+            if (pWwFib->nFibError)
+                nErrRet = ERR_SWG_READ_ERROR;
+        }
+    }
+
+    if (!nErrRet)
+        nErrRet = CoreLoad(pGloss, *rPaM.GetPoint());
+
+    delete pTempMain;
+    delete pTempTable;
+    delete pTempData;
+
+    if (!pGloss)
+        delete pWwFib;
+    return nErrRet;
+}
+
 class outlineeq : public std::unary_function<const SwTxtFmtColl*, bool>
 {
 private:
@@ -4290,9 +4542,6 @@
 {
     ULONG nErrRet = 0;
 
-    pAktColl    = 0;
-    pAktItemSet = 0;
-
     {
         static const sal_Char* aNames[ 12 ] = {
             "WinWord/WW", "WinWord/WW8", "WinWord/WWFT",
@@ -4357,11 +4606,10 @@
     }
 
     if (!nErrRet)
-        nErrRet = LoadDoc1(rPaM ,pGloss);
+        nErrRet = LoadThroughDecryption(rPaM ,pGloss);
 
     return nErrRet;
 }
-
 
 ULONG WW8Reader::Read(SwDoc &rDoc, SwPaM &rPam, const String & /* FileName */)
 {


Index: sw/source/filter/ww8/ww8scan.cxx
===================================================================
RCS file: /cvs/sw/sw/source/filter/ww8/ww8scan.cxx,v
retrieving revision 1.110
retrieving revision 1.107.24.2
diff -w -u -r1.110 -r1.107.24.2
--- sw/source/filter/ww8/ww8scan.cxx	17 Jun 2004 13:49:29 -0000	1.110
+++ sw/source/filter/ww8/ww8scan.cxx	13 Jul 2004 12:44:44 -0000	1.107.24.2
@@ -5033,8 +5033,8 @@
     rSt >> aBits1;
     rSt >> aBits2;
     rSt >> nFibBack;
-    rSt >> lKey1;
-    rSt >> lKey2;
+    rSt >> nHash;
+    rSt >> nKey;
     rSt >> envr;
     rSt >> aVer8Bits1;      // unter Ver67  nur leeres Reservefeld
                             // Inhalt von aVer8Bits1
@@ -5407,8 +5407,8 @@
     Set_UInt16( pData, nBits16 );
 
     Set_UInt16( pData, nFibBack );
-    Set_UInt16( pData, lKey1 );
-    Set_UInt16( pData, lKey2 );
+    Set_UInt16( pData, nHash );
+    Set_UInt16( pData, nKey );
     Set_UInt8( pData, envr );
 
     BYTE nBits8 = 0;


--- sw/source/filter/ww8/ww8par.hxx	2004-07-21 19:26:51.000000000 +0100
+++ sw/source/filter/ww8/ww8par.hxx	2004-09-02 13:24:39.507825616 +0100
@@ -1173,8 +1173,10 @@
 	//This converts MS Asian Typography information into OOo's
 	void ImportDopTypography(const WW8DopTypography &rTypo);
 
-	ULONG LoadDoc1( SwPaM& rPaM ,WW8Glossary *pGloss);
+    ULONG LoadThroughDecryption(SwPaM& rPaM ,WW8Glossary *pGloss);
+    ULONG SetSubStreams(SvStorageStreamRef &rTableStream, SvStorageStreamRef &rDataStream);
+    ULONG CoreLoad(WW8Glossary *pGloss, const SwPosition &rPos);
 
 	bool StartTable(WW8_CP nStartCp);
     bool InEqualApo(int nLvl) const;

--- sw/source/filter/ww8/ww8scan.hxx	2004-07-21 19:26:52.000000000 +0100
+++ sw/source/filter/ww8/ww8scan.hxx	2004-09-02 13:26:15.593218416 +0100
@@ -1052,8 +1052,8 @@
 
 
 	UINT16 nFibBack; 	// 0xc
-	INT16 lKey1; 			// 0xe  file encrypted key, only valid if fEncrypted.
-	INT16 lKey2; 			// 0x10  key in 2 Portionen wg. Misalignment
+    UINT16 nHash;       // 0xe  file encrypted hash
+    UINT16 nKey;        // 0x10  file encrypted key
 	UINT8 envr;			// 0x12 environment in which file was created
 									//      0 created by Win Word / 1 created by Mac Word
 	BYTE fMac              :1;			// 0x13 when 1, this file was last saved in the Mac environment
