Index: sc/source/filter/inc/op.h
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/op.h,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 op.h
--- sc/source/filter/inc/op.h	18 Sep 2000 16:45:13 -0000	1.1.1.1
+++ sc/source/filter/inc/op.h	6 Oct 2004 07:36:59 -0000
@@ -63,6 +63,7 @@
 #define _OP_H
 
 #include <tools/solar.h>
+#include <patattr.hxx>
 
 // OP-Code-Funktionen
 class SvStream;
@@ -86,6 +87,17 @@
 void OP_HiddenCols( SvStream &aStream, USHORT nLaenge );
 void OP_Window1( SvStream &aStream, USHORT nLaenge );
 void OP_Blank( SvStream &aStream, USHORT nLaenge );
+// Lotus 123 bits.
+void OP_BOF123( SvStream &aStream, USHORT nLaenge );
+void OP_EOF123( SvStream &aStream, USHORT nLaenge );  
+void OP_Number123( SvStream &aStream, USHORT nLaenge );
+void OP_Label123( SvStream &aStream, USHORT nLaenge );
+void OP_Formula123( SvStream &aStream, USHORT nLaenge );
+void OP_IEEENumber123(SvStream& r, UINT16 n);
+void OP_Note123(SvStream &aStream, USHORT nLaenge);
+void OP_CreatePattern123(SvStream &aStream, USHORT nLaenge);
+void OP_HorAlign123(BYTE nAlignPattern, SfxItemSet& rPattern /*  const ScPatternAttr& rPattern*/  );
+void OP_VerAlign123(BYTE nAlignPattern, SfxItemSet& rPattern /*  const ScPatternAttr& rPattern*/  );
+void OP_ApplyPatternArea123(SvStream& r);
 
 #endif
-
Index: sc/source/filter/inc/formel.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/formel.hxx,v
retrieving revision 1.3
diff -u -r1.3 formel.hxx
--- sc/source/filter/inc/formel.hxx	28 Nov 2001 16:41:03 -0000	1.3
+++ sc/source/filter/inc/formel.hxx	6 Oct 2004 07:36:59 -0000
@@ -294,6 +294,7 @@
 	inline void			Read( UINT16& nUINT16 );
 	inline void			Read( INT16& nINT16 );
 	inline void			Read( double& fDouble );
+        inline void                     Read( UINT32& nUINT32 );
 
 						LotusConverterBase( SvStream& rStr, UINT16 nNewBuffer );
 	virtual				~LotusConverterBase();
@@ -344,6 +345,12 @@
 	nBytesLeft -= 8;
 }
 
+inline void LotusConverterBase::Read( UINT32& nUINT32 )
+{
+	aIn >> nUINT32;
+	nBytesLeft -= 4;
+}
+
 #endif
 
 
Index: sc/source/filter/inc/lotform.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/lotform.hxx,v
retrieving revision 1.2
diff -u -r1.2 lotform.hxx
--- sc/source/filter/inc/lotform.hxx	6 Feb 2001 16:19:42 -0000	1.2
+++ sc/source/filter/inc/lotform.hxx	6 Oct 2004 07:36:59 -0000
@@ -119,12 +119,13 @@
 	// ---------------------------------------------------------------
 	static FUNC_TYPE	IndexToType( BYTE );
 	static DefTokenId	IndexToToken( BYTE );
-	static FUNC_TYPE	IndexToTypeWK3( BYTE );
-	static DefTokenId	IndexToTokenWK3( BYTE );
+	static FUNC_TYPE	IndexToTypeWK123( BYTE );
+	static DefTokenId	IndexToTokenWK123( BYTE );
 	void				DoFunc( DefTokenId eOc, BYTE nAnz, const sal_Char* pExtName );
 	void				LotusRelToScRel( UINT16 nCol, UINT16 nRow,
 							SingleRefData& rSRD );
 	BOOL				bWK3;		// alternative Codeumsetzung statt fuer < WK1
+        BOOL                            bWK123;         // alternative for 123
 	// -------------------------------------------------------------------
 	void				ReadSRD( SingleRefData& rSRD, BYTE nFlags );
 	inline void			ReadCRD( ComplRefData& rCRD, BYTE nFlags );
@@ -137,7 +138,7 @@
 	void				NegToken( TokenId& rParam );
 						// ACHTUNG: wie ~, nur wird '-(<rParam>)' gebildet
 public:
-						LotusToSc( SvStream& aStr, CharSet eSrc );
+						LotusToSc( SvStream& aStr, CharSet eSrc, BOOL b );
 	virtual ConvErr		Convert( const ScTokenArray*& rpErg, INT32& nRest,
 									const FORMULA_TYPE eFT = FT_CellFormula );
 
@@ -158,7 +159,7 @@
 
 inline void LotusToSc::SetWK3( void )
 {
-	bWK3 = TRUE;
+        bWK3 = TRUE;
 }
 
 
Index: sc/source/filter/inc/optab.h
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/optab.h,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 optab.h
--- sc/source/filter/inc/optab.h	18 Sep 2000 16:45:13 -0000	1.1.1.1
+++ sc/source/filter/inc/optab.h	6 Oct 2004 07:36:59 -0000
@@ -66,5 +66,21 @@
 
 #define FKT_LIMIT	101
 
+#define FKT_LIMIT123	101
+
+#define LOTUS_EOF	0x01
+
+#define LOTUS_FILEPASSWD 0x4b
+
+#define LOTUS_PATTERN	0x284
+
+#define LOTUS_FORMAT_INDEX 0x800
+
+#define LOTUS_FORMAT_INFO 0x801
+
+#define ROW_FORMAT_MARKER 0x106
+
+#define COL_FORMAT_MARKER 0x107
+
 #endif
 
Index: sc/source/filter/inc/decl.h
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/decl.h,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 decl.h
--- sc/source/filter/inc/decl.h	18 Sep 2000 16:45:12 -0000	1.1.1.1
+++ sc/source/filter/inc/decl.h	6 Oct 2004 07:36:59 -0000
@@ -68,7 +68,7 @@
 #include <tools/string.hxx>
 #endif
 
-enum WKTYP { eWK_UNKNOWN = -2, eWK_1 = 0, eWK_2, eWK3, eWK4, eWK_Error };
+enum WKTYP { eWK_UNKNOWN = -2, eWK_1 = 0, eWK_2, eWK3, eWK4, eWK_Error, eWK123 };
 typedef void ( BEARBFKT )( void );
 typedef sal_Char STRING16[ 16 ];
 typedef sal_Char STRING14[ 14 ];
Index: sc/source/filter/inc/tool.h
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/tool.h,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 tool.h
--- sc/source/filter/inc/tool.h	18 Sep 2000 16:45:13 -0000	1.1.1.1
+++ sc/source/filter/inc/tool.h	6 Oct 2004 07:37:00 -0000
@@ -81,6 +81,8 @@
 
 double		SnumToDouble( INT16 nVal );
 
+double          Snum32ToDouble( UINT32 nValue );
+
 typedef UINT16 StampTyp;
 
 #define MAKE_STAMP(nF,nS) ((nS&0x0F)+((nF&0x7F)*16))
Index: sc/source/filter/lotus/filter.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/filter.cxx,v
retrieving revision 1.3
diff -u -r1.3 filter.cxx
--- sc/source/filter/lotus/filter.cxx	15 Apr 2003 17:26:38 -0000	1.3
+++ sc/source/filter/lotus/filter.cxx	6 Oct 2004 07:37:00 -0000
@@ -71,6 +71,7 @@
 
 #include <tools/solar.h>
 #include <string.h>
+#include <map>
 
 #include "filter.hxx"
 #include "document.hxx"
@@ -88,6 +89,7 @@
 #include "fprogressbar.hxx"
 #endif
 
+#include "op.h"
 
 // Konstanten ------------------------------------------------------------
 const UINT16		nBOF = 0x0000;
@@ -116,95 +118,101 @@
 
 extern OPCODE_FKT	pOpFkt[ FKT_LIMIT ];
 									// -> optab.cxx, Tabelle moeglicher Opcodes
+extern OPCODE_FKT	pOpFkt123[ FKT_LIMIT123 ];
+									// -> optab.cxx, Table of possible Opcodes
 
 extern long			nDateiLaenge;	// -> datei.cpp, ...der gerade offenen Datei
 
 LOTUS_ROOT*			pLotusRoot = NULL;
 
 
-WKTYP				ScanVersion( SvStream& aStream );
+std::map<UINT16, ScPatternAttr> aLotusPatternPool;
 
-
-extern FltError		ScImportLotus123old( SvStream&, ScDocument*, CharSet eSrc );
-
-
-
-FltError ScImportLotus123old( SvStream& aStream, ScDocument* pDocument, CharSet eSrc )
+static FltError
+generate_Opcodes( SvStream& aStream, ScDocument* pDoc,
+				  ScfStreamProgressBar& aPrgrsBar, WKTYP eTyp )
 {
-	aStream.Seek( 0UL );
-
-	// Zeiger auf Dokument global machen
-	pDoc = pDocument;
-
-	bEOF = FALSE;
-
-	eCharVon = eSrc;
-
-	// Speicher besorgen
-	if( !MemNew() )
-		return eERR_NOMEM;
-
-	InitPage(); // Seitenformat initialisieren (nur Tab 0!)
-
-	// Progressbar starten
-    ScfStreamProgressBar aPrgrsBar( aStream, pDocument->GetDocumentShell() );
-
-	// Datei-Typ ermitteln
-	eTyp = ScanVersion( aStream );
+	OPCODE_FKT *pOps;
+	int         nOps;
 
-	switch( eTyp )  // auswaehlen der Tabelle
+	switch(eTyp)
 	{
-		case eWK_1:
-		case eWK_2:		break;
-		case eWK3:		return eERR_NI;
-		case eWK_Error:	return eERR_FORMAT;
-		default:		return eERR_UNKN_WK;
-	}
-
-	// Init von Lotus Root-Daten -> Ctor LotusImport
-
-	// Aufdroeseln der Opcodes
-
+	    case eWK_1:
+	    case eWK_2:
+		pOps = pOpFkt;
+		nOps = FKT_LIMIT;
+		break;
+	    case eWK123:
+		pOps = pOpFkt123;
+		nOps = FKT_LIMIT123;
+		break;
+	    case eWK3:		return eERR_NI;
+	    case eWK_Error:	return eERR_FORMAT;
+	    default:		return eERR_UNKN_WK;
+ 	}
+	aStream.Seek( 0UL );
 	while( !bEOF )
 	{
-		UINT16			nOpcode, nLaenge;
-
-		// ein Lotus-Record einlesen
-		aStream >> nOpcode >> nLaenge;
-
-		aPrgrsBar.Progress();
-
-
-		if( aStream.IsEof() )
-			bEOF = TRUE;
-		else if( nOpcode == 75 )
-			return eERR_FILEPASSWD;
-		else if( nOpcode < FKT_LIMIT )
-			( pOpFkt[ nOpcode ] )( aStream, nLaenge );
+	    UINT16 nOpcode, nLength;
+	    
+	    aStream >> nOpcode >> nLength;
+#ifdef DEBUG
+	    fprintf( stderr, "nOpcode=%x nLength=%x\n", nOpcode, nLength);
+#endif
+	    aPrgrsBar.Progress();
+	    if( nOpcode == LOTUS_EOF )
+		bEOF = TRUE;
+	    else
+	    {
+		if( nOpcode == LOTUS_FILEPASSWD ) 
+		    return eERR_FILEPASSWD;
+		
+		if( nOpcode < nOps )
+		    pOps[ nOpcode ] ( aStream, nLength );
+
+		else if ( nOpcode == LOTUS_PATTERN ) 
+                {
+			aStream.SeekRel(nLength);
+			aStream >> nOpcode >> nLength;
+                        if ( nOpcode == 0x29a)
+                        {
+                        	aStream.SeekRel(nLength);
+	                        aStream >> nOpcode >> nLength;
+        	                if ( nOpcode == 0x804 )
+                	        {
+                        		aStream.SeekRel(nLength);
+		                        OP_ApplyPatternArea123(aStream);
+                	        }
+                        	else
+		                        aStream.SeekRel(nLength);
+                	}
+                        else 
+                        	aStream.SeekRel(nLength);
+                }
 		else
-			aStream.SeekRel( nLaenge );
+		    aStream.SeekRel( nLength );
+	    }
 	}
 
 	MemDelete();
 
 	pDoc->CalcAfterLoad();
-
+    
 	return eERR_OK;
 }
 
-
 WKTYP ScanVersion( SvStream& aStream )
 {
 	// PREC:    pWKDatei:   Zeiger auf offene Datei
 	// POST:    return:     Typ der Datei
-	UINT16			nOpcode, nVersNr, nRecLaenge;
+	UINT16			nOpcode, nVersNr, nRecLen;
 
 	// erstes Byte muss wegen BOF zwingend 0 sein!
 	aStream >> nOpcode;
 	if( nOpcode != nBOF )
 		return eWK_UNKNOWN;
 
-	aStream >> nRecLaenge >> nVersNr;
+	aStream >> nRecLen >> nVersNr;
 
 	if( aStream.IsEof() )
 		return eWK_Error;
@@ -212,14 +220,14 @@
 	switch( nVersNr )
 	{
 		case 0x0404:
-			if( nRecLaenge == 2 )
+			if( nRecLen == 2 )
 				return eWK_1;
 			else
 				return eWK_UNKNOWN;
 			break;
 
 		case 0x0406:
-			if( nRecLaenge == 2 )
+			if( nRecLen == 2 )
 				return eWK_2;
 			else
 				return eWK_UNKNOWN;
@@ -228,17 +236,55 @@
 		case 0x1000:
 			aStream >> nVersNr;
 			if( aStream.IsEof() ) return eWK_Error;
-			if( nVersNr == 0x0004 && nRecLaenge == 26 )
+			if( nVersNr == 0x0004 && nRecLen == 26 )
 			{	// 4 Bytes von 26 gelesen->22 ueberlesen
 				aStream.Read( pDummy1, 22 );
 				return eWK3;
 			}
 			break;
+		case 0x1003:
+			if( nRecLen == 0x1a )
+				return eWK123;
+			else
+				return eWK_UNKNOWN;
+			break;	
+		case 0x1005:
+			if( nRecLen == 0x1a )
+				return eWK123;
+			else
+				return eWK_UNKNOWN;
+			break;       
 	}
 
 	return eWK_UNKNOWN;
 }
 
+FltError ScImportLotus123old( SvStream& aStream, ScDocument* pDocument, CharSet eSrc )
+{
+	aStream.Seek( 0UL );
+
+	// Zeiger auf Dokument global machen
+	pDoc = pDocument;
+
+	bEOF = FALSE;
+
+	eCharVon = eSrc;
+
+	// Speicher besorgen
+	if( !MemNew() )
+		return eERR_NOMEM;
 
+	InitPage(); // Seitenformat initialisieren (nur Tab 0!)
+
+        // Progressbar starten
+	ScfStreamProgressBar aPrgrsBar( aStream, pDocument->GetDocumentShell() );
+
+	// Datei-Typ ermitteln
+	eTyp = ScanVersion( aStream );
+
+	aLotusPatternPool.clear();
+	        	
+	return generate_Opcodes( aStream, pDoc, aPrgrsBar, eTyp );
+}
 
 
Index: sc/source/filter/lotus/tool.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/tool.cxx,v
retrieving revision 1.6
diff -u -r1.6 tool.cxx
--- sc/source/filter/lotus/tool.cxx	26 Mar 2003 18:05:30 -0000	1.6
+++ sc/source/filter/lotus/tool.cxx	6 Oct 2004 07:37:00 -0000
@@ -72,6 +72,7 @@
 #include <svtools/zforlist.hxx>
 #include <tools/solar.h>
 
+#include <math.h>
 #include "cell.hxx"
 #include "rangenam.hxx"
 #include "compiler.hxx"
@@ -219,16 +220,6 @@
 }
 
 
-
-
-String DosToSystem( sal_Char* p )
-{	// Umwandlung vom internen in externen Zeichensatz
-	return String( p, pLotusRoot->eCharsetQ );
-}
-
-
-
-
 double SnumToDouble( INT16 nVal )
 {
 	const double pFacts[ 8 ] = {
@@ -254,7 +245,23 @@
 	return fVal;
 }
 
+double Snum32ToDouble( UINT32 nValue )
+{
+	double  fValue;
+
+	fValue = nValue >> 6;
+	if (nValue & 0x0f)
+	{
+	    if (nValue & 0x00000010)
+                fValue /= pow(10, (nValue & 0x0f));
+	    else
+		fValue *= pow(10, (nValue & 0x0f));	
+	}
 
+	if ((nValue & 0x00000020))
+		fValue = -fValue;
+	return fValue;
+}
 
 
 FormCache::FormCache( ScDocument* pDoc, BYTE nNewDefaultFormat )
Index: sc/source/filter/lotus/op.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/op.cxx,v
retrieving revision 1.7
diff -u -r1.7 op.cxx
--- sc/source/filter/lotus/op.cxx	26 Mar 2003 18:05:30 -0000	1.7
+++ sc/source/filter/lotus/op.cxx	6 Oct 2004 07:37:00 -0000
@@ -71,18 +71,50 @@
 #include <rtl/math.hxx>
 #include <stdio.h>
 #include <string.h>
+#include <math.h>
 #include <ctype.h>
 #if defined( MAC ) || defined( ICC )
 #include <stdlib.h>
 #endif
 
+#include "scitems.hxx"
+#include <svx/algitem.hxx>
+#include <svx/postitem.hxx>
+#include <svx/udlnitem.hxx>
+#include <svx/wghtitem.hxx>
+#include <map>
+
+#ifndef _SVTOOLS_PASSWORDHELPER_HXX
+#include <svtools/PasswordHelper.hxx>
+#endif
+
+#include "global.hxx"
+#include "sc.hrc"
+#include "attrib.hxx"
+#include "patattr.hxx"
+#include "docpool.hxx"
+#include "document.hxx"
+#include "collect.hxx"
+#include "rangenam.hxx"
+#include "dbcolect.hxx"
+#include "stlsheet.hxx"
+#include "stlpool.hxx"
+#include "filter.hxx"
+#include "scflt.hxx"
+#include "cell.hxx"
+#include "scfobj.hxx"
+#include "docoptio.hxx"
+#include "viewopti.hxx"
+#include "globstr.hrc"
+#include "ftools.hxx"
+
 #include "cell.hxx"
 #include "rangenam.hxx"
 #include "document.hxx"
 
 #include "op.h"
+#include "optab.h"
 #include "tool.h"
-#include "math.h"
 #include "decl.h"
 #include "lotform.hxx"
 #include "lotrange.hxx"
@@ -105,8 +137,7 @@
 
 static UINT16		nDefWidth = ( UINT16 ) ( TWIPS_PER_CHAR * 10 );
 
-
-
+extern std::map<UINT16, ScPatternAttr> aLotusPatternPool;
 
 void NI( SvStream& r, UINT16 n )
 {
@@ -150,7 +181,7 @@
 
 	r >> nFormat >> nCol >> nRow >> fValue;
 
-    fValue = ::rtl::math::round( fValue, 15 );
+	fValue = ::rtl::math::round( fValue, 15 );
 	ScValueCell*	pZelle = new ScValueCell( fValue );
 	pDoc->PutCell( nCol, nRow, nTab, pZelle, ( BOOL ) TRUE );
 
@@ -160,31 +191,29 @@
 
 void OP_Label( SvStream& r, UINT16 n )
 {
-	BYTE			nFormat;
+    	BYTE			nFormat;
 	UINT16			nCol, nRow, nTab = 0;
-	sal_Char		pText[ 256 ];
-
+	
 	r >> nFormat >> nCol >> nRow;
 	n -= 5;
 
-	r.Read( pText, n );
-	pText[ n + 1 ] = 0;   // zur Sicherheit Nullterminator anhaengen
-	// der Mega-Hack: bei Text wird HART Text als Format eingebrannt!!!!!!!
+	sal_Char* pText = new sal_Char[n + 1];
+ 	r.Read( pText, n );
+	pText[n] = 0;
 	nFormat &= 0x80;    // Bit 7 belassen
 	nFormat |= 0x75;    // protected egal, special-text gesetzt
 
-	// Sonderzeichenanpassung
-	DosToSystem( pText );
-
 	PutFormString( nCol, nRow, nTab, pText );
 
 	SetFormat( nCol, nRow, nTab, nFormat, nDezStd );
+	
+	delete []pText;
 }
 
 
 void OP_Text( SvStream& r, UINT16 n )        // WK3
 {
-	UINT16			nRow;
+    	UINT16			nRow;
 	BYTE			nCol, nTab;
 	sal_Char		pText[ 256 ];
 
@@ -211,7 +240,7 @@
 	INT32				nBytesLeft = nFormulaSize;
 	ScAddress			aAddress( nCol, nRow, nTab );
 
-	LotusToSc			aConv( r, pLotusRoot->eCharsetQ );
+	LotusToSc			aConv( r, pLotusRoot->eCharsetQ, FALSE );
 	aConv.Reset( aAddress );
 	aConv.Convert( pErg, nBytesLeft );
 
@@ -271,8 +300,6 @@
 	else
 		strcpy( pAnsi, cPuffer );           // #100211# - checked
 
-	DosToSystem( pAnsi );
-
 	String				aTmp( pAnsi, pLotusRoot->eCharsetQ );
 
     ScfTools::ConvertToScDefinedName( aTmp );
@@ -310,8 +337,6 @@
 	else
 		strcpy( pAnsi, cPuffer );           // #100211# - checked
 
-	DosToSystem( pAnsi );
-
 	String		aTmp( pAnsi, pLotusRoot->eCharsetQ );
     ScfTools::ConvertToScDefinedName( aTmp );
 
@@ -388,4 +413,282 @@
 	SetFormat( nCol, nRow, 0, nFormat, nDezFloat );
 }
 
+void OP_BOF123( SvStream& r, UINT16 n )
+{
+	r.SeekRel( 26 );        
+}
+
+
+void OP_EOF123( SvStream& r, UINT16 n )
+{
+	bEOF = TRUE;
+}
+
+void OP_Label123( SvStream& r, UINT16 n )
+{ 
+	BYTE      nTab, nCol;
+	UINT16    nRow;
+	r >> nRow >> nTab >> nCol;
+	n -= 4;
+
+	sal_Char* pText = new sal_Char[n + 1];
+	r.Read( pText, n );
+	pText[ n ] = 0;
 
+	PutFormString(( UINT16 )  nCol, nRow,( UINT16 )  nTab, pText );
+
+	delete []pText;
+}
+
+void OP_Number123( SvStream& r, UINT16 n )
+{
+	BYTE    nCol,nTab;
+	UINT16  nRow;
+	UINT32   nValue;
+
+	r >> nRow >> nTab >> nCol >> nValue;
+	double fValue = Snum32ToDouble( nValue );
+
+	ScValueCell *pCell = new ScValueCell( fValue );
+	pDoc->PutCell( ( UINT16 ) nCol, nRow, ( UINT16 ) nTab, pCell, ( BOOL ) TRUE );
+}
+
+void OP_Formula123( SvStream& r, UINT16 n )
+{
+        BYTE nCol,nTab;
+        UINT16 nRow;
+        
+        r >> nRow >> nTab >> nCol;
+	r.SeekRel( 8 );    // Result- jump over
+	
+	const ScTokenArray*	pErg;
+	INT32				nBytesLeft = n - 12;
+	ScAddress			aAddress( nCol, nRow, nTab );
+
+	LotusToSc			aConv( r, pLotusRoot->eCharsetQ, TRUE );
+	aConv.Reset( aAddress );
+	aConv.Convert( pErg, nBytesLeft );
+
+	ScFormulaCell*		pCell = new ScFormulaCell( pLotusRoot->pDoc, aAddress, pErg );
+
+	pCell->AddRecalcMode( RECALCMODE_ONLOAD_ONCE );
+
+	pDoc->PutCell( (UINT16) nCol, nRow, ( UINT16 ) nTab, pCell, ( BOOL ) TRUE );
+}
+
+void OP_IEEENumber123(SvStream& r, UINT16 n)
+{
+        BYTE nCol,nTab;
+        UINT16 nRow;
+        double dValue;
+
+        r >> nRow >> nTab >> nCol >> dValue;
+
+        ScValueCell *pCell = new ScValueCell(dValue);
+        pDoc->PutCell( (UINT16) nCol, nRow, ( UINT16 ) nTab, pCell, ( BOOL ) TRUE );
+}
+
+void OP_Note123(SvStream& r, UINT16 n)
+{
+        BYTE      nTab, nCol;
+        UINT16    nRow;
+        r >> nRow >> nTab >> nCol;
+        n -= 4;
+
+        sal_Char* pText = new sal_Char[n + 1];
+        r.Read( pText, n );
+        pText[ n ] = 0;
+
+        String aTmp(pText,pLotusRoot->eCharsetQ);
+        ScPostIt* pNote = new ScPostIt(aTmp);
+
+        ScNoteCell *pCell = new ScNoteCell(*pNote);
+
+	pDoc->SetNote( (UINT16) nCol, nRow, (UINT16) nTab, *pNote ) ;
+	
+	delete []pText;
+}
+
+void OP_HorAlign123(BYTE nAlignPattern, SfxItemSet& rPatternItemSet )
+{
+//      pre:  Pattern is stored in the last 3 bites of the 21st byte
+//      post: Appropriate Horizontal Alignement is set in rPattern according to the bit pattern.
+                                                                                                                                                             
+//      LEFT:001
+//      RIGHT:010
+//      CENTER:011
+//      JUSTIFY:110
+//      LEFT-Text/RIGHT-NUMBER:100
+//      DEFAULT:000
+
+	nAlignPattern = ( nAlignPattern & 0x07);
+                                                                                                                                                             
+	switch (nAlignPattern)
+ 	{
+		case 1:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_LEFT ) );
+			break;
+	  	case 2:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_RIGHT ) );
+        		break;
+		case 3:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_CENTER ) );
+		        break;
+  		case 4:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_STANDARD ) );
+		        break;
+		case 6:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_BLOCK ) );
+		        break;
+  		default:
+			rPatternItemSet.Put( SvxHorJustifyItem( SVX_HOR_JUSTIFY_STANDARD ) );
+		        break;
+  	}
+}
+                                                                                                                                                             
+void OP_VerAlign123(BYTE nAlignPattern,SfxItemSet& rPatternItemSet  )
+{
+//      pre:  Pattern is stored in the last 3 bites of the 22nd byte
+//      post: Appropriate Verticle Alignement is set in rPattern according to the bit pattern.
+
+//      TOP:001
+//      MIDDLE:010
+//      DOWN:100
+//      DEFAULT:000
+ 
+	nAlignPattern = ( nAlignPattern & 0x07);
+                                                                                                                                                             
+	switch (nAlignPattern)
+        {
+		case 0:
+			rPatternItemSet.Put( SvxVerJustifyItem(SVX_VER_JUSTIFY_STANDARD) );
+	                break;
+        	case 1:
+			rPatternItemSet.Put( SvxVerJustifyItem(SVX_VER_JUSTIFY_TOP) );
+	                break;
+        	case 2:
+			rPatternItemSet.Put( SvxVerJustifyItem(SVX_VER_JUSTIFY_CENTER) );
+	                break;
+          	case 4:
+			rPatternItemSet.Put( SvxVerJustifyItem(SVX_VER_JUSTIFY_BOTTOM) );
+	                break;
+        	default:
+			rPatternItemSet.Put( SvxVerJustifyItem(SVX_VER_JUSTIFY_STANDARD) );
+	                break;
+        }
+}
+
+void OP_CreatePattern123(SvStream& r, UINT16 n)
+{
+        UINT16 nCode,nPatternId;
+                                                                                                                                                             
+        ScPatternAttr aPattern(pDoc->GetPool());
+        SfxItemSet& rItemSet = aPattern.GetItemSet();
+                                                                                                                                                             
+        r >> nCode;
+        n = n - 2;
+        
+	if ( nCode == 0x0fd2 )
+        {
+                r >> nPatternId;
+                                                                                                                                                             
+                BYTE Hor_Align, Ver_Align, temp;
+                BOOL bIsBold,bIsUnderLine,bIsItalics;
+                                                                                                                                                             
+                r.SeekRel(12);
+                
+		// Read 17th Byte
+                r >> temp; 
+                                                                                                                                                             
+                bIsBold = (temp & 0x01);
+                bIsItalics = (temp & 0x02);
+                bIsUnderLine = (temp & 0x04);
+                                                                                                                                                             
+                if ( bIsBold )
+                        rItemSet.Put( SvxWeightItem(WEIGHT_BOLD,ATTR_FONT_WEIGHT) );
+                if ( bIsItalics )
+                        rItemSet.Put( SvxPostureItem(ITALIC_NORMAL, ATTR_FONT_POSTURE ) );
+                if ( bIsUnderLine )
+                        rItemSet.Put( SvxUnderlineItem( UNDERLINE_SINGLE, ATTR_FONT_UNDERLINE ) );
+                                                                                                                                                             
+                r.SeekRel(3); 
+		
+		// Read 21st Byte
+                r >> Hor_Align;
+                OP_HorAlign123( Hor_Align, rItemSet );
+                                                                                                                                                             
+                r >> Ver_Align;
+                OP_VerAlign123( Ver_Align, rItemSet );
+                                                                                                                                                             
+		aLotusPatternPool.insert( std::map<UINT16, ScPatternAttr>::value_type( nPatternId, aPattern ) );
+		n = n - 20; 
+        }
+        r.SeekRel(n);
+}
+
+void OP_ApplyPatternArea123( SvStream& r)
+{
+	UINT16 nOpcode, nLength;
+        UINT16 nCol = 0, nColCount = 0, nRow = 0, nRowCount = 0, nTab = 0, nData, nTabCount = 0, nLevel = 0;
+
+	do
+	{
+		r >> nOpcode >> nLength;
+		switch ( nOpcode )
+                {
+                	case ROW_FORMAT_MARKER:
+					nLevel++;
+                                        break;
+                	case COL_FORMAT_MARKER:
+                                        nLevel--;
+					if( nLevel == 1 )
+					{
+	                                        nTab = nTab + nTabCount;
+						nCol = 0; nColCount = 0;
+	        	        	        nRow = 0; nRowCount = 0;
+					}
+                                        break;
+			case LOTUS_FORMAT_INDEX:
+                                        if( nLength == 2 )
+                                        {
+                                                r >> nData;
+						if( nLevel == 1 )
+							nTabCount = nData;	 
+                                                else if( nLevel == 2 )
+                                                {
+                                                        nCol = nCol + nColCount;
+                                                        nColCount = nData;
+                                                        if ( nCol > 0xff ) // 256 is the max col size supported by 123
+                                                                nCol = 0;
+                                                }
+                                                else if( nLevel == 3 ) 
+                                                {
+                                                        nRow = nRow + nRowCount;
+                                                        nRowCount = nData;
+                                                        if ( nRow > 0x1fff ) // 8192 is the max row size supported by 123
+                                                                nRow = 0;
+                                                }
+                                        }
+                                        else r.SeekRel(nLength);
+                                        break;
+			case LOTUS_FORMAT_INFO:
+                                        if( nLength == 2 )
+                                        {
+                                                r >> nData;
+                                                for( int i = 0; i < nTabCount; i++)
+                                                {
+                                                        std::map<UINT16, ScPatternAttr>::iterator loc = aLotusPatternPool.find( nData );
+                                                        pDoc->ApplyPatternAreaTab( nCol, nRow, nCol +  nColCount - 1, nRow + nRowCount - 1, nTab + i, loc->second );
+                                                }
+                                        }
+                                        else r.SeekRel(nLength);
+                                        break;
+			default:
+                                        r.SeekRel(nLength);
+                                        break;
+		}
+	}
+	 while( nLevel );
+	
+	aLotusPatternPool.clear();
+}
Index: sc/source/filter/lotus/optab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/optab.cxx,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 optab.cxx
--- sc/source/filter/lotus/optab.cxx	18 Sep 2000 16:45:14 -0000	1.1.1.1
+++ sc/source/filter/lotus/optab.cxx	6 Oct 2004 07:37:00 -0000
@@ -176,3 +176,108 @@
 };
 
 
+OPCODE_FKT pOpFkt123[ FKT_LIMIT123 ] =
+{						//  Code
+	OP_BOF123,				//    0
+	OP_EOF123,				//    1
+	NI,					//    2
+	NI,					//    3
+	NI,					//    4
+	NI,					//    5
+	NI,					//    6
+	NI,			//    7
+	NI,		//    8
+	NI,					//    9
+	NI,					//   10
+	NI,		//   11
+	NI,			//   12
+	NI,			//   13
+	NI,			//   14
+	NI,			//   15
+	NI,			//   16
+	NI,					//   17
+	NI,					//   18
+	NI,					//   19
+	NI,					//   20
+	NI,					//   21
+	OP_Label123,				//   22
+	NI,					//   23
+	NI,					//   24
+	NI,					//   25
+	NI,					//   26
+	OP_CreatePattern123,			//   27
+	NI,					//   28
+	NI,					//   29
+	NI,					//   30
+	NI,					//   31
+	NI,					//   32
+	NI,					//   33
+	NI,					//   34
+	NI,					//   35
+	NI,					//   36
+	OP_Number123,  			        //   37
+	OP_Note123,			//   38
+	OP_IEEENumber123,					//   39
+	OP_Formula123,			//   40
+	NI,					//   41
+	NI,					//   42
+	NI,					//   43
+	NI,					//   44
+	NI,					//   45
+	NI,					//   46
+	NI,					//   47
+	NI,					//   48
+	NI,					//   49
+	NI,					//   50
+	NI,					//   51
+	NI,					//   52
+	NI,					//   53
+	NI,					//   54
+	NI,					//   55
+	NI,					//   56
+	NI,					//   57
+	NI,					//   58
+	NI,					//   59
+	NI,					//   60
+	NI,					//   61
+	NI,					//   62
+	NI,					//   63
+	NI,					//   64
+	NI,					//   65
+	NI,					//   66
+	NI,					//   67
+	NI,					//   68
+	NI,					//   69
+	NI,					//   70
+	NI,	//   71
+	NI,					//   72
+	NI,					//   73
+	NI,					//   74
+	NI,					//   75
+	NI,					//   76
+	NI,					//   77
+	NI,					//   78
+	NI,					//   79
+	NI,					//   80
+	NI,					//   81
+	NI,					//   82
+	NI,					//   83
+	NI,					//   84
+	NI,					//   85
+	NI,					//   86
+	NI,					//   87
+	NI,					//   88
+	NI,					//   89
+	NI,					//   90
+	NI,					//   91
+	NI,					//   92
+	NI,					//   93
+	NI,					//   94
+	NI,					//   95
+	NI,					//   96
+	NI,					//   97
+	NI,					//   98
+	NI,					//   99
+	NI		//  100
+};
+	
Index: sc/source/filter/lotus/lotform.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/lotform.cxx,v
retrieving revision 1.7
diff -u -r1.7 lotform.cxx
--- sc/source/filter/lotus/lotform.cxx	26 Mar 2003 18:05:29 -0000	1.7
+++ sc/source/filter/lotus/lotform.cxx	6 Oct 2004 07:37:01 -0000
@@ -75,6 +75,7 @@
 #include "root.hxx"
 #include "ftools.hxx"
 #include "tool.h"
+#include <math.h>
 
 extern WKTYP				eTyp;
 
@@ -82,7 +83,7 @@
 
 static DefTokenId			lcl_KnownAddIn( const ByteString& sTest );
 
-
+//extern double decipher_Number123( UINT32 nValue );
 
 
 void LotusToSc::DoFunc( DefTokenId eOc, BYTE nAnz, const sal_Char* pExtString )
@@ -394,11 +395,12 @@
 	}
 
 
-LotusToSc::LotusToSc( SvStream &rStream, CharSet e ) :
+LotusToSc::LotusToSc( SvStream &rStream, CharSet e, BOOL b ) :
 	LotusConverterBase( rStream, 128 )
 	{
 	eSrcChar = e;
 	bWK3 = FALSE;
+	bWK123 = b;
 	}
 
 
@@ -434,9 +436,14 @@
 	FuncType2*			pIndexToToken;
 
 	if( bWK3 )
-	{	// fuer > WK3
-		pIndexToType = IndexToTypeWK3;
-		pIndexToToken = IndexToTokenWK3;
+	{	// for > WK3
+		pIndexToType = IndexToTypeWK123;
+		pIndexToToken = IndexToTokenWK123;
+	}
+	else if( bWK123 )
+	{
+		pIndexToType = IndexToTypeWK123;
+		pIndexToToken = IndexToTokenWK123;
 	}
 	else
 	{
@@ -471,7 +478,7 @@
 		switch( eType )
 		{
 			case FT_Return:
-				if( bWK3 )
+				if( bWK3 || bWK123 )
 					nBytesLeft = 0;	// wird ab WK3 nicht benutzt
 
 				rRest = nBytesLeft;
@@ -482,7 +489,7 @@
 			case FT_FuncFix2:	DoFunc( eOc, 2, pExtName ); break;
 			case FT_FuncFix3:	DoFunc( eOc, 3, pExtName ); break;
 			case FT_FuncFix4:	DoFunc( eOc, 4, pExtName ); break;
-			case FT_FuncVar:
+		        case FT_FuncVar:
 				Read( nAnz );
 				DoFunc( eOc, nAnz, pExtName );
 				break;
@@ -647,16 +654,31 @@
 			}
 				break;
 			case FT_Const10Float:
-                aStack << aPool.Store( ScfTools::ReadLongDouble( aIn ) );
-				break;
+			        if ( bWK123 )
+			        {
+			                double fValue;
+			                Read( fValue );
+			                aStack << aPool.Store( fValue );
+			        }
+			        else aStack << aPool.Store( ScfTools::ReadLongDouble( aIn ) );
+			        break;
 			case FT_Snum:
+			        if ( bWK123 )
 				{
-				INT16 nVal;
-				Read( nVal );
-				aStack << aPool.Store( SnumToDouble( nVal ) );
+				         UINT32   nValue;
+
+				         Read( nValue );
+					 double  fValue = Snum32ToDouble( nValue );
+					 aStack << aPool.Store( fValue );
+				}
+				else
+				{
+				        INT16 nVal;
+				        Read( nVal );
+				        aStack << aPool.Store( SnumToDouble( nVal ) );
 				}
 				break;
-			default:
+		    	default:
 				DBG_ERROR( "*LotusToSc::Convert(): unbekannter enum!" );
 		}
 	}
@@ -1206,16 +1228,16 @@
 }
 
 
-FUNC_TYPE LotusToSc::IndexToTypeWK3( BYTE nIndex )
+FUNC_TYPE LotusToSc::IndexToTypeWK123( BYTE nIndex )
 {
 	static const FUNC_TYPE pType[ 256 ] =
 	{						// Code Bezeichnung
-		FT_Const10Float,	//    0 8-Byte-IEEE-Float
+		FT_Const10Float,	//    0 8-Byte-IEEE-Long-Number
 		FT_Cref,			//    1 Cell Reference
 		FT_Rref,			//    2 Area Reference
 		FT_Return,			//    3 return
 		FT_Braces,			//    4 Klammer
-		FT_Snum,			//    5 2-Byte-Short-Num
+		FT_Snum,			//    5 Short-Number
 		FT_ConstString,		//    6 ASCII-String
 		FT_Nrref,			//    7 Named range reference
 		FT_Absnref,			//    8 Absolut named range
@@ -1471,16 +1493,16 @@
 }
 
 
-DefTokenId LotusToSc::IndexToTokenWK3( BYTE nIndex )
+DefTokenId LotusToSc::IndexToTokenWK123( BYTE nIndex )
 {
 	static const DefTokenId pToken[ 256 ] =
 	{						// Code Bezeichnung
-		ocPush,				//    0 8-Byte-IEEE-Float
+		ocPush,				//    0 8-Byte-IEEE-Long-Numbers
 		ocPush,				//    1 Variable
 		ocPush,				//    2 Bereich
 		ocPush,				//    3 return
 		ocPush,				//    4 Klammer
-		ocPush,				//    5 2-Byte-Integer
+		ocPush,				//    5 Numbers
 		ocPush,				//    6 ASCII-String
 		ocPush,				//    7 Named range reference
 		ocPush,				//    8 Absolut named range
Index: sc/source/filter/lotus/lotimpop.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/lotus/lotimpop.cxx,v
retrieving revision 1.6
diff -u -r1.6 lotimpop.cxx
--- sc/source/filter/lotus/lotimpop.cxx	26 Mar 2003 18:05:29 -0000	1.6
+++ sc/source/filter/lotus/lotimpop.cxx	6 Oct 2004 07:37:01 -0000
@@ -97,7 +97,7 @@
 ImportLotus::ImportLotus( SvStream& aStream, ScDocument* pDoc, CharSet eQ ) :
     ImportTyp( pDoc, eQ ),
 	pIn( &aStream ),
-	aConv( *pIn, eQ )
+	aConv( *pIn, eQ, FALSE )
 {
 	pExtOpt = NULL;
 
@@ -198,7 +198,6 @@
 			Read( nSpaces );
 			// ACHTUNG: Korrekturfaktor nach 'Augenmass' ermittelt!
 			pD->SetColWidth( nCol, nTab, ( UINT16 ) ( TWIPS_PER_CHAR * 1.28 * nSpaces ) );
-
 			nCnt--;
 		}
 	}
