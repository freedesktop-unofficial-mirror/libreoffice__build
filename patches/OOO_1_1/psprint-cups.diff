Index: psprint/inc/psprint/fontcache.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/fontcache.hxx,v
retrieving revision 1.2.38.1
diff -u -r1.2.38.1 fontcache.hxx
--- psprint/inc/psprint/fontcache.hxx	15 Jan 2004 12:56:53 -0000	1.2.38.1
+++ psprint/inc/psprint/fontcache.hxx	9 Jun 2004 02:15:29 -0000
@@ -70,6 +70,10 @@
 #include <tools/string.hxx>
 #endif
 
+#ifndef _STRING_HXX
+#include <tools/string.hxx>
+#endif
+
 #include <hash_map>
 
 namespace psp
Index: psprint/inc/psprint/jobdata.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/jobdata.hxx,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 jobdata.hxx
--- psprint/inc/psprint/jobdata.hxx	8 May 2001 11:45:33 -0000	1.1.1.1
+++ psprint/inc/psprint/jobdata.hxx	9 Jun 2004 02:15:30 -0000
@@ -105,6 +105,10 @@
             m_eOrientation( orientation::Portrait ),
             m_pParser( NULL ) {}
 
+    JobData& operator=(const psp::JobData& rRight);
+
+    JobData( const JobData& rData ) { *this = rData; }
+
     // creates a new buffer using new
     // it is up to the user to delete it again
     bool getStreamBuffer( void*& pData, int& bytes );
@@ -113,4 +117,5 @@
 
 } // namespace
 
+
 #endif // PSPRINT_JOBDATA_HXX
Index: psprint/inc/psprint/ppdparser.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/ppdparser.hxx,v
retrieving revision 1.4
diff -u -r1.4 ppdparser.hxx
--- psprint/inc/psprint/ppdparser.hxx	11 Apr 2003 17:17:50 -0000	1.4
+++ psprint/inc/psprint/ppdparser.hxx	9 Jun 2004 02:15:30 -0000
@@ -149,11 +149,13 @@
  */
 
 class PPDContext;
+class CUPSManager;
 
 class PPDParser
 {
     friend class PPDContext;
-    
+    friend class CUPSManager;
+
     typedef ::std::hash_map< ::rtl::OUString, PPDKey*, ::rtl::OUStringHash > hash_type;
     typedef ::std::vector< PPDKey* > value_type;
 
Index: psprint/inc/psprint/printergfx.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/printergfx.hxx,v
retrieving revision 1.11
diff -u -r1.11 printergfx.hxx
--- psprint/inc/psprint/printergfx.hxx	30 Jun 2003 14:26:09 -0000	1.11
+++ psprint/inc/psprint/printergfx.hxx	9 Jun 2004 02:15:30 -0000
@@ -113,10 +113,10 @@
             meColorspace (eRGB)
     {}
     PrinterColor (sal_uInt32 nRGB) :
-            meColorspace (eRGB),
-            mnBlue  ((nRGB & 0x000000ff)      ),
+            mnRed   ((nRGB & 0x00ff0000) >> 16),
             mnGreen ((nRGB & 0x0000ff00) >>  8),
-            mnRed   ((nRGB & 0x00ff0000) >> 16)
+            mnBlue  ((nRGB & 0x000000ff)      ),
+            meColorspace (eRGB)
     {}
     ~PrinterColor ()
     {}
@@ -210,6 +210,8 @@
 {
     rtl::OString        maFont;
     rtl_TextEncoding	maEncoding;
+    bool				mbArtItalic;
+    bool				mbArtBold;
     sal_Int32           mnTextHeight;
     sal_Int32           mnTextWidth;
     PrinterColor        maColor;
@@ -422,13 +424,25 @@
     void            DrawMask   (const Rectangle& rDest, const Rectangle& rSrc, 
                                 const PrinterBmp &rBitmap, PrinterColor& rMaskColor);
 
-    // font and text handling
+    // font and text handling (compatibility)
     sal_uInt16      SetFont (
                              sal_Int32 nFontID,
                              sal_Int32 nPointHeight,
                              sal_Int32 nPointWidth,
                              sal_Int32 nAngle,
                              bool bVertical
+                             ) { return SetFont(nFontID, nPointHeight, nPointWidth,
+				                nAngle, bVertical, false, false);}
+
+    // font and text handling
+    sal_uInt16      SetFont (
+                             sal_Int32 nFontID,
+                             sal_Int32 nPointHeight,
+                             sal_Int32 nPointWidth,
+                             sal_Int32 nAngle,
+                             bool bVertical,
+                             bool bArtItalic,
+                             bool bArtBold
                              );
     sal_uInt16      SetFallbackFont ( sal_Int32 nFontID );
     sal_Int32       GetFontAngle () const
@@ -441,6 +455,10 @@
     { return maVirtualStatus.mnTextHeight; }
     sal_Int32       GetFontWidth () const
     { return maVirtualStatus.mnTextWidth; }
+    bool			GetArtificialItalic() const
+    { return maVirtualStatus.mbArtItalic; }
+    bool			GetArtificialBold() const
+    { return maVirtualStatus.mbArtBold; }
     void            DrawText (const Point& rPoint, 
                               const sal_Unicode* pStr, sal_Int16 nLen, 
                               const sal_Int32* pDeltaArray = NULL);
Index: psprint/inc/psprint/printerinfomanager.hxx
===================================================================
RCS file: /cvs/gsl/psprint/inc/psprint/printerinfomanager.hxx,v
retrieving revision 1.4.26.1
diff -u -r1.4.26.1 printerinfomanager.hxx
--- psprint/inc/psprint/printerinfomanager.hxx	28 Jan 2004 11:21:49 -0000	1.4.26.1
+++ psprint/inc/psprint/printerinfomanager.hxx	9 Jun 2004 02:15:30 -0000
@@ -80,6 +80,36 @@
 #ifndef _PSPRINT_HELPER_HXX_
 #include <psprint/helper.hxx>
 #endif
+#include <cstdio>
+
+#ifdef MACOSX
+/* MacOS X print system discovery constants:
+ *
+ * These values enumerate Apple OS printing systems we could use.
+ * They are used as indications _as well as_ indexes into the
+ * aParms structure used below for print commands.
+ */
+#define		kApplePrintingFailure		0		/* For whatever reason, we can't print at all */
+#define		kApplePrintingLPR			1		/* Darwin 5.x style LPR printing */
+#define		kApplePrintingCUPS			2		/* MacOS X 10.2/Darwin 6 style CUPS (also CUPS installed by users on 10.1) */
+#define		kApplePrintingPrintCenter	3		/* MacOS X 10.1 /usr/sbin/Print printing */
+
+/* Constants for PostScript vs PDF printing */
+#define		kApplePrintingUsePDF		1		/* Default; Run PS through ps2pdf first (requires GhostScript) */
+#define		kApplePrintingUsePS			2		/* Optional, print PS directly to printer (less compatible, requires PS printer) */
+
+/* Define various printing commands */
+#define		kApplePCPrintCommand	"/usr/sbin/Print"		/* Mac OS X 10.1 Print Center Printing command */
+#define		kApplePS2PDFLocation	"/usr/local/bin/ps2pdf"	/* PS -> PDF conversion command */
+#define		kApplePCQueueName		"Apple Print Center Default Printer"	/* Name that appears in Print... dialog as the default */
+																/* printer for 10.1 Print Center printing */
+
+/* Prototype for print method discovery function.  Returns
+ * a constant defined in printerinfomanager.hxx
+ */
+sal_Int32	macxp_GetSystemPrintMethod( void );
+#endif
+
 
 #ifdef MACOSX
 /* MacOS X print system discovery constants:
@@ -118,16 +148,16 @@
 struct PrinterInfo : JobData
 {
     // basename of PPD
-    ::rtl::OUString             m_aDriverName;
+    rtl::OUString             m_aDriverName;
     // can be the queue
-    ::rtl::OUString             m_aLocation;
+    rtl::OUString             m_aLocation;
     // a user defined comment
-    ::rtl::OUString             m_aComment;
+    rtl::OUString             m_aComment;
     // a command line to pipe a PS-file to
-    ::rtl::OUString             m_aCommand;
+    rtl::OUString             m_aCommand;
     // a list of special features separated by ',' not used by psprint
     // but assigned from the outside (currently only for "fax")
-    ::rtl::OUString             m_aFeatures;
+    rtl::OUString             m_aFeatures;
     // a mapping of fonts to other fonts.
     // this provides a method for the user
     // to replace arbitrary fonts by printer builtin fonts
@@ -138,20 +168,24 @@
     // this vector is currently implicitly given by the adobe
     // standard encoding
     bool                        m_bPerformFontSubstitution;
-    ::std::hash_map< ::rtl::OUString, ::rtl::OUString, ::rtl::OUStringHash >
+    std::hash_map< rtl::OUString, rtl::OUString, rtl::OUStringHash >
     m_aFontSubstitutes;
-    ::std::hash_map< fontID, fontID >
+    std::hash_map< fontID, fontID >
     m_aFontSubstitutions;
 };
 
 class PrinterInfoManager
 {
+public:
+    enum Type { Default = 0, CUPS = 1 };
+
+protected:
     // needed for checkPrintersChanged: files (not necessarily existant)
     // and their last known modification time
     struct WatchFile
     {
         // the file in question
-        ::rtl::OUString         m_aFilePath;
+        rtl::OUString         m_aFilePath;
         // the last know modification time or 0, if file did not exist
         TimeValue               m_aModified;
     };
@@ -161,33 +195,35 @@
     {
         // configuration file containing this printer
         // empty means a freshly added printer that has to be saved yet
-        ::rtl::OUString         m_aFile;
+        rtl::OUString         m_aFile;
         // details other config files that have this printer
         // in case of removal all have to be removed
-        ::std::list< ::rtl::OUString > m_aAlternateFiles;
+        std::list< rtl::OUString > m_aAlternateFiles;
         // group in m_aFile containing the printer
         // this must be unique over all configuration files
         // it usually should be the printer name
-        ::rtl::OString          m_aGroup;
+        rtl::OString          m_aGroup;
         // whether changes need to be saved
         bool                    m_bModified;
         // the corresponding info and job data
         PrinterInfo             m_aInfo;
     };
 
-    ::std::hash_map< ::rtl::OUString, Printer, ::rtl::OUStringHash > m_aPrinters;
+    std::hash_map< rtl::OUString, Printer, rtl::OUStringHash > m_aPrinters;
     PrinterInfo                         m_aGlobalDefaults;
-    ::std::list< WatchFile >            m_aWatchFiles;
-    ::rtl::OUString                     m_aDefaultPrinter;
-    ::rtl::OUString                     m_aSystemPrintCommand;
-    ::std::list< ::rtl::OUString >      m_aSystemPrintQueues;
+    std::list< WatchFile >            m_aWatchFiles;
+    rtl::OUString                     m_aDefaultPrinter;
+    rtl::OUString                     m_aSystemPrintCommand;
+    std::list< rtl::OUString >      m_aSystemPrintQueues;
 
     SystemQueueInfo*					m_pQueueInfo;
 
-    PrinterInfoManager();
-    ~PrinterInfoManager();
+    Type								m_eType;
 
-    void initialize();
+    PrinterInfoManager( Type eType = Default );
+    virtual ~PrinterInfoManager();
+
+    virtual void initialize();
 
     // fill in font substitutions
     // the resulting hash_map maps from source to target font ids
@@ -197,52 +233,65 @@
     // there can only be one
     static PrinterInfoManager& get();
 
+    // get PrinterInfoManager type
+    Type getType() const { return m_eType; }
+
     // lists the names of all known printers
-    void listPrinters( ::std::list< ::rtl::OUString >& rList ) const;
+    void listPrinters( std::list< rtl::OUString >& rList ) const;
 
     // gets the number of known printers
     int countPrinters() const { return m_aPrinters.size(); }
 
     // gets info about a named printer
-    const PrinterInfo& getPrinterInfo( const ::rtl::OUString& rPrinter ) const;
+    const PrinterInfo& getPrinterInfo( const rtl::OUString& rPrinter ) const;
         
     // gets the name of the default printer
-    const ::rtl::OUString& getDefaultPrinter() const { return m_aDefaultPrinter; }
+    const rtl::OUString& getDefaultPrinter() const { return m_aDefaultPrinter; }
+
+    virtual void setupJobContextData( JobData& rData );
 
     // changes the info about a named printer
-    void changePrinterInfo( const ::rtl::OUString& rPrinter, const PrinterInfo& rNewInfo );
+    virtual void changePrinterInfo( const rtl::OUString& rPrinter, const PrinterInfo& rNewInfo );
 
     // check if the printer configuration has changed
-    bool checkPrintersChanged();
+    virtual bool checkPrintersChanged();
 
     // members for administration (->padmin)
 
     // add a named printer
     // addPrinter fails if a printer with the same name already exists
     // or the driver does not exist
-    bool addPrinter( const ::rtl::OUString& rPrinterName, const ::rtl::OUString& rDriverName );
+    virtual bool addPrinter( const rtl::OUString& rPrinterName, const rtl::OUString& rDriverName );
 
     // remove a named printer
     // this fails if the config file belonging to this printer
     // is not writeable
     // if bCheckOnly is true, the printer is not really removed;
     // this is for checking if the removal would fail
-    bool removePrinter( const ::rtl::OUString& rPrinterName, bool bCheckOnly = false );
+    virtual bool removePrinter( const rtl::OUString& rPrinterName, bool bCheckOnly = false );
 
     // save the changes to all printers. this fails if there
     // is no writable config file at all
-    bool writePrinterConfig();
+    virtual bool writePrinterConfig();
 
     // set a new default printer
     // fails if the specified printer does not exist
-    bool setDefaultPrinter( const ::rtl::OUString& rPrinterName );
+    virtual bool setDefaultPrinter( const rtl::OUString& rPrinterName );
 
     // primarily used internally but also by padmin
     // returns the printer queue names
-    const ::std::list< ::rtl::OUString >& getSystemPrintQueues();
+    virtual const std::list< rtl::OUString >& getSystemPrintQueues();
         
     // similar but returnse whole commandlines
-    void getSystemPrintCommands( ::std::list< ::rtl::OUString >& rCommands );
+    virtual void getSystemPrintCommands( std::list< rtl::OUString >& rCommands );
+
+    // abstract print command
+    // returns a stdio FILE* that a postscript file may be written to
+    // this may either be a regular file or the result of popen()
+    virtual FILE* startSpool( const rtl::OUString& rPrinterName );
+    // close the FILE* returned by startSpool and does the actual spooling
+    // returns a numerical job id
+    virtual int endSpool( const rtl::OUString& rPrinterName, const rtl::OUString& rJobTitle, FILE* pFile );
 };
     
 } // namespace
Index: psprint/source/fontmanager/fontmanager.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/fontmanager/fontmanager.cxx,v
retrieving revision 1.39.20.5
diff -u -r1.39.20.5 fontmanager.cxx
--- psprint/source/fontmanager/fontmanager.cxx	15 Apr 2004 14:28:22 -0000	1.39.20.5
+++ psprint/source/fontmanager/fontmanager.cxx	9 Jun 2004 02:15:30 -0000
@@ -534,12 +534,12 @@
 
 
                 KernPair aPair;
-                for( i = 0; i < pImplTTFont->nkern; i++ )
+                for( i = 0; i < (int)pImplTTFont->nkern; i++ )
                 {
                     const sal_uInt8* pTable = pImplTTFont->kerntables[i];
 
-                    sal_uInt16 nVersion     = getUInt16BE( pTable );
-                    sal_uInt16 nLength      = getUInt16BE( pTable );
+                    /*sal_uInt16 nVersion     =*/ getUInt16BE( pTable );
+                    /*sal_uInt16 nLength      =*/ getUInt16BE( pTable );
                     sal_uInt16 nCoverage    = getUInt16BE( pTable );
 
                     aPair.kern_x    = 0;
@@ -854,7 +854,7 @@
                 RTL_TEXTENCODING_JIS_X_0208
             };
 
-        for( int enc = 0; enc < sizeof( aEncs )/sizeof(aEncs[0]) && m_aEncoding == RTL_TEXTENCODING_DONTKNOW; enc++ )
+        for( unsigned int enc = 0; enc < sizeof( aEncs )/sizeof(aEncs[0]) && m_aEncoding == RTL_TEXTENCODING_DONTKNOW; enc++ )
         {
             sal_Int32 nIndex = 0, nOffset = 1;
             do
@@ -1125,12 +1125,12 @@
  */
 
 PrintFontManager::PrintFontManager() :
-        m_pAtoms( new MultiAtomProvider() ),
         m_nNextFontID( 1 ),
+        m_pAtoms( new MultiAtomProvider() ),
         m_nNextDirAtom( 1 ),
         m_pFontCache( NULL )
 {
-    for( int i = 0; i < sizeof( aAdobeCodes )/sizeof( aAdobeCodes[0] ); i++ )
+    for( unsigned int i = 0; i < sizeof( aAdobeCodes )/sizeof( aAdobeCodes[0] ); i++ )
     {
         m_aUnicodeToAdobename.insert( ::std::hash_multimap< sal_Unicode, ::rtl::OString >::value_type( aAdobeCodes[i].aUnicode, aAdobeCodes[i].pAdobename ) );
         m_aAdobenameToUnicode.insert( ::std::hash_multimap< ::rtl::OString, sal_Unicode, ::rtl::OStringHash >::value_type( aAdobeCodes[i].pAdobename, aAdobeCodes[i].aUnicode ) );
@@ -1221,7 +1221,6 @@
 bool PrintFontManager::analyzeFontFile( int nDirID, const OString& rFontFile, bool bReadFile, const ::std::list<OString>& rXLFDs, ::std::list< PrintFontManager::PrintFont* >& rNewFonts ) const
 {
     rNewFonts.clear();
-    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
 
     OString aDir( getDirectory( nDirID ) );
 
@@ -1949,7 +1948,7 @@
     };
     ::std::list< ByteString > aLines;
 
-    for( int i = 0; i < sizeof(pCommands)/sizeof(pCommands[0]); i++ )
+    for( unsigned int i = 0; i < sizeof(pCommands)/sizeof(pCommands[0]); i++ )
     {
         FILE* pPipe = popen( pCommands[i], "r" );
         aLines.clear();
@@ -3069,7 +3068,7 @@
     // find a directory with write access
     rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
     SvFileStream aFontsDir;
-    int nDirID;
+    int nDirID = 0;
     INetURLObject aDir;
     for( ::std::list< int >::const_iterator dir_it = m_aPrivateFontDirectories.begin();
          ! ( aFontsDir.IsOpen() && aFontsDir.IsWritable() ) && dir_it != m_aPrivateFontDirectories.end(); ++dir_it )
@@ -3692,7 +3691,8 @@
     memset( pGID, 0, sizeof( pGID ) );
     memset( pOldIndex, 0, sizeof( pOldIndex ) );
     int nChar = 1;
-    for( int i = 0; i < nGlyphs; i++ )
+    int i;
+    for( i = 0; i < nGlyphs; i++ )
     {
         if( pNewEncoding[i] == 0 )
         {
@@ -3782,8 +3782,8 @@
     if( aRet.begin() == aRet.end() && aChar != 0 )
     {
         sal_Char aBuf[8];
-        snprintf( (char*)aBuf, sizeof( aBuf ), "uni%.4hX\0", aChar );
-        aRet.push_back( aBuf );
+        sal_Int32 nChars = snprintf( (char*)aBuf, sizeof( aBuf ), "uni%.4hX", aChar );
+        aRet.push_back( OString( aBuf, nChars ) );
     }
 
     return aRet;
Index: psprint/source/fontmanager/makefile.mk
===================================================================
RCS file: /cvs/gsl/psprint/source/fontmanager/makefile.mk,v
retrieving revision 1.4
diff -u -r1.4 makefile.mk
--- psprint/source/fontmanager/makefile.mk	20 Aug 2002 15:00:13 -0000	1.4
+++ psprint/source/fontmanager/makefile.mk	9 Jun 2004 02:15:30 -0000
@@ -66,12 +66,12 @@
 PRJNAME=psprint
 TARGET=fontman
 
-ENVCFLAGS+= -I..$/fontsubset
-
 # --- Settings -----------------------------------------------------
 
 .INCLUDE :  settings.mk
 
+CFLAGS+= -I..$/fontsubset
+
 # --- Files --------------------------------------------------------
 
 SLOFILES=\
Index: psprint/source/fontmanager/parseAFM.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/fontmanager/parseAFM.cxx,v
retrieving revision 1.3
diff -u -r1.3 parseAFM.cxx
--- psprint/source/fontmanager/parseAFM.cxx	20 Jul 2002 15:21:19 -0000	1.3
+++ psprint/source/fontmanager/parseAFM.cxx	9 Jun 2004 02:15:30 -0000
@@ -655,8 +655,7 @@
  */ 
 
 static int
-reallocFontMetrics( void **pp_fontmetrics, int *p_oldcount, unsigned int n_newcount,
-                    unsigned int n_size )
+reallocFontMetrics( void **pp_fontmetrics, int *p_oldcount, int n_newcount, unsigned int n_size )
 {
     char *p_tmpmetrics = NULL;
 
Index: psprint/source/fontsubset/gsub.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/fontsubset/gsub.cxx,v
retrieving revision 1.4.76.1
diff -u -r1.4.76.1 gsub.cxx
--- psprint/source/fontsubset/gsub.cxx	15 Jan 2004 12:58:22 -0000	1.4.76.1
+++ psprint/source/fontsubset/gsub.cxx	9 Jun 2004 02:15:30 -0000
@@ -149,7 +149,7 @@
         if( (nDefaultLangsysOfs != 0) && (nDefaultLangsysOfs != nLangsysOffset) )
         {       
             const FT_Byte* pLangSys = pGsubBase + nOfsScriptList + nOfsScriptTable + nDefaultLangsysOfs;
-            const USHORT nLookupOrder   = NEXT_UShort( pLangSys );
+            /*const USHORT nLookupOrder   =*/ NEXT_UShort( pLangSys );
             const USHORT nReqFeatureIdx = NEXT_UShort( pLangSys );
             const USHORT nCntFeature    = NEXT_UShort( pLangSys );
             aFeatureIndexList.push_back( nReqFeatureIdx );
@@ -163,7 +163,7 @@
         if( nLangsysOffset != 0 )
         {       
             const FT_Byte* pLangSys = pGsubBase + nOfsScriptList + nOfsScriptTable + nLangsysOffset;
-            const USHORT nLookupOrder   = NEXT_UShort( pLangSys );
+            /*const USHORT nLookupOrder   =*/ NEXT_UShort( pLangSys );
             const USHORT nReqFeatureIdx = NEXT_UShort( pLangSys );
             const USHORT nCntFeature    = NEXT_UShort( pLangSys );
             aFeatureIndexList.push_back( nReqFeatureIdx );
@@ -222,7 +222,7 @@
         const USHORT nOfsLookupTable = *it;
         const FT_Byte* pLookupTable = pGsubBase + nOfsLookupList + nOfsLookupTable;
         const USHORT eLookupType        = NEXT_UShort( pLookupTable );
-        const USHORT eLookupFlag        = NEXT_UShort( pLookupTable );
+        /*const USHORT eLookupFlag        =*/ NEXT_UShort( pLookupTable );
         const USHORT nCntLookupSubtable = NEXT_UShort( pLookupTable );
 
         // TODO: switch( eLookupType )
Index: psprint/source/fontsubset/list.c
===================================================================
RCS file: /cvs/gsl/psprint/source/fontsubset/list.c,v
retrieving revision 1.2
diff -u -r1.2 list.c
--- psprint/source/fontsubset/list.c	15 Apr 2003 16:14:04 -0000	1.2
+++ psprint/source/fontsubset/list.c	9 Jun 2004 02:15:30 -0000
@@ -72,8 +72,11 @@
 #include <stdlib.h>
 
 #if OSL_DEBUG_LEVEL == 0
-#define NDEBUG
+#  ifndef NDEBUG
+#    define NDEBUG
+#  endif
 #endif
+
 #include <assert.h>
 
 #ifdef MALLOC_TRACE
Index: psprint/source/fontsubset/sft.c
===================================================================
RCS file: /cvs/gsl/psprint/source/fontsubset/sft.c,v
retrieving revision 1.23.8.5
diff -u -r1.23.8.5 sft.c
--- psprint/source/fontsubset/sft.c	7 Apr 2004 11:04:59 -0000	1.23.8.5
+++ psprint/source/fontsubset/sft.c	9 Jun 2004 02:15:30 -0000
@@ -67,7 +67,9 @@
  */
 
 #if OSL_DEBUG_LEVEL == 0
-#define NDEBUG
+#  ifndef NDEBUG
+#    define NDEBUG
+#  endif
 #endif
 #include <assert.h>
 
@@ -937,19 +939,18 @@
     int i = 0, pCount = 0;
     PSPathElement *p;
 
-    int x0, y0, x1, y1, x2, y2, curx, cury;
+    int x0 = 0, y0 = 0, x1 = 0, y1 = 0, x2, y2, curx, cury;
     int lastOff = 0;                                        /*- last point was off-contour */
     int scflag = 1;                                         /*- start contour flag */
     int ecflag = 0;                                         /*- end contour flag */
     int cp = 0;                                             /*- current point */
+    int StartContour = 0, EndContour = 0;
 
     listSetElementDtor(pList, free);
     *path = 0;
 
     /* if (srcCount > 0) for(;;) */
     while (srcCount > 0) {                                  /*- srcCount does not get changed inside the loop. */
-        int StartContour, EndContour;
-
         if (scflag) {
             int l = cp;
             StartContour = cp;
@@ -2218,10 +2219,10 @@
 static GlyphOffsets *GlyphOffsetsNew(sal_uInt8 *sfntP)
 {
     GlyphOffsets *res = smalloc(sizeof(GlyphOffsets));
-    sal_uInt8 *loca;
+    sal_uInt8 *loca = NULL;
     sal_uInt16 i, numTables = GetUInt16(sfntP, 4, 1);
-    sal_uInt32 locaLen;
-    sal_Int16 indexToLocFormat;
+    sal_uInt32 locaLen = 0;
+    sal_Int16 indexToLocFormat = 0;
 
     for (i = 0; i < numTables; i++) {
         sal_uInt32 tag = GetUInt32(sfntP + 12, 16 * i, 1);
@@ -2380,7 +2381,7 @@
         return res;
     }
 
-    fprintf(outf, "%%!PS-TrueTypeFont-%d.%d-%d.%d\n", ver>>16, ver & 0xFFFF, rev>>16, rev & 0xFFFF);
+    fprintf(outf, "%%!PS-TrueTypeFont-%d.%d-%d.%d\n", (int)(ver>>16), (int)(ver & 0xFFFF), (int)(rev>>16), (int)(rev & 0xFFFF));
     fprintf(outf, "%%%%Creator: %s %s %s\n", modname, modver, modextra);
     fprintf(outf, "%%- Font subset generated from a source font file: '%s'\n", ttf->fname);
     fprintf(outf, "%%- Original font name: %s\n", ttf->psname);
@@ -2398,7 +2399,7 @@
     for (i = 1; i<nGlyphs; i++) {
         fprintf(outf, "Encoding %d /glyph%d put\n", encoding[i], gID[i]);
     }
-    fprintf(outf, "/XUID [103 0 1 16#%08X %d 16#%08X 16#%08X] def\n", rtl_crc32(0, ttf->ptr, ttf->fsize), nGlyphs, rtl_crc32(0, glyphArray, nGlyphs * 2), rtl_crc32(0, encoding, nGlyphs));
+    fprintf(outf, "/XUID [103 0 1 16#%08X %d 16#%08X 16#%08X] def\n", (unsigned int)rtl_crc32(0, ttf->ptr, ttf->fsize), (unsigned int)nGlyphs, (unsigned int)rtl_crc32(0, glyphArray, nGlyphs * 2), (unsigned int)rtl_crc32(0, encoding, nGlyphs));
 
     DumpSfnts(outf, sfntP);
 
Index: psprint/source/fontsubset/ttcr.c
===================================================================
RCS file: /cvs/gsl/psprint/source/fontsubset/ttcr.c,v
retrieving revision 1.4
diff -u -r1.4 ttcr.c
--- psprint/source/fontsubset/ttcr.c	15 Apr 2003 16:14:27 -0000	1.4
+++ psprint/source/fontsubset/ttcr.c	9 Jun 2004 02:15:30 -0000
@@ -73,7 +73,9 @@
 #include <string.h>
 
 #if OSL_DEBUG_LEVEL == 0
-#define NDEBUG
+#  ifndef NDEBUG
+#    define NDEBUG
+#  endif
 #endif
 #include <assert.h>
 
@@ -299,7 +301,7 @@
     TrueTypeCreator *ptr = smalloc(sizeof(TrueTypeCreator));
 
     ptr->tables = listNewEmpty();
-    listSetElementDtor(ptr->tables, TrueTypeTableDispose);
+    listSetElementDtor(ptr->tables, (void(*)(void*))TrueTypeTableDispose);
 
     ptr->tag = tag;
 
@@ -348,7 +350,7 @@
     sal_uInt8 *ttf;
     int i=0, n;
     TableEntry *te;
-    sal_uInt8 *head;     /* saved pointer to the head table data for checkSumAdjustment calculation */
+    sal_uInt8 *head = NULL;     /* saved pointer to the head table data for checkSumAdjustment calculation */
     
     if ((n = listCount(_this->tables)) == 0) return SF_TTFORMAT;
 
@@ -628,7 +630,7 @@
             if (p->format == 0x00030000) {
                 /* do nothing */
             } else {
-                fprintf(stderr, "Unsupported format of a 'post' table: %08X.\n", p->format);
+                fprintf(stderr, "Unsupported format of a 'post' table: %08X.\n", (int)p->format);
             }
             free(p);
         }
@@ -955,7 +957,7 @@
         PutUInt16((sal_uInt16)p->isFixedPitch, post, 12, 1);
         ret = TTCR_OK;
     } else {
-        fprintf(stderr, "Unrecognized format of a post table: %08X.\n", p->format);
+        fprintf(stderr, "Unrecognized format of a post table: %08X.\n", (int)p->format);
         ret = TTCR_POSTFORMAT;
     }
 
Index: psprint/source/helper/helper.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/helper/helper.cxx,v
retrieving revision 1.14.38.4
diff -u -r1.14.38.4 helper.cxx
--- psprint/source/helper/helper.cxx	19 Feb 2004 10:58:14 -0000	1.14.38.4
+++ psprint/source/helper/helper.cxx	9 Jun 2004 02:15:30 -0000
@@ -359,8 +359,8 @@
     {
         // read leading bytes
         bEof = ! rInFile.read( buffer, 6, nRead ) && nRead == 6 ? false : true;
-        int nType = buffer[ 1 ];
-        int nBytesToRead = buffer[2] | buffer[3] << 8 | buffer[4] << 16 | buffer[5] << 24;
+        unsigned int nType = buffer[ 1 ];
+        unsigned int nBytesToRead = buffer[2] | buffer[3] << 8 | buffer[4] << 16 | buffer[5] << 24;
         if( buffer[0] != 0x80 ) // test for pfb m_agic number
         {
             // this migt be a pfa font already
@@ -395,8 +395,8 @@
                     // ascii data, convert dos lineends( \r\n ) and
                     // m_ac lineends( \r ) to \n
                     unsigned char * pWriteBuffer = new unsigned char[ nBytesToRead ];
-                    int nBytesToWrite = 0;
-                    for( int i = 0; i < nBytesToRead; i++ )
+                    unsigned int nBytesToWrite = 0;
+                    for( unsigned int i = 0; i < nBytesToRead; i++ )
                     {
                         if( pBuffer[i] != '\r' )
                             pWriteBuffer[ nBytesToWrite++ ] = pBuffer[i];
@@ -416,8 +416,8 @@
                 else
                 {
                     // binary data
-                    int nBuffer = 0;
-                    for( int i = 0; i < nBytesToRead && bSuccess; i++ )
+                    unsigned int nBuffer = 0;
+                    for( unsigned int i = 0; i < nBytesToRead && bSuccess; i++ )
                     {
                         buffer[ nBuffer++ ] = hexDigits[ pBuffer[ i ] >> 4 ];
                         buffer[ nBuffer++ ] = hexDigits[ pBuffer[ i ] & 15 ];
Index: psprint/source/helper/ppdparser.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/helper/ppdparser.cxx,v
retrieving revision 1.8.38.2
diff -u -r1.8.38.2 ppdparser.cxx
--- psprint/source/helper/ppdparser.cxx	19 Feb 2004 10:58:29 -0000	1.8.38.2
+++ psprint/source/helper/ppdparser.cxx	9 Jun 2004 02:15:30 -0000
@@ -67,16 +67,19 @@
 // define a hash for PPDKey
 namespace psp { class PPDKey; }
 
-struct std::hash< const psp::PPDKey* >
+namespace  _STL {
+struct hash< const psp::PPDKey* >
 {
     size_t operator()( const psp::PPDKey * pKey) const
     { return (size_t)pKey; }
 };
+}
 
 #include <psprint/ppdparser.hxx>
 #include <tools/debug.hxx>
 #include <psprint/strhelper.hxx>
 #include <psprint/helper.hxx>
+#include <cupsmgr.hxx>
 #include <tools/urlobj.hxx>
 #include <tools/stream.hxx>
 #include <osl/mutex.hxx>
@@ -104,13 +107,11 @@
 void PPDParser::scanPPDDir( const String& rDir )
 {
     static const sal_Char* pSuffixes[] = { "PS", "PPD" };
-    static const int nSuffixLens[] = { 2, 3 };
     const int nSuffixes = sizeof(pSuffixes)/sizeof(pSuffixes[0]);
 
     osl::Directory aDir( rDir );
     aDir.open();
     osl::DirectoryItem aItem;
-    bool bWas = false;
 
     INetURLObject aPPDDir(rDir);
     while( aDir.getNextItem( aItem ) == osl::FileBase::E_None )
@@ -275,7 +276,8 @@
     static ::osl::Mutex aMutex;
     ::osl::Guard< ::osl::Mutex > aGuard( aMutex );
 
-    aFile = getPPDFile( aFile );
+    if( aFile.CompareToAscii( "CUPS:", 5 ) != COMPARE_EQUAL )
+        aFile = getPPDFile( aFile );
     if( ! aFile.Len() )
     {
         fprintf( stderr, "Could not get printer PPD file!\n" );
@@ -286,8 +288,21 @@
         if( (*it)->m_aFile == aFile )
             return *it;
 
-    PPDParser *pNewParser = new PPDParser( aFile );
-    aAllParsers.push_back( pNewParser );
+    PPDParser* pNewParser = NULL;
+    if( aFile.CompareToAscii( "CUPS:", 5 ) != COMPARE_EQUAL )
+        pNewParser = new PPDParser( aFile );
+    else
+    {
+        PrinterInfoManager& rMgr = PrinterInfoManager::get();
+        if( rMgr.getType() == PrinterInfoManager::CUPS )
+        {
+            pNewParser = const_cast<PPDParser*>(static_cast<CUPSManager&>(rMgr).createCUPSParser( aFile ));
+            if( pNewParser )
+                pNewParser->m_aFile = aFile;
+        }
+    }
+    if( pNewParser )
+        aAllParsers.push_back( pNewParser );
     return pNewParser;
 }
 
@@ -304,6 +319,7 @@
 
 PPDParser::PPDParser( const String& rFile ) :
         m_aFile( rFile ),
+        m_bType42Capable( false ),
         m_pDefaultImageableArea( NULL ),
         m_pImageableAreas( NULL ),
         m_pDefaultPaperDimension( NULL ),
@@ -314,8 +330,7 @@
         m_pResolutions( NULL ),
         m_pDefaultDuplexType( NULL ),
         m_pDuplexTypes( NULL ),
-        m_pFontList( NULL ),
-        m_bType42Capable( false )
+        m_pFontList( NULL )
 {
     // read in the file
     ::std::list< String > aLines;
@@ -490,7 +505,7 @@
 
 const PPDKey* PPDParser::getKey( int n ) const
 {
-    return (n < m_aOrderedKeys.size() && n >= 0) ? m_aOrderedKeys[n] : NULL;
+    return ((unsigned int)n < m_aOrderedKeys.size() && n >= 0) ? m_aOrderedKeys[n] : NULL;
 }
 
 const PPDKey* PPDParser::getKey( const String& rKey ) const
@@ -1194,10 +1209,10 @@
 
 PPDKey::PPDKey( const String& rKey ) :
         m_aKey( rKey ),
-        m_bUIOption( false ),
-        m_eUIType( PickOne ),
         m_pDefaultValue( NULL ),
         m_bQueryValue( false ),
+        m_bUIOption( false ),
+        m_eUIType( PickOne ),
         m_nOrderDependency( 100 ),
         m_eSetupType( AnySetup )
 {
@@ -1213,14 +1228,13 @@
 
 const PPDValue* PPDKey::getValue( int n ) const
 {
-    return (n < m_aOrderedValues.size() && n >= 0) ? m_aOrderedValues[n] : NULL;
+    return ((unsigned int)n < m_aOrderedValues.size() && n >= 0) ? m_aOrderedValues[n] : NULL;
 }
 
 // -------------------------------------------------------------------
 
 const PPDValue* PPDKey::getValue( const String& rOption ) const
 {
-    const PPDValue* pValue = NULL;
     PPDKey::hash_type::const_iterator it = m_aValues.find( rOption );
     return it != m_aValues.end() ? &it->second : NULL;
 }
@@ -1299,8 +1313,11 @@
 
 void PPDContext::setParser( const PPDParser* pParser )
 {
-    m_aCurrentValues.clear();
-    m_pParser = pParser;
+    if( pParser != m_pParser )
+    {
+        m_aCurrentValues.clear();
+        m_pParser = pParser;
+    }
 }
 
 // -------------------------------------------------------------------
@@ -1539,7 +1556,6 @@
 void* PPDContext::getStreamableBuffer( ULONG& rBytes ) const
 {
     rBytes = 0;
-    int i;
     if( ! m_aCurrentValues.size() )
         return NULL;
     ::std::hash_map< const PPDKey*, const PPDValue* >::const_iterator it;
Index: psprint/source/helper/strhelper.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/helper/strhelper.cxx,v
retrieving revision 1.3.80.1
diff -u -r1.3.80.1 strhelper.cxx
--- psprint/source/helper/strhelper.cxx	9 Jan 2004 18:21:24 -0000	1.3.80.1
+++ psprint/source/helper/strhelper.cxx	9 Jun 2004 02:15:30 -0000
@@ -664,12 +664,12 @@
         *pBuffer++ = '-';
         f = -f;
     }
-    int exponent = log10( f );
+    int exponent = (int)log10( f );
     if( exponent < 4 && exponent > -4 )
         exponent = 0;
     f /= pow( 10, (double) exponent );
 
-    int nInt = f;
+    int nInt = (int)f;
     f -= nInt;
     // f should really not be 1.0 after this, but some
     // hardware implementations seem to round at this point
@@ -696,7 +696,7 @@
         do
         {
             f *= 10;
-            nInt = f;
+            nInt = (int)f;
             f -= nInt;
             // f should really not be 1.0 after this, but some
             // hardware implementations seem to round at this point
Index: psprint/source/printer/jobdata.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printer/jobdata.cxx,v
retrieving revision 1.2.78.1
diff -u -r1.2.78.1 jobdata.cxx
--- psprint/source/printer/jobdata.cxx	9 Jan 2004 18:21:26 -0000	1.2.78.1
+++ psprint/source/printer/jobdata.cxx	9 Jun 2004 02:15:30 -0000
@@ -72,6 +72,30 @@
 using namespace psp;
 using namespace rtl;
 
+JobData& JobData::operator=(const JobData& rRight)
+{
+    m_nCopies				= rRight.m_nCopies;
+    m_nScale				= rRight.m_nScale;
+    m_nLeftMarginAdjust		= rRight.m_nLeftMarginAdjust;
+    m_nRightMarginAdjust	= rRight.m_nRightMarginAdjust;
+    m_nTopMarginAdjust		= rRight.m_nTopMarginAdjust;
+    m_nBottomMarginAdjust	= rRight.m_nBottomMarginAdjust;
+    m_nColorDepth			= rRight.m_nColorDepth;
+    m_eOrientation			= rRight.m_eOrientation;
+    m_aPrinterName			= rRight.m_aPrinterName;
+    m_pParser				= rRight.m_pParser;
+    m_aContext				= rRight.m_aContext;
+    m_nPSLevel				= rRight.m_nPSLevel;
+    m_nColorDevice			= rRight.m_nColorDevice;
+
+    if( ! m_pParser && m_aPrinterName.getLength() )
+    {
+        PrinterInfoManager& rMgr = PrinterInfoManager::get();
+        rMgr.setupJobContextData( *this );
+    }
+    return *this;
+}
+
 bool JobData::getStreamBuffer( void*& pData, int& bytes )
 {
     // consistency checks
Index: psprint/source/printer/makefile.mk
===================================================================
RCS file: /cvs/gsl/psprint/source/printer/makefile.mk,v
retrieving revision 1.2.78.1
diff -u -r1.2.78.1 makefile.mk
--- psprint/source/printer/makefile.mk	28 Jan 2004 11:24:45 -0000	1.2.78.1
+++ psprint/source/printer/makefile.mk	9 Jun 2004 02:15:30 -0000
@@ -70,6 +70,10 @@
 
 .INCLUDE :  settings.mk
 
+#.IF "$(ENABLE_CUPS)" != ""
+CDEFS += -DENABLE_CUPS
+#.ENDIF
+
 # --- Files --------------------------------------------------------
 
 .IF "$(GUIBASE)"=="aqua"
@@ -81,10 +85,19 @@
 
 SLOFILES=\
 	$(SLO)$/printerinfomanager.obj	\
-	$(SLO)$/jobdata.obj
+	$(SLO)$/jobdata.obj				\
+	$(SLO)$/cupsmgr.obj
 
 .ENDIF # GUIBASE = aqua
 
 # --- Targets ------------------------------------------------------
 
 .INCLUDE :  target.mk
+XSALSETLIBNAME=$(DLLPRE)spa$(UPD)$(DLLPOSTFIX)$(DLLPOST)
+
+$(INCCOM)$/rtsname.hxx:
+	rm -f $(INCCOM)$/rtsname.hxx ; \
+	echo "#define _XSALSET_LIBNAME "\"$(XSALSETLIBNAME)\" > $(INCCOM)$/rtsname.hxx
+
+$(SLO)$/cupsmgr.obj : $(INCCOM)$/rtsname.hxx
+
Index: psprint/source/printer/printerinfomanager.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printer/printerinfomanager.cxx,v
retrieving revision 1.19.26.2
diff -u -r1.19.26.2 printerinfomanager.cxx
--- psprint/source/printer/printerinfomanager.cxx	19 Feb 2004 10:58:43 -0000	1.19.26.2
+++ psprint/source/printer/printerinfomanager.cxx	9 Jun 2004 02:15:30 -0000
@@ -67,7 +67,7 @@
 #include <tools/stream.hxx>
 #include <tools/debug.hxx>
 #include <tools/config.hxx>
-#include <psprint/printerinfomanager.hxx>
+#include <cupsmgr.hxx>
 #include <psprint/fontmanager.hxx>
 
 #include <osl/thread.hxx>
@@ -123,17 +123,29 @@
 
 PrinterInfoManager& PrinterInfoManager::get()
 {
-    static PrinterInfoManager aManager;
+    static PrinterInfoManager* pManager = NULL;
 
-    return aManager;
+    if( ! pManager )
+    {
+        pManager = CUPSManager::tryLoadCUPS();
+        if( ! pManager )
+            pManager = new PrinterInfoManager();
+
+        if( pManager )
+            pManager->initialize();
+    }
+
+    return *pManager;
 }
 
 // -----------------------------------------------------------------
 
-PrinterInfoManager::PrinterInfoManager()
+PrinterInfoManager::PrinterInfoManager( Type eType ) :
+        m_pQueueInfo( NULL ),
+        m_eType( eType )
 {
-    m_pQueueInfo = new SystemQueueInfo();
-    initialize();
+    if( eType == Default )
+        m_pQueueInfo = new SystemQueueInfo();
 }
 
 // -----------------------------------------------------------------
@@ -172,7 +184,7 @@
             }
         }
     }
-    if( ! bChanged )
+    if( ! bChanged && m_pQueueInfo )
         bChanged = m_pQueueInfo->hasChanged();
     if( bChanged )
     {
@@ -254,8 +266,12 @@
             m_aGlobalDefaults.m_eOrientation = aValue.EqualsIgnoreCaseAscii( "Landscape" ) ? orientation::Landscape : orientation::Portrait;
 
             aValue = aConfig.ReadKey( "Scale" );
-		  if ( aValue.Len() )
+            if( aValue.Len() )
+            {
                 m_aGlobalDefaults.m_nScale = aValue.ToInt32();
+                if( (m_aGlobalDefaults.m_nScale < 1) || (m_aGlobalDefaults.m_nScale > 1000) )
+                    m_aGlobalDefaults.m_nScale = 100;
+            }
 
             aValue = aConfig.ReadKey( "MarginAdjust" );
             m_aGlobalDefaults.m_nLeftMarginAdjust   = aValue.GetToken( 0, ',' ).ToInt32();
@@ -415,64 +431,71 @@
                 aPrinterName = String( aValue.Copy( nNamePos+1 ), RTL_TEXTENCODING_UTF8 );
                 aPrinter.m_aInfo.m_aPrinterName     = aPrinterName;
                 aPrinter.m_aInfo.m_aDriverName      = String( aValue.Copy( 0, nNamePos ), RTL_TEXTENCODING_UTF8 );
-                aPrinter.m_aInfo.m_pParser          = PPDParser::getParser( aPrinter.m_aInfo.m_aDriverName );
-                aPrinter.m_aInfo.m_aContext.setParser( aPrinter.m_aInfo.m_pParser );
-                // note: setParser also purges the context
-
-                // ignore this printer if its driver is not found
-                if( ! aPrinter.m_aInfo.m_pParser )
-                    continue;
 
-                // merge the ppd context keys if the printer has the same keys and values
-                // this is a bit tricky, since it involves mixing two PPDs
-                // without constraints which might end up badly
-                // this feature should be use with caution
-                // it is mainly to select default paper sizes for new printers
-                for( int nPPDValueModified = 0; nPPDValueModified < m_aGlobalDefaults.m_aContext.countValuesModified(); nPPDValueModified++ )
+                // set parser, merge settings
+                // don't do this for CUPS printers as this is done
+                // by the CUPS system itself
+                if( aPrinter.m_aInfo.m_aDriverName.compareToAscii( "CUPS:", 5 ) != 0 )
                 {
-                    const PPDKey* pDefKey = m_aGlobalDefaults.m_aContext.getModifiedKey( nPPDValueModified );
-                    const PPDValue* pDefValue = m_aGlobalDefaults.m_aContext.getValue( pDefKey );
-                    const PPDKey* pPrinterKey = pDefKey ? aPrinter.m_aInfo.m_pParser->getKey( pDefKey->getKey() ) : NULL;
-                    if( pDefKey && pPrinterKey )
-                        // at least the options exist in both PPDs
+                    aPrinter.m_aInfo.m_pParser          = PPDParser::getParser( aPrinter.m_aInfo.m_aDriverName );
+                    aPrinter.m_aInfo.m_aContext.setParser( aPrinter.m_aInfo.m_pParser );
+                    // note: setParser also purges the context
+
+                    // ignore this printer if its driver is not found
+                    if( ! aPrinter.m_aInfo.m_pParser )
+                        continue;
+
+                    // merge the ppd context keys if the printer has the same keys and values
+                    // this is a bit tricky, since it involves mixing two PPDs
+                    // without constraints which might end up badly
+                    // this feature should be use with caution
+                    // it is mainly to select default paper sizes for new printers
+                    for( int nPPDValueModified = 0; nPPDValueModified < m_aGlobalDefaults.m_aContext.countValuesModified(); nPPDValueModified++ )
                     {
-                        if( pDefValue )
+                        const PPDKey* pDefKey = m_aGlobalDefaults.m_aContext.getModifiedKey( nPPDValueModified );
+                        const PPDValue* pDefValue = m_aGlobalDefaults.m_aContext.getValue( pDefKey );
+                        const PPDKey* pPrinterKey = pDefKey ? aPrinter.m_aInfo.m_pParser->getKey( pDefKey->getKey() ) : NULL;
+                        if( pDefKey && pPrinterKey )
+                            // at least the options exist in both PPDs
                         {
-                            const PPDValue* pPrinterValue = pPrinterKey->getValue( pDefValue->m_aOption );
-                            if( pPrinterValue )
-                                // the printer has a corresponding option for the key
-                                aPrinter.m_aInfo.m_aContext.setValue( pPrinterKey, pPrinterValue );
-                        }
+                            if( pDefValue )
+                            {
+                                const PPDValue* pPrinterValue = pPrinterKey->getValue( pDefValue->m_aOption );
+                                if( pPrinterValue )
+                                    // the printer has a corresponding option for the key
+                                    aPrinter.m_aInfo.m_aContext.setValue( pPrinterKey, pPrinterValue );
+                            }
                         else
                             aPrinter.m_aInfo.m_aContext.setValue( pPrinterKey, NULL );
+                        }
                     }
-                }
 
-                aValue = aConfig.ReadKey( "Command" );
-                // no printer without a command
-                if( ! aValue.Len() )
-                {
-                    /*  TODO:
-                     *  porters: please append your platform to the Solaris
-                     *  case if your platform has SystemV printing per default.
-                     */
+                    aValue = aConfig.ReadKey( "Command" );
+                    // no printer without a command
+                    if( ! aValue.Len() )
+                    {
+                        /*  TODO:
+                         *  porters: please append your platform to the Solaris
+                         *  case if your platform has SystemV printing per default.
+                         */
 #if defined SOLARIS || defined(IRIX)
-                    aValue = "lp";
-#elif defined(MACOSX)
-                    if ( applePrintSystem == kApplePrintingCUPS )
                         aValue = "lp";
-                    else if ( applePrintSystem == kApplePrintingPrintCenter )
-                        aValue = kApplePCPrintCommand;
-                    else
-                    {
-                        // Fallback case is kApplePrintingLPR
-                        aValue = "lpr";
-                    }
+#elif defined(MACOSX)
+                        if ( applePrintSystem == kApplePrintingCUPS )
+                            aValue = "lp";
+                        else if ( applePrintSystem == kApplePrintingPrintCenter )
+                            aValue = kApplePCPrintCommand;
+                        else
+                        {
+                            // Fallback case is kApplePrintingLPR
+                            aValue = "lpr";
+                        }
 #else
-                    aValue = "lpr";
+                        aValue = "lpr";
 #endif
+                    }
+                    aPrinter.m_aInfo.m_aCommand = String( aValue, RTL_TEXTENCODING_UTF8 );
                 }
-                aPrinter.m_aInfo.m_aCommand = String( aValue, RTL_TEXTENCODING_UTF8 );
 
                 aValue = aConfig.ReadKey( "Features" );
                 aPrinter.m_aInfo.m_aFeatures = String( aValue, RTL_TEXTENCODING_UTF8 );
@@ -498,7 +521,11 @@
 
                 aValue = aConfig.ReadKey( "Scale" );
                 if( aValue.Len() )
+                {
                     aPrinter.m_aInfo.m_nScale = aValue.ToInt32();
+                    if( (aPrinter.m_aInfo.m_nScale < 1) || (aPrinter.m_aInfo.m_nScale > 1000) )
+                        aPrinter.m_aInfo.m_nScale = 100;
+                }                
 
                 aValue = aConfig.ReadKey( "MarginAdjust" );
                 if( aValue.Len() )
@@ -533,7 +560,7 @@
                 for( int nKey = 0; nKey < aConfig.GetKeyCount(); nKey++ )
                 {
                     ByteString aKey( aConfig.GetKeyName( nKey ) );
-                    if( aKey.CompareTo( "PPD_", 4 ) == COMPARE_EQUAL )
+                    if( aKey.CompareTo( "PPD_", 4 ) == COMPARE_EQUAL && aPrinter.m_aInfo.m_pParser )
                     {
                         aValue = aConfig.ReadKey( aKey );
                         const PPDKey* pKey = aPrinter.m_aInfo.m_pParser->getKey( String( aKey.Copy( 4 ), RTL_TEXTENCODING_ISO_8859_1 ) );
@@ -570,6 +597,9 @@
         }
     }
 
+    if( m_eType != Default )
+        return;
+
     // set default printer
     if( m_aPrinters.size() )
     {
@@ -743,6 +773,124 @@
         }
 #endif
 
+#ifdef MACOSX
+        // If we are using OS X 10.2 CUPS printing, we want to grab the PPD that this printer
+        // is associated with from /etc/cups/ppd (it's autocreated by the OS X printing system) and
+        // use those values instead of the ones generated in the merged defaults.  We want to make
+        // this system printer just like we assigned it a PPD in padmin.
+        if ( applePrintSystem == kApplePrintingCUPS )
+        {
+            aPrinter.m_aInfo.m_aFontSubstitutes.clear();
+            aPrinter.m_aInfo.m_aFontSubstitutions.clear();
+
+            // Printer's autogenerated PPD will be /etc/cups/ppd/<printername-from-lpstat>.ppd
+            aPrinter.m_aInfo.m_aDriverName      = String( *it );
+            aPrinter.m_aInfo.m_pParser          = PPDParser::getParser( aPrinter.m_aInfo.m_aDriverName );
+            aPrinter.m_aInfo.m_aContext.setParser( aPrinter.m_aInfo.m_pParser );
+
+            if( aPrinter.m_aInfo.m_pParser )
+            {
+                // merge the ppd context keys if the printer has the same keys and values
+                // it is mainly to select default paper sizes for new printers
+                for( int nPPDValueModified = 0; nPPDValueModified < m_aGlobalDefaults.m_aContext.countValuesModified(); nPPDValueModified++ )
+                {
+                    const PPDKey* pDefKey = m_aGlobalDefaults.m_aContext.getModifiedKey( nPPDValueModified );
+                    const PPDValue* pDefValue = m_aGlobalDefaults.m_aContext.getValue( pDefKey );
+				// If the default PPD has a certain key, attempt to get that same key in the Printer's PPD
+                    const PPDKey* pPrinterKey = pDefKey ? aPrinter.m_aInfo.m_pParser->getKey( pDefKey->getKey() ) : NULL;
+
+                    // The key usually merged is PageSize
+                    if( pDefKey && pPrinterKey )
+                    {
+                        // Key exists in both the Default PPD and the printer's specific PPD.
+                        if( pDefValue )
+                        {
+                            const PPDValue* pPrinterValue = pPrinterKey->getValue( pDefValue->m_aOption );
+                            // If the printer has a corresponding option for the key, use printer PPD's option
+                            if( pPrinterValue )
+                                aPrinter.m_aInfo.m_aContext.setValue( pPrinterKey, pPrinterValue );
+                        }
+                        else
+                            aPrinter.m_aInfo.m_aContext.setValue( pPrinterKey, NULL );
+                    }
+                }
+
+                // Some CUPS PPDs on Mac OS X (Epson, HP) don't include the requisite
+                // PageSize information for the value.  We have to fudge it from the
+                // margin information.  Others (Canon BJC 8200) have the coordinates
+			 // but not the "setpagedevice" stuff
+                const PPDKey* pPSizeKey = aPrinter.m_aInfo.m_pParser->getKey( String(RTL_CONSTASCII_USTRINGPARAM("PageSize")) );
+                if ( pPSizeKey )
+                {
+                    int           psIndex = 0;
+                    int           nNumValues = pPSizeKey->countValues();
+
+                    for ( psIndex = 0; psIndex < nNumValues; psIndex++ )
+                    {
+                        const PPDValue*   pPSizeValue = pPSizeKey->getValue( psIndex );
+
+                        // Only take care of PPD values that are not formatted correctly.
+                        if (  pPSizeValue &&
+                              ( !(pPSizeValue->m_aValue.Len()) ||
+                              (pPSizeValue->m_aValue.Len() && (pPSizeValue->m_aValue.SearchAscii("setpagedevice")==STRING_NOTFOUND)) )
+                           )
+                        {
+                            // Deal with the two cases:  1) where there is a blank PageSize value and
+                            // 2) where there are simply the dimensions as the PageSize value
+                            if ( !pPSizeValue->m_aValue.Len() )
+                            {
+                                int     paperWidth;
+                                int     paperHeight;
+                                char    aWidth[ 32 ];
+                                char    aHeight[ 32 ];
+
+                                // Grab dimensions for this paper size from the "PaperDimension" key of the PPD
+                                aPrinter.m_aInfo.m_pParser->getPaperDimension( pPSizeValue->m_aOption, paperWidth, paperHeight );
+                                snprintf( aWidth, 32, "%d", paperWidth );
+                                snprintf( aHeight, 32, "%d", paperHeight );
+
+                                // Construct a suitable PageSize key value from the PaperDimension values for this paper size
+                           	  pPSizeValue->m_aValue.AppendAscii( "<</PageSize [" );
+                                pPSizeValue->m_aValue.AppendAscii( aWidth );
+                           	  pPSizeValue->m_aValue.AppendAscii( " " );
+                                pPSizeValue->m_aValue.AppendAscii( aHeight );
+                           	  pPSizeValue->m_aValue.AppendAscii( "] /ImagingBBox null>> setpagedevice" );
+                            }
+                            else
+            			   {
+                                String  aBox( pPSizeValue->m_aValue );
+				   
+                                // The PageSize value was just the bounding box, add in the correct postscript
+                                pPSizeValue->m_aValue.AssignAscii( "" );
+                           	  pPSizeValue->m_aValue.AppendAscii( "<</PageSize [" );
+                                pPSizeValue->m_aValue.Append( aBox );
+                           	  pPSizeValue->m_aValue.AppendAscii( "] /ImagingBBox null>> setpagedevice" );
+            			   }
+                        }
+                    }
+                }
+            }
+		  else
+            {
+                ByteString  aBytePrinterName = ByteString( UniString(aPrinter.m_aInfo.m_aDriverName), RTL_TEXTENCODING_UTF8 );
+                fprintf( stderr, "Could not get Printer PPD from /etc/cups/ppd for printer '%s'!  Using simple shared printer PPD...\n", aBytePrinterName.GetBuffer() );
+
+                // Some printers don't have the PPDs in /etc/cups/ppd (like Rendezvous-shared ones)
+                // so we have to simply use a stripped down shared printer PPD for them
+                aPrinter.m_aInfo.m_aDriverName    = String( RTL_CONSTASCII_USTRINGPARAM("MacShared") );
+                aPrinter.m_aInfo.m_pParser        = PPDParser::getParser( aPrinter.m_aInfo.m_aDriverName );
+                aPrinter.m_aInfo.m_aContext.setParser( aPrinter.m_aInfo.m_pParser );
+                if( !(aPrinter.m_aInfo.m_pParser) )
+                {
+                    fprintf( stderr, "Warning:  still couldn't load the PPD, MacShared.ppd may be missing.  Will use generic printer PPD.\n" );
+                    aPrinter.m_aInfo.m_aDriverName    = String( RTL_CONSTASCII_USTRINGPARAM("SGENPRT") );
+                    aPrinter.m_aInfo.m_pParser        = PPDParser::getParser( aPrinter.m_aInfo.m_aDriverName );
+                    aPrinter.m_aInfo.m_aContext.setParser( aPrinter.m_aInfo.m_pParser );
+                }
+            }
+        }
+#endif
+
         m_aPrinters[ aPrinterName ] = aPrinter;
     }
 }
@@ -898,16 +1046,19 @@
             aValue += ByteString::CreateFromInt32( it->second.m_aInfo.m_nBottomMarginAdjust );
             pConfig->WriteKey( "MarginAdjust", aValue );
 
-            // write PPDContext
-            for( int i = 0; i < it->second.m_aInfo.m_aContext.countValuesModified(); i++ )
+            if( it->second.m_aInfo.m_aDriverName.compareToAscii( "CUPS:", 5 ) != 0 )
             {
-                const PPDKey* pKey = it->second.m_aInfo.m_aContext.getModifiedKey( i );
-                ByteString aKey( "PPD_" );
-                aKey += ByteString( pKey->getKey(), RTL_TEXTENCODING_ISO_8859_1 );
-
-                const PPDValue* pValue = it->second.m_aInfo.m_aContext.getValue( pKey );
-                aValue = pValue ? ByteString( pValue->m_aOption, RTL_TEXTENCODING_ISO_8859_1 ) : ByteString( "*nil" );
-                pConfig->WriteKey( aKey, aValue );
+                // write PPDContext (not for CUPS)
+                for( int i = 0; i < it->second.m_aInfo.m_aContext.countValuesModified(); i++ )
+                {
+                    const PPDKey* pKey = it->second.m_aInfo.m_aContext.getModifiedKey( i );
+                    ByteString aKey( "PPD_" );
+                    aKey += ByteString( pKey->getKey(), RTL_TEXTENCODING_ISO_8859_1 );
+                    
+                    const PPDValue* pValue = it->second.m_aInfo.m_aContext.getValue( pKey );
+                    aValue = pValue ? ByteString( pValue->m_aOption, RTL_TEXTENCODING_ISO_8859_1 ) : ByteString( "*nil" );
+                    pConfig->WriteKey( aKey, aValue );
+                }
             }
 
             // write font substitution table
@@ -970,6 +1121,14 @@
 
         m_aPrinters[ rPrinterName ] = aPrinter;
         bSuccess = true;
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "new printer %s, level = %d, scale = %d, colordevice = %d, depth = %d\n",
+                 OUStringToOString( rPrinterName, osl_getThreadTextEncoding() ).getStr(),
+                 m_aPrinters[rPrinterName].m_aInfo.m_nPSLevel,
+                 m_aPrinters[rPrinterName].m_aInfo.m_nScale,
+                 m_aPrinters[rPrinterName].m_aInfo.m_nColorDevice,
+                 m_aPrinters[rPrinterName].m_aInfo.m_nColorDepth );
+#endif
     }
     return bSuccess;
 }
@@ -1147,7 +1306,7 @@
 
 void PrinterInfoManager::getSystemPrintCommands( std::list< OUString >& rCommands )
 {
-    if( m_pQueueInfo->hasChanged() )
+    if( m_pQueueInfo && m_pQueueInfo->hasChanged() )
     {
         m_aSystemPrintCommand = m_pQueueInfo->getCommand();
         m_pQueueInfo->getSystemQueues( m_aSystemPrintQueues );
@@ -1166,7 +1325,7 @@
 
 const std::list< OUString >& PrinterInfoManager::getSystemPrintQueues()
 {
-    if( m_pQueueInfo->hasChanged() )
+    if( m_pQueueInfo && m_pQueueInfo->hasChanged() )
     {
         m_aSystemPrintCommand = m_pQueueInfo->getCommand();
         m_pQueueInfo->getSystemQueues( m_aSystemPrintQueues );
@@ -1175,6 +1334,32 @@
     return m_aSystemPrintQueues;
 }
 
+FILE* PrinterInfoManager::startSpool( const OUString& rPrintername )
+{
+    const PrinterInfo&   rPrinterInfo	= getPrinterInfo (rPrintername);
+    const rtl::OUString& rCommand		= rPrinterInfo.m_aCommand;
+    const rtl::OString aShellCommand	= OUStringToOString (rCommand, RTL_TEXTENCODING_ISO_8859_1);
+													  
+    return popen (aShellCommand.getStr(), "w");
+}
+
+int PrinterInfoManager::endSpool( const OUString& rPrintername, const OUString& rJobTitle, FILE* pFile )
+{
+    pclose( pFile );
+    return 0; // job id ?
+}
+
+void PrinterInfoManager::setupJobContextData( JobData& rData )
+{
+    std::hash_map< OUString, Printer, OUStringHash >::iterator it =
+        m_aPrinters.find( rData.m_aPrinterName );
+    if( it != m_aPrinters.end() )
+    {
+        rData.m_pParser		= it->second.m_aInfo.m_pParser;
+        rData.m_aContext	= it->second.m_aInfo.m_aContext;
+    }
+}
+
 // -----------------------------------------------------------------
 
 SystemQueueInfo::SystemQueueInfo() :
@@ -1245,7 +1430,7 @@
 {
     char pBuffer[1024];
     ByteString aPrtQueueCmd, aForeToken, aAftToken, aString;
-    int nForeTokenCount, i;
+    int nForeTokenCount = 0, i;
     FILE *pPipe;
     bool bSuccess = false;
     std::list< ByteString > aLines;
Index: psprint/source/printergfx/bitmap_gfx.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/bitmap_gfx.cxx,v
retrieving revision 1.6
diff -u -r1.6 bitmap_gfx.cxx
--- psprint/source/printergfx/bitmap_gfx.cxx	26 Mar 2003 14:24:07 -0000	1.6
+++ psprint/source/printergfx/bitmap_gfx.cxx	9 Jun 2004 02:15:30 -0000
@@ -71,8 +71,8 @@
 
 namespace psp {
 
-const sal_Int32 nLineLength = 80;
-const sal_Int32 nBufferSize = 16384;
+const sal_uInt32 nLineLength = 80;
+const sal_uInt32 nBufferSize = 16384;
 
 /*
  * 
@@ -197,9 +197,9 @@
 
 Ascii85Encoder::Ascii85Encoder (osl::File* pFile) :
         mpFile (pFile),
-        mnOffset (0),
+        mnByte (0),
         mnColumn (0),
-        mnByte (0)
+        mnOffset (0)
 {}
 
 inline void
@@ -591,13 +591,14 @@
     sal_Int32 nChar = 0;
     sal_Char  pImage [512];
 
-    sal_Int32 nDictType;
+    sal_Int32 nDictType = 0;
     switch (nType)
     {
         case psp::TrueColorImage:  nDictType = 0; break;
         case psp::PaletteImage:    nDictType = 1; break;
         case psp::GrayScaleImage:  nDictType = 2; break;
         case psp::MonochromeImage: nDictType = 3; break;
+        default: break;
     }
     sal_Int32 nCompressType = mbCompressBmp ? 1 : 0;
 
@@ -630,14 +631,15 @@
 
         case psp::MonochromeImage: 
         case psp::PaletteImage:
+        {
 
             sal_Int32 nChar = 0;
             sal_Char  pImage [4096];
 
-            sal_Int32 nSize = rBitmap.GetPaletteEntryCount() - 1;
+            const sal_uInt32 nSize = rBitmap.GetPaletteEntryCount();
 
             nChar += psp::appendStr ("[/Indexed /DeviceRGB ", pImage + nChar);
-            nChar += psp::getValueOf (rBitmap.GetPaletteEntryCount() - 1, pImage + nChar);
+            nChar += psp::getValueOf (nSize - 1, pImage + nChar);
             if (mbCompressBmp)
                 nChar += psp::appendStr ("\npsp_lzwstring\n", pImage + nChar);
             else
@@ -646,7 +648,7 @@
 
             ByteEncoder* pEncoder = mbCompressBmp ? new LZWEncoder(mpPageBody) 
                                                   : new Ascii85Encoder(mpPageBody);
-            for (sal_Int32 i = 0; i < rBitmap.GetPaletteEntryCount(); i++)
+            for (sal_uInt32 i = 0; i < nSize; i++)
             {
                 PrinterColor aColor = rBitmap.GetPaletteColor(i);
 
@@ -657,8 +659,9 @@
             delete pEncoder;
           
             WritePS (mpPageBody, "pop ] setcolorspace\n");
-  
-            break;
+        }
+        break;
+        default: break;
     }
 }
 
Index: psprint/source/printergfx/common_gfx.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/common_gfx.cxx,v
retrieving revision 1.11.44.2
diff -u -r1.11.44.2 common_gfx.cxx
--- psprint/source/printergfx/common_gfx.cxx	2 Apr 2004 12:15:06 -0000	1.11.44.2
+++ psprint/source/printergfx/common_gfx.cxx	9 Jun 2004 02:15:31 -0000
@@ -94,7 +94,9 @@
 GraphicsStatus::GraphicsStatus() :
         mnTextHeight( 0 ),
         mnTextWidth( 0 ),
-        mfLineWidth( -1 )
+        mfLineWidth( -1 ),
+        mbArtItalic( false ),
+        mbArtBold( false )
 {
 }
 
@@ -131,8 +133,8 @@
     mpPageHeader    = NULL;
     mpPageBody      = NULL;
     mnDepth         = rData.m_nColorDepth;
-    mnPSLevel       = rData.m_nPSLevel ? rData.m_nPSLevel : rData.m_pParser->getLanguageLevel();
-    mbColor         = rData.m_nColorDevice ? ( rData.m_nColorDevice == -1 ? sal_False : sal_True ) : ( rData.m_pParser->isColorDevice() ? sal_True : sal_False );
+    mnPSLevel       = rData.m_nPSLevel ? rData.m_nPSLevel : (rData.m_pParser ? rData.m_pParser->getLanguageLevel() : 2 );
+    mbColor         = rData.m_nColorDevice ? ( rData.m_nColorDevice == -1 ? sal_False : sal_True ) : (( rData.m_pParser ?  (rData.m_pParser->isColorDevice() ? sal_True : sal_False ) : sal_True ) );
     int nRes = rData.m_aContext.getRenderResolution();
     mnDpi           = nRes;
     mfScaleX        = (double)72.0 / (double)mnDpi;
@@ -174,12 +176,13 @@
         mpPageBody (NULL),
         mnFontID (0),
         mnFallbackID (0),
-        maLineColor (0, 0xff, 0),
-        maFillColor (0xff,0,0),
-        maTextColor (0,0,0),
+        mnTextAngle (0),
         mbTextVertical (false),
         mrFontMgr (PrintFontManager::get()),
         mbCompressBmp (sal_True),
+        maFillColor (0xff,0,0),
+        maTextColor (0,0,0),
+        maLineColor (0, 0xff, 0),
         mpFontSubstitutes( NULL )
 {
     maVirtualStatus.mfLineWidth = 1.0;
@@ -489,7 +492,7 @@
         
     PSBinStartPath();
     PSBinMoveTo( pPath[0], aPoint, nColumn );
-    for( int n = 1; n < nPoints; n++ )
+    for( unsigned int n = 1; n < nPoints; n++ )
         PSBinLineTo( pPath[n], aPoint, nColumn );
     if( pPath[0] != pPath[nPoints-1] )
         PSBinLineTo( pPath[0], aPoint, nColumn );
@@ -531,14 +534,14 @@
 
 
     // setup closed path
-    for( int i = 0; i < nPoly; i++ )
+    for( unsigned int i = 0; i < nPoly; i++ )
     {
         Point aPoint( 0, 0 );
         sal_Int32 nColumn( 0 );
         
         PSBinStartPath();
         PSBinMoveTo( pPaths[i][0], aPoint, nColumn );
-        for( int n = 1; n < pSizes[i]; n++ )
+        for( unsigned int n = 1; n < pSizes[i]; n++ )
             PSBinLineTo( pPaths[i][n], aPoint, nColumn );
         if( pPaths[i][0] != pPaths[i][pSizes[i]-1] )
                 PSBinLineTo( pPaths[i][0], aPoint, nColumn );
@@ -593,25 +596,25 @@
         }
         else
         {
-            snprintf(pString, nBezString, "%i %i moveto\n", pPath[0].X(), pPath[0].Y());
+            snprintf(pString, nBezString, "%li %li moveto\n", pPath[0].X(), pPath[0].Y());
             WritePS(mpPageBody, pString);
         }
         
         // Handle the drawing of mixed lines mixed with curves 
         // - a normal point followed by a normal point is a line
         // - a normal point followed by 2 control points and a normal point is a curve
-        for (int i=1; i<nPoints;)
+        for (unsigned int i=1; i<nPoints;)
         {
             if (pFlgAry[i+1] != POLY_CONTROL) //If the next point is a POLY_NORMAL, we're drawing a line
             {
                 if (i+1 >= nPoints) return; //Make sure we don't pass the end of the array
-                snprintf(pString, nBezString, "%i %i lineto\n", pPath[i].X(), pPath[i].Y());
+                snprintf(pString, nBezString, "%li %li lineto\n", pPath[i].X(), pPath[i].Y());
                 i++;
             }
             else //Otherwise we're drawing a spline
             {
                 if (i+3 >= nPoints) return; //Make sure we don't pass the end of the array
-                snprintf(pString, nBezString, "%i %i %i %i %i %i curveto\n",
+                snprintf(pString, nBezString, "%li %li %li %li %li %li curveto\n",
                         pPath[i+1].X(), pPath[i+1].Y(),
                         pPath[i+2].X(), pPath[i+2].Y(),
                         pPath[i+3].X(), pPath[i+3].Y());
@@ -656,13 +659,13 @@
     if (!(nPoints > 1) || (pPath == NULL) || !(maFillColor.Is() || maLineColor.Is()))
         return;
     
-    snprintf(pString, nBezString, "%i %i moveto\n", pPath[0].X(), pPath[0].Y());
+    snprintf(pString, nBezString, "%li %li moveto\n", pPath[0].X(), pPath[0].Y());
     WritePS(mpPageBody, pString); //Move to the starting point for the PolyPoygon
-    for (int i=1; i < nPoints;) 
+    for (unsigned int i=1; i < nPoints;) 
     {
         if (pFlgAry[i] != POLY_CONTROL)
         {
-            snprintf(pString, nBezString, "%i %i lineto\n", pPath[i].X(), pPath[i].Y());
+            snprintf(pString, nBezString, "%li %li lineto\n", pPath[i].X(), pPath[i].Y());
             WritePS(mpPageBody, pString);
             i++;
         }
@@ -673,7 +676,7 @@
             if ((pFlgAry[i] == POLY_CONTROL) && (pFlgAry[i+1] == POLY_CONTROL) &&
                     (pFlgAry[i+2] != POLY_CONTROL))
             {
-                snprintf(pString, nBezString, "%i %i %i %i %i %i curveto\n",
+                snprintf(pString, nBezString, "%li %li %li %li %li %li curveto\n",
                         pPath[i].X(), pPath[i].Y(), 
                         pPath[i+1].X(), pPath[i+1].Y(), 
                         pPath[i+2].X(), pPath[i+2].Y());
@@ -712,22 +715,22 @@
         return;
     
     
-    for (int i=0; i<nPoly;i++)
+    for (unsigned int i=0; i<nPoly;i++)
     {
         sal_uInt32 nPoints = pPoints[i];
         // #112689# sanity check
         if( nPoints == 0 || pPtAry[i] == NULL )
             continue;
         
-        snprintf(pString, nBezString, "%i %i moveto\n", pPtAry[i][0].X(), pPtAry[i][0].Y()); //Move to the starting point
+        snprintf(pString, nBezString, "%li %li moveto\n", pPtAry[i][0].X(), pPtAry[i][0].Y()); //Move to the starting point
         WritePS(mpPageBody, pString);
-        for (int j=1; j < nPoints;)
+        for (unsigned int j=1; j < nPoints;)
         {
             // if no flag array exists for this polygon, then it must be a regular
             // polygon without beziers
             if ( ! pFlgAry[i] || pFlgAry[i][j] != POLY_CONTROL)
             {
-                snprintf(pString, nBezString, "%i %i lineto\n", pPtAry[i][j].X(), pPtAry[i][j].Y());
+                snprintf(pString, nBezString, "%li %li lineto\n", pPtAry[i][j].X(), pPtAry[i][j].Y());
                 WritePS(mpPageBody, pString);
                 j++;
             }
@@ -737,7 +740,7 @@
                     break; //Error: wrong sequence of contol/normal points somehow
                 if ((pFlgAry[i][j] == POLY_CONTROL) && (pFlgAry[i][j+1] == POLY_CONTROL) && (pFlgAry[i][j+2] != POLY_CONTROL))
                 {
-                    snprintf(pString, nBezString, "%i %i %i %i %i %i curveto\n",
+                    snprintf(pString, nBezString, "%li %li %li %li %li %li curveto\n",
                             pPtAry[i][j].X(), pPtAry[i][j].Y(), 
                             pPtAry[i][j+1].X(), pPtAry[i][j+1].Y(), 
                             pPtAry[i][j+2].X(), pPtAry[i][j+2].Y());
@@ -849,15 +852,20 @@
 PrinterGfx::PSSetFont ()
 {
     GraphicsStatus& rCurrent( currentState() );
-    if( maVirtualStatus.maFont           != rCurrent.maFont         ||
-        maVirtualStatus.mnTextHeight     != rCurrent.mnTextHeight   ||
-        maVirtualStatus.maEncoding       != rCurrent.maEncoding     ||
-        maVirtualStatus.mnTextWidth      != rCurrent.mnTextWidth )
+    if( maVirtualStatus.maFont			!= rCurrent.maFont			||
+        maVirtualStatus.mnTextHeight	!= rCurrent.mnTextHeight	||
+        maVirtualStatus.maEncoding      != rCurrent.maEncoding		||
+        maVirtualStatus.mnTextWidth     != rCurrent.mnTextWidth		||
+        maVirtualStatus.mbArtBold		!= rCurrent.mbArtBold		||
+        maVirtualStatus.mbArtItalic		!= rCurrent.mbArtItalic
+        )
     {
         rCurrent.maFont              = maVirtualStatus.maFont;
         rCurrent.maEncoding          = maVirtualStatus.maEncoding;
         rCurrent.mnTextWidth         = maVirtualStatus.mnTextWidth;
         rCurrent.mnTextHeight        = maVirtualStatus.mnTextHeight;
+        rCurrent.mbArtItalic		 = maVirtualStatus.mbArtItalic;
+        rCurrent.mbArtBold			 = maVirtualStatus.mbArtBold;
 
         sal_Int32 nTextHeight = rCurrent.mnTextHeight;
         sal_Int32 nTextWidth  = rCurrent.mnTextWidth ? rCurrent.mnTextWidth 
@@ -894,10 +902,24 @@
                                                     pSetFont + nChar);
         }
 
-        nChar += psp::getValueOf (nTextWidth,   pSetFont + nChar);
-        nChar += psp::appendStr  (" ",          pSetFont + nChar);
-        nChar += psp::getValueOf (-nTextHeight, pSetFont + nChar);
-        nChar += psp::appendStr  (" matrix scale makefont setfont\n", pSetFont + nChar);
+        if( ! rCurrent.mbArtItalic )
+        {
+            nChar += psp::getValueOf (nTextWidth,   pSetFont + nChar);
+            nChar += psp::appendStr  (" ",          pSetFont + nChar);
+            nChar += psp::getValueOf (-nTextHeight, pSetFont + nChar);
+            nChar += psp::appendStr  (" matrix scale makefont setfont\n", pSetFont + nChar);
+        }
+        else // skew 15 degrees to right
+        {
+            nChar += psp::appendStr  ( " [",		pSetFont + nChar);
+            nChar += psp::getValueOf (nTextWidth,	pSetFont + nChar);
+            nChar += psp::appendStr  (" 0 ",        pSetFont + nChar);
+            nChar += psp::getValueOfDouble (pSetFont + nChar, 0.27*(double)nTextWidth, 3 );
+            nChar += psp::appendStr  ( " ",			pSetFont + nChar);
+            nChar += psp::getValueOf (-nTextHeight, pSetFont + nChar);
+            
+            nChar += psp::appendStr  (" 0 0] makefont setfont\n", pSetFont + nChar);
+        }
 
         WritePS (mpPageBody, pSetFont);
     }
@@ -1023,7 +1045,7 @@
 
     PSBinStartPath ();
     PSBinMoveTo (*pPath, aPoint, nColumn);
-    for (int i = 1; i < nPoints; i++)
+    for (unsigned int i = 1; i < nPoints; i++)
         PSBinLineTo (pPath[i], aPoint, nColumn);
     PSBinEndPath ();
 }
@@ -1168,17 +1190,40 @@
         PSRotate (mnTextAngle);
     }
 
+    sal_Char pBuffer[256];
+    if( maVirtualStatus.mbArtBold )
+    {
+        sal_Int32 nLW = maVirtualStatus.mnTextWidth;
+        if( nLW == 0 )
+            nLW = maVirtualStatus.mnTextHeight;
+        else
+            nLW = nLW < maVirtualStatus.mnTextHeight ? nLW : maVirtualStatus.mnTextHeight;
+        psp::getValueOfDouble( pBuffer, (double)nLW / 30.0 );
+    }
     // dispatch to the drawing method
     if (pDeltaArray == NULL)
     {
         PSHexString (pStr, nBytes);
-        WritePS (mpPageBody, "show\n");
+            
+        if( maVirtualStatus.mbArtBold )
+        {
+            WritePS( mpPageBody, pBuffer );
+            WritePS( mpPageBody, " bshow\n" );
+        }
+        else
+            WritePS (mpPageBody, "show\n");
     }
     else
     {
         PSHexString (pStr, nBytes);
         PSDeltaArray (pDeltaArray, nGlyphs - 1);
-        WritePS (mpPageBody, "xshow\n");
+        if( maVirtualStatus.mbArtBold )
+        {
+            WritePS( mpPageBody, pBuffer );
+            WritePS( mpPageBody, " bxshow\n" );
+        }
+        else
+            WritePS (mpPageBody, "xshow\n");
     }
 
     // restore the user coordinate system   
@@ -1210,6 +1255,8 @@
 {
     if( nSize == 0 )
         return sal_True;
+    if( ! mpPageBody )
+        return sal_False;
 
     sal_Bool bSuccess = sal_False;
 
@@ -1263,10 +1310,8 @@
     {
         double fScaleX = (double)rBoundingBox.GetWidth()/(fRight-fLeft);
         double fScaleY = -(double)rBoundingBox.GetHeight()/(fTop-fBottom);
-        Point aTranslatePoint( rBoundingBox.Left()-fLeft*fScaleX,
-                               rBoundingBox.Bottom()+1-fBottom*fScaleY );
-        char buffer[128];
-
+        Point aTranslatePoint( (int)(rBoundingBox.Left()-fLeft*fScaleX),
+                               (int)(rBoundingBox.Bottom()+1-fBottom*fScaleY) );
         // prepare EPS
         WritePS( mpPageBody,
                  "/b4_Inc_state save def\n"
Index: psprint/source/printergfx/printerjob.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/printerjob.cxx,v
retrieving revision 1.21.44.4
diff -u -r1.21.44.4 printerjob.cxx
--- psprint/source/printergfx/printerjob.cxx	7 Apr 2004 11:05:16 -0000	1.21.44.4
+++ psprint/source/printergfx/printerjob.cxx	9 Jun 2004 02:15:31 -0000
@@ -143,8 +143,8 @@
 
     pSrc->setPos (osl_Pos_Absolut, 0);
 
-    sal_uInt64 nIn;
-    sal_uInt64 nOut;
+    sal_uInt64 nIn = 0;
+    sal_uInt64 nOut = 0;
     do
     {
         pSrc->read  (pBuffer, nBlockSize, nIn);
@@ -267,8 +267,8 @@
  */ 
 
 PrinterJob::PrinterJob () :
-        mpJobTrailer (NULL),
-        mpJobHeader (NULL)
+        mpJobHeader (NULL),
+        mpJobTrailer (NULL)
 {
 }
 
@@ -451,6 +451,8 @@
     rtl::OUString aExt = rtl::OUString::createFromAscii (".ps");
     mpJobHeader  = CreateSpoolFile (rtl::OUString::createFromAscii("psp_head"), aExt);
     mpJobTrailer = CreateSpoolFile (rtl::OUString::createFromAscii("psp_tail"), aExt);
+    if( ! (mpJobHeader && mpJobTrailer) ) // existing files are removed in destructor
+        return sal_False;
 
     // write document header according to Document Structuring Conventions (DSC)
     WritePS (mpJobHeader,
@@ -481,6 +483,7 @@
 
     // Document Title
     aFilterWS = WhitespaceToSpace( rJobName, FALSE );
+    maJobName = aFilterWS;
     WritePS (mpJobHeader, "%%Title: "); 
     WritePS (mpJobHeader, aFilterWS);
     WritePS (mpJobHeader, "\n");
@@ -519,8 +522,11 @@
 
     // write document setup (done here because it
     // includes the accumulated fonts
-    writeSetup( mpJobHeader, m_aDocumentJobData );
+    if( mpJobHeader )
+        writeSetup( mpJobHeader, m_aDocumentJobData );
     m_pGraphics->OnEndJob();
+    if( ! (mpJobHeader && mpJobTrailer) )
+        return sal_False;
 
     // write document trailer according to Document Structuring Conventions (DSC)
     rtl::OStringBuffer aTrailer(512);
@@ -575,6 +581,12 @@
     }
     else
     {
+#ifndef MACOSX
+        PrinterInfoManager& rPrinterInfoManager = PrinterInfoManager::get ();
+        pDestFILE = rPrinterInfoManager.startSpool( m_aLastJobData.m_aPrinterName );
+        if (pDestFILE == NULL)
+            return sal_False;
+#else
         const PrinterInfoManager& rPrinterInfoManager = PrinterInfoManager::get ();
         const rtl::OUString& rPrinter     = m_aLastJobData.m_aPrinterName;
         const PrinterInfo&   rPrinterInfo = rPrinterInfoManager.getPrinterInfo (rPrinter);
@@ -587,19 +599,12 @@
          *           All other OS X/Darwin cases use spool to file.
 	    * Other UNIX:  always open a pipe.
          */
-        if (
-           #ifdef MACOSX
-               applePrintSysType == kApplePrintingLPR
-           #else
-               sal_True
-           #endif
-           )
+        if ( applePrintSysType == kApplePrintingLPR )
         {
             pDestFILE = popen (aShellCommand.getStr(), "w");
             if (pDestFILE == NULL)
                 return sal_False;
         }
-     #ifdef MACOSX
         else
         {
             /* Spool to file instead so we can convert it.  Cases used here:
@@ -624,7 +629,7 @@
                 return sal_False;
             }
         }
-     #endif
+#endif
     }
 
     /* spool the document parts to the destination */
@@ -633,25 +638,36 @@
 
     AppendPS (pDestFILE, mpJobHeader, pBuffer);
     mpJobHeader->close();
-    
+
+    sal_Bool bSuccess = sal_True;
     std::list< osl::File* >::iterator pPageBody;
     std::list< osl::File* >::iterator pPageHead;
     for (pPageBody  = maPageList.begin(), pPageHead  = maHeaderList.begin();
          pPageBody != maPageList.end() && pPageHead != maHeaderList.end(); 
          pPageBody++, pPageHead++)
     {
-        osl::File::RC nError = (*pPageHead)->open(OpenFlag_Read);
-        if (nError == osl::File::E_None)
+        if( *pPageHead )
         {
-            AppendPS (pDestFILE, *pPageHead, pBuffer);
-            (*pPageHead)->close();
+            osl::File::RC nError = (*pPageHead)->open(OpenFlag_Read);
+            if (nError == osl::File::E_None)
+            {
+                AppendPS (pDestFILE, *pPageHead, pBuffer);
+                (*pPageHead)->close();
+            }
         }
-        nError = (*pPageBody)->open(OpenFlag_Read);
-        if (nError == osl::File::E_None)
+        else
+            bSuccess = sal_False;
+        if( *pPageBody )
         {
-            AppendPS (pDestFILE, *pPageBody, pBuffer);
-            (*pPageBody)->close();
+            osl::File::RC nError = (*pPageBody)->open(OpenFlag_Read);
+            if (nError == osl::File::E_None)
+            {
+                AppendPS (pDestFILE, *pPageBody, pBuffer);
+                (*pPageBody)->close();
+            }
         }
+        else
+            bSuccess = sal_False;
     }
     
     AppendPS (pDestFILE, mpJobTrailer, pBuffer);
@@ -662,8 +678,13 @@
     if (bSpoolToFile)
         fclose (pDestFILE);
     else
+#ifndef MACOSX
+    {
+        PrinterInfoManager& rPrinterInfoManager = PrinterInfoManager::get();
+        rPrinterInfoManager.endSpool( m_aLastJobData.m_aPrinterName, maJobName, pDestFILE );
+    }
+#else
     {
-        #ifdef MACOSX
             sal_uInt32	nXdpi;
             sal_uInt32	nYdpi;
 
@@ -691,14 +712,9 @@
                                            aShellCommand,
                                            aDriverName,
                                            m_aLastJobData,
-                                           &maJobName,
+                                           &maJobTitle,
                                            mnResolution );
-        #else
-            pclose (pDestFILE);
-        #endif
     }
-
-#ifdef MACOSX
     /* If we created a spool file for our Mac OS X/Darwin job,
      * delete it.  Also free the variable, since it is malloc()ed in macxp_tempnam()
      * and otherwise we'd leak memory.
@@ -710,7 +726,7 @@
     }
 #endif
 
-    return sal_True;
+    return bSuccess;
 }
 
 #ifdef MACOSX
@@ -1041,6 +1057,9 @@
     maHeaderList.push_back (pPageHeader);
     maPageList.push_back (pPageBody);
 
+    if( ! (pPageHeader && pPageBody) )
+        return sal_False;
+
     /* #i7262# write setup only before first page
      *  don't do this in StartJob since the jobsetup there may be
      *  different.
@@ -1088,6 +1107,9 @@
     osl::File* pPageHeader = maHeaderList.back();
     osl::File* pPageBody   = maPageList.back();
 
+    if( ! (pPageBody && pPageHeader) )
+        return sal_False;
+
     // copy page to paper and write page trailer according to DSC
 
     sal_Char pTrailer[256];
@@ -1143,7 +1165,7 @@
 
     // emit features ordered to OrderDependency
     // ignore features that are set to default
-    const PPDContext& rContext = rJob.m_aContext;
+
     // sanity check
     if( rJob.m_pParser == rJob.m_aContext.getParser() &&
         rJob.m_pParser &&
@@ -1314,6 +1336,12 @@
         "rlineto closepath } def\n"
         "/rectfill { rectangle fill } def\n"
         "/rectstroke { rectangle stroke } def } if\n"
+        "/bshow { currentlinewidth 3 1 roll currentpoint 3 index show moveto\n"
+        "setlinewidth false charpath stroke setlinewidth } def\n"
+        "/bxshow { currentlinewidth 4 1 roll setlinewidth exch dup length 1 sub\n"
+        "0 1 3 -1 roll { 1 string 2 index 2 index get 1 index exch 0 exch put dup\n"
+        "currentpoint 3 -1 roll show moveto currentpoint 3 -1 roll false charpath\n"
+        "stroke moveto 2 index exch get 0 rmoveto } for pop pop setlinewidth } def\n"
         "\n"
 		"/psp_lzwfilter { currentfile /ASCII85Decode filter /LZWDecode filter } def\n"
 		"/psp_ascii85filter { currentfile /ASCII85Decode filter } def\n"
Index: psprint/source/printergfx/psheader.ps
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/psheader.ps,v
retrieving revision 1.4
diff -u -r1.4 psheader.ps
--- psprint/source/printergfx/psheader.ps	26 Mar 2003 14:24:09 -0000	1.4
+++ psprint/source/printergfx/psheader.ps	9 Jun 2004 02:15:31 -0000
@@ -339,3 +339,65 @@
     /psp_reencodedfont exch definefont
 } def
 
+% bshow shows a text in artificial bold
+% this is achieved by first showing the text
+% then stroking its outline over it with
+% the linewidth set to the second parameter
+% usage: (string) num bshow
+
+/bshow {
+  currentlinewidth		% save current linewidth
+  3 1 roll				% move it to the last stack position
+  currentpoint			% save the current point
+  3 index				% copy the string to show
+  show					% show it
+  moveto				% move to the original coordinates again
+  setlinewidth			% set the linewidth
+  false charpath		% create the outline path of the shown string
+  stroke				% and stroke it
+  setlinewidth			% reset the stored linewidth
+} def
+
+% bxshow shows a text with a delta array in artificial bold
+% that is it does what bshow does for show
+% usage: (string) [deltaarray] num bxshow
+
+/bxshow {
+  currentlinewidth		% save linewidth
+  4 1 roll				% move it to the last stack position
+  setlinewidth			% set the new linewidth
+  exch					% exchange string and delta array
+  dup
+  length				% get length of string
+  1 sub					% prepare parameters for {} for
+  0 1
+  3 -1 roll
+  {
+    1 string			% create a string object length 1
+    2 index				% get the text
+    2 index				% get charpos (for index variable)
+    get					% have char value at charpos
+    1 index				% prepare string for put
+    exch
+    0
+    exch
+    put					% put into string of length 1
+    dup					% duplicate the it
+    currentpoint		% save current position
+    3 -1 roll			% prepare show
+    show				% show the character
+    moveto				% move back to beginning
+    currentpoint		% save current position
+    3 -1 roll			% prepare outline path of character
+    false charpath
+    stroke				% stroke it
+    moveto				% move back
+    % now move to next point
+    2 index				% get advance array
+    exch				% get charpos
+    get					% get advance element
+    0 rmoveto			% advance current position
+  } for
+  pop pop				% remove string and delta array
+  setlinewidth			% restore linewidth
+} def
Index: psprint/source/printergfx/psputil.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/psputil.cxx,v
retrieving revision 1.2
diff -u -r1.2 psputil.cxx
--- psprint/source/printergfx/psputil.cxx	20 Mar 2002 15:37:37 -0000	1.2
+++ psprint/source/printergfx/psputil.cxx	9 Jun 2004 02:15:32 -0000
@@ -193,7 +193,7 @@
     sal_uInt64 nInLength = rtl_str_getLength (pString);
     sal_uInt64 nOutLength = 0;
     
-    if (nInLength > 0)
+    if (nInLength > 0 && pFile)
         pFile->write (pString, nInLength, nOutLength);
 
     return nInLength == nOutLength;
@@ -204,7 +204,7 @@
 {
     sal_uInt64 nOutLength = 0;
     
-    if (nInLength > 0)
+    if (nInLength > 0 && pFile)
         pFile->write (pString, nInLength, nOutLength);
 
     return nInLength == nOutLength;
@@ -216,7 +216,7 @@
     sal_uInt64 nInLength = rString.getLength();
     sal_uInt64 nOutLength = 0;
     
-    if (nInLength > 0)
+    if (nInLength > 0 && pFile)
         pFile->write (rString, nInLength, nOutLength);
 
     return nInLength == nOutLength;
Index: psprint/source/printergfx/text_gfx.cxx
===================================================================
RCS file: /cvs/gsl/psprint/source/printergfx/text_gfx.cxx,v
retrieving revision 1.20.20.1
diff -u -r1.20.20.1 text_gfx.cxx
--- psprint/source/printergfx/text_gfx.cxx	9 Jan 2004 18:21:28 -0000	1.20.20.1
+++ psprint/source/printergfx/text_gfx.cxx	9 Jun 2004 02:15:32 -0000
@@ -176,7 +176,9 @@
                     sal_Int32 nHeight,
                     sal_Int32 nWidth,
                     sal_Int32 nAngle,
-                    bool bVertical
+                    bool bVertical,
+                    bool bArtItalic,
+                    bool bArtBold
                     )
 {
     // font and encoding will be set by drawText again immediately
@@ -186,6 +188,8 @@
     maVirtualStatus.maEncoding        = RTL_TEXTENCODING_DONTKNOW;
     maVirtualStatus.mnTextHeight      = nHeight;
     maVirtualStatus.mnTextWidth       = nWidth;
+    maVirtualStatus.mbArtItalic		  = bArtItalic;
+    maVirtualStatus.mbArtBold		  = bArtBold;
     mnTextAngle                       = nAngle;
     mbTextVertical                    = bVertical;
 
@@ -275,7 +279,6 @@
         sal_Unicode* pTempUnicodes = (sal_Unicode*)alloca(sizeof(sal_Unicode)*nLen);
         sal_Int16 nTempLen = 0;
         sal_Int32 nTempFirstDelta = 0;
-        sal_Int32 nRot = 0;
         Point aRotPoint;
         sal_Int32 nTextHeight = maVirtualStatus.mnTextHeight;
         sal_Int32 nTextWidth  = maVirtualStatus.mnTextWidth ? maVirtualStatus.mnTextWidth : maVirtualStatus.mnTextHeight;
@@ -451,12 +454,17 @@
 
         while ((nTo < nLen) && (nFont == pFontMap[nTo]))
         {
-            pNewDeltaArray[ nTo ] = ((0.5 + pNewDeltaArray[ nTo ]) / 1000.0) - nDelta;
+            pNewDeltaArray[ nTo ] = (sal_Int32)(((0.5 + pNewDeltaArray[ nTo ]) / 1000.0) - nDelta);
             nTo++ ;
         }
 
-        SetFont( nFont, maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
-                mnTextAngle, mbTextVertical );
+        SetFont( nFont,
+                 maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
+                 mnTextAngle,
+                 mbTextVertical,
+                 maVirtualStatus.mbArtItalic,
+                 maVirtualStatus.mbArtBold
+                 );
         
         if (mbTextVertical)
         {
@@ -483,8 +491,12 @@
     }
 
     // restore the original font settings
-    SetFont( nRestoreFont, maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
-            mnTextAngle, mbTextVertical );
+    SetFont( nRestoreFont,
+             maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
+             mnTextAngle, mbTextVertical,
+             maVirtualStatus.mbArtItalic,
+             maVirtualStatus.mbArtBold
+             );
 }
 
 void PrinterGfx::drawVerticalizedText(
@@ -517,24 +529,30 @@
             i++;
         if( i <= nLen && i > nLastPos )
         {
-            int nWidth = 0;
             for( int n = nLastPos; n < i; n++ )
                 pDelta[n] = pDeltaArray[n] - (aPoint.X() - rPoint.X() );
             
-            SetFont( mnFontID, maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, nNormalAngle, mbTextVertical );
+            SetFont( mnFontID,
+                     maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth,
+                     nNormalAngle, mbTextVertical,
+                     maVirtualStatus.mbArtItalic,
+                     maVirtualStatus.mbArtBold );
             drawText( aPoint, pStr + nLastPos, i - nLastPos, pDelta + nLastPos );
             
-            aPoint.X() = rPoint.X() + ((double)pDeltaArray[i-1] * fCos);
-            aPoint.Y() = rPoint.Y() + ((double)pDeltaArray[i-1] * fSin);
+            aPoint.X() = (sal_Int32)(rPoint.X() + ((double)pDeltaArray[i-1] * fCos));
+            aPoint.Y() = (sal_Int32)(rPoint.Y() + ((double)pDeltaArray[i-1] * fSin));
         }
         if( i < nLen )
         {
             int nOldWidth	= maVirtualStatus.mnTextWidth;
             int nOldHeight	= maVirtualStatus.mnTextHeight;
-            SetFont( mnFontID, nTextScale,
+            SetFont( mnFontID,
+                     nTextScale,
                      maVirtualStatus.mnTextHeight,
                      nNormalAngle + nDeltaAngle, 
-                     mbTextVertical );
+                     mbTextVertical,
+                     maVirtualStatus.mbArtItalic,
+                     maVirtualStatus.mbArtBold );
 
             double nA = nTextScale * aInfo.m_nAscend / 1000.0;
             double nD = nTextScale * aInfo.m_nDescend / 1000.0;
@@ -546,19 +564,19 @@
             switch( nDeltaAngle )
             {
                 case +900:
-                    aPos.X() += +nA * fCos + nD * fSin;
-                    aPos.Y() += -nA * fSin + nD * fCos;
+                    aPos.X() += (sal_Int32)(+nA * fCos + nD * fSin);
+                    aPos.Y() += (sal_Int32)(-nA * fSin + nD * fCos);
                     break;
                 case -900:
-                    aPos.X() += +nA * fSin + nD * fCos;
-                    aPos.Y() += -(nTextScale*fStretch - nD) * fCos;
+                    aPos.X() += (sal_Int32)(+nA * fSin + nD * fCos);
+                    aPos.Y() += (sal_Int32)(-(nTextScale*fStretch - nD) * fCos);
                     break;
             }
             drawText( aPos, pStr+i, 1, NULL );
             if( i < nLen-1 && pDeltaArray )
             {
-                aPoint.X() = rPoint.X() + ((double)pDeltaArray[i] * fCos);
-                aPoint.Y() = rPoint.Y() + ((double)pDeltaArray[i] * fSin);
+                aPoint.X() = (sal_Int32)(rPoint.X() + ((double)pDeltaArray[i] * fCos));
+                aPoint.Y() = (sal_Int32)(rPoint.Y() + ((double)pDeltaArray[i] * fSin));
             }
 
             // swap text width/height again
@@ -566,7 +584,9 @@
                      nOldHeight,
                      nOldWidth,
                      nNormalAngle, 
-                     mbTextVertical );
+                     mbTextVertical,
+                     maVirtualStatus.mbArtItalic,
+                     maVirtualStatus.mbArtBold );
         }
         i++;
         nLastPos = i;
@@ -618,8 +638,6 @@
         return;
 
     fonttype::type   eType          = mrFontMgr.getFontType (mnFontID);
-    fonttype::type   eEffectiveType = fonttype::Unknown;
-    rtl_TextEncoding nEncoding      = mrFontMgr.getFontEncoding (mnFontID);
 
     if (eType == fonttype::Type1)
         PSUploadPS1Font (mnFontID);
diff -x CVS -x unxlngi4.pro -x '*.orig' -Nurd psprint.origpkg/inc/cupsmgr.hxx psprint/inc/cupsmgr.hxx
--- psprint.origpkg/inc/cupsmgr.hxx	1970-01-01 01:00:00.000000000 +0100
+++ psprint/inc/cupsmgr.hxx	2004-03-18 13:07:32.000000000 +0100
@@ -0,0 +1,128 @@
+/*************************************************************************
+ *
+ *  $RCSfile: psprint-cups.diff,v $
+ *
+ *  $Revision: 1.3 $
+ *
+ *  last change: $Author: challs $ $Date: 2004/04/28 15:30:22 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _PSPRINT_CUPSMGR_HXX_
+#define _PSPRINT_CUPSMGR_HXX_
+
+#include <psprint/printerinfomanager.hxx>
+#include <osl/module.h>
+
+namespace psp
+{
+
+class CUPSWrapper;
+class PPDParser;
+
+struct FPtrHash
+{
+    size_t operator()(const FILE* pPtr) const
+    { return (size_t)pPtr; }
+};
+
+class CUPSManager : public PrinterInfoManager
+{
+    CUPSWrapper*												m_pCUPSWrapper;
+    std::hash_map< FILE*, rtl::OString, FPtrHash >				m_aSpoolFiles;
+    int															m_nDests;
+    void*														m_pDests;
+    bool														m_bFirstDest;
+    std::hash_map< rtl::OUString, int, rtl::OUStringHash >		m_aCUPSDestMap;
+
+    rtl::OString												m_aUser;
+    // this is a security risk, but the CUPS API demands
+    // to deliver a pointer to a static buffer containing
+    // the password, so this cannot be helped
+    rtl::OString												m_aPassword;
+
+    CUPSManager( CUPSWrapper*, int nDests = 0, void* pDests = NULL );
+    virtual ~CUPSManager();
+
+    virtual void initialize();
+public:
+
+    static CUPSManager* tryLoadCUPS();
+
+    const PPDParser* createCUPSParser( const rtl::OUString& rPrinter );
+	// wraps cupsGetPPD, so unlink after use !
+
+    const char* authenticateUser( const char* );
+
+    virtual FILE* startSpool( const rtl::OUString& rPrinterName );
+    virtual int endSpool( const rtl::OUString& rPrinterName, const rtl::OUString& rJobTitle, FILE* pFile );
+    virtual void setupJobContextData( JobData& rData );
+
+    // changes the info about a named printer
+    virtual void changePrinterInfo( const ::rtl::OUString& rPrinter, const PrinterInfo& rNewInfo );
+
+    // check if the printer configuration has changed
+    virtual bool checkPrintersChanged();
+
+    // members for administration (->padmin)
+    // disable for CUPS
+    virtual bool addPrinter( const rtl::OUString& rPrinterName, const ::rtl::OUString& rDriverName );
+    virtual bool removePrinter( const rtl::OUString& rPrinterName, bool bCheckOnly = false );
+    virtual bool writePrinterConfig();
+    virtual bool setDefaultPrinter( const rtl::OUString& rPrinterName );
+};
+
+} // namespace psp
+
+#endif
--- psprint.origpkg/source/printer/cupsmgr.cxx	1970-01-01 01:00:00.000000000 +0100
+++ psprint/source/printer/cupsmgr.cxx	2004-03-18 13:07:32.000000000 +0100
@@ -0,0 +1,736 @@
+/*************************************************************************
+ *
+ *  $RCSfile: psprint-cups.diff,v $
+ *
+ *  $Revision: 1.3 $
+ *
+ *  last change: $Author: challs $ $Date: 2004/04/28 15:30:22 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifdef ENABLE_CUPS
+#include <cups/cups.h>
+#include <cups/ppd.h>
+#else
+typedef void ppd_file_t;
+typedef void cups_dest_t;
+typedef void cups_option_t;
+#endif
+
+#include <osl/thread.h>
+#include <osl/diagnose.h>
+#include <cupsmgr.hxx>
+
+namespace psp
+{
+class CUPSWrapper
+{
+    oslModule		m_pLib;
+
+    int				(*m_pcupsPrintFile)(const char*, const char*, const char*, int, cups_option_t*);
+    int				(*m_pcupsGetDests)(cups_dest_t**);
+    void			(*m_pcupsSetDests)(int,cups_dest_t*);
+    void			(*m_pcupsFreeDests)(int,cups_dest_t*);
+    const char*	(*m_pcupsGetPPD)(const char*);
+    int				(*m_pcupsMarkOptions)(ppd_file_t*,int,cups_option_t*);
+    int				(*m_pcupsAddOption)(const char*,const char*,int,cups_option_t**);
+    void			(*m_pcupsFreeOptions)(int,cups_option_t*);
+    ppd_file_t*		(*m_pppdOpenFile)(const char* pFile);
+    void			(*m_pppdClose)(ppd_file_t*);
+    const char*	(*m_pcupsServer)();
+    void			(*m_pcupsSetPasswordCB)(const char*(cb)(const char*));
+    const char*	(*m_pcupsUser)();
+    void			(*m_pcupsSetUser)(const char*);
+
+    void* loadSymbol( const char* );
+public:
+    CUPSWrapper();
+    ~CUPSWrapper();
+
+    bool isValid();
+
+    int cupsGetDests(cups_dest_t** pDests)
+    { return m_pcupsGetDests(pDests); }
+
+    void cupsSetDests( int nDests, cups_dest_t* pDests )
+    { m_pcupsSetDests( nDests, pDests ); }
+
+    void cupsFreeDests(int nDests, cups_dest_t* pDests)
+    { m_pcupsFreeDests(nDests, pDests); }
+
+    int cupsPrintFile( const char* pPrinter,
+                       const char* pFileName,
+                       const char* pTitle,
+                       int nOptions,
+                   cups_option_t* pOptions )
+    { return m_pcupsPrintFile( pPrinter, pFileName, pTitle, nOptions, pOptions ); }
+
+    const char* cupsGetPPD( const char* pPrinter )
+    { return m_pcupsGetPPD( pPrinter ); }
+
+    int cupsMarkOptions(ppd_file_t* pPPD, int nOptions, cups_option_t* pOptions )
+    { return m_pcupsMarkOptions(pPPD, nOptions, pOptions); }
+
+    int cupsAddOption( const char* pName, const char* pValue, int nOptions, cups_option_t** pOptions )
+    { return m_pcupsAddOption( pName, pValue, nOptions, pOptions ); }
+
+    void cupsFreeOptions( int nOptions, cups_option_t* pOptions )
+    { m_pcupsFreeOptions( nOptions, pOptions ); }
+
+    ppd_file_t* ppdOpenFile( const char* pFileName )
+    { return m_pppdOpenFile( pFileName ); }
+
+    void ppdClose( ppd_file_t* pPPD )
+    { m_pppdClose( pPPD ); }
+
+    const char	*cupsServer(void)
+    { return m_pcupsServer(); }
+
+    const char	*cupsUser(void)
+    { return m_pcupsUser(); }
+    
+    void cupsSetPasswordCB(const char *(*cb)(const char *))
+    { m_pcupsSetPasswordCB( cb ); }
+
+    void cupsSetUser(const char *user)
+    { m_pcupsSetUser( user ); }
+    
+};
+}
+
+using namespace psp;
+using namespace osl;
+using namespace rtl;
+
+/*
+ *  CUPSWrapper class
+ */
+
+void* CUPSWrapper::loadSymbol( const char* pSymbol )
+{
+    OUString aSym( OUString::createFromAscii( pSymbol ) );
+    void* pSym = osl_getSymbol( m_pLib, aSym.pData );
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "%s %s\n", pSymbol, pSym ? "found" : "not found" );
+#endif
+    return pSym;
+}
+
+CUPSWrapper::CUPSWrapper() 
+        : m_pLib( NULL )
+{
+#ifdef ENABLE_CUPS
+    OUString aLib( RTL_CONSTASCII_USTRINGPARAM( "libcups.so.2" ) );
+    m_pLib = osl_loadModule( aLib.pData, SAL_LOADMODULE_LAZY );
+    if( ! m_pLib )
+    {
+        aLib = OUString( RTL_CONSTASCII_USTRINGPARAM( "libcups.so" ) );
+        m_pLib = osl_loadModule( aLib.pData, SAL_LOADMODULE_LAZY );
+    }
+#endif
+
+    if( ! m_pLib )
+    {
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "no cups library found\n" );
+#endif
+        return;
+    }
+
+    m_pcupsPrintFile	 	= (int(*)(const char*,const char*,const char*,int,cups_option_t*))
+        loadSymbol( "cupsPrintFile" );
+    m_pcupsGetDests			= (int(*)(cups_dest_t**))
+        loadSymbol( "cupsGetDests" );
+    m_pcupsSetDests			= (void(*)(int,cups_dest_t*))
+        loadSymbol( "cupsSetDests" );
+    m_pcupsFreeDests		= (void(*)(int,cups_dest_t*))
+        loadSymbol( "cupsFreeDests" );
+    m_pcupsGetPPD			= (const char*(*)(const char*))
+        loadSymbol( "cupsGetPPD" );
+    m_pcupsMarkOptions		= (int(*)(ppd_file_t*,int,cups_option_t*))
+        loadSymbol( "cupsMarkOptions" );
+    m_pcupsAddOption		= (int(*)(const char*,const char*,int,cups_option_t**))
+        loadSymbol( "cupsAddOption" );
+    m_pcupsFreeOptions		= (void(*)(int,cups_option_t*))
+        loadSymbol( "cupsFreeOptions" );
+    m_pppdOpenFile			= (ppd_file_t*(*)(const char*))
+        loadSymbol( "ppdOpenFile" );
+    m_pppdClose				= (void(*)(ppd_file_t*))
+        loadSymbol( "ppdClose" );
+    m_pcupsServer			= (const char*(*)())
+        loadSymbol( "cupsServer" );
+    m_pcupsUser				= (const char*(*)())
+        loadSymbol( "cupsUser" );
+    m_pcupsSetPasswordCB	= (void(*)(const char*(*)(const char*)))
+        loadSymbol( "cupsSetPasswordCB" );
+    m_pcupsSetUser			= (void(*)(const char*))
+        loadSymbol( "cupsSetUser" );
+
+    if( ! (
+           m_pcupsPrintFile					&&
+           m_pcupsGetDests					&&
+           m_pcupsSetDests					&&
+           m_pcupsFreeDests					&&
+           m_pcupsGetPPD					&&
+           m_pcupsMarkOptions				&&
+           m_pcupsAddOption					&&
+           m_pcupsServer					&&
+           m_pcupsUser						&&
+           m_pcupsSetPasswordCB				&&
+           m_pcupsSetUser					&&
+           m_pcupsFreeOptions				&&
+           m_pppdOpenFile					&&
+           m_pppdClose
+           ) )
+    {
+        osl_unloadModule( m_pLib );
+        m_pLib = NULL;
+    }
+}
+
+CUPSWrapper::~CUPSWrapper()
+{
+    if( m_pLib )
+        osl_unloadModule( m_pLib );
+}
+
+bool CUPSWrapper::isValid()
+{
+    return m_pLib != NULL;
+}
+
+static const char* setPasswordCallback( const char* pIn )
+{
+    const char* pRet = NULL;
+    
+    PrinterInfoManager& rMgr = PrinterInfoManager::get();
+    if( rMgr.getType() == PrinterInfoManager::CUPS ) // sanity check
+        pRet = static_cast<CUPSManager&>(rMgr).authenticateUser( pIn );
+    return pRet;
+}
+
+/*
+ *  CUPSManager class
+ */
+
+CUPSManager* CUPSManager::tryLoadCUPS()
+{
+    CUPSManager* pManager = NULL;
+#ifdef ENABLE_CUPS
+    static const char* pEnv = getenv( "SAL_DISABLE_CUPS" );
+    
+    if( ! pEnv || ! *pEnv )
+    {
+        // try to load CUPS
+        CUPSWrapper* pWrapper = new CUPSWrapper();
+        if( pWrapper->isValid() )
+        {
+            // check if there are any dests; if not
+            // CUPS is unconfigured (at least) and
+            // should not be used
+            cups_dest_t* pDests = NULL;
+            int nDests = pWrapper->cupsGetDests( &pDests );
+            if( nDests && pDests )
+                pManager = new CUPSManager( pWrapper, nDests, pDests );
+#if OSL_DEBUG_LEVEL > 1
+            else
+                fprintf( stderr, "CUPS loaded but no dests -> CUPS disabled\n" );
+#endif
+        }
+        // something failed, don't use CUPS
+        if( ! pManager )
+            delete pWrapper;
+    }
+#endif
+    return pManager;
+}
+
+CUPSManager::CUPSManager( CUPSWrapper* pWrapper, int nDests, void* pDests ) :
+        PrinterInfoManager( CUPS ),
+        m_pCUPSWrapper( pWrapper ),
+        m_nDests( nDests ),
+        m_pDests( pDests )
+{
+        m_bFirstDest = (nDests && pDests);
+}
+
+CUPSManager::~CUPSManager()
+{
+    if( m_nDests && m_pDests )
+        m_pCUPSWrapper->cupsFreeDests( m_nDests, (cups_dest_t*)m_pDests );
+    delete m_pCUPSWrapper;
+}
+
+void CUPSManager::initialize()
+{
+#ifdef ENABLE_CUPS
+    // there may have been a previous run
+    if( m_nDests && m_pDests && !m_bFirstDest )
+        m_pCUPSWrapper->cupsFreeDests( m_nDests, (cups_dest_t*)m_pDests );
+    m_aPrinters.clear();
+    m_aCUPSDestMap.clear();
+
+    // get normal printers
+    PrinterInfoManager::initialize();
+
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+    int nPrinter = 0;
+
+    // get CUPS dests if this is not the first run after the constructor
+    // in which case m_pDests was already intialized
+    if( m_bFirstDest && m_nDests && m_pDests )
+        nPrinter = m_nDests;
+    else
+        m_nDests = nPrinter = m_pCUPSWrapper->cupsGetDests( (cups_dest_t**)&m_pDests );
+    
+    m_bFirstDest = false;
+
+    // add CUPS printers, should there be a printer
+    // with the same name as a CUPS printer, overwrite it
+    while( nPrinter-- )
+    {
+        cups_dest_t* pDest = ((cups_dest_t*)m_pDests)+nPrinter;
+        OUString aPrinterName = OStringToOUString( pDest->name, aEncoding );
+
+        // initialize printer with possible configuration from psprint.conf
+        Printer aPrinter = m_aPrinters[ aPrinterName ];
+        aPrinter.m_aInfo.m_aPrinterName = aPrinterName;
+        if( pDest->instance && *pDest->instance )
+            aPrinter.m_aInfo.m_aLocation = OStringToOUString( pDest->instance, aEncoding );
+        if( pDest->is_default )
+            m_aDefaultPrinter = aPrinterName;
+
+
+        OUString aPPD( RTL_CONSTASCII_USTRINGPARAM( "CUPS:" ) );
+        aPPD = aPPD + aPrinterName;
+        // note: the parser that goes with the PrinterInfo
+        // is created implicitly by the JobData::operator=()
+        // when it detects the NULL ptr m_pParser.
+        // if we wanted to fill in the parser here this
+        // would mean we'd have to download PPDs for each and
+        // every printer - which would be really bad runtime
+        // behaviour
+        aPrinter.m_aInfo.m_pParser = NULL;
+        aPrinter.m_aInfo.m_aContext.setParser( NULL );
+        aPrinter.m_aInfo.m_aDriverName = aPPD;
+        aPrinter.m_bModified = false;
+
+        m_aPrinters[ aPrinter.m_aInfo.m_aPrinterName ] = aPrinter;
+        m_aCUPSDestMap[ aPrinter.m_aInfo.m_aPrinterName ] = nPrinter;
+    }
+
+    // remove everything that is not a CUPS printer and not
+    // a special purpose printer (PDF, Fax)
+    std::list< OUString > aRemovePrinters;
+    for( std::hash_map< OUString, Printer, OUStringHash >::iterator it = m_aPrinters.begin();
+         it != m_aPrinters.end(); ++it )
+    {
+        if( m_aCUPSDestMap.find( it->first ) != m_aCUPSDestMap.end() )
+            continue;
+
+        if( it->second.m_aInfo.m_aFeatures.getLength() > 0 )
+            continue;
+        aRemovePrinters.push_back( it->first );
+    }
+    while( aRemovePrinters.begin() != aRemovePrinters.end() )
+    {
+        m_aPrinters.erase( aRemovePrinters.front() );
+        aRemovePrinters.pop_front();
+    }
+
+    m_pCUPSWrapper->cupsSetPasswordCB( setPasswordCallback );
+#endif // ENABLE_CUPS
+}
+
+#ifdef ENABLE_CUPS
+static void updatePrinterContextInfo( ppd_group_t* pPPDGroup, PrinterInfo& rInfo )
+{
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+    for( int i = 0; i < pPPDGroup->num_options; i++ )
+    {
+        ppd_option_t* pOption = pPPDGroup->options + i;
+        for( int n = 0; n < pOption->num_choices; n++ )
+        {
+            ppd_choice_t* pChoice = pOption->choices + n;
+            if( pChoice->marked )
+            {
+                const PPDKey* pKey = rInfo.m_pParser->getKey( OStringToOUString( pOption->keyword, aEncoding ) );
+                if( pKey )
+                {
+                    const PPDValue* pValue = pKey->getValue( OStringToOUString( pChoice->choice, aEncoding ) );
+                    if( pValue )
+                    {
+                        if( pValue != pKey->getDefaultValue() )
+                        {
+                            rInfo.m_aContext.setValue( pKey, pValue, true );
+#if OSL_DEBUG_LEVEL > 1
+                            fprintf( stderr, "key %s is set to %s\n", pOption->keyword, pChoice->choice );
+#endif
+                            
+                        }                       
+#if OSL_DEBUG_LEVEL > 1
+                        else
+                            fprintf( stderr, "key %s is defaulted to %s\n", pOption->keyword, pChoice->choice );
+#endif
+                    }
+#if OSL_DEBUG_LEVEL > 1
+                    else
+                        fprintf( stderr, "caution: value %s not found in key %s\n", pChoice->choice, pOption->keyword );
+#endif
+                }
+#if OSL_DEBUG_LEVEL > 1
+                else
+                    fprintf( stderr, "caution: key %s not found in parser\n", pOption->keyword );
+#endif
+            }
+        }
+    }
+
+    // recurse through subgroups
+    for( int g = 0; g < pPPDGroup->num_subgroups; g++ )
+    {
+        updatePrinterContextInfo( pPPDGroup->subgroups + g, rInfo );
+    }
+}
+#endif // ENABLE_CUPS
+
+const PPDParser* CUPSManager::createCUPSParser( const OUString& rPrinter )
+{
+    const PPDParser* pNewParser = NULL;
+#ifdef ENABLE_CUPS
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+
+    OUString aPrinter;
+    if( rPrinter.compareToAscii( "CUPS:", 5 ) == 0 )
+        aPrinter = rPrinter.copy( 5 );
+    else
+        aPrinter = rPrinter;
+    OString aPrinterName( OUStringToOString( aPrinter, aEncoding ) );
+
+    const char* pPPDFile = m_pCUPSWrapper->cupsGetPPD( aPrinterName.getStr() );
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "PPD for %s is %s\n", aPrinterName.getStr(), pPPDFile );
+#endif
+    if( pPPDFile )
+    {
+        OUString aFileName( OStringToOUString( pPPDFile, aEncoding ) );
+        // create the new parser
+        pNewParser = new PPDParser( aFileName );
+
+        std::hash_map< OUString, int, OUStringHash >::iterator dest_it =
+            m_aCUPSDestMap.find( aPrinter );
+
+        if( dest_it != m_aCUPSDestMap.end() )
+        {
+            cups_dest_t* pDest = ((cups_dest_t*)m_pDests) + dest_it->second;
+            // update the printer info with context information
+            ppd_file_t* pPPD = m_pCUPSWrapper->ppdOpenFile( pPPDFile );
+            /*int nConflicts =*/ m_pCUPSWrapper->cupsMarkOptions( pPPD, pDest->num_options, pDest->options );
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "processing the following options for printer %s (instance %s):\n",
+                     pDest->name, pDest->instance );
+            for( int k = 0; k < pDest->num_options; k++ )
+                fprintf( stderr, "   \"%s\" = \"%s\"\n",
+                         pDest->options[k].name,
+                         pDest->options[k].value );
+#endif
+            PrinterInfo& rInfo = m_aPrinters[ aPrinter ].m_aInfo;
+        
+            rInfo.m_pParser = pNewParser;
+            rInfo.m_aContext.setParser( pNewParser );
+            for( int i = 0; i < pPPD->num_groups; i++ )
+                updatePrinterContextInfo( pPPD->groups + i, rInfo );
+
+            // clean up the mess
+            m_pCUPSWrapper->ppdClose( pPPD );
+        }
+#if OSL_DEBUG_LEVEL > 1
+        else
+            fprintf( stderr, "no dest found for printer %s\n", aPrinterName.getStr() );
+#endif
+        // remove temporary PPD file
+        unlink( pPPDFile );
+    }
+    else
+#endif // ENABLE_CUPS
+    {
+        // get the default PPD
+        pNewParser = PPDParser::getParser( String( RTL_CONSTASCII_USTRINGPARAM( "SGENPRT" ) ) );
+        
+        PrinterInfo& rInfo = m_aPrinters[ aPrinter ].m_aInfo;
+        
+        rInfo.m_pParser = pNewParser;
+        rInfo.m_aContext.setParser( pNewParser );
+    }
+
+    return pNewParser;
+}
+
+void CUPSManager::setupJobContextData( JobData& rData )
+{
+#ifdef ENABLE_CUPS
+    std::hash_map< OUString, int, OUStringHash >::iterator dest_it =
+        m_aCUPSDestMap.find( rData.m_aPrinterName );
+
+    if( dest_it == m_aCUPSDestMap.end() )
+        return PrinterInfoManager::setupJobContextData( rData );
+
+    std::hash_map< OUString, Printer, OUStringHash >::iterator p_it =
+        m_aPrinters.find( rData.m_aPrinterName );
+    if( p_it == m_aPrinters.end() ) // huh ?
+    {
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "CUPS printer list in disorder, no dest for printer %s !\n", OUStringToOString( rData.m_aPrinterName, osl_getThreadTextEncoding() ).getStr() );
+#endif
+        return;
+    }
+
+    if( p_it->second.m_aInfo.m_pParser == NULL )
+    {
+        // in turn calls createCUPSParser
+        // which updates the printer info
+        p_it->second.m_aInfo.m_pParser = PPDParser::getParser( p_it->second.m_aInfo.m_aDriverName );
+    }
+
+    rData.m_pParser		= p_it->second.m_aInfo.m_pParser;
+    rData.m_aContext	= p_it->second.m_aInfo.m_aContext;
+#endif
+}
+
+FILE* CUPSManager::startSpool( const OUString& rPrintername )
+{
+#ifdef ENABLE_CUPS
+    OUString aTmpURL, aTmpFile;
+    osl_createTempFile( NULL, NULL, &aTmpURL.pData );
+    osl_getSystemPathFromFileURL( aTmpURL.pData, &aTmpFile.pData );
+    OString aSysFile = OUStringToOString( aTmpFile, osl_getThreadTextEncoding() );
+    FILE* fp = fopen( aSysFile.getStr(), "w" );
+    if( fp )
+        m_aSpoolFiles[fp] = aSysFile;
+    
+    return fp;
+#else
+    return NULL;
+#endif
+}
+
+int CUPSManager::endSpool( const OUString& rPrintername, const OUString& rJobTitle, FILE* pFile )
+{
+    int nJobID = 0;
+
+#ifdef ENABLE_CUPS
+    std::hash_map< FILE*, OString, FPtrHash >::const_iterator it = m_aSpoolFiles.find( pFile );
+    if( it != m_aSpoolFiles.end() )
+    {
+        fclose( pFile );
+        rtl_TextEncoding aEnc = osl_getThreadTextEncoding();
+
+        nJobID = m_pCUPSWrapper->cupsPrintFile( OUStringToOString( rPrintername, aEnc ).getStr(),
+                                            it->second.getStr(),
+                                            OUStringToOString( rJobTitle, aEnc ).getStr(),
+                                            0, NULL );
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "cupsPrintFile( %s, %s, %s, 0, 0 ) returns %d\n",
+                 OUStringToOString( rPrintername, aEnc ).getStr(),
+                 it->second.getStr(),
+                 OUStringToOString( rJobTitle, aEnc ).getStr(),
+                 nJobID );
+        OString aCmd( "cp " );
+        aCmd = aCmd + it->second;
+        aCmd = aCmd + OString( " $HOME/cupsprint.ps" );
+        system( aCmd.getStr() );
+#endif
+
+        unlink( it->second.getStr() );
+        m_aSpoolFiles.erase( pFile );
+    }
+#endif // ENABLE_CUPS
+
+    return nJobID;
+}
+
+
+void CUPSManager::changePrinterInfo( const OUString& rPrinter, const PrinterInfo& rNewInfo )
+{
+    PrinterInfoManager::changePrinterInfo( rPrinter, rNewInfo );
+}
+
+bool CUPSManager::checkPrintersChanged()
+{
+    return PrinterInfoManager::checkPrintersChanged();
+}
+
+bool CUPSManager::addPrinter( const OUString& rName, const OUString& rDriver )
+{
+    // don't touch the CUPS printers
+    if( m_aCUPSDestMap.find( rName ) != m_aCUPSDestMap.end() ||
+        rDriver.compareToAscii( "CUPS:", 5 ) == 0
+        )
+        return false;
+    return PrinterInfoManager::addPrinter( rName, rDriver );
+}
+
+bool CUPSManager::removePrinter( const OUString& rName, bool bCheck )
+{
+    // don't touch the CUPS printers
+    if( m_aCUPSDestMap.find( rName ) != m_aCUPSDestMap.end() )
+        return false;
+    return PrinterInfoManager::removePrinter( rName, bCheck );
+}
+
+bool CUPSManager::setDefaultPrinter( const OUString& rName )
+{
+#ifdef ENABLE_CUPS
+    std::hash_map< OUString, int, OUStringHash >::iterator nit =
+        m_aCUPSDestMap.find( rName );
+    if( nit == m_aCUPSDestMap.end() )
+        return false;
+
+    cups_dest_t* pDests = (cups_dest_t*)m_pDests;
+    for( int i = 0; i < m_nDests; i++ )
+        pDests[i].is_default = 0;
+    pDests[ nit->second ].is_default = 1;
+    m_pCUPSWrapper->cupsSetDests( m_nDests, (cups_dest_t*)m_pDests );
+    m_aDefaultPrinter = rName;
+
+    return true;
+#else
+    return false;
+#endif
+}
+
+bool CUPSManager::writePrinterConfig()
+{
+#ifdef ENABLE_CUPS
+    bool bDestModified = false;
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+
+    for( std::hash_map< OUString, Printer, OUStringHash >::iterator prt =
+             m_aPrinters.begin(); prt != m_aPrinters.end(); ++prt )
+    {
+        std::hash_map< OUString, int, OUStringHash >::iterator nit =
+            m_aCUPSDestMap.find( prt->first );
+        if( nit == m_aCUPSDestMap.end() )
+            continue;
+        
+        if( ! prt->second.m_bModified )
+            continue;
+
+        bDestModified = true;
+        cups_dest_t* pDest = ((cups_dest_t*)m_pDests) + nit->second;
+        PrinterInfo& rInfo = prt->second.m_aInfo;
+
+        // create new option list
+        int nNewOptions = 0;
+        cups_option_t* pNewOptions = NULL; 
+        int nValues = rInfo.m_aContext.countValuesModified();
+        for( int i = 0; i < nValues; i++ )
+        {
+            const PPDKey* pKey = rInfo.m_aContext.getModifiedKey( i );
+            const PPDValue* pValue = rInfo.m_aContext.getValue( pKey );
+            if( pKey && pValue ) // sanity check
+            {
+                OString aName = OUStringToOString( pKey->getKey(), aEncoding );
+                OString aValue = OUStringToOString( pValue->m_aOption, aEncoding );
+                nNewOptions = m_pCUPSWrapper->cupsAddOption( aName.getStr(), aValue.getStr(), nNewOptions, &pNewOptions );
+            }
+        }
+        // set PPD options on CUPS dest
+        m_pCUPSWrapper->cupsFreeOptions( pDest->num_options, pDest->options );
+        pDest->num_options = nNewOptions;
+        pDest->options = pNewOptions;
+    }
+    if( bDestModified )
+        m_pCUPSWrapper->cupsSetDests( m_nDests, (cups_dest_t*)m_pDests );
+#endif // ENABLE_CUPS
+
+    return PrinterInfoManager::writePrinterConfig();
+}
+
+#include <rtsname.hxx>
+
+const char* CUPSManager::authenticateUser( const char* pIn )
+{
+    const char* pRet = NULL;
+
+#ifdef ENABLE_CUPS
+    OUString aLib = OUString::createFromAscii( _XSALSET_LIBNAME );
+    oslModule pLib = osl_loadModule( aLib.pData, SAL_LOADMODULE_LAZY );
+    if( pLib )
+    {
+        OUString aSym( RTL_CONSTASCII_USTRINGPARAM( "Sal_authenticateQuery" ) );
+        bool (*getpw)( const OString& rServer, OString& rUser, OString& rPw) =
+            (bool(*)(const OString&,OString&,OString&))osl_getSymbol( pLib, aSym.pData );
+        if( getpw )
+        {
+            OString aUser = m_pCUPSWrapper->cupsUser();
+            OString aServer = m_pCUPSWrapper->cupsServer();
+            OString aPassword;
+            if( getpw( aServer, aUser, aPassword ) )
+            {       
+                m_aPassword = aPassword;
+                m_aUser = aUser;
+                m_pCUPSWrapper->cupsSetUser( m_aUser.getStr() );
+                pRet = m_aPassword.getStr();
+            }   	
+        }
+        osl_unloadModule( pLib );
+    }
+#if OSL_DEBUG_LEVEL > 1
+    else fprintf( stderr, "loading of module %s failed\n", OUStringToOString( aLib, osl_getThreadTextEncoding() ).getStr() );
+#endif
+#endif // ENABLE_CUPS
+
+    return pRet;
+}
