 padmin/source/adddlg.cxx                      |    7 
 psprint/inc/cupsmgr.hxx                       |  136 ++++
 psprint/inc/psprint/fontcache.hxx             |    4 
 psprint/inc/psprint/jobdata.hxx               |    5 
 psprint/inc/psprint/ppdparser.hxx             |    4 
 psprint/inc/psprint/printergfx.hxx            |   26 
 psprint/inc/psprint/printerinfomanager.hxx    |  109 ++-
 psprint/source/fontmanager/fontmanager.cxx    |   24 
 psprint/source/fontmanager/makefile.mk        |    4 
 psprint/source/fontmanager/parseAFM.cxx       |    3 
 psprint/source/fontsubset/gsub.cxx            |    6 
 psprint/source/fontsubset/list.c              |    5 
 psprint/source/fontsubset/sft.c               |   19 
 psprint/source/fontsubset/ttcr.c              |   12 
 psprint/source/helper/helper.cxx              |   12 
 psprint/source/helper/ppdparser.cxx           |  100 +-
 psprint/source/helper/strhelper.cxx           |    6 
 psprint/source/printer/cupsmgr.cxx            |  872 ++++++++++++++++++++++++++
 psprint/source/printer/jobdata.cxx            |   24 
 psprint/source/printer/makefile.mk            |   15 
 psprint/source/printer/printerinfomanager.cxx |  310 ++++++---
 psprint/source/printergfx/bitmap_gfx.cxx      |   23 
 psprint/source/printergfx/common_gfx.cxx      |  119 ++-
 psprint/source/printergfx/printerjob.cxx      |  250 +++++--
 psprint/source/printergfx/psheader.ps         |   62 +
 psprint/source/printergfx/psputil.cxx         |    6 
 psprint/source/printergfx/text_gfx.cxx        |   62 +
 27 files changed, 1856 insertions(+), 369 deletions(-)

Index: psprint/inc/cupsmgr.hxx
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ psprint/inc/cupsmgr.hxx	2004-10-21 14:47:17.000000000 +0100
@@ -0,0 +1,140 @@
+/*************************************************************************
+ *
+ *  $RCSfile: psprint-cups.diff,v $
+ *
+ *  $Revision: 1.8 $
+ *
+ *  last change: $Author: challs $ $Date: 2004/07/08 17:31:02 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _PSPRINT_CUPSMGR_HXX_
+#define _PSPRINT_CUPSMGR_HXX_
+
+#include <psprint/printerinfomanager.hxx>
+#include <osl/module.h>
+#include <osl/thread.h>
+#include <osl/mutex.hxx>
+
+namespace psp
+{
+
+class CUPSWrapper;
+class PPDParser;
+
+struct FPtrHash
+{
+    size_t operator()(const FILE* pPtr) const
+    { return (size_t)pPtr; }
+};
+
+class CUPSManager : public PrinterInfoManager
+{
+    CUPSWrapper*												m_pCUPSWrapper;
+    std::hash_map< FILE*, rtl::OString, FPtrHash >				m_aSpoolFiles;
+    int															m_nDests;
+    void*														m_pDests;
+    bool														m_bNewDests;
+    std::hash_map< rtl::OUString, int, rtl::OUStringHash >		m_aCUPSDestMap;
+
+    std::hash_map< rtl::OUString, PPDContext, rtl::OUStringHash > m_aDefaultContexts;
+
+    rtl::OString												m_aUser;
+    // this is a security risk, but the CUPS API demands
+    // to deliver a pointer to a static buffer containing
+    // the password, so this cannot be helped
+    rtl::OString												m_aPassword;
+
+    osl::Mutex													m_aCUPSMutex;
+    oslThread													m_aDestThread;
+
+    CUPSManager( CUPSWrapper* );
+    virtual ~CUPSManager();
+
+    virtual void initialize();
+
+    void runDests();
+    static void runDestThread(void* pMgr);
+public:
+
+    static CUPSManager* tryLoadCUPS();
+
+    const PPDParser* createCUPSParser( const rtl::OUString& rPrinter );
+	// wraps cupsGetPPD, so unlink after use !
+
+    const char* authenticateUser( const char* );
+
+    virtual FILE* startSpool( const rtl::OUString& rPrinterName );
+    virtual int endSpool( const rtl::OUString& rPrinterName, const rtl::OUString& rJobTitle, FILE* pFile );
+    virtual void setupJobContextData( JobData& rData );
+
+    // changes the info about a named printer
+    virtual void changePrinterInfo( const ::rtl::OUString& rPrinter, const PrinterInfo& rNewInfo );
+
+    // check if the printer configuration has changed
+    virtual bool checkPrintersChanged();
+
+    // members for administration (->padmin)
+    // disable for CUPS
+    virtual bool addPrinter( const rtl::OUString& rPrinterName, const ::rtl::OUString& rDriverName );
+    virtual bool removePrinter( const rtl::OUString& rPrinterName, bool bCheckOnly = false );
+    virtual bool writePrinterConfig();
+    virtual bool setDefaultPrinter( const rtl::OUString& rPrinterName );
+    
+    virtual bool addOrRemovePossible() const;
+};
+
+} // namespace psp
+
+#endif
Index: psprint/inc/psprint/jobdata.hxx
===================================================================
--- psprint/inc/psprint/jobdata.hxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/inc/psprint/jobdata.hxx	2004-10-21 14:47:17.000000000 +0100
@@ -105,6 +105,10 @@ struct JobData
             m_eOrientation( orientation::Portrait ),
             m_pParser( NULL ) {}
 
+    JobData& operator=(const psp::JobData& rRight);
+
+    JobData( const JobData& rData ) { *this = rData; }
+
     // creates a new buffer using new
     // it is up to the user to delete it again
     bool getStreamBuffer( void*& pData, int& bytes );
@@ -113,4 +117,5 @@ struct JobData
 
 } // namespace
 
+
 #endif // PSPRINT_JOBDATA_HXX
Index: psprint/inc/psprint/ppdparser.hxx
===================================================================
--- psprint/inc/psprint/ppdparser.hxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/inc/psprint/ppdparser.hxx	2004-10-21 14:47:17.000000000 +0100
@@ -142,6 +142,13 @@ public:
     int                 getOrderDependency() const { return m_nOrderDependency; }
 };
 
+// define a hash for PPDKey
+struct PPDKeyhash
+{
+    size_t operator()( const PPDKey * pKey) const
+        { return (size_t)pKey; }
+};
+
 // ----------------------------------------------------------------------
 
 /*
@@ -149,11 +156,13 @@ public:
  */
 
 class PPDContext;
+class CUPSManager;
 
 class PPDParser
 {
     friend class PPDContext;
-    
+    friend class CUPSManager;
+
     typedef ::std::hash_map< ::rtl::OUString, PPDKey*, ::rtl::OUStringHash > hash_type;
     typedef ::std::vector< PPDKey* > value_type;
 
@@ -309,7 +318,8 @@ public:
 
 class PPDContext
 {
-    ::std::hash_map< const PPDKey*, const PPDValue* >   m_aCurrentValues;
+    typedef ::std::hash_map< const PPDKey*, const PPDValue*, PPDKeyhash > hash_type;
+    hash_type m_aCurrentValues;
     const PPDParser*                                    m_pParser;
 
     // returns false: check failed, new value is constrained
Index: psprint/inc/psprint/printergfx.hxx
===================================================================
--- psprint/inc/psprint/printergfx.hxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/inc/psprint/printergfx.hxx	2004-10-21 14:47:18.000000000 +0100
@@ -113,10 +113,10 @@ public:
             meColorspace (eRGB)
     {}
     PrinterColor (sal_uInt32 nRGB) :
-            meColorspace (eRGB),
-            mnBlue  ((nRGB & 0x000000ff)      ),
+            mnRed   ((nRGB & 0x00ff0000) >> 16),
             mnGreen ((nRGB & 0x0000ff00) >>  8),
-            mnRed   ((nRGB & 0x00ff0000) >> 16)
+            mnBlue  ((nRGB & 0x000000ff)      ),
+            meColorspace (eRGB)
     {}
     ~PrinterColor ()
     {}
@@ -210,6 +210,8 @@ struct GraphicsStatus
 {
     rtl::OString        maFont;
     rtl_TextEncoding	maEncoding;
+    bool				mbArtItalic;
+    bool				mbArtBold;
     sal_Int32           mnTextHeight;
     sal_Int32           mnTextWidth;
     PrinterColor        maColor;
@@ -422,13 +424,25 @@ public:
     void            DrawMask   (const Rectangle& rDest, const Rectangle& rSrc, 
                                 const PrinterBmp &rBitmap, PrinterColor& rMaskColor);
 
-    // font and text handling
+    // font and text handling (compatibility)
     sal_uInt16      SetFont (
                              sal_Int32 nFontID,
                              sal_Int32 nPointHeight,
                              sal_Int32 nPointWidth,
                              sal_Int32 nAngle,
                              bool bVertical
+                             ) { return SetFont(nFontID, nPointHeight, nPointWidth,
+				                nAngle, bVertical, false, false);}
+
+    // font and text handling
+    sal_uInt16      SetFont (
+                             sal_Int32 nFontID,
+                             sal_Int32 nPointHeight,
+                             sal_Int32 nPointWidth,
+                             sal_Int32 nAngle,
+                             bool bVertical,
+                             bool bArtItalic,
+                             bool bArtBold
                              );
     sal_uInt16      SetFallbackFont ( sal_Int32 nFontID );
     sal_Int32       GetFontAngle () const
@@ -441,6 +455,10 @@ public:
     { return maVirtualStatus.mnTextHeight; }
     sal_Int32       GetFontWidth () const
     { return maVirtualStatus.mnTextWidth; }
+    bool			GetArtificialItalic() const
+    { return maVirtualStatus.mbArtItalic; }
+    bool			GetArtificialBold() const
+    { return maVirtualStatus.mbArtBold; }
     void            DrawText (const Point& rPoint, 
                               const sal_Unicode* pStr, sal_Int16 nLen, 
                               const sal_Int32* pDeltaArray = NULL);
Index: psprint/inc/psprint/printerinfomanager.hxx
===================================================================
--- psprint/inc/psprint/printerinfomanager.hxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/inc/psprint/printerinfomanager.hxx	2004-10-21 14:47:18.000000000 +0100
@@ -80,6 +80,7 @@
 #ifndef _PSPRINT_HELPER_HXX_
 #include <psprint/helper.hxx>
 #endif
+#include <cstdio>
 
 #ifdef MACOSX
 /* MacOS X print system discovery constants:
@@ -88,17 +89,20 @@
  * They are used as indications _as well as_ indexes into the
  * aParms structure used below for print commands.
  */
-#define		kApplePrintingFailure                   0		/* For whatever reason, we can't print at all */
+#define		kApplePrintingFailure		0		/* For whatever reason, we can't print at all */
 #define		kApplePrintingLPR			1		/* Darwin 5.x style LPR printing */
 #define		kApplePrintingCUPS			2		/* MacOS X 10.2/Darwin 6 style CUPS (also CUPS installed by users on 10.1) */
-#define         kApplePrintingNewCUPS                   3               /* MacOSX 10.3/Darwin 7 style CUPS with integrated ghostscript like filters */
+#define		kApplePrintingPrintCenter	3		/* MacOS X 10.1 /usr/sbin/Print printing */
 
 /* Constants for PostScript vs PDF printing */
-#define		kApplePrintingUsePDF		        1	/* Run PS through ps to pdfconversion first requires GhostScript in /usr/local */
-#define		kApplePrintingUsePS			2	/* print PS directly to printer (requires PS printer or New CUPS) */
+#define		kApplePrintingUsePDF		1		/* Default; Run PS through ps2pdf first (requires GhostScript) */
+#define		kApplePrintingUsePS			2		/* Optional, print PS directly to printer (less compatible, requires PS printer) */
 
 /* Define various printing commands */
-#define		kApplePS2PDFLocation	        "/usr/local/bin/ps2pdf"	/* PS -> PDF conversion command (Ghostscript) */
+#define		kApplePCPrintCommand	"/usr/sbin/Print"		/* Mac OS X 10.1 Print Center Printing command */
+#define		kApplePS2PDFLocation	"/usr/local/bin/ps2pdf"	/* PS -> PDF conversion command */
+#define		kApplePCQueueName		"Apple Print Center Default Printer"	/* Name that appears in Print... dialog as the default */
+																/* printer for 10.1 Print Center printing */
 
 /* Prototype for print method discovery function.  Returns
  * a constant defined in printerinfomanager.hxx
@@ -115,16 +119,16 @@ class SystemQueueInfo;
 struct PrinterInfo : JobData
 {
     // basename of PPD
-    ::rtl::OUString             m_aDriverName;
+    rtl::OUString             m_aDriverName;
     // can be the queue
-    ::rtl::OUString             m_aLocation;
+    rtl::OUString             m_aLocation;
     // a user defined comment
-    ::rtl::OUString             m_aComment;
+    rtl::OUString             m_aComment;
     // a command line to pipe a PS-file to
-    ::rtl::OUString             m_aCommand;
+    rtl::OUString             m_aCommand;
     // a list of special features separated by ',' not used by psprint
     // but assigned from the outside (currently only for "fax")
-    ::rtl::OUString             m_aFeatures;
+    rtl::OUString             m_aFeatures;
     // a mapping of fonts to other fonts.
     // this provides a method for the user
     // to replace arbitrary fonts by printer builtin fonts
@@ -135,20 +139,29 @@ struct PrinterInfo : JobData
     // this vector is currently implicitly given by the adobe
     // standard encoding
     bool                        m_bPerformFontSubstitution;
-    ::std::hash_map< ::rtl::OUString, ::rtl::OUString, ::rtl::OUStringHash >
+    std::hash_map< rtl::OUString, rtl::OUString, rtl::OUStringHash >
     m_aFontSubstitutes;
-    ::std::hash_map< fontID, fontID >
+    std::hash_map< fontID, fontID >
     m_aFontSubstitutions;
+
+    PrinterInfo() :
+            JobData(),
+            m_bPerformFontSubstitution( false )
+    {}
 };
 
 class PrinterInfoManager
 {
+public:
+    enum Type { Default = 0, CUPS = 1 };
+
+protected:
     // needed for checkPrintersChanged: files (not necessarily existant)
     // and their last known modification time
     struct WatchFile
     {
         // the file in question
-        ::rtl::OUString         m_aFilePath;
+        rtl::OUString         m_aFilePath;
         // the last know modification time or 0, if file did not exist
         TimeValue               m_aModified;
     };
@@ -158,88 +171,111 @@ class PrinterInfoManager
     {
         // configuration file containing this printer
         // empty means a freshly added printer that has to be saved yet
-        ::rtl::OUString         m_aFile;
+        rtl::OUString         m_aFile;
         // details other config files that have this printer
         // in case of removal all have to be removed
-        ::std::list< ::rtl::OUString > m_aAlternateFiles;
+        std::list< rtl::OUString > m_aAlternateFiles;
         // group in m_aFile containing the printer
         // this must be unique over all configuration files
         // it usually should be the printer name
-        ::rtl::OString          m_aGroup;
+        rtl::OString          m_aGroup;
         // whether changes need to be saved
         bool                    m_bModified;
         // the corresponding info and job data
         PrinterInfo             m_aInfo;
     };
 
-    ::std::hash_map< ::rtl::OUString, Printer, ::rtl::OUStringHash > m_aPrinters;
+    std::hash_map< rtl::OUString, Printer, rtl::OUStringHash > m_aPrinters;
     PrinterInfo                         m_aGlobalDefaults;
-    ::std::list< WatchFile >            m_aWatchFiles;
-    ::rtl::OUString                     m_aDefaultPrinter;
-    ::rtl::OUString                     m_aSystemPrintCommand;
-    ::std::list< ::rtl::OUString >      m_aSystemPrintQueues;
+    std::list< WatchFile >            m_aWatchFiles;
+    rtl::OUString                     m_aDefaultPrinter;
+    rtl::OUString                     m_aSystemPrintCommand;
+    std::list< rtl::OUString >      m_aSystemPrintQueues;
 
     SystemQueueInfo*					m_pQueueInfo;
 
-    PrinterInfoManager();
-    ~PrinterInfoManager();
+    Type								m_eType;
 
-    void initialize();
+    PrinterInfoManager( Type eType = Default );
+    virtual ~PrinterInfoManager();
+
+    virtual void initialize();
 
     // fill in font substitutions
     // the resulting hash_map maps from source to target font ids
     void fillFontSubstitutions( PrinterInfo& rInfo ) const;
+    
+    // fill default paper if not configured in config file
+    // default paper is e.g. locale dependent
+    // if a paper is already set it will not be overwritten
+    void setDefaultPaper( PrinterInfo& rInfo ) const;
 public:
 
     // there can only be one
     static PrinterInfoManager& get();
 
+    // get PrinterInfoManager type
+    Type getType() const { return m_eType; }
+
     // lists the names of all known printers
-    void listPrinters( ::std::list< ::rtl::OUString >& rList ) const;
+    void listPrinters( std::list< rtl::OUString >& rList ) const;
 
     // gets the number of known printers
     int countPrinters() const { return m_aPrinters.size(); }
 
     // gets info about a named printer
-    const PrinterInfo& getPrinterInfo( const ::rtl::OUString& rPrinter ) const;
+    const PrinterInfo& getPrinterInfo( const rtl::OUString& rPrinter ) const;
         
     // gets the name of the default printer
-    const ::rtl::OUString& getDefaultPrinter() const { return m_aDefaultPrinter; }
+    const rtl::OUString& getDefaultPrinter() const { return m_aDefaultPrinter; }
+
+    virtual void setupJobContextData( JobData& rData );
 
     // changes the info about a named printer
-    void changePrinterInfo( const ::rtl::OUString& rPrinter, const PrinterInfo& rNewInfo );
+    virtual void changePrinterInfo( const rtl::OUString& rPrinter, const PrinterInfo& rNewInfo );
 
     // check if the printer configuration has changed
-    bool checkPrintersChanged();
+    virtual bool checkPrintersChanged();
 
     // members for administration (->padmin)
 
     // add a named printer
     // addPrinter fails if a printer with the same name already exists
     // or the driver does not exist
-    bool addPrinter( const ::rtl::OUString& rPrinterName, const ::rtl::OUString& rDriverName );
+    virtual bool addPrinter( const rtl::OUString& rPrinterName, const rtl::OUString& rDriverName );
 
     // remove a named printer
     // this fails if the config file belonging to this printer
     // is not writeable
     // if bCheckOnly is true, the printer is not really removed;
     // this is for checking if the removal would fail
-    bool removePrinter( const ::rtl::OUString& rPrinterName, bool bCheckOnly = false );
+    virtual bool removePrinter( const rtl::OUString& rPrinterName, bool bCheckOnly = false );
 
     // save the changes to all printers. this fails if there
     // is no writable config file at all
-    bool writePrinterConfig();
+    virtual bool writePrinterConfig();
 
     // set a new default printer
     // fails if the specified printer does not exist
-    bool setDefaultPrinter( const ::rtl::OUString& rPrinterName );
+    virtual bool setDefaultPrinter( const rtl::OUString& rPrinterName );
 
     // primarily used internally but also by padmin
     // returns the printer queue names
-    const ::std::list< ::rtl::OUString >& getSystemPrintQueues();
+    virtual const std::list< rtl::OUString >& getSystemPrintQueues();
         
     // similar but returnse whole commandlines
-    void getSystemPrintCommands( ::std::list< ::rtl::OUString >& rCommands );
+    virtual void getSystemPrintCommands( std::list< rtl::OUString >& rCommands );
+
+    // abstract print command
+    // returns a stdio FILE* that a postscript file may be written to
+    // this may either be a regular file or the result of popen()
+    virtual FILE* startSpool( const rtl::OUString& rPrinterName );
+    // close the FILE* returned by startSpool and does the actual spooling
+    // returns a numerical job id
+    virtual int endSpool( const rtl::OUString& rPrinterName, const rtl::OUString& rJobTitle, FILE* pFile );
+    
+    // for spadmin: whether adding or removing a printer is possible
+    virtual bool addOrRemovePossible() const;
 };
     
 } // namespace
Index: psprint/source/fontmanager/fontmanager.cxx
===================================================================
--- psprint/source/fontmanager/fontmanager.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/fontmanager/fontmanager.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -543,12 +543,12 @@ bool PrintFontManager::TrueTypeFontFile:
 
 
                 KernPair aPair;
-                for( i = 0; i < pImplTTFont->nkern; i++ )
+                for( i = 0; i < (int)pImplTTFont->nkern; i++ )
                 {
                     const sal_uInt8* pTable = pImplTTFont->kerntables[i];
 
-                    sal_uInt16 nVersion     = getUInt16BE( pTable );
-                    sal_uInt16 nLength      = getUInt16BE( pTable );
+                    /*sal_uInt16 nVersion     =*/ getUInt16BE( pTable );
+                    /*sal_uInt16 nLength      =*/ getUInt16BE( pTable );
                     sal_uInt16 nCoverage    = getUInt16BE( pTable );
 
                     aPair.kern_x    = 0;
@@ -775,7 +775,7 @@ bool PrintFontManager::PrintFont::readAf
     if( ! fp )
         return false;
     FontInfo* pInfo = NULL;
-    int nResult = parseFile( fp, &pInfo, P_ALL );
+    parseFile( fp, &pInfo, P_ALL );
     fclose( fp );
     if( ! pInfo || ! pInfo->numOfChars )
     {
@@ -863,7 +863,7 @@ bool PrintFontManager::PrintFont::readAf
                 RTL_TEXTENCODING_JIS_X_0208
             };
 
-        for( int enc = 0; enc < sizeof( aEncs )/sizeof(aEncs[0]) && m_aEncoding == RTL_TEXTENCODING_DONTKNOW; enc++ )
+        for( unsigned int enc = 0; enc < sizeof( aEncs )/sizeof(aEncs[0]) && m_aEncoding == RTL_TEXTENCODING_DONTKNOW; enc++ )
         {
             sal_Int32 nIndex = 0, nOffset = 1;
             do
@@ -1134,12 +1134,12 @@ PrintFontManager& PrintFontManager::get(
  */
 
 PrintFontManager::PrintFontManager() :
-        m_pAtoms( new MultiAtomProvider() ),
         m_nNextFontID( 1 ),
+        m_pAtoms( new MultiAtomProvider() ),
         m_nNextDirAtom( 1 ),
         m_pFontCache( NULL )
 {
-    for( int i = 0; i < sizeof( aAdobeCodes )/sizeof( aAdobeCodes[0] ); i++ )
+    for( unsigned int i = 0; i < sizeof( aAdobeCodes )/sizeof( aAdobeCodes[0] ); i++ )
     {
         m_aUnicodeToAdobename.insert( ::std::hash_multimap< sal_Unicode, ::rtl::OString >::value_type( aAdobeCodes[i].aUnicode, aAdobeCodes[i].pAdobename ) );
         m_aAdobenameToUnicode.insert( ::std::hash_multimap< ::rtl::OString, sal_Unicode, ::rtl::OStringHash >::value_type( aAdobeCodes[i].pAdobename, aAdobeCodes[i].aUnicode ) );
@@ -1405,7 +1405,6 @@ int PrintFontManager::addFontFile( const
 bool PrintFontManager::analyzeFontFile( int nDirID, const OString& rFontFile, bool bReadFile, const ::std::list<OString>& rXLFDs, ::std::list< PrintFontManager::PrintFont* >& rNewFonts ) const
 {
     rNewFonts.clear();
-    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
 
     OString aDir( getDirectory( nDirID ) );
 
@@ -1424,7 +1423,7 @@ bool PrintFontManager::analyzeFontFile( 
         // first look for an adjacent file
         static const char* pSuffix[] = { ".afm", ".AFM" };
         
-        for( int i = 0; i < sizeof(pSuffix)/sizeof(pSuffix[0]); i++ )
+        for( unsigned int i = 0; i < sizeof(pSuffix)/sizeof(pSuffix[0]); i++ )
         {
             ByteString aName( rFontFile );
             aName.Erase( aName.Len()-4 );
@@ -1485,7 +1484,9 @@ bool PrintFontManager::analyzeFontFile( 
         else
             delete pFont;
     }
-    else if( aExt.EqualsIgnoreCaseAscii( "ttf" ) )
+    else if( aExt.EqualsIgnoreCaseAscii( "ttf" )
+         ||  aExt.EqualsIgnoreCaseAscii( "tte" )   // #i33947# for Gaiji support
+         ||  aExt.EqualsIgnoreCaseAscii( "otf" ) ) // #112957# allow GLYF-OTF
     {
         TrueTypeFontFile* pFont     = new TrueTypeFontFile();
         pFont->m_nDirectory         = nDirID;
@@ -1737,6 +1738,8 @@ void PrintFontManager::getFontAttributes
                 case fonttype::TrueType:
                     static_cast<TrueTypeFontFile*>(pFont)->m_aXLFD = rXLFDs.front();
                     break;
+                default:
+                    break;
             }
         }
         else
@@ -1771,11 +1774,24 @@ void PrintFontManager::getFontAttributes
     // handle iso8859-1 as ms1252 to fill the "gap" starting at 0x80
     if( pFont->m_aEncoding == RTL_TEXTENCODING_ISO_8859_1 )
         pFont->m_aEncoding = RTL_TEXTENCODING_MS_1252;
+    if( rXLFDs.begin() != rXLFDs.end() )
+    {
+        switch( pFont->m_eType )
+        {
+            case fonttype::Type1:
+                static_cast<Type1FontFile*>(pFont)->m_aXLFD = rXLFDs.front();
+                break;
+            case fonttype::TrueType:
+                static_cast<TrueTypeFontFile*>(pFont)->m_aXLFD = rXLFDs.front();
+                break;
+            default: break;
+        }
+    }
 }
 
 // -------------------------------------------------------------------------
 
-ByteString PrintFontManager::getXLFD( PrintFont* pFont ) const
+OString PrintFontManager::getXLFD( PrintFont* pFont ) const
 {
     if( pFont->m_eType == fonttype::Type1 )
     {
@@ -1788,52 +1804,65 @@ ByteString PrintFontManager::getXLFD( Pr
             return static_cast<TrueTypeFontFile*>(pFont)->m_aXLFD;
     }
 
-    ByteString aXLFD( "-misc-" );
+    OStringBuffer aXLFD( 128 );
+
+    aXLFD.append( "-misc-" );
     ByteString aFamily( String( m_pAtoms->getString( ATOM_FAMILYNAME, pFont->m_nFamilyName ) ), RTL_TEXTENCODING_UTF8 );
     aFamily.SearchAndReplaceAll( '-',' ' );
     aFamily.SearchAndReplaceAll( '?',' ' );
     aFamily.SearchAndReplaceAll( '*',' ' );
-    aXLFD += aFamily;
-    aXLFD += '-';
+    aXLFD.append( OString( aFamily ) );
+    aXLFD.append( '-' );
     switch( pFont->m_eWeight )
     {
-        case weight::Thin:              aXLFD += "thin";break;
-        case weight::UltraLight:        aXLFD += "ultralight";break;
-        case weight::Light:         aXLFD += "light";break;
-        case weight::SemiLight:     aXLFD += "semilight";break;
-        case weight::Normal:            aXLFD += "normal";break;
-        case weight::Medium:            aXLFD += "medium";break;
-        case weight::SemiBold:          aXLFD += "semibold";break;
-        case weight::Bold:              aXLFD += "bold";break;
-        case weight::UltraBold:     aXLFD += "ultrabold";break;
-        case weight::Black:         aXLFD += "black";break;
+        case weight::Thin:          aXLFD.append("thin");break;
+        case weight::UltraLight:    aXLFD.append("ultralight");break;
+        case weight::Light:         aXLFD.append("light");break;
+        case weight::SemiLight:     aXLFD.append("semilight");break;
+        case weight::Normal:        aXLFD.append("normal");break;
+        case weight::Medium:        aXLFD.append("medium");break;
+        case weight::SemiBold:      aXLFD.append("semibold");break;
+        case weight::Bold:          aXLFD.append("bold");break;
+        case weight::UltraBold:     aXLFD.append("ultrabold");break;
+        case weight::Black:         aXLFD.append("black");break;
+        default: break;
     }
-    aXLFD += '-';
+    aXLFD.append('-');
     switch( pFont->m_eItalic )
     {
-        case italic::Upright:           aXLFD += 'r';break;
-        case italic::Oblique:           aXLFD += 'o';break;
-        case italic::Italic:            aXLFD += 'i';break;
+        case italic::Upright:       aXLFD.append('r');break;
+        case italic::Oblique:       aXLFD.append('o');break;
+        case italic::Italic:        aXLFD.append('i');break;
+        default: break;
     }
-    aXLFD += '-';
+    aXLFD.append('-');
     switch( pFont->m_eWidth )
     {
-        case width::UltraCondensed: aXLFD += "ultracondensed";break;
-        case width::ExtraCondensed: aXLFD += "extracondensed";break;
-        case width::Condensed:          aXLFD += "condensed";break;
-        case width::SemiCondensed:      aXLFD += "semicondensed";break;
-        case width::Normal:         aXLFD += "normal";break;
-        case width::SemiExpanded:       aXLFD += "semiexpanded";break;
-        case width::Expanded:           aXLFD += "expanded";break;
-        case width::ExtraExpanded:      aXLFD += "extraexpanded";break;
-        case width::UltraExpanded:      aXLFD += "ultraexpanded";break;
-    }
-    aXLFD += "-utf8-0-0-0-0-";
-    aXLFD += pFont->m_ePitch == pitch::Fixed ? "m" : "p";
-    aXLFD += "-0-";
-    aXLFD += rtl_getBestUnixCharsetFromTextEncoding( pFont->m_aEncoding );
+        case width::UltraCondensed: aXLFD.append("ultracondensed");break;
+        case width::ExtraCondensed: aXLFD.append("extracondensed");break;
+        case width::Condensed:      aXLFD.append("condensed");break;
+        case width::SemiCondensed:  aXLFD.append("semicondensed");break;
+        case width::Normal:         aXLFD.append("normal");break;
+        case width::SemiExpanded:   aXLFD.append("semiexpanded");break;
+        case width::Expanded:       aXLFD.append("expanded");break;
+        case width::ExtraExpanded:  aXLFD.append("extraexpanded");break;
+        case width::UltraExpanded:  aXLFD.append("ultraexpanded");break;
+        default: break;
+    }
+    aXLFD.append("-utf8-0-0-0-0-");
+    aXLFD.append( pFont->m_ePitch == pitch::Fixed ? "m" : "p" );
+    aXLFD.append("-0-");
+    const char* pEnc = rtl_getBestUnixCharsetFromTextEncoding( pFont->m_aEncoding );
+    if( ! pEnc )
+    {
+        if( pFont->m_aEncoding == RTL_TEXTENCODING_ADOBE_STANDARD )
+            pEnc = "adobe-standard";
+        else
+            pEnc = "iso8859-1";
+    }
+    aXLFD .append( pEnc );
 
-    return aXLFD;
+    return aXLFD.makeStringAndClear();
 }
 #else /* FONTCONFIG_FONTS */
 
@@ -2199,7 +2228,7 @@ void PrintFontManager::getServerDirector
     };
     ::std::list< ByteString > aLines;
 
-    for( int i = 0; i < sizeof(pCommands)/sizeof(pCommands[0]); i++ )
+    for( unsigned int i = 0; i < sizeof(pCommands)/sizeof(pCommands[0]); i++ )
     {
         FILE* pPipe = popen( pCommands[i], "r" );
         aLines.clear();
@@ -3334,7 +3363,7 @@ int PrintFontManager::importFonts( const
     // find a directory with write access
     rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
     SvFileStream aFontsDir;
-    int nDirID;
+    int nDirID = 0;
     INetURLObject aDir;
     for( ::std::list< int >::const_iterator dir_it = m_aPrivateFontDirectories.begin();
          ! ( aFontsDir.IsOpen() && aFontsDir.IsWritable() ) && dir_it != m_aPrivateFontDirectories.end(); ++dir_it )
@@ -3958,7 +3987,8 @@ bool PrintFontManager::createFontSubset(
     memset( pGID, 0, sizeof( pGID ) );
     memset( pOldIndex, 0, sizeof( pOldIndex ) );
     int nChar = 1;
-    for( int i = 0; i < nGlyphs; i++ )
+    int i;
+    for( i = 0; i < nGlyphs; i++ )
     {
         if( pNewEncoding[i] == 0 )
         {
@@ -4048,8 +4078,8 @@ std::list< OString > PrintFontManager::g
     if( aRet.begin() == aRet.end() && aChar != 0 )
     {
         sal_Char aBuf[8];
-        snprintf( (char*)aBuf, sizeof( aBuf ), "uni%.4hX\0", aChar );
-        aRet.push_back( aBuf );
+        sal_Int32 nChars = snprintf( (char*)aBuf, sizeof( aBuf ), "uni%.4hX", aChar );
+        aRet.push_back( OString( aBuf, nChars ) );
     }
 
     return aRet;
Index: psprint/source/fontmanager/makefile.mk
===================================================================
--- psprint/source/fontmanager/makefile.mk.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/fontmanager/makefile.mk	2004-10-21 14:47:18.000000000 +0100
@@ -66,12 +66,12 @@ ENABLE_EXCEPTIONS=TRUE
 PRJNAME=psprint
 TARGET=fontman
 
-ENVCFLAGS+= -I..$/fontsubset
-
 # --- Settings -----------------------------------------------------
 
 .INCLUDE :  settings.mk
 
+CFLAGS+= -I..$/fontsubset
+
 # --- Files --------------------------------------------------------
 
 SLOFILES=\
Index: psprint/source/fontmanager/parseAFM.cxx
===================================================================
--- psprint/source/fontmanager/parseAFM.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/fontmanager/parseAFM.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -655,8 +655,7 @@ static int parseCharWidths( FILE* fp, re
  */ 
 
 static int
-reallocFontMetrics( void **pp_fontmetrics, int *p_oldcount, unsigned int n_newcount,
-                    unsigned int n_size )
+reallocFontMetrics( void **pp_fontmetrics, int *p_oldcount, int n_newcount, unsigned int n_size )
 {
     char *p_tmpmetrics = NULL;
 
@@ -788,8 +787,7 @@ static int parseCharMetrics( FILE* fp, r
                 break;
             case CHARNAME: 
                 keyword = token(fp);
-                temp->name = (char *) malloc(strlen(keyword) + 1);
-                strcpy(temp->name, keyword);
+                temp->name = (char *)strdup(keyword);
                 break;            
             case CHARBBOX: 
                 temp->charBBox.llx = atoi(token(fp));
@@ -810,11 +808,9 @@ static int parseCharMetrics( FILE* fp, r
                 
                 *tail = (Ligature *) calloc(1, sizeof(Ligature));
                 keyword = token(fp);
-                (*tail)->succ = (char *) malloc(strlen(keyword) + 1);
-                strcpy((*tail)->succ, keyword);
+                (*tail)->succ = (char *)strdup(keyword);
                 keyword = token(fp);
-                (*tail)->lig = (char *) malloc(strlen(keyword) + 1);
-                strcpy((*tail)->lig, keyword);
+                (*tail)->lig = (char *)strdup(keyword);
                 break; }
             case ENDCHARMETRICS:
                 cont = false;;
Index: psprint/source/fontsubset/gsub.cxx
===================================================================
--- psprint/source/fontsubset/gsub.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/fontsubset/gsub.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -149,7 +149,7 @@ int ReadGSUB( struct _TrueTypeFont* pTTF
         if( (nDefaultLangsysOfs != 0) && (nDefaultLangsysOfs != nLangsysOffset) )
         {       
             const FT_Byte* pLangSys = pGsubBase + nOfsScriptList + nOfsScriptTable + nDefaultLangsysOfs;
-            const USHORT nLookupOrder   = NEXT_UShort( pLangSys );
+            /*const USHORT nLookupOrder   =*/ NEXT_UShort( pLangSys );
             const USHORT nReqFeatureIdx = NEXT_UShort( pLangSys );
             const USHORT nCntFeature    = NEXT_UShort( pLangSys );
             aFeatureIndexList.push_back( nReqFeatureIdx );
@@ -163,7 +163,7 @@ int ReadGSUB( struct _TrueTypeFont* pTTF
         if( nLangsysOffset != 0 )
         {       
             const FT_Byte* pLangSys = pGsubBase + nOfsScriptList + nOfsScriptTable + nLangsysOffset;
-            const USHORT nLookupOrder   = NEXT_UShort( pLangSys );
+            /*const USHORT nLookupOrder   =*/ NEXT_UShort( pLangSys );
             const USHORT nReqFeatureIdx = NEXT_UShort( pLangSys );
             const USHORT nCntFeature    = NEXT_UShort( pLangSys );
             aFeatureIndexList.push_back( nReqFeatureIdx );
@@ -222,7 +222,7 @@ int ReadGSUB( struct _TrueTypeFont* pTTF
         const USHORT nOfsLookupTable = *it;
         const FT_Byte* pLookupTable = pGsubBase + nOfsLookupList + nOfsLookupTable;
         const USHORT eLookupType        = NEXT_UShort( pLookupTable );
-        const USHORT eLookupFlag        = NEXT_UShort( pLookupTable );
+        /*const USHORT eLookupFlag        =*/ NEXT_UShort( pLookupTable );
         const USHORT nCntLookupSubtable = NEXT_UShort( pLookupTable );
 
         // TODO: switch( eLookupType )
Index: psprint/source/fontsubset/list.c
===================================================================
--- psprint/source/fontsubset/list.c.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/fontsubset/list.c	2004-10-21 14:47:18.000000000 +0100
@@ -72,8 +72,11 @@
 #include <stdlib.h>
 
 #if OSL_DEBUG_LEVEL == 0
-#define NDEBUG
+#  ifndef NDEBUG
+#    define NDEBUG
+#  endif
 #endif
+
 #include <assert.h>
 
 #ifdef MALLOC_TRACE
@@ -606,7 +609,7 @@ int main()
 
     for(i=0; i<10; i++) {
         ptr = malloc(20);
-        sprintf(ptr, "element # %d", i);
+        snprintf(ptr, 20, "element # %d", i);
         listAppend(l1, ptr);
     }
 
Index: psprint/source/fontsubset/sft.c
===================================================================
--- psprint/source/fontsubset/sft.c.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/fontsubset/sft.c	2004-10-21 14:47:18.000000000 +0100
@@ -67,7 +67,9 @@
  */
 
 #if OSL_DEBUG_LEVEL == 0
-#define NDEBUG
+#  ifndef NDEBUG
+#    define NDEBUG
+#  endif
 #endif
 #include <assert.h>
 
@@ -937,19 +939,18 @@ static int BSplineToPSPath(ControlPoint 
     int i = 0, pCount = 0;
     PSPathElement *p;
 
-    int x0, y0, x1, y1, x2, y2, curx, cury;
+    int x0 = 0, y0 = 0, x1 = 0, y1 = 0, x2, y2, curx, cury;
     int lastOff = 0;                                        /*- last point was off-contour */
     int scflag = 1;                                         /*- start contour flag */
     int ecflag = 0;                                         /*- end contour flag */
     int cp = 0;                                             /*- current point */
+    int StartContour = 0, EndContour = 1;
 
     listSetElementDtor(pList, free);
     *path = 0;
 
     /* if (srcCount > 0) for(;;) */
     while (srcCount > 0) {                                  /*- srcCount does not get changed inside the loop. */
-        int StartContour, EndContour;
-
         if (scflag) {
             int l = cp;
             StartContour = cp;
@@ -2218,10 +2219,10 @@ int  CreateTTFromTTGlyphs(TrueTypeFont  
 static GlyphOffsets *GlyphOffsetsNew(sal_uInt8 *sfntP)
 {
     GlyphOffsets *res = smalloc(sizeof(GlyphOffsets));
-    sal_uInt8 *loca;
+    sal_uInt8 *loca = NULL;
     sal_uInt16 i, numTables = GetUInt16(sfntP, 4, 1);
-    sal_uInt32 locaLen;
-    sal_Int16 indexToLocFormat;
+    sal_uInt32 locaLen = 0;
+    sal_Int16 indexToLocFormat = 0;
 
     for (i = 0; i < numTables; i++) {
         sal_uInt32 tag = GetUInt32(sfntP + 12, 16 * i, 1);
@@ -2380,7 +2381,7 @@ int  CreateT42FromTTGlyphs(TrueTypeFont 
         return res;
     }
 
-    fprintf(outf, "%%!PS-TrueTypeFont-%d.%d-%d.%d\n", ver>>16, ver & 0xFFFF, rev>>16, rev & 0xFFFF);
+    fprintf(outf, "%%!PS-TrueTypeFont-%d.%d-%d.%d\n", (int)(ver>>16), (int)(ver & 0xFFFF), (int)(rev>>16), (int)(rev & 0xFFFF));
     fprintf(outf, "%%%%Creator: %s %s %s\n", modname, modver, modextra);
     fprintf(outf, "%%- Font subset generated from a source font file: '%s'\n", ttf->fname);
     fprintf(outf, "%%- Original font name: %s\n", ttf->psname);
@@ -2398,7 +2399,7 @@ int  CreateT42FromTTGlyphs(TrueTypeFont 
     for (i = 1; i<nGlyphs; i++) {
         fprintf(outf, "Encoding %d /glyph%d put\n", encoding[i], gID[i]);
     }
-    fprintf(outf, "/XUID [103 0 1 16#%08X %d 16#%08X 16#%08X] def\n", rtl_crc32(0, ttf->ptr, ttf->fsize), nGlyphs, rtl_crc32(0, glyphArray, nGlyphs * 2), rtl_crc32(0, encoding, nGlyphs));
+    fprintf(outf, "/XUID [103 0 1 16#%08X %d 16#%08X 16#%08X] def\n", (unsigned int)rtl_crc32(0, ttf->ptr, ttf->fsize), (unsigned int)nGlyphs, (unsigned int)rtl_crc32(0, glyphArray, nGlyphs * 2), (unsigned int)rtl_crc32(0, encoding, nGlyphs));
 
     DumpSfnts(outf, sfntP);
 
@@ -2740,6 +2741,7 @@ int GetTTNameRecords(TrueTypeFont *ttf, 
                 rec[i].slen = 0;
                 continue;
             }
+
             rec_string = table + nStrBase + nStrOffset;
             // sanity check
             if( rec_string > (sal_uInt8*)ttf->ptr && rec_string < ((sal_uInt8*)ttf->ptr + ttf->fsize - rec[i].slen ) )
Index: psprint/source/fontsubset/ttcr.c
===================================================================
--- psprint/source/fontsubset/ttcr.c.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/fontsubset/ttcr.c	2004-10-21 14:47:18.000000000 +0100
@@ -73,7 +73,9 @@
 #include <string.h>
 
 #if OSL_DEBUG_LEVEL == 0
-#define NDEBUG
+#  ifndef NDEBUG
+#    define NDEBUG
+#  endif
 #endif
 #include <assert.h>
 
@@ -299,7 +301,7 @@ void TrueTypeCreatorNewEmpty(sal_uInt32 
     TrueTypeCreator *ptr = smalloc(sizeof(TrueTypeCreator));
 
     ptr->tables = listNewEmpty();
-    listSetElementDtor(ptr->tables, TrueTypeTableDispose);
+    listSetElementDtor(ptr->tables, (void(*)(void*))TrueTypeTableDispose);
 
     ptr->tag = tag;
 
@@ -348,7 +350,7 @@ int StreamToMemory(TrueTypeCreator *_thi
     sal_uInt8 *ttf;
     int i=0, n;
     TableEntry *te;
-    sal_uInt8 *head;     /* saved pointer to the head table data for checkSumAdjustment calculation */
+    sal_uInt8 *head = NULL;     /* saved pointer to the head table data for checkSumAdjustment calculation */
     
     if ((n = listCount(_this->tables)) == 0) return SF_TTFORMAT;
 
@@ -628,7 +630,7 @@ static void TrueTypeTableDispose_post(Tr
             if (p->format == 0x00030000) {
                 /* do nothing */
             } else {
-                fprintf(stderr, "Unsupported format of a 'post' table: %08X.\n", p->format);
+                fprintf(stderr, "Unsupported format of a 'post' table: %08X.\n", (int)p->format);
             }
             free(p);
         }
@@ -955,7 +957,7 @@ static int GetRawData_post(TrueTypeTable
         PutUInt16((sal_uInt16)p->isFixedPitch, post, 12, 1);
         ret = TTCR_OK;
     } else {
-        fprintf(stderr, "Unrecognized format of a post table: %08X.\n", p->format);
+        fprintf(stderr, "Unrecognized format of a post table: %08X.\n", (int)p->format);
         ret = TTCR_POSTFORMAT;
     }
 
Index: psprint/source/helper/helper.cxx
===================================================================
--- psprint/source/helper/helper.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/helper/helper.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -359,8 +359,8 @@ bool psp::convertPfbToPfa( ::osl::File& 
     {
         // read leading bytes
         bEof = ! rInFile.read( buffer, 6, nRead ) && nRead == 6 ? false : true;
-        int nType = buffer[ 1 ];
-        int nBytesToRead = buffer[2] | buffer[3] << 8 | buffer[4] << 16 | buffer[5] << 24;
+        unsigned int nType = buffer[ 1 ];
+        unsigned int nBytesToRead = buffer[2] | buffer[3] << 8 | buffer[4] << 16 | buffer[5] << 24;
         if( buffer[0] != 0x80 ) // test for pfb m_agic number
         {
             // this migt be a pfa font already
@@ -395,8 +395,8 @@ bool psp::convertPfbToPfa( ::osl::File& 
                     // ascii data, convert dos lineends( \r\n ) and
                     // m_ac lineends( \r ) to \n
                     unsigned char * pWriteBuffer = new unsigned char[ nBytesToRead ];
-                    int nBytesToWrite = 0;
-                    for( int i = 0; i < nBytesToRead; i++ )
+                    unsigned int nBytesToWrite = 0;
+                    for( unsigned int i = 0; i < nBytesToRead; i++ )
                     {
                         if( pBuffer[i] != '\r' )
                             pWriteBuffer[ nBytesToWrite++ ] = pBuffer[i];
@@ -416,8 +416,8 @@ bool psp::convertPfbToPfa( ::osl::File& 
                 else
                 {
                     // binary data
-                    int nBuffer = 0;
-                    for( int i = 0; i < nBytesToRead && bSuccess; i++ )
+                    unsigned int nBuffer = 0;
+                    for( unsigned int i = 0; i < nBytesToRead && bSuccess; i++ )
                     {
                         buffer[ nBuffer++ ] = hexDigits[ pBuffer[ i ] >> 4 ];
                         buffer[ nBuffer++ ] = hexDigits[ pBuffer[ i ] & 15 ];
@@ -450,3 +450,35 @@ bool psp::convertPfbToPfa( ::osl::File& 
 
     return bSuccess;
 }
+void psp::normPath( OString& rPath )
+{
+    char buf[PATH_MAX];
+    ByteString aPath( rPath );
+    
+    // double slashes and slash at end are probably
+    // removed by realpath anyway, but since this runs
+    // on many different platforms let's play it safe
+    while( aPath.SearchAndReplace( "//", "/" ) != STRING_NOTFOUND )
+        ;
+    if( aPath.Len() > 0 && aPath.GetChar( aPath.Len()-1 ) == '/' )
+        aPath.Erase( aPath.Len()-1 );
+
+    if( realpath( aPath.GetBuffer(), buf ) )
+        rPath = buf;
+    else
+        rPath = aPath;
+}
+
+void psp::splitPath( OString& rPath, OString& rDir, OString& rBase )
+{
+    normPath( rPath );
+    sal_Int32 nIndex = rPath.lastIndexOf( '/' );
+    if( nIndex > 0 )
+        rDir = rPath.copy( 0, nIndex );
+    else if( nIndex == 0 ) // root dir
+        rDir = rPath.copy( 0, 1 );
+    if( rPath.getLength() > nIndex+1 )
+        rBase = rPath.copy( nIndex+1 );
+}
+
+
Index: psprint/source/helper/ppdparser.cxx
===================================================================
--- psprint/source/helper/ppdparser.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/helper/ppdparser.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -61,22 +61,13 @@
 #include <stdlib.h>
 #include <stdio.h>
 
-#ifndef __SGI_STL_HASH_MAP
 #include <hash_map>
-#endif
-// define a hash for PPDKey
-namespace psp { class PPDKey; }
-
-struct std::hash< const psp::PPDKey* >
-{
-    size_t operator()( const psp::PPDKey * pKey) const
-    { return (size_t)pKey; }
-};
 
 #include <psprint/ppdparser.hxx>
 #include <tools/debug.hxx>
 #include <psprint/strhelper.hxx>
 #include <psprint/helper.hxx>
+#include <cupsmgr.hxx>
 #include <tools/urlobj.hxx>
 #include <tools/stream.hxx>
 #include <osl/mutex.hxx>
@@ -104,13 +95,11 @@ static String aEmptyString;
 void PPDParser::scanPPDDir( const String& rDir )
 {
     static const sal_Char* pSuffixes[] = { "PS", "PPD" };
-    static const int nSuffixLens[] = { 2, 3 };
     const int nSuffixes = sizeof(pSuffixes)/sizeof(pSuffixes[0]);
 
     osl::Directory aDir( rDir );
     aDir.open();
     osl::DirectoryItem aItem;
-    bool bWas = false;
 
     INetURLObject aPPDDir(rDir);
     while( aDir.getNextItem( aItem ) == osl::FileBase::E_None )
@@ -181,24 +170,21 @@ String PPDParser::getPPDFile( const Stri
     if( ! aStream.IsOpen() )
     {
         initPPDFiles();
-#ifdef MACOSX
+        // some PPD files contain dots beside the extension, so try name first,
+        // base after that
         std::hash_map< OUString, OUString, OUStringHash >::const_iterator it =
             pAllPPDFiles->find( aPPD.getName() );
-#else
-        std::hash_map< OUString, OUString, OUStringHash >::const_iterator it =
-            pAllPPDFiles->find( aPPD.getBase() );
-#endif // MACOSX
+        if( it == pAllPPDFiles->end() )
+            it = pAllPPDFiles->find( aPPD.getBase() );
         if( it == pAllPPDFiles->end() )
         {
             // a new file ? rehash
             delete pAllPPDFiles; pAllPPDFiles = NULL;
             initPPDFiles();
             // aPPD is already the file name minus the extension
-#ifdef MACOSX
             it = pAllPPDFiles->find( aPPD.getName() );
-#else
-            it = pAllPPDFiles->find( aPPD.getBase() );
-#endif // MACOSX
+            if( it == pAllPPDFiles->end() )
+                it = pAllPPDFiles->find( aPPD.getBase() );
             // note this is optimized for office start where
             // no new files occur and initPPDFiles is called only once
         }
@@ -275,10 +261,13 @@ const PPDParser* PPDParser::getParser( S
     static ::osl::Mutex aMutex;
     ::osl::Guard< ::osl::Mutex > aGuard( aMutex );
 
-    aFile = getPPDFile( aFile );
+    if( aFile.CompareToAscii( "CUPS:", 5 ) != COMPARE_EQUAL )
+        aFile = getPPDFile( aFile );
     if( ! aFile.Len() )
     {
-        fprintf( stderr, "Could not get printer PPD file!\n" );
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "Could not get printer PPD file \"%s\" !\n", OUStringToOString( aFile, osl_getThreadTextEncoding() ).getStr() );
+#endif
         return NULL;
     }
 
@@ -286,8 +275,25 @@ const PPDParser* PPDParser::getParser( S
         if( (*it)->m_aFile == aFile )
             return *it;
 
-    PPDParser *pNewParser = new PPDParser( aFile );
-    aAllParsers.push_back( pNewParser );
+    PPDParser* pNewParser = NULL;
+    if( aFile.CompareToAscii( "CUPS:", 5 ) != COMPARE_EQUAL )
+        pNewParser = new PPDParser( aFile );
+    else
+    {
+        PrinterInfoManager& rMgr = PrinterInfoManager::get();
+        if( rMgr.getType() == PrinterInfoManager::CUPS )
+        {
+            pNewParser = const_cast<PPDParser*>(static_cast<CUPSManager&>(rMgr).createCUPSParser( aFile ));
+        }
+    }
+    if( pNewParser )
+    {
+        // this may actually be the SGENPRT parser,
+        // so ensure uniquness here
+        aAllParsers.remove( pNewParser );
+        // insert new parser to list
+        aAllParsers.push_front( pNewParser );
+    }
     return pNewParser;
 }
 
@@ -304,6 +310,7 @@ void PPDParser::freeAll()
 
 PPDParser::PPDParser( const String& rFile ) :
         m_aFile( rFile ),
+        m_bType42Capable( false ),
         m_pDefaultImageableArea( NULL ),
         m_pImageableAreas( NULL ),
         m_pDefaultPaperDimension( NULL ),
@@ -314,8 +321,7 @@ PPDParser::PPDParser( const String& rFil
         m_pResolutions( NULL ),
         m_pDefaultDuplexType( NULL ),
         m_pDuplexTypes( NULL ),
-        m_pFontList( NULL ),
-        m_bType42Capable( false )
+        m_pFontList( NULL )
 {
     // read in the file
     ::std::list< String > aLines;
@@ -350,8 +356,8 @@ PPDParser::PPDParser( const String& rFil
 
     // now get the Values
     parse( aLines );
-#ifdef __DEBUG
-    fprintf( stderr, "acquired %d Keys from PPD %s:\n", m_aKeys.Count(), BSTRING( m_aFile ).GetBuffer() );
+#if OSL_DEBUG_LEVEL > 2
+    fprintf( stderr, "acquired %d Keys from PPD %s:\n", m_aKeys.size(), BSTRING( m_aFile ).GetBuffer() );
     for( PPDParser::hash_type::const_iterator it = m_aKeys.begin(); it != m_aKeys.end(); ++it )
     {
         const PPDKey* pKey = it->second;
@@ -375,7 +381,7 @@ PPDParser::PPDParser( const String& rFil
         for( int j = 0; j < pKey->countValues(); j++ )
         {
             fprintf( stderr, "\t\t" );
-            PPDValue* pValue = pKey->getValue( j );
+            const PPDValue* pValue = pKey->getValue( j );
             if( pValue == pKey->m_pDefaultValue )
                 fprintf( stderr, "(Default:) " );
             char* pVType = "<unknown>";
@@ -396,15 +402,14 @@ PPDParser::PPDParser( const String& rFil
                      BSTRING( pValue->m_aValueTranslation ).GetBuffer() );
         }
     }
-    fprintf( stderr, "constraints: (%d found)\n", m_aConstraints.Count() );
-    for( int j = 0; j < m_aConstraints.Count(); j++ )
+    fprintf( stderr, "constraints: (%d found)\n", m_aConstraints.size() );
+    for( std::list< PPDConstraint >::const_iterator cit = m_aConstraints.begin(); cit != m_aConstraints.end(); ++cit )
     {
-        PPDConstraint* pCon = m_aConstraints.GetObject( j );
         fprintf( stderr, "*\"%s\" \"%s\" *\"%s\" \"%s\"\n",
-                 BSTRING( pCon->m_pKey1->getKey() ).GetBuffer(),
-                 pCon->m_pOption1 ? BSTRING( pCon->m_pOption1->m_aOption ).GetBuffer() : "<nil>",
-                 BSTRING( pCon->m_pKey2->getKey() ).GetBuffer(),
-                 pCon->m_pOption2 ? BSTRING( pCon->m_pOption2->m_aOption ).GetBuffer() : "<nil>"
+                 BSTRING( cit->m_pKey1->getKey() ).GetBuffer(),
+                 cit->m_pOption1 ? BSTRING( cit->m_pOption1->m_aOption ).GetBuffer() : "<nil>",
+                 BSTRING( cit->m_pKey2->getKey() ).GetBuffer(),
+                 cit->m_pOption2 ? BSTRING( cit->m_pOption2->m_aOption ).GetBuffer() : "<nil>"
                  );
     }
 #endif
@@ -444,16 +449,16 @@ PPDParser::PPDParser( const String& rFil
     DBG_ASSERT( m_pFontList, "Warning: no Font in PPD\n" );
 
     // fill in direct values
-    if( pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "ModelName" ) ) ) )
+    if( (pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "ModelName" ) ) )) )
         m_aPrinterName = pKey->getValue( 0 )->m_aValue;
-    if( pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "NickName" ) ) ) )
+    if( (pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "NickName" ) ) )) )
         m_aNickName = pKey->getValue( 0 )->m_aValue;
-    if( pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "ColorDevice" ) ) ) )
+    if( (pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "ColorDevice" ) ) )) )
         m_bColorDevice = pKey->getValue( 0 )->m_aValue.CompareIgnoreCaseToAscii( "true", 4 ) == COMPARE_EQUAL ? true : false;
 
-    if( pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "LanguageLevel" ) ) ) )
+    if( (pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "LanguageLevel" ) ) )) )
         m_nLanguageLevel = pKey->getValue( 0 )->m_aValue.ToInt32();
-    if( pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "TTRasterizer" ) ) ) )
+    if( (pKey = getKey( String( RTL_CONSTASCII_USTRINGPARAM( "TTRasterizer" ) ) )) )
         m_bType42Capable = pKey->getValue( 0 )->m_aValue.EqualsIgnoreCaseAscii( "Type42" ) ? true : false;
 
 #ifdef MACOSX
@@ -490,7 +495,7 @@ void PPDParser::insertKey( const String&
 
 const PPDKey* PPDParser::getKey( int n ) const
 {
-    return (n < m_aOrderedKeys.size() && n >= 0) ? m_aOrderedKeys[n] : NULL;
+    return ((unsigned int)n < m_aOrderedKeys.size() && n >= 0) ? m_aOrderedKeys[n] : NULL;
 }
 
 const PPDKey* PPDParser::getKey( const String& rKey ) const
@@ -1194,10 +1199,10 @@ const String& PPDParser::getFont( int nF
 
 PPDKey::PPDKey( const String& rKey ) :
         m_aKey( rKey ),
-        m_bUIOption( false ),
-        m_eUIType( PickOne ),
         m_pDefaultValue( NULL ),
         m_bQueryValue( false ),
+        m_bUIOption( false ),
+        m_eUIType( PickOne ),
         m_nOrderDependency( 100 ),
         m_eSetupType( AnySetup )
 {
@@ -1213,14 +1218,13 @@ PPDKey::~PPDKey()
 
 const PPDValue* PPDKey::getValue( int n ) const
 {
-    return (n < m_aOrderedValues.size() && n >= 0) ? m_aOrderedValues[n] : NULL;
+    return ((unsigned int)n < m_aOrderedValues.size() && n >= 0) ? m_aOrderedValues[n] : NULL;
 }
 
 // -------------------------------------------------------------------
 
 const PPDValue* PPDKey::getValue( const String& rOption ) const
 {
-    const PPDValue* pValue = NULL;
     PPDKey::hash_type::const_iterator it = m_aValues.find( rOption );
     return it != m_aValues.end() ? &it->second : NULL;
 }
@@ -1289,7 +1293,7 @@ PPDContext::~PPDContext()
 
 const PPDKey* PPDContext::getModifiedKey( int n ) const
 {
-    ::std::hash_map< const PPDKey*, const PPDValue* >::const_iterator it;
+    hash_type::const_iterator it;
     for( it = m_aCurrentValues.begin(); it != m_aCurrentValues.end() && n--; ++it )
         ;
     return it != m_aCurrentValues.end() ? it->first : NULL;
@@ -1299,8 +1303,11 @@ const PPDKey* PPDContext::getModifiedKey
 
 void PPDContext::setParser( const PPDParser* pParser )
 {
-    m_aCurrentValues.clear();
-    m_pParser = pParser;
+    if( pParser != m_pParser )
+    {
+        m_aCurrentValues.clear();
+        m_pParser = pParser;
+    }
 }
 
 // -------------------------------------------------------------------
@@ -1310,7 +1317,7 @@ const PPDValue* PPDContext::getValue( co
     if( ! m_pParser )
         return NULL;
 
-    ::std::hash_map< const PPDKey*, const PPDValue* >::const_iterator it;
+    hash_type::const_iterator it;
     it = m_aCurrentValues.find( pKey );
     if( it != m_aCurrentValues.end() )
         return it->second;
@@ -1349,7 +1356,7 @@ const PPDValue* PPDContext::setValue( co
             m_aCurrentValues[ pKey ] = pValue;
 
             // after setting this value, check all constraints !
-            ::std::hash_map< const PPDKey*, const PPDValue* >::iterator it = m_aCurrentValues.begin();
+            hash_type::iterator it = m_aCurrentValues.begin();
             while(  it != m_aCurrentValues.end() )
             {
                 if( it->first != pKey &&
@@ -1539,10 +1546,9 @@ void PPDContext::getUnconstrainedValues(
 void* PPDContext::getStreamableBuffer( ULONG& rBytes ) const
 {
     rBytes = 0;
-    int i;
     if( ! m_aCurrentValues.size() )
         return NULL;
-    ::std::hash_map< const PPDKey*, const PPDValue* >::const_iterator it;
+    hash_type::const_iterator it;
     for( it = m_aCurrentValues.begin(); it != m_aCurrentValues.end(); ++it )
     {
         ByteString aCopy( it->first->getKey(), RTL_TEXTENCODING_MS_1252 );
Index: psprint/source/helper/strhelper.cxx
===================================================================
--- psprint/source/helper/strhelper.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/helper/strhelper.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -643,19 +643,19 @@ int getValueOfDouble( char* pBuffer, dou
 
     if( ! finite( f ) )
     {
-        strcpy( pBuffer, "Inf" );
+        strncpy( pBuffer, "Inf", 3 );
         return 3;
     }
 
     if( isnan( f ) )
     {
-        strcpy( pBuffer, "NaN" );
+        strncpy( pBuffer, "NaN", 3 );
         return 3;
     }
 
     if( f == 0.0 )
     {
-        strcpy( pBuffer, "0" );
+        strncpy( pBuffer, "0", 3 );
         return 1;
     }
 
@@ -664,12 +664,12 @@ int getValueOfDouble( char* pBuffer, dou
         *pBuffer++ = '-';
         f = -f;
     }
-    int exponent = log10( f );
+    int exponent = (int)log10( f );
     if( exponent < 4 && exponent > -4 )
         exponent = 0;
     f /= pow( 10, (double) exponent );
 
-    int nInt = f;
+    int nInt = (int)f;
     f -= nInt;
     // f should really not be 1.0 after this, but some
     // hardware implementations seem to round at this point
@@ -696,7 +696,7 @@ int getValueOfDouble( char* pBuffer, dou
         do
         {
             f *= 10;
-            nInt = f;
+            nInt = (int)f;
             f -= nInt;
             // f should really not be 1.0 after this, but some
             // hardware implementations seem to round at this point
Index: psprint/source/printer/cupsmgr.cxx
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ psprint/source/printer/cupsmgr.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -0,0 +1,911 @@
+/*************************************************************************
+ *
+ *  $RCSfile: psprint-cups.diff,v $
+ *
+ *  $Revision: 1.8 $
+ *
+ *  last change: $Author: challs $ $Date: 2004/07/08 17:31:02 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifdef ENABLE_CUPS
+#include <cups/cups.h>
+#include <cups/ppd.h>
+#else
+typedef void ppd_file_t;
+typedef void cups_dest_t;
+typedef void cups_option_t;
+#endif
+
+#include <unistd.h>
+
+#include <osl/thread.h>
+#include <osl/diagnose.h>
+#include <osl/conditn.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <cupsmgr.hxx>
+
+#include <unistd.h>
+
+namespace psp
+{
+class CUPSWrapper
+{
+    oslModule		m_pLib;
+    osl::Mutex		m_aGetPPDMutex;
+
+    int				(*m_pcupsPrintFile)(const char*, const char*, const char*, int, cups_option_t*);
+    int				(*m_pcupsGetDests)(cups_dest_t**);
+    void			(*m_pcupsSetDests)(int,cups_dest_t*);
+    void			(*m_pcupsFreeDests)(int,cups_dest_t*);
+    const char*		(*m_pcupsGetPPD)(const char*);
+    int				(*m_pcupsMarkOptions)(ppd_file_t*,int,cups_option_t*);
+    int				(*m_pcupsAddOption)(const char*,const char*,int,cups_option_t**);
+    void			(*m_pcupsFreeOptions)(int,cups_option_t*);
+    ppd_file_t*		(*m_pppdOpenFile)(const char* pFile);
+    void			(*m_pppdClose)(ppd_file_t*);
+    const char*		(*m_pcupsServer)();
+    void			(*m_pcupsSetPasswordCB)(const char*(cb)(const char*));
+    const char*		(*m_pcupsUser)();
+    void			(*m_pcupsSetUser)(const char*);
+
+    void* loadSymbol( const char* );
+public:
+    CUPSWrapper();
+    ~CUPSWrapper();
+
+    bool isValid();
+
+    int cupsGetDests(cups_dest_t** pDests)
+    { return m_pcupsGetDests(pDests); }
+
+    void cupsSetDests( int nDests, cups_dest_t* pDests )
+    { m_pcupsSetDests( nDests, pDests ); }
+
+    void cupsFreeDests(int nDests, cups_dest_t* pDests)
+    { m_pcupsFreeDests(nDests, pDests); }
+
+    int cupsPrintFile( const char* pPrinter,
+                       const char* pFileName,
+                       const char* pTitle,
+                       int nOptions,
+                   cups_option_t* pOptions )
+    { return m_pcupsPrintFile( pPrinter, pFileName, pTitle, nOptions, pOptions ); }
+
+    const char* cupsGetPPD( const char* pPrinter );
+
+    int cupsMarkOptions(ppd_file_t* pPPD, int nOptions, cups_option_t* pOptions )
+    { return m_pcupsMarkOptions(pPPD, nOptions, pOptions); }
+
+    int cupsAddOption( const char* pName, const char* pValue, int nOptions, cups_option_t** pOptions )
+    { return m_pcupsAddOption( pName, pValue, nOptions, pOptions ); }
+
+    void cupsFreeOptions( int nOptions, cups_option_t* pOptions )
+    { m_pcupsFreeOptions( nOptions, pOptions ); }
+
+    ppd_file_t* ppdOpenFile( const char* pFileName )
+    { return m_pppdOpenFile( pFileName ); }
+
+    void ppdClose( ppd_file_t* pPPD )
+    { m_pppdClose( pPPD ); }
+
+    const char	*cupsServer(void)
+    { return m_pcupsServer(); }
+
+    const char	*cupsUser(void)
+    { return m_pcupsUser(); }
+    
+    void cupsSetPasswordCB(const char *(*cb)(const char *))
+    { m_pcupsSetPasswordCB( cb ); }
+
+    void cupsSetUser(const char *user)
+    { m_pcupsSetUser( user ); }
+    
+};
+}
+
+using namespace psp;
+using namespace osl;
+using namespace rtl;
+
+/*
+ *  CUPSWrapper class
+ */
+
+void* CUPSWrapper::loadSymbol( const char* pSymbol )
+{
+    OUString aSym( OUString::createFromAscii( pSymbol ) );
+    void* pSym = osl_getSymbol( m_pLib, aSym.pData );
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "%s %s\n", pSymbol, pSym ? "found" : "not found" );
+#endif
+    return pSym;
+}
+
+CUPSWrapper::CUPSWrapper() 
+        : m_pLib( NULL )
+{
+#ifdef ENABLE_CUPS
+    OUString aLib( RTL_CONSTASCII_USTRINGPARAM( "libcups.so.2" ) );
+    m_pLib = osl_loadModule( aLib.pData, SAL_LOADMODULE_LAZY );
+    if( ! m_pLib )
+    {
+        aLib = OUString( RTL_CONSTASCII_USTRINGPARAM( "libcups.so" ) );
+        m_pLib = osl_loadModule( aLib.pData, SAL_LOADMODULE_LAZY );
+    }
+#endif
+
+    if( ! m_pLib )
+    {
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "no cups library found\n" );
+#endif
+        return;
+    }
+
+    m_pcupsPrintFile	 	= (int(*)(const char*,const char*,const char*,int,cups_option_t*))
+        loadSymbol( "cupsPrintFile" );
+    m_pcupsGetDests			= (int(*)(cups_dest_t**))
+        loadSymbol( "cupsGetDests" );
+    m_pcupsSetDests			= (void(*)(int,cups_dest_t*))
+        loadSymbol( "cupsSetDests" );
+    m_pcupsFreeDests		= (void(*)(int,cups_dest_t*))
+        loadSymbol( "cupsFreeDests" );
+    m_pcupsGetPPD			= (const char*(*)(const char*))
+        loadSymbol( "cupsGetPPD" );
+    m_pcupsMarkOptions		= (int(*)(ppd_file_t*,int,cups_option_t*))
+        loadSymbol( "cupsMarkOptions" );
+    m_pcupsAddOption		= (int(*)(const char*,const char*,int,cups_option_t**))
+        loadSymbol( "cupsAddOption" );
+    m_pcupsFreeOptions		= (void(*)(int,cups_option_t*))
+        loadSymbol( "cupsFreeOptions" );
+    m_pppdOpenFile			= (ppd_file_t*(*)(const char*))
+        loadSymbol( "ppdOpenFile" );
+    m_pppdClose				= (void(*)(ppd_file_t*))
+        loadSymbol( "ppdClose" );
+    m_pcupsServer			= (const char*(*)())
+        loadSymbol( "cupsServer" );
+    m_pcupsUser				= (const char*(*)())
+        loadSymbol( "cupsUser" );
+    m_pcupsSetPasswordCB	= (void(*)(const char*(*)(const char*)))
+        loadSymbol( "cupsSetPasswordCB" );
+    m_pcupsSetUser			= (void(*)(const char*))
+        loadSymbol( "cupsSetUser" );
+
+    if( ! (
+           m_pcupsPrintFile					&&
+           m_pcupsGetDests					&&
+           m_pcupsSetDests					&&
+           m_pcupsFreeDests					&&
+           m_pcupsGetPPD					&&
+           m_pcupsMarkOptions				&&
+           m_pcupsAddOption					&&
+           m_pcupsServer					&&
+           m_pcupsUser						&&
+           m_pcupsSetPasswordCB				&&
+           m_pcupsSetUser					&&
+           m_pcupsFreeOptions				&&
+           m_pppdOpenFile					&&
+           m_pppdClose
+           ) )
+    {
+        osl_unloadModule( m_pLib );
+        m_pLib = NULL;
+    }
+}
+
+CUPSWrapper::~CUPSWrapper()
+{
+    if( m_pLib )
+        osl_unloadModule( m_pLib );
+}
+
+bool CUPSWrapper::isValid()
+{
+    return m_pLib != NULL;
+}
+
+static struct GetPPDAttribs
+{
+    const char* (*pFunction)(const char*);
+    osl::Condition		m_aCondition;
+    const char*			m_pParameter;
+    const char*			m_pResult;
+    oslThread			m_aThread;
+} *pAttribs = NULL;
+
+extern "C" {
+    static void getPPDWorker(void*)
+    {
+        pAttribs->m_pResult = pAttribs->pFunction( pAttribs->m_pParameter );
+        if( pAttribs->m_aCondition.check() )
+        {
+            // timed out, unlink file
+            if( pAttribs->m_pResult )
+                unlink( pAttribs->m_pResult );
+            delete pAttribs;
+            pAttribs = NULL;
+        }
+        else
+            pAttribs->m_aCondition.set();
+    }
+}
+
+const char* CUPSWrapper::cupsGetPPD( const char* pPrinter )
+{
+    const char* pResult = NULL;
+
+    // if one thread hangs in cupsGetPPD already, don't start another
+    if( ! pAttribs )
+    {
+        pAttribs = new GetPPDAttribs();
+        pAttribs->pFunction			= m_pcupsGetPPD;
+        pAttribs->m_aCondition.reset();
+        pAttribs->m_pParameter		= pPrinter;
+        pAttribs->m_pResult			= NULL;
+        pAttribs->m_aThread			= osl_createThread( getPPDWorker, NULL );
+
+        TimeValue aValue;
+        aValue.Seconds = 5;
+        aValue.Nanosec = 0;
+        if( pAttribs->m_aCondition.wait( &aValue ) == Condition::result_ok )
+        {
+            osl_destroyThread( pAttribs->m_aThread );
+            pResult = pAttribs->m_pResult;
+            delete pAttribs;
+            pAttribs = NULL;
+        }
+        else
+        {
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "cupsGetPPD %s timed out\n", pPrinter );
+#endif
+            // should the thread awake again notify it to clean up itself
+            pAttribs->m_aCondition.set();
+            osl_destroyThread( pAttribs->m_aThread );
+        }
+    }
+
+    return pResult;
+}
+
+static const char* setPasswordCallback( const char* pIn )
+{
+    const char* pRet = NULL;
+    
+    PrinterInfoManager& rMgr = PrinterInfoManager::get();
+    if( rMgr.getType() == PrinterInfoManager::CUPS ) // sanity check
+        pRet = static_cast<CUPSManager&>(rMgr).authenticateUser( pIn );
+    return pRet;
+}
+
+/*
+ *  CUPSManager class
+ */
+
+CUPSManager* CUPSManager::tryLoadCUPS()
+{
+    CUPSManager* pManager = NULL;
+#ifdef ENABLE_CUPS
+    static const char* pEnv = getenv( "SAL_DISABLE_CUPS" );
+    
+    if( ! pEnv || ! *pEnv )
+    {
+        // try to load CUPS
+        CUPSWrapper* pWrapper = new CUPSWrapper();
+        if( pWrapper->isValid() )
+            pManager = new CUPSManager( pWrapper );
+        else
+            delete pWrapper;
+    }
+#endif
+    return pManager;
+}
+
+CUPSManager::CUPSManager( CUPSWrapper* pWrapper ) :
+        PrinterInfoManager( CUPS ),
+        m_pCUPSWrapper( pWrapper ),
+        m_nDests( 0 ),
+        m_pDests( NULL ),
+        m_bNewDests( false )
+{
+    m_aDestThread = osl_createThread( runDestThread, this );
+}
+
+CUPSManager::~CUPSManager()
+{
+    if( m_aDestThread )
+    {
+        // if the thread is still running here, then
+        // cupsGetDests is hung; terminate the thread instead of joining
+        osl_terminateThread( m_aDestThread );
+        osl_destroyThread( m_aDestThread );
+    }
+
+    if( m_nDests && m_pDests )
+        m_pCUPSWrapper->cupsFreeDests( m_nDests, (cups_dest_t*)m_pDests );
+    delete m_pCUPSWrapper;
+}
+
+void CUPSManager::runDestThread( void* pThis )
+{
+    ((CUPSManager*)pThis)->runDests();
+}
+
+void CUPSManager::runDests()
+{
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "starting cupsGetDests\n" );
+#endif
+    int nDests = 0;
+    cups_dest_t* pDests = NULL;
+    nDests = m_pCUPSWrapper->cupsGetDests( &pDests );
+
+    osl::MutexGuard aGuard( m_aCUPSMutex );
+    m_nDests = nDests;
+    m_pDests = pDests;
+    m_bNewDests = true;
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "finished cupsGetDests\n" );
+#endif
+}
+
+void CUPSManager::initialize()
+{
+    // get normal printers, clear printer list
+    PrinterInfoManager::initialize();
+
+#ifdef ENABLE_CUPS
+    // check whether thread has completed
+    // if not behave like old printing system
+    osl::MutexGuard aGuard( m_aCUPSMutex );
+
+    if( ! (m_nDests && m_pDests ) )
+        return;
+
+    // dest thread has run, clean up
+    if( m_aDestThread )
+    {
+        osl_joinWithThread( m_aDestThread );
+        osl_destroyThread( m_aDestThread );
+        m_aDestThread = NULL;
+    }
+
+    // clear old stuff
+    m_aCUPSDestMap.clear();
+
+    m_bNewDests = false;
+
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+    int nPrinter = m_nDests;
+
+    // add CUPS printers, should there be a printer
+    // with the same name as a CUPS printer, overwrite it
+    while( nPrinter-- )
+    {
+        cups_dest_t* pDest = ((cups_dest_t*)m_pDests)+nPrinter;
+        OUString aPrinterName = OStringToOUString( pDest->name, aEncoding );
+        if( pDest->instance && *pDest->instance )
+        {
+            OUStringBuffer aBuf( 256 );
+            aBuf.append( aPrinterName );
+            aBuf.append( sal_Unicode( '/' ) );
+            aBuf.append( OStringToOUString( pDest->instance, aEncoding ) );
+            aPrinterName = aBuf.makeStringAndClear();
+        }
+
+        // initialize printer with possible configuration from psprint.conf
+        Printer aPrinter = m_aPrinters[ aPrinterName ];
+        aPrinter.m_aInfo.m_aPrinterName = aPrinterName;
+        if( pDest->is_default )
+            m_aDefaultPrinter = aPrinterName;
+
+
+        OUStringBuffer aBuf( 256 );
+        aBuf.appendAscii( "CUPS:" );
+        aBuf.append( aPrinterName );
+        // note: the parser that goes with the PrinterInfo
+        // is created implicitly by the JobData::operator=()
+        // when it detects the NULL ptr m_pParser.
+        // if we wanted to fill in the parser here this
+        // would mean we'd have to download PPDs for each and
+        // every printer - which would be really bad runtime
+        // behaviour
+        aPrinter.m_aInfo.m_pParser = NULL;
+        aPrinter.m_aInfo.m_aContext.setParser( NULL );
+        std::hash_map< OUString, PPDContext, OUStringHash >::const_iterator c_it = m_aDefaultContexts.find( aPrinterName );
+        if( c_it != m_aDefaultContexts.end() )
+        {
+            aPrinter.m_aInfo.m_pParser = c_it->second.getParser();
+            aPrinter.m_aInfo.m_aContext = c_it->second;
+        }
+        aPrinter.m_aInfo.m_aDriverName = aBuf.makeStringAndClear();
+        aPrinter.m_bModified = false;
+
+        m_aPrinters[ aPrinter.m_aInfo.m_aPrinterName ] = aPrinter;
+        m_aCUPSDestMap[ aPrinter.m_aInfo.m_aPrinterName ] = nPrinter;
+    }
+
+    // remove everything that is not a CUPS printer and not
+    // a special purpose printer (PDF, Fax)
+    std::list< OUString > aRemovePrinters;
+    for( std::hash_map< OUString, Printer, OUStringHash >::iterator it = m_aPrinters.begin();
+         it != m_aPrinters.end(); ++it )
+    {
+        if( m_aCUPSDestMap.find( it->first ) != m_aCUPSDestMap.end() )
+            continue;
+
+        if( it->second.m_aInfo.m_aFeatures.getLength() > 0 )
+            continue;
+        aRemovePrinters.push_back( it->first );
+    }
+    while( aRemovePrinters.begin() != aRemovePrinters.end() )
+    {
+        m_aPrinters.erase( aRemovePrinters.front() );
+        aRemovePrinters.pop_front();
+    }
+
+    m_pCUPSWrapper->cupsSetPasswordCB( setPasswordCallback );
+#endif // ENABLE_CUPS
+}
+
+#ifdef ENABLE_CUPS
+static void updatePrinterContextInfo( ppd_group_t* pPPDGroup, PPDContext& rContext )
+{
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+    for( int i = 0; i < pPPDGroup->num_options; i++ )
+    {
+        ppd_option_t* pOption = pPPDGroup->options + i;
+        for( int n = 0; n < pOption->num_choices; n++ )
+        {
+            ppd_choice_t* pChoice = pOption->choices + n;
+            if( pChoice->marked )
+            {
+                const PPDKey* pKey = rContext.getParser()->getKey( OStringToOUString( pOption->keyword, aEncoding ) );
+                if( pKey )
+                {
+                    const PPDValue* pValue = pKey->getValue( OStringToOUString( pChoice->choice, aEncoding ) );
+                    if( pValue )
+                    {
+                        if( pValue != pKey->getDefaultValue() )
+                        {
+                            rContext.setValue( pKey, pValue, true );
+#if OSL_DEBUG_LEVEL > 1
+                            fprintf( stderr, "key %s is set to %s\n", pOption->keyword, pChoice->choice );
+#endif
+                            
+                        }                       
+#if OSL_DEBUG_LEVEL > 1
+                        else
+                            fprintf( stderr, "key %s is defaulted to %s\n", pOption->keyword, pChoice->choice );
+#endif
+                    }
+#if OSL_DEBUG_LEVEL > 1
+                    else
+                        fprintf( stderr, "caution: value %s not found in key %s\n", pChoice->choice, pOption->keyword );
+#endif
+                }
+#if OSL_DEBUG_LEVEL > 1
+                else
+                    fprintf( stderr, "caution: key %s not found in parser\n", pOption->keyword );
+#endif
+            }
+        }
+    }
+
+    // recurse through subgroups
+    for( int g = 0; g < pPPDGroup->num_subgroups; g++ )
+    {
+        updatePrinterContextInfo( pPPDGroup->subgroups + g, rContext );
+    }
+}
+#endif // ENABLE_CUPS
+
+const PPDParser* CUPSManager::createCUPSParser( const OUString& rPrinter )
+{
+    const PPDParser* pNewParser = NULL;
+    OUString aPrinter;
+
+    if( rPrinter.compareToAscii( "CUPS:", 5 ) == 0 )
+        aPrinter = rPrinter.copy( 5 );
+    else
+        aPrinter = rPrinter;
+
+#ifdef ENABLE_CUPS
+    if( m_aCUPSMutex.tryToAcquire() && m_nDests && m_pDests )
+    {
+        std::hash_map< OUString, int, OUStringHash >::iterator dest_it =
+            m_aCUPSDestMap.find( aPrinter );
+        if( dest_it != m_aCUPSDestMap.end() )
+        {
+            cups_dest_t* pDest = ((cups_dest_t*)m_pDests) + dest_it->second;
+            const char* pPPDFile = m_pCUPSWrapper->cupsGetPPD( pDest->name );
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "PPD for %s is %s\n", OUStringToOString( aPrinter, osl_getThreadTextEncoding() ).getStr(), pPPDFile );
+#endif
+            if( pPPDFile )
+            {
+                rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+                OUString aFileName( OStringToOUString( pPPDFile, aEncoding ) );
+                // update the printer info with context information
+                ppd_file_t* pPPD = m_pCUPSWrapper->ppdOpenFile( pPPDFile );
+                if( pPPD )
+                {
+                    // create the new parser
+                    PPDParser* pCUPSParser =  new PPDParser( aFileName );
+                    pCUPSParser->m_aFile = rPrinter;
+                    pNewParser = pCUPSParser;
+                    
+                    /*int nConflicts =*/ m_pCUPSWrapper->cupsMarkOptions( pPPD, pDest->num_options, pDest->options );
+#if OSL_DEBUG_LEVEL > 1
+                    fprintf( stderr, "processing the following options for printer %s (instance %s):\n",
+                    pDest->name, pDest->instance );
+                    for( int k = 0; k < pDest->num_options; k++ )
+                        fprintf( stderr, "   \"%s\" = \"%s\"\n",
+                    pDest->options[k].name,
+                    pDest->options[k].value );
+#endif
+                    PrinterInfo& rInfo = m_aPrinters[ aPrinter ].m_aInfo;
+                    
+                    // remember the default context for later use
+                    PPDContext& rContext = m_aDefaultContexts[ aPrinter ];
+                    rContext.setParser( pNewParser );
+                    for( int i = 0; i < pPPD->num_groups; i++ )
+                        updatePrinterContextInfo( pPPD->groups + i, rContext );
+                    
+                    rInfo.m_pParser = pNewParser;
+                    rInfo.m_aContext = rContext;
+                    
+                    // clean up the mess
+                    m_pCUPSWrapper->ppdClose( pPPD );
+                }
+#if OSL_DEBUG_LEVEL > 1
+                else
+                    fprintf( stderr, "ppdOpenFile failed, fallinmg back to generic driver\n" );
+#endif
+
+                // remove temporary PPD file
+                unlink( pPPDFile );
+            }
+#if OSL_DEBUG_LEVEL > 1
+            else
+                fprintf( stderr, "no dest found for printer %s\n", OUStringToOString( aPrinter, osl_getThreadTextEncoding() ).getStr() );
+#endif
+        }
+        m_aCUPSMutex.release();
+    }
+#endif // ENABLE_CUPS
+
+    if( ! pNewParser )
+    {
+        // get the default PPD
+        pNewParser = PPDParser::getParser( String( RTL_CONSTASCII_USTRINGPARAM( "SGENPRT" ) ) );
+        
+        PrinterInfo& rInfo = m_aPrinters[ aPrinter ].m_aInfo;
+        
+        rInfo.m_pParser = pNewParser;
+        rInfo.m_aContext.setParser( pNewParser );
+    }
+
+    return pNewParser;
+}
+
+void CUPSManager::setupJobContextData( JobData& rData )
+{
+#ifdef ENABLE_CUPS
+    std::hash_map< OUString, int, OUStringHash >::iterator dest_it =
+        m_aCUPSDestMap.find( rData.m_aPrinterName );
+
+    if( dest_it == m_aCUPSDestMap.end() )
+        return PrinterInfoManager::setupJobContextData( rData );
+
+    std::hash_map< OUString, Printer, OUStringHash >::iterator p_it =
+        m_aPrinters.find( rData.m_aPrinterName );
+    if( p_it == m_aPrinters.end() ) // huh ?
+    {
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "CUPS printer list in disorder, no dest for printer %s !\n", OUStringToOString( rData.m_aPrinterName, osl_getThreadTextEncoding() ).getStr() );
+#endif
+        return;
+    }
+
+    if( p_it->second.m_aInfo.m_pParser == NULL )
+    {
+        // in turn calls createCUPSParser
+        // which updates the printer info
+        p_it->second.m_aInfo.m_pParser = PPDParser::getParser( p_it->second.m_aInfo.m_aDriverName );
+    }
+    if( p_it->second.m_aInfo.m_aContext.getParser() == NULL )
+    {
+        OUString aPrinter;
+        if( p_it->second.m_aInfo.m_aDriverName.compareToAscii( "CUPS:", 5 ) == 0 )
+            aPrinter = p_it->second.m_aInfo.m_aDriverName.copy( 5 );
+        else
+            aPrinter = p_it->second.m_aInfo.m_aDriverName;
+
+        p_it->second.m_aInfo.m_aContext = m_aDefaultContexts[ aPrinter ];
+    }
+
+    rData.m_pParser		= p_it->second.m_aInfo.m_pParser;
+    rData.m_aContext	= p_it->second.m_aInfo.m_aContext;
+#endif
+}
+
+FILE* CUPSManager::startSpool( const OUString& rPrintername )
+{
+    if( m_aCUPSDestMap.find( rPrintername ) == m_aCUPSDestMap.end() )
+        return PrinterInfoManager::startSpool( rPrintername );
+    
+#ifdef ENABLE_CUPS
+    OUString aTmpURL, aTmpFile;
+    osl_createTempFile( NULL, NULL, &aTmpURL.pData );
+    osl_getSystemPathFromFileURL( aTmpURL.pData, &aTmpFile.pData );
+    OString aSysFile = OUStringToOString( aTmpFile, osl_getThreadTextEncoding() );
+    FILE* fp = fopen( aSysFile.getStr(), "w" );
+    if( fp )
+        m_aSpoolFiles[fp] = aSysFile;
+    
+    return fp;
+#else
+    return NULL;
+#endif
+}
+
+int CUPSManager::endSpool( const OUString& rPrintername, const OUString& rJobTitle, FILE* pFile )
+{
+    int nJobID = 0;
+
+    osl::MutexGuard aGuard( m_aCUPSMutex );
+    
+    std::hash_map< OUString, int, OUStringHash >::iterator dest_it =
+        m_aCUPSDestMap.find( rPrintername );
+    if( dest_it == m_aCUPSDestMap.end() )
+        return PrinterInfoManager::endSpool( rPrintername, rJobTitle, pFile );
+
+    #ifdef ENABLE_CUPS
+    std::hash_map< FILE*, OString, FPtrHash >::const_iterator it = m_aSpoolFiles.find( pFile );
+    if( it != m_aSpoolFiles.end() )
+    {
+        fclose( pFile );
+        rtl_TextEncoding aEnc = osl_getThreadTextEncoding();
+
+        cups_dest_t* pDest = ((cups_dest_t*)m_pDests) + dest_it->second;
+        nJobID = m_pCUPSWrapper->cupsPrintFile( pDest->name,
+        it->second.getStr(),
+        OUStringToOString( rJobTitle, aEnc ).getStr(),
+        0, NULL );
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "cupsPrintFile( %s, %s, %s, 0, 0 ) returns %d\n",
+        pDest->name,
+        it->second.getStr(),
+        OUStringToOString( rJobTitle, aEnc ).getStr(),
+        nJobID );
+        OString aCmd( "cp " );
+        aCmd = aCmd + it->second;
+        aCmd = aCmd + OString( " $HOME/cupsprint.ps" );
+        system( aCmd.getStr() );
+#endif
+        
+        unlink( it->second.getStr() );
+        m_aSpoolFiles.erase( pFile );
+    }
+#endif // ENABLE_CUPS
+
+    return nJobID;
+}
+
+
+void CUPSManager::changePrinterInfo( const OUString& rPrinter, const PrinterInfo& rNewInfo )
+{
+    PrinterInfoManager::changePrinterInfo( rPrinter, rNewInfo );
+}
+
+bool CUPSManager::checkPrintersChanged()
+{
+    bool bChanged = false;
+    if( m_aCUPSMutex.tryToAcquire() )
+    {
+        bChanged = m_bNewDests;
+        m_aCUPSMutex.release();
+    }
+
+    if( ! bChanged )
+        bChanged = PrinterInfoManager::checkPrintersChanged();
+    
+    if( bChanged )
+        initialize();
+
+    return bChanged;
+}
+
+bool CUPSManager::addPrinter( const OUString& rName, const OUString& rDriver )
+{
+    // don't touch the CUPS printers
+    if( m_aCUPSDestMap.find( rName ) != m_aCUPSDestMap.end() ||
+        rDriver.compareToAscii( "CUPS:", 5 ) == 0
+        )
+        return false;
+    return PrinterInfoManager::addPrinter( rName, rDriver );
+}
+
+bool CUPSManager::removePrinter( const OUString& rName, bool bCheck )
+{
+    // don't touch the CUPS printers
+    if( m_aCUPSDestMap.find( rName ) != m_aCUPSDestMap.end() )
+        return false;
+    return PrinterInfoManager::removePrinter( rName, bCheck );
+}
+
+bool CUPSManager::setDefaultPrinter( const OUString& rName )
+{
+    bool bSuccess = false;
+#ifdef ENABLE_CUPS
+    std::hash_map< OUString, int, OUStringHash >::iterator nit =
+        m_aCUPSDestMap.find( rName );
+    if( nit != m_aCUPSDestMap.end() && m_aCUPSMutex.tryToAcquire() )
+    {
+        cups_dest_t* pDests = (cups_dest_t*)m_pDests;
+        for( int i = 0; i < m_nDests; i++ )
+            pDests[i].is_default = 0;
+        pDests[ nit->second ].is_default = 1;
+        m_pCUPSWrapper->cupsSetDests( m_nDests, (cups_dest_t*)m_pDests );
+        m_aDefaultPrinter = rName;
+        m_aCUPSMutex.release();
+        bSuccess = true;
+    }
+    else
+#endif
+        PrinterInfoManager::setDefaultPrinter( rName );
+        
+    return bSuccess;
+}
+
+bool CUPSManager::writePrinterConfig()
+{
+#ifdef ENABLE_CUPS
+    bool bDestModified = false;
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+
+    for( std::hash_map< OUString, Printer, OUStringHash >::iterator prt =
+             m_aPrinters.begin(); prt != m_aPrinters.end(); ++prt )
+    {
+        std::hash_map< OUString, int, OUStringHash >::iterator nit =
+            m_aCUPSDestMap.find( prt->first );
+        if( nit == m_aCUPSDestMap.end() )
+            continue;
+        
+        if( ! prt->second.m_bModified )
+            continue;
+
+        if( m_aCUPSMutex.tryToAcquire() )
+        {
+            bDestModified = true;
+            cups_dest_t* pDest = ((cups_dest_t*)m_pDests) + nit->second;
+            PrinterInfo& rInfo = prt->second.m_aInfo;
+
+            // create new option list
+            int nNewOptions = 0;
+            cups_option_t* pNewOptions = NULL; 
+            int nValues = rInfo.m_aContext.countValuesModified();
+            for( int i = 0; i < nValues; i++ )
+            {
+                const PPDKey* pKey = rInfo.m_aContext.getModifiedKey( i );
+                const PPDValue* pValue = rInfo.m_aContext.getValue( pKey );
+                if( pKey && pValue ) // sanity check
+                {
+                    OString aName = OUStringToOString( pKey->getKey(), aEncoding );
+                    OString aValue = OUStringToOString( pValue->m_aOption, aEncoding );
+                    nNewOptions = m_pCUPSWrapper->cupsAddOption( aName.getStr(), aValue.getStr(), nNewOptions, &pNewOptions );
+                }
+            }
+            // set PPD options on CUPS dest
+            m_pCUPSWrapper->cupsFreeOptions( pDest->num_options, pDest->options );
+            pDest->num_options = nNewOptions;
+            pDest->options = pNewOptions;
+            m_aCUPSMutex.release();
+        }
+    }
+    if( bDestModified && m_aCUPSMutex.tryToAcquire() )
+    {
+        m_pCUPSWrapper->cupsSetDests( m_nDests, (cups_dest_t*)m_pDests );
+        m_aCUPSMutex.release();
+    }
+#endif // ENABLE_CUPS
+
+    return PrinterInfoManager::writePrinterConfig();
+}
+
+bool CUPSManager::addOrRemovePossible() const
+{
+    return (m_nDests && m_pDests) ? false : PrinterInfoManager::addOrRemovePossible();
+}
+
+#include <rtsname.hxx>
+
+const char* CUPSManager::authenticateUser( const char* pIn )
+{
+    const char* pRet = NULL;
+
+#ifdef ENABLE_CUPS
+    OUString aLib = OUString::createFromAscii( _XSALSET_LIBNAME );
+    oslModule pLib = osl_loadModule( aLib.pData, SAL_LOADMODULE_LAZY );
+    if( pLib )
+    {
+        OUString aSym( RTL_CONSTASCII_USTRINGPARAM( "Sal_authenticateQuery" ) );
+        bool (*getpw)( const OString& rServer, OString& rUser, OString& rPw) =
+            (bool(*)(const OString&,OString&,OString&))osl_getSymbol( pLib, aSym.pData );
+        if( getpw )
+        {
+            osl::MutexGuard aGuard( m_aCUPSMutex );
+
+            OString aUser = m_pCUPSWrapper->cupsUser();
+            OString aServer = m_pCUPSWrapper->cupsServer();
+            OString aPassword;
+            if( getpw( aServer, aUser, aPassword ) )
+            {       
+                m_aPassword = aPassword;
+                m_aUser = aUser;
+                m_pCUPSWrapper->cupsSetUser( m_aUser.getStr() );
+                pRet = m_aPassword.getStr();
+            }   	
+        }
+        osl_unloadModule( pLib );
+    }
+#if OSL_DEBUG_LEVEL > 1
+    else fprintf( stderr, "loading of module %s failed\n", OUStringToOString( aLib, osl_getThreadTextEncoding() ).getStr() );
+#endif
+#endif // ENABLE_CUPS
+
+    return pRet;
+}
Index: psprint/source/printer/jobdata.cxx
===================================================================
--- psprint/source/printer/jobdata.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/printer/jobdata.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -72,6 +72,30 @@
 using namespace psp;
 using namespace rtl;
 
+JobData& JobData::operator=(const JobData& rRight)
+{
+    m_nCopies				= rRight.m_nCopies;
+    m_nScale				= rRight.m_nScale;
+    m_nLeftMarginAdjust		= rRight.m_nLeftMarginAdjust;
+    m_nRightMarginAdjust	= rRight.m_nRightMarginAdjust;
+    m_nTopMarginAdjust		= rRight.m_nTopMarginAdjust;
+    m_nBottomMarginAdjust	= rRight.m_nBottomMarginAdjust;
+    m_nColorDepth			= rRight.m_nColorDepth;
+    m_eOrientation			= rRight.m_eOrientation;
+    m_aPrinterName			= rRight.m_aPrinterName;
+    m_pParser				= rRight.m_pParser;
+    m_aContext				= rRight.m_aContext;
+    m_nPSLevel				= rRight.m_nPSLevel;
+    m_nColorDevice			= rRight.m_nColorDevice;
+
+    if( ! m_pParser && m_aPrinterName.getLength() )
+    {
+        PrinterInfoManager& rMgr = PrinterInfoManager::get();
+        rMgr.setupJobContextData( *this );
+    }
+    return *this;
+}
+
 bool JobData::getStreamBuffer( void*& pData, int& bytes )
 {
     // consistency checks
Index: psprint/source/printer/makefile.mk
===================================================================
--- psprint/source/printer/makefile.mk.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/printer/makefile.mk	2004-10-21 14:47:18.000000000 +0100
@@ -70,6 +70,10 @@ TARGET=printer
 
 .INCLUDE :  settings.mk
 
+#.IF "$(ENABLE_CUPS)" != ""
+CDEFS += -DENABLE_CUPS
+#.ENDIF
+
 # --- Files --------------------------------------------------------
 
 .IF "$(GUIBASE)"=="aqua"
@@ -81,10 +85,19 @@ dummy:
 
 SLOFILES=\
 	$(SLO)$/printerinfomanager.obj	\
-	$(SLO)$/jobdata.obj
+	$(SLO)$/jobdata.obj				\
+	$(SLO)$/cupsmgr.obj
 
 .ENDIF # GUIBASE = aqua
 
 # --- Targets ------------------------------------------------------
 
 .INCLUDE :  target.mk
+XSALSETLIBNAME=$(DLLPRE)spa$(UPD)$(DLLPOSTFIX)$(DLLPOST)
+
+$(INCCOM)$/rtsname.hxx:
+	rm -f $(INCCOM)$/rtsname.hxx ; \
+	echo "#define _XSALSET_LIBNAME "\"$(XSALSETLIBNAME)\" > $(INCCOM)$/rtsname.hxx
+
+$(SLO)$/cupsmgr.obj : $(INCCOM)$/rtsname.hxx
+
Index: psprint/source/printer/printerinfomanager.cxx
===================================================================
--- psprint/source/printer/printerinfomanager.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/printer/printerinfomanager.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -67,11 +67,12 @@
 #include <tools/stream.hxx>
 #include <tools/debug.hxx>
 #include <tools/config.hxx>
-#include <psprint/printerinfomanager.hxx>
+#include <cupsmgr.hxx>
 #include <psprint/fontmanager.hxx>
 
 #include <osl/thread.hxx>
 #include <osl/mutex.hxx>
+#include <osl/process.h>
 
 #ifdef MACOSX
 #include <sys/stat.h>
@@ -123,17 +124,32 @@ class SystemQueueInfo : public Thread
 
 PrinterInfoManager& PrinterInfoManager::get()
 {
-    static PrinterInfoManager aManager;
+    static PrinterInfoManager* pManager = NULL;
 
-    return aManager;
+    if( ! pManager )
+    {
+        pManager = CUPSManager::tryLoadCUPS();
+        if( ! pManager )
+            pManager = new PrinterInfoManager();
+
+        if( pManager )
+            pManager->initialize();
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "PrinterInfoManager::get create Manager of type %d\n", pManager->getType() );
+#endif
+    }
+
+    return *pManager;
 }
 
 // -----------------------------------------------------------------
 
-PrinterInfoManager::PrinterInfoManager()
+PrinterInfoManager::PrinterInfoManager( Type eType ) :
+        m_pQueueInfo( NULL ),
+        m_eType( eType )
 {
-    m_pQueueInfo = new SystemQueueInfo();
-    initialize();
+    if( eType == Default )
+        m_pQueueInfo = new SystemQueueInfo();
 }
 
 // -----------------------------------------------------------------
@@ -172,7 +188,7 @@ bool PrinterInfoManager::checkPrintersCh
             }
         }
     }
-    if( ! bChanged )
+    if( ! bChanged && m_pQueueInfo )
         bChanged = m_pQueueInfo->hasChanged();
     if( bChanged )
     {
@@ -183,7 +199,7 @@ bool PrinterInfoManager::checkPrintersCh
         sal_Int32    applePrintSystem;
 
         applePrintSystem = macxp_GetSystemPrintMethod();
-        if ( (applePrintSystem == kApplePrintingCUPS) || (applePrintSystem == kApplePrintingNewCUPS) )
+        if ( applePrintSystem == kApplePrintingCUPS )
         {
             m_aSystemPrintQueues.clear();
             delete m_pQueueInfo;
@@ -254,8 +270,12 @@ void PrinterInfoManager::initialize()
             m_aGlobalDefaults.m_eOrientation = aValue.EqualsIgnoreCaseAscii( "Landscape" ) ? orientation::Landscape : orientation::Portrait;
 
             aValue = aConfig.ReadKey( "Scale" );
-		  if ( aValue.Len() )
+            if( aValue.Len() )
+            {
                 m_aGlobalDefaults.m_nScale = aValue.ToInt32();
+                if( (m_aGlobalDefaults.m_nScale < 1) || (m_aGlobalDefaults.m_nScale > 1000) )
+                    m_aGlobalDefaults.m_nScale = 100;
+            }
 
             aValue = aConfig.ReadKey( "MarginAdjust" );
             m_aGlobalDefaults.m_nLeftMarginAdjust   = aValue.GetToken( 0, ',' ).ToInt32();
@@ -300,6 +320,7 @@ void PrinterInfoManager::initialize()
                     m_aGlobalDefaults.m_aFontSubstitutes[ OStringToOUString( aKey.Copy( 10 ), RTL_TEXTENCODING_ISO_8859_1 ) ] = OStringToOUString( aValue, RTL_TEXTENCODING_ISO_8859_1 );
                 }
             }
+            setDefaultPaper( m_aGlobalDefaults );
 #if OSL_DEBUG_LEVEL > 1
             fprintf( stderr, "global settings: fontsubst = %s, %d substitutes\n", m_aGlobalDefaults.m_bPerformFontSubstitution ? "true" : "false", m_aGlobalDefaults.m_aFontSubstitutes.size() );
 #endif
@@ -313,7 +334,7 @@ void PrinterInfoManager::initialize()
     // notified of queue/printer updates, but these don't necessarily
     // happen when psprint.conf changes.  The user can change settings in
     // the Print Center which should also make OOo update its queue list.
-    if ( (applePrintSystem == kApplePrintingCUPS) || (applePrintSystem == kApplePrintingNewCUPS) )
+    if ( applePrintSystem == kApplePrintingCUPS )
     {
         // /etc/cups/printers.conf gets modified every time the Print Center printer
         // list is modified, so we want to watch this file too.
@@ -415,62 +436,71 @@ void PrinterInfoManager::initialize()
                 aPrinterName = String( aValue.Copy( nNamePos+1 ), RTL_TEXTENCODING_UTF8 );
                 aPrinter.m_aInfo.m_aPrinterName     = aPrinterName;
                 aPrinter.m_aInfo.m_aDriverName      = String( aValue.Copy( 0, nNamePos ), RTL_TEXTENCODING_UTF8 );
-                aPrinter.m_aInfo.m_pParser          = PPDParser::getParser( aPrinter.m_aInfo.m_aDriverName );
-                aPrinter.m_aInfo.m_aContext.setParser( aPrinter.m_aInfo.m_pParser );
-                // note: setParser also purges the context
-
-                // ignore this printer if its driver is not found
-                if( ! aPrinter.m_aInfo.m_pParser )
-                    continue;
 
-                // merge the ppd context keys if the printer has the same keys and values
-                // this is a bit tricky, since it involves mixing two PPDs
-                // without constraints which might end up badly
-                // this feature should be use with caution
-                // it is mainly to select default paper sizes for new printers
-                for( int nPPDValueModified = 0; nPPDValueModified < m_aGlobalDefaults.m_aContext.countValuesModified(); nPPDValueModified++ )
+                // set parser, merge settings
+                // don't do this for CUPS printers as this is done
+                // by the CUPS system itself
+                if( aPrinter.m_aInfo.m_aDriverName.compareToAscii( "CUPS:", 5 ) != 0 )
                 {
-                    const PPDKey* pDefKey = m_aGlobalDefaults.m_aContext.getModifiedKey( nPPDValueModified );
-                    const PPDValue* pDefValue = m_aGlobalDefaults.m_aContext.getValue( pDefKey );
-                    const PPDKey* pPrinterKey = pDefKey ? aPrinter.m_aInfo.m_pParser->getKey( pDefKey->getKey() ) : NULL;
-                    if( pDefKey && pPrinterKey )
-                        // at least the options exist in both PPDs
+                    aPrinter.m_aInfo.m_pParser          = PPDParser::getParser( aPrinter.m_aInfo.m_aDriverName );
+                    aPrinter.m_aInfo.m_aContext.setParser( aPrinter.m_aInfo.m_pParser );
+                    // note: setParser also purges the context
+
+                    // ignore this printer if its driver is not found
+                    if( ! aPrinter.m_aInfo.m_pParser )
+                        continue;
+
+                    // merge the ppd context keys if the printer has the same keys and values
+                    // this is a bit tricky, since it involves mixing two PPDs
+                    // without constraints which might end up badly
+                    // this feature should be use with caution
+                    // it is mainly to select default paper sizes for new printers
+                    for( int nPPDValueModified = 0; nPPDValueModified < m_aGlobalDefaults.m_aContext.countValuesModified(); nPPDValueModified++ )
                     {
-                        if( pDefValue )
+                        const PPDKey* pDefKey = m_aGlobalDefaults.m_aContext.getModifiedKey( nPPDValueModified );
+                        const PPDValue* pDefValue = m_aGlobalDefaults.m_aContext.getValue( pDefKey );
+                        const PPDKey* pPrinterKey = pDefKey ? aPrinter.m_aInfo.m_pParser->getKey( pDefKey->getKey() ) : NULL;
+                        if( pDefKey && pPrinterKey )
+                            // at least the options exist in both PPDs
                         {
-                            const PPDValue* pPrinterValue = pPrinterKey->getValue( pDefValue->m_aOption );
-                            if( pPrinterValue )
-                                // the printer has a corresponding option for the key
-                                aPrinter.m_aInfo.m_aContext.setValue( pPrinterKey, pPrinterValue );
-                        }
+                            if( pDefValue )
+                            {
+                                const PPDValue* pPrinterValue = pPrinterKey->getValue( pDefValue->m_aOption );
+                                if( pPrinterValue )
+                                    // the printer has a corresponding option for the key
+                                    aPrinter.m_aInfo.m_aContext.setValue( pPrinterKey, pPrinterValue );
+                            }
                         else
                             aPrinter.m_aInfo.m_aContext.setValue( pPrinterKey, NULL );
+                        }
                     }
-                }
 
-                aValue = aConfig.ReadKey( "Command" );
-                // no printer without a command
-                if( ! aValue.Len() )
-                {
-                    /*  TODO:
-                     *  porters: please append your platform to the Solaris
-                     *  case if your platform has SystemV printing per default.
-                     */
+                    aValue = aConfig.ReadKey( "Command" );
+                    // no printer without a command
+                    if( ! aValue.Len() )
+                    {
+                        /*  TODO:
+                         *  porters: please append your platform to the Solaris
+                         *  case if your platform has SystemV printing per default.
+                         */
 #if defined SOLARIS || defined(IRIX)
-                    aValue = "lp";
-#elif defined(MACOSX)
-                    if ( (applePrintSystem == kApplePrintingCUPS ) || (applePrintSystem == kApplePrintingNewCUPS) )
                         aValue = "lp";
-                    else
-                    {
-                        // Fallback case is kApplePrintingLPR
-                        aValue = "lpr";
-                    }
+#elif defined(MACOSX)
+                        if ( applePrintSystem == kApplePrintingCUPS )
+                            aValue = "lp";
+                        else if ( applePrintSystem == kApplePrintingPrintCenter )
+                            aValue = kApplePCPrintCommand;
+                        else
+                        {
+                            // Fallback case is kApplePrintingLPR
+                            aValue = "lpr";
+                        }
 #else
-                    aValue = "lpr";
+                        aValue = "lpr";
 #endif
+                    }
+                    aPrinter.m_aInfo.m_aCommand = String( aValue, RTL_TEXTENCODING_UTF8 );
                 }
-                aPrinter.m_aInfo.m_aCommand = String( aValue, RTL_TEXTENCODING_UTF8 );
 
                 aValue = aConfig.ReadKey( "Features" );
                 aPrinter.m_aInfo.m_aFeatures = String( aValue, RTL_TEXTENCODING_UTF8 );
@@ -496,7 +526,11 @@ void PrinterInfoManager::initialize()
 
                 aValue = aConfig.ReadKey( "Scale" );
                 if( aValue.Len() )
+                {
                     aPrinter.m_aInfo.m_nScale = aValue.ToInt32();
+                    if( (aPrinter.m_aInfo.m_nScale < 1) || (aPrinter.m_aInfo.m_nScale > 1000) )
+                        aPrinter.m_aInfo.m_nScale = 100;
+                }                
 
                 aValue = aConfig.ReadKey( "MarginAdjust" );
                 if( aValue.Len() )
@@ -531,7 +565,7 @@ void PrinterInfoManager::initialize()
                 for( int nKey = 0; nKey < aConfig.GetKeyCount(); nKey++ )
                 {
                     ByteString aKey( aConfig.GetKeyName( nKey ) );
-                    if( aKey.CompareTo( "PPD_", 4 ) == COMPARE_EQUAL )
+                    if( aKey.CompareTo( "PPD_", 4 ) == COMPARE_EQUAL && aPrinter.m_aInfo.m_pParser )
                     {
                         aValue = aConfig.ReadKey( aKey );
                         const PPDKey* pKey = aPrinter.m_aInfo.m_pParser->getKey( String( aKey.Copy( 4 ), RTL_TEXTENCODING_ISO_8859_1 ) );
@@ -550,6 +584,7 @@ void PrinterInfoManager::initialize()
                     }
                 }
 
+                setDefaultPaper( aPrinter.m_aInfo );
                 fillFontSubstitutions( aPrinter.m_aInfo );
 
                 // finally insert printer
@@ -578,6 +613,9 @@ void PrinterInfoManager::initialize()
         aDefaultPrinter = OUString();
     m_aDefaultPrinter = aDefaultPrinter;
 
+    if( m_eType != Default )
+        return;
+
     // add a default printer for every available print queue
     // merge paper and font substitution from default printer,
     // all else from global defaults
@@ -628,7 +666,7 @@ void PrinterInfoManager::initialize()
         // is associated with from /etc/cups/ppd (it's autocreated by the OS X printing system) and
         // use those values instead of the ones generated in the merged defaults.  We want to make
         // this system printer just like we assigned it a PPD in padmin.
-        if ( (applePrintSystem == kApplePrintingCUPS) || (applePrintSystem == kApplePrintingNewCUPS) )
+        if ( applePrintSystem == kApplePrintingCUPS )
         {
             aPrinter.m_aInfo.m_aFontSubstitutes.clear();
             aPrinter.m_aInfo.m_aFontSubstitutions.clear();
@@ -896,16 +934,19 @@ bool PrinterInfoManager::writePrinterCon
             aValue += ByteString::CreateFromInt32( it->second.m_aInfo.m_nBottomMarginAdjust );
             pConfig->WriteKey( "MarginAdjust", aValue );
 
-            // write PPDContext
-            for( int i = 0; i < it->second.m_aInfo.m_aContext.countValuesModified(); i++ )
+            if( it->second.m_aInfo.m_aDriverName.compareToAscii( "CUPS:", 5 ) != 0 )
             {
-                const PPDKey* pKey = it->second.m_aInfo.m_aContext.getModifiedKey( i );
-                ByteString aKey( "PPD_" );
-                aKey += ByteString( pKey->getKey(), RTL_TEXTENCODING_ISO_8859_1 );
-
-                const PPDValue* pValue = it->second.m_aInfo.m_aContext.getValue( pKey );
-                aValue = pValue ? ByteString( pValue->m_aOption, RTL_TEXTENCODING_ISO_8859_1 ) : ByteString( "*nil" );
-                pConfig->WriteKey( aKey, aValue );
+                // write PPDContext (not for CUPS)
+                for( int i = 0; i < it->second.m_aInfo.m_aContext.countValuesModified(); i++ )
+                {
+                    const PPDKey* pKey = it->second.m_aInfo.m_aContext.getModifiedKey( i );
+                    ByteString aKey( "PPD_" );
+                    aKey += ByteString( pKey->getKey(), RTL_TEXTENCODING_ISO_8859_1 );
+                    
+                    const PPDValue* pValue = it->second.m_aInfo.m_aContext.getValue( pKey );
+                    aValue = pValue ? ByteString( pValue->m_aOption, RTL_TEXTENCODING_ISO_8859_1 ) : ByteString( "*nil" );
+                    pConfig->WriteKey( aKey, aValue );
+                }
             }
 
             // write font substitution table
@@ -968,6 +1009,14 @@ bool PrinterInfoManager::addPrinter( con
 
         m_aPrinters[ rPrinterName ] = aPrinter;
         bSuccess = true;
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "new printer %s, level = %d, scale = %d, colordevice = %d, depth = %d\n",
+                 OUStringToOString( rPrinterName, osl_getThreadTextEncoding() ).getStr(),
+                 m_aPrinters[rPrinterName].m_aInfo.m_nPSLevel,
+                 m_aPrinters[rPrinterName].m_aInfo.m_nScale,
+                 m_aPrinters[rPrinterName].m_aInfo.m_nColorDevice,
+                 m_aPrinters[rPrinterName].m_aInfo.m_nColorDepth );
+#endif
     }
     return bSuccess;
 }
@@ -1045,6 +1094,12 @@ bool PrinterInfoManager::setDefaultPrint
 }
 
 // -----------------------------------------------------------------
+bool PrinterInfoManager::addOrRemovePossible() const
+{
+    return true;
+}
+
+// -----------------------------------------------------------------
 
 void PrinterInfoManager::fillFontSubstitutions( PrinterInfo& rInfo ) const
 {
@@ -1118,7 +1173,7 @@ void PrinterInfoManager::fillFontSubstit
                 if( nSubstitute != -1 )
                 {
                     rInfo.m_aFontSubstitutions[ it->m_nID ] = nSubstitute;
-#if OSL_DEBUG_LEVEL > 1
+#if OSL_DEBUG_LEVEL > 2
                     FastPrintFontInfo aInfo;
                     rFontManager.getFontFastInfo( nSubstitute, aInfo );
                     fprintf( stderr,
@@ -1145,7 +1200,7 @@ void PrinterInfoManager::fillFontSubstit
 
 void PrinterInfoManager::getSystemPrintCommands( std::list< OUString >& rCommands )
 {
-    if( m_pQueueInfo->hasChanged() )
+    if( m_pQueueInfo && m_pQueueInfo->hasChanged() )
     {
         m_aSystemPrintCommand = m_pQueueInfo->getCommand();
         m_pQueueInfo->getSystemQueues( m_aSystemPrintQueues );
@@ -1164,7 +1219,7 @@ void PrinterInfoManager::getSystemPrintC
 
 const std::list< OUString >& PrinterInfoManager::getSystemPrintQueues()
 {
-    if( m_pQueueInfo->hasChanged() )
+    if( m_pQueueInfo && m_pQueueInfo->hasChanged() )
     {
         m_aSystemPrintCommand = m_pQueueInfo->getCommand();
         m_pQueueInfo->getSystemQueues( m_aSystemPrintQueues );
@@ -1173,6 +1228,117 @@ const std::list< OUString >& PrinterInfo
     return m_aSystemPrintQueues;
 }
 
+FILE* PrinterInfoManager::startSpool( const OUString& rPrintername )
+{
+    const PrinterInfo&   rPrinterInfo	= getPrinterInfo (rPrintername);
+    const rtl::OUString& rCommand		= rPrinterInfo.m_aCommand;
+    rtl::OString aShellCommand	= OUStringToOString (rCommand, RTL_TEXTENCODING_ISO_8859_1);
+    aShellCommand += rtl::OString( " 2>/dev/null" );
+
+    return popen (aShellCommand.getStr(), "w");
+}
+
+int PrinterInfoManager::endSpool( const OUString& rPrintername, const OUString& rJobTitle, FILE* pFile )
+{
+    pclose( pFile );
+    return 0; // job id ?
+}
+
+void PrinterInfoManager::setupJobContextData( JobData& rData )
+{
+    std::hash_map< OUString, Printer, OUStringHash >::iterator it =
+        m_aPrinters.find( rData.m_aPrinterName );
+    if( it != m_aPrinters.end() )
+    {
+        rData.m_pParser		= it->second.m_aInfo.m_pParser;
+        rData.m_aContext	= it->second.m_aInfo.m_aContext;
+    }
+}
+
+void PrinterInfoManager::setDefaultPaper( PrinterInfo& rInfo ) const
+{
+    if( ! rInfo.m_pParser || ! rInfo.m_aContext.getParser() )
+        return;
+ 
+    const PPDKey* pPageSizeKey = rInfo.m_pParser->getKey( String( RTL_CONSTASCII_USTRINGPARAM( "PageSize" ) ) );
+    if( ! pPageSizeKey )
+        return;
+    
+    int nModified = rInfo.m_aContext.countValuesModified();
+    while( nModified-- &&
+        rInfo.m_aContext.getModifiedKey( nModified ) != pPageSizeKey )
+    ;
+    
+    if( nModified >= 0 ) // paper was set already, do not modify
+    {
+        #if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "not setting default paper, already set %s\n",
+            OUStringToOString( rInfo.m_aContext.getValue( pPageSizeKey )->m_aOption, RTL_TEXTENCODING_ISO_8859_1 ).getStr() );
+        #endif
+        return;
+    }
+    
+    // paper not set, fill in default value
+    // default value is Letter for US (en_US), Cannada (en_CA, fr_CA); else A4
+    // en will be interpreted as en_US
+    const PPDValue* pPaperVal = NULL;
+
+    // check for LC_PAPER
+    const char* pPaperLang = getenv( "LC_PAPER" );
+    if( pPaperLang && *pPaperLang )
+    {
+        OString aLang( pPaperLang );
+        if( aLang.getLength() > 5 )
+            aLang = aLang.copy( 0, 5 );
+        if( aLang.getLength() == 5 )
+        {
+            if(    aLang.equalsIgnoreAsciiCase( "en_us" )
+                || aLang.equalsIgnoreAsciiCase( "en_ca" )
+                || aLang.equalsIgnoreAsciiCase( "fr_ca" )
+                )
+                pPaperVal = pPageSizeKey->getValue( String( RTL_CONSTASCII_USTRINGPARAM( "Letter" ) ) );
+            else
+                pPaperVal = pPageSizeKey->getValue( String( RTL_CONSTASCII_USTRINGPARAM( "A4" ) ) );
+        }
+        else if( aLang.getLength() == 2 && aLang.equalsIgnoreAsciiCase( "en" ) )
+            pPaperVal = pPageSizeKey->getValue( String( RTL_CONSTASCII_USTRINGPARAM( "Letter" ) ) );
+        else
+            pPaperVal = pPageSizeKey->getValue( String( RTL_CONSTASCII_USTRINGPARAM( "A4" ) ) );
+    }
+    
+    // use process locale to determine paper
+    if( !pPaperVal )
+    {
+        rtl_Locale* pLoc = NULL;
+        osl_getProcessLocale( &pLoc );
+        if( pLoc )
+        {
+            pPaperVal = pPageSizeKey->getValue( String( RTL_CONSTASCII_USTRINGPARAM( "A4" ) ) );
+            if( 0 == rtl_ustr_ascii_compareIgnoreAsciiCase_WithLength( pLoc->Language->buffer, pLoc->Language->length, "en") )
+            {
+                if(    0 == rtl_ustr_ascii_compareIgnoreAsciiCase_WithLength( pLoc->Country->buffer, pLoc->Country->length, "us")
+                    || 0 == rtl_ustr_ascii_compareIgnoreAsciiCase_WithLength( pLoc->Country->buffer, pLoc->Country->length, "ca")
+                    || pLoc->Country->length == 0
+                    )
+                    pPaperVal = pPageSizeKey->getValue( String( RTL_CONSTASCII_USTRINGPARAM( "Letter" ) ) );
+            }
+            else if( 0 == rtl_ustr_ascii_compareIgnoreAsciiCase_WithLength( pLoc->Language->buffer, pLoc->Language->length, "fr") )
+            {
+                if( 0 == rtl_ustr_ascii_compareIgnoreAsciiCase_WithLength( pLoc->Country->buffer, pLoc->Country->length, "ca") )
+                    pPaperVal = pPageSizeKey->getValue( String( RTL_CONSTASCII_USTRINGPARAM( "Letter" ) ) );
+            }
+        }
+    }
+    
+    if( pPaperVal )
+    {
+        #if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "setting default paper %s\n", OUStringToOString( pPaperVal->m_aOption, RTL_TEXTENCODING_ISO_8859_1 ).getStr() );
+        #endif
+        rInfo.m_aContext.setValue( pPageSizeKey, pPaperVal );
+    }
+}
+
 // -----------------------------------------------------------------
 
 SystemQueueInfo::SystemQueueInfo() :
@@ -1213,7 +1379,7 @@ struct SystemCommandParameters
     const char*		pPrintCommand;
     const char*		pForeToken;
     const char*		pAftToken;
-    int					nForeTokenCount;
+    unsigned int	nForeTokenCount;
 };
 
 static const struct SystemCommandParameters aParms[] =
@@ -1227,11 +1393,11 @@ static const struct SystemCommandParamet
      * printerinfomanager.hxx and are indexed by those constants.  ORDER IS IMPORTANT!!!
 	*/
     /* Apple LPR printing (kApplePrintingLPR) */
-    { "/usr/sbin/lpc status", "lpr -P (PRINTER)", "", ":", 0 },
+    { "/usr/bin/lpc status", "lpr -P (PRINTER)", "", ":", 0 },
     /* Apple CUPS printing (kApplePrintingCUPS) */
     { "LANG=C;LC_ALL=C;export LANG LC_ALL;/usr/bin/lpstat -s", "lp -d (PRINTER)", "device for ", ": ", 1 },
-    /* Apple New CUPS printing (kApplePrintingCUPS) */
-    { "LANG=C;LC_ALL=C;export LANG LC_ALL;/usr/bin/lpstat -s", "lp -d (PRINTER)", "device for ", ": ", 1 },
+    /* Apple Print Center printing (kApplePrintingPrintCenter) */
+    { kApplePCQueueName, kApplePCPrintCommand, "", ":", 0 }
 #else
     { "LANG=C;LC_ALL=C;export LANG LC_ALL;lpstat -s", "lp -d \"(PRINTER)\"", "system for ", ": ", 1 },
     { "/usr/sbin/lpc status", "lpr -P \"(PRINTER)\"", "", ":", 0 },
@@ -1241,19 +1407,9 @@ static const struct SystemCommandParamet
 
 void SystemQueueInfo::run()
 {
-
-#ifdef MACOSX
-    // FIXME: revisit this to see why MacOSX needs to grab the mutex earlier
-    // Workaround to allow MacOSX print queue detection to work
-    // Must grab the mutex as early as possible to make
-    // sure that run() actually runs before hasChanged() or
-    // getSystemQueues() get called by the PrinterInfoManager
-    MutexGuard aGuard( m_aMutex );
-#endif
-
     char pBuffer[1024];
     ByteString aPrtQueueCmd, aForeToken, aAftToken, aString;
-    int nForeTokenCount, i;
+    unsigned int nForeTokenCount = 0, i;
     FILE *pPipe;
     bool bSuccess = false;
     std::list< ByteString > aLines;
@@ -1279,8 +1435,25 @@ void SystemQueueInfo::run()
 #if OSL_DEBUG_LEVEL > 1
         fprintf( stderr, "trying print queue command \"%s\" ... ", aParms[i].pQueueCommand );
 #endif
+#ifdef MACOSX
+        /* For Mac OS X 10.1 Print Center printing, we only use the default queue.  We do not
+         * need to discover it.  So when it comes up in the list of possible queues,
+         * recognize it and declare success.
+         */
+        if ( applePrintSysType == kApplePrintingPrintCenter )
+        {
+            if ( strstr(aPrtQueueCmd.GetBuffer(), kApplePCQueueName) != NULL )
+                bSuccess = TRUE;
+#ifdef DEBUG
+            else
+                fprintf( stderr, "Ignoring print queue command \"%s\" because using 10.1 Print Center printing.\n", aParms[i].pQueueCommand );
+#endif
+        }
+        else
+#endif
         {
-            if( pPipe = popen( aPrtQueueCmd.GetBuffer(), "r" ) )
+			aPrtQueueCmd += ByteString( " 2>/dev/null" );	
+            if( (pPipe = popen( aPrtQueueCmd.GetBuffer(), "r" )) )
             {
                 while( fgets( pBuffer, 1024, pPipe ) )
                     aLines.push_back( ByteString( pBuffer ) );
@@ -1293,7 +1466,27 @@ void SystemQueueInfo::run()
 #endif
     }
 
-   {
+#ifdef MACOSX
+    /* Since we only print to the default printer for MacOS X 10.1,
+     * queue discovery serves no purpose.
+     */
+    if ( applePrintSysType == kApplePrintingPrintCenter )
+    {
+        std::list< OUString > aSysPrintQueues;
+
+        aSysPrintQueues.push_back( OUString::createFromAscii(kApplePCQueueName) );
+      #ifdef DEBUG
+        fprintf( stderr, "printerinfomanager.cxx: using Print Center default print queue.\n" );
+      #endif
+
+        MutexGuard aGuard( m_aMutex );
+        m_bChanged	= true;
+        m_aQueues	= aSysPrintQueues;
+        m_aCommand	= aPrintCommand;
+    }
+    else
+#endif	/* MACOSX */
+    {
         /* Normal Unix print queue discovery, also used for Darwin 5 LPR printing
          * and MacOS X 10.2/Darwin 6 CUPS printing.
          */
@@ -1308,7 +1501,7 @@ void SystemQueueInfo::run()
                 ByteString aOutLine( aLines.front() );
                 aLines.pop_front();
             
-                for( int i = 0; i < nForeTokenCount && nPos != STRING_NOTFOUND; i++ )
+                for( i = 0; i < nForeTokenCount && nPos != STRING_NOTFOUND; i++ )
                 {
                     nPos = aOutLine.Search( aForeToken, nPos );
                     if( nPos != STRING_NOTFOUND && aOutLine.Len() >= nPos+aForeToken.Len() )
@@ -1330,11 +1523,7 @@ void SystemQueueInfo::run()
                 }
             }
         
-#ifndef MACOSX
-            // FIXME: revisit this to see why MacOSX needs to grab the mutex earlier
-            // A specific MacOSX workaround grabbed this Mutex earlier so do not regrab
             MutexGuard aGuard( m_aMutex );
-#endif
             m_bChanged	= true;
             m_aQueues	= aSysPrintQueues;
             m_aCommand	= aPrintCommand;
@@ -1346,10 +1535,13 @@ void SystemQueueInfo::run()
 
 /* On Apple systems printing gets more complicated...
  * 1)  Darwin 5:     use straight lpr system, user has to configure lpr correctly
- * 2)  MacOS X 10.2: use CUPS duo of lpstat/lp
- * 3)  Darwin 6:     Like MacOS X 10.2, use CUPS
- * 4)  MacOS X 10.3:use New CUPS and duo lpstat/lp 
- * 5)  Darwin 7: Like MacOS X 10.3
+ * 2)  MacOS X 10.1: use /usr/sbin/Print which prints to default Print Center printer
+ * 3)  MacOS X 10.2: use CUPS duo of lpstat/lp
+ * 4)  Darwin 6:     Like MacOS X 10.2, use CUPS
+ *
+ * --- FIXME ---   We don't support printer choosing on MacOS X 10.1 at this time,
+ *                 only printing to default Print Center printer.  The user can
+ *                 change the default Print Center printer at any point however.
  */
 
 /*
@@ -1357,8 +1549,11 @@ void SystemQueueInfo::run()
  *
  * Find out which printing system/OS we are using.
  *
- * Darwin 5 is the fallback case.  For 10.2/Darwin 6, we attempt to find lpstat.
- * For 10.3/Darwin 7, we attempt to fid pstopdf
+ * Darwin 5 is the fallback case.  To check for 10.1 printing we try to see if
+ * /usr/sbin/Print exists.  For 10.2/Darwin 6, we attempt to find lpstat.  Users
+ * might also have installed CUPS on Darwin 5 or MacOS X 10.1, but we default to
+ * Print Center (/usr/sbin/Print) printing on 10.1.
+ *
  */
 sal_Int32 macxp_GetSystemPrintMethod( void )
 {
@@ -1369,13 +1564,13 @@ sal_Int32 macxp_GetSystemPrintMethod( vo
      /* Attempt to find out which OS we are on... */
      applePrintSysType = kApplePrintingLPR;
 	
-     /* Check for MacOS X 10.3 and later CUPS first. */
-     err = stat( "/usr/bin/pstopdf", &status );
+     /* Check for MacOS X 10.1 first. */
+     err = stat( "/usr/sbin/Print", &status );
      if ( err == 0 )
      {
-          applePrintSysType = kApplePrintingNewCUPS;
+          applePrintSysType = kApplePrintingPrintCenter;
           #ifdef DEBUG
-               fprintf( stderr, "printerinfomanager.cxx:  found MacOS X 10.3 or later type printing system.\n" );
+               fprintf( stderr, "printerinfomanager.cxx:  found MacOS X 10.1-type printing system.\n" );
           #endif
      }
      else
@@ -1399,6 +1594,7 @@ sal_Int32 macxp_GetSystemPrintMethod( vo
      return( applePrintSysType );
 }
 
+#if 0
 /*
  * macxp_GetSystemPrintFormat()
  *
@@ -1412,7 +1608,7 @@ sal_Int32 macxp_GetSystemPrintMethod( vo
  * therefore the environment variable OOO_PRINT_PS_DIRECTLY, if set,
  * forces OOo to NOT undergo the PS -> PDF translation by default.
  */
-/*sal_Int32 macxp_GetSystemPrintFormat( void )
+sal_Int32 macxp_GetSystemPrintFormat( void )
 {
      int			printFormat;
      int			err;
@@ -1423,15 +1619,15 @@ sal_Int32 macxp_GetSystemPrintMethod( vo
 	
      /* Check for presence of OSAScript executable, which is
       * believed to be MacOS X only (ie not present on Darwin).
-      *
+      */
      err = stat( "/usr/bin/osascript", &status );
      if ( err == 0 )
      {
-          /* Check to see if the user wants to print PS anyway *
+         /* Check to see if the user wants to print PS anyway */
           pPDFOverride = getenv( "OOO_PRINT_PS_DIRECTLY" );
           if ( pPDFOverride == NULL )
           {
-               /* Now we have to check for ps2pdf to make sure we can do the conversion *
+          /* Now we have to check for ps2pdf to make sure we can do the conversion */
                err = stat( kApplePS2PDFLocation, &status );
                if ( err == 0 )
                {
@@ -1444,6 +1640,7 @@ sal_Int32 macxp_GetSystemPrintMethod( vo
      }
 	
      return( printFormat );
-}*/
+}
+#endif
 #endif
 
Index: psprint/source/printergfx/bitmap_gfx.cxx
===================================================================
--- psprint/source/printergfx/bitmap_gfx.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/printergfx/bitmap_gfx.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -71,8 +71,8 @@
 
 namespace psp {
 
-const sal_Int32 nLineLength = 80;
-const sal_Int32 nBufferSize = 16384;
+const sal_uInt32 nLineLength = 80;
+const sal_uInt32 nBufferSize = 16384;
 
 /*
  * 
@@ -197,9 +197,9 @@ public:
 
 Ascii85Encoder::Ascii85Encoder (osl::File* pFile) :
         mpFile (pFile),
-        mnOffset (0),
+        mnByte (0),
         mnColumn (0),
-        mnByte (0)
+        mnOffset (0)
 {}
 
 inline void
@@ -591,13 +591,14 @@ PrinterGfx::writePS2ImageHeader (const R
     sal_Int32 nChar = 0;
     sal_Char  pImage [512];
 
-    sal_Int32 nDictType;
+    sal_Int32 nDictType = 0;
     switch (nType)
     {
         case psp::TrueColorImage:  nDictType = 0; break;
         case psp::PaletteImage:    nDictType = 1; break;
         case psp::GrayScaleImage:  nDictType = 2; break;
         case psp::MonochromeImage: nDictType = 3; break;
+        default: break;
     }
     sal_Int32 nCompressType = mbCompressBmp ? 1 : 0;
 
@@ -630,14 +631,15 @@ PrinterGfx::writePS2Colorspace(const Pri
 
         case psp::MonochromeImage: 
         case psp::PaletteImage:
+        {
 
             sal_Int32 nChar = 0;
             sal_Char  pImage [4096];
 
-            sal_Int32 nSize = rBitmap.GetPaletteEntryCount() - 1;
+            const sal_uInt32 nSize = rBitmap.GetPaletteEntryCount();
 
             nChar += psp::appendStr ("[/Indexed /DeviceRGB ", pImage + nChar);
-            nChar += psp::getValueOf (rBitmap.GetPaletteEntryCount() - 1, pImage + nChar);
+            nChar += psp::getValueOf (nSize - 1, pImage + nChar);
             if (mbCompressBmp)
                 nChar += psp::appendStr ("\npsp_lzwstring\n", pImage + nChar);
             else
@@ -646,7 +648,7 @@ PrinterGfx::writePS2Colorspace(const Pri
 
             ByteEncoder* pEncoder = mbCompressBmp ? new LZWEncoder(mpPageBody) 
                                                   : new Ascii85Encoder(mpPageBody);
-            for (sal_Int32 i = 0; i < rBitmap.GetPaletteEntryCount(); i++)
+            for (sal_uInt32 i = 0; i < nSize; i++)
             {
                 PrinterColor aColor = rBitmap.GetPaletteColor(i);
 
@@ -657,8 +659,9 @@ PrinterGfx::writePS2Colorspace(const Pri
             delete pEncoder;
           
             WritePS (mpPageBody, "pop ] setcolorspace\n");
-  
-            break;
+        }
+        break;
+        default: break;
     }
 }
 
Index: psprint/source/printergfx/common_gfx.cxx
===================================================================
--- psprint/source/printergfx/common_gfx.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/printergfx/common_gfx.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -94,7 +94,9 @@ static const sal_Int32 nMaxTextColumn = 
 GraphicsStatus::GraphicsStatus() :
         mnTextHeight( 0 ),
         mnTextWidth( 0 ),
-        mfLineWidth( -1 )
+        mfLineWidth( -1 ),
+        mbArtItalic( false ),
+        mbArtBold( false )
 {
 }
 
@@ -131,8 +133,8 @@ PrinterGfx::Init (const JobData& rData)
     mpPageHeader    = NULL;
     mpPageBody      = NULL;
     mnDepth         = rData.m_nColorDepth;
-    mnPSLevel       = rData.m_nPSLevel ? rData.m_nPSLevel : rData.m_pParser->getLanguageLevel();
-    mbColor         = rData.m_nColorDevice ? ( rData.m_nColorDevice == -1 ? sal_False : sal_True ) : ( rData.m_pParser->isColorDevice() ? sal_True : sal_False );
+    mnPSLevel       = rData.m_nPSLevel ? rData.m_nPSLevel : (rData.m_pParser ? rData.m_pParser->getLanguageLevel() : 2 );
+    mbColor         = rData.m_nColorDevice ? ( rData.m_nColorDevice == -1 ? sal_False : sal_True ) : (( rData.m_pParser ?  (rData.m_pParser->isColorDevice() ? sal_True : sal_False ) : sal_True ) );
     int nRes = rData.m_aContext.getRenderResolution();
     mnDpi           = nRes;
     mfScaleX        = (double)72.0 / (double)mnDpi;
@@ -174,12 +176,13 @@ PrinterGfx::PrinterGfx() : 
         mpPageBody (NULL),
         mnFontID (0),
         mnFallbackID (0),
-        maLineColor (0, 0xff, 0),
-        maFillColor (0xff,0,0),
-        maTextColor (0,0,0),
+        mnTextAngle (0),
         mbTextVertical (false),
         mrFontMgr (PrintFontManager::get()),
         mbCompressBmp (sal_True),
+        maFillColor (0xff,0,0),
+        maTextColor (0,0,0),
+        maLineColor (0, 0xff, 0),
         mpFontSubstitutes( NULL )
 {
     maVirtualStatus.mfLineWidth = 1.0;
@@ -489,7 +492,7 @@ PrinterGfx::DrawPolygon (sal_uInt32 nPoi
         
     PSBinStartPath();
     PSBinMoveTo( pPath[0], aPoint, nColumn );
-    for( int n = 1; n < nPoints; n++ )
+    for( unsigned int n = 1; n < nPoints; n++ )
         PSBinLineTo( pPath[n], aPoint, nColumn );
     if( pPath[0] != pPath[nPoints-1] )
         PSBinLineTo( pPath[0], aPoint, nColumn );
@@ -531,14 +534,14 @@ PrinterGfx::DrawPolyPolygon (sal_uInt32 
 
 
     // setup closed path
-    for( int i = 0; i < nPoly; i++ )
+    for( unsigned int i = 0; i < nPoly; i++ )
     {
         Point aPoint( 0, 0 );
         sal_Int32 nColumn( 0 );
         
         PSBinStartPath();
         PSBinMoveTo( pPaths[i][0], aPoint, nColumn );
-        for( int n = 1; n < pSizes[i]; n++ )
+        for( unsigned int n = 1; n < pSizes[i]; n++ )
             PSBinLineTo( pPaths[i][n], aPoint, nColumn );
         if( pPaths[i][0] != pPaths[i][pSizes[i]-1] )
                 PSBinLineTo( pPaths[i][0], aPoint, nColumn );
@@ -593,25 +596,25 @@ PrinterGfx::DrawPolyLineBezier (sal_uInt
         }
         else
         {
-            snprintf(pString, nBezString, "%i %i moveto\n", pPath[0].X(), pPath[0].Y());
+            snprintf(pString, nBezString, "%li %li moveto\n", pPath[0].X(), pPath[0].Y());
             WritePS(mpPageBody, pString);
         }
         
         // Handle the drawing of mixed lines mixed with curves 
         // - a normal point followed by a normal point is a line
         // - a normal point followed by 2 control points and a normal point is a curve
-        for (int i=1; i<nPoints;)
+        for (unsigned int i=1; i<nPoints;)
         {
             if (pFlgAry[i+1] != POLY_CONTROL) //If the next point is a POLY_NORMAL, we're drawing a line
             {
                 if (i+1 >= nPoints) return; //Make sure we don't pass the end of the array
-                snprintf(pString, nBezString, "%i %i lineto\n", pPath[i].X(), pPath[i].Y());
+                snprintf(pString, nBezString, "%li %li lineto\n", pPath[i].X(), pPath[i].Y());
                 i++;
             }
             else //Otherwise we're drawing a spline
             {
                 if (i+3 >= nPoints) return; //Make sure we don't pass the end of the array
-                snprintf(pString, nBezString, "%i %i %i %i %i %i curveto\n",
+                snprintf(pString, nBezString, "%li %li %li %li %li %li curveto\n",
                         pPath[i+1].X(), pPath[i+1].Y(),
                         pPath[i+2].X(), pPath[i+2].Y(),
                         pPath[i+3].X(), pPath[i+3].Y());
@@ -656,13 +659,13 @@ PrinterGfx::DrawPolygonBezier (sal_uInt3
     if (!(nPoints > 1) || (pPath == NULL) || !(maFillColor.Is() || maLineColor.Is()))
         return;
     
-    snprintf(pString, nBezString, "%i %i moveto\n", pPath[0].X(), pPath[0].Y());
+    snprintf(pString, nBezString, "%li %li moveto\n", pPath[0].X(), pPath[0].Y());
     WritePS(mpPageBody, pString); //Move to the starting point for the PolyPoygon
-    for (int i=1; i < nPoints;) 
+    for (unsigned int i=1; i < nPoints;) 
     {
         if (pFlgAry[i] != POLY_CONTROL)
         {
-            snprintf(pString, nBezString, "%i %i lineto\n", pPath[i].X(), pPath[i].Y());
+            snprintf(pString, nBezString, "%li %li lineto\n", pPath[i].X(), pPath[i].Y());
             WritePS(mpPageBody, pString);
             i++;
         }
@@ -673,7 +676,7 @@ PrinterGfx::DrawPolygonBezier (sal_uInt3
             if ((pFlgAry[i] == POLY_CONTROL) && (pFlgAry[i+1] == POLY_CONTROL) &&
                     (pFlgAry[i+2] != POLY_CONTROL))
             {
-                snprintf(pString, nBezString, "%i %i %i %i %i %i curveto\n",
+                snprintf(pString, nBezString, "%li %li %li %li %li %li curveto\n",
                         pPath[i].X(), pPath[i].Y(), 
                         pPath[i+1].X(), pPath[i+1].Y(), 
                         pPath[i+2].X(), pPath[i+2].Y());
@@ -712,22 +715,22 @@ PrinterGfx::DrawPolyPolygonBezier (sal_u
         return;
     
     
-    for (int i=0; i<nPoly;i++)
+    for (unsigned int i=0; i<nPoly;i++)
     {
         sal_uInt32 nPoints = pPoints[i];
         // #112689# sanity check
         if( nPoints == 0 || pPtAry[i] == NULL )
             continue;
         
-        snprintf(pString, nBezString, "%i %i moveto\n", pPtAry[i][0].X(), pPtAry[i][0].Y()); //Move to the starting point
+        snprintf(pString, nBezString, "%li %li moveto\n", pPtAry[i][0].X(), pPtAry[i][0].Y()); //Move to the starting point
         WritePS(mpPageBody, pString);
-        for (int j=1; j < nPoints;)
+        for (unsigned int j=1; j < nPoints;)
         {
             // if no flag array exists for this polygon, then it must be a regular
             // polygon without beziers
             if ( ! pFlgAry[i] || pFlgAry[i][j] != POLY_CONTROL)
             {
-                snprintf(pString, nBezString, "%i %i lineto\n", pPtAry[i][j].X(), pPtAry[i][j].Y());
+                snprintf(pString, nBezString, "%li %li lineto\n", pPtAry[i][j].X(), pPtAry[i][j].Y());
                 WritePS(mpPageBody, pString);
                 j++;
             }
@@ -737,7 +740,7 @@ PrinterGfx::DrawPolyPolygonBezier (sal_u
                     break; //Error: wrong sequence of contol/normal points somehow
                 if ((pFlgAry[i][j] == POLY_CONTROL) && (pFlgAry[i][j+1] == POLY_CONTROL) && (pFlgAry[i][j+2] != POLY_CONTROL))
                 {
-                    snprintf(pString, nBezString, "%i %i %i %i %i %i curveto\n",
+                    snprintf(pString, nBezString, "%li %li %li %li %li %li curveto\n",
                             pPtAry[i][j].X(), pPtAry[i][j].Y(), 
                             pPtAry[i][j+1].X(), pPtAry[i][j+1].Y(), 
                             pPtAry[i][j+2].X(), pPtAry[i][j+2].Y());
@@ -849,15 +852,20 @@ void
 PrinterGfx::PSSetFont ()
 {
     GraphicsStatus& rCurrent( currentState() );
-    if( maVirtualStatus.maFont           != rCurrent.maFont         ||
-        maVirtualStatus.mnTextHeight     != rCurrent.mnTextHeight   ||
-        maVirtualStatus.maEncoding       != rCurrent.maEncoding     ||
-        maVirtualStatus.mnTextWidth      != rCurrent.mnTextWidth )
+    if( maVirtualStatus.maFont			!= rCurrent.maFont			||
+        maVirtualStatus.mnTextHeight	!= rCurrent.mnTextHeight	||
+        maVirtualStatus.maEncoding      != rCurrent.maEncoding		||
+        maVirtualStatus.mnTextWidth     != rCurrent.mnTextWidth		||
+        maVirtualStatus.mbArtBold		!= rCurrent.mbArtBold		||
+        maVirtualStatus.mbArtItalic		!= rCurrent.mbArtItalic
+        )
     {
         rCurrent.maFont              = maVirtualStatus.maFont;
         rCurrent.maEncoding          = maVirtualStatus.maEncoding;
         rCurrent.mnTextWidth         = maVirtualStatus.mnTextWidth;
         rCurrent.mnTextHeight        = maVirtualStatus.mnTextHeight;
+        rCurrent.mbArtItalic		 = maVirtualStatus.mbArtItalic;
+        rCurrent.mbArtBold			 = maVirtualStatus.mbArtBold;
 
         sal_Int32 nTextHeight = rCurrent.mnTextHeight;
         sal_Int32 nTextWidth  = rCurrent.mnTextWidth ? rCurrent.mnTextWidth 
@@ -894,10 +902,24 @@ PrinterGfx::PSSetFont ()
                                                     pSetFont + nChar);
         }
 
-        nChar += psp::getValueOf (nTextWidth,   pSetFont + nChar);
-        nChar += psp::appendStr  (" ",          pSetFont + nChar);
-        nChar += psp::getValueOf (-nTextHeight, pSetFont + nChar);
-        nChar += psp::appendStr  (" matrix scale makefont setfont\n", pSetFont + nChar);
+        if( ! rCurrent.mbArtItalic )
+        {
+            nChar += psp::getValueOf (nTextWidth,   pSetFont + nChar);
+            nChar += psp::appendStr  (" ",          pSetFont + nChar);
+            nChar += psp::getValueOf (-nTextHeight, pSetFont + nChar);
+            nChar += psp::appendStr  (" matrix scale makefont setfont\n", pSetFont + nChar);
+        }
+        else // skew 15 degrees to right
+        {
+            nChar += psp::appendStr  ( " [",		pSetFont + nChar);
+            nChar += psp::getValueOf (nTextWidth,	pSetFont + nChar);
+            nChar += psp::appendStr  (" 0 ",        pSetFont + nChar);
+            nChar += psp::getValueOfDouble (pSetFont + nChar, 0.27*(double)nTextWidth, 3 );
+            nChar += psp::appendStr  ( " ",			pSetFont + nChar);
+            nChar += psp::getValueOf (-nTextHeight, pSetFont + nChar);
+            
+            nChar += psp::appendStr  (" 0 0] makefont setfont\n", pSetFont + nChar);
+        }
 
         WritePS (mpPageBody, pSetFont);
     }
@@ -1023,7 +1045,7 @@ PrinterGfx::PSBinCurrentPath (sal_uInt32
 
     PSBinStartPath ();
     PSBinMoveTo (*pPath, aPoint, nColumn);
-    for (int i = 1; i < nPoints; i++)
+    for (unsigned int i = 1; i < nPoints; i++)
         PSBinLineTo (pPath[i], aPoint, nColumn);
     PSBinEndPath ();
 }
@@ -1168,17 +1190,40 @@ PrinterGfx::PSShowText (const sal_uChar*
         PSRotate (mnTextAngle);
     }
 
+    sal_Char pBuffer[256];
+    if( maVirtualStatus.mbArtBold )
+    {
+        sal_Int32 nLW = maVirtualStatus.mnTextWidth;
+        if( nLW == 0 )
+            nLW = maVirtualStatus.mnTextHeight;
+        else
+            nLW = nLW < maVirtualStatus.mnTextHeight ? nLW : maVirtualStatus.mnTextHeight;
+        psp::getValueOfDouble( pBuffer, (double)nLW / 30.0 );
+    }
     // dispatch to the drawing method
     if (pDeltaArray == NULL)
     {
         PSHexString (pStr, nBytes);
-        WritePS (mpPageBody, "show\n");
+            
+        if( maVirtualStatus.mbArtBold )
+        {
+            WritePS( mpPageBody, pBuffer );
+            WritePS( mpPageBody, " bshow\n" );
+        }
+        else
+            WritePS (mpPageBody, "show\n");
     }
     else
     {
         PSHexString (pStr, nBytes);
         PSDeltaArray (pDeltaArray, nGlyphs - 1);
-        WritePS (mpPageBody, "xshow\n");
+        if( maVirtualStatus.mbArtBold )
+        {
+            WritePS( mpPageBody, pBuffer );
+            WritePS( mpPageBody, " bxshow\n" );
+        }
+        else
+            WritePS (mpPageBody, "xshow\n");
     }
 
     // restore the user coordinate system   
@@ -1210,6 +1255,8 @@ PrinterGfx::DrawEPS( const Rectangle& rB
 {
     if( nSize == 0 )
         return sal_True;
+    if( ! mpPageBody )
+        return sal_False;
 
     sal_Bool bSuccess = sal_False;
 
@@ -1263,10 +1310,8 @@ PrinterGfx::DrawEPS( const Rectangle& rB
     {
         double fScaleX = (double)rBoundingBox.GetWidth()/(fRight-fLeft);
         double fScaleY = -(double)rBoundingBox.GetHeight()/(fTop-fBottom);
-        Point aTranslatePoint( rBoundingBox.Left()-fLeft*fScaleX,
-                               rBoundingBox.Bottom()+1-fBottom*fScaleY );
-        char buffer[128];
-
+        Point aTranslatePoint( (int)(rBoundingBox.Left()-fLeft*fScaleX),
+                               (int)(rBoundingBox.Bottom()+1-fBottom*fScaleY) );
         // prepare EPS
         WritePS( mpPageBody,
                  "/b4_Inc_state save def\n"
Index: psprint/source/printergfx/printerjob.cxx
===================================================================
--- psprint/source/printergfx/printerjob.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/printergfx/printerjob.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -107,7 +107,8 @@
 
 #include "glyphset.hxx"
 
-using namespace psp ;
+using namespace psp;
+using namespace rtl;
 
 #ifdef MACOSX
 // Prototype our MacOS X printing help function
@@ -143,8 +144,8 @@ AppendPS (FILE* pDst, osl::File* pSrc, s
 
     pSrc->setPos (osl_Pos_Absolut, 0);
 
-    sal_uInt64 nIn;
-    sal_uInt64 nOut;
+    sal_uInt64 nIn = 0;
+    sal_uInt64 nOut = 0;
     do
     {
         pSrc->read  (pBuffer, nBlockSize, nIn);
@@ -267,8 +268,8 @@ PrinterJob::GetCurrentPageBody ()
  */ 
 
 PrinterJob::PrinterJob () :
-        mpJobTrailer (NULL),
-        mpJobHeader (NULL)
+        mpJobHeader (NULL),
+        mpJobTrailer (NULL)
 {
 }
 
@@ -451,6 +452,8 @@ PrinterJob::StartJob (
     rtl::OUString aExt = rtl::OUString::createFromAscii (".ps");
     mpJobHeader  = CreateSpoolFile (rtl::OUString::createFromAscii("psp_head"), aExt);
     mpJobTrailer = CreateSpoolFile (rtl::OUString::createFromAscii("psp_tail"), aExt);
+    if( ! (mpJobHeader && mpJobTrailer) ) // existing files are removed in destructor
+        return sal_False;
 
     // write document header according to Document Structuring Conventions (DSC)
     WritePS (mpJobHeader,
@@ -481,6 +484,7 @@ PrinterJob::StartJob (
 
     // Document Title
     aFilterWS = WhitespaceToSpace( rJobName, FALSE );
+    maJobName = aFilterWS;
     WritePS (mpJobHeader, "%%Title: "); 
     WritePS (mpJobHeader, aFilterWS);
     WritePS (mpJobHeader, "\n");
@@ -500,7 +504,7 @@ PrinterJob::StartJob (
     WritePS (mpJobHeader, "%%EndComments\n");
 
     // write Prolog
-    writeProlog (mpJobHeader);
+    writeProlog (mpJobHeader, rSetupData);
 
     // mark last job setup as not set
     m_aLastJobData.m_pParser = NULL;
@@ -519,8 +523,11 @@ PrinterJob::EndJob ()
 
     // write document setup (done here because it
     // includes the accumulated fonts
-    writeSetup( mpJobHeader, m_aDocumentJobData );
+    if( mpJobHeader )
+        writeSetup( mpJobHeader, m_aDocumentJobData );
     m_pGraphics->OnEndJob();
+    if( ! (mpJobHeader && mpJobTrailer) )
+        return sal_False;
 
     // write document trailer according to Document Structuring Conventions (DSC)
     rtl::OStringBuffer aTrailer(512);
@@ -575,6 +582,12 @@ PrinterJob::EndJob ()
     }
     else
     {
+#ifndef MACOSX
+        PrinterInfoManager& rPrinterInfoManager = PrinterInfoManager::get ();
+        pDestFILE = rPrinterInfoManager.startSpool( m_aLastJobData.m_aPrinterName );
+        if (pDestFILE == NULL)
+            return sal_False;
+#else
         const PrinterInfoManager& rPrinterInfoManager = PrinterInfoManager::get ();
         const rtl::OUString& rPrinter     = m_aLastJobData.m_aPrinterName;
         const PrinterInfo&   rPrinterInfo = rPrinterInfoManager.getPrinterInfo (rPrinter);
@@ -587,26 +600,19 @@ PrinterJob::EndJob ()
          *           All other OS X/Darwin cases use spool to file.
 	    * Other UNIX:  always open a pipe.
          */
-        if (
-           #ifdef MACOSX
-               applePrintSysType == kApplePrintingLPR
-           #else
-               sal_True
-           #endif
-           )
+        if ( applePrintSysType == kApplePrintingLPR )
         {
             pDestFILE = popen (aShellCommand.getStr(), "w");
             if (pDestFILE == NULL)
                 return sal_False;
         }
-     #ifdef MACOSX
         else
         {
             /* Spool to file instead so we can convert it.  Cases used here:
-             * 1) kApplePrintingCUPS && kApplePrintingUsePDF
-             * 2) kApplePrintingCUPS && kApplePrintingUsePS
-             * 3) kApplePrintingNewCUPS && kApplePrintingUseNewPDF
-             * 2) kApplePrintingNewCUPS && kApplePrintingUsePS
+             * 1) kApplePrintingPrintCenter && kApplePrintingUsePDF
+             * 2) kApplePrintingPrintCenter && kApplePrintingUsePS
+             * 3) kApplePrintingCUPS && kApplePrintingUsePDF
+             * 4) kApplePrintingCUPS && kApplePrintingUsePS
              */
 
             /* Get a temporary file name for the spool file.
@@ -624,7 +630,7 @@ PrinterJob::EndJob ()
                 return sal_False;
             }
         }
-     #endif
+#endif
     }
 
     /* spool the document parts to the destination */
@@ -633,25 +639,36 @@ PrinterJob::EndJob ()
 
     AppendPS (pDestFILE, mpJobHeader, pBuffer);
     mpJobHeader->close();
-    
+
+    sal_Bool bSuccess = sal_True;
     std::list< osl::File* >::iterator pPageBody;
     std::list< osl::File* >::iterator pPageHead;
     for (pPageBody  = maPageList.begin(), pPageHead  = maHeaderList.begin();
          pPageBody != maPageList.end() && pPageHead != maHeaderList.end(); 
          pPageBody++, pPageHead++)
     {
-        osl::File::RC nError = (*pPageHead)->open(OpenFlag_Read);
-        if (nError == osl::File::E_None)
+        if( *pPageHead )
         {
-            AppendPS (pDestFILE, *pPageHead, pBuffer);
-            (*pPageHead)->close();
+            osl::File::RC nError = (*pPageHead)->open(OpenFlag_Read);
+            if (nError == osl::File::E_None)
+            {
+                AppendPS (pDestFILE, *pPageHead, pBuffer);
+                (*pPageHead)->close();
+            }
         }
-        nError = (*pPageBody)->open(OpenFlag_Read);
-        if (nError == osl::File::E_None)
+        else
+            bSuccess = sal_False;
+        if( *pPageBody )
         {
-            AppendPS (pDestFILE, *pPageBody, pBuffer);
-            (*pPageBody)->close();
+            osl::File::RC nError = (*pPageBody)->open(OpenFlag_Read);
+            if (nError == osl::File::E_None)
+            {
+                AppendPS (pDestFILE, *pPageBody, pBuffer);
+                (*pPageBody)->close();
+            }
         }
+        else
+            bSuccess = sal_False;
     }
     
     AppendPS (pDestFILE, mpJobTrailer, pBuffer);
@@ -662,8 +679,13 @@ PrinterJob::EndJob ()
     if (bSpoolToFile)
         fclose (pDestFILE);
     else
+#ifndef MACOSX
+    {
+        PrinterInfoManager& rPrinterInfoManager = PrinterInfoManager::get();
+        rPrinterInfoManager.endSpool( m_aLastJobData.m_aPrinterName, maJobName, pDestFILE );
+    }
+#else
     {
-        #ifdef MACOSX
             sal_uInt32	nXdpi;
             sal_uInt32	nYdpi;
 
@@ -691,14 +713,9 @@ PrinterJob::EndJob ()
                                            aShellCommand,
                                            aDriverName,
                                            m_aLastJobData,
-                                           &maJobName,
+                                           &maJobTitle,
                                            mnResolution );
-        #else
-            pclose (pDestFILE);
-        #endif
     }
-
-#ifdef MACOSX
     /* If we created a spool file for our Mac OS X/Darwin job,
      * delete it.  Also free the variable, since it is malloc()ed in macxp_tempnam()
      * and otherwise we'd leak memory.
@@ -710,7 +727,7 @@ PrinterJob::EndJob ()
     }
 #endif
 
-    return sal_True;
+    return bSuccess;
 }
 
 #ifdef MACOSX
@@ -754,46 +771,73 @@ void macxp_ProcessAndPrintDocument( sal_
          * "cupsFilter" key, or if the "cupsFilter" key _doesn't_ contain "application/pdf",
          * then we print directly with PostScript.
          */
-
-        /* For Jaguar default to using PDF unless no PDF filter in ppd */
-        if (applePrintSysType==kApplePrintingCUPS) {
-            printFormat = kApplePrintingUsePDF;
-            if ( (sal_False == psprintDriverName.equals("SGENPRT")) && (sal_False == psprintDriverName.equals("MacShared")) )
+        printFormat = kApplePrintingUsePDF;
+        if ( (sal_False == psprintDriverName.equals("SGENPRT")) && (sal_False == psprintDriverName.equals("MacShared")) )
+        {
+            /* The should exist a valid PPD for this printer */
+            if ( pJobData.m_pParser )
             {
-                /* The should exist a valid PPD for this printer */
-                if ( pJobData.m_pParser )
-                {
-                    const PPDKey    *pCupsFilterKey;
-                    const PPDValue  *pCupsFilterValue;
+                const PPDKey    *pCupsFilterKey;
+                const PPDValue  *pCupsFilterValue;
 
-                    pCupsFilterKey = pJobData.m_pParser->getKey( String(RTL_CONSTASCII_USTRINGPARAM("cupsFilter")) );
-                    pCupsFilterValue = pCupsFilterKey != NULL ? pJobData.m_aContext.getValue( pCupsFilterKey ) : NULL;
-                    if ( pCupsFilterValue )
-                    {
-                        ByteString    aCupsFilterString( pCupsFilterValue->m_aOption, RTL_TEXTENCODING_ISO_8859_1 );
-                        if ( aCupsFilterString.Search("application/pdf") == 0 )
-                        {
-                            /* cupsFilter didn't have application/pdf */
-                            printFormat = kApplePrintingUsePS;
-                        }
-                    }
-                    else
+                pCupsFilterKey = pJobData.m_pParser->getKey( String(RTL_CONSTASCII_USTRINGPARAM("cupsFilter")) );
+                pCupsFilterValue = pCupsFilterKey != NULL ? pJobData.m_aContext.getValue( pCupsFilterKey ) : NULL;
+                if ( pCupsFilterValue )
+                {
+                    ByteString    aCupsFilterString( pCupsFilterValue->m_aOption, RTL_TEXTENCODING_ISO_8859_1 );
+                    if ( aCupsFilterString.Search("application/pdf") == 0 )
                     {
-                        /* No "cupsFilter" key */
+                        /* cupsFilter didn't have application/pdf */
                         printFormat = kApplePrintingUsePS;
                     }
                 }
+                else
+                {
+                    /* No "cupsFilter" key */
+                    printFormat = kApplePrintingUsePS;
+                }
             }
-	}
-
-        /* For Panther and later simply use PS and let the new CUPS handle any conversions via filters */
-        if (applePrintSysType==kApplePrintingNewCUPS) {         
-            printFormat = kApplePrintingUsePS;
         }
 
+        if ( (applePrintSysType==kApplePrintingPrintCenter) && (printFormat==kApplePrintingUsePS) )
+        {		  
+            /* Now pass the PS file to /usr/sbin/Print for printing. */
+            snprintf( sysCommandBuffer, kSysCommandBufferLen-1, "%s -M ps \"%s\"", kApplePCPrintCommand, spoolFileName );
+            #ifdef DEBUG
+                fprintf( stderr, "printerjob.cxx: printing doc with command '%s'\n", sysCommandBuffer );
+            #endif
 
-        if ( ((applePrintSysType==kApplePrintingCUPS) || (applePrintSysType==kApplePrintingNewCUPS)) 
-             && ((printFormat==kApplePrintingUsePDF) || (printFormat==kApplePrintingUsePS)) )
+            printCmdErr = system( sysCommandBuffer );
+        }
+        else if ( (applePrintSysType==kApplePrintingPrintCenter) && (printFormat==kApplePrintingUsePDF) )
+        {
+            char	pdfFileName[ kPDFFileNameBufferLen ];
+            char	pdfFileNameMacFormat[ kPDFFileNameBufferLen ];
+            char	*c;
+            
+            /* Convert file to PDF using GhostScript */
+            printCmdErr =  macxp_ConvertPSFileToPDF( spoolFileName, pdfFileName, kPDFFileNameBufferLen, jobDPI );
+            if ( printCmdErr == 0 )
+		  {
+                /* AppleScript expects MacOS-style paths, so convert Unix path to Mac OS Style.
+                 * If the Unix path is absolute, get rid of the starting slash
+                 */
+                strncpy( pdfFileNameMacFormat, pdfFileName, kPDFFileNameBufferLen-1 );
+                if ( *pdfFileNameMacFormat == '/' )
+                    strncpy( pdfFileNameMacFormat, pdfFileName+1, kPDFFileNameBufferLen-2 );
+                while ( (c=strchr(pdfFileNameMacFormat,'/')) != NULL )
+                    *c = ':';
+            
+                /* Construct and execute the actual printing command using AppleScript */
+                snprintf( sysCommandBuffer, kSysCommandBufferLen-1, "/usr/bin/osascript -e 'tell application \"Finder\"' -e 'print {file \"%s\"}' -e 'end tell'", pdfFileNameMacFormat );
+                #ifdef DEBUG
+                    fprintf( stderr, "printerjob.cxx: printing PDF with command '%s'\n", sysCommandBuffer );
+                #endif
+                printCmdErr = system( sysCommandBuffer );
+            }
+		  unlink( pdfFileName );
+        }
+        else if ( (applePrintSysType==kApplePrintingCUPS) && ((printFormat==kApplePrintingUsePDF) || (printFormat==kApplePrintingUsePS)) )
         {
             char	     pdfFileName[ kPDFFileNameBufferLen ];
             char         numCopiesSwitch[ 5 ];
@@ -923,18 +967,19 @@ int macxp_ConvertPSFileToPDF( char *psFi
 
         /* Create the file name for the converted PDF and assemble the conversion command */
         snprintf( pdfFileName, pdfFileNameBufferLen-1, "%s%s", psFileName, kPDFFileExtension );
-	   
-	   sysCommandBuffer = (char *)malloc( sizeof(char) * ( strlen(kSysPrintSetupString) +
+	   int nBufferSize = sizeof(char) * ( strlen(kSysPrintSetupString) +
 	                                               strlen(kApplePS2PDFLocation) +
                                                     10 +	/* For " -r<DPI>" */
                                                     strlen(psFileName) +
                                                     strlen(pdfFileName) +
-                                                    10) );  /*  10 bytes fudge factor */
+                                          10);  /*  10 bytes fudge factor */
+       
+	   sysCommandBuffer = (char *)malloc( nBufferSize ); 
         if ( sysCommandBuffer == NULL )
             returnVal = -1;
         else
 	   {
-            sprintf( sysCommandBuffer, "%s;%s -r%d \"%s\" \"%s\"'", kSysPrintSetupString, kApplePS2PDFLocation, jobDPI, psFileName, pdfFileName );
+            snprintf( sysCommandBuffer, nBufferSize, "%s;%s -r%d \"%s\" \"%s\"'", kSysPrintSetupString, kApplePS2PDFLocation, jobDPI, psFileName, pdfFileName );
           #ifdef DEBUG
                 fprintf( stderr, "printerjob.cxx: converting document to PDF with command '%s'\n", sysCommandBuffer );
           #endif
@@ -1014,6 +1059,9 @@ PrinterJob::StartPage (const JobData& rJ
     maHeaderList.push_back (pPageHeader);
     maPageList.push_back (pPageBody);
 
+    if( ! (pPageHeader && pPageBody) )
+        return sal_False;
+
     /* #i7262# write setup only before first page
      *  don't do this in StartJob since the jobsetup there may be
      *  different.
@@ -1061,6 +1109,9 @@ PrinterJob::EndPage ()
     osl::File* pPageHeader = maHeaderList.back();
     osl::File* pPageBody   = maPageList.back();
 
+    if( ! (pPageBody && pPageHeader) )
+        return sal_False;
+
     // copy page to paper and write page trailer according to DSC
 
     sal_Char pTrailer[256];
@@ -1116,7 +1167,7 @@ bool PrinterJob::writeFeatureList( osl::
 
     // emit features ordered to OrderDependency
     // ignore features that are set to default
-    const PPDContext& rContext = rJob.m_aContext;
+
     // sanity check
     if( rJob.m_pParser == rJob.m_aContext.getParser() &&
         rJob.m_pParser &&
@@ -1223,10 +1274,55 @@ bool PrinterJob::writePageSetup( osl::Fi
     return bSuccess;
 }
 
-bool PrinterJob::writeProlog (osl::File* pFile)
+void PrinterJob::writeJobPatch( osl::File* pFile, const JobData& rJobData )
+{
+    const PPDKey* pKey = NULL;
+    
+    if( rJobData.m_pParser )
+        pKey = rJobData.m_pParser->getKey( OUString( RTL_CONSTASCII_USTRINGPARAM( "JobPatchFile" ) ) );
+    if( ! pKey )
+        return;
+
+    // order the patch files
+    // according to PPD spec the JobPatchFile options must be int
+    // and should be emitted in order
+    std::list< sal_Int32 > patch_order;
+    int nValueCount = pKey->countValues();
+    for( int i = 0; i < nValueCount; i++ )
+    {
+        const PPDValue* pVal = pKey->getValue( i );
+        patch_order.push_back( pVal->m_aOption.ToInt32() );
+        if( patch_order.back() == 0 && ! pVal->m_aOption.EqualsAscii( "0" ) )
+        {
+            WritePS( pFile, "% Warning: left out JobPatchFile option \"" );
+            OString aOption = OUStringToOString( pVal->m_aOption, RTL_TEXTENCODING_ASCII_US );
+            WritePS( pFile, aOption.getStr() );
+            WritePS( pFile,
+                     "\"\n% as it violates the PPD spec;\n"
+                     "% JobPatchFile options need to be numbered for ordering.\n" );
+        }
+    }
+
+    patch_order.sort();
+    patch_order.unique();
+
+    while( patch_order.begin() != patch_order.end() )
+    {
+        // note: this discards patch files not adhering to the "int" scheme
+        // as there won't be a value for them
+        writeFeature( pFile, pKey, pKey->getValue( OUString::valueOf( patch_order.front() ) ) );
+        patch_order.pop_front();
+    }
+}
+
+bool PrinterJob::writeProlog (osl::File* pFile, const JobData& rJobData )
 {
+    WritePS( pFile, "%%BeginProlog\n" );
+
+    // JobPatchFile feature needs to be emitted at begin of prolog
+    writeJobPatch( pFile, rJobData );
+
     const sal_Char pProlog[] = {
-        "%%BeginProlog\n"
         "%%BeginResource: procset PSPrint-Prolog 1.0 0\n"
         "/ISO1252Encoding [\n"
         "/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef\n"
@@ -1287,6 +1383,12 @@ bool PrinterJob::writeProlog (osl::File*
         "rlineto closepath } def\n"
         "/rectfill { rectangle fill } def\n"
         "/rectstroke { rectangle stroke } def } if\n"
+        "/bshow { currentlinewidth 3 1 roll currentpoint 3 index show moveto\n"
+        "setlinewidth false charpath stroke setlinewidth } def\n"
+        "/bxshow { currentlinewidth 4 1 roll setlinewidth exch dup length 1 sub\n"
+        "0 1 3 -1 roll { 1 string 2 index 2 index get 1 index exch 0 exch put dup\n"
+        "currentpoint 3 -1 roll show moveto currentpoint 3 -1 roll false charpath\n"
+        "stroke moveto 2 index exch get 0 rmoveto } for pop pop setlinewidth } def\n"
         "\n"
 		"/psp_lzwfilter { currentfile /ASCII85Decode filter /LZWDecode filter } def\n"
 		"/psp_ascii85filter { currentfile /ASCII85Decode filter } def\n"
Index: psprint/source/printergfx/psheader.ps
===================================================================
--- psprint/source/printergfx/psheader.ps.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/printergfx/psheader.ps	2004-10-21 14:47:18.000000000 +0100
@@ -339,3 +339,65 @@ if 
     /psp_reencodedfont exch definefont
 } def
 
+% bshow shows a text in artificial bold
+% this is achieved by first showing the text
+% then stroking its outline over it with
+% the linewidth set to the second parameter
+% usage: (string) num bshow
+
+/bshow {
+  currentlinewidth		% save current linewidth
+  3 1 roll				% move it to the last stack position
+  currentpoint			% save the current point
+  3 index				% copy the string to show
+  show					% show it
+  moveto				% move to the original coordinates again
+  setlinewidth			% set the linewidth
+  false charpath		% create the outline path of the shown string
+  stroke				% and stroke it
+  setlinewidth			% reset the stored linewidth
+} def
+
+% bxshow shows a text with a delta array in artificial bold
+% that is it does what bshow does for show
+% usage: (string) [deltaarray] num bxshow
+
+/bxshow {
+  currentlinewidth		% save linewidth
+  4 1 roll				% move it to the last stack position
+  setlinewidth			% set the new linewidth
+  exch					% exchange string and delta array
+  dup
+  length				% get length of string
+  1 sub					% prepare parameters for {} for
+  0 1
+  3 -1 roll
+  {
+    1 string			% create a string object length 1
+    2 index				% get the text
+    2 index				% get charpos (for index variable)
+    get					% have char value at charpos
+    1 index				% prepare string for put
+    exch
+    0
+    exch
+    put					% put into string of length 1
+    dup					% duplicate the it
+    currentpoint		% save current position
+    3 -1 roll			% prepare show
+    show				% show the character
+    moveto				% move back to beginning
+    currentpoint		% save current position
+    3 -1 roll			% prepare outline path of character
+    false charpath
+    stroke				% stroke it
+    moveto				% move back
+    % now move to next point
+    2 index				% get advance array
+    exch				% get charpos
+    get					% get advance element
+    0 rmoveto			% advance current position
+  } for
+  pop pop				% remove string and delta array
+  setlinewidth			% restore linewidth
+} def
Index: psprint/source/printergfx/psputil.cxx
===================================================================
--- psprint/source/printergfx/psputil.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/printergfx/psputil.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -193,7 +193,7 @@ WritePS (osl::File* pFile, const sal_Cha
     sal_uInt64 nInLength = rtl_str_getLength (pString);
     sal_uInt64 nOutLength = 0;
     
-    if (nInLength > 0)
+    if (nInLength > 0 && pFile)
         pFile->write (pString, nInLength, nOutLength);
 
     return nInLength == nOutLength;
@@ -204,7 +204,7 @@ WritePS (osl::File* pFile, const sal_Cha
 {
     sal_uInt64 nOutLength = 0;
     
-    if (nInLength > 0)
+    if (nInLength > 0 && pFile)
         pFile->write (pString, nInLength, nOutLength);
 
     return nInLength == nOutLength;
@@ -216,7 +216,7 @@ WritePS (osl::File* pFile, const rtl::OS
     sal_uInt64 nInLength = rString.getLength();
     sal_uInt64 nOutLength = 0;
     
-    if (nInLength > 0)
+    if (nInLength > 0 && pFile)
         pFile->write (rString, nInLength, nOutLength);
 
     return nInLength == nOutLength;
Index: psprint/source/printergfx/text_gfx.cxx
===================================================================
--- psprint/source/printergfx/text_gfx.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ psprint/source/printergfx/text_gfx.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -176,7 +176,9 @@ PrinterGfx::SetFont(
                     sal_Int32 nHeight,
                     sal_Int32 nWidth,
                     sal_Int32 nAngle,
-                    bool bVertical
+                    bool bVertical,
+                    bool bArtItalic,
+                    bool bArtBold
                     )
 {
     // font and encoding will be set by drawText again immediately
@@ -186,6 +188,8 @@ PrinterGfx::SetFont(
     maVirtualStatus.maEncoding        = RTL_TEXTENCODING_DONTKNOW;
     maVirtualStatus.mnTextHeight      = nHeight;
     maVirtualStatus.mnTextWidth       = nWidth;
+    maVirtualStatus.mbArtItalic		  = bArtItalic;
+    maVirtualStatus.mbArtBold		  = bArtBold;
     mnTextAngle                       = nAngle;
     mbTextVertical                    = bVertical;
 
@@ -275,7 +279,6 @@ void PrinterGfx::DrawGlyphs(
         sal_Unicode* pTempUnicodes = (sal_Unicode*)alloca(sizeof(sal_Unicode)*nLen);
         sal_Int16 nTempLen = 0;
         sal_Int32 nTempFirstDelta = 0;
-        sal_Int32 nRot = 0;
         Point aRotPoint;
         sal_Int32 nTextHeight = maVirtualStatus.mnTextHeight;
         sal_Int32 nTextWidth  = maVirtualStatus.mnTextWidth ? maVirtualStatus.mnTextWidth : maVirtualStatus.mnTextHeight;
@@ -451,12 +454,17 @@ PrinterGfx::DrawText (
 
         while ((nTo < nLen) && (nFont == pFontMap[nTo]))
         {
-            pNewDeltaArray[ nTo ] = ((0.5 + pNewDeltaArray[ nTo ]) / 1000.0) - nDelta;
+            pNewDeltaArray[ nTo ] = (sal_Int32)(((0.5 + pNewDeltaArray[ nTo ]) / 1000.0) - nDelta);
             nTo++ ;
         }
 
-        SetFont( nFont, maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
-                mnTextAngle, mbTextVertical );
+        SetFont( nFont,
+                 maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
+                 mnTextAngle,
+                 mbTextVertical,
+                 maVirtualStatus.mbArtItalic,
+                 maVirtualStatus.mbArtBold
+                 );
         
         if (mbTextVertical)
         {
@@ -483,8 +491,12 @@ PrinterGfx::DrawText (
     }
 
     // restore the original font settings
-    SetFont( nRestoreFont, maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
-            mnTextAngle, mbTextVertical );
+    SetFont( nRestoreFont,
+             maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, 
+             mnTextAngle, mbTextVertical,
+             maVirtualStatus.mbArtItalic,
+             maVirtualStatus.mbArtBold
+             );
 }
 
 void PrinterGfx::drawVerticalizedText(
@@ -517,24 +529,30 @@ void PrinterGfx::drawVerticalizedText(
             i++;
         if( i <= nLen && i > nLastPos )
         {
-            int nWidth = 0;
             for( int n = nLastPos; n < i; n++ )
                 pDelta[n] = pDeltaArray[n] - (aPoint.X() - rPoint.X() );
             
-            SetFont( mnFontID, maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth, nNormalAngle, mbTextVertical );
+            SetFont( mnFontID,
+                     maVirtualStatus.mnTextHeight, maVirtualStatus.mnTextWidth,
+                     nNormalAngle, mbTextVertical,
+                     maVirtualStatus.mbArtItalic,
+                     maVirtualStatus.mbArtBold );
             drawText( aPoint, pStr + nLastPos, i - nLastPos, pDelta + nLastPos );
             
-            aPoint.X() = rPoint.X() + ((double)pDeltaArray[i-1] * fCos);
-            aPoint.Y() = rPoint.Y() + ((double)pDeltaArray[i-1] * fSin);
+            aPoint.X() = (sal_Int32)(rPoint.X() + ((double)pDeltaArray[i-1] * fCos));
+            aPoint.Y() = (sal_Int32)(rPoint.Y() + ((double)pDeltaArray[i-1] * fSin));
         }
         if( i < nLen )
         {
             int nOldWidth	= maVirtualStatus.mnTextWidth;
             int nOldHeight	= maVirtualStatus.mnTextHeight;
-            SetFont( mnFontID, nTextScale,
+            SetFont( mnFontID,
+                     nTextScale,
                      maVirtualStatus.mnTextHeight,
                      nNormalAngle + nDeltaAngle, 
-                     mbTextVertical );
+                     mbTextVertical,
+                     maVirtualStatus.mbArtItalic,
+                     maVirtualStatus.mbArtBold );
 
             double nA = nTextScale * aInfo.m_nAscend / 1000.0;
             double nD = nTextScale * aInfo.m_nDescend / 1000.0;
@@ -546,19 +564,19 @@ void PrinterGfx::drawVerticalizedText(
             switch( nDeltaAngle )
             {
                 case +900:
-                    aPos.X() += +nA * fCos + nD * fSin;
-                    aPos.Y() += -nA * fSin + nD * fCos;
+                    aPos.X() += (sal_Int32)(+nA * fCos + nD * fSin);
+                    aPos.Y() += (sal_Int32)(-nA * fSin + nD * fCos);
                     break;
                 case -900:
-                    aPos.X() += +nA * fSin + nD * fCos;
-                    aPos.Y() += -(nTextScale*fStretch - nD) * fCos;
+                    aPos.X() += (sal_Int32)(+nA * fSin + nD * fCos);
+                    aPos.Y() += (sal_Int32)(-(nTextScale*fStretch - nD) * fCos);
                     break;
             }
             drawText( aPos, pStr+i, 1, NULL );
             if( i < nLen-1 && pDeltaArray )
             {
-                aPoint.X() = rPoint.X() + ((double)pDeltaArray[i] * fCos);
-                aPoint.Y() = rPoint.Y() + ((double)pDeltaArray[i] * fSin);
+                aPoint.X() = (sal_Int32)(rPoint.X() + ((double)pDeltaArray[i] * fCos));
+                aPoint.Y() = (sal_Int32)(rPoint.Y() + ((double)pDeltaArray[i] * fSin));
             }
 
             // swap text width/height again
@@ -566,7 +584,9 @@ void PrinterGfx::drawVerticalizedText(
                      nOldHeight,
                      nOldWidth,
                      nNormalAngle, 
-                     mbTextVertical );
+                     mbTextVertical,
+                     maVirtualStatus.mbArtItalic,
+                     maVirtualStatus.mbArtBold );
         }
         i++;
         nLastPos = i;
@@ -618,8 +638,6 @@ PrinterGfx::drawText(
         return;
 
     fonttype::type   eType          = mrFontMgr.getFontType (mnFontID);
-    fonttype::type   eEffectiveType = fonttype::Unknown;
-    rtl_TextEncoding nEncoding      = mrFontMgr.getFontEncoding (mnFontID);
 
     if (eType == fonttype::Type1)
         PSUploadPS1Font (mnFontID);
Index: padmin/source/adddlg.cxx
===================================================================
--- padmin/source/adddlg.cxx.orig	2004-10-21 12:52:30.000000000 +0100
+++ padmin/source/adddlg.cxx	2004-10-21 14:47:18.000000000 +0100
@@ -82,9 +82,9 @@
 #ifndef _OSL_THREAD_H_
 #include <osl/thread.h>
 #endif
-
 #include <hash_set>
 
+
 using namespace rtl;
 using namespace psp;
 using namespace padmin;
@@ -112,6 +112,13 @@ APChooseDevicePage::APChooseDevicePage( 
 	m_aOldBtn.Check( FALSE );
     if( ! AddPrinterDialog::getOldPrinterLocation().Len() )
         m_aOldBtn.Enable( FALSE );
+    if( ! PrinterInfoManager::get().addOrRemovePossible() )
+    {
+        m_aPrinterBtn.Check( FALSE );
+        m_aFaxBtn.Check( TRUE );
+        m_aPrinterBtn.Enable( FALSE );
+        m_aOldBtn.Enable( FALSE );
+    }
 }
 
 APChooseDevicePage::~APChooseDevicePage()
@@ -615,21 +622,21 @@ APOldPrinterPage::APOldPrinterPage( AddP
                 aInfo.m_aContext.setValue( pKey, pValue );
             aValue = aConfig.ReadKey( "MarginLeft", aDefMarginLeft );
             if( aValue.Len() )
-                aInfo.m_nLeftMarginAdjust = aValue.ToInt32() - ((double)nLeft * 35.27777778 );
+                aInfo.m_nLeftMarginAdjust = aValue.ToInt32() - (int)((double)nLeft * 35.27777778 );
             aValue = aConfig.ReadKey( "MarginRight", aDefMarginRight );
             if( aValue.Len() )
-                aInfo.m_nRightMarginAdjust = aValue.ToInt32() - ((double)nRight * 35.27777778 );
+                aInfo.m_nRightMarginAdjust = aValue.ToInt32() - (int)((double)nRight * 35.27777778 );
             aValue = aConfig.ReadKey( "MarginTop", aDefMarginTop );
             if( aValue.Len() )
-                aInfo.m_nTopMarginAdjust = aValue.ToInt32() - ((double)nTop * 35.27777778 );
+                aInfo.m_nTopMarginAdjust = aValue.ToInt32() - (int)((double)nTop * 35.27777778 );
             aValue = aConfig.ReadKey( "MarginBottom", aDefMarginBottom );
             if( aValue.Len() )
-                aInfo.m_nBottomMarginAdjust = aValue.ToInt32() - ((double)nBottom * 35.27777778 );
+                aInfo.m_nBottomMarginAdjust = aValue.ToInt32() - (int)((double)nBottom * 35.27777778 );
         }
 
         aValue = aConfig.ReadKey( "Scale", aDefScale );
         if( aValue.Len() )
-            aInfo.m_nScale = 100.0 * StringToDouble( aValue );
+            aInfo.m_nScale = (int)(100.0 * StringToDouble( aValue ));
 
         aValue = aConfig.ReadKey( "Copies", aDefScale );
         if( aValue.Len() )
@@ -785,17 +792,17 @@ void APPdfDriverPage::fill( PrinterInfo&
 
 AddPrinterDialog::AddPrinterDialog( Window* pParent )
 		: ModalDialog( pParent, PaResId( RID_ADD_PRINTER_DIALOG ) ),
-		  m_aNextPB( this, PaResId( RID_ADDP_BTN_NEXT ) ),
+		  m_aCancelPB( this, PaResId( RID_ADDP_BTN_CANCEL ) ),
 		  m_aPrevPB( this, PaResId( RID_ADDP_BTN_PREV ) ),
+		  m_aNextPB( this, PaResId( RID_ADDP_BTN_NEXT ) ),
 		  m_aFinishPB( this, PaResId( RID_ADDP_BTN_FINISH ) ),
-		  m_aCancelPB( this, PaResId( RID_ADDP_BTN_CANCEL ) ),
 		  m_aLine( this, PaResId( RID_ADDP_LINE ) ),
           m_aTitleImage( this, PaResId( RID_ADDP_CTRL_TITLE ) ),
 		  m_pCurrentPage( NULL ),
 		  m_pChooseDevicePage( NULL ),
+		  m_pCommandPage( NULL ),
 		  m_pChooseDriverPage( NULL ),
 		  m_pNamePage( NULL ),
-		  m_pCommandPage( NULL ),
 		  m_pOldPrinterPage( NULL ),
 		  m_pFaxDriverPage( NULL ),
 		  m_pFaxSelectDriverPage( NULL ),
@@ -1103,7 +1110,6 @@ String AddPrinterDialog::uniquePrinterNa
 	PrinterInfoManager& rManager( PrinterInfoManager::get() );
 
 	int nVersion = 1;
-	bool bDoublet;
     list< OUString > aPrinterList;
     rManager.listPrinters( aPrinterList );
     hash_set< OUString, OUStringHash > aPrinters;
@@ -1126,7 +1132,6 @@ String AddPrinterDialog::getOldPrinterLo
     ByteString aFileName;
 
 	rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
-	PrinterInfoManager& rManager( PrinterInfoManager::get() );
 	if( pHome )
 	{
 		aFileName = pHome;
Index: psprint/inc/psprint/printerjob.hxx
===================================================================
--- psprint/inc/psprint/printerjob.hxx.orig	2004-10-20 19:42:56.000000000 +0100
+++ psprint/inc/psprint/printerjob.hxx	2004-10-21 14:47:18.000000000 +0100
@@ -126,7 +126,8 @@ private:            // private methods
     bool			writeFeatureList( osl::File* pFile, const JobData&, bool bDocumentSetup );
     bool            writeSetup( osl::File* pFile, const JobData& );
     bool            writePageSetup( osl::File* pFile, const JobData& );
-    bool            writeProlog (osl::File* pFile);
+    void			writeJobPatch( osl::File* File, const JobData& );
+    bool            writeProlog (osl::File* pFile, const JobData& );
 
 public:             // for usage in PrinterGfx
             
