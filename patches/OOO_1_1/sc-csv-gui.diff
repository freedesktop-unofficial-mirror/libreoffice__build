Index: sc/source/ui/dbgui/asciiopt.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/dbgui/asciiopt.cxx,v
retrieving revision 1.18
diff -u -p -u -r1.18 asciiopt.cxx
--- sc/source/ui/dbgui/asciiopt.cxx	28 Apr 2003 15:44:08 -0000	1.18
+++ sc/source/ui/dbgui/asciiopt.cxx	13 Jun 2005 16:43:17 -0000
@@ -84,6 +84,8 @@
 
 // ============================================================================
 
+#define DEFAULT_SEP '"'
+
 //! TODO make dynamic
 #ifdef WIN
 const sal_Int32 ASCIIDLG_MAXROWS                = 10000;
@@ -101,7 +103,7 @@ ScAsciiOptions::ScAsciiOptions() :
 	bFixedLen		( FALSE ),
 	aFieldSeps		( ';' ),
 	bMergeFieldSeps	( FALSE ),
-	cTextSep		( 34 ),
+	cTextSep		( DEFAULT_SEP ),
 	eCharSet		( gsl_getSystemTextEncoding() ),
 	bCharSetSystem	( FALSE ),
 	nStartRow		( 1 ),
@@ -522,13 +524,80 @@ sal_Unicode lcl_CharFromCombo( ComboBox&
 	return c;
 }
 
+// ----------------------------------------------------------------------------
+
+bool ScImportAsciiDlg::GetLine( ULONG nLine, String &rText )
+{
+    if (nLine >= ASCIIDLG_MAXROWS || !mpDatStream)
+        return false;
+
+    bool bRet = true;
+    bool bFixed = aRbFixed.IsChecked();
+
+    if (!mpRowPosArray)
+        mpRowPosArray = new ULONG[ASCIIDLG_MAXROWS + 2];
+
+    if (!mnRowPosCount) // complete re-fresh
+    {
+        memset( mpRowPosArray, 0, sizeof(mpRowPosArray[0]) * (ASCIIDLG_MAXROWS+2));
+
+        Seek(0);
+        if ( mpDatStream->GetStreamCharSet() == RTL_TEXTENCODING_UNICODE )
+            mpDatStream->StartReadingUnicodeText();
+
+        mnStreamPos = mpDatStream->Tell();
+        mpRowPosArray[mnRowPosCount] = mnStreamPos;
+    }
+
+    if (nLine >= mnRowPosCount)
+    {
+        // need to work out some more line information
+        do
+        {
+            if (!Seek( mpRowPosArray[mnRowPosCount]) ||
+                    mpDatStream->GetError() != ERRCODE_NONE ||
+                    mpDatStream->IsEof())
+            {
+                bRet = false;
+                break;
+            }
+			ScImportExport::ReadCSVLine (*mpDatStream, rText, mcTextSep, bFixed);
+            mnStreamPos = mpDatStream->Tell();
+            mpRowPosArray[++mnRowPosCount] = mnStreamPos;
+        } while (nLine >= mnRowPosCount &&
+                mpDatStream->GetError() == ERRCODE_NONE &&
+                !mpDatStream->IsEof());
+        if (mpDatStream->IsEof() &&
+                mnStreamPos == mpRowPosArray[mnRowPosCount-1])
+        {
+            // the very end, not even an empty line read
+            bRet = false;
+            --mnRowPosCount;
+        }
+    }
+    else
+    {
+        Seek( mpRowPosArray[nLine]);
+		ScImportExport::ReadCSVLine (*mpDatStream, rText, mcTextSep, bFixed);
+        mnStreamPos = mpDatStream->Tell();
+    }
+
+    //	#107455# If the file content isn't unicode, ReadUniStringLine
+    //	may try to seek beyond the file's end and cause a CANTSEEK error
+    //	(depending on the stream type). The error code has to be cleared,
+    //	or further read operations (including non-unicode) will fail.
+    if ( mpDatStream->GetError() == ERRCODE_IO_CANTSEEK )
+        mpDatStream->ResetError();
+
+    return bRet;
+}
 
 // ----------------------------------------------------------------------------
 
 ScImportAsciiDlg::ScImportAsciiDlg( Window* pParent,String aDatName,
 									SvStream* pInStream, sal_Unicode cSep ) :
 		ModalDialog	( pParent, ScResId( RID_SCDLG_ASCII ) ),
-        pDatStream  ( pInStream ),
+        mpDatStream  ( pInStream ),
 
 		aRbFixed	( this, ScResId( RB_FIXED ) ),
 		aRbSeparated( this, ScResId( RB_SEPARATED ) ),
@@ -560,10 +629,11 @@ ScImportAsciiDlg::ScImportAsciiDlg( Wind
 		aCharSetUser( ScResId( SCSTR_CHARSET_USER ) ),
 		aColumnUser	( ScResId( SCSTR_COLUMN_USER ) ),
 		aFldSepList	( ScResId( SCSTR_FIELDSEP ) ),
-		aTextSepList( ScResId( SCSTR_TEXTSEP ) ),
-		pRowPosArray( NULL ),
-        pRowPosArrayUnicode( NULL ),
-        bVFlag      ( FALSE )
+		maTextSepList( ScResId( SCSTR_TEXTSEP ) ),
+		mcTextSep( DEFAULT_SEP ),
+		mpRowPosArray( NULL ),
+		mnRowPosCount(0),
+		mnStreamPos(0)
 {
 	FreeResource();
 
@@ -584,45 +654,20 @@ ScImportAsciiDlg::ScImportAsciiDlg( Wind
             aEdOther.SetText( cSep );
 	}
 
-	nArrayEndPos = nArrayEndPosUnicode = 0;
 	USHORT nField;
 	BOOL bPreselectUnicode = FALSE;
-    if( pDatStream )
+	// Sniff for Unicode / not
+    if( mpDatStream )
 	{
-		USHORT j;
-		pRowPosArray=new ULONG[ASCIIDLG_MAXROWS+2];
-		pRowPosArrayUnicode=new ULONG[ASCIIDLG_MAXROWS+2];
-		ULONG *pPtrRowPos=pRowPosArray;
-		ULONG *pPtrRowPosUnicode=pRowPosArrayUnicode;
-		for(nField=0;nField<ASCIIDLG_MAXROWS;nField++)
-		{
-			*pPtrRowPos++=0;
-			*pPtrRowPosUnicode++=0;
-		}
-		pDatStream->SetBufferSize(ASCIIDLG_MAXROWS);
-		pDatStream->SetStreamCharSet( gsl_getSystemTextEncoding() );	//!???
-		pDatStream->Seek( 0 );
-        for ( j=0; j < CSV_PREVIEW_LINES; j++ )
-		{
-			pRowPosArray[nArrayEndPos++]=pDatStream->Tell();
-			if(!pDatStream->ReadLine( aPreviewLine[j] ))
-			{
-				bVFlag=TRUE;
-                maTableBox.Execute( CSVCMD_SETLINECOUNT, j );
-				break;
-			}
-		}
-		nStreamPos = pDatStream->Tell();
-
-		pDatStream->Seek( 0 );
-		pDatStream->StartReadingUnicodeText();
-		ULONG nUniPos = pDatStream->Tell();
+		Seek( 0 );
+		mpDatStream->StartReadingUnicodeText();
+		ULONG nUniPos = mpDatStream->Tell();
 		if ( nUniPos > 0 )
 			bPreselectUnicode = TRUE;	// read 0xfeff/0xfffe
 		else
 		{
 			UINT16 n;
-			*pDatStream >> n;
+			*mpDatStream >> n;
 			// Assume that normal ASCII/ANSI/ISO/etc. text doesn't start with
 			// control characters except CR,LF,TAB
 			if ( (n & 0xff00) < 0x2000 )
@@ -637,33 +682,14 @@ ScImportAsciiDlg::ScImportAsciiDlg( Wind
 						bPreselectUnicode = TRUE;
 				}
 			}
-			pDatStream->Seek( nUniPos );
 		}
-        for ( j=0; j < CSV_PREVIEW_LINES; j++ )
-		{
-			pRowPosArrayUnicode[nArrayEndPosUnicode++] = pDatStream->Tell();
-			if( !pDatStream->ReadUniStringLine( aPreviewLineUnicode[j] ) )
-				break;
-			// #84386# Reading Unicode on ASCII/ANSI data won't find any line
-			// ends and therefor tries to read the whole file into strings.
-			// Check if first line is completely filled and don't try any further.
-			if ( j == 0 && aPreviewLineUnicode[j].Len() == STRING_MAXLEN )
-				break;
-		}
-		nStreamPosUnicode = pDatStream->Tell();
-
-		//	#107455# If the file content isn't unicode, ReadUniStringLine
-		//	may try to seek beyond the file's end and cause a CANTSEEK error
-		//	(depending on the stream type). The error code has to be cleared,
-		//	or further read operations (including non-unicode) will fail.
-		if ( pDatStream->GetError() == ERRCODE_IO_CANTSEEK )
-			pDatStream->ResetError();
+		mnStreamPos = mpDatStream->Tell();
 	}
 
     aNfRow.SetModifyHdl( LINK( this, ScImportAsciiDlg, FirstRowHdl ) );
 
     // *** Separator characters ***
-    lcl_FillCombo( aCbTextSep, aTextSepList, 34 );      // Default "
+    lcl_FillCombo( aCbTextSep, maTextSepList, DEFAULT_SEP );      // Default "
 
     Link aSeparatorHdl =LINK( this, ScImportAsciiDlg, SeparatorHdl );
     aCbTextSep.SetSelectHdl( aSeparatorHdl );
@@ -701,24 +727,21 @@ ScImportAsciiDlg::ScImportAsciiDlg( Wind
     maTableBox.InitTypes( aLbType );
     maTableBox.SetColTypeHdl( LINK( this, ScImportAsciiDlg, ColTypeHdl ) );
 
-	if(!bVFlag)
-        maTableBox.Execute( CSVCMD_SETLINECOUNT, ASCIIDLG_MAXROWS );
-
     aRbSeparated.SetClickHdl( LINK( this, ScImportAsciiDlg, RbSepFixHdl ) );
     aRbFixed.SetClickHdl( LINK( this, ScImportAsciiDlg, RbSepFixHdl ) );
 
     SetupSeparatorCtrls();
     RbSepFixHdl( &aRbFixed );
 
+	UpdateVertical ();
+
     maTableBox.Execute( CSVCMD_NEWCELLTEXTS );
 }
 
 
 ScImportAsciiDlg::~ScImportAsciiDlg()
 {
-	delete[] pRowPosArray;
-	delete[] pRowPosArrayUnicode;
-
+	delete[] mpRowPosArray;
 }
 
 void ScImportAsciiDlg::GetOptions( ScAsciiOptions& rOpt )
@@ -732,7 +755,7 @@ void ScImportAsciiDlg::GetOptions( ScAsc
     {
         rOpt.SetFieldSeps( GetSeparators() );
         rOpt.SetMergeSeps( aCkbAsOnce.IsChecked() );
-        rOpt.SetTextSep( lcl_CharFromCombo( aCbTextSep, aTextSepList ) );
+        rOpt.SetTextSep( lcl_CharFromCombo( aCbTextSep, maTextSepList ) );
     }
 }
 
@@ -774,112 +797,16 @@ void ScImportAsciiDlg::SetupSeparatorCtr
     aCbTextSep.Enable( bEnable );
 }
 
-void ScImportAsciiDlg::UpdateVertical( bool bSwitchToFromUnicode )
+void ScImportAsciiDlg::UpdateVertical()
 {
-	if ( bSwitchToFromUnicode )
-	{
-		bVFlag = FALSE;
-        maTableBox.Execute( CSVCMD_SETLINECOUNT, ASCIIDLG_MAXROWS );
-	}
-	ULONG nNew = 0;
-    if(!bVFlag)
-	{
-        // dragging the scrollbar -> read entire file
-		bVFlag=TRUE;
-		ULONG nRows = 0;
-
-		pDatStream->Seek(0);
-        if ( meCharSet == RTL_TEXTENCODING_UNICODE )
-		{
-			String aStringUnicode;
-			pDatStream->StartReadingUnicodeText();
-			ULONG* pPtrRowPos = pRowPosArrayUnicode;
-			*pPtrRowPos++ = 0;
-			while( pDatStream->ReadUniStringLine( aStringUnicode ) )
-			{
-				nRows++;
-				if( nRows > ASCIIDLG_MAXROWS )
-					break;
-				*pPtrRowPos++ = pDatStream->Tell();
-			}
-			nStreamPosUnicode = pDatStream->Tell();
+	mnRowPosCount = 0;
+	maTableBox.Execute( CSVCMD_SETLINECOUNT, ASCIIDLG_MAXROWS );
 
-			if ( pDatStream->GetError() == ERRCODE_IO_CANTSEEK )	// #107455# reset seek error
-				pDatStream->ResetError();
-		}
-		else
-		{
-			ByteString aString;
-			ULONG* pPtrRowPos = pRowPosArray;
-			*pPtrRowPos++ = 0;
-			while( pDatStream->ReadLine( aString ) )
-			{
-				nRows++;
-				if( nRows > ASCIIDLG_MAXROWS )
-					break;
-				*pPtrRowPos++ = pDatStream->Tell();
-			}
-			nStreamPos = pDatStream->Tell();
-		}
-
-        maTableBox.Execute( CSVCMD_SETLINECOUNT, nRows );
-	}
-
-    nNew = maTableBox.GetFirstVisLine();
-
-    if ( meCharSet == RTL_TEXTENCODING_UNICODE )
-	{
-		if ( bVFlag || nNew <= nArrayEndPosUnicode )
-			pDatStream->Seek( pRowPosArrayUnicode[nNew] );
-		else
-			pDatStream->Seek( nStreamPosUnicode );
-        for ( USHORT j=0; j < CSV_PREVIEW_LINES; j++ )
-		{
-			if( !bVFlag && nNew+j >= nArrayEndPos )
-			{
-				pRowPosArrayUnicode[nNew+j] = pDatStream->Tell();
-				nArrayEndPosUnicode = (USHORT) nNew+j;
-			}
-			// #84386# Reading Unicode on ASCII/ANSI data won't find any line
-			// ends and therefor tries to read the whole file into strings.
-			// Check if first line is completely filled and don't try any further.
-			if( (!pDatStream->ReadUniStringLine( aPreviewLineUnicode[j] ) ||
-				 (j == 0 && aPreviewLineUnicode[j].Len() == STRING_MAXLEN)) &&
-				 !bVFlag )
-			{
-				bVFlag = TRUE;
-                maTableBox.Execute( CSVCMD_SETLINECOUNT, nArrayEndPosUnicode );
-			}
-		}
-		nStreamPosUnicode = pDatStream->Tell();
-
-		if ( pDatStream->GetError() == ERRCODE_IO_CANTSEEK )	// #107455# reset seek error
-			pDatStream->ResetError();
-	}
-	else
-	{
-		if ( bVFlag || nNew <= nArrayEndPos )
-			pDatStream->Seek( pRowPosArray[nNew] );
-		else
-			pDatStream->Seek( nStreamPos );
-        for ( USHORT j=0; j < CSV_PREVIEW_LINES; j++ )
-		{
-			if( !bVFlag && nNew+j >= nArrayEndPos )
-			{
-				pRowPosArray[nNew+j] = pDatStream->Tell();
-				nArrayEndPos = (USHORT) nNew+j;
-			}
-			if( !pDatStream->ReadLine( aPreviewLine[j] ) && !bVFlag )
-			{
-				bVFlag = TRUE;
-                maTableBox.Execute( CSVCMD_SETLINECOUNT, nArrayEndPos );
-			}
-		}
-		nStreamPos = pDatStream->Tell();
-	}
+	// FIXME: Detect if we need to move the window eg. fewer rows.
+	if (mpDatStream)
+		mpDatStream->SetStreamCharSet (meCharSet);
 }
 
-
 // ----------------------------------------------------------------------------
 
 IMPL_LINK( ScImportAsciiDlg, RbSepFixHdl, RadioButton*, pButton )
@@ -905,6 +832,11 @@ IMPL_LINK( ScImportAsciiDlg, SeparatorHd
     DBG_ASSERT( pCtrl, "ScImportAsciiDlg::SeparatorHdl - missing sender" );
     DBG_ASSERT( !aRbFixed.IsChecked(), "ScImportAsciiDlg::SeparatorHdl - not allowed in fixed width" );
 
+	sal_Unicode cNewSep = lcl_CharFromCombo( aCbTextSep, maTextSepList );
+	if( cNewSep != mcTextSep )
+		UpdateVertical();
+	mcTextSep = cNewSep;
+
     if( (pCtrl == &aCkbOther) && aCkbOther.IsChecked() )
         aEdOther.GrabFocus();
     else if( pCtrl == &aEdOther )
@@ -922,12 +854,10 @@ IMPL_LINK( ScImportAsciiDlg, CharSetHdl,
         SetPointer( Pointer( POINTER_WAIT ) );
         CharSet eOldCharSet = meCharSet;
         SetSelectedCharSet();
-        if( (meCharSet == RTL_TEXTENCODING_UNICODE) != (eOldCharSet == RTL_TEXTENCODING_UNICODE) )
-        {
-            // switching to/from Unicode invalidates all positions
-            if( pDatStream )
-                UpdateVertical( TRUE );
-        }
+		if (eOldCharSet != meCharSet)
+            // switching char-set invalidates 8bit -> String conversions
+			UpdateVertical();
+
         maTableBox.Execute( CSVCMD_NEWCELLTEXTS );
         SetPointer( Pointer( POINTER_ARROW ) );
     }
@@ -953,19 +883,22 @@ IMPL_LINK( ScImportAsciiDlg, UpdateTextH
 {
     DBG_ASSERT( pTableBox, "ScImportAsciiDlg::UpdateTextHdl - missing sender" );
 
-    BOOL bVFlag1 = bVFlag;
-    if( pDatStream )
-        UpdateVertical();
-    if( bVFlag != bVFlag1 )
-        UpdateVertical();
+	ULONG i;
+    ULONG nBaseLine = maTableBox.GetFirstVisLine();
 
-	sal_Unicode cTextSep = lcl_CharFromCombo( aCbTextSep, aTextSepList );
-    bool bMergeSep = (aCkbAsOnce.IsChecked() == TRUE);
+	for (i = 0; i < CSV_PREVIEW_LINES; i++)
+	{
+		if (!GetLine( nBaseLine + i, maPreviewLine [i]))
+		{
+			maTableBox.Execute( CSVCMD_SETLINECOUNT, mnRowPosCount );
+			break;
+		}
+	}
+	for (; i < CSV_PREVIEW_LINES; i++)
+		maPreviewLine[i] = String();
 
-    if( meCharSet == RTL_TEXTENCODING_UNICODE )
-        maTableBox.SetUniStrings( aPreviewLineUnicode, GetSeparators(), cTextSep, bMergeSep );
-    else
-        maTableBox.SetByteStrings( aPreviewLine, meCharSet, GetSeparators(), cTextSep, bMergeSep );
+    bool bMergeSep = (aCkbAsOnce.IsChecked() == TRUE);
+	maTableBox.SetUniStrings( maPreviewLine, GetSeparators(), mcTextSep, bMergeSep );
 
     return 0;
 }
