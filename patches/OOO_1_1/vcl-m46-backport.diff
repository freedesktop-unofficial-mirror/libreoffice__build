Index: vcl/inc/abstdlg.hxx
===================================================================
RCS file: vcl/inc/abstdlg.hxx
diff -N vcl/inc/abstdlg.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/inc/abstdlg.hxx	3 Feb 2004 17:13:21 -0000	1.3
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _VCL_ABSTDLG_HXX
+#define _VCL_ABSTDLG_HXX
+
+// include ---------------------------------------------------------------
+
+#include <tools/solar.h>
+#include <tools/string.hxx>
+
+class Window;
+class ResId;
+
+class VclAbstractDialog
+{
+public:
+	virtual	USHORT			Execute() = 0;
+	//virtual void			Show( BOOL bVisible = TRUE, USHORT nFlags = 0 ) = 0;
+	virtual					~VclAbstractDialog();
+};
+
+class VclAbstractTerminatedDialog : public VclAbstractDialog
+{
+public:
+	virtual void			EndDialog(long nResult =0) = 0;
+};
+
+class VclAbstractRefreshableDialog : public VclAbstractDialog
+{
+public:
+    virtual void            Update() = 0;
+    virtual void            Sync() = 0;
+};
+
+class VclAbstractDialogFactory
+{
+public:
+	static VclAbstractDialogFactory*	Create();
+	virtual VclAbstractDialog* 			CreateVclDialog( Window* pParent, const ResId& rResId ) = 0;
+};
+
+#endif
+
Index: vcl/inc/accel.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/accel.hxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/inc/accel.hxx	7 Dec 2000 13:37:15 -0000	1.2
+++ vcl/inc/accel.hxx	6 Jan 2004 12:50:31 -0000	1.3
@@ -65,11 +65,11 @@
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
-#ifndef _SV_RESID_HXX
-#include <resid.hxx>
+#ifndef _TOOLS_RESID_HXX
+#include <tools/resid.hxx>
 #endif
-#ifndef _SV_RC_HXX
-#include <rc.hxx>
+#ifndef _TOOLS_RC_HXX
+#include <tools/rc.hxx>
 #endif
 #ifndef _SV_KEYCOD_HXX
 #include <keycod.hxx>
@@ -84,6 +84,8 @@ class ImplAccelEntry;
 
 class Accelerator : public Resource
 {
+	friend class ImplAccelManager;
+
 private:
 	ImplAccelData*	mpData;
 	XubString		maHelpStr;
@@ -99,15 +101,12 @@ private:
 	BOOL*			mpDel;
 
 #if _SOLAR__PRIVATE
-#ifdef _SV_ACCEL_CXX
 	void			ImplInit();
 	void			ImplCopyData( ImplAccelData& rAccelData );
 	void			ImplDeleteData();
 	void			ImplInsertAccel( USHORT nItemId, const KeyCode& rKeyCode,
 									 BOOL bEnable, Accelerator* pAutoAccel );
-#endif
 
-	friend class ImplAccelManager;
 	ImplAccelEntry* ImplGetAccelData( const KeyCode& rKeyCode ) const;
 #endif
 
@@ -118,7 +117,7 @@ public:
 					Accelerator();
 					Accelerator( const Accelerator& rAccel );
 					Accelerator( const ResId& rResId );
-					 ~Accelerator();
+	virtual			~Accelerator();
 
 	virtual void	Activate();
 	virtual void	Deactivate();
Index: vcl/inc/alpha.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/alpha.hxx,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -p -u -r1.3 -r1.6
--- vcl/inc/alpha.hxx	12 Sep 2002 09:30:19 -0000	1.3
+++ vcl/inc/alpha.hxx	21 May 2004 16:20:16 -0000	1.6
@@ -70,15 +70,15 @@
 // - AlphaMask -
 // -------------
 
+class ImageList;
+
 class AlphaMask : private Bitmap
 {
 	friend class BitmapEx;
 	friend class OutputDevice;
+	friend SvStream& operator<<( SvStream&, const ImageList& );
 
 private:
-
-	long					nDummy1;
-	long					nDummy2;
 
 	const Bitmap&			ImplGetBitmap() const;
 	void					ImplSetBitmap( const Bitmap& rBitmap );
Index: vcl/inc/apptypes.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/apptypes.hxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/inc/apptypes.hxx	11 Jul 2001 08:32:52 -0000	1.3
+++ vcl/inc/apptypes.hxx	6 Jan 2004 12:51:37 -0000	1.4
@@ -62,12 +62,12 @@
 #ifndef _VCL_APPTYPES_HXX
 #define _VCL_APPTYPES_HXX
 
-#ifndef _RTTI_HXX
-#include <tools/rtti.hxx>
-#endif
-
 #ifndef _SV_SV_H
 #include <sv.h>
+#endif
+
+#ifndef _RTTI_HXX
+#include <tools/rtti.hxx>
 #endif
 
 // ---------------------
Index: vcl/inc/bitmap.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/bitmap.hxx,v
retrieving revision 1.8
retrieving revision 1.13
diff -u -p -u -r1.8 -r1.13
--- vcl/inc/bitmap.hxx	24 Apr 2003 14:56:11 -0000	1.8
+++ vcl/inc/bitmap.hxx	10 Jun 2004 17:36:43 -0000	1.13
@@ -68,8 +68,8 @@
 #ifndef _SV_MAPMOD_HXX
 #include <mapmod.hxx>
 #endif
-#ifndef _SV_RC_HXX
-#include <rc.hxx>
+#ifndef _TOOLS_RC_HXX
+#include <tools/rc.hxx>
 #endif
 #ifndef _SV_REGION_HXX
 #include <region.hxx>
@@ -106,8 +106,8 @@
 
 // -----------------------------------------------------------------------------
 
-#define BMP_COL_TRANS				Color( 252, 3, 251 )
-
+#define BMP_COL_TRANS					Color( 252, 3, 251 )
+#define BMP_COLOR_MONOCHROME_THRESHOLD	128
 
 // ---------
 // - Enums -
@@ -188,7 +188,9 @@ enum BmpFilter
 enum BmpColorMode
 {
     BMP_COLOR_NORMAL = 0,
-    BMP_COLOR_HIGHCONTRAST = 1
+    BMP_COLOR_HIGHCONTRAST = 1,
+	BMP_COLOR_MONOCHROME_BLACK = 2,
+	BMP_COLOR_MONOCHROME_WHITE = 3
 };
 
 // --------------------
@@ -330,27 +332,6 @@ public:
 	BOOL					ImplMosaic( const BmpFilterParam* pFilterParam, const Link* pProgress );
 	BOOL					ImplPopArt( const BmpFilterParam* pFilterParam, const Link* pProgress );
 
-#ifdef REMOTE_APPSERVER
-
-	void                    ImplDrawRemote( OutputDevice* pOut,
-                                            const Point& rSrcPt, const Size& rSrcSz,
-                                            const Point& rDestPt, const Size& rDestSz ) const;
-	void                    ImplDrawRemoteEx( OutputDevice* pOut,
-                                            const Point& rSrcPt, const Size& rSrcSz,
-                                            const Point& rDestPt, const Size& rDestSz,
-											const Bitmap& rMask ) const;
-	void                    ImplDrawRemoteAlpha( OutputDevice* pOut,
-                                            const Point& rSrcPt, const Size& rSrcSz,
-                                            const Point& rDestPt, const Size& rDestSz,
-											const AlphaMask& rAlpha ) const;
-	void                    ImplDrawRemoteMask( OutputDevice* pOut,
-                                            const Point& rSrcPt, const Size& rSrcSz,
-                                            const Point& rDestPt, const Size& rDestSz,
-											const Color& rColor ) const;
-	void					ImplGetRemoteBmp( OutputDevice* pOut, const Point& rPt, 
-											  const Size& rSz );
-
-#endif // REMOTE_APPSERVER
 #endif // PRIVATE
 
 public:
Index: vcl/inc/bitmapex.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/bitmapex.hxx,v
retrieving revision 1.5
retrieving revision 1.9
diff -u -p -u -r1.5 -r1.9
--- vcl/inc/bitmapex.hxx	22 Oct 2002 17:07:54 -0000	1.5
+++ vcl/inc/bitmapex.hxx	21 May 2004 16:20:50 -0000	1.9
@@ -68,8 +68,8 @@
 #ifndef _SV_ALPHA_HXX
 #include <alpha.hxx>
 #endif
-#ifndef _SV_COLOR_HXX
-#include <color.hxx>
+#ifndef _TOOLS_COLOR_HXX
+#include <tools/color.hxx>
 #endif
 
 // -------------------
@@ -100,23 +100,10 @@ private:
 	Size				aBitmapSize;
 	Color				aTransparentColor;
 	TransparentType		eTransparent;
-	USHORT				nDummy;
 	BOOL				bAlpha;
-	BYTE				cDummy;
 
 public:
 
-#ifdef REMOTE_APPSERVER
-
-	void				ImplDrawRemote( OutputDevice* pOut,
-										const Point& rSrcPt, const Size& rSrcSz,
-										const Point& rDestPt, const Size& rDestSz ) const;
-	void				ImplDrawRemoteAlpha( OutputDevice* pOut,
-										const Point& rSrcPt, const Size& rSrcSz,
-										const Point& rDestPt, const Size& rDestSz ) const;
-
-#endif // REMOTE
-
 #if _SOLAR__PRIVATE
 
     ImpBitmap*			ImplGetBitmapImpBitmap() const { return aBitmap.ImplGetImpBitmap(); }
Index: vcl/inc/brdwin.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/brdwin.hxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/inc/brdwin.hxx	16 Feb 2001 11:09:45 -0000	1.2
+++ vcl/inc/brdwin.hxx	17 Jun 2004 12:01:23 -0000	1.4
@@ -156,14 +156,12 @@ private:
 	BOOL					mbHelpBtn;
 	BOOL					mbDisplayActive;
 
-#ifdef _SV_BRDWIN_CXX
 	void					ImplInit( Window* pParent,
 									  WinBits nStyle, USHORT nTypeStyle,
 									  SystemParentData* pParentData );
 	void					ImplInit( Window* pParent,
 									  WinBits nStyle, USHORT nTypeStyle, 
 									  const ::com::sun::star::uno::Any& );
-#endif
 
 public:
 							ImplBorderWindow( Window* pParent,
@@ -213,8 +211,8 @@ public:
 	void					SetMinOutputSize( long nWidth, long nHeight )
 								{ mnMinWidth = nWidth; mnMinHeight = nHeight; }
 
-	void					GetBorder( long& rLeftBorder, long& rTopBorder,
-									   long& rRightBorder, long& rBottomBorder ) const;
+	void					GetBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+									   sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const;
 	long					CalcTitleWidth() const;
 };
 
@@ -242,10 +240,10 @@ struct ImplBorderFrameData
 	long					mnTrackY;
 	long					mnTrackWidth;
 	long					mnTrackHeight;
-	long					mnLeftBorder;
-	long					mnTopBorder;
-	long					mnRightBorder;
-	long					mnBottomBorder;
+	sal_Int32				mnLeftBorder;
+	sal_Int32				mnTopBorder;
+	sal_Int32				mnRightBorder;
+	sal_Int32				mnBottomBorder;
 	long					mnNoTitleTop;
 	long					mnBorderSize;
 	long					mnTitleHeight;
@@ -279,8 +277,8 @@ public:
 	virtual USHORT			RequestHelp( const Point& rPos, Rectangle& rHelpRect );
 
 	virtual void			Init( OutputDevice* pDev, long nWidth, long nHeight ) = 0;
-	virtual void			GetBorder( long& rLeftBorder, long& rTopBorder,
-									   long& rRightBorder, long& rBottomBorder ) const = 0;
+	virtual void			GetBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+									   sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const = 0;
 	virtual long			CalcTitleWidth() const = 0;
 	virtual void			DrawWindow( USHORT nDrawFlags, OutputDevice* pOutDev = NULL, const Point* pOffset = NULL ) = 0;
 
@@ -305,8 +303,8 @@ public:
 							ImplNoBorderWindowView( ImplBorderWindow* pBorderWindow );
 
 	virtual void			Init( OutputDevice* pDev, long nWidth, long nHeight );
-	virtual void			GetBorder( long& rLeftBorder, long& rTopBorder,
-									   long& rRightBorder, long& rBottomBorder ) const;
+	virtual void			GetBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+									   sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const;
 	virtual long			CalcTitleWidth() const;
 	virtual void			DrawWindow( USHORT nDrawFlags, OutputDevice* pOutDev, const Point* pOffset );
 };
@@ -324,17 +322,17 @@ class ImplSmallBorderWindowView : public
 	OutputDevice*			mpOutDev;
 	long					mnWidth;
 	long					mnHeight;
-	long					mnLeftBorder;
-	long					mnTopBorder;
-	long					mnRightBorder;
-	long					mnBottomBorder;
+	sal_Int32				mnLeftBorder;
+	sal_Int32				mnTopBorder;
+	sal_Int32				mnRightBorder;
+	sal_Int32				mnBottomBorder;
 
 public:
 							ImplSmallBorderWindowView( ImplBorderWindow* pBorderWindow );
 
 	virtual void			Init( OutputDevice* pOutDev, long nWidth, long nHeight );
-	virtual void			GetBorder( long& rLeftBorder, long& rTopBorder,
-									   long& rRightBorder, long& rBottomBorder ) const;
+	virtual void			GetBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+									   sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const;
 	virtual long			CalcTitleWidth() const;
 	virtual void			DrawWindow( USHORT nDrawFlags, OutputDevice* pOutDev, const Point* pOffset );
 };
@@ -363,8 +361,8 @@ public:
 	virtual USHORT			RequestHelp( const Point& rPos, Rectangle& rHelpRect );
 
 	virtual void			Init( OutputDevice* pDev, long nWidth, long nHeight );
-	virtual void			GetBorder( long& rLeftBorder, long& rTopBorder,
-									   long& rRightBorder, long& rBottomBorder ) const;
+	virtual void			GetBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+									   sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const;
 	virtual long			CalcTitleWidth() const;
 	virtual void			DrawWindow( USHORT nDrawFlags, OutputDevice* pOutDev, const Point* pOffset );
 };
Index: vcl/inc/btndlg.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/btndlg.hxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/inc/btndlg.hxx	7 Dec 2000 13:37:15 -0000	1.2
+++ vcl/inc/btndlg.hxx	6 Jan 2004 12:53:29 -0000	1.3
@@ -101,20 +101,15 @@ private:
 	BOOL				mbFormat;
 	Link				maClickHdl;
 
-#if _SOLAR__PRIVATE
-#ifdef _SV_BTNDLG_CXX
 	void				ImplInitData();
 	PushButton* 		ImplCreatePushButton( USHORT nBtnFlags );
 	ImplBtnDlgItem* 	ImplGetItem( USHORT nId ) const;
 						DECL_LINK( ImplClickHdl, PushButton* pBtn );
 	void				ImplPosControls();
-#endif
-protected:
-	long				ImplGetButtonSize();
-#endif
 
 protected:
 						ButtonDialog( WindowType nType );
+	long				ImplGetButtonSize();
 
 public:
 						ButtonDialog( Window* pParent, WinBits nStyle = WB_STDDIALOG );
Index: vcl/inc/button.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/button.hxx,v
retrieving revision 1.8
retrieving revision 1.11
diff -u -p -u -r1.8 -r1.11
--- vcl/inc/button.hxx	17 Apr 2003 17:55:12 -0000	1.8
+++ vcl/inc/button.hxx	10 May 2004 15:40:59 -0000	1.11
@@ -78,6 +78,10 @@
 #include <bitmap.hxx>
 #endif
 
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+
 class UserDrawEvent;
 
 // ----------
@@ -124,7 +128,6 @@ protected:
     Image           maImageHC;
     BitmapEx*       mpBitmapEx;
     BitmapEx*       mpBitmapExHC;
-    void*           mpDummy;
     SymbolType      meSymbol;
     ImageAlign      meImageAlign;
     TriState        meState;
@@ -133,12 +136,9 @@ protected:
     USHORT          mnButtonState;
     BOOL            mbPressed;
     BOOL            mbInUserDraw;
-    BOOL            mbDummy1;
-    BOOL            mbDummy2;
     Link            maToggleHdl;
 
 #if _SOLAR__PRIVATE
-#ifdef _SV_BUTTON_CXX
     void            ImplInitData();
     WinBits         ImplInitStyle( const Window* pPrevWindow, WinBits nStyle );
     void            ImplInitSettings( BOOL bFont, BOOL bForeground, BOOL bBackground );
@@ -148,7 +148,6 @@ protected:
     USHORT          ImplGetTextStyle() const;
     BOOL            IsSymbol() const { return ( (meSymbol != SYMBOL_NOSYMBOL) && (meSymbol != SYMBOL_IMAGE) ); }
     BOOL            IsImage() const { return !!maImage; }
-#endif
 
 protected:
     void            ImplInit( Window* pParent, WinBits nStyle );
@@ -180,6 +179,7 @@ public:
     virtual void    LoseFocus();
     virtual void    StateChanged( StateChangedType nType );
     virtual void    DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
     virtual void    UserDraw( const UserDrawEvent& rUDEvt );
 
     virtual void    Toggle();
@@ -253,10 +246,8 @@ inline BOOL PushButton::IsChecked() cons
 
 class OKButton : public PushButton
 {
-#ifdef _SV_BUTTON_CXX
 private:
     void            ImplInit( Window* pParent, WinBits nStyle );
-#endif
 
 public:
                     OKButton( Window* pParent, WinBits nStyle = WB_DEFBUTTON );
@@ -271,10 +262,8 @@ public:
 
 class CancelButton : public PushButton
 {
-#ifdef _SV_BUTTON_CXX
 private:
     void            ImplInit( Window* pParent, WinBits nStyle );
-#endif
 
 public:
                     CancelButton( Window* pParent, WinBits nStyle = 0 );
@@ -289,10 +278,8 @@ public:
 
 class HelpButton : public PushButton
 {
-#ifdef _SV_BUTTON_CXX
 private:
     void            ImplInit( Window* pParent, WinBits nStyle );
-#endif
 
 public:
                     HelpButton( Window* pParent, WinBits nStyle = 0 );
@@ -318,12 +305,9 @@ private:
     BOOL            mbSaveValue;
     BOOL            mbRadioCheck;
     BOOL            mbStateChanged;
-    BOOL            mbDummy1;
-    BOOL            mbDummy2;
     Link            maToggleHdl;
 
 #if _SOLAR__PRIVATE
-#ifdef _SV_BUTTON_CXX
     void            ImplInitData();
     WinBits         ImplInitStyle( const Window* pPrevWindow, WinBits nStyle );
     void            ImplInitSettings( BOOL bFont, BOOL bForeground, BOOL bBackground );
@@ -336,7 +320,6 @@ private:
                               bool bLayout = false );
     void            ImplDrawRadioButton( bool bLayout = false );
     void            ImplUncheckAllOther();
-#endif
 
 protected:
     void            ImplInit( Window* pParent, WinBits nStyle );
@@ -376,6 +359,7 @@ public:
     virtual void    LoseFocus();
     virtual void    StateChanged( StateChangedType nType );
     virtual void    DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
     virtual void    Toggle();
 
@@ -428,7 +412,6 @@ private:
     Link            maToggleHdl;
 
 #if _SOLAR__PRIVATE
-#ifdef _SV_BUTTON_CXX
     void            ImplInitData();
     WinBits         ImplInitStyle( const Window* pPrevWindow, WinBits nStyle );
     void            ImplInitSettings( BOOL bFont, BOOL bForeground, BOOL bBackground );
@@ -439,7 +422,6 @@ private:
                               Rectangle& rStateRect,
                               Rectangle& rMouseRect, Rectangle& rFocusRect, bool bLayout );
     void            ImplDrawCheckBox( bool bLayout = false );
-#endif
 
 protected:
     void            ImplInit( Window* pParent, WinBits nStyle );
@@ -465,6 +447,7 @@ public:
     virtual void    LoseFocus();
     virtual void    StateChanged( StateChangedType nType );
     virtual void    DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
     virtual void    Toggle();
 
Index: vcl/inc/cmdevt.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/cmdevt.hxx,v
retrieving revision 1.10.250.1
retrieving revision 1.12
diff -u -p -u -r1.10.250.1 -r1.12
--- vcl/inc/cmdevt.hxx	9 Jan 2004 18:13:38 -0000	1.10.250.1
+++ vcl/inc/cmdevt.hxx	6 Jan 2004 12:54:08 -0000	1.12
@@ -101,7 +101,6 @@ private:
     xub_StrLen          mnOldTextLen;
     USHORT              mnCursorFlags;
     BOOL                mbOnlyCursor;
-    BOOL                mbDummy;
 
 public:
                         CommandExtTextInputData();
Index: vcl/inc/combobox.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/combobox.hxx,v
retrieving revision 1.12
retrieving revision 1.14
diff -u -p -u -r1.12 -r1.14
--- vcl/inc/combobox.hxx	11 Apr 2003 17:24:42 -0000	1.12
+++ vcl/inc/combobox.hxx	18 May 2004 10:47:56 -0000	1.14
@@ -192,6 +192,7 @@ public:
     BOOL            IsUserDrawEnabled() const;
 
     void            DrawEntry( const UserDrawEvent& rEvt, BOOL bDrawImage, BOOL bDrawText, BOOL bDrawTextAtImagePos = FALSE );
+    void            SetBorderStyle( USHORT nBorderStyle );
 
     void            SetSeparatorPos( USHORT n );
     void            SetSeparatorPos();
Index: vcl/inc/controllayout.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/controllayout.hxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/inc/controllayout.hxx	16 May 2002 11:52:49 -0000	1.3
+++ vcl/inc/controllayout.hxx	18 May 2004 10:48:10 -0000	1.4
@@ -103,6 +103,20 @@ struct ControlLayoutData
     // returns the interval [start,end] of line nLine
     // returns [-1,-1] for an invalid line
     Pair GetLineStartEnd( long nLine ) const;
+    /** ToRelativeLineIndex changes a layout data index to a count relative to its line.
+        
+    <p>This is equivalent to getting the line start/end pairs with
+    <member>GetLineStartEnd</member> until the index lies within [start,end] of a line
+    </p>
+
+    @param nIndex
+    the absolute index inside the display text to be changed to a relative index
+
+    @returns
+    the relative index inside the displayed line or -1 if the absolute index does
+    not match any line
+    */
+    long ToRelativeLineIndex( long nIndex ) const;
 };
 
 } // namespace vcl
Index: vcl/inc/ctrl.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/ctrl.hxx,v
retrieving revision 1.5
retrieving revision 1.8
diff -u -p -u -r1.5 -r1.8
--- vcl/inc/ctrl.hxx	16 May 2002 11:52:49 -0000	1.5
+++ vcl/inc/ctrl.hxx	18 May 2004 10:48:23 -0000	1.8
@@ -73,6 +73,10 @@
 #include <window.hxx>
 #endif
 
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+
 // forward
 namespace vcl { struct ControlLayoutData; }
 
@@ -83,27 +87,26 @@ namespace vcl { struct ControlLayoutData
 class Control : public Window
 {
 protected:
-	mutable vcl::ControlLayoutData*			mpLayoutData;
+	mutable vcl::ControlLayoutData*	mpLayoutData;
 private:
-	long										mnDummy1;
-	BOOL										mbHasFocus;
-	BOOL										mbDummy1;
-	BOOL										mbDummy2;
-	BOOL										mbDummy3;
-	Link										maGetFocusHdl;
-	Link										maLoseFocusHdl;
+	BOOL							mbHasFocus;
+	Link							maGetFocusHdl;
+	Link							maLoseFocusHdl;
 
-#ifdef _SV_CTRL_CXX
 	void			ImplInitData();
-public:
-    void			ImplSubControlLayoutChanged() const;
-#endif
+
 protected:
 					Control( WindowType nType );
-    virtual void  FillLayoutData() const;
+    virtual void	FillLayoutData() const;
 
     // helper method for composite controls
     void			AppendLayoutData( const Control& rSubControl ) const;
+
+#if _SOLAR__PRIVATE
+public:
+    void			ImplClearLayoutData() const;
+#endif    
+
 public:
 					Control( Window* pParent, WinBits nWinStyle = 0 );
 					Control( Window* pParent, const ResId& rResId );
@@ -129,6 +132,20 @@ public:
     // returns the interval [start,end] of line nLine
     // returns [-1,-1] for an invalid line
     Pair GetLineStartEnd( long nLine ) const;
+    /** ToRelativeLineIndex changes a layout data index to a count relative to its line.
+        
+    <p>This is equivalent to getting the line start/end pairs with
+    <member>GetLineStartEnd</member> until the index lies within [start,end] of a line
+    </p>
+
+    @param nIndex
+    the absolute index inside the display text to be changed to a relative index
+
+    @returns
+    the relative index inside the displayed line or -1 if the absolute index does
+    not match any line
+    */
+    long ToRelativeLineIndex( long nIndex ) const;
     
 
 	void			SetGetFocusHdl( const Link& rLink ) { maGetFocusHdl = rLink; }
Index: vcl/inc/cursor.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/cursor.hxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/inc/cursor.hxx	27 Mar 2003 17:57:20 -0000	1.3
+++ vcl/inc/cursor.hxx	6 Jan 2004 12:55:28 -0000	1.4
@@ -66,6 +66,10 @@
 #include <tools/gen.hxx>
 #endif
 
+#ifndef _LINK_HXX
+#include <tools/link.hxx>
+#endif
+
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
@@ -103,11 +107,9 @@ private:
 
 #if _SOLAR__PRIVATE
 public:
-#ifdef _SV_CURSOR_CXX
 	void			ImplDraw();
 	void			ImplRestore();
 					DECL_LINK( ImplTimerHdl, AutoTimer* );
-#endif
 	void			ImplShow( BOOL bDrawDirect = TRUE );
 	void			ImplHide();
 	void			ImplNew();
Index: vcl/inc/cvtsvm.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/cvtsvm.hxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/inc/cvtsvm.hxx	7 Dec 2000 13:37:15 -0000	1.3
+++ vcl/inc/cvtsvm.hxx	6 Jan 2004 12:55:49 -0000	1.4
@@ -129,7 +129,6 @@ class SVMConverter
 {
 private:
 #if _SOLAR__PRIVATE
-#ifdef _SV_CVTSVM_CXX
 	void				ImplConvertFromSVM1( SvStream& rIStm, GDIMetaFile& rMtf );
 	void				ImplConvertToSVM1( SvStream& rOStm, GDIMetaFile& rMtf );
 	ULONG				ImplWriteActions( SvStream& rOStm, GDIMetaFile& rMtf,
@@ -137,7 +136,6 @@ private:
 										  Color& rLineCol, Stack& rLineColStack,
 										  rtl_TextEncoding& rActualCharSet );
 #endif
-#endif // __PRIVATE
 
 public:
 						SVMConverter( SvStream& rIStm, GDIMetaFile& rMtf, ULONG nConvertMode  );
Index: vcl/inc/decoview.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/decoview.hxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/inc/decoview.hxx	27 Mar 2003 17:57:20 -0000	1.3
+++ vcl/inc/decoview.hxx	10 May 2004 15:41:25 -0000	1.4
@@ -88,6 +88,7 @@ class OutputDevice;
 #define FRAME_DRAW_DOUBLEIN 				((USHORT)0x0004)
 #define FRAME_DRAW_DOUBLEOUT				((USHORT)0x0005)
 #define FRAME_DRAW_MENU                     ((USHORT)0x0010)
+#define FRAME_DRAW_WINDOWBORDER             ((USHORT)0x0020)
 #define FRAME_DRAW_MONO 					((USHORT)0x1000)
 #define FRAME_DRAW_NODRAW					((USHORT)0x8000)
 #define FRAME_DRAW_STYLE					((USHORT)0x000F)
Index: vcl/inc/dialog.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/dialog.hxx,v
retrieving revision 1.7.252.1
retrieving revision 1.10
diff -u -p -u -r1.7.252.1 -r1.10
--- vcl/inc/dialog.hxx	31 Oct 2003 15:43:22 -0000	1.7.252.1
+++ vcl/inc/dialog.hxx	17 Jun 2004 12:02:16 -0000	1.10
@@ -81,20 +81,16 @@ class Dialog : public SystemWindow
 {
 private:
 	Window* 		mpDialogParent;
-	long			mnDummy;
 	Dialog* 		mpPrevExecuteDlg;
 	long*			mpResult;
-	long			mnDummy1;
 	long			mnMousePositioned;
 	BOOL			mbInExecute;
 	BOOL			mbOldSaveBack;
 	BOOL			mbInClose;
 	BOOL			mbModalMode;
 
-#ifdef _SV_DIALOG_CXX
 	void			ImplInitData();
 	void			ImplInitSettings();
-#endif
 
 #if _SOLAR__PRIVATE
 protected:
@@ -126,8 +122,8 @@ public:
 	void			EndDialog( long nResult = 0 );
 	static void		EndAllDialogs( Window* pParent=NULL );
 
-    void            GetDrawWindowBorder( long& rLeftBorder, long& rTopBorder,
-                                         long& rRightBorder, long& rBottomBorder ) const;
+    void            GetDrawWindowBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+                                         sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const;
 
 	void			SetModalInputMode( BOOL bModal );
 	void			SetModalInputMode( BOOL bModal, BOOL bSubModalDialogs );
Index: vcl/inc/dockwin.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/dockwin.hxx,v
retrieving revision 1.4
retrieving revision 1.6
diff -u -p -u -r1.4 -r1.6
--- vcl/inc/dockwin.hxx	24 Apr 2002 15:41:07 -0000	1.4
+++ vcl/inc/dockwin.hxx	17 Jun 2004 12:02:29 -0000	1.6
@@ -89,10 +89,10 @@ private:
 	long			mnTrackY;
 	long			mnTrackWidth;
 	long			mnTrackHeight;
-	long			mnDockLeft;
-	long			mnDockTop;
-	long			mnDockRight;
-	long			mnDockBottom;
+	sal_Int32			mnDockLeft;
+	sal_Int32			mnDockTop;
+	sal_Int32			mnDockRight;
+	sal_Int32			mnDockBottom;
 	WinBits 		mnFloatBits;
 	BOOL			mbDockCanceled:1,
 					mbDockPrevented:1,
@@ -106,15 +106,10 @@ private:
 					mbPined:1,
 					mbRollUp:1,
 					mbDockBtn:1,
-					mbHideBtn:1,
-					mbDummy1:1,
-					mbDummy2:1,
-					mbDummy3:1;
+					mbHideBtn:1;
 
 #if _SOLAR__PRIVATE
-#ifdef _SV_DOCKWIN_CXX
 	void			ImplInitData();
-#endif
 
 protected:
 	void			ImplInit( Window* pParent, WinBits nStyle );
Index: vcl/inc/edit.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/edit.hxx,v
retrieving revision 1.11
retrieving revision 1.13
diff -u -p -u -r1.11 -r1.13
--- vcl/inc/edit.hxx	27 Mar 2003 17:57:20 -0000	1.11
+++ vcl/inc/edit.hxx	10 May 2004 15:41:45 -0000	1.13
@@ -139,7 +139,6 @@ private:
 	Link				maAutocompleteHdl;
 
 #if _SOLAR__PRIVATE
-#ifdef _SV_EDIT_CXX
 						DECL_LINK( ImplUpdateDataHdl, Timer* );
 
 	void				ImplInitData();
@@ -164,7 +163,6 @@ private:
     void                ImplPaste( ::com::sun::star::uno::Reference< ::com::sun::star::datatransfer::clipboard::XClipboard >& rxClipboard );
     long                ImplGetExtraOffset() const;
 #endif
-#endif
 
 protected:
 #if _SOLAR__PRIVATE
@@ -174,6 +172,7 @@ protected:
 	void				ImplLoadRes( const ResId& rResId );
 	void				ImplSetSelection( const Selection& rSelection, BOOL bPaint = TRUE );
 #endif
+    int                 ImplGetNativeControlType();
 
 	::com::sun::star::uno::Reference< ::com::sun::star::datatransfer::dnd::XDragSourceListener > mxDnDListener;
 
Index: vcl/inc/field.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/field.hxx,v
retrieving revision 1.9
retrieving revision 1.12
diff -u -p -u -r1.9 -r1.12
--- vcl/inc/field.hxx	5 Nov 2001 13:00:00 -0000	1.9
+++ vcl/inc/field.hxx	2 Apr 2004 10:35:02 -0000	1.12
@@ -105,17 +105,10 @@ private:
     BOOL                    mbEmptyFieldValue;
     BOOL                    mbEmptyFieldValueEnabled;
     BOOL                    mbDefaultLocale;
-    ULONG                   mnDummy1;
-    BOOL                    mbDummy1;
-    BOOL                    mbDummy2;
-    BOOL                    mbDummy3;
-    BOOL                    mbDummy4;
 
 protected:
-#if defined( _SV_FIELD_CXX ) || defined( _SV_FIELD2_CXX ) || defined( VCL_LONGCURR_CXX )
     void                    ImplSetText( const XubString& rText, Selection* pNewSel = NULL );
     BOOL                    ImplGetEmptyFieldValue() const  { return mbEmptyFieldValue; }
-#endif
 
     void                    SetFieldText( const XubString& rText, BOOL bKeepSelection );
     void                    SetEmptyFieldValueData( BOOL bValue ) { mbEmptyFieldValue = bValue; }
@@ -125,7 +118,7 @@ protected:
 
 public:
                             FormatterBase( Edit* pField = NULL );
-                            ~FormatterBase();
+    virtual                 ~FormatterBase();
 
     const LocaleDataWrapper& GetLocaleDataWrapper() const;
 
@@ -174,21 +163,16 @@ private:
     XubString               maFieldString;
     XubString               maLiteralMask;
     USHORT                  mnFormatFlags;
-    USHORT                  mnDummy1;
     BOOL                    mbSameMask;
     BOOL                    mbInPattKeyInput;
-    BOOL                    mbDummy1;
-    BYTE                    mbDummy2;
 
 protected:
                             PatternFormatter();
 
-#ifdef _SV_FIELD2_CXX
     void                    ImplLoadRes( const ResId& rResId );
     void                    ImplSetMask( const ByteString& rEditMask, const XubString& rLiteralMask );
     BOOL                    ImplIsSameMask() const { return mbSameMask; }
     BOOL&                   ImplGetInPattKeyInput() { return mbInPattKeyInput; }
-#endif
 
 public:
                             ~PatternFormatter();
@@ -217,9 +201,7 @@ public:
 class NumericFormatter : public FormatterBase
 {
 private:
-#ifdef _SV_FIELD_CXX
     void                    ImplInit();
-#endif
 
 protected:
     long                    mnFieldValue;
@@ -233,8 +215,6 @@ protected:
     USHORT                  mnDumym2;
     BOOL                    mbThousandSep;
     BOOL                    mbShowTrailingZeros;
-    BYTE                    mbDummy2;
-    BYTE                    mbDummy3;
 
     // Eigentlich nur am entsprechenden Feld einstellbar (fuer Interaktion),
     // wird aber in allen Verschiedenen Ableitungen benoetigt
@@ -255,12 +235,10 @@ protected:
     void                    FieldFirst();
     void                    FieldLast();
 
-#ifdef _SV_FIELD_CXX
     void                    ImplLoadRes( const ResId& rResId );
     BOOL                    ImplNumericReformat( const XubString& rStr, double& rValue, XubString& rOutStr );
     void                    ImplNewFieldValue( long nNewValue );
     void                    ImplSetUserValue( long nNewValue, Selection* pNewSelection = NULL );
-#endif
 
 public:
                             ~NumericFormatter();
@@ -308,9 +286,7 @@ public:
 class MetricFormatter : public NumericFormatter
 {
 private:
-#ifdef _SV_FIELD_CXX
     void                    ImplInit();
-#endif
 
 protected:
     XubString               maCustomUnitText;
@@ -324,10 +300,8 @@ protected:
 
     virtual XubString       CreateFieldText( long nValue ) const;
 
-#ifdef _SV_FIELD_CXX
     void                    ImplLoadRes( const ResId& rResId );
     BOOL                    ImplMetricReformat( const XubString& rStr, double& rValue, XubString& rOutStr );
-#endif
 
 public:
                             ~MetricFormatter();
@@ -368,23 +342,13 @@ class CurrencyFormatter : public Numeric
 {
 private:
     String                  maCurrencySymbol;
-    BOOL                    mbDummy1;
-    BOOL                    mbDummy2;
-    BYTE                    mbDummy3;
-    BYTE                    mbDummy4;
 
-#ifdef _SV_FIELD_CXX
     void                    ImplInit();
-#endif
 
 protected:
                             CurrencyFormatter();
-
     virtual XubString       CreateFieldText( long nValue ) const;
-
-#ifdef _SV_FIELD_CXX
     BOOL                    ImplCurrencyReformat( const XubString& rStr, XubString& rOutStr );
-#endif
 
 public:
                             ~CurrencyFormatter();
@@ -417,19 +381,13 @@ private:
     BOOL                    mbShowDateCentury;
     USHORT                  mnDateFormat;
     ULONG                   mnExtDateFormat;
-    BOOL                    mbDummy1;
-    BOOL                    mbDummy2;
-    BYTE                    mbDummy3;
-    BYTE                    mbDummy4;
+    BOOL                    mbEnforceValidValue;
 
-#ifdef _SV_FIELD2_CXX
     void                    ImplInit();
-#endif
 
 protected:
                             DateFormatter();
 
-#ifdef _SV_FIELD2_CXX
     void                    ImplLoadRes( const ResId& rResId );
     const Date&             ImplGetFieldDate() const    { return maFieldDate; }
     BOOL                    ImplDateReformat( const XubString& rStr, XubString& rOutStr,
@@ -440,7 +398,8 @@ protected:
                                                const AllSettings& rSettings ) const;
     void                    ImplNewFieldValue( const Date& rDate );
     CalendarWrapper&        GetCalendarWrapper() const;
-#endif
+
+    BOOL                    ImplAllowMalformedInput() const;
 
 public:
                             ~DateFormatter();
@@ -450,11 +409,6 @@ public:
 
     virtual void            SetLocale( const ::com::sun::star::lang::Locale& rLocale );
 
-#if SUPD < 651
-    // MT 11/01: Seems that nobody uses them, I only want to use the ExtDateFormat now ( ## )
-    void                    SetDateFormat( DateFormat eFormat );
-    DateFormat              GetDateFormat() const;
-#endif
 
     void                    SetExtDateFormat( ExtDateFieldFormat eFormat );
     ExtDateFieldFormat      GetExtDateFormat( BOOL bResolveSystemFormat = FALSE ) const;
@@ -489,6 +443,23 @@ public:
 
     static void             ExpandCentury( Date& rDate );
     static void             ExpandCentury( Date& rDate, USHORT nTwoDigitYearStart );
+
+    static Date             GetInvalidDate() { return Date( 0, 0, 0 ); }
+
+    /** enables or disables the enforcement of valid values
+
+        If this is set to <TRUE/> (which is the default), then GetDate will always return a valid
+        date, no matter whether the current text can really be interpreted as date. (Note: this
+        is the compatible bahavior).
+
+        If this is set to <FALSE/>, the GetDate will return GetInvalidDate, in case the current text
+        cannot be interpreted as date.
+
+        In addition, if this is set to <FALSE/>, the text in the field will <em>not</em> be corrected
+        when the control loses the focus - instead, the invalid input will be preserved.
+    */
+    void                    EnforceValidValue( BOOL _bEnforce ) { mbEnforceValidValue = _bEnforce; }
+    inline BOOL             IsEnforceValidValue( ) const { return mbEnforceValidValue; }
 };
 
 
@@ -507,27 +478,20 @@ private:
     USHORT                  mnTimeFormat;
     BOOL                    mbDuration;
     BOOL                    mbEmptyTime;
-    ULONG                   mnDummy1;
-    BOOL                    mbDummy1;
-    BOOL                    mbDummy2;
-    BYTE                    mbDummy3;
-    BYTE                    mbDummy4;
+    BOOL                    mbEnforceValidValue;
 
-#ifdef _SV_FIELD2_CXX
     void                    ImplInit();
-#endif
 
 protected:
     Time                    maFieldTime;
 
                             TimeFormatter();
 
-#ifdef _SV_FIELD2_CXX
     void                    ImplLoadRes( const ResId& rResId );
     BOOL                    ImplTimeReformat( const XubString& rStr, XubString& rOutStr );
     void                    ImplNewFieldValue( const Time& rTime );
     void                    ImplSetUserTime( const Time& rNewTime, Selection* pNewSelection = NULL );
-#endif
+    BOOL                    ImplAllowMalformedInput() const;
 
 public:
                             ~TimeFormatter();
@@ -557,6 +521,23 @@ public:
     void                    SetEmptyTime() { FormatterBase::SetEmptyFieldValue(); }
     BOOL                    IsEmptyTime() const { return FormatterBase::IsEmptyFieldValue(); }
     Time                    GetCorrectedTime() const { return maCorrectedTime; }
+
+    static Time             GetInvalidTime() { return Time( 99, 99, 99 ); }
+
+    /** enables or disables the enforcement of valid values
+
+        If this is set to <TRUE/> (which is the default), then GetTime will always return a valid
+        time, no matter whether the current text can really be interpreted as time. (Note: this
+        is the compatible bahavior).
+
+        If this is set to <FALSE/>, the GetTime will return GetInvalidTime, in case the current text
+        cannot be interpreted as time.
+
+        In addition, if this is set to <FALSE/>, the text in the field will <em>not</em> be corrected
+        when the control loses the focus - instead, the invalid input will be preserved.
+    */
+    void                    EnforceValidValue( BOOL _bEnforce ) { mbEnforceValidValue = _bEnforce; }
+    inline BOOL             IsEnforceValidValue( ) const { return mbEnforceValidValue; }
 };
 
 
@@ -583,10 +564,8 @@ public:
 
 class NumericField : public SpinField, public NumericFormatter
 {
-#ifdef _SV_FIELD_CXX
 protected:
     void                    ImplLoadRes( const ResId& rResId );
-#endif
 
 public:
                             NumericField( Window* pParent, WinBits nWinStyle );
@@ -612,10 +591,8 @@ public:
 
 class MetricField : public SpinField, public MetricFormatter
 {
-#ifdef _SV_FIELD_CXX
 protected:
     void                    ImplLoadRes( const ResId& rResId );
-#endif
 
 public:
                             MetricField( Window* pParent, WinBits nWinStyle );
@@ -663,10 +640,8 @@ public:
 
 class CurrencyField : public SpinField, public CurrencyFormatter
 {
-#ifdef _SV_FIELD_CXX
 protected:
     void                    ImplLoadRes( const ResId& rResId );
-#endif
 
 public:
                             CurrencyField( Window* pParent, WinBits nWinStyle );
@@ -696,11 +671,9 @@ private:
     Date                    maFirst;
     Date                    maLast;
 
-#ifdef _SV_FIELD2_CXX
 protected:
     void                    ImplDateSpinArea( BOOL bUp );
     void                    ImplLoadRes( const ResId& rResId );
-#endif
 
 public:
                             DateField( Window* pParent, WinBits nWinStyle );
@@ -739,11 +707,9 @@ private:
     Time                    maFirst;
     Time                    maLast;
 
-#ifdef _SV_FIELD2_CXX
 protected:
     void                    ImplTimeSpinArea( BOOL bUp );
     void                    ImplLoadRes( const ResId& rResId );
-#endif
 
 public:
                             TimeField( Window* pParent, WinBits nWinStyle );
Index: vcl/inc/fixbrd.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/fixbrd.hxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/inc/fixbrd.hxx	7 Dec 2000 13:37:15 -0000	1.2
+++ vcl/inc/fixbrd.hxx	6 Jan 2004 12:57:59 -0000	1.3
@@ -91,18 +91,13 @@ class FixedBorder : public Control
 private:
 	USHORT			mnType;
 	BOOL			mbTransparent;
-	BOOL			mbDummy1;
 
-#if _SOLAR__PRIVATE
-#ifdef _SV_FIXBRD_CXX
 private:
 	void			ImplInit( Window* pParent, WinBits nStyle );
 	WinBits 		ImplInitStyle( WinBits nStyle );
 	void			ImplInitSettings();
 	void			ImplDraw( OutputDevice* pDev, ULONG nDrawFlags,
 							  const Point& rPos, const Size& rSize );
-#endif
-#endif
 
 public:
 					FixedBorder( Window* pParent, WinBits nStyle = 0 );
Index: vcl/inc/fixed.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/fixed.hxx,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -p -u -r1.5 -r1.6
--- vcl/inc/fixed.hxx	29 Apr 2002 17:46:17 -0000	1.5
+++ vcl/inc/fixed.hxx	6 Jan 2004 12:58:20 -0000	1.6
@@ -84,14 +84,12 @@ class UserDrawEvent;
 class FixedText : public Control
 {
 #if _SOLAR__PRIVATE
-#ifdef _SV_FIXED_CXX
 private:
     void            ImplInit( Window* pParent, WinBits nStyle );
     WinBits         ImplInitStyle( WinBits nStyle );
     void            ImplInitSettings( BOOL bFont, BOOL bForeground, BOOL bBackground );
     void            ImplDraw( OutputDevice* pDev, ULONG nDrawFlags,
                               const Point& rPos, const Size& rSize, bool bFillLayout = false ) const;
-#endif
 public:
     static USHORT   ImplGetTextStyle( WinBits nWinBits );
 #endif
@@ -116,17 +114,15 @@ public:
 
 class FixedLine : public Control
 {
-#if _SOLAR__PRIVATE
-#ifdef _SV_FIXED_CXX
 private:
     void            ImplInit( Window* pParent, WinBits nStyle );
     WinBits         ImplInitStyle( WinBits nStyle );
     void            ImplInitSettings( BOOL bFont, BOOL bForeground, BOOL bBackground );
     void 			ImplDraw( bool bLayout = false );
-#endif
-#endif
+
 protected:
-    virtual void  FillLayoutData() const;
+    virtual void	FillLayoutData() const;
+
 public:
                     FixedLine( Window* pParent, WinBits nStyle = WB_HORZ );
                     FixedLine( Window* pParent, const ResId& rResId );
@@ -148,19 +144,14 @@ private:
     Bitmap          maBitmap;
     Bitmap          maBitmapHC;
 
-#if _SOLAR__PRIVATE
-#ifdef _SV_FIXED_CXX
-private:
     void            ImplInit( Window* pParent, WinBits nStyle );
     WinBits         ImplInitStyle( WinBits nStyle );
     void            ImplInitSettings();
     void            ImplDraw( OutputDevice* pDev, ULONG nDrawFlags,
                               const Point& rPos, const Size& rSize );
-#endif
 
 protected:
     void            ImplLoadRes( const ResId& rResId );
-#endif
 
 public:
                     FixedBitmap( Window* pParent, WinBits nStyle = 0 );
@@ -190,19 +181,15 @@ private:
     Image           maImageHC;
     BOOL            mbInUserDraw;
 
-#if _SOLAR__PRIVATE
-#ifdef _SV_FIXED_CXX
 private:
     void            ImplInit( Window* pParent, WinBits nStyle );
     WinBits         ImplInitStyle( WinBits nStyle );
     void            ImplInitSettings();
     void            ImplDraw( OutputDevice* pDev, ULONG nDrawFlags,
                               const Point& rPos, const Size& rSize );
-#endif
 
 protected:
     void            ImplLoadRes( const ResId& rResId );
-#endif
 
 public:
                     FixedImage( Window* pParent, WinBits nStyle = 0 );
Index: vcl/inc/floatwin.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/floatwin.hxx,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -p -u -r1.5 -r1.6
--- vcl/inc/floatwin.hxx	31 Oct 2001 19:28:50 -0000	1.5
+++ vcl/inc/floatwin.hxx	6 Jan 2004 12:58:54 -0000	1.6
@@ -114,7 +114,6 @@ private:
 	FloatingWindow* mpNextFloat;
 	Window* 		mpFirstPopupModeWin;
 	ToolBox*		mpBox;
-	void*			mpDummy;
 	Rectangle		maFloatRect;
 	ULONG			mnPostId;
 	ULONG			mnPopupModeFlags;
@@ -131,10 +130,8 @@ private:
 	Link			maPopupModeEndHdl;
 
 #if _SOLAR__PRIVATE
-#ifdef _SV_FLOATWIN_CXX
 	void			ImplCallPopupModeEnd();
 					DECL_LINK( ImplEndPopupModeHdl, void* );
-#endif
 
 protected:
 	void			ImplInit( Window* pParent, WinBits nStyle );
Index: vcl/inc/fntstyle.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/fntstyle.hxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/inc/fntstyle.hxx	23 Mar 2001 11:44:51 -0000	1.2
+++ vcl/inc/fntstyle.hxx	6 Jan 2004 12:59:13 -0000	1.3
@@ -62,6 +62,7 @@
 #ifndef _VCL_FNTSTYLE_HXX
 #define _VCL_FNTSTYLE_HXX
 
+#include <tools/solar.h>
 #include <sal/types.h>
 
 // --------------
Index: vcl/inc/font.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/font.hxx,v
retrieving revision 1.6
retrieving revision 1.8
diff -u -p -u -r1.6 -r1.8
--- vcl/inc/font.hxx	1 Aug 2001 12:32:45 -0000	1.6
+++ vcl/inc/font.hxx	6 Jan 2004 12:59:38 -0000	1.8
@@ -71,8 +71,8 @@
 #ifndef _TOOLS_LANG_HXX
 #include <tools/lang.hxx>
 #endif
-#ifndef _SV_COLOR_HXX
-#include <color.hxx>
+#ifndef _TOOLS_COLOR_HXX
+#include <tools/color.hxx>
 #endif
 #ifndef _VCL_VCLENUM_HXX
 #include <vclenum.hxx>
@@ -81,12 +81,6 @@
 #include <fntstyle.hxx>
 #endif
 
-#ifdef SMART_UNO_GENERATION
-class Font_Type;
-class Font_Size;
-class Font_Attribs;
-#endif
-
 class SvStream;
 #define FontAlign TextAlign
 
@@ -226,16 +220,4 @@ public:
 
 	friend SvStream&	operator>>( SvStream& rIStm, Font& rFont );
 	friend SvStream&	operator<<( SvStream& rOStm, const Font& rFont );
-
-#ifdef SMART_UNO_GENERATION
-	void				getType( Font_Type& ) const;
-	void				setType( const Font_Type& );
-
-	void				getSize( Font_Size& ) const;
-	void				setSize( const Font_Size& );
-
-	void				getAttribs( Font_Attribs& ) const;
-	void				setAttribs( const Font_Attribs& );
-#endif
-
 };

Index: vcl/inc/fontcfg.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/fontcfg.hxx,v
retrieving revision 1.3
retrieving revision 1.5
diff -u -p -u -r1.3 -r1.5
--- vcl/inc/fontcfg.hxx	29 May 2002 13:37:05 -0000	1.3
+++ vcl/inc/fontcfg.hxx	25 Jun 2004 15:24:19 -0000	1.5
@@ -66,43 +66,70 @@
 #ifndef _UTL_CONFIGITEM_HXX_
 #include <unotools/configitem.hxx>
 #endif
-#ifndef _LANG_HXX
-#include <tools/lang.hxx>
-#endif
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
 #ifndef _VCL_ENUM_HXX
 #include <vclenum.hxx>
 #endif
+#ifndef _COM_SUN_STAR_LANG_LOCALE_HPP_
+#include <com/sun/star/lang/Locale.hpp>
+#endif
 
-#include <map>
 #include <hash_map>
 #include <vector>
 
+namespace com {
+namespace sun {
+namespace star {
+namespace lang {
+
+// equality operator needed for hash_map;
+// (-> why does this need to be in the namespace of Locale ? g++ fails to compile else)
+inline bool operator==( const com::sun::star::lang::Locale& rLeft, const com::sun::star::lang::Locale& rRight )
+{
+    return
+        rLeft.Language.equals( rRight.Language ) &&
+        rLeft.Country.equals( rRight.Country )  &&
+        rLeft.Variant.equals( rRight.Variant )
+        ;
+}
+}}}}
+
 namespace vcl
 {
 
+struct LocaleHash
+{
+    size_t operator()( const com::sun::star::lang::Locale& rLocale ) const
+    {
+        return
+            (size_t)rLocale.Language.hashCode() ^
+            (size_t)rLocale.Country.hashCode()  ^
+            (size_t)rLocale.Variant.hashCode();
+    }
+};
+
 class DefaultFontConfigItem : public ::utl::ConfigItem
 {
 
-    ::std::map< int, ::std::map< int, ::rtl::OUString > >		m_aDefaults;
+    std::hash_map< com::sun::star::lang::Locale , std::hash_map< int, rtl::OUString >, vcl::LocaleHash >		m_aDefaults;
 
-    virtual void Notify( const ::com::sun::star::uno::Sequence< ::rtl::OUString >& rPropertyNames );
+    virtual void Notify( const com::sun::star::uno::Sequence< rtl::OUString >& rPropertyNames );
     virtual void Commit();
 
     void getValues();
-    static int getKeyType( const ::rtl::OUString& rKey );
+    static int getKeyType( const rtl::OUString& rKey );
     DefaultFontConfigItem();
 public:
     virtual ~DefaultFontConfigItem();
 
     static DefaultFontConfigItem* get();
 
-    const ::rtl::OUString& getDefaultFont( int nLanguage, int nType ) const;
-    const ::rtl::OUString& getUserInterfaceFont( int nLanguage = LANGUAGE_SYSTEM ) const;
+    const rtl::OUString& getDefaultFont( const com::sun::star::lang::Locale& rLocale, int nType ) const;
+    const rtl::OUString& getUserInterfaceFont( const com::sun::star::lang::Locale& rLocale ) const;
 
-    void setDefaultFont( int nLanguage, int nType, const ::rtl::OUString& rName );
+    void setDefaultFont( const com::sun::star::lang::Locale& rLocale, int nType, const rtl::OUString& rName );
 };
 
 
@@ -170,13 +197,13 @@ public:
     struct FontNameAttr
     {
         String								Name;
-        ::std::vector< String >				Substitutions;
-        ::std::vector< String >				MSSubstitutions;
-        ::std::vector< String >				PSSubstitutions;
-        ::std::vector< String >				HTMLSubstitutions;
-        FontWeight							Weight;
+        std::vector< String >			Substitutions;
+        std::vector< String >			MSSubstitutions;
+        std::vector< String >			PSSubstitutions;
+        std::vector< String >			HTMLSubstitutions;
+        FontWeight						Weight;
         FontWidth							Width;
-        unsigned long						Type; // bitfield of IMPL_FONT_ATTR_*
+        unsigned long					Type; // bitfield of IMPL_FONT_ATTR_*
     };
 private:
 
@@ -184,9 +211,9 @@ private:
     // searches on the substitutes are done with Name as key, where
     // a minimal match is sufficient (that is e.g. "Thorndale" will match
     // "Thorndale BlaBlub"). Also names must be lower case.
-    ::std::map< int, ::std::vector< FontNameAttr > > m_aSubstitutions;
+    std::hash_map< com::sun::star::lang::Locale, std::vector< FontNameAttr >, vcl::LocaleHash > m_aSubstitutions;
 
-    virtual void Notify( const ::com::sun::star::uno::Sequence< ::rtl::OUString >& rPropertyNames );
+    virtual void Notify( const com::sun::star::uno::Sequence< rtl::OUString >& rPropertyNames );
     virtual void Commit();
 
     void getValues();
@@ -196,17 +223,23 @@ public:
 
     static FontSubstConfigItem* get();
 
-    const FontNameAttr* getSubstInfo( const String& rFontName, int nLanguage = LANGUAGE_ENGLISH ) const;
+    const FontNameAttr* getSubstInfo(
+                                     const String& rFontName,
+                                     const com::sun::star::lang::Locale& rLocale =
+                                     com::sun::star::lang::Locale( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "en" ) ),
+                                                                   rtl::OUString(),
+                                                                   rtl::OUString() )
+                                     ) const;
     static void getMapName( const String& rOrgName, String& rShortName, String& rFamilyName, FontWeight& rWeight, FontWidth& rWidth, unsigned long& rType );
 };
 
 class SettingsConfigItem : public ::utl::ConfigItem
 {
 
-    ::std::hash_map< ::rtl::OUString, ::std::hash_map< ::rtl::OUString, ::rtl::OUString, ::rtl::OUStringHash >, ::rtl::OUStringHash >
+    std::hash_map< rtl::OUString, std::hash_map< rtl::OUString, rtl::OUString, rtl::OUStringHash >, rtl::OUStringHash >
     			m_aSettings;
 
-    virtual void Notify( const ::com::sun::star::uno::Sequence< ::rtl::OUString >& rPropertyNames );
+    virtual void Notify( const com::sun::star::uno::Sequence< rtl::OUString >& rPropertyNames );
     virtual void Commit();
 
     void getValues();
@@ -216,8 +249,8 @@ public:
 
     static SettingsConfigItem* get();
 
-    const ::rtl::OUString& getValue( const ::rtl::OUString& rGroup, const ::rtl::OUString& rKey ) const;
-    void setValue( const ::rtl::OUString& rGroup, const ::rtl::OUString& rKey, const ::rtl::OUString& rValue );
+    const rtl::OUString& getValue( const rtl::OUString& rGroup, const rtl::OUString& rKey ) const;
+    void setValue( const rtl::OUString& rGroup, const rtl::OUString& rKey, const rtl::OUString& rValue );
 };
 
 
Index: vcl/inc/gdimtf.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/gdimtf.hxx,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -p -u -r1.5 -r1.6
--- vcl/inc/gdimtf.hxx	18 Nov 2002 13:42:14 -0000	1.5
+++ vcl/inc/gdimtf.hxx	6 Jan 2004 13:00:30 -0000	1.6
@@ -98,6 +98,7 @@ class Gradient;
 #ifndef METAFILE_END
 #define METAFILE_END					GDI_METAFILE_END
 #endif
+
 #ifndef METAFILE_LABEL_NOTFOUND
 #define METAFILE_LABEL_NOTFOUND			GDI_METAFILE_LABEL_NOTFOUND
 #endif
@@ -136,11 +137,7 @@ typedef BitmapEx (*BmpExchangeFnc)( cons
 // - GDIMetaFile -
 // ---------------
 
-#ifndef MAC
 class GDIMetaFile : protected List
-#else
-class GDIMetaFile : public List
-#endif
 {
 private:
 
@@ -191,8 +188,8 @@ protected:
 
 public:
                     GDIMetaFile();
-                    GDIMetaFile( const GDIMetaFile& rMtf );
-                    ~GDIMetaFile();
+					GDIMetaFile( const GDIMetaFile& rMtf );
+    virtual			~GDIMetaFile();
 
     GDIMetaFile&    operator=( const GDIMetaFile& rMtf );
 	BOOL			operator==( const GDIMetaFile& rMtf ) const;
Index: vcl/inc/glyphcache.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/glyphcache.hxx,v
retrieving revision 1.19
retrieving revision 1.22
diff -u -p -u -r1.19 -r1.22
--- vcl/inc/glyphcache.hxx	2 Jul 2003 13:38:54 -0000	1.19
+++ vcl/inc/glyphcache.hxx	18 May 2004 10:48:36 -0000	1.22
@@ -72,6 +72,7 @@ class ServerFontLayout;
 
 #include <tools/gen.hxx>
 #include <hash_map>
+#include <map>
 #include <hash_set>
 
 struct ImplFontSelectData;
@@ -90,14 +91,20 @@ bool operator==( const ImplFontSelectDat
 
 // =======================================================================
 
+namespace std {
 template<>
-struct std::hash<ImplFontSelectData> 
+struct hash<ImplFontSelectData> 
 {
     size_t operator()( const ImplFontSelectData& ) const;
 };
 
+}
+
 //--------
 
+typedef std::map< sal_Unicode, std::map< sal_Unicode, int > > unicodeKernMap;
+typedef std::map< int, std::map< int, int > > glyphKernMap;
+
 class GlyphCache
 {
 public:
@@ -110,7 +117,11 @@ public:
     void                        ClearFontPath();
     void                        AddFontPath( const String& rFontPath );
     void                        AddFontFile( const rtl::OString& rNormalizedName,
-                                    int nFaceNum, int nFontId, const ImplFontData* );
+                                             int nFaceNum,
+                                             int nFontId,
+                                             const ImplFontData*,
+                                             const unicodeKernMap* pUniKernPairs = NULL
+                                             );
     long                        FetchFontList( ImplDevFontList* ) const;
 
     ServerFont*                 CacheFont( const ImplFontSelectData& );
@@ -118,7 +129,7 @@ public:
     void                        RemoveFont( const ImplFontData* );
 
 private:
-friend ServerFont;
+    friend class ServerFont;
     // used by ServerFont class only
     void                        AddedGlyph( ServerFont& rServerFont, GlyphData& rGlyphData );
     void                        RemovingGlyph( ServerFont& rSF, GlyphData& rGD, int nGlyphIndex );
@@ -156,7 +167,7 @@ public:
     long                    GetCharWidth() const { return mnAdvanceWidth; }
 
 protected:
-friend class GlyphData;
+    friend class GlyphData;
     void                    SetOffset( int nX, int nY ) { maOffset = Point( nX, nY); }
     void                    SetDelta( int nX, int nY )  { maDelta = Point( nX, nY); }
     void                    SetSize( const Size& s )    { maSize = s; }
@@ -218,8 +229,8 @@ public:
     const ImplFontSelectData&   GetFontSelData() const      { return maFontSelData; }
 
     virtual void                FetchFontMetric( ImplFontMetricData&, long& rFactor ) const = 0;
-    virtual ULONG               GetKernPairs( struct ImplKernPairData** ) const = 0;
-    virtual int                 GetGlyphKernValue( int, int ) const = 0;
+    virtual ULONG               GetKernPairs( struct ImplKernPairData** ) const;
+    virtual int                 GetGlyphKernValue( int, int ) const;
     virtual ULONG               GetFontCodeRanges( sal_uInt32* pCodes ) const { return 0; }
     Point                       TransformPoint( const Point& ) const;
 
@@ -238,9 +249,9 @@ public:
     void*                       GetExtPointer() { return mpExtData; }
 
 protected:
-friend GlyphCache;
-friend ServerFontLayout;
-                                ServerFont( const ImplFontSelectData& );
+    friend class GlyphCache;
+    friend class ServerFontLayout;
+                                ServerFont( const ImplFontSelectData&, const glyphKernMap* pGlyphKern = NULL, const unicodeKernMap* pUniKern = NULL  );
     virtual                     ~ServerFont();
 
     void                        AddRef() const      { ++mnRefCount; }
@@ -273,6 +284,12 @@ private:
 protected:
     long                        nCos;
     long                        nSin;
+
+    // maps left glyph id to map of right glyphid
+    // the inner map maps right glyphid to kern value
+    const glyphKernMap*			mpKernPairs;
+    const unicodeKernMap*		mpUnicodeKernPairs;
+
 };
 
 // =======================================================================
Index: vcl/inc/gradient.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/gradient.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/inc/gradient.hxx	19 Sep 2000 10:23:04 -0000	1.1.1.1
+++ vcl/inc/gradient.hxx	6 Jan 2004 13:01:22 -0000	1.3
@@ -62,7 +62,10 @@
 #ifndef _SV_GRADIENT_HXX
 #define _SV_GRADIENT_HXX
 
-#include <color.hxx>
+#ifndef _TOOLS_COLOR_HXX
+#include <tools/color.hxx>
+#endif
+
 #include <vclenum.hxx>
 
 // ------------------
@@ -160,29 +163,6 @@ public:
 
     friend SvStream& operator>>( SvStream& rIStm, Gradient& rGradient );
     friend SvStream& operator<<( SvStream& rOStm, const Gradient& rGradient );
-
-#ifdef SMART_UNO_GENERATION
-	GradientStyle	getStyle() const				{ return GetStyle(); }
-	void 			setStyle( GradientStyle e ) 	{ SetStyle( e ); }
-	long 			getStartColor() const			{ return GetStartColor().GetColor(); }
-	void 			setStartColor( long n ) 		{ SetStartColor( Color( n ) ); }
-	long 			getEndColor() const				{ return GetEndColor().GetColor(); }
-	void 			setEndColor( long n ) 			{ SetEndColor( Color( n ) ); }
-	USHORT 			getAngle() const				{ return GetAngle(); }
-	void 			setAngle( USHORT n )			{ SetAngle( n ); }
-	USHORT			getBorder() const				{ return GetBorder(); }
-	void 			setBorder( USHORT n )			{ SetBorder( n ); }
-	USHORT			getXOffset() const				{ return GetOfsX(); }
-	void 			setXOffset( USHORT n )			{ SetOfsX( n ); }
-	USHORT			getYOffset() const				{ return GetOfsY(); }
-	void 			setYOffset( USHORT n )			{ SetOfsY( n ); }
-	USHORT			getStartIntensity() const		{ return GetStartIntensity(); }
-	void 			setStartIntensity( USHORT n )	{ SetStartIntensity( n ); }
-	USHORT			getEndIntensity() const			{ return GetEndIntensity(); }
-	void 			setEndIntensity( USHORT n )		{ SetEndIntensity( n ); }
-	USHORT			getStepCount() const			{ return GetSteps(); }
-	void 			setStepCount( USHORT n )		{ SetSteps( n ); }
-#endif
 };
 
 #endif  // _SV_GRADIENT_HXX
Index: vcl/inc/graph.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/graph.hxx,v
retrieving revision 1.6
retrieving revision 1.7
diff -u -p -u -r1.6 -r1.7
--- vcl/inc/graph.hxx	27 Mar 2003 17:57:21 -0000	1.6
+++ vcl/inc/graph.hxx	20 Apr 2004 13:53:29 -0000	1.7
@@ -143,6 +143,8 @@ public:
     Bitmap              GetBitmap( const Size* pSizePixel ) const;
     BitmapEx            GetBitmapEx() const;
     BitmapEx            GetBitmapEx( const Size* pSizePixel ) const;
+    Bitmap              GetUnlimitedBitmap( const Size* pSizePixel ) const;
+    BitmapEx            GetUnlimitedBitmapEx( const Size* pSizePixel ) const;
     Animation           GetAnimation() const;
     const GDIMetaFile&  GetGDIMetaFile() const;
 
Index: vcl/inc/group.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/group.hxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/inc/group.hxx	8 May 2002 16:01:29 -0000	1.2
+++ vcl/inc/group.hxx	6 Jan 2004 13:01:39 -0000	1.3
@@ -75,16 +75,15 @@
 
 class GroupBox : public Control
 {
-#ifdef _SV_GROUP_CXX
 private:
     void            ImplInit( Window* pParent, WinBits nStyle );
     WinBits         ImplInitStyle( WinBits nStyle );
     void            ImplInitSettings( BOOL bFont, BOOL bForeground, BOOL bBackground );
     void            ImplDraw( OutputDevice* pDev, ULONG nDrawFlags,
                               const Point& rPos, const Size& rSize, bool bLayout = false );
-#endif
 
-    virtual void FillLayoutData() const;
+    virtual void	FillLayoutData() const;
+
 public:
                     GroupBox( Window* pParent, WinBits nStyle = 0 );
                     GroupBox( Window* pParent, const ResId& rResId );
Index: vcl/inc/hatch.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/hatch.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/inc/hatch.hxx	19 Sep 2000 10:23:04 -0000	1.1.1.1
+++ vcl/inc/hatch.hxx	6 Jan 2004 13:01:57 -0000	1.3
@@ -62,7 +62,10 @@
 #ifndef _SV_HATCH_HXX
 #define _SV_HATCH_HXX
 
-#include <color.hxx>
+#ifndef _TOOLS_COLOR_HXX
+#include <tools/color.hxx>
+#endif
+
 #include <vclenum.hxx>
 
 // --------------
@@ -77,7 +80,6 @@ struct ImplHatch
     Color				maColor;
     HatchStyle			meStyle;
     long				mnDistance;
-	long				mnDummy;
     USHORT				mnAngle;
 
 						ImplHatch();
@@ -124,22 +126,6 @@ public:
 
     friend SvStream& operator>>( SvStream& rIStm, Hatch& rHatch );
     friend SvStream& operator<<( SvStream& rOStm, const Hatch& rHatch );
-
-#ifdef SMART_UNO_GENERATION
-
-	HatchStyle		getStyle() const { return GetStyle(); }
-	void 			setStyle( HatchStyle eStyle ) { SetStyle( eStyle ); }
-
-	long 			getColor() const { return GetColor().GetColor(); }
-	void 			setColor( long nColor ) { SetColor( Color( nColor ) ); }
-
-	long			getDistance() const { return GetDistance(); }
-	void 			setDistance( ULONG nDistance ) { SetDistance( nDistance ); }
-
-	USHORT 			getAngle() const { return GetAngle(); }
-	void 			setAngle( USHORT n ) { SetAngle( n ); }
-
-#endif
 };
 
 #endif  // _SV_HATCH_HXX
Index: vcl/inc/help.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/help.hxx,v
retrieving revision 1.3.284.1
retrieving revision 1.5
diff -u -p -u -r1.3.284.1 -r1.5
--- vcl/inc/help.hxx	9 Jan 2004 18:13:39 -0000	1.3.284.1
+++ vcl/inc/help.hxx	6 Jan 2004 13:02:14 -0000	1.5
@@ -103,6 +103,7 @@ private:
 
 public:
 						Help();
+	virtual				~Help();
 
 	void				SetHelpFile( const String& rFileName ) { maHelpFile = rFileName; }
 	const String&		GetHelpFile() const { return maHelpFile; }
Index: vcl/inc/ilstbox.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/ilstbox.hxx,v
retrieving revision 1.20
retrieving revision 1.23
diff -u -p -u -r1.20 -r1.23
--- vcl/inc/ilstbox.hxx	24 Apr 2003 16:29:18 -0000	1.20
+++ vcl/inc/ilstbox.hxx	18 May 2004 10:48:51 -0000	1.23
@@ -244,7 +244,7 @@ private:
 	USHORT			mnBorder;		 // Abstand Rahmen - Text
 	USHORT			mnTextHeight;	 // Texthoehe
 
-	USHORT			mnSelectModifier;	// Modifiers 
+	USHORT			mnSelectModifier;	// Modifiers
 
     BOOL            mbHasFocusRect;
 
@@ -261,8 +261,8 @@ private:
 					mbGrabFocus:			1,  // Focus bei MBDown grabben
 					mbUserDrawEnabled:		1,	// UserDraw possible
 					mbInUserDraw:			1,	// In UserDraw
-					mbReadOnly:				1;	// ReadOnly
-
+					mbReadOnly:				1,	// ReadOnly
+					mbMirroring:			1;	// pb: #106948# explicit mirroring for calc
 
 	Link			maScrollHdl;
 	Link			maSelectHdl;
@@ -273,7 +273,7 @@ private:
 
 protected:
 	DECL_LINK(		SearchStringTimeout, Timer* );
-	
+
 	virtual void	KeyInput( const KeyEvent& rKEvt );
 	virtual void	MouseButtonDown( const MouseEvent& rMEvt );
 	virtual void	MouseMove( const MouseEvent& rMEvt );
@@ -293,7 +293,7 @@ protected:
     void            ImplShowFocusRect();
     void            ImplHideFocusRect();
 
-	
+
 	virtual void	StateChanged( StateChangedType nType );
 	virtual void	DataChanged( const DataChangedEvent& rDCEvt );
 
@@ -316,6 +316,7 @@ public:
 
 	void			SelectEntry( USHORT nPos, BOOL bSelect );
 	void			DeselectAll();
+    USHORT			GetEntryPosForPoint( const Point& rPoint ) const;
 
 	BOOL			ProcessKeyInput( const KeyEvent& rKEvt );
 
@@ -342,13 +343,13 @@ public:
 
 	void			EnableUserDraw( BOOL bUserDraw ) { mbUserDrawEnabled = bUserDraw; }
 	BOOL			IsUserDrawEnabled() const 	{ return mbUserDrawEnabled; }
-	
+
 	void			EnableMultiSelection( BOOL bMulti, BOOL bStackMode ) { mbMulti = bMulti; mbStackMode = bStackMode; }
 	BOOL			IsMultiSelectionEnabled() const 	{ return mbMulti; }
-	
+
 	void			SetMultiSelectionSimpleMode( BOOL bSimple )	{ mbSimpleMode = bSimple; }
 	BOOL			IsMultiSelectionSimpleMode() const 			{ return mbSimpleMode; }
-	
+
 	void			EnableMouseMoveSelect( BOOL bMouseMoveSelect ) { mbMouseMoveSelect = bMouseMoveSelect; }
 	BOOL			IsMouseMoveSelectEnabled() const 	{ return mbMouseMoveSelect; }
 	BOOL			IsMouseMoveSelect() const 	{ return mbMouseMoveSelect||mbStackMode; }
@@ -372,7 +373,7 @@ public:
 	const Link& 	GetUserDrawHdl() const				{ return maUserDrawHdl; }
 	void			SetMRUChangedHdl( const Link& rLink )	{ maMRUChangedHdl = rLink; }
 	const Link& 	GetMRUChangedHdl() const				{ return maMRUChangedHdl; }
-					
+
 	BOOL			IsSelectionChanged() const { return mbSelectionChanged; }
 	USHORT			GetSelectModifier() const { return mnSelectModifier; }
 
@@ -381,8 +382,11 @@ public:
 	void			SetReadOnly( BOOL bReadOnly ) 	{ mbReadOnly = bReadOnly; }
 	BOOL			IsReadOnly() const 				{ return mbReadOnly; }
 
-	
 	void			ImplInitSettings( BOOL bFont, BOOL bForeground, BOOL bBackground );
+
+	// pb: #106948# explicit mirroring for calc
+	inline void		EnableMirroring()		{ mbMirroring = TRUE; }
+	inline BOOL		IsMirroring() const { return mbMirroring; }
 };
 
 // ---------------
@@ -422,7 +426,7 @@ public:
 
 	const ImplEntryList*	GetEntryList() const			{ return maLBWindow.GetEntryList(); }
 	ImplListBoxWindow* 		GetMainWindow() 				{ return &maLBWindow; }
-	
+
 	virtual void	Resize();
     virtual const Wallpaper& GetDisplayBackground() const;
     virtual Window*     GetPreferredKeyInputWindow();
@@ -441,7 +445,7 @@ public:
 
 	BOOL			ProcessKeyInput( const KeyEvent& rKEvt )	{ return maLBWindow.ProcessKeyInput( rKEvt ); }
 	BOOL			HandleWheelAsCursorTravel( const CommandEvent& rCEvt );
-	
+
 	void			SetSeparatorPos( USHORT n )		{ maLBWindow.SetSeparatorPos( n ); }
 	USHORT			GetSeparatorPos() const			{ return maLBWindow.GetSeparatorPos(); }
 
@@ -459,7 +463,7 @@ public:
 
 	void			EnableMultiSelection( BOOL bMulti, BOOL bStackMode ) { maLBWindow.EnableMultiSelection( bMulti, bStackMode ); }
 	BOOL			IsMultiSelectionEnabled() const 	{ return maLBWindow.IsMultiSelectionEnabled(); }
-	
+
 	void			SetMultiSelectionSimpleMode( BOOL bSimple ) { maLBWindow.SetMultiSelectionSimpleMode( bSimple ); }
 	BOOL			IsMultiSelectionSimpleMode() const 	{ return maLBWindow.IsMultiSelectionSimpleMode(); }
 
@@ -481,7 +485,7 @@ public:
 	const Link& 	GetDoubleClickHdl() const				{ return maLBWindow.GetDoubleClickHdl(); }
 	void			SetUserDrawHdl( const Link& rLink )	{ maLBWindow.SetUserDrawHdl( rLink ); }
 	const Link& 	GetUserDrawHdl() const				{ return maLBWindow.GetUserDrawHdl(); }
-	
+
 	void			SetSelectionChangedHdl( const Link& rLnk )	{ maLBWindow.GetEntryList()->SetSelectionChangedHdl( rLnk ); }
 	void			SetCallSelectionChangedHdl( BOOL bCall )	{ maLBWindow.GetEntryList()->SetCallSelectionChangedHdl( bCall ); }
 	BOOL			IsSelectionChanged() const 					{ return maLBWindow.IsSelectionChanged(); }
@@ -493,6 +497,9 @@ public:
 	USHORT			GetMaxMRUCount() const						{ return maLBWindow.GetEntryList()->GetMaxMRUCount(); }
     USHORT			GetDisplayLineCount() const
     { return maLBWindow.GetDisplayLineCount(); }
+
+	// pb: #106948# explicit mirroring for calc
+	inline void		EnableMirroring()	{ maLBWindow.EnableMirroring(); }
 };
 
 // -----------------------------
@@ -535,6 +542,8 @@ public:
 	USHORT			GetDropDownLineCount() const { return mnDDLineCount; }
 
     USHORT          GetPopupModeStartSaveSelection() const { return mnPopupModeStartSaveSelection; }
+
+    virtual void	Resize();
 };
 
 // -----------
@@ -544,15 +553,15 @@ public:
 class ImplWin : public Control
 {
 private:
-	
+
 	USHORT			mnItemPos;	// wegen UserDraw muss ich wissen, welches Item ich darstelle.
 	XubString		maString;
 	Image			maImage;
 	Image			maImageHC;
-	
+
 	Rectangle		maFocusRect;
 	Size			maUserItemSize;
-	
+
 	Link			maMBDownHdl;
 	Link			maUserDrawHdl;
 
@@ -573,10 +582,11 @@ public:
 	virtual void	Resize();
 	virtual void	GetFocus();
 	virtual void	LoseFocus();
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
 	USHORT			GetItemPos() const { return mnItemPos; }
 	void			SetItemPos( USHORT n ) { mnItemPos = n; }
-	
+
 	const XubString& GetString() const { return maString; }
 	void			SetString( const XubString& rStr ) { maString = rStr; }
 
@@ -590,16 +600,16 @@ public:
 	virtual void	MBDown();
 	void			SetMBDownHdl( const Link& rLink ) { maMBDownHdl = rLink; }
 	const Link& 	GetMBDownHdl() const { return maMBDownHdl; }
-	
+
 	void			SetUserDrawHdl( const Link& rLink )	{ maUserDrawHdl = rLink; }
 	const Link& 	GetUserDrawHdl() const				{ return maUserDrawHdl; }
-	
+
 	void			SetUserItemSize( const Size& rSz )	{ maUserItemSize = rSz; }
 	const Size&		GetUserItemSize() const				{ return maUserItemSize; }
 
 	void			EnableUserDraw( BOOL bUserDraw ) 	{ mbUserDrawEnabled = bUserDraw; }
 	BOOL			IsUserDrawEnabled() const 			{ return mbUserDrawEnabled; }
-	
+
 	void 			DrawEntry( BOOL bDrawImage, BOOL bDrawText, BOOL bDrawTextAtImagePos = FALSE, bool bLayout = false );
 };
 
Index: vcl/inc/imgcons.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/imgcons.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/imgcons.hxx	19 Sep 2000 10:23:04 -0000	1.1.1.1
+++ vcl/inc/imgcons.hxx	6 Jan 2004 13:03:07 -0000	1.2
@@ -85,7 +85,6 @@ private:
 	Bitmap				maBitmap;
 	Bitmap				maMask;
 	Rectangle			maChangedRect;
-	Rectangle			maDummyRect;
 	Size				maSize;
 	ImplColorMapper*	mpMapper;
 	Color*				mpPal;
@@ -94,10 +93,6 @@ private:
 	ULONG				mnFormat;
 	ULONG				mnStatus;
 	BOOL				mbTrans;
-	long				mnDummy1;
-	long				mnDummy2;
-	BOOL				mbDummy1;
-	BOOL				mbDummy2;
 						
 protected:				
 						
Index: vcl/inc/imgctrl.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/imgctrl.hxx,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- vcl/inc/imgctrl.hxx	15 Aug 2002 14:49:14 -0000	1.4
+++ vcl/inc/imgctrl.hxx	6 Jan 2004 13:03:24 -0000	1.5
@@ -74,7 +74,7 @@ class ImageControl : public FixedImage
 private:
 	BitmapEx		maBmp;
 	BitmapEx		maBmpHC;
-	ULONG			mnDummy1_mbScaleImage;  // Change member in next full update!
+	BOOL			mbScaleImage;
 
 public:
 					ImageControl( Window* pParent, WinBits nStyle = 0 );
Index: vcl/inc/impbmp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/impbmp.hxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/inc/impbmp.hxx	7 Dec 2000 13:37:15 -0000	1.2
+++ vcl/inc/impbmp.hxx	1 Dec 2003 12:53:44 -0000	1.3
@@ -92,11 +92,7 @@ private:
     ULONG				mnRefCount;
 	ULONG				mnChecksum;
 	RMBitmap*			mpRMBitmap;
-#ifndef REMOTE_APPSERVER
     SalBitmap*			mpSalBitmap;
-#else
-    ImplServerBitmap*   mpSalBitmap;
-#endif
 
 public:
 
@@ -107,41 +103,8 @@ public:
 
 public:
 
-#ifndef REMOTE_APPSERVER
 	void				ImplSetSalBitmap( SalBitmap* pSalBitmap );
     SalBitmap*			ImplGetSalBitmap() const { return mpSalBitmap; }
-#else
-    void            	ImplSetSalBitmap( ImplServerBitmap* pSalBitmap );
-    ImplServerBitmap*	ImplGetSalBitmap() const { return mpSalBitmap; }
-
-	RMBitmap*			ImplGetRemoteBmp();
-
-	void				ImplCreateRemoteBmp( const Bitmap& rBitmap );
-	void				ImplCreateRemoteBmp( const Bitmap& rBitmap, 
-											 OutputDevice* pOut,
-											 const Point& rPt, const Size& rSz );
-	
-	void				ImplReleaseRemoteBmp();
-
-	void				ImplDrawRemoteBmp( OutputDevice* pOut,
-								const Point& rSrcPt, const Size& rSrcSz,
-								const Point& rDestPt, const Size& rDestSz );
-	void				ImplDrawRemoteBmpEx( OutputDevice* pOut,
-								const Point& rSrcPt, const Size& rSrcSz,
-								const Point& rDestPt, const Size& rDestSz,
-								const Bitmap& rMask );
-	void				ImplDrawRemoteBmpAlpha( OutputDevice* pOut,
-								const Point& rSrcPt, const Size& rSrcSz,
-								const Point& rDestPt, const Size& rDestSz,
-								const AlphaMask& rAlpha );
-	void				ImplDrawRemoteBmpMask( OutputDevice* pOut,
-								const Point& rSrcPt, const Size& rSrcSz,
-								const Point& rDestPt, const Size& rDestSz,
-								const Color& rColor );
-
-	BOOL				ImplIsGetPrepared() const;
-	void				ImplResolveGet();
-#endif
 
 public:
 
Index: vcl/inc/impgraph.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/impgraph.hxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/inc/impgraph.hxx	24 Aug 2001 14:07:49 -0000	1.3
+++ vcl/inc/impgraph.hxx	20 Apr 2004 13:53:44 -0000	1.4
@@ -144,8 +144,8 @@ private:
 	BOOL				ImplIsAlpha() const;
 	BOOL				ImplIsAnimated() const;
 
-	Bitmap				ImplGetBitmap( const Size* pSizePixel ) const;
-	BitmapEx			ImplGetBitmapEx( const Size* pSizePixel ) const;
+	Bitmap				ImplGetBitmap( const Size* pSizePixel, BOOL bUnlimited ) const;
+	BitmapEx			ImplGetBitmapEx( const Size* pSizePixel, BOOL bUnlimited ) const;
 	Animation			ImplGetAnimation() const;
 	const GDIMetaFile&	ImplGetGDIMetaFile() const;
 
Index: vcl/inc/jobset.h
===================================================================
RCS file: /cvs/gsl/vcl/inc/jobset.h,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -p -u -r1.5 -r1.6
--- vcl/inc/jobset.h	6 Mar 2002 11:13:54 -0000	1.5
+++ vcl/inc/jobset.h	6 Jan 2004 13:03:42 -0000	1.6
@@ -72,7 +72,7 @@
 #ifndef _SV_PRNTYPES_HXX
 #include <prntypes.hxx>
 #endif
-#ifndef __SGI_STL_HASH_MAP
+#ifndef _STLP_HASH_MAP
 #include <hash_map>
 #endif
 #ifndef _RTL_USTRING_
Index: vcl/inc/jobset.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/jobset.hxx,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- vcl/inc/jobset.hxx	19 Dec 2001 14:43:31 -0000	1.4
+++ vcl/inc/jobset.hxx	1 Dec 2003 12:54:41 -0000	1.5
@@ -75,10 +75,6 @@
 class SvStream;
 struct ImplJobSetup;
 
-#ifdef REMOTE_APPSERVER
-namespace com { namespace sun { namespace star { namespace portal { namespace client { struct RmJobSetup; } } } } }
-#endif
-
 // ------------
 // - JobSetup -
 // ------------
@@ -115,10 +111,6 @@ public:
 	
 
 	JobSetup&			operator=( const JobSetup& rJob );
-#ifdef REMOTE_APPSERVER
-    JobSetup&			operator=( const ::com::sun::star::portal::client::RmJobSetup& );
-    void				SetRmJobSetup( ::com::sun::star::portal::client::RmJobSetup& ) const;
-#endif
 
 	BOOL				operator==( const JobSetup& rJobSetup ) const;
 	BOOL				operator!=( const JobSetup& rJobSetup ) const
Index: vcl/inc/keycod.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/keycod.hxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/inc/keycod.hxx	27 Feb 2002 12:11:26 -0000	1.2
+++ vcl/inc/keycod.hxx	6 Jan 2004 13:03:58 -0000	1.3
@@ -69,8 +69,8 @@
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
-#ifndef _SV_RESID_HXX
-#include <resid.hxx>
+#ifndef _TOOLS_RESID_HXX
+#include <tools/resid.hxx>
 #endif
 #ifndef _SV_KEYCODES_HXX
 #include <keycodes.hxx>
Index: vcl/inc/keycodes.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/keycodes.hxx,v
retrieving revision 1.2.250.1
retrieving revision 1.5
diff -u -p -u -r1.2.250.1 -r1.5
--- vcl/inc/keycodes.hxx	9 Jan 2004 18:13:39 -0000	1.2.250.1
+++ vcl/inc/keycodes.hxx	17 Mar 2004 10:04:17 -0000	1.5
@@ -70,7 +70,7 @@
 // - KeyCode-Types -
 // -----------------
 
-// By changes you must also change: tools/vclrsc.hxx
+// By changes you must also change: rsc/vclrsc.hxx
 
 // Key-Gruppen
 #define KEYGROUP_NUM	((USHORT)0x0100)
@@ -186,6 +186,7 @@
 #define KEY_MENU		((USHORT)(KEYGROUP_MISC+26))
 #define KEY_HELP		((USHORT)(KEYGROUP_MISC+27))
 #define KEY_HANGUL_HANJA ((USHORT)(KEYGROUP_MISC+28))
+#define KEY_DECIMAL     ((USHORT)(KEYGROUP_MISC+29))
 
 #define KEY_CODE		((USHORT)0x0FFF)
 
Index: vcl/inc/lineinfo.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/lineinfo.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/lineinfo.hxx	19 Sep 2000 10:23:05 -0000	1.1.1.1
+++ vcl/inc/lineinfo.hxx	4 Sep 2003 07:41:49 -0000	1.2
@@ -140,31 +140,6 @@ public:
 
     friend SvStream& operator>>( SvStream& rIStm, LineInfo& rLineInfo );
     friend SvStream& operator<<( SvStream& rOStm, const LineInfo& rLineInfo );
-
-#ifdef SMART_UNO_GENERATION
-
-	LineStyle		getStyle() const { return GetStyle(); }
-	void 			setStyle( LineStyle eStyle ) { SetStyle( eStyle ); }
-
-	long			getWidth() const { return GetWidth(); }
-	void 			setWidth( ULONG nDistance ) { SetWidth( nWidth ); }
-
-	USORT			getDashCount const { return GetDashCount(); }
-	void			setDashCount( USHORT nDashCount ) { SetDashCount( nDashCount ); }
-
-	long			getDashLen() const { return GetDashLen(); }
-	void			setDashLen( long nDashLen ) { SetDashLen( nDashLen ); }
-
-	USHORT			getDotCount() const { return GetDotCount(); }
-	void			setDotCount( USHORT nDotCount ) { SetDotCount( nDotCount ); }
-
-	long			getDotLen() const { GetDotLen(); }
-	void			setDotLen( long nDotLen ) { SetDotLen( nDotLen ); }
-
-	long			getDistance() const { return GetDistance(); }
-	void			setDistance( long nDistance ) { SetDistance( nDistance ); }
-
-#endif
 };
 
 #endif  // _SV_LINEINFO_HXX
Index: vcl/inc/longcurr.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/longcurr.hxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/inc/longcurr.hxx	29 Jun 2001 10:17:29 -0000	1.3
+++ vcl/inc/longcurr.hxx	6 Jan 2004 13:04:51 -0000	1.4
@@ -77,12 +77,9 @@ class LocaleDataWrapper;
 
 class LongCurrencyFormatter : public FormatterBase
 {
-#if _SOLAR__PRIVATE
-#ifdef VCL_LONGCURR_CXX
-	friend BOOL ImplLongCurrencyReformat( const XubString&, BigInt, BigInt, USHORT, const LocaleDataWrapper&, XubString&, LongCurrencyFormatter& );
+private:
+	friend BOOL				ImplLongCurrencyReformat( const XubString&, BigInt, BigInt, USHORT, const LocaleDataWrapper&, XubString&, LongCurrencyFormatter& );
 	void					ImpInit();
-#endif
-#endif
 
 protected:
 	BigInt					mnFieldValue;
@@ -95,9 +92,6 @@ protected:
 	USHORT                  mnDecimalDigits;
     BOOL                    mbThousandSep;
 
-    ULONG                   mnDummy;
-    BOOL                    mbDummy;
-
 							LongCurrencyFormatter();
 	void					ImplLoadRes( const ResId& rResId );
 
@@ -141,9 +135,7 @@ public:
 class LongCurrencyField : public SpinField, public LongCurrencyFormatter
 {
 #if _SOLAR__PRIVATE
-#ifdef VCL_LONGCURR_CXX
 	friend void ImplNewLongCurrencyFieldValue( LongCurrencyField*, BigInt );
-#endif
 #endif
 
 private:
Index: vcl/inc/lstbox.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/lstbox.hxx,v
retrieving revision 1.12
retrieving revision 1.14
diff -u -p -u -r1.12 -r1.14
--- vcl/inc/lstbox.hxx	1 Nov 2002 09:00:27 -0000	1.12
+++ vcl/inc/lstbox.hxx	18 May 2004 10:49:04 -0000	1.14
@@ -232,6 +232,9 @@ public:
 	USHORT			GetMaxMRUCount() const;
 
     USHORT			GetDisplayLineCount() const;
+
+	void			EnableMirroring();
+
 };
 
 

Index: vcl/inc/mapmod.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/mapmod.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/mapmod.hxx	19 Sep 2000 10:23:05 -0000	1.1.1.1
+++ vcl/inc/mapmod.hxx	7 Jan 2004 09:06:47 -0000	1.2
@@ -72,8 +72,8 @@
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
-#ifndef _SV_RESID_HXX
-#include <resid.hxx>
+#ifndef _TOOLS_RESID_HXX
+#include <tools/resid.hxx>
 #endif
 #ifndef _VCL_MAPUNIT_HXX
 #include <mapunit.hxx>
@@ -101,11 +101,9 @@ private:
 	friend SvStream& operator>>( SvStream& rIStm, ImplMapMode& rMapMode );
 	friend SvStream& operator<<( SvStream& rOStm, const ImplMapMode& rMapMode );
 
-#ifdef _SV_MAPMOD_CXX
 public:
 					ImplMapMode();
 					ImplMapMode( const ImplMapMode& rImpMapMode );
-#endif
 };
 
 // -----------
@@ -119,9 +117,7 @@ class MapMode
 private:
 	ImplMapMode*	mpImplMapMode;
 
-#ifdef _SV_MAPMOD_CXX
 	void			ImplMakeUnique();
-#endif
 
 public:
 					MapMode();
Index: vcl/inc/menu.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/menu.hxx,v
retrieving revision 1.26.112.1
retrieving revision 1.30
diff -u -p -u -r1.26.112.1 -r1.30
--- vcl/inc/menu.hxx	13 Nov 2003 16:48:20 -0000	1.26.112.1
+++ vcl/inc/menu.hxx	25 Feb 2004 17:29:29 -0000	1.30
@@ -66,20 +66,20 @@
 #include <sv.h>
 #endif
 
-#ifndef _SV_RC_HXX
-#include <rc.hxx>
+#ifndef _TOOLS_RC_HXX
+#include <tools/rc.hxx>
 #endif
 
-#ifndef _SV_RESID_HXX
-#include <resid.hxx>
+#ifndef _TOOLS_RESID_HXX
+#include <tools/resid.hxx>
 #endif
 
 #ifndef _SV_BITMAPEX_HXX
 #include <bitmapex.hxx>
 #endif
 
-#ifndef _SV_COLOR_HXX
-#include <color.hxx>
+#ifndef _TOOLS_COLOR_HXX
+#include <tools/color.hxx>
 #endif
 
 #ifndef _VCL_VCLEVENT_HXX
@@ -103,7 +103,9 @@ class KeyEvent;
 class AppBarWindow;
 class MenuFloatingWindow;
 class Window;
 class AccessObjectRef;
+class SalMenu;
+struct SystemMenuData;
 
 namespace com {
 namespace sun {
@@ -126,11 +127,11 @@ namespace vcl { struct MenuLayoutData; }
 #define POPUPMENU_EXECUTE_LEFT	((USHORT)0x0004)
 #define POPUPMENU_EXECUTE_RIGHT ((USHORT)0x0008)
 
-// By changes you must also change: tools/vclrsc.hxx
+// By changes you must also change: rsc/vclrsc.hxx
 enum MenuItemType { MENUITEM_DONTKNOW, MENUITEM_STRING, MENUITEM_IMAGE,
 					MENUITEM_STRINGIMAGE, MENUITEM_SEPARATOR };
 
-// By changes you must also change: tools/vclrsc.hxx
+// By changes you must also change: rsc/vclrsc.hxx
 typedef USHORT MenuItemBits;
 #define MIB_CHECKABLE			((MenuItemBits)0x0001)
 #define MIB_RADIOCHECK			((MenuItemBits)0x0002)
@@ -151,12 +152,10 @@ struct MenuLogo
 	BitmapEx	aBitmap;
 	Color		aStartColor;
 	Color		aEndColor;
-	ULONG		nDummy;
 };
 
 class Menu : public Resource
 {
-	friend class AccessObject;
 	friend class MenuBar;
 	friend class MenuBarWindow;
 	friend class MenuFloatingWindow;
@@ -164,6 +163,7 @@ class Menu : public Resource
 	friend class SystemWindow;
 
 private:
+	void*				pMenuData_NotUsedYet;
 	MenuItemList*		pItemList;			// Liste mit den MenuItems
 	MenuLogo*			pLogo;
 	Menu*				pStartedFrom;
@@ -180,7 +180,7 @@ private:
 	XubString			aTitleText; 		// PopupMenu-Text
 
 	ULONG				nEventId;
-	ULONG				nDummy;
+	USHORT				mnHighlightedItemPos; // for native menues: keeps track of the highlighted item 
 	USHORT				nMenuFlags;
 	USHORT				nDefaultItem;		// Id vom Default-Item
 	USHORT				nSelectedId;
@@ -197,16 +197,14 @@ private:
 
     ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > mxAccessible;
 	mutable vcl::MenuLayoutData* mpLayoutData;
-	void*				mpDummy;
-	long				mnDummy;
-	BOOL				mbDummy;
+	SalMenu*			mpSalMenu;
 
 protected:
-#ifdef _SV_MENU_CXX
 	void				ImplInit();
 	void				ImplLoadRes( const ResId& rResId );
 	Menu*				ImplGetStartMenu();
 	Menu*				ImplFindSelectMenu();
+	Menu*				ImplFindMenu( USHORT nId );
 	Size				ImplCalcSize( Window* pWin );
 	BOOL				ImplIsVisible( USHORT nPos ) const;
 	USHORT				ImplGetVisibleItemCount() const;
@@ -220,11 +218,16 @@ protected:
 						DECL_LINK( ImplCallSelect, Menu* );
 
     void				ImplFillLayoutData() const;
+    SalMenu*            ImplGetSalMenu() { return mpSalMenu; }
+    void                ImplSetSalMenu( SalMenu *pMenu );
+
+#if _SOLAR__PRIVATE
 public:
     void				ImplKillLayoutData() const;
 #endif
 
 						Menu();
+						Menu( BOOL bMenuBar );
 	Window* 			ImplGetWindow() const { return pWindow; }
 
 public:
@@ -315,7 +318,10 @@ public:
 	void				SetTipHelpText( USHORT nItemId, const XubString& rString );
 	const XubString&	GetTipHelpText( USHORT nItemId ) const;
 
-	void				SetHelpId( USHORT nItemId, ULONG nHelpId );
+    void                SetHelpCommand( USHORT nItemId, const XubString& rString );
+    const XubString&    GetHelpCommand( USHORT nItemId ) const;
+    
+    void				SetHelpId( USHORT nItemId, ULONG nHelpId );
 	ULONG				GetHelpId( USHORT nItemId ) const;
 
 	void				SetActivateHdl( const Link& rLink ) 	{ aActivateHdl = rLink; }
@@ -342,6 +348,9 @@ public:
 	// Fuer Menu-'Funktionen'
 	MenuItemList*		GetItemList() const 					{ return pItemList; }
 
+    // returns the system's menu handle if native menues are supported
+    // pData must point to a SystemMenuData structure
+    BOOL                GetSystemMenuData( SystemMenuData* pData ) const;
 
     // accessibility helpers
 
@@ -393,14 +400,13 @@ public:
 
 class MenuBar : public Menu
 {
-	void*				pDummy;
 	Link				maCloserHdl;
 	Link				maFloatHdl;
 	Link				maHideHdl;
 	BOOL				mbCloserVisible;
 	BOOL				mbFloatBtnVisible;
 	BOOL				mbHideBtnVisible;
-	BOOL				mbDummy1;
+	BOOL				mbDisplayable;
 
 #if _SOLAR__PRIVATE
 	friend class Application;
@@ -431,6 +437,10 @@ public:
 	void				ShowButtons( BOOL bClose, BOOL bFloat, BOOL bHide );
 
 	void				SelectEntry( USHORT nId );
+    BOOL                HandleMenuActivateEvent( Menu *pMenu ) const;
+    BOOL                HandleMenuDeActivateEvent( Menu *pMenu ) const;
+    BOOL                HandleMenuHighlightEvent( Menu *pMenu, USHORT nEventId ) const;
+    BOOL                HandleMenuCommandEvent( Menu *pMenu, USHORT nEventId ) const;
 
 	void				SetCloserHdl( const Link& rLink )			{ maCloserHdl = rLink; }
 	const Link& 		GetCloserHdl() const						{ return maCloserHdl; }
@@ -438,6 +448,14 @@ public:
 	const Link& 		GetFloatButtonClickHdl() const				{ return maFloatHdl; }
 	void				SetHideButtonClickHdl( const Link& rLink )	{ maHideHdl = rLink; }
 	const Link& 		GetHideButtonClickHdl() const				{ return maHideHdl; }
+
+    //  - by default a menubar is displayable
+    //  - if a menubar is not displayable, its MenuBarWindow will never be shown
+    //    and it will be hidden if it was visible before
+    //  - note: if a menubar is diplayable, this does not necessarily mean that it is currently visible
+    void                SetDisplayable( BOOL bDisplayable );
+    BOOL                IsDisplayable() const                       { return mbDisplayable; }
+
 };
 
 inline MenuBar& MenuBar::operator =( const MenuBar& rMenu )
Index: vcl/inc/menubtn.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/menubtn.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/menubtn.hxx	19 Sep 2000 10:23:05 -0000	1.1.1.1
+++ vcl/inc/menubtn.hxx	7 Jan 2004 09:07:50 -0000	1.2
@@ -86,7 +86,6 @@ class MenuButton : public PushButton
 {
 private:
 	Rectangle		maFocusRect;
-	void*			mpDummy;
 	Timer*			mpMenuTimer;
 	PopupMenu*		mpOwnMenu;
 	PopupMenu*		mpMenu;
@@ -95,11 +94,9 @@ private:
 	Link			maActivateHdl;
 	Link			maSelectHdl;
 
-#ifdef _SV_MENUBTN_CXX
 	void			ImplInitData();
 	void			ImplExecuteMenu();
 					DECL_LINK( ImplMenuTimeoutHdl, Timer* );
-#endif
 
 protected:
 	void			ImplInit( Window* pParent, WinBits nStyle );
Index: vcl/inc/metaact.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/metaact.hxx,v
retrieving revision 1.4.252.1
retrieving revision 1.7
diff -u -p -u -r1.4.252.1 -r1.7
--- vcl/inc/metaact.hxx	9 Jan 2004 18:13:40 -0000	1.4.252.1
+++ vcl/inc/metaact.hxx	17 Jun 2004 12:05:02 -0000	1.7
@@ -74,8 +74,8 @@
 #ifndef _SV_FONT_HXX
 #include <font.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_BITMAP_HXX
 #include <bitmap.hxx>
@@ -575,7 +575,7 @@ private:
 
 	Point				maStartPt;
 	XubString			maStr;
-	long*				mpDXAry;
+	sal_Int32*			mpDXAry;
 	USHORT				mnIndex;
 	USHORT				mnLen;
 
@@ -586,7 +586,7 @@ public:
 						MetaTextArrayAction( const MetaTextArrayAction& rAction );
 						MetaTextArrayAction( const Point& rStartPt,
 											 const XubString& rStr,
-											 const long* pDXAry,
+											 const sal_Int32* pDXAry,
 											 USHORT nIndex,
 											 USHORT nLen );
 	virtual 			~MetaTextArrayAction();
@@ -605,7 +605,7 @@ public:
 	const XubString&	GetText() const { return maStr; }
 	USHORT				GetIndex() const { return mnIndex; }
 	USHORT				GetLen() const { return mnLen; }
-	long*				GetDXArray() const { return mpDXAry; }
+	sal_Int32*			GetDXArray() const { return mpDXAry; }
 };
 
 // -------------------------
Index: vcl/inc/msgbox.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/msgbox.hxx,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -p -u -r1.5 -r1.6
--- vcl/inc/msgbox.hxx	24 Oct 2002 10:56:12 -0000	1.5
+++ vcl/inc/msgbox.hxx	7 Jan 2004 09:08:49 -0000	1.6
@@ -118,12 +118,9 @@ protected:
     XubString           maCheckBoxText;
     BOOL                mbCheck;
 
-#ifdef _SV_MSGBOX_CXX
-private:
 	void				ImplInitData();
 	void				ImplInitButtons();
 	void				ImplPosControls();
-#endif
 
 protected:
 	void				ImplLoadRes( const ResId& rResId );
@@ -159,10 +156,8 @@ public:
 
 class InfoBox : public MessBox
 {
-#ifdef _SV_MSGBOX_CXX
 private:
 	void				ImplInitData();
-#endif
 
 public:
 						InfoBox( Window* pParent, const XubString& rMessage );
@@ -177,10 +172,8 @@ public:
 
 class WarningBox : public MessBox
 {
-#ifdef _SV_MSGBOX_CXX
 private:
 	void				ImplInitData();
-#endif
 
 public:
 						WarningBox( Window* pParent, WinBits nStyle,
@@ -198,10 +191,8 @@ public:
 
 class ErrorBox : public MessBox
 {
-#ifdef _SV_MSGBOX_CXX
 private:
 	void				ImplInitData();
-#endif
 
 public:
 						ErrorBox( Window* pParent, WinBits nStyle,
@@ -217,10 +208,8 @@ public:
 
 class QueryBox : public MessBox
 {
-#ifdef _SV_MSGBOX_CXX
 private:
 	void				ImplInitData();
-#endif
 
 public:
 						QueryBox( Window* pParent, WinBits nStyle,
Index: vcl/inc/opengl.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/opengl.hxx,v
retrieving revision 1.3
retrieving revision 1.5
diff -u -p -u -r1.3 -r1.5
--- vcl/inc/opengl.hxx	15 Mar 2002 17:10:25 -0000	1.3
+++ vcl/inc/opengl.hxx	7 Jan 2004 09:09:11 -0000	1.5
@@ -80,22 +80,13 @@ class RmOpenGL;
 class OpenGL
 {
 	static BOOL     mbNoOGL;
-private:
 
+private:
 	OutputDevice*	mpOutDev;
-#ifndef REMOTE_APPSERVER
 	SalOpenGL*		mpOGL;
-#else
-	RmOpenGL*		mpOGL;
-#endif
 
-#if _SOLAR__PRIVATE
-#ifdef _SV_OPENGL_CXX
-private:
 	void			ImplInit();
 	BOOL			ImplInitFncPointers();
-#endif
-#endif // __PRIVATE
 
 public:
 					OpenGL( OutputDevice* pOutDev );
Index: vcl/inc/outdata.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/outdata.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/inc/outdata.hxx	19 Sep 2000 10:23:05 -0000	1.1.1.1
+++ vcl/inc/outdata.hxx	7 Jan 2004 09:09:31 -0000	1.3
@@ -66,8 +66,8 @@
 #include <sv.h>
 #endif
 
-#ifndef _SV_COLOR_HXX
-#include <color.hxx>
+#ifndef _TOOLS_COLOR_HXX
+#include <tools/color.hxx>
 #endif
 
 #ifndef _SV_SALGTYPE_HXX
@@ -78,12 +78,10 @@
 // - Hilfemethoden -
 // -----------------
 
-#ifndef REMOTE_APPSERVER
 inline SalColor ImplColorToSal( Color aColor )
 {
 	return MAKE_SALCOLOR( aColor.GetRed(), aColor.GetGreen(), aColor.GetBlue() );
 }
-#endif
 
 inline int ImplIsColorTransparent( Color aColor )
 {
Index: vcl/inc/outdev.h
===================================================================
RCS file: /cvs/gsl/vcl/inc/outdev.h,v
retrieving revision 1.13
retrieving revision 1.14
diff -u -p -u -r1.13 -r1.14
--- vcl/inc/outdev.h	27 Mar 2003 17:57:25 -0000	1.13
+++ vcl/inc/outdev.h	7 Jan 2004 09:09:50 -0000	1.14
@@ -263,7 +263,6 @@ private:
     ImplFontEntry*      mpFirstEntry;
     USHORT              mnRef0Count;
     BOOL                mbPrinter;
-    BOOL                mbDummy;
 
 public:
                         ImplFontCache( BOOL bPrinter );
Index: vcl/inc/outdev.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/outdev.hxx,v
retrieving revision 1.40
retrieving revision 1.51
diff -u -p -u -r1.40 -r1.51
--- vcl/inc/outdev.hxx	6 Jun 2003 10:29:59 -0000	1.40
+++ vcl/inc/outdev.hxx	17 Jun 2004 12:05:32 -0000	1.51
@@ -71,11 +71,11 @@
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
-#ifndef _SV_RC_HXX
-#include <rc.hxx>
+#ifndef _TOOLS_RC_HXX
+#include <tools/rc.hxx>
 #endif
-#ifndef _SV_COLOR_HXX
-#include <color.hxx>
+#ifndef _TOOLS_COLOR_HXX
+#include <tools/color.hxx>
 #endif
 #ifndef _SV_FONT_HXX
 #include <font.hxx>
@@ -92,8 +92,8 @@
 #ifndef _SV_SETTINGS_HXX
 #include <settings.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 
 #include <vector>
@@ -108,7 +108,6 @@ class ImplGetDevFontList;
 class ImplGetDevSizeList;
 class ImplMultiTextLineInfo;
 class SalGraphics;
-class ImplServerGraphics;
 class Gradient;
 class Hatch;
 class Bitmap;
@@ -139,7 +138,10 @@ namespace awt {
 typedef std::vector< Rectangle > MetricVector;
 
 namespace vcl { class PDFWriterImpl; }
 
+#define OUTDEV_BUFFER_SIZE  128
+
+
 // ---------------------
 // - OutputDevice-Data -
 // ---------------------
@@ -196,7 +194,9 @@ struct KerningPair
 #define PUSH_TEXTALIGN                  ((USHORT)0x0100)
 #define PUSH_REFPOINT                   ((USHORT)0x0200)
 #define PUSH_TEXTLINECOLOR              ((USHORT)0x0400)
-#define PUSH_ALLTEXT                    (PUSH_TEXTCOLOR | PUSH_TEXTFILLCOLOR | PUSH_TEXTLINECOLOR | PUSH_TEXTALIGN)
+#define PUSH_TEXTLAYOUTMODE             ((USHORT)0x0800)
+#define PUSH_TEXTLANGUAGE               ((USHORT)0x1000)
+#define PUSH_ALLTEXT                    (PUSH_TEXTCOLOR | PUSH_TEXTFILLCOLOR | PUSH_TEXTLINECOLOR | PUSH_TEXTALIGN | PUSH_TEXTLAYOUTMODE | PUSH_TEXTLANGUAGE)
 #define PUSH_ALLFONT                    (PUSH_ALLTEXT | PUSH_FONT)
 #define PUSH_ALL                        ((USHORT)0xFFFF)
 
@@ -224,10 +224,11 @@ struct KerningPair
 #define IMAGE_DRAW_DISABLE              ((USHORT)0x0001)
 #define IMAGE_DRAW_HIGHLIGHT            ((USHORT)0x0002)
 #define IMAGE_DRAW_DEACTIVE             ((USHORT)0x0004)
-#define IMAGE_DRAW_COLORTRANSFORM       ((USHORT)0x0008)
+#define IMAGE_DRAW_COLORTRANSFORM      	((USHORT)0x0008)
 #define IMAGE_DRAW_SEMITRANSPARENT      ((USHORT)0x0010)
+#define IMAGE_DRAW_MONOCHROME_BLACK  	((USHORT)0x0020)
+#define IMAGE_DRAW_MONOCHROME_WHITE  	((USHORT)0x0040)
 #define IMAGE_DRAW_3DLOOK               0
-
 #define IMAGE_DRAW_BTNLOOK              0
 
 // WaveLine
@@ -327,20 +328,24 @@ enum OutDevViewType { OUTDEV_VIEWTYPE_DO
 
 class OutputDevice : public Resource
 {
-    friend class Window;
-    friend class VirtualDevice;
-    friend class Printer;
-    friend class ImplQPrinter;
-    friend class OpenGL;
-    friend class ::vcl::PDFWriterImpl;
-    friend class SalGraphicsLayout;
+	friend class Application;
+	friend class Bitmap;
+	friend class ImplImageBmp;
+	friend class ImplQPrinter;
+	friend class OpenGL;
+	friend class Printer;
+	friend class RMBitmap;
+	friend class RMBitmapEx;
+	friend class SalGraphicsLayout;
+	friend class System;
+	friend class VirtualDevice;
+	friend class Window;
+	friend class WorkWindow;
+	friend class vcl::PDFWriterImpl;
+	friend const char* ImplDbgCheckOutputDevice( const void* pObj );
 
 private:
-#ifndef REMOTE_APPSERVER
     mutable SalGraphics*        mpGraphics;
-#else
-    mutable ImplServerGraphics* mpGraphics;
-#endif
     mutable OutputDevice*       mpPrevGraphics;
     mutable OutputDevice*       mpNextGraphics;
     GDIMetaFile*        mpMetaFile;
@@ -354,7 +359,10 @@ private:
     List*               mpUnoGraphicsList;
     OutDev3D*           mp3DContext;
     vcl::PDFWriterImpl* mpPDFWriter;
-    void*               mpDummy1;
+
+    // TEMP TEMP TEMP
+    VirtualDevice*      mpAlphaVDev;
+
     /// Additional output pixel offset, applied in LogicToPixel (used by SetPixelOffset/GetPixelOffset)
     long				mnOutOffOrigX;
     /// Additional output offset in _logical_ coordinates, applied in PixelToLogic (used by SetPixelOffset/GetPixelOffset)
@@ -369,8 +377,8 @@ private:
     long                mnOutOffY;
     long                mnOutWidth;
     long                mnOutHeight;
-    long                mnDPIX;
-    long                mnDPIY;
+    sal_Int32           mnDPIX;
+    sal_Int32           mnDPIY;
     /// Output offset for text alignment in pixel
     long                mnTextOffX;
     /// Output offset for text alignment in pixel
@@ -379,7 +387,6 @@ private:
     long                mnEmphasisDescent;
     ULONG               mnDrawMode;
     ULONG               mnTextLayoutMode;
-    long                mnDummy1;
     ImplMapRes          maMapRes;
     ImplThresholdRes    maThresRes;
     OutDevType          meOutDevType;
@@ -389,7 +396,6 @@ private:
     Color               maFillColor;
     Font                maFont;
     Color               maTextColor;
-    Color               maTextFillColorDummy; // For compatibility to SV we work with the font fill color
     Color               maTextLineColor;
     TextAlign           meTextAlign;
     RasterOp            meRasterOp;
@@ -399,8 +405,6 @@ private:
     Point               maRefPoint;
     USHORT              mnAntialiasing;
     LanguageType        meTextLanguage;
-    USHORT              mnDummy3;
-    USHORT              mnDummy4;
     mutable BOOL       mbMap:1,
                         mbMapIsDefault:1,
                         mbClipRegion:1,
@@ -421,12 +425,121 @@ private:
                         mbTextLines:1,
                         mbTextSpecial:1,
                         mbRefPoint:1,
-                        mbEnableRTL:1,
-                        mbDummy2:1,
-                        mbDummy3:1;
+                        mbEnableRTL:1;
 
 #if _SOLAR__PRIVATE
-#include <outdev.imp>
+public:
+	sal_Int32			ImplGetDPIX() const { return mnDPIX; }
+	sal_Int32			ImplGetDPIY() const { return mnDPIY; }
+	int 				ImplGetGraphics() const;
+	void				ImplReleaseGraphics( BOOL bRelease = TRUE );
+    BOOL                ImplHasMirroredGraphics();
+    void                ImplReMirror( Point &rPoint ) const;
+    void                ImplReMirror( Rectangle &rRect ) const;
+    void                ImplReMirror( Region &rRegion ) const;
+	void				ImplInitOutDevData();
+	void				ImplDeInitOutDevData();
+	void				ImplInitLineColor();
+	void				ImplInitFillColor();
+	int 				ImplNewFont();
+	void				ImplInitFont();
+	void				ImplInitTextColor();
+	void				ImplInitKerningPairs( ImplKernPairData* pKernPairs = 0, long nKernPairs = 0 );
+	void				ImplInitClipRegion();
+	static BOOL 		ImplSelectClipRegion( SalGraphics* pGraphics, const Region& rRegion, OutputDevice *pOutDev );
+	void				ImplSetClipRegion( const Region* pRegion );
+
+    SalLayout*          ImplLayout( const String& rOrigStr, xub_StrLen nIndex,
+                            xub_StrLen nLen, const Point& rLogicPos = Point(0,0),
+                            long nLogicWidth=0, const sal_Int32* pLogicDXArray=NULL ) const;
+    long                ImplGetTextWidth( const SalLayout& ) const;
+    void                ImplDrawTextBackground( const SalLayout& );
+    void                ImplDrawTextLines( SalLayout&, FontStrikeout eStrikeout, FontUnderline eUnderline, BOOL bWordLine, BOOL bUnderlineAbove );
+    bool                ImplDrawRotateText( SalLayout& );
+    void                ImplDrawTextDirect( SalLayout&, BOOL bTextLines );
+    void                ImplDrawSpecialText( SalLayout& );
+    void                ImplDrawText( SalLayout& );
+    Rectangle           ImplGetTextBoundRect( const SalLayout& );
+	void				ImplDrawEmphasisMarks( SalLayout& );
+
+    void				ImplDrawTextRect( long nBaseX, long nBaseY, long nX, long nY, long nWidth, long nHeight );
+
+	void				ImplInitTextLineSize();
+	void				ImplInitAboveTextLineSize();
+	void				ImplDrawWaveLine( long nBaseX, long nBaseY, long nStartX, long nStartY, long nWidth, long nHeight, long nLineWidth, short nOrientation, const Color& rColor );
+    void                ImplDrawTextLine( long nBaseX, long nX, long nY, long nWidth, FontStrikeout eStrikeout, FontUnderline eUnderline, BOOL bUnderlineAbove );
+	void				ImplDrawMnemonicLine( long nX, long nY, long nWidth );
+    void				ImplGetEmphasisMark( PolyPolygon& rPolyPoly, BOOL& rPolyLine, Rectangle& rRect1, Rectangle& rRect2, long& rYOff, long& rWidth, FontEmphasisMark eEmphasis, long nHeight, short nOrient );
+	void				ImplDrawEmphasisMark( long nBaseX, long nX, long nY, const PolyPolygon& rPolyPoly, BOOL bPolyLine, const Rectangle& rRect1, const Rectangle& rRect2 );
+	long				ImplGetTextLines( ImplMultiTextLineInfo& rLineInfo, long nWidth, const XubString& rStr, USHORT nStyle ) const;
+    void				ImplInitFontList() const;
+	void				ImplUpdateFontData( BOOL bNewFontLists );
+	static void 		ImplUpdateAllFontData( BOOL bNewFontLists );
+	long				ImplLogicXToDevicePixel( long nX ) const;
+	long				ImplLogicYToDevicePixel( long nY ) const;
+	long				ImplLogicWidthToDevicePixel( long nWidth ) const;
+	long				ImplLogicHeightToDevicePixel( long nHeight ) const;
+	long				ImplDevicePixelToLogicWidth( long nWidth ) const;
+	long				ImplDevicePixelToLogicHeight( long nHeight ) const;
+	Point				ImplLogicToDevicePixel( const Point& rLogicPt ) const;
+	Size				ImplLogicToDevicePixel( const Size& rLogicSize ) const;
+	Rectangle			ImplLogicToDevicePixel( const Rectangle& rLogicRect ) const;
+	Polygon 			ImplLogicToDevicePixel( const Polygon& rLogicPoly ) const;
+	PolyPolygon 		ImplLogicToDevicePixel( const PolyPolygon& rLogicPolyPoly ) const;
+	LineInfo			ImplLogicToDevicePixel( const LineInfo& rLineInfo ) const;
+	Rectangle			ImplDevicePixelToLogic( const Rectangle& rLogicRect ) const;
+	Region				ImplPixelToDevicePixel( const Region& rRegion ) const;
+	void				ImplDrawPolygon( const Polygon& rPoly, const PolyPolygon* pClipPolyPoly = NULL );
+	void				ImplDrawPolyPolygon( const PolyPolygon& rPolyPoly, const PolyPolygon* pClipPolyPoly = NULL );
+	void 				ImplDrawPolyPolygon( USHORT nPoly, const PolyPolygon& rPolyPoly );
+	void				ImplDrawLinearGradient( const Rectangle& rRect, const Gradient& rGradient, BOOL bMtf, const PolyPolygon* pClipPolyPoly );
+	void				ImplDrawComplexGradient( const Rectangle& rRect, const Gradient& rGradient, BOOL bMtf, const PolyPolygon* pClipPolyPoly );
+
+	void				ImplDrawHatch( const PolyPolygon& rPolyPoly, const Hatch& rHatch, BOOL bMtf );
+	void				ImplCalcHatchValues( const Rectangle& rRect, long nDist, USHORT nAngle10, Point& rPt1, Point& rPt2, Size& rInc, Point& rEndPt1 );
+	void				ImplDrawHatchLine( const Line& rLine, const PolyPolygon& rPolyPoly, Point* pPtBuffer, BOOL bMtf );
+
+	void				ImplDrawWallpaper( long nX, long nY, long nWidth, long nHeight, const Wallpaper& rWallpaper );
+	void				ImplDrawColorWallpaper( long nX, long nY, long nWidth, long nHeight, const Wallpaper& rWallpaper );
+	void				ImplDrawBitmapWallpaper( long nX, long nY, long nWidth, long nHeight, const Wallpaper& rWallpaper );
+	void				ImplDrawGradientWallpaper( long nX, long nY, long nWidth, long nHeight, const Wallpaper& rWallpaper );
+	void				ImplDraw2ColorFrame( const Rectangle& rRect, const Color& rLeftTopColor, const Color& rRightBottomColor );
+
+	void				ImplDrawOutDevDirect( const OutputDevice* pSrcDev, void* pPosAry );
+	void				ImplDrawBitmap( const Point& rDestPt, const Size& rDestSize,
+										const Point& rSrcPtPixel, const Size& rSrcSizePixel,
+										const Bitmap& rBitmap, const ULONG nAction );
+	void				ImplDrawBitmapEx( const Point& rDestPt, const Size& rDestSize,
+										  const Point& rSrcPtPixel, const Size& rSrcSizePixel,
+										  const BitmapEx& rBitmapEx, const ULONG nAction );
+	void				ImplDrawMask( const Point& rDestPt, const Size& rDestSize,
+									  const Point& rSrcPtPixel, const Size& rSrcSizePixel,
+									  const Bitmap& rBitmap, const Color& rMaskColor,
+									  const ULONG nAction );
+	void				ImplDrawAlpha( const Bitmap& rBmp, const AlphaMask& rAlpha,
+									   const Point& rDestPt, const Size& rDestSize,
+									   const Point& rSrcPtPixel, const Size& rSrcSizePixel );
+	void				ImplPrintTransparent( const Bitmap& rBmp, const Bitmap& rMask,
+											  const Point& rDestPt, const Size& rDestSize,
+											  const Point& rSrcPtPixel, const Size& rSrcSizePixel );
+	void				ImplPrintMask( const Bitmap& rMask, const Color& rMaskColor,
+									   const Point& rDestPt, const Size& rDestSize,
+									   const Point& rSrcPtPixel, const Size& rSrcSizePixel );
+	void				ImplDrawFrameDev( const Point& rPt, const Point& rDevPt, const Size& rDevSize,
+										  const OutputDevice& rOutDev, const Region& rRegion );
+	void				ImplGetFrameDev( const Point& rPt, const Point& rDevPt, const Size& rDevSize,
+										 OutputDevice& rOutDev );
+	void				ImplGetFrameBitmap( const Point& rPt, const Size& rSize,
+											Bitmap& rBitmap ) const;
+
+    BOOL				ImplIsRecordLayout() const;
+
+    void         		ImplAddDevFontSubstitute( const XubString& rFontName,
+                                                  const XubString& rReplaceFontName,
+                                                  USHORT nFlags = 0 );
+
+    static FontEmphasisMark ImplGetEmphasisMarkStyle( const Font& rFont );
+    static BOOL ImplIsUnderlineAbove( const Font& );
 #endif
 
 protected:
@@ -459,15 +572,15 @@ public:
                                       xub_StrLen nLen = STRING_LEN ) const;
     long                GetTextHeight() const;
     void                DrawTextArray( const Point& rStartPt, const XubString& rStr,
-                                       const long* pDXAry = NULL,
+                                       const sal_Int32* pDXAry = NULL,
                                        xub_StrLen nIndex = 0,
                                        xub_StrLen nLen = STRING_LEN );
-    long                GetTextArray( const XubString& rStr, long* pDXAry = NULL,
+    long                GetTextArray( const XubString& rStr, sal_Int32* pDXAry = NULL,
                                       xub_StrLen nIndex = 0,
                                       xub_StrLen nLen = STRING_LEN ) const;
-    bool                GetCaretPositions( const XubString&, long* pCaretXArray,
+    bool                GetCaretPositions( const XubString&, sal_Int32* pCaretXArray,
                                       xub_StrLen nIndex, xub_StrLen nLen,
-                                      long* pDXAry = NULL, long nWidth = 0,
+                                      sal_Int32* pDXAry = NULL, long nWidth = 0,
                                       BOOL bCellBreaking = TRUE ) const;
     void                DrawStretchText( const Point& rStartPt, ULONG nWidth,
                                          const XubString& rStr,
@@ -505,10 +618,10 @@ public:
                             xub_StrLen nLen = STRING_LEN ) const;
     BOOL                GetTextOutline( PolyPolygon&,
                             const String& rStr, xub_StrLen nBase = 0, xub_StrLen nIndex = 0,
-                            xub_StrLen nLen = STRING_LEN, BOOL bOptimize = TRUE, const ULONG nWidth = 0, const long* pDXArray = NULL ) const;
+                            xub_StrLen nLen = STRING_LEN, BOOL bOptimize = TRUE, const ULONG nWidth = 0, const sal_Int32* pDXArray = NULL ) const;
     BOOL                GetTextOutlines( PolyPolyVector&,
                             const String& rStr, xub_StrLen nBase = 0, xub_StrLen nIndex = 0,
-                            xub_StrLen nLen = STRING_LEN, BOOL bOptimize = TRUE, const ULONG nWidth = 0, const long* pDXArray = NULL ) const;
+                            xub_StrLen nLen = STRING_LEN, BOOL bOptimize = TRUE, const ULONG nWidth = 0, const sal_Int32* pDXArray = NULL ) const;
     BOOL				GetGlyphBoundRects( const Point& rOrigin, const String& rStr, int nIndex,
                             int nLen, int nBase, MetricVector& rVector );
 
@@ -517,10 +630,52 @@ public:
     void                DrawLine( const Point& rStartPt, const Point& rEndPt );
     void                DrawLine( const Point& rStartPt, const Point& rEndPt,
                                   const LineInfo& rLineInfo );
+
+    /** Render the given polygon as a line stroke
+
+		The given polygon is stroked with the current LineColor, start
+		and end point are not automatically connected
+
+        @see DrawPolygon
+        @see DrawPolyPolygon
+     */
     void                DrawPolyLine( const Polygon& rPoly );
+
+    /** Render the given polygon as a line stroke
+
+		The given polygon is stroked with the current LineColor, start
+		and end point are not automatically connected. The line is
+		rendered according to the specified LineInfo, e.g. supplying a
+		dash pattern, or a line thickness.
+
+        @see DrawPolygon
+        @see DrawPolyPolygon
+     */
     void                DrawPolyLine( const Polygon& rPoly,
                                       const LineInfo& rLineInfo );
+
+    /** Render the given polygon
+
+		The given polygon is stroked with the current LineColor, and
+		filled with the current FillColor. If one of these colors are
+		transparent, the corresponding stroke or fill stays
+		invisible. Start and end point of the polygon are
+		automatically connected.
+
+        @see DrawPolyLine
+     */
     void                DrawPolygon( const Polygon& rPoly );
+
+    /** Render the given poly-polygon
+
+		The given poly-polygon is stroked with the current LineColor,
+		and filled with the current FillColor. If one of these colors
+		are transparent, the corresponding stroke or fill stays
+		invisible. Start and end points of the contained polygons are
+		automatically connected.
+
+        @see DrawPolyLine
+     */
     void                DrawPolyPolygon( const PolyPolygon& rPolyPoly );
     void                DrawRect( const Rectangle& rRect );
     void                DrawRect( const Rectangle& rRect,
@@ -606,17 +755,21 @@ public:
 
     Bitmap              GetBitmap( const Point& rSrcPt, const Size& rSize ) const;
 
-    void                EnableMapMode( BOOL bEnable = TRUE ) { mbMap = (bEnable != 0); }
+    /** Query extended bitmap (with alpha channel, if available).
+     */
+    BitmapEx            GetBitmapEx( const Point& rSrcPt, const Size& rSize ) const;
+
+    void                EnableMapMode( BOOL bEnable = TRUE );
     BOOL                IsMapModeEnabled() const { return mbMap; }
 
     // Enabling/disabling RTL only makes sense for OutputDevices that use a mirroring SalGraphisLayout
     void                EnableRTL( BOOL bEnable = TRUE);
     BOOL                IsRTLEnabled() const { return mbEnableRTL; }
 
-    void                SetConnectMetaFile( GDIMetaFile* pMtf ) { mpMetaFile = pMtf; }
+    void                SetConnectMetaFile( GDIMetaFile* pMtf );
     GDIMetaFile*        GetConnectMetaFile() const { return mpMetaFile; }
 
-    void                EnableOutput( BOOL bEnable = TRUE ) { mbOutput = (bEnable != 0); }
+    void                EnableOutput( BOOL bEnable = TRUE );
     BOOL                IsOutputEnabled() const { return mbOutput; }
     BOOL                IsDeviceOutput() const { return mbDevOutput; }
     BOOL                IsDeviceOutputNecessary() const { return (mbOutput && mbDevOutput); }
@@ -676,7 +829,7 @@ public:
     void                SetFont( const Font& rNewFont );
     const Font&         GetFont() const { return maFont; }
     void                SetTextColor( const Color& rColor );
-    const Color&        GetTextColor() const { return maFont.GetColor(); }
+    const Color&        GetTextColor() const { return maTextColor; }
     void                SetTextFillColor();
     void                SetTextFillColor( const Color& rColor );
 
@@ -689,6 +842,6 @@ public:
     void                SetTextAlign( TextAlign eAlign );
     TextAlign           GetTextAlign() const { return maFont.GetAlign(); }
 
-    void                SetSettings( const AllSettings& rSettings ) { maSettings = rSettings; }
+    void                SetSettings( const AllSettings& rSettings );
     const AllSettings&  GetSettings() const { return maSettings; }
 
@@ -811,6 +953,11 @@ public:
 
     Size                GetOutputSizePixel() const
                             { return Size( mnOutWidth, mnOutHeight ); }
+    long				GetOutputWidthPixel() const { return mnOutWidth; }
+    long				GetOutputHeightPixel() const { return mnOutHeight; }
+    long				GetOutOffXPixel() const { return mnOutOffX; }
+    long				GetOutOffYPixel() const { return mnOutOffY; }
+    
     Size                GetOutputSize() const
                             { return PixelToLogic( GetOutputSizePixel() ); }
 
@@ -831,9 +978,22 @@ public:
     USHORT              GetBitCount() const;
+
+    /** Query the existence and depth of the alpha channel
+
+    	@return 0, if no alpha channel available, and the bit depth of
+    	the alpha channel otherwise.
+     */
+    USHORT              GetAlphaBitCount() const;
     ULONG               GetColorCount() const;
 
     void                Push( USHORT nFlags = PUSH_ALL );
     void                Pop();
 
+    /** Query availability of alpha channel
+
+    	@return TRUE, if this device has an alpha channel.
+     */
+    BOOL				HasAlpha();
+    
     void                DrawEPS( const Point& rPt, const Size& rSz,
                                  const GfxLink& rGfxLink, GDIMetaFile* pSubst = NULL );
 

Index: vcl/inc/pdfwriter.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/pdfwriter.hxx,v
retrieving revision 1.6
retrieving revision 1.8
diff -u -p -u -r1.6 -r1.8
--- vcl/inc/pdfwriter.hxx	28 May 2003 12:29:54 -0000	1.6
+++ vcl/inc/pdfwriter.hxx	17 Jun 2004 12:05:47 -0000	1.8
@@ -73,7 +73,7 @@
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
-#ifndef _COLOR_HXX
+#ifndef _TOOLS_COLOR_HXX
 #include <tools/color.hxx>
 #endif
 
@@ -191,7 +191,7 @@ public:
                                       FontUnderline eUnderline,
                                       BOOL bUnderlineAbove = FALSE );
     void				DrawTextArray( const Point& rStartPt, const XubString& rStr,
-                                       const long* pDXAry = NULL,
+                                       const sal_Int32* pDXAry = NULL,
                                        xub_StrLen nIndex = 0,
                                        xub_StrLen nLen = STRING_LEN );
     void				DrawStretchText( const Point& rStartPt, ULONG nWidth,
Index: vcl/inc/pngread.hxx
===================================================================
RCS file: vcl/inc/pngread.hxx
diff -N vcl/inc/pngread.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/inc/pngread.hxx	28 Jun 2004 16:05:43 -0000	1.3
@@ -0,0 +1,101 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_PNGREAD_HXX
+#define _SV_PNGREAD_HXX
+
+#ifndef _SV_BITMAPEX_HXX
+#include <bitmapex.hxx>
+#endif
+#include <vector>
+
+// -------------
+// - PNGReader -
+// -------------
+
+namespace vcl
+{
+	class PNGReaderImpl;
+
+	class PNGReader
+	{
+		PNGReaderImpl*			mpImpl;
+
+	public:
+
+		/* the PNG chunks are read within the c'tor, so the stream will
+		be positioned at the end of the PNG */
+		PNGReader( SvStream& rStm );
+		~PNGReader();
+	
+		BitmapEx						Read();
+
+		// retrieve every chunk that resides inside the PNG
+		struct ChunkData
+		{
+			sal_uInt32					nType;
+			std::vector< sal_uInt8 >	aData;
+		};
+		const std::vector< ChunkData >&	GetChunks() const;
+	};
+}
+
+#endif // _SV_PNGREAD_HXX
Index: vcl/inc/pngwrite.hxx
===================================================================
RCS file: vcl/inc/pngwrite.hxx
diff -N vcl/inc/pngwrite.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/inc/pngwrite.hxx	28 Jun 2004 16:05:57 -0000	1.3
@@ -0,0 +1,106 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_PNGWRITE_HXX
+#define _SV_PNGWRITE_HXX
+
+#ifndef _COM_SUN_STAR_UNO_SEQUENCE_HXX_
+#include <com/sun/star/uno/Sequence.hxx>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_
+#include <com/sun/star/beans/PropertyValue.hpp>
+#endif
+#ifndef _SV_BITMAPEX_HXX
+#include <bitmapex.hxx>
+#endif
+#include <vector>
+
+// -------------
+// - PNGWriter -
+// -------------
+
+namespace vcl
+{
+	class PNGWriterImpl;
+
+	class PNGWriter
+	{
+		PNGWriterImpl*			mpImpl;
+
+	public:
+
+		PNGWriter( const BitmapEx& BmpEx,
+			const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >* pFilterData = NULL );
+		~PNGWriter();
+
+		sal_Bool Write( SvStream& rStm );
+
+		// additional method to be able to modify all chunk before they are stored
+		struct ChunkData
+		{
+			sal_uInt32					nType;
+			std::vector< sal_uInt8 >	aData;
+		};
+		std::vector< vcl::PNGWriter::ChunkData >& GetChunks();
+	};
+}
+
+#endif // _SV_PNGWRITE_HXX
Index: vcl/inc/print.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/print.hxx,v
retrieving revision 1.17
retrieving revision 1.19
diff -u -p -u -r1.17 -r1.19
--- vcl/inc/print.hxx	27 Mar 2003 17:57:29 -0000	1.17
+++ vcl/inc/print.hxx	7 Jan 2004 09:11:49 -0000	1.19
@@ -85,12 +85,9 @@
 #include <tools/stream.hxx>
 #endif
 
-#if defined REMOTE_APPSERVER
-#include <vector>
-#endif
-
 struct SalPrinterInfoQueue;
 class SalInfoPrinter;
+struct SalPrinterQueueInfo;
 class SalPrinter;
 class VirtualDevice;
 class Window;
@@ -101,10 +98,6 @@ namespace com { namespace sun { namespac
 	class Any;
 } } } }
 
-#ifdef REMOTE_APPSERVER
-namespace com { namespace sun { namespace star { namespace portal { namespace client { struct RmJobSetup; } } } } }
-#endif
-
 // -----------------
 // - Printer-Types -
 // -----------------
@@ -268,29 +261,17 @@ class Printer : public OutputDevice
 	friend class ImplQPrinter;
 
 private:
-#ifndef REMOTE_APPSERVER
+	void*						mpPrinterData_NotUsedYet;
 	SalInfoPrinter* 			mpInfoPrinter;
 	SalPrinter* 				mpPrinter;
 	Printer*					mpJobPrinter;
 	SalGraphics*				mpJobGraphics;
-#else
-	RmPrinter*					mpInfoPrinter;
-	RmPrinter*					mpPrinter;
-	void*						mpJobPrinter;
-	void*						mpJobGraphics;
-#endif
 	Printer*					mpPrev;
 	Printer*					mpNext;
 	VirtualDevice*				mpDisplayDev;
 	ImplQPrinter*				mpQPrinter;
 	GDIMetaFile*				mpQMtf;
     PrinterOptions*             mpPrinterOptions;
-#ifndef REMOTE_APPSERVER
-	void*						mpDummy2;
-#else
-    ::std::vector< PrinterPage* >* mpRemotePages;
-#endif
-	void*						mpDummy3;
 	XubString					maPrinterName;
 	XubString					maDriver;
 	XubString					maPrintFile;
@@ -313,18 +294,11 @@ private:
 	BOOL						mbIsQueuePrinter;
 	BOOL						mbUserSetupCompleted;
 	BOOL						mbUserSetupResult;
-	BOOL						mbDummy3;
 	Link						maErrorHdl;
 	Link						maStartPrintHdl;
 	Link						maEndPrintHdl;
 	Link						maPrintPageHdl;
 
-#ifdef REMOTE_APPSERVER
-	DECL_LINK( UserSetupCompleted, ::com::sun::star::uno::Any* );
-#endif
-
-#if _SOLAR__PRIVATE
-#ifdef _SV_PRINT_CXX
 	void						ImplInitData();
 	void						ImplInit( SalPrinterQueueInfo* pInfo );
 	void						ImplInitDisplay( const Window* pWindow );
@@ -333,19 +307,11 @@ private:
 	void						ImplUpdatePageData();
 	void						ImplUpdateFontList();
 	void						ImplFindPaperFormatForUserSize( JobSetup& );
-#endif // _SV_PRINT_CXX
-#ifndef REMOTE_APPSERVER
-
 								DECL_LINK( ImplDestroyPrinterAsync, void* );
+#if _SOLAR__PRIVATE
 public:
-
 	void						ImplEndPrint();
-#else
-public:
-    void PrintRemotePage( ULONG nPage );
-    void GetRemotePageSetup( ULONG nPage, ::com::sun::star::portal::client::RmJobSetup& rSetup );
-#endif // REMOTE_APPSERVER
-#endif // __PRIVATE
+#endif
 
 #ifdef _SPOOLPRINTER_EXT
 public:
Index: vcl/inc/regband.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/regband.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/regband.hxx	19 Sep 2000 10:23:06 -0000	1.1.1.1
+++ vcl/inc/regband.hxx	7 Jan 2004 09:13:14 -0000	1.2
@@ -65,8 +65,8 @@
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 
 /* =======================================================================
Index: vcl/inc/region.h
===================================================================
RCS file: /cvs/gsl/vcl/inc/region.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/region.h	19 Sep 2000 10:23:06 -0000	1.1.1.1
+++ vcl/inc/region.h	7 Jan 2004 09:13:32 -0000	1.2
@@ -68,8 +68,8 @@
 #ifndef _SV_REGBAND_HXX
 #include <regband.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 
 #ifndef _SV_REGION_HXX
Index: vcl/inc/region.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/region.hxx,v
retrieving revision 1.3
retrieving revision 1.5
diff -u -p -u -r1.3 -r1.5
--- vcl/inc/region.hxx	18 Jun 2001 12:53:13 -0000	1.3
+++ vcl/inc/region.hxx	7 Jan 2004 09:13:51 -0000	1.5
@@ -91,11 +91,30 @@ typedef long RegionHandle;
 
 class Region
 {
+	friend class OutputDevice;
+	friend class Window;
+	friend class Bitmap;
+
 private:
-	ImplRegion* 	mpImplRegion;
+	ImplRegion* 		mpImplRegion;
+
+	void				ImplCopyData();
+	void				ImplCreateRectRegion( const Rectangle& rRect );
+	void				ImplCreatePolyPolyRegion( const PolyPolygon& rPolyPoly );
+	void				ImplPolyPolyRegionToBandRegionFunc();
+	inline void 		ImplPolyPolyRegionToBandRegion();
+	const ImplRegion*	ImplGetImplRegion() const { return mpImplRegion; }
+	ImplRegion* 		ImplGetImplRegion() { return mpImplRegion; }
+	BOOL				ImplGetFirstRect( ImplRegionInfo& rImplRegionInfo,
+										  long& nX, long& nY, long& nWidth, long& nHeight ) const;
+	BOOL				ImplGetNextRect( ImplRegionInfo& rImplRegionInfo,
+										 long& nX, long& nY, long& nWidth, long& nHeight ) const;
+	void				ImplBeginAddRect( );
+	BOOL				ImplAddRect( const Rectangle& rRect );
+	void				ImplEndAddRect( );
 
-#if _SOLAR__PRIVATE
-#include <region.imp>
+#ifdef DBG_UTIL
+	friend const char*	ImplDbgTestRegion( const void* pObj );
 #endif
 
 public:
@@ -150,9 +169,6 @@ public:
 
 	friend SvStream& operator>>( SvStream& rIStm, Region& rRegion );
 	friend SvStream& operator<<( SvStream& rOStm, const Region& rRegion );
-
-	// usage of this function is only intended for the remote client
-	RegionOverlapType  GetOverlapType( const Rectangle& rRect ) const;
 };
 
 #endif	// _SV_REGION_HXX
Index: vcl/inc/salbmp.hxx
===================================================================
RCS file: vcl/inc/salbmp.hxx
diff -N vcl/inc/salbmp.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/inc/salbmp.hxx	18 Nov 2003 14:28:29 -0000	1.2
@@ -0,0 +1,96 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALBMP_HXX
+#define _SV_SALBMP_HXX
+
+#ifndef _TL_GEN_HXX
+#include <tools/gen.hxx>
+#endif
+
+struct BitmapBuffer;
+class SalGraphics;
+class BitmapPalette;
+
+class SalBitmap
+{
+public:
+    SalBitmap() {}
+    virtual ~SalBitmap();
+    
+    virtual bool			Create( const Size& rSize, 
+                                    USHORT nBitCount, 
+                                    const BitmapPalette& rPal ) = 0;
+	virtual bool			Create( const SalBitmap& rSalBmp ) = 0;
+	virtual bool			Create( const SalBitmap& rSalBmp, 
+                                    SalGraphics* pGraphics ) = 0;
+	virtual bool			Create( const SalBitmap& rSalBmp,
+                                    USHORT nNewBitCount ) = 0;
+	virtual void			Destroy() = 0;
+	virtual Size			GetSize() const = 0;
+	virtual USHORT			GetBitCount() const = 0;
+						
+	virtual BitmapBuffer*	AcquireBuffer( bool bReadOnly ) = 0;
+	virtual void			ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly ) = 0;
+
+};
+
+#endif
Index: vcl/inc/salctrlhandle.hxx
===================================================================
RCS file: vcl/inc/salctrlhandle.hxx
diff -N vcl/inc/salctrlhandle.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/inc/salctrlhandle.hxx	10 May 2004 15:42:11 -0000	1.2
@@ -0,0 +1,82 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALCTRLHANDLE_HXX
+#define _SV_SALCTRLHANDLE_HXX
+
+/* SalControlHandle:
+ *
+ *   Container for platform-specific handles and data
+ *   about controls.  Lives as long as the VCL control
+ *   lives.
+ */
+
+class SalControlHandle
+{
+	public:
+		SalControlHandle() {}
+		virtual ~SalControlHandle();
+
+        // TODO: derive Sal implementation
+		//SalControlHandleData	maData;
+};
+
+#endif
Index: vcl/inc/salframe.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/salframe.hxx,v
retrieving revision 1.16
retrieving revision 1.19
diff -u -p -u -r1.16 -r1.19
--- vcl/inc/salframe.hxx	24 Apr 2003 15:16:48 -0000	1.16
+++ vcl/inc/salframe.hxx	10 May 2004 15:42:24 -0000	1.19
@@ -80,9 +80,6 @@
 #ifndef _SV_SALWTYPE_HXX
 #include <salwtype.hxx>
 #endif
-#ifndef _SV_SALFRAME_H
-#include <salframe.h>
-#endif
 #ifndef _SV_SALGEOM_HXX
 #include <salgeom.hxx>
 #endif
@@ -91,11 +88,20 @@
 #include <tools/gen.hxx>
 #endif
 
+#ifndef _SV_REGION_HXX
+#include <region.hxx>
+#endif
+
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
+#endif
+
 #ifdef __cplusplus
 
 class AllSettings;
 class SalGraphics;
 class SalBitmap;
+class SalMenu;
 
 #else
 
@@ -160,112 +166,119 @@ struct SystemEnvData;
 
 #ifdef __cplusplus
 
+using namespace rtl;
+
 // ------------
 // - SalFrame -
 // ------------
 
+struct SystemParentData;
+
 class SalFrame
 {
-    friend class SalInstance;
-
+    void*					m_pInst;
+    SALFRAMEPROC			m_pProc;
 public:                     // public for Sal Implementation
-                            SalFrame();
-                            ~SalFrame();
+    SalFrame() : m_pInst( NULL ), m_pProc( NULL ) {}
+    virtual ~SalFrame();
 
 public:                     // public for Sal Implementation
-    SalFrameData            maFrameData;
     SalFrameGeometry		maGeometry;
-    static BOOL             mbInReparent;
-
-#ifdef _INCL_SAL_SALFRAME_IMP
-#include <salframe.imp>
-#endif
 
 public:
     // SalGraphics or NULL, but two Graphics for all SalFrames
     // must be returned
-    SalGraphics*            GetGraphics();
-    void                    ReleaseGraphics( SalGraphics* pGraphics );
+    virtual SalGraphics*		GetGraphics() = 0;
+    virtual void				ReleaseGraphics( SalGraphics* pGraphics ) = 0;
 
     // Event must be destroyed, when Frame is destroyed
     // When Event is called, SalInstance::Yield() must be returned
-    BOOL                    PostEvent( void* pData );
+    virtual BOOL				PostEvent( void* pData ) = 0;
 
-    void                    SetTitle( const XubString& rTitle );
-    void                    SetIcon( USHORT nIcon );
-
-                            // Befor the window is visible, a resize event
-                            // must be sent with the correct size
-    void                    Show( BOOL bVisible, BOOL bNoActivate = FALSE );
-    void                    Enable( BOOL bEnable );
-                            // Set ClientSize and Center the Window to the desktop
-                            // and send/post a resize message
-    void                    SetMinClientSize( long nWidth, long nHeight );
-    void                    SetPosSize( long nX, long nY, long nWidth, long nHeight, USHORT nFlags );
-    void                    GetClientSize( long& rWidth, long& rHeight );
-    void                    GetWorkArea( Rectangle& rRect );
-    SalFrame*               GetParent() const;
+    virtual void				SetTitle( const XubString& rTitle ) = 0;
+    virtual void				SetIcon( USHORT nIcon ) = 0;
+    virtual void                    SetMenu( SalMenu *pSalMenu ) = 0;
+    virtual void                    DrawMenuBar() = 0;
+
+    // Before the window is visible, a resize event
+    // must be sent with the correct size
+    virtual void				Show( BOOL bVisible, BOOL bNoActivate = FALSE ) = 0;
+    virtual void				Enable( BOOL bEnable ) = 0;
+    // Set ClientSize and Center the Window to the desktop
+    // and send/post a resize message
+    virtual void              SetMinClientSize( long nWidth, long nHeight ) = 0;
+    virtual void				SetPosSize( long nX, long nY, long nWidth, long nHeight, USHORT nFlags ) = 0;
+    virtual void				GetClientSize( long& rWidth, long& rHeight ) = 0;
+    virtual void				GetWorkArea( Rectangle& rRect ) = 0;
+    virtual SalFrame*			GetParent() const = 0;
     // Note: x will be mirrored at parent if UI mirroring is active
-    SalFrameGeometry        GetGeometry();
-    const SalFrameGeometry& GetUnmirroredGeometry() const { return maGeometry; }
-    void                    SetWindowState( const SalFrameState* pState );
-    BOOL                    GetWindowState( SalFrameState* pState );
-    void                    ShowFullScreen( BOOL bFullScreen );
-                            // Enable/Disable ScreenSaver, SystemAgents, ...
-    void                    StartPresentation( BOOL bStart );
-                            // Show Window over all other Windows
-    void                    SetAlwaysOnTop( BOOL bOnTop );
-
-                            // Window to top and grab focus
-    void                    ToTop( USHORT nFlags );
-
-                            // this function can call with the same
-                            // pointer style
-    void                    SetPointer( PointerStyle ePointerStyle );
-    void                    CaptureMouse( BOOL bMouse );
-    void                    SetPointerPos( long nX, long nY );
-
-                            // Alle noch anstehenden Ausgaben sofort
-                            // durchfuehren
-    void                    Flush();
-                            // Dummy-Syncronen Aufruf zum Client/Display
-                            // machen, damit man sicher sein kann, das
-                            // Ausgaben nicht den Client/das Display
-                            // ueberrennen
-    void                    Sync();
-
-    void                    SetInputContext( SalInputContext* pContext );
-    void                    EndExtTextInput( USHORT nFlags );
-
-    XubString               GetKeyName( USHORT nKeyCode );
-    XubString               GetSymbolKeyName( const XubString& rFontName, USHORT nKeyCode );
-
-                            // returns the input language used for the last key stroke
-                            // may be LANGUAGE_DONTKNOW if not supported by the OS
-    LanguageType            GetInputLanguage();
-
-    SalBitmap*              SnapShot();
+    SalFrameGeometry			GetGeometry();
+    const SalFrameGeometry&		GetUnmirroredGeometry() const { return maGeometry; }
+    virtual void				SetWindowState( const SalFrameState* pState ) = 0;
+    virtual BOOL				GetWindowState( SalFrameState* pState ) = 0;
+    virtual void				ShowFullScreen( BOOL bFullScreen ) = 0;
+    // Enable/Disable ScreenSaver, SystemAgents, ...
+    virtual void				StartPresentation( BOOL bStart ) = 0;
+    // Show Window over all other Windows
+    virtual void				SetAlwaysOnTop( BOOL bOnTop ) = 0;
+
+    // Window to top and grab focus
+    virtual void				ToTop( USHORT nFlags ) = 0;
+
+    // this function can call with the same
+    // pointer style
+    virtual void				SetPointer( PointerStyle ePointerStyle ) = 0;
+    virtual void				CaptureMouse( BOOL bMouse ) = 0;
+    virtual void				SetPointerPos( long nX, long nY ) = 0;
+
+    // flush output buffer
+    virtual void				Flush() = 0;
+    // flush output buffer, wait till outstanding operations are done
+    virtual void				Sync() = 0;
+
+    virtual void				SetInputContext( SalInputContext* pContext ) = 0;
+    virtual void				EndExtTextInput( USHORT nFlags ) = 0;
+
+    virtual String				GetKeyName( USHORT nKeyCode ) = 0;
+    virtual String				GetSymbolKeyName( const XubString& rFontName, USHORT nKeyCode ) = 0;
+
+    // returns the input language used for the last key stroke
+    // may be LANGUAGE_DONTKNOW if not supported by the OS
+    virtual LanguageType		GetInputLanguage() = 0;
 
-    void                    UpdateSettings( AllSettings& rSettings );
+    virtual SalBitmap*			SnapShot() = 0;
 
-    void                    Beep( SoundType eSoundType );
+    virtual void				UpdateSettings( AllSettings& rSettings ) = 0;
 
-    // Liefert die SystemDaten zurueck
-    const SystemEnvData*    GetSystemData() const;
+    virtual void				Beep( SoundType eSoundType ) = 0;
+
+    // returns system data (most prominent: window handle)
+    virtual const SystemEnvData*	GetSystemData() const = 0;
 
-    // Callbacks (indepen in \sv\source\app\svframe.cxx)
-    // for default message handling return 0
-    void                    SetCallback( void* pInst, SALFRAMEPROC pProc );
 
     // get current modifier and button mask
-    ULONG					GetCurrentModButtons();
+    virtual ULONG				GetCurrentModButtons() = 0;
 
     // set new parent window
-    void					SetParent( SalFrame* pNewParent );
+    virtual void				SetParent( SalFrame* pNewParent ) = 0;
     // reparent window to act as a plugin; implementation
     // may choose to use a new system window inetrnally
     // return false to indicate failure
-    bool					SetPluginParent( SystemParentData* pNewParent );
+    virtual bool				SetPluginParent( SystemParentData* pNewParent ) = 0;
+
+    // Callbacks (indepent part in vcl/source/window/winproc.cxx)
+    // for default message handling return 0
+    void						SetCallback( void* pInst, SALFRAMEPROC pProc )
+    { m_pInst = pInst; m_pProc = pProc; }
+
+    // returns the instance set
+    void*                       GetInstance() const { return m_pInst; }
+    
+    // Call the callback set; this sometimes necessary for implementation classes
+    // that should not now more than necessary about the SalFrame implementation
+    // (e.g. input methods, printer update handlers).
+    long						CallCallback( USHORT nEvent, const void* pEvent ) const
+    { return m_pProc ? m_pProc( m_pInst, const_cast<SalFrame*>(this), nEvent, pEvent ) : 0; }
 };
 
 
Index: vcl/inc/salgdi.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/salgdi.hxx,v
retrieving revision 1.20.116.1
retrieving revision 1.24
diff -u -p -u -r1.20.116.1 -r1.24
--- vcl/inc/salgdi.hxx	9 Jan 2004 18:13:40 -0000	1.20.116.1
+++ vcl/inc/salgdi.hxx	17 Jun 2004 12:07:14 -0000	1.24
@@ -72,15 +72,21 @@
 #ifndef _SV_SALGTYPE_HXX
 #include <salgtype.hxx>
 #endif
-#ifndef _SV_SALGDI_H
-#include <salgdi.h>
-#endif
 #ifndef _VOS_THREAD_HXX
 #include <vos/thread.hxx>
 #endif
 #ifndef _SV_OUTDEV_HXX
 #include <outdev.hxx>
 #endif
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
+#endif
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+#ifndef _SV_SALCTRLHANDLE_HXX
+#include <salctrlhandle.hxx>
+#endif
 
 #include <map>
 
@@ -97,6 +103,7 @@ class ImplLayoutArgs;
 class Rectangle;
 struct FontSubsetInfo;
 class OutputDevice;
+class ServerFontLayout;
 
 // ---------------------
 // - SalGraphics-Codes -
@@ -114,72 +121,131 @@ class OutputDevice;
 // - SalGraphics -
 // ---------------
 
-// note: if you add any new methods to class SalGraphics that work with coordinates 
-//       make sure they are virtual and add them to class SalGraphicsLayout where you have
-//       to perform coordinate mirroring if required, (see existing methods as sample)
+// note: if you add any new methods to class SalGraphics using coordinates 
+//       make sure they have a corresponding protected pure virtual method
+//       which has to be implemented by the platform dependent part.
+//       Add a method that performs coordinate mirroring if required, (see
+//       existing methods as sample) and then calls the equivalent pure method.
+
+// note: all positions are in pixel and relative to
+// the top/left-position of the virtual output area
+
 
 class SalGraphics
 {
-    friend class SalFrame;
-    friend class SalVirtualDevice;
-    friend class SalPrinter;
-
-public:                     // public for Sal Implementation
-                            SalGraphics();
-                            virtual ~SalGraphics();
-
-public:                     // public for Sal Implementation
-    SalGraphicsData         maGraphicsData;
-
-    // to be overridden by derived class
-    virtual int             GetLayout() { return 0; }	// base class supports left-to-right only
-    virtual void            SetLayout( int ) {};
+	int						m_nLayout; // 0: mirroring off, 1: mirror x-axis
+public:
+    SalGraphics();
+    virtual ~SalGraphics();
 
-#ifdef _INCL_SAL_SALGDI_IMP
-#include <salgdi.imp>
-#endif
+protected:
+    virtual BOOL		unionClipRegion( long nX, long nY, long nWidth, long nHeight ) = 0;
+    // draw --> LineColor and FillColor and RasterOp and ClipRegion
+    virtual void		drawPixel( long nX, long nY ) = 0;
+    virtual void		drawPixel( long nX, long nY, SalColor nSalColor ) = 0;
+    virtual void		drawLine( long nX1, long nY1, long nX2, long nY2 ) = 0;
+    virtual void		drawRect( long nX, long nY, long nWidth, long nHeight ) = 0;
+    virtual void		drawPolyLine( ULONG nPoints, const SalPoint* pPtAry ) = 0;
+    virtual void		drawPolygon( ULONG nPoints, const SalPoint* pPtAry ) = 0;
+    virtual void		drawPolyPolygon( ULONG nPoly, const ULONG* pPoints, PCONSTSALPOINT* pPtAry ) = 0;
+    virtual sal_Bool	drawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry ) = 0;
+    virtual sal_Bool	drawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry ) = 0;
+    virtual sal_Bool	drawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints, const SalPoint* const* pPtAry, const BYTE* const* pFlgAry ) = 0;
 
+    // CopyArea --> No RasterOp, but ClipRegion
+    virtual void		copyArea( long nDestX, long nDestY, long nSrcX, long nSrcY, long nSrcWidth,
+                                  long nSrcHeight, USHORT nFlags ) = 0;
+    
+    // CopyBits and DrawBitmap --> RasterOp and ClipRegion
+    // CopyBits() --> pSrcGraphics == NULL, then CopyBits on same Graphics
+    virtual void		copyBits( const SalTwoRect* pPosAry, SalGraphics* pSrcGraphics ) = 0;
+    virtual void		drawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap ) = 0;
+    virtual void		drawBitmap( const SalTwoRect* pPosAry,
+                                    const SalBitmap& rSalBitmap,
+                                    SalColor nTransparentColor ) = 0;
+    virtual void		drawBitmap( const SalTwoRect* pPosAry,
+                                    const SalBitmap& rSalBitmap,
+                                    const SalBitmap& rTransparentBitmap ) = 0;
+    virtual void		drawMask( const SalTwoRect* pPosAry,
+                                  const SalBitmap& rSalBitmap,
+                                  SalColor nMaskColor ) = 0;
+    
+    virtual SalBitmap*	getBitmap( long nX, long nY, long nWidth, long nHeight ) = 0;
+    virtual SalColor	getPixel( long nX, long nY ) = 0;
+
+    // invert --> ClipRegion (only Windows or VirDevs)
+    virtual void		invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags) = 0;
+    virtual void		invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags ) = 0;
+
+    virtual BOOL		drawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize ) = 0;
+
+    // native widget rendering methods that require mirroring
+    virtual BOOL        hitTestNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                              const Point& aPos, SalControlHandle& rControlHandle, BOOL& rIsInside );
+    virtual BOOL        drawNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                           ControlState nState, const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+                                           rtl::OUString aCaption );
+    virtual BOOL        drawNativeControlText( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                               ControlState nState, const ImplControlValue& aValue,
+                                               SalControlHandle& rControlHandle, rtl::OUString aCaption );
+    virtual BOOL        getNativeControlRegion( ControlType nType, ControlPart nPart, const Region& rControlRegion, ControlState nState,
+                                                const ImplControlValue& aValue, SalControlHandle& rControlHandle, rtl::OUString aCaption,
+                                                Region &rNativeBoundingRegion, Region &rNativeContentRegion );
 public:
+    // public SalGraphics methods, the interface to the independent vcl part
 
-    // this functions must be quick, because this data is query for all
-    // GetGraphics()-Instances
-    void                    GetResolution( long& rDPIX, long& rDPIY );
-    void                    GetScreenFontResolution( long& rDPIX, long& rDPIY );
-    USHORT                  GetBitCount();
-    long                    GetGraphicsWidth();
-
-    void                    ResetClipRegion();
-    void                    BeginSetClipRegion( ULONG nCount );
-    virtual BOOL            UnionClipRegion( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev );
-    void                    EndSetClipRegion();
-
-    void                    SetLineColor();
-    void                    SetLineColor( SalColor nSalColor );
-    void                    SetFillColor();
-
-    void                    SetFillColor( SalColor nSalColor );
-
-    void                    SetXORMode( BOOL bSet );
-
-    void                    SetROPLineColor( SalROPColor nROPColor );
-    void                    SetROPFillColor( SalROPColor nROPColor );
-
-    // all positions are in pixel and relative to
-    // the top/left-position of the output area
-    void                    SetTextColor( SalColor nSalColor );
-    USHORT                  SetFont( ImplFontSelectData*, int nFallbackLevel );
-    void                    GetFontMetric( ImplFontMetricData* );
-                            // return only PairCount when (pKernPairs == NULL)
-    ULONG                   GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs );
-    ULONG                   GetFontCodeRanges( sal_uInt32* pCodePairs ) const;
+    // get device resolution
+    virtual void			GetResolution( sal_Int32& rDPIX, sal_Int32& rDPIY ) = 0;
+    // get resolution for fonts (an implementations specific adjustment,
+    // ideally would be the same as the Resolution)
+    virtual void			GetScreenFontResolution( sal_Int32& rDPIX, sal_Int32& rDPIY ) = 0;
+    // get the depth of the device
+    virtual USHORT			GetBitCount() = 0;
+    // get the width of the device
+    virtual long			GetGraphicsWidth() = 0;
+
+    // set the clip region to empty
+    virtual void			ResetClipRegion() = 0;
+    // begin setting the clip region, add rectangles to the
+    // region with the UnionClipRegion call
+    virtual void			BeginSetClipRegion( ULONG nCount ) = 0;
+    // all rectangles were added and the clip region should be set now
+    virtual void			EndSetClipRegion() = 0;
+
+    // set the line color to transparent (= don't draw lines)
+    virtual void			SetLineColor() = 0;
+    // set the line color to a specific color
+    virtual void			SetLineColor( SalColor nSalColor ) = 0;
+    // set the fill color to transparent (= don't fill)
+    virtual void			SetFillColor() = 0;
+    // set the fill color to a specific color, shapes will be
+    // filled accordingly
+    virtual void          	SetFillColor( SalColor nSalColor ) = 0;
+    // enable/disable XOR drawing
+    virtual void			SetXORMode( BOOL bSet ) = 0;
+    // set line color for raster operations
+    virtual void			SetROPLineColor( SalROPColor nROPColor ) = 0;
+    // set fill color for raster operations
+    virtual void			SetROPFillColor( SalROPColor nROPColor ) = 0;
+    // set the text color to a specific color
+    virtual void			SetTextColor( SalColor nSalColor ) = 0;
+    // set the font
+    virtual USHORT         SetFont( ImplFontSelectData*, int nFallbackLevel ) = 0;
+    // get the current font's etrics
+    virtual void			GetFontMetric( ImplFontMetricData* ) = 0;
+    // get kernign pairs of the current font
+    // return only PairCount if (pKernPairs == NULL)
+    virtual ULONG			GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs ) = 0;
+    // get the repertoire of the current font; the code pairs returned
+    // contain unicode ranges. if pCodePairs is NULL return only the
+    // number of pairs which would be filled
+    virtual ULONG			GetFontCodeRanges( sal_uInt32* pCodePairs ) const = 0;
     // graphics must fill supplied font list
-    void                    GetDevFontList( ImplDevFontList* );
+    virtual void			GetDevFontList( ImplDevFontList* ) = 0;
     // graphics should call ImplAddDevFontSubstitute on supplied
     // OutputDevice for all its device specific preferred font substitutions
-    void					GetDevFontSubstList( OutputDevice* );
-    ImplFontData*           AddTempDevFont( const String& rFileURL, const String& rFontName );
-    static void             RemovingFont( ImplFontData* );
-
+    virtual void			GetDevFontSubstList( OutputDevice* ) = 0;
+    virtual ImplFontData*	AddTempDevFont( const String& rFileURL, const String& rFontName ) = 0;
     // CreateFontSubset: a method to get a subset of glyhps of a font
     // inside a new valid font file
     // returns TRUE if creation of subset was successfull
@@ -192,14 +258,14 @@ public:
     //             rInfo: additional outgoing information
     // implementation note: encoding 0 with glyph id 0 should be added implicitly
     // as "undefined character"
-    BOOL					CreateFontSubset( const rtl::OUString& rToFile,
+    virtual BOOL			CreateFontSubset( const rtl::OUString& rToFile,
                                               ImplFontData* pFont,
-                                              long* pGlyphIDs,
+                                              sal_Int32* pGlyphIDs,
                                               sal_uInt8* pEncoding,
                                               sal_Int32* pWidths,
                                               int nGlyphs,
                                               FontSubsetInfo& rInfo // out parameter
-                                              );
+                                              ) = 0;
 
     // GetFontEncodingVector: a method to get the encoding map Unicode
 	// to font encoded character; this is only used for type1 fonts and
@@ -208,7 +274,7 @@ public:
     // glyphs with only a name) exist it is set to the corresponding
     // map for non encoded glyphs; the encoding vector contains -1
     // as encoding for these cases
-    const std::map< sal_Unicode, sal_Int32 >* GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** ppNonEncoded );
+    virtual const std::map< sal_Unicode, sal_Int32 >* GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** ppNonEncoded ) = 0;
 
     // GetEmbedFontData: gets the font data for a font marked
     // embeddable by GetDevFontList or NULL in case of error
@@ -219,130 +285,146 @@ public:
     //                      pWidths MUST support at least 256 members;
     //             rInfo: additional outgoing information
     //             pDataLen: out parameter, contains the byte length of the returned buffer
-    const void*                     GetEmbedFontData( ImplFontData* pFont,
-                                                      const sal_Unicode* pUnicodes,
-                                                      sal_Int32* pWidths,
-                                                      FontSubsetInfo& rInfo,
-                                                      long* pDataLen );
+    virtual const void* GetEmbedFontData( ImplFontData* pFont,
+                                          const sal_Unicode* pUnicodes,
+                                          sal_Int32* pWidths,
+                                          FontSubsetInfo& rInfo,
+                                          long* pDataLen ) = 0;
     // frees the font data again
-    void                            FreeEmbedFontData( const void* pData, long nDataLen );
+    virtual void			FreeEmbedFontData( const void* pData, long nDataLen ) = 0;
 
-    virtual BOOL                    GetGlyphBoundRect( long nIndex, Rectangle&, const OutputDevice *pOutDev );
-    virtual BOOL                    GetGlyphOutline( long nIndex, PolyPolygon&, const OutputDevice *pOutDev );
+    virtual BOOL                    GetGlyphBoundRect( long nIndex, Rectangle& ) = 0;
+    virtual BOOL                    GetGlyphOutline( long nIndex, PolyPolygon& ) = 0;
 
-    virtual SalLayout*              GetTextLayout( ImplLayoutArgs&, int nFallbackLevel );
+    virtual SalLayout*              GetTextLayout( ImplLayoutArgs&, int nFallbackLevel ) = 0;
+    virtual void					 DrawServerFontLayout( const ServerFontLayout& ) = 0;
 
-    // draw --> LineColor and FillColor and RasterOp and ClipRegion
-    virtual void                    DrawPixel( long nX, long nY, const OutputDevice *pOutDev );
-    virtual void                    DrawPixel( long nX, long nY, SalColor nSalColor, const OutputDevice *pOutDev );
-    virtual void                    DrawLine( long nX1, long nY1, long nX2, long nY2, const OutputDevice *pOutDev );
-    virtual void                    DrawRect( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev );
-    virtual void                    DrawPolyLine( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev );
-    virtual void                    DrawPolygon( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev );
-    virtual void                    DrawPolyPolygon( ULONG nPoly, const ULONG* pPoints,
-                                             PCONSTSALPOINT* pPtAry, const OutputDevice *pOutDev );
-    virtual sal_Bool                DrawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev );
-    virtual sal_Bool                DrawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev );
-    virtual sal_Bool                DrawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
-                                                   const SalPoint* const* pPtAry, const BYTE* const* pFlgAry, const OutputDevice *pOutDev );
+    // mirroring specifica
+	int						GetLayout() { return m_nLayout; }
+	void					SetLayout( int aLayout ) { m_nLayout = aLayout;}
 
+	void					mirror( long& nX, const OutputDevice *pOutDev );
+	void					mirror( long& nX, long& nWidth, const OutputDevice *pOutDev );
+	BOOL					mirror( sal_uInt32 nPoints, const SalPoint *pPtAry, SalPoint *pPtAry2, const OutputDevice *pOutDev );
+    void                    mirror( Region& rRgn, const OutputDevice *pOutDev );
+
+    // non virtual methods; these do eventual coordinate mirroring and
+    // then delegate to protected virtual methods
+    BOOL					UnionClipRegion( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev );
+    // draw --> LineColor and FillColor and RasterOp and ClipRegion
+    void                    DrawPixel( long nX, long nY, const OutputDevice *pOutDev );
+    void                    DrawPixel( long nX, long nY, SalColor nSalColor, const OutputDevice *pOutDev );
+    void                    DrawLine( long nX1, long nY1, long nX2, long nY2, const OutputDevice *pOutDev );
+    void                    DrawRect( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev );
+    void                    DrawPolyLine( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev );
+    void                    DrawPolygon( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev );
+    void                    DrawPolyPolygon( ULONG nPoly,
+                                             const ULONG* pPoints,
+                                             PCONSTSALPOINT* pPtAry,
+                                             const OutputDevice *pOutDev );
+    sal_Bool                DrawPolyLineBezier( ULONG nPoints,
+                                                const SalPoint* pPtAry,
+                                                const BYTE* pFlgAry,
+                                                const OutputDevice *pOutDev );
+    sal_Bool                DrawPolygonBezier( ULONG nPoints,
+                                               const SalPoint* pPtAry,
+                                               const BYTE* pFlgAry,
+                                               const OutputDevice *pOutDev );
+    sal_Bool                DrawPolyPolygonBezier( ULONG nPoly,
+                                                   const ULONG* pPoints,
+                                                   const SalPoint* const* pPtAry,
+                                                   const BYTE* const* pFlgAry,
+                                                   const OutputDevice *pOutDev );
+    
     // CopyArea --> No RasterOp, but ClipRegion
-    virtual void                    CopyArea( long nDestX, long nDestY,
-                                      long nSrcX, long nSrcY,
-                                      long nSrcWidth, long nSrcHeight,
-                                      USHORT nFlags, const OutputDevice *pOutDev );
+    void                    CopyArea( long nDestX,
+                                      long nDestY,
+                                      long nSrcX,
+                                      long nSrcY,
+                                      long nSrcWidth,
+                                      long nSrcHeight,
+                                      USHORT nFlags,
+                                      const OutputDevice *pOutDev );
 
     // CopyBits and DrawBitmap --> RasterOp and ClipRegion
     // CopyBits() --> pSrcGraphics == NULL, then CopyBits on same Graphics
-    virtual void                    CopyBits( const SalTwoRect* pPosAry,
-                                      SalGraphics* pSrcGraphics, const OutputDevice *pOutDev, const OutputDevice *pSrcOutDev );
-    virtual void                    DrawBitmap( const SalTwoRect* pPosAry,
-                                        const SalBitmap& rSalBitmap, const OutputDevice *pOutDev );
-    virtual void                    DrawBitmap( const SalTwoRect* pPosAry,
+    void                    CopyBits( const SalTwoRect* pPosAry,
+                                      SalGraphics* pSrcGraphics,
+                                      const OutputDevice *pOutDev,
+                                      const OutputDevice *pSrcOutDev );
+    void                    DrawBitmap( const SalTwoRect* pPosAry,
                                         const SalBitmap& rSalBitmap,
-                                        SalColor nTransparentColor, const OutputDevice *pOutDev );
-    virtual void                    DrawBitmap( const SalTwoRect* pPosAry,
+                                        const OutputDevice *pOutDev );
+    void                    DrawBitmap( const SalTwoRect* pPosAry,
                                         const SalBitmap& rSalBitmap,
-                                        const SalBitmap& rTransparentBitmap, const OutputDevice *pOutDev );
+                                        SalColor nTransparentColor,
+                                        const OutputDevice *pOutDev );
+    void                    DrawBitmap( const SalTwoRect* pPosAry,
+                                        const SalBitmap& rSalBitmap,
+                                        const SalBitmap& rTransparentBitmap,
+                                        const OutputDevice *pOutDev );
 
-    virtual void                    DrawMask( const SalTwoRect* pPosAry,
+    void                    DrawMask( const SalTwoRect* pPosAry,
                                       const SalBitmap& rSalBitmap,
-                                      SalColor nMaskColor, const OutputDevice *pOutDev );
+                                      SalColor nMaskColor,
+                                      const OutputDevice *pOutDev );
 
-    virtual SalBitmap*              GetBitmap( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev );
-    virtual SalColor                GetPixel( long nX, long nY, const OutputDevice *pOutDev );
+    SalBitmap*              GetBitmap( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev );
+    SalColor                GetPixel( long nX, long nY, const OutputDevice *pOutDev );
 
     // invert --> ClipRegion (only Windows)
-    virtual void                    Invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags, const OutputDevice *pOutDev );
-    virtual void                    Invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags, const OutputDevice *pOutDev );
-
-    virtual BOOL                    DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice *pOutDev );
-};
-
-
-// ---------------------
-// - SalGraphicsLayout -
-// ---------------------
-
-// extend SalGraphics for RTL
-
-class SalGraphicsLayout : public SalGraphics
-{
-	friend class SalFrame;
-	friend class SalVirtualDevice;
-	friend class SalPrinter;
-
-private:
-	int                             mnLayout;
-
-public:
-							SalGraphicsLayout();
-							~SalGraphicsLayout();
-
-	int                     GetLayout() { return mnLayout; }
-	void					SetLayout( int aLayout)	{ mnLayout = aLayout;}
-
-	void					mirror( long& nX, const OutputDevice *pOutDev );
-	void					mirror( long& nX, long& nWidth, const OutputDevice *pOutDev );
-	BOOL					mirror( sal_uInt32 nPoints, const SalPoint *pPtAry, SalPoint *pPtAry2, const OutputDevice *pOutDev );
-
-	// overwrite those SalGraphics methods that require mirroring
-    // note: text methods will not be mirrored here, this is handled in outdev3.cxx
-	BOOL					UnionClipRegion( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev );
-	void					DrawPixel( long nX, long nY, const OutputDevice *pOutDev );
-	void					DrawPixel( long nX, long nY, SalColor nSalColor, const OutputDevice *pOutDev );
-	void					DrawLine( long nX1, long nY1, long nX2, long nY2, const OutputDevice *pOutDev );
-	void					DrawRect( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev );
-	void					DrawPolyLine( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev );
-	void					DrawPolygon( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev );
-	void					DrawPolyPolygon( ULONG nPoly, const ULONG* pPoints,
-											 PCONSTSALPOINT* pPtAry, const OutputDevice *pOutDev );
-    sal_Bool                DrawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev );
-    sal_Bool                DrawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev );
-    sal_Bool                DrawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
-                                                   const SalPoint* const* pPtAry, const BYTE* const* pFlgAry, const OutputDevice *pOutDev );
-	void					CopyArea( long nDestX, long nDestY,
-									  long nSrcX, long nSrcY,
-									  long nSrcWidth, long nSrcHeight,
-									  USHORT nFlags, const OutputDevice *pOutDev );
-	void					CopyBits( const SalTwoRect* pPosAry,
-									  SalGraphics* pSrcGraphics, const OutputDevice *pOutDev, const OutputDevice *pSrcOutDev );
-	void					DrawBitmap( const SalTwoRect* pPosAry,
-										const SalBitmap& rSalBitmap, const OutputDevice *pOutDev );
-	void					DrawBitmap( const SalTwoRect* pPosAry,
-										const SalBitmap& rSalBitmap,
-										SalColor nTransparentColor, const OutputDevice *pOutDev );
-	void					DrawBitmap( const SalTwoRect* pPosAry,
-										const SalBitmap& rSalBitmap,
-										const SalBitmap& rTransparentBitmap, const OutputDevice *pOutDev );
-	void					DrawMask( const SalTwoRect* pPosAry,
-									  const SalBitmap& rSalBitmap,
-									  SalColor nMaskColor, const OutputDevice *pOutDev );
-	SalBitmap*				GetBitmap( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev );
-	SalColor				GetPixel( long nX, long nY, const OutputDevice *pOutDev );
-	void					Invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags, const OutputDevice *pOutDev );
-	void					Invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags, const OutputDevice *pOutDev );
-	BOOL					DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice *pOutDev );
+    void                    Invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags, const OutputDevice *pOutDev );
+    void                    Invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags, const OutputDevice *pOutDev );
+    
+    BOOL                    DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice *pOutDev );
+
+    //-------------------------------------
+    //  Native Widget Rendering functions
+    //-------------------------------------
+
+    // Query the platform layer for control support
+    virtual BOOL IsNativeControlSupported( ControlType nType, ControlPart nPart );
+
+    // Query the native control to determine if it was acted upon
+    BOOL HitTestNativeControl( ControlType nType,
+									  ControlPart nPart,
+									  const Region& rControlRegion,
+									  const Point& aPos,
+									  SalControlHandle& rControlHandle,
+                                      BOOL& rIsInside,
+                                      const OutputDevice *pOutDev );
+
+    // Request rendering of a particular control and/or part
+    BOOL DrawNativeControl( ControlType nType,
+									ControlPart nPart,
+									const Region& rControlRegion,
+									ControlState nState,
+									const ImplControlValue& aValue,
+									SalControlHandle& rControlHandle,
+									rtl::OUString aCaption,
+                                    const OutputDevice *pOutDev );
+
+    // Request rendering of a caption string for a control
+    BOOL DrawNativeControlText( ControlType nType,
+										ControlPart nPart,
+										const Region& rControlRegion,
+										ControlState nState,
+										const ImplControlValue& aValue,
+										SalControlHandle& rControlHandle,
+										rtl::OUString aCaption,
+                                        const OutputDevice *pOutDev );
+
+    // Query the native control's actual drawing region (including adornment)
+    BOOL GetNativeControlRegion( ControlType nType,
+										 ControlPart nPart,
+										 const Region& rControlRegion,
+										 ControlState nState,
+										 const ImplControlValue& aValue,
+										 SalControlHandle& rControlHandle,
+										 rtl::OUString aCaption,
+										 Region &rNativeBoundingRegion,
+										 Region &rNativeContentRegion,
+                                         const OutputDevice *pOutDev );
 };
 
 #endif // _SV_SALGDI_HXX
Index: vcl/inc/salimestatus.hxx
===================================================================
RCS file: vcl/inc/salimestatus.hxx
diff -N vcl/inc/salimestatus.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/inc/salimestatus.hxx	18 Nov 2003 14:29:06 -0000	1.2
@@ -0,0 +1,77 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALIMESTATUS_HXX
+#define _SV_SALIMESTATUS_HXX
+
+class SalI18NImeStatus
+{
+public:
+    SalI18NImeStatus() {}
+    virtual ~SalI18NImeStatus();
+    
+    // asks whether there is a status window available
+    // to toggle into menubar
+    virtual bool canToggle() = 0;
+    virtual void toggle() = 0;
+};
+
+#endif
Index: vcl/inc/salinst.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/salinst.hxx,v
retrieving revision 1.6.280.1
retrieving revision 1.10
diff -u -p -u -r1.6.280.1 -r1.10
--- vcl/inc/salinst.hxx	2 Mar 2004 10:00:22 -0000	1.6.280.1
+++ vcl/inc/salinst.hxx	18 May 2004 10:49:17 -0000	1.10
@@ -67,15 +67,11 @@
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
-
 #endif // __cplusplus
 
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
-#ifndef _SV_SALINST_H
-#include <salinst.h>
-#endif
 
 #ifdef __cplusplus
 
@@ -86,10 +82,19 @@ struct ImplJobSetup;
 class SalGraphics;
 class SalFrame;
 class SalObject;
+class SalSound;
+class SalOpenGL;
+class SalMenu;
+class SalMenuItem;
 class SalVirtualDevice;
 class SalInfoPrinter;
 class SalPrinter;
+class SalTimer;
 class ImplPrnQueueList;
+class SalI18NImeStatus;
+class SalSystem;
+class SalBitmap;
+struct SalItemParams;
 class SalSession;
 
 namespace vos { class IMutex; }
@@ -100,67 +105,88 @@ namespace vos { class IMutex; }
 
 class SalInstance
 {
-    friend SalInstance* CreateSalInstance();
-    friend void DestroySalInstance( SalInstance* );
-
+public:
+    typedef bool(*Callback)(void*,void*,int);
 private:
-                            SalInstance();
-                            ~SalInstance();
-
-public:                     // public for Sal Implementation
-    SalInstanceData         maInstData;
-
-#ifdef _INCL_SAL_SALINST_IMP
-#include <salinst.imp>
-#endif
-
+    void*						m_pEventInst;
+    void*						m_pErrorInst;
+    Callback					m_pEventCallback;
+    Callback					m_pErrorCallback;
+    
 public:
-                            // Frame
-                            // DisplayName for Unix ???
-    SalFrame*               CreateChildFrame( SystemParentData* pParent, ULONG nStyle );
-    SalFrame*               CreateFrame( SalFrame* pParent, ULONG nStyle );
-    void                    DestroyFrame( SalFrame* pFrame );
-
-                            // Object (System Child Window)
-    SalObject*              CreateObject( SalFrame* pParent );
-    void                    DestroyObject( SalObject* pObject );
-
-                            // VirtualDevice
-                            // nDX and nDY in Pixeln
-                            // nBitCount: 0 == Default / 1 == Mono
-    SalVirtualDevice*       CreateVirtualDevice( SalGraphics* pGraphics,
-                                                 long nDX, long nDY,
-                                                 USHORT nBitCount );
-    void                    DestroyVirtualDevice( SalVirtualDevice* pDevice );
-
-                            // Printer
-                            // pSetupData->mpDriverData can be 0
-                            // pSetupData must be updatet with the current
-                            // JobSetup
-    SalInfoPrinter*         CreateInfoPrinter( SalPrinterQueueInfo* pQueueInfo,
-                                               ImplJobSetup* pSetupData );
-    void                    DestroyInfoPrinter( SalInfoPrinter* pPrinter );
-    SalPrinter*             CreatePrinter( SalInfoPrinter* pInfoPrinter );
-    void                    DestroyPrinter( SalPrinter* pPrinter );
-
-    void                    GetPrinterQueueInfo( ImplPrnQueueList* pList );
-    void                    GetPrinterQueueState( SalPrinterQueueInfo* pInfo );
-    void                    DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo );
-    XubString               GetDefaultPrinter();
+    SalInstance() :
+            m_pEventInst( NULL ),
+            m_pErrorInst( NULL ),
+            m_pEventCallback( NULL ),
+            m_pErrorCallback( NULL )
+    {}
+    virtual ~SalInstance();
+
+    // Frame
+    // DisplayName for Unix ???
+    virtual SalFrame*      	CreateChildFrame( SystemParentData* pParent, ULONG nStyle ) = 0;
+    virtual SalFrame*      	CreateFrame( SalFrame* pParent, ULONG nStyle ) = 0;
+    virtual void				DestroyFrame( SalFrame* pFrame ) = 0;
+
+    // Object (System Child Window)
+    virtual SalObject*			CreateObject( SalFrame* pParent ) = 0;
+    virtual void				DestroyObject( SalObject* pObject ) = 0;
+
+    // VirtualDevice
+    // nDX and nDY in Pixel
+    // nBitCount: 0 == Default(=as window) / 1 == Mono
+    virtual SalVirtualDevice*	CreateVirtualDevice( SalGraphics* pGraphics,
+                                                     long nDX, long nDY,
+                                                     USHORT nBitCount ) = 0;
+    virtual void				DestroyVirtualDevice( SalVirtualDevice* pDevice ) = 0;
+
+    // Printer
+    // pSetupData->mpDriverData can be 0
+    // pSetupData must be updatet with the current
+    // JobSetup
+    virtual SalInfoPrinter*	CreateInfoPrinter( SalPrinterQueueInfo* pQueueInfo,
+                                               ImplJobSetup* pSetupData ) = 0;
+    virtual void				DestroyInfoPrinter( SalInfoPrinter* pPrinter ) = 0;
+    virtual SalPrinter*		CreatePrinter( SalInfoPrinter* pInfoPrinter ) = 0;
+    virtual void				DestroyPrinter( SalPrinter* pPrinter ) = 0;
+
+    virtual void				GetPrinterQueueInfo( ImplPrnQueueList* pList ) = 0;
+    virtual void				GetPrinterQueueState( SalPrinterQueueInfo* pInfo ) = 0;
+    virtual void				DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo ) = 0;
+    virtual String             GetDefaultPrinter() = 0;
+
+    // SalSound
+    virtual SalSound*			CreateSalSound() = 0;
+    // SalTimer
+    virtual SalTimer*			CreateSalTimer() = 0;
+    // SalOpenGL
+    virtual SalOpenGL*			CreateSalOpenGL( SalGraphics* pGraphics ) = 0;
+    // SalI18NImeStatus
+    virtual SalI18NImeStatus*	CreateI18NImeStatus() = 0;
+    // SalSystem
+    virtual SalSystem*			CreateSalSystem() = 0;
+    // SalBitmap
+    virtual SalBitmap*			CreateSalBitmap() = 0;
+
+    // YieldMutex
+    virtual vos::IMutex*		GetYieldMutex() = 0;
+    virtual ULONG				ReleaseYieldMutex() = 0;
+    virtual void				AcquireYieldMutex( ULONG nCount ) = 0;
+
+	// wait next event and dispatch
+    // must returned by UserEvent (SalFrame::PostEvent)
+    // and timer
+    virtual void				Yield( BOOL bWait ) = 0;
+    virtual bool				AnyInput( USHORT nType ) = 0;
+
+                            // Menues
+    virtual SalMenu*        CreateMenu( BOOL bMenuBar ) = 0;
+    virtual void            DestroyMenu( SalMenu* pMenu) = 0;
+    virtual SalMenuItem*    CreateMenuItem( const SalItemParams* pItemData ) = 0;
+    virtual void            DestroyMenuItem( SalMenuItem* pItem ) = 0;
 
     // may return NULL to disable session management
-    SalSession*				CreateSalSession();
-
-                            // YieldMutex
-    vos::IMutex*            GetYieldMutex();
-    ULONG                   ReleaseYieldMutex();
-    void                    AcquireYieldMutex( ULONG nCount );
-
-                            // wait next event and dispatch
-                            // must returned by UserEvent (SalFrame::PostEvent)
-                            // and timer
-    void                    Yield( BOOL bWait );
-    static BOOL             AnyInput( USHORT nType );
+    virtual SalSession*		CreateSalSession() = 0;
 
     // methods for XDisplayConnection
 
@@ -168,11 +194,21 @@ public:
     //    void* pInst:          pInstance form the SetCallback call
     //    void* pEvent:         address of the system specific event structure
     //    int   nBytes:         length of the system specific event structure
-    void                    SetEventCallback( void* pInstance, bool(*pCallback)(void*,void*,int));
-    void                    SetErrorEventCallback( void* pInstance, bool(*pCallback)(void*,void*,int));
+    void				SetEventCallback( void* pInstance, Callback pCallback )
+    { m_pEventInst = pInstance; m_pEventCallback = pCallback; }
+    Callback GetEventCallback() const 
+    { return m_pEventCallback; }
+    bool				CallEventCallback( void* pEvent, int nBytes )
+    { return m_pEventCallback ? m_pEventCallback( m_pEventInst, pEvent, nBytes ) : false; }
+    void				SetErrorEventCallback( void* pInstance, Callback pCallback )
+    { m_pErrorInst = pInstance; m_pErrorCallback = pCallback; }
+    Callback			GetErrorEventCallback() const
+    { return m_pErrorCallback; }
+    bool				CallErrorCallback( void* pEvent, int nBytes )
+    { return m_pErrorCallback ? m_pErrorCallback( m_pErrorInst, pEvent, nBytes ) : false; }
 
     enum ConnectionIdentifierType { AsciiCString, Blob };
-    void*                   GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes );
+    virtual void*				GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes ) = 0;
 };
 
 // called from SVMain
@@ -185,6 +221,8 @@ void DestroySalInstance( SalInstance* pI
 
 void SalAbort( const XubString& rErrorText );
 
+const ::rtl::OUString& SalGetDesktopEnvironment();
+
 #endif // __cplusplus
 
 // -----------
@@ -193,7 +231,6 @@ void SalAbort( const XubString& rErrorTe
 
 void InitSalData();                         // called from Application-Ctor
 void DeInitSalData();                       // called from Application-Dtor
-void SetFilterCallback( void* pCallback, void* pInst );
 
 void InitSalMain();
 void DeInitSalMain();
Index: vcl/inc/sallayout.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/sallayout.hxx,v
retrieving revision 1.31.68.1
retrieving revision 1.36
diff -u -p -u -r1.31.68.1 -r1.36
--- vcl/inc/sallayout.hxx	9 Jan 2004 18:13:41 -0000	1.31.68.1
+++ vcl/inc/sallayout.hxx	17 Jun 2004 12:07:38 -0000	1.36
@@ -63,10 +63,10 @@
 #define _SV_SALLAYOUT_HXX
 
 #ifndef _SV_GEN_HXX
-#include <gen.hxx>
-#endif // _SV_GEN_HXX
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#include <tools/gen.hxx>
+#endif
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 
 #ifndef _TOOLS_LANG_HXX
@@ -76,11 +76,6 @@ typedef unsigned short LanguageType;
 #include <vector>
 #include <list>
 
-#ifdef REMOTE_APPSERVER
-// TODO: better solution: derive ImpServerGraphics from SalGraphics
-#define SalGraphics ImplServerGraphics
-#endif
-
 class SalGraphics;
 struct ImplFontData;
 
@@ -113,7 +108,7 @@ private:
     std::vector<int>    maRuns;
 
 public:
-            ImplLayoutRuns()    { mnRunIndex = 0; }
+            ImplLayoutRuns() { mnRunIndex = 0; maRuns.reserve(8); }
 
     void    Clear()             { maRuns.clear(); }
     bool    AddPos( int nCharPos, bool bRTL );
@@ -140,7 +135,7 @@ public:
     const xub_Unicode*  mpStr;
 
     // positioning related inputs
-    const long*         mpDXArray;          // in pixel units
+    const sal_Int32*         mpDXArray;          // in pixel units
     long                mnLayoutWidth;      // in pixel units
     int                 mnOrientation;      // in 0-3600 system
 
@@ -153,7 +148,7 @@ public:
                     int nMinCharPos, int nEndCharPos, int nFlags );
 
     void        SetLayoutWidth( long nWidth )       { mnLayoutWidth = nWidth; }
-    void        SetDXArray( const long* pDXArray )  { mpDXArray = pDXArray; }
+    void        SetDXArray( const sal_Int32* pDXArray )  { mpDXArray = pDXArray; }
     void        SetOrientation( int nOrientation )  { mnOrientation = nOrientation; }
 
     void        ResetPos()
@@ -220,13 +215,13 @@ public:
 
     // methods using string indexing
     virtual int     GetTextBreak( long nMaxWidth, long nCharExtra=0, int nFactor=1 ) const = 0;
-    virtual long    FillDXArray( long* pDXArray ) const = 0;
+    virtual long    FillDXArray( sal_Int32* pDXArray ) const = 0;
     virtual long    GetTextWidth() const { return FillDXArray( NULL ); }
-    virtual void    GetCaretPositions( int nArraySize, long* pCaretXArray ) const = 0;
+    virtual void    GetCaretPositions( int nArraySize, sal_Int32* pCaretXArray ) const = 0;
 
     // methods using glyph indexing
-    virtual int     GetNextGlyphs( int nLen, long* pGlyphIdxAry, Point& rPos, int&,
-                        long* pGlyphAdvAry = NULL, int* pCharPosAry = NULL ) const = 0;
+    virtual int     GetNextGlyphs( int nLen, sal_Int32* pGlyphIdxAry, Point& rPos, int&,
+                        sal_Int32* pGlyphAdvAry = NULL, int* pCharPosAry = NULL ) const = 0;
     virtual bool    GetOutline( SalGraphics&, PolyPolyVector& ) const;
     virtual bool    GetBoundRect( SalGraphics&, Rectangle& ) const;
 
@@ -280,10 +275,10 @@ class MultiSalLayout : public SalLayout
 public:
     virtual void    DrawText( SalGraphics& ) const;
     virtual int     GetTextBreak( long nMaxWidth, long nCharExtra, int nFactor ) const;
-    virtual long    FillDXArray( long* pDXArray ) const;
-    virtual void    GetCaretPositions( int nArraySize, long* pCaretXArray ) const;
-    virtual int     GetNextGlyphs( int nLen, long* pGlyphIdxAry, Point& rPos,
-                        int&, long* pGlyphAdvAry, int* pCharPosAry ) const;
+    virtual long    FillDXArray( sal_Int32* pDXArray ) const;
+    virtual void    GetCaretPositions( int nArraySize, sal_Int32* pCaretXArray ) const;
+    virtual int     GetNextGlyphs( int nLen, sal_Int32* pGlyphIdxAry, Point& rPos,
+                        int&, sal_Int32* pGlyphAdvAry, int* pCharPosAry ) const;
     virtual bool    GetOutline( SalGraphics&, PolyPolyVector& ) const;
     virtual bool    GetBoundRect( SalGraphics&, Rectangle& ) const;
 
@@ -364,13 +359,13 @@ public:
 
     // used by upper layers
     virtual long    GetTextWidth() const;
-    virtual long    FillDXArray( long* pDXArray ) const;
+    virtual long    FillDXArray( sal_Int32* pDXArray ) const;
     virtual int     GetTextBreak( long nMaxWidth, long nCharExtra, int nFactor ) const;
-    virtual void    GetCaretPositions( int nArraySize, long* pCaretXArray ) const;
+    virtual void    GetCaretPositions( int nArraySize, sal_Int32* pCaretXArray ) const;
 
     // used by display layers
-    virtual int     GetNextGlyphs( int nLen, long* pGlyphIdxAry, Point& rPos, int&,
-                        long* pGlyphAdvAry = NULL, int* pCharPosAry = NULL ) const;
+    virtual int     GetNextGlyphs( int nLen, sal_Int32* pGlyphIdxAry, Point& rPos, int&,
+                        sal_Int32* pGlyphAdvAry = NULL, int* pCharPosAry = NULL ) const;
 
 protected:
                     GenericSalLayout();
@@ -381,7 +376,7 @@ protected:
     virtual void    DropGlyph( int nStart );
     virtual void    Simplify( bool bIsBase );
 
-    bool            GetCharWidths( long* pCharWidths ) const;
+    bool            GetCharWidths( sal_Int32* pCharWidths ) const;
 
 private:
     GlyphItem*      mpGlyphItems;   // TODO: change to GlyphList
Index: vcl/inc/salmenu.hxx
===================================================================
RCS file: vcl/inc/salmenu.hxx
diff -N vcl/inc/salmenu.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/inc/salmenu.hxx	7 Jan 2004 09:17:01 -0000	1.4
@@ -0,0 +1,122 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALMENU_HXX
+#define _SV_SALMENU_HXX
+
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+#ifndef _SV_MENU_HXX
+#include <menu.hxx>
+#endif
+#ifndef _SV_KEYCODE_HXX
+#include <keycod.hxx>
+#endif
+#ifndef _SV_IMAGE_HXX
+#include <image.hxx>
+#endif
+
+struct SystemMenuData;
+class SalFrame;
+
+struct SalItemParams
+{
+    USHORT          nId;					// item Id
+    MenuItemType    eType;					// MenuItem-Type
+    MenuItemBits    nBits;					// MenuItem-Bits
+    Menu*           pMenu;				    // Pointer to Menu
+    XubString       aText;					// Menu-Text
+    Image           aImage;					// Image
+};
+
+
+class SalMenuItem
+{
+public:
+    SalMenuItem() {}
+    virtual ~SalMenuItem();
+};
+
+class SalMenu
+{
+public:
+    SalMenu() {}
+    virtual ~SalMenu();
+
+    virtual BOOL VisibleMenuBar() = 0;  // must return TRUE to actually DISPLAY native menu bars
+                            // otherwise only menu messages are processed (eg, OLE on Windows)
+
+    virtual void InsertItem( SalMenuItem* pSalMenuItem, unsigned nPos ) = 0;
+    virtual void RemoveItem( unsigned nPos ) = 0;
+    virtual void SetSubMenu( SalMenuItem* pSalMenuItem, SalMenu* pSubMenu, unsigned nPos ) = 0;
+    virtual void SetFrame( const SalFrame* pFrame ) = 0;
+    virtual void CheckItem( unsigned nPos, BOOL bCheck ) = 0;
+    virtual void EnableItem( unsigned nPos, BOOL bEnable ) = 0;
+    virtual void SetItemText( unsigned nPos, SalMenuItem* pSalMenuItem, const XubString& rText )= 0;
+    virtual void SetItemImage( unsigned nPos, SalMenuItem* pSalMenuItem, const Image& rImage ) = 0;
+    virtual void SetAccelerator( unsigned nPos, SalMenuItem* pSalMenuItem, const KeyCode& rKeyCode, const XubString& rKeyName ) = 0;
+    virtual void GetSystemMenuData( SystemMenuData* pData ) = 0;
+};
+
+
+#endif // _SV_SALMENU_HXX
+
Index: vcl/inc/salnativewidgets.hxx
===================================================================
RCS file: vcl/inc/salnativewidgets.hxx
diff -N vcl/inc/salnativewidgets.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/inc/salnativewidgets.hxx	10 May 2004 15:42:51 -0000	1.2
@@ -0,0 +1,367 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_NATIVEWIDGETS_HXX
+#define _SV_NATIVEWIDGETS_HXX
+
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
+#endif
+
+/* Control Types:
+ *
+ *   Specify the overall, whole control
+ *   type (as opposed to parts of the
+ *   control if it were composite).
+ */
+
+typedef sal_uInt32		ControlType;
+
+// Normal PushButton/Command Button
+#define CTRL_PUSHBUTTON			1
+
+// Normal single radio button
+#define CTRL_RADIOBUTTON			2
+
+// Normal single checkbox
+#define CTRL_CHECKBOX			10
+
+// Combobox, i.e. a ListBox
+// that allows data entry by user
+#define CTRL_COMBOBOX			20
+
+// Control that allows text entry
+#define CTRL_EDITBOX			30
+
+// Control that allows text entry, but without the usual border
+// Has to be handled separately, because this one cannot handle
+// HAS_BACKGROUND_TEXTURE, which is drawn in the edit box'es
+// border window.
+#define CTRL_EDITBOX_NOBORDER	31
+
+// Control that pops up a menu,
+// but does NOT allow data entry
+#define CTRL_LISTBOX			35
+
+// An edit field together with two little 
+// buttons on the side (aka spin field)
+#define CTRL_SPINBOX			40
+
+// Two standalone spin buttons
+// without an edit field
+#define CTRL_SPINBUTTONS		45
+
+// A single tab
+#define CTRL_TAB_ITEM			50
+
+// The border around a tab area,
+// but without the tabs themselves.
+// May have a gap at the top for
+// the active tab
+#define CTRL_TAB_PANE			55
+
+// Background of a Tab Pane
+#define CTRL_TAB_BODY			56
+
+// Normal scrollbar, including
+// all parts like slider, buttons
+#define CTRL_SCROLLBAR			60
+
+// Border around a group of related
+// items, perhaps also displaying
+// a label of identification
+#define CTRL_GROUPBOX			70
+
+// A separator line
+#define CTRL_FIXEDLINE			80
+
+// A rectangular border, like a
+// Tab Pane, but without the
+// possible gap for a tab
+#define CTRL_FIXEDBORDER			90
+
+
+
+/* Control Parts:
+ *
+ *   Uniquely identify a part of a control,
+ *   for example the slider of a scroll bar.
+ */
+
+typedef sal_uInt32		ControlPart;
+
+#define PART_ENTIRE_CONTROL		1
+#define PART_WINDOW             5       // the static listbox window containing the list
+#define PART_BUTTON				100
+#define PART_BUTTON_UP			101
+#define PART_BUTTON_DOWN			102	// Also for ComboBoxes/ListBoxes
+#define PART_BUTTON_LEFT			103
+#define PART_BUTTON_RIGHT		104
+#define PART_ALL_BUTTONS    		105
+#define PART_TRACK_HORZ_LEFT		200
+#define PART_TRACK_VERT_UPPER		201
+#define PART_TRACK_HORZ_RIGHT		202
+#define PART_TRACK_VERT_LOWER		203
+#define PART_THUMB_HORZ			210
+#define PART_THUMB_VERT			211
+
+/** The edit field part of a control, e.g. of the combo box.
+
+    Currently used just for combo boxes and just for GetNativeControlRegion().
+    It is valid only if GetNativeControlRegion() supports PART_BUTTON_DOWN as
+    well.
+*/
+#define PART_SUB_EDIT           300
+
+// For controls that require the entire background
+// to be drawn first, and then other pieces over top.
+// (GTK+ scrollbars for example).  Control region passed
+// in to draw this part is expected to be the entire
+// area of the control.
+// A control may respond to one or both.
+#define PART_DRAW_BACKGROUND_HORZ		1000
+#define PART_DRAW_BACKGROUND_VERT		1001
+
+// GTK+ also draws tabs right->left since there is a 
+// hardcoded 2 pixel overlap between adjacent tabs
+#define PART_TABS_DRAW_RTL			3000
+
+// For themes that do not want to have the focus
+// rectangle part drawn by VCL but take care of the
+// whole inner control part by themselves
+// eg, listboxes or comboboxes or spinbuttons
+#define HAS_BACKGROUND_TEXTURE  4000
+
+// For scrollbars that have 3 buttons (most KDE themes)
+#define HAS_THREE_BUTTONS       5000
+
+/* Control State:
+ *
+ *   Specify how a particular part of the control
+ *   is to be drawn.  Constants are bitwise OR-ed
+ *   together to compose a final drawing state.
+ *   A _disabled_ state is assumed by the drawing
+ *   functions until an ENABLED or HIDDEN is passed
+ *   in the ControlState.
+ */
+
+typedef sal_uInt32		ControlState;
+
+#define CTRL_STATE_ENABLED		0x0001
+#define CTRL_STATE_FOCUSED		0x0002
+#define CTRL_STATE_PRESSED		0x0004
+#define CTRL_STATE_ROLLOVER		0x0008
+#define CTRL_STATE_HIDDEN		0x0010
+#define CTRL_STATE_DEFAULT		0x0020
+#define CTRL_STATE_SELECTED		0x0040
+#define CTRL_CACHING_ALLOWED	0x8000  // set when the control is completely visible (i.e. not clipped)
+
+/* ButtonValue:
+ *
+ *   Identifies the tri-state value options
+ *   that buttons allow
+ */
+
+enum ButtonValue {
+	BUTTONVALUE_DONTKNOW,
+	BUTTONVALUE_ON,
+	BUTTONVALUE_OFF,
+	BUTTONVALUE_MIXED
+};
+
+
+#ifdef __cplusplus
+
+
+/* ScrollbarValue:
+ *
+ *   Value container for scrollbars.
+ */
+class ScrollbarValue
+{
+	public:
+		long			mnMin;
+		long			mnMax;
+		long			mnCur;
+		long			mnVisibleSize;
+		Rectangle		maThumbRect;
+		Rectangle		maButton1Rect;
+		Rectangle		maButton2Rect;
+		ControlState	mnButton1State;
+		ControlState	mnButton2State;
+		ControlState	mnThumbState;
+		ControlState	mnPage1State;
+		ControlState	mnPage2State;
+
+		inline ScrollbarValue()
+				{
+					mnMin = 0; mnMax = 0; mnCur = 0; mnVisibleSize = 0;
+					mnButton1State = 0; mnButton2State = 0;
+					mnThumbState = 0; mnPage1State = 0; mnPage2State = 0;
+				};
+		inline ~ScrollbarValue() {};
+};
+
+/* TabitemValue:
+ *
+ *   Value container for tabitems.
+ */
+
+/* TABITEM constants are OR-ed together */
+#define TABITEM_NOTALIGNED     0x000   // the tabitem is an inner item
+#define TABITEM_LEFTALIGNED    0x001   // the tabitem is aligned with the left  border of the TabControl
+#define TABITEM_RIGHTALIGNED   0x002   // the tabitem is aligned with the right border of the TabControl
+#define TABITEM_FIRST_IN_GROUP 0x004   // the tabitem is the first in group of tabitems
+#define TABITEM_LAST_IN_GROUP  0x008   // the tabitem is the last in group of tabitems
+
+class TabitemValue
+{
+	public:
+        unsigned int    mnAlignment;
+
+		inline TabitemValue()
+				{
+					mnAlignment = 0;
+				};
+		inline ~TabitemValue() {};
+
+        BOOL isLeftAligned()  { return (mnAlignment & TABITEM_LEFTALIGNED) != 0; }
+        BOOL isRightAligned() { return (mnAlignment & TABITEM_RIGHTALIGNED) != 0; }
+        BOOL isBothAligned()  { return isLeftAligned() && isRightAligned(); }
+        BOOL isNotAligned()   { return (mnAlignment & (TABITEM_LEFTALIGNED | TABITEM_RIGHTALIGNED)) == 0; }
+        BOOL isFirst()        { return (mnAlignment & TABITEM_FIRST_IN_GROUP) != 0; }
+        BOOL isLast()         { return (mnAlignment & TABITEM_LAST_IN_GROUP) != 0; }
+};
+
+
+/* SpinbuttonValue:
+ *
+ *   Value container for spinbuttons to paint both buttons at once.
+ *   Note: the other parameters of DrawNativeControl will have no meaning
+ *         all parameters for spinbuttons are carried here
+ */
+class SpinbuttonValue
+{
+	public:
+		Rectangle		maUpperRect;
+		Rectangle		maLowerRect;
+		ControlState	mnUpperState;
+		ControlState	mnLowerState;
+		int			mnUpperPart;
+		int			mnLowerPart;
+
+		inline SpinbuttonValue()
+				{
+					mnUpperState = mnLowerState = 0;
+				};
+		inline ~SpinbuttonValue() {};
+};
+
+/* ImplControlValue:
+ *
+ *   Generic value container for all control parts.
+ */
+
+class ImplControlValue
+{
+	friend class SalFrame;
+	
+	private:
+		ButtonValue	mTristate;	// Tristate value: on, off, mixed
+		rtl::OUString	mString;		// string value
+		long			mNumber;		// numeric value
+		void *		mOptionalVal;	// optional control-specific value
+
+	public:
+		inline ImplControlValue( ButtonValue nTristate, rtl::OUString sString, long nNumeric, void * aOptVal ) \
+								{ mTristate = nTristate; mString = sString; mNumber = nNumeric; mOptionalVal = aOptVal; };
+		inline ImplControlValue( ButtonValue nTristate, rtl::OUString sString, long nNumeric ) \
+								{ mTristate = nTristate; mString = sString; mNumber = nNumeric; mOptionalVal = NULL; };
+		inline ImplControlValue( ButtonValue nTristate )	{ mTristate = nTristate; mOptionalVal = NULL; };
+		inline ImplControlValue( rtl::OUString sString )	{ mString = sString; mOptionalVal = NULL; };
+		inline ImplControlValue( long nNumeric )		{ mNumber = nNumeric; mOptionalVal = NULL; };
+		inline ImplControlValue( void * aOptVal ) 		{ mOptionalVal = aOptVal; };
+		inline ImplControlValue() { mTristate = BUTTONVALUE_DONTKNOW; mNumber = 0; mOptionalVal = NULL; };
+		inline ~ImplControlValue() { mOptionalVal = NULL; };
+
+		inline ButtonValue		getTristateVal( void ) const { return mTristate; }
+		inline void			setTristateVal( ButtonValue nTristate ) { mTristate = nTristate; }
+
+		inline const rtl::OUString&	getStringVal( void ) const { return mString; }
+		inline void			setStringVal( rtl::OUString sString ) { mString = sString; }
+
+		inline long			getNumericVal( void ) const { return mNumber; }
+		inline void			setNumericVal( long nNumeric ) { mNumber = nNumeric; }
+
+		inline void *			getOptionalVal( void ) const { return mOptionalVal; }
+		inline void			setOptionalVal( void * aOptVal ) { mOptionalVal = aOptVal; }
+};
+
+#endif	/* __cplusplus */
+
+#endif
+
+
+
+
+
+
+
Index: vcl/inc/salobj.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/salobj.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/salobj.hxx	19 Sep 2000 10:23:06 -0000	1.1.1.1
+++ vcl/inc/salobj.hxx	18 Nov 2003 14:29:32 -0000	1.2
@@ -71,9 +71,6 @@
 #ifndef _SV_SALWTYPE_HXX
 #include <salwtype.hxx>
 #endif
-#ifndef _SV_SALOBJ_H
-#include <salobj.h>
-#endif
 
 struct SystemEnvData;
 
@@ -91,37 +88,32 @@ struct SystemEnvData;
 
 class SalObject
 {
-public: 					// public for Sal Implementation
-							SalObject();
-							~SalObject();
-
-public: 					// public for Sal Implementation
-	SalObjectData			maObjectData;
-
-#ifdef _INCL_SAL_SALOBJ_IMP
-#include <salobj.imp>
-#endif
-
+    void*				m_pInst;
+    SALOBJECTPROC		m_pCallback;
 public:
-	void					ResetClipRegion();
-	USHORT					GetClipRegionType();
-	void					BeginSetClipRegion( ULONG nRects );
-	void					UnionClipRegion( long nX, long nY, long nWidth, long nHeight );
-	void					EndSetClipRegion();
-
-	void					SetPosSize( long nX, long nY, long nWidth, long nHeight );
-	void					Show( BOOL bVisible );
-	void					Enable( BOOL nEnable );
-	void					GrabFocus();
-
-	void					SetBackground();
-	void					SetBackground( SalColor nSalColor );
-
-	const SystemEnvData*	GetSystemData() const;
-
-	// Callbacks (indepen in \vcl\source\window\winproc.cxx)
-	// for default message handling return 0
-	void					SetCallback( void* pInst, SALOBJECTPROC pProc );
+    SalObject() : m_pInst( NULL ), m_pCallback( NULL ) {}
+    virtual ~SalObject();
+
+	virtual void					ResetClipRegion() = 0;
+	virtual USHORT					GetClipRegionType() = 0;
+	virtual void					BeginSetClipRegion( ULONG nRects ) = 0;
+	virtual void					UnionClipRegion( long nX, long nY, long nWidth, long nHeight ) = 0;
+	virtual void					EndSetClipRegion() = 0;
+
+	virtual void					SetPosSize( long nX, long nY, long nWidth, long nHeight ) = 0;
+	virtual void					Show( BOOL bVisible ) = 0;
+	virtual void					Enable( BOOL nEnable ) = 0;
+	virtual void					GrabFocus() = 0;
+
+	virtual void					SetBackground() = 0;
+	virtual void					SetBackground( SalColor nSalColor ) = 0;
+
+	virtual const SystemEnvData*	GetSystemData() const = 0;
+
+	void					SetCallback( void* pInst, SALOBJECTPROC pProc )
+    { m_pInst = pInst; m_pCallback = pProc; }
+    long					CallCallback( USHORT nEvent, const void* pEvent )
+    { return m_pCallback ? m_pCallback( m_pInst, this, nEvent, pEvent ) : 0; }
 };
 
 #endif // _SV_SALOBJ_HXX
Index: vcl/inc/salogl.hxx
===================================================================
RCS file: vcl/inc/salogl.hxx
diff -N vcl/inc/salogl.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/inc/salogl.hxx	18 Nov 2003 14:29:40 -0000	1.2
@@ -0,0 +1,109 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALOGL_HXX
+#define _SV_SALOGL_HXX
+
+#define _OPENGL_EXT
+
+#ifndef _GEN_HXX
+#include <tools/gen.hxx>
+#endif
+
+#define _SVUNX_H
+
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+#ifndef _SV_SALOTYPE_HXX
+#include <salotype.hxx>
+#endif
+
+// -----------------
+// - State defines -
+// -----------------
+
+#define OGL_STATE_UNLOADED		(0x00000000)
+#define OGL_STATE_INVALID		(0x00000001)
+#define OGL_STATE_VALID		(0x00000002)
+
+// -------------
+// - SalOpenGL -
+// -------------
+
+class SalGraphics;
+
+class SalOpenGL
+{
+public:					
+    
+    SalOpenGL() {}
+    virtual ~SalOpenGL();
+						
+	virtual bool		IsValid() = 0;
+	virtual void*		GetOGLFnc( const char * ) = 0;
+	virtual void		OGLEntry( SalGraphics* pGraphics ) = 0;
+	virtual void		OGLExit( SalGraphics* pGraphics ) = 0;
+    virtual void		StartScene( SalGraphics* pGraphics ) = 0;
+	virtual void		StopScene() = 0;
+};
+
+#endif
Index: vcl/inc/salprn.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/salprn.hxx,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- vcl/inc/salprn.hxx	20 Nov 2002 12:03:33 -0000	1.4
+++ vcl/inc/salprn.hxx	18 Nov 2003 14:29:49 -0000	1.5
@@ -69,9 +69,6 @@
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
-#ifndef _SV_SALPRN_H
-#include <salprn.h>
-#endif
 #ifndef _SV_PRNTYPES_HXX
 #include <prntypes.hxx>
 #endif
@@ -107,49 +104,39 @@ struct SalPrinterQueueInfo
 
 class SalInfoPrinter
 {
-	friend class SalInstance;
-
 public:
     std::vector< vcl::PaperInfo  >		m_aPaperFormats;	// all printer supported formats
     bool								m_bPapersInit;		// set to true after InitPaperFormats
+    
+    SalInfoPrinter() {}
+    virtual ~SalInfoPrinter();
 
-							SalInfoPrinter();
-							~SalInfoPrinter();
-
-public: 					// public for Sal Implementation
-	SalInfoPrinterData		maPrinterData;
-
-#ifdef _INCL_SAL_SALIPRN_IMP
-#include <saliprn.imp>
-#endif
-
-public:
 	// SalGraphics or NULL, but two Graphics for all SalFrames
 	// must be returned
-	SalGraphics*			GetGraphics();
-	void					ReleaseGraphics( SalGraphics* pGraphics );
+	virtual SalGraphics*			GetGraphics() = 0;
+	virtual void					ReleaseGraphics( SalGraphics* pGraphics ) = 0;
 
-	BOOL					Setup( SalFrame* pFrame, ImplJobSetup* pSetupData );
-							// This function set the driver data and
-							// set the new indepen data in pSetupData
-	BOOL					SetPrinterData( ImplJobSetup* pSetupData );
-							// This function merged the indepen driver data
-							// and set the new indepen data in pSetupData
-							// Only the data must changed, where the bit
-							// in nFlags is set
-	BOOL					SetData( ULONG nFlags, ImplJobSetup* pSetupData );
-
-	void					GetPageInfo( const ImplJobSetup* pSetupData,
-										 long& rOutWidth, long& rOutHeight,
-										 long& rPageOffX, long& rPageOffY,
-										 long& rPageWidth, long& rPageHeight );
-	ULONG					GetCapabilities( const ImplJobSetup* pSetupData, USHORT nType );
-	ULONG					GetPaperBinCount( const ImplJobSetup* pSetupData );
-	XubString				GetPaperBinName( const ImplJobSetup* pSetupData, ULONG nPaperBin );
+	virtual BOOL					Setup( SalFrame* pFrame, ImplJobSetup* pSetupData ) = 0;
+    // This function set the driver data and
+    // set the new indepen data in pSetupData
+	virtual BOOL					SetPrinterData( ImplJobSetup* pSetupData ) = 0;
+    // This function merged the indepen driver data
+    // and set the new indepen data in pSetupData
+    // Only the data must changed, where the bit
+    // in nFlags is set
+	virtual BOOL					SetData( ULONG nFlags, ImplJobSetup* pSetupData ) = 0;
+
+	virtual void					GetPageInfo( const ImplJobSetup* pSetupData,
+                                                 long& rOutWidth, long& rOutHeight,
+                                                 long& rPageOffX, long& rPageOffY,
+                                                 long& rPageWidth, long& rPageHeight ) = 0;
+	virtual ULONG					GetCapabilities( const ImplJobSetup* pSetupData, USHORT nType ) = 0;
+	virtual ULONG					GetPaperBinCount( const ImplJobSetup* pSetupData ) = 0;
+	virtual String					GetPaperBinName( const ImplJobSetup* pSetupData, ULONG nPaperBin ) = 0;
 	// fills m_aPaperFormats and sets m_bPapersInit to true
-    void					InitPaperFormats( const ImplJobSetup* pSetupData );
+    virtual void					InitPaperFormats( const ImplJobSetup* pSetupData ) = 0;
     // returns angle that a landscape page will be turned counterclockwise wrt to portrait
-    int						GetLandscapeAngle( const ImplJobSetup* pSetupData );
+    virtual int					GetLandscapeAngle( const ImplJobSetup* pSetupData ) = 0;
 };
 
 
@@ -159,30 +146,20 @@ public:
 
 class SalPrinter
 {
-	friend class SalInstance;
-
-private:
-							SalPrinter();
-							~SalPrinter();
-
 public: 					// public for Sal Implementation
-	SalPrinterData			maPrinterData;
+    SalPrinter() {}
+    virtual ~SalPrinter();
 
-#ifdef _INCL_SAL_SALPRN_IMP
-#include <salprn.imp>
-#endif
-
-public:
-	BOOL					StartJob( const XubString* pFileName,
-									  const XubString& rJobName,
-									  const XubString& rAppName,
-									  ULONG nCopies, BOOL bCollate,
-									  ImplJobSetup* pSetupData );
-	BOOL					EndJob();
-	BOOL					AbortJob();
-	SalGraphics*			StartPage( ImplJobSetup* pSetupData, BOOL bNewJobData );
-	BOOL					EndPage();
-	ULONG					GetErrorCode();
+	virtual BOOL					StartJob( const XubString* pFileName,
+                                              const XubString& rJobName,
+                                              const XubString& rAppName,
+                                              ULONG nCopies, BOOL bCollate,
+                                              ImplJobSetup* pSetupData ) = 0;
+	virtual BOOL					EndJob() = 0;
+	virtual BOOL					AbortJob() = 0;
+	virtual SalGraphics*			StartPage( ImplJobSetup* pSetupData, BOOL bNewJobData ) = 0;
+	virtual BOOL					EndPage() = 0;
+	virtual ULONG					GetErrorCode() = 0;
 };
 
 #endif // _SV_SALPRN_HXX

Index: vcl/inc/salsound.hxx
===================================================================
RCS file: vcl/inc/salsound.hxx
diff -N vcl/inc/salsound.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/inc/salsound.hxx	18 Nov 2003 14:29:57 -0000	1.2
@@ -0,0 +1,119 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALSOUND_HXX
+#define _SV_SALSOUND_HXX
+
+#ifndef _GEN_HXX
+#include <tools/gen.hxx>
+#endif
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+#ifndef _STRING_HXX
+#include <tools/string.hxx>
+#endif
+#ifndef _SV_SALSTYPE_HXX
+#include <salstype.hxx>
+#endif
+
+class SalSound
+{
+	// for notification
+	void*					m_pInst;
+	SALSOUNDPROC			m_aPROC;
+public:
+    SalSound() : m_pInst( NULL ), m_aPROC( NULL ) {}
+    virtual ~SalSound();
+    
+    // checks whether sound system is ready for input and hence
+    // SalSound can be initialized
+    virtual bool		IsValid() = 0;
+    // initialize with sound file name, returns success and // FIXME: rSoundLen ?
+    virtual bool		Init( const String&	rSoundName,
+                              ULONG&		rSoundLen ) = 0;
+    // play the sound, start at nStartTime (ms), play for nPlayTime (ms),
+	// loop = true/false
+   	virtual void		Play( ULONG nStartTime, ULONG nPlayTime, bool bLoop ) = 0;
+    // stop playing
+	virtual void		Stop() = 0;
+    // pause playing
+	virtual void		Pause() = 0;
+    // continue a paused play
+	virtual void		Continue() = 0;
+    // is looping ?
+    virtual bool		IsLoopMode() const = 0;
+    // is playing ?
+	virtual bool		IsPlaying() const = 0;
+    // is paused ?
+    virtual bool		IsPaused() const = 0;
+
+    // register a callback to be called when state changes
+	void		SetNotifyProc( void* pInst, SALSOUNDPROC pProc )
+    { m_pInst = pInst; m_aPROC = pProc; }
+    void		CallNotifyProc( SoundNotification eNotification, ULONG nError )
+    {
+        if( m_aPROC )
+            m_aPROC( m_pInst, eNotification, nError );
+    }
+};
+
+#endif
Index: vcl/inc/salsys.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/salsys.hxx,v
retrieving revision 1.7
retrieving revision 1.9
diff -u -p -u -r1.7 -r1.9
--- vcl/inc/salsys.hxx	20 Nov 2002 15:45:04 -0000	1.7
+++ vcl/inc/salsys.hxx	7 Jan 2004 09:17:24 -0000	1.9
@@ -65,44 +65,9 @@
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
-#ifndef _LIST_HXX
-#include <tools/list.hxx>
-#endif
-
-#ifndef _SV_SV_H
-#include <sv.h>
-#endif
-
-#ifndef _SV_SYSTEM_HXX
-#include <system.hxx>
-#endif
-
-#include <list>
-
-// -------------------
-// - SalSystem-Types -
-// -------------------
-
-// Must be the same values like in VCLSystemInfo
-#define SALSYSTEM_GETSYSTEMINFO_STACK           ((ULONG)0x00000001)
-#define SALSYSTEM_GETSYSTEMINFO_MODULES         ((ULONG)0x00000002)
-#define SALSYSTEM_GETSYSTEMINFO_SYSTEMVERSION   ((ULONG)0x00000004)
-#define SALSYSTEM_GETSYSTEMINFO_CPUTYPE         ((ULONG)0x00000008)
-#define SALSYSTEM_GETSYSTEMINFO_MEMORYINFO      ((ULONG)0x00000010)
-#define SALSYSTEM_GETSYSTEMINFO_LOCALVOLUMES    ((ULONG)0x00000020)
-#define SALSYSTEM_GETSYSTEMINFO_SYSTEMDIRS      ((ULONG)0x00000040)
-#define SALSYSTEM_GETSYSTEMINFO_MOUSEINFO       ((ULONG)0x00000080)
-#define SALSYSTEM_GETSYSTEMINFO_GRAPHICSSYSTEM  ((ULONG)0x00000100)
-
-// -------------
-// - SalSystem -
-// -------------
 
-String GetSalSummarySystemInfos( ULONG nFlags );
 
-bool GetSalSystemDisplayInfo( System::DisplayInfo& rInfo );
-
-/* Button combinations for ImplShowNativeMessageBox
+/* Button combinations for ShowNativeMessageBox
 */
 const int SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK                 = 0;
 const int SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK_CANCEL          = 1;
@@ -111,7 +76,7 @@ const int SALSYSTEM_SHOWNATIVEMSGBOX_BTN
 const int SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_YES_NO             = 4;
 const int SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_RETRY_CANCEL       = 5;
 
-/* Button identifier for ImplShowNativeMessageBox
+/* Button identifier for ShowNativeMessageBox
 */
 const int SALSYSTEM_SHOWNATIVEMSGBOX_BTN_OK     = 1;
 const int SALSYSTEM_SHOWNATIVEMSGBOX_BTN_CANCEL = 2;
@@ -121,29 +86,57 @@ const int SALSYSTEM_SHOWNATIVEMSGBOX_BTN
 const int SALSYSTEM_SHOWNATIVEMSGBOX_BTN_YES    = 6;
 const int SALSYSTEM_SHOWNATIVEMSGBOX_BTN_NO     = 7;
 
-/*  Shows a native message box with the specified title, message and button
-    combination. 
+
+
+// -------------
+// - SalSystem -
+// -------------
+
+struct DisplayInfo
+{
+    int nWidth, nHeight, nDepth;
+};
+
+
+class SalSystem
+{
+public:
+			SalSystem() {}
+    virtual ~SalSystem();
+    
+    // get info about the display
+    virtual bool GetSalSystemDisplayInfo( DisplayInfo& rInfo ) = 0;
+
+
+	/*  Shows a native message box with the specified title, message and button
+        combination. 
                 
-    @param  rTitle
-            The title to be shown by the dialog box.
+        @param  rTitle
+        The title to be shown by the dialog box.
             
-    @param  rMessage
-            The message to be shown by the dialog box.
+        @param  rMessage
+        The message to be shown by the dialog box.
             
-    @param  nButtonCombination
-            Specify which button combination the message box should display.
-            See button combinations above.
+        @param  nButtonCombination
+        Specify which button combination the message box should display.
+        See button combinations above.
                         
-    @param  nDefaultButton
-            Specifies which button has the focus initially. 
-            See button identifiers above. 
-            The effect of specifying a button that doesn't belong
-            to the specified button combination is undefined.
+        @param  nDefaultButton
+        Specifies which button has the focus initially. 
+        See button identifiers above. 
+        The effect of specifying a button that doesn't belong
+        to the specified button combination is undefined.
                                              
-    @returns the identifier of the button that was pressed by the user.            
-             See button identifier above. If the function fails the
-             return value is 0.
-*/
-int ImplShowNativeMessageBox(const String& rTitle, const String& rMessage, int nButtonCombination, int nDefaultButton);
+        @returns the identifier of the button that was pressed by the user.            
+        See button identifier above. If the function fails the
+        return value is 0.
+    */
+    virtual int ShowNativeMessageBox( const String& rTitle,
+                                      const String& rMessage,
+                                      int nButtonCombination,
+                                      int nDefaultButton) = 0;
+};
+
+SalSystem* ImplGetSalSystem();
 
 #endif // _SV_SALSYS_HXX
Index: vcl/inc/saltimer.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/saltimer.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/saltimer.hxx	19 Sep 2000 10:23:06 -0000	1.1.1.1
+++ vcl/inc/saltimer.hxx	18 Nov 2003 14:30:19 -0000	1.2
@@ -73,15 +73,34 @@
 // - SalTimer -
 // ------------
 
+/*
+ * note: there will be only a single instance of SalTimer
+ * SalTimer originally had only static methods, but
+ * this needed to be virtualized for the sal plugin migration
+ */
+
 class SalTimer
 {
+    SALTIMERPROC		m_pProc;
 public:
-							// AutoRepeat and Restart
-	static void 			Start( ULONG nMS );
-	static void 			Stop();
+    SalTimer() : m_pProc( NULL ) {}
+    virtual ~SalTimer();
+
+    // AutoRepeat and Restart
+	virtual void 			Start( ULONG nMS ) = 0;
+	virtual void 			Stop() = 0;
 
 	// Callbacks (indepen in \sv\source\app\timer.cxx)
-	static void 			SetCallback( SALTIMERPROC pProc );
+	void 			SetCallback( SALTIMERPROC pProc )
+    {
+        m_pProc = pProc; 
+    }
+    
+    void			CallCallback()
+    {
+        if( m_pProc )
+            m_pProc();
+    }
 };
 
 #endif // _SV_SALTIMER_HXX
Index: vcl/inc/salvd.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/salvd.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/salvd.hxx	19 Sep 2000 10:23:06 -0000	1.1.1.1
+++ vcl/inc/salvd.hxx	18 Nov 2003 14:30:29 -0000	1.2
@@ -65,9 +65,6 @@
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
-#ifndef _SV_SALVD_H
-#include <salvd.h>
-#endif
 
 class SalGraphics;
 
@@ -77,27 +74,17 @@ class SalGraphics;
 
 class SalVirtualDevice
 {
-    friend class SalInstance;
-
-private:
-                            SalVirtualDevice();
-                            ~SalVirtualDevice();
-
 public:                     // public for Sal Implementation
-    SalVirDevData           maVirDevData;
-
-#ifdef _INCL_SAL_SALVD_IMP
-#include <salvd.imp>
-#endif
+    SalVirtualDevice() {}
+    virtual ~SalVirtualDevice();
 
-public:
     // SalGraphics or NULL, but two Graphics for all SalVirtualDevices
     // must be returned
-    SalGraphics*            GetGraphics();
-    void                    ReleaseGraphics( SalGraphics* pGraphics );
+    virtual SalGraphics*			GetGraphics() = 0;
+    virtual void					ReleaseGraphics( SalGraphics* pGraphics ) = 0;
 
                             // Set new size, without saving the old contents
-    BOOL                    SetSize( long nNewDX, long nNewDY );
+    virtual BOOL                    SetSize( long nNewDX, long nNewDY ) = 0;
 };
 
 #endif // _SV_SALVD_HXX
Index: vcl/inc/salwtype.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/salwtype.hxx,v
retrieving revision 1.11
retrieving revision 1.12
diff -u -p -u -r1.11 -r1.12
--- vcl/inc/salwtype.hxx	27 Mar 2003 17:57:31 -0000	1.11
+++ vcl/inc/salwtype.hxx	18 Nov 2003 14:56:54 -0000	1.12
@@ -147,7 +147,11 @@ struct ImplFontSelectData;
 #define SALEVENT_CLOSEPOPUPS            ((USHORT)30)
 #define SALEVENT_EXTERNALKEYINPUT       ((USHORT)31)
 #define SALEVENT_EXTERNALKEYUP          ((USHORT)32)
-#define SALEVENT_COUNT                  ((USHORT)32)
+#define SALEVENT_MENUCOMMAND            ((USHORT)33)
+#define SALEVENT_MENUHIGHLIGHT          ((USHORT)34)
+#define SALEVENT_MENUACTIVATE           ((USHORT)35)
+#define SALEVENT_MENUDEACTIVATE         ((USHORT)36)
+#define SALEVENT_COUNT                  ((USHORT)36)
 
 // MOUSELEAVE must send, when the pointer leave the client area and
 // the mouse is not captured
@@ -169,6 +173,13 @@ struct SalKeyEvent
     USHORT          mnCode;         // SV-KeyCode (KEY_xxx | KEY_SHIFT | KEY_MOD1 | KEY_MOD2)
     USHORT          mnCharCode;     // SV-CharCode
     USHORT          mnRepeat;       // Repeat-Count (KeyInputs-1)
+};
+
+// MENUEVENT
+struct SalMenuEvent
+{
+    USHORT          mnId;           // Menu item ID
+    void*           mpMenu;         // pointer to VCL menu (class Menu)
 };
 
 // KEYMODCHANGE
Index: vcl/inc/scrbar.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/scrbar.hxx,v
retrieving revision 1.5
retrieving revision 1.10
diff -u -p -u -r1.5 -r1.10
--- vcl/inc/scrbar.hxx	25 Jul 2001 11:39:21 -0000	1.5
+++ vcl/inc/scrbar.hxx	10 May 2004 15:43:03 -0000	1.10
@@ -69,6 +69,8 @@
 #include <ctrl.hxx>
 #endif
 
+class AutoTimer;
+
 // -------------------
 // - ScrollBar-Types -
 // -------------------
@@ -79,6 +81,7 @@ enum ScrollType { SCROLL_DONTKNOW, SCROL
 // -------------
 // - ScrollBar -
 // -------------
+struct ImplScrollBarData;
 
 class ScrollBar : public Control
 {
@@ -88,7 +91,7 @@ private:
     Rectangle       maPage1Rect;
     Rectangle       maPage2Rect;
     Rectangle       maThumbRect;
-    void*           mpDummy;
+    ImplScrollBarData* mpData;
     long            mnStartPos;
     long            mnMouseOff;
     long            mnThumbPixRange;
@@ -107,14 +110,26 @@ private:
     ScrollType      meDDScrollType;
     BOOL            mbCalcSize;
     BOOL            mbFullDrag;
-    BOOL            mbDummy1;
-    BOOL            mbDummy2;
     Link            maScrollHdl;
     Link            maEndScrollHdl;
+    Rectangle*      ImplFindPartRect( const Point& rPt );
 
-#ifdef _SV_SCRBAR_CXX
-#include <scrbar.imp>
-#endif
+	void			ImplInit( Window* pParent, WinBits nStyle );
+	void			ImplInitStyle( WinBits nStyle );
+	void			ImplLoadRes( const ResId& rResId );
+	BOOL			ImplUpdateThumbRect( const Rectangle& rOldRect );
+	void			ImplUpdateRects( BOOL bUpdate = TRUE );
+	long			ImplCalcThumbPos( long nPixPos );
+	long			ImplCalcThumbPosPix( long nPos );
+	void			ImplCalc( BOOL bUpdate = TRUE );
+	void			ImplDraw( USHORT nDrawFlags, OutputDevice* pOutDev  );
+	long			ImplScroll( long nNewPos, BOOL bCallEndScroll );
+	long			ImplDoAction( BOOL bCallEndScroll );
+	void			ImplDoMouseAction( const Point& rPos, BOOL bCallAction = TRUE );
+	void			ImplInvert();
+    BOOL            ImplDrawNative( USHORT nDrawFlags );
+					DECL_LINK( ImplTimerHdl, Timer* );
+					DECL_LINK( ImplAutoTimerHdl, AutoTimer* );
 
 public:
                     ScrollBar( Window* pParent, WinBits nStyle = WB_VERT );
@@ -125,9 +140,13 @@ public:
     virtual void    Tracking( const TrackingEvent& rTEvt );
     virtual void    KeyInput( const KeyEvent& rKEvt );
     virtual void    Paint( const Rectangle& rRect );
+    virtual void    Draw( OutputDevice* pDev, const Point& rPos, const Size& rSize, ULONG nFlags );
     virtual void    Resize();
     virtual void    StateChanged( StateChangedType nType );
     virtual void    DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
+    virtual void    GetFocus();
+    virtual void    LoseFocus();
 
     virtual void    Scroll();
     virtual void    EndScroll();
@@ -169,11 +188,9 @@ public:
 
 class ScrollBarBox : public Window
 {
-#ifdef _SV_SCRBAR_CXX
 private:
     void            ImplInit( Window* pParent, WinBits nStyle );
     void            ImplInitSettings();
-#endif
 
 public:
                     ScrollBarBox( Window* pParent, WinBits nStyle = 0 );
Index: vcl/inc/settings.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/settings.hxx,v
retrieving revision 1.19
retrieving revision 1.23
diff -u -p -u -r1.19 -r1.23
--- vcl/inc/settings.hxx	17 Apr 2003 15:16:59 -0000	1.19
+++ vcl/inc/settings.hxx	10 Jun 2004 17:17:43 -0000	1.23
@@ -69,8 +69,8 @@
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
-#ifndef _SV_COLOR_HXX
-#include <color.hxx>
+#ifndef _TOOLS_COLOR_HXX
+#include <tools/color.hxx>
 #endif
 #ifndef _SV_FONT_HXX
 #include <font.hxx>
@@ -99,10 +99,8 @@ class ImplMachineData
 {
     friend class MachineSettings;
 
-#ifdef _SV_SETTINGS_CXX
                                     ImplMachineData();
                                     ImplMachineData( const ImplMachineData& rData );
-#endif
 
 private:
     USHORT                          mnRefCount;
@@ -161,10 +159,8 @@ class ImplMouseData
 {
     friend class MouseSettings;
 
-#ifdef _SV_SETTINGS_CXX
                                     ImplMouseData();
                                     ImplMouseData( const ImplMouseData& rData );
-#endif
 
 private:
     USHORT                          mnRefCount;
@@ -187,10 +183,6 @@ private:
     ULONG                           mnActionDelay;
     ULONG                           mnMenuDelay;
     ULONG                           mnFollow;
-    ULONG                           mnDummy1;
-    ULONG                           mnDummy2;
-    ULONG                           mnDummy3;
-    ULONG                           mnDummy4;
     USHORT                          mnMiddleButtonAction;
     USHORT                          mnAlign1;
 };
@@ -324,10 +316,8 @@ class ImplKeyboardData
 {
     friend class KeyboardSettings;
 
-#ifdef _SV_SETTINGS_CXX
                                     ImplKeyboardData();
                                     ImplKeyboardData( const ImplKeyboardData& rData );
-#endif
 
 private:
     USHORT                          mnRefCount;
@@ -378,74 +368,56 @@ class ImplStyleData
 {
     friend class StyleSettings;
 
-#ifdef _SV_SETTINGS_CXX
                                     ImplStyleData();
                                     ImplStyleData( const ImplStyleData& rData );
     void                            SetStandardStyles();
-    void                            SetStandardWinStyles();
-    void                            SetStandardOS2Styles();
-    void                            SetStandardMacStyles();
-    void                            SetStandardUnixStyles();
-#endif
 
 private:
     USHORT                          mnRefCount;
-    Color                           maFaceColor;
-    Color                           maCheckedColor;
-    Color                           maLightColor;
-    Color                           maLightBorderColor;
-    Color                           maShadowColor;
-    Color                           maDarkShadowColor;
-    Color                           maButtonTextColor;
-    Color                           maRadioCheckTextColor;
-    Color                           maLabelTextColor;
-    Color                           maInfoTextColor;
-    Color                           maWindowColor;
-    Color                           maWindowTextColor;
-    Color                           maDialogColor;
-    Color                           maDialogTextColor;
-    Color                           maWorkspaceColor;
-    Color                           maFieldColor;
-    Color                           maFieldTextColor;
+
+	void*							mpStyleData_NotUsedYet;
+
+	Color                           maActiveBorderColor;
     Color                           maActiveColor;
     Color                           maActiveColor2;
     Color                           maActiveTextColor;
-    Color                           maActiveBorderColor;
+    Color                           maButtonTextColor;
+    Color                           maCheckedColor;
+    Color                           maDarkShadowColor;
+    Color                           maDeactiveBorderColor;
     Color                           maDeactiveColor;
     Color                           maDeactiveColor2;
     Color                           maDeactiveTextColor;
-    Color                           maDeactiveBorderColor;
+    Color                           maDialogColor;
+    Color                           maDialogTextColor;
+    Color                           maDisableColor;
+    Color                           maFaceColor;
+    Color                           maFieldColor;
+    Color                           maFieldTextColor;
+    Color                           maFontColor;
+    Color                           maGroupTextColor;
+    Color                           maHelpColor;
     Color                           maHelpTextColor;
-    Color                           maMenuColor;
     Color                           maHighlightColor;
+    Color                           maHighlightLinkColor;
     Color                           maHighlightTextColor;
+    Color                           maInfoTextColor;
+    Color                           maLabelTextColor;
+    Color                           maLightBorderColor;
+    Color                           maLightColor;
+    Color                           maLinkColor;
+    Color                           maMenuBarColor;
+    Color                           maMenuBorderColor;
+    Color                           maMenuColor;
     Color                           maMenuHighlightColor;
     Color                           maMenuHighlightTextColor;
-    Color                           maDisableColor;
-    Color                           maHelpColor;
-    Color                           maGroupTextColor;
     Color                           maMenuTextColor;
-    Color                           maLinkColor;
+    Color                           maRadioCheckTextColor;
+    Color                           maShadowColor;
     Color                           maVisitedLinkColor;
-    Color                           maHighlightLinkColor;
-    Color                           maFontColor;
-    Color                           maDummyColor2;
-    Color                           maDummyColor3;
-    Color                           maDummyColor4;
-    Color                           maDummyColor5;
-    Color                           maDummyColor6;
-    Color                           maDummyColor7;
-    Color                           maDummyColor8;
-    Color                           maDummyColor9;
-    Color                           maDummyColor10;
-    Color                           maDummyColor11;
-    Color                           maDummyColor12;
-    Color                           maDummyColor13;
-    Color                           maDummyColor14;
-    Color                           maDummyColor15;
-    Color                           maDummyColor16;
-    Color                           maMenuBorderColor;
-    Color                           maMenuBarColor;
+    Color                           maWindowColor;
+    Color                           maWindowTextColor;
+    Color                           maWorkspaceColor;
     Font                            maAppFont;
     Font                            maHelpFont;
     Font                            maTitleFont;
@@ -459,8 +431,6 @@ private:
     Font                            maFieldFont;
     Font                            maIconFont;
     Font                            maGroupFont;
-    Font                            maDummyFont1;
-    Font                            maDummyFont2;
     long                            mnBorderSize;
     long                            mnTitleHeight;
     long                            mnFloatTitleHeight;
@@ -473,11 +443,6 @@ private:
     long                            mnIconHorzSpace;
     long                            mnIconVertSpace;
     long                            mnAntialiasedMin;
-    long                            mnDummySize2;
-    long                            mnDummySize3;
-    long                            mnDummySize4;
-    long                            mnDummySize5;
-    long                            mnDummySize6;
     ULONG                           mnCursorBlinkTime;
     ULONG                           mnDragFullOptions;
     ULONG                           mnAnimationOptions;
@@ -485,8 +450,6 @@ private:
     ULONG                           mnLogoDisplayTime;
     ULONG                           mnDisplayOptions;
     ULONG                           mnToolbarIconSize;
-    ULONG                           mnDummyOption3;
-    ULONG                           mnDummyOption4;
     ULONG                           mnUseFlatMenues;
     ULONG                           mnOptions;
     USHORT                          mnScreenZoom;
@@ -499,6 +462,7 @@ private:
     USHORT                          mnUseSystemUIFonts;
     USHORT                          mnAutoMnemonic;
     USHORT                          mnUseImagesInMenus;
+    ULONG                           mnUseFlatBorders;
 };
 
 // -----------------
@@ -750,10 +714,15 @@ public:
                                         { CopyData(); mpData->mnHighContrast = bHighContrast; }
     BOOL							GetHighContrastMode() const
                                         { return (BOOL) mpData->mnHighContrast; }
+    BOOL							IsHighContrastBlackAndWhite() const;
     void							SetUseSystemUIFonts( BOOL bUseSystemUIFonts )
                                         { CopyData(); mpData->mnUseSystemUIFonts = bUseSystemUIFonts; }
     BOOL							GetUseSystemUIFonts() const
                                         { return (BOOL) mpData->mnUseSystemUIFonts; }
+    void							SetUseFlatBorders( BOOL bUseFlatBorders )
+                                        { CopyData(); mpData->mnUseFlatBorders = bUseFlatBorders; }
+    BOOL							GetUseFlatBorders() const
+                                        { return (BOOL) mpData->mnUseFlatBorders; }
     void							SetUseFlatMenues( BOOL bUseFlatMenues )
                                         { CopyData(); mpData->mnUseFlatMenues = bUseFlatMenues; }
     BOOL							GetUseFlatMenues() const
@@ -962,17 +931,14 @@ class ImplMiscData
 {
     friend class MiscSettings;
 
-#ifdef _SV_SETTINGS_CXX
                                     ImplMiscData();
                                     ImplMiscData( const ImplMiscData& rData );
-#endif
 
 private:
     USHORT                          mnRefCount;
     USHORT                          mnTwoDigitYearStart;
     USHORT                          mnEnableATT;
-    USHORT                          mnDummy1;
-    USHORT                          mnDummy2;
+    BOOL                            mbEnableLocalizedDecimalSep;
 };
 
 // ----------------
@@ -997,6 +963,8 @@ public:
                                         { return mpData->mnTwoDigitYearStart; }
     void							SetEnableATToolSupport( BOOL bEnable );
     BOOL							GetEnableATToolSupport() const;
+    void							SetEnableLocalizedDecimalSep( BOOL bEnable );
+    BOOL							GetEnableLocalizedDecimalSep() const;
     const MiscSettings&             operator =( const MiscSettings& rSet );
 
     BOOL                            operator ==( const MiscSettings& rSet ) const;
@@ -1012,10 +980,8 @@ class ImplSoundData
 {
     friend class SoundSettings;
 
-#ifdef _SV_SETTINGS_CXX
                                     ImplSoundData();
                                     ImplSoundData( const ImplSoundData& rData );
-#endif
 
 private:
     USHORT                          mnRefCount;
@@ -1063,10 +1029,8 @@ class ImplNotificationData
 {
     friend class NotificationSettings;
 
-#ifdef _SV_SETTINGS_CXX
                                     ImplNotificationData();
                                     ImplNotificationData( const ImplNotificationData& rData );
-#endif
 
 private:
     USHORT                          mnRefCount;
@@ -1109,10 +1073,8 @@ class ImplHelpData
 {
     friend class HelpSettings;
 
-#ifdef _SV_SETTINGS_CXX
                                     ImplHelpData();
                                     ImplHelpData( const ImplHelpData& rData );
-#endif
 
 private:
     USHORT                          mnRefCount;
@@ -1171,13 +1133,11 @@ public:
 
 class ImplAllSettingsData
 {
-    friend class AllSettings;
+    friend class	AllSettings;
 
-#ifdef _SV_SETTINGS_CXX
-                                            ImplAllSettingsData();
-                                            ImplAllSettingsData( const ImplAllSettingsData& rData );
-                                            ~ImplAllSettingsData();
-#endif
+					ImplAllSettingsData();
+					ImplAllSettingsData( const ImplAllSettingsData& rData );
+					~ImplAllSettingsData();
 
 private:
     USHORT                                  mnRefCount;
@@ -1202,9 +1162,6 @@ private:
     CollatorWrapper*                        mpUICollatorWrapper;
     vcl::I18nHelper*                        mpI18nHelper;
     vcl::I18nHelper*                        mpUII18nHelper;
-
-    void*                                   mpDummy1;
-    void*                                   mpDummy2;
 };
 
 // ---------------
Index: vcl/inc/slider.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/slider.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/slider.hxx	19 Sep 2000 10:23:07 -0000	1.1.1.1
+++ vcl/inc/slider.hxx	7 Jan 2004 09:18:32 -0000	1.2
@@ -106,7 +106,6 @@ private:
 	Link			maSlideHdl;
 	Link			maEndSlideHdl;
 
-#ifdef _SV_SLIDER_CXX
 	void			ImplInit( Window* pParent, WinBits nStyle );
 	void			ImplInitStyle( WinBits nStyle );
 	void			ImplLoadRes( const ResId& rResId );
@@ -123,7 +122,6 @@ private:
 	void			ImplDoMouseAction( const Point& rPos, BOOL bCallAction = TRUE );
 	long			ImplDoSlide( long nNewPos );
 	long			ImplDoSlideAction( ScrollType eScrollType );
-#endif
 
 public:
 					Slider( Window* pParent, WinBits nStyle = WB_HORZ );
Index: vcl/inc/sound.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/sound.hxx,v
retrieving revision 1.3
retrieving revision 1.5
diff -u -p -u -r1.3 -r1.5
--- vcl/inc/sound.hxx	13 Jun 2001 10:52:47 -0000	1.3
+++ vcl/inc/sound.hxx	7 Jan 2004 09:19:13 -0000	1.5
@@ -92,15 +92,10 @@ class Sound
 {
 private:
 
-#ifndef REMOTE_APPSERVER
 	SalSound*			mpSound;
-#else
-	RMSound*			mpSound;
-#endif
-
 	XubString			maSoundName;
 	Window* 			mpWindow;
-	BYTE*				mpSoundData;
+	BYTE*				mpSoundData_NOTUSED;
 	ULONG				mnDataLen;
 	ULONG				mnSoundLen;
 	ULONG				mnStartTime;
@@ -124,7 +119,7 @@ public:
 	
 public:
                         Sound( Window* pWindow = NULL );
-                        ~Sound();
+    virtual             ~Sound();
 
     virtual void        Notify();
 
@@ -132,8 +127,6 @@ public:
 	Window* 			GetWindow() const { return mpWindow; }
 	BOOL				SetSoundName( const XubString& rSoundName );
 	const XubString& 	GetSoundName() const { return maSoundName; }
-	BOOL				SetSoundData( const BYTE* pSoundData, ULONG nDataLen );
-	BYTE*				GetSoundData() const { return mpSoundData; }
 	ULONG				GetSoundLen() const { return mnSoundLen; }
 
     void				Play();
Index: vcl/inc/spin.h
===================================================================
RCS file: /cvs/gsl/vcl/inc/spin.h,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/spin.h	19 Sep 2000 10:23:07 -0000	1.1.1.1
+++ vcl/inc/spin.h	11 Dec 2003 11:51:45 -0000	1.2
@@ -82,6 +82,6 @@ void ImplDrawSpinButton( OutputDevice* p
                          BOOL bUpperIn, BOOL bLowerIn,
                          BOOL bUpperEnabled = TRUE,
                          BOOL bLowerEnabled = TRUE,
-                         BOOL bHorz = FALSE );
+                         BOOL bHorz = FALSE, BOOL bMirrorHorz = FALSE );
 
 #endif  // _SV_SPIN_H
Index: vcl/inc/spin.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/spin.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.4
diff -u -p -u -r1.1.1.1 -r1.4
--- vcl/inc/spin.hxx	19 Sep 2000 10:23:07 -0000	1.1.1.1
+++ vcl/inc/spin.hxx	10 May 2004 15:43:29 -0000	1.4
@@ -82,19 +82,24 @@ private:
     AutoTimer       maRepeatTimer;
     Rectangle       maUpperRect;
     Rectangle       maLowerRect;
-    BOOL            mbRepeat      : 1;
-    BOOL            mbUpperIn     : 1;
-    BOOL            mbLowerIn     : 1;
-    BOOL            mbInitialUp   : 1;
-    BOOL            mbInitialDown : 1;
-    BOOL            mbHorz        : 1;
+    Rectangle       maFocusRect;
+    BOOL            mbRepeat         : 1;
+    BOOL            mbUpperIn        : 1;
+    BOOL            mbLowerIn        : 1;
+    BOOL            mbInitialUp      : 1;
+    BOOL            mbInitialDown    : 1;
+    BOOL            mbHorz           : 1;
+    BOOL            mbUpperIsFocused : 1;
     Link            maUpHdlLink;
     Link            maDownHdlLink;
+    long            mnMinRange;
+    long            mnMaxRange;
+    long            mnValue;
+    long            mnValueStep;
+    Rectangle*      ImplFindPartRect( const Point& rPt );
 
-#ifdef _SV_SPIN_CXX
     void            ImplInit( Window* pParent, WinBits nStyle );
                     DECL_LINK( ImplTimeout, Timer* );
-#endif
 
 public:
                     SpinButton( Window* pParent, WinBits nStyle = 0 );
@@ -106,16 +111,45 @@ public:
 
     virtual void    Resize();
     virtual void    Paint( const Rectangle& rRect );
+    virtual void    Draw( OutputDevice* pDev, const Point& rPos, const Size& rSize, ULONG nFlags );
     virtual void    MouseButtonDown( const MouseEvent& rMEvt );
     virtual void    MouseButtonUp( const MouseEvent& rMEvt );
     virtual void    MouseMove( const MouseEvent& rMEvt );
     virtual void    KeyInput( const KeyEvent& rKEvt );
     virtual void    StateChanged( StateChangedType nStateChange );
+    virtual void    GetFocus();
+    virtual void    LoseFocus();
+
+    void            SetRangeMin( long nNewRange );
+    long            GetRangeMin() const { return mnMinRange; }
+    void            SetRangeMax( long nNewRange );
+    long            GetRangeMax() const { return mnMaxRange; }
+    void            SetRange( const Range& rRange );
+    Range           GetRange() const { return Range( GetRangeMin(), GetRangeMax() ); }
+    void            SetValue( long nValue );
+    long            GetValue() const { return mnValue; }
+    void            SetValueStep( long nNewStep ) { mnValueStep = nNewStep; }
+    long            GetValueStep() const { return mnValueStep; }
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
     void            SetUpHdl( const Link& rLink ) { maUpHdlLink = rLink; }
     const Link&     GetUpHdl() const   { return maUpHdlLink;   }
     void            SetDownHdl( const Link& rLink ) { maDownHdlLink = rLink; }
     const Link&     GetDownHdl() const { return maDownHdlLink; }
+
+private:
+    // moves the focus to the upper or lower rect. Return TRUE if the focus rect actually changed.
+    BOOL            ImplMoveFocus( BOOL _bUpper );
+    void            ImplCalcFocusRect( BOOL _bUpper );
+
+    inline BOOL     ImplIsUpperEnabled( ) const
+    {
+        return mnValue + mnValueStep <= mnMaxRange;
+    }
+    inline BOOL     ImplIsLowerEnabled( ) const
+    {
+        return mnValue >= mnMinRange + mnValueStep;
+    }
 };
 
 #endif  // _SV_SPIN_HXX
Index: vcl/inc/spinfld.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/spinfld.hxx,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -p -u -r1.3 -r1.6
--- vcl/inc/spinfld.hxx	3 May 2002 13:04:10 -0000	1.3
+++ vcl/inc/spinfld.hxx	10 May 2004 15:43:41 -0000	1.6
@@ -97,16 +97,12 @@ protected:
 					mbLowerIn:1,
 					mbInDropDown:1;
 
-#if _SOLAR__PRIVATE
 	void			ImplInit( Window* pParent, WinBits nStyle );
 
-#ifdef _SV_SPINFLD_CXX
 private:
 					DECL_LINK( ImplTimeout, Timer* );
 	void			ImplInitData();
 	void			ImplCalcButtonAreas( OutputDevice* pDev, const Size& rOutSz, Rectangle& rDDArea, Rectangle& rSpinUpArea, Rectangle& rSpinDownArea );
-#endif
-#endif
 
 protected:
 					SpinField( WindowType nTyp );
@@ -117,6 +113,7 @@ protected:
 	void			EndDropDown();
 
     virtual void  FillLayoutData() const;
+    Rectangle *     ImplFindPartRect( const Point& rPt );
 public:
 					SpinField( Window* pParent, WinBits nWinStyle = 0 );
 					SpinField( Window* pParent, const ResId& rResId );
@@ -137,6 +134,7 @@ public:
 	virtual void	Resize();
 	virtual void	StateChanged( StateChangedType nType );
 	virtual void	DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long    PreNotify( NotifyEvent& rNEvt );
 
 	void			SetUpHdl( const Link& rLink ) { maUpHdlLink = rLink; }
 	const Link& 	GetUpHdl() const { return maUpHdlLink; }
Index: vcl/inc/split.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/split.hxx,v
retrieving revision 1.7
retrieving revision 1.8
diff -u -p -u -r1.7 -r1.8
--- vcl/inc/split.hxx	14 Aug 2002 14:06:39 -0000	1.7
+++ vcl/inc/split.hxx	7 Jan 2004 09:20:22 -0000	1.8
@@ -92,7 +92,6 @@ private:
     Link                maStartSplitHdl;
     Link                maSplitHdl;
 
-#ifdef _SV_SPLIT_CXX
 	void 				ImplInitData();
 	void 				ImplDrawSplitter();
     void                ImplSplitMousePos( Point& rPos );
@@ -101,7 +100,6 @@ private:
     BOOL                ImplSplitterActive();
     Splitter*           ImplFindSibling();
     void                ImplRestoreSplitter();
-#endif
 
 protected:
 	void 				ImplInit( Window* pParent, WinBits nWinStyle );
Index: vcl/inc/splitwin.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/splitwin.hxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/inc/splitwin.hxx	27 Mar 2003 17:57:33 -0000	1.2
+++ vcl/inc/splitwin.hxx	7 Jan 2004 09:20:41 -0000	1.3
@@ -141,10 +141,7 @@ private:
 						mbFadeInPressed:1,
 						mbFadeOutPressed:1,
 						mbFadeNoButtonMode:1,
-						mbNoAlign:1,
-						mbDummy2:1,
-						mbDummy3:1,
-						mbDummy4:1;
+						mbNoAlign:1;
 	Link				maStartSplitHdl;
 	Link				maSplitHdl;
 	Link				maSplitResizeHdl;
@@ -152,7 +149,6 @@ private:
 	Link				maFadeInHdl;
 	Link				maFadeOutHdl;
 
-#ifdef _SV_SPLITWIN_CXX
 	void				ImplInit( Window* pParent, WinBits nStyle );
 	void				ImplInitSettings();
 	void				ImplCalcLayout();
@@ -169,7 +165,6 @@ private:
 	void				ImplDrawFadeIn( BOOL bInPaint );
 	void				ImplDrawFadeOut( BOOL bInPaint );
 	void				ImplNewAlign();
-#endif
 
 public:
 						SplitWindow( Window* pParent, WinBits nStyle = 0 );
Index: vcl/inc/status.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/status.hxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/inc/status.hxx	27 Mar 2003 17:57:33 -0000	1.3
+++ vcl/inc/status.hxx	7 Jan 2004 09:20:58 -0000	1.4
@@ -128,23 +128,17 @@ private:
 	long				mnCalcHeight;
 	long				mnTextY;
 	long				mnItemY;
-	long				mnDummyLong;
 	USHORT				mnCurItemId;
 	USHORT				mnPercent;
 	USHORT				mnPercentCount;
-	USHORT				mnDummy1;
 	BOOL				mbVisibleItems;
 	BOOL				mbFormat;
 	BOOL				mbProgressMode;
 	BOOL				mbInUserDraw;
 	BOOL				mbBottomBorder;
-	BOOL				mbDummy1;
-	BOOL				mbDummy2;
-	BOOL				mbDummy3;
 	Link				maClickHdl;
 	Link				maDoubleClickHdl;
 
-#ifdef _SV_STATUS_CXX
 	void				ImplInit( Window* pParent, WinBits nStyle );
 	void				ImplInitSettings( BOOL bFont, BOOL bForeground, BOOL bBackground );
 	void				ImplFormat();
@@ -155,7 +149,6 @@ private:
 										  USHORT nOldPerc, USHORT nNewPerc );
 	void				ImplCalcProgressRect();
 	Rectangle			ImplGetItemRectPos( USHORT nPos ) const;
-#endif
 
 public:
 						StatusBar( Window* pParent,
Index: vcl/inc/svapp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/svapp.hxx,v
retrieving revision 1.27
retrieving revision 1.30
diff -u -p -u -r1.27 -r1.30
--- vcl/inc/svapp.hxx	10 Jun 2003 14:29:14 -0000	1.27
+++ vcl/inc/svapp.hxx	10 May 2004 12:57:43 -0000	1.30
@@ -74,9 +74,6 @@
 #ifndef _UNQID_HXX
 #include <tools/unqid.hxx>
 #endif
-#ifndef _RTTI_HXX
-#include <tools/rtti.hxx>
-#endif
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
@@ -100,13 +97,8 @@ class Window;
 class Reflection;
 class KeyCode;
 class NotifyEvent;
 class KeyEvent;
 
-#ifndef NOOLDSV
-class Font;
-class ApplicationAddress;
-class ApplicationEvent;
-#endif
 namespace vos { class IMutex; }
 
 #ifndef _COM_SUN_STAR_UNO_REFERENCE_H_
@@ -327,7 +291,7 @@ class Application
 {
 public:
                                 Application();
-                                ~Application();
+    virtual                     ~Application();
 
     virtual void                Main() = 0;
 
@@ -406,8 +370,9 @@ public:
 
 #ifndef NO_GETAPPWINDOW
     static WorkWindow*          GetAppWindow();
 #endif
-    static Window*              GetFocusWindow();
+
+	static Window*              GetFocusWindow();
     static OutputDevice*        GetDefaultDevice();
 
     static Window*              GetFirstTopLevelWindow();
@@ -562,6 +482,11 @@ public:
         Can be called without the Solar mutex locked.
      */
     static bool GetShowImeStatusWindowDefault();
+    
+    /** Returns a string representing the desktop environment 
+        the process is currently running in.
+     */
+    static const ::rtl::OUString& GetDesktopEnvironment();
 };
 
 Application* GetpApp();
Index: vcl/inc/svdata.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/svdata.hxx,v
retrieving revision 1.38.88.2
retrieving revision 1.45
diff -u -p -u -r1.38.88.2 -r1.45
--- vcl/inc/svdata.hxx	2 Mar 2004 10:00:45 -0000	1.38.88.2
+++ vcl/inc/svdata.hxx	25 Jun 2004 17:08:32 -0000	1.45
@@ -147,80 +147,13 @@ class ImplVDevCache;
 class UnoWrapperBase;
 class GraphicConverter;
 class ImplWheelWindow;
+class SalTimer;
+class SalI18NImeStatus;
 
 namespace vos { class OMutex; }
 namespace vos { class OCondition; }
 namespace vcl { class DisplayConnection; class DefaultFontConfigItem; class FontSubstConfigItem; class SettingsConfigItem;}
 
-// ----------
-// - Remote -
-// ----------
-
-#ifdef REMOTE_APPSERVER
-class VclOTimer;
-class RmEventQueue;
-class UNODispatchThread;
-
-// see unotools/atom.hxx
-namespace utl {
-    class AtomClient;
-}
-
-// needed for server side drag and drop
-namespace com { namespace sun { namespace star { namespace datatransfer { namespace dnd {
-    class XDragSource;
-} } } } }
-
-#include <tools/table.hxx>
-#include <vos/mutex.hxx>
-#include <vos/thread.hxx>
-#include <vos/semaphor.hxx>
-#include "rvp.hxx"
-
-#define CHECK_FOR_RVPSYNC_NORMAL()  ImplGetSVData()->mpRVPNormalSync->CheckForRVPSync( NULL );
-#define CHECK_FOR_RVPSYNC_SOUND()   ImplGetSVData()->mpRVPSoundSync->CheckForRVPSync( NULL );
-
-void rvpExceptionHandler();
-
-DECLARE_TABLE( KeyNames, String* );
-
-class ImplRemoteYieldMutex : public vos::OMutex
-{
-    ULONG                                       mnCount;
-    vos::OThread::TThreadIdentifier             mnThreadId;
-    vos::OThread::TThreadIdentifier             mnMainThreadId;
-
-public:
-                                                ImplRemoteYieldMutex();
-
-    virtual void SAL_CALL                       acquire();
-    virtual void SAL_CALL                       release();
-    virtual sal_Bool SAL_CALL                   tryToAcquire();
-
-    ULONG                                       GetAcquireCount() const { return mnCount; }
-    vos::OThread::TThreadIdentifier             GetThreadId() const { return mnThreadId; }
-    vos::OThread::TThreadIdentifier             GetMainThreadId() const { return mnMainThreadId; }
-
-};
-
-// sync uno rvp call packages
-class RVPSync
-{
-    vos::OThread::TThreadIdentifier             mnLastThreadId;
-    oslInterlockedCount                         mnRVPCount;
-    REF( NMSP_CLIENT::XRmSync )                 mxRVPSync;
-    vos::OMutex                                 maMutex;
-	sal_uInt32                                  mnForceSyncCount;
-	sal_uInt32                                  mnSyncCount;
-
-public:
-    RVPSync( const REF( NMSP_CLIENT::XRmSync )& xRVPSync );
-
-    void                                        CheckForRVPSync( const char* );
-};
-
-#endif
-
 // -----------------
 // - ImplSVAppData -
 // -----------------
@@ -234,9 +167,6 @@ struct ImplSVAppData
         ImeStatusWindowMode_SHOW
     };
 
-#ifdef REMOTE_APPSERVER
-    ImplRemoteYieldMutex*   mpSolarMutex;       // Solar-Mutex
-#endif
     ::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory >    mxMSF;
     String*                 mpMSFTempFileName;
     AllSettings*            mpSettings;         // Application settings
@@ -337,7 +266,6 @@ struct ImplSVWinData
     USHORT                  mnAutoScrollFlags;  // auto scroll flags
     BOOL                    mbNoDeactivate;     // TRUE: keine Deactivate durchfuehren
 	BOOL					mbNoSaveFocus;		// TRUE: menues must not save/restore focus
-    BOOL                    mbDummy1;
 };
 
 
@@ -387,17 +315,6 @@ struct ImplSVHelpData
 };
 
 
-// --------------------
-// - ImplSVSystemData -
-// --------------------
-
-struct ImplSVSystemData
-{
-#ifndef REMOTE_APPSERVER
-    SalSystem*              mpDefSystem;        // Default-System-Instance
-#endif
-};
-
 // --------------
 // - ImplSVData -
 // --------------
@@ -412,6 +329,9 @@ struct ImplSVData
     ULONG                   mnThreadCount;      // is VCL MultiThread enabled
     ImplConfigData*         mpFirstConfigData;  // Zeiger auf ersten Config-Block
     ImplTimerData*          mpFirstTimerData;   // list of all running timers
+    SalTimer*				mpSalTimer;			// interface to sal event loop/timers
+    SalI18NImeStatus*		mpImeStatus;		// interface to ime status window
+    SalSystem*				mpSalSystem;		// SalSystem interface
     ResMgr*                 mpResMgr;           // SV-Resource-Manager
     ULONG                   mnTimerPeriod;      // current timer period
     ULONG                   mnTimerUpdate;      // TimerCallbackProcs on stack
@@ -422,35 +342,12 @@ struct ImplSVData
     ImplSVWinData           maWinData;          // indepen data for Windows classes
     ImplSVCtrlData          maCtrlData;         // indepen data for Control classes
     ImplSVHelpData          maHelpData;         // indepen data for Help classes
-    ImplSVSystemData        maSystemData;       // indepen data for class System
     UnoWrapperBase*         mpUnoWrapper;
     Window*                 mpIntroWindow;      // the splash screen
 
     vos::OThread::TThreadIdentifier     mnMainThreadId;
     ::vcl::DisplayConnection*           mpDisplayConnection;
 
-#ifdef REMOTE_APPSERVER
-    VclOTimer*                          mpOTimer;           // VOS-Timer
-    RmEventQueue*                       mpRmEventQueue;     // Remote-EventQueue
-    REF( NMSP_CLIENT::XRmStatus )               mxStatus;           // Remote-Status
-    REF( NMSP_LANG::XMultiServiceFactory )      mxClientFactory;    // XFactory zum erzeugen der UNO-Objekte statt ueber UNO_createObject
-    REF( NMSP_CLIENT::XMultiInstanceFactory )   mxMultiFactory;     // XFactory zum erzeugen der UNO-Objekte statt ueber UNO_createObject
-    RVPSync*                            mpRVPNormalSync;    // sync interfaces for rvp normal-calls
-    RVPSync*                            mpRVPSoundSync;     // sync interfaces for rvp sound-calls
-    long                                mnRemoteVersion;    // remote version of client
-    ::utl::AtomClient*                  mpAtoms;            // Atoms for client connection
-    ::vos::OMutex*                      mpWindowObjectMutex;
-    ::vos::OCondition*                  mpStartUpCond;
-    void*                               mhRemoteEnv;        // not needed anymore
-    String*                             mpConnectionName;
-    KeyNames*                           mpKeyNames;
-    REF( NMSP_CLIENT::XRmPrinterEnvironment )	mxRmPrinterEnvironment;
-    NMSP_CLIENT::PrinterEnvironment*			mpPrinterEnvironment;
-//  UNO_Server                          mhRemotePrinter;    // UNO-PrinterServer
-//  XRmPrinterEnvironment*              mpRmPrinterEnv;     // UNO-Printer-Environment
-    ::com::sun::star::uno::Reference< ::com::sun::star::datatransfer::dnd::XDragSource > mxServerDragSource;
-	Rectangle							maWorkArea;			// the remote screen size in pixels
-#endif
     ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > mxAccessBridge;
     com::sun::star::uno::Reference< com::sun::star::frame::XSessionManagerClient > xSMClient;
     ::vcl::SettingsConfigItem*			mpSettingsConfigItem;
@@ -465,10 +362,8 @@ ResMgr*     ImplGetResMgr();
 void        ImplWindowAutoMnemonic( Window* pWindow );
 void        ImplTimerCallbackProc();
 
-#ifndef REMOTE_APPSERVER
 void        ImplUpdateSystemProcessWindow();
 Window*     ImplFindWindow( const SalFrame* pFrame, Point& rSalFramePos );
-#endif
 
 // SVAPP.CXX
 BOOL        ImplCallHotKey( const KeyCode& rKeyCode );
Index: vcl/inc/sysdata.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/sysdata.hxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/inc/sysdata.hxx	9 Feb 2001 14:51:45 -0000	1.2
+++ vcl/inc/sysdata.hxx	7 Jan 2004 09:22:49 -0000	1.4
@@ -69,11 +69,8 @@
 struct SystemEnvData
 {
 	unsigned long		nSize;			// size in bytes of this structure
-#ifndef SYSDATA_ONLY_BASETYPE
-#if defined( WIN ) || defined( WNT )
+#if defined( WNT )
 	HWND				hWnd;			// the window hwnd
-#elif defined( OS2 )
-	HWND				hWnd;			// the client hwnd
 #elif defined( UNX )
 	void*				pDisplay;		// the relevant display connection
 	long				aWindow;		// the window of the object
@@ -86,7 +83,6 @@ struct SystemEnvData
 	long				aShellWindow;	// the window of the frame's shell
 	void*				pShellWidget;	// the frame's shell widget
 #endif
-#endif
 };
 
 #define SystemChildData SystemEnvData
@@ -98,14 +94,24 @@ struct SystemEnvData
 struct SystemParentData
 {
 	unsigned long	nSize;			// size in bytes of this structure
-#ifndef SYSDATA_ONLY_BASETYPE
-#if defined( WIN ) || defined( WNT )
+#if defined( WNT )
 	HWND			hWnd;			// the window hwnd
-#elif defined( OS2 )
-	HWND			hWnd;			// the client hwnd
 #elif defined( UNX )
 	long		    aWindow;		// the window of the object
 #endif
+};
+
+// --------------------
+// - SystemMenuData -
+// --------------------
+
+struct SystemMenuData
+{
+	unsigned long	nSize;			// size in bytes of this structure
+#if defined( WNT )
+	HMENU			hMenu;			// the menu handle of the menu bar
+#elif defined( UNX )
+	long		    aMenu;		    // ???
 #endif
 };
 
Index: vcl/inc/syswin.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/syswin.hxx,v
retrieving revision 1.12
retrieving revision 1.13
diff -u -p -u -r1.12 -r1.13
--- vcl/inc/syswin.hxx	27 Mar 2003 17:57:34 -0000	1.12
+++ vcl/inc/syswin.hxx	7 Jan 2004 09:23:35 -0000	1.13
@@ -219,12 +219,9 @@ private:
     BOOL            mbDockBtn;
     BOOL            mbHideBtn;
     BOOL            mbSysChild;
-    BOOL            mbDummy2;
-    BOOL            mbDummy3;
     USHORT          mnMenuBarMode;
     USHORT          mnIcon;
 	TaskPaneList*   mpTaskPaneList;
-	void*			mpDummy;
 
 protected:
                     SystemWindow( WindowType nType );
Index: vcl/inc/tabctrl.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/tabctrl.hxx,v
retrieving revision 1.4
retrieving revision 1.7
diff -u -p -u -r1.4 -r1.7
--- vcl/inc/tabctrl.hxx	4 Jun 2003 11:21:18 -0000	1.4
+++ vcl/inc/tabctrl.hxx	10 May 2004 15:43:53 -0000	1.7
@@ -110,8 +110,6 @@ private:
     Link                maActivateHdl;
     Link                maDeactivateHdl;
 
-#ifdef _SV_TABCTRL_CXX
-private:
     void                ImplInitSettings( BOOL bFont, BOOL bForeground, BOOL bBackground );
     ImplTabItem*        ImplGetItem( USHORT nId ) const;
     void                ImplScrollBtnsColor();
@@ -124,16 +122,17 @@ private:
     void                ImplActivateTabPage( BOOL bNext );
     void                ImplSetFirstPagePos( USHORT nPagePos );
     void                ImplShowFocus();
-    void                ImplDrawItem( ImplTabItem* pItem, const Rectangle& rCurRect, bool bLayout = false );
+    void                ImplDrawItem( ImplTabItem* pItem, const Rectangle& rCurRect, bool bLayout = false, bool bFirstInGroup = false, bool bLastInGroup = false, bool bIsCurrentItem = false );
     void				ImplPaint( const Rectangle& rRect, bool bLayout = false );
     void				ImplFreeLayoutData();
                         DECL_LINK( ImplScrollBtnHdl, PushButton* pBtn );
-#endif
+
 protected:
     void                ImplInit( Window* pParent, WinBits nStyle );
     void                ImplLoadRes( const ResId& rResId );
 
     virtual void		FillLayoutData() const;
+    Rectangle*          ImplFindPartRect( const Point& rPt );
 
 public:
                         TabControl( Window* pParent,
@@ -152,6 +151,7 @@ public:
     virtual long        Notify( NotifyEvent& rNEvt );
     virtual void        StateChanged( StateChangedType nType );
     virtual void        DataChanged( const DataChangedEvent& rDCEvt );
+    virtual long        PreNotify( NotifyEvent& rNEvt );
 
     virtual void        ActivatePage();
     virtual long        DeactivatePage();
Index: vcl/inc/tabdlg.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/tabdlg.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/tabdlg.hxx	19 Sep 2000 10:23:07 -0000	1.1.1.1
+++ vcl/inc/tabdlg.hxx	7 Jan 2004 09:24:21 -0000	1.2
@@ -83,10 +83,8 @@ private:
 	WindowAlign 		meViewAlign;
 	BOOL				mbPosControls;
 
-#ifdef _SV_TABDLG_CXX
 	void				ImplInitData();
 	void				ImplPosControls();
-#endif
 
 public:
 						TabDialog( Window* pParent,
Index: vcl/inc/tabpage.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/tabpage.hxx,v
retrieving revision 1.3
retrieving revision 1.5
diff -u -p -u -r1.3 -r1.5
--- vcl/inc/tabpage.hxx	24 Apr 2003 16:30:10 -0000	1.3
+++ vcl/inc/tabpage.hxx	20 Feb 2004 08:49:19 -0000	1.5
@@ -75,15 +75,15 @@
 
 class TabPage : public Window
 {
-#ifdef _SV_TABPAGE_CXX
 private:
 	void			ImplInit( Window* pParent, WinBits nStyle );
 	void			ImplInitSettings();
-#endif
 
 public:
 					TabPage( Window* pParent, WinBits nStyle = 0 );
 					TabPage( Window* pParent, const ResId& rResId );
+
+    virtual void    Paint( const Rectangle& rRect );
 
 	virtual void	StateChanged( StateChangedType nStateChange );
 	virtual void	DataChanged( const DataChangedEvent& rDCEvt );
Index: vcl/inc/threadex.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/threadex.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/threadex.hxx	19 Sep 2000 10:23:07 -0000	1.1.1.1
+++ vcl/inc/threadex.hxx	7 Jan 2004 09:24:56 -0000	1.2
@@ -74,7 +74,7 @@ namespace vcl
 		static void SAL_CALL worker( void* );
 	public:
 		ThreadExecutor();
-		~ThreadExecutor();
+		virtual ~ThreadExecutor();
 
 		virtual long doIt() = 0;
 		long execute();
@@ -88,7 +88,7 @@ namespace vcl
 		DECL_LINK( worker, void* );
 	public:
 		SolarThreadExecutor();
-		~SolarThreadExecutor();
+		virtual ~SolarThreadExecutor();
 
 		virtual long doIt() = 0;
 		long execute();
Index: vcl/inc/timer.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/timer.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/timer.hxx	19 Sep 2000 10:23:07 -0000	1.1.1.1
+++ vcl/inc/timer.hxx	7 Jan 2004 09:25:18 -0000	1.2
@@ -89,7 +89,7 @@ protected:
 public:
                     Timer();
                     Timer( const Timer& rTimer );
-                    ~Timer();
+	virtual			~Timer();
 
     virtual void    Timeout();
 
Index: vcl/inc/toolbox.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/toolbox.hxx,v
retrieving revision 1.24
retrieving revision 1.26
diff -u -p -u -r1.24 -r1.26
--- vcl/inc/toolbox.hxx	17 Apr 2003 15:17:11 -0000	1.24
+++ vcl/inc/toolbox.hxx	20 Jan 2004 11:55:53 -0000	1.26
@@ -202,7 +201,6 @@ private:
     Rectangle           maPaintRect;
     FloatingWindow*     mpFloatWin;
     USHORT              mnKeyModifier;
-	USHORT				mnDummy2;
     long                mnDX;
     long                mnDY;
     long                mnItemWidth;
@@ -250,10 +248,9 @@ private:
                         mbDragging:1,
                         mbHideStatusText:1,
                         mbMenuStrings:1,
-                        mbDummy1_Shift:1,
-                        mbDummy2_KeyEvt:1,
-                        mbDummy3_ChangingHighlight:1,
-                        mbDummy4:1;
+                        mbIsShift:1,
+                        mbIsKeyEvent:1,
+                        mbChangingHighlight:1;
     WindowAlign         meAlign;
     WindowAlign         meDockAlign;
     ButtonType          meButtonType;
@@ -267,8 +264,6 @@ private:
     Link                maSelectHdl;
     Link                maNextToolBoxHdl;
 
-#if _SOLAR__PRIVATE
-#ifdef _SV_TOOLBOX_CXX
     void                ImplInit( Window* pParent, WinBits nStyle );
     void                ImplInitSettings( BOOL bFont, BOOL bForeground, BOOL bBackground );
     void                ImplLoadRes( const ResId& rResId );
@@ -298,12 +293,16 @@ private:
 	void				ImplUpdateInputEnable();
     void				ImplFillLayoutData() const;
                         DECL_LINK( ImplUpdateHdl, void* );
-#endif
+
+#if _SOLAR__PRIVATE
 public:
     void                ImplFloatControl( BOOL bStart, FloatingWindow* pWindow = NULL );
 	void				ImplDisableFlatButtons();
 #endif
 
+protected: 
+    void                SetCurItemId(USHORT nSet) { mnCurItemId = nSet; }
+
 public:
                         ToolBox( Window* pParent, WinBits nStyle = 0 );
                         ToolBox( Window* pParent, const ResId& rResId );
@@ -510,9 +509,9 @@ public:
     void                GetAccessObject( AccessObjectRef& rAcc ) const;
 
     // allow Click Handler to detect special key
-    BOOL                IsShift() const { return mbDummy1_Shift; }
+    BOOL                IsShift() const { return mbIsShift; }
     // allow Click Handler to distinguish between mouse and key input
-    BOOL                IsKeyEvent() const { return mbDummy2_KeyEvt; }
+    BOOL                IsKeyEvent() const { return mbIsKeyEvent; }
 
     // accessibility helpers
 
Index: vcl/inc/unobrok.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/unobrok.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/unobrok.hxx	19 Sep 2000 10:23:07 -0000	1.1.1.1
+++ vcl/inc/unobrok.hxx	1 Dec 2003 13:02:17 -0000	1.2
@@ -62,62 +62,8 @@
 #ifndef _UNOBROK_HXX
 #define _UNOBROK_HXX
 
-#include "rvp.hxx"
-
 #include <svdata.hxx>
 #include <vos/thread.hxx>
-
-//  #include <com/sun/star/connection/XAcceptor.hpp>
-
-//  class UnoBrokerThread : public ::vos::OThread
-//  {
-//  public:
-
-//  	UnoBrokerThread(
-//  		const ::com::sun::star::uno::Reference<
-//  		      ::com::sun::star::lang::XMultiServiceFactory > &rSMgr,
-//  		const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > &rInitialObject );
-
-//  	~UnoBrokerThread();
-//  protected:
-	
-//  	virtual void SAL_CALL run();
-//  	virtual void SAL_CALL onTerminated();
-
-//  private:
-
-//  	::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > m_rSMgr;
-//  	::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > m_rInitialObject;
-//  };
-
-
-//  /*****************
-//   * This thread is used, when application is started as appserver
-//   * Note : No security is checked, every user may connect to the application !
-//   *****************/
-//  class vcl_AcceptorThread : public ::vos::OThread
-//  {
-//  public:
-
-//  	vcl_AcceptorThread(
-//  		const ::com::sun::star::uno::Reference<
-//  		      ::com::sun::star::lang::XMultiServiceFactory > &rSMgr,
-//  		const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > &rInitialObject,
-//  		const ::rtl::OUString &sAcceptorParameter);
-
-//  protected:
-	
-//  	virtual void SAL_CALL run();
-//  	virtual void SAL_CALL onTerminated();
-
-//  	virtual void SAL_CALL terminate();
-//  private:
-
-//  	::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > m_rSMgr;
-//  	::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > m_rInitialObject;
-//  	::com::sun::star::uno::Reference< ::com::sun::star::connection::XAcceptor  > m_rAcceptor;
-//  	::rtl::OUString m_sAcceptorDescription;
-//  };
 
 namespace vcl_accept
 {
Index: vcl/inc/unohelp2.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/unohelp2.hxx,v
retrieving revision 1.1
retrieving revision 1.2
diff -u -p -u -r1.1 -r1.2
--- vcl/inc/unohelp2.hxx	18 Mar 2002 17:34:51 -0000	1.1
+++ vcl/inc/unohelp2.hxx	7 Jan 2004 09:25:54 -0000	1.2
@@ -74,6 +74,9 @@
 #include <tools/string.hxx>
 #endif
 
+#ifndef _OSL_MUTEX_HXX_
+#include <osl/mutex.hxx>
+#endif
 
 namespace vcl { namespace unohelper {
 
@@ -98,6 +101,14 @@ namespace vcl { namespace unohelper {
 		::com::sun::star::uno::Any SAL_CALL getTransferData( const ::com::sun::star::datatransfer::DataFlavor& aFlavor ) throw(::com::sun::star::datatransfer::UnsupportedFlavorException, ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
 		::com::sun::star::uno::Sequence< ::com::sun::star::datatransfer::DataFlavor > SAL_CALL getTransferDataFlavors(  ) throw(::com::sun::star::uno::RuntimeException);
 		sal_Bool SAL_CALL isDataFlavorSupported( const ::com::sun::star::datatransfer::DataFlavor& aFlavor ) throw(::com::sun::star::uno::RuntimeException);
+	};
+	
+	struct MutexHelper
+	{
+	    private:
+	        ::osl::Mutex maMutex;
+	    public:
+	        ::osl::Mutex& GetMutex() { return maMutex; }
 	};
 
 }}	// namespace vcl::unohelper
Index: vcl/inc/vclevent.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/vclevent.hxx,v
retrieving revision 1.30
retrieving revision 1.31
diff -u -p -u -r1.30 -r1.31
--- vcl/inc/vclevent.hxx	12 Jun 2003 07:50:37 -0000	1.30
+++ vcl/inc/vclevent.hxx	19 May 2004 13:50:40 -0000	1.31
@@ -178,6 +178,7 @@ class Menu;
 #define VCLEVENT_TOOLBOX_ITEMENABLED        1168        // pData = itempos
 #define VCLEVENT_TOOLBOX_ITEMDISABLED       1169        // pData = itempos
 #define VCLEVENT_TABPAGE_PAGETEXTCHANGED    1170        // pData = pageid
+#define VCLEVENT_ROADMAP_ITEMSELECTED       1171
 
 // VclMenuEvent
 #define VCLEVENT_MENU_ACTIVATE              1200
@@ -203,8 +204,8 @@ class VclSimpleEvent
 {
 private:
     ULONG nId;
-    
-public:    
+
+public:
     VclSimpleEvent( ULONG n ) { nId = n; }
 	TYPEINFO();
 
@@ -216,11 +217,11 @@ class VclWindowEvent : public VclSimpleE
 private:
     Window* pWindow;
     void*   pData;
-    
-public:    
+
+public:
     VclWindowEvent( Window* pWin, ULONG n, void* pDat = NULL ) : VclSimpleEvent(n) { pWindow = pWin; pData = pDat; }
 	TYPEINFO();
-	
+
 	Window* GetWindow() const { return pWindow; }
 	void*   GetData() const { return pData; }
 };
@@ -230,11 +231,11 @@ class VclMouseEvent : public VclWindowEv
 {
 private:
     MouseEvent aEvent;
-    
-public:    
+
+public:
     VclMouseEvent( Window* pWin, ULONG n, const MouseEvent& rEvent ) : VclWindowEvent( pWin, n ), aEvent(rEvent) { ; }
 	TYPEINFO();
-	
+
 	const MouseEvent& GetEvent() const { return aEvent; }
 };
 */
@@ -244,11 +245,11 @@ class VclMenuEvent : public VclSimpleEve
 private:
     Menu* pMenu;
     USHORT mnPos;
-    
-public:    
+
+public:
     VclMenuEvent( Menu* pM, ULONG n, USHORT nPos ) : VclSimpleEvent(n) { pMenu = pM; mnPos = nPos; }
 	TYPEINFO();
-	
+
 	Menu* GetMenu() const { return pMenu; }
     USHORT GetItemPos() const { return mnPos; }
 };
@@ -261,7 +262,7 @@ public:
 
     // stops notifying when any handler has processed the event
     // and returns TRUE in that case
-    // a handler must return TRUE to signal that it has processed the event 
+    // a handler must return TRUE to signal that it has processed the event
     BOOL Process( VclSimpleEvent* pEvent ) const;
 };
 
Index: vcl/inc/virdev.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/virdev.hxx,v
retrieving revision 1.3
retrieving revision 1.7
diff -u -p -u -r1.3 -r1.7
--- vcl/inc/virdev.hxx	1 Apr 2003 09:43:53 -0000	1.3
+++ vcl/inc/virdev.hxx	7 Jan 2004 09:26:54 -0000	1.7
@@ -78,40 +78,52 @@ class RmVirtualDevice;
 
 class VirtualDevice : public OutputDevice
 {
-private:
+	friend class Application;
+	friend class OutputDevice;
 
-#ifndef REMOTE_APPSERVER
+private:
 	SalVirtualDevice*	mpVirDev;
-#else
-	RmVirtualDevice*	mpVirDev;
-#endif
 	VirtualDevice*		mpPrev;
 	VirtualDevice*		mpNext;
 	USHORT				mnBitCount;
 	BOOL				mbScreenComp;
-	BOOL				mbDummyAlign;
+	sal_Int8			mnAlphaDepth;
+	BYTE				meRefDevMode;
 
-#if _SOLAR__PRIVATE
-	friend class Application;
-	friend class OutputDevice;
-#ifdef _SV_VIRDEV_CXX
 	void				ImplInitVirDev( const OutputDevice* pOutDev, long nDX, long nDY, USHORT nBitCount );
-#endif
-#ifdef REMOTE_APPSERVER
-	RmVirtualDevice*	ImplGetRemoteVirDev() const { return mpVirDev; }
-#endif
-#endif
+	BOOL				ImplSetOutputSizePixel( const Size& rNewSize, BOOL bErase );
 
 public:
 						VirtualDevice( USHORT nBitCount = 0 );
 						VirtualDevice( const OutputDevice& rCompDev,
 									   USHORT nBitCount = 0 );
+    /** Create a virtual device with alpha channel
+        
+    	@param rCompDev
+        The generated vdev will be compatible to this device. By
+        default, Application::GetDefaultDevice() is used here.
+
+        @param nBitCount
+        Bit depth of the generated virtual device. Use 0 here, to
+        indicate: take default screen depth. Currently, only 0 and 1
+        are allowed here, with 1 denoting binary mask.
+
+        @param nAlphaBitCount
+        Bit depth of the generated virtual device. Use 0 here, to
+        indicate: take default screen depth. Currently, only 0 and 1
+        are allowed here, with 1 denoting binary mask.
+     */
+						VirtualDevice( const OutputDevice& rCompDev,
+									   USHORT nBitCount, USHORT nAlphaBitCount );
 	virtual 			~VirtualDevice();
 
-    void                SetReferenceDevice();
 	BOOL				SetOutputSizePixel( const Size& rNewSize, BOOL bErase = TRUE );
 	BOOL				SetOutputSize( const Size& rNewSize, BOOL bErase = TRUE )
 							{ return SetOutputSizePixel( LogicToPixel( rNewSize ), bErase ); }
+
+    // reference device modes for different compatibility levels
+    enum RefDevMode { REFDEV_NONE=0, REFDEV_MODE06, REFDEV_MODE48, REFDEV_MODE96 };
+    void                SetReferenceDevice( RefDevMode eMode = VirtualDevice::REFDEV_MODE06 );
 };
 
 #endif // _SV_VIRDEV_HXX
Index: vcl/inc/wall.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/wall.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/inc/wall.hxx	19 Sep 2000 10:23:08 -0000	1.1.1.1
+++ vcl/inc/wall.hxx	7 Jan 2004 09:27:34 -0000	1.2
@@ -65,13 +65,14 @@
 #ifndef _SV_SV_H
 #include <sv.h>
 #endif
-#ifndef _SV_COLOR_HXX
-#include <color.hxx>
+#ifndef _TOOLS_COLOR_HXX
+#include <tools/color.hxx>
 #endif
 
 class Rectangle;
 class Gradient;
 class BitmapEx;
+class ImplWallpaper;
 
 // -------------------
 // - Wallpaper-Types -
@@ -113,40 +114,6 @@ enum WallpaperStyle 
 
 #endif
 
-// -----------------
-// - ImplWallpaper -
-// -----------------
-
-class SvStream;
-
-class ImplWallpaper
-{
-	friend class Wallpaper;
-
-private:
-	Color			maColor;
-	BitmapEx*		mpBitmap;
-	Gradient*		mpGradient;
-	Rectangle*		mpRect;
-	WallpaperStyle	meStyle;
-	USHORT			mnRefCount;
-	BitmapEx*		mpCache;
-
-	friend SvStream& operator>>( SvStream& rIStm, ImplWallpaper& rImplWallpaper );
-	friend SvStream& operator<<( SvStream& rOStm, const ImplWallpaper& rImplWallpaper );
-
-#ifdef _SV_WALL_CXX
-public:
-					ImplWallpaper();
-					ImplWallpaper( const ImplWallpaper& rImplWallpaper );
-					~ImplWallpaper();
-
-	void			ImplSetCachedBitmap( BitmapEx& rBmp );
-	const BitmapEx*	ImplGetCachedBitmap() { return mpCache; }
-	void			ImplReleaseCachedBitmap();
-#endif
-};
-
 // -------------
 // - Wallpaper -
 // -------------
@@ -156,8 +123,9 @@ class Wallpaper
 private:
 	ImplWallpaper*	mpImplWallpaper;
 
-#ifdef _SV_WALL_CXX
 	void			ImplMakeUnique( BOOL bReleaseCache = TRUE );
+
+#if _SOLAR__PRIVATE
 public:
 	ImplWallpaper*	ImplGetImpWallpaper() const { return mpImplWallpaper; }
 #endif
@@ -171,25 +139,25 @@ public:
 					~Wallpaper();
 
 	void			SetColor( const Color& rColor );
-	const Color&	GetColor() const { return mpImplWallpaper->maColor; }
+	const Color&	GetColor() const;
 
 	void			SetStyle( WallpaperStyle eStyle );
-	WallpaperStyle	GetStyle() const { return mpImplWallpaper->meStyle; }
+	WallpaperStyle	GetStyle() const;
 
 	void			SetBitmap( const BitmapEx& rBitmap );
 	void			SetBitmap();
 	BitmapEx		GetBitmap() const;
-	BOOL			IsBitmap() const { return (mpImplWallpaper->mpBitmap != 0); }
+	BOOL			IsBitmap() const;
 
 	void			SetGradient( const Gradient& rGradient );
 	void			SetGradient();
 	Gradient		GetGradient() const;
-	BOOL			IsGradient() const { return (mpImplWallpaper->mpGradient != 0); }
+	BOOL			IsGradient() const;
 
 	void			SetRect( const Rectangle& rRect );
 	void			SetRect();
 	Rectangle		GetRect() const;
-	BOOL			IsRect() const { return (mpImplWallpaper->mpRect != 0); }
+	BOOL			IsRect() const;
 
 	BOOL			IsFixed() const;
 	BOOL			IsScrollable() const;
Index: vcl/inc/wall2.hxx
===================================================================
RCS file: vcl/inc/wall2.hxx
diff -N vcl/inc/wall2.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/inc/wall2.hxx	7 Jan 2004 09:27:49 -0000	1.2
@@ -0,0 +1,96 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_WALL2_HXX
+#define _SV_WALL2_HXX
+
+#ifndef _SV_WALL_HXX
+#include <wall.hxx>
+#endif
+
+class ImplWallpaper
+{
+	friend class Wallpaper;
+
+private:
+	Color			maColor;
+	BitmapEx*		mpBitmap;
+	Gradient*		mpGradient;
+	Rectangle*		mpRect;
+	WallpaperStyle	meStyle;
+	USHORT			mnRefCount;
+	BitmapEx*		mpCache;
+
+	friend SvStream& operator>>( SvStream& rIStm, ImplWallpaper& rImplWallpaper );
+	friend SvStream& operator<<( SvStream& rOStm, const ImplWallpaper& rImplWallpaper );
+
+public:
+					ImplWallpaper();
+					ImplWallpaper( const ImplWallpaper& rImplWallpaper );
+					~ImplWallpaper();
+
+	void			ImplSetCachedBitmap( BitmapEx& rBmp );
+	const BitmapEx*	ImplGetCachedBitmap() { return mpCache; }
+	void			ImplReleaseCachedBitmap();
+};
+
+
+#endif	// _SV_WALL2_HXX
Index: vcl/inc/windata.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/windata.hxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/inc/windata.hxx	27 Jun 2001 08:23:42 -0000	1.2
+++ vcl/inc/windata.hxx	1 Dec 2003 13:02:52 -0000	1.3
@@ -72,15 +72,7 @@ class SalFrame;
 // - Prototypes -
 // --------------
 
-#ifndef REMOTE_APPSERVER
-	long ImplWindowFrameProc( void* pInst, SalFrame* pFrame,
-                          		USHORT nEvent, const void* pEvent );
-#else
-	class ExtRmEvent;
-    class Window;
-	void ImplRemoteWindowFrameProc( ExtRmEvent* pEvent );
-    void ImplUpdateCursorRect( Window *pWindow );
-#endif
+long ImplWindowFrameProc( void* pInst, SalFrame* pFrame, USHORT nEvent, const void* pEvent );
 
 // -----------
 // - HitTest -
Index: vcl/inc/window.h
===================================================================
RCS file: /cvs/gsl/vcl/inc/window.h,v
retrieving revision 1.11.136.1
retrieving revision 1.15
diff -u -p -u -r1.11.136.1 -r1.15
--- vcl/inc/window.h	9 Jan 2004 18:13:41 -0000	1.11.136.1
+++ vcl/inc/window.h	17 Jun 2004 12:10:38 -0000	1.15
@@ -86,6 +86,7 @@ class VirtualDevice;
 struct SalPaintEvent;
 class ImplDevFontList;
 class ImplFontCache;
+class SalControlHandle;
 
 namespace com {
 namespace sun {
@@ -113,6 +114,10 @@ struct ImplWinData
     Rectangle*          mpFocusRect;
     Rectangle*          mpTrackRect;
     USHORT              mnTrackFlags;
+    USHORT				mnIsTopWindow;
+    BOOL                mbMouseOver;          // tracks mouse over for native widget paint effect
+    SalControlHandle*   mpSalControlHandle;   // native data for NWF
+    BOOL                mbEnableNativeWidget; // toggle native widget rendering
 };
 
 // -------------------
@@ -145,16 +150,18 @@ struct ImplFrameData
     Window*             mpFirstBackWin;     // Erstes Overlap-Window mit Hintergrund-Sicherung
     ImplDevFontList*    mpFontList;         // Font-List for this frame
     ImplFontCache*      mpFontCache;        // Font-Cache for this frame
-    long                mnDPIX;             // Original Screen Resolution
-    long                mnDPIY;             // Original Screen Resolution
-    long                mnFontDPIX;         // Original Font Resolution
-    long                mnFontDPIY;         // Original Font Resolution
+    sal_Int32           mnDPIX;             // Original Screen Resolution
+    sal_Int32           mnDPIY;             // Original Screen Resolution
+    sal_Int32           mnFontDPIX;         // Original Font Resolution
+    sal_Int32           mnFontDPIY;         // Original Font Resolution
     ImplMapRes          maMapUnitRes;       // for LogicUnitToPixel
     ULONG               mnAllSaveBackSize;  // Groesse aller Bitmaps fuer Hintergrund-Sicherung
     ULONG               mnFocusId;          // FocusId for PostUserLink
     ULONG               mnMouseMoveId;      // MoveId for PostUserLink
     long                mnLastMouseX;       // last x mouse position
     long                mnLastMouseY;       // last y mouse position
+    long                mnBeforeLastMouseX; // last but one x mouse position
+    long                mnBeforeLastMouseY; // last but one y mouse position
     long                mnFirstMouseX;      // first x mouse position by mousebuttondown
     long                mnFirstMouseY;      // first y mouse position by mousebuttondown
     long                mnLastMouseWinX;    // last x mouse position, rel. to pMouseMoveWin
Index: vcl/inc/window.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/window.hxx,v
retrieving revision 1.47.112.1
retrieving revision 1.55
diff -u -p -u -r1.47.112.1 -r1.55
--- vcl/inc/window.hxx	26 Jan 2004 17:20:36 -0000	1.47.112.1
+++ vcl/inc/window.hxx	17 Jun 2004 12:10:54 -0000	1.55
@@ -68,8 +68,8 @@
 #ifndef _SV_OUTDEV_HXX
 #include <outdev.hxx>
 #endif
-#ifndef _SV_RESID_HXX
-#include <resid.hxx>
+#ifndef _TOOLS_RESID_HXX
+#include <tools/resid.hxx>
 #endif
 #ifndef _SV_POINTR_HXX
 #include <pointr.hxx>
@@ -91,12 +91,20 @@
 #include <event.hxx>
 #endif
 
-#ifndef _COM_SUN_STAR_UNO_REFERENCE_HXX_
-#include <com/sun/star/uno/Reference.hxx>
+#ifndef _SV_REGION_HXX
+#include <region.hxx>
+#endif
+
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
 #endif
 
-#ifdef REMOTE_APPSERVER
-#include "rvp.hxx"
+#ifndef _COM_SUN_STAR_UNO_REFERENCE_HXX_
+#include <com/sun/star/uno/Reference.hxx>
 #endif
 
 class VirtualDevice;
@@ -144,6 +151,7 @@ namespace sun {
 namespace star {
 namespace awt {
     class XWindowPeer;
+       class XWindow;
 }
 namespace uno {
     class Any;
@@ -335,26 +351,55 @@ typedef USHORT StateChangedType;
 #define EXTTEXTINPUT_END_COMPLETE       ((USHORT)0x0001)
 #define EXTTEXTINPUT_END_CANCEL         ((USHORT)0x0002)
 
+#if _SOLAR__PRIVATE
+#define IMPL_MINSIZE_BUTTON_WIDTH       70
+#define IMPL_MINSIZE_BUTTON_HEIGHT      22
+#define IMPL_EXTRA_BUTTON_WIDTH         18
+#define IMPL_EXTRA_BUTTON_HEIGHT        10
+#define IMPL_SEP_BUTTON_X               5
+#define IMPL_SEP_BUTTON_Y               5
+#define IMPL_MINSIZE_MSGBOX_WIDTH       150
+#define IMPL_MINSIZE_MSGBOX_HEIGHT      80
+#define IMPL_DIALOG_OFFSET              5
+#define IMPL_DIALOG_BAR_OFFSET          3
+#define IMPL_MSGBOX_OFFSET_EXTRA_X      0
+#define IMPL_MSGBOX_OFFSET_EXTRA_Y      2
+#define IMPL_SEP_MSGBOX_IMAGE           8
+#define IMPL_SEP_BUTTON_IMAGE           4
+
+#define DLGWINDOW_PREV                  0
+#define DLGWINDOW_NEXT                  1
+#define DLGWINDOW_FIRST                 2
+#endif
+
 // ----------
 // - Window -
 // ----------
 
 class Window : public OutputDevice
 {
+    friend class Cursor;
+    friend class OutputDevice;
+    friend class Application;
+    friend class SystemWindow;
+    friend class WorkWindow;
+    friend class Dialog;
+    friend class MessBox;
+    friend class DockingWindow;
+    friend class FloatingWindow;
+    friend class GroupBox;
+    friend class PushButton;
+    friend class RadioButton;
+    friend class SystemChildWindow;
+    friend class ImplBorderWindow;
+
 private:
     ImplWinData*        mpWinData;
     ImplOverlapData*    mpOverlapData;
     ImplFrameData*      mpFrameData;
-#ifndef REMOTE_APPSERVER
     SalFrame*           mpFrame;
     SalObject*          mpSysObj;
     void*               mpRmEvents;
-#else
-    friend class ExtRmEvent;
-    RmFrameWindow*      mpFrame;
-    void*               mpSysObj;
-    ExtRmEvent*         mpRmEvents;
-#endif
     Window*             mpFrameWindow;
     Window*             mpOverlapWindow;
     Window*             mpBorderWindow;
@@ -385,14 +433,13 @@ private:
     Font*               mpControlFont;
     Color               maControlForeground;
     Color               maControlBackground;
-    long                mnLeftBorder;
-    long                mnTopBorder;
-    long                mnRightBorder;
-    long                mnBottomBorder;
+    sal_Int32           mnLeftBorder;
+    sal_Int32           mnTopBorder;
+    sal_Int32           mnRightBorder;
+    sal_Int32           mnBottomBorder;
     long                mnX;
     long                mnY;
     long                mnAbsScreenX;
-    long                mnDummy2;
     Point               maPos;
     ULONG               mnHelpId;
     ULONG               mnUniqId;
@@ -413,8 +460,6 @@ private:
     WinBits             mnExtendedStyle;
     WinBits             mnPrevExtendedStyle;
     WindowType          mnType;
-    LanguageType        meDummy1;
-    CharSet             meDummy2;
     USHORT              mnWaitCount;
     USHORT              mnPaintFlags;
     USHORT              mnGetFocusFlags;
@@ -422,8 +467,6 @@ private:
     USHORT              mnActivateMode;
     USHORT              mnDlgCtrlFlags;
     USHORT              mnLockCount;
-    USHORT              mnDummy3;
-    USHORT              mnIsTopWindow;
     BOOL                mbFrame:1,
                         mbBorderWin:1,
                         mbOverlapWin:1,
@@ -490,9 +533,176 @@ private:
                         mbDrawSelectionBackground:1;
 
     ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > mxDNDListenerContainer;
+    void                ImplInitData( WindowType nType );
+
 
 #if _SOLAR__PRIVATE
-#include <window.imp>
+
+#ifdef DBG_UTIL
+    friend const char* ImplDbgCheckWindow( const void* pObj );
+#endif
+
+public:
+    void                ImplInit( Window* pParent, WinBits nStyle, SystemParentData* pSystemParentData );
+    void                ImplInit( Window* pParent, WinBits nStyle, const ::com::sun::star::uno::Any& aSystemWorkWindowToken );
+    WinBits             ImplInitRes( const ResId& rResId );
+    void                ImplLoadRes( const ResId& rResId );
+    void                ImplWindowRes( const ResId& rResId );
+    void				ImplSetFrameParent( const Window* pParent );
+    void                ImplInsertWindow( Window* pParent );
+    void                ImplRemoveWindow( BOOL bRemoveFrameData );
+    Window*             ImplGetWindow() { if ( mpClientWindow ) return mpClientWindow; else return this; }
+    ImplFrameData*      ImplGetFrameData() { return mpFrameData; }
+    SalFrame*           ImplGetFrame() const { return mpFrame; }
+    ImplWinData*        ImplGetWinData() const;
+    SalGraphics*        ImplGetFrameGraphics() const;
+    void                ImplCallFocusChangeActivate( Window* pNewOverlapWindow, Window* pOldOverlapWindow );
+    Window*             ImplFindWindow( const Point& rFramePos );
+    USHORT              ImplHitTest( const Point& rFramePos );
+    Window*             ImplGetParent() const { return mpParent; }
+    Window*             ImplGetClientWindow() const { return mpClientWindow; }
+    Window*             ImplGetBorderWindow() const { return mpBorderWindow; }
+    Window*             ImplGetFirstOverlapWindow() { if ( mbOverlapWin ) return this; else return mpOverlapWindow; }
+    const Window*       ImplGetFirstOverlapWindow() const { if ( mbOverlapWin ) return this; else return mpOverlapWindow; }
+    Window*             ImplGetFrameWindow() const { return mpFrameWindow; }
+    BOOL                ImplIsRealParentPath( const Window* pWindow ) const;
+    BOOL                ImplIsChild( const Window* pWindow, BOOL bSystemWindow = FALSE ) const;
+    BOOL                ImplIsWindowOrChild( const Window* pWindow, BOOL bSystemWindow = FALSE ) const;
+    Window*             ImplGetSameParent( const Window* pWindow ) const;
+    BOOL                ImplIsDockingWindow() const { return mbDockWin; }
+    BOOL                ImplIsFloatingWindow() const { return mbFloatWin; }
+    BOOL                ImplIsToolbox() const { return mbToolBox; }
+    BOOL                ImplIsSplitter() const { return mbSplitter; }
+    BOOL                ImplIsPushButton() const { return mbPushButton; }
+    BOOL                ImplIsOverlapWindow() const { return mbOverlapWin; }
+    void                ImplSetActive( BOOL bActive ) { mbActive = bActive; }
+    BOOL                ImplIsMouseTransparent() const { return mbMouseTransparent; }
+    void                ImplSetMouseTransparent( BOOL bTransparent ) { mbMouseTransparent = bTransparent; }
+    int                 ImplTestMousePointerSet();
+    PointerStyle        ImplGetMousePointer() const;
+    void                ImplResetReallyVisible();
+    void                ImplSetReallyVisible();
+    void                ImplCallInitShow();
+    void                ImplAddDel( ImplDelData* pDel );
+    void                ImplRemoveDel( ImplDelData* pDel );
+    void                ImplInitResolutionSettings();
+    void                ImplPointToLogic( Font& rFont ) const;
+    void                ImplLogicToPoint( Font& rFont ) const;
+    Point               ImplOutputToFrame( const Point& rPos )
+                            { return Point( rPos.X()+mnOutOffX, rPos.Y()+mnOutOffY ); }
+    Point               ImplFrameToOutput( const Point& rPos )
+                            { return Point( rPos.X()-mnOutOffX, rPos.Y()-mnOutOffY ); }
+    void                ImplOutputToFrame( Rectangle& rRect )
+                            { rRect.Left()+=mnOutOffX; rRect.Top()+=mnOutOffY;
+                              rRect.Right()+=mnOutOffX; rRect.Bottom()+=mnOutOffY; }
+    void                ImplFrameToOutput( Rectangle& rRect )
+                            { rRect.Left()-=mnOutOffX; rRect.Top()-=mnOutOffY;
+                              rRect.Right()-=mnOutOffX; rRect.Bottom()-=mnOutOffY; }
+    BOOL                ImplSysObjClip( const Region* pOldRegion );
+    void                ImplUpdateSysObjChildsClip();
+    void                ImplUpdateSysObjOverlapsClip();
+    void                ImplUpdateSysObjClip();
+    BOOL                ImplSetClipFlagChilds( BOOL bSysObjOnlySmaller = FALSE );
+    BOOL                ImplSetClipFlagOverlapWindows( BOOL bSysObjOnlySmaller = FALSE );
+    BOOL                ImplSetClipFlag( BOOL bSysObjOnlySmaller = FALSE );
+    void                ImplIntersectWindowClipRegion( Region& rRegion );
+    void                ImplIntersectWindowRegion( Region& rRegion );
+    void                ImplExcludeWindowRegion( Region& rRegion );
+    void                ImplExcludeOverlapWindows( Region& rRegion );
+    void                ImplExcludeOverlapWindows2( Region& rRegion );
+    void                ImplClipBoundaries( Region& rRegion, BOOL bThis, BOOL bOverlaps );
+    BOOL                ImplClipChilds( Region& rRegion );
+    void                ImplClipAllChilds( Region& rRegion );
+    void                ImplClipSiblings( Region& rRegion );
+    void                ImplInitWinClipRegion();
+    void                ImplInitWinChildClipRegion();
+    Region*             ImplGetWinChildClipRegion();
+    void                ImplIntersectAndUnionOverlapWindows( const Region& rInterRegion, Region& rRegion );
+    void                ImplIntersectAndUnionOverlapWindows2( const Region& rInterRegion, Region& rRegion );
+    void                ImplCalcOverlapRegionOverlaps( const Region& rInterRegion, Region& rRegion );
+    void                ImplCalcOverlapRegion( const Rectangle& rSourceRect, Region& rRegion,
+                                               BOOL bChilds, BOOL bParent, BOOL bSiblings );
+    void                ImplCallPaint( const Region* pRegion, USHORT nPaintFlags );
+    void                ImplCallOverlapPaint();
+    void                ImplPostPaint();
+    void                ImplInvalidateFrameRegion( const Region* pRegion, USHORT nFlags );
+    void                ImplInvalidateOverlapFrameRegion( const Region& rRegion );
+    void                ImplInvalidateParentFrameRegion( Region& rRegion );
+    void                ImplInvalidate( const Region* rRegion, USHORT nFlags );
+    void                ImplValidateFrameRegion( const Region* rRegion, USHORT nFlags );
+    void                ImplValidate( const Region* rRegion, USHORT nFlags );
+    void                ImplMoveInvalidateRegion( const Rectangle& rRect, long nHorzScroll, long nVertScroll, BOOL bChilds );
+    void                ImplMoveAllInvalidateRegions( const Rectangle& rRect, long nHorzScroll, long nVertScroll, BOOL bChilds );
+    void                ImplScroll( const Rectangle& rRect, long nHorzScroll, long nVertScroll, USHORT nFlags );
+    void                ImplUpdateAll( BOOL bOverlapWindows = TRUE );
+    void                ImplUpdateWindowPtr( Window* pWindow );
+    void                ImplUpdateWindowPtr();
+    void                ImplUpdateOverlapWindowPtr( BOOL bNewFrame );
+    BOOL                ImplUpdatePos();
+    void                ImplUpdateSysObjPos();
+    void                ImplUpdateGlobalSettings( AllSettings& rSettings, BOOL bCallHdl = TRUE );
+    void                ImplAlignChilds();
+    void                ImplPosSizeWindow( long nX, long nY, long nWidth, long nHeight, USHORT nFlags );
+    void                ImplToBottomChild();
+    void                ImplCalcToTop( ImplCalcToTopData* pPrevData );
+    void                ImplCalcChildOverlapToTop( ImplCalcToTopData* pPrevData );
+    void                ImplToTop( USHORT nFlags );
+    void                ImplStartToTop( USHORT nFlags );
+    void                ImplFocusToTop( USHORT nFlags, BOOL bReallyVisible );
+    void                ImplShowAllOverlaps();
+    void                ImplHideAllOverlaps();
+    void                ImplNotifyKeyMouseCommandEventListeners( NotifyEvent& rNEvt );
+    void                ImplCallMouseMove( USHORT nMouseCode, BOOL bModChanged = FALSE );
+    void                ImplGenerateMouseMove();
+    void                ImplGrabFocus( USHORT nFlags );
+    void                ImplInvertFocus( const Rectangle& rRect );
+    void                ImplControlFocus( USHORT nFlags = 0 );
+    Window*             ImplGetDlgWindow( USHORT n, USHORT nType, USHORT nStart = 0, USHORT nEnd = 0xFFFF, USHORT* pIndex = NULL );
+    BOOL                ImplDlgCtrl( const KeyEvent& rKEvt, BOOL bKeyInput );
+    BOOL                ImplHasDlgCtrl();
+    void                ImplDlgCtrlNextWindow();
+    void                ImplDlgCtrlFocusChanged( Window* pWindow, BOOL bGetFocus );
+    Window*             ImplFindDlgCtrlWindow( Window* pWindow );
+    long                ImplLogicUnitToPixelX( long nX, MapUnit eUnit );
+    long                ImplLogicUnitToPixelY( long nY, MapUnit eUnit );
+    BOOL                ImplIsWindowInFront( const Window* pTestWindow ) const;
+    void                ImplSaveOverlapBackground();
+    BOOL                ImplRestoreOverlapBackground( Region& rInvRegion );
+    void                ImplDeleteOverlapBackground();
+    void                ImplInvalidateAllOverlapBackgrounds();
+    static void         ImplNewInputContext();
+    void                ImplCallActivateListeners(Window*);
+    void                ImplCallDeactivateListeners(Window*);
+                        DECL_LINK( ImplHandlePaintHdl, void* );
+                        DECL_LINK( ImplGenerateMouseMoveHdl, void* );
+                        DECL_LINK( ImplTrackTimerHdl, Timer* );
+                        DECL_LINK( ImplAsyncFocusHdl, void* );
+                        DECL_LINK( ImplAsyncStateChangedHdl, void* );
+
+    static void         ImplCalcSymbolRect( Rectangle& rRect );
+    void                ImplHandleScroll( ScrollBar* pHScrl, long nX, ScrollBar* pVScrl, long nY );
+    BOOL                ImplGetCurrentBackgroundColor( Color& rCol );
+    BOOL                ImplIsAccessibleCandidate() const;
+    BOOL                ImplIsAccessibleNativeFrame() const;
+    USHORT              ImplGetAccessibleCandidateChildWindowCount( USHORT nFirstWindowType ) const;
+    Window*             ImplGetAccessibleCandidateChild( USHORT nChild, USHORT& rChildCount, USHORT nFirstWindowType, BOOL bTopLevel = TRUE ) const;
+    BOOL                ImplRegisterAccessibleNativeFrame();
+    void                ImplRevokeAccessibleNativeFrame();
+    void                ImplCallResize();
+    void                ImplCallMove();
+    Rectangle           ImplOutputToUnmirroredAbsoluteScreenPixel( const Rectangle& rRect ) const;
+    void                ImplMirrorFramePos( Point &pt ) const;
+    long                ImplGetUnmirroredOutOffX();
+    void                ImplIncModalCount();
+    void                ImplDecModalCount();
+
+    Rectangle           ImplGetWindowExtentsRelative( Window *pRelativeWindow, BOOL bClientOnly );
+    void                ImplNotifyIconifiedState( BOOL bIconified );
+    bool				ImplStopDnd();
+    void				ImplStartDnd();
+
+    static void			ImplInitAppFontData( Window* pWindow );
+    void                ImplInitSalControlHandle();
 #endif
 
 protected:
@@ -573,8 +783,8 @@ public:
 
     void                SetBorderStyle( USHORT nBorderStyle );
     USHORT              GetBorderStyle() const;
-    void                GetBorder( long& rLeftBorder, long& rTopBorder,
-                                   long& rRightBorder, long& rBottomBorder ) const;
+    void                GetBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+                                   sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const;
     Size                CalcWindowSize( const Size& rOutSz ) const;
     Size                CalcOutputSize( const Size& rWinSz ) const;
     long                CalcTitleWidth() const;
@@ -594,6 +804,8 @@ public:
     void                SetDialogControlFlags( USHORT nFlags ) { mnDlgCtrlFlags = nFlags; }
     USHORT              GetDialogControlFlags() const { return mnDlgCtrlFlags; }
 
+    BOOL                IsMouseOver();
+
     ULONG               GetCurrentModButtons();
 
     void                SetInputContext( const InputContext& rInputContext );
@@ -616,7 +828,7 @@ public:
     void                SetZoomedPointFont( const Font& rFont );
     long                GetDrawPixel( OutputDevice* pDev, long nPixels ) const;
     Font                GetDrawPixelFont( OutputDevice* pDev ) const;
-    void                GetFontResolution( long& nDPIX, long& nDPIY ) const;
+    void                GetFontResolution( sal_Int32& nDPIX, sal_Int32& nDPIY ) const;
 
     void                SetControlFont();
     void                SetControlFont( const Font& rFont );
@@ -641,6 +853,10 @@ public:
     Region              GetWindowClipRegionPixel( USHORT nFlags = 0 ) const;
     Region              GetPaintRegion() const;
     BOOL                IsInPaint() const { return mbInPaint; }
+    // while IsInPaint returns true ExpandPaintClipRegion adds the
+    // submitted region to the paint clip region so you can
+    // paint additional parts of your window if necessary
+    void				ExpandPaintClipRegion( const Region& rRegion );
 
     void                SetParent( Window* pNewParent );
     Window*             GetParent() const { return mpRealParent; }
@@ -687,8 +903,12 @@ public:
     BOOL                IsDefaultPos() const { return mbDefPos; }
     BOOL                IsDefaultSize() const { return mbDefSize; }
 
+    // those conversion routines might deliver different results during UI mirroring
     Point               OutputToScreenPixel( const Point& rPos ) const;
     Point               ScreenToOutputPixel( const Point& rPos ) const;
+    //  the normalized screen methods work independent from UI mirroring
+    Point               OutputToNormalizedScreenPixel( const Point& rPos ) const;
+    Point               NormalizedScreenToOutputPixel( const Point& rPos ) const;
     Point               OutputToAbsoluteScreenPixel( const Point& rPos ) const;
     Point               AbsoluteScreenToOutputPixel( const Point& rPos ) const;
     Rectangle           GetDesktopRectPixel() const;
@@ -753,6 +964,7 @@ public:
     BOOL                IsChildPointerOverwrite() const { return mbChildPtrOverwrite; }
     void                SetPointerPosPixel( const Point& rPos );
     Point               GetPointerPosPixel();
+    Point               GetLastPointerPosPixel();
     void                ShowPointer( BOOL bVisible );
     BOOL                IsPointerVisible() const { return !mbNoPtrVisible; }
     void                EnterWait();
@@ -852,11 +1060,11 @@ public:
     ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > GetAccessible( BOOL bCreate = TRUE );
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > CreateAccessible();
 	void SetAccessible( ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > );
-	
+
     Window* GetAccessibleParentWindow() const;
     USHORT  GetAccessibleChildWindowCount();
     Window* GetAccessibleChildWindow( USHORT n );
-    
+
     void    SetAccessibleRole( USHORT nRole );
     USHORT  GetAccessibleRole() const;
 
@@ -900,6 +1114,52 @@ public:
     // Clipboard/Selection interfaces
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::datatransfer::clipboard::XClipboard > GetClipboard();
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::datatransfer::clipboard::XClipboard > GetSelection();
+
+    //-------------------------------------
+    //  Native Widget Rendering functions
+    //-------------------------------------
+
+    // form controls must never use native widgets, this can be toggled here
+    void    EnableNativeWidget( BOOL bEnable = TRUE );
+    BOOL    IsNativeWidgetEnabled() const;
+
+    // These all just call through to the private mpFrame functions of the same name.
+
+    // Query the platform layer for control support
+    BOOL					IsNativeControlSupported( ControlType nType, ControlPart nPart );
+
+    // Query the native control to determine if it was acted upon
+    BOOL				HitTestNativeControl( ControlType nType,
+									  ControlPart nPart,
+									  const Region& rControlRegion,
+									  const Point& aPos,
+									  BOOL& rIsInside );
+
+    // Request rendering of a particular control and/or part
+    BOOL				DrawNativeControl(    ControlType nType,
+									  ControlPart nPart,
+									  const Region& rControlRegion,
+									  ControlState nState,
+									  const ImplControlValue& aValue,
+									  rtl::OUString aCaption );
+
+     // Request rendering of a caption string for a control
+    BOOL				DrawNativeControlText(     ControlType nType,
+										  ControlPart nPart,
+										  const Region& rControlRegion,
+										  ControlState nState,
+										  const ImplControlValue& aValue,
+										  rtl::OUString aCaption );
+
+    // Query the native control's actual drawing region (including adornment)
+    BOOL				GetNativeControlRegion(  ControlType nType,
+										  ControlPart nPart,
+										  const Region& rControlRegion,
+										  ControlState nState,
+										  const ImplControlValue& aValue,
+										  rtl::OUString aCaption,
+										  Region &rNativeBoundingRegion,
+										  Region &rNativeContentRegion );
 };
 
 inline void Window::SetPosPixel( const Point& rNewPos )
Index: vcl/inc/wintypes.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/wintypes.hxx,v
retrieving revision 1.14
retrieving revision 1.17
diff -u -p -u -r1.14 -r1.17
--- vcl/inc/wintypes.hxx	11 Apr 2003 17:27:04 -0000	1.14
+++ vcl/inc/wintypes.hxx	10 May 2004 15:44:37 -0000	1.17
@@ -154,14 +154,15 @@ typedef USHORT WindowType;
 #define WINDOW_TREELISTBOX	        (WINDOW_FIRST + 0x4d)
 #define WINDOW_HELPTEXTWINDOW		(WINDOW_FIRST + 0x4e)
 #define WINDOW_INTROWINDOW		    (WINDOW_FIRST + 0x4f)
-#define WINDOW_LAST 				(WINDOW_INTROWINDOW)
+#define WINDOW_LISTBOXWINDOW        (WINDOW_FIRST + 0x50)
+#define WINDOW_LAST 				(WINDOW_LISTBOXWINDOW)
 
 
 // ---------------
 // - Window-Bits -
 // ---------------
 
-// By changes you must also change: tools/vclrsc.hxx
+// By changes you must also change: rsc/vclrsc.hxx
 typedef sal_Int64 WinBits;
 
 // Window-Bits fuer Window
Index: vcl/inc/wrkwin.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/wrkwin.hxx,v
retrieving revision 1.7
retrieving revision 1.9
diff -u -p -u -r1.7 -r1.9
--- vcl/inc/wrkwin.hxx	11 Apr 2003 17:27:14 -0000	1.7
+++ vcl/inc/wrkwin.hxx	17 Jun 2004 11:43:45 -0000	1.9
@@ -96,20 +92,10 @@ private:
     BOOL            mbPresentationMode:1,
                     mbPresentationVisible:1,
                     mbPresentationFull:1,
-                    mbFullScreenMode:1,
-                    mbDummy0:1,
-                    mbDummy1:1,
-                    mbDummy2:1,
-                    mbDummy3:1,
-                    mbDummy4:1,
-                    mbDummy5:1,
-                    mbDummy6:1,
-                    mbDummy7:1;
+                    mbFullScreenMode:1;
 
-#ifdef _SV_WRKWIN_CXX
     void            ImplInitData();
     void            ImplInit( Window* pParent, WinBits nStyle, const ::com::sun::star::uno::Any& aSystemWorkWindowToken );
-#endif
 
 protected:
                     WorkWindow( WindowType nType );
@@ -124,6 +110,8 @@ public:
                     WorkWindow( SystemParentData* pParent ); // Not in the REMOTE-Version
                     ~WorkWindow();
 
+    virtual BOOL    Close();
+
     void            ShowFullScreenMode( BOOL bFullScreenMode = TRUE );
     void            EndFullScreenMode() { ShowFullScreenMode( FALSE ); }
     BOOL            IsFullScreenMode() const { return mbFullScreenMode; }
@@ -136,16 +124,14 @@ public:
 
     BOOL			SetPluginParent( SystemParentData* pParent );
 
-#ifndef NOOLDSV
     void            Minimize();
-    void            Maximize();
     void            Restore();
 
-    BOOL            IsMaximized() const;
 
     void            SetOptOutputSizePixel( const Size& ) {}
     Size            GetOptOutputSizePixel() const { return Size(); }
-#endif
+    void			Maximize( BOOL bMaximize = TRUE );
+    BOOL			IsMaximized();
 };
 
 #endif // _SV_WRKWIN_HXX
Index: vcl/inc/xconnection.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/xconnection.hxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/inc/xconnection.hxx	11 Sep 2001 15:52:21 -0000	1.2
+++ vcl/inc/xconnection.hxx	6 Jan 2004 13:08:25 -0000	1.3
@@ -78,7 +78,7 @@
 #include <com/sun/star/uno/Reference.hxx>
 #endif
 
-#ifndef __SGI_STL_LIST
+#ifndef _STLP_LIST
 #include <list>
 #endif
 
Index: vcl/jobs/descript.plc
===================================================================
RCS file: vcl/jobs/descript.plc
diff -N vcl/jobs/descript.plc
--- vcl/jobs/descript.plc	18 Sep 2000 17:05:32 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,7 +0,0 @@
-PROCLIST_v1.0
-..
-stgetree.pld
-`call s:\bat\descript.btm`
-..\log\descript
-; log2err.awk
-777 2 666 2 555 2 444 2 333 2 222 2 777 2 666 2 555 2 444 2 333 2 222 2 111 2
Index: vcl/jobs/l2e_sv.awk
===================================================================
RCS file: vcl/jobs/l2e_sv.awk
diff -N vcl/jobs/l2e_sv.awk
--- vcl/jobs/l2e_sv.awk	18 Sep 2000 17:05:32 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,168 +0,0 @@
-BEGIN {
-	if ( ARGC < 3)
-	{
-		printf("Syntax: awk ... LogFileIn ErrorLogOut [MscCLOOKsOut]\n")
-		exit 1
-	}
-	fout = ARGV[2]
-	if ( ARGC == 4 )
-	{
-		CLOOKsOut = ARGV[3]
-		doClooks = 1
-		ARGC -= 2
-		printf("") >CLOOKsOut
-	}
-	else
-	{
-		ARGC -= 1
-		doClooks = 0
-	}
-	err = 0
-	clook = 0
-	hzeile = ""
-	zeile1 = ""
-	zeile2 = ""
-	errhzeile = 0
-	clookhzeile = 0
-	isError = 0
-	isProduct = 0
-	printf("") >fout
-}
-
-{
-	if ( "[error log]" == $1" "$2 )
-	{
-		if ( $0 ~ /product=/ )
-		{
-			isProduct = 1
-		}
-		if ( err == 1 )
-		{
-			printf("\n\n") >>fout
-			err = 0
-		}
-		if ( clook == 1 )
-		{
-			printf("\n\n") >>CLOOKsOut
-			clook = 0
-		}
-		hzeile = $0
-		errhzeile = 0
-		clookhzeile = 0
-	}
-	else
-	{
-		if ( $0 ~ /error/ || $0 ~ /Error/ || $0 ~ /ERROR/ )
-		{
-			isError = 1
-		}
-		else if ( $2 == "warning," && ($1 == "vcs:" || $1 == "get:"))
-		{
-			# // pvcs error
-			isError = 1
-		}
-		else if ( $0 ~ /attributes/ && $0 ~ /change/ )
-		{
-			# // pvcs error
-			isError = 1
-		}
-		if ( isError == 1 )
-		{
-			if ( doClooks && ( \
-					$0 ~ /error C1055: compiler limit : out of keys/ || \
-					$0 ~ /error C1852: '/ ))
-			{
-				if ( clookhzeile == 0 )
-				{
-					print hzeile >>CLOOKsOut
-					clookhzeile = 1
-					printf("\n") >>CLOOKsOut
-				}
-				print >>CLOOKsOut
-				clook = 1
-				isError = 0
-			}
-			else
-			{
-				# // die ganz speziellen, die keine sind..
-				if ( ( FILENAME ~ /SB_VM.LOG/ || FILENAME ~ /sb_vm.log/ || \
-						FILENAME ~ /SB_VM.log/ || FILENAME ~ /sb_vm.LOG/ ) && \
-						(( $0 ~ /sberror.obj/ && $0 ~ /obj/ ) || \
-							( $0 ~ /sberror.cxx/ )))
-				{
-					isError = 0
-				}
-				else if ( ( FILENAME ~ /_UI.LOG/ || FILENAME ~ /_ui.log/ || \
-						FILENAME ~ /_UI.log/ || FILENAME ~ /_ui.LOG/ ) && \
-						(( $0 ~ /error.src/ && $0 ~ /app.srs/ ) || \
-							( $0 ~ /error.src/ && $0 ~ /commandline/ )))
-				{
-					isError = 0
-				}
-				# // MASM Endmeldung
-				else if ( $0 ~ / 0 Warning Errors/ || \
-							$0 ~ / 0 Severe  Errors/  )
-				{
-					isError = 0
-				}
-				# // TASM Endausgabe
-				if ( $0 ~ /Error messages:    None/ )
-				{
-					isError = 0
-				}
-				# // MkDepend doppeltes Include, leading tab
-				else if ( $0 == "\t../../../INC/error.h" || $0 == "\t../../../inc/error.h" )
-				{
-					isError = 0
-				}
-				else if ($0 == "\ttype ..\inc\rscerror.h          >>..\WINMSCI\inc\rsc.hxx")
-				{
-					isError = 0
-				}
-				# // PM2B300: Warning filename.ext line: Parameter '*error*' is never used
-				else if ( $1 == "Warning" && $4 == "Parameter" )
-				{
-					isError = 0
-				}
-				# // PVCS StampGet
-				else if ( $0 == "Modified logfile \"T:/sw6/source/ui/app/error.srv\"." || \
-					 		$0 == "error.src <- t:/sw6/source/ui/app/error.srv" || \
-					 		$0 == "Modified logfile \"T:/sw6/inc/error.h_v\"." || \
-					 		$0 == "error.h <- t:/sw6/inc/error.h_v" || \
-							$0 == "Modified logfile \"T:/hm2/inc/reerrors.h_v\"." || \
-							$0 == "Modified logfile \"T:/hm2/inc/slerror.h_v\"." || \
-							$0 == "reerrors.h <- t:/hm2/inc/reerrors.h_v" || \
-							$0 == "slerror.h <- t:/hm2/inc/slerror.h_v" || \
-							$0 == "Modified logfile \"T:/rsc/inc/rscerror.h_v\"." || \
-							$0 == "rscerror.h <- t:/rsc/inc/rscerror.h_v" || \
-							$0 == "Modified logfile \"T:/setup/source/app/error.srv\"." || \
-							$0 == "error.src <- t:/setup/source/app/error.srv" || \
-							$0 == "Modified logfile \"T:/setup/inc/error.hrv\"." || \
-							$0 == "error.hrc <- t:/setup/inc/error.hrv" || \
-							$0 == "Modified logfile \"T:/sbasic/inc/sberror.h_v\"." || \
-							$0 == "sberrors.hxx <- t:/basic/inc/sberrors.hxv" || \
-							$0 == "Modified logfile \"T:/basic\inc/sberrors.hxv" || \
-							$0 == "sberror.h <- t:/sbasic/inc/sberror.h_v" || \
-							$0 == "Modified logfile \"T:/sbasic/source/vm/sberror.cxv\"." || \
-							$0 == "sberror.cxx <- t:/sbasic/source/vm/sberror.cxv" )
-							
-				{
-					isError = 0
-				}
-			}
-		}
-		if ( isError == 1 )
-		{
-			if ( errhzeile == 0 )
-			{
-				print hzeile >>fout
-				errhzeile = 1
-				printf("\n") >>fout
-			}
-			print >>fout
-			err = 1
-			isError = 0
-		}
-	}
-}
-
Index: vcl/jobs/log2err.awk
===================================================================
RCS file: vcl/jobs/log2err.awk
diff -N vcl/jobs/log2err.awk
--- vcl/jobs/log2err.awk	18 Sep 2000 17:05:32 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,142 +0,0 @@
-BEGIN {
-	if ( ARGC < 3)
-	{
-		printf("Syntax: awk ... LogFileIn ErrorLogOut [MscCLOOKsOut]\n")
-		exit 1
-	}
-	fout = ARGV[2]
-	if ( ARGC == 4 )
-	{
-		CLOOKsOut = ARGV[3]
-		doClooks = 1
-		ARGC -= 2
-		printf("") >CLOOKsOut
-	}
-	else
-	{
-		ARGC -= 1
-		doClooks = 0
-	}
-	err = 0
-	clook = 0
-	hzeile = ""
-	zeile1 = ""
-	zeile2 = ""
-	errhzeile = 0
-	clookhzeile = 0
-	isError = 0
-	isProduct = 0
-	printf("") >fout
-}
-
-{
-	if ( "[error log]" == $1" "$2 )
-	{
-		if ( $0 ~ /product=/ )
-		{
-			isProduct = 1
-		}
-		if ( err == 1 )
-		{
-			printf("\n\n") >>fout
-			err = 0
-		}
-		if ( clook == 1 )
-		{
-			printf("\n\n") >>CLOOKsOut
-			clook = 0
-		}
-		hzeile = $0
-		errhzeile = 0
-		clookhzeile = 0
-	}
-	else
-	{
-		if ( $0 ~ /error/ || $0 ~ /Error/ || $0 ~ /ERROR/ )
-		{
-			isError = 1
-		}
-		else if ( $2 == "warning," && ($1 == "vcs:" || $1 == "get:"))
-		{
-			# // pvcs error
-			isError = 1
-		}
-		if ( isError == 1 )
-		{
-			if ( doClooks && ( \
-					$0 ~ /error C1055: compiler limit : out of keys/ || \
-					$0 ~ /error C1852: '/ ))
-			{
-				if ( clookhzeile == 0 )
-				{
-					print hzeile >>CLOOKsOut
-					clookhzeile = 1
-					printf("\n") >>CLOOKsOut
-				}
-				print >>CLOOKsOut
-				clook = 1
-				isError = 0
-			}
-			else
-			{
-				# // die ganz speziellen, die keine sind..
-				if ( ( FILENAME ~ /APP.LOG/ || FILENAME ~ /app.log/ || \
-						FILENAME ~ /APP.log/ || FILENAME ~ /app.LOG/ ) && \
-						(( $0 ~ /error.src/ && $0 ~ /app.srs/ ) || \
-							( $0 ~ /error.src/ && $0 ~ /commandline/ )))
-				{
-					isError = 0
-				}
-				else if ( ( FILENAME ~ /_UI.LOG/ || FILENAME ~ /_ui.log/ || \
-						FILENAME ~ /_UI.log/ || FILENAME ~ /_ui.LOG/ ) && \
-						(( $0 ~ /error.src/ && $0 ~ /app.srs/ ) || \
-							( $0 ~ /error.src/ && $0 ~ /commandline/ )))
-				{
-					isError = 0
-				}
-				# // MASM Endmeldung
-				else if ( $0 ~ / 0 Warning Errors/ || \
-							$0 ~ / 0 Severe  Errors/  )
-				{
-					isError = 0
-				}
-				# // TASM Endausgabe
-				if ( $0 ~ /Error messages:    None/ )
-				{
-					isError = 0
-				}
-				# // MkDepend doppeltes Include, leading tab
-				else if ( $0 == "\t../../../INC/error.h" || $0 == "\t../../../inc/error.h" )
-				{
-					isError = 0
-				}
-				# // PM2B300: Warning filename.ext line: Parameter '*error*' is never used
-				else if ( $1 == "Warning" && $4 == "Parameter" )
-				{
-					isError = 0
-				}
-				# // PVCS StampGet
-				else if ( $0 == "Modified logfile \"T:/sw6/source/ui/app/error.srv\"." || \
-					 		$0 == "error.src <- t:/sw6/source/ui/app/error.srv" || \
-					 		$0 == "Modified logfile \"T:/sw6/inc/error.h_v\"." || \
-					 		$0 == "error.h <- t:/sw6/inc/error.h_v" )
-				{
-					isError = 0
-				}
-			}
-		}
-		if ( isError == 1 )
-		{
-			if ( errhzeile == 0 )
-			{
-				print hzeile >>fout
-				errhzeile = 1
-				printf("\n") >>fout
-			}
-			print >>fout
-			err = 1
-			isError = 0
-		}
-	}
-}
-
Index: vcl/jobs/make.plc
===================================================================
RCS file: vcl/jobs/make.plc
diff -N vcl/jobs/make.plc
--- vcl/jobs/make.plc	18 Sep 2000 17:05:32 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,7 +0,0 @@
-PROCLIST_v1.0
-..
-depcomp.pld
-`nmake -i depend=t ^ nmake -i optimize=t`
-..\log\%OUTPATH%
-; log2err.awk
-777 2 666 2 555 2 444 2 333 2 222 2 777 2 666 2 555 2 444 2 333 2 222 2 111 2
Index: vcl/jobs/make_cap.plc
===================================================================
RCS file: vcl/jobs/make_cap.plc
diff -N vcl/jobs/make_cap.plc
--- vcl/jobs/make_cap.plc	18 Sep 2000 17:05:32 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,7 +0,0 @@
-PROCLIST_v1.0
-..
-depcomp.pld
-`nmake -i depend=t profile=t ^ nmake -i optimize=t profile=t`
-..\log\%OUTPATH%.cap
-l2e_sv.awk
-777 2 666 2 555 2 444 2 333 2 222 2 777 2 666 2 555 2 444 2 333 2 222 2 111 2
Index: vcl/jobs/make_pro.plc
===================================================================
RCS file: vcl/jobs/make_pro.plc
diff -N vcl/jobs/make_pro.plc
--- vcl/jobs/make_pro.plc	18 Sep 2000 17:05:32 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,7 +0,0 @@
-PROCLIST_v1.0
-..
-depcomp.pld
-`nmake -i optimize=t product=full depend=t ^ nmake -i optimize=t product=full`
-..\log\%OUTPATH%.pro
-;log2err.awk
-;
Index: vcl/jobs/putall.plc
===================================================================
RCS file: vcl/jobs/putall.plc
diff -N vcl/jobs/putall.plc
--- vcl/jobs/putall.plc	18 Sep 2000 17:05:32 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,7 +0,0 @@
-PROCLIST_v1.0
-..
-stgetree.pld
-`call s:\bat\putall.btm`
-..\log\putall
-; log2err.awk
-777 2 666 2 555 2 444 2 333 2 222 2 777 2 666 2 555 2 444 2 333 2 222 2 111 2
Index: vcl/jobs/stamp.plc
===================================================================
RCS file: vcl/jobs/stamp.plc
diff -N vcl/jobs/stamp.plc
--- vcl/jobs/stamp.plc	18 Sep 2000 17:05:32 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,7 +0,0 @@
-PROCLIST_v1.0
-..
-stgetree.PLD
-`if "%_sv_version%" != "" vcs -v%_sv_version% -y *.??v`
-..\log\stamp
-log2err.awk
-777 2 666 2 555 2 444 2 333 2 222 2 777 2 666 2 555 2 444 2 333 2 222 2 111 2
Index: vcl/jobs/stampget.plc
===================================================================
RCS file: vcl/jobs/stampget.plc
diff -N vcl/jobs/stampget.plc
--- vcl/jobs/stampget.plc	18 Sep 2000 17:05:32 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,7 +0,0 @@
-PROCLIST_v1.0
-..
-stgetree.PLD
-`iff "%_sv_version%" != "" then ^ vcs -v%_sv_version% -y *.??v ^ call get -y *.??v ^ endiff`
-..\log\stampget
-l2e_sv.awk
-430 10 1500 2 
Index: vcl/jobs/stgetree.pld
===================================================================
RCS file: vcl/jobs/stgetree.pld
diff -N vcl/jobs/stgetree.pld
--- vcl/jobs/stgetree.pld	18 Sep 2000 17:05:32 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,20 +0,0 @@
-inc
-source\app
-source\gdi
-source\window
-source\control
-source\remote
-source\uno
-source\ex
-source\src
-win\source\app		::w_app
-win\source\gdi          ::w_gdi
-win\source\window       ::w_win
-win\source\src          ::w_src
-win\inc		        ::w_inc
-os2\source\app          ::o_app
-os2\source\gdi          ::o_gdi
-os2\source\window       ::o_win
-os2\source\src          ::o_src
-util
-workben
Index: vcl/jobs/verget.plc
===================================================================
RCS file: vcl/jobs/verget.plc
diff -N vcl/jobs/verget.plc
--- vcl/jobs/verget.plc	18 Sep 2000 17:05:32 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,7 +0,0 @@
-PROCLIST_v1.0
-..
-STGETREE.PLD
-`get -y -v%_sv_version *.??v`
-..\log\get
-l2e_sv.awk
-440 3 593 3 440 3 593 3 440 3 593 9 999 1 888 1 777 1 666 1 555 1 444 1 333 1 222 1 111 1
Index: vcl/prj/build.lst
===================================================================
RCS file: /cvs/gsl/vcl/prj/build.lst,v
retrieving revision 1.20.60.1
retrieving revision 1.32
diff -u -p -u -r1.20.60.1 -r1.32
--- vcl/prj/build.lst	2 Dec 2003 11:12:11 -0000	1.20.60.1
+++ vcl/prj/build.lst	24 May 2004 07:45:49 -0000	1.32
@@ -1,9 +1,8 @@
-vc	vcl	:	nas freetype psprint rsc sot ucbhelper unotools rvpapi icu unoil ridljar x11_extensions NULL
+vc	vcl	:	boost nas freetype psprint rsc sot ucbhelper unotools rvpapi icu i18npool unoil ridljar x11_extensions gtk offuh basegfx NULL
 vc	vcl										usr1	-	all	vc_mkout NULL
 vc	vcl\source\unotypes						nmake	-	all	vc_unot NULL
 vc	vcl\source\glyphs						nmake	-	all	vc_glyphs vc_unot NULL
-vc	vcl\source\remote						nmake	-	all	vc_remo vc_glyphs vc_unot NULL
-vc	vcl\source\app							nmake	-	all	vc_app vc_unot vc_remo NULL
+vc	vcl\source\app							nmake	-	all	vc_app vc_unot NULL
 vc	vcl\source\gdi							nmake	-	all	vc_gdi vc_unot NULL
 vc	vcl\source\window						nmake	-	all	vc_win vc_unot NULL
 vc	vcl\source\control						nmake	-	all	vc_ctrl	vc_unot NULL
@@ -13,16 +12,15 @@ vc	vcl\win\source\app						nmake	-	w	vc_
 vc	vcl\win\source\gdi						nmake	-	w	vc__gdiw vc_unot NULL
 vc	vcl\win\source\window					nmake	-	w	vc__winw vc_unot NULL
 vc	vcl\win\source\src						nmake	-	w	vc__srcw vc_unot NULL
-vc	vcl\os2\source\app						nmake	-	p	vc__appp vc_unot NULL
-vc	vcl\os2\source\gdi						nmake	-	p	vc__gdip vc_unot NULL
-vc	vcl\os2\source\window					nmake	-	p	vc__winp vc_unot NULL
-vc	vcl\os2\source\src						nmake	-	p	vc__srcp vc_unot NULL
+vc  vcl\unx\source\plugadapt				nmake	-	u	vc__plug vc_unot NULL
 vc	vcl\unx\source\app						nmake	-	u	vc__appu vc_unot NULL
 vc	vcl\unx\source\gdi						nmake	-	u	vc__gdiu vc_unot NULL
-vc	vcl\unx\source\gdi\getstyle				nmake	-	u	vc__gdus vc_unot NULL
-vc	vcl\unx\source\gdi\native-msgbox		nmake	-	u	vc__gdun vc_unot NULL
 vc	vcl\unx\source\window					nmake	-	u	vc__winu vc_unot NULL
 vc	vcl\unx\source\src						nmake	-	u	vc__srcu vc_unot NULL
+vc  vcl\unx\dummy							nmake   -   u   vc__du   vc_unot NULL
+vc  vcl\unx\gtk\app							nmake   -   u   vc__gtka vc_unot NULL
+vc  vcl\unx\gtk\window						nmake   -   u   vc__gtkw vc_unot NULL
+vc  vcl\unx\gtk\gdi 						nmake   -   u   vc__gtkg vc_unot NULL
 vc	vcl\aqua\source\app						nmake	-	u	vc__appa vc_unot NULL
 vc	vcl\aqua\source\gdi						nmake	-	u	vc__gdia vc_unot NULL
 vc	vcl\aqua\source\window					nmake	-	u	vc__wina vc_unot NULL
@@ -31,5 +29,5 @@ vc	vcl\mac\source\app						nmake	-	m	vc_
 vc	vcl\mac\source\gdi						nmake	-	m	vc__gdim vc_unot NULL
 vc	vcl\mac\source\window					nmake	-	m	vc__winm vc_unot NULL
 vc	vcl\mac\source\src						nmake	-	m	vc__srcm vc_unot NULL
-vc	vcl\util								nmake	-	all	vc_util vc__appa.u vc__appm.m vc__appp.p vc__appu.u vc__appw.w vc__gdim.m vc__gdip.p vc__gdiu.u vc__gdiw.w vc__srcm.m vc__srcp.p vc__srcu.u vc__srcw.w vc__wina.u vc__winm.m vc__winp.p vc__winu.u vc__winw.w vc_app vc_ctrl vc_gdi vc_hlp vc_remo vc_src vc_win NULL
+vc	vcl\util								nmake	-	all	vc_util vc__plug.u vc__appa.u vc__appm.m vc__appu.u vc__appw.w vc__gdim.m vc__gdiu.u vc__gdiw.w vc__srcm.m vc__srcu.u vc__srcw.w vc__wina.u vc__winm.m vc__winu.u vc__winw.w vc__du.u vc__gtka.u vc__gtkw.u vc__gtkg.u vc_app vc_ctrl vc_gdi vc_hlp vc_src vc_win NULL
 #vc	vcl\workben								nmake	-	all	vc_wrkb vc_util NULL
Index: vcl/prj/d.lst
===================================================================
RCS file: /cvs/gsl/vcl/prj/d.lst,v
retrieving revision 1.29.102.1
retrieving revision 1.39
diff -u -p -u -r1.29.102.1 -r1.39
--- vcl/prj/d.lst	28 Jan 2004 15:21:59 -0000	1.29.102.1
+++ vcl/prj/d.lst	25 Jun 2004 15:15:11 -0000	1.39
@@ -1,5 +1,4 @@
-mkdir: %_DEST%\bin%_EXT%\remote
-mkdir: %_DEST%\lib%_EXT%\remote
+mkdir: %COMMON_DEST%\bin%_EXT%\hid
 mkdir: %_DEST%\inc%_EXT%\sv
 mkdir: %_DEST%\inc%_EXT%\tools
 mkdir: %_DEST%\inc%_EXT%\uno
@@ -7,19 +6,16 @@ mkdir: %_DEST%\inc%_EXT%\uno\awt
 mkdir: %_DEST%\inc%_EXT%\vcl
 mkdir: %_DEST%\inc%_EXT%\vcl\unx
 
-..\%__SRC%\bin\remote\vcl?????.dll %_DEST%\bin%_EXT%\remote\vcl?????.dll
-..\%__SRC%\bin\vcl?????.res %_DEST%\bin%_EXT%\vcl?????.res
+..\%COMMON_OUTDIR%\misc\*.hid %COMMON_DEST%\bin%_EXT%\hid\*.hid
+..\%__SRC%\bin\vcl*.res %_DEST%\bin%_EXT%\vcl*.res
 ..\%__SRC%\bin\vcl?????.dll %_DEST%\bin%_EXT%\vcl?????.dll
 ..\%__SRC%\bin\vcl?????.sym %_DEST%\bin%_EXT%\vcl?????.sym
-..\%__SRC%\bin\getstyle-gnome %_DEST%\bin%_EXT%\getstyle-gnome
-..\%__SRC%\bin\msgbox-gnome %_DEST%\bin%_EXT%\msgbox-gnome
 ..\%__SRC%\lib\libvcl*.so %_DEST%\lib%_EXT%\libvcl*.so
 ..\%__SRC%\lib\*.dylib %_DEST%\lib%_EXT%\*.dylib
 ..\%__SRC%\lib\app16.lib %_DEST%\lib%_EXT%\app16.lib
 ..\%__SRC%\lib\gdi16.lib %_DEST%\lib%_EXT%\gdi16.lib
 ..\%__SRC%\lib\isv.lib %_DEST%\lib%_EXT%\isv.lib
 ..\%__SRC%\lib\ivcl.lib %_DEST%\lib%_EXT%\ivcl.lib
-..\%__SRC%\lib\remote\lib*.so %_DEST%\lib%_EXT%\remote\lib*.so
 ..\%__SRC%\lib\vcl.lib %_DEST%\lib%_EXT%\vcl.lib
 ..\%__SRC%\misc\vcl?????.map %_DEST%\bin%_EXT%\vcl?????.map
 ..\%__SRC%\obj\main.obj %_DEST%\lib%_EXT%\xsvmain.obj
@@ -111,6 +98,8 @@ hedabu: ..\inc\outdev.hxx %_DEST%\inc%_E
 hedabu: ..\inc\salgtype.hxx %_DEST%\inc%_EXT%\vcl\salgtype.hxx
 hedabu: ..\inc\salotype.hxx %_DEST%\inc%_EXT%\vcl\salotype.hxx
 hedabu: ..\inc\salstype.hxx %_DEST%\inc%_EXT%\vcl\salstype.hxx
+hedabu: ..\inc\salnativewidgets.hxx %_DEST%\inc%_EXT%\vcl\salnativewidgets.hxx
+hedabu: ..\unx\inc\salnativewidgets.h %_DEST%\inc%_EXT%\vcl\salnativewidgets.h
 hedabu: ..\inc\scrbar.hxx %_DEST%\inc%_EXT%\vcl\scrbar.hxx
 hedabu: ..\inc\seleng.hxx %_DEST%\inc%_EXT%\vcl\seleng.hxx
 hedabu: ..\inc\settings.hxx %_DEST%\inc%_EXT%\vcl\settings.hxx
@@ -182,5 +162,8 @@ hedabu: ..\inc\dndhelp.hxx %_DEST%\inc%_
 hedabu: ..\inc\pdfwriter.hxx %_DEST%\inc%_EXT%\vcl\pdfwriter.hxx
 hedabu: ..\inc\controllayout.hxx %_DEST%\inc%_EXT%\vcl\controllayout.hxx
 hedabu: ..\inc\introwin.hxx %_DEST%\inc%_EXT%\vcl\introwin.hxx
+hedabu: ..\inc\abstdlg.hxx %_DEST%\inc%_EXT%\vcl\abstdlg.hxx
+hedabu: ..\inc\pngread.hxx %_DEST%\inc%_EXT%\vcl\pngread.hxx
+hedabu: ..\inc\pngwrite.hxx %_DEST%\inc%_EXT%\vcl\pngwrite.hxx
 
 dos: sh -c "if test %OS% = MACOSX; then create-bundle %_DEST%\lib%_EXT%\*.dylib; fi"
Index: vcl/source/app/dbggui.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/dbggui.cxx,v
retrieving revision 1.12
retrieving revision 1.16
diff -u -p -u -r1.12 -r1.16
--- vcl/source/app/dbggui.cxx	27 Nov 2002 09:19:16 -0000	1.12
+++ vcl/source/app/dbggui.cxx	30 Mar 2004 13:42:10 -0000	1.16
@@ -59,15 +59,13 @@
  *
  ************************************************************************/
 
-#pragma hdrstop
 
-#ifdef DBG_UTIL
 
-#define _SV_DBGGUI_CXX
+#ifdef DBG_UTIL
 
 #include "svdata.hxx"
-#include <stdio.h>
-#include <string.h>
+#include <cstdio>
+#include <cstring>
 #include <limits.h>
 #include <svsys.h>
 
@@ -108,9 +106,6 @@
 #ifndef _SV_WRKWIN_HXX
 #include <wrkwin.hxx>
 #endif
-#ifndef _SV_SYSTEM_HXX
-#include <system.hxx>
-#endif
 #ifndef _SV_SOUND_HXX
 #include <sound.hxx>
 #endif
@@ -170,7 +165,6 @@ static sal_Char* pDbgHelpText[] =
 "\n",
 "Damit die Makros Wirkung haben, muss DBG_UTIL defniert sein.\n",
 "\n",
-#ifndef CFRONT
 "--- Optionen ---\n",
 "This\n",
 "Es wird auf gueltigen This-Pointer getestet. Dadurch kann man erreichen, "
@@ -510,7 +504,6 @@ static sal_Char* pDbgHelpText[] =
 "    //...\n",
 "}",
 "\n",
-#endif
 NULL
 };
 
@@ -684,7 +677,7 @@ void DbgWindow::InsertLine( const XubStr
 // =======================================================================
 
 DbgDialog::DbgDialog() :
-    ModalDialog( Application::GetAppWindow(), WB_STDMODAL | WB_SYSTEMWINDOW ),
+    ModalDialog( NULL, WB_STDMODAL | WB_SYSTEMWINDOW ),
     maXtorThis( this ),
     maXtorFunc( this ),
     maXtorExit( this ),
@@ -1097,11 +1090,7 @@ DbgDialog::DbgDialog() :
     }
 
     {
-#ifdef REMOTE_APPSERVER
-    SetText( XubString( RTL_CONSTASCII_USTRINGPARAM( "VCL Debug Options (Server)" ) ) );
-#else
     SetText( XubString( RTL_CONSTASCII_USTRINGPARAM( "VCL Debug Options" ) ) );
-#endif
     SetOutputSizePixel( LogicToPixel( Size( 340, 265 ), aAppMap ) );
     }
 }
@@ -1211,10 +1200,10 @@ IMPL_LINK( DbgDialog, ClickHdl, Button*,
         DbgData* pData = DbgGetData();
         pData->nTestFlags &= ~(DBG_TEST_XTOR_TRACE | DBG_TEST_MEM_INIT | DBG_TEST_RESOURCE | DBG_TEST_DIALOG | DBG_TEST_BOLDAPPFONT);
         pData->nTestFlags |= aData.nTestFlags & (DBG_TEST_XTOR_TRACE | DBG_TEST_MEM_INIT | DBG_TEST_RESOURCE | DBG_TEST_DIALOG | DBG_TEST_BOLDAPPFONT);
-        strcpy( pData->aInclClassFilter, aData.aInclClassFilter );
-        strcpy( pData->aExclClassFilter, aData.aExclClassFilter );
-        strcpy( pData->aInclFilter, aData.aInclFilter );
-        strcpy( pData->aExclFilter, aData.aExclFilter );
+        strncpy( pData->aInclClassFilter, aData.aInclClassFilter, sizeof( pData->aInclClassFilter ) );
+        strncpy( pData->aExclClassFilter, aData.aExclClassFilter, sizeof( pData->aExclClassFilter ) );
+        strncpy( pData->aInclFilter, aData.aInclFilter, sizeof( pData->aInclFilter ) );
+        strncpy( pData->aExclFilter, aData.aExclFilter, sizeof( pData->aExclFilter ) );
         if ( maBoldAppFont.GetSavedValue() != maBoldAppFont.IsChecked() )
         {
             AllSettings aSettings = Application::GetSettings();
@@ -1403,7 +1392,7 @@ void DbgDialogTest( Window* pWindow )
             XubString       aErrorText = aText;
             USHORT          nAccelPos;
             xub_Unicode     cAccel = 0;
-            if ( aErrorText > 128 )
+            if ( aErrorText.Len() > 128 )
             {
                 aErrorText.Erase( 128 );
                 aErrorText.AppendAscii( "..." );
@@ -1711,10 +1700,6 @@ void DbgPrintShell( const char* pLine );
 
 void DbgPrintMsgBox( const char* pLine )
 {
-#ifdef REMOTE_APPSERVER
-    DbgPrintShell( pLine );
-    return;
-#endif
     if ( Application::IsDialogCancelEnabled() )
     {
 #if defined( WNT )
@@ -1738,7 +1723,6 @@ void DbgPrintMsgBox( const char* pLine )
 #endif
     }
 
-#ifndef REMOTE_APPSERVER
 #ifdef UNX
     sal_Bool bAcquire = Application::GetSolarMutex().tryToAcquire();
     if (!bAcquire)
@@ -1748,7 +1732,6 @@ void DbgPrintMsgBox( const char* pLine )
         return;
     }
 #endif
-#endif
 
     strcpy( aDbgOutBuf, pLine );
     strcat( aDbgOutBuf, "\nAbort ? (Yes=abort / No=ignore / Cancel=core dump)" );
@@ -1760,7 +1743,6 @@ void DbgPrintMsgBox( const char* pLine )
     if ( pSVData->maWinData.mpCaptureWin )
         pSVData->maWinData.mpCaptureWin->ReleaseMouse();
 
-#ifndef REMOTE_APPSERVER
 #if defined( WNT )
     BOOL bOldCallTimer = pSVData->mbNoCallTimer;
     pSVData->mbNoCallTimer = TRUE;
@@ -1805,30 +1787,19 @@ void DbgPrintMsgBox( const char* pLine )
 #else
     USHORT nOldMode = Application::GetSystemWindowMode();
     Application::SetSystemWindowMode( nOldMode & ~SYSTEMWINDOW_MODE_NOAUTOMODE );
-    ErrorBox aBox( Application::GetAppWindow(), WB_YES_NO_CANCEL | WB_DEF_NO,
+    ErrorBox aBox( NULL, WB_YES_NO_CANCEL | WB_DEF_NO,
                    UniString( aDbgOutBuf, RTL_TEXTENCODING_UTF8 ) );
     aBox.SetText( String( RTL_CONSTASCII_USTRINGPARAM("Debug Output") ) );
     Application::SetSystemWindowMode( nOldMode );
     short nRet = aBox.Execute();
 #endif
-#else
-    USHORT nOldMode = Application::GetSystemWindowMode();
-    Application::SetSystemWindowMode( nOldMode & ~SYSTEMWINDOW_MODE_NOAUTOMODE );
-    ErrorBox aBox( Application::GetAppWindow(), WB_YES_NO_CANCEL | WB_DEF_NO,
-                   UniString( aDbgOutBuf, RTL_TEXTENCODING_UTF8 ) );
-    aBox.SetText( String( RTL_CONSTASCII_USTRINGPARAM("Debug Output (Server)") ) );
-    Application::SetSystemWindowMode( nOldMode );
-    short nRet = aBox.Execute();
-#endif
 
-#ifndef REMOTE_APPSERVER
 #ifdef UNX
     if (bAcquire)
     {
         Application::GetSolarMutex().release();
     }
 #endif
-#endif
 
     if ( nRet == RET_YES )
         GetpApp()->Abort( XubString( RTL_CONSTASCII_USTRINGPARAM( "Debug-Utilities-Error" ) ) );
@@ -1882,7 +1853,7 @@ void DbgPrintShell( const char* pLine )
 
 // =======================================================================
 
-#if defined( REMOTE_APPSERVER ) || defined( WNT ) || defined( OS2 )
+#ifdef WNT
 void ImplDbgTestSolarMutex();
 #endif
 
@@ -1893,7 +1864,7 @@ void DbgGUIInit()
     DbgSetPrintMsgBox( DbgPrintMsgBox );
     DbgSetPrintWindow( DbgPrintWindow );
     DbgSetPrintShell( DbgPrintShell );
-#if defined( REMOTE_APPSERVER ) || defined( WNT ) || defined( OS2 )
+#ifdef WNT
     DbgSetTestSolarMutex( ImplDbgTestSolarMutex );
 #endif
 }
@@ -1905,7 +1876,7 @@ void DbgGUIDeInit()
     DbgSetPrintMsgBox( NULL );
     DbgSetPrintWindow( NULL );
     DbgSetPrintShell( NULL );
-#if defined( REMOTE_APPSERVER ) || defined( WNT ) || defined( OS2 )
+#ifdef WNT
     DbgSetTestSolarMutex( NULL );
 #endif
 
Index: vcl/source/app/dndhelp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/dndhelp.cxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/source/app/dndhelp.cxx	23 Nov 2001 12:38:33 -0000	1.2
+++ vcl/source/app/dndhelp.cxx	1 Dec 2003 13:05:02 -0000	1.3
@@ -59,7 +59,7 @@
  *
  ************************************************************************/
 
-#pragma hdrstop
+
 
 #include <dndhelp.hxx>
 
Index: vcl/source/app/help.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/help.cxx,v
retrieving revision 1.23.60.1
retrieving revision 1.26
diff -u -p -u -r1.23.60.1 -r1.26
--- vcl/source/app/help.cxx	9 Jan 2004 18:13:42 -0000	1.23.60.1
+++ vcl/source/app/help.cxx	6 Jan 2004 13:10:20 -0000	1.26
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_HELP_CXX
-
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
 #endif
@@ -90,7 +88,7 @@
 
 #include <stdio.h>
 
-#pragma hdrstop
+
 
 
 // =======================================================================
@@ -108,6 +106,10 @@
 // =======================================================================
 
 Help::Help()
+{
+}
+
+Help::~Help()
 {
 }
 
Index: vcl/source/app/i18nhelp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/i18nhelp.cxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/source/app/i18nhelp.cxx	23 Aug 2001 12:03:17 -0000	1.3
+++ vcl/source/app/i18nhelp.cxx	1 Dec 2003 13:05:40 -0000	1.4
@@ -59,7 +59,7 @@
  *
  ************************************************************************/
 
-#pragma hdrstop
+
 
 #include <i18nhelp.hxx>
 
Index: vcl/source/app/idlemgr.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/idlemgr.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/app/idlemgr.cxx	18 Sep 2000 17:05:35 -0000	1.1.1.1
+++ vcl/source/app/idlemgr.cxx	6 Jan 2004 13:10:53 -0000	1.2
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_IDLEMGR_CXX
 
 #ifndef _LIST_HXX
 #include <tools/list.hxx>
Index: vcl/source/app/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/source/app/makefile.mk,v
retrieving revision 1.10.260.1
retrieving revision 1.13
diff -u -p -u -r1.10.260.1 -r1.13
--- vcl/source/app/makefile.mk	2 Mar 2004 10:00:57 -0000	1.10.260.1
+++ vcl/source/app/makefile.mk	18 May 2004 10:50:00 -0000	1.13
@@ -89,32 +87,15 @@ SLOFILES=	$(SLO)$/access.obj		\
 			$(SLO)$/svapp.obj		\
 			$(SLO)$/svdata.obj		\
 			$(SLO)$/svmain.obj		\
-			$(SLO)$/system.obj		\
 			$(SLO)$/timer.obj		\
 			$(SLO)$/dndhelp.obj     \
 			$(SLO)$/unohelp.obj     \
 			$(SLO)$/unohelp2.obj    \
 			$(SLO)$/vclevent.obj	\
 			$(SLO)$/i18nhelp.obj	\
+			$(SLO)$/salvtables.obj	\
 			$(SLO)$/session.obj
 
-.IF "$(remote)"!=""
-EXCEPTIONSFILES=					\
-			$(SLO)$/svapp.obj		\
-			$(SLO)$/access.obj		\
-			$(SLO)$/oldsv.obj		\
-			$(SLO)$/help.obj		\
-			$(SLO)$/resmgr.obj		\
-			$(SLO)$/sound.obj		\
-			$(SLO)$/svdata.obj		\
-			$(SLO)$/svmain.obj		\
-			$(SLO)$/system.obj		\
-			$(SLO)$/idlemgr.obj 	\
-			$(SLO)$/timer.obj		\
-			$(SLO)$/unohelp.obj     \
-			$(SLO)$/unohelp2.obj    \
-			$(SLO)$/dndhelp.obj
-.ELSE
 EXCEPTIONSFILES=					\
 			$(SLO)$/svapp.obj		\
 			$(SLO)$/svdata.obj		\
@@ -124,7 +105,6 @@ EXCEPTIONSFILES=					\
 			$(SLO)$/i18nhelp.obj 	\
 			$(SLO)$/svmain.obj		\
 			$(SLO)$/session.obj
-.ENDIF
 
 # --- Targets ------------------------------------------------------
 
Index: vcl/source/app/salvtables.cxx
===================================================================
RCS file: vcl/source/app/salvtables.cxx
diff -N vcl/source/app/salvtables.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/source/app/salvtables.cxx	10 May 2004 15:45:16 -0000	1.4
@@ -0,0 +1,137 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <salframe.hxx>
+#include <salinst.hxx>
+#include <salvd.hxx>
+#include <salprn.hxx>
+#include <saltimer.hxx>
+#include <salsound.hxx>
+#include <salogl.hxx>
+#include <salimestatus.hxx>
+#include <salsys.hxx>
+#include <salbmp.hxx>
+#include <salobj.hxx>
+#include <salmenu.hxx>
+#include <salctrlhandle.hxx>
+
+// this file contains the virtual destructors of the sal interface
+// compilers ususally put their vtables where the destructor is
+
+SalFrame::~SalFrame()
+{
+}
+
+SalInstance::~SalInstance()
+{
+}
+
+SalSound::~SalSound()
+{
+}
+
+SalTimer::~SalTimer()
+{
+}
+
+SalOpenGL::~SalOpenGL()
+{
+}
+
+SalBitmap::~SalBitmap()
+{
+}
+
+SalI18NImeStatus::~SalI18NImeStatus()
+{
+}
+
+SalSystem::~SalSystem()
+{
+}
+
+SalPrinter::~SalPrinter()
+{
+}
+
+SalInfoPrinter::~SalInfoPrinter()
+{
+}
+
+SalVirtualDevice::~SalVirtualDevice()
+{
+}
+
+SalObject::~SalObject()
+{
+}
+
+SalMenu::~SalMenu()
+{
+}
+
+SalMenuItem::~SalMenuItem()
+{
+}
+SalControlHandle::~SalControlHandle()
+{
+}
+
Index: vcl/source/app/session.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/session.cxx,v
retrieving revision 1.1.4.2
retrieving revision 1.2
diff -u -p -u -r1.1.4.2 -r1.2
--- vcl/source/app/session.cxx	2 Mar 2004 14:22:34 -0000	1.1.4.2
+++ vcl/source/app/session.cxx	18 May 2004 10:53:41 -0000	1.2
@@ -58,12 +58,6 @@
  *
  *
  ************************************************************************/
-#ifdef WNT
-#define VCL_NEED_BASETSD
-#include <tools/presys.h>
-#include <windows.h>
-#include <tools/postsys.h>
-#endif
 
 #ifndef _SV_SVAPP_HXX
 #include <svapp.hxx>
Index: vcl/source/app/settings.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/settings.cxx,v
retrieving revision 1.38.122.1
retrieving revision 1.46
diff -u -p -u -r1.38.122.1 -r1.46
--- vcl/source/app/settings.cxx	15 Jan 2004 14:16:01 -0000	1.38.122.1
+++ vcl/source/app/settings.cxx	25 Jun 2004 15:15:36 -0000	1.46
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SETTINGS_CXX
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -112,7 +110,7 @@
 
 using namespace rtl;
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -241,7 +239,7 @@ ImplMouseData::ImplMouseData()
     mnDragLinkCode              = KEY_SHIFT | KEY_MOD1;
     mnContextMenuCode           = MOUSE_RIGHT;
     mnContextMenuClicks         = 1;
-    mbContextMenuDown           = FALSE;
+    mbContextMenuDown           = TRUE;
     mnMiddleButtonAction        = MOUSE_MIDDLE_AUTOSCROLL;
     mnScrollRepeat              = 100;
     mnButtonStartRepeat         = 370;
@@ -473,11 +471,7 @@ ImplStyleData::ImplStyleData()
     mnIconVertSpace             = 40;
     mnAntialiasedMin            = 0;
     mnCursorSize                = 2;
-#ifdef REMOTE_APPSERVER
     mnCursorBlinkTime           = STYLE_CURSOR_NOBLINKTIME;
-#else
-    mnCursorBlinkTime           = 500;
-#endif
     mnScreenZoom                = 100;
     mnScreenFontZoom            = 100;
     mnRadioButtonStyle          = 0;
@@ -499,60 +493,60 @@ ImplStyleData::ImplStyleData()
 // -----------------------------------------------------------------------
 
 ImplStyleData::ImplStyleData( const ImplStyleData& rData ) :
-    maFaceColor( rData.maFaceColor ),
-    maCheckedColor( rData.maCheckedColor ),
-    maLightColor( rData.maLightColor ),
-    maLightBorderColor( rData.maLightBorderColor ),
-    maShadowColor( rData.maShadowColor ),
-    maDarkShadowColor( rData.maDarkShadowColor ),
-    maButtonTextColor( rData.maButtonTextColor ),
-    maRadioCheckTextColor( rData.maRadioCheckTextColor ),
-    maGroupTextColor( rData.maGroupTextColor ),
-    maLabelTextColor( rData.maLabelTextColor ),
-    maInfoTextColor( rData.maInfoTextColor ),
-    maWindowColor( rData.maWindowColor ),
-    maWindowTextColor( rData.maWindowTextColor ),
-    maDialogColor( rData.maDialogColor ),
-    maDialogTextColor( rData.maDialogTextColor ),
-    maWorkspaceColor( rData.maWorkspaceColor ),
-    maFieldColor( rData.maFieldColor ),
-    maFieldTextColor( rData.maFieldTextColor ),
+    maActiveBorderColor( rData.maActiveBorderColor ),
     maActiveColor( rData.maActiveColor ),
     maActiveColor2( rData.maActiveColor2 ),
     maActiveTextColor( rData.maActiveTextColor ),
-    maActiveBorderColor( rData.maActiveBorderColor ),
+    maButtonTextColor( rData.maButtonTextColor ),
+    maCheckedColor( rData.maCheckedColor ),
+    maDarkShadowColor( rData.maDarkShadowColor ),
+    maDeactiveBorderColor( rData.maDeactiveBorderColor ),
     maDeactiveColor( rData.maDeactiveColor ),
     maDeactiveColor2( rData.maDeactiveColor2 ),
     maDeactiveTextColor( rData.maDeactiveTextColor ),
-    maDeactiveBorderColor( rData.maDeactiveBorderColor ),
-    maMenuColor( rData.maMenuColor ),
-    maMenuBarColor( rData.maMenuBarColor ),
-    maMenuBorderColor( rData.maMenuBorderColor ),
-    maMenuTextColor( rData.maMenuTextColor ),
-    maMenuHighlightColor( rData.maMenuHighlightColor ),
-    maMenuHighlightTextColor( rData.maMenuHighlightTextColor ),
-    maHighlightColor( rData.maHighlightColor ),
-    maHighlightTextColor( rData.maHighlightTextColor ),
+    maDialogColor( rData.maDialogColor ),
+    maDialogTextColor( rData.maDialogTextColor ),
     maDisableColor( rData.maDisableColor ),
+    maFaceColor( rData.maFaceColor ),
+    maFieldColor( rData.maFieldColor ),
+    maFieldTextColor( rData.maFieldTextColor ),
+	maFontColor( rData.maFontColor ),
+    maGroupTextColor( rData.maGroupTextColor ),
     maHelpColor( rData.maHelpColor ),
     maHelpTextColor( rData.maHelpTextColor ),
+    maHighlightColor( rData.maHighlightColor ),
+    maHighlightLinkColor( rData.maLinkColor ),
+    maHighlightTextColor( rData.maHighlightTextColor ),
+    maInfoTextColor( rData.maInfoTextColor ),
+    maLabelTextColor( rData.maLabelTextColor ),
+    maLightBorderColor( rData.maLightBorderColor ),
+    maLightColor( rData.maLightColor ),
     maLinkColor( rData.maLinkColor ),
+    maMenuBarColor( rData.maMenuBarColor ),
+    maMenuBorderColor( rData.maMenuBorderColor ),
+    maMenuColor( rData.maMenuColor ),
+    maMenuHighlightColor( rData.maMenuHighlightColor ),
+    maMenuHighlightTextColor( rData.maMenuHighlightTextColor ),
+    maMenuTextColor( rData.maMenuTextColor ),
+    maRadioCheckTextColor( rData.maRadioCheckTextColor ),
+    maShadowColor( rData.maShadowColor ),
     maVisitedLinkColor( rData.maLinkColor ),
-    maHighlightLinkColor( rData.maLinkColor ),
+    maWindowColor( rData.maWindowColor ),
+    maWindowTextColor( rData.maWindowTextColor ),
+    maWorkspaceColor( rData.maWorkspaceColor ),
     maAppFont( rData.maAppFont ),
     maHelpFont( rData.maAppFont ),
     maTitleFont( rData.maTitleFont ),
     maFloatTitleFont( rData.maFloatTitleFont ),
     maMenuFont( rData.maMenuFont ),
     maToolFont( rData.maToolFont ),
-    maGroupFont( rData.maGroupFont ),
     maLabelFont( rData.maLabelFont ),
+    maGroupFont( rData.maGroupFont ),
     maInfoFont( rData.maInfoFont ),
     maRadioCheckFont( rData.maRadioCheckFont ),
     maPushButtonFont( rData.maPushButtonFont ),
     maFieldFont( rData.maFieldFont ),
-    maIconFont( rData.maIconFont ),
-	maFontColor( rData.maFontColor )
+    maIconFont( rData.maIconFont )
 {
     mnRefCount                  = 1;
     mnBorderSize                = rData.mnBorderSize;
@@ -582,6 +576,7 @@ ImplStyleData::ImplStyleData( const Impl
     mnOptions                   = rData.mnOptions;
 	mnHighContrast				= rData.mnHighContrast;
 	mnUseSystemUIFonts			= rData.mnUseSystemUIFonts;
+	mnUseFlatBorders 			= rData.mnUseFlatBorders;
 	mnUseFlatMenues 			= rData.mnUseFlatMenues;
     mnAutoMnemonic				= rData.mnAutoMnemonic;
     mnUseImagesInMenus			= rData.mnUseImagesInMenus;
@@ -595,7 +590,7 @@ void ImplStyleData::SetStandardStyles()
     Font aStdFont( FAMILY_SWISS, Size( 0, 8 ) );
     aStdFont.SetCharSet( gsl_getSystemTextEncoding() );
     aStdFont.SetWeight( WEIGHT_NORMAL );
-    aStdFont.SetName( vcl::DefaultFontConfigItem::get()->getUserInterfaceFont(LANGUAGE_ENGLISH) );
+    aStdFont.SetName( vcl::DefaultFontConfigItem::get()->getUserInterfaceFont(com::sun::star::lang::Locale( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("en") ), rtl::OUString(), rtl::OUString() ) ) );
     maAppFont                   = aStdFont;
     maHelpFont                  = aStdFont;
     maMenuFont                  = aStdFont;
@@ -609,7 +604,6 @@ void ImplStyleData::SetStandardStyles()
     maIconFont                  = aStdFont;
     maFloatTitleFont            = aStdFont;
     aStdFont.SetWeight( WEIGHT_BOLD );
-    aStdFont.SetName( vcl::DefaultFontConfigItem::get()->getUserInterfaceFont(LANGUAGE_ENGLISH) );
     maTitleFont                 = aStdFont;
 
     maFaceColor                 = Color( COL_LIGHTGRAY );
@@ -667,229 +661,13 @@ void ImplStyleData::SetStandardStyles()
     mnMenuBarHeight             = 14;
 	mnHighContrast				= 0;
 	mnUseSystemUIFonts			= 0;
+	mnUseFlatBorders 			= 0;
 	mnUseFlatMenues 			= 0;
 	mnUseImagesInMenus			= (USHORT)TRUE;
 }
 
 // -----------------------------------------------------------------------
 
-void ImplStyleData::SetStandardWinStyles()
-{
-    SetStandardStyles();
-
-    mnRadioButtonStyle         &= ~STYLE_RADIOBUTTON_STYLE;
-    mnRadioButtonStyle         |= STYLE_RADIOBUTTON_WIN;
-    mnCheckBoxStyle            &= ~STYLE_CHECKBOX_STYLE;
-    mnCheckBoxStyle            |= STYLE_CHECKBOX_WIN;
-    mnPushButtonStyle          &= ~STYLE_PUSHBUTTON_STYLE;
-    mnPushButtonStyle          |= STYLE_PUSHBUTTON_WIN;
-    mnTabControlStyle           = 0;
-
-    mnOptions                  &= ~(STYLE_OPTION_SYSTEMSTYLE | STDSYS_STYLE);
-    mnOptions                  |= STYLE_OPTION_WINSTYLE;
-}
-
-// -----------------------------------------------------------------------
-
-void ImplStyleData::SetStandardOS2Styles()
-{
-    Font aStdFont( FAMILY_SWISS, Size( 0, 9 ) );
-    aStdFont.SetCharSet( gsl_getSystemTextEncoding() );
-    aStdFont.SetWeight( WEIGHT_NORMAL );
-    aStdFont.SetName( vcl::DefaultFontConfigItem::get()->getUserInterfaceFont(LANGUAGE_ENGLISH) );
-    maAppFont                   = aStdFont;
-    maHelpFont                  = aStdFont;
-    maToolFont                  = aStdFont;
-    maGroupFont                 = aStdFont;
-    maLabelFont                 = aStdFont;
-    maInfoFont                  = aStdFont;
-    maRadioCheckFont            = aStdFont;
-    maPushButtonFont            = aStdFont;
-    maFieldFont                 = aStdFont;
-    maIconFont                  = aStdFont;
-    maFloatTitleFont            = aStdFont;
-    aStdFont.SetWeight( WEIGHT_BOLD );
-    aStdFont.SetName( vcl::DefaultFontConfigItem::get()->getUserInterfaceFont(LANGUAGE_ENGLISH) );
-    maMenuFont                  = aStdFont;
-    maTitleFont                 = aStdFont;
-
-    maFaceColor                 = Color( COL_LIGHTGRAY );
-    maCheckedColor              = Color( 0xCC, 0xCC, 0xCC );
-    maLightColor                = Color( COL_WHITE );
-    maLightBorderColor          = Color( COL_LIGHTGRAY );
-    maShadowColor               = Color( COL_GRAY );
-    maDarkShadowColor           = Color( COL_BLACK );
-    maButtonTextColor           = Color( COL_BLACK );
-    maRadioCheckTextColor       = Color( COL_BLACK );
-    maGroupTextColor            = Color( COL_BLACK );
-    maLabelTextColor            = Color( COL_BLACK );
-    maInfoTextColor             = Color( COL_BLACK );
-    maWindowColor               = Color( COL_WHITE );
-    maWindowTextColor           = Color( COL_BLACK );
-    maDialogColor               = Color( COL_LIGHTGRAY );
-    maDialogTextColor           = Color( COL_BLACK );
-    maWorkspaceColor            = Color( COL_GRAY );
-    maFieldColor                = Color( COL_WHITE );
-    maFieldTextColor            = Color( COL_BLACK );
-    maActiveColor               = Color( COL_BLUE );
-    maActiveColor2              = Color( COL_BLACK );
-    maActiveTextColor           = Color( COL_WHITE );
-    maActiveBorderColor         = Color( COL_LIGHTGRAY );
-    maDeactiveColor             = Color( COL_GRAY );
-    maDeactiveColor2            = Color( COL_BLACK );
-    maDeactiveTextColor         = Color( COL_LIGHTGRAY );
-    maDeactiveBorderColor       = Color( COL_LIGHTGRAY );
-    maMenuColor                 = Color( COL_LIGHTGRAY );
-    maMenuBarColor              = Color( COL_LIGHTGRAY );
-    maMenuBorderColor           = Color( COL_LIGHTGRAY );
-    maMenuTextColor             = Color( COL_BLACK );
-    maMenuHighlightColor        = Color( COL_BLUE );
-    maMenuHighlightTextColor    = Color( COL_WHITE );
-    maHighlightColor            = Color( COL_GRAY );
-    maHighlightTextColor        = Color( COL_WHITE );
-    maDisableColor              = Color( COL_GRAY );
-    maHelpColor                 = Color( 0xFF, 0xFF, 0xE0 );
-    maHelpTextColor             = Color( COL_BLACK );
-
-    mnRadioButtonStyle         &= ~STYLE_RADIOBUTTON_STYLE;
-    mnRadioButtonStyle         |= STYLE_RADIOBUTTON_OS2;
-    mnCheckBoxStyle            &= ~STYLE_CHECKBOX_STYLE;
-    mnCheckBoxStyle            |= STYLE_CHECKBOX_OS2;
-    mnPushButtonStyle          &= ~STYLE_PUSHBUTTON_STYLE;
-    mnPushButtonStyle          |= STYLE_PUSHBUTTON_OS2;
-    mnTabControlStyle           = STYLE_TABCONTROL_SINGLELINE |
-                                  STYLE_TABCONTROL_COLOR;
-
-    mnOptions                  &= ~(STYLE_OPTION_SYSTEMSTYLE | STDSYS_STYLE);
-    mnOptions                  |= STYLE_OPTION_OS2STYLE | STYLE_OPTION_SPINARROW;
-    mnBorderSize                = 1;
-    mnTitleHeight               = 18;
-    mnFloatTitleHeight          = 13;
-    mnTearOffTitleHeight        = 8;
-    mnMenuBarHeight             = 14;
-	mnHighContrast				= 0;
-	mnUseSystemUIFonts			= 0;
-	mnUseFlatMenues 			= 0;
-	mnUseImagesInMenus			= (USHORT)TRUE;	
-}
-
-// -----------------------------------------------------------------------
-
-void ImplStyleData::SetStandardMacStyles()
-{
-    Font aStdFont( FAMILY_SWISS, Size( 0, 8 ) );
-    aStdFont.SetCharSet( gsl_getSystemTextEncoding() );
-    aStdFont.SetWeight( WEIGHT_NORMAL );
-    aStdFont.SetName( vcl::DefaultFontConfigItem::get()->getUserInterfaceFont(LANGUAGE_ENGLISH) );
-    maAppFont                   = aStdFont;
-    maHelpFont                  = aStdFont;
-    maToolFont                  = aStdFont;
-    maPushButtonFont            = aStdFont;
-    maGroupFont                 = aStdFont;
-    maLabelFont                 = aStdFont;
-    maInfoFont                  = aStdFont;
-    maRadioCheckFont            = aStdFont;
-    maFieldFont                 = aStdFont;
-    maIconFont                  = aStdFont;
-    maFloatTitleFont            = aStdFont;
-    aStdFont.SetName( vcl::DefaultFontConfigItem::get()->getUserInterfaceFont(LANGUAGE_ENGLISH) );
-//    aStdFont.SetWeight( WEIGHT_BOLD );
-    maMenuFont                  = aStdFont;
-    maTitleFont                 = aStdFont;
-//    maPushButtonFont            = aStdFont;
-//    maGroupFont                 = aStdFont;
-//    maLabelFont                 = aStdFont;
-
-    maFaceColor                 = Color( COL_LIGHTGRAY );
-    maCheckedColor              = Color( 0x99, 0x99, 0x99 );
-    maLightColor                = Color( COL_WHITE );
-    maLightBorderColor          = Color( COL_LIGHTGRAY );
-    maShadowColor               = Color( COL_GRAY );
-    maDarkShadowColor           = Color( COL_BLACK );
-    maButtonTextColor           = Color( COL_BLACK );
-    maRadioCheckTextColor       = Color( COL_BLACK );
-    maGroupTextColor            = Color( COL_BLACK );
-    maLabelTextColor            = Color( COL_BLACK );
-    maInfoTextColor             = Color( COL_BLACK );
-    maWindowColor               = Color( COL_WHITE );
-    maWindowTextColor           = Color( COL_BLACK );
-    maDialogColor               = Color( COL_LIGHTGRAY );
-    maDialogTextColor           = Color( COL_BLACK );
-    maWorkspaceColor            = Color( COL_GRAY );
-    maFieldColor                = Color( COL_WHITE );
-    maFieldTextColor            = Color( COL_BLACK );
-    maActiveColor               = Color( COL_LIGHTGRAY );
-    maActiveColor2              = Color( COL_LIGHTGRAY );
-    maActiveTextColor           = Color( COL_BLACK );
-    maActiveBorderColor         = Color( COL_LIGHTGRAY );
-    maDeactiveColor             = Color( COL_LIGHTGRAY );
-    maDeactiveColor2            = Color( COL_LIGHTGRAY );
-    maDeactiveTextColor         = Color( COL_GRAY );
-    maDeactiveBorderColor       = Color( COL_LIGHTGRAY );
-    maMenuColor                 = Color( COL_LIGHTGRAY );
-    maMenuBarColor              = Color( COL_LIGHTGRAY );
-    maMenuBorderColor           = Color( COL_LIGHTGRAY );
-    maMenuTextColor             = Color( COL_BLACK );
-    maMenuHighlightColor        = Color( COL_BLUE );
-    maMenuHighlightTextColor    = Color( COL_WHITE );
-    maHighlightColor            = Color( COL_BLUE );
-    maHighlightTextColor        = Color( COL_WHITE );
-    maDisableColor              = Color( COL_GRAY );
-    maHelpColor                 = Color( 0xFF, 0xFF, 0xE0 );
-    maHelpTextColor             = Color( COL_BLACK );
-
-    mnRadioButtonStyle         &= ~STYLE_RADIOBUTTON_STYLE;
-    mnRadioButtonStyle         |= STYLE_RADIOBUTTON_MAC;
-    mnCheckBoxStyle            &= ~STYLE_CHECKBOX_STYLE;
-    mnCheckBoxStyle            |= STYLE_CHECKBOX_MAC;
-    mnPushButtonStyle          &= ~STYLE_PUSHBUTTON_STYLE;
-    mnPushButtonStyle          |= STYLE_PUSHBUTTON_MAC;
-    mnTabControlStyle           = 0;
-
-    mnOptions                  &= ~(STYLE_OPTION_SYSTEMSTYLE | STDSYS_STYLE);
-    mnOptions                  |= STYLE_OPTION_MACSTYLE | STYLE_OPTION_NOMNEMONICS | STYLE_OPTION_SPINUPDOWN;
-    mnBorderSize                = 2;
-    mnTitleHeight               = 16;
-    mnFloatTitleHeight          = 12;
-    mnTearOffTitleHeight        = 7;
-    mnMenuBarHeight             = 14;
-	mnHighContrast				= 0;
-	mnUseSystemUIFonts			= 0;
-	mnUseFlatMenues 			= 0;
-	mnUseImagesInMenus			= (USHORT)TRUE;
-}
-
-// -----------------------------------------------------------------------
-
-void ImplStyleData::SetStandardUnixStyles()
-{
-    SetStandardStyles();
-
-    maActiveColor               = Color( 182, 77, 121 );
-    maActiveColor2              = Color( 182, 77, 121 );
-    maActiveTextColor           = Color( COL_WHITE );
-    maActiveBorderColor         = Color( 182, 77, 121 );
-    maDeactiveColor             = Color( 174, 178, 199 );
-    maDeactiveColor2            = Color( 174, 178, 199 );
-    maDeactiveTextColor         = Color( COL_BLACK );
-    maDeactiveBorderColor       = Color( 174, 178, 199 );
-
-    mnRadioButtonStyle         &= ~STYLE_RADIOBUTTON_STYLE;
-    mnRadioButtonStyle         |= STYLE_RADIOBUTTON_UNIX;
-    mnCheckBoxStyle            &= ~STYLE_CHECKBOX_STYLE;
-    mnCheckBoxStyle            |= STYLE_CHECKBOX_UNIX;
-    mnPushButtonStyle          &= ~STYLE_PUSHBUTTON_STYLE;
-    mnPushButtonStyle          |= STYLE_PUSHBUTTON_UNIX;
-    mnTabControlStyle           = 0;
-
-    mnOptions                  &= ~(STYLE_OPTION_SYSTEMSTYLE | STDSYS_STYLE);
-    mnOptions                  |= STYLE_OPTION_UNIXSTYLE;
-
-    mnBorderSize                = 3;
-}
-
-// -----------------------------------------------------------------------
-
 StyleSettings::StyleSettings()
 {
     mpData = new ImplStyleData();
@@ -960,32 +738,28 @@ void StyleSettings::SetStandardStyles()
 
 void StyleSettings::SetStandardWinStyles()
 {
-    CopyData();
-    mpData->SetStandardWinStyles();
+    return; // no more style changes since NWF
 }
 
 // -----------------------------------------------------------------------
 
 void StyleSettings::SetStandardOS2Styles()
 {
-    CopyData();
-    mpData->SetStandardOS2Styles();
+    return; // no more style changes since NWF
 }
 
 // -----------------------------------------------------------------------
 
 void StyleSettings::SetStandardMacStyles()
 {
-    CopyData();
-    mpData->SetStandardMacStyles();
+    return; // no more style changes since NWF
 }
 
 // -----------------------------------------------------------------------
 
 void StyleSettings::SetStandardUnixStyles()
 {
-    CopyData();
-    mpData->SetStandardUnixStyles();
+    return; // no more style changes since NWF
 }
 
 
@@ -1023,6 +797,54 @@ void StyleSettings::CopyData()
 
 // -----------------------------------------------------------------------
 
+inline BOOL ImplIsBackOrWhite( const Color& rColor )
+{
+    UINT8 nLuminance = rColor.GetLuminance();
+    return ( nLuminance < 8 ) || ( nLuminance > 250 );
+}
+
+BOOL StyleSettings::IsHighContrastBlackAndWhite() const
+{
+    BOOL bBWOnly = TRUE;
+
+    // Only use B&W if fully B&W, like on GNOME.
+    // Some colors like CheckedColor and HighlightColor are not B&W in Windows Standard HC Black,
+    // and we don't want to be B&W then, so check these color first, very probably not B&W.
+    
+    // Unfortunately, GNOME uses a very very dark color (0x000033) instead of BLACK (0x000000)
+
+    if ( !ImplIsBackOrWhite( GetFaceColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetHighlightTextColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetWindowColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetWindowTextColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetButtonTextColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetButtonTextColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetGroupTextColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetLabelTextColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetDialogColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetFieldColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetMenuColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetMenuBarColor() ) )
+        bBWOnly = FALSE;
+    else if ( !ImplIsBackOrWhite( GetMenuHighlightColor() ) )
+        bBWOnly = FALSE;
+
+    return bBWOnly;
+}
+
+// -----------------------------------------------------------------------
+
 BOOL StyleSettings::operator ==( const StyleSettings& rSet ) const
 {
     if ( mpData == rSet.mpData )
@@ -1056,6 +878,7 @@ BOOL StyleSettings::operator ==( const S
          (mpData->mnTabControlStyle         == rSet.mpData->mnTabControlStyle)          &&
          (mpData->mnHighContrast			== rSet.mpData->mnHighContrast)             &&
          (mpData->mnUseSystemUIFonts		== rSet.mpData->mnUseSystemUIFonts)         &&
+         (mpData->mnUseFlatBorders   		== rSet.mpData->mnUseFlatBorders)           &&
          (mpData->mnUseFlatMenues   		== rSet.mpData->mnUseFlatMenues)            &&
          (mpData->maFaceColor               == rSet.mpData->maFaceColor)                &&
          (mpData->maCheckedColor            == rSet.mpData->maCheckedColor)             &&
@@ -1124,6 +947,8 @@ ImplMiscData::ImplMiscData()
     mnRefCount                  = 1;
     mnTwoDigitYearStart         = 1930;
     mnEnableATT					= ~0;
+    static const char* pEnv = getenv("SAL_DECIMALSEP_ENABLED" ); // set default without UI
+    mbEnableLocalizedDecimalSep = (pEnv != NULL) ? TRUE : FALSE;
 }
 
 // -----------------------------------------------------------------------
@@ -1133,6 +958,7 @@ ImplMiscData::ImplMiscData( const ImplMi
     mnRefCount                  = 1;
     mnTwoDigitYearStart         = rData.mnTwoDigitYearStart;
     mnEnableATT					= rData.mnEnableATT;
+    mbEnableLocalizedDecimalSep = rData.mbEnableLocalizedDecimalSep;
 }
 
 // -----------------------------------------------------------------------
@@ -1204,7 +1030,8 @@ BOOL MiscSettings::operator ==( const Mi
         return TRUE;
 
     if ( (mpData->mnTwoDigitYearStart   == rSet.mpData->mnTwoDigitYearStart ) &&
-         (mpData->mnEnableATT			== rSet.mpData->mnEnableATT ) )
+         (mpData->mnEnableATT			== rSet.mpData->mnEnableATT ) &&
+         (mpData->mbEnableLocalizedDecimalSep == rSet.mpData->mbEnableLocalizedDecimalSep ) )
         return TRUE;
     else
         return FALSE;
@@ -1214,16 +1041,12 @@ BOOL MiscSettings::operator ==( const Mi
 
 BOOL MiscSettings::GetEnableATToolSupport() const
 {
-#ifndef REMOTE_APPSERVER
     if( mpData->mnEnableATT == (USHORT)~0 )
     {
 #ifdef UNX
         mpData->mnEnableATT = 0;
 
-        DtIntegrator* pIntegrator = DtIntegrator::CreateDtIntegrator( NULL );
         static const char* pEnv = getenv("SAL_ACCESSIBILITY_ENABLED" );
-        if( ( pIntegrator && pIntegrator->GetDtType() == DtGNOME ) ||
-            ( pEnv && *pEnv ) )
         {
             char buf[16];
             // use 2 shells to suppress the eventual "gcontool-2 not found" message
@@ -1300,9 +1123,6 @@ BOOL MiscSettings::GetEnableATToolSuppor
     }
     return (BOOL)mpData->mnEnableATT;
     
-#else // REMOTE_APPSERVER
-    return FALSE;
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -1361,6 +1181,19 @@ void MiscSettings::SetEnableATToolSuppor
     }
 }
 
+void MiscSettings::SetEnableLocalizedDecimalSep( BOOL bEnable )
+{
+    CopyData();
+    mpData->mbEnableLocalizedDecimalSep = bEnable;
+}
+
+BOOL MiscSettings::GetEnableLocalizedDecimalSep() const
+{
+    return mpData->mbEnableLocalizedDecimalSep;
+}
+
+
+
 // =======================================================================
 
 ImplSoundData::ImplSoundData()
@@ -1547,9 +1380,9 @@ ImplHelpData::ImplHelpData()
 {
     mnRefCount                  = 1;
     mnOptions                   = 0;
-    mnTipDelay                  = 200;  // #112193# faster tooltips  
+    mnTipDelay                  = 500;
     mnTipTimeout                = 3000;
-    mnBalloonDelay              = 1000; // #112193# faster tooltips  
+    mnBalloonDelay              = 1500;
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/app/sound.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/sound.cxx,v
retrieving revision 1.6
retrieving revision 1.9
diff -u -p -u -r1.6 -r1.9
--- vcl/source/app/sound.cxx	27 Mar 2003 17:57:50 -0000	1.6
+++ vcl/source/app/sound.cxx	6 Jan 2004 13:12:46 -0000	1.9
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SOUND_CXX
-
 #ifndef _URLOBJ_HXX
 #include <tools/urlobj.hxx>
 #endif
@@ -73,17 +71,12 @@
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALSOUND_HXX
 #include <salsound.hxx>
 #endif
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
-#else
-#include <rmwindow.hxx>
-#include <rmsound.hxx>
-#endif
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -105,29 +98,27 @@
 #ifndef _SV_SOUND_HXX
 #include <sound.hxx>
 #endif
+#ifndef _SV_SALINST_HXX
+#include <salinst.hxx>
+#endif
+
 
-#pragma hdrstop
 
 // ----------------------
 // - SalSound-Callback	-
 // ----------------------
 
-#ifndef REMOTE_APPSERVER
-
 void SalSoundProc( void* pInst, SoundNotification eNotification, ULONG nError )
 {
 	( (Sound*) pInst )->ImplNotify( eNotification, nError );
 }
 
-#endif
-
 // ---------
 // - Sound -
 // ---------
 
 Sound::Sound( Window* pWindow ) :
 			mpWindow		( pWindow ),
-			mpSoundData		( NULL ),
 			mnDataLen		( 0UL ),
 			mnSoundLen		( 0UL ),
 			mnStartTime		( 0UL ),
@@ -137,29 +128,16 @@ Sound::Sound( Window* pWindow ) :
 			mbPlaying		( FALSE ),
 			mbLoopMode		( FALSE )
 {
-#ifndef REMOTE_APPSERVER
-
-	mpSound = new SalSound;
-	mpSound->Create();
+	mpSound = ImplGetSVData()->mpDefInst->CreateSalSound();
 
 	if( mpSound->IsValid() )
 		mpSound->SetNotifyProc( this, SalSoundProc );
-
-#else
-
-	mpSound = new RMSound;
-	mpSound->Create( this );
-	
-#endif
 }
 
 // -----------------------------------------------------------------------
 
 Sound::~Sound()
 {
-	if( mpSoundData )
-		SvMemFree( mpSoundData );
-
 	delete mpSound;
 }
 
@@ -203,23 +181,7 @@ BOOL Sound::SetSoundName( const XubStrin
 		mbLoopMode = FALSE;
 		bRet = TRUE;
 
-#ifdef REMOTE_APPSERVER
-		if( mpSoundData )
-		{
-			SvMemFree( mpSoundData );
-			mpSoundData = NULL;
-		}
-
-		// if IFace is init., destroy it and create a new one
-		if( maSoundName.Len() )
-		{
-			delete mpSound;
-			mpSound = new RMSound;
-			mpSound->Create( this );
-		}
-#else
-		mpSound->Init( NULL, rSoundName, mnSoundLen );
-#endif
+		mpSound->Init( rSoundName, mnSoundLen );
 	}
 	else if( mpSound->IsValid() )
 	{
@@ -230,11 +192,7 @@ BOOL Sound::SetSoundName( const XubStrin
         // #106654# Accept only local sound files
 		if( aSoundURL.GetProtocol() == INET_PROT_FILE )
 		{
-#ifdef REMOTE_APPSERVER
-			aSoundName = aSoundURL.GetMainURL( INetURLObject::NO_DECODE );
-#else
-			::utl::LocalFileHelper::ConvertURLToPhysicalName( aSoundURL.GetMainURL( INetURLObject::NO_DECODE ), aSoundName );
-#endif
+			utl::LocalFileHelper::ConvertURLToPhysicalName( aSoundURL.GetMainURL( INetURLObject::NO_DECODE ), aSoundName );
             bValidName = TRUE;
 		}
 		else if( aSoundURL.GetProtocol() == INET_PROT_NOT_VALID &&
@@ -250,11 +208,11 @@ BOOL Sound::SetSoundName( const XubStrin
 
             // #106654# Don't set bRet to true for invalid sound file
             // names, but init with empty string, anyway
-		    mpSound->Init( NULL, aSoundName, mnSoundLen );
+		    mpSound->Init( aSoundName, mnSoundLen );
 		}
 
         if( bValidName )
-		    bRet = mpSound->Init( NULL, aSoundName, mnSoundLen );
+		    bRet = mpSound->Init( aSoundName, mnSoundLen );
 	}
 
 	maSoundName = rSoundName;
@@ -269,38 +227,9 @@ BOOL Sound::SetSoundName( const XubStrin
 
 // -----------------------------------------------------------------------
 
-BOOL Sound::SetSoundData( const BYTE* pSoundData, ULONG nDataLen )
-{
-	BOOL bRet;
-
-	if( mpSoundData )
-		SvMemFree( mpSoundData );
-	
-	mpSoundData = (BYTE*) SvMemAlloc( mnDataLen = nDataLen );
-	HMEMCPY( mpSoundData, pSoundData, nDataLen );
-
-	if( mpSound->IsValid() )
-		bRet = mpSound->Init( NULL, mpSoundData, mnDataLen, mnSoundLen );
-	else
-		bRet = FALSE;
-
-	// if sound could not be initialized, but we've gotten _no_
-	// notification ==> create common error notification
-	if( !bRet && !mnErrorCode )
-		ImplNotify( SOUND_NOTIFY_ERROR, SOUNDERR_GENERAL_ERROR );
-
-	return bRet;
-}
-
-// -----------------------------------------------------------------------
-
 void Sound::SetStartTime( ULONG nStartTime ) 
 {
 	mnStartTime = nStartTime;
-
-#ifdef REMOTE_APPSERVER
-	mpSound->SetStartTime( nStartTime );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -308,10 +237,6 @@ void Sound::SetStartTime( ULONG nStartTi
 void Sound::SetPlayTime( ULONG nPlayTime )
 {
 	mnPlayTime = nPlayTime; 
-
-#ifdef REMOTE_APPSERVER
-	mpSound->SetStartTime( nPlayTime );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -319,10 +244,6 @@ void Sound::SetPlayTime( ULONG nPlayTime
 void Sound::SetLoopMode( BOOL bLoop ) 
 {
 	mbLoopMode = bLoop; 
-
-#ifdef REMOTE_APPSERVER
-	mpSound->SetStartTime( bLoop );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -330,10 +251,6 @@ void Sound::SetLoopMode( BOOL bLoop ) 
 void Sound::ClearError() 
 {
 	mnErrorCode = 0; 
-
-#ifdef REMOTE_APPSERVER
-	mpSound->ClearError();
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -344,13 +261,8 @@ void Sound::Play()
 
 	if( mpSound->IsValid() && !mnErrorCode )
 	{
-#ifndef REMOTE_APPSERVER
 		mpSound->Play( mnStartTime, mnPlayTime, mbLoopMode );
-#else
-		mpSound->Play();
-#endif
-
-		mbPlaying = TRUE;
+        mbPlaying = TRUE;
 	}
 	else
 		bRet = FALSE;
Index: vcl/source/app/stdtext.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/stdtext.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/app/stdtext.cxx	18 Sep 2000 17:05:35 -0000	1.1.1.1
+++ vcl/source/app/stdtext.cxx	6 Jan 2004 13:13:14 -0000	1.3
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_STDTEXT_CXX
-
 #ifndef _SV_SVIDS_HRC
 #include <svids.hrc>
 #endif
@@ -74,7 +72,7 @@
 #include <stdtext.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
Index: vcl/source/app/svapp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/svapp.cxx,v
retrieving revision 1.44
retrieving revision 1.50
diff -u -p -u -r1.44 -r1.50
--- vcl/source/app/svapp.cxx	15 Apr 2003 16:05:08 -0000	1.44
+++ vcl/source/app/svapp.cxx	25 Jun 2004 17:08:44 -0000	1.50
@@ -59,10 +59,7 @@
  *
  ************************************************************************/
 
-#define _SV_APP_CXX
-
 #include <stdio.h>
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -72,16 +69,6 @@
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
-#else
-#include "rvp.hxx"
-#include <rmwindow.hxx>
-#include <rmevents.hxx>
-#include <vos/thread.hxx>
-#ifndef _SV_MSGBOX_HXX
-#include <msgbox.hxx>
-#endif
-#endif
-
 #ifndef _VOS_PROCESS_HXX
 #include <vos/process.hxx>
 #endif
@@ -155,25 +139,21 @@
 #include <comphelper/processfactory.hxx>
 #endif
 
-#ifdef REMOTE_APPSERVER
-#include <osl/signal.h>
-#include <ooffice.hxx>
-#include <cppuhelper/implbase1.hxx>
-
-#include <com/sun/star/connection/XConnectionBroadcaster.hpp>
-#include <com/sun/star/io/XStreamListener.hpp>
-#include <com/sun/star/portal/client/XRmSync.hpp>
-#endif
-
 #include <osl/module.h>
 #include <osl/file.hxx>
 
 #include "osl/thread.h"
 #include "rtl/tencinfo.h"
 
-#if defined UNX
-#include "i18n_status.hxx"
-#endif // UNX
+#ifndef INCLUDED_RTL_INSTANCE_HXX
+#include <rtl/instance.hxx>
+#endif
+
+#ifndef _SV_SALIMESTATUS_HXX
+#include <salimestatus.hxx>
+#endif
+
+#include <utility>
 
 using namespace ::com::sun::star::uno;
 
@@ -906,44 +620,7 @@ USHORT Application::GetDispatchLevel()
 
 BOOL Application::AnyInput( USHORT nType )
 {
-#ifndef REMOTE_APPSERVER
-    return SalInstance::AnyInput( nType );
-#else
-    ImplSVData* pSVData = ImplGetSVData();
-
-    if( ( nType & ( INPUT_ANY ) ) == ( INPUT_ANY ) )
-    {
-        return( pSVData->mpRmEventQueue->HasMouseEvent() ||
-                pSVData->mpRmEventQueue->HasKeyEvent() ||
-                pSVData->mpRmEventQueue->HasPaintEvent() ||
-                pSVData->mpRmEventQueue->HasTimerEvent() ||
-                pSVData->mpRmEventQueue->HasOtherEvent() );
-    }
-    else if( ( nType & ( INPUT_MOUSEANDKEYBOARD ) ) == ( INPUT_MOUSEANDKEYBOARD ) )
-    {
-        return( pSVData->mpRmEventQueue->HasMouseEvent() ||
-                pSVData->mpRmEventQueue->HasKeyEvent() );
-    }
-    else
-    {
-        if( nType & INPUT_MOUSE )
-            return pSVData->mpRmEventQueue->HasMouseEvent();
-
-        if( nType & INPUT_KEYBOARD )
-            return pSVData->mpRmEventQueue->HasKeyEvent();
-
-        if( nType & INPUT_PAINT )
-            return pSVData->mpRmEventQueue->HasPaintEvent();
-
-        if( nType & INPUT_TIMER )
-            return pSVData->mpRmEventQueue->HasTimerEvent();
-
-        if( nType & INPUT_OTHER )
-            return pSVData->mpRmEventQueue->HasOtherEvent();
-    }
-
-    return FALSE;
-#endif
+    return (BOOL)ImplGetSVData()->mpDefInst->AnyInput( nType );
 }
 
 // -----------------------------------------------------------------------
@@ -1057,8 +732,8 @@ void Application::SetSettings( const All
             // Update all windows
             Window* pFirstFrame = pSVData->maWinData.mpFirstFrame;
             // Daten, die neu berechnet werden muessen, zuruecksetzen
-            long nOldDPIX;
-            long nOldDPIY;
+            long nOldDPIX(0);
+            long nOldDPIY(0);
             if ( pFirstFrame )
             {
                 nOldDPIX = pFirstFrame->mnDPIX;
@@ -1310,7 +979,6 @@ BOOL Application::PostUserEvent( ULONG& 
     pSVEvent->mpWindow  = NULL;
     pSVEvent->mbCall    = TRUE;
     rEventId = (ULONG)pSVEvent;
-#ifndef REMOTE_APPSERVER
     if ( ImplGetDefaultWindow()->ImplGetFrame()->PostEvent( pSVEvent ) )
         return TRUE;
     else
@@ -1319,31 +987,29 @@ BOOL Application::PostUserEvent( ULONG& 
         delete pSVEvent;
         return FALSE;
     }
-#else
-    ExtRmEvent* pEvt = new ExtRmEvent( RMEVENT_USEREVENT, NULL, pSVEvent );
-    ImplPostEvent( pEvt );
-    return TRUE;
-#endif
 }
 
 // -----------------------------------------------------------------------
 
 void Application::RemoveUserEvent( ULONG nUserEvent )
 {
-    ImplSVEvent* pSVEvent = (ImplSVEvent*)nUserEvent;
+    if(nUserEvent)
+	{
+		ImplSVEvent* pSVEvent = (ImplSVEvent*)nUserEvent;
 
-    DBG_ASSERT( !pSVEvent->mpWindow,
-                "Application::RemoveUserEvent(): Event is send to a window" );
-    DBG_ASSERT( pSVEvent->mbCall,
-                "Application::RemoveUserEvent(): Event is already removed" );
+		DBG_ASSERT( !pSVEvent->mpWindow,
+					"Application::RemoveUserEvent(): Event is send to a window" );
+		DBG_ASSERT( pSVEvent->mbCall,
+					"Application::RemoveUserEvent(): Event is already removed" );
+
+		if ( pSVEvent->mpWindow )
+		{
+			pSVEvent->mpWindow->ImplRemoveDel( &(pSVEvent->maDelData) );
+			pSVEvent->mpWindow = NULL;
+		}
 
-    if ( pSVEvent->mpWindow )
-    {
-        pSVEvent->mpWindow->ImplRemoveDel( &(pSVEvent->maDelData) );
-        pSVEvent->mpWindow = NULL;
-    }
-
-    pSVEvent->mbCall = FALSE;
+		pSVEvent->mbCall = FALSE;
+	}
 }
 
 // -----------------------------------------------------------------------
@@ -1935,12 +1481,8 @@ void Application::SetUnoWrapper( UnoWrap
 
 ::com::sun::star::uno::Reference< ::com::sun::star::awt::XDisplayConnection > Application::GetDisplayConnection()
 {
-#ifndef REMOTE_APPSERVER
     ImplSVData* pSVData = ImplGetSVData();
     return pSVData->mpDisplayConnection ? pSVData->mpDisplayConnection : new ::vcl::DisplayConnection;
-#else
-    return ::com::sun::star::uno::Reference< ::com::sun::star::awt::XDisplayConnection >();
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -2302,10 +1691,9 @@ BOOL Application::IsHeadlessModeEnabled(
 bool Application::CanToggleImeStatusWindow()
 {
-#if defined UNX
-    return vcl::I18NStatus::get().canToggleStatusWindow();
-#else // UNX
-    return false;
-#endif // UNX
+    ImplSVData* pSVData = ImplGetSVData();
+    if( ! pSVData->mpImeStatus )
+        pSVData->mpImeStatus  = pSVData->mpDefInst->CreateI18NImeStatus();
+    return pSVData->mpImeStatus->canToggle();
 }
 
 void Application::ShowImeStatusWindow(bool bShow)
@@ -2329,9 +1704,11 @@ void Application::ShowImeStatusWindow(bo
     ImplGetSVData()->maAppData.meShowImeStatusWindow = bShow
         ? ImplSVAppData::ImeStatusWindowMode_SHOW
         : ImplSVAppData::ImeStatusWindowMode_HIDE;
-#if defined UNX
-    vcl::I18NStatus::get().toggleStatusWindow();
-#endif
+
+    ImplSVData* pSVData = ImplGetSVData();
+    if( ! pSVData->mpImeStatus )
+        pSVData->mpImeStatus  = pSVData->mpDefInst->CreateI18NImeStatus();
+    pSVData->mpImeStatus->toggle();
 }
 
 bool Application::GetShowImeStatusWindowDefault()
@@ -2342,6 +1719,11 @@ bool Application::GetShowImeStatusWindow
         && aInfo.MaximumCharSize > 1;
 }
 
+const ::rtl::OUString& Application::GetDesktopEnvironment()
+{
+    return SalGetDesktopEnvironment();    
+}
+
 BOOL Application::IsAccessibilityEnabled()
 {
     return FALSE;
@@ -2362,4 +1744,32 @@ BOOL InitAccessBridge( BOOL bShowCancel,
     }
 
     return bRet;
+}
+
+// MT: AppProperty, AppEvent was in oldsv.cxx, but is still needed...
+// ------------------------------------------------------------------------
+
+TYPEINIT0(ApplicationProperty)
+
+// ------------------------------------------------------------------------
+
+static PropertyHandler* pHandler=NULL;
+
+void Application::Property( ApplicationProperty& rProp )
+{
+    if ( pHandler )
+        pHandler->Property( rProp );
+}
+
+void Application::SetPropertyHandler( PropertyHandler* p )
+{
+    if ( pHandler )
+        delete pHandler;
+    pHandler = p;
+}
+
+
+
+void Application::AppEvent( const ApplicationEvent& rAppEvent )
+{
 }
Index: vcl/source/app/svdata.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/svdata.cxx,v
retrieving revision 1.27.60.1
retrieving revision 1.34
diff -u -p -u -r1.27.60.1 -r1.34
--- vcl/source/app/svdata.cxx	7 Apr 2004 11:01:55 -0000	1.27.60.1
+++ vcl/source/app/svdata.cxx	25 Jun 2004 17:08:58 -0000	1.34
@@ -61,9 +61,6 @@
 
 #include <string.h>
 
-#define _SV_SVDATA_CXX
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -73,7 +70,6 @@
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
-#endif
 
 #ifndef _VOS_MUTEX_HXX
 #include <vos/mutex.hxx>
@@ -110,9 +106,6 @@
 #include <wrkwin.hxx>
 #endif
 
-#ifndef _VCL_UNOWRAP_HXX
-#include <unowrap.hxx>
-#endif
 #ifndef _VCL_UNOHELP_HXX
 #include <unohelp.hxx>
 #endif
@@ -121,6 +114,10 @@
 #include <button.hxx> // for Button::GetStandardText
 #endif
 
+#ifndef _SV_SALIMESTATUS_HXX
+#include <salimestatus.hxx>
+#endif
+
 #ifndef _COM_SUN_STAR_LANG_XMULTISERVICEFACTORY_HPP_
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #endif
@@ -155,6 +153,14 @@ using namespace rtl;
 // static SV-Data
 ImplSVData* pImplSVData = &private_aImplSVData;
+
+SalSystem* ImplGetSalSystem()
+{
+    ImplSVData* pSVData = ImplGetSVData();
+    if( ! pSVData->mpSalSystem )
+        pSVData->mpSalSystem = pSVData->mpDefInst->CreateSalSystem();
+    return pSVData->mpSalSystem;
+}
 
 // static SharedLib SV-Data
 ImplSVShlData aImplSVShlData;
 
@@ -210,12 +210,6 @@ void ImplDeInitSVData()
     if( pSVData->maGDIData.mpFontSubstConfig )
         delete pSVData->maGDIData.mpFontSubstConfig;
 
-    if ( pSVData->mpUnoWrapper )
-    {
-        pSVData->mpUnoWrapper->Destroy();
-        pSVData->mpUnoWrapper = NULL;
-    }
-
     if ( pSVData->maAppData.mpMSFTempFileName )
     {
         if ( pSVData->maAppData.mxMSF.is() )
@@ -231,9 +225,6 @@ void ImplDeInitSVData()
         delete pSVData->maAppData.mpMSFTempFileName;
         pSVData->maAppData.mpMSFTempFileName = NULL;
     }
-#ifdef REMOTE_APPSERVER
-    delete pSVData->mpPrinterEnvironment;
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -241,7 +232,6 @@ void ImplDeInitSVData()
 void ImplDestroySVData()
 {
     ImplSVData** ppSVData = (ImplSVData**)GetAppData( SHL_SV );
-    ImplSVData*  pSVData = *ppSVData;
 
     // delete global sharedlib data
     // ...
@@ -402,17 +392,17 @@ bool ImplInitAccessBridge(BOOL bAllowCan
 
     catch(::com::sun::star::java::JavaNotConfiguredException e)
     {
-        ResMgr *pResMgr = bErrorMessage ? ImplGetResMgr() : NULL;
-        
-        if( pResMgr && bAllowCancel )
+        if( bErrorMessage && bAllowCancel )
         {
+            ResMgr *pResMgr = ImplGetResMgr();
+
             String aTitle(ResId(SV_ACCESSERROR_JAVA_NOT_CONFIGURED, pResMgr));
             String aMessage(ResId(SV_ACCESSERROR_JAVA_MSG, pResMgr));
 
             aMessage += String(" ", 1, RTL_TEXTENCODING_ASCII_US);
             aMessage += String(ResId(SV_ACCESSERROR_OK_CANCEL_MSG, pResMgr));
 
-            int ret = ImplShowNativeMessageBox(
+            int ret = ImplGetSalSystem()->ShowNativeMessageBox(
                 aTitle,
                 ReplaceJavaErrorMessages(aMessage),
                 SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK_CANCEL,
@@ -428,17 +418,17 @@ bool ImplInitAccessBridge(BOOL bAllowCan
 
     catch(::com::sun::star::java::JavaVMCreationFailureException e)
     {
-        ResMgr *pResMgr = bErrorMessage ? ImplGetResMgr() : NULL;
-        
-        if( pResMgr && bAllowCancel )
+        if( bErrorMessage && bAllowCancel )
         {
+            ResMgr *pResMgr = ImplGetResMgr();
+
             String aTitle(ResId(SV_ACCESSERROR_FAULTY_JAVA, pResMgr));
             String aMessage(ResId(SV_ACCESSERROR_JAVA_MSG, pResMgr));
 
             aMessage += String(" ", 1, RTL_TEXTENCODING_ASCII_US);
             aMessage += String(ResId(SV_ACCESSERROR_OK_CANCEL_MSG, pResMgr));
 
-            int ret = ImplShowNativeMessageBox(
+            int ret = ImplGetSalSystem()->ShowNativeMessageBox(
                 aTitle,
                 ReplaceJavaErrorMessages(aMessage),
                 SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK_CANCEL,
@@ -454,17 +444,17 @@ bool ImplInitAccessBridge(BOOL bAllowCan
 
     catch(::com::sun::star::java::MissingJavaRuntimeException e)
     {
-        ResMgr *pResMgr = bErrorMessage ? ImplGetResMgr() : NULL;
-        
-        if( pResMgr && bAllowCancel )
+        if( bErrorMessage && bAllowCancel )
         {
+            ResMgr *pResMgr = ImplGetResMgr();
+
             String aTitle(ResId(SV_ACCESSERROR_MISSING_JAVA, pResMgr));
             String aMessage(ResId(SV_ACCESSERROR_JAVA_MSG, pResMgr));
 
             aMessage += String(" ", 1, RTL_TEXTENCODING_ASCII_US);
             aMessage += String(ResId(SV_ACCESSERROR_OK_CANCEL_MSG, pResMgr));
 
-            int ret = ImplShowNativeMessageBox(
+            int ret = ImplGetSalSystem()->ShowNativeMessageBox(
                 aTitle,
                 ReplaceJavaErrorMessages(aMessage),
                 SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK_CANCEL,
@@ -480,17 +470,17 @@ bool ImplInitAccessBridge(BOOL bAllowCan
 
     catch(::com::sun::star::java::JavaDisabledException e)
     {
-        ResMgr *pResMgr = bErrorMessage ? ImplGetResMgr() : NULL;
-        
-        if( pResMgr && bAllowCancel )
+        if( bErrorMessage && bAllowCancel )
         {
+            ResMgr *pResMgr = ImplGetResMgr();
+
             String aTitle(ResId(SV_ACCESSERROR_JAVA_DISABLED, pResMgr));
             String aMessage(ResId(SV_ACCESSERROR_JAVA_MSG, pResMgr));
 
             aMessage += String(" ", 1, RTL_TEXTENCODING_ASCII_US);
             aMessage += String(ResId(SV_ACCESSERROR_OK_CANCEL_MSG, pResMgr));
 
-            int ret = ImplShowNativeMessageBox(
+            int ret = ImplGetSalSystem()->ShowNativeMessageBox(
                 aTitle,
                 ReplaceJavaErrorMessages(aMessage),
                 SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK_CANCEL,
@@ -507,10 +497,10 @@ bool ImplInitAccessBridge(BOOL bAllowCan
 
     catch(::com::sun::star::uno::RuntimeException e)
     {
-        ResMgr *pResMgr = bErrorMessage ? ImplGetResMgr() : NULL;
-        
-        if( pResMgr )
+        if( bErrorMessage )
         {
+            ResMgr *pResMgr = ImplGetResMgr();
+
             String aTitle;
             String aMessage(ResId(SV_ACCESSERROR_BRIDGE_MSG, pResMgr));
 
@@ -533,7 +523,7 @@ bool ImplInitAccessBridge(BOOL bAllowCan
                     aMessage += String(" ", 1, RTL_TEXTENCODING_ASCII_US);
                     aMessage += String(ResId(SV_ACCESSERROR_OK_CANCEL_MSG, pResMgr));
 
-                    int ret = ImplShowNativeMessageBox(
+                    int ret = ImplGetSalSystem()->ShowNativeMessageBox(
                         aTitle, 
                         ReplaceJavaErrorMessages(aMessage), 
                         SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK_CANCEL,
@@ -547,7 +537,7 @@ bool ImplInitAccessBridge(BOOL bAllowCan
                 {
                     // The user tried to activate accessibility support using Tools-Options dialog,
                     // so we don't offer to terminate here !
-                    ImplShowNativeMessageBox(
+                    ImplGetSalSystem()->ShowNativeMessageBox(
                         aTitle, 
                         ReplaceJavaErrorMessages(aMessage), 
                         SALSYSTEM_SHOWNATIVEMSGBOX_BTNCOMBI_OK,
@@ -567,8 +557,6 @@ bool ImplInitAccessBridge(BOOL bAllowCan
 
 // -----------------------------------------------------------------------
 
-#ifndef REMOTE_APPSERVER
-
 Window* ImplFindWindow( const SalFrame* pFrame, Point& rSalFramePos )
 {
     ImplSVData* pSVData = ImplGetSVData();
@@ -588,18 +576,3 @@ Window* ImplFindWindow( const SalFrame* 
 
     return NULL;
 }
-
-#endif
-
-// -----------------------------------------------------------------------
-
-#ifdef REMOTE_APPSERVER
-
-void rvpExceptionHandler()
-{
-#ifdef DBG_UTIL
-    fprintf( stderr, "RVP exception caught!\n" );
-#endif
-}
-
-#endif
Index: vcl/source/app/svmain.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/svmain.cxx,v
retrieving revision 1.41
retrieving revision 1.49
diff -u -p -u -r1.41 -r1.49
--- vcl/source/app/svmain.cxx	11 Apr 2003 17:28:07 -0000	1.41
+++ vcl/source/app/svmain.cxx	28 May 2004 13:32:57 -0000	1.49
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SVMAIN_CXX
-
 #ifdef WNT
 #include <tools/prewin.h>
 #include <process.h>    // for _beginthreadex
@@ -76,9 +74,6 @@
 #include <svunx.h>
 #endif
 
-#ifndef _SV_SALDATA_HXX
-#include <saldata.hxx>
-#endif
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -128,7 +123,7 @@
 #include <image.hxx>
 #endif
 #ifndef _SV_RESMGR_HXX
-#include <resmgr.hxx>
+#include <tools/resmgr.hxx>
 #endif
 #ifndef _SV_ACCMGR_HXX
 #include <accmgr.hxx>
@@ -148,6 +143,18 @@
 #ifndef _SV_SETTINGS_HXX
 #include <settings.hxx>
 #endif
+#ifndef _VCL_UNOWRAP_HXX
+#include <unowrap.hxx>
+#endif
+#ifndef _SV_SALSYS_HXX
+#include <salsys.hxx>
+#endif
+#ifndef _SV_SALTIMER_HXX
+#include <saltimer.hxx>
+#endif
+#ifndef _SV_SALIMESTATUS_HXX
+#include <salimestatus.hxx>
+#endif
 
 #include <vos/process.hxx>
 #include <osl/file.hxx>
@@ -165,36 +175,9 @@ using namespace ::rtl;
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::lang;
 
-#ifdef REMOTE_APPSERVER
-#include <config.hxx>
-#include <ooffice.hxx>
-#include <rversion.h>
-#include <xevthdl.hxx>
-#include <rmevents.hxx>
-#include <rmprint.hxx>
-#include <outdev.h>
-#include <vos/mutex.hxx>
-#include <vos/timer.hxx>
-#include "rvp.hxx"
-#include <unotools/atom.hxx>
-
-
-#include <com/sun/star/portal/client/XRmStatus.hpp>
-#include <com/sun/star/portal/client/XRmSync.hpp>
-
-using namespace ::cppu;
-using namespace ::com::sun::star::portal::client;
-
-#ifdef UNX
-void SalData::Init (int *pIPointer, char *pCPointer[] )
-{};
-#endif /* UNX */
-
-#endif /* REMOTE_APPSERVER */
-
 #include <fontcfg.hxx>
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -252,11 +235,7 @@ public:
             }
             bIn = FALSE;
 
-#ifndef REMOTE_APPSERVER
             return vos::OSignalHandler::TAction_CallNextHandler;
-#else
-            return vos::OSignalHandler::TAction_KillApplication;
-#endif
         }
     }
 
@@ -312,23 +291,7 @@ BOOL InitVCL( const ::com::sun::star::un
     {
         pOwnSvApp = new Application_Impl();
     }
-#ifndef REMOTE_APPSERVER
     InitSalMain();
-#endif
-
-#ifdef WNT
-    // remember data, copied from WinMain
-    SalData* pData = GetAppSalData();
-    if ( pData )    // Im AppServer NULL
-    {
-        STARTUPINFO aSI;
-        aSI.cb = sizeof( aSI );
-        GetStartupInfo( &aSI );
-        pData->mhInst                   = GetModuleHandle( NULL );
-        pData->mhPrevInst               = NULL;
-        pData->mnCmdShow                = aSI.wShowWindow;
-    }
-#endif
 
     /*AllSettings aAS;
     Application::SetSettings( aAS );// ???
@@ -347,19 +310,13 @@ BOOL InitVCL( const ::com::sun::star::un
     vos::OStartupInfo   aStartInfo;
     rtl::OUString       aExeFileName;
 
-#ifdef REMOTE_APPSERVER
-    // create condition now to avoid race
-    pSVData->mpStartUpCond = new vos::OCondition;
-#endif
 
     // Sal initialisieren
-#ifndef REMOTE_APPSERVER
     RTL_LOGFILE_CONTEXT_TRACE( aLog, "{ ::CreateSalInstance" );
     pSVData->mpDefInst = CreateSalInstance();
     if ( !pSVData->mpDefInst )
         return FALSE;
     RTL_LOGFILE_CONTEXT_TRACE( aLog, "} ::CreateSalInstance" );
-#endif
 
 	// Initialize application instance (should be done after initialization of VCL SAL part)
     if( pSVData->mpApp )
@@ -367,24 +324,6 @@ BOOL InitVCL( const ::com::sun::star::un
         // soffice/sfx implementation creates the global service manager
         pSVData->mpApp->Init();
 
-#ifdef REMOTE_APPSERVER
-    {
-    Reference< XMultiServiceFactory > rSMgr = ::comphelper::getProcessServiceFactory();
-
-    pSVData->mpRmEventQueue = new RmEventQueue;
-    pSVData->mpWindowObjectMutex = new vos::OMutex;
-    pSVData->maAppData.mpSolarMutex = new ImplRemoteYieldMutex;
-
-    pSVData->maGDIData.mpScreenFontList   = new ImplDevFontList;
-    pSVData->maGDIData.mpScreenFontCache  = new ImplFontCache( FALSE );
-
-    pSVData->maAppData.mpSolarMutex->acquire(); // mutex should be aquired for startup
-
-//    ImplInitRemotePrinterList();
-    }
-
-#endif
-
     // Den AppFileName gleich holen und absolut machen, bevor das
     // WorkingDirectory sich aendert...
     aStartInfo.getExecutableFile( aExeFileName );
@@ -418,11 +359,5 @@ void DeInitVCL()
        pSVData->maAppData.mpAccessList = NULL;
    }
 
-    // globale daten wieder freigeben
-#ifndef REMOTE_APPSERVER
-    SalSound::Release();
-    SalOpenGL::Release();
-#endif
-
     // free global data
     delete pSVData->maGDIData.mpGrfConverter; 
@@ -499,79 +424,11 @@ void DeInitVCL()
         pSVData->mpResMgr = NULL;
     }
 
-#ifdef REMOTE_APPSERVER
-    if( pSVData->mxClientFactory.is() )
-    {
-        try
-        {
-            pSVData->mxClientFactory = Reference < XMultiServiceFactory >();
-        }
-        catch(::com::sun::star::uno::Exception&)
-        {
-        }
-    }
-
-    if( pSVData->mxMultiFactory.is() )
-    {
-        try
-        {
-            pSVData->mxMultiFactory.clear();
-        }
-        catch(::com::sun::star::uno::Exception&)
-        {
-        }
-
-    }
-    CORmStarOffice::eraseRemoteCaches();
-    if( pSVData->mxStatus.is() )
-    {
-        try
-        {
-            // #93174 DO NOT SYNC HERE - 
-            // the client's sync object might already be destructed by the ORmRemoteClientFactory destructor
-            // CHECK_FOR_RVPSYNC_NORMAL()
-
-            delete pSVData->mpRVPNormalSync;
-            delete pSVData->mpRVPSoundSync;
-            delete pSVData->mpAtoms;
-
-            pSVData->mxStatus->Quit();
-            pSVData->mxStatus = Reference < ::com::sun::star::portal::client::XRmStatus >();
-        }
-        catch(::com::sun::star::uno::Exception&)
-        {
-        }
-    }
-
-    if( pSVData->mpApp )
-        // call deinit to deinitialize application class
-        // soffice/sfx implementation disposes the global service manager
-        // Warning: After this call you can't call uno services
-        pSVData->mpApp->DeInit();
-
-    pSVData->maAppData.mpSolarMutex->release();
-    delete pSVData->maAppData.mpSolarMutex;
-    pSVData->maAppData.mpSolarMutex = NULL;
-    pSVData->mpOTimer->release();
-    pSVData->mpOTimer = NULL;
-    delete pSVData->mpRmEventQueue;
-    pSVData->mpRmEventQueue = NULL;
-    delete pSVData->mpWindowObjectMutex;
-    pSVData->mpWindowObjectMutex = NULL;
-
-    if ( pSVData->mpKeyNames )
-    {
-        for( String* pObj = pSVData->mpKeyNames->First(); pObj; pObj = pSVData->mpKeyNames->Next() )
-            delete pObj;
-        delete pSVData->mpKeyNames;
-    }
-#else
     if( pSVData->mpApp )
         // call deinit to deinitialize application class
         // soffice/sfx implementation disposes the global service manager
         // Warning: After this call you can't call uno services
         pSVData->mpApp->DeInit();
-#endif
 
     if ( pSVData->maAppData.mpSettings )
     {
@@ -624,6 +481,13 @@ void DeInitVCL()
     if ( pSVData->maAppData.mpFirstEventHook )
         ImplFreeEventHookData();
 
+	// #114285# Moved here from ImplDeInitSVData...
+    if ( pSVData->mpUnoWrapper )
+    {
+        pSVData->mpUnoWrapper->Destroy();
+        pSVData->mpUnoWrapper = NULL;
+    }
+
     ImplDeletePrnQueueList();
     delete pSVData->maGDIData.mpScreenFontList;
     pSVData->maGDIData.mpScreenFontList = NULL;
@@ -633,16 +497,22 @@ void DeInitVCL()
 
     ResMgr::DestroyAllResMgr();
 
+	// destroy all Sal interfaces before destorying the instance
+	// and thereby unloading the plugin
+	delete pSVData->mpImeStatus;
+	pSVData->mpImeStatus = NULL;
+	delete pSVData->mpSalSystem;
+	pSVData->mpSalSystem = NULL;
+	delete pSVData->mpSalTimer;
+	pSVData->mpSalTimer = NULL;
+
     // Sal deinitialisieren
-#ifndef REMOTE_APPSERVER
     DestroySalInstance( pSVData->mpDefInst );
-#endif
 
     DeInitTools();
 
-#ifndef REMOTE_APPSERVER
     DeInitSalMain();
-#endif
+
     if( pOwnSvApp )
     {
         delete pOwnSvApp;
Index: vcl/source/app/timer.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/timer.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.4
diff -u -p -u -r1.1.1.1 -r1.4
--- vcl/source/app/timer.cxx	18 Sep 2000 17:05:35 -0000	1.1.1.1
+++ vcl/source/app/timer.cxx	6 Jan 2004 13:15:29 -0000	1.4
@@ -59,19 +59,13 @@
  *
  ************************************************************************/
 
-#define _SV_TIMER_CXX
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALTIMER_HXX
 #include <saltimer.hxx>
 #endif
-#else
-#include <rmevents.hxx>
-#endif
 
 #ifndef _TIME_HXX
 #include <tools/time.hxx>
@@ -83,6 +77,9 @@
 #ifndef _SV_SVAPP_HXX
 #include <svapp.hxx>
 #endif
+#ifndef _SV_SALINST_HXX
+#include <salinst.hxx>
+#endif
 
 #define protected public
 #ifndef _SV_TIMER_HXX
@@ -90,7 +87,7 @@
 #endif
 #undef protected
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -134,12 +131,8 @@ void ImplDeInitTimer()
 
 		pSVData->mpFirstTimerData	= NULL;
 		pSVData->mnTimerPeriod		= 0;
-#ifndef REMOTE_APPSERVER
-		SalTimer::Stop();
-#else
-		if ( pSVData->mpOTimer )
-			pSVData->mpOTimer->StopTimer();
-#endif
+        delete pSVData->mpSalTimer;
+        pSVData->mpSalTimer = NULL;
 	}
 }
 
@@ -150,24 +143,11 @@ static void ImplStartTimer( ImplSVData* 
 	if ( !nMS )
 		nMS = 1;
 
-#ifndef REMOTE_APPSERVER
 	if ( nMS != pSVData->mnTimerPeriod )
 	{
 		pSVData->mnTimerPeriod = nMS;
-		SalTimer::Start( nMS );
+		pSVData->mpSalTimer->Start( nMS );
 	}
-#else
-	pSVData->mnTimerPeriod = nMS;
-	if ( !pSVData->mpOTimer )
-	{
-		pSVData->mpOTimer = new VclOTimer;
-		pSVData->mpOTimer->acquire();
-	}
-	else
-		pSVData->mpOTimer->StopTimer();
-	pSVData->mpOTimer->setRemainingTime( nMS, 0 );
-	pSVData->mpOTimer->StartTimer();
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -275,12 +255,7 @@ void ImplTimerCallbackProc()
 	// Wenn keine Timer mehr existieren, dann Clock loeschen
 	if ( !pSVData->mpFirstTimerData )
 	{
-#ifndef REMOTE_APPSERVER
-		SalTimer::Stop();
-#else
-		if ( pSVData->mpOTimer )
-			pSVData->mpOTimer->StopTimer();
-#endif
+        pSVData->mpSalTimer->Stop();
 		pSVData->mnTimerPeriod = MAX_TIMER_PERIOD;
 	}
 	else
@@ -292,49 +267,6 @@ void ImplTimerCallbackProc()
 
 // =======================================================================
 
-#ifdef REMOTE_APPSERVER
-
-VclOTimer::VclOTimer() :
-	maTimeoutHdl( LINK( this, VclOTimer, Timeout ) )
-{
-	mbSend = FALSE;
-}
-
-void SAL_CALL VclOTimer::onShot()
-{
-	stop(); // start wird durch ImplTimerCallbackProc() gerufen
-	if ( !mbSend )
-	{
-		mbSend = TRUE;
-		if ( !Application::PostUserEvent( maTimeoutHdl ) )
-		{
-			mbSend = FALSE;
-			start();
-		}
-	}
-}
-
-IMPL_LINK( VclOTimer, Timeout, void*, EMPTYARG )
-{
-	mbSend = FALSE;
-	ImplTimerCallbackProc();
-	return 0;
-}
-
-void VclOTimer::StartTimer()
-{
-	start();
-}
-
-void VclOTimer::StopTimer()
-{
-	stop();
-}
-
-#endif
-
-// =======================================================================
-
 Timer::Timer()
 {
 	mpTimerData 	= NULL;
@@ -402,9 +334,11 @@ void Timer::Start()
 		if ( !pSVData->mpFirstTimerData )
 		{
 			pSVData->mnTimerPeriod = MAX_TIMER_PERIOD;
-#ifndef REMOTE_APPSERVER
-			SalTimer::SetCallback( ImplTimerCallbackProc );
-#endif
+            if( ! pSVData->mpSalTimer )
+            {
+                pSVData->mpSalTimer = pSVData->mpDefInst->CreateSalTimer();
+                pSVData->mpSalTimer->SetCallback( ImplTimerCallbackProc );
+            }
 		}
 
 		// insert timer and start
Index: vcl/source/app/unohelp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/unohelp.cxx,v
retrieving revision 1.27
retrieving revision 1.29
diff -u -p -u -r1.27 -r1.29
--- vcl/source/app/unohelp.cxx	24 Apr 2003 16:31:14 -0000	1.27
+++ vcl/source/app/unohelp.cxx	1 Dec 2003 13:09:39 -0000	1.29
@@ -59,7 +59,7 @@
  *
  ************************************************************************/
 
-#pragma hdrstop
+
 
 #include <unohelp.hxx>
 
@@ -118,8 +118,8 @@ using namespace ::rtl;
 
 struct VCLRegServiceInfo
 {
-	sal_Char*	pLibName;
-	sal_Bool	bHasSUPD;
+	const sal_Char*		pLibName;
+	sal_Bool			bHasSUPD;
 };
 
 static VCLRegServiceInfo aVCLComponentsArray[] =
Index: vcl/source/control/button.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/button.cxx,v
retrieving revision 1.21.116.1
retrieving revision 1.27
diff -u -p -u -r1.21.116.1 -r1.27
--- vcl/source/control/button.cxx	9 Jan 2004 18:13:43 -0000	1.21.116.1
+++ vcl/source/control/button.cxx	10 May 2004 15:45:59 -0000	1.27
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_BUTTON_CXX
-
 #include <tools/debug.hxx>
 
 #ifndef _SV_SVIDS_HRC
@@ -93,8 +91,8 @@
 #ifndef _SV_FIXED_HXX
 #include <fixed.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_BUTTON_HXX
 #include <button.hxx>
@@ -102,12 +100,15 @@
 #ifndef _VCL_CONTROLLAYOUT_HXX
 #include <controllayout.hxx>
 #endif
+#ifndef _SV_NATIVEWIDGET_HXX
+#include <salnativewidgets.hxx>
+#endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -307,7 +308,28 @@ void PushButton::ImplInitSettings( BOOL 
     }
 
     if ( bBackground )
-        SetBackground();
+    {
+        Window* pParent = GetParent();
+        if ( (pParent->IsChildTransparentModeEnabled() && !IsControlBackground() ) 
+            || IsNativeControlSupported( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL ) )
+        {
+            EnableChildTransparentMode( TRUE );
+            SetParentClipMode( PARENTCLIPMODE_NOCLIP );
+            SetPaintTransparent( TRUE );
+            SetBackground();
+        }
+        else
+        {
+            EnableChildTransparentMode( FALSE );
+            SetParentClipMode( 0 );
+            SetPaintTransparent( FALSE );
+
+            if ( IsControlBackground() )
+                SetBackground( GetControlBackground() );
+            else
+                SetBackground( pParent->GetBackground() );
+        }
+    }
 }
 
 // -----------------------------------------------------------------------
@@ -841,27 +863,111 @@ void PushButton::ImplDrawPushButton( boo
     if( !bLayout )
         HideFocus();
 
-    const StyleSettings&    rStyleSettings = GetSettings().GetStyleSettings();
     USHORT                  nButtonStyle = mnButtonState;
     Point                   aPoint;
     Size                    aOutSz( GetOutputSizePixel() );
     Rectangle               aRect( aPoint, aOutSz );
     Rectangle               aInRect = aRect;
     Rectangle               aTextRect;
+    BOOL                    bNativeOK = FALSE;
 
     // adjust style if button should be rendered 'pressed'
     if ( mbPressed )
         nButtonStyle |= BUTTON_DRAW_PRESSED;
 
-    // draw PushButtonFrame, aInRect has content size afterwards
-    if( ! bLayout )
-        ImplDrawPushButtonFrame( this, aInRect, nButtonStyle );
+    // TODO: move this to Window class or make it a member !!!
+    ControlType aCtrlType = 0;
+    switch( GetParent()->GetType() )
+    {
+        case WINDOW_LISTBOX:
+        case WINDOW_MULTILISTBOX:
+        case WINDOW_TREELISTBOX:
+            aCtrlType = CTRL_LISTBOX;
+            break;
+
+        case WINDOW_COMBOBOX:
+        case WINDOW_PATTERNBOX:			
+        case WINDOW_NUMERICBOX:			
+        case WINDOW_METRICBOX:			
+        case WINDOW_CURRENCYBOX:
+        case WINDOW_DATEBOX:		
+        case WINDOW_TIMEBOX:			
+        case WINDOW_LONGCURRENCYBOX:
+            aCtrlType = CTRL_COMBOBOX;
+            break;
+        default:
+            break;
+    }
+
+    BOOL bDropDown = ( IsSymbol() && (GetSymbol()==SYMBOL_SPIN_DOWN) && !GetText().Len() );
+
+    if( bDropDown && (aCtrlType == CTRL_COMBOBOX || aCtrlType == CTRL_LISTBOX ) )
+    {
+        if( GetParent()->IsNativeControlSupported( aCtrlType, PART_ENTIRE_CONTROL) )
+        {
+            if( !GetParent()->IsNativeControlSupported( aCtrlType, PART_BUTTON_DOWN) )
+                // skip painting if the button was already drawn by the theme
+                bNativeOK = TRUE;
+            else
+            {
+                // let the theme draw it, note we then need support
+                // for CTRL_LISTBOX/PART_BUTTON_DOWN and CTRL_COMBOBOX/PART_BUTTON_DOWN
+
+                ImplControlValue    aControlValue;
+                Region              aCtrlRegion( aInRect );
+                ControlState        nState = 0;
 
-    // draw content
-    ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+                if ( mbPressed ) 						nState |= CTRL_STATE_PRESSED;
+                if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+                if ( HasFocus() )						nState |= CTRL_STATE_FOCUSED;
+                if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+                if ( Window::IsEnabled() ) 				nState |= CTRL_STATE_ENABLED;
 
-    if( ! bLayout )
+                if ( IsMouseOver() && aInRect.IsInside( GetPointerPosPixel() ) )
+                    nState |= CTRL_STATE_ROLLOVER;
+
+                bNativeOK = DrawNativeControl( aCtrlType, PART_BUTTON_DOWN, aCtrlRegion, nState,
+                                                aControlValue, rtl::OUString() );
+            }
+        }
+    }
+
+    if( bNativeOK )
+        return;
+
+    if ( (bNativeOK=IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
     {
+        ImplControlValue aControlValue;
+        Region			 aCtrlRegion( aInRect );
+        ControlState	 nState = 0;
+
+        if ( mbPressed ) 						nState |= CTRL_STATE_PRESSED;
+        if ( mnButtonState & BUTTON_DRAW_PRESSED ) nState |= CTRL_STATE_PRESSED;
+        if ( HasFocus() )						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( Window::IsEnabled() ) 				nState |= CTRL_STATE_ENABLED;
+
+        if ( IsMouseOver() && aInRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+	     				aControlValue, rtl::OUString()/*PushButton::GetText()*/ );
+
+        // draw frame into invisible window to have aInRect modified correctly
+        // but do not shift the inner rect for pressed buttons (ie remove BUTTON_DRAW_PRESSED)
+        // this assumes the theme has enough visual cues to signalize the button was pressed
+        //Window aWin( this );
+        //ImplDrawPushButtonFrame( &aWin, aInRect, nButtonStyle & ~BUTTON_DRAW_PRESSED );
+
+        // looks better this way as symbols were displaced slightly using the above approach
+        aInRect.Top()+=4;
+        aInRect.Bottom()-=4;
+        aInRect.Left()+=4;
+        aInRect.Right()-=4;
+
+        // draw content using the same aInRect as non-native VCL would do
+        ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+
         maFocusRect = aTextRect;
         if( !maFocusRect.IsEmpty() )
         {
@@ -870,21 +976,97 @@ void PushButton::ImplDrawPushButton( boo
             maFocusRect.Right()++;
             maFocusRect.Bottom()++;
             if ( HasFocus() )
-            {
                 ShowFocus( maFocusRect );
-            }
         }
     }
+
+    if ( bNativeOK == FALSE )
+    {
+        // draw PushButtonFrame, aInRect has content size afterwards
+        if( ! bLayout )
+            ImplDrawPushButtonFrame( this, aInRect, nButtonStyle );
+
+        // draw content
+        ImplDrawPushButtonContent( this, 0, aInRect, aTextRect, bLayout );
+
+        if( ! bLayout )
+        {
+            maFocusRect = aTextRect;
+            if( !maFocusRect.IsEmpty() )
+            {
+                maFocusRect.Left()--;
+                maFocusRect.Top()--;
+                maFocusRect.Right()++;
+                maFocusRect.Bottom()++;
+                if ( HasFocus() )
+                {
+                    ShowFocus( maFocusRect );
+                }
+            }
+        } 
+    }
 }
 
 // -----------------------------------------------------------------------
 
 void PushButton::ImplSetDefButton( BOOL bSet )
 {
+    Size aSize( GetSizePixel() );
+    Point aPos( GetPosPixel() );
+    int dLeft(0), dRight(0), dTop(0), dBottom(0);
+    BOOL bSetPos = FALSE;
+
+    if ( (IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        Region aBoundingRgn, aContentRgn;
+        Rectangle aCtrlRect( 0, 0, 80, 20 ); // use a constant size to avoid accumulating
+                                             // will not work if the theme has dynamic adornment sizes
+        ImplControlValue aControlValue;
+        Region			 aCtrlRegion( aCtrlRect );
+        ControlState	 nState = CTRL_STATE_DEFAULT|CTRL_STATE_ENABLED;
+
+        // get native size of a 'default' button
+        // and adjust the VCL button if more space for adornment is required
+        if( GetNativeControlRegion( CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion,
+                                nState, aControlValue, rtl::OUString(),
+								aBoundingRgn, aContentRgn ) )
+        {
+            Rectangle aCont(aContentRgn.GetBoundRect());
+            Rectangle aBound(aBoundingRgn.GetBoundRect());
+
+            dLeft = aCont.Left() - aBound.Left();
+            dTop = aCont.Top() - aBound.Top();
+            dRight = aBound.Right() - aCont.Right();
+            dBottom = aBound.Bottom() - aCont.Bottom();
+            bSetPos = dLeft || dTop || dRight || dBottom;
+        }
+    }
+
     if ( bSet )
+    {
+        if( !(mnButtonState & BUTTON_DRAW_DEFAULT) && bSetPos )
+        {
+            // adjust pos/size when toggling from non-default to default
+            aPos.Move(-dLeft, -dTop);
+            aSize.Width() += dLeft + dRight;
+            aSize.Height() += dTop + dBottom;
+        }
         mnButtonState |= BUTTON_DRAW_DEFAULT;
+    }
     else
+    {
+        if( (mnButtonState & BUTTON_DRAW_DEFAULT) && bSetPos )
+        {
+            // adjust pos/size when toggling from default to non-default
+            aPos.Move(dLeft, dTop);
+            aSize.Width() -= dLeft + dRight;
+            aSize.Height() -= dTop + dBottom;
+        }
         mnButtonState &= ~BUTTON_DRAW_DEFAULT;
+    }
+    if( bSetPos )
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+
     Invalidate();
 }
 
@@ -1080,9 +1262,23 @@ void PushButton::Draw( OutputDevice* pDe
     pDev->SetMapMode();
     pDev->SetFont( aFont );
     if ( nFlags & WINDOW_DRAW_MONO )
+	{
         pDev->SetTextColor( Color( COL_BLACK ) );
+	}
     else
+	{
         pDev->SetTextColor( GetTextColor() );
+
+		// DecoView uses the FaceColor...
+		AllSettings aSettings = pDev->GetSettings();
+		StyleSettings aStyleSettings = aSettings.GetStyleSettings();
+		if ( IsControlBackground() )
+			aStyleSettings.SetFaceColor( GetControlBackground() );
+		else
+			aStyleSettings.SetFaceColor( GetSettings().GetStyleSettings().GetFaceColor() );
+		aSettings.SetStyleSettings( aStyleSettings );
+		pDev->SetSettings( aSettings );
+	}
     pDev->SetTextFillColor();
 
     DecorationView aDecoView( pDev );
@@ -1186,6 +1382,73 @@ void PushButton::DataChanged( const Data
 
 // -----------------------------------------------------------------------
 
+long PushButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( pMouseEvt->IsEnterWindow() || pMouseEvt->IsLeaveWindow() )
+        {
+            // trigger redraw as mouse over state has changed
+
+            // TODO: move this to Window class or make it a member !!!
+            ControlType aCtrlType = 0;
+            switch( GetParent()->GetType() )
+            {
+                case WINDOW_LISTBOX:
+                case WINDOW_MULTILISTBOX:
+                case WINDOW_TREELISTBOX:
+                    aCtrlType = CTRL_LISTBOX;
+                    break;
+
+                case WINDOW_COMBOBOX:
+                case WINDOW_PATTERNBOX:			
+                case WINDOW_NUMERICBOX:			
+                case WINDOW_METRICBOX:			
+                case WINDOW_CURRENCYBOX:
+                case WINDOW_DATEBOX:		
+                case WINDOW_TIMEBOX:			
+                case WINDOW_LONGCURRENCYBOX:
+                    aCtrlType = CTRL_COMBOBOX;
+                    break;
+                default:
+                    break;
+            }
+
+            BOOL bDropDown = ( IsSymbol() && (GetSymbol()==SYMBOL_SPIN_DOWN) && !GetText().Len() );
+
+            if( bDropDown && GetParent()->IsNativeControlSupported( aCtrlType, PART_ENTIRE_CONTROL) && 
+                   !GetParent()->IsNativeControlSupported( aCtrlType, PART_BUTTON_DOWN) )
+            {
+                Window *pBorder = GetParent()->GetWindow( WINDOW_BORDER );
+                if(aCtrlType == CTRL_COMBOBOX)
+                {
+                    // only paint the button part to avoid flickering of the combobox text
+                    Point aPt;
+                    Rectangle aClipRect( aPt, GetOutputSizePixel() );
+                    aClipRect.SetPos(pBorder->ScreenToOutputPixel(OutputToScreenPixel(aClipRect.TopLeft())));
+                    pBorder->Invalidate( aClipRect );
+                }
+                else
+                {
+                    pBorder->Invalidate( INVALIDATE_NOERASE );
+                    pBorder->Update();
+                }
+            }
+            else if( IsNativeControlSupported(CTRL_PUSHBUTTON, PART_ENTIRE_CONTROL) )
+            {
+                Invalidate();
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void PushButton::Toggle()
 {
     ImplCallEventListeners( VCLEVENT_PUSHBUTTON_TOGGLE );
@@ -1635,7 +1898,8 @@ void RadioButton::ImplInitSettings( BOOL
     if ( bBackground )
     {
         Window* pParent = GetParent();
-        if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+        if ( (pParent->IsChildTransparentModeEnabled() && !IsControlBackground() ) 
+            || IsNativeControlSupported( CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL ) )
         {
             EnableChildTransparentMode( TRUE );
             SetParentClipMode( PARENTCLIPMODE_NOCLIP );
@@ -1669,7 +1933,31 @@ void RadioButton::DrawRadioButtonState( 
 void RadioButton::ImplDrawRadioButtonState()
 {
     USHORT nStyle = 0;
+    BOOL   bNativeOK = FALSE;
+
+    // no native drawing for image radio buttons
+    if ( !maImage && (bNativeOK=IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        ImplControlValue		    aControlValue( mbChecked ? BUTTONVALUE_ON : BUTTONVALUE_OFF, rtl::OUString(), 0 );
+        Rectangle					aCtrlRect( maStateRect.TopLeft(), maStateRect.GetSize() );
+        Region						aCtrlRegion( aCtrlRect );
+        ControlState				nState = 0;
+
+        if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+        if ( HasFocus() ) 						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( IsEnabled() )						nState |= CTRL_STATE_ENABLED;
+
+        if ( IsMouseOver() && maMouseRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+                    aControlValue,rtl::OUString() );
+
+    }
 
+if ( bNativeOK == FALSE )
+{
     // kein Image-RadioButton
     if ( !maImage )
     {
@@ -1762,6 +2050,7 @@ void RadioButton::ImplDrawRadioButtonSta
             ShowFocus( maFocusRect );
     }
 }
+}
 
 // -----------------------------------------------------------------------
 
@@ -1812,6 +2101,7 @@ void RadioButton::ImplDraw( OutputDevice
             rFocusRect = rMouseRect;
             rFocusRect.Left()--;
             rFocusRect.Right()++;
+            //rFocusRect.Bottom()++;  // provide space for mnemonic underline
 
             rMouseRect.Left()   = rPos.X();
             rStateRect.Left()   = rPos.X();
@@ -1910,10 +2200,11 @@ void RadioButton::ImplDrawRadioButton( b
     aImageSize.Width()  = CalcZoom( aImageSize.Width() );
     aImageSize.Height() = CalcZoom( aImageSize.Height() );
 
+    // Draw control text
     ImplDraw( this, 0, Point(), GetOutputSizePixel(),
               aImageSize, IMPL_SEP_BUTTON_IMAGE, maStateRect, maMouseRect, maFocusRect, bLayout );
 
-    if( !bLayout )
+    if( !bLayout || (IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL)==TRUE) )
     {
         if ( !maImage )
         {
@@ -2352,6 +2643,35 @@ void RadioButton::DataChanged( const Dat
 
 // -----------------------------------------------------------------------
 
+long RadioButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_RADIOBUTTON, PART_ENTIRE_CONTROL) )
+            {
+                if( ( maMouseRect.IsInside( GetPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetLastPointerPosPixel()) ) ||
+                    ( maMouseRect.IsInside( GetLastPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetPointerPosPixel()) ) ||
+                     pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow() )
+                {
+                    Invalidate( maStateRect );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void RadioButton::Toggle()
 {
     ImplCallEventListeners( VCLEVENT_RADIOBUTTON_TOGGLE );
@@ -2611,7 +2931,8 @@ void CheckBox::ImplInitSettings( BOOL bF
     if ( bBackground )
     {
         Window* pParent = GetParent();
-        if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+        if ( ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+            || IsNativeControlSupported( CTRL_CHECKBOX, PART_ENTIRE_CONTROL ) )
         {
             EnableChildTransparentMode( TRUE );
             SetParentClipMode( PARENTCLIPMODE_NOCLIP );
@@ -2651,18 +2972,46 @@ void CheckBox::ImplLoadRes( const ResId&
 
 void CheckBox::ImplDrawCheckBoxState()
 {
-    USHORT nStyle = mnButtonState;
-    if ( !IsEnabled() )
-        nStyle |= BUTTON_DRAW_DISABLED;
-    if ( meState == STATE_DONTKNOW )
-        nStyle |= BUTTON_DRAW_DONTKNOW;
-    else if ( meState == STATE_CHECK )
-        nStyle |= BUTTON_DRAW_CHECKED;
-    Image aImage = GetCheckImage( GetSettings(), nStyle );
-    if ( IsZoom() )
-        DrawImage( maStateRect.TopLeft(), maStateRect.GetSize(), aImage );
-    else
-        DrawImage( maStateRect.TopLeft(), aImage );
+    bool	bNativeOK = TRUE;
+
+    if ( (bNativeOK=IsNativeControlSupported(CTRL_CHECKBOX, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        ImplControlValue    aControlValue( meState == STATE_CHECK ? BUTTONVALUE_ON : BUTTONVALUE_OFF, rtl::OUString(), 0 );
+        Region              aCtrlRegion( maStateRect );
+        ControlState        nState = 0;
+
+        if ( HasFocus() ) 						nState |= CTRL_STATE_FOCUSED;
+        if ( mnButtonState & BUTTON_DRAW_DEFAULT )	nState |= CTRL_STATE_DEFAULT;
+        if ( mnButtonState & BUTTON_DRAW_PRESSED )	nState |= CTRL_STATE_PRESSED;
+        if ( IsEnabled() )						nState |= CTRL_STATE_ENABLED;
+
+        if ( meState == STATE_CHECK )
+            aControlValue.setTristateVal( BUTTONVALUE_ON );
+        else if ( meState == STATE_DONTKNOW )					
+            aControlValue.setTristateVal( BUTTONVALUE_MIXED );
+
+        if ( IsMouseOver() && maMouseRect.IsInside( GetPointerPosPixel() ) )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        bNativeOK = DrawNativeControl( CTRL_CHECKBOX, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+	     						aControlValue, rtl::OUString() );
+    }
+
+    if ( bNativeOK == FALSE )
+    {
+        USHORT nStyle = mnButtonState;
+        if ( !IsEnabled() )
+            nStyle |= BUTTON_DRAW_DISABLED;
+        if ( meState == STATE_DONTKNOW )
+            nStyle |= BUTTON_DRAW_DONTKNOW;
+        else if ( meState == STATE_CHECK )
+            nStyle |= BUTTON_DRAW_CHECKED;
+        Image aImage = GetCheckImage( GetSettings(), nStyle );
+        if ( IsZoom() )
+            DrawImage( maStateRect.TopLeft(), maStateRect.GetSize(), aImage );
+        else
+            DrawImage( maStateRect.TopLeft(), aImage );
+    }
 }
 
 // -----------------------------------------------------------------------
@@ -2711,11 +3060,11 @@ void CheckBox::ImplDraw( OutputDevice* p
         rFocusRect = rMouseRect;
         rFocusRect.Left()--;
         rFocusRect.Right()++;
+        //rFocusRect.Bottom()++;  // provide space for mnemonic underline
 
+        rStateRect.Left()   = rPos.X();
+        rStateRect.Top()    = rMouseRect.Top();
         rMouseRect.Left()   = rPos.X();
-        // add 1 so that checkboxes with and without text are aligned
-        rStateRect.Left()   = rPos.X()+1;
-        rStateRect.Top()    = rMouseRect.Top()+1;
 
         long nTextHeight = GetTextHeight();
         if ( nTextHeight > rImageSize.Height() )
@@ -2730,17 +3079,22 @@ void CheckBox::ImplDraw( OutputDevice* p
         if ( nWinStyle & WB_CENTER )
             rStateRect.Left() = rPos.X()+((rSize.Width()-rImageSize.Width())/2);
         else if ( nWinStyle & WB_RIGHT )
-            rStateRect.Left() = rPos.X()+rSize.Width()-rImageSize.Width()-1;
+            rStateRect.Left() = rPos.X()+rSize.Width()-rImageSize.Width();
         else
-            rStateRect.Left() = rPos.X()+1;
+            rStateRect.Left() = rPos.X();
         if ( nWinStyle & WB_VCENTER )
             rStateRect.Top() = rPos.Y()+((rSize.Height()-rImageSize.Height())/2);
         else if ( nWinStyle & WB_BOTTOM )
-            rStateRect.Top() = rPos.Y()+rSize.Height()-rImageSize.Height()-1;
+            rStateRect.Top() = rPos.Y()+rSize.Height()-rImageSize.Height();
         else
-            rStateRect.Top() = rPos.Y()+1;
+            rStateRect.Top() = rPos.Y();
         rStateRect.Right()  = rStateRect.Left()+rImageSize.Width()-1;
         rStateRect.Bottom() = rStateRect.Top()+rImageSize.Height()-1;
+        // provide space for focusrect
+        // note: this assumes that the control's size was adjusted
+        // accordingly in Get/LoseFocus, so the onscreen position won't change
+        if( HasFocus() )
+            rStateRect.Move( 1, 1 );    
         rMouseRect          = rStateRect;
 
         rFocusRect          = rStateRect;
@@ -3044,7 +3398,21 @@ void CheckBox::Resize()
 
 void CheckBox::GetFocus()
 {
-    ShowFocus( maFocusRect );
+    if ( !GetText().Len() || (mnButtonState & BUTTON_DRAW_NOTEXT) )
+    {
+        // increase button size to have space for focus rect
+        // checkboxes without text will draw focusrect around the check
+        // See CheckBox::ImplDraw()
+        Point aPos( GetPosPixel() );
+        Size aSize( GetSizePixel() );
+        aPos.Move(-1,-1);
+        aSize.Height() += 2;
+        aSize.Width() += 2;
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+        ImplDrawCheckBox();
+    }
+    else
+        ShowFocus( maFocusRect );
     SetInputContext( InputContext( GetFont() ) );
     Button::GetFocus();
 }
@@ -3061,6 +3429,19 @@ void CheckBox::LoseFocus()
 
     HideFocus();
     Button::LoseFocus();
+
+    if ( !GetText().Len() || (mnButtonState & BUTTON_DRAW_NOTEXT) )
+    {
+        // decrease button size again (see GetFocus())
+        // checkboxes without text will draw focusrect around the check
+        Point aPos( GetPosPixel() );
+        Size aSize( GetSizePixel() );
+        aPos.Move(1,1);
+        aSize.Height() -= 2;
+        aSize.Width() -= 2;
+        SetPosSizePixel( aPos.X(), aPos.Y(), aSize.Width(), aSize.Height(), WINDOW_POSSIZE_ALL );
+        ImplDrawCheckBox();
+    }
 }
 
 // -----------------------------------------------------------------------
@@ -3131,6 +3512,35 @@ void CheckBox::DataChanged( const DataCh
         ImplInitSettings( TRUE, TRUE, TRUE );
         Invalidate();
     }
+}
+
+// -----------------------------------------------------------------------
+
+long CheckBox::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_CHECKBOX, PART_ENTIRE_CONTROL) )
+            {
+                if( ( maMouseRect.IsInside( GetPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetLastPointerPosPixel()) ) ||
+                    ( maMouseRect.IsInside( GetLastPointerPosPixel()) && 
+                     !maMouseRect.IsInside( GetPointerPosPixel()) ) ||
+                    pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow() )
+                {
+                    Invalidate( maStateRect );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Button::PreNotify(rNEvt);
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/control/combobox.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/combobox.cxx,v
retrieving revision 1.25
retrieving revision 1.31
diff -u -p -u -r1.25 -r1.31
--- vcl/source/control/combobox.cxx	12 Jun 2003 08:18:32 -0000	1.25
+++ vcl/source/control/combobox.cxx	17 Jun 2004 12:11:35 -0000	1.31
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_COMBOBOX_CXX
-
 #ifndef _TOOLS_TABLE_HXX
 #include <tools/table.hxx>
 #endif
@@ -69,7 +67,7 @@
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -99,7 +97,7 @@
 #include <controllayout.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -191,7 +189,7 @@ void ComboBox::ImplInitData()
 
 void ComboBox::ImplCalcEditHeight()
 {
-	long nLeft, nTop, nRight, nBottom;
+	sal_Int32 nLeft, nTop, nRight, nBottom;
 	GetBorder( nLeft, nTop, nRight, nBottom );
 	mnDDHeight = (USHORT)(mpSubEdit->GetTextHeight() + nTop + nBottom + 4);
 	if ( !IsDropDownBox() )
@@ -248,7 +246,7 @@ void ComboBox::ImplInit( Window* pParent
 	}
 
 	mpSubEdit = new Edit( this, nEditStyle );
-    mpSubEdit->EnableRTL( FALSE );
+	mpSubEdit->EnableRTL( FALSE );
 	SetSubEdit( mpSubEdit );
 	mpSubEdit->SetPosPixel( Point() );
 	EnableAutocomplete( TRUE );
@@ -268,8 +266,8 @@ void ComboBox::ImplInit( Window* pParent
 
 	if ( mpFloatWin )
 		mpFloatWin->SetImplListBox( mpImplLB );
-//	else
-//		mpImplLB->GetMainWindow()->AllowGrabFocus( TRUE );
+	else
+		mpImplLB->GetMainWindow()->AllowGrabFocus( TRUE );
 
 	ImplCalcEditHeight();
 
@@ -336,6 +334,11 @@ IMPL_LINK( ComboBox, ImplClickBtnHdl, vo
     SetSelection( Selection( 0, SELECTION_MAX ) );
 	mpFloatWin->StartFloat( TRUE );
     ImplCallEventListeners( VCLEVENT_DROPDOWN_OPEN );
+
+    ImplClearLayoutData();
+    if( mpImplLB )
+        mpImplLB->GetMainWindow()->ImplClearLayoutData();
+
 	return 0;
 }
 
@@ -355,6 +358,10 @@ IMPL_LINK( ComboBox, ImplPopupModeEndHdl
         }
     }
 
+    ImplClearLayoutData();
+    if( mpImplLB )
+        mpImplLB->GetMainWindow()->ImplClearLayoutData();
+
 	mpBtn->SetPressed( FALSE );
     ImplCallEventListeners( VCLEVENT_DROPDOWN_CLOSE );
 	return 0;
@@ -630,7 +637,7 @@ void ComboBox::SetPosSizePixel( long nX,
 	if( IsDropDownBox() && ( nFlags & WINDOW_POSSIZE_SIZE ) )
 	{
 		Size aPrefSz = mpFloatWin->GetPrefSize();
-		if ( ( nFlags & WINDOW_POSSIZE_HEIGHT ) && ( nHeight > mnDDHeight ) )
+		if ( ( nFlags & WINDOW_POSSIZE_HEIGHT ) && ( nHeight >= 2*mnDDHeight ) )
 			aPrefSz.Height() = nHeight-mnDDHeight;
 		if ( nFlags & WINDOW_POSSIZE_WIDTH )
 			aPrefSz.Width() = nWidth;
@@ -653,9 +660,48 @@ void ComboBox::Resize()
 	if( IsDropDownBox() )
 	{
 		long nSBWidth = GetSettings().GetStyleSettings().GetScrollBarSize();
-		nSBWidth = CalcZoom( nSBWidth );
-		mpSubEdit->SetSizePixel( Size( aOutSz.Width() - nSBWidth, aOutSz.Height() ) );
-		mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, 0, nSBWidth, aOutSz.Height() );
+		long	nTop = 0;
+		long	nBottom = aOutSz.Height();
+
+        Window *pBorder = GetWindow( WINDOW_BORDER );
+		ImplControlValue aControlValue;
+		Point aPoint;
+		Region aContent, aBound;
+
+        // use the full extent of the control
+		Region aArea( Rectangle(aPoint, pBorder->GetOutputSizePixel()) );
+
+		if ( GetNativeControlRegion(CTRL_COMBOBOX, PART_BUTTON_DOWN,
+				aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+		{
+            // convert back from border space to local coordinates
+            aPoint = pBorder->ScreenToOutputPixel( OutputToScreenPixel( aPoint ) );
+            aContent.Move(-aPoint.X(), -aPoint.Y());
+
+			// use the themes drop down size for the button
+            aOutSz.Width() = aContent.GetBoundRect().Left();
+		    mpBtn->SetPosSizePixel( aContent.GetBoundRect().Left(), nTop, aContent.GetBoundRect().getWidth(), (nBottom-nTop) );
+
+            // adjust the size of the edit field
+            if ( GetNativeControlRegion(CTRL_COMBOBOX, PART_SUB_EDIT,
+                        aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+            {
+                // convert back from border space to local coordinates
+                aContent.Move(-aPoint.X(), -aPoint.Y());
+
+                // use the themes drop down size
+                Rectangle aContentRect = aContent.GetBoundRect();
+                mpSubEdit->SetPosSizePixel( aContentRect.TopLeft(), aContentRect.GetSize() );
+            }
+            else
+                mpSubEdit->SetSizePixel( aOutSz );
+		}
+		else
+        {
+            nSBWidth = CalcZoom( nSBWidth );
+		    mpSubEdit->SetSizePixel( Size( aOutSz.Width() - nSBWidth, aOutSz.Height() ) );
+		    mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, nTop, nSBWidth, (nBottom-nTop) );
+        }
 	}
 	else
 	{
@@ -768,6 +814,8 @@ void ComboBox::DataChanged( const DataCh
 		}
 		Resize();
 		mpImplLB->Resize(); // Wird nicht durch ComboBox::Resize() gerufen, wenn sich die ImplLB nicht aendert.
+        SetBackground();    // due to a hack in Window::UpdateSettings the background must be reset 
+                            // otherwise it will overpaint NWF drawn comboboxes
 	}
 }
 
@@ -1072,7 +1120,7 @@ Size ComboBox::CalcMinimumSize() const
 Size ComboBox::CalcAdjustedSize( const Size& rPrefSize ) const
 {
 	Size aSz = rPrefSize;
-	long nLeft, nTop, nRight, nBottom;
+	sal_Int32 nLeft, nTop, nRight, nBottom;
 	((Window*)this)->GetBorder( nLeft, nTop, nRight, nBottom );
 	aSz.Height() -= nTop+nBottom;
 	if ( !IsDropDownBox() )
@@ -1281,14 +1329,6 @@ BOOL ComboBox::IsUserDrawEnabled() const
 
 // -----------------------------------------------------------------------
 
-#if SUPD < 593
-void ComboBox::DrawEntry( const UserDrawEvent& rEvt, BOOL bDrawImage, BOOL bDrawText )
-{
-	DBG_ASSERT( rEvt.GetDevice() == mpImplLB->GetMainWindow(), "DrawEntry?!" );
-	mpImplLB->GetMainWindow()->DrawEntry( rEvt.GetItemId(), bDrawImage, bDrawText );
-}
-#endif
-
 void ComboBox::DrawEntry( const UserDrawEvent& rEvt, BOOL bDrawImage, BOOL bDrawText, BOOL bDrawTextAtImagePos )
 {
 	DBG_ASSERT( rEvt.GetDevice() == mpImplLB->GetMainWindow(), "DrawEntry?!" );
@@ -1454,3 +1494,15 @@ Rectangle ComboBox::GetBoundingRectangle
     return aRect;
 }
 // -----------------------------------------------------------------------------
+
+void ComboBox::SetBorderStyle( USHORT nBorderStyle )
+{
+	Window::SetBorderStyle( nBorderStyle );
+	if ( !IsDropDownBox() )
+	{
+		mpSubEdit->SetBorderStyle( nBorderStyle );
+		mpImplLB->SetBorderStyle( nBorderStyle );
+	}
+}
+// -----------------------------------------------------------------------------
+
Index: vcl/source/control/ctrl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/ctrl.cxx,v
retrieving revision 1.10
retrieving revision 1.14
diff -u -p -u -r1.10 -r1.14
--- vcl/source/control/ctrl.cxx	4 Jun 2003 11:21:43 -0000	1.10
+++ vcl/source/control/ctrl.cxx	18 May 2004 10:54:12 -0000	1.14
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_CTRL_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -79,8 +77,11 @@
 #ifndef _VCL_CONTROLLAYOUT_HXX
 #include <controllayout.hxx>
 #endif
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+
 
-#pragma hdrstop
 
 using namespace vcl;
 
@@ -205,7 +206,6 @@ long ControlLayoutData::GetIndexForPoint
 
 long Control::GetIndexForPoint( const Point& rPoint ) const
 {
-    long nIndex = -1;
     if( ! mpLayoutData )
         FillLayoutData();
     return mpLayoutData ? mpLayoutData->GetIndexForPoint( rPoint ) : -1;
@@ -266,6 +266,49 @@ Pair Control::GetLineStartEnd( long nLin
 
 // -----------------------------------------------------------------------
 
+long ControlLayoutData::ToRelativeLineIndex( long nIndex ) const
+{
+    // is the index sensible at all ?
+    if( nIndex >= 0 && nIndex < m_aDisplayText.Len() )
+    {
+        int nDisplayLines = m_aLineIndices.size();
+        // if only 1 line exists, then absolute and relative index are
+        // identical -> do nothing
+        if( nDisplayLines > 1 )
+        {
+            int nLine;
+            for( nLine = nDisplayLines-1; nLine >= 0; nLine-- )
+            {
+                if( m_aLineIndices[nLine] <= nIndex )
+                {
+                    nIndex -= m_aLineIndices[nLine];
+                    break;
+                }
+            }
+            if( nLine < 0 )
+            {
+                DBG_ASSERT( nLine >= 0, "ToRelativeLineIndex failed" );
+                nIndex = -1;
+            }
+        }
+    }
+    else
+        nIndex = -1;
+
+    return nIndex;
+}
+
+// -----------------------------------------------------------------------
+
+long Control::ToRelativeLineIndex( long nIndex ) const
+{
+    if( ! mpLayoutData )
+        FillLayoutData();
+    return mpLayoutData ? mpLayoutData->ToRelativeLineIndex( nIndex ) : -1;
+}
+
+// -----------------------------------------------------------------------
+
 String Control::GetDisplayText() const
 {
     if( ! mpLayoutData )
@@ -371,7 +414,7 @@ void Control::SetLayoutDataParent( const
 
 // -----------------------------------------------------------------
 
-void Control::ImplSubControlLayoutChanged() const
+void Control::ImplClearLayoutData() const
 {
     delete mpLayoutData, mpLayoutData = NULL;
 }
@@ -381,5 +424,5 @@ void Control::ImplSubControlLayoutChange
 ControlLayoutData::~ControlLayoutData()
 {
     if( m_pParent )
-        m_pParent->ImplSubControlLayoutChanged();
+        m_pParent->ImplClearLayoutData();
 }
Index: vcl/source/control/edit.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/edit.cxx,v
retrieving revision 1.59.60.1
retrieving revision 1.65
diff -u -p -u -r1.59.60.1 -r1.65
--- vcl/source/control/edit.cxx	15 Jan 2004 12:48:13 -0000	1.59.60.1
+++ vcl/source/control/edit.cxx	17 Jun 2004 12:12:07 -0000	1.65
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_EDIT_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -159,7 +157,7 @@
 #endif
 
 
-#pragma hdrstop
+
 
 using namespace ::com::sun::star;
 using namespace ::com::sun::star::uno;
@@ -390,18 +388,26 @@ void Edit::ImplInit( Window* pParent, Wi
     if( Application::GetSettings().GetLayoutRTL() )
         mnAlign	= EDIT_ALIGN_RIGHT;
 
-	if ( nStyle & WB_RIGHT )
-		mnAlign = EDIT_ALIGN_RIGHT;
-	else if ( nStyle & WB_CENTER )
-		mnAlign = EDIT_ALIGN_CENTER;
+    if ( nStyle & WB_RIGHT )
+        mnAlign = EDIT_ALIGN_RIGHT;
+    else if ( nStyle & WB_CENTER )
+        mnAlign = EDIT_ALIGN_CENTER;
 
-	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
-	SetBackground( Wallpaper( rStyleSettings.GetFieldColor() ) );
-	SetFillColor( rStyleSettings.GetFieldColor() );
-	SetCursor( new Cursor );
+    const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
+    if ( IsNativeControlSupported(ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE) )
+    {
+        SetBackground();
+        SetFillColor();
+    }
+    else
+    {
+        SetBackground( Wallpaper( rStyleSettings.GetFieldColor() ) );
+        SetFillColor( rStyleSettings.GetFieldColor() );
+    }
+    SetCursor( new Cursor );
 
-	SetPointer( Pointer( POINTER_TEXT ) );
-	ImplInitSettings( TRUE, TRUE, TRUE );
+    SetPointer( Pointer( POINTER_TEXT ) );
+    ImplInitSettings( TRUE, TRUE, TRUE );
 
     uno::Reference< datatransfer::dnd::XDragGestureListener> xDGL( mxDnDListener, uno::UNO_QUERY );
     uno::Reference< datatransfer::dnd::XDragGestureRecognizer > xDGR = GetDragGestureRecognizer();
@@ -470,7 +476,13 @@ void Edit::ImplInitSettings( BOOL bFont,
 
 	if ( bBackground )
 	{
-		if( IsControlBackground() )
+		if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+		{
+			// Transparent background
+			SetBackground();
+			SetFillColor();
+		}
+		else if ( IsControlBackground() )
 		{
 			SetBackground( GetControlBackground() );
 			SetFillColor( GetControlBackground() );
@@ -528,15 +540,15 @@ void Edit::ImplRepaint( xub_StrLen nStar
     nStart = 0;
     nEnd = aText.Len();
 
-    long	nDXBuffer[256];
-    long*	pDXBuffer = NULL;
-    long*	pDX = nDXBuffer;
+    sal_Int32	nDXBuffer[256];
+    sal_Int32*	pDXBuffer = NULL;
+    sal_Int32*	pDX = nDXBuffer;
 
     if( aText.Len() )
     {
         if( 2*aText.Len() > sizeof(nDXBuffer)/sizeof(nDXBuffer[0]) )
         {
-            pDXBuffer = new long[2*(aText.Len()+1)];
+            pDXBuffer = new sal_Int32[2*(aText.Len()+1)];
             pDX = pDXBuffer;
         }
 
@@ -576,7 +588,11 @@ void Edit::ImplRepaint( xub_StrLen nStar
 	else
 		SetTextColor( rStyleSettings.GetDisableColor() );
 
-	SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
+	// Set background color of the normal text
+	if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+		SetTextFillColor();
+	else
+		SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
 
 	BOOL bDrawSelection = maSelection.Len() && ( HasFocus() || ( GetStyle() & WB_NOHIDESELECTION ) || mbActivePopup );
 
@@ -596,7 +612,8 @@ void Edit::ImplRepaint( xub_StrLen nStar
 		Selection aTmpSel( maSelection );
 		aTmpSel.Justify();
         // selection is highlighted
-        for( int i = 0; i < aText.Len(); i++ )
+        int i;
+        for( i = 0; i < aText.Len(); i++ )
         {
             Rectangle aRect( aPos, Size( 10, nTH ) );
             aRect.Left() = pDX[2*i] + mnXOffset + ImplGetExtraOffset();
@@ -619,8 +636,14 @@ void Edit::ImplRepaint( xub_StrLen nStar
         // draw normal text
         Color aNormalTextColor = GetTextColor();
         SetClipRegion( aNormalClipRegion );
-        SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
+
+	    // Set background color when part of the text is selected
+	    if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+		    SetTextFillColor();
+	    else
+		    SetTextFillColor( IsControlBackground() ? GetControlBackground() : rStyleSettings.GetFieldColor() );
 		DrawText( aPos, aText, nStart, nEnd - nStart );
+
         // draw highlighted text
         SetClipRegion( aHiglightClipRegion );
         SetTextColor( rStyleSettings.GetHighlightTextColor() );
@@ -853,6 +876,51 @@ void Edit::ImplSetText( const XubString&
 
 // -----------------------------------------------------------------------
 
+int Edit::ImplGetNativeControlType()
+{
+    int nCtrl = 0;
+    Window *pControl = mbIsSubEdit ? GetParent() : this;
+
+    switch( pControl->GetType() )
+    {
+        case WINDOW_COMBOBOX:
+        case WINDOW_PATTERNBOX:			
+        case WINDOW_NUMERICBOX:			
+        case WINDOW_METRICBOX:			
+        case WINDOW_CURRENCYBOX:
+        case WINDOW_DATEBOX:		
+        case WINDOW_TIMEBOX:			
+        case WINDOW_LONGCURRENCYBOX:
+            nCtrl = CTRL_COMBOBOX;
+            break;
+
+        case WINDOW_EDIT:
+        case WINDOW_MULTILINEEDIT:
+        case WINDOW_PATTERNFIELD:
+        case WINDOW_METRICFIELD:
+        case WINDOW_CURRENCYFIELD:
+        case WINDOW_DATEFIELD:
+        case WINDOW_TIMEFIELD:
+        case WINDOW_LONGCURRENCYFIELD:
+        case WINDOW_NUMERICFIELD:
+        case WINDOW_SPINFIELD:
+            if( pControl->GetStyle() & WB_SPIN )
+                nCtrl = CTRL_SPINBOX;
+            else
+            {
+                if ( GetWindow( WINDOW_BORDER ) != this )
+                    nCtrl = CTRL_EDITBOX;
+                else
+                    nCtrl = CTRL_EDITBOX_NOBORDER;
+            }
+            break;
+
+        default:
+            nCtrl = CTRL_EDITBOX;
+    }
+    return nCtrl;
+}
+
 void Edit::ImplClearBackground( long nXStart, long nXEnd )
 {
 	Point aTmpPoint;
@@ -865,7 +933,43 @@ void Edit::ImplClearBackground( long nXS
 	if ( pCursor )
 		pCursor->Hide();
 
-	Erase( aRect );
+    if ( IsNativeControlSupported( ImplGetNativeControlType(), HAS_BACKGROUND_TEXTURE ) )
+    {
+        // draw the inner part by painting the whole control using its border window
+        Window *pControl = this;
+        Window *pBorder = GetWindow( WINDOW_BORDER );
+        if( pBorder == this )
+        {
+            // we have no border, use parent
+            pControl = mbIsSubEdit ? GetParent() : this;
+            pBorder = pControl->GetWindow( WINDOW_BORDER );
+        }
+        
+        if( pBorder )
+        {
+            // set proper clipping region to not overdraw the whole control
+            Region aClipRgn = GetPaintRegion();
+            if( !aClipRgn.IsNull() )
+            {
+                // transform clipping region to border window's coordinate system
+                Point aBorderOffs;
+                aBorderOffs = pBorder->ScreenToOutputPixel( OutputToScreenPixel( aBorderOffs ) );
+                aClipRgn.Move( aBorderOffs.X(), aBorderOffs.Y() );
+
+                Region oldRgn( pBorder->GetClipRegion() );
+                pBorder->SetClipRegion( aClipRgn );
+
+                pBorder->Paint( Rectangle() );
+
+                pBorder->SetClipRegion( oldRgn );
+            }
+            else
+                pBorder->Paint( Rectangle() );
+
+        }
+    }
+    else
+	    Erase( aRect );
 
 	if ( pCursor )
 		pCursor->Show();
@@ -883,15 +987,15 @@ void Edit::ImplShowCursor( BOOL bOnlyIfV
 
     long nTextPos = 0;
 
-    long	nDXBuffer[256];
-    long*	pDXBuffer = NULL;
-    long*	pDX = nDXBuffer;
+    sal_Int32	nDXBuffer[256];
+    sal_Int32*	pDXBuffer = NULL;
+    sal_Int32*	pDX = nDXBuffer;
 
     if( aText.Len() )
     {
         if( 2*aText.Len() > sizeof(nDXBuffer)/sizeof(nDXBuffer[0]) )
         {
-            pDXBuffer = new long[2*(aText.Len()+1)];
+            pDXBuffer = new sal_Int32[2*(aText.Len()+1)];
             pDX = pDXBuffer;
         }
         
@@ -1005,12 +1109,12 @@ xub_StrLen Edit::ImplGetCharPos( const P
     xub_StrLen nIndex = STRING_LEN;
     String aText = ImplGetText();
 
-    long	nDXBuffer[256];
-    long*	pDXBuffer = NULL;
-    long*	pDX = nDXBuffer;
+    sal_Int32	nDXBuffer[256];
+    sal_Int32*	pDXBuffer = NULL;
+    sal_Int32*	pDX = nDXBuffer;
     if( 2*aText.Len() > sizeof(nDXBuffer)/sizeof(nDXBuffer[0]) )
     {
-        pDXBuffer = new long[2*(aText.Len()+1)];
+        pDXBuffer = new sal_Int32[2*(aText.Len()+1)];
         pDX = pDXBuffer;
     }
 
@@ -1840,6 +1944,16 @@ void Edit::Command( const CommandEvent& 
 		SetInsertMode( bInsertMode );
 
 		ImplModified();
+
+        // #i25161# call auto complete handler for ext text commit also
+        if ( maAutocompleteHdl.IsSet() )
+        {
+            if ( (maSelection.Min() == maSelection.Max()) && (maSelection.Min() == maText.Len()) )
+            {
+                meAutocompleteAction = AUTOCOMPLETE_KEYINPUT;
+                maAutocompleteHdl.Call( this );
+            }
+        }
 	}
 	else if ( rCEvt.GetCommand() == COMMAND_EXTTEXTINPUT )
 	{
@@ -2517,7 +2631,6 @@ void Edit::drop( const ::com::sun::star:
 	if ( !mbReadOnly && mpDDInfo )
 	{
 		ImplHideDDCursor();
-		Point aMousePos( rDTDE.LocationX, rDTDE.LocationY );
 
 		Selection aSel( maSelection );
 		aSel.Justify();
@@ -2563,7 +2676,7 @@ void Edit::dragEnter( const ::com::sun::
     {
 		mpDDInfo = new DDInfo;
     }
-    sal_Bool bTextContent = mbReadOnly ? sal_False : sal_True;   // quiery from rDTDEE.SupportedDataFlavors()
+//    sal_Bool bTextContent = mbReadOnly ? sal_False : sal_True;   // quiery from rDTDEE.SupportedDataFlavors()
 //    if ( bTextContent )
 //        rDTDEE.Context->acceptDrop(datatransfer::dnd::DNDConstants::ACTION_COPY_OR_MOVE);
 //    else
Index: vcl/source/control/field.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/field.cxx,v
retrieving revision 1.9
retrieving revision 1.11
diff -u -p -u -r1.9 -r1.11
--- vcl/source/control/field.cxx	25 Oct 2002 11:44:53 -0000	1.9
+++ vcl/source/control/field.cxx	6 Jan 2004 13:17:34 -0000	1.11
@@ -59,19 +59,17 @@
  *
  ************************************************************************/
 
+#ifndef _BIGINT_HXX
 #define _TOOLS_BIGINT
-#define _SV_FIELD_CXX
+#include <tools/bigint.hxx>
+#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 
-#ifndef _BIGINT_HXX
-#include <tools/bigint.hxx>
-#endif
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _TOOLS_RESARY_HXX
 #include <tools/resary.hxx>
@@ -85,7 +83,7 @@
 #include <svdata.hxx>
 #include <unohelp.hxx>
 
-#pragma hdrstop
+
 
 #ifndef _UNOTOOLS_LOCALEDATAWRAPPER_HXX
 #include <unotools/localedatawrapper.hxx>
@@ -395,14 +378,6 @@ void FormatterBase::ImplSetText( const X
 {
     if ( mpField )
     {
-        // !!! TH-18.2.99: Wenn wir Zeit haben sollte mal geklaert werden,
-        // !!! warum SetText() intern bei gleichem Text nicht ImplSetSelection
-        // !!! aufruft, sondern etwas anders macht, denn sehr haeufig kommt
-        // !!! hier der gleiche Text an.
-
-        // ggf. bleibt der Text gleich, aber die Selektion wird geaendert...
-        BOOL bTextChanged = (mpField->GetText() != rText);
-
         if ( pNewSelection )
             mpField->SetText( rText, *pNewSelection );
         else
@@ -412,14 +387,6 @@ void FormatterBase::ImplSetText( const X
             mpField->SetText( rText, aSel );
         }
 
-        // !!! TH-18.2.99: Wenn wir Zeit haben sollte mal geklaert werden,
-        // !!! warum hier der Modify-Handler gerufen wird !!!
-
-        // !!! MT-8.7.99: Erstmal auskommentiert, koentest recht haben,
-        // !!! Modify wird zu oft gerufen.
-//      if ( MustBeReformatted() && bTextChanged )
-//          mpField->Edit::Modify();    // Nur damit Modify-Hdl gerufen wird.
-
         MarkToBeReformatted( FALSE );
     }
 }
@@ -1168,48 +1135,6 @@ static FieldUnit ImplMetricGetUnit( cons
 {
     XubString aStr = ImplMetricGetUnitText( rStr );
     return ImplStringToMetric( aStr );
-/*
-    aStr.ToLowerAscii();
-
-    if ( aStr.EqualsAscii( "mm" ) )             // Milimeter
-        return FUNIT_MM;
-    else if ( aStr.EqualsAscii( "cm" ) )        // Centimeter
-        return FUNIT_CM;
-    else if ( aStr.EqualsAscii( "m" ) )         // Meter
-        return FUNIT_M;
-    else if ( aStr.EqualsAscii( "km" ) )        // Km
-        return FUNIT_KM;
-    else if ( aStr.EqualsAscii( "twip" ) )      // Twips
-        return FUNIT_TWIP;
-    else if ( aStr.EqualsAscii( "twips" ) )     // Twips
-        return FUNIT_TWIP;
-    else if ( aStr.EqualsAscii( "pt" ) )        // Point
-        return FUNIT_POINT;
-    else if ( aStr.EqualsAscii( "pi" ) )        // Pica
-        return FUNIT_PICA;
-    else if ( aStr.EqualsAscii( "\"" ) )        // Inch
-        return FUNIT_INCH;
-    else if ( aStr.EqualsAscii( "in" ) )        // Inch
-        return FUNIT_INCH;
-    else if ( aStr.EqualsAscii( "inch" ) )      // Inch
-        return FUNIT_INCH;
-    else if ( aStr.EqualsAscii( "'" ) )         // Foot
-        return FUNIT_FOOT;
-    else if ( aStr.EqualsAscii( "ft" ) )        // Foot
-        return FUNIT_FOOT;
-    else if ( aStr.EqualsAscii( "foot" ) )      // Foot
-        return FUNIT_FOOT;
-    else if ( aStr.EqualsAscii( "feet" ) )      // Foot
-        return FUNIT_FOOT;
-    else if ( aStr.EqualsAscii( "mile" ) )      // Mile
-        return FUNIT_MILE;
-    else if ( aStr.EqualsAscii( "miles" ) )     // Mile
-        return FUNIT_MILE;
-    else if ( aStr.EqualsAscii( "%" ) )         // Percent
-        return FUNIT_PERCENT;
-    else
-        return FUNIT_NONE;
-*/
 }
 
 #define K *1000L
@@ -1289,6 +1214,7 @@ long MetricField::ConvertValue( long nVa
 
 // -----------------------------------------------------------------------
 
+// MT: Not needed?
 long MetricField::ConvertValue( long nValue, USHORT nDigits,
                                 MapUnit eInUnit, FieldUnit eOutUnit )
 {
@@ -1297,10 +1223,11 @@ long MetricField::ConvertValue( long nVa
 
 // -----------------------------------------------------------------------
 
+// MT: Not needed?
 long MetricField::ConvertValue( long nValue, USHORT nDigits,
                                 FieldUnit eInUnit, MapUnit eOutUnit )
 {
-    return (long)ConvertValue( nValue, nDigits, eInUnit, eOutUnit );
+    return (long)ConvertDoubleValue( nValue, nDigits, eInUnit, eOutUnit );
 }
 
 // -----------------------------------------------------------------------
@@ -1591,48 +1518,6 @@ XubString MetricFormatter::CreateFieldTe
         aStr += ImplMetricToString( meUnit );
 
     return aStr;
-    /*
-    // Einheit dranhaengen
-    switch ( meUnit )
-    {
-        case FUNIT_MM:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "mm" ) );
-            break;
-        case FUNIT_CM:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "cm" ) );
-            break;
-        case FUNIT_M:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "m" ) );
-            break;
-        case FUNIT_KM:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "km" ) );
-            break;
-        case FUNIT_TWIP:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "twips" ) );
-            break;
-        case FUNIT_POINT:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "pt" ) );
-            break;
-        case FUNIT_PICA:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "pi" ) );
-            break;
-        case FUNIT_INCH:
-            aStr.Append( '"' );
-            break;
-        case FUNIT_FOOT:
-            aStr.Append( '\'' );
-            break;
-        case FUNIT_MILE:
-            aStr.AppendAscii( RTL_CONSTASCII_STRINGPARAM( "miles" ) );
-            break;
-        case FUNIT_CUSTOM:
-            aStr += maCustomUnitText;
-            break;
-        default:
-            break;
-    }
-    return aStr;
-    */
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/control/field2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/field2.cxx,v
retrieving revision 1.11
retrieving revision 1.16
diff -u -p -u -r1.11 -r1.16
--- vcl/source/control/field2.cxx	2 Sep 2002 13:41:36 -0000	1.11
+++ vcl/source/control/field2.cxx	2 Apr 2004 10:35:20 -0000	1.16
@@ -59,14 +59,12 @@
  *
  ************************************************************************/
 
-#define _SV_FIELD2_CXX
-
 #ifndef _TOOLS_DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -77,9 +75,6 @@
 #ifndef _SV_SVAPP_HXX
 #include <svapp.hxx>
 #endif
-#ifndef _SV_SYSTEM_HXX
-#include <system.hxx>
-#endif
 #ifndef _SV_SOUND_HXX
 #include <sound.hxx>
 #endif
@@ -106,7 +101,7 @@
 #include <com/sun/star/i18n/KCharacterType.hpp>
 #endif
 
-#pragma hdrstop
+
 
 #ifndef _UNOTOOLS_LOCALEDATAWRAPPER_HXX
 #include <unotools/localedatawrapper.hxx>
@@ -1191,35 +1186,14 @@ static ExtDateFieldFormat ImplGetExtForm
     {
         case DMY:   return XTDATEF_SHORT_DDMMYY;
         case MDY:   return XTDATEF_SHORT_MMDDYY;
-        case YMD:   return XTDATEF_SHORT_YYMMDD;
+        default:    return XTDATEF_SHORT_YYMMDD;
     }
 }
 
-static USHORT ImplCutMonthFromString( XubString& rStr, const CalendarWrapper& rCalendarWrapper )
-{
-    USHORT nPos;
-
-    //Nach Monatsnamen suchen
-    for ( USHORT i=1; i <= 12; i++ )
-    {
-        String aMonthName = rCalendarWrapper.getMonths()[i-1].FullName;
-        // Voller Monatsname ?
-        nPos = rStr.Search( aMonthName );
-        if ( nPos != STRING_NOTFOUND )
-        {
-            rStr.Erase( 0, nPos + aMonthName.Len() );
-            return i;
-        }
-        // Kurzer Monatsname ?
-        String aAbbrevMonthName = rCalendarWrapper.getMonths()[i-1].AbbrevName;
-        nPos = rStr.Search( aAbbrevMonthName );
-        if ( nPos != STRING_NOTFOUND )
-        {
-            rStr.Erase( 0, nPos + aAbbrevMonthName.Len() );
-            return i;
-        }
-    }
+// -----------------------------------------------------------------------
 
+static USHORT ImplCutNumberFromString( XubString& rStr )
+{
     // Nach Zahl suchen
     while ( rStr.Len() && !(rStr.GetChar( 0 ) >= '0' && rStr.GetChar( 0 ) <= '9') )
         rStr.Erase( 0, 1 );
@@ -1236,20 +1210,36 @@ static USHORT ImplCutMonthFromString( Xu
 
 // -----------------------------------------------------------------------
 
-static USHORT ImplCutNumberFromString( XubString& rStr )
+static BOOL ImplCutMonthName( XubString& rStr, const XubString& _rLookupMonthName )
 {
-    // Nach Zahl suchen
-    while ( rStr.Len() && !(rStr.GetChar( 0 ) >= '0' && rStr.GetChar( 0 ) <= '9') )
-        rStr.Erase( 0, 1 );
-    if ( !rStr.Len() )
-        return 0;
-    XubString aNumStr;
-    while ( rStr.Len() && (rStr.GetChar( 0 ) >= '0' && rStr.GetChar( 0 ) <= '9') )
+    USHORT nPos = rStr.Search( _rLookupMonthName );
+    if ( nPos != STRING_NOTFOUND )
     {
-        aNumStr.Insert( rStr.GetChar( 0 ) );
-        rStr.Erase( 0, 1 );
+        rStr.Erase( 0, nPos + _rLookupMonthName.Len() );
+        return TRUE;
     }
-    return (USHORT)aNumStr.ToInt32();
+    return FALSE;
+}
+
+// -----------------------------------------------------------------------
+
+static USHORT ImplCutMonthFromString( XubString& rStr, const CalendarWrapper& rCalendarWrapper )
+{
+    // search for a month' name
+    for ( USHORT i=1; i <= 12; i++ )
+    {
+        String aMonthName = rCalendarWrapper.getMonths()[i-1].FullName;
+        // long month name?
+        if ( ImplCutMonthName( rStr, aMonthName ) )
+            return i;
+
+        // short month name?
+        String aAbbrevMonthName = rCalendarWrapper.getMonths()[i-1].AbbrevName;
+        if ( ImplCutMonthName( rStr, aAbbrevMonthName ) )
+            return i;
+    }
+
+    return ImplCutNumberFromString( rStr );
 }
 
 // -----------------------------------------------------------------------
@@ -1428,11 +1418,6 @@ XubString DateFormatter::ImplGetDateAsTe
     BOOL bShowCentury = FALSE;
     switch ( GetExtDateFormat() )
     {
-        case XTDATEF_SYSTEM_SHORT:
-        {
-            bShowCentury = FALSE;   // ??? DEFAULT ???
-        }
-        break;
         case XTDATEF_SYSTEM_SHORT_YYYY:
         case XTDATEF_SYSTEM_LONG:
         case XTDATEF_SHORT_DDMMYYYY:
@@ -1443,6 +1428,10 @@ XubString DateFormatter::ImplGetDateAsTe
             bShowCentury = TRUE;
         }
         break;
+        default:
+        {
+            bShowCentury = FALSE;
+        }
     }
 
     if ( !bShowCentury )
@@ -1594,6 +1583,12 @@ static void ImplDateIncrementYear( Date&
 }
 
 // -----------------------------------------------------------------------
+BOOL DateFormatter::ImplAllowMalformedInput() const
+{
+    return ( NULL != GetField() ) && ( ( GetField()->GetStyle() & 0x80000000 ) != 0 );
+}
+
+// -----------------------------------------------------------------------
 
 void DateField::ImplDateSpinArea( BOOL bUp )
 {
@@ -1696,10 +1691,11 @@ void DateFormatter::ImplInit()
 // -----------------------------------------------------------------------
 
 DateFormatter::DateFormatter() :
+    maFieldDate( 0 ),
+    maLastDate( 0 ),
     maMin( 1, 1, 1900 ),
     maMax( 31, 12, 2200 ),
-    maFieldDate( 0 ),
-    maLastDate( 0 )
+    mbEnforceValidValue( TRUE )
 {
     ImplInit();
 }
@@ -1776,26 +1772,6 @@ CalendarWrapper& DateFormatter::GetCalen
     return *mpCalendarWrapper;
 }
 
-#if SUPD < 651
-
-// -----------------------------------------------------------------------
-
-void DateFormatter::SetDateFormat( DateFormat eFormat )
-{
-    DBG_ERROR( "Who is using DateFormatter::SetDateFormat?\nPlease report to Malte Timmermann" );
-    mnDateFormat = eFormat;
-}
-
-// -----------------------------------------------------------------------
-
-DateFormat DateFormatter::GetDateFormat() const
-{
-    DBG_ERROR( "Who is using DateFormatter::GetDateFormat?\nPlease report to Malte Timmermann" );
-    return ( mnDateFormat != 0xFFFF ) ? (DateFormat)mnDateFormat : ImplGetLocaleDataWrapper().getDateFormat();
-}
-
-#endif
-
 // -----------------------------------------------------------------------
 
 void DateFormatter::SetExtDateFormat( ExtDateFieldFormat eFormat )
@@ -1894,6 +1870,8 @@ void DateFormatter::SetShowDateCentury( 
                 SetExtDateFormat( XTDATEF_SHORT_YYYYMMDD );     break;
             case XTDATEF_SHORT_YYMMDD_DIN5008:
                 SetExtDateFormat( XTDATEF_SHORT_YYYYMMDD_DIN5008 ); break;
+            default:
+                ;
         }
     }
     else
@@ -1911,6 +1889,8 @@ void DateFormatter::SetShowDateCentury( 
                 SetExtDateFormat( XTDATEF_SHORT_YYMMDD );       break;
             case XTDATEF_SHORT_YYYYMMDD_DIN5008:
                 SetExtDateFormat( XTDATEF_SHORT_YYMMDD_DIN5008 );  break;
+            default:
+                ;
         }
     }
 
@@ -2000,10 +1980,15 @@ Date DateFormatter::GetDate() const
             // !!! allen anderen Feldern anders behandelt wird.
             // !!! Siehe dazu Bug: 52304
 
-            if ( maLastDate.GetDate() )
-                aDate = maLastDate;
-            else if ( !IsEmptyFieldValueEnabled() )
-                aDate = Date();
+            if ( !ImplAllowMalformedInput() )
+            {
+                if ( maLastDate.GetDate() )
+                    aDate = maLastDate;
+                else if ( !IsEmptyFieldValueEnabled() )
+                    aDate = Date();
+            }
+            else
+                aDate = GetInvalidDate();
         }
     }
 
@@ -2021,7 +2006,9 @@ Date DateFormatter::GetRealDate() const
 
     if ( GetField() )
     {
-        ImplDateGetValue( GetField()->GetText(), aDate, GetExtDateFormat(TRUE), ImplGetLocaleDataWrapper(), GetCalendarWrapper(), GetFieldSettings() );
+        if ( !ImplDateGetValue( GetField()->GetText(), aDate, GetExtDateFormat(TRUE), ImplGetLocaleDataWrapper(), GetCalendarWrapper(), GetFieldSettings() ) )
+            if ( ImplAllowMalformedInput() )
+                aDate = GetInvalidDate();
     }
 
     return aDate;
@@ -2216,7 +2203,18 @@ long DateField::Notify( NotifyEvent& rNE
 
             BOOL bTextLen = GetText().Len() != 0;
             if ( bTextLen || !IsEmptyFieldValueEnabled() )
-                Reformat();
+            {
+                if ( !ImplAllowMalformedInput() )
+                    Reformat();
+                else
+                {
+                    Date aDate( 0, 0, 0 );
+                    if ( ImplDateGetValue( GetText(), aDate, GetExtDateFormat(TRUE), ImplGetLocaleDataWrapper(), GetCalendarWrapper(), GetFieldSettings() ) )
+                        // even with strict text analysis, our text is a valid date -> do a complete
+                        // reformat
+                        Reformat();
+                }
+            }
             else if ( !bTextLen && IsEmptyFieldValueEnabled() )
             {
                 ResetLastDate();
@@ -2477,9 +2466,47 @@ static BOOL ImplTimeProcessKeyInput( Edi
 
 // -----------------------------------------------------------------------
 
+static BOOL ImplIsOnlyDigits( const String& _rStr )
+{
+    const sal_Unicode* _pChr = _rStr.GetBuffer();
+    for ( xub_StrLen i = 0; i < _rStr.Len(); ++i, ++_pChr )
+    {
+        if ( *_pChr < '0' || *_pChr > '9' )
+            return FALSE;
+    }
+    return TRUE;
+}
+
+// -----------------------------------------------------------------------
+
+static BOOL ImplIsValidTimePortion( BOOL _bSkipInvalidCharacters, const String& _rStr )
+{
+    if ( !_bSkipInvalidCharacters )
+    {
+        if ( ( _rStr.Len() > 2 ) || ( _rStr.Len() < 1 ) || !ImplIsOnlyDigits( _rStr ) )
+            return FALSE;
+    }
+    return TRUE;
+}
+
+// -----------------------------------------------------------------------
+
+static BOOL ImplCutTimePortion( String& _rStr, xub_StrLen _nSepPos, BOOL _bSkipInvalidCharacters, short* _pPortion )
+{
+    String sPortion = _rStr.Copy( 0, _nSepPos );
+    _rStr.Erase( 0, _nSepPos + 1 );
+
+    if ( !ImplIsValidTimePortion( _bSkipInvalidCharacters, sPortion ) )
+        return FALSE;
+    *_pPortion = (short)sPortion.ToInt32();
+    return TRUE;
+}
+
+// -----------------------------------------------------------------------
+
 static BOOL ImplTimeGetValue( const XubString& rStr, Time& rTime,
                               TimeFieldFormat eFormat, TimeFormat eTimeFormat, BOOL bDuration,
-                              const LocaleDataWrapper& rLocaleDataWrapper )
+                              const LocaleDataWrapper& rLocaleDataWrapper, BOOL _bSkipInvalidCharacters = TRUE )
 {
     XubString   aStr    = rStr;
     short       nHour   = 0;
@@ -2518,25 +2545,25 @@ static BOOL ImplTimeGetValue( const XubS
     if ( eFormat != TIMEF_SEC_CS )
     {
         if ( nSepPos == STRING_NOTFOUND )
+            nSepPos = aStr.Len();
+        if ( !ImplCutTimePortion( aStr, nSepPos, _bSkipInvalidCharacters, &nHour ) )
             return FALSE;
-        nHour = (short)aStr.Copy( 0, nSepPos ).ToInt32();
-        aStr.Erase( 0, nSepPos+1 );
 
         nSepPos = aStr.Search( rLocaleDataWrapper.getTimeSep() );
         if ( aStr.GetChar( 0 ) == '-' )
             bNegative = TRUE;
         if ( nSepPos != STRING_NOTFOUND )
         {
-            nMinute = (short)aStr.Copy( 0, nSepPos ).ToInt32();
-            aStr.Erase( 0, nSepPos+1 );
+            if ( !ImplCutTimePortion( aStr, nSepPos, _bSkipInvalidCharacters, &nMinute ) )
+                return FALSE;
 
             nSepPos = aStr.Search( rLocaleDataWrapper.getTimeSep() );
             if ( aStr.GetChar( 0 ) == '-' )
                 bNegative = TRUE;
             if ( nSepPos != STRING_NOTFOUND )
             {
-                nSecond = (short)aStr.Copy( 0, nSepPos ).ToInt32();
-                aStr.Erase( 0, nSepPos+1 );
+                if ( !ImplCutTimePortion( aStr, nSepPos, _bSkipInvalidCharacters, &nSecond ) )
+                    return FALSE;
                 if ( aStr.GetChar( 0 ) == '-' )
                     bNegative = TRUE;
                 n100Sec = (short)aStr.ToInt32();
@@ -2745,6 +2772,12 @@ BOOL TimeFormatter::ImplTimeReformat( co
 }
 
 // -----------------------------------------------------------------------
+BOOL TimeFormatter::ImplAllowMalformedInput() const
+{
+    return ( NULL != GetField() ) && ( ( GetField()->GetStyle() & 0x80000000 ) != 0 );
+}
+
+// -----------------------------------------------------------------------
 
 void TimeField::ImplTimeSpinArea( BOOL bUp )
 {
@@ -2826,10 +2859,11 @@ void TimeFormatter::ImplInit()
 // -----------------------------------------------------------------------
 
 TimeFormatter::TimeFormatter() :
+    maLastTime( 0, 0 ),
     maMin( 0, 0 ),
     maMax( 23, 59, 59, 99 ),
     maFieldTime( 0, 0 ),
-    maLastTime( 0, 0 )
+    mbEnforceValidValue( TRUE )
 {
     ImplInit();
 }
@@ -3055,7 +3089,8 @@ Time TimeFormatter::GetTime() const
 
     if ( GetField() )
     {
-        if ( ImplTimeGetValue( GetField()->GetText(), aTime, GetFormat(), GetTimeFormat(), IsDuration(), ImplGetLocaleDataWrapper() ) )
+        BOOL bAllowMailformed = ImplAllowMalformedInput();
+        if ( ImplTimeGetValue( GetField()->GetText(), aTime, GetFormat(), GetTimeFormat(), IsDuration(), ImplGetLocaleDataWrapper(), !bAllowMailformed ) )
         {
             if ( aTime > GetMax() )
                 aTime = GetMax();
@@ -3063,7 +3098,12 @@ Time TimeFormatter::GetTime() const
                 aTime = GetMin();
         }
         else
-            aTime = maLastTime;
+        {
+            if ( bAllowMailformed )
+                aTime = GetInvalidTime();
+            else
+                aTime = maLastTime;
+        }
     }
 
     return aTime;
@@ -3077,7 +3117,10 @@ Time TimeFormatter::GetRealTime() const
 
     if ( GetField() )
     {
-        ImplTimeGetValue( GetField()->GetText(), aTime, GetFormat(), GetTimeFormat(), IsDuration(), ImplGetLocaleDataWrapper() );
+        BOOL bAllowMailformed = ImplAllowMalformedInput();
+        if ( !ImplTimeGetValue( GetField()->GetText(), aTime, GetFormat(), GetTimeFormat(), IsDuration(), ImplGetLocaleDataWrapper(), !bAllowMailformed ) )
+            if ( bAllowMailformed )
+                aTime = GetInvalidTime();
     }
 
     return aTime;
@@ -3201,7 +3244,18 @@ long TimeField::Notify( NotifyEvent& rNE
     else if ( rNEvt.GetType() == EVENT_LOSEFOCUS )
     {
         if ( MustBeReformatted() && (GetText().Len() || !IsEmptyFieldValueEnabled()) )
-            Reformat();
+        {
+            if ( !ImplAllowMalformedInput() )
+                Reformat();
+            else
+            {
+                Time aTime( 0, 0, 0 );
+                if ( ImplTimeGetValue( GetText(), aTime, GetFormat(), GetTimeFormat(), IsDuration(), ImplGetLocaleDataWrapper(), FALSE ) )
+                    // even with strict text analysis, our text is a valid time -> do a complete
+                    // reformat
+                    Reformat();
+            }
+        }
     }
 
     return SpinField::Notify( rNEvt );
Index: vcl/source/control/fixbrd.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/fixbrd.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.4
diff -u -p -u -r1.1.1.1 -r1.4
--- vcl/source/control/fixbrd.cxx	18 Sep 2000 17:05:36 -0000	1.1.1.1
+++ vcl/source/control/fixbrd.cxx	10 May 2004 15:46:54 -0000	1.4
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_FIXBRD_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
@@ -71,7 +69,7 @@
 #include <fixbrd.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -164,8 +162,26 @@ void FixedBorder::ImplDraw( OutputDevice
 		 (rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
 		nBorderStyle |= FRAME_DRAW_MONO;
 
-	DecorationView	aDecoView( pDev );
-	aDecoView.DrawFrame( aRect, nBorderStyle );
+    /*
+    // seems only to be used in tools->options around a tabpage (ie, no tabcontrol!)
+    // as tabpages that are not embedded in a tabcontrol should not be drawn natively
+    // the fixedborder must also not be drawn (reason was, that it looks too ugly, dialogs must be redesigned)
+    Window *pWin = pDev->GetOutDevType() == OUTDEV_WINDOW ? (Window*) pDev : NULL;
+    if( !(nBorderStyle & FRAME_DRAW_MONO) && pWin && pWin->IsNativeControlSupported( CTRL_FIXEDBORDER, PART_ENTIRE_CONTROL ) )
+    {
+        ImplControlValue aControlValue;
+        Point aPt;
+        Region aCtrlRegion( Rectangle( aPt, GetOutputSizePixel() ) );
+        ControlState nState = IsEnabled() ? CTRL_STATE_ENABLED : 0;
+        pWin->DrawNativeControl( CTRL_FIXEDBORDER, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+	     						aControlValue, rtl::OUString() );
+    }
+    else
+    */
+    {
+	    DecorationView	aDecoView( pDev );
+	    aDecoView.DrawFrame( aRect, nBorderStyle );
+    }
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/control/fixed.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/fixed.cxx,v
retrieving revision 1.10
retrieving revision 1.12
diff -u -p -u -r1.10 -r1.12
--- vcl/source/control/fixed.cxx	17 Oct 2002 14:47:00 -0000	1.10
+++ vcl/source/control/fixed.cxx	6 Jan 2004 13:19:05 -0000	1.12
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_FIXED_CXX
-
 #ifndef _SV_DECOVIEW_HXX
 #include <decoview.hxx>
 #endif
@@ -74,9 +72,9 @@
 #include <controllayout.hxx>
 #endif
 
-#include <rc.h>
+#include <tools/rc.h>
+
 
-#pragma hdrstop
 
 // =======================================================================
 
Index: vcl/source/control/group.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/group.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/source/control/group.cxx	8 May 2002 16:01:30 -0000	1.2
+++ vcl/source/control/group.cxx	6 Jan 2004 13:19:32 -0000	1.4
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_GROUP_CXX
-
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
 #endif
@@ -72,10 +70,10 @@
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
Index: vcl/source/control/ilstbox.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/ilstbox.cxx,v
retrieving revision 1.41
retrieving revision 1.47
diff -u -p -u -r1.41 -r1.47
--- vcl/source/control/ilstbox.cxx	24 Apr 2003 16:31:26 -0000	1.41
+++ vcl/source/control/ilstbox.cxx	17 Jun 2004 12:12:49 -0000	1.47
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_ILSTBOX_CXX
-
 #ifndef _TOOLS_DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -106,7 +104,7 @@
 #include <com/sun/star/accessibility/XAccessible.hpp>
 #endif
 
-#pragma hdrstop
+
 
 using namespace ::com::sun::star;
 
@@ -149,10 +147,14 @@ void ImplInitDropDownButton( PushButton*
 		pButton->SetSymbol( SYMBOL_SPIN_UPDOWN );
 	else
 		pButton->SetSymbol( SYMBOL_SPIN_DOWN );
+
+	if ( pButton->IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! pButton->IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+		pButton->SetBackground();
 }
 
 // =======================================================================
-
+
 ImplEntryList::ImplEntryList( Window* pWindow )
 {
     mpWindow = pWindow;
@@ -207,7 +209,7 @@ uno::Reference< i18n::XCollator > ImplGe
 		xCollator = vcl::unohelper::CreateCollator();
 	if( xCollator.is() )
 		xCollator->loadDefaultCollator (rLocale, 0);
-	
+
 	return xCollator;
 }
 
@@ -222,7 +224,7 @@ USHORT ImplEntryList::InsertEntry( USHOR
 	}
 	else
 	{
-		lang::Locale aLocale = Application::GetSettings().GetLocale(); 
+		lang::Locale aLocale = Application::GetSettings().GetLocale();
 		uno::Reference< i18n::XCollator > xCollator = ImplGetCollator(aLocale);
 
 		const XubString& rStr = pNewEntry->maStr;
@@ -289,8 +291,8 @@ USHORT ImplEntryList::InsertEntry( USHOR
 		{
 			// XXX this is arguable, if the exception occured because pNewEntry is
 			// garbage you wouldn't insert it. If the exception occured because the
-			// Collator implementation is garbage then give the user a chance to see 
-			// his stuff 
+			// Collator implementation is garbage then give the user a chance to see
+			// his stuff
 			Insert( pNewEntry, (ULONG)0 );
 		}
 
@@ -512,10 +514,12 @@ ImplListBoxWindow::ImplListBoxWindow( Wi
     mbHasFocusRect      = FALSE;
 	mbSimpleMode		= ( nWinStyle & WB_SIMPLEMODE ) ? TRUE : FALSE;
 	mbSort				= ( nWinStyle & WB_SORT ) ? TRUE : FALSE;
+	// pb: #106948# explicit mirroring for calc
+	mbMirroring			= FALSE;
 
 	mnCurrentPos			= LISTBOX_ENTRY_NOTFOUND;
 	mnTrackingSaveSelection = LISTBOX_ENTRY_NOTFOUND;
-	mnSeparatorPos		= LISTBOX_ENTRY_NOTFOUND;
+	mnSeparatorPos			= LISTBOX_ENTRY_NOTFOUND;
 
 	SetLineColor();
 	SetTextFillColor();
@@ -773,6 +777,16 @@ void ImplListBoxWindow::ImplHideFocusRec
 
 // -----------------------------------------------------------------------
 
+USHORT ImplListBoxWindow::GetEntryPosForPoint( const Point& rPoint ) const
+{
+    USHORT nSelect = (USHORT) ( ( rPoint.Y() + mnBorder ) / mnMaxHeight ) + (USHORT) mnTop;
+    if( nSelect < mnTop || nSelect >= mpEntryList->GetEntryCount() )
+        nSelect = LISTBOX_ENTRY_NOTFOUND;
+    return nSelect;
+}
+
+// -----------------------------------------------------------------------
+
 void ImplListBoxWindow::MouseButtonDown( const MouseEvent& rMEvt )
 {
 	mbMouseMoveSelect = FALSE;	// Nur bis zum ersten MouseButtonDown
@@ -782,8 +796,8 @@ void ImplListBoxWindow::MouseButtonDown(
 	{
 		if( rMEvt.GetClicks() == 1 )
 		{
-			USHORT nSelect = (USHORT) ( ( rMEvt.GetPosPixel().Y() + mnBorder ) / mnMaxHeight ) + (USHORT) mnTop;
-			if( nSelect < mpEntryList->GetEntryCount() )
+			USHORT nSelect = GetEntryPosForPoint( rMEvt.GetPosPixel() );
+			if( nSelect != LISTBOX_ENTRY_NOTFOUND )
 			{
 				if ( !mbMulti && GetEntryList()->GetSelectEntryCount() )
 					mnTrackingSaveSelection = GetEntryList()->GetSelectEntryPos( 0 );
@@ -815,12 +829,10 @@ void ImplListBoxWindow::MouseButtonDown(
 
 void ImplListBoxWindow::MouseMove( const MouseEvent& rMEvt )
 {
-    if ( rMEvt.IsLeaveWindow() ) 
+    if ( rMEvt.IsLeaveWindow() )
     {
 		if ( mbStackMode && IsMouseMoveSelect() && IsReallyVisible() )
 		{
-			Size aSz = GetOutputSizePixel();
-//			if ( ( rMEvt.GetPosPixel().X() < 0 ) || ( rMEvt.GetPosPixel().X() > aSz.Width() ) )
 			if ( rMEvt.GetPosPixel().Y() < 0 )
 			{
 				DeselectAll();
@@ -1212,7 +1224,7 @@ void ImplListBoxWindow::Tracking( const 
 				        if ( ( rTEvt.GetMouseEvent().GetPosPixel().Y() < 0 ) || ( rTEvt.GetMouseEvent().GetPosPixel().Y() > GetOutputSizePixel().Height() ) )
 				        {
                             BOOL bSelectionChanged = FALSE;
-                            if ( ( rTEvt.GetMouseEvent().GetPosPixel().Y() < 0 ) 
+                            if ( ( rTEvt.GetMouseEvent().GetPosPixel().Y() < 0 )
                                    && !mnCurrentPos )
                             {
                                 if ( mpEntryList->IsEntryPosSelected( 0 ) )
@@ -1525,8 +1537,6 @@ BOOL ImplListBoxWindow::ProcessKeyInput(
 		DBG_ASSERT( (nSelect != mnCurrentPos) || mbMulti, "ImplListBox: Selecting same Entry" );
 	    if( nSelect >= mpEntryList->GetEntryCount() )
             nSelect = mpEntryList->GetEntryCount()-1;
-        else if (nSelect < 0 )
-            nSelect = 0;
 		mnCurrentPos = nSelect;
 		if ( SelectEntries( nSelect, eLET, bShift, bCtrl ) )
 		{
@@ -1605,15 +1615,21 @@ void ImplListBoxWindow::DrawEntry( USHOR
 		nPos = mnUserDrawEntry; // real entry, not the matching entry from MRU
 
 	long nY = ( nPos - mnTop ) * mnMaxHeight;
+	Size aImgSz;
 
 	if( bDrawImage && mpEntryList->HasImages() && !bLayout )
 	{
 		Image aImage = mpEntryList->GetEntryImage( nPos );
 		if( !!aImage )
 		{
-			Size aImgSz = aImage.GetSizePixel();
+			aImgSz = aImage.GetSizePixel();
 			Point aPtImg( mnBorder - mnLeft, nY + ( ( mnMaxHeight - aImgSz.Height() ) / 2 ) );
 
+			// pb: #106948# explicit mirroring for calc
+			if ( mbMirroring )
+				// right aligned
+				aPtImg.X() = mnMaxWidth + mnBorder - aImgSz.Width() - mnLeft;
+
 			if ( !IsZoom() )
 			{
 				DrawImage( aPtImg, aImage );
@@ -1642,6 +1658,19 @@ void ImplListBoxWindow::DrawEntry( USHOR
 			}
             if( bLayout )
                 mpLayoutData->m_aLineIndices.push_back( mpLayoutData->m_aDisplayText.Len() );
+
+			// pb: #106948# explicit mirroring for calc
+			if ( mbMirroring )
+			{
+				// right aligned
+				long nSBWidth = GetSettings().GetStyleSettings().GetScrollBarSize();
+				long nMaxWidth = Max( static_cast< long >( mnMaxWidth ),
+									  GetOutputSizePixel().Width() - 2*mnBorder );
+				aPtTxt.X() = nMaxWidth + mnBorder - GetTextWidth( aStr ) - mnLeft;
+				if ( aImgSz.Width() > 0 )
+					aPtTxt.X() -= ( aImgSz.Width() + IMG_TXT_DISTANCE );
+			}
+
 			DrawText( aPtTxt, aStr, 0, STRING_LEN, pVector, pDisplayText );
 		}
 	}
@@ -1714,7 +1743,7 @@ USHORT ImplListBoxWindow::GetDisplayLine
 {
 	USHORT nCount = mpEntryList->GetEntryCount();
 	long nHeight = GetOutputSizePixel().Height();// - mnMaxHeight + mnBorder;
-    USHORT nEntries = (nHeight + mnMaxHeight-1)/mnMaxHeight;
+    USHORT nEntries = static_cast< USHORT >( ( nHeight + mnMaxHeight - 1 ) / mnMaxHeight );
     if( nEntries > nCount-mnTop )
         nEntries = nCount-mnTop;
 
@@ -1737,6 +1766,8 @@ void ImplListBoxWindow::Resize()
 
     if ( bShowFocusRect )
         ImplShowFocusRect();
+
+    delete mpLayoutData, mpLayoutData = NULL;
 }
 
 // -----------------------------------------------------------------------
@@ -1900,6 +1931,7 @@ void ImplListBoxWindow::StateChanged( St
 		ImplInitSettings( FALSE, FALSE, TRUE );
 		Invalidate();
 	}
+    delete mpLayoutData, mpLayoutData = NULL;
 }
 
 // -----------------------------------------------------------------------
@@ -1926,6 +1958,9 @@ ImplListBox::ImplListBox( Window* pParen
 	Control( pParent, nWinStyle ),
 	maLBWindow( this, nWinStyle&(~WB_BORDER) )
 {
+    // for native widget rendering we must be able to detect this window type
+    SetType( WINDOW_LISTBOXWINDOW );
+
 	mpVScrollBar	= new ScrollBar( this, WB_VSCROLL | WB_DRAG );
 	mpHScrollBar	= new ScrollBar( this, WB_HSCROLL | WB_DRAG );
 	mpScrollBarBox	= new ScrollBarBox( this );
@@ -2192,13 +2227,17 @@ void ImplListBox::ImplResizeControls()
 	if ( mbHScroll )
 		aInnerSz.Height() -= nSBWidth;
 
-	maLBWindow.SetPosSizePixel( Point(), aInnerSz );
+	// pb: #106948# explicit mirroring for calc
+	// Scrollbar on left or right side?
+	BOOL bMirroring = maLBWindow.IsMirroring();
+	Point aWinPos( bMirroring && mbVScroll ? nSBWidth : 0, 0 );
+	maLBWindow.SetPosSizePixel( aWinPos, aInnerSz );
 
 	// ScrollBarBox
 	if( mbVScroll && mbHScroll )
 	{
-		mpScrollBarBox->SetPosSizePixel( Point( aInnerSz.Width(), aInnerSz.Height() ),
-										 Size( nSBWidth, nSBWidth ) );
+		Point aBoxPos( bMirroring ? 0 : aInnerSz.Width(), aInnerSz.Height() );
+		mpScrollBarBox->SetPosSizePixel( aBoxPos, Size( nSBWidth, nSBWidth ) );
 		mpScrollBarBox->Show();
 	}
 	else
@@ -2209,8 +2248,9 @@ void ImplListBox::ImplResizeControls()
 	// vert. ScrollBar
 	if( mbVScroll )
 	{
-		mpVScrollBar->SetPosSizePixel( Point( aOutSz.Width()-nSBWidth, 0 ),
-									   Size( nSBWidth, aInnerSz.Height() ) );
+		// Scrollbar on left or right side?
+		Point aVPos( bMirroring ? 0 : aOutSz.Width() - nSBWidth, 0 );
+		mpVScrollBar->SetPosSizePixel( aVPos, Size( nSBWidth, aInnerSz.Height() ) );
 		mpVScrollBar->Show();
 	}
 	else
@@ -2223,8 +2263,8 @@ void ImplListBox::ImplResizeControls()
 	// horz. ScrollBar
 	if( mbHScroll )
 	{
-		mpHScrollBar->SetPosSizePixel( Point( 0, aOutSz.Height()-nSBWidth ),
-									   Size( aInnerSz.Width(), nSBWidth ) );
+		Point aHPos( ( bMirroring && mbVScroll ) ? nSBWidth : 0, aOutSz.Height() - nSBWidth );
+		mpHScrollBar->SetPosSizePixel( aHPos, Size( aInnerSz.Width(), nSBWidth ) );
 		mpHScrollBar->Show();
 	}
 	else
@@ -2390,7 +2430,12 @@ XubString ImplListBox::GetMRUEntries( xu
 ImplWin::ImplWin( Window* pParent, WinBits nWinStyle ) :
 	Control ( pParent, nWinStyle )
 {
-	SetBackground( Wallpaper( GetSettings().GetStyleSettings().GetFieldColor() ) );
+	if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+		SetBackground();
+	else
+		SetBackground( Wallpaper( GetSettings().GetStyleSettings().GetFieldColor() ) );
+
 	mbInUserDraw = FALSE;
 	mbUserDrawEnabled = FALSE;
 	mnItemPos = LISTBOX_ENTRY_NOTFOUND;
@@ -2448,12 +2493,76 @@ void ImplWin::FillLayoutData() const
 
 // -----------------------------------------------------------------------
 
+long ImplWin::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( pMouseEvt->IsEnterWindow() || pMouseEvt->IsLeaveWindow() )
+        {
+            // trigger redraw as mouse over state has changed
+            if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+            {
+                GetParent()->GetWindow( WINDOW_BORDER )->Invalidate( INVALIDATE_NOERASE );
+                GetParent()->GetWindow( WINDOW_BORDER )->Update();
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void ImplWin::ImplDraw( bool bLayout )
 {
 	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
 
+    BOOL bNativeOK = FALSE;
+
     if( ! bLayout )
     {
+        if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+			&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+        {
+	        // Repaint the (focused) area similarly to
+	        // ImplSmallBorderWindowView::DrawWindow() in
+	        // vcl/source/window/brdwin.cxx
+	        Window *pWin = GetParent();
+
+	        ImplControlValue aControlValue;
+	        ControlState nState = CTRL_STATE_ENABLED;
+	        if ( !pWin->IsEnabled() )
+		    nState &= ~CTRL_STATE_ENABLED;
+	        if ( pWin->HasFocus() )
+		    nState |= CTRL_STATE_FOCUSED;
+    	    
+	        // The listbox is painted over the entire control including the
+	        // border, but ImplWin does not contain the border => correction
+	        // needed.
+	        long nLeft, nTop, nRight, nBottom;
+	        pWin->GetBorder( nLeft, nTop, nRight, nBottom );
+	        Point aPoint( -nLeft, -nTop );
+	        Region aCtrlRegion( Rectangle( aPoint - GetPosPixel(), pWin->GetSizePixel() ) );
+
+            BOOL bMouseOver = FALSE;
+            if( GetParent() )
+            {
+                Window *pChild = GetParent()->GetWindow( WINDOW_FIRSTCHILD );
+                while( pChild && !(bMouseOver = pChild->IsMouseOver()) )
+                    pChild = pChild->GetWindow( WINDOW_NEXT );
+            }
+    	    
+            if( bMouseOver )
+                nState |= CTRL_STATE_ROLLOVER;
+
+	        bNativeOK = DrawNativeControl( CTRL_LISTBOX, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+		        aControlValue, rtl::OUString() );
+	    }
+
         if( IsEnabled() )
         {
             if( HasFocus() )
@@ -2468,13 +2577,15 @@ void ImplWin::ImplDraw( bool bLayout )
                 if( IsControlForeground() )
                     aColor = GetControlForeground();
                 SetTextColor( aColor );
-                Erase( maFocusRect );
+		        if ( !bNativeOK )
+		            Erase( maFocusRect );
             }
         }
         else // Disabled
         {
             SetTextColor( rStyleSettings.GetDisableColor() );
-            Erase( maFocusRect );
+	        if ( !bNativeOK )
+		        Erase( maFocusRect );
         }
     }
 
@@ -2594,7 +2705,7 @@ void ImplWin::LoseFocus()
 }
 
 // =======================================================================
-
+
 ImplBtn::ImplBtn( Window* pParent, WinBits nWinStyle ) :
 	PushButton(  pParent, nWinStyle ),
 	mbDown	( FALSE )
@@ -2696,11 +2807,19 @@ void ImplListBoxFloatingWindow::SetPosSi
 
 // -----------------------------------------------------------------------
 
+void ImplListBoxFloatingWindow::Resize()
+{
+    mpImplLB->GetMainWindow()->ImplClearLayoutData();
+    FloatingWindow::Resize();
+}
+
+// -----------------------------------------------------------------------
+
 Size ImplListBoxFloatingWindow::CalcFloatSize()
 {
 	Size aFloatSz( maPrefSz );
 
-	long nLeft, nTop, nRight, nBottom;
+	sal_Int32 nLeft, nTop, nRight, nBottom;
 	GetBorder( nLeft, nTop, nRight, nBottom );
 
 	USHORT nLines = mpImplLB->GetEntryList()->GetEntryCount();
@@ -2783,5 +2902,7 @@ void ImplListBoxFloatingWindow::StartFlo
 
 		if ( mpImplLB->GetMainWindow()->IsGrabFocusAllowed() )
 			mpImplLB->GetMainWindow()->GrabFocus();
+
+        mpImplLB->GetMainWindow()->ImplClearLayoutData();
 	}
 }
Index: vcl/source/control/imgctrl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/imgctrl.cxx,v
retrieving revision 1.7
retrieving revision 1.8
diff -u -p -u -r1.7 -r1.8
--- vcl/source/control/imgctrl.cxx	15 Aug 2002 14:48:40 -0000	1.7
+++ vcl/source/control/imgctrl.cxx	6 Jan 2004 13:20:30 -0000	1.8
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_IMGCTRL_CXX
-
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
 #endif
@@ -71,16 +69,16 @@
 ImageControl::ImageControl( Window* pParent, WinBits nStyle ) :
     FixedImage( pParent, nStyle )
 {
-    mnDummy1_mbScaleImage = TRUE;
+    mbScaleImage = TRUE;
 }
 
 // -----------------------------------------------------------------------
 
 void ImageControl::SetScaleImage( BOOL bScale )
 {
-    if ( bScale != mnDummy1_mbScaleImage )
+    if ( bScale != mbScaleImage )
     {
-        mnDummy1_mbScaleImage = bScale;
+        mbScaleImage = bScale;
         Invalidate();
     }
 }
@@ -90,7 +88,7 @@ void ImageControl::SetScaleImage( BOOL b
 BOOL ImageControl::IsScaleImage() const 
 {
     // Make inline when changing member from dummy... 
-    return (BOOL)mnDummy1_mbScaleImage; 
+    return mbScaleImage; 
 }
 
 
@@ -123,7 +121,7 @@ void ImageControl::UserDraw( const UserD
 		Image aImage( maBmp );
 		if ( !!aImage )
 		{
-			if ( mnDummy1_mbScaleImage )
+			if ( mbScaleImage )
 				rUDEvt.GetDevice()->DrawImage( rUDEvt.GetRect().TopLeft(),
 												rUDEvt.GetRect().GetSize(), 
 												aImage, nStyle );
@@ -139,7 +137,7 @@ void ImageControl::UserDraw( const UserD
 	}
 	else
 	{
-		if ( mnDummy1_mbScaleImage )
+		if ( mbScaleImage )
 		{
 			maBmp.Draw( rUDEvt.GetDevice(),
 						rUDEvt.GetRect().TopLeft(),
Index: vcl/source/control/longcurr.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/longcurr.cxx,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -p -u -r1.5 -r1.7
--- vcl/source/control/longcurr.cxx	29 Jun 2001 10:39:19 -0000	1.5
+++ vcl/source/control/longcurr.cxx	6 Jan 2004 13:21:10 -0000	1.7
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define VCL_LONGCURR_CXX
-
 #include <sot/object.hxx>
 #define _TOOLS_BIGINT
 #include <sot/factory.hxx>
@@ -73,7 +71,7 @@
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
 #include <event.hxx>
@@ -81,7 +79,7 @@
 #include <svdata.hxx>
 #include <longcurr.hxx>
 
-#pragma hdrstop
+
 
 #ifndef _UNOTOOLS_LOCALEDATAWRAPPER_HXX
 #include <unotools/localedatawrapper.hxx>
Index: vcl/source/control/lstbox.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/lstbox.cxx,v
retrieving revision 1.22
retrieving revision 1.28
diff -u -p -u -r1.22 -r1.28
--- vcl/source/control/lstbox.cxx	12 Jun 2003 08:18:53 -0000	1.22
+++ vcl/source/control/lstbox.cxx	17 Jun 2004 12:13:15 -0000	1.28
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_LSTBOX_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -101,7 +99,7 @@
 #include <tools/debug.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -177,11 +175,11 @@ void ListBox::ImplInit( Window* pParent,
 
 	if( nStyle & WB_DROPDOWN )
 	{
-		long nLeft, nTop, nRight, nBottom;
+		sal_Int32 nLeft, nTop, nRight, nBottom;
 		GetBorder( nLeft, nTop, nRight, nBottom );
 		mnDDHeight = (USHORT)(GetTextHeight() + nTop + nBottom + 4);
 
-		mpFloatWin	= new ImplListBoxFloatingWindow( this );
+		mpFloatWin = new ImplListBoxFloatingWindow( this );
 		mpFloatWin->SetAutoWidth( TRUE );
 		mpFloatWin->SetPopupModeEndHdl( LINK( this, ListBox, ImplPopupModeEndHdl ) );
 
@@ -344,6 +342,12 @@ IMPL_LINK( ListBox, ImplClickBtnHdl, voi
 		mpBtn->SetPressed( TRUE );
 		mpFloatWin->StartFloat( TRUE );
         ImplCallEventListeners( VCLEVENT_DROPDOWN_OPEN );
+
+        ImplClearLayoutData();
+        if( mpImplLB )
+            mpImplLB->GetMainWindow()->ImplClearLayoutData();
+        if( mpImplWin )
+            mpImplWin->ImplClearLayoutData();
 	}
 
 	return 0;
@@ -366,6 +370,12 @@ IMPL_LINK( ListBox, ImplPopupModeEndHdl,
         }
     }
 
+    ImplClearLayoutData();
+    if( mpImplLB )
+        mpImplLB->GetMainWindow()->ImplClearLayoutData();
+    if( mpImplWin )
+        mpImplWin->ImplClearLayoutData();
+
     mpBtn->SetPressed( FALSE );
     ImplCallEventListeners( VCLEVENT_DROPDOWN_CLOSE );
 	return 0;
@@ -547,6 +557,8 @@ void ListBox::DataChanged( const DataCha
 		 ((rDCEvt.GetType() == DATACHANGED_SETTINGS) &&
 		  (rDCEvt.GetFlags() & SETTINGS_STYLE)) )
 	{
+        SetBackground();    // due to a hack in Window::UpdateSettings the background must be reset 
+                            // otherwise it will overpaint NWF drawn listboxes
 		Resize();
 		mpImplLB->Resize(); // Wird nicht durch ListBox::Resize() gerufen, wenn sich die ImplLB nicht aendert.
 
@@ -619,7 +631,7 @@ void ListBox::SetPosSizePixel( long nX, 
 	if( IsDropDownBox() && ( nFlags & WINDOW_POSSIZE_SIZE ) )
 	{
 		Size aPrefSz = mpFloatWin->GetPrefSize();
-		if ( ( nFlags & WINDOW_POSSIZE_HEIGHT ) && ( nHeight > mnDDHeight ) )
+		if ( ( nFlags & WINDOW_POSSIZE_HEIGHT ) && ( nHeight >= 2*mnDDHeight ) )
 			aPrefSz.Height() = nHeight-mnDDHeight;
 		if ( nFlags & WINDOW_POSSIZE_WIDTH )
 			aPrefSz.Width() = nWidth;
@@ -639,10 +651,50 @@ void ListBox::Resize()
 	Size aOutSz = GetOutputSizePixel();
 	if( IsDropDownBox() )
 	{
+		// initialize the dropdown button size with the standard scrollbar width
 		long nSBWidth = GetSettings().GetStyleSettings().GetScrollBarSize();
-		nSBWidth = CalcZoom( nSBWidth );
-		mpImplWin->SetPosSizePixel( 0, 0, aOutSz.Width() - nSBWidth, aOutSz.Height() );
-		mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, 0, nSBWidth, aOutSz.Height() );
+		long	nTop = 0;
+		long	nBottom = aOutSz.Height();
+
+		Window *pBorder = GetWindow( WINDOW_BORDER );
+		ImplControlValue aControlValue;
+		Point aPoint;
+		Region aContent, aBound;
+
+		// use the full extent of the control
+		Region aArea( Rectangle(aPoint, pBorder->GetOutputSizePixel()) );
+
+		if ( GetNativeControlRegion( CTRL_LISTBOX, PART_BUTTON_DOWN,
+					aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+		{
+			// convert back from border space to local coordinates
+			aPoint = pBorder->ScreenToOutputPixel( OutputToScreenPixel( aPoint ) );
+			aContent.Move( -aPoint.X(), -aPoint.Y() );
+
+			// use the themes drop down size for the button
+			aOutSz.Width() = aContent.GetBoundRect().Left();
+			mpBtn->SetPosSizePixel( aContent.GetBoundRect().Left(), nTop, aContent.GetBoundRect().Right(), (nBottom-nTop) );
+
+			// adjust the size of the edit field
+			if ( GetNativeControlRegion( CTRL_LISTBOX, PART_SUB_EDIT,
+						aArea, 0, aControlValue, rtl::OUString(), aBound, aContent) )
+			{
+				// convert back from border space to local coordinates
+				aContent.Move( -aPoint.X(), -aPoint.Y() );
+
+				// use the themes drop down size
+				Rectangle aContentRect = aContent.GetBoundRect();
+				mpImplWin->SetPosSizePixel( aContentRect.TopLeft(), aContentRect.GetSize() );
+			}
+			else
+				mpImplWin->SetSizePixel( aOutSz );
+		}
+		else
+		{
+			nSBWidth = CalcZoom( nSBWidth );
+			mpImplWin->SetPosSizePixel( 0, 0, aOutSz.Width() - nSBWidth, aOutSz.Height() );
+			mpBtn->SetPosSizePixel( aOutSz.Width() - nSBWidth, 0, nSBWidth, aOutSz.Height() );
+		}
 	}
 	else
 	{
@@ -698,7 +809,13 @@ void ListBox::StateChanged( StateChanged
 		if( mpImplWin )
 		{
 			mpImplWin->Enable( IsEnabled() );
-			mpImplWin->Invalidate();
+			if ( IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL)
+					&& ! IsNativeControlSupported(CTRL_LISTBOX, PART_BUTTON_DOWN) )
+			{
+				GetWindow( WINDOW_BORDER )->Invalidate( INVALIDATE_NOERASE );
+			}
+			else
+				mpImplWin->Invalidate();
 		}
 		if( mpBtn )
 			mpBtn->Enable( IsEnabled() );
@@ -745,8 +862,17 @@ void ListBox::StateChanged( StateChanged
 		mpImplLB->SetControlBackground( GetControlBackground() );
 		if ( mpImplWin )
 		{
-			mpImplWin->SetBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
-			mpImplWin->SetControlBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
+			if ( mpImplWin->IsNativeControlSupported(CTRL_LISTBOX, PART_ENTIRE_CONTROL) )
+			{
+				// Transparent background
+				mpImplWin->SetBackground();
+				mpImplWin->SetControlBackground();
+			}
+			else
+			{
+				mpImplWin->SetBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
+				mpImplWin->SetControlBackground( mpImplLB->GetMainWindow()->GetControlBackground() );
+			}
 			mpImplWin->SetFont( mpImplLB->GetMainWindow()->GetFont() );
 			mpImplWin->Invalidate();
 		}
@@ -1134,7 +1260,7 @@ Size ListBox::CalcMinimumSize() const
 Size ListBox::CalcAdjustedSize( const Size& rPrefSize ) const
 {
 	Size aSz = rPrefSize;
-	long nLeft, nTop, nRight, nBottom;
+	sal_Int32 nLeft, nTop, nRight, nBottom;
 	((Window*)this)->GetBorder( nLeft, nTop, nRight, nBottom );
 	aSz.Height() -= nTop+nBottom;
 	if ( !IsDropDownBox() )
@@ -1232,16 +1358,6 @@ void ListBox::UserDraw( const UserDrawEv
 
 // -----------------------------------------------------------------------
 
-#if SUPD < 593
-void ListBox::DrawEntry( const UserDrawEvent& rEvt, BOOL bDrawImage, BOOL bDrawText )
-{
-	if ( rEvt.GetDevice() == mpImplLB->GetMainWindow() )
-		mpImplLB->GetMainWindow()->DrawEntry( rEvt.GetItemId(), bDrawImage, bDrawText );
-	else if ( rEvt.GetDevice() == mpImplWin )
-		mpImplWin->DrawEntry( bDrawImage, bDrawText );
-}
-#endif
-
 void ListBox::DrawEntry( const UserDrawEvent& rEvt, BOOL bDrawImage, BOOL bDrawText, BOOL bDrawTextAtImagePos )
 {
 	if ( rEvt.GetDevice() == mpImplLB->GetMainWindow() )
@@ -1354,6 +1470,15 @@ USHORT ListBox::GetMaxMRUCount() const
 USHORT ListBox::GetDisplayLineCount() const
 {
     return mpImplLB->GetDisplayLineCount();
+}
+
+// -----------------------------------------------------------------------
+
+// pb: #106948# explicit mirroring for calc
+
+void ListBox::EnableMirroring()
+{
+    mpImplLB->EnableMirroring();
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/control/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/source/control/makefile.mk,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -p -u -r1.5 -r1.6
--- vcl/source/control/makefile.mk	4 Jun 2003 11:22:05 -0000	1.5
+++ vcl/source/control/makefile.mk	6 Jan 2004 13:22:11 -0000	1.6
@@ -100,23 +100,11 @@ SLOFILES=	$(SLO)$/button.obj		\
 			$(SLO)$/spinbtn.obj 	\
 			$(SLO)$/tabctrl.obj
 
-.IF "$(remote)"!=""
-EXCEPTIONSFILES=					\
-			$(SLO)$/button.obj		\
-			$(SLO)$/ctrl.obj		\
-			$(SLO)$/edit.obj		\
-			$(SLO)$/field.obj		\
-			$(SLO)$/field2.obj		\
-			$(SLO)$/longcurr.obj	\
-			$(SLO)$/ilstbox.obj 	\
-			$(SLO)$/tabctrl.obj
-.ELSE
 EXCEPTIONSFILES=					\
 			$(SLO)$/edit.obj		\
 			$(SLO)$/field2.obj		\
 			$(SLO)$/ilstbox.obj		\
 			$(SLO)$/tabctrl.obj
-.ENDIF
 
 # --- Targets ------------------------------------------------------
 
Index: vcl/source/control/menubtn.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/menubtn.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/control/menubtn.cxx	18 Sep 2000 17:05:36 -0000	1.1.1.1
+++ vcl/source/control/menubtn.cxx	6 Jan 2004 13:22:49 -0000	1.3
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_MENUBTN_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_DECOVIEW_HXX
 #include <decoview.hxx>
@@ -80,7 +78,7 @@
 #include <menubtn.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
Index: vcl/source/control/morebtn.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/morebtn.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/control/morebtn.cxx	18 Sep 2000 17:05:36 -0000	1.1.1.1
+++ vcl/source/control/morebtn.cxx	6 Jan 2004 13:23:15 -0000	1.3
@@ -59,17 +59,15 @@
  *
  ************************************************************************/
 
-#define _SV_MOREBTN_CXX
-
 #ifndef _SV_MOREBTN_HXX
 #include <morebtn.hxx>
 #endif
 
 #ifndef _SV_RD_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
Index: vcl/source/control/scrbar.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/scrbar.cxx,v
retrieving revision 1.8
retrieving revision 1.13
diff -u -p -u -r1.8 -r1.13
--- vcl/source/control/scrbar.cxx	19 Jul 2002 11:12:18 -0000	1.8
+++ vcl/source/control/scrbar.cxx	10 May 2004 15:47:32 -0000	1.13
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SCRBAR_CXX
-
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
 #endif
@@ -73,12 +71,21 @@
 #ifndef _SV_SCRBAR_HXX
 #include <scrbar.hxx>
 #endif
+#ifndef _SV_TIMER_HXX
+#include <timer.hxx>
+#endif
+
+#ifndef _RTL_STRING_HXX_
+#include <rtl/string.hxx>
+#endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#pragma hdrstop
+
+
+using namespace rtl;
 
 // =======================================================================
 
@@ -95,9 +102,10 @@ static long ImplMulDiv( long nNumber, lo
 #define SCRBAR_DRAW_PAGE1           ((USHORT)0x0004)
 #define SCRBAR_DRAW_PAGE2           ((USHORT)0x0008)
 #define SCRBAR_DRAW_THUMB           ((USHORT)0x0010)
+#define SCRBAR_DRAW_BACKGROUND      ((USHORT)0x0020)
 #define SCRBAR_DRAW_ALL             (SCRBAR_DRAW_BTN1 | SCRBAR_DRAW_BTN2 |  \
                                      SCRBAR_DRAW_PAGE1 | SCRBAR_DRAW_PAGE2 |\
-                                     SCRBAR_DRAW_THUMB)
+                                     SCRBAR_DRAW_THUMB | SCRBAR_DRAW_BACKGROUND )
 
 #define SCRBAR_STATE_BTN1_DOWN      ((USHORT)0x0001)
 #define SCRBAR_STATE_BTN1_DISABLE   ((USHORT)0x0002)
@@ -111,10 +119,17 @@ static long ImplMulDiv( long nNumber, lo
 
 #define SCRBAR_VIEW_STYLE           (WB_3DLOOK | WB_HORZ | WB_VERT)
 
+struct ImplScrollBarData
+{
+	AutoTimer		maTimer;			// Timer
+    BOOL            mbHide;
+};
+
 // =======================================================================
 
 void ScrollBar::ImplInit( Window* pParent, WinBits nStyle )
 {
+    mpData              = NULL;
     mnThumbPixRange     = 0;
     mnThumbPixPos       = 0;
     mnThumbPixSize      = 0;
@@ -176,6 +191,8 @@ ScrollBar::ScrollBar( Window* pParent, c
 
 ScrollBar::~ScrollBar()
 {
+    if( mpData )
+        delete mpData;
 }
 
 // -----------------------------------------------------------------------
@@ -202,8 +219,8 @@ void ScrollBar::ImplLoadRes( const ResId
 
 BOOL ScrollBar::ImplUpdateThumbRect( const Rectangle& rOldRect )
 {
-    Size aThumbRectSize  = rOldRect.GetSize();
 /* !!! Wegen ueberlappenden Fenstern ... !!!
+    Size aThumbRectSize  = rOldRect.GetSize();
     if ( aThumbRectSize == maThumbRect.GetSize() )
     {
         DrawOutDev( maThumbRect.TopLeft(), aThumbRectSize,
@@ -263,10 +280,15 @@ void ScrollBar::ImplUpdateRects( BOOL bU
         }
     }
 
-    if ( mnThumbPos == mnMinRange )
-        mnStateFlags |= SCRBAR_STATE_BTN1_DISABLE;
-    if ( mnThumbPos >= (mnMaxRange-mnVisibleSize) )
-        mnStateFlags |= SCRBAR_STATE_BTN2_DISABLE;
+    if( !IsNativeControlSupported(CTRL_SCROLLBAR, PART_ENTIRE_CONTROL) )
+    {
+        // disable scrollbar buttons only in VCL's own 'theme'
+        // as it is uncommon on other platforms
+        if ( mnThumbPos == mnMinRange )
+            mnStateFlags |= SCRBAR_STATE_BTN1_DISABLE;
+        if ( mnThumbPos >= (mnMaxRange-mnVisibleSize) )
+            mnStateFlags |= SCRBAR_STATE_BTN2_DISABLE;
+    }
 
     if ( bUpdate )
     {
@@ -286,7 +308,7 @@ void ScrollBar::ImplUpdateRects( BOOL bU
             if ( !ImplUpdateThumbRect( aOldThumbRect ) )
                 nDraw |= SCRBAR_DRAW_THUMB;
         }
-        ImplDraw( nDraw );
+        ImplDraw( nDraw, this );
     }
 }
 
@@ -333,6 +355,10 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
         Size    aSize = GetOutputSizePixel();
         Size    aBtnSize;
 
+        Point aPoint( 0, 0 );
+        Region aControlRegion( Rectangle( aPoint, aSize ) );
+        Region aBtn1Region, aBtn2Region, aBoundingRegion;
+
         if ( GetStyle() & WB_HORZ )
         {
             if ( aSize.Height()*2 > aSize.Width()-SCRBAR_MIN_THUMB )
@@ -346,11 +372,22 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
             }
             else
             {
-                mnThumbPixRange         = aSize.Width()-(aSize.Height()*2);
-                aBtnSize                = Size( aSize.Height(), aSize.Height() );
-                maBtn2Rect.Left()       = aSize.Width()-aSize.Height();
-                maBtn1Rect.SetSize( aBtnSize );
-                maBtn2Rect.SetSize( aBtnSize );
+                if ( GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_LEFT,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn1Region ) &&
+                     GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_RIGHT,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn2Region ) )
+                {
+                    maBtn1Rect = aBtn1Region.GetBoundRect();
+                    maBtn2Rect = aBtn2Region.GetBoundRect();
+                }
+                else
+                {
+                    aBtnSize                = Size( aSize.Height(), aSize.Height() );
+                    maBtn2Rect.Left()       = aSize.Width()-aSize.Height();
+                    maBtn1Rect.SetSize( aBtnSize );
+                    maBtn2Rect.SetSize( aBtnSize );
+                }
+                mnThumbPixRange         = aSize.Width() - maBtn1Rect.GetWidth() - maBtn2Rect.GetWidth();
                 maPage1Rect.Left()      = maBtn1Rect.Right()+1;
                 maPage1Rect.Bottom()    = maBtn1Rect.Bottom();
                 maPage2Rect.Bottom()    = maBtn1Rect.Bottom();
@@ -370,11 +407,22 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
             }
             else
             {
-                mnThumbPixRange         = aSize.Height()-(aSize.Width()*2);
-                aBtnSize                = Size( aSize.Width(), aSize.Width() );
-                maBtn2Rect.Top()        = aSize.Height()-aSize.Width();
-                maBtn1Rect.SetSize( aBtnSize );
-                maBtn2Rect.SetSize( aBtnSize );
+                if ( GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_UP,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn1Region ) &&
+                     GetNativeControlRegion( CTRL_SCROLLBAR, PART_BUTTON_DOWN,
+                            aControlRegion, 0, ImplControlValue(), rtl::OUString(), aBoundingRegion, aBtn2Region ) )
+                {
+                    maBtn1Rect = aBtn1Region.GetBoundRect();
+                    maBtn2Rect = aBtn2Region.GetBoundRect();
+                }
+                else
+                {
+                    aBtnSize                = Size( aSize.Width(), aSize.Width() );
+                    maBtn2Rect.Top()        = aSize.Height()-aSize.Width();
+                    maBtn1Rect.SetSize( aBtnSize );
+                    maBtn2Rect.SetSize( aBtnSize );
+                }
+                mnThumbPixRange         = aSize.Height() - maBtn1Rect.GetHeight() - maBtn2Rect.GetHeight();
                 maPage1Rect.Top()       = maBtn1Rect.Bottom()+1;
                 maPage1Rect.Right()     = maBtn1Rect.Right();
                 maPage2Rect.Right()     = maBtn1Rect.Right();
@@ -434,12 +482,223 @@ void ScrollBar::ImplCalc( BOOL bUpdate )
 
 // -----------------------------------------------------------------------
 
-void ScrollBar::ImplDraw( USHORT nDrawFlags )
+void ScrollBar::Draw( OutputDevice* pDev, const Point& rPos, const Size& rSize, ULONG nFlags )
 {
-    DecorationView          aDecoView( this );
+    Point       aPos  = pDev->LogicToPixel( rPos );
+    Size        aSize = pDev->LogicToPixel( rSize );
+    Rectangle   aRect( aPos, aSize );
+
+    pDev->Push();
+    pDev->SetMapMode();
+    if ( !(nFlags & WINDOW_DRAW_MONO) )
+	{
+		// DecoView uses the FaceColor...
+		AllSettings aSettings = pDev->GetSettings();
+		StyleSettings aStyleSettings = aSettings.GetStyleSettings();
+		if ( IsControlBackground() )
+			aStyleSettings.SetFaceColor( GetControlBackground() );
+		else
+			aStyleSettings.SetFaceColor( GetSettings().GetStyleSettings().GetFaceColor() );
+
+		aSettings.SetStyleSettings( aStyleSettings );
+		pDev->SetSettings( aSettings );
+	}
+
+    // for printing: 
+    // -calculate the size of the rects
+    // -because this is zero-based add the correct offset
+    // -print
+    // -force recalculate
+
+    if ( mbCalcSize )
+        ImplCalc( FALSE );
+
+    maBtn1Rect+=aPos;
+    maBtn2Rect+=aPos;
+    maThumbRect+=aPos;
+    maPage1Rect+=aPos;
+    maPage2Rect+=aPos;
+
+    ImplDraw( SCRBAR_DRAW_ALL, pDev );
+    pDev->Pop();
+
+    mbCalcSize = TRUE;
+}
+
+// -----------------------------------------------------------------------
+
+BOOL ScrollBar::ImplDrawNative( USHORT nDrawFlags )
+{
+    BOOL bNativeOK = FALSE;
+    ImplControlValue aControlValue( BUTTONVALUE_DONTKNOW, rtl::OUString(), 0 );
+
+    if( bNativeOK = IsNativeControlSupported(CTRL_SCROLLBAR, PART_ENTIRE_CONTROL) )
+    {
+        BOOL bHorz = (GetStyle() & WB_HORZ ? true : false);
+
+        // Draw the entire background if the control supports it
+        if( IsNativeControlSupported(CTRL_SCROLLBAR, bHorz ? PART_DRAW_BACKGROUND_HORZ : PART_DRAW_BACKGROUND_VERT) )
+        {
+            Region  		aCtrlRegion;
+            ControlState		nState = ( IsEnabled() ? CTRL_STATE_ENABLED : 0 ) | ( HasFocus() ? CTRL_STATE_FOCUSED : 0 );
+            ScrollbarValue	scrValue;
+
+            scrValue.mnMin = mnMinRange;
+            scrValue.mnMax = mnMaxRange;
+            scrValue.mnCur = mnThumbPos;
+            scrValue.mnVisibleSize = mnVisibleSize;
+            scrValue.maThumbRect = maThumbRect;
+            scrValue.maButton1Rect = maBtn1Rect;
+            scrValue.maButton2Rect = maBtn2Rect;
+            scrValue.mnButton1State = ((mnStateFlags & SCRBAR_STATE_BTN1_DOWN) ? CTRL_STATE_PRESSED : 0) |
+								((!(mnStateFlags & SCRBAR_STATE_BTN1_DISABLE)) ? CTRL_STATE_ENABLED : 0);
+            scrValue.mnButton2State = ((mnStateFlags & SCRBAR_STATE_BTN2_DOWN) ? CTRL_STATE_PRESSED : 0) |
+								((!(mnStateFlags & SCRBAR_STATE_BTN2_DISABLE)) ? CTRL_STATE_ENABLED : 0);
+            scrValue.mnThumbState = nState | ((mnStateFlags & SCRBAR_STATE_THUMB_DOWN) ? CTRL_STATE_PRESSED : 0);
+            scrValue.mnPage1State = nState | ((mnStateFlags & SCRBAR_STATE_PAGE1_DOWN) ? CTRL_STATE_PRESSED : 0);
+            scrValue.mnPage2State = nState | ((mnStateFlags & SCRBAR_STATE_PAGE2_DOWN) ? CTRL_STATE_PRESSED : 0);
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maThumbRect )
+                        scrValue.mnThumbState |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maBtn1Rect )
+                        scrValue.mnButton1State |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maBtn2Rect )
+                        scrValue.mnButton2State |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maPage1Rect )
+                        scrValue.mnPage1State |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maPage2Rect )
+                        scrValue.mnPage2State |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            aControlValue.setOptionalVal( (void *)(&scrValue) );
+
+            aCtrlRegion.Union( maBtn1Rect );
+            aCtrlRegion.Union( maBtn2Rect );
+            aCtrlRegion.Union( maPage1Rect );
+            aCtrlRegion.Union( maPage2Rect );
+            aCtrlRegion.Union( maThumbRect );
+
+            bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, (bHorz ? PART_DRAW_BACKGROUND_HORZ : PART_DRAW_BACKGROUND_VERT),
+                            aCtrlRegion, nState, aControlValue, rtl::OUString() );
+        }
+        else
+      {
+        if ( (nDrawFlags & SCRBAR_DRAW_PAGE1) || (nDrawFlags & SCRBAR_DRAW_PAGE2) )
+        {
+            sal_uInt32	part1 = bHorz ? PART_TRACK_HORZ_LEFT : PART_TRACK_VERT_UPPER;
+            sal_uInt32	part2 = bHorz ? PART_TRACK_HORZ_RIGHT : PART_TRACK_VERT_LOWER;
+            Region  	aCtrlRegion1( maPage1Rect );
+            Region  	aCtrlRegion2( maPage2Rect );
+            ControlState nState1 = (IsEnabled() ? CTRL_STATE_ENABLED : 0) | (HasFocus() ? CTRL_STATE_FOCUSED : 0);
+            ControlState nState2 = nState1;
+
+            nState1 |= ((mnStateFlags & SCRBAR_STATE_PAGE1_DOWN) ? CTRL_STATE_PRESSED : 0);
+            nState2 |= ((mnStateFlags & SCRBAR_STATE_PAGE2_DOWN) ? CTRL_STATE_PRESSED : 0);
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maPage1Rect )
+                        nState1 |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maPage2Rect )
+                        nState2 |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            if ( nDrawFlags & SCRBAR_DRAW_PAGE1 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part1, aCtrlRegion1, nState1, 
+                                aControlValue, rtl::OUString() );
+
+            if ( nDrawFlags & SCRBAR_DRAW_PAGE2 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part2, aCtrlRegion2, nState2, 
+                                aControlValue, rtl::OUString() );
+        }
+        if ( (nDrawFlags & SCRBAR_DRAW_BTN1) || (nDrawFlags & SCRBAR_DRAW_BTN2) )
+        {
+            sal_uInt32	part1 = bHorz ? PART_BUTTON_LEFT : PART_BUTTON_UP;
+            sal_uInt32	part2 = bHorz ? PART_BUTTON_RIGHT : PART_BUTTON_DOWN;
+            Region  	aCtrlRegion1( maBtn1Rect );
+            Region  	aCtrlRegion2( maBtn2Rect );
+            ControlState nState1 = HasFocus() ? CTRL_STATE_FOCUSED : 0;
+            ControlState nState2 = nState1;
+
+            if ( !Window::IsEnabled() || !IsEnabled() )
+                nState1 = (nState2 &= ~CTRL_STATE_ENABLED);
+            else
+                nState1 = (nState2 |= CTRL_STATE_ENABLED);
+
+
+            nState1 |= ((mnStateFlags & SCRBAR_STATE_BTN1_DOWN) ? CTRL_STATE_PRESSED : 0);
+            nState2 |= ((mnStateFlags & SCRBAR_STATE_BTN2_DOWN) ? CTRL_STATE_PRESSED : 0);
+
+            if(mnStateFlags & SCRBAR_STATE_BTN1_DISABLE)
+                nState1 &= ~CTRL_STATE_ENABLED;
+            if(mnStateFlags & SCRBAR_STATE_BTN2_DISABLE)
+                nState2 &= ~CTRL_STATE_ENABLED;
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maBtn1Rect )
+                        nState1 |= CTRL_STATE_ROLLOVER;
+                    else if( pRect == &maBtn2Rect )
+                        nState2 |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            if ( nDrawFlags & SCRBAR_DRAW_BTN1 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part1, aCtrlRegion1, nState1, 
+                                aControlValue, rtl::OUString() );
+
+            if ( nDrawFlags & SCRBAR_DRAW_BTN2 )
+                bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, part2, aCtrlRegion2, nState2, 
+                                aControlValue, rtl::OUString() );
+        }
+        if ( (nDrawFlags & SCRBAR_DRAW_THUMB) && !maThumbRect.IsEmpty() )
+        {
+            ControlState	nState = IsEnabled() ? CTRL_STATE_ENABLED : 0;
+            Region		aCtrlRegion( maThumbRect );
+
+            if ( mnStateFlags & SCRBAR_STATE_THUMB_DOWN )
+                nState |= CTRL_STATE_PRESSED;
+
+            if ( HasFocus() )
+                nState |= CTRL_STATE_FOCUSED;
+
+            if( IsMouseOver() )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                if( pRect )
+                {
+                    if( pRect == &maThumbRect )
+                        nState |= CTRL_STATE_ROLLOVER;
+                }
+            }
+
+            bNativeOK = DrawNativeControl( CTRL_SCROLLBAR, (bHorz ? PART_THUMB_HORZ : PART_THUMB_VERT),
+                    aCtrlRegion, nState, aControlValue, rtl::OUString() );
+        }
+      }
+    }
+    return bNativeOK;
+}
+
+void ScrollBar::ImplDraw( USHORT nDrawFlags, OutputDevice* pOutDev )
+{
+    DecorationView          aDecoView( pOutDev );
     Rectangle               aTempRect;
     USHORT                  nStyle;
-    const StyleSettings&    rStyleSettings = GetSettings().GetStyleSettings();
+    const StyleSettings&    rStyleSettings = pOutDev->GetSettings().GetStyleSettings();
     SymbolType              eSymbolType;
     BOOL                    bEnabled = IsEnabled();
 
@@ -447,7 +706,18 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
     if ( mbCalcSize )
         ImplCalc( FALSE );
 
-    if ( nDrawFlags & SCRBAR_DRAW_BTN1 )
+    Window *pWin = NULL;
+    if( pOutDev->GetOutDevType() == OUTDEV_WINDOW )
+        pWin = (Window*) pOutDev;
+    
+    // Draw the entire control if the native theme engine needs it
+    if ( nDrawFlags && pWin && pWin->IsNativeControlSupported(CTRL_SCROLLBAR, PART_DRAW_BACKGROUND_HORZ) )
+    {
+        ImplDrawNative( SCRBAR_DRAW_BACKGROUND );
+        return;
+    }
+
+    if( (nDrawFlags & SCRBAR_DRAW_BTN1) && (!pWin || !ImplDrawNative( SCRBAR_DRAW_BTN1 ) ) )
     {
         nStyle = BUTTON_DRAW_NOLIGHTBORDER;
         if ( mnStateFlags & SCRBAR_STATE_BTN1_DOWN )
@@ -474,7 +744,7 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
         aDecoView.DrawSymbol( aTempRect, eSymbolType, rStyleSettings.GetButtonTextColor(), nStyle );
     }
 
-    if ( nDrawFlags & SCRBAR_DRAW_BTN2 )
+    if ( (nDrawFlags & SCRBAR_DRAW_BTN2) && (!pWin || !ImplDrawNative( SCRBAR_DRAW_BTN2 ) ) )
     {
         nStyle = BUTTON_DRAW_NOLIGHTBORDER;
         if ( mnStateFlags & SCRBAR_STATE_BTN2_DOWN )
@@ -501,19 +771,21 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
         aDecoView.DrawSymbol( aTempRect, eSymbolType, rStyleSettings.GetButtonTextColor(), nStyle );
     }
 
-    SetLineColor();
+    pOutDev->SetLineColor();
 
-    if ( nDrawFlags & SCRBAR_DRAW_THUMB )
+    if ( (nDrawFlags & SCRBAR_DRAW_THUMB) && (!pWin || !ImplDrawNative( SCRBAR_DRAW_THUMB ) ) )
     {
         if ( !maThumbRect.IsEmpty() )
         {
             if ( bEnabled )
             {
                 nStyle = BUTTON_DRAW_NOLIGHTBORDER;
-                if ( mnStateFlags & SCRBAR_STATE_THUMB_DOWN )
-                    nStyle |= BUTTON_DRAW_PRESSED;
+                // pressed thumbs only in OS2 style
+                if ( rStyleSettings.GetOptions() & STYLE_OPTION_OS2STYLE )
+                    if ( mnStateFlags & SCRBAR_STATE_THUMB_DOWN )
+                        nStyle |= BUTTON_DRAW_PRESSED;
                 aTempRect = aDecoView.DrawButton( maThumbRect, nStyle );
-                // Im OS2-Look geben wir auch ein Muster auf dem Thumb aus
+                // OS2 style requires pattern on the thumb
                 if ( rStyleSettings.GetOptions() & STYLE_OPTION_OS2STYLE )
                 {
                     if ( GetStyle() & WB_HORZ )
@@ -529,12 +801,12 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
                                 if ( nX > aTempRect.Right()-1 )
                                     break;
 
-                                SetLineColor( rStyleSettings.GetButtonTextColor() );
-                                DrawLine( Point( nX, aTempRect.Top()+1 ),
+                                pOutDev->SetLineColor( rStyleSettings.GetButtonTextColor() );
+                                pOutDev->DrawLine( Point( nX, aTempRect.Top()+1 ),
                                           Point( nX, aTempRect.Bottom()-1 ) );
                                 nX++;
-                                SetLineColor( rStyleSettings.GetLightColor() );
-                                DrawLine( Point( nX, aTempRect.Top()+1 ),
+                                pOutDev->SetLineColor( rStyleSettings.GetLightColor() );
+                                pOutDev->DrawLine( Point( nX, aTempRect.Top()+1 ),
                                           Point( nX, aTempRect.Bottom()-1 ) );
                                 nX++;
                             }
@@ -553,43 +825,43 @@ void ScrollBar::ImplDraw( USHORT nDrawFl
                                 if ( nY > aTempRect.Bottom()-1 )
                                     break;
 
-                                SetLineColor( rStyleSettings.GetButtonTextColor() );
-                                DrawLine( Point( aTempRect.Left()+1, nY ),
+                                pOutDev->SetLineColor( rStyleSettings.GetButtonTextColor() );
+                                pOutDev->DrawLine( Point( aTempRect.Left()+1, nY ),
                                           Point( aTempRect.Right()-1, nY ) );
                                 nY++;
-                                SetLineColor( rStyleSettings.GetLightColor() );
-                                DrawLine( Point( aTempRect.Left()+1, nY ),
+                                pOutDev->SetLineColor( rStyleSettings.GetLightColor() );
+                                pOutDev->DrawLine( Point( aTempRect.Left()+1, nY ),
                                           Point( aTempRect.Right()-1, nY ) );
                                 nY++;
                             }
                         }
                     }
-                    SetLineColor();
+                    pOutDev->SetLineColor();
                 }
             }
             else
             {
-                SetFillColor( rStyleSettings.GetCheckedColor() );
-                DrawRect( maThumbRect );
+                pOutDev->SetFillColor( rStyleSettings.GetCheckedColor() );
+                pOutDev->DrawRect( maThumbRect );
             }
         }
     }
 
-    if ( nDrawFlags & SCRBAR_DRAW_PAGE1 )
+    if ( (nDrawFlags & SCRBAR_DRAW_PAGE1) && (!pWin || !ImplDrawNative( SCRBAR_DRAW_PAGE1 ) ) )
     {
         if ( mnStateFlags & SCRBAR_STATE_PAGE1_DOWN )
-            SetFillColor( rStyleSettings.GetShadowColor() );
+            pOutDev->SetFillColor( rStyleSettings.GetShadowColor() );
         else
-            SetFillColor( rStyleSettings.GetCheckedColor() );
-        DrawRect( maPage1Rect );
+            pOutDev->SetFillColor( rStyleSettings.GetCheckedColor() );
+        pOutDev->DrawRect( maPage1Rect );
     }
-    if ( nDrawFlags & SCRBAR_DRAW_PAGE2 )
+    if ( (nDrawFlags & SCRBAR_DRAW_PAGE2) && (!pWin || !ImplDrawNative( SCRBAR_DRAW_PAGE2 ) ) )
     {
         if ( mnStateFlags & SCRBAR_STATE_PAGE2_DOWN )
-            SetFillColor( rStyleSettings.GetShadowColor() );
+            pOutDev->SetFillColor( rStyleSettings.GetShadowColor() );
         else
-            SetFillColor( rStyleSettings.GetCheckedColor() );
-        DrawRect( maPage2Rect );
+            pOutDev->SetFillColor( rStyleSettings.GetCheckedColor() );
+        pOutDev->DrawRect( maPage2Rect );
     }
 }
 
@@ -634,6 +906,8 @@ long ScrollBar::ImplDoAction( BOOL bCall
         case SCROLL_PAGEDOWN:
             nDelta = ImplScroll( mnThumbPos+mnPageSize, bCallEndScroll );
             break;
+        default:
+            ;
     }
 
     return nDelta;
@@ -645,11 +919,19 @@ void ScrollBar::ImplDoMouseAction( const
 {
     USHORT  nOldStateFlags = mnStateFlags;
     BOOL    bAction = FALSE;
+    BOOL    bHorizontal = ( GetStyle() & WB_HORZ )? TRUE: FALSE;
+    BOOL    bIsInside = FALSE;
+
+    Point aPoint( 0, 0 );
+    Region aControlRegion( Rectangle( aPoint, GetOutputSizePixel() ) );
 
     switch ( meScrollType )
     {
         case SCROLL_LINEUP:
-            if ( maBtn1Rect.IsInside( rMousePos ) )
+            if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_LEFT: PART_BUTTON_UP,
+                        aControlRegion, rMousePos, bIsInside )?
+                    bIsInside:
+                    maBtn1Rect.IsInside( rMousePos ) )
             {
                 bAction = bCallAction;
                 mnStateFlags |= SCRBAR_STATE_BTN1_DOWN;
@@ -659,7 +941,10 @@ void ScrollBar::ImplDoMouseAction( const
             break;
 
         case SCROLL_LINEDOWN:
-            if ( maBtn2Rect.IsInside( rMousePos ) )
+            if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_RIGHT: PART_BUTTON_DOWN,
+                        aControlRegion, rMousePos, bIsInside )?
+                    bIsInside:
+                    maBtn2Rect.IsInside( rMousePos ) )
             {
                 bAction = bCallAction;
                 mnStateFlags |= SCRBAR_STATE_BTN2_DOWN;
@@ -687,10 +972,12 @@ void ScrollBar::ImplDoMouseAction( const
             else
                 mnStateFlags &= ~SCRBAR_STATE_PAGE2_DOWN;
             break;
+        default:
+            ;
     }
 
     if ( nOldStateFlags != mnStateFlags )
-        ImplDraw( mnDragDraw );
+        ImplDraw( mnDragDraw, this );
     if ( bAction )
         ImplDoAction( FALSE );
 }
@@ -703,8 +990,16 @@ void ScrollBar::MouseButtonDown( const M
     {
         const Point&    rMousePos = rMEvt.GetPosPixel();
         USHORT          nTrackFlags = 0;
+        BOOL            bHorizontal = ( GetStyle() & WB_HORZ )? TRUE: FALSE;
+        BOOL            bIsInside = FALSE;
 
-        if ( maBtn1Rect.IsInside( rMousePos ) )
+        Point aPoint( 0, 0 );
+        Region aControlRegion( Rectangle( aPoint, GetOutputSizePixel() ) );
+
+        if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_LEFT: PART_BUTTON_UP,
+                    aControlRegion, rMousePos, bIsInside )?
+                bIsInside:
+                maBtn1Rect.IsInside( rMousePos ) )
         {
             if ( !(mnStateFlags & SCRBAR_STATE_BTN1_DISABLE) )
             {
@@ -715,7 +1010,10 @@ void ScrollBar::MouseButtonDown( const M
             else
                 Sound::Beep( SOUND_DISABLE, this );
         }
-        else if ( maBtn2Rect.IsInside( rMousePos ) )
+        else if ( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_RIGHT: PART_BUTTON_DOWN,
+                    aControlRegion, rMousePos, bIsInside )?
+                bIsInside:
+                maBtn2Rect.IsInside( rMousePos ) )
         {
             if ( !(mnStateFlags & SCRBAR_STATE_BTN2_DISABLE) )
             {
@@ -728,6 +1026,13 @@ void ScrollBar::MouseButtonDown( const M
         }
         else if ( maThumbRect.IsInside( rMousePos ) )
         {
+            if( mpData )
+            {
+                mpData->mbHide = TRUE;  // disable focus blinking
+                if( HasFocus() )
+                    ImplDraw( SCRBAR_DRAW_THUMB, this ); // paint without focus
+            }
+
             if ( mnVisibleSize < mnMaxRange-mnMinRange )
             {
                 nTrackFlags     = 0;
@@ -740,12 +1045,8 @@ void ScrollBar::MouseButtonDown( const M
                 else
                     mnMouseOff = rMousePos.Y()-maThumbRect.Top();
 
-                // Im OS2-Look geben wir den Thumb gedrueck aus
-                if ( GetSettings().GetStyleSettings().GetOptions() & STYLE_OPTION_OS2STYLE )
-                {
-                    mnStateFlags |= SCRBAR_STATE_THUMB_DOWN;
-                    ImplDraw( mnDragDraw );
-                }
+                mnStateFlags |= SCRBAR_STATE_THUMB_DOWN;
+                ImplDraw( mnDragDraw, this );
             }
             else
                 Sound::Beep( SOUND_DISABLE, this );
@@ -792,7 +1093,7 @@ void ScrollBar::Tracking( const Tracking
                           SCRBAR_STATE_PAGE1_DOWN | SCRBAR_STATE_PAGE2_DOWN |
                           SCRBAR_STATE_THUMB_DOWN);
         if ( nOldStateFlags != mnStateFlags )
-            ImplDraw( mnDragDraw );
+            ImplDraw( mnDragDraw, this );
         mnDragDraw = 0;
 
         // Bei Abbruch, die alte ThumbPosition wieder herstellen
@@ -822,6 +1123,10 @@ void ScrollBar::Tracking( const Tracking
         EndScroll();
         mnDelta = 0;
         meScrollType = SCROLL_DONTKNOW;
+
+        if( mpData )
+            mpData->mbHide = FALSE; // re-enable focus blinking
+
     }
     else
     {
@@ -912,7 +1217,7 @@ void ScrollBar::KeyInput( const KeyEvent
 
 void ScrollBar::Paint( const Rectangle& rRect )
 {
-    ImplDraw( SCRBAR_DRAW_ALL );
+    ImplDraw( SCRBAR_DRAW_ALL, this );
 }
 
 // -----------------------------------------------------------------------
@@ -928,6 +1233,60 @@ void ScrollBar::Resize()
 
 // -----------------------------------------------------------------------
 
+IMPL_LINK( ScrollBar, ImplAutoTimerHdl, AutoTimer*, EMPTYARG )
+{
+    if( mpData && mpData->mbHide )
+        return 0;
+    ImplInvert();
+    return 0;
+}
+
+void ScrollBar::ImplInvert()
+{
+    Rectangle aRect( maThumbRect );
+    if( aRect.getWidth() > 4 )
+    {
+        aRect.Left() += 2;
+        aRect.Right() -= 2;
+    }
+    if( aRect.getHeight() > 4 ) 
+    {
+        aRect.Top() += 2;
+        aRect.Bottom() -= 2;
+    }
+
+    Invert( aRect, 0 );
+}
+
+// -----------------------------------------------------------------------
+
+void ScrollBar::GetFocus()
+{
+    if( !mpData )
+    {
+	    mpData = new ImplScrollBarData;
+		mpData->maTimer.SetTimeoutHdl( LINK( this, ScrollBar, ImplAutoTimerHdl ) );
+        mpData->mbHide = FALSE;
+    }
+    ImplInvert();   // react immediately
+	mpData->maTimer.SetTimeout( GetSettings().GetStyleSettings().GetCursorBlinkTime() );
+    mpData->maTimer.Start();
+    Control::GetFocus();
+}
+
+// -----------------------------------------------------------------------
+
+void ScrollBar::LoseFocus()
+{
+    if( mpData )
+        mpData->maTimer.Stop();
+    ImplDraw( SCRBAR_DRAW_THUMB, this );
+
+    Control::LoseFocus();
+}
+
+// -----------------------------------------------------------------------
+
 void ScrollBar::StateChanged( StateChangedType nType )
 {
     Control::StateChanged( nType );
@@ -977,6 +1336,79 @@ void ScrollBar::DataChanged( const DataC
     if ( (rDCEvt.GetType() == DATACHANGED_SETTINGS) &&
          (rDCEvt.GetFlags() & SETTINGS_STYLE) )
         Invalidate();
+}
+
+// -----------------------------------------------------------------------
+
+Rectangle* ScrollBar::ImplFindPartRect( const Point& rPt )
+{
+    BOOL    bHorizontal = ( GetStyle() & WB_HORZ )? TRUE: FALSE;
+    BOOL    bIsInside = FALSE;
+
+    Point aPoint( 0, 0 );
+    Region aControlRegion( Rectangle( aPoint, GetOutputSizePixel() ) );
+
+    if( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_LEFT: PART_BUTTON_UP,
+                aControlRegion, rPt, bIsInside )?
+            bIsInside:
+            maBtn1Rect.IsInside( rPt ) )
+        return &maBtn1Rect;
+    else if( HitTestNativeControl( CTRL_SCROLLBAR, bHorizontal? PART_BUTTON_RIGHT: PART_BUTTON_DOWN,
+                aControlRegion, rPt, bIsInside )?
+            bIsInside:
+            maBtn2Rect.IsInside( rPt ) )
+        return &maBtn2Rect;
+    else if( maPage1Rect.IsInside( rPt ) )
+        return &maPage1Rect;
+    else if( maPage2Rect.IsInside( rPt ) )
+        return &maPage2Rect;
+    else if( maThumbRect.IsInside( rPt ) )
+        return &maThumbRect;
+    else
+        return NULL;
+}
+
+long ScrollBar::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_SCROLLBAR, PART_ENTIRE_CONTROL) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow() )
+                {
+                    Region aRgn( GetActiveClipRegion() );
+                    Region aClipRegion;
+
+                    if ( pRect )
+                        aClipRegion.Union( *pRect );
+                    if ( pLastRect )
+                        aClipRegion.Union( *pLastRect );
+                    
+                    // Support for 3-button scroll bars
+                    BOOL bHas3Buttons = IsNativeControlSupported( CTRL_SCROLLBAR, HAS_THREE_BUTTONS );
+                    if ( bHas3Buttons && ( pRect == &maBtn1Rect || pLastRect == &maBtn1Rect ) )
+                    {
+                        aClipRegion.Union( maBtn2Rect );
+                    }
+
+                    SetClipRegion( aClipRegion );
+                    Paint( aClipRegion.GetBoundRect() );
+
+                    SetClipRegion( aRgn );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/control/slider.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/slider.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/source/control/slider.cxx	8 May 2002 16:01:30 -0000	1.2
+++ vcl/source/control/slider.cxx	6 Jan 2004 13:24:26 -0000	1.4
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_SLIDER_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
@@ -74,7 +72,7 @@
 #include <slider.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -176,7 +174,7 @@ void Slider::ImplLoadRes( const ResId& r
 	INT16 nThumbPos		= ReadShortRes();
 	INT16 nPage			= ReadShortRes();
 	INT16 nStep			= ReadShortRes();
-	INT16 nVisibleSize	= ReadShortRes();
+	/* INT16 nVisibleSize	= */ ReadShortRes();
 
 	SetRange( Range( nMin, nMax ) );
 	SetLineSize( nStep );
@@ -188,8 +186,6 @@ void Slider::ImplLoadRes( const ResId& r
 
 void Slider::ImplInitSettings()
 {
-	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
-
 	Window* pParent = GetParent();
 	if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
 	{
Index: vcl/source/control/spinbtn.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/spinbtn.cxx,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -p -u -r1.3 -r1.6
--- vcl/source/control/spinbtn.cxx	8 May 2002 16:01:30 -0000	1.3
+++ vcl/source/control/spinbtn.cxx	10 May 2004 15:47:45 -0000	1.6
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_SPIN_CXX
-
-#ifndef _SV_RCID_H
-#include <rcid.h>
+#ifndef _TOOLS_RCID_H
+#include <tools/rcid.h>
 #endif
 #ifndef _SV_SPIN_H
 #include <spin.h>
@@ -83,15 +81,15 @@ void SpinButton::ImplInit( Window* pPare
     mbInitialUp   = FALSE;
     mbInitialDown = FALSE;
 
-    if ( nStyle & WB_REPEAT )
-    {
-        mbRepeat = TRUE;
+    mnMinRange  = 0;
+    mnMaxRange  = 100;
+    mnValue     = 0;
+    mnValueStep = 1;
 
-        maRepeatTimer.SetTimeout( SPIN_DELAY );
-        maRepeatTimer.SetTimeoutHdl( LINK( this, SpinButton, ImplTimeout ) );
-    }
-    else
-        mbRepeat = FALSE;
+    maRepeatTimer.SetTimeout( GetSettings().GetMouseSettings().GetButtonStartRepeat() );
+    maRepeatTimer.SetTimeoutHdl( LINK( this, SpinButton, ImplTimeout ) );
+
+    mbRepeat = 0 != ( nStyle & WB_REPEAT );
 
     if ( nStyle & WB_HSCROLL )
         mbHorz = TRUE;
@@ -103,16 +101,18 @@ void SpinButton::ImplInit( Window* pPare
 
 // -----------------------------------------------------------------------
 
-SpinButton::SpinButton( Window* pParent, WinBits nStyle ) :
-    Control( WINDOW_SPINBUTTON )
+SpinButton::SpinButton( Window* pParent, WinBits nStyle )
+    :Control( WINDOW_SPINBUTTON )
+    ,mbUpperIsFocused( FALSE )
 {
     ImplInit( pParent, nStyle );
 }
 
 // -----------------------------------------------------------------------
 
-SpinButton::SpinButton( Window* pParent, const ResId& rResId ) :
-    Control( WINDOW_SPINBUTTON )
+SpinButton::SpinButton( Window* pParent, const ResId& rResId )
+    :Control( WINDOW_SPINBUTTON )
+    ,mbUpperIsFocused( FALSE )
 {
     rResId.SetRT( RSC_SPINBUTTON );
     ImplInit( pParent, ImplInitRes( rResId ) );
@@ -130,9 +130,9 @@ SpinButton::~SpinButton()
 
 IMPL_LINK( SpinButton, ImplTimeout, Timer*, pTimer )
 {
-    if ( pTimer->GetTimeout() == SPIN_DELAY )
+    if ( pTimer->GetTimeout() == GetSettings().GetMouseSettings().GetButtonStartRepeat() )
     {
-        pTimer->SetTimeout( SPIN_SPEED );
+        pTimer->SetTimeout( GetSettings().GetMouseSettings().GetButtonRepeat() );
         pTimer->Start();
     }
     else
@@ -150,6 +150,14 @@ IMPL_LINK( SpinButton, ImplTimeout, Time
 
 void SpinButton::Up()
 {
+    if ( ImplIsUpperEnabled() )
+    {
+        mnValue += mnValueStep;
+        StateChanged( STATE_CHANGE_DATA );
+
+        ImplMoveFocus( TRUE );
+    }
+
     ImplCallEventListeners( VCLEVENT_SPINBUTTON_UP );
     maUpHdlLink.Call( this );
 }
@@ -158,6 +166,14 @@ void SpinButton::Up()
 
 void SpinButton::Down()
 {
+    if ( ImplIsLowerEnabled() )
+    {
+        mnValue -= mnValueStep;
+        StateChanged( STATE_CHANGE_DATA );
+
+        ImplMoveFocus( FALSE );
+    }
+
     ImplCallEventListeners( VCLEVENT_SPINBUTTON_DOWN );
     maDownHdlLink.Call( this );
 }
@@ -173,8 +189,8 @@ void SpinButton::Resize()
     Rectangle aRect( aTmpPoint, aSize );
     if ( mbHorz )
     {
-        maUpperRect = Rectangle( 0, 0, aSize.Width()/2, aSize.Height()-1 );
-        maLowerRect = Rectangle( maUpperRect.TopRight(), aRect.BottomRight() );
+        maLowerRect = Rectangle( 0, 0, aSize.Width()/2, aSize.Height()-1 );
+        maUpperRect = Rectangle( maLowerRect.TopRight(), aRect.BottomRight() );
     }
     else
     {
@@ -182,29 +198,81 @@ void SpinButton::Resize()
         maLowerRect = Rectangle( maUpperRect.BottomLeft(), aRect.BottomRight() );
     }
 
+    ImplCalcFocusRect( ImplIsUpperEnabled() || !ImplIsLowerEnabled() );
+
     Invalidate();
 }
 
 // -----------------------------------------------------------------------
 
+void SpinButton::Draw( OutputDevice* pDev, const Point& rPos, const Size& rSize, ULONG nFlags )
+{
+    Point       aPos  = pDev->LogicToPixel( rPos );
+    Size        aSize = pDev->LogicToPixel( rSize );
+ 
+    pDev->Push();
+    pDev->SetMapMode();
+    if ( !(nFlags & WINDOW_DRAW_MONO) )
+	{
+		// DecoView uses the FaceColor...
+		AllSettings aSettings = pDev->GetSettings();
+		StyleSettings aStyleSettings = aSettings.GetStyleSettings();
+		if ( IsControlBackground() )
+			aStyleSettings.SetFaceColor( GetControlBackground() );
+		else
+			aStyleSettings.SetFaceColor( GetSettings().GetStyleSettings().GetFaceColor() );
+
+		aSettings.SetStyleSettings( aStyleSettings );
+		pDev->SetSettings( aSettings );
+	}
+
+    Rectangle   aRect( Point( 0, 0 ), aSize );
+    Rectangle aLowerRect, aUpperRect;
+    if ( mbHorz )
+    {
+        aLowerRect = Rectangle( 0, 0, aSize.Width()/2, aSize.Height()-1 );
+        aUpperRect = Rectangle( aLowerRect.TopRight(), aRect.BottomRight() );
+    }
+    else
+    {
+        aUpperRect = Rectangle( 0, 0, aSize.Width()-1, aSize.Height()/2 );
+        aLowerRect = Rectangle( aUpperRect.BottomLeft(), aRect.BottomRight() );
+    }
+
+    aUpperRect += aPos;
+    aLowerRect += aPos;
+
+    ImplDrawSpinButton( pDev, aUpperRect, aLowerRect, FALSE, FALSE,
+                        IsEnabled() && ImplIsUpperEnabled(),
+                        IsEnabled() && ImplIsLowerEnabled(), mbHorz, TRUE );
+    pDev->Pop();
+}
+
+
 void SpinButton::Paint( const Rectangle& )
 {
+    HideFocus();
+
     BOOL bEnable = IsEnabled();
     ImplDrawSpinButton( this, maUpperRect, maLowerRect, mbUpperIn, mbLowerIn,
-                        bEnable, bEnable, mbHorz );
+                        bEnable && ImplIsUpperEnabled(),
+                        bEnable && ImplIsLowerEnabled(), mbHorz, TRUE );
+
+    if ( HasFocus() )
+        ShowFocus( maFocusRect );
 }
 
 // -----------------------------------------------------------------------
 
 void SpinButton::MouseButtonDown( const MouseEvent& rMEvt )
 {
-    if ( maUpperRect.IsInside( rMEvt.GetPosPixel() ) )
+    if ( maUpperRect.IsInside( rMEvt.GetPosPixel() ) && ( ImplIsUpperEnabled() ) )
     {
         mbUpperIn   = TRUE;
         mbInitialUp = TRUE;
         Invalidate( maUpperRect );
     }
-    else if ( maLowerRect.IsInside( rMEvt.GetPosPixel() ) )
+    else if ( maLowerRect.IsInside( rMEvt.GetPosPixel() ) && ( ImplIsLowerEnabled() ) )
     {
         mbLowerIn     = TRUE;
         mbInitialDown = TRUE;
@@ -246,7 +314,7 @@ void SpinButton::MouseButtonUp( const Mo
     if ( mbRepeat )
     {
         maRepeatTimer.Stop();
-        maRepeatTimer.SetTimeout( SPIN_DELAY );
+        maRepeatTimer.SetTimeout( GetSettings().GetMouseSettings().GetButtonStartRepeat() );
     }
 }
 
@@ -299,10 +367,37 @@ void SpinButton::KeyInput( const KeyEven
 {
     KeyCode aCode = rKEvt.GetKeyCode();
 
-    if ( aCode.GetCode() == KEY_UP )
-        Up();
-    else if( aCode.GetCode() == KEY_DOWN )
-        Down();
+    if ( !rKEvt.GetKeyCode().GetModifier() )
+    {
+        switch ( rKEvt.GetKeyCode().GetCode() )
+        {
+        case KEY_LEFT:
+        case KEY_RIGHT:
+        {
+            BOOL bUp = KEY_RIGHT == rKEvt.GetKeyCode().GetCode();
+            if ( mbHorz && !ImplMoveFocus( bUp ) )
+                bUp ? Up() : Down();
+        }
+        break;
+
+        case KEY_UP:
+        case KEY_DOWN:
+        {
+            BOOL bUp = KEY_UP == rKEvt.GetKeyCode().GetCode();
+            if ( !mbHorz && !ImplMoveFocus( KEY_UP == rKEvt.GetKeyCode().GetCode() ) )
+                bUp ? Up() : Down();
+        }
+        break;
+
+        case KEY_SPACE:
+            mbUpperIsFocused ? Up() : Down();
+            break;
+
+        default:
+            Control::KeyInput( rKEvt );
+            break;
+        }
+    }
     else
         Control::KeyInput( rKEvt );
 }
@@ -311,7 +406,188 @@ void SpinButton::KeyInput( const KeyEven
 
 void SpinButton::StateChanged( StateChangedType nType )
 {
-    if ( nType == STATE_CHANGE_ENABLE )
+    switch ( nType )
+    {
+    case STATE_CHANGE_DATA:
+    case STATE_CHANGE_ENABLE:
         Invalidate();
+        break;
+
+    case STATE_CHANGE_STYLE:
+    {
+        BOOL bNewRepeat = 0 != ( GetStyle() & WB_REPEAT );
+        if ( bNewRepeat != mbRepeat )
+        {
+            if ( maRepeatTimer.IsActive() )
+            {
+                maRepeatTimer.Stop();
+                maRepeatTimer.SetTimeout( GetSettings().GetMouseSettings().GetButtonStartRepeat() );
+            }
+            mbRepeat = bNewRepeat;
+        }
+
+        BOOL bNewHorz = 0 != ( GetStyle() & WB_HSCROLL );
+        if ( bNewHorz != mbHorz )
+        {
+            mbHorz = bNewHorz;
+            Resize();
+        }
+    }
+    break;
+    }
+
     Control::StateChanged( nType );
 }
+
+// -----------------------------------------------------------------------
+
+void SpinButton::SetRangeMin( long nNewRange )
+{
+    SetRange( Range( nNewRange, GetRangeMax() ) );
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::SetRangeMax( long nNewRange )
+{
+    SetRange( Range( GetRangeMin(), nNewRange ) );
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::SetRange( const Range& rRange )
+{
+    // adjust rage
+    Range aRange = rRange;
+    aRange.Justify();
+    long nNewMinRange = aRange.Min();
+    long nNewMaxRange = aRange.Max();
+
+    // do something only if old and new range differ
+    if ( (mnMinRange != nNewMinRange) ||
+         (mnMaxRange != nNewMaxRange) )
+    {
+        mnMinRange = nNewMinRange;
+        mnMaxRange = nNewMaxRange;
+
+        // adjust value to new range, if necessary
+        if ( mnValue > mnMaxRange )
+            mnValue = mnMaxRange;
+        if ( mnValue < mnMinRange )
+            mnValue = mnMinRange;
+
+        StateChanged( STATE_CHANGE_DATA );
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::SetValue( long nValue )
+{
+    // adjust, if necessary
+    if ( nValue > mnMaxRange )
+        nValue = mnMaxRange;
+    if ( nValue < mnMinRange )
+        nValue = mnMinRange;
+
+    if ( mnValue != nValue )
+    {
+        mnValue = nValue;
+        StateChanged( STATE_CHANGE_DATA );
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::GetFocus()
+{
+    ShowFocus( maFocusRect );
+    Control::GetFocus();
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::LoseFocus()
+{
+    HideFocus();
+    Control::LoseFocus();
+}
+
+// -----------------------------------------------------------------------
+
+BOOL SpinButton::ImplMoveFocus( BOOL _bUpper )
+{
+    if ( _bUpper == mbUpperIsFocused )
+        return FALSE;
+
+    HideFocus();
+    ImplCalcFocusRect( _bUpper );
+    if ( HasFocus() )
+        ShowFocus( maFocusRect );
+    return TRUE;
+}
+
+// -----------------------------------------------------------------------
+
+void SpinButton::ImplCalcFocusRect( BOOL _bUpper )
+{
+    maFocusRect = _bUpper ? maUpperRect : maLowerRect;
+    // inflate by some pixels
+    maFocusRect.Left() += 2;
+    maFocusRect.Top() += 2;
+    maFocusRect.Right() -= 2;
+    maFocusRect.Bottom() -= 2;
+    mbUpperIsFocused = _bUpper;
+}
+
+// -----------------------------------------------------------------------
+
+Rectangle* SpinButton::ImplFindPartRect( const Point& rPt )
+{
+    if( maUpperRect.IsInside( rPt ) )
+        return &maUpperRect;
+    else if( maLowerRect.IsInside( rPt ) )
+        return &maLowerRect;
+    else
+        return NULL;
+}
+
+long SpinButton::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) ||
+                IsNativeControlSupported(CTRL_SPINBOX, PART_ALL_BUTTONS) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || (pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow()) )
+                {
+                    Region aRgn( GetActiveClipRegion() );
+                    if( pLastRect )
+                    {
+                        SetClipRegion( *pLastRect );
+                        Paint( *pLastRect );
+                        SetClipRegion( aRgn );
+                    }
+                    if( pRect )
+                    {
+                        SetClipRegion( *pRect );
+                        Paint( *pRect );
+                        SetClipRegion( aRgn );
+                    }
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
Index: vcl/source/control/spinfld.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/spinfld.cxx,v
retrieving revision 1.10
retrieving revision 1.14
diff -u -p -u -r1.10 -r1.14
--- vcl/source/control/spinfld.cxx	12 Sep 2002 08:35:13 -0000	1.10
+++ vcl/source/control/spinfld.cxx	10 May 2004 15:47:58 -0000	1.14
@@ -59,10 +59,8 @@
  *
  ************************************************************************/
 
-#define _SV_SPINFLD_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
@@ -82,11 +80,116 @@
 
 // =======================================================================
 
+void ImplGetSpinbuttonValue( Window *pWin, const Rectangle& rUpperRect,
+                            const Rectangle& rLowerRect,
+                            BOOL bUpperIn, BOOL bLowerIn,
+                            BOOL bUpperEnabled, BOOL bLowerEnabled, BOOL bHorz,
+                            SpinbuttonValue& rValue )
+{
+    // convert spinbutton data to a SpinbuttonValue structure for native painting
+
+    rValue.maUpperRect = rUpperRect;
+    rValue.maLowerRect = rLowerRect;
+
+    // convert rectangles to screen coordinates
+    Point aPt = pWin->OutputToScreenPixel( rValue.maUpperRect.TopLeft() );
+    rValue.maUpperRect.SetPos( aPt );
+    aPt = pWin->OutputToScreenPixel( rValue.maLowerRect.TopLeft() );
+    rValue.maLowerRect.SetPos( aPt );
+
+    ControlState nState = CTRL_STATE_ENABLED;
+    if ( bUpperIn )
+        nState |= CTRL_STATE_PRESSED;
+    if ( !pWin->IsEnabled() || !bUpperEnabled )
+        nState &= ~CTRL_STATE_ENABLED;
+    if ( pWin->HasFocus() )
+        nState |= CTRL_STATE_FOCUSED;
+    if( pWin->IsMouseOver() && rUpperRect.IsInside( pWin->GetPointerPosPixel() ) )
+        nState |= CTRL_STATE_ROLLOVER;
+    rValue.mnUpperState = nState;
+
+    nState = CTRL_STATE_ENABLED;
+    if ( bLowerIn )
+        nState |= CTRL_STATE_PRESSED;
+    if ( !pWin->IsEnabled() || !bLowerEnabled )
+        nState &= ~CTRL_STATE_ENABLED;
+    if ( pWin->HasFocus() )
+        nState |= CTRL_STATE_FOCUSED;
+    // for overlapping spins: highlight only one
+    if( pWin->IsMouseOver() && rLowerRect.IsInside( pWin->GetPointerPosPixel() ) &&
+                              !rUpperRect.IsInside( pWin->GetPointerPosPixel() ) )
+        nState |= CTRL_STATE_ROLLOVER;
+    rValue.mnLowerState = nState;
+
+    rValue.mnUpperPart = bHorz ? PART_BUTTON_LEFT : PART_BUTTON_UP;
+    rValue.mnLowerPart = bHorz ? PART_BUTTON_RIGHT : PART_BUTTON_DOWN;
+}
+
+
+BOOL ImplDrawNativeSpinfield( Window *pWin, const SpinbuttonValue& rSpinbuttonValue )
+{
+    BOOL bNativeOK = FALSE;
+
+    if( pWin->IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) )
+    {
+        ImplControlValue aControlValue;
+        aControlValue.setOptionalVal( (void*) &rSpinbuttonValue );
+
+        if( pWin->IsNativeControlSupported(CTRL_SPINBOX, rSpinbuttonValue.mnUpperPart) && 
+            pWin->IsNativeControlSupported(CTRL_SPINBOX, rSpinbuttonValue.mnLowerPart) )
+        {
+            // only paint the embedded spin buttons, all buttons are painted at once
+            bNativeOK = pWin->DrawNativeControl( CTRL_SPINBOX, PART_ALL_BUTTONS, Region(), CTRL_STATE_ENABLED,
+                        aControlValue, rtl::OUString() );
+        }
+        else
+        {
+            // paint the spinbox as a whole, use borderwindow to have proper clipping
+            Window *pBorder = pWin->GetWindow( WINDOW_BORDER );
+
+            // to not overwrite everything, set the button region as clipregion to the border window
+            Rectangle aClipRect( rSpinbuttonValue.maLowerRect );
+            aClipRect.Union( rSpinbuttonValue.maUpperRect );
+
+            // convert from screen space to borderwin space
+            aClipRect.SetPos( pBorder->ScreenToOutputPixel(aClipRect.TopLeft()) );
+
+            Region oldRgn( pBorder->GetClipRegion() );
+            pBorder->SetClipRegion( Region( aClipRect ) );
+
+            Point aPt;
+            Size aSize( pBorder->GetOutputSizePixel() );    // the size of the border window, i.e., the whole control
+            Region aRgn( Rectangle( aPt, aSize ) );
+            bNativeOK = pBorder->DrawNativeControl( CTRL_SPINBOX, PART_ENTIRE_CONTROL, aRgn, CTRL_STATE_ENABLED,
+                        aControlValue, rtl::OUString() );
+
+            pBorder->SetClipRegion( oldRgn );
+        }
+    }
+    return bNativeOK;
+}
+
+BOOL ImplDrawNativeSpinbuttons( Window *pWin, const SpinbuttonValue& rSpinbuttonValue )
+{
+    BOOL bNativeOK = FALSE;
+
+    if( pWin->IsNativeControlSupported(CTRL_SPINBUTTONS, PART_ENTIRE_CONTROL) )
+    {
+        ImplControlValue aControlValue;
+        aControlValue.setOptionalVal( (void*) &rSpinbuttonValue );
+
+        // only paint the standalone spin buttons, all buttons are painted at once
+        bNativeOK = pWin->DrawNativeControl( CTRL_SPINBUTTONS, PART_ALL_BUTTONS, Region(), CTRL_STATE_ENABLED,
+                    aControlValue, rtl::OUString() );
+    }
+    return bNativeOK;
+}
+
 void ImplDrawSpinButton( OutputDevice* pOutDev,
 						 const Rectangle& rUpperRect,
 						 const Rectangle& rLowerRect,
 						 BOOL bUpperIn, BOOL bLowerIn,
-						 BOOL bUpperEnabled, BOOL bLowerEnabled, BOOL bHorz )
+						 BOOL bUpperEnabled, BOOL bLowerEnabled, BOOL bHorz, BOOL bMirrorHorz )
 {
 	DecorationView aDecoView( pOutDev );
 
@@ -98,10 +201,11 @@ void ImplDrawSpinButton( OutputDevice* p
 	const StyleSettings& rStyleSettings = pOutDev->GetSettings().GetStyleSettings();
 	if ( rStyleSettings.GetOptions() & STYLE_OPTION_SPINARROW )
 	{
+        // arrows are only use in OS/2 look
 		if ( bHorz )
 		{
-			eType1 = SYMBOL_ARROW_LEFT;
-			eType2 = SYMBOL_ARROW_RIGHT;
+            eType1 = bMirrorHorz ? SYMBOL_ARROW_RIGHT : SYMBOL_ARROW_LEFT;
+            eType2 = bMirrorHorz ? SYMBOL_ARROW_LEFT : SYMBOL_ARROW_RIGHT;
 		}
 		else
 		{
@@ -113,8 +217,8 @@ void ImplDrawSpinButton( OutputDevice* p
 	{
 		if ( bHorz )
 		{
-			eType1 = SYMBOL_SPIN_LEFT;
-			eType2 = SYMBOL_SPIN_RIGHT;
+            eType1 = bMirrorHorz ? SYMBOL_SPIN_RIGHT : SYMBOL_SPIN_LEFT;
+            eType2 = bMirrorHorz ? SYMBOL_SPIN_LEFT : SYMBOL_SPIN_RIGHT;
 		}
 		else
 		{
@@ -127,12 +231,55 @@ void ImplDrawSpinButton( OutputDevice* p
 	USHORT nTempStyle = nStyle;
 	if ( bUpperIn )
 		nTempStyle |= BUTTON_DRAW_PRESSED;
-	Rectangle aUpRect = aDecoView.DrawButton( rUpperRect, nTempStyle );
+
+    BOOL bNativeOK = FALSE;
+	Rectangle aUpRect;
+
+    if( pOutDev->GetOutDevType() == OUTDEV_WINDOW )
+    {
+        Window *pWin = (Window*) pOutDev;
+
+        // are we drawing standalone spin buttons or members of a spinfield ?
+        ControlType aControl = CTRL_SPINBUTTONS;
+        switch( pWin->GetType() )
+        {
+            case WINDOW_EDIT:
+            case WINDOW_MULTILINEEDIT:
+            case WINDOW_PATTERNFIELD:
+            case WINDOW_METRICFIELD:
+            case WINDOW_CURRENCYFIELD:
+            case WINDOW_DATEFIELD:
+            case WINDOW_TIMEFIELD:
+            case WINDOW_LONGCURRENCYFIELD:
+            case WINDOW_NUMERICFIELD:
+            case WINDOW_SPINFIELD:
+                aControl = CTRL_SPINBOX;
+                break;
+            default:
+                aControl = CTRL_SPINBUTTONS;
+                break;
+        }
+
+        SpinbuttonValue aValue;
+        ImplGetSpinbuttonValue( pWin, rUpperRect, rLowerRect,
+						        bUpperIn, bLowerIn, bUpperEnabled, bLowerEnabled,
+                                bHorz, aValue );
+
+        if( aControl == CTRL_SPINBOX )
+            bNativeOK = ImplDrawNativeSpinfield( pWin, aValue );
+        else if( aControl == CTRL_SPINBUTTONS )
+            bNativeOK = ImplDrawNativeSpinbuttons( pWin, aValue );
+    }
+
+    if( !bNativeOK )
+        aUpRect = aDecoView.DrawButton( rUpperRect, nTempStyle );
 
 	// Unteren/rechten Button malen
 	if ( bLowerIn )
 		nStyle |= BUTTON_DRAW_PRESSED;
-	Rectangle aLowRect = aDecoView.DrawButton( rLowerRect, nStyle );
+	Rectangle aLowRect;
+    if( !bNativeOK )
+	    aLowRect = aDecoView.DrawButton( rLowerRect, nStyle );
 
 	// Zusaetzliche Default-Kante wollen wir auch ausnutzen
 	aUpRect.Left()--;
@@ -177,11 +324,13 @@ void ImplDrawSpinButton( OutputDevice* p
 	nTempStyle = nSymStyle;
 	if ( !bUpperEnabled )
 		nTempStyle |= SYMBOL_DRAW_DISABLE;
-	aDecoView.DrawSymbol( aUpRect, eType1, rStyleSettings.GetButtonTextColor(), nTempStyle );
+    if( !bNativeOK )
+	    aDecoView.DrawSymbol( aUpRect, eType1, rStyleSettings.GetButtonTextColor(), nTempStyle );
 
 	if ( !bLowerEnabled )
 		nSymStyle |= SYMBOL_DRAW_DISABLE;
-	aDecoView.DrawSymbol( aLowRect, eType2, rStyleSettings.GetButtonTextColor(), nSymStyle );
+    if( !bNativeOK )
+        aDecoView.DrawSymbol( aLowRect, eType2, rStyleSettings.GetButtonTextColor(), nSymStyle );
 }
 
 // =======================================================================
@@ -209,14 +358,27 @@ void SpinField::ImplInit( Window* pParen
 	if ( nWinStyle & (WB_SPIN|WB_DROPDOWN) )
 	{
 		mbSpin = TRUE;
-		mpEdit = new Edit( this, WB_NOBORDER );
-        mpEdit->EnableRTL( FALSE );
+		
+		// Some themes want external spin buttons, therefore the main
+		// spinfield should not overdraw the border between its encapsulated
+		// edit field and the spin buttons
+		if ( (nWinStyle & WB_SPIN) &&
+		    IsNativeControlSupported(CTRL_SPINBOX, HAS_BACKGROUND_TEXTURE) ) 
+		{
+			SetBackground();
+			mpEdit = new Edit( this, WB_NOBORDER );
+			mpEdit->SetBackground();
+		}
+		else
+			mpEdit = new Edit( this, WB_NOBORDER );
+
+		mpEdit->EnableRTL( FALSE );
 		mpEdit->SetPosPixel( Point() );
 		mpEdit->Show();
 		SetSubEdit( mpEdit );
 
 		maRepeatTimer.SetTimeoutHdl( LINK( this, SpinField, ImplTimeout ) );
-		maRepeatTimer.SetTimeout( SPIN_DELAY );
+		maRepeatTimer.SetTimeout( GetSettings().GetMouseSettings().GetButtonStartRepeat() );
 		if ( nWinStyle & WB_REPEAT )
 			mbRepeat = TRUE;
 
@@ -346,7 +508,7 @@ void SpinField::MouseButtonUp( const Mou
 	ReleaseMouse();
 	mbInitialUp = mbInitialDown = FALSE;
 	maRepeatTimer.Stop();
-	maRepeatTimer.SetTimeout( SPIN_DELAY );
+	maRepeatTimer.SetTimeout( GetSettings().GetMouseSettings().GetButtonStartRepeat() );
 
 	if ( mbUpperIn )
 	{
@@ -518,9 +680,9 @@ void SpinField::Paint( const Rectangle& 
 {
 	if ( mbSpin )
 	{
-		BOOL bEnable = IsEnabled();
-		ImplDrawSpinButton( this, maUpperRect, maLowerRect,
-							mbUpperIn, mbLowerIn, bEnable, bEnable );
+		BOOL	bEnable = IsEnabled();
+        ImplDrawSpinButton( this, maUpperRect, maLowerRect,
+		                    mbUpperIn, mbLowerIn, bEnable, bEnable );
 	}
 
 	if ( GetStyle() & WB_DROPDOWN )
@@ -547,11 +709,13 @@ void SpinField::Paint( const Rectangle& 
 
 void SpinField::ImplCalcButtonAreas( OutputDevice* pDev, const Size& rOutSz, Rectangle& rDDArea, Rectangle& rSpinUpArea, Rectangle& rSpinDownArea )
 {
-	const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
+	const StyleSettings& rStyleSettings = pDev->GetSettings().GetStyleSettings();
 
 	Size aSize = rOutSz;
 	Size aDropDownSize;
 
+    DBG_ASSERT( !(GetStyle() & WB_DROPDOWN), "SpinField::ImplCalcButtonAreas(): SpinField with drop down not supported on all (native) platforms !" );
+
 	if ( GetStyle() & WB_DROPDOWN )
 	{
 		long nW = rStyleSettings.GetScrollBarSize();
@@ -568,13 +732,56 @@ void SpinField::ImplCalcButtonAreas( Out
 	if ( GetStyle() & WB_SPIN )
 	{
 		long nBottom1 = aSize.Height()/2;
+		long nBottom2 = aSize.Height()-1;
 		long nTop2 = nBottom1;
+		long nTop1 = 0;
 		if ( !(aSize.Height() & 0x01) )
 			nBottom1--;
 
-		aSize.Width() -= CalcZoom( GetDrawPixel( pDev, rStyleSettings.GetSpinSize() ) );
-		rSpinUpArea = Rectangle( aSize.Width(), 0, rOutSz.Width()-aDropDownSize.Width()-1, nBottom1 );
-		rSpinDownArea = Rectangle( rSpinUpArea.Left(), nTop2, rSpinUpArea.Right(), aSize.Height()-1 );
+        BOOL bNativeRegionOK = FALSE;
+        Region aContentUp, aContentDown;
+
+		if ( (pDev->GetOutDevType() == OUTDEV_WINDOW) && 
+            IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) )
+        {
+            Window *pWin = (Window*) pDev;
+            Window *pBorder = pWin->GetWindow( WINDOW_BORDER );
+
+            // get the system's spin button size
+		    ImplControlValue aControlValue;
+		    Region aBound;
+		    Point aPoint;
+
+            // use the full extent of the control
+		    Region aArea( Rectangle( aPoint, pBorder->GetOutputSizePixel() ) );
+
+		    bNativeRegionOK = 
+                pWin->GetNativeControlRegion(CTRL_SPINBOX, PART_BUTTON_UP,
+                    aArea, 0, aControlValue, rtl::OUString(), aBound, aContentUp) &&
+                pWin->GetNativeControlRegion(CTRL_SPINBOX, PART_BUTTON_DOWN,
+                    aArea, 0, aControlValue, rtl::OUString(), aBound, aContentDown);
+
+            if( bNativeRegionOK )
+            {
+                // convert back from border space to local coordinates
+                aPoint = pBorder->ScreenToOutputPixel( pWin->OutputToScreenPixel( aPoint ) );
+                aContentUp.Move(-aPoint.X(), -aPoint.Y());
+                aContentDown.Move(-aPoint.X(), -aPoint.Y());
+            }
+        }
+
+        if( bNativeRegionOK )
+        {
+		    rSpinUpArea = aContentUp.GetBoundRect();
+		    rSpinDownArea = aContentDown.GetBoundRect();
+        }
+        else
+        {
+		    aSize.Width() -= CalcZoom( GetDrawPixel( pDev, rStyleSettings.GetSpinSize() ) );
+
+		    rSpinUpArea = Rectangle( aSize.Width(), nTop1, rOutSz.Width()-aDropDownSize.Width()-1, nBottom1 );
+		    rSpinDownArea = Rectangle( rSpinUpArea.Left(), nTop2, rSpinUpArea.Right(), nBottom2 );
+        }
 	}
 	else
 	{
@@ -589,14 +796,13 @@ void SpinField::Resize()
 {
 	if ( mbSpin )
 	{
-        Control::Resize();
+		Control::Resize();
 		Size aSize = GetOutputSizePixel();
 
 		if ( GetStyle() & (WB_SPIN|WB_DROPDOWN) )
 		{
 			ImplCalcButtonAreas( this, aSize, maDropDownRect, maUpperRect, maLowerRect );
-			aSize.Width() -= maDropDownRect.GetWidth();
-			aSize.Width() -= maUpperRect.GetWidth();
+			aSize.Width() = maUpperRect.Left();
 		}
 
 		mpEdit->SetSizePixel( aSize );
@@ -682,6 +888,56 @@ void SpinField::DataChanged( const DataC
 
 // -----------------------------------------------------------------------
 
+Rectangle* SpinField::ImplFindPartRect( const Point& rPt )
+{
+    if( maUpperRect.IsInside( rPt ) )
+        return &maUpperRect;
+    else if( maLowerRect.IsInside( rPt ) )
+        return &maLowerRect;
+    else
+        return NULL;
+}
+
+long SpinField::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_SPINBOX, PART_ENTIRE_CONTROL) ||
+                IsNativeControlSupported(CTRL_SPINBOX, PART_ALL_BUTTONS) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || (pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow()) )
+                {
+                    Region aRgn( GetActiveClipRegion() );
+                    if( pLastRect )
+                    {
+                        SetClipRegion( *pLastRect );
+                        Paint( *pLastRect );
+                        SetClipRegion( aRgn );
+                    }
+                    if( pRect )
+                    {
+                        SetClipRegion( *pRect );
+                        Paint( *pRect );
+                        SetClipRegion( aRgn );
+                    }
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Edit::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 void SpinField::EndDropDown()
 {
 	mbInDropDown = FALSE;
@@ -736,9 +992,9 @@ USHORT SpinField::GetMaxVisChars() const
 
 IMPL_LINK( SpinField, ImplTimeout, Timer*, pTimer )
 {
-	if ( pTimer->GetTimeout() == SPIN_DELAY )
+	if ( pTimer->GetTimeout() == GetSettings().GetMouseSettings().GetButtonStartRepeat() )
 	{
-		pTimer->SetTimeout( SPIN_SPEED );
+		pTimer->SetTimeout( GetSettings().GetMouseSettings().GetButtonRepeat() );
 		pTimer->Start();
 	}
 	else
@@ -755,7 +1011,7 @@ IMPL_LINK( SpinField, ImplTimeout, Timer
 
 void SpinField::Draw( OutputDevice* pDev, const Point& rPos, const Size& rSize, ULONG nFlags )
 {
-    Edit::Draw( pDev, rPos, rSize, nFlags );
+	Edit::Draw( pDev, rPos, rSize, nFlags );
 
 	WinBits nStyle = GetStyle();
 	if ( !(nFlags & WINDOW_DRAW_NOCONTROLS ) && ( nStyle & (WB_SPIN|WB_DROPDOWN) ) )
Index: vcl/source/control/tabctrl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/control/tabctrl.cxx,v
retrieving revision 1.17
retrieving revision 1.21
diff -u -p -u -r1.17 -r1.21
--- vcl/source/control/tabctrl.cxx	12 Jun 2003 07:51:17 -0000	1.17
+++ vcl/source/control/tabctrl.cxx	10 May 2004 15:48:11 -0000	1.21
@@ -59,14 +59,12 @@
  *
  ************************************************************************/
 
-#define _SV_TABCTRL_CXX
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -102,8 +97,6 @@
 #include <hash_map>
 #include <vector>
 
-#pragma hdrstop
-
 // =======================================================================
 
 struct ImplTabCtrlData
@@ -176,6 +169,9 @@ void TabControl::ImplInit( Window* pPare
     if ( !(nStyle & WB_NODIALOGCONTROL) )
         nStyle |= WB_DIALOGCONTROL;
 
+    // no single line tabs since NWF
+    nStyle &= ~WB_SINGLELINE;
+
     Control::ImplInit( pParent, nStyle, NULL );
 
     mpItemList          		= new ImplTabItemList( 8, 8 );
@@ -199,11 +195,13 @@ void TabControl::ImplInit( Window* pPare
     mpTabCtrlData->mpLeftBtn    = NULL;
     mpTabCtrlData->mpRightBtn   = NULL;
 
-    if ( (GetSettings().GetStyleSettings().GetTabControlStyle() & STYLE_TABCONTROL_SINGLELINE) ||
-         (nStyle & WB_SINGLELINE) )
-        mbSingleLine = TRUE;
 
     ImplInitSettings( TRUE, TRUE, TRUE );
+
+    // if the tabcontrol is drawn (ie filled) by a native widget, make sure all contols will have transparent background
+    // otherwise they will paint with a wrong background
+    if( IsNativeControlSupported(CTRL_TAB_PANE, PART_ENTIRE_CONTROL) )
+        EnableChildTransparentMode( TRUE );
 }
 
 // -----------------------------------------------------------------------
@@ -235,8 +233,13 @@ void TabControl::ImplInitSettings( BOOL 
     if ( bBackground )
     {
         Window* pParent = GetParent();
-        if ( pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+        if ( (pParent->IsChildTransparentModeEnabled() && !IsControlBackground() )
+            || IsNativeControlSupported(CTRL_TAB_PANE, PART_ENTIRE_CONTROL) 
+            || IsNativeControlSupported(CTRL_TAB_ITEM, PART_ENTIRE_CONTROL) )
+
         {
+            // set transparent mode for NWF tabcontrols to have
+            // the background always cleared properly
             EnableChildTransparentMode( TRUE );
             SetParentClipMode( PARENTCLIPMODE_NOCLIP );
             SetPaintTransparent( TRUE );
@@ -255,8 +258,6 @@ void TabControl::ImplInitSettings( BOOL 
         }
     }
 
-    // Sollen TabReiter farbig dargestellt werden
-    mbColored =  (rStyleSettings.GetTabControlStyle() & STYLE_TABCONTROL_COLOR) != 0;
     ImplScrollBtnsColor();
 }
 
@@ -365,17 +366,8 @@ void TabControl::ImplScrollBtnsColor()
 {
     if ( mpTabCtrlData && mpTabCtrlData->mpLeftBtn )
     {
-        if ( mbColored )
-        {
-            Color aScrollBtnColor( COL_LIGHTBLUE );
-            mpTabCtrlData->mpLeftBtn->SetControlForeground( aScrollBtnColor );
-            mpTabCtrlData->mpRightBtn->SetControlForeground( aScrollBtnColor );
-        }
-        else
-        {
-            mpTabCtrlData->mpLeftBtn->SetControlForeground();
-            mpTabCtrlData->mpRightBtn->SetControlForeground();
-        }
+        mpTabCtrlData->mpLeftBtn->SetControlForeground();
+        mpTabCtrlData->mpRightBtn->SetControlForeground();
     }
 }
 
@@ -493,15 +485,11 @@ Rectangle TabControl::ImplGetTabRect( US
     if ( nPos == TAB_PAGERECT )
     {
         USHORT nLastPos;
-        if ( mbSingleLine )
-            nLastPos = mnFirstPagePos;
+        if ( mnCurPageId )
+            nLastPos = GetPagePos( mnCurPageId );
         else
-        {
-            if ( mnCurPageId )
-                nLastPos = GetPagePos( mnCurPageId );
-            else
-                nLastPos = 0;
-        }
+            nLastPos = 0;
+
         Rectangle aRect = ImplGetTabRect( nLastPos, nWidth, nHeight );
         aRect = Rectangle( Point( TAB_OFFSET, aRect.Bottom()+TAB_OFFSET ),
                            Size( nWidth-TAB_OFFSET*2,
@@ -545,86 +533,7 @@ Rectangle TabControl::ImplGetTabRect( US
             nMaxWidth = mnMaxPageWidth;
 
         mbScroll = FALSE;
-        if ( mbSingleLine )
-        {
-            // Zuerst ermitteln wir, ob wir scrollen muessen
-            pItem = mpItemList->First();
-            while ( pItem )
-            {
-                aSize = ImplGetItemSize( pItem, nMaxWidth );
-                pItem->maRect = Rectangle( Point( nX, nY ), aSize );
-                pItem->mnLine = 1;
-                pItem->mbFullVisible = TRUE;
-                nX += aSize.Width();
-
-                if ( (nX > nWidth-2) && (nWidth > 4) )
-                    mbScroll = TRUE;
-
-                pItem = mpItemList->Next();
-            }
-
-            // Wenn wir Scrollen muessen, dann muessen die Reiter
-            // entsprechend angeordnet werden
-            if ( mbScroll )
-            {
-                // Zuerst ermitteln wir den letzten TabReiter, bei dem
-                // die restlichen noch sichtbar bleiben und passen
-                // gegebenenfalls den ersten sichtbaren Writer an
-                mnBtnSize = GetTextHeight()+(TAB_TABOFFSET_Y*2);
-                long    nMaxWidth = nWidth-(mnBtnSize*2);
-                long    nTempWidth = 0;
-                USHORT  nPageCount = GetPageCount();
-                mnLastFirstPagePos = nPageCount;
-                pItem = mpItemList->Last();
-                while ( pItem )
-                {
-                    nTempWidth += pItem->maRect.GetSize().Width();
-                    if ( nTempWidth > nMaxWidth )
-                        break;
-
-                    mnLastFirstPagePos--;
-                    pItem = mpItemList->Prev();
-                }
-                if ( mnLastFirstPagePos > nPageCount-1 )
-                    mnLastFirstPagePos = nPageCount-1;
-                if ( mnFirstPagePos > mnLastFirstPagePos )
-                   mnFirstPagePos = mnLastFirstPagePos;
-
-                // Jetzt die TabReiter anordnen und die Reiter ausblenden,
-                // die nicht zu sehen sind
-                nPos = 0;
-                nX = 2;
-                pItem = mpItemList->First();
-                while ( pItem )
-                {
-                    if ( (nPos < mnFirstPagePos) ||
-                         ((nX > nWidth-2) && (nWidth > 4)) )
-                    {
-                        pItem->mbFullVisible = FALSE;
-                        pItem->maRect.SetEmpty();
-                        mbSmallInvalidate = FALSE;
-                    }
-                    else
-                    {
-                        aSize = pItem->maRect.GetSize();
-                        Rectangle aNewRect( Point( nX, nY ), aSize );
-                        if ( mbSmallInvalidate && (pItem->maRect != aNewRect) )
-                            mbSmallInvalidate = FALSE;
-                        pItem->maRect = aNewRect;
-                        nX += aSize.Width();
-                    }
-
-                    if ( nX > nMaxWidth )
-                        pItem->mbFullVisible = FALSE;
-
-                    pItem = mpItemList->Next();
-                    nPos++;
-                }
-            }
-            else
-                mnFirstPagePos = 0;
-        }
-        else
+        if( 1 )
         {
             USHORT          nLines = 0;
             USHORT          nCurLine = 0;
@@ -815,6 +724,17 @@ void TabControl::ImplChangeTabPage( USHO
     if ( pOldPage )
         pOldPage->Hide();
 
+    // Invalidate the same region that will be send to NWF
+    // to always allow for bitmap caching
+    // see Window::DrawNativeControl()
+    if( IsNativeControlSupported( CTRL_TAB_PANE, PART_ENTIRE_CONTROL ) )
+    {
+        aRect.Left()   -= TAB_OFFSET;
+        aRect.Top()    -= TAB_OFFSET;
+        aRect.Right()  += TAB_OFFSET;
+        aRect.Bottom() += TAB_OFFSET;
+    }
+    
     Invalidate( aRect );
 }
 
@@ -865,32 +782,7 @@ void TabControl::ImplActivateTabPage( BO
 
 void TabControl::ImplSetFirstPagePos( USHORT nPagePos )
 {
-    if ( !mbSingleLine )
-        return;
-
-    ImplFreeLayoutData();
-
-    if ( mbFormat )
-        mnFirstPagePos = nPagePos;
-    else
-    {
-        if ( nPagePos > mnLastFirstPagePos )
-            nPagePos = mnLastFirstPagePos;
-
-        if ( nPagePos != mnFirstPagePos )
-        {
-            // Neu auszugebene Rechteck berechnen
-            Rectangle aRect = ImplGetTabRect( TAB_PAGERECT );
-            aRect.Bottom()  = aRect.Top();
-            aRect.Left()    = 0;
-            aRect.Top()     = 0;
-            aRect.Right()   = Control::GetOutputSizePixel().Width();
-
-            mbFormat = TRUE;
-            mnFirstPagePos = nPagePos;
-            Invalidate( aRect, INVALIDATE_NOCHILDREN );
-        }
-    }
+    return; // was only required for single line
 }
 
 // -----------------------------------------------------------------------
@@ -922,7 +814,7 @@ void TabControl::ImplShowFocus()
 
 // -----------------------------------------------------------------------
 
-void TabControl::ImplDrawItem( ImplTabItem* pItem, const Rectangle& rCurRect, bool bLayout )
+void TabControl::ImplDrawItem( ImplTabItem* pItem, const Rectangle& rCurRect, bool bLayout, bool bFirstInGroup, bool bLastInGroup, bool bIsCurrentItem )
 {
     if ( pItem->maRect.IsEmpty() )
         return;
@@ -945,6 +837,7 @@ void TabControl::ImplDrawItem( ImplTabIt
     BOOL                    bLeftBorder = TRUE;
     BOOL                    bRightBorder = TRUE;
     USHORT                  nOff;
+    BOOL                    bNativeOK = FALSE;
 
     USHORT nOff2 = 0;
     USHORT nOff3 = 0;
@@ -982,36 +875,59 @@ void TabControl::ImplDrawItem( ImplTabIt
         }
     }
 
-    if( ! bLayout )
+    if( !bLayout && (bNativeOK = IsNativeControlSupported(CTRL_TAB_ITEM, PART_ENTIRE_CONTROL)) == TRUE )
+    {
+        ImplControlValue		aControlValue;
+        Region				aCtrlRegion( pItem->maRect );
+        ControlState		nState = 0;
+
+        if( pItem->mnId == mnCurPageId )
+            nState |= CTRL_STATE_SELECTED;
+        if ( HasFocus() )
+            nState |= CTRL_STATE_FOCUSED;
+        if ( IsEnabled() )
+            nState |= CTRL_STATE_ENABLED;
+        if( IsMouseOver() && pItem->maRect.IsInside( GetPointerPosPixel() ) )
+        {
+            nState |= CTRL_STATE_ROLLOVER;
+            ImplTabItem* pI;
+            int idx=0;
+            while( (pI = mpItemList->GetObject(idx++)) )
+                if( (pI != pItem) && (pI->maRect.IsInside( GetPointerPosPixel() ) ) )
+                {
+                    nState &= ~CTRL_STATE_ROLLOVER; // avoid multiple highlighted tabs
+                    break;
+                }
+        }
+
+        TabitemValue tiValue;
+        if(pItem->maRect.Left() < 5)
+            tiValue.mnAlignment |= TABITEM_LEFTALIGNED;
+        if(pItem->maRect.Right() > mnLastWidth - 5)
+            tiValue.mnAlignment |= TABITEM_RIGHTALIGNED;
+        if ( bFirstInGroup )
+            tiValue.mnAlignment |= TABITEM_FIRST_IN_GROUP;
+        if ( bLastInGroup )
+            tiValue.mnAlignment |= TABITEM_LAST_IN_GROUP;
+        aControlValue.setOptionalVal( (void *)(&tiValue) );
+
+        bNativeOK = DrawNativeControl( CTRL_TAB_ITEM, PART_ENTIRE_CONTROL, aCtrlRegion, nState,
+                    aControlValue, rtl::OUString() );
+    }
+
+    if( ! bLayout && !bNativeOK )
     {
         if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
         {
-            if ( mbColored )
-            {
-                USHORT  nPos = (USHORT)mpItemList->GetPos( pItem );
-                Color   aOldFillColor = GetFillColor();
-                SetLineColor();
-                SetFillColor( aImplTabColorAry[nPos%TABCOLORCOUNT] );
-                Rectangle aColorRect;
-                aColorRect.Left()   = aRect.Left()-nOff2+1;
-                aColorRect.Top()    = aRect.Top()-nOff2+1;
-                aColorRect.Right()  = aRect.Right()+nOff2-3;
-                aColorRect.Bottom() = nLeftBottom;
-                if ( pItem->mnId != mnCurPageId )
-                    aColorRect.Bottom()--;
-                DrawRect( aColorRect );
-                SetFillColor( aOldFillColor );
-            }
-            
             SetLineColor( rStyleSettings.GetLightColor() );
-            DrawPixel( Point( aRect.Left()+1-nOff2, aRect.Top()+1-nOff2 ) );
+            DrawPixel( Point( aRect.Left()+1-nOff2, aRect.Top()+1-nOff2 ) );    // diagonally indented top-left pixel
             if ( bLeftBorder )
             {
                 DrawLine( Point( aRect.Left()-nOff2, aRect.Top()+2-nOff2 ),
                           Point( aRect.Left()-nOff2, nLeftBottom-1 ) );
             }
-            DrawLine( Point( aRect.Left()+2-nOff2, aRect.Top()-nOff2 ),
-                      Point( aRect.Right()+nOff2-3, aRect.Top()-nOff2 ) );
+            DrawLine( Point( aRect.Left()+2-nOff2, aRect.Top()-nOff2 ),         // top line starting 2px from left border
+                      Point( aRect.Right()+nOff2-3, aRect.Top()-nOff2 ) );      // ending 3px from right border
             
             if ( bRightBorder )
             {
@@ -1053,6 +969,13 @@ void TabControl::ImplDrawItem( ImplTabIt
         mpTabCtrlData->maTabRectangles.push_back( aRect );
     }
 
+    // set font accordingly, current item is painted bold
+    // we set the font attributes always before drawing to be re-entrant (DrawNativeControl may trigger additional paints)
+    Font aFont( GetFont() );
+    aFont.SetTransparent( TRUE );
+    aFont.SetWeight( bIsCurrentItem ? WEIGHT_BOLD : WEIGHT_LIGHT );
+    SetFont( aFont );
+
     Size aTabSize = aRect.GetSize();
     long nTextHeight = GetTextHeight();
     long nTextWidth = GetCtrlTextWidth( pItem->maFormatText );
@@ -1069,10 +992,6 @@ void TabControl::ImplDrawItem( ImplTabIt
 
 IMPL_LINK( TabControl, ImplScrollBtnHdl, PushButton*, pBtn )
 {
-    if ( pBtn == mpTabCtrlData->mpRightBtn )
-        ImplSetFirstPagePos( mnFirstPagePos+1 );
-    else
-        ImplSetFirstPagePos( mnFirstPagePos-1 );
     ImplSetScrollBtnsState();
     return 0;
 }
@@ -1121,15 +1040,7 @@ void TabControl::ImplPaint( const Rectan
     // Hier wird gegebenenfalls auch neu formatiert
     Rectangle aRect = ImplGetTabRect( TAB_PAGERECT );
 
-    // Fonts entsprechend setzen
-    Font aFont( GetFont() );
-    Font aLightFont = aFont;
-    aFont.SetTransparent( TRUE );
-    aFont.SetWeight( WEIGHT_BOLD );
-    aLightFont.SetTransparent( TRUE );
-    aLightFont.SetWeight( WEIGHT_LIGHT );
-
-    // Aktuelles Item ermitteln
+    // find current item
     ImplTabItem* pPrevCurItem = NULL;
     ImplTabItem* pCurItem = NULL;
     ImplTabItem* pItem = mpItemList->First();
@@ -1145,7 +1056,7 @@ void TabControl::ImplPaint( const Rectan
         pItem = mpItemList->Next();
     }
 
-    // Border um TabPage zeichnen
+    // Draw the TabPage border
     const StyleSettings&    rStyleSettings  = GetSettings().GetStyleSettings();
     Rectangle               aCurRect;
     long                    nTopOff = 1;
@@ -1153,65 +1064,127 @@ void TabControl::ImplPaint( const Rectan
     aRect.Top()    -= TAB_OFFSET;
     aRect.Right()  += TAB_OFFSET;
     aRect.Bottom() += TAB_OFFSET;
-    if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
-        SetLineColor( rStyleSettings.GetLightColor() );
-    else
-        SetLineColor( Color( COL_BLACK ) );
-    if ( pCurItem && !pCurItem->maRect.IsEmpty() )
+
+    BOOL bNativeOK = FALSE;
+    if( (bNativeOK = IsNativeControlSupported( CTRL_TAB_PANE, PART_ENTIRE_CONTROL) ) == TRUE )
     {
-        aCurRect = pCurItem->maRect;
-        if( ! bLayout )
-            DrawLine( aRect.TopLeft(), Point( aCurRect.Left()-2, aRect.Top() ) );
-        if ( aCurRect.Right()+1 < aRect.Right() )
-        {
-            if( ! bLayout )
-                DrawLine( Point( aCurRect.Right(), aRect.Top() ), aRect.TopRight() );
-        }
-        else
-            nTopOff = 0;
+        const ImplControlValue aControlValue( BUTTONVALUE_DONTKNOW, rtl::OUString(), 0 );
+
+        ControlState nState = CTRL_STATE_ENABLED;
+        int part = PART_ENTIRE_CONTROL;
+        if ( !IsEnabled() )
+            nState &= ~CTRL_STATE_ENABLED;
+        if ( HasFocus() )
+            nState |= CTRL_STATE_FOCUSED;
+        
+        Region aClipRgn( GetActiveClipRegion() );
+        aClipRgn.Intersect( aRect );
+        if( !rRect.IsEmpty() )
+            aClipRgn.Intersect( rRect );
+        
+        Region aCtrlRegion( aRect );
+        Rectangle aClipRect( aClipRgn.GetBoundRect() );
+        if( !aClipRgn.IsEmpty() ) //&& aClipRect.getHeight() && aClipRect.getWidth() )
+            bNativeOK = DrawNativeControl( CTRL_TAB_PANE, part, aCtrlRegion, nState,
+                aControlValue, rtl::OUString() );
     }
     else
-        if( ! bLayout )
-            DrawLine( aRect.TopLeft(), aRect.TopRight() );
-
-    if( ! bLayout )
     {
-        DrawLine( aRect.TopLeft(), aRect.BottomLeft() );
-
         if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
+            SetLineColor( rStyleSettings.GetLightColor() );
+        else
+            SetLineColor( Color( COL_BLACK ) );
+        if ( pCurItem && !pCurItem->maRect.IsEmpty() )
         {
-            SetLineColor( rStyleSettings.GetShadowColor() );
-            DrawLine( Point( 1, aRect.Bottom()-1 ),
-                      Point( aRect.Right()-1, aRect.Bottom()-1 ) );
-            DrawLine( Point( aRect.Right()-1, aRect.Top()+nTopOff ),
-                      Point( aRect.Right()-1, aRect.Bottom()-1 ) );
-            SetLineColor( rStyleSettings.GetDarkShadowColor() );
-            DrawLine( Point( 0, aRect.Bottom() ),
-                      Point( aRect.Right(), aRect.Bottom() ) );
-            DrawLine( Point( aRect.Right(), aRect.Top()+nTopOff ),
-                      Point( aRect.Right(), aRect.Bottom() ) );
+            aCurRect = pCurItem->maRect;
+            if( ! bLayout )
+                DrawLine( aRect.TopLeft(), Point( aCurRect.Left()-2, aRect.Top() ) );
+            if ( aCurRect.Right()+1 < aRect.Right() )
+            {
+                if( ! bLayout )
+                    DrawLine( Point( aCurRect.Right(), aRect.Top() ), aRect.TopRight() );
+            }
+            else
+                nTopOff = 0;
         }
         else
+            if( ! bLayout )
+                DrawLine( aRect.TopLeft(), aRect.TopRight() );
+
+        if( ! bLayout )
         {
-            DrawLine( aRect.TopRight(), aRect.BottomRight() );
-            DrawLine( aRect.BottomLeft(), aRect.BottomRight() );
+            DrawLine( aRect.TopLeft(), aRect.BottomLeft() );
+
+            if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
+            {
+                SetLineColor( rStyleSettings.GetShadowColor() );
+                DrawLine( Point( 1, aRect.Bottom()-1 ),
+                        Point( aRect.Right()-1, aRect.Bottom()-1 ) );
+                DrawLine( Point( aRect.Right()-1, aRect.Top()+nTopOff ),
+                        Point( aRect.Right()-1, aRect.Bottom()-1 ) );
+                SetLineColor( rStyleSettings.GetDarkShadowColor() );
+                DrawLine( Point( 0, aRect.Bottom() ),
+                        Point( aRect.Right(), aRect.Bottom() ) );
+                DrawLine( Point( aRect.Right(), aRect.Top()+nTopOff ),
+                        Point( aRect.Right(), aRect.Bottom() ) );
+            }
+            else
+            {
+                DrawLine( aRect.TopRight(), aRect.BottomRight() );
+                DrawLine( aRect.BottomLeft(), aRect.BottomRight() );
+            }
         }
     }
 
-    // Alle Items bis auf das aktuelle Zeichnen (nicht fett)
-    SetFont( aLightFont );
-    pItem = mpItemList->First();
-    while ( pItem )
+    // Some native toolkits (GTK+) draw tabs right-to-left, with an
+    // overlap between adjacent tabs
+    bool			bDrawTabsRTL = IsNativeControlSupported( CTRL_TAB_ITEM, PART_TABS_DRAW_RTL );
+    ImplTabItem *	pFirstTab = NULL;
+    ImplTabItem *	pLastTab = NULL;
+    unsigned idx;
+
+    // Event though there is a tab overlap with GTK+, the first tab is not
+    // overlapped on the left side.  Other tookits ignore this option.
+    if ( bDrawTabsRTL )
+    {
+        pFirstTab = mpItemList->First();
+        pLastTab = mpItemList->Last();
+        idx = mpItemList->Count()-1;
+    }
+    else
+    {
+        pLastTab = mpItemList->Last();
+        pFirstTab = mpItemList->First();
+        idx = 0;
+    }
+
+    while ( (pItem = mpItemList->GetObject(idx)) != NULL )
     {
         if ( pItem != pCurItem )
-            ImplDrawItem( pItem, aCurRect, bLayout );
-        pItem = mpItemList->Next();
+        {
+            Region aClipRgn( GetActiveClipRegion() );
+            aClipRgn.Intersect( pItem->maRect );
+            if( !rRect.IsEmpty() )
+                aClipRgn.Intersect( rRect );
+            if( bLayout || !aClipRgn.IsEmpty() )
+                ImplDrawItem( pItem, aCurRect, bLayout, (pItem==pFirstTab), (pItem==pLastTab), FALSE );
+        }
+
+        if ( bDrawTabsRTL )
+            idx--;
+        else
+            idx++;
     }
 
-    // aktuelles Item zeichnen wir fett
-    SetFont( aFont );
     if ( pCurItem )
-        ImplDrawItem( pCurItem, aCurRect, bLayout );
+    {
+        Region aClipRgn( GetActiveClipRegion() );
+        aClipRgn.Intersect( pCurItem->maRect );
+        if( !rRect.IsEmpty() )
+            aClipRgn.Intersect( rRect );
+        if( bLayout || !aClipRgn.IsEmpty() )
+            ImplDrawItem( pCurItem, aCurRect, bLayout, (pCurItem==pFirstTab), (pItem==pLastTab), TRUE );
+    }
 
     if ( !bLayout && HasFocus() )
         ImplShowFocus();
@@ -1266,6 +1239,7 @@ void TabControl::Resize()
             Invalidate( aRect, INVALIDATE_NOCHILDREN );
         else
             Invalidate( aRect );
+            
     }
     else
     {
@@ -1451,6 +1425,76 @@ void TabControl::DataChanged( const Data
 
 // -----------------------------------------------------------------------
 
+Rectangle* TabControl::ImplFindPartRect( const Point& rPt )
+{
+    ImplTabItem* pItem = mpItemList->First();
+    ImplTabItem* pFoundItem = NULL;
+    int nFound = 0;
+    while ( pItem )
+    {
+        if ( pItem->maRect.IsInside( rPt ) )
+        {
+            // assure that only one tab is highlighted at a time
+            nFound++;
+            pFoundItem = pItem;
+        }
+        pItem = mpItemList->Next();
+    }
+    // assure that only one tab is highlighted at a time
+    return nFound == 1 ? &pFoundItem->maRect : NULL;
+}
+
+long TabControl::PreNotify( NotifyEvent& rNEvt )
+{
+    long nDone = 0;
+    const MouseEvent* pMouseEvt = NULL;
+
+    if( (rNEvt.GetType() == EVENT_MOUSEMOVE) && (pMouseEvt = rNEvt.GetMouseEvent()) )
+    {
+        if( !pMouseEvt->GetButtons() && !pMouseEvt->IsSynthetic() && !pMouseEvt->IsModifierChanged() )
+        {
+            // trigger redraw if mouse over state has changed
+            if( IsNativeControlSupported(CTRL_TAB_ITEM, PART_ENTIRE_CONTROL) )
+            {
+                Rectangle* pRect = ImplFindPartRect( GetPointerPosPixel() );
+                Rectangle* pLastRect = ImplFindPartRect( GetLastPointerPosPixel() );
+                if( pRect != pLastRect || (pMouseEvt->IsLeaveWindow() || pMouseEvt->IsEnterWindow()) )
+                {
+                    Region aClipRgn;
+                    if( pLastRect )
+                    {
+                        // allow for slightly bigger tabitems
+                        // as used by gtk
+                        // TODO: query for the correct sizes
+                        Rectangle aRect(*pLastRect);
+                        aRect.nLeft-=2;
+                        aRect.nRight+=2;
+                        aRect.nTop-=3;
+                        aClipRgn.Union( aRect );
+                    }
+                    if( pRect )
+                    {
+                        // allow for slightly bigger tabitems
+                        // as used by gtk
+                        // TODO: query for the correct sizes
+                        Rectangle aRect(*pRect);
+                        aRect.nLeft-=2;
+                        aRect.nRight+=2;
+                        aRect.nTop-=3;
+                        aClipRgn.Union( aRect );
+                    }
+                    if( !aClipRgn.IsEmpty() )
+                        Invalidate( aClipRgn );
+                }
+            }
+        }
+    }
+
+    return nDone ? nDone : Control::PreNotify(rNEvt);
+}
+
+// -----------------------------------------------------------------------
+
 long TabControl::Notify( NotifyEvent& rNEvt )
 {
     if ( (rNEvt.GetType() == EVENT_KEYINPUT) && (GetPageCount() > 1) )
@@ -1580,7 +1624,7 @@ void TabControl::InsertPage( USHORT nPag
 
     ImplFreeLayoutData();
 
-	ImplCallEventListeners( VCLEVENT_TABPAGE_INSERTED, (void*) nPageId );
+	ImplCallEventListeners( VCLEVENT_TABPAGE_INSERTED, (void*) (ULONG)nPageId );
 }
 
 // -----------------------------------------------------------------------
@@ -1620,7 +1664,7 @@ void TabControl::RemovePage( USHORT nPag
 
         ImplFreeLayoutData();
 
-		ImplCallEventListeners( VCLEVENT_TABPAGE_REMOVED, (void*) nPageId );
+		ImplCallEventListeners( VCLEVENT_TABPAGE_REMOVED, (void*) (ULONG) nPageId );
     }
 }
 
@@ -1717,8 +1761,6 @@ void TabControl::SetCurPageId( USHORT nP
             mnActPageId = nPageId;
         else
         {
-            if ( pItem->maRect.IsEmpty() || !pItem->mbFullVisible )
-                SetFirstPageId( nPageId );
             mbFormat = TRUE;
             USHORT nOldId = mnCurPageId;
             mnCurPageId = nPageId;
@@ -1741,9 +1783,7 @@ USHORT TabControl::GetCurPageId() const
 
 void TabControl::SetFirstPageId( USHORT nPageId )
 {
-    USHORT nPos = GetPagePos( nPageId );
-    if ( (nPos != TAB_PAGE_NOTFOUND) && (nPos != mnFirstPagePos) )
-        ImplSetFirstPagePos( nPos );
+    return; // was only required for single line
 }
 
 // -----------------------------------------------------------------------
@@ -1754,7 +1794,7 @@ void TabControl::SelectTabPage( USHORT n
     {
         ImplFreeLayoutData();
 
-		ImplCallEventListeners( VCLEVENT_TABPAGE_DEACTIVATE, (void*) mnCurPageId );
+		ImplCallEventListeners( VCLEVENT_TABPAGE_DEACTIVATE, (void*) (ULONG) mnCurPageId );
         if ( DeactivatePage() )
         {
             mnActPageId = nPageId;
@@ -1763,7 +1803,7 @@ void TabControl::SelectTabPage( USHORT n
             nPageId = mnActPageId;
             mnActPageId = 0;
             SetCurPageId( nPageId );
-			ImplCallEventListeners( VCLEVENT_TABPAGE_ACTIVATE, (void*) nPageId );
+			ImplCallEventListeners( VCLEVENT_TABPAGE_ACTIVATE, (void*) (ULONG) nPageId );
         }
     }
 }
@@ -1830,7 +1870,7 @@ void TabControl::SetPageText( USHORT nPa
         if ( IsUpdateMode() )
             Invalidate();
         ImplFreeLayoutData();
-		ImplCallEventListeners( VCLEVENT_TABPAGE_PAGETEXTCHANGED, (void*) nPageId );
+		ImplCallEventListeners( VCLEVENT_TABPAGE_PAGETEXTCHANGED, (void*) (ULONG) nPageId );
     }
 }
 
Index: vcl/source/gdi/alpha.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/alpha.cxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/source/gdi/alpha.cxx	12 Sep 2002 09:30:55 -0000	1.3
+++ vcl/source/gdi/alpha.cxx	6 Jan 2004 13:26:28 -0000	1.4
@@ -59,16 +59,14 @@
  *
  ************************************************************************/
 
-#define _SV_ALPHA_CXX
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 #ifndef _SV_BMPACC_HXX
 #include <bmpacc.hxx>
 #endif
-#ifndef _SV_COLOR_HXX
-#include <color.hxx>
+#ifndef _TOOLS_COLOR_HXX
+#include <tools/color.hxx>
 #endif
 #ifndef _SV_ALPHA_HXX
 #include <alpha.hxx>
Index: vcl/source/gdi/animate.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/animate.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.4
diff -u -p -u -r1.1.1.1 -r1.4
--- vcl/source/gdi/animate.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/animate.cxx	17 Jun 2004 12:14:23 -0000	1.4
@@ -59,7 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_ANIMATE_CXX
 #define ENABLE_BYTESTRING_STREAM_OPERATORS
 
 #ifndef _DEBUG_HXX
@@ -137,11 +136,11 @@ ULONG AnimationBitmap::GetChecksum() con
 // -------------
 
 Animation::Animation() :
-	mbIsInAnimation 	( FALSE ),
-	meCycleMode 		( CYCLE_NORMAL ),
 	mnLoopCount 		( 0 ),
 	mnLoops 			( 0 ),
 	mnPos				( 0 ),
+	meCycleMode 		( CYCLE_NORMAL ),
+	mbIsInAnimation 	( FALSE ),
 	mbLoopTerminated	( FALSE ),
 	mbIsWaiting 		( FALSE )
 {
@@ -153,12 +152,12 @@ Animation::Animation() :
 // -----------------------------------------------------------------------
 
 Animation::Animation( const Animation& rAnimation ) :
-	maGlobalSize		( rAnimation.maGlobalSize ),
 	maBitmapEx			( rAnimation.maBitmapEx ),
-	meCycleMode 		( rAnimation.meCycleMode ),
-	mbIsInAnimation 	( FALSE ),
+	maGlobalSize		( rAnimation.maGlobalSize ),
 	mnLoopCount 		( rAnimation.mnLoopCount ),
 	mnPos				( rAnimation.mnPos ),
+	meCycleMode 		( rAnimation.meCycleMode ),
+	mbIsInAnimation 	( FALSE ),
 	mbLoopTerminated	( rAnimation.mbLoopTerminated ),
 	mbIsWaiting 		( rAnimation.mbIsWaiting )
 {
@@ -490,10 +489,7 @@ void Animation::Draw( OutputDevice* pOut
 
 void Animation::ImplRestartTimer( ULONG nTimeout )
 {
-#ifdef REMOTE_APPSERVER
-	nTimeout = nTimeout > 40 ? nTimeout : 40;
-#endif
-	maTimer.SetTimeout( Max( nTimeout, MIN_TIMEOUT + ( mnAnimCount - 1 ) * INC_TIMEOUT ) * 10L );
+	maTimer.SetTimeout( Max( nTimeout, (ULONG)(MIN_TIMEOUT + ( mnAnimCount - 1 ) * INC_TIMEOUT) ) * 10L );
 	maTimer.Start();
 }
 
@@ -957,8 +953,6 @@ SvStream& operator>>( SvStream& rIStm, A
 		AnimationBitmap aAnimBmp;
 		BitmapEx		aBmpEx;
 		ByteString		aDummyStr;
-		Point			aPoint;
-		Size			aSize;
 		UINT32			nTmp32;
 		UINT16			nTmp16;
 		BYTE			cTmp;
Index: vcl/source/gdi/bitmap.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bitmap.cxx,v
retrieving revision 1.7
retrieving revision 1.11
diff -u -p -u -r1.7 -r1.11
--- vcl/source/gdi/bitmap.cxx	24 Apr 2003 14:56:22 -0000	1.7
+++ vcl/source/gdi/bitmap.cxx	21 May 2004 16:22:22 -0000	1.11
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_BITMAP_CXX
-
 #ifndef _RTL_CRC_H_
 #include <rtl/crc.h>
 #endif
@@ -73,8 +71,8 @@
 #ifndef _SV_BMPACC_HXX
 #include <bmpacc.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_OUTDEV_HXX
 #include <outdev.hxx>
@@ -83,13 +81,13 @@
 #include <impbmp.hxx>
 #endif
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_BITMAP_HXX
 #include <bitmap.hxx>
 #endif
-#ifndef _SV_ALPHA_HXX
-#include <alpha.hxx>
+#ifndef _SV_BITMAPEX_HXX
+#include <bitmapex.hxx>
 #endif
 #ifndef _SV_SVAPP_HXX
 #include <svapp.hxx>
@@ -98,7 +96,9 @@
 #include <image.hxx>
 #endif
 
-// ------------------------------------------------------------------
+// ----------
+// - Bitmap -
+// ----------
 
 Bitmap::Bitmap() :
 	mpImpBmp( NULL )
@@ -496,12 +486,6 @@ void Bitmap::ImplSetImpBitmap( ImpBitmap
 
 BitmapReadAccess* Bitmap::AcquireReadAccess()
 {
-#ifdef REMOTE_APPSERVER
-	BOOL bGottenFromServer = FALSE;
-	if( mpImpBmp && mpImpBmp->ImplIsGetPrepared() )
-		mpImpBmp->ImplResolveGet(), bGottenFromServer = TRUE;
-#endif
-
 	BitmapReadAccess* pReadAccess = new BitmapReadAccess( *this );
 
 	if( !*pReadAccess )
@@ -510,11 +494,6 @@ BitmapReadAccess* Bitmap::AcquireReadAcc
 		pReadAccess = NULL;
 	}
 
-#ifdef REMOTE_APPSERVER
-	if( pReadAccess && mpImpBmp && bGottenFromServer )
-		mpImpBmp->ImplReleaseRemoteBmp();
-#endif
-
 	return pReadAccess;
 }
 
@@ -522,11 +501,6 @@ BitmapReadAccess* Bitmap::AcquireReadAcc
 
 BitmapWriteAccess* Bitmap::AcquireWriteAccess()
 {
-#ifdef REMOTE_APPSERVER
-	if( mpImpBmp && mpImpBmp->ImplIsGetPrepared() )
-		mpImpBmp->ImplResolveGet();
-#endif
-
 	BitmapWriteAccess* pWriteAccess = new BitmapWriteAccess( *this );
 
 	if( !*pWriteAccess )
@@ -535,11 +509,6 @@ BitmapWriteAccess* Bitmap::AcquireWriteA
 		pWriteAccess = NULL;
 	}
 
-#ifdef REMOTE_APPSERVER
-	if( pWriteAccess && mpImpBmp )
-		mpImpBmp->ImplReleaseRemoteBmp();
-#endif
-
 	return pWriteAccess;
 }
 
@@ -560,8 +529,8 @@ BOOL Bitmap::Erase( const Color& rFillCo
 	if( pWriteAcc )
 	{
 		const ULONG nFormat = pWriteAcc->GetScanlineFormat();
-		BYTE		cIndex;
-		BOOL		bFast;
+		BYTE		cIndex = 0;
+		BOOL		bFast = FALSE;
 
 		switch( nFormat )
 		{
@@ -612,7 +581,7 @@ BOOL Bitmap::Erase( const Color& rFillCo
 		if( bFast )
 		{
 			const ULONG nBufSize = pWriteAcc->GetScanlineSize() * pWriteAcc->Height();
-			HMEMSET( pWriteAcc->GetBuffer(), cIndex, nBufSize );
+			memset( pWriteAcc->GetBuffer(), cIndex, nBufSize );
 		}
 		else
 		{
@@ -713,9 +682,9 @@ BOOL Bitmap::Mirror( ULONG nMirrorFlags 
 
 			for( long nY = 0L, nOther = nHeight1; nY < nHeight_2; nY++, nOther-- )
 			{
-				HMEMCPY( pBuffer, pAcc->GetScanline( nY ), nScanSize );
-				HMEMCPY( pAcc->GetScanline( nY ), pAcc->GetScanline( nOther ), nScanSize );
-				HMEMCPY( pAcc->GetScanline( nOther ), pBuffer, nScanSize );
+				memcpy( pBuffer, pAcc->GetScanline( nY ), nScanSize );
+				memcpy( pAcc->GetScanline( nY ), pAcc->GetScanline( nOther ), nScanSize );
+				memcpy( pAcc->GetScanline( nOther ), pBuffer, nScanSize );
 			}
 
 			delete[] pBuffer;
@@ -1069,6 +1038,9 @@ BOOL Bitmap::CopyPixel( const Rectangle&
 						}
 						else if( pReadAcc->HasPalette() )
 						{
+							for( long nSrcY = aRectSrc.Top(); nSrcY < nSrcEndY; nSrcY++, nDstY++ )
+								for( long nSrcX = aRectSrc.Left(), nDstX = aRectDst.Left(); nSrcX < nSrcEndX; nSrcX++, nDstX++ )
+									pWriteAcc->SetPixel( nDstY, nDstX, pReadAcc->GetPaletteColor( pReadAcc->GetPixel( nSrcY, nSrcX ) ) );
 						}
 						else
 							for( long nSrcY = aRectSrc.Top(); nSrcY < nSrcEndY; nSrcY++, nDstY++ )
@@ -1157,8 +1129,6 @@ BOOL Bitmap::Expand( ULONG nDX, ULONG nD
 
 		if( pReadAcc )
 		{
-// Was soll den das ?
-//			BitmapPalette		aBmpPal( pReadAcc ? pReadAcc->GetPalette() : BitmapPalette() );
 			BitmapPalette		aBmpPal( pReadAcc->GetPalette() );
 			Bitmap				aNewBmp( aNewSize, GetBitCount(), &aBmpPal );
 			BitmapWriteAccess*	pWriteAcc = aNewBmp.AcquireWriteAccess();
@@ -1166,7 +1136,6 @@ BOOL Bitmap::Expand( ULONG nDX, ULONG nD
 			if( pWriteAcc )
 			{
 				BitmapColor aColor;
-				const ULONG nScanlineSize = pReadAcc->GetScanlineSize();
 				const long	nNewX = nWidth;
 				const long	nNewY = nHeight;
 				const long	nNewWidth = pWriteAcc->Width();
@@ -1448,11 +1417,6 @@ Region Bitmap::CreateRegion( const Color
 	return aRegion;
 }
 
-//fuer WIN16 Borland
-#ifdef WIN
-#pragma codeseg BITMAP_SEG1
-#endif
-
 // ------------------------------------------------------------------
 
 BOOL Bitmap::Replace( const Bitmap& rMask, const Color& rReplaceColor )
@@ -1755,7 +1719,6 @@ Bitmap Bitmap::CreateDisplayBitmap( Outp
 {
 	Bitmap aDispBmp( *this );
 
-#ifndef REMOTE_APPSERVER
 	if( mpImpBmp && ( pDisplay->mpGraphics || pDisplay->ImplGetGraphics() ) )
 	{
 		ImpBitmap* pImpDispBmp = new ImpBitmap;
@@ -1765,7 +1728,6 @@ Bitmap Bitmap::CreateDisplayBitmap( Outp
 		else
 			delete pImpDispBmp;
 	}
-#endif
 
 	return aDispBmp;
 }
@@ -1971,80 +1945,3 @@ BOOL Bitmap::MakeMono( BYTE cThreshold )
 {
 	return ImplMakeMono( cThreshold );
 }
-
-// ------------------------------------------------------------------
-
-#ifdef REMOTE_APPSERVER
-
-void Bitmap::ImplDrawRemote( OutputDevice* pOut,
-							 const Point& rSrcPt, const Size& rSrcSz,
-							 const Point& rDestPt, const Size& rDestSz ) const
-{
-	if( mpImpBmp )
-	{
-		if( !mpImpBmp->ImplGetRemoteBmp() )
-			mpImpBmp->ImplCreateRemoteBmp( *this );
-
-		mpImpBmp->ImplDrawRemoteBmp( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz );
-	}
-}
-
-// ------------------------------------------------------------------
-
-void Bitmap::ImplDrawRemoteEx( OutputDevice* pOut,
-							 const Point& rSrcPt, const Size& rSrcSz,
-							 const Point& rDestPt, const Size& rDestSz,
-							 const Bitmap& rMask ) const
-{
-	if( mpImpBmp )
-	{
-		if( !mpImpBmp->ImplGetRemoteBmp() )
-			mpImpBmp->ImplCreateRemoteBmp( *this );
-
-		mpImpBmp->ImplDrawRemoteBmpEx( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rMask );
-	}
-}
-
-// ------------------------------------------------------------------
-
-void Bitmap::ImplDrawRemoteAlpha( OutputDevice* pOut,
-								  const Point& rSrcPt, const Size& rSrcSz,
-								  const Point& rDestPt, const Size& rDestSz,
-								  const AlphaMask& rAlpha ) const
-{
-	if( mpImpBmp )
-	{
-		if( !mpImpBmp->ImplGetRemoteBmp() )
-			mpImpBmp->ImplCreateRemoteBmp( *this );
-
-		mpImpBmp->ImplDrawRemoteBmpAlpha( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rAlpha );
-	}
-}
-
-// ------------------------------------------------------------------
-
-void Bitmap::ImplDrawRemoteMask( OutputDevice* pOut,
-							 const Point& rSrcPt, const Size& rSrcSz,
-							 const Point& rDestPt, const Size& rDestSz,
-							 const Color& rColor ) const
-{
-	if( mpImpBmp )
-	{
-		if( !mpImpBmp->ImplGetRemoteBmp() )
-			mpImpBmp->ImplCreateRemoteBmp( *this );
-
-		mpImpBmp->ImplDrawRemoteBmpMask( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rColor );
-	}
-}
-
-// ------------------------------------------------------------------
-
-void Bitmap::ImplGetRemoteBmp( OutputDevice* pOut, const Point& rPt, const Size& rSz )
-{
-	DBG_ASSERT( !mpImpBmp, "Bitmap::ImplGetRemoteBmp???" );
-
-	mpImpBmp = new ImpBitmap;
-	mpImpBmp->ImplCreateRemoteBmp( *this, pOut, rPt, rSz );
-}
-
-#endif
Index: vcl/source/gdi/bitmap2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bitmap2.cxx,v
retrieving revision 1.4
retrieving revision 1.6
diff -u -p -u -r1.4 -r1.6
--- vcl/source/gdi/bitmap2.cxx	24 Apr 2003 13:17:58 -0000	1.4
+++ vcl/source/gdi/bitmap2.cxx	17 Jun 2004 12:14:50 -0000	1.6
@@ -59,14 +59,6 @@
  *
  ************************************************************************/
 
-#ifdef WIN
-#ifndef _SV_SVSYS_HXX
-#include <svsys.h>
-#endif
-#endif
-
-#define _SV_BITMAP_CXX
-
 #include <tools/zcodec.hxx>
 #ifndef _TOOLS_NEW_HXX
 #include <tools/new.hxx>
@@ -130,8 +122,8 @@ struct DIBInfoHeader
 						nHeight( 0UL ),
 						nPlanes( 0 ),
 						nBitCount( 0 ),
-						nCompression( 0UL ),
-						nSizeImage( 0UL ),
+						nCompression( 0 ),
+						nSizeImage( 0 ),
 						nXPelsPerMeter( 0UL ),
 						nYPelsPerMeter( 0UL ),
 						nColsUsed( 0UL ),
@@ -196,8 +188,6 @@ BOOL Bitmap::ImplReadDIB( SvStream& rISt
 {
 	DIBInfoHeader	aHeader;
 	const ULONG 	nStmPos = rIStm.Tell();
-	BitmapPalette*	pPalette = NULL;
-	BOOL			bHeaderRead = FALSE;
 	BOOL			bRet = FALSE;
 
 	if( ImplReadDIBInfoHeader( rIStm, aHeader ) && aHeader.nWidth && aHeader.nHeight && aHeader.nBitCount )
@@ -665,7 +655,7 @@ BOOL Bitmap::ImplReadDIBBits( SvStream& 
 
 BOOL Bitmap::Write( SvStream& rOStm, BOOL bCompressed, BOOL bFileHeader ) const
 {
-	BMP_ASSERT( mpImpBmp, "Empty Bitmaps can't be saved" );
+	DBG_ASSERT( mpImpBmp, "Empty Bitmaps can't be saved" );
 
 	const Size	aSizePix( GetSizePixel() );
 	BOOL		bRet = FALSE;
@@ -711,7 +701,7 @@ BOOL Bitmap::ImplWriteDIB( SvStream& rOS
 	DIBInfoHeader	aHeader;
 	ULONG			nImageSizePos;
 	ULONG			nEndPos;
-	ULONG			nCompression = 0UL;
+	ULONG			nCompression = 0;
 	BOOL			bRet = FALSE;
 
 	aHeader.nSize = DIBINFOHEADERSIZE;
Index: vcl/source/gdi/bitmap3.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bitmap3.cxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/source/gdi/bitmap3.cxx	27 Aug 2001 12:57:08 -0000	1.3
+++ vcl/source/gdi/bitmap3.cxx	6 Jan 2004 13:28:34 -0000	1.4
@@ -60,11 +60,6 @@
  ************************************************************************/
 
 #include <stdlib.h>
-#define _SV_BITMAP_CXX
-
-#ifdef W31
-#include <tools/svwin.h>
-#endif
 #include <tools/new.hxx>
 #ifndef _SV_BMPACC_HXX
 #include <bmpacc.hxx>
@@ -1033,7 +1028,7 @@ BOOL Bitmap::ImplScaleFast( const double
 
 					while( ( nActY < nNewHeight1 ) && ( pLutY[ nActY + 1 ] == nMapY ) )
 					{
-						HMEMCPY( pWriteAcc->GetScanline( nActY + 1L ),
+						memcpy( pWriteAcc->GetScanline( nActY + 1L ),
 								 pWriteAcc->GetScanline( nActY ), nScanlineSize );
 						nActY++;
 					}
@@ -1316,11 +1311,6 @@ BOOL Bitmap::Dither( ULONG nDitherFlags,
 	return bRet;
 }
 
-//fuer WIN16 Borland
-#ifdef WIN
-#pragma codeseg BITMAP3_SEG1
-#endif
-
 // ------------------------------------------------------------------------
 
 BOOL Bitmap::ImplDitherMatrix( const BitmapPalette* pDitherPal )
@@ -1413,7 +1403,6 @@ BOOL Bitmap::ImplDitherFloyd( const Bitm
 			long		nX;
 			long		nW = nWidth * 3L;
 			long		nW2 = nW - 3L;
-			long		nWLen = nW << 2;
 			long		nRErr, nGErr, nBErr;
 			long		nRC, nGC, nBC;
 			long		nTemp;
@@ -1491,7 +1480,8 @@ BOOL Bitmap::ImplDitherFloyd( const Bitm
 				pWriteAcc->SetPixel( nYAcc, 0, BitmapColor( (BYTE) ( nVCLBLut[ nBC ] + nVCLGLut[nGC ] + nVCLRLut[nRC ] ) ) );
 
 				// mittlere Pixel ueber Schleife
-				for ( long nX = 3L, nXAcc = 1L; nX < nW2; nXAcc++ )
+				long nX, nXAcc;
+				for ( nX = 3L, nXAcc = 1L; nX < nW2; nXAcc++ )
 				{
 					CALC_ERRORS;
 					CALC_TABLES7;
@@ -1908,12 +1898,12 @@ BOOL Bitmap::ImplReduceMedian( USHORT nC
 		if( pWAcc )
 		{
 			const ULONG	nSize = 32768UL * sizeof( ULONG );
-			HPULONG		pColBuf = (HPULONG) SvMemAlloc( nSize );
+			ULONG*		pColBuf = (ULONG*) SvMemAlloc( nSize );
 			const long	nWidth = pWAcc->Width();
 			const long	nHeight = pWAcc->Height();
 			long		nIndex = 0L;
 
-			HMEMSET( (HPBYTE) pColBuf, 0, nSize );
+			memset( (HPBYTE) pColBuf, 0, nSize );
 
 			// create Buffer
 			if( pRAcc->HasPalette() )
@@ -1986,7 +1976,7 @@ void Bitmap::ImplMedianCut( ULONG* pColB
 	const long	nGLen = nG2 - nG1; 
 	const long	nBLen = nB2 - nB1;
 	long 		nR, nG, nB;
-	HPULONG		pBuf = pColBuf;
+	ULONG*		pBuf = pColBuf;
 
 	if( !nRLen && !nGLen && !nBLen )
 	{
Index: vcl/source/gdi/bitmap4.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/bitmap4.cxx,v
retrieving revision 1.2.292.1
retrieving revision 1.5
diff -u -p -u -r1.2.292.1 -r1.5
--- vcl/source/gdi/bitmap4.cxx	15 Aug 2003 11:23:35 -0000	1.2.292.1
+++ vcl/source/gdi/bitmap4.cxx	6 Jan 2004 13:29:07 -0000	1.5
@@ -58,7 +58,6 @@
  *
  *
  ************************************************************************/
-#define _SV_BITMAP_CXX
 
 #include <stdlib.h>
 #include <vos/macros.hxx>
@@ -88,8 +87,7 @@
 
 BOOL Bitmap::Filter( BmpFilter eFilter, const BmpFilterParam* pFilterParam, const Link* pProgress )
 {
-	const USHORT	nBitCount = GetBitCount();
-	BOOL			bRet = FALSE;
+	BOOL bRet = FALSE;
 
 	switch( eFilter )
 	{
@@ -620,7 +618,7 @@ BOOL Bitmap::ImplEmbossGrey( const BmpFi
 							aGrey.SetIndex( 0 );
 						else
 						{
-							const double fGrey = nDotL / sqrt( nNx * nNx + nNy * nNy + nZ2 );
+							const double fGrey = nDotL / sqrt( (double)(nNx * nNx + nNy * nNy + nZ2) );
 							aGrey.SetIndex( (BYTE) VOS_BOUND( fGrey, 0, 255 ) );
 						}
 						
Index: vcl/source/gdi/color.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/color.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/color.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/color.cxx	6 Jan 2004 13:34:39 -0000	1.2
@@ -76,7 +76,7 @@
 #include <svapp.hxx>
 #endif
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
 //============================================================================
@@ -97,7 +97,7 @@ Color::Color( const ResId& rResId )
 		USHORT nGreen	= pResMgr->ReadShort();
 		USHORT nBlue	= pResMgr->ReadShort();
 		// one more historical USHORT
-		USHORT nDummy	= pResMgr->ReadShort();
+		pResMgr->ReadShort();
 
 		// RGB-Farbe
 		mnColor = RGB_COLORDATA( nRed>>8, nGreen>>8, nBlue>>8 );
Index: vcl/source/gdi/cvtgrf.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/cvtgrf.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/source/gdi/cvtgrf.cxx	27 Sep 2001 17:00:25 -0000	1.2
+++ vcl/source/gdi/cvtgrf.cxx	6 Jan 2004 13:35:07 -0000	1.4
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_CVTGRF_CXX
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -81,19 +79,6 @@
 // - Callback	-
 // --------------
 
-#ifndef REMOTE_APPSERVER
-
-ULONG ImplFilterCallback( void* pInst,
-						  ULONG nInFormat, void* pInBuffer, ULONG nInBufSize,
-						  ULONG nOutFormat, void** ppOutBuffer )
-{
-	return( ( (GraphicConverter*) pInst )->ImplConvert( nInFormat, 
-														pInBuffer, nInBufSize,
-														ppOutBuffer, nOutFormat ) );
-}
-
-#endif
-
 // --------------------
 // - GraphicConverter -
 // --------------------
@@ -101,9 +86,6 @@ ULONG ImplFilterCallback( void* pInst,
 GraphicConverter::GraphicConverter() :
 	mpConvertData( NULL )
 {
-#ifndef REMOTE_APPSERVER
-	SetFilterCallback( (void*)ImplFilterCallback, this );
-#endif	
 }
 
 // ------------------------------------------------------------------------
Index: vcl/source/gdi/cvtsvm.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/cvtsvm.cxx,v
retrieving revision 1.7
retrieving revision 1.9
diff -u -p -u -r1.7 -r1.9
--- vcl/source/gdi/cvtsvm.cxx	27 Mar 2003 17:57:56 -0000	1.7
+++ vcl/source/gdi/cvtsvm.cxx	17 Jun 2004 12:15:59 -0000	1.9
@@ -59,7 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_CVTSVM_CXX
 #define ENABLE_BYTESTRING_STREAM_OPERATORS
 
 #include <algorithm>
@@ -720,7 +719,7 @@ void SVMConverter::ImplConvertFromSVM1( 
 				case( GDI_TEXTARRAY_ACTION ):
 				{
 					ByteString	aByteStr;
-					long*		pDXAry = NULL;
+					sal_Int32*	pDXAry = NULL;
 					INT32		nIndex, nLen, nAryLen;
 
 					rIStm >> aPt >> nIndex >> nLen >> nTmp >> nAryLen;
@@ -731,7 +730,7 @@ void SVMConverter::ImplConvertFromSVM1( 
 					{
                         INT32 nStrLen( aStr.Len() );
 
-						pDXAry = new long[ ::std::max( nAryLen, nStrLen ) ];
+						pDXAry = new sal_Int32[ Max( nAryLen, nStrLen ) ];
 
 						for( long i = 0L; i < nAryLen; i++ )
 							rIStm >> nTmp, pDXAry[ i ] = nTmp;
@@ -741,7 +740,7 @@ void SVMConverter::ImplConvertFromSVM1( 
                         {
                             if( nAryLen+1 == nStrLen )
                             {
-                                long* pTmpAry = new long[nStrLen];
+                                sal_Int32* pTmpAry = new sal_Int32[nStrLen];
 
                                 aFontVDev.GetTextArray( aStr, pTmpAry, (USHORT) nIndex, (USHORT) nLen );
                                 
@@ -1195,7 +1194,6 @@ void SVMConverter::ImplConvertToSVM1( Sv
 	ULONG				nPos;
 	ULONG				nCountPos;
 	Font				aSaveFont;
-	const ULONG 		nActionCount = rMtf.GetActionCount();
 	const USHORT		nOldFormat = rOStm.GetNumberFormatInt();
 	rtl_TextEncoding	eActualCharSet = gsl_getSystemTextEncoding();
 	const Size			aPrefSize( rMtf.GetPrefSize() );
@@ -1461,7 +1459,7 @@ ULONG SVMConverter::ImplWriteActions( Sv
 				ULONG					nAryLen;
 				ULONG					nLen = pAct->GetLen();
 				const ULONG 			nTextLen = aText.Len();
-				long*					pDXArray = pAct->GetDXArray();
+				sal_Int32*				pDXArray = pAct->GetDXArray();
 
 				if ( ImplWriteUnicodeComment( rOStm, aUniText ) )
 					nCount++;
Index: vcl/source/gdi/font.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/font.cxx,v
retrieving revision 1.6
retrieving revision 1.7
diff -u -p -u -r1.6 -r1.7
--- vcl/source/gdi/font.cxx	27 Mar 2003 17:57:56 -0000	1.6
+++ vcl/source/gdi/font.cxx	6 Jan 2004 13:36:04 -0000	1.7
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_FONT_CXX
-
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
 #endif
@@ -110,11 +108,11 @@ Impl_Font::Impl_Font() :
 // -----------------------------------------------------------------------
 
 Impl_Font::Impl_Font( const Impl_Font& rImplFont ) :
-	maColor( rImplFont.maColor ),
-	maFillColor( rImplFont.maFillColor ),
 	maName( rImplFont.maName ),
 	maStyleName( rImplFont.maStyleName ),
-	maSize( rImplFont.maSize )
+	maSize( rImplFont.maSize ),
+	maColor( rImplFont.maColor ),
+	maFillColor( rImplFont.maFillColor )
 {
 	mnRefCount			= 1;
 	meCharSet			= rImplFont.meCharSet;
@@ -158,11 +156,7 @@ Font::Font()
 {
 	DBG_CTOR( Font, NULL );
 
-#ifdef WIN
-	static Impl_Font _near aStaticImplFont;
-#else
 	static Impl_Font aStaticImplFont;
-#endif
 	// RefCount == 0 fuer statische Objekte
 	aStaticImplFont.mnRefCount = 0;
 	mpImplFont = &aStaticImplFont;
@@ -609,19 +603,16 @@ SvStream& operator>>( SvStream& rIStm, I
 	rIStm.ReadByteString( rImpl_Font.maName, rIStm.GetStreamCharSet() );
 	rIStm.ReadByteString( rImpl_Font.maStyleName, rIStm.GetStreamCharSet() );
 	rIStm >> rImpl_Font.maSize;
-//	rIStm >> rImpl_Font.maColor;									// removed since SUPD396
-//	rIStm >> rImpl_Font.maFillColor;								// removed since SUPD396
 
 	rIStm >> nTmp16; rImpl_Font.meCharSet = (rtl_TextEncoding) nTmp16;
 	rIStm >> nTmp16; rImpl_Font.meFamily = (FontFamily) nTmp16;
 	rIStm >> nTmp16; rImpl_Font.mePitch = (FontPitch) nTmp16;
-//	rIStm >> nTmp16; rImpl_Font.meAlign = (FontAlign) nTmp16;		// removed since SUPD396
 	rIStm >> nTmp16; rImpl_Font.meWeight = (FontWeight) nTmp16;
 	rIStm >> nTmp16; rImpl_Font.meUnderline = (FontUnderline) nTmp16;
 	rIStm >> nTmp16; rImpl_Font.meStrikeout = (FontStrikeout) nTmp16;
 	rIStm >> nTmp16; rImpl_Font.meItalic = (FontItalic) nTmp16;
-	rIStm >> nTmp16; rImpl_Font.meLanguage = (LanguageType) nTmp16; // new since SUPD 396
-	rIStm >> nTmp16; rImpl_Font.meWidthType = (FontWidth) nTmp16;	// new since SUPD 396
+	rIStm >> nTmp16; rImpl_Font.meLanguage = (LanguageType) nTmp16;
+	rIStm >> nTmp16; rImpl_Font.meWidthType = (FontWidth) nTmp16;
 
 	rIStm >> rImpl_Font.mnOrientation;
 
@@ -629,7 +620,6 @@ SvStream& operator>>( SvStream& rIStm, I
 	rIStm >> bTmp; rImpl_Font.mbOutline = bTmp;
 	rIStm >> bTmp; rImpl_Font.mbShadow = bTmp;
 	rIStm >> nTmp8; rImpl_Font.mnKerning = nTmp8;
-//	rIStm >> bTmp; rImpl_Font.mbTransparent = bTmp; 				// removed since SUPD396
 
     if( aCompat.GetVersion() >= 2 )
     {
@@ -652,19 +642,16 @@ SvStream& operator<<( SvStream& rOStm, c
 	rOStm.WriteByteString( rImpl_Font.maName, rOStm.GetStreamCharSet() );
 	rOStm.WriteByteString( rImpl_Font.maStyleName, rOStm.GetStreamCharSet() );
 	rOStm << rImpl_Font.maSize;
-//	rOStm << rImpl_Font.maColor;				// removed since SUPD396
-//	rOStm << rImpl_Font.maFillColor;			// removed since SUPD396
 
 	rOStm << (UINT16) GetStoreCharSet( rImpl_Font.meCharSet, rOStm.GetVersion() );
 	rOStm << (UINT16) rImpl_Font.meFamily;
 	rOStm << (UINT16) rImpl_Font.mePitch;
-//	rOStm << (UINT16) rImpl_Font.meAlign;		// removed since SUPD396
 	rOStm << (UINT16) rImpl_Font.meWeight;
 	rOStm << (UINT16) rImpl_Font.meUnderline;
 	rOStm << (UINT16) rImpl_Font.meStrikeout;
 	rOStm << (UINT16) rImpl_Font.meItalic;
-	rOStm << (UINT16) rImpl_Font.meLanguage;	// new since SUPD 396
-	rOStm << (UINT16) rImpl_Font.meWidthType;	// new since SUPD 396
+	rOStm << (UINT16) rImpl_Font.meLanguage;
+	rOStm << (UINT16) rImpl_Font.meWidthType;
 
 	rOStm << rImpl_Font.mnOrientation;
 
@@ -672,7 +659,6 @@ SvStream& operator<<( SvStream& rOStm, c
 	rOStm << (BOOL) rImpl_Font.mbOutline;
 	rOStm << (BOOL) rImpl_Font.mbShadow;
 	rOStm << (BYTE) rImpl_Font.mnKerning;
-//	rOStm << (BOOL) rImpl_Font.mbTransparent;	// removed since SUPD396
 
     // new in version 2
     rOStm << (BYTE)		rImpl_Font.meRelief;
Index: vcl/source/gdi/fontcfg.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/fontcfg.cxx,v
retrieving revision 1.18.20.3
retrieving revision 1.28
diff -u -p -u -r1.18.20.3 -r1.28
--- vcl/source/gdi/fontcfg.cxx	26 Jan 2004 17:21:01 -0000	1.18.20.3
+++ vcl/source/gdi/fontcfg.cxx	25 Jun 2004 15:16:03 -0000	1.28
@@ -88,13 +88,12 @@
 #include <tools/isolang.hxx>
 #endif
 
-#if OSL_DEBUG_LEVEL > 1
-#include <stdio.h>
+#ifndef _RTL_USTRBUF_HXX_
+#include <rtl/ustrbuf.hxx>
 #endif
 
-#if defined DEBUG_TIMING
+#if OSL_DEBUG_LEVEL > 1
 #include <stdio.h>
-#include <osl/time.h>
 #endif
 
 #include <string.h>
@@ -109,6 +108,7 @@ using namespace vcl;
 using namespace rtl;
 using namespace utl;
 using namespace com::sun::star::uno;
+using namespace com::sun::star::lang;
 using namespace com::sun::star::beans;
 
 struct KeyMap
@@ -221,36 +221,41 @@ void DefaultFontConfigItem::Commit()
 
     int i, nKeys = sizeof(aKeyMap)/sizeof(aKeyMap[0]);
 
-    ::std::map< int, ::std::map< int, OUString > >::const_iterator lang;
+    std::hash_map< Locale, std::hash_map< int, OUString >, LocaleHash >::const_iterator lang;
 
     for( lang = m_aDefaults.begin(); lang != m_aDefaults.end(); ++lang )
     {
-        int nLanguage = lang->first;
-        if( nLanguage == LANGUAGE_DONTKNOW		||
-            nLanguage == LANGUAGE_NONE			||
-            nLanguage == LANGUAGE_SYSTEM		||
-            ( nLanguage >= LANGUAGE_USER1 && nLanguage <= LANGUAGE_USER9 )
-            )
-            continue;
-        String aLanguage( ConvertLanguageToIsoString( nLanguage, '-' ).ToLowerAscii() );
-        if( ! aLanguage.Len() )
+        OUStringBuffer aLanguage(16);
+        aLanguage.append( lang->first.Language.toAsciiLowerCase() );
+        if( lang->first.Country.getLength() )
+        {
+            aLanguage.append( sal_Unicode('-') );
+            aLanguage.append( lang->first.Country.toAsciiLowerCase() );
+            if( lang->first.Variant.getLength() )
+            {
+                aLanguage.append( sal_Unicode('-') );
+                aLanguage.append( lang->first.Variant.toAsciiLowerCase() );
+            }
+        }
+        if( ! aLanguage.getLength() )
             continue;
 
-        String aKeyName( aLanguage );
-        sal_Bool bAdded = AddNode( OUString(), aLanguage ); // defaults for a not yet configured language may be added
+        OUString aKeyName = aLanguage.makeStringAndClear();
+        AddNode( OUString(), aKeyName ); // defaults for a not yet configured language may be added
         Sequence< PropertyValue > aValues( nKeys );
         PropertyValue* pValues = aValues.getArray();
         int nIndex = 0;
         for( i = 0; i < nKeys; i++ )
         {
-            ::std::map< int, OUString >::const_iterator it = lang->second.find( aKeyMap[i].nEnum );
+            std::hash_map< int, OUString >::const_iterator it = lang->second.find( aKeyMap[i].nEnum );
             if( it == lang->second.end() )
                 continue;
 
-            String aName( aKeyName );
-            aName.Append( '/' );
-            aName.AppendAscii( aKeyMap[i].pName, aKeyMap[i].nLen );
-            pValues[nIndex].Name	= aName;
+            OUStringBuffer aName( 64 );
+            aName.append( aKeyName );
+            aName.append( sal_Unicode('/') );
+            aName.appendAscii( aKeyMap[i].pName, aKeyMap[i].nLen );
+            pValues[nIndex].Name	= aName.makeStringAndClear();
             pValues[nIndex].Handle	= it->first;
             pValues[nIndex].Value <<= it->second;
             pValues[nIndex].State	= PropertyState_DIRECT_VALUE;
@@ -274,65 +279,19 @@ void DefaultFontConfigItem::Notify( cons
 /*
  *  DefaultFontConfigItem::getValues
  */
-#ifdef DEBUG_TIMING
-static double fTimeCorrection = 0.0;
-#define START_TIMING() osl_getSystemTime( &aTmpTV1 );
-#define END_TIMING()\
-    osl_getSystemTime( &aTmpTV2 );\
-    fTmp = (double)aTmpTV2.Seconds + 1e-9*(double)aTmpTV2.Nanosec - (double)aTmpTV1.Seconds -1e-9*(double)aTmpTV1.Nanosec;\
-    if( fTmp > 0.0005 )\
-        fConfigTime += fTmp;\
-    else\
-        fprintf( stderr, "warning: timining inaccurate: %g\n", fTmp );
-
-#else
-#define START_TIMING()
-#define END_TIMING()
-#endif
-
 void DefaultFontConfigItem::getValues()
 {
     if( ! IsValidConfigMgr() )
         return;
 
-#ifdef DEBUG_TIMING
-    static bool bOnce = false;
-    TimeValue aStart;
-    TimeValue aStop;
-    TimeValue aTmpTV1, aTmpTV2;
-    double fConfigTime = 0.0;
-    double fTmp;
-    if( ! bOnce )
-    {
-        bOnce = true;
-        START_TIMING();
-        for( int i = 0; i < 100000; i++ )
-            osl_getSystemTime( &aStop );
-        END_TIMING();
-        fTimeCorrection = fTmp/100000.0;
-        fprintf( stderr, "osl_getSystemTime takes an average of %g seconds\n", fTimeCorrection );
-    }
-    osl_getSystemTime( &aStart );
-    fConfigTime = 0.0;
-#endif
-
     m_aDefaults.clear();
 
     int i, j;
-    START_TIMING();
     Sequence< OUString > aNames( GetNodeNames( OUString() ) );
-    END_TIMING();
     for( j = 0; j < aNames.getLength(); j++ )
     {
-#if OSL_DEBUG_LEVEL > 1
-        fprintf( stderr, "found localized default font data for \"%s\"\n",
-                 OUStringToOString( aNames.getConstArray()[j], RTL_TEXTENCODING_ASCII_US ).getStr()
-                 );
-#endif
         String aKeyName( aNames.getConstArray()[j] );
-        START_TIMING();
         Sequence< OUString > aKeys( GetNodeNames( aKeyName ) );
-        END_TIMING();
         Sequence< OUString > aLocaleKeys( aKeys.getLength() );
         const OUString* pFrom = aKeys.getConstArray();
         OUString* pTo = aLocaleKeys.getArray();
@@ -343,10 +302,26 @@ void DefaultFontConfigItem::getValues()
             aName.Append( String( pFrom[m] ) );
             pTo[m] = aName;
         }
-        START_TIMING();
         Sequence< Any > aValues( GetProperties( aLocaleKeys ) );
-        END_TIMING();
-        int nLanguageType = ConvertIsoStringToLanguage( aNames.getConstArray()[j], '-' );
+        Locale aLocale;
+        sal_Int32 nIndex = 0;
+        const OUString* pIso = aNames.getConstArray() + j;
+        aLocale.Language = pIso->getToken( 0, '-', nIndex ).toAsciiLowerCase();
+        if( nIndex > 0 )
+        {
+            aLocale.Country = pIso->getToken( 0, '-', nIndex ).toAsciiLowerCase();
+            if( nIndex > 0 )
+                aLocale.Variant = pIso->copy( nIndex ).toAsciiLowerCase();
+        }
+#if OSL_DEBUG_LEVEL > 2
+        fprintf( stderr, "found localized default font data for \"%s\" = %s-%s-%s\n",
+                 OUStringToOString( *pIso, osl_getThreadTextEncoding() ).getStr(),
+                 OUStringToOString( aLocale.Language, osl_getThreadTextEncoding() ).getStr(),
+                 OUStringToOString( aLocale.Country, osl_getThreadTextEncoding() ).getStr(),
+                 OUStringToOString( aLocale.Variant, osl_getThreadTextEncoding() ).getStr()
+                 
+                 );
+#endif
         const Any* pValue = aValues.getConstArray();
         for( i = 0; i < aValues.getLength(); i++, pValue++ )
         {
@@ -354,8 +329,8 @@ void DefaultFontConfigItem::getValues()
             {
                 const OUString* pLine = (const OUString*)pValue->getValue();
                 if( pLine->getLength() )
-                    m_aDefaults[ nLanguageType ][ getKeyType( aKeys.getConstArray()[i] ) ] = *pLine;
-#if OSL_DEBUG_LEVEL > 1
+                    m_aDefaults[ aLocale ][ getKeyType( aKeys.getConstArray()[i] ) ] = *pLine;
+#if OSL_DEBUG_LEVEL > 2
                 fprintf( stderr, "   \"%s\"=\"%.30s\"\n",
                          OUStringToOString( aKeys.getConstArray()[i], RTL_TEXTENCODING_ASCII_US ).getStr(),
                          OUStringToOString( *pLine, RTL_TEXTENCODING_ASCII_US ).getStr()
@@ -364,36 +339,37 @@ void DefaultFontConfigItem::getValues()
             }
         }
     }
-#ifdef DEBUG_TIMING
-    osl_getSystemTime( &aStop );
-    double fElapse = (double)aStop.Seconds + 1e-9*(double)aStop.Nanosec;
-    fElapse -= (double)aStart.Seconds + 1e-9*(double)aStart.Nanosec;
-    fprintf( stderr, "DefaultFontConfigItem::getValues needed %g seconds\n", fElapse );
-    fprintf( stderr, "time spent in configuration: %g seconds (%g%%)\n", fConfigTime, fConfigTime/fElapse*100.0 );
-#endif
 }
 
 /*
  *  DefaultFontConfigItem::getDefaultFont
  */
 
-const OUString& DefaultFontConfigItem::getDefaultFont( int nLanguage, int nType ) const
+const OUString& DefaultFontConfigItem::getDefaultFont( const Locale& rLocale, int nType ) const
 {
-    ::std::map< int, ::std::map< int, OUString > >::const_iterator lang = m_aDefaults.find( nLanguage );
+    Locale aLocale;
+    aLocale.Language = rLocale.Language.toAsciiLowerCase();
+    aLocale.Country = rLocale.Country.toAsciiLowerCase();
+    aLocale.Variant = rLocale.Variant.toAsciiLowerCase();
+    std::hash_map< Locale, std::hash_map< int, OUString >, vcl::LocaleHash >::const_iterator lang = m_aDefaults.find( aLocale );
     if( lang == m_aDefaults.end() || lang->second.find( nType ) == lang->second.end() )
     {
-        String aLang, aCountry;
-        ConvertLanguageToIsoNames( nLanguage, aLang, aCountry );
-        nLanguage = ConvertIsoStringToLanguage( aLang );
-        lang = m_aDefaults.find( nLanguage );
+        aLocale.Variant = OUString();
+        lang = m_aDefaults.find( aLocale );
         if( lang == m_aDefaults.end() || lang->second.find( nType ) == lang->second.end() )
         {
-            nLanguage = LANGUAGE_ENGLISH;
-            lang = m_aDefaults.find( nLanguage );
+            aLocale.Country = OUString();
+
+            lang = m_aDefaults.find( aLocale );
             if( lang == m_aDefaults.end() || lang->second.find( nType ) == lang->second.end() )
             {
-                static OUString aEmpty;
-                return aEmpty;
+                aLocale.Language = OUString( RTL_CONSTASCII_USTRINGPARAM( "en" ) );
+                lang = m_aDefaults.find( aLocale );
+                if( lang == m_aDefaults.end() || lang->second.find( nType ) == lang->second.end() )
+                {
+                    static OUString aEmpty;
+                    return aEmpty;
+                }
             }
         }
     }
@@ -404,11 +380,17 @@ const OUString& DefaultFontConfigItem::g
  *  DefaultFontConfigItem::getUserInterfaceFont
  */
 
-const OUString& DefaultFontConfigItem::getUserInterfaceFont( int nLanguage ) const
+const OUString& DefaultFontConfigItem::getUserInterfaceFont( const Locale& rLocale ) const
 {
-    if( nLanguage == LANGUAGE_SYSTEM )
-        nLanguage = Application::GetSettings().GetUILanguage();
-    const OUString& aUIFont = getDefaultFont( nLanguage, DEFAULTFONT_UI_SANS );
+    Locale aLocale;
+    aLocale.Language = rLocale.Language.toAsciiLowerCase();
+    aLocale.Country = rLocale.Country.toAsciiLowerCase();
+    aLocale.Variant = rLocale.Variant.toAsciiLowerCase();
+
+    if( ! aLocale.Language.getLength() )
+        aLocale = Application::GetSettings().GetUILocale();
+
+    const OUString& aUIFont = getDefaultFont( aLocale, DEFAULTFONT_UI_SANS );
 
     if( aUIFont.getLength() )
         return aUIFont;
@@ -464,63 +446,43 @@ const OUString& DefaultFontConfigItem::g
     static const OUString aFallBackKorean( aFallBackKoreanLocalized );
    
     // optimize font list for some locales, as long as Andale Sans UI does not support them
-    switch( nLanguage )
+    if( aLocale.Language.equalsAscii( "ar" ) ||
+        aLocale.Language.equalsAscii( "he" ) ||
+        aLocale.Language.equalsAscii( "iw" ) )
     {
-       case LANGUAGE_ARABIC:
-       case LANGUAGE_ARABIC_SAUDI_ARABIA:
-       case LANGUAGE_ARABIC_IRAQ:
-       case LANGUAGE_ARABIC_EGYPT:
-       case LANGUAGE_ARABIC_LIBYA:
-       case LANGUAGE_ARABIC_ALGERIA:
-       case LANGUAGE_ARABIC_MOROCCO:
-       case LANGUAGE_ARABIC_TUNISIA:
-       case LANGUAGE_ARABIC_OMAN:
-       case LANGUAGE_ARABIC_YEMEN:
-       case LANGUAGE_ARABIC_SYRIA:
-       case LANGUAGE_ARABIC_JORDAN:
-       case LANGUAGE_ARABIC_LEBANON:
-       case LANGUAGE_ARABIC_KUWAIT:
-       case LANGUAGE_ARABIC_UAE:
-       case LANGUAGE_ARABIC_BAHRAIN:
-       case LANGUAGE_ARABIC_QATAR:
-       case LANGUAGE_HEBREW:
-           return aFallBackArabic;
-           break;
-       case LANGUAGE_THAI:
-           return aFallBackThai;
-           break;
-       case LANGUAGE_KOREAN:
-       case LANGUAGE_KOREAN_JOHAB:
-           return aFallBackKorean;
-           break;
-            // latin-2 (use luxi before vera)
-       case LANGUAGE_CZECH:
-       case LANGUAGE_HUNGARIAN:
-       case LANGUAGE_POLISH:
-       case LANGUAGE_ROMANIAN:
-       case LANGUAGE_CROATIAN:
-       case LANGUAGE_SLOVAK:
-       case LANGUAGE_SLOVENIAN:
-       case LANGUAGE_SORBIAN:
-           return aFallbackLatin2;
-           break;
-
-       case LANGUAGE_CHINESE:
-       case LANGUAGE_CHINESE_SIMPLIFIED:
+        return aFallBackArabic;
+    }
+    else if( aLocale.Language.equalsAscii( "th" ) )
+    {
+        return aFallBackThai;
+    }
+    else if( aLocale.Language.equalsAscii( "ko" ) )
+    {
+        return aFallBackKorean;
+    }
+    else if( aLocale.Language.equalsAscii( "cs" ) ||
+             aLocale.Language.equalsAscii( "hu" ) ||
+             aLocale.Language.equalsAscii( "pl" ) ||
+             aLocale.Language.equalsAscii( "ro" ) ||
+             aLocale.Language.equalsAscii( "rm" ) ||
+             aLocale.Language.equalsAscii( "hr" ) ||
+             aLocale.Language.equalsAscii( "sk" ) ||
+             aLocale.Language.equalsAscii( "sl" ) ||
+             aLocale.Language.equalsAscii( "sb" ) )
+    {
+        return aFallbackLatin2;
+    }
+    else if( aLocale.Language.equalsAscii( "zh" ) )
+    {
+        if( ! aLocale.Country.equalsAscii( "cn" ) )
+            return aFallBackChineseTRD;
+        else
             return aFallBackChineseSIM;
-            break;
-       case LANGUAGE_CHINESE_TRADITIONAL:
-       case LANGUAGE_CHINESE_HONGKONG:
-       case LANGUAGE_CHINESE_SINGAPORE:
-       case LANGUAGE_CHINESE_MACAU:
-           return aFallBackChineseTRD;
-           break;
-       case LANGUAGE_JAPANESE:
-           return aFallBackJapanese;
-           break;
-       default:
-           break;
-   }
+    }
+    else if( aLocale.Language.equalsAscii( "ja" ) )
+    {
+        return aFallBackJapanese;
+    }
    
    return aFallback;
 }
@@ -529,12 +491,17 @@ const OUString& DefaultFontConfigItem::g
  *  DefaultFontConfigItem::setDefaultFont
  */
 
-void DefaultFontConfigItem::setDefaultFont( int nLanguage, int nType, const OUString& rFont )
+void DefaultFontConfigItem::setDefaultFont( const Locale& rLocale, int nType, const OUString& rFont )
 {
-    bool bModified = m_aDefaults[ nLanguage ][ nType ] != rFont;
+    Locale aLocale;
+    aLocale.Language = rLocale.Language.toAsciiLowerCase();
+    aLocale.Country = rLocale.Country.toAsciiLowerCase();
+    aLocale.Variant = rLocale.Variant.toAsciiLowerCase();
+
+    bool bModified = m_aDefaults[ aLocale ][ nType ] != rFont;
     if( bModified )
     {
-        m_aDefaults[ nLanguage ][ nType ] = rFont;
+        m_aDefaults[ aLocale ][ nType ] = rFont;
         SetModified();
     }
 }
@@ -922,7 +889,7 @@ static BOOL ImplFindAndErase( String& rN
 // =======================================================================
 
 void FontSubstConfigItem::getMapName( const String& rOrgName, String& rShortName,
-    String& rFamilyName, FontWeight& rWeight, FontWidth& rWidth, unsigned long& rType )
+    String& rFamilyName, FontWeight& rWeight, FontWidth& rWidth, ULONG& rType )
 {
     rShortName = rOrgName;
 
@@ -1072,54 +1039,62 @@ void FontSubstConfigItem::getValues()
     if( ! IsValidConfigMgr() )
         return;
 
-#ifdef DEBUG_TIMING
-    TimeValue aStart;
-    TimeValue aStop;
-    TimeValue aTmpTV1, aTmpTV2;
-    osl_getSystemTime( &aStart );
-
-    double fConfigTime = 0.0;
-    double fTmp;
-#endif
-
-    START_TIMING();
     Sequence< OUString > aLocales( GetNodeNames( OUString( ) ) );
-    END_TIMING();
     for( int j = 0; j < aLocales.getLength(); j++ )
     {
-        String aKeyName( aLocales.getConstArray()[j] );
-        int nLanguageType = ConvertIsoStringToLanguage( aLocales.getConstArray()[j], '-' );
-        START_TIMING();
-        Sequence< OUString > aSubstFonts( GetNodeNames( aKeyName ) );
-        END_TIMING();
-#if OSL_DEBUG_LEVEL > 1
+        const OUString* pIso = aLocales.getConstArray() +j;
+        Locale aLocale;
+        sal_Int32 nIndex = 0;
+        aLocale.Language = pIso->getToken( 0, '-', nIndex ).toAsciiLowerCase();
+        if( nIndex > 0 )
+        {
+            aLocale.Country = pIso->getToken( 0, '-', nIndex ).toAsciiLowerCase();
+            if( nIndex > 0 )
+                aLocale.Variant = pIso->copy( nIndex ).toAsciiLowerCase();
+        }
+        Sequence< OUString > aSubstFonts( GetNodeNames( *pIso ) );
+#if OSL_DEBUG_LEVEL > 2
         fprintf( stderr, "reading %d font substitutions for locale %s\n",
                  aSubstFonts.getLength(),
-                 ByteString( aKeyName, RTL_TEXTENCODING_ASCII_US ).GetBuffer() );
+                 OUStringToOString( *pIso, RTL_TEXTENCODING_ASCII_US ).getStr() );
 #endif
         for( int i = 0; i < aSubstFonts.getLength(); i++ )
         {
             FontNameAttr aAttributes;
             aAttributes.Name = aSubstFonts.getConstArray()[i];
 
-            String aFontKey( aKeyName );
-            aFontKey.Append( '/' );
+            OUStringBuffer aFontKey( 128 );
+            aFontKey.append( *pIso );
+            aFontKey.append( sal_Unicode('/') );
             // must use the wrapped name in config paths due to non-ASCII chars (eg korean font names) !!!
-            String wrappedName = wrapConfigurationElementName( aAttributes.Name );
-            aFontKey.Append( wrappedName );  
+            OUString wrappedName = wrapConfigurationElementName( aAttributes.Name );
+            aFontKey.append( wrappedName );
             Sequence< OUString > aKeys( 7 );
             OUString* pKeys = aKeys.getArray();
-            aFontKey.Append( '/' );
-            pKeys[0] = aFontKey.Copy().AppendAscii( "SubstFonts" );
-            pKeys[1] = aFontKey.Copy().AppendAscii( "SubstFontsMS" );
-            pKeys[2] = aFontKey.Copy().AppendAscii( "SubstFontsPS" );
-            pKeys[3] = aFontKey.Copy().AppendAscii( "SubstFontsHTML" );
-            pKeys[4] = aFontKey.Copy().AppendAscii( "FontWidth" );
-            pKeys[5] = aFontKey.Copy().AppendAscii( "FontWeight" );
-            pKeys[6] = aFontKey.Copy().AppendAscii( "FontType" );
-            START_TIMING();
+            aFontKey.append( sal_Unicode('/') );
+            OUString aPath = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "SubstFonts" );
+            pKeys[0] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "SubstFontsMS" );
+            pKeys[1] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "SubstFontsPS" );
+            pKeys[2] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "SubstFontsHTML" );
+            pKeys[3] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "FontWidth" );
+            pKeys[4] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "FontWeight" );
+            pKeys[5] = aFontKey.makeStringAndClear();
+            aFontKey.append( aPath );
+            aFontKey.appendAscii( "FontType" );
+            pKeys[6] = aFontKey.makeStringAndClear();
             Sequence< Any > aValues( GetProperties( aKeys ) );
-            END_TIMING();
             const Any* pValues = aValues.getConstArray();
             sal_Int32 nIndex = 0, width = -1, weight = -1, type = 0;
             const OUString* pLine;
@@ -1226,20 +1201,13 @@ void FontSubstConfigItem::getValues()
             }
             aAttributes.Type = type;
 
-            m_aSubstitutions[nLanguageType].push_back( aAttributes );
+            m_aSubstitutions[aLocale].push_back( aAttributes );
         }
-        ::std::sort( m_aSubstitutions[nLanguageType].begin(), m_aSubstitutions[nLanguageType].end(), StrictStringSort() );
+        std::sort( m_aSubstitutions[aLocale].begin(), m_aSubstitutions[aLocale].end(), StrictStringSort() );
     }
-#ifdef DEBUG_TIMING
-    osl_getSystemTime( &aStop );
-    double fElapse = (double)aStop.Seconds + 1e-9*(double)aStop.Nanosec;
-    fElapse -= (double)aStart.Seconds + 1e-9*(double)aStart.Nanosec;
-    fprintf( stderr, "FontSubstConfigItem::getValues needed %g seconds\n", fElapse );
-    fprintf( stderr, "time spent in configuration: %g seconds (%g%%)\n", fConfigTime, fConfigTime/fElapse*100.0 );
-#endif
 }
 
-const FontSubstConfigItem::FontNameAttr* FontSubstConfigItem::getSubstInfo( const String& rFontName, int nLanguage ) const
+const FontSubstConfigItem::FontNameAttr* FontSubstConfigItem::getSubstInfo( const String& rFontName, const Locale& rLocale ) const
 {
     if( !rFontName.Len() )
         return NULL;
@@ -1250,9 +1218,18 @@ const FontSubstConfigItem::FontNameAttr*
     aSearchFont.ToLowerAscii();
     FontNameAttr aSearchAttr;
     aSearchAttr.Name = aSearchFont;
-    for( int i = 0; i < 3; i++ )
+
+    Locale aLocale;
+    aLocale.Language = rLocale.Language.toAsciiLowerCase();
+    aLocale.Country = rLocale.Country.toAsciiLowerCase();
+    aLocale.Variant = rLocale.Variant.toAsciiLowerCase();
+
+    if( ! aLocale.Language.getLength() )
+        aLocale = Application::GetSettings().GetUILocale();
+
+    while( aLocale.Language.getLength() )
     {
-        ::std::map< int, ::std::vector< FontNameAttr > >::const_iterator lang = m_aSubstitutions.find( nLanguage );
+        std::hash_map< Locale, std::vector< FontNameAttr >, LocaleHash >::const_iterator lang = m_aSubstitutions.find( aLocale );
         if( lang != m_aSubstitutions.end() )
         {
             // try to find an exact match
@@ -1261,22 +1238,15 @@ const FontSubstConfigItem::FontNameAttr*
             if( it != lang->second.end() && aSearchFont.CompareTo( it->Name, aSearchFont.Len() ) == COMPARE_EQUAL )
                 return &(*it);
         }
-        switch( i )
-        {
-            case 0:
-            {
-                String aLang, aCountry;
-                ConvertLanguageToIsoNames( nLanguage, aLang, aCountry );
-                int nNewLanguage = ConvertIsoStringToLanguage( aLang );
-                if( nNewLanguage == nLanguage || nNewLanguage == LANGUAGE_DONTKNOW || nNewLanguage == LANGUAGE_NONE )
-                    nNewLanguage = LANGUAGE_ENGLISH;
-                nLanguage = nNewLanguage;
-            }
-            break;
-            case 1:
-                nLanguage = LANGUAGE_ENGLISH;
-                break;
-        }
+        // gradually become more unspecific
+        if( aLocale.Variant.getLength() )
+            aLocale.Variant = OUString();
+        else if( aLocale.Country.getLength() )
+            aLocale.Country = OUString();
+        else if( ! aLocale.Language.equalsAscii( "en" ) )
+            aLocale.Language = OUString( RTL_CONSTASCII_USTRINGPARAM( "en" ) );
+        else
+            aLocale.Language = OUString();
     }
     return NULL;
 }
@@ -1324,7 +1294,7 @@ void SettingsConfigItem::Commit()
     if( ! IsValidConfigMgr() )
         return;
 
-    ::std::hash_map< OUString, ::std::hash_map< OUString, OUString, OUStringHash >, OUStringHash >::const_iterator group;
+    std::hash_map< OUString, std::hash_map< OUString, OUString, OUStringHash >, OUStringHash >::const_iterator group;
 
     for( group = m_aSettings.begin(); group != m_aSettings.end(); ++group )
     {
@@ -1333,7 +1303,7 @@ void SettingsConfigItem::Commit()
         Sequence< PropertyValue > aValues( group->second.size() );
         PropertyValue* pValues = aValues.getArray();
         int nIndex = 0;
-        ::std::hash_map< OUString, OUString, OUStringHash >::const_iterator it;
+        std::hash_map< OUString, OUString, OUStringHash >::const_iterator it;
         for( it = group->second.begin(); it != group->second.end(); ++it )
         {
             String aName( aKeyName );
@@ -1372,7 +1342,7 @@ void SettingsConfigItem::getValues()
     Sequence< OUString > aNames( GetNodeNames( OUString() ) );
     for( j = 0; j < aNames.getLength(); j++ )
     {
-#if OSL_DEBUG_LEVEL > 1
+#if OSL_DEBUG_LEVEL > 2
         fprintf( stderr, "found settings data for \"%s\"\n",
                  OUStringToOString( aNames.getConstArray()[j], RTL_TEXTENCODING_ASCII_US ).getStr()
                  );
@@ -1398,7 +1368,7 @@ void SettingsConfigItem::getValues()
                 const OUString* pLine = (const OUString*)pValue->getValue();
                 if( pLine->getLength() )
                     m_aSettings[ aKeyName ][ pFrom[i] ] = *pLine;
-#if OSL_DEBUG_LEVEL > 1
+#if OSL_DEBUG_LEVEL > 2
                 fprintf( stderr, "   \"%s\"=\"%.30s\"\n",
                          OUStringToOString( aKeys.getConstArray()[i], RTL_TEXTENCODING_ASCII_US ).getStr(),
                          OUStringToOString( *pLine, RTL_TEXTENCODING_ASCII_US ).getStr()
Index: vcl/source/gdi/fontcvt.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/fontcvt.cxx,v
retrieving revision 1.13
retrieving revision 1.14
diff -u -p -u -r1.13 -r1.14
--- vcl/source/gdi/fontcvt.cxx	10 Jun 2002 11:06:06 -0000	1.13
+++ vcl/source/gdi/fontcvt.cxx	6 Jan 2004 13:37:42 -0000	1.14
@@ -67,16 +67,16 @@
 #include <outdev.h>
 #endif
 
-#ifndef __SGI_STL_MAP
+#ifndef _STLP_MAP
 #include <map>
 #endif
-#ifndef __SGI_STL_VECTOR
+#ifndef _STLP_VECTOR
 #include <vector>
 #endif
-#ifndef __SGI_STL_ALGORITHM
+#ifndef _STLP_ALGORITHM
 #include <algorithm>
 #endif
-#ifndef __SGI_STL_FUNCTIONAL
+#ifndef _STLP_FUNCTIONAL
 #include <functional>
 #endif
 
@@ -1233,13 +1233,9 @@ StarSymbolToMSMultiFontImpl::StarSymbolT
         for (aEntry.cIndex = 0xFF; aEntry.cIndex >= 0x20; --aEntry.cIndex)
         {
             if (sal_Unicode cChar = r.pTab[aEntry.cIndex-0x20])
-#if 1
                 maMagicMap.insert(
                     ::std::multimap<sal_Unicode, SymbolEntry>::value_type(
                     cChar, aEntry));
-#else
-                maMagicMap.insert(::std::make_pair(cChar, aEntry));
-#endif
         }
     }
 
@@ -1270,14 +1266,9 @@ StarSymbolToMSMultiFontImpl::StarSymbolT
         for (int j = r.mnSize / sizeof(r.mpTable[0]); j >=0; --j)
         {
             aEntry.cIndex = r.mpTable[j].cMS;
-#if 1
             maMagicMap.insert(
                 ::std::multimap<sal_Unicode, SymbolEntry>::value_type(
                 r.mpTable[j].cStar, aEntry));
-#else
-            maMagicMap.insert(::std::make_pair(r.mpTable[j].cStar,aEntry));
-#endif
-
         }
     }
 }
@@ -1317,11 +1308,7 @@ String StarSymbolToMSMultiFontImpl::Conv
 String StarSymbolToMSMultiFontImpl::ConvertString(String &rString, 
     xub_StrLen& rIndex)
 { 
-#if 1
     typedef ::std::multimap<sal_Unicode, SymbolEntry>::iterator MI;
-#else
-    typedef ::std::multimap<sal_Unicode, SymbolEntry>::const_iterator MI;
-#endif
     typedef ::std::pair<MI, MI> Result;
     
     String sRet;
Index: vcl/source/gdi/gdimtf.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/gdimtf.cxx,v
retrieving revision 1.9
retrieving revision 1.10
diff -u -p -u -r1.9 -r1.10
--- vcl/source/gdi/gdimtf.cxx	18 Nov 2002 13:44:33 -0000	1.9
+++ vcl/source/gdi/gdimtf.cxx	6 Jan 2004 13:38:14 -0000	1.10
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_GDIMTF_CXX
-
 #ifndef _VOS_MACROS_HXX_
 #include <vos/macros.hxx>
 #endif
@@ -1174,8 +1172,6 @@ void GDIMetaFile::Rotate( long nAngle10 
 			    case( META_GRADIENTEX_ACTION ):
 			    {
 				    MetaGradientExAction* pAct = (MetaGradientExAction*) pAction;
-				    Gradient			  aGradient(  );
-
 				    aMtf.AddAction( new MetaGradientExAction( ImplGetRotatedPolyPolygon( pAct->GetPolyPolygon(), aRotAnchor, aRotOffset, fSin, fCos ),
                                                               pAct->GetGradient() ) );
 			    }
@@ -2178,7 +2174,6 @@ SvStream& operator>>( SvStream& rIStm, G
 		char	aId[ 7 ];
 		ULONG	nStmPos = rIStm.Tell();
 		USHORT	nOldFormat = rIStm.GetNumberFormatInt();
-		BOOL	bError = FALSE;
 
 		rIStm.SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
 
Index: vcl/source/gdi/gfxlink.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/gfxlink.cxx,v
retrieving revision 1.9
retrieving revision 1.10
diff -u -p -u -r1.9 -r1.10
--- vcl/source/gdi/gfxlink.cxx	24 Jun 2003 07:32:36 -0000	1.9
+++ vcl/source/gdi/gfxlink.cxx	6 Jan 2004 13:39:16 -0000	1.10
@@ -79,9 +79,9 @@
 
 GfxLink::GfxLink() :
 	meType		( GFX_LINK_TYPE_NONE ),
-	mnBufSize	( 0 ),
 	mpBuf		( NULL ),
 	mpSwap		( NULL ),
+	mnBufSize	( 0 ),
 	mnUserId	( 0UL ),
     mpImpData   ( new ImpGfxLink )
 {
Index: vcl/source/gdi/gradient.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/gradient.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/gradient.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/gradient.cxx	6 Jan 2004 13:39:43 -0000	1.2
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_GRADIENT_CXX
 
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
Index: vcl/source/gdi/graph.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/graph.cxx,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -p -u -r1.5 -r1.7
--- vcl/source/gdi/graph.cxx	27 Mar 2003 17:57:57 -0000	1.5
+++ vcl/source/gdi/graph.cxx	20 Apr 2004 13:54:00 -0000	1.7
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_GRAPH_CXX
-
 #ifndef _SV_IMPGRAPH_HXX
 #include <impgraph.hxx>
 #endif
@@ -446,14 +444,28 @@ BitmapEx Graphic::GetBitmapEx() const
 
 Bitmap Graphic::GetBitmap( const Size* pSizePixel ) const
 {
-    return mpImpGraphic->ImplGetBitmap( pSizePixel );
+    return mpImpGraphic->ImplGetBitmap( pSizePixel, FALSE );
 }
 
 // ------------------------------------------------------------------------
 
 BitmapEx Graphic::GetBitmapEx( const Size* pSizePixel ) const
 {
-    return mpImpGraphic->ImplGetBitmapEx( pSizePixel );
+    return mpImpGraphic->ImplGetBitmapEx( pSizePixel, FALSE );
+}
+
+// ------------------------------------------------------------------------
+
+Bitmap Graphic::GetUnlimitedBitmap( const Size* pSizePixel ) const
+{
+    return mpImpGraphic->ImplGetBitmap( pSizePixel, TRUE ) ;
+}
+
+// ------------------------------------------------------------------------
+
+BitmapEx Graphic::GetUnlimitedBitmapEx( const Size* pSizePixel ) const
+{
+    return mpImpGraphic->ImplGetBitmapEx( pSizePixel, TRUE ) ;
 }
 
 // ------------------------------------------------------------------------
@@ -507,7 +519,7 @@ Size Graphic::GetSizePixel( const Output
     Size aRet;
 
     if( GRAPHIC_BITMAP == mpImpGraphic->ImplGetType() )
-        aRet = mpImpGraphic->ImplGetBitmapEx( NULL ).GetSizePixel();
+        aRet = mpImpGraphic->ImplGetBitmapEx( NULL, FALSE ).GetSizePixel();
     else
         aRet = ( pRefDevice ? pRefDevice : Application::GetDefaultDevice() )->LogicToPixel( GetPrefSize(), GetPrefMapMode() );
      
Index: vcl/source/gdi/hatch.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/hatch.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/hatch.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/hatch.cxx	6 Jan 2004 13:40:40 -0000	1.2
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_HATCH_CXX
 
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>

Index: vcl/source/gdi/impanmvw.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impanmvw.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/gdi/impanmvw.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/impanmvw.cxx	6 Jan 2004 13:42:16 -0000	1.3
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_IMPANMVW_CXX
-
 #define private public
 
 #include "impanmvw.hxx"
@@ -78,11 +76,11 @@ ImplAnimView::ImplAnimView( Animation* p
 							OutputDevice* pFirstFrameOutDev ) :
 		mpParent		( pParent ),
 		mpOut			( pFirstFrameOutDev ? pFirstFrameOutDev : pOut ),
+		mnExtraData		( nExtraData ),
 		maPt			( rPt ),
 		maSz			( rSz ),
-		maClip			( mpOut->GetClipRegion() ),
 		maSzPix			( mpOut->LogicToPixel( maSz ) ),
-		mnExtraData		( nExtraData ),
+		maClip			( mpOut->GetClipRegion() ),
 		mpBackground	( new VirtualDevice ),
 		mpRestore		( new VirtualDevice ),
 		meLastDisposal	( DISPOSE_BACK ),
@@ -345,10 +343,8 @@ void ImplAnimView::ImplDraw( ULONG nPos,
 			
 			delete pDev;
 
-#ifndef REMOTE_APPSERVER
 			if( mpOut->GetOutDevType() == OUTDEV_WINDOW )
 				( (Window*) mpOut )->Sync();
-#endif
 		}
 	}
 }
Index: vcl/source/gdi/impbmp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impbmp.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.4
diff -u -p -u -r1.1.1.1 -r1.4
--- vcl/source/gdi/impbmp.cxx	18 Sep 2000 17:05:37 -0000	1.1.1.1
+++ vcl/source/gdi/impbmp.cxx	6 Jan 2004 13:42:38 -0000	1.4
@@ -59,26 +59,19 @@
  *
  ************************************************************************/
 
-#define _SV_IMPBMP_CXX
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
 #ifndef _SV_SALBMP_HXX
 #include <salbmp.hxx>
 #endif
-#else
-#include <indbmp.hxx>
-#ifndef _SV_RMBITMAP_HXX
-#include <rmbitmap.hxx>
-#endif
-#endif
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 #include <impbmp.hxx>
 #include <bitmap.hxx>
+#include <svdata.hxx>
+#include <salinst.hxx>
 
 // --------------
 // - ImpBitmap	-
@@ -88,11 +81,7 @@ ImpBitmap::ImpBitmap() :
 			mnRefCount	( 1UL ),
 			mnChecksum	( 0UL ),
 			mpRMBitmap	( NULL ),
-#ifndef REMOTE_APPSERVER
-			mpSalBitmap ( new SalBitmap )
-#else
-			mpSalBitmap ( new ImplServerBitmap )
-#endif
+			mpSalBitmap ( ImplGetSVData()->mpDefInst->CreateSalBitmap() )
 {
 }
 
@@ -100,18 +89,11 @@ ImpBitmap::ImpBitmap() :
 
 ImpBitmap::~ImpBitmap()
 {
-#ifdef REMOTE_APPSERVER
-	ImplReleaseRemoteBmp();
-#endif
 	delete mpSalBitmap;
 }
 
 // -----------------------------------------------------------------------
-#ifndef REMOTE_APPSERVER
 void ImpBitmap::ImplSetSalBitmap( SalBitmap* pBitmap )
-#else
-void ImpBitmap::ImplSetSalBitmap( ImplServerBitmap* pBitmap )
-#endif
 {
 	delete mpSalBitmap, mpSalBitmap = pBitmap;
 }
@@ -195,115 +164,4 @@ void ImpBitmap::ImplReleaseBuffer( Bitma
 
 	if( !bReadOnly )
 		mnChecksum = 0;
-}
-
-#ifdef REMOTE_APPSERVER
-
-RMBitmap* ImpBitmap::ImplGetRemoteBmp()
-{
-	return mpRMBitmap;
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplCreateRemoteBmp( const Bitmap& rBitmap )
-{
-	DBG_ASSERT( !mpRMBitmap, "ImplCreateRemoteBmp( Bitmap& rBitmap )???" );
-
-	mpRMBitmap = new RMBitmap( &(Bitmap&) rBitmap );
-	mpRMBitmap->Create();
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplCreateRemoteBmp( const Bitmap& rBitmap,
-									 OutputDevice* pOut,
-									 const Point& rPt, const Size& rSz )
-{
-	DBG_ASSERT( !mpRMBitmap, "ImplCreateRemoteBmp( Bitmap& rBitmap )???" );
-
-	mpRMBitmap = new RMBitmap( &(Bitmap&) rBitmap );
-	mpRMBitmap->CreateGet( pOut, rPt, rSz );
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplReleaseRemoteBmp()
-{
-	delete mpRMBitmap;
-	mpRMBitmap = NULL;
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplDrawRemoteBmp( OutputDevice* pOut,
-							const Point& rSrcPt, const Size& rSrcSz,
-							const Point& rDestPt, const Size& rDestSz )
-{
-	if( mpRMBitmap )
-		mpRMBitmap->Draw( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz );
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplDrawRemoteBmpEx( OutputDevice* pOut,
-							const Point& rSrcPt, const Size& rSrcSz,
-							const Point& rDestPt, const Size& rDestSz,
-							const Bitmap& rMask )
-{
-	if( mpRMBitmap )
-		mpRMBitmap->DrawEx( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rMask );
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplDrawRemoteBmpAlpha( OutputDevice* pOut,
-							const Point& rSrcPt, const Size& rSrcSz,
-							const Point& rDestPt, const Size& rDestSz,
-							const AlphaMask& rAlpha )
-{
-	if( mpRMBitmap )
-		mpRMBitmap->DrawAlpha( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rAlpha );
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplDrawRemoteBmpMask( OutputDevice* pOut,
-							const Point& rSrcPt, const Size& rSrcSz,
-							const Point& rDestPt, const Size& rDestSz,
-							const Color& rColor )
-{
-	if( mpRMBitmap )
-		mpRMBitmap->DrawMask( pOut, rSrcPt, rSrcSz, rDestPt, rDestSz, rColor );
-}
-
-// -----------------------------------------------------------------------
-
-BOOL ImpBitmap::ImplIsGetPrepared() const
-{
-	return( mpRMBitmap ? mpRMBitmap->IsGetPrepared() : FALSE );
-}
-
-// -----------------------------------------------------------------------
-
-void ImpBitmap::ImplResolveGet()
-{
-	if( mpRMBitmap )
-	{
-		Bitmap aBmp;
-		mpRMBitmap->Get( aBmp );
-		ImpBitmap* pGetImpBmp = aBmp.ImplGetImpBitmap();
-
-		if( pGetImpBmp )
-		{
-			// wir nehmen der gegetteten Bitmap einfach
-			// die SalBitmap weg; Null-Setzen nicht vergessen,
-			// da die Bitmap die SalBitmap sonst abraeumt
-			delete mpSalBitmap;
-			mpSalBitmap = pGetImpBmp->mpSalBitmap;
-			pGetImpBmp->mpSalBitmap = NULL;
-		}
-	}
-}
-
-#endif
+}
\ No newline at end of file
Index: vcl/source/gdi/impgraph.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impgraph.cxx,v
retrieving revision 1.14
retrieving revision 1.16
diff -u -p -u -r1.14 -r1.16
--- vcl/source/gdi/impgraph.cxx	24 Jun 2003 07:32:48 -0000	1.14
+++ vcl/source/gdi/impgraph.cxx	20 Apr 2004 13:54:19 -0000	1.16
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_IMPGRAPH_CXX
-
 #ifndef _VCOMPAT_HXX
 #include <tools/vcompat.hxx>
 #endif
@@ -166,8 +164,8 @@ ImpGraphic::ImpGraphic() :
 // ------------------------------------------------------------------------
 
 ImpGraphic::ImpGraphic( const ImpGraphic& rImpGraphic ) :
-		maEx			( rImpGraphic.maEx ),
 		maMetaFile		( rImpGraphic.maMetaFile ),
+		maEx			( rImpGraphic.maEx ),
 	    mpContext		( NULL ),
 		mpSwapFile		( rImpGraphic.mpSwapFile ),
 		meType			( rImpGraphic.meType ),
@@ -490,7 +488,7 @@ BOOL ImpGraphic::ImplIsAnimated() const
 
 // ------------------------------------------------------------------------
 
-Bitmap ImpGraphic::ImplGetBitmap( const Size* pSizePixel ) const
+Bitmap ImpGraphic::ImplGetBitmap( const Size* pSizePixel, BOOL bUnlimited ) const
 {
     Bitmap aRetBmp;
 
@@ -523,7 +521,7 @@ Bitmap ImpGraphic::ImplGetBitmap( const 
             aSizePix = *pSizePixel;
         }
 
-		if( aSizePix.Width() && aSizePix.Height() &&
+		if( aSizePix.Width() && aSizePix.Height() && !bUnlimited &&
 			( aSizePix.Width() > GRAPHIC_MTFTOBMP_MAXEXT || aSizePix.Height() > GRAPHIC_MTFTOBMP_MAXEXT ) )
 		{
 			const Size  aOldSizePix( aSizePix );
@@ -556,7 +554,7 @@ Bitmap ImpGraphic::ImplGetBitmap( const 
 
 // ------------------------------------------------------------------------
 
-BitmapEx ImpGraphic::ImplGetBitmapEx( const Size* pSizePixel ) const
+BitmapEx ImpGraphic::ImplGetBitmapEx( const Size* pSizePixel, BOOL bUnlimited ) const
 {
     BitmapEx aRetBmpEx;
 
@@ -570,7 +568,7 @@ BitmapEx ImpGraphic::ImplGetBitmapEx( co
     else if( ( meType != GRAPHIC_DEFAULT ) && ImplIsSupportedGraphic() )
     {
 		const ImpGraphic aMonoMask( maMetaFile.GetMonochromeMtf( COL_BLACK ) );
-		aRetBmpEx = BitmapEx( ImplGetBitmap( pSizePixel ), aMonoMask.ImplGetBitmap( pSizePixel ) );
+		aRetBmpEx = BitmapEx( ImplGetBitmap( pSizePixel, bUnlimited ), aMonoMask.ImplGetBitmap( pSizePixel, bUnlimited ) );
     }
 
     return aRetBmpEx;
@@ -1147,7 +1145,6 @@ BOOL ImpGraphic::ImplWriteEmbedded( SvSt
 		const MapMode	aMapMode( ImplGetPrefMapMode() );
 		const Size		aSize( ImplGetPrefSize() );
 		const USHORT	nOldFormat = rOStm.GetNumberFormatInt();
-		const ULONG		nStmPos1 = rOStm.Tell();
 		ULONG			nDataFieldPos;
 
 		rOStm.SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
Index: vcl/source/gdi/implncvt.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/implncvt.cxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/source/gdi/implncvt.cxx	27 Mar 2003 17:57:57 -0000	1.2
+++ vcl/source/gdi/implncvt.cxx	6 Jan 2004 13:44:03 -0000	1.3
@@ -134,11 +134,11 @@ ImplFloatPoint ImplFloatPoint::GetNVec( 
 // --------------------
 
 ImplLineConverter::ImplLineConverter( const Polygon& rPolygon, const LineInfo& rLineInfo, const Point* pRefPoint ) :
-	maLineInfo		( rLineInfo ),
 	mfWidthHalf		( rLineInfo.GetWidth() >> 1 ),
-	mpFloatPoint	( NULL ),
+	maLineInfo		( rLineInfo ),
 	mpFloat0		( new ImplFloatPoint[ 6 ] ),
 	mpFloat1		( new ImplFloatPoint[ 6 ] ),
+	mpFloatPoint	( NULL ),
 	mnLines			( 0 )
 {
 	UINT16	nIndex, nPolySize = rPolygon.GetSize();
@@ -249,7 +249,6 @@ const Polygon* ImplLineConverter::ImplGe
 				INT32 nDashLen = maLineInfo.GetDashLen() + nDistance;
 				INT32 nDashesLen = maLineInfo.GetDashCount() * nDashLen;
 				INT32 nDotLen = maLineInfo.GetDotLen() + nDistance;
-				INT32 nDotsLen = maLineInfo.GetDotCount() * nDotLen;
 
 				if ( mnRefDistance >= nDashesLen )
 				{
Index: vcl/source/gdi/implncvt.hxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/implncvt.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/implncvt.hxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/implncvt.hxx	6 Jan 2004 13:44:27 -0000	1.2
@@ -62,8 +62,8 @@
 #ifndef _SV_LINECONV_HXX
 #define _SV_LINECONV_HXX
 
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_LINEINFO_HXX
 #include <lineinfo.hxx>
Index: vcl/source/gdi/impprn.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impprn.cxx,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -p -u -r1.5 -r1.7
--- vcl/source/gdi/impprn.cxx	27 Mar 2003 17:57:57 -0000	1.5
+++ vcl/source/gdi/impprn.cxx	6 Jan 2004 13:44:52 -0000	1.7
@@ -59,9 +59,6 @@
  *
  ************************************************************************/
 
-#ifndef REMOTE_APPSERVER
-
-#define _SV_IMPPRN_CXX
 #define _SPOOLPRINTER_EXT
 
 #ifndef _QUEUE_HXX
@@ -150,8 +147,6 @@ void ImplQPrinter::Destroy()
 
 void ImplQPrinter::ImplPrintMtf( GDIMetaFile& rMtf, long nMaxBmpDPIX, long nMaxBmpDPIY )
 {
-    const PrinterOptions& rPrinterOptions = GetPrinterOptions();
-
 	for( MetaAction* pAct = rMtf.FirstAction(); pAct && !mbAborted; pAct = rMtf.NextAction() )
 	{
 		const ULONG		nType = pAct->GetType();
@@ -191,8 +186,6 @@ void ImplQPrinter::ImplPrintMtf( GDIMeta
 
 				if( pAct && ( pAct->GetType() == META_BMPSCALE_ACTION ) )
 				{
-                    MetaBmpScaleAction* pBmpScaleAction = (MetaBmpScaleAction*) pAct;
-
                     // execute action here to avoid DPI processing of bitmap;
                     pAct->Execute( this );
 
@@ -403,8 +396,6 @@ IMPL_LINK( ImplQPrinter, ImplPrintHdl, T
 
 		for ( USHORT i = 0; i < nCopyCount; i++ )
 		{
-			ULONG nActionPos = 0UL;
-
 			if ( pActPage->mpSetup )
 			{
 				SetJobSetup( *pActPage->mpSetup );
@@ -476,5 +467,3 @@ void ImplQPrinter::AddQueuePage( GDIMeta
 		pQueuePage->mpSetup = new JobSetup( mpParent->GetJobSetup() );
 	mpQueue->Put( pQueuePage );
 }
-
-#endif
Index: vcl/source/gdi/impvect.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impvect.cxx,v
retrieving revision 1.3.120.1
retrieving revision 1.5
diff -u -p -u -r1.3.120.1 -r1.5
--- vcl/source/gdi/impvect.cxx	15 Jan 2004 14:03:27 -0000	1.3.120.1
+++ vcl/source/gdi/impvect.cxx	2 Mar 2004 10:35:43 -0000	1.5
@@ -59,15 +59,13 @@
  *
  ************************************************************************/
 
-#define _SV_IMPVECT_CXX
-
 #include <stdlib.h>
 #include <tools/new.hxx>
 #ifndef _SV_BMPACC_HXX
 #include <bmpacc.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_GDIMTF_HXX
 #include <gdimtf.hxx>
@@ -88,19 +86,6 @@
 #include <impvect.hxx>
 #endif
 
-// !!! ggf. einkommentieren, um Bitmaps zu erzeugen (nur, wenn File mit Debug uebersetzt wurde)
-// #define DEBUG_BMPOUTPUT
-
-#if (OSL_DEBUG_LEVEL > 1) && defined DEBUG_BMPOUTPUT
-#define DBG_BMP 1
-#else
-#undef	DBG_BMP
-#endif
-
-#ifdef DBG_BMP
-#include <tools/stream.hxx>
-#endif
-
 // -----------
 // - Defines -
 // -----------
@@ -221,15 +206,9 @@ extern "C" int __LOADONCALLAPI ImplColor
 // - ImplPointArray -
 // ------------------
 
-#ifdef WIN
-typedef Point* huge HPPoint;
-#else
-typedef Point*		HPPoint;
-#endif
-
 class ImplPointArray
 {
-	HPPoint				mpArray;
+	Point*				mpArray;
 	ULONG				mnSize;
 	ULONG				mnRealSize;
 
@@ -252,9 +231,9 @@ public:
 // -----------------------------------------------------------------------------
 
 ImplPointArray::ImplPointArray() :
+	mpArray		( NULL ),
 	mnSize		( 0UL ),
-	mnRealSize	( 0UL ),
-	mpArray		( NULL )
+	mnRealSize	( 0UL )
 
 {
 }
@@ -279,8 +258,8 @@ void ImplPointArray::ImplSetSize( ULONG 
 	if( mpArray )
 		SvMemFree( mpArray );
 
-	mpArray = (HPPoint) SvMemAlloc( nTotal );
-	HMEMSET( (HPBYTE) mpArray, 0, nTotal );
+	mpArray = (Point*) SvMemAlloc( nTotal );
+	memset( (HPBYTE) mpArray, 0, nTotal );
 }
 
 // -----------------------------------------------------------------------------
@@ -336,9 +315,6 @@ public:
 	inline BOOL		IsCont( long nY, long nX ) const;
 	inline BOOL		IsDone( long nY, long nX ) const;
 
-#ifdef DBG_BMP
-	Bitmap			GetBitmap() const;
-#endif // DBG_BMP
 };
 
 // -----------------------------------------------------------------------------
@@ -351,7 +327,7 @@ ImplVectMap::ImplVectMap( long nWidth, l
 	const long	nSize = nWidthAl * nHeight;
 	Scanline	pTmp = mpBuf = (Scanline) SvMemAlloc( nSize );
 
-	HMEMSET( mpBuf, 0, nSize );
+	memset( mpBuf, 0, nSize );
 	mpScan = (Scanline*) SvMemAlloc( nHeight * sizeof( Scanline ) );
 
 	for( long nY = 0L; nY < nHeight; pTmp += nWidthAl )
@@ -403,36 +379,6 @@ inline BOOL ImplVectMap::IsDone( long nY
 	return( VECT_DONE_INDEX == Get( nY, nX ) );
 }
 
-// -----------------------------------------------------------------------------
-
-#ifdef DBG_BMP
-Bitmap ImplVectMap::GetBitmap() const
-{
-	Bitmap				aBmp( Size( mnWidth, mnHeight ), 4 );
-	BitmapWriteAccess*	pAcc = aBmp.AcquireWriteAccess();
-
-	if( pAcc )
-	{
-		for( long nY = 0L; nY < mnHeight; nY++ )
-		{
-			for( long nX = 0L; nX < mnWidth; nX++ )
-			{
-				switch( Get( nY, nX ) )
-				{
-					case( VECT_FREE_INDEX ): pAcc->SetPixel( nY, nX, 15 ); break;
-					case( VECT_CONT_INDEX ): pAcc->SetPixel( nY, nX, 0 ); break;
-					case( VECT_DONE_INDEX ): pAcc->SetPixel( nY, nX, 2); break;
-				}
-			}
-		}
-
-		aBmp.ReleaseAccess( pAcc );
-	}
-
-	return aBmp;
-}
-#endif // DBG_BMP
-
 // -------------
 // - ImplChain -
 // -------------
@@ -470,8 +416,8 @@ public:
 // -----------------------------------------------------------------------------
 
 ImplChain::ImplChain( ULONG nInitCount, long nResize ) :
-	mnCount		( 0UL ),
 	mnArraySize	( nInitCount ),
+	mnCount		( 0UL ),
 	mnResize	( nResize )
 {
 	DBG_ASSERT( nInitCount && nResize, "ImplChain::ImplChain(): invalid parameters!" );
@@ -494,7 +440,7 @@ void ImplChain::ImplGetSpace()
 
 	mnArraySize = ( mnResize < 0L ) ? ( mnArraySize << 1UL ) : ( mnArraySize + (ULONG) mnResize );
 	pNewCodes = new BYTE[ mnArraySize ];
-	HMEMCPY( pNewCodes, mpCodes, nOldArraySize );
+	memcpy( pNewCodes, mpCodes, nOldArraySize );
 	delete[] mpCodes;
 	mpCodes = pNewCodes;
 }
@@ -542,7 +488,7 @@ void ImplChain::ImplEndAdd( ULONG nFlag 
 				const BYTE				cNextMove = mpCodes[ i + 1 ];
 				const ChainMove&		rMove = aImplMove[ cMove ];
 				const ChainMove&		rMoveInner = aImplMoveInner[ cMove ];
-				Point&					rPt = aArr[ nPolyPos ];
+//				Point&					rPt = aArr[ nPolyPos ];
 				BOOL					bDone = TRUE;
 
 				nLastX += rMove.nDX;
@@ -649,7 +595,7 @@ void ImplChain::ImplEndAdd( ULONG nFlag 
 				const BYTE				cNextMove = mpCodes[ i + 1 ];
 				const ChainMove&		rMove = aImplMove[ cMove ];
 				const ChainMove&		rMoveOuter = aImplMoveOuter[ cMove ];
-				Point&					rPt = aArr[ nPolyPos ];
+//				Point&					rPt = aArr[ nPolyPos ];
 				BOOL					bDone = TRUE;
 
 				nLastX += rMove.nDX;
@@ -889,7 +835,7 @@ BOOL ImplVectorizer::ImplVectorize( cons
 		{
 			const BitmapColor	aBmpCol( pRAcc->GetPaletteColor( pColorSet[ i ].mnIndex ) );
 			const Color			aFindColor( aBmpCol.GetRed(), aBmpCol.GetGreen(), aBmpCol.GetBlue() );
-			const BYTE			cLum = aFindColor.GetLuminance();
+//			const BYTE			cLum = aFindColor.GetLuminance();
 			ImplVectMap*		pMap = ImplExpand( pRAcc, aFindColor );
 
 			VECT_PROGRESS( pProgress, FRound( fPercent += fPercentStep_2 ) );
@@ -977,7 +923,7 @@ BOOL ImplVectorizer::ImplVectorize( cons
 		if( nFlags & BMP_VECTORIZE_REDUCE_EDGES )
 			rPolyPoly.Optimize( POLY_OPTIMIZE_EDGES );
 
-        // #i14895:setting the correct direction for polygons
+        // #i14895#:setting the correct direction for polygons
         // that represent holes and non-holes; non-hole polygons
         // need to have a right orientation, holes need to have a
         // left orientation in order to be treated correctly by
@@ -1172,14 +1118,6 @@ void ImplVectorizer::ImplCalculate( Impl
 {
 	const long nWidth = pMap->Width(), nHeight= pMap->Height();
 
-#ifdef DBG_BMP
-	if( pMap )
-	{
-		SvFileStream aOStm( "d:\\cont.bmp", STREAM_WRITE | STREAM_TRUNC );
-		aOStm << pMap->GetBitmap();
-	}
-#endif // DBG_BMP
-
 	for( long nY = 0L; nY < nHeight; nY++ )
 	{
 		long	nX = 0L;
@@ -1241,14 +1179,6 @@ void ImplVectorizer::ImplCalculate( Impl
 			}
 		}
 	}
-
-#ifdef DBG_BMP
-	if( pMap )
-	{
-		SvFileStream aOStm( "d:\\vect.bmp", STREAM_WRITE | STREAM_TRUNC );
-		aOStm << pMap->GetBitmap();
-	}
-#endif // DBG_BMP
 }
 
 // -----------------------------------------------------------------------------
Index: vcl/source/gdi/impvect.hxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/impvect.hxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/impvect.hxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/impvect.hxx	6 Jan 2004 13:45:39 -0000	1.2
@@ -62,8 +62,8 @@
 #ifndef _SV_IMPVECT_HXX
 #define _SV_IMPVECT_HXX
 
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_GDIMTF_HXX
 #include <gdimtf.hxx>
Index: vcl/source/gdi/jobset.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/jobset.cxx,v
retrieving revision 1.7
retrieving revision 1.8
diff -u -p -u -r1.7 -r1.8
--- vcl/source/gdi/jobset.cxx	19 Jun 2002 11:20:42 -0000	1.7
+++ vcl/source/gdi/jobset.cxx	6 Jan 2004 13:46:09 -0000	1.8
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_JOBSET_CXX
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
Index: vcl/source/gdi/lineinfo.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/lineinfo.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/lineinfo.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/lineinfo.cxx	6 Jan 2004 13:46:37 -0000	1.2
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_LINEINFO_CXX
 
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
Index: vcl/source/gdi/mapmod.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/mapmod.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/gdi/mapmod.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/mapmod.cxx	17 Mar 2004 10:04:58 -0000	1.3
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_MAPMOD_CXX
-
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
 #endif
@@ -137,12 +135,11 @@ SvStream& operator<<( SvStream& rOStm, c
 
 static ImplMapMode* ImplGetStaticMapMode( MapUnit eUnit )
 {
-    // Achtung: Ganz fies und dreckig !!!
-#ifdef WIN
-    static long _near aStaticImplMapModeAry[(MAP_LASTENUMDUMMY)*sizeof(ImplMapMode)/sizeof(long)];
-#else
     static long aStaticImplMapModeAry[(MAP_LASTENUMDUMMY)*sizeof(ImplMapMode)/sizeof(long)];
-#endif
+
+    // #i19496 check for out-of-bounds
+     if( eUnit >= MAP_LASTENUMDUMMY )
+        return (ImplMapMode*)aStaticImplMapModeAry;
 
     ImplMapMode* pImplMapMode = ((ImplMapMode*)aStaticImplMapModeAry)+eUnit;
     if ( !pImplMapMode->mbSimple )
Index: vcl/source/gdi/metaact.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/metaact.cxx,v
retrieving revision 1.11.112.1
retrieving revision 1.14
diff -u -p -u -r1.11.112.1 -r1.14
--- vcl/source/gdi/metaact.cxx	9 Jan 2004 18:13:44 -0000	1.11.112.1
+++ vcl/source/gdi/metaact.cxx	17 Jun 2004 12:17:25 -0000	1.14
@@ -59,7 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_METAACT_CXX
 #define ENABLE_BYTESTRING_STREAM_OPERATORS
 
 #include <algorithm>
@@ -1364,8 +1363,8 @@ MetaTextArrayAction::MetaTextArrayAction
 	{
 		const ULONG nAryLen = mnLen;
 
-		mpDXAry = new long[ nAryLen ];
-		memcpy( mpDXAry, rAction.mpDXAry, nAryLen * sizeof( long ) );
+		mpDXAry = new sal_Int32[ nAryLen ];
+		memcpy( mpDXAry, rAction.mpDXAry, nAryLen * sizeof( sal_Int32 ) );
 	}
 	else
 		mpDXAry = NULL;
@@ -1375,7 +1374,7 @@ MetaTextArrayAction::MetaTextArrayAction
 
 MetaTextArrayAction::MetaTextArrayAction( const Point& rStartPt,
 										  const XubString& rStr,
-										  const long* pDXAry,
+										  const sal_Int32* pDXAry,
 										  USHORT nIndex,
 										  USHORT nLen ) :
 	MetaAction	( META_TEXTARRAY_ACTION ),
@@ -1388,8 +1387,8 @@ MetaTextArrayAction::MetaTextArrayAction
 
 	if( nAryLen )
 	{
-		mpDXAry = new long[ nAryLen ];
-		memcpy( mpDXAry, pDXAry, nAryLen * sizeof( long ) );
+		mpDXAry = new sal_Int32[ nAryLen ];
+		memcpy( mpDXAry, pDXAry, nAryLen * sizeof( sal_Int32 ) );
 	}
 	else
 		mpDXAry = NULL;
@@ -1492,8 +1491,8 @@ void MetaTextArrayAction::Read( SvStream
 	if( nAryLen )
 	{
         // #i9762#, #106172# Ensure that DX array is at least mnLen entries long
-        const ULONG nIntAryLen( ::std::max(nAryLen, static_cast<ULONG>(mnLen)) );
-		mpDXAry = new long[ nIntAryLen ];
+        const ULONG nIntAryLen( Max(nAryLen, static_cast<ULONG>(mnLen)) );
+		mpDXAry = new sal_Int32[ nIntAryLen ];
         
         ULONG i;
 		for( i = 0UL; i < nAryLen; i++ )
@@ -3964,7 +3963,7 @@ void MetaCommentAction::ImplInitDynamicD
 	if ( nDataSize && pData )
 	{
 		mnDataSize = nDataSize, mpData = new BYTE[ mnDataSize ];
-		HMEMCPY( mpData, pData, mnDataSize );
+		memcpy( mpData, pData, mnDataSize );
 	}
 	else
 	{
Index: vcl/source/gdi/octree.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/octree.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/octree.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/octree.cxx	6 Jan 2004 13:48:20 -0000	1.2
@@ -70,16 +70,6 @@
 #endif
 #include <octree.hxx>
 
-// ------------
-// - Typedefs -
-// ------------
-
-#ifdef WIN
-typedef ULONG huge* HPULONG;
-#else
-typedef ULONG*      HPULONG;
-#endif
-
 // ---------
 // - pMask -
 // ---------
@@ -345,13 +335,11 @@ void Octree::GetPalIndex( PNODE pNode )
 InverseColorMap::InverseColorMap( const BitmapPalette& rPal ) :
             nBits( 8 - OCTREE_BITS )
 {
-    HPULONG         cdp;
+    ULONG*			cdp;
     BYTE*           crgbp;
     const ULONG     nColorMax = 1 << OCTREE_BITS;
     const ULONG     xsqr = 1 << ( nBits << 1 );
     const ULONG     xsqr2 = xsqr << 1;
-    const ULONG     gstride =  nColorMax;
-    const ULONG     rstride = nColorMax * nColorMax;
     const ULONG     nColors = rPal.GetEntryCount();
     const long      x = 1L << nBits;
     const long      x2 = x >> 1L;
@@ -378,7 +366,7 @@ InverseColorMap::InverseColorMap( const 
         cginc = ( xsqr - ( cGreen << nBits ) ) << 1L;
         cbinc = ( xsqr - ( cBlue << nBits ) ) << 1L;
 
-        cdp = (HPULONG) pBuffer;
+        cdp = (ULONG*) pBuffer;
         crgbp = pMap;
 
         for( r = 0, rxx = crinc; r < nColorMax; rdist += rxx, r++, rxx += xsqr2 )
@@ -412,8 +400,8 @@ void InverseColorMap::ImplCreateBuffers(
     const ULONG nSize = nCount * sizeof( ULONG );
 
     pMap = (BYTE*) SvMemAlloc( nCount );
-    HMEMSET( pMap, 0x00, nCount );
+    memset( pMap, 0x00, nCount );
 
     pBuffer = (BYTE*) SvMemAlloc( nSize );
-    HMEMSET( pBuffer, 0xff, nSize );
+    memset( pBuffer, 0xff, nSize );
 }
Index: vcl/source/gdi/opengl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/opengl.cxx,v
retrieving revision 1.5
retrieving revision 1.8
diff -u -p -u -r1.5 -r1.8
--- vcl/source/gdi/opengl.cxx	28 Apr 2003 17:09:40 -0000	1.5
+++ vcl/source/gdi/opengl.cxx	6 Jan 2004 13:48:43 -0000	1.8
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_OPENGL_CXX
-
 #define private public
 #include <svsys.h>
 #include <window.hxx>
@@ -79,6 +77,12 @@
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
+#ifndef _SV_SVDATA_HXX
+#include <svdata.hxx>
+#endif
+#ifndef _SV_SALINST_HXX
+#include <salinst.hxx>
+#endif
 
 
 #include <svapp.hxx>
@@ -88,9 +92,7 @@
 // - Defines -
 // -----------
 
-#ifdef WIN
-#define __OPENGL_CALL _far _pascal
-#elif defined WNT
+#ifdef WNT
 #define __OPENGL_CALL __stdcall
 #else
 #define __OPENGL_CALL
@@ -190,11 +192,7 @@ typedef void ( __OPENGL_CALL *OGLFncBlen
 
 #define PGRAPHICS mpOutDev->mpGraphics
 
-#ifndef REMOTE_APPSERVER
 #define OGL_INIT() (mpOGL && (mpOutDev->mpGraphics || mpOutDev->ImplGetGraphics()))
-#else
-#define OGL_INIT() (mpOGL && (mpOutDev->mpGraphics || mpOutDev->ImplGetGraphics()))
-#endif
 
 #define INIT_OGLFNC( FncName ) static OGLFnc##FncName pImplOpenGLFnc##FncName = NULL;
 #define GET_OGLFNC_GL( FncName )													\
@@ -297,7 +295,6 @@ INIT_OGLFNC( BlendFunc );
 
 BOOL OpenGL::ImplInitFncPointers()
 {
-#ifndef REMOTE_APPSERVER
 	BOOL bRet = TRUE;
 
 	GET_OGLFNC_GL( ClearDepth );
@@ -387,9 +384,6 @@ BOOL OpenGL::ImplInitFncPointers()
 	GET_OGLFNC_GL( BlendFunc );
 
 	return bRet;
-#else
-	return FALSE;
-#endif
 }
 
 BOOL OpenGL::mbNoOGL = FALSE;
@@ -406,22 +400,18 @@ OpenGL::OpenGL( OutputDevice* pOutDev ) 
 
 OpenGL::~OpenGL()
 {
-#ifndef REMOTE_APPSERVER
 	delete mpOGL;
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::ImplInit()
 {
-#ifndef REMOTE_APPSERVER
 	if( ( PGRAPHICS || mpOutDev->ImplGetGraphics() ) && ! mbNoOGL )
 	{
-		mpOGL = new SalOpenGL( PGRAPHICS );
+		mpOGL = ImplGetSVData()->mpDefInst->CreateSalOpenGL( PGRAPHICS );
 
-		if ( !mpOGL->Create() || (!bImplOpenGLFncPtrInitialized && !ImplInitFncPointers()) )
+		if ( !mpOGL->IsValid() || (!bImplOpenGLFncPtrInitialized && !ImplInitFncPointers()) )
 		{
 			delete mpOGL;
 			mpOGL = NULL;
@@ -431,133 +421,105 @@ void OpenGL::ImplInit()
 	}
 	else
 		mpOGL = NULL;
-#else
-	mpOGL = NULL;
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::SetConnectOutputDevice( OutputDevice* pOutDev )
 {
-#ifndef REMOTE_APPSERVER
 	delete mpOGL;
 	mpOutDev = pOutDev;
 	ImplInit();
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::ClearDepth( GLclampd fDepth )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncClearDepth( fDepth );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DepthFunc( GLenum eFunc )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDepthFunc( eFunc );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Enable( GLenum eCap )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncEnable( eCap );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Disable( GLenum eCap )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDisable( eCap );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DepthMask( GLboolean bFlag )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDepthMask( bFlag );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::ShadeModel( GLenum eMode )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncShadeModel( eMode );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::EdgeFlag( GLboolean bFlag )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncEdgeFlag( bFlag );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Clear( GLbitfield nMask )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 #if defined UNX && ! defined MACOSX
@@ -567,30 +529,24 @@ void OpenGL::Clear( GLbitfield nMask )
 		pImplOpenGLFncClear( nMask );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Flush()
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncFlush();
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Finish()
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
@@ -600,15 +556,12 @@ void OpenGL::Finish()
 #endif
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Viewport( GLint nX, GLint nY, GLsizei nWidth, GLsizei nHeight )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		long nOutHeight;
@@ -625,7 +578,7 @@ void OpenGL::Viewport( GLint nX, GLint n
         {
             long lx = nX + mpOutDev->mnOutOffX;
             long lwidth = nWidth;
-            ((SalGraphicsLayout*)mpOutDev->mpGraphics)->mirror( lx, lwidth, mpOutDev );
+            mpOutDev->mpGraphics->mirror( lx, lwidth, mpOutDev );
             nX = lx - mpOutDev->mnOutOffX;
         }
 		pImplOpenGLFncViewport( nX + mpOutDev->mnOutOffX,
@@ -634,549 +587,438 @@ void OpenGL::Viewport( GLint nX, GLint n
 
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Begin( GLenum eMode )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncBegin( eMode );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::End()
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncEnd();
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Vertex3dv( const GLdouble* fVar )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncVertex3dv( fVar );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Normal3dv( const GLdouble* fVar )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncNormal3dv( fVar );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Color4ub( GLubyte cRed, GLubyte cGreen, GLubyte cBlue, GLubyte cAlpha )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncColor4ub( cRed, cGreen, cBlue, cAlpha );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Materialfv( GLenum eFace, GLenum ePName, const GLfloat *fParams )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncMaterialfv( eFace, ePName, fParams );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Materialf( GLenum eFace, GLenum ePName, GLfloat fParam )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncMaterialf( eFace, ePName, fParam );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::LightModelfv( GLenum ePName, const GLfloat *fParams )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLightModelfv( ePName, fParams );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::LightModelf( GLenum ePName, GLfloat fParam )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLightModelf( ePName, fParam );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Lightfv( GLenum eLight, GLenum ePName, const GLfloat *fParams )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLightfv( eLight, ePName, fParams );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Lightf( GLenum eLight, GLenum ePName, GLfloat fParam )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLightf( eLight, ePName, fParam );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PolygonMode( GLenum eFace, GLenum eMode )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPolygonMode( eFace, eMode );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::CullFace( GLenum eMode )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncCullFace( eMode );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PointSize( GLfloat fSize )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPointSize( fSize );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::LineWidth( GLfloat fWidth )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLineWidth( fWidth );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::MatrixMode( GLenum eMode )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncMatrixMode( eMode );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::LoadMatrixd( const GLdouble *fM )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLoadMatrixd( fM );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexCoord2dv( const GLdouble *pParams )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexCoord2dv( pParams );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexCoord3dv( const GLdouble *fVar )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexCoord3dv( fVar );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexImage1D( GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexImage1D( target, level, internalformat, width, border, format, type, pixels );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexImage2D( GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexImage2D( target, level, internalformat, width, height, border, format, type, pixels );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::CopyTexImage1D( GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncCopyTexImage1D( target, level, internalFormat, x, y, width, border );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::CopyTexImage2D( GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncCopyTexImage2D( target, level, internalFormat, x, y, width, height, border );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::CopyTexSubImage1D( GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncCopyTexSubImage1D( target, level, xoffset, x, y, width );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::CopyTexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncCopyTexSubImage2D( target, level, xoffset, yoffset, x, y, width, height );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PixelTransferf( GLenum pname, GLfloat param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPixelTransferf( pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PixelTransferi( GLenum pname, GLint param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPixelTransferi( pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GetTexLevelParameterfv( GLenum target, GLint level, GLenum pname, GLfloat *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGetTexLevelParameterfv( target, level, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GetTexLevelParameteriv( GLenum target, GLint level, GLenum pname, GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGetTexLevelParameteriv( target, level, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GetTexParameterfv( GLenum target, GLenum pname, GLfloat *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGetTexParameterfv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GetTexParameteriv( GLenum target, GLenum pname, GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGetTexParameteriv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexSubImage1D( GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexSubImage1D( target, level, xoffset, width, format, type, pixels );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexSubImage2D( GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexSubImage2D( target, level, xoffset, yoffset, width, height, format, type, pixels );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PixelStoref( GLenum pname, GLfloat param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPixelStoref( pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PixelStorei( GLenum pname, GLint param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPixelStorei( pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GenTextures( GLsizei n, GLuint *textures )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGenTextures( n, textures );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
@@ -1185,16 +1027,12 @@ GLboolean OpenGL::IsTexture( GLuint text
 {
 	GLboolean bRet = FALSE;
 
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		bRet = pImplOpenGLFncIsTexture( texture );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
-
 	return bRet;
 }
 
@@ -1202,30 +1040,24 @@ GLboolean OpenGL::IsTexture( GLuint text
 
 void OpenGL::BindTexture( GLenum target, GLuint texture )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncBindTexture( target, texture );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DeleteTextures( GLsizei n, const GLuint *textures )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDeleteTextures( n, textures );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
@@ -1233,17 +1065,12 @@ void OpenGL::DeleteTextures( GLsizei n, 
 GLboolean OpenGL::AreTexturesResident( GLsizei n, const GLuint *textures, GLboolean *residences )
 {
 	GLboolean bRet = FALSE;
-
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		bRet = pImplOpenGLFncAreTexturesResident( n, textures, residences );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
-
 	return bRet;
 }
 
@@ -1251,262 +1078,210 @@ GLboolean OpenGL::AreTexturesResident( G
 
 void OpenGL::PrioritizeTextures( GLsizei n, const GLuint *textures, const GLclampf *priorities )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPrioritizeTextures( n, textures, priorities );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexEnvf( GLenum target, GLenum pname, GLfloat param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexEnvf( target, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexEnvfv( GLenum target, GLenum pname, const GLfloat *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexEnvfv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexEnvi( GLenum target, GLenum pname, GLint param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexEnvi( target, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexEnviv( GLenum target, GLenum pname, const GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexEnviv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexParameterf( GLenum target, GLenum pname, GLfloat param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexParameterf( target, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexParameterfv( GLenum target, GLenum pname, const GLfloat *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexParameterfv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexParameteri( GLenum target, GLenum pname, GLint param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexParameteri( target, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexParameteriv( GLenum target, GLenum pname, const GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexParameteriv( target, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGend( GLenum coord, GLenum pname, GLdouble param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGend( coord, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGendv( GLenum coord, GLenum pname, const GLdouble *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGendv( coord, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGenf( GLenum coord, GLenum pname, GLfloat param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGenf( coord, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGenfv( GLenum coord, GLenum pname, const GLfloat *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGenfv( coord, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGeni( GLenum coord, GLenum pname, GLint param )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGeni( coord, pname, param );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexGeniv( GLenum coord, GLenum pname, const GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexGeniv( coord, pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::GetIntegerv( GLenum pname, GLint *params )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncGetIntegerv( pname, params );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::PolygonOffset( GLfloat factor, GLfloat units )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncPolygonOffset( factor, units );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::Scissor( GLint nX, GLint nY, GLsizei nWidth, GLsizei nHeight )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		long nOutHeight;
@@ -1523,7 +1298,7 @@ void OpenGL::Scissor( GLint nX, GLint nY
         {
             long lx = nX + mpOutDev->mnOutOffX;
             long lwidth = nWidth;
-            ((SalGraphicsLayout*)mpOutDev->mpGraphics)->mirror( lx, lwidth, mpOutDev );
+            mpOutDev->mpGraphics->mirror( lx, lwidth, mpOutDev );
             nX = lx - mpOutDev->mnOutOffX;
         }
 		pImplOpenGLFncScissor( nX + mpOutDev->mnOutOffX,
@@ -1531,217 +1306,173 @@ void OpenGL::Scissor( GLint nX, GLint nY
 					 nWidth, nHeight );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::EnableClientState( GLenum array )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncEnableClientState( array );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DisableClientState( GLenum array )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDisableClientState( array );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::VertexPointer( GLint size, GLenum type, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncVertexPointer( size, type, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::ColorPointer( GLint size, GLenum type, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncColorPointer( size, type, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::IndexPointer( GLenum type, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncIndexPointer( type, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::NormalPointer( GLenum type, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncNormalPointer( type, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::TexCoordPointer( GLint size, GLenum type, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncTexCoordPointer( size, type, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::EdgeFlagPointer( GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncEdgeFlagPointer( stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::ArrayElement( GLint i )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncArrayElement( i );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DrawElements( GLenum mode, GLsizei count, GLenum type, const GLvoid *indices )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDrawElements( mode, count, type, indices );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::DrawArrays( GLenum mode, GLint first, GLsizei count )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncDrawArrays( mode, first, count );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::InterleavedArrays( GLenum format, GLsizei stride, const GLvoid *pointer )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncInterleavedArrays( format, stride, pointer );
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::LoadIdentity( )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncLoadIdentity();
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
 // ------------------------------------------------------------------------
 
 void OpenGL::BlendFunc( GLenum sfactor, GLenum dfactor )
 {
-#ifndef REMOTE_APPSERVER
 	if( OGL_INIT() )
 	{
 		mpOGL->OGLEntry( PGRAPHICS );
 		pImplOpenGLFncBlendFunc( sfactor, dfactor);
 		mpOGL->OGLExit( PGRAPHICS );
 	}
-#else
-#endif
 }
 
Index: vcl/source/gdi/outdev.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev.cxx,v
retrieving revision 1.23
retrieving revision 1.29
diff -u -p -u -r1.23 -r1.29
--- vcl/source/gdi/outdev.cxx	24 Apr 2003 10:27:08 -0000	1.23
+++ vcl/source/gdi/outdev.cxx	3 Feb 2004 16:45:04 -0000	1.29
@@ -59,15 +59,10 @@
  *
  ************************************************************************/
 
-#define _SV_OUTDEV_CXX
 #include <tools/ref.hxx>
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
@@ -83,12 +78,6 @@
 #ifndef _SV_SALPRN_HXX
 #include <salprn.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -153,8 +142,8 @@
 #include <com/sun/star/awt/XGraphics.hpp>
 
 DBG_NAME( OutputDevice );
-DBG_NAMEEX( Polygon );
-DBG_NAMEEX( PolyPolygon );
+DBG_NAME( Polygon );
+DBG_NAME( PolyPolygon );
 DBG_NAMEEX( Region );
 
 // -----------------------------------------------------------------------
@@ -184,19 +173,21 @@ const char* ImplDbgCheckOutputDevice( co
 
 struct ImplObjStack
 {
-	ImplObjStack*	mpPrev;
-	MapMode*		mpMapMode;
-	Region* 		mpClipRegion;
-	Color*			mpLineColor;
-	Color*			mpFillColor;
-	Font*			mpFont;
-	Color*			mpTextColor;
-	Color*			mpTextFillColor;
-	Color*			mpTextLineColor;
-	Point*			mpRefPoint;
-	TextAlign		meTextAlign;
-	RasterOp		meRasterOp;
-	USHORT			mnFlags;
+    ImplObjStack*   mpPrev;
+    MapMode*        mpMapMode;
+    Region*         mpClipRegion;
+    Color*          mpLineColor;
+    Color*          mpFillColor;
+    Font*           mpFont;
+    Color*          mpTextColor;
+    Color*          mpTextFillColor;
+    Color*          mpTextLineColor;
+    Point*          mpRefPoint;
+    TextAlign       meTextAlign;
+    RasterOp        meRasterOp;
+    ULONG           mnTextLayoutMode;
+    LanguageType    meTextLanguage;
+    USHORT          mnFlags;
 };
 
 // -----------------------------------------------------------------------
@@ -248,7 +239,6 @@ static void ImplDeleteObjStack( ImplObjS
 
 // -----------------------------------------------------------------------
 
-#ifndef REMOTE_APPSERVER
 
 BOOL OutputDevice::ImplSelectClipRegion( SalGraphics* pGraphics, const Region& rRegion, OutputDevice *pOutDev )
 {
@@ -277,7 +267,6 @@ BOOL OutputDevice::ImplSelectClipRegion(
 	return bClipRegion;
 }
 
-#endif
 
 // =======================================================================
 
@@ -305,7 +294,6 @@ PolyPolygon ImplSubdivideBezier( const P
 
 // =======================================================================
 
-#ifndef REMOTE_APPSERVER
 // #100127# Extracted from OutputDevice::DrawPolyPolygon()
 void OutputDevice::ImplDrawPolyPolygon( USHORT nPoly, const PolyPolygon& rPolyPoly )
 {
@@ -390,15 +378,14 @@ void OutputDevice::ImplDrawPolyPolygon( 
         delete[] pFlagAryAry;
     }
 }
-#endif
 
 // =======================================================================
 
 OutputDevice::OutputDevice() :
 	maRegion( REGION_NULL ),
-	maSettings( Application::GetSettings() ),
 	maFillColor( COL_WHITE ),
-	maTextLineColor( COL_TRANSPARENT )
+	maTextLineColor( COL_TRANSPARENT ),
+	maSettings( Application::GetSettings() )
 {
 	DBG_CTOR( OutputDevice, ImplDbgCheckOutputDevice );
 
@@ -416,6 +403,7 @@ OutputDevice::OutputDevice() :
 	mpOutDevData		= NULL;
 	mp3DContext 		= NULL;
     mpPDFWriter			= NULL;
+    mpAlphaVDev			= NULL;
 	mnOutOffX			= 0;
 	mnOutOffY			= 0;
 	mnOutWidth			= 0;
@@ -442,7 +430,6 @@ OutputDevice::OutputDevice() :
 	mbDevOutput 		= FALSE;
 	mbOutputClipped 	= FALSE;
 	maTextColor 		= maFont.GetColor();
-	maTextFillColorDummy= maFont.GetFillColor();
 	meTextAlign 		= maFont.GetAlign();
 	meRasterOp			= ROP_OVERPAINT;
 	mnAntialiasing		= 0;
@@ -523,6 +510,8 @@ OutputDevice::~OutputDevice()
         mpFontList->Clear();
         delete mpFontList;
     }
+
+    delete mpAlphaVDev;
 }
 
 // -----------------------------------------------------------------------
@@ -540,17 +529,18 @@ void OutputDevice::EnableRTL( BOOL bEnab
             if( ImplGetGraphics() )
                 mpGraphics->SetLayout( mbEnableRTL ? SAL_LAYOUT_BIDI_RTL : 0 );
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->EnableRTL( bEnable );
 }
 
 BOOL OutputDevice::ImplHasMirroredGraphics()
 {
-#ifndef REMOTE_APPSERVER
     return ( ImplGetGraphics() && (mpGraphics->GetLayout() & SAL_LAYOUT_BIDI_RTL) );
-#else
-    return FALSE;
-#endif
 }
 
+// note: the coordiantes to be remirrored are in frame coordiantes !
+
 void    OutputDevice::ImplReMirror( Point &rPoint ) const
 {
     rPoint.X() = mnOutOffX + mnOutWidth - 1 - rPoint.X() + mnOutOffX; 
@@ -590,8 +580,6 @@ void    OutputDevice::ImplReMirror( Regi
 
 // -----------------------------------------------------------------------
 
-#ifndef REMOTE_APPSERVER
-
 int OutputDevice::ImplGetGraphics() const
 {
 	DBG_TESTSOLARMUTEX();
@@ -824,8 +812,6 @@ void OutputDevice::ImplReleaseGraphics( 
 	}
 }
 
-#endif
-
 // -----------------------------------------------------------------------
 
 void OutputDevice::ImplInitOutDevData()
@@ -871,7 +857,6 @@ void OutputDevice::ImplInitLineColor()
 {
 	DBG_TESTSOLARMUTEX();
 
-#ifndef REMOTE_APPSERVER
 	if( mbLineColor )
 	{
 		if( ROP_0 == meRasterOp )
@@ -885,9 +870,6 @@ void OutputDevice::ImplInitLineColor()
 	}
 	else
 		mpGraphics->SetLineColor();
-#else
-	mpGraphics->SetLineColor( maLineColor );
-#endif
 
 	mbInitLineColor = FALSE;
 }
@@ -898,7 +880,6 @@ void OutputDevice::ImplInitFillColor()
 {
 	DBG_TESTSOLARMUTEX();
 
-#ifndef REMOTE_APPSERVER
 	if( mbFillColor )
 	{
 		if( ROP_0 == meRasterOp )
@@ -912,9 +893,6 @@ void OutputDevice::ImplInitFillColor()
 	}
 	else
 		mpGraphics->SetFillColor();
-#else
-	mpGraphics->SetFillColor( maFillColor );
-#endif
 
 	mbInitFillColor = FALSE;
 }
@@ -950,11 +928,7 @@ void OutputDevice::ImplInitClipRegion()
 		else
 		{
 			mbOutputClipped = FALSE;
-#ifndef REMOTE_APPSERVER
 			ImplSelectClipRegion( mpGraphics, aRegion, this );
-#else
-			mpGraphics->SetClipRegion( aRegion );
-#endif
 		}
 		mbClipRegionSet = TRUE;
 	}
@@ -967,13 +941,9 @@ void OutputDevice::ImplInitClipRegion()
 			else
 			{
 				mbOutputClipped = FALSE;
-#ifndef REMOTE_APPSERVER
 				ImplSelectClipRegion( mpGraphics, 
                                       // #102532# Respect output offset also for clip region
                                       ImplPixelToDevicePixel( maRegion ), this );
-#else
-				mpGraphics->SetClipRegion( maRegion );
-#endif
 			}
 
 			mbClipRegionSet = TRUE;
@@ -982,11 +952,7 @@ void OutputDevice::ImplInitClipRegion()
 		{
 			if ( mbClipRegionSet )
 			{
-#ifndef REMOTE_APPSERVER
 				mpGraphics->ResetClipRegion();
-#else
-				mpGraphics->SetClipRegion();
-#endif
 				mbClipRegionSet = FALSE;
 			}
 
@@ -1031,6 +997,9 @@ void OutputDevice::SetClipRegion()
 		mpMetaFile->AddAction( new MetaClipRegionAction( Region(), FALSE ) );
 
 	ImplSetClipRegion( NULL );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetClipRegion();
 }
 
 // -----------------------------------------------------------------------
@@ -1051,6 +1020,9 @@ void OutputDevice::SetClipRegion( const 
 		Region aRegion = LogicToPixel( rRegion );
 		ImplSetClipRegion( &aRegion );
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetClipRegion( rRegion );
 }
 
 // -----------------------------------------------------------------------
@@ -1101,6 +1073,9 @@ void OutputDevice::MoveClipRegion( long 
 					   ImplLogicHeightToDevicePixel( nVertMove ) );
 		mbInitClipRegion = TRUE;
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->MoveClipRegion( nHorzMove, nVertMove );
 }
 
 // -----------------------------------------------------------------------
@@ -1117,6 +1092,9 @@ void OutputDevice::IntersectClipRegion( 
 	maRegion.Intersect( aRect );
 	mbClipRegion		= TRUE;
 	mbInitClipRegion	= TRUE;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->IntersectClipRegion( rRect );
 }
 
 // -----------------------------------------------------------------------
@@ -1139,6 +1117,9 @@ void OutputDevice::IntersectClipRegion( 
 		mbClipRegion		= TRUE;
 		mbInitClipRegion	= TRUE;
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->IntersectClipRegion( rRegion );
 }
 
 // -----------------------------------------------------------------------
@@ -1149,6 +1130,9 @@ void OutputDevice::SetDrawMode( ULONG nD
 	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
 
 	mnDrawMode = nDrawMode;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetDrawMode( nDrawMode );
 }
 
 // -----------------------------------------------------------------------
@@ -1166,15 +1150,12 @@ void OutputDevice::SetRasterOp( RasterOp
 		meRasterOp = eRasterOp;
 		mbInitLineColor = mbInitFillColor = TRUE;
 
-#ifndef REMOTE_APPSERVER
 		if( mpGraphics || ImplGetGraphics() )
 			mpGraphics->SetXORMode( (ROP_INVERT == meRasterOp) || (ROP_XOR == meRasterOp) );
-#else
-		ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-		if( pGraphics )
-			pGraphics->SetRasterOp( eRasterOp );
-#endif
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetRasterOp( eRasterOp );
 }
 
 // -----------------------------------------------------------------------
@@ -1193,6 +1174,9 @@ void OutputDevice::SetLineColor()
 		mbLineColor = FALSE;
 		maLineColor = Color( COL_TRANSPARENT );
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetLineColor();
 }
 
 // -----------------------------------------------------------------------
@@ -1258,6 +1242,9 @@ void OutputDevice::SetLineColor( const C
 			maLineColor = aColor;
 		}
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetLineColor( COL_BLACK );
 }
 
 // -----------------------------------------------------------------------
@@ -1276,6 +1263,9 @@ void OutputDevice::SetFillColor()
 		mbFillColor = FALSE;
 		maFillColor = Color( COL_TRANSPARENT );
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetFillColor();
 }
 
 // -----------------------------------------------------------------------
@@ -1345,6 +1335,9 @@ void OutputDevice::SetFillColor( const C
 			maFillColor = aColor;
 		}
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetFillColor( COL_BLACK );
 }
 
 // -----------------------------------------------------------------------
@@ -1356,6 +1349,9 @@ void OutputDevice::SetBackground()
 
 	maBackground = Wallpaper();
 	mbBackground = FALSE;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetBackground();
 }
 
 // -----------------------------------------------------------------------
@@ -1371,6 +1367,9 @@ void OutputDevice::SetBackground( const 
 		mbBackground = FALSE;
 	else
 		mbBackground = TRUE;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetBackground( rBackground );
 }
 
 // -----------------------------------------------------------------------
@@ -1385,6 +1384,9 @@ void OutputDevice::SetRefPoint()
 
 	mbRefPoint = FALSE;
 	maRefPoint.X() = maRefPoint.Y() = 0L;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetRefPoint();
 }
 
 // -----------------------------------------------------------------------
@@ -1399,6 +1401,9 @@ void OutputDevice::SetRefPoint( const Po
 
 	mbRefPoint = TRUE;
 	maRefPoint = rRefPoint;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetRefPoint( rRefPoint );
 }
 
 // -----------------------------------------------------------------------
@@ -1414,7 +1419,6 @@ void OutputDevice::DrawLine( const Point
 	if ( !IsDeviceOutputNecessary() || !mbLineColor || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	if ( !mpGraphics )
 	{
 		if ( !ImplGetGraphics() )
@@ -1433,16 +1437,9 @@ void OutputDevice::DrawLine( const Point
 	Point aEndPt = ImplLogicToDevicePixel( rEndPt );
 
 	mpGraphics->DrawLine( aStartPt.X(), aStartPt.Y(), aEndPt.X(), aEndPt.Y(), this );
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		pGraphics->DrawLine( ImplLogicToDevicePixel( rStartPt ),
-							 ImplLogicToDevicePixel( rEndPt ) );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawLine( rStartPt, rEndPt );
 }
 
 // -----------------------------------------------------------------------
@@ -1465,8 +1462,6 @@ void OutputDevice::DrawLine( const Point
 	if ( !IsDeviceOutputNecessary() || !mbLineColor || ( LINE_NONE == rLineInfo.GetStyle() ) || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
-
 	if( !mpGraphics && !ImplGetGraphics() )
 		return;
 
@@ -1523,60 +1518,8 @@ void OutputDevice::DrawLine( const Point
 		mpGraphics->DrawLine( aStartPt.X(), aStartPt.Y(), aEndPt.X(), aEndPt.Y(), this );
 	}
 
-#else
-
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		const LineInfo aInfo( ImplLogicToDevicePixel( rLineInfo ) );
-
-		if( ( aInfo.GetWidth() > 1L ) || ( LINE_DASH == aInfo.GetStyle() ) )
-		{
-			Polygon 			aPoly( 2 ); aPoly[ 0 ] = rStartPt; aPoly[ 1 ] = rEndPt;
-			GDIMetaFile*		pOldMetaFile = mpMetaFile;
-			ImplLineConverter	aLineCvt( ImplLogicToDevicePixel( aPoly ), aInfo, ( mbRefPoint ) ? &maRefPoint : NULL );
-
-			mpMetaFile = NULL;
-
-			if ( aInfo.GetWidth() > 1 )
-			{
-				const Color 	aOldLineColor( maLineColor );
-				const Color 	aOldFillColor( maFillColor );
-
-				SetLineColor();
-				ImplInitLineColor();
-				SetFillColor( aOldLineColor );
-				ImplInitFillColor();
-
-				for( const Polygon* pPoly = aLineCvt.ImplGetFirst(); pPoly; pPoly = aLineCvt.ImplGetNext() )
-					pGraphics->DrawPolygon( *pPoly );
-
-				SetLineColor( aOldLineColor );
-				SetFillColor( aOldFillColor );
-			}
-			else
-			{
-				if ( mbInitLineColor )
-					ImplInitLineColor();
-
-				for ( const Polygon* pPoly = aLineCvt.ImplGetFirst(); pPoly; pPoly = aLineCvt.ImplGetNext() ) {
-					Point xPoint((*pPoly)[ 0 ].X(), (*pPoly)[ 0 ].Y());
-					Point yPoint((*pPoly)[ 1 ].X(), (*pPoly)[ 1 ].Y());
-					mpGraphics->DrawLine( xPoint, yPoint );
-				}
-			}
-			mpMetaFile = pOldMetaFile;
-		}
-		else
-		{
-			if ( mbInitLineColor )
-				ImplInitLineColor();
-
-			pGraphics->DrawLine( ImplLogicToDevicePixel( rStartPt ), ImplLogicToDevicePixel( rEndPt ) );
-		}
-	}
-
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawLine( rStartPt, rEndPt, rLineInfo );
 }
 
 // -----------------------------------------------------------------------
@@ -1598,7 +1541,6 @@ void OutputDevice::DrawRect( const Recta
 		return;
 	aRect.Justify();
 
-#ifndef REMOTE_APPSERVER
 	if ( !mpGraphics )
 	{
 		if ( !ImplGetGraphics() )
@@ -1616,17 +1558,9 @@ void OutputDevice::DrawRect( const Recta
 		ImplInitFillColor();
 
 	mpGraphics->DrawRect( aRect.Left(), aRect.Top(), aRect.GetWidth(), aRect.GetHeight(), this );
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawRect( aRect );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( rRect );
 }
 
 // -----------------------------------------------------------------------
@@ -1645,7 +1579,6 @@ void OutputDevice::DrawPolyLine( const P
 	if ( !IsDeviceOutputNecessary() || !mbLineColor || (nPoints < 2) || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -1679,22 +1612,9 @@ void OutputDevice::DrawPolyLine( const P
     {
         mpGraphics->DrawPolyLine( nPoints, pPtAry, this );
     }
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-
-        Polygon aPoly = ImplLogicToDevicePixel( rPoly );
 
-        // #100127# TODO: maybe extend Polygon::operator>>
-        if( aPoly.HasFlags() )
-            aPoly = ImplSubdivideBezier( aPoly );
-        
-        pGraphics->DrawPolyLine( aPoly );
-	}
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPolyLine( rPoly );
 }
 
 // -----------------------------------------------------------------------
@@ -1728,7 +1648,6 @@ void OutputDevice::DrawPolyLine( const P
         nPoints = aPoly.GetSize();
     }
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics && !ImplGetGraphics() )
 		return;
@@ -1774,48 +1693,9 @@ void OutputDevice::DrawPolyLine( const P
 		else
 			mpGraphics->DrawPolyLine( nPoints, (const SalPoint*) aPoly.GetConstPointAry(), this );
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
 
-	if ( pGraphics )
-	{
-		const LineInfo aInfo( ImplLogicToDevicePixel( rLineInfo ) );
-
-		if( aInfo.GetWidth() > 1L )
-		{
-			const Color 		aOldLineColor( maLineColor );
-			const Color 		aOldFillColor( maFillColor );
-			GDIMetaFile*		pOldMetaFile = mpMetaFile;
-			ImplLineConverter	aLineCvt( aPoly, aInfo, ( mbRefPoint ) ? &maRefPoint : NULL );
-
-			mpMetaFile = NULL;
-			SetLineColor();
-			ImplInitLineColor();
-			SetFillColor( aOldLineColor );
-			ImplInitFillColor();
-
-			for( const Polygon* pPoly = aLineCvt.ImplGetFirst(); pPoly; pPoly = aLineCvt.ImplGetNext() )
-				pGraphics->DrawPolygon( *pPoly );
-
-			SetLineColor( aOldLineColor );
-			SetFillColor( aOldFillColor );
-			mpMetaFile = pOldMetaFile;
-		}
-		else
-		{
-			if ( mbInitLineColor )
-				ImplInitLineColor();
-			if ( LINE_DASH == aInfo.GetStyle() )
-			{
-				ImplLineConverter	aLineCvt( aPoly, aInfo, ( mbRefPoint ) ? &maRefPoint : NULL );
-				for( const Polygon* pPoly = aLineCvt.ImplGetFirst(); pPoly; pPoly = aLineCvt.ImplGetNext() )
-					pGraphics->DrawPolyLine( *pPoly );
-			}
-			else
-				pGraphics->DrawPolyLine( aPoly );
-		}
-	}
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPolyLine( rPoly, rLineInfo );
 }
 
 // -----------------------------------------------------------------------
@@ -1834,7 +1714,6 @@ void OutputDevice::DrawPolygon( const Po
 	if ( !IsDeviceOutputNecessary() || (!mbLineColor && !mbFillColor) || (nPoints < 2) || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -1870,24 +1749,8 @@ void OutputDevice::DrawPolygon( const Po
     {
         mpGraphics->DrawPolygon( nPoints, pPtAry, this );
     }
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-
-        Polygon aPoly = ImplLogicToDevicePixel( rPoly );
-
-        // #100127# TODO: maybe extend Polygon::operator>>
-        if( aPoly.HasFlags() )
-            aPoly = ImplSubdivideBezier( aPoly );
-
-		pGraphics->DrawPolygon( aPoly );
-	}
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPolygon( rPoly );
 }
 
 // -----------------------------------------------------------------------
@@ -1906,7 +1769,6 @@ void OutputDevice::DrawPolyPolygon( cons
 	if ( !IsDeviceOutputNecessary() || (!mbLineColor && !mbFillColor) || !nPoly || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -1945,47 +1807,8 @@ void OutputDevice::DrawPolyPolygon( cons
         // ImplLogicToDevicePixel calls
         ImplDrawPolyPolygon( nPoly, ImplLogicToDevicePixel( rPolyPoly ) );
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		if ( nPoly == 1 )
-		{
-			Polygon aPoly = ImplLogicToDevicePixel( rPolyPoly.GetObject( 0 ) );
-			USHORT nSize = aPoly.GetSize();
-			if ( nSize >= 2 )
-            {
-                // #100127# TODO: maybe extend Polygon::operator>>
-                if( aPoly.HasFlags() )
-                    aPoly = ImplSubdivideBezier( aPoly );
-
-				pGraphics->DrawPolygon( aPoly );
-            }
-		}
-		else
-        {
-            PolyPolygon aPolyPoly = ImplLogicToDevicePixel( rPolyPoly );
-
-            USHORT i, nPoints = aPolyPoly.Count();
-            for( i=0; i<nPoints; ++i )
-            {
-                if( aPolyPoly.GetObject( i ).HasFlags() )
-                {
-                    // #100127# TODO: maybe extend Polygon::operator>>
-                    aPolyPoly = ImplSubdivideBezier( aPolyPoly );
-                    break;
-                }
-            }
-
-			pGraphics->DrawPolyPolygon( aPolyPoly );
-        }
-	}
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPolyPolygon( rPolyPoly );
 }
 
 // -----------------------------------------------------------------------
@@ -2038,6 +1861,10 @@ void OutputDevice::Push( USHORT nFlags )
 	}
 	if ( nFlags & PUSH_TEXTALIGN )
 		pData->meTextAlign = GetTextAlign();
+	if( nFlags & PUSH_TEXTLAYOUTMODE )
+		pData->mnTextLayoutMode = GetLayoutMode();
+	if( nFlags & PUSH_TEXTLANGUAGE )
+		pData->meTextLanguage = GetDigitLanguage();
 	if ( nFlags & PUSH_RASTEROP )
 		pData->meRasterOp = GetRasterOp();
 	if ( nFlags & PUSH_MAPMODE )
@@ -2061,6 +1888,9 @@ void OutputDevice::Push( USHORT nFlags )
 		else
 			pData->mpRefPoint = NULL;
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->Push();
 }
 
 // -----------------------------------------------------------------------
@@ -2083,6 +1913,9 @@ void OutputDevice::Pop()
 		return;
 	}
 
+    if( mpAlphaVDev )
+        mpAlphaVDev->Pop();
+
 	mpObjStack = pData->mpPrev;
 
 	if ( pData->mnFlags & PUSH_LINECOLOR )
@@ -2119,6 +1952,10 @@ void OutputDevice::Pop()
 	}
 	if ( pData->mnFlags & PUSH_TEXTALIGN )
 		SetTextAlign( pData->meTextAlign );
+	if( pData->mnFlags & PUSH_TEXTLAYOUTMODE )
+		SetLayoutMode( pData->mnTextLayoutMode );
+	if( pData->mnFlags & PUSH_TEXTLANGUAGE )
+		SetDigitLanguage( pData->meTextLanguage );
 	if ( pData->mnFlags & PUSH_RASTEROP )
 		SetRasterOp( pData->meRasterOp );
 	if ( pData->mnFlags & PUSH_MAPMODE )
@@ -2145,6 +1982,33 @@ void OutputDevice::Pop()
 
 // -----------------------------------------------------------------------
 
+void OutputDevice::SetConnectMetaFile( GDIMetaFile* pMtf ) 
+{ 
+    mpMetaFile = pMtf; 
+}
+
+// -----------------------------------------------------------------------
+
+void OutputDevice::EnableOutput( BOOL bEnable ) 
+{ 
+    mbOutput = (bEnable != 0); 
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->EnableOutput( bEnable );
+}
+
+// -----------------------------------------------------------------------
+
+void OutputDevice::SetSettings( const AllSettings& rSettings ) 
+{ 
+    maSettings = rSettings; 
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetSettings( rSettings );
+}
+
+// -----------------------------------------------------------------------
+
 USHORT OutputDevice::GetBitCount() const
 {
 	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
@@ -2152,20 +2016,33 @@ USHORT OutputDevice::GetBitCount() const
 	if ( meOutDevType == OUTDEV_VIRDEV )
 		return ((VirtualDevice*)this)->mnBitCount;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
 		if ( !((OutputDevice*)this)->ImplGetGraphics() )
 			return 0;
 	}
-#endif
 
 	return (USHORT)mpGraphics->GetBitCount();
 }
 
 // -----------------------------------------------------------------------
 
+USHORT OutputDevice::GetAlphaBitCount() const
+{
+	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
+
+	if ( meOutDevType == OUTDEV_VIRDEV &&
+        mpAlphaVDev != NULL )
+    {
+		return mpAlphaVDev->GetBitCount();
+    }
+
+    return 0;
+}
+
+// -----------------------------------------------------------------------
+
 ULONG OutputDevice::GetColorCount() const
 {
 	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
@@ -2176,11 +2053,17 @@ ULONG OutputDevice::GetColorCount() cons
 
 // -----------------------------------------------------------------------
 
+BOOL OutputDevice::HasAlpha()
+{
+    return mpAlphaVDev != NULL;
+}
+
+// -----------------------------------------------------------------------
+
 OpenGL* OutputDevice::GetOpenGL()
 {
 	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
 
-#ifndef REMOTE_APPSERVER
 	OpenGL* pOGL;
 
 	if( OUTDEV_PRINTER != meOutDevType )
@@ -2197,9 +2080,6 @@ OpenGL* OutputDevice::GetOpenGL()
 		pOGL = NULL;
 
 	return pOGL;
-#else
-	return NULL;
-#endif
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/gdi/outdev2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev2.cxx,v
retrieving revision 1.13.112.1
retrieving revision 1.22
diff -u -p -u -r1.13.112.1 -r1.22
--- vcl/source/gdi/outdev2.cxx	15 Jan 2004 14:04:04 -0000	1.13.112.1
+++ vcl/source/gdi/outdev2.cxx	24 May 2004 15:24:50 -0000	1.22
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_OUTDEV2_CXX
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -112,12 +110,16 @@
 #ifndef _SV_WINDOW_HXX
 #include <window.hxx>
 #endif
-#ifdef REMOTE_APPSERVER
-#include <rmoutdev.hxx>
-#endif
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
 #endif
+#ifndef _SV_IMAGE_H
+#include <image.h>
+#endif
+#ifndef _SV_IMAGE_HXX
+#include <image.hxx>
+#endif
+
 #define BAND_MAX_SIZE 512000
 
 // =======================================================================
@@ -130,8 +132,6 @@ DBG_NAMEEX( OutputDevice );
 // - Defines -
 // -----------
 
-#ifndef REMOTE_APPSERVER
-
 #define OUTDEV_INIT()						\
 {											\
 	if ( !IsDeviceOutputNecessary() )		\
@@ -148,24 +148,7 @@ DBG_NAMEEX( OutputDevice );
 		return; 							\
 }
 
-#else // !REMOTE_APPSERVER
-
-#define OUTDEV_INIT()											\
-{																\
-	if ( !IsDeviceOutputNecessary() )							\
-		return; 												\
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();	\
-	if ( !pGraphics )											\
-		return; 												\
-}
-
-#endif // REMOTE_APPSERVER
-
-#ifndef REMOTE_APPSERVER
 #define TwoRect 	SalTwoRect
-#else
-#define TwoRect 	RemoteTwoRect
-#endif
 
 // -------------
 // - externals -
@@ -241,11 +224,7 @@ ULONG ImplAdjustTwoRect( TwoRect& rTwoRe
 void OutputDevice::ImplDrawOutDevDirect( const OutputDevice* pSrcDev, void* pVoidPosAry )
 {
 	TwoRect*			pPosAry = (TwoRect*)pVoidPosAry;
-#ifndef REMOTE_APPSERVER
 	SalGraphics*		pGraphics2;
-#else
-	ImplServerGraphics* pGraphics2;
-#endif
 
 	if ( pPosAry->mnSrcWidth && pPosAry->mnSrcHeight && pPosAry->mnDestWidth && pPosAry->mnDestHeight )
 	{
@@ -256,13 +235,11 @@ void OutputDevice::ImplDrawOutDevDirect(
 			if ( (GetOutDevType() != pSrcDev->GetOutDevType()) ||
 				 (GetOutDevType() != OUTDEV_WINDOW) )
 			{
-#ifndef REMOTE_APPSERVER
 				if ( !pSrcDev->mpGraphics )
 				{
 					if ( !((OutputDevice*)pSrcDev)->ImplGetGraphics() )
 						return;
 				}
-#endif
 				pGraphics2 = pSrcDev->mpGraphics;
 			}
 			else
@@ -271,16 +248,13 @@ void OutputDevice::ImplDrawOutDevDirect(
 					pGraphics2 = NULL;
 				else
 				{
-#ifndef REMOTE_APPSERVER
 					if ( !pSrcDev->mpGraphics )
 					{
 						if ( !((OutputDevice*)pSrcDev)->ImplGetGraphics() )
 							return;
 					}
-#endif
 					pGraphics2 = pSrcDev->mpGraphics;
 
-#ifndef REMOTE_APPSERVER
 					if ( !mpGraphics )
 					{
 						if ( !ImplGetGraphics() )
@@ -288,7 +262,6 @@ void OutputDevice::ImplDrawOutDevDirect(
 					}
 					DBG_ASSERT( mpGraphics && pSrcDev->mpGraphics,
 								"OutputDevice::DrawOutDev(): We need more than one Graphics" );
-#endif
 				}
 			}
 		}
@@ -324,7 +297,7 @@ void OutputDevice::ImplDrawOutDevDirect(
             if( (GetOutDevType() != OUTDEV_WINDOW) && pGraphics2 && (pGraphics2->GetLayout() & SAL_LAYOUT_BIDI_RTL) )
             {
 		        SalTwoRect pPosAry2 = *pPosAry;
-			    ((SalGraphicsLayout*)pGraphics2)->mirror( pPosAry2.mnSrcX, pPosAry2.mnSrcWidth, pSrcDev ); 
+			    pGraphics2->mirror( pPosAry2.mnSrcX, pPosAry2.mnSrcWidth, pSrcDev ); 
 			    mpGraphics->CopyBits( &pPosAry2, pGraphics2, this, pSrcDev );
             }
             else
@@ -401,6 +374,9 @@ void OutputDevice::DrawOutDev( const Poi
 			mpGraphics->CopyBits( &aPosAry, NULL, this, NULL );
 		}
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawOutDev( rDestPt, rDestSize, rSrcPt, rSrcSize );
 }
 
 // ------------------------------------------------------------------
@@ -442,7 +418,38 @@ void OutputDevice::DrawOutDev( const Poi
 	aPosAry.mnDestWidth  = ImplLogicWidthToDevicePixel( rDestSize.Width() );
 	aPosAry.mnDestHeight = ImplLogicHeightToDevicePixel( rDestSize.Height() );
 
-	ImplDrawOutDevDirect( &rOutDev, &aPosAry );
+    if( mpAlphaVDev )
+    {
+        if( rOutDev.mpAlphaVDev )
+        {
+            // alpha-blend source over destination
+            DrawBitmapEx( rDestPt, rDestSize, rOutDev.GetBitmapEx(rSrcPt, rSrcSize) );
+
+            // This would be mode SOURCE:
+            // copy source alpha channel to our alpha channel
+            //mpAlphaVDev->DrawOutDev( rDestPt, rDestSize, rSrcPt, rSrcSize, *rOutDev.mpAlphaVDev );
+        }
+        else
+        {
+            ImplDrawOutDevDirect( &rOutDev, &aPosAry );
+
+            // make destination rectangle opaque - source has no alpha
+            mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
+        }
+    }
+    else
+    {
+        if( rOutDev.mpAlphaVDev )
+        {
+            // alpha-blend source over destination
+            DrawBitmapEx( rDestPt, rDestSize, rOutDev.GetBitmapEx(rSrcPt, rSrcSize) );
+        }
+        else
+        {
+            // no alpha at all, neither in source nor destination device
+            ImplDrawOutDevDirect( &rOutDev, &aPosAry );
+        }
+    }
 }
 
 // ------------------------------------------------------------------
@@ -496,17 +503,10 @@ void OutputDevice::CopyArea( const Point
 															   aPosAry.mnDestY-aPosAry.mnSrcY,
 															   FALSE );
 
-#ifndef REMOTE_APPSERVER
 				mpGraphics->CopyArea( aPosAry.mnDestX, aPosAry.mnDestY,
 									  aPosAry.mnSrcX, aPosAry.mnSrcY,
 									  aPosAry.mnSrcWidth, aPosAry.mnSrcHeight,
 									  SAL_COPYAREA_WINDOWINVALIDATE, this );
-#else
-				mpGraphics->CopyArea( aPosAry.mnDestX, aPosAry.mnDestY,
-									  aPosAry.mnSrcX, aPosAry.mnSrcY,
-									  aPosAry.mnSrcWidth, aPosAry.mnSrcHeight,
-									  COPYAREA_WINDOWINVALIDATE );
-#endif
 			}
 			else
 			{
@@ -518,6 +518,9 @@ void OutputDevice::CopyArea( const Point
 	}
 
 	SetRasterOp( eOldRop );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->CopyArea( rDestPt, rSrcPt, rSrcSize, nFlags );
 }
 
 // ------------------------------------------------------------------
@@ -534,7 +537,6 @@ void OutputDevice::ImplDrawFrameDev( con
 	mbMap = FALSE;
 	SetRasterOp( ROP_OVERPAINT );
 
-#ifndef REMOTE_APPSERVER
 	if ( !IsDeviceOutputNecessary() )
 		return;
 
@@ -543,24 +545,12 @@ void OutputDevice::ImplDrawFrameDev( con
 		if ( !ImplGetGraphics() )
 			return;
 	}
-#else
-	if ( !IsDeviceOutputNecessary() )
-		return;
-
-#endif
 
 	// ClipRegion zuruecksetzen
-#ifndef REMOTE_APPSERVER
 	if ( rRegion.IsNull() )
 		mpGraphics->ResetClipRegion();
 	else
 		ImplSelectClipRegion( mpGraphics, rRegion, this );
-#else
-	if ( rRegion.IsNull() )
-		mpGraphics->SetClipRegion();
-	else
-		mpGraphics->SetClipRegion( rRegion );
-#endif
 
 	TwoRect aPosAry;
 	aPosAry.mnSrcX		 = rDevPt.X();
@@ -605,6 +595,9 @@ void OutputDevice::DrawBitmap( const Poi
 
 	const Size aSizePix( rBitmap.GetSizePixel() );
 	ImplDrawBitmap( rDestPt, PixelToLogic( aSizePix ), Point(), aSizePix, rBitmap, META_BMP_ACTION );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, PixelToLogic( aSizePix )) );
 }
 
 // ------------------------------------------------------------------
@@ -617,6 +610,9 @@ void OutputDevice::DrawBitmap( const Poi
         return;
 
 	ImplDrawBitmap( rDestPt, rDestSize, Point(), rBitmap.GetSizePixel(), rBitmap, META_BMPSCALE_ACTION );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
 }
 
 // ------------------------------------------------------------------
@@ -631,6 +627,9 @@ void OutputDevice::DrawBitmap( const Poi
         return;
 
 	ImplDrawBitmap( rDestPt, rDestSize, rSrcPtPixel, rSrcSizePixel, rBitmap, META_BMPSCALEPART_ACTION );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
 }
 
 // -----------------------------------------------------------------------------
@@ -721,15 +720,7 @@ void OutputDevice::ImplDrawBitmap( const
 			if ( nMirrFlags )
 				aBmp.Mirror( nMirrFlags );
 
-#ifndef REMOTE_APPSERVER
 			mpGraphics->DrawBitmap( &aPosAry, *aBmp.ImplGetImpBitmap()->ImplGetSalBitmap(), this );
-#else
-			aBmp.ImplDrawRemote( this,
-						Point( aPosAry.mnSrcX, aPosAry.mnSrcY ),
-						Size( aPosAry.mnSrcWidth, aPosAry.mnSrcHeight ),
-						Point( aPosAry.mnDestX, aPosAry.mnDestY ),
-						Size( aPosAry.mnDestWidth, aPosAry.mnDestHeight ) );
-#endif
 		}
 	}
 }
@@ -873,13 +864,11 @@ void OutputDevice::ImplDrawBitmapEx( con
         }
 	    return;
 	}
-#ifndef REMOTE_APPSERVER
 	else if( rBitmapEx.IsAlpha() )
 	{
 		ImplDrawAlpha( aBmpEx.GetBitmap(), aBmpEx.GetAlpha(), rDestPt, rDestSize, rSrcPtPixel, rSrcSizePixel );
 		return;
 	}
-#endif
 
 	if( !( !aBmpEx ) )
 	{
@@ -898,7 +887,6 @@ void OutputDevice::ImplDrawBitmapEx( con
 
 		if( aPosAry.mnSrcWidth && aPosAry.mnSrcHeight && aPosAry.mnDestWidth && aPosAry.mnDestHeight )
 		{
-#ifndef REMOTE_APPSERVER
 
 			if( nMirrFlags )
 				aBmpEx.Mirror( nMirrFlags );
@@ -967,22 +955,29 @@ void OutputDevice::ImplDrawBitmapEx( con
 				mpGraphics->DrawBitmap( &aPosAry, *pImpBmp->ImplGetSalBitmap(), 
                                         *pMaskBmp->ImplGetSalBitmap(), 
                                         this );
+
+                // #110958# Paint mask to alpha channel. Luckily, the
+                // black and white representation of the mask maps to
+                // the alpha channel 
+
+                // #i25167# Restrict mask painting to _opaque_ areas
+                // of the mask, otherwise we spoil areas where no
+                // bitmap content was ever visible. Interestingly
+                // enough, this can be achieved by taking the mask as
+                // the transparency mask of itself
+                if( mpAlphaVDev )
+                    mpAlphaVDev->DrawBitmapEx( rDestPt, 
+                                               rDestSize, 
+                                               BitmapEx( rBitmapEx.GetMask(),
+                                                         rBitmapEx.GetMask() ) );
             }
 			else
+            {
 				mpGraphics->DrawBitmap( &aPosAry, *pImpBmp->ImplGetSalBitmap(), this );
 
-#else
-
-			if( nMirrFlags )
-				aBmpEx.Mirror( nMirrFlags );
-
-			aBmpEx.ImplDrawRemote( this,
-					Point( aPosAry.mnSrcX, aPosAry.mnSrcY ),
-					Size( aPosAry.mnSrcWidth, aPosAry.mnSrcHeight ),
-					Point( aPosAry.mnDestX, aPosAry.mnDestY ),
-					Size( aPosAry.mnDestWidth, aPosAry.mnDestHeight ) );
-
-#endif
+                if( mpAlphaVDev )
+                    mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
+            }
 		}
 	}
 }
@@ -999,6 +994,10 @@ void OutputDevice::DrawMask( const Point
 
 	const Size aSizePix( rBitmap.GetSizePixel() );
 	ImplDrawMask( rDestPt, PixelToLogic( aSizePix ), Point(), aSizePix, rBitmap, rMaskColor, META_MASK_ACTION );
+
+    // TODO: Use mask here
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, PixelToLogic( aSizePix )) );
 }
 
 // ------------------------------------------------------------------
@@ -1012,6 +1011,10 @@ void OutputDevice::DrawMask( const Point
         return;
 
 	ImplDrawMask( rDestPt, rDestSize, Point(), rBitmap.GetSizePixel(), rBitmap, rMaskColor, META_MASKSCALE_ACTION );
+
+    // TODO: Use mask here
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
 }
 
 // ------------------------------------------------------------------
@@ -1026,6 +1029,10 @@ void OutputDevice::DrawMask( const Point
         return;
 
 	ImplDrawMask( rDestPt, rDestSize, rSrcPtPixel, rSrcSizePixel, rBitmap, rMaskColor, META_MASKSCALEPART_ACTION );
+
+    // TODO: Use mask here
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( Rectangle(rDestPt, rDestSize) );
 }
 
 // ------------------------------------------------------------------
@@ -1066,16 +1073,13 @@ void OutputDevice::ImplDrawMask( const P
 
 	OUTDEV_INIT();
 
-#ifndef REMOTE_APPSERVER
 	if ( OUTDEV_PRINTER == meOutDevType )
 	{
 		ImplPrintMask( rBitmap, rMaskColor, rDestPt, rDestSize, rSrcPtPixel, rSrcSizePixel );
 		return;
 	}
-#endif
 
 	const ImpBitmap* pImpBmp = rBitmap.ImplGetImpBitmap();
-
 	if ( pImpBmp )
 	{
 		TwoRect aPosAry;
@@ -1146,13 +1214,10 @@ Bitmap OutputDevice::GetBitmap( const Po
 	long	nWidth = ImplLogicWidthToDevicePixel( rSize.Width() );
 	long	nHeight = ImplLogicHeightToDevicePixel( rSize.Height() );
 
-#ifndef REMOTE_APPSERVER
 	if ( mpGraphics || ( (OutputDevice*) this )->ImplGetGraphics() )
-#endif
 	{
 		if ( nWidth && nHeight )
 		{
-#ifndef REMOTE_APPSERVER
 			Rectangle	aRect( Point( nX, nY ), Size( nWidth, nHeight ) );
 			BOOL		bClipped = FALSE;
 
@@ -1232,9 +1297,6 @@ Bitmap OutputDevice::GetBitmap( const Po
 					aBmp.ImplSetImpBitmap( pImpBmp );
 				}
 			}
-#else
-			aBmp.ImplGetRemoteBmp( (OutputDevice*) this, Point( nX, nY ), Size( nWidth, nHeight ) );
-#endif
 		}
 	}
 
@@ -1243,6 +1305,27 @@ Bitmap OutputDevice::GetBitmap( const Po
 
 // ------------------------------------------------------------------
 
+BitmapEx OutputDevice::GetBitmapEx( const Point& rSrcPt, const Size& rSize ) const
+{
+	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
+
+    // #110958# Extract alpha value from VDev, if any
+    if( mpAlphaVDev )
+    {
+        Bitmap aAlphaBitmap( mpAlphaVDev->GetBitmap( rSrcPt, rSize ) );
+
+        // ensure 8 bit alpha
+        if( aAlphaBitmap.GetBitCount() > 8 )
+            aAlphaBitmap.Convert( BMP_CONVERSION_8BIT_GREYS );
+
+        return BitmapEx(GetBitmap( rSrcPt, rSize ), AlphaMask( aAlphaBitmap ) );
+    }
+    else
+        return GetBitmap( rSrcPt, rSize );
+}
+
+// ------------------------------------------------------------------
+
 void OutputDevice::ImplGetFrameBitmap( const Point& rDestPt, const Size& rSize,
 									   Bitmap& rBitmap ) const
 {
@@ -1262,7 +1345,6 @@ Color OutputDevice::GetPixel( const Poin
 
 	Color aColor;
 
-#ifndef REMOTE_APPSERVER
 	if ( mpGraphics || ((OutputDevice*)this)->ImplGetGraphics() )
 	{
 		if ( mbInitClipRegion )
@@ -1278,16 +1360,6 @@ Color OutputDevice::GetPixel( const Poin
 			aColor.SetBlue( SALCOLOR_BLUE( aSalCol ) );
 		}
 	}
-#else // REMOTE_APPSERVER
-	ImplServerGraphics* pGraphics = ( (OutputDevice*) this )->ImplGetServerGraphics();
-	if( pGraphics )
-	{
-		const long nX = ImplLogicXToDevicePixel( rPt.X() );
-		const long nY = ImplLogicYToDevicePixel( rPt.Y() );
-		aColor = pGraphics->GetPixel( Point( nX, nY ) );
-	}
-#endif // REMOTE_APPSERVER
-
 	return aColor;
 }
 
@@ -1302,7 +1374,6 @@ Color* OutputDevice::GetPixel( const Pol
 
 	if( nSize )
 	{
-#ifndef REMOTE_APPSERVER
 		if ( mpGraphics || ((OutputDevice*)this)->ImplGetGraphics() )
 		{
 			if ( mbInitClipRegion )
@@ -1325,13 +1396,6 @@ Color* OutputDevice::GetPixel( const Pol
 				}
 			}
 		}
-#else // REMOTE_APPSERVER
-		ImplServerGraphics* pGraphics = ( (OutputDevice*) this )->ImplGetServerGraphics();
-		if( pGraphics )
-		{
-			pColors = pGraphics->GetPixel( ImplLogicToDevicePixel( rPts ) );
-		}
-#endif // REMOTE_APPSERVER
 	}
 
 	return pColors;
@@ -1350,7 +1414,6 @@ void OutputDevice::DrawPixel( const Poin
 	if ( !IsDeviceOutputNecessary() || !mbLineColor || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	Point aPt = ImplLogicToDevicePixel( rPt );
 
 	// we need a graphics
@@ -1369,15 +1432,9 @@ void OutputDevice::DrawPixel( const Poin
 		ImplInitLineColor();
 
 	mpGraphics->DrawPixel( aPt.X(), aPt.Y(), this );
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		pGraphics->DrawPixel( ImplLogicToDevicePixel( rPt ) );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPixel( rPt );
 }
 
 // -----------------------------------------------------------------------
@@ -1428,7 +1485,6 @@ void OutputDevice::DrawPixel( const Poin
 	if ( !IsDeviceOutputNecessary() || ImplIsColorTransparent( aColor ) || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	Point aPt = ImplLogicToDevicePixel( rPt );
 
 	// we need a graphics
@@ -1444,11 +1500,9 @@ void OutputDevice::DrawPixel( const Poin
 		return;
 
 	mpGraphics->DrawPixel( aPt.X(), aPt.Y(), ImplColorToSal( aColor ), this );
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-		pGraphics->DrawPixel( ImplLogicToDevicePixel( rPt ), aColor );
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPixel( rPt );
 }
 
 // -----------------------------------------------------------------------
@@ -1474,7 +1528,6 @@ void OutputDevice::DrawPixel( const Poly
 			if ( !IsDeviceOutputNecessary() || ImplIsRecordLayout() )
 				return;
 
-#ifndef REMOTE_APPSERVER
 			// we need a graphics
 			if ( mpGraphics || ImplGetGraphics() )
 			{
@@ -1490,15 +1543,11 @@ void OutputDevice::DrawPixel( const Poly
 					mpGraphics->DrawPixel( aPt.X(), aPt.Y(), ImplColorToSal( pColors[ i ] ), this );
 				}
 			}
-#else
-			ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-			if ( pGraphics )
-			{
-				pGraphics->DrawPixel( ImplLogicToDevicePixel( rPts ), pColors );
-			}
-#endif
 		}
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPixel( rPts, pColors );
 }
 
 // -----------------------------------------------------------------------
@@ -1516,6 +1565,9 @@ void OutputDevice::DrawPixel( const Poly
 		DrawPixel( rPts, pColArray );
 		delete[] pColArray;
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPixel( rPts, rColor );
 }
 
 // ------------------------------------------------------------------------
@@ -1552,6 +1604,8 @@ void OutputDevice::ImplDrawAlpha( const 
 
 	if( !aDstRect.Intersection( Rectangle( aOutPt, aOutSz ) ).IsEmpty() )
 	{
+        VirtualDevice* pOldVDev = mpAlphaVDev;
+
 		Rectangle aBmpRect( aPt, rBmp.GetSizePixel() );
 
 		if( !aBmpRect.Intersection( Rectangle( rSrcPtPixel, rSrcSizePixel ) ).IsEmpty() )
@@ -1567,6 +1621,11 @@ void OutputDevice::ImplDrawAlpha( const 
             // access)
             aDstRect.SetSize( aBmp.GetSizePixel() );
 
+            // #110958# Disable alpha VDev, we're doing the necessary
+            // stuff explicitely furher below
+            if( mpAlphaVDev )
+                mpAlphaVDev = NULL;
+
 			BitmapColor 	aDstCol;
 			const long		nSrcWidth = aBmpRect.GetWidth(), nSrcHeight = aBmpRect.GetHeight();
 			const long		nDstWidth = aDstRect.GetWidth(), nDstHeight = aDstRect.GetHeight();
@@ -1600,12 +1659,17 @@ void OutputDevice::ImplDrawAlpha( const 
 					pMapY[ nY ] = nMirrOffY - pMapY[ nY ];
 			}
 
+            BitmapReadAccess*	pP = ( (Bitmap&) rBmp ).AcquireReadAccess();
+            BitmapReadAccess*	pA = ( (AlphaMask&) rAlpha ).AcquireReadAccess();
+
+            DBG_ASSERT( pA->GetScanlineFormat() == BMP_FORMAT_8BIT_PAL ||
+                        pA->GetScanlineFormat() == BMP_FORMAT_8BIT_TC_MASK, 
+                        "OutputDevice::ImplDrawAlpha(): non-8bit alpha no longer supported!" );
+            
 			if( GetBitCount() <= 8 )
 			{
 				Bitmap				aDither( aBmp.GetSizePixel(), 8 );
 				BitmapColor 		aIndex( 0 );
-				BitmapReadAccess*	pP = ( (Bitmap&) rBmp ).AcquireReadAccess();
-				BitmapReadAccess*	pA = ( (AlphaMask&) rAlpha ).AcquireReadAccess();
 				BitmapReadAccess*	pB = aBmp.AcquireReadAccess();
 				BitmapWriteAccess*	pW = aDither.AcquireWriteAccess();
 
@@ -1631,126 +1695,210 @@ void OutputDevice::ImplDrawAlpha( const 
 					}
 				}
 
-				( (Bitmap&) rBmp ).ReleaseAccess( pP );
-				( (AlphaMask&) rAlpha ).ReleaseAccess( pA );
 				aBmp.ReleaseAccess( pB );
 				aDither.ReleaseAccess( pW );
 				DrawBitmap( aDstRect.TopLeft(), aDither );
 			}
 			else
 			{
-				BitmapReadAccess*	pP = ( (Bitmap&) rBmp ).AcquireReadAccess();
-				BitmapReadAccess*	pA = ( (AlphaMask&) rAlpha ).AcquireReadAccess();
 				BitmapWriteAccess*	pB = aBmp.AcquireWriteAccess();
 
 				if( pP && pA && pB )
 				{
-					if( pA->GetScanlineFormat() == BMP_FORMAT_8BIT_PAL )
-					{
-						switch( pP->GetScanlineFormat() )
-						{
-							case( BMP_FORMAT_8BIT_PAL ):
-							{
-								for( nY = 0; nY < nDstHeight; nY++ )
-								{
-									const long	nMapY = pMapY[ nY ];
-									Scanline	pPScan = pP->GetScanline( nMapY );
-									Scanline	pAScan = pA->GetScanline( nMapY );
-
-									for( nX = 0; nX < nDstWidth; nX++ )
-									{
-										const long nMapX = pMapX[ nX ];
-										aDstCol = pB->GetPixel( nY, nX );
-										pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetPaletteColor( pPScan[ nMapX ] ),
-																			 pAScan[ nMapX ] ) );
-									}
-								}
-							}
-							break;
-
-							case( BMP_FORMAT_24BIT_TC_BGR ):
-							{
-								for( nY = 0; nY < nDstHeight; nY++ )
-								{
-									const long	nMapY = pMapY[ nY ];
-									Scanline	pPScan = pP->GetScanline( nMapY );
-									Scanline	pAScan = pA->GetScanline( nMapY );
-
-									for( nX = 0; nX < nDstWidth; nX++ )
-									{
-										const long	nMapX = pMapX[ nX ];
-										Scanline	pTmp = pPScan + nMapX * 3;
-
-										aDstCol = pB->GetPixel( nY, nX );
-										pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 2 ], pTmp[ 1 ], pTmp[ 0 ],
-																			 pAScan[ nMapX ] ) );
-									}
-								}
-							}
-							break;
-
-							case( BMP_FORMAT_24BIT_TC_RGB ):
-							{
-								for( nY = 0; nY < nDstHeight; nY++ )
-								{
-									const long	nMapY = pMapY[ nY ];
-									Scanline	pPScan = pP->GetScanline( nMapY );
-									Scanline	pAScan = pA->GetScanline( nMapY );
-
-									for( nX = 0; nX < nDstWidth; nX++ )
-									{
-										const long	nMapX = pMapX[ nX ];
-										Scanline	pTmp = pPScan + nMapX * 3;
-
-										aDstCol = pB->GetPixel( nY, nX );
-										pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 0 ], pTmp[ 1 ], pTmp[ 2 ],
-																			 pAScan[ nMapX ] ) );
-									}
-								}
-							}
-							break;
-
-							default:
-							{
-								for( nY = 0; nY < nDstHeight; nY++ )
-								{
-									const long	nMapY = pMapY[ nY ];
-									Scanline	pAScan = pA->GetScanline( nMapY );
-
-									for( nX = 0; nX < nDstWidth; nX++ )
-									{
-										const long nMapX = pMapX[ nX ];
-										aDstCol = pB->GetPixel( nY, nX );
-										pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetColor( nMapY, nMapX ),
-																			 pAScan[ nMapX ] ) );
-									}
-								}
-							}
-							break;
-						}
-					}
-					else
-					{
-						for( nY = 0; nY < nDstHeight; nY++ )
-						{
-							const long nMapY = pMapY[ nY ];
-
-							for( nX = 0; nX < nDstWidth; nX++ )
-							{
-								const long nMapX = pMapX[ nX ];
-								aDstCol = pB->GetPixel( nY, nX );
-								pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetColor( nMapY, nMapX ),
-																	 (BYTE) pA->GetPixel( nMapY, nMapX ) ) );
-							}
-						}
-					}
+                    switch( pP->GetScanlineFormat() )
+                    {
+                        case( BMP_FORMAT_8BIT_PAL ):
+                        {
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pPScan = pP->GetScanline( nMapY );
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long nMapX = pMapX[ nX ];
+                                    aDstCol = pB->GetPixel( nY, nX );
+                                    pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetPaletteColor( pPScan[ nMapX ] ),
+                                                                         pAScan[ nMapX ] ) );
+                                }
+                            }
+                        }
+                        break;
+
+                        case( BMP_FORMAT_24BIT_TC_BGR ):
+                        {
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pPScan = pP->GetScanline( nMapY );
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long	nMapX = pMapX[ nX ];
+                                    Scanline	pTmp = pPScan + nMapX * 3;
+
+                                    aDstCol = pB->GetPixel( nY, nX );
+                                    pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 2 ], pTmp[ 1 ], pTmp[ 0 ],
+                                                                         pAScan[ nMapX ] ) );
+                                }
+                            }
+                        }
+                        break;
+
+                        case( BMP_FORMAT_24BIT_TC_RGB ):
+                        {
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pPScan = pP->GetScanline( nMapY );
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long	nMapX = pMapX[ nX ];
+                                    Scanline	pTmp = pPScan + nMapX * 3;
+
+                                    aDstCol = pB->GetPixel( nY, nX );
+                                    pB->SetPixel( nY, nX, aDstCol.Merge( pTmp[ 0 ], pTmp[ 1 ], pTmp[ 2 ],
+                                                                         pAScan[ nMapX ] ) );
+                                }
+                            }
+                        }
+                        break;
+
+                        default:
+                        {
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long nMapX = pMapX[ nX ];
+                                    aDstCol = pB->GetPixel( nY, nX );
+                                    pB->SetPixel( nY, nX, aDstCol.Merge( pP->GetColor( nMapY, nMapX ),
+                                                                         pAScan[ nMapX ] ) );
+                                }
+                            }
+                        }
+                        break;
+                    }
 				}
 
-				( (Bitmap&) rBmp ).ReleaseAccess( pP );
-				( (AlphaMask&) rAlpha ).ReleaseAccess( pA );
 				aBmp.ReleaseAccess( pB );
 				DrawBitmap( aDstRect.TopLeft(), aBmp );
 			}
+
+            // #110958# Enable alpha VDev again
+            mpAlphaVDev = pOldVDev;
+
+            // #110958# Perform merging of bitmap and VDev alpha channel
+            if( mpAlphaVDev )
+            {
+                BOOL bOldMapMode( IsMapModeEnabled() );
+                mpAlphaVDev->EnableMapMode(FALSE);
+                Bitmap aBitmap( mpAlphaVDev->GetBitmap( aDstRect.TopLeft(), aDstRect.GetSize() ) );
+				BitmapWriteAccess*	pW = aBitmap.AcquireWriteAccess();
+                BYTE nAlpha;
+
+                if( pW && pA )
+                {
+                    if( mpAlphaVDev->GetBitCount() < 8 )
+                    {
+                        // Less than 8 bit for backbuffer - try dithering of alpha channel
+                        BitmapColor	aIndex( 0 );
+
+                        for( nY = 0, nOutY = nOffY; nY < nDstHeight; nY++, nOutY++ )
+                        {
+                            const long nMapY = pMapY[ nY ];
+                            const long nModY = ( nOutY & 0x0FL ) << 4L;
+                            Scanline  pAScan = pA->GetScanline( nMapY );
+
+                            for( nX = 0, nOutX = nOffX; nX < nDstWidth; nX++, nOutX++ )
+                            {
+                                const long	nMapX = pMapX[ nX ];
+                                const ULONG nD = nVCLDitherLut[ nModY | ( nOutX & 0x0FL ) ];
+
+                                nAlpha = pAScan[ nMapX ];
+
+                                // Have to perform the compositing
+                                // 'algebra' in the inverse alpha
+                                // space (with 255 meaning opaque),
+                                // otherwise, transitivity is not
+                                // achieved.
+                                nAlpha = 255-COLOR_CHANNEL_MERGE( 255, (BYTE) 255-pW->GetColor( nY, nX ), 255-nAlpha );
+
+                                aIndex.SetIndex( (BYTE) ( nVCLRLut[ ( nVCLLut[ nAlpha ] + nD ) >> 16UL ] +
+                                                          nVCLGLut[ ( nVCLLut[ nAlpha ] + nD ) >> 16UL ] +
+                                                          nVCLBLut[ ( nVCLLut[ nAlpha ] + nD ) >> 16UL ] ) );
+                                pW->SetPixel( nY, nX, aIndex );
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if( pW->GetScanlineFormat() == BMP_FORMAT_8BIT_PAL ||
+                            pW->GetScanlineFormat() == BMP_FORMAT_8BIT_TC_MASK )
+                        {
+                            // optimized handling for 8 bit alpha - 8 bit backbuffer
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pWScan = pW->GetScanline( nY );
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+                                
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long nMapX = pMapX[ nX ];
+
+                                    nAlpha = pAScan[ nMapX ];
+
+                                    // Have to perform the compositing
+                                    // 'algebra' in the inverse alpha
+                                    // space (with 255 meaning opaque),
+                                    // otherwise, transitivity is not
+                                    // achieved.
+                                    pWScan[ nX ] = 255 - COLOR_CHANNEL_MERGE( 255, 255-pWScan[ nX ], 255-nAlpha );
+                                }
+                            }
+                        }
+                        else
+                        {
+                            // optimized handling for 8 bit alpha - >8 bit backbuffer
+                            for( nY = 0; nY < nDstHeight; nY++ )
+                            {
+                                const long	nMapY = pMapY[ nY ];
+                                Scanline	pAScan = pA->GetScanline( nMapY );
+                                
+                                for( nX = 0; nX < nDstWidth; nX++ )
+                                {
+                                    const long nMapX = pMapX[ nX ];
+                                    nAlpha = pAScan[ nMapX ];
+
+                                    // Have to perform the compositing
+                                    // 'algebra' in the inverse alpha
+                                    // space (with 255 meaning opaque),
+                                    // otherwise, transitivity is not
+                                    // achieved.
+                                    nAlpha = 255 - COLOR_CHANNEL_MERGE( 255, 255-pW->GetColor( nY, nX ).GetBlue(), 255-nAlpha );
+
+                                    pW->SetPixel( nY, nX, Color(nAlpha, nAlpha, nAlpha) );
+                                }
+                            }
+                        }
+                    }
+                }
+                                
+                aBitmap.ReleaseAccess( pW );
+ 				mpAlphaVDev->DrawBitmap( aDstRect.TopLeft(), aBitmap );
+                mpAlphaVDev->EnableMapMode( bOldMapMode );
+            }
+            
+            ( (Bitmap&) rBmp ).ReleaseAccess( pP );
+            ( (AlphaMask&) rAlpha ).ReleaseAccess( pA );
 
 			delete[] pMapX;
 			delete[] pMapY;
Index: vcl/source/gdi/outdev3.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev3.cxx,v
retrieving revision 1.155.20.6
retrieving revision 1.173
diff -u -p -u -r1.155.20.6 -r1.173
--- vcl/source/gdi/outdev3.cxx	13 Feb 2004 14:03:37 -0000	1.155.20.6
+++ vcl/source/gdi/outdev3.cxx	25 Jun 2004 15:16:20 -0000	1.173
@@ -59,27 +59,20 @@
  *
  ************************************************************************/
 
-#include <math.h>
-#include <string.h>
+#include <cmath>
+#include <cstring>
 
+#ifndef _ISOLANG_HXX
+#include <tools/isolang.hxx>
+#endif
 
-#define _SV_OUTDEV_CXX
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif // REMOTE_APPSERVER
 
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
@@ -110,8 +103,8 @@
 #ifndef _SV_OUTFONT_HXX
 #include <outfont.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_OUTDEV_H
 #include <outdev.h>
@@ -153,6 +146,10 @@
 #include <osl/file.h>
 #endif
 
+#ifndef _SV_GLYPHCACHE_HXX
+#include <glyphcache.hxx>
+#endif
+
 #include <unohelp.hxx>
 #ifndef _VCL_PDFWRITER_IMPL_HXX
 #include <pdfwriter_impl.hxx>
@@ -179,11 +176,12 @@
 #define GLYPH_FONT_HEIGHT   256
 #endif
 
-#if defined(WIN32)
-#include <malloc.h>
-#define alloca _alloca
-#elif defined(SOLARIS) || defined(IRIX)
-#include <alloca.h>
+#if defined(SOLARIS) || defined(IRIX)
+  #include <alloca.h>
+#else
+#ifndef MACOSX
+  #include <malloc.h>
+#endif
 #endif
 
 #include <memory>
@@ -211,6 +209,9 @@ using namespace ::vcl;
 
 // =======================================================================
 
+//#ifdef USE_NEW_RTL_IMPLEMENTATION
+
+
 static void ImplRotatePos( long nOriginX, long nOriginY, long& rX, long& rY,
                            int nOrientation )
 {
@@ -296,11 +297,7 @@ void OutputDevice::ImplUpdateFontData( B
         if ( bNewFontLists )
         {
             // we need a graphics
-#ifndef REMOTE_APPSERVER
             if ( ImplGetGraphics() )
-#else
-            if ( ImplGetServerGraphics() )
-#endif
             {
                 if( mpFontList && mpFontList != pSVData->maGDIData.mpScreenFontList )
                     mpFontList->Clear();
@@ -395,10 +392,9 @@ void OutputDevice::ImplUpdateAllFontData
         pFrame = pSVData->maWinData.mpFirstFrame;
         if ( pFrame )
         {
-#ifndef REMOTE_APPSERVER
             if ( pFrame->ImplGetGraphics() )
-#endif
-                pFrame->mpGraphics->GetDevFontList( pFrame->mpFrameData->mpFontList );
+                // MT: Stupid typecast here and somewhere ((OutputDevice*)&aVDev)->, because bug in .NET2002 compiler.
+                ((OutputDevice*)pFrame)->mpGraphics->GetDevFontList( pFrame->mpFrameData->mpFontList );
         }
     }
 }
@@ -908,8 +904,8 @@ void OutputDevice::GetFontSubstitute( US
 
 // -----------------------------------------------------------------------
 
-static void ImplFontSubstitute( String& rFontName,
-                                USHORT nFlags, ImplFontSubstEntry* pDevSpecific )
+static BOOL ImplFontSubstitute( XubString& rFontName,
+                                USHORT nFlags1, USHORT nFlags2, ImplFontSubstEntry* pDevSpecific )
 {
 #ifdef DBG_UTIL
     String aTempName = rFontName;
@@ -917,33 +913,36 @@ static void ImplFontSubstitute( String& 
     DBG_ASSERT( aTempName == rFontName, "ImplFontSubstitute() called without a searchname" );
 #endif
 
-    // apply global replacement (e.g. from the Tools->Options->Fonts dialog)
-    ImplSVData* pSVData = ImplGetSVData();
-    const ImplFontSubstEntry* pEntry = pSVData->maGDIData.mpFirstFontSubst;
-    for(; pEntry; pEntry = pEntry->mpNext ) // linear search => TODO
+    // apply font replacement (eg, from the list in Tools->Options)
+    ImplSVData*         pSVData = ImplGetSVData();
+    ImplFontSubstEntry* pEntry = pSVData->maGDIData.mpFirstFontSubst;
+    while ( pEntry )
     {
-        // replace if ALWAYS or SCREENONLY flags match or nFlags is zero
-        if(((pEntry->mnFlags & nFlags) || !nFlags)
-        &&  (pEntry->maSearchName == rFontName) )
+        if ( ((pEntry->mnFlags & nFlags1) == nFlags2) &&
+             (pEntry->maSearchName == rFontName) )
         {
             rFontName = pEntry->maSearchReplaceName;
-            return;
+            return TRUE;
         }
-    }
 
-    // apply device specific replacement (e.g. Arial->Helvetica on a PS printer)
+        pEntry = pEntry->mpNext;
+    }
     if( pDevSpecific )
     {
-        for( pEntry = pDevSpecific; pEntry; pEntry = pEntry->mpNext )
+        pEntry = pDevSpecific;
+        while ( pEntry )
         {
-            if(((pEntry->mnFlags & nFlags) || !nFlags)
-            &&  (pEntry->maSearchName == rFontName) )
+            if ( ((pEntry->mnFlags & nFlags1) == nFlags2) &&
+                 (pEntry->maSearchName == rFontName) )
             {
                 rFontName = pEntry->maSearchReplaceName;
-                return;
+                return TRUE;
             }
+            pEntry = pEntry->mpNext;
         }
     }
+
+    return FALSE;
 }
 
 // =======================================================================
@@ -1034,14 +1033,25 @@ static void ImplAddTokenFontNames( Strin
 Font OutputDevice::GetDefaultFont( USHORT nType, LanguageType eLang,
                                    ULONG nFlags, const OutputDevice* pOutDev )
 {
+    DBG_TRACE( "OutputDevice::GetDefaultFont()" );
+
+    com::sun::star::lang::Locale aLocale;
     if( eLang == LANGUAGE_NONE || eLang == LANGUAGE_SYSTEM || eLang == LANGUAGE_DONTKNOW )
     {
-        eLang = Application::GetSettings().GetUILanguage();
+        aLocale = Application::GetSettings().GetUILocale();
     }
+    else
+    {
+        String aLang, aCountry;
+        ConvertLanguageToIsoNames( eLang, aLang, aCountry );
+        aLocale.Language= aLang;
+        aLocale.Country = aCountry;
+    }
+
 
     DefaultFontConfigItem* pDefaults = DefaultFontConfigItem::get();
-    String aSearch = pDefaults->getUserInterfaceFont( eLang ); // ensure a fallback
-    String aDefault = pDefaults->getDefaultFont( eLang, nType );
+    String aSearch = pDefaults->getUserInterfaceFont( aLocale ); // ensure a fallback
+    String aDefault = pDefaults->getDefaultFont( aLocale, nType );
     if( aDefault.Len() )
         aSearch = aDefault;
 
@@ -1166,6 +1176,47 @@ Font OutputDevice::GetDefaultFont( USHOR
                 aFont.SetName( aSearch );
         }
     }
+
+#if OSL_DEBUG_LEVEL > 2
+    const char* s = "DEFAULTFONT_SANS_UNKNOWN";
+    switch ( nType )
+    {
+	case DEFAULTFONT_SANS_UNICODE:	s = "DEFAULTFONT_SANS_UNICODE"; break;
+	case DEFAULTFONT_UI_SANS:	s = "DEFAULTFONT_UI_SANS"; break;
+
+	case DEFAULTFONT_SANS:	s = "DEFAULTFONT_SANS"; break;
+	case DEFAULTFONT_LATIN_HEADING:	s = "DEFAULTFONT_LATIN_HEADING"; break;
+	case DEFAULTFONT_LATIN_SPREADSHEET:	s = "DEFAULTFONT_LATIN_SPREADSHEET"; break;
+	case DEFAULTFONT_LATIN_DISPLAY:	s = "DEFAULTFONT_LATIN_DISPLAY"; break;
+
+	case DEFAULTFONT_SERIF:	s = "DEFAULTFONT_SERIF"; break;
+	case DEFAULTFONT_LATIN_TEXT:	s = "DEFAULTFONT_LATIN_TEXT"; break;
+	case DEFAULTFONT_LATIN_PRESENTATION:	s = "DEFAULTFONT_LATIN_PRESENTATION"; break;
+
+	case DEFAULTFONT_FIXED:	s = "DEFAULTFONT_FIXED"; break;
+	case DEFAULTFONT_LATIN_FIXED:	s = "DEFAULTFONT_LATIN_FIXED"; break;
+	case DEFAULTFONT_UI_FIXED:	s = "DEFAULTFONT_UI_FIXED"; break;
+
+	case DEFAULTFONT_SYMBOL:	s = "DEFAULTFONT_SYMBOL"; break;
+
+	case DEFAULTFONT_CJK_TEXT:	s = "DEFAULTFONT_CJK_TEXT"; break;
+	case DEFAULTFONT_CJK_PRESENTATION:	s = "DEFAULTFONT_CJK_PRESENTATION"; break;
+	case DEFAULTFONT_CJK_SPREADSHEET:	s = "DEFAULTFONT_CJK_SPREADSHEET"; break;
+	case DEFAULTFONT_CJK_HEADING:	s = "DEFAULTFONT_CJK_HEADING"; break;
+	case DEFAULTFONT_CJK_DISPLAY:	s = "DEFAULTFONT_CJK_DISPLAY"; break;
+
+	case DEFAULTFONT_CTL_TEXT:	s = "DEFAULTFONT_CTL_TEXT"; break;
+	case DEFAULTFONT_CTL_PRESENTATION:	s = "DEFAULTFONT_CTL_PRESENTATION"; break;
+	case DEFAULTFONT_CTL_SPREADSHEET:	s = "DEFAULTFONT_CTL_SPREADSHEET"; break;
+	case DEFAULTFONT_CTL_HEADING:	s = "DEFAULTFONT_CTL_HEADING"; break;
+	case DEFAULTFONT_CTL_DISPLAY:	s = "DEFAULTFONT_CTL_DISPLAY"; break;
+    }
+    fprintf( stderr, "   OutputDevice::GetDefaultFont() Type=\"%s\" lang=%d flags=%d FontName=\"%s\"\n",
+	     s, eLang, nFlags,
+	     OUStringToOString( aFont.GetName(), osl_getThreadTextEncoding() ).getStr()
+	     );
+#endif
+
     return aFont;
 }
 
@@ -1291,8 +1342,7 @@ static void ImplCalcType( ULONG& rType, 
 
 // =======================================================================
 
-ImplDevFontList::ImplDevFontList() :
-    List( CONTAINER_MAXBLOCKSIZE, 96, 32 )
+ImplDevFontList::ImplDevFontList() : List( CONTAINER_MAXBLOCKSIZE, 96, 32 )
 {
     mbMatchData = FALSE;
     mbMapNames  = FALSE;
@@ -1319,7 +1369,9 @@ void ImplDevFontList::ImplClear()
             ImplFontData* pNextFD = pFontData->mpNext;
 
             // tell lower layers about the imminent death
-            SalGraphics::RemovingFont( pFontData );
+#ifdef UNX
+            GlyphCache::GetInstance().RemoveFont( pFontData );
+#endif
             delete pFontData;
 
             pFontData = pNextFD;
@@ -1800,24 +1852,24 @@ ImplFontEntry* ImplFontCache::Get( ImplD
 
     ImplDevFontListData*    pFoundData;
     String                  aSearchName;
+    USHORT                  nSubstFlags1 = FONT_SUBSTITUTE_ALWAYS;
+    USHORT                  nSubstFlags2 = FONT_SUBSTITUTE_ALWAYS;
+    xub_StrLen              nFirstNameIndex = 0;
     xub_StrLen              nIndex = 0;
     int                     nToken = 0;
     ULONG                   i;
 
-    USHORT nSubstFlags = FONT_SUBSTITUTE_ALWAYS;
-    if ( !mbPrinter )
-        nSubstFlags |= FONT_SUBSTITUTE_SCREENONLY;
-
-    // check if the first font in the semicolon separated list of font names
-    // is available, substitute the font there is a matching entry in the
-    // Tools->Options->Fonts dialog with ALWAYS or SCREENONLY flags set
+    if ( mbPrinter )
+        nSubstFlags1 |= FONT_SUBSTITUTE_SCREENONLY;
+
+    // Test if one Font in the name list is available
     do
     {
         nToken++;
         String aToken = GetFontToken( aName, 0, nIndex );
         aSearchName = aToken;
         ImplGetEnglishSearchFontName( aSearchName );
-        ImplFontSubstitute( aSearchName, nSubstFlags, pDevSpecific );
+        ImplFontSubstitute( aSearchName, nSubstFlags1, nSubstFlags2, pDevSpecific );
         pFoundData = pFontList->ImplFind( aSearchName );
         if( pFoundData )
         {
@@ -1827,13 +1879,14 @@ ImplFontEntry* ImplFontCache::Get( ImplD
     }
     while ( nIndex != STRING_NOTFOUND );
 
-    // if the first font was not available find the next available font in
-    // the semicolon separated list of font names. A font is also considered
-    // available when there is a matching entry in the Tools->Options->Fonts
-    // dialog witho neither ALWAYS nor SCREENONLY flags set and the substitution
-    // font is available
-    if( !pFoundData )
+    // Danach versuchen wir es nocheinmal unter Beruecksichtigung
+    // der gloablen Fontersetzungstabelle, wobei wir jetzt auch
+    // die Fonts nehmen, die ersetzt werden sollen, wenn sie
+    // nicht vorhanden sind
+    if ( !pFoundData )
     {
+        nSubstFlags1 &= ~FONT_SUBSTITUTE_ALWAYS;
+        nSubstFlags2 &= ~FONT_SUBSTITUTE_ALWAYS;
         nIndex = 0;
         do
         {
@@ -1844,7 +1897,7 @@ ImplFontEntry* ImplFontCache::Get( ImplD
             }
             else
                 nIndex = STRING_NOTFOUND;
-            ImplFontSubstitute( aSearchName, 0, pDevSpecific );
+            ImplFontSubstitute( aSearchName, nSubstFlags1, nSubstFlags2, pDevSpecific );
             pFoundData = pFontList->ImplFind( aSearchName );
             if( pFoundData )
                 break;
@@ -1917,7 +1970,9 @@ ImplFontEntry* ImplFontCache::Get( ImplD
 
         if ( !pFoundData && bSymbolEncoding )
         {
-            String aFontname = DefaultFontConfigItem::get()->getDefaultFont( LANGUAGE_ENGLISH, DEFAULTFONT_SYMBOL );
+            com::sun::star::lang::Locale aLocale( OUString( RTL_CONSTASCII_USTRINGPARAM("en") ),
+                                                  OUString(), OUString() );
+            String aFontname = DefaultFontConfigItem::get()->getDefaultFont( aLocale, DEFAULTFONT_SYMBOL );
             ImplGetEnglishSearchFontName( aFontname );
             pFoundData = pFontList->ImplFindFontFromToken( aFontname );
         }
@@ -2378,23 +2433,25 @@ ImplFontEntry* ImplFontCache::Get( ImplD
             // Try to use a Standard Unicode or a Standard Font to get
             // as max as possible characters
             DefaultFontConfigItem* pDefaults = DefaultFontConfigItem::get();
-            String aFontname = pDefaults->getDefaultFont( LANGUAGE_ENGLISH, DEFAULTFONT_SANS_UNICODE );
+            com::sun::star::lang::Locale aLoc( OUString( RTL_CONSTASCII_USTRINGPARAM( "en" ) ),
+                                               OUString(), OUString() );
+            String aFontname = pDefaults->getDefaultFont( aLoc, DEFAULTFONT_SANS_UNICODE );
             ImplGetEnglishSearchFontName( aFontname );
 
             pFoundData = pFontList->ImplFindFontFromToken( aFontname );
             if ( !pFoundData )
             {
-                aFontname = pDefaults->getDefaultFont( LANGUAGE_ENGLISH, DEFAULTFONT_SANS );
+                aFontname = pDefaults->getDefaultFont( aLoc, DEFAULTFONT_SANS );
                 ImplGetEnglishSearchFontName( aFontname );
                 pFoundData = pFontList->ImplFindFontFromToken( aFontname );
                 if ( !pFoundData )
                 {
-                    aFontname = pDefaults->getDefaultFont( LANGUAGE_ENGLISH, DEFAULTFONT_SERIF );
+                    aFontname = pDefaults->getDefaultFont( aLoc, DEFAULTFONT_SERIF );
                     ImplGetEnglishSearchFontName( aFontname );
                     pFoundData = pFontList->ImplFindFontFromToken( aFontname );
                     if ( !pFoundData )
                     {
-                        aFontname = pDefaults->getDefaultFont( LANGUAGE_ENGLISH, DEFAULTFONT_FIXED );
+                        aFontname = pDefaults->getDefaultFont( aLoc, DEFAULTFONT_FIXED );
                         ImplGetEnglishSearchFontName( aFontname );
                         pFoundData = pFontList->ImplFindFontFromToken( aFontname );
                     }
@@ -2626,7 +2683,7 @@ ImplFontEntry* ImplFontCache::GetFallbac
     {
         // TODO: implement dynamic lists or improve static lists
         #define FALLBACKFONT_NAMELIST \
-            "arialunicodems;andalesansui;cyberbit;starsymbol;opensymbol;lucidatypeWriter;"  \
+            "arialunicodems;andalesansui;cyberbit;starsymbol;opensymbol;lucidatypewriter;"  \
             "fzmingti;sunbatang;sundotum;baekmukdotum;"                     \
             "hgmincholightj;msunglightsc;msunglighttc;hymyeongjolightk;"    \
             "lucidasans;tahoma;"                                            \
@@ -2730,7 +2787,6 @@ void ImplFontCache::Clear()
     }
 
     // #112304# make sure the font cache is really clean
-    // #112304# there are still referenced entries
     mpFirstEntry = NULL;
 
     DBG_ASSERT( (mnRef0Count==0), "ImplFontCache::Clear() - mnRef0Count non-zero" );
@@ -2871,11 +2927,7 @@ void OutputDevice::ImplInitTextColor()
 
     if ( mbInitTextColor )
     {
-#ifndef REMOTE_APPSERVER
         mpGraphics->SetTextColor( ImplColorToSal( GetTextColor() ) );
-#else
-        mpGraphics->SetTextColor( GetTextColor() );
-#endif
         mbInitTextColor = FALSE;
     }
 }
@@ -2900,16 +2952,10 @@ int OutputDevice::ImplNewFont()
 
     mbNewFont = FALSE;
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if ( !mpGraphics && !ImplGetGraphics() )
         return FALSE;
     SalGraphics* pGraphics = mpGraphics;
-#else
-    // due to clipping we may get NULL, so don't use return value
-    ImplGetServerGraphics();
-    ImplServerGraphics* pGraphics = mpGraphics;
-#endif
     ImplInitFontList();
 
     // convert to pixel height
@@ -3006,16 +3053,7 @@ int OutputDevice::ImplNewFont()
                 mpPDFWriter->getFontMetric( &pFontEntry->maFontSelData, &(pFontEntry->maMetric) );
             else
             {
-#ifndef REMOTE_APPSERVER
                 pGraphics->GetFontMetric( &(pFontEntry->maMetric) );
-#else
-                long nFactor = 0;
-                pGraphics->GetFontMetric(
-                                         pFontEntry->maMetric, nFactor,
-                                         0x21, 0x20, NULL,
-                                         (maFont.GetKerning() & KERNING_FONTSPECIFIC) != 0,
-                                         &pKernPairs, nKernPairs );
-#endif
             }
 
             pFontEntry->mbFixedFont     = pFontEntry->maMetric.mePitch == PITCH_FIXED;
@@ -3122,9 +3160,10 @@ inline bool CmpKernData( const ImplKernP
 
 static void ImplSortKernPairs( ImplKernPairData* pKernPairs, long l, long r )
 {
-#if 1 // TODO: use STL's insertion sort
-    long                i = l;
+	// TODO: use STL's insertion sort
+	// std::sort( pKernPairs+l, pKernPairs+r, CmpKernData );
 
+	long                i = l;
     long                j = r;
     ImplKernPairData*   pComp = pKernPairs + ((l+r) >> 1);
     sal_uInt32          nComp = *((sal_uInt32*)pComp);
@@ -3150,9 +3189,6 @@ static void ImplSortKernPairs( ImplKernP
         ImplSortKernPairs( pKernPairs, l, j );
     if ( i < r )
         ImplSortKernPairs( pKernPairs, i, r );
-#else
-    std::sort( pKernPairs+l, pKernPairs+r, CmpKernData );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -3174,7 +3210,6 @@ void OutputDevice::ImplInitKerningPairs(
             pFontEntry->mpKernPairs = NULL;
             return;
         }
-#ifndef REMOTE_APPSERVER
         pFontEntry->mnKernPairs = mpGraphics->GetKernPairs( 0, NULL );
         if ( pFontEntry->mnKernPairs )
         {
@@ -3183,12 +3218,6 @@ void OutputDevice::ImplInitKerningPairs(
             pFontEntry->mnKernPairs = mpGraphics->GetKernPairs( pFontEntry->mnKernPairs, pKernPairs );
             pFontEntry->mpKernPairs = pKernPairs;
         }
-#else
-        if ( !pKernPairs )
-            nKernPairs = mpGraphics->GetKernPairs( &pKernPairs );
-        if ( nKernPairs )
-            pFontEntry->mpKernPairs = pKernPairs;
-#endif
 
         // Sort Kerning Pairs
         if ( pFontEntry->mpKernPairs )
@@ -3256,21 +3285,12 @@ void OutputDevice::ImplDrawTextRect( lon
             Rectangle aRect( Point( nX, nY ), Size( nWidth+1, nHeight+1 ) );
             Polygon   aPoly( aRect );
             aPoly.Rotate( Point( nBaseX, nBaseY ), mpFontEntry->mnOrientation );
-#ifndef REMOTE_APPSERVER
             ImplDrawPolygon( aPoly );
-#else
-            mpGraphics->DrawPolygon( aPoly );
-#endif
             return;
         }
     }
 
-#ifndef REMOTE_APPSERVER
     mpGraphics->DrawRect( nX, nY, nWidth, nHeight, this );
-#else
-    Rectangle aRect( Point( nX, nY ), Size( nWidth, nHeight ) );
-    mpGraphics->DrawRect( aRect );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -3282,7 +3302,6 @@ void OutputDevice::ImplDrawTextBackgroun
     long nX = aBase.X();
     long nY = aBase.Y();
 
-#ifndef REMOTE_APPSERVER
     if ( mbLineColor || mbInitLineColor )
     {
         mpGraphics->SetLineColor();
@@ -3294,21 +3313,6 @@ void OutputDevice::ImplDrawTextBackgroun
     ImplDrawTextRect( nX, nY, nX, nY-mpFontEntry->maMetric.mnAscent-mnEmphasisAscent,
                       nWidth,
                       mpFontEntry->mnLineHeight+mnEmphasisAscent+mnEmphasisDescent );
-#else
-    Color aOldLineColor = GetLineColor();
-    Color aOldFillColor = GetFillColor();
-    SetLineColor();
-    SetFillColor( GetTextFillColor() );
-    if ( mbInitLineColor )
-        ImplInitLineColor();
-    if ( mbInitFillColor )
-        ImplInitFillColor();
-    ImplDrawTextRect( nX, nY, nX, nY-mpFontEntry->maMetric.mnAscent-mnEmphasisAscent,
-                      nWidth,
-                      mpFontEntry->mnLineHeight+mnEmphasisAscent+mnEmphasisDescent );
-    SetLineColor( aOldLineColor );
-    SetFillColor( aOldFillColor );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -3542,11 +3545,7 @@ void OutputDevice::ImplInitAboveTextLine
 static void ImplDrawWavePixel( long nOriginX, long nOriginY,
                                long nCurX, long nCurY,
                                short nOrientation,
-#ifndef REMOTE_APPSERVER
                                SalGraphics* pGraphics,
-#else
-                               ImplServerGraphics* pGraphics,
-#endif
                                OutputDevice* pOutDev,
                                BOOL bDrawPixAsRect,
 
@@ -3557,24 +3556,12 @@ static void ImplDrawWavePixel( long nOri
 
     if ( bDrawPixAsRect )
     {
-#ifndef REMOTE_APPSERVER
 
         pGraphics->DrawRect( nCurX, nCurY, nPixWidth, nPixHeight, pOutDev );
-#else
-        Point       aPos( nCurX, nCurY );
-        Size        aSize( nPixWidth, nPixHeight );
-        Rectangle   aRect( aPos, aSize );
-        pGraphics->DrawRect( aRect );
-#endif
     }
     else
     {
-#ifndef REMOTE_APPSERVER
         pGraphics->DrawPixel( nCurX, nCurY, pOutDev );
-#else
-        Point aPos( nCurX, nCurY );
-        pGraphics->DrawPixel( aPos );
-#endif
     }
 }
 
@@ -3592,15 +3579,8 @@ void OutputDevice::ImplDrawWaveLine( lon
     // Bei Hoehe von 1 Pixel reicht es, eine Linie auszugeben
     if ( (nLineWidth == 1) && (nHeight == 1) )
     {
-#ifndef REMOTE_APPSERVER
         mpGraphics->SetLineColor( ImplColorToSal( rColor ) );
         mbInitLineColor = TRUE;
-#else
-        Color aOldLineColor = GetLineColor();
-        SetLineColor( rColor );
-        if ( mbInitLineColor )
-            ImplInitLineColor();
-#endif
 
         long nEndX = nStartX+nWidth;
         long nEndY = nStartY;
@@ -3609,15 +3589,8 @@ void OutputDevice::ImplDrawWaveLine( lon
             ImplRotatePos( nBaseX, nBaseY, nStartX, nStartY, nOrientation );
             ImplRotatePos( nBaseX, nBaseY, nEndX, nEndY, nOrientation );
         }
-#ifndef REMOTE_APPSERVER
         mpGraphics->DrawLine( nStartX, nStartY, nEndX, nEndY, this );
-#else
-        mpGraphics->DrawLine( Point( nStartX, nStartY ), Point( nEndX, nEndY ) );
-#endif
 
-#ifdef REMOTE_APPSERVER
-        SetLineColor( aOldLineColor );
-#endif
     }
     else
     {
@@ -3632,15 +3605,9 @@ void OutputDevice::ImplDrawWaveLine( lon
         long    nPixWidth;
         long    nPixHeight;
         BOOL    bDrawPixAsRect;
-#ifdef REMOTE_APPSERVER
-        Color   aOldLineColor = GetLineColor();
-        Color   aOldFillColor = GetFillColor();
-
-#endif
         // Auf Druckern die Pixel per DrawRect() ausgeben
         if ( (GetOutDevType() == OUTDEV_PRINTER) || (nLineWidth > 1) )
         {
-#ifndef REMOTE_APPSERVER
             if ( mbLineColor || mbInitLineColor )
             {
                 mpGraphics->SetLineColor();
@@ -3648,29 +3615,14 @@ void OutputDevice::ImplDrawWaveLine( lon
             }
             mpGraphics->SetFillColor( ImplColorToSal( rColor ) );
             mbInitFillColor = TRUE;
-#else
-            SetLineColor();
-            SetFillColor( rColor );
-            if ( mbInitLineColor )
-                ImplInitLineColor();
-            if ( mbInitFillColor )
-                ImplInitFillColor();
-#endif
             bDrawPixAsRect  = TRUE;
             nPixWidth       = nLineWidth;
             nPixHeight      = ((nLineWidth*mnDPIX)+(mnDPIY/2))/mnDPIY;
         }
         else
         {
-#ifndef REMOTE_APPSERVER
             mpGraphics->SetLineColor( ImplColorToSal( rColor ) );
             mbInitLineColor = TRUE;
-#else
-            Color aOldLineColor = GetLineColor();
-            SetLineColor( rColor );
-            if ( mbInitLineColor )
-                ImplInitLineColor();
-#endif
             nPixWidth       = 1;
             nPixHeight      = 1;
             bDrawPixAsRect  = FALSE;
@@ -3732,10 +3684,6 @@ void OutputDevice::ImplDrawWaveLine( lon
             }
         }
 
-#ifdef REMOTE_APPSERVER
-        SetLineColor( aOldLineColor );
-        SetFillColor( aOldFillColor );
-#endif
     }
 }
 
@@ -3877,7 +3825,13 @@ void OutputDevice::ImplDrawTextLine( lon
         {
             if( mpFontEntry->mnOrientation )
                 ImplRotatePos( nBaseX, nBaseY, nX, nY, mpFontEntry->mnOrientation );
-            SalLayout* pSalLayout = ImplLayout( aStrikeoutText, 0, STRING_LEN, Point(nX,nY) );
+
+            // strikeout text has to be left aligned
+            ULONG nOrigTLM = mnTextLayoutMode;
+            mnTextLayoutMode = TEXT_LAYOUT_BIDI_STRONG | TEXT_LAYOUT_COMPLEX_DISABLED;
+            SalLayout* pSalLayout = ImplLayout( aStrikeoutText, 0, STRING_LEN );
+            mnTextLayoutMode = nOrigTLM;
+
             if( pSalLayout )
             {
                 pSalLayout->DrawBase() = Point( nX+mnTextOffX, nY+mnTextOffY );
@@ -3898,17 +3852,20 @@ void OutputDevice::ImplDrawTextLine( lon
             case UNDERLINE_WAVE:
             case UNDERLINE_DOUBLEWAVE:
             case UNDERLINE_BOLDWAVE:
+            {
                 bNormalLines = FALSE;
+            }
+            break;
+            default: 
+            {
+                ; // We don't want a gcc warning...
+            }
+                
         }
     }
 
     if ( bNormalLines )
     {
-#ifdef REMOTE_APPSERVER
-        Color aOldLineColor = GetLineColor();
-        Color aOldFillColor = GetFillColor();
-#endif
-
         if ( eUnderline > UNDERLINE_LAST )
             eUnderline = UNDERLINE_SINGLE;
 
@@ -3981,7 +3938,6 @@ void OutputDevice::ImplDrawTextLine( lon
 
         if ( nLineHeight )
         {
-#ifndef REMOTE_APPSERVER
             if ( mbLineColor || mbInitLineColor )
             {
                 mpGraphics->SetLineColor();
@@ -3989,14 +3945,6 @@ void OutputDevice::ImplDrawTextLine( lon
             }
             mpGraphics->SetFillColor( ImplColorToSal( aUnderlineColor ) );
             mbInitFillColor = TRUE;
-#else
-            SetLineColor();
-            SetFillColor( aUnderlineColor );
-            if ( mbInitLineColor )
-                ImplInitLineColor();
-            if ( mbInitFillColor )
-                ImplInitFillColor();
-#endif
 
             nLeft = nX;
 
@@ -4173,7 +4121,6 @@ void OutputDevice::ImplDrawTextLine( lon
 
         if ( nLineHeight )
         {
-#ifndef REMOTE_APPSERVER
             if ( mbLineColor || mbInitLineColor )
             {
                 mpGraphics->SetLineColor();
@@ -4181,14 +4128,6 @@ void OutputDevice::ImplDrawTextLine( lon
             }
             mpGraphics->SetFillColor( ImplColorToSal( aStrikeoutColor ) );
             mbInitFillColor = TRUE;
-#else
-            SetLineColor();
-            SetFillColor( aStrikeoutColor );
-            if ( mbInitLineColor )
-                ImplInitLineColor();
-            if ( mbInitFillColor )
-                ImplInitFillColor();
-#endif
 
             nLeft = nX;
 
@@ -4202,10 +4141,6 @@ void OutputDevice::ImplDrawTextLine( lon
             }
         }
 
-#ifdef REMOTE_APPSERVER
-        SetLineColor( aOldLineColor );
-        SetFillColor( aOldFillColor );
-#endif
     }
 }
 
@@ -4217,10 +4152,10 @@ void OutputDevice::ImplDrawTextLines( Sa
     if( bWordLine )
     {
         Point aPos, aStartPt;
-        long nWidth = 0, nAdvance=0;
+        sal_Int32 nWidth = 0, nAdvance=0;
         for( int nStart = 0;;)
         {
-            long nGlyphIndex;
+            sal_Int32 nGlyphIndex;
             if( !rSalLayout.GetNextGlyphs( 1, &nGlyphIndex, aPos, nStart, &nAdvance ) )
                 break;
 
@@ -4486,7 +4421,7 @@ void OutputDevice::ImplDrawEmphasisMarks
     BOOL                bOldMap         = mbMap;
     GDIMetaFile*        pOldMetaFile    = mpMetaFile;
     mpMetaFile = NULL;
-    mbMap = FALSE;
+    EnableMapMode( FALSE );
 
     FontEmphasisMark    nEmphasisMark = ImplGetEmphasisMarkStyle( maFont );
     PolyPolygon         aPolyPoly;
@@ -4534,11 +4469,11 @@ void OutputDevice::ImplDrawEmphasisMarks
     Rectangle aRectangle;
     for( int nStart = 0;;)
     {
-        long nGlyphIndex;
+        sal_Int32 nGlyphIndex;
         if( !rSalLayout.GetNextGlyphs( 1, &nGlyphIndex, aOutPoint, nStart ) )
             break;
 
-        if( !mpGraphics->GetGlyphBoundRect( nGlyphIndex, aRectangle, NULL ) )
+        if( !mpGraphics->GetGlyphBoundRect( nGlyphIndex, aRectangle ) )
             continue;
 
         if( !rSalLayout.IsSpacingGlyph( nGlyphIndex ) )
@@ -4557,7 +4492,7 @@ void OutputDevice::ImplDrawEmphasisMarks
 
     SetLineColor( aOldLineColor );
     SetFillColor( aOldFillColor );
-    mbMap = bOldMap;
+    EnableMapMode( bOldMap );
     mpMetaFile = pOldMetaFile;
 }
 
@@ -4604,7 +4539,7 @@ bool OutputDevice::ImplDrawRotateText( S
 
     // draw text into upper left corner
     rSalLayout.DrawBase() -= aBoundRect.TopLeft();
-    rSalLayout.DrawText( *pVDev->mpGraphics );
+    rSalLayout.DrawText( *((OutputDevice*)pVDev)->mpGraphics );
 
     Bitmap aBmp = pVDev->GetBitmap( Point(), aBoundRect.GetSize() );
     if ( !aBmp || !aBmp.Rotate( mpFontEntry->mnOwnOrientation, COL_WHITE ) )
@@ -4625,11 +4560,11 @@ bool OutputDevice::ImplDrawRotateText( S
     mnOutOffX   = 0L;
     mnOutOffY   = 0L;
     mpMetaFile  = NULL;
-    mbMap       = FALSE;
+    EnableMapMode( FALSE );
 
     DrawMask( aPoint, aBmp, GetTextColor() );
 
-    mbMap       = bOldMap;
+    EnableMapMode( bOldMap );
     mnOutOffX   = nOldOffX;
     mnOutOffY   = nOldOffY;
     mpMetaFile  = pOldMetaFile;
@@ -4655,9 +4590,15 @@ void OutputDevice::ImplDrawTextDirect( S
        		rSalLayout.DrawBase().X() = w - 1 - x;
             if( !IsRTLEnabled() )
             {
+                OutputDevice *pOutDevRef = (OutputDevice *)this;
+#ifdef USE_NEW_RTL_IMPLEMENTATION
+                if( meOutDevType == OUTDEV_WINDOW )
+                    pOutDevRef = (OutputDevice*) ((Window *) this)->mpDummy4;
+#endif
+
                 // mirror this window back
-                long devX = w-mnOutWidth-mnOutOffX;   // re-mirrored mnOutOffX
-                rSalLayout.DrawBase().X() = devX + ( mnOutWidth - 1 - (rSalLayout.DrawBase().X() - devX) ) ;
+                long devX = w-pOutDevRef->mnOutWidth-pOutDevRef->mnOutOffX;   // re-mirrored mnOutOffX
+                rSalLayout.DrawBase().X() = devX + ( pOutDevRef->mnOutWidth - 1 - (rSalLayout.DrawBase().X() - devX) ) ;
             }
         }
 
@@ -4897,6 +4838,9 @@ void OutputDevice::SetAntialiasing( USHO
         mnAntialiasing = nMode;
         mbInitFont = TRUE;
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetAntialiasing( nMode );
 }
 
 // -----------------------------------------------------------------------
@@ -4978,13 +4922,26 @@ void OutputDevice::SetFont( const Font& 
         mpMetaFile->AddAction( new MetaTextFillColorAction( aFont.GetFillColor(), !aFont.IsTransparent() ) );
     }
 
+#if OSL_DEBUG_LEVEL > 2
+    fprintf( stderr, "   OutputDevice::SetFont() FontName=\"%s\"\n",
+	     OUStringToOString( aFont.GetName(), osl_getThreadTextEncoding() ).getStr() );
+#endif
+
     if ( !maFont.IsSameInstance( aFont ) )
     {
-        if ( maFont.GetColor() != aFont.GetColor() )
+        // Optimization MT/HDU: COL_TRANSPARENT means SetFont should ignore the font color, 
+        // because SetTextColor() is used for this.
+        if ( ( aFont.GetColor() != COL_TRANSPARENT ) && ( maFont.GetColor() != aFont.GetColor() ) )
+		{
+			maTextColor = aFont.GetColor();
             mbInitTextColor = TRUE;
+		}
         maFont      = aFont;
         mbNewFont   = TRUE;
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetFont( rNewFont );
 }
 
 // -----------------------------------------------------------------------
@@ -4997,6 +4954,9 @@ void OutputDevice::SetLayoutMode( ULONG 
         mpMetaFile->AddAction( new MetaLayoutModeAction( nTextLayoutMode ) );
 
     mnTextLayoutMode = nTextLayoutMode;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetLayoutMode( nTextLayoutMode );
 }
 
 // -----------------------------------------------------------------------
@@ -5012,6 +4972,9 @@ void OutputDevice::SetDigitLanguage( Lan
         eTextLanguage = GetSystemLanguage();
 
     meTextLanguage = eTextLanguage;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetDigitLanguage( eTextLanguage );
 }
 
 // -----------------------------------------------------------------------
@@ -5050,11 +5013,14 @@ void OutputDevice::SetTextColor( const C
     if ( mpMetaFile )
         mpMetaFile->AddAction( new MetaTextColorAction( aColor ) );
 
-    if ( maFont.GetColor() != aColor )
+    if ( maTextColor != aColor )
     {
-        maFont.SetColor( aColor );
+        maTextColor = aColor;
         mbInitTextColor = TRUE;
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextColor( COL_BLACK );
 }
 
 // -----------------------------------------------------------------------
@@ -5071,6 +5037,9 @@ void OutputDevice::SetTextFillColor()
         maFont.SetFillColor( Color( COL_TRANSPARENT ) );
     if ( !maFont.IsTransparent() )
         maFont.SetTransparent( TRUE );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextFillColor();
 }
 
 // -----------------------------------------------------------------------
@@ -5122,6 +5091,9 @@ void OutputDevice::SetTextFillColor( con
         maFont.SetFillColor( aColor );
     if ( maFont.IsTransparent() != bTransFill )
         maFont.SetTransparent( bTransFill );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextFillColor( COL_BLACK );
 }
 
 // -----------------------------------------------------------------------
@@ -5145,6 +5117,9 @@ void OutputDevice::SetTextLineColor()
         mpMetaFile->AddAction( new MetaTextLineColorAction( Color(), FALSE ) );
 
     maTextLineColor = Color( COL_TRANSPARENT );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextLineColor();
 }
 
 // -----------------------------------------------------------------------
@@ -5184,6 +5159,9 @@ void OutputDevice::SetTextLineColor( con
         mpMetaFile->AddAction( new MetaTextLineColorAction( aColor, TRUE ) );
 
     maTextLineColor = aColor;
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextLineColor( COL_BLACK );
 }
 
 // -----------------------------------------------------------------------
@@ -5202,6 +5180,9 @@ void OutputDevice::SetTextAlign( TextAli
         maFont.SetAlign( eAlign );
         mbNewFont = TRUE;
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetTextAlign( eAlign );
 }
 
 // -----------------------------------------------------------------------
@@ -5224,7 +5205,6 @@ void OutputDevice::DrawTextLine( const P
     if ( !IsDeviceOutputNecessary() || ImplIsRecordLayout() )
         return;
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if( !mpGraphics && !ImplGetGraphics() )
         return;
@@ -5232,10 +5212,6 @@ void OutputDevice::DrawTextLine( const P
         ImplInitClipRegion();
     if( mbOutputClipped )
         return;
-#else
-    if( !ImplGetServerGraphics() )
-        return;
-#endif
 
     // initialize font if needed to get text offsets
     // TODO: only needed for mnTextOff!=(0,0)
@@ -5249,6 +5225,9 @@ void OutputDevice::DrawTextLine( const P
     nWidth = ImplLogicWidthToDevicePixel( nWidth );
     aPos += Point( mnTextOffX, mnTextOffY );
     ImplDrawTextLine( aPos.X(), aPos.X(), aPos.Y(), nWidth, eStrikeout, eUnderline, bUnderlineAbove );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawTextLine( rPos, nWidth, eStrikeout, eUnderline, bUnderlineAbove );
 }
 
 // ------------------------------------------------------------------------
@@ -5266,7 +5245,6 @@ void OutputDevice::DrawWaveLine( const P
     DBG_TRACE( "OutputDevice::DrawWaveLine()" );
     DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
 
-#ifndef REMOTE_APPSERVER
     if ( !IsDeviceOutputNecessary() || ImplIsRecordLayout() )
         return;
 
@@ -5324,18 +5302,8 @@ void OutputDevice::DrawWaveLine( const P
      ImplDrawWaveLine( nStartX, nStartY, nStartX, nStartY,
                       nEndX-nStartX, nWaveHeight, 1,
                       nOrientation, GetLineColor() );
-#else
-    ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-    if ( pGraphics )
-    {
-        if ( mbInitLineColor )
-            ImplInitLineColor();
-
-        Point aPos1 = ImplLogicToDevicePixel( rStartPos );
-        Point aPos2 = ImplLogicToDevicePixel( rEndPos );
-        pGraphics->DrawWaveLine( aPos1, aPos2, nStyle );
-    }
-#endif
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawWaveLine( rStartPos, rEndPos, nStyle );
 }
 
 // -----------------------------------------------------------------------
@@ -5354,6 +5322,11 @@ void OutputDevice::DrawText( const Point
     DBG_TRACE( "OutputDevice::DrawText()" );
     DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
 
+#if OSL_DEBUG_LEVEL > 2
+    fprintf( stderr, "   OutputDevice::DrawText(\"%s\")\n",
+	     OUStringToOString( rStr, osl_getThreadTextEncoding() ).getStr() );
+#endif
+
     if ( mpMetaFile )
         mpMetaFile->AddAction( new MetaTextAction( rStartPt, rStr, nIndex, nLen ) );
     if( pVector )
@@ -5405,25 +5378,15 @@ void OutputDevice::DrawText( const Point
 
     if ( !IsDeviceOutputNecessary() || pVector )
         return;
-#ifdef UNX
-    String aStr( rStr );
-    if( meOutDevType == OUTDEV_PRINTER )
-    {
-        if( !mpGraphics )
-            if( !ImplGetGraphics() )
-                return;
-        xub_StrLen nCutStart, nCutStop;
-        aStr = mpGraphics->maGraphicsData.FaxPhoneComment( rStr, nIndex, nLen, nCutStart, nCutStop );
-    }
-    SalLayout* pSalLayout = ImplLayout( aStr, nIndex, nLen, rStartPt );
-#else
     SalLayout* pSalLayout = ImplLayout( rStr, nIndex, nLen, rStartPt );
-#endif
     if( pSalLayout )
     {
         ImplDrawText( *pSalLayout );
         pSalLayout->Release();
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawText( rStartPt, rStr, nIndex, nLen, pVector, pDisplayText );
 }
 
 // -----------------------------------------------------------------------
@@ -5460,7 +5423,7 @@ long OutputDevice::GetTextHeight() const
 // -----------------------------------------------------------------------
 
 void OutputDevice::DrawTextArray( const Point& rStartPt, const String& rStr,
-                                  const long* pDXAry,
+                                  const sal_Int32* pDXAry,
                                   xub_StrLen nIndex, xub_StrLen nLen )
 {
     DBG_TRACE( "OutputDevice::DrawTextArray()" );
@@ -5472,38 +5435,20 @@ void OutputDevice::DrawTextArray( const 
     if ( !IsDeviceOutputNecessary() )
         return;
 
-#ifdef UNX
-    String aStr( rStr );
-    if( meOutDevType == OUTDEV_PRINTER )
-    {
-        if( !mpGraphics )
-            if( !ImplGetGraphics() )
-                return;
-        xub_StrLen nCutStart, nCutStop, nOrgLen = nLen;
-        aStr = mpGraphics->maGraphicsData.FaxPhoneComment( rStr, nIndex, nLen, nCutStart, nCutStop );
-        if( nCutStop != nCutStart )
-        {
-            long* pAry = (long*)alloca(sizeof(long)*nLen );
-            if( nCutStart > nIndex )
-                memcpy( pAry, pDXAry, sizeof(long)*(nCutStart-nIndex) );
-            memcpy( pAry+nCutStart-nIndex, pDXAry + nOrgLen - (nCutStop-nIndex), nLen - (nCutStop-nIndex) );
-            pDXAry = pAry;
-        }
-    }
-    SalLayout* pSalLayout = ImplLayout( aStr, nIndex, nLen, rStartPt, 0, pDXAry );
-#else
     SalLayout* pSalLayout = ImplLayout( rStr, nIndex, nLen, rStartPt, 0, pDXAry );
-#endif
     if( pSalLayout )
     {
         ImplDrawText( *pSalLayout );
         pSalLayout->Release();
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawTextArray( rStartPt, rStr, pDXAry, nIndex, nLen );
 }
 
 // -----------------------------------------------------------------------
 
-long OutputDevice::GetTextArray( const String& rStr, long* pDXAry,
+long OutputDevice::GetTextArray( const String& rStr, sal_Int32* pDXAry,
                                  xub_StrLen nIndex, xub_StrLen nLen ) const
 {
     DBG_TRACE( "OutputDevice::GetTextArray()" );
@@ -5550,9 +5495,9 @@ long OutputDevice::GetTextArray( const S
 
 // -----------------------------------------------------------------------
 
-bool OutputDevice::GetCaretPositions( const XubString& rStr, long* pCaretXArray,
+bool OutputDevice::GetCaretPositions( const XubString& rStr, sal_Int32* pCaretXArray,
     xub_StrLen nIndex, xub_StrLen nLen,
-    long* pDXAry, long nLayoutWidth,
+    sal_Int32* pDXAry, long nLayoutWidth,
     BOOL bCellBreaking ) const
 {
     DBG_TRACE( "OutputDevice::GetCaretPositions()" );
@@ -5632,44 +5577,29 @@ void OutputDevice::DrawStretchText( cons
     if ( !IsDeviceOutputNecessary() )
         return;
 
-#ifdef UNX
-    String aStr( rStr );
-    if( meOutDevType == OUTDEV_PRINTER )
-    {
-        if( !mpGraphics )
-            if( !ImplGetGraphics() )
-                return;
-        xub_StrLen nCutStart, nCutStop;
-        aStr = mpGraphics->maGraphicsData.FaxPhoneComment( rStr, nIndex, nLen, nCutStart, nCutStop );
-    }
-    SalLayout* pSalLayout = ImplLayout( aStr, nIndex, nLen, rStartPt, nWidth );
-#else
     SalLayout* pSalLayout = ImplLayout( rStr, nIndex, nLen, rStartPt, nWidth );
-#endif
     if( pSalLayout )
     {
         ImplDrawText( *pSalLayout );
         pSalLayout->Release();
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawStretchText( rStartPt, nWidth, rStr, nIndex, nLen );
 }
 
 // -----------------------------------------------------------------------
 
 SalLayout* OutputDevice::ImplLayout( const String& rOrigStr,
     xub_StrLen nMinIndex, xub_StrLen nLen,
-    const Point& rLogicalPos, long nLogicalWidth, const long* pDXArray ) const
+    const Point& rLogicalPos, long nLogicalWidth, const sal_Int32* pDXArray ) const
 {
     SalLayout* pSalLayout = NULL;
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if( !mpGraphics )
         if( !ImplGetGraphics() )
             return NULL;
-#else
-    // due to clipping we may get NULL, so don't use return value
-    ImplGetServerGraphics();
-#endif
 
     // initialize font if needed
     if( mbNewFont )
@@ -5790,7 +5720,7 @@ SalLayout* OutputDevice::ImplLayout( con
     if( pDXArray && mbMap )
     {
         // convert from logical units to font units using a temporary array
-        long* pTempDXAry = (long*)alloca( nLength * sizeof(long) );
+        sal_Int32* pTempDXAry = (sal_Int32*)alloca( nLength * sizeof(sal_Int32) );
         // using base position for better rounding a.k.a. "dancing characters"
         int nPixelXOfs = ImplLogicWidthToDevicePixel( rLogicalPos.X() );
         for( int i = 0; i < nLength; ++i )
@@ -6017,7 +5947,6 @@ void OutputDevice::DrawText( const Recta
     if ( ( !IsDeviceOutputNecessary() && ! pVector ) || !rOrigStr.Len() || rRect.IsEmpty() )
         return;
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if( !mpGraphics && !ImplGetGraphics() )
         return;
@@ -6025,10 +5954,6 @@ void OutputDevice::DrawText( const Recta
         ImplInitClipRegion();
     if( mbOutputClipped )
         return;
-#else
-    if( !ImplGetServerGraphics() )
-        return;
-#endif
 
     Color aOldTextColor;
     Color aOldTextFillColor;
@@ -6063,10 +5988,14 @@ void OutputDevice::DrawText( const Recta
             SetTextColor( COL_LIGHTGREEN );
         else
         {
+            // draw disabled text always without shadow
+            // as it fits better with native look
+            /*
             SetTextColor( GetSettings().GetStyleSettings().GetLightColor() );
             Rectangle aRect = rRect;
             aRect.Move( 1, 1 );
             DrawText( aRect, rOrigStr, nStyle & ~TEXT_DRAW_DISABLE );
+            */
             SetTextColor( GetSettings().GetStyleSettings().GetShadowColor() );
         }
     }
@@ -6176,7 +6105,7 @@ void OutputDevice::DrawText( const Recta
                         long        nMnemonicY;
                         long        nMnemonicWidth;
 
-                        long *pCaretXArray = (long*) alloca( 2 * sizeof(long) * nLineLen );
+                        sal_Int32* pCaretXArray = (sal_Int32*) alloca( 2 * sizeof(sal_Int32) * nLineLen );
                         BOOL bRet = GetCaretPositions( aStr, pCaretXArray,
                                                 nIndex, nLineLen);
                         long lc_x1 = pCaretXArray[2*(nMnemonicPos - nIndex)];
@@ -6184,11 +6113,7 @@ void OutputDevice::DrawText( const Recta
                         nMnemonicWidth = ::abs((int)(lc_x1 - lc_x2));
 
                         Point       aTempPos = LogicToPixel( aPos );
-#if (_MSC_VER < 1300)
-                        nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( std::min( lc_x1, lc_x2 ) );
-#else
-                        nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( min( lc_x1, lc_x2 ) );
-#endif
+                        nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( Min( lc_x1, lc_x2 ) );
                         nMnemonicY = mnOutOffY + aTempPos.Y() + ImplLogicWidthToDevicePixel( GetFontMetric().GetAscent() );
                         ImplDrawMnemonicLine( nMnemonicX, nMnemonicY, nMnemonicWidth );
                     }
@@ -6251,18 +6176,14 @@ void OutputDevice::DrawText( const Recta
         long        nMnemonicWidth;
         if ( nMnemonicPos != STRING_NOTFOUND )
         {
-            long *pCaretXArray = (long*) alloca( 2 * sizeof(long) * aStr.Len() );
+            sal_Int32* pCaretXArray = (sal_Int32*) alloca( 2 * sizeof(sal_Int32) * aStr.Len() );
             BOOL bRet = GetCaretPositions( aStr, pCaretXArray, 0, aStr.Len() );
             long lc_x1 = pCaretXArray[2*(nMnemonicPos)];
             long lc_x2 = pCaretXArray[2*(nMnemonicPos)+1];
             nMnemonicWidth = ::abs((int)(lc_x1 - lc_x2));
 
             Point aTempPos = LogicToPixel( aPos );
-#if (_MSC_VER < 1300)
-            nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( std::min(lc_x1, lc_x2) );
-#else
-            nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( min(lc_x1, lc_x2) );
-#endif
+            nMnemonicX = mnOutOffX + aTempPos.X() + ImplLogicWidthToDevicePixel( Min(lc_x1, lc_x2) );
             nMnemonicY = mnOutOffY + aTempPos.Y() + ImplLogicWidthToDevicePixel( GetFontMetric().GetAscent() );
         }
 
@@ -6295,6 +6216,9 @@ void OutputDevice::DrawText( const Recta
         if ( bRestoreFillColor )
             SetTextFillColor( aOldTextFillColor );
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawText( rRect, rOrigStr, nStyle, pVector, pDisplayText );
 }
 
 // -----------------------------------------------------------------------
@@ -6559,7 +6483,6 @@ void OutputDevice::DrawCtrlText( const P
         return;
 
     // better get graphics here because ImplDrawMnemonicLine() will not
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if( !mpGraphics && !ImplGetGraphics() )
         return;
@@ -6567,10 +6490,6 @@ void OutputDevice::DrawCtrlText( const P
         ImplInitClipRegion();
     if ( mbOutputClipped )
         return;
-#else
-    if( !ImplGetServerGraphics() )
-        return;
-#endif
 
     if( nIndex >= rStr.Len() )
         return;
@@ -6608,22 +6527,17 @@ void OutputDevice::DrawCtrlText( const P
                 nMnemonicPos = nLen-1;
             }
 
-            long *pCaretXArray = (long*)alloca( 2 * sizeof(long) * nLen );
+            sal_Int32* pCaretXArray = (sal_Int32*)alloca( 2 * sizeof(sal_Int32) * nLen );
             BOOL bRet = GetCaretPositions( aStr, pCaretXArray, nIndex, nLen );
             long lc_x1 = pCaretXArray[ 2*(nMnemonicPos - nIndex) ];
             long lc_x2 = pCaretXArray[ 2*(nMnemonicPos - nIndex)+1 ];
             nMnemonicWidth = ::abs((int)(lc_x1 - lc_x2));
 
-#if (_MSC_VER < 1300)
-            Point aTempPos( std::min(lc_x1,lc_x2), GetFontMetric().GetAscent() );
+            Point aTempPos( Min(lc_x1,lc_x2), GetFontMetric().GetAscent() );
             if( bInvalidPos )  // #106952#, place behind the (last) character
-                aTempPos = Point( std::max(lc_x1,lc_x2), GetFontMetric().GetAscent() );
-#else
-            Point aTempPos( min(lc_x1,lc_x2), GetFontMetric().GetAscent() );
-            if( bInvalidPos )  // #106952#, place behind the (last) character
-                aTempPos = Point( max(lc_x1,lc_x2), GetFontMetric().GetAscent() );
-#endif
-            aTempPos += rPos;
+                aTempPos = Point( Max(lc_x1,lc_x2), GetFontMetric().GetAscent() );
+
+			aTempPos += rPos;
             aTempPos = LogicToPixel( aTempPos );
             nMnemonicX = mnOutOffX + aTempPos.X();
             nMnemonicY = mnOutOffY + aTempPos.Y();
@@ -6688,6 +6602,9 @@ void OutputDevice::DrawCtrlText( const P
                 ImplDrawMnemonicLine( nMnemonicX, nMnemonicY, nMnemonicWidth );
         }
     }
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawCtrlText( rPos, rStr, nIndex, nLen, nStyle, pVector, pDisplayText );
 }
 
 // -----------------------------------------------------------------------
@@ -6835,6 +6752,10 @@ BOOL OutputDevice::AddTempDevFont( const
     if( !pFontData )
         return FALSE;
     mpFontList->Add( pFontData );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->AddTempDevFont( rFileURL, rFontName );
+
     return TRUE;
 }
 
@@ -7101,13 +7023,8 @@ BOOL OutputDevice::GetTextBoundRect( Rec
     long nXOffset = 0;
     if( nBase != nIndex )
     {
-#if (_MSC_VER < 1300)
-        xub_StrLen nStart = std::min( nBase, nIndex );
-        xub_StrLen nOfsLen = std::max( nBase, nIndex ) - nStart;
-#else
-        xub_StrLen nStart = min( nBase, nIndex );
-        xub_StrLen nOfsLen = max( nBase, nIndex ) - nStart;
-#endif
+        xub_StrLen nStart = Min( nBase, nIndex );
+        xub_StrLen nOfsLen = Max( nBase, nIndex ) - nStart;
         pSalLayout = ImplLayout( rStr, nStart, nOfsLen );
         if( pSalLayout )
         {
@@ -7269,7 +7186,7 @@ BOOL OutputDevice::GetTextBoundRect( Rec
 
 BOOL OutputDevice::GetTextOutline( PolyPolygon& rPolyPoly,
     const String& rStr, xub_StrLen nBase, xub_StrLen nIndex, xub_StrLen nLen,
-    BOOL bOptimize, const ULONG nTWidth, const long* pDXArray ) const
+    BOOL bOptimize, const ULONG nTWidth, const sal_Int32* pDXArray ) const
 {
     rPolyPoly.Clear();
     PolyPolyVector aVector;
@@ -7286,7 +7203,7 @@ BOOL OutputDevice::GetTextOutline( PolyP
 
 BOOL OutputDevice::GetTextOutlines( PolyPolyVector& rVector,
     const String& rStr, xub_StrLen nBase, xub_StrLen nIndex,
-    xub_StrLen nLen, BOOL bOptimize, const ULONG nTWidth, const long* pDXArray ) const
+    xub_StrLen nLen, BOOL bOptimize, const ULONG nTWidth, const sal_Int32* pDXArray ) const
 {
     BOOL bRet = FALSE;
     rVector.clear();
@@ -7309,13 +7226,8 @@ BOOL OutputDevice::GetTextOutlines( Poly
     long nXOffset = 0;
     if( nBase != nIndex )
     {
-#if (_MSC_VER < 1300)
-        xub_StrLen nStart = std::min( nBase, nIndex );
-        xub_StrLen nOfsLen = std::max( nBase, nIndex ) - nStart;
-#else
-        xub_StrLen nStart = min( nBase, nIndex );
-        xub_StrLen nOfsLen = max( nBase, nIndex ) - nStart;
-#endif
+        xub_StrLen nStart = Min( nBase, nIndex );
+        xub_StrLen nOfsLen = Max( nBase, nIndex ) - nStart;
         pSalLayout = ImplLayout( rStr, nStart, nOfsLen, Point( 0,0 ), nTWidth, pDXArray );
         if( pSalLayout )
         {
@@ -7401,8 +7313,8 @@ BOOL OutputDevice::GetTextOutlines( Poly
     if (pSalLayout == 0)
         return false;
     long nWidth = pSalLayout->GetTextWidth();
-    long nHeight = aVDev.mpFontEntry->mnLineHeight + aVDev.mnEmphasisAscent
-        + aVDev.mnEmphasisDescent;
+    long nHeight = ((OutputDevice*)&aVDev)->mpFontEntry->mnLineHeight + ((OutputDevice*)&aVDev)->mnEmphasisAscent
+        + ((OutputDevice*)&aVDev)->mnEmphasisDescent;
     pSalLayout->Release();
 
     if( !nWidth || !nHeight )
@@ -7446,8 +7358,8 @@ BOOL OutputDevice::GetTextOutlines( Poly
             // draw glyph into virtual device
             aVDev.Erase();
             pSalLayout->DrawBase() += aOffset;
-            pSalLayout->DrawBase() += Point( aVDev.mnTextOffX, aVDev.mnTextOffY );
-            pSalLayout->DrawText( *aVDev.mpGraphics );
+            pSalLayout->DrawBase() += Point( ((OutputDevice*)&aVDev)->mnTextOffX, ((OutputDevice*)&aVDev)->mnTextOffY );
+            pSalLayout->DrawText( *((OutputDevice*)&aVDev)->mpGraphics );
             pSalLayout->Release();
 
             // convert character image into outline
@@ -7467,11 +7379,11 @@ BOOL OutputDevice::GetTextOutlines( Poly
                         Point& rPt = rPoly[k];
                         rPt.X() = FRound(ImplDevicePixelToLogicWidth(
                                              nXOffset + rPt.X() - aOffset.X()
-                                             - aVDev.mnTextOffX)
+                                             - ((OutputDevice*)&aVDev)->mnTextOffX)
                                          * fScaleX);
                         rPt.Y() = FRound(ImplDevicePixelToLogicHeight(
                                              rPt.Y() - aOffset.Y()
-                                             - aVDev.mnTextOffY)
+                                             - ((OutputDevice*)&aVDev)->mnTextOffY)
                                          * fScaleY);
                     }
                 }
@@ -7499,13 +7411,9 @@ BOOL OutputDevice::GetFontCharMap( FontC
 {
     rFontCharMap.ImplSetDefaultRanges();
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if( !mpGraphics && !ImplGetGraphics() )
         return FALSE;
-#else
-    ImplGetServerGraphics();
-#endif
 
     if( mbNewFont )
         const_cast<OutputDevice&>(*this).ImplNewFont();
Index: vcl/source/gdi/outdev4.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev4.cxx,v
retrieving revision 1.13.136.1
retrieving revision 1.17
diff -u -p -u -r1.13.136.1 -r1.17
--- vcl/source/gdi/outdev4.cxx	9 Jan 2004 18:13:45 -0000	1.13.136.1
+++ vcl/source/gdi/outdev4.cxx	6 Jan 2004 13:50:37 -0000	1.17
@@ -59,24 +59,14 @@
  *
  ************************************************************************/
 
-#define _SV_OUTDEV_CXX
-
 #include <math.h>
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -95,14 +85,14 @@
 #ifndef _SV_OUTDATA_HXX
 #include <outdata.hxx>
 #endif
-#ifndef _POLY_HXX
+#ifndef _TL_POLY_HXX
 #include <tools/poly.hxx>
 #endif
 #ifndef _SV_SALBTYPE_HXX
 #include <salbtype.hxx>
 #endif
-#ifndef _SV_LINE_HXX
-#include <line.hxx>
+#ifndef _LINE_HXX
+#include <tools/line.hxx>
 #endif
 #ifndef _SV_HATCH_HXX
 #include <hatch.hxx>
@@ -147,8 +137,6 @@ DBG_NAMEEX( Gradient );
 
 // =======================================================================
 
-#ifndef REMOTE_APPSERVER
-
 void OutputDevice::ImplDrawPolygon( const Polygon& rPoly, const PolyPolygon* pClipPolyPoly )
 {
 	if( pClipPolyPoly )
@@ -224,8 +212,6 @@ void OutputDevice::ImplDrawPolyPolygon( 
 		delete pPolyPoly;
 }
 
-#endif
-
 // -----------------------------------------------------------------------
 
 inline UINT8 ImplGetGradientColorValue( long nValue )
@@ -395,10 +381,8 @@ void OutputDevice::ImplDrawLinearGradien
 
 	if ( bMtf )
 		mpMetaFile->AddAction( new MetaFillColorAction( Color( nRed, nGreen, nBlue ), TRUE ) );
-#ifndef REMOTE_APPSERVER
 	else
 		mpGraphics->SetFillColor( MAKE_SALCOLOR( nRed, nGreen, nBlue ) );
-#endif
 
 	// Startpolygon erzeugen (== Borderpolygon)
 	Polygon 	aPoly( 4 );
@@ -415,10 +399,8 @@ void OutputDevice::ImplDrawLinearGradien
 		// berechnetesPolygon ausgeben
 		if ( bMtf )
 			mpMetaFile->AddAction( new MetaPolygonAction( aPoly ) );
-#ifndef REMOTE_APPSERVER
 		else
 			ImplDrawPolygon( aPoly, pClipPolyPoly );
-#endif
 
 		// neues Polygon berechnen
 		aRect.Top() = (long)(fScanLine += fScanInc);
@@ -484,10 +466,8 @@ void OutputDevice::ImplDrawLinearGradien
 
 		if ( bMtf )
 			mpMetaFile->AddAction( new MetaFillColorAction( Color( nRed, nGreen, nBlue ), TRUE ) );
-#ifndef REMOTE_APPSERVER
 		else
 			mpGraphics->SetFillColor( MAKE_SALCOLOR( nRed, nGreen, nBlue ) );
-#endif
 	}
 }
 
@@ -630,17 +610,14 @@ void OutputDevice::ImplDrawComplexGradie
 
 	if( bMtf )
 		mpMetaFile->AddAction( new MetaFillColorAction( Color( nRed, nGreen, nBlue ), TRUE ) );
-#ifndef REMOTE_APPSERVER
 	else
 		mpGraphics->SetFillColor( MAKE_SALCOLOR( nRed, nGreen, nBlue ) );
-#endif
 
 	if( pPolyPoly )
 	{   
     	pPolyPoly->Insert( aPoly = rRect );
 		pPolyPoly->Insert( aPoly );
 	}
-#ifndef REMOTE_APPSERVER
 	else
     {
 	    // extend rect, to avoid missing bounding line
@@ -653,7 +630,6 @@ void OutputDevice::ImplDrawComplexGradie
 
 		ImplDrawPolygon( aPoly = aExtRect, pClipPolyPoly );
     }
-#endif
 
 	// Schleife, um nacheinander die Polygone/PolyPolygone auszugeben
 	for( long i = 1; i < nSteps; i++ )
@@ -690,10 +666,8 @@ void OutputDevice::ImplDrawComplexGradie
 
 			if( bMtf )
 				mpMetaFile->AddAction( new MetaPolyPolygonAction( *pPolyPoly ) );
-#ifndef REMOTE_APPSERVER
 			else
 				ImplDrawPolyPolygon( *pPolyPoly, pClipPolyPoly );
-#endif
 
             // #107349# Set fill color _after_ geometry painting:
             // pPolyPoly's geometry is the band from last iteration's
@@ -707,7 +681,6 @@ void OutputDevice::ImplDrawComplexGradie
             else
                 mpGraphics->SetFillColor( MAKE_SALCOLOR( nRed, nGreen, nBlue ) );
 		}
-#ifndef REMOTE_APPSERVER
 		else
         {
             // #107349# Set fill color _before_ geometry painting
@@ -718,7 +691,6 @@ void OutputDevice::ImplDrawComplexGradie
 
 			ImplDrawPolygon( aPoly, pClipPolyPoly );
         }
-#endif
 	}
 
 	// Falls PolyPolygon-Ausgabe, muessen wir noch ein letztes inneres Polygon zeichnen
@@ -743,13 +715,11 @@ void OutputDevice::ImplDrawComplexGradie
 	    		mpMetaFile->AddAction( new MetaFillColorAction( Color( nRed, nGreen, nBlue ), TRUE ) );
 				mpMetaFile->AddAction( new MetaPolygonAction( rPoly ) );
             }
-#ifndef REMOTE_APPSERVER
 		    else
             {
 			    mpGraphics->SetFillColor( MAKE_SALCOLOR( nRed, nGreen, nBlue ) );
    				ImplDrawPolygon( rPoly, pClipPolyPoly );
             }
-#endif
 		}
 
 		delete pPolyPoly;
@@ -835,7 +805,6 @@ void OutputDevice::DrawGradient( const R
 	// Wenn Rechteck leer ist, brauchen wir nichts machen
 	if ( !aRect.IsEmpty() )
 	{
-#ifndef REMOTE_APPSERVER
 		// Clip Region sichern
 		Push( PUSH_CLIPREGION );
 		IntersectClipRegion( rRect );
@@ -879,12 +848,10 @@ void OutputDevice::DrawGradient( const R
 		}
 
 		Pop();
-#else
-		ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-		if ( pGraphics )
-			pGraphics->DrawGradient( aRect, aGradient );
-#endif
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( rRect );
 }
 
 // -----------------------------------------------------------------------
@@ -990,7 +957,6 @@ void OutputDevice::DrawGradient( const P
 			aGradient.SetEndColor( aEndCol );
 		}
 
-#ifndef REMOTE_APPSERVER
 		if( OUTDEV_PRINTER == meOutDevType )
 		{
 			const Rectangle	aBoundRect( rPolyPoly.GetBoundRect() );
@@ -1054,41 +1020,52 @@ void OutputDevice::DrawGradient( const P
 
 			if( !aDstRect.IsEmpty() )
 			{
-				VirtualDevice	aVDev;
+				VirtualDevice*	pVDev;
 				const Size		aDstSize( aDstRect.GetSize() );
 
-				if( aVDev.SetOutputSizePixel( aDstSize) )
+                if( HasAlpha() )
+                {
+                    // #110958# Pay attention to alpha VDevs here, otherwise, 
+                    // background will be wrong: Temp VDev has to have alpha, too.
+                    pVDev = new VirtualDevice( *this, 0, GetAlphaBitCount() > 1 ? 0 : 1 );
+                }
+                else
+                {
+                    // nothing special here. Plain VDev
+                    pVDev = new VirtualDevice();
+                }
+
+				if( pVDev->SetOutputSizePixel( aDstSize) )
 				{
 					MapMode			aVDevMap;
-					const RasterOp	eOldROP = GetRasterOp();
 					const BOOL		bOldMap = mbMap;
 
-					mbMap = FALSE;
+					EnableMapMode( FALSE );
 
-					aVDev.DrawOutDev( Point(), aDstSize, aDstRect.TopLeft(), aDstSize, *this );
-					aVDev.SetRasterOp( ROP_XOR );
+					pVDev->DrawOutDev( Point(), aDstSize, aDstRect.TopLeft(), aDstSize, *this );
+					pVDev->SetRasterOp( ROP_XOR );
 					aVDevMap.SetOrigin( Point( -aDstRect.Left(), -aDstRect.Top() ) );
-					aVDev.SetMapMode( aVDevMap );
-					aVDev.DrawGradient( aBoundRect, aGradient );
-					aVDev.SetFillColor( COL_BLACK );
-					aVDev.SetRasterOp( ROP_0 );
-					aVDev.DrawPolyPolygon( aPolyPoly );
-					aVDev.SetRasterOp( ROP_XOR );
-					aVDev.DrawGradient( aBoundRect, aGradient );
+					pVDev->SetMapMode( aVDevMap );
+					pVDev->DrawGradient( aBoundRect, aGradient );
+					pVDev->SetFillColor( COL_BLACK );
+					pVDev->SetRasterOp( ROP_0 );
+					pVDev->DrawPolyPolygon( aPolyPoly );
+					pVDev->SetRasterOp( ROP_XOR );
+					pVDev->DrawGradient( aBoundRect, aGradient );
 					aVDevMap.SetOrigin( Point() );
-					aVDev.SetMapMode( aVDevMap );
-					DrawOutDev( aDstRect.TopLeft(), aDstSize, Point(), aDstSize, aVDev );
+					pVDev->SetMapMode( aVDevMap );
+					DrawOutDev( aDstRect.TopLeft(), aDstSize, Point(), aDstSize, *pVDev );
 
-					mbMap = bOldMap;
+					EnableMapMode( bOldMap );
 				}
+
+                delete pVDev;
 			}
 		}
-#else
-		ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-		if ( pGraphics )
-			pGraphics->DrawGradient( ImplLogicToDevicePixel( rPolyPoly ), aGradient );
-#endif
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPolyPolygon( rPolyPoly );
 }
 
 // -----------------------------------------------------------------------
@@ -1180,7 +1157,6 @@ void OutputDevice::DrawHatch( const Poly
 	if( !IsDeviceOutputNecessary() || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	if( !mpGraphics && !ImplGetGraphics() )
 		return;
 
@@ -1189,39 +1165,29 @@ void OutputDevice::DrawHatch( const Poly
 
 	if( mbOutputClipped )
 		return;
-#endif
 
 	if( rPolyPoly.Count() )
 	{ 
-#ifndef REMOTE_APPSERVER
 		PolyPolygon		aPolyPoly( LogicToPixel( rPolyPoly ) );
 		GDIMetaFile*	pOldMetaFile = mpMetaFile;
 		BOOL			bOldMap = mbMap;
 
 		aPolyPoly.Optimize( POLY_OPTIMIZE_NO_SAME );
-		aHatch.SetDistance( ImplLogicWidthToDevicePixel( aHatch.GetDistance() ) );
+        aHatch.SetDistance( ImplLogicWidthToDevicePixel( aHatch.GetDistance() ) );
 
 		mpMetaFile = NULL;
-		mbMap = FALSE;
+		EnableMapMode( FALSE );
 		Push( PUSH_LINECOLOR );
 		SetLineColor( aHatch.GetColor() );
 		ImplInitLineColor();
 		ImplDrawHatch( aPolyPoly, aHatch, FALSE );
 		Pop();
-		mbMap = bOldMap;
+		EnableMapMode( bOldMap );
 		mpMetaFile = pOldMetaFile;
-#else
-		ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-		if ( pGraphics )
-		{
-			PolyPolygon aPolyPoly( ImplLogicToDevicePixel( rPolyPoly ) );
-
-			aPolyPoly.Optimize( POLY_OPTIMIZE_NO_SAME );
-			aHatch.SetDistance( ImplLogicWidthToDevicePixel( aHatch.GetDistance() ) );
-			pGraphics->DrawHatch( aPolyPoly, aHatch );
-		}
-#endif
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawHatch( rPolyPoly, rHatch );
 }
 
 // -----------------------------------------------------------------------
@@ -1422,7 +1388,6 @@ void OutputDevice::ImplDrawHatchLine( co
 
 		if( rPoly.GetSize() > 1 )
 		{
-			Point	aIntersection;
 			Line	aCurSegment( rPoly[ 0 ], Point() );
 
 			for( long i = 1, nCount = rPoly.GetSize(); i <= nCount; i++ )
@@ -1482,20 +1447,19 @@ void OutputDevice::ImplDrawHatchLine( co
 		}
 		else
 		{
-#ifndef REMOTE_APPSERVER
 			for( long i = 0; i < nPCounter; i += 2 )
 			{
                 if( mpPDFWriter )
-                    mpPDFWriter->drawLine( pPtBuffer[i], pPtBuffer[i+1] );
+                {
+                    mpPDFWriter->drawLine( pPtBuffer[ i ], pPtBuffer[ i+1 ] );
+                }
                 else
                 {
                     const Point aPt1( ImplLogicToDevicePixel( pPtBuffer[ i ] ) );
                     const Point aPt2( ImplLogicToDevicePixel( pPtBuffer[ i + 1 ] ) );
-                    
                     mpGraphics->DrawLine( aPt1.X(), aPt1.Y(), aPt2.X(), aPt2.Y(), this );
                 }
 			}
-#endif
 		}
 	}
 }
Index: vcl/source/gdi/outdev5.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev5.cxx,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -p -u -r1.3 -r1.6
--- vcl/source/gdi/outdev5.cxx	27 Mar 2003 17:58:00 -0000	1.3
+++ vcl/source/gdi/outdev5.cxx	6 Jan 2004 13:51:01 -0000	1.6
@@ -59,23 +59,14 @@
  *
  ************************************************************************/
 
-#define _SV_OUTDEV_CXX
 #include <tools/ref.hxx>
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
@@ -84,7 +75,7 @@
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
 #endif
-#ifndef _POLY_HXX
+#ifndef _TL_POLY_HXX
 #include <tools/poly.hxx>
 #endif
 #ifndef _SV_METAACT_HXX
@@ -102,6 +93,9 @@
 #ifndef _SV_OUTDEV_HXX
 #include <outdev.hxx>
 #endif
+#ifndef _SV_VIRDEV_HXX
+#include <virdev.hxx>
+#endif
 
 // =======================================================================
 
@@ -129,7 +123,6 @@ void OutputDevice::DrawRect( const Recta
 	nHorzRound = ImplLogicWidthToDevicePixel( nHorzRound );
 	nVertRound = ImplLogicHeightToDevicePixel( nVertRound );
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -163,20 +156,9 @@ void OutputDevice::DrawRect( const Recta
 				mpGraphics->DrawPolygon( aRoundRectPoly.GetSize(), pPtAry, this );
 		}
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		if ( !nHorzRound || !nVertRound )
-			pGraphics->DrawRect( aRect );
-		else
-			pGraphics->DrawRect( aRect, nHorzRound, nVertRound );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawRect( rRect, nHorzRound, nVertRound );
 }
 
 // -----------------------------------------------------------------------
@@ -196,7 +178,6 @@ void OutputDevice::DrawEllipse( const Re
 	if ( aRect.IsEmpty() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -225,17 +206,9 @@ void OutputDevice::DrawEllipse( const Re
 			mpGraphics->DrawPolygon( aRectPoly.GetSize(), pPtAry, this );
 		}
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawEllipse( aRect );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawEllipse( rRect );
 }
 
 // -----------------------------------------------------------------------
@@ -256,7 +229,6 @@ void OutputDevice::DrawArc( const Rectan
 	if ( aRect.IsEmpty() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -281,19 +253,9 @@ void OutputDevice::DrawArc( const Rectan
 		const SalPoint* pPtAry = (const SalPoint*)aArcPoly.GetConstPointAry();
 		mpGraphics->DrawPolyLine( aArcPoly.GetSize(), pPtAry, this );
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawArc( aRect,
-							ImplLogicToDevicePixel( rStartPt ),
-							ImplLogicToDevicePixel( rEndPt ) );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawArc( rRect, rStartPt, rEndPt );
 }
 
 // -----------------------------------------------------------------------
@@ -314,7 +276,6 @@ void OutputDevice::DrawPie( const Rectan
 	if ( aRect.IsEmpty() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -346,19 +307,9 @@ void OutputDevice::DrawPie( const Rectan
 			mpGraphics->DrawPolygon( aPiePoly.GetSize(), pPtAry, this );
 		}
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawPie( aRect,
-							ImplLogicToDevicePixel( rStartPt ),
-							ImplLogicToDevicePixel( rEndPt ) );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawPie( rRect, rStartPt, rEndPt );
 }
 
 // -----------------------------------------------------------------------
@@ -379,7 +330,6 @@ void OutputDevice::DrawChord( const Rect
 	if ( aRect.IsEmpty() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -411,17 +361,7 @@ void OutputDevice::DrawChord( const Rect
 			mpGraphics->DrawPolygon( aChordPoly.GetSize(), pPtAry, this );
 		}
 	}
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawChord( aRect,
-							  ImplLogicToDevicePixel( rStartPt ),
-							  ImplLogicToDevicePixel( rEndPt ) );
-	}
-#endif
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawChord( rRect, rStartPt, rEndPt );
 }
Index: vcl/source/gdi/outdev6.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outdev6.cxx,v
retrieving revision 1.5
retrieving revision 1.9
diff -u -p -u -r1.5 -r1.9
--- vcl/source/gdi/outdev6.cxx	8 Apr 2003 15:35:51 -0000	1.5
+++ vcl/source/gdi/outdev6.cxx	17 May 2004 16:00:10 -0000	1.9
@@ -59,19 +59,13 @@
  *
  ************************************************************************/
 
-#define _SV_WALL_CXX
-
 #include <math.h>
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
-#else // REMOTE_APPSERVER
-#include <tools/stream.hxx>
-#endif // REMOTE_APPSERVER
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -102,8 +96,8 @@
 #ifndef _SV_GRAPH_HXX
 #include <graph.hxx>
 #endif
-#ifdef REMOTE_APPSERVER
-#include <rmoutdev.hxx>
+#ifndef _SV_WALL2_HXX
+#include <wall2.hxx>
 #endif
 #ifndef _COM_SUN_STAR_UNO_SEQUENCE_HXX_
 #include <com/sun/star/uno/Sequence.hxx>
@@ -126,7 +120,6 @@ void OutputDevice::DrawGrid( const Recta
 	if( aDstRect.IsEmpty() || ImplIsRecordLayout() )
 		return;
 
-#ifndef REMOTE_APPSERVER
 	if( !mpGraphics && !ImplGetGraphics() )
 		return;
 
@@ -135,12 +128,6 @@ void OutputDevice::DrawGrid( const Recta
 
 	if( mbOutputClipped )
 		return;
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-
-	if( !pGraphics )
-		return;
-#endif
 
 	const long	nDistX = Max( rDist.Width(), 1L );
 	const long	nDistY = Max( rDist.Height(), 1L );
@@ -180,9 +167,8 @@ void OutputDevice::DrawGrid( const Recta
 	if( mbInitFillColor )
 		ImplInitFillColor();
 
-#ifndef REMOTE_APPSERVER
 	const BOOL bOldMap = mbMap;
-	mbMap = FALSE;
+	EnableMapMode( FALSE );
 
 	if( nFlags & GRID_DOTS )
 	{
@@ -211,12 +197,10 @@ void OutputDevice::DrawGrid( const Recta
 		}
 	}
 
-	mbMap = bOldMap;
-#else // REMOTE_APPSERVER
-	aHorzBuf.realloc( nHorzCount );
-	aVertBuf.realloc( nVertCount );
-	pGraphics->DrawGrid( nStartX, nEndX, aHorzBuf, nStartY, nEndY, aVertBuf, nFlags );
-#endif // REMOTE_APPSERVER
+	EnableMapMode( bOldMap );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawGrid( rRect, rDist, nFlags );
 }
 
 // ------------------------------------------------------------------------
@@ -241,6 +225,13 @@ void OutputDevice::DrawTransparent( cons
 		if( mpMetaFile )
 			mpMetaFile->AddAction( new MetaTransparentAction( rPolyPoly, nTransparencePercent ) );
 
+        VirtualDevice* pOldAlphaVDev = mpAlphaVDev;
+
+        // #110958# Disable alpha VDev, we perform the necessary
+        // operation explicitely further below.
+        if( mpAlphaVDev )
+            mpAlphaVDev = NULL;
+
 		if( !IsDeviceOutputNecessary() || ( !mbLineColor && !mbFillColor ) || ImplIsRecordLayout() )
 			return;
 
@@ -272,7 +263,7 @@ void OutputDevice::DrawTransparent( cons
 			Rectangle aRect( aPolyRect.TopLeft(), Size( aPolyRect.GetWidth(), nBaseExtent ) );
 
 			const BOOL bOldMap = mbMap;
-			mbMap = FALSE;
+			EnableMapMode( FALSE );
 
 			while( aRect.Top() <= aPolyRect.Bottom() )
 			{
@@ -287,12 +278,11 @@ void OutputDevice::DrawTransparent( cons
 				aRect.Move( nMove, 0 );
 			}
 
-			mbMap = bOldMap;
+			EnableMapMode( bOldMap );
 			Pop();
 		}
 		else
 		{
-#ifndef REMOTE_APPSERVER
 			PolyPolygon 	aPolyPoly( LogicToPixel( rPolyPoly ) );
 			Rectangle		aPolyRect( aPolyPoly.GetBoundRect() );
 			Point			aPoint;
@@ -321,7 +311,7 @@ void OutputDevice::DrawTransparent( cons
 				{
 					const BOOL bOldMap = mbMap;
 
-					mbMap = FALSE;
+					EnableMapMode( FALSE );
 
 					aVDev.SetLineColor( COL_BLACK );
 					aVDev.SetFillColor( COL_BLACK );
@@ -438,7 +428,7 @@ void OutputDevice::DrawTransparent( cons
 
                         DrawBitmap( aDstRect.TopLeft(), aPaint );
 
-                        mbMap = bOldMap;
+                        EnableMapMode( bOldMap );
 
                         if( mbLineColor )
                         {
@@ -452,20 +442,25 @@ void OutputDevice::DrawTransparent( cons
 				else
 					DrawPolyPolygon( rPolyPoly );
 			}
-#else // REMOTE_APPSERVER
-			ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-			if ( pGraphics )
-			{
-				if ( mbInitLineColor )
-					ImplInitLineColor();
-				if ( mbInitFillColor )
-					ImplInitFillColor();
-				pGraphics->DrawTransparent( ImplLogicToDevicePixel( rPolyPoly ), nTransparencePercent );
-			}
-#endif // REMOTE_APPSERVER
 		}
 
 		mpMetaFile = pOldMetaFile;
+
+        // #110958# Restore disabled alpha VDev
+        mpAlphaVDev = pOldAlphaVDev;
+
+        // #110958# Apply alpha value also to VDev alpha channel
+        if( mpAlphaVDev )
+        {
+            const Color aFillCol( mpAlphaVDev->GetFillColor() );
+            mpAlphaVDev->SetFillColor( Color(255*nTransparencePercent/100,
+                                             255*nTransparencePercent/100,
+                                             255*nTransparencePercent/100) );
+
+            mpAlphaVDev->DrawTransparent( rPolyPoly, nTransparencePercent );
+
+            mpAlphaVDev->SetFillColor( aFillCol );
+        }
 	}
 }
 
@@ -511,8 +506,8 @@ void OutputDevice::DrawTransparent( cons
 		{
 			VirtualDevice* pVDev = new VirtualDevice;
 
-			pVDev->mnDPIX = mnDPIX;
-			pVDev->mnDPIY = mnDPIY;
+			((OutputDevice*)pVDev)->mnDPIX = mnDPIX;
+			((OutputDevice*)pVDev)->mnDPIY = mnDPIY;
 
 			if( pVDev->SetOutputSizePixel( aDstRect.GetSize() ) )
 			{
@@ -553,17 +548,13 @@ void OutputDevice::DrawTransparent( cons
 				pVDev->EnableMapMode( FALSE );
 				pVDev->DrawMask( Point(), pVDev->GetOutputSizePixel(), aMask, Color( COL_WHITE ) );
 
-#ifndef REMOTE_APPSERVER
 				aAlpha = pVDev->GetBitmap( Point(), pVDev->GetOutputSizePixel() );
-#else
-				aAlpha.ImplSetBitmap( pVDev->GetBitmap( Point(), pVDev->GetOutputSizePixel() ) );
-#endif
 
 				delete pVDev;
 
-				mbMap = FALSE;
+				EnableMapMode( FALSE );
 				DrawBitmapEx( aDstRect.TopLeft(), BitmapEx( aPaint, aAlpha ) );
-				mbMap = bOldMap;
+				EnableMapMode( bOldMap );
 			}
 			else
 				delete pVDev;
@@ -579,7 +570,6 @@ void OutputDevice::ImplDrawColorWallpape
 										   long nWidth, long nHeight,
 										   const Wallpaper& rWallpaper )
 {
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !mpGraphics )
 	{
@@ -604,23 +594,6 @@ void OutputDevice::ImplDrawColorWallpape
 	mpGraphics->DrawRect( nX+mnOutOffX, nY+mnOutOffY, nWidth, nHeight, this );
 	SetLineColor( aOldLineColor );
 	SetFillColor( aOldFillColor );
-#else
-	ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-	if ( pGraphics )
-	{
-		Color aOldLineColor = GetLineColor();
-		Color aOldFillColor = GetFillColor();
-		SetLineColor();
-		SetFillColor( rWallpaper.GetColor() );
-		if ( mbInitLineColor )
-			ImplInitLineColor();
-		if ( mbInitFillColor )
-			ImplInitFillColor();
-		pGraphics->DrawRect( Rectangle( Point( nX+mnOutOffX, nY+mnOutOffY ), Size( nWidth, nHeight ) ) );
-		SetLineColor( aOldLineColor );
-		SetFillColor( aOldFillColor );
-	}
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -699,7 +672,7 @@ void OutputDevice::ImplDrawBitmapWallpap
 	}
 
 	mpMetaFile = NULL;
-	mbMap = FALSE;
+	EnableMapMode( FALSE );
 	Push( PUSH_CLIPREGION );
 	IntersectClipRegion( Rectangle( Point( nX, nY ), Size( nWidth, nHeight ) ) );
 
@@ -862,7 +835,7 @@ void OutputDevice::ImplDrawBitmapWallpap
 	rWallpaper.ImplGetImpWallpaper()->ImplSetCachedBitmap( aBmpEx );
 
 	Pop();
-	mbMap = bOldMap;
+	EnableMapMode( bOldMap );
 	mpMetaFile = pOldMetaFile;
 }
 
@@ -884,14 +857,14 @@ void OutputDevice::ImplDrawGradientWallp
 		aBound = Rectangle( Point( nX, nY ), Size( nWidth, nHeight ) );
 
 	mpMetaFile = NULL;
-	mbMap = FALSE;
+	EnableMapMode( FALSE );
 	Push( PUSH_CLIPREGION );
 	IntersectClipRegion( Rectangle( Point( nX, nY ), Size( nWidth, nHeight ) ) );
 
 	DrawGradient( aBound, rWallpaper.GetGradient() );
 
 	Pop();
-	mbMap = bOldMap;
+	EnableMapMode( bOldMap );
 	mpMetaFile = pOldMetaFile;
 }
 
@@ -931,6 +904,9 @@ void OutputDevice::DrawWallpaper( const 
 							   rWallpaper );
 		}
 	}
+    
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawWallpaper( rRect, rWallpaper );
 }
 
 // -----------------------------------------------------------------------
@@ -949,6 +925,9 @@ void OutputDevice::Erase()
 		if ( eRasterOp != ROP_OVERPAINT )
 			SetRasterOp( eRasterOp );
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->Erase();
 }
 
 // -----------------------------------------------------------------------
@@ -957,40 +936,12 @@ void OutputDevice::ImplDraw2ColorFrame( 
 										const Color& rLeftTopColor,
 										const Color& rRightBottomColor )
 {
-#ifndef REMOTE_APPSERVER
 	SetFillColor( rLeftTopColor );
 	DrawRect( Rectangle( rRect.TopLeft(), Point( rRect.Left(), rRect.Bottom()-1 ) ) );
 	DrawRect( Rectangle( rRect.TopLeft(), Point( rRect.Right()-1, rRect.Top() ) ) );
 	SetFillColor( rRightBottomColor );
 	DrawRect( Rectangle( rRect.BottomLeft(), rRect.BottomRight() ) );
 	DrawRect( Rectangle( rRect.TopRight(), rRect.BottomRight() ) );
-#else
-	if ( mpMetaFile )
-	{
-		BOOL bOutputEnabled = IsOutputEnabled();
-		EnableOutput( FALSE );
-		SetFillColor( rLeftTopColor );
-		DrawRect( Rectangle( rRect.TopLeft(), Point( rRect.Left(), rRect.Bottom()-1 ) ) );
-		DrawRect( Rectangle( rRect.TopLeft(), Point( rRect.Right()-1, rRect.Top() ) ) );
-		SetFillColor( rRightBottomColor );
-		DrawRect( Rectangle( rRect.BottomLeft(), rRect.BottomRight() ) );
-		DrawRect( Rectangle( rRect.TopRight(), rRect.BottomRight() ) );
-		EnableOutput( bOutputEnabled );
-	}
-
-	if ( IsDeviceOutputNecessary() && !rRect.IsEmpty() )
-	{
-		ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-		if ( pGraphics )
-		{
-			if ( mbInitLineColor )
-				ImplInitLineColor();
-			Rectangle aRect( ImplLogicToDevicePixel( rRect ) );
-			pGraphics->Draw2ColorFrame( aRect, rLeftTopColor, rRightBottomColor );
-		}
-	}
-	SetFillColor( rRightBottomColor );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -1011,6 +962,9 @@ void OutputDevice::DrawEPS( const Point&
 	if ( !IsDeviceOutputNecessary() || ImplIsRecordLayout() )
 		return;
 
+	if( mbOutputClipped )
+		return;
+
 	Rectangle	aRect( ImplLogicToDevicePixel( Rectangle( rPoint, rSize ) ) );
 	BOOL		bDrawn = FALSE;
 
@@ -1020,21 +974,14 @@ void OutputDevice::DrawEPS( const Point&
 
 		if( GetOutDevType() == OUTDEV_PRINTER )
 		{
-#ifndef REMOTE_APPSERVER
 			if( !mpGraphics && !ImplGetGraphics() )
 				return;
 
 			if( mbInitClipRegion )
 				ImplInitClipRegion();
 
-			if( !mbOutputClipped )
-			{
-				bDrawn = mpGraphics->DrawEPS( aRect.Left(), aRect.Top(), aRect.GetWidth(), aRect.GetHeight(),
-											  (BYTE*) rGfxLink.GetData(), rGfxLink.GetDataSize(), this );
-			}
-#else
-			DBG_ERROR( "No direct EPS-support for remote appserver!" );
-#endif
+            bDrawn = mpGraphics->DrawEPS( aRect.Left(), aRect.Top(), aRect.GetWidth(), aRect.GetHeight(),
+                                          (BYTE*) rGfxLink.GetData(), rGfxLink.GetDataSize(), this );
 		}
 
 		if( !bDrawn && pSubst )
@@ -1046,4 +993,7 @@ void OutputDevice::DrawEPS( const Point&
 			mpMetaFile = pOldMetaFile;
 		}
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->DrawEPS( rPoint, rSize, rGfxLink, pSubst );
 }
Index: vcl/source/gdi/outmap.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/outmap.cxx,v
retrieving revision 1.10.122.1
retrieving revision 1.13
diff -u -p -u -r1.10.122.1 -r1.13
--- vcl/source/gdi/outmap.cxx	17 Sep 2003 08:35:33 -0000	1.10.122.1
+++ vcl/source/gdi/outmap.cxx	6 Jan 2004 13:51:57 -0000	1.13
@@ -61,8 +61,6 @@
 
 #include <limits.h>
 
-#define _SV_OUTMAP_CXX
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -74,10 +72,13 @@
 #include <tools/debug.hxx>
 #endif
 
+#ifndef _SV_VIRDEV_HXX
+#include <virdev.hxx>
+#endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
 #endif
-#ifndef _POLY_HXX
+#ifndef _TL_POLY_HXX
 #include <tools/poly.hxx>
 #endif
 #ifndef _SV_REGION_HXX
@@ -811,6 +812,16 @@ Region OutputDevice::ImplPixelToDevicePi
 
 // -----------------------------------------------------------------------
 
+void OutputDevice::EnableMapMode( BOOL bEnable ) 
+{ 
+    mbMap = (bEnable != 0); 
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->EnableMapMode( bEnable );    
+}
+
+// -----------------------------------------------------------------------
+
 void OutputDevice::SetMapMode()
 {
 	DBG_CHKTHIS( OutputDevice, ImplDbgCheckOutputDevice );
@@ -836,6 +847,9 @@ void OutputDevice::SetMapMode()
         mnOutOffLogicX = mnOutOffOrigX; // no mapping -> equal offsets
         mnOutOffLogicY = mnOutOffOrigY;
 	}
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetMapMode();    
 }
 
 // -----------------------------------------------------------------------
@@ -859,6 +873,9 @@ void OutputDevice::SetMapMode( const Map
 	if ( maMapMode == rNewMapMode )
 		return;
 
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetMapMode( rNewMapMode );
+
 	// Ist Default-MapMode, dann bereche nichts
 	BOOL bOldMap = mbMap;
 	mbMap = !rNewMapMode.IsDefault();
@@ -999,6 +1016,9 @@ void OutputDevice::SetRelativeMapMode( c
 	mnOutOffLogicY = ImplPixelToLogic( mnOutOffOrigY, mnDPIY,
                                        maMapRes.mnMapScNumY, maMapRes.mnMapScDenomY,
                                        maThresRes.mnThresPixToLogY );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetRelativeMapMode( rNewMapMode );
 }
 
 // -----------------------------------------------------------------------
@@ -2113,6 +2133,9 @@ void OutputDevice::SetPixelOffset( const
 	mnOutOffLogicY = ImplPixelToLogic( mnOutOffOrigY, mnDPIY,
                                        maMapRes.mnMapScNumY, maMapRes.mnMapScDenomY,
                                        maThresRes.mnThresPixToLogY );
+
+    if( mpAlphaVDev )
+        mpAlphaVDev->SetPixelOffset( rOffset );
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/gdi/pdfwriter.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/pdfwriter.cxx,v
retrieving revision 1.8
retrieving revision 1.9
diff -u -p -u -r1.8 -r1.9
--- vcl/source/gdi/pdfwriter.cxx	28 May 2003 12:30:50 -0000	1.8
+++ vcl/source/gdi/pdfwriter.cxx	17 Jun 2004 12:19:19 -0000	1.9
@@ -129,7 +129,7 @@ void PDFWriter::DrawTextLine(
 void PDFWriter::DrawTextArray(
                               const Point& rStartPt,
                               const XubString& rStr,
-                              const long* pDXAry,
+                              const sal_Int32* pDXAry,
                               xub_StrLen nIndex,
                               xub_StrLen nLen )
 {
Index: vcl/source/gdi/pdfwriter_impl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/pdfwriter_impl.cxx,v
retrieving revision 1.55.10.6
retrieving revision 1.68
diff -u -p -u -r1.55.10.6 -r1.68
--- vcl/source/gdi/pdfwriter_impl.cxx	13 Feb 2004 13:20:46 -0000	1.55.10.6
+++ vcl/source/gdi/pdfwriter_impl.cxx	17 Jun 2004 12:39:36 -0000	1.68
@@ -59,6 +59,9 @@
  *
  ************************************************************************/
 
+#define _USE_MATH_DEFINES
+#include <math.h>
+
 #include <pdfwriter_impl.hxx>
 #include <rtl/strbuf.hxx>
 #include <tools/debug.hxx>
@@ -71,29 +74,14 @@
 #include <outdev.h>
 #include <sallayout.hxx>
 #include <metric.hxx>
-#ifndef REMOTE_APPSERVER
 #include <svsys.h>
 #include <salgdi.hxx>
-#else
-#include <rmoutdev.hxx>
-#endif
 #include <osl/thread.h>
 #include <osl/file.h>
 #include <rtl/crc.h>
 
 #include "implncvt.hxx"
 
-#include <math.h>
-#ifdef WNT
-// Aaarrgh
-#define M_PI 3.14159265
-#endif
-
-#define ENABLE_COMPRESSION
-#if OSL_DEBUG_LEVEL < 2
-#define COMPRESS_PAGES
-#endif
-
 using namespace vcl;
 using namespace rtl;
 
@@ -246,6 +234,117 @@ static void appendNonStrokingColor( cons
     }
 }
 
+// matrix helper class
+namespace vcl
+{
+/*	for sparse matrices of the form (2D linear transformations)
+ *  f[0] f[1] 0
+ *  f[2] f[3] 0
+ *  f[4] f[5] 1
+ */
+class Matrix3
+{
+    double f[6];
+
+    void set( double *pn ) { for( int i = 0 ; i < 5; i++ ) f[i] = pn[i]; }
+public:
+    Matrix3();
+    ~Matrix3() {}
+
+    void skew( double alpha, double beta );
+    void scale( double sx, double sy );
+    void rotate( double angle );
+    void translate( double tx, double ty );
+
+    void append( PDFWriterImpl::PDFPage& rPage, OStringBuffer& rBuffer, Point* pBack = NULL );
+
+    Point transform( const Point& rPoint );
+};
+}
+
+Matrix3::Matrix3()
+{
+    // initialize to unity
+    f[0] = 1.0;
+    f[1] = 0.0;
+    f[2] = 0.0;
+    f[3] = 1.0;
+    f[4] = 0.0;
+    f[5] = 0.0;
+}
+
+Point Matrix3::transform( const Point& rOrig )
+{
+    double x = (double)rOrig.X(), y = (double)rOrig.Y();
+    return Point( (int)(x*f[0] + y*f[2] + f[4]), (int)(x*f[1] + y*f[3] + f[5]) );
+}
+
+void Matrix3::skew( double alpha, double beta )
+{
+    double fn[6];
+    double tb = tan( beta );
+    fn[0] = f[0] + f[2]*tb;
+    fn[1] = f[1];
+    fn[2] = f[2] + f[3]*tb;
+    fn[3] = f[3];
+    fn[4] = f[4] + f[5]*tb;
+    fn[5] = f[5];
+    if( alpha != 0.0 )
+    {
+        double ta = tan( alpha );
+        fn[1] += f[0]*ta;
+        fn[3] += f[2]*ta;
+        fn[5] += f[4]*ta;
+    }
+    set( fn );
+}
+
+void Matrix3::scale( double sx, double sy )
+{
+    double fn[6];
+    fn[0] = sx*f[0];
+    fn[1] = sy*f[1];
+    fn[2] = sx*f[2];
+    fn[3] = sy*f[3];
+    fn[4] = sx*f[4];
+    fn[5] = sy*f[5];
+    set( fn );
+}
+
+void Matrix3::rotate( double angle )
+{
+    double fn[6];
+    double fSin = sin(angle);
+    double fCos = cos(angle);
+    fn[0] = f[0]*fCos - f[1]*fSin;
+    fn[1] = f[0]*fSin + f[1]*fCos;
+    fn[2] = f[2]*fCos - f[3]*fSin;
+    fn[3] = f[2]*fSin + f[3]*fCos;
+    fn[4] = f[4]*fCos - f[5]*fSin;
+    fn[5] = f[4]*fSin + f[5]*fCos;
+    set( fn );
+}
+
+void Matrix3::translate( double tx, double ty )
+{
+    f[4] += tx;
+    f[5] += ty;
+}
+
+void Matrix3::append( PDFWriterImpl::PDFPage& rPage, OStringBuffer& rBuffer, Point* pBack )
+{
+    appendDouble( f[0], rBuffer );
+    rBuffer.append( ' ' );
+    appendDouble( f[1], rBuffer );
+    rBuffer.append( ' ' );
+    appendDouble( f[2], rBuffer );
+    rBuffer.append( ' ' );
+    appendDouble( f[3], rBuffer );    
+    rBuffer.append( ' ' );
+    rPage.appendPoint( Point( (long)f[4], (long)f[5] ), rBuffer, false, pBack );
+}
+
+
 
 PDFWriterImpl::PDFPage::PDFPage( PDFWriterImpl* pWriter, sal_Int32 nPageWidth, sal_Int32 nPageHeight, PDFWriter::Orientation eOrientation )
         :
@@ -277,7 +376,7 @@ void PDFWriterImpl::PDFPage::beginStream
     aLine.append( " 0 obj\r\n<< /Length " );
     aLine.append( m_nStreamLengthObject );
     aLine.append( " 0 R\r\n" );
-#if defined COMPRESS_PAGES && defined ENABLE_COMPRESSION
+#if defined ( COMPRESS_PAGES ) && !defined ( DEBUG_DISABLE_PDFCOMPRESSION )
     aLine.append( "   /Filter /FlateDecode\r\n" );
 #endif
     aLine.append( ">>\r\nstream\r\n" );
@@ -288,7 +387,7 @@ void PDFWriterImpl::PDFPage::beginStream
         osl_closeFile( m_pWriter->m_aFile );
         m_pWriter->m_bOpen = false;
     }
-#if defined COMPRESS_PAGES && defined ENABLE_COMPRESSION
+#if defined ( COMPRESS_PAGES ) && !defined ( DEBUG_DISABLE_PDFCOMPRESSION )
     m_pWriter->beginCompression();
 #endif
 }
@@ -329,9 +428,6 @@ bool PDFWriterImpl::PDFPage::emit(sal_In
                   "   /Parent " );
     aLine.append( nParentObject );
     aLine.append( " 0 R\r\n" );
-    aLine.append( "   /Resources " );
-    aLine.append( m_pWriter->m_nResourceDict );
-    aLine.append( " 0 R\r\n" );
     if( m_nPageWidth && m_nPageHeight )
     {
         aLine.append( "   /MediaBox [ 0 0 " );
@@ -428,9 +524,9 @@ void PDFWriterImpl::PDFPage::appendRect(
 {
     appendPoint( rRect.BottomLeft() + Point( 0, 1 ), rBuffer );
     rBuffer.append( ' ' );
-    appendMappedLength( rRect.GetWidth(), rBuffer, false );
+    appendMappedLength( (sal_Int32)rRect.GetWidth(), rBuffer, false );
     rBuffer.append( ' ' );
-    appendMappedLength( rRect.GetHeight(), rBuffer, true );
+    appendMappedLength( (sal_Int32)rRect.GetHeight(), rBuffer, true );
     rBuffer.append( " re" );
 }
 
@@ -545,23 +641,23 @@ void PDFWriterImpl::PDFPage::appendLineI
         rBuffer.append( "[ " );
         for( int n = 0; n < rInfo.GetDashCount(); n++ )
         {
-            appendMappedLength( rInfo.GetDashLen(), rBuffer );
+            appendMappedLength( (sal_Int32)rInfo.GetDashLen(), rBuffer );
             rBuffer.append( ' ' );
-            appendMappedLength( rInfo.GetDistance(), rBuffer );
+            appendMappedLength( (sal_Int32)rInfo.GetDistance(), rBuffer );
             rBuffer.append( ' ' );
         }
         for( int m = 0; m < rInfo.GetDotCount(); m++ )
         {
-            appendMappedLength( rInfo.GetDotLen(), rBuffer );
+            appendMappedLength( (sal_Int32)rInfo.GetDotLen(), rBuffer );
             rBuffer.append( ' ' );
-            appendMappedLength( rInfo.GetDistance(), rBuffer );
+            appendMappedLength( (sal_Int32)rInfo.GetDistance(), rBuffer );
             rBuffer.append( ' ' );
         }
         rBuffer.append( "] 0 d\r\n" );
     }
     if( rInfo.GetWidth() > 1 )
     {
-        appendMappedLength( rInfo.GetWidth(), rBuffer );
+        appendMappedLength( (sal_Int32)rInfo.GetWidth(), rBuffer );
         rBuffer.append( " w\r\n" );
     }
     else if( rInfo.GetWidth() == 0 )
@@ -620,7 +716,6 @@ PDFWriterImpl::PDFWriterImpl( const OUSt
         m_nInheritedPageHeight( 842 ), // default A4
         m_eInheritedOrientation( PDFWriter::Portrait ),
         m_nCurrentPage( -1 ),
-        m_nResourceDict( -1 ),
         m_eVersion( eVersion ),
         m_eCompression( eCompression ),
         m_aFileName( rFilename ),
@@ -695,7 +790,7 @@ void PDFWriterImpl::emitComment( const O
 
 void PDFWriterImpl::beginCompression()
 {
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     m_pCodec = new ZCodec( 0x4000, 0x4000 );
     m_pMemStream = new SvMemoryStream();
     m_pCodec->BeginCompression();
@@ -704,7 +799,7 @@ void PDFWriterImpl::beginCompression()
 
 void PDFWriterImpl::endCompression()
 {
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     if( m_pCodec )
     {
         m_pCodec->EndCompression();
@@ -753,24 +848,19 @@ OutputDevice* PDFWriterImpl::getReferenc
     if( ! m_pReferenceDevice )
     {
         VirtualDevice*  pVDev = new VirtualDevice( 0 );
-        sal_Int32       nDPI;
 
         m_pReferenceDevice = pVDev;
-        pVDev->SetReferenceDevice();
 
+        VirtualDevice::RefDevMode eMode = VirtualDevice::REFDEV_MODE06;
         switch( m_eCompression )
         {
-            case( PDFWriter::Print ): nDPI = 1200; break;
-            case( PDFWriter::Press ): nDPI = 2400; break;
-
-            default:
-                nDPI = 600;
-            break;
+            case( PDFWriter::Print ): eMode = VirtualDevice::REFDEV_MODE48; break;
+            case( PDFWriter::Press ): eMode = VirtualDevice::REFDEV_MODE96; break;
         }
+        pVDev->SetReferenceDevice( eMode );
 
         pVDev->SetOutputSizePixel( Size( 640, 480 ) );
         pVDev->SetMapMode( MAP_MM );
-        pVDev->mnDPIX = pVDev->mnDPIY = nDPI;
 
         m_pReferenceDevice->mpPDFWriter = this;
         m_pReferenceDevice->ImplUpdateFontData( TRUE );
@@ -781,7 +871,6 @@ OutputDevice* PDFWriterImpl::getReferenc
 ImplDevFontList* PDFWriterImpl::filterDevFontList( ImplDevFontList* pFontList )
 {
     DBG_ASSERT( m_aSubsets.size() == 0, "Fonts changing during PDF generation, document will be invalid" );
-
     ImplDevFontList* pFiltered = new ImplDevFontList();
 
     ImplDevFontListData* pData = pFontList->First();
@@ -1403,7 +1493,7 @@ std::map< sal_Int32, sal_Int32 > PDFWrit
                       "<< /Length " );
         aLine.append( nStreamLengthObject );
         aLine.append( " 0 R\r\n"
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
                       "   /Filter /FlateDecode\r\n"
 #endif
                       "   /Length1 " );
@@ -1764,7 +1854,7 @@ sal_Int32 PDFWriterImpl::createToUnicode
                       "CMapName currentdict /CMap defineresource pop\r\n"
                       "end\r\n"
                       "end\r\n" );
-#if defined COMPRESS_PAGES && defined ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     ZCodec* pCodec = new ZCodec( 0x4000, 0x4000 );
     SvMemoryStream aStream;
     pCodec->BeginCompression();
@@ -1777,7 +1867,7 @@ sal_Int32 PDFWriterImpl::createToUnicode
 
     aLine.append( nStream );
     aLine.append( " 0 obj\r\n<< /Length " );
-#if defined COMPRESS_PAGES && defined ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     sal_Int32 nLen = (sal_Int32)aStream.Tell();
     aStream.Seek( 0 );
     aLine.append( nLen );
@@ -1787,7 +1877,7 @@ sal_Int32 PDFWriterImpl::createToUnicode
 #endif
     aLine.append( " >>\r\nstream\r\n" );
     CHECK_RETURN( writeBuffer( aLine.getStr(), aLine.getLength() ) );
-#if defined COMPRESS_PAGES && defined ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     CHECK_RETURN( writeBuffer( aStream.GetData(), nLen ) );
 #else
     CHECK_RETURN( writeBuffer( aContents.getStr(), aContents.getLength() ) );
@@ -1884,11 +1974,7 @@ sal_Int32 PDFWriterImpl::emitFonts()
     if( ! m_aSubsets.size() && ! m_aEmbeddedFonts.size() ) // no fonts
         return 0;
 
-#ifndef REMOTE_APPSERVER
     if( ! m_pReferenceDevice->ImplGetGraphics() )
-#else
-    if( ! m_pReferenceDevice->ImplGetServerGraphics() )
-#endif
         return 0;
 
     OStringBuffer aLine( 1024 );
@@ -1902,7 +1988,7 @@ sal_Int32 PDFWriterImpl::emitFonts()
     {
         for( FontEmitList::iterator lit = it->second.m_aSubsets.begin(); lit != it->second.m_aSubsets.end(); ++lit )
         {
-            long pGlyphIDs[ 256 ];
+            sal_Int32 pGlyphIDs[ 256 ];
             sal_Int32 pWidths[ 256 ];
             sal_uInt8 pEncoding[ 256 ];
             sal_Unicode pUnicodes[ 256 ];
@@ -1954,7 +2040,7 @@ sal_Int32 PDFWriterImpl::emitFonts()
                               "<< /Length " );
                 aLine.append( (sal_Int32)nStreamLengthObject );
                 aLine.append( " 0 R\r\n"
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
                               "   /Filter /FlateDecode\r\n"
 #endif
                               "   /Length1 " );
@@ -2226,14 +2312,13 @@ bool PDFWriterImpl::emitCatalog()
     // first create a page tree node id
     sal_Int32 nTreeNode = createObject();
 
-    // emit global resource dictionary (page emit needs it)
-    m_nResourceDict = emitResources();
-
     // emit all pages
     for( std::list<PDFPage>::iterator it = m_aPages.begin(); it != m_aPages.end(); ++it )
         if( ! it->emit( nTreeNode ) )
             return false;
 
+    sal_Int32 nResourceDict = emitResources();
+
     // adjust tree node file offset
     if( ! updateObject( nTreeNode ) )
         return false;
@@ -2244,7 +2329,7 @@ bool PDFWriterImpl::emitCatalog()
     aLine.append( " 0 obj\r\n" );
     aLine.append( "<< /Type /Pages\r\n" );
     aLine.append( "   /Resources " );
-    aLine.append( m_nResourceDict );
+    aLine.append( nResourceDict );
     aLine.append( " 0 R\r\n" );
     switch( m_eInheritedOrientation )
     {
@@ -2468,7 +2553,7 @@ bool PDFWriterImpl::emit()
 
 void PDFWriterImpl::registerGlyphs(
                                    int nGlyphs,
-                                   long* pGlyphs,
+                                   sal_Int32* pGlyphs,
                                    sal_Unicode* pUnicodes,
                                    sal_uInt8* pMappedGlyphs,
                                    sal_Int32* pMappedFontObjects,
@@ -2535,10 +2620,8 @@ void PDFWriterImpl::registerGlyphs(
 
             const std::map< sal_Unicode, sal_Int32 >* pEncoding = NULL;
             const std::map< sal_Unicode, rtl::OString >* pNonEncoded = NULL;
-#ifndef REMOTE_APPSERVER
             getReferenceDevice()->ImplGetGraphics();
             pEncoding = m_pReferenceDevice->mpGraphics->GetFontEncodingVector( pCurrentFont, &pNonEncoded );
-#endif
 
             std::map< sal_Unicode, sal_Int32 >::const_iterator enc_it;
             std::map< sal_Unicode, rtl::OString >::const_iterator nonenc_it;
@@ -2608,131 +2691,112 @@ void PDFWriterImpl::registerGlyphs(
     }
 }
 
-void PDFWriterImpl::drawLayout( SalLayout& rLayout, const String& rText, bool bTextLines )
+void PDFWriterImpl::drawRelief( SalLayout& rLayout, const String& rText, bool bTextLines )
 {
-    FontRelief eRelief = m_aCurrentPDFState.m_aFont.GetRelief();
-    // relief takes precedence over shadow (see outdev3.cxx)
-    if(  eRelief != RELIEF_NONE )
-    {
-        push( PUSH_ALL );
+    push( PUSH_ALL );
 
-        Color aTextColor = m_aCurrentPDFState.m_aFont.GetColor();
-        Color aTextLineColor = m_aCurrentPDFState.m_aTextLineColor;
-        Color aReliefColor( COL_LIGHTGRAY );
-        if( aTextColor == COL_BLACK )
-            aTextColor = Color( COL_WHITE );
-        if( aTextLineColor == COL_BLACK )
-            aTextLineColor = Color( COL_WHITE );
-        if( aTextColor == COL_WHITE )
-            aReliefColor = Color( COL_BLACK );
-
-        Font aSetFont = m_aCurrentPDFState.m_aFont;
-        aSetFont.SetRelief( RELIEF_NONE );
-        aSetFont.SetShadow( FALSE );
-
-        aSetFont.SetColor( aReliefColor );
-        setTextLineColor( aTextLineColor );
-        setFont( aSetFont );
-        long nOff = 1 + getReferenceDevice()->mnDPIX/300;
-        if( eRelief == RELIEF_ENGRAVED )
-            nOff = -nOff;
+    FontRelief eRelief = m_aCurrentPDFState.m_aFont.GetRelief();
 
-        rLayout.DrawOffset() += Point( nOff, nOff );
-        updateGraphicsState();
-        drawLayout( rLayout, rText, bTextLines );
+    Color aTextColor = m_aCurrentPDFState.m_aFont.GetColor();
+    Color aTextLineColor = m_aCurrentPDFState.m_aTextLineColor;
+    Color aReliefColor( COL_LIGHTGRAY );
+    if( aTextColor == COL_BLACK )
+        aTextColor = Color( COL_WHITE );
+    if( aTextLineColor == COL_BLACK )
+        aTextLineColor = Color( COL_WHITE );
+    if( aTextColor == COL_WHITE )
+        aReliefColor = Color( COL_BLACK );
+    
+    Font aSetFont = m_aCurrentPDFState.m_aFont;
+    aSetFont.SetRelief( RELIEF_NONE );
+    aSetFont.SetShadow( FALSE );
+    
+    aSetFont.SetColor( aReliefColor );
+    setTextLineColor( aTextLineColor );
+    setFont( aSetFont );
+    long nOff = 1 + getReferenceDevice()->mnDPIX/300;
+    if( eRelief == RELIEF_ENGRAVED )
+        nOff = -nOff;
+    
+    rLayout.DrawOffset() += Point( nOff, nOff );
+    updateGraphicsState();
+    drawLayout( rLayout, rText, bTextLines );
+    
+    rLayout.DrawOffset() -= Point( nOff, nOff );
+    setTextLineColor( aTextLineColor );
+    aSetFont.SetColor( aTextColor );
+    setFont( aSetFont );
+    updateGraphicsState();
+    drawLayout( rLayout, rText, bTextLines );
+    
+    // clean up the mess
+    pop();
+}
 
-        rLayout.DrawOffset() -= Point( nOff, nOff );
-        setTextLineColor( aTextLineColor );
-        aSetFont.SetColor( aTextColor );
-        setFont( aSetFont );
-        updateGraphicsState();
-        drawLayout( rLayout, rText, bTextLines );
+void PDFWriterImpl::drawShadow( SalLayout& rLayout, const String& rText, bool bTextLines )
+{
+    Font aSaveFont = m_aCurrentPDFState.m_aFont;
+    Color aSaveTextLineColor = m_aCurrentPDFState.m_aTextLineColor;
+    
+    Font& rFont = m_aCurrentPDFState.m_aFont;
+    if( rFont.GetColor() == Color( COL_BLACK ) || rFont.GetColor().GetLuminance() < 8 )
+        rFont.SetColor( Color( COL_LIGHTGRAY ) );
+    else
+        rFont.SetColor( Color( COL_BLACK ) );
+    rFont.SetShadow( FALSE );
+    rFont.SetOutline( FALSE );
+    setFont( rFont );
+    setTextLineColor( rFont.GetColor() );
+    updateGraphicsState();
+    
+    long nOff = 1 + ((m_pReferenceDevice->mpFontEntry->mnLineHeight-24)/24);
+    if( rFont.IsOutline() )
+        nOff++;
+    rLayout.DrawBase() += Point( nOff, nOff );
+    drawLayout( rLayout, rText, bTextLines );
+    rLayout.DrawBase() -= Point( nOff, nOff );
+    
+    setFont( aSaveFont );
+    setTextLineColor( aSaveTextLineColor );
+    updateGraphicsState();
+}
 
-        // clean up the mess
-        pop();
+void PDFWriterImpl::drawLayout( SalLayout& rLayout, const String& rText, bool bTextLines )
+{
+    // relief takes precedence over shadow (see outdev3.cxx)
+    if(  m_aCurrentPDFState.m_aFont.GetRelief() != RELIEF_NONE )
+    {
+        drawRelief( rLayout, rText, bTextLines );
         return;
     }
     else if( m_aCurrentPDFState.m_aFont.IsShadow() )
-    {
-        Font aSaveFont = m_aCurrentPDFState.m_aFont;
-        Color aSaveTextLineColor = m_aCurrentPDFState.m_aTextLineColor;
-
-        Font& rFont = m_aCurrentPDFState.m_aFont;
-        if( rFont.GetColor() == Color( COL_BLACK ) || rFont.GetColor().GetLuminance() < 8 )
-            rFont.SetColor( Color( COL_LIGHTGRAY ) );
-        else
-            rFont.SetColor( Color( COL_BLACK ) );
-        rFont.SetShadow( FALSE );
-        setFont( rFont );
-        setTextLineColor( rFont.GetColor() );
-        updateGraphicsState();
-
-        long nOff = 1 + ((m_pReferenceDevice->mpFontEntry->mnLineHeight-24)/24);
-        if( rFont.IsOutline() )
-            nOff++;
-        rLayout.DrawBase() += Point( nOff, nOff );
-        drawLayout( rLayout, rText, bTextLines );
-        rLayout.DrawBase() -= Point( nOff, nOff );
-
-        setFont( aSaveFont );
-        setTextLineColor( aSaveTextLineColor );
-        updateGraphicsState();
-    }
+        drawShadow( rLayout, rText, bTextLines );
 
     OStringBuffer aLine( 512 );
 
-    // setup text colors (if necessary)
-    bool bPop = false;
-    if( m_aCurrentPDFState.m_aFont.IsOutline() &&
-        m_aCurrentPDFState.m_aLineColor != m_aCurrentPDFState.m_aFont.GetColor() )
-    {
-        bPop = true;
-        aLine.append( "q " );
-        appendStrokingColor( m_aCurrentPDFState.m_aFont.GetColor(), aLine );
-        aLine.append( "\r\n" );
-    }
-    else if( m_aCurrentPDFState.m_aFillColor != m_aCurrentPDFState.m_aFont.GetColor() )
-    {
-        bPop = true;
-        aLine.append( "q " );
-        appendNonStrokingColor( m_aCurrentPDFState.m_aFont.GetColor(), aLine );
-        aLine.append( "\r\n" );
-    }
-
-    // begin text object
-    aLine.append( "BT\r\n" );
-    // outline attribute ?
-    if( m_aCurrentPDFState.m_aFont.IsOutline() )
-    {
-        aLine.append( "1 Tr " );
-        double fW = (double)m_aCurrentPDFState.m_aFont.GetHeight() / 30.0;
-        m_aPages.back().appendMappedLength( fW, aLine );
-        aLine.append ( " w\r\n" );
-    }
-
     const int nMaxGlyphs = 256;
 
-    // note: the layout calculates in outdevs device pixel !!
-
-    long pGlyphs[nMaxGlyphs];
+    sal_Int32 pGlyphs[nMaxGlyphs];
     sal_uInt8 pMappedGlyphs[nMaxGlyphs];
     sal_Int32 pMappedFontObjects[nMaxGlyphs];
     sal_Unicode pUnicodes[nMaxGlyphs];
     int pCharPosAry[nMaxGlyphs];
-    long nAdvanceWidths[nMaxGlyphs];
+    sal_Int32 nAdvanceWidths[nMaxGlyphs];
     ImplFontData* pFallbackFonts[nMaxGlyphs];
-    long *pAdvanceWidths = m_aCurrentPDFState.m_aFont.IsVertical() ? nAdvanceWidths : NULL;
-    long nGlyphFlags[nMaxGlyphs];
+    sal_Int32 *pAdvanceWidths = m_aCurrentPDFState.m_aFont.IsVertical() ? nAdvanceWidths : NULL;
+    sal_Int32 nGlyphFlags[nMaxGlyphs];
     int nGlyphs;
     int nIndex = 0;
     Point aPos, aLastPos(0, 0), aCumulativePos(0,0), aGlyphPos;
     bool bFirst = true, bWasYChange = false;
     int nMinCharPos = 0, nMaxCharPos = rText.Len()-1;
     double fXScale = 1.0;
+    double fSkew = 0.0;
     sal_Int32 nFontHeight = m_pReferenceDevice->mpFontEntry->maFontSelData.mnHeight;
     TextAlign eAlign = m_aCurrentPDFState.m_aFont.GetAlign();
 
     // transform font height back to current units
+    // note: the layout calculates in outdevs device pixel !!
     nFontHeight = m_pReferenceDevice->ImplDevicePixelToLogicHeight( nFontHeight );
     if( m_aCurrentPDFState.m_aFont.GetWidth() )
     {
@@ -2748,16 +2812,99 @@ void PDFWriterImpl::drawLayout( SalLayou
         // force state before GetFontMetric
         m_pReferenceDevice->ImplNewFont();
     }
+
+    // perform artificial italics if necessary
+    if( ( m_aCurrentPDFState.m_aFont.GetItalic() == ITALIC_NORMAL ||
+          m_aCurrentPDFState.m_aFont.GetItalic() == ITALIC_OBLIQUE ) &&
+        !( m_pReferenceDevice->mpFontEntry->maFontSelData.mpFontData->meItalic == ITALIC_NORMAL ||
+           m_pReferenceDevice->mpFontEntry->maFontSelData.mpFontData->meItalic == ITALIC_OBLIQUE )
+        )
+    {
+        fSkew = M_PI/12.0;
+    }
+
     // if the mapmode is distorted we need to adjust for that also
     if( m_aCurrentPDFState.m_aMapMode.GetScaleX() != m_aCurrentPDFState.m_aMapMode.GetScaleY() )
     {
         fXScale *= (double)(m_aCurrentPDFState.m_aMapMode.GetScaleX() / m_aCurrentPDFState.m_aMapMode.GetScaleY());
     }
 
-    double fAngle = (double)m_aCurrentPDFState.m_aFont.GetOrientation() * M_PI / 1800.0;
-    double fSin = sin( fAngle );
-    double fCos = cos( fAngle );
+    int nAngle = m_aCurrentPDFState.m_aFont.GetOrientation();
+    // normalize angles
+    while( nAngle < 0 )
+        nAngle += 3600;
+    nAngle = nAngle % 3600;
+    double fAngle = (double)nAngle * M_PI / 1800.0;
+
+    Matrix3 aRotScale;
+    aRotScale.scale( fXScale, 1.0 );
+    if( fAngle != 0.0 )
+        aRotScale.rotate( -fAngle );
     
+    bool bPop = false;
+    bool bABold = false;
+    // artificial bold necessary ?
+    int nBoldness = (int)m_aCurrentPDFState.m_aFont.GetWeight() - (int)m_pReferenceDevice->mpFontEntry->maFontSelData.mpFontData->meWeight;
+    if( nBoldness > 1 )
+    {
+        if( ! bPop )
+            aLine.append( "q " );
+        bPop = true;
+        bABold = true;
+    }
+    // setup text colors (if necessary)
+    Color aStrokeColor( COL_TRANSPARENT );
+    Color aNonStrokeColor( COL_TRANSPARENT );
+
+    if( m_aCurrentPDFState.m_aFont.IsOutline() )
+    {
+        aStrokeColor = m_aCurrentPDFState.m_aFont.GetColor();
+        aNonStrokeColor = Color( COL_WHITE );
+    }
+    else
+        aNonStrokeColor = m_aCurrentPDFState.m_aFont.GetColor();
+    if( bABold )
+        aStrokeColor = m_aCurrentPDFState.m_aFont.GetColor();
+
+    if( aStrokeColor != Color( COL_TRANSPARENT ) && aStrokeColor != m_aCurrentPDFState.m_aLineColor )
+    {
+        if( ! bPop )
+            aLine.append( "q " );
+        bPop = true;
+        appendStrokingColor( aStrokeColor, aLine );
+        aLine.append( "\r\n" );
+    }
+    if( aNonStrokeColor != Color( COL_TRANSPARENT ) && aNonStrokeColor != m_aCurrentPDFState.m_aFillColor )
+    {
+        if( ! bPop )
+            aLine.append( "q " );
+        bPop = true;
+        appendNonStrokingColor( aNonStrokeColor, aLine );
+        aLine.append( "\r\n" );
+    }
+
+    // begin text object
+    aLine.append( "BT\r\n" );
+    // outline attribute ?
+    if( m_aCurrentPDFState.m_aFont.IsOutline() || bABold )
+    {
+        // set correct text mode, set stroke width
+        aLine.append( "2 Tr " ); // fill, then stroke
+
+        if( m_aCurrentPDFState.m_aFont.IsOutline() )
+        {
+            // unclear what to do in case of outline and artificial bold
+            // for the time being outline wins
+            aLine.append( "0.25 w \r\n" );
+        }
+        else
+        {
+            double fW = (double)m_aCurrentPDFState.m_aFont.GetHeight() / 30.0;
+            m_aPages.back().appendMappedLength( fW, aLine );
+            aLine.append ( " w\r\n" );
+        }
+    }
+
     sal_Int32 nLastMappedFont = -1;
     while( (nGlyphs = rLayout.GetNextGlyphs( nMaxGlyphs, pGlyphs, aPos, nIndex, pAdvanceWidths, pCharPosAry )) )
     {
@@ -2774,8 +2921,7 @@ void PDFWriterImpl::drawLayout( SalLayou
 
         if( aDiff.X() || aDiff.Y() )
         {
-            aDiff = Point( (int)(fXScale * fCos * (double)aDiff.X() + fSin * (double)aDiff.Y()),
-                               -(int)(fXScale * fSin * (double)aDiff.X() - fCos * (double)aDiff.Y()) );
+            aDiff = aRotScale.transform( aDiff );
             aPos += aDiff;
         }
 
@@ -2816,6 +2962,8 @@ void PDFWriterImpl::drawLayout( SalLayou
                 double fDeltaAngle = 0.0;
                 double fYScale = 1.0;
                 double fTempXScale = fXScale;
+                double fSkewB = fSkew;
+                double fSkewA = 0.0;
 
                 Point aDeltaPos;
                 if( ( nGlyphFlags[n] & GF_ROTMASK ) == GF_ROTL )
@@ -2825,6 +2973,8 @@ void PDFWriterImpl::drawLayout( SalLayou
                     aDeltaPos.Y() = (int)((double)m_pReferenceDevice->GetFontMetric().GetDescent() * fXScale);
                     fYScale = fXScale;
                     fTempXScale = 1.0;
+                    fSkewA = -fSkewB;
+                    fSkewB = 0.0;
                 }
                 else if( ( nGlyphFlags[n] & GF_ROTMASK ) == GF_ROTR )
                 {
@@ -2833,6 +2983,8 @@ void PDFWriterImpl::drawLayout( SalLayou
                     aDeltaPos.Y() = -m_pReferenceDevice->GetFontMetric().GetAscent();
                     fYScale = fXScale;
                     fTempXScale = 1.0;
+                    fSkewA = fSkewB;
+                    fSkewB = 0.0;
                 }
                 aDeltaPos += (m_pReferenceDevice->PixelToLogic( Point( (int)((double)nXOffset/fXScale)/rLayout.GetUnitsPerPixel(), 0 ) ) - m_pReferenceDevice->PixelToLogic( Point() ) );
                 nXOffset += pAdvanceWidths[n];
@@ -2840,21 +2992,15 @@ void PDFWriterImpl::drawLayout( SalLayou
                     continue;
 
 
-                aDeltaPos = Point( (int)(fXScale * fCos * (double)aDeltaPos.X() + fSin * (double)aDeltaPos.Y()),
-                                   -(int)(fXScale * fSin * (double)aDeltaPos.X() - fCos * (double)aDeltaPos.Y()) );
+                aDeltaPos = aRotScale.transform( aDeltaPos );
 
-                double fDSin = sin( fAngle+fDeltaAngle );
-                double fDCos = cos( fAngle+fDeltaAngle );
-
-                appendDouble( fTempXScale*fDCos, aLine );
-                aLine.append( ' ' );
-                appendDouble( fDSin*fTempXScale, aLine );
-                aLine.append( ' ' );
-                appendDouble( -fDSin*fYScale, aLine );
-                aLine.append( ' ' );
-                appendDouble( fDCos*fYScale, aLine );
-                aLine.append( ' ' );
-                m_aPages.back().appendPoint( aPos+aDeltaPos, aLine );
+                Matrix3 aMat;
+                if( fSkewB != 0.0 || fSkewA != 0.0 )
+                    aMat.skew( fSkewA, fSkewB );
+                aMat.scale( fTempXScale, fYScale );
+                aMat.rotate( fAngle+fDeltaAngle );
+                aMat.translate( aPos.X()+aDeltaPos.X(), aPos.Y()+aDeltaPos.Y() );
+                aMat.append( m_aPages.back(), aLine );
                 aLine.append( " Tm" );
                 if( nLastMappedFont != pMappedFontObjects[n] )
                 {
@@ -2873,7 +3019,7 @@ void PDFWriterImpl::drawLayout( SalLayou
         else // normal case
         {
             // optimize use of Td vs. Tm
-            if( fXScale == 1.0 && fCos == 1.0 && fSin == 0.0 )
+            if( fAngle == 0.0 && fXScale == 1.0 && ( !bFirst || fSkew == 0.0 ) )
             {
                 if( bFirst )
                 {
@@ -2885,12 +3031,12 @@ void PDFWriterImpl::drawLayout( SalLayou
                 {
                     sal_Int32 nDiffL = 0;
                     Point aDiff = aPos - aLastPos;
-                    m_aPages.back().appendMappedLength( aDiff.X(), aLine, false, &nDiffL );
+                    m_aPages.back().appendMappedLength( (sal_Int32)aDiff.X(), aLine, false, &nDiffL );
                     aCumulativePos.X() += nDiffL;
                     aLine.append( ' ' );
                     if( bWasYChange )
                     {
-                        m_aPages.back().appendMappedLength( aDiff.Y(), aLine, true, &nDiffL );
+                        m_aPages.back().appendMappedLength( (sal_Int32)aDiff.Y(), aLine, true, &nDiffL );
                         aCumulativePos.Y() += nDiffL;
                     }
                     else
@@ -2912,17 +3058,16 @@ void PDFWriterImpl::drawLayout( SalLayou
             }
             else
             {
-                appendDouble( fXScale*fCos, aLine );
-                aLine.append( ' ' );
-                appendDouble( fSin*fXScale, aLine );
-                aLine.append( ' ' );
-                appendDouble( -fSin, aLine );
-                aLine.append( ' ' );
-                appendDouble( fCos, aLine );
-                aLine.append( ' ' );
-                m_aPages.back().appendPoint( aPos, aLine, false, &aCumulativePos );
+                Matrix3 aMat;
+                if( fSkew != 0.0 )
+                    aMat.skew( 0.0, fSkew );
+                aMat.scale( fXScale, 1.0 );
+                aMat.rotate( fAngle );
+                aMat.translate( aPos.X(), aPos.Y() );
+                aMat.append( m_aPages.back(), aLine, &aCumulativePos );
                 aLine.append( " Tm\r\n" );
                 aLastPos = aPos;
+                bFirst = false;
             }
             int nLast = 0;
             while( nLast < nGlyphs )
@@ -2979,10 +3124,10 @@ void PDFWriterImpl::drawLayout( SalLayou
         if( m_aCurrentPDFState.m_aFont.IsWordLineMode() )
         {
             Point aPos, aStartPt;
-            long nWidth = 0, nAdvance=0;
+            sal_Int32 nWidth = 0, nAdvance=0;
             for( int nStart = 0;;)
             {
-                long nGlyphIndex;
+                sal_Int32 nGlyphIndex;
                 if( !rLayout.GetNextGlyphs( 1, &nGlyphIndex, aPos, nStart, &nAdvance ) )
                     break;
 
@@ -3081,7 +3226,7 @@ void PDFWriterImpl::drawLayout( SalLayou
         for( int nStart = 0;;)
         {
             Point aPos;
-            long nGlyphIndex, nAdvance;
+            sal_Int32 nGlyphIndex, nAdvance;
             if( !rLayout.GetNextGlyphs( 1, &nGlyphIndex, aPos, nStart, &nAdvance ) )
                 break;
 
@@ -3089,8 +3234,7 @@ void PDFWriterImpl::drawLayout( SalLayou
             {
                 Point aAdjOffset = aOffset;
                 aAdjOffset.X() += (nAdvance - nEmphWidth) / 2;
-                aAdjOffset = Point( (int)(fXScale * fCos * (double)aAdjOffset.X() + fSin * (double)aAdjOffset.Y()),
-                                 -(int)(fXScale * fSin * (double)aAdjOffset.X() - fCos * (double)aAdjOffset.Y()) );
+                aAdjOffset = aRotScale.transform( aAdjOffset );
 
                 aAdjOffset -= Point( nEmphWidth2, nEmphHeight2 );
 
@@ -3113,7 +3257,7 @@ void PDFWriterImpl::drawEmphasisMark( lo
                                       const Rectangle& rRect1, const Rectangle& rRect2 )
 {
     // TODO: pass nWidth as width of this mark
-    long nWidth = 0;
+    // long nWidth = 0;
 
     if ( rPolyPoly.Count() )
     {
@@ -3163,7 +3307,7 @@ void PDFWriterImpl::drawText( const Poin
     }
 }
 
-void PDFWriterImpl::drawTextArray( const Point& rPos, const String& rText, const long* pDXArray, xub_StrLen nIndex, xub_StrLen nLen, bool bTextLines )
+void PDFWriterImpl::drawTextArray( const Point& rPos, const String& rText, const sal_Int32* pDXArray, xub_StrLen nIndex, xub_StrLen nLen, bool bTextLines )
 {
     MARK( "drawText with array" );
 
@@ -3219,7 +3363,6 @@ void PDFWriterImpl::drawText( const Rect
     Point       aPos            = rRect.TopLeft();
 
     long		nTextHeight		= m_pReferenceDevice->GetTextHeight();
-    TextAlign   eAlign			= m_aCurrentPDFState.m_aFont.GetAlign();
     xub_StrLen  nMnemonicPos    = STRING_NOTFOUND;
 
     String aStr = rOrigStr;
@@ -3346,7 +3489,7 @@ void PDFWriterImpl::drawLine( const Poin
 
     OStringBuffer aLine;
     m_aPages.back().appendPoint( rStart, aLine );
-    aLine.append( " m " );
+    aLine.append( "m " );
     m_aPages.back().appendPoint( rStop, aLine );
     aLine.append( " l S\r\n" );
 
@@ -3454,7 +3597,13 @@ void PDFWriterImpl::drawTextLine( const 
             setFont( aFont );
             updateGraphicsState();
         }
+
+        // strikeout string is left aligned non-CTL text
+        ULONG nOrigTLM = m_pReferenceDevice->GetLayoutMode();
+        m_pReferenceDevice->SetLayoutMode( TEXT_LAYOUT_BIDI_STRONG|TEXT_LAYOUT_COMPLEX_DISABLED );
         drawText( rPos, aStrikeout, 0, aStrikeout.Len(), false );
+        m_pReferenceDevice->SetLayoutMode( nOrigTLM );
+
         if( bShadow )
         {
             Font aFont = m_aCurrentPDFState.m_aFont;
@@ -3471,7 +3620,14 @@ void PDFWriterImpl::drawTextLine( const 
             case UNDERLINE_WAVE:
             case UNDERLINE_DOUBLEWAVE:
             case UNDERLINE_BOLDWAVE:
-                bNormalLines = false;
+            {
+                bNormalLines = FALSE;
+            }
+            break;
+            default:
+            {
+                ; // No gcc warning
+            }
         }
     }
 
@@ -3488,17 +3644,10 @@ void PDFWriterImpl::drawTextLine( const 
 
     // rotate and translate matrix
     double fAngle = (double)m_aCurrentPDFState.m_aFont.GetOrientation() * M_PI / 1800.0;
-    double fSin = sin( fAngle );
-    double fCos = cos( fAngle );
-    appendDouble( fCos, aLine );
-    aLine.append( ' ' );
-    appendDouble( fSin, aLine );
-    aLine.append( ' ' );
-    appendDouble( -fSin, aLine );
-    aLine.append( ' ' );
-    appendDouble( fCos, aLine );
-    aLine.append( ' ' );
-    m_aPages.back().appendPoint( aPos, aLine );
+    Matrix3 aMat;
+    aMat.rotate( fAngle );
+    aMat.translate( aPos.X(), aPos.Y() );
+    aMat.append( m_aPages.back(), aLine );
     aLine.append( " cm\r\n" );
 
     if ( aUnderlineColor.GetTransparency() != 0 )
@@ -3536,7 +3685,7 @@ void PDFWriterImpl::drawTextLine( const 
         if ( eUnderline == UNDERLINE_BOLDWAVE )
             nLineWidth = 3*nLineWidth/2;
 
-        m_aPages.back().appendMappedLength( nLineWidth, aLine );
+        m_aPages.back().appendMappedLength( (sal_Int32)nLineWidth, aLine );
         aLine.append( " w " );
 
         if ( eUnderline == UNDERLINE_DOUBLEWAVE )
@@ -3651,7 +3800,7 @@ void PDFWriterImpl::drawTextLine( const 
 
         if ( nLineHeight )
         {
-            m_aPages.back().appendMappedLength( nLineHeight, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, true );
             aLine.append( " w " );
             appendStrokingColor( aUnderlineColor, aLine );
             aLine.append( "\r\n" );
@@ -3660,7 +3809,7 @@ void PDFWriterImpl::drawTextLine( const 
                  (eUnderline == UNDERLINE_BOLDDOTTED) )
             {
                 aLine.append( "[ " );
-                m_aPages.back().appendMappedLength( nLineHeight, aLine, false );
+                m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, false );
                 aLine.append( " ] 0 d\r\n" );
             }
             else if ( (eUnderline == UNDERLINE_DASH) ||
@@ -3670,12 +3819,8 @@ void PDFWriterImpl::drawTextLine( const 
             {
                 sal_Int32 nDashLength = 4*nLineHeight;
                 sal_Int32 nVoidLength = 2*nLineHeight;
-                switch( eUnderline )
-                {
-                    case UNDERLINE_LONGDASH:
-                    case UNDERLINE_BOLDLONGDASH:
-                        nDashLength = 8*nLineHeight;
-                }
+                if ( ( eUnderline == UNDERLINE_LONGDASH ) || ( eUnderline == UNDERLINE_BOLDLONGDASH ) )
+                    nDashLength = 8*nLineHeight;
 
                 aLine.append( "[ " );
                 m_aPages.back().appendMappedLength( nDashLength, aLine, false );
@@ -3693,7 +3838,7 @@ void PDFWriterImpl::drawTextLine( const 
                 aLine.append( ' ' );
                 m_aPages.back().appendMappedLength( nVoidLength, aLine, false );
                 aLine.append( ' ' );
-                m_aPages.back().appendMappedLength( nLineHeight, aLine, false );
+                m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, false );
                 aLine.append( ' ' );
                 m_aPages.back().appendMappedLength( nVoidLength, aLine, false );
                 aLine.append( " ] 0 d\r\n" );
@@ -3709,31 +3854,31 @@ void PDFWriterImpl::drawTextLine( const 
                 aLine.append( ' ' );
                 m_aPages.back().appendMappedLength( nVoidLength, aLine, false );
                 aLine.append( ' ' );
-                m_aPages.back().appendMappedLength( nLineHeight, aLine, false );
+                m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, false );
                 aLine.append( ' ' );
                 m_aPages.back().appendMappedLength( nVoidLength, aLine, false );
                 aLine.append( ' ' );
-                m_aPages.back().appendMappedLength( nLineHeight, aLine, false );
+                m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, false );
                 aLine.append( ' ' );
                 m_aPages.back().appendMappedLength( nVoidLength, aLine, false );
                 aLine.append( " ] 0 d\r\n" );
             }
 
             aLine.append( "0 " );
-            m_aPages.back().appendMappedLength( -nLinePos, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos), aLine, true );
             aLine.append( " m " );
-            m_aPages.back().appendMappedLength( nWidth, aLine, false );
+            m_aPages.back().appendMappedLength( (sal_Int32)nWidth, aLine, false );
             aLine.append( ' ' );
-            m_aPages.back().appendMappedLength( -nLinePos, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos), aLine, true );
             aLine.append( " l S\r\n" );
             if ( eUnderline == UNDERLINE_DOUBLE )
             {
                 aLine.append( "0 " );
-                m_aPages.back().appendMappedLength( -nLinePos2-nLineHeight, aLine, true );
+                m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos2-nLineHeight), aLine, true );
                 aLine.append( " m " );
-                m_aPages.back().appendMappedLength( nWidth, aLine, false );
+                m_aPages.back().appendMappedLength( (sal_Int32)nWidth, aLine, false );
                 aLine.append( ' ' );
-                m_aPages.back().appendMappedLength( -nLinePos2-nLineHeight, aLine, true );
+                m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos2-nLineHeight), aLine, true );
                 aLine.append( " l S\r\n" );
             }
         }
@@ -3769,27 +3914,27 @@ void PDFWriterImpl::drawTextLine( const 
 
         if ( nLineHeight )
         {
-            m_aPages.back().appendMappedLength( nLineHeight, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)nLineHeight, aLine, true );
             aLine.append( " w " );
             appendStrokingColor( aStrikeoutColor, aLine );
             aLine.append( "\r\n" );
 
             aLine.append( "0 " );
-            m_aPages.back().appendMappedLength( -nLinePos, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos), aLine, true );
             aLine.append( " m " );
-            m_aPages.back().appendMappedLength( nWidth, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)nWidth, aLine, true );
             aLine.append( ' ' );
-            m_aPages.back().appendMappedLength( -nLinePos, aLine, true );
+            m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos), aLine, true );
             aLine.append( " l S\r\n" );
 
             if ( eStrikeout == STRIKEOUT_DOUBLE )
             {
                 aLine.append( "0 " );
-                m_aPages.back().appendMappedLength( -nLinePos2-nLineHeight, aLine, true );
+                m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos2-nLineHeight), aLine, true );
                 aLine.append( " m " );
-                m_aPages.back().appendMappedLength( nWidth, aLine, true );
+                m_aPages.back().appendMappedLength( (sal_Int32)nWidth, aLine, true );
                 aLine.append( ' ' );
-                m_aPages.back().appendMappedLength( -nLinePos2-nLineHeight, aLine, true );
+                m_aPages.back().appendMappedLength( (sal_Int32)(-nLinePos2-nLineHeight), aLine, true );
                 aLine.append( " l S\r\n" );
 
             }
@@ -4366,7 +4511,7 @@ bool PDFWriterImpl::writeGradientFunctio
                   "   /Length " );
     aLine.append( nStreamLengthObject );
     aLine.append( " 0 R\r\n"
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
                   "   /Filter /FlateDecode\r\n"
 #endif
                   ">>\r\n"
@@ -4587,7 +4732,7 @@ bool PDFWriterImpl::writeBitmapObject( B
                   "   /Length " );
     aLine.append( nStreamLengthObject );
     aLine.append( " 0 R\r\n" );
-#ifdef ENABLE_COMPRESSION
+#ifndef DEBUG_DISABLE_PDFCOMPRESSION
     aLine.append( "   /Filter /FlateDecode\r\n" );
 #endif
     if( ! bMask )
@@ -4768,9 +4913,9 @@ void PDFWriterImpl::drawJPGBitmap( SvStr
         delete pStream;
 
     aLine.append( "q " );
-    m_aPages.back().appendMappedLength( rTargetArea.GetWidth(), aLine, false );
+    m_aPages.back().appendMappedLength( (sal_Int32)rTargetArea.GetWidth(), aLine, false );
     aLine.append( " 0 0 " );
-    m_aPages.back().appendMappedLength( rTargetArea.GetHeight(), aLine, true );
+    m_aPages.back().appendMappedLength( (sal_Int32)rTargetArea.GetHeight(), aLine, true );
     aLine.append( ' ' );
     m_aPages.back().appendPoint( rTargetArea.BottomLeft(), aLine );
     aLine.append( " cm\r\n  /Im" );
@@ -4790,9 +4935,9 @@ void PDFWriterImpl::drawBitmap( const Po
         appendNonStrokingColor( rFillColor, aLine );
         aLine.append( ' ' );
     }
-    m_aPages.back().appendMappedLength( rDestSize.Width(), aLine, false );
+    m_aPages.back().appendMappedLength( (sal_Int32)rDestSize.Width(), aLine, false );
     aLine.append( " 0 0 " );
-    m_aPages.back().appendMappedLength( rDestSize.Height(), aLine, true );
+    m_aPages.back().appendMappedLength( (sal_Int32)rDestSize.Height(), aLine, true );
     aLine.append( ' ' );
     m_aPages.back().appendPoint( rDestPoint + Point( 0, rDestSize.Height()-1 ), aLine );
     aLine.append( " cm\r\n  /Im" );
@@ -4910,9 +5055,9 @@ void PDFWriterImpl::drawGradient( const 
     if( m_aGraphicsStack.front().m_aLineColor != Color( COL_TRANSPARENT ) )
         aLine.append( "q " );
     aLine.append( "0 0 " );
-    m_aPages.back().appendMappedLength( rRect.GetWidth(), aLine, false );
+    m_aPages.back().appendMappedLength( (sal_Int32)rRect.GetWidth(), aLine, false );
     aLine.append( ' ' );
-    m_aPages.back().appendMappedLength( rRect.GetHeight(), aLine, true );
+    m_aPages.back().appendMappedLength( (sal_Int32)rRect.GetHeight(), aLine, true );
     aLine.append( " re W n\r\n" );
 
     aLine.append( "/P" );
@@ -4921,9 +5066,9 @@ void PDFWriterImpl::drawGradient( const 
     if( m_aGraphicsStack.front().m_aLineColor != Color( COL_TRANSPARENT ) )
     {
         aLine.append( "Q 0 0 " );
-        m_aPages.back().appendMappedLength( rRect.GetWidth(), aLine, false );
+        m_aPages.back().appendMappedLength( (sal_Int32)rRect.GetWidth(), aLine, false );
         aLine.append( ' ' );
-        m_aPages.back().appendMappedLength( rRect.GetHeight(), aLine, true );
+        m_aPages.back().appendMappedLength( (sal_Int32)rRect.GetHeight(), aLine, true );
         aLine.append( " re S " );
     }
     aLine.append( "Q\r\n" );
@@ -4977,17 +5122,16 @@ void PDFWriterImpl::drawHatch( const Pol
     if( m_aGraphicsStack.front().m_aLineColor == Color( COL_TRANSPARENT ) &&
         m_aGraphicsStack.front().m_aFillColor == Color( COL_TRANSPARENT ) )
         return;
-
-    if( rPolyPoly.Count() )
-    {
-        PolyPolygon             aPolyPoly( rPolyPoly );
-        
-        aPolyPoly.Optimize( POLY_OPTIMIZE_NO_SAME );
-        push( PUSH_LINECOLOR );
-        setLineColor( rHatch.GetColor() );
-        getReferenceDevice()->ImplDrawHatch( aPolyPoly, rHatch, FALSE );
-        pop();
-    }
+	if( rPolyPoly.Count() )
+	{ 
+		PolyPolygon		aPolyPoly( rPolyPoly );
+
+		aPolyPoly.Optimize( POLY_OPTIMIZE_NO_SAME );
+		push( PUSH_LINECOLOR );
+		setLineColor( rHatch.GetColor() );
+		getReferenceDevice()->ImplDrawHatch( aPolyPoly, rHatch, FALSE );
+		pop();
+	}
 }
 
 void PDFWriterImpl::drawWallpaper( const Rectangle& rRect, const Wallpaper& rWall )
@@ -5056,6 +5200,7 @@ void PDFWriterImpl::drawWallpaper( const
                         aBmpPos.X() += aRect.GetWidth()-aBmpSize.Width();
                         aBmpPos.Y() += aRect.GetHeight()-aBmpSize.Height();
                         break;
+                    default: ;
                 }
             }
             else
Index: vcl/source/gdi/pdfwriter_impl.hxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/pdfwriter_impl.hxx,v
retrieving revision 1.25.82.2
retrieving revision 1.28
diff -u -p -u -r1.25.82.2 -r1.28
--- vcl/source/gdi/pdfwriter_impl.hxx	26 Jan 2004 17:22:37 -0000	1.25.82.2
+++ vcl/source/gdi/pdfwriter_impl.hxx	17 Jun 2004 12:19:44 -0000	1.28
@@ -339,7 +339,6 @@ private:
     sal_Int32						m_nCurrentPage;
 
     sal_Int32						m_nCatalogObject;
-    sal_Int32						m_nResourceDict;
 
     PDFWriter::PDFVersion			m_eVersion;
     PDFWriter::Compression          m_eCompression;
@@ -406,11 +405,13 @@ private:
     SvMemoryStream*						m_pMemStream;
 
     /* creates fonts and subsets that will be emitted later */
-    void registerGlyphs( int nGlyphs, long* pGlyphs, sal_Unicode* pUnicodes, sal_uInt8* pMappedGlyphs, sal_Int32* pMappedFontObjects, ImplFontData* pFallbackFonts[] );
+    void registerGlyphs( int nGlyphs, sal_Int32* pGlyphs, sal_Unicode* pUnicodes, sal_uInt8* pMappedGlyphs, sal_Int32* pMappedFontObjects, ImplFontData* pFallbackFonts[] );
 
     /*  emits a text object according to the passed layout */
     /* TODO: remove rText as soon as SalLayout will change so that rText is not necessary anymore */
     void drawLayout( SalLayout& rLayout, const String& rText, bool bTextLines );
+    void drawRelief( SalLayout& rLayout, const String& rText, bool bTextLines );
+    void drawShadow( SalLayout& rLayout, const String& rText, bool bTextLines );
 
     /*  writes differences between graphics stack and current real PDF
      *   state to the file
@@ -569,7 +570,7 @@ public:
 
     /* actual drawing functions */
     void drawText( const Point& rPos, const String& rText, xub_StrLen nIndex = 0, xub_StrLen nLen = STRING_LEN, bool bTextLines = true );
-    void drawTextArray( const Point& rPos, const String& rText, const long* pDXArray = NULL, xub_StrLen nIndex = 0, xub_StrLen nLen = STRING_LEN, bool bTextLines = true );
+    void drawTextArray( const Point& rPos, const String& rText, const sal_Int32* pDXArray = NULL, xub_StrLen nIndex = 0, xub_StrLen nLen = STRING_LEN, bool bTextLines = true );
     void drawStretchText( const Point& rPos, ULONG nWidth, const String& rText,
                           xub_StrLen nIndex = 0, xub_StrLen nLen = STRING_LEN,
                           bool bTextLines = true  );
Index: vcl/source/gdi/pngread.cxx
===================================================================
RCS file: vcl/source/gdi/pngread.cxx
diff -N vcl/source/gdi/pngread.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/source/gdi/pngread.cxx	28 Jun 2004 16:23:30 -0000	1.6
@@ -0,0 +1,1499 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include "pngread.hxx"
+
+#include <cmath>
+#include <rtl/crc.h>
+#include <rtl/memory.h>
+#include <rtl/alloc.h>
+#include <tools/zcodec.hxx>
+#include <tools/stream.hxx>
+#include "bmpacc.hxx"
+#include "svapp.hxx"
+#include "alpha.hxx"
+
+#ifndef _OSL_ENDIAN_H_
+#include <osl/endian.h>
+#endif
+
+// -----------
+// - Defines -
+// -----------
+
+#define PNGCHUNK_IHDR 		0x49484452
+#define PNGCHUNK_PLTE 		0x504c5445
+#define PNGCHUNK_IDAT 		0x49444154
+#define PNGCHUNK_IEND 		0x49454e44
+#define PNGCHUNK_bKGD 		0x624b4744
+#define PNGCHUNK_cHRM		0x6348524d
+#define PNGCHUNK_gAMA 		0x67414d41
+#define PNGCHUNK_hIST 		0x68495354
+#define PNGCHUNK_pHYs 		0x70485973
+#define PNGCHUNK_sBIT 		0x73425420
+#define PNGCHUNK_tIME		0x74494d45
+#define PNGCHUNK_tEXt		0x74455874
+#define PNGCHUNK_tRNS 		0x74524e53
+#define PNGCHUNK_zTXt 		0x7a545874
+#define PMGCHUNG_msOG		0x6d734f47		// Microsoft Office Animated GIF
+
+#define PNG_TRANS_VAL		0x1
+
+#define VIEWING_GAMMA		2.5
+#define DISPLAY_GAMMA		1.25
+
+namespace vcl
+{
+// -----------
+// - statics -
+// -----------
+
+static const BYTE aBlockHeight[ 8 ] = 
+{
+	0, 8, 8, 4, 4, 2, 2, 1 
+};
+
+// ------------------------------------------------------------------------------
+
+static const BYTE aBlockWidth[ 8 ]  = 
+{
+	0, 8, 4, 4, 2, 2, 1, 1 
+};
+
+// ------------------------------------------------------------------------------
+
+static const BYTE mpDefaultColorTable[ 256 ] =
+{	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
+	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
+	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
+	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
+	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
+	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
+	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
+	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
+	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
+	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
+	0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
+	0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
+	0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
+	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
+};
+
+/* ------------------------------------------------------------------------
+   SJ: InitChunkSeq reads all PNG chunks. The rStm stream position will be at
+   the end of the file afterwards.
+*/ 
+const sal_Bool InitChunkSeq( SvStream& rStm, std::vector< vcl::PNGReader::ChunkData >& rChunkSeq )
+{
+	sal_Bool	bRet = sal_True;
+	sal_uInt16	nIStmOldMode = rStm.GetNumberFormatInt();
+	rStm.SetNumberFormatInt( NUMBERFORMAT_INT_BIGENDIAN );
+
+	sal_uInt32 nDummy[ 2 ];
+	rStm >> nDummy[0] >> nDummy[1];
+	if( ! ( nDummy[0] == 0x89504e47 ) && ( nDummy[1] == 0x0d0a1a0a ) )
+		bRet = sal_False;
+	else
+	{
+		sal_uInt32 nChunkLen, nCRC32, nCheck, nType = 0;
+		while( !rStm.IsEof() && ( rStm.GetError() == ERRCODE_NONE ) )
+		{
+			rChunkSeq.resize( rChunkSeq.size() + 1 );
+			vcl::PNGReader::ChunkData& rChunkData = rChunkSeq.back();		
+			rStm >> nChunkLen
+				 >> nType;
+			
+			rChunkData.nType = nType;
+			#if defined(__LITTLEENDIAN) || defined(OSL_LITENDIAN)
+				nType = SWAPLONG( nType );
+			#endif
+			nCRC32 = rtl_crc32( 0, &nType, 4 );
+			if ( nChunkLen && !rStm.IsEof() )
+			{
+				rChunkData.aData.resize( nChunkLen );
+				sal_uInt8* pPtr = &rChunkData.aData[ 0 ];
+				rStm.Read( pPtr, nChunkLen );
+				nCRC32 = rtl_crc32( nCRC32, pPtr, nChunkLen );
+			}
+			rStm >> nCheck;
+			if ( nCRC32 != nCheck )
+			{
+				bRet = sal_False;
+				break;
+			}
+			if ( rChunkData.nType == PNGCHUNK_IEND )
+				break;
+		}
+		if ( !rChunkSeq.size() || ( rChunkSeq[ 0 ].nType != PNGCHUNK_IHDR ) )
+			bRet = sal_False;
+	}
+	rStm.SetNumberFormatInt( nIStmOldMode );
+	return bRet;
+}
+
+// -------------
+// - PNGReaderImpl -
+// -------------
+
+class PNGReaderImpl
+{
+	friend class vcl::PNGReader;
+
+	std::vector< vcl::PNGReader::ChunkData >	maChunkSeq;
+	std::vector< sal_uInt8 >::iterator			maDataIter;
+	std::vector< sal_uInt8 >::iterator			maDataEnd;
+	sal_Int32									mnChunkLen;
+
+	Bitmap*				mpBmp;
+	BitmapWriteAccess*	mpAcc;
+	Bitmap*				mpMaskBmp;
+	AlphaMask*			mpAlphaMask;
+	BitmapWriteAccess*	mpMaskAcc;
+	ZCodec* 			mpZCodec;
+	BYTE*				mpInflateInBuf; // as big as the size of a scanline + alphachannel + 1
+	BYTE*				mpScanprior;	// pointer to the latest scanline
+	BYTE*				mpTransTab;		//
+	BYTE*				mpScan;			// pointer in the current scanline
+	BYTE*				mpColorTable;	//
+	sal_uInt32			mnChunkType;	// Chunk which is currently open
+	sal_uInt32			mnWidth;
+	sal_uInt32			mnHeight;
+	sal_uInt32			mnBBP;			// number of bytes per pixel
+	sal_uInt32			mnScansize;		// max size of scanline
+	sal_uInt32			mnPrefWidth;	// preferred width in meter
+	sal_uInt32			mnPrefHeight;	// preferred Height in meter
+	sal_uInt32			mnYpos;			// latest y position;
+	USHORT				mnIStmOldMode;
+	USHORT				mnDepth;		// pixel depth
+	BYTE				mnTransRed;
+	BYTE				mnTransGreen;
+	BYTE				mnTransBlue;
+	BYTE				mnBitDepth;		// sample depth
+	BYTE				mnColorType;
+	BYTE				mnCompressionType;
+	BYTE				mnFilterType;
+	BYTE				mnInterlaceType;
+	BYTE				mnPass;			// if interlaced the latest pass ( 1..7 ) else 7
+	BYTE				cTransIndex1;
+	BYTE				cNonTransIndex1;
+	BOOL				mbStatus;
+	BOOL				mbTransparent;	// graphic includes an tRNS Chunk or an alpha Channel
+	BOOL				mbAlphaChannel;
+	BOOL				mbRGBTriple;
+	BOOL				mbPalette;		// FALSE if we need a Palette
+	BOOL				mbGrayScale;
+	BOOL				mbzCodecInUse;
+	BOOL				mbIDAT;			// TRUE if finished with the complete IDAT...
+	BOOL				mbGamma;		// TRUE if Gamma Correction available
+	BOOL				mbpHYs;			// TRUE if pysical size of pixel available
+
+	void				ImplSetPixel( sal_uInt32 y, sal_uInt32 x, const BitmapColor &, BOOL bTrans );
+	void				ImplSetPixel( sal_uInt32 y, sal_uInt32 x, BYTE nPalIndex, BOOL bTrans );
+	void				ImplSetAlphaPixel( sal_uInt32 y, sal_uInt32 x, const BitmapColor&, BYTE nAlpha );
+	void				ImplReadIDAT();
+	void				ImplResizeScanline();
+	void				ImplGetFilter( sal_uInt32 nXStart=0, sal_uInt32 nXAdd=1 );
+	void				ImplReadTransparent();
+	void				ImplGetGamma();
+	void				ImplGetBackground();
+	BYTE				ImplScaleColor();
+	BOOL				ImplReadHeader();
+	BOOL				ImplReadPalette();
+	void				ImplGetGrayPalette( sal_uInt32 );
+	sal_uInt32			ImplReadsal_uInt32();
+
+public:
+
+									PNGReaderImpl( SvStream& rStm );
+									~PNGReaderImpl();
+
+	BitmapEx						Read();	
+};
+
+// ------------------------------------------------------------------------------
+
+PNGReaderImpl::PNGReaderImpl( SvStream& rPNG ) :
+	mpAcc			( NULL ),
+	mpMaskAcc		( NULL ),
+	mpInflateInBuf	( NULL ),
+	mpScanprior 	( NULL ),
+	mpTransTab		( NULL ),
+	mpBmp			( NULL ),
+	mpMaskBmp		( NULL ),
+	mpAlphaMask		( NULL ),
+	mbGamma			( sal_False ),
+	mbzCodecInUse	( sal_False ),
+	mbpHYs			( sal_False ),
+	mpColorTable	( (sal_uInt8*) mpDefaultColorTable ),
+	mpZCodec		( new ZCodec( DEFAULT_IN_BUFSIZE, DEFAULT_OUT_BUFSIZE, MAX_MEM_USAGE ) )
+{
+	mbStatus = InitChunkSeq( rPNG, maChunkSeq );
+}
+
+// ------------------------------------------------------------------------
+
+PNGReaderImpl::~PNGReaderImpl()
+{
+	if ( mbzCodecInUse )
+		mpZCodec->EndCompression();
+
+	if( mpColorTable != mpDefaultColorTable )
+		delete[] mpColorTable;
+
+	rtl_freeMemory( mpScanprior );
+
+	delete mpBmp;
+	delete mpAlphaMask;
+	delete mpMaskBmp;
+	delete[] mpTransTab;
+	delete[] mpInflateInBuf;
+	delete mpZCodec;
+}
+
+// ------------------------------------------------------------------------
+
+BitmapEx PNGReaderImpl::Read()
+{
+	BitmapEx	aRet;
+
+	std::vector< vcl::PNGReader::ChunkData >::iterator aIter( maChunkSeq.begin() );
+	std::vector< vcl::PNGReader::ChunkData >::iterator aEnd ( maChunkSeq.end() );
+
+	while( mbStatus && ( aIter != aEnd ) && ( aIter->nType != PNGCHUNK_IEND ) )
+	{
+		maDataIter = aIter->aData.begin();
+		maDataEnd  = aIter->aData.end();
+		mnChunkLen = aIter->aData.size();
+
+		switch ( aIter->nType )
+		{
+			case PNGCHUNK_IHDR :
+			{
+				mbStatus = ImplReadHeader();
+			}
+			break;
+
+			case PNGCHUNK_gAMA :								// the gamma chunk must precede
+			{
+				if ( mbIDAT == FALSE )							// the 'IDAT' and also the
+					ImplGetGamma(); 							// 'PLTE'(if available )
+			}
+			break;
+
+			case PNGCHUNK_PLTE :
+			{
+				if ( !mbPalette )
+					mbStatus = ImplReadPalette();
+			}
+			break;
+
+			case PNGCHUNK_tRNS :
+				ImplReadTransparent();
+			break;
+
+			case PNGCHUNK_bKGD :								// the background chunk must appear
+			{
+				if ( ( mbIDAT == FALSE ) && mbPalette ) 		// before the 'IDAT' and after the
+					ImplGetBackground();						// PLTE(if available ) chunk.
+			}
+			break;
+
+			case PNGCHUNK_IDAT :
+			{
+				if ( !mbIDAT )		// the gfx is finished, but there may be left a zlibCRC of about 4Bytes
+					ImplReadIDAT();
+			}
+			break;
+
+			case PNGCHUNK_pHYs :
+			{
+				if ( !mbIDAT && mnChunkLen == 9 )
+				{
+					mnPrefWidth = ImplReadsal_uInt32();
+					mnPrefHeight= ImplReadsal_uInt32();
+
+					sal_uInt8 nUnitSpecifier = *maDataIter++;
+
+					if ( nUnitSpecifier == 1 )
+						mbpHYs = sal_True;
+				}
+			}
+			break;
+		}
+		aIter++;
+	}
+	if ( mpAcc )
+		mpBmp->ReleaseAccess( mpAcc ), mpAcc = NULL;
+
+	if ( mpMaskAcc )
+	{
+		if ( mbAlphaChannel )
+			mpAlphaMask->ReleaseAccess( mpMaskAcc );
+		else
+			mpMaskBmp->ReleaseAccess( mpMaskAcc );
+
+		mpMaskAcc = NULL;
+	}
+	
+	if ( mbStatus )
+	{
+		if ( mbAlphaChannel )
+			aRet = BitmapEx( *mpBmp, *mpAlphaMask );
+		else if ( mbTransparent )
+			aRet = BitmapEx( *mpBmp, *mpMaskBmp );
+		else
+			aRet = *mpBmp;
+
+		if ( mbpHYs && mnPrefWidth && mnPrefHeight )
+		{
+			sal_Int32 nPrefSizeX = (sal_Int32)( 100000.0 * ( (double)mnWidth / mnPrefWidth ) );
+			sal_Int32 nPrefSizeY = (sal_Int32)( 100000.0 * ( (double)mnHeight / mnPrefHeight ) );
+			
+			aRet.SetPrefMapMode( MAP_100TH_MM );
+			aRet.SetPrefSize( Size( nPrefSizeX, nPrefSizeY ) );
+		}
+	}
+	if( !mbStatus )
+		aRet.Clear();
+
+	return aRet;
+}
+
+// ------------------------------------------------------------------------
+
+BOOL PNGReaderImpl::ImplReadHeader()
+{
+	mnWidth = ImplReadsal_uInt32();
+	mnHeight = ImplReadsal_uInt32();
+	
+	if ( ( mnWidth == 0 ) || ( mnHeight == 0 ) )
+		return FALSE;
+	
+	mnBitDepth = *maDataIter++;
+	mnColorType = *maDataIter++;
+	
+	if ( mnCompressionType = *maDataIter++ )
+		return FALSE;
+	
+	if ( mnFilterType = *maDataIter++ )
+		return FALSE;
+	
+	switch ( mnInterlaceType = *maDataIter++ )	// filter type valid ?
+	{
+		case 0 :
+			mnPass = 7;
+			break;
+		case 1 :
+			mnPass = 0;
+			break;
+		default:
+			return FALSE;
+	}
+	mnYpos = 0;
+	mbPalette = TRUE;
+	mbIDAT = mbAlphaChannel = mbTransparent = FALSE;
+	mbGrayScale = mbRGBTriple = FALSE;
+	mnDepth = mnBitDepth;
+	mnScansize = ( ( mnWidth * mnBitDepth ) + 7 ) >> 3;
+
+	// valid color types are 0,2,3,4 & 6
+	switch ( mnColorType )
+	{
+		case 0 :	// each pixel is a grayscale
+		{
+			switch ( mnBitDepth )
+			{
+				case 2 :
+					mnDepth = 8;	// we have to expand the bitmap
+				case 16 :
+					mnDepth >>= 1;	// we have to reduce the bitmap
+				case 1 :
+				case 4 :
+				case 8 :
+					mbGrayScale = TRUE;
+					break;
+				default :
+					return FALSE;
+			}
+		}
+		break;
+
+		case 2 :	// each pixel is an RGB triple
+		{
+			mbRGBTriple = TRUE;
+			mnScansize*=3;
+			switch ( mnBitDepth )
+			{
+				case 16 :			// we have to reduce the bitmap
+				case 8 :
+					mnDepth = 24;
+					break;
+				default :
+					return FALSE;
+			}
+		}
+		break;
+
+		case 3 :	// each pixel is a palette index
+		{
+			switch ( mnBitDepth )
+			{
+				case 2 :
+					mnDepth = 4;	// we have to expand the bitmap
+				case 1 :
+				case 4 :
+				case 8 :
+					mbPalette = FALSE;
+					break;
+				default :
+					return FALSE;
+			}
+		}
+		break;
+
+		case 4 :	// each pixel is a grayscale sample followed by an alpha sample
+		{
+			mnScansize <<= 1;
+			mbAlphaChannel = TRUE;
+			switch ( mnBitDepth )
+			{
+				case 16 :
+					mnDepth >>= 1;	// we have to reduce the bitmap
+				case 8 :
+					mbGrayScale = TRUE;
+					break;
+				default :
+					return FALSE;
+			}
+		}
+		break;
+
+		case 6 :	// each pixel is an RGB triple followed by an alpha sample
+		{
+			mbRGBTriple = TRUE;
+			mnScansize*=4;
+			mbAlphaChannel = TRUE;
+			switch (mnBitDepth )
+			{
+				case 16 :			// we have to reduce the bitmap
+				case 8 :
+					mnDepth = 24;
+					break;
+				default :
+					return FALSE;
+			}
+		}
+		break;
+
+		default :
+			return FALSE;
+	}
+	mnBBP = mnScansize / mnWidth;
+	
+	if ( !mnBBP )
+		mnBBP = 1;
+
+	mnScansize++;		// each scanline includes one filterbyte
+	mpScan = mpInflateInBuf = new BYTE[ mnScansize ];
+	mpScanprior = (sal_uInt8*)rtl_allocateZeroMemory( mnScansize );
+
+	if ( mnInterlaceType )
+		ImplResizeScanline();
+
+	mpBmp = new Bitmap( Size( mnWidth, mnHeight ), mnDepth);
+	mpAcc = mpBmp->AcquireWriteAccess();
+
+	if ( mbAlphaChannel )
+	{
+		mpAlphaMask = new AlphaMask( Size( mnWidth, mnHeight ) );
+		mpAlphaMask->Erase( 128 );
+		mpMaskAcc = mpAlphaMask->AcquireWriteAccess();
+	}
+	else
+	{
+		mpMaskBmp = new Bitmap( Size( mnWidth, mnHeight ), 1 );
+		mpMaskBmp->Erase( Color( COL_WHITE ) );
+		mpMaskAcc = mpMaskBmp->AcquireWriteAccess();
+	}
+
+	if ( ( mpAcc == NULL ) || ( mpMaskAcc == NULL ) )
+		return FALSE;
+
+	const Color aWhite( COL_WHITE );
+	cTransIndex1 = (BYTE)mpMaskAcc->GetBestPaletteIndex( aWhite );
+	cNonTransIndex1 = cTransIndex1 ? 0 : 1;
+
+	if ( mbGrayScale )
+		ImplGetGrayPalette( mnDepth );
+
+	return TRUE;
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplGetGrayPalette( sal_uInt32 nDepth )
+{
+	sal_uInt32 nAdd, nStart = 0;
+
+	mpAcc->SetPaletteEntryCount( 1 << nDepth );
+
+	switch ( nDepth )
+	{
+		case 1 : nAdd = 255; break;
+		case 2 : nAdd = 85; break;
+		case 4 : nAdd = 17; break;
+		case 8 : nAdd = 1; break;
+	}
+
+	for ( sal_uInt32 i = 0; nStart < 256; i++, nStart += nAdd )
+		mpAcc->SetPaletteColor( (USHORT)i, BitmapColor( mpColorTable[ nStart ],
+			mpColorTable[ nStart ], mpColorTable[ nStart ] ) );
+}
+
+// ------------------------------------------------------------------------
+
+BOOL PNGReaderImpl::ImplReadPalette()
+{
+	sal_uInt32 nCount = mnChunkLen / 3;
+
+	if ( ( ( mnChunkLen % 3 ) == 0 ) && ( ( 0 < nCount ) && ( nCount <= 256 ) ) && mpAcc )
+	{
+		BYTE 	nRed, nGreen, nBlue;
+
+		mbPalette = TRUE;
+		mpAcc->SetPaletteEntryCount( (USHORT) nCount );
+
+		for ( USHORT i = 0; i < nCount; i++ )
+		{
+			nRed =   mpColorTable[ *maDataIter++ ];
+			nGreen = mpColorTable[ *maDataIter++ ];
+			nBlue =  mpColorTable[ *maDataIter++ ];
+			mpAcc->SetPaletteColor( i, Color( nRed, nGreen, nBlue ) );
+		}
+	}
+	else
+		mbStatus = FALSE;
+
+	return mbStatus;
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplReadTransparent()
+{
+	if ( mpTransTab == NULL )
+	{
+		switch ( mnColorType )
+		{
+			case 0 :
+			{
+				if ( mnChunkLen == 2 )
+				{
+					mpTransTab = new sal_uInt8[ 256 ];
+					rtl_fillMemory( mpTransTab, 256, 0xff );
+                    // color type 0 and 4 is always greyscale,
+                    // so the return value can be used as index
+                	sal_uInt8 nIndex = ImplScaleColor();
+					mpTransTab[ nIndex ] = 0;
+					mbTransparent = sal_True;
+				}
+			}
+			break;
+
+			case 2 :
+			{
+				if ( mnChunkLen == 6 )
+				{
+					mnTransRed = ImplScaleColor();
+					mnTransGreen = ImplScaleColor();
+					mnTransBlue = ImplScaleColor();
+				}
+			}
+			break;
+
+			case 3 :
+			{
+				if ( mnChunkLen <= 256 )
+				{
+					mpTransTab = new BYTE [ 256 ];
+					rtl_fillMemory( mpTransTab, 256, 0xff );
+					rtl_copyMemory( mpTransTab, maDataIter, mnChunkLen );
+					maDataIter += mnChunkLen;
+					mbTransparent = TRUE;
+				}
+			}
+			break;
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplGetGamma()
+{
+	sal_uInt32	nGammaValue = ImplReadsal_uInt32();
+	double		fGamma = ( ( VIEWING_GAMMA / DISPLAY_GAMMA ) * ( (double)nGammaValue / 100000 ) );
+	double 		fInvGamma = ( fGamma <= 0.0 || fGamma > 10.0 ) ? 1.0 : ( 1.0 / fGamma );
+
+	if ( fInvGamma != 1.0 )
+	{
+		mbGamma = TRUE;
+		
+		if ( mpColorTable == mpDefaultColorTable )
+			mpColorTable = new sal_uInt8[ 256 ];
+		
+		for ( sal_Int32 i = 0; i < 256; i++ )
+			mpColorTable[ i ] = (sal_uInt8)(pow((double)i/255.0, fInvGamma) * 255.0 + 0.5);
+
+		if ( mbGrayScale )
+			ImplGetGrayPalette( mnDepth );
+	}
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplGetBackground()
+{
+	Point 		aPoint;
+	Rectangle	aRectangle( aPoint, Size( mnWidth, mnHeight ) );
+
+	switch ( mnColorType )
+	{
+		case 3 :
+		{
+			if ( mnChunkLen == 1 )
+			{
+				UINT16 nCol = *maDataIter++;
+				if ( nCol < mpAcc->GetPaletteEntryCount() )
+				{
+					mpAcc->SetFillColor( (const Color&)mpAcc->GetPaletteColor( (BYTE)nCol ) );
+					mpAcc->FillRect( aRectangle );
+					break;
+				}
+			}			
+		}
+		break;
+
+		case 0 :
+		case 4 :
+		{
+			if ( mnChunkLen == 2 )
+			{
+                // the color type 0 and 4 is always greyscale,
+                // so the return value can be used as index
+				sal_uInt8 nIndex = ImplScaleColor();
+				mpAcc->SetFillColor( (const Color&)mpAcc->GetPaletteColor( nIndex ) );
+				mpAcc->FillRect( aRectangle );
+			}
+		}
+		break;
+	
+		case 2 :
+		case 6 :
+		{
+			if ( mnChunkLen == 6 )
+			{
+				sal_uInt8 nRed = ImplScaleColor();
+				sal_uInt8 nGreen = ImplScaleColor();
+				sal_uInt8 nBlue = ImplScaleColor();
+				mpAcc->SetFillColor( Color( nRed, nGreen, nBlue ) );
+				mpAcc->FillRect( aRectangle );
+			}
+		}
+		break;
+	}
+}
+
+// ------------------------------------------------------------------------
+
+// for color type 0 and 4 (greyscale) the return value is always index to the color
+//                2 and 6 (RGB)       the return value is always the 8 bit color component
+sal_uInt8 PNGReaderImpl::ImplScaleColor()
+{
+    sal_uInt32 nMask = ( ( 1 << mnBitDepth ) - 1 );
+	sal_uInt16 nCol = ( *maDataIter++ << 8 );
+	
+	nCol += *maDataIter++ & (sal_uInt16)nMask;
+	
+	if ( mnBitDepth > 8 )	// convert 16bit graphics to 8
+		nCol >>= 8;
+	
+	return (sal_uInt8) nCol;
+}
+
+// ------------------------------------------------------------------------
+// ImplReadIDAT reads as much bitmap data as possible
+
+void PNGReaderImpl::ImplReadIDAT()
+{
+	sal_uInt32 nToRead, nRead;
+	if ( mnChunkLen )		// Chunk empty ?
+	{
+		if ( mbzCodecInUse == FALSE )
+		{
+			mbzCodecInUse = TRUE;
+			mpZCodec->BeginCompression( ZCODEC_PNG_DEFAULT );
+		}
+		mpZCodec->SetBreak( mnChunkLen );
+		SvMemoryStream aIStrm( maDataIter, mnChunkLen, STREAM_READ );
+
+		while ( ( mpZCodec->GetBreak() ) )
+		{
+			// get bytes needed to fill the current scanline
+			nToRead = mnScansize - ( mpScan - mpInflateInBuf );
+
+			if ( ( nRead = mpZCodec->ReadAsynchron( aIStrm, mpScan, nToRead ) ) < 0 )
+			{
+				mbStatus = FALSE;
+				break;
+			}
+			if ( nRead < nToRead )
+			{
+				mpScan += nRead;			// ZStream is Broken
+				break;
+			}
+			else
+			{
+				mpScan = mpInflateInBuf;	// this scanline is Finished
+
+				if ( mnInterlaceType == 0	)
+				{
+					ImplGetFilter ( 0, 1 );
+					mnYpos++;
+				}
+				else
+				{
+					// interlace mode
+					switch ( mnPass )
+					{
+						case 1 :																			// pass 1
+						{
+							ImplGetFilter ( 0, 8 );
+							mnYpos += 8;
+						}
+						break;
+
+						case 2 :																			// pass 2
+						{
+							ImplGetFilter ( 4, 8 );
+							mnYpos += 8;
+						}
+						break;
+
+						case 3 :																			// pass 3
+						{
+							if ( mnYpos >= 4 )
+							{
+								ImplGetFilter ( 0, 4 );
+							}
+							mnYpos += 8;
+						}
+						break;
+
+						case 4 :																			// pass 4
+						{
+							ImplGetFilter ( 2, 4 );
+							mnYpos += 4;
+						}
+						break;
+
+						case 5 :																			// pass 5
+						{
+							if ( mnYpos >= 2 )
+							{
+								ImplGetFilter ( 0, 2 );
+							}
+							mnYpos += 4;
+						}
+						break;
+
+						case 6 :																			// pass 6
+						{
+								ImplGetFilter ( 1, 2 );
+								mnYpos += 2;
+						}
+						break;
+
+						case 7 :																			// pass 7
+						{
+							if ( mnYpos >= 1 )
+							{
+								ImplGetFilter ( 0, 1 );
+							}
+							mnYpos += 2;
+						}
+						break;
+					}
+				}
+			}
+
+			if ( mnYpos >= mnHeight )
+			{
+				if ( mnPass == 7 )
+					break;
+				else
+				{
+					ImplResizeScanline();
+				}
+			}
+		}
+	}
+
+	if ( ( mnPass >= 7 ) && ( mnYpos >= mnHeight ) )
+	{
+		mpZCodec->EndCompression();
+		mbzCodecInUse = FALSE;
+		mbIDAT = TRUE;
+	}
+}
+
+// ---------------------------------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplResizeScanline( void )
+{
+	long nScansize;
+
+	while ( mnPass < 7 )
+	{
+		sal_uInt32 nX = 0;
+
+		mnYpos = 0;
+		mnPass++;
+
+		switch ( mnPass )
+		{
+			case 1 :
+				nScansize = ( mnWidth + 7 ) >> 3;
+			break;
+
+			case 2 :
+				nX += 4;
+				nScansize = ( mnWidth + 3 ) >> 3;
+			break;
+
+			case 3 :
+				mnYpos += 4;
+				nScansize = ( mnWidth + 3 ) >> 2;
+			break;
+
+			case 4 :
+				nX += 2;
+				nScansize = ( mnWidth + 1) >> 2;
+			break;
+
+			case 5 :
+				mnYpos += 2;
+				nScansize = ( mnWidth + 1 ) >> 1;
+			break;
+
+			case 6 :
+				nX++;
+				nScansize = mnWidth >> 1;
+			break;
+
+			case 7 :
+				mnYpos++;
+				nScansize = mnWidth;
+			break;
+		}
+
+		if ( ( mnYpos >= mnHeight ) || ( nX >= mnWidth ) )	// is pass to be skipped ?
+			continue;
+
+		// in Interlace mode the size of scanline is not constant
+		// so first we calculate the number of entrys
+		mnScansize = nScansize * mnBitDepth;
+
+		if ( mbRGBTriple )
+			mnScansize *= 3;
+
+		// convert bitsize to byte
+		mnScansize = ( mnScansize + 7 ) >> 3;
+
+		if ( mbAlphaChannel )
+			mnScansize += ( ( nScansize * mnBitDepth ) >> 3 );
+
+		rtl_zeroMemory( mpScanprior, ++mnScansize );
+		break;
+	}
+}
+
+// ---------------------------------------------------------------------------------------------------
+// ImplGetFilter writes the complete Scanline (nY) - in interlace mode the parameter nXStart and nXAdd
+// appends to the currently used pass
+// the complete size of scanline will be returned - in interlace mode zero is possible!
+
+void PNGReaderImpl::ImplGetFilter ( sal_uInt32 nXStart, sal_uInt32 nXAdd )
+{
+	BYTE* 		pTmp = mpInflateInBuf;
+	BYTE* 		p1;
+	BYTE* 		p2;
+	BYTE* 		p3;
+	BYTE* 		p4;
+	BYTE  		nFilterType, nCol;
+	sal_uInt32	nXIndex, nX, nY = mnYpos, n1, n2, na, nb, nc;
+	sal_Int32	np, npa, npb, npc;
+
+	sal_uInt32 nBBP = mnBBP;
+
+	if ( nXStart < (sal_uInt32)mnWidth )
+	{
+		nFilterType = *pTmp++;	// the filter type may change each scanline
+
+		switch ( nFilterType )
+		{
+			case 1 :
+			{
+				p1 = pTmp + nBBP;
+				p2 = pTmp;
+		
+				while ( p1 < pTmp + mnScansize - 1 )
+					( *p1++ ) += ( *p2++ );
+			}
+			break;
+
+			case 2 :
+			{
+				p1 = pTmp;
+				p2 = mpScanprior+1;
+
+				while ( p1 < pTmp + mnScansize - 1 )
+					( *p1++ ) += ( *p2++ );
+			}
+			break;
+
+			case 3 :
+			{
+				p1 = pTmp;
+				p2 = mpScanprior + 1;
+				p3 = pTmp-nBBP;
+
+				while ( p1 < pTmp + mnScansize - 1 )
+				{
+					n1 = (BYTE)( *p2++ );
+					n2 = ( p3 >= pTmp ) ? (BYTE)*p3 : 0;
+					p3++;
+					( *p1++ ) += (BYTE)( ( n1 + n2 ) >> 1 );
+				}
+			}
+			break;
+
+			case 4 :
+			{
+				p1 = pTmp;
+				p2 = p1 - nBBP;
+				p3 = mpScanprior + 1;
+				p4 = p3 - nBBP;
+
+				while ( p1 < pTmp + mnScansize - 1 )
+				{
+					nb = *p3++;
+					if ( p2 >= pTmp )
+					{
+						na = *p2;
+						nc = *p4;
+					}
+					else
+						na = nc = 0;
+
+					np = na + nb;
+					np -= nc;
+					npa = np - na;
+					npb = np - nb;
+					npc = np - nc;
+					
+					if ( npa < 0 )
+						npa =-npa;
+					if ( npb < 0 )
+						npb =-npb;
+					if ( npc < 0 )
+						npc =-npc;
+
+					if ( ( npa <= npb ) && ( npa <= npc ) ) 
+						*p1++ += (BYTE)na;
+					else if ( npb <= npc )
+						*p1++ += (BYTE)nb;
+					else
+						*p1++ += (BYTE)nc;
+
+					p2++;
+					p4++;
+				}
+			}
+			break;
+			// undefined FilterType -> we will let them pass and display the data unfiltered
+		}
+		if ( mpAcc->HasPalette() )	// alphachannel is not allowed by pictures including palette entries
+		{
+			switch ( mpAcc->GetBitCount() )
+			{
+				case 1 :
+				{
+					if ( mbTransparent )
+					{
+						for ( nX = nXStart, nXIndex = 0; nX < (sal_uInt32)mnWidth; nX += nXAdd, nXIndex++ )
+						{
+							sal_uInt32 nShift = ( nXIndex & 7 ) ^ 7;
+					
+							if ( nShift == 0 )
+								nCol = ( *pTmp++ ) & 1;
+							else
+								nCol = ( *pTmp >> nShift ) & 1;
+	
+							ImplSetPixel( nY, nX, nCol, mpTransTab[ nCol ] < PNG_TRANS_VAL );
+						}
+					}
+					else
+					{
+						for ( nX = nXStart, nXIndex = 0; nX < (sal_uInt32)mnWidth; nX += nXAdd, nXIndex++ )
+						{
+							sal_uInt32 nShift = ( nXIndex & 7 ) ^ 7;
+
+							if ( nShift == 0 )
+								ImplSetPixel( nY, nX, ( *pTmp++ & 1 ), FALSE );
+							else
+								ImplSetPixel( nY, nX, ( *pTmp >> nShift ) & 1, FALSE );
+						}
+					}
+				}
+				break;
+
+				case 4 :
+				{
+					if ( mbTransparent )
+					{
+						if ( mnBitDepth == 4 )	// maybe the source is a two bitmap graphic
+						{
+							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
+							{
+								if( nXIndex & 1 )
+								{
+									ImplSetPixel( nY, nX, *pTmp & 0x0f, mpTransTab[ *pTmp & 0x0f ] < PNG_TRANS_VAL );
+									pTmp++;
+								}
+								else
+								{
+									ImplSetPixel( nY, nX, ( *pTmp >> 4 ) & 0x0f, mpTransTab[ *pTmp >> 4 ] < PNG_TRANS_VAL );
+								}
+							}
+						}
+						else
+						{
+							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
+							{
+								switch( nXIndex & 3 )
+								{
+									case 0 :
+										nCol = *pTmp >> 6;
+									break;
+
+									case 1 :
+										nCol = ( *pTmp >> 4 ) & 0x03 ;
+									break;
+
+									case 2 :
+										nCol = ( *pTmp >> 2 ) & 0x03;
+									break;
+
+									case 3 :
+										nCol = ( *pTmp++ ) & 0x03;
+									break;
+								}
+
+								ImplSetPixel( nY, nX, nCol, mpTransTab[ nCol ] < PNG_TRANS_VAL );
+							}
+						}
+					}
+					else
+					{
+						if ( mnBitDepth == 4 )	// maybe the source is a two bitmap graphic
+						{
+							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
+							{
+								if( nXIndex & 1 )
+									ImplSetPixel( nY, nX, *pTmp++ & 0x0f, FALSE );
+								else
+									ImplSetPixel( nY, nX, ( *pTmp >> 4 ) & 0x0f, FALSE );
+							}
+						}
+						else
+						{
+							for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX += nXAdd, nXIndex++ )
+							{
+								switch( nXIndex & 3 )
+								{
+									case 0 :
+										ImplSetPixel( nY, nX, *pTmp >> 6, FALSE );
+									break;
+
+									case 1 :
+										ImplSetPixel( nY, nX, ( *pTmp >> 4 ) & 0x03, FALSE );
+									break;
+
+									case 2 :
+										ImplSetPixel( nY, nX, ( *pTmp >> 2 ) & 0x03, FALSE );
+									break;
+
+									case 3 :
+										ImplSetPixel( nY, nX, *pTmp++ & 0x03, FALSE );
+									break;
+								}
+							}
+						}
+					}
+				}
+				break;
+
+				case 8 :
+				{
+					if ( mbAlphaChannel )
+					{
+						if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
+						{
+							for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 2 )
+								ImplSetAlphaPixel( nY, nX, pTmp[ 0 ], pTmp[ 1 ] );
+						}
+						else
+						{
+							for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 4 )
+								ImplSetAlphaPixel( nY, nX, pTmp[ 0 ], pTmp[ 2 ] );
+						}
+					}
+					else
+					{
+						if ( mbTransparent )
+						{
+							if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
+							{
+								for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp++ )
+									ImplSetPixel( nY, nX, *pTmp, mpTransTab[ *pTmp ] < PNG_TRANS_VAL );
+							}
+							else
+							{
+								for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 2 )
+									ImplSetPixel( nY, nX, *pTmp, mpTransTab[ *pTmp ] < PNG_TRANS_VAL );
+							}
+						}
+						else
+						{
+							if ( mnBitDepth == 8 )	// maybe the source is a 16 bit grayscale
+							{
+								for ( nX = nXStart; nX < mnWidth; nX += nXAdd )
+									ImplSetPixel( nY, nX, *pTmp++, FALSE );
+							}
+							else
+							{
+								for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 2 )
+									ImplSetPixel( nY, nX, *pTmp, FALSE );
+							}
+						}
+					}
+				}
+				break;
+
+				default :
+					mbStatus = FALSE;
+				break;
+			}
+		}
+		else
+		{
+			if ( mbAlphaChannel || mbTransparent )
+			{
+				if ( mbAlphaChannel )
+				{
+					if ( mnBitDepth == 8 )	// maybe the source is a 16 bit each sample
+					{
+						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 4 )
+							ImplSetAlphaPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+																		mpColorTable[ pTmp[ 1 ] ],
+																			mpColorTable[ pTmp[ 2 ] ] ), pTmp[ 3 ] );
+					}
+					else
+					{
+						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 8 )
+							ImplSetAlphaPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+																		mpColorTable[ pTmp[ 2 ] ],
+																			mpColorTable[ pTmp[ 4 ] ] ), pTmp[6] );
+					}
+				}
+				else // Transparency chunk
+				{
+					sal_Bool	bTransparent;
+					sal_uInt8	nRed, nGreen, nBlue;
+
+					if ( mnBitDepth == 8 )	// maybe the source is a 16 bit each sample
+					{
+						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 3 )
+						{
+							nRed = pTmp[ 0 ];
+							nGreen = pTmp[ 1 ];
+							nBlue = pTmp[ 2 ];
+							bTransparent = ( ( nRed == mnTransRed )
+											&& ( nGreen == mnTransGreen )
+												&& ( nBlue == mnTransBlue ) );
+
+							ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ nRed ],
+																mpColorTable[ nGreen ],
+																	mpColorTable[ nBlue ] ), bTransparent );
+						}
+					}
+					else
+					{
+						for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 6 )
+						{
+							nRed = pTmp[ 0 ];
+							nGreen = pTmp[ 2 ];
+							nBlue = pTmp[ 4 ];
+							bTransparent = ( ( nRed == mnTransRed )
+											&& ( nGreen == mnTransGreen )
+												&& ( nBlue == mnTransBlue ) );
+
+							ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ nRed ],
+																mpColorTable[ nGreen ],
+																	mpColorTable[ nBlue ] ), bTransparent );
+						}
+					}
+				}
+			}
+			else
+			{
+				if ( mnBitDepth == 8 )	// maybe the source is a 16 bit each sample
+				{
+					for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 3 )
+						ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+															mpColorTable[ pTmp[ 1 ] ],
+																mpColorTable[ pTmp[ 2 ] ] ), FALSE );
+				}
+				else
+				{
+					for ( nX = nXStart; nX < mnWidth; nX += nXAdd, pTmp += 6 )
+						ImplSetPixel( nY, nX, BitmapColor( mpColorTable[ pTmp[ 0 ] ],
+															mpColorTable[ pTmp[ 2 ] ],
+																mpColorTable[ pTmp[ 4 ] ] ), FALSE );
+				}
+			}
+		}
+	}
+
+	rtl_copyMemory( mpScanprior, mpInflateInBuf, mnScansize );
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplSetPixel( sal_uInt32 nY, sal_uInt32 nX, const BitmapColor& rBitmapColor, BOOL bTrans )
+{
+	if ( mnPass == 7 )
+	{
+		mpAcc->SetPixel( nY, nX, rBitmapColor );
+
+		if ( bTrans )
+			mpMaskAcc->SetPixel( nY, nX, cTransIndex1 );
+		else
+			mpMaskAcc->SetPixel( nY, nX, cNonTransIndex1 );
+	}
+	else
+	{
+		sal_uInt32 nTX;
+
+		for ( int nBHeight = 0; nBHeight < aBlockHeight[ mnPass ]; nBHeight++ )
+		{
+			nTX = nX;
+
+			for ( int nBWidth = 0; nBWidth < aBlockWidth[ mnPass ]; nBWidth++ )
+			{
+				mpAcc->SetPixel( nY, nTX, rBitmapColor );
+
+				if ( bTrans )
+					mpMaskAcc->SetPixel( nY, nTX, cTransIndex1 );
+				else
+					mpMaskAcc->SetPixel( nY, nTX, cNonTransIndex1 );
+
+				if ( ++nTX == mnWidth )
+					break;
+			}
+
+			if ( ++nY == mnHeight )
+				break;
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplSetPixel( sal_uInt32 nY, sal_uInt32 nX, BYTE nPalIndex, BOOL bTrans )
+{
+	if ( mnPass == 7 )
+	{
+		mpAcc->SetPixel( nY, nX, (BYTE)nPalIndex );
+
+		if ( bTrans )
+			mpMaskAcc->SetPixel( nY, nX, cTransIndex1 );
+		else
+			mpMaskAcc->SetPixel( nY, nX, cNonTransIndex1 );
+	}
+	else
+	{
+		sal_uInt32 nTX;
+
+		for ( int nBHeight = 0; nBHeight < aBlockHeight[ mnPass ]; nBHeight++ )
+		{
+			nTX = nX;
+
+			for ( int nBWidth = 0; nBWidth < aBlockWidth[ mnPass ]; nBWidth++ )
+			{
+				mpAcc->SetPixel( nY, nTX, (BYTE)nPalIndex );
+
+				if ( bTrans )
+					mpMaskAcc->SetPixel( nY, nTX, cTransIndex1 );
+				else
+					mpMaskAcc->SetPixel( nY, nTX, cNonTransIndex1 );
+
+				if ( ++nTX == mnWidth )
+					break;
+			}
+			if ( ++nY == mnHeight )
+				break;
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+void PNGReaderImpl::ImplSetAlphaPixel( sal_uInt32 nY, sal_uInt32 nX, const BitmapColor& rBitmapColor, BYTE nAlpha )
+{
+	if ( mnPass == 7 )
+	{
+		mpAcc->SetPixel( nY, nX, rBitmapColor );
+		mpMaskAcc->SetPixel( nY, nX, 255 - nAlpha );
+	}
+	else
+	{
+		sal_uInt32 nTX;
+
+		for ( int nBHeight = 0; nBHeight < aBlockHeight[ mnPass ]; nBHeight++ )
+		{
+			nTX = nX;
+
+			for ( int nBWidth = 0; nBWidth < aBlockWidth[ mnPass ]; nBWidth++ )
+			{
+				mpAcc->SetPixel( nY, nTX, rBitmapColor );
+				mpMaskAcc->SetPixel( nY, nTX, 255 - nAlpha );
+				if ( ++nTX == mnWidth )
+					break;
+			}
+
+			if ( ++nY == mnHeight )
+				break;
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+sal_uInt32 PNGReaderImpl::ImplReadsal_uInt32()
+{
+	sal_uInt32 nRet;
+	nRet = *maDataIter++;
+	nRet <<= 8;
+	nRet |= *maDataIter++;
+	nRet <<= 8;
+	nRet |= *maDataIter++;
+	nRet <<= 8;
+	nRet |= *maDataIter++;
+	return nRet;
+}
+
+// ------------------------------------------------------------------------
+
+// -------------
+// - PNGReader -
+// -------------
+
+PNGReader::PNGReader( SvStream& rIStm ) :
+	mpImpl( new ::vcl::PNGReaderImpl( rIStm ) )
+{
+}
+
+// ------------------------------------------------------------------------
+
+PNGReader::~PNGReader()
+{
+	delete mpImpl;
+}
+
+// ------------------------------------------------------------------------
+
+BitmapEx PNGReader::Read()
+{
+	return mpImpl->Read();
+}
+
+// ------------------------------------------------------------------------
+
+const std::vector< vcl::PNGReader::ChunkData >& PNGReader::GetChunks() const
+{
+	return mpImpl->maChunkSeq;
+}
+
+} // namespace vcl
Index: vcl/source/gdi/pngwrite.cxx
===================================================================
RCS file: vcl/source/gdi/pngwrite.cxx
diff -N vcl/source/gdi/pngwrite.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/source/gdi/pngwrite.cxx	28 Jun 2004 16:23:56 -0000	1.4
@@ -0,0 +1,750 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include "pngwrite.hxx"
+
+#include <cmath>
+#include <rtl/crc.h>
+#include <rtl/memory.h>
+#include <rtl/alloc.h>
+#include <tools/zcodec.hxx>
+#include <tools/stream.hxx>
+#include "bmpacc.hxx"
+#include "svapp.hxx"
+#include "alpha.hxx"
+
+#ifndef _OSL_ENDIAN_H_
+#include <osl/endian.h>
+#endif
+
+// -----------
+// - Defines -
+// -----------
+
+#define PNG_DEF_COMPRESSION 6
+
+#define PNGCHUNK_IHDR 0x49484452
+#define PNGCHUNK_PLTE 0x504c5445
+#define PNGCHUNK_IDAT 0x49444154
+#define PNGCHUNK_IEND 0x49454e44
+#define PNGCHUNK_bKGD 0x624b4744
+#define PNGCHUNK_cHRM 0x6348524d
+#define PNGCHUNK_gAMA 0x67414d41
+#define PNGCHUNK_hIST 0x68495354
+#define PNGCHUNK_pHYs 0x70485973
+#define PNGCHUNK_sBIT 0x73425420
+#define PNGCHUNK_tIME 0x74494d45
+#define PNGCHUNK_tEXt 0x74455874
+#define PNGCHUNK_tRNS 0x74524e53
+#define PNGCHUNK_zTXt 0x7a545874
+
+namespace vcl
+{
+// -----------------
+// - PNGWriterImplImpl -
+// -----------------
+
+class PNGWriterImpl
+{
+public:
+
+				PNGWriterImpl( const BitmapEx& BmpEx,
+					const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >* pFilterData = NULL );
+				~PNGWriterImpl();
+
+	sal_Bool	Write( SvStream& rOStm );
+
+	std::vector< vcl::PNGWriter::ChunkData >&	GetChunks();
+
+private:
+
+	std::vector< vcl::PNGWriter::ChunkData >	maChunkSeq;
+
+	sal_Int32			mnCompLevel;
+	sal_Int32			mnInterlaced;
+	BOOL				mbStatus;
+
+	BitmapReadAccess*	mpAccess;
+	BitmapReadAccess*	mpMaskAccess;
+	ZCodec*				mpZCodec;
+
+	BYTE*				mpDeflateInBuf;			// as big as the size of a scanline + alphachannel + 1
+	BYTE*				mpPreviousScan;			// as big as mpDeflateInBuf
+	BYTE*				mpCurrentScan;
+	ULONG				mnDeflateInSize;
+
+	ULONG				mnWidth, mnHeight;
+	BYTE				mnBitsPerPixel;
+	BYTE				mnFilterType;			// 0 oder 4;
+	ULONG				mnBBP;					// bytes per pixel ( needed for filtering )
+	BOOL				mbTrueAlpha;
+	ULONG				mnCRC;
+	long				mnChunkDatSize;
+	ULONG				mnLastPercent;
+
+	void				ImplWritepHYs( const BitmapEx& rBitmapEx );
+	void				ImplWriteIDAT();
+	ULONG				ImplGetFilter( ULONG nY, ULONG nXStart=0, ULONG nXAdd=1 );
+	void				ImplClearFirstScanline();
+	void				ImplWriteTransparent();
+	BOOL				ImplWriteHeader();
+	void				ImplWritePalette();
+	void				ImplOpenChunk( ULONG nChunkType );
+	void				ImplWriteChunk( BYTE nNumb );
+	void				ImplWriteChunk( ULONG nNumb );
+	void				ImplWriteChunk( unsigned char* pSource, sal_uInt32 nDatSize );
+	void				ImplCloseChunk( void );
+};
+
+// ------------------------------------------------------------------------
+
+PNGWriterImpl::PNGWriterImpl( const BitmapEx& rBmpEx,
+	const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >* pFilterData ) :
+		mnLastPercent	( 0UL ),
+		mnInterlaced	( 0 ),
+		mnCompLevel		( PNG_DEF_COMPRESSION ),
+		mpAccess		( NULL ),
+		mpMaskAccess	( NULL ),
+		mbStatus		( TRUE ),
+		mpZCodec		( new ZCodec( DEFAULT_IN_BUFSIZE, DEFAULT_OUT_BUFSIZE, MAX_MEM_USAGE ) )
+{
+	if ( !rBmpEx.IsEmpty() )
+	{
+		Bitmap			aBmp( rBmpEx.GetBitmap() );
+
+		if ( pFilterData )
+		{
+			sal_Int32 i = 0;
+			for ( i = 0; i < pFilterData->getLength(); i++ )
+			{
+				if ( (*pFilterData)[ i ].Name.equalsAscii( "Compression" ) )
+					(*pFilterData)[ i ].Value >>= mnCompLevel;
+				else if ( (*pFilterData)[ i ].Name.equalsAscii( "Interlaced" ) )
+					(*pFilterData)[ i ].Value >>= mnInterlaced;
+			}
+		}
+		mnBitsPerPixel = (BYTE)aBmp.GetBitCount();
+		
+		if( rBmpEx.IsTransparent() )
+		{
+			if ( mnBitsPerPixel <= 8 && rBmpEx.IsAlpha() )
+			{
+				aBmp.Convert( BMP_CONVERSION_24BIT );
+				mnBitsPerPixel = 24;
+			}
+	        
+			if ( mnBitsPerPixel <= 8 )					// transparent palette
+			{
+				aBmp.Convert( BMP_CONVERSION_8BIT_TRANS );
+				aBmp.Replace( rBmpEx.GetMask(), BMP_COL_TRANS );
+				mnBitsPerPixel = 8;
+				mpAccess = aBmp.AcquireReadAccess();
+				if ( mpAccess )
+				{
+					if ( ImplWriteHeader() )
+					{
+						ImplWritepHYs( rBmpEx );
+						ImplWritePalette();
+						ImplWriteTransparent();
+						ImplWriteIDAT();
+					}
+					aBmp.ReleaseAccess( mpAccess );
+				}
+				else
+					mbStatus = FALSE;
+			}
+			else
+			{
+				mpAccess = aBmp.AcquireReadAccess();	// TRUE RGB with alphachannel
+				if( mpAccess )
+				{
+					if ( ( mbTrueAlpha = rBmpEx.IsAlpha() ) )
+					{
+						AlphaMask aMask( rBmpEx.GetAlpha() );
+						mpMaskAccess = aMask.AcquireReadAccess();
+						if ( mpMaskAccess )
+						{
+							if ( ImplWriteHeader() )
+							{
+								ImplWritepHYs( rBmpEx );
+								ImplWriteIDAT();
+							}
+							aMask.ReleaseAccess( mpMaskAccess );
+						}
+						else
+							mbStatus = FALSE;
+					}
+					else
+					{
+						Bitmap aMask( rBmpEx.GetMask() );
+						mpMaskAccess = aMask.AcquireReadAccess();
+						if( mpMaskAccess )
+						{
+							if ( ImplWriteHeader() )
+							{
+								ImplWritepHYs( rBmpEx );
+								ImplWriteIDAT();
+							}
+							aMask.ReleaseAccess( mpMaskAccess );
+						}
+						else
+							mbStatus = FALSE;
+					}
+					aBmp.ReleaseAccess( mpAccess );
+				}
+				else
+					mbStatus = FALSE;
+			}
+		}
+		else
+		{
+			mpAccess = aBmp.AcquireReadAccess();		// palette + RGB without alphachannel
+			if( mpAccess )
+			{
+				if ( ImplWriteHeader() )
+				{
+					ImplWritepHYs( rBmpEx );
+					if( mpAccess->HasPalette() )
+						ImplWritePalette();
+
+					ImplWriteIDAT();
+				}
+				aBmp.ReleaseAccess( mpAccess );
+			}
+			else
+				mbStatus = FALSE;
+		}
+		if ( mbStatus )
+		{
+			ImplOpenChunk( PNGCHUNK_IEND );		// create an IEND chunk
+			ImplCloseChunk();
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+PNGWriterImpl::~PNGWriterImpl()
+{
+	delete mpZCodec;
+}
+
+// ------------------------------------------------------------------------
+
+sal_Bool PNGWriterImpl::Write( SvStream& rOStm )
+{
+   /* png signature is always an array of 8 bytes */
+	sal_uInt16 nOldMode = rOStm.GetNumberFormatInt();
+	rOStm.SetNumberFormatInt( NUMBERFORMAT_INT_BIGENDIAN );
+	rOStm << (ULONG)0x89504e47;
+	rOStm << (ULONG)0x0d0a1a0a;
+
+	std::vector< vcl::PNGWriter::ChunkData >::iterator aBeg( maChunkSeq.begin() );
+	std::vector< vcl::PNGWriter::ChunkData >::iterator aEnd( maChunkSeq.end() );
+	while( aBeg != aEnd )
+	{
+		sal_uInt32 nType = aBeg->nType;
+	#if defined(__LITTLEENDIAN) || defined(OSL_LITENDIAN)
+		nType = SWAPLONG( nType );
+	#endif
+		sal_uInt32 nCRC = rtl_crc32( 0, &nType, 4 );
+		sal_uInt32 nDataSize = aBeg->aData.size();
+		if ( nDataSize )
+			nCRC = rtl_crc32( nCRC, &aBeg->aData[ 0 ], nDataSize );
+		rOStm << nDataSize
+			  << aBeg->nType;
+		rOStm.Write( &aBeg->aData[ 0 ], nDataSize );
+		rOStm << nCRC;
+		aBeg++;
+	}
+	rOStm.SetNumberFormatInt( nOldMode );
+	return mbStatus;
+}
+
+// ------------------------------------------------------------------------
+
+std::vector< vcl::PNGWriter::ChunkData >& PNGWriterImpl::GetChunks()
+{
+	return maChunkSeq;
+}
+
+// ------------------------------------------------------------------------
+
+BOOL PNGWriterImpl::ImplWriteHeader()
+{
+	ImplOpenChunk(PNGCHUNK_IHDR);
+	ImplWriteChunk( ( mnWidth = (ULONG)mpAccess->Width() ) );
+	ImplWriteChunk( ( mnHeight = (ULONG)mpAccess->Height() ) );
+
+	if ( mnWidth && mnHeight && mnBitsPerPixel && mbStatus )
+	{
+		BYTE nBitDepth = mnBitsPerPixel;
+		if ( mnBitsPerPixel <= 8 )
+			mnFilterType = 0;
+		else
+			mnFilterType = 4;
+
+		BYTE nColorType = 2;					// colortype:
+												// bit 0 -> palette is used
+		if ( mpAccess->HasPalette() )			// bit 1 -> color is used
+			nColorType |= 1;					// bit 2 -> alpha channel is used
+		else
+			nBitDepth /= 3;
+
+		if ( mpMaskAccess )
+			nColorType |= 4;
+
+		ImplWriteChunk( nBitDepth );
+		ImplWriteChunk( nColorType );			// colortype
+		ImplWriteChunk((BYTE) 0 );				// compression type
+		ImplWriteChunk((BYTE) 0 );				// filter type - is not supported in this version
+		ImplWriteChunk((BYTE) mnInterlaced );	// interlace type
+		ImplCloseChunk();
+	}
+	else
+		mbStatus = FALSE;
+	return mbStatus;
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplWritePalette()
+{
+	const ULONG	nCount = mpAccess->GetPaletteEntryCount();
+	BYTE*		pTempBuf = new BYTE[ nCount*3 ];
+	BYTE*		pTmp = pTempBuf;
+
+	ImplOpenChunk( PNGCHUNK_PLTE );
+
+	for ( USHORT i = 0; i < nCount; i++ )
+	{
+		const BitmapColor& rColor = mpAccess->GetPaletteColor( i );
+		*pTmp++ = rColor.GetRed();
+		*pTmp++ = rColor.GetGreen();
+		*pTmp++ = rColor.GetBlue();
+	}
+	ImplWriteChunk( pTempBuf, nCount*3 );
+	ImplCloseChunk();
+	delete[] pTempBuf;
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplWriteTransparent ()
+{
+	const ULONG nTransIndex = mpAccess->GetBestMatchingColor( BMP_COL_TRANS );
+
+	ImplOpenChunk( PNGCHUNK_tRNS );
+
+	for ( ULONG n = 0UL; n <= nTransIndex; n++ )
+		ImplWriteChunk( ( nTransIndex == n ) ? (BYTE) 0x0 : (BYTE) 0xff );
+
+	ImplCloseChunk();
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplWritepHYs( const BitmapEx& rBmpEx )
+{
+	if ( rBmpEx.GetPrefMapMode() == MAP_100TH_MM )
+	{
+		Size aPrefSize( rBmpEx.GetPrefSize() );
+		if ( aPrefSize.Width() && aPrefSize.Height() )
+		{
+			ImplOpenChunk( PNGCHUNK_pHYs );
+			sal_uInt8 nMapUnit = 1;
+			sal_uInt32 nPrefSizeX = (sal_uInt32)( (double)100000.0 / ( (double)aPrefSize.Width() / mnWidth ) + 0.5 );
+			sal_uInt32 nPrefSizeY = (sal_uInt32)( (double)100000.0 / ( (double)aPrefSize.Height() / mnHeight ) + 0.5 );
+			ImplWriteChunk( nPrefSizeX );
+			ImplWriteChunk( nPrefSizeY );
+			ImplWriteChunk( nMapUnit );
+			ImplCloseChunk();
+		}
+	}
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplWriteIDAT ()
+{
+	ImplOpenChunk( PNGCHUNK_IDAT );
+
+	mnDeflateInSize = mnBitsPerPixel;
+
+	if( mpMaskAccess )
+		mnDeflateInSize += 8;
+
+	mnBBP = ( mnDeflateInSize + 7 ) >> 3;
+
+	mnDeflateInSize = mnBBP * mnWidth + 1;
+
+	mpDeflateInBuf = new BYTE[ mnDeflateInSize ];
+
+	if ( mnFilterType )			// using filter type 4 we need memory for the scanline 3 times
+	{
+		mpPreviousScan = new BYTE[ mnDeflateInSize ];
+		mpCurrentScan = new BYTE[ mnDeflateInSize ];
+		ImplClearFirstScanline();
+	}
+	mpZCodec->BeginCompression( ZCODEC_PNG_DEFAULT + mnCompLevel );
+	mpZCodec->SetCRC( mnCRC );
+	SvMemoryStream aOStm;
+	if ( mnInterlaced == 0 )
+	{
+		for ( ULONG nY = 0; nY < mnHeight; nY++ )
+			mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter( nY ) );
+	}
+	else
+	{
+		// interlace mode
+		ULONG nY;
+		for ( nY = 0; nY < mnHeight; nY+=8 )												// pass 1
+			mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 0, 8 ) );
+		ImplClearFirstScanline();
+
+		for ( nY = 0; nY < mnHeight; nY+=8 )												// pass 2
+			mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 4, 8 ) );
+		ImplClearFirstScanline();
+
+		if ( mnHeight >= 5 )																// pass 3
+		{
+			for ( nY = 4; nY < mnHeight; nY+=8 )
+				mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 0, 4 ) );
+			ImplClearFirstScanline();
+		}
+
+		for ( nY = 0; nY < mnHeight; nY+=4 )												// pass 4
+			mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 2, 4 ) );
+		ImplClearFirstScanline();
+
+		if ( mnHeight >= 3 )																// pass 5
+		{
+			for ( nY = 2; nY < mnHeight; nY+=4 )
+				mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 0, 2 ) );
+			ImplClearFirstScanline();
+		}
+
+		for ( nY = 0; nY < mnHeight; nY+=2 )												// pass 6
+			mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 1, 2 ) );
+		ImplClearFirstScanline();
+
+		if ( mnHeight >= 2 )																// pass 7
+		{
+			for ( nY = 1; nY < mnHeight; nY+=2 )
+				mpZCodec->Write( aOStm, mpDeflateInBuf, ImplGetFilter ( nY, 0, 1 ) );
+		}
+	}
+	mpZCodec->EndCompression();
+	mnCRC = mpZCodec->GetCRC();
+
+	if ( mnFilterType )			// using filter type 4 we need memory for the scanline 3 times
+	{
+		delete[] mpCurrentScan;
+		delete[] mpPreviousScan;
+	}
+	delete[] mpDeflateInBuf;
+	ImplWriteChunk( (unsigned char*)aOStm.GetData(), aOStm.Tell() );
+	ImplCloseChunk();
+}
+
+// ---------------------------------------------------------------------------------------------------
+// ImplGetFilter writes the complete Scanline (nY) - in interlace mode the parameter nXStart and nXAdd
+// appends to the currently used pass
+// the complete size of scanline will be returned - in interlace mode zero is possible!
+
+ULONG PNGWriterImpl::ImplGetFilter ( ULONG nY, ULONG nXStart, ULONG nXAdd )
+{
+	BYTE* pDest;
+
+	if ( mnFilterType )
+		pDest = mpCurrentScan;
+	else
+		pDest = mpDeflateInBuf;
+
+	if ( nXStart < mnWidth )
+	{
+		*pDest++ = mnFilterType;		// in this version the filter type is either 0 or 4
+
+		if ( mpAccess->HasPalette() )	// alphachannel is not allowed by pictures including palette entries
+		{
+			switch ( mnBitsPerPixel )
+			{
+				case( 1 ):
+				{
+					ULONG nX, nXIndex;
+					for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX+=nXAdd, nXIndex++ )
+					{
+						ULONG nShift = ( nXIndex & 7 ) ^ 7;
+						if ( nShift == 7)
+							*pDest = (BYTE) mpAccess->GetPixel( nY, nX ) << nShift;
+						else if  ( nShift == 0 )
+							*pDest++ |= (BYTE) mpAccess->GetPixel( nY, nX ) << nShift;
+						else
+							*pDest |= (BYTE) mpAccess->GetPixel( nY, nX ) << nShift;
+					}
+					if ( ( nXIndex & 7 ) != 0 ) pDest++;	// byte is not completely used, so the
+				}											// bufferpointer is to correct
+				break;
+
+				case( 4 ):
+				{
+					ULONG nX, nXIndex;
+					for ( nX = nXStart, nXIndex = 0; nX < mnWidth; nX+= nXAdd, nXIndex++ )
+					{
+						if( nXIndex & 1 )
+							*pDest++ |= (BYTE) mpAccess->GetPixel( nY, nX );
+						else
+							*pDest = (BYTE) mpAccess->GetPixel( nY, nX ) << 4;
+					}
+					if ( nXIndex & 1 ) pDest++;
+				}
+				break;
+
+				case( 8 ):
+				{
+					for ( ULONG nX = nXStart; nX < mnWidth; nX+=nXAdd )
+						*pDest++ = mpAccess->GetPixel( nY, nX );
+				}
+				break;
+
+				default :
+					mbStatus = FALSE;
+				break;
+			}
+		}
+		else
+		{
+			if ( mpMaskAccess )				// mpMaskAccess != NULL -> alphachannel is to create
+			{
+				if ( mbTrueAlpha )
+				{
+					for ( ULONG nX = nXStart; nX < mnWidth; nX += nXAdd )
+					{
+						const BitmapColor& rColor = mpAccess->GetPixel( nY, nX );
+						*pDest++ = rColor.GetRed();
+						*pDest++ = rColor.GetGreen();
+						*pDest++ = rColor.GetBlue();
+						*pDest++ = 255 - mpMaskAccess->GetPixel( nY, nX );
+					}
+				}
+				else
+				{
+					const BitmapColor aTrans( mpMaskAccess->GetBestMatchingColor( Color( COL_WHITE ) ) );
+
+					for ( ULONG nX = nXStart; nX < mnWidth; nX+=nXAdd )
+					{
+						const BitmapColor& rColor = mpAccess->GetPixel( nY, nX );
+						*pDest++ = rColor.GetRed();
+						*pDest++ = rColor.GetGreen();
+						*pDest++ = rColor.GetBlue();
+
+						if( mpMaskAccess->GetPixel( nY, nX ) == aTrans )
+							*pDest++ = 0;
+						else
+							*pDest++ = 0xff;
+					}
+				}
+			}
+			else
+			{
+				for ( ULONG nX = nXStart; nX < mnWidth; nX+=nXAdd )
+				{
+					const BitmapColor& rColor = mpAccess->GetPixel( nY, nX );
+					*pDest++ = rColor.GetRed();
+					*pDest++ = rColor.GetGreen();
+					*pDest++ = rColor.GetBlue();
+				}
+			}
+		}
+	}
+	// filter type4 ( PAETH ) will be used only for 24bit graphics
+	if ( mnFilterType )
+	{
+		mnDeflateInSize = pDest - mpCurrentScan;
+		pDest = mpDeflateInBuf;
+		*pDest++ = 4;									// filter type
+
+		ULONG na, nb, nc;
+		long  np, npa, npb, npc;
+
+		BYTE* p1 = mpCurrentScan + 1;					// Current Pixel
+		BYTE* p2 = p1 - mnBBP;							// left pixel
+		BYTE* p3 = mpPreviousScan;						// upper pixel
+		BYTE* p4 = p3 - mnBBP;							// upperleft Pixel;
+
+		while ( pDest < mpDeflateInBuf + mnDeflateInSize )
+		{
+			nb = *p3++;
+			if ( p2 >= mpCurrentScan + 1 )
+			{
+				na = *p2;
+				nc = *p4;
+			}
+			else
+				na = nc = 0;
+
+			np = na + nb;
+			np -= nc;
+			npa = np - na;
+			npb = np - nb;
+			npc = np - nc;
+			if ( npa < 0 )
+				npa =-npa;
+			if ( npb < 0 )
+				npb =-npb;
+			if ( npc < 0 )
+				npc =-npc;
+			if ( ( npa <= npb ) && ( npa <= npc ) ) *pDest++ = *p1++ - (BYTE)na;
+			else if ( npb <= npc ) *pDest++ = *p1++ - (BYTE)nb;
+			else *pDest++ = *p1++ - (BYTE)nc;
+			p4++;
+			p2++;
+		}
+		for ( long i = 0; i < (long)( mnDeflateInSize - 1 ); i++ )
+			mpPreviousScan[ i ] = mpCurrentScan[ i + 1 ];
+	}
+	else
+		mnDeflateInSize = pDest - mpDeflateInBuf;
+	return ( mnDeflateInSize );
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplClearFirstScanline()
+{
+	if ( mnFilterType )
+		rtl_zeroMemory( mpPreviousScan, mnDeflateInSize );
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplOpenChunk ( ULONG nChunkType )
+{
+	maChunkSeq.resize( maChunkSeq.size() + 1 );
+	maChunkSeq.back().nType = nChunkType;
+}
+
+// ------------------------------------------------------------------------
+
+void PNGWriterImpl::ImplWriteChunk ( BYTE nSource )
+{
+	maChunkSeq.back().aData.push_back( nSource );
+}
+
+void PNGWriterImpl::ImplWriteChunk ( ULONG nSource )
+{
+	vcl::PNGWriter::ChunkData& rChunkData = maChunkSeq.back();
+	rChunkData.aData.push_back( (sal_uInt8)( nSource >> 24 ) );
+	rChunkData.aData.push_back( (sal_uInt8)( nSource >> 16 ) );
+	rChunkData.aData.push_back( (sal_uInt8)( nSource >> 8 ) );
+	rChunkData.aData.push_back( (sal_uInt8)( nSource ) );
+}
+
+void PNGWriterImpl::ImplWriteChunk ( unsigned char* pSource, sal_uInt32 nDatSize )
+{
+	if ( nDatSize )
+	{
+		vcl::PNGWriter::ChunkData& rChunkData = maChunkSeq.back();
+		sal_uInt32 nSize = rChunkData.aData.size();
+		rChunkData.aData.resize( nSize + nDatSize );
+		rtl_copyMemory( &rChunkData.aData[ nSize ], pSource, nDatSize );
+	}
+}
+
+// ------------------------------------------------------------------------
+// nothing to do
+void PNGWriterImpl::ImplCloseChunk ( void )
+{
+}
+
+// -------------
+// - PNGWriter -
+// -------------
+
+PNGWriter::PNGWriter( const BitmapEx& rBmpEx,
+	const ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyValue >* pFilterData ) :
+	mpImpl( new ::vcl::PNGWriterImpl( rBmpEx, pFilterData ) )
+{
+}
+
+// ------------------------------------------------------------------------
+
+PNGWriter::~PNGWriter()
+{
+	delete mpImpl;
+}
+
+// ------------------------------------------------------------------------
+
+sal_Bool PNGWriter::Write( SvStream& rIStm )
+{
+	return mpImpl->Write( rIStm );
+}
+
+// ------------------------------------------------------------------------
+
+std::vector< vcl::PNGWriter::ChunkData >& PNGWriter::GetChunks()
+{
+	return mpImpl->GetChunks();
+}
+
+} // namespace vcl
+
Index: vcl/source/gdi/polyscan.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/polyscan.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/polyscan.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/polyscan.cxx	6 Jan 2004 13:52:52 -0000	1.2
@@ -62,8 +62,11 @@
 #include <string.h>
 #include <tools/new.hxx>
 #include "salbtype.hxx"
-#include "poly.hxx"
 #include "polyscan.hxx"
+
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
+#endif
 
 // ----------------
 // - PolyScanline -
Index: vcl/source/gdi/print.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/print.cxx,v
retrieving revision 1.42.82.1
retrieving revision 1.45
diff -u -p -u -r1.42.82.1 -r1.45
--- vcl/source/gdi/print.cxx	26 Jan 2004 17:23:05 -0000	1.42.82.1
+++ vcl/source/gdi/print.cxx	6 Jan 2004 13:53:20 -0000	1.45
@@ -59,14 +59,11 @@
  *
  ************************************************************************/
 
-#define _SV_PRINT_CXX
 #define _SPOOLPRINTER_EXT
 #define _RMPRINTER_EXT
 #define ENABLE_BYTESTRING_STREAM_OPERATORS
 #include <list>
 
-#ifndef REMOTE_APPSERVER
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -85,44 +82,6 @@
 
 #include <unohelp.hxx>
 
-#else /* REMOTE_APPSERVER */
-
-#include "rvp.hxx"
-#include "rmoutdev.hxx"
-#include "rmwindow.hxx"
-
-struct SalPrinterQueueInfo
-{
-	XubString				maPrinterName;
-	XubString				maDriver;
-	XubString				maLocation;
-	XubString				maComment;
-	ULONG					mnStatus;
-	ULONG					mnJobs;
-	void*					mpSysData;
-
-							SalPrinterQueueInfo();
-							~SalPrinterQueueInfo();
-};
-#include "rmprint.hxx"
-
-#include <vos/mutex.hxx>
-#ifndef _VCL_UNOHELP_HXX
-#include <unohelp.hxx>
-#endif
-
-using namespace com::sun::star::portal::client;
-
-#if OSL_DEBUG_LEVEL > 1
-#ifdef PRODUCT
-#define OSL_DEBUG_LEVEL 0
-#else
-#define OSL_DEBUG_LEVEL 1
-#endif
-#endif
-
-#endif
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -371,27 +330,7 @@ static void ImplInitPrnQueueList()
 
 	pSVData->maGDIData.mpPrinterQueueList = new ImplPrnQueueList;
 
-#ifndef REMOTE_APPSERVER
 	pSVData->mpDefInst->GetPrinterQueueInfo( pSVData->maGDIData.mpPrinterQueueList );
-#else
-    BOOL		bPrinterInfoOk = FALSE;
-    const ULONG nCount = pSVData->mpPrinterEnvironment->Infos.getLength();
-    const RmQueueInfo* pInfos = pSVData->mpPrinterEnvironment->Infos.getConstArray();
-
-    for( ULONG i = 0; i < nCount; i++ )
-    {
-        SalPrinterQueueInfo*		pNewInfo = new SalPrinterQueueInfo;
-
-        pNewInfo->maPrinterName = pInfos[i].PrinterName;
-        pNewInfo->maDriver		= pInfos[i].Driver;
-        pNewInfo->maLocation	= pInfos[i].Location;
-        pNewInfo->maComment 	= pInfos[i].Comment;
-        pNewInfo->mnStatus		= pInfos[i].PrinterStatus;
-        pNewInfo->mnJobs		= pInfos[i].Jobs;
-        pNewInfo->mpSysData 	= NULL;
-        pSVData->maGDIData.mpPrinterQueueList->Add( pNewInfo );
-	}
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -409,11 +348,7 @@ void ImplDeletePrnQueueList()
 			if ( pInfo->mpQueueInfo )
 				delete pInfo->mpQueueInfo;
 
-#ifndef REMOTE_APPSERVER
 			pSVData->mpDefInst->DeletePrinterQueueInfo( pInfo->mpSalQueueInfo );
-#else
-			delete pInfo->mpSalQueueInfo;
-#endif
 
 			delete pInfo;
 			pInfo = pPrnList->Next();
@@ -457,12 +392,8 @@ const QueueInfo& Printer::GetQueueInfo( 
 
 	ImplPrnQueueData* pInfo = pSVData->maGDIData.mpPrinterQueueList->Get( nQueue );
 
-#ifndef REMOTE_APPSERVER
 	if ( bStatus )
 		pSVData->mpDefInst->GetPrinterQueueState( pInfo->mpSalQueueInfo );
-#else
-	// ???
-#endif
 
 	if ( !pInfo->mpQueueInfo )
 		pInfo->mpQueueInfo = new QueueInfo;
@@ -482,11 +413,7 @@ XubString Printer::GetDefaultPrinterName
 {
 	ImplSVData* pSVData = ImplGetSVData();
 
-#ifndef REMOTE_APPSERVER
 	return pSVData->mpDefInst->GetDefaultPrinter();
-#else
-	return pSVData->mpPrinterEnvironment->DefaultPrinter;
-#endif
 }
 
 // =======================================================================
@@ -524,9 +451,6 @@ void Printer::ImplInitData()
 	else
 		pSVData->maGDIData.mpLastPrinter = this;
 	pSVData->maGDIData.mpFirstPrinter = this;
-#ifdef REMOTE_APPSERVER
-    mpRemotePages = new ::std::vector< PrinterPage* >();
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -557,7 +481,6 @@ void Printer::ImplInit( SalPrinterQueueI
 	pJobSetup->maPrinterName = maPrinterName;
 	pJobSetup->maDriver = maDriver;
 
-#ifndef REMOTE_APPSERVER
 	mpInfoPrinter	= pSVData->mpDefInst->CreateInfoPrinter( pInfo, pJobSetup );
 	mpPrinter		= NULL;
 	mpJobPrinter	= NULL;
@@ -576,73 +499,10 @@ void Printer::ImplInit( SalPrinterQueueI
 		ImplInitDisplay( NULL );
 		return;
 	}
-#else
-
-	mpInfoPrinter = new RmPrinter;
-
-	Reference< XRmPrinter > xPrinter;
-
-	if (pSVData->mxClientFactory.is() )
-	{
-        xPrinter = Reference< XRmPrinter >( pSVData->mxClientFactory->createInstance( ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "OfficePrinter.stardiv.de" ) ) ), NMSP_UNO::UNO_QUERY );
-        mpInfoPrinter->SetInterface( xPrinter );
-	}
-
-	if ( ! xPrinter.is() )
-	{
-		delete mpInfoPrinter;
-		mpInfoPrinter = NULL;
-		ImplInitDisplay( NULL );
-		return;
-	}
-	else
-	{
-		QueueInfo				aQInfo;
-		RmJobSetup 				aRmJobSetup;
-		const REF( XRmPrinter )&	rxPrinter = mpInfoPrinter->GetInterface();
-
-        const RmQueueInfo* 		pInfos = pSVData->mpPrinterEnvironment->Infos.getConstArray();
-        const RmQueueInfo* 		pSelectedInfo = NULL;
-        ::rtl::OUString aCompare( maPrinterName );
-        for( int i = 0; i < pSVData->mpPrinterEnvironment->Infos.getLength(); i++ )
-        {
-            if( pInfos[i].PrinterName == aCompare )
-            {
-                pSelectedInfo = pInfos+i;
-                break;
-            }
-        }
-
-        if( pSelectedInfo )
-        {
-            mpInfoPrinter->CreateInfoInstance( *pSelectedInfo, aRmJobSetup );
-            maJobSetup = aRmJobSetup;
-        }
-
-		if( rxPrinter.is() )
-		{
-			mpGraphics = new ImplServerGraphics( pSVData->mpAtoms );
-            REF( XRmOutputDevice ) aTmp( rxPrinter, UNO_QUERY );
-			mpGraphics->SetInterface( aTmp );
-		}
-
-		if( !mpGraphics->GetInterface().is() )
-		{
-			delete mpGraphics, mpGraphics = NULL;
-			delete mpInfoPrinter, mpInfoPrinter = NULL;
-			ImplInitDisplay( NULL );
-			return;
-		}
-		else
-		{
-			ImplGetServerGraphics();
-		}
-	}
-#endif
 
 	// Daten initialisieren
 	ImplUpdatePageData();
-	mpFontList = new ImplDevFontList;
+	mpFontList = new ImplDevFontList();
 	mpFontCache = new ImplFontCache( TRUE );
 	mpGraphics->GetDevFontList( mpFontList );
 }
@@ -666,10 +526,6 @@ void Printer::ImplInitDisplay( const Win
 	mpFontCache 		= pSVData->maGDIData.mpScreenFontCache;
 	mnDPIX				= mpDisplayDev->mnDPIX;
 	mnDPIY				= mpDisplayDev->mnDPIY;
-
-#ifdef REMOTE_APPSERVER
-	mpGraphics			= mpDisplayDev->mpGraphics;
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -761,7 +617,6 @@ SalPrinterQueueInfo* Printer::ImplGetQue
 
 void Printer::ImplUpdatePageData()
 {
-#ifndef REMOTE_APPSERVER
 	// we need a graphics
 	if ( !ImplGetGraphics() )
 		return;
@@ -771,15 +626,6 @@ void Printer::ImplUpdatePageData()
 								mnOutWidth, mnOutHeight,
 								maPageOffset.X(), maPageOffset.Y(),
 								maPaperSize.Width(), maPaperSize.Height() );
-#else
-	if ( mpInfoPrinter && mpGraphics )
-	{
-		mpGraphics->GetResolution( mnDPIX, mnDPIY );
-		mpInfoPrinter->GetPageInfo( mnOutWidth, mnOutHeight,
-									maPageOffset.X(), maPageOffset.Y(),
-									maPaperSize.Width(), maPaperSize.Height() );
-	}
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -869,37 +715,9 @@ Printer::~Printer()
 
     delete mpPrinterOptions;
 
-#ifndef REMOTE_APPSERVER
 	ImplReleaseGraphics();
 	if ( mpInfoPrinter )
 		ImplGetSVData()->mpDefInst->DestroyInfoPrinter( mpInfoPrinter );
-#else
-	if ( mpInfoPrinter )
-	{
-		if( mpGraphics ) {
-           REF( XRmOutputDevice ) aTmp;
-			mpGraphics->SetInterface( aTmp );
-        }
-
-		ImplReleaseServerGraphics();
-
-		if ( mpGetDevFontList )
-		{
-			delete mpGetDevFontList;
-			mpGetDevFontList = NULL;
-		}
-		if ( mpGetDevSizeList )
-		{
-			delete mpGetDevSizeList;
-			mpGetDevSizeList = NULL;
-		}
-		delete mpGraphics, mpGraphics = NULL;
-		delete mpInfoPrinter, mpInfoPrinter = NULL;
-	}
-    for( int i = 0; i < mpRemotePages->size(); i++ )
-        delete (*mpRemotePages)[i];
-    delete mpRemotePages;
-#endif
 	if ( mpDisplayDev )
 		delete mpDisplayDev;
 	else
@@ -944,11 +762,7 @@ ULONG Printer::GetCapabilities( USHORT n
 	if ( IsDisplayPrinter() )
 		return FALSE;
 
-#ifndef REMOTE_APPSERVER
 	return mpInfoPrinter->GetCapabilities( maJobSetup.ImplGetConstData(), nType );
-#else
-	return mpInfoPrinter->GetCapabilities( nType );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -989,7 +803,6 @@ BOOL Printer::SetJobSetup( const JobSetu
 
 	JobSetup aJobSetup = rSetup;
 
-#ifndef REMOTE_APPSERVER
 	ImplReleaseGraphics();
 	if ( mpInfoPrinter->SetPrinterData( aJobSetup.ImplGetData() ) )
 	{
@@ -1002,55 +815,10 @@ BOOL Printer::SetJobSetup( const JobSetu
 	}
 
 	return FALSE;
-#else
-	if ( mpInfoPrinter )
-	{
-		RmJobSetup aRmJobSetup;
-
-        aJobSetup.SetRmJobSetup( aRmJobSetup );
-		if ( mpInfoPrinter->SetJobSetup( aRmJobSetup ) )
-		{
-			mbNewJobSetup = TRUE;
-			maJobSetup = aRmJobSetup;
-			ImplUpdatePageData();
-			ImplUpdateFontList();
-			return TRUE;
-		}
-		else
-			return FALSE;
-	}
-	return FALSE;
-#endif
 }
 
 // -----------------------------------------------------------------------
 
-#ifdef REMOTE_APPSERVER
-IMPL_LINK( Printer, UserSetupCompleted, ::com::sun::star::uno::Any*, pResult )
-{
-	::vos::OGuard guard( Application::GetSolarMutex( ) );
-
-	if( pResult->hasValue() )
-	{
-		mbUserSetupResult = TRUE;
-
-		::com::sun::star::portal::client::RmJobSetup aRmJobSetup;
-		*pResult >>= aRmJobSetup;
-		JobSetup aJobSetup;
-        aJobSetup = aRmJobSetup;
-		ImplUpdateJobSetupPaper( aJobSetup );
-		mbNewJobSetup = TRUE;
-		maJobSetup = aJobSetup;
-		ImplUpdatePageData();
-		ImplUpdateFontList();
-	}
-	else
-		mbUserSetupResult = FALSE;
-
-	mbUserSetupCompleted = TRUE;
-	return 0;
-}
-#endif
 
 BOOL Printer::Setup( Window* pWindow )
 {
@@ -1060,7 +828,6 @@ BOOL Printer::Setup( Window* pWindow )
 	if ( IsJobActive() || IsPrinting() )
 		return FALSE;
 
-#ifndef REMOTE_APPSERVER
 	JobSetup aJobSetup = maJobSetup;
 	SalFrame* pFrame;
 	if ( !pWindow )
@@ -1084,21 +851,6 @@ BOOL Printer::Setup( Window* pWindow )
 		return TRUE;
 	}
 	return FALSE;
-#else
-	RmJobSetup aRmJobSetup;
-    maJobSetup.SetRmJobSetup( aRmJobSetup );
-	mpInfoPrinter->SetJobSetup( aRmJobSetup );
-	RmFrameWindow* pFrame;
-	if ( !pWindow )
-		pFrame = ImplGetDefaultWindow()->ImplGetFrame();
-	else
-		pFrame = pWindow->ImplGetFrame();
-	mbUserSetupCompleted = FALSE;
-	mpInfoPrinter->UserSetup( pFrame->GetFrameInterface(), pFrame->InsertUserEventLink( LINK( this, Printer, UserSetupCompleted ) ) );
-	while( ! mbUserSetupCompleted )
-		Application::Reschedule();
-	return mbUserSetupResult;
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -1123,22 +875,8 @@ BOOL Printer::SetPrinterProps( const Pri
 		// Alten Printer zerstoeren
 		if ( !IsDisplayPrinter() )
 		{
-#ifndef REMOTE_APPSERVER
 			ImplReleaseGraphics();
 			pSVData->mpDefInst->DestroyInfoPrinter( mpInfoPrinter );
-#else
-			if ( mpInfoPrinter )
-			{
-				if( mpGraphics ) {
-                    REF( XRmOutputDevice ) aTmp;
-					mpGraphics->SetInterface( aTmp );
-                }
-
-				ImplReleaseServerGraphics();
-				delete mpGraphics, mpGraphics = NULL;
-				delete mpInfoPrinter, mpInfoPrinter = NULL;
-			}
-#endif
 			if ( mpFontEntry )
 			{
 				mpFontCache->Release( mpFontEntry );
@@ -1173,9 +911,7 @@ BOOL Printer::SetPrinterProps( const Pri
 	// Alten Printer zerstoeren?
 	if ( GetName() != pPrinter->GetName() )
 	{
-#ifndef REMOTE_APPSERVER
 		ImplReleaseGraphics();
-#endif
 		if ( mpDisplayDev )
 		{
 			delete mpDisplayDev;
@@ -1183,21 +919,7 @@ BOOL Printer::SetPrinterProps( const Pri
 		}
 		else
 		{
-#ifndef REMOTE_APPSERVER
 			pSVData->mpDefInst->DestroyInfoPrinter( mpInfoPrinter );
-#else
-			if ( mpInfoPrinter )
-			{
-				if( mpGraphics ) {
-                    REF( XRmOutputDevice ) aTmp;
-					mpGraphics->SetInterface( aTmp );
-                }
-
-				ImplReleaseServerGraphics();
-				delete mpGraphics, mpGraphics = NULL;
-				delete mpInfoPrinter, mpInfoPrinter = NULL;
-			}
-#endif
 
 			if ( mpFontEntry )
 			{
@@ -1258,18 +980,10 @@ BOOL Printer::SetOrientation( Orientatio
 			return TRUE;
 		}
 
-#ifndef REMOTE_APPSERVER
 		ImplReleaseGraphics();
 		if ( mpInfoPrinter->SetData( SAL_JOBSET_ORIENTATION, pSetupData ) )
 		{
 			ImplUpdateJobSetupPaper( aJobSetup );
-#else
-		RmJobSetup aRmJobSetup;
-        aJobSetup.SetRmJobSetup( aRmJobSetup );
-		if ( mpInfoPrinter->SetOrientation( (unsigned short)eOrientation, aRmJobSetup ) )
-		{
-            aJobSetup = aRmJobSetup;
-#endif
 			mbNewJobSetup = TRUE;
 			maJobSetup = aJobSetup;
 			ImplUpdatePageData();
@@ -1311,18 +1025,10 @@ BOOL Printer::SetPaperBin( USHORT nPaper
 			return TRUE;
 		}
 
-#ifndef REMOTE_APPSERVER
 		ImplReleaseGraphics();
 		if ( mpInfoPrinter->SetData( SAL_JOBSET_PAPERBIN, pSetupData ) )
 		{
 			ImplUpdateJobSetupPaper( aJobSetup );
-#else
-		RmJobSetup aRmJobSetup;
-        aJobSetup.SetRmJobSetup( aRmJobSetup );
-		if ( mpInfoPrinter->SetPaperBin( nPaperBin, aRmJobSetup ) )
-		{
-            aJobSetup = aRmJobSetup;
-#endif
 			mbNewJobSetup = TRUE;
 			maJobSetup = aJobSetup;
 			ImplUpdatePageData();
@@ -1377,6 +1083,7 @@ void Printer::ImplFindPaperFormatForUser
 								 nPaperWidth,
 								 nPaperHeight ) )
 		{
+			pSetupData->meOrientation = ORIENTATION_PORTRAIT;
 			pSetupData->mePaperFormat = ImplGetPaperFormat( rPaperInfo.m_nPaperWidth*100,
 															rPaperInfo.m_nPaperHeight*100 );
 			break;
@@ -1399,6 +1106,7 @@ void Printer::ImplFindPaperFormatForUser
 									 nPaperHeight,
 									 nPaperWidth ))
 			{
+				pSetupData->meOrientation = ORIENTATION_LANDSCAPE;
 				pSetupData->mePaperFormat = ImplGetPaperFormat( rPaperInfo.m_nPaperWidth*100,
 																rPaperInfo.m_nPaperHeight*100 );
 				break;
@@ -1432,20 +1140,12 @@ BOOL Printer::SetPaper( Paper ePaper )
 			return TRUE;
 		}
 
-#ifndef REMOTE_APPSERVER
 		ImplReleaseGraphics();
 		if ( ePaper == PAPER_USER )
 			ImplFindPaperFormatForUserSize( aJobSetup );
 		if ( mpInfoPrinter->SetData( SAL_JOBSET_PAPERSIZE|SAL_JOBSET_ORIENTATION, pSetupData ) )
 		{
 			ImplUpdateJobSetupPaper( aJobSetup );
-#else
-		RmJobSetup aRmJobSetup;
-        aJobSetup.SetRmJobSetup( aRmJobSetup );
-		if ( mpInfoPrinter->SetPaper( (unsigned short)ePaper, aRmJobSetup ) )
-		{
-            aJobSetup = aRmJobSetup;
-#endif
 			mbNewJobSetup = TRUE;
 			maJobSetup = aJobSetup;
 			ImplUpdatePageData();
@@ -1486,7 +1186,6 @@ BOOL Printer::SetPaperSizeUser( const Si
 			return TRUE;
 		}
 
-#ifndef REMOTE_APPSERVER
 		ImplReleaseGraphics();
 		ImplFindPaperFormatForUserSize( aJobSetup );
 
@@ -1494,13 +1193,6 @@ BOOL Printer::SetPaperSizeUser( const Si
 		if ( mpInfoPrinter->SetData( SAL_JOBSET_PAPERSIZE|SAL_JOBSET_ORIENTATION, pSetupData ) )
 		{
 			ImplUpdateJobSetupPaper( aJobSetup );
-#else
-		RmJobSetup aRmJobSetup;
-        aJobSetup.SetRmJobSetup( aRmJobSetup );
-        if ( mpInfoPrinter->SetPaperSizeUser( aPageSize.Width(), aPageSize.Height(), aRmJobSetup ) )
-		{
-            aJobSetup = aRmJobSetup;
-#endif
 			mbNewJobSetup = TRUE;
 			maJobSetup = aJobSetup;
 			ImplUpdatePageData();
@@ -1611,14 +1303,7 @@ USHORT Printer::GetPaperBinCount() const
 	if ( IsDisplayPrinter() )
 		return 0;
 
-#ifndef REMOTE_APPSERVER
 	return (USHORT)mpInfoPrinter->GetPaperBinCount( maJobSetup.ImplGetConstData() );
-#else
-	if ( mpInfoPrinter )
-		return mpInfoPrinter->GetPaperBinCount();
-	else
-		return 0;
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -1628,17 +1313,10 @@ XubString Printer::GetPaperBinName( USHO
 	if ( IsDisplayPrinter() )
 		return ImplGetSVEmptyStr();
 
-#ifndef REMOTE_APPSERVER
 	if ( nPaperBin < GetPaperBinCount() )
 		return mpInfoPrinter->GetPaperBinName( maJobSetup.ImplGetConstData(), nPaperBin );
 	else
 		return ImplGetSVEmptyStr();
-#else
-	if ( mpInfoPrinter )
-		return (String)mpInfoPrinter->GetPaperBinName( nPaperBin );
-	else
-		return ImplGetSVEmptyStr();
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -1679,7 +1357,6 @@ void Printer::PrintPage()
 
 // -----------------------------------------------------------------------
 
-#ifndef REMOTE_APPSERVER
 
 ULONG ImplSalPrinterErrorCodeToVCL( ULONG nError )
 {
@@ -1724,10 +1401,6 @@ IMPL_LINK( Printer, ImplDestroyPrinterAs
 
 // -----------------------------------------------------------------------
 
-#endif
-
-// -----------------------------------------------------------------------
-
 BOOL Printer::StartJob( const XubString& rJobName )
 {
 	mnError = PRINTER_OK;
@@ -1738,7 +1411,6 @@ BOOL Printer::StartJob( const XubString&
 	if ( IsJobActive() || IsPrinting() )
 		return FALSE;
 
-#ifndef REMOTE_APPSERVER
 	ULONG	nCopies = mnCopyCount;
 	BOOL	bCollateCopy = mbCollateCopy;
 	BOOL	bUserCopy = FALSE;
@@ -1836,14 +1508,6 @@ BOOL Printer::StartJob( const XubString&
 			return FALSE;
 		}
 	}
-#else
-    mbNewJobSetup	= FALSE;
-    maJobName		= rJobName;
-    mnCurPage		= 1;
-    mnCurPrintPage	= 1;
-    mbJobActive 	= TRUE;
-    mbPrinting		= TRUE;
-#endif
 
 	return TRUE;
 }
@@ -1859,7 +1523,6 @@ BOOL Printer::EndJob()
 
 	mbJobActive = FALSE;
 
-#ifndef REMOTE_APPSERVER
 	if ( mpPrinter || mpQPrinter )
 	{
 		ImplReleaseGraphics();
@@ -1886,75 +1549,6 @@ BOOL Printer::EndJob()
 
 		return TRUE;
 	}
-#else
-	ImplSVData* pSVData = ImplGetSVData();
-    sal_Bool bResult = sal_False;
-
-    try
-    {
-        mpPrinter = new RmPrinter();
-        mpPrinter->mxRemotePrinter = REF( XRmPrinter )( pSVData->mxClientFactory->createInstance( ::rtl::OUString::createFromAscii( "OfficePrinter.stardiv.de" ) ), NMSP_UNO::UNO_QUERY );
-        RmJobSetup aRmJobSetup;
-        maJobSetup.SetRmJobSetup( aRmJobSetup );
-        mpPrinter->CreatePrintInstance( aRmJobSetup );
-        if( mpPrinter->mxRemotePrinter.is() )
-        {
-            RmPageRequestor* pRequestor = new RmPageRequestor( this );
-            Reference< XRmPageRequestor > xReq( pRequestor );
-            CHECK_FOR_RVPSYNC_NORMAL();
-            bResult = mpPrinter->mxRemotePrinter->StartJob( mnCopyCount,
-                                                            mbCollateCopy,
-                                                            maJobName,
-                                                            maPrintFile,
-                                                            mbPrintFile,
-                                                            mpRemotePages->size(),
-                                                            xReq );
-            if( bResult )
-                do Application::Reschedule(); while( mbPrinting && ! pRequestor->isCompleted() );
-        }
-    }
-    catch( RuntimeException &e )
-    {
-        rvpExceptionHandler();
-        bResult = FALSE;
-        if( mpPrinter )
-        {
-            delete mpPrinter;
-            mpPrinter = NULL;
-        }
-    }
-
-    for( int i = 0; i < mpRemotePages->size(); i++ )
-        delete (*mpRemotePages)[i];
-    *mpRemotePages = ::std::vector< PrinterPage* >();
-
-	if ( mpPrinter )
-	{
-        if( bResult )
-        {
-            CHECK_FOR_RVPSYNC_NORMAL();
-            try
-            {
-                mpPrinter->mxRemotePrinter->EndJob( vcl::unohelper::GetMultiServiceFactory() );
-            }
-            catch( RuntimeException &e )
-            {
-                rvpExceptionHandler();
-            }
-        }
-		mbPrinting = FALSE;
-        mbDevOutput = FALSE;
-		mnCurPage = 0;
-		mnCurPrintPage = 0;
-		maJobName.Erase();
-		EndPrint();
-
-		delete mpPrinter;
-		mpPrinter = NULL;
-
-		return bResult;
-	}
-#endif
 
 	return FALSE;
 }
@@ -1972,7 +1566,6 @@ BOOL Printer::AbortJob()
 	mbInPrintPage	= FALSE;
 	mpJobGraphics	= NULL;
 
-#ifndef REMOTE_APPSERVER
 	if ( mpPrinter || mpQPrinter )
 	{
 		mbPrinting		= FALSE;
@@ -2005,33 +1598,6 @@ BOOL Printer::AbortJob()
 
 		return TRUE;
 	}
-#else
-    mbPrinting		= FALSE;
-    mbDevOutput		= FALSE;
-    mnCurPage		= 0;
-    mnCurPrintPage	= 0;
-    maJobName.Erase();
-    if( mpPrinter )
-    {
-        if( mpPrinter->mxRemotePrinter.is() )
-        {
-            CHECK_FOR_RVPSYNC_NORMAL();
-            try
-            {
-                mpPrinter->mxRemotePrinter->AbortJob();
-            }
-            catch( RuntimeException &e )
-            {
-                rvpExceptionHandler();
-            }
-        }
-        delete mpPrinter;
-        mpPrinter = NULL;
-    }
-    EndPrint();
-
-    return TRUE;
-#endif
 
 	return FALSE;
 }
@@ -2043,7 +1609,6 @@ BOOL Printer::StartPage()
 	if ( !IsJobActive() )
 		return FALSE;
 
-#ifndef REMOTE_APPSERVER
 	if ( mpPrinter || mpQPrinter )
 	{
 		if ( mpPrinter )
@@ -2083,18 +1648,6 @@ BOOL Printer::StartPage()
 
 		return TRUE;
 	}
-#else
-		mpQMtf = new GDIMetaFile;
-		mpQMtf->Record( this );
-		mpQMtf->SaveStatus();
-
-		mbInPrintPage = TRUE;
-		mnCurPage++;
-		mnCurPrintPage++;
-		PrintPage();
-
-		return TRUE;
-#endif
 
 	return FALSE;
 }
@@ -2108,7 +1661,6 @@ BOOL Printer::EndPage()
 
 	mbInPrintPage = FALSE;
 
-#ifndef REMOTE_APPSERVER
 	if ( mpPrinter || mpQPrinter )
 	{
 		if ( mpPrinter )
@@ -2132,109 +1684,6 @@ BOOL Printer::EndPage()
 
 		return TRUE;
 	}
-#else
-    mpQMtf->Stop();
-    mpQMtf->WindStart();
-    mpRemotePages->push_back( new PrinterPage( mpQMtf, mbNewJobSetup, GetJobSetup() ) );
-    mpQMtf = NULL;
-    mbNewJobSetup = FALSE;
-
-    return TRUE;
-#endif
 
 	return FALSE;
 }
-
-#ifdef REMOTE_APPSERVER
-void Printer::GetRemotePageSetup( ULONG nPage, RmJobSetup& rSetup )
-{
-    if( nPage < mpRemotePages->size() )
-        (*mpRemotePages)[nPage]->GetJobSetup().SetRmJobSetup( rSetup );
-}
-
-void Printer::PrintRemotePage( ULONG nPage )
-{
-#if OSL_DEBUG_LEVEL > 1
-    fprintf( stderr, "printing page %d of %d\n", nPage, mpRemotePages->size() );
-#endif
-	if ( mpPrinter && mpPrinter->mxRemotePrinter.is() )
-	{
-#if OSL_DEBUG_LEVEL > 1
-        fprintf( stderr, "have printer\n", nPage );
-#endif
-        if( nPage >=  mpRemotePages->size() )
-        {
-            try
-            {
-                CHECK_FOR_RVPSYNC_NORMAL();
-                mpPrinter->mxRemotePrinter->StartPage();
-                CHECK_FOR_RVPSYNC_NORMAL();
-                mpPrinter->mxRemotePrinter->EndPage();
-            }
-            catch( RuntimeException &e )
-            {
-                rvpExceptionHandler();
-            }
-            return;
-        }
-
-        if( mpGraphics ) {
-            REF( XRmOutputDevice ) aTmp;
-            mpGraphics->SetInterface( aTmp );
-            delete mpGraphics;
-        }
-
-        PrinterPage* pPage = (*mpRemotePages)[nPage];
-
-		CHECK_FOR_RVPSYNC_NORMAL();
-        try
-        {
-            mpPrinter->mxRemotePrinter->StartPage();
-#if OSL_DEBUG_LEVEL > 1
-            fprintf( stderr, "page started\n" );
-#endif
-        }
-        catch( RuntimeException &e )
-        {
-#if OSL_DEBUG_LEVEL > 1
-            fprintf( stderr, "page started exception\n" );
-#endif
-            rvpExceptionHandler();
-        }
-
-        mpGraphics = new ImplServerGraphics( ImplGetSVData()->mpAtoms );
-		Reference< XRmOutputDevice > temp( mpPrinter->mxRemotePrinter, UNO_QUERY );
-        mpGraphics->SetInterface( temp );
-
-        mbDevOutput		= TRUE;
-		mbInPrintPage	= TRUE;
-		mnCurPage		= nPage;
-		mnCurPrintPage	= nPage;
-
-        pPage->GetGDIMetaFile()->WindStart();
-        pPage->GetGDIMetaFile()->Play( this );
-
-#if OSL_DEBUG_LEVEL > 1
-            fprintf( stderr, "metafile played %d actions\n", pPage->GetGDIMetaFile()->GetActionCount() );
-#endif
-
-		CHECK_FOR_RVPSYNC_NORMAL();
-        try
-        {
-		    mpPrinter->mxRemotePrinter->EndPage();
-#if OSL_DEBUG_LEVEL > 1
-            fprintf( stderr, "page ended\n" );
-#endif
-        }
-        catch( RuntimeException &e )
-        {
-#if OSL_DEBUG_LEVEL > 1
-            fprintf( stderr, "page ended exception\n" );
-#endif
-            rvpExceptionHandler();
-        }
-        mbDevOutput = FALSE;
-		mbNewJobSetup = FALSE;
-	}
-}
-#endif
Index: vcl/source/gdi/print2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/print2.cxx,v
retrieving revision 1.17.82.1
retrieving revision 1.19
diff -u -p -u -r1.17.82.1 -r1.19
--- vcl/source/gdi/print2.cxx	9 Jan 2004 18:13:47 -0000	1.17.82.1
+++ vcl/source/gdi/print2.cxx	6 Jan 2004 13:53:54 -0000	1.19
@@ -59,7 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_PRINT_CXX
 #define _SPOOLPRINTER_EXT
 
 #include <functional>
@@ -604,9 +603,6 @@ struct ConnectedComponents
 typedef ::std::list< ConnectedComponents > ConnectedComponentsList;	
 
 // remove comment to enable highlighting of generated output
-#ifdef DBG_UTIL
-//#define DEBUG_GetPreparedMetaFile
-#endif
 
 void Printer::GetPreparedMetaFile( const GDIMetaFile& rInMtf, GDIMetaFile& rOutMtf, 
                                    long nMaxBmpDPIX, long nMaxBmpDPIY )
@@ -1041,10 +1037,6 @@ void Printer::GetPreparedMetaFile( const
                                                                       aBandBmp, nMaxBmpDPIX, nMaxBmpDPIY );
                                     }
 
-#ifdef DEBUG_GetPreparedMetaFile
-                                    //aBandBmp.Invert();
-#endif
-
                                     rOutMtf.AddAction( new MetaCommentAction( "PRNSPOOL_TRANSPARENTBITMAP_BEGIN" ) );
                                     rOutMtf.AddAction( new MetaBmpScaleAction( aDstPtPix, aDstSzPix, aBandBmp ) );
                                     rOutMtf.AddAction( new MetaCommentAction( "PRNSPOOL_TRANSPARENTBITMAP_END" ) );
@@ -1140,20 +1132,6 @@ void Printer::GetPreparedMetaFile( const
 
         rOutMtf.SetPrefMapMode( rInMtf.GetPrefMapMode() );
         rOutMtf.SetPrefSize( rInMtf.GetPrefSize() );
-
-#ifdef DEBUG_GetPreparedMetaFile
-        // iterate over all aCCList members and generate rectangles for the bounding boxes
-        rOutMtf.AddAction( new MetaFillColorAction( COL_WHITE, FALSE ) );
-        for( aCurr = aCCList.begin(); aCurr != aLast; ++aCurr )
-        {
-            if( aCurr->bIsSpecial )
-                rOutMtf.AddAction( new MetaLineColorAction( COL_RED, TRUE) );
-            else
-                rOutMtf.AddAction( new MetaLineColorAction( COL_BLUE, TRUE) );
-
-            rOutMtf.AddAction( new MetaRectAction( aMapModeVDev.PixelToLogic( aCurr->aBounds ) ) );
-        }
-#endif
 	}
 }
 
Index: vcl/source/gdi/regband.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/regband.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/regband.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/regband.cxx	6 Jan 2004 13:54:21 -0000	1.2
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_REGBAND_CXX
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -633,7 +631,6 @@ void ImplRegionBand::XOr( long nXLeft, l
 		//	 -> reduce boundaries of new separation
 		if ( (nXLeft <= pSep->mnXLeft) && (nXRight >= pSep->mnXRight) )
 		{
-			int iOldXRight = pSep->mnXRight;
 			pSep->mnXRight = pSep->mnXLeft;
 			pSep->mnXLeft = nXLeft;
 			nXLeft = pSep->mnXRight;
@@ -644,7 +641,6 @@ void ImplRegionBand::XOr( long nXLeft, l
 		//	 -> set boundaries of new separation to right remainder
 		if ( (nXRight >= pSep->mnXLeft) && (nXLeft <= pSep->mnXLeft) )
 		{
-			int iOldXRight = pSep->mnXRight;
 			pSep->mnXRight = pSep->mnXLeft;
 			pSep->mnXLeft = nXLeft;
 			nXLeft = pSep->mnXRight;
Index: vcl/source/gdi/region.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/region.cxx,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -p -u -r1.3 -r1.6
--- vcl/source/gdi/region.cxx	30 Sep 2002 17:28:03 -0000	1.3
+++ vcl/source/gdi/region.cxx	4 Feb 2004 14:42:24 -0000	1.6
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_REGION_CXX
-
 #include <limits.h>
 
 #ifndef _VCOMPAT_HXX
@@ -2202,49 +2200,6 @@ SvStream& operator<<( SvStream& rOStrm, 
 
 // -----------------------------------------------------------------------
 
-RegionOverlapType Region::GetOverlapType( const Rectangle& rRect ) const
-{
-	DBG_CHKTHIS( Region, ImplDbgTestRegion );
-
-	// is rectangle empty? -> not inside
-	if ( rRect.IsEmpty() )
-		return REGION_OUTSIDE;
-
-	((Region*)this)->ImplPolyPolyRegionToBandRegion();
-
-	// no instance data? -> not inside
-	if ( (mpImplRegion == &aImplEmptyRegion) || (mpImplRegion == &aImplNullRegion) )
-		return REGION_OUTSIDE;
-
-	// resolve pointer
-	ImplRegionBand* 	pBand	= mpImplRegion->mpFirstBand;
-	ImplRegionBandSep*	pSep	= pBand->mpFirstSep;
-
-	// complex region? don't check for now. This may change in the future...
-	if ( pBand->mpNextBand || pSep->mpNextSep )
-		return REGION_OVER;
-
-	// get justified rectangle
-	long nLeft		= Min( rRect.Left(), rRect.Right() );
-	long nTop		= Min( rRect.Top(), rRect.Bottom() );
-	long nRight 	= Max( rRect.Left(), rRect.Right() );
-	long nBottom	= Max( rRect.Top(), rRect.Bottom() );
-
-	// check rectangle region
-	BOOL boLeft   = (nLeft >= pSep->mnXLeft) && (nLeft < pSep->mnXRight);
-	BOOL boRight  = (nRight <= pSep->mnXRight) && (nRight > pSep->mnXLeft);
-	BOOL boTop	  = (nTop >= pBand->mnYTop) && (nTop < pBand->mnYBottom);
-	BOOL boBottom = (nBottom <= pBand->mnYBottom) && (nBottom > pBand->mnYTop);
-	if ( boLeft && boRight && boTop && boBottom )
-		return REGION_INSIDE;
-	if ( boLeft || boRight || boTop || boBottom )
-		return REGION_OVER;
-
-	return REGION_OUTSIDE;
-}
-
-// -----------------------------------------------------------------------
-
 void Region::ImplBeginAddRect()
 {
 	DBG_CHKTHIS( Region, ImplDbgTestRegion );
@@ -2440,13 +2395,13 @@ RegionHandle Region::BeginEnumRects()
 
 	// no internal data? -> region is empty!
 	if ( (mpImplRegion == &aImplEmptyRegion) || (mpImplRegion == &aImplNullRegion) )
-		return NULL;
+		return 0;
 
 	// no band in the list? -> region is empty!
 	if ( mpImplRegion->mpFirstBand == NULL )
 	{
 		DBG_ASSERT( mpImplRegion->mpFirstBand, "Region::BeginEnumRects() First Band is Empty!" );
-		return NULL;
+		return 0;
 	}
 
 	ImplRegionHandle* pData = new ImplRegionHandle;
Index: vcl/source/gdi/salgdilayout.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/salgdilayout.cxx,v
retrieving revision 1.12
retrieving revision 1.17
diff -u -p -u -r1.12 -r1.17
--- vcl/source/gdi/salgdilayout.cxx	27 Mar 2003 17:58:03 -0000	1.12
+++ vcl/source/gdi/salgdilayout.cxx	10 May 2004 15:49:10 -0000	1.17
@@ -59,15 +59,11 @@
  *
  ************************************************************************/
 
-#define _SV_OUTDEV_CXX
 #include <tools/ref.hxx>
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
@@ -80,11 +76,6 @@
 #ifndef _SV_SALPRN_HXX
 #include <salprn.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
@@ -95,7 +86,7 @@
 #ifndef _SV_SVAPP_HXX
 #include <svapp.hxx>
 #endif
-#ifndef _POLY_HXX
+#ifndef _TL_POLY_HXX
 #include <tools/poly.hxx>
 #endif
 #ifndef _SV_REGION_HXX
@@ -149,9 +140,9 @@
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
 #endif
+#undef private
 
-#define IS_NOTRTL_ENABLED() ( pOutDev && !pOutDev->IsRTLEnabled() )
-
+//#define USE_NEW_RTL_IMPLEMENTATION
 
 // ----------------------------------------------------------------------------
 // The only common SalFrame method
@@ -174,68 +165,80 @@ SalFrameGeometry SalFrame::GetGeometry()
 
 // ----------------------------------------------------------------------------
 
-SalGraphicsLayout::SalGraphicsLayout() : SalGraphics()
+SalGraphics::SalGraphics() 
+        : m_nLayout( 0 )
 {
     // read global RTL settings
     if( Application::GetSettings().GetLayoutRTL() )
-	    mnLayout = SAL_LAYOUT_BIDI_RTL;
-    else
-        mnLayout = 0;
+	    m_nLayout = SAL_LAYOUT_BIDI_RTL;
 }
 
-SalGraphicsLayout::~SalGraphicsLayout()
+SalGraphics::~SalGraphics()
 {
 }
 
 // ----------------------------------------------------------------------------
 
-void SalGraphicsLayout::mirror( long& x, const OutputDevice *pOutDev )
+void SalGraphics::mirror( long& x, const OutputDevice *pOutDev )
 {
 	long w;
-    if( pOutDev && pOutDev->meOutDevType == OUTDEV_VIRDEV )
-        w = pOutDev->mnOutWidth;
+    if( pOutDev && pOutDev->GetOutDevType() == OUTDEV_VIRDEV )
+        w = pOutDev->GetOutputWidthPixel();
     else
         w = GetGraphicsWidth();
 
 	if( w )
     {
-		x = w-1-x;
-
         if( pOutDev && !pOutDev->IsRTLEnabled() )
         {
+            OutputDevice *pOutDevRef = (OutputDevice*) pOutDev;
+#ifdef USE_NEW_RTL_IMPLEMENTATION
+            if( pOutDev->meOutDevType == OUTDEV_WINDOW )
+                pOutDevRef = (OutputDevice*) ((Window *) pOutDev)->mpDummy4; // top of non-mirroring hierarchy
+#endif
+
             // mirror this window back
-            long devX = w-pOutDev->mnOutWidth-pOutDev->mnOutOffX;   // re-mirrored mnOutOffX
-            x = devX + ( pOutDev->mnOutWidth - 1 - (x - devX) ) ;
+            long devX = w-pOutDevRef->GetOutputWidthPixel()-pOutDevRef->GetOutOffXPixel();   // re-mirrored mnOutOffX
+            x = devX + (x - pOutDevRef->GetOutOffXPixel());
         }
+        else
+		    x = w-1-x;
     }
 }
 
-void SalGraphicsLayout::mirror( long& x, long& nWidth, const OutputDevice *pOutDev )
+void SalGraphics::mirror( long& x, long& nWidth, const OutputDevice *pOutDev )
 {
 	long w;
-    if( pOutDev && pOutDev->meOutDevType == OUTDEV_VIRDEV )
-        w = pOutDev->mnOutWidth;
+    if( pOutDev && pOutDev->GetOutDevType() == OUTDEV_VIRDEV )
+        w = pOutDev->GetOutputWidthPixel();
     else
         w = GetGraphicsWidth();
 
 	if( w )
     {
-		x = w-nWidth-x;
-
         if( pOutDev && !pOutDev->IsRTLEnabled() )
         {
+            OutputDevice *pOutDevRef = (OutputDevice*) pOutDev;
+#ifdef USE_NEW_RTL_IMPLEMENTATION
+            if( pOutDev->meOutDevType == OUTDEV_WINDOW )
+                pOutDevRef = (OutputDevice*) ((Window *) pOutDev)->mpDummy4; // top of non-mirroring hierarchy
+#endif
+
             // mirror this window back
-            long devX = w-pOutDev->mnOutWidth-pOutDev->mnOutOffX;   // re-mirrored mnOutOffX
-            x = devX + ( pOutDev->mnOutWidth - nWidth - (x - devX) ) ;
+            long devX = w-pOutDevRef->GetOutputWidthPixel()-pOutDevRef->GetOutOffXPixel();   // re-mirrored mnOutOffX
+            x = devX + (x - pOutDevRef->GetOutOffXPixel());
         }
+        else
+		    x = w-nWidth-x;
+
     }
 }
 
-BOOL SalGraphicsLayout::mirror( sal_uInt32 nPoints, const SalPoint *pPtAry, SalPoint *pPtAry2, const OutputDevice *pOutDev )
+BOOL SalGraphics::mirror( sal_uInt32 nPoints, const SalPoint *pPtAry, SalPoint *pPtAry2, const OutputDevice *pOutDev )
 {
 	long w;
-    if( pOutDev && pOutDev->meOutDevType == OUTDEV_VIRDEV )
-        w = pOutDev->mnOutWidth;
+    if( pOutDev && pOutDev->GetOutDevType() == OUTDEV_VIRDEV )
+        w = pOutDev->GetOutputWidthPixel();
     else
         w = GetGraphicsWidth();
 
@@ -245,12 +248,19 @@ BOOL SalGraphicsLayout::mirror( sal_uInt
 
         if( pOutDev && !pOutDev->IsRTLEnabled() )
         {
+            OutputDevice *pOutDevRef = (OutputDevice*) pOutDev;
+#ifdef USE_NEW_RTL_IMPLEMENTATION
+            if( pOutDev->meOutDevType == OUTDEV_WINDOW )
+                pOutDevRef = (OutputDevice*) ((Window *) pOutDev)->mpDummy4; // top of non-mirroring hierarchy
+#endif
+
             // mirror this window back
-            long devX = w-pOutDev->mnOutWidth-pOutDev->mnOutOffX;   // re-mirrored mnOutOffX
+            long devX = w-pOutDevRef->GetOutputWidthPixel()-pOutDevRef->GetOutOffXPixel();   // re-mirrored mnOutOffX
 		    for( i=0, j=nPoints-1; i<nPoints; i++,j-- )
 		    {
-			    long x = w-1-pPtAry[i].mnX;
-			    pPtAry2[j].mnX = devX + ( pOutDev->mnOutWidth - 1 - (x - devX) );
+			    //long x = w-1-pPtAry[i].mnX;
+			    //pPtAry2[j].mnX = devX + ( pOutDevRef->mnOutWidth - 1 - (x - devX) );
+			    pPtAry2[j].mnX = devX + (pPtAry[i].mnX - pOutDevRef->GetOutOffXPixel());
 			    pPtAry2[j].mnY = pPtAry[i].mnY;
 		    }
         }
@@ -268,69 +278,81 @@ BOOL SalGraphicsLayout::mirror( sal_uInt
 		return FALSE;
 }
 
+void SalGraphics::mirror( Region& rRgn, const OutputDevice *pOutDev )
+{
+    // mirror the bounding rect and move Region by resulting offset
+    Rectangle aRect( rRgn.GetBoundRect() );
+    long nWidth = aRect.GetWidth();
+    long x      = aRect.Left();
+    long x_org = x;
+
+    mirror( x, nWidth, pOutDev );
+    rRgn.Move( x - x_org, 0 );
+}
+
 // ----------------------------------------------------------------------------
 
-BOOL	SalGraphicsLayout::UnionClipRegion( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
+BOOL	SalGraphics::UnionClipRegion( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, nWidth, pOutDev );
-	return SalGraphics::UnionClipRegion( nX, nY, nWidth, nHeight, NULL );
+	return unionClipRegion( nX, nY, nWidth, nHeight );
 }
 
-void	SalGraphicsLayout::DrawPixel( long nX, long nY, const OutputDevice *pOutDev )
+void	SalGraphics::DrawPixel( long nX, long nY, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, pOutDev );
-	SalGraphics::DrawPixel( nX, nY, NULL );
+	drawPixel( nX, nY );
 }
-void	SalGraphicsLayout::DrawPixel( long nX, long nY, SalColor nSalColor, const OutputDevice *pOutDev )
+void	SalGraphics::DrawPixel( long nX, long nY, SalColor nSalColor, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, pOutDev );
-	SalGraphics::DrawPixel( nX, nY, nSalColor, NULL );
+	drawPixel( nX, nY, nSalColor );
 }
-void	SalGraphicsLayout::DrawLine( long nX1, long nY1, long nX2, long nY2, const OutputDevice *pOutDev )
+void	SalGraphics::DrawLine( long nX1, long nY1, long nX2, long nY2, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		mirror( nX1, pOutDev );
 		mirror( nX2, pOutDev );
 	}
-	SalGraphics::DrawLine( nX1, nY1, nX2, nY2, NULL );
+	drawLine( nX1, nY1, nX2, nY2 );
 }
-void	SalGraphicsLayout::DrawRect( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
+void	SalGraphics::DrawRect( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, nWidth, pOutDev );
-	SalGraphics::DrawRect( nX, nY, nWidth, nHeight, NULL );
+	drawRect( nX, nY, nWidth, nHeight );
 }
-void	SalGraphicsLayout::DrawPolyLine( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev )
+void	SalGraphics::DrawPolyLine( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalPoint* pPtAry2 = new SalPoint[nPoints];
 		BOOL bCopied = mirror( nPoints, pPtAry, pPtAry2, pOutDev ); 
-		SalGraphics::DrawPolyLine( nPoints, bCopied ? pPtAry2 : pPtAry, NULL );
+		drawPolyLine( nPoints, bCopied ? pPtAry2 : pPtAry );
 		delete [] pPtAry2;
 	}
 	else
-		SalGraphics::DrawPolyLine( nPoints, pPtAry, NULL );
+		drawPolyLine( nPoints, pPtAry );
 }
-void	SalGraphicsLayout::DrawPolygon( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev )
+void	SalGraphics::DrawPolygon( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalPoint* pPtAry2 = new SalPoint[nPoints];
 		BOOL bCopied = mirror( nPoints, pPtAry, pPtAry2, pOutDev ); 
-		SalGraphics::DrawPolygon( nPoints, bCopied ? pPtAry2 : pPtAry, NULL );
+		drawPolygon( nPoints, bCopied ? pPtAry2 : pPtAry );
 		delete [] pPtAry2;
 	}
 	else
-		SalGraphics::DrawPolygon( nPoints, pPtAry, NULL );
+		drawPolygon( nPoints, pPtAry );
 }
-void	SalGraphicsLayout::DrawPolyPolygon( ULONG nPoly, const ULONG* pPoints, PCONSTSALPOINT* pPtAry, const OutputDevice *pOutDev )
+void	SalGraphics::DrawPolyPolygon( ULONG nPoly, const ULONG* pPoints, PCONSTSALPOINT* pPtAry, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
         // TODO: optimize, reduce new/delete calls
         SalPoint **pPtAry2 = new SalPoint*[nPoly];
@@ -339,148 +361,213 @@ void	SalGraphicsLayout::DrawPolyPolygon(
         {
             ULONG nPoints = pPoints[i];
             pPtAry2[i] = new SalPoint[ nPoints ];
-		    BOOL bCopied = mirror( nPoints, pPtAry[i], pPtAry2[i], pOutDev ); 
+		    mirror( nPoints, pPtAry[i], pPtAry2[i], pOutDev ); 
         }
 
-        SalGraphics::DrawPolyPolygon( nPoly, pPoints, (PCONSTSALPOINT*)pPtAry2, NULL );
+        drawPolyPolygon( nPoly, pPoints, (PCONSTSALPOINT*)pPtAry2 );
 
         for(i=0; i<nPoly; i++)
             delete [] pPtAry2[i];
         delete [] pPtAry2;
     }
     else
-	    SalGraphics::DrawPolyPolygon( nPoly, pPoints, pPtAry, NULL );
+	    drawPolyPolygon( nPoly, pPoints, pPtAry );
 }
-sal_Bool SalGraphicsLayout::DrawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev )
+sal_Bool SalGraphics::DrawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev )
 {
-    DBG_ASSERT( !(mnLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolyLineBezier - no mirroring implemented"); 
-    return SalGraphics::DrawPolyLineBezier( nPoints, pPtAry, pFlgAry, NULL );
+    DBG_ASSERT( !(m_nLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolyLineBezier - no mirroring implemented"); 
+    return drawPolyLineBezier( nPoints, pPtAry, pFlgAry );
 }
-sal_Bool SalGraphicsLayout::DrawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev )
+sal_Bool SalGraphics::DrawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice *pOutDev )
 {
-    DBG_ASSERT( !(mnLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolygonBezier - no mirroring implemented"); 
-    return SalGraphics::DrawPolygonBezier( nPoints, pPtAry, pFlgAry, NULL );
+    DBG_ASSERT( !(m_nLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolygonBezier - no mirroring implemented"); 
+    return drawPolygonBezier( nPoints, pPtAry, pFlgAry );
 }
-sal_Bool SalGraphicsLayout::DrawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
+sal_Bool SalGraphics::DrawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
                                                    const SalPoint* const* pPtAry, const BYTE* const* pFlgAry, const OutputDevice *pOutDev )
 {
-    DBG_ASSERT( !(mnLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolyPolygonBezier - no mirroring implemented"); 
-    return SalGraphics::DrawPolyPolygonBezier( nPoly, pPoints, pPtAry, pFlgAry, NULL );
+    DBG_ASSERT( !(m_nLayout & SAL_LAYOUT_BIDI_RTL), "DrawPolyPolygonBezier - no mirroring implemented"); 
+    return drawPolyPolygonBezier( nPoly, pPoints, pPtAry, pFlgAry );
 }
-void	SalGraphicsLayout::CopyArea( long nDestX, long nDestY,
-								  long nSrcX, long nSrcY,
-								  long nSrcWidth, long nSrcHeight,
-								  USHORT nFlags, const OutputDevice *pOutDev )
+void	SalGraphics::CopyArea( long nDestX, long nDestY,
+                               long nSrcX, long nSrcY,
+                               long nSrcWidth, long nSrcHeight,
+                               USHORT nFlags, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		mirror( nDestX, nSrcWidth, pOutDev );
 		mirror( nSrcX, nSrcWidth, pOutDev );
 	}
-	SalGraphics::CopyArea( nDestX, nDestY, nSrcX, nSrcY, nSrcWidth, nSrcHeight, nFlags, NULL );
+	copyArea( nDestX, nDestY, nSrcX, nSrcY, nSrcWidth, nSrcHeight, nFlags );
 }
-void	SalGraphicsLayout::CopyBits( const SalTwoRect* pPosAry,
-								  SalGraphics* pSrcGraphics, const OutputDevice *pOutDev, const OutputDevice *pSrcOutDev )
+void	SalGraphics::CopyBits( const SalTwoRect* pPosAry,
+                               SalGraphics* pSrcGraphics, const OutputDevice *pOutDev, const OutputDevice *pSrcOutDev )
 {
-	if( ( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) || 
+	if( ( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) || 
         (pSrcGraphics && (pSrcGraphics->GetLayout() & SAL_LAYOUT_BIDI_RTL) ) )
 	{
 		SalTwoRect pPosAry2 = *pPosAry;
 		if( pSrcGraphics && (pSrcGraphics->GetLayout() & SAL_LAYOUT_BIDI_RTL) )
 			mirror( pPosAry2.mnSrcX, pPosAry2.mnSrcWidth, pSrcOutDev ); 
-		if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+		if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 			mirror( pPosAry2.mnDestX, pPosAry2.mnDestWidth, pOutDev ); 
-		SalGraphics::CopyBits( &pPosAry2, pSrcGraphics, NULL, NULL );
+		copyBits( &pPosAry2, pSrcGraphics );
 	}
 	else
-		SalGraphics::CopyBits( pPosAry, pSrcGraphics, NULL, NULL );
+		copyBits( pPosAry, pSrcGraphics );
 }
-void	SalGraphicsLayout::DrawBitmap( const SalTwoRect* pPosAry,
+void	SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
 									const SalBitmap& rSalBitmap, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalTwoRect pPosAry2 = *pPosAry;
 		mirror( pPosAry2.mnDestX, pPosAry2.mnDestWidth, pOutDev ); 
-		SalGraphics::DrawBitmap( &pPosAry2, rSalBitmap, NULL );
+		drawBitmap( &pPosAry2, rSalBitmap );
 	}
 	else
-		SalGraphics::DrawBitmap( pPosAry, rSalBitmap, NULL );
+		drawBitmap( pPosAry, rSalBitmap );
 }
-void	SalGraphicsLayout::DrawBitmap( const SalTwoRect* pPosAry,
+void	SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
 									const SalBitmap& rSalBitmap,
 									SalColor nTransparentColor, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalTwoRect pPosAry2 = *pPosAry;
 		mirror( pPosAry2.mnDestX, pPosAry2.mnDestWidth, pOutDev ); 
-		SalGraphics::DrawBitmap( &pPosAry2, rSalBitmap, nTransparentColor, NULL );
+		drawBitmap( &pPosAry2, rSalBitmap, nTransparentColor );
 	}
 	else
-		SalGraphics::DrawBitmap( pPosAry, rSalBitmap, nTransparentColor, NULL );
+		drawBitmap( pPosAry, rSalBitmap, nTransparentColor );
 }
-void SalGraphicsLayout::DrawBitmap( const SalTwoRect* pPosAry,
-									const SalBitmap& rSalBitmap,
-									const SalBitmap& rTransparentBitmap, const OutputDevice *pOutDev )
+void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry,
+                              const SalBitmap& rSalBitmap,
+                              const SalBitmap& rTransparentBitmap, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalTwoRect pPosAry2 = *pPosAry;
 		mirror( pPosAry2.mnDestX, pPosAry2.mnDestWidth, pOutDev ); 
-		SalGraphics::DrawBitmap( &pPosAry2, rSalBitmap, rTransparentBitmap, NULL );
+		drawBitmap( &pPosAry2, rSalBitmap, rTransparentBitmap );
 	}
 	else
-		SalGraphics::DrawBitmap( pPosAry, rSalBitmap, rTransparentBitmap, NULL );
+		drawBitmap( pPosAry, rSalBitmap, rTransparentBitmap );
 }
-void	SalGraphicsLayout::DrawMask( const SalTwoRect* pPosAry,
+void	SalGraphics::DrawMask( const SalTwoRect* pPosAry,
 								  const SalBitmap& rSalBitmap,
 								  SalColor nMaskColor, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalTwoRect pPosAry2 = *pPosAry;
 		mirror( pPosAry2.mnDestX, pPosAry2.mnDestWidth, pOutDev ); 
-		SalGraphics::DrawMask( &pPosAry2, rSalBitmap, nMaskColor, NULL );
+		drawMask( &pPosAry2, rSalBitmap, nMaskColor );
 	}
 	else
-		SalGraphics::DrawMask( pPosAry, rSalBitmap, nMaskColor, NULL );
+		drawMask( pPosAry, rSalBitmap, nMaskColor );
 }
-SalBitmap*	SalGraphicsLayout::GetBitmap( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
+SalBitmap*	SalGraphics::GetBitmap( long nX, long nY, long nWidth, long nHeight, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, nWidth, pOutDev );
-	return SalGraphics::GetBitmap( nX, nY, nWidth, nHeight, NULL );
+	return getBitmap( nX, nY, nWidth, nHeight );
 }
-SalColor	SalGraphicsLayout::GetPixel( long nX, long nY, const OutputDevice *pOutDev )
+SalColor	SalGraphics::GetPixel( long nX, long nY, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, pOutDev );
-	return SalGraphics::GetPixel( nX, nY, NULL );
+	return getPixel( nX, nY );
 }
-void	SalGraphicsLayout::Invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags, const OutputDevice *pOutDev )
+void	SalGraphics::Invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, nWidth, pOutDev );
-	SalGraphics::Invert( nX, nY, nWidth, nHeight, nFlags, NULL );
+	invert( nX, nY, nWidth, nHeight, nFlags );
 }
-void	SalGraphicsLayout::Invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags, const OutputDevice *pOutDev )
+void	SalGraphics::Invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 	{
 		SalPoint* pPtAry2 = new SalPoint[nPoints];
 		BOOL bCopied = mirror( nPoints, pPtAry, pPtAry2, pOutDev ); 
-		SalGraphics::Invert( nPoints, bCopied ? pPtAry2 : pPtAry, nFlags, NULL );
+		invert( nPoints, bCopied ? pPtAry2 : pPtAry, nFlags );
 		delete [] pPtAry2;
 	}
 	else
-		SalGraphics::Invert( nPoints, pPtAry, nFlags, NULL );
+		invert( nPoints, pPtAry, nFlags );
 }
 
-BOOL	SalGraphicsLayout::DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice *pOutDev )
+BOOL	SalGraphics::DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice *pOutDev )
 {
-	if( (mnLayout & SAL_LAYOUT_BIDI_RTL) ) 
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) ) 
 		mirror( nX, nWidth, pOutDev );
-	return SalGraphics::DrawEPS( nX, nY, nWidth, nHeight,  pPtr, nSize, NULL );
+	return drawEPS( nX, nY, nWidth, nHeight,  pPtr, nSize );
 }
 
+BOOL SalGraphics::HitTestNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                const Point& aPos, SalControlHandle& rControlHandle, BOOL& rIsInside, const OutputDevice *pOutDev )
+{
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Point pt( aPos );
+        Region rgn( rControlRegion );
+        mirror( pt.X(), pOutDev );
+        mirror( rgn, pOutDev );
+        return hitTestNativeControl( nType, nPart, rgn, pt, rControlHandle, rIsInside );
+    }
+    else
+        return hitTestNativeControl( nType, nPart, rControlRegion, aPos, rControlHandle, rIsInside );
+}
+
+BOOL SalGraphics::DrawNativeControl( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                ControlState nState, const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+                                                OUString aCaption, const OutputDevice *pOutDev )
+{
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Region rgn( rControlRegion );
+        mirror( rgn, pOutDev );
+        return drawNativeControl( nType, nPart, rgn, nState, aValue, rControlHandle, aCaption );
+    }
+    else
+        return drawNativeControl( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+}
+
+BOOL SalGraphics::DrawNativeControlText( ControlType nType, ControlPart nPart, const Region& rControlRegion,
+                                                ControlState nState, const ImplControlValue& aValue,
+                                                SalControlHandle& rControlHandle, OUString aCaption, const OutputDevice *pOutDev )
+{
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Region rgn( rControlRegion );
+        mirror( rgn, pOutDev );
+        return drawNativeControlText( nType, nPart, rgn, nState, aValue, rControlHandle, aCaption );
+    }
+    else
+        return drawNativeControlText( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+}
+
+BOOL SalGraphics::GetNativeControlRegion( ControlType nType, ControlPart nPart, const Region& rControlRegion, ControlState nState,
+                                                const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption,
+                                                Region &rNativeBoundingRegion, Region &rNativeContentRegion, const OutputDevice *pOutDev )
+{
+	if( (m_nLayout & SAL_LAYOUT_BIDI_RTL) )
+    {
+        Region rgn( rControlRegion );
+        mirror( rgn, pOutDev );
+        if( getNativeControlRegion( nType, nPart, rgn, nState, aValue, rControlHandle, aCaption, 
+                                                rNativeBoundingRegion, rNativeContentRegion ) )
+        {
+            mirror( rNativeBoundingRegion, pOutDev );
+            mirror( rNativeContentRegion, pOutDev );
+            return TRUE;
+        }
+        else
+            return FALSE;
+    }
+    else
+        return getNativeControlRegion( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption, 
+                                                rNativeBoundingRegion, rNativeContentRegion );
+}
Index: vcl/source/gdi/sallayout.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/sallayout.cxx,v
retrieving revision 1.46.10.6
retrieving revision 1.58
diff -u -p -u -r1.46.10.6 -r1.58
--- vcl/source/gdi/sallayout.cxx	7 Apr 2004 11:02:20 -0000	1.46.10.6
+++ vcl/source/gdi/sallayout.cxx	17 Jun 2004 12:20:59 -0000	1.58
@@ -60,41 +60,33 @@
  ************************************************************************/
 
 #include <cstdio>
+
+#define _USE_MATH_DEFINES
 #include <math.h>
 
-#if defined(WIN32)
-#define M_PI 3.1415926536
-#include <malloc.h>
-#define alloca _alloca
-#elif defined(SOLARIS) || defined(IRIX)
-#include <alloca.h>
+#if defined(SOLARIS) || defined(IRIX)
+  #include <alloca.h>
+#else
+#ifndef MACOSX
+  #include <malloc.h>
+#endif
 #endif
 
-//#define _SV_OUTDEV_CXX
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
-#else
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#endif // REMOTE_APPSERVER
 
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
 #endif // _SV_SALLAYOUT_HXX
 
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
-#endif // _SV_POLY_HXX
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
+#endif
 
 #include <tools/lang.hxx>
 
@@ -133,13 +125,14 @@ sal_Unicode GetVerticalChar( sal_Unicode
 {
     return 0; // #i14788# input method is responsible vertical char changes
  
-    int nVert = 0;
+	int nVert = 0;
     switch( nChar )
     {
         // #104627# special treatment for some unicodes
         case 0x002C: nVert = 0x3001; break;
         case 0x002E: nVert = 0x3002; break;
-#if 0   // to few fonts have the compatibility forms, using
+		/*
+		// to few fonts have the compatibility forms, using
         // them will then cause more trouble than good
         // TODO: decide on a font specific basis
         case 0x2018: nVert = 0xFE41; break;
@@ -167,7 +160,7 @@ sal_Unicode GetVerticalChar( sal_Unicode
         case 0x300D: nVert = 0xFE42; break;
         case 0x300E: nVert = 0xFE43; break;
         case 0x300F: nVert = 0xFE44; break;
-#endif
+		*/
     }
 
     return nVert;
@@ -440,13 +433,14 @@ bool ImplLayoutRuns::GetRun( int* nMinRu
 
 ImplLayoutArgs::ImplLayoutArgs( const xub_Unicode* pStr, int nLength,
     int nMinCharPos, int nEndCharPos, int nFlags )
-:   mpStr( pStr ),
+:   
+    mnFlags( nFlags ),
     mnLength( nLength ),
     mnMinCharPos( nMinCharPos ),
     mnEndCharPos( nEndCharPos ),
-    mnFlags( nFlags ),
-    mnLayoutWidth( 0 ),
+    mpStr( pStr ),
     mpDXArray( NULL ),
+    mnLayoutWidth( 0 ),
     mnOrientation( 0 )
 {
     if( mnFlags & SAL_LAYOUT_BIDI_STRONG )
@@ -487,14 +481,13 @@ ImplLayoutArgs::ImplLayoutArgs( const xu
     for( int i = 0; i < nRunCount; ++i )
     {
         int32_t nMinPos, nLength;
-        UBiDiDirection nDir = ubidi_getVisualRun( pLineBidi, i, &nMinPos, &nLength );
+        ubidi_getVisualRun( pLineBidi, i, &nMinPos, &nLength );
         int nPos0 = nMinPos + mnMinCharPos;
         int nPos1 = nPos0 + nLength;
-#if 0
-        bool bRTL = (nDir == UBIDI_RTL);
-#else // workaround for #110273# (probably ICU problem TODO: analyze there)
+
+		// bool bRTL = (nDir == UBIDI_RTL);
+		// workaround for #110273# (probably ICU problem TODO: analyze there)
         bool bRTL = ((pParaLevels[ nPos0 ] & 1) != 0);
-#endif
 
         // remove control characters from runs by splitting them up
         if( !bRTL )
@@ -554,10 +547,10 @@ SalLayout::SalLayout()
 :   mnMinCharPos( -1 ),
     mnEndCharPos( -1 ),
     mnLayoutFlags( 0 ),
-    mnOrientation( 0 ),
-    maDrawOffset( 0, 0 ),
     mnUnitsPerPixel( 1 ),
-    mnRefCount( 1 )
+    mnOrientation( 0 ),
+    mnRefCount( 1 ),
+    maDrawOffset( 0, 0 )
 {}
 
 // -----------------------------------------------------------------------
@@ -673,12 +666,12 @@ bool SalLayout::GetOutline( SalGraphics&
     PolyPolygon aGlyphOutline;
     for( int nStart = 0;;)
     {
-        long nLGlyph;
+        sal_Int32 nLGlyph;
         if( !GetNextGlyphs( 1, &nLGlyph, aPos, nStart ) )
             break;
 
         // get outline of individual glyph, ignoring "empty" glyphs
-        bool bSuccess = rSalGraphics.GetGlyphOutline( nLGlyph, aGlyphOutline, NULL );
+        bool bSuccess = rSalGraphics.GetGlyphOutline( nLGlyph, aGlyphOutline );
         bRet &= bSuccess;
         // only add non-empty outlines
         if( bSuccess && (aGlyphOutline.Count() > 0) )
@@ -703,12 +696,12 @@ bool SalLayout::GetBoundRect( SalGraphic
     Rectangle aRectangle;
     for( int nStart = 0;;)
     {
-        long nLGlyph;
+        sal_Int32 nLGlyph;
         if( !GetNextGlyphs( 1, &nLGlyph, aPos, nStart ) )
             break;
 
         // get bounding rectangle of individual glyph
-        if( rSalGraphics.GetGlyphBoundRect( nLGlyph, aRectangle, NULL ) )
+        if( rSalGraphics.GetGlyphBoundRect( nLGlyph, aRectangle ) )
         {
             // merge rectangle
             aRectangle += aPos;
@@ -741,9 +734,10 @@ bool SalLayout::IsSpacingGlyph( long nGl
 // =======================================================================
 
 GenericSalLayout::GenericSalLayout()
-:   mnGlyphCount(0),
-    mnGlyphCapacity(0),
-    mpGlyphItems(0)
+:   mpGlyphItems(0),
+    mnGlyphCount(0),
+    mnGlyphCapacity(0)
+    
 {}
 
 // -----------------------------------------------------------------------
@@ -776,7 +770,7 @@ void GenericSalLayout::AppendGlyph( cons
 
 // -----------------------------------------------------------------------
 
-bool GenericSalLayout::GetCharWidths( long* pCharWidths ) const
+bool GenericSalLayout::GetCharWidths( sal_Int32* pCharWidths ) const
 {
     // initialize character extents buffer
     int nCharCount = mnEndCharPos - mnMinCharPos;
@@ -785,7 +779,6 @@ bool GenericSalLayout::GetCharWidths( lo
 
     // determine cluster extents
     const GlyphItem* pG = mpGlyphItems;
-    int nClusterIndex = 0;
     for( int i = mnGlyphCount; --i >= 0; ++pG )
     {
         // use cluster start to get char index
@@ -840,7 +833,7 @@ bool GenericSalLayout::GetCharWidths( lo
 
 // -----------------------------------------------------------------------
 
-long GenericSalLayout::FillDXArray( long* pCharWidths ) const
+long GenericSalLayout::FillDXArray( sal_Int32* pCharWidths ) const
 {
     if( pCharWidths )
         if( !GetCharWidths( pCharWidths ) )
@@ -915,7 +908,7 @@ void GenericSalLayout::ApplyDXArray( Imp
     }
 
     // calculate adjusted cluster widths
-    long* pNewGlyphWidths = (long*)alloca( mnGlyphCount * sizeof(long) );
+    sal_Int32* pNewGlyphWidths = (sal_Int32*)alloca( mnGlyphCount * sizeof(long) );
     for( i = 0; i < mnGlyphCount; ++i )
         pNewGlyphWidths[ i ] = 0;
 
@@ -937,7 +930,6 @@ void GenericSalLayout::ApplyDXArray( Imp
     long nDelta = 0;
     long nNewPos = 0;
     pG = mpGlyphItems;
-    const GlyphItem* const pGEnd = mpGlyphItems + mnGlyphCount;
     for( i = 0; i < mnGlyphCount; ++i, ++pG )
     {
         if( pG->IsClusterStart() )
@@ -1006,7 +998,7 @@ void GenericSalLayout::Justify( long nNe
 
     // interpolate inbetween glyph positions
     int nDiffWidth = nNewWidth - nOldWidth;
-    int nDiffSum = 0;
+    int nDeltaSum = 0;
     for( pG = mpGlyphItems; (pG < pGRight) && (nStretchable > 0); ++pG )
     {
         if( pG->mnOrigWidth <= 0 )
@@ -1017,12 +1009,11 @@ void GenericSalLayout::Justify( long nNe
         --nStretchable;
 
         pG->mnNewWidth += nDeltaWidth;
-        pG->maLinearPos.X() += nDiffSum;
-        nDiffSum += nDeltaWidth;
+        pG->maLinearPos.X() += nDeltaSum;
+	nDeltaSum += nDeltaWidth;
     }
 }
 
-
 // -----------------------------------------------------------------------
 
 void GenericSalLayout::ApplyAsianKerning( const sal_Unicode* pStr, int nLength )
@@ -1140,7 +1131,7 @@ void GenericSalLayout::KashidaJustify( l
 
 // -----------------------------------------------------------------------
 
-void GenericSalLayout::GetCaretPositions( int nMaxIndex, long* pCaretXArray ) const
+void GenericSalLayout::GetCaretPositions( int nMaxIndex, sal_Int32* pCaretXArray ) const
 {
     // initialize result array
     long nXPos = -1;
@@ -1176,7 +1167,7 @@ void GenericSalLayout::GetCaretPositions
 int GenericSalLayout::GetTextBreak( long nMaxWidth, long nCharExtra, int nFactor ) const
 {
     int nCharCapacity = mnEndCharPos - mnMinCharPos;
-    long* pCharWidths = (long*)alloca( nCharCapacity * sizeof(long) );
+    sal_Int32* pCharWidths = (sal_Int32*)alloca( nCharCapacity * sizeof(sal_Int32) );
     if( !GetCharWidths( pCharWidths ) )
         return STRING_LEN;
 
@@ -1194,8 +1185,8 @@ int GenericSalLayout::GetTextBreak( long
 
 // -----------------------------------------------------------------------
 
-int GenericSalLayout::GetNextGlyphs( int nLen, long* pGlyphs, Point& rPos,
-    int& nStart, long* pGlyphAdvAry, int* pCharPosAry ) const
+int GenericSalLayout::GetNextGlyphs( int nLen, sal_Int32* pGlyphs, Point& rPos,
+    int& nStart, sal_Int32* pGlyphAdvAry, int* pCharPosAry ) const
 {
     const GlyphItem* pG = mpGlyphItems + nStart;
 
@@ -1411,7 +1402,7 @@ void MultiSalLayout::AdjustLayout( ImplL
             mpLayouts[n]->SalLayout::AdjustLayout( aMultiArgs );
         // then we can measure the unmodified metrics
         int nCharCount = rArgs.mnEndCharPos - rArgs.mnMinCharPos;
-        long* pJustificationArray = (long*)alloca( nCharCount * sizeof(long) );
+        sal_Int32* pJustificationArray = (sal_Int32*)alloca( nCharCount * sizeof(sal_Int32) );
         FillDXArray( pJustificationArray );
         // #i17359# multilayout is not simplified yet, so calculating the
         // unjustified width needs handholding; also count the number of
@@ -1456,11 +1447,11 @@ void MultiSalLayout::AdjustLayout( ImplL
     int nStartOld[ MAX_FALLBACK ];
     int nStartNew[ MAX_FALLBACK ];
     int nCharPos[ MAX_FALLBACK ];
-    long nGlyphAdv[ MAX_FALLBACK ];
+    sal_Int32 nGlyphAdv[ MAX_FALLBACK ];
     int nValid[ MAX_FALLBACK ];
     const ImplLayoutRuns& rLastLevelRuns = maFallbackRuns[ mnLevel-1 ];
 
-    long nDummy;
+    sal_Int32 nDummy;
     Point aPos;
     int nLevel = 0, n;
     for( n = 0; n < mnLevel; ++n )
@@ -1501,6 +1492,7 @@ void MultiSalLayout::AdjustLayout( ImplL
 
     // merge the fallback levels
     long nXPos = 0;
+    int nFallbackUnitsPerPixel = 1;
     for( n = 0; n < nLevel; ++n )
         maFallbackRuns[n].ResetPos();
     while( nValid[0] )
@@ -1515,9 +1507,10 @@ void MultiSalLayout::AdjustLayout( ImplL
         {
             // use base(n==0) or fallback(n>=1) level
             long nNewPos = nXPos;
-            if( mpLayouts[n]->GetUnitsPerPixel() != mnUnitsPerPixel )
+            nFallbackUnitsPerPixel = mpLayouts[n]->GetUnitsPerPixel();
+            if( nFallbackUnitsPerPixel != mnUnitsPerPixel )
             {
-                nNewPos *= mpLayouts[n]->GetUnitsPerPixel();
+                nNewPos *= nFallbackUnitsPerPixel;
                 nNewPos /= mnUnitsPerPixel;
             }
             mpLayouts[n]->MoveGlyph( nStartOld[n], nNewPos );
@@ -1530,12 +1523,19 @@ void MultiSalLayout::AdjustLayout( ImplL
                 n = 0;  // keep NotDef in base level
             else
                 n = -1; // drop NotDef in base level
+            nFallbackUnitsPerPixel = mnUnitsPerPixel;
         }
 
         if( n >= 0 )
         {
             // use glyph from best matching layout
-            nXPos += nGlyphAdv[n] * mnUnitsPerPixel / mpLayouts[n]->GetUnitsPerPixel();
+            int nCurrentGlyphAdv = nGlyphAdv[n];
+            if( nFallbackUnitsPerPixel != mnUnitsPerPixel )
+            {
+                nCurrentGlyphAdv *= mnUnitsPerPixel;
+                nCurrentGlyphAdv /= nFallbackUnitsPerPixel;
+            }
+            nXPos += nCurrentGlyphAdv;
 
             // complete this glyph cluster, then advance to next
             for( int nActivePos = nCharPos[0];; )
@@ -1545,7 +1545,13 @@ void MultiSalLayout::AdjustLayout( ImplL
                     nStartNew[n], &nGlyphAdv[n], &nCharPos[n] );
                 if( !nValid[n] || (nCharPos[n] != nActivePos) )
                     break;
-                nXPos += nGlyphAdv[n] * mnUnitsPerPixel / mpLayouts[n]->GetUnitsPerPixel();
+                int nCurrentGlyphAdv = nGlyphAdv[n];
+                if( nFallbackUnitsPerPixel != mnUnitsPerPixel )
+                {
+                    nCurrentGlyphAdv *= mnUnitsPerPixel;
+                    nCurrentGlyphAdv /= nFallbackUnitsPerPixel;
+                }
+                nXPos += nCurrentGlyphAdv;
             }
 
             // performance optimization (fallback level is completed)
@@ -1557,7 +1563,7 @@ void MultiSalLayout::AdjustLayout( ImplL
         {
             // drop NotDef glyph from base layout
             mpLayouts[0]->DropGlyph( nStartOld[0] );
-            mpLayouts[0]->MoveGlyph( nStartNew[0], nXPos*mpLayouts[0]->GetUnitsPerPixel()/mnUnitsPerPixel );
+            mpLayouts[0]->MoveGlyph( nStartNew[0], nXPos );
 
             // get next glyph in base layout
             nStartOld[0] = nStartNew[0];
@@ -1613,7 +1619,7 @@ int MultiSalLayout::GetTextBreak( long n
         return mpLayouts[0]->GetTextBreak( nMaxWidth, nCharExtra, nFactor );
 
     int nCharCount = mnEndCharPos - mnMinCharPos;
-    long* pCharWidths = (long*)alloca( 2*nCharCount * sizeof(long) );
+    sal_Int32* pCharWidths = (sal_Int32*)alloca( 2*nCharCount * sizeof(sal_Int32) );
     mpLayouts[0]->FillDXArray( pCharWidths );
 
     for( int n = 1; n < mnLevel; ++n )
@@ -1642,18 +1648,18 @@ int MultiSalLayout::GetTextBreak( long n
 
 // -----------------------------------------------------------------------
 
-long MultiSalLayout::FillDXArray( long* pCharWidths ) const
+long MultiSalLayout::FillDXArray( sal_Int32* pCharWidths ) const
 {
     long nMaxWidth = 0;
 
     // prepare merging of fallback levels
-    long* pTempWidths = NULL;
+    sal_Int32* pTempWidths = NULL;
     const int nCharCount = mnEndCharPos - mnMinCharPos;
     if( pCharWidths )
     {
         for( int i = 0; i < nCharCount; ++i )
             pCharWidths[i] = 0;
-        pTempWidths = (long*)alloca( nCharCount * sizeof(long) );
+        pTempWidths = (sal_Int32*)alloca( nCharCount * sizeof(sal_Int32) );
     }
 
     for( int n = mnLevel; --n >= 0; )
@@ -1663,11 +1669,8 @@ long MultiSalLayout::FillDXArray( long* 
         if( !nWidth )
             continue;
         // merge results from current level
-        if( mnUnitsPerPixel != mpLayouts[n]->GetUnitsPerPixel() )
-        {
-            nWidth *= mnUnitsPerPixel;
-            nWidth /= mpLayouts[n]->GetUnitsPerPixel();
-        }
+        nWidth *= mnUnitsPerPixel;
+        nWidth /= mpLayouts[n]->GetUnitsPerPixel();
         if( nMaxWidth < nWidth )
             nMaxWidth = nWidth;
         if( !pCharWidths )
@@ -1693,14 +1696,14 @@ long MultiSalLayout::FillDXArray( long* 
 
 // -----------------------------------------------------------------------
 
-void MultiSalLayout::GetCaretPositions( int nMaxIndex, long* pCaretXArray ) const
+void MultiSalLayout::GetCaretPositions( int nMaxIndex, sal_Int32* pCaretXArray ) const
 {
     SalLayout& rLayout = *mpLayouts[ 0 ];
     rLayout.GetCaretPositions( nMaxIndex, pCaretXArray );
 
     if( mnLevel > 1 )
     {
-        long* pTempPos = (long*)alloca( nMaxIndex * sizeof(long) );
+        sal_Int32* pTempPos = (sal_Int32*)alloca( nMaxIndex * sizeof(sal_Int32) );
         for( int n = 1; n < mnLevel; ++n )
         {
             mpLayouts[ n ]->GetCaretPositions( nMaxIndex, pTempPos );
@@ -1718,8 +1721,8 @@ void MultiSalLayout::GetCaretPositions( 
 
 // -----------------------------------------------------------------------
 
-int MultiSalLayout::GetNextGlyphs( int nLen, long* pGlyphIdxAry, Point& rPos,
-    int& nStart, long* pGlyphAdvAry, int* pCharPosAry ) const
+int MultiSalLayout::GetNextGlyphs( int nLen, sal_Int32* pGlyphIdxAry, Point& rPos,
+    int& nStart, sal_Int32* pGlyphAdvAry, int* pCharPosAry ) const
 {
     // for multi-level fallback only single glyphs should be used
     if( mnLevel > 1 && nLen > 1 )
Index: vcl/source/gdi/salmisc.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/salmisc.cxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/source/gdi/salmisc.cxx	17 Jan 2002 15:35:33 -0000	1.3
+++ vcl/source/gdi/salmisc.cxx	6 Jan 2004 13:56:04 -0000	1.4
@@ -89,7 +89,7 @@ break
 #define DOUBLE_SCANLINES()														\
 while( ( nActY < nHeight1 ) && ( pMapY[ nActY + 1 ] == nMapY ) )				\
 {																				\
-	HMEMCPY( pDstScanMap[ nActY + 1L ], pDstScan, rDstBuffer.mnScanlineSize );	\
+	memcpy( pDstScanMap[ nActY + 1L ], pDstScan, rDstBuffer.mnScanlineSize );	\
 	nActY++;																	\
 }
 
Index: vcl/source/gdi/salnativewidgets-none.cxx
===================================================================
RCS file: vcl/source/gdi/salnativewidgets-none.cxx
diff -N vcl/source/gdi/salnativewidgets-none.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/source/gdi/salnativewidgets-none.cxx	10 May 2004 15:49:20 -0000	1.2
@@ -0,0 +1,172 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Juergen Keil
+ *
+ *
+ ************************************************************************/
+
+#include <salgdi.hxx>
+
+using namespace rtl;
+
+/****************************************************************
+ *  Placeholder for no native widgets
+ ***************************************************************/
+
+
+/*
+ * IsNativeControlSupported()
+ *
+ *  Returns TRUE if the platform supports native
+ *  drawing of the control defined by nPart
+ */
+BOOL SalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+	return( FALSE );
+}
+
+
+/*
+ * HitTestNativeControl()
+ *
+ *  If the return value is TRUE, bIsInside contains information whether
+ *  aPos was or was not inside the native widget specified by the
+ *  nType/nPart combination.
+ */
+BOOL SalGraphics::hitTestNativeControl( ControlType nType,
+							  ControlPart nPart,
+							  const Region& rControlRegion,
+							  const Point& aPos,
+							  SalControlHandle& rControlHandle,
+							  BOOL& rIsInside )
+{
+	return( FALSE );
+}
+
+
+/*
+ * DrawNativeControl()
+ *
+ *  Draws the requested control described by nPart/nState.
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::drawNativeControl(	ControlType nType,
+							ControlPart nPart,
+							const Region& rControlRegion,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption )
+{
+	return( FALSE );
+}
+
+
+/*
+ * DrawNativeControlText()
+ *
+ *  OPTIONAL.  Draws the requested text for the control described by nPart/nState.
+ *     Used if text not drawn by DrawNativeControl().
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::drawNativeControlText(	ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption )
+{
+	return( FALSE );
+}
+
+
+/*
+ * GetNativeControlRegion()
+ *
+ *  If the return value is TRUE, rNativeBoundingRegion
+ *  contains the TRUE bounding region covered by the control
+ *  including any adornment, while rNativeContentRegion contains the area
+ *  within the control that can be safely drawn into without drawing over
+ *  the borders of the control.
+ *
+ *  rControlRegion:	The bounding region of the control in VCL frame coordinates.
+ *  aValue:		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:		A caption or title string (like button text etc)
+ */
+BOOL SalGraphics::getNativeControlRegion(  ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+								Region &rNativeBoundingRegion,
+								Region &rNativeContentRegion )
+{
+	return( FALSE );
+}
+
Index: vcl/source/gdi/svcompat.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/svcompat.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/svcompat.cxx	18 Sep 2000 17:05:38 -0000	1.1.1.1
+++ vcl/source/gdi/svcompat.cxx	6 Jan 2004 13:56:30 -0000	1.2
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_COMPAT_CXX
 
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
Index: vcl/source/gdi/virdev.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/virdev.cxx,v
retrieving revision 1.9
retrieving revision 1.14
diff -u -p -u -r1.9 -r1.14
--- vcl/source/gdi/virdev.cxx	2 May 2003 14:36:42 -0000	1.9
+++ vcl/source/gdi/virdev.cxx	6 Jan 2004 13:57:02 -0000	1.14
@@ -59,13 +59,10 @@
  *
  ************************************************************************/
 
-#define _SV_VIRDEV_CXX
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALINST_HXX
 #include <salinst.hxx>
 #endif
@@ -78,7 +75,6 @@
 #ifndef _SV_SALVD_HXX
 #include <salvd.hxx>
 #endif
-#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
@@ -104,52 +100,6 @@
 
 using namespace ::com::sun::star::uno;
 
-// appserver
-#ifdef REMOTE_APPSERVER
-#ifndef _SV_RMOUTDEV_HXX
-#include <rmoutdev.hxx>
-#endif
-#ifndef _SV_RMVIRDEV_HXX
-#include <rmvirdev.hxx>
-#endif
-#ifndef _VCL_RMCACHE_HXX_
-#include <rmcache.hxx>
-#endif
-#endif
-
-// =======================================================================
-
-// interface cache
-#ifdef REMOTE_APPSERVER
-
-static ::vcl::InterfacePairCache< ::com::sun::star::portal::client::XRmVirtualDevice, ::com::sun::star::portal::client::XRmOutputDevice >* pRemoteVirdevCache = NULL;
-
-typedef ::std::pair< ::com::sun::star::uno::Reference< ::com::sun::star::portal::client::XRmVirtualDevice >, ::com::sun::star::uno::Reference< ::com::sun::star::portal::client::XRmOutputDevice > > virdevInterfacePair;
-
-
-void createRemoteVirdevCache( const ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& aInterfaceSeq )
-{
-	if( ! pRemoteVirdevCache )
-	{
-		ImplSVData* pSVData = ImplGetSVData();
-		pRemoteVirdevCache = new ::vcl::InterfacePairCache< ::com::sun::star::portal::client::XRmVirtualDevice, ::com::sun::star::portal::client::XRmOutputDevice >(
-			pSVData->mxMultiFactory,
-			aInterfaceSeq,
-			::rtl::OUString::createFromAscii( "OfficeVirtualDevice.stardiv.de" ), 10, 40 );
-	}
-}
-
-void eraseRemoteVirdevCache()
-{
-	if( pRemoteVirdevCache )
-	{
-		delete pRemoteVirdevCache;
-		pRemoteVirdevCache = NULL;
-	}
-}
-
-#endif
-
 // =======================================================================
 
 void VirtualDevice::ImplInitVirDev( const OutputDevice* pOutDev,
@@ -169,7 +119,6 @@ void VirtualDevice::ImplInitVirDev( cons
 	if ( !pOutDev )
 		pOutDev = ImplGetDefaultWindow();
 
-#ifndef REMOTE_APPSERVER
 	SalGraphics* pGraphics;
 	if ( !pOutDev->mpGraphics )
 		((OutputDevice*)pOutDev)->ImplGetGraphics();
@@ -180,62 +129,13 @@ void VirtualDevice::ImplInitVirDev( cons
 		mpVirDev = NULL;
 	if ( !mpVirDev )
 		GetpApp()->Exception( EXC_SYSOBJNOTCREATED );
-#else
-
-	if( pOutDev->GetOutDevType() == OUTDEV_PRINTER || ! mpVirDev )
-	{
-		virdevInterfacePair aPair = pRemoteVirdevCache->takeInterface();
-		if( aPair.first.is() && aPair.second.is() )
-		{
-			if( ! mpVirDev )
-				mpVirDev = new RmVirtualDevice;
-			mpVirDev->SetInterface( aPair.first );
-			mpVirDev->Create( (ULONG) pOutDev, nDX, nDY, nBitCount );
-
-			if( ! mpGraphics )
-				mpGraphics = new ImplServerGraphics();
-			mpGraphics->SetInterface( aPair.second );
-		}
-	}
-	else
-	{
-		// this was done in ImpGetServerGraphics before
-		// and is now here because of interface caching
-		if( mpGraphics && mpGraphics->GetInterface().is() )
-		{
-			try
-			{
-				CHECK_FOR_RVPSYNC_NORMAL();
-				mpGraphics->GetInterface()->SetFillColor( mpGraphics->maFillColor.GetColor() );
-			}
-			catch (...)
-			{
-				if( mpGraphics )
-					delete mpGraphics, mpGraphics = NULL;
-
-				if( mpVirDev )
-				{
-					virdevInterfacePair aPair = pRemoteVirdevCache->takeInterface();
-					if( aPair.first.is() && aPair.second.is() )
-					{
-						mpVirDev->SetInterface( aPair.first );
-						mpVirDev->Create( (ULONG)NULL, mnOutWidth, mnOutHeight, mnBitCount );
-						mpGraphics = new ImplServerGraphics();
-						mpGraphics->SetInterface( aPair.second );
-					}
-					else
-						mpVirDev->SetInterface( REF( NMSP_CLIENT::XRmVirtualDevice )() );
-				}
-			}
-		}
-		ImplGetServerGraphics( TRUE );
-	}
-#endif
 
 	mnBitCount		= ( nBitCount ? nBitCount : pOutDev->GetBitCount() );
 	mnOutWidth		= nDX;
 	mnOutHeight 	= nDY;
 	mbScreenComp	= TRUE;
+	mbScreenComp	= FALSE;
+    mnAlphaDepth	= -1;
 
     if( mnBitCount < 8 )
         SetAntialiasing( ANTIALIASING_DISABLE_TEXT );
@@ -270,7 +170,8 @@ void VirtualDevice::ImplInitVirDev( cons
 // -----------------------------------------------------------------------
 
 VirtualDevice::VirtualDevice( USHORT nBitCount )
-	: mpVirDev( NULL )
+:   mpVirDev( NULL ),
+    meRefDevMode( REFDEV_NONE )
 {
 	DBG_TRACE1( "VirtualDevice::VirtualDevice( %hu )", nBitCount );
 
@@ -280,11 +181,25 @@ VirtualDevice::VirtualDevice( USHORT nBi
 // -----------------------------------------------------------------------
 
 VirtualDevice::VirtualDevice( const OutputDevice& rCompDev, USHORT nBitCount )
+	: mpVirDev( NULL ),
+    meRefDevMode( REFDEV_NONE )
+{
+	DBG_TRACE1( "VirtualDevice::VirtualDevice( %hu )", nBitCount );
+
+	ImplInitVirDev( &rCompDev, 1, 1, nBitCount );
+}
+
+// -----------------------------------------------------------------------
+
+VirtualDevice::VirtualDevice( const OutputDevice& rCompDev, USHORT nBitCount, USHORT nAlphaBitCount )
 	: mpVirDev( NULL )
 {
 	DBG_TRACE1( "VirtualDevice::VirtualDevice( %hu )", nBitCount );
 
 	ImplInitVirDev( &rCompDev, 1, 1, nBitCount );
+
+    // #110958# Enable alpha channel
+    mnAlphaDepth = nAlphaBitCount;
 }
 
 // -----------------------------------------------------------------------
@@ -295,33 +210,10 @@ VirtualDevice::~VirtualDevice()
 
    ImplSVData* pSVData = ImplGetSVData();
 
-#ifndef REMOTE_APPSERVER
 	ImplReleaseGraphics();
 
 	if ( mpVirDev )
 		pSVData->mpDefInst->DestroyVirtualDevice( mpVirDev );
-#else
-	if ( pRemoteVirdevCache && mpVirDev && mpGraphics )
-	{
-		virdevInterfacePair aPair( mpVirDev->GetInterface(), mpGraphics->GetInterface() );
-		CHECK_FOR_RVPSYNC_NORMAL();
-        try
-        {
-		    aPair.first->Create( 0, 0, 0, 0 );
-		    pRemoteVirdevCache->putInterface( aPair );
-        }
-        catch ( RuntimeException &e )
-        {
-            rvpExceptionHandler();
-        }
-	}
-
-    REF( NMSP_CLIENT::XRmOutputDevice ) aTmp;
-	mpGraphics->SetInterface( aTmp );
-	ImplReleaseServerGraphics();
-	delete mpVirDev;
-	delete mpGraphics;
-#endif
 
 	// VirDev aus der Liste eintragen
 	if( mpPrev )
@@ -337,9 +229,9 @@ VirtualDevice::~VirtualDevice()
 
 // -----------------------------------------------------------------------
 
-BOOL VirtualDevice::SetOutputSizePixel( const Size& rNewSize, BOOL bErase )
+BOOL VirtualDevice::ImplSetOutputSizePixel( const Size& rNewSize, BOOL bErase )
 {
-	DBG_TRACE3( "VirtualDevice::SetOutputSizePixel( %ld, %ld, %d )", rNewSize.Width(), rNewSize.Height(), (int)bErase );
+	DBG_TRACE3( "VirtualDevice::ImplSetOutputSizePixel( %ld, %ld, %d )", rNewSize.Width(), rNewSize.Height(), (int)bErase );
 
 	if ( !mpVirDev )
 		return FALSE;
@@ -350,33 +242,6 @@ BOOL VirtualDevice::SetOutputSizePixel( 
 		return TRUE;
 	}
 
-#ifdef REMOTE_APPSERVER
-	long nOldWidth = mnOutWidth, nOldHeight = mnOutHeight;
-
-	try
-	{
-		mnOutWidth	= rNewSize.Width();
-		mnOutHeight = rNewSize.Height();
-		mpVirDev->ResizeOutputSizePixel( mnOutWidth, mnOutHeight );
-	}
-	catch (...)
-	{
-		delete mpVirDev, mpVirDev = NULL;
-		ImplInitVirDev( NULL, mnOutWidth, mnOutHeight, mnBitCount );
-	}
-
-	if( bErase )
-		Erase();
-	else
-	{
-		if ( nOldWidth < mnOutWidth )
-			Erase( Rectangle( Point( nOldWidth, 0 ), Size( mnOutWidth-nOldWidth, Max( nOldHeight, mnOutHeight ) ) ) );
-		if ( nOldHeight< mnOutHeight )
-			Erase( Rectangle( Point( 0, nOldHeight ), Size( Max( nOldWidth, mnOutWidth ), mnOutHeight-nOldHeight ) ) );
-	}
-
-	return TRUE;
-#else
 	BOOL bRet;
 	long nNewWidth = rNewSize.Width(), nNewHeight = rNewSize.Height();
 
@@ -455,16 +320,79 @@ BOOL VirtualDevice::SetOutputSizePixel( 
 	}
 
 	return bRet;
-#endif
 }
 
-void VirtualDevice::SetReferenceDevice()
+// -----------------------------------------------------------------------
+
+BOOL VirtualDevice::SetOutputSizePixel( const Size& rNewSize, BOOL bErase )
 {
-    // reference device has 600dpi
-    mnDPIX = 600;
-    mnDPIY = 600;
+    if( ImplSetOutputSizePixel(rNewSize, bErase) )
+    {
+        if( mnAlphaDepth != -1 )
+        {
+            // #110958# Setup alpha bitmap
+			if(mpAlphaVDev && mpAlphaVDev->GetOutputSizePixel() != rNewSize)
+			{
+				delete mpAlphaVDev;
+				mpAlphaVDev = 0L;
+			}
+
+			if( !mpAlphaVDev )
+            {
+                mpAlphaVDev = new VirtualDevice( *this, mnAlphaDepth );
+                mpAlphaVDev->ImplSetOutputSizePixel(rNewSize, bErase);
+            }
+
+            // TODO: copy full outdev state to new one, here. Also needed in outdev2.cxx:DrawOutDev
+            if( GetLineColor() != Color( COL_TRANSPARENT ) )
+                mpAlphaVDev->SetLineColor( COL_BLACK );
+
+            if( GetFillColor() != Color( COL_TRANSPARENT ) )
+                mpAlphaVDev->SetFillColor( COL_BLACK );
+
+            mpAlphaVDev->SetMapMode( GetMapMode() );
+        }
+
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+// -----------------------------------------------------------------------
+
+void VirtualDevice::SetReferenceDevice( RefDevMode eRefDevMode )
+{
+    switch( eRefDevMode )
+    {
+    case REFDEV_NONE:
+    default:
+        DBG_ASSERT( FALSE, "VDev::SetRefDev illegal argument!" );
+        // fall through
+    case REFDEV_MODE06:
+        mnDPIX = mnDPIY = 600;
+        break;
+    case REFDEV_MODE48:
+        mnDPIX = mnDPIY = 4800;
+        break;
+    case REFDEV_MODE96:
+        mnDPIX = mnDPIY = 9600;
+        break;
+    }
+
+    EnableOutput( FALSE );  // prevent output on reference device
     mbScreenComp = FALSE;
 
+    // invalidate currently selected fonts
+    mbInitFont = TRUE;
+    mbNewFont = TRUE;
+
+    // avoid adjusting font lists when already in refdev mode
+    BYTE nOldRefDevMode = meRefDevMode;
+    meRefDevMode = (BYTE)eRefDevMode;
+    if( nOldRefDevMode != REFDEV_NONE )
+        return;
+
     // the reference device should have only scalable fonts
     // => clean up the original font lists before getting new ones
     if ( mpFontEntry )
@@ -491,6 +419,7 @@ void VirtualDevice::SetReferenceDevice()
         delete mpFontCache;
 
     // get font list with scalable fonts only
+    ImplGetGraphics();
     ImplDevFontList* pScalableDevFonts = new ImplDevFontList();
     ImplDevFontListData* pData = pSVData->maGDIData.mpScreenFontList->First();
     for(; pData; pData = pSVData->maGDIData.mpScreenFontList->Next() )
@@ -506,13 +435,11 @@ void VirtualDevice::SetReferenceDevice()
             pScalableDevFonts->Add( pNewData );
         }
     }
-    mpFontList = pScalableDevFonts;
 
     // prepare to use new font lists
+    mpFontList = pScalableDevFonts;
     mpFontCache = new ImplFontCache( FALSE );
-    mbInitFont = TRUE;
-    mbNewFont = TRUE;
-    
-    // TODO: increase maFont's size accordingly?
 }
 
+// -----------------------------------------------------------------------
+// eof
Index: vcl/source/gdi/wall.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/wall.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/source/gdi/wall.cxx	18 Sep 2000 17:05:39 -0000	1.1.1.1
+++ vcl/source/gdi/wall.cxx	6 Jan 2004 13:57:32 -0000	1.2
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_WALL_CXX
-
 #ifndef _STREAM_HXX
 #include <tools/stream.hxx>
 #endif
@@ -79,8 +77,10 @@
 #ifndef _SV_WALL_HXX
 #include <wall.hxx>
 #endif
+#ifndef _SV_WALL2_HXX
+#include <wall2.hxx>
+#endif
 
-// =======================================================================
 
 DBG_NAME( Wallpaper );
 
@@ -259,11 +259,7 @@ Wallpaper::Wallpaper()
 {
 	DBG_CTOR( Wallpaper, NULL );
 
-#ifdef WIN
-	static ImplWallpaper _near aStaticImplWallpaper;
-#else
 	static ImplWallpaper aStaticImplWallpaper;
-#endif
 
 	aStaticImplWallpaper.mnRefCount = 0;
 	mpImplWallpaper = &aStaticImplWallpaper;
@@ -349,6 +345,15 @@ void Wallpaper::SetColor( const Color& r
 
 // -----------------------------------------------------------------------
 
+const Color& Wallpaper::GetColor() const 
+{ 
+	DBG_CHKTHIS( Wallpaper, NULL );
+
+    return mpImplWallpaper->maColor; 
+}
+
+// -----------------------------------------------------------------------
+
 void Wallpaper::SetStyle( WallpaperStyle eStyle )
 {
 	DBG_CHKTHIS( Wallpaper, NULL );
@@ -359,6 +364,15 @@ void Wallpaper::SetStyle( WallpaperStyle
 
 // -----------------------------------------------------------------------
 
+WallpaperStyle Wallpaper::GetStyle() const 
+{ 
+	DBG_CHKTHIS( Wallpaper, NULL );
+
+    return mpImplWallpaper->meStyle; 
+}
+
+// -----------------------------------------------------------------------
+
 void Wallpaper::SetBitmap( const BitmapEx& rBitmap )
 {
 	DBG_CHKTHIS( Wallpaper, NULL );
@@ -416,6 +430,16 @@ BitmapEx Wallpaper::GetBitmap() const
 
 // -----------------------------------------------------------------------
 
+BOOL Wallpaper::IsBitmap() const 
+{ 
+	DBG_CHKTHIS( Wallpaper, NULL );
+
+    return (mpImplWallpaper->mpBitmap != 0); 
+}
+
+
+// -----------------------------------------------------------------------
+
 void Wallpaper::SetGradient( const Gradient& rGradient )
 {
 	DBG_CHKTHIS( Wallpaper, NULL );
@@ -462,6 +486,16 @@ Gradient Wallpaper::GetGradient() const
 
 // -----------------------------------------------------------------------
 
+BOOL Wallpaper::IsGradient() const 
+{ 
+	DBG_CHKTHIS( Wallpaper, NULL );
+
+    return (mpImplWallpaper->mpGradient != 0); 
+}
+
+
+// -----------------------------------------------------------------------
+
 void Wallpaper::SetRect( const Rectangle& rRect )
 {
 	DBG_CHKTHIS( Wallpaper, NULL );
@@ -513,6 +547,16 @@ Rectangle Wallpaper::GetRect() const
 		return aRect;
 	}
 }
+
+// -----------------------------------------------------------------------
+
+BOOL Wallpaper::IsRect() const 
+{ 
+	DBG_CHKTHIS( Wallpaper, NULL );
+
+    return (mpImplWallpaper->mpRect != 0); 
+}
+
 
 // -----------------------------------------------------------------------
 
Index: vcl/source/glyphs/gcach_ftyp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/gcach_ftyp.hxx,v
retrieving revision 1.24
retrieving revision 1.27
diff -u -p -u -r1.24 -r1.27
--- vcl/source/glyphs/gcach_ftyp.hxx	4 Jul 2003 12:51:33 -0000	1.24
+++ vcl/source/glyphs/gcach_ftyp.hxx	18 May 2004 10:55:11 -0000	1.27
@@ -65,11 +65,15 @@
 #include <glyphcache.hxx>
 #include <rtl/textcvt.h>
 
-typedef int FT_Int;
-struct FT_GlyphRec_;
+#include "ft2build.h"
+#include  FT_FREETYPE_H
+#include  FT_GLYPH_H
+#include  FT_OUTLINE_H
+#include  FT_TRUETYPE_TABLES_H
+#include  FT_TRUETYPE_TAGS_H
+#include  FT_TRUETYPE_IDS_H
 class FreetypeServerFont;
-struct FT_FaceRec_;
-struct FT_SizeRec_;
+struct FT_GlyphRec_;
 
 // -----------------------------------------------------------------------
 
@@ -87,7 +85,6 @@ public:
     const unsigned char*    GetBuffer() const { return mpFileMap; }
     int                     GetFileSize() const { return mnFileSize; }
     const ::rtl::OString*   GetFileName() const { return &maNativeFileName; }
-
 private:
                             FtFontFile( const ::rtl::OString& rNativeFileName );
 
@@ -104,7 +101,9 @@ class FtFontInfo
 {
 public:
     FtFontInfo( const ImplFontData&, const ::rtl::OString&,
-        int nFaceNum, int nFontId, int nSynthetic );
+                int nFaceNum, int nFontId, int nSynthetic,
+                const unicodeKernMap* pUnicodeKern = NULL
+                );
 
     const unsigned char*  GetTable( const char*, ULONG* pLength=0 ) const;
 
@@ -121,6 +120,11 @@ public:
 
     int                   GetGlyphIndex( sal_Unicode cChar ) const;
     void                  CacheGlyphIndex( sal_Unicode cChar, int nGI ) const;
+    const glyphKernMap*	  GetGlyphKernMap() const
+    { return (maUnicodeKernPairs.size() || maGlyphKernPairs.size()) ? &maGlyphKernPairs : NULL; }
+    const unicodeKernMap* GetUnicodeKernMap() const
+    { return maUnicodeKernPairs.size() ? &maUnicodeKernPairs : NULL; }
+
 
 private:
     ImplFontData    maFontData;
@@ -135,6 +139,9 @@ private:
     // cache unicode->glyphid mapping because looking it up is expensive
     typedef ::std::hash_map<sal_Unicode,int> FIGlyphMap;
     mutable FIGlyphMap maGlyphMap;
+
+    mutable glyphKernMap maGlyphKernPairs;
+    unicodeKernMap maUnicodeKernPairs;
 };
 
 // these two inlines are very important for performance
@@ -147,11 +154,6 @@ inline int FtFontInfo::GetGlyphIndex( sa
     return -1;
 }
 
-inline void FtFontInfo::CacheGlyphIndex( sal_Unicode cChar, int nGI ) const
-{
-    maGlyphMap[ cChar ] = nGI;
-}
-
 // -----------------------------------------------------------------------
 
 class FreetypeManager
@@ -162,7 +164,9 @@ public:
 
     long                AddFontDir( const String& rUrlName );
     void                AddFontFile( const rtl::OString& rNormalizedName,
-                            int nFaceNum, int nFontId, const ImplFontData* );
+                                     int nFaceNum, int nFontId, const ImplFontData*,
+                                     const unicodeKernMap* pKern = NULL
+                                     );
     long                FetchFontList( ImplDevFontList* ) const;
     void                ClearFontList();
 
@@ -182,7 +186,7 @@ private:
 class FreetypeServerFont : public ServerFont
 {
 public:
-                                FreetypeServerFont( const ImplFontSelectData&, FtFontInfo* );
+                                FreetypeServerFont( const ImplFontSelectData&, FtFontInfo*, const glyphKernMap*, const unicodeKernMap* );
     virtual                     ~FreetypeServerFont();
 
     virtual const ::rtl::OString* GetFontFileName() const { return mpFontInfo->GetFontFileName(); }
@@ -206,9 +210,10 @@ public:
     const unsigned char*        GetTable( const char* pName, ULONG* pLength )
                                 { return mpFontInfo->GetTable( pName, pLength ); }
     int                         GetEmUnits() const;
+    const FT_Size_Metrics&      GetMetricsFT() const { return maSizeFT->metrics; }
 
 protected:
-friend GlyphCache;
+    friend class GlyphCache;
 
     int                         ApplyGlyphTransform( int nGlyphFlags, FT_GlyphRec_* ) const;
     virtual void                InitGlyphData( int nGlyphIndex, GlyphData& ) const;
Index: vcl/source/glyphs/gcach_layout.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/gcach_layout.cxx,v
retrieving revision 1.23.20.1
retrieving revision 1.29
diff -u -p -u -r1.23.20.1 -r1.29
--- vcl/source/glyphs/gcach_layout.cxx	9 Jan 2004 18:13:49 -0000	1.23.20.1
+++ vcl/source/glyphs/gcach_layout.cxx	25 Jun 2004 17:09:25 -0000	1.29
@@ -59,30 +59,26 @@
  ************************************************************************/
 
 #define ENABLE_ICU_LAYOUT
-#if OSL_DEBUG_LEVEL > 1
-//#define VERBOSE_DEBUG
-#endif
-
-#if !defined(_SV_SALUNX_HXX) && !defined(WIN32)
-#include <salunx.h>
-#endif
 
 #ifndef _SV_GCACHFTYP_HXX
-#include <freetype/freetype.h>
 #include <gcach_ftyp.hxx>
 #endif
 
 #ifndef _SV_SALLAYOUT_HXX
 #include <sallayout.hxx>
 #endif
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
 
-#ifdef WIN32
-#include <malloc.h>
-#define alloca _alloca
-#elif !defined(FREEBSD) && !defined(NETBSD) && !defined(MACOSX)
-#include <alloca.h>
+#if defined(SOLARIS) || defined(IRIX)
+  #include <alloca.h>
+#else
+#ifndef MACOSX
+  #include <malloc.h>
+#endif
 #endif
 
 #if OSL_DEBUG_LEVEL > 1
 #include <cstdio>
 #endif
@@ -446,6 +446,13 @@
     meScriptCode( USCRIPT_INVALID_CODE )
 {}
 
+void ServerFontLayout::DrawText( SalGraphics& rSalGraphics ) const
+{
+    rSalGraphics.DrawServerFontLayout( *this );
+}
+
+//--------------------------------------------------------------------------
+
 // -----------------------------------------------------------------------
 
 IcuLayoutEngine::~IcuLayoutEngine()
Index: vcl/source/glyphs/gcach_rbmp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/gcach_rbmp.cxx,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/source/glyphs/gcach_rbmp.cxx	13 Dec 2001 14:54:19 -0000	1.3
+++ vcl/source/glyphs/gcach_rbmp.cxx	6 Jan 2004 13:58:48 -0000	1.4
@@ -64,7 +64,7 @@
 //------------------------------------------------------------------------
 
 RawBitmap::RawBitmap()
-: mnAllocated(0), mpBits(0)
+: mpBits(0), mnAllocated(0)
 {}
 
 //------------------------------------------------------------------------
Index: vcl/source/glyphs/gcach_vdev.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/gcach_vdev.cxx,v
retrieving revision 1.11
retrieving revision 1.15
diff -u -p -u -r1.11 -r1.15
--- vcl/source/glyphs/gcach_vdev.cxx	5 Aug 2002 07:19:22 -0000	1.11
+++ vcl/source/glyphs/gcach_vdev.cxx	17 Jun 2004 12:21:43 -0000	1.15
@@ -75,10 +75,6 @@
 
 long VirtDevServerFont::FetchFontList( ImplDevFontList* pToAdd )
 {
-#if 0
-	// TODO: add fonts on server but not on client to the list
-	long nCount = 0;
-#else
 	// TODO: get fonts on server but not on client,
 	// problem is that currently there is no serverside virtual device...
 	VirtualDevice vdev( 1 );
@@ -112,8 +108,6 @@ long VirtDevServerFont::FetchFontList( I
 
 		pToAdd->Add( new ImplFontData( rData ) );	// TODO: avoid copy if possible
 	}
-#endif
-
 	return nCount;
 }
 
@@ -202,13 +197,16 @@ void VirtDevServerFont::InitGlyphData( i
 	vdev.SetFont( aFont );
 
 	// get glyph metrics
-	long nCharWidth = 10;
+	sal_Int32 nCharWidth = 10;
 // TODO:	vdev.GetCharWidth( nGlyphIndex, nGlyphIndex, &nCharWidth );
 	rGD.SetCharWidth( nCharWidth );
 
-	const Rectangle aRect = vdev.GetTextRect( aRect, nGlyphIndex );
+	const Rectangle aRect = vdev.GetTextRect(
+        aRect, String(static_cast< sal_Unicode >(nGlyphIndex)) );
 	rGD.SetOffset( aRect.Top(), aRect.Left() );
-	rGD.SetDelta( vdev.GetTextWidth( nGlyphIndex ), 0 );
+	rGD.SetDelta(
+        vdev.GetTextWidth( String(static_cast< sal_Unicode >(nGlyphIndex)) ),
+        0 );
 	rGD.SetSize( aRect.GetSize() );
 }
 
@@ -223,7 +221,7 @@ bool VirtDevServerFont::GetAntialiasAdvi
 
 bool VirtDevServerFont::GetGlyphBitmap1( int nGlyphIndex, RawBitmap& ) const
 {
-#if 0
+	/*
 	// draw bitmap
 	vdev.SetOutputSizePixel( aSize, TRUE );
 	vdev.DrawText( Point(0,0)-rGD.GetMetric().GetOffset(), nGlyphIndex );
@@ -233,9 +231,8 @@ bool VirtDevServerFont::GetGlyphBitmap1(
 	const Bitmap& rBitmap = vdev.GetBitmap( Point(0,0), aSize );
 	rGD.SetBitmap( new Bitmap( rBitmap ) );
 	return true;
-#else
+	*/
 	return false;
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -295,9 +292,8 @@ ULONG VirtDevServerFont::GetKernPairs( I
 
 bool VirtDevServerFont::GetGlyphOutline( int nGlyphIndex, PolyPolygon& rPolyPoly ) const
 {
-#if 1
 	return false;
-#else
+	/*
     Font aFont;
 	aFont.SetName		( GetFontSelData().maName );
 	aFont.SetStyleName	( GetFontSelData().maStyleName );
@@ -311,7 +307,7 @@ bool VirtDevServerFont::GetGlyphOutline(
 
 	const bool bOptimize = true;
 	return vdev.GetGlyphOutline( nGlyphIndex, rPolyPoly, bOptimize );
-#endif
+	*/
 }
 
 // =======================================================================
Index: vcl/source/glyphs/gcach_vdev.hxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/gcach_vdev.hxx,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -p -u -r1.5 -r1.7
--- vcl/source/glyphs/gcach_vdev.hxx	15 Feb 2002 15:58:57 -0000	1.5
+++ vcl/source/glyphs/gcach_vdev.hxx	4 Feb 2004 15:59:34 -0000	1.7
@@ -72,7 +72,7 @@ public:
 	virtual bool				GetGlyphOutline( int nGlyphIndex, PolyPolygon& ) const;
 
 protected:
-friend GlyphCache;
+    friend class GlyphCache;
 	static long					FetchFontList( ImplDevFontList* );
 	static void					ClearFontList();
 
Index: vcl/source/glyphs/glyphcache.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/glyphcache.cxx,v
retrieving revision 1.22.40.2
retrieving revision 1.26
diff -u -p -u -r1.22.40.2 -r1.26
--- vcl/source/glyphs/glyphcache.cxx	26 Jan 2004 17:23:59 -0000	1.22.40.2
+++ vcl/source/glyphs/glyphcache.cxx	18 May 2004 10:55:25 -0000	1.26
@@ -88,8 +88,8 @@ GlyphCache::GlyphCache( ULONG nMaxSize )
     mnBytesUsed(sizeof(GlyphCache)),
     mnLruIndex(0),
     mnGlyphCount(0),
-    mpFtManager(NULL),
-    mpCurrentGCFont(NULL)
+    mpCurrentGCFont(NULL),
+    mpFtManager(NULL)
 {
     mpFtManager = new FreetypeManager;
 }
@@ -167,7 +167,7 @@ void GlyphCache::RemoveFont( const ImplF
     FontList::iterator it_next = maFontList.begin(), it;
     while( it_next != maFontList.end() )
     {
-	it = it_next++;
+        it = it_next++;
         if( pFontData != it->first.mpFontData )
             continue;
 
@@ -219,10 +219,12 @@ void GlyphCache::AddFontPath( const Stri
 // -----------------------------------------------------------------------
 
 void GlyphCache::AddFontFile( const rtl::OString& rNormalizedName, int nFaceNum,
-    int nFontId, const ImplFontData* pFontData )
+                              int nFontId, const ImplFontData* pFontData,
+                              const unicodeKernMap* pKern
+                              )
 {
     if( mpFtManager )
-        mpFtManager->AddFontFile( rNormalizedName, nFaceNum, nFontId, pFontData );
+        mpFtManager->AddFontFile( rNormalizedName, nFaceNum, nFontId, pFontData, pKern );
 }
 
 // -----------------------------------------------------------------------
@@ -337,7 +339,7 @@ void GlyphCache::GarbageCollect()
             FontList::iterator it_next = maFontList.begin(), it;
             while( it_next != maFontList.end() )
             {
-		it = it_next++;
+                it = it_next++;
                 ServerFont* pSF = it->second;
                 if( (pSF != NULL)
                 &&  (pSF->GetRefCount() <= 0)
@@ -401,15 +403,17 @@ inline void GlyphCache::RemovingGlyph( S
 // ServerFont
 // =======================================================================
 
-ServerFont::ServerFont( const ImplFontSelectData& rFSD )
+ServerFont::ServerFont( const ImplFontSelectData& rFSD, const glyphKernMap* pKern, const unicodeKernMap* pUniKern )
 :   maFontSelData(rFSD),
     mnExtInfo(0),
     mnRefCount(1),
     mnBytesUsed( sizeof(ServerFont) ),
-    mpNextGCFont( NULL ),
     mpPrevGCFont( NULL ),
+    mpNextGCFont( NULL ),
     nCos( 0x10000),
-    nSin( 0)
+    nSin( 0),
+    mpKernPairs( pKern ),
+    mpUnicodeKernPairs( pUniKern )
 {
     if( rFSD.mnOrientation != 0 )
     {
@@ -440,6 +444,65 @@ long ServerFont::Release() const
 
 // -----------------------------------------------------------------------
 
+int ServerFont::GetGlyphKernValue( int left, int right ) const
+{
+    int kern = 0;
+    if( mpKernPairs )
+    {
+        std::map< int, std::map< int, int > >::const_iterator left_it =
+            mpKernPairs->find( left );
+        if( left_it != mpKernPairs->end() )
+        {
+            std::map< int, int >::const_iterator right_it = left_it->second.find( right );
+            if( right_it != left_it->second.end() )
+                kern = right_it->second;
+        }
+    }
+    return kern*(maFontSelData.mnWidth ? maFontSelData.mnWidth : maFontSelData.mnHeight)/1000;
+}
+
+// -----------------------------------------------------------------------
+
+ULONG ServerFont::GetKernPairs( struct ImplKernPairData** ppKernPairs ) const
+{
+    int nKernEntry = 0;
+    unicodeKernMap::const_iterator left_it;
+    std::map< sal_Unicode, int >::const_iterator right_it;
+    if( mpUnicodeKernPairs )
+    {
+        // count the kern entries
+        for( left_it = mpUnicodeKernPairs->begin(); left_it != mpUnicodeKernPairs->end(); ++left_it )
+        {
+            nKernEntry += left_it->second.size();
+        }
+    }
+
+    // allocate kern pair table
+    if( nKernEntry )
+    {
+        *ppKernPairs = new ImplKernPairData[ nKernEntry ];
+
+        // fill in kern pairs
+        nKernEntry = 0;
+        for( left_it = mpUnicodeKernPairs->begin(); left_it != mpUnicodeKernPairs->end(); ++left_it )
+        {
+            for( right_it = left_it->second.begin(); right_it != left_it->second.end(); ++right_it )
+            {
+                (*ppKernPairs)[ nKernEntry ].mnChar1 = (USHORT)left_it->first;
+                (*ppKernPairs)[ nKernEntry ].mnChar2 = (USHORT)right_it->first;
+                (*ppKernPairs)[ nKernEntry ].mnKern = right_it->second*(maFontSelData.mnWidth ? maFontSelData.mnWidth : maFontSelData.mnHeight)/1000;
+                nKernEntry++;
+            }
+        }
+    }
+    else
+        *ppKernPairs = NULL;
+
+    return (ULONG)nKernEntry;
+}
+
+// -----------------------------------------------------------------------
+
 GlyphData& ServerFont::GetGlyphData( int nGlyphIndex )
 {
     // usually the GlyphData is cached
@@ -465,7 +528,7 @@ void ServerFont::GarbageCollect( long nM
     GlyphList::iterator it_next = maGlyphList.begin(), it;
     while( it_next != maGlyphList.end() )
     {
-	it = it_next++;
+        it = it_next++;
         GlyphData& rGD = it->second;
         if( (nMinLruIndex - rGD.GetLruValue()) > 0 )
         {
Index: vcl/source/glyphs/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/makefile.mk,v
retrieving revision 1.5
retrieving revision 1.6
diff -u -p -u -r1.5 -r1.6
--- vcl/source/glyphs/makefile.mk	15 Feb 2002 15:52:27 -0000	1.5
+++ vcl/source/glyphs/makefile.mk	6 Jan 2004 14:00:38 -0000	1.6
@@ -76,11 +76,9 @@ TARGET=glyphs
 SLOFILES=\
 		$(SLO)$/glyphcache.obj		\
 		$(SLO)$/gcach_rbmp.obj		\
+		$(SLO)$/gcach_layout.obj	\
 		$(SLO)$/gcach_vdev.obj		\
 		$(SLO)$/gcach_ftyp.obj
-.IF "$(ENABLE_CTL)" != ""
-SLOFILES+=$(SLO)$/gcach_layout.obj
-.ENDIF
 .ENDIF
 
 # --- Targets ------------------------------------------------------
Index: vcl/source/helper/evntpost.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/helper/evntpost.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/helper/evntpost.cxx	18 Sep 2000 17:05:39 -0000	1.1.1.1
+++ vcl/source/helper/evntpost.cxx	6 Jan 2004 14:01:05 -0000	1.3
@@ -59,7 +59,7 @@
  *
  ************************************************************************/
 
-#pragma hdrstop
+
 
 #include "evntpost.hxx"
 #include "svapp.hxx"
@@ -69,8 +69,8 @@ namespace vcl
 
 EventPoster::EventPoster( const Link& rLink )
     : m_aLink(rLink)
-    , m_nId(0)
 {
+    m_nId = 0;
 }
 
 EventPoster::~EventPoster()
Index: vcl/source/helper/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/source/helper/makefile.mk,v
retrieving revision 1.11
retrieving revision 1.13
diff -u -p -u -r1.11 -r1.13
--- vcl/source/helper/makefile.mk	11 Apr 2003 17:29:42 -0000	1.11
+++ vcl/source/helper/makefile.mk	17 Mar 2004 13:57:06 -0000	1.13
@@ -77,11 +77,8 @@ TARGET=helper
 
 SLOFILES=\
 	$(SLO)$/evntpost.obj		\
+	$(SLO)$/xconnection.obj		\
 	$(SLO)$/threadex.obj
-
-.IF "$(remote)" == ""
-SLOFILES+=$(SLO)$/xconnection.obj
-.ENDIF
 
 # --- Targets ------------------------------------------------------
 
Index: vcl/source/src/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/source/src/makefile.mk,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -p -u -r1.3 -r1.6
--- vcl/source/src/makefile.mk	25 Oct 2002 11:45:39 -0000	1.3
+++ vcl/source/src/makefile.mk	21 May 2004 16:26:00 -0000	1.6
@@ -68,13 +68,12 @@ RESTARGET=vcl
 
 # --- Settings -----------------------------------------------------
 
-.INCLUDE :	svpre.mk
 .INCLUDE :	settings.mk
-.INCLUDE :	sv.mk
 
 # --- Files --------------------------------------------------------
 
-SRCFILES=			images.src			\
+SRS1NAME=$(TARGET)
+SRC1FILES=			images.src			\
 					menu.src			\
 					stdtext.src 		\
 					helptext.src		\
@@ -82,29 +81,10 @@ SRCFILES=			images.src			\
 					btntext.src
 
 RESLIB1NAME=		$(RESTARGET)
+RESLIB1IMAGES= $(PRJ)$/source/src
 RESLIB1SRSFILES=	$(SRS)$/svsrc.srs
-RESLIB1BMPS=		check.bmp			\
-					checkwin.bmp		\
-					checkos2.bmp		\
-					checkmac.bmp		\
-					checkunx.bmp		\
-					radio.bmp			\
-					radiowin.bmp		\
-					radioos2.bmp		\
-					radiomac.bmp		\
-					radiounx.bmp		\
-					msgbox.bmp			\
-					scrbmp.bmp			\
-					scrmsk.bmp			\
-					pin.bmp 			\
-					splhpin.bmp 		\
-					splvpin.bmp 		\
-					splharw.bmp 		\
-					splvarw.bmp         \
-					closedoc.bmp 		\
-					closedochc.bmp
-					
 
 # --- Targets ------------------------------------------------------
 
 .INCLUDE :	target.mk
+
Index: vcl/source/src/makefile.unx
===================================================================
RCS file: vcl/source/src/makefile.unx
diff -N vcl/source/src/makefile.unx
--- vcl/source/src/makefile.unx	27 Mar 2003 17:58:17 -0000	1.3
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,10 +0,0 @@
-#include <indepen.unx>
-
-SRCS = images.src
-
-SRSS = $(SRS)/source.src.srs
-
-BUILD_RESOURCES (vcl, $(STD_LANGUAGES),  $(SRSS))
-
-#include <stdtarg.unx>
-
Index: vcl/source/window/abstdlg.cxx
===================================================================
RCS file: vcl/source/window/abstdlg.cxx
diff -N vcl/source/window/abstdlg.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/source/window/abstdlg.cxx	5 Jan 2004 11:27:26 -0000	1.2
@@ -0,0 +1,84 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include "abstdlg.hxx"
+#include "cuilib.hxx"
+
+#include <osl/module.hxx>
+#include <tools/string.hxx>
+
+typedef VclAbstractDialogFactory* (__LOADONCALLAPI *FuncPtrCreateDialogFactory)();
+
+VclAbstractDialogFactory* VclAbstractDialogFactory::Create()
+{
+    FuncPtrCreateDialogFactory fp = 0;
+	static ::osl::Module aDialogLibrary;
+	if ( aDialogLibrary.is() || aDialogLibrary.load( String( RTL_CONSTASCII_USTRINGPARAM( DLL_NAME ) ) ) )
+        fp = ( VclAbstractDialogFactory* (__LOADONCALLAPI*)() )
+			aDialogLibrary.getSymbol( ::rtl::OUString::createFromAscii("CreateDialogFactory") );
+	if ( fp )
+		return fp();
+	return 0;
+}
+
+VclAbstractDialog::~VclAbstractDialog()
+{
+}
Index: vcl/source/window/accel.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/accel.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/window/accel.cxx	18 Sep 2000 17:05:39 -0000	1.1.1.1
+++ vcl/source/window/accel.cxx	6 Jan 2004 14:01:59 -0000	1.3
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_ACCEL_CXX
-
 #ifndef _LIST_HXX
 #include <tools/list.hxx>
 #endif
@@ -81,10 +79,10 @@
 #include <accel.hxx>
 #endif
 #ifndef _RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -419,7 +417,6 @@ void Accelerator::InsertItem( const ResI
 	USHORT				nAccelKeyId;
 	USHORT				bDisable;
 	KeyCode 			aKeyCode;
-	BOOL				bEnable 	= FALSE;
 	Accelerator*		pAutoAccel	= NULL;
 
 	GetRes( rResId.SetRT( RSC_ACCELITEM ) );
Index: vcl/source/window/accmgr.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/accmgr.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/window/accmgr.cxx	18 Sep 2000 17:05:40 -0000	1.1.1.1
+++ vcl/source/window/accmgr.cxx	6 Jan 2004 14:02:47 -0000	1.3
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_ACCMGR_CXX
-
 #ifndef _LIST_HXX
 #include <tools/list.hxx>
 #endif
@@ -78,7 +76,7 @@
 #include <accmgr.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
Index: vcl/source/window/brdwin.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/brdwin.cxx,v
retrieving revision 1.9.82.1
retrieving revision 1.14
diff -u -p -u -r1.9.82.1 -r1.14
--- vcl/source/window/brdwin.cxx	9 Jan 2004 18:13:54 -0000	1.9.82.1
+++ vcl/source/window/brdwin.cxx	17 Jun 2004 12:45:34 -0000	1.14
@@ -59,12 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_BRDWIN_CXX
-
-#ifdef REMOTE_APPSERVER
-#include <rmwindow.hxx>
-#endif
-
 #ifndef _SV_SVIDS_HRC
 #include <svids.hrc>
 #endif
@@ -101,16 +95,14 @@
 #ifndef _SV_HELP_HXX
 #include <help.hxx>
 #endif
+#ifndef _SV_EDIT_HXX
+#include <edit.hxx>
+#endif
 #ifndef _SV_BRDWIN_HXX
 #include <brdwin.hxx>
 #endif
-
 #include <tools/debug.hxx>
 
-#include <rvp.hxx>
-
-#pragma hdrstop
-
 using namespace ::com::sun::star::uno;
 
 // =======================================================================
@@ -968,8 +960,8 @@ void ImplNoBorderWindowView::Init( Outpu
 
 // -----------------------------------------------------------------------
 
-void ImplNoBorderWindowView::GetBorder( long& rLeftBorder, long& rTopBorder,
-										long& rRightBorder, long& rBottomBorder ) const
+void ImplNoBorderWindowView::GetBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+										sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const
 {
 	rLeftBorder 	= 0;
 	rTopBorder		= 0;
@@ -1043,8 +1035,8 @@ void ImplSmallBorderWindowView::Init( Ou
 
 // -----------------------------------------------------------------------
 
-void ImplSmallBorderWindowView::GetBorder( long& rLeftBorder, long& rTopBorder,
-										   long& rRightBorder, long& rBottomBorder ) const
+void ImplSmallBorderWindowView::GetBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+										   sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const
 {
 	rLeftBorder 	= mnLeftBorder;
 	rTopBorder		= mnTopBorder;
@@ -1067,6 +1059,112 @@ void ImplSmallBorderWindowView::DrawWind
 	if ( nBorderStyle & WINDOW_BORDER_NOBORDER )
 		return;
 
+    BOOL bNativeOK = FALSE;
+    // for native widget drawing we must find out what
+    // control this border belongs to
+    Window *pWin = NULL, *pCtrl = NULL;
+    if( mpOutDev->GetOutDevType() == OUTDEV_WINDOW )
+        pWin = (Window*) mpOutDev;
+
+    ControlType aCtrlType = 0;
+    ControlPart aCtrlPart = PART_ENTIRE_CONTROL;
+
+    if( pWin && (pCtrl = mpBorderWindow->GetWindow( WINDOW_CLIENT )) != NULL )
+    {
+        switch( pCtrl->GetType() )
+        {
+            case WINDOW_EDIT:
+            case WINDOW_MULTILINEEDIT:
+            case WINDOW_PATTERNFIELD:
+            case WINDOW_METRICFIELD:
+            case WINDOW_CURRENCYFIELD:
+            case WINDOW_DATEFIELD:
+            case WINDOW_TIMEFIELD:
+            case WINDOW_LONGCURRENCYFIELD:
+            case WINDOW_NUMERICFIELD:
+            case WINDOW_SPINFIELD:
+                if( pCtrl->GetStyle() & WB_SPIN )
+                    aCtrlType = CTRL_SPINBOX;
+                else
+                    aCtrlType = CTRL_EDITBOX;
+                break;
+
+            case WINDOW_LISTBOX:
+            case WINDOW_MULTILISTBOX:
+            case WINDOW_TREELISTBOX:
+                aCtrlType = CTRL_LISTBOX;
+                if( pCtrl->GetStyle() & WB_DROPDOWN )
+                    aCtrlPart = PART_ENTIRE_CONTROL;
+                else
+                    aCtrlPart = PART_WINDOW;
+                break;
+
+            case WINDOW_LISTBOXWINDOW:
+                aCtrlType = CTRL_LISTBOX;
+                aCtrlPart = PART_WINDOW;
+                break;
+
+            case WINDOW_COMBOBOX:
+            case WINDOW_PATTERNBOX:			
+            case WINDOW_NUMERICBOX:			
+            case WINDOW_METRICBOX:			
+            case WINDOW_CURRENCYBOX:
+            case WINDOW_DATEBOX:		
+            case WINDOW_TIMEBOX:			
+            case WINDOW_LONGCURRENCYBOX:
+                if( pCtrl->GetStyle() & WB_DROPDOWN )
+                {
+                    aCtrlType = CTRL_COMBOBOX;
+                    aCtrlPart = PART_ENTIRE_CONTROL;
+                }
+                else
+                {
+                    aCtrlType = CTRL_LISTBOX;
+                    aCtrlPart = PART_WINDOW;
+                }
+                break;
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    if ( aCtrlType && pCtrl->IsNativeControlSupported(aCtrlType, aCtrlPart) )
+    {
+        ImplControlValue aControlValue;
+        ControlState     nState = CTRL_STATE_ENABLED;
+
+        if ( !pWin->IsEnabled() )
+            nState &= ~CTRL_STATE_ENABLED;
+        if ( pWin->HasFocus() )
+            nState |= CTRL_STATE_FOCUSED;
+        BOOL bMouseOver = FALSE;
+        Window *pCtrlChild = pCtrl->GetWindow( WINDOW_FIRSTCHILD );
+        while( pCtrlChild && !(bMouseOver = pCtrlChild->IsMouseOver()) )
+            pCtrlChild = pCtrlChild->GetWindow( WINDOW_NEXT );
+    	
+        if( bMouseOver )
+            nState |= CTRL_STATE_ROLLOVER;
+
+        Point aPoint;
+        Region aCtrlRegion( Rectangle( aPoint, Size( mnWidth, mnHeight ) ) );
+        bNativeOK = pWin->DrawNativeControl( aCtrlType, aCtrlPart, aCtrlRegion, nState,
+                aControlValue, rtl::OUString() );
+
+        // if the native theme draws the spinbuttons in one call, make sure the proper settings
+        // are passed, this might force a redraw though.... (TODO: improve)
+        if ( (aCtrlType == CTRL_SPINBOX) && !pCtrl->IsNativeControlSupported( CTRL_SPINBOX, PART_BUTTON_UP ) )
+        {
+            Edit *pEdit = ((Edit*) pCtrl)->GetSubEdit();
+            if ( pEdit )
+                pCtrl->Paint( Rectangle() );  // make sure the buttons are also drawn as they might overwrite the border
+        }
+    }
+
+    if( bNativeOK )
+        return;
+
 	if ( nDrawFlags & BORDERWINDOW_DRAW_FRAME )
 	{
 		if ( nBorderStyle & WINDOW_BORDER_ACTIVE )
@@ -1092,8 +1190,11 @@ void ImplSmallBorderWindowView::DrawWind
 				nStyle |= FRAME_DRAW_MONO;
 			if ( nBorderStyle & WINDOW_BORDER_MENU )
 				nStyle |= FRAME_DRAW_MENU;
+            // tell DrawFrame that we're drawing a window border of a frame window to avoid round corners
+            if( pWin && pWin == pWin->ImplGetFrameWindow() )
+                nStyle |= FRAME_DRAW_WINDOWBORDER;  
 
-			DecorationView	aDecoView( mpOutDev );
+            DecorationView	aDecoView( mpOutDev );
 			Point			aTmpPoint;
 			Rectangle		aInRect( aTmpPoint, Size( mnWidth, mnHeight ) );
 			aDecoView.DrawFrame( aInRect, nStyle );
@@ -1301,8 +1402,8 @@ void ImplStdBorderWindowView::Init( Outp
 
 // -----------------------------------------------------------------------
 
-void ImplStdBorderWindowView::GetBorder( long& rLeftBorder, long& rTopBorder,
-										 long& rRightBorder, long& rBottomBorder ) const
+void ImplStdBorderWindowView::GetBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+										 sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const
 {
 	rLeftBorder 	= maFrameData.mnLeftBorder;
 	rTopBorder		= maFrameData.mnTopBorder;
@@ -1375,7 +1476,6 @@ void ImplStdBorderWindowView::DrawWindow
 			pDev->SetTextColor( rStyleSettings.GetDeactiveTextColor() );
 			aColor2 = rStyleSettings.GetDeactiveColor2();
 		}
-#ifndef REMOTE_APPSERVER
 		BOOL bDrawRect;
 		if ( pDev->GetColorCount() >= 256 )
 		{
@@ -1420,7 +1520,6 @@ void ImplStdBorderWindowView::DrawWindow
 			bDrawRect = TRUE;
 
 		if ( bDrawRect )
-#endif
 			pDev->DrawRect( aInRect );
 
 		if ( pData->mnTitleType != BORDERWINDOW_TITLE_TEAROFF )
@@ -1519,1795 +1618,52 @@ void ImplStdBorderWindowView::DrawWindow
 	}
 }
 
-// =======================================================================
-
-// ---------------------------
-// - ImplOS2BorderWindowView -
-// ---------------------------
-
-class ImplOS2BorderWindowView : public ImplBorderWindowView
-{
-	ImplBorderFrameData 	maFrameData;
-
-public:
-							ImplOS2BorderWindowView( ImplBorderWindow* pBorderWindow );
-							~ImplOS2BorderWindowView();
-
-	virtual BOOL			MouseMove( const MouseEvent& rMEvt );
-	virtual BOOL			MouseButtonDown( const MouseEvent& rMEvt );
-	virtual BOOL			Tracking( const TrackingEvent& rTEvt );
-	virtual USHORT			RequestHelp( const Point& rPos, Rectangle& rHelpRect );
-
-	virtual void			Init( OutputDevice* pDev, long nWidth, long nHeight );
-	virtual void			GetBorder( long& rLeftBorder, long& rTopBorder,
-									   long& rRightBorder, long& rBottomBorder ) const;
-	virtual long			CalcTitleWidth() const;
-	virtual void			DrawWindow( USHORT nDrawFlags, OutputDevice* pOutDev, const Point* pOffset );
-
-	Rectangle				DrawOS2TitleButton( const Rectangle& rRect, USHORT nStyle );
-};
-
-// Aus decoview.cxx
-void ImplDrawOS2Symbol( OutputDevice* pDev, const Rectangle& rRect,
-						USHORT nStyle, BOOL bClose );
 
 // =======================================================================
-
-ImplOS2BorderWindowView::ImplOS2BorderWindowView( ImplBorderWindow* pBorderWindow )
-{
-	maFrameData.mpBorderWindow	= pBorderWindow;
-	maFrameData.mbDragFull		= FALSE;
-	maFrameData.mnHitTest		= 0;
-	maFrameData.mnPinState		= 0;
-	maFrameData.mnCloseState	= 0;
-	maFrameData.mnRollState 	= 0;
-	maFrameData.mnDockState 	= 0;
-	maFrameData.mnHideState 	= 0;
-	maFrameData.mnHelpState 	= 0;
-}
-
-// -----------------------------------------------------------------------
-
-ImplOS2BorderWindowView::~ImplOS2BorderWindowView()
-{
-}
-
-// -----------------------------------------------------------------------
-
-BOOL ImplOS2BorderWindowView::MouseMove( const MouseEvent& rMEvt )
-{
-	return ImplMouseMove( &maFrameData, rMEvt );
-}
-
-// -----------------------------------------------------------------------
-
-BOOL ImplOS2BorderWindowView::MouseButtonDown( const MouseEvent& rMEvt )
-{
-	return ImplMouseButtonDown( &maFrameData, rMEvt );
-}
-
-// -----------------------------------------------------------------------
-
-BOOL ImplOS2BorderWindowView::Tracking( const TrackingEvent& rTEvt )
-{
-	return ImplTracking( &maFrameData, rTEvt );
-}
-
-// -----------------------------------------------------------------------
-
-USHORT ImplOS2BorderWindowView::RequestHelp( const Point& rPos, Rectangle& rHelpRect )
+void ImplBorderWindow::ImplInit( Window* pParent,
+								 WinBits nStyle, USHORT nTypeStyle,
+								 const ::com::sun::star::uno::Any& aSystemToken )
 {
-	return ImplRequestHelp( &maFrameData, rPos, rHelpRect );
+	ImplInit( pParent, nStyle, nTypeStyle, NULL );
 }
 
-// -----------------------------------------------------------------------
-
-void ImplOS2BorderWindowView::Init( OutputDevice* pDev, long nWidth, long nHeight )
+void ImplBorderWindow::ImplInit( Window* pParent,
+								 WinBits nStyle, USHORT nTypeStyle,
+								 SystemParentData* pSystemParentData
+								 )
 {
-	ImplBorderFrameData*	pData = &maFrameData;
-	ImplBorderWindow*		pBorderWindow = maFrameData.mpBorderWindow;
-	const StyleSettings&	rStyleSettings = pDev->GetSettings().GetStyleSettings();
-	DecorationView			aDecoView( pDev );
-	Rectangle				aRect( 0, 0, 10, 10 );
-	Rectangle				aCalcRect = aDecoView.DrawFrame( aRect, FRAME_DRAW_DOUBLEOUT | FRAME_DRAW_NODRAW );
-
-	pData->mpOutDev 		= pDev;
-	pData->mnWidth			= nWidth;
-	pData->mnHeight 		= nHeight;
-
-	pData->mnTitleType		= pBorderWindow->mnTitleType;
-	pData->mbFloatWindow	= pBorderWindow->mbFloatWindow;
-
-	if ( !(pBorderWindow->GetStyle() & WB_MOVEABLE) || (pData->mnTitleType == BORDERWINDOW_TITLE_NONE) )
-		pData->mnBorderSize = 0;
-	else if ( pData->mnTitleType == BORDERWINDOW_TITLE_TEAROFF )
-		pData->mnBorderSize = 0;
-	else
-		pData->mnBorderSize = rStyleSettings.GetBorderSize();
-	pData->mnLeftBorder 	= aCalcRect.Left();
-	pData->mnTopBorder		= aCalcRect.Top();
-	pData->mnRightBorder	= aRect.Right()-aCalcRect.Right();
-	pData->mnBottomBorder	= aRect.Bottom()-aCalcRect.Bottom();
-	pData->mnLeftBorder    += pData->mnBorderSize;
-	pData->mnTopBorder	   += pData->mnBorderSize;
-	pData->mnRightBorder   += pData->mnBorderSize;
-	pData->mnBottomBorder  += pData->mnBorderSize;
-	pData->mnNoTitleTop 	= pData->mnTopBorder;
+	// Alle WindowBits entfernen, die wir nicht haben wollen
+	WinBits nOrgStyle = nStyle;
+	WinBits nTestStyle = (WB_MOVEABLE | WB_SIZEABLE | WB_ROLLABLE | WB_PINABLE | WB_CLOSEABLE | WB_STANDALONE | WB_DIALOGCONTROL | WB_NODIALOGCONTROL | WB_SYSTEMFLOATWIN | WB_INTROWIN | WB_TOOLTIPWIN | WB_NOSHADOW);
+	if ( nTypeStyle & BORDERWINDOW_STYLE_APP )
+		nTestStyle |= WB_APP;
+	nStyle &= nTestStyle;
 
-	ImplInitTitle( &maFrameData );
-	if ( pData->mnTitleHeight )
+	mbBorderWin 		= TRUE;
+	mbSmallOutBorder	= FALSE;
+	if ( nTypeStyle & BORDERWINDOW_STYLE_FRAME )
 	{
-		// Wegen 3D-Border bei aktiver Darstellung
-		if ( pData->mnTitleType != BORDERWINDOW_TITLE_TEAROFF )
-		{
-			long nTextHeight = pBorderWindow->GetTextHeight();
-			nTextHeight += 2;
-			if ( nTextHeight > pData->mnTitleHeight )
-				pData->mnTitleHeight = nTextHeight;
-		}
-
-		pData->maTitleRect.Left()	 = pData->mnLeftBorder;
-		pData->maTitleRect.Right()	 = nWidth-pData->mnRightBorder-1;
-		pData->maTitleRect.Top()	 = pData->mnTopBorder;
-		pData->maTitleRect.Bottom()  = pData->maTitleRect.Top()+pData->mnTitleHeight-1;
-
-		if ( pData->mnTitleType & (BORDERWINDOW_TITLE_NORMAL | BORDERWINDOW_TITLE_SMALL) )
-		{
-			long nLeft			= pData->maTitleRect.Left();
-			long nRight 		= pData->maTitleRect.Right();
-			long nItemTop		= pData->maTitleRect.Top();
-			long nItemBottom	= pData->maTitleRect.Bottom();
-
-			if ( pBorderWindow->mbHelpBtn )
-			{
-				pData->maHelpRect.Top()    = nItemTop;
-				pData->maHelpRect.Bottom() = nItemBottom;
-				pData->maHelpRect.Left()   = nLeft;
-				pData->maHelpRect.Right()  = pData->maHelpRect.Left()+pData->maHelpRect.GetHeight()-1;
-				nLeft += pData->maHelpRect.GetWidth();
-			}
-
-			if ( pBorderWindow->GetStyle() & WB_PINABLE )
-			{
-				nLeft += 2;
-				Image aImage;
-				ImplGetPinImage( 0, 0, aImage );
-				pData->maPinRect.Top()	  = nItemTop;
-				pData->maPinRect.Bottom() = nItemBottom;
-				pData->maPinRect.Left()   = nLeft;
-				pData->maPinRect.Right()  = pData->maPinRect.Left()+aImage.GetSizePixel().Width();
-				nLeft += pData->maPinRect.GetWidth();
-			}
-
-			if ( pBorderWindow->mbDockBtn )
-			{
-				pData->maDockRect.Top()    = nItemTop;
-				pData->maDockRect.Bottom() = nItemBottom;
-				pData->maDockRect.Right()  = nRight;
-				pData->maDockRect.Left()   = pData->maDockRect.Right()-pData->maDockRect.GetHeight()+1;
-				nRight -= pData->maDockRect.GetWidth();
-			}
-
-			if ( pBorderWindow->mbHideBtn )
-			{
-				pData->maHideRect.Top()    = nItemTop;
-				pData->maHideRect.Bottom() = nItemBottom;
-				pData->maHideRect.Right()  = nRight;
-				pData->maHideRect.Left()   = pData->maHideRect.Right()-pData->maHideRect.GetHeight()+1;
-				nRight -= pData->maHideRect.GetWidth();
-			}
-
-			if ( pBorderWindow->GetStyle() & WB_ROLLABLE )
-			{
-				pData->maRollRect.Top()    = nItemTop;
-				pData->maRollRect.Bottom() = nItemBottom;
-				pData->maRollRect.Right()  = nRight;
-				pData->maRollRect.Left()   = pData->maRollRect.Right()-pData->maRollRect.GetHeight()+1;
-				nRight -= pData->maRollRect.GetWidth();
-			}
-
-			if ( pBorderWindow->GetStyle() & WB_CLOSEABLE )
-			{
-				pData->maCloseRect.Top()	= nItemTop;
-				pData->maCloseRect.Bottom() = nItemBottom;
-				pData->maCloseRect.Right()	= nRight;
-				pData->maCloseRect.Left()	= pData->maCloseRect.Right()-pData->maCloseRect.GetHeight()+1;
-				nRight -= pData->maCloseRect.GetWidth();
-			}
-		}
-		else
-		{
-			pData->maPinRect.SetEmpty();
-			pData->maCloseRect.SetEmpty();
-			pData->maDockRect.SetEmpty();
-			pData->maHideRect.SetEmpty();
-			pData->maRollRect.SetEmpty();
-			pData->maHelpRect.SetEmpty();
-		}
-
-		pData->mnTopBorder	+= pData->mnTitleHeight;
+		mbOverlapWin	= TRUE;
+		mbFrame 		= TRUE;
+		mbFrameBorder	= FALSE;
+        // closeable windows may have a border as well, eg. system floating windows without caption
+		if ( (nOrgStyle & (WB_BORDER | WB_NOBORDER | WB_MOVEABLE | WB_SIZEABLE/* | WB_CLOSEABLE*/)) == WB_BORDER )
+			mbSmallOutBorder = TRUE;
 	}
-	else
+	else if ( nTypeStyle & BORDERWINDOW_STYLE_OVERLAP )
 	{
-		pData->maTitleRect.SetEmpty();
-		pData->maPinRect.SetEmpty();
-		pData->maCloseRect.SetEmpty();
-		pData->maDockRect.SetEmpty();
-		pData->maHideRect.SetEmpty();
-		pData->maRollRect.SetEmpty();
-		pData->maHelpRect.SetEmpty();
+		mbOverlapWin	= TRUE;
+		mbFrameBorder	= TRUE;
 	}
-}
-
-// -----------------------------------------------------------------------
-
-void ImplOS2BorderWindowView::GetBorder( long& rLeftBorder, long& rTopBorder,
-										 long& rRightBorder, long& rBottomBorder ) const
-{
-	rLeftBorder 	= maFrameData.mnLeftBorder;
-	rTopBorder		= maFrameData.mnTopBorder;
-	rRightBorder	= maFrameData.mnRightBorder;
-	rBottomBorder	= maFrameData.mnBottomBorder;
-}
-
-// -----------------------------------------------------------------------
-
-long ImplOS2BorderWindowView::CalcTitleWidth() const
-{
-	return ImplCalcTitleWidth( &maFrameData );
-}
-
-// -----------------------------------------------------------------------
-
-void ImplOS2BorderWindowView::DrawWindow( USHORT nDrawFlags, OutputDevice* pOutDev, const Point* pOffset )
-{
-	ImplBorderFrameData*	pData = &maFrameData;
-	OutputDevice*			pDev = pOutDev ? pOutDev : pData->mpOutDev;
-	ImplBorderWindow*		pBorderWindow = pData->mpBorderWindow;
-	Point					aTmpPoint( pOffset ? *pOffset : Point() );
-	Rectangle				aInRect( aTmpPoint, Size( pData->mnWidth, pData->mnHeight ) );
-	const StyleSettings&	rStyleSettings = pDev->GetSettings().GetStyleSettings();
-	DecorationView			aDecoView( pDev );
-	USHORT					nStyle;
-	BOOL					bActive = pBorderWindow->IsDisplayActive();
+	else
+		mbFrameBorder	= FALSE;
 
-	// Draw Frame
-	if ( nDrawFlags & BORDERWINDOW_DRAW_FRAME )
-		nStyle = 0;
+	if ( nTypeStyle & BORDERWINDOW_STYLE_FLOAT )
+		mbFloatWindow = TRUE;
 	else
-		nStyle = FRAME_DRAW_NODRAW;
-	aInRect = aDecoView.DrawFrame( aInRect, FRAME_DRAW_DOUBLEOUT | nStyle );
+		mbFloatWindow = FALSE;
 
-	// Draw Border
-	pDev->SetLineColor();
-	long nBorderSize = pData->mnBorderSize;
-	if ( (nDrawFlags & BORDERWINDOW_DRAW_BORDER) && nBorderSize )
-	{
-		if ( bActive )
-			pDev->SetFillColor( rStyleSettings.GetActiveBorderColor() );
-		else
-			pDev->SetFillColor( rStyleSettings.GetDeactiveBorderColor() );
-		pDev->DrawRect( Rectangle( Point( aInRect.Left(), aInRect.Top() ),
-								   Size( aInRect.GetWidth(), nBorderSize ) ) );
-		pDev->DrawRect( Rectangle( Point( aInRect.Left(), aInRect.Top()+nBorderSize ),
-								   Size( nBorderSize, aInRect.GetHeight()-nBorderSize ) ) );
-		pDev->DrawRect( Rectangle( Point( aInRect.Left(), aInRect.Bottom()-nBorderSize+1 ),
-								   Size( aInRect.GetWidth(), nBorderSize ) ) );
-		pDev->DrawRect( Rectangle( Point( aInRect.Right()-nBorderSize+1, aInRect.Top()+nBorderSize ),
-								   Size( nBorderSize, aInRect.GetHeight()-nBorderSize ) ) );
-	}
-
-	// Draw Title
-	if ( (nDrawFlags & BORDERWINDOW_DRAW_TITLE) && !pData->maTitleRect.IsEmpty() )
-	{
-		aInRect = pData->maTitleRect;
-
-		if ( !pData->maHelpRect.IsEmpty() )
-			aInRect.Left() = pData->maHelpRect.Right()+1;
-
-		if ( !pData->maCloseRect.IsEmpty() )
-			aInRect.Right() = pData->maCloseRect.Left()-1;
-		else if ( !pData->maRollRect.IsEmpty() )
-			aInRect.Right() = pData->maRollRect.Left()-1;
-		else if ( !pData->maHideRect.IsEmpty() )
-			aInRect.Right() = pData->maHideRect.Left()-1;
-		else if ( !pData->maDockRect.IsEmpty() )
-			aInRect.Right() = pData->maDockRect.Left()-1;
-
-        if ( pOffset )
-            aInRect.Move( pOffset->X(), pOffset->Y() );
-
-		if ( bActive )
-		{
-			pDev->SetFillColor( rStyleSettings.GetActiveColor() );
-			pDev->SetTextColor( rStyleSettings.GetActiveTextColor() );
-		}
-		else
-		{
-			pDev->SetFillColor( rStyleSettings.GetDeactiveColor() );
-			pDev->SetTextColor( rStyleSettings.GetDeactiveTextColor() );
-		}
-		pDev->DrawRect( aInRect );
-
-		if ( pData->mnTitleType != BORDERWINDOW_TITLE_TEAROFF )
-		{
-			Rectangle aOrgInRect = aInRect;
-
-			if ( !pData->maPinRect.IsEmpty() )
-				aInRect.Left() += pData->maPinRect.Right();
-
-			aInRect.Left()	+= 2;
-			aInRect.Right() -= 2;
-
-			pDev->DrawText( aInRect, pBorderWindow->GetText(),
-							TEXT_DRAW_LEFT | TEXT_DRAW_VCENTER |
-							TEXT_DRAW_ENDELLIPSIS | TEXT_DRAW_CLIP );
-
-			if ( bActive )
-				aDecoView.DrawFrame( aOrgInRect, rStyleSettings.GetShadowColor(), rStyleSettings.GetLightColor() );
-		}
-	}
-
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_CLOSE) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maCloseRect.IsEmpty() )
-	{
-		Rectangle aRect = DrawOS2TitleButton( pData->maCloseRect, pData->mnCloseState );
-		if ( pOffset )
-			aRect.Move( pOffset->X(), pOffset->Y() );
-		ImplDrawOS2Symbol( pDev, aRect, pData->mnCloseState, TRUE );
-	}
-
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_DOCK) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maDockRect.IsEmpty() )
-	{
-		Rectangle aRect = DrawOS2TitleButton( pData->maDockRect, pData->mnDockState );
-		if ( pOffset )
-			aRect.Move( pOffset->X(), pOffset->Y() );
-		ImplDrawOS2Symbol( pDev, aRect, pData->mnDockState, FALSE );
-	}
-
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_HIDE) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maHideRect.IsEmpty() )
-	{
-		Rectangle aRect = DrawOS2TitleButton( pData->maHideRect, pData->mnHideState );
-		aRect.Left()   += 2;
-		aRect.Top()    += 2;
-		aRect.Right()  -= 2;
-		aRect.Bottom() -= 2;
-		if ( pOffset )
-			aRect.Move( pOffset->X(), pOffset->Y() );
-		ImplDrawOS2Symbol( pDev, aRect, pData->mnHideState, FALSE );
-	}
-
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_ROLL) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maRollRect.IsEmpty() )
-	{
-		Rectangle aRect = DrawOS2TitleButton( pData->maRollRect, pData->mnRollState );
-		if ( !pBorderWindow->mbRollUp )
-			aRect.Bottom() = aRect.Top()+6;
-		if ( pOffset )
-			aRect.Move( pOffset->X(), pOffset->Y() );
-		ImplDrawOS2Symbol( pDev, aRect, pData->mnRollState, FALSE );
-		if ( pBorderWindow->mbRollUp )
-		{
-			aRect.Left()   += 3;
-			aRect.Top()    += 3;
-			aRect.Right()  -= 3;
-			aRect.Bottom() -= 3;
-			pDev->SetFillColor();
-			if ( nStyle & (BUTTON_DRAW_PRESSED | BUTTON_DRAW_CHECKED) )
-				pDev->SetLineColor( rStyleSettings.GetShadowColor() );
-			else
-				pDev->SetLineColor( rStyleSettings.GetLightColor() );
-			pDev->DrawLine( aRect.TopLeft(), aRect.TopRight() );
-			aRect.Top()++;
-			if ( nStyle & (BUTTON_DRAW_PRESSED | BUTTON_DRAW_CHECKED) )
-				pDev->SetLineColor( rStyleSettings.GetLightColor() );
-			else
-				pDev->SetLineColor( rStyleSettings.GetShadowColor() );
-			pDev->DrawLine( aRect.TopLeft(), aRect.TopRight() );
-		}
-	}
-
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_HELP) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maHelpRect.IsEmpty() )
-	{
-		Rectangle aRect = DrawOS2TitleButton( pData->maHelpRect, pData->mnHelpState );
-		if ( pOffset )
-			aRect.Move( pOffset->X(), pOffset->Y() );
-		ImplDrawBrdWinSymbol( pDev, aRect, SYMBOL_HELP );
-	}
-
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_PIN) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maPinRect.IsEmpty() )
-	{
-		Image aImage;
-		ImplGetPinImage( pData->mnPinState, pBorderWindow->mbPined, aImage );
-		Size  aImageSize = aImage.GetSizePixel();
-		long  nRectHeight = pData->maPinRect.GetHeight();
-        Point aPos = pData->maPinRect.TopLeft();
-        if( pOffset )
-            aPos += *pOffset;
-		if ( nRectHeight < aImageSize.Height() )
-		{
-			pDev->DrawImage( aPos,
-							 Size( aImageSize.Width(), nRectHeight ),
-							 aImage );
-		}
-		else
-		{
-			pDev->DrawImage( Point( aPos.X(),
-									aPos.Y()+(nRectHeight-aImageSize.Height())/2 ),
-							 aImage );
-		}
-	}
-}
-
-// -----------------------------------------------------------------------
-
-Rectangle ImplOS2BorderWindowView::DrawOS2TitleButton( const Rectangle& rRect, USHORT )
-{
-	OutputDevice*			pDev = maFrameData.mpOutDev;
-	const StyleSettings&	rStyleSettings = pDev->GetSettings().GetStyleSettings();
-	Rectangle				aRect = rRect;
-
-	pDev->SetLineColor();
-	pDev->SetFillColor( rStyleSettings.GetFaceColor() );
-	pDev->DrawRect( aRect );
-
-	long nExtraWidth  = ((aRect.GetWidth()*150)+500)/1000;
-	long nExtraHeight = ((aRect.GetHeight()*150)+500)/1000;
-	if ( !nExtraWidth )
-		nExtraWidth = 1;
-	if ( !nExtraHeight )
-		nExtraHeight = 1;
-	aRect.Left()	+= nExtraWidth;
-	aRect.Right()	-= nExtraWidth;
-	aRect.Top() 	+= nExtraHeight;
-	aRect.Bottom()	-= nExtraHeight;
-	return aRect;
-}
-
-// =======================================================================
-
-// ---------------------------
-// - ImplUnxBorderWindowView -
-// ---------------------------
-
-class ImplUnxBorderWindowView : public ImplBorderWindowView
-{
-	ImplBorderFrameData 	maFrameData;
-
-public:
-							ImplUnxBorderWindowView( ImplBorderWindow* pBorderWindow );
-							~ImplUnxBorderWindowView();
-
-	virtual BOOL			MouseMove( const MouseEvent& rMEvt );
-	virtual BOOL			MouseButtonDown( const MouseEvent& rMEvt );
-	virtual BOOL			Tracking( const TrackingEvent& rTEvt );
-	virtual USHORT			RequestHelp( const Point& rPos, Rectangle& rHelpRect );
-
-	virtual void			Init( OutputDevice* pDev, long nWidth, long nHeight );
-	virtual void			GetBorder( long& rLeftBorder, long& rTopBorder,
-									   long& rRightBorder, long& rBottomBorder ) const;
-	virtual long			CalcTitleWidth() const;
-	virtual void			DrawWindow( USHORT nDrawFlags, OutputDevice* pOutDev, const Point* pOffset );
-
-	Rectangle				DrawUnxTitleButton( const Rectangle& rRect, USHORT nStyle );
-};
-
-// =======================================================================
-
-ImplUnxBorderWindowView::ImplUnxBorderWindowView( ImplBorderWindow* pBorderWindow )
-{
-	maFrameData.mpBorderWindow	= pBorderWindow;
-	maFrameData.mbDragFull		= FALSE;
-	maFrameData.mnHitTest		= 0;
-	maFrameData.mnPinState		= 0;
-	maFrameData.mnCloseState	= 0;
-	maFrameData.mnRollState 	= 0;
-	maFrameData.mnDockState 	= 0;
-	maFrameData.mnHideState 	= 0;
-	maFrameData.mnHelpState 	= 0;
-}
-
-// -----------------------------------------------------------------------
-
-ImplUnxBorderWindowView::~ImplUnxBorderWindowView()
-{
-}
-
-// -----------------------------------------------------------------------
-
-BOOL ImplUnxBorderWindowView::MouseMove( const MouseEvent& rMEvt )
-{
-	return ImplMouseMove( &maFrameData, rMEvt );
-}
-
-// -----------------------------------------------------------------------
-
-BOOL ImplUnxBorderWindowView::MouseButtonDown( const MouseEvent& rMEvt )
-{
-	return ImplMouseButtonDown( &maFrameData, rMEvt );
-}
-
-// -----------------------------------------------------------------------
-
-BOOL ImplUnxBorderWindowView::Tracking( const TrackingEvent& rTEvt )
-{
-	return ImplTracking( &maFrameData, rTEvt );
-}
-
-// -----------------------------------------------------------------------
-
-USHORT ImplUnxBorderWindowView::RequestHelp( const Point& rPos, Rectangle& rHelpRect )
-{
-	return ImplRequestHelp( &maFrameData, rPos, rHelpRect );
-}
-
-// -----------------------------------------------------------------------
-
-void ImplUnxBorderWindowView::Init( OutputDevice* pDev, long nWidth, long nHeight )
-{
-	ImplBorderFrameData*	pData = &maFrameData;
-	ImplBorderWindow*		pBorderWindow = maFrameData.mpBorderWindow;
-	const StyleSettings&	rStyleSettings = pDev->GetSettings().GetStyleSettings();
-	DecorationView			aDecoView( pDev );
-	Rectangle				aRect( 0, 0, 10, 10 );
-	Rectangle				aCalcRect = aDecoView.DrawFrame( aRect, FRAME_DRAW_DOUBLEOUT | FRAME_DRAW_NODRAW );
-
-	pData->mpOutDev 		= pDev;
-	pData->mnWidth			= nWidth;
-	pData->mnHeight 		= nHeight;
-
-	pData->mnTitleType		= pBorderWindow->mnTitleType;
-	pData->mbFloatWindow	= pBorderWindow->mbFloatWindow;
-
-	if ( !(pBorderWindow->GetStyle() & WB_MOVEABLE) ||
-		 (pData->mnTitleType == BORDERWINDOW_TITLE_NONE) )
-		pData->mnBorderSize = 0;
-	else if ( pData->mnTitleType == BORDERWINDOW_TITLE_TEAROFF )
-		pData->mnBorderSize = 0;
-	else
-	{
-		pData->mnBorderSize = rStyleSettings.GetBorderSize();
-		if ( pData->mnBorderSize < 3 )
-			pData->mnBorderSize = 3;
-		aCalcRect = aRect;
-	}
-	pData->mnLeftBorder 	= aCalcRect.Left();
-	pData->mnTopBorder		= aCalcRect.Top();
-	pData->mnRightBorder	= aRect.Right()-aCalcRect.Right();
-	pData->mnBottomBorder	= aRect.Bottom()-aCalcRect.Bottom();
-	pData->mnLeftBorder    += pData->mnBorderSize;
-	pData->mnTopBorder	   += pData->mnBorderSize;
-	pData->mnRightBorder   += pData->mnBorderSize;
-	pData->mnBottomBorder  += pData->mnBorderSize;
-	pData->mnNoTitleTop 	= pData->mnTopBorder;
-
-	ImplInitTitle( &maFrameData );
-	if ( pData->mnTitleHeight )
-	{
-		pData->maTitleRect.Left()	 = pData->mnLeftBorder;
-		pData->maTitleRect.Right()	 = nWidth-pData->mnRightBorder-1;
-		pData->maTitleRect.Top()	 = pData->mnTopBorder;
-		pData->maTitleRect.Bottom()  = pData->maTitleRect.Top() + pData->mnTitleHeight - 1;
-
-		if ( pData->mnTitleType & (BORDERWINDOW_TITLE_NORMAL | BORDERWINDOW_TITLE_SMALL) )
-		{
-			long nLeft			= pData->maTitleRect.Left();
-			long nRight 		= pData->maTitleRect.Right();
-			long nItemTop		= pData->maTitleRect.Top();
-			long nItemBottom	= pData->maTitleRect.Bottom();
-
-			if ( pBorderWindow->GetStyle() & WB_CLOSEABLE )
-			{
-				pData->maCloseRect.Top()	= nItemTop;
-				pData->maCloseRect.Bottom() = nItemBottom;
-				pData->maCloseRect.Left()	= nLeft;
-				pData->maCloseRect.Right()	= nLeft + pData->maCloseRect.GetHeight();
-				nLeft += pData->maCloseRect.GetWidth() + 2;
-			}
-
-			if ( pBorderWindow->GetStyle() & WB_PINABLE )
-			{
-				Image aImage;
-				ImplGetPinImage( 0, 0, aImage );
-				pData->maPinRect.Top()	  = nItemTop;
-				pData->maPinRect.Bottom() = nItemBottom;
-				pData->maPinRect.Left()   = nLeft;
-				pData->maPinRect.Right()  = pData->maPinRect.Left() + aImage.GetSizePixel().Width();
-				nLeft += pData->maPinRect.GetWidth();
-			}
-
-			if ( pBorderWindow->mbDockBtn )
-			{
-				pData->maDockRect.Top()    = nItemTop;
-				pData->maDockRect.Bottom() = nItemBottom;
-				pData->maDockRect.Right()  = nRight;
-				pData->maDockRect.Left()   = pData->maDockRect.Right()-pData->maDockRect.GetHeight()+1;
-				nRight -= pData->maDockRect.GetWidth();
-			}
-
-			if ( pBorderWindow->mbHideBtn )
-			{
-				pData->maHideRect.Top()    = nItemTop;
-				pData->maHideRect.Bottom() = nItemBottom;
-				pData->maHideRect.Right()  = nRight;
-				pData->maHideRect.Left()   = pData->maHideRect.Right()-pData->maHideRect.GetHeight()+1;
-				nRight -= pData->maHideRect.GetWidth();
-			}
-
-			if ( pBorderWindow->GetStyle() & WB_ROLLABLE )
-			{
-				pData->maRollRect.Top()    = nItemTop;
-				pData->maRollRect.Bottom() = nItemBottom;
-				pData->maRollRect.Right()  = nRight;
-				pData->maRollRect.Left()   = pData->maRollRect.Right()-pData->maRollRect.GetHeight()+1;
-				nRight -= pData->maRollRect.GetWidth();
-			}
-
-			if ( pBorderWindow->mbHelpBtn )
-			{
-				pData->maHelpRect.Top()    = nItemTop;
-				pData->maHelpRect.Bottom() = nItemBottom;
-				pData->maHelpRect.Right()  = nRight;
-				pData->maHelpRect.Left()   = pData->maHelpRect.Right()-pData->maHelpRect.GetHeight()+1;
-				nRight -= pData->maHelpRect.GetWidth();
-			}
-		}
-		else
-		{
-			pData->maPinRect.SetEmpty();
-			pData->maCloseRect.SetEmpty();
-			pData->maDockRect.SetEmpty();
-			pData->maHideRect.SetEmpty();
-			pData->maRollRect.SetEmpty();
-			pData->maHelpRect.SetEmpty();
-		}
-
-		pData->mnTopBorder += pData->mnTitleHeight;
-	}
-	else
-	{
-		pData->maTitleRect.SetEmpty();
-		pData->maPinRect.SetEmpty();
-		pData->maCloseRect.SetEmpty();
-		pData->maDockRect.SetEmpty();
-		pData->maHideRect.SetEmpty();
-		pData->maRollRect.SetEmpty();
-		pData->maHelpRect.SetEmpty();
-	}
-}
-
-// -----------------------------------------------------------------------
-
-void ImplUnxBorderWindowView::GetBorder( long& rLeftBorder, long& rTopBorder,
-										 long& rRightBorder, long& rBottomBorder ) const
-{
-	rLeftBorder 	= maFrameData.mnLeftBorder;
-	rTopBorder		= maFrameData.mnTopBorder;
-	rRightBorder	= maFrameData.mnRightBorder;
-	rBottomBorder	= maFrameData.mnBottomBorder;
-}
-
-// -----------------------------------------------------------------------
-
-long ImplUnxBorderWindowView::CalcTitleWidth() const
-{
-	return ImplCalcTitleWidth( &maFrameData );
-}
-
-// -----------------------------------------------------------------------
-
-void ImplUnxBorderWindowView::DrawWindow( USHORT nDrawFlags, OutputDevice* pOutDev, const Point* pOffset )
-{
-	ImplBorderFrameData*	pData = &maFrameData;
-	OutputDevice*			pDev = pOutDev ? pOutDev : pData->mpOutDev;
-	ImplBorderWindow*		pBorderWindow = pData->mpBorderWindow;
-	Point					aTmpPoint( pOffset ? *pOffset : Point() );
-	Rectangle				aInRect( aTmpPoint, Size( pData->mnWidth, pData->mnHeight ) );
-	const StyleSettings&	rStyleSettings = pDev->GetSettings().GetStyleSettings();
-	DecorationView			aDecoView( pDev );
-	USHORT					nStyle;
-	BOOL					bActive = pBorderWindow->IsDisplayActive();
-
-	// Color-Management for 3D-like Border
-	Color aLineColor;
-	Color aFillColor;
-	Color aLightColor;
-	Color aDarkColor;
-	Color aTextColor;
-	if ( bActive )
-	{
-		aLineColor = rStyleSettings.GetActiveBorderColor();
-		aFillColor = rStyleSettings.GetActiveColor();
-		aTextColor = rStyleSettings.GetActiveTextColor();
-	}
-	else
-	{
-		aLineColor = rStyleSettings.GetDeactiveBorderColor();
-		aFillColor = rStyleSettings.GetDeactiveColor();
-		aTextColor = rStyleSettings.GetDeactiveTextColor();
-	}
-	aLightColor = aLineColor;
-	aDarkColor	= aLineColor;
-	aLightColor.IncreaseLuminance( 64 );
-	aDarkColor.DecreaseLuminance(  64 );
-
-	// Draw Frame
-	long nBorderSize = pData->mnBorderSize;
-	if ( !nBorderSize )
-	{
-		if ( nDrawFlags & BORDERWINDOW_DRAW_FRAME )
-			nStyle = 0;
-		else
-			nStyle = FRAME_DRAW_NODRAW;
-		aInRect = aDecoView.DrawFrame( aInRect, FRAME_DRAW_DOUBLEOUT | nStyle );
-	}
-	else
-	{
-		// Draw Border
-		if ( (nDrawFlags & BORDERWINDOW_DRAW_BORDER) && nBorderSize )
-		{
-			// Geometry Presettings
-			long	nOffset = 0;
-			long	nEffBorderSize;
-			long	nLeft	= aInRect.Left();
-			long	nRight	= aInRect.Right();
-			long	nTop	= aInRect.Top();
-			long	nBottom = aInRect.Bottom();
-
-			nEffBorderSize = nBorderSize > 2 ? nBorderSize - 2 : 1;
-
-			// outer border
-			pDev->SetLineColor( aLightColor );
-			pDev->DrawLine( Point( nLeft,  nTop    ), Point( nLeft,  nBottom ) );
-			pDev->DrawLine( Point( nLeft,  nTop    ), Point( nRight, nTop	 ) );
-
-			pDev->SetLineColor( aDarkColor );
-			nTop++; nLeft++;
-			pDev->DrawLine( Point( nRight, nTop    ), Point( nRight, nBottom ) );
-			pDev->DrawLine( Point( nLeft,  nBottom ), Point( nRight, nBottom ) );
-
-			// middle border
-			pDev->SetLineColor();
-			pDev->SetFillColor( aLineColor );
-			nRight--; nBottom--;
-			pDev->DrawRect( Rectangle( Point( nLeft, nTop ),
-									   Size(  nRight - nLeft, nEffBorderSize ) ) );
-			pDev->DrawRect( Rectangle( Point( nLeft, nTop ),
-									   Size(  nEffBorderSize, nBottom - nTop ) ) );
-			nRight	-= nEffBorderSize;
-			nBottom -= nEffBorderSize;
-			pDev->DrawRect( Rectangle( Point( nRight + 1, nTop ),
-									   Size(  nEffBorderSize, nBottom - nTop + 1) ) );
-			pDev->DrawRect( Rectangle( Point( nLeft, nBottom + 1),
-									   Size(  nRight - nLeft + 1, nEffBorderSize ) ) );
-
-			// inner Border
-			pDev->SetLineColor( aDarkColor );
-			nTop += nEffBorderSize; nLeft += nEffBorderSize;
-			pDev->DrawLine( Point( nLeft,  nTop    ), Point( nLeft,  nBottom ) );
-			pDev->DrawLine( Point( nLeft,  nTop    ), Point( nRight, nTop	 ) );
-
-			pDev->SetLineColor( aLightColor );
-			nTop++; nLeft++;
-			pDev->DrawLine( Point( nRight, nTop    ), Point( nRight, nBottom ) );
-			pDev->DrawLine( Point( nLeft,  nBottom ), Point( nRight, nBottom ) );
-
-			// edge intersections
-			if ( pBorderWindow->GetStyle() & WB_SIZEABLE )
-			{
-				nLeft	= aInRect.Left();
-				nRight	= aInRect.Right();
-				nTop	= aInRect.Top();
-				nBottom = aInRect.Bottom();
-
-				if ( !pData->maTitleRect.IsEmpty() )
-					nOffset = pData->maTitleRect.GetHeight() + nEffBorderSize + 2;
-
-				pDev->SetLineColor( aDarkColor );
-				pDev->DrawLine( Point( nLeft + 1,			   nTop + nOffset ),
-								Point( nLeft + nEffBorderSize, nTop + nOffset ));
-				pDev->DrawLine( Point( nLeft + nOffset, 	   nTop + 1 	  ),
-								Point( nLeft + nOffset, 	   nTop + nEffBorderSize));
-				pDev->DrawLine( Point( nRight - 1,			   nTop + nOffset ),
-								Point( nRight - nEffBorderSize,nTop + nOffset ));
-				pDev->DrawLine( Point( nRight - nOffset,	   nTop + 1 	  ),
-								Point( nRight - nOffset,	   nTop + nEffBorderSize));
-
-				pDev->DrawLine( Point( nLeft + 1,			   nBottom - nOffset ),
-								Point( nLeft + nEffBorderSize, nBottom - nOffset ));
-				pDev->DrawLine( Point( nLeft + nOffset, 	   nBottom - 1		 ),
-								Point( nLeft + nOffset, 	   nBottom - nEffBorderSize));
-				pDev->DrawLine( Point( nRight - 1,			   nBottom - nOffset ),
-								Point( nRight - nEffBorderSize,nBottom - nOffset ));
-				pDev->DrawLine( Point( nRight - nOffset,	   nBottom - 1		 ),
-								Point( nRight - nOffset,	   nBottom - nEffBorderSize));
-				pDev->SetLineColor( aLightColor );
-				nEffBorderSize = nBorderSize > 1 ? nBorderSize - 1 : 1;
-				nOffset += 1;
-
-				pDev->DrawLine( Point( nLeft,				   nTop + nOffset	 ),
-								Point( nLeft + nEffBorderSize, nTop + nOffset	 ));
-				pDev->DrawLine( Point( nLeft + nOffset, 	   nTop 			 ),
-								Point( nLeft + nOffset, 	   nTop + nEffBorderSize));
-				pDev->DrawLine( Point( nRight,				   nTop + nOffset	 ),
-								Point( nRight - nEffBorderSize,nTop + nOffset	 ));
-				pDev->DrawLine( Point( nLeft + nOffset, 	   nBottom			 ),
-								Point( nLeft + nOffset, 	   nBottom - nEffBorderSize));
-				nOffset -= 2;
-				pDev->DrawLine( Point( nRight - nOffset,	   nTop 			 ),
-								Point( nRight - nOffset,	   nTop + nEffBorderSize));
-				pDev->DrawLine( Point( nLeft,				   nBottom - nOffset ),
-								Point( nLeft + nEffBorderSize, nBottom - nOffset ));
-				pDev->DrawLine( Point( nRight,				   nBottom - nOffset ),
-								Point( nRight - nEffBorderSize,nBottom - nOffset ));
-				pDev->DrawLine( Point( nRight - nOffset,	   nBottom			 ),
-								Point( nRight - nOffset,	   nBottom - nEffBorderSize));
-			}
-
-			// Reset Linecolor
-			pDev->SetLineColor();
-		}
-	}
-
-	// Draw Title
-	if ( (nDrawFlags & BORDERWINDOW_DRAW_TITLE) && !pData->maTitleRect.IsEmpty() )
-	{
-		// Title Rect
-		aInRect = pData->maTitleRect;
-
-        if( pOffset )
-            aInRect.Move( pOffset->X(), pOffset->Y() );
-
-		pDev->SetFillColor( aFillColor );
-		pDev->SetTextColor( aTextColor );
-		pDev->DrawRect( aInRect );
-
-		// Title Rect Decoration
-		pDev->SetLineColor( aDarkColor );
-		pDev->DrawLine( Point( aInRect.Left(),	aInRect.Bottom() ),
-						Point( aInRect.Right(), aInRect.Bottom() ) );
-		pDev->DrawLine( Point( aInRect.Right(), aInRect.Top()	 ),
-						Point( aInRect.Right(), aInRect.Bottom() ) );
-		pDev->SetLineColor( aLightColor );
-		pDev->DrawLine( Point( aInRect.Left(),	aInRect.Top()	 ),
-						Point( aInRect.Right(), aInRect.Top()	 ) );
-		pDev->DrawLine( Point( aInRect.Left(),	aInRect.Top() ),
-						Point( aInRect.Left(),	aInRect.Bottom() ) );
-
-		long nLeft;
-		if ( !pData->maCloseRect.IsEmpty() )
-        {
-			nLeft = pData->maCloseRect.Right()+1;
-            if( pOffset )
-                nLeft += pOffset->X();
-        }
-		else
-			nLeft = aInRect.Left()+1;
-
-		// Title Text
-		if ( pData->mnTitleType != BORDERWINDOW_TITLE_TEAROFF )
-		{
-            long nXOff = pOffset ? pOffset->X() : 0;
-			if ( !pData->maPinRect.IsEmpty() )
-				aInRect.Left() = pData->maPinRect.Right()+1 + nXOff;
-			else if ( !pData->maCloseRect.IsEmpty() )
-				aInRect.Left() = pData->maCloseRect.Right()+1 + nXOff;
-
-			if ( !pData->maHelpRect.IsEmpty() )
-				aInRect.Right() = pData->maHelpRect.Left()-1 + nXOff;
-			else if ( !pData->maRollRect.IsEmpty() )
-				aInRect.Right() = pData->maRollRect.Left()-1 + nXOff;
-			else if ( !pData->maHideRect.IsEmpty() )
-				aInRect.Right() = pData->maHideRect.Left()-1 + nXOff;
-			else if ( !pData->maDockRect.IsEmpty() )
-				aInRect.Right() = pData->maDockRect.Left()-1 + nXOff;
-
-			pDev->DrawText( aInRect, pBorderWindow->GetText(),
-							TEXT_DRAW_CENTER | TEXT_DRAW_VCENTER |
-							TEXT_DRAW_ENDELLIPSIS | TEXT_DRAW_CLIP );
-		}
-
-		// more Title Rect Decoration
-		pDev->SetLineColor( aLightColor );
-		pDev->DrawLine( Point( nLeft, aInRect.Bottom() ),
-						Point( nLeft, aInRect.Top()    ));
-		pDev->SetLineColor( aDarkColor );
-		pDev->DrawLine( Point( aInRect.Right(), aInRect.Top() ),
-						Point( aInRect.Right(), aInRect.Bottom() ) );
-	}
-
-	// Draw the buttons
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_CLOSE) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maCloseRect.IsEmpty() )
-	{
-		Rectangle aInCloseRect = DrawUnxTitleButton( pData->maCloseRect,
-													 pData->mnCloseState );
-        if( pOffset )
-            aInCloseRect.Move( pOffset->X(), pOffset->Y() );
-		aDecoView.DrawSymbol( aInCloseRect, SYMBOL_CLOSE, aTextColor, 0 );
-	}
-
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_DOCK) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maDockRect.IsEmpty() )
-	{
-		Rectangle aInDockRect = DrawUnxTitleButton( pData->maDockRect,
-													pData->mnDockState );
-        if( pOffset )
-            aInDockRect.Move( pOffset->X(), pOffset->Y() );
-		aDecoView.DrawSymbol( aInDockRect, SYMBOL_DOCK, aTextColor, 0 );
-	}
-
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_HIDE) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maHideRect.IsEmpty() )
-	{
-		Rectangle aInHideRect = DrawUnxTitleButton( pData->maHideRect,
-													pData->mnHideState );
-        if( pOffset )
-            aInHideRect.Move( pOffset->X(), pOffset->Y() );
-		aDecoView.DrawSymbol( aInHideRect, SYMBOL_HIDE, aTextColor, 0 );
-	}
-
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_ROLL) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maRollRect.IsEmpty() )
-	{
-		Rectangle aInRollRect = DrawUnxTitleButton( pData->maRollRect,
-													pData->mnRollState );
-		SymbolType eType;
-		if ( pBorderWindow->mbRollUp )
-			eType = SYMBOL_ROLLDOWN;
-		else
-			eType = SYMBOL_ROLLUP;
-        if( pOffset )
-            aInRollRect.Move( pOffset->X(), pOffset->Y() );
-		aDecoView.DrawSymbol( aInRollRect, eType, aTextColor, 0 );
-	}
-
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_HELP) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maHelpRect.IsEmpty() )
-	{
-		Rectangle aInHelpRect = DrawUnxTitleButton( pData->maHelpRect,
-													pData->mnHelpState );
-        if( pOffset )
-            aInHelpRect.Move( pOffset->X(), pOffset->Y() );
-		aDecoView.DrawSymbol( aInHelpRect, SYMBOL_HELP, aTextColor, 0 );
-	}
-
-	if ( ((nDrawFlags & BORDERWINDOW_DRAW_PIN) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-		 !pData->maPinRect.IsEmpty() )
-	{
-		Image aImage;
-		ImplGetPinImage( pData->mnPinState, pBorderWindow->mbPined, aImage );
-		Size  aImageSize = aImage.GetSizePixel();
-		long  nRectHeight = pData->maPinRect.GetHeight();
-        Point aPos( pData->maPinRect.TopLeft() );
-        if( pOffset )
-            aPos += *pOffset;
-		if ( nRectHeight < aImageSize.Height() )
-		{
-			pDev->DrawImage( aPos,
-							 Size( aImageSize.Width(), nRectHeight ),
-							 aImage );
-		}
-		else
-		{
-			pDev->DrawImage( Point( aPos.X(),
-									aPos.Y()+(nRectHeight-aImageSize.Height())/2 ),
-							 aImage );
-		}
-	}
-}
-
-// -----------------------------------------------------------------------
-
-Rectangle ImplUnxBorderWindowView::DrawUnxTitleButton( const Rectangle& rRect, USHORT nStyle )
-{
-	Rectangle				aFillRect = rRect;
-	OutputDevice*			pDev = maFrameData.mpOutDev;
-	const StyleSettings&	rStyleSettings = pDev->GetSettings().GetStyleSettings();
-	ImplBorderFrameData*	pData = &maFrameData;
-	ImplBorderWindow*		pBorderWindow = pData->mpBorderWindow;
-	BOOL					bActive = pBorderWindow->IsDisplayActive();
-
-	// Color-Management for 3D-like Border
-	Color aLineColor;
-	Color aLightColor;
-	Color aDarkColor;
-	if ( bActive )
-		aLineColor = rStyleSettings.GetActiveBorderColor();
-	else
-		aLineColor = rStyleSettings.GetDeactiveBorderColor();
-	aLightColor = aLineColor;
-	aDarkColor	= aLineColor;
-	aLightColor.IncreaseLuminance( 64 );
-	aDarkColor.DecreaseLuminance(  64 );
-
-	// Draw Button
-	if ( !(nStyle & BUTTON_DRAW_NODRAW) )
-	{
-		// left and upper button-border
-		if ( nStyle & (BUTTON_DRAW_PRESSED | BUTTON_DRAW_CHECKED) )
-			pDev->SetLineColor( aDarkColor );
-		else
-			pDev->SetLineColor( aLightColor );
-		pDev->DrawLine( Point( aFillRect.Left(),  aFillRect.Top()	 ),
-						Point( aFillRect.Right(), aFillRect.Top()	 ) );
-		pDev->DrawLine( Point( aFillRect.Left(),  aFillRect.Top()	 ),
-						Point( aFillRect.Left(),  aFillRect.Bottom() ) );
-
-		aFillRect.Left()++;
-		aFillRect.Top()++;
-
-		// right and bottom button-border
-		if ( nStyle & (BUTTON_DRAW_PRESSED | BUTTON_DRAW_CHECKED) )
-			pDev->SetLineColor( aLightColor );
-		else
-			pDev->SetLineColor( aDarkColor );
-		pDev->DrawLine( Point( aFillRect.Right(), aFillRect.Top()	 ),
-						Point( aFillRect.Right(), aFillRect.Bottom()	) );
-		pDev->DrawLine( Point( aFillRect.Left(),  aFillRect.Bottom()	),
-						Point( aFillRect.Right(), aFillRect.Bottom() ) );
-
-		aFillRect.Right()--;
-		aFillRect.Bottom()--;
-
-		// button area
-		pDev->SetFillColor( aLineColor );
-		pDev->SetLineColor();
-
-		pDev->DrawRect( Rectangle( aFillRect.Left(),  aFillRect.Top(),
-								   aFillRect.Right(), aFillRect.Bottom() ) );
-	}
-
-	aFillRect.Left()	+= 3;
-	aFillRect.Top() 	+= 3;
-	aFillRect.Right()	-= 2;
-	aFillRect.Bottom()	-= 2;
-	return aFillRect;
-}
-
-// =======================================================================
-
-// ---------------------------
-// - ImplMacBorderWindowView -
-// ---------------------------
-
-class ImplMacBorderWindowView : public ImplBorderWindowView
-{
-	ImplBorderFrameData 	maFrameData;
-	VirtualDevice			maVirDev;
-	BOOL					mbPressed;
-
-public:
-							ImplMacBorderWindowView( ImplBorderWindow* pBorderWindow );
-							~ImplMacBorderWindowView();
-
-	virtual BOOL			MouseMove( const MouseEvent& rMEvt );
-	virtual BOOL			MouseButtonDown( const MouseEvent& rMEvt );
-	virtual BOOL			Tracking( const TrackingEvent& rTEvt );
-	virtual USHORT			RequestHelp( const Point& rPos, Rectangle& rHelpRect );
-
-	virtual void			Init( OutputDevice* pDev, long nWidth, long nHeight );
-	virtual void			GetBorder( long& rLeftBorder, long& rTopBorder,
-									   long& rRightBorder, long& rBottomBorder ) const;
-	virtual long			CalcTitleWidth() const;
-	virtual void			DrawWindow( USHORT nDrawFlags, OutputDevice* pOutDev, const Point* pOffset );
-
-	Rectangle				DrawMacTitleButton( OutputDevice* pDev, const Rectangle& rRect, USHORT nStyle );
-};
-
-// =======================================================================
-
-ImplMacBorderWindowView::ImplMacBorderWindowView( ImplBorderWindow* pBorderWindow )
-{
-	maFrameData.mpBorderWindow	= pBorderWindow;
-	maFrameData.mbDragFull		= FALSE;
-	maFrameData.mnHitTest		= 0;
-	maFrameData.mnPinState		= 0;
-	maFrameData.mnCloseState	= 0;
-	maFrameData.mnRollState 	= 0;
-	maFrameData.mnDockState 	= 0;
-	maFrameData.mnHideState 	= 0;
-	maFrameData.mnHelpState 	= 0;
-
-	mbPressed					= FALSE;
-}
-
-// -----------------------------------------------------------------------
-
-ImplMacBorderWindowView::~ImplMacBorderWindowView()
-{
-}
-
-// -----------------------------------------------------------------------
-
-BOOL ImplMacBorderWindowView::MouseMove( const MouseEvent& rMEvt )
-{
-	return ImplMouseMove( &maFrameData, rMEvt );
-}
-
-// -----------------------------------------------------------------------
-
-BOOL ImplMacBorderWindowView::MouseButtonDown( const MouseEvent& rMEvt )
-{
-	return ImplMouseButtonDown( &maFrameData, rMEvt );
-}
-
-// -----------------------------------------------------------------------
-
-BOOL ImplMacBorderWindowView::Tracking( const TrackingEvent& rTEvt )
-{
-	return ImplTracking( &maFrameData, rTEvt );
-}
-
-// -----------------------------------------------------------------------
-
-USHORT ImplMacBorderWindowView::RequestHelp( const Point& rPos, Rectangle& rHelpRect )
-{
-	return ImplRequestHelp( &maFrameData, rPos, rHelpRect );
-}
-
-// -----------------------------------------------------------------------
-
-void ImplMacBorderWindowView::Init( OutputDevice* pDev, long nWidth, long nHeight )
-{
-	ImplBorderFrameData*	pData = &maFrameData;
-	ImplBorderWindow*		pBorderWindow = maFrameData.mpBorderWindow;
-	const StyleSettings&	rStyleSettings = pDev->GetSettings().GetStyleSettings();
-
-	pData->mpOutDev 		= pDev;
-	pData->mnWidth			= nWidth;
-	pData->mnHeight 		= nHeight;
-
-	pData->mnTitleType		= pBorderWindow->mnTitleType;
-	pData->mbFloatWindow	= pBorderWindow->mbFloatWindow;
-
-	if ( !(pBorderWindow->GetStyle() & WB_MOVEABLE) || (pData->mnTitleType == BORDERWINDOW_TITLE_NONE) )
-		pData->mnBorderSize = 0;
-	else if ( pData->mnTitleType == BORDERWINDOW_TITLE_TEAROFF )
-		pData->mnBorderSize = 1;
-	else
-		pData->mnBorderSize = rStyleSettings.GetBorderSize();
-	pData->mnLeftBorder 	= 2;
-	pData->mnTopBorder		= 2;
-	pData->mnRightBorder	= 2;
-	pData->mnBottomBorder	= 2;
-	pData->mnLeftBorder    += pData->mnBorderSize;
-	pData->mnTopBorder	   += pData->mnBorderSize;
-	pData->mnRightBorder   += pData->mnBorderSize;
-	pData->mnBottomBorder  += pData->mnBorderSize;
-	pData->mnNoTitleTop 	= pData->mnTopBorder;
-	pData->mnTitleOff		= 0;
-
-	ImplInitTitle( &maFrameData );
-	if ( pData->mnTitleHeight )
-	{
-		if ( (pData->mnTitleType & (BORDERWINDOW_TITLE_NORMAL | BORDERWINDOW_TITLE_SMALL)) &&
-			 pData->mnBorderSize )
-			pData->mnTitleOff = 3;	// 3 damit Hoehe auf dem MAC stimmt, ansonsten waere 2 richtig
-		pData->mnTitleHeight		-= pData->mnTitleOff;
-		pData->maTitleRect.Left()	 = pData->mnLeftBorder;
-		pData->maTitleRect.Right()	 = nWidth-pData->mnRightBorder-1;
-		pData->maTitleRect.Top()	 = pData->mnTopBorder;
-		pData->maTitleRect.Bottom()  = pData->maTitleRect.Top()+pData->mnTitleHeight-1;
-
-		if ( pData->mnTitleType & (BORDERWINDOW_TITLE_NORMAL | BORDERWINDOW_TITLE_SMALL) )
-		{
-			long nLeft			= pData->maTitleRect.Left();
-			long nRight 		= pData->maTitleRect.Right();
-			long nItemTop		= pData->maTitleRect.Top();
-			long nItemBottom	= pData->maTitleRect.Bottom();
-
-			if ( pBorderWindow->GetStyle() & WB_CLOSEABLE )
-			{
-				pData->maCloseRect.Top()	= nItemTop;
-				pData->maCloseRect.Bottom() = nItemBottom;
-				pData->maCloseRect.Left()	= nLeft;
-				pData->maCloseRect.Right()	= pData->maCloseRect.Left()+pData->maCloseRect.GetHeight()-1;
-				nLeft += pData->maCloseRect.GetWidth()+3;
-			}
-
-			if ( pBorderWindow->GetStyle() & WB_PINABLE )
-			{
-				Image aImage;
-				ImplGetPinImage( 0, 0, aImage );
-				pData->maPinRect.Top()	  = nItemTop;
-				pData->maPinRect.Bottom() = nItemBottom;
-				pData->maPinRect.Left()   = nLeft;
-				pData->maPinRect.Right()  = pData->maPinRect.Left()+aImage.GetSizePixel().Width();
-				nLeft += pData->maPinRect.GetWidth()+3;
-			}
-
-			if ( pBorderWindow->mbDockBtn )
-			{
-				pData->maDockRect.Top()    = nItemTop;
-				pData->maDockRect.Bottom() = nItemBottom;
-				pData->maDockRect.Right()  = nRight;
-				pData->maDockRect.Left()   = pData->maDockRect.Right()-pData->maDockRect.GetHeight()+1;
-				nRight -= pData->maDockRect.GetWidth()+3;
-			}
-
-			if ( pBorderWindow->mbHideBtn )
-			{
-				pData->maHideRect.Top()    = nItemTop;
-				pData->maHideRect.Bottom() = nItemBottom;
-				pData->maHideRect.Right()  = nRight;
-				pData->maHideRect.Left()   = pData->maHideRect.Right()-pData->maHideRect.GetHeight()+1;
-				nRight -= pData->maHideRect.GetWidth()+3;
-			}
-
-			if ( pBorderWindow->GetStyle() & WB_ROLLABLE )
-			{
-				pData->maRollRect.Top()    = nItemTop;
-				pData->maRollRect.Bottom() = nItemBottom;
-				pData->maRollRect.Right()  = nRight;
-				pData->maRollRect.Left()   = pData->maRollRect.Right()-pData->maRollRect.GetHeight()+1;
-				nRight -= pData->maRollRect.GetWidth()+3;
-			}
-
-			if ( pBorderWindow->mbHelpBtn )
-			{
-				pData->maHelpRect.Top()    = nItemTop;
-				pData->maHelpRect.Bottom() = nItemBottom;
-				pData->maHelpRect.Right()  = nRight;
-				pData->maHelpRect.Left()   = pData->maHelpRect.Right()-pData->maHelpRect.GetHeight()+1;
-				nRight -= pData->maHelpRect.GetWidth()+3;
-			}
-		}
-		else
-		{
-			pData->maCloseRect.SetEmpty();
-			pData->maDockRect.SetEmpty();
-			pData->maHideRect.SetEmpty();
-			pData->maRollRect.SetEmpty();
-			pData->maHelpRect.SetEmpty();
-		}
-
-		pData->mnTopBorder	+= pData->mnTitleHeight;
-
-		// Innerer Border nur, wenn wir auch eine TitleBar haben
-		if ( !pBorderWindow->mbRollUp || pBorderWindow->mnRollHeight )
-		{
-			pData->mnTopBorder		+= 3+pData->mnBorderSize;
-			pData->mnBottomBorder	+= 3;
-		}
-		pData->mnLeftBorder 	+= 3;
-		pData->mnRightBorder	+= 3;
-	}
-	else
-	{
-		pData->maTitleRect.SetEmpty();
-		pData->maPinRect.SetEmpty();
-		pData->maCloseRect.SetEmpty();
-		pData->maDockRect.SetEmpty();
-		pData->maHideRect.SetEmpty();
-		pData->maRollRect.SetEmpty();
-		pData->maHelpRect.SetEmpty();
-	}
-}
-
-// -----------------------------------------------------------------------
-
-void ImplMacBorderWindowView::GetBorder( long& rLeftBorder, long& rTopBorder,
-										 long& rRightBorder, long& rBottomBorder ) const
-{
-	rLeftBorder 	= maFrameData.mnLeftBorder;
-	rTopBorder		= maFrameData.mnTopBorder;
-	rRightBorder	= maFrameData.mnRightBorder;
-	rBottomBorder	= maFrameData.mnBottomBorder;
-}
-
-// -----------------------------------------------------------------------
-
-long ImplMacBorderWindowView::CalcTitleWidth() const
-{
-	return ImplCalcTitleWidth( &maFrameData );
-}
-
-// -----------------------------------------------------------------------
-
-void ImplMacBorderWindowView::DrawWindow( USHORT nDrawFlags, OutputDevice* pOutDev, const Point* pOffset )
-{
-	ImplBorderFrameData*	pData = &maFrameData;
-	OutputDevice*			pDev = pOutDev ? pOutDev : pData->mpOutDev;
-	ImplBorderWindow*		pBorderWindow = pData->mpBorderWindow;
-	Point					aTmpPoint( pOffset ? *pOffset : Point() );
-	Rectangle				aInRect( aTmpPoint, Size( pData->mnWidth, pData->mnHeight ) );
-	const StyleSettings&	rStyleSettings = pDev->GetSettings().GetStyleSettings();
-	BOOL					bActive = pBorderWindow->IsDisplayActive();
-
-	// DrawFrame
-	pBorderWindow->SetFillColor();
-	if ( nDrawFlags & BORDERWINDOW_DRAW_FRAME )
-	{
-		if ( bActive )
-			pDev->SetLineColor( rStyleSettings.GetDarkShadowColor() );
-		else
-			pDev->SetLineColor( rStyleSettings.GetShadowColor() );
-		pDev->DrawRect( aInRect );
-		aInRect.Left()++;
-		aInRect.Top()++;
-		aInRect.Right()--;
-		aInRect.Bottom()--;
-		if ( bActive )
-		{
-			pDev->SetLineColor( rStyleSettings.GetLightColor() );
-			pDev->DrawLine( aInRect.TopLeft(), Point( aInRect.Left(), aInRect.Bottom() ) );
-			pDev->DrawLine( aInRect.TopLeft(), Point( aInRect.Right(), aInRect.Top() ) );
-			pDev->SetLineColor( rStyleSettings.GetShadowColor() );
-			pDev->DrawLine( Point( aInRect.Left()+1, aInRect.Bottom() ), aInRect.BottomRight() );
-			pDev->DrawLine( Point( aInRect.Right(), aInRect.Top()+1 ), aInRect.BottomRight() );
-		}
-		else
-		{
-			pDev->SetLineColor( rStyleSettings.GetDeactiveBorderColor() );
-			pDev->DrawRect( aInRect );
-		}
-		aInRect.Left()++;
-		aInRect.Top()++;
-		aInRect.Right()--;
-		aInRect.Bottom()--;
-	}
-	else
-	{
-		aInRect.Left()	 += 2;
-		aInRect.Top()	 += 2;
-		aInRect.Right()  -= 2;
-		aInRect.Bottom() -= 2;
-	}
-
-	pBorderWindow->SetLineColor();
-	long nBorderSize = pData->mnBorderSize;
-	if ( (nDrawFlags & BORDERWINDOW_DRAW_BORDER) && nBorderSize )
-	{
-		if ( bActive )
-			pDev->SetFillColor( rStyleSettings.GetActiveBorderColor() );
-		else
-			pDev->SetFillColor( rStyleSettings.GetDeactiveBorderColor() );
-		pDev->DrawRect( Rectangle( Point( aInRect.Left(), aInRect.Top() ),
-								   Size( aInRect.GetWidth(), nBorderSize ) ) );
-		pDev->DrawRect( Rectangle( Point( aInRect.Left(), aInRect.Top()+nBorderSize ),
-								   Size( nBorderSize, aInRect.GetHeight()-nBorderSize ) ) );
-		pDev->DrawRect( Rectangle( Point( aInRect.Left(), aInRect.Bottom()-nBorderSize+1 ),
-								   Size( aInRect.GetWidth(), nBorderSize ) ) );
-		pDev->DrawRect( Rectangle( Point( aInRect.Right()-nBorderSize+1, aInRect.Top()+nBorderSize ),
-								   Size( nBorderSize, aInRect.GetHeight()-nBorderSize ) ) );
-	}
-	aInRect.Left()	 += nBorderSize;
-	aInRect.Top()	 += nBorderSize;
-	aInRect.Right()  -= nBorderSize;
-	aInRect.Bottom() -= nBorderSize;
-
-	Rectangle	aTitleRect = pData->maTitleRect;
-    if( pOffset )
-        aTitleRect.Move( pOffset->X(), pOffset->Y() );
-	XubString	aText = pBorderWindow->GetText();
-	BOOL		bDrawText = FALSE;
-	if ( (nDrawFlags & BORDERWINDOW_DRAW_TITLE) && !pData->maTitleRect.IsEmpty() )
-	{
-		Rectangle aTextRect;
-		if ( bActive )
-		{
-			pDev->SetFillColor( rStyleSettings.GetActiveColor() );
-			pDev->SetTextColor( rStyleSettings.GetActiveTextColor() );
-		}
-		else
-		{
-			pDev->SetFillColor( rStyleSettings.GetDeactiveColor() );
-			pDev->SetTextColor( rStyleSettings.GetDeactiveTextColor() );
-		}
-		pDev->DrawRect( aTitleRect );
-
-		if ( pData->mnTitleType != BORDERWINDOW_TITLE_TEAROFF )
-		{
-            long nXOff = pOffset ? pOffset->X() : 0;
-			if ( !pData->maPinRect.IsEmpty() )
-				aTitleRect.Left() = pData->maPinRect.Right()+3 + nXOff;
-			else if ( !pData->maCloseRect.IsEmpty() )
-				aTitleRect.Left() = pData->maCloseRect.Right()+3 + nXOff;
-
-			if ( !pData->maHelpRect.IsEmpty() )
-				aTitleRect.Right() = pData->maHelpRect.Left()-3 + nXOff;
-			else if ( !pData->maHideRect.IsEmpty() )
-				aTitleRect.Right() = pData->maHideRect.Left()-3 + nXOff;
-			else if ( !pData->maDockRect.IsEmpty() )
-				aTitleRect.Right() = pData->maDockRect.Left()-3 + nXOff;
-			else if ( !pData->maRollRect.IsEmpty() )
-				aTitleRect.Right() = pData->maRollRect.Left()-3 + nXOff;
-
-			if ( aText.Len() )
-			{
-				aTextRect = pDev->GetTextRect( aTitleRect, aText,
-											   TEXT_DRAW_CENTER | TEXT_DRAW_VCENTER |
-											   TEXT_DRAW_ENDELLIPSIS );
-				bDrawText = TRUE;
-			}
-		}
-
-		if ( bActive )
-		{
-			long nY 		= aTitleRect.Top();
-			long nYMax		= nY+pData->mnTitleHeight-2+(pData->mnTitleHeight%2);
-			long nX1		= aTitleRect.Left();
-			long nX2;
-			long nX3;
-			long nX4;
-			BOOL bLines;
-			BOOL b2Lines;
-			if ( aTextRect.IsEmpty() )
-			{
-				nX2 	= aTitleRect.Right();
-				bLines	= nX2-2 > nX1;
-				b2Lines = FALSE;
-			}
-			else
-			{
-				aTextRect.Left()  -= 4;
-				aTextRect.Right() += 4;
-				if ( (aTextRect.Left() > aTitleRect.Left()) &&
-					 (aTextRect.Right() < aTitleRect.Right()) )
-				{
-					nX2 	= aTextRect.Left();
-					nX3 	= aTextRect.Right();
-					nX4 	= aTitleRect.Right();
-					bLines	= TRUE;
-					b2Lines = TRUE;
-				}
-				else
-					bLines = FALSE;
-			}
-
-			if ( bLines )
-			{
-				for ( ; nY < nYMax; nY += 2 )
-				{
-					if ( rStyleSettings.GetOptions() & STYLE_OPTION_MONO )
-						pDev->SetLineColor( Color( COL_BLACK ) );
-					else
-						pDev->SetLineColor( rStyleSettings.GetLightColor() );
-					pDev->DrawLine( Point( nX1, nY ), Point( nX2-1, nY ) );
-					if ( b2Lines )
-						pDev->DrawLine( Point( nX3, nY ), Point( nX4-1, nY ) );
-					if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
-					{
-						pDev->SetLineColor( rStyleSettings.GetShadowColor() );
-						pDev->DrawLine( Point( nX1+1, nY+1 ), Point( nX2, nY+1 ) );
-						if ( b2Lines )
-							pDev->DrawLine( Point( nX3+1, nY+1 ), Point( nX4, nY+1 ) );
-					}
-				}
-			}
-		}
-	}
-	aInRect.Top() += pData->mnTitleHeight;
-
-	if ( bActive )
-	{
-		if ( ((nDrawFlags & BORDERWINDOW_DRAW_CLOSE) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-			 !pData->maCloseRect.IsEmpty() )
-        {
-            Rectangle aRect = pData->maCloseRect;
-            if( pOffset )
-                aRect.Move( pOffset->X(), pOffset->Y() );
-			DrawMacTitleButton( pDev, aRect, pData->mnCloseState );
-        }
-
-		if ( ((nDrawFlags & BORDERWINDOW_DRAW_PIN) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-			 !pData->maPinRect.IsEmpty() )
-		{
-			Image aImage;
-			ImplGetPinImage( pData->mnPinState, pBorderWindow->mbPined, aImage );
-			Size  aImageSize = aImage.GetSizePixel();
-			long  nRectHeight = pData->maPinRect.GetHeight();
-            Point aPos( pData->maPinRect.TopLeft() );
-            if( pOffset )
-                aPos += *pOffset;
-			if ( nRectHeight < aImageSize.Height() )
-			{
-				pDev->DrawImage( aPos,
-								 Size( aImageSize.Width(), nRectHeight ),
-								 aImage );
-			}
-			else
-			{
-				pDev->DrawImage( Point( aPos.X(),
-										aPos.Y()+(nRectHeight-aImageSize.Height())/2 ),
-								 aImage );
-			}
-		}
-
-		if ( ((nDrawFlags & BORDERWINDOW_DRAW_DOCK) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-			 !pData->maDockRect.IsEmpty() )
-		{
-            Rectangle aRect = pData->maDockRect;
-            if( pOffset )
-                aRect.Move( pOffset->X(), pOffset->Y() );
-			Rectangle aInDockRect = DrawMacTitleButton( pDev, aRect, pData->mnDockState );
-			pDev->SetLineColor( rStyleSettings.GetDarkShadowColor() );
-			pDev->SetFillColor();
-			aInDockRect.Left()++;
-			aInDockRect.Top()++;
-			aInDockRect.Right()--;
-			aInDockRect.Bottom()--;
-			pDev->DrawRect( aInDockRect );
-		}
-
-		if ( ((nDrawFlags & BORDERWINDOW_DRAW_HIDE) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-			 !pData->maHideRect.IsEmpty() )
-		{
-            Rectangle aRect = pData->maHideRect;
-            if( pOffset )
-                aRect.Move( pOffset->X(), pOffset->Y() );
-			Rectangle aInHideRect = DrawMacTitleButton( pDev, aRect, pData->mnHideState );
-			pDev->SetLineColor( rStyleSettings.GetDarkShadowColor() );
-			pDev->DrawLine( Point( aInHideRect.Left(), aInHideRect.Bottom()-1 ), Point( aInHideRect.Right(), aInHideRect.Bottom()-1 ) );
-			pDev->DrawLine( Point( aInHideRect.Left(), aInHideRect.Bottom() ), Point( aInHideRect.Right(), aInHideRect.Bottom() ) );
-		}
-
-		if ( ((nDrawFlags & BORDERWINDOW_DRAW_ROLL) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-			 !pData->maRollRect.IsEmpty() )
-		{
-            Rectangle aRect = pData->maRollRect;
-            if( pOffset )
-                aRect.Move( pOffset->X(), pOffset->Y() );
-			Rectangle aInRollRect = DrawMacTitleButton( pDev, aRect, pData->mnRollState );
-			pDev->SetLineColor( rStyleSettings.GetDarkShadowColor() );
-			long nY = aInRollRect.Center().Y();
-			pDev->DrawLine( Point( aInRollRect.Left(), nY-1 ), Point( aInRollRect.Right(), nY-1 ) );
-			pDev->DrawLine( Point( aInRollRect.Left(), nY+1 ), Point( aInRollRect.Right(), nY+1 ) );
-		}
-
-		if ( ((nDrawFlags & BORDERWINDOW_DRAW_HELP) || (nDrawFlags & BORDERWINDOW_DRAW_TITLE)) &&
-			 !pData->maHelpRect.IsEmpty() )
-		{
-            Rectangle aRect = pData->maHelpRect;
-            if( pOffset )
-                aRect.Move( pOffset->X(), pOffset->Y() );
-			Rectangle aInHelpRect = DrawMacTitleButton( pDev, aRect, pData->mnHelpState );
-			// ...
-		}
-	}
-
-	if ( (nDrawFlags & BORDERWINDOW_DRAW_BORDER) && nBorderSize && !pData->maTitleRect.IsEmpty() )
-	{
-		pBorderWindow->SetLineColor();
-		if ( bActive )
-			pDev->SetFillColor( rStyleSettings.GetActiveColor() );
-		else
-			pDev->SetFillColor( rStyleSettings.GetDeactiveColor() );
-		pDev->DrawRect( Rectangle( Point( aInRect.Left(), aInRect.Top() ),
-								   Size( aInRect.GetWidth(), nBorderSize ) ) );
-	}
-	aInRect.Top() += nBorderSize;
-
-	if ( (nDrawFlags & BORDERWINDOW_DRAW_FRAME) && !pData->maTitleRect.IsEmpty() &&
-		 (!pBorderWindow->mbRollUp || pBorderWindow->mnRollHeight) )
-	{
-		pBorderWindow->SetFillColor();
-		if ( bActive )
-		{
-			pDev->SetLineColor( rStyleSettings.GetShadowColor() );
-			pDev->DrawLine( aInRect.TopLeft(), Point( aInRect.Left(), aInRect.Bottom() ) );
-			pDev->DrawLine( aInRect.TopLeft(), Point( aInRect.Right(), aInRect.Top() ) );
-			pDev->SetLineColor( rStyleSettings.GetLightColor() );
-			pDev->DrawLine( Point( aInRect.Left()+1, aInRect.Bottom() ), aInRect.BottomRight() );
-			pDev->DrawLine( Point( aInRect.Right(), aInRect.Top()+1 ), aInRect.BottomRight() );
-		}
-		else
-		{
-			pDev->SetLineColor( rStyleSettings.GetDeactiveBorderColor() );
-			pDev->DrawRect( aInRect );
-		}
-		aInRect.Left()++;
-		aInRect.Top()++;
-		aInRect.Right()--;
-		aInRect.Bottom()--;
-		if ( bActive )
-			pDev->SetLineColor( rStyleSettings.GetDarkShadowColor() );
-		else
-			pDev->SetLineColor( rStyleSettings.GetShadowColor() );
-		pDev->DrawRect( aInRect );
-		aInRect.Left()++;
-		aInRect.Top()++;
-		aInRect.Right()--;
-		aInRect.Bottom()--;
-		if ( bActive )
-		{
-			pDev->SetLineColor( rStyleSettings.GetLightColor() );
-			pDev->DrawLine( aInRect.TopLeft(), Point( aInRect.Left(), aInRect.Bottom() ) );
-			pDev->DrawLine( aInRect.TopLeft(), Point( aInRect.Right(), aInRect.Top() ) );
-			pDev->SetLineColor( rStyleSettings.GetShadowColor() );
-			pDev->DrawLine( Point( aInRect.Left()+1, aInRect.Bottom() ), aInRect.BottomRight() );
-			pDev->DrawLine( Point( aInRect.Right(), aInRect.Top()+1 ), aInRect.BottomRight() );
-		}
-		else
-		{
-			pDev->SetLineColor( rStyleSettings.GetDeactiveBorderColor() );
-			pDev->DrawRect( aInRect );
-		}
-	}
-
-	// Text als letztes zeichen, da auf dem MAC unter/ober-Laengen in
-	// den Border gezeichnet werden
-	if ( bDrawText )
-	{
-		pDev->DrawText( aTitleRect, aText,
-						 TEXT_DRAW_CENTER | TEXT_DRAW_VCENTER |
-						 TEXT_DRAW_ENDELLIPSIS );
-	}
-}
-
-//fuer WIN16 Borland
-#ifdef WIN
-#pragma codeseg BRWDIN_SEG1
-#endif
-
-// -----------------------------------------------------------------------
-
-Rectangle ImplMacBorderWindowView::DrawMacTitleButton( OutputDevice* pDev, const Rectangle& rRect, USHORT nStyle )
-{
-	const StyleSettings&	rStyleSettings = pDev->GetSettings().GetStyleSettings();
-	Rectangle				aRect = rRect;
-
-	if ( !(rStyleSettings.GetOptions() & STYLE_OPTION_MONO) )
-	{
-		pDev->SetLineColor( rStyleSettings.GetShadowColor() );
-		pDev->DrawLine( aRect.TopLeft(), Point( aRect.Left(), aRect.Bottom() ) );
-		pDev->DrawLine( aRect.TopLeft(), Point( aRect.Right(), aRect.Top() ) );
-		pDev->SetLineColor( rStyleSettings.GetLightColor() );
-		pDev->DrawLine( Point( aRect.Left()+1, aRect.Bottom() ), aRect.BottomRight() );
-		pDev->DrawLine( Point( aRect.Right(), aRect.Top()+1 ), aRect.BottomRight() );
-		aRect.Left()++;
-		aRect.Top()++;
-		aRect.Right()--;
-		aRect.Bottom()--;
-		pDev->SetLineColor( rStyleSettings.GetDarkShadowColor() );
-		BOOL bDrawRect;
-		if ( pDev->GetColorCount() >= 256 )
-		{
-			Point	aTempPoint;
-			Size	aRectSize = aRect.GetSize();
-			BOOL	bNewPressed = (nStyle & BUTTON_DRAW_PRESSED) != 0;
-			bDrawRect = FALSE;
-			if ( (aRectSize != maVirDev.GetOutputSizePixel()) ||
-				 (bNewPressed != mbPressed) )
-			{
-				Gradient aGradient( GRADIENT_LINEAR,
-									rStyleSettings.GetShadowColor(),
-									rStyleSettings.GetLightColor() );
-				if ( bNewPressed )
-				{
-					aGradient.SetStartColor( rStyleSettings.GetDarkShadowColor() );
-					aGradient.SetEndColor( rStyleSettings.GetFaceColor() );
-				}
-				aGradient.SetAngle( 450 );
-				if ( maVirDev.SetOutputSizePixel( aRectSize ) )
-					maVirDev.DrawGradient( Rectangle( aTempPoint, aRectSize ), aGradient );
-				else
-					bDrawRect = TRUE;
-				mbPressed = bNewPressed;
-			}
-			if ( !bDrawRect )
-			{
-				pDev->DrawOutDev( aRect.TopLeft(), aRectSize,
-								  aTempPoint, aRectSize, maVirDev );
-				pDev->SetFillColor();
-			}
-		}
-		else
-			bDrawRect = TRUE;
-		if ( bDrawRect )
-		{
-			if ( nStyle & BUTTON_DRAW_PRESSED )
-				pDev->SetFillColor( rStyleSettings.GetShadowColor() );
-			else
-				pDev->SetFillColor( rStyleSettings.GetActiveColor() );
-		}
-		pDev->DrawRect( aRect );
-		aRect.Left()++;
-		aRect.Top()++;
-		aRect.Right()--;
-		aRect.Bottom()--;
-		if ( nStyle & BUTTON_DRAW_PRESSED )
-			pDev->SetLineColor( rStyleSettings.GetShadowColor() );
-		else
-			pDev->SetLineColor( rStyleSettings.GetLightColor() );
-		pDev->DrawLine( aRect.TopLeft(), Point( aRect.Left(), aRect.Bottom() ) );
-		pDev->DrawLine( aRect.TopLeft(), Point( aRect.Right(), aRect.Top() ) );
-		pDev->SetLineColor( rStyleSettings.GetShadowColor() );
-		pDev->DrawLine( Point( aRect.Left()+1, aRect.Bottom() ), aRect.BottomRight() );
-		pDev->DrawLine( Point( aRect.Right(), aRect.Top()+1 ), aRect.BottomRight() );
-	}
-	else
-	{
-		pDev->SetLineColor( Color( COL_BLACK ) );
-		if ( nStyle & BUTTON_DRAW_PRESSED )
-			pDev->SetFillColor( Color( COL_BLACK ) );
-		else
-			pDev->SetFillColor( rStyleSettings.GetActiveColor() );
-		pDev->DrawRect( aRect );
-		aRect.Left()++;
-		aRect.Top()++;
-		aRect.Right()--;
-		aRect.Bottom()--;
-	}
-
-	return aRect;
-}
-
-// =======================================================================
-#ifdef REMOTE_APPSERVER
-void ImplBorderWindow::ImplInit( Window* pParent,
-								 WinBits nStyle, USHORT nTypeStyle,
-								 SystemParentData* pSystemParentData
-								 )
-{
-	static ::com::sun::star::uno::Any aVoid;
-
-	DBG_ASSERT( pSystemParentData, "remote and non remote confusion, please clarify" );
-	ImplInit( pParent, nStyle, nTypeStyle, aVoid );
-}
-#else
-void ImplBorderWindow::ImplInit( Window* pParent,
-								 WinBits nStyle, USHORT nTypeStyle,
-								 const ::com::sun::star::uno::Any& aSystemToken )
-{
-	ImplInit( pParent, nStyle, nTypeStyle, NULL );
-}
-#endif
-
-#ifndef REMOTE_APPSERVER
-void ImplBorderWindow::ImplInit( Window* pParent,
-								 WinBits nStyle, USHORT nTypeStyle,
-								 SystemParentData* pSystemParentData
-								 )
-#else
-void ImplBorderWindow::ImplInit( Window* pParent,
-								 WinBits nStyle,
-								 USHORT nTypeStyle,
-								 const ::com::sun::star::uno::Any& aSystemToken
-								 )
-#endif
-{
-	// Alle WindowBits entfernen, die wir nicht haben wollen
-	WinBits nOrgStyle = nStyle;
-	WinBits nTestStyle = (WB_MOVEABLE | WB_SIZEABLE | WB_ROLLABLE | WB_PINABLE | WB_CLOSEABLE | WB_STANDALONE | WB_DIALOGCONTROL | WB_NODIALOGCONTROL | WB_SYSTEMFLOATWIN | WB_INTROWIN | WB_TOOLTIPWIN | WB_NOSHADOW);
-	if ( nTypeStyle & BORDERWINDOW_STYLE_APP )
-		nTestStyle |= WB_APP;
-	nStyle &= nTestStyle;
-
-	mbBorderWin 		= TRUE;
-	mbSmallOutBorder	= FALSE;
-	if ( nTypeStyle & BORDERWINDOW_STYLE_FRAME )
-	{
-		mbOverlapWin	= TRUE;
-		mbFrame 		= TRUE;
-		mbFrameBorder	= FALSE;
-        // closeable windows may have a border as well, eg. system floating windows without caption
-		if ( (nOrgStyle & (WB_BORDER | WB_NOBORDER | WB_MOVEABLE | WB_SIZEABLE/* | WB_CLOSEABLE*/)) == WB_BORDER )
-			mbSmallOutBorder = TRUE;
-	}
-	else if ( nTypeStyle & BORDERWINDOW_STYLE_OVERLAP )
-	{
-		mbOverlapWin	= TRUE;
-		mbFrameBorder	= TRUE;
-	}
-	else
-		mbFrameBorder	= FALSE;
-
-	if ( nTypeStyle & BORDERWINDOW_STYLE_FLOAT )
-		mbFloatWindow = TRUE;
-	else
-		mbFloatWindow = FALSE;
-
-#ifndef REMOTE_APPSERVER
 	Window::ImplInit( pParent, nStyle, pSystemParentData );
-#else
-	Window::ImplInit( pParent, nStyle, aSystemToken );
-#endif
 	SetBackground();
 	SetTextFillColor();
 
@@ -3464,10 +1820,10 @@ void ImplBorderWindow::Resize()
 
 		if ( mpMenuBarWindow )
 		{
-			long nLeftBorder;
-			long nTopBorder;
-			long nRightBorder;
-			long nBottomBorder;
+			sal_Int32 nLeftBorder;
+			sal_Int32 nTopBorder;
+			sal_Int32 nRightBorder;
+			sal_Int32 nBottomBorder;
 			long nMenuHeight = mpMenuBarWindow->GetSizePixel().Height();
 			if ( mbMenuHide )
 			{
@@ -3552,12 +1908,6 @@ void ImplBorderWindow::InitView()
 		mpBorderView = new ImplNoBorderWindowView( this );
 	else if ( !mbFrameBorder )
 		mpBorderView = new ImplSmallBorderWindowView( this );
-	else if ( GetSettings().GetStyleSettings().GetOptions() & STYLE_OPTION_MACSTYLE )
-		mpBorderView = new ImplMacBorderWindowView( this );
-	else if ( GetSettings().GetStyleSettings().GetOptions() & STYLE_OPTION_OS2STYLE )
-		mpBorderView = new ImplOS2BorderWindowView( this );
-	else if ( GetSettings().GetStyleSettings().GetOptions() & STYLE_OPTION_UNIXSTYLE )
-		mpBorderView = new ImplUnxBorderWindowView( this );
 	else
 		mpBorderView = new ImplStdBorderWindowView( this );
 	Size aSize = GetOutputSizePixel();
@@ -3568,10 +1918,10 @@ void ImplBorderWindow::InitView()
 
 void ImplBorderWindow::UpdateView( BOOL bNewView, const Size& rNewOutSize )
 {
-	long nLeftBorder;
-	long nTopBorder;
-	long nRightBorder;
-	long nBottomBorder;
+	sal_Int32 nLeftBorder;
+	sal_Int32 nTopBorder;
+	sal_Int32 nRightBorder;
+	sal_Int32 nBottomBorder;
 	Size aOldSize = GetSizePixel();
 	Size aOutputSize = rNewOutSize;
 
@@ -3614,10 +1964,10 @@ void ImplBorderWindow::InvalidateBorder(
 	if ( IsReallyVisible() )
 	{
 		// Nur wenn wir einen Border haben, muessen wir auch invalidieren
-		long nLeftBorder;
-		long nTopBorder;
-		long nRightBorder;
-		long nBottomBorder;
+		sal_Int32 nLeftBorder;
+		sal_Int32 nTopBorder;
+		sal_Int32 nRightBorder;
+		sal_Int32 nBottomBorder;
 		mpBorderView->GetBorder( nLeftBorder, nTopBorder, nRightBorder, nBottomBorder );
 		if ( nLeftBorder || nTopBorder || nRightBorder || nBottomBorder )
 		{
@@ -3755,8 +2105,8 @@ void ImplBorderWindow::SetMenuBarMode( B
 
 // -----------------------------------------------------------------------
 
-void ImplBorderWindow::GetBorder( long& rLeftBorder, long& rTopBorder,
-								  long& rRightBorder, long& rBottomBorder ) const
+void ImplBorderWindow::GetBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+								  sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const
 {
 	mpBorderView->GetBorder( rLeftBorder, rTopBorder, rRightBorder, rBottomBorder );
 	if ( mpMenuBarWindow && !mbMenuHide )
Index: vcl/source/window/btndlg.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/btndlg.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/source/window/btndlg.cxx	5 Dec 2000 15:16:28 -0000	1.2
+++ vcl/source/window/btndlg.cxx	6 Jan 2004 14:03:57 -0000	1.4
@@ -59,7 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_BTNDLG_CXX
 #include <tools/ref.hxx>
 #ifndef _TOOLS_DEBUG_HXX
 #include <tools/debug.hxx>
@@ -76,10 +75,10 @@
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
Index: vcl/source/window/cmdevt.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/cmdevt.cxx,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- vcl/source/window/cmdevt.cxx	30 Jun 2003 14:30:09 -0000	1.4
+++ vcl/source/window/cmdevt.cxx	6 Jan 2004 14:04:53 -0000	1.5
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_CMDEVT_CXX
 
 #ifndef _STRING_H
 #include <string.h>
Index: vcl/source/window/cursor.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/cursor.cxx,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -p -u -r1.5 -r1.7
--- vcl/source/window/cursor.cxx	17 Apr 2003 15:19:06 -0000	1.5
+++ vcl/source/window/cursor.cxx	6 Jan 2004 14:05:26 -0000	1.7
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_CURSOR_CXX
-
 #ifndef _SV_SVAPP_HXX
 #include <svapp.hxx>
 #endif
@@ -76,18 +74,13 @@
 #ifndef _SV_WINDOW_H
 #include <window.h>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_CURSOR_HXX
 #include <cursor.hxx>
 #endif
-#ifdef REMOTE_APPSERVER
-#ifndef _SV_WINDATA_HXX
-#include <windata.hxx>
-#endif
-#endif
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -208,10 +201,6 @@ void Cursor::ImplDraw()
 		// Ausgabeflaeche berechnen und ausgeben
 		ImplCursorInvert( mpData );
 		mpData->mbCurVisible = TRUE;
-#ifdef REMOTE_APPSERVER
-        // update remote cursor pos
-        ImplUpdateCursorRect( pWindow );
-#endif
 	}
 }
 
@@ -331,8 +320,8 @@ Cursor::Cursor()
 // -----------------------------------------------------------------------
 
 Cursor::Cursor( const Cursor& rCursor ) :
-	maPos( rCursor.maPos ),
-	maSize( rCursor.maSize )
+	maSize( rCursor.maSize ),
+	maPos( rCursor.maPos )
 {
 	mpData			= NULL;
 	mpWindow		= NULL;
Index: vcl/source/window/decoview.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/decoview.cxx,v
retrieving revision 1.4
retrieving revision 1.9
diff -u -p -u -r1.4 -r1.9
--- vcl/source/window/decoview.cxx	27 Mar 2003 17:58:20 -0000	1.4
+++ vcl/source/window/decoview.cxx	21 May 2004 16:28:29 -0000	1.9
@@ -59,13 +59,11 @@
  *
  ************************************************************************/
 
-#define _SV_DECOVIEW_CXX
-
 #ifndef _SV_SETTINGS_HXX
 #include <settings.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_OUTDEV_HXX
 #include <outdev.hxx>
@@ -76,8 +74,9 @@
 #ifndef _SV_DECOVIEW_HXX
 #include <decoview.hxx>
 #endif
-
-#pragma hdrstop
+#ifndef _SV_WINDOW_HXX
+#include <window.hxx>
+#endif
 
 // =======================================================================
 
@@ -157,7 +156,7 @@ static void ImplDrawSymbol( OutputDevice
 							SymbolType eType  )
 {
 	// Groessen vorberechnen
-	long	n		= ::std::min( rRect.GetWidth(), rRect.GetHeight() );
+	long	n		= Min( rRect.GetWidth(), rRect.GetHeight() );
 	long	nSize	= n;
 
 	if ( n & 0x01 )
@@ -562,7 +561,8 @@ static void ImplDrawSymbol( OutputDevice
 				long nStepsY = aPos2.Y()-aPos1.Y();
 				long nX = aPos1.X();
 				long nY = aPos1.Y();
-				for ( long n = 0; n <= nStepsY; n++ )
+				long n;
+				for ( n = 0; n <= nStepsY; n++ )
 				{
                     if( bRTL )
                         nX--;
@@ -829,7 +829,7 @@ void DecorationView::DrawHighlightFrame(
 // =======================================================================
 
 static void ImplDrawDPILineRect( OutputDevice* pDev, Rectangle& rRect,
-								 const Color* pColor )
+								 const Color* pColor, BOOL bRound = FALSE )
 {
 	long nLineWidth = pDev->ImplGetDPIX()/300;
 	long nLineHeight = pDev->ImplGetDPIY()/300;
@@ -844,7 +844,15 @@ static void ImplDrawDPILineRect( OutputD
 		{
 			pDev->SetLineColor( *pColor );
 			pDev->SetFillColor();
-			pDev->DrawRect( rRect );
+            if( bRound )
+            {
+			    pDev->DrawLine( Point( rRect.Left()+1, rRect.Top()), Point( rRect.Right()-1, rRect.Top()) );
+			    pDev->DrawLine( Point( rRect.Left()+1, rRect.Bottom()), Point( rRect.Right()-1, rRect.Bottom()) );
+			    pDev->DrawLine( Point( rRect.Left(), rRect.Top()+1), Point( rRect.Left(), rRect.Bottom()-1) );
+			    pDev->DrawLine( Point( rRect.Right(), rRect.Top()+1), Point( rRect.Right(), rRect.Bottom()-1) );
+            }
+            else
+			    pDev->DrawRect( rRect );
 		}
 		else
 		{
@@ -876,14 +884,33 @@ static void ImplDrawFrame( OutputDevice*
     BOOL bMenuStyle = nStyle & FRAME_DRAW_MENU;
     nStyle &= ~FRAME_DRAW_MENU;
 
+    Window *pWin = NULL;
+    if( pDev->GetOutDevType() == OUTDEV_WINDOW )
+        pWin = (Window*) pDev;
+
+    // UseFlatBorders disables 3D style for all frames except menus
+    // menus may use different border colors (eg on XP)
+    // normal frames will be drawn using the shadow color 
+    // whereas window frame borders will use black
+    BOOL bFlatBorders = ( !bMenuStyle && rStyleSettings.GetUseFlatBorders() );
+
+    // no flat borders for standard VCL controls (ie formcontrols that keep their classic look)
+    // will not affect frame windows (like dropdowns)
+    if( pWin && pWin->GetType() == WINDOW_BORDERWINDOW && (pWin != pWin->ImplGetFrameWindow()) )
+        bFlatBorders = FALSE;
+
+    // no round corners for window frame borders
+    BOOL bRound = (bFlatBorders && !(nStyle & FRAME_DRAW_WINDOWBORDER));
+
 	if ( (rStyleSettings.GetOptions() & STYLE_OPTION_MONO) ||
-		 (pDev->GetOutDevType() == OUTDEV_PRINTER) )
+		 (pDev->GetOutDevType() == OUTDEV_PRINTER) ||
+         bFlatBorders )
 		nStyle |= FRAME_DRAW_MONO;
 
 	if ( nStyle & FRAME_DRAW_NODRAW )
 	{
 		if ( nStyle & FRAME_DRAW_MONO )
-			ImplDrawDPILineRect( pDev, rRect, NULL );
+			ImplDrawDPILineRect( pDev, rRect, NULL, bRound );
 		else
 		{
 			USHORT nFrameStyle = nStyle & FRAME_DRAW_STYLE;
@@ -916,10 +943,12 @@ static void ImplDrawFrame( OutputDevice*
 	{
 		if ( nStyle & FRAME_DRAW_MONO )
 		{
-			Color aColor( COL_BLACK );
-			if( pDev->GetSettings().GetStyleSettings().GetFaceColor().IsDark() )
+            // flat borders will be drawn in the shadow color
+            // but flat window borders will use black
+            Color aColor( bRound ? rStyleSettings.GetShadowColor() : COL_BLACK );
+			if( aColor.IsDark() && pDev->GetSettings().GetStyleSettings().GetFaceColor().IsDark() )
 				aColor = Color( COL_WHITE );
-			ImplDrawDPILineRect( pDev, rRect, &aColor );
+			ImplDrawDPILineRect( pDev, rRect, &aColor, bRound );
 		}
 		else
 		{
@@ -969,17 +998,28 @@ static void ImplDrawFrame( OutputDevice*
 				{
 					if ( nFrameStyle == FRAME_DRAW_DOUBLEIN )
 					{
-						pDev->ImplDraw2ColorFrame( rRect,
-												   rStyleSettings.GetShadowColor(),
-												   rStyleSettings.GetLightColor() );
+                        if( bFlatBorders ) // no 3d effect
+                            pDev->ImplDraw2ColorFrame( rRect,
+												    rStyleSettings.GetShadowColor(),
+												    rStyleSettings.GetShadowColor() );
+                        else
+						    pDev->ImplDraw2ColorFrame( rRect,
+												    rStyleSettings.GetShadowColor(),
+												    rStyleSettings.GetLightColor() );
 					}
 					else
 					{
-						pDev->ImplDraw2ColorFrame( rRect,
-                                                   bMenuStyle ? 
-                                                   rStyleSettings.GetMenuBorderColor() :
+                        if( bMenuStyle )
+						    pDev->ImplDraw2ColorFrame( rRect,
+                                                   rStyleSettings.GetMenuBorderColor(),
+												   rStyleSettings.GetDarkShadowColor() );
+                        else
+						    pDev->ImplDraw2ColorFrame( rRect,
+                                                   bFlatBorders ? // no 3d effect
+                                                   rStyleSettings.GetDarkShadowColor() :
 												   rStyleSettings.GetLightBorderColor(),
 												   rStyleSettings.GetDarkShadowColor() );
+                                                   
 					}
 
 					rRect.Left()++;
@@ -987,11 +1027,17 @@ static void ImplDrawFrame( OutputDevice*
 					rRect.Right()--;
 					rRect.Bottom()--;
 
+                    BOOL bDrawn = TRUE;
 					if ( nFrameStyle == FRAME_DRAW_DOUBLEIN )
 					{
-						pDev->ImplDraw2ColorFrame( rRect,
-												   rStyleSettings.GetDarkShadowColor(),
-												   rStyleSettings.GetLightBorderColor() );
+                        if( bFlatBorders ) // no 3d effect
+						    pDev->ImplDraw2ColorFrame( rRect,
+												    rStyleSettings.GetFaceColor(),
+												    rStyleSettings.GetFaceColor() );
+                        else
+						    pDev->ImplDraw2ColorFrame( rRect,
+												    rStyleSettings.GetDarkShadowColor(),
+												    rStyleSettings.GetLightBorderColor() );
 					}
 					else
 					{
@@ -1000,12 +1046,16 @@ static void ImplDrawFrame( OutputDevice*
 						    pDev->ImplDraw2ColorFrame( rRect,
 												    rStyleSettings.GetLightColor(),
 												    rStyleSettings.GetShadowColor() );
+                        else
+                            bDrawn = FALSE;
 					}
-
-					rRect.Left()++;
-					rRect.Top()++;
-					rRect.Right()--;
-					rRect.Bottom()--;
+                    if( bDrawn )
+                    {
+					    rRect.Left()++;
+					    rRect.Top()++;
+					    rRect.Right()--;
+					    rRect.Bottom()--;
+                    }
 				}
 			}
 		}
@@ -1277,8 +1327,7 @@ Rectangle DecorationView::DrawButton( co
 	{
 		const StyleSettings& rStyleSettings = mpOutDev->GetSettings().GetStyleSettings();
 
-		if ( (rStyleSettings.GetOptions() & STYLE_OPTION_MONO) ||
-			 (mpOutDev->GetOutDevType() == OUTDEV_PRINTER) )
+		if ( rStyleSettings.GetOptions() & STYLE_OPTION_MONO )
 			nStyle |= BUTTON_DRAW_MONO;
 
 		if ( nStyle & BUTTON_DRAW_NODRAW )
Index: vcl/source/window/dialog.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/dialog.cxx,v
retrieving revision 1.25.136.1
retrieving revision 1.29
diff -u -p -u -r1.25.136.1 -r1.29
--- vcl/source/window/dialog.cxx	31 Oct 2003 15:43:35 -0000	1.25.136.1
+++ vcl/source/window/dialog.cxx	17 Jun 2004 12:22:28 -0000	1.29
@@ -59,14 +59,12 @@
  *
  ************************************************************************/
 
-#define _SV_DIALOG_CXX
-
 #ifndef _TOOLS_DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -111,7 +106,7 @@
 
 #include <unowrap.hxx>
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -333,7 +328,7 @@ void Dialog::ImplInit( Window* pParent, 
     {
         pParent = Application::GetDefDialogParent();
         if ( !pParent && !(nStyle & WB_SYSTEMWINDOW) )
-            pParent = Application::GetAppWindow();
+            pParent = ImplGetSVData()->maWinData.mpAppWin;
 
         // If Parent is disabled, then we search for a modal dialog
         // in this frame
@@ -894,7 +881,7 @@ void Dialog::GrabFocusToFirstControl()
         pFocusControl->ImplControlFocus( GETFOCUS_INIT );
 }
 
-void Dialog::GetDrawWindowBorder( long& rLeftBorder, long& rTopBorder, long& rRightBorder, long& rBottomBorder ) const
+void Dialog::GetDrawWindowBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder, sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const
 {
     ImplBorderWindow aImplWin( (Window*)this, WB_BORDER|WB_STDWORK, BORDERWINDOW_STYLE_OVERLAP );
 //  aImplWin.SetText( GetText() );
Index: vcl/source/window/dlgctrl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/dlgctrl.cxx,v
retrieving revision 1.13
retrieving revision 1.15
diff -u -p -u -r1.13 -r1.15
--- vcl/source/window/dlgctrl.cxx	28 May 2003 12:32:21 -0000	1.13
+++ vcl/source/window/dlgctrl.cxx	6 Jan 2004 14:09:02 -0000	1.15
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_DLGCTRL_CXX
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
@@ -93,7 +91,7 @@
 using namespace ::com::sun::star;
 
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -1023,7 +1021,6 @@ Window* Window::GetLabelFor() const
 {
     Window* pWindow = NULL;
     Window* pFrameWindow = ImplGetFrameWindow();
-    Window* pParent = ImplGetParent();
 
     WinBits nFrameStyle = pFrameWindow->GetStyle();
     if( ! ( nFrameStyle & WB_DIALOGCONTROL )
@@ -1094,7 +1091,6 @@ Window* Window::GetLabeledBy() const
 {
     Window* pWindow = NULL;
     Window* pFrameWindow = ImplGetFrameWindow();
-    Window* pParent = ImplGetParent();
 
 /* #105538# OJ approved by PL
     WinBits nFrameStyle = pFrameWindow->GetStyle();
Index: vcl/source/window/dndevdis.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/dndevdis.cxx,v
retrieving revision 1.12
retrieving revision 1.14
diff -u -p -u -r1.12 -r1.14
--- vcl/source/window/dndevdis.cxx	4 Jun 2003 11:22:44 -0000	1.12
+++ vcl/source/window/dndevdis.cxx	6 Jan 2004 14:09:34 -0000	1.14
@@ -338,7 +338,6 @@ void SAL_CALL DNDEventDispatcher::dragGe
 {	MutexGuard aImplGuard( m_aMutex );
 
 	Point origin( dge.DragOriginX, dge.DragOriginY );
-	sal_Int32 nListeners;
 
 	// find the window that is toplevel for this coordinates
 	OClearableGuard aSolarGuard( Application::GetSolarMutex() );
@@ -594,17 +593,5 @@ sal_Int32 DNDEventDispatcher::fireDragGe
         pWindow->DecrementLockCount();
 	}
     
-#ifdef REMOTE_APPSERVER
-
-     if( ! pWindow->ImplGetFrameData()->mbInternalDragGestureRecognizer )
-     {
-        if( xSource.is() )
-        {
-            xSource->startDrag( DragGestureEvent(), 0, 0, 0, Reference< XTransferable >(), Reference< XDragSourceListener > () );
-        }
-     }
-     
-#endif
-
 	return n;
 }
Index: vcl/source/window/dndlcon.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/dndlcon.cxx,v
retrieving revision 1.6
retrieving revision 1.7
diff -u -p -u -r1.6 -r1.7
--- vcl/source/window/dndlcon.cxx	28 Jun 2001 12:51:04 -0000	1.6
+++ vcl/source/window/dndlcon.cxx	6 Jan 2004 14:10:09 -0000	1.7
@@ -70,8 +70,8 @@ using namespace ::com::sun::star::datatr
 // 
 //==================================================================================================
 
-DNDListenerContainer::DNDListenerContainer( sal_Int8 nDefaultActions ) : m_aMutex(),
-	WeakComponentImplHelper4< XDragGestureRecognizer, XDropTargetDragContext, XDropTargetDropContext, XDropTarget >(m_aMutex)
+DNDListenerContainer::DNDListenerContainer( sal_Int8 nDefaultActions )
+	: WeakComponentImplHelper4< XDragGestureRecognizer, XDropTargetDragContext, XDropTargetDropContext, XDropTarget >(GetMutex())
 {
 	m_bActive = sal_True;
 	m_nDefaultActions = nDefaultActions;	
Index: vcl/source/window/dndlcon.hxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/dndlcon.hxx,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- vcl/source/window/dndlcon.hxx	28 Jun 2001 12:51:04 -0000	1.4
+++ vcl/source/window/dndlcon.hxx	6 Jan 2004 14:10:44 -0000	1.5
@@ -86,14 +86,15 @@
 #include <cppuhelper/compbase4.hxx>
 #endif
 
-class DNDListenerContainer : public ::cppu::WeakComponentImplHelper4< 
+#include <unohelp2.hxx>
+
+class DNDListenerContainer :    public ::vcl::unohelper::MutexHelper, 
+                                public ::cppu::WeakComponentImplHelper4< 
 	::com::sun::star::datatransfer::dnd::XDragGestureRecognizer, \
 	::com::sun::star::datatransfer::dnd::XDropTargetDragContext,
 	::com::sun::star::datatransfer::dnd::XDropTargetDropContext,
 	::com::sun::star::datatransfer::dnd::XDropTarget >
 {
-	::osl::Mutex m_aMutex;
-
 	sal_Bool m_bActive;
 	sal_Int8 m_nDefaultActions;
 
Index: vcl/source/window/dockwin.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/dockwin.cxx,v
retrieving revision 1.13
retrieving revision 1.15
diff -u -p -u -r1.13 -r1.15
--- vcl/source/window/dockwin.cxx	27 Mar 2003 17:58:21 -0000	1.13
+++ vcl/source/window/dockwin.cxx	6 Jan 2004 14:11:10 -0000	1.15
@@ -59,10 +59,11 @@
  *
  ************************************************************************/
 
-#define _SV_DOCKWIN_CXX
-
+#ifndef _SV_SVSYS_HXX
+#include <svsys.h>
+#endif
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
@@ -82,16 +83,13 @@
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
 #endif
-#ifndef _SV_SVSYS_HXX
-#include <svsys.h>
-#endif
 #ifndef _SV_TIMER_HXX
 #include <timer.hxx>
 #endif
 #include <unowrap.hxx>
 #include <salframe.hxx>
 
-#pragma hdrstop
+
 
 // =======================================================================
 
Index: vcl/source/window/floatwin.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/floatwin.cxx,v
retrieving revision 1.25
retrieving revision 1.27
diff -u -p -u -r1.25 -r1.27
--- vcl/source/window/floatwin.cxx	27 Mar 2003 17:58:22 -0000	1.25
+++ vcl/source/window/floatwin.cxx	6 Jan 2004 14:11:39 -0000	1.27
@@ -59,12 +59,9 @@
  *
  ************************************************************************/
 
-#define _SV_FLOATWIN_CXX
-
-#ifndef _DEBUG_HXX
-#include <tools/debug.hxx>
+#ifndef _SV_SVSYS_HXX
+#include <svsys.h>
 #endif
-
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
 #endif
@@ -90,15 +87,15 @@
 #include <window.h>
 #endif
 #ifndef _SV_RC_H
-#include <rc.h>
-#endif
-#ifndef _SV_SVSYS_HXX
-#include <svsys.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
-#pragma hdrstop
+#ifndef _DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+
 
 // =======================================================================
 
@@ -108,9 +105,10 @@ void FloatingWindow::ImplInit( Window* p
     mbInCleanUp = FALSE;
     mbGrabFocus = FALSE;
 
+    DBG_ASSERT( pParent, "FloatWindow::FloatingWindow(): - pParent == NULL!" );
 
     if ( !pParent )
-        pParent = Application::GetAppWindow();
+        pParent = ImplGetSVData()->maWinData.mpAppWin;
 
     DBG_ASSERT( pParent, "FloatWindow::FloatingWindow(): - pParent == NULL and no AppWindow exists" );
 
Index: vcl/source/window/introwin.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/introwin.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/source/window/introwin.cxx	27 Mar 2003 17:58:22 -0000	1.2
+++ vcl/source/window/introwin.cxx	6 Jan 2004 14:12:14 -0000	1.4
@@ -59,25 +59,19 @@
  *
  ************************************************************************/
 
-#define _SV_INTROWIN_CXX
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
-#else
-#include <rmwindow.hxx>
-#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -100,7 +94,7 @@
 
 #include <introwin.hxx>
 
-#pragma hdrstop
+
 
 
 // =======================================================================
Index: vcl/source/window/keycod.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/keycod.cxx,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/source/window/keycod.cxx	4 Dec 2001 15:26:43 -0000	1.2
+++ vcl/source/window/keycod.cxx	6 Jan 2004 14:12:50 -0000	1.4
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_KEYCOD_CXX
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -82,14 +80,10 @@
 #endif
 
 #ifndef _RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#ifdef REMOTE_APPSERVER
-#include <rmwindow.hxx>
-#endif
 
-#pragma hdrstop
 
 // =======================================================================
 
@@ -171,84 +165,16 @@ XubString KeyCode::GetName( Window* pWin
 {
 	if ( !pWindow )
 		pWindow = ImplGetDefaultWindow();
-#ifndef REMOTE_APPSERVER
 	return pWindow->ImplGetFrame()->GetKeyName( GetFullCode() );
-#else
-	ImplSVData* pSVData = ImplGetSVData();
-	if ( !pSVData->mpKeyNames )
-	{
-		pSVData->mpKeyNames = new KeyNames;
-		NMSP_CLIENT::KeyNameSequence aKeyNames;
-		pWindow->ImplGetFrame()->GetKeyNames( aKeyNames );
-		ULONG nNames = aKeyNames.getLength();
-		for ( USHORT n = 0; n < nNames; n++ )
-		{
-			const NMSP_CLIENT::IDLKeyNameInfo& rInfo = aKeyNames.getConstArray()[n];
-			pSVData->mpKeyNames->Insert( rInfo.nCode, new String( rInfo.aName )  );
-		}
-	}
-
-	String		aName;
-	const int	nMods = 3;
-	USHORT		nKeyCode = GetFullCode();
-	USHORT		aModifiers[nMods] = { KEY_MOD2, KEY_MOD1, KEY_SHIFT };
-	for ( USHORT n = 0; n < nMods; n++ )
-	{
-		USHORT nMod = aModifiers[n];
-		if ( nKeyCode & nMod )
-		{
-			String* pMod = pSVData->mpKeyNames->Get( nMod );
-			if ( pMod )
-			{
-				aName += *pMod;
-				aName += '+';
-			}
-		}
-	}
-
-	USHORT nCode = GetCode();
-	if ( (nCode >= KEY_0) && (nCode <= KEY_9) )
-		aName += (sal_Unicode)'0'+(nCode-KEY_0);
-	else if ( (nCode >= KEY_A) && (nCode <= KEY_Z) )
-		aName += (sal_Unicode)'A'+(nCode-KEY_A);
-	else if ( (nCode >= KEY_F1) && (nCode <= KEY_F9) )
-	{
-		aName += (sal_Unicode)'F';
-		aName += (sal_Unicode)'1' + (nCode-KEY_F1);
-	}
-	else if ( (nCode >= KEY_F10) && (nCode <= KEY_F19) )
-	{
-		aName += (sal_Unicode)'F';
-		aName += (sal_Unicode)'1';
-		aName += (sal_Unicode)'0' + (nCode-KEY_F10);
-	}
-	else if ( (nCode >= KEY_F20) && (nCode <= KEY_F26) )
-	{
-		aName += (sal_Unicode)'F';
-		aName += (sal_Unicode)'2';
-		aName += (sal_Unicode)'0' + (nCode-KEY_F20);
-	}
-	else
-	{
-		String* pName = pSVData->mpKeyNames->Get( nCode );
-		if ( pName )
-			aName += *pName;
-	}
-	return aName;
-#endif
 }
 
 // -----------------------------------------------------------------------
 
 XubString KeyCode::GetSymbolName( const XubString& rFontName, Window* pWindow ) const
 {
-#ifndef REMOTE_APPSERVER
 	if ( !pWindow )
 		pWindow = ImplGetDefaultWindow();
 	return pWindow->ImplGetFrame()->GetSymbolKeyName( rFontName, GetFullCode() );
-#else
-	return GetName( pWindow );
-#endif
 }
 
 // -----------------------------------------------------------------------
Index: vcl/source/window/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/source/window/makefile.mk,v
retrieving revision 1.10
retrieving revision 1.13
diff -u -p -u -r1.10 -r1.13
--- vcl/source/window/makefile.mk	27 Mar 2003 17:58:22 -0000	1.10
+++ vcl/source/window/makefile.mk	10 May 2004 15:50:07 -0000	1.13
@@ -76,6 +76,7 @@ TARGET=win
 # --- Files --------------------------------------------------------
 
 SLOFILES=	$(SLO)$/accel.obj		\
+			$(SLO)$/abstdlg.obj		\
 			$(SLO)$/accmgr.obj		\
 			$(SLO)$/brdwin.obj		\
 			$(SLO)$/btndlg.obj		\
@@ -103,6 +104,7 @@ SLOFILES=	$(SLO)$/accel.obj		\
 			$(SLO)$/toolbox2.obj	\
 			$(SLO)$/window.obj		\
 			$(SLO)$/window2.obj 	\
+			$(SLO)$/window3.obj		\
 			$(SLO)$/winproc.obj 	\
 			$(SLO)$/wrkwin.obj		\
 			$(SLO)$/introwin.obj	\
@@ -111,41 +113,29 @@ SLOFILES=	$(SLO)$/accel.obj		\
 			$(SLO)$/dndlcon.obj     \
 			$(SLO)$/taskpanelist.obj
 
-.IF "$(remote)"!=""
-EXCEPTIONSFILES=					\
-			$(SLO)$/brdwin.obj		\
-			$(SLO)$/keycod.obj		\
-			$(SLO)$/window.obj		\
-			$(SLO)$/winproc.obj 	\
-			$(SLO)$/wrkwin.obj		\
-			$(SLO)$/introwin.obj	\
-			$(SLO)$/accel.obj		\
-			$(SLO)$/cursor.obj		\
-			$(SLO)$/dlgctrl.obj 	\
-			$(SLO)$/floatwin.obj	\
-			$(SLO)$/menu.obj		\
-			$(SLO)$/msgbox.obj		\
-			$(SLO)$/split.obj		\
-			$(SLO)$/status.obj		\
-			$(SLO)$/syschild.obj	\
-			$(SLO)$/syswin.obj		\
-			$(SLO)$/tabpage.obj 	\
-			$(SLO)$/toolbox.obj 	\
-			$(SLO)$/toolbox2.obj	\
-			$(SLO)$/dialog.obj		\
-			$(SLO)$/dndevdis.obj	\
-			$(SLO)$/dndlcon.obj
-.ELSE
 EXCEPTIONSFILES=					\
 			$(SLO)$/window.obj		\
 			$(SLO)$/winproc.obj		\
 			$(SLO)$/syswin.obj		\
 			$(SLO)$/dndevdis.obj	\
 			$(SLO)$/dndlcon.obj
-.ENDIF
 
 # --- Targets ------------------------------------------------------
 
 .INCLUDE :	target.mk
 
 .INCLUDE :	$(PRJ)$/util$/target.pmk
+
+$(INCCOM)$/cuilib.hxx: makefile.mk
+.IF "$(GUI)"=="UNX"
+    $(RM) $@
+    +echo \#define DLL_NAME \"libcui$(UPD)$(DLLPOSTFIX)$(DLLPOST)\" >$@
+.ELSE
+.IF "$(USE_SHELL)"!="4nt"
+    +echo \#define DLL_NAME \"cui$(UPD)$(DLLPOSTFIX)$(DLLPOST)\" >$@
+.ELSE          # "$(USE_SHELL)"!="4nt"
+    +echo #define DLL_NAME "cui$(UPD)$(DLLPOSTFIX)$(DLLPOST)" >$@
+.ENDIF          # "$(USE_SHELL)"!="4nt"
+.ENDIF
+
+$(SLO)$/abstdlg.obj : $(INCCOM)$/cuilib.hxx
Index: vcl/source/window/menu.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/menu.cxx,v
retrieving revision 1.96.60.1
retrieving revision 1.106
diff -u -p -u -r1.96.60.1 -r1.106
--- vcl/source/window/menu.cxx	13 Nov 2003 16:48:45 -0000	1.96.60.1
+++ vcl/source/window/menu.cxx	17 Jun 2004 12:23:14 -0000	1.106
@@ -59,8 +59,12 @@
  *
  ************************************************************************/
 
-#define _SV_MENU_CXX
-
+#ifndef _SV_SVSYS_HXX
+#include <svsys.h>
+#endif
+#ifndef _SV_SALINST_HXX
+#include <salinst.hxx>
+#endif
 #ifndef _LIST_HXX
 #include <tools/list.hxx>
 #endif
@@ -110,7 +114,7 @@
 #include <bitmap.hxx>
 #endif
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_MENU_HXX
 #include <menu.hxx>
@@ -143,8 +144,13 @@
 #include <toolbox.hxx>
 #endif
 #include <tools/stream.hxx>
+#ifndef _SV_SALMENU_HXX
+#include <salmenu.hxx>
+#endif
+#ifndef _SV_SALFRAME_HXX
+#include <salframe.hxx>
+#endif
 
-#pragma hdrstop
 
 #ifndef _COM_SUN_STAR_UNO_REFERENCE_H_
 #include <com/sun/star/uno/Reference.h>
@@ -196,11 +202,6 @@ DBG_NAME( Menu );
 // document closer
 #define IID_DOCUMENTCLOSE 1
 
-inline BOOL ImplIsMouseFollow()
-{
-    return ( Application::GetSettings().GetMouseSettings().GetFollow() & MOUSE_FOLLOW_MENU ) ? TRUE : FALSE;
-}
-
 struct MenuItemData
 {
     USHORT          nId;					// SV Id
@@ -212,6 +213,7 @@ struct MenuItemData
     XubString       aHelpText;				// Help-String
     XubString       aTipHelpText;			// TipHelp-String (eg, expanded filenames)
     XubString       aCommandStr;			// CommandString
+    XubString       aHelpCommandStr;        // Help command string (to reference external help)
     ULONG           nHelpId;				// Help-Id
     ULONG           nUserValue;				// User value
     Image           aImage;					// Image
@@ -225,10 +227,15 @@ struct MenuItemData
 	XubString		aAccessibleName;		// accessible name
 	XubString		aAccessibleDescription;	// accessible description
 
-                    MenuItemData() {}
+    SalMenuItem*    pSalMenuItem;           // access to native menu
+
+                    MenuItemData() :
+                        pSalMenuItem ( NULL )
+                    {}
                     MenuItemData( const XubString& rStr, const Image& rImage ) :
                         aText( rStr ),
-                        aImage( rImage )
+                        aImage( rImage ),
+                        pSalMenuItem ( NULL )
                     {}
                     ~MenuItemData();
 };
@@ -241,6 +248,8 @@ MenuItemData::~MenuItemData()
         delete pAutoSubMenu;
         pAutoSubMenu = NULL;
     }
+    if( pSalMenuItem )
+        ImplGetSVData()->mpDefInst->DestroyMenuItem( pSalMenuItem );
 }
 
 class MenuItemList : public List
@@ -300,6 +309,18 @@ MenuItemData* MenuItemList::Insert( USHO
     pData->bIsTemporary 	= FALSE;
     pData->bMirrorMode		= FALSE;
     pData->nItemImageAngle	= 0;
+
+    SalItemParams aSalMIData;
+    aSalMIData.nId = nId;
+    aSalMIData.eType = eType;
+    aSalMIData.nBits = nBits;
+    aSalMIData.pMenu = pMenu;
+    aSalMIData.aText = rStr;
+    aSalMIData.aImage = rImage;
+
+    // Native-support: returns NULL if not supported
+    pData->pSalMenuItem = ImplGetSVData()->mpDefInst->CreateMenuItem( &aSalMIData );
+
     List::Insert( (void*)pData, nPos );
     return pData;
 }
@@ -319,6 +340,18 @@ void MenuItemList::InsertSeparator( USHO
     pData->bIsTemporary 	= FALSE;
     pData->bMirrorMode		= FALSE;
     pData->nItemImageAngle	= 0;
+
+    SalItemParams aSalMIData;
+    aSalMIData.nId = 0;
+    aSalMIData.eType = MENUITEM_SEPARATOR;
+    aSalMIData.nBits = 0;
+    aSalMIData.pMenu = NULL;
+    aSalMIData.aText = XubString();
+    aSalMIData.aImage = Image();
+
+    // Native-support: returns NULL if not supported
+    pData->pSalMenuItem = ImplGetSVData()->mpDefInst->CreateMenuItem( &aSalMIData );
+
     List::Insert( (void*)pData, nPos );
 }
 
@@ -633,6 +656,7 @@ public:
     virtual ::com::sun::star::uno::Reference< ::com::sun::star::accessibility::XAccessible > CreateAccessible();
 
     void SetAutoPopup( BOOL bAuto ) { mbAutoPopup = bAuto; }
+    void            ImplLayoutChanged();
 };
 
 
@@ -663,7 +687,6 @@ static BOOL ImplHandleHelpEvent( Window*
 {
     BOOL bDone = FALSE;
     USHORT nId = 0;
-	ImplSVData* pSVData = ImplGetSVData();
 
     if ( nHighlightedItem != ITEMPOS_INVALID )
     {
@@ -723,10 +746,19 @@ static BOOL ImplHandleHelpEvent( Window*
     return bDone;
 }
 
-
 Menu::Menu()
 {
     DBG_CTOR( Menu, NULL );
+    bIsMenuBar = FALSE;
+    ImplInit();
+}
+
+// this constructor makes sure we're creating the native menu
+// with the correct type (ie, MenuBar vs. PopupMenu)
+Menu::Menu( BOOL bMenubar )
+{
+    DBG_CTOR( Menu, NULL );
+    bIsMenuBar = bMenubar;
     ImplInit();
 }
 
@@ -756,13 +788,18 @@ Menu::~Menu()
     delete pItemList;
     delete pLogo;
     delete mpLayoutData;
+
+    // Native-support: destroy SalMenu
+    ImplSetSalMenu( NULL );
 }
 
 void Menu::ImplInit()
 {
+    mnHighlightedItemPos = ITEMPOS_INVALID;
+    mpSalMenu       = NULL;
     nMenuFlags      = 0;
     nDefaultItem    = 0;
-    bIsMenuBar      = FALSE;
+    //bIsMenuBar      = FALSE;  // this is now set in the ctor, must not be changed here!!!
     nSelectedId     = 0;
     pItemList       = new MenuItemList;
     pLogo           = NULL;
@@ -773,6 +810,9 @@ void Menu::ImplInit()
     bInCallback     = FALSE;
     bKilled         = FALSE;
     mpLayoutData	= NULL;
+
+    // Native-support: returns NULL if not supported
+    mpSalMenu = ImplGetSVData()->mpDefInst->CreateMenu( bIsMenuBar );
 }
 
 void Menu::ImplLoadRes( const ResId& rResId )
@@ -958,14 +998,18 @@ void Menu::InsertItem( USHORT nItemId, c
     DBG_ASSERT( GetItemPos( nItemId ) == MENU_ITEM_NOTFOUND,
                 "Menu::InsertItem(): ItemId already exists" );
 
-    // Falls Position > ItemCount, dann anheangen
+    // if Position > ItemCount, append
     if ( nPos >= (USHORT)pItemList->Count() )
         nPos = MENU_APPEND;
 
-    // Item in die MenuItemListe aufnehmen
+    // put Item in MenuItemList
     MenuItemData* pData = pItemList->Insert( nItemId, MENUITEM_STRING,
                              nItemBits, rStr, Image(), this, nPos );
 
+    // update native menu
+    if( ImplGetSalMenu() && pData->pSalMenuItem )
+        ImplGetSalMenu()->InsertItem( pData->pSalMenuItem, nPos );
+
     Window* pWin = ImplGetWindow();
     delete mpLayoutData, mpLayoutData = NULL;
     if ( pWin )
@@ -1095,16 +1139,23 @@ void Menu::InsertItem( const ResId& rRes
 
 void Menu::InsertSeparator( USHORT nPos )
 {
-    // Handelt es sich um einen MenuBar, dann mache nichts
+    // do nothing if its a menu bar
     if ( bIsMenuBar )
         return;
 
-    // Falls Position > ItemCount, dann anheangen
+    // if position > ItemCount, append
     if ( nPos >= (USHORT)pItemList->Count() )
         nPos = MENU_APPEND;
 
-    // Separator in die Item-Liste einfuegen
+    // put separator in item list
     pItemList->InsertSeparator( nPos );
+
+    // update native menu
+    USHORT itemPos = nPos != MENU_APPEND ? nPos : (USHORT)pItemList->Count() - 1;
+    MenuItemData *pData = pItemList->GetDataFromPos( itemPos );
+    if( ImplGetSalMenu() && pData && pData->pSalMenuItem )
+        ImplGetSalMenu()->InsertItem( pData->pSalMenuItem, nPos );
+
     delete mpLayoutData, mpLayoutData = NULL;
 
     ImplCallEventListeners( VCLEVENT_MENU_INSERTITEM, nPos );
@@ -1116,6 +1167,10 @@ void Menu::RemoveItem( USHORT nPos )
 
     if ( nPos < GetItemCount() )
 	{
+        // update native menu
+        if( ImplGetSalMenu() )
+            ImplGetSalMenu()->RemoveItem( nPos );
+
         pItemList->Remove( nPos );
 		bRemove = TRUE;
 	}
@@ -1166,6 +1221,8 @@ void ImplCopyItem( Menu* pThis, const Me
         pThis->SetHelpId( nId, pData->nHelpId );
         pThis->SetHelpText( nId, pData->aHelpText );
         pThis->SetAccelKey( nId, pData->aAccelKey );
+        pThis->SetItemCommand( nId, pData->aCommandStr );
+        pThis->SetHelpCommand( nId, pData->aHelpCommandStr );
 
         PopupMenu* pSubMenu = rMenu.GetPopupMenu( nId );
         if ( pSubMenu )
@@ -1310,17 +1367,24 @@ void Menu::SetPopupMenu( USHORT nItemId,
     USHORT          nPos;
     MenuItemData*   pData = pItemList->GetData( nItemId, nPos );
 
-    // Item nicht vorhanden, dann NULL zurueckgeben
+    // Item does not exist -> return NULL
     if ( !pData )
         return;
 
-    // Gleiches Menu, danmn brauchen wir nichts machen
+    // same menu, nothing to do
     if ( (PopupMenu*)pData->pSubMenu == pMenu )
         return;
 
-    // Daten austauschen
+    // data exchange
     pData->pSubMenu = pMenu;
 
+    // set native submenu
+    if( ImplGetSalMenu() && pData->pSalMenuItem )
+        if( pMenu )
+            ImplGetSalMenu()->SetSubMenu( pData->pSalMenuItem, pMenu->ImplGetSalMenu(), nPos );
+        else
+            ImplGetSalMenu()->SetSubMenu( pData->pSalMenuItem, NULL, nPos );
+
     ImplCallEventListeners( VCLEVENT_MENU_SUBMENUCHANGED, nPos );
 }
 
@@ -1346,6 +1410,10 @@ void Menu::SetAccelKey( USHORT nItemId, 
         return;
 
     pData->aAccelKey = rKeyCode;
+
+    // update native menu
+    if( ImplGetSalMenu() && pData->pSalMenuItem )
+        ImplGetSalMenu()->SetAccelerator( nPos, pData->pSalMenuItem, rKeyCode, rKeyCode.GetName() );
 }
 
 KeyCode Menu::GetAccelKey( USHORT nItemId ) const
@@ -1441,6 +1509,10 @@ void Menu::CheckItem( USHORT nItemId, BO
 
     pData->bChecked = bCheck;
 
+    // update native menu
+    if( ImplGetSalMenu() )
+        ImplGetSalMenu()->CheckItem( nPos, bCheck );
+
 	ImplCallEventListeners( bCheck ? VCLEVENT_MENU_ITEMCHECKED : VCLEVENT_MENU_ITEMUNCHECKED, nPos );
 }
 
@@ -1481,6 +1553,10 @@ void Menu::EnableItem( USHORT nItemId, B
                 nX += pData->aSz.Width();
             }
         }
+        // update native menu
+        if( ImplGetSalMenu() )
+            ImplGetSalMenu()->EnableItem( nPos, bEnable );
+
         ImplCallEventListeners( bEnable ? VCLEVENT_MENU_ENABLE : VCLEVENT_MENU_DISABLE, nPos );
     }
 }
@@ -1508,7 +1584,20 @@ void Menu::SetItemText( USHORT nItemId, 
 	{
 		pData->aText = rStr;
 		ImplSetMenuItemData( pData, nPos );
-		ImplCallEventListeners( VCLEVENT_MENU_ITEMTEXTCHANGED, nPos );
+        // update native menu
+        if( ImplGetSalMenu() && pData->pSalMenuItem )
+            ImplGetSalMenu()->SetItemText( nPos, pData->pSalMenuItem, rStr );
+
+        Window* pWin = ImplGetWindow();
+        delete mpLayoutData, mpLayoutData = NULL;
+        if ( pWin && IsMenuBar() )
+        {
+            ImplCalcSize( pWin );
+            if ( pWin->IsVisible() )
+                pWin->Invalidate();
+        }
+
+        ImplCallEventListeners( VCLEVENT_MENU_ITEMTEXTCHANGED, nPos );
 	}
 }
 
@@ -1670,6 +1731,24 @@ const XubString& Menu::GetItemCommand( U
         return ImplGetSVEmptyStr();
 }
 
+void Menu::SetHelpCommand( USHORT nItemId, const XubString& rStr )
+{
+    MenuItemData* pData = pItemList->GetData( nItemId );
+
+    if ( pData )
+        pData->aHelpCommandStr = rStr;
+}
+
+const XubString& Menu::GetHelpCommand( USHORT nItemId ) const
+{
+    MenuItemData* pData = pItemList->GetData( nItemId );
+
+    if ( pData )
+        return pData->aHelpCommandStr;
+    else
+        return ImplGetSVEmptyStr();
+}
+    
 void Menu::SetHelpText( USHORT nItemId, const XubString& rStr )
 {
     MenuItemData* pData = pItemList->GetData( nItemId );
@@ -1944,7 +2023,7 @@ Size Menu::ImplCalcSize( Window* pWin )
                     aSz.Width() += pData->aSz.Width();
                 }
 				else
-					pData->aSz.Height() = std::max( std::max( nTextHeight, pData->aSz.Height() ), nMinMenuItemHeight );
+					pData->aSz.Height() = Max( Max( nTextHeight, pData->aSz.Height() ), nMinMenuItemHeight );
             }
 
             // Accel
@@ -1963,10 +2042,7 @@ Size Menu::ImplCalcSize( Window* pWin )
                 if ( nFontHeight > nMaxAccWidth )
                     nMaxAccWidth = nFontHeight;
 
-				pData->aSz.Height() = std::max( std::max( nFontHeight, pData->aSz.Height() ), nMinMenuItemHeight );
-
-//                if ( nFontHeight > pData->aSz.Height() )
-//                    pData->aSz.Height() = nFontHeight;
+				pData->aSz.Height() = Max( Max( nFontHeight, pData->aSz.Height() ), nMinMenuItemHeight );
             }
 
             pData->aSz.Height() += EXTRAITEMHEIGHT; // Etwas mehr Abstand:
@@ -1978,7 +2054,7 @@ Size Menu::ImplCalcSize( Window* pWin )
 
     if ( !bIsMenuBar )
     {
-        USHORT gfxExtra = (USHORT) std::max( nExtra, 7L ); // #107710# increase space between checkmarks/images/text
+        USHORT gfxExtra = (USHORT) Max( nExtra, 7L ); // #107710# increase space between checkmarks/images/text
         nCheckPos = (USHORT)nExtra;
         nImagePos = (USHORT)(nCheckPos + nFontHeight/2 + gfxExtra );
         nTextPos = (USHORT)(nImagePos+aMaxImgSz.Width());
@@ -2015,7 +2091,6 @@ void Menu::ImplPaint( Window* pWin, USHO
         aTopLeft.X() = pLogo->aBitmap.GetSizePixel().Width();
 
     Size aOutSz = pWin->GetOutputSizePixel();
-    long nMaxY = aOutSz.Height() - nBorder;
     USHORT nCount = (USHORT)pItemList->Count();
     if( bLayout )
         mpLayoutData->m_aVisibleItemBoundRects.clear();
@@ -2244,6 +2319,23 @@ Menu* Menu::ImplFindSelectMenu()
     return pSelMenu;
 }
 
+Menu* Menu::ImplFindMenu( USHORT nItemId )
+{
+    Menu* pSelMenu = NULL;
+
+    for ( ULONG n = GetItemList()->Count(); n && !pSelMenu; )
+    {
+        MenuItemData* pData = GetItemList()->GetDataFromPos( --n );
+
+        if( pData->nId == nItemId )
+            pSelMenu = this;
+        else if ( pData->pSubMenu )
+            pSelMenu = pData->pSubMenu->ImplFindMenu( nItemId );
+    }
+
+    return pSelMenu;
+}
+
 void Menu::RemoveDisabledEntries( BOOL bCheckPopups, BOOL bRemoveEmptyPopups )
 {
     for ( USHORT n = 0; n < GetItemCount(); n++ )
@@ -2358,7 +2445,7 @@ Rectangle Menu::GetCharacterBounds( USHO
         ImplFillLayoutData();
     if( mpLayoutData )
     {
-        for( int i = 0; i < (int) mpLayoutData->m_aLineItemIds.size(); i++ )
+        for( size_t i = 0; i < mpLayoutData->m_aLineItemIds.size(); i++ )
         {
             if( mpLayoutData->m_aLineItemIds[i] == nItemID )
             {
@@ -2380,7 +2467,7 @@ long Menu::GetIndexForPoint( const Point
     if( mpLayoutData )
     {
         nIndex = mpLayoutData->GetIndexForPoint( rPoint );
-        for( int i = 0; i < (int) mpLayoutData->m_aLineIndices.size(); i++ )
+        for( size_t i = 0; i < mpLayoutData->m_aLineIndices.size(); i++ )
         {
             if( mpLayoutData->m_aLineIndices[i] <= nIndex &&
                 (i == mpLayoutData->m_aLineIndices.size()-1 || mpLayoutData->m_aLineIndices[i+1] > nIndex) )
@@ -2414,7 +2501,7 @@ Pair Menu::GetItemStartEnd( USHORT nItem
     if( ! mpLayoutData )
         ImplFillLayoutData();
 
-    for( long i = 0; i < (long) mpLayoutData->m_aLineItemIds.size(); i++ )
+    for( size_t i = 0; i < mpLayoutData->m_aLineItemIds.size(); i++ )
         if( mpLayoutData->m_aLineItemIds[i] == nItem )
             return GetLineStartEnd( i );
 
@@ -2426,7 +2513,7 @@ USHORT Menu::GetDisplayItemId( long nLin
     USHORT nItemId = 0;
     if( ! mpLayoutData )
         ImplFillLayoutData();
-    if( mpLayoutData && nLine >= 0 && nLine < (long) mpLayoutData->m_aLineItemIds.size() )
+    if( mpLayoutData && ( nLine >= 0 ) && ( nLine < (long)mpLayoutData->m_aLineItemIds.size() ) )
         nItemId = mpLayoutData->m_aLineItemIds[nLine];
     return nItemId;
 }
@@ -2498,21 +2585,42 @@ XubString Menu::GetAccessibleDescription
         return ImplGetSVEmptyStr();
 }
 
+void Menu::ImplSetSalMenu( SalMenu *pSalMenu )
+{
+    if( mpSalMenu )
+        ImplGetSVData()->mpDefInst->DestroyMenu( mpSalMenu );
+    mpSalMenu = pSalMenu;
+}
+
+BOOL Menu::GetSystemMenuData( SystemMenuData* pData ) const
+{
+    Menu* pMenu = (Menu*)this;
+    if( pData && pMenu->ImplGetSalMenu() )
+    {
+        pMenu->ImplGetSalMenu()->GetSystemMenuData( pData );
+        return TRUE;
+    }
+    else
+        return FALSE;
+}
+
+
+
 // -----------
 // - MenuBar -
 // -----------
 
-MenuBar::MenuBar()
+MenuBar::MenuBar() : Menu( TRUE )
 {
-    bIsMenuBar          = TRUE;
+    mbDisplayable       = TRUE;
     mbCloserVisible     = FALSE;
     mbFloatBtnVisible   = FALSE;
     mbHideBtnVisible    = FALSE;
 }
 
-MenuBar::MenuBar( const MenuBar& rMenu )
+MenuBar::MenuBar( const MenuBar& rMenu ) : Menu( TRUE )
 {
-    bIsMenuBar          = TRUE;
+    mbDisplayable       = TRUE;
     mbCloserVisible     = FALSE;
     mbFloatBtnVisible   = FALSE;
     mbHideBtnVisible    = FALSE;
@@ -2520,9 +2628,9 @@ MenuBar::MenuBar( const MenuBar& rMenu )
     bIsMenuBar          = TRUE;
 }
 
-MenuBar::MenuBar( const ResId& rResId )
+MenuBar::MenuBar( const ResId& rResId ) : Menu ( TRUE )
 {
-    bIsMenuBar          = TRUE;
+    mbDisplayable       = TRUE;
     mbCloserVisible     = FALSE;
     mbFloatBtnVisible   = FALSE;
     mbHideBtnVisible    = FALSE;
@@ -2563,6 +2671,17 @@ void MenuBar::ShowButtons( BOOL bClose, 
     }
 }
 
+void MenuBar::SetDisplayable( BOOL bDisplayable )
+{
+    if( bDisplayable != mbDisplayable )
+    {
+        mbDisplayable = bDisplayable;
+        MenuBarWindow* pMenuWin = (MenuBarWindow*) ImplGetWindow();
+        if( pMenuWin )
+            pMenuWin->ImplLayoutChanged();
+    }
+}
+
 Window* MenuBar::ImplCreate( Window* pParent, Window* pWindow, MenuBar* pMenu )
 {
     if ( !pWindow )
@@ -2573,6 +2692,13 @@ Window* MenuBar::ImplCreate( Window* pPa
     ((MenuBarWindow*)pWindow)->SetMenu( pMenu );
     long nHeight = pMenu->ImplCalcSize( pWindow ).Height();
     if( nHeight < 20 ) nHeight = 20;   // leave enough space for closer
+
+    // depending on the native implementation or the displayable flag
+    // the menubar windows is supressed (ie, height=0)
+    if( !((MenuBar*) pMenu)->IsDisplayable() || 
+        ( pMenu->ImplGetSalMenu() && pMenu->ImplGetSalMenu()->VisibleMenuBar() ) )
+        nHeight = 0;
+
     pWindow->SetPosSizePixel( 0, 0, 0, nHeight, WINDOW_POSSIZE_HEIGHT );
     return pWindow;
 }
@@ -2591,6 +2717,12 @@ void MenuBar::ImplDestroy( MenuBar* pMen
 BOOL MenuBar::ImplHandleKeyEvent( const KeyEvent& rKEvent, BOOL bFromMenu )
 {
     BOOL bDone = FALSE;
+
+    // No keyboard processing when system handles the menu or our menubar is invisible
+    if( !IsDisplayable() || 
+        ( ImplGetSalMenu() && ImplGetSalMenu()->VisibleMenuBar() ) )
+        return bDone;
+
     // Enabled-Abfragen, falls diese Methode von einem anderen Fenster gerufen wurde...
     Window* pWin = ImplGetWindow();
     if ( pWin && pWin->IsEnabled() && pWin->IsInputEnabled() )
@@ -2621,6 +2753,70 @@ void MenuBar::SelectEntry( USHORT nId )
     }
 }
 
+// -----------------------------------------------------------------------
+
+// handler for native menu selection and command events
+
+BOOL MenuBar::HandleMenuActivateEvent( Menu *pMenu ) const
+{
+    if( pMenu )
+    {
+        pMenu->pStartedFrom = (Menu*)this;
+        pMenu->bInCallback = TRUE; 
+        pMenu->Activate();
+        pMenu->bInCallback = FALSE; 
+    }
+    return TRUE;
+}
+
+BOOL MenuBar::HandleMenuDeActivateEvent( Menu *pMenu ) const
+{
+    if( pMenu )
+    {
+        pMenu->pStartedFrom = (Menu*)this;
+        pMenu->bInCallback = TRUE; 
+        pMenu->Deactivate();
+        pMenu->bInCallback = FALSE; 
+    }
+    return TRUE;
+}
+
+BOOL MenuBar::HandleMenuHighlightEvent( Menu *pMenu, USHORT nEventId ) const
+{
+    if( !pMenu )
+        pMenu = ((Menu*) this)->ImplFindMenu( nEventId );
+    if( pMenu )
+    {
+        if( mnHighlightedItemPos != ITEMPOS_INVALID )
+            pMenu->ImplCallEventListeners( VCLEVENT_MENU_DEHIGHLIGHT, mnHighlightedItemPos );
+
+        pMenu->mnHighlightedItemPos = pMenu->GetItemPos( nEventId );
+        pMenu->nSelectedId = nEventId;
+        pMenu->pStartedFrom = (Menu*)this;
+        pMenu->ImplCallHighlight( pMenu->mnHighlightedItemPos );
+        return TRUE;
+    }
+    else
+        return FALSE;
+}
+
+BOOL MenuBar::HandleMenuCommandEvent( Menu *pMenu, USHORT nEventId ) const
+{
+    if( !pMenu )
+        pMenu = ((Menu*) this)->ImplFindMenu( nEventId );
+    if( pMenu )
+    {
+        pMenu->nSelectedId = nEventId;
+        pMenu->pStartedFrom = (Menu*)this;
+        pMenu->ImplSelect();
+        return TRUE;
+    }
+    else
+        return FALSE;
+}
+
+// -----------------------------------------------------------------------
+
 // BOOL PopupMenu::bAnyPopupInExecute = FALSE;
 
 PopupMenu::PopupMenu()
@@ -2717,6 +2913,7 @@ USHORT PopupMenu::Execute( Window* pWind
 
 USHORT PopupMenu::ImplExecute( Window* pW, const Rectangle& rRect, ULONG nPopupModeFlags, Menu* pSFrom, BOOL bPreSelectFirst )
 {
+
     // #59614# Mit TH abgesprochen dass die ASSERTION raus kommt,
     // weil es evtl. legitim ist...
 //  DBG_ASSERT( !PopupMenu::IsInExecute() || pSFrom, "PopupMenu::Execute() called in PopupMenu::Execute()" );
@@ -2815,7 +3012,7 @@ USHORT PopupMenu::ImplExecute( Window* p
     long nMaxHeight = pWin->GetDesktopRectPixel().GetHeight();
     if ( pStartedFrom && pStartedFrom->bIsMenuBar )
         nMaxHeight -= pW->GetSizePixel().Height();
-    long nLeft, nTop, nRight, nBottom;
+    sal_Int32 nLeft, nTop, nRight, nBottom;
     pWindow->GetBorder( nLeft, nTop, nRight, nBottom );
     nMaxHeight -= nTop+nBottom;
     if ( aSz.Height() > nMaxHeight )
@@ -3251,7 +3442,7 @@ IMPL_LINK( MenuFloatingWindow, Highlight
                 aItemTopLeft.Y() -= 2;
             else
             {
-                long nL, nT, nR, nB;
+                sal_Int32 nL, nT, nR, nB;
                 GetBorder( nL, nT, nR, nB );
                 aItemTopLeft.Y() -= nT;
             }
@@ -3430,10 +3621,7 @@ void MenuFloatingWindow::MouseButtonDown
     //if ( pActivePopup && pActivePopup->ImplGetWindow() && !pActivePopup->ImplGetFloatingWindow()->pActivePopup )
     //    pActivePopup->ImplGetFloatingWindow()->ToTop( TOTOP_NOGRABFOCUS );
 
-//  if ( !ImplIsMouseFollow() ) // Issuezilla#591
-    {
-        ImplHighlightItem( rMEvt, TRUE );
-    }
+    ImplHighlightItem( rMEvt, TRUE );
 
     nMBDownPos = nHighlightedItem;
 }
@@ -3470,21 +3658,19 @@ void MenuFloatingWindow::MouseMove( cons
 
     if ( rMEvt.IsLeaveWindow() )
     {
-        if ( ImplIsMouseFollow() || ( rMEvt.GetButtons() == MOUSE_LEFT ) )
-        {
-            // #102461# do not remove highlight if a popup menu is open at this position
-            MenuItemData* pData = pMenu->pItemList->GetDataFromPos( nHighlightedItem );
-            // close popup with some delayed if we leave somewhere else
-            if( pActivePopup && pData && pData->pSubMenu != pActivePopup )
-                pActivePopup->ImplGetFloatingWindow()->aSubmenuCloseTimer.Start();
+        // #102461# do not remove highlight if a popup menu is open at this position
+        MenuItemData* pData = pMenu->pItemList->GetDataFromPos( nHighlightedItem );
+        // close popup with some delayed if we leave somewhere else
+        if( pActivePopup && pData && pData->pSubMenu != pActivePopup )
+            pActivePopup->ImplGetFloatingWindow()->aSubmenuCloseTimer.Start();
+
+        if( !pActivePopup || (pData && pData->pSubMenu != pActivePopup ) )
+            ChangeHighlightItem( ITEMPOS_INVALID, FALSE );
 
-            if( !pActivePopup || (pData && pData->pSubMenu != pActivePopup ) )
-                ChangeHighlightItem( ITEMPOS_INVALID, FALSE );
-        }
         if ( IsScrollMenu() )
             ImplScroll( rMEvt.GetPosPixel() );
     }
-    else if ( ImplIsMouseFollow() || ( rMEvt.GetButtons() == MOUSE_LEFT ) )
+    else
     {
         aSubmenuCloseTimer.Stop();
 		if( bIgnoreFirstMove )
@@ -3768,7 +3954,7 @@ void MenuFloatingWindow::ImplCursorUpDow
 		}
 		else
 		{
-			n = -1;
+			n = (USHORT)-1;
 			nLoop = n+1;
 		}
 	}
@@ -4135,6 +4321,15 @@ void MenuBarWindow::SetMenu( MenuBar* pM
         aHideBtn.Show( pMen->HasHideButton() );
     }
     Invalidate();
+
+    // show and connect native menubar
+    if( pMenu && pMenu->ImplGetSalMenu() )
+    {
+        if( pMenu->ImplGetSalMenu()->VisibleMenuBar() )
+            ImplGetFrame()->SetMenu( pMenu->ImplGetSalMenu() );
+
+        pMenu->ImplGetSalMenu()->SetFrame( ImplGetFrame() );
+    }
 }
 
 void MenuBarWindow::ShowButtons( BOOL bClose, BOOL bFloat, BOOL bHide )
@@ -4253,7 +4448,7 @@ void MenuBarWindow::MouseButtonDown( con
     USHORT nEntry = ImplFindEntry( rMEvt.GetPosPixel() );
     if ( ( nEntry != ITEMPOS_INVALID ) && ( nEntry != nHighlightedItem ) )
     {
-        ChangeHighlightItem( nEntry, ImplIsMouseFollow() ? FALSE : TRUE );
+        ChangeHighlightItem( nEntry, FALSE );
     }
     else
     {
@@ -4279,8 +4474,7 @@ void MenuBarWindow::MouseMove( const Mou
 	}
 
     USHORT nEntry = ImplFindEntry( rMEvt.GetPosPixel() );
-    if ( ( nEntry != ITEMPOS_INVALID ) && ( nEntry != nHighlightedItem )
-         && ( ImplIsMouseFollow() || ( rMEvt.GetButtons() == MOUSE_LEFT ) ) )
+    if ( ( nEntry != ITEMPOS_INVALID ) && ( nEntry != nHighlightedItem ) )
         ChangeHighlightItem( nEntry, FALSE );
 }
 
@@ -4468,7 +4662,7 @@ BOOL MenuBarWindow::ImplHandleKeyEvent( 
             USHORT nLoop = n;
 
 			if( nCode == KEY_HOME )
-				{ n = -1; nLoop = n+1; }
+				{ n = (USHORT)-1; nLoop = n+1; }
 			if( nCode == KEY_END )
 				{ n = pMenu->GetItemCount(); nLoop = n-1; }
 
@@ -4573,6 +4767,13 @@ BOOL MenuBarWindow::ImplHandleKeyEvent( 
 
 void MenuBarWindow::Paint( const Rectangle& rRect )
 {
+    // no VCL paint if native menus
+    if( pMenu->ImplGetSalMenu() && pMenu->ImplGetSalMenu()->VisibleMenuBar() )
+    {
+        ImplGetFrame()->DrawMenuBar();
+        return;
+    }
+
     pMenu->ImplPaint( this, 0 );
     if ( nHighlightedItem != ITEMPOS_INVALID )
         HighlightItem( nHighlightedItem, TRUE );
@@ -4695,6 +4896,27 @@ void MenuBarWindow::StateChanged( StateC
 
 }
 
+void MenuBarWindow::ImplLayoutChanged()
+{
+    ImplInitMenuWindow( this, TRUE, TRUE );
+    // Falls sich der Font geaendert hat.
+    long nHeight = pMenu->ImplCalcSize( this ).Height();
+    if( nHeight < 20 ) nHeight = 20;   // leave enough space for closer
+
+    // depending on the native implementation or the displayable flag
+    // the menubar windows is supressed (ie, height=0)
+    if( !((MenuBar*) pMenu)->IsDisplayable() || 
+        ( pMenu->ImplGetSalMenu() && pMenu->ImplGetSalMenu()->VisibleMenuBar() ) )
+        nHeight = 0;
+
+    SetPosSizePixel( 0, 0, 0, nHeight, WINDOW_POSSIZE_HEIGHT );
+    GetParent()->Resize();
+    Invalidate();
+    Resize();
+    if( pMenu )
+        pMenu->ImplKillLayoutData();
+}
+
 void MenuBarWindow::DataChanged( const DataChangedEvent& rDCEvt )
 {
     Window::DataChanged( rDCEvt );
@@ -4704,16 +4926,7 @@ void MenuBarWindow::DataChanged( const D
          ((rDCEvt.GetType() == DATACHANGED_SETTINGS) &&
           (rDCEvt.GetFlags() & SETTINGS_STYLE)) )
     {
-        ImplInitMenuWindow( this, TRUE, TRUE );
-        // Falls sich der Font geaendert hat.
-        long nHeight = pMenu->ImplCalcSize( this ).Height();
-        if( nHeight < 20 ) nHeight = 20;   // leave enough space for closer
-        SetPosSizePixel( 0, 0, 0, nHeight, WINDOW_POSSIZE_HEIGHT );
-        GetParent()->Resize();
-        Invalidate();
-        Resize();
-        if( pMenu )
-            pMenu->ImplKillLayoutData();
+        ImplLayoutChanged();
     }
 }
 
Index: vcl/source/window/mnemonic.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/mnemonic.cxx,v
retrieving revision 1.12.46.3
retrieving revision 1.16
diff -u -p -u -r1.12.46.3 -r1.16
--- vcl/source/window/mnemonic.cxx	15 Jan 2004 14:04:41 -0000	1.12.46.3
+++ vcl/source/window/mnemonic.cxx	2 Feb 2004 18:23:36 -0000	1.16
@@ -58,8 +58,6 @@
  *
  *
  ************************************************************************/
-
-#define _SV_MNEMONIC_CXX
 
 #include <string.h>
 #include <svapp.hxx>
Index: vcl/source/window/msgbox.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/msgbox.cxx,v
retrieving revision 1.10
retrieving revision 1.12
diff -u -p -u -r1.10 -r1.12
--- vcl/source/window/msgbox.cxx	17 Apr 2003 15:19:21 -0000	1.10
+++ vcl/source/window/msgbox.cxx	6 Jan 2004 14:14:46 -0000	1.12
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_MSGBOX_CXX
-
 #ifndef _SV_SVIDS_HRC
 #include <svids.hrc>
 #endif
@@ -92,13 +90,13 @@
 #include <button.hxx>
 #endif
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_MNEMONIC_HXX
 #include <mnemonic.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -226,7 +224,7 @@ MessBox::MessBox( Window* pParent, const
 	USHORT nLoDefButton = ReadShortRes();
 	USHORT nHiHelpId	= ReadShortRes();
 	USHORT nLoHelpId	= ReadShortRes();
-	USHORT bSysModal	= ReadShortRes();
+	/* USHORT bSysModal	= */ ReadShortRes();
 	SetHelpId( ((ULONG)nHiHelpId << 16) + nLoHelpId );
 	WinBits nBits = (((ULONG)nHiButtons << 16) + nLoButtons) |
 					(((ULONG)nHiDefButton << 16) + nLoDefButton);
Index: vcl/source/window/scrwnd.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/scrwnd.cxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/source/window/scrwnd.cxx	6 Jul 2001 16:06:21 -0000	1.2
+++ vcl/source/window/scrwnd.cxx	6 Jan 2004 14:15:10 -0000	1.3
@@ -97,11 +97,11 @@
 ImplWheelWindow::ImplWheelWindow( Window* pParent ) :
             FloatingWindow  ( pParent, 0 ),
             mnRepaintTime   ( 1UL ),
-            mnActDist       ( 0UL ),
+            mnTimeout       ( DEF_TIMEOUT ),
             mnWheelMode     ( WHEELMODE_NONE ),
+            mnActDist       ( 0UL ),
             mnActDeltaX     ( 0L ),
-            mnActDeltaY     ( 0L ),
-            mnTimeout       ( DEF_TIMEOUT )
+            mnActDeltaY     ( 0L )
 {
     // we need a parent
     DBG_ASSERT( pParent, "ImplWheelWindow::ImplWheelWindow(): Parent not set!" );
Index: vcl/source/window/seleng.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/seleng.cxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/source/window/seleng.cxx	4 Apr 2002 09:22:32 -0000	1.2
+++ vcl/source/window/seleng.cxx	1 Dec 2003 13:39:23 -0000	1.3
@@ -64,7 +64,7 @@
 #include <seleng.hxx>
 #include <tools/debug.hxx>
 
-#pragma hdrstop
+
 
 
 inline BOOL SelectionEngine::ShouldDeselect( BOOL bModifierKey1 ) const
Index: vcl/source/window/split.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/split.cxx,v
retrieving revision 1.8
retrieving revision 1.12
diff -u -p -u -r1.8 -r1.12
--- vcl/source/window/split.cxx	14 Aug 2002 14:05:52 -0000	1.8
+++ vcl/source/window/split.cxx	25 Jun 2004 17:09:38 -0000	1.12
@@ -59,10 +60,8 @@
  *
  ************************************************************************/
 
-#define _SV_SPLIT_CXX
-
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
@@ -341,7 +363,8 @@ void Splitter::Tracking( const TrackingE
 	}
 	else
 	{
-		Point aNewPos = mpRefWin->ScreenToOutputPixel( OutputToScreenPixel( rTEvt.GetMouseEvent().GetPosPixel() ) );
+		//Point aNewPos = mpRefWin->ScreenToOutputPixel( OutputToScreenPixel( rTEvt.GetMouseEvent().GetPosPixel() ) );
+		Point aNewPos = mpRefWin->NormalizedScreenToOutputPixel( OutputToNormalizedScreenPixel( rTEvt.GetMouseEvent().GetPosPixel() ) );
 		ImplSplitMousePos( aNewPos );
 		Splitting( aNewPos );
 		ImplSplitMousePos( aNewPos );
@@ -667,7 +690,6 @@ void Splitter::KeyInput( const KeyEvent&
     Splitter *pSibling = ImplFindSibling();
     KeyCode aKeyCode = rKEvt.GetKeyCode();
     USHORT nCode = aKeyCode.GetCode();
-	BOOL bForwardKey = FALSE;
     switch ( nCode )
     {
         case KEY_UP:
Index: vcl/source/window/splitwin.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/splitwin.cxx,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -p -u -r1.5 -r1.7
--- vcl/source/window/splitwin.cxx	17 Apr 2003 15:19:34 -0000	1.5
+++ vcl/source/window/splitwin.cxx	6 Jan 2004 14:16:03 -0000	1.7
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SPLITWIN_CXX
-
 #include <string.h>
 
 #ifndef _LIST_HXX
@@ -70,8 +68,8 @@
 #include <tools/debug.hxx>
 #endif
 
-#ifndef _SV_RCID_H
-#include <rcid.h>
+#ifndef _TOOLS_RCID_H
+#include <tools/rcid.h>
 #endif
 #ifndef _SV_EVENT_HXX
 #include <event.hxx>
@@ -106,7 +104,7 @@
 #endif
 #undef private
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -1895,7 +1893,6 @@ void SplitWindow::ImplDrawAutoHide( BOOL
 {
 	if ( mbAutoHide )
 	{
-		const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
 		Rectangle aTempRect;
 		ImplGetAutoHideRect( aTempRect );
 
@@ -1998,7 +1995,6 @@ void SplitWindow::ImplDrawFadeIn( BOOL b
 {
 	if ( mbFadeIn )
 	{
-		const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
 		Rectangle		aTempRect;
 		Image			aImage;
 		ImplGetFadeInRect( aTempRect );
@@ -2036,7 +2032,6 @@ void SplitWindow::ImplDrawFadeOut( BOOL 
 {
 	if ( mbFadeOut )
 	{
-		const StyleSettings& rStyleSettings = GetSettings().GetStyleSettings();
 		Rectangle		aTempRect;
 		Image			aImage;
 		ImplGetFadeOutRect( aTempRect );
Index: vcl/source/window/status.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/status.cxx,v
retrieving revision 1.9
retrieving revision 1.12
diff -u -p -u -r1.9 -r1.12
--- vcl/source/window/status.cxx	27 Mar 2003 17:58:23 -0000	1.9
+++ vcl/source/window/status.cxx	10 May 2004 15:50:35 -0000	1.12
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_STATUS_CXX
-
 #ifndef _LIST_HXX
 #include <tools/list.hxx>
 #endif
@@ -69,7 +67,7 @@
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -90,7 +88,7 @@
 #include <status.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -136,11 +134,14 @@ static Point ImplGetItemTextPos( const S
 {
 	long nX;
 	long nY;
+    long delta = (rTextSize.Height()/4) + 1;
+    if( delta + rTextSize.Width() > rRectSize.Width() )
+        delta = 0;
 
 	if ( nStyle & SIB_LEFT )
-		nX = 0;
+		nX = delta;
 	else if ( nStyle & SIB_RIGHT )
-		nX = rRectSize.Width()-rTextSize.Width();
+		nX = rRectSize.Width()-rTextSize.Width()-delta;
 	else // SIB_CENTER
 		nX = (rRectSize.Width()-rTextSize.Width())/2;
 	nY = (rRectSize.Height()-rTextSize.Height())/2 + 1;
@@ -497,10 +498,6 @@ void StatusBar::ImplDrawItem( BOOL bOffS
 
 // -----------------------------------------------------------------------
 
-#ifdef _MSC_VER
-#pragma optimize( "", off )
-#endif
-
 void DrawProgress( Window* pWindow, const Point& rPos,
 				   long nOffset, long nPrgsWidth, long nPrgsHeight,
 				   USHORT nPercent1, USHORT nPercent2, USHORT nPercentCount )
@@ -569,10 +566,6 @@ void DrawProgress( Window* pWindow, cons
 		pWindow->Flush();
 	}
 }
-
-#ifdef _MSC_VER
-#pragma optimize( "", on )
-#endif
 
 // -----------------------------------------------------------------------
 
Index: vcl/source/window/syschild.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/syschild.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/window/syschild.cxx	18 Sep 2000 17:05:40 -0000	1.1.1.1
+++ vcl/source/window/syschild.cxx	6 Jan 2004 14:16:59 -0000	1.3
@@ -59,9 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SYSCHILD_CXX
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -75,10 +72,9 @@
 #ifndef _SV_SALOBJ_HXX
 #include <salobj.hxx>
 #endif
-#endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -93,11 +89,9 @@
 #include <syschild.hxx>
 #endif
 
-#pragma hdrstop
 
-// =======================================================================
 
-#ifndef REMOTE_APPSERVER
+// =======================================================================
 
 long ImplSysChildProc( void* pInst, SalObject* /* pObject */,
 					   USHORT nEvent, const void* /* pEvent */ )
@@ -146,19 +140,14 @@ long ImplSysChildProc( void* pInst, SalO
 	return nRet;
 }
 
-#endif
-
 // =======================================================================
 
 void SystemChildWindow::ImplInit( Window* pParent, WinBits nStyle )
 {
-#ifndef REMOTE_APPSERVER
 	mpSysObj = ImplGetSVData()->mpDefInst->CreateObject( pParent->ImplGetFrame() );
-#endif
 
 	Window::ImplInit( pParent, nStyle, NULL );
 
-#ifndef REMOTE_APPSERVER
 	// Wenn es ein richtiges SysChild ist, dann painten wir auch nicht
 	if ( GetSystemData() )
 	{
@@ -166,7 +155,6 @@ void SystemChildWindow::ImplInit( Window
 		SetParentClipMode( PARENTCLIPMODE_CLIP );
 		SetBackground();
 	}
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -195,27 +183,21 @@ SystemChildWindow::SystemChildWindow( Wi
 
 SystemChildWindow::~SystemChildWindow()
 {
-#ifndef REMOTE_APPSERVER
 	Hide();
 	if ( mpSysObj )
 	{
 		ImplGetSVData()->mpDefInst->DestroyObject( mpSysObj );
 		mpSysObj = NULL;
 	}
-#endif
 }
 
 // -----------------------------------------------------------------------
 
 const SystemEnvData* SystemChildWindow::GetSystemData() const
 {
-#ifndef REMOTE_APPSERVER
 	if ( mpSysObj )
 		return mpSysObj->GetSystemData();
 	else
 		return NULL;
-#else
-	return NULL;
-#endif
 }
 
Index: vcl/source/window/syswin.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/syswin.cxx,v
retrieving revision 1.33
retrieving revision 1.35
diff -u -p -u -r1.33 -r1.35
--- vcl/source/window/syswin.cxx	24 Apr 2003 16:32:28 -0000	1.33
+++ vcl/source/window/syswin.cxx	6 Jan 2004 14:17:23 -0000	1.35
@@ -59,20 +59,16 @@
  *
  ************************************************************************/
 
-#define _SV_SYSWIN_CXX
-
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
-#endif
 
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -112,11 +105,6 @@
 #endif
 #include <unowrap.hxx>
 
-#ifdef REMOTE_APPSERVER
-#include "rmwindow.hxx"
-#endif
-
-#pragma hdrstop
 
 using namespace ::com::sun::star::uno;
 using namespace ::com::sun::star::lang;
@@ -257,10 +245,6 @@ BOOL SystemWindow::Close()
 
     Hide();
 
-    // Ist es das Applikationsfenster, dann beende die Applikation
-    if ( Application::GetAppWindow() == (const WorkWindow*)this )
-        GetpApp()->Quit();
-
     return TRUE;
 }
 
@@ -589,7 +573,6 @@ void SystemWindow::SetWindowStateData( c
 
     if ( pWindow->mbFrame )
     {
-#ifndef REMOTE_APPSERVER
         ULONG           nState = rData.GetState();
         SalFrameState   aState;
         aState.mnMask   = rData.GetMask();
@@ -646,11 +629,6 @@ void SystemWindow::SetWindowStateData( c
         }
 
         mpFrame->SetWindowState( &aState );
-#else
-        ByteString aStr;
-        ImplWindowStateToStr( rData, aStr );
-        mpFrame->SetWindowState( ::rtl::OUString( aStr.GetBuffer(), aStr.Len(), RTL_TEXTENCODING_ASCII_US ) );
-#endif
 
         // Syncrones Resize ausloesen, damit wir nach Moeglichkeit gleich
         // mit der richtigen Groesse rechnen
@@ -719,7 +697,6 @@ void SystemWindow::GetWindowStateData( W
 
     if ( pWindow->mbFrame )
     {
-#ifndef REMOTE_APPSERVER
         SalFrameState aState;
         aState.mnMask = 0xFFFFFFFF;
         if ( mpFrame->GetWindowState( &aState ) )
@@ -743,13 +720,6 @@ void SystemWindow::GetWindowStateData( W
         }
         else
             rData.SetMask( 0 );
-#else
-        ::rtl::OUString aStr( mpFrame->GetWindowState() );
-        ByteString aByteStr( aStr.getStr(), aStr.getLength(), RTL_TEXTENCODING_ASCII_US );
-        WindowStateData aData;
-        ImplWindowStateFromStr( aData, aByteStr );
-        rData = aData;
-#endif
     }
     else
     {
Index: vcl/source/window/tabdlg.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/tabdlg.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.3
diff -u -p -u -r1.1.1.1 -r1.3
--- vcl/source/window/tabdlg.cxx	18 Sep 2000 17:05:40 -0000	1.1.1.1
+++ vcl/source/window/tabdlg.cxx	6 Jan 2004 14:17:49 -0000	1.3
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_TABDLG_CXX
-
 #ifndef _SV_FIXED_HXX
 #include <fixed.hxx>
 #endif
@@ -71,10 +69,10 @@
 #include <tabdlg.hxx>
 #endif
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
Index: vcl/source/window/tabpage.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/tabpage.cxx,v
retrieving revision 1.6
retrieving revision 1.10
diff -u -p -u -r1.6 -r1.10
--- vcl/source/window/tabpage.cxx	12 Jun 2003 07:51:42 -0000	1.6
+++ vcl/source/window/tabpage.cxx	10 May 2004 15:50:49 -0000	1.10
@@ -59,12 +59,10 @@
  *
  ************************************************************************/
 
-#define _SV_TABPAGE_CXX
-
 #include <tools/ref.hxx>
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -86,7 +84,7 @@
 #include <com/sun/star/accessibility/XAccessible.hpp>
 #endif
 
-#pragma hdrstop
+
 
 
 // =======================================================================
@@ -99,6 +97,11 @@ void TabPage::ImplInit( Window* pParent,
     Window::ImplInit( pParent, nStyle, NULL );
 
     ImplInitSettings();
+
+    // if the tabpage is drawn (ie filled) by a native widget, make sure all contols will have transparent background
+    // otherwise they will paint with a wrong background
+    if( IsNativeControlSupported(CTRL_TAB_BODY, PART_ENTIRE_CONTROL) && GetParent() && (GetParent()->GetType() == WINDOW_TABCONTROL) )
+        EnableChildTransparentMode( TRUE );
 }
 
 // -----------------------------------------------------------------------
@@ -177,6 +180,30 @@ void TabPage::DataChanged( const DataCha
     {
         ImplInitSettings();
         Invalidate();
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void TabPage::Paint( const Rectangle& rRect )
+{
+    // draw native tabpage only inside tabcontrols, standalone tabpages look ugly (due to bad dialog design)
+    if( IsNativeControlSupported(CTRL_TAB_BODY, PART_ENTIRE_CONTROL) && GetParent() && (GetParent()->GetType() == WINDOW_TABCONTROL) )
+    {
+        const ImplControlValue aControlValue( BUTTONVALUE_DONTKNOW, rtl::OUString(), 0 );
+
+        ControlState nState = CTRL_STATE_ENABLED;
+        int part = PART_ENTIRE_CONTROL;
+        if ( !IsEnabled() )
+            nState &= ~CTRL_STATE_ENABLED;
+        if ( HasFocus() )
+            nState |= CTRL_STATE_FOCUSED;
+        Point aPoint;
+        // pass the whole window region to NWF as the tab body might be a gradient or bitmap
+        // that has to be scaled properly, clipping makes sure that we do not paint too much
+        Region aCtrlRegion( Rectangle( aPoint, GetOutputSizePixel() ) );
+        DrawNativeControl( CTRL_TAB_BODY, part, aCtrlRegion, nState,
+                aControlValue, rtl::OUString() );
     }
 }
 
Index: vcl/source/window/taskpanelist.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/taskpanelist.cxx,v
retrieving revision 1.14
retrieving revision 1.15
diff -u -p -u -r1.14 -r1.15
--- vcl/source/window/taskpanelist.cxx	21 Nov 2002 10:28:30 -0000	1.14
+++ vcl/source/window/taskpanelist.cxx	6 Jan 2004 14:19:09 -0000	1.15
@@ -61,8 +61,8 @@
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
 #endif
-#ifndef _RCID_H
-#include <rcid.h>
+#ifndef _TOOLS_RCID_H
+#include <tools/rcid.h>
 #endif
 #ifndef _SV_DOCKWIN_HXX
 #include <dockwin.hxx>
@@ -199,7 +199,6 @@ BOOL TaskPaneList::HandleKeyEvent( KeyEv
         bSplitterOnly = bF6 && aKeyCode.IsMod1() && aKeyCode.IsShift();
 
 		// is the focus in the list ?
-		BOOL bHasFocus = FALSE;
 		::std::vector< Window* >::iterator p = mTaskPanes.begin();
 		while( p != mTaskPanes.end() )
         {
Index: vcl/source/window/toolbox.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/toolbox.cxx,v
retrieving revision 1.61.82.1
retrieving revision 1.69
diff -u -p -u -r1.61.82.1 -r1.69
--- vcl/source/window/toolbox.cxx	9 Jan 2004 18:13:55 -0000	1.61.82.1
+++ vcl/source/window/toolbox.cxx	10 Jun 2004 17:18:47 -0000	1.69
@@ -59,12 +59,13 @@
  *
  ************************************************************************/
 
-#define _SV_TOOLBOX_CXX
-
 #include <string.h>
-
 #include <vector>
 
+#ifndef _SV_SVSYS_HXX
+#include <svsys.h>
+#endif
+
 #ifndef _LIST_HXX
 #include <tools/list.hxx>
 #endif
@@ -73,7 +74,7 @@
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -116,11 +114,8 @@
 #ifndef _SV_BITMAP_HXX
 #include <bitmap.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
-#endif
-#ifndef _SV_SVSYS_HXX
-#include <svsys.h>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
@@ -382,40 +377,6 @@ static ImplTBDragMgr* ImplGetTBDragMgr()
 
 static void ImplDrawConfigFrame( ToolBox* pThis, const Rectangle& rRect )
 {
-/*
-    Color   aBlackColor( COL_BLACK );
-    Pen     aOldPen;
-    Brush   aOldBrush;
-    Pen     aNullPen( PEN_NULL );
-
-    aOldPen = pThis->GetPen();
-    pThis->SetPen( aNullPen );
-    if ( pThis->IsSVLook() )
-    {
-        Color aFaceColor( COL_3DFACE );
-        Brush aBrush( aFaceColor, aBlackColor, BRUSH_50 );
-        aOldBrush = pThis->GetFillInBrush();
-        pThis->SetFillInBrush( aBrush );
-    }
-    else
-    {
-        Color aWhiteColor( COL_WHITE );
-        Brush aBrush( aBlackColor, aWhiteColor, BRUSH_50 );
-        aOldBrush = pThis->GetFillInBrush();
-        pThis->SetFillInBrush( aBrush );
-    }
-    pThis->DrawRect( Rectangle( rRect.Left(), rRect.Top(),
-                                rRect.Right(), rRect.Top()+2 ) );
-    pThis->DrawRect( Rectangle( rRect.Left(), rRect.Top(),
-                                rRect.Left()+2, rRect.Bottom() ) );
-    pThis->DrawRect( Rectangle( rRect.Left(), rRect.Bottom()-2,
-                                rRect.Right(), rRect.Bottom() ) );
-    pThis->DrawRect( Rectangle( rRect.Right()-2, rRect.Top(),
-                                rRect.Right(), rRect.Bottom() ) );
-
-    pThis->SetPen( aOldPen );
-    pThis->SetFillInBrush( aOldBrush );
-*/
 }
 
 // -----------------------------------------------------------------------
@@ -956,38 +917,6 @@ ImplTBDragMgr::~ImplTBDragMgr()
 
 ToolBox* ImplTBDragMgr::FindToolBox( const Rectangle& rRect )
 {
-#if 0
-    // ToolBox suchen
-    Point aPos = rRect.Center();
-    ToolBox* pBox = mpBoxList->First();
-    while ( pBox )
-    {
-        if ( pBox->IsReallyVisible() )
-        {
-            Window* pWindow = pBox->ImplGetFrameWindow()->FindWindow( aPos );
-            if ( pWindow && pBox->IsWindowOrChild( pWindow ) )
-                return pBox;
-        }
-        pBox = mpBoxList->Next();
-    }
-
-    // Falls so nicht gefunden wurde, suchen wir die ToolBox ueber das Rechteck
-    pBox = mpBoxList->First();
-    while ( pBox )
-    {
-        if ( pBox->IsReallyVisible() )
-        {
-            if ( pBox->IsFloatingMode() )
-            {
-                Rectangle aTempRect( pBox->GetPosPixel(), pBox->GetSizePixel() );
-                if ( aTempRect.IsOver( rRect ) )
-                    return pBox;
-            }
-        }
-
-        pBox = mpBoxList->Next();
-    }
-#endif
     ToolBox* pBox = mpBoxList->First();
     while ( pBox )
     {
@@ -1070,7 +999,6 @@ void ImplTBDragMgr::Dragging( const Poin
     if ( mnLineMode )
     {
         ImplLineSizing( mpDragBox, rPos, maRect, mnLineMode );
-        Point aPos = mpDragBox->OutputToScreenPixel( rPos );
         Point aOff = mpDragBox->OutputToScreenPixel( Point() );
         maRect.Move( aOff.X(), aOff.Y() );
         mpDragBox->Docking( rPos, maRect );
@@ -1459,7 +1387,7 @@ void ToolBox::ImplInit( Window* pParent,
     mnRightBorder     = 0;
     mnBottomBorder    = 0;
     mnLastResizeDY    = 0;
-    mnOutStyle        = 0;
+    mnOutStyle        = TOOLBOX_STYLE_FLAT; // force flat buttons since NWF
     mnHighItemId      = 0;
     mnCurItemId       = 0;
     mnDownItemId      = 0;
@@ -1490,9 +1418,9 @@ void ToolBox::ImplInit( Window* pParent,
     mbDragging        = FALSE;
     mbHideStatusText  = FALSE;
     mbMenuStrings     = FALSE;
-    mbDummy1_Shift    = FALSE;
-    mbDummy2_KeyEvt   = FALSE;
-    mbDummy3_ChangingHighlight = FALSE;
+    mbIsShift		  = FALSE;
+    mbIsKeyEvent = FALSE;
+    mbChangingHighlight = FALSE;
     meButtonType      = BUTTON_SYMBOL;
     meAlign           = WINDOWALIGN_TOP;
     meLastStyle       = POINTER_ARROW;
@@ -2049,6 +1977,22 @@ USHORT ToolBox::ImplCalcBreaks( long nWi
 }
 
 // -----------------------------------------------------------------------
+namespace
+{
+    BOOL ImplFollowedByVisibleButton( std::vector< ImplToolItem >::iterator _aSeparator, std::vector< ImplToolItem >::iterator _aEnd )
+    {
+        std::vector< ImplToolItem >::iterator aLookup = _aSeparator;
+        while ( ++aLookup != _aEnd )
+        {
+            if ( aLookup->meType == TOOLBOXITEM_SEPARATOR )
+                return ImplFollowedByVisibleButton( aLookup, _aEnd );
+
+            if ( ( aLookup->meType == TOOLBOXITEM_BUTTON ) && aLookup->mbVisible )
+                return TRUE;
+        }
+        return FALSE;
+    }
+}
 
 void ToolBox::ImplFormat( BOOL bResize )
 {
@@ -2194,8 +2138,11 @@ void ToolBox::ImplFormat( BOOL bResize )
             // For items not visible, release resources only needed during
             // painting the items (on Win98, for example, these are system-wide
             // resources that are easily exhausted, so be nice):
-            it->maImage.ClearCaches();
-            it->maHighImage.ClearCaches();
+            
+			/* !!!
+				it->maImage.ClearCaches();
+            	it->maHighImage.ClearCaches();
+			*/
 
             ++it;
         }
@@ -2290,18 +2237,7 @@ void ToolBox::ImplFormat( BOOL bResize )
                     {
                         // Feststellen ob dahinter ueberhaupt noch
                         // ein Item sichtbar ist
-                        temp_it = it+1;
-                        while ( temp_it != mpData->m_aItems.end() )
-                        {
-                            if ( (temp_it->meType == TOOLBOXITEM_SEPARATOR) ||
-                                 ((temp_it->meType == TOOLBOXITEM_BUTTON) &&
-                                  temp_it->mbVisible) )
-                            {
-                                it->mbVisible = TRUE;
-                                break;
-                            }
-                            ++temp_it;
-                        }
+                        it->mbVisible = ImplFollowedByVisibleButton( it, mpData->m_aItems.end() );
                     }
                     bLastSep = TRUE;
                 }
@@ -2491,8 +2427,11 @@ void ToolBox::ImplFormat( BOOL bResize )
                 // For items not visible, release resources only needed during
                 // painting the items (on Win98, for example, these are system-
                 // wide resources that are easily exhausted, so be nice):
-                it->maImage.ClearCaches();
+                
+				/* !!!
+				it->maImage.ClearCaches();
                 it->maHighImage.ClearCaches();
+				*/
             }
             ++it;
         }
@@ -2508,7 +2447,6 @@ IMPL_LINK( ToolBox, ImplUpdateHdl, void*
 {
     DBG_CHKTHIS( Window, ImplDbgCheckWindow );
 
-//#ifndef REMOTE_APPSERVER
     if( GetCurrentModButtons() & ( MOUSE_LEFT | MOUSE_MIDDLE | MOUSE_RIGHT ) )
     {
         mbFormat = TRUE;
@@ -2516,7 +2454,6 @@ IMPL_LINK( ToolBox, ImplUpdateHdl, void*
         maTimer.Start();
     }
     else
-//#endif
     {
         mbFormat = TRUE;
         ImplFormat();
@@ -2628,7 +2565,6 @@ static void SetToolArrowClipregion( Tool
                                long nSize = 6 )
 {
     WindowAlign     eAlign = pBox->meAlign;
-    long            n = 0;
     long            nHalfSize;
     if ( bLeft )
         eAlign = WINDOWALIGN_RIGHT;
@@ -3053,7 +2989,9 @@ void ToolBox::ImplDrawItem( USHORT nPos,
             {
                 nTempOffX++;
                 nTempOffY++;
-                if( pImage->HasMaskBitmap() )
+                
+				/* !!!
+				if( pImage->HasMaskBitmap() )
                 {
                     Color aMaskCol = GetpApp()->GetSettings().GetStyleSettings().GetHighlightColor();
                     USHORT h,s,b;
@@ -3063,6 +3001,8 @@ void ToolBox::ImplDrawItem( USHORT nPos,
                     aMaskCol = ImplHSBtoRGB( h, s, b );
                     DrawMask( Point( nTempOffX, nTempOffY ), pImage->GetMaskBitmap(), aMaskCol );
                 }
+				*/ 
+				
                 nTempOffX-=2;
                 nTempOffY-=2;
             }
@@ -3204,7 +3144,16 @@ void ToolBox::ImplDrawItem( USHORT nPos,
             SetFillColor( rStyleSettings.GetShadowColor() );
         else
         {
-            SetFillColor( COL_LIGHTGREEN );
+            Color aFillColor( COL_LIGHTGREEN );
+            if ( rStyleSettings.IsHighContrastBlackAndWhite() )
+            {
+                if ( rStyleSettings.GetFaceColor().GetColor() == COL_WHITE )
+                    aFillColor = Color( COL_BLACK );
+                else
+                    aFillColor = Color( COL_WHITE );
+
+            }
+            SetFillColor( aFillColor );
             bBlack = TRUE;
         }
 
@@ -3613,7 +3562,7 @@ void ToolBox::MouseMove( const MouseEven
             if ( mnCurPos != TOOLBOX_ITEM_NOTFOUND )
             {
                 ImplDrawItem( mnCurPos );
-                ImplCallEventListeners( VCLEVENT_TOOLBOX_HIGHLIGHTOFF, (void*) mnCurPos );
+                ImplCallEventListeners( VCLEVENT_TOOLBOX_HIGHLIGHTOFF, reinterpret_cast< void* >( mnCurPos ) );
             }
 
             mnCurPos = nNewPos;
@@ -3707,7 +3656,7 @@ void ToolBox::MouseMove( const MouseEven
                                     ImplHideFocus();
                                     USHORT nPos = GetItemPos( mnHighItemId );
                                     ImplDrawItem( nPos );
-                                    ImplCallEventListeners( VCLEVENT_TOOLBOX_HIGHLIGHTOFF, (void*) nPos );
+                                    ImplCallEventListeners( VCLEVENT_TOOLBOX_HIGHLIGHTOFF, reinterpret_cast< void* >( nPos ) );
                                 }
                                 mnHighItemId = it->mnId;
                                 ImplDrawItem( nTempPos, 2 );
@@ -3733,7 +3682,7 @@ void ToolBox::MouseMove( const MouseEven
             {
                 ImplDrawItem( nClearPos, (nClearPos == mnCurPos) ? TRUE : FALSE );
                 if( nClearPos != mnCurPos )
-                    ImplCallEventListeners( VCLEVENT_TOOLBOX_HIGHLIGHTOFF, (void*) nClearPos );
+                    ImplCallEventListeners( VCLEVENT_TOOLBOX_HIGHLIGHTOFF, reinterpret_cast< void* >( nClearPos ) );
             }
             ImplHideFocus();
             mnHighItemId = 0;
@@ -4745,9 +4687,9 @@ BOOL ToolBox::ImplActivateItem( KeyCode 
         if( pItem && pItem->mpWindow && HasFocus() )
         {
             ImplHideFocus();
-            mbDummy3_ChangingHighlight = TRUE;  // avoid focus change due to loose focus
+            mbChangingHighlight = TRUE;  // avoid focus change due to loose focus
             pItem->mpWindow->ImplControlFocus( GETFOCUS_TAB );
-            mbDummy3_ChangingHighlight = FALSE;
+            mbChangingHighlight = FALSE;
         }
         else
         {
@@ -4769,7 +4711,7 @@ BOOL ToolBox::ImplActivateItem( KeyCode 
 				}
             }
             mnMouseModifier = aKeyCode.GetModifier();
-            mbDummy2_KeyEvt = TRUE;
+            mbIsKeyEvent = TRUE;
             Activate();
             Click();
 
@@ -4782,7 +4724,7 @@ BOOL ToolBox::ImplActivateItem( KeyCode 
             ImplRemoveDel( &aDelData );
 
             Deactivate();
-            mbDummy2_KeyEvt = FALSE;
+            mbIsKeyEvent = FALSE;
             mnMouseModifier = 0;
         }
 	}
@@ -4829,14 +4771,14 @@ BOOL ToolBox::ImplOpenItem( KeyCode aKey
 		ImplToolItem* pItem = ImplGetItem( mnHighItemId );
 
 		mnMouseModifier = aKeyCode.GetModifier();
-		mbDummy1_Shift = TRUE;
-		mbDummy2_KeyEvt = TRUE;
+		mbIsShift = TRUE;
+		mbIsKeyEvent = TRUE;
 		Activate();
 		Click();
 		if (pItem->mnBits & TIB_REPEAT)
 			Select();
-		mbDummy2_KeyEvt = FALSE;
-		mbDummy1_Shift = FALSE;
+		mbIsKeyEvent = FALSE;
+		mbIsShift = FALSE;
 		mnMouseModifier = 0;
 	}
     else
@@ -5029,9 +4971,9 @@ void ToolBox::KeyInput( const KeyEvent& 
             {
                 Window *pFocusWindow = Application::GetFocusWindow();
                 ImplHideFocus();
-                mbDummy3_ChangingHighlight = TRUE;  // avoid focus change due to loose focus
+                mbChangingHighlight = TRUE;  // avoid focus change due to loose focus
                 pItem->mpWindow->ImplControlFocus( GETFOCUS_TAB );
-                mbDummy3_ChangingHighlight = FALSE;
+                mbChangingHighlight = FALSE;
                 if( pFocusWindow != Application::GetFocusWindow() )
                     Application::GetFocusWindow()->KeyInput( rKEvt );
             }
@@ -5177,10 +5119,10 @@ static USHORT ImplFindItemPos( const Imp
 void ToolBox::ImplChangeHighlight( ImplToolItem* pItem, BOOL bNoGrabFocus )
 {
     // avoid recursion due to focus change
-    if( mbDummy3_ChangingHighlight )
+    if( mbChangingHighlight )
         return;
 
-    mbDummy3_ChangingHighlight = TRUE;
+    mbChangingHighlight = TRUE;
 
 	ImplToolItem* pOldItem = NULL;
     USHORT        oldPos = 0;
@@ -5190,7 +5132,7 @@ void ToolBox::ImplChangeHighlight( ImplT
         ImplHideFocus();
         USHORT nPos = GetItemPos( mnHighItemId );
         ImplDrawItem( nPos, FALSE );
-        ImplCallEventListeners( VCLEVENT_TOOLBOX_HIGHLIGHTOFF, (void*) nPos );
+        ImplCallEventListeners( VCLEVENT_TOOLBOX_HIGHLIGHTOFF, reinterpret_cast< void* >( nPos ) );
 	    pOldItem = ImplGetItem( mnHighItemId );
         oldPos = ImplFindItemPos( pOldItem, mpData->m_aItems );
     }
@@ -5242,7 +5184,7 @@ void ToolBox::ImplChangeHighlight( ImplT
         mnCurPos = TOOLBOX_ITEM_NOTFOUND;
     }
 
-    mbDummy3_ChangingHighlight = FALSE;
+    mbChangingHighlight = FALSE;
 }
 
 // -----------------------------------------------------------------------
@@ -5289,7 +5231,6 @@ BOOL ToolBox::ImplChangeHighlightUpDn( B
         }
     }
 
-	ImplToolItem* pOldItem = pItem;
 	if( pItem )
 	{
         ULONG pos = ImplFindItemPos( pItem, mpData->m_aItems );
Index: vcl/source/window/toolbox2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/toolbox2.cxx,v
retrieving revision 1.20.82.1
retrieving revision 1.25
diff -u -p -u -r1.20.82.1 -r1.25
--- vcl/source/window/toolbox2.cxx	9 Jan 2004 18:13:55 -0000	1.20.82.1
+++ vcl/source/window/toolbox2.cxx	21 May 2004 16:29:11 -0000	1.25
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_TOOLBOX_CXX
-
 #ifndef _LIST_HXX
 #include <tools/list.hxx>
 #endif
@@ -69,7 +67,7 @@
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -468,24 +466,6 @@ void ToolBox::InsertItem( const ResId& r
 	if ( nObjMask & RSC_TOOLBOXITEM_HELPTEXT )
 		aItem.maHelpText = ReadStringRes();
 
-/*
-#ifndef WIN
-	static
-#endif
-		short nHelpMode = -1;
-	if( nHelpMode == -1 ) {
-		SvHelpSettings aHelpSettings;
-
-		GetpApp()->Property( aHelpSettings );
-		nHelpMode = aHelpSettings.nHelpMode;
-	}
-
-	if( (nHelpMode & HELPTEXTMODE_EXTERN) && aItem.aHelpText.Len() )
-		aItem.aHelpText.Erase();
-	if( (nHelpMode & HELPTEXTMODE_DEBUG) && !aItem.nHelpId )
-		aItem.aHelpText = "??? !aItem.nHelpId MP/W.P. ???";
-*/
-
 	if ( nObjMask & RSC_TOOLBOXITEM_BITMAP )
 	{
 		Bitmap aBmp = Bitmap( ResId( (RSHEADER_TYPE*)GetClassRes() ) );
@@ -541,7 +521,7 @@ void ToolBox::InsertItem( const ResId& r
 
     // Notify
 	USHORT nNewPos = ( nPos == TOOLBOX_APPEND ) ? ( mpData->m_aItems.size() - 1 ) : nPos;
-    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, (void*) nNewPos );
+    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, reinterpret_cast< void* >( nNewPos ) );
 }
 
 // -----------------------------------------------------------------------
@@ -561,7 +541,7 @@ void ToolBox::InsertItem( USHORT nItemId
 
     // Notify
     USHORT nNewPos = ( nPos == TOOLBOX_APPEND ) ? ( mpData->m_aItems.size() - 1 ) : nPos;
-    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, (void*) nNewPos );
+    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, reinterpret_cast< void* >(nNewPos ) );
 }
 
 // -----------------------------------------------------------------------
@@ -582,7 +562,7 @@ void ToolBox::InsertItem( USHORT nItemId
 
     // Notify
     USHORT nNewPos = ( nPos == TOOLBOX_APPEND ) ? ( mpData->m_aItems.size() - 1 ) : nPos;
-    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, (void*) nNewPos );
+    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, reinterpret_cast< void* >( nNewPos ) );
 }
 
 // -----------------------------------------------------------------------
@@ -602,7 +582,7 @@ void ToolBox::InsertItem( USHORT nItemId
 
     // Notify
     USHORT nNewPos = ( nPos == TOOLBOX_APPEND ) ? ( mpData->m_aItems.size() - 1 ) : nPos;
-    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, (void*) nNewPos );
+    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, reinterpret_cast< void* >( nNewPos ) );
 }
 
 // -----------------------------------------------------------------------
@@ -630,7 +610,7 @@ void ToolBox::InsertWindow( USHORT nItem
 
     // Notify
     USHORT nNewPos = ( nPos == TOOLBOX_APPEND ) ? ( mpData->m_aItems.size() - 1 ) : nPos;
-    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, (void*) nNewPos );
+    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, reinterpret_cast< void* >( nNewPos ) );
 }
 
 // -----------------------------------------------------------------------
@@ -648,7 +628,7 @@ void ToolBox::InsertSpace( USHORT nPos )
 
     // Notify
     USHORT nNewPos = ( nPos == TOOLBOX_APPEND ) ? ( mpData->m_aItems.size() - 1 ) : nPos;
-    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, (void*) nNewPos );
+    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, reinterpret_cast< void* >( nNewPos ) );
 }
 
 // -----------------------------------------------------------------------
@@ -668,7 +648,7 @@ void ToolBox::InsertSeparator( USHORT nP
 
     // Notify
     USHORT nNewPos = ( nPos == TOOLBOX_APPEND ) ? ( mpData->m_aItems.size() - 1 ) : nPos;
-    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, (void*) nNewPos );
+    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, reinterpret_cast< void* >( nNewPos ) );
 }
 
 // -----------------------------------------------------------------------
@@ -686,7 +666,7 @@ void ToolBox::InsertBreak( USHORT nPos )
 
     // Notify
     USHORT nNewPos = ( nPos == TOOLBOX_APPEND ) ? ( mpData->m_aItems.size() - 1 ) : nPos;
-    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, (void*) nNewPos );
+    ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, reinterpret_cast< void* >( nNewPos ) );
 }
 
 // -----------------------------------------------------------------------
@@ -719,7 +699,7 @@ void ToolBox::RemoveItem( USHORT nPos )
         mpData->ImplClearLayoutData();
 
         // Notify
-        ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMREMOVED, (void*) nPos );
+        ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMREMOVED, reinterpret_cast< void* >( nPos ) );
 	}
 }
 
@@ -749,11 +729,11 @@ void ToolBox::MoveItem( USHORT nItemId, 
 
         // Notify
         if( nPos < nNewPos )    // only send one event, all indices above this item are invalid anyway
-            ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMREMOVED, (void*) nPos );
+            ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMREMOVED, reinterpret_cast< void* >( nPos ) );
         else
 		{
 			USHORT nNewPos2 = ( nNewPos == TOOLBOX_APPEND ) ? ( mpData->m_aItems.size() - 1 ) : nNewPos;
-			ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, (void*) nNewPos2 );
+			ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, reinterpret_cast< void* >( nNewPos2 ) );
 		}
 	}
 }
@@ -784,7 +764,7 @@ void ToolBox::CopyItem( const ToolBox& r
 
         // Notify
 		USHORT nNewPos2 = ( nNewPos == TOOLBOX_APPEND ) ? ( mpData->m_aItems.size() - 1 ) : nNewPos;
-		ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, (void*) nNewPos2 );
+		ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMADDED, reinterpret_cast< void* >( nNewPos2 ) );
 	}
 }
 
@@ -1290,7 +1240,7 @@ void ToolBox::SetItemText( USHORT nItemI
 			pItem->maText = ImplConvertMenuString( rText );
 
         // Notify
-        ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMTEXTCHANGED, (void*) nPos );
+        ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMTEXTCHANGED, reinterpret_cast< void* >( nPos ) );
 	}
 }
 
@@ -1319,7 +1269,7 @@ void ToolBox::SetItemWindow( USHORT nIte
 		if ( pNewWindow )
 			pNewWindow->Hide();
 		ImplInvalidate( TRUE );
-		ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMWINDOWCHANGED, (void*) nPos );
+		ImplCallEventListeners( VCLEVENT_TOOLBOX_ITEMWINDOWCHANGED, reinterpret_cast< void* >( nPos ) );
 	}
 }
 
@@ -1485,7 +1435,7 @@ void ToolBox::SetItemState( USHORT nItem
 			pItem->meState = eState;
 			ImplUpdateItem( nPos );
 			// Notify
-		    ImplCallEventListeners( VCLEVENT_TOOLBOX_CLICK, (void*) nPos );
+		    ImplCallEventListeners( VCLEVENT_TOOLBOX_CLICK, reinterpret_cast< void* >( nPos ) );
 		}
 	}
 }
@@ -1526,7 +1476,7 @@ void ToolBox::EnableItem( USHORT nItemId
 
 			ImplUpdateInputEnable();
 
-            ImplCallEventListeners( bEnable ? VCLEVENT_TOOLBOX_ITEMENABLED : VCLEVENT_TOOLBOX_ITEMDISABLED, (void*)nPos );
+            ImplCallEventListeners( bEnable ? VCLEVENT_TOOLBOX_ITEMENABLED : VCLEVENT_TOOLBOX_ITEMDISABLED, reinterpret_cast< void* >( nPos ) );
 		}
 	}
 }
@@ -1684,6 +1634,9 @@ void ToolBox::SetBorder( long nX, long n
 
 void ToolBox::SetOutStyle( USHORT nNewStyle )
 {
+    // always force flat looking toolbars since NWF
+    nNewStyle |= TOOLBOX_STYLE_FLAT;
+
 	if ( mnOutStyle != nNewStyle )
 	{
 		mnOutStyle = nNewStyle;
@@ -1826,4 +1779,3 @@ USHORT ToolBox::GetDisplayItemId( long n
         nItemId = mpData->m_pLayoutData->m_aLineItemIds[nText];
     return nItemId;
 }
-
Index: vcl/source/window/window.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/window.cxx,v
retrieving revision 1.176.46.6
retrieving revision 1.191
diff -u -p -u -r1.176.46.6 -r1.191
--- vcl/source/window/window.cxx	5 Feb 2004 16:45:54 -0000	1.176.46.6
+++ vcl/source/window/window.cxx	25 Jun 2004 15:18:01 -0000	1.191
@@ -59,9 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_WINDOW_CXX
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
@@ -80,6 +77,8 @@
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
+#ifndef _SV_SALCTRLHANDLE_HXX
+#include <salctrlhandle.hxx>
 #endif
 
 #include <unohelp.hxx>
@@ -88,7 +87,7 @@
 #include <tools/debug.hxx>
 #endif
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -188,20 +189,6 @@
 #include <com/sun/star/accessibility/AccessibleRole.hpp>
 #endif
 
-
-#ifdef REMOTE_APPSERVER
-#include "rmwindow.hxx"
-#include "xevthdl.hxx"
-#include "rmevents.hxx"
-#include "rmoutdev.hxx"
-#ifndef _ISOLANG_HXX
-#include <tools/isolang.hxx>
-#endif
-#include "com/sun/star/portal/client/XRmFrameWindow.hpp"
-#include "com/sun/star/uno/Any.hxx"
-#include "com/sun/star/uno/Reference.hxx"
-#endif
-
 #include <unowrap.hxx>
 #include <dndlcon.hxx>
 #include <dndevdis.hxx>
@@ -211,7 +198,7 @@
 #include <unotools/confignode.hxx>
 #endif
 
-#pragma hdrstop
+
 
 using namespace rtl;
 using namespace ::com::sun::star::uno;
@@ -342,7 +329,7 @@ void Window::ImplUpdateGlobalSettings( A
     {
         ImplInitFontList();
 
-        String aConfigFont = vcl::DefaultFontConfigItem::get()->getUserInterfaceFont();
+        String aConfigFont = vcl::DefaultFontConfigItem::get()->getUserInterfaceFont( rSettings.GetUILocale() );
         xub_StrLen nIndex = 0;
         while( nIndex != STRING_NOTFOUND )
         {
@@ -409,16 +396,29 @@ void Window::ImplUpdateGlobalSettings( A
 
     if( 1 )
     {
-        // #97047: Force all fonts except Mneu and Help to a fixed height
-        // to avoid UI scaling due to large fonts
         StyleSettings aStyleSettings = rSettings.GetStyleSettings();
+        // #97047: Force all fonts except Menu and Help to a fixed height
+        // to avoid UI scaling due to large fonts
+        // - but allow bigger fonts on bigger screens (i16682, i21238)
+        //   dialogs were designed to fit 800x600 with an 8pt font, so scale accordingly
+        int maxFontheight = 9; // #107886#: 9 is default for some asian systems, so always allow if requested
+        if( GetDesktopRectPixel().getHeight() > 600 )
+            maxFontheight = (int) ((( 8 * (double) GetDesktopRectPixel().getHeight()) / 600.) + 0.5);
 
-        // #107886# allow scaling of the UI if the menu font is 
-        //  slightly larger/smaller than the 8pt default
-        int defFontheight = 8;
         Font aFont = aStyleSettings.GetMenuFont();
-        if( abs(aFont.GetHeight() - defFontheight) == 1 )
-            defFontheight = aFont.GetHeight();
+        int defFontheight = aFont.GetHeight();
+        if( defFontheight > maxFontheight )
+            defFontheight = maxFontheight;
+
+        // if the UI is korean, always use 9pt
+        LanguageType aLang = Application::GetSettings().GetUILanguage();
+        if( aLang == LANGUAGE_KOREAN || aLang == LANGUAGE_KOREAN_JOHAB )
+            defFontheight = Max(9, defFontheight);
+
+        // i22098, toolfont will be scaled differently to avoid bloated rulers and status bars for big fonts
+        int toolfontheight = defFontheight;
+        if( toolfontheight > 9 )
+            toolfontheight = (defFontheight+8) / 2;
 
         aFont = aStyleSettings.GetAppFont();
         aFont.SetHeight( defFontheight );
@@ -435,9 +435,12 @@ void Window::ImplUpdateGlobalSettings( A
         //aFont = aStyleSettings.GetMenuFont();
         //aFont.SetHeight( defFontheight );
         //aStyleSettings.SetMenuFont( aFont );
+
+        // use different height for toolfont
         aFont = aStyleSettings.GetToolFont();
-        aFont.SetHeight( defFontheight );
+        aFont.SetHeight( toolfontheight ); 
         aStyleSettings.SetToolFont( aFont );
+
         aFont = aStyleSettings.GetLabelFont();
         aFont.SetHeight( defFontheight );
         aStyleSettings.SetLabelFont( aFont );
@@ -552,6 +555,18 @@ MouseEvent ImplTranslateMouseEvent( cons
     return MouseEvent( aPos, rE.GetClicks(), rE.GetMode(), rE.GetButtons(), rE.GetModifier() );
 }
 
+// -----------------------------------------------------------------------
+
+CommandEvent ImplTranslateCommandEvent( const CommandEvent& rCEvt, Window* pSource, Window* pDest )
+{
+    if ( !rCEvt.IsMouseEvent() )
+        return rCEvt;
+
+    Point aPos = pSource->OutputToScreenPixel( rCEvt.GetMousePosPixel() );
+    aPos = pDest->ScreenToOutputPixel( aPos );
+    return CommandEvent( aPos, rCEvt.GetCommand(), rCEvt.IsMouseEvent(), rCEvt.GetData() );
+}
+
 // =======================================================================
 
 void Window::ImplInitData( WindowType nType )
@@ -609,7 +624,6 @@ void Window::ImplInitData( WindowType nT
     mnActivateMode      = 0;            // Wird bei System/Overlap-Windows umgesetzt
     mnDlgCtrlFlags      = 0;            // DialogControl-Flags
     mnLockCount         = 0;            // LockCount
-    mnIsTopWindow       = (USHORT) ~0;  // not initialized yet, 0/1 will indicate TopWindow (see IsTopWindow())
     mbFrame             = FALSE;        // TRUE: Window is a frame window
     mbBorderWin         = FALSE;        // TRUE: Window is a border window
     mbOverlapWin        = FALSE;        // TRUE: Window is a overlap window
@@ -675,37 +689,18 @@ void Window::ImplInitData( WindowType nT
     mbSuppressAccessibilityEvents = FALSE; // TRUE: do not send any accessibility events
     mbEnableRTL         = TRUE;         // TRUE: this outdev will be mirrored if RTL window layout (UI mirroring) is globally active
     mbDrawSelectionBackground = FALSE;  // TRUE: draws transparent window background to indicate (toolbox) selection
-#ifdef REMOTE_APPSERVER
-    mpRmEvents          = NULL;
-
-    Font aFont = maInputContext.GetFont();
-    aFont.SetCharSet( gsl_getSystemTextEncoding() );
-    maInputContext.SetFont( aFont );
-#endif
 }
 
 // -----------------------------------------------------------------------
 
-#ifdef REMOTE_APPSERVER
-void Window::ImplInit( Window* pParent, WinBits nStyle, SystemParentData* pSystemParentData )
-{
-    static ::com::sun::star::uno::Any aVoid;
-    ImplInit( pParent, nStyle, aVoid );
-}
-#else
 void Window::ImplInit( Window* pParent, WinBits nStyle, const ::com::sun::star::uno::Any& aSystemWorkWindowToken )
 {
     ImplInit( pParent, nStyle, NULL );
 }
-#endif
 
 // -----------------------------------------------------------------------
 
-#ifndef REMOTE_APPSERVER
 void Window::ImplInit( Window* pParent, WinBits nStyle, SystemParentData* pSystemParentData )
-#else
-void Window::ImplInit( Window* pParent, WinBits nStyle, const ::com::sun::star::uno::Any& aSystemWorkWindowToken )
-#endif
 {
     DBG_ASSERT( mbFrame || pParent, "Window::Window(): pParent == NULL" );
 
@@ -746,7 +741,6 @@ void Window::ImplInit( Window* pParent, 
     if ( mbFrame )
     {
         // create frame
-#ifndef REMOTE_APPSERVER
         ULONG nFrameStyle = 0;
 
         if ( nStyle & WB_MOVEABLE )
@@ -783,31 +777,6 @@ void Window::ImplInit( Window* pParent, 
         if ( !pFrame )
             GetpApp()->Exception( EXC_SYSOBJNOTCREATED );
         pFrame->SetCallback( this, ImplWindowFrameProc );
-#else
-        if ( !(nStyle & WB_MOVEABLE) && 
-            (mbFloatWin || ((GetType() == WINDOW_BORDERWINDOW) && ((ImplBorderWindow*)this)->mbFloatWindow) ) )
-            nStyle = WB_SYSTEMFLOATWIN;	// window corresponds to a float win on the server
-
-        RmFrameWindow* pParentFrame = pParent ? pParent->mpFrame : NULL;;
-        star::uno::Reference< star::portal::client::XRmFrameWindow >
-            xClientWindow;
-        star::uno::Any aToken;
-        if (!(aSystemWorkWindowToken >>= xClientWindow))
-            aToken = aSystemWorkWindowToken;
-        RmFrameWindow* pFrame = new RmFrameWindow(this, xClientWindow);
-        if ( !pFrame->IsValid() )
-        {
-            delete pFrame;
-            pFrame = NULL;
-            GetpApp()->Exception( EXC_SYSOBJNOTCREATED );
-        }
-        else
-        {
-            pFrame->Create( nStyle, pFrame->GetEventHdlInterface(), GetAccessible()->getAccessibleContext(),
-                            aToken,
-                            pParentFrame ? pParentFrame->GetFrameInterface() : REF( NMSP_CLIENT::XRmFrameWindow )() );
-        }
-#endif
 
         // set window frame data
         mpFrameData     = new ImplFrameData;
@@ -830,6 +799,8 @@ void Window::ImplInit( Window* pParent, 
         mpFrameData->mnMouseMoveId      = 0;
         mpFrameData->mnLastMouseX       = -1;
         mpFrameData->mnLastMouseY       = -1;
+        mpFrameData->mnBeforeLastMouseX = -1;
+        mpFrameData->mnBeforeLastMouseY = -1;
         mpFrameData->mnFirstMouseX      = -1;
         mpFrameData->mnFirstMouseY      = -1;
         mpFrameData->mnLastMouseWinX    = -1;
@@ -866,7 +837,6 @@ void Window::ImplInit( Window* pParent, 
 
     if ( mbFrame )
     {
-#ifndef REMOTE_APPSERVER
         if ( pParent )
         {
             mpFrameData->mnDPIX     = pParent->mpFrameData->mnDPIX;
@@ -882,37 +852,7 @@ void Window::ImplInit( Window* pParent, 
                 mpGraphics->GetScreenFontResolution( mpFrameData->mnFontDPIX, mpFrameData->mnFontDPIY );
             }
         }
-#else
-        const REF( NMSP_CLIENT::XRmFrameWindow )& rxWindow = mpFrame->GetFrameInterface();
-        REF( NMSP_CLIENT::XRmOutputDevice ) xOutDev( mpFrame->GetOutdevInterface() );
 
-        if ( rxWindow.is() && xOutDev.is() )
-        {
-            mpGraphics = new ImplServerGraphics;
-            mpGraphics->SetInterface( xOutDev );
-            if ( pParent )
-            {
-                mpFrameData->mnDPIX     = pParent->mpFrameData->mnDPIX;
-                mpFrameData->mnDPIY     = pParent->mpFrameData->mnDPIY;
-                mpFrameData->mnFontDPIX = pParent->mpFrameData->mnFontDPIX;
-                mpFrameData->mnFontDPIY = pParent->mpFrameData->mnFontDPIY;
-            }
-            else
-            {
-                // We currently assume, that we have only one display
-                static NMSP_CLIENT::RmFrameResolutions aResl = mpFrame->GetFrameResolutions();
-                mpFrameData->mnDPIX     = aResl.DPIx;
-                mpFrameData->mnDPIY     = aResl.DPIy;
-                mpFrameData->mnFontDPIX = aResl.FontDPIx;
-                mpFrameData->mnFontDPIY = aResl.FontDPIy;
-                mpGraphics->SetWindowResolution( aResl.DPIx, aResl.DPIy, aResl.Depth );
-                if ( !mpFrameData->mpFontList->Count() )
-                    mpGraphics->GetDevFontList( mpFrameData->mpFontList );
-            }
-        }
-#endif
-
-#ifndef REMOTE_APPSERVER
         // delay settings initialization until first "real" frame
         // this relies on the IntroWindow not needing any system settings
         if ( !pSVData->maAppData.mbSettingsInit &&
@@ -924,7 +864,6 @@ void Window::ImplInit( Window* pParent, 
             OutputDevice::SetSettings( *pSVData->maAppData.mpSettings );
             pSVData->maAppData.mbSettingsInit = TRUE;
         }
-#endif
 
         // If we create a Window with default size, query this
         // size directly, because we want resize all Controls to
@@ -987,13 +926,8 @@ void Window::ImplSetFrameParent( const W
             DBG_ASSERT( mpFrame != pFrameWindow->mpFrame, "SetFrameParent to own" );
             DBG_ASSERT( mpFrame, "no frame" );
             
-#ifndef REMOTE_APPSERVER
             SalFrame* pParentFrame = pParent ? pParent->mpFrame : NULL;
             pFrameWindow->mpFrame->SetParent( pParentFrame );
-#else
-            RmFrameWindow* pParentFrame = pParent ? pParent->mpFrame : NULL;
-            pFrameWindow->mpFrame->SetParent( pParentFrame ? pParentFrame->GetFrameInterface() : REF( NMSP_CLIENT::XRmFrameWindow )() );
-#endif
         }
         pFrameWindow = pFrameWindow->mpFrameData->mpNextFrame;
     }
@@ -1014,9 +948,6 @@ void Window::ImplInsertWindow( Window* p
         mpFrame         = pFrameParent->mpFrame;
         mpFrameWindow   = pFrameParent;
         mbFrame         = FALSE;
-#ifdef REMOTE_APPSERVER
-        mpGraphics      = mpFrameWindow->mpGraphics;
-#endif
 
         // search overlap window and insert window in list
         if ( ImplIsOverlapWindow() )
@@ -1100,11 +1031,7 @@ void Window::ImplRemoveWindow( BOOL bRem
     if ( bRemoveFrameData )
     {
         // Graphic freigeben
-#ifndef REMOTE_APPSERVER
         ImplReleaseGraphics();
-#else
-        ImplReleaseServerGraphics();
-#endif
     }
 }
 
@@ -1321,6 +1262,8 @@ ImplWinData* Window::ImplGetWinData() co
 {
     if ( !mpWinData )
     {
+        static const char* pNoNWF = getenv( "SAL_NO_NWF" );
+
         ((Window*)this)->mpWinData = new ImplWinData;
         mpWinData->mpExtOldText     = NULL;
         mpWinData->mpExtOldAttrAry  = NULL;
@@ -1329,14 +1272,17 @@ ImplWinData* Window::ImplGetWinData() co
         mpWinData->mpFocusRect      = NULL;
         mpWinData->mpTrackRect      = NULL;
         mpWinData->mnTrackFlags     = 0;
-    }
+        mpWinData->mnIsTopWindow	= (USHORT) ~0;  // not initialized yet, 0/1 will indicate TopWindow (see IsTopWindow())
+        mpWinData->mbMouseOver      = FALSE;
+        mpWinData->mbEnableNativeWidget = (pNoNWF && *pNoNWF) ? FALSE : TRUE; // TRUE: try to draw this control with native theme API
+        mpWinData->mpSalControlHandle  = NULL;
+   }
 
     return mpWinData;
 }
 
 // -----------------------------------------------------------------------
 
-#ifndef REMOTE_APPSERVER
 SalGraphics* Window::ImplGetFrameGraphics() const
 {
     if ( mpFrameWindow->mpGraphics )
@@ -1346,7 +1292,6 @@ SalGraphics* Window::ImplGetFrameGraphic
     mpFrameWindow->mpGraphics->ResetClipRegion();
     return mpFrameWindow->mpGraphics;
 }
-#endif
 
 // -----------------------------------------------------------------------
 
@@ -1398,13 +1343,11 @@ Window* Window::ImplFindWindow( const Po
 USHORT Window::ImplHitTest( const Point& rFramePos )
 {
     Point aFramePos( rFramePos );
-#ifndef REMOTE_APPSERVER
     if( ImplHasMirroredGraphics() && !IsRTLEnabled() )
     {
         // - RTL - re-mirror frame pos at this window
         ImplReMirror( aFramePos );
     }
-#endif
     Rectangle aRect( Point( mnOutOffX, mnOutOffY ), Size( mnOutWidth, mnOutHeight ) );
     if ( !aRect.IsInside( aFramePos ) )
         return 0;
@@ -1737,7 +1680,6 @@ void Window::ImplLogicToPoint( Font& rFo
 
 // -----------------------------------------------------------------------
 
-#ifndef REMOTE_APPSERVER
 BOOL Window::ImplSysObjClip( const Region* pOldRegion )
 {
     BOOL bUpdate = TRUE;
@@ -1862,14 +1804,11 @@ void Window::ImplUpdateSysObjClip()
         mpFrameWindow->ImplUpdateSysObjOverlapsClip();
 }
 
-#endif
-
 // -----------------------------------------------------------------------
 
 BOOL Window::ImplSetClipFlagChilds( BOOL bSysObjOnlySmaller )
 {
     BOOL bUpdate = TRUE;
-#ifndef REMOTE_APPSERVER
     if ( mpSysObj )
     {
         Region* pOldRegion = NULL;
@@ -1898,7 +1837,6 @@ BOOL Window::ImplSetClipFlagChilds( BOOL
             delete pOldRegion;
     }
     else
-#endif
     {
     mbInitClipRegion = TRUE;
     mbInitWinClipRegion = TRUE;
@@ -2384,14 +2322,12 @@ void Window::ImplCallPaint( const Region
             Region      aPaintRegion( maInvalidateRegion );
             Rectangle   aPaintRect = aPaintRegion.GetBoundRect();
 
-#ifndef REMOTE_APPSERVER
             // - RTL - re-mirror paint rect and region at this window
 		    if( ImplHasMirroredGraphics() && !IsRTLEnabled() )
             {
                 ImplReMirror( aPaintRect );
                 ImplReMirror( aPaintRegion );
             }
-#endif
             aPaintRect = ImplDevicePixelToLogic( aPaintRect);
             mpPaintRegion = &aPaintRegion;
             maInvalidateRegion.SetEmpty();
@@ -2904,7 +2840,6 @@ void Window::ImplScroll( const Rectangle
                 InvertTracking( *(mpWinData->mpTrackRect), mpWinData->mnTrackFlags );
         }
 
-#ifndef REMOTE_APPSERVER
         SalGraphics* pGraphics = ImplGetFrameGraphics();
         if ( pGraphics )
         {
@@ -2920,17 +2855,6 @@ void Window::ImplScroll( const Rectangle
                                  rRect.GetWidth(), rRect.GetHeight(),
                                  SAL_COPYAREA_WINDOWINVALIDATE, this );
         }
-#else
-        ImplServerGraphics* pGraphics = ImplGetServerGraphics( TRUE );
-        if ( pGraphics )
-        {
-            pGraphics->SetClipRegion( aRegion );
-            pGraphics->CopyArea( rRect.Left()+nHorzScroll, rRect.Top()+nVertScroll,
-                                 rRect.Left(), rRect.Top(),
-                                 rRect.GetWidth(), rRect.GetHeight(),
-                                 COPYAREA_WINDOWINVALIDATE );
-        }
-#endif
 
         if ( mpWinData )
         {
@@ -2974,12 +2898,8 @@ void Window::ImplScroll( const Rectangle
                 pWindow->maPos.X()  += nHorzScroll;
                 pWindow->mnY        += nVertScroll;
                 pWindow->maPos.Y()  += nVertScroll;
-#ifndef REMOTE_APPSERVER
                 if ( pWindow->ImplUpdatePos() )
                     pWindow->ImplUpdateSysObjPos();
-#else
-                pWindow->ImplUpdatePos();
-#endif
                 if ( pWindow->IsReallyVisible() )
                     pWindow->ImplSetClipFlag();
                 if ( pWindow->mpClientWindow )
@@ -3045,12 +2965,7 @@ void Window::ImplUpdateWindowPtr( Window
     if ( mpFrameWindow != pWindow->mpFrameWindow )
     {
         // Graphic freigeben
-#ifndef REMOTE_APPSERVER
         ImplReleaseGraphics();
-#else
-        ImplReleaseServerGraphics();
-        mpGraphics = pWindow->mpFrameWindow->mpGraphics;
-#endif
     }
 
     mpFrameData     = pWindow->mpFrameData;
@@ -3092,12 +3007,8 @@ void Window::ImplUpdateOverlapWindowPtr(
     ImplInsertWindow( ImplGetParent() );
     mpRealParent = pRealParent;
     ImplUpdateWindowPtr();
-#ifndef REMOTE_APPSERVER
     if ( ImplUpdatePos() )
         ImplUpdateSysObjPos();
-#else
-    ImplUpdatePos();
-#endif
 
     if ( bNewFrame )
     {
@@ -3141,17 +3052,14 @@ BOOL Window::ImplUpdatePos()
         pChild = pChild->mpNext;
     }
 
-#ifndef REMOTE_APPSERVER
     if ( mpSysObj )
         bSysChild = TRUE;
-#endif
 
     return bSysChild;
 }
 
 // -----------------------------------------------------------------------
 
-#ifndef REMOTE_APPSERVER
 void Window::ImplUpdateSysObjPos()
 {
     if ( mpSysObj )
@@ -3164,8 +3072,6 @@ void Window::ImplUpdateSysObjPos()
         pChild = pChild->mpNext;
     }
 }
-#endif
-
 // -----------------------------------------------------------------------
 
 void Window::ImplPosSizeWindow( long nX, long nY,
@@ -3199,12 +3105,14 @@ void Window::ImplPosSizeWindow( long nX,
             bCopyBits = TRUE;
     }
 
+    BOOL bnXRecycled = FALSE; // avoid duplicate mirroring in RTL case
     if ( nFlags & WINDOW_POSSIZE_WIDTH )
     {
         if(!( nFlags & WINDOW_POSSIZE_X ))
         {
             nX = mnX;
             nFlags |= WINDOW_POSSIZE_X;
+            bnXRecycled = TRUE; // we're using a mnX which was already mirrored in RTL case
         }
 
         if ( nWidth < 0 )
@@ -3235,22 +3143,19 @@ void Window::ImplPosSizeWindow( long nX,
         //if ( nX != mnX )
 		// --- RTL ---  (compare the screen coordinates)
 		Point aPtDev( Point( nX+mnOutOffX, 0 ) );
-#ifndef REMOTE_APPSERVER
 		if( ImplHasMirroredGraphics() )
         {
-            ((SalGraphicsLayout*)mpGraphics)->mirror( aPtDev.X(), this );
+            mpGraphics->mirror( aPtDev.X(), this );
 
-            if( IsRTLEnabled() )
+            // #106948# always mirror our pos if our parent is not mirroring, even
+            // if we are also not mirroring
+            // --- RTL --- check if parent is in different coordinates
+            if( !bnXRecycled && mpParent && !mpParent->mbFrame && mpParent->ImplHasMirroredGraphics() && !mpParent->IsRTLEnabled() )
             {
-                // --- RTL --- check if parent is in different coordinates
-                if( mpParent && !mpParent->mbFrame && mpParent->ImplHasMirroredGraphics() && !mpParent->IsRTLEnabled() )
-                {
-                    // --- RTL --- (re-mirror at parent window)
-                    nX = mpParent->mnOutWidth - mnOutWidth - nX; 
-                }
+                // --- RTL --- (re-mirror at parent window)
+                nX = mpParent->mnOutWidth - mnOutWidth - nX; 
             }
         }
-#endif
         if ( mnAbsScreenX != aPtDev.X() || nX != mnX )  
         {
             if ( bCopyBits && !pOverlapRegion )
@@ -3295,14 +3200,9 @@ void Window::ImplPosSizeWindow( long nX,
 */
     if ( bNewPos || bNewSize )
     {
-#ifndef REMOTE_APPSERVER
         BOOL bUpdateSysObjPos = FALSE;
         if ( bNewPos )
             bUpdateSysObjPos = ImplUpdatePos();
-#else
-        if ( bNewPos )
-            ImplUpdatePos();
-#endif
 
         if ( mpClientWindow )
         {
@@ -3354,9 +3254,7 @@ void Window::ImplPosSizeWindow( long nX,
                 mbCallResize = TRUE;
         }
 
-#ifndef REMOTE_APPSERVER
         BOOL bUpdateSysObjClip = FALSE;
-#endif
         if ( IsReallyVisible() )
         {
             if ( bNewPos || bNewSize )
@@ -3367,11 +3265,7 @@ void Window::ImplPosSizeWindow( long nX,
                 if ( mpFrameData->mpFirstBackWin )
                     ImplInvalidateAllOverlapBackgrounds();
                 // Clip-Flag neu setzen
-#ifndef REMOTE_APPSERVER
                 bUpdateSysObjClip = !ImplSetClipFlag( TRUE );
-#else
-                ImplSetClipFlag();
-#endif
             }
 
             // Fensterinhalt invalidieren ?
@@ -3403,7 +3297,6 @@ void Window::ImplPosSizeWindow( long nX,
                                                                      Size( nOldOutWidth, nOldOutHeight ) ),
                                                           mnOutOffX-nOldOutOffX, mnOutOffY-nOldOutOffY,
                                                           TRUE );
-#ifndef REMOTE_APPSERVER
                             SalGraphics* pGraphics = ImplGetFrameGraphics();
                             if ( pGraphics )
                             {
@@ -3420,19 +3313,6 @@ void Window::ImplPosSizeWindow( long nX,
                             }
                             else
                                 bInvalidate = TRUE;
-#else
-                            ImplServerGraphics* pGraphics = ImplGetServerGraphics( TRUE );
-                            if ( pGraphics )
-                            {
-                                pGraphics->SetClipRegion( aRegion );
-                                pGraphics->CopyArea( mnOutOffX, mnOutOffY,
-                                                     nOldOutOffX, nOldOutOffY,
-                                                     nOldOutWidth, nOldOutHeight,
-                                                     COPYAREA_WINDOWINVALIDATE );
-                            }
-                            else
-                                bInvalidate = TRUE;
-#endif
                             if ( !bInvalidate )
                             {
                                 if ( !pOverlapRegion->IsEmpty() )
@@ -3472,7 +3352,6 @@ void Window::ImplPosSizeWindow( long nX,
             }
         }
 
-#ifndef REMOTE_APPSERVER
         // System-Objekte anpassen
         if ( bUpdateSysObjClip )
             ImplUpdateSysObjClip();
@@ -3480,7 +3359,6 @@ void Window::ImplPosSizeWindow( long nX,
             ImplUpdateSysObjPos();
         if ( bNewSize && mpSysObj )
             mpSysObj->SetPosSize( mnOutOffX, mnOutOffY, mnOutWidth, mnOutHeight );
-#endif
     }
 
     if ( pOverlapRegion )
@@ -3573,7 +3451,6 @@ void Window::ImplToTop( USHORT nFlags )
              !mpFrameData->mbInSysObjFocusHdl &&
              !mpFrameData->mbInSysObjToTopHdl )
         {
-#ifndef REMOTE_APPSERVER
 			// do not bring floating windows on the client to top
 			if( !ImplGetClientWindow() || !(ImplGetClientWindow()->GetStyle() & WB_SYSTEMFLOATWIN) )
 			{
@@ -3586,9 +3463,6 @@ void Window::ImplToTop( USHORT nFlags )
                     nSysFlags = SAL_FRAME_TOTOP_GRABFOCUS_ONLY;
 				mpFrame->ToTop( nSysFlags );
 			}
-#else
-            mpFrame->ToTop( nFlags );
-#endif
         }
     }
     else
@@ -3965,13 +3839,8 @@ void Window::ImplGrabFocus( USHORT nFlag
     }
 
     BOOL bHasFocus = TRUE;
-#ifndef REMOTE_APPSERVER
         if ( !mpSysObj && !mpFrameData->mbHasFocus )
             bHasFocus = FALSE;
-#else
-        if ( !mpFrameData->mbHasFocus )
-            bHasFocus = FALSE;
-#endif
 
     BOOL bMustNotGrabFocus = FALSE;
     // #100242#, check parent hierarchy if some floater prohibits grab focus
@@ -4013,11 +3882,7 @@ void Window::ImplGrabFocus( USHORT nFlag
                 // Hier setzen wir schon den Focus um, da ToTop() den Focus
                 // nicht auf ein anderes Fenster setzen darf
                 //DBG_WARNING( "Window::GrabFocus() - Frame doesn't have the focus" );
-#ifndef REMOTE_APPSERVER
 				mpFrame->ToTop( SAL_FRAME_TOTOP_GRABFOCUS | SAL_FRAME_TOTOP_GRABFOCUS_ONLY );
-#else
-				mpFrame->ToTop(0);
-#endif
                 return;
             }
         }
@@ -4173,14 +4038,12 @@ void Window::ImplGrabFocus( USHORT nFlag
 
         if ( pSVData->maWinData.mpFocusWin == this )
         {
-#ifndef REMOTE_APPSERVER
             if ( mpSysObj )
             {
                 mpFrameData->mpFocusWin = this;
                 if ( !mpFrameData->mbInSysObjFocusHdl )
                     mpSysObj->GrabFocus();
             }
-#endif
 
             if ( pSVData->maWinData.mpFocusWin == this )
             {
@@ -4224,7 +4087,6 @@ void Window::ImplNewInputContext()
 
     pFocusWin->mpFrameData->maOldInputContext = rInputContext;
 
-#ifndef REMOTE_APPSERVER
     SalInputContext         aNewContext;
     const Font&             rFont = rInputContext.GetFont();
     const XubString&        rFontName = rFont.GetName();
@@ -4252,10 +4114,6 @@ void Window::ImplNewInputContext()
 
     if ( pFontEntry )
         pFocusWin->mpFontCache->Release( pFontEntry );
-#else
-    const Font& rFont       = rInputContext.GetFont();
-    pFocusWin->ImplGetFrame()->SetInputContext( rFont, rInputContext.GetOptions() );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -4518,9 +4388,9 @@ Window::~Window()
             else if ( ImplIsOverlapWindow() )
                 pParent = mpOverlapWindow;
 
-            if ( pParent && pParent->IsEnabled() && pParent->IsInputEnabled() )
+            if ( pParent && pParent->IsEnabled() && pParent->IsInputEnabled() ) 
                 pParent->GrabFocus();
-            else
+            else 
                 mpFrameWindow->GrabFocus();
 
             // If the focus was set back to 'this' set it to nothing
@@ -4551,22 +4421,6 @@ Window::~Window()
     if ( pSVData->maWinData.mpLastDeacWin == this )
         pSVData->maWinData.mpLastDeacWin = NULL;
 
-#ifdef REMOTE_APPSERVER
-    {
-    // Events als ungueltig markieren...
-    vos::OGuard aGuard( pSVData->mpWindowObjectMutex );
-    if ( mpRmEvents )
-    {
-        ExtRmEvent* p = mpRmEvents;
-        while ( p )
-        {
-            p->MarkInvalid();
-            p = p->GetNextWindowEvent();
-        }
-    }
-    }
-#endif
-
     if ( mbFrame )
     {
         if ( mpFrameData->mnFocusId )
@@ -4576,11 +4430,7 @@ Window::~Window()
     }
 
     // Graphic freigeben
-#ifndef REMOTE_APPSERVER
     ImplReleaseGraphics();
-#else
-    ImplReleaseServerGraphics();
-#endif
 
     // Evt. anderen Funktion mitteilen, das das Fenster geloescht
     // wurde
@@ -4608,9 +4458,13 @@ Window::~Window()
             delete mpWinData->mpFocusRect;
         if ( mpWinData->mpTrackRect )
             delete mpWinData->mpTrackRect;
+        // Native widget support
+        delete mpWinData->mpSalControlHandle;
+        mpWinData->mpSalControlHandle = NULL;
         delete mpWinData;
     }
 
+
     // Overlap-Window-Daten loeschen
     if ( mpOverlapData )
     {
@@ -4631,18 +4485,9 @@ Window::~Window()
                 pSysWin = pSysWin->mpFrameData->mpNextFrame;
             pSysWin->mpFrameData->mpNextFrame = mpFrameData->mpNextFrame;
         }
-#ifndef REMOTE_APPSERVER
         mpFrame->SetCallback( NULL, NULL );
         pSVData->mpDefInst->DestroyFrame( mpFrame );
-#else
-        REF( NMSP_CLIENT::XRmOutputDevice ) aTmp;
-        mpGraphics->SetInterface( aTmp );
-        delete mpFrame;
-#endif
         delete mpFrameData;
-#ifdef REMOTE_APPSERVER
-        delete mpGraphics;
-#endif
     }
 
     if ( mpChildClipRegion )
@@ -4895,8 +4759,30 @@ void Window::DataChanged( const DataChan
 
 // -----------------------------------------------------------------------
 
-void Window::ImplNotifyKeyMouseEventListeners( NotifyEvent& rNEvt )
+void Window::ImplNotifyKeyMouseCommandEventListeners( NotifyEvent& rNEvt )
 {
+    if( rNEvt.GetType() == EVENT_COMMAND )
+    {
+        const CommandEvent* pCEvt = rNEvt.GetCommandEvent();
+        if ( pCEvt->GetCommand() != COMMAND_CONTEXTMENU )
+            // non context menu events are not to be notified up the chain
+            // so we return immediately
+            return;
+
+        if ( mbCompoundControl || ( rNEvt.GetWindow() == this ) )
+        {
+            if ( rNEvt.GetWindow() == this )
+                // not interested in: The event listeners are already called in ::Command,
+                // and calling them here a second time doesn't make sense
+                ;
+            else
+            {
+                CommandEvent aCommandEvent = ImplTranslateCommandEvent( *pCEvt, rNEvt.GetWindow(), this );
+                ImplCallEventListeners( VCLEVENT_WINDOW_COMMAND, &aCommandEvent );
+            }
+        }
+    }
+
     // #82968# notify event listeners for mouse and key events seperately and
     // not in PreNotify ( as for focus listeners )
     // this allows for procesing those events internally first and pass it to
@@ -4965,7 +4851,7 @@ void Window::ImplNotifyKeyMouseEventList
     {
         if( pParent->IsCompoundControl() )
         {
-            pParent->ImplNotifyKeyMouseEventListeners( rNEvt );
+            pParent->ImplNotifyKeyMouseCommandEventListeners( rNEvt );
             break;
         }
         pParent = pParent->ImplGetParent();
@@ -5011,7 +4897,7 @@ long Window::PreNotify( NotifyEvent& rNE
                 ImplCallEventListeners( VCLEVENT_WINDOW_LOSEFOCUS );
         }
 
-        // #82968# mouse and key events will be notified after processing ( in ImplNotifyKeyMouseEventListeners() )!
+        // #82968# mouse and key events will be notified after processing ( in ImplNotifyKeyMouseCommandEventListeners() )!
         //    see also ImplHandleMouseEvent(), ImplHandleKey()
 
         /*
@@ -5219,7 +5105,6 @@ BOOL Window::PostUserEvent( ULONG& rEven
     pSVEvent->mbCall    = TRUE;
     ImplAddDel( &(pSVEvent->maDelData) );
     rEventId = (ULONG)pSVEvent;
-#ifndef REMOTE_APPSERVER
     if ( mpFrame->PostEvent( pSVEvent ) )
         return TRUE;
     else
@@ -5229,11 +5114,6 @@ BOOL Window::PostUserEvent( ULONG& rEven
         delete pSVEvent;
         return FALSE;
     }
-#else
-    ExtRmEvent* pEvt = new ExtRmEvent( RMEVENT_USEREVENT, NULL, pSVEvent );
-    ImplPostEvent( pEvt );
-    return TRUE;
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -5250,7 +5130,6 @@ BOOL Window::PostUserEvent( ULONG& rEven
     pSVEvent->mbCall    = TRUE;
     ImplAddDel( &(pSVEvent->maDelData) );
     rEventId = (ULONG)pSVEvent;
-#ifndef REMOTE_APPSERVER
     if ( mpFrame->PostEvent( pSVEvent ) )
         return TRUE;
     else
@@ -5260,11 +5139,6 @@ BOOL Window::PostUserEvent( ULONG& rEven
         delete pSVEvent;
         return FALSE;
     }
-#else
-    ExtRmEvent* pEvt = new ExtRmEvent( RMEVENT_USEREVENT, NULL, pSVEvent );
-    ImplPostEvent( pEvt );
-    return TRUE;
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -5533,10 +5407,6 @@ void Window::SetCursorRect( const Rectan
 
     pWinData->mnCursorExtWidth = nExtTextInputWidth;
 
-#ifdef REMOTE_APPSERVER
-    // update remote cursor pos
-    ImplUpdateCursorRect( this );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -5682,7 +5552,7 @@ Font Window::GetPointFont() const
 
 // -----------------------------------------------------------------------
 
-void Window::GetFontResolution( long& nDPIX, long& nDPIY ) const
+void Window::GetFontResolution( sal_Int32& nDPIX, sal_Int32& nDPIY ) const
 {
     DBG_CHKTHIS( Window, ImplDbgCheckWindow );
 
@@ -5878,6 +5748,28 @@ Region Window::GetPaintRegion() const
 
 // -----------------------------------------------------------------------
 
+void Window::ExpandPaintClipRegion( const Region& rRegion )
+{
+    if( mpPaintRegion )
+    {
+        Region aPixRegion = LogicToPixel( rRegion );
+        Region aDevPixRegion = ImplPixelToDevicePixel( aPixRegion );
+
+        Region aWinChildRegion = *ImplGetWinChildClipRegion();
+        // --- RTL -- only this region is in frame coordinates, so re-mirror it
+        if( ImplHasMirroredGraphics() && !IsRTLEnabled() )
+            ImplReMirror( aWinChildRegion );
+        aDevPixRegion.Intersect( aWinChildRegion );
+        if( ! aDevPixRegion.IsEmpty() )
+        {
+            mpPaintRegion->Union( aDevPixRegion );
+            mbInitClipRegion = TRUE;
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
 void Window::SetParent( Window* pNewParent )
 {
     DBG_CHKTHIS( Window, ImplDbgCheckWindow );
@@ -5942,12 +5834,8 @@ void Window::SetParent( Window* pNewPare
     if ( mnParentClipMode & PARENTCLIPMODE_CLIP )
         pNewParent->mbClipChildren = TRUE;
     ImplUpdateWindowPtr();
-#ifndef REMOTE_APPSERVER
     if ( ImplUpdatePos() )
         ImplUpdateSysObjPos();
-#else
-    ImplUpdatePos();
-#endif
 
     // Wenn sich das Overlap-Window geaendert hat, dann muss getestet werden,
     // ob auch OverlapWindow die das Child-Fenster als Parent gehabt haben
@@ -6092,6 +5980,13 @@ void Window::Show( BOOL bVisible, USHORT
     }
     else
     {
+        // inherit native widget flag for form controls
+        // required here, because frames never show up in the child hierarchy - which should be fixed....
+        // eg, the drop down of a combobox which is a system floating window
+        if( mbFrame && GetParent() && GetParent()->IsCompoundControl() &&
+            GetParent()->IsNativeWidgetEnabled() != IsNativeWidgetEnabled() )
+            EnableNativeWidget( GetParent()->IsNativeWidgetEnabled() );
+
         if ( mbCallMove )
         {
             ImplCallMove();
@@ -6231,8 +6126,8 @@ Size Window::GetSizePixel() const
                  mnOutHeight+mnTopBorder+mnBottomBorder );
 }
 
-void Window::GetBorder( long& rLeftBorder, long& rTopBorder,
-                               long& rRightBorder, long& rBottomBorder ) const
+void Window::GetBorder( sal_Int32& rLeftBorder, sal_Int32& rTopBorder,
+                               sal_Int32& rRightBorder, sal_Int32& rBottomBorder ) const
 {
     rLeftBorder     = mnLeftBorder;
     rTopBorder      = mnTopBorder;
@@ -6274,10 +6169,8 @@ void Window::Enable( BOOL bEnable, BOOL 
     if ( mbDisabled != !bEnable )
     {
         mbDisabled = !bEnable;
-#ifndef REMOTE_APPSERVER
         if ( mpSysObj )
             mpSysObj->Enable( bEnable && !mbInputDisabled );
-#endif
 //      if ( mbFrame )
 //          mpFrame->Enable( bEnable && !mbInputDisabled );
         StateChanged( STATE_CHANGE_ENABLE );
@@ -6329,10 +6222,8 @@ void Window::EnableInput( BOOL bEnable, 
         if ( mbInputDisabled != !bEnable )
         {
             mbInputDisabled = !bEnable;
-#ifndef REMOTE_APPSERVER
             if ( mpSysObj )
                 mpSysObj->Enable( !mbDisabled && bEnable );
-#endif
 //          if ( mbFrame )
 //              mpFrame->Enable( !mbDisabled && bEnable );
         }
@@ -6697,7 +6588,6 @@ void Window::SetPosSizePixel( long nX, l
     if ( pWindow->mbFrame )
     {
         long nOldWidth  = pWindow->mnOutWidth;
-        long nOldHeight = pWindow->mnOutHeight;
 
         if ( !(nFlags & WINDOW_POSSIZE_WIDTH) )
             nWidth = pWindow->mnOutWidth;
@@ -6705,7 +6595,6 @@ void Window::SetPosSizePixel( long nX, l
             nHeight = pWindow->mnOutHeight;
 
 
-#ifndef REMOTE_APPSERVER
         USHORT nSysFlags=0;
         if( nFlags & WINDOW_POSSIZE_WIDTH )
             nSysFlags |= SAL_FRAME_POSSIZE_WIDTH;
@@ -6751,9 +6640,7 @@ void Window::SetPosSizePixel( long nX, l
         if( nFlags & WINDOW_POSSIZE_Y )
             nSysFlags |= SAL_FRAME_POSSIZE_Y;
         pWindow->mpFrame->SetPosSize( nX, nY, nWidth, nHeight, nSysFlags );
-#else
-        pWindow->mpFrame->SetPosSize( nX, nY, nWidth, nHeight, nFlags );
-#endif
+
         // Resize should be called directly. If we havn't
         // set the correct size, we get a second resize from
         // the system with the correct size. This can be happend
@@ -6762,7 +6649,6 @@ void Window::SetPosSizePixel( long nX, l
     }
     else
     {
-
         pWindow->ImplPosSizeWindow( nX, nY, nWidth, nHeight, nFlags );
         if ( IsReallyVisible() )
             ImplGenerateMouseMove();
@@ -6803,6 +6689,44 @@ Point Window::ScreenToOutputPixel( const
 
 // -----------------------------------------------------------------------
 
+long Window::ImplGetUnmirroredOutOffX()
+{
+    // revert mnOutOffX changes that were potentially made in ImplPosSizeWindow
+    long offx = mnOutOffX;
+    if( ImplHasMirroredGraphics() )
+    {
+        if( mpParent && !mpParent->mbFrame && mpParent->ImplHasMirroredGraphics() && !mpParent->IsRTLEnabled() )
+        {
+            if ( !ImplIsOverlapWindow() )
+                offx -= mpParent->mnOutOffX;
+
+            offx = mpParent->mnOutWidth - mnOutWidth - offx;
+
+            if ( !ImplIsOverlapWindow() )
+                offx += mpParent->mnOutOffX;
+
+        }
+    }
+    return offx;
+}
+
+// normalized screen pixel are independent of mirroring
+Point Window::OutputToNormalizedScreenPixel( const Point& rPos ) const
+{       
+    // relative to top level parent
+    long offx = ((Window*) this)->ImplGetUnmirroredOutOffX();
+    return Point( rPos.X()+offx, rPos.Y()+mnOutOffY );
+}
+
+Point Window::NormalizedScreenToOutputPixel( const Point& rPos ) const
+{
+    // relative to top level parent
+    long offx = ((Window*) this)->ImplGetUnmirroredOutOffX();
+    return Point( rPos.X()-offx, rPos.Y()-mnOutOffY );
+}
+
+// -----------------------------------------------------------------------
+
 Point Window::OutputToAbsoluteScreenPixel( const Point& rPos ) const
 {
     // relative to the screen
@@ -7114,12 +7038,7 @@ void Window::Update()
 void Window::Flush()
 {
     DBG_CHKTHIS( Window, ImplDbgCheckWindow );
-
-#ifdef REMOTE_APPSERVER
-    // !!!!!
-#else
     mpFrame->Flush();
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -7128,13 +7047,7 @@ void Window::Sync()
 {
     DBG_CHKTHIS( Window, ImplDbgCheckWindow );
 
-#ifdef REMOTE_APPSERVER
-    // Wir rufen eine syncrone Funktion, um uns zu syncronisieren
-    long nDummy;
-    mpFrame->GetClientSize( nDummy, nDummy );
-#else
     mpFrame->Sync();
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -7303,7 +7216,6 @@ void Window::SetPointerPosPixel( const P
     DBG_CHKTHIS( Window, ImplDbgCheckWindow );
 
     Point aPos = ImplOutputToFrame( rPos );
-#ifndef REMOTE_APPSERVER
     if( ImplHasMirroredGraphics() )
     {
         if( !IsRTLEnabled() )
@@ -7312,9 +7224,8 @@ void Window::SetPointerPosPixel( const P
             ImplReMirror( aPos );
         }
         // mirroring is required here, SetPointerPos bypasses SalGraphics
-        ((SalGraphicsLayout*)mpGraphics)->mirror( aPos.X(), this );
+        mpGraphics->mirror( aPos.X(), this );
     }
-#endif
     mpFrame->SetPointerPos( aPos.X(), aPos.Y() );
 }
 
@@ -7325,6 +7236,21 @@ Point Window::GetPointerPosPixel()
     DBG_CHKTHIS( Window, ImplDbgCheckWindow );
 
     Point aPos( mpFrameData->mnLastMouseX, mpFrameData->mnLastMouseY );
+    if( ImplHasMirroredGraphics() && !IsRTLEnabled() )
+    {
+        // --- RTL --- (re-mirror mouse pos at this window)
+        ImplReMirror( aPos );
+    }
+    return ImplFrameToOutput( aPos );
+}
+
+// -----------------------------------------------------------------------
+
+Point Window::GetLastPointerPosPixel()
+{
+    DBG_CHKTHIS( Window, ImplDbgCheckWindow );
+
+    Point aPos( mpFrameData->mnBeforeLastMouseX, mpFrameData->mnBeforeLastMouseY );
 #ifndef REMOTE_APPSERVER
     if( ImplHasMirroredGraphics() && !IsRTLEnabled() )
     {
@@ -7360,6 +7286,13 @@ ULONG Window::GetCurrentModButtons()
 
 // -----------------------------------------------------------------------
 
+BOOL Window::IsMouseOver()
+{
+    return ImplGetWinData()->mbMouseOver;
+}
+
+// -----------------------------------------------------------------------
+
 void Window::EnterWait()
 {
     DBG_CHKTHIS( Window, ImplDbgCheckWindow );
@@ -7640,11 +7573,7 @@ const SystemEnvData* Window::GetSystemDa
 {
     DBG_CHKTHIS( Window, ImplDbgCheckWindow );
 
-#ifndef REMOTE_APPSERVER
     return mpFrame ? mpFrame->GetSystemData() : NULL;
-#else
-    return NULL;
-#endif
 }
 
 ::com::sun::star::uno::Any Window::GetSystemDataAny() const
@@ -7831,11 +7760,6 @@ Reference< XDragSource > Window::GetDrag
         {
             try
             {
-#ifdef REMOTE_APPSERVER
-                if ( mpFrame->IsValid() ) 
-                    mpFrame->GetDragSourceDropTarget( mpFrameData->mxDragSource, mpFrameData->mxDropTarget );
-#else
-
                 Reference< XMultiServiceFactory > xFactory = vcl::unohelper::GetMultiServiceFactory();
                 if ( xFactory.is() )
                 {
@@ -7859,7 +7783,7 @@ Reference< XDragSource > Window::GetDrag
                         aDragSourceAL[ 0 ] = makeAny( Application::GetDisplayConnection() );
                         aDragSourceAL[ 2 ] = makeAny( vcl::createBmpConverter() );
                         aDropTargetAL[ 0 ] = makeAny( Application::GetDisplayConnection() );
-                        aDropTargetAL[ 1 ] = makeAny( pEnvData->aShellWindow );
+                        aDropTargetAL[ 1 ] = makeAny( (sal_Size)(pEnvData->aShellWindow) );
                         aDropTargetAL[ 2 ] = makeAny( vcl::createBmpConverter() );
 #endif
                         if( aDragSourceSN.getLength() )
@@ -7869,7 +7793,6 @@ Reference< XDragSource > Window::GetDrag
                             mpFrameData->mxDropTarget = Reference< XDropTarget > ( xFactory->createInstanceWithArguments( aDropTargetSN, aDropTargetAL ), UNO_QUERY );
                     }
                 }
-#endif
             }
 
             // createInstance can throw any exception
@@ -7924,10 +7847,6 @@ Reference< XClipboard > Window::GetClipb
         {
             try
             {
-#ifdef REMOTE_APPSERVER
-                if ( mpFrame->IsValid() )
-                    mpFrame->GetFrameInterface()->GetClipboardAndSelection( mpFrameData->mxClipboard, mpFrameData->mxSelection );
-#else
                 Reference< XMultiServiceFactory > xFactory( vcl::unohelper::GetMultiServiceFactory() );
 
                 if( xFactory.is() )
@@ -7951,7 +7870,6 @@ Reference< XClipboard > Window::GetClipb
                     }
 #endif
                 }
-#endif
             }
 
             // createInstance can throw any exception
@@ -7980,11 +7898,6 @@ Reference< XClipboard > Window::GetSelec
         {
             try
             {
-#ifdef REMOTE_APPSERVER
-                if ( mpFrame->IsValid() )
-                    mpFrame->GetFrameInterface()->GetClipboardAndSelection( mpFrameData->mxClipboard, mpFrameData->mxSelection );
-#else
-
                 Reference< XMultiServiceFactory > xFactory( vcl::unohelper::GetMultiServiceFactory() );
 
                 if( xFactory.is() )
@@ -8006,8 +7919,6 @@ Reference< XClipboard > Window::GetSelec
                     mpFrameData->mxSelection = s_xSelection;
 #	endif
                 }
-
-#endif
             }
 
             // createInstance can throw any exception
@@ -8614,7 +8525,6 @@ void Window::DrawSelectionBackground( co
     // colors used for item highlighting
     Color aSelectionBorderCol( GetSettings().GetStyleSettings().GetHighlightColor() );
     Color aSelectionFillCol( aSelectionBorderCol );
-    Color aSelectionMaskCol( aSelectionBorderCol );
 
 	BOOL bDark = GetSettings().GetStyleSettings().GetFaceColor().IsDark();
 	BOOL bBright = GetSettings().GetStyleSettings().GetFaceColor().IsBright();
@@ -8753,14 +8663,15 @@ BOOL Window::IsTopWindow() const
     if( !mbFrame && (!mpBorderWindow || (mpBorderWindow && !mpBorderWindow->mbFrame) ) )
         return FALSE;
 
-    if( mnIsTopWindow == (USHORT)~0)    // still uninitialized
+    ImplGetWinData();
+    if( mpWinData->mnIsTopWindow == (USHORT)~0)    // still uninitialized
     {
         // #113722#, cache result of expensive queryInterface call
         Window *pThisWin = (Window*)this;
         Reference< XTopWindow > xTopWindow( pThisWin->GetComponentInterface(), UNO_QUERY );
-        pThisWin->mnIsTopWindow = xTopWindow.is() ? 1 : 0;
+        pThisWin->mpWinData->mnIsTopWindow = xTopWindow.is() ? 1 : 0;
     }
-    return mnIsTopWindow == 1 ? TRUE : FALSE;
+    return mpWinData->mnIsTopWindow == 1 ? TRUE : FALSE;
 }
 
 void Window::ImplMirrorFramePos( Point &pt ) const
@@ -8826,3 +8737,27 @@ LanguageType Window::GetInputLanguage() 
     return mpFrame->GetInputLanguage();
 }
 
+void Window::EnableNativeWidget( BOOL bEnable )
+{
+    if( bEnable != ImplGetWinData()->mbEnableNativeWidget )
+    {
+        ImplGetWinData()->mbEnableNativeWidget = bEnable;
+        // sometimes the borderwindow is queried, so keep it in sync
+        if( mpBorderWindow )
+            mpBorderWindow->ImplGetWinData()->mbEnableNativeWidget = bEnable;
+    }
+
+    // push down, useful for compound controls
+    Window *pChild = mpFirstChild;
+    while( pChild )
+    {
+        pChild->EnableNativeWidget( bEnable );
+        pChild = pChild->mpNext;
+    }
+}
+
+BOOL Window::IsNativeWidgetEnabled() const
+{
+    return ImplGetWinData()->mbEnableNativeWidget;
+}
+





Index: vcl/source/window/window2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/window2.cxx,v
retrieving revision 1.9
retrieving revision 1.12
diff -u -p -u -r1.9 -r1.12
--- vcl/source/window/window2.cxx	27 Mar 2003 17:58:24 -0000	1.9
+++ vcl/source/window/window2.cxx	3 Feb 2004 11:55:39 -0000	1.12
@@ -59,13 +59,10 @@
  *
  ************************************************************************/
 
-#define _SV_WINDOW_CXX
-
 #include <limits.h>
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALBMP_HXX
 #include <salbmp.hxx>
 #endif
@@ -75,9 +72,6 @@
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
-#else
-#include <rmoutdev.hxx>
-#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
@@ -107,7 +101,7 @@
 #ifndef _SV_ACCESS_HXX
 #include <access.hxx>
 #endif
-#ifndef _POLY_HXX
+#ifndef _TL_POLY_HXX
 #include <tools/poly.hxx>
 #endif
 #ifndef _SV_VIRDEV_HXX
@@ -129,7 +120,7 @@
 #include <scrwnd.hxx>
 #endif
 
-#pragma hdrstop
+
 
 // =======================================================================
 
@@ -140,6 +131,8 @@ DBG_NAMEEX( Window );
 #define IMPL_MAXSAVEBACKSIZE    (640*480)
 #define IMPL_MAXALLSAVEBACKSIZE (800*600*2)
 
+//#define USE_NEW_RTL_IMPLEMENTATION
+
 // =======================================================================
 
 struct ImplFocusDelData : public ImplDelData
@@ -398,7 +391,6 @@ Bitmap Window::SnapShot( BOOL bBorder ) 
         {
             ((Window*)this)->Update();
 
-#ifndef REMOTE_APPSERVER
             if ( bBorder && mbFrame )
             {
                 SalBitmap* pSalBmp = mpFrame->SnapShot();
@@ -411,7 +403,6 @@ Bitmap Window::SnapShot( BOOL bBorder ) 
                     return aBmp;
                 }
             }
-#endif
 
             mpFrameWindow->ImplGetFrameBitmap( Point( mnOutOffX, mnOutOffY ), Size( mnOutWidth, mnOutHeight ), aBmp );
         }
@@ -485,7 +476,6 @@ void Window::Invert( const Rectangle& rR
         return;
     aRect.Justify();
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if ( !mpGraphics )
     {
@@ -505,11 +495,6 @@ void Window::Invert( const Rectangle& rR
     if ( nFlags & INVERT_50 )
         nSalFlags |= SAL_INVERT_50;
     mpGraphics->Invert( aRect.Left(), aRect.Top(), aRect.GetWidth(), aRect.GetHeight(), nSalFlags, this );
-#else
-    ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-    if ( pGraphics )
-        pGraphics->Invert( aRect, nFlags );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -528,7 +513,6 @@ void Window::Invert( const Polygon& rPol
 
     Polygon aPoly( ImplLogicToDevicePixel( rPoly ) );
 
-#ifndef REMOTE_APPSERVER
     // we need a graphics
     if ( !mpGraphics )
     {
@@ -549,11 +533,6 @@ void Window::Invert( const Polygon& rPol
         nSalFlags |= SAL_INVERT_50;
     const SalPoint* pPtAry = (const SalPoint*)aPoly.GetConstPointAry();
     mpGraphics->Invert( nPoints, pPtAry, nSalFlags, this );
-#else
-    ImplServerGraphics* pGraphics = ImplGetServerGraphics();
-    if ( pGraphics )
-        pGraphics->Invert( aPoly, nFlags );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -613,7 +592,6 @@ void Window::InvertTracking( const Recta
         return;
     aRect.Justify();
 
-#ifndef REMOTE_APPSERVER
     SalGraphics* pGraphics;
 
     if ( nFlags & SHOWTRACK_WINDOW )
@@ -665,33 +643,6 @@ void Window::InvertTracking( const Recta
         pGraphics->Invert( aRect.Left(), aRect.Top()+nBorder, nBorder, aRect.GetHeight()-(nBorder*2), SAL_INVERT_50, this );
         pGraphics->Invert( aRect.Right()-nBorder+1, aRect.Top()+nBorder, nBorder, aRect.GetHeight()-(nBorder*2), SAL_INVERT_50, this );
     }
-#else
-    ImplServerGraphics* pGraphics;
-    if ( nFlags & SHOWTRACK_WINDOW )
-    {
-        if ( !IsDeviceOutputNecessary() )
-            return;
-
-        pGraphics = ImplGetServerGraphics();
-    }
-    else
-    {
-        pGraphics = ImplGetServerGraphics( TRUE );
-
-        if ( nFlags & SHOWTRACK_CLIP )
-        {
-            Point aTmpPoint( mnOutOffX, mnOutOffY );
-            Size aTmpSize( mnOutWidth, mnOutHeight );
-            Rectangle aTmpRect( aTmpPoint, aTmpSize );
-            Region aRegion( aTmpRect );
-            ImplClipBoundaries( aRegion, FALSE, FALSE );
-            pGraphics->SetClipRegion( aRegion );
-        }
-    }
-
-    if ( pGraphics )
-        pGraphics->InvertTracking( aRect, nFlags );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -707,7 +658,6 @@ void Window::InvertTracking( const Polyg
 
     Polygon aPoly( ImplLogicToDevicePixel( rPoly ) );
 
-#ifndef REMOTE_APPSERVER
     SalGraphics* pGraphics;
 
     if ( nFlags & SHOWTRACK_WINDOW )
@@ -746,33 +696,6 @@ void Window::InvertTracking( const Polyg
 
     const SalPoint* pPtAry = (const SalPoint*)aPoly.GetConstPointAry();
     pGraphics->Invert( nPoints, pPtAry, SAL_INVERT_TRACKFRAME, this );
-#else
-    ImplServerGraphics* pGraphics;
-    if ( nFlags & SHOWTRACK_WINDOW )
-    {
-        if ( !IsDeviceOutputNecessary() )
-            return;
-
-        pGraphics = ImplGetServerGraphics();
-    }
-    else
-    {
-        pGraphics = ImplGetServerGraphics( TRUE );
-
-        if ( nFlags & SHOWTRACK_CLIP )
-        {
-            Point aTmpPoint( mnOutOffX, mnOutOffY );
-            Size aTmpSize( mnOutWidth, mnOutHeight );
-            Rectangle aTmpRect( aTmpPoint, aTmpSize );
-            Region aRegion( aTmpRect );
-            ImplClipBoundaries( aRegion, FALSE, FALSE );
-            pGraphics->SetClipRegion( aRegion );
-        }
-    }
-
-    if ( pGraphics )
-        pGraphics->InvertTracking( aPoly, nFlags );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -787,13 +710,16 @@ IMPL_LINK( Window, ImplTrackTimerHdl, Ti
 
     // Tracking-Event erzeugen
     Point           aMousePos( mpFrameData->mnLastMouseX, mpFrameData->mnLastMouseY );
-#ifndef REMOTE_APPSERVER
     if( ImplHasMirroredGraphics() && !IsRTLEnabled() )
     {
         // - RTL - re-mirror frame pos at pChild
+#ifdef USE_NEW_RTL_IMPLEMENTATION
+        Window *pRefWindow = (Window*) mpDummy4;
+        pRefWindow->ImplReMirror( aMousePos );
+#else
         ImplReMirror( aMousePos );
-    }
 #endif
+    }
     MouseEvent      aMEvt( ImplFrameToOutput( aMousePos ),
                            mpFrameData->mnClickCount, 0,
                            mpFrameData->mnMouseCode, mpFrameData->mnMouseCode );
@@ -863,8 +789,15 @@ void Window::EndTracking( USHORT nFlags 
         {
             Point           aMousePos( mpFrameData->mnLastMouseX, mpFrameData->mnLastMouseY );
             if( ImplHasMirroredGraphics() && !IsRTLEnabled() )
+            {
                 // - RTL - re-mirror frame pos at pChild
+#ifdef USE_NEW_RTL_IMPLEMENTATION
+                Window *pRefWindow = (Window*) mpDummy4;
+                pRefWindow->ImplReMirror( aMousePos );
+#else
                 ImplReMirror( aMousePos );
+#endif
+            }
 
             MouseEvent      aMEvt( ImplFrameToOutput( aMousePos ),
                                    mpFrameData->mnClickCount, 0,
@@ -948,7 +881,6 @@ void Window::SaveBackground( const Point
         {
             const Region    aOldClip( rSaveDevice.GetClipRegion() );
             const Point     aPixOffset( rSaveDevice.LogicToPixel( rDestOff ) );
-            const Point     aPixTopLeft( aClip.GetBoundRect().TopLeft() );
             const BOOL      bMap = rSaveDevice.IsMapModeEnabled();
 
             // move clip region to have the same distance to DestOffset
Index: vcl/source/window/window3.cxx
===================================================================
RCS file: vcl/source/window/window3.cxx
diff -N vcl/source/window/window3.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/source/window/window3.cxx	10 May 2004 15:51:43 -0000	1.2
@@ -0,0 +1,260 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#define _SV_WINDOW_CXX
+
+#ifndef _SV_SVSYS_HXX
+#include <svsys.h>
+#endif
+
+#ifndef _SV_WINDOW_H
+#include <window.h>
+#endif
+#ifndef _SV_WINDOW_HXX
+#include <window.hxx>
+#endif
+
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
+#ifndef _SV_NATIVEWIDGETS_HXX
+#include <salnativewidgets.hxx>
+#endif
+#ifndef _SV_SALCTRLHANDLE_HXX
+#include <salctrlhandle.hxx>
+#endif
+#ifndef _RTL_USTRING_HXX_
+#include <rtl/ustring.hxx>
+#endif
+
+using namespace rtl;
+
+// -----------------------------------------------------------------------
+// These functions are mainly passthrough functions that allow access to
+// the SalFrame behind a Window object for native widget rendering purposes.
+// -----------------------------------------------------------------------
+
+void Window::ImplInitSalControlHandle()
+{
+    // create SalControlHandle on demand
+    // not needed for ordinary windows
+    // TODO: move creation to SalGraphics
+    //if( !ImplGetWinData()->mpSalControlHandle )
+    //    ImplGetWinData()->mpSalControlHandle = new SalControlHandle;
+}
+
+// -----------------------------------------------------------------------
+
+BOOL Window::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    return( mpGraphics->IsNativeControlSupported(nType, nPart) );
+}
+
+
+// -----------------------------------------------------------------------
+
+BOOL Window::HitTestNativeControl( ControlType nType,
+                              ControlPart nPart,
+                              const Region& rControlRegion,
+                              const Point& aPos,
+                              BOOL& rIsInside )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    ImplInitSalControlHandle();
+    return( mpGraphics->HitTestNativeControl(nType, nPart, rControlRegion, aPos, *ImplGetWinData()->mpSalControlHandle, rIsInside, this ) );
+}
+
+// -----------------------------------------------------------------------
+
+BOOL Window::DrawNativeControl( ControlType nType,
+                            ControlPart nPart,
+                            const Region& rControlRegion,
+                            ControlState nState,
+                            const ImplControlValue& aValue,
+                            OUString aCaption )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if( !IsInPaint() && IsPaintTransparent() )
+    {
+        // only required if called directly (ie, we're not in Paint() ):
+        // force redraw (Paint()) for transparent controls
+        // to trigger a repaint of the background
+        Region aClipRgn( GetClipRegion() );
+        if( !rControlRegion.IsEmpty() )
+            aClipRgn.Intersect( rControlRegion );
+        Invalidate( aClipRgn, INVALIDATE_UPDATE );
+        return TRUE;
+    }
+
+    ImplInitSalControlHandle();
+
+    // make sure the current clip region is initialized correctly
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    if ( mbInitClipRegion )
+        ImplInitClipRegion();
+    if ( mbOutputClipped )
+        return TRUE;
+
+    if ( mbInitLineColor )
+        ImplInitLineColor();
+    if ( mbInitFillColor )
+        ImplInitFillColor();
+
+    // Convert the coordinates from relative to Window-absolute, so we draw
+    // in the correct place in platform code
+    Point aWinOffs;
+    aWinOffs = OutputToScreenPixel( aWinOffs );
+    Region screenRegion( rControlRegion );
+    screenRegion.Move( aWinOffs.X(), aWinOffs.Y());
+
+    Region aTestRegion( GetActiveClipRegion() );
+    aTestRegion.Intersect( rControlRegion );
+    if( aTestRegion == rControlRegion )
+        nState |= CTRL_CACHING_ALLOWED;   // control is not clipped, caching allowed
+    
+    return( mpGraphics->DrawNativeControl(nType, nPart, screenRegion, nState, aValue, *ImplGetWinData()->mpSalControlHandle, aCaption, this ) );
+}
+
+
+// -----------------------------------------------------------------------
+
+BOOL Window::DrawNativeControlText(ControlType nType,
+                            ControlPart nPart,
+                            const Region& rControlRegion,
+                            ControlState nState,
+                            const ImplControlValue& aValue,
+                            OUString aCaption )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    ImplInitSalControlHandle();
+
+    // make sure the current clip region is initialized correctly
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return false;
+
+    if ( mbInitClipRegion )
+        ImplInitClipRegion();
+    if ( mbOutputClipped )
+        return true;
+
+    if ( mbInitLineColor )
+        ImplInitLineColor();
+    if ( mbInitFillColor )
+        ImplInitFillColor();
+
+    // Convert the coordinates from relative to Window-absolute, so we draw
+    // in the correct place in platform code
+    Point aWinOffs;
+    aWinOffs = OutputToScreenPixel( aWinOffs );
+    Region screenRegion( rControlRegion );
+    screenRegion.Move( aWinOffs.X(), aWinOffs.Y());
+
+    return( mpGraphics->DrawNativeControlText(nType, nPart, screenRegion, nState, aValue, *ImplGetWinData()->mpSalControlHandle, aCaption, this ) );
+}
+
+
+// -----------------------------------------------------------------------
+
+BOOL Window::GetNativeControlRegion(  ControlType nType,
+                                ControlPart nPart,
+                                const Region& rControlRegion,
+                                ControlState nState,
+                                const ImplControlValue& aValue,
+                                OUString aCaption,
+                                Region &rNativeBoundingRegion,
+                                Region &rNativeContentRegion )
+{
+    if( !IsNativeWidgetEnabled() )
+        return FALSE;
+
+    if ( !mpGraphics )
+        if ( !ImplGetGraphics() )
+            return FALSE;
+
+    ImplInitSalControlHandle();
+    return( mpGraphics->GetNativeControlRegion(nType, nPart, rControlRegion, nState, aValue,
+                                *ImplGetWinData()->mpSalControlHandle, aCaption, rNativeBoundingRegion,
+                                rNativeContentRegion, this ) );
+}
+
+
+// -----------------------------------------------------------------------
Index: vcl/source/window/winproc.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/winproc.cxx,v
retrieving revision 1.80.46.2
retrieving revision 1.89
diff -u -p -u -r1.80.46.2 -r1.89
--- vcl/source/window/winproc.cxx	15 Jan 2004 12:50:42 -0000	1.80.46.2
+++ vcl/source/window/winproc.cxx	10 May 2004 15:51:57 -0000	1.89
@@ -59,29 +59,30 @@
  *
  ************************************************************************/
 
-#define _SV_WINPROC_CXX
-
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
 
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SALWTYPE_HXX
 #include <salwtype.hxx>
 #endif
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
-#else
-#include <rmwindow.hxx>
-#include <rmevents.hxx>
-#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 #ifndef _INTN_HXX
-#include <tools/intn.hxx>
+//#include <tools/intn.hxx>
+#endif
+
+#ifndef _VCL_I18NHELP_HXX
+#include <i18nhelp.hxx>
+#endif
+#include <unohelp.hxx>
+#ifndef _UNOTOOLS_LOCALEDATAWRAPPER_HXX
+#include <unotools/localedatawrapper.hxx>
 #endif
 
 #define private public
@@ -145,6 +146,9 @@
 #ifndef _SV_SALGDI_HXX
 #include <salgdi.hxx>
 #endif
+#ifndef _SV_MENU_HXX
+#include <menu.hxx>
+#endif
 #undef private
 
 #include <dndlcon.hxx>
@@ -157,7 +161,9 @@
 #include <com/sun/star/awt/MouseEvent.hpp>
 #endif
 
-#pragma hdrstop
+
+
+//#define USE_NEW_RTL_IMPLEMENTATION
 
 
 // =======================================================================
@@ -394,6 +400,9 @@ static BOOL ImplCallCommand( Window* pCh
 
         pChild->mbCommand = FALSE;
         pChild->Command( aCEvt );
+
+        if( !aDelData.IsDelete() )
+            pChild->ImplNotifyKeyMouseCommandEventListeners( aNCmdEvt );
     }
     else
         bPreNotify = TRUE;
@@ -445,6 +454,8 @@ long ImplHandleMouseEvent( Window* pWind
     }
 
     // update frame data
+    pWindow->mpFrameData->mnBeforeLastMouseX = pWindow->mpFrameData->mnLastMouseX;
+    pWindow->mpFrameData->mnBeforeLastMouseY = pWindow->mpFrameData->mnLastMouseY;
     pWindow->mpFrameData->mnLastMouseX = nX;
     pWindow->mpFrameData->mnLastMouseY = nY;
     pWindow->mpFrameData->mnMouseCode  = nCode;
@@ -500,18 +511,19 @@ long ImplHandleMouseEvent( Window* pWind
     // Ein paar Test ausfuehren und Message abfangen oder Status umsetzen
     if ( pChild )
     {
-#ifndef REMOTE_APPSERVER
         if( pChild->ImplHasMirroredGraphics() && !pChild->IsRTLEnabled() )
         {
             // - RTL - re-mirror frame pos at pChild
+#ifdef USE_NEW_RTL_IMPLEMENTATION
+            Window *pRefWindow = (Window*) pChild->mpDummy4;
+            pRefWindow->ImplReMirror( aMousePos );
+#else
             pChild->ImplReMirror( aMousePos );
-        }
 #endif
+        }
         // no mouse messages to system object windows
-#ifndef REMOTE_APPSERVER
         if ( pChild->mpSysObj )
             return 0;
-#endif
 
         // no mouse messages to disabled windows
         // #106845# if the window was disabed during capturing we have to pass the mouse events to release capturing
@@ -604,29 +616,6 @@ long ImplHandleMouseEvent( Window* pWind
                     {
                         pMouseDownWin->mpFrameData->mbStartDragCalled  = TRUE;
 
-#if 0
-                        /*
-                         * old drag and drop api
-                         */
-
-                        Point aCmdMousePos( pMouseDownWin->mpFrameData->mnFirstMouseX,
-                                            pMouseDownWin->mpFrameData->mnFirstMouseY );
-                        aCmdMousePos = pMouseDownWin->ImplFrameToOutput( aCmdMousePos );
-                        CommandEvent    aCEvt( aCmdMousePos, COMMAND_STARTDRAG, TRUE );
-                        NotifyEvent     aNCmdEvt( EVENT_COMMAND, pMouseDownWin, &aCEvt );
-                        ImplDelData     aDelData;
-                        pMouseDownWin->ImplAddDel( &aDelData );
-                        if ( !ImplCallPreNotify( aNCmdEvt ) )
-                            pMouseDownWin->Command( aCEvt );
-                        if ( aDelData.IsDelete() )
-                            return 1;
-                        pMouseDownWin->ImplRemoveDel( &aDelData );
-#endif
-
-                        /*
-                         * new drag and drop api
-                         */
-
                         // Check if drag source provides it's own recognizer
                         if( pMouseDownWin->mpFrameData->mbInternalDragGestureRecognizer )
                         {                         
@@ -685,6 +674,7 @@ long ImplHandleMouseEvent( Window* pWind
                 ImplDelData aDelData;
                 ImplDelData aDelData2;
                 pWindow->mpFrameData->mbInMouseMove = TRUE;
+                pMouseMoveWin->ImplGetWinData()->mbMouseOver = FALSE;
                 pMouseMoveWin->ImplAddDel( &aDelData );
                 // Durch MouseLeave kann auch dieses Fenster zerstoert
                 // werden
@@ -695,7 +685,7 @@ long ImplHandleMouseEvent( Window* pWind
                     pMouseMoveWin->MouseMove( aMLeaveEvt );
                     // #82968#
                     if( !aDelData.IsDelete() )
-                        aNLeaveEvt.GetWindow()->ImplNotifyKeyMouseEventListeners( aNLeaveEvt );
+                        aNLeaveEvt.GetWindow()->ImplNotifyKeyMouseCommandEventListeners( aNLeaveEvt );
                 }
 
                 pWindow->mpFrameData->mpMouseMoveWin = NULL;
@@ -716,6 +706,8 @@ long ImplHandleMouseEvent( Window* pWind
             nMode |= MOUSE_ENTERWINDOW;
         }
         pWindow->mpFrameData->mpMouseMoveWin = pChild;
+        if( pChild )
+            pChild->ImplGetWinData()->mbMouseOver = TRUE;
 
         // MouseLeave
         if ( !pChild )
@@ -770,7 +762,6 @@ long ImplHandleMouseEvent( Window* pWind
     MouseEvent aMEvt( aChildPos, nClicks, nMode, nCode, nCode );
 
     // tracking window gets the mouse events
-    BOOL bTracking = FALSE;
     if ( pSVData->maWinData.mpTrackWin )
         pChild = pSVData->maWinData.mpTrackWin;
 
@@ -876,7 +867,7 @@ long ImplHandleMouseEvent( Window* pWind
 
         // #82968#
         if ( !aDelData.IsDelete() )
-            aNEvt.GetWindow()->ImplNotifyKeyMouseEventListeners( aNEvt );
+            aNEvt.GetWindow()->ImplNotifyKeyMouseCommandEventListeners( aNEvt );
     }
 
     if ( aDelData.IsDelete() )
@@ -1021,6 +1012,16 @@ static long ImplHandleKey( Window* pWind
             return 1;
     }
 
+    // #i1820# use locale specific decimal separator
+    if( nCode == KEY_DECIMAL )
+    {
+        if( Application::GetSettings().GetMiscSettings().GetEnableLocalizedDecimalSep() )
+        {
+            String aSep( pWindow->GetSettings().GetLocaleDataWrapper().getNumDecimalSep() );
+            nCharCode = (USHORT) aSep.GetChar(0);
+        }
+    }
+
 	BOOL bCtrlF6 = (aKeyCode.GetCode() == KEY_F6) && aKeyCode.IsMod1();
 
     // determine last input time
@@ -1030,12 +1031,8 @@ static long ImplHandleKey( Window* pWind
     if ( nSVEvent == EVENT_KEYINPUT )
     {
 #ifdef DBG_UTIL
-#ifdef REMOTE_APPSERVER
-        if ( aKeyCode.IsShift() && aKeyCode.IsMod2() && (aKeyCode.GetCode() == KEY_D) )
-#else
         // #105224# use Ctrl-Alt-Shift-D, Ctrl-Shift-D must be useable by app
         if ( aKeyCode.IsShift() && aKeyCode.IsMod1() && aKeyCode.IsMod2() && (aKeyCode.GetCode() == KEY_D) )
-#endif
         {
             DBGGUI_START();
             return 1;
@@ -1160,7 +1157,7 @@ static long ImplHandleKey( Window* pWind
         }
         // #82968#
         if( !aDelData.IsDelete() )
-            aNEvt.GetWindow()->ImplNotifyKeyMouseEventListeners( aNEvt );
+            aNEvt.GetWindow()->ImplNotifyKeyMouseCommandEventListeners( aNEvt );
     }
     else
         bPreNotify = TRUE;
@@ -1276,7 +1273,7 @@ static long ImplHandleKey( Window* pWind
             }
             // #82968#
             if( !aDelData.IsDelete() )
-                aNEvt.GetWindow()->ImplNotifyKeyMouseEventListeners( aNEvt );
+                aNEvt.GetWindow()->ImplNotifyKeyMouseCommandEventListeners( aNEvt );
         }
         else
             bPreNotify = TRUE;
@@ -1820,8 +1817,6 @@ IMPL_LINK( Window, ImplAsyncFocusHdl, vo
 
 static void ImplHandleGetFocus( Window* pWindow )
 {
-    ImplSVData* pSVData = ImplGetSVData();
-
     pWindow->mpFrameData->mbHasFocus = TRUE;
 
     // Focus-Events zeitverzoegert ausfuehren, damit bei SystemChildFenstern
@@ -1954,8 +1949,6 @@ static void ImplHandleUserEvent( ImplSVE
 
 // =======================================================================
 
-#ifndef REMOTE_APPSERVER
-
 static USHORT ImplGetMouseMoveMode( SalMouseEvent* pEvent )
 {
     USHORT nMode = 0;
@@ -2037,6 +2030,46 @@ long ImplHandleSalMouseActivate( Window*
 
 // -----------------------------------------------------------------------
 
+static long ImplHandleMenuEvent( Window* pWindow, SalMenuEvent* pEvent, USHORT nEvent )
+{
+    // Find SystemWindow and its Menubar and let it dispatch the command
+    long nRet = 0;
+    Window *pWin = pWindow->mpFirstChild;
+    while ( pWin )
+    {
+        if ( pWin->mbSysWin )
+            break;
+        pWin = pWin->mpNext;
+    }
+    if( pWin )
+    {
+        MenuBar *pMenuBar = ((SystemWindow*) pWin)->GetMenuBar();
+        if( pMenuBar )
+        {
+            switch( nEvent )
+            {
+                case SALEVENT_MENUACTIVATE:
+                    nRet = pMenuBar->HandleMenuActivateEvent( (Menu*) pEvent->mpMenu ) ? 1 : 0;
+                    break;
+                case SALEVENT_MENUDEACTIVATE:
+                    nRet = pMenuBar->HandleMenuDeActivateEvent( (Menu*) pEvent->mpMenu ) ? 1 : 0;
+                    break;
+                case SALEVENT_MENUHIGHLIGHT:
+                    nRet = pMenuBar->HandleMenuHighlightEvent( (Menu*) pEvent->mpMenu, pEvent->mnId ) ? 1 : 0;
+                    break;
+                case SALEVENT_MENUCOMMAND:
+                    nRet = pMenuBar->HandleMenuCommandEvent( (Menu*) pEvent->mpMenu, pEvent->mnId ) ? 1 : 0;
+                    break;
+                default:
+                    break;
+            }
+        }
+    }
+    return nRet;
+}
+
+// -----------------------------------------------------------------------
+
 static void ImplHandleSalKeyMod( Window* pWindow, SalKeyModEvent* pEvent )
 {
     ImplSVData* pSVData = ImplGetSVData();
@@ -2204,6 +2237,13 @@ long ImplWindowFrameProc( void* pInst, S
             ImplHandleSalKeyMod( (Window*)pInst, (SalKeyModEvent*)pEvent );
             break;
 
+        case SALEVENT_MENUACTIVATE:
+        case SALEVENT_MENUDEACTIVATE:
+        case SALEVENT_MENUHIGHLIGHT:
+        case SALEVENT_MENUCOMMAND:
+            nRet = ImplHandleMenuEvent( (Window*)pInst, (SalMenuEvent*)pEvent, nEvent );
+            break;
+
         case SALEVENT_WHEELMOUSE:
             {
             ImplSVData* pSVData = ImplGetSVData();
@@ -2335,212 +2375,3 @@ long ImplWindowFrameProc( void* pInst, S
 
     return nRet;
 }
-
-#else   // => REMOTE_APPSERVER
-
-void ImplUpdateCursorRect( Window *pWindow )
-{
-    RmFrameWindow *pFrame;
-    if( pWindow && ( ( pFrame = pWindow->ImplGetFrame() ) != NULL ) )
-    {
-        if( pFrame->IsInEvtHandler() )
-            return;     // we'll update later
-        Rectangle rRect;
-        long rWidth;
-        pFrame->IsInEvtHandler( true ); // avoid recursion
-        ImplHandleExtTextInputPos( pWindow, rRect, rWidth, 0 );
-        pFrame->IsInEvtHandler( false );
-        pFrame->SetCursorRect( &rRect, rWidth );
-    }
-}
-
-void ImplHandleGeometryChange( Window *pWindow, Rectangle *pRect )
-{
-    if( pWindow && pWindow->ImplGetFrame() && pRect )
-	{
-		pWindow->ImplGetFrame()->maGeometry.nX = pRect->nLeft;
-		pWindow->ImplGetFrame()->maGeometry.nY = pRect->nTop;
-		pWindow->ImplGetFrame()->maGeometry.nWidth = pRect->nRight - pRect->nLeft + 1;
-		pWindow->ImplGetFrame()->maGeometry.nHeight = pRect->nBottom - pRect->nTop + 1;
-		ImplHandleMoveResize( pWindow, pRect->nLeft, pRect->nTop, 
-			pWindow->ImplGetFrame()->maGeometry.nWidth,
-			pWindow->ImplGetFrame()->maGeometry.nHeight );
-	}
-}
-
-void ImplHandleDecorationChange( Window *pWindow, Rectangle *pRect )
-{
-    if( pWindow && pWindow->ImplGetFrame() && pRect )
-	{
-		pWindow->ImplGetFrame()->maGeometry.nLeftDecoration = pRect->nLeft;
-		pWindow->ImplGetFrame()->maGeometry.nTopDecoration = pRect->nTop;
-		pWindow->ImplGetFrame()->maGeometry.nRightDecoration = pRect->nRight;
-		pWindow->ImplGetFrame()->maGeometry.nBottomDecoration = pRect->nBottom;
-	}
-}
-
-void ImplRemoteWindowFrameProc( ExtRmEvent* pEvent )
-{
-    DBG_TESTSOLARMUTEX();
-
-    ImplDelData aDelData;
-    Window *pWindow = pEvent->GetWindow();
-    if( pWindow && pWindow->ImplGetFrame() )
-    {
-        pWindow->ImplAddDel( &aDelData );
-        // disable updates like remote CursorRect
-        pWindow->ImplGetFrame()->IsInEvtHandler( true );
-    }
-
-    ULONG nId = pEvent->GetId();
-    switch ( nId )
-    {
-        case RMEVENT_KEYINPUT:
-        {
-            RmKeyEventData* pData = (RmKeyEventData*)pEvent->GetData();
-            ImplHandleKey( pEvent->GetWindow(), EVENT_KEYINPUT,
-                           pData->nKeyCode, pData->nChar, pData->nCount, TRUE );
-        }
-        break;
-        case RMEVENT_KEYUP:
-        {
-            RmKeyEventData* pData = (RmKeyEventData*)pEvent->GetData();
-            ImplHandleKey( pEvent->GetWindow(), EVENT_KEYUP,
-                           pData->nKeyCode, pData->nChar, 0, TRUE );
-        }
-        break;
-        case RMEVENT_MOUSEBUTTONDOWN:
-        case RMEVENT_MOUSEBUTTONUP:
-        case RMEVENT_MOUSEMOVE:
-        {
-            USHORT nSVEvent;
-            if ( nId == RMEVENT_MOUSEBUTTONDOWN )
-                nSVEvent = EVENT_MOUSEBUTTONDOWN;
-            else if ( nId == RMEVENT_MOUSEBUTTONUP )
-                nSVEvent = EVENT_MOUSEBUTTONUP;
-            else
-                nSVEvent = EVENT_MOUSEMOVE;
-            RmMouseEventData* pData = (RmMouseEventData*)pEvent->GetData();
-            BOOL bMouseLeave = ( pData->nMode & MOUSE_LEAVEWINDOW ) ? TRUE : FALSE;
-            pData->nMode &= ~(MOUSE_ENTERWINDOW|MOUSE_LEAVEWINDOW);
-
-            // Bei MOUSE_MOVE eine Bestaetigung zurueckschicken, damit der
-            // RClient solange verzoegert...
-            // Vorm ImplHandleMouseEvent, falls dort z.B. ein modaler Dialog
-            // aufgemacht wird.
-            if ( nId == RMEVENT_MOUSEMOVE )
-            {
-                DBG_ASSERT( pEvent->GetWindow()->ImplGetFrame(), "RemoteWindowProc: Frame?" );
-                if ( pEvent->GetWindow()->ImplGetFrame() )
-                    pEvent->GetWindow()->ImplGetFrame()->MouseMoveProcessed();
-            }
-
-            ImplHandleMouseEvent( pEvent->GetWindow(), nSVEvent, bMouseLeave,
-                           pData->nX, pData->nY, pData->nSysTime,
-                           pData->nCode, pData->nMode );
-
-        }
-        break;
-        case RMEVENT_PAINT:
-        {
-            Rectangle* pRect = (Rectangle*)pEvent->GetData();
-            ImplHandlePaint( pEvent->GetWindow(), *pRect );
-        }
-        break;
-        case RMEVENT_RESIZE:
-        {
-            Size* pSize = (Size*)pEvent->GetData();
-            ImplHandleResize( pEvent->GetWindow(), pSize->Width(), pSize->Height() );
-        }
-        break;
-        case RMEVENT_USEREVENT:
-        {
-            ImplHandleUserEvent( (ImplSVEvent*)pEvent->GetData() );
-        }
-        break;
-        case RMEVENT_CLOSE:
-        {
-            ImplHandleClose( pEvent->GetWindow() );
-        }
-        break;
-        case RMEVENT_GETFOCUS:
-        {
-            ImplHandleGetFocus( pEvent->GetWindow() );
-        };
-        break;
-        case RMEVENT_LOSEFOCUS:
-        {
-            ImplSVData* pSVData = ImplGetSVData();
-            ULONG nOldFlags;
-			if ( pSVData->maWinData.mpFirstFloat )
-			{
-				nOldFlags = pSVData->maWinData.mpFirstFloat->GetPopupModeFlags();
-				pSVData->maWinData.mpFirstFloat->SetPopupModeFlags( nOldFlags | FLOATWIN_POPUPMODE_NOAPPFOCUSCLOSE );
-			}
-            ImplHandleLoseFocus( pEvent->GetWindow() );
-			if ( pSVData->maWinData.mpFirstFloat )
-				pSVData->maWinData.mpFirstFloat->SetPopupModeFlags( nOldFlags );
-        };
-        break;
-        case RMEVENT_MOUSEWHEEL:
-        {
-            RmMouseWheelEventData* pData = (RmMouseWheelEventData*)pEvent->GetData();
-            ImplHandleWheelEvent( pEvent->GetWindow(),
-                                  pData->nX,
-                                  pData->nY,
-                                  pData->nSysTime,
-                                  pData->nDelta,
-                                  pData->nNotchDelta,
-                                  pData->nScrollLines,
-                                  pData->nCode,
-                                  pData->bHorz );
-        };
-        break;
-        case RMEVENT_STARTEXTTEXTINPUT:
-        {
-            // ???
-        }
-        break;
-        case RMEVENT_EXTTEXTINPUT:
-        {
-            RmExtTextInputData* pData = (RmExtTextInputData*)pEvent->GetData();
-            ImplHandleExtTextInput( pEvent->GetWindow(), pData->nSysTime,
-                                           pData->aText, pData->pTextAttr,
-                                           pData->nCursorPos, pData->nCursorFlags );
-        }
-        break;
-        case RMEVENT_ENDEXTTEXTINPUT:
-        {
-            ImplHandleEndExtTextInput( pEvent->GetWindow() );
-        }
-        break;
-        case RMEVENT_INPUTCONTEXTCHANGE:
-        {
-            LanguageType *pL = (LanguageType*)pEvent->GetData();
-            ImplHandleInputContextChange( pEvent->GetWindow(), *pL );
-        }
-        break;
-		case RMEVENT_GEOMETRYCHANGE:
-		{
-            Rectangle* pRect = (Rectangle*)pEvent->GetData();
-			ImplHandleGeometryChange( pEvent->GetWindow(), pRect );
-		}
-		break;
-		case RMEVENT_DECORATIONCHANGE:
-		{
-            Rectangle* pRect = (Rectangle*)pEvent->GetData();
-			ImplHandleDecorationChange( pEvent->GetWindow(), pRect );
-		}
-		break;
-    }
-
-    if( pWindow && !aDelData.IsDelete() )   // window not deleted ?
-    {
-        pWindow->ImplRemoveDel( &aDelData );
-        // enable updates like remote CursorRect
-        pWindow->ImplGetFrame()->IsInEvtHandler( false );
-        ImplUpdateCursorRect( pWindow );
-    }
-}
-
-#endif
Index: vcl/source/window/wrkwin.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/window/wrkwin.cxx,v
retrieving revision 1.7
retrieving revision 1.11
diff -u -p -u -r1.7 -r1.11
--- vcl/source/window/wrkwin.cxx	11 Apr 2003 17:31:17 -0000	1.7
+++ vcl/source/window/wrkwin.cxx	17 Jun 2004 11:44:01 -0000	1.11
@@ -59,25 +59,19 @@
  *
  ************************************************************************/
 
-#define _SV_WRKWIN_CXX
-
-#ifndef REMOTE_APPSERVER
 #ifndef _SV_SVSYS_HXX
 #include <svsys.h>
 #endif
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
-#else
-#include <rmwindow.hxx>
-#endif
 
 #ifndef _DEBUG_HXX
 #include <tools/debug.hxx>
 #endif
 
 #ifndef _SV_RC_H
-#include <rc.h>
+#include <tools/rc.h>
 #endif
 #ifndef _SV_SVDATA_HXX
 #include <svdata.hxx>
@@ -97,10 +91,9 @@
 #ifndef _SV_OPENGL_HXX
 #include <opengl.hxx>
 #endif
-
-#include <rvp.hxx>
-
-#pragma hdrstop
+#ifndef _SV_SYSDATA_HXX
+#include <sysdata.hxx>
+#endif
 
 // =======================================================================
 
@@ -124,11 +117,6 @@ void WorkWindow::ImplInitData()
 
 void WorkWindow::ImplInit( Window* pParent, WinBits nStyle, SystemParentData* pSystemParentData )
 {
-#ifdef REMOTE_APPSERVER
-    static ::com::sun::star::uno::Any aVoid;
-    DBG_ASSERT( ! pSystemParentData, "SystemParentData not implemented in remote vcl" );
-    ImplInit( pParent, nStyle, aVoid );
-#else
 #if defined WNT
 	/*
 	 * #98153# since SystemParentData typically contains a HWND from
@@ -157,14 +145,12 @@ void WorkWindow::ImplInit( Window* pPare
     }
 
     SetActivateMode( ACTIVATE_MODE_GRABFOCUS );
-#endif
 }
 
 // -----------------------------------------------------------------------
 
 void WorkWindow::ImplInit( Window* pParent, WinBits nStyle, const ::com::sun::star::uno::Any& aSystemWorkWindowToken )
 {
-#ifndef REMOTE_APPSERVER
     if( aSystemWorkWindowToken.hasValue() )
     {
         ::com::sun::star::uno::Sequence< sal_Int8 > aSeq;
@@ -176,26 +162,6 @@ void WorkWindow::ImplInit( Window* pPare
     }
     else
         ImplInit( pParent, nStyle, NULL );
-#else
-    USHORT nFrameStyle = BORDERWINDOW_STYLE_FRAME;
-    if ( nStyle & WB_APP )
-        nFrameStyle |= BORDERWINDOW_STYLE_APP;
-    ImplBorderWindow* pBorderWin  = new ImplBorderWindow( pParent, nStyle, nFrameStyle, aSystemWorkWindowToken );
-    Window::ImplInit( pBorderWin, nStyle & (WB_3DLOOK | WB_CLIPCHILDREN | WB_DIALOGCONTROL), aSystemWorkWindowToken );
-    pBorderWin->mpClientWindow = this;
-    pBorderWin->GetBorder( mnLeftBorder, mnTopBorder, mnRightBorder, mnBottomBorder );
-    mpBorderWindow  = pBorderWin;
-//        mpRealParent    = pParent; // !!! Muesste eigentlich gesetzt werden, aber wegen Fehlern mit dem MenuBar erstmal nicht gesetzt !!!
-
-    if ( nStyle & WB_APP )
-    {
-        ImplSVData* pSVData = ImplGetSVData();
-        DBG_ASSERT( !pSVData->maWinData.mpAppWin, "WorkWindow::WorkWindow(): More than one window with style WB_APP" );
-        pSVData->maWinData.mpAppWin = this;
-    }
-
-    SetActivateMode( ACTIVATE_MODE_GRABFOCUS );
-#endif
 }
 
 // -----------------------------------------------------------------------
@@ -252,7 +218,7 @@ void WorkWindow::ImplLoadRes( const ResI
 {
     SystemWindow::ImplLoadRes( rResId );
 
-    USHORT nShowStyle   = ReadShortRes();
+    ReadShortRes();
     if ( !(rResId.aWinBits & WB_HIDE) && (RSC_WORKWIN == rResId.GetRT()) )
         Show();
 }
@@ -300,7 +266,6 @@ void WorkWindow::StartPresentationMode( 
 
         if ( !(mnPresentationFlags & PRESENTATION_NOFULLSCREEN) )
             ShowFullScreenMode( TRUE );
-#ifndef REMOTE_APPSERVER
         if ( !mbSysChild )
         {
             if ( mnPresentationFlags & PRESENTATION_HIDEALLAPPS )
@@ -309,10 +274,6 @@ void WorkWindow::StartPresentationMode( 
                 ToTop();
             mpFrame->StartPresentation( TRUE );
         }
-#else
-        if ( !mbSysChild )
-            mpFrame->StartPresentation( TRUE, nFlags | PRESENTATION_NOFULLSCREEN | PRESENTATION_NOAUTOSHOW );
-#endif
 
         if ( !(mnPresentationFlags & PRESENTATION_NOAUTOSHOW) )
             Show();
@@ -320,17 +281,12 @@ void WorkWindow::StartPresentationMode( 
     else
     {
         Show( mbPresentationVisible );
-#ifndef REMOTE_APPSERVER
         if ( !mbSysChild )
         {
             mpFrame->StartPresentation( FALSE );
             if ( mnPresentationFlags & PRESENTATION_HIDEALLAPPS )
                 mpFrame->SetAlwaysOnTop( FALSE );
         }
-#else
-        if ( !mbSysChild )
-            mpFrame->StartPresentation( FALSE, mnPresentationFlags | PRESENTATION_NOFULLSCREEN | PRESENTATION_NOAUTOSHOW );
-#endif
         ShowFullScreenMode( mbPresentationFull );
 
         mbPresentationMode      = FALSE;
@@ -366,5 +322,57 @@ BOOL WorkWindow::SetPluginParent( System
     if( bWasDnd )
         Window::ImplStartDnd();
 
+    return bRet;
+}
+
+void WorkWindow::ImplSetFrameState( ULONG aFrameState )
+{
+    Window* pWindow = mpFrameWindow;
+
+    SalFrameState   aState;
+    aState.mnMask   = SAL_FRAMESTATE_MASK_STATE;
+    aState.mnState  = aFrameState; //SAL_FRAMESTATE_MAXIMIZED;
+    mpFrame->SetWindowState( &aState );
+}
+
+
+void WorkWindow::Minimize()
+{
+    ImplSetFrameState( SAL_FRAMESTATE_MINIMIZED );
+}
+
+void WorkWindow::Restore()
+{
+    ImplSetFrameState( SAL_FRAMESTATE_NORMAL );
+}
+
+BOOL WorkWindow::Close()
+{
+    BOOL bCanClose = SystemWindow::Close();
+
+    // Ist es das Applikationsfenster, dann beende die Applikation
+    if ( bCanClose && ( ImplGetSVData()->maWinData.mpAppWin == this ) )
+        GetpApp()->Quit();
+    
+    return bCanClose;
+}
+
+void WorkWindow::Maximize( BOOL bMaximize )
+{
+    ImplSetFrameState( bMaximize ? SAL_FRAMESTATE_MAXIMIZED : SAL_FRAMESTATE_NORMAL );
+}
+
+BOOL WorkWindow::IsMaximized()
+{
+    BOOL bRet = FALSE;
+
+    SalFrameState aState;
+    if( mpFrame->GetWindowState( &aState ) )
+    {
+        if( aState.mnState & (SAL_FRAMESTATE_MAXIMIZED			|
+                              SAL_FRAMESTATE_MAXIMIZED_HORZ		|
+                              SAL_FRAMESTATE_MAXIMIZED_VERT ) )
+            bRet = TRUE;
+    }
     return bRet;
 }
Index: vcl/test/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/test/makefile.mk,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -p -u -r1.3 -r1.4
--- vcl/test/makefile.mk	27 Mar 2003 17:58:29 -0000	1.3
+++ vcl/test/makefile.mk	6 Jan 2004 14:22:48 -0000	1.4
@@ -91,9 +91,6 @@ APP1STDLIBS=	$(CPPULIB)			\
 APP1DEPN=		$(L)$/itools.lib	\
 				$(L)$/sot.lib
 
-.IF "$(remote)"!=""
-EXCEPTIONSFILES= $(OBJ)$/dndtest.obj
-.ENDIF
 
 # --- Targets ------------------------------------------------------
 
Index: vcl/unx/dummy/dbmp.cxx
===================================================================
RCS file: vcl/unx/dummy/dbmp.cxx
diff -N vcl/unx/dummy/dbmp.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/dummy/dbmp.cxx	20 Feb 2004 08:52:40 -0000	1.2
@@ -0,0 +1,226 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <dbmp.hxx>
+#include <bmpacc.hxx>
+
+// -------------
+// - SalBitmap -
+// -------------
+
+DummyBitmap::DummyBitmap() :
+	mpDIB( NULL )
+{
+}
+
+// -----------------------------------------------------------------------------
+
+DummyBitmap::~DummyBitmap()
+{
+	Destroy();
+}
+
+// -----------------------------------------------------------------------------
+
+// -----------------------------------------------------------------------------
+
+BitmapBuffer* DummyBitmap::ImplCreateDIB( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
+{
+	DBG_ASSERT( nBitCount == 1 || nBitCount == 4 || nBitCount == 8 || nBitCount == 24, "Unsupported BitCount!" );
+
+	BitmapBuffer* pDIB;
+
+	if( rSize.Width() && rSize.Height() )
+	{
+		pDIB = new BitmapBuffer;
+
+		if( pDIB )
+		{
+			const USHORT nColors = ( nBitCount <= 8 ) ? ( 1 << nBitCount ) : 0;
+			
+			pDIB->mnFormat = BMP_FORMAT_BOTTOM_UP;
+
+			switch( nBitCount )
+			{
+				case( 1 ): pDIB->mnFormat |= BMP_FORMAT_1BIT_MSB_PAL; break;
+				case( 4 ): pDIB->mnFormat |= BMP_FORMAT_4BIT_MSN_PAL; break;
+				case( 8 ): pDIB->mnFormat |= BMP_FORMAT_8BIT_PAL; break;
+			
+				default:
+					pDIB->mnFormat |= BMP_FORMAT_24BIT_TC_BGR;
+				break;
+			}
+
+			pDIB->mnWidth = rSize.Width();
+			pDIB->mnHeight = rSize.Height();
+			pDIB->mnScanlineSize = AlignedWidth4Bytes( pDIB->mnWidth * nBitCount );
+			pDIB->mnBitCount = nBitCount;
+			
+			if( nColors )
+			{
+				pDIB->maPalette = rPal;
+				pDIB->maPalette.SetEntryCount( nColors );
+			}
+
+			pDIB->mpBits = new BYTE[ pDIB->mnScanlineSize * pDIB->mnHeight ];
+			rtl_zeroMemory( pDIB->mpBits, pDIB->mnScanlineSize * pDIB->mnHeight );
+		}
+	}
+	else
+		pDIB = NULL;
+
+	return pDIB;
+}
+
+// -----------------------------------------------------------------------------
+
+bool DummyBitmap::Create( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
+{
+	Destroy();
+	mpDIB = ImplCreateDIB( rSize, nBitCount, rPal );
+
+	return( mpDIB != NULL );
+}
+
+// -----------------------------------------------------------------------------
+
+bool DummyBitmap::Create( const SalBitmap& rSSalBmp )
+{
+	Destroy();
+
+    const DummyBitmap& rSalBmp = static_cast<const DummyBitmap&>( rSSalBmp );
+
+	if( rSalBmp.mpDIB )
+	{
+		mpDIB = ImplCreateDIB( rSalBmp.GetSize(), rSalBmp.GetBitCount(), rSalBmp.mpDIB->maPalette );
+		
+		if( mpDIB )
+			memcpy( mpDIB->mpBits, rSalBmp.mpDIB->mpBits, mpDIB->mnScanlineSize * mpDIB->mnHeight );
+	}
+	return( ! rSalBmp.mpDIB  || 
+			( rSalBmp.mpDIB && ( mpDIB != NULL ) )
+            );
+}
+
+// -----------------------------------------------------------------------------
+
+bool DummyBitmap::Create( const SalBitmap& rSalBmp, SalGraphics* pGraphics )
+{
+	return FALSE;
+}
+
+// -----------------------------------------------------------------------------
+
+bool DummyBitmap::Create( const SalBitmap& rSalBmp, USHORT nNewBitCount )
+{
+	return FALSE;
+}
+
+// -----------------------------------------------------------------------------
+
+void DummyBitmap::Destroy()
+{
+	if( mpDIB )
+	{
+		delete[] mpDIB->mpBits;
+		delete mpDIB, mpDIB = NULL;
+	}
+}
+
+// -----------------------------------------------------------------------------
+
+Size DummyBitmap::GetSize() const
+{
+	Size aSize;
+
+	if( mpDIB )
+		aSize.Width() = mpDIB->mnWidth, aSize.Height() = mpDIB->mnHeight;
+	
+	return aSize;
+}
+
+// -----------------------------------------------------------------------------
+
+USHORT DummyBitmap::GetBitCount() const
+{
+	USHORT nBitCount;
+
+	if( mpDIB )
+		nBitCount = mpDIB->mnBitCount;
+	else
+		nBitCount = 0;
+
+	return nBitCount;
+}
+
+// -----------------------------------------------------------------------------
+
+BitmapBuffer* DummyBitmap::AcquireBuffer( bool bReadOnly )
+{
+	return mpDIB;
+}
+
+// -----------------------------------------------------------------------------
+
+void DummyBitmap::ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly )
+{
+}
+
Index: vcl/unx/dummy/dbmp.hxx
===================================================================
RCS file: vcl/unx/dummy/dbmp.hxx
diff -N vcl/unx/dummy/dbmp.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/dummy/dbmp.hxx	20 Feb 2004 08:52:50 -0000	1.2
@@ -0,0 +1,110 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_DBMP_HXX
+#define _SV_DBMP_HXX
+
+#ifndef _SV_SALBMP_HXX
+#include <salbmp.hxx>
+#endif
+
+struct	BitmapBuffer;
+class	BitmapPalette;
+class	SalGraphics;
+
+// -------------
+// - SalBitmap -
+// -------------
+
+class DummyBitmap : public SalBitmap
+{
+private:
+
+	static BitmapBuffer*		ImplCreateDIB( const Size& rSize,
+											   USHORT nBitCount, 
+											   const BitmapPalette& rPal );
+	BitmapBuffer*	mpDIB;
+public:
+
+    DummyBitmap();
+    virtual ~DummyBitmap();
+
+    // overload pure virtual methods
+	virtual bool			Create( const Size& rSize, 
+                            USHORT nBitCount, 
+							const BitmapPalette& rPal );
+	virtual bool			Create( const SalBitmap& rSalBmp );
+	virtual bool			Create( const SalBitmap& rSalBmp, 
+                                    SalGraphics* pGraphics );
+	virtual bool			Create( const SalBitmap& rSalBmp,
+                                    USHORT nNewBitCount );
+						
+	virtual void			Destroy();
+						
+	virtual Size			GetSize() const;
+	virtual USHORT			GetBitCount() const;
+						
+	virtual BitmapBuffer*	AcquireBuffer( bool bReadOnly );
+	virtual void			ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly );
+};
+
+#endif // _SV_DBMP_HXX
+
Index: vcl/unx/dummy/dinst.cxx
===================================================================
RCS file: vcl/unx/dummy/dinst.cxx
diff -N vcl/unx/dummy/dinst.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/dummy/dinst.cxx	18 May 2004 10:55:52 -0000	1.3
@@ -0,0 +1,275 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <salinst.hxx>
+#include <dbmp.hxx>
+
+class DummyInstance : public SalInstance
+{
+public:
+    DummyInstance() {}
+    virtual ~DummyInstance();
+
+    virtual SalFrame*      	CreateChildFrame( SystemParentData* pParent, ULONG nStyle );
+    virtual SalFrame*      	CreateFrame( SalFrame* pParent, ULONG nStyle );
+    virtual void				DestroyFrame( SalFrame* pFrame );
+    virtual SalObject*			CreateObject( SalFrame* pParent );
+    virtual void				DestroyObject( SalObject* pObject );
+    virtual SalVirtualDevice*	CreateVirtualDevice( SalGraphics* pGraphics,
+                                                     long nDX, long nDY,
+                                                     USHORT nBitCount );
+    virtual void				DestroyVirtualDevice( SalVirtualDevice* pDevice );
+
+    virtual SalInfoPrinter*	CreateInfoPrinter( SalPrinterQueueInfo* pQueueInfo,
+                                               ImplJobSetup* pSetupData );
+    virtual void				DestroyInfoPrinter( SalInfoPrinter* pPrinter );
+    virtual SalPrinter*		CreatePrinter( SalInfoPrinter* pInfoPrinter );
+    virtual void				DestroyPrinter( SalPrinter* pPrinter );
+
+    virtual void				GetPrinterQueueInfo( ImplPrnQueueList* pList );
+    virtual void				GetPrinterQueueState( SalPrinterQueueInfo* pInfo );
+    virtual void				DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo );
+    virtual String             GetDefaultPrinter();
+
+    virtual SalSound*			CreateSalSound();
+    virtual SalTimer*			CreateSalTimer();
+    virtual SalOpenGL*			CreateSalOpenGL( SalGraphics* pGraphics );
+    virtual SalI18NImeStatus*	CreateI18NImeStatus();
+    virtual SalSystem*			CreateSalSystem();
+    virtual SalBitmap*			CreateSalBitmap();
+    virtual SalSession*			CreateSalSession();
+    virtual vos::IMutex*		GetYieldMutex();
+    virtual ULONG				ReleaseYieldMutex();
+    virtual void				AcquireYieldMutex( ULONG nCount );
+    virtual void				Yield( BOOL bWait );
+    virtual bool				AnyInput( USHORT nType );
+
+                            // Menues
+    virtual SalMenu*        CreateMenu( BOOL bMenuBar );
+    virtual void            DestroyMenu( SalMenu* pMenu);
+    virtual SalMenuItem*    CreateMenuItem( const SalItemParams* pItemData );
+    virtual void            DestroyMenuItem( SalMenuItem* pItem );
+    virtual void*				GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes );
+};
+
+// plugin factory function
+extern "C" 
+{
+    SalInstance* create_SalInstance()
+    {
+        return new DummyInstance();
+    }
+}
+
+
+DummyInstance::~DummyInstance()
+{
+}
+
+SalFrame*			DummyInstance::CreateChildFrame( SystemParentData*, ULONG )
+{
+    return NULL;
+}
+
+SalFrame*			DummyInstance::CreateFrame( SalFrame*, ULONG )
+{
+    return NULL;
+}
+
+void				DummyInstance::DestroyFrame( SalFrame* )
+{
+}
+
+SalObject*			DummyInstance::CreateObject( SalFrame* )
+{
+    return NULL;
+}
+
+void				DummyInstance::DestroyObject( SalObject* )
+{
+}
+
+SalVirtualDevice*	DummyInstance::CreateVirtualDevice( SalGraphics*, long, long, USHORT )
+{
+    return NULL;
+}
+
+void				DummyInstance::DestroyVirtualDevice( SalVirtualDevice* )
+{
+}
+
+SalInfoPrinter*		DummyInstance::CreateInfoPrinter( SalPrinterQueueInfo*, ImplJobSetup* )
+{
+    return NULL;
+}
+
+void				DummyInstance::DestroyInfoPrinter( SalInfoPrinter* )
+{
+}
+
+SalPrinter*			DummyInstance::CreatePrinter( SalInfoPrinter* )
+{
+    return NULL;
+}
+
+void				DummyInstance::DestroyPrinter( SalPrinter* )
+{
+}
+
+void				DummyInstance::GetPrinterQueueInfo( ImplPrnQueueList* )
+{
+}
+
+void				DummyInstance::GetPrinterQueueState( SalPrinterQueueInfo* )
+{
+}
+
+void				DummyInstance::DeletePrinterQueueInfo( SalPrinterQueueInfo* )
+{
+}
+
+String				DummyInstance::GetDefaultPrinter()
+{
+    return String();
+}
+
+SalSound*			DummyInstance::CreateSalSound()
+{
+    return NULL;
+}
+
+SalTimer*			DummyInstance::CreateSalTimer()
+{
+    return NULL;
+}
+
+SalOpenGL*			DummyInstance::CreateSalOpenGL( SalGraphics* )
+{
+    return NULL;
+}
+
+SalI18NImeStatus*	DummyInstance::CreateI18NImeStatus()
+{
+    return NULL;
+}
+
+SalSystem*			DummyInstance::CreateSalSystem()
+{
+    return NULL;
+}
+
+SalBitmap*			DummyInstance::CreateSalBitmap()
+{
+    return new DummyBitmap();
+}
+
+vos::IMutex*		DummyInstance::GetYieldMutex()
+{
+    return NULL;
+}
+
+ULONG				DummyInstance::ReleaseYieldMutex()
+{
+    return 0;
+}
+
+void				DummyInstance::AcquireYieldMutex( ULONG nCount )
+{
+}
+
+void				DummyInstance::Yield( BOOL )
+{
+}
+
+bool				DummyInstance::AnyInput( USHORT )
+{
+    return false;
+}
+
+SalMenu*			DummyInstance::CreateMenu( BOOL )
+{
+    return NULL;
+}
+
+void				DummyInstance::DestroyMenu( SalMenu* )
+{
+}
+
+SalMenuItem*		DummyInstance::CreateMenuItem( const SalItemParams* )
+{
+    return NULL;
+}
+
+void				DummyInstance::DestroyMenuItem( SalMenuItem* )
+{
+}
+
+void*				DummyInstance::GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes )
+{
+    rReturnedType		= Blob;
+    rReturnedBytes		= 0;
+    return NULL;
+}
+
+SalSession*			DummyInstance::CreateSalSession()
+{
+    return NULL;
+}
Index: vcl/unx/dummy/makefile.mk
===================================================================
RCS file: vcl/unx/dummy/makefile.mk
diff -N vcl/unx/dummy/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/dummy/makefile.mk	20 Feb 2004 08:53:14 -0000	1.2
@@ -0,0 +1,94 @@
+#*************************************************************************
+#
+#   
+#
+#   
+#
+#   
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..
+
+PRJNAME=vcl
+TARGET=dapp
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  svpre.mk
+.INCLUDE :  settings.mk
+.INCLUDE :  sv.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(GUIBASE)"!="unx"
+
+dummy:
+	@echo "Nothing to build for GUIBASE $(GUIBASE)"
+
+.ELSE		# "$(GUIBASE)"!="unx"
+
+SLOFILES=\
+			$(SLO)$/dinst.obj\
+			$(SLO)$/dbmp.obj
+
+.ENDIF		# "$(GUIBASE)"!="unx"
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+.INCLUDE :  $(PRJ)$/util$/target.pmk
Index: vcl/unx/gtk/app/gtkdata.cxx
===================================================================
RCS file: vcl/unx/gtk/app/gtkdata.cxx
diff -N vcl/unx/gtk/app/gtkdata.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/app/gtkdata.cxx	2 Jun 2004 14:54:21 -0000	1.7
@@ -0,0 +1,790 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#define _SV_SALDATA_CXX
+
+// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <errno.h>
+#include <poll.h>
+#ifdef FREEBSD
+#include <sys/types.h>
+#include <sys/time.h>
+#include <unistd.h>
+#endif
+
+#ifndef _VCL_GTKDATA_HXX
+#include <plugins/gtk/gtkdata.hxx>
+#endif
+#ifndef _VCL_GTKINST_HXX
+#include <plugins/gtk/gtkinst.hxx>
+#endif
+#ifndef _VCL_GTKFRAME_HXX
+#include <plugins/gtk/gtkframe.hxx>
+#endif
+#ifndef _OSL_THREAD_H_
+#include <osl/thread.h>
+#endif
+#ifndef _OSL_PROCESS_H_
+#include <osl/process.h>
+#endif
+
+#include <tools/debug.hxx>
+
+#ifndef _SAL_I18N_INPUTMETHOD_HXX
+#include "i18n_im.hxx"
+#endif
+#ifndef _SAL_I18N_XKBDEXTENSION_HXX
+#include "i18n_xkb.hxx"
+#endif
+
+#include "../../unx/source/inc/salcursors.h"
+
+using namespace rtl;
+
+/***************************************************************************
+ * class GtkDisplay                                                        *
+ ***************************************************************************/
+
+GtkSalDisplay::GtkSalDisplay( GdkDisplay* pDisplay, Visual* pVis, Colormap aCol ) 
+            : m_pGdkDisplay( pDisplay ),
+              SalDisplay( gdk_x11_display_get_xdisplay( pDisplay ), aCol )
+{
+	for(int i = 0; i < POINTER_COUNT; i++)
+		m_aCursors[ i ] = NULL;
+	Init ( aCol, pVis );
+}
+
+GtkSalDisplay::~GtkSalDisplay()
+{
+    doDestruct();
+
+	for(int i = 0; i < POINTER_COUNT; i++)
+		if( m_aCursors[ i ] )
+			gdk_cursor_unref( m_aCursors[ i ] );
+
+    pDisp_ = NULL;
+}
+
+void GtkSalDisplay::deregisterFrame( SalFrame* pFrame )
+{
+	if( m_pCapture == pFrame )
+	{
+		static_cast<GtkSalFrame*>(m_pCapture)->grabPointer( FALSE );
+		m_pCapture = NULL;
+	}
+    SalDisplay::deregisterFrame( pFrame );
+}
+
+GdkFilterReturn GtkSalDisplay::filterGdkEvent( GdkXEvent* sys_event,
+                                               GdkEvent* event,
+                                               gpointer data )
+{
+    GTK_YIELD_GRAB();
+    
+    GdkFilterReturn aFilterReturn = GDK_FILTER_CONTINUE;
+    
+	XEvent *pEvent = (XEvent *)sys_event;
+	GtkSalDisplay *pDisplay = (GtkSalDisplay *)data;
+
+    if (pDisplay->GetDisplay() == pEvent->xany.display )
+    {
+        // let's see if one of our frames wants to swallow these events
+        // get the frame
+        for( std::list< SalFrame* >::const_iterator it = pDisplay->m_aFrames.begin();
+                 it != pDisplay->m_aFrames.end(); ++it )
+        {
+            GtkSalFrame* pFrame = static_cast<GtkSalFrame*>(*it);
+            if( pFrame->GetSystemData()->aWindow == pEvent->xany.window ||
+                ( pFrame->getForeignParent() && GDK_WINDOW_XWINDOW(pFrame->getForeignParent()) == pEvent->xany.window ) ||
+                ( pFrame->getForeignTopLevel() && GDK_WINDOW_XWINDOW(pFrame->getForeignTopLevel()) == pEvent->xany.window )
+                )
+            {
+                if( ! pFrame->Dispatch( pEvent ) )
+                    aFilterReturn = GDK_FILTER_REMOVE;
+                break;
+            }
+        }
+    }
+
+    return aFilterReturn;
+}
+
+long GtkSalDisplay::Dispatch( XEvent* pEvent )
+{
+    if( GetDisplay() == pEvent->xany.display )
+    {
+        // let's see if one of our frames wants to swallow these events
+        // get the child frame
+        for( std::list< SalFrame* >::const_iterator it = m_aFrames.begin();
+             it != m_aFrames.end(); ++it )
+        {
+            if( (*it)->GetSystemData()->aWindow == pEvent->xany.window )
+                return static_cast<GtkSalFrame*>(*it)->Dispatch( pEvent );
+        }
+    }
+
+    return GDK_FILTER_CONTINUE;
+}
+
+GdkCursor* GtkSalDisplay::getFromXPM( const char *pBitmap,
+									  const char *pMask,
+									  int nWidth, int nHeight,
+									  int nXHot, int nYHot )
+{
+	GdkScreen *pScreen = gdk_display_get_default_screen( m_pGdkDisplay );
+	GdkDrawable *pDrawable = GDK_DRAWABLE( gdk_screen_get_root_window (pScreen) );
+	GdkBitmap *pBitmapPix = gdk_bitmap_create_from_data
+			( pDrawable, pBitmap, nWidth, nHeight );
+	GdkBitmap *pMaskPix = gdk_bitmap_create_from_data
+			( pDrawable, pMask, nWidth, nHeight );
+	GdkColormap *pColormap = gdk_drawable_get_colormap( pDrawable );
+
+	GdkColor aWhite = { 0, 0xffff, 0xffff, 0xffff };
+	GdkColor aBlack = { 0, 0, 0, 0 };
+
+	gdk_colormap_alloc_color( pColormap, &aBlack, FALSE, TRUE);
+	gdk_colormap_alloc_color( pColormap, &aWhite, FALSE, TRUE);
+
+	return gdk_cursor_new_from_pixmap
+			( pBitmapPix, pMaskPix,
+			  &aBlack, &aWhite, nXHot, nYHot);
+}
+
+#define MAKE_CURSOR( vcl_name, name ) \
+	case vcl_name: \
+		pCursor = getFromXPM( name##curs##_bits, name##mask##_bits, \
+							  name##curs_width, name##curs_height, \
+							  name##curs_x_hot, name##curs_y_hot ); \
+		break
+#define MAP_BUILTIN( vcl_name, gdk_name ) \
+		case vcl_name: \
+			pCursor = gdk_cursor_new_for_display( m_pGdkDisplay, gdk_name ); \
+			break
+
+GdkCursor *GtkSalDisplay::getCursor( PointerStyle ePointerStyle )
+{
+    if( ePointerStyle > POINTER_COUNT )
+        return NULL;
+
+	if ( !m_aCursors[ ePointerStyle ] )
+	{
+		GdkCursor *pCursor;
+
+	    switch( ePointerStyle )
+	    {
+			MAP_BUILTIN( POINTER_ARROW, GDK_LEFT_PTR );
+			MAP_BUILTIN( POINTER_TEXT, GDK_XTERM );
+			MAP_BUILTIN( POINTER_HELP, GDK_QUESTION_ARROW );
+			MAP_BUILTIN( POINTER_CROSS, GDK_CROSSHAIR );
+
+			MAP_BUILTIN( POINTER_NSIZE, GDK_SB_V_DOUBLE_ARROW );
+			MAP_BUILTIN( POINTER_SSIZE, GDK_SB_V_DOUBLE_ARROW );
+			MAP_BUILTIN( POINTER_WSIZE, GDK_SB_H_DOUBLE_ARROW );
+			MAP_BUILTIN( POINTER_ESIZE, GDK_SB_H_DOUBLE_ARROW );
+
+			MAP_BUILTIN( POINTER_WINDOW_NSIZE, GDK_TOP_SIDE );
+			MAP_BUILTIN( POINTER_WINDOW_SSIZE, GDK_BOTTOM_SIDE );
+			MAP_BUILTIN( POINTER_WINDOW_WSIZE, GDK_LEFT_SIDE );
+			MAP_BUILTIN( POINTER_WINDOW_ESIZE, GDK_RIGHT_SIDE );
+
+			MAP_BUILTIN( POINTER_WINDOW_NWSIZE, GDK_TOP_LEFT_CORNER );
+			MAP_BUILTIN( POINTER_WINDOW_NESIZE, GDK_TOP_RIGHT_CORNER );
+			MAP_BUILTIN( POINTER_WINDOW_SWSIZE, GDK_BOTTOM_LEFT_CORNER );
+			MAP_BUILTIN( POINTER_WINDOW_SESIZE, GDK_BOTTOM_RIGHT_CORNER );
+
+			MAP_BUILTIN( POINTER_HSIZEBAR, GDK_SB_H_DOUBLE_ARROW );
+			MAP_BUILTIN( POINTER_VSIZEBAR, GDK_SB_V_DOUBLE_ARROW );
+
+			MAP_BUILTIN( POINTER_REFHAND, GDK_HAND1 );
+			MAP_BUILTIN( POINTER_HAND, GDK_HAND2 );
+			MAP_BUILTIN( POINTER_PEN, GDK_PENCIL );
+
+			MAKE_CURSOR( POINTER_NULL, null );
+			MAKE_CURSOR( POINTER_WAIT, wait_ );
+			MAKE_CURSOR( POINTER_NWSIZE, nwsesize_ );
+			MAKE_CURSOR( POINTER_NESIZE, neswsize_ );
+			MAKE_CURSOR( POINTER_SWSIZE, neswsize_ );
+			MAKE_CURSOR( POINTER_SESIZE, nwsesize_ );
+			MAKE_CURSOR( POINTER_HSPLIT, hsplit_ );
+			MAKE_CURSOR( POINTER_VSPLIT, vsplit_ );
+			MAKE_CURSOR( POINTER_MAGNIFY, magnify_ );
+			MAKE_CURSOR( POINTER_FILL, fill_ );
+			MAKE_CURSOR( POINTER_MOVE, move_ );
+			MAKE_CURSOR( POINTER_MOVEDATA, movedata_ );
+			MAKE_CURSOR( POINTER_COPYDATA, copydata_ );
+			MAKE_CURSOR( POINTER_MOVEFILE, movefile_ );
+			MAKE_CURSOR( POINTER_COPYFILE, copyfile_ );
+			MAKE_CURSOR( POINTER_MOVEFILES, movefiles_ );
+			MAKE_CURSOR( POINTER_COPYFILES, copyfiles_ );
+			MAKE_CURSOR( POINTER_NOTALLOWED, nodrop_ );
+			MAKE_CURSOR( POINTER_ROTATE, rotate_ );
+			MAKE_CURSOR( POINTER_HSHEAR, hshear_ );
+			MAKE_CURSOR( POINTER_VSHEAR, vshear_ );
+			MAKE_CURSOR( POINTER_DRAW_LINE, drawline_ );
+			MAKE_CURSOR( POINTER_DRAW_RECT, drawrect_ );
+			MAKE_CURSOR( POINTER_DRAW_POLYGON, drawpolygon_ );
+			MAKE_CURSOR( POINTER_DRAW_BEZIER, drawbezier_ );
+			MAKE_CURSOR( POINTER_DRAW_ARC, drawarc_ );
+			MAKE_CURSOR( POINTER_DRAW_PIE, drawpie_ );
+			MAKE_CURSOR( POINTER_DRAW_CIRCLECUT, drawcirclecut_ );
+			MAKE_CURSOR( POINTER_DRAW_ELLIPSE, drawellipse_ );
+			MAKE_CURSOR( POINTER_DRAW_CONNECT, drawconnect_ );
+			MAKE_CURSOR( POINTER_DRAW_TEXT, drawtext_ );
+			MAKE_CURSOR( POINTER_MIRROR, mirror_ );
+			MAKE_CURSOR( POINTER_CROOK, crook_ );
+			MAKE_CURSOR( POINTER_CROP, crop_ );
+			MAKE_CURSOR( POINTER_MOVEPOINT, movepoint_ );
+			MAKE_CURSOR( POINTER_MOVEBEZIERWEIGHT, movebezierweight_ );
+			MAKE_CURSOR( POINTER_DRAW_FREEHAND, drawfreehand_ );
+			MAKE_CURSOR( POINTER_DRAW_CAPTION, drawcaption_ );
+			MAKE_CURSOR( POINTER_LINKDATA, linkdata_ );
+			MAKE_CURSOR( POINTER_MOVEDATALINK, movedlnk_ );
+			MAKE_CURSOR( POINTER_COPYDATALINK, copydlnk_ );
+			MAKE_CURSOR( POINTER_LINKFILE, linkfile_ );
+			MAKE_CURSOR( POINTER_MOVEFILELINK, moveflnk_ );
+			MAKE_CURSOR( POINTER_COPYFILELINK, copyflnk_ );
+			MAKE_CURSOR( POINTER_CHART, chart_ );
+			MAKE_CURSOR( POINTER_DETECTIVE, detective_ );
+			MAKE_CURSOR( POINTER_PIVOT_COL, pivotcol_ );
+			MAKE_CURSOR( POINTER_PIVOT_ROW, pivotrow_ );
+			MAKE_CURSOR( POINTER_PIVOT_FIELD, pivotfld_ );
+			MAKE_CURSOR( POINTER_PIVOT_DELETE, pivotdel_ );
+			MAKE_CURSOR( POINTER_CHAIN, chain_ );
+			MAKE_CURSOR( POINTER_CHAIN_NOTALLOWED, chainnot_ );
+			MAKE_CURSOR( POINTER_TIMEEVENT_MOVE, timemove_ );
+			MAKE_CURSOR( POINTER_TIMEEVENT_SIZE, timesize_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_N, asn_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_S, ass_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_W, asw_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_E, ase_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_NW, asnw_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_NE, asne_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_SW, assw_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_SE, asse_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_NS, asns_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_WE, aswe_ );
+			MAKE_CURSOR( POINTER_AUTOSCROLL_NSWE, asnswe_ );
+			MAKE_CURSOR( POINTER_AIRBRUSH, airbrush_ );
+			MAKE_CURSOR( POINTER_TEXT_VERTICAL, vertcurs_ );
+		default:
+			fprintf( stderr, "pointer %d not implemented", ePointerStyle );
+			break;
+		}
+		if( !pCursor )
+			pCursor = gdk_cursor_new_for_display( m_pGdkDisplay, GDK_LEFT_PTR );
+
+		m_aCursors[ ePointerStyle ] = pCursor;
+	}
+
+	return m_aCursors[ ePointerStyle ];
+}
+
+int GtkSalDisplay::CaptureMouse( SalFrame* pSFrame )
+{
+    GtkSalFrame* pFrame = static_cast<GtkSalFrame*>(pSFrame);
+
+	if( !pFrame )
+	{
+		if( m_pCapture )
+			static_cast<GtkSalFrame*>(m_pCapture)->grabPointer( FALSE );
+		m_pCapture = NULL;
+		return 0;
+	}
+
+	if( m_pCapture )
+	{
+		if( pFrame == m_pCapture )
+			return 1;
+		static_cast<GtkSalFrame*>(m_pCapture)->grabPointer( FALSE );
+	}
+		
+	m_pCapture = pFrame;
+	static_cast<GtkSalFrame*>(pFrame)->grabPointer( TRUE );
+    return 1;
+}
+
+/***************************************************************************
+ * class GtkXLib                                                           *
+ ***************************************************************************/
+
+class GtkXLib : public SalXLib
+{
+    GtkSalDisplay       *m_pGtkSalDisplay;
+    std::list<GSource *> m_aSources;
+    GSource             *m_pTimeout;
+	GSource				*m_pUserEvent;
+	ULONG				 m_nTimeoutMs;
+
+	static gboolean      timeoutFn(gpointer data);
+	static gboolean      userEventFn(gpointer data);
+public:
+
+    GtkXLib();
+    virtual ~GtkXLib();
+  
+    virtual void    Init();
+    virtual void    Yield( BOOL );
+    virtual void    Insert( int fd, void* data,
+                            YieldFunc	pending,
+                            YieldFunc	queued,
+                            YieldFunc	handle );
+    virtual void    Remove( int fd );
+
+	virtual void    StartTimer( ULONG nMS );
+	virtual void    StopTimer();
+    virtual void    Wakeup();
+    virtual void    PostUserEvent();
+};
+
+GtkXLib::GtkXLib()
+{
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "GtkXLib::GtkXLib()\n" );
+#endif
+    m_pGtkSalDisplay = NULL;
+	m_pTimeout = NULL;
+	m_nTimeoutMs = 0;
+    m_pUserEvent = NULL;
+}
+
+GtkXLib::~GtkXLib()
+{
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "GtkXLib::~GtkXLib()\n" );
+#endif
+	StopTimer();
+}
+
+void GtkXLib::Init()
+{
+    int i;
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "GtkXLib::Init()\n" );
+#endif
+	XrmInitialize();
+
+    gtk_set_locale();
+
+	/*
+	 * open connection to X11 Display
+	 * try in this order:
+	 *  o  -display command line parameter,
+	 *  o  $DISPLAY environment variable
+	 *  o  default display
+	 */
+	
+    GdkDisplay *pGdkDisp = NULL;
+    
+	// is there a -display command line parameter?
+    rtl_TextEncoding aEnc = osl_getThreadTextEncoding();
+	int nParams = osl_getCommandArgCount();
+	rtl::OString aDisplay;
+	rtl::OUString aParam, aBin;
+    char** pCmdLineAry = new char*[ nParams+1 ];
+    osl_getExecutableFile( &aParam.pData );
+    osl_getSystemPathFromFileURL( aParam.pData, &aBin.pData );
+    pCmdLineAry[0] = g_strdup( OUStringToOString( aBin, aEnc ).getStr() );
+	for (i=0; i<nParams; i++) 
+	{
+		osl_getCommandArg(i, &aParam.pData );
+        OString aBParam( OUStringToOString( aParam, aEnc ) );
+
+		if( aParam.equalsAscii( "-display" ) || aParam.equalsAscii( "--display" ) )
+		{
+			pCmdLineAry[i+1] = g_strdup( "--display" );
+			osl_getCommandArg(i+1, &aParam.pData );
+			aDisplay = rtl::OUStringToOString( aParam, aEnc );
+		}
+		else
+	        pCmdLineAry[i+1] = g_strdup( aBParam.getStr() );
+	}
+    // add executable
+    nParams++;
+
+    // init gtk/gdk
+    gtk_init_check( &nParams, &pCmdLineAry );
+    
+	for (i = 0; i < nParams; i++ )
+		g_free( pCmdLineAry[i] );
+	delete [] pCmdLineAry;
+
+#if OSL_DEBUG_LEVEL > 1
+	if (g_getenv ("SAL_DEBUG_UPDATES"))
+		gdk_window_set_debug_updates (TRUE);
+#endif
+
+    pGdkDisp = gdk_display_get_default();
+	if ( !pGdkDisp )
+	{
+	    rtl::OUString aProgramFileURL;
+        osl_getExecutableFile( &aProgramFileURL.pData );
+	    rtl::OUString aProgramSystemPath;
+        osl_getSystemPathFromFileURL (aProgramFileURL.pData, &aProgramSystemPath.pData);
+        rtl::OString  aProgramName = rtl::OUStringToOString(
+                                            aProgramSystemPath,
+                                            osl_getThreadTextEncoding() );
+		fprintf( stderr, "%s X11 error: Can't open display: %s\n",
+				aProgramName.getStr(), aDisplay.getStr()); 
+		fprintf( stderr, "   Set DISPLAY environment variable, use -display option\n"); 
+		fprintf( stderr, "   or check permissions of your X-Server\n"); 
+		fprintf( stderr, "   (See \"man X\" resp. \"man xhost\" for details)\n");
+		fflush( stderr );
+		exit(0);
+	}
+
+	/*
+	 * if a -display switch was used, we need
+	 * to set the environment accoringly since 
+	 * the clipboard build another connection 
+	 * to the xserver using $DISPLAY
+	 */
+	char *pPutEnvIsBroken = g_strdup_printf( "DISPLAY=%s",
+											 gdk_display_get_name( pGdkDisp ) );
+	putenv( pPutEnvIsBroken );
+
+	Display *pDisp = gdk_x11_display_get_xdisplay( pGdkDisp );
+	XVisualInfo aVI;
+	Colormap	aColMap;
+	int 		nScreen = DefaultScreen( pDisp );
+
+	if( SalDisplay::BestVisual( pDisp, nScreen, aVI ) ) // DefaultVisual
+		aColMap = DefaultColormap( pDisp, nScreen );
+	else
+		aColMap = XCreateColormap( pDisp,
+								   RootWindow( pDisp, nScreen ),
+								   aVI.visual,
+								   AllocNone );
+
+	XSetIOErrorHandler	  ( (XIOErrorHandler)SalData::XIOErrorHdl );
+	XSetErrorHandler	  ( (XErrorHandler)SalData::XErrorHdl );
+
+	m_pGtkSalDisplay = new GtkSalDisplay( pGdkDisp, aVI.visual, aColMap );
+
+    gdk_window_add_filter( NULL, GtkSalDisplay::filterGdkEvent, m_pGtkSalDisplay );
+
+	sal_Bool bOldErrorSetting = GetIgnoreXErrors();
+	SetIgnoreXErrors( True );
+	SalI18N_KeyboardExtension *pKbdExtension = new SalI18N_KeyboardExtension( pDisp );
+	XSync( pDisp, False );
+
+	pKbdExtension->UseExtension( ! WasXError() );
+	SetIgnoreXErrors( bOldErrorSetting );
+
+	m_pGtkSalDisplay->SetKbdExtension( pKbdExtension );
+    
+}
+
+gboolean GtkXLib::timeoutFn(gpointer data)
+{
+	SalData *pSalData = GetSalData();
+	GtkXLib *pThis = (GtkXLib *) data;
+
+	pSalData->pInstance_->GetYieldMutex()->acquire();
+
+	if( pThis->m_pTimeout )
+	{
+		g_source_unref (pThis->m_pTimeout);
+		pThis->m_pTimeout = NULL;
+	}
+
+	// Auto-restart immediately
+	pThis->StartTimer( pThis->m_nTimeoutMs );
+	
+	GetSalData()->Timeout();
+
+	pSalData->pInstance_->GetYieldMutex()->release();
+	
+	return FALSE;
+}
+
+void GtkXLib::StartTimer( ULONG nMS )
+{
+	StopTimer();
+	m_nTimeoutMs = nMS; // for restarting
+
+//	fprintf (stderr, "Add timeout of '%d'ms\n", m_nTimeoutMs);
+
+	m_pTimeout = g_timeout_source_new (m_nTimeoutMs);
+	g_source_set_can_recurse (m_pTimeout, TRUE);
+	g_source_set_callback (m_pTimeout, timeoutFn,
+						   (gpointer) this, NULL);
+	g_source_attach (m_pTimeout, g_main_context_default ());
+}
+
+void GtkXLib::StopTimer()
+{
+	if (m_pTimeout)
+	{
+		g_source_destroy (m_pTimeout);
+		g_source_unref (m_pTimeout);
+		m_pTimeout = NULL;
+	}
+}
+
+gboolean GtkXLib::userEventFn(gpointer data)
+{
+	gboolean bContinue;
+	GtkXLib *pThis = (GtkXLib *) data;
+	SalData *pSalData = GetSalData();
+
+	pSalData->pInstance_->GetYieldMutex()->acquire();
+	pThis->m_pGtkSalDisplay->EventGuardAcquire();
+
+	if( !pThis->m_pGtkSalDisplay->HasMoreEvents() )
+	{
+		if( pThis->m_pUserEvent )
+		{
+			g_source_unref (pThis->m_pUserEvent);
+			pThis->m_pUserEvent = NULL;
+		}
+		bContinue = FALSE;
+	}
+	else
+		bContinue = TRUE;
+
+	pThis->m_pGtkSalDisplay->EventGuardRelease();
+
+	pThis->m_pGtkSalDisplay->DispatchInternalEvent();
+
+	pSalData->pInstance_->GetYieldMutex()->release();
+
+	return bContinue;
+}
+
+// hEventGuard_ held during this invocation
+void GtkXLib::PostUserEvent()
+{
+	if( !m_pUserEvent ) // not pending anyway
+	{
+		m_pUserEvent = g_idle_source_new();
+		g_source_set_priority( m_pUserEvent, G_PRIORITY_HIGH );
+		g_source_set_can_recurse (m_pUserEvent, TRUE);
+		g_source_set_callback (m_pUserEvent, userEventFn,
+							   (gpointer) this, NULL);
+		g_source_attach (m_pUserEvent, g_main_context_default ());
+	}
+    Wakeup();
+}
+
+void GtkXLib::Wakeup()
+{
+	g_main_context_wakeup( g_main_context_default () );
+}
+
+void GtkXLib::Yield( BOOL bWait )
+{
+	// release YieldMutex (and re-acquire at method end)
+	YieldMutexReleaser aReleaser;
+
+	g_main_context_iteration( NULL, bWait );
+}
+
+extern "C" {
+
+typedef struct {
+	GSource       source;
+
+	GPollFD       pollfd;
+	GIOCondition  condition;
+	
+	YieldFunc     pending;
+	YieldFunc     handle;
+	gpointer      user_data;
+} SalWatch;
+
+static gboolean 
+sal_source_prepare (GSource *source,
+					gint    *timeout)
+{
+	SalWatch *watch = (SalWatch *)source;
+
+	*timeout = -1;
+
+	if (watch->pending &&
+	    watch->pending (watch->pollfd.fd, watch->user_data)) {
+		watch->pollfd.revents |= watch->condition;
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static gboolean 
+sal_source_check (GSource *source)
+{
+	SalWatch *watch = (SalWatch *)source;
+
+	return watch->pollfd.revents & watch->condition;
+}
+
+static gboolean
+sal_source_dispatch (GSource    *source,
+					 GSourceFunc callback,
+					 gpointer    user_data)
+{
+	SalData *pSalData = GetSalData();
+	SalWatch *watch = (SalWatch *) source;
+
+	pSalData->pInstance_->GetYieldMutex()->acquire();
+
+	watch->handle (watch->pollfd.fd, watch->user_data);
+
+	pSalData->pInstance_->GetYieldMutex()->release();
+
+	return TRUE;
+}
+
+static void
+sal_source_finalize (GSource *source)
+{
+}
+
+static GSourceFuncs sal_source_watch_funcs = {
+	sal_source_prepare,
+	sal_source_check,
+	sal_source_dispatch,
+	sal_source_finalize
+};
+
+static GSource *
+sal_source_create_watch (int           fd,
+                         GIOCondition  condition,
+                         YieldFunc     pending,
+                         YieldFunc     handle,
+                         gpointer      user_data)
+{
+	GSource      *source;
+	SalWatch     *watch;
+	GMainContext *context = g_main_context_default ();
+
+	source = g_source_new (&sal_source_watch_funcs,
+			       sizeof (SalWatch));
+	watch = (SalWatch *) source;
+
+	watch->pollfd.fd     = fd;
+	watch->pollfd.events = condition;
+	watch->condition = condition;
+	watch->pending   = pending;
+	watch->handle    = handle;
+	watch->user_data = user_data;
+
+	g_source_set_can_recurse (source, TRUE);
+	g_source_add_poll (source, &watch->pollfd);
+	g_source_attach (source, context);
+
+	return source;
+}
+
+} // extern "C"
+
+void GtkXLib::Insert( int       nFD,
+		      void     *data,
+		      YieldFunc pending,
+		      YieldFunc queued,
+		      YieldFunc handle )
+{
+	GSource *source = sal_source_create_watch
+		( nFD, (GIOCondition) ((G_IO_IN|G_IO_PRI) |
+				       (G_IO_ERR|G_IO_HUP|G_IO_NVAL)),
+		  pending, handle, data );
+	m_aSources.push_back( source );
+}
+
+void GtkXLib::Remove( int nFD )
+{
+    ::std::list< GSource * >::iterator it;
+	
+	for (it = m_aSources.begin(); it != m_aSources.end(); ++it)
+	{
+		SalWatch *watch = (SalWatch *) *it;
+
+		if (watch->pollfd.fd == nFD)
+		{
+            m_aSources.erase( it );
+
+			g_source_destroy ((GSource *)watch);
+			g_source_unref   ((GSource *)watch);
+			return;
+		}
+	}
+}
+
+/**********************************************************************
+ * class GtkData                                                      *
+ **********************************************************************/
+
+GtkData::~GtkData()
+{
+}
+
+void GtkData::Init()
+{
+    pXLib_ = new GtkXLib();
+    pXLib_->Init();
+}
Index: vcl/unx/gtk/app/gtkinst.cxx
===================================================================
RCS file: vcl/unx/gtk/app/gtkinst.cxx
diff -N vcl/unx/gtk/app/gtkinst.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/app/gtkinst.cxx	2 Jun 2004 14:53:44 -0000	1.5
@@ -0,0 +1,323 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <osl/module.h>
+#include <plugins/gtk/gtkdata.hxx>
+#include <plugins/gtk/gtkinst.hxx>
+#include <salframe.h>
+#include <plugins/gtk/gtkframe.hxx>
+#include <plugins/gtk/gtkobject.hxx>
+
+#if OSL_DEBUG_LEVEL > 1
+#include <cstdio>
+#endif
+
+GtkHookedYieldMutex::GtkHookedYieldMutex()
+{
+}
+
+/*
+ * These methods always occur in pairs
+ * A ThreadsEnter is followed by a ThreadsLeave
+ * We need to queue up the recursive lock count
+ * for each pair, so we can accurately restore
+ * it later.
+ */
+void GtkHookedYieldMutex::ThreadsEnter()
+{
+	acquire();
+	if( !aYieldStack.empty() )
+	{ /* Previously called ThreadsLeave() */
+		ULONG nCount = aYieldStack.front();
+		aYieldStack.pop_front();
+		while( nCount-- > 1 )
+			acquire();
+	}
+}
+
+void GtkHookedYieldMutex::ThreadsLeave()
+{
+	aYieldStack.push_front( mnCount );
+
+#if OSL_DEBUG_LEVEL > 1
+	if( mnThreadId &&
+		mnThreadId != NAMESPACE_VOS(OThread)::getCurrentIdentifier())
+		fprintf( stderr, "\n\n--- A different thread owns the mutex ...---\n\n\n");
+#endif
+
+	while( mnCount > 1 )
+		release();
+	release();
+}
+
+void GtkHookedYieldMutex::acquire()
+{
+	SalYieldMutex::acquire();
+}
+
+void GtkHookedYieldMutex::release()
+{
+	SalYieldMutex::release();
+}
+
+extern "C" 
+{
+	#define GET_YIELD_MUTEX() static_cast<GtkHookedYieldMutex*>(GetSalData()->pInstance_->GetYieldMutex())
+	static void GdkThreadsEnter( void )
+	{
+		GtkHookedYieldMutex *pYieldMutex = GET_YIELD_MUTEX();
+		pYieldMutex->ThreadsEnter();
+	}
+	static void GdkThreadsLeave( void )
+	{
+		GtkHookedYieldMutex *pYieldMutex = GET_YIELD_MUTEX();
+		pYieldMutex->ThreadsLeave();
+	}
+	static bool hookLocks( oslModule pModule )
+	{
+		typedef void (*GdkLockFn) (GCallback enter_fn, GCallback leave_fn);
+		rtl::OUString aSymbolName( RTL_CONSTASCII_USTRINGPARAM( "gdk_threads_set_lock_functions") );
+
+		GdkLockFn gdk_threads_set_lock_functions =
+				(GdkLockFn) osl_getSymbol( pModule, aSymbolName.pData );
+		if ( !gdk_threads_set_lock_functions )
+		{
+#if OSL_DEBUG_LEVEL > 1
+		    fprintf( stderr, "Failed to hook gdk threads locks\n" );
+#endif
+			return false;
+		}
+
+		gdk_threads_set_lock_functions (GdkThreadsEnter, GdkThreadsLeave);
+#if OSL_DEBUG_LEVEL > 1
+		fprintf( stderr, "Hooked gdk threads locks\n" );
+#endif
+		return true;
+	}
+
+    SalInstance* create_SalInstance( oslModule pModule )
+    {
+        const gchar* pVersion = gtk_check_version( 2, 2, 0 );
+        if( pVersion )
+        {
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "gtk version conflict: %s\n", pVersion );
+#endif
+            return NULL;
+        }
+
+		GtkYieldMutex *pYieldMutex;
+
+        // init gdk thread protection
+		if ( !g_thread_supported() )
+			g_thread_init( NULL );
+
+		if ( hookLocks( pModule ) )
+			pYieldMutex = new GtkHookedYieldMutex();
+		else
+			pYieldMutex = new GtkYieldMutex();
+				
+		gdk_threads_init();
+
+        GtkInstance* pInstance = new GtkInstance( pYieldMutex );
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "creating GtkSalInstance 0x%p\n", pInstance );
+#endif
+
+        // initialize SalData
+        SalData *pSalData = new GtkData();
+        SetSalData( pSalData );
+        pSalData->pInstance_ = pInstance;
+        pSalData->Init();
+        pSalData->initNWF();
+
+        return pInstance;
+    }
+}
+
+GtkInstance::~GtkInstance()
+{
+}
+
+SalFrame* GtkInstance::CreateFrame( SalFrame* pParent, ULONG nStyle )
+{
+    return new GtkSalFrame( pParent, nStyle );
+}
+
+SalObject* GtkInstance::CreateObject( SalFrame* pParent )
+{
+    return new GtkSalObject( static_cast<GtkSalFrame*>(pParent) );
+}
+
+GtkYieldMutex::GtkYieldMutex()
+{
+}
+
+void GtkYieldMutex::acquire()
+{
+    vos::OThread::TThreadIdentifier aCurrentThread = vos::OThread::getCurrentIdentifier();
+    // protect member manipulation
+    OMutex::acquire();
+    if( mnCount > 0 && mnThreadId == aCurrentThread )
+    {
+        mnCount++;
+        OMutex::release();
+        return;
+    }
+    OMutex::release();
+    
+    // obtain gdk mutex
+    gdk_threads_enter();
+
+    // obtained gdk mutex, now lock count is one by definition
+    OMutex::acquire();
+    mnCount = 1;
+    mnThreadId = aCurrentThread;
+    OMutex::release();
+}
+
+void GtkYieldMutex::release()
+{
+    vos::OThread::TThreadIdentifier aCurrentThread = vos::OThread::getCurrentIdentifier();
+    // protect member manipulation
+    OMutex::acquire();
+    // strange things happen, do nothing if we don't own the mutex
+    if( mnThreadId == aCurrentThread )
+    {
+        mnCount--;
+        if( mnCount == 0 )
+        {
+            gdk_threads_leave();
+            mnThreadId = 0;
+        }
+    }
+    OMutex::release();
+}
+
+sal_Bool GtkYieldMutex::tryToAcquire()
+{
+    vos::OThread::TThreadIdentifier aCurrentThread = vos::OThread::getCurrentIdentifier();
+    // protect member manipulation
+    OMutex::acquire();
+    if( mnCount > 0 )
+    {
+        if( mnThreadId == aCurrentThread )
+        {
+            mnCount++;
+            OMutex::release();
+            return sal_True;
+        }
+        else
+        {
+            OMutex::release();
+            return sal_False;
+        }
+    }
+    OMutex::release();
+
+    // HACK: gdk_threads_mutex is private, we shouldn't use it.
+    // how to we do a try_lock without having a gdk_threads_try_enter ?
+    if( ! g_mutex_trylock( gdk_threads_mutex ) )
+        return sal_False;
+    
+    // obtained gdk mutex, now lock count is one by definition
+    OMutex::acquire();
+    mnCount = 1;
+    mnThreadId = aCurrentThread;
+    OMutex::release();
+    
+    return sal_True;
+}
+
+int GtkYieldMutex::Grab()
+{
+    // this MUST only be called by gdk/gtk callbacks:
+    // they are entered with gdk mutex locked; the mutex
+    // was unlocked by GtkYieldMutex befor yielding which
+    // is now locked again by gtk implicitly
+
+    // obtained gdk mutex, now lock count is one by definition
+    OMutex::acquire();
+    int nRet = mnCount;
+    if( mnCount == 0 ) // recursive else
+        mnThreadId = vos::OThread::getCurrentIdentifier();
+#if OSL_DEBUG_LEVEL > 1
+    else if( mnThreadId != vos::OThread::getCurrentIdentifier() )
+    {
+        fprintf( stderr, "Yield mutex grabbed in different thread !\n" );
+        abort();
+    }
+#endif
+    mnCount = 1;
+    OMutex::release();
+    return nRet;
+}
+
+void GtkYieldMutex::Ungrab( int nGrabs )
+{
+    // this MUST only be called when leaving the callback
+    // that locked the mutex with Grab()
+    OMutex::acquire();
+    mnCount = nGrabs;
+    if( mnCount == 0 )
+        mnThreadId = 0;
+    OMutex::release();
+}
Index: vcl/unx/gtk/app/gtksys.cxx
===================================================================
RCS file: vcl/unx/gtk/app/gtksys.cxx
diff -N vcl/unx/gtk/app/gtksys.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/app/gtksys.cxx	20 Feb 2004 08:53:44 -0000	1.2
@@ -0,0 +1,127 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <svunx.h>
+#include <svdata.hxx>
+#include <window.hxx>
+#include <plugins/gtk/gtkinst.hxx>
+#include <cstdio>
+#include <gdk/gdk.h>
+#include <gtk/gtk.h>
+#include <X11/Xlib.h>
+
+SalSystem *GtkInstance::CreateSalSystem()
+{
+		return new GtkSalSystem();
+}
+
+GtkSalSystem::~GtkSalSystem()
+{
+}
+
+int GtkSalSystem::ShowNativeDialog( const String& rTitle,
+									const String& rMessage,
+									const std::list< String >& rButtons,
+									int nDefButton )
+{
+
+	ImplSVData* pSVData = ImplGetSVData();
+	if( pSVData->mpIntroWindow )
+			pSVData->mpIntroWindow->Hide();
+
+#if OSL_DEBUG_LEVEL > 1
+	fprintf( stderr, "GtkSalSystem::ShowNativeDialog\n");
+#endif
+
+	ByteString aTitle( rTitle, RTL_TEXTENCODING_UTF8 );
+	ByteString aMessage( rMessage, RTL_TEXTENCODING_UTF8 );
+
+    /* Create the dialogue */
+    GtkWidget* mainwin = gtk_message_dialog_new
+			( NULL, (GtkDialogFlags)0, GTK_MESSAGE_WARNING,
+			  GTK_BUTTONS_NONE, aMessage.GetBuffer(), NULL );
+    gtk_window_set_title( GTK_WINDOW( mainwin ), aTitle.GetBuffer() );
+
+    gint i, nButtons = 0, nResponse;
+
+	int nButton = 0;
+	for( std::list< String >::const_iterator it = rButtons.begin(); it != rButtons.end(); ++it )
+	{
+        ByteString aLabel( *it, RTL_TEXTENCODING_UTF8 );
+
+		if( nButton == nDefButton )
+		{
+            gtk_dialog_add_button( GTK_DIALOG( mainwin ), aLabel.GetBuffer(), nButtons );
+            gtk_dialog_set_default_response( GTK_DIALOG( mainwin ), nButtons );
+		}
+		else
+			gtk_dialog_add_button( GTK_DIALOG( mainwin ), aLabel.GetBuffer(), nButtons );
+		nButtons++;
+	}
+
+    nResponse = gtk_dialog_run( GTK_DIALOG(mainwin) );
+    if( nResponse == GTK_RESPONSE_NONE || nResponse == GTK_RESPONSE_DELETE_EVENT )
+        nResponse = -1;
+
+    gtk_widget_destroy( GTK_WIDGET(mainwin) );
+
+	return nResponse;
+}
Index: vcl/unx/gtk/app/makefile.mk
===================================================================
RCS file: vcl/unx/gtk/app/makefile.mk
diff -N vcl/unx/gtk/app/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/app/makefile.mk	10 May 2004 15:52:35 -0000	1.4
@@ -0,0 +1,110 @@
+#*************************************************************************
+#
+#   
+#
+#   
+#
+#   
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=vcl
+TARGET=gtkapp
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# workaround for makedepend hang
+MKDEPENDSOLVER=
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(GUIBASE)"!="unx"
+
+dummy:
+	@echo "Nothing to build for GUIBASE $(GUIBASE)"
+
+.ELSE		# "$(GUIBASE)"!="unx"
+
+.IF "$(ENABLE_GTK)" != ""
+
+CFLAGS+=`pkg-config --cflags gtk+-2.0`
+
+SLOFILES=\
+			$(SLO)$/gtkdata.obj	\
+			$(SLO)$/gtkinst.obj	\
+			$(SLO)$/gtksys.obj
+
+.IF "$(WITH_LIBSN)"=="YES"
+CDEFS+=-DHAVE_LIBSN
+CFLAGS+=$(LIBSN_CFLAGS)
+.ENDIF
+
+.ELSE # "$(ENABLE_GTK)" != ""
+
+dummy:
+	@echo GTK disabled - nothing to build
+.ENDIF
+.ENDIF		# "$(GUIBASE)"!="unx"
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+.INCLUDE :  $(PRJ)$/util$/target.pmk
Index: vcl/unx/gtk/gdi/makefile.mk
===================================================================
RCS file: vcl/unx/gtk/gdi/makefile.mk
diff -N vcl/unx/gtk/gdi/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/gdi/makefile.mk	10 May 2004 15:52:47 -0000	1.2
@@ -0,0 +1,102 @@
+#*************************************************************************
+#
+#   
+#
+#   
+#
+#   
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=vcl
+TARGET=gtkgdi
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  svpre.mk
+.INCLUDE :  settings.mk
+.INCLUDE :  sv.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(GUIBASE)"!="unx"
+
+dummy:
+	@echo "Nothing to build for GUIBASE $(GUIBASE)"
+
+.ELSE		# "$(GUIBASE)"!="unx"
+
+.IF "$(ENABLE_GTK)" != ""
+
+CFLAGS+=`pkg-config --cflags gtk+-2.0`
+
+SLOFILES=\
+			$(SLO)$/salnativewidgets-gtk.obj
+
+.ELSE # "$(ENABLE_GTK)" != ""
+dummy:
+	@echo GTK disabled - nothing to build
+.ENDIF
+
+.ENDIF		# "$(GUIBASE)"!="unx"
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+.INCLUDE :  $(PRJ)$/util$/target.pmk
Index: vcl/unx/gtk/gdi/salnativewidgets-gtk.cxx
===================================================================
RCS file: vcl/unx/gtk/gdi/salnativewidgets-gtk.cxx
diff -N vcl/unx/gtk/gdi/salnativewidgets-gtk.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/gdi/salnativewidgets-gtk.cxx	10 May 2004 15:52:59 -0000	1.2
@@ -0,0 +1,2340 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *
+ ************************************************************************/
+
+#include <plugins/gtk/gtkframe.hxx>
+#include <plugins/gtk/gtkdata.hxx>
+#include <plugins/gtk/gtkinst.hxx>
+#include <plugins/gtk/gtkgdi.hxx>
+
+#include <cstdio>
+#include <cmath>
+#include <vector>
+#include <algorithm>
+
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
+#endif
+
+
+#ifndef _OSL_CONDITN_HXX_
+#include <osl/mutex.hxx>
+#endif
+
+// initialize statics
+BOOL GtkSalGraphics::bThemeChanged = TRUE;
+
+GtkSalGraphics::~GtkSalGraphics()
+{
+}
+
+
+using namespace rtl;
+
+/*************************************
+ * Cached native widget objects
+ *************************************/
+static GtkWidget *	gCacheWindow = NULL;
+static GtkWidget *	gDumbContainer = NULL;
+
+static GtkWidget *	gBtnWidget 			= NULL;
+static GtkWidget *	gRadioWidget			= NULL;
+static GtkWidget *	gCheckWidget			= NULL;
+static GtkWidget *	gScrollHorizWidget		= NULL;
+static GtkWidget *	gScrollVertWidget		= NULL;
+static GtkWidget *	gArrowWidget			= NULL;
+static GtkWidget *	gDropdownWidget		= NULL;
+static GtkWidget *	gEditBoxWidget			= NULL;
+static GtkWidget *	gSpinButtonWidget		= NULL;
+static GtkWidget *	gNotebookWidget		= NULL;
+static GtkWidget *	gOptionMenuWidget		= NULL;
+static GtkWidget *	gComboWidget			= NULL;
+static GtkWidget *	gScrolledWindowWidget	= NULL;
+
+osl::Mutex	* pWidgetMutex;
+
+class NWPixmapCacheList;
+static NWPixmapCacheList* gNWPixmapCacheList = NULL;
+
+static const GtkBorder aDefDefBorder		= { 1, 1, 1, 1 };
+static const GtkBorder aDefDefOutsideBorder	= { 0, 0, 0, 0 };
+
+// Some GTK defaults
+#define MIN_ARROW_SIZE					11
+#define BTN_CHILD_SPACING				1
+#define MIN_SPIN_ARROW_WIDTH				6
+
+
+static void NWEnsureGTKRadio			( void );
+static void NWEnsureGTKButton			( void );
+static void NWEnsureGTKCheck			( void );
+static void NWEnsureGTKScrollbars		( void );
+static void NWEnsureGTKArrow			( void );
+static void NWEnsureGTKEditBox		( void );
+static void NWEnsureGTKSpinButton		( void );
+static void NWEnsureGTKNotebook		( void );
+static void NWEnsureGTKOptionMenu		( void );
+static void NWEnsureGTKCombo			( void );
+static void NWEnsureGTKScrolledWindow	( void );
+
+static void NWConvertVCLStateToGTKState( ControlState nVCLState, GtkStateType* nGTKState, GtkShadowType* nGTKShadow );
+static void NWAddWidgetToCacheWindow( GtkWidget* widget );
+
+
+/*
+ * Individual helper functions
+ *
+ */
+
+//---
+static Rectangle NWGetButtonArea( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+								const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+//---
+static Rectangle NWGetEditBoxPixmapRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+static void NWPaintOneEditBox( GdkWindow * gdkDrawable, GdkRectangle *gdkRect, 
+                               ControlType nType, ControlPart nPart, Rectangle aEditBoxRect,
+                               ControlState nState, const ImplControlValue& aValue,
+                               SalControlHandle& rControlHandle, OUString aCaption );
+
+//---
+static Rectangle NWGetSpinButtonRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+static void NWPaintOneSpinButton( GdkPixmap * pixmap, ControlType nType, ControlPart nPart, Rectangle aAreaRect,
+							ControlState nState, const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+							OUString aCaption );
+//---
+static Rectangle NWGetComboBoxButtonRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+//---
+static Rectangle NWGetListBoxButtonRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+
+static Rectangle NWGetListBoxIndicatorRect( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption );
+//---
+
+/*********************************************************
+ * PixmapCache
+ *********************************************************/
+
+// as some native widget drawing operations are pretty slow
+// with certain themes (eg tabpages)
+// this cache can be used to cache the corresponding pixmap
+// see NWPaintGTKTabItem
+
+class NWPixmapCacheData
+{
+public:
+    ControlType m_nType;
+    ControlState m_nState;
+    Rectangle   m_pixmapRect;
+    GdkPixmap*  m_pixmap;
+    
+    NWPixmapCacheData()
+        { m_pixmap = NULL; };
+    ~NWPixmapCacheData()
+        { SetPixmap( NULL ); };
+    void SetPixmap( GdkPixmap* pPixmap );
+};
+
+class NWPixmapCache
+{
+    int m_size;
+    int m_idx;
+    NWPixmapCacheData* pData;
+public:
+    NWPixmapCache();
+    ~NWPixmapCache();
+    
+    void SetSize( int n)
+        { delete [] pData; m_idx = 0; m_size = n; pData = new NWPixmapCacheData[m_size]; }
+    int GetSize() { return m_size; }
+    
+    BOOL Find( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap** pPixmap );
+    void Fill( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap* pPixmap );
+    
+    void ThemeChanged();    
+};
+
+class NWPixmapCacheList
+{
+public:
+    ::std::vector< NWPixmapCache* > mCaches;
+
+    void AddCache( NWPixmapCache *pCache );
+    void RemoveCache( NWPixmapCache *pCache );
+    void ThemeChanged();
+};
+
+// --- implementation ---
+
+void NWPixmapCacheData::SetPixmap( GdkPixmap* pPixmap )
+{
+    if( m_pixmap )
+        g_object_unref( m_pixmap );
+    
+    m_pixmap = pPixmap;
+    
+    if( m_pixmap )
+        g_object_ref( m_pixmap );
+}
+
+
+NWPixmapCache::NWPixmapCache()
+{
+    m_idx = 0;
+    m_size = 0;
+    pData = NULL;
+    gNWPixmapCacheList->AddCache(this);
+} 
+NWPixmapCache::~NWPixmapCache()
+{
+    gNWPixmapCacheList->RemoveCache(this);
+    delete[] pData;
+}
+void NWPixmapCache::ThemeChanged()
+{
+    // throw away cached pixmaps
+    int i;
+    for(i=0; i<m_size; i++)
+        pData[i].SetPixmap( NULL );
+}
+
+BOOL  NWPixmapCache::Find( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap** pPixmap )
+{
+    aState &= ~CTRL_CACHING_ALLOWED; // mask clipping flag
+    int i;
+    for(i=0; i<m_size; i++)
+    {
+        if( pData[i].m_nType == aType &&
+            pData[i].m_nState == aState &&    
+            pData[i].m_pixmapRect.getWidth() == r_pixmapRect.getWidth() &&    
+            pData[i].m_pixmapRect.getHeight() == r_pixmapRect.getHeight() &&    
+            pData[i].m_pixmap != NULL )
+        {
+            *pPixmap = pData[i].m_pixmap;
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+void NWPixmapCache::Fill( ControlType aType, ControlState aState, const Rectangle& r_pixmapRect, GdkPixmap* pPixmap )
+{
+    if( !(aState & CTRL_CACHING_ALLOWED) )
+        return; 
+
+    aState &= ~CTRL_CACHING_ALLOWED; // mask clipping flag
+    m_idx = (m_idx+1) % m_size; // just wrap
+    pData[m_idx].m_nType = aType;
+    pData[m_idx].m_nState = aState;
+    pData[m_idx].m_pixmapRect = r_pixmapRect;
+    pData[m_idx].SetPixmap( pPixmap );
+}
+
+
+void NWPixmapCacheList::AddCache( NWPixmapCache* pCache )
+{
+    mCaches.push_back( pCache );
+}
+void NWPixmapCacheList::RemoveCache( NWPixmapCache* pCache )
+{
+    ::std::vector< NWPixmapCache* >::iterator p;
+    p = ::std::find( mCaches.begin(), mCaches.end(), pCache );
+    if( p != mCaches.end() )
+        mCaches.erase( p );
+}
+void NWPixmapCacheList::ThemeChanged( )
+{
+    ::std::vector< NWPixmapCache* >::iterator p = mCaches.begin();
+    while( p != mCaches.end() )
+    {
+        (*p)->ThemeChanged();
+        p++;
+    }
+}
+
+
+/*********************************************************
+ * Make border manipulation easier
+ *********************************************************/
+inline void NW_gtk_border_set_from_border( GtkBorder& aDst, const GtkBorder * pSrc )
+{
+	aDst.left		= pSrc->left;
+	aDst.top		= pSrc->top;
+	aDst.right	= pSrc->right;
+	aDst.bottom	= pSrc->bottom;
+}
+
+
+/*********************************************************
+ * Initialize GTK and local stuff                         
+ *********************************************************/
+void GtkData::initNWF( void )
+{
+	pWidgetMutex = new osl::Mutex;
+    gNWPixmapCacheList = new NWPixmapCacheList;
+}
+
+
+/*********************************************************
+ * Release GTK and local stuff                         
+ *********************************************************/
+void GtkData::deInitNWF( void )
+{
+	delete pWidgetMutex;
+    delete gNWPixmapCacheList;
+}
+
+/*
+ * IsNativeControlSupported()
+ *
+ *  Returns TRUE if the platform supports native
+ *  drawing of the control defined by nPart
+ */
+BOOL GtkSalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+	if (
+		((nType==CTRL_PUSHBUTTON)  && (nPart==PART_ENTIRE_CONTROL)) 	||
+ 		((nType==CTRL_RADIOBUTTON) && (nPart==PART_ENTIRE_CONTROL))		||
+		((nType==CTRL_CHECKBOX)    && (nPart==PART_ENTIRE_CONTROL))		||
+		((nType==CTRL_SCROLLBAR) &&
+				(  (nPart==PART_DRAW_BACKGROUND_HORZ)
+				|| (nPart==PART_DRAW_BACKGROUND_VERT)
+				|| (nPart==PART_ENTIRE_CONTROL) )				)	||
+		((nType==CTRL_EDITBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==HAS_BACKGROUND_TEXTURE) ) 			)	||
+		((nType==CTRL_SPINBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_ALL_BUTTONS)
+				|| (nPart==HAS_BACKGROUND_TEXTURE) )			)	||
+		((nType==CTRL_SPINBUTTONS) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_ALL_BUTTONS)	)				)	||
+		((nType==CTRL_COMBOBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==HAS_BACKGROUND_TEXTURE)	)			)	||
+		(((nType==CTRL_TAB_ITEM) || (nType==CTRL_TAB_PANE) ||
+		  (nType==CTRL_TAB_BODY) || (nType==CTRL_FIXEDBORDER)) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_TABS_DRAW_RTL) )				)	||
+		((nType==CTRL_LISTBOX) &&
+				(  (nPart==PART_ENTIRE_CONTROL)
+				|| (nPart==PART_WINDOW)
+				|| (nPart==HAS_BACKGROUND_TEXTURE) )			)
+	   )
+		return( TRUE );
+
+	return( FALSE );
+}
+
+
+/*
+ * HitTestNativeControl()
+ *
+ *  bIsInside is set to TRUE if aPos is contained within the
+ *  given part of the control, whose bounding region is
+ *  given by rControlRegion (in VCL frame coordinates).
+ *
+ *  returns whether bIsInside was really set.
+ */
+BOOL GtkSalGraphics::hitTestNativeControl( ControlType		nType,
+								ControlPart		nPart,
+								const Region&		rControlRegion,
+								const Point&		aPos,
+								SalControlHandle&	rControlHandle,
+								BOOL&			rIsInside )
+{
+	if( IsNativeControlSupported(nType, nPart) )
+	{
+		rIsInside = rControlRegion.IsInside( aPos );
+		return( TRUE );
+	}
+	else
+	{
+		return( FALSE );
+	}
+}
+
+
+/*
+ * DrawNativeControl()
+ *
+ *  Draws the requested control described by nPart/nState.
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL GtkSalGraphics::drawNativeControl(	ControlType nType,
+							ControlPart nPart,
+							const Region& rControlRegion,
+							ControlState nState,
+							const ImplControlValue& aValue,
+							SalControlHandle& rControlHandle,
+							OUString aCaption )
+{
+	BOOL			returnVal = FALSE;
+	int			    nDepth = GetSalData()->GetDisplay()->GetVisual()->GetDepth();
+
+	// get a GC with current clipping region set
+	GC			gc = SelectFont();
+    
+    // theme changed ?
+    if( GtkSalGraphics::bThemeChanged )
+    {
+        // invalidate caches
+        gNWPixmapCacheList->ThemeChanged();
+        GtkSalGraphics::bThemeChanged = FALSE;    
+    }
+    
+	if ( pWidgetMutex->acquire() )
+	{
+		if ( (nType==CTRL_PUSHBUTTON) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKButton( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( (nType==CTRL_RADIOBUTTON) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKRadio( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( (nType==CTRL_CHECKBOX) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKCheck( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( (nType==CTRL_SCROLLBAR) && ((nPart==PART_DRAW_BACKGROUND_HORZ) || (nPart==PART_DRAW_BACKGROUND_VERT)) )
+		{
+			returnVal = NWPaintGTKScrollbar( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( ((nType==CTRL_EDITBOX) && ((nPart==PART_ENTIRE_CONTROL) || (nPart==HAS_BACKGROUND_TEXTURE)) )
+				|| ((nType==CTRL_SPINBOX) && (nPart==HAS_BACKGROUND_TEXTURE))
+				|| ((nType==CTRL_COMBOBOX) && (nPart==HAS_BACKGROUND_TEXTURE))
+				|| ((nType==CTRL_LISTBOX) && (nPart==HAS_BACKGROUND_TEXTURE)) )
+		{
+			returnVal = NWPaintGTKEditBox( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( ((nType==CTRL_SPINBOX) || (nType==CTRL_SPINBUTTONS))
+				&& ((nPart==PART_ENTIRE_CONTROL) || (nPart==PART_ALL_BUTTONS)) )
+		{
+			returnVal = NWPaintGTKSpinBox( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( (nType == CTRL_COMBOBOX) && (nPart==PART_ENTIRE_CONTROL) )
+		{
+			returnVal = NWPaintGTKComboBox( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+		else if ( (nType==CTRL_TAB_ITEM) || (nType==CTRL_TAB_PANE) || (nType==CTRL_TAB_BODY) || (nType==CTRL_FIXEDBORDER) )
+		{
+			if ( nType == CTRL_TAB_BODY )
+				returnVal = TRUE;
+			else
+				returnVal = NWPaintGTKTabItem( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption);
+		}
+		else if ( (nType==CTRL_LISTBOX) && ((nPart==PART_ENTIRE_CONTROL) || (nPart==PART_WINDOW)) )
+		{
+			returnVal = NWPaintGTKListBox( nType, nPart, rControlRegion, nState, aValue, rControlHandle, aCaption );
+		}
+
+		pWidgetMutex->release();
+	}
+
+	return( returnVal );
+}
+
+
+/*
+ * DrawNativeControlText()
+ *
+ *  OPTIONAL.  Draws the requested text for the control described by nPart/nState.
+ *     Used if text not drawn by DrawNativeControl().
+ *
+ *  rControlRegion:	The bounding region of the complete control in VCL frame coordinates.
+ *  aValue:  		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:  	A caption or title string (like button text etc)
+ */
+BOOL GtkSalGraphics::drawNativeControlText(	ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption )
+{
+	return( FALSE );
+}
+
+
+/*
+ * GetNativeControlRegion()
+ *
+ *  If the return value is TRUE, rNativeBoundingRegion
+ *  contains the TRUE bounding region covered by the control
+ *  including any adornment, while rNativeContentRegion contains the area
+ *  within the control that can be safely drawn into without drawing over
+ *  the borders of the control.
+ *
+ *  rControlRegion:	The bounding region of the control in VCL frame coordinates.
+ *  aValue:		An optional value (tristate/numerical/string)
+ *  rControlHandle:	Carries platform dependent data and is maintained by the SalFrame implementation.
+ *  aCaption:		A caption or title string (like button text etc)
+ */
+BOOL GtkSalGraphics::getNativeControlRegion(  ControlType nType,
+								ControlPart nPart,
+								const Region& rControlRegion,
+								ControlState nState,
+								const ImplControlValue& aValue,
+								SalControlHandle& rControlHandle,
+								OUString aCaption,
+								Region &rNativeBoundingRegion,
+								Region &rNativeContentRegion )
+{
+	BOOL returnVal = FALSE;
+
+	if ( pWidgetMutex->acquire() )
+	{
+		if ( (nType==CTRL_PUSHBUTTON) && (nPart==PART_ENTIRE_CONTROL)
+				&& (rControlRegion.GetBoundRect().GetWidth() > 16)
+				&& (rControlRegion.GetBoundRect().GetHeight() > 16) )
+		{
+			rNativeBoundingRegion = NWGetButtonArea( nType, nPart, rControlRegion.GetBoundRect(),
+									 nState, aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rControlRegion;
+	
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_SPINBOX) && ((nPart==PART_BUTTON_UP) || (nPart==PART_BUTTON_DOWN)) )
+		{
+			rNativeBoundingRegion = NWGetSpinButtonRect( nType, nPart, rControlRegion.GetBoundRect(),
+										nState, aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+	
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_COMBOBOX) && (nPart==PART_BUTTON_DOWN) )
+		{
+			rNativeBoundingRegion = NWGetComboBoxButtonRect( nType, nPart, rControlRegion.GetBoundRect(), nState,
+										aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+	
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_SPINBOX) && ((nPart==PART_BUTTON_UP) || (nPart==PART_BUTTON_DOWN)) )
+		{
+			SpinbuttonValue *	pSpinVal = (SpinbuttonValue *)(aValue.getOptionalVal());
+
+			rNativeBoundingRegion = NWGetSpinButtonRect( nType, nPart, rControlRegion.GetBoundRect(), nState,
+									aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+
+			returnVal = TRUE;
+		}
+		if ( (nType==CTRL_LISTBOX) && ((nPart==PART_BUTTON_DOWN) || (nPart==PART_SUB_EDIT)) )
+		{
+			rNativeBoundingRegion = NWGetListBoxButtonRect( nType, nPart, rControlRegion.GetBoundRect(), nState,
+										aValue, rControlHandle, aCaption );
+			rNativeContentRegion = rNativeBoundingRegion;
+	
+			returnVal = TRUE;
+		}
+
+		pWidgetMutex->release();
+	}
+
+	return( returnVal );
+}
+
+
+/************************************************************************
+ * Individual control drawing functions
+ ************************************************************************/
+BOOL GtkSalGraphics::NWPaintGTKButton( ControlType nType, ControlPart nPart,
+			const Region& rControlRegion, ControlState nState, const ImplControlValue& aValue,
+			SalControlHandle& rControlHandle, OUString aCaption )
+{
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		buttonRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	gboolean		interiorFocus;
+	gint			focusWidth;
+	gint			focusPad;
+	BOOL			bDrawFocus = TRUE;
+	gint			x, y, w, h;
+	GtkBorder		aDefBorder;
+	GtkBorder		aDefOutsideBorder;
+	GtkBorder*		pBorder;
+	GtkBorder*		pOutBorder;
+    GdkRectangle	clipRect;
+    
+	NWEnsureGTKButton();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+    BOOL bUseWindow = (GetNumCliprects() == 1);
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+	x = y = 0;
+	w = pixmapRect.getWidth();
+	h = pixmapRect.getHeight();
+
+	// Grab some button style attributes
+	gtk_widget_style_get( gBtnWidget,	"focus-line-width",	&focusWidth,
+								"focus-padding", 	&focusPad,
+					 			"interior_focus",	&interiorFocus,
+								"default_border",	&pBorder,
+								"default_outside_border", &pOutBorder, NULL );
+
+	// Make sure the border values exist, otherwise use some defaults
+	if ( pBorder )
+	{
+		NW_gtk_border_set_from_border( aDefBorder, pBorder );
+		gtk_border_free( pBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefBorder, &aDefDefBorder );
+
+	if ( pOutBorder )
+	{
+		NW_gtk_border_set_from_border( aDefOutsideBorder, pOutBorder );
+		gtk_border_free( pOutBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefOutsideBorder, &aDefDefOutsideBorder );
+
+	// If the button is too small, don't ever draw focus or grab more space
+	if ( (w < 16) || (h < 16) )
+		bDrawFocus = FALSE;
+
+	// Some themes use these GTK flags to alter the appearance of the button
+	GTK_WIDGET_UNSET_FLAGS( gBtnWidget, GTK_HAS_DEFAULT );
+	GTK_WIDGET_UNSET_FLAGS( gBtnWidget, GTK_HAS_FOCUS );
+	GTK_WIDGET_UNSET_FLAGS( gBtnWidget, GTK_SENSITIVE );
+	if ( nState & CTRL_STATE_DEFAULT )
+		GTK_WIDGET_SET_FLAGS( gBtnWidget, GTK_HAS_DEFAULT );
+	if ( nState & CTRL_STATE_FOCUSED )
+		GTK_WIDGET_SET_FLAGS( gBtnWidget, GTK_HAS_FOCUS );
+	if ( nState & CTRL_STATE_ENABLED )
+		GTK_WIDGET_SET_FLAGS( gBtnWidget, GTK_SENSITIVE );
+
+	gtk_widget_set_state( gBtnWidget, stateType );
+
+    if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = pixmapRect.Left();
+        y = pixmapRect.Top();
+    }
+    
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+	// Buttons must paint opaque since some themes have alpha-channel enabled buttons
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_NONE, 
+                        gdkRect, gBtnWidget, "base", x, y, w, h );
+
+	if ( (nState & CTRL_STATE_DEFAULT) && (GTK_BUTTON(gBtnWidget)->relief == GTK_RELIEF_NORMAL) )
+	{
+		gtk_paint_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_IN, 
+                       gdkRect, gBtnWidget, "buttondefault", x, y, w, h );
+	}
+
+	if ( (nState & CTRL_STATE_DEFAULT) && bDrawFocus )
+	{
+		x += aDefBorder.left;
+		y += aDefBorder.top;
+		w -= aDefBorder.left + aDefBorder.right;
+		h -= aDefBorder.top + aDefBorder.bottom;
+	}
+
+	if ( !interiorFocus && bDrawFocus )
+	{
+		x += focusWidth + focusPad;
+		y += focusWidth + focusPad;
+		w -= 2 * (focusWidth + focusPad);
+		h -= 2 * (focusWidth + focusPad);
+	}
+
+	if ( (GTK_BUTTON(gBtnWidget)->relief != GTK_RELIEF_NONE)
+		|| ((GTK_WIDGET_STATE(gBtnWidget) != GTK_STATE_NORMAL)
+		    && (GTK_WIDGET_STATE(gBtnWidget) != GTK_STATE_INSENSITIVE)) )
+	{
+		gtk_paint_box( gBtnWidget->style, gdkDrawable, stateType, shadowType,
+                       gdkRect, gBtnWidget, "button", x, y, w, h );
+	}
+
+	// Draw focus rect
+#if 0 // VCL draws focus rects
+	if ( (nState & CTRL_STATE_FOCUSED) && (nState & CTRL_STATE_ENABLED) && bDrawFocus )
+	{
+		if (interiorFocus)
+		{
+			x += gBtnWidget->style->xthickness + focusPad;
+			y += gBtnWidget->style->ythickness + focusPad;
+			w -= 2 * (gBtnWidget->style->xthickness + focusPad);
+			h -=  2 * (gBtnWidget->style->xthickness + focusPad);
+		}
+		else
+		{
+			x -= focusWidth + focusPad;
+			y -= focusWidth + focusPad;
+			w += 2 * (focusWidth + focusPad);
+			h += 2 * (focusWidth + focusPad);
+		}
+		if ( !interiorFocus )
+			gtk_paint_focus( gBtnWidget->style, gdkDrawable, stateType, gdkRect,
+                             gBtnWidget, "button", x, y, w, h );
+	}
+#endif
+
+//	gdk_draw_rectangle( pixmap, gBtnWidget->style->black_gc, false, 0, 0, pixmapRect.getWidth()-1, pixmapRect.getHeight()-1 );
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+        g_object_unref( pixmap );
+    }
+    
+	return( TRUE );
+}
+
+static Rectangle NWGetButtonArea( ControlType nType, ControlPart nPart, Rectangle aAreaRect, ControlState nState,
+							const ImplControlValue& aValue, SalControlHandle& rControlHandle, OUString aCaption )
+{
+	gboolean		interiorFocus;
+	gint			focusWidth;
+	gint			focusPad;
+	GtkBorder		aDefBorder;
+	GtkBorder		aDefOutsideBorder;
+	GtkBorder *	pBorder;
+	GtkBorder *	pOutBorder;
+	BOOL			bDrawFocus = TRUE;
+	Rectangle		aRect;
+	gint			x, y, w, h;
+
+	NWEnsureGTKButton();
+	gtk_widget_style_get( gBtnWidget,	"focus-line-width",	&focusWidth,
+								"focus-padding", 	&focusPad,
+					 			"interior_focus",	&interiorFocus,
+								"default_border",	&pBorder,
+								"default_outside_border", &pOutBorder, NULL );
+
+	// Make sure the border values exist, otherwise use some defaults
+	if ( pBorder )
+	{
+		NW_gtk_border_set_from_border( aDefBorder, pBorder );
+		gtk_border_free( pBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefBorder, &aDefDefBorder );
+
+	if ( pOutBorder )
+	{
+		NW_gtk_border_set_from_border( aDefOutsideBorder, pOutBorder );
+		gtk_border_free( pOutBorder );
+	}
+	else NW_gtk_border_set_from_border( aDefOutsideBorder, &aDefDefOutsideBorder );
+
+	x = aAreaRect.getX();
+	y = aAreaRect.getY();
+	w = aAreaRect.getWidth();
+	h = aAreaRect.getHeight();
+
+	// If the button is too small, don't ever draw focus or grab more space
+	if ( (w < 16) || (h < 16) )
+		bDrawFocus = FALSE;
+
+	if ( (nState & CTRL_STATE_DEFAULT) && bDrawFocus )
+	{
+		x -= aDefBorder.left;
+		y -= aDefBorder.top;
+		w += aDefBorder.left + aDefBorder.right;
+		h += aDefBorder.top + aDefBorder.bottom;
+	}
+
+	aRect.setX( x );
+	aRect.setY( y );
+	aRect.setWidth( w );
+	aRect.setHeight( h );
+
+	return( aRect );
+}
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKRadio( ControlType nType, ControlPart nPart,
+                                      const Region& rControlRegion, ControlState nState, 
+                                      const ImplControlValue& aValue, SalControlHandle& rControlHandle, 
+                                      OUString aCaption )
+{
+#define	RADIO_BUTTON_MINIMUMSIZE   14 // found by experiment, TODO: should be checked at runtime if possible 
+
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	BOOL			isChecked = (aValue.getTristateVal()==BUTTONVALUE_ON);
+	gboolean		interiorFocus;
+	gint			focusWidth;
+	gint			focusPad;
+    gint            x, y;
+    GdkRectangle	clipRect;
+   
+	NWEnsureGTKButton();
+	NWEnsureGTKRadio();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+    BOOL bUseWindow = (GetNumCliprects() == 1);
+
+	// Find the overall bounding rect of the control
+	pixmapRect = rControlRegion.GetBoundRect();
+    x = y = 0;
+    
+    // assure minimum button size required by gtk+ to avoid clipping
+    if( pixmapRect.getWidth() < RADIO_BUTTON_MINIMUMSIZE )
+        pixmapRect.setWidth( RADIO_BUTTON_MINIMUMSIZE );
+    if( pixmapRect.getHeight() < RADIO_BUTTON_MINIMUMSIZE )
+        pixmapRect.setHeight( RADIO_BUTTON_MINIMUMSIZE );
+
+	// Set the shadow based on if checked or not so we get a freakin checkmark.
+	shadowType = isChecked ? GTK_SHADOW_IN : GTK_SHADOW_OUT;
+
+	gtk_widget_set_state( GTK_WIDGET(gRadioWidget), stateType );
+	gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(gRadioWidget), isChecked );
+
+    if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+        x = y = 0;
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = pixmapRect.Left();
+        y = pixmapRect.Top();
+    }
+    
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+    gtk_paint_option( gRadioWidget->style, gdkDrawable, stateType, shadowType, 
+                      gdkRect, gRadioWidget, "radiobutton",
+                      x, y, pixmapRect.getWidth(), pixmapRect.getHeight() );
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+        g_object_unref( pixmap );
+    }
+    
+	return( TRUE );
+}
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKCheck( ControlType nType, ControlPart nPart,
+                                      const Region& rControlRegion, ControlState nState, 
+                                      const ImplControlValue& aValue,
+                                      SalControlHandle& rControlHandle, OUString aCaption )
+{
+#define	CHECKBOX_MINIMUMSIZE   14 // found by experiment, TODO: should be checked at runtime if possible 
+    
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		btnBoundRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	BOOL			isChecked = (aValue.getTristateVal()==BUTTONVALUE_ON) ? TRUE : FALSE;
+	gint			ctrlSize;
+    GdkRectangle	clipRect;
+    gint			x,y;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKCheck();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+    BOOL bUseWindow = (GetNumCliprects() == 1);
+
+	// Find the overall bounding rect of the control
+	pixmapRect = rControlRegion.GetBoundRect();
+    
+    // assure minimum button size required by gtk+ to avoid clipping
+    if( pixmapRect.getWidth() < CHECKBOX_MINIMUMSIZE )
+        pixmapRect.setWidth( CHECKBOX_MINIMUMSIZE );
+    if( pixmapRect.getHeight() < CHECKBOX_MINIMUMSIZE )
+        pixmapRect.setHeight( CHECKBOX_MINIMUMSIZE );
+    
+	btnBoundRect = pixmapRect;
+
+	// Set the shadow based on if checked or not so we get a freakin checkmark.
+	shadowType = isChecked ? GTK_SHADOW_IN : GTK_SHADOW_OUT;
+
+	gtk_widget_set_state( gCheckWidget, stateType );
+	gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(gCheckWidget), isChecked );
+
+    if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+        x = btnBoundRect.getX() - pixmapRect.getX();
+        y = btnBoundRect.getY() - pixmapRect.getY();
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = btnBoundRect.Left();
+        y = btnBoundRect.Top();
+    }
+
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+	gtk_paint_check( gCheckWidget->style, gdkDrawable, stateType, shadowType, 
+                     gdkRect, gCheckWidget, "checkbutton",
+                     x, y, btnBoundRect.getWidth(), btnBoundRect.getHeight() );
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+        g_object_unref( pixmap );
+    }
+	return( TRUE );
+}
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKScrollbar( ControlType nType, ControlPart nPart,
+                                          const Region& rControlRegion, ControlState nState, 
+                                          const ImplControlValue& aValue, SalControlHandle& rControlHandle, 
+                                          OUString aCaption )
+{
+	ScrollbarValue* pScrollbarVal = (ScrollbarValue *)(aValue.getOptionalVal());
+	GdkPixmap	*	pixmap = NULL;
+	Rectangle		pixmapRect;
+	Rectangle		scrollbarRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	GtkScrollbar *	scrollbarWidget;
+	GtkStyle *	style;
+	GtkAdjustment* scrollbarValues = NULL;
+	GtkOrientation	scrollbarOrientation;
+	Rectangle		thumbRect = pScrollbarVal->maThumbRect;
+	Rectangle		button1BoundRect = pScrollbarVal->maButton1Rect;
+	Rectangle		button2BoundRect = pScrollbarVal->maButton2Rect;
+	GtkArrowType	button1Type;
+	GtkArrowType	button2Type;
+	gint			nButton1Extra = 0;
+	gint			nButton2Extra = 0;
+	gchar *		scrollbarTagH = (gchar *) "hscrollbar";
+	gchar *		scrollbarTagV = (gchar *) "vscrollbar";
+	gchar *		scrollbarTag = NULL;
+	Rectangle		arrow1Rect;
+	Rectangle		arrow2Rect;
+	gint			slider_width;
+	gint			stepper_size;
+	gint			stepper_spacing;
+	gint			trough_border;
+	gint			vShim = 0;
+	gint			hShim = 0;
+	gint			x,y;
+	GdkRectangle	clipRect;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKScrollbars();
+	NWEnsureGTKArrow();
+
+    // as multiple paints are required for the scrollbar
+	// painting them directly to the window flickers
+    BOOL bUseWindow = FALSE; //(GetNumCliprects() == 1);
+    
+	// Find the overall bounding rect of the control
+	pixmapRect = rControlRegion.GetBoundRect();
+	pixmapRect.setWidth( pixmapRect.getWidth() + 1 );
+	pixmapRect.setHeight( pixmapRect.getHeight() + 1 );
+	scrollbarRect = pixmapRect;
+	if ( (scrollbarRect.getWidth() <= 1) || (scrollbarRect.getHeight() <= 1) )
+		return( TRUE );
+
+	// Grab some button style attributes
+	gtk_widget_style_get( gScrollHorizWidget, "slider_width", &slider_width,
+									  "stepper_size", &stepper_size,
+									  "trough_border", &trough_border,
+									  "stepper_spacing", &stepper_spacing, NULL );
+
+	if ( nPart == PART_DRAW_BACKGROUND_HORZ )
+	{
+		unsigned int	sliderHeight = slider_width + (trough_border * 2);
+		vShim = (pixmapRect.getHeight() - sliderHeight) / 2;
+
+		if ( sliderHeight < scrollbarRect.getHeight() );
+		{
+			scrollbarRect.Move( 0, vShim );
+			scrollbarRect.setHeight( sliderHeight );
+		}
+
+		scrollbarWidget = GTK_SCROLLBAR( gScrollHorizWidget );
+		scrollbarOrientation = GTK_ORIENTATION_HORIZONTAL;
+		scrollbarTag = scrollbarTagH;
+		button1Type = GTK_ARROW_LEFT;
+		button2Type = GTK_ARROW_RIGHT;
+
+		button1BoundRect.setX( (button1BoundRect.getWidth()-stepper_size) / 2 );
+		button1BoundRect.setY( ((button1BoundRect.getHeight()-vShim)-slider_width) / 2 );
+		button1BoundRect.setHeight( slider_width );
+		button1BoundRect.setWidth( stepper_size );
+		nButton1Extra = (pScrollbarVal->maButton1Rect.getX() + pScrollbarVal->maButton1Rect.getWidth()) - 
+				(button1BoundRect.getX() + button1BoundRect.getWidth());
+
+		button2BoundRect.setX( scrollbarRect.getWidth() - button2BoundRect.getWidth() + ((button2BoundRect.getWidth()-stepper_size) / 2) );
+		button2BoundRect.setY( ((button2BoundRect.getHeight()-vShim)-slider_width) / 2 );
+		button2BoundRect.setHeight( slider_width );
+		button2BoundRect.setWidth( stepper_size );
+		nButton2Extra =  button2BoundRect.getX() - pScrollbarVal->maButton2Rect.getX();
+
+		thumbRect.setHeight( slider_width );
+		// Center vertically in the track
+		thumbRect.Move( 0, (scrollbarRect.getHeight() - slider_width) / 2 );
+
+		// Themes may have a different idea of what the scrollbar stepper button
+		// size should be, so we have to adjust the Thumbs rectangle to account
+		// for the difference between OOo's idea and the theme's
+		thumbRect.Move( -nButton1Extra, 0 );
+		thumbRect.setWidth( thumbRect.getWidth() + nButton1Extra + nButton2Extra );
+	}
+	else
+	{
+		unsigned int	sliderWidth = slider_width + (trough_border * 2);
+		hShim = (pixmapRect.getWidth() - sliderWidth) / 2;
+
+		if ( sliderWidth < scrollbarRect.getWidth() );
+		{
+			scrollbarRect.Move( hShim, 0 );
+			scrollbarRect.setWidth( sliderWidth );
+		}
+
+		scrollbarWidget = GTK_SCROLLBAR( gScrollVertWidget );
+		scrollbarOrientation = GTK_ORIENTATION_VERTICAL;
+		scrollbarTag = scrollbarTagV;
+		button1Type = GTK_ARROW_UP;
+		button2Type = GTK_ARROW_DOWN;
+
+		button1BoundRect.setX( ((button1BoundRect.getWidth()-hShim)-slider_width) / 2 );
+		button1BoundRect.setY( (button1BoundRect.getHeight()-stepper_size) / 2 );
+		button1BoundRect.setHeight( stepper_size );
+		button1BoundRect.setWidth( slider_width );
+		nButton1Extra = (pScrollbarVal->maButton1Rect.getY() + pScrollbarVal->maButton1Rect.getHeight()) - 
+				(button1BoundRect.getY() + button1BoundRect.getHeight());
+
+		button2BoundRect.setX( ((button2BoundRect.getWidth()-hShim)-slider_width) / 2 );
+		button2BoundRect.setY( scrollbarRect.getHeight() - button2BoundRect.getHeight() + ((button2BoundRect.getHeight()-stepper_size) / 2) );
+		button2BoundRect.setHeight( stepper_size );
+		button2BoundRect.setWidth( slider_width );
+		nButton2Extra =  button2BoundRect.getY() - pScrollbarVal->maButton2Rect.getY();
+
+		thumbRect.setWidth( slider_width );
+		// Center horizontally in the track
+		thumbRect.Move( (scrollbarRect.getWidth() - slider_width) / 2, 0 );
+
+		// Themes may have a different idea of what the scrollbar stepper button
+		// size should be, so we have to adjust the Thumbs rectangle to account
+		// for the difference between OOo's idea and the theme's
+		thumbRect.Move( 0, -nButton1Extra );
+		thumbRect.setHeight( thumbRect.getHeight() + nButton1Extra + nButton2Extra );
+	}
+
+	scrollbarValues = gtk_range_get_adjustment( GTK_RANGE(scrollbarWidget) );
+	if ( scrollbarValues == NULL )
+		scrollbarValues = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+	if ( nPart == PART_DRAW_BACKGROUND_HORZ )
+	{
+		scrollbarValues->lower = pScrollbarVal->mnMin;
+		scrollbarValues->upper = pScrollbarVal->mnMax;
+		scrollbarValues->value = pScrollbarVal->mnCur;
+		scrollbarValues->page_size = scrollbarRect.getWidth() / 2;
+	}
+	else
+	{
+		scrollbarValues->lower = pScrollbarVal->mnMin;
+		scrollbarValues->upper = pScrollbarVal->mnMax;
+		scrollbarValues->value = pScrollbarVal->mnCur;
+		scrollbarValues->page_size = scrollbarRect.getHeight() / 2;
+	}
+	gtk_adjustment_changed( scrollbarValues );
+
+	// Size the arrow appropriately
+	arrow1Rect.setWidth ( button1BoundRect.getWidth()  / 2 );
+	arrow1Rect.setHeight( button1BoundRect.getHeight() / 2 );
+	arrow2Rect.setWidth ( button2BoundRect.getWidth()  / 2 );
+	arrow2Rect.setHeight( button2BoundRect.getHeight() / 2 );
+
+	arrow1Rect.setX( button1BoundRect.getX() + (button1BoundRect.getWidth()  - arrow1Rect.getWidth() ) / 2 );
+	arrow1Rect.setY( button1BoundRect.getY() + (button1BoundRect.getHeight() - arrow1Rect.getHeight()) / 2 );
+	arrow2Rect.setX( button2BoundRect.getX() + (button2BoundRect.getWidth()  - arrow2Rect.getWidth() ) / 2 );
+	arrow2Rect.setY( button2BoundRect.getY() + (button2BoundRect.getHeight() - arrow2Rect.getHeight()) / 2 );
+
+	if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+        x = y = 0;
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = pixmapRect.Left();
+        y = pixmapRect.Top();
+    }
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+	style = GTK_WIDGET( scrollbarWidget )->style;
+
+	// ----------------- TROUGH
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, 
+                        GTK_STATE_NORMAL, GTK_SHADOW_NONE, gdkRect,
+                        gBtnWidget, "base", x, y, 
+                        pixmapRect.getWidth(), pixmapRect.getHeight() );
+	gtk_paint_box( style, gdkDrawable, GTK_STATE_ACTIVE, GTK_SHADOW_IN, 
+                   gdkRect, GTK_WIDGET(scrollbarWidget), "trough",
+                   x+(scrollbarRect.getX() - pixmapRect.getX()), 
+                   y+(scrollbarRect.getY()-pixmapRect.getY()),
+                   scrollbarRect.getWidth(), scrollbarRect.getHeight() );
+
+	if ( nState & CTRL_STATE_FOCUSED )
+	{
+		gtk_paint_focus( style, gdkDrawable, GTK_STATE_ACTIVE, 
+                         gdkRect, GTK_WIDGET(scrollbarWidget), "trough",
+                         x+(scrollbarRect.getX() - pixmapRect.getX()), 
+                         y+(scrollbarRect.getY()-pixmapRect.getY()),
+                         scrollbarRect.getWidth(), scrollbarRect.getHeight() );
+	}
+
+	// ----------------- THUMB
+	NWConvertVCLStateToGTKState( pScrollbarVal->mnThumbState, &stateType, &shadowType );
+	if ( pScrollbarVal->mnThumbState & CTRL_STATE_PRESSED )  stateType = GTK_STATE_PRELIGHT;
+	gtk_paint_slider( style, gdkDrawable, stateType, GTK_SHADOW_OUT, 
+                      gdkRect, GTK_WIDGET(scrollbarWidget), "slider",
+                      x+hShim+thumbRect.getX(), y+vShim+thumbRect.getY(), 
+                      thumbRect.getWidth(), thumbRect.getHeight(), scrollbarOrientation );
+
+	// ----------------- BUTTON 1
+	NWConvertVCLStateToGTKState( pScrollbarVal->mnButton1State, &stateType, &shadowType );
+	if ( stateType == GTK_STATE_INSENSITIVE )	stateType = GTK_STATE_NORMAL;
+	gtk_paint_box( style, gdkDrawable, stateType, shadowType, 
+                   gdkRect, GTK_WIDGET(scrollbarWidget), "stepper",
+                   x+hShim+button1BoundRect.getX(), y+vShim+button1BoundRect.getY(), 
+                   button1BoundRect.getWidth(), button1BoundRect.getHeight() );
+	// ----------------- ARROW 1
+	gtk_paint_arrow( style, gdkDrawable, stateType, shadowType, 
+                     gdkRect, GTK_WIDGET(scrollbarWidget), scrollbarTag, button1Type, TRUE,
+                     x+hShim+arrow1Rect.getX(), y+vShim+arrow1Rect.getY(), 
+                     arrow1Rect.getWidth(), arrow1Rect.getHeight() );
+
+	// ----------------- BUTTON 2
+	NWConvertVCLStateToGTKState( pScrollbarVal->mnButton2State, &stateType, &shadowType );
+	if ( stateType == GTK_STATE_INSENSITIVE )	stateType = GTK_STATE_NORMAL;
+	gtk_paint_box( style, gdkDrawable, stateType, shadowType, gdkRect, 
+                   GTK_WIDGET(scrollbarWidget), "stepper",
+                   x+hShim+button2BoundRect.getX(), y+vShim+button2BoundRect.getY(), 
+                   button2BoundRect.getWidth(), button2BoundRect.getHeight() );
+	// ----------------- ARROW 2
+	gtk_paint_arrow( style, gdkDrawable, stateType, shadowType, 
+                     gdkRect, GTK_WIDGET(scrollbarWidget), scrollbarTag, button2Type, TRUE,
+                     x+hShim+arrow2Rect.getX(), y+vShim+arrow2Rect.getY(), 
+                     arrow2Rect.getWidth(), arrow2Rect.getHeight() );
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+        g_object_unref( pixmap );
+    }
+	return( TRUE );
+}
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKEditBox( ControlType nType, ControlPart nPart,
+                                        const Region& rControlRegion, ControlState nState, 
+                                        const ImplControlValue& aValue, SalControlHandle& rControlHandle, 
+                                        OUString aCaption )
+{
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = NWGetEditBoxPixmapRect( nType, nPart, rControlRegion.GetBoundRect(),
+					nState, aValue, rControlHandle, aCaption );
+
+	pixmap = NWGetPixmapFromScreen( pixmapRect );
+	if ( !pixmap )
+		return( FALSE );
+
+	// NWPaintOneEditBox() requires pixmap local
+	Rectangle		aEditBoxRect = rControlRegion.GetBoundRect();
+	aEditBoxRect.setX( rControlRegion.GetBoundRect().getX() - pixmapRect.getX() );
+	aEditBoxRect.setY( rControlRegion.GetBoundRect().getY() - pixmapRect.getY() );
+
+	NWPaintOneEditBox( pixmap, NULL, nType, nPart, aEditBoxRect, nState, aValue, rControlHandle, aCaption );
+
+	if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+
+/* Take interior/exterior focus into account and return
+ * the bounding rectangle of the edit box including
+ * any focus requirements.
+ */
+static Rectangle NWGetEditBoxPixmapRect(ControlType			nType,
+								ControlPart			nPart,
+								Rectangle				aAreaRect,
+								ControlState			nState,
+								const ImplControlValue&	aValue,
+								SalControlHandle&		rControlHandle,
+								OUString				aCaption )
+{
+	Rectangle		pixmapRect = aAreaRect;
+	gboolean		interiorFocus;
+	gint			focusWidth;
+
+	NWEnsureGTKEditBox();
+
+	// Grab some entry style attributes
+	gtk_widget_style_get( gEditBoxWidget,	"focus-line-width",	&focusWidth,
+					 				"interior-focus",	&interiorFocus, NULL );
+
+	if ( !interiorFocus )
+	{
+		pixmapRect.Move( -(focusWidth), -(focusWidth) );
+		pixmapRect.setWidth( pixmapRect.getWidth() + (2*(focusWidth)) );
+		pixmapRect.setHeight( pixmapRect.getHeight() + (2*(focusWidth)) );
+	}
+
+	return( pixmapRect );
+}
+
+
+/* Paint a GTK Entry widget into the specified GdkPixmap.
+ * All coordinates should be local to the Pixmap, NOT
+ * screen/window coordinates.
+ */
+static void NWPaintOneEditBox(	GdkWindow * gdkDrawable,
+                                GdkRectangle *	gdkRect,
+							ControlType			nType,
+							ControlPart			nPart,
+							Rectangle				aEditBoxRect,
+							ControlState			nState,
+							const ImplControlValue&	aValue,
+							SalControlHandle&		rControlHandle,
+							OUString				aCaption )
+{
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	GtkWidget *	widget;
+	gboolean		interiorFocus;
+	gint			focusWidth;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKEditBox();
+	NWEnsureGTKSpinButton();
+	NWEnsureGTKCombo();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	switch ( nType )
+	{
+		case CTRL_COMBOBOX:
+		case CTRL_SPINBOX:
+			widget = gSpinButtonWidget;
+			break;
+
+//		case CTRL_COMBOBOX:
+//			widget = gComboWidget;
+//			break;
+
+		default:
+			widget = gEditBoxWidget;
+			break;
+	}
+
+	GTK_WIDGET_UNSET_FLAGS( widget, GTK_HAS_DEFAULT );
+	GTK_WIDGET_UNSET_FLAGS( widget, GTK_HAS_FOCUS );
+	GTK_WIDGET_UNSET_FLAGS( widget, GTK_SENSITIVE );
+	if ( nState & CTRL_STATE_DEFAULT )
+		GTK_WIDGET_SET_FLAGS( widget, GTK_HAS_DEFAULT );
+	if ( nState & CTRL_STATE_FOCUSED )
+		GTK_WIDGET_SET_FLAGS( widget, GTK_HAS_FOCUS );
+	if ( nState & CTRL_STATE_ENABLED )
+		GTK_WIDGET_SET_FLAGS( widget, GTK_SENSITIVE );
+
+	gtk_widget_set_state( widget, stateType );
+
+	// Blueprint needs to paint entry_bg with a Button widget, not an Entry widget to get
+	// a nice white (or whatever default color) background
+	if ( stateType == GTK_STATE_PRELIGHT )
+		stateType = GTK_STATE_NORMAL;
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, stateType, GTK_SHADOW_NONE, 
+                        gdkRect, gBtnWidget, "entry_bg",
+                        aEditBoxRect.getX(), aEditBoxRect.getY(), 
+                        aEditBoxRect.getWidth(), aEditBoxRect.getHeight() );
+
+	gtk_paint_shadow( widget->style, gdkDrawable, GTK_STATE_NORMAL, shadowType, 
+                      gdkRect, widget, "entry",
+                      aEditBoxRect.getX(), aEditBoxRect.getY(), 
+                      aEditBoxRect.getWidth(), aEditBoxRect.getHeight() );
+
+	// Grab some entry style attributes
+	gtk_widget_style_get( gEditBoxWidget,	"focus-line-width",	&focusWidth,
+					 				"interior-focus",	&interiorFocus, NULL );
+	// Draw focus rect
+#if 0   // vcl draws focus rects
+	if ( nState & CTRL_STATE_FOCUSED )
+	{
+		if ( !interiorFocus )
+		{
+			Rectangle aFocusRect = aEditBoxRect;
+
+			aFocusRect.Move( -(focusWidth), -(focusWidth) );
+			aFocusRect.setWidth( aFocusRect.getWidth() + (2*(focusWidth)) );
+			aFocusRect.setHeight( aFocusRect.getHeight() + (2*(focusWidth)) );
+
+			gtk_paint_focus( widget->style, gdkDrawable, stateType, gdkRect, widget, "entry", 
+				aFocusRect.getX(), aFocusRect.getY(), aFocusRect.getWidth(), aFocusRect.getHeight() );
+		}
+	}
+#endif
+}
+
+
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKSpinBox( ControlType nType, ControlPart nPart,
+                                        const Region& rControlRegion, ControlState nState, 
+                                        const ImplControlValue& aValue,
+                                        SalControlHandle& rControlHandle, OUString aCaption )
+{
+	GdkPixmap	*		pixmap;
+	Rectangle			pixmapRect;
+	GtkStateType		stateType;
+	GtkShadowType		shadowType;
+	SpinbuttonValue *	pSpinVal = (SpinbuttonValue *)(aValue.getOptionalVal());
+	Rectangle			upBtnRect;
+	ControlPart		upBtnPart = PART_BUTTON_UP;
+	ControlState		upBtnState = CTRL_STATE_ENABLED;
+	Rectangle			downBtnRect;
+	ControlPart		downBtnPart = PART_BUTTON_DOWN;
+	ControlState		downBtnState = CTRL_STATE_ENABLED;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKSpinButton();
+	NWEnsureGTKArrow();
+
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	if ( pSpinVal )
+	{
+		upBtnPart = pSpinVal->mnUpperPart;
+		upBtnState = pSpinVal->mnUpperState;
+
+		downBtnPart = pSpinVal->mnLowerPart;
+		downBtnState = pSpinVal->mnLowerState;
+	}
+
+	// CTRL_SPINBUTTONS pass their area in pSpinVal, not in rControlRegion
+	if ( nType == CTRL_SPINBUTTONS )
+	{
+		if ( !pSpinVal )
+		{
+			fprintf( stderr, "Tried to draw CTRL_SPINBUTTONS, but the SpinButtons data structure didn't exist!\n" );
+			return( false );
+		}
+		pixmapRect = pSpinVal->maUpperRect;
+		pixmapRect.Union( pSpinVal->maLowerRect );
+	}
+	else
+		pixmapRect = rControlRegion.GetBoundRect();
+
+
+	pixmap = NWGetPixmapFromScreen( pixmapRect );
+	if ( !pixmap )
+		return( FALSE );
+
+	upBtnRect = NWGetSpinButtonRect( nType, upBtnPart, pixmapRect, upBtnState, aValue, rControlHandle, aCaption );
+	downBtnRect = NWGetSpinButtonRect( nType, downBtnPart, pixmapRect, downBtnState, aValue, rControlHandle, aCaption );
+
+	if ( (nType==CTRL_SPINBOX) && (nPart!=PART_ALL_BUTTONS) )
+	{
+		// Draw an edit field for SpinBoxes and ComboBoxes
+		Rectangle aEditBoxRect( pixmapRect );
+		aEditBoxRect.setWidth( upBtnRect.getX() - pixmapRect.getX() );
+		aEditBoxRect.setX( 0 );
+		aEditBoxRect.setY( 0 );
+
+		NWPaintOneEditBox( pixmap, NULL, nType, nPart, aEditBoxRect, nState, aValue, rControlHandle, aCaption );
+	}
+
+	gtk_widget_style_get( gSpinButtonWidget, "shadow_type", &shadowType, NULL );
+
+	if ( shadowType != GTK_SHADOW_NONE )
+	{
+		Rectangle		shadowRect( upBtnRect );
+
+		shadowRect.Union( downBtnRect );
+		gtk_paint_box( gSpinButtonWidget->style, pixmap, GTK_STATE_NORMAL, shadowType, NULL,
+			gSpinButtonWidget, "spinbutton",
+			(shadowRect.getX() - pixmapRect.getX()), (shadowRect.getY() - pixmapRect.getY()),
+			shadowRect.getWidth(), shadowRect.getHeight() );
+	}
+
+	NWPaintOneSpinButton( pixmap, nType, upBtnPart, pixmapRect, upBtnState, aValue, rControlHandle, aCaption );
+	NWPaintOneSpinButton( pixmap, nType, downBtnPart, pixmapRect, downBtnState, aValue, rControlHandle, aCaption );
+
+	if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+//---
+
+static Rectangle NWGetSpinButtonRect(	ControlType			nType,
+								ControlPart			nPart,
+								Rectangle 			aAreaRect,
+								ControlState			nState,
+								const ImplControlValue&	aValue,
+								SalControlHandle&		rControlHandle,
+								OUString				aCaption )
+{
+	gint			buttonSize;
+	Rectangle		buttonRect;
+
+	NWEnsureGTKSpinButton();
+
+	buttonSize = MAX( PANGO_PIXELS( pango_font_description_get_size(GTK_WIDGET(gSpinButtonWidget)->style->font_desc) ),
+				   MIN_SPIN_ARROW_WIDTH );
+	buttonSize -= buttonSize % 2 - 1; /* force odd */
+	buttonRect.setWidth( buttonSize + 2 * gSpinButtonWidget->style->xthickness );
+	buttonRect.setX( aAreaRect.getX() + (aAreaRect.getWidth() - buttonRect.getWidth()) );
+	buttonRect.setHeight( (aAreaRect.getHeight() / 2) );
+	if ( nPart == PART_BUTTON_UP )
+        buttonRect.setY( aAreaRect.getY() );
+	else
+    {
+        buttonRect.Top() = aAreaRect.getY() + (aAreaRect.getHeight() / 2);
+        buttonRect.Bottom() = aAreaRect.Bottom(); // cover area completely
+    }
+
+	return( buttonRect );
+}
+
+//---
+
+static void NWPaintOneSpinButton(	GdkPixmap	*			pixmap,
+							ControlType			nType,
+							ControlPart			nPart,
+							Rectangle				aAreaRect,
+							ControlState			nState,
+							const ImplControlValue&	aValue,
+							SalControlHandle&		rControlHandle,
+							OUString				aCaption )
+{
+	Rectangle			buttonRect;
+	GtkStateType		stateType;
+	GtkShadowType		shadowType;
+	Rectangle			arrowRect;
+	gint				arrowSize;
+
+	NWEnsureGTKSpinButton();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+//	gtk_widget_set_state( gSpinButtonWidget, stateType );
+
+	buttonRect = NWGetSpinButtonRect( nType, nPart, aAreaRect, nState, aValue, rControlHandle, aCaption );
+
+	GTK_WIDGET_UNSET_FLAGS( gSpinButtonWidget, GTK_SENSITIVE );
+	if ( nState & CTRL_STATE_ENABLED )
+		GTK_WIDGET_SET_FLAGS( gSpinButtonWidget, GTK_SENSITIVE );
+
+	gtk_paint_box( gSpinButtonWidget->style, pixmap, stateType, shadowType, NULL, gSpinButtonWidget,
+			(nPart == PART_BUTTON_UP) ? "spinbutton_up" : "spinbutton_down",
+			(buttonRect.getX() - aAreaRect.getX()), (buttonRect.getY() - aAreaRect.getY()),
+			buttonRect.getWidth(), buttonRect.getHeight() );
+
+	arrowSize = (buttonRect.getWidth() - (2 * gSpinButtonWidget->style->xthickness)) - 4;
+	arrowSize -= arrowSize % 2 - 1; /* force odd */
+	arrowRect.setWidth( arrowSize );
+	arrowRect.setHeight( arrowRect.getWidth() );
+	arrowRect.setX( buttonRect.getX() + (buttonRect.getWidth() - arrowRect.getWidth()) / 2 );
+	if ( nPart == PART_BUTTON_UP )
+		arrowRect.setY( buttonRect.getY() + (buttonRect.getHeight() - arrowRect.getHeight()) / 2 + 1);
+	else
+		arrowRect.setY( buttonRect.getY() + (buttonRect.getHeight() - arrowRect.getHeight()) / 2 - 1);
+
+	gtk_paint_arrow( gSpinButtonWidget->style, pixmap, GTK_STATE_NORMAL, GTK_SHADOW_OUT, NULL, gSpinButtonWidget,
+			"spinbutton", (nPart == PART_BUTTON_UP) ? GTK_ARROW_UP : GTK_ARROW_DOWN, TRUE,
+			(arrowRect.getX() - aAreaRect.getX()), (arrowRect.getY() - aAreaRect.getY()),
+			arrowRect.getWidth(), arrowRect.getHeight() );
+}
+
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKComboBox( ControlType nType, ControlPart nPart,
+                                         const Region& rControlRegion, ControlState nState, 
+                                         const ImplControlValue& aValue,
+                                         SalControlHandle& rControlHandle, OUString aCaption )
+{
+	GdkPixmap	*	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		buttonRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	Rectangle		arrowRect;
+	gint			arrowSize;
+    gint			x,y;
+    GdkRectangle	clipRect;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKArrow();
+	NWEnsureGTKCombo();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+    BOOL bUseWindow = (GetNumCliprects() == 1);
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+
+    if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+        x = y = 0;
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = pixmapRect.Left();
+        y = pixmapRect.Top();
+    }
+
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+    buttonRect = NWGetComboBoxButtonRect( nType, nPart, pixmapRect, nState, aValue, rControlHandle, aCaption );
+
+	Rectangle		aEditBoxRect( pixmapRect );
+	aEditBoxRect.setWidth( pixmapRect.getWidth() - buttonRect.getWidth() );
+	aEditBoxRect.setX( x );
+	aEditBoxRect.setY( y );
+
+	NWPaintOneEditBox( gdkDrawable, gdkRect, nType, nPart, aEditBoxRect, 
+                       nState, aValue, rControlHandle, aCaption );
+
+//	gtk_widget_set_state( gComboWidget, stateType );
+
+	// Buttons must paint opaque since some themes have alpha-channel enabled buttons
+	gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_NONE, 
+                        gdkRect, gBtnWidget, "base", 
+                        x+(buttonRect.getX() - pixmapRect.getX()), 
+                        y+(buttonRect.getY() - pixmapRect.getY()),
+                        buttonRect.getWidth(), buttonRect.getHeight() );
+	gtk_paint_box( GTK_COMBO(gComboWidget)->button->style, gdkDrawable, stateType, shadowType,
+                   gdkRect, GTK_COMBO(gComboWidget)->button, "button",
+                   x+(buttonRect.getX() - pixmapRect.getX()), 
+                   y+(buttonRect.getY() - pixmapRect.getY()),
+                   buttonRect.getWidth(), buttonRect.getHeight() );
+
+#define ARROW_EXTENT		0.7
+	arrowRect.setWidth( (gint)(MIN_ARROW_SIZE * ARROW_EXTENT) );
+	arrowRect.setHeight( (gint)(MIN_ARROW_SIZE * ARROW_EXTENT) );
+	arrowRect.setX( buttonRect.getX() + (gint)((buttonRect.getWidth() - arrowRect.getWidth()) / 2)  );
+	arrowRect.setY( buttonRect.getY() + (gint)((buttonRect.getHeight() - arrowRect.getHeight()) / 2)  );
+
+	gtk_paint_arrow( gArrowWidget->style, gdkDrawable, stateType, shadowType,
+			gdkRect, gArrowWidget, "arrow", GTK_ARROW_DOWN, TRUE,
+			x+(arrowRect.getX() - pixmapRect.getX()), y+(arrowRect.getY() - pixmapRect.getY()),
+			arrowRect.getWidth(), arrowRect.getHeight() );
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+        g_object_unref( pixmap );
+    }
+
+	return( TRUE );
+}
+
+//----
+
+static Rectangle NWGetComboBoxButtonRect(	ControlType			nType,
+									ControlPart			nPart,
+									Rectangle				aAreaRect,
+									ControlState			nState,
+									const ImplControlValue&	aValue,
+									SalControlHandle&		rControlHandle,
+									OUString				aCaption )
+{
+	Rectangle	aButtonRect;
+	gint		nArrowWidth;
+	gint		nFocusWidth;
+	gint		nFocusPad;
+
+	NWEnsureGTKArrow();
+
+	// Grab some button style attributes
+	gtk_widget_style_get( gDropdownWidget,	"focus-line-width",	&nFocusWidth,
+									"focus-padding", 	&nFocusPad, NULL );
+
+	nArrowWidth = MIN_ARROW_SIZE + (GTK_MISC(gArrowWidget)->xpad * 2);
+	aButtonRect.setY( aAreaRect.getY() );
+	aButtonRect.setHeight( aAreaRect.getHeight() );
+	aButtonRect.setWidth( nArrowWidth + ((BTN_CHILD_SPACING + gDropdownWidget->style->xthickness) * 2)
+						+ (2 * (nFocusWidth+nFocusPad)) );
+	aButtonRect.setX( aAreaRect.getX() + aAreaRect.getWidth() - aButtonRect.getWidth() );
+
+	return( aButtonRect );
+}
+
+//-------------------------------------
+
+
+    
+BOOL GtkSalGraphics::NWPaintGTKTabItem( ControlType nType, ControlPart nPart,
+                                        const Region& rControlRegion, ControlState nState, 
+                                        const ImplControlValue& aValue,
+                                        SalControlHandle& rControlHandle, OUString aCaption )
+{
+	GdkPixmap *	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		tabRect;
+	TabitemValue *	pTabitemValue = (TabitemValue *)(aValue.getOptionalVal());
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+    static NWPixmapCache aCacheItems;
+    static NWPixmapCache aCachePage;
+
+    if( !aCacheItems.GetSize() )
+        aCacheItems.SetSize( 20 );
+    if( !aCachePage.GetSize() )
+        aCachePage.SetSize( 1 );
+    
+	if ( !pTabitemValue && (nType==CTRL_TAB_ITEM) )
+	{
+		fprintf( stderr, "NWPaintGTKTabItem() received a NULL TabitemValue.  Cannot draw native tab\n" );
+		return( false );
+	}
+
+	NWEnsureGTKButton();
+	NWEnsureGTKNotebook();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+	if ( nType == CTRL_TAB_ITEM )
+	{
+		if ( !pTabitemValue->isFirst() )
+		{
+			// GTK+ tabs overlap on the right edge (the top tab obscures the
+			// left edge of the tab right "below" it, so adjust the rectangle
+			// to draw tabs slightly large so the overlap happens
+			pixmapRect.Move( -2, 0 );
+			pixmapRect.setWidth( pixmapRect.getWidth() + 2 );
+		}
+		if ( nState & CTRL_STATE_SELECTED )
+		{
+			// In GTK+, the selected tab is 2px taller than all other tabs
+			pixmapRect.setY( pixmapRect.getY() - 2 );
+			pixmapRect.setHeight( pixmapRect.getHeight() + 3 );
+			tabRect = pixmapRect;
+			// Only draw over 1 pixel of the tab pane that this tab is drawn on top of.
+			tabRect.setHeight( tabRect.getHeight() - 1 );
+		}
+		else
+			tabRect = pixmapRect;
+
+		// Allow the tab to draw a right border if needed
+		tabRect.setWidth( tabRect.getWidth() - 1 );
+	}
+
+    if( nType == CTRL_TAB_ITEM )
+    {
+        if( aCacheItems.Find( nType, nState, pixmapRect, &pixmap ) )
+            return NWRenderPixmapToScreen( pixmap, pixmapRect );
+    }
+    else
+    {
+        if( aCachePage.Find( nType, nState, pixmapRect, &pixmap ) )
+            return NWRenderPixmapToScreen( pixmap, pixmapRect );
+    }
+
+        
+//	gtk_widget_set_state( gNotebookWidget, stateType );
+
+	pixmap = NWGetPixmapFromScreen( pixmapRect );
+	if ( !pixmap )
+		return( FALSE );
+
+	switch( nType )
+	{
+		case CTRL_TAB_BODY:
+			break;
+
+		case CTRL_FIXEDBORDER:
+		case CTRL_TAB_PANE:
+			gtk_paint_box_gap( gNotebookWidget->style, pixmap, GTK_STATE_NORMAL, GTK_SHADOW_OUT, NULL, gNotebookWidget,
+				(char *)"notebook", 0, 0, pixmapRect.getWidth(), pixmapRect.getHeight(), GTK_POS_TOP, 0, 0 );
+			break;
+
+		case CTRL_TAB_ITEM:
+			stateType = ( nState & CTRL_STATE_SELECTED ) ? GTK_STATE_NORMAL : GTK_STATE_ACTIVE;
+
+			gtk_paint_extension( gNotebookWidget->style, pixmap, stateType, GTK_SHADOW_OUT, NULL, gNotebookWidget,
+				(char *)"tab", (tabRect.getX() - pixmapRect.getX()), (tabRect.getY() - pixmapRect.getY()),
+				tabRect.getWidth(), tabRect.getHeight(), GTK_POS_BOTTOM );
+
+			if ( nState & CTRL_STATE_SELECTED )
+			{
+				gtk_paint_flat_box( gNotebookWidget->style, pixmap, stateType, GTK_SHADOW_NONE, NULL, gNotebookWidget,
+					(char *)"base", 0, (pixmapRect.getHeight() - 2), pixmapRect.getWidth(), 1 );
+			}
+			break;
+
+		default:
+			break;
+	}
+
+	// Crux seems to think it can make the pane without a left edge
+	if ( nType == CTRL_FIXEDBORDER )
+		pixmapRect.Move( 1, 0 );
+
+    // cache data
+    if( GetGtkFrame()->getVisibilityState() == GDK_VISIBILITY_UNOBSCURED ) 
+    {
+        if( nType == CTRL_TAB_ITEM )
+            aCacheItems.Fill( nType, nState, pixmapRect, pixmap );
+        else
+            aCachePage.Fill( nType, nState, pixmapRect, pixmap );
+    }
+        
+	if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+	{
+		g_object_unref( pixmap );
+		return( FALSE );
+	}
+    
+	g_object_unref( pixmap );
+	return( TRUE );
+}
+
+//-------------------------------------
+
+BOOL GtkSalGraphics::NWPaintGTKListBox( ControlType nType, ControlPart nPart,
+                                        const Region& rControlRegion, ControlState nState, 
+                                        const ImplControlValue& aValue,
+                                        SalControlHandle& rControlHandle, OUString aCaption )
+{
+	GdkPixmap	*	pixmap;
+	Rectangle		pixmapRect;
+	Rectangle		widgetRect;
+	Rectangle		aIndicatorRect;
+	GtkStateType	stateType;
+	GtkShadowType	shadowType;
+	gint			bInteriorFocus;
+	gint			nFocusLineWidth;
+	gint			nFocusPadding;
+    gint			x,y;
+    GdkRectangle    clipRect;
+
+	NWEnsureGTKButton();
+	NWEnsureGTKOptionMenu();
+	NWEnsureGTKScrolledWindow();
+	NWConvertVCLStateToGTKState( nState, &stateType, &shadowType );
+
+    BOOL bUseWindow = (GetNumCliprects() == 1);
+
+	// Find the overall bounding rect of the buttons's drawing area,
+	// plus its actual draw rect excluding adornment
+	pixmapRect = rControlRegion.GetBoundRect();
+	if ( nPart == PART_WINDOW )
+	{
+		// Make the widget a _bit_ bigger
+		pixmapRect.setX( pixmapRect.getX() - 1 );
+		pixmapRect.setY( pixmapRect.getY() - 1 );
+		pixmapRect.setWidth( pixmapRect.getWidth() + 2 );
+		pixmapRect.setHeight( pixmapRect.getHeight() + 2 );
+	}
+
+	widgetRect = pixmapRect;
+
+    if( !bUseWindow )
+    {
+        pixmap = NWGetPixmapFromScreen( pixmapRect );
+        if ( !pixmap )
+            return( FALSE );
+        x = y = 0;
+    }
+    else
+    {
+        clipRect.x = GetBoundingCliprect().Left();
+        clipRect.y = GetBoundingCliprect().Top();
+        clipRect.width = GetBoundingCliprect().getWidth();
+        clipRect.height = GetBoundingCliprect().getHeight();
+        x = pixmapRect.Left();
+        y = pixmapRect.Top();
+    }
+
+    // set up references to correct drawable and cliprect
+    GdkDrawable* const &gdkDrawable = GDK_DRAWABLE( bUseWindow ? GetGdkWindow() : pixmap );
+    GdkRectangle* const &gdkRect    = bUseWindow ? &clipRect : NULL;
+
+	if ( nPart != PART_WINDOW )
+	{
+		gtk_widget_style_get( gOptionMenuWidget,
+			"interior_focus",	&bInteriorFocus,
+			"focus_line_width",	&nFocusLineWidth,
+			"focus_padding",	&nFocusPadding,
+			NULL);
+
+		// Listboxes must paint opaque since some themes have alpha-channel enabled bodies
+		gtk_paint_flat_box( gBtnWidget->style, gdkDrawable, GTK_STATE_NORMAL, GTK_SHADOW_NONE, 
+                            gdkRect, gBtnWidget, "base", x, y, 
+                            pixmapRect.getWidth(), pixmapRect.getHeight() );
+
+		gtk_paint_box( gOptionMenuWidget->style, gdkDrawable, stateType, shadowType, gdkRect,
+                       gOptionMenuWidget, "optionmenu",
+                       x+(widgetRect.getX() - pixmapRect.getX()), 
+                       y+(widgetRect.getY() - pixmapRect.getY()),
+                       widgetRect.getWidth(), widgetRect.getHeight() );
+
+		aIndicatorRect = NWGetListBoxIndicatorRect( nType, nPart, widgetRect, nState, 
+                                                    aValue, rControlHandle, aCaption );
+		gtk_paint_tab( gOptionMenuWidget->style, gdkDrawable, stateType, shadowType, gdkRect,
+                       gOptionMenuWidget, "op  tionmenutab",
+                       x+(aIndicatorRect.getX() - pixmapRect.getX()), 
+                       y+(aIndicatorRect.getY() - pixmapRect.getY()),
+                       aIndicatorRect.getWidth(), aIndicatorRect.getHeight() );
+	}
+	else
+	{
+		gtk_paint_shadow( gScrolledWindowWidget->style, gdkDrawable, GTK_STATE_NORMAL, shadowType,
+			gdkRect, gScrolledWindowWidget, "scrolled_window",
+			x+(widgetRect.getX() - pixmapRect.getX()), y+(widgetRect.getY() - pixmapRect.getY()),
+			widgetRect.getWidth(), widgetRect.getHeight() );
+	}
+
+    if( !bUseWindow )
+    {
+        if( !NWRenderPixmapToScreen(pixmap, pixmapRect) )
+        {
+            g_object_unref( pixmap );
+            return( FALSE );
+        }
+	g_object_unref( pixmap );
+    }
+
+	return( TRUE );
+}
+
+//----
+
+static Rectangle NWGetListBoxButtonRect(	ControlType			nType,
+									ControlPart			nPart,
+									Rectangle				aAreaRect,
+									ControlState			nState,
+									const ImplControlValue&	aValue,
+									SalControlHandle&		rControlHandle,
+									OUString				aCaption )
+{
+	Rectangle 		aPartRect;
+	GtkRequisition *	pIndicatorSize;
+	GtkBorder *		pIndicatorSpacing;
+	gint				width = 13;	// GTK+ default
+	gint				left  = 7;	// GTK+ default
+	gint				right = 5;	// GTK+ default
+	gint				nButtonAreaWidth = 0;
+
+	NWEnsureGTKOptionMenu();
+
+	gtk_widget_style_get( gOptionMenuWidget,
+			"indicator_size",	&pIndicatorSize,
+			"indicator_spacing",&pIndicatorSpacing, NULL);
+	
+	if ( pIndicatorSize && ((pIndicatorSize->width < 20) || (pIndicatorSize->width >= 0)) )
+		width = pIndicatorSize->width;
+
+	if ( pIndicatorSpacing && ((pIndicatorSpacing->right < 20) || (pIndicatorSpacing->right >= 0)) )
+		right = pIndicatorSpacing->right;
+	if ( pIndicatorSpacing && ((pIndicatorSpacing->left < 20) || (pIndicatorSpacing->left >= 0)) )
+		left = pIndicatorSpacing->left;
+
+	aPartRect.setHeight( aAreaRect.getHeight() );
+	aPartRect.setY( aAreaRect.getY() );
+
+	nButtonAreaWidth = width + right + (gOptionMenuWidget->style->xthickness * 2);
+	switch( nPart )
+	{
+		case PART_BUTTON_DOWN:
+			aPartRect.setWidth( nButtonAreaWidth );
+			aPartRect.setX( aAreaRect.getX() + aAreaRect.getWidth() - aPartRect.getWidth() );
+			break;
+
+		case PART_SUB_EDIT:
+			aPartRect.setWidth( aAreaRect.getWidth() - nButtonAreaWidth );
+			aPartRect.setX( aAreaRect.getX() );
+			break;
+
+		default:
+			aPartRect.setWidth( aAreaRect.getWidth() );	
+			aPartRect.setX( aAreaRect.getX() );
+			break;
+	}
+
+	if ( pIndicatorSize )
+		g_free( pIndicatorSize );
+	if ( pIndicatorSpacing )
+		g_free( pIndicatorSpacing );
+
+	return( aPartRect );
+}
+
+//----
+
+static Rectangle NWGetListBoxIndicatorRect(	ControlType			nType,
+									ControlPart			nPart,
+									Rectangle				aAreaRect,
+									ControlState			nState,
+									const ImplControlValue&	aValue,
+									SalControlHandle&		rControlHandle,
+									OUString				aCaption )
+{
+	Rectangle 		aIndicatorRect;
+	GtkRequisition *	pIndicatorSize;
+	GtkBorder *		pIndicatorSpacing;
+	gint				width = 7;	// GTK+ default
+	gint				height = 13;	// GTK+ default
+	gint				right = 5;	// GTK+ default
+
+	NWEnsureGTKOptionMenu();
+
+	gtk_widget_style_get( gOptionMenuWidget,
+			"indicator_size",	&pIndicatorSize,
+			"indicator_spacing",&pIndicatorSpacing, NULL);
+	
+	if ( pIndicatorSize && ((pIndicatorSize->width < 20) && (pIndicatorSize->width >= 0)) )
+		width = pIndicatorSize->width;
+	if ( pIndicatorSize && ((pIndicatorSize->height < 20) && (pIndicatorSize->height >= 0)) )
+		height = pIndicatorSize->height;
+
+	if ( pIndicatorSpacing && ((pIndicatorSpacing->right < 20) && (pIndicatorSpacing->right >= 0)) )
+		right = pIndicatorSpacing->right;
+
+	aIndicatorRect.setWidth( width );
+	aIndicatorRect.setHeight( height );
+	aIndicatorRect.setX( aAreaRect.getX() + aAreaRect.getWidth() - width - right - gOptionMenuWidget->style->xthickness );
+	aIndicatorRect.setY( aAreaRect.getY() + ((aAreaRect.getHeight() - height) / 2) );
+
+	// If height is odd, move the indicator down 1 pixel
+	if ( aIndicatorRect.getHeight() % 2 )
+		aIndicatorRect.setY( aIndicatorRect.getY() + 1 );
+
+	if ( pIndicatorSize )
+		g_free( pIndicatorSize );
+	if ( pIndicatorSpacing )
+		g_free( pIndicatorSpacing );
+
+	return( aIndicatorRect );
+}
+
+
+/************************************************************************
+ * Create a GdkPixmap filled with the contents of an area of an Xlib window
+ ************************************************************************/
+
+GdkPixmap* GtkSalGraphics::NWGetPixmapFromScreen( Rectangle srcRect )
+{
+    // Create a new pixmap to hold the composite of the window background and the control
+    GdkPixmap * pPixmap		= gdk_pixmap_new( NULL, srcRect.getWidth(), srcRect.getHeight(), 
+                                              GetSalData()->GetDisplay()->GetVisual()->GetDepth() );
+    GdkGC *	 pPixmapGC	= gdk_gc_new( pPixmap );
+
+    if( !pPixmap || !pPixmapGC )
+    {
+        if ( pPixmap )
+            g_object_unref( pPixmap );
+        if ( pPixmapGC )
+            g_object_unref( pPixmapGC );
+        fprintf( stderr, "salnativewidgets-gtk.cxx: could not get valid pixmap from screen\n" );
+        return( NULL );
+    }
+
+    // Copy the background of the screen into a composite pixmap
+    XCopyArea( GetXDisplay(), GetDrawable(), gdk_x11_drawable_get_xid(pPixmap), gdk_x11_gc_get_xgc(pPixmapGC),
+               srcRect.getX(), srcRect.getY(), srcRect.getWidth(), srcRect.getHeight(), 0, 0 );
+
+    g_object_unref( pPixmapGC );
+    return( pPixmap );
+}
+
+
+
+
+/************************************************************************
+ * Copy an alpha pixmap to screen using a gc with clipping
+ ************************************************************************/
+
+BOOL GtkSalGraphics::NWRenderPixmapToScreen( GdkPixmap* pPixmap, Rectangle dstRect )
+{
+    // The GC can't be null, otherwise we'd have no clip region
+    if( SelectFont() == NULL )
+    {
+        fprintf(stderr, "salnativewidgets.cxx: no valid GC\n" );
+        return( FALSE );
+    }
+
+    if ( !pPixmap )
+        return( FALSE );
+
+    // Copy the background of the screen into a composite pixmap
+    XCopyArea( GetXDisplay(), GDK_DRAWABLE_XID(pPixmap), GetDrawable(), SelectFont(),
+               0, 0, dstRect.getWidth(), dstRect.getHeight(), dstRect.getX(), dstRect.getY() );
+
+    X11SalGraphics::YieldGraphicsExpose( GetXDisplay(), NULL, GetDrawable() );
+    
+    return( TRUE );
+}
+
+
+/************************************************************************
+ * State conversion
+ ************************************************************************/
+static void NWConvertVCLStateToGTKState( ControlState nVCLState,
+			GtkStateType* nGTKState, GtkShadowType* nGTKShadow )
+{
+	*nGTKShadow = GTK_SHADOW_OUT;
+	*nGTKState = GTK_STATE_INSENSITIVE;
+
+	if ( nVCLState & CTRL_STATE_ENABLED )
+	{
+		// Pressed button?
+		if ( nVCLState & CTRL_STATE_PRESSED )
+		{
+			*nGTKState = GTK_STATE_ACTIVE;
+			*nGTKShadow = GTK_SHADOW_IN;
+		}
+		else if ( nVCLState & CTRL_STATE_ROLLOVER )
+		{
+			*nGTKState = GTK_STATE_PRELIGHT;
+			*nGTKShadow = GTK_SHADOW_OUT;
+		}
+		else
+		{
+			*nGTKState = GTK_STATE_NORMAL;
+			*nGTKShadow = GTK_SHADOW_OUT;
+		}
+	}
+}
+
+
+/************************************************************************
+ * Widget ensure functions - make sure cached objects are valid
+ ************************************************************************/
+
+//-------------------------------------
+#if 0
+static void
+style_set_cb (GtkWidget *widget)
+{
+  g_print ("Here: %s\n", g_type_name_from_instance ((gpointer)widget));
+}
+#endif
+
+static void NWAddWidgetToCacheWindow( GtkWidget* widget )
+{
+	if ( !gCacheWindow || !gDumbContainer )
+	{
+		if ( !gCacheWindow )
+			gCacheWindow = gtk_window_new( GTK_WINDOW_TOPLEVEL );
+		if ( !gDumbContainer )
+			gDumbContainer = gtk_fixed_new();
+		gtk_container_add( GTK_CONTAINER(gCacheWindow), gDumbContainer );
+		gtk_widget_realize( gDumbContainer );
+		gtk_widget_realize( gCacheWindow );
+#if 0
+		gtk_widget_show( gCacheWindow );
+		gtk_widget_show( gDumbContainer );
+#endif		
+	}
+
+	gtk_container_add( GTK_CONTAINER(gDumbContainer), widget );
+	gtk_widget_realize( widget );
+#if 0
+	gtk_widget_show( widget );
+	g_signal_connect ( widget, "style-set", G_CALLBACK (style_set_cb), NULL);
+#endif
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKButton( void )
+{
+	if ( !gBtnWidget )
+	{
+		gBtnWidget = gtk_button_new_with_label( "" );
+		NWAddWidgetToCacheWindow( gBtnWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKRadio( void )
+{
+	if ( !gRadioWidget )
+	{
+		gRadioWidget = gtk_radio_button_new( NULL );
+		NWAddWidgetToCacheWindow( gRadioWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKCheck( void )
+{
+	if ( !gCheckWidget )
+	{
+		gCheckWidget = gtk_check_button_new();
+		NWAddWidgetToCacheWindow( gCheckWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKScrollbars( void )
+{
+	if ( !gScrollHorizWidget )
+	{
+		gScrollHorizWidget = gtk_hscrollbar_new( NULL );
+		NWAddWidgetToCacheWindow( gScrollHorizWidget );
+	}
+
+	if ( !gScrollVertWidget )
+	{
+		gScrollVertWidget = gtk_vscrollbar_new( NULL );
+		NWAddWidgetToCacheWindow( gScrollVertWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKArrow( void )
+{
+	if ( !gArrowWidget || !gDropdownWidget )
+	{
+		gDropdownWidget = gtk_toggle_button_new();
+		NWAddWidgetToCacheWindow( gDropdownWidget );
+		gArrowWidget = gtk_arrow_new( GTK_ARROW_DOWN, GTK_SHADOW_OUT );
+		gtk_container_add( GTK_CONTAINER(gDropdownWidget), gArrowWidget );
+		gtk_widget_set_rc_style( gArrowWidget );
+		gtk_widget_realize( gArrowWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKEditBox( void )
+{
+	if ( !gEditBoxWidget )
+	{
+		gEditBoxWidget = gtk_entry_new();
+		NWAddWidgetToCacheWindow( gEditBoxWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKSpinButton( void )
+{
+	if ( !gSpinButtonWidget )
+	{
+		GtkAdjustment *adj = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+		gSpinButtonWidget = gtk_spin_button_new( adj, 1, 2 );
+		NWAddWidgetToCacheWindow( gSpinButtonWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKNotebook( void )
+{
+	if ( !gNotebookWidget )
+	{
+		gNotebookWidget = gtk_notebook_new();
+		NWAddWidgetToCacheWindow( gNotebookWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKOptionMenu( void )
+{
+	if ( !gOptionMenuWidget )
+	{
+		gOptionMenuWidget = gtk_option_menu_new();
+		NWAddWidgetToCacheWindow( gOptionMenuWidget );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKCombo( void )
+{
+	if ( !gComboWidget )
+	{
+		gComboWidget = gtk_combo_new();
+		NWAddWidgetToCacheWindow( gComboWidget );
+		// Must realize the ComboBox's button widget, since GTK
+		// does not do this for us in GtkCombo::gtk_widget_realize()
+		gtk_widget_realize( GTK_COMBO(gComboWidget)->button );
+	}
+}
+
+//-------------------------------------
+
+static void NWEnsureGTKScrolledWindow( void )
+{
+	if ( !gScrolledWindowWidget )
+	{
+		GtkAdjustment *hadj = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+		GtkAdjustment *vadj = GTK_ADJUSTMENT( gtk_adjustment_new(0, 0, 0, 0, 0, 0) );
+
+		gScrolledWindowWidget = gtk_scrolled_window_new( hadj, vadj );
+		NWAddWidgetToCacheWindow( gScrolledWindowWidget );
+	}
+}
Index: vcl/unx/gtk/window/gtkframe.cxx
===================================================================
RCS file: vcl/unx/gtk/window/gtkframe.cxx
diff -N vcl/unx/gtk/window/gtkframe.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/window/gtkframe.cxx	17 Jun 2004 12:48:23 -0000	1.6
@@ -0,0 +1,1810 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <plugins/gtk/gtkframe.hxx>
+#include <plugins/gtk/gtkdata.hxx>
+#include <plugins/gtk/gtkinst.hxx>
+#include <plugins/gtk/gtkgdi.hxx>
+#include <keycodes.hxx>
+#include <wmadaptor.hxx>
+#include <salbmp.h>
+#include <floatwin.hxx>
+
+#include <prex.h>
+#include <X11/Xatom.h>
+#include <postx.h>
+
+#include <dlfcn.h>
+#include <soicon.hxx>
+
+#if OSL_DEBUG_LEVEL > 1
+#include <cstdio>
+#endif
+
+int GtkSalFrame::m_nFloats = 0;
+
+static USHORT GetModCode( guint state )
+{
+    USHORT nCode = 0;
+    if( (state & GDK_SHIFT_MASK) )
+        nCode |= KEY_SHIFT;
+    if( (state & GDK_CONTROL_MASK) )
+        nCode |= KEY_MOD1;
+    if( (state & GDK_MOD1_MASK) )
+	{
+        nCode |= KEY_MOD2;
+		if( (state & GDK_MOD1_MASK) )
+			nCode |= KEY_CONTROLMOD;
+	}
+    if( (state & GDK_BUTTON1_MASK) )
+        nCode |= MOUSE_LEFT;
+    if( (state & GDK_BUTTON2_MASK) )
+        nCode |= MOUSE_MIDDLE;
+    if( (state & GDK_BUTTON3_MASK) )
+        nCode |= MOUSE_RIGHT;
+    return nCode;
+}
+
+static USHORT GetKeyCode( guint keyval )
+{
+    USHORT nCode = 0;
+    if( keyval >= GDK_0 && keyval <= GDK_9 )
+        nCode = KEY_0 + (keyval-GDK_0);
+    else if( keyval >= GDK_A && keyval <= GDK_Z )
+        nCode = KEY_A + (keyval-GDK_A );
+    else if( keyval >= GDK_a && keyval <= GDK_z )
+        nCode = KEY_A + (keyval-GDK_a );
+    else if( keyval >= GDK_F1 && keyval <= GDK_F26 )
+        nCode = KEY_F1 + (keyval-GDK_F1);
+    
+    {
+        switch( keyval )
+        {
+            case GDK_KP_Down:
+            case GDK_Down:			nCode = KEY_DOWN;		break;
+            case GDK_KP_Up:
+            case GDK_Up:			nCode = KEY_UP;			break;
+            case GDK_KP_Left:
+            case GDK_Left:			nCode = KEY_LEFT;		break;
+            case GDK_KP_Right:
+            case GDK_Right:			nCode =	KEY_RIGHT;		break;
+            case GDK_KP_Home:
+            case GDK_Home:			nCode = KEY_HOME;		break;
+            case GDK_KP_End:
+            case GDK_End:			nCode = KEY_END;		break;
+            case GDK_KP_Page_Up:
+            case GDK_Page_Up:		nCode = KEY_PAGEUP;		break;
+            case GDK_KP_Page_Down:
+            case GDK_Page_Down:		nCode = KEY_PAGEDOWN;	break;
+            case GDK_KP_Enter:
+            case GDK_Return:		nCode = KEY_RETURN;		break;
+            case GDK_Escape:		nCode = KEY_ESCAPE;		break;
+            case GDK_ISO_Left_Tab:
+            case GDK_KP_Tab:
+            case GDK_Tab:			nCode = KEY_TAB;		break;
+            case GDK_BackSpace:		nCode = KEY_BACKSPACE;	break;
+            case GDK_KP_Space:
+            case GDK_space:			nCode = KEY_SPACE;		break;
+            case GDK_Insert:		nCode = KEY_INSERT;		break;
+            case GDK_Delete:		nCode = KEY_DELETE;		break;
+            case GDK_KP_Add:		nCode = KEY_ADD;		break;
+            case GDK_KP_Subtract:	nCode = KEY_SUBTRACT;	break;
+            case GDK_KP_Multiply:	nCode = KEY_MULTIPLY;	break;
+            case GDK_KP_Divide:		nCode = KEY_DIVIDE;		break;
+            case GDK_period:
+            case GDK_decimalpoint:	nCode = KEY_POINT;		break;
+            case GDK_comma:			nCode = KEY_COMMA;		break;
+            case GDK_less:			nCode = KEY_LESS;		break;
+            case GDK_greater:		nCode = KEY_GREATER;	break;
+            case GDK_equal:			nCode = KEY_EQUAL;		break;
+            case GDK_Find:			nCode = KEY_FIND;		break;
+            case GDK_Menu:			nCode = KEY_MENU;		break;
+            case GDK_Help:			nCode = KEY_HELP;		break;
+            case GDK_Undo:			nCode = KEY_UNDO;		break;
+        }
+    }
+    return nCode;
+}
+
+static USHORT GetCharCodeFromUnicode( sal_Unicode cCode )
+{
+    USHORT nRet = 0;
+    
+    if( cCode >= '0' && cCode <= '9' )
+        nRet = KEY_0 + (cCode - '0');
+    else if( cCode >= 'a' && cCode <= 'z' )
+        nRet = KEY_A + (cCode -'a' );
+    else if( cCode >= 'A' && cCode <= 'Z' )
+        nRet = KEY_A + (cCode -'A' );
+    else if( cCode == ' ' )
+        nRet = KEY_SPACE;
+    else if( cCode == '+' )
+        nRet = KEY_ADD;
+    else if( cCode == '-' )
+        nRet = KEY_SUBTRACT;
+    else if( cCode == '*' )
+        nRet = KEY_MULTIPLY;
+    else if( cCode == '/' )
+        nRet = KEY_DIVIDE;
+    else if( cCode == '.' )
+        nRet = KEY_POINT;
+    else if( cCode == ',' )
+        nRet = KEY_COMMA;
+    else if( cCode == '<' )
+        nRet = KEY_LESS;
+    else if( cCode == '>' )
+        nRet = KEY_GREATER;
+    else if( cCode == '=' )
+        nRet = KEY_EQUAL;
+    
+    return nRet;
+}
+
+GtkSalFrame::GraphicsHolder::~GraphicsHolder()
+{
+    delete pGraphics;
+}
+
+GtkSalFrame::GtkSalFrame( SalFrame* pParent, ULONG nStyle )
+{
+	getDisplay()->registerFrame( this );
+    Init( pParent, nStyle );
+}
+
+GtkSalFrame::GtkSalFrame( SystemParentData* pSysData )
+{
+	getDisplay()->registerFrame( this );
+    getDisplay()->setHaveSystemChildFrame();
+    Init( pSysData );
+}
+
+GtkSalFrame::~GtkSalFrame()
+{
+	getDisplay()->deregisterFrame( this );
+    if( m_pIMContext )
+    {
+        gtk_im_context_reset( m_pIMContext );
+        gtk_im_context_set_client_window( m_pIMContext, NULL );
+        g_object_unref( m_pIMContext );
+    }
+    if( m_pFixedContainer )
+        gtk_widget_destroy( GTK_WIDGET(m_pFixedContainer) );
+    if( m_pWindow )
+        gtk_widget_destroy( GTK_WIDGET(m_pWindow) );
+    if( m_pForeignParent )
+        gdk_window_destroy( m_pForeignParent );
+    if( m_pForeignTopLevel )
+        gdk_window_destroy( m_pForeignTopLevel );
+}
+
+void GtkSalFrame::InitCommon()
+{
+    // connect signals
+    g_signal_connect( G_OBJECT(m_pWindow), "style-set", G_CALLBACK(signalStyleSet), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "button-press-event", G_CALLBACK(signalButton), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "button-release-event", G_CALLBACK(signalButton), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "expose-event", G_CALLBACK(signalExpose), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "focus-in-event", G_CALLBACK(signalFocus), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "focus-out-event", G_CALLBACK(signalFocus), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "map-event", G_CALLBACK(signalMap), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "unmap-event", G_CALLBACK(signalUnmap), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "configure-event", G_CALLBACK(signalConfigure), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "motion-notify-event", G_CALLBACK(signalMotion), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "key-press-event", G_CALLBACK(signalKey), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "key-release-event", G_CALLBACK(signalKey), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "delete-event", G_CALLBACK(signalDelete), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "window-state-event", G_CALLBACK(signalState), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "scroll-event", G_CALLBACK(signalScroll), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "leave-notify-event", G_CALLBACK(signalCrossing), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "enter-notify-event", G_CALLBACK(signalCrossing), this );
+    g_signal_connect( G_OBJECT(m_pWindow), "visibility-notify-event", G_CALLBACK(signalVisibility), this );
+
+    // init members
+	m_pCurrentCursor    = NULL;
+	m_nKeyModifiers     = 0;
+	m_bSingleAltPress   = false;
+    m_bResizeable		= true;
+    m_bDefaultPos		= true;
+    m_bDefaultSize		= ( (m_nStyle & SAL_FRAME_STYLE_SIZEABLE) && ! m_pParent );
+    m_nState			= GDK_WINDOW_STATE_WITHDRAWN;
+    m_nVisibility		= GDK_VISIBILITY_FULLY_OBSCURED;
+	m_bSendModChangeOnRelease = false;
+    m_pIMContext		= NULL;
+    m_bWasPreedit		= false;
+    // delete graphics if InitCommon is called not from destructor
+    for( int i = 0; i < nMaxGraphics; i++ )
+    {
+        m_aGraphics[i].bInUse = false;
+        delete m_aGraphics[i].pGraphics;
+        m_aGraphics[i].pGraphics = NULL;
+    }
+    
+    gtk_widget_set_app_paintable( GTK_WIDGET(m_pWindow), TRUE );
+    gtk_widget_set_double_buffered( GTK_WIDGET(m_pWindow), FALSE );
+    gtk_widget_set_redraw_on_allocate( GTK_WIDGET(m_pWindow), FALSE );
+
+    // realize the window, we need an XWindow id
+    gtk_widget_realize( GTK_WIDGET(m_pWindow) );
+
+    // add the fixed container child,
+    // fixed is needed since we have to position plugin windows
+    m_pFixedContainer = GTK_FIXED(gtk_fixed_new());
+    gtk_container_add( GTK_CONTAINER(m_pWindow), GTK_WIDGET(m_pFixedContainer) );
+    gtk_widget_show( GTK_WIDGET(m_pFixedContainer) );
+
+    //system data
+    SalDisplay* pDisp = GetSalData()->GetDisplay();
+    m_aSystemData.pDisplay		= pDisp->GetDisplay();
+    m_aSystemData.aWindow		= GDK_WINDOW_XWINDOW(GTK_WIDGET(m_pWindow)->window);
+    m_aSystemData.pSalFrame		= this;
+    m_aSystemData.pWidget		= GTK_WIDGET(m_pWindow);
+    m_aSystemData.pVisual		= pDisp->GetVisual()->GetVisual();
+    m_aSystemData.nDepth		= pDisp->GetVisual()->GetDepth();
+    m_aSystemData.aColormap		= pDisp->GetColormap().GetXColormap();
+    m_aSystemData.pAppContext	= NULL;
+    m_aSystemData.aShellWindow	= m_aSystemData.aWindow;
+    m_aSystemData.pShellWidget	= m_aSystemData.pWidget;
+
+    gtk_widget_add_events( GTK_WIDGET(m_pWindow),
+                           GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+                           GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK |
+                           GDK_VISIBILITY_NOTIFY_MASK
+                           );
+
+    // fake an initial geometry, gets updated via configure event or SetPosSize
+    Size aDefSize = calcDefaultSize();
+    maGeometry.nX					= -1;
+    maGeometry.nY					= -1;
+    maGeometry.nWidth				= aDefSize.Width();
+    maGeometry.nHeight				= aDefSize.Height();
+    if( m_pParent )
+    {
+        // approximation
+        maGeometry.nTopDecoration		= m_pParent->maGeometry.nTopDecoration;
+        maGeometry.nBottomDecoration	= m_pParent->maGeometry.nBottomDecoration;
+        maGeometry.nLeftDecoration		= m_pParent->maGeometry.nLeftDecoration;
+        maGeometry.nRightDecoration		= m_pParent->maGeometry.nRightDecoration;
+    }
+    else
+    {
+        maGeometry.nTopDecoration		= 0;
+        maGeometry.nBottomDecoration	= 0;
+        maGeometry.nLeftDecoration		= 0;
+        maGeometry.nRightDecoration		= 0;
+    }
+}
+
+void GtkSalFrame::Init( SalFrame* pParent, ULONG nStyle )
+{
+    if( nStyle & SAL_FRAME_STYLE_DEFAULT ) // ensure default style
+    {
+        nStyle |= SAL_FRAME_STYLE_MOVEABLE | SAL_FRAME_STYLE_SIZEABLE | SAL_FRAME_STYLE_CLOSEABLE;
+        nStyle &= ~SAL_FRAME_STYLE_FLOAT;
+    }
+    
+    m_pWindow = GTK_WINDOW( gtk_widget_new( GTK_TYPE_WINDOW, "type", (nStyle & SAL_FRAME_STYLE_FLOAT) ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL, "visible", FALSE, NULL ) );
+    m_pParent = static_cast<GtkSalFrame*>(pParent);
+    m_pForeignParent = NULL;
+    m_pForeignTopLevel = NULL;
+    m_nStyle = nStyle;
+
+	if( m_pParent && m_pParent->m_pWindow && ! (m_pParent->m_nStyle & SAL_FRAME_STYLE_CHILD) )
+		gtk_window_set_screen( m_pWindow, gtk_window_get_screen( m_pParent->m_pWindow ) );
+
+    InitCommon();
+
+    if( ! (nStyle & (SAL_FRAME_STYLE_FLOAT|SAL_FRAME_STYLE_CHILD)) )
+    {
+        m_bResizeable = (nStyle & SAL_FRAME_STYLE_SIZEABLE) != 0;
+        gtk_window_set_resizable( m_pWindow, m_bResizeable ? TRUE : FALSE );
+        gtk_window_set_gravity( m_pWindow, GDK_GRAVITY_STATIC );
+        if( (nStyle & SAL_FRAME_STYLE_INTRO) )
+            gtk_window_set_type_hint( m_pWindow, GDK_WINDOW_TYPE_HINT_SPLASHSCREEN );
+        else if( (nStyle & SAL_FRAME_STYLE_TOOLWINDOW ) )
+            gtk_window_set_type_hint( m_pWindow, GDK_WINDOW_TYPE_HINT_UTILITY );
+        if( ! (nStyle & (SAL_FRAME_STYLE_MOVEABLE | SAL_FRAME_STYLE_SIZEABLE | SAL_FRAME_STYLE_CLOSEABLE ) ) )
+            gtk_window_set_decorated( m_pWindow, FALSE );
+        if( m_pParent && ! (m_pParent->m_nStyle & SAL_FRAME_STYLE_CHILD) )
+            gtk_window_set_transient_for( m_pWindow, m_pParent->m_pWindow );
+    }
+}
+
+GdkNativeWindow GtkSalFrame::findTopLevelSystemWindow( GdkNativeWindow aWindow )
+{
+    int x_ret, y_ret;
+    unsigned int bw, d;
+    XLIB_Window aRoot, aParent;
+    XLIB_Window* pChildren;
+    unsigned int nChildren;
+    bool bBreak = false;
+    do
+    {
+        XQueryTree( getDisplay()->GetDisplay(), aWindow,
+                    &aRoot, &aParent, &pChildren, &nChildren );
+        XFree( pChildren );
+        if( aParent != aRoot )
+            aWindow = aParent;
+        int nCount = 0;
+        Atom* pProps = XListProperties( getDisplay()->GetDisplay(),
+                                        aWindow,
+                                        &nCount );
+        for( int i = 0; i < nCount && ! bBreak; ++i )
+            bBreak = (pProps[i] == XA_WM_HINTS);
+        if( pProps )
+            XFree( pProps );
+    } while( aParent != aRoot && ! bBreak );
+    
+    return aWindow;
+}
+
+void GtkSalFrame::Init( SystemParentData* pSysData )
+{
+    m_pParent = NULL;
+    m_pForeignParent = gdk_window_foreign_new_for_display( getGdkDisplay(), (GdkNativeWindow)pSysData->aWindow );
+    gdk_window_set_events( m_pForeignParent, GDK_STRUCTURE_MASK );
+    m_pForeignTopLevel = gdk_window_foreign_new_for_display( getGdkDisplay(), findTopLevelSystemWindow( (GdkNativeWindow)pSysData->aWindow ) );
+    gdk_window_set_events( m_pForeignTopLevel, GDK_STRUCTURE_MASK );
+    m_pWindow = GTK_WINDOW(gtk_window_new( GTK_WINDOW_POPUP ));
+    m_nStyle = SAL_FRAME_STYLE_CHILD;
+	InitCommon();
+    XReparentWindow( getDisplay()->GetDisplay(),
+                     GDK_WINDOW_XWINDOW(GTK_WIDGET(m_pWindow)->window),
+                     (XLIB_Window)pSysData->aWindow,
+                     0, 0 );
+}
+
+SalGraphics* GtkSalFrame::GetGraphics()
+{
+    if( m_pWindow )
+    {
+        for( int i = 0; i < nMaxGraphics; i++ )
+        {
+            if( ! m_aGraphics[i].bInUse )
+            {
+                m_aGraphics[i].bInUse = true;
+                if( ! m_aGraphics[i].pGraphics )
+                {
+                    m_aGraphics[i].pGraphics = new GtkSalGraphics(GTK_WIDGET( m_pWindow ));
+                    m_aGraphics[i].pGraphics->Init( this, GDK_WINDOW_XWINDOW(GTK_WIDGET(m_pWindow)->window) );
+                }
+                return m_aGraphics[i].pGraphics;
+            }
+        }
+    }
+    
+    return NULL;
+}
+
+void GtkSalFrame::ReleaseGraphics( SalGraphics* pGraphics )
+{
+    for( int i = 0; i < nMaxGraphics; i++ )
+    {
+        if( m_aGraphics[i].pGraphics == pGraphics )
+        {
+            m_aGraphics[i].bInUse = false;
+            break;
+        }
+    }
+}
+
+BOOL GtkSalFrame::PostEvent( void* pData )
+{
+	getDisplay()->SendInternalEvent( this, pData );
+	return TRUE;
+}
+
+void GtkSalFrame::SetTitle( const String& rTitle )
+{
+    if( m_pWindow && !(m_nStyle & SAL_FRAME_STYLE_CHILD))
+        gtk_window_set_title( m_pWindow, rtl::OUStringToOString( rTitle, RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+void GtkSalFrame::SetIcon( USHORT nIcon )
+{
+    if( m_nStyle & SAL_FRAME_STYLE_CHILD )
+        return;
+
+	GList *pPixbufs = NULL;
+
+    // pl: evil ? don't be scared so easily :-)
+	{ // Begin this unutterably evil; we need to pass a nice handle down
+	    VCL_CUSTOM_ICON_FN *pCustomIcon = 0;
+		char *pSymbol = g_strdup_printf ("%s%d", VCL_CUSTOM_ICON_BASE, nIcon );
+		void *pAppHdl = dlopen( NULL, RTLD_LAZY );
+		if ( ( pCustomIcon = ( VCL_CUSTOM_ICON_FN* ) dlsym( pAppHdl, pSymbol ) ) )
+		{
+			char **pIcons[4] = { NULL, NULL, NULL, NULL };
+			pCustomIcon( pIcons[0], pIcons[1], pIcons[2], pIcons[3] );
+			for( int i = 0; i < 4; i++)
+			{
+                if( pIcons[i] )
+                {
+                    GdkPixbuf *pPixbuf = gdk_pixbuf_new_from_xpm_data( (const char **) pIcons[i] );
+                    pPixbufs = g_list_prepend( pPixbufs, pPixbuf );
+                }
+			}
+		}
+		g_free( pSymbol );
+		dlclose( pAppHdl );
+	} // End evilness
+
+	gtk_window_set_icon_list( m_pWindow, pPixbufs );
+
+	g_list_foreach( pPixbufs, (GFunc) g_object_unref, NULL );
+	g_list_free( pPixbufs );
+}
+
+void GtkSalFrame::SetMenu( SalMenu* pSalMenu )
+{
+}
+
+void GtkSalFrame::DrawMenuBar()
+{
+}
+
+void GtkSalFrame::Center()
+{
+    long nX, nY;
+
+    if( m_pParent )
+    {
+        nX = ((long)m_pParent->maGeometry.nWidth - (long)maGeometry.nWidth)/2;
+        nY = ((long)m_pParent->maGeometry.nHeight - (long)maGeometry.nHeight)/2;
+        
+    }
+    else
+    {
+        long	nScreenWidth, nScreenHeight;
+        long	nScreenX = 0, nScreenY = 0;
+
+        nScreenWidth		= GetSalData()->GetDisplay()->GetScreenSize().Width();
+        nScreenHeight		= GetSalData()->GetDisplay()->GetScreenSize().Height();
+        if( GetSalData()->GetDisplay()->IsXinerama() )
+        {
+            // get xinerama screen we are on
+            // if there is a parent, use its center for screen determination
+            // else use the pointer
+            GdkScreen* pScreen;
+            gint x, y;
+            GdkModifierType aMask;
+            gdk_display_get_pointer( getGdkDisplay(), &pScreen, &x, &y, &aMask );
+
+            const std::vector< Rectangle >& rScreens = GetSalData()->GetDisplay()->GetXineramaScreens();
+            for( int i = 0; i < rScreens.size(); i++ )
+                if( rScreens[i].IsInside( Point( x, y ) ) )
+                {
+                    nScreenX			= rScreens[i].Left();
+                    nScreenY			= rScreens[i].Top();
+                    nScreenWidth		= rScreens[i].GetWidth();
+                    nScreenHeight		= rScreens[i].GetHeight();
+                    break;
+                }
+        }
+        nX = nScreenX + (nScreenWidth - (long)maGeometry.nWidth)/2;
+        nY = nScreenY + (nScreenHeight - (long)maGeometry.nHeight)/2;
+    }
+    SetPosSize( nX, nY, 0, 0, SAL_FRAME_POSSIZE_X | SAL_FRAME_POSSIZE_Y );		
+}
+
+Size GtkSalFrame::calcDefaultSize()
+{
+    const Size& rScreenSize( getDisplay()->GetScreenSize() );
+    long w = rScreenSize.Width();
+    long h = rScreenSize.Height();
+
+    // fill in holy default values brought to us by product management
+    if( rScreenSize.Width() >= 800 )
+        w = 785;
+    if( rScreenSize.Width() >= 1024 )
+        w = 920;
+    
+    if( rScreenSize.Height() >= 600 )
+        h = 550;
+    if( rScreenSize.Height() >= 768 )
+        h = 630;
+    if( rScreenSize.Height() >= 1024 )
+        h = 875;
+
+    return Size( w, h );
+}
+
+void GtkSalFrame::SetDefaultSize()
+{
+    Size aDefSize = calcDefaultSize();
+    
+    SetPosSize( 0, 0, aDefSize.Width(), aDefSize.Height(),
+                SAL_FRAME_POSSIZE_WIDTH | SAL_FRAME_POSSIZE_HEIGHT );
+
+    if( m_nStyle & SAL_FRAME_STYLE_DEFAULT )
+        gtk_window_maximize( m_pWindow );
+}
+
+void GtkSalFrame::Show( BOOL bVisible, BOOL bNoActivate )
+{
+    if( m_pWindow )
+    {
+        if( bVisible )
+        {
+            if( m_bDefaultPos )
+                Center();
+            if( m_bDefaultSize )
+                SetDefaultSize();
+
+            gtk_widget_show( GTK_WIDGET(m_pWindow) );
+            if( isFloatGrabWindow() )
+            {
+                m_nFloats++;
+                if( ! getDisplay()->GetCaptureFrame() && m_nFloats == 1 )
+                    grabPointer( TRUE, TRUE );
+            }
+        }
+        else
+        {
+            if( isFloatGrabWindow() )
+            {
+                m_nFloats--;
+                if( ! getDisplay()->GetCaptureFrame() && m_nFloats == 0)
+                    grabPointer( FALSE );
+            }
+            gtk_widget_hide( GTK_WIDGET(m_pWindow) );
+            if( m_pIMContext )
+            {
+                gtk_im_context_focus_out( m_pIMContext );
+                gtk_im_context_reset( m_pIMContext );
+            }
+        }
+    }
+}
+
+void GtkSalFrame::Enable( BOOL bEnable )
+{
+	// Not implemented by X11SalFrame either
+}
+
+void GtkSalFrame::SetMinClientSize( long nWidth, long nHeight )
+{
+    if( m_pWindow )
+        gtk_widget_set_size_request( GTK_WIDGET(m_pWindow), nWidth, nHeight );
+}
+
+void GtkSalFrame::SetPosSize( long nX, long nY, long nWidth, long nHeight, USHORT nFlags )
+{
+    if( !m_pWindow || (m_nStyle & SAL_FRAME_STYLE_CHILD) )
+		return;
+
+	if( (nFlags & ( SAL_FRAME_POSSIZE_WIDTH | SAL_FRAME_POSSIZE_HEIGHT )) &&
+		(nWidth > 0 && nHeight > 0 ) // sometimes stupid things happen
+            )
+	{
+#if OSL_DEBUG_LEVEL > 1
+		if( nWidth < 2 || nWidth > 2000 || nHeight < 2 || nHeight > 2000 )
+		{
+			fprintf( stderr, "Discarding bad size: %d, %d\n", nWidth, nHeight );
+			return;
+		}
+#endif
+        m_bDefaultSize = false;
+		gtk_window_resize( m_pWindow, nWidth, nHeight );
+		if( ! m_bResizeable )
+		{
+			GdkGeometry aGeo;
+			aGeo.min_width = aGeo.max_width = nWidth;
+			aGeo.min_height = aGeo.max_height = nHeight;
+			gtk_window_set_geometry_hints( m_pWindow,
+                                           NULL,
+                                           &aGeo,
+                                           (GdkWindowHints)( GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE ) );
+		}
+
+		maGeometry.nWidth	= nWidth;
+		maGeometry.nHeight	= nHeight;
+	}
+    else if( m_bDefaultSize )
+        SetDefaultSize();
+
+    m_bDefaultSize = false;
+
+	if( nFlags & ( SAL_FRAME_POSSIZE_X | SAL_FRAME_POSSIZE_Y ) )
+	{
+#if OSL_DEBUG_LEVEL > 1
+		if( std::abs( nX ) > 2000 || std::abs( nY ) > 2000 )
+		{
+			fprintf( stderr, "Discarding bad pos: %d, %d\n", nX, nY );
+            return;
+		}
+#endif
+		if( m_pParent )
+		{
+			nX += m_pParent->maGeometry.nX;
+			nY += m_pParent->maGeometry.nY;
+		}
+
+        // adjust position to avoid off screen windows
+        Size aScreenSize = GetSalData()->GetDisplay()->GetScreenSize();
+        if( nX < (long)maGeometry.nLeftDecoration )
+            nX = maGeometry.nLeftDecoration;
+        if( nY < (long)maGeometry.nTopDecoration )
+            nY = maGeometry.nTopDecoration;
+        if( (nX + (long)maGeometry.nWidth + (long)maGeometry.nRightDecoration) > (long)aScreenSize.Width() )
+            nX = aScreenSize.Width() - maGeometry.nWidth - maGeometry.nRightDecoration;
+        if( (nY + (long)maGeometry.nHeight + (long)maGeometry.nBottomDecoration) > (long)aScreenSize.Height() )
+            nY = aScreenSize.Height() - maGeometry.nHeight - maGeometry.nBottomDecoration;
+
+		m_bDefaultPos = false;
+		gtk_window_move( m_pWindow, nX, nY );
+		maGeometry.nX = nX;
+		maGeometry.nY = nY;
+	}
+	else if( m_bDefaultPos )
+		Center();
+
+	m_bDefaultPos = false;
+}
+
+void GtkSalFrame::GetClientSize( long& rWidth, long& rHeight )
+{
+    if( GTK_WIDGET_MAPPED( GTK_WIDGET(m_pWindow) ) )
+    {
+        rWidth = maGeometry.nWidth;
+        rHeight = maGeometry.nHeight;
+    }
+    else
+        rWidth = rHeight = 0;
+}
+
+void GtkSalFrame::GetWorkArea( Rectangle& rRect )
+{
+    rRect = GetSalData()->GetDisplay()->getWMAdaptor()->getWorkArea( 0 );
+}
+
+SalFrame* GtkSalFrame::GetParent() const
+{
+    return m_pParent;
+}
+
+void GtkSalFrame::SetWindowState( const SalFrameState* pState )
+{
+    if( ! m_pWindow || ! pState || (m_nStyle & SAL_FRAME_STYLE_CHILD) )
+        return;
+
+    if( pState->mnMask & (SAL_FRAMESTATE_MASK_X | SAL_FRAMESTATE_MASK_Y | SAL_FRAMESTATE_MASK_WIDTH | SAL_FRAMESTATE_MASK_HEIGHT ) )
+    {
+        USHORT nPosSizeFlags = 0;
+        long nX			= pState->mnX - (m_pParent ? m_pParent->maGeometry.nX : 0);
+        long nY			= pState->mnY - (m_pParent ? m_pParent->maGeometry.nY : 0);
+        long nWidth		= pState->mnWidth;
+        long nHeight	= pState->mnHeight;
+        if( pState->mnMask & SAL_FRAMESTATE_MASK_X )
+            nPosSizeFlags |= SAL_FRAME_POSSIZE_X;
+        else
+            nX = maGeometry.nX - (m_pParent ? m_pParent->maGeometry.nX : 0);
+        if( pState->mnMask & SAL_FRAMESTATE_MASK_Y )
+            nPosSizeFlags |= SAL_FRAME_POSSIZE_Y;
+        else
+            nY = maGeometry.nY - (m_pParent ? m_pParent->maGeometry.nY : 0);
+        if( pState->mnMask & SAL_FRAMESTATE_MASK_WIDTH )
+            nPosSizeFlags |= SAL_FRAME_POSSIZE_WIDTH;
+        else
+            nWidth = maGeometry.nWidth;
+        if( pState->mnMask & SAL_FRAMESTATE_MASK_HEIGHT )
+            nPosSizeFlags |= SAL_FRAME_POSSIZE_HEIGHT;
+        else
+            nHeight = maGeometry.nHeight;
+        SetPosSize( nX, nY, pState->mnWidth, pState->mnHeight, nPosSizeFlags );
+    }
+    if( pState->mnMask & SAL_FRAMESTATE_MASK_STATE )
+    {
+        if( pState->mnState & SAL_FRAMESTATE_MAXIMIZED )
+            gtk_window_maximize( m_pWindow );
+        if( pState->mnState & SAL_FRAMESTATE_MINIMIZED )
+            gtk_window_iconify( m_pWindow );
+    }
+}
+
+BOOL GtkSalFrame::GetWindowState( SalFrameState* pState )
+{
+    pState->mnState = SAL_FRAMESTATE_NORMAL;
+    if( (m_nState & GDK_WINDOW_STATE_ICONIFIED) )
+        pState->mnState |= SAL_FRAMESTATE_MINIMIZED;
+    if( m_nState & GDK_WINDOW_STATE_MAXIMIZED )
+        pState->mnState |= SAL_FRAMESTATE_MAXIMIZED;
+    // rollup ? gtk 2.2 does not seem to support the shaded state
+
+    pState->mnX			= maGeometry.nX;
+    pState->mnY			= maGeometry.nY;
+    pState->mnWidth		= maGeometry.nWidth;
+    pState->mnHeight	= maGeometry.nHeight;
+    pState->mnMask		=
+        SAL_FRAMESTATE_MASK_X			|
+        SAL_FRAMESTATE_MASK_Y			|
+        SAL_FRAMESTATE_MASK_WIDTH		|
+        SAL_FRAMESTATE_MASK_HEIGHT		|
+        SAL_FRAMESTATE_MASK_STATE;
+
+#if OSL_DEBUG_LEVEL > 1
+    if( std::abs( maGeometry.nX ) > 2000 || std::abs( maGeometry.nY ) > 2000 )
+    {
+        fprintf( stderr, "bad pos in GetWindowState: %d, %d\n", maGeometry.nX, maGeometry.nY );
+        abort();
+    }
+    if( maGeometry.nWidth < 2 || maGeometry.nWidth > 2000 || maGeometry.nHeight < 2 || maGeometry.nHeight > 2000 )
+    {
+        fprintf( stderr, "bad size in GetWindowState: %d, %d\n", maGeometry.nWidth, maGeometry.nHeight );
+        abort();
+    }
+#endif
+
+    return TRUE;
+}
+
+void GtkSalFrame::ShowFullScreen( BOOL bFullScreen )
+{
+    if( m_pWindow && ! (m_nStyle & SAL_FRAME_STYLE_CHILD) )
+    {
+        if( bFullScreen )
+        {
+            if( ! m_bResizeable )
+                gtk_window_set_resizable( m_pWindow, TRUE );
+            gtk_window_fullscreen( m_pWindow );
+        }
+        else
+        {
+            gtk_window_unfullscreen( m_pWindow );
+            if( ! m_bResizeable )
+                gtk_window_set_resizable( m_pWindow, FALSE );
+        }
+    }
+}
+
+/* definitions from xautolock.c (pl15) */
+#define XAUTOLOCK_DISABLE 1
+#define XAUTOLOCK_ENABLE  2
+
+void GtkSalFrame::setAutoLock( bool bLock )
+{
+	GdkScreen  *pScreen = gtk_window_get_screen( m_pWindow );
+	GdkDisplay *pDisplay = gdk_screen_get_display( pScreen );
+	GdkWindow  *pRootWin = gdk_screen_get_root_window( pScreen );
+
+	Atom nAtom = XInternAtom( GDK_DISPLAY_XDISPLAY( pDisplay ),
+							  "XAUTOLOCK_MESSAGE", False );
+
+	int nMessage = bLock ? XAUTOLOCK_ENABLE : XAUTOLOCK_DISABLE;
+
+	XChangeProperty( GDK_DISPLAY_XDISPLAY( pDisplay ),
+					 GDK_WINDOW_XID( pRootWin ),
+					 nAtom, XA_INTEGER,
+					 8, PropModeReplace,
+					 (unsigned char*)&nMessage,
+					 sizeof( nMessage ) );
+}
+
+void GtkSalFrame::StartPresentation( BOOL bStart )
+{
+	Display *pDisplay = GDK_DISPLAY_XDISPLAY( getGdkDisplay() );
+
+	setAutoLock( !bStart );
+
+	int nTimeout, nInterval, bPreferBlanking, bAllowExposures;
+
+	XGetScreenSaver( pDisplay, &nTimeout, &nInterval,
+					 &bPreferBlanking, &bAllowExposures );
+	if( bStart )
+	{
+		if ( nTimeout )
+		{
+			m_nSavedScreenSaverTimeout = nTimeout;
+			XResetScreenSaver( pDisplay );
+			XSetScreenSaver( pDisplay, 0, nInterval,
+							 bPreferBlanking, bAllowExposures );
+		}
+	}
+	else
+	{
+		if( m_nSavedScreenSaverTimeout )
+			XSetScreenSaver( pDisplay, m_nSavedScreenSaverTimeout,
+							 nInterval, bPreferBlanking,
+							 bAllowExposures );
+		m_nSavedScreenSaverTimeout = 0;
+	}	
+}
+
+void GtkSalFrame::SetAlwaysOnTop( BOOL bOnTop )
+{
+}
+
+void GtkSalFrame::ToTop( USHORT nFlags )
+{
+    if( m_pWindow )
+    {
+        if( GTK_WIDGET_MAPPED( GTK_WIDGET(m_pWindow ) ) )
+        {
+            if( ! SAL_FRAME_TOTOP_GRABFOCUS_ONLY )
+                gtk_window_present( m_pWindow );
+            else
+                gdk_window_focus( GTK_WIDGET(m_pWindow)->window, GDK_CURRENT_TIME );
+        }
+        else
+        {
+            if( nFlags & SAL_FRAME_TOTOP_RESTOREWHENMIN )
+                gtk_window_present( m_pWindow );
+        }
+    }
+}
+
+void GtkSalFrame::SetPointer( PointerStyle ePointerStyle )
+{
+	GdkCursor *pCursor = getDisplay()->getCursor( ePointerStyle );
+	gdk_window_set_cursor( GTK_WIDGET(m_pWindow)->window, pCursor );
+	m_pCurrentCursor = pCursor;
+}
+
+void GtkSalFrame::grabPointer( BOOL bGrab, BOOL bOwnerEvents )
+{
+	int nMask = ( GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK | GDK_POINTER_MOTION_HINT_MASK );
+	GdkGrabStatus nStatus;
+
+	if( bGrab )
+		nStatus = gdk_pointer_grab
+				( GTK_WIDGET(m_pWindow)->window, bOwnerEvents,
+				  (GdkEventMask) nMask, NULL, m_pCurrentCursor,
+				  GDK_CURRENT_TIME );
+	else
+	{
+		// Two GdkDisplays may be open
+		gdk_display_pointer_ungrab( getGdkDisplay(), GDK_CURRENT_TIME);
+	}
+}
+
+void GtkSalFrame::CaptureMouse( BOOL bCapture )
+{
+	getDisplay()->CaptureMouse( bCapture ? this : NULL );
+}
+
+void GtkSalFrame::SetPointerPos( long nX, long nY )
+{
+	GdkScreen *pScreen = gtk_window_get_screen( m_pWindow );
+	GdkDisplay *pDisplay = gdk_screen_get_display( pScreen );
+
+    /* #87921# when the application tries to center the mouse in the dialog the
+     * window isn't mapped already. So use coordinates relative to the root window.
+     */
+    unsigned int nWindowLeft = maGeometry.nX + nX;
+    unsigned int nWindowTop  = maGeometry.nY + nY;
+
+    XWarpPointer( GDK_DISPLAY_XDISPLAY (pDisplay), None,
+				  GDK_WINDOW_XID (gdk_screen_get_root_window( pScreen ) ),
+                  0, 0, 0, 0, nWindowLeft, nWindowTop);
+}
+
+void GtkSalFrame::Flush()
+{
+#ifdef HAVE_A_RECENT_GTK
+	gdk_display_flush( getGdkDisplay() );
+#else
+    XFlush (GDK_DISPLAY_XDISPLAY (getGdkDisplay()));
+#endif
+}
+
+void GtkSalFrame::Sync()
+{
+	gdk_display_sync( getGdkDisplay() );
+}
+
+String GtkSalFrame::GetSymbolKeyName( const String&, USHORT nKeyCode )
+{
+  return getDisplay()->GetKeyName( nKeyCode );
+}
+
+String GtkSalFrame::GetKeyName( USHORT nKeyCode )
+{
+	return getDisplay()->GetKeyName( nKeyCode );
+}
+
+GdkDisplay *GtkSalFrame::getGdkDisplay()
+{
+    return static_cast<GtkSalDisplay*>(GetSalData()->GetDisplay())->GetGdkDisplay();
+}
+
+GtkSalDisplay *GtkSalFrame::getDisplay()
+{
+	return static_cast<GtkSalDisplay*>(GetSalData()->GetDisplay());
+}
+
+ULONG GtkSalFrame::GetCurrentModButtons()
+{
+    GdkScreen* pScreen;
+    gint x, y;
+    GdkModifierType aMask;
+    gdk_display_get_pointer( getGdkDisplay(), &pScreen, &x, &y, &aMask );
+    return GetModCode( aMask );
+}
+
+void GtkSalFrame::SetInputContext( SalInputContext* pContext )
+{
+    if( ! pContext )
+        return;
+    
+    if( ! (pContext->mnOptions & SAL_INPUTCONTEXT_TEXT) )
+    {
+        if( m_pIMContext )
+            gtk_im_context_focus_out( m_pIMContext );
+        return;
+    }
+
+    // create a new im context
+    if( ! m_pIMContext )
+    {
+        m_pIMContext = gtk_im_multicontext_new ();
+        g_signal_connect( m_pIMContext, "commit",
+                          G_CALLBACK (signalIMCommit), this );
+        g_signal_connect( m_pIMContext, "preedit_changed",
+                          G_CALLBACK (signalIMPreeditChanged), this );
+        g_signal_connect( m_pIMContext, "retrieve_surrounding",
+                          G_CALLBACK (signalIMRetrieveSurrounding), this );
+        g_signal_connect( m_pIMContext, "delete_surrounding",
+                          G_CALLBACK (signalIMDeleteSurrounding), this );
+
+        gtk_im_context_set_client_window( m_pIMContext, GTK_WIDGET(m_pWindow)->window );
+    }
+}
+void GtkSalFrame::EndExtTextInput( USHORT nFlags )
+{
+    if( m_pIMContext )
+        gtk_im_context_reset( m_pIMContext );
+    m_bWasPreedit = false;
+}
+
+LanguageType GtkSalFrame::GetInputLanguage()
+{
+    return LANGUAGE_DONTKNOW;
+}
+
+SalBitmap* GtkSalFrame::SnapShot()
+{
+	if( !m_pWindow )
+		return NULL;
+
+	X11SalBitmap *pBmp = new X11SalBitmap;
+	GdkWindow *pWin = GTK_WIDGET(m_pWindow)->window;
+	if( pBmp->SnapShot( GDK_DISPLAY_XDISPLAY( getGdkDisplay() ),
+						GDK_WINDOW_XID( pWin ) ) )
+		return pBmp;
+	else
+		delete pBmp;
+
+	return NULL;
+}
+
+static inline Color getColor( const GdkColor& rCol )
+{
+    return Color( rCol.red >> 8, rCol.green >> 8, rCol.blue >> 8 );
+}
+
+#if OSL_DEBUG_LEVEL > 1
+
+void printColor( const char* name, const GdkColor& rCol )
+{
+    fprintf( stderr, "   %s = 0x%2x 0x%2x 0x%2x\n",
+             name,
+             rCol.red >> 8, rCol.green >> 8, rCol.blue >> 8 );
+}
+
+void printStyleColors( GtkStyle* pStyle )
+{
+    static const char* pStates[] = { "NORMAL", "ACTIVE", "PRELIGHT", "SELECTED", "INSENSITIVE" };
+
+    for( int i = 0; i < 5; i++ )
+    {
+        fprintf( stderr, "state %s colors:\n", pStates[i] );
+        printColor( "bg     ", pStyle->bg[i] ); 
+        printColor( "fg     ", pStyle->fg[i] ); 
+        printColor( "light  ", pStyle->light[i] ); 
+        printColor( "dark   ", pStyle->dark[i] ); 
+        printColor( "mid    ", pStyle->mid[i] ); 
+        printColor( "text   ", pStyle->text[i] ); 
+        printColor( "base   ", pStyle->base[i] ); 
+        printColor( "text_aa", pStyle->text_aa[i] ); 
+    }
+}
+#endif
+
+void GtkSalFrame::UpdateSettings( AllSettings& rSettings )
+{
+    if( ! m_pWindow )
+        return;
+
+    StyleSettings aStyleSet = rSettings.GetStyleSettings();
+
+    gtk_widget_ensure_style( GTK_WIDGET(m_pWindow) );
+    GtkStyle* pStyle = gtk_widget_get_style( GTK_WIDGET(m_pWindow) );
+
+#if OSL_DEBUG_LEVEL > 2
+    printStyleColors( pStyle );
+#endif
+    
+    // text colors
+    Color aTextColor = getColor( pStyle->text[GTK_STATE_NORMAL] );
+    aStyleSet.SetDialogTextColor( aTextColor );
+    aStyleSet.SetMenuTextColor( aTextColor );
+    aStyleSet.SetButtonTextColor( aTextColor );
+    aStyleSet.SetRadioCheckTextColor( aTextColor );
+    aStyleSet.SetGroupTextColor( aTextColor );
+    aStyleSet.SetLabelTextColor( aTextColor );
+    aStyleSet.SetInfoTextColor( aTextColor );
+    aStyleSet.SetWindowTextColor( aTextColor );
+    aStyleSet.SetFieldTextColor( aTextColor );
+    
+    // background colors
+    Color aBackColor = getColor( pStyle->bg[GTK_STATE_NORMAL] );
+    Color aBackFieldColor = getColor( pStyle->base[ GTK_STATE_NORMAL ] );
+    aStyleSet.Set3DColors( aBackColor );
+    aStyleSet.SetFaceColor( aBackColor );
+    aStyleSet.SetDialogColor( aBackColor );
+    aStyleSet.SetMenuColor( aBackColor );
+    aStyleSet.SetMenuBarColor( aBackColor );
+    aStyleSet.SetFieldColor( aBackFieldColor );
+    aStyleSet.SetWindowColor( aBackFieldColor );
+    // ancient wisdom tells us a mystic algorithm how to set checked color
+    if( aBackColor == COL_LIGHTGRAY )
+        aStyleSet.SetCheckedColor( Color( 0xCC, 0xCC, 0xCC ) );
+    else
+    {
+        Color aColor2 = aStyleSet.GetLightColor();
+        Color aCheck( (BYTE)(((USHORT)aBackColor.GetRed()+(USHORT)aColor2.GetRed())/2),
+                      (BYTE)(((USHORT)aBackColor.GetGreen()+(USHORT)aColor2.GetGreen())/2),
+                      (BYTE)(((USHORT)aBackColor.GetBlue()+(USHORT)aColor2.GetBlue())/2)
+                      );
+        aStyleSet.SetCheckedColor( aCheck );
+    }
+
+    // highlighting colors
+    Color aHighlightColor = getColor( pStyle->base[GTK_STATE_SELECTED] );
+    Color aHighlightTextColor = getColor( pStyle->text[GTK_STATE_SELECTED] );
+    aStyleSet.SetHighlightColor( aHighlightColor );
+    aStyleSet.SetHighlightTextColor( aHighlightTextColor );
+
+    // menu highlighting
+    aHighlightColor = getColor( pStyle->bg[ GTK_STATE_SELECTED ] );
+    aStyleSet.SetMenuHighlightColor( aHighlightColor );
+    aHighlightTextColor = getColor( pStyle->fg[ GTK_STATE_PRELIGHT ] );
+    aStyleSet.SetMenuHighlightTextColor( aHighlightTextColor );
+
+    // UI font
+    ByteString	aFamily	= pango_font_description_get_family( pStyle->font_desc );
+    int nPixelHeight	= pango_font_description_get_size( pStyle->font_desc )/PANGO_SCALE;
+    PangoStyle	eStyle	= pango_font_description_get_style( pStyle->font_desc );
+    PangoWeight	eWeight	= pango_font_description_get_weight( pStyle->font_desc );
+    
+    sal_Int32 nDPIX, nDPIY;
+    sal_Int32 nDispDPIY = getDisplay()->GetResolution().B();
+    getDisplay()->GetScreenFontResolution( nDPIX, nDPIY );
+    int nHeight = nPixelHeight * nDispDPIY / nDPIY;
+    // allow for rounding in back conversion (at SetFont)
+    while( (nHeight * nDPIY / nDispDPIY) > nPixelHeight )
+        nHeight--;
+    while( (nHeight * nDPIY / nDispDPIY) < nPixelHeight )
+        nHeight++;
+    
+    Font aFont( String( aFamily, RTL_TEXTENCODING_UTF8 ), Size( 0, nHeight ) );
+    if( eWeight >= PANGO_WEIGHT_BOLD )
+        aFont.SetWeight( WEIGHT_BOLD );
+    else if( PANGO_WEIGHT_LIGHT )
+        aFont.SetWeight( WEIGHT_LIGHT );
+    if( eStyle == PANGO_STYLE_OBLIQUE )
+        aFont.SetItalic( ITALIC_OBLIQUE );
+    else if( eStyle == PANGO_STYLE_ITALIC )
+        aFont.SetItalic( ITALIC_NORMAL );
+    
+    aStyleSet.SetAppFont( aFont );
+    aStyleSet.SetHelpFont( aFont );
+    aStyleSet.SetTitleFont( aFont );
+    aStyleSet.SetFloatTitleFont( aFont );
+    aStyleSet.SetMenuFont( aFont );
+    aStyleSet.SetToolFont( aFont );
+    aStyleSet.SetLabelFont( aFont );
+    aStyleSet.SetInfoFont( aFont );
+    aStyleSet.SetRadioCheckFont( aFont );
+    aStyleSet.SetPushButtonFont( aFont );
+    aStyleSet.SetFieldFont( aFont );
+    aStyleSet.SetIconFont( aFont );
+    aStyleSet.SetGroupFont( aFont );    
+
+//  FIXME: need some way of fetching toolbar icon size.
+//	aStyleSet.SetToolbarIconSize( STYLE_TOOLBAR_ICONSIZE_SMALL );
+
+    rSettings.SetStyleSettings( aStyleSet );
+}
+
+void GtkSalFrame::Beep( SoundType eType )
+{
+    gdk_display_beep( getGdkDisplay() );
+}
+
+const SystemEnvData* GtkSalFrame::GetSystemData() const
+{
+    return &m_aSystemData;
+}
+
+void GtkSalFrame::SetParent( SalFrame* pNewParent )
+{
+    m_pParent = static_cast<GtkSalFrame*>(pNewParent);
+    if( ! (m_nStyle & SAL_FRAME_STYLE_CHILD) )
+        gtk_window_set_transient_for( m_pWindow,
+                                      (m_pParent && !(m_pParent->m_nStyle & SAL_FRAME_STYLE_CHILD)) ? m_pParent->m_pWindow : NULL
+                                     );
+}
+
+bool GtkSalFrame::SetPluginParent( SystemParentData* pSysParent )
+{
+    gtk_widget_destroy( GTK_WIDGET(m_pWindow) );
+    if( m_pForeignParent )
+        gdk_window_destroy( m_pForeignParent );
+    if( m_pForeignTopLevel )
+        gdk_window_destroy( m_pForeignTopLevel );
+    Init( pSysParent );
+    return true;
+}
+
+bool GtkSalFrame::Dispatch( const XEvent* pEvent )
+{
+    bool bContinueDispatch = true;
+
+    if( m_pForeignParent &&
+        pEvent->type == ConfigureNotify &&
+        pEvent->xconfigure.window == GDK_WINDOW_XWINDOW(m_pForeignParent)
+        )
+    {
+        bContinueDispatch = false;
+        gtk_window_resize( m_pWindow, pEvent->xconfigure.width, pEvent->xconfigure.height );
+    }
+    else if( m_pForeignTopLevel &&
+             pEvent->type == ConfigureNotify &&
+             pEvent->xconfigure.window == GDK_WINDOW_XWINDOW(m_pForeignTopLevel)
+             )
+    {
+        bContinueDispatch = false;
+        // update position
+        int x = 0, y = 0;
+        XLIB_Window aChild;
+  		XTranslateCoordinates( getDisplay()->GetDisplay(),
+                               GDK_WINDOW_XWINDOW(GTK_WIDGET(m_pWindow)->window),
+ 							   getDisplay()->GetRootWindow(),
+ 							   0, 0,
+ 							   &x, &y,
+ 							   &aChild );
+        if( x != maGeometry.nX || y != maGeometry.nY )
+        {
+            maGeometry.nX = x;
+            maGeometry.nY = y;
+            getDisplay()->SendInternalEvent( this, NULL, SALEVENT_MOVE );
+        }
+    }
+    
+    return bContinueDispatch;
+}
+
+gboolean GtkSalFrame::signalButton( GtkWidget* pWidget, GdkEventButton* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    SalMouseEvent aEvent;
+    USHORT nEventType = 0;
+    switch( pEvent->type )
+    {
+        case GDK_BUTTON_PRESS:
+            nEventType = SALEVENT_MOUSEBUTTONDOWN;
+            break;
+        case GDK_BUTTON_RELEASE:
+            nEventType = SALEVENT_MOUSEBUTTONUP;
+            break;
+        default:
+            return FALSE;
+    }
+    switch( pEvent->button )
+    {
+        case 1: aEvent.mnButton = MOUSE_LEFT;	break;
+        case 2: aEvent.mnButton = MOUSE_MIDDLE;	break;
+        case 3: aEvent.mnButton = MOUSE_RIGHT;	break;
+        default: return FALSE;				break;
+    }       
+    aEvent.mnTime	= pEvent->time;
+    aEvent.mnX		= (long)pEvent->x;
+    aEvent.mnY		= (long)pEvent->y;
+    aEvent.mnCode	= GetModCode( pEvent->state );
+
+    bool bClosePopups = false;
+    if( pEvent->type == GDK_BUTTON_PRESS && m_nFloats > 0 )
+    {
+        // close popups if user clicks outside our application
+        gint x, y;
+        bClosePopups = (gdk_display_get_window_at_pointer( pThis->getGdkDisplay(), &x, &y ) == NULL);
+        gdk_display_pointer_ungrab( pThis->getGdkDisplay(), GDK_CURRENT_TIME );
+    }
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( nEventType, &aEvent );
+
+    if( bClosePopups )
+    {
+        ImplSVData* pSVData = ImplGetSVData();
+        if ( pSVData->maWinData.mpFirstFloat )
+        {
+            static const char* pEnv = getenv( "SAL_FLOATWIN_NOAPPFOCUSCLOSE" );
+            if ( !(pSVData->maWinData.mpFirstFloat->GetPopupModeFlags() & FLOATWIN_POPUPMODE_NOAPPFOCUSCLOSE) && !(pEnv && *pEnv) )
+                pSVData->maWinData.mpFirstFloat->EndPopupMode( FLOATWIN_POPUPMODEEND_CANCEL | FLOATWIN_POPUPMODEEND_CLOSEALL );
+        }
+    }
+
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalScroll( GtkWidget* pWidget, GdkEvent* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    GdkEventScroll* pSEvent = (GdkEventScroll*)pEvent;
+
+    static ULONG		nLines = 0;
+    if( ! nLines )
+    {
+        char* pEnv = getenv( "SAL_WHEELLINES" );
+        nLines = pEnv ? atoi( pEnv ) : 3;
+        if( nLines > 10 )
+            nLines = SAL_WHEELMOUSE_EVENT_PAGESCROLL;
+    }
+
+    bool bNeg = (pSEvent->direction == GDK_SCROLL_DOWN || pSEvent->direction == GDK_SCROLL_RIGHT );
+    SalWheelMouseEvent aEvent;
+    aEvent.mnTime			= pSEvent->time;
+    aEvent.mnX				= (ULONG)pSEvent->x;
+    aEvent.mnY				= (ULONG)pSEvent->y;
+    aEvent.mnDelta			= bNeg ? -120 : 120;
+    aEvent.mnNotchDelta		= bNeg ? -1 : 1;
+    aEvent.mnScrollLines	= nLines;
+    aEvent.mnCode			= GetModCode( pSEvent->state );
+    aEvent.mbHorz			= (pSEvent->direction == GDK_SCROLL_LEFT || pSEvent->direction == GDK_SCROLL_RIGHT);
+    
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_WHEELMOUSE, &aEvent );
+    
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalMotion( GtkWidget* pWidget, GdkEventMotion* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    SalMouseEvent aEvent;
+    aEvent.mnTime	= pEvent->time;
+    aEvent.mnX		= (long)pEvent->x;
+    aEvent.mnY		= (long)pEvent->y;
+    aEvent.mnCode	= GetModCode( pEvent->state );
+    aEvent.mnButton	= 0;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_MOUSEMOVE, &aEvent );
+
+    // ask for the next hint
+    gint x, y;
+    GdkModifierType mask;
+    gdk_window_get_pointer( GTK_WIDGET(pThis->m_pWindow)->window, &x, &y, &mask );
+
+    return TRUE;
+}
+
+gboolean GtkSalFrame::signalCrossing( GtkWidget* pWidget, GdkEventCrossing* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    SalMouseEvent aEvent;
+    aEvent.mnTime	= pEvent->time;
+    aEvent.mnX		= (long)pEvent->x;
+    aEvent.mnY		= (long)pEvent->y;
+    aEvent.mnCode	= GetModCode( pEvent->state );
+    aEvent.mnButton	= 0;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( (pEvent->type == GDK_ENTER_NOTIFY) ? SALEVENT_MOUSEMOVE : SALEVENT_MOUSELEAVE, &aEvent );
+
+    return TRUE;
+}
+
+
+gboolean GtkSalFrame::signalExpose( GtkWidget* pWidget, GdkEventExpose* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    struct SalPaintEvent aEvent;
+    aEvent.mnBoundX			= pEvent->area.x;
+    aEvent.mnBoundY			= pEvent->area.y;
+    aEvent.mnBoundWidth		= pEvent->area.width;
+    aEvent.mnBoundHeight	= pEvent->area.height;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_PAINT, &aEvent );
+    
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalFocus( GtkWidget* pWidget, GdkEventFocus* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    GTK_YIELD_GRAB();
+
+	if( !pEvent->in )
+	{
+		pThis->m_nKeyModifiers = 0;
+		pThis->m_bSingleAltPress = false;
+		pThis->m_bSendModChangeOnRelease = false;
+        pThis->m_bWasPreedit = false;
+	}
+
+    if( pThis->m_pIMContext )
+    {
+        if( pEvent->in )
+        {
+            gtk_im_context_focus_in( pThis->m_pIMContext );
+            gtk_im_context_reset( pThis->m_pIMContext );
+        }
+        else
+        {
+            gtk_im_context_focus_out( pThis->m_pIMContext );
+            pThis->CallCallback( SALEVENT_ENDEXTTEXTINPUT, NULL );
+            gtk_im_context_reset( pThis->m_pIMContext );
+        }
+    }
+
+    // FIXME: find out who the hell steals the focus from our frame
+    // if we are plugged and a float opens; why does the same not
+    // happen unplugged ? Is the plugging application (SimpleViewer in SDK)
+    // somehow responsible ? The focus does not seem to get set inside our process
+    //
+    // in the meantime do not propagate focus get/lose on a plugged window
+    // if floats are open
+    if( ! ((pThis->m_nStyle & SAL_FRAME_STYLE_CHILD) && m_nFloats > 0 ) )
+        pThis->CallCallback( pEvent->in ? SALEVENT_GETFOCUS : SALEVENT_LOSEFOCUS, NULL );
+
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalMap( GtkWidget* pWidget, GdkEvent* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_RESIZE, NULL );
+    
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalUnmap( GtkWidget* pWidget, GdkEvent* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_RESIZE, NULL );
+    
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalConfigure( GtkWidget* pWidget, GdkEventConfigure* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    bool bMoved = false, bSized = false;
+    int x = pEvent->x, y = pEvent->y;
+
+    if( (pThis->m_nStyle & SAL_FRAME_STYLE_CHILD) )
+    {
+        // in child case the coordinates are not root coordinates,
+        // need to transform
+        XLIB_Window aChild;
+  		XTranslateCoordinates( pThis->getDisplay()->GetDisplay(),
+                               GDK_WINDOW_XWINDOW(GTK_WIDGET(pThis->m_pWindow)->window),
+ 							   pThis->getDisplay()->GetRootWindow(),
+ 							   0, 0,
+ 							   &x, &y,
+ 							   &aChild );
+    }
+
+
+    if( x != pThis->maGeometry.nX || y != pThis->maGeometry.nY )
+        bMoved = true;
+    if( pEvent->width != pThis->maGeometry.nWidth || pEvent->height != pThis->maGeometry.nHeight )
+        bSized = true;
+
+    pThis->maGeometry.nX		= x;
+    pThis->maGeometry.nY		= y;
+    pThis->maGeometry.nWidth	= pEvent->width;
+    pThis->maGeometry.nHeight	= pEvent->height;
+
+    // update decoration hints
+    if( ! (pThis->m_nStyle & SAL_FRAME_STYLE_CHILD) )
+    {
+        GdkRectangle aRect;
+        gdk_window_get_frame_extents( GTK_WIDGET(pThis->m_pWindow)->window, &aRect );
+        pThis->maGeometry.nTopDecoration	= y - aRect.y;
+        pThis->maGeometry.nBottomDecoration	= aRect.y + aRect.height - y - pEvent->height;
+        pThis->maGeometry.nLeftDecoration	= x - aRect.x;
+        pThis->maGeometry.nRightDecoration	= aRect.x + aRect.width - x - pEvent->width;
+    }
+    else
+    {
+        pThis->maGeometry.nTopDecoration =
+            pThis->maGeometry.nBottomDecoration =
+            pThis->maGeometry.nLeftDecoration =
+            pThis->maGeometry.nRightDecoration = 0;
+    }
+
+	GTK_YIELD_GRAB();
+    if( bMoved && bSized )
+        pThis->CallCallback( SALEVENT_MOVERESIZE, NULL );
+    else if( bMoved )
+        pThis->CallCallback( SALEVENT_MOVE, NULL );
+    else if( bSized )
+        pThis->CallCallback( SALEVENT_RESIZE, NULL );
+
+	return FALSE;
+}
+
+gboolean GtkSalFrame::signalKey( GtkWidget* pWidget, GdkEventKey* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    static GdkEventKey aLastPressEvent = { GDK_KEY_PRESS, NULL, 0, 0, 0, 0, 0, NULL, 0, 0 };
+
+    if( pThis->m_pIMContext )
+    {
+        if( gtk_im_context_filter_keypress( pThis->m_pIMContext, pEvent ) )
+        {
+            aLastPressEvent = *pEvent;
+            return TRUE;
+        }    
+        else
+            if( pEvent->type == GDK_KEY_PRESS )
+                aLastPressEvent.window = NULL;
+    }
+
+    // swallow key release events if according keypress was filtered
+    if( pEvent->type == GDK_KEY_RELEASE							&&
+        pEvent->window		== aLastPressEvent.window			&&
+        pEvent->send_event	== aLastPressEvent.send_event		&&
+        pEvent->state		== aLastPressEvent.state			&&
+        pEvent->keyval		== aLastPressEvent.keyval )
+    {
+        aLastPressEvent.window = NULL;
+        return TRUE;
+    }
+
+    GTK_YIELD_GRAB();
+
+    // handle modifiers
+    if( pEvent->keyval == GDK_Shift_L || pEvent->keyval == GDK_Shift_R ||
+        pEvent->keyval == GDK_Control_L || pEvent->keyval == GDK_Control_R ||
+        pEvent->keyval == GDK_Alt_L || pEvent->keyval == GDK_Alt_R ||
+        pEvent->keyval == GDK_Meta_L || pEvent->keyval == GDK_Meta_R )
+    {
+		SalKeyModEvent aModEvt;
+
+		USHORT nModCode = GetModCode( pEvent->state );
+
+        aModEvt.mnModKeyCode = 0; // emit no MODKEYCHANGE events
+        if( pEvent->type == GDK_KEY_PRESS && !pThis->m_nKeyModifiers )
+			pThis->m_bSendModChangeOnRelease = true;
+
+        else if( pEvent->type == GDK_KEY_RELEASE &&
+				 pThis->m_bSendModChangeOnRelease )
+        {
+			aModEvt.mnModKeyCode = pThis->m_nKeyModifiers;
+			pThis->m_nKeyModifiers = 0;
+        }
+
+        USHORT nExtModMask = 0;
+        USHORT nModMask = 0;
+		// pressing just the ctrl key leads to a keysym of XK_Control but
+		// the event state does not contain ControlMask. In the release
+		// event its the other way round: it does contain the Control mask.
+		// The modifier mode therefore has to be adapted manually.
+        switch( pEvent->keyval )
+        {
+            case GDK_Control_L:
+                nExtModMask = MODKEY_LMOD1;
+                nModMask = KEY_MOD1;
+                break;
+            case GDK_Control_R:
+                nExtModMask = MODKEY_RMOD1;
+                nModMask = KEY_MOD1;
+                break;
+            case GDK_Alt_L:
+                nExtModMask = MODKEY_LMOD2;
+                nModMask = KEY_MOD2 | (pEvent->type == GDK_KEY_RELEASE ? KEY_CONTROLMOD : 0);
+                break;
+            case GDK_Alt_R:
+                nExtModMask = MODKEY_RMOD2;
+                nModMask = KEY_MOD2 | (pEvent->type == GDK_KEY_RELEASE ? KEY_CONTROLMOD : 0);
+                break;
+            case GDK_Shift_L:
+                nExtModMask = MODKEY_LSHIFT;
+                nModMask = KEY_SHIFT;
+                break;
+            case GDK_Shift_R:
+                nExtModMask = MODKEY_RSHIFT;
+                nModMask = KEY_SHIFT;
+                break;
+        }
+        if( pEvent->type == GDK_KEY_RELEASE )
+        {
+            nModCode &= ~nModMask;
+            pThis->m_nKeyModifiers &= ~nExtModMask;
+        }
+        else
+        {
+            nModCode |= nModMask;
+            pThis->m_nKeyModifiers |= nExtModMask;
+        }
+
+		aModEvt.mnCode = nModCode;
+		aModEvt.mnTime = pEvent->time;
+
+		pThis->CallCallback( SALEVENT_KEYMODCHANGE, &aModEvt );
+
+        // emulate KEY_MENU
+		if( ( pEvent->keyval == GDK_Alt_L || pEvent->keyval == GDK_Alt_R ) &&
+			( nModCode & ~(KEY_CONTROLMOD|KEY_MOD2)) == 0 )
+		{
+            if( pEvent->type == GDK_KEY_PRESS )
+                pThis->m_bSingleAltPress = true;
+
+			else if( pThis->m_bSingleAltPress )
+			{
+		        SalKeyEvent aKeyEvt;
+
+                aKeyEvt.mnCode	   = KEY_MENU | nModCode;
+                aKeyEvt.mnRepeat   = 0;
+                aKeyEvt.mnTime	   = pEvent->time;
+                aKeyEvt.mnCharCode = 0;
+
+                // simulate KEY_MENU
+                pThis->CallCallback( SALEVENT_KEYINPUT, &aKeyEvt );
+                pThis->CallCallback( SALEVENT_KEYUP, &aKeyEvt );
+				pThis->m_bSingleAltPress = false;
+			}
+		}
+		else
+			pThis->m_bSingleAltPress = false;
+    }
+    else
+    {
+        SalKeyEvent aEvent;
+        
+        aEvent.mnTime			= pEvent->time;
+        aEvent.mnCode			= GetKeyCode( pEvent->keyval ) | GetModCode( pEvent->state );
+        aEvent.mnCharCode		= (USHORT)gdk_keyval_to_unicode( pEvent->keyval );
+        aEvent.mnRepeat			= 0;
+
+        pThis->CallCallback( (pEvent->type == GDK_KEY_PRESS) ? SALEVENT_KEYINPUT : SALEVENT_KEYUP, &aEvent );
+
+		pThis->m_bSendModChangeOnRelease = false;
+		pThis->m_bSingleAltPress = false;
+    }
+
+    return TRUE;
+}
+
+gboolean GtkSalFrame::signalDelete( GtkWidget* pWidget, GdkEvent* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    GTK_YIELD_GRAB();
+    pThis->CallCallback( SALEVENT_CLOSE, NULL );
+
+    return TRUE;
+}
+
+void GtkSalFrame::signalStyleSet( GtkWidget* pWidget, GtkStyle* pPrevious, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    // every frame gets an initial style set on creation
+    // do not post these as the whole application tends to
+    // redraw itself to adjust to the new style
+    // where there IS no new style resulting in tremendous unnecessary flickering
+    if( pPrevious != NULL )
+        // signalStyleSet does NOT usually have the gdk lock
+        // so post user event to safely dispatch the SALEVENT_SETTINGSCHANGED
+        // note: settings changed for multiple frames is avoided in winproc.cxx ImplHandleSettings
+        pThis->getDisplay()->SendInternalEvent( pThis, NULL, SALEVENT_SETTINGSCHANGED );
+        
+    if( ! pThis->m_pParent ) 
+    {
+        // signalize theme changed for NWF caches
+        // FIXME: should be called only once for a style change
+        GtkSalGraphics::bThemeChanged = TRUE;
+    }
+}
+
+gboolean GtkSalFrame::signalState( GtkWidget* pWidget, GdkEvent* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    pThis->m_nState = pEvent->window_state.new_window_state;
+
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalVisibility( GtkWidget* pWidget, GdkEventVisibility* pEvent, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+    pThis->m_nVisibility = pEvent->state;
+
+    return FALSE;
+}
+
+void GtkSalFrame::signalIMCommit( GtkIMContext* pContext, gchar* pText, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    SalExtTextInputEvent aTextEvent;
+
+    aTextEvent.mnTime 			= 0;
+    aTextEvent.mpTextAttr 		= 0;
+    aTextEvent.maText 			= String( pText, RTL_TEXTENCODING_UTF8 );
+    aTextEvent.mnCursorPos 		= aTextEvent.maText.Len();
+    aTextEvent.mnCursorFlags 	= 0;
+    aTextEvent.mnDeltaStart 	= 0;
+    aTextEvent.mbOnlyCursor 	= False;
+
+    GTK_YIELD_GRAB();
+
+    /* necessary HACK: all keyboard input comes in here as soon as a IMContext is set
+     *  which is logical and consequent. But since even simple input like
+     *  <space> comes through the commit signal instead of signalKey
+     *  and all kinds of windows only implement KeyInput (e.g. PushButtons,
+     *  RadioButtons and a lot of other Controls), will send a single
+     *  KeyInput/KeyUp sequence instead of an ExtText event if there
+     *  never was a preedit and the text is only one character.
+     *
+     *  In this case there the last ExtText event must have been
+     *  SALEVENT_ENDEXTTEXTINPUT, either because of a regular commit
+     *  or because there never was a preedit.
+     */
+    if( ! pThis->m_bWasPreedit && aTextEvent.maText.Len() == 1 )
+    {
+        USHORT nCharCode = GetCharCodeFromUnicode( aTextEvent.maText.GetChar( 0 ) );
+        if( nCharCode != 0 )
+        {
+            SalKeyEvent aEvent;
+            
+            aEvent.mnTime			= 0;
+            aEvent.mnCode			= nCharCode;
+            aEvent.mnCharCode		= aTextEvent.maText.GetChar(0);
+            aEvent.mnRepeat			= 0;
+
+            pThis->m_bWasPreedit = false;
+            pThis->CallCallback( SALEVENT_KEYINPUT, &aEvent );
+            pThis->CallCallback( SALEVENT_KEYUP, &aEvent );
+            return;
+        }
+    }
+
+    pThis->m_bWasPreedit = false;
+    pThis->CallCallback( SALEVENT_EXTTEXTINPUT, (void*)&aTextEvent);
+    pThis->CallCallback( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
+}
+
+void GtkSalFrame::signalIMPreeditChanged( GtkIMContext* pContext, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    char*			pText			= NULL;
+    PangoAttrList*	pAttribs		= NULL;
+    gint			nCursorPos		= 0;
+    
+    gtk_im_context_get_preedit_string( pThis->m_pIMContext,
+                                       &pText,
+                                       &pAttribs,
+                                       &nCursorPos );
+    SalExtTextInputEvent aTextEvent;
+
+    aTextEvent.mnTime 			= 0;
+    aTextEvent.maText 			= String( pText, RTL_TEXTENCODING_UTF8 );
+    aTextEvent.mnCursorPos 		= nCursorPos;
+    aTextEvent.mnCursorFlags 	= 0;
+    aTextEvent.mnDeltaStart 	= 0;
+    aTextEvent.mbOnlyCursor 	= False;
+
+    USHORT* pSalAttribs = new USHORT[ aTextEvent.maText.Len() ];
+	// FIXME: more sophisticated attributes
+    for( int i = 0; i < aTextEvent.maText.Len(); ++i )
+        pSalAttribs[i] = SAL_EXTTEXTINPUT_ATTR_UNDERLINE;
+
+    aTextEvent.mpTextAttr 		= pSalAttribs;
+
+    g_free( pText );
+    pango_attr_list_unref( pAttribs );
+    
+    GTK_YIELD_GRAB();
+    pThis->m_bWasPreedit = true;
+    pThis->CallCallback( SALEVENT_EXTTEXTINPUT, (void*)&aTextEvent);
+
+    delete [] pSalAttribs;
+}
+
+void GtkSalFrame::signalIMPreeditStart( GtkIMContext* pContext, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+}
+
+void GtkSalFrame::signalIMPreeditEnd( GtkIMContext* pContext, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+}
+
+gboolean GtkSalFrame::signalIMRetrieveSurrounding( GtkIMContext* pContext, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    return FALSE;
+}
+
+gboolean GtkSalFrame::signalIMDeleteSurrounding( GtkIMContext* pContext, gint arg1, gint arg2, gpointer frame )
+{
+    GtkSalFrame* pThis = (GtkSalFrame*)frame;
+
+    return FALSE;
+}
Index: vcl/unx/gtk/window/gtkobject.cxx
===================================================================
RCS file: vcl/unx/gtk/window/gtkobject.cxx
diff -N vcl/unx/gtk/window/gtkobject.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/window/gtkobject.cxx	10 May 2004 15:53:24 -0000	1.3
@@ -0,0 +1,220 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <plugins/gtk/gtkobject.hxx>
+#include <plugins/gtk/gtkframe.hxx>
+#include <plugins/gtk/gtkdata.hxx>
+#include <plugins/gtk/gtkinst.hxx>
+
+GtkSalObject::GtkSalObject( GtkSalFrame* pParent ) 
+        : m_pSocket( NULL ),
+          m_pRegion( NULL )
+{
+    if( pParent )
+    {
+        // our plug window
+        m_pSocket = gtk_drawing_area_new();
+        // insert into container
+        gtk_fixed_put( pParent->getFixedContainer(),
+                       m_pSocket,
+                       0, 0 );
+        // realize so we can get a window id
+        gtk_widget_realize( m_pSocket );
+
+
+        // make it transparent; some plugins may not insert
+        // their own window here but use the socket window itself
+        gtk_widget_set_app_paintable( m_pSocket, TRUE );
+
+        //system data
+        SalDisplay* pDisp = GetSalData()->GetDisplay();
+        m_aSystemData.pDisplay		= pDisp->GetDisplay();
+        m_aSystemData.aWindow		= GDK_WINDOW_XWINDOW(m_pSocket->window);
+        m_aSystemData.pSalFrame		= NULL;
+        m_aSystemData.pWidget		= m_pSocket;
+        m_aSystemData.pVisual		= pDisp->GetVisual()->GetVisual();
+        m_aSystemData.nDepth		= pDisp->GetVisual()->GetDepth();
+        m_aSystemData.aColormap		= pDisp->GetColormap().GetXColormap();
+        m_aSystemData.pAppContext	= NULL;
+        m_aSystemData.aShellWindow	= GDK_WINDOW_XWINDOW(GTK_WIDGET(pParent->getWindow())->window);
+        m_aSystemData.pShellWidget	= GTK_WIDGET(pParent->getWindow());
+
+        g_signal_connect( G_OBJECT(m_pSocket), "button-press-event", G_CALLBACK(signalButton), this );
+        g_signal_connect( G_OBJECT(m_pSocket), "button-release-event", G_CALLBACK(signalButton), this );
+        g_signal_connect( G_OBJECT(m_pSocket), "focus-in-event", G_CALLBACK(signalFocus), this );
+        g_signal_connect( G_OBJECT(m_pSocket), "focus-out-event", G_CALLBACK(signalFocus), this );
+    }
+}
+
+GtkSalObject::~GtkSalObject()
+{
+    if( m_pRegion )
+        gdk_region_destroy( m_pRegion );
+    if( m_pSocket )
+    {
+        // remove socket from parent frame's fixed container
+        gtk_container_remove( GTK_CONTAINER(gtk_widget_get_parent(m_pSocket)),
+                              m_pSocket );
+        // get rid of the socket
+        gtk_widget_destroy( m_pSocket );
+    }
+}
+
+void GtkSalObject::ResetClipRegion()
+{
+    gdk_window_shape_combine_region( m_pSocket->window, NULL, 0, 0 );
+}
+
+USHORT GtkSalObject::GetClipRegionType()
+{
+    return SAL_OBJECT_CLIP_INCLUDERECTS;
+}
+
+void GtkSalObject::BeginSetClipRegion( ULONG nRects )
+{
+    if( m_pRegion )
+        gdk_region_destroy( m_pRegion );
+    m_pRegion = gdk_region_new();
+}
+
+void GtkSalObject::UnionClipRegion( long nX, long nY, long nWidth, long nHeight )
+{
+    GdkRectangle aRect;
+    aRect.x			= nX;
+    aRect.y			= nY;
+    aRect.width		= nWidth;
+    aRect.height	= nHeight;
+    
+    gdk_region_union_with_rect( m_pRegion, &aRect );
+}
+
+void GtkSalObject::EndSetClipRegion()
+{
+    gdk_window_shape_combine_region( m_pSocket->window, m_pRegion, 0, 0 );
+}
+
+void GtkSalObject::SetPosSize( long nX, long nY, long nWidth, long nHeight )
+{
+    if( m_pSocket )
+    {
+        GtkFixed* pContainer = GTK_FIXED(gtk_widget_get_parent(m_pSocket));
+        gtk_fixed_move( pContainer, m_pSocket, nX, nY );
+        gtk_widget_set_size_request( m_pSocket, nWidth, nHeight );
+        gtk_container_resize_children( GTK_CONTAINER(pContainer) );
+    }
+}
+
+void GtkSalObject::Show( BOOL bVisible )
+{
+    if( m_pSocket )
+    {
+        if( bVisible )
+            gtk_widget_show( m_pSocket );
+        else
+            gtk_widget_hide( m_pSocket );
+    }
+}
+
+void GtkSalObject::Enable( BOOL nEnable )
+{
+}
+
+void GtkSalObject::GrabFocus()
+{
+}
+
+void GtkSalObject::SetBackground()
+{
+}
+
+void GtkSalObject::SetBackground( SalColor nSalColor )
+{
+}
+
+const SystemEnvData* GtkSalObject::GetSystemData() const
+{
+    return &m_aSystemData;
+}
+
+   
+gboolean GtkSalObject::signalButton( GtkWidget* pWidget, GdkEventButton* pEvent, gpointer object )
+{
+    GtkSalObject* pThis = (GtkSalObject*)object;
+
+    if( pEvent->type == GDK_BUTTON_PRESS )
+    {
+        GTK_YIELD_GRAB();
+        pThis->CallCallback( SALOBJ_EVENT_TOTOP, NULL );
+    }
+
+    return FALSE;
+}
+
+gboolean GtkSalObject::signalFocus( GtkWidget* pWidget, GdkEventFocus* pEvent, gpointer object )
+{
+    GtkSalObject* pThis = (GtkSalObject*)object;
+
+    GTK_YIELD_GRAB();
+
+    pThis->CallCallback( pEvent->in ? SALOBJ_EVENT_GETFOCUS : SALOBJ_EVENT_LOSEFOCUS, NULL );
+
+    return FALSE;
+}
Index: vcl/unx/gtk/window/makefile.mk
===================================================================
RCS file: vcl/unx/gtk/window/makefile.mk
diff -N vcl/unx/gtk/window/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/gtk/window/makefile.mk	10 May 2004 15:53:37 -0000	1.4
@@ -0,0 +1,103 @@
+#*************************************************************************
+#
+#   
+#
+#   
+#
+#   
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=vcl
+TARGET=gtkwin
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# workaround for makedepend hang
+MKDEPENDSOLVER=
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  settings.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(GUIBASE)"!="unx"
+
+dummy:
+	@echo "Nothing to build for GUIBASE $(GUIBASE)"
+
+.ELSE		# "$(GUIBASE)"!="unx"
+
+.IF "$(ENABLE_GTK)" != ""
+
+CFLAGS+=`pkg-config --cflags gtk+-2.0`
+
+SLOFILES=\
+			$(SLO)$/gtkframe.obj				\
+			$(SLO)$/gtkobject.obj
+.ELSE # "$(ENABLE_GTK)" != ""
+
+dummy:
+	@echo GTK disabled - nothing to build
+.ENDIF
+.ENDIF		# "$(GUIBASE)"!="unx"
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+.INCLUDE :  $(PRJ)$/util$/target.pmk
Index: vcl/unx/inc/cdeint.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/cdeint.hxx,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- vcl/unx/inc/cdeint.hxx	10 Jun 2002 17:27:27 -0000	1.4
+++ vcl/unx/inc/cdeint.hxx	18 Nov 2003 14:35:40 -0000	1.5
@@ -67,9 +67,9 @@
 
 class CDEIntegrator : public DtIntegrator
 {
-	friend DtIntegrator* DtIntegrator::CreateDtIntegrator( SalFrame* );
+	friend DtIntegrator* DtIntegrator::CreateDtIntegrator();
 private:
-	CDEIntegrator( SalFrame* );
+	CDEIntegrator();
 
 public:
 	virtual ~CDEIntegrator();
Index: vcl/unx/inc/dtint.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/dtint.hxx,v
retrieving revision 1.6
retrieving revision 1.9
diff -u -p -u -r1.6 -r1.9
--- vcl/unx/inc/dtint.hxx	27 Mar 2003 17:58:30 -0000	1.6
+++ vcl/unx/inc/dtint.hxx	20 Feb 2004 08:54:36 -0000	1.9
@@ -61,8 +61,6 @@
 #ifndef _SV_DTINT_HXX
 #define _SV_DTINT_HXX
 
-#include <cstdio>
-
 #ifndef _LIST_HXX
 #include <tools/list.hxx>
 #endif
@@ -72,10 +70,11 @@
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
+#ifndef _TOOLS_COLOR_HXX
 #include <tools/color.hxx>
+#endif
 #include <font.hxx>
 
-class SalFrame;
 class SalBitmap;
 class SalDisplay;
 class AllSettings;
@@ -107,29 +106,17 @@ protected:
 	DtType				meType;
 	Display*			mpDisplay;
 	SalDisplay*			mpSalDisplay;
-	SalFrame*			mpSalFrame;
 	int					mnRefCount;
     int					mnSystemLookCommandProcess;
 
 
-	DtIntegrator( SalFrame* );
+	DtIntegrator();
 
 	static DtIntegratorList	aIntegratorList;
 	static String			aHomeDir;
 
-    // executes pCommand and parses its output
-    // to get system look information
-    // different DtIntegrators can rely
-    // on native programs to query system settings
-    // pass NULL as command to read the VCL_SYSTEM_SETTINGS property
-    void GetSystemLook( const char* pCommand, AllSettings& rSettings );
-    bool StartSystemLookProcess( const char* pCommand );
-
-    Color parseColor( const ByteString& );
-    Font parseFont( const ByteString& );
-
 public:
-	static DtIntegrator* CreateDtIntegrator( SalFrame* );
+	static DtIntegrator* CreateDtIntegrator();
 	
 	virtual ~DtIntegrator();
 
@@ -137,7 +124,6 @@ public:
 	virtual void GetSystemLook( AllSettings& rSettings );
 	
 	DtType			GetDtType() { return meType; }
-	SalFrame*		GetFrame() { return mpSalFrame; }
 	SalDisplay*		GetSalDisplay() { return mpSalDisplay; }
 	Display*		GetDisplay() { return mpDisplay; }
 
Index: vcl/unx/inc/i18n_cb.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/i18n_cb.hxx,v
retrieving revision 1.6
retrieving revision 1.7
diff -u -p -u -r1.6 -r1.7
--- vcl/unx/inc/i18n_cb.hxx	2 Nov 2001 14:54:02 -0000	1.6
+++ vcl/unx/inc/i18n_cb.hxx	18 Nov 2003 14:36:13 -0000	1.7
@@ -115,7 +115,7 @@ typedef enum {
 } preedit_status_t;
 
 typedef struct {
-    SalFrame      	   *pFrame;
+    SalFrame*			pFrame;
 	Bool		   		bIsMultilingual;
 	preedit_status_t 	eState;
     preedit_text_t 		aText;
Index: vcl/unx/inc/i18n_ic.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/i18n_ic.hxx,v
retrieving revision 1.7
retrieving revision 1.9
diff -u -p -u -r1.7 -r1.9
--- vcl/unx/inc/i18n_ic.hxx	24 Aug 2001 10:22:29 -0000	1.7
+++ vcl/unx/inc/i18n_ic.hxx	18 Nov 2003 14:36:24 -0000	1.9
@@ -96,7 +96,7 @@ private:
 	XVaNestedList mpAttributes;
 	XVaNestedList mpStatusAttributes;
 	XVaNestedList mpPreeditAttributes;
-    SalFrame*	  mpFocusFrame;
+    SalFrame*  mpFocusFrame;
 		
 	Bool 		 SupportInputMethodStyle( XIMStyles *pIMStyles );
 	unsigned int GetWeightingOfIMStyle(   XIMStyle n_style ) const ;
Index: vcl/unx/inc/i18n_status.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/i18n_status.hxx,v
retrieving revision 1.6
retrieving revision 1.7
diff -u -p -u -r1.6 -r1.7
--- vcl/unx/inc/i18n_status.hxx	26 Nov 2002 15:35:08 -0000	1.6
+++ vcl/unx/inc/i18n_status.hxx	18 Nov 2003 14:36:37 -0000	1.7
@@ -78,6 +78,10 @@
 #include <rtl/ustring.hxx>
 #endif
 
+#ifndef _SV_SALIMESTATUS_HXX
+#include <salimestatus.hxx>
+#endif
+
 #include <vector>
 
 class SalFrame;
@@ -92,6 +96,16 @@ namespace vcl
 
 class StatusWindow;
 
+class X11ImeStatus : public SalI18NImeStatus
+{
+public:
+    X11ImeStatus() {}
+    virtual ~X11ImeStatus();
+    
+    virtual bool canToggle();
+    virtual void toggle();
+};
+
 class I18NStatus
 {
 public:
@@ -127,7 +141,7 @@ public:
     SalFrame* getStatusFrame() const;
 
     void setStatusText( const String& rText );
-    const String& getStatusText() const;
+    String getStatusText() const;
 
     enum ShowReason { focus, presentation, contextmap };
     void show( bool bShow, ShowReason eReason );
Index: vcl/unx/inc/kdeint.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/kdeint.hxx,v
retrieving revision 1.4
retrieving revision 1.5
diff -u -p -u -r1.4 -r1.5
--- vcl/unx/inc/kdeint.hxx	10 Jun 2002 17:27:27 -0000	1.4
+++ vcl/unx/inc/kdeint.hxx	18 Nov 2003 14:36:49 -0000	1.5
@@ -70,9 +70,9 @@
 
 class KDEIntegrator : public DtIntegrator
 {
-	friend DtIntegrator* DtIntegrator::CreateDtIntegrator( SalFrame* );
+	friend DtIntegrator* DtIntegrator::CreateDtIntegrator();
 private:
-	KDEIntegrator( SalFrame* );
+	KDEIntegrator();
 
 public:
 	virtual ~KDEIntegrator();
Index: vcl/unx/inc/prex.h
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/prex.h,v
retrieving revision 1.9
retrieving revision 1.11
diff -u -p -u -r1.9 -r1.11
--- vcl/unx/inc/prex.h	12 Jun 2003 10:25:34 -0000	1.9
+++ vcl/unx/inc/prex.h	6 Jan 2004 14:23:45 -0000	1.11
@@ -90,13 +80,6 @@
 
 /* fuer Network Audio System */
 #define Sound		XLIB_Sound
-
-#if defined( MTF12 ) || defined( ALPHA )
-#define XLIB_ILLEGAL_ACCESS 
-#endif   
-#if defined( RS6000 ) || defined( ALPHA )
-struct _XDisplay;
-#endif   
 
 #if defined __cplusplus
 extern "C" {
Index: vcl/unx/inc/pspgraphics.h
===================================================================
RCS file: vcl/unx/inc/pspgraphics.h
diff -N vcl/unx/inc/pspgraphics.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/inc/pspgraphics.h	17 Jun 2004 12:25:37 -0000	1.3
@@ -0,0 +1,218 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _VCL_PSPGRAPHICS_H
+#define _VCL_PSPGRAPHICS_H
+
+
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
+#ifndef _PSPRINT_FONTMANAGER_HXX
+#include <psprint/fontmanager.hxx>
+#endif
+#ifndef _SV_SALLAYOUT_HXX
+#include <sallayout.hxx>
+#endif
+
+#ifndef _USE_PRINT_EXTENSION_
+namespace psp { struct JobData; class PrinterGfx; }
+#endif
+
+class ServerFont;
+
+class PspGraphics : public SalGraphics
+{
+    psp::JobData*				m_pJobData;
+    psp::PrinterGfx*			m_pPrinterGfx;
+    String*						m_pPhoneNr;
+    bool						m_bSwallowFaxNo;
+
+    ServerFont*					m_pServerFont[ MAX_FALLBACK ];
+    bool						m_bFontVertical;
+public:
+    PspGraphics( psp::JobData* pJob, psp::PrinterGfx* pGfx, String* pPhone = NULL, bool bSwallow = false )
+            : m_pJobData( pJob ),
+              m_pPrinterGfx( pGfx ),
+              m_pPhoneNr( pPhone ),
+              m_bSwallowFaxNo( bSwallow ),
+              m_bFontVertical( false )
+    { for( int i = 0; i < MAX_FALLBACK; i++ ) m_pServerFont[i] = 0; }
+    virtual ~PspGraphics();
+
+    String            FaxPhoneComment( const String& rOrig, xub_StrLen nIndex, xub_StrLen& rLen, xub_StrLen& rCutStart, xub_StrLen& rCutStop ) const;
+
+    // helper methods for sharing with X11SalGraphics
+    static bool DoCreateFontSubset( const rtl::OUString& rToFile,
+                                    psp::fontID aFont,
+                                    sal_Int32* pGlyphIDs,
+                                    sal_uInt8* pEncoding,
+                                    sal_Int32* pWidths,
+                                    int nGlyphs,
+                                    FontSubsetInfo& rInfo );
+    static const void* DoGetEmbedFontData( psp::fontID aFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen );
+    static void DoFreeEmbedFontData( const void* pData, long nLen );
+    static const std::map< sal_Unicode, sal_Int32 >* DoGetFontEncodingVector( psp::fontID aFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded );
+    static void SetImplFontData( const psp::FastPrintFontInfo& aInfo, ImplFontData& rData );
+    static FontWidth	ToFontWidth (psp::width::type eWidth);
+    static FontWeight	ToFontWeight (psp::weight::type eWeight);
+    static FontPitch	ToFontPitch (psp::pitch::type ePitch);
+    static FontItalic	ToFontItalic (psp::italic::type eItalic);
+    static FontFamily	ToFontFamily (psp::family::type eFamily);
+
+    // overload all pure virtual methods
+    virtual void			GetResolution( sal_Int32& rDPIX, sal_Int32& rDPIY );
+    virtual void			GetScreenFontResolution( sal_Int32& rDPIX, sal_Int32& rDPIY );
+    virtual USHORT			GetBitCount();
+    virtual long			GetGraphicsWidth();
+
+    virtual void			ResetClipRegion();
+    virtual void			BeginSetClipRegion( ULONG nCount );
+    virtual BOOL			unionClipRegion( long nX, long nY, long nWidth, long nHeight );
+    virtual void			EndSetClipRegion();
+
+    virtual void			SetLineColor();
+    virtual void			SetLineColor( SalColor nSalColor );
+    virtual void			SetFillColor();
+
+    virtual void          	SetFillColor( SalColor nSalColor );
+
+    virtual void			SetXORMode( BOOL bSet );
+
+    virtual void			SetROPLineColor( SalROPColor nROPColor );
+    virtual void			SetROPFillColor( SalROPColor nROPColor );
+
+    virtual void			SetTextColor( SalColor nSalColor );
+    virtual USHORT         SetFont( ImplFontSelectData*, int nFallbackLevel );
+    virtual void			GetFontMetric( ImplFontMetricData* );
+    virtual ULONG			GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs );
+    virtual ULONG			GetFontCodeRanges( sal_uInt32* pCodePairs ) const;
+    virtual void			GetDevFontList( ImplDevFontList* );
+    virtual void			GetDevFontSubstList( OutputDevice* );
+    virtual ImplFontData*	AddTempDevFont( const String& rFileURL, const String& rFontName );
+    virtual BOOL			CreateFontSubset( const rtl::OUString& rToFile,
+                                              ImplFontData* pFont,
+                                              sal_Int32* pGlyphIDs,
+                                              sal_uInt8* pEncoding,
+                                              sal_Int32* pWidths,
+                                              int nGlyphs,
+                                              FontSubsetInfo& rInfo
+                                              );
+    virtual const std::map< sal_Unicode, sal_Int32 >* GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** ppNonEncoded );
+    virtual const void*	GetEmbedFontData( ImplFontData* pFont,
+                                          const sal_Unicode* pUnicodes,
+                                          sal_Int32* pWidths,
+                                          FontSubsetInfo& rInfo,
+                                          long* pDataLen );
+    virtual void			FreeEmbedFontData( const void* pData, long nDataLen );
+    virtual BOOL			GetGlyphBoundRect( long nIndex, Rectangle& );
+    virtual BOOL			GetGlyphOutline( long nIndex, PolyPolygon& );
+    virtual SalLayout*		GetTextLayout( ImplLayoutArgs&, int nFallbackLevel );
+    virtual void			DrawServerFontLayout( const ServerFontLayout& );
+    virtual void			drawPixel( long nX, long nY );
+    virtual void			drawPixel( long nX, long nY, SalColor nSalColor );
+    virtual void			drawLine( long nX1, long nY1, long nX2, long nY2 );
+    virtual void			drawRect( long nX, long nY, long nWidth, long nHeight );
+    virtual void			drawPolyLine( ULONG nPoints, const SalPoint* pPtAry );
+    virtual void			drawPolygon( ULONG nPoints, const SalPoint* pPtAry );
+    virtual void			drawPolyPolygon( ULONG nPoly,
+                                             const ULONG* pPoints,
+                                             PCONSTSALPOINT* pPtAry );
+    virtual sal_Bool		drawPolyLineBezier( ULONG nPoints,
+                                                const SalPoint* pPtAry,
+                                                const BYTE* pFlgAry );
+    virtual sal_Bool		drawPolygonBezier( ULONG nPoints,
+                                               const SalPoint* pPtAry,
+                                               const BYTE* pFlgAry );
+    virtual sal_Bool		drawPolyPolygonBezier( ULONG nPoly,
+                                                   const ULONG* pPoints,
+                                                   const SalPoint* const* pPtAry,
+                                                   const BYTE* const* pFlgAry );
+    virtual void			copyArea( long nDestX,
+                                      long nDestY,
+                                      long nSrcX,
+                                      long nSrcY,
+                                      long nSrcWidth,
+                                      long nSrcHeight,
+                                      USHORT nFlags );
+    virtual void			copyBits( const SalTwoRect* pPosAry,
+                                      SalGraphics* pSrcGraphics );
+    virtual void			drawBitmap( const SalTwoRect* pPosAry,
+                                        const SalBitmap& rSalBitmap );
+    virtual void			drawBitmap( const SalTwoRect* pPosAry,
+                                        const SalBitmap& rSalBitmap,
+                                        SalColor nTransparentColor );
+    virtual void			drawBitmap( const SalTwoRect* pPosAry,
+                                        const SalBitmap& rSalBitmap,
+                                        const SalBitmap& rTransparentBitmap );
+    virtual void			drawMask( const SalTwoRect* pPosAry,
+                                      const SalBitmap& rSalBitmap,
+                                      SalColor nMaskColor );
+    virtual SalBitmap*		getBitmap( long nX, long nY, long nWidth, long nHeight );
+    virtual SalColor		getPixel( long nX, long nY );
+    virtual void			invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags );
+    virtual void			invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags );
+
+    virtual BOOL			drawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize );
+
+};
+
+#endif // _VCL_PSPGRAPHICS_H
Index: vcl/unx/inc/salbmp.h
===================================================================
RCS file: vcl/unx/inc/salbmp.h
diff -N vcl/unx/inc/salbmp.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/inc/salbmp.h	22 Jun 2004 17:42:31 -0000	1.3
@@ -0,0 +1,285 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALBMP_H
+#define _SV_SALBMP_H
+
+#ifndef _SALSTD_HXX
+#include <salstd.hxx>
+#endif
+#ifndef _SV_SALGTYPE
+#include <salgtype.hxx>
+#endif
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
+#endif
+#ifndef _SV_SALBMP_HXX
+#include <salbmp.hxx>
+#endif
+
+struct	BitmapBuffer;
+class	BitmapPalette;
+class	SalGraphics;
+class	ImplSalDDB;
+class	ImplSalBitmapCache;
+
+// -------------
+// - SalBitmap -
+// -------------
+
+class X11SalBitmap : public SalBitmap
+{
+private:
+
+	static BitmapBuffer*		ImplCreateDIB( const Size& rSize,
+											   USHORT nBitCount, 
+											   const BitmapPalette& rPal );
+	static BitmapBuffer*		ImplCreateDIB( Drawable aDrawable,
+											   long nDrawableDepth,
+											   long nX, long nY,
+											   long nWidth, long nHeight );
+
+public:
+
+	static ImplSalBitmapCache*	mpCache;
+	static ULONG				mnCacheInstCount;
+
+	static void					ImplCreateCache();
+	static void					ImplDestroyCache();
+    void				        ImplRemovedFromCache();
+
+    bool                        SnapShot (Display* pDisplay, XLIB_Window hWindow);
+    bool                        ImplCreateFromXImage (Display* pDisplay, XLIB_Window hWindow, 
+                                                      XImage* pImage);
+private:
+
+
+	BitmapBuffer*	mpDIB;
+	ImplSalDDB*		mpDDB;
+								
+public:
+
+	bool			ImplCreateFromDrawable( 
+#ifdef _USE_PRINT_EXTENSION_ 
+											SalDisplay* pDisplay,
+#endif
+											Drawable aDrawable, 
+											long nDrawableDepth,
+											long nX, long nY, 
+											long nWidth, long nHeight );
+
+	XImage*			ImplCreateXImage( 
+											SalDisplay* pSalDisp, long nDepth, 
+									  		const SalTwoRect& rTwoRect ) const;
+#ifdef _USE_PRINT_EXTENSION_
+	void			ImplDraw( SalDisplay *pDisplay, Drawable aDrawable, long nDrawableDepth, 
+							  const SalTwoRect& rTwoRect, const GC& rGC, bool bDstIsWindow ) const;
+#else
+	void			ImplDraw( Drawable aDrawable, long nDrawableDepth, 
+							  const SalTwoRect& rTwoRect, const GC& rGC, bool bDstIsWindow ) const;
+#endif
+						
+public:					
+								
+    X11SalBitmap();
+    virtual ~X11SalBitmap();
+
+    // overload pure virtual methods
+	virtual bool			Create( const Size& rSize, 
+                            USHORT nBitCount, 
+							const BitmapPalette& rPal );
+	virtual bool			Create( const SalBitmap& rSalBmp );
+	virtual bool			Create( const SalBitmap& rSalBmp, 
+                                    SalGraphics* pGraphics );
+	virtual bool			Create( const SalBitmap& rSalBmp,
+                                    USHORT nNewBitCount );
+						
+	virtual void			Destroy();
+						
+	virtual Size			GetSize() const;
+	virtual USHORT			GetBitCount() const;
+						
+	virtual BitmapBuffer*	AcquireBuffer( bool bReadOnly );
+	virtual void			ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly );
+};
+
+// --------------
+// - ImplSalDDB -
+// --------------
+
+class ImplSalDDB
+{
+private:
+
+	Pixmap			maPixmap;
+	SalTwoRect		maTwoRect;
+	long			mnDepth;
+
+					ImplSalDDB() {}
+
+    static void	ImplDraw( 
+#ifdef _USE_PRINT_EXTENSION_ 
+								SalDisplay* pDisplay,
+#endif
+    Drawable aSrcDrawable, long nSrcDrawableDepth,
+						      Drawable aDstDrawable, long nDstDrawableDepth,
+						      long nSrcX, long nSrcY, 
+						      long nDestWidth, long nDestHeight, 
+						      long nDestX, long nDestY, const GC& rGC, bool bDstIsWindow );
+					
+public:				
+					
+					ImplSalDDB( 
+#ifdef _USE_PRINT_EXTENSION_ 
+								SalDisplay* pDisplay,
+#endif
+								XImage* pImage, Drawable aDrawable, 
+								const SalTwoRect& rTwoRect );
+					ImplSalDDB( 
+#ifdef _USE_PRINT_EXTENSION_ 
+								SalDisplay* pDisplay,
+#endif
+								Drawable aDrawable, long nDrawableDepth, 
+								long nX, long nY, long nWidth, long nHeight );
+                    ImplSalDDB (Display* pDisplay, XLIB_Window hWindow, XImage* pImage); 
+					~ImplSalDDB();
+					
+	Pixmap			ImplGetPixmap() const { return maPixmap; }
+	long			ImplGetWidth() const { return maTwoRect.mnDestWidth; }
+	long			ImplGetHeight() const { return maTwoRect.mnDestHeight; }
+	long			ImplGetDepth() const { return mnDepth; }
+	ULONG			ImplGetMemSize() const { return( ( maTwoRect.mnDestWidth * maTwoRect.mnDestHeight * mnDepth ) >> 3 ); }
+					
+	bool			ImplMatches( long nDepth, const SalTwoRect& rTwoRect ) const;
+	void			ImplDraw( 
+#ifdef _USE_PRINT_EXTENSION_ 
+								SalDisplay* pDisplay,
+#endif
+								Drawable aDrawable, long nDrawableDepth, 
+								const SalTwoRect& rTwoRect, const GC& rGC, bool bDstIsWindow ) const;
+};
+
+// ----------------------
+// - ImplSalBitmapCache -
+// ----------------------
+
+class ImplSalBitmapCache
+{
+private:
+
+	List			maBmpList;
+	ULONG			mnTotalSize;
+
+public:				
+					
+					ImplSalBitmapCache();
+					~ImplSalBitmapCache();
+
+	void			ImplAdd( X11SalBitmap* pBmp, ULONG nMemSize = 0UL, ULONG nFlags = 0UL );
+	void			ImplRemove( X11SalBitmap* pBmp );
+	void			ImplClear();
+};
+
+#endif // _SV_SALBMP_HXX
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Index: vcl/unx/inc/saldata.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/saldata.hxx,v
retrieving revision 1.5
retrieving revision 1.9
diff -u -p -u -r1.5 -r1.9
--- vcl/unx/inc/saldata.hxx	16 Jul 2003 17:46:41 -0000	1.5
+++ vcl/unx/inc/saldata.hxx	10 May 2004 15:53:52 -0000	1.9
@@ -74,23 +74,17 @@
 #ifndef _SV_SALWTYPE_HXX
 #include <salwtype.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
 
 // -=-= forwards -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 class SalXLib;
 class SalDisplay;
-class SalInstance;
 class SalFrame;
 class SalPrinter;
 
 // -=-= typedefs -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-#ifndef SIG_PF
-typedef void SIG_FUNC_TYP(int);
-typedef SIG_FUNC_TYP *SIG_TYP;
-#define SIG_PF SIG_TYP
-#endif
 
 DECLARE_LIST( SalDisplays, SalDisplay* )
 
@@ -103,63 +97,42 @@ typedef	unsigned int pthread_t;
 // -=-= SalData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 class SalData
 {
-			char**				argv_;
-			int					argc_;
-			String				aBinaryPath_;
-
-			SALTIMERPROC		pTimerProc_;		// timer callback proc
-
-			SIG_TYP				sig_[30];
+protected:
 			BOOL				bNoExceptions_;
 
 			SalXLib			   *pXLib_;
 
-	        SalDisplays			SalDisplays_;
-			SalDisplay		   *pDefDisp_;
-			SalDisplay		   *pCurDisp_;
+			SalDisplay		   *m_pSalDisplay;
 
 	        pthread_t			hMainThread_;
 public:
-			SalInstance		   *pFirstInstance_;	// pointer of first instance
-			SalFrame		   *pFirstFrame_;		// pointer of first frame
-
+			SalInstance*		pInstance_;			// pointer to instance
 public:
-								SalData();
-								~SalData();
+    SalData();
+    virtual ~SalData();
 	
-			void				Init( int *pArgc, char *ppArgv[] );
+    virtual void			Init();
+    virtual void			initNWF();
+    virtual void			deInitNWF();
+    
+	inline	void			XError( Display     *pDisplay, XErrorEvent *pEvent ) const;
+
+    SalDisplay*				GetDisplay() const 
+    { return m_pSalDisplay; }
+    void					SetSalDisplay( SalDisplay* pDisplay )
+    { m_pSalDisplay = pDisplay; }
 
-	inline	const XubString	   &GetFileName() const { return aBinaryPath_; }
-	inline	USHORT				GetCommandLineParamCount() const
-	                                { return argc_; }
-			XubString			GetCommandLineParam( USHORT nParam ) const;
-
-			long				ShutDown() const;
-			long				Close() const;
-	inline	void				XError( Display     *pDisplay,
-										XErrorEvent *pEvent ) const;
-
-	        SalDisplay	       *GetDisplay( Display *pDisplay );
-	inline  SalDisplay         *GetDisplay( long nDisplay ) const
-	                                { return SalDisplays_.GetObject(nDisplay); }
-	inline	SalDisplay		   *GetDefDisp() const { return pDefDisp_; }
-	inline	SalDisplay		   *GetCurDisp() const { return pCurDisp_; }
-	inline	void				SetDefDisp( SalDisplay *pDisp )
-	                                { pDefDisp_ = pDisp; }
-	inline	void				SetCurDisp( SalDisplay *pDisp )
-	                                { pCurDisp_ = pDisp; }
-	inline  void				Insert( SalDisplay *pDisplay );
-	inline  void				Remove( SalDisplay *pDisplay );
+    void					DeleteDisplay(); // for shutdown
 	
-	inline	SalXLib			   *GetLib() const { return pXLib_; }
+	inline	SalXLib*		GetLib() const { return pXLib_; }
 	inline	pthread_t		GetMainThread() const { return hMainThread_; }
 
-			void				StartTimer( ULONG nMS );
-	inline	void				StopTimer();
-	inline	void				SetCallback( SALTIMERPROC pProc )
-	                                { pTimerProc_ = pProc; }
-	        void				Timeout() const;
+    void					StartTimer( ULONG nMS );
+	inline	void			StopTimer();
+    void					Timeout() const;
 
+    static int XErrorHdl( Display*, XErrorEvent* );
+    static int XIOErrorHdl( Display* );
 };
 
 // -=-= inlines =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
@@ -169,12 +142,6 @@ inline void SetSalData( SalData* pData )
 inline SalData* GetSalData()
 { return (SalData*)ImplGetSVData()->mpSalData; }
 
-inline void	SalData::Insert( SalDisplay *pDisplay )
-{ SalDisplays_.Insert( pDisplay ); }
-
-inline void	SalData::Remove( SalDisplay *pDisplay )
-{ SalDisplays_.Remove( pDisplay ); }
-
 #ifdef _SV_SALDISP_HXX
 inline void SalData::XError( Display *pDisplay,	XErrorEvent *pEvent ) const
 { pXLib_->XError( pDisplay, pEvent ); }
@@ -183,7 +150,6 @@ inline void SalData::XError( Display *pD
 class YieldMutexReleaser
 {
 	ULONG				m_nYieldCount;
-	SalYieldMutex*		m_pSalInstYieldMutex;
 public:
 	inline YieldMutexReleaser();
 	inline ~YieldMutexReleaser();
@@ -191,30 +157,12 @@ public:
 
 inline YieldMutexReleaser::YieldMutexReleaser()
 {
-	SalData *pSalData		= GetSalData();
-	m_pSalInstYieldMutex	=
-		pSalData->pFirstInstance_->maInstData.mpSalYieldMutex;
-
-	ULONG i;
-	if ( m_pSalInstYieldMutex->GetThreadId() ==
-		 NAMESPACE_VOS(OThread)::getCurrentIdentifier() )
-	{
-		m_nYieldCount = m_pSalInstYieldMutex->GetAcquireCount();
-		for ( i = 0; i < m_nYieldCount; i++ )
-			m_pSalInstYieldMutex->release();
-	}
-	else
-		m_nYieldCount = 0;
+	m_nYieldCount = GetSalData()->pInstance_->ReleaseYieldMutex();
 }
 
 inline YieldMutexReleaser::~YieldMutexReleaser()
 {
-	// Yield-Semaphore wieder holen
-	while ( m_nYieldCount )
-	{
-		m_pSalInstYieldMutex->acquire();
-		m_nYieldCount--;
-	}
+    GetSalData()->pInstance_->AcquireYieldMutex( m_nYieldCount );
 }
 
 #endif // _SV_SALDATA_HXX
Index: vcl/unx/inc/saldisp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/saldisp.hxx,v
retrieving revision 1.16.122.2
retrieving revision 1.24
diff -u -p -u -r1.16.122.2 -r1.24
--- vcl/unx/inc/saldisp.hxx	9 Jan 2004 18:13:57 -0000	1.16.122.2
+++ vcl/unx/inc/saldisp.hxx	17 Jun 2004 12:26:03 -0000	1.24
@@ -63,15 +63,10 @@
 #define _SV_SALDISP_HXX
 
 // -=-= exports =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-struct	SalAppXResource;
 class	SalDisplay;
 class	SalColormap;
-class	SalColormapRef;
-class	SalTrueColorConverter;
 class	SalVisual;
 class	SalXLib;
-class	SalImageList;
-class	SalBitmapList;
 
 // -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #ifndef _SALUNX_H
@@ -86,32 +81,25 @@ class	SalBitmapList;
 #ifndef _SAL_TYPES_H_
 #include <sal/types.h>
 #endif
-
+#ifndef _OSL_MUTEX_H
+#include <osl/mutex.h>
+#endif
 #include <vector>
+#include <list>
 #ifndef _GEN_HXX
 #include <tools/gen.hxx>
 #endif
+#ifndef _SV_SALWTYPE_HXX
+#include <salwtype.hxx>
+#endif
 
 // -=-= forwards -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 class	BitmapPalette;
-class	SalImage;
-class	SalBitmap;
-class	SalFrameData;
+class	SalFrame;
 class	ColorMask;
-class	SalSystemData;
 
 namespace vcl_sal { class WMAdaptor; }
 
-#ifndef _XSHM_H_
-struct XShmSegmentInfo;
-#endif
-
-// -=-= typedefs -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-typedef struct _oslMutexImpl *oslThreadMutex;
-
-DECLARE_LIST( SalImageList, SalImage* )
-DECLARE_LIST( SalBitmapList,SalBitmap*)
-
 // -=-= #defines -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #define PROPERTY_SUPPORT_WM_SetPos				0x00000001
 #define PROPERTY_SUPPORT_WM_Screen				0x00000002
@@ -185,8 +173,6 @@ enum SalRGB { RGB,  RBG,
 // -=-= SalVisual =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 class SalVisual : public XVisualInfo
 {
-	STDAPI( SalVisual );
-	
     SalRGB			eRGBMode_;
     int				nRedShift_;
     int				nGreenShift_;
@@ -210,11 +196,9 @@ public:
          	BOOL			Convert( int &n0, int &n1, int &n2 ); // 24bit
 };
 
-// -=-= SalColormap/SalColormapRef=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-class SalColormap : public SvRefBase
+// -=-= SalColormap =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+class SalColormap
 {
-	STDAPI( SalColormap );
-	
     SalDisplay	   *pDisplay_;
     Colormap		hColormap_;
     SalColor	   *pPalette_;			// Pseudocolor
@@ -232,7 +216,7 @@ public:
     SalColormap( const BitmapPalette &rpPalette );
     SalColormap( USHORT               nDepth );
     SalColormap();
-	virtual					~SalColormap();
+	~SalColormap();
     
 	inline	Colormap		GetXColormap() const { return hColormap_; }
 	inline	SalDisplay	   *GetDisplay() const { return pDisplay_; }
@@ -257,23 +241,20 @@ public:
     void			SetPalette( const BitmapPalette &rPalette );
 };
 
-SV_DECL_IMPL_REF( SalColormap )
-
 // -=-= SalXLib =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 typedef int(*YieldFunc)(int fd, void* data);
 struct YieldEntry;
 
 class SalXLib
 {
-	STDAPI( SalXLib );
-	
+protected:
     timeval			Timeout_;
     ULONG           nTimeoutMS_;
 	int             pTimeoutFDS_[2];
 
-    int 		    nStateOfYield_;
     BOOL			bWasXError_;
     BOOL			bIgnoreXErrors_;
+    bool			m_bHaveSystemChildFrames;
     int                         nIgnoreErrorLevel;
 
     int				nFDs_;
@@ -283,17 +264,18 @@ class SalXLib
 
 public:
     SalXLib();
-    ~SalXLib();
-    void			Init( int *pArgc, char *ppArgv[] );
+    virtual			~SalXLib();
+    virtual void		Init();
 	
-    void			Yield( BOOL bWait );
-    void			Wakeup();
+    virtual void		Yield( BOOL bWait );
+    virtual void        Wakeup();
+	virtual void		PostUserEvent();
     
-    void			Insert( int fd, void* data,
+    virtual void    Insert( int fd, void* data,
                             YieldFunc	pending,
                             YieldFunc	queued,
                             YieldFunc	handle );
-    void			Remove( int fd );
+    virtual void    Remove( int fd );
     
     void			XError( Display *pDisp, XErrorEvent *pEvent );
 	inline  void                    PushErrorTrap() { nIgnoreErrorLevel++; }
@@ -303,17 +285,13 @@ public:
 	inline	void			SetIgnoreXErrors( BOOL b )
     { bIgnoreXErrors_ = b; bWasXError_ = FALSE; }
     
-	inline  void			StartTimer( ULONG nMS );
-	inline	void			StopTimer();    
+	virtual void			StartTimer( ULONG nMS );
+	virtual void			StopTimer();    
 
     bool            CheckTimeout( bool bExecuteTimers = true );
-};
 
-// -=-= SalXEvent =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-struct SalXEvent
-{
-         	SalXEvent      *pNext_;				// Stack
-	        XEvent			event_;
+    void			setHaveSystemChildFrame() 
+    { m_bHaveSystemChildFrames = true; }
 };
 
 // -=-= SalDisplay -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
@@ -336,8 +314,21 @@ extern "C" {
 
 class SalDisplay
 {
-	STDAPI( SalDisplay );
-	
+// -=-= UserEvent =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+    struct SalUserEvent
+    {
+        SalFrame*		m_pFrame;
+        void*			m_pData;
+        USHORT			m_nEvent;
+        
+        SalUserEvent( SalFrame* pFrame, void* pData, USHORT nEvent = SALEVENT_USEREVENT ) 
+                : m_pFrame( pFrame ),
+                  m_pData( pData ),
+                  m_nEvent( nEvent )
+        {}
+    };
+
+protected:	
     SalXLib		   *pXLib_;
     SalI18N_InputMethod			*mpInputMethod;
     SalI18N_KeyboardExtension	*mpKbdExtension;
@@ -346,9 +337,6 @@ class SalDisplay
     XlfdStorage	   				*mpFontList;
     const ExtendedXlfd			*mpFallbackFactory;
     
-    SalSystemData  *mpSalSystemData;
-    // the one to get create and destroy notify events
-    
     Display		   *pDisp_;				// X Display
     Screen		   *pScreen_;			// XDefaultScreenOfDisplay
     int				nScreen_;			// XDefaultScreen
@@ -356,6 +344,7 @@ class SalDisplay
     XLIB_Window		hRootWindow_;	
     Size			aSize_;				// Screen Size [pixel]
     Pair			aResolution_;		// [dpi]
+    bool			mbExactResolution;
     ULONG			nMaxRequestSize_;	// [byte]
     
     srv_vendor_t	meServerVendor;
@@ -364,18 +353,13 @@ class SalDisplay
     BOOL			bLocal_;			// Server==Client? Init 
     // in SalDisplay::IsLocal()
     BOOL			mbLocalIsValid;		// bLocal_ is valid ?
-    ULONG			nImageDepths_;		// Supported Image Depths
-    ULONG			nSharedImages_;		// Supports MIT-SHM Extension
     // until x bytes
 	
-    int				nStateOfYield_;
-    int             nStateOfSendEvent_;
-    oslThreadMutex  hEventGuard_;
-    SalXEvent	   *pEventQueue_;		// threaded user event queue
-    SalXEvent      *pDispatchStack_;	// Dispatch/Yield
+    oslMutex        hEventGuard_;
+    std::list< SalUserEvent > m_aUserEvents;
     
     XLIB_Cursor		aPointerCache_[POINTER_COUNT];
-    SalFrameData   *pCapture_;
+    SalFrame*		m_pCapture;
     
     // GDI
     SalVisual	   *pVisual_;			// Visual
@@ -387,12 +371,10 @@ class SalDisplay
     GC				pOrGC_;
     GC				pStippleGC_;
     Pixmap			hInvert50_;
-    SalColormapRef  xColor_;
+    SalColormap    *m_pColormap;
     
     SalFontCache   *pFontCache_;
     
-    int				nBeepVolume_;		// Sound
-    
     // Keyboard
     BOOL			bNumLockFromXS_;	// Num Lock handled by X Server
     int				nNumLockIndex_;		// modifier index in modmap
@@ -402,21 +384,20 @@ class SalDisplay
     KeySym			nMod1KeySym_;		// first mod1 modifier
     ByteString		m_aKeyboardName;
     
-    SalBitmapList	Bitmaps_;			// to destroy bitmap resources;
-    
-    SalImageList	SharedImages_;
-    
-    ::vcl_sal::WMAdaptor*	m_pWMAdaptor;
+    vcl_sal::WMAdaptor*	m_pWMAdaptor;
 
     bool			m_bXinerama;
     std::vector< Rectangle > m_aXineramaScreens;
+    std::list<SalFrame*> m_aFrames;
 
     struct SnDisplay           *m_pSnDisplay;
     struct SnLauncheeContext   *m_pSnLauncheeContext;
 	
     void			DestroyFontCache();
-    long			Dispatch( XEvent *pEvent );
+    virtual long	Dispatch( XEvent *pEvent ) = 0;
     void			InitXinerama();
+
+    void			doDestruct();
 public:
 	static	SalDisplay	   *GetSalDisplay( Display* display );
 	static	BOOL			BestVisual( Display     *pDisp,
@@ -424,21 +405,20 @@ public:
 										XVisualInfo &rVI );
 
 							SalDisplay( Display* pDisp,
-										Visual* pVisual = NULL,
-										Colormap aColMap = None);
+										Colormap aColMap = None );
     
-    ~SalDisplay();
+    virtual ~SalDisplay();
     
-    void			Init( Colormap hXColmap, const XVisualInfo* pXVI );
+
+    virtual void			registerFrame( SalFrame* pFrame );
+    virtual void			deregisterFrame( SalFrame* pFrame );
+    void					setHaveSystemChildFrame() const 
+    { pXLib_->setHaveSystemChildFrame(); }
+
+    void			Init( Colormap hXColmap, Visual *pVisual );
     
-    BOOL			IsEvent();
-    void			SendEvent( Atom			aEvent,
-                               void		   *pData,
-                               XLIB_Window	hReceiver = 0 ) const;
-    void			SendEvent( Atom			aEvent,
-                               UINT32	   *pData = 0,
-                               XLIB_Window	hReceiver = 0 ) const;
-    void			Yield( BOOL bWait );
+    void			SendInternalEvent( SalFrame* pFrame, void* pData, USHORT nEvent = SALEVENT_USEREVENT );
+    bool			DispatchInternalEvent();
     void			PrintInfo() const;
     
     void			PrintEvent( const ByteString &rComment,
@@ -466,15 +446,10 @@ public:
                                XIC = NULL ) const;
     
     XLIB_Cursor		GetPointer( int ePointerStyle );
-    int				CaptureMouse( SalFrameData *pCapture );
+    virtual int	CaptureMouse( SalFrame *pCapture );
     
     BOOL			IsLocal();
-	inline  void			Insert( SalBitmap *pBitmap );
-	inline  void			Remove( SalBitmap *pBitmap );
-    
-	inline	SalImage	   *Seek( SalImage *pImage );
-	inline  void			Insert( SalImage *pImage );
-	inline  void			Remove( SalImage *pImage );
+
     void			Remove( XEvent   *pEvent );
 	
 	XLIB_Window		GetRootWindow() const { return hRootWindow_; }
@@ -492,22 +467,20 @@ public:
 	GC				GetStippleGC() const { return pStippleGC_; }
 	GC				GetGC( USHORT nDepth ) const;
 	Pixmap			GetInvert50() const { return hInvert50_; }
-	SalColormap    &GetColormap() const { return *xColor_; }
+	SalColormap    &GetColormap() const { return *m_pColormap; }
 	SalVisual	   *GetVisual() const { return pVisual_; }
 	SalVisual	   *GetRootVisual() const { return pRootVisual_; }
 	const Size	   &GetScreenSize() const { return aSize_; }
 	const Pair	   &GetResolution() const { return aResolution_; }
+    bool			GetExactResolution() const { return mbExactResolution; }
 	ULONG			GetProperties() const { return nProperties_; }
 	ULONG			GetMaxRequestSize() const { return nMaxRequestSize_; }
-	ULONG			GetImageDepths() const { return nImageDepths_; }
-    ULONG			SupportsShm() const { return nSharedImages_; }
-	void			DisableShm() { nSharedImages_ /= 2; } // = 0
-    void			GetScreenFontResolution( long& rDPIX, long& rDPIY ) const;
+    void			GetScreenFontResolution( sal_Int32& rDPIX, sal_Int32& rDPIY ) const;
 	
-	BOOL			MouseCaptured( const SalFrameData *pFrameData ) const
-    { return pCapture_ == pFrameData; }
-    SalFrameData*	GetCaptureFrame() const
-    { return pCapture_; }
+	BOOL			MouseCaptured( const SalFrame *pFrameData ) const
+    { return m_pCapture == pFrameData; }
+    SalFrame*	GetCaptureFrame() const
+    { return m_pCapture; }
 	SalXLib*         GetXLib() { return pXLib_; }
     
 	SalI18N_InputMethod*			GetInputMethod()  { return mpInputMethod;  }
@@ -520,25 +493,14 @@ public:
     ::vcl_sal::WMAdaptor* getWMAdaptor() const { return m_pWMAdaptor; }
     bool			IsXinerama() const { return m_bXinerama; }
     const std::vector< Rectangle >& GetXineramaScreens() const { return m_aXineramaScreens; }
+
+    const std::list< SalFrame* >& getFrames() 
+    { return m_aFrames; }
+    
 };
 
 // -=-= inlines =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-inline void SalDisplay::Remove( SalBitmap *pBitmap )
-{ Bitmaps_.Remove( pBitmap ); }
-	
-inline void SalDisplay::Insert( SalBitmap *pBitmap )
-{ Bitmaps_.Insert( pBitmap ); }
-	
-inline SalImage *SalDisplay::Seek( SalImage *pImage )
-{ return SharedImages_.Seek( pImage ); }
-	
-inline void SalDisplay::Remove( SalImage *pImage )
-{ SharedImages_.Remove( pImage ); }
-	
-inline void SalDisplay::Insert( SalImage *pImage )
-{ SharedImages_.Insert( pImage ); }
-	
 inline GC SalDisplay::GetGC( USHORT nDepth ) const
 { return 1 == nDepth
 	     ? pMonoGC_
@@ -557,6 +519,20 @@ inline Visual *SalColormap::GetXVisual()
 
 inline int SalColormap::GetClass() const
 { return pVisual_ ? pVisual_->GetClass() : PseudoColor; }
+
+class SalX11Display : public SalDisplay
+{
+public:
+		     SalX11Display( Display* pDisp,
+						 Visual* pVisual = NULL,
+						 Colormap aColMap = None );
+    virtual ~SalX11Display();
+
+    virtual long		Dispatch( XEvent *pEvent );
+    virtual void		Yield( BOOL bWait );
+
+    BOOL	 IsEvent();
+};
 
 /*----------------------------------------------------------
  keep track of correct size of the initial window
Index: vcl/unx/inc/salframe.h
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/salframe.h,v
retrieving revision 1.31.42.2
retrieving revision 1.38
diff -u -p -u -r1.31.42.2 -r1.38
--- vcl/unx/inc/salframe.h	2 Mar 2004 10:01:45 -0000	1.31.42.2
+++ vcl/unx/inc/salframe.h	18 May 2004 10:56:20 -0000	1.38
@@ -65,6 +65,9 @@
 #ifndef _SALSTD_HXX
 #include <salstd.hxx>
 #endif
+#ifndef _SV_SALFRAME_HXX
+#include <salframe.hxx>
+#endif
 #ifndef _SV_SALWTYPE_HXX
 #include <salwtype.hxx>
 #endif
@@ -89,9 +92,8 @@
 
 // -=-= forwards -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 class	SalDisplay;
-class	SalGraphics;
-class	SalFrame;
-class	SalColormap;
+class	X11SalGraphics;
+class SalGraphicsLayout;
 class   SalI18N_InputContext;
 
 namespace vcl_sal { class WMAdaptor; class NetWMAdaptor; class GnomeWMAdaptor; }
@@ -113,36 +115,26 @@ class SalFrameDelData 
         SalFrameDelData*    GetNext ()   { return mpNext; }
 }; 
 
-// -=-= SalFrameData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
+// -=-= X11SalFrame =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 #define SHOWSTATE_UNKNOWN		-1
 #define SHOWSTATE_MINIMIZED 	0
 #define SHOWSTATE_NORMAL		1
 #define SHOWSTATE_HIDDEN		2
 
-class SalFrameData
+class X11SalFrame : public SalFrame
 {
-	friend	class			SalFrame;
-    friend class			::vcl_sal::WMAdaptor;
-    friend class			::vcl_sal::NetWMAdaptor;
-    friend class			::vcl_sal::GnomeWMAdaptor;
-	friend  SalFrame* SalInstance::CreateFrame( SalFrame*, ULONG );
-	friend  SalFrame* SalInstance::CreateChildFrame( SystemParentData*, ULONG );
-
-	static Bool checkKeyReleaseForRepeat( Display*, XEvent*, XPointer pSalFrameData );
-    STDAPI( SalFrameData );
+    friend class vcl_sal::WMAdaptor;
+    friend class vcl_sal::NetWMAdaptor;
+    friend class vcl_sal::GnomeWMAdaptor;
+    
+	static Bool checkKeyReleaseForRepeat( Display*, XEvent*, XPointer pX11SalFrame );
 
-    static SalFrame* s_pSaveYourselfFrame;
+    static X11SalFrame* s_pSaveYourselfFrame;
                                 
-    SalFrame	   *pNextFrame_;		// pointer to next frame
-    SalFrame	   *pFrame_;
-
-    SalFrame*       mpParent;            // pointer to parent frame
+    X11SalFrame*	mpParent;            // pointer to parent frame
 	                                // which should never obscur this frame
     bool			mbTransientForRoot;
-    ::std::list< SalFrame* > maChildren;         // List of child frames
-    
-    SALFRAMEPROC	pProc_;				// callback proc
-    void		   *pInst_;				// instance handle for callback
+    std::list< X11SalFrame* > maChildren;         // List of child frames
     
     SalDisplay	   *pDisplay_;
     XLIB_Window		mhWindow;
@@ -155,8 +147,8 @@ class SalFrameData
     XLIB_Cursor		hCursor_;
     int				nCaptured_;			// is captured
     
-    SalGraphics	   *pGraphics_;			// current frame graphics
-    SalGraphics	   *pFreeGraphics_;		// first free frame graphics
+    X11SalGraphics	*pGraphics_;			// current frame graphics
+    X11SalGraphics	*pFreeGraphics_;		// first free frame graphics
     
     XLIB_Time		nReleaseTime_;		// timestamp of last key release
     USHORT			nKeyCode_;			// last key code
@@ -183,7 +175,6 @@ class SalFrameData
     bool			mbMoved;
     bool			mbSized;
     Rectangle		maPaintRegion;
-    bool			mbWasGraphicsPaint;
 
     Timer			maAlwaysOnTopRaiseTimer;
     
@@ -206,8 +197,6 @@ class SalFrameData
     SalFrameDelData *mpDeleteData;
     void            NotifyDeleteData ();
     
-    SalGraphics	   *GetGraphics();
-    
     void			GetPosSize( Rectangle &rPosSize );
     void			SetSize   ( const Size      &rSize );
     void            Center();
@@ -231,45 +220,35 @@ class SalFrameData
     long			HandleReparentEvent	( XReparentEvent	*pEvent );
     long			HandleClientMessage	( XClientMessageEvent*pEvent );
     
-	inline	void			CaptureMouse( BOOL bCapture );
-	inline	void			SetPointer( PointerStyle ePointerStyle );
-
-	inline		            SalFrameData( SalFrame *pFrame );
-	inline			        ~SalFrameData();
-
     DECL_LINK( HandleResizeTimer, void* );
     DECL_LINK( HandleAlwaysOnTopRaise, void* );
 
     void			passOnSaveYourSelf();
 public:
+	X11SalFrame( SalFrame* pParent, ULONG nSalFrameStyle, SystemParentData* pSystemParent = NULL );
+	virtual ~X11SalFrame();
+
     long			Dispatch( XEvent *pEvent );
     void			Init( ULONG nSalFrameStyle, SystemParentData* pParentData = NULL );
-    bool			SetPluginParent( SystemParentData* pNewParent );
 
-    SalDisplay     *GetDisplay() const { return pDisplay_; }
-	inline	Display		   *GetXDisplay() const;
-	inline	XLIB_Window		GetDrawable() const;
-    inline  XLIB_Window    GetWindow() const { return mhWindow; }
-    inline  XLIB_Window    GetShellWindow() const { return mhShellWindow; }
-	inline	XLIB_Window		GetForeignParent() const { return mhForeignParent; }
-	inline	XLIB_Window		GetStackingWindow() const { return mhStackingWindow; }
-	inline	long			ShutDown() const
-				{ return pProc_( pInst_, pFrame_, SALEVENT_SHUTDOWN, 0 ); }
-	inline	long			Close() const
-				{ return pProc_( pInst_, pFrame_, SALEVENT_CLOSE, 0 ); }
-	inline	long			Call( USHORT nEvent, const void *pEvent ) const
-				{ return pProc_( pInst_, pFrame_, nEvent, pEvent ); }
-	inline	SalFrame	   *GetNextFrame() const { return pNextFrame_; }
+    SalDisplay*				GetDisplay() const { return pDisplay_; }
+	Display*				GetXDisplay() const;
+	XLIB_Window				GetDrawable() const;
+    XLIB_Window				GetWindow() const { return mhWindow; }
+    XLIB_Window				GetShellWindow() const { return mhShellWindow; }
+	XLIB_Window				GetForeignParent() const { return mhForeignParent; }
+	XLIB_Window				GetStackingWindow() const { return mhStackingWindow; }
+	long					ShutDown() const { return CallCallback( SALEVENT_SHUTDOWN, 0 ); }
+	long					Close() const { return CallCallback( SALEVENT_CLOSE, 0 ); }
           	ULONG           GetStyle() const { return nStyle_; }
 	
 	inline	XLIB_Cursor		GetCursor() const { return hCursor_; }
 	inline	BOOL			IsCaptured() const { return nCaptured_ == 1; }
-	#if !defined(__synchronous_extinput__)
-			void 			HandleExtTextEvent (XClientMessageEvent *pEvent);
-			void			PostExtTextEvent (sal_uInt16 nExtTextEventType, 
-								void *pExtTextEvent);
-	#endif
-	inline	SalColormap	   &GetColormap() const;
+#if !defined(__synchronous_extinput__)
+    void 			HandleExtTextEvent (XClientMessageEvent *pEvent);
+    void			PostExtTextEvent (sal_uInt16 nExtTextEventType, 
+                                      void *pExtTextEvent);
+#endif
     bool					IsOverrideRedirect() const;
     bool					IsFloatGrabWindow() const;
     SalI18N_InputContext* getInputContext() const { return mpInputContext; }
@@ -278,25 +257,58 @@ public:
     bool					isMapped() const { return bMapped_; }
     void            RegisterDeleteData (SalFrameDelData *pData);
     void            UnregisterDeleteData (SalFrameDelData *pData);
+    
+    virtual SalGraphics*		GetGraphics();
+    virtual void				ReleaseGraphics( SalGraphics* pGraphics );
 
-    static void SaveYourselfDone( SalFrame* );
+    virtual BOOL				PostEvent( void* pData );
 
-    void			YieldGraphicsExpose();
+    virtual void				SetTitle( const XubString& rTitle );
+    virtual void				SetIcon( USHORT nIcon );
+    virtual void				SetMenu( SalMenu* pMenu );
+    virtual void                                DrawMenuBar();
+
+    virtual void				Show( BOOL bVisible, BOOL bNoActivate = FALSE );
+    virtual void				Enable( BOOL bEnable );
+    virtual void              SetMinClientSize( long nWidth, long nHeight );
+    virtual void				SetPosSize( long nX, long nY, long nWidth, long nHeight, USHORT nFlags );
+    virtual void				GetClientSize( long& rWidth, long& rHeight );
+    virtual void				GetWorkArea( Rectangle& rRect );
+    virtual SalFrame*			GetParent() const;
+    virtual void				SetWindowState( const SalFrameState* pState );
+    virtual BOOL				GetWindowState( SalFrameState* pState );
+    virtual void				ShowFullScreen( BOOL bFullScreen );
+    virtual void				StartPresentation( BOOL bStart );
+    virtual void				SetAlwaysOnTop( BOOL bOnTop );
+    virtual void				ToTop( USHORT nFlags );
+    virtual void				SetPointer( PointerStyle ePointerStyle );
+    virtual void				CaptureMouse( BOOL bMouse );
+    virtual void				SetPointerPos( long nX, long nY );
+    virtual void				Flush();
+    virtual void				Sync();
+    virtual void				SetInputContext( SalInputContext* pContext );
+    virtual void				EndExtTextInput( USHORT nFlags );
+    virtual String				GetKeyName( USHORT nKeyCode );
+    virtual String				GetSymbolKeyName( const XubString& rFontName, USHORT nKeyCode );
+    virtual LanguageType		GetInputLanguage();
+    virtual SalBitmap*			SnapShot();
+    virtual void				UpdateSettings( AllSettings& rSettings );
+    virtual void				Beep( SoundType eSoundType );
+    virtual const SystemEnvData*	GetSystemData() const;
+    virtual ULONG				GetCurrentModButtons();
+    virtual void				SetParent( SalFrame* pNewParent );
+    virtual bool				SetPluginParent( SystemParentData* pNewParent );
+
+    static void SaveYourselfDone( SalFrame* );
 };
 
 #ifdef _SV_SALDISP_HXX
 
-inline void SalFrameData::CaptureMouse( BOOL bCapture )
-{ nCaptured_ = pDisplay_->CaptureMouse( bCapture ? this : NULL ); }
-
-inline Display *SalFrameData::GetXDisplay() const
+inline Display *X11SalFrame::GetXDisplay() const
 { return pDisplay_->GetDisplay(); }
 
-inline XLIB_Window SalFrameData::GetDrawable() const
+inline XLIB_Window X11SalFrame::GetDrawable() const
 { return GetWindow(); }
-
-inline	SalColormap	&SalFrameData::GetColormap() const
-{ return pDisplay_->GetColormap(); }
 
 #endif
 
Index: vcl/unx/inc/salgdi.h
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/salgdi.h,v
retrieving revision 1.22.136.1
retrieving revision 1.28
diff -u -p -u -r1.22.136.1 -r1.28
--- vcl/unx/inc/salgdi.h	9 Jan 2004 18:13:58 -0000	1.22.136.1
+++ vcl/unx/inc/salgdi.h	17 Jun 2004 12:26:27 -0000	1.28
@@ -72,6 +72,9 @@ class   SalGraphicsData;
 #ifndef _SALSTD_HXX
 #include <salstd.hxx>
 #endif
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
 #ifndef _SV_SALGTYPE_HXX
 #include <salgtype.hxx>
 #endif
@@ -88,49 +91,34 @@ class   SalBitmap;
 class   SalColormap;
 class   SalDisplay;
 class   SalFrame;
-class   SalVirtualDevice;
+class   X11SalVirtualDevice;
 class   SalPolyLine;
-class   SalPrinter;
-class   SalInfoPrinter;
+class   PspSalPrinter;
+class   PspSalInfoPrinter;
 class   ServerFont;
 class   ImplLayoutArgs;
 class   X11FontLayout;
 class   ServerFontLayout;
 
-#ifndef _USE_PRINT_EXTENSION_
-namespace psp { struct JobData; class PrinterGfx; }
-#endif
-
-#ifndef _SV_SALDISP_HXX
-typedef SalColormap         *SalColormapRef;
-#endif
-
 // -=-= SalGraphicsData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-class SalGraphicsData
+class X11SalGraphics : public SalGraphics
 {
-    friend class            SalGraphics;
-    friend class            SalPrinter;
-    friend class            SalInfoPrinter;
     friend class            X11FontLayout;
     friend class            ServerFontLayout;
-
-    STDAPI( SalGraphicsData );
+protected:
     SalFrame*				m_pFrame; // the SalFrame which created this Graphics or NULL
-    SalVirtualDevice*		m_pVDev;  // the SalVirtualDevice which created this Graphics or NULL
-
-#ifndef _USE_PRINT_EXTENSION_
-    ::psp::JobData*         m_pJobData;
-    ::psp::PrinterGfx*      m_pPrinterGfx;
-    String*                 m_pPhoneNr;
-    bool                    m_bSwallowFaxNo;
-#endif
+    X11SalVirtualDevice*	m_pVDev;  // the SalVirtualDevice which created this Graphics or NULL
 
-    SalColormapRef  xColormap_;
+    SalColormap    *m_pColormap;
+    SalColormap    *m_pDeleteColormap;
     Drawable        hDrawable_;     // use
     
     XLIB_Region     pPaintRegion_;
     XLIB_Region     pClipRegion_;
+
+    int             numClipRects_;
+    Rectangle       boundingClipRect_;
     
     GC              pPenGC_;        // Pen attributes
     SalColor        nPenColor_;
@@ -142,7 +130,6 @@ class SalGraphicsData
 
     SalColor        nTextColor_;
     Pixel           nTextPixel_;
-    short           nFontOrientation_;
     BOOL            bFontVertical_;
     
     GC              pBrushGC_;      // Brush attributes
@@ -176,24 +163,17 @@ class SalGraphicsData
     void			SetClipRegion( GC          pGC,
                                    XLIB_Region pXReg = NULL ) const;
     
-#if defined(_SV_SALGDI_CXX) || defined (_SV_SALGDI2_CXX)
     GC				GetTrackingGC();
     GC				GetInvertGC();
     GC				GetInvert50GC();
     GC				CreateGC( Drawable      hDrawable,
                               unsigned long nMask = GCGraphicsExposures );
-#endif
-
-#if defined _SV_SALGDI_CXX
     GC				SelectPen();
     GC				SelectBrush();
     void			DrawLines( ULONG              nPoints,
                                const SalPolyLine &rPoints,
                                GC				  pGC );
     BOOL			GetDitherPixmap ( SalColor nSalColor );	
-#endif
-
-#if defined _SV_SALGDI2_CXX
 
     inline	GC				GetMonoGC( Pixmap hPixmap );
     inline	GC				GetCopyGC();
@@ -224,103 +204,161 @@ class SalGraphicsData
                                 const SalBitmap  &rSalBitmap,
                                 const SalBitmap  &rTransparentBitmap,
                                 SalColor          nTransparentColor );
-#endif
 
     GC                      SelectFont();
-    bool                    SetFont( const ImplFontSelectData* pEntry, int nFallbackLevel );
+    bool                    setFont( const ImplFontSelectData* pEntry, int nFallbackLevel );
 
 protected:
-    ULONG                   GetFontCodeRanges( sal_uInt32* pCodePairs ) const;
-
     void                    DrawStringUCS2MB( ExtendedFontStruct& rFont, const Point&,
                                 const sal_Unicode* pStr, int nLength );
 
     void                    DrawPrinterString( const SalLayout& );
 
     void                    DrawServerFontString( const ServerFontLayout& );
-    void                    DispatchServerFontString( const ServerFontLayout& );
     void                    DrawServerSimpleFontString( const ServerFontLayout& );
     void                    DrawServerAAFontString( const ServerFontLayout& );
     bool                    DrawServerAAForcedString( const ServerFontLayout& );
-
-    SalLayout*              GetTextLayout( ImplLayoutArgs&, int nFallbackLevel );
 public:
-                            SalGraphicsData();
-                            ~SalGraphicsData();
+                            X11SalGraphics();
+    virtual				~X11SalGraphics();
 
-            void            Init( SalFrame *pFrame );
-            void            Init( SalVirtualDevice *pVirtualDevice,
-                                SalGraphics *pSalGraphics );
+            void            Init( SalFrame *pFrame, Drawable aDrawable );
+            void            Init( X11SalVirtualDevice *pVirtualDevice );
             void            Init( class ImplSalPrinterData *pPrinter );
             void            DeInit();
 
     inline  SalDisplay     *GetDisplay() const;
     inline  Display        *GetXDisplay() const;
+    inline  SalVisual		*GetVisual() const;
     inline  Drawable        GetDrawable() const { return hDrawable_; }
     inline  void            SetDrawable( Drawable d ) { hDrawable_ = d; }
-    inline  SalColormap    &GetColormap() const { return *xColormap_; }
-    inline  BOOL            IsCompatible( USHORT nDepth,
-                                          SalColormap *pMap ) const;
+    inline  SalColormap    &GetColormap() const { return *m_pColormap; }
     inline  Pixel           GetPixel( SalColor nSalColor ) const;
 
-            String            FaxPhoneComment( const String& rOrig, xub_StrLen nIndex, xub_StrLen& rLen, xub_StrLen& rCutStart, xub_StrLen& rCutStop ) const;
+    inline  int            GetNumCliprects() const { return numClipRects_; }
+    inline  const Rectangle& GetBoundingCliprect() const { return boundingClipRect_; }
+    
+        
+    // overload all pure virtual methods
+    virtual void			GetResolution( sal_Int32& rDPIX, sal_Int32& rDPIY );
+    virtual void			GetScreenFontResolution( sal_Int32& rDPIX, sal_Int32& rDPIY );
+    virtual USHORT			GetBitCount();
+    virtual long			GetGraphicsWidth();
+
+    virtual void			ResetClipRegion();
+    virtual void			BeginSetClipRegion( ULONG nCount );
+    virtual BOOL			unionClipRegion( long nX, long nY, long nWidth, long nHeight );
+    virtual void			EndSetClipRegion();
+
+    virtual void			SetLineColor();
+    virtual void			SetLineColor( SalColor nSalColor );
+    virtual void			SetFillColor();
+
+    virtual void          	SetFillColor( SalColor nSalColor );
+
+    virtual void			SetXORMode( BOOL bSet );
+
+    virtual void			SetROPLineColor( SalROPColor nROPColor );
+    virtual void			SetROPFillColor( SalROPColor nROPColor );
+
+    virtual void			SetTextColor( SalColor nSalColor );
+    virtual USHORT         SetFont( ImplFontSelectData*, int nFallbackLevel );
+    virtual void			GetFontMetric( ImplFontMetricData* );
+    virtual ULONG			GetKernPairs( ULONG nPairs, ImplKernPairData* pKernPairs );
+    virtual ULONG			GetFontCodeRanges( sal_uInt32* pCodePairs ) const;
+    virtual void			GetDevFontList( ImplDevFontList* );
+    virtual void			GetDevFontSubstList( OutputDevice* );
+    virtual ImplFontData*	AddTempDevFont( const String& rFileURL, const String& rFontName );
+    virtual BOOL			CreateFontSubset( const rtl::OUString& rToFile,
+                                              ImplFontData* pFont,
+                                              sal_Int32* pGlyphIDs,
+                                              sal_uInt8* pEncoding,
+                                              sal_Int32* pWidths,
+                                              int nGlyphs,
+                                              FontSubsetInfo& rInfo
+                                              );
+    virtual const std::map< sal_Unicode, sal_Int32 >* GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** ppNonEncoded );
+    virtual const void*	GetEmbedFontData( ImplFontData* pFont,
+                                          const sal_Unicode* pUnicodes,
+                                          sal_Int32* pWidths,
+                                          FontSubsetInfo& rInfo,
+                                          long* pDataLen );
+    virtual void			FreeEmbedFontData( const void* pData, long nDataLen );
+    virtual BOOL			GetGlyphBoundRect( long nIndex, Rectangle& );
+    virtual BOOL			GetGlyphOutline( long nIndex, PolyPolygon& );
+    virtual SalLayout*		GetTextLayout( ImplLayoutArgs&, int nFallbackLevel );
+    virtual void			DrawServerFontLayout( const ServerFontLayout& );
+    virtual void			drawPixel( long nX, long nY );
+    virtual void			drawPixel( long nX, long nY, SalColor nSalColor );
+    virtual void			drawLine( long nX1, long nY1, long nX2, long nY2 );
+    virtual void			drawRect( long nX, long nY, long nWidth, long nHeight );
+    virtual void			drawPolyLine( ULONG nPoints, const SalPoint* pPtAry );
+    virtual void			drawPolygon( ULONG nPoints, const SalPoint* pPtAry );
+    virtual void			drawPolyPolygon( ULONG nPoly,
+                                             const ULONG* pPoints,
+                                             PCONSTSALPOINT* pPtAry );
+    virtual sal_Bool		drawPolyLineBezier( ULONG nPoints,
+                                                const SalPoint* pPtAry,
+                                                const BYTE* pFlgAry );
+    virtual sal_Bool		drawPolygonBezier( ULONG nPoints,
+                                               const SalPoint* pPtAry,
+                                               const BYTE* pFlgAry );
+    virtual sal_Bool		drawPolyPolygonBezier( ULONG nPoly,
+                                                   const ULONG* pPoints,
+                                                   const SalPoint* const* pPtAry,
+                                                   const BYTE* const* pFlgAry );
+    virtual void			copyArea( long nDestX,
+                                      long nDestY,
+                                      long nSrcX,
+                                      long nSrcY,
+                                      long nSrcWidth,
+                                      long nSrcHeight,
+                                      USHORT nFlags );
+    virtual void			copyBits( const SalTwoRect* pPosAry,
+                                      SalGraphics* pSrcGraphics );
+    virtual void			drawBitmap( const SalTwoRect* pPosAry,
+                                        const SalBitmap& rSalBitmap );
+    virtual void			drawBitmap( const SalTwoRect* pPosAry,
+                                        const SalBitmap& rSalBitmap,
+                                        SalColor nTransparentColor );
+    virtual void			drawBitmap( const SalTwoRect* pPosAry,
+                                        const SalBitmap& rSalBitmap,
+                                        const SalBitmap& rTransparentBitmap );
+    virtual void			drawMask( const SalTwoRect* pPosAry,
+                                      const SalBitmap& rSalBitmap,
+                                      SalColor nMaskColor );
+    virtual SalBitmap*		getBitmap( long nX, long nY, long nWidth, long nHeight );
+    virtual SalColor		getPixel( long nX, long nY );
+    virtual void			invert( long nX, long nY, long nWidth, long nHeight, SalInvert nFlags );
+    virtual void			invert( ULONG nPoints, const SalPoint* pPtAry, SalInvert nFlags );
+
+    virtual BOOL			drawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize );
+
+    /*  use to handle GraphicsExpose/NoExpose after XCopyArea & friends
+     *  if pFrame is not NULL, corresponding Paint events are generated
+     *  and dispatched to pFrame
+     *
+     *  it is imperative to eat up graphics exposes even in case you don't need
+     *  them because the next one using XCopyArea can depend on them
+     */
+    static void YieldGraphicsExpose( Display* pDisplay, SalFrame* pFrame, Drawable aDrawable );
 };
 
 
-#ifdef _SV_SALDATA_HXX
-
-inline SalDisplay *SalGraphicsData::GetDisplay() const
+inline SalDisplay *X11SalGraphics::GetDisplay() const
 { return GetColormap().GetDisplay(); }
 
-inline Display *SalGraphicsData::GetXDisplay() const
-{ return GetColormap().GetXDisplay(); }
+inline SalVisual *X11SalGraphics::GetVisual() const
+{ return GetColormap().GetDisplay()->GetVisual(); }
 
-inline BOOL SalGraphicsData::IsCompatible( USHORT       nDepth,
-                                           SalColormap *pMap ) const
-{
-    return (GetDisplay()->GetImageDepths() & (1 << (nDepth-1))) != 0
-            && &xColormap_ == pMap;
-}
+inline Display *X11SalGraphics::GetXDisplay() const
+{ return GetColormap().GetXDisplay(); }
 
-inline Pixel SalGraphicsData::GetPixel( SalColor nSalColor ) const
+inline Pixel X11SalGraphics::GetPixel( SalColor nSalColor ) const
 { return GetColormap().GetPixel( nSalColor ); }
 
-#endif
 
 // -=-= Shortcuts =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-#if defined _SV_SALGDI_CXX || defined _SV_SALGDI2_CXX || defined _SV_SALGDI3_CXX
-#define _GetXDisplay()		maGraphicsData.GetXDisplay()
-#define _GetDisplay()		maGraphicsData.GetDisplay()
-#define _GetVisual()		maGraphicsData.GetDisplay()->GetVisual()
-#define _GetDrawable()		maGraphicsData.hDrawable_
-#define _GetColormap()		maGraphicsData.GetColormap()
-#define _GetClipRegion()	maGraphicsData.pClipRegion_
-#define	_GetPenPixel()		maGraphicsData.nPenPixel_
-#define	_GetTextPixel()		maGraphicsData.nTextPixel_
-#define	_GetBrushPixel()	maGraphicsData.nBrushPixel_
-#define	_GetPenColor()		maGraphicsData.nPenColor_
-#define	_GetTextColor()		maGraphicsData.nTextColor_
-#define	_GetBrushColor()	maGraphicsData.nBrushColor_
-#define _GetPixel(n)		maGraphicsData.GetPixel( n )
-#define _GetColor(n)		maGraphicsData.GetColormap().GetColor( n )
-#define	_IsPenGC()			maGraphicsData.bPenGC_
-#define	_IsFontGC()			maGraphicsData.bFontGC_
-#define	_IsBrushGC()		maGraphicsData.bBrushGC_
-#define	_IsMonoGC()			maGraphicsData.bMonoGC_
-#define	_IsCopyGC()			maGraphicsData.bCopyGC_
-#define	_IsInvertGC()		maGraphicsData.bInvertGC_
-#define	_IsInvert50GC()		maGraphicsData.bInvert50GC_
-#define	_IsStippleGC()		maGraphicsData.bStippleGC_
-#define	_IsTrackingGC()		maGraphicsData.bTrackingGC_
-#define _IsXORMode()		maGraphicsData.bXORMode_
-#define _IsWindow()			maGraphicsData.bWindow_
-#define _IsPrinter()		maGraphicsData.bPrinter_
-#define _IsVirtualDevice()	maGraphicsData.bVirDev_
-#define _IsDitherBrush()	maGraphicsData.bDitherBrush_
-#define _SelectPen()		maGraphicsData.SelectPen()
-#define _SelectBrush()		maGraphicsData.SelectBrush()
-#define _GetTrackingGC()	maGraphicsData.GetTrackingGC()
-#endif
 
 #ifdef DBG_UTIL
 #define stderr0( s )			fprintf( stderr, s )
Index: vcl/unx/inc/salinst.h
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/salinst.h,v
retrieving revision 1.3
retrieving revision 1.8
diff -u -p -u -r1.3 -r1.8
--- vcl/unx/inc/salinst.h	14 Jun 2001 13:31:23 -0000	1.3
+++ vcl/unx/inc/salinst.h	18 May 2004 10:56:33 -0000	1.8
@@ -82,9 +72,13 @@
 #ifndef _VOS_THREAD_HXX
 #include <vos/thread.hxx>
 #endif
+#ifndef _SV_SALINST_HXX
+#include <salinst.hxx>
+#endif
 
 class SalYieldMutex : public NAMESPACE_VOS(OMutex)
 {
+protected:
 	ULONG										mnCount;
 	NAMESPACE_VOS(OThread)::TThreadIdentifier	mnThreadId;
 
@@ -100,20 +94,68 @@ public:
 };
 
 // -=-= SalInstanceData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-class SalInstanceData
+class X11SalInstance : public SalInstance
 {
-	friend class SalInstance;
-
-public:
-
-	void*							mpFilterInst;
-	void*							mpFilterCallback;
+protected:
 	SalYieldMutex*					mpSalYieldMutex;
-	bool(*mpEventCallback)(void*,void*,int);
-	void*							mpEventInst;
-	bool(*mpErrorEventCallback)(void*,void*,int);
-	void*							mpErrorEventInst;
     bool							mbPrinterInit;
+
+public:
+    X11SalInstance( SalYieldMutex* pMutex ) 
+            : mpSalYieldMutex( pMutex ),
+              mbPrinterInit( false )
+    {}
+    virtual ~X11SalInstance();
+
+    virtual SalFrame*      	CreateChildFrame( SystemParentData* pParent, ULONG nStyle );
+    virtual SalFrame*      	CreateFrame( SalFrame* pParent, ULONG nStyle );
+    virtual void				DestroyFrame( SalFrame* pFrame );
+
+    virtual SalObject*			CreateObject( SalFrame* pParent );
+    virtual void				DestroyObject( SalObject* pObject );
+
+    virtual SalVirtualDevice*	CreateVirtualDevice( SalGraphics* pGraphics,
+                                                     long nDX, long nDY,
+                                                     USHORT nBitCount );
+    virtual void				DestroyVirtualDevice( SalVirtualDevice* pDevice );
+
+    virtual SalInfoPrinter*	CreateInfoPrinter( SalPrinterQueueInfo* pQueueInfo,
+                                               ImplJobSetup* pSetupData );
+    virtual void				DestroyInfoPrinter( SalInfoPrinter* pPrinter );
+    virtual SalPrinter*		CreatePrinter( SalInfoPrinter* pInfoPrinter );
+    virtual void				DestroyPrinter( SalPrinter* pPrinter );
+
+    virtual void				GetPrinterQueueInfo( ImplPrnQueueList* pList );
+    virtual void				GetPrinterQueueState( SalPrinterQueueInfo* pInfo );
+    virtual void				DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo );
+    virtual String             GetDefaultPrinter();
+
+    virtual SalSound*			CreateSalSound();
+    virtual SalTimer*			CreateSalTimer();
+    virtual SalOpenGL*			CreateSalOpenGL( SalGraphics* pGraphics );
+    virtual SalI18NImeStatus*	CreateI18NImeStatus();
+    virtual SalSystem*			CreateSalSystem();
+    virtual SalBitmap*			CreateSalBitmap();
+    virtual SalSession*			CreateSalSession();
+
+    virtual vos::IMutex*		GetYieldMutex();
+    virtual ULONG				ReleaseYieldMutex();
+    virtual void				AcquireYieldMutex( ULONG nCount );
+
+    virtual void				Yield( BOOL bWait );
+    virtual bool				AnyInput( USHORT nType );
+    virtual SalMenu*        CreateMenu( BOOL bMenuBar );
+    virtual void            DestroyMenu( SalMenu* pMenu);
+    virtual SalMenuItem*    CreateMenuItem( const SalItemParams* pItemData );
+    virtual void            DestroyMenuItem( SalMenuItem* pItem );
+
+    virtual void*				GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes );
+
+
+    bool isPrinterInit() const 
+    {
+        return mbPrinterInit;
+    }
 };
 
 #endif // _SV_SALINST_H
Index: vcl/unx/inc/salmenu.h
===================================================================
RCS file: vcl/unx/inc/salmenu.h
diff -N vcl/unx/inc/salmenu.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/inc/salmenu.h	20 Nov 2003 13:03:09 -0000	1.3
@@ -0,0 +1,106 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALMENU_H
+#define _SV_SALMENU_H
+
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+#ifndef _SV_BITMAP_HXX
+#include <bitmap.hxx>
+#endif
+
+#ifndef _SV_SALMENU_HXX
+#include <salmenu.hxx>
+#endif
+
+
+class X11SalMenu : public SalMenu
+{
+public:
+	X11SalMenu() {}
+	virtual ~X11SalMenu();
+
+    virtual BOOL VisibleMenuBar();  // must return TRUE to actually DISPLAY native menu bars
+                            // otherwise only menu messages are processed (eg, OLE on Windows)
+
+    virtual void InsertItem( SalMenuItem* pSalMenuItem, unsigned nPos );
+    virtual void RemoveItem( unsigned nPos );
+    virtual void SetSubMenu( SalMenuItem* pSalMenuItem, SalMenu* pSubMenu, unsigned nPos );
+    virtual void SetFrame( const SalFrame* pFrame );
+    virtual void CheckItem( unsigned nPos, BOOL bCheck );
+    virtual void EnableItem( unsigned nPos, BOOL bEnable );
+    virtual void SetItemText( unsigned nPos, SalMenuItem* pSalMenuItem, const XubString& rText );
+    virtual void SetItemImage( unsigned nPos, SalMenuItem* pSalMenuItem, const Image& rImage);
+    virtual void SetAccelerator( unsigned nPos, SalMenuItem* pSalMenuItem, const KeyCode& rKeyCode, const XubString& rKeyName );
+    virtual void GetSystemMenuData( SystemMenuData* pData );
+};
+
+class X11SalMenuItem : public SalMenuItem
+{
+public:
+	X11SalMenuItem() {}
+        virtual ~X11SalMenuItem();
+};
+
+#endif // _SV_SALMENU_H
+
Index: vcl/unx/inc/salobj.h
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/salobj.h,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/unx/inc/salobj.h	24 Oct 2001 16:32:21 -0000	1.2
+++ vcl/unx/inc/salobj.h	18 Nov 2003 14:38:20 -0000	1.3
@@ -71,15 +71,13 @@
 #ifndef _LIST_HXX
 #include <tools/list.hxx>
 #endif
+#ifndef _SV_SALOBJ_HXX
+#include <salobj.hxx>
+#endif
 
+class X11SalObject;
 
-// -----------------
-// - SalObjectData -
-// -----------------
-
-class SalObject;
-
-DECLARE_LIST( SalObjectList, SalObject* );
+DECLARE_LIST( SalObjectList, X11SalObject* );
 
 class SalClipRegion
 {
@@ -112,12 +110,9 @@ private:
 };
 
 
-class SalObjectData
+class X11SalObject : public SalObject
 {
-	friend class SalObject;
-	friend class SalDisplay;
-	friend class SalInstance;
-
+public:
 	static SalObjectList aAllObjects;
 
 	SystemChildData maSystemChildData;
@@ -130,6 +125,27 @@ class SalObjectData
 	BOOL			mbVisible;
 
 	static long Dispatch( XEvent* pEvent );
+
+    X11SalObject();
+    virtual ~X11SalObject();
+
+    // overload all pure virtual methods
+ 	virtual void					ResetClipRegion();
+	virtual USHORT					GetClipRegionType();
+	virtual void					BeginSetClipRegion( ULONG nRects );
+	virtual void					UnionClipRegion( long nX, long nY, long nWidth, long nHeight );
+	virtual void					EndSetClipRegion();
+
+	virtual void					SetPosSize( long nX, long nY, long nWidth, long nHeight );
+	virtual void					Show( BOOL bVisible );
+	virtual void					Enable( BOOL nEnable );
+	virtual void					GrabFocus();
+
+	virtual void					SetBackground();
+	virtual void					SetBackground( SalColor nSalColor );
+
+	virtual const SystemEnvData*	GetSystemData() const;
+   
 };
 
 #endif // _SV_SALOBJ_H
Index: vcl/unx/inc/salogl.h
===================================================================
RCS file: vcl/unx/inc/salogl.h
diff -N vcl/unx/inc/salogl.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/inc/salogl.h	18 Nov 2003 14:38:28 -0000	1.2
@@ -0,0 +1,138 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALOGL_H
+#define _SV_SALOGL_H
+
+#if defined EXPLICITLY_INCLUDE_GLX_H
+#include <prex.h>
+#define GL_H
+#include <GL/glx.h>
+#include <postx.h>
+#else
+typedef void* GLXContext;
+typedef XID   GLXDrawable;
+// needed GLX_ constants
+#define GLX_USE_GL			1
+#define GLX_DOUBLEBUFFER	5
+#endif
+
+#ifndef _SV_SALOGL_HXX
+#include <salogl.hxx>
+#endif
+
+#ifndef _OSL_MODULE_H
+#include <osl/module.h>
+#endif
+
+// -------------
+// - SalOpenGL -
+// -------------
+
+class SalGraphics;
+
+class X11SalOpenGL : public SalOpenGL
+{
+private:
+	static oslModule		mpGLLib;
+	static GLXContext		maGLXContext;
+	static ULONG			mnOGLState;
+	static Display*		mpDisplay;
+	static XVisualInfo*	mpVisualInfo;
+	static BOOL			mbHaveGLVisual;
+
+	static BOOL			ImplInit();
+	static void			ImplFreeLib();
+
+	static GLXContext (*pCreateContext)( Display *, XVisualInfo *, GLXContext, Bool );
+	static void       (*pDestroyContext)( Display *, GLXContext );
+	static GLXContext (*pGetCurrentContext)( );
+	static Bool       (*pMakeCurrent)( Display *, GLXDrawable, GLXContext );
+	static void		(*pSwapBuffers)( Display*, GLXDrawable );
+	static int		(*pGetConfig)( Display*, XVisualInfo*, int, int* );
+	static void		(*pFlush)();
+
+	Drawable            maDrawable;
+
+	static void* resolveSymbol( const char* pSym );
+public:					
+						
+    X11SalOpenGL( SalGraphics* pGraphics );
+    ~X11SalOpenGL();
+						
+	static void		Release();
+	static void		MakeVisualWeights(
+                                      Display *pDisplay,
+                                      XVisualInfo* pInfos,
+                                      int* pWeights,
+                                      int nVisuals
+                                      );
+						
+    // overload all pure virtual methods
+	virtual bool		IsValid();
+	virtual void*		GetOGLFnc( const char * );
+	virtual void		OGLEntry( SalGraphics* pGraphics );
+	virtual void		OGLExit( SalGraphics* pGraphics );
+    virtual void		StartScene( SalGraphics* pGraphics );
+	virtual void		StopScene();
+};
+
+#endif // _SV_SALOGL_H
Index: vcl/unx/inc/salprn.h
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/salprn.h,v
retrieving revision 1.9
retrieving revision 1.11
diff -u -p -u -r1.9 -r1.11
--- vcl/unx/inc/salprn.h	13 Nov 2002 20:24:03 -0000	1.9
+++ vcl/unx/inc/salprn.h	20 Feb 2004 08:56:54 -0000	1.11
@@ -62,8 +62,6 @@
 #ifndef _SV_SALPRN_H
 #define _SV_SALPRN_H
 
-#ifndef _USE_PRINT_EXTENSION_
-
 #ifndef _PSPRINT_JOBDATA_HXX_
 #include <psprint/jobdata.hxx>
 #endif
@@ -73,29 +71,68 @@
 #ifndef _PSPRINT_PRINTERJOB_HXX_
 #include <psprint/printerjob.hxx>
 #endif
+#ifndef _SV_SALPRN_HXX
+#include <salprn.hxx>
+#endif
 
-class SalGraphics;
+class PspGraphics;
 
-struct SalInfoPrinterData
+class PspSalInfoPrinter : public SalInfoPrinter
 {
-	SalGraphics*			m_pGraphics;
-	::psp::JobData			m_aJobData;
-	::psp::PrinterGfx		m_aPrinterGfx;
+public:
+	PspGraphics*			m_pGraphics;
+	psp::JobData			m_aJobData;
+	psp::PrinterGfx			m_aPrinterGfx;
+
+    PspSalInfoPrinter();
+    virtual ~PspSalInfoPrinter();
+
+    // overload all pure virtual methods
+	virtual SalGraphics*			GetGraphics();
+	virtual void					ReleaseGraphics( SalGraphics* pGraphics );
+    virtual BOOL					Setup( SalFrame* pFrame, ImplJobSetup* pSetupData );
+	virtual BOOL					SetPrinterData( ImplJobSetup* pSetupData );
+	virtual BOOL					SetData( ULONG nFlags, ImplJobSetup* pSetupData );
+	virtual void					GetPageInfo( const ImplJobSetup* pSetupData,
+                                                 long& rOutWidth, long& rOutHeight,
+                                                 long& rPageOffX, long& rPageOffY,
+                                                 long& rPageWidth, long& rPageHeight );
+	virtual ULONG					GetCapabilities( const ImplJobSetup* pSetupData, USHORT nType );
+	virtual ULONG					GetPaperBinCount( const ImplJobSetup* pSetupData );
+	virtual String					GetPaperBinName( const ImplJobSetup* pSetupData, ULONG nPaperBin );
+    virtual void					InitPaperFormats( const ImplJobSetup* pSetupData );
+    virtual int					GetLandscapeAngle( const ImplJobSetup* pSetupData );
 };
 
-struct SalPrinterData
+class PspSalPrinter : public SalPrinter
 {
+public:
 	String					m_aFileName;
 	String					m_aTmpFile;
 	String					m_aFaxNr;
 	bool					m_bFax:1;
 	bool					m_bPdf:1;
 	bool					m_bSwallowFaxNo:1;
-	SalGraphics*			m_pGraphics;
-	::psp::PrinterJob		m_aPrintJob;
-	::psp::JobData			m_aJobData;
-	::psp::PrinterGfx		m_aPrinterGfx;
+	PspGraphics*			m_pGraphics;
+	psp::PrinterJob			m_aPrintJob;
+	psp::JobData			m_aJobData;
+	psp::PrinterGfx			m_aPrinterGfx;
     ULONG					m_nCopies;
+
+    PspSalPrinter();
+    virtual ~PspSalPrinter();
+
+    // overload all pure virtual methods
+	virtual BOOL					StartJob( const XubString* pFileName,
+                                              const XubString& rJobName,
+                                              const XubString& rAppName,
+                                              ULONG nCopies, BOOL bCollate,
+                                              ImplJobSetup* pSetupData );
+	virtual BOOL					EndJob();
+	virtual BOOL					AbortJob();
+	virtual SalGraphics*			StartPage( ImplJobSetup* pSetupData, BOOL bNewJobData );
+	virtual BOOL					EndPage();
+	virtual ULONG					GetErrorCode();
 };
 
 class Timer;
@@ -114,74 +151,6 @@ public:
     static void jobEnded();
 };
 }
-
-#else
-
-#ifndef _SALSTD_HXX
-#include <salstd.hxx>
-#endif
-
-#ifndef _SV_PRNTYPES_HXX
-#include <prntypes.hxx>
-#endif
-
-// forward declarations
-class SalInfoPrinter;
-
-class SalPrinterQueueInfo;
-class ImplJobSetup;
-
-class ImplSalPrinterData;
-
-
-// class declarations
-
-
-class SalInfoPrinterData
-{
-  friend class SalInfoPrinter;
-  friend class SalPrinterData;
-
-  ImplSalPrinterData*	mpImplData;
- 
-  inline		SalInfoPrinterData();
-  inline		~SalInfoPrinterData();
-
-public:
-
-  inline void	Init( SalPrinterQueueInfo*	pQueueInfo,
-					  ImplJobSetup*			pJobSetup);
-};
-
-
-// -=-= SalPrinterData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-class SalPrinterData
-{
-	friend class SalPrinter;
-	
-	ImplSalPrinterData*	mpImplData;
-	
-	BOOL					mbJobStarted;		// is job started
-	BOOL					mbPageStarted;		// is page started
-	String					maFileName;			// print to file
-	int						mnError;			// error code
-	ImplJobSetup*			mpJobSetup;			// job setup
-	BOOL					mbAbort:1;			// is job aborted
-	BOOL					mbFirstPage:1;		// false after first startpage
-	
-	inline		SalPrinterData();
-	inline		~SalPrinterData();
-
-public:
-	inline void	Init( SalInfoPrinter*	pInfoPrinter );
-};
-
-
-// necessary to get changes in Xpdefaults
-void StartPrinterListening();
-void StopPrinterListening();
-
-#endif
 
 #endif // _SV_SALPRN_H
 
Index: vcl/unx/inc/salprn.imp
===================================================================
RCS file: vcl/unx/inc/salprn.imp
diff -N vcl/unx/inc/salprn.imp
--- vcl/unx/inc/salprn.imp	18 Sep 2000 17:05:41 -0000	1.1.1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,3 +0,0 @@
-static void xprinterPrologHandler( void*, void* );
-static void xprinterGlobalSetupHandler( void*, void* );
-static void xprinterPageSetupHandler( void*, int, void* );
Index: vcl/unx/inc/salsound.h
===================================================================
RCS file: vcl/unx/inc/salsound.h
diff -N vcl/unx/inc/salsound.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/inc/salsound.h	18 Nov 2003 14:39:11 -0000	1.2
@@ -0,0 +1,114 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALSOUND_H
+#define _SV_SALSOUND_H
+
+#ifndef _SV_SALSOUND_HXX
+#include <salsound.hxx>
+#endif
+
+// ------------
+// - SalSound -
+// ------------
+
+namespace vcl_sal { class VSound; }
+
+class X11SalSound : public SalSound
+{
+// public for VSound sub classes
+public:
+	// the real sound
+	vcl_sal::VSound*		m_pVSound;
+	
+	// the sound to play
+	ByteString				m_aSoundFile;
+	
+	// state data
+	bool					m_bLoop;
+	bool					m_bPlaying;
+	bool					m_bPaused;
+	
+	ULONG					m_nStartTime;
+	ULONG					m_nPlayTime;
+	
+	void changeStateStop();
+	void changeStatePause();
+	void changeStateCont();
+	void setError( ULONG );
+public:
+    X11SalSound();
+	virtual ~X11SalSound();
+	
+    // overload all pure virtual methods
+    virtual bool		IsValid();
+    virtual bool		Init( const String&	rSoundName,
+                              ULONG&		rSoundLen );
+   	virtual void		Play( ULONG nStartTime, ULONG nPlayTime, bool bLoop );
+	virtual void		Stop();
+	virtual void		Pause();
+	virtual void		Continue();
+    virtual bool		IsLoopMode() const;
+	virtual bool		IsPlaying() const;
+    virtual bool		IsPaused() const;
+};
+
+#endif // _SV_SALSOUND_HXX
Index: vcl/unx/inc/salstd.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/salstd.hxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/unx/inc/salstd.hxx	12 Oct 2001 09:20:59 -0000	1.2
+++ vcl/unx/inc/salstd.hxx	6 Jan 2004 14:25:49 -0000	1.3
@@ -74,14 +74,6 @@
 #endif
 #ifndef _SV_SV_H
 #include <sv.h>
-#endif
-
-// -=-= #defines -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-#ifndef STDAPI
-#define STDAPI(Class)	int		operator != ( const Class& ) const; \
-                        int     operator == ( const Class& ) const; \
-						Class  &operator = ( const Class& ); \
-						Class( const Class& )
 #endif
 
 // -=-= X-Lib forwards -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
Index: vcl/unx/inc/salsys.h
===================================================================
RCS file: vcl/unx/inc/salsys.h
diff -N vcl/unx/inc/salsys.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/inc/salsys.h	20 Feb 2004 08:57:04 -0000	1.3
@@ -0,0 +1,98 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+// -=-= includes -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+#ifndef _SV_SALSYS_H
+#define _SV_SALSYS_H
+
+#ifndef _SV_SV_H
+#include <sv.h>
+#endif
+#ifndef _VOS_MUTEX_HXX
+#include <vos/mutex.hxx>
+#endif
+#ifndef _VOS_THREAD_HXX
+#include <vos/thread.hxx>
+#endif
+#ifndef _SV_SALSYS_HXX
+#include <salsys.hxx>
+#endif
+#include <list>
+
+class X11SalSystem : public SalSystem
+{
+public:
+    X11SalSystem() {}
+    virtual ~X11SalSystem();
+    
+    // overload pure virtual methods
+    virtual bool GetSalSystemDisplayInfo( DisplayInfo& rInfo );
+    virtual int ShowNativeDialog( const String& rTitle,
+                                  const String& rMessage,
+                                  const std::list< String >& rButtons,
+                                  int nDefButton );
+    virtual int ShowNativeMessageBox( const String& rTitle,
+                                      const String& rMessage,
+                                      int nButtonCombination,
+                                      int nDefaultButton);
+};
+
+#endif // _SV_SALSYS_H
Index: vcl/unx/inc/saltimer.h
===================================================================
RCS file: vcl/unx/inc/saltimer.h
diff -N vcl/unx/inc/saltimer.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/inc/saltimer.h	18 Nov 2003 14:39:32 -0000	1.2
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _SV_SALTIMER_H
+#define _SV_SALTIMER_H
+
+#ifndef _SV_SALTIMER_HXX
+#include <saltimer.hxx>
+#endif
+
+class X11SalTimer : public SalTimer
+{
+public:
+    X11SalTimer() {}
+    virtual ~X11SalTimer();
+
+    // overload all pure virtual methods
+	void 			Start( ULONG nMS );
+	void 			Stop();
+};
+
+#endif
Index: vcl/unx/inc/salvd.h
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/salvd.h,v
retrieving revision 1.2
retrieving revision 1.4
diff -u -p -u -r1.2 -r1.4
--- vcl/unx/inc/salvd.h	18 Jun 2002 11:26:23 -0000	1.2
+++ vcl/unx/inc/salvd.h	18 Nov 2003 14:39:44 -0000	1.4
@@ -76,36 +66,36 @@
 #ifndef _SALSTD_HXX
 #include <salstd.hxx>
 #endif
+#ifndef _SV_SALVD_HXX
+#include <salvd.hxx>
+#endif
 
 // -=-= forwards -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 class SalDisplay;
-class SalGraphics;
-class SalVirtualDevice;
+class X11SalGraphics;
 
 // -=-= SalVirDevData -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-class SalVirDevData
+class X11SalVirtualDevice : public SalVirtualDevice
 {
-	friend	class			SalVirtualDevice;
-
-			SalDisplay	   *pDisplay_;
-			SalGraphics	   *pGraphics_;			// current frame graphics
-
-			Pixmap			hDrawable_;
-
-			int				nDX_;
-			int				nDY_;
-			USHORT			nDepth_;
-			BOOL			bGraphics_;			// is Graphics used
-
-	inline					SalVirDevData();
-	inline					~SalVirDevData();
-
+    SalDisplay		*pDisplay_;
+    X11SalGraphics	*pGraphics_;
+	
+    
+    Pixmap			hDrawable_;
+    
+    int				nDX_;
+    int				nDY_;
+    USHORT			nDepth_;
+    BOOL			bGraphics_;			// is Graphics used
+    
 public:
-			BOOL			Init( SalDisplay *pDisplay,
-								  long nDX, long nDY,
-								  USHORT nBitCount );
-	inline	void			InitGraphics( SalVirtualDevice *pVD,
-										  SalGraphics	   *pGraphics );
+	X11SalVirtualDevice();
+    virtual ~X11SalVirtualDevice();
+
+    BOOL			Init( SalDisplay *pDisplay,
+                          long nDX, long nDY,
+                          USHORT nBitCount );
+	inline	void			InitGraphics( X11SalVirtualDevice *pVD );
 
 	inline	Display		   *GetXDisplay() const;
 	inline	SalDisplay	   *GetDisplay() const;
@@ -114,21 +104,26 @@ public:
 	inline	USHORT			GetDepth() const { return nDepth_; }
     int						GetWidth() const { return nDX_; }
     int						GetHeight() const { return nDY_; }
+
+    virtual SalGraphics*	GetGraphics();
+    virtual void			ReleaseGraphics( SalGraphics* pGraphics );
+
+                            // Set new size, without saving the old contents
+    virtual BOOL			SetSize( long nNewDX, long nNewDY );
 };
 
 #ifdef _SV_SALDISP_HXX
 
-inline void SalVirDevData::InitGraphics( SalVirtualDevice *pVD,
-										 SalGraphics	  *pGraphics )
-{ pGraphics_->maGraphicsData.Init( pVD, pGraphics ); }
+inline void X11SalVirtualDevice::InitGraphics( X11SalVirtualDevice *pVD )
+{ pGraphics_->Init( pVD ); }
 
-inline Display *SalVirDevData::GetXDisplay() const
+inline Display *X11SalVirtualDevice::GetXDisplay() const
 { return pDisplay_->GetDisplay(); }
 
-inline SalDisplay *SalVirDevData::GetDisplay() const
+inline SalDisplay *X11SalVirtualDevice::GetDisplay() const
 { return pDisplay_; }
 
-inline BOOL SalVirDevData::IsDisplay() const
+inline BOOL X11SalVirtualDevice::IsDisplay() const
 { return pDisplay_->IsDisplay(); }
 
 #endif
Index: vcl/unx/inc/wmadaptor.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/wmadaptor.hxx,v
retrieving revision 1.18
retrieving revision 1.19
diff -u -p -u -r1.18 -r1.19
--- vcl/unx/inc/wmadaptor.hxx	30 Jun 2003 14:31:11 -0000	1.18
+++ vcl/unx/inc/wmadaptor.hxx	18 Nov 2003 14:39:55 -0000	1.19
@@ -76,7 +76,7 @@
 #include <vector>
 
 class SalDisplay;
-class SalFrame;
+class X11SalFrame;
 
 namespace vcl_sal {
 
@@ -227,7 +227,7 @@ public:
     /*
      *  sets window title
      */
-    virtual void setWMName( SalFrame* pFrame, const String& rWMName ) const;
+    virtual void setWMName( X11SalFrame* pFrame, const String& rWMName ) const;
 
     /*
      *  maximizes frame
@@ -235,11 +235,11 @@ public:
      *  to get the original position and size
      *  use maximizeFrame( pFrame, false, false )
      */
-    virtual void maximizeFrame( SalFrame* pFrame, bool bHorizontal = true, bool bVertical = true ) const;
+    virtual void maximizeFrame( X11SalFrame* pFrame, bool bHorizontal = true, bool bVertical = true ) const;
     /*
      *  start/stop fullscreen mode on a frame
      */
-    virtual void showFullScreen( SalFrame* pFrame, bool bFullScreen ) const;
+    virtual void showFullScreen( X11SalFrame* pFrame, bool bFullScreen ) const;
 
     /*
      *  tells whether fullscreen mode is supported by WM
@@ -249,13 +249,13 @@ public:
     /*
      *  shade/unshade frame
      */
-    virtual void shade( SalFrame* pFrame, bool bToShaded ) const;
+    virtual void shade( X11SalFrame* pFrame, bool bToShaded ) const;
 
     /*
      *  set hints what decoration is needed;
      *  must be called before showing the frame
      */
-    virtual void setFrameTypeAndDecoration( SalFrame* pFrame, WMWindowType eType, int nDecorationFlags, SalFrame* pTransientFrame = NULL ) const;
+    virtual void setFrameTypeAndDecoration( X11SalFrame* pFrame, WMWindowType eType, int nDecorationFlags, X11SalFrame* pTransientFrame = NULL ) const;
 
     /*
      *  tells whether there is WM support for splash screens
@@ -265,7 +265,7 @@ public:
     /*
      *  enables always on top or equivalent if possible
      */
-    virtual void enableAlwaysOnTop( SalFrame* pFrame, bool bEnable ) const;
+    virtual void enableAlwaysOnTop( X11SalFrame* pFrame, bool bEnable ) const;
 
     /*
      *  tells whether enableAlwaysOnTop actually works with this WM
@@ -275,7 +275,7 @@ public:
     /*
      *  handle WM messages (especially WM state changes)
      */
-    virtual int handlePropertyNotify( SalFrame* pFrame, XPropertyEvent* pEvent ) const;
+    virtual int handlePropertyNotify( X11SalFrame* pFrame, XPropertyEvent* pEvent ) const;
 
     /*
      *  gets a WM atom
@@ -305,7 +305,7 @@ public:
      *  changes the transient hint of a window to reference frame
      *  if reference frame is NULL the root window is used instead
      */
-    void changeReferenceFrame( SalFrame* pFrame, SalFrame* pReferenceFrame ) const;
+    void changeReferenceFrame( X11SalFrame* pFrame, X11SalFrame* pReferenceFrame ) const;
 };
 
 } // namespace
Index: vcl/unx/inc/xfont.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/xfont.hxx,v
retrieving revision 1.12.122.1
retrieving revision 1.14
diff -u -p -u -r1.12.122.1 -r1.14
--- vcl/unx/inc/xfont.hxx	9 Jan 2004 18:13:58 -0000	1.12.122.1
+++ vcl/unx/inc/xfont.hxx	17 Jun 2004 12:26:53 -0000	1.14
@@ -160,12 +160,12 @@ class ExtendedFontStruct : public SvRefB
 
 		sal_Size			GetDefaultWidth();
 		sal_Size 			GetCharWidth8( sal_Unicode nFrom, sal_Unicode nTo, 
-									long *pWidthArray, 
+									sal_Int32 *pWidthArray, 
 									rtl_TextEncoding nEncoding );
 		sal_Size 			GetCharWidthUTF16( sal_Unicode nFrom, sal_Unicode nTo, 
-									long *pWidthArray );
+									sal_Int32 *pWidthArray );
 		sal_Size 			GetCharWidth16( sal_Unicode nFrom, sal_Unicode nTo, 
-									long *pWidthArray, ExtendedFontStruct *pFallback );
+									sal_Int32 *pWidthArray, ExtendedFontStruct *pFallback );
 	public:
 							ExtendedFontStruct( Display* pDisplay, 
 									const Size& rPixelSize, sal_Bool bVertical,
@@ -179,7 +179,7 @@ class ExtendedFontStruct : public SvRefB
 		Bool				ToImplFontMetricData( ImplFontMetricData *pMetric );
 		rtl_TextEncoding	GetAsciiEncoding( int *pAsciiRange = NULL ) const;
 		sal_Size			GetCharWidth( sal_Unicode, 
-									long *pPhysWidth, long* pLogWidth );
+									sal_Int32* pPhysWidth, sal_Int32* pLogWidth );
         int                 GetFontCodeRanges( sal_uInt32* pCodePairs ) const;
         bool                HasUnicodeChar( sal_Unicode ) const;
 };
Index: vcl/unx/source/app/devaudiosound.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/devaudiosound.cxx,v
retrieving revision 1.7.74.1
retrieving revision 1.11
diff -u -p -u -r1.7.74.1 -r1.11
--- vcl/unx/source/app/devaudiosound.cxx	13 Nov 2003 16:49:08 -0000	1.7.74.1
+++ vcl/unx/source/app/devaudiosound.cxx	17 Mar 2004 10:05:58 -0000	1.11
@@ -59,7 +59,7 @@
  *
  ************************************************************************/
 
-#include <salsound.hxx>
+#include <salsound.h>
 #include <salimpsound.hxx>
 
 #include <svapp.hxx>
@@ -80,11 +80,9 @@
 #include <sal/types.h>
 #endif
 
-#ifdef _USE_NAMESPACE
 using namespace vcl_sal;
 using namespace vos;
 using namespace osl;
-#endif
 
 int									DevAudioSound::s_nDevice = -1;
 DevAudioDataList					DevAudioSound::s_aDataList;
@@ -294,7 +292,7 @@ BOOL DevAudioSound::startRIFF( DevAudioD
 	return TRUE;
 }
 
-int DevAudioSound::findChunk( DevAudioData* pData, char* pChunk )
+int DevAudioSound::findChunk( DevAudioData* pData, const char* pChunk )
 {
 	if( !pData || ! pData->m_pSound || ! pData->m_pSound->m_pBuffer )
 		return -1;
@@ -311,18 +309,18 @@ int DevAudioSound::findChunk( DevAudioDa
 	return -1;
 }
 
-short int DevAudioSound::readLEShort( char* pBuf )
+short int DevAudioSound::readLEShort( const char* pBuf )
 {
-	unsigned char* pBuffer = (unsigned char*)pBuf;
+	const unsigned char* pBuffer = (const unsigned char*)pBuf;
 	short int nRet = *pBuffer++;
 	nRet |= *pBuffer << 8;
 
 	return nRet;
 }
 
-ULONG DevAudioSound::readBELong( char* pBuf )
+ULONG DevAudioSound::readBELong( const char* pBuf )
 {
-	unsigned char* pBuffer = (unsigned char*)pBuf;
+	const unsigned char* pBuffer = (const unsigned char*)pBuf;
 	ULONG nRet	 = *pBuffer++ << 24;
 	nRet		|= *pBuffer++ << 16;
 	nRet		|= *pBuffer++ << 8;
@@ -331,9 +329,9 @@ ULONG DevAudioSound::readBELong( char* p
 	return nRet;
 }
 
-int DevAudioSound::readLEInt( char* pBuf )
+int DevAudioSound::readLEInt( const char* pBuf )
 {
-	unsigned char* pBuffer = (unsigned char*)pBuf;
+	const unsigned char* pBuffer = (const unsigned char*)pBuf;
 	int nRet = *pBuffer++;
 	nRet |= (int)(*pBuffer++) << 8;
 	nRet |= (int)(*pBuffer++) << 16;
@@ -391,7 +389,10 @@ void DevAudioSound::run()
                     pData->m_nCurPos += nBytes;
 
                     aGuard.clear();
-                    usleep(50000);
+                    TimeValue aVal;
+                    aVal.Seconds = 0;
+                    aVal.Nanosec = 50000000;
+                    osl_waitThread( &aVal );
                     aGuard.reset();
 
                     if( s_aDataList.GetObject( 0 ) != pData )
@@ -452,7 +453,7 @@ void DevAudioSound::remove( DevAudioSoun
 	}
 }
 
-DevAudioSound::DevAudioSound( ::SalSound* pSound ) :
+DevAudioSound::DevAudioSound( ::X11SalSound* pSound ) :
 		VSound( pSound )
 {
 	initBuffer();
Index: vcl/unx/source/app/i18n_cb.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/i18n_cb.cxx,v
retrieving revision 1.18.120.1
retrieving revision 1.21
diff -u -p -u -r1.18.120.1 -r1.21
--- vcl/unx/source/app/i18n_cb.cxx	15 Aug 2003 11:24:53 -0000	1.18.120.1
+++ vcl/unx/source/app/i18n_cb.cxx	6 Jan 2004 14:26:47 -0000	1.21
@@ -88,6 +88,9 @@
 #ifndef _SAL_I18N_INPUTMETHOD_HXX
 #include "i18n_im.hxx"
 #endif
+#ifndef _OSL_THREAD_H
+#include <osl/thread.h>
+#endif
 
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
@@ -128,9 +131,9 @@ PreeditDoneCallback ( XIC ic, XPointer c
         if( pPreeditData->pFrame )
         {
 #ifdef __synchronous_extinput__
-            pPreeditData->pFrame->maFrameData.Call( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
+            pPreeditData->pFrame->CallCallback( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
 #else
-            pPreeditData->pFrame->maFrameData.PostExtTextEvent( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
+            pPreeditData->pFrame->PostExtTextEvent( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
 #endif
         }
 	}
@@ -265,7 +268,6 @@ Preedit_InsertText(preedit_text_t *pText
       		sal_uInt32  nConversionInfo;
       		sal_Size    nConvertedChars;
 
-      		sal_Size nSize =
 			rtl_convertTextToUnicode( aConverter, aContext,
 					pMBString, nMBLength,
 	 				pInsertTextString, nBufferSize,
@@ -377,12 +379,13 @@ Preedit_FeedbackToSAL ( XIMFeedback* pfe
       		if (nfeedback & XIMTertiary) // same as 2ery
 				nval |= SAL_EXTTEXTINPUT_ATTR_DASHDOTUNDERLINE;
 
-#if 0 // visibility feedback not supported now
+			/*
+			// visibility feedback not supported now
       		if (   (nfeedback & XIMVisibleToForward)
 	  			|| (nfeedback & XIMVisibleToBackward)
 	  			|| (nfeedback & XIMVisibleCenter) )
 			{ }
-#endif
+			*/
     	}
     	// copy in list
     	psalattr[npos] = nval;
@@ -470,12 +473,11 @@ PreeditDrawCallback(XIC ic, XPointer cli
   	aTextEvent.mbOnlyCursor = False;
 
   	if ( pPreeditData->eState == ePreeditStatusActive && pPreeditData->pFrame )
-    	pPreeditData->pFrame->maFrameData.Call(SALEVENT_EXTTEXTINPUT,
-				(void*)&aTextEvent);
+    	pPreeditData->pFrame->CallCallback(SALEVENT_EXTTEXTINPUT, (void*)&aTextEvent);
   	if (aTextEvent.mpTextAttr)
     	free((void*)aTextEvent.mpTextAttr);
     if (pPreeditData->aText.nLength == 0 && pPreeditData->pFrame )
-	    pPreeditData->pFrame->maFrameData.Call( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
+	    pPreeditData->pFrame->CallCallback( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
 
 #else
 
@@ -493,10 +495,10 @@ PreeditDrawCallback(XIC ic, XPointer cli
 
     if( pPreeditData->pFrame )
     {
-        pPreeditData->pFrame->maFrameData.PostExtTextEvent (SALEVENT_EXTTEXTINPUT,
+        pPreeditData->pFrame->PostExtTextEvent (SALEVENT_EXTTEXTINPUT,
                                                             (void*)pTextEvent);
         if (pPreeditData->aText.nLength == 0)
-            pPreeditData->pFrame->maFrameData.PostExtTextEvent( SALEVENT_ENDEXTTEXTINPUT,
+            pPreeditData->pFrame->PostExtTextEvent( SALEVENT_ENDEXTTEXTINPUT,
                                                                 (void*)NULL );
     }
 #endif
@@ -519,8 +521,7 @@ GetPreeditSpotLocation(XIC ic, XPointer 
   	preedit_data_t* pPreeditData = (preedit_data_t*)client_data;
 
     if( pPreeditData->pFrame )
-        pPreeditData->pFrame->maFrameData.Call(SALEVENT_EXTTEXTINPUTPOS,
-                                               (void*)&mPosEvent);
+        pPreeditData->pFrame->CallCallback(SALEVENT_EXTTEXTINPUTPOS, (void*)&mPosEvent);
 
   	XPoint point;
   	point.x = mPosEvent.mnX + mPosEvent.mnWidth;
@@ -547,8 +548,8 @@ PreeditCaretCallback ( XIC ic, XPointer 
 	XIMPreeditCaretCallbackStruct *call_data )
 {
 	// XXX PreeditCaretCallback is pure debug code for now
-	char *direction = "?";
-	char *style = "?";
+	const char *direction = "?";
+	const char *style = "?";
 
 	switch ( call_data->style )
 	{
@@ -611,11 +612,9 @@ CommitStringCallback( XIC ic, XPointer c
         if( pPreeditData->pFrame )
         {
 #ifdef __synchronous_extinput__
-            pPreeditData->pFrame->maFrameData.Call( SALEVENT_ENDEXTTEXTINPUT,
-                                                    (void*)NULL );
+            pPreeditData->pFrame->CallCallback( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
 #else
-            pPreeditData->pFrame->maFrameData.PostExtTextEvent(SALEVENT_ENDEXTTEXTINPUT,
-                                                               (void*)NULL );
+            pPreeditData->pFrame->PostExtTextEvent(SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
 #endif
         }
     }
@@ -635,10 +634,8 @@ CommitStringCallback( XIC ic, XPointer c
             aTextEvent.mnDeltaStart 	= 0;
             aTextEvent.mbOnlyCursor 	= False;
 
-            pPreeditData->pFrame->maFrameData.Call( SALEVENT_EXTTEXTINPUT,
-                                                    (void*)&aTextEvent);
-            pPreeditData->pFrame->maFrameData.Call( SALEVENT_ENDEXTTEXTINPUT,
-                                                    (void*)NULL );
+            pPreeditData->pFrame->CallCallback( SALEVENT_EXTTEXTINPUT, (void*)&aTextEvent);
+            pPreeditData->pFrame->CallCallback( SALEVENT_ENDEXTTEXTINPUT, (void*)NULL );
 #else
 
             SalExtTextInputEvent *pTextEvent = new SalExtTextInputEvent;
@@ -651,9 +648,9 @@ CommitStringCallback( XIC ic, XPointer c
             pTextEvent->mnDeltaStart 	= 0;
             pTextEvent->mbOnlyCursor 	= False;
 
-            pPreeditData->pFrame->maFrameData.PostExtTextEvent( SALEVENT_EXTTEXTINPUT,
+            pPreeditData->pFrame->PostExtTextEvent( SALEVENT_EXTTEXTINPUT,
                                                                 (void*)pTextEvent);
-            pPreeditData->pFrame->maFrameData.PostExtTextEvent( SALEVENT_ENDEXTTEXTINPUT,
+            pPreeditData->pFrame->PostExtTextEvent( SALEVENT_ENDEXTTEXTINPUT,
                                                                 (void*)NULL );
 #endif
         }
Index: vcl/unx/source/app/i18n_ic.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/i18n_ic.cxx,v
retrieving revision 1.26.42.1
retrieving revision 1.30
diff -u -p -u -r1.26.42.1 -r1.30
--- vcl/unx/source/app/i18n_ic.cxx	2 Mar 2004 10:02:10 -0000	1.26.42.1
+++ vcl/unx/source/app/i18n_ic.cxx	18 May 2004 10:57:02 -0000	1.30
@@ -88,13 +88,25 @@
 #endif
 
 #ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#include <salframe.h>
+#endif
+
+#ifndef _SV_SYSDATA_HXX
+#include <sysdata.hxx>
+#endif
+
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
 #endif
 
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
 
+#ifndef _OSL_THREAD_H
+#include <osl/thread.h>
+#endif
+
 using namespace vcl;
 
 // ---------------------------------------------------------------------------
@@ -183,11 +195,6 @@ get_font_set( Display *p_display )
 SalI18N_InputContext::SalI18N_InputContext ( SalFrame *pFrame ) :
         mbUseable( True ),
         maContext( (XIC)NULL ),
-        mpAttributes( NULL ),
-        mpStatusAttributes( NULL ),
-        mpPreeditAttributes( NULL ),
-        mnStatusStyle( 0 ),
-        mnPreeditStyle( 0 ),
         mnSupportedStatusStyle(
                                XIMStatusCallbacks   |
                                XIMStatusNothing     |
@@ -198,6 +205,11 @@ SalI18N_InputContext::SalI18N_InputConte
                                 XIMPreeditNothing   |
                                 XIMPreeditNone
                                 ),
+        mnStatusStyle( 0 ),
+        mnPreeditStyle( 0 ),
+        mpAttributes( NULL ),
+        mpStatusAttributes( NULL ),
+        mpPreeditAttributes( NULL ),
         mpFocusFrame( NULL )
 {
 #ifdef SOLARIS
@@ -210,7 +222,7 @@ SalI18N_InputContext::SalI18N_InputConte
     maClientData.aText.pCharStyle     = NULL;
 
     SalI18N_InputMethod *pInputMethod;
-    pInputMethod = pFrame->maFrameData.GetDisplay()->GetInputMethod();
+    pInputMethod = GetSalData()->GetDisplay()->GetInputMethod();
     mbMultiLingual = pInputMethod->IsMultiLingual();
 
     mnSupportedPreeditStyle =   XIMPreeditCallbacks | XIMPreeditPosition
@@ -218,8 +230,9 @@ SalI18N_InputContext::SalI18N_InputConte
     if (pInputMethod->UseMethod()
         && SupportInputMethodStyle( pInputMethod->GetSupportedStyles() ) )
     {
-        XLIB_Window  aClientWindow = pFrame->maFrameData.GetShellWindow();
-        XLIB_Window  aFocusWindow  = pFrame->maFrameData.GetWindow();
+        const SystemEnvData* pEnv = pFrame->GetSystemData();
+        XLIB_Window  aClientWindow = pEnv->aShellWindow;
+        XLIB_Window  aFocusWindow  = pEnv->aWindow;
 
         // for status callbacks and commit string callbacks
 #define PREEDIT_BUFSZ 16
@@ -309,7 +322,7 @@ SalI18N_InputContext::SalI18N_InputConte
             {
                 // spot location
                 SalExtTextInputPosEvent aPosEvent;
-                pFrame->maFrameData.Call(SALEVENT_EXTTEXTINPUTPOS, (void*)&aPosEvent);
+                pFrame->CallCallback(SALEVENT_EXTTEXTINPUTPOS, (void*)&aPosEvent);
 
                 static XPoint aSpot;
                 aSpot.x = aPosEvent.mnX + aPosEvent.mnWidth;
@@ -324,7 +337,7 @@ SalI18N_InputContext::SalI18N_InputConte
                 // XCreateIC() fails on Redflag Linux 2.0 if there is no
                 // fontset though the data itself is not evaluated nor is
                 // it required according to the X specs.
-                Display* pDisplay = pFrame->maFrameData.GetDisplay()->GetDisplay();
+                Display* pDisplay = GetSalData()->GetDisplay()->GetDisplay();
                 XFontSet pFontSet = get_font_set(pDisplay);
 
                 if (pFontSet != NULL)
@@ -476,7 +489,7 @@ SalI18N_InputContext::Map( SalFrame *pFr
             if ( maContext == NULL )
             {
                 SalI18N_InputMethod *pInputMethod;
-                pInputMethod = pFrame->maFrameData.GetDisplay()->GetInputMethod();
+                pInputMethod = GetSalData()->GetDisplay()->GetInputMethod();
 
                 maContext = XCreateIC( pInputMethod->GetMethod(),
                                        XNVaNestedList, mpAttributes,
@@ -660,8 +673,8 @@ SalI18N_InputContext::CommitKeyEvent(sal
         aTextEvent.mnDeltaStart  = 0;
         aTextEvent.mbOnlyCursor  = False;
 
-        maClientData.pFrame->maFrameData.Call (SALEVENT_EXTTEXTINPUT,    (void*)&aTextEvent);
-        maClientData.pFrame->maFrameData.Call (SALEVENT_ENDEXTTEXTINPUT, (void*)NULL);
+        maClientData.pFrame->CallCallback(SALEVENT_EXTTEXTINPUT,    (void*)&aTextEvent);
+        maClientData.pFrame->CallCallback(SALEVENT_ENDEXTTEXTINPUT, (void*)NULL);
     }
 #if OSL_DEBUG_LEVEL > 1
     else
@@ -678,7 +691,7 @@ SalI18N_InputContext::UpdateSpotLocation
         return -1;
 
     SalExtTextInputPosEvent aPosEvent;
-    maClientData.pFrame->maFrameData.Call(SALEVENT_EXTTEXTINPUTPOS, (void*)&aPosEvent);
+    maClientData.pFrame->CallCallback(SALEVENT_EXTTEXTINPUTPOS, (void*)&aPosEvent);
 
     XPoint aSpot;
     aSpot.x = aPosEvent.mnX + aPosEvent.mnWidth;
@@ -710,14 +723,16 @@ SalI18N_InputContext::SetICFocus( SalFra
         if( mpFocusFrame )
         {
             mpFocusFrame->EndExtTextInput( SAL_FRAME_ENDEXTTEXTINPUT_COMPLETE );
-            mpFocusFrame->maFrameData.getInputContext()->UnsetICFocus( mpFocusFrame );
+            // FIXME: remove cast to X11SalFrame
+            static_cast<X11SalFrame*>(mpFocusFrame)->getInputContext()->UnsetICFocus( mpFocusFrame );
         }
 
         mpFocusFrame = pFocusFrame;
         maClientData.pFrame = pFocusFrame;
 
-        XLIB_Window  aClientWindow= pFocusFrame->maFrameData.GetShellWindow();
-        XLIB_Window  aFocusWindow= pFocusFrame->maFrameData.GetWindow();
+        const SystemEnvData* pEnv	= pFocusFrame->GetSystemData();
+        XLIB_Window  aClientWindow	= pEnv->aShellWindow;
+        XLIB_Window  aFocusWindow	= pEnv->aWindow;
 
         XSetICValues( maContext,
                       XNFocusWindow,       aFocusWindow,
@@ -755,7 +770,6 @@ SalI18N_InputContext::UnsetICFocus( SalF
 void
 SalI18N_InputContext::SetPreeditState(Bool aPreeditState)
 {
-#if XlibSpecificationRelease >= 6
     XIMPreeditState preedit_state = XIMPreeditUnKnown;
     XVaNestedList preedit_attr;
 
@@ -776,7 +790,6 @@ SalI18N_InputContext::SetPreeditState(Bo
     }
 
     XFree(preedit_attr);
-#endif
 
     return;
 }
@@ -793,7 +806,6 @@ SalI18N_InputContext::EndExtTextInput( U
 {
     if ( mbUseable && (maContext != NULL) )
     {
-#if XlibSpecificationRelease >= 6
         // restore conversion state after resetting XIC
         XIMPreeditState preedit_state = XIMPreeditUnKnown;
         XVaNestedList preedit_attr;
@@ -808,14 +820,12 @@ SalI18N_InputContext::EndExtTextInput( U
             is_preedit_state = True;
         }
         XFree(preedit_attr);
-#endif
 
         char *pPendingChars = XmbResetIC( maContext );
 
         if (pPendingChars == NULL && maClientData.eState != ePreeditStatusStartPending )
             PreeditDoneCallback (maContext, (char*)&maClientData, NULL);
 
-#if XlibSpecificationRelease >= 6
         preedit_attr = XVaCreateNestedList(0,
                                            XNPreeditState, preedit_state,
                                            0);
@@ -826,7 +836,6 @@ SalI18N_InputContext::EndExtTextInput( U
                          NULL);
         }
         XFree(preedit_attr);
-#endif
         // text is unicode
         if ( (pPendingChars != NULL)
              && (nFlags & SAL_FRAME_ENDEXTTEXTINPUT_COMPLETE) )
Index: vcl/unx/source/app/i18n_im.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/i18n_im.cxx,v
retrieving revision 1.23.110.3
retrieving revision 1.30
diff -u -p -u -r1.23.110.3 -r1.30
--- vcl/unx/source/app/i18n_im.cxx	2 Mar 2004 10:02:23 -0000	1.23.110.3
+++ vcl/unx/source/app/i18n_im.cxx	17 Jun 2004 12:27:17 -0000	1.30
@@ -61,7 +61,9 @@
 
 #include <stdio.h>
 #ifdef LINUX
-#define __USE_XOPEN
+#  ifndef __USE_XOPEN
+#    define __USE_XOPEN
+#  endif
 #endif
 #include <poll.h>
 
@@ -309,10 +311,10 @@ SalI18N_InputMethod::PosixLocale()
 //
 // ------------------------------------------------------------------------
 
-SalI18N_InputMethod::SalI18N_InputMethod( ) : maMethod( (XIM)NULL ),
-								  			  mpStyles( (XIMStyles*)NULL ),
-								  			  mbUseable( bUseInputMethodDefault ),
-											  mbMultiLingual( False )
+SalI18N_InputMethod::SalI18N_InputMethod( ) : mbUseable( bUseInputMethodDefault ),
+											  mbMultiLingual( False ),
+                                              maMethod( (XIM)NULL ),
+								  			  mpStyles( (XIMStyles*)NULL )
 {
 	const char *pUseInputMethod = getenv( "SAL_USEINPUTMETHOD" );
 	if ( pUseInputMethod != NULL )
@@ -409,7 +411,7 @@ SalI18N_InputMethod::CreateMethod ( Disp
 			mbMultiLingual = True; // set ml-input flag to create input-method
 	    	maMethod = XvaOpenIM(pDisplay, NULL, NULL, NULL,
 					XNMultiLingualInput, mbMultiLingual, /* dummy */
-			 		0);
+			 		(void *)0);
 			// get ml-input flag from input-method
 			if ( maMethod == (XIM)NULL )
 				mbMultiLingual = False;
@@ -505,15 +507,11 @@ SalI18N_InputMethod::FilterEvent( XEvent
 
     Bool bFilterEvent = XFilterEvent (pEvent, window);
 
-    if (! IMServerKinput2())
-        return bFilterEvent;
     if (pEvent->type != XLIB_KeyPress && pEvent->type != KeyRelease)
         return bFilterEvent;
-    if (mbMultiLingual)
-        return bFilterEvent;
 
     /*
-     * fix kinput2 key release handling
+     * fix broken key release handling of some IMs
      */
     XKeyEvent*         pKeyEvent = &(pEvent->xkey);
     static XKeyEventOp maLastKeyPress;
Index: vcl/unx/source/app/i18n_status.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/i18n_status.cxx,v
retrieving revision 1.22
retrieving revision 1.25
diff -u -p -u -r1.22 -r1.25
--- vcl/unx/source/app/i18n_status.cxx	30 Jun 2003 14:31:34 -0000	1.22
+++ vcl/unx/source/app/i18n_status.cxx	10 May 2004 15:55:48 -0000	1.25
@@ -84,8 +84,9 @@
 #include <svdata.hxx>
 #include <svapp.hxx>
 #include <saldisp.hxx>
-#include <salframe.hxx>
+#include <salframe.h>
 #include <saldata.hxx>
+#include <sysdata.hxx>
 
 using namespace vcl;
 using namespace rtl;
@@ -101,7 +102,7 @@ public:
 
     virtual void setPosition( SalFrame* );
     virtual void setText( const String & ) = 0;
-    virtual const String& getText() const = 0;
+    virtual String getText() const = 0;
     virtual void show( bool bShow, I18NStatus::ShowReason eReason ) = 0;
     virtual void toggle( bool bOn );
 };
@@ -152,7 +153,7 @@ public:
 
     virtual void setPosition( SalFrame* );
     virtual void setText( const String & );
-    virtual const String& getText() const;
+    virtual String getText() const;
     virtual void show( bool bShow, I18NStatus::ShowReason eReason );
 
     // overload WorkWindow::DataChanged
@@ -164,8 +165,8 @@ public:
 XIMStatusWindow::XIMStatusWindow() :
         StatusWindow( WB_BORDER | WB_SYSTEMFLOATWIN | WB_TOOLTIPWIN ),
         m_aStatusText( this, 0 ),
-        m_bAnchoredAtRight( false ),
         m_pLastParent( NULL ),
+        m_bAnchoredAtRight( false ),
         m_bDelayedShow( false ),
         m_eDelayedReason( I18NStatus::contextmap ),
         m_nDelayedEvent( 0 )
@@ -196,15 +197,13 @@ void XIMStatusWindow::layout()
 
     if (m_bAnchoredAtRight && IsVisible())
     {
-        SalFrameData & rData
-            = static_cast< SalFrame * >(
-                GetSystemData()->pSalFrame)->maFrameData;
-        Rectangle aOldRect;
-        rData.getPosSize(aOldRect);
-        long nDelta = aOldRect.GetWidth() - m_aWindowSize.Width();
-        rData.setPosSize(Rectangle(Point(aOldRect.Left() + nDelta,
-                                         aOldRect.Top()),
-                                   m_aWindowSize));
+        SalFrame* pFrame = (SalFrame*)GetSystemData()->pSalFrame;
+        long nDelta = pFrame->maGeometry.nWidth - m_aWindowSize.Width();
+        pFrame->SetPosSize( pFrame->maGeometry.nX + nDelta,
+                            pFrame->maGeometry.nY,
+                            m_aWindowSize.Width(),
+                            m_aWindowSize.Height(),
+                            SAL_FRAME_POSSIZE_X | SAL_FRAME_POSSIZE_Y | SAL_FRAME_POSSIZE_WIDTH | SAL_FRAME_POSSIZE_HEIGHT );
     }
     else
         SetOutputSizePixel( m_aWindowSize );
@@ -214,12 +213,11 @@ bool XIMStatusWindow::checkLastParent() 
 {
     if( m_pLastParent )
     {
-        SalFrame* pFrame = GetSalData()->pFirstFrame_;
-        while( pFrame )
+        const std::list< SalFrame* >& rFrames = GetSalData()->GetDisplay()->getFrames();
+        for( std::list< SalFrame* >::const_iterator it = rFrames.begin(); it != rFrames.end(); ++it )
         {
-            if( pFrame == m_pLastParent )
+            if( *it == m_pLastParent )
                 return true;
-            pFrame = pFrame->maFrameData.GetNextFrame();
         }
     }
     return false;
@@ -236,17 +234,15 @@ Point XIMStatusWindow::updatePosition()
     Point aRet;
     if( checkLastParent() )
     {
-        const SystemEnvData* pEnvData = GetSystemData();
         const SystemEnvData* pParentEnvData = m_pLastParent->GetSystemData();
-        SalFrame* pStatusFrame = (SalFrame*)pEnvData->pSalFrame;
-
+        
         SalExtTextInputPosEvent aPosEvent;
-        m_pLastParent->maFrameData.Call(SALEVENT_EXTTEXTINPUTPOS, (void*)&aPosEvent);
+        m_pLastParent->CallCallback( SALEVENT_EXTTEXTINPUTPOS, (void*)&aPosEvent );
         int x, y;
         XLIB_Window aChild;
         XTranslateCoordinates( (Display*)pParentEnvData->pDisplay,
                                (XLIB_Window)pParentEnvData->aShellWindow,
-                               m_pLastParent->maFrameData.GetDisplay()->GetRootWindow(),
+                               GetSalData()->GetDisplay()->GetRootWindow(),
                                0, 0,
                                &x, &y,
                                &aChild );
@@ -295,7 +291,8 @@ void XIMStatusWindow::setPosition( SalFr
         {
             const SystemEnvData* pEnvData = GetSystemData();
             SalFrame* pStatusFrame = (SalFrame*)pEnvData->pSalFrame;
-            pStatusFrame->maFrameData.setPosSize( Rectangle( updatePosition(), m_aWindowSize ) );
+            Point aPoint = updatePosition();
+            pStatusFrame->SetPosSize( aPoint.X(), aPoint.Y(), m_aWindowSize.Width(), m_aWindowSize.Height(), SAL_FRAME_POSSIZE_X | SAL_FRAME_POSSIZE_Y | SAL_FRAME_POSSIZE_WIDTH | SAL_FRAME_POSSIZE_HEIGHT );
         }
     }
 }
@@ -309,7 +306,8 @@ IMPL_LINK( XIMStatusWindow, DelayedShowH
     {
         Size aControlSize( m_aWindowSize.Width()-4, m_aWindowSize.Height()-4 );
         m_aStatusText.SetPosSizePixel( Point( 1, 1 ), aControlSize );
-        pStatusFrame->maFrameData.setPosSize( Rectangle( updatePosition(), m_aWindowSize ) );
+        Point aPoint = updatePosition();
+        pStatusFrame->SetPosSize( aPoint.X(), aPoint.Y(), m_aWindowSize.Width(), m_aWindowSize.Height(), SAL_FRAME_POSSIZE_X | SAL_FRAME_POSSIZE_Y | SAL_FRAME_POSSIZE_WIDTH | SAL_FRAME_POSSIZE_HEIGHT );
     }
     Show( m_bDelayedShow, SHOW_NOACTIVATE );
     if( m_bDelayedShow )
@@ -337,7 +335,7 @@ void XIMStatusWindow::setText( const Str
     m_aWindowSize.Width() = m_aStatusText.GetTextWidth( rText )+8;
 }
 
-const String& XIMStatusWindow::getText() const
+String XIMStatusWindow::getText() const
 {
     return m_aStatusText.GetText();
 }
@@ -363,7 +361,7 @@ public:
     virtual ~IIIMPStatusWindow();
 
     virtual void setText( const String & );
-    virtual const String& getText() const;
+    virtual String getText() const;
     virtual void show( bool bShow, I18NStatus::ShowReason eReason );
     virtual void toggle( bool bOn );
     void layout();
@@ -399,7 +397,6 @@ IIIMPStatusWindow::IIIMPStatusWindow( Sa
     if( pParent )
     {
         const SystemEnvData* pEnvData = GetSystemData();
-        const SystemEnvData* pParentEnvData = pParent->GetSystemData();
 
         const SalFrameGeometry& rGeom( pParent->GetUnmirroredGeometry() );
         int nDistance = rGeom.nTopDecoration;
@@ -445,7 +442,7 @@ void IIIMPStatusWindow::setText( const S
     m_aStatusBtn.SetText( rText );
 }
 
-const String& IIIMPStatusWindow::getText() const
+String IIIMPStatusWindow::getText() const
 {
     return m_aStatusBtn.GetText();
 }
@@ -492,21 +489,23 @@ void IIIMPStatusWindow::GetFocus()
          *  since reset focus really is an internal hack there should
          *  not be a method to be called in SalFrame destructor
          */
-        SalFrame* pFrame = GetSalData()->pFirstFrame_;
-        while( pFrame && pFrame != m_pResetFocus )
-            pFrame = pFrame->maFrameData.GetNextFrame();
-        if( pFrame == m_pResetFocus )
+        const std::list< SalFrame* >& rFrames = GetSalData()->GetDisplay()->getFrames();
+        std::list< SalFrame* >::const_iterator it;
+        for( it = rFrames.begin(); it != rFrames.end() && *it != m_pResetFocus; ++it )
+            ;
+        if( it != rFrames.end() )
         {
             const SystemEnvData* pParentEnvData = m_pResetFocus->GetSystemData();
-            BOOL bIgnore = m_pResetFocus->maFrameData.GetDisplay()->GetXLib()->GetIgnoreXErrors();
-            m_pResetFocus->maFrameData.GetDisplay()->GetXLib()->SetIgnoreXErrors( TRUE );
+            SalXLib* pXLib = GetSalData()->GetDisplay()->GetXLib();
+            BOOL bIgnore = pXLib->GetIgnoreXErrors();
+            pXLib->SetIgnoreXErrors( TRUE );
             XSetInputFocus( (Display*)pParentEnvData->pDisplay,
                             (XLIB_Window)pParentEnvData->aShellWindow,
                             RevertToNone,
                             CurrentTime
                             );
             XSync( (Display*)pParentEnvData->pDisplay, False );
-            m_pResetFocus->maFrameData.GetDisplay()->GetXLib()->SetIgnoreXErrors( bIgnore );
+            pXLib->SetIgnoreXErrors( bIgnore );
         }
         m_pResetFocus = NULL;
     }
@@ -527,18 +526,21 @@ IMPL_LINK( IIIMPStatusWindow, SelectHdl,
                           XNUnicodeCharacterSubset,
                           rChoices[nIndex].pData,
                           0);
-            SalFrame* pParent = I18NStatus::get().getParent();
-            if( pParent && pParent->maFrameData.isMapped() )
+            // FIXME: get rid of X11SalFrame
+            X11SalFrame* pParent = static_cast<X11SalFrame*>(I18NStatus::get().getParent());
+            if( pParent && pParent->isMapped() )
             {
-                BOOL bIgnore = pParent->maFrameData.GetDisplay()->GetXLib()->GetIgnoreXErrors();
-                pParent->maFrameData.GetDisplay()->GetXLib()->SetIgnoreXErrors( TRUE );
-                XSetInputFocus( pParent->maFrameData.GetXDisplay(),
-                                pParent->maFrameData.GetShellWindow(),
+                const SystemEnvData* pEnv = pParent->GetSystemData();
+                SalXLib* pXLib = GetSalData()->GetDisplay()->GetXLib();
+                BOOL bIgnore = pXLib->GetIgnoreXErrors();
+                pXLib->SetIgnoreXErrors( TRUE );
+                XSetInputFocus( (Display*)pEnv->pDisplay,
+                                (XLIB_Window)pEnv->aShellWindow,
                                 RevertToNone,
                                 CurrentTime
                                 );
-                XSync( pParent->maFrameData.GetXDisplay(), False );
-                pParent->maFrameData.GetDisplay()->GetXLib()->SetIgnoreXErrors( bIgnore );
+                XSync( (Display*)pEnv->pDisplay, False );
+                pXLib->SetIgnoreXErrors( bIgnore );
             }
         }
     }
@@ -671,10 +673,9 @@ void I18NStatus::changeIM( const String&
 
 // --------------------------------------------------------------------------
 
-const String& I18NStatus::getStatusText() const
+String I18NStatus::getStatusText() const
 {
-    static String aEmpty;
-    return m_pStatusWindow ? m_pStatusWindow->getText() :  aEmpty;
+    return m_pStatusWindow ? m_pStatusWindow->getText() :  String();
 }
 
 // --------------------------------------------------------------------------
@@ -741,4 +742,26 @@ bool I18NStatus::getStatusWindowMode()
     case ImplSVAppData::ImeStatusWindowMode_SHOW:
         return true;
     }
+}
+
+/*
+ * X11ImeStatus
+ */
+X11ImeStatus::~X11ImeStatus()
+{
+}
+
+bool X11ImeStatus::canToggle()
+{
+    return vcl::I18NStatus::get().canToggleStatusWindow();
+}
+
+void X11ImeStatus::toggle()
+{
+    vcl::I18NStatus::get().toggleStatusWindow();
+}
+
+SalI18NImeStatus* X11SalInstance::CreateI18NImeStatus()
+{
+    return new X11ImeStatus();
 }
Index: vcl/unx/source/app/i18n_wrp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/i18n_wrp.cxx,v
retrieving revision 1.6
retrieving revision 1.7
diff -u -p -u -r1.6 -r1.7
--- vcl/unx/source/app/i18n_wrp.cxx	27 Aug 2002 13:19:00 -0000	1.6
+++ vcl/unx/source/app/i18n_wrp.cxx	6 Jan 2004 14:28:49 -0000	1.7
@@ -280,14 +280,9 @@ XvaOpenIM(Display *display, XrmDatabase 
  * Close the connection to the input manager, and free the XIM structure
  */
 
-Status
-XvaCloseIM(XIM im)
+Status XvaCloseIM(XIM im)
 {
   	Status s;
-	#if 0
-  	XCloseIM(im);
-  	s = (im->methods->close)(im); /* we can use the same close module  */
-	#endif
 
 	/* MacOS X doesn't yet support XIM... FIXME */
 #if !defined(MACOSX)  
@@ -299,12 +294,6 @@ XvaCloseIM(XIM im)
     	g_open_im = (OpenFunction)NULL;
   	}
 #endif
-
-	#if 0
-  	if (im) 
-		Xfree((char *)im);
-	#endif
-
 	return (s);
 }
 
Index: vcl/unx/source/app/keysymnames.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/keysymnames.cxx,v
retrieving revision 1.7.120.2
retrieving revision 1.10
diff -u -p -u -r1.7.120.2 -r1.10
--- vcl/unx/source/app/keysymnames.cxx	9 Jan 2004 18:13:59 -0000	1.7.120.2
+++ vcl/unx/source/app/keysymnames.cxx	6 Jan 2004 14:29:18 -0000	1.10
@@ -91,9 +91,6 @@
 #include <deflt.h>
 #include <unistd.h>
 #include <stdlib.h>
-#ifndef KB_USB // compile with too old headers
-#define KB_USB 6
-#endif
 #endif
 
 #include <string.h>
Index: vcl/unx/source/app/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/makefile.mk,v
retrieving revision 1.9.250.1
retrieving revision 1.13
diff -u -p -u -r1.9.250.1 -r1.13
--- vcl/unx/source/app/makefile.mk	15 Aug 2003 11:25:34 -0000	1.9.250.1
+++ vcl/unx/source/app/makefile.mk	10 May 2004 15:56:00 -0000	1.13
@@ -81,10 +81,6 @@ dummy:
 
 .ELSE		# "$(GUIBASE)"!="unx"
 
-.IF "$(remote)"==""
-OBJFILES=\
-			$(OBJ)$/salmain.obj
-
 SLOFILES=\
 			$(SLO)$/i18n_cb.obj			\
 			$(SLO)$/i18n_ic.obj			\
@@ -93,7 +89,6 @@ SLOFILES=\
 			$(SLO)$/i18n_wrp.obj		\
 			$(SLO)$/i18n_status.obj		\
 			$(SLO)$/i18n_keysym.obj		\
-			$(SLO)$/salmain.obj			\
 			$(SLO)$/saldata.obj			\
 			$(SLO)$/saltimer.obj		\
 			$(SLO)$/saldisp.obj			\
@@ -107,31 +102,24 @@ SLOFILES=\
 			$(SLO)$/salsys.obj			\
 			$(SLO)$/soicon.obj			\
 			$(SLO)$/sm.obj				\
-			$(SLO)$/stacktrace.obj		\
 			$(SLO)$/keysymnames.obj		\
-			$(SLO)$/wmadaptor.obj
+			$(SLO)$/wmadaptor.obj		\
 
 .IF "$(WITH_LIBSN)"=="YES"
 CDEFS+=-DHAVE_LIBSN
 CFLAGS+=$(LIBSN_CFLAGS)
 .ENDIF
 
+.IF "$(WITH_WIDGETSET)"!=""
+CFLAGS+= $(WIDGETSET_CFLAGS)
+.ENDIF
+
 .IF "$(OS)$(CPU)" == "SOLARISS"
 .IF "$(COM)"!="GCC"
 SLOFILES+=$(SLO)$/getfpsols.obj
 .ENDIF			# "$(COM)"!="GCC"
 .ELIF "$(OS)$(CPU)" == "SOLARISI"
 SLOFILES+=$(SLO)$/getfpsoli.obj
-.ENDIF
-
-.ELSE
-SLOFILES=\
-			$(SLO)$/salmain.obj
-.ENDIF
-
-.IF "$(remote)"!=""
-EXCEPTIONSFILES=$(SLO)$/salmain.obj	\
-		$(OBJ)$/salmain.obj
 .ENDIF
 
 .ENDIF		# "$(GUIBASE)"!="unx"
Index: vcl/unx/source/app/nassound.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/nassound.cxx,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -p -u -r1.3 -r1.6
--- vcl/unx/source/app/nassound.cxx	4 Jun 2003 11:23:18 -0000	1.3
+++ vcl/unx/source/app/nassound.cxx	10 May 2004 15:56:12 -0000	1.6
@@ -59,7 +59,7 @@
  *
  ************************************************************************/
 #include <salimpsound.hxx>
-#include <salsound.hxx>
+#include <salsound.h>
 
 #ifdef USE_NAS
 
@@ -139,7 +139,7 @@ BOOL NASSound::connect()
 											(YieldFunc)handleEvents );
 			SalDbgAssert( "AudioConnectionNumber is %d, DisplayConnectionNumber is %d\n",
 						  AuServerConnectionNumber( (AuServer*)s_pServer ),
-						  ConnectionNumber( GetSalData()->GetDefDisp()->GetDisplay() ) );
+						  ConnectionNumber( GetSalData()->GetDisplay()->GetDisplay() ) );
 		}
 	}
 	return s_pServer ? TRUE : FALSE;
@@ -179,7 +179,7 @@ int NASSound::handleEvents( int fd, void
 	return 1;
 }
 
-NASSound::NASSound( ::SalSound* pSalSound ) :
+NASSound::NASSound( ::X11SalSound* pSalSound ) :
 		VSound( pSalSound ),
 		m_nFlowID( 0 )
 {
@@ -224,7 +224,10 @@ void NASSound::play()
  			aState.element_num = 0;
  			for( int n = 0; n < 20 && ! bStarted; n++ )
  			{
- 				usleep( 20000 );
+                TimeValue aVal;
+                aVal.Seconds = 0;
+                aVal.Nanosec = 20000000;
+                osl_waitThread( &aVal );
  				AuHandleEvents( (AuServer*)s_pServer );
 
  				int nStates = 1;
Index: vcl/unx/source/app/osssound.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/osssound.cxx,v
retrieving revision 1.4
retrieving revision 1.6
diff -u -p -u -r1.4 -r1.6
--- vcl/unx/source/app/osssound.cxx	4 Jun 2003 11:23:28 -0000	1.4
+++ vcl/unx/source/app/osssound.cxx	17 Mar 2004 10:06:24 -0000	1.6
@@ -58,7 +58,7 @@
  *
  *
  ************************************************************************/
-#include <salsound.hxx>
+#include <salsound.h>
 #include <salimpsound.hxx>
 
 #include <svapp.hxx>
@@ -270,7 +270,7 @@ BOOL OSSSound::startRIFF( OSSData* pData
 	return TRUE;
 }
 
-int OSSSound::findChunk( OSSData* pData, char* pChunk )
+int OSSSound::findChunk( OSSData* pData, const char* pChunk )
 {
 	if( !pData || ! pData->m_pSound || ! pData->m_pSound->m_pBuffer )
 		return -1;
@@ -287,18 +287,18 @@ int OSSSound::findChunk( OSSData* pData,
 	return -1;
 }
 
-short int OSSSound::readLEShort( char* pBuf )
+short int OSSSound::readLEShort( const char* pBuf )
 {
-	unsigned char* pBuffer = (unsigned char*)pBuf;
+	const unsigned char* pBuffer = (const unsigned char*)pBuf;
 	short int nRet = *pBuffer++;
 	nRet |= *pBuffer << 8;
 
 	return nRet;
 }
 
-ULONG OSSSound::readBELong( char* pBuf )
+ULONG OSSSound::readBELong( const char* pBuf )
 {
-	unsigned char* pBuffer = (unsigned char*)pBuf;
+	const unsigned char* pBuffer = (const unsigned char*)pBuf;
 	ULONG nRet	 = *pBuffer++ << 24;
 	nRet		|= *pBuffer++ << 16;
 	nRet		|= *pBuffer++ << 8;
@@ -307,9 +307,9 @@ ULONG OSSSound::readBELong( char* pBuf )
 	return nRet;
 }
 
-int OSSSound::readLEInt( char* pBuf )
+int OSSSound::readLEInt( const char* pBuf )
 {
-	unsigned char* pBuffer = (unsigned char*)pBuf;
+	const unsigned char* pBuffer = (const unsigned char*)pBuf;
 	int nRet = *pBuffer++;
 	nRet |= (int)(*pBuffer++) << 8;
 	nRet |= (int)(*pBuffer++) << 16;
@@ -360,7 +360,10 @@ void OSSSound::run()
                             pData->m_nCurPos += nBytes;
                     }
                     aGuard.clear();
-                    usleep(50000);
+                    TimeValue aVal;
+                    aVal.Seconds = 0;
+                    aVal.Nanosec = 20000000;
+                    osl_waitThread( &aVal );
                     aGuard.reset();
                     if( s_aDataList.GetObject( 0 ) != pData )
                     {
@@ -422,7 +425,7 @@ void OSSSound::remove( OSSSound* pSound 
 	}
 }
 
-OSSSound::OSSSound( ::SalSound* pSound ) :
+OSSSound::OSSSound( ::X11SalSound* pSound ) :
 		VSound( pSound )
 {
 	initBuffer();
Index: vcl/unx/source/app/rptpsound.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/rptpsound.cxx,v
retrieving revision 1.6.74.1
retrieving revision 1.13
diff -u -p -u -r1.6.74.1 -r1.13
--- vcl/unx/source/app/rptpsound.cxx	28 Jan 2004 15:23:50 -0000	1.6.74.1
+++ vcl/unx/source/app/rptpsound.cxx	10 May 2004 15:56:24 -0000	1.13
@@ -64,7 +64,7 @@
 #include <sys/poll.h>
 #endif
 
-#include <salsound.hxx>
+#include <salsound.h>
 #include <salimpsound.hxx>
 
 #include <salunx.h>
@@ -72,21 +72,11 @@
 #include <saldisp.hxx>
 #include <psprint/strhelper.hxx>
 #include <string.h>
-
-#ifdef SOLARIS
-// Solaris 2.5.1 misses it in unistd.h
-extern "C" int usleep(unsigned int);
-#endif
-
-#if defined(FREEBSD) || defined(NETBSD)
 #include <unistd.h>
-#endif
 
-#ifdef _USE_NAMESPACE
 using namespace vcl_sal;
 using namespace vos;
 using namespace psp;
-#endif
 
 BOOL						RPTPSound::s_bConnected			= FALSE;
 BOOL						RPTPSound::s_bFailedOnce		= FALSE;
@@ -112,17 +102,17 @@ BOOL RPTPSound::connect()
 	static const char* portenv = env ? strchr( env, ':' ) : NULL;
 	static char sBuf[1024];
 
-	if( ! env && GetSalData() && GetSalData()->GetDefDisp() &&
-		DisplayString( GetSalData()->GetDefDisp()->GetDisplay() ) )
+	if( ! env && GetSalData() && GetSalData()->GetDisplay() &&
+		DisplayString( GetSalData()->GetDisplay()->GetDisplay() ) )
 	{
-		env = strdup( DisplayString( GetSalData()->GetDefDisp()->GetDisplay() ) );
+		env = strdup( DisplayString( GetSalData()->GetDisplay()->GetDisplay() ) );
 		portenv = strchr( env, ':' );
 	}
 
 	int nPort = portenv ? atoi( portenv+1 ) : 5556;
 	nPort = nPort ? nPort : 5556;
 
-	strcpy( sBuf, "uninitialized" );
+	strncpy( sBuf, "uninitialized", 14 );
 	if( env && portenv )
 	{
 		if( portenv != env )
@@ -131,10 +121,10 @@ BOOL RPTPSound::connect()
 			sBuf[ portenv - env ] = 0;
 		}
 		else
-			strcpy( sBuf, "localhost" );
+			strncpy( sBuf, "localhost", 10 );
 	}
 	else
-		strcpy( sBuf, "localhost" );
+		strncpy( sBuf, "localhost", 10 );
 
 	SalDbgAssert( "resolving \"%s\", env = \"%s\", portenv = \"%s\"\n",
 				  sBuf,
@@ -259,7 +249,10 @@ ByteString RPTPSound::readLine()
 					goto doreturn;
 				}
 			}
-			usleep( 1000 );
+            TimeValue aVal;
+            aVal.Seconds = 0;
+            aVal.Nanosec = 1000000;
+            osl_waitThread( &aVal );
 		}
 	}
   doreturn:
@@ -303,7 +296,7 @@ ULONG RPTPSound::getMaxId()
 	return nID;
 }
 
-RPTPSound::RPTPSound( SalSound* pSalSound ) :
+RPTPSound::RPTPSound( X11SalSound* pSalSound ) :
 		VSound( pSalSound ),
 		m_nID( 0 )
 {
@@ -350,7 +343,7 @@ void RPTPSound::play()
 		aCommand += " sound=";
 		aCommand += m_pSalSound->m_aSoundFile;
 		aCommand += " size=";
-		aCommand += (ULONG)m_aStat.st_size;
+		aCommand += ByteString::CreateFromInt64((ULONG)m_aStat.st_size);
 		
 		aAnswer = sendCommand( aCommand );
 		
@@ -383,7 +376,7 @@ void RPTPSound::stop()
 	if( m_nID )
 	{
 		ByteString aCommand( "stop id=#" );
-		aCommand += m_nID;
+		aCommand += ByteString::CreateFromInt64(m_nID);
 		aAnswer = sendCommand( aCommand );
 	}
 	if( aAnswer.GetChar( 0 ) != '+' && m_pSalSound)
@@ -395,7 +388,7 @@ void RPTPSound::pause()
 	if( m_nID )
 	{
 		ByteString aCommand( "pause id=#" );
-		aCommand += m_nID;
+		aCommand += ByteString::CreateFromInt64(m_nID);
 		sendCommand( aCommand );
 	}
 }
@@ -405,7 +398,7 @@ void RPTPSound::cont()
 	if( m_nID )
 	{
 		ByteString aCommand( "continue id=#" );
-		aCommand += m_nID;
+		aCommand += ByteString::CreateFromInt64(m_nID);
 		sendCommand( aCommand );
 	}
 }
Index: vcl/unx/source/app/saldata.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/saldata.cxx,v
retrieving revision 1.26.10.2
retrieving revision 1.36
diff -u -p -u -r1.26.10.2 -r1.36
--- vcl/unx/source/app/saldata.cxx	26 Aug 2003 14:15:59 -0000	1.26.10.2
+++ vcl/unx/source/app/saldata.cxx	17 Jun 2004 12:27:36 -0000	1.36
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALDATA_CXX
-
 #ifdef USE_XTOOLKIT
 #  define SAL_XT
 #endif
@@ -70,9 +68,9 @@
 #include <unistd.h>
 #include <fcntl.h>
 
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
+#include <cstdio>
+#include <cstring>
+#include <cstdlib>
 #include <limits.h>
 #include <errno.h>
 #include <pthread.h>
@@ -101,18 +99,15 @@
 // [ed] 6/15/02 There's a conflicting definition of INT8 within the Xmd.h header
 // and the solar.h OOo header.  So, wrap the X11 header with a bogus #define
 // to use the OOo definition of the symbol for INT8.
+// [fa] 4/12/04 With 64-bit changes, X11 headers also conflict with INT64
 
-#ifdef MACOSX
-#define INT8 blehBlahFooBar
-#endif
+#define INT8 blehBlahFooBarINT8
+#define INT64 blehBlahFooBarINT64
 
 #include <X11/Xproto.h>
 
-// [ed] 6/15/02 Get rid of INT8 hack
-
-#ifdef MACOSX
 #undef INT8
-#endif
+#undef INT64
 
 #include <postx.h>
 
@@ -125,8 +120,8 @@
 #ifndef _SV_SALINST_HXX
 #include <salinst.hxx>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
 #ifndef _OSL_SIGNAL_H_
 #include <osl/signal.h>
@@ -140,6 +135,7 @@
 
 #include <tools/debug.hxx>
 #include <sm.hxx>
+#include <svapp.hxx>
 
 #ifndef _SAL_I18N_INPUTMETHOD_HXX
 #include "i18n_im.hxx"
@@ -297,23 +293,20 @@ static const char* XRequest[] = {
 	"X_NoOperation"
 };
 
-BEGIN_C
 // -=-= C statics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
+BEGIN_C
 
 static oslSignalAction SalSignalHdl (void* pData, oslSignalInfo* pInfo)
 {
-	ULONG nException = 0;
-
 	switch (pInfo->Signal)
 	{
 		case osl_Signal_System :
 			return osl_Signal_ActCallNextHdl;
 		case osl_Signal_Terminate :
-			if (!GetSalData()->Close())
-				return osl_Signal_ActIgnore;
-			break;
+			Application::Quit();
+            return osl_Signal_ActIgnore;
 		case osl_Signal_User :
 			return osl_Signal_ActCallNextHdl;
 		default: break;
@@ -322,14 +315,15 @@ static oslSignalAction SalSignalHdl (voi
 	return osl_Signal_ActAbortApp;
 }
 
+END_C
 
-static int sal_XErrorHdl( Display *pDisplay, XErrorEvent *pEvent )
+int SalData::XErrorHdl( Display *pDisplay, XErrorEvent *pEvent )
 {
 	GetSalData()->XError( pDisplay, pEvent );
 	return 0;
 }
 
-static int sal_XIOErrorHdl( Display *pDisplay )
+int SalData::XIOErrorHdl( Display *pDisplay )
 {
     /*  #106197# hack: until a real shutdown procedure exists
      *  _exit ASAP
@@ -339,7 +333,7 @@ static int sal_XIOErrorHdl( Display *pDi
 
     // really bad hack
     if( ! SessionManagerClient::checkDocumentsSaved() )
-        oslSignalAction eToDo = osl_raiseSignal (OSL_SIGNAL_USER_X11SUBSYSTEMERROR, NULL);
+        /* oslSignalAction eToDo = */ osl_raiseSignal (OSL_SIGNAL_USER_X11SUBSYSTEMERROR, NULL);
 
 	fprintf( stderr, "X IO Error\n" );
 	fflush( stdout );
@@ -353,100 +347,46 @@ static int sal_XIOErrorHdl( Display *pDi
 	return 0;
 }
 
-END_C
-
 // -=-= SalData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #include <pthread.h>
 
 SalData::SalData()
 {
-	argv_			= 0;
-	argc_			= 0;
-
-	pTimerProc_ 	= 0;
-
-	memset( sig_, 0, sizeof( sig_ ) ); // SIG_DFL
 	bNoExceptions_	= !!getenv( "SAL_NOSEGV" );
 
-	pXLib_			= new SalXLib();
-	pDefDisp_		= 0;
-	pCurDisp_		= 0;
+	pXLib_			= NULL;
+    m_pSalDisplay	= NULL;
+	pInstance_		= NULL;
 
 	hMainThread_	= pthread_self();
-
-	pFirstInstance_ = NULL;
-	pFirstFrame_	= NULL;
 }
 
 SalData::~SalData()
 {
-    while( SalDisplays_.Count() )
-        delete SalDisplays_.Remove( (ULONG)0 );
-
-	delete pXLib_;
-    pDefDisp_ = NULL;
-    pCurDisp_ = NULL;
-}
-
-long SalData::Close() const
-{
-	signal( SIGTERM, sig_[SIGTERM] );
-	if( !pFirstFrame_ )
-		return 1;
-
-	SalFrame *pFrame = pFirstFrame_;
-	while( pFrame )
-	{
-		if( !pFrame->maFrameData.Close() )
-			return 0;
-		pFrame = pFrame->maFrameData.GetNextFrame();
-	}
-	return 1;
+    DeleteDisplay();
 }
 
-long SalData::ShutDown() const
+void SalData::DeleteDisplay()
 {
-	if( !pFirstFrame_ )
-		return 1;
-
-	SalFrame *pFrame = pFirstFrame_;
-	while( pFrame )
-	{
-		if( !pFrame->maFrameData.ShutDown() )
-			return 0;
-		pFrame = pFrame->maFrameData.GetNextFrame();
-	}
-	return 1;
+    delete m_pSalDisplay;
+    m_pSalDisplay	= NULL;
+	delete pXLib_;
+    pXLib_		= NULL;
 }
 
-XubString SalData::GetCommandLineParam( USHORT nParam ) const
+void SalData::Init()
 {
-	if( !nParam ) { return aBinaryPath_; }
-	if( nParam >= argc_ ) return String();
-	return String( argv_[nParam], osl_getThreadTextEncoding() );
+    pXLib_ = new SalXLib();
+    pXLib_->Init();
 }
 
-SalDisplay *SalData::GetDisplay( Display *pDisplay )
+void SalData::initNWF( void )
 {
-	SalDisplay *pSalDisplay = SalDisplays_.First();
-	while( pSalDisplay && pSalDisplay->GetDisplay() != pDisplay )
-		pSalDisplay = SalDisplays_.Next();
-	return pSalDisplay;
 }
 
-void SalData::Init( int *pArgc, char *ppArgv[] )
+void SalData::deInitNWF( void )
 {
-	// Pfad zum Executable bestimmen
-	char aFilePath[ PATH_MAX ];
-	::rtl::OUString aPath;
-	osl_getExecutableFile( &aPath.pData );
-
-	aBinaryPath_ = aPath;
-
-	argc_			= *pArgc;
-	argv_			= ppArgv;
-	pXLib_->Init( pArgc, ppArgv );
 }
 
 // -=-= SalXLib =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
@@ -496,10 +436,10 @@ SalXLib::SalXLib()
 		nFDs_ = pTimeoutFDS_[0] + 1;
 	}
 
-	bWasXError_ 			= FALSE;
-	bIgnoreXErrors_ 		= !!getenv( "SAL_IGNOREXERRORS" );
+	bWasXError_						= FALSE;
+	bIgnoreXErrors_					= !!getenv( "SAL_IGNOREXERRORS" );
+    m_bHaveSystemChildFrames		= false;
 	nIgnoreErrorLevel               = 0;
-	nStateOfYield_			= 0;
 }
 
 SalXLib::~SalXLib()
@@ -507,17 +447,11 @@ SalXLib::~SalXLib()
 	// close 'wakeup' pipe.
 	close (pTimeoutFDS_[0]);
 	close (pTimeoutFDS_[1]);
-
-// completetly disabled Bug Nr. #47319 -> segv while using xsuntransport=shmem
-// #ifdef SAL_XT
-//	XtDestroyApplicationContext( pApplicationContext_ );
-// #endif
 }
 
 
-void SalXLib::Init( int *pArgc, char *ppArgv[] )
+void SalXLib::Init()
 {
-	SalData *pSalData = GetSalData();
 	SalI18N_InputMethod* pInputMethod = new SalI18N_InputMethod;
 	pInputMethod->SetLocale();
 	XrmInitialize();
@@ -527,7 +461,7 @@ void SalXLib::Init( int *pArgc, char *pp
 	 * try in this order:
 	 *  o  -display command line parameter,
 	 *  o  $DISPLAY environment variable
-	 *  o  defualt display
+	 *  o  default display
 	 */
 	
 	Display *pDisp = NULL;
@@ -545,6 +479,7 @@ void SalXLib::Init( int *pArgc, char *pp
 			aCommandLine.getCommandArg(i+1, aParam);
 			aDisplay = rtl::OUStringToOString(
 				   aParam, osl_getThreadTextEncoding());
+
 			if ((pDisp = XOpenDisplay(aDisplay.getStr()))!=NULL)
 			{
 				/*
@@ -555,7 +490,7 @@ void SalXLib::Init( int *pArgc, char *pp
 			 	*/
 				const char envpre[] = "DISPLAY=";
 				char *envstr = new char[sizeof(envpre)+aDisplay.getLength()];
-				sprintf(envstr, "DISPLAY=%s", aDisplay.getStr());
+				snprintf(envstr, sizeof(envpre)+aDisplay.getLength(), "DISPLAY=%s", aDisplay.getStr());
 				putenv(envstr);
 			}
 			break;
@@ -573,7 +508,8 @@ void SalXLib::Init( int *pArgc, char *pp
 
 	if ( !pDisp )
 	{
-	    rtl::OUString aProgramFileURL = pSalData->GetCommandLineParam(0);
+	    rtl::OUString aProgramFileURL;
+        osl_getExecutableFile( &aProgramFileURL.pData );
 	    rtl::OUString aProgramSystemPath;
         osl_getSystemPathFromFileURL (aProgramFileURL.pData, &aProgramSystemPath.pData);
         rtl::OString  aProgramName = rtl::OUStringToOString(
@@ -600,10 +536,10 @@ void SalXLib::Init( int *pArgc, char *pp
 								   aVI.visual,
 								   AllocNone );
 
-	XSetIOErrorHandler	  ( (XIOErrorHandler)sal_XIOErrorHdl );
-	XSetErrorHandler	  ( (XErrorHandler)sal_XErrorHdl );
+	XSetIOErrorHandler	  ( (XIOErrorHandler)SalData::XIOErrorHdl );
+	XSetErrorHandler	  ( (XErrorHandler)SalData::XErrorHdl );
 
-	SalDisplay *pSalDisplay = new SalDisplay( pDisp, aVI.visual, aColMap );
+	SalDisplay *pSalDisplay = new SalX11Display( pDisp, aVI.visual, aColMap );
 
     pInputMethod->CreateMethod( pDisp );
 	pInputMethod->AddConnectionWatch( pDisp, (void*)this );
@@ -637,29 +573,15 @@ void EmitFontpathWarning( void )
 
 void SalXLib::XError( Display *pDisplay, XErrorEvent *pEvent )
 {
-	char msg[ 120 ] = "";
+    if( m_bHaveSystemChildFrames )
+        return;
 
+	char msg[ 120 ] = "";
 	if( nIgnoreErrorLevel > 0 )
 		return;
 
 	if( ! bIgnoreXErrors_ )
 	{
-		SalFrame* pFrame = GetSalData()->pFirstFrame_;
-		while( pFrame )
-		{
-			if( pFrame->maFrameData.GetStyle() & SAL_FRAME_STYLE_CHILD )
-			{
-				bIgnoreXErrors_ = TRUE;
-				break;
-			}
-			pFrame = pFrame->maFrameData.GetNextFrame();
-		}
-	}
-
-
-
-	if( ! bIgnoreXErrors_ )
-	{
 		if (   (pEvent->error_code   == BadAlloc)
 			&& (pEvent->request_code == X_OpenFont) )
 		{
@@ -682,7 +604,7 @@ void SalXLib::XError( Display *pDisplay,
 #endif
 		fprintf( stderr, "X-Error: %s\n", msg );
 		if( pEvent->request_code > capacityof( XRequest ) )
-			fprintf( stderr, "\tMajor opcode: %d (Shm?)\n", pEvent->request_code );
+			fprintf( stderr, "\tMajor opcode: %d\n", pEvent->request_code );
 		else if( XRequest[pEvent->request_code] )
 			fprintf( stderr, "\tMajor opcode: %d (%s)\n",
 					 pEvent->request_code, XRequest[pEvent->request_code] );
@@ -696,7 +618,7 @@ void SalXLib::XError( Display *pDisplay,
 		fflush( stdout );
 		fflush( stderr );
 #endif
-        if( pDisplay != GetSalData()->GetDefDisp()->GetDisplay() )
+        if( pDisplay != GetSalData()->GetDisplay()->GetDisplay() )
             return;
 
 		oslSignalAction eToDo = osl_raiseSignal (OSL_SIGNAL_USER_X11SUBSYSTEMERROR, NULL);
@@ -811,8 +733,6 @@ void SalXLib::Yield( BOOL bWait )
     if (p_prioritize_timer != NULL)
         CheckTimeout();
 
-	nStateOfYield_ = 0; // is not 0 if we are recursive called
-
 	// first, check for already queued events.
 	for ( int nFD = 0; nFD < nFDs_; nFD++ )
 	{
@@ -864,7 +784,6 @@ void SalXLib::Yield( BOOL bWait )
 		}
 	}
 
-	nStateOfYield_ = 1;
 	{
 		// release YieldMutex (and re-acquire at block end)
 		YieldMutexReleaser aReleaser;
@@ -875,10 +794,8 @@ void SalXLib::Yield( BOOL bWait )
 	if( nFound < 0 ) // error
 	{
 #ifdef DBG_UTIL
-		fprintf( stderr, "SalXLib::Yield s=%d e=%d f=%d\n",
-				 nStateOfYield_, errno, nFound );
+		fprintf( stderr, "SalXLib::Yield e=%d f=%d\n", errno, nFound );
 #endif
-		nStateOfYield_ = 0;
 		if( EINTR == errno )
 		{
 			errno = 0;
@@ -910,10 +827,7 @@ void SalXLib::Yield( BOOL bWait )
 
 		// someone-else has done the job for us
 		if (nFound == 0)
-		{
-			nStateOfYield_ = 0;
 			return;
-		}
 
 		for ( int nFD = 0; nFD < nFDs_; nFD++ )
 		{
@@ -928,25 +842,25 @@ void SalXLib::Yield( BOOL bWait )
 				}
 				if ( FD_ISSET( nFD, &ReadFDS ) )
 				{
-					nStateOfYield_ = 3;
 					if ( pEntry->IsEventQueued() )
 					{
-						nStateOfYield_ = 4;
 						pEntry->HandleNextEvent();
 						// if a recursive call has done the job
 						// so abort here
-						if ( nStateOfYield_ != 4 )
-							break;
 					}
 					nFound--;
 				}
 			}
 		}
 	}
-	nStateOfYield_ = 0;
 }
 
 void SalXLib::Wakeup()
 {
 	write (pTimeoutFDS_[1], "", 1);
+}
+
+void SalXLib::PostUserEvent()
+{
+	Wakeup();
 }
Index: vcl/unx/source/app/saldisp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/saldisp.cxx,v
retrieving revision 1.44.10.2
retrieving revision 1.55
diff -u -p -u -r1.44.10.2 -r1.55
--- vcl/unx/source/app/saldisp.cxx	9 Jan 2004 18:14:00 -0000	1.44.10.2
+++ vcl/unx/source/app/saldisp.cxx	17 Jun 2004 12:27:52 -0000	1.55
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALDISP_CXX
-
 #define SAL_XT
 
 // -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
@@ -82,152 +80,10 @@
 #include <osl/module.h>
 #endif
 
-#ifdef __SunOS_5_5_1
-extern "C" { int gethostname(char*,int); }
-#endif
-
 #include <prex.h>
 #include <X11/cursorfont.h>
-#include "nodrop_curs.h"
-#include "nodrop_mask.h"
-#include "wait_curs.h"
-#include "wait_mask.h"
-#include "hsplit_curs.h"
-#include "hsplit_mask.h"
-#include "vsplit_curs.h"
-#include "vsplit_mask.h"
-#include "neswsize_curs.h"
-#include "neswsize_mask.h"
-#include "nwsesize_curs.h"
-#include "nwsesize_mask.h"
-#include "magnify_curs.h"
-#include "magnify_mask.h"
-#include "rotate_curs.h"
-#include "rotate_mask.h"
-#include "hshear_curs.h"
-#include "hshear_mask.h"
-#include "vshear_curs.h"
-#include "vshear_mask.h"
-#include "drawline_curs.h"
-#include "drawline_mask.h"
-#include "drawrect_curs.h"
-#include "drawrect_mask.h"
-#include "drawpolygon_curs.h"
-#include "drawpolygon_mask.h"
-#include "drawbezier_curs.h"
-#include "drawbezier_mask.h"
-#include "drawarc_curs.h"
-#include "drawarc_mask.h"
-#include "drawpie_curs.h"
-#include "drawpie_mask.h"
-#include "drawcirclecut_curs.h"
-#include "drawcirclecut_mask.h"
-#include "drawellipse_curs.h"
-#include "drawellipse_mask.h"
-#include "drawconnect_curs.h"
-#include "drawconnect_mask.h"
-#include "drawtext_curs.h"
-#include "drawtext_mask.h"
-#include "mirror_curs.h"
-#include "mirror_mask.h"
-#include "crook_curs.h"
-#include "crook_mask.h"
-#include "crop_curs.h"
-#include "crop_mask.h"
-#include "move_curs.h"
-#include "move_mask.h"
-#include "movepoint_curs.h"
-#include "movepoint_mask.h"
-#include "movebezierweight_curs.h"
-#include "movebezierweight_mask.h"
-#include "drawfreehand_curs.h"
-#include "drawfreehand_mask.h"
-#include "drawcaption_curs.h"
-#include "drawcaption_mask.h"
-#include "movedata_curs.h"
-#include "movedata_mask.h"
-#include "copydata_curs.h"
-#include "copydata_mask.h"
-#include "linkdata_curs.h"
-#include "linkdata_mask.h"
-#include "movedlnk_curs.h"
-#include "movedlnk_mask.h"
-#include "copydlnk_curs.h"
-#include "copydlnk_mask.h"
-#include "movefile_curs.h"
-#include "movefile_mask.h"
-#include "copyfile_curs.h"
-#include "copyfile_mask.h"
-#include "linkfile_curs.h"
-#include "linkfile_mask.h"
-#include "moveflnk_curs.h"
-#include "moveflnk_mask.h"
-#include "copyflnk_curs.h"
-#include "copyflnk_mask.h"
-#include "movefiles_curs.h"
-#include "movefiles_mask.h"
-#include "copyfiles_curs.h"
-#include "copyfiles_mask.h"
-
-#include "chart_curs.h"
-#include "chart_mask.h"
-#include "detective_curs.h"
-#include "detective_mask.h"
-#include "pivotcol_curs.h"
-#include "pivotcol_mask.h"
-#include "pivotfld_curs.h"
-#include "pivotfld_mask.h"
-#include "pivotrow_curs.h"
-#include "pivotrow_mask.h"
-#include "pivotdel_curs.h"
-#include "pivotdel_mask.h"
-
-#include "chain_curs.h"
-#include "chain_mask.h"
-#include "chainnot_curs.h"
-#include "chainnot_mask.h"
-
-#include "timemove_curs.h"
-#include "timemove_mask.h"
-#include "timesize_curs.h"
-#include "timesize_mask.h"
-
-#include "ase_curs.h"
-#include "ase_mask.h"
-#include "asn_curs.h"
-#include "asn_mask.h"
-#include "asne_curs.h"
-#include "asne_mask.h"
-#include "asns_curs.h"
-#include "asns_mask.h"
-#include "asnswe_curs.h"
-#include "asnswe_mask.h"
-#include "asnw_curs.h"
-#include "asnw_mask.h"
-#include "ass_curs.h"
-#include "ass_mask.h"
-#include "asse_curs.h"
-#include "asse_mask.h"
-#include "assw_curs.h"
-#include "assw_mask.h"
-#include "asw_curs.h"
-#include "asw_mask.h"
-#include "aswe_curs.h"
-#include "aswe_mask.h"
-#include "null_curs.h"
-#include "null_mask.h"
-
-#include "airbrush_curs.h"
-#include "airbrush_mask.h" 
-#include "fill_curs.h"
-#include "fill_mask.h"
-#include "vertcurs_curs.h" 
-#include "vertcurs_mask.h" 
-
+#include "salcursors.h"
 #include "invert50.h"
-#if !(defined AIX)
-#include <X11/extensions/XShm.h>
-#endif
 #ifdef SOLARIS
 #define XK_KOREAN
 #endif
@@ -272,7 +128,7 @@ extern "C" { int gethostname(char*,int);
 #include <salgdi.hxx>
 #endif
 #ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#include <salframe.h>
 #endif
 #ifndef _SV_KEYCODES_HXX
 #include <keycodes.hxx>
@@ -280,20 +136,17 @@ extern "C" { int gethostname(char*,int);
 #ifndef _SV_SALBTYPE_HXX
 #include <salbtype.hxx>
 #endif
-#ifndef _SV_SALBMP_HXX
-#include <salbmp.hxx>
-#endif
-#ifndef _SV_SALSYS_HXX
-#include <salsys.hxx>
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
 #endif
-#ifndef _SV_SALOGL_HXX
-#include <salogl.hxx>
+#ifndef _SV_SALOGL_H
+#include <salogl.h>
 #endif
 #ifndef _OSL_THREADMUTEX_H_
 #include <osl/mutex.h>
 #endif
-#ifndef _SV_SALOBJ_HXX
-#include <salobj.hxx>
+#ifndef _SV_SALOBJ_H
+#include <salobj.h>
 #endif
 #ifndef _VCL_SM_HXX
 #include <sm.hxx>
@@ -301,6 +154,9 @@ extern "C" { int gethostname(char*,int);
 #ifndef _VCL_WMADAPTOR_HXX_
 #include <wmadaptor.hxx>
 #endif
+#ifndef _SV_DTINT_HXX
+#include <dtint.hxx>
+#endif
 
 #include <osl/socket.h>
 #include <rtl/ustring>
@@ -323,8 +179,6 @@ using namespace vcl_sal;
 
 // -=-= Prototyps =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-EXTERN_C int XShmGetEventBase( Display* );
-
 // -=-= static variables -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 static const char* const VisualClassName[] = {
@@ -565,9 +419,9 @@ extern "C" srv_vendor_t 
 sal_GetServerVendor( Display *p_display )
 {
 	typedef struct {
-		srv_vendor_t  e_vendor;	// vendor as enum
-		char		 *p_name;	// vendor name as returned by VendorString()
-		unsigned int  n_len;	// number of chars to compare
+		srv_vendor_t	e_vendor;	// vendor as enum
+		const char		*p_name;	// vendor name as returned by VendorString()
+		unsigned int	n_len;	// number of chars to compare
 	} vendor_t;
 
 	const vendor_t p_vendorlist[] = {
@@ -697,7 +551,7 @@ BOOL SalDisplay::BestVisual( Display    
 		pWeight[ i ] -= pVInfos[ i ].visualid;
 	}
 
-	SalOpenGL::MakeVisualWeights( pDisplay, pVInfos, pWeight, nVisuals );
+	X11SalOpenGL::MakeVisualWeights( pDisplay, pVInfos, pWeight, nVisuals );
 	
 	int nBestVisual = 0;
 	int nBestWeight = -1024;
@@ -743,19 +597,20 @@ extern "C" {
 }
 #endif /* HAVE_LIBSN */
 
-SalDisplay::SalDisplay( Display *display, Visual *pVisual, Colormap aColMap ) : 
+SalDisplay::SalDisplay( Display *display, Colormap aColMap ) :
 		pDisp_( display ),
 		mpFallbackFactory ( NULL ),
         m_pWMAdaptor( NULL ),
-        hRefWindow_( None )
+        hRefWindow_( None ),
+        mpInputMethod( NULL )
 {
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "SalDisplay::SalDisplay()\n" );
+#endif
     SalData *pSalData  = GetSalData();
-    XVisualInfo aXVI;
 
-    if( !pSalData->GetDefDisp() )
-        pSalData->SetDefDisp( this );
-    if( !pSalData->GetCurDisp() )
-        pSalData->SetCurDisp( this );
+    DBG_ASSERT( ! pSalData->GetDisplay(), "Second SalDisplay created !!!\n" );
+    pSalData->SetSalDisplay( this );
 
 #ifdef _USE_PRINT_EXTENSION_
     pXLib_    = XSalIsDisplay( pDisp_ ) ? pSalData->GetLib() : NULL;
@@ -768,30 +623,30 @@ SalDisplay::SalDisplay( Display *display
 		aColMap = DefaultColormap( display, nScreen_ );
     if( !IsDisplay() && !aColMap)
     	aColMap = 1;   // trick for XPrinter
-    if (!pVisual)
-        pVisual = DefaultVisual( pDisp_, nScreen_ );
-
-    sal_GetVisualInfo( pDisp_, XVisualIDFromVisual( pVisual ), aXVI );
-    Init( aColMap, &aXVI );
-
-#ifdef HAVE_LIBSN
-    m_pSnDisplay = sn_display_new( display, SnErrorTrapPush, SnErrorTrapPop );
-    m_pSnLauncheeContext = sn_launchee_context_new_from_environment( m_pSnDisplay, nScreen_ );
-#  ifdef DBG_UTIL
-    if( !m_pSnLauncheeContext )
-         fprintf( stderr, "Failed to get launch feedback info from "
-		  "DESKTOP_LAUNCH_ID/DESKTOP_LAUNCH_WINDOW\n" );
-#  endif /* DBG_UTIL */
-#endif /* HAVE_LIBSN */
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 SalDisplay::~SalDisplay( )
 {
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "SalDisplay::~SalDisplay()\n" );
+#endif
+    if( pDisp_ )
+    {
+        doDestruct();
+#if OSL_DEBUG_LEVEL > 1
+        fprintf( stderr, "display %p closed\n", pDisp_ );
+#endif
+        pDisp_ = NULL;
+    }
+}
+
+void SalDisplay::doDestruct()
+{
     SalData *pSalData = GetSalData();
 
     delete m_pWMAdaptor;
-	SalBitmap::ImplDestroyCache();
+	X11SalBitmap::ImplDestroyCache();
     DestroyFontCache();
 
     if( IsDisplay() )
@@ -827,7 +682,7 @@ SalDisplay::~SalDisplay( )
         pXLib_->Remove( ConnectionNumber( pDisp_ ) );
 		
         // free colormap before modifying pVisual_
-        xColor_.Clear();
+        delete m_pColormap;
         
         delete pVisual_;
         
@@ -836,7 +691,6 @@ SalDisplay::~SalDisplay( )
 
 		delete mpInputMethod;
 		delete mpKbdExtension;
-        XCloseDisplay( pDisp_ );
     }
 
 #ifdef HAVE_LIBSN
@@ -845,96 +699,126 @@ SalDisplay::~SalDisplay( )
     sn_display_unref( m_pSnDisplay );
 #endif /* HAVE_LIBSN */
 
-    pDisp_  = (Display*)ILLEGAL_POINTER;
-
-    pSalData->Remove( this );
-
     pVisual_        = (SalVisual*)ILLEGAL_POINTER;
     pRootVisual_    = (SalVisual*)ILLEGAL_POINTER;
 
-    if( pSalData->GetDefDisp() == this )
-        pSalData->SetDefDisp( NULL );
-    if( pSalData->GetCurDisp() == this )
-        pSalData->SetCurDisp( NULL );
+    if( pSalData->GetDisplay() == this )
+        pSalData->SetSalDisplay( NULL );
 }
 
-static int DisplayHasEvent( int fd, SalDisplay *pDisplay  )
+static int DisplayHasEvent( int fd, SalX11Display *pDisplay  )
 {
   DBG_ASSERT( ConnectionNumber( pDisplay->GetDisplay() ) == fd,
               "wrong fd in DisplayHasEvent" );
   if( ! pDisplay->IsDisplay() )
       return 0;
 
-  SalYieldMutex* pSalInstYieldMutex	=
-      GetSalData()->pFirstInstance_->maInstData.mpSalYieldMutex;
+  vos::IMutex* pSalInstYieldMutex	=
+      GetSalData()->pInstance_->GetYieldMutex();
   ::vos::OGuard aGuard( *pSalInstYieldMutex );
   return pDisplay->IsEvent();
 }
-static int DisplayQueue( int fd, SalDisplay *pDisplay )
+static int DisplayQueue( int fd, SalX11Display *pDisplay )
 {
   DBG_ASSERT( ConnectionNumber( pDisplay->GetDisplay() ) == fd,
               "wrong fd in DisplayHasEvent" )
-  SalYieldMutex* pSalInstYieldMutex	=
-      GetSalData()->pFirstInstance_->maInstData.mpSalYieldMutex;
+  vos::IMutex* pSalInstYieldMutex	=
+      GetSalData()->pInstance_->GetYieldMutex();
   ::vos::OGuard aGuard( *pSalInstYieldMutex );
   return XEventsQueued( pDisplay->GetDisplay(),
                         QueuedAfterReading );
 }
-static int DisplayYield( int fd, SalDisplay *pDisplay )
+static int DisplayYield( int fd, SalX11Display *pDisplay )
 {
   DBG_ASSERT( ConnectionNumber( pDisplay->GetDisplay() ) == fd,
               "wrong fd in DisplayHasEvent" );
-  SalYieldMutex* pSalInstYieldMutex	=
-      GetSalData()->pFirstInstance_->maInstData.mpSalYieldMutex;
+  vos::IMutex* pSalInstYieldMutex	=
+      GetSalData()->pInstance_->GetYieldMutex();
   ::vos::OGuard aGuard( *pSalInstYieldMutex );
   pDisplay->Yield( TRUE );
   return TRUE;
 }
 
+SalX11Display::SalX11Display( Display *display, Visual *pVisual, Colormap aColMap )
+		: SalDisplay( display, aColMap )
+{
+    Init( aColMap, pVisual );
+
+	pXLib_->Insert( ConnectionNumber( pDisp_ ),
+					this,
+					(YieldFunc) DisplayHasEvent,
+					(YieldFunc) DisplayQueue,
+					(YieldFunc) DisplayYield );
+}
+
+SalX11Display::~SalX11Display()
+{
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "SalX11Display::~SalX11Display()\n" );
+#endif
+	if( pDisp_ )
+	{
+		doDestruct();
+		XCloseDisplay( pDisp_ );
+		pDisp_ = NULL;
+	}
+}
+
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalDisplay::Init( Colormap hXColmap, const XVisualInfo* pXVI )
+void SalDisplay::Init( Colormap hXColmap, Visual *pVisual )
 {
-    GetSalData()->Insert( this );
+    XVisualInfo aXVI;
+
+    if (!pVisual)
+        pVisual = DefaultVisual( pDisp_, nScreen_ );
+    sal_GetVisualInfo( pDisp_, XVisualIDFromVisual( pVisual ), aXVI );
 
     for( size_t i = 0; i < POINTER_COUNT; i++ )
         aPointerCache_[i] = None;
 
     eWindowManager_     = otherwm;
     nProperties_        = PROPERTY_DEFAULT;
-    nStateOfYield_      = 0;
-    nStateOfSendEvent_  = 0;
     hEventGuard_        = NULL;
-    pEventQueue_        = NULL;
-    pDispatchStack_     = NULL;
     pFontCache_         = NULL;
 	mpFontList			= (XlfdStorage*)NULL;
 	mpFactory  			= (AttributeProvider*)NULL;
-    pCapture_           = NULL;
-    pVisual_            = new SalVisual( pXVI );
+    m_pCapture			= NULL;
+    pVisual_            = new SalVisual( &aXVI );
     m_bXinerama			= false;
     aSize_              = Size( DisplayWidth ( pDisp_, nScreen_ ),
                                 DisplayHeight( pDisp_, nScreen_ ) );
-    aResolution_        =
-        Pair( DPI( aSize_.Width(),  DisplayWidthMM ( pDisp_, nScreen_ ) ),
-              DPI( aSize_.Height(), DisplayHeightMM( pDisp_, nScreen_ ) ) );
 
+    const char *value;
+    /*  #i15507#
+     *  Xft resolution should take precedence since
+     *  it is what modern desktops use.
+     */
+    if ((value = XGetDefault (pDisp_, "Xft", "dpi")))
+    {
+        rtl::OString str (value);
+        long dpi = (long) str.toDouble();
+        aResolution_ = Pair( dpi, dpi );
+        mbExactResolution = true;
+    }
+    else
+    {
+        aResolution_     =
+            Pair( DPI( aSize_.Width(),  DisplayWidthMM ( pDisp_, nScreen_ ) ),
+                  DPI( aSize_.Height(), DisplayHeightMM( pDisp_, nScreen_ ) ) );
+        mbExactResolution	= false;
+    }
+    
     nMaxRequestSize_    = XExtendedMaxRequestSize( pDisp_ ) * 4;
     if( !nMaxRequestSize_ )
         nMaxRequestSize_ = XMaxRequestSize( pDisp_ ) * 4;
 	
 	SetServerVendor();
-	SalBitmap::ImplCreateCache();
+	X11SalBitmap::ImplCreateCache();
 
     if( IsDisplay() )
     {
         hEventGuard_    = osl_createMutex();
 
-        pXLib_->Insert( ConnectionNumber( pDisp_ ),
-                        this,
-                        (YieldFunc) DisplayHasEvent,
-                        (YieldFunc) DisplayQueue,
-                        (YieldFunc) DisplayYield );
-
         pScreen_        = ScreenOfDisplay( pDisp_, nScreen_ );
         hRootWindow_    = RootWindowOfScreen( pScreen_ );
 
@@ -944,7 +828,6 @@ void SalDisplay::Init( Colormap hXColmap
 
         // - - - - - - - - - - Visuals - - - - - - - - - - - - - - -
         Visual *pRootVisual = DefaultVisual( pDisp_, nScreen_ );
-        // if( pRootVisual != pXVI->visual )
         if( pRootVisual->visualid != pVisual_->GetVisualId() )
         {
             XVisualInfo aXVI;
@@ -984,10 +867,10 @@ void SalDisplay::Init( Colormap hXColmap
 							 );
 
 			ByteString aExec( SessionManagerClient::getExecName(), osl_getThreadTextEncoding() );
-			char* argv[2];
+			const char* argv[2];
 			argv[0] = "/bin/sh";
-			argv[1] = const_cast<char*>(aExec.GetBuffer());
-			XSetCommand( pDisp_, hRefWindow_, argv, 2 );
+			argv[1] = aExec.GetBuffer();
+			XSetCommand( pDisp_, hRefWindow_, const_cast<char**>(argv), 2 );
 
             XSelectInput( pDisp_, hRefWindow_, PropertyChangeMask );
 
@@ -996,40 +879,6 @@ void SalDisplay::Init( Colormap hXColmap
         // - - - - - - - - - - Synchronize - - - - - - - - - - - - -
         if( getenv( "SAL_SYNCHRONIZE" ) )
             XSynchronize( pDisp_, True );
-
-        // - - - - - - - - - - Shared Images - - - - - - - - - - - -
-#if defined _XSHM_H_ // && defined DBG_UTIL
-        // SharedMem wird nur noch ueber SalProperties enabled
-        // wegen Bugs #47289 und #46512
-
-        if(    ( nProperties_ & PROPERTY_FEATURE_SharedMemory )
-            && (    *DisplayString( pDisp_ ) == ':'
-                || !strncmp( DisplayString( pDisp_ ), "localhost:", 10 ))
-          )
-        {
-            int  nMinor, nMajor;
-            Bool bPixmaps;
-
-            nSharedImages_      = XShmQueryVersion( pDisp_,
-                                                    &nMajor,
-                                                    &nMinor,
-                                                    &bPixmaps )
-                ? 0x80000000 : 0;
-        }
-        else
-            nSharedImages_      = 0;
-#else
-        nSharedImages_      = 0;
-#endif
-        // - - - - - - - - - - Images  - - - - - - - - - - - - - - -
-        nImageDepths_       = 0x00000000;
-        int nCount, *pDepths = XListDepths( pDisp_, nScreen_, &nCount );
-        if( pDepths )
-        {
-            for( int i = 0; i < nCount; i++ )
-                nImageDepths_ |= 1 << (pDepths[i]-1);
-            XFree( pDepths );
-        }
     }
     else
     {
@@ -1064,22 +913,10 @@ void SalDisplay::Init( Colormap hXColmap
         bLocal_             = TRUE;	/* always true for xprinter */
 		mbLocalIsValid		= TRUE; /* yes bLocal_ is initialized */
         nProperties_       &= ~PROPERTY_SUPPORT_XSetClipMask; //XPrinter doesnt
-        nSharedImages_      = 0;
-        nImageDepths_       = 0xFFFFFFFF;
     }
 
     // - - - - - - - - - - Images  - - - - - - - - - - - - - - -
-    // 0x8080C889
-    nImageDepths_ &= (1<<(32-1))
-                     |(1<<(24-1))
-                     |(1<<(16-1))
-                     |(1<<(15-1))
-                     |(1<<(12-1))
-                     |(1<<(8-1))
-                     |(1<<(4-1))
-                     |(1<<(1-1));
-
-    xColor_             = new SalColormap( this, hXColmap );
+    m_pColormap             = new SalColormap( this, hXColmap );
 
     // - - - - - - - - - - GCs - - - - - - - - - - - - - - - - -
     XGCValues values;
@@ -1149,10 +986,6 @@ void SalDisplay::Init( Colormap hXColmap
                                             invert50_width,
                                             invert50_height );
 
-        // - - - - - - - - - - Sound - - - - - - - - - - - - - - - -
-
-        nBeepVolume_    = 0;
-
         // - - - - - - - - - - Fonts - - - - - - - - - - - - - - - -
 
 #ifndef USE_BUILTIN_RASTERIZER
@@ -1215,9 +1048,6 @@ void SalDisplay::Init( Colormap hXColmap
 			if( GetServerVendor() == vendor_xfree )
             {
                 nProperties_ |= PROPERTY_BUG_XCopyArea_GXxor;
-#ifdef ARM32 // ??? Server! nicht Client ???
-                nProperties_ &= ~PROPERTY_SUPPORT_XSetClipMask;
-#endif
 #if defined LINUX || defined FREEBSD || defined MACOSX
 				// otherwm and olwm are a kind of default, which are not detected
 				// carefully. if we are running linux (i.e. not netbsd) on an xfree 
@@ -1322,6 +1152,20 @@ void SalDisplay::Init( Colormap hXColmap
 
     InitXinerama();
 
+    // initialize system settings update
+    DtIntegrator* pIntegrator = DtIntegrator::CreateDtIntegrator();
+    pIntegrator->Acquire();
+
+#ifdef HAVE_LIBSN
+    m_pSnDisplay = sn_display_new( GetDisplay(), SnErrorTrapPush, SnErrorTrapPop );
+    m_pSnLauncheeContext = sn_launchee_context_new_from_environment( m_pSnDisplay, nScreen_ );
+#  ifdef DBG_UTIL
+    if( !m_pSnLauncheeContext )
+         fprintf( stderr, "Failed to get launch feedback info from "
+		  "DESKTOP_LAUNCH_ID/DESKTOP_LAUNCH_WINDOW\n" );
+#  endif /* DBG_UTIL */
+#endif /* HAVE_LIBSN */
+
 #ifdef DBG_UTIL
     PrintInfo();
 #endif
@@ -1331,7 +1175,7 @@ void SalDisplay::Init( Colormap hXColmap
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 void SalDisplay::Beep() const
 {
-    XBell( pDisp_, nBeepVolume_ );
+    XBell( pDisp_, 0 );
 }
 
 // Keyboard
@@ -1477,9 +1321,6 @@ XubString SalDisplay::GetKeyName( USHORT
             break;
 
         #if !defined (SunXK_Undo) 
-            #define SunXK_Undo		0x0000FF65	// XK_Undo
-            #define SunXK_Again		0x0000FF66	// XK_Redo
-            #define SunXK_Find		0x0000FF68	// XK_Find
             #define SunXK_Stop		0x0000FF69	// XK_Cancel
             #define SunXK_Props		0x1005FF70
             #define SunXK_Front		0x1005FF71
@@ -1490,28 +1331,28 @@ XubString SalDisplay::GetKeyName( USHORT
         #endif
 
         case KEY_REPEAT:
-			nKeySym = GetServerVendor() == vendor_sun ? SunXK_Again : XK_L2;
+			nKeySym = XK_Redo;
             break;
         case KEY_PROPERTIES:
-            nKeySym = GetServerVendor() == vendor_sun ? SunXK_Props : XK_L3;
+            nKeySym = SunXK_Props;
             break;
         case KEY_UNDO:
-            nKeySym = GetServerVendor() == vendor_sun ? SunXK_Undo  : XK_L4; 
+            nKeySym = XK_Undo;
             break;
         case KEY_FRONT:
-            nKeySym = GetServerVendor() == vendor_sun ? SunXK_Front : XK_L5;
+            nKeySym = SunXK_Front;
             break;
         case KEY_COPY:
-            nKeySym = GetServerVendor() == vendor_sun ? SunXK_Copy  : XK_L6;
+            nKeySym = SunXK_Copy;
             break;
         case KEY_OPEN:
-            nKeySym = GetServerVendor() == vendor_sun ? SunXK_Open  : XK_L7;
+            nKeySym = SunXK_Open;
             break;
         case KEY_PASTE:
-            nKeySym = GetServerVendor() == vendor_sun ? SunXK_Paste : XK_L8;
+            nKeySym = SunXK_Paste;
             break;
         case KEY_FIND:
-            nKeySym = GetServerVendor() == vendor_sun ? SunXK_Find  : XK_L9; 
+            nKeySym = XK_Find;
             break;
         case KEY_CUT:
             nKeySym = GetServerVendor() == vendor_sun ? SunXK_Cut   : XK_L10;
@@ -1543,8 +1384,8 @@ XubString SalDisplay::GetKeyName( USHORT
         case KEY_EQUAL:
             nKeySym = XK_equal;
             break;
-        case KEY_FRONT+1: // KEY_HELP
-            nKeySym = XK_F1; // XK_Help; ???
+        case KEY_HELP:
+            nKeySym = XK_Help;
             break;
         case KEY_HANGUL_HANJA:
             nKeySym = XK_Hangul_Hanja;
@@ -1647,7 +1488,7 @@ USHORT SalDisplay::GetKeyCode( KeySym ke
                 *pcPrintable = '+';
                 break;
             case XK_KP_Separator:
-                nKey = KEY_COMMA; // ???
+                nKey = KEY_DECIMAL;
                 *pcPrintable = ',';
                 break;
             case XK_KP_Subtract:
@@ -1655,7 +1496,7 @@ USHORT SalDisplay::GetKeyCode( KeySym ke
                 *pcPrintable = '-';
                 break;
             case XK_KP_Decimal:
-                nKey = KEY_POINT;
+                nKey = KEY_DECIMAL;
                 *pcPrintable = '.';
                 break;
             case XK_KP_Divide:
@@ -1673,28 +1514,7 @@ USHORT SalDisplay::GetKeyCode( KeySym ke
         }
         else switch( keysym )
         {
-#if 1 // Sun schaltet mit "Alt Graph"/XK_Mode_switch um
             // - - - - - Sun X-Server Tastatur ohne Cursorblock ??? - - -
-#if 0 // Sal supports F1 - F26
-            case XK_R1: // XK_F21:
-                nKey = KEY_F21; // KEY_PRINT/KEY_SYSREQ
-                break;
-            case XK_R2: // XK_F22:
-                nKey = KEY_F22; // KEY_SCROLLLOCK
-                break;
-            case XK_R3: // XK_F23:
-                nKey = KEY_F23; // KEY_PAUSE/KEY_BREAK
-                break;
-            case XK_R4: // XK_F24:
-                nKey = KEY_F24; // KEY_EQUAL
-                break;
-            case XK_R5: // XK_F25:
-                nKey = KEY_F25; // KEY_DIVIDE
-                break;
-            case XK_R6: // XK_F26:
-                nKey = KEY_F26; // KEY_MULTIPLY
-                break;
-#endif
             case XK_R7: // XK_F27:
                 nKey = KEY_HOME;
                 break;
@@ -1724,7 +1544,8 @@ USHORT SalDisplay::GetKeyCode( KeySym ke
                 break;
             // - - - - - Sun X-Server Tastatur ??? - - - - - - - - - - - -
             case XK_L1: // XK_F11:
-                nKey = KEY_F11; // KEY_CANCEL
+                nKey = KEY_F11; // on a sun keyboard this actually is usally SunXK_Stop,
+                // but VCL doesn't have a key defintion for that
                 break;
             case XK_L2: // XK_F12:
 				if ( GetServerVendor() == vendor_sun )
@@ -1756,7 +1577,6 @@ USHORT SalDisplay::GetKeyCode( KeySym ke
             case XK_L10: // XK_F20:
                 nKey = KEY_CUT; // KEY_F20
                 break;
-#endif
             default:
                 if( keysym >= XK_F1 && keysym <= XK_F26 )
                     nKey = (USHORT)(KEY_F1 + keysym - XK_F1);
@@ -1811,19 +1631,18 @@ USHORT SalDisplay::GetKeyCode( KeySym ke
                 nKey = KEY_FIND;
                 break;
             case XK_Help:
-                nKey = KEY_FRONT+1; // KEY_HELP
-                nKey = KEY_F1;
+                nKey = KEY_HELP;
                 break;
             case XK_Menu:
                 nKey = KEY_F10;
                 break;
-#if 0
+/*
             case XK_Break:
             case XK_Select:
             case XK_Execute:
             case XK_Print:
             case XK_Cancel:
-#endif
+*/
         }
     }
     else if( IsISOKey( keysym ) )  // XK_ISO_
@@ -2070,7 +1889,7 @@ KeySym SalDisplay::GetKeySym( XKeyEvent 
 XLIB_Cursor SalDisplay::GetPointer( int ePointerStyle )
 {
     if( ePointerStyle > POINTER_COUNT )
-        return NULL;
+        return 0;
 
     XLIB_Cursor &aCur = aPointerCache_[ePointerStyle];
 
@@ -2355,7 +2174,7 @@ XLIB_Cursor SalDisplay::GetPointer( int 
     if( None == aCur )
     {
         XColor      aBlack, aWhite, aDummy;
-        Colormap    hColormap = xColor_->GetXColormap();
+        Colormap    hColormap = m_pColormap->GetXColormap();
 
         XAllocNamedColor( pDisp_, hColormap, "black", &aBlack, &aDummy );
         XAllocNamedColor( pDisp_, hColormap, "white", &aWhite, &aDummy );
@@ -2372,28 +2191,28 @@ XLIB_Cursor SalDisplay::GetPointer( int 
     return aCur;
 }
 
-int SalDisplay::CaptureMouse( SalFrameData *pCapture )
+int SalDisplay::CaptureMouse( SalFrame *pCapture )
 {
     if( !pCapture )
     {
-        pCapture_ = NULL;
+        m_pCapture = NULL;
         XUngrabPointer( GetDisplay(), CurrentTime );
 		XFlush( GetDisplay() );
         return 0;
     }
 
-    if( pCapture_ )
-        //pCapture_->CaptureMouse( FALSE );
-        pCapture_ = NULL;
+    m_pCapture = NULL;
 
+    // FIXME: get rid of X11SalFrame
+    const SystemEnvData* pEnvData = pCapture->GetSystemData();
     int ret = XGrabPointer( GetDisplay(),
-                            pCapture->GetWindow(),
+                            (XLIB_Window)pEnvData->aWindow,
                             False,
                             PointerMotionMask| ButtonPressMask|ButtonReleaseMask,
                             GrabModeAsync,
                             GrabModeAsync,
                             None,
-                            pCapture->GetCursor(),
+                            static_cast<X11SalFrame*>(pCapture)->GetCursor(),
                             CurrentTime );
 
     if( ret != GrabSuccess )
@@ -2402,7 +2221,7 @@ int SalDisplay::CaptureMouse( SalFrameDa
         return -1;
     }
 
-    pCapture_ = pCapture;
+    m_pCapture = pCapture;
     return 1;
 }
 
@@ -2484,198 +2303,141 @@ void SalDisplay::AddFontPath( const Byte
 
 // Events
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalDisplay::Remove( XEvent *pEvent )
-{
-}
-
-void SalDisplay::SendEvent( Atom          aEvent,
-                                  void         *pData,
-                                  XLIB_Window   hReceiver ) const
-{
-    UINT32 aData[5];
-
-#if __SIZEOFLONG > 4
-    aData[0] = (UINT32)((long)pData & 0xffffffff);
-    aData[1] = (UINT32)((long)pData >> 32);
-#else
-    aData[0] = (UINT32)(long)pData;
-    aData[1] = NULL;
-#endif
-    aData[2] = NULL;
-    aData[3] = NULL;
-    aData[4] = NULL;
-
-    SendEvent( aEvent, aData, hReceiver );
-}
 
-void SalDisplay::SendEvent( Atom          aEvent,
-                                  UINT32       *Data,
-                                  XLIB_Window   hReceiver ) const
+void SalDisplay::SendInternalEvent( SalFrame* pFrame, void* pData, USHORT nEvent )
 {
-#define pClient (&(aClient.xclient))
-    XEvent aClient;
-
-    if( !hReceiver )
-        hReceiver = hReceiver;
-
-    pClient->type           = ClientMessage;
-    pClient->display        = pDisp_;
-    pClient->window         = hReceiver;
-    pClient->message_type   = aEvent;
-    pClient->format         = 32;
-
-    if( Data ) for( int i = 0; i < 5; i++ )
-        pClient->data.l[i] = Data[i];
-
 	if( osl_acquireMutex( hEventGuard_ ) )
     {
-        pClient->send_event     = 2;
-        if( pEventQueue_ )
-        {
-            SalXEvent *pEvent = pEventQueue_;
-            while( pEvent->pNext_ )
-                pEvent = pEvent->pNext_;
-
-            pEvent->pNext_                      = new SalXEvent;
-            pEvent->pNext_->event_              = aClient;
-            pEvent->pNext_->pNext_              = NULL;
-        }
-        else
-        {
-            ((SalDisplay*)this)->pEventQueue_   = new SalXEvent;
-            pEventQueue_->event_                = aClient;
-            pEventQueue_->pNext_                = NULL;
-        }
+        m_aUserEvents.push_back( SalUserEvent( pFrame, pData, nEvent ) );
 
 		// Notify SalXLib::Yield() of a pending event.
-		pXLib_->Wakeup();
+		pXLib_->PostUserEvent();
 
         osl_releaseMutex( hEventGuard_ );
     }
     else
         DBG_ASSERT( 1, "SalDisplay::SendEvent !acquireMutex\n" );
-#undef pClient
 }
 
-BOOL SalDisplay::IsEvent()
+BOOL SalX11Display::IsEvent()
 {
-    if( pEventQueue_ )
-        return TRUE;
-
-    if( XEventsQueued( pDisp_, QueuedAlready ) )
+    BOOL bRet = FALSE;
+    
+    if( osl_acquireMutex( hEventGuard_ ) )
+    {
+        if( m_aUserEvents.begin() != m_aUserEvents.end() )
+            bRet = TRUE;
+        osl_releaseMutex( hEventGuard_ );
+    }
+    
+    if( bRet || XEventsQueued( pDisp_, QueuedAlready ) )
         return TRUE;
 
     XFlush( pDisp_ );
     return FALSE;
 }
 
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-void SalDisplay::Yield( BOOL bWait )
+bool SalDisplay::DispatchInternalEvent()
 {
-    SalXEvent aEvent;
-    while( !nStateOfYield_ )
+    SalFrame* pFrame = NULL;
+    void* pData = NULL;
+    USHORT nEvent = 0;
+
+    if( osl_acquireMutex( hEventGuard_ ) )
     {
-        if( pEventQueue_ )
+        if( m_aUserEvents.begin() != m_aUserEvents.end() )
         {
-            nStateOfYield_ = 5;
-            if( osl_acquireMutex( hEventGuard_ ) )
-            {
-                nStateOfYield_ = 6;
-
-                SalXEvent *pEvent = pEventQueue_;
+            pFrame	= m_aUserEvents.front().m_pFrame;
+            pData	= m_aUserEvents.front().m_pData;
+            nEvent	= m_aUserEvents.front().m_nEvent;
 
-                pEventQueue_    = pEventQueue_->pNext_;
+            m_aUserEvents.pop_front();
+        }
+        osl_releaseMutex( hEventGuard_ );
+    }
+    else
+        DBG_ASSERT( 1, "SalDisplay::Yield !acquireMutex\n" );
 
-                osl_releaseMutex( hEventGuard_ );
+    if( pFrame )
+        pFrame->CallCallback( nEvent, pData );
 
-                aEvent.event_   = pEvent->event_;
+    return pFrame != NULL;
+}
 
-                delete pEvent;
+// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-                break;
-            }
-            else
-                DBG_ASSERT( 1, "SalDisplay::Yield !acquireMutex\n" );
-        }
+void SalX11Display::Yield( BOOL bWait )
+{
+    if( DispatchInternalEvent() )
+        return;
 
-        nStateOfYield_ = 1;
+    XEvent aEvent;
+    DBG_ASSERT( static_cast<SalYieldMutex*>(GetSalData()->pInstance_->GetYieldMutex())->GetThreadId() ==
+                NAMESPACE_VOS(OThread)::getCurrentIdentifier(),
+                "will crash soon since solar mutex not locked in SalDisplay::Yield" );
 
-		SalData *pSalData		= GetSalData();
-		SalYieldMutex* pSalInstYieldMutex	=
-			pSalData->pFirstInstance_->maInstData.mpSalYieldMutex;
-		
-		DBG_ASSERT( pSalInstYieldMutex->GetThreadId() ==
-				   NAMESPACE_VOS(OThread)::getCurrentIdentifier(),
-					"will crash soon since solar mutex not locked in SalDisplay::Yield" );
-		
-		// note: alternate input is dispatched by XtAppNextEvent
-		XNextEvent( pDisp_, &aEvent.event_ );		
+    XNextEvent( pDisp_, &aEvent );		
 
 #ifdef HAVE_LIBSN
-		if( m_pSnLauncheeContext )
-	        {
-			sn_launchee_context_complete( m_pSnLauncheeContext );
-			sn_launchee_context_unref( m_pSnLauncheeContext );
-			m_pSnLauncheeContext = NULL;
-		}
-
-		if( sn_display_process_event( m_pSnDisplay, &aEvent.event_ ) )
-			return;
+    if( m_pSnLauncheeContext )
+    {
+        sn_launchee_context_complete( m_pSnLauncheeContext );
+        sn_launchee_context_unref( m_pSnLauncheeContext );
+        m_pSnLauncheeContext = NULL;
+    }
+    
+    if( sn_display_process_event( m_pSnDisplay, &aEvent ) )
+        return;
 #endif /* HAVE_LIBSN */
-	}
-
-    nStateOfYield_ = 0;
 
     BOOL bIgnoreXErrors = pXLib_->GetIgnoreXErrors();
 
-    aEvent.pNext_   = pDispatchStack_;
-    pDispatchStack_ = &aEvent;
-
-    Dispatch( &aEvent.event_ );
-
-    pDispatchStack_ = aEvent.pNext_;
+    Dispatch( &aEvent );
 
 #ifdef DBG_UTIL
     if( pXLib_->WasXError() )
     {
         XFlush( pDisp_ );
-        PrintEvent( "SalDisplay::Yield (WasXError)", &aEvent.event_ );
+        PrintEvent( "SalDisplay::Yield (WasXError)", &aEvent );
     }
 #endif
 
     pXLib_->SetIgnoreXErrors( bIgnoreXErrors );
 }
 
-long SalDisplay::Dispatch( XEvent *pEvent )
+long SalX11Display::Dispatch( XEvent *pEvent )
 {
 	if( pEvent->type == XLIB_KeyPress || pEvent->type == KeyRelease )
-	  {
+    {
 	    XLIB_Window aWindow = pEvent->xkey.window;
-	    SalFrame* pFrame = NULL;
-	    for( pFrame = GetSalData()->pFirstFrame_; 
-			    pFrame 
-			 && pFrame->maFrameData.GetWindow()      != aWindow 
-			 && pFrame->maFrameData.GetShellWindow() != aWindow; 
-			 pFrame = pFrame->maFrameData.GetNextFrame() )
-	      ;
-	    if( pFrame ) {
-	      XLIB_Window window= pFrame->maFrameData.GetWindow();
-	      if ( mpInputMethod->FilterEvent( pEvent , window) )
-		return 0;
+        
+        std::list< SalFrame* >::const_iterator it;
+        for( it = m_aFrames.begin(); it != m_aFrames.end(); ++it )
+        {
+            X11SalFrame* pFrame = static_cast< X11SalFrame* >(*it);
+            if( pFrame->GetWindow() == aWindow || pFrame->GetShellWindow() == aWindow )
+            {
+                aWindow = pFrame->GetWindow();
+                break;
+            }
+        }
+	    if( it != m_aFrames.end() )
+        {
+            if ( mpInputMethod->FilterEvent( pEvent , aWindow ) )
+                return 0;
 	    }
-	  }
+    }
 	else
-	  if ( mpInputMethod->FilterEvent( pEvent, None ) )
-	    return 0;
+        if ( mpInputMethod->FilterEvent( pEvent, None ) )
+            return 0;
 	
-	SalInstance* pInstance = GetSalData()->pFirstInstance_;
-	if( pInstance->maInstData.mpEventCallback )
+	SalInstance* pInstance = GetSalData()->pInstance_;
+    if( pInstance->GetEventCallback() )
 	{
 		YieldMutexReleaser aReleaser;
-		pInstance->maInstData.mpEventCallback( pInstance->maInstData.mpEventInst, pEvent, sizeof( XEvent ) );
+		pInstance->CallEventCallback( pEvent, sizeof( XEvent ) );
 	}
-
+    
     switch( pEvent->type )
     {
         case MotionNotify:
@@ -2689,12 +2451,9 @@ long SalDisplay::Dispatch( XEvent *pEven
             if( pEvent->xproperty.window == hRefWindow_ &&
                 pEvent->xproperty.atom == getWMAdaptor()->getAtom( WMAdaptor::VCL_SYSTEM_SETTINGS ) )
             {
-                SalFrame *pFrame = GetSalData()->pFirstFrame_;
-                while( pFrame )
-                {
-                    pFrame->maFrameData.Call( SALEVENT_SETTINGSCHANGED, NULL );
-                    pFrame = pFrame->maFrameData.GetNextFrame();
-                }
+                std::list< SalFrame* >::const_iterator it;
+                for( it = m_aFrames.begin(); it != m_aFrames.end(); ++it )
+                    (*it)->CallCallback( SALEVENT_SETTINGSCHANGED, NULL );
                 return 0;
             }
             break;
@@ -2713,43 +2472,29 @@ long SalDisplay::Dispatch( XEvent *pEven
 				GetKbdExtension()->Dispatch( pEvent );
 				return 1;
 			}
-
-#ifdef _XSHM_H_
-		{
-			BOOL bPrevious = pXLib_->GetIgnoreXErrors();
-			pXLib_->SetIgnoreXErrors( TRUE );
-            if( pEvent->type == XShmGetEventBase( pDisp_ ) + ShmCompletion )
-            {
-                Remove( pEvent );
-                return 1;
-            }
-			pXLib_->SetIgnoreXErrors( bPrevious );
-		}
-#endif
             break;
     }
 
-    SalFrame *pFrame = GetSalData()->pFirstFrame_;
-
-    while( pFrame )
+    std::list< SalFrame* >::const_iterator it;
+    for( it = m_aFrames.begin(); it != m_aFrames.end(); ++it )
     {
+        X11SalFrame* pFrame = static_cast< X11SalFrame* >(*it);
 		XLIB_Window aDispatchWindow = pEvent->xany.window;
-        if( pFrame->maFrameData.GetWindow() == aDispatchWindow
-            || pFrame->maFrameData.GetShellWindow() == aDispatchWindow
-            || pFrame->maFrameData.GetForeignParent() == aDispatchWindow
+        if( pFrame->GetWindow() == aDispatchWindow
+            || pFrame->GetShellWindow() == aDispatchWindow
+            || pFrame->GetForeignParent() == aDispatchWindow
 			)
 		{
-			return pFrame->maFrameData.Dispatch( pEvent );
+			return pFrame->Dispatch( pEvent );
 		}
-		if( pEvent->type == ConfigureNotify && pEvent->xconfigure.window == pFrame->maFrameData.GetStackingWindow() )
+		if( pEvent->type == ConfigureNotify && pEvent->xconfigure.window == pFrame->GetStackingWindow() )
 		{
-			return pFrame->maFrameData.Dispatch( pEvent );
+			return pFrame->Dispatch( pEvent );
 		}
-        pFrame = pFrame->maFrameData.GetNextFrame();
     }
 
 	// dispatch to salobjects
-	SalObjectData::Dispatch( pEvent );
+	X11SalObject::Dispatch( pEvent );
 
     return 0;
 }
@@ -2884,24 +2629,6 @@ void SalDisplay::PrintEvent( const ByteS
                 break;
         }
     }
-#ifdef _XSHM_H_
-    else if( pEvent->type == XShmGetEventBase( pDisp_ ) + ShmCompletion )
-    {
-#define pCompletionEvent ((XShmCompletionEvent*)pEvent)
-        fprintf( stderr, "[%s] %s s=%d d=%ld\n",
-                 rComment.GetBuffer(),
-                 "ShmCompletion",
-                 pCompletionEvent->send_event,
-                 pCompletionEvent->drawable );
-
-        fprintf( stderr, "\t\tc=%d.%d s=%ld o=%ld\n",
-                 pCompletionEvent->major_code,
-                 pCompletionEvent->minor_code,
-                 pCompletionEvent->shmseg,
-                 pCompletionEvent->offset );
-#undef pCompletionEvent
-    }
-#endif
     else
         fprintf( stderr, "[%s] %d s=%d w=%ld\n",
                  rComment.GetBuffer(),
@@ -2970,7 +2697,7 @@ void SalDisplay::PrintInfo() const
              Hypothenuse( DisplayWidthMM ( pDisp_, nScreen_ ),
                           DisplayHeightMM( pDisp_, nScreen_ ) ) / 25.4 );
     fprintf( stderr, "\tBlack&White       \t%lu %lu\n",
-             xColor_->GetBlackPixel(), xColor_->GetWhitePixel() );
+             m_pColormap->GetBlackPixel(), m_pColormap->GetWhitePixel() );
     fprintf( stderr, "\tRGB               \t0x%lx 0x%lx 0x%lx\n",
              pVisual_->red_mask, pVisual_->green_mask, pVisual_->blue_mask );
     fprintf( stderr, "\tVisual            \t%d-bit %s ID=0x%x\n",
@@ -2982,31 +2709,16 @@ void SalDisplay::PrintInfo() const
                  pRootVisual_->GetDepth(),
                  VisualClassName[ pRootVisual_->GetClass() ],
                  pRootVisual_->GetVisualId() );
-    fprintf( stderr, "\tImages (Shared)   \t0x%lx (%lx)\n",
-             nImageDepths_, nSharedImages_ );
-
-    if( nStateOfYield_ || nStateOfSendEvent_ )
-    {
-        fprintf( stderr, "Thread/Signal\n" );
-        fprintf( stderr, "\tNextEvent         \t%d\n", nStateOfYield_ );
-        fprintf( stderr, "\tSendEvent         \t%d\n", nStateOfSendEvent_ );
-    }
-    if( pDispatchStack_ )
-    {
-        fprintf( stderr, "Event\n" );
-        SalXEvent *pEvent = pDispatchStack_;
-        while( pEvent )
-        {
-            PrintEvent( "\t\x08\x08", &pEvent->event_ );
-            pEvent = pEvent->pNext_;
-        }
-    }
 }
 
-void SalDisplay::GetScreenFontResolution( long& rDPIX, long& rDPIY ) const
+void SalDisplay::GetScreenFontResolution( sal_Int32& rDPIX, sal_Int32& rDPIY ) const
 {
+    rDPIX = aResolution_.A();
+    rDPIY = aResolution_.B();
+    if( mbExactResolution )
+        return;
+    
     int   nThreshold;
-
     if (aSize_.Height() <= 600)
         nThreshold =  96;
     else if (aSize_.Height() <= 768)
@@ -3014,9 +2726,6 @@ void SalDisplay::GetScreenFontResolution
     else
         nThreshold = 120; 
     
-    rDPIX = aResolution_.A();
-    rDPIY = aResolution_.B();
-    
     if( rDPIY < nThreshold )
     {
         rDPIX = Divide( rDPIX * nThreshold, rDPIY );
@@ -3097,6 +2806,33 @@ void SalDisplay::InitXinerama()
 #endif
 }
 
+void SalDisplay::registerFrame( SalFrame* pFrame )
+{
+    m_aFrames.push_front( pFrame );
+}
+
+void SalDisplay::deregisterFrame( SalFrame* pFrame )
+{
+    if( osl_acquireMutex( hEventGuard_ ) )
+    {
+        for( std::list< SalUserEvent >::iterator it = m_aUserEvents.begin();
+             it != m_aUserEvents.end(); ++it )
+        {
+            if( it->m_pFrame == pFrame )
+            {
+                std::list< SalUserEvent >::iterator rit = it++;
+                m_aUserEvents.erase( rit );
+            }
+        }
+        osl_releaseMutex( hEventGuard_ );
+    }
+    else
+        DBG_ERROR( "SalDisplay::deregisterFrame !acquireMutex\n" );
+
+    m_aFrames.remove( pFrame );
+}
+
+
 // -=-= SalVisual -=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 SalVisual::SalVisual( const XVisualInfo* pXVI )
@@ -3398,7 +3134,7 @@ SalColormap::SalColormap( SalDisplay *pD
 
 // PseudoColor
 SalColormap::SalColormap( const BitmapPalette &rPalette )
-    : pDisplay_( GetSalData()->GetCurDisp() ),
+    : pDisplay_( GetSalData()->GetDisplay() ),
       hColormap_( None ),
       pVisual_( NULL ),
       nUsed_( rPalette.GetEntryCount() ),
@@ -3423,7 +3159,7 @@ SalColormap::SalColormap( const BitmapPa
 
 // MonoChrome
 SalColormap::SalColormap()
-    : pDisplay_( GetSalData()->GetCurDisp() ),
+    : pDisplay_( GetSalData()->GetDisplay() ),
       hColormap_( None ),
       pVisual_( NULL ),
       nUsed_( 2 ),
@@ -3439,7 +3175,7 @@ SalColormap::SalColormap()
 
 // TrueColor
 SalColormap::SalColormap( USHORT nDepth )
-    : pDisplay_( GetSalData()->GetCurDisp() ),
+    : pDisplay_( GetSalData()->GetDisplay() ),
       hColormap_( None ),
       pPalette_( NULL ),
       nUsed_( 1 << nDepth ),
@@ -3543,7 +3279,7 @@ SalColormap::~SalColormap()
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 void SalColormap::SetPalette( const BitmapPalette &rPalette )
 {
-	if( this != &GetSalData()->GetCurDisp()->GetColormap() )
+	if( this != &GetSalData()->GetDisplay()->GetColormap() )
 	{
 	    nBlackPixel_ = 0xFFFFFFFF;
 		nWhitePixel_ = 0xFFFFFFFF;
Index: vcl/unx/source/app/salimpsound.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/salimpsound.hxx,v
retrieving revision 1.3
retrieving revision 1.5
diff -u -p -u -r1.3 -r1.5
--- vcl/unx/source/app/salimpsound.hxx	4 Jun 2003 11:23:59 -0000	1.3
+++ vcl/unx/source/app/salimpsound.hxx	6 Jan 2004 14:31:37 -0000	1.5
@@ -73,9 +73,7 @@
 #include <unistd.h>
 #endif
 
-#ifdef _USE_NAMESPACE
 namespace vcl_sal {
-#endif
 
 // OSS can only be used on local displays
 
@@ -108,17 +106,17 @@ namespace vcl_sal {
 		static BOOL		startSound( OSSData* pData );
 		static BOOL		startAU( OSSData* pData );
 		static BOOL		startRIFF( OSSData* pData );
-		static int			findChunk( OSSData* pData, char* pChunk );
-		static short int	readLEShort( char* );
-		static int			readLEInt( char* );
-		static ULONG		readBELong( char* );
+		static int			findChunk( OSSData* pData, const char* pChunk );
+		static short int	readLEShort( const char* );
+		static int			readLEInt( const char* );
+		static ULONG		readBELong( const char* );
 
 		DECL_LINK( notifyStopHdl, void* );
 		DECL_LINK( notifyErrorHdl, void* );
 	protected:
 		virtual BOOL isValid();
 	public:
-		OSSSound( ::SalSound* pSalSound );
+		OSSSound( ::X11SalSound* pSalSound );
 		virtual ~OSSSound();
 
 		virtual void play();
@@ -171,17 +169,17 @@ namespace vcl_sal {
 		static BOOL			startSound( DevAudioData* pData );
 		static BOOL			startAU( DevAudioData* pData );
 		static BOOL			startRIFF( DevAudioData* pData );
-		static int			findChunk( DevAudioData* pData, char* pChunk );
-		static short int	readLEShort( char* );
-		static int			readLEInt( char* );
-		static ULONG		readBELong( char* );
+		static int			findChunk( DevAudioData* pData, const char* pChunk );
+		static short int	readLEShort( const char* );
+		static int			readLEInt( const char* );
+		static ULONG		readBELong( const char* );
 
 		DECL_LINK( notifyStopHdl, void* );
 		DECL_LINK( notifyErrorHdl, void* );
 	protected:
 		virtual BOOL isValid();
 	public:
-		DevAudioSound( ::SalSound* pSalSound );
+		DevAudioSound( ::X11SalSound* pSalSound );
 		virtual ~DevAudioSound();
 
 		virtual void play();
@@ -220,7 +218,7 @@ namespace vcl_sal {
 	protected:
 		virtual BOOL isValid();
 	public:
-		RPTPSound( ::SalSound* pSalSound );
+		RPTPSound( ::X11SalSound* pSalSound );
 
 		virtual	~RPTPSound();
 
@@ -252,7 +250,7 @@ namespace vcl_sal {
 	protected:
 		virtual BOOL isValid();
 	public:
-		NASSound( ::SalSound* pSalSound );
+		NASSound( ::X11SalSound* pSalSound );
 
 		virtual	~NASSound();
 
@@ -262,9 +260,6 @@ namespace vcl_sal {
 		virtual void cont();
 	};
 #endif
-
-#ifdef _USE_NAMESPACE
 }
-#endif
 
 #endif
Index: vcl/unx/source/app/salinst.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/salinst.cxx,v
retrieving revision 1.16
retrieving revision 1.22
diff -u -p -u -r1.16 -r1.22
--- vcl/unx/source/app/salinst.cxx	22 Jul 2003 10:12:20 -0000	1.16
+++ vcl/unx/source/app/salinst.cxx	10 May 2004 15:57:05 -0000	1.22
@@ -59,9 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALINST_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -77,11 +74,11 @@
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
 #ifndef _SV_SALWTYPE_HXX
 #include <salwtype.hxx>
@@ -92,25 +89,15 @@
 #ifndef _SV_DTINT_HXX
 #include <dtint.hxx>
 #endif
-#if !defined(_USE_PRINT_EXTENSION_)
 #ifndef _SV_SALPRN_H
 #include <salprn.h>
 #endif
-#endif
 #ifndef _VCL_SM_HXX
 #include <sm.hxx>
 #endif
-// -=-= C++ globals =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-void SalAbort( const XubString& rErrorText )
-{
-	if( !rErrorText.Len() )
-		fprintf( stderr, "Application Error" );
-	else
-		fprintf( stderr, ByteString( rErrorText, gsl_getSystemTextEncoding() ).GetBuffer() );
-	abort();
-}
-
+#ifndef _SV_SALOGL_H
+#include <salogl.h>
+#endif
 
 // -------------------------------------------------------------------------
 //
@@ -156,83 +143,43 @@ sal_Bool SalYieldMutex::tryToAcquire()
 
 //----------------------------------------------------------------------------
 
-void InitSalData()
-{
-	SalData *pSalData = new SalData;
-	SetSalData( pSalData );
-}
-
-void DeInitSalData()
-{
-	SalData *pSalData = GetSalData();
-	delete pSalData;
-	SetSalData( NULL );
-}
-
-void InitSalMain()
-{
-	if (GetSalData())
-	{
-		int argc = 0;
-		GetSalData()->Init( &argc, 0 );
-	}
-}
-
-void DeInitSalMain()
-{
-}
-
-void SetFilterCallback( void* pCallback, void* pInst )
-{
-	SalData* pSalData = GetSalData();
-
-	pSalData->pFirstInstance_->maInstData.mpFilterCallback = pCallback;
-	pSalData->pFirstInstance_->maInstData.mpFilterInst = pInst;
-}
+// -=-= SalInstance =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-SalInstance *CreateSalInstance()
+// plugin factory function
+extern "C" 
 {
-	SalData 	*pSalData = GetSalData();
-	SalInstance *pInst	  = new SalInstance;
+    SalInstance* create_SalInstance()
+    {
+        X11SalInstance* pInstance = new X11SalInstance( new SalYieldMutex() );
 
-	// init instance (only one instance in this version !!!)
-	pSalData->pFirstInstance_ = pInst;
+        // initialize SalData
+        SalData *pSalData = new SalData;
+        SetSalData( pSalData );
+        pSalData->pInstance_ = pInstance;
+        pSalData->Init();
 
-	return pInst;
+        return pInstance;
+    }
 }
 
-void DestroySalInstance( SalInstance *pInst )
+X11SalInstance::~X11SalInstance()
 {
+    // eventually free OpenGL lib
+    X11SalOpenGL::Release();
+    
+    // close session management
     SessionManagerClient::close();
-	SalData *pSalData = GetSalData();
+    // dispose SalDisplay list from SalData
+    // would be done in a static destructor else which is
+    // a little late
 
-	// reset instance (only one instance in this version !!!)
-	if( pSalData->pFirstInstance_ == pInst )
-		pSalData->pFirstInstance_ = NULL;
+	SalData *pSalData = GetSalData();
+    pSalData->deInitNWF();
+	delete pSalData;
+	SetSalData( NULL );
 
-	delete pInst;
-}
-
-// -=-= SalInstance =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalInstance::SalInstance()
-{
-	maInstData.mpFilterCallback 	= NULL;
-	maInstData.mpFilterInst 		= NULL;
-	maInstData.mpEventInst			= NULL;
-	maInstData.mpEventCallback		= NULL;
-	maInstData.mpErrorEventInst		= NULL;
-	maInstData.mpErrorEventCallback	= NULL;
-	maInstData.mpSalYieldMutex		= new SalYieldMutex;
-	maInstData.mpSalYieldMutex->acquire();
-    maInstData.mbPrinterInit		= false;
-}
-
-SalInstance::~SalInstance()
-{
-// #75711# - java is running
-  	maInstData.mpSalYieldMutex->release();
-  	delete maInstData.mpSalYieldMutex;
+  	delete mpSalYieldMutex;
 }
 
 
@@ -284,14 +231,15 @@ Bool ImplPredicateEvent( Display *, XEve
 }
 
 
-BOOL SalInstance::AnyInput(USHORT nType)
+
+bool X11SalInstance::AnyInput(USHORT nType)
 {
 	SalData *pSalData = GetSalData();
-	Display *pDisplay  = pSalData->GetDefDisp()->GetDisplay();
+	Display *pDisplay  = pSalData->GetDisplay()->GetDisplay();
     BOOL bRet = FALSE;
 
     if( (nType & INPUT_TIMER) &&
-        pSalData->GetDefDisp()->GetXLib()->CheckTimeout( false ) )
+        pSalData->GetDisplay()->GetXLib()->CheckTimeout( false ) )
     {
         bRet = TRUE;
     }
@@ -311,20 +259,16 @@ BOOL SalInstance::AnyInput(USHORT nType)
 	return bRet;
 }
 
-#ifdef _VOS_NO_NAMESPACE
-IMutex* SalInstance::GetYieldMutex()
-#else
-vos::IMutex* SalInstance::GetYieldMutex()
-#endif
+vos::IMutex* X11SalInstance::GetYieldMutex()
 {
-	return maInstData.mpSalYieldMutex;
+	return mpSalYieldMutex;
 }
 
 // -----------------------------------------------------------------------
 
-ULONG SalInstance::ReleaseYieldMutex()
+ULONG X11SalInstance::ReleaseYieldMutex()
 {
-	SalYieldMutex* pYieldMutex = maInstData.mpSalYieldMutex;
+	SalYieldMutex* pYieldMutex = mpSalYieldMutex;
 	if ( pYieldMutex->GetThreadId() ==
 		 NAMESPACE_VOS(OThread)::getCurrentIdentifier() )
 	{
@@ -344,9 +288,9 @@ ULONG SalInstance::ReleaseYieldMutex()
 
 // -----------------------------------------------------------------------
 
-void SalInstance::AcquireYieldMutex( ULONG nCount )
+void X11SalInstance::AcquireYieldMutex( ULONG nCount )
 {
-	SalYieldMutex* pYieldMutex = maInstData.mpSalYieldMutex;
+	SalYieldMutex* pYieldMutex = mpSalYieldMutex;
 	while ( nCount )
 	{
 		pYieldMutex->acquire();
@@ -354,25 +298,38 @@ void SalInstance::AcquireYieldMutex( ULO
 	}
 }
 
-void SalInstance::Yield( BOOL bWait )
+void X11SalInstance::Yield( BOOL bWait )
 { GetSalData()->GetLib()->Yield( bWait ); }
 
-void SalInstance::SetEventCallback( void* pInstance, bool(*pCallback)(void*,void*,int) )
+void* X11SalInstance::GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes )
+{
+	static const char* pDisplay = getenv( "DISPLAY" );
+	rReturnedType	= AsciiCString;
+	rReturnedBytes	= pDisplay ? strlen( pDisplay )+1 : 1;
+	return pDisplay ? (void*)pDisplay : (void*)"";
+}
+
+SalFrame *X11SalInstance::CreateFrame( SalFrame *pParent, ULONG nSalFrameStyle )
 {
-	maInstData.mpEventInst		= pInstance;
-	maInstData.mpEventCallback	= pCallback;
+	SalFrame *pFrame = new X11SalFrame( pParent, nSalFrameStyle );
+
+	return pFrame;
 }
 
-void SalInstance::SetErrorEventCallback( void* pInstance, bool(*pCallback)(void*,void*,int) )
+SalFrame* X11SalInstance::CreateChildFrame( SystemParentData* pParentData, ULONG nStyle )
 {
-	maInstData.mpErrorEventInst		= pInstance;
-	maInstData.mpErrorEventCallback	= pCallback;
+	SalFrame* pFrame = new X11SalFrame( NULL, nStyle, pParentData );
+
+	return pFrame;
 }
 
-void* SalInstance::GetConnectionIdentifier( ConnectionIdentifierType& rReturnedType, int& rReturnedBytes )
+void X11SalInstance::DestroyFrame( SalFrame* pFrame )
 {
-	static const char* pDisplay = getenv( "DISPLAY" );
-	rReturnedType	= AsciiCString;
-	rReturnedBytes	= pDisplay ? strlen( pDisplay )+1 : 1;
-	return pDisplay ? (void*)pDisplay : (void*)"";
+	delete pFrame;
 }
+
+SalOpenGL* X11SalInstance::CreateSalOpenGL( SalGraphics* pGraphics )
+{
+    return new X11SalOpenGL( pGraphics );
+}
+
Index: vcl/unx/source/app/salsound2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/salsound2.cxx,v
retrieving revision 1.3
retrieving revision 1.6
diff -u -p -u -r1.3 -r1.6
--- vcl/unx/source/app/salsound2.cxx	27 Mar 2003 17:58:38 -0000	1.3
+++ vcl/unx/source/app/salsound2.cxx	10 May 2004 15:57:17 -0000	1.6
@@ -65,113 +65,103 @@
 
 #include <salunx.h>
 #include <saldata.hxx>
-#include <salframe.hxx>
 #include <saldisp.hxx>
 
-#include <salsound.hxx>
+#include <salsound.h>
 #include <vsound.hxx>
 
 
-#ifdef _USE_NAMESPACE
 using namespace vcl_sal;
-#endif
 
-SalSound::SalSound() :
-		m_pInst( NULL ),
-		m_aPROC( NULL ),
+SalSound* X11SalInstance::CreateSalSound()
+{
+    return new X11SalSound();
+}
+
+X11SalSound::X11SalSound() :
 		m_pVSound( NULL ),
-		m_pFrame( NULL ),
-		m_bLoop( FALSE ),
-		m_bPlaying( FALSE ),
-		m_bPaused( FALSE ),
+		m_bLoop( false ),
+		m_bPlaying( false ),
+		m_bPaused( false ),
 		m_nStartTime( 0 ),
 		m_nPlayTime( 0 )
 {
-	SalDbgAssert( "SalSound::SalSound()\n" );
+	SalDbgAssert( "X11SalSound::X11SalSound()\n" );
 }
 
-SalSound::~SalSound()
+X11SalSound::~X11SalSound()
 {
-	m_aPROC = NULL;
-	SalDbgAssert( "SalSound::~SalSound()\n" );
+	SalDbgAssert( "X11SalSound::~X11SalSound()\n" );
 	if( m_pVSound )
 		delete m_pVSound;
 }
 
-BOOL SalSound::Create()
-{
-	return TRUE;
-}
-
-void SalSound::Release()
+bool X11SalSound::IsValid()
 {
+	return true;
 }
 
-BOOL SalSound::IsValid()
-{
-	return TRUE;
-}
-
-BOOL SalSound::Init( SalFrame* pFrame,
-					 const String& rSoundName,
-					 ULONG& rSoundLen )
+bool X11SalSound::Init( const String& rSoundName, ULONG& rSoundLen )
 {
 	if( m_pVSound )
 		delete m_pVSound;
 
-	m_aSoundFile = ByteString( rSoundName, gsl_getSystemTextEncoding() );
-	SalDbgAssert( "SalSound::Init( %p, \"%s\", %d )\n",
-				  pFrame, m_aSoundFile.GetBuffer(), rSoundLen );
-	m_pFrame = pFrame;
-	if( ! m_pFrame )
-		m_pFrame = GetSalData()->pFirstFrame_;
+	m_aSoundFile = ByteString( rSoundName, osl_getThreadTextEncoding() );
+	SalDbgAssert( "X11SalSound::Init( \"%s\", %d )\n", m_aSoundFile.GetBuffer(), rSoundLen );
 
 	m_pVSound = ( !m_aSoundFile.Len() || access( m_aSoundFile.GetBuffer(), R_OK ) ) ? NULL : VSound::createVSound( this );
 
 	return m_pVSound ? TRUE : FALSE;
 }
 
-BOOL SalSound::Init( SalFrame* pFrame,
-					 const BYTE* pSound,
-					 ULONG nDataLen,
-					 ULONG& rSoundLen )
+void X11SalSound::Play( ULONG nStartTime, ULONG nPlayTime, bool bLoop )
 {
-	return FALSE;
-}
-
-void SalSound::Play( ULONG nStartTime, ULONG nPlayTime, BOOL bLoop )
-{
-	SalDbgAssert( "SalSound::Play( %d, %d, %s )\n", nStartTime, nPlayTime, bLoop ? "TRUE" : "FALSE" );
+	SalDbgAssert( "X11SalSound::Play( %d, %d, %s )\n", nStartTime, nPlayTime, bLoop ? "TRUE" : "FALSE" );
 	if( m_bPlaying && m_pVSound )
 		m_pVSound->stop();
-
+    
 	m_bLoop			= bLoop;
 	m_nStartTime	= nStartTime;
 	m_nPlayTime		= nPlayTime;
-
+    
 	if( m_pVSound )
 		m_pVSound->play();
 }
 
-void SalSound::Stop()
+void X11SalSound::Stop()
 {
-	SalDbgAssert( "SalSound::Stop()\n" );
+	SalDbgAssert( "X11SalSound::Stop()\n" );
 	if( m_bPlaying && m_pVSound )
 		m_pVSound->stop();
 }
 
-void SalSound::Pause()
+void X11SalSound::Pause()
 {
 	if( m_bPlaying && m_pVSound )
 		m_pVSound->pause();
 }
 
-void SalSound::Continue()
+void X11SalSound::Continue()
 {
 	if( m_bPaused && m_pVSound )
 		m_pVSound->cont();
 }
 
+bool X11SalSound::IsLoopMode() const
+{
+    return m_bLoop;
+}
+
+bool X11SalSound::IsPlaying() const
+{
+    return m_bPlaying;
+}
+
+bool X11SalSound::IsPaused() const
+{
+    return m_bPaused;
+}
+
 // --------------------------------------------------
 
 #include <salimpsound.hxx>
@@ -210,18 +200,18 @@ void VSound::releaseBuffer()
 }
 
 
-VSound* VSound::createVSound( SalSound* pSalSound )
+VSound* VSound::createVSound( X11SalSound* pX11SalSound )
 {
 	struct stat aStat;
-	if( stat( pSalSound->m_aSoundFile.GetBuffer(), & aStat ) )
+	if( stat( pX11SalSound->m_aSoundFile.GetBuffer(), & aStat ) )
 		return NULL;
 
 	VSound* pRet = NULL;
 
 #ifdef USE_OSS
-	if( ! pSalSound->m_pFrame || pSalSound->m_pFrame->maFrameData.GetDisplay()->IsLocal() )
+	if( GetSalData()->GetDisplay()->IsLocal() )
 	{
-		pRet = new OSSSound( pSalSound );
+		pRet = new OSSSound( pX11SalSound );
 		if( pRet && ! pRet->isValid() )
 		{
 			delete pRet;
@@ -233,9 +223,9 @@ VSound* VSound::createVSound( SalSound* 
 #endif
 
 #ifdef USE_DEVAUDIO
-	if( ! pSalSound->m_pFrame || pSalSound->m_pFrame->maFrameData.GetDisplay()->IsLocal() )
+	if( GetSalData()->GetDisplay()->IsLocal() )
 	{
-		pRet = new DevAudioSound( pSalSound );
+		pRet = new DevAudioSound( pX11SalSound );
 		if( pRet && ! pRet->isValid() )
 		{
 			delete pRet;
@@ -249,7 +239,7 @@ VSound* VSound::createVSound( SalSound* 
 #ifdef USE_NAS
 	if( ! pRet )
 	{
-		pRet = new NASSound( pSalSound );
+		pRet = new NASSound( pX11SalSound );
 		if( pRet && ! pRet->isValid() )
 		{
 			delete pRet;
@@ -262,7 +252,7 @@ VSound* VSound::createVSound( SalSound* 
 
 	if( ! pRet )
 	{
-		pRet = new RPTPSound( pSalSound );
+		pRet = new RPTPSound( pX11SalSound );
 		if( pRet && ! pRet->isValid() )
 		{
 			delete pRet;
@@ -275,47 +265,38 @@ VSound* VSound::createVSound( SalSound* 
 	return pRet;
 }
 
-void SalSound::changeStateStop()
+void X11SalSound::changeStateStop()
 {
-	SalDbgAssert( "SalSound(%p)::changeStateStop()\n", this );
+	SalDbgAssert( "X11SalSound(%p)::changeStateStop()\n", this );
 
 	m_bPlaying	= FALSE;
 	m_bPaused 	= FALSE;
 
-	if( m_aPROC )
-		m_aPROC( m_pInst, SOUND_NOTIFY_SUCCESS, SOUNDERR_SUCCESS );
+    CallNotifyProc( SOUND_NOTIFY_SUCCESS, SOUNDERR_SUCCESS );
 }
 
-void SalSound::changeStatePause()
+void X11SalSound::changeStatePause()
 {
-	SalDbgAssert( "SalSound(%p)::changeStatePause()\n", this );
+	SalDbgAssert( "X11SalSound(%p)::changeStatePause()\n", this );
 
 	m_bPlaying	= TRUE;
 	m_bPaused	= TRUE;
 
-	if( m_aPROC )
-		m_aPROC( m_pInst, SOUND_NOTIFY_SUCCESS, SOUNDERR_SUCCESS );
+    CallNotifyProc( SOUND_NOTIFY_SUCCESS, SOUNDERR_SUCCESS );
 }
 
-void SalSound::changeStateCont()
+void X11SalSound::changeStateCont()
 {
-	SalDbgAssert( "SalSound(%p)::changeStateCont()\n", this );
+	SalDbgAssert( "X11SalSound(%p)::changeStateCont()\n", this );
 
 	m_bPlaying	= TRUE;
 	m_bPlaying	= FALSE;
-	if( m_aPROC )
-		m_aPROC( m_pInst, SOUND_NOTIFY_SUCCESS, SOUNDERR_SUCCESS );
-}
 
-void SalSound::setError( ULONG nError )
-{
-	if( m_aPROC )
-		m_aPROC( m_pInst, SOUND_NOTIFY_ERROR, nError );
+    CallNotifyProc( SOUND_NOTIFY_SUCCESS, SOUNDERR_SUCCESS );
 }
 
-void SalSound::SetNotifyProc( void* pInst, SALSOUNDPROC pProc )
+void X11SalSound::setError( ULONG nError )
 {
-	SalDbgAssert( "SalSound::SetNotifyProc( %p, %p )\n", pInst, pProc );
-	m_pInst = pInst;
-	m_aPROC = pProc;
+    CallNotifyProc( SOUND_NOTIFY_ERROR, nError );
 }
+
Index: vcl/unx/source/app/salsys.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/salsys.cxx,v
retrieving revision 1.7
retrieving revision 1.10
diff -u -p -u -r1.7 -r1.10
--- vcl/unx/source/app/salsys.cxx	15 Apr 2003 16:08:33 -0000	1.7
+++ vcl/unx/source/app/salsys.cxx	20 Feb 2004 08:58:32 -0000	1.10
@@ -59,51 +59,30 @@
  *
  ************************************************************************/
 
-#include <salsys.hxx>
-#include <stacktrace.hxx>
-
-#include <stdio.h>
-
 #include <salunx.h>
-#include <saldisp.hxx>
+#include <salsys.hxx>
 #include <dtint.hxx>
 #include <msgbox.hxx>
 #include <button.hxx>
 #include <svdata.hxx>
+#include <salinst.h>
+#include <saldisp.hxx>
+#include <salsys.h>
+#include <cstdio>
 
-// -----------------------------------------------------------------------
 
-String GetSalSummarySystemInfos( ULONG nFlags )
+SalSystem* X11SalInstance::CreateSalSystem()
 {
-	sal_PostMortem aPostMortem;
+    return new X11SalSystem();
+}
+
+// -----------------------------------------------------------------------
 
-	/*
-	 *	unimplemented flags:
-	 *	SALSYSTEM_GETSYSTEMINFO_MODULES
-	 *	SALSYSTEM_GETSYSTEMINFO_MOUSEINFO
-	 *	SALSYSTEM_GETSYSTEMINFO_SYSTEMDIRS
-	 *	SALSYSTEM_GETSYSTEMINFO_LOCALVOLUMES
-	 */
-
-	ByteString aRet;
-	if( nFlags & SALSYSTEM_GETSYSTEMINFO_SYSTEMVERSION )
-		aRet += aPostMortem.getSystemInfo();
-	if( nFlags & SALSYSTEM_GETSYSTEMINFO_CPUTYPE )
-		aRet += aPostMortem.getProcessorInfo();
-	if( nFlags & SALSYSTEM_GETSYSTEMINFO_MEMORYINFO )
-		aRet += aPostMortem.getMemoryInfo();
-	if( nFlags & SALSYSTEM_GETSYSTEMINFO_STACK )
-		aRet += aPostMortem.getStackTrace();
-	if( nFlags & SALSYSTEM_GETSYSTEMINFO_GRAPHICSSYSTEM )
-		aRet += aPostMortem.getGraphicsSystem();
-
-#if OSL_DEBUG_LEVEL > 1
-	fprintf( stderr, "SalSystem::GetSummarySystemInfos() =\n%s", aRet.GetBuffer() );
-#endif
-	return String( aRet, RTL_TEXTENCODING_ISO_8859_1 );
+X11SalSystem::~X11SalSystem()
+{
 }
 
-bool GetSalSystemDisplayInfo( System::DisplayInfo& rInfo )
+bool X11SalSystem::GetSalSystemDisplayInfo( DisplayInfo& rInfo )
 {
     bool bSuccess = false;
     Display* pDisplay = XOpenDisplay( NULL );
@@ -128,7 +107,7 @@ bool GetSalSystemDisplayInfo( System::Di
     return bSuccess;
 }
 
-int ImplShowNativeDialog( const String& rTitle, const String& rMessage, const std::list< String >& rButtons, int nDefButton )
+int X11SalSystem::ShowNativeDialog( const String& rTitle, const String& rMessage, const std::list< String >& rButtons, int nDefButton )
 {
     int nRet = -1;
 
@@ -136,57 +115,19 @@ int ImplShowNativeDialog( const String& 
     if( pSVData->mpIntroWindow )
         pSVData->mpIntroWindow->Hide();
 
-    DtIntegrator* pIntegrator = DtIntegrator::CreateDtIntegrator( NULL );
-    if( pIntegrator->GetDtType() == DtGNOME )
-    {
-        ByteString aCmdLine( "msgbox-gnome ");
-        int nButton = 0;
-        for( std::list< String >::const_iterator it = rButtons.begin(); it != rButtons.end(); ++it )
-        {
-            if( nButton == nDefButton )
-                aCmdLine.Append( "-defaultbutton" );
-            else
-                aCmdLine.Append( "-button" );
-            nButton++;
-            aCmdLine.Append( " \"" );
-            aCmdLine.Append( ByteString( *it, RTL_TEXTENCODING_UTF8 ) );
-            aCmdLine.Append( "\" " );
-        }
-        aCmdLine.Append( " \"" );
-        aCmdLine.Append( ByteString( rTitle, RTL_TEXTENCODING_UTF8 ) );
-        aCmdLine.Append( "\" \"" );
-        aCmdLine.Append( ByteString( rMessage, RTL_TEXTENCODING_UTF8 ) );
-        aCmdLine.Append( "\" 2>/dev/null" );
-
-        FILE* fp = popen( aCmdLine.GetBuffer(), "r" );
-        if( fp )
-        {
-            ByteString aAnswer;
-            char buf[16];
-            while( fgets( buf, sizeof( buf ), fp ) )
-            {
-                aAnswer.Append( buf );
-            }
-            pclose( fp );
-            nRet = aAnswer.ToInt32();
-        }
-    }
-    else // default to a VCL dialogue since we do not have a native implementation
-    {
-        WarningBox aWarn( NULL, WB_STDWORK, rMessage );
-        aWarn.SetText( rTitle );
-        aWarn.Clear();
-
-        USHORT nButton = 0;
-        for( std::list< String >::const_iterator it = rButtons.begin(); it != rButtons.end(); ++it )
-        {
+	WarningBox aWarn( NULL, WB_STDWORK, rMessage );
+	aWarn.SetText( rTitle );
+	aWarn.Clear();
+
+	USHORT nButton = 0;
+	for( std::list< String >::const_iterator it = rButtons.begin(); it != rButtons.end(); ++it )
+	{
             aWarn.AddButton( *it, nButton+1, nButton == (USHORT)nDefButton ? BUTTONDIALOG_DEFBUTTON : 0 );
             nButton++;
-        }
-        aWarn.SetFocusButton( (USHORT)nDefButton+1 );
-
-        nRet = ((int)aWarn.Execute()) - 1;
-    }
+	}
+	aWarn.SetFocusButton( (USHORT)nDefButton+1 );
+	
+	nRet = ((int)aWarn.Execute()) - 1;
 
     // normalize behaviour, actually this should never happen
     if( nRet < -1 || nRet >= rButtons.size() )
@@ -195,7 +136,7 @@ int ImplShowNativeDialog( const String& 
     return nRet;
 }
 
-int ImplShowNativeMessageBox(const String& rTitle, const String& rMessage, int nButtonCombination, int nDefaultButton)
+int X11SalSystem::ShowNativeMessageBox(const String& rTitle, const String& rMessage, int nButtonCombination, int nDefaultButton)
 {
     int nDefButton = 0;
     std::list< String > aButtons;
@@ -245,7 +186,7 @@ int ImplShowNativeMessageBox(const Strin
             case SALSYSTEM_SHOWNATIVEMSGBOX_BTN_IGNORE: nDefButton = 2;break;
         }
     }
-    int nResult = ImplShowNativeDialog( rTitle, rMessage, aButtons, nDefButton );
+    int nResult = ShowNativeDialog( rTitle, rMessage, aButtons, nDefButton );
 
     return nResult != -1 ? nButtonIds[ nResult ] : 0;
 }
Index: vcl/unx/source/app/saltimer.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/saltimer.cxx,v
retrieving revision 1.4.136.1
retrieving revision 1.8
diff -u -p -u -r1.4.136.1 -r1.8
--- vcl/unx/source/app/saltimer.cxx	15 Aug 2003 11:26:14 -0000	1.4.136.1
+++ vcl/unx/source/app/saltimer.cxx	10 May 2004 15:57:39 -0000	1.8
@@ -59,9 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALTIMER_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #include <stdio.h>
 #if defined(IRIX)
 #include <ctime>
@@ -79,28 +76,32 @@
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
-#ifndef _SV_SALTIMER_HXX
-#include <saltimer.hxx>
+#ifndef _SV_SALTIMER_H
+#include <saltimer.h>
+#endif
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
 
 // -=-= SalData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 void SalData::Timeout() const
 {
-	if( pTimerProc_ )
-		pTimerProc_();
+    ImplSVData* pSVData = ImplGetSVData();
+    if( pSVData->mpSalTimer )
+        pSVData->mpSalTimer->CallCallback();
 }
 
 // -=-= SalXLib =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline void SalXLib::StopTimer()
+void SalXLib::StopTimer()
 {
 	Timeout_.tv_sec		= 0;
 	Timeout_.tv_usec	= 0;
 	nTimeoutMS_			= 0;
 }
 
-inline void SalXLib::StartTimer( ULONG nMS )
+void SalXLib::StartTimer( ULONG nMS )
 {
 	timeval Timeout (Timeout_); // previous timeout.
 	gettimeofday (&Timeout_, 0);
@@ -117,16 +118,21 @@ inline void SalXLib::StartTimer( ULONG n
 
 // -=-= SalTimer -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-/* static */ void SalTimer::SetCallback( SALTIMERPROC pProc )
-{ GetSalData()->SetCallback( pProc ); }
+SalTimer* X11SalInstance::CreateSalTimer()
+{
+    return new X11SalTimer();
+}
 
+X11SalTimer::~X11SalTimer()
+{
+}
 
-/* static */ void SalTimer::Stop()
+void X11SalTimer::Stop()
 {
 	GetSalData()->GetLib()->StopTimer();
 }
 
-/* static */ void SalTimer::Start( ULONG nMS )
+void X11SalTimer::Start( ULONG nMS )
 {
 	GetSalData()->GetLib()->StartTimer( nMS );
 }
Index: vcl/unx/source/app/sm.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/sm.cxx,v
retrieving revision 1.13.12.3
retrieving revision 1.18
diff -u -p -u -r1.13.12.3 -r1.18
--- vcl/unx/source/app/sm.cxx	3 May 2004 16:44:39 -0000	1.13.12.3
+++ vcl/unx/source/app/sm.cxx	18 May 2004 13:52:10 -0000	1.18
@@ -60,6 +60,8 @@
  ************************************************************************/
 #include <string.h>
 #include <unistd.h>
+#include <sys/poll.h>
+#include <fcntl.h>
 
 // [ed] 6/15/02 Use the poll replacement on OS X
 #ifdef MACOSX
@@ -67,8 +69,6 @@
 #else
 #include <sys/poll.h>
 #endif
-
-#include <fcntl.h>
 #include <stdio.h>
 
 #include <osl/process.h>
@@ -87,14 +87,14 @@
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
 #ifndef _SV_SVAPP_HXX
 #include <svapp.hxx>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
 
 #include <osl/conditn.h>
@@ -121,7 +121,7 @@ inline void SMprintf( const char* pForma
 
 static IceSalSession* pOneInstance = NULL;
 
-SalSession* SalInstance::CreateSalSession()
+SalSession* X11SalInstance::CreateSalSession()
 {
     if( ! pOneInstance )
         pOneInstance = new IceSalSession();
@@ -132,7 +132,7 @@ SalSession* SalInstance::CreateSalSessio
  *  class IceSalSession
  */
 
-static SalFrame* pOldStyleSaveFrame = NULL;
+static X11SalFrame* pOldStyleSaveFrame = NULL;
 
 IceSalSession::IceSalSession()
 {
@@ -162,7 +162,10 @@ void IceSalSession::saveDone()
 {
     SessionManagerClient::saveDone();
     if( pOldStyleSaveFrame )
-        SalFrameData::SaveYourselfDone( pOldStyleSaveFrame );
+    {
+        // note: does nothing if not running in generic plugin
+        X11SalFrame::SaveYourselfDone( pOldStyleSaveFrame );
+    }
 }
 
 bool IceSalSession::cancelShutdown()
@@ -175,7 +178,7 @@ void IceSalSession::handleOldX11SaveYour
     // do this only once
     if( ! pOldStyleSaveFrame )
     {
-        pOldStyleSaveFrame = pFrame;
+        pOldStyleSaveFrame = static_cast<X11SalFrame*>(pFrame);
         if( pOneInstance )
         {
             SalSessionSaveRequestEvent aEvent( true, false );
@@ -314,14 +317,6 @@ IMPL_STATIC_LINK( SessionManagerClient, 
     return 0;
 }
 
-IMPL_STATIC_LINK( SessionManagerClient, ShutDownHdl, void*, pDummy )
-{
-    SMprintf( GetSalData()->pFirstFrame_ ? "shutdown on first frame\n" : "shutdown event but no frame\n" );
-    if( GetSalData()->pFirstFrame_ )
-        GetSalData()->pFirstFrame_->maFrameData.ShutDown();
-    return 0;
-}
-
 IMPL_STATIC_LINK( SessionManagerClient, ShutDownCancelHdl, void*, pDummy )
 {
     SMprintf( "shutdown cancel\n" );
@@ -361,6 +356,15 @@ void SessionManagerClient::SaveYourselfP
 #endif
 }
 
+IMPL_STATIC_LINK( SessionManagerClient, ShutDownHdl, void*, pDummy )
+{
+    const std::list< SalFrame* >& rFrames = GetSalData()->GetDisplay()->getFrames();
+    SMprintf( rFrames.begin() != rFrames.end() ? "shutdown on first frame\n" : "shutdown event but no frame\n" );
+    if( rFrames.begin() != rFrames.end() )
+        rFrames.front()->CallCallback( SALEVENT_SHUTDOWN, 0 );
+    return 0;
+}
+
 void SessionManagerClient::DieProc(
 	SmcConn connection,
 	SmPointer client_data
@@ -459,7 +463,7 @@ void SessionManagerClient::open()
         pClientID = NULL;
         ICEConnectionObserver::unlock();
 
-        SalDisplay* pDisp = GetSalData()->GetDefDisp();
+        SalDisplay* pDisp = GetSalData()->GetDisplay();
         if( pDisp->GetDrawable() && aClientID.Len() )
         {
             XChangeProperty( pDisp->GetDisplay(),
@@ -717,6 +721,6 @@ void ICEConnectionObserver::ICEWatchProc
     SMprintf( "ICE connection on %d %s\n",
               IceConnectionNumber( connection ),
               opening ? "inserted" : "removed" );
-    SMprintf( "Display connection is %d\n", ConnectionNumber( GetSalData()->GetDefDisp()->GetDisplay() ) );
+    SMprintf( "Display connection is %d\n", ConnectionNumber( GetSalData()->GetDisplay()->GetDisplay() ) );
 #endif
 }
Index: vcl/unx/source/app/soicon.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/soicon.cxx,v
retrieving revision 1.11
retrieving revision 1.15
diff -u -p -u -r1.11 -r1.15
--- vcl/unx/source/app/soicon.cxx	11 Apr 2003 17:32:54 -0000	1.11
+++ vcl/unx/source/app/soicon.cxx	30 Mar 2004 13:43:24 -0000	1.15
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SOICON_CXX
-
 #include <dlfcn.h>
 #include <stdio.h>
 #include <string.h>
@@ -98,6 +96,12 @@
 #ifndef _SV_SOICON_HXX
 #include <soicon.hxx>
 #endif
+#ifndef _SV_SALINST_HXX
+#include <salinst.hxx>
+#endif
+#ifndef _SV_SVDATA_HXX
+#include <svdata.hxx>
+#endif
 
 #include <tools/stream.hxx>
 #include <tools/string.hxx>
@@ -115,7 +119,7 @@ static void ConvertXpm( SalDisplay* pDis
 	int nWidth, nHeight, nColors, nCharsPerPixel;
 	XColor *pColors;
 	char *pColorAlias;
-	int nElement = 0,nColor = 0,i,nX,nY;
+	int nElement = 0,nColor = 0,nX,nY;
 	char pColorString[256];
 	BOOL bTransparent = FALSE;
 
@@ -145,7 +149,7 @@ static void ConvertXpm( SalDisplay* pDis
 			}
 		}
 	}
-	nColors = nColor+1;
+	nColors = nColor;
 
 	aPixmap = XCreatePixmap( pDisplay->GetDisplay(),
 								pDisplay->GetRootWindow(),
@@ -236,7 +240,7 @@ BOOL SelectAppIconPixmap( SalDisplay *pD
     // call custom function to read icon
     char customIconFn[256];
 
-    sprintf( customIconFn, "%s%d", VCL_CUSTOM_ICON_BASE, nIcon );
+    snprintf( customIconFn, sizeof(customIconFn), "%s%d", VCL_CUSTOM_ICON_BASE, nIcon );
 	static void* pAppHdl = dlopen( NULL, RTLD_LAZY );
     if ( ( pCustomIcon = ( VCL_CUSTOM_ICON_FN* ) dlsym( pAppHdl, customIconFn ) )
              != NULL )
@@ -315,9 +319,7 @@ static void NextLine( SvStream& rFile, B
 BOOL ReadXBMFile( Display* pDisplay, const String& rFile, SalBitmap*& rpBmp )
 {
 	SvFileStream	aFile( rFile, STREAM_READ );
-	int	   			nBytes = 0;
 	int				nWidth= -1, nHeight=-1;
-	BOOL			bSuccess = FALSE;
 
 	rpBmp = NULL;
 
@@ -351,7 +353,7 @@ BOOL ReadXBMFile( Display* pDisplay, con
 	aPal[ 0 ] = BitmapColor( 0, 0, 0 );
 	aPal[ 1 ] = BitmapColor( 0xff, 0xff, 0xff );
 
-	rpBmp = new SalBitmap;
+	rpBmp = ImplGetSVData()->mpDefInst->CreateSalBitmap();
 	rpBmp->Create( aSize, 1, aPal );
 
 	BitmapBuffer*	pBmpBuf = rpBmp->AcquireBuffer( FALSE );
@@ -408,10 +410,9 @@ BOOL ReadXPMFile( Display* pDisplay, con
 	SvFileStream	aFile( rFile, STREAM_READ );
 	ByteString		aColorName, aColorString, aLine;
 	int				nWidth, nHeight, nColors, nCharsPerPixel;
-	int				nElement = 0,nColor = 0, i, nX, nY;
+	int				nColor = 0,  nX, nY;
 	UINT8*			pColorTable;
 	char*			pColorAlias;
-	BOOL			bTransparent = FALSE;
 	BOOL			bXpm2Mode = FALSE;
 
 	rpBmp = rpMsk = NULL;
@@ -454,13 +455,13 @@ BOOL ReadXPMFile( Display* pDisplay, con
 
 		if( !!aBmp )
 		{
-			rpBmp = new SalBitmap;
+			rpBmp = ImplGetSVData()->mpDefInst->CreateSalBitmap();
 			rpBmp->Create( *aBmp.ImplGetImpBitmap()->ImplGetSalBitmap() );
 		}
 
 		if( !!aMsk )
 		{
-			rpMsk = new SalBitmap;
+			rpMsk = ImplGetSVData()->mpDefInst->CreateSalBitmap();
 			rpMsk->Create( *aMsk.ImplGetImpBitmap()->ImplGetSalBitmap() );
 		}
 
@@ -514,11 +515,11 @@ BOOL ReadXPMFile( Display* pDisplay, con
 	aPal[ 0 ] = BitmapColor( 0, 0, 0 );
 	aPal[ 1 ] = BitmapColor( 0xff, 0xff, 0xff );
 
-	rpBmp = new SalBitmap;
+	rpBmp = ImplGetSVData()->mpDefInst->CreateSalBitmap();
 	rpBmp->Create( aSize, 24, aPal );
 	BitmapBuffer* pBmpBuf = rpBmp->AcquireBuffer( FALSE );
 
-	rpMsk = new SalBitmap;
+	rpMsk = ImplGetSVData()->mpDefInst->CreateSalBitmap();
 	rpMsk->Create( aSize, 1, aPal );
 	BitmapBuffer* pMskBuf = rpMsk->AcquireBuffer( FALSE );
 
Index: vcl/unx/source/app/sunconvert.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/sunconvert.cxx,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/unx/source/app/sunconvert.cxx	18 Sep 2000 17:05:42 -0000	1.1.1.1
+++ vcl/unx/source/app/sunconvert.cxx	6 Jan 2004 14:35:26 -0000	1.2
@@ -429,7 +429,7 @@ fmult(
 	int		srn)
 {
 	short		anmag, anexp, anmant;
-	short		wanexp, wanmag, wanmant;
+	short		wanexp, wanmant;
 	short		retval;
 
 	anmag = (an > 0) ? an : ((-an) & 0x1FFF);
@@ -635,12 +635,11 @@ update(
 	struct g72x_state *state_ptr)	/* coder state pointer */
 {
 	int		cnt;
-	short		mag, exp, mant;	/* Adaptive predictor, FLOAT A */
+	short		mag, exp;	/* Adaptive predictor, FLOAT A */
 	short		a2p;		/* LIMC */
 	short		a1ul;		/* UPA1 */
-	short		ua2, pks1;	/* UPA2 */
-	short		uga2a, fa1;
-	short		uga2b;
+	short		pks1;	/* UPA2 */
+	short		fa1;
 	char		tr;		/* tone/transition detector */
 	short		ylint, thr2, dqthr;
 	short  		ylfrac, thr1;
@@ -1319,7 +1318,7 @@ g723_40_decoder(
 	struct g72x_state *state_ptr)
 {
 	short		sezi, sei, sez, se;	/* ACCUM */
-	short		y, dif;			/* MIX */
+	short		y;			/* MIX */
 	short		sr;			/* ADDB */
 	short		dq;
 	short		dqsez;
Index: vcl/unx/source/app/vsound.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/vsound.hxx,v
retrieving revision 1.4
retrieving revision 1.7
diff -u -p -u -r1.4 -r1.7
--- vcl/unx/source/app/vsound.hxx	4 Jun 2003 11:24:09 -0000	1.4
+++ vcl/unx/source/app/vsound.hxx	17 Mar 2004 10:07:04 -0000	1.7
@@ -73,26 +73,20 @@
 #define USE_NAS
 #endif
 
-#if STLPORT_VERSION>=321
 #include <cstdarg>
-#endif
-
 #include <sys/stat.h>
-
 #include <tools/string.hxx>
 
-class SalSound;
+class X11SalSound;
 
-#ifdef _USE_NAMESPACE
 namespace vcl_sal {
-#endif
 	class VSound
 	{
 	protected:
-		VSound( ::SalSound* pSound ) : m_pSalSound( pSound ), m_pBuffer( NULL ) {}
+		VSound( ::X11SalSound* pSound ) : m_pSalSound( pSound ), m_pBuffer( NULL ) {}
 
 		// instance data
-		::SalSound*			m_pSalSound;
+		::X11SalSound*			m_pSalSound;
 		// pointer to mmaped file
 		char*		m_pBuffer;
 		struct stat m_aStat;
@@ -109,7 +103,7 @@ namespace vcl_sal {
 		virtual void pause() = 0;
 		virtual void cont() = 0;
 
-		static VSound* createVSound( SalSound* );
+		static VSound* createVSound( X11SalSound* );
 	};
 
 	// a class to convert bytestreams from one codec to another
@@ -131,9 +125,7 @@ namespace vcl_sal {
 		static AudioConverter* createSwapINT16Converter();
 	};
 
-#ifdef _USE_NAMESPACE
 }
-#endif
 
 #if OSL_DEBUG_LEVEL > 1
 #include <stdarg.h>
@@ -141,7 +133,7 @@ namespace vcl_sal {
 inline void SalDbgAssert( const char* pFmt, ... )
 {
 	va_list ap;
-	va_start( ap, &pFmt );
+	va_start( ap, pFmt );
 	vfprintf( stderr, pFmt, ap );
 	va_end( ap );
 }
Index: vcl/unx/source/app/wmadaptor.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/wmadaptor.cxx,v
retrieving revision 1.42.46.4
retrieving revision 1.48
diff -u -p -u -r1.42.46.4 -r1.48
--- vcl/unx/source/app/wmadaptor.cxx	28 Jan 2004 15:24:27 -0000	1.42.46.4
+++ vcl/unx/source/app/wmadaptor.cxx	20 Feb 2004 08:58:46 -0000	1.48
@@ -72,8 +72,11 @@
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
+#endif
+#ifndef _SV_SYSDATA_HXX
+#include <sysdata.hxx>
 #endif
 #ifndef _SV_SALGGDI_HXX
 #include <salgdi.hxx>
@@ -102,38 +105,38 @@ namespace vcl_sal {
 
 class NetWMAdaptor : public WMAdaptor
 {
-    void setNetWMState( SalFrame* pFrame ) const;
+    void setNetWMState( X11SalFrame* pFrame ) const;
     void initAtoms();
     virtual bool isValid() const;
 public:
     NetWMAdaptor( SalDisplay* );
     virtual ~NetWMAdaptor();
 
-    virtual void setWMName( SalFrame* pFrame, const String& rWMName ) const;
-    virtual void maximizeFrame( SalFrame* pFrame, bool bHorizontal = true, bool bVertical = true ) const;
-    virtual void shade( SalFrame* pFrame, bool bToShaded ) const;
-    virtual void setFrameTypeAndDecoration( SalFrame* pFrame, WMWindowType eType, int nDecorationFlags, SalFrame* pTransientFrame = NULL ) const;
+    virtual void setWMName( X11SalFrame* pFrame, const String& rWMName ) const;
+    virtual void maximizeFrame( X11SalFrame* pFrame, bool bHorizontal = true, bool bVertical = true ) const;
+    virtual void shade( X11SalFrame* pFrame, bool bToShaded ) const;
+    virtual void setFrameTypeAndDecoration( X11SalFrame* pFrame, WMWindowType eType, int nDecorationFlags, X11SalFrame* pTransientFrame = NULL ) const;
     virtual bool supportsICCCMPos() const;
-    virtual void enableAlwaysOnTop( SalFrame* pFrame, bool bEnable ) const;
-    virtual int handlePropertyNotify( SalFrame* pFrame, XPropertyEvent* pEvent ) const;
-    virtual void showFullScreen( SalFrame* pFrame, bool bFullScreen ) const;
+    virtual void enableAlwaysOnTop( X11SalFrame* pFrame, bool bEnable ) const;
+    virtual int handlePropertyNotify( X11SalFrame* pFrame, XPropertyEvent* pEvent ) const;
+    virtual void showFullScreen( X11SalFrame* pFrame, bool bFullScreen ) const;
 };
 
 class GnomeWMAdaptor : public WMAdaptor
 {
     bool m_bValid;
 
-    void setGnomeWMState( SalFrame* pFrame ) const;
+    void setGnomeWMState( X11SalFrame* pFrame ) const;
     void initAtoms();
     virtual bool isValid() const;
 public:
     GnomeWMAdaptor( SalDisplay * );
     virtual ~GnomeWMAdaptor();
 
-    virtual void maximizeFrame( SalFrame* pFrame, bool bHorizontal = true, bool bVertical = true ) const;
-    virtual void shade( SalFrame* pFrame, bool bToShaded ) const;
-    virtual void enableAlwaysOnTop( SalFrame* pFrame, bool bEnable ) const;
-    virtual int handlePropertyNotify( SalFrame* pFrame, XPropertyEvent* pEvent ) const;
+    virtual void maximizeFrame( X11SalFrame* pFrame, bool bHorizontal = true, bool bVertical = true ) const;
+    virtual void shade( X11SalFrame* pFrame, bool bToShaded ) const;
+    virtual void enableAlwaysOnTop( X11SalFrame* pFrame, bool bEnable ) const;
+    virtual int handlePropertyNotify( X11SalFrame* pFrame, XPropertyEvent* pEvent ) const;
 };
 
 }
@@ -312,11 +315,7 @@ WMAdaptor::WMAdaptor( SalDisplay* pDispl
                                        &pProperty) == 0
                    && nItems))
         {
-#if NeedWidePrototypes
-            if (*(sal_Int32*)pProperty)
-#else
             if (*pProperty)
-#endif
             {
                 m_aWMName = String(RTL_CONSTASCII_USTRINGPARAM("Dtwm"));
                 m_bTransientBehaviour = false;
@@ -625,9 +624,8 @@ GnomeWMAdaptor::GnomeWMAdaptor( SalDispl
     unsigned long		nItems		= 0;
     unsigned long		nBytesLeft	= 0;
     unsigned char*	pProperty	= NULL;
-    bool				bGnomeWM	= false;
 
-    initAtoms();
+	initAtoms();
 
     // check for GnomeWM
     if( m_aWMAtoms[ WIN_SUPPORTING_WM_CHECK ] && m_aWMAtoms[ WIN_PROTOCOLS ] )
@@ -1005,7 +1003,7 @@ void GnomeWMAdaptor::initAtoms()
  *       WM_ICON_NAME
  */
 
-void WMAdaptor::setWMName( SalFrame* pFrame, const String& rWMName ) const
+void WMAdaptor::setWMName( X11SalFrame* pFrame, const String& rWMName ) const
 {
 	ByteString aTitle( rWMName, osl_getThreadTextEncoding() );
 
@@ -1048,8 +1046,9 @@ void WMAdaptor::setWMName( SalFrame* pFr
     Atom nType				= aProp.nitems ? aProp.encoding : XA_STRING;
     int nFormat				= aProp.nitems ? aProp.format : 8;
     int nBytes				= aProp.nitems ? aProp.nitems : aTitle.Len();
+    const SystemEnvData* pEnv = pFrame->GetSystemData();
     XChangeProperty( m_pDisplay,
-                     pFrame->maFrameData.GetShellWindow(),
+                     (XLIB_Window)pEnv->aShellWindow,
                      XA_WM_NAME,
                      nType,
                      nFormat,
@@ -1057,7 +1056,7 @@ void WMAdaptor::setWMName( SalFrame* pFr
                      pData,
                      nBytes );
     XChangeProperty( m_pDisplay,
-                     pFrame->maFrameData.GetShellWindow(),
+                     (XLIB_Window)pEnv->aShellWindow,
                      XA_WM_ICON_NAME,
                      nType,
                      nFormat,
@@ -1065,7 +1064,7 @@ void WMAdaptor::setWMName( SalFrame* pFr
                      pData,
                      nBytes );
     XChangeProperty( m_pDisplay,
-                     pFrame->maFrameData.GetShellWindow(),
+                     (XLIB_Window)pEnv->aShellWindow,
                      m_aWMAtoms[ WM_LOCALE_NAME ],
                      XA_STRING,
                      8,
@@ -1083,14 +1082,15 @@ void WMAdaptor::setWMName( SalFrame* pFr
  *       WM_ICON_NAME
  *       _NET_WM_ICON_NAME
  */
-void NetWMAdaptor::setWMName( SalFrame* pFrame, const String& rWMName ) const
+void NetWMAdaptor::setWMName( X11SalFrame* pFrame, const String& rWMName ) const
 {
     WMAdaptor::setWMName( pFrame, rWMName );
 
     ByteString aTitle( rWMName, RTL_TEXTENCODING_UTF8 );
+    const SystemEnvData* pEnv = pFrame->GetSystemData();
     if( m_aWMAtoms[ NET_WM_NAME ] )
         XChangeProperty( m_pDisplay,
-                         pFrame->maFrameData.GetShellWindow(),
+                         (XLIB_Window)pEnv->aShellWindow,
                          m_aWMAtoms[ NET_WM_NAME ],
                          m_aWMAtoms[ UTF8_STRING ],
                          8,
@@ -1099,7 +1099,7 @@ void NetWMAdaptor::setWMName( SalFrame* 
                          aTitle.Len()+1 );
     if( m_aWMAtoms[ NET_WM_ICON_NAME ] )
         XChangeProperty( m_pDisplay,
-                         pFrame->maFrameData.GetShellWindow(),
+                         (XLIB_Window)pEnv->aShellWindow,
                          m_aWMAtoms[ NET_WM_ICON_NAME ],
                          m_aWMAtoms[ UTF8_STRING ],
                          8,
@@ -1116,7 +1116,7 @@ void NetWMAdaptor::setWMName( SalFrame* 
  *  NetWMAdaptor::setNetWMState
  *  sets _NET_WM_STATE
  */
-void NetWMAdaptor::setNetWMState( SalFrame* pFrame ) const
+void NetWMAdaptor::setNetWMState( X11SalFrame* pFrame ) const
 {
     if( m_aWMAtoms[ NET_WM_STATE ] )
     {
@@ -1125,7 +1125,7 @@ void NetWMAdaptor::setNetWMState( SalFra
 
         // set NET_WM_STATE_MODAL
         if( m_aWMAtoms[ NET_WM_STATE_MODAL ]
-            && pFrame->maFrameData.meWindowType == windowType_ModalDialogue )
+            && pFrame->meWindowType == windowType_ModalDialogue )
         {
             aStateAtoms[ nStateAtoms++ ] = m_aWMAtoms[ NET_WM_STATE_MODAL ];
             /*
@@ -1135,23 +1135,23 @@ void NetWMAdaptor::setNetWMState( SalFra
              *  aStateAtoms[ nStateAtoms++ ] = m_aWMAtoms[ NET_WM_STATE_SKIP_TASKBAR ];
              */
         }
-        if( pFrame->maFrameData.mbMaximizedVert
+        if( pFrame->mbMaximizedVert
             && m_aWMAtoms[ NET_WM_STATE_MAXIMIZED_VERT ] )
             aStateAtoms[ nStateAtoms++ ] = m_aWMAtoms[ NET_WM_STATE_MAXIMIZED_VERT ];
-        if( pFrame->maFrameData.mbMaximizedHorz
+        if( pFrame->mbMaximizedHorz
             && m_aWMAtoms[ NET_WM_STATE_MAXIMIZED_HORZ ] )
             aStateAtoms[ nStateAtoms++ ] = m_aWMAtoms[ NET_WM_STATE_MAXIMIZED_HORZ ];
-        if( pFrame->maFrameData.bAlwaysOnTop_ && m_aWMAtoms[ NET_WM_STATE_STAYS_ON_TOP ] )
+        if( pFrame->bAlwaysOnTop_ && m_aWMAtoms[ NET_WM_STATE_STAYS_ON_TOP ] )
             aStateAtoms[ nStateAtoms++ ] = m_aWMAtoms[ NET_WM_STATE_STAYS_ON_TOP ];
-        if( pFrame->maFrameData.mbShaded && m_aWMAtoms[ NET_WM_STATE_SHADED ] )
+        if( pFrame->mbShaded && m_aWMAtoms[ NET_WM_STATE_SHADED ] )
             aStateAtoms[ nStateAtoms++ ] = m_aWMAtoms[ NET_WM_STATE_SHADED ];
-        if( pFrame->maFrameData.mbFullScreen && m_aWMAtoms[ NET_WM_STATE_FULLSCREEN ] )
+        if( pFrame->mbFullScreen && m_aWMAtoms[ NET_WM_STATE_FULLSCREEN ] )
             aStateAtoms[ nStateAtoms++ ] = m_aWMAtoms[ NET_WM_STATE_FULLSCREEN ];
 
         if( nStateAtoms )
         {
             XChangeProperty( m_pDisplay,
-                             pFrame->maFrameData.GetShellWindow(),
+                             pFrame->GetShellWindow(),
                              m_aWMAtoms[ NET_WM_STATE ],
                              XA_ATOM,
                              32,
@@ -1162,11 +1162,11 @@ void NetWMAdaptor::setNetWMState( SalFra
         }
         else
             XDeleteProperty( m_pDisplay,
-                             pFrame->maFrameData.GetShellWindow(),
+                             pFrame->GetShellWindow(),
                              m_aWMAtoms[ NET_WM_STATE ] );
-        if( pFrame->maFrameData.mbMaximizedHorz
-           && pFrame->maFrameData.mbMaximizedVert
-           && ! ( pFrame->maFrameData.nStyle_ & SAL_FRAME_STYLE_SIZEABLE ) )
+        if( pFrame->mbMaximizedHorz
+           && pFrame->mbMaximizedVert
+           && ! ( pFrame->nStyle_ & SAL_FRAME_STYLE_SIZEABLE ) )
         {
             /*
              *  for maximizing use NorthWestGravity (including decoration)
@@ -1175,7 +1175,7 @@ void NetWMAdaptor::setNetWMState( SalFra
             long		supplied;
             bool bHint = false;
             if( XGetWMNormalHints( m_pDisplay,
-                                   pFrame->maFrameData.GetShellWindow(),
+                                   pFrame->GetShellWindow(),
                                    &hints,
                                    &supplied ) )
             {
@@ -1183,7 +1183,7 @@ void NetWMAdaptor::setNetWMState( SalFra
                 hints.flags |= PWinGravity;
                 hints.win_gravity = NorthWestGravity;
                 XSetWMNormalHints( m_pDisplay,
-                                   pFrame->maFrameData.GetShellWindow(),
+                                   pFrame->GetShellWindow(),
                                    &hints );
                 XSync( m_pDisplay, False );
             }
@@ -1237,17 +1237,17 @@ void NetWMAdaptor::setNetWMState( SalFra
                                         - rGeom.nTopDecoration
                                         - rGeom.nBottomDecoration )
                                   );
-            pFrame->maFrameData.SetPosSize( aPosSize );
+            pFrame->SetPosSize( aPosSize );
 
             /*
              *  reset gravity hint to static gravity
              *  (this should not move window according to ICCCM)
              */
-            if( bHint && pFrame->maFrameData.nShowState_ != SHOWSTATE_UNKNOWN )
+            if( bHint && pFrame->nShowState_ != SHOWSTATE_UNKNOWN )
             {
                 hints.win_gravity = StaticGravity;
                 XSetWMNormalHints( m_pDisplay,
-                                   pFrame->maFrameData.GetShellWindow(),
+                                   pFrame->GetShellWindow(),
                                    &hints );
             }
         }
@@ -1258,21 +1258,21 @@ void NetWMAdaptor::setNetWMState( SalFra
  *  GnomeWMAdaptor::setNetWMState
  *  sets _WIN_STATE
  */
-void GnomeWMAdaptor::setGnomeWMState( SalFrame* pFrame ) const
+void GnomeWMAdaptor::setGnomeWMState( X11SalFrame* pFrame ) const
 {
     if( m_aWMAtoms[ WIN_STATE ] )
     {
         sal_uInt32 nWinWMState = 0;
 
-        if( pFrame->maFrameData.mbMaximizedVert )
+        if( pFrame->mbMaximizedVert )
             nWinWMState |= 1 << 2;
-        if( pFrame->maFrameData.mbMaximizedHorz )
+        if( pFrame->mbMaximizedHorz )
             nWinWMState |= 1 << 3;
-        if( pFrame->maFrameData.mbShaded )
+        if( pFrame->mbShaded )
             nWinWMState |= 1 << 5;
 
         XChangeProperty( m_pDisplay,
-                         pFrame->maFrameData.GetShellWindow(),
+                         pFrame->GetShellWindow(),
                          m_aWMAtoms[ WIN_STATE ],
                          XA_CARDINAL,
                          32,
@@ -1280,9 +1280,9 @@ void GnomeWMAdaptor::setGnomeWMState( Sa
                          (unsigned char*)&nWinWMState,
                          1
                          );
-        if( pFrame->maFrameData.mbMaximizedHorz
-           && pFrame->maFrameData.mbMaximizedVert
-           && ! ( pFrame->maFrameData.nStyle_ & SAL_FRAME_STYLE_SIZEABLE ) )
+        if( pFrame->mbMaximizedHorz
+           && pFrame->mbMaximizedVert
+           && ! ( pFrame->nStyle_ & SAL_FRAME_STYLE_SIZEABLE ) )
         {
             /*
              *  for maximizing use NorthWestGravity (including decoration)
@@ -1291,7 +1291,7 @@ void GnomeWMAdaptor::setGnomeWMState( Sa
             long		supplied;
             bool bHint = false;
             if( XGetWMNormalHints( m_pDisplay,
-                                   pFrame->maFrameData.GetShellWindow(),
+                                   pFrame->GetShellWindow(),
                                    &hints,
                                    &supplied ) )
             {
@@ -1299,7 +1299,7 @@ void GnomeWMAdaptor::setGnomeWMState( Sa
                 hints.flags |= PWinGravity;
                 hints.win_gravity = NorthWestGravity;
                 XSetWMNormalHints( m_pDisplay,
-                                   pFrame->maFrameData.GetShellWindow(),
+                                   pFrame->GetShellWindow(),
                                    &hints );
                 XSync( m_pDisplay, False );
             }
@@ -1353,17 +1353,17 @@ void GnomeWMAdaptor::setGnomeWMState( Sa
                                         - rGeom.nTopDecoration
                                         - rGeom.nBottomDecoration )
                                   );
-            pFrame->maFrameData.SetPosSize( aPosSize );
+            pFrame->SetPosSize( aPosSize );
 
             /*
              *  reset gravity hint to static gravity
              *  (this should not move window according to ICCCM)
              */
-            if( bHint && pFrame->maFrameData.nShowState_ != SHOWSTATE_UNKNOWN )
+            if( bHint && pFrame->nShowState_ != SHOWSTATE_UNKNOWN )
             {
                 hints.win_gravity = StaticGravity;
                 XSetWMNormalHints( m_pDisplay,
-                                   pFrame->maFrameData.GetShellWindow(),
+                                   pFrame->GetShellWindow(),
                                    &hints );
             }
         }
@@ -1376,10 +1376,10 @@ void GnomeWMAdaptor::setGnomeWMState( Sa
  *		 WM_TRANSIENT_FOR
  */
 
-void WMAdaptor::setFrameTypeAndDecoration( SalFrame* pFrame, WMWindowType eType, int nDecorationFlags, SalFrame* pReferenceFrame ) const
+void WMAdaptor::setFrameTypeAndDecoration( X11SalFrame* pFrame, WMWindowType eType, int nDecorationFlags, X11SalFrame* pReferenceFrame ) const
 {
-    pFrame->maFrameData.meWindowType		= eType;
-    pFrame->maFrameData.mnDecorationFlags	= nDecorationFlags;
+    pFrame->meWindowType		= eType;
+    pFrame->mnDecorationFlags	= nDecorationFlags;
 
     // set mwm hints
     struct _mwmhints {
@@ -1423,7 +1423,7 @@ void WMAdaptor::setFrameTypeAndDecoratio
 
     // set the hint
      XChangeProperty( m_pDisplay,
-                      pFrame->maFrameData.GetShellWindow(),
+                      pFrame->GetShellWindow(),
                       m_aWMAtoms[ MOTIF_WM_HINTS ],
                       m_aWMAtoms[ MOTIF_WM_HINTS ],
                       32,
@@ -1440,13 +1440,13 @@ void WMAdaptor::setFrameTypeAndDecoratio
     if( pReferenceFrame )
     {
         XSetTransientForHint( m_pDisplay,
-                              pFrame->maFrameData.GetShellWindow(),
-                              pReferenceFrame->maFrameData.bMapped_ ?
-                              pReferenceFrame->maFrameData.GetShellWindow() :
+                              pFrame->GetShellWindow(),
+                              pReferenceFrame->bMapped_ ?
+                              pReferenceFrame->GetShellWindow() :
                               m_pSalDisplay->GetRootWindow()
                               );
-        if( ! pReferenceFrame->maFrameData.bMapped_ )
-            pFrame->maFrameData.mbTransientForRoot = true;
+        if( ! pReferenceFrame->bMapped_ )
+            pFrame->mbTransientForRoot = true;
     }
     // #110333# in case no one ever sets a title prevent
     // the Dtwm taking the class instead
@@ -1462,7 +1462,7 @@ void WMAdaptor::setFrameTypeAndDecoratio
  *		 WM_TRANSIENT_FOR
  */
 
-void NetWMAdaptor::setFrameTypeAndDecoration( SalFrame* pFrame, WMWindowType eType, int nDecorationFlags, SalFrame* pReferenceFrame ) const
+void NetWMAdaptor::setFrameTypeAndDecoration( X11SalFrame* pFrame, WMWindowType eType, int nDecorationFlags, X11SalFrame* pReferenceFrame ) const
 {
     WMAdaptor::setFrameTypeAndDecoration( pFrame, eType, nDecorationFlags, pReferenceFrame );
 
@@ -1475,13 +1475,6 @@ void NetWMAdaptor::setFrameTypeAndDecora
         switch( eType )
         {
             case windowType_Utility:
-#if 0
-                // advertise tool windows as dialogues not utilities for now
-                // due to a bug in metacity 2.4.34 (smaller titlebar font on
-                // resizable utility windows)
-                eWMType = m_aWMAtoms[ NET_WM_WINDOW_TYPE_UTILITY ] ? NET_WM_WINDOW_TYPE_UTILITY : NET_WM_WINDOW_TYPE_DIALOG;
-                break;
-#endif
             case windowType_ModelessDialogue:
             case windowType_ModalDialogue:
                 eWMType = NET_WM_WINDOW_TYPE_DIALOG;
@@ -1494,7 +1487,7 @@ void NetWMAdaptor::setFrameTypeAndDecora
                 break;
         }
         XChangeProperty( m_pDisplay,
-                         pFrame->maFrameData.GetShellWindow(),
+                         pFrame->GetShellWindow(),
                          m_aWMAtoms[ NET_WM_WINDOW_TYPE ],
                          XA_ATOM,
                          32,
@@ -1507,9 +1500,9 @@ void NetWMAdaptor::setFrameTypeAndDecora
         && ! pReferenceFrame )
     {
         XSetTransientForHint( m_pDisplay,
-                              pFrame->maFrameData.GetShellWindow(),
+                              pFrame->GetShellWindow(),
                               m_pSalDisplay->GetRootWindow() );
-        pFrame->maFrameData.mbTransientForRoot = true;
+        pFrame->mbTransientForRoot = true;
     }
 }
 
@@ -1517,10 +1510,10 @@ void NetWMAdaptor::setFrameTypeAndDecora
  *  WMAdaptor::maximizeFrame
  */
 
-void WMAdaptor::maximizeFrame( SalFrame* pFrame, bool bHorizontal, bool bVertical ) const
+void WMAdaptor::maximizeFrame( X11SalFrame* pFrame, bool bHorizontal, bool bVertical ) const
 {
-    pFrame->maFrameData.mbMaximizedVert = bVertical;
-    pFrame->maFrameData.mbMaximizedHorz = bHorizontal;
+    pFrame->mbMaximizedVert = bVertical;
+    pFrame->mbMaximizedHorz = bHorizontal;
 
     const SalFrameGeometry& rGeom( pFrame->GetUnmirroredGeometry() );
 
@@ -1528,12 +1521,12 @@ void WMAdaptor::maximizeFrame( SalFrame*
     XSync( m_pDisplay, False );
     XEvent aDiscard;
     while( XCheckTypedWindowEvent( m_pDisplay,
-                                   pFrame->maFrameData.GetShellWindow(),
+                                   pFrame->GetShellWindow(),
                                    ConfigureNotify,
                                    &aDiscard ) )
         ;
     while( XCheckTypedWindowEvent( m_pDisplay,
-                                   pFrame->maFrameData.GetWindow(),
+                                   pFrame->GetWindow(),
                                    ConfigureNotify,
                                    &aDiscard ) )
         ;
@@ -1562,36 +1555,34 @@ void WMAdaptor::maximizeFrame( SalFrame*
         {
             aTarget.SetSize(
                             Size(
-                                 pFrame->maFrameData.maRestorePosSize.IsEmpty() ?
-                                 rGeom.nWidth : pFrame->maFrameData.maRestorePosSize.GetWidth(),
+                                 pFrame->maRestorePosSize.IsEmpty() ?
+                                 rGeom.nWidth : pFrame->maRestorePosSize.GetWidth(),
                                  aTarget.GetHeight()
                                  )
                             );
             aTarget.Left() =
-                pFrame->maFrameData.maRestorePosSize.IsEmpty() ?
-                rGeom.nX : pFrame->maFrameData.maRestorePosSize.Left();
+                pFrame->maRestorePosSize.IsEmpty() ?
+                rGeom.nX : pFrame->maRestorePosSize.Left();
         }
         else if( ! bVertical )
         {
             aTarget.SetSize(
                             Size(
                                  aTarget.GetWidth(),
-                                 pFrame->maFrameData.maRestorePosSize.IsEmpty() ?
-                                 rGeom.nHeight : pFrame->maFrameData.maRestorePosSize.GetHeight()
+                                 pFrame->maRestorePosSize.IsEmpty() ?
+                                 rGeom.nHeight : pFrame->maRestorePosSize.GetHeight()
                                  )
                             );
             aTarget.Top() =
-                pFrame->maFrameData.maRestorePosSize.IsEmpty() ?
-                rGeom.nY : pFrame->maFrameData.maRestorePosSize.Top();
+                pFrame->maRestorePosSize.IsEmpty() ?
+                rGeom.nY : pFrame->maRestorePosSize.Top();
         }
-        delete pFrame->maFrameData.pFreeGraphics_;
-        pFrame->maFrameData.pFreeGraphics_ = NULL;
 
         Rectangle aRestore( Point( rGeom.nX, rGeom.nY ), Size( rGeom.nWidth, rGeom.nHeight ) );
-        if( pFrame->maFrameData.bMapped_ )
+        if( pFrame->bMapped_ )
         {
             XSetInputFocus( m_pDisplay,
-                            pFrame->maFrameData.GetShellWindow(),
+                            pFrame->GetShellWindow(),
                             RevertToNone,
                             CurrentTime
                             );
@@ -1607,31 +1598,28 @@ void WMAdaptor::maximizeFrame( SalFrame*
             }
         }
 
-        if( pFrame->maFrameData.maRestorePosSize.IsEmpty() )
-            pFrame->maFrameData.maRestorePosSize = aRestore;
+        if( pFrame->maRestorePosSize.IsEmpty() )
+            pFrame->maRestorePosSize = aRestore;
 
-        pFrame->maFrameData.SetPosSize( aTarget );
-        pFrame->maFrameData.nWidth_		= aTarget.GetWidth();
-        pFrame->maFrameData.nHeight_	= aTarget.GetHeight();
+        pFrame->SetPosSize( aTarget );
+        pFrame->nWidth_		= aTarget.GetWidth();
+        pFrame->nHeight_	= aTarget.GetHeight();
         XRaiseWindow( m_pDisplay,
-                      pFrame->maFrameData.GetShellWindow()
+                      pFrame->GetShellWindow()
                       );
-        if( pFrame->maFrameData.GetStackingWindow() )
+        if( pFrame->GetStackingWindow() )
             XRaiseWindow( m_pDisplay,
-                          pFrame->maFrameData.GetStackingWindow()
+                          pFrame->GetStackingWindow()
                           );
 
     }
     else
     {
-        delete pFrame->maFrameData.pFreeGraphics_;
-        pFrame->maFrameData.pFreeGraphics_ = NULL;
-
-        pFrame->maFrameData.SetPosSize( pFrame->maFrameData.maRestorePosSize );
-        pFrame->maFrameData.maRestorePosSize = Rectangle();
-        pFrame->maFrameData.nWidth_ 			= rGeom.nWidth;
-        pFrame->maFrameData.nHeight_			= rGeom.nHeight;
-        if( m_aWMName.EqualsAscii( "Dtwm" ) && pFrame->maFrameData.bMapped_ )
+        pFrame->SetPosSize( pFrame->maRestorePosSize );
+        pFrame->maRestorePosSize = Rectangle();
+        pFrame->nWidth_ 			= rGeom.nWidth;
+        pFrame->nHeight_			= rGeom.nHeight;
+        if( m_aWMName.EqualsAscii( "Dtwm" ) && pFrame->bMapped_ )
         {
             pFrame->maGeometry.nX += rGeom.nLeftDecoration;
             pFrame->maGeometry.nY += rGeom.nTopDecoration;
@@ -1644,24 +1632,24 @@ void WMAdaptor::maximizeFrame( SalFrame*
  *  changes _NET_WM_STATE by sending a client message
  */
 
-void NetWMAdaptor::maximizeFrame( SalFrame* pFrame, bool bHorizontal, bool bVertical ) const
+void NetWMAdaptor::maximizeFrame( X11SalFrame* pFrame, bool bHorizontal, bool bVertical ) const
 {
-    pFrame->maFrameData.mbMaximizedVert = bVertical;
-    pFrame->maFrameData.mbMaximizedHorz = bHorizontal;
+    pFrame->mbMaximizedVert = bVertical;
+    pFrame->mbMaximizedHorz = bHorizontal;
 
     if( m_aWMAtoms[ NET_WM_STATE ]
         && m_aWMAtoms[ NET_WM_STATE_MAXIMIZED_VERT ]
         && m_aWMAtoms[ NET_WM_STATE_MAXIMIZED_HORZ ]
-        && ( pFrame->maFrameData.nStyle_ & ~SAL_FRAME_STYLE_DEFAULT )
+        && ( pFrame->nStyle_ & ~SAL_FRAME_STYLE_DEFAULT )
         )
     {
-        if( pFrame->maFrameData.bMapped_ )
+        if( pFrame->bMapped_ )
         {
             // window already mapped, send WM a message
             XEvent aEvent;
             aEvent.type					= ClientMessage;
             aEvent.xclient.display		= m_pDisplay;
-            aEvent.xclient.window		= pFrame->maFrameData.GetShellWindow();
+            aEvent.xclient.window		= pFrame->GetShellWindow();
             aEvent.xclient.message_type	= m_aWMAtoms[ NET_WM_STATE ];
             aEvent.xclient.format		= 32;
             aEvent.xclient.data.l[0]	= bHorizontal ? 1 : 0;
@@ -1694,11 +1682,11 @@ void NetWMAdaptor::maximizeFrame( SalFra
             setNetWMState( pFrame );
         }
         if( !bHorizontal && !bVertical )
-            pFrame->maFrameData.maRestorePosSize = Rectangle();
-        else if( pFrame->maFrameData.maRestorePosSize.IsEmpty() )
+            pFrame->maRestorePosSize = Rectangle();
+        else if( pFrame->maRestorePosSize.IsEmpty() )
         {
             const SalFrameGeometry& rGeom( pFrame->GetUnmirroredGeometry() );
-            pFrame->maFrameData.maRestorePosSize =
+            pFrame->maRestorePosSize =
                 Rectangle( Point( rGeom.nX, rGeom.nY ), Size( rGeom.nWidth, rGeom.nHeight ) );
         }
     }
@@ -1711,22 +1699,22 @@ void NetWMAdaptor::maximizeFrame( SalFra
  *  changes _WIN_STATE by sending a client message
  */
 
-void GnomeWMAdaptor::maximizeFrame( SalFrame* pFrame, bool bHorizontal, bool bVertical ) const
+void GnomeWMAdaptor::maximizeFrame( X11SalFrame* pFrame, bool bHorizontal, bool bVertical ) const
 {
-    pFrame->maFrameData.mbMaximizedVert = bVertical;
-    pFrame->maFrameData.mbMaximizedHorz = bHorizontal;
+    pFrame->mbMaximizedVert = bVertical;
+    pFrame->mbMaximizedHorz = bHorizontal;
 
     if( m_aWMAtoms[ WIN_STATE ]
-        && ( pFrame->maFrameData.nStyle_ & ~SAL_FRAME_STYLE_DEFAULT )
+        && ( pFrame->nStyle_ & ~SAL_FRAME_STYLE_DEFAULT )
         )
     {
-        if( pFrame->maFrameData.bMapped_ )
+        if( pFrame->bMapped_ )
         {
              // window already mapped, send WM a message
             XEvent aEvent;
             aEvent.type					= ClientMessage;
             aEvent.xclient.display		= m_pDisplay;
-            aEvent.xclient.window		= pFrame->maFrameData.GetShellWindow();
+            aEvent.xclient.window		= pFrame->GetShellWindow();
             aEvent.xclient.message_type	= m_aWMAtoms[ WIN_STATE ];
             aEvent.xclient.format		= 32;
             aEvent.xclient.data.l[0]	= (1<<2)|(1<<3);
@@ -1748,11 +1736,11 @@ void GnomeWMAdaptor::maximizeFrame( SalF
             setGnomeWMState( pFrame );
 
         if( !bHorizontal && !bVertical )
-            pFrame->maFrameData.maRestorePosSize = Rectangle();
-        else if( pFrame->maFrameData.maRestorePosSize.IsEmpty() )
+            pFrame->maRestorePosSize = Rectangle();
+        else if( pFrame->maRestorePosSize.IsEmpty() )
         {
             const SalFrameGeometry& rGeom( pFrame->GetUnmirroredGeometry() );
-            pFrame->maFrameData.maRestorePosSize =
+            pFrame->maRestorePosSize =
                 Rectangle( Point( rGeom.nX, rGeom.nY ), Size( rGeom.nWidth, rGeom.nHeight ) );
         }
     }
@@ -1784,25 +1772,25 @@ bool NetWMAdaptor::supportsICCCMPos() co
 /*
  *  WMAdaptor::enableAlwaysOnTop
  */
-void WMAdaptor::enableAlwaysOnTop( SalFrame* pFrame, bool bEnable ) const
+void WMAdaptor::enableAlwaysOnTop( X11SalFrame* pFrame, bool bEnable ) const
 {
 }
 
 /*
  *  NetWMAdaptor::enableAlwaysOnTop
  */
-void NetWMAdaptor::enableAlwaysOnTop( SalFrame* pFrame, bool bEnable ) const
+void NetWMAdaptor::enableAlwaysOnTop( X11SalFrame* pFrame, bool bEnable ) const
 {
-    pFrame->maFrameData.bAlwaysOnTop_ = bEnable;
+    pFrame->bAlwaysOnTop_ = bEnable;
     if( m_aWMAtoms[ NET_WM_STATE_STAYS_ON_TOP ] )
     {
-        if( pFrame->maFrameData.bMapped_ )
+        if( pFrame->bMapped_ )
         {
             // window already mapped, send WM a message
             XEvent aEvent;
             aEvent.type					= ClientMessage;
             aEvent.xclient.display		= m_pDisplay;
-            aEvent.xclient.window		= pFrame->maFrameData.GetShellWindow();
+            aEvent.xclient.window		= pFrame->GetShellWindow();
             aEvent.xclient.message_type	= m_aWMAtoms[ NET_WM_STATE ];
             aEvent.xclient.format		= 32;
             aEvent.xclient.data.l[0]	= bEnable ? 1 : 0;
@@ -1825,18 +1813,18 @@ void NetWMAdaptor::enableAlwaysOnTop( Sa
 /*
  *  GnomeWMAdaptor::enableAlwaysOnTop
  */
-void GnomeWMAdaptor::enableAlwaysOnTop( SalFrame* pFrame, bool bEnable ) const
+void GnomeWMAdaptor::enableAlwaysOnTop( X11SalFrame* pFrame, bool bEnable ) const
 {
-    pFrame->maFrameData.bAlwaysOnTop_ = bEnable;
+    pFrame->bAlwaysOnTop_ = bEnable;
     if( m_aWMAtoms[ WIN_LAYER ] )
     {
-        if( pFrame->maFrameData.bMapped_ )
+        if( pFrame->bMapped_ )
         {
             // window already mapped, send WM a message
             XEvent aEvent;
             aEvent.type					= ClientMessage;
             aEvent.xclient.display		= m_pDisplay;
-            aEvent.xclient.window		= pFrame->maFrameData.GetShellWindow();
+            aEvent.xclient.window		= pFrame->GetShellWindow();
             aEvent.xclient.message_type	= m_aWMAtoms[ WIN_LAYER ];
             aEvent.xclient.format		= 32;
             aEvent.xclient.data.l[0]	= bEnable ? 6 : 4;
@@ -1855,7 +1843,7 @@ void GnomeWMAdaptor::enableAlwaysOnTop( 
         {
             sal_uInt32 nNewLayer = bEnable ? 6 : 4;
             XChangeProperty( m_pDisplay,
-                             pFrame->maFrameData.GetShellWindow(),
+                             pFrame->GetShellWindow(),
                              m_aWMAtoms[ WIN_LAYER ],
                              XA_CARDINAL,
                              32,
@@ -1870,23 +1858,21 @@ void GnomeWMAdaptor::enableAlwaysOnTop( 
 /*
  *  WMAdaptor::changeReferenceFrame
  */
-void WMAdaptor::changeReferenceFrame( SalFrame* pFrame, SalFrame* pReferenceFrame ) const
+void WMAdaptor::changeReferenceFrame( X11SalFrame* pFrame, X11SalFrame* pReferenceFrame ) const
 {
-    SalFrameData& rData( pFrame->maFrameData );
-    if( ! ( rData.nStyle_ & ( SAL_FRAME_STYLE_CHILD | SAL_FRAME_STYLE_FLOAT ) )
-        && ! rData.IsOverrideRedirect()
+    if( ! ( pFrame->nStyle_ & ( SAL_FRAME_STYLE_CHILD | SAL_FRAME_STYLE_FLOAT ) )
+        && ! pFrame->IsOverrideRedirect()
         )
     {
-        XLIB_Window aTransient = rData.pDisplay_->GetRootWindow();
-        rData.mbTransientForRoot = true;
+        XLIB_Window aTransient = pFrame->pDisplay_->GetRootWindow();
+        pFrame->mbTransientForRoot = true;
         if( pReferenceFrame )
         {
-            SalFrameData& rRefData( pReferenceFrame->maFrameData );
-            aTransient = rRefData.GetShellWindow();
-            rData.mbTransientForRoot = false;
+            aTransient = pReferenceFrame->GetShellWindow();
+            pFrame->mbTransientForRoot = false;
         }
         XSetTransientForHint( m_pDisplay,
-                              rData.GetShellWindow(),
+                              pFrame->GetShellWindow(),
                               aTransient );
     }
 }
@@ -1894,7 +1880,7 @@ void WMAdaptor::changeReferenceFrame( Sa
 /*
  *  WMAdaptor::handlePropertyNotify
  */
-int WMAdaptor::handlePropertyNotify( SalFrame* pFrame, XPropertyEvent* pEvent ) const
+int WMAdaptor::handlePropertyNotify( X11SalFrame* pFrame, XPropertyEvent* pEvent ) const
 {
     return 0;
 }
@@ -1902,13 +1888,13 @@ int WMAdaptor::handlePropertyNotify( Sal
 /*
  *  NetWMAdaptor::handlePropertyNotify
  */
-int NetWMAdaptor::handlePropertyNotify( SalFrame* pFrame, XPropertyEvent* pEvent ) const
+int NetWMAdaptor::handlePropertyNotify( X11SalFrame* pFrame, XPropertyEvent* pEvent ) const
 {
     int nHandled = 1;
     if( pEvent->atom == m_aWMAtoms[ NET_WM_STATE ] )
     {
-        pFrame->maFrameData.mbMaximizedHorz = pFrame->maFrameData.mbMaximizedVert = false;
-        pFrame->maFrameData.mbShaded = false;
+        pFrame->mbMaximizedHorz = pFrame->mbMaximizedVert = false;
+        pFrame->mbShaded = false;
 
         if( pEvent->state == PropertyNewValue )
         {
@@ -1937,11 +1923,11 @@ int NetWMAdaptor::handlePropertyNotify( 
                         for( unsigned long i = 0; i < nItems; i++ )
                         {
                             if( pStates[i] == m_aWMAtoms[ NET_WM_STATE_MAXIMIZED_VERT ] && m_aWMAtoms[ NET_WM_STATE_MAXIMIZED_VERT ] )
-                                pFrame->maFrameData.mbMaximizedVert = true;
+                                pFrame->mbMaximizedVert = true;
                             else if( pStates[i] == m_aWMAtoms[ NET_WM_STATE_MAXIMIZED_HORZ ] && m_aWMAtoms[ NET_WM_STATE_MAXIMIZED_HORZ ] )
-                                pFrame->maFrameData.mbMaximizedHorz = true;
+                                pFrame->mbMaximizedHorz = true;
                             else if( pStates[i] == m_aWMAtoms[ NET_WM_STATE_SHADED ] && m_aWMAtoms[ NET_WM_STATE_SHADED ] )
-                                pFrame->maFrameData.mbShaded = true;
+                                pFrame->mbShaded = true;
                         }
                     }
                     XFree( pData );
@@ -1949,14 +1935,14 @@ int NetWMAdaptor::handlePropertyNotify( 
             } while( nBytesLeft > 0 );
         }
 
-        if( ! (pFrame->maFrameData.mbMaximizedHorz || pFrame->maFrameData.mbMaximizedVert ) )
-            pFrame->maFrameData.maRestorePosSize = Rectangle();
+        if( ! (pFrame->mbMaximizedHorz || pFrame->mbMaximizedVert ) )
+            pFrame->maRestorePosSize = Rectangle();
         else
         {
             const SalFrameGeometry& rGeom = pFrame->GetUnmirroredGeometry();
             // the current geometry may already be changed by the corresponding
             // ConfigureNotify, but this cannot be helped
-            pFrame->maFrameData.maRestorePosSize =
+            pFrame->maRestorePosSize =
                 Rectangle( Point( rGeom.nX, rGeom.nY ),
                            Size( rGeom.nWidth, rGeom.nHeight ) );
         }
@@ -1970,13 +1956,13 @@ int NetWMAdaptor::handlePropertyNotify( 
 /*
  *  GnomeWMAdaptor::handlePropertyNotify
  */
-int GnomeWMAdaptor::handlePropertyNotify( SalFrame* pFrame, XPropertyEvent* pEvent ) const
+int GnomeWMAdaptor::handlePropertyNotify( X11SalFrame* pFrame, XPropertyEvent* pEvent ) const
 {
     int nHandled = 1;
     if( pEvent->atom == m_aWMAtoms[ WIN_STATE ] )
     {
-        pFrame->maFrameData.mbMaximizedHorz = pFrame->maFrameData.mbMaximizedVert = false;
-        pFrame->maFrameData.mbShaded = false;
+        pFrame->mbMaximizedHorz = pFrame->mbMaximizedVert = false;
+        pFrame->mbShaded = false;
 
         if( pEvent->state == PropertyNewValue )
         {
@@ -2000,24 +1986,24 @@ int GnomeWMAdaptor::handlePropertyNotify
                 {
                     sal_uInt32 nWinState = *(sal_uInt32*)pData;
                     if( nWinState & (1<<2) )
-                        pFrame->maFrameData.mbMaximizedVert = true;
+                        pFrame->mbMaximizedVert = true;
                     if( nWinState & (1<<3) )
-                        pFrame->maFrameData.mbMaximizedHorz = true;
+                        pFrame->mbMaximizedHorz = true;
                     if( nWinState & (1<<5) )
-                        pFrame->maFrameData.mbShaded = true;
+                        pFrame->mbShaded = true;
                 }
                 XFree( pData );
             }
         }
 
-        if( ! (pFrame->maFrameData.mbMaximizedHorz || pFrame->maFrameData.mbMaximizedVert ) )
-            pFrame->maFrameData.maRestorePosSize = Rectangle();
+        if( ! (pFrame->mbMaximizedHorz || pFrame->mbMaximizedVert ) )
+            pFrame->maRestorePosSize = Rectangle();
         else
         {
             const SalFrameGeometry& rGeom = pFrame->GetUnmirroredGeometry();
             // the current geometry may already be changed by the corresponding
             // ConfigureNotify, but this cannot be helped
-            pFrame->maFrameData.maRestorePosSize =
+            pFrame->maRestorePosSize =
                 Rectangle( Point( rGeom.nX, rGeom.nY ),
                            Size( rGeom.nWidth, rGeom.nHeight ) );
         }
@@ -2031,28 +2017,28 @@ int GnomeWMAdaptor::handlePropertyNotify
 /*
  * WMAdaptor::shade
  */
-void WMAdaptor::shade( SalFrame* pFrame, bool bToShaded ) const
+void WMAdaptor::shade( X11SalFrame* pFrame, bool bToShaded ) const
 {
 }
 
 /*
  * NetWMAdaptor::shade
  */
-void NetWMAdaptor::shade( SalFrame* pFrame, bool bToShaded ) const
+void NetWMAdaptor::shade( X11SalFrame* pFrame, bool bToShaded ) const
 {
     if( m_aWMAtoms[ NET_WM_STATE ]
         && m_aWMAtoms[ NET_WM_STATE_SHADED ]
-        && ( pFrame->maFrameData.nStyle_ & ~SAL_FRAME_STYLE_DEFAULT )
+        && ( pFrame->nStyle_ & ~SAL_FRAME_STYLE_DEFAULT )
         )
     {
-        pFrame->maFrameData.mbShaded = bToShaded;
-        if( pFrame->maFrameData.bMapped_ )
+        pFrame->mbShaded = bToShaded;
+        if( pFrame->bMapped_ )
         {
             // window already mapped, send WM a message
             XEvent aEvent;
             aEvent.type					= ClientMessage;
             aEvent.xclient.display		= m_pDisplay;
-            aEvent.xclient.window		= pFrame->maFrameData.GetShellWindow();
+            aEvent.xclient.window		= pFrame->GetShellWindow();
             aEvent.xclient.message_type	= m_aWMAtoms[ NET_WM_STATE ];
             aEvent.xclient.format		= 32;
             aEvent.xclient.data.l[0]	= bToShaded ? 1 : 0;
@@ -2078,18 +2064,18 @@ void NetWMAdaptor::shade( SalFrame* pFra
 /*
  *  GnomeWMAdaptor::shade
  */
-void GnomeWMAdaptor::shade( SalFrame* pFrame, bool bToShaded ) const
+void GnomeWMAdaptor::shade( X11SalFrame* pFrame, bool bToShaded ) const
 {
     if( m_aWMAtoms[ WIN_STATE ] )
     {
-        pFrame->maFrameData.mbShaded = bToShaded;
-        if( pFrame->maFrameData.bMapped_ )
+        pFrame->mbShaded = bToShaded;
+        if( pFrame->bMapped_ )
         {
             // window already mapped, send WM a message
             XEvent aEvent;
             aEvent.type					= ClientMessage;
             aEvent.xclient.display		= m_pDisplay;
-            aEvent.xclient.window		= pFrame->maFrameData.GetShellWindow();
+            aEvent.xclient.window		= pFrame->GetShellWindow();
             aEvent.xclient.message_type	= m_aWMAtoms[ WIN_STATE ];
             aEvent.xclient.format		= 32;
             aEvent.xclient.data.l[0]	= (1<<5);
@@ -2112,27 +2098,27 @@ void GnomeWMAdaptor::shade( SalFrame* pF
 /*
  *  WMAdaptor::showFullScreen
  */
-void WMAdaptor::showFullScreen( SalFrame* pFrame, bool bFullScreen ) const
+void WMAdaptor::showFullScreen( X11SalFrame* pFrame, bool bFullScreen ) const
 {
-    pFrame->maFrameData.mbFullScreen = bFullScreen;
+    pFrame->mbFullScreen = bFullScreen;
     maximizeFrame( pFrame, bFullScreen, bFullScreen );
 }
 
 /*
  *  NetWMAdaptor::showFullScreen
  */
-void NetWMAdaptor::showFullScreen( SalFrame* pFrame, bool bFullScreen ) const
+void NetWMAdaptor::showFullScreen( X11SalFrame* pFrame, bool bFullScreen ) const
 {
     if( m_aWMAtoms[ NET_WM_STATE_FULLSCREEN ] )
     {
-        pFrame->maFrameData.mbFullScreen = bFullScreen;
-        if( pFrame->maFrameData.bMapped_ )
+        pFrame->mbFullScreen = bFullScreen;
+        if( pFrame->bMapped_ )
         {
             // window already mapped, send WM a message
             XEvent aEvent;
             aEvent.type					= ClientMessage;
             aEvent.xclient.display		= m_pDisplay;
-            aEvent.xclient.window		= pFrame->maFrameData.GetShellWindow();
+            aEvent.xclient.window		= pFrame->GetShellWindow();
             aEvent.xclient.message_type	= m_aWMAtoms[ NET_WM_STATE ];
             aEvent.xclient.format		= 32;
             aEvent.xclient.data.l[0]	= bFullScreen ? 1 : 0;
Index: vcl/unx/source/gdi/cdeint.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/cdeint.cxx,v
retrieving revision 1.8
retrieving revision 1.9
diff -u -p -u -r1.8 -r1.9
--- vcl/unx/source/gdi/cdeint.cxx	24 Jun 2002 15:53:02 -0000	1.8
+++ vcl/unx/source/gdi/cdeint.cxx	18 Nov 2003 14:44:27 -0000	1.9
@@ -64,14 +64,12 @@
 #include <salunx.h>
 #include <saldisp.hxx>
 #include <cdeint.hxx>
-#include <salframe.hxx>
 #include <settings.hxx>
 
 #include <tools/stream.hxx>
 #include <tools/debug.hxx>
 
-CDEIntegrator::CDEIntegrator( SalFrame* pFrame ) :
-		DtIntegrator( pFrame )
+CDEIntegrator::CDEIntegrator()
 {
 	meType = DtCDE;
 	mnRefCount++;
Index: vcl/unx/source/gdi/dtint.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/dtint.cxx,v
retrieving revision 1.16.82.1
retrieving revision 1.22
diff -u -p -u -r1.16.82.1 -r1.22
--- vcl/unx/source/gdi/dtint.cxx	15 Jan 2004 12:52:24 -0000	1.16.82.1
+++ vcl/unx/source/gdi/dtint.cxx	10 May 2004 15:58:19 -0000	1.22
@@ -72,10 +72,8 @@
 #include <cdeint.hxx>
 #endif
 #include <kdeint.hxx>
-#include <gnomeint.hxx>
 #include <saldisp.hxx>
 #include <saldata.hxx>
-#include <salframe.hxx>
 #include <wmadaptor.hxx>
 
 #include <svapp.hxx>
@@ -103,16 +101,12 @@ BOOL bSymbolLoadFailed = FALSE;
 DtIntegratorList DtIntegrator::aIntegratorList;
 String DtIntegrator::aHomeDir;
 
-DtIntegrator::DtIntegrator( SalFrame* pFrame ) :
-		mpSalFrame( pFrame ),
+DtIntegrator::DtIntegrator() :
 		meType( DtGeneric ),
 		mnRefCount( 0 ),
         mnSystemLookCommandProcess( -1 )
 {
-    if( pFrame )
-        mpSalDisplay = pFrame->maFrameData.GetDisplay();
-    else
-        mpSalDisplay = GetSalData()->GetDefDisp();
+    mpSalDisplay = GetSalData()->GetDisplay();
 	mpDisplay = mpSalDisplay->GetDisplay();
 	aIntegratorList.Insert( this, LIST_APPEND );
     static const char* pHome = getenv( "HOME" );
@@ -123,16 +117,12 @@ DtIntegrator::~DtIntegrator()
 {
 }
 
-DtIntegrator* DtIntegrator::CreateDtIntegrator( SalFrame* pFrame )
+DtIntegrator* DtIntegrator::CreateDtIntegrator()
 {
-	// hack for sclient
-	if( ! pFrame && aIntegratorList.Count() )
-		return aIntegratorList.GetObject( 0 );
-
-    SalDisplay* pSalDisplay = pFrame ? pFrame->maFrameData.GetDisplay() : GetSalData()->GetDefDisp();
+    SalDisplay* pSalDisplay = GetSalData()->GetDisplay();
     Display* pDisplay = pSalDisplay->GetDisplay();
 
-	for( int i = 0; i < aIntegratorList.Count(); i++ )
+	for( unsigned int i = 0; i < aIntegratorList.Count(); i++ )
 	{
 		DtIntegrator* pIntegrator = aIntegratorList.GetObject( i );
 		if( pIntegrator->mpDisplay == pDisplay )
@@ -150,14 +140,12 @@ DtIntegrator* DtIntegrator::CreateDtInte
         OString aOver( pOverride );
 #if USE_CDE
         if( aOver.equalsIgnoreAsciiCase( "cde" ) )
-            return new CDEIntegrator( pFrame );
+            return new CDEIntegrator();
 #endif
         if( aOver.equalsIgnoreAsciiCase( "kde" ) )
-            return new KDEIntegrator( pFrame );
-        if( aOver.equalsIgnoreAsciiCase( "gnome" ) )
-            return new GNOMEIntegrator( pFrame );
+            return new KDEIntegrator();
         if( aOver.equalsIgnoreAsciiCase( "none" ) )
-            return new DtIntegrator( pFrame );
+            return new DtIntegrator();
     }
 
 	Atom nDtAtom = None;
@@ -168,461 +156,20 @@ DtIntegrator* DtIntegrator::CreateDtInte
 	// check dt type
 	// CDE
 	nDtAtom = XInternAtom( pDisplay, "_DT_WM_READY", True );
-	if( nDtAtom && ( pLibrary = dlopen( "libDtSvc.so", DLOPEN_MODE ) ) )
+	if( nDtAtom && ( pLibrary = dlopen( "/usr/dt/lib/libDtSvc.so", DLOPEN_MODE ) ) )
 	{
         dlclose( pLibrary );
-		return new CDEIntegrator( pFrame );
+		return new CDEIntegrator();
 	}
 #endif
 
     if( pSalDisplay->getWMAdaptor()->getWindowManagerName().EqualsAscii( "KWin" ) )
-		return new KDEIntegrator( pFrame );
-
-    // actually this is not that good an indicator for a GNOME running
-    // but there currently does not seem to be a better one
-    nDtAtom = XInternAtom( pDisplay, "GNOME_SM_PROXY", True );
-	Atom nDtAtom2 = XInternAtom( pDisplay, "NAUTILUS_DESKTOP_WINDOW_ID", True );
-    if( nDtAtom || nDtAtom2 )
-    {
-        int nProperties = 0;
-        Atom* pProperties = XListProperties( pDisplay, pSalDisplay->GetRootWindow(), &nProperties );
-        if( pProperties && nProperties )
-        {
-            for( int i = 0; i < nProperties; i++ )
-                if( pProperties[ i ] == nDtAtom ||
-					pProperties[ i ] == nDtAtom2 )
-                {
-                    XFree( pProperties );
-                    return new GNOMEIntegrator( pFrame );
-                }
-            XFree( pProperties );
-        }
-    }
+		return new KDEIntegrator();
 
 	// default: generic implementation
-	return new DtIntegrator( pFrame );
+	return new DtIntegrator();
 }
 
 void DtIntegrator::GetSystemLook( AllSettings& rSettings )
 {
-}
-
-Color DtIntegrator::parseColor( const ByteString& rLine )
-{
-    Color aColor;
-
-    xub_StrLen nPos1 = rLine.Search( '(' );
-    xub_StrLen nPos2 = rLine.Search( ')', nPos1 != STRING_NOTFOUND ? nPos1 : 0 );
-    if( nPos1 != STRING_NOTFOUND && nPos2 != STRING_NOTFOUND
-        && (int)nPos2 - (int)nPos1 > 5 )
-    {
-        ByteString aTriple( rLine.Copy( nPos1+1, nPos2-nPos1-1 ) );
-        xub_StrLen nIndex = 0;
-        int nRed, nGreen, nBlue, nColor = 0;
-        do
-        {
-            switch( nColor )
-            {
-                case 0: nRed = aTriple.GetToken( 0, ',', nIndex ).ToInt32();break;
-                case 1: nGreen = aTriple.GetToken( 0, ',', nIndex ).ToInt32();break;
-                case 2: nBlue = aTriple.GetToken( 0, ',', nIndex ).ToInt32();break;
-            }
-            nColor++;
-        } while(  nIndex != STRING_NOTFOUND );
-        if( nColor == 3 )
-        {
-            aColor = Color( nRed, nGreen, nBlue );
-        }
-    }
-    return aColor;
-}
-
-Font DtIntegrator::parseFont( const ByteString& rLine )
-{
-    Font aFont;
-
-    xub_StrLen nPos1 = rLine.Search( '"' );
-    xub_StrLen nPos2 = rLine.Search( '"', nPos1 != STRING_NOTFOUND ? nPos1+1 : 0 );
-    if( nPos1 != STRING_NOTFOUND && nPos2 != STRING_NOTFOUND
-        && (int)nPos2 - (int)nPos1 > 1 )
-    {
-        aFont.SetName( String( rLine.Copy( nPos1+1, nPos2-nPos1-1 ), osl_getThreadTextEncoding() ) );
-        xub_StrLen nIndex = nPos2;
-        ByteString aToken = rLine.GetToken( 1, ',', nIndex );
-        if( aToken.Len() )
-        {
-            int nPixelHeight = aToken.ToInt32();
-            long nDPIX, nDPIY;
-            long nDispDPIY = mpSalDisplay->GetResolution().B();
-            mpSalDisplay->GetScreenFontResolution( nDPIX, nDPIY );
-            int nHeight = nPixelHeight * nDispDPIY / nDPIY;
-            // allow for rounding in back conversion (at SetFont)
-            while( (nHeight * nDPIY / nDispDPIY) > nPixelHeight )
-                nHeight--;
-            while( (nHeight * nDPIY / nDispDPIY) < nPixelHeight )
-                nHeight++;
-            aFont.SetHeight( nHeight );
-        }
-        while( nIndex != STRING_NOTFOUND )
-        {
-            aToken = rLine.GetToken( 0, ',', nIndex );
-            if( aToken.Equals( "bold" ) )
-                aFont.SetWeight( WEIGHT_BOLD );
-            else if( aToken.Equals( "light" ) )
-                aFont.SetWeight( WEIGHT_LIGHT );
-            else if( aToken.Equals( "italic" ) )
-                aFont.SetItalic( ITALIC_NORMAL );
-        }
-    }
-    return aFont;
-}
-
-bool DtIntegrator::StartSystemLookProcess( const char* pCommand )
-{
-    ByteString aCommand, aArgWindow;
-    if( pCommand[0] == '/' )
-        aCommand = pCommand;
-    else
-    {
-        OUString aExec;
-        OUString aSys;
-        osl_getExecutableFile( &aExec.pData );
-        if( osl_File_E_None != osl_getSystemPathFromFileURL( aExec.pData, &aSys.pData ) )
-            return false; // huh ?
-        aCommand = ByteString( String( aSys ), osl_getThreadTextEncoding() );
-        aCommand.Erase( aCommand.SearchBackward( '/' )+1 );
-        aCommand.Append( pCommand );
-    }
-    aArgWindow = ByteString::CreateFromInt32( mpSalDisplay->GetDrawable() );
-    mnSystemLookCommandProcess = fork();
-    if( mnSystemLookCommandProcess == 0 )
-    {
-#if OSL_DEBUG_LEVEL > 1
-        fprintf( stderr, "exec( \"%s --vcl-system-settings-window %s\" )\n", aCommand.GetBuffer(), aArgWindow.GetBuffer() );
-#endif
-        int nRedirect = open( "/dev/null", O_WRONLY );
-        if( nRedirect != -1 )
-        {
-            dup2( nRedirect, STDOUT_FILENO );
-            dup2( nRedirect, STDERR_FILENO );
-        }
-        execl( aCommand.GetBuffer(), aCommand.GetBuffer(), "--vcl-system-settings-window", aArgWindow.GetBuffer(), NULL );
-        _exit(1);
-    }
-    return mnSystemLookCommandProcess != -1;
-}
-
-void DtIntegrator::GetSystemLook( const char* pCommand, AllSettings& rSettings )
-{
-    BOOL bRet = FALSE;
-    std::list< ByteString > aLines;
-
-    if( pCommand )
-    {
-        char pBuffer[1024];
-        FILE* pOutput = NULL;
-
-        ByteString aCommand;
-        if( pCommand[0] == '/' )
-            aCommand = pCommand;
-        else
-        {
-            OUString aExec;
-            OUString aSys;
-            osl_getExecutableFile( &aExec.pData );
-            if( osl_File_E_None != osl_getSystemPathFromFileURL( aExec.pData, &aSys.pData ) )
-                return; // huh ?
-            aCommand = ByteString( String( aSys ), osl_getThreadTextEncoding() );
-            aCommand.Erase( aCommand.SearchBackward( '/' )+1 );
-            aCommand.Append( pCommand );
-        }
-#if OSL_DEBUG_LEVEL < 2
-        aCommand.Append( " 2>/dev/null" );
-#endif
-        pOutput = popen( aCommand.GetBuffer(), "r" );
-#if OSL_DEBUG_LEVEL > 1
-        fprintf( stderr, "popen( \"%s\", \"r\" ) = %p\n", aCommand.GetBuffer(), pOutput );
-#endif
-        while( fgets( pBuffer, sizeof( pBuffer ), pOutput ) )
-        {
-            aLines.push_back( ByteString( pBuffer ) );
-        }
-        pclose( pOutput );
-    }
-    else if( ! pCommand && mnSystemLookCommandProcess != -1 )
-    {
-        // get the lines from the VCL_SYSTEM_SETTINGS property
-        Atom nType = 0;
-        int nFormat = 0;
-        unsigned long nItems = 0, nBytes = 0;
-        char* pData = NULL;
-        // query size of the property
-        XGetWindowProperty( mpSalDisplay->GetDisplay(),
-                            mpSalDisplay->GetDrawable(),
-                            mpSalDisplay->getWMAdaptor()->getAtom( WMAdaptor::VCL_SYSTEM_SETTINGS ),
-                            0, 0,
-                            False,
-                            XA_STRING,
-                            &nType,
-                            &nFormat,
-                            &nItems,
-                            &nBytes,
-                            (unsigned char**)&pData );
-        if( nBytes )
-        {
-            // query the actual data
-            XGetWindowProperty( mpSalDisplay->GetDisplay(),
-                                mpSalDisplay->GetDrawable(),
-                                mpSalDisplay->getWMAdaptor()->getAtom( WMAdaptor::VCL_SYSTEM_SETTINGS ),
-                                0, (nBytes+3)/4,
-                                False,
-                                XA_STRING,
-                                &nType,
-                                &nFormat,
-                                &nItems,
-                                &nBytes,
-                                (unsigned char**)&pData );
-            // sanity check
-            if( nFormat == 8 && nType == XA_STRING && nItems )
-            {
-#if OSL_DEBUG_LEVEL > 1
-                fprintf( stderr, "got %d data items:\n%.*s", nItems, nItems, pData );
-#endif
-                // fill in the lines
-                char* pRun = pData;
-                char* pLastLine = pData;
-                while( (pRun-pData) <= nItems )
-                {
-                    if( *pRun == '\n' )
-                    {
-                        if( pRun-pLastLine > 1 )
-                        {
-                            aLines.push_back( ByteString( pLastLine, pRun - pLastLine ) );
-                            pLastLine = pRun+1;
-                        }
-                    }
-                    pRun++;
-                }
-            }
-#if OSL_DEBUG_LEVEL > 1
-            else
-                fprintf( stderr, "query of data failed with nFormat = %d, nType = %d, nItems = %d\n", nFormat, nType, nItems );
-#endif
-            XFree( pData );
-        }
-#if OSL_DEBUG_LEVEL > 1
-        else
-            fprintf( stderr, "query of bytes failed\n" );
-#endif
-    }
-
-    // nothing to do ?
-    if( aLines.begin() == aLines.end() )
-        return;
-
-    StyleSettings aStyleSettings( rSettings.GetStyleSettings() );
-    MouseSettings aMouseSettings( rSettings.GetMouseSettings() );
-    KeyboardSettings aKeyboardSettings( rSettings.GetKeyboardSettings() );
-
-    std::set< DtSetEnum > aItemSet;
-
-    while( aLines.begin() != aLines.end() )
-    {
-        ByteString aLine( aLines.front() );
-        aLines.pop_front();
-        if( aLine.GetChar( aLine.Len()-1 ) == '\n' )
-            aLine.Erase( aLine.Len()-1 ); // cut newline
-
-        USHORT nPos = aLine.Search( '=' );
-        if( nPos == STRING_NOTFOUND )
-            continue;
-
-        DtSetEnum aToken = (DtSetEnum)aLine.Copy( 0, nPos ).ToInt32();
-        aLine.Erase( 0, nPos+1 );
-
-        if( aToken )
-        {
-            bRet = TRUE;
-            aItemSet.insert( aToken );
-        }
-
-        switch( aToken )
-        {
-            case MouseOptions:			aMouseSettings.SetOptions( aLine.ToInt32() );break;
-            case DoubleClickTime:		aMouseSettings.SetDoubleClickTime( aLine.ToInt32() );break;
-            case DoubleClickWidth:		aMouseSettings.SetDoubleClickWidth( aLine.ToInt32() );break;
-            case DoubleClickHeight:		aMouseSettings.SetDoubleClickHeight( aLine.ToInt32() );break;
-            case StartDragWidth:		aMouseSettings.SetStartDragWidth( aLine.ToInt32() );break;
-            case StartDragHeight:		aMouseSettings.SetStartDragHeight( aLine.ToInt32() );break;
-            case DragMoveCode:			aMouseSettings.SetDragMoveCode( aLine.ToInt32() );break;
-            case DragCopyCode:			aMouseSettings.SetDragCopyCode( aLine.ToInt32() );break;
-            case DragLinkCode:			aMouseSettings.SetDragLinkCode( aLine.ToInt32() );break;
-            case ContextMenuCode:		aMouseSettings.SetContextMenuCode( aLine.ToInt32() );break;
-            case ContextMenuClicks:		aMouseSettings.SetContextMenuClicks( aLine.ToInt32() );break;
-            case ContextMenuDown:		aMouseSettings.SetContextMenuDown( aLine.ToInt32() );break;
-            case ScrollRepeat:			aMouseSettings.SetScrollRepeat( aLine.ToInt32() );break;
-            case ButtonStartRepeat:		aMouseSettings.SetButtonStartRepeat( aLine.ToInt32() );break;
-            case ButtonRepeat:			aMouseSettings.SetButtonRepeat( aLine.ToInt32() );break;
-            case ActionDelay:			aMouseSettings.SetActionDelay( aLine.ToInt32() );break;
-            case MenuDelay:				aMouseSettings.SetMenuDelay( aLine.ToInt32() );break;
-            case Follow:				aMouseSettings.SetFollow( aLine.ToInt32() );break;
-            case MiddleButtonAction:	aMouseSettings.SetMiddleButtonAction( aLine.ToInt32() );break;
-            case KeyboardOptions:		aKeyboardSettings.SetOptions( aLine.ToInt32() );break;
-            case StyleOptions:			aStyleSettings.SetOptions( aLine.ToInt32() );break;
-            case BorderSize:			aStyleSettings.SetBorderSize( aLine.ToInt32() );break;
-            case TitleHeight:			aStyleSettings.SetTitleHeight( aLine.ToInt32() );break;
-            case FloatTitleHeight:		aStyleSettings.SetFloatTitleHeight( aLine.ToInt32() );break;
-            case TearOffTitleHeight:	aStyleSettings.SetTearOffTitleHeight( aLine.ToInt32() );break;
-            case MenuBarHeight:			aStyleSettings.SetMenuBarHeight( aLine.ToInt32() );break;
-            case ScrollBarSize:			aStyleSettings.SetScrollBarSize( aLine.ToInt32() );break;
-            case SpinSize:				aStyleSettings.SetSpinSize( aLine.ToInt32() );break;
-            case SplitSize:				aStyleSettings.SetSplitSize( aLine.ToInt32() );break;
-            case IconHorzSpace:			aStyleSettings.SetIconHorzSpace( aLine.ToInt32() );break;
-            case IconVertSpace:			aStyleSettings.SetIconVertSpace( aLine.ToInt32() );break;
-            case CursorSize:			aStyleSettings.SetCursorSize( aLine.ToInt32() );break;
-            case CursorBlinkTime:		aStyleSettings.SetCursorBlinkTime( aLine.ToInt32() );break;
-            case ScreenZoom:			aStyleSettings.SetScreenZoom( aLine.ToInt32() );break;
-            case ScreenFontZoom:		aStyleSettings.SetScreenFontZoom( aLine.ToInt32() );break;
-            case LogoDisplayTime:		aStyleSettings.SetLogoDisplayTime( aLine.ToInt32() );break;
-            case DragFullOptions:		aStyleSettings.SetDragFullOptions( aLine.ToInt32() );break;
-            case AnimationOptions:		aStyleSettings.SetAnimationOptions( aLine.ToInt32() );break;
-            case SelectionOptions:		aStyleSettings.SetSelectionOptions( aLine.ToInt32() );break;
-            case DisplayOptions:		aStyleSettings.SetDisplayOptions( aLine.ToInt32() );break;
-            case AntialiasingMinPixelHeight: aStyleSettings.SetAntialiasingMinPixelHeight( aLine.ToInt32() );break;
-            case ThreeDColor:			aStyleSettings.Set3DColors( parseColor( aLine ) );break;
-            case FaceColor:				aStyleSettings.SetFaceColor( parseColor( aLine ) );break;
-            case CheckedColor:			aStyleSettings.SetCheckedColor( parseColor( aLine ) );break;
-            case LightColor:			aStyleSettings.SetLightColor( parseColor( aLine ) );break;
-            case LightBorderColor:		aStyleSettings.SetLightBorderColor( parseColor( aLine ) );break;
-            case ShadowColor:			aStyleSettings.SetShadowColor( parseColor( aLine ) );break;
-            case DarkShadowColor:		aStyleSettings.SetDarkShadowColor( parseColor( aLine ) );break;
-            case ButtonTextColor:		aStyleSettings.SetButtonTextColor( parseColor( aLine ) );break;
-            case RadioCheckTextColor:	aStyleSettings.SetRadioCheckTextColor( parseColor( aLine ) );break;
-            case GroupTextColor:		aStyleSettings.SetGroupTextColor( parseColor( aLine ) );break;
-            case LabelTextColor:		aStyleSettings.SetLabelTextColor( parseColor(aLine ) );break;
-            case InfoTextColor:			aStyleSettings.SetInfoTextColor( parseColor( aLine ) );break;
-            case WindowColor:			aStyleSettings.SetWindowColor( parseColor( aLine ) );break;
-            case WindowTextColor:		aStyleSettings.SetWindowTextColor( parseColor( aLine ) );break;
-            case DialogColor:			aStyleSettings.SetDialogColor( parseColor( aLine ) );break;
-            case DialogTextColor:		aStyleSettings.SetDialogTextColor( parseColor( aLine ) );break;
-            case WorkspaceColor:		aStyleSettings.SetWorkspaceColor( parseColor( aLine ) );break;
-            case FieldColor:			aStyleSettings.SetFieldColor( parseColor( aLine ) );break;
-            case FieldTextColor:		aStyleSettings.SetFieldTextColor( parseColor( aLine ) );break;
-            case ActiveColor:			aStyleSettings.SetActiveColor( parseColor( aLine ) );break;
-            case ActiveColor2:			aStyleSettings.SetActiveColor2( parseColor( aLine ) );break;
-            case ActiveTextColor:		aStyleSettings.SetActiveTextColor( parseColor( aLine ) );break;
-            case ActiveBorderColor:		aStyleSettings.SetActiveBorderColor( parseColor( aLine ) );break;
-            case DeactiveColor:			aStyleSettings.SetDeactiveColor( parseColor( aLine ) );break;
-            case DeactiveColor2:		aStyleSettings.SetDeactiveColor2( parseColor( aLine ) );break;
-            case DeactiveTextColor:		aStyleSettings.SetDeactiveTextColor( parseColor( aLine ) );break;
-            case DeactiveBorderColor:	aStyleSettings.SetDeactiveBorderColor( parseColor( aLine ) );break;
-            case HighlightColor:		aStyleSettings.SetHighlightColor( parseColor( aLine ) );break;
-            case HighlightTextColor:	aStyleSettings.SetHighlightTextColor( parseColor( aLine ) );break;
-            case DisableColor:			aStyleSettings.SetDisableColor( parseColor( aLine ) );break;
-            case HelpColor:				aStyleSettings.SetHelpColor( parseColor( aLine ) );break;
-            case HelpTextColor:			aStyleSettings.SetHelpTextColor( parseColor( aLine ) );break;
-            case MenuColor:				aStyleSettings.SetMenuColor( parseColor( aLine ) );break;
-            case MenuBarColor:			aStyleSettings.SetMenuBarColor( parseColor( aLine ) );break;
-            case MenuTextColor:			aStyleSettings.SetMenuTextColor( parseColor( aLine ) );break;
-            case MenuHighlightColor:	aStyleSettings.SetMenuHighlightColor( parseColor( aLine ) );break;
-            case MenuHighlightTextColor: aStyleSettings.SetMenuHighlightTextColor( parseColor( aLine ) );break;
-            case LinkColor:				aStyleSettings.SetLinkColor( parseColor( aLine ) );break;
-            case VisitedLinkColor:		aStyleSettings.SetVisitedLinkColor( parseColor( aLine ) );break;
-            case HighlightLinkColor:	aStyleSettings.SetHighlightLinkColor( parseColor( aLine ) );break;
-            case HighContrastMode:		aStyleSettings.SetHighContrastMode( aLine.ToInt32() );break;
-            case AppFont:				aStyleSettings.SetAppFont( parseFont( aLine ) );break;
-            case HelpFont:				aStyleSettings.SetHelpFont( parseFont( aLine ) );break;
-            case TitleFont:				aStyleSettings.SetTitleFont( parseFont( aLine ) );break;
-            case FloatTitleFont:		aStyleSettings.SetFloatTitleFont( parseFont( aLine ) );break;
-            case MenuFont:				aStyleSettings.SetMenuFont( parseFont( aLine ) );break;
-            case ToolFont:				aStyleSettings.SetToolFont( parseFont( aLine ) );break;
-            case GroupFont:				aStyleSettings.SetGroupFont( parseFont( aLine ) );break;
-            case LabelFont:				aStyleSettings.SetLabelFont( parseFont( aLine ) );break;
-            case InfoFont:				aStyleSettings.SetInfoFont( parseFont( aLine ) );break;
-            case RadioCheckFont:		aStyleSettings.SetRadioCheckFont( parseFont( aLine ) );break;
-            case PushButtonFont:		aStyleSettings.SetPushButtonFont( parseFont( aLine ) );break;
-            case FieldFont:				aStyleSettings.SetFieldFont( parseFont( aLine ) );break;
-            case IconFont:				aStyleSettings.SetIconFont( parseFont( aLine ) );break;
-            case RadioButtonStyle:		aStyleSettings.SetRadioButtonStyle( aLine.ToInt32() );break;
-            case CheckBoxStyle:			aStyleSettings.SetCheckBoxStyle( aLine.ToInt32() );break;
-            case PushButtonStyle:		aStyleSettings.SetPushButtonStyle( aLine.ToInt32() );break;
-            case TabControlStyle:		aStyleSettings.SetTabControlStyle( aLine.ToInt32() );
-                break;
-
-            case AllTextColors:
-            {
-                Color aTextColor = parseColor( aLine );
-                aStyleSettings.SetDialogTextColor( aTextColor );
-                aStyleSettings.SetMenuTextColor( aTextColor );
-                aStyleSettings.SetButtonTextColor( aTextColor );
-                aStyleSettings.SetRadioCheckTextColor( aTextColor );
-                aStyleSettings.SetGroupTextColor( aTextColor );
-                aStyleSettings.SetLabelTextColor( aTextColor );
-                aStyleSettings.SetInfoTextColor( aTextColor );
-                aStyleSettings.SetWindowTextColor( aTextColor );
-                aStyleSettings.SetFieldTextColor( aTextColor );
-            }
-            break;
-            case AllBackColors:
-            {
-                Color aBack = parseColor( aLine );
-                aStyleSettings.Set3DColors( aBack );
-                aStyleSettings.SetFaceColor( aBack );
-                aStyleSettings.SetDialogColor( aBack );
-                aStyleSettings.SetMenuColor( aBack );
-                aStyleSettings.SetMenuBarColor( aBack );
-                aStyleSettings.SetWindowColor( aBack );
-                aStyleSettings.SetFieldColor( aBack );
-                if( aBack == COL_LIGHTGRAY )
-                    aStyleSettings.SetCheckedColor( Color( 0xCC, 0xCC, 0xCC ) );
-                else
-                {
-                    Color aColor2 = aStyleSettings.GetLightColor();
-                    aStyleSettings.
-                        SetCheckedColor( Color(
-                                               (BYTE)(((USHORT)aBack.GetRed()+(USHORT)aColor2.GetRed())/2),
-                                               (BYTE)(((USHORT)aBack.GetGreen()+(USHORT)aColor2.GetGreen())/2),
-                                               (BYTE)(((USHORT)aBack.GetBlue()+(USHORT)aColor2.GetBlue())/2)
-                                               ) );
-                }
-            }
-            break;
-            case UIFont:
-                if( aStyleSettings.GetUseSystemUIFonts() )
-                {
-                    Font aFont = parseFont( aLine );
-                    aStyleSettings.SetAppFont( aFont );
-                    aStyleSettings.SetHelpFont( aFont );
-                    aStyleSettings.SetMenuFont( aFont );
-                    aStyleSettings.SetToolFont( aFont );
-                    aStyleSettings.SetLabelFont( aFont );
-                    aStyleSettings.SetInfoFont( aFont );
-                    aStyleSettings.SetRadioCheckFont( aFont );
-                    aStyleSettings.SetPushButtonFont( aFont );
-                    aStyleSettings.SetFieldFont( aFont );
-                    aStyleSettings.SetIconFont( aFont );
-                    aStyleSettings.SetGroupFont( aFont );
-                }
-                break;
-            case ToolbarIconSize:
-                if( aLine.EqualsIgnoreCaseAscii( "large" ) )
-                    aStyleSettings.SetToolbarIconSize( STYLE_TOOLBAR_ICONSIZE_LARGE );
-                else if( aLine.EqualsIgnoreCaseAscii( "small" ) )
-                    aStyleSettings.SetToolbarIconSize( STYLE_TOOLBAR_ICONSIZE_SMALL );
-                else
-                    aStyleSettings.SetToolbarIconSize( STYLE_TOOLBAR_ICONSIZE_UNKNOWN );
-                break;
-#if OSL_DEBUG_LEVEL > 1
-            default:
-                fprintf( stderr, "don't understand \"%d=%s\"\n", aToken, aLine.GetBuffer() );
-                break;
-#endif
-        }
-    }
-    if( bRet )
-    {
-        rSettings.SetKeyboardSettings( aKeyboardSettings );
-        rSettings.SetMouseSettings( aMouseSettings );
-        rSettings.SetStyleSettings( aStyleSettings );
-    }
 }
Index: vcl/unx/source/gdi/gcach_xpeer.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/gcach_xpeer.cxx,v
retrieving revision 1.32.18.1
retrieving revision 1.37
diff -u -p -u -r1.32.18.1 -r1.37
--- vcl/unx/source/gdi/gcach_xpeer.cxx	9 Jan 2004 18:14:01 -0000	1.32.18.1
+++ vcl/unx/source/gdi/gcach_xpeer.cxx	4 Feb 2004 11:05:23 -0000	1.37
@@ -61,6 +61,7 @@
 
 #include <rtl/ustring.hxx>
 #include <osl/module.h>
+#include <osl/thread.h>
 using namespace rtl;
 
 #include <gcach_xpeer.hxx>
@@ -138,7 +139,7 @@ void X11GlyphPeer::SetDisplay( Display* 
     if( !pRenderLib ) {
 #ifdef DEBUG
         fprintf( stderr, "Display can do XRender, but no %s installed.\n"
-            "Please install for improved display performance\n", xrenderLibraryName.getStr() );
+            "Please install for improved display performance\n", OUStringToOString( xrenderLibraryName.getStr(), osl_getThreadTextEncoding() ).getStr() );
 #endif
         return;
     }
@@ -296,15 +297,16 @@ void X11GlyphPeer::RemovingGlyph( Server
 
         case XRENDER_KIND:
             {
+/*
+				// TODO: reenable when it works without problems
                 Glyph nGlyphId = (Glyph)rGlyphData.GetExtPointer();
                 // XRenderFreeGlyphs not implemented yet for version<=0.2
                 // #108209# disabled because of crash potential,
                 // the glyph leak is not too bad because they will
                 // be cleaned up when the glyphset is released
-#if 0   // TODO: reenable when it works without problems
                 if( nRenderVersion >= 0x05 )
                     (*pXRenderFreeGlyphs)( mpDisplay, aGlyphSet, &nGlyphId, 1 );
-#endif
+*/
                 mnBytesUsed -= nHeight * ((nWidth + 3) & ~3);
             }
             break;
@@ -331,7 +333,7 @@ bool X11GlyphPeer::ForcedAntialiasing( c
 GlyphSet X11GlyphPeer::GetGlyphSet( ServerFont& rServerFont )
 {
     if( !mbUsingXRender )
-        return NULL;
+        return 0;
 
     GlyphSet aGlyphSet;
 
@@ -354,12 +356,12 @@ GlyphSet X11GlyphPeer::GetGlyphSet( Serv
                     rServerFont.SetExtended( XRENDER_KIND, (void*)aGlyphSet );
                 }
                 else
-                    aGlyphSet = NULL;
+                    aGlyphSet = 0;
             }
             break;
 
         default:
-            aGlyphSet = NULL;
+            aGlyphSet = 0;
             break;
     }
 
@@ -381,7 +383,7 @@ Pixmap X11GlyphPeer::GetPixmap( ServerFo
         {
             // #94666# circumvent bug in some X11 systems, e.g. XF410.LynxEM.v163
             ULONG nPixmapWidth = 8 * maRawBitmap.mnScanlineSize - 1;
-            nPixmapWidth = std::max( nPixmapWidth, maRawBitmap.mnWidth );
+            nPixmapWidth = Max( nPixmapWidth, maRawBitmap.mnWidth );
 
             rGlyphData.SetSize( Size( nPixmapWidth, maRawBitmap.mnHeight ) );
             rGlyphData.SetOffset( +maRawBitmap.mnXOffset, +maRawBitmap.mnYOffset );
Index: vcl/unx/source/gdi/kdeint.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/kdeint.cxx,v
retrieving revision 1.10
retrieving revision 1.12
diff -u -p -u -r1.10 -r1.12
--- vcl/unx/source/gdi/kdeint.cxx	16 Jul 2003 17:46:57 -0000	1.10
+++ vcl/unx/source/gdi/kdeint.cxx	6 Jan 2004 14:37:00 -0000	1.12
@@ -60,18 +60,18 @@
  ************************************************************************/
 
 #include <kdeint.hxx>
-#include <config.hxx>
+#include <tools/config.hxx>
 #include <settings.hxx>
 
 #include <osl/thread.h>
 
 #include <unistd.h>
+#include <cstdio>
 
 using namespace rtl;
 using namespace osl;
 
-KDEIntegrator::KDEIntegrator( SalFrame* pFrame ) :
-		DtIntegrator( pFrame )
+KDEIntegrator::KDEIntegrator()
 {
 	meType = DtKDE;
 }
@@ -80,7 +80,7 @@ KDEIntegrator::~KDEIntegrator()
 {
 }
 
-static char* pTryFiles[] =
+static const char* pTryFiles[] =
   {
 	"/usr/share/config/kdeglobals",
 	"/opt/kde/share/config/kdeglobals",
@@ -93,7 +93,7 @@ void KDEIntegrator::GetSystemLook( AllSe
 {
     rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
 
-	for( int i = 0; (i < sizeof( pTryFiles )/sizeof(pTryFiles[0])); i++ )
+	for( unsigned int i = 0; (i < sizeof( pTryFiles )/sizeof(pTryFiles[0])); i++ )
 	  {
 		String aFile;
 		if( pTryFiles[i][0] == '~' )
Index: vcl/unx/source/gdi/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/makefile.mk,v
retrieving revision 1.9
retrieving revision 1.13
diff -u -p -u -r1.9 -r1.13
--- vcl/unx/source/gdi/makefile.mk	27 Aug 2002 14:52:35 -0000	1.9
+++ vcl/unx/source/gdi/makefile.mk	10 May 2004 15:58:32 -0000	1.13
@@ -80,24 +80,29 @@ dummy:
 
 .ELSE		# "$(GUIBASE)"!="unx"
 
-.IF "$(remote)"==""
 SLOFILES=	\
 		$(SLO)$/salgdi2.obj		\
 		$(SLO)$/salbmp.obj		\
 		$(SLO)$/salgdi.obj		\
 		$(SLO)$/salvd.obj		\
 		$(SLO)$/salogl.obj		\
-		$(SLO)$/charnames.obj	\
 		$(SLO)$/dtint.obj		\
-		$(SLO)$/kdeint.obj		\
-		$(SLO)$/gnomeint.obj	\
 		$(SLO)$/salcvt.obj		\
-		$(SLO)$/ansi1252.obj	\
 		$(SLO)$/xfont.obj		\
 		$(SLO)$/xlfd_attr.obj	\
 		$(SLO)$/xlfd_extd.obj	\
 		$(SLO)$/xlfd_smpl.obj	\
-		$(SLO)$/salgdi3.obj
+		$(SLO)$/salgdi3.obj		\
+		$(SLO)$/pspgraphics.obj
+
+.IF "$(WITH_WIDGETSET)"=="kde"
+	# salnativewidgets-kde.cxx contains own implementation of KDEintegrator
+	SLOFILES+=$(SLO)/salnativewidgets-kde.obj
+	CFLAGS+=$(WIDGETSET_CFLAGS)
+.ELSE
+	SLOFILES+= \
+		$(SLO)$/kdeint.obj
+.ENDIF
 
 .IF "$(USE_XPRINT)" == "TRUE"
 CFLAGS+=-D_USE_PRINT_EXTENSION_=1
@@ -113,8 +118,6 @@ ENVCFLAGS+=-DUSE_CDE
 
 .IF "$(USE_BUILTIN_RASTERIZER)" != ""
 SLOFILES+=	$(SLO)$/gcach_xpeer.obj
-.ENDIF
-
 .ENDIF
 
 .ENDIF	# "$(GUIBASE)"!="unx"
Index: vcl/unx/source/gdi/pspgraphics.cxx
===================================================================
RCS file: vcl/unx/source/gdi/pspgraphics.cxx
diff -N vcl/unx/source/gdi/pspgraphics.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/source/gdi/pspgraphics.cxx	17 Jun 2004 12:28:07 -0000	1.4
@@ -0,0 +1,1355 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <pspgraphics.h>
+#include <psprint/jobdata.hxx>
+#include <psprint/printergfx.hxx>
+#include <psprint/printerinfomanager.hxx>
+#include <bmpacc.hxx>
+#include <salbmp.hxx>
+#include <glyphcache.hxx>
+#include <svapp.hxx>
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+using namespace psp;
+using namespace rtl;
+
+// ----- Implementation of PrinterBmp by means of SalBitmap/BitmapBuffer ---------------
+
+class SalPrinterBmp : public psp::PrinterBmp
+{
+	private:
+    BitmapBuffer*		mpBmpBuffer;
+    
+    FncGetPixel			mpFncGetPixel;
+    Scanline			mpScanAccess;
+    sal_Int32			mnScanOffset;
+    
+    sal_uInt32			ColorOf (BitmapColor& rColor) const;
+    sal_uInt8			GrayOf  (BitmapColor& rColor) const;
+    
+    SalPrinterBmp ();
+
+	public:
+
+							SalPrinterBmp (BitmapBuffer* pBitmap);
+		virtual				~SalPrinterBmp ();
+		virtual sal_uInt32	GetPaletteColor (sal_uInt32 nIdx) const;
+		virtual sal_uInt32	GetPaletteEntryCount () const;
+		virtual sal_uInt32	GetPixelRGB  (sal_uInt32 nRow, sal_uInt32 nColumn) const;
+		virtual sal_uInt8	GetPixelGray (sal_uInt32 nRow, sal_uInt32 nColumn) const;
+		virtual sal_uInt8	GetPixelIdx  (sal_uInt32 nRow, sal_uInt32 nColumn) const;
+		virtual sal_uInt32	GetWidth () const;
+		virtual sal_uInt32	GetHeight() const;
+		virtual sal_uInt32	GetDepth ()	const;
+};
+
+SalPrinterBmp::SalPrinterBmp (BitmapBuffer* pBuffer) :
+		mpBmpBuffer (pBuffer)
+{
+	DBG_ASSERT (mpBmpBuffer, "SalPrinterBmp::SalPrinterBmp () can't acquire Bitmap");
+
+	// calibrate scanline buffer
+	if( BMP_SCANLINE_ADJUSTMENT( mpBmpBuffer->mnFormat ) == BMP_FORMAT_TOP_DOWN )
+	{
+		mpScanAccess = mpBmpBuffer->mpBits;
+		mnScanOffset = mpBmpBuffer->mnScanlineSize;
+	}
+	else
+	{
+		mpScanAccess = mpBmpBuffer->mpBits
+					   + (mpBmpBuffer->mnHeight - 1) * mpBmpBuffer->mnScanlineSize;
+		mnScanOffset = - mpBmpBuffer->mnScanlineSize;
+	}
+
+	// request read access to the pixels
+	switch( BMP_SCANLINE_FORMAT( mpBmpBuffer->mnFormat ) )
+	{
+		case BMP_FORMAT_1BIT_MSB_PAL:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_1BIT_MSB_PAL;	 break;
+		case BMP_FORMAT_1BIT_LSB_PAL:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_1BIT_LSB_PAL;	 break;
+		case BMP_FORMAT_4BIT_MSN_PAL:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_4BIT_MSN_PAL;	 break;
+		case BMP_FORMAT_4BIT_LSN_PAL:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_4BIT_LSN_PAL;	 break;
+		case BMP_FORMAT_8BIT_PAL:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_8BIT_PAL; 	 break;
+		case BMP_FORMAT_8BIT_TC_MASK:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_8BIT_TC_MASK;	 break;
+		case BMP_FORMAT_16BIT_TC_MSB_MASK:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_16BIT_TC_MSB_MASK; break;
+		case BMP_FORMAT_16BIT_TC_LSB_MASK:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_16BIT_TC_LSB_MASK; break;
+		case BMP_FORMAT_24BIT_TC_BGR:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_BGR;  break;
+		case BMP_FORMAT_24BIT_TC_RGB:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_RGB;  break;
+		case BMP_FORMAT_24BIT_TC_MASK:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_MASK; break;
+		case BMP_FORMAT_32BIT_TC_ABGR:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_ABGR; break;
+		case BMP_FORMAT_32BIT_TC_ARGB:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_ARGB; break;
+		case BMP_FORMAT_32BIT_TC_BGRA:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_BGRA; break;
+		case BMP_FORMAT_32BIT_TC_RGBA:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_RGBA; break;
+		case BMP_FORMAT_32BIT_TC_MASK:
+			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_MASK; break;
+
+		default:
+			DBG_ERROR("Error: SalPrinterBmp::SalPrinterBmp() unknown bitmap format");
+		break;
+	}
+}
+
+SalPrinterBmp::~SalPrinterBmp ()
+{
+}
+
+sal_uInt32
+SalPrinterBmp::GetWidth () const
+{
+	return mpBmpBuffer->mnWidth;
+}
+
+sal_uInt32
+SalPrinterBmp::GetHeight () const
+{
+	return mpBmpBuffer->mnHeight;
+}
+
+sal_uInt32
+SalPrinterBmp::GetDepth () const
+{
+	sal_uInt32 nDepth;
+
+	switch (mpBmpBuffer->mnBitCount)
+	{
+		case 1:
+			nDepth = 1;
+			break;
+
+		case 4:
+		case 8:
+			nDepth = 8;
+			break;
+
+		case 16:
+		case 24:
+		case 32:
+			nDepth = 24;
+			break;
+
+		default:
+			DBG_ERROR ("Error: unsupported bitmap depth in SalPrinterBmp::GetDepth()");
+			break;
+	}
+
+	return nDepth;
+}
+
+sal_uInt32
+SalPrinterBmp::ColorOf (BitmapColor& rColor) const
+{
+	if (rColor.IsIndex())
+		return ColorOf (mpBmpBuffer->maPalette[rColor.GetIndex()]);
+	else
+		return 	  ((rColor.GetBlue()) 		 & 0x000000ff)
+				| ((rColor.GetGreen() <<  8) & 0x0000ff00)
+				| ((rColor.GetRed()   << 16) & 0x00ff0000);
+}
+
+sal_uInt8
+SalPrinterBmp::GrayOf (BitmapColor& rColor) const
+{
+	if (rColor.IsIndex())
+		return GrayOf (mpBmpBuffer->maPalette[rColor.GetIndex()]);
+	else
+		return (  rColor.GetBlue()  *  28UL
+				+ rColor.GetGreen() * 151UL
+				+ rColor.GetRed()   *  77UL ) >> 8;
+}
+
+sal_uInt32
+SalPrinterBmp::GetPaletteEntryCount () const
+{
+	return mpBmpBuffer->maPalette.GetEntryCount ();
+}
+
+sal_uInt32
+SalPrinterBmp::GetPaletteColor (sal_uInt32 nIdx) const
+{
+	return ColorOf (mpBmpBuffer->maPalette[nIdx]);
+}
+
+sal_uInt32
+SalPrinterBmp::GetPixelRGB (sal_uInt32 nRow, sal_uInt32 nColumn) const
+{
+	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
+	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
+
+	return ColorOf (aColor);
+}
+
+sal_uInt8
+SalPrinterBmp::GetPixelGray (sal_uInt32 nRow, sal_uInt32 nColumn) const
+{
+	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
+	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
+
+	return GrayOf (aColor);
+}
+
+sal_uInt8
+SalPrinterBmp::GetPixelIdx (sal_uInt32 nRow, sal_uInt32 nColumn) const
+{
+	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
+	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
+
+	if (aColor.IsIndex())
+		return aColor.GetIndex();
+	else
+		return 0;
+}
+
+/*******************************************************
+ * PspGraphics                                         *
+ *******************************************************/
+
+PspGraphics::~PspGraphics()
+{
+}
+
+void PspGraphics::GetResolution( sal_Int32 &rDPIX, sal_Int32 &rDPIY )
+{
+	if (m_pJobData != NULL)
+	{
+		int x = m_pJobData->m_aContext.getRenderResolution();
+
+		rDPIX = x;
+		rDPIY = x;
+	}
+}
+
+void PspGraphics::GetScreenFontResolution( sal_Int32 &rDPIX, sal_Int32 &rDPIY )
+{
+    m_pPrinterGfx->GetScreenFontResolution (rDPIX, rDPIY);
+}
+
+USHORT PspGraphics::GetBitCount()
+{
+    return m_pPrinterGfx->GetBitCount();
+}
+
+long PspGraphics::GetGraphicsWidth()
+{
+    return 0;
+}
+
+void PspGraphics::ResetClipRegion()
+{
+    m_pPrinterGfx->ResetClipRegion ();
+}
+
+void PspGraphics::BeginSetClipRegion( ULONG n )
+{
+    m_pPrinterGfx->BeginSetClipRegion(n);
+}
+
+BOOL PspGraphics::unionClipRegion( long nX, long nY, long nDX, long nDY )
+{
+    return (BOOL)m_pPrinterGfx->UnionClipRegion (nX, nY, nDX, nDY);
+}
+
+void PspGraphics::EndSetClipRegion()
+{
+    m_pPrinterGfx->EndSetClipRegion ();
+}
+
+void PspGraphics::SetLineColor()
+{
+    m_pPrinterGfx->SetLineColor ();
+}
+
+void PspGraphics::SetLineColor( SalColor nSalColor )
+{
+    psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
+                              SALCOLOR_GREEN (nSalColor),
+                              SALCOLOR_BLUE  (nSalColor));
+    m_pPrinterGfx->SetLineColor (aColor);
+}
+
+void PspGraphics::SetFillColor()
+{
+    m_pPrinterGfx->SetFillColor ();
+}
+
+void PspGraphics::SetFillColor( SalColor nSalColor )
+{
+    psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
+                              SALCOLOR_GREEN (nSalColor),
+                              SALCOLOR_BLUE  (nSalColor));
+    m_pPrinterGfx->SetFillColor (aColor);
+}
+
+void PspGraphics::SetROPLineColor( SalROPColor nROPColor )
+{
+    DBG_ASSERT( 0, "Error: PrinterGfx::SetROPLineColor() not implemented" );
+}
+
+void PspGraphics::SetROPFillColor( SalROPColor nROPColor )
+{
+    DBG_ASSERT( 0, "Error: PrinterGfx::SetROPFillColor() not implemented" );
+}
+
+void PspGraphics::SetXORMode( BOOL bSet )
+{
+    DBG_ASSERT( !bSet, "Error: PrinterGfx::SetXORMode() not implemented" );
+}
+
+void PspGraphics::drawPixel( long nX, long nY )
+{
+    m_pPrinterGfx->DrawPixel (Point(nX, nY));
+}
+
+void PspGraphics::drawPixel( long nX, long nY, SalColor nSalColor )
+{
+    psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
+                              SALCOLOR_GREEN (nSalColor),
+                              SALCOLOR_BLUE  (nSalColor));
+    m_pPrinterGfx->DrawPixel (Point(nX, nY), aColor);
+}
+
+void PspGraphics::drawLine( long nX1, long nY1, long nX2, long nY2 )
+{
+    m_pPrinterGfx->DrawLine (Point(nX1, nY1), Point(nX2, nY2));
+}
+
+void PspGraphics::drawRect( long nX, long nY, long nDX, long nDY )
+{
+    m_pPrinterGfx->DrawRect (Rectangle(Point(nX, nY), Size(nDX, nDY)));
+}
+
+void PspGraphics::drawPolyLine( ULONG nPoints, const SalPoint *pPtAry )
+{
+    m_pPrinterGfx->DrawPolyLine (nPoints, (Point*)pPtAry);
+}
+
+void PspGraphics::drawPolygon( ULONG nPoints, const SalPoint* pPtAry )
+{
+	// Point must be equal to SalPoint! see vcl/inc/salgtype.hxx
+    m_pPrinterGfx->DrawPolygon (nPoints, (Point*)pPtAry);
+}
+
+void PspGraphics::drawPolyPolygon( ULONG			nPoly,
+								   const ULONG	   *pPoints,
+								   PCONSTSALPOINT  *pPtAry )
+{
+    m_pPrinterGfx->DrawPolyPolygon (nPoly, pPoints, (const Point**)pPtAry);
+}
+
+sal_Bool PspGraphics::drawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
+{
+    m_pPrinterGfx->DrawPolyLineBezier (nPoints, (Point*)pPtAry, pFlgAry);
+    return sal_True;
+}
+
+sal_Bool PspGraphics::drawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
+{
+    m_pPrinterGfx->DrawPolygonBezier (nPoints, (Point*)pPtAry, pFlgAry);
+    return sal_True;
+}
+
+sal_Bool PspGraphics::drawPolyPolygonBezier( ULONG nPoly,
+                                             const ULONG* pPoints,
+                                             const SalPoint* const* pPtAry,
+                                             const BYTE* const* pFlgAry )
+{
+	// Point must be equal to SalPoint! see vcl/inc/salgtype.hxx
+    m_pPrinterGfx->DrawPolyPolygonBezier (nPoly, pPoints, (Point**)pPtAry, (BYTE**)pFlgAry);
+    return sal_True;
+}
+
+void PspGraphics::invert( ULONG nPoints,
+                          const SalPoint* pPtAry,
+                          SalInvert nFlags )
+{
+    DBG_ASSERT( 0, "Error: PrinterGfx::Invert() not implemented" );
+}
+BOOL PspGraphics::drawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize )
+{
+    return m_pPrinterGfx->DrawEPS( Rectangle( Point( nX, nY ), Size( nWidth, nHeight ) ), pPtr, nSize );
+}
+
+void PspGraphics::copyBits( const SalTwoRect *pPosAry,
+                            SalGraphics	   *pSSrcGraphics )
+{
+    DBG_ERROR( "Error: PrinterGfx::CopyBits() not implemented" );
+}
+
+void PspGraphics::copyArea ( long nDestX,    long nDestY,
+                             long nSrcX,     long nSrcY,
+                             long nSrcWidth, long nSrcHeight,
+                             USHORT nFlags )
+{
+    DBG_ERROR( "Error: PrinterGfx::CopyArea() not implemented" );
+}
+
+void PspGraphics::drawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap )
+{
+    Rectangle aSrc (Point(pPosAry->mnSrcX, pPosAry->mnSrcY),
+                    Size(pPosAry->mnSrcWidth, pPosAry->mnSrcHeight));
+    Rectangle aDst (Point(pPosAry->mnDestX, pPosAry->mnDestY),
+                    Size(pPosAry->mnDestWidth, pPosAry->mnDestHeight));
+    
+    BitmapBuffer* pBuffer= const_cast<SalBitmap&>(rSalBitmap).AcquireBuffer(sal_True);
+    
+    SalPrinterBmp aBmp (pBuffer);
+    m_pPrinterGfx->DrawBitmap (aDst, aSrc, aBmp);
+    
+    const_cast<SalBitmap&>(rSalBitmap).ReleaseBuffer (pBuffer, sal_True);
+}
+
+void PspGraphics::drawBitmap( const SalTwoRect* pPosAry,
+                              const SalBitmap& rSalBitmap,
+                              const SalBitmap& rTransBitmap )
+{
+    DBG_ERROR("Error: no PrinterGfx::DrawBitmap() for transparent bitmap");
+}
+
+void PspGraphics::drawBitmap( const SalTwoRect* pPosAry,
+                              const SalBitmap& rSalBitmap,
+                              SalColor nTransparentColor )
+{
+    DBG_ERROR("Error: no PrinterGfx::DrawBitmap() for transparent color");
+}
+
+void PspGraphics::drawMask( const SalTwoRect* pPosAry,
+                            const SalBitmap &rSalBitmap,
+                            SalColor nMaskColor )
+{
+    DBG_ERROR("Error: PrinterGfx::DrawMask() not implemented");
+}
+
+SalBitmap* PspGraphics::getBitmap( long nX, long nY, long nDX, long nDY )
+{
+    DBG_WARNING ("Warning: PrinterGfx::GetBitmap() not implemented");
+    return NULL;
+}
+
+SalColor PspGraphics::getPixel( long nX, long nY )
+{
+    DBG_ERROR ("Warning: PrinterGfx::GetPixel() not implemented");
+    return 0;
+}
+
+void PspGraphics::invert(
+                         long		nX,
+                         long		nY,
+                         long		nDX,
+                         long		nDY,
+                         SalInvert	nFlags )
+{
+    DBG_ERROR ("Warning: PrinterGfx::Invert() not implemented");
+}
+
+/*
+ *  returns:
+ *  true: cut out positions rStart to rStop from output because fax number was swallowed
+ *  false: do nothing
+ */
+
+String PspGraphics::FaxPhoneComment( const String& rOrig, xub_StrLen nIndex, xub_StrLen& rLen, xub_StrLen& rCutStart, xub_StrLen& rCutStop ) const
+{
+    rCutStop = rCutStart = STRING_NOTFOUND;
+
+	if( ! m_pPhoneNr )
+		return String( rOrig );
+
+#define FAX_PHONE_TOKEN          "@@#"
+#define FAX_PHONE_TOKEN_LENGTH   3
+#define FAX_END_TOKEN            "@@"
+#define FAX_END_TOKEN_LENGTH     2
+
+	bool bRet = false;
+	bool bStarted = false;
+	bool bStopped = false;
+	USHORT nPos;
+	USHORT nStart = 0;
+	USHORT nStop = rLen;
+	String aPhone = rOrig.Copy( nIndex, rLen );
+
+	static String aPhoneNumber;
+	static bool bIsCollecting = false;
+
+	if( ! bIsCollecting )
+	{
+		if( ( nPos = aPhone.SearchAscii( FAX_PHONE_TOKEN ) ) != STRING_NOTFOUND )
+		{
+			nStart = nPos;
+			bIsCollecting = true;
+			aPhoneNumber.Erase();
+			bRet = true;
+			bStarted = true;
+		}
+	}
+	if( bIsCollecting )
+	{
+		bRet = true;
+		nPos = bStarted ? nStart + FAX_PHONE_TOKEN_LENGTH : 0;
+		if( ( nPos = aPhone.SearchAscii( FAX_END_TOKEN, nPos ) ) != STRING_NOTFOUND )
+		{
+			bIsCollecting = false;
+			nStop = nPos + FAX_END_TOKEN_LENGTH;
+			bStopped = true;
+		}
+		int nTokenStart = nStart + (bStarted ? FAX_PHONE_TOKEN_LENGTH : 0);
+		int nTokenStop = nStop - (bStopped ? FAX_END_TOKEN_LENGTH : 0);
+		aPhoneNumber += aPhone.Copy( nTokenStart, nTokenStop - nTokenStart );
+		if( ! bIsCollecting )
+		{
+			*m_pPhoneNr = aPhoneNumber;
+			aPhoneNumber.Erase();
+		}
+	}
+	if( aPhoneNumber.Len() > 1024 )
+	{
+		bIsCollecting = false;
+		aPhoneNumber.Erase();
+		bRet = false;
+	}
+
+    String aRet;
+    if( bRet && m_bSwallowFaxNo )
+    {
+        rLen -= nStop - nStart;
+        rCutStart = nStart+nIndex;
+        rCutStop = nStop+nIndex;
+        if( rCutStart )
+            aRet = rOrig.Copy( 0, rCutStart );
+        aRet += rOrig.Copy( rCutStop );
+    }
+    else
+        aRet = rOrig;
+
+    return aRet;
+}
+
+class PspFontLayout : public GenericSalLayout
+{
+public:
+                        PspFontLayout( ::psp::PrinterGfx& );
+    virtual bool        LayoutText( ImplLayoutArgs& );
+    virtual void        InitFont() const;
+    virtual void        DrawText( SalGraphics& ) const;
+private:
+    ::psp::PrinterGfx&  mrPrinterGfx;
+    int                 mnFontID;
+    int                 mnFontHeight;
+    int                 mnFontWidth;
+    bool                mbVertical;
+    bool				mbArtItalic;
+    bool				mbArtBold;
+};
+
+//--------------------------------------------------------------------------
+
+PspFontLayout::PspFontLayout( ::psp::PrinterGfx& rGfx )
+:   mrPrinterGfx( rGfx )
+{
+    mnFontID     = mrPrinterGfx.GetFontID();
+    mnFontHeight = mrPrinterGfx.GetFontHeight();
+    mnFontWidth  = mrPrinterGfx.GetFontWidth();
+    mbVertical   = mrPrinterGfx.GetFontVertical();
+    mbArtItalic	 = mrPrinterGfx.GetArtificialItalic();
+    mbArtBold	 = mrPrinterGfx.GetArtificialBold();
+}
+
+//--------------------------------------------------------------------------
+
+bool PspFontLayout::LayoutText( ImplLayoutArgs& rArgs )
+{
+    mbVertical = ((rArgs.mnFlags & SAL_LAYOUT_VERTICAL) != 0);
+
+    long nUnitsPerPixel = 1;
+    int nOldGlyphId = -1;
+    long nGlyphWidth = 0;
+    int nCharPos = -1;
+    Point aNewPos( 0, 0 );
+    GlyphItem aPrevItem;
+    rtl_TextEncoding aFontEnc = mrPrinterGfx.GetFontMgr().getFontEncoding( mnFontID );
+    for(;;)
+    {
+        bool bRightToLeft;
+        if( !rArgs.GetNextPos( &nCharPos, &bRightToLeft ) )
+            break;
+
+        sal_Unicode cChar = rArgs.mpStr[ nCharPos ];
+        if( bRightToLeft )
+            cChar = GetMirroredChar( cChar );
+        // symbol font aliasing: 0x0020-0x00ff -> 0xf020 -> 0xf0ff
+        if( aFontEnc == RTL_TEXTENCODING_SYMBOL )
+            if( cChar < 256 )
+                cChar += 0xf000;
+        int nGlyphIndex = cChar;  // printer glyphs = unicode
+
+        // update fallback_runs if needed
+        psp::CharacterMetric aMetric;
+        mrPrinterGfx.GetFontMgr().getMetrics( mnFontID, cChar, cChar, &aMetric, mbVertical );
+        if( aMetric.width == -1 && aMetric.height == -1 )
+            rArgs.NeedFallback( nCharPos, bRightToLeft );
+
+        // apply pair kerning to prev glyph if requested
+        if( SAL_LAYOUT_KERNING_PAIRS & rArgs.mnFlags )
+        {
+            if( nOldGlyphId > 0 )
+            {
+                const std::list< KernPair >& rKernPairs = mrPrinterGfx.getKernPairs(mbVertical);
+                for( std::list< KernPair >::const_iterator it = rKernPairs.begin();
+                     it != rKernPairs.end(); ++it )
+                {
+                    if( it->first == nOldGlyphId && it->second == nGlyphIndex )
+                    {
+                        int nTextScale = mrPrinterGfx.GetFontWidth();
+                        if( ! nTextScale )
+                            nTextScale = mrPrinterGfx.GetFontHeight();
+                        int nKern = (mbVertical ? it->kern_y : it->kern_x) * nTextScale;
+                        nGlyphWidth += nKern;
+                        aPrevItem.mnNewWidth = nGlyphWidth;
+                        break;
+                    }
+                }
+            }
+        }
+        
+        // finish previous glyph
+        if( nOldGlyphId >= 0 )
+            AppendGlyph( aPrevItem );
+        nOldGlyphId = nGlyphIndex;
+        aNewPos.X() += nGlyphWidth;
+
+        // prepare GlyphItem for appending it in next round
+        nUnitsPerPixel = mrPrinterGfx.GetCharWidth( cChar, cChar, &nGlyphWidth );
+        int nGlyphFlags = bRightToLeft ? GlyphItem::IS_RTL_GLYPH : 0;
+        nGlyphIndex |= GF_ISCHAR;
+        aPrevItem = GlyphItem( nCharPos, nGlyphIndex, aNewPos, nGlyphFlags, nGlyphWidth );
+    }
+
+    // append last glyph item if any
+    if( nOldGlyphId >= 0 )
+        AppendGlyph( aPrevItem );
+
+    SetOrientation( mrPrinterGfx.GetFontAngle() );
+    SetUnitsPerPixel( nUnitsPerPixel );
+    return (nOldGlyphId >= 0);
+}
+
+class PspServerFontLayout : public ServerFontLayout
+{
+public:
+    PspServerFontLayout( ::psp::PrinterGfx&, ServerFont& rFont );
+
+    virtual void        InitFont() const;
+private:
+    ::psp::PrinterGfx&  mrPrinterGfx;
+    int                 mnFontID;
+    int                 mnFontHeight;
+    int                 mnFontWidth;
+    bool                mbVertical;
+    bool				mbArtItalic;
+    bool				mbArtBold;
+};
+
+PspServerFontLayout::PspServerFontLayout( ::psp::PrinterGfx& rGfx, ServerFont& rFont )
+        :   ServerFontLayout( rFont ),
+            mrPrinterGfx( rGfx )
+{
+    mnFontID     = mrPrinterGfx.GetFontID();
+    mnFontHeight = mrPrinterGfx.GetFontHeight();
+    mnFontWidth  = mrPrinterGfx.GetFontWidth();
+    mbVertical   = mrPrinterGfx.GetFontVertical();
+    mbArtItalic	 = mrPrinterGfx.GetArtificialItalic();
+    mbArtBold	 = mrPrinterGfx.GetArtificialBold();
+}
+
+void PspServerFontLayout::InitFont() const
+{
+    mrPrinterGfx.SetFont( mnFontID, mnFontHeight, mnFontWidth,
+                          mnOrientation, mbVertical, mbArtItalic, mbArtBold );
+}
+
+//--------------------------------------------------------------------------
+
+void DrawPrinterLayout( const SalLayout& rLayout, ::psp::PrinterGfx& rGfx )
+{
+    const int nMaxGlyphs = 200;
+    sal_Int32   aGlyphAry[ nMaxGlyphs ];
+    sal_Int32   aWidthAry[ nMaxGlyphs ];
+    sal_Int32   aIdxAry  [ nMaxGlyphs ];
+    sal_Unicode aUnicodes[ nMaxGlyphs ];
+    Point aPos;
+    long nUnitsPerPixel = rLayout.GetUnitsPerPixel();
+    for( int nStart = 0;; )
+    {
+        int nGlyphCount = rLayout.GetNextGlyphs( nMaxGlyphs, aGlyphAry, aPos, nStart, aWidthAry );
+        if( !nGlyphCount )
+            break;
+
+        sal_Int32 nXOffset = 0;
+        for( int i = 0; i < nGlyphCount; ++i )
+        {
+            nXOffset += aWidthAry[ i ];
+            aIdxAry[ i ] = nXOffset / nUnitsPerPixel;
+            sal_uInt32 nGlyphIdx = aGlyphAry[i] & (GF_IDXMASK | GF_ROTMASK);
+            aUnicodes[i] = (aGlyphAry[i] & GF_ISCHAR) ? nGlyphIdx : 0;
+            aGlyphAry[i] = nGlyphIdx;
+        }
+
+        rGfx.DrawGlyphs( aPos, (sal_uInt32 *)aGlyphAry, aUnicodes, nGlyphCount, aIdxAry );
+    }
+}
+
+//--------------------------------------------------------------------------
+
+void PspFontLayout::InitFont() const
+{
+    mrPrinterGfx.SetFont( mnFontID, mnFontHeight, mnFontWidth,
+        mnOrientation, mbVertical, mbArtItalic, mbArtBold );
+}
+
+//--------------------------------------------------------------------------
+
+void PspFontLayout::DrawText( SalGraphics& ) const
+{
+    DrawPrinterLayout( *this, mrPrinterGfx );
+}
+
+void PspGraphics::DrawServerFontLayout( const ServerFontLayout& rLayout )
+{
+#ifdef USE_BUILTIN_RASTERIZER
+    // print complex text
+    DrawPrinterLayout( rLayout, *m_pPrinterGfx );
+#endif
+}
+
+ULONG PspGraphics::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
+
+{
+    ULONG nPairs = 0;
+#ifdef USE_BUILTIN_RASTERIZER
+    if( m_pServerFont[0] )
+        nPairs = m_pServerFont[0]->GetFontCodeRanges( pCodePairs );
+#endif //USE_BUILTIN_RASTERIZER
+    return nPairs;
+}
+
+USHORT PspGraphics::SetFont( ImplFontSelectData *pEntry, int nFallbackLevel )
+{
+    sal_Bool bVertical = pEntry->mbVertical;
+    sal_Int32 nID = pEntry->mpFontData ? (sal_Int32)pEntry->mpFontData->mpSysData : 0;
+
+    bool bArtItalic = false;
+    bool bArtBold = false;
+    if( pEntry->meItalic == ITALIC_OBLIQUE || pEntry->meItalic == ITALIC_NORMAL )
+    {
+        psp::italic::type eItalic = m_pPrinterGfx->GetFontMgr().getFontItalic( nID );
+        if( eItalic != psp::italic::Italic && eItalic != psp::italic::Oblique )
+            bArtItalic = true;
+    }
+    int nWeight = (int)pEntry->meWeight;
+    int nRealWeight = (int)m_pPrinterGfx->GetFontMgr().getFontWeight( nID );
+    if( nRealWeight < nWeight-2 ||
+        ( nRealWeight < (int)psp::weight::SemiBold && nWeight > (int)WEIGHT_NORMAL) )
+    {
+        bArtBold = true;
+    }
+
+    // also set the serverside font for layouting
+    m_bFontVertical	= pEntry->mbVertical;
+    for( int i = nFallbackLevel; i < MAX_FALLBACK; ++i )
+    {
+        if( m_pServerFont[i] != NULL )
+        {
+            // old server side font is no longer referenced
+            GlyphCache::GetInstance().UncacheFont( *m_pServerFont[i] );
+            m_pServerFont[i] = NULL;
+        }
+    }
+
+    if( pEntry->mpFontData )
+    {
+        // requesting a font provided by builtin rasterizer
+        ServerFont* pServerFont = GlyphCache::GetInstance().CacheFont( *pEntry );
+        if( pServerFont != NULL )
+        {
+            if( pServerFont->TestFont() )
+                m_pServerFont[ nFallbackLevel ] = pServerFont;
+            else
+                GlyphCache::GetInstance().UncacheFont( *pServerFont );
+        }
+        else
+            m_pServerFont[ nFallbackLevel ] = pServerFont;
+    }
+
+    // set the printer font
+    return m_pPrinterGfx->SetFont( nID,
+                                   pEntry->mnHeight,
+                                   pEntry->mnWidth,
+                                   pEntry->mnOrientation,
+                                   pEntry->mbVertical,
+                                   bArtItalic,
+                                   bArtBold
+                                   );
+}
+
+void PspGraphics::SetTextColor( SalColor nSalColor )
+{
+    psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
+                              SALCOLOR_GREEN (nSalColor),
+                              SALCOLOR_BLUE  (nSalColor));
+    m_pPrinterGfx->SetTextColor (aColor);
+}
+
+ImplFontData* PspGraphics::AddTempDevFont(const String& rFileURL, const String& rFontName )
+{
+    return NULL;
+}
+
+void PspGraphics::GetDevFontList( ImplDevFontList *pList )
+{
+    const char* pLangBoost = NULL;
+    const LanguageType aLang = Application::GetSettings().GetUILanguage();
+    switch( aLang )
+    {
+        case LANGUAGE_JAPANESE:
+            pLangBoost = "jan";    // japanese is default
+            break;
+        case LANGUAGE_CHINESE:
+        case LANGUAGE_CHINESE_SIMPLIFIED:
+        case LANGUAGE_CHINESE_SINGAPORE:
+            pLangBoost = "zhs";
+            break;
+        case LANGUAGE_CHINESE_TRADITIONAL:
+        case LANGUAGE_CHINESE_HONGKONG:
+        case LANGUAGE_CHINESE_MACAU:
+            pLangBoost = "zht";
+            break;
+        case LANGUAGE_KOREAN:
+        case LANGUAGE_KOREAN_JOHAB:
+            pLangBoost = "kor";
+            break;
+    }
+    
+    ::std::list< psp::fontID > aList;
+    const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    rMgr.getFontList( aList, m_pJobData->m_pParser );
+    
+    ::std::list< psp::fontID >::iterator it;
+    for (it = aList.begin(); it != aList.end(); ++it)
+    {
+        psp::FastPrintFontInfo aInfo;
+        if (rMgr.getFontFastInfo (*it, aInfo))
+        {
+            ImplFontData *pFontData = new ImplFontData;
+            SetImplFontData( aInfo, *pFontData );
+            pFontData->mpSysData = (void*)*it;
+            if( pFontData->maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
+                pFontData->maName = pFontData->maName.Copy( 4 );
+            if( aInfo.m_eType == psp::fonttype::TrueType )
+            {
+                // prefer truetype fonts
+                pFontData->mnQuality += 10;
+                // asian type 1 fonts are not known
+                ByteString aFileName( rMgr.getFontFileSysPath( *it ) );
+                int nPos = aFileName.SearchBackward( '_' );
+                if( nPos == STRING_NOTFOUND || aFileName.GetChar( nPos+1 ) == '.' )
+                    pFontData->mnQuality += 5;
+                else
+                {
+                    if( pLangBoost && aFileName.Copy( nPos+1, 3 ).EqualsIgnoreCaseAscii( pLangBoost ) )
+                        pFontData->mnQuality += 10;
+                }
+            }
+            pList->Add( pFontData );
+        }
+    }
+}
+
+void PspGraphics::GetDevFontSubstList( OutputDevice* pOutDev )
+{
+    const psp::PrinterInfo& rInfo = psp::PrinterInfoManager::get().getPrinterInfo( m_pJobData->m_aPrinterName );
+    if( rInfo.m_bPerformFontSubstitution )
+    {
+        for( std::hash_map< rtl::OUString, rtl::OUString, rtl::OUStringHash >::const_iterator it = rInfo.m_aFontSubstitutes.begin(); it != rInfo.m_aFontSubstitutes.end(); ++it )
+            pOutDev->ImplAddDevFontSubstitute( it->first, it->second, FONT_SUBSTITUTE_ALWAYS );
+    }
+}
+
+void PspGraphics::GetFontMetric( ImplFontMetricData *pMetric )
+{
+    const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    psp::PrintFontInfo aInfo;
+    
+    if (rMgr.getFontInfo (m_pPrinterGfx->GetFontID(), aInfo))
+    {
+        sal_Int32 nTextHeight	= m_pPrinterGfx->GetFontHeight();
+        sal_Int32 nTextWidth	= m_pPrinterGfx->GetFontWidth();
+        if( ! nTextWidth )
+            nTextWidth = nTextHeight;
+        
+        pMetric->mnOrientation 	= m_pPrinterGfx->GetFontAngle();
+        pMetric->mnSlant		= 0;
+        pMetric->mbDevice		= aInfo.m_eType == psp::fonttype::Builtin ? sal_True : sal_False;
+        
+        pMetric->meCharSet		= aInfo.m_aEncoding;
+        
+        pMetric->meFamily		= ToFontFamily (aInfo.m_eFamilyStyle);
+        pMetric->meWeight		= ToFontWeight (aInfo.m_eWeight);
+        pMetric->mePitch		= ToFontPitch  (aInfo.m_ePitch);
+        pMetric->meItalic		= ToFontItalic (aInfo.m_eItalic);
+        pMetric->meType			= TYPE_SCALABLE;
+        
+        pMetric->mnFirstChar	=   0;
+        pMetric->mnLastChar		= 255;
+        
+        pMetric->mnWidth		= nTextWidth;
+        pMetric->mnAscent		= ( aInfo.m_nAscend * nTextHeight + 500 ) / 1000;
+        pMetric->mnDescent		= ( aInfo.m_nDescend * nTextHeight + 500 ) / 1000;
+        pMetric->mnLeading		= ( aInfo.m_nLeading * nTextHeight + 500 ) / 1000;
+    }
+}
+
+ULONG PspGraphics::GetKernPairs( ULONG nPairs, ImplKernPairData *pKernPairs )
+{
+    const ::std::list< ::psp::KernPair >& rPairs( m_pPrinterGfx->getKernPairs() );
+    ULONG nHavePairs = rPairs.size();
+    if( pKernPairs && nPairs )
+    {
+        ::std::list< ::psp::KernPair >::const_iterator it;
+        int i;
+        int nTextScale = m_pPrinterGfx->GetFontWidth();
+        if( ! nTextScale )
+            nTextScale = m_pPrinterGfx->GetFontHeight();
+        for( i = 0, it = rPairs.begin(); i < nPairs && i < nHavePairs; i++, ++it )
+        {
+            pKernPairs[i].mnChar1	= it->first;
+            pKernPairs[i].mnChar2	= it->second;
+            pKernPairs[i].mnKern	= it->kern_x * nTextScale / 1000;
+        }
+        
+    }
+    return nHavePairs;
+}
+
+BOOL PspGraphics::GetGlyphBoundRect( long nGlyphIndex, Rectangle& rRect )
+{
+    int nLevel = nGlyphIndex >> GF_FONTSHIFT;
+    if( nLevel >= MAX_FALLBACK )
+        return FALSE;
+
+    ServerFont* pSF = m_pServerFont[ nLevel ];
+    if( !pSF )
+        return FALSE;
+
+    nGlyphIndex &= ~GF_FONTMASK;
+    const GlyphMetric& rGM = pSF->GetGlyphMetric( nGlyphIndex );
+    rRect = Rectangle( rGM.GetOffset(), rGM.GetSize() );
+    return TRUE;
+}
+
+BOOL PspGraphics::GetGlyphOutline( long nGlyphIndex, PolyPolygon& rPolyPoly )
+{
+    int nLevel = nGlyphIndex >> GF_FONTSHIFT;
+    if( nLevel >= MAX_FALLBACK )
+        return FALSE;
+
+    ServerFont* pSF = m_pServerFont[ nLevel ];
+    if( !pSF )
+        return FALSE;
+
+    nGlyphIndex &= ~GF_FONTMASK;
+    if( pSF->GetGlyphOutline( nGlyphIndex, rPolyPoly ) )
+        return TRUE;
+
+    return FALSE;
+}
+
+SalLayout* PspGraphics::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
+{
+    // workaround for printers not handling glyph indexing for non-TT fonts
+    int nFontId = m_pPrinterGfx->GetFontID();
+    if( psp::fonttype::TrueType != psp::PrintFontManager::get().getFontType( nFontId ) )
+        rArgs.mnFlags |= SAL_LAYOUT_DISABLE_GLYPH_PROCESSING;
+    else if( nFallbackLevel > 0 )
+        rArgs.mnFlags &= ~SAL_LAYOUT_DISABLE_GLYPH_PROCESSING;
+
+    GenericSalLayout* pLayout = NULL;
+
+    if( m_pServerFont[ nFallbackLevel ]
+        && !(rArgs.mnFlags & SAL_LAYOUT_DISABLE_GLYPH_PROCESSING) )
+        pLayout = new PspServerFontLayout( *m_pPrinterGfx, *m_pServerFont[nFallbackLevel] );
+    else
+        pLayout = new PspFontLayout( *m_pPrinterGfx );
+
+    return pLayout;
+}
+//--------------------------------------------------------------------------
+
+BOOL PspGraphics::CreateFontSubset(
+                                   const rtl::OUString& rToFile,
+                                   ImplFontData* pFont,
+                                   sal_Int32* pGlyphIDs,
+                                   sal_uInt8* pEncoding,
+                                   sal_Int32* pWidths,
+                                   int nGlyphs,
+                                   FontSubsetInfo& rInfo
+                                   )
+{
+    // in this context the sysdata member of pFont should
+    // contain a fontID as the X fonts should be filtered
+    // out of the font list available to PDF export (for
+    // which this method was created). The correct way would
+    // be to have the GlyphCache search for the ImplFontData pFont
+    psp::fontID aFont = (psp::fontID)pFont->mpSysData;
+    return PspGraphics::DoCreateFontSubset( rToFile, aFont, pGlyphIDs, pEncoding, pWidths, nGlyphs, rInfo );
+}
+
+//--------------------------------------------------------------------------
+
+const void* PspGraphics::GetEmbedFontData( ImplFontData* pFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
+{
+    // in this context the sysdata member of pFont should
+    // contain a fontID as the X fonts should be filtered
+    // out of the font list available to PDF export (for
+    // which this method was created). The correct way would
+    // be to have the GlyphCache search for the ImplFontData pFont
+    psp::fontID aFont = (psp::fontID)pFont->mpSysData;
+    return PspGraphics::DoGetEmbedFontData( aFont, pUnicodes, pWidths, rInfo, pDataLen );
+}
+
+//--------------------------------------------------------------------------
+
+void PspGraphics::FreeEmbedFontData( const void* pData, long nLen )
+{
+    PspGraphics::DoFreeEmbedFontData( pData, nLen );
+}
+
+//--------------------------------------------------------------------------
+
+const std::map< sal_Unicode, sal_Int32 >* PspGraphics::GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
+{
+    // in this context the sysdata member of pFont should
+    // contain a fontID as the X fonts should be filtered
+    // out of the font list available to PDF export (for
+    // which this method was created). The correct way would
+    // be to have the GlyphCache search for the ImplFontData pFont
+    psp::fontID aFont = (psp::fontID)pFont->mpSysData;
+    return PspGraphics::DoGetFontEncodingVector( aFont, pNonEncoded );
+}
+
+
+// static helpers of PspGraphics
+
+bool PspGraphics::DoCreateFontSubset( const rtl::OUString& rToFile,
+                                      psp::fontID aFont,
+                                      sal_Int32* pGlyphIDs,
+                                      sal_uInt8* pEncoding,
+                                      sal_Int32* pWidths,
+                                      int nGlyphs,
+                                      FontSubsetInfo& rInfo )
+{
+    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    psp::PrintFontInfo aFontInfo;
+    
+    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
+        return false;
+    
+    // fill in font info
+    switch( aFontInfo.m_eType )
+    {
+        case psp::fonttype::TrueType: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TRUETYPE;break;
+        case psp::fonttype::Type1: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TYPE1;break;
+        default:
+            return false;
+    }
+    rInfo.m_nAscent     = aFontInfo.m_nAscend;
+    rInfo.m_nDescent    = aFontInfo.m_nDescend;
+    rInfo.m_aPSName     = rMgr.getPSName( aFont );
+    
+    int xMin, yMin, xMax, yMax;
+    rMgr.getFontBoundingBox( aFont, xMin, yMin, xMax, yMax );
+    
+    if( ! rMgr.createFontSubset( aFont,
+                                 rToFile,
+                                 pGlyphIDs,
+                                 pEncoding,
+                                 pWidths,
+                                 nGlyphs
+                                 ) )
+        return false;
+
+    rInfo.m_aFontBBox	= Rectangle( Point( xMin, yMin ), Size( xMax-xMin, yMax-yMin ) );
+    rInfo.m_nCapHeight	= yMax; // Well ...
+
+    return true;
+}
+
+const void* PspGraphics::DoGetEmbedFontData( fontID aFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
+{
+    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    
+    psp::PrintFontInfo aFontInfo;
+    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
+        return NULL;
+    
+    // fill in font info
+    switch( aFontInfo.m_eType )
+    {
+        case psp::fonttype::TrueType: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TRUETYPE;break;
+        case psp::fonttype::Type1: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TYPE1;break;
+        default:
+            return NULL;
+    }
+    rInfo.m_nAscent		= aFontInfo.m_nAscend;
+    rInfo.m_nDescent	= aFontInfo.m_nDescend;
+    rInfo.m_aPSName		= rMgr.getPSName( aFont );
+    
+    int xMin, yMin, xMax, yMax;
+    rMgr.getFontBoundingBox( aFont, xMin, yMin, xMax, yMax );
+    
+    psp::CharacterMetric aMetrics[256];
+    sal_Unicode aUnicodes[256];
+    if( aFontInfo.m_aEncoding == RTL_TEXTENCODING_SYMBOL && aFontInfo.m_eType == psp::fonttype::Type1 )
+    {
+        for( int i = 0; i < 256; i++ )
+            aUnicodes[i] = pUnicodes[i] < 0x0100 ? pUnicodes[i] + 0xf000 : pUnicodes[i];
+        pUnicodes = aUnicodes;
+    }
+    if( ! rMgr.getMetrics( aFont, pUnicodes, 256, aMetrics ) )
+        return NULL;
+    
+    OString aSysPath = rMgr.getFontFileSysPath( aFont );
+    struct stat aStat;
+    if( stat( aSysPath.getStr(), &aStat ) )
+        return NULL;
+    int fd = open( aSysPath.getStr(), O_RDONLY );
+    if( fd < 0 )
+        return NULL;
+    void* pFile = mmap( NULL, aStat.st_size, PROT_READ, MAP_SHARED, fd, 0 );
+    close( fd );
+    if( pFile == MAP_FAILED )
+        return NULL;
+    
+    *pDataLen = aStat.st_size;
+    
+    rInfo.m_aFontBBox	= Rectangle( Point( xMin, yMin ), Size( xMax-xMin, yMax-yMin ) );
+    rInfo.m_nCapHeight	= yMax; // Well ...
+    
+    for( int i = 0; i < 256; i++ )
+        
+        pWidths[i] = (aMetrics[i].width > 0 ? aMetrics[i].width : 0);
+    
+    return pFile;
+}
+
+void PspGraphics::DoFreeEmbedFontData( const void* pData, long nLen )
+{
+    if( pData )
+        munmap( (char*)pData, nLen );
+}
+
+const std::map< sal_Unicode, sal_Int32 >* PspGraphics::DoGetFontEncodingVector( fontID aFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
+{
+    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    
+    psp::PrintFontInfo aFontInfo;
+    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
+    {
+        if( pNonEncoded )
+            *pNonEncoded = NULL;
+        return NULL;
+    }
+
+    return rMgr.getEncodingMap( aFont, pNonEncoded );
+}
+
+void PspGraphics::SetImplFontData( const psp::FastPrintFontInfo& aInfo, ImplFontData& rData )
+{
+	rData.meFamily     	= ToFontFamily (aInfo.m_eFamilyStyle);
+	rData.meWeight     	= ToFontWeight (aInfo.m_eWeight);
+
+	rData.meItalic     	= ToFontItalic (aInfo.m_eItalic);
+	rData.meWidthType  	= ToFontWidth  (aInfo.m_eWidth);
+	rData.mePitch	   	= ToFontPitch  (aInfo.m_ePitch);
+	rData.meCharSet    	= aInfo.m_aEncoding;
+	rData.maName		= aInfo.m_aFamilyName;
+	// rData.meScript		= SCRIPT_DONTKNOW;
+	/*rData.maStyleName	= XXX */
+
+	rData.mnWidth		= 0;
+	rData.mnHeight		= 0;
+	rData.mbOrientation	= TRUE;
+	rData.mnQuality		= (aInfo.m_eType == psp::fonttype::Builtin ? 1024 : 0);
+	rData.mnVerticalOrientation= 0;
+	rData.meType		= TYPE_SCALABLE;
+	rData.mbDevice		= (aInfo.m_eType == psp::fonttype::Builtin);
+    String aMapNames;
+    for( ::std::list< OUString >::const_iterator it = aInfo.m_aAliases.begin(); it != aInfo.m_aAliases.end(); ++it )
+    {
+        if( it != aInfo.m_aAliases.begin() )
+            aMapNames.Append(';');
+        aMapNames.Append( String( *it ) );
+    }
+    rData.maMapNames	= aMapNames;
+    switch( aInfo.m_eType )
+    {
+        case psp::fonttype::TrueType:
+            rData.mbSubsettable	= TRUE;
+            rData.mbEmbeddable	= FALSE;
+            break;
+        case psp::fonttype::Type1:
+            rData.mbSubsettable	= FALSE;
+            rData.mbEmbeddable	= TRUE;
+            break;
+        default:
+            rData.mbSubsettable = FALSE;
+            rData.mbEmbeddable	= FALSE;
+            break;
+    }
+}
+
+FontWidth PspGraphics::ToFontWidth (psp::width::type eWidth)
+{
+	switch (eWidth)
+	{
+		case psp::width::UltraCondensed: return WIDTH_ULTRA_CONDENSED;
+		case psp::width::ExtraCondensed: return WIDTH_EXTRA_CONDENSED;
+		case psp::width::Condensed:		 return WIDTH_CONDENSED;
+		case psp::width::SemiCondensed:	 return WIDTH_SEMI_CONDENSED;
+		case psp::width::Normal:		 return WIDTH_NORMAL;
+		case psp::width::SemiExpanded:	 return WIDTH_SEMI_EXPANDED;
+		case psp::width::Expanded:		 return WIDTH_EXPANDED;
+		case psp::width::ExtraExpanded:	 return WIDTH_EXTRA_EXPANDED;
+		case psp::width::UltraExpanded:	 return WIDTH_ULTRA_EXPANDED;
+	}
+	return WIDTH_DONTKNOW;
+}
+
+FontWeight PspGraphics::ToFontWeight (psp::weight::type eWeight)
+{
+	switch (eWeight)
+	{
+		case psp::weight::Thin:		  return WEIGHT_THIN;
+		case psp::weight::UltraLight: return WEIGHT_ULTRALIGHT;
+		case psp::weight::Light:	  return WEIGHT_LIGHT;
+		case psp::weight::SemiLight:  return WEIGHT_SEMILIGHT;
+		case psp::weight::Normal:	  return WEIGHT_NORMAL;
+		case psp::weight::Medium:	  return WEIGHT_MEDIUM;
+		case psp::weight::SemiBold:	  return WEIGHT_SEMIBOLD;
+		case psp::weight::Bold:		  return WEIGHT_BOLD;
+		case psp::weight::UltraBold:  return WEIGHT_ULTRABOLD;
+		case psp::weight::Black:	  return WEIGHT_BLACK;
+	}
+	return WEIGHT_DONTKNOW;
+}
+
+FontPitch PspGraphics::ToFontPitch (psp::pitch::type ePitch)
+{
+	switch (ePitch)
+	{
+		case psp::pitch::Fixed:		return PITCH_FIXED;
+		case psp::pitch::Variable:	return PITCH_VARIABLE;
+	}
+	return PITCH_DONTKNOW;
+}
+
+FontItalic PspGraphics::ToFontItalic (psp::italic::type eItalic)
+{
+	switch (eItalic)
+	{
+		case psp::italic::Upright:	return ITALIC_NONE;
+		case psp::italic::Oblique:	return ITALIC_OBLIQUE;
+		case psp::italic::Italic:	return ITALIC_NORMAL;
+	}
+	return ITALIC_DONTKNOW;
+}
+
+FontFamily PspGraphics::ToFontFamily (psp::family::type eFamily)
+{
+	switch (eFamily)
+	{
+		case psp::family::Decorative: return FAMILY_DECORATIVE;
+		case psp::family::Modern:	  return FAMILY_MODERN;
+		case psp::family::Roman:	  return FAMILY_ROMAN;
+		case psp::family::Script:	  return FAMILY_SCRIPT;
+		case psp::family::Swiss:	  return FAMILY_SWISS;
+		case psp::family::System:	  return FAMILY_SYSTEM;
+	}
+	return FAMILY_DONTKNOW;
+}
Index: vcl/unx/source/gdi/salbmp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/salbmp.cxx,v
retrieving revision 1.8.274.1
retrieving revision 1.14
diff -u -p -u -r1.8.274.1 -r1.14
--- vcl/unx/source/gdi/salbmp.cxx	15 Jan 2004 12:52:46 -0000	1.8.274.1
+++ vcl/unx/source/gdi/salbmp.cxx	22 Jun 2004 17:42:38 -0000	1.14
@@ -59,20 +59,18 @@
  *
  ************************************************************************/
 
-#define _SV_SALBMP_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
 #include <string.h>
 #include <stdio.h>
 #include <errno.h>
 #ifdef FREEBSD
 #include <sys/types.h>
 #endif
-#include <sys/shm.h>
 #include <prex.h>
 #include <postx.h>
 #include <salunx.h>
+#ifndef _OSL_ENDIAN_H_
+#include <osl/endian.h>
+#endif
 #ifndef _RTL_MEMORY_H_
 #include <rtl/memory.h>
 #endif
@@ -85,11 +83,14 @@
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
+#endif
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
 #endif
-#ifndef _SV_SALBMP_HXX
-#include <salbmp.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
 
 // -----------
@@ -102,12 +103,17 @@
 // - SalBitmap -
 // -------------
 
-ImplSalBitmapCache*	SalBitmap::mpCache = NULL;
-ULONG				SalBitmap::mnCacheInstCount = 0;
+SalBitmap* X11SalInstance::CreateSalBitmap()
+{
+    return new X11SalBitmap();
+}
+
+ImplSalBitmapCache*	X11SalBitmap::mpCache = NULL;
+ULONG				X11SalBitmap::mnCacheInstCount = 0;
 
 // -----------------------------------------------------------------------------
 
-SalBitmap::SalBitmap() :
+X11SalBitmap::X11SalBitmap() :
 	mpDIB( NULL ),
 	mpDDB( NULL )
 {
@@ -115,14 +121,14 @@ SalBitmap::SalBitmap() :
 
 // -----------------------------------------------------------------------------
 
-SalBitmap::~SalBitmap()
+X11SalBitmap::~X11SalBitmap()
 {
 	Destroy();
 }
 
 // -----------------------------------------------------------------------------
 
-void SalBitmap::ImplCreateCache()
+void X11SalBitmap::ImplCreateCache()
 {
 	if( !mnCacheInstCount++ )
 		mpCache = new ImplSalBitmapCache;
@@ -130,9 +136,9 @@ void SalBitmap::ImplCreateCache()
 
 // -----------------------------------------------------------------------------
 
-void SalBitmap::ImplDestroyCache()
+void X11SalBitmap::ImplDestroyCache()
 {
-	DBG_ASSERT( mnCacheInstCount, "SalBitmap::ImplDestroyCache(): underflow" );
+	DBG_ASSERT( mnCacheInstCount, "X11SalBitmap::ImplDestroyCache(): underflow" );
 
 	if( mnCacheInstCount && !--mnCacheInstCount )
 		delete mpCache, mpCache = NULL;
@@ -140,7 +146,7 @@ void SalBitmap::ImplDestroyCache()
 
 // -----------------------------------------------------------------------------
 
-void SalBitmap::ImplRemovedFromCache()
+void X11SalBitmap::ImplRemovedFromCache()
 {
 	if( mpDDB )
 		delete mpDDB, mpDDB = NULL;
@@ -148,7 +154,7 @@ void SalBitmap::ImplRemovedFromCache()
 
 // -----------------------------------------------------------------------------
 
-BitmapBuffer* SalBitmap::ImplCreateDIB( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
+BitmapBuffer* X11SalBitmap::ImplCreateDIB( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
 {
 	DBG_ASSERT( nBitCount == 1 || nBitCount == 4 || nBitCount == 8 || nBitCount == 24, "Unsupported BitCount!" );
 
@@ -198,7 +204,7 @@ BitmapBuffer* SalBitmap::ImplCreateDIB( 
 
 // -----------------------------------------------------------------------------
 
-BitmapBuffer* SalBitmap::ImplCreateDIB( Drawable aDrawable,
+BitmapBuffer* X11SalBitmap::ImplCreateDIB( Drawable aDrawable,
 										long nDrawableDepth,
 										long nX, long nY,
 										long nWidth, long nHeight )
@@ -207,7 +213,7 @@ BitmapBuffer* SalBitmap::ImplCreateDIB( 
 
 	if( aDrawable && nWidth && nHeight && nDrawableDepth )
 	{
-		SalDisplay*	pSalDisp = GetSalData()->GetCurDisp();
+		SalDisplay*	pSalDisp = GetSalData()->GetDisplay();
 		SalXLib*	pXLib = pSalDisp->GetXLib();
 		Display*	pXDisp = pSalDisp->GetDisplay();
 
@@ -342,13 +348,13 @@ BitmapBuffer* SalBitmap::ImplCreateDIB( 
 
 // -----------------------------------------------------------------------------
 
-XImage*	SalBitmap::ImplCreateXImage( SalDisplay *pSalDisp, long nDepth, const SalTwoRect& rTwoRect ) const
+XImage*	X11SalBitmap::ImplCreateXImage( SalDisplay *pSalDisp, long nDepth, const SalTwoRect& rTwoRect ) const
 {
 	XImage* pImage = NULL;
 
 	if( !mpDIB && mpDDB )
 	{
-	    ( (SalBitmap*) this )->mpDIB = ImplCreateDIB( mpDDB->ImplGetPixmap(), 
+	    const_cast<X11SalBitmap*>(this)->mpDIB = ImplCreateDIB( mpDDB->ImplGetPixmap(), 
 													  mpDDB->ImplGetDepth(),
 													  0, 0, 
 													  mpDDB->ImplGetWidth(), 
@@ -391,14 +397,14 @@ XImage*	SalBitmap::ImplCreateXImage( Sal
 				
 				case( 16 ):
 				{
-                    #ifdef __BIGENDIAN
+                    #ifdef OSL_BIGENDIAN
 					
                     if( MSBFirst == pImage->byte_order )
 					    nDstFormat |= BMP_FORMAT_16BIT_TC_MSB_MASK;
                     else
 					    nDstFormat |= BMP_FORMAT_16BIT_TC_LSB_MASK;
                     
-                    #else /* __LITTLEENDIAN */
+                    #else /* OSL_LITENDIAN */
 
 					nDstFormat |= BMP_FORMAT_16BIT_TC_LSB_MASK;
 					if( MSBFirst == pImage->byte_order )
@@ -478,7 +484,7 @@ XImage*	SalBitmap::ImplCreateXImage( Sal
 
 // -----------------------------------------------------------------------------
 #ifdef _USE_PRINT_EXTENSION_
-BOOL SalBitmap::ImplCreateFromDrawable(  SalDisplay* pDisplay, Drawable aDrawable, long nDrawableDepth, 
+bool X11SalBitmap::ImplCreateFromDrawable(  SalDisplay* pDisplay, Drawable aDrawable, long nDrawableDepth, 
 										long nX, long nY, long nWidth, long nHeight )
 {
 	Destroy();
@@ -489,7 +495,7 @@ BOOL SalBitmap::ImplCreateFromDrawable( 
 	return( mpDDB != NULL );
 }
 #else
-BOOL SalBitmap::ImplCreateFromDrawable(  Drawable aDrawable, long nDrawableDepth, 
+bool X11SalBitmap::ImplCreateFromDrawable(  Drawable aDrawable, long nDrawableDepth, 
 										long nX, long nY, long nWidth, long nHeight )
 {
 	Destroy();
@@ -502,19 +508,8 @@ BOOL SalBitmap::ImplCreateFromDrawable( 
 // -----------------------------------------------------------------------------
 #endif
 
-BOOL SalBitmap::ImplCreateLocalFromDrawable(  Drawable aDrawable, long nDrawableDepth, 
-											  long nX, long nY, long nWidth, long nHeight )
-{
-	Destroy();
-
-	if( aDrawable && nWidth && nHeight && nDrawableDepth )
-        mpDIB = ImplCreateDIB( aDrawable, nDrawableDepth, nX, nY, nWidth, nHeight );
-
-	return( mpDIB != NULL );
-}
-
-BOOL 
-SalBitmap::SnapShot (Display* pDisplay, XLIB_Window hWindow)
+bool 
+X11SalBitmap::SnapShot (Display* pDisplay, XLIB_Window hWindow)
 {
     if (hWindow != None)
     {
@@ -577,7 +572,7 @@ SalBitmap::SnapShot (Display* pDisplay, 
                 {
                     XImage* pImage = XGetImage (pDisplay, aAttribute.root, 
                                                 x, y, width, height, AllPlanes, ZPixmap);
-                    BOOL bSnapShot = ImplCreateFromXImage (pDisplay, aAttribute.root, pImage);
+                    bool bSnapShot = ImplCreateFromXImage (pDisplay, aAttribute.root, pImage);
                     XDestroyImage (pImage);
 
                     return bSnapShot;
@@ -589,8 +584,8 @@ SalBitmap::SnapShot (Display* pDisplay, 
     return False;
 }
 
-BOOL 
-SalBitmap::ImplCreateFromXImage (Display* pDisplay, XLIB_Window hWindow, XImage* pImage)
+bool 
+X11SalBitmap::ImplCreateFromXImage (Display* pDisplay, XLIB_Window hWindow, XImage* pImage)
 {
     Destroy();
 
@@ -603,8 +598,8 @@ SalBitmap::ImplCreateFromXImage (Display
 }
 
 #ifdef _USE_PRINT_EXTENSION_
-void SalBitmap::ImplDraw( SalDisplay *pDisplay, Drawable aDrawable, long nDrawableDepth, 
-						  const SalTwoRect& rTwoRect, const GC& rGC ) const
+void X11SalBitmap::ImplDraw( SalDisplay *pDisplay, Drawable aDrawable, long nDrawableDepth, 
+						  const SalTwoRect& rTwoRect, const GC& rGC, bool bDstIsWindow ) const
 {
 	if( !mpDDB || !mpDDB->ImplMatches( nDrawableDepth, rTwoRect ) )
 	{
@@ -654,11 +649,11 @@ void SalBitmap::ImplDraw( SalDisplay *pD
 	}
 
 	if( mpDDB )
-		mpDDB->ImplDraw( pDisplay, aDrawable, nDrawableDepth, rTwoRect, rGC );
+		mpDDB->ImplDraw( pDisplay, aDrawable, nDrawableDepth, rTwoRect, rGC, bDstIsWindow );
 }
 #else
-void SalBitmap::ImplDraw( Drawable aDrawable, long nDrawableDepth, 
-						  const SalTwoRect& rTwoRect, const GC& rGC ) const
+void X11SalBitmap::ImplDraw( Drawable aDrawable, long nDrawableDepth, 
+						  const SalTwoRect& rTwoRect, const GC& rGC, bool bDstIsWindow ) const
 {
 	if( !mpDDB || !mpDDB->ImplMatches( nDrawableDepth, rTwoRect ) )
 	{
@@ -667,18 +662,18 @@ void SalBitmap::ImplDraw( Drawable aDraw
 			// do we already have a DIB? if not, create aDIB from current DDB first
 			if( !mpDIB )
 			{
-				( (SalBitmap*) this )->mpDIB = ImplCreateDIB( mpDDB->ImplGetPixmap(), 
+				const_cast<X11SalBitmap*>(this)->mpDIB = ImplCreateDIB( mpDDB->ImplGetPixmap(), 
 															  mpDDB->ImplGetDepth(),
 															  0, 0, 
 															  mpDDB->ImplGetWidth(), 
 															  mpDDB->ImplGetHeight() );
 			}
 
-			delete mpDDB, ( (SalBitmap*) this )->mpDDB = NULL;
+			delete mpDDB, const_cast<X11SalBitmap*>(this)->mpDDB = NULL;
 		}
 
 		if( mpCache )
-			mpCache->ImplRemove( const_cast<SalBitmap*>(this) );
+			mpCache->ImplRemove( const_cast<X11SalBitmap*>(this) );
 
 		SalTwoRect aTwoRect( rTwoRect );
 
@@ -693,28 +688,28 @@ void SalBitmap::ImplDraw( Drawable aDraw
 			aTwoRect.mnSrcHeight = aTwoRect.mnDestHeight = aSize.Height();
 		}
 
-		XImage*	pImage = ImplCreateXImage( GetSalData()->GetCurDisp(), 
+		XImage*	pImage = ImplCreateXImage( GetSalData()->GetDisplay(), 
 				nDrawableDepth, aTwoRect );
 
 		if( pImage )
 		{
-			( (SalBitmap*) this )->mpDDB = new ImplSalDDB( pImage, aDrawable, aTwoRect );
+			const_cast<X11SalBitmap*>(this)->mpDDB = new ImplSalDDB( pImage, aDrawable, aTwoRect );
 			delete[] pImage->data, pImage->data = NULL;
 			XDestroyImage( pImage );
 
 			if( mpCache )
-				mpCache->ImplAdd( const_cast<SalBitmap*>(this), mpDDB->ImplGetMemSize() );
+				mpCache->ImplAdd( const_cast<X11SalBitmap*>(this), mpDDB->ImplGetMemSize() );
 		}
 	}
 
 	if( mpDDB )
-		mpDDB->ImplDraw( aDrawable, nDrawableDepth, rTwoRect, rGC );
+		mpDDB->ImplDraw( aDrawable, nDrawableDepth, rTwoRect, rGC, bDstIsWindow );
 }
 #endif
 
 // -----------------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
+bool X11SalBitmap::Create( const Size& rSize, USHORT nBitCount, const BitmapPalette& rPal )
 {
 	Destroy();
 	mpDIB = ImplCreateDIB( rSize, nBitCount, rPal );
@@ -724,14 +719,14 @@ BOOL SalBitmap::Create( const Size& rSiz
 
 // -----------------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBmp )
+bool X11SalBitmap::Create( const SalBitmap& rSSalBmp )
 {
 	Destroy();
 
+    const X11SalBitmap& rSalBmp = static_cast<const X11SalBitmap&>( rSSalBmp );
+
 	if( rSalBmp.mpDIB )
 	{
-		const Size aSize( rSalBmp.GetSize() );
-
 		mpDIB = ImplCreateDIB( rSalBmp.GetSize(), rSalBmp.GetBitCount(), rSalBmp.mpDIB->maPalette );
 		
 		if( mpDIB )
@@ -752,21 +747,21 @@ BOOL SalBitmap::Create( const SalBitmap&
 
 // -----------------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBmp, SalGraphics* pGraphics )
+bool X11SalBitmap::Create( const SalBitmap& rSalBmp, SalGraphics* pGraphics )
 {
 	return FALSE;
 }
 
 // -----------------------------------------------------------------------------
 
-BOOL SalBitmap::Create( const SalBitmap& rSalBmp, USHORT nNewBitCount )
+bool X11SalBitmap::Create( const SalBitmap& rSalBmp, USHORT nNewBitCount )
 {
 	return FALSE;
 }
 
 // -----------------------------------------------------------------------------
 
-void SalBitmap::Destroy()
+void X11SalBitmap::Destroy()
 {
 	if( mpDIB )
 	{
@@ -783,7 +778,7 @@ void SalBitmap::Destroy()
 
 // -----------------------------------------------------------------------------
 
-Size SalBitmap::GetSize() const
+Size X11SalBitmap::GetSize() const
 {
 	Size aSize;
 
@@ -797,7 +792,7 @@ Size SalBitmap::GetSize() const
 
 // -----------------------------------------------------------------------------
 
-USHORT SalBitmap::GetBitCount() const
+USHORT X11SalBitmap::GetBitCount() const
 {
 	USHORT nBitCount;
 
@@ -825,7 +820,7 @@ USHORT SalBitmap::GetBitCount() const
 
 // -----------------------------------------------------------------------------
 
-BitmapBuffer* SalBitmap::AcquireBuffer( BOOL bReadOnly )
+BitmapBuffer* X11SalBitmap::AcquireBuffer( bool bReadOnly )
 {
 	if( !mpDIB && mpDDB )
 	{
@@ -838,7 +833,7 @@ BitmapBuffer* SalBitmap::AcquireBuffer( 
 
 // -----------------------------------------------------------------------------
 
-void SalBitmap::ReleaseBuffer( BitmapBuffer* pBuffer, BOOL bReadOnly )
+void X11SalBitmap::ReleaseBuffer( BitmapBuffer* pBuffer, bool bReadOnly )
 {
 	if( !bReadOnly )
 	{
@@ -864,14 +859,14 @@ ImplSalDDB::ImplSalDDB( 
 	mnDepth		( pImage->depth )
 {
 #if !defined(_USE_PRINT_EXTENSION_)	
-	SalDisplay*	pSalDisp = GetSalData()->GetCurDisp();
+	SalDisplay*	pSalDisp = GetSalData()->GetDisplay();
 	Display*	pXDisp = pSalDisp->GetDisplay();
 #else
 	Display*	pXDisp = pDisplay->GetDisplay();
 #endif
 
 
-	if( maPixmap = XCreatePixmap( pXDisp, aDrawable, ImplGetWidth(), ImplGetHeight(), ImplGetDepth() ) )
+	if( (maPixmap = XCreatePixmap( pXDisp, aDrawable, ImplGetWidth(), ImplGetHeight(), ImplGetDepth() )) )
 	{
 		XGCValues	aValues;
 		GC			aGC;
@@ -939,13 +934,13 @@ ImplSalDDB::ImplSalDDB( 
 	mnDepth( nDrawableDepth )
 {
 #if !defined(_USE_PRINT_EXTENSION_)	
-	SalDisplay*	pSalDisp = GetSalData()->GetCurDisp();
+	SalDisplay*	pSalDisp = GetSalData()->GetDisplay();
 	Display*	pXDisp = pSalDisp->GetDisplay();
 #else
 	Display*	pXDisp = pDisplay->GetDisplay();
 #endif
 
-	if( maPixmap = XCreatePixmap( pXDisp, aDrawable, nWidth, nHeight, nDrawableDepth ) )
+	if( (maPixmap = XCreatePixmap( pXDisp, aDrawable, nWidth, nHeight, nDrawableDepth )) )
 	{
 		XGCValues	aValues;
 		GC			aGC;
@@ -962,10 +957,10 @@ ImplSalDDB::ImplSalDDB( 
 		aGC = XCreateGC( pXDisp, maPixmap, nValues, &aValues );
 #ifdef _USE_PRINT_EXTENSION_
 		ImplDraw( pDisplay, aDrawable, nDrawableDepth, maPixmap, mnDepth,
-				  nX, nY, nWidth, nHeight, 0, 0, aGC );
+				  nX, nY, nWidth, nHeight, 0, 0, aGC, false );
 #else
 		ImplDraw( aDrawable, nDrawableDepth, maPixmap, mnDepth,
-				  nX, nY, nWidth, nHeight, 0, 0, aGC );
+				  nX, nY, nWidth, nHeight, 0, 0, aGC, false );
 #endif
 		XFreeGC( pXDisp, aGC );
 
@@ -980,14 +975,14 @@ ImplSalDDB::ImplSalDDB( 
 ImplSalDDB::~ImplSalDDB()
 {
 	if( maPixmap && ImplGetSVData() )
-		XFreePixmap( GetSalData()->GetCurDisp()->GetDisplay(), maPixmap );
+		XFreePixmap( GetSalData()->GetDisplay()->GetDisplay(), maPixmap );
 }
 
 // -----------------------------------------------------------------------------
 
-BOOL ImplSalDDB::ImplMatches( long nDepth, const SalTwoRect& rTwoRect ) const
+bool ImplSalDDB::ImplMatches( long nDepth, const SalTwoRect& rTwoRect ) const
 {
-	BOOL bRet = FALSE;
+	bool bRet = FALSE;
 
 	if( ( maPixmap != 0 ) && ( ( mnDepth == nDepth ) || ( 1 == mnDepth ) ) )
 	{
@@ -1017,18 +1012,18 @@ void ImplSalDDB::ImplDraw( 
 #ifdef _USE_PRINT_EXTENSION_
 				SalDisplay* pDisplay,
 #endif
-				Drawable aDrawable, long nDrawableDepth, const SalTwoRect& rTwoRect, const GC& rGC ) const
+				Drawable aDrawable, long nDrawableDepth, const SalTwoRect& rTwoRect, const GC& rGC, bool bDstIsWindow ) const
 {
 #ifdef _USE_PRINT_EXTENSION_
 	ImplDraw( pDisplay, maPixmap, mnDepth, aDrawable, nDrawableDepth, 
 			  rTwoRect.mnSrcX - maTwoRect.mnSrcX, rTwoRect.mnSrcY - maTwoRect.mnSrcY,
 			  rTwoRect.mnDestWidth, rTwoRect.mnDestHeight,
-			  rTwoRect.mnDestX, rTwoRect.mnDestY, rGC );
+			  rTwoRect.mnDestX, rTwoRect.mnDestY, rGC, bDstIsWindow );
 #else
 	ImplDraw( maPixmap, mnDepth, aDrawable, nDrawableDepth, 
 			  rTwoRect.mnSrcX - maTwoRect.mnSrcX, rTwoRect.mnSrcY - maTwoRect.mnSrcY,
 			  rTwoRect.mnDestWidth, rTwoRect.mnDestHeight,
-			  rTwoRect.mnDestX, rTwoRect.mnDestY, rGC );
+			  rTwoRect.mnDestX, rTwoRect.mnDestY, rGC, bDstIsWindow );
 #endif
 }
 
@@ -1042,10 +1037,10 @@ void ImplSalDDB::ImplDraw( 
 						   Drawable aDstDrawable, long nDstDrawableDepth,
 						   long nSrcX, long nSrcY, 
 						   long nDestWidth, long nDestHeight, 
-						   long nDestX, long nDestY, const GC& rGC )
+						   long nDestX, long nDestY, const GC& rGC, bool bDstIsWindow )
 {
 #if !defined(_USE_PRINT_EXTENSION_)
-	SalDisplay*	pSalDisp = GetSalData()->GetCurDisp();
+	SalDisplay*	pSalDisp = GetSalData()->GetDisplay();
 	Display*	pXDisp = pSalDisp->GetDisplay();
 #else
 	Display*	pXDisp = pDisplay->GetDisplay();
@@ -1058,18 +1053,11 @@ void ImplSalDDB::ImplDraw( 
 	}
 	else
 	{
-		if( nDestWidth > SAL_DRAWPIXMAP_MAX_EXT )
-		{
-			// !!! Broken XCopyArea
-			XCopyArea( pXDisp, aSrcDrawable, aDstDrawable, rGC,
-					   nSrcX, nSrcY, nDestWidth, nDestHeight, nDestX, nDestY );
-		}
-		else
-		{
-			XCopyArea( pXDisp, aSrcDrawable, aDstDrawable, rGC,
-					   nSrcX, nSrcY, nDestWidth, nDestHeight, nDestX, nDestY );
-		}
+        XCopyArea( pXDisp, aSrcDrawable, aDstDrawable, rGC,
+                   nSrcX, nSrcY, nDestWidth, nDestHeight, nDestX, nDestY );
 	}
+    if( bDstIsWindow )
+        X11SalGraphics::YieldGraphicsExpose( pXDisp, NULL, aDstDrawable );
 }
 
 // ----------------------
@@ -1078,11 +1066,11 @@ void ImplSalDDB::ImplDraw( 
 
 struct ImplBmpObj
 {
-	SalBitmap*	mpBmp;
+	X11SalBitmap*	mpBmp;
 	ULONG		mnMemSize;
 	ULONG		mnFlags;
 
-				ImplBmpObj( SalBitmap* pBmp, ULONG nMemSize, ULONG nFlags ) :
+				ImplBmpObj( X11SalBitmap* pBmp, ULONG nMemSize, ULONG nFlags ) :
 					mpBmp( pBmp ), mnMemSize( nMemSize ), mnFlags( nFlags ) {}
 };
 
@@ -1102,10 +1090,10 @@ ImplSalBitmapCache::~ImplSalBitmapCache(
 
 // -----------------------------------------------------------------------------
 
-void ImplSalBitmapCache::ImplAdd( SalBitmap* pBmp, ULONG nMemSize, ULONG nFlags )
+void ImplSalBitmapCache::ImplAdd( X11SalBitmap* pBmp, ULONG nMemSize, ULONG nFlags )
 {
 	ImplBmpObj* pObj;
-	BOOL		bFound = FALSE;
+	bool		bFound = FALSE;
 
 	for( pObj = (ImplBmpObj*) maBmpList.Last(); pObj && !bFound; pObj = (ImplBmpObj*) maBmpList.Prev() )
 		if( pObj->mpBmp == pBmp )
@@ -1124,7 +1112,7 @@ void ImplSalBitmapCache::ImplAdd( SalBit
 
 // -----------------------------------------------------------------------------
 
-void ImplSalBitmapCache::ImplRemove( SalBitmap* pBmp )
+void ImplSalBitmapCache::ImplRemove( X11SalBitmap* pBmp )
 {
 	for( ImplBmpObj* pObj = (ImplBmpObj*) maBmpList.Last(); pObj; pObj = (ImplBmpObj*) maBmpList.Prev() )
 	{
Index: vcl/unx/source/gdi/salgdi.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/salgdi.cxx,v
retrieving revision 1.24.120.2
retrieving revision 1.33
diff -u -p -u -r1.24.120.2 -r1.33
--- vcl/unx/source/gdi/salgdi.cxx	15 Jan 2004 12:53:28 -0000	1.24.120.2
+++ vcl/unx/source/gdi/salgdi.cxx	22 Jun 2004 17:42:18 -0000	1.33
@@ -59,14 +59,22 @@
  *
  ************************************************************************/
 
-#define _SV_SALGDI_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 #include <stdio.h>
 #include <stdlib.h>
 
 #include <prex.h>
+// [ed] 6/15/02 There's a conflicting definition of INT8 within the Xmd.h header
+// and the solar.h OOo header.  So, wrap the X11 header with a bogus #define
+// to use the OOo definition of the symbol for INT8.
+// [fa] 4/12/04 With 64-bit changes, X11 headers also conflict with INT64
+
+#define INT8 blehBlahFooBarINT8
+#define INT64 blehBlahFooBarINT64
+
 #include <X11/Xproto.h>
+
+#undef INT8
+#undef INT64
 #include <postx.h>
 
 #include <salunx.h>
@@ -78,13 +86,13 @@
 #include <saldisp.hxx>
 #endif
 #ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#include <salgdi.h>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
-#ifndef _SV_SALVD_HXX
-#include <salvd.hxx>
+#ifndef _SV_SALVD_H
+#include <salvd.h>
 #endif
 #include <tools/debug.hxx>
 
@@ -128,17 +136,13 @@ inline SalPolyLine::~SalPolyLine()
 { if( pFirst_ != Points_ ) delete [] pFirst_; }
 
 #undef STATIC_POINTS
-// -=-= SalGraphicsData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+// -=-= X11SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalGraphicsData::SalGraphicsData()
+X11SalGraphics::X11SalGraphics()
 {
-#ifndef _USE_PRINT_EXTENSION_
-	m_pJobData			= NULL;
-	m_pPrinterGfx 		= NULL;
-	m_pPhoneNr			= NULL;
-#endif
     m_pFrame			= NULL;
     m_pVDev				= NULL;
+    m_pDeleteColormap	= NULL;
 	hDrawable_			= None;
 
 	pClipRegion_			= NULL;
@@ -188,38 +192,53 @@ SalGraphicsData::SalGraphicsData()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalGraphicsData::~SalGraphicsData()
+X11SalGraphics::~X11SalGraphics()
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if( ! ( m_pJobData || m_pPrinterGfx ) )
-#endif
-	{
-		Display *pDisplay = GetXDisplay();
+    Display *pDisplay = GetXDisplay();
+    
+    DBG_ASSERT( !pPaintRegion_, "pPaintRegion_" )
+        if( pClipRegion_ ) XDestroyRegion( pClipRegion_ );
+    
+    if( hBrush_ )		XFreePixmap( pDisplay, hBrush_ );
+    if( pPenGC_ )		XFreeGC( pDisplay, pPenGC_ );
+    if( pFontGC_ )		XFreeGC( pDisplay, pFontGC_ );
+    if( pBrushGC_ )		XFreeGC( pDisplay, pBrushGC_ );
+    if( pMonoGC_ )		XFreeGC( pDisplay, pMonoGC_ );
+    if( pCopyGC_ )		XFreeGC( pDisplay, pCopyGC_ );
+    if( pMaskGC_ )		XFreeGC( pDisplay, pMaskGC_ );
+    if( pInvertGC_ )	XFreeGC( pDisplay, pInvertGC_ );
+    if( pInvert50GC_ )	XFreeGC( pDisplay, pInvert50GC_ );
+    if( pStippleGC_ )	XFreeGC( pDisplay, pStippleGC_ );
+    if( pTrackingGC_ )	XFreeGC( pDisplay, pTrackingGC_ );
+    if( m_pDeleteColormap )
+        delete m_pDeleteColormap;
+}
 
-		DBG_ASSERT( !pPaintRegion_, "pPaintRegion_" )
-			if( pClipRegion_ ) XDestroyRegion( pClipRegion_ );
+// -=-= SalGraphics / X11SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-		if( hBrush_ )		XFreePixmap( pDisplay, hBrush_ );
-		if( pPenGC_ )		XFreeGC( pDisplay, pPenGC_ );
-		if( pFontGC_ )		XFreeGC( pDisplay, pFontGC_ );
-		if( pBrushGC_ )		XFreeGC( pDisplay, pBrushGC_ );
-		if( pMonoGC_ )		XFreeGC( pDisplay, pMonoGC_ );
-		if( pCopyGC_ )		XFreeGC( pDisplay, pCopyGC_ );
-		if( pMaskGC_ )		XFreeGC( pDisplay, pMaskGC_ );
-		if( pInvertGC_ )	XFreeGC( pDisplay, pInvertGC_ );
-		if( pInvert50GC_ )	XFreeGC( pDisplay, pInvert50GC_ );
-		if( pStippleGC_ )	XFreeGC( pDisplay, pStippleGC_ );
-		if( pTrackingGC_ )	XFreeGC( pDisplay, pTrackingGC_ );
-	}
+void X11SalGraphics::Init( SalFrame *pFrame, Drawable aTarget )
+{
+	m_pColormap		= &GetSalData()->GetDisplay()->GetColormap();
+	hDrawable_		= aTarget;
+
+	bWindow_		= TRUE;
+    m_pFrame		= pFrame;
+    m_pVDev			= NULL;
+
+	nPenPixel_		= GetPixel( nPenColor_ );
+	nTextPixel_ 	= GetPixel( nTextColor_ );
+	nBrushPixel_	= GetPixel( nBrushColor_ );
+    numClipRects_   = 0;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphicsData::DeInit()
+void X11SalGraphics::DeInit()
 {
+    hDrawable_ = None;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphicsData::SetClipRegion( GC pGC, XLIB_Region pXReg ) const
+void X11SalGraphics::SetClipRegion( GC pGC, XLIB_Region pXReg ) const
 {
 	Display *pDisplay = GetXDisplay();
 
@@ -250,7 +269,7 @@ void SalGraphicsData::SetClipRegion( GC 
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::SelectPen()
+GC X11SalGraphics::SelectPen()
 {
 	Display *pDisplay = GetXDisplay();
 
@@ -281,7 +300,7 @@ GC SalGraphicsData::SelectPen()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::SelectBrush()
+GC X11SalGraphics::SelectBrush()
 {
 	Display *pDisplay = GetXDisplay();
 
@@ -334,7 +353,7 @@ GC SalGraphicsData::SelectBrush()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::GetTrackingGC()
+GC X11SalGraphics::GetTrackingGC()
 {
 	const char    dash_list[2] = {2, 2};
 
@@ -343,8 +362,8 @@ GC SalGraphicsData::GetTrackingGC()
 		XGCValues     values;
 
 		values.graphics_exposures   = True;
-    	values.foreground           = xColormap_->GetBlackPixel()
-			                          ^ xColormap_->GetWhitePixel();
+    	values.foreground           = m_pColormap->GetBlackPixel()
+			                          ^ m_pColormap->GetWhitePixel();
     	values.function             = GXxor;
     	values.line_width           = 1;
 		values.line_style			= LineOnOffDash;
@@ -366,7 +385,7 @@ GC SalGraphicsData::GetTrackingGC()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphicsData::DrawLines( ULONG              nPoints,
+void X11SalGraphics::DrawLines( ULONG              nPoints,
 									   const SalPolyLine &rPoints,
 									   GC                 pGC )
 {
@@ -399,7 +418,7 @@ void SalGraphicsData::DrawLines( ULONG  
 #define P_DELTA			51
 #define DMAP( v, m )	((v % P_DELTA) > m ? (v / P_DELTA) + 1 : (v / P_DELTA))
 
-BOOL SalGraphicsData::GetDitherPixmap( SalColor nSalColor )
+BOOL X11SalGraphics::GetDitherPixmap( SalColor nSalColor )
 {
     static const short nOrdDither8Bit[ 8 ][ 8 ] =
 	{
@@ -475,49 +494,24 @@ BOOL SalGraphicsData::GetDitherPixmap( S
 	return TRUE;
 }
 
-// -=-= SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalGraphics::SalGraphics()
-{ }
-
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalGraphics::~SalGraphics()
-{ }
-
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::GetResolution( long &rDPIX, long &rDPIY ) // const
+void X11SalGraphics::GetResolution( sal_Int32 &rDPIX, sal_Int32 &rDPIY ) // const
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pJobData != NULL)
-	{
-		int x = maGraphicsData.m_pJobData->m_aContext.getRenderResolution();
-
-		rDPIX = x;
-		rDPIY = x;
-	}
-	else
-	{
-#endif
-
-        SalDisplay *pDisplay = _GetDisplay();
-
-        rDPIX = pDisplay->GetResolution().A();
-        rDPIY = pDisplay->GetResolution().B();
-        if ( rDPIY < 96 )
-        {
-            rDPIX = Divide( rDPIX * 96, rDPIY );
+    SalDisplay *pDisplay = GetDisplay();
+    
+    rDPIX = pDisplay->GetResolution().A();
+    rDPIY = pDisplay->GetResolution().B();
+    if( !pDisplay->GetExactResolution() && rDPIY < 96 )
+    {
+        rDPIX = Divide( rDPIX * 96, rDPIY );
             rDPIY = 96;
-        }
-        else if ( rDPIY > 200 )
-        {
-            rDPIX = Divide( rDPIX * 200, rDPIY );
-            rDPIY = 200;
-        }
- 
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
-
+    }
+    else if ( rDPIY > 200 )
+    {
+        rDPIX = Divide( rDPIX * 200, rDPIY );
+        rDPIY = 200;
+    }
+    
     // #i12705# equalize x- and y-resolution if they are close enough
     if( rDPIX != rDPIY )
     {
@@ -535,731 +529,439 @@ void SalGraphics::GetResolution( long &r
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::GetScreenFontResolution( long &rDPIX, long &rDPIY ) // const
+void X11SalGraphics::GetScreenFontResolution( sal_Int32 &rDPIX, sal_Int32 &rDPIY ) // const
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->GetScreenFontResolution (rDPIX, rDPIY);
-	else
-#endif
-        _GetDisplay()->GetScreenFontResolution( rDPIX, rDPIY );
+    GetDisplay()->GetScreenFontResolution( rDPIX, rDPIY );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-USHORT SalGraphics::GetBitCount() // const
+USHORT X11SalGraphics::GetBitCount() // const
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		return maGraphicsData.m_pPrinterGfx->GetBitCount ();
-	else
-	{
-#endif
-
-        return _GetVisual()->GetDepth();
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    return GetVisual()->GetDepth();
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-long SalGraphics::GetGraphicsWidth()
+long X11SalGraphics::GetGraphicsWidth()
 {
-    if( maGraphicsData.m_pFrame )
-        return maGraphicsData.m_pFrame->maGeometry.nWidth;
-    else if( maGraphicsData.m_pVDev )
-        return maGraphicsData.m_pVDev->maVirDevData.GetWidth();
+    if( m_pFrame )
+        return m_pFrame->maGeometry.nWidth;
+    else if( m_pVDev )
+        return m_pVDev->GetWidth();
     else
         return 0;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::ResetClipRegion()
+void X11SalGraphics::ResetClipRegion()
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->ResetClipRegion ();
-	else
-	{
-#endif
-
-        if( _GetClipRegion() )
-        {
-            _IsPenGC()			= FALSE;
-            _IsFontGC()			= FALSE;
-            _IsBrushGC()		= FALSE;
-            _IsMonoGC()			= FALSE;
-            _IsCopyGC()			= FALSE;
-            _IsInvertGC()		= FALSE;
-            _IsInvert50GC()		= FALSE;
-            _IsStippleGC()		= FALSE;
-            _IsTrackingGC()		= FALSE;
-
-            XDestroyRegion( _GetClipRegion() );
-            _GetClipRegion()	= NULL;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( pClipRegion_ )
+    {
+        bPenGC_			= FALSE;
+        bFontGC_		= FALSE;
+        bBrushGC_		= FALSE;
+        bMonoGC_		= FALSE;
+        bCopyGC_		= FALSE;
+        bInvertGC_		= FALSE;
+        bInvert50GC_	= FALSE;
+        bStippleGC_		= FALSE;
+        bTrackingGC_	= FALSE;
+        
+        XDestroyRegion( pClipRegion_ );
+        pClipRegion_	= NULL;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::BeginSetClipRegion( ULONG n )
+void X11SalGraphics::BeginSetClipRegion( ULONG n )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->BeginSetClipRegion(n);
-	else
-	{
-#endif
-
-        if( _GetClipRegion() )
-            XDestroyRegion( _GetClipRegion() );
-        _GetClipRegion() = XCreateRegion();
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( pClipRegion_ )
+        XDestroyRegion( pClipRegion_ );
+    pClipRegion_ = XCreateRegion();
+    numClipRects_ = 0;
+    boundingClipRect_.SetEmpty();
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-BOOL SalGraphics::UnionClipRegion( long nX, long nY, long nDX, long nDY, const OutputDevice* )
+BOOL X11SalGraphics::unionClipRegion( long nX, long nY, long nDX, long nDY )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		return maGraphicsData.m_pPrinterGfx->UnionClipRegion (nX, nY, nDX, nDY);
-	else
-	{
-#endif
-
-        if (!nDX || !nDY)
-            return TRUE;
-
-        XRectangle aRect;
-        aRect.x			= (short)nX;
-        aRect.y			= (short)nY;
-        aRect.width		= (unsigned short)nDX;
-        aRect.height	= (unsigned short)nDY;
-
-        XUnionRectWithRegion( &aRect, _GetClipRegion(), _GetClipRegion() );
-
+    if (!nDX || !nDY)
         return TRUE;
 
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    numClipRects_++;
+    boundingClipRect_.Union( Rectangle( nX, nY, nX+nDX, nY+nDY ) );
+    
+    XRectangle aRect;
+    aRect.x			= (short)nX;
+    aRect.y			= (short)nY;
+    aRect.width		= (unsigned short)nDX;
+    aRect.height	= (unsigned short)nDY;
+    
+    XUnionRectWithRegion( &aRect, pClipRegion_, pClipRegion_ );
+    
+    return TRUE;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::EndSetClipRegion()
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->EndSetClipRegion ();
-	else
-	{
-#endif
-
-        _IsPenGC()		= FALSE;
-        _IsFontGC()		= FALSE;
-        _IsBrushGC()	= FALSE;
-        _IsMonoGC()		= FALSE;
-        _IsCopyGC()		= FALSE;
-        _IsInvertGC()	= FALSE;
-        _IsInvert50GC()	= FALSE;
-        _IsStippleGC()	= FALSE;
-        _IsTrackingGC()	= FALSE;
-
-        if( XEmptyRegion( _GetClipRegion() ) )
-        {
-            XDestroyRegion( _GetClipRegion() );
-            _GetClipRegion()	= NULL;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+void X11SalGraphics::EndSetClipRegion()
+{
+    bPenGC_			= FALSE;
+    bFontGC_		= FALSE;
+    bBrushGC_		= FALSE;
+    bMonoGC_		= FALSE;
+    bCopyGC_		= FALSE;
+    bInvertGC_		= FALSE;
+    bInvert50GC_	= FALSE;
+    bStippleGC_		= FALSE;
+    bTrackingGC_	= FALSE;
+    
+    if( XEmptyRegion( pClipRegion_ ) )
+    {
+        XDestroyRegion( pClipRegion_ );
+        pClipRegion_= NULL;
+        numClipRects_ = 0;
+        boundingClipRect_.SetEmpty();
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetLineColor()
+void X11SalGraphics::SetLineColor()
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->SetLineColor ();
-	else
-	{
-#endif
-
-        if( _GetPenColor() != 0xFFFFFFFF )
-        {
-            _GetPenColor()		= 0xFFFFFFFF;
-            _IsPenGC()			= FALSE;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nPenColor_ != 0xFFFFFFFF )
+    {
+        nPenColor_		= 0xFFFFFFFF;
+        bPenGC_			= FALSE;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetLineColor( SalColor nSalColor )
+void X11SalGraphics::SetLineColor( SalColor nSalColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
-                                  SALCOLOR_GREEN (nSalColor),
-                                  SALCOLOR_BLUE  (nSalColor));
-		maGraphicsData.m_pPrinterGfx->SetLineColor (aColor);
-	}
-	else
-	{
-#endif
-
-        if( _GetPenColor() != nSalColor )
-        {
-            _GetPenColor()		= nSalColor;
-            _GetPenPixel()		= _GetPixel( nSalColor );
-            _IsPenGC()			= FALSE;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nPenColor_ != nSalColor )
+    {
+        nPenColor_		= nSalColor;
+        nPenPixel_		= GetPixel( nSalColor );
+        bPenGC_			= FALSE;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetFillColor()
+void X11SalGraphics::SetFillColor()
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->SetFillColor ();
-	else
-	{
-#endif
-
-        if( _GetBrushColor() != 0xFFFFFFFF )
-        {
-            _IsDitherBrush()	= FALSE;
-            _GetBrushColor()	= 0xFFFFFFFF;
-            _IsBrushGC()		= FALSE;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nBrushColor_ != 0xFFFFFFFF )
+    {
+        bDitherBrush_	= FALSE;
+        nBrushColor_	= 0xFFFFFFFF;
+        bBrushGC_		= FALSE;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetFillColor( SalColor nSalColor )
+void X11SalGraphics::SetFillColor( SalColor nSalColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
-                                  SALCOLOR_GREEN (nSalColor),
-                                  SALCOLOR_BLUE  (nSalColor));
-		maGraphicsData.m_pPrinterGfx->SetFillColor (aColor);
-	}
-	else
-	{
-#endif
-
-        if( _GetBrushColor() != nSalColor )
-        {
-            _IsDitherBrush()	= FALSE;
-            _GetBrushColor()	= nSalColor;
-            _GetBrushPixel()	= _GetPixel( nSalColor );
-            if( TrueColor != _GetColormap().GetVisual()->GetClass()
-                && _GetColor( _GetBrushPixel() ) != _GetBrushColor()
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0x00 ) // black
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0x80 ) // blue
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0x80, 0x00 ) // green
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0x80, 0x80 ) // cyan
-                && nSalColor != MAKE_SALCOLOR( 0x80, 0x00, 0x00 ) // red
-                && nSalColor != MAKE_SALCOLOR( 0x80, 0x00, 0x80 ) // magenta
-                && nSalColor != MAKE_SALCOLOR( 0x80, 0x80, 0x00 ) // brown
-                && nSalColor != MAKE_SALCOLOR( 0x80, 0x80, 0x80 ) // gray
-                && nSalColor != MAKE_SALCOLOR( 0xC0, 0xC0, 0xC0 ) // light gray
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0xFF ) // light blue
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0xFF, 0x00 ) // light green
-                && nSalColor != MAKE_SALCOLOR( 0x00, 0xFF, 0xFF ) // light cyan
-                && nSalColor != MAKE_SALCOLOR( 0xFF, 0x00, 0x00 ) // light red
-                && nSalColor != MAKE_SALCOLOR( 0xFF, 0x00, 0xFF ) // light magenta
-                && nSalColor != MAKE_SALCOLOR( 0xFF, 0xFF, 0x00 ) // light brown
-                && nSalColor != MAKE_SALCOLOR( 0xFF, 0xFF, 0xFF ) )
-                _IsDitherBrush() = maGraphicsData.GetDitherPixmap(nSalColor);
-            _IsBrushGC()		= FALSE;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nBrushColor_ != nSalColor )
+    {
+        bDitherBrush_	= FALSE;
+        nBrushColor_	= nSalColor;
+        nBrushPixel_	= GetPixel( nSalColor );
+        if( TrueColor != GetColormap().GetVisual()->GetClass()
+            && GetColormap().GetColor( nBrushPixel_ ) != nBrushColor_
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0x00 ) // black
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0x80 ) // blue
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0x80, 0x00 ) // green
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0x80, 0x80 ) // cyan
+            && nSalColor != MAKE_SALCOLOR( 0x80, 0x00, 0x00 ) // red
+            && nSalColor != MAKE_SALCOLOR( 0x80, 0x00, 0x80 ) // magenta
+            && nSalColor != MAKE_SALCOLOR( 0x80, 0x80, 0x00 ) // brown
+            && nSalColor != MAKE_SALCOLOR( 0x80, 0x80, 0x80 ) // gray
+            && nSalColor != MAKE_SALCOLOR( 0xC0, 0xC0, 0xC0 ) // light gray
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0x00, 0xFF ) // light blue
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0xFF, 0x00 ) // light green
+            && nSalColor != MAKE_SALCOLOR( 0x00, 0xFF, 0xFF ) // light cyan
+            && nSalColor != MAKE_SALCOLOR( 0xFF, 0x00, 0x00 ) // light red
+            && nSalColor != MAKE_SALCOLOR( 0xFF, 0x00, 0xFF ) // light magenta
+            && nSalColor != MAKE_SALCOLOR( 0xFF, 0xFF, 0x00 ) // light brown
+            && nSalColor != MAKE_SALCOLOR( 0xFF, 0xFF, 0xFF ) )
+            bDitherBrush_ = GetDitherPixmap(nSalColor);
+        bBrushGC_		= FALSE;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetROPLineColor( SalROPColor nROPColor )
+void X11SalGraphics::SetROPLineColor( SalROPColor nROPColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ASSERT( 0, "Error: PrinterGfx::SetROPLineColor() not implemented" );
-	}
-	else
-	{
-#endif
-
-        switch( nROPColor )
-        {
-            case SAL_ROP_0 : // 0
-                _GetPenPixel() = (Pixel)0;
-                break;
-            case SAL_ROP_1 : // 1
-                _GetPenPixel() = (Pixel)(1 << _GetVisual()->GetDepth()) - 1;
-                break;
-            case SAL_ROP_INVERT : // 2
-                _GetPenPixel() = (Pixel)(1 << _GetVisual()->GetDepth()) - 1;
-                break;
-        }
-        _GetPenColor()	= _GetColor( _GetPenPixel() );
-        _IsPenGC()		= FALSE;
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    switch( nROPColor )
+    {
+        case SAL_ROP_0 : // 0
+            nPenPixel_ = (Pixel)0;
+            break;
+        case SAL_ROP_1 : // 1
+            nPenPixel_ = (Pixel)(1 << GetVisual()->GetDepth()) - 1;
+            break;
+        case SAL_ROP_INVERT : // 2
+            nPenPixel_ = (Pixel)(1 << GetVisual()->GetDepth()) - 1;
+            break;
+    }
+    nPenColor_	= GetColormap().GetColor( nPenPixel_ );
+    bPenGC_		= FALSE;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetROPFillColor( SalROPColor nROPColor )
+void X11SalGraphics::SetROPFillColor( SalROPColor nROPColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ASSERT( 0, "Error: PrinterGfx::SetROPFillColor() not implemented" );
-	}
-	else
-	{
-#endif
-
-        switch( nROPColor )
-        {
-            case SAL_ROP_0 : // 0
-                _GetBrushPixel() = (Pixel)0;
-                break;
-            case SAL_ROP_1 : // 1
-                _GetBrushPixel() = (Pixel)(1 << _GetVisual()->GetDepth()) - 1;
-                break;
-            case SAL_ROP_INVERT : // 2
-                _GetBrushPixel() = (Pixel)(1 << _GetVisual()->GetDepth()) - 1;
-                break;
-        }
-        _IsDitherBrush()	= FALSE;
-        _GetBrushColor()	= _GetColor( _GetBrushPixel() );
-        _IsBrushGC()		= FALSE;
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    switch( nROPColor )
+    {
+        case SAL_ROP_0 : // 0
+            nBrushPixel_ = (Pixel)0;
+            break;
+        case SAL_ROP_1 : // 1
+            nBrushPixel_ = (Pixel)(1 << GetVisual()->GetDepth()) - 1;
+            break;
+        case SAL_ROP_INVERT : // 2
+            nBrushPixel_ = (Pixel)(1 << GetVisual()->GetDepth()) - 1;
+            break;
+    }
+    bDitherBrush_	= FALSE;
+    nBrushColor_	= GetColormap().GetColor( nBrushPixel_ );
+    bBrushGC_		= FALSE;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::SetXORMode( BOOL bSet )
+void X11SalGraphics::SetXORMode( BOOL bSet )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ASSERT( !bSet, "Error: PrinterGfx::SetXORMode() not implemented" );
-	}
-	else
-	{
-#endif
-
-        if( !_IsXORMode() == bSet )
-        {
-            _IsXORMode() 	= bSet;
-            _IsPenGC()		= FALSE;
-            _IsBrushGC()	= FALSE;
-            _IsMonoGC()		= FALSE;
-            _IsCopyGC()		= FALSE;
-            _IsInvertGC()	= FALSE;
-            _IsInvert50GC()	= FALSE;
-            _IsStippleGC()	= FALSE;
-            _IsTrackingGC()	= FALSE;
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( !bXORMode_ == bSet )
+    {
+        bXORMode_ 	= bSet;
+        bPenGC_		= FALSE;
+        bBrushGC_	= FALSE;
+        bMonoGC_		= FALSE;
+        bCopyGC_		= FALSE;
+        bInvertGC_	= FALSE;
+        bInvert50GC_	= FALSE;
+        bStippleGC_	= FALSE;
+        bTrackingGC_	= FALSE;
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawPixel( long nX, long nY, const OutputDevice* )
+void X11SalGraphics::drawPixel( long nX, long nY )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->DrawPixel (Point(nX, nY));
-	else
-	{
-#endif
-
-        if( _GetPenColor() !=  0xFFFFFFFF )
-            XDrawPoint( _GetXDisplay(), _GetDrawable(), _SelectPen(), nX, nY );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nPenColor_ !=  0xFFFFFFFF )
+        XDrawPoint( GetXDisplay(), GetDrawable(), SelectPen(), nX, nY );
 }
 
-void SalGraphics::DrawPixel( long nX, long nY, SalColor nSalColor, const OutputDevice* )
+void X11SalGraphics::drawPixel( long nX, long nY, SalColor nSalColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
-                                  SALCOLOR_GREEN (nSalColor),
-                                  SALCOLOR_BLUE  (nSalColor));
-		maGraphicsData.m_pPrinterGfx->DrawPixel (Point(nX, nY), aColor);
-	}
-	else
-	{
-#endif
-
-        if( nSalColor != 0xFFFFFFFF )
+    if( nSalColor != 0xFFFFFFFF )
+    {
+        Display *pDisplay = GetXDisplay();
+        
+        if( nPenColor_ == 0xFFFFFFFF && !bPenGC_ )
+        {
+            SetLineColor( nSalColor );
+            XDrawPoint( pDisplay, GetDrawable(), SelectPen(), nX, nY );
+            nPenColor_ = 0xFFFFFFFF;
+            bPenGC_ = False;
+        }
+        else
         {
-            Display *pDisplay = _GetXDisplay();
-
-            if( _GetPenColor() == 0xFFFFFFFF && !_IsPenGC() )
-            {
-                SetLineColor( nSalColor );
-                XDrawPoint( pDisplay, _GetDrawable(), _SelectPen(), nX, nY );
-                _GetPenColor() = 0xFFFFFFFF;
-                _IsPenGC() = False;
-            }
-            else
-            {
-                GC pGC = _SelectPen();
-
-                if( nSalColor != _GetPenColor() )
-                    XSetForeground( pDisplay, pGC, _GetPixel( nSalColor ) );
-
-                XDrawPoint( pDisplay, _GetDrawable(), pGC, nX, nY );
-
-                if( nSalColor != _GetPenColor() )
-                    XSetForeground( pDisplay, pGC, _GetPenPixel() );
-            }
+            GC pGC = SelectPen();
+            
+            if( nSalColor != nPenColor_ )
+                XSetForeground( pDisplay, pGC, GetPixel( nSalColor ) );
+            
+            XDrawPoint( pDisplay, GetDrawable(), pGC, nX, nY );
+            
+            if( nSalColor != nPenColor_ )
+                XSetForeground( pDisplay, pGC, nPenPixel_ );
         }
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawLine( long nX1, long nY1, long nX2, long nY2, const OutputDevice* )
+void X11SalGraphics::drawLine( long nX1, long nY1, long nX2, long nY2 )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->DrawLine (Point(nX1, nY1), Point(nX2, nY2));
-	else
-	{
-#endif
-
-        if( _GetPenColor() != 0xFFFFFFFF )
+    if( nPenColor_ != 0xFFFFFFFF )
+    {
+        if ( GetDisplay()->GetProperties() & PROPERTY_BUG_DrawLine )
         {
-            if ( _GetDisplay()->GetProperties() & PROPERTY_BUG_DrawLine )
-            {
-                GC aGC = _SelectPen();
-                XDrawPoint (_GetXDisplay(), _GetDrawable(), aGC, (int)nX1, (int)nY1);
-                XDrawPoint (_GetXDisplay(), _GetDrawable(), aGC, (int)nX2, (int)nY2);
-                XDrawLine  (_GetXDisplay(), _GetDrawable(), aGC, nX1, nY1, nX2, nY2 );
+            GC aGC = SelectPen();
+            XDrawPoint (GetXDisplay(), GetDrawable(), aGC, (int)nX1, (int)nY1);
+            XDrawPoint (GetXDisplay(), GetDrawable(), aGC, (int)nX2, (int)nY2);
+            XDrawLine  (GetXDisplay(), GetDrawable(), aGC, nX1, nY1, nX2, nY2 );
 		}
-            else
-                XDrawLine( _GetXDisplay(), _GetDrawable(),_SelectPen(),
-                           nX1, nY1, nX2, nY2 );
-        }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+        else
+            XDrawLine( GetXDisplay(), GetDrawable(),SelectPen(),
+                       nX1, nY1, nX2, nY2 );
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawRect( long nX, long nY, long nDX, long nDY, const OutputDevice* )
+void X11SalGraphics::drawRect( long nX, long nY, long nDX, long nDY )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-
-		maGraphicsData.m_pPrinterGfx->DrawRect (Rectangle(Point(nX, nY), Size(nDX, nDY)));
-	else
-	{
-#endif
-
-        if( _GetBrushColor() != 0xFFFFFFFF )
-        {
-            XFillRectangle( _GetXDisplay(),
-                            _GetDrawable(),
-                            _SelectBrush(),
-                            nX, nY, nDX, nDY );
-        }
-        // Beschreibung DrawRect verkehrt, deshalb -1
-        if( _GetPenColor() != 0xFFFFFFFF )
-            XDrawRectangle( _GetXDisplay(),
-                            _GetDrawable(),
-                            _SelectPen(),
-                            nX, nY, nDX-1, nDY-1 );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nBrushColor_ != 0xFFFFFFFF )
+    {
+        XFillRectangle( GetXDisplay(),
+                        GetDrawable(),
+                        SelectBrush(),
+                        nX, nY, nDX, nDY );
+    }
+    // Beschreibung DrawRect verkehrt, deshalb -1
+    if( nPenColor_ != 0xFFFFFFFF )
+        XDrawRectangle( GetXDisplay(),
+                        GetDrawable(),
+                        SelectPen(),
+                        nX, nY, nDX-1, nDY-1 );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawPolyLine( ULONG nPoints, const SalPoint *pPtAry, const OutputDevice* )
+void X11SalGraphics::drawPolyLine( ULONG nPoints, const SalPoint *pPtAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->DrawPolyLine (nPoints, (Point*)pPtAry);
-	else
-	{
-#endif
-
-        if( _GetPenColor() != 0xFFFFFFFF )
-        {
-            SalPolyLine Points( nPoints, pPtAry );
-
-            maGraphicsData.DrawLines( nPoints, Points, _SelectPen() );
-        }
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    if( nPenColor_ != 0xFFFFFFFF )
+    {
+        SalPolyLine Points( nPoints, pPtAry );
+        
+        DrawLines( nPoints, Points, SelectPen() );
+    }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawPolygon( ULONG nPoints, const SalPoint* pPtAry, const OutputDevice *pOutDev )
+void X11SalGraphics::drawPolygon( ULONG nPoints, const SalPoint* pPtAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	// Point must be equal to SalPoint! see vcl/inc/salgtype.hxx
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->DrawPolygon (nPoints, (Point*)pPtAry);
-	else
-	{
-#endif
-
-        if( nPoints < 3 )
+    if( nPoints < 3 )
+    {
+        if( !nPoints )
         {
-            if( !nPoints )
-            {
 #if OSL_DEBUG_LEVEL > 1
-                fprintf( stderr, "SalGraphics::DrawPolygon !nPoints\n" );
+            fprintf( stderr, "X11SalGraphicsDrawPolygon !nPoints\n" );
 #endif
-            }
-            else if( !_IsXORMode() )
-            {
-                if( 1 == nPoints  )
-                    DrawPixel( pPtAry[0].mnX, pPtAry[0].mnY, pOutDev );
-                else
-                    DrawLine( pPtAry[0].mnX, pPtAry[0].mnY,
-                              pPtAry[1].mnX, pPtAry[1].mnY, pOutDev );
-            }
-            return;
         }
-
-        SalPolyLine Points( nPoints, pPtAry );
-
-        nPoints++;
-
-        if( _GetBrushColor() != 0xFFFFFFFF )
-            XFillPolygon( _GetXDisplay(),
-					  _GetDrawable(),
-                          _SelectBrush(),
-                          &Points[0], nPoints,
-                          Complex, CoordModeOrigin );
-
-        if( _GetPenColor() != 0xFFFFFFFF )
-            maGraphicsData.DrawLines( nPoints, Points, _SelectPen() );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+        else if( !bXORMode_ )
+        {
+            if( 1 == nPoints  )
+                drawPixel( pPtAry[0].mnX, pPtAry[0].mnY );
+            else
+                drawLine( pPtAry[0].mnX, pPtAry[0].mnY,
+                          pPtAry[1].mnX, pPtAry[1].mnY );
+        }
+        return;
+    }
+    
+    SalPolyLine Points( nPoints, pPtAry );
+    
+    nPoints++;
+    
+    if( nBrushColor_ != 0xFFFFFFFF )
+        XFillPolygon( GetXDisplay(),
+					  GetDrawable(),
+                      SelectBrush(),
+                      &Points[0], nPoints,
+                      Complex, CoordModeOrigin );
+    
+    if( nPenColor_ != 0xFFFFFFFF )
+        DrawLines( nPoints, Points, SelectPen() );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawPolyPolygon( ULONG			nPoly,
+void X11SalGraphics::drawPolyPolygon( ULONG			nPoly,
 								   const ULONG	   *pPoints,
-								   PCONSTSALPOINT  *pPtAry,
-                                   const OutputDevice *pOutDev )
+								   PCONSTSALPOINT  *pPtAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-		maGraphicsData.m_pPrinterGfx->DrawPolyPolygon (nPoly, pPoints, (const Point**)pPtAry);
-	else
-	{
-
-#endif
-
-        if( _GetBrushColor() != 0xFFFFFFFF )
-        {
-            ULONG		i, n;
-            XLIB_Region	pXRegA	= NULL;
-
-#ifdef CLIPPING
-            Size aOutSize = pOutDev->GetOutputSizePixel();
-
-            ClipRectangle aClippingRect( Point(0,0),
-                                         Point(aOutSize.Width(), aOutSize.Height()) );
-
-            ULONG nMax = pPoints[0];
-            for( i = 1; i < nPoly; i++ )
-                if( pPoints[i] > nMax )
-                    nMax = pPoints[i];
-
-            SalPolyLine Points( nMax * 2 );
-
-            for( i = 0; i < nPoly; i++ )
+    if( nBrushColor_ != 0xFFFFFFFF )
+    {
+        ULONG		i, n;
+        XLIB_Region	pXRegA	= NULL;
+        
+        for( i = 0; i < nPoly; i++ ) {
+            n = pPoints[i];
+            SalPolyLine Points( n, pPtAry[i] );
+            if( n > 2 )
             {
-                n = aClippingRect.ClipPolygon( pPoints[i], pPtAry[i], &Points[0] );
-#else
-            for( i = 0; i < nPoly; i++ ) {
-                n = pPoints[i];
-                SalPolyLine Points( n, pPtAry[i] );
-#endif
-                if( n > 2 )
+                XLIB_Region pXRegB = XPolygonRegion( &Points[0], n+1, WindingRule );
+                if( !pXRegA )
+                    pXRegA = pXRegB;
+                else
                 {
-                    XLIB_Region pXRegB = XPolygonRegion( &Points[0], n+1, WindingRule );
-                    if( !pXRegA )
-                        pXRegA = pXRegB;
-                    else
-                    {
-                        XXorRegion( pXRegA, pXRegB, pXRegA );
-                        XDestroyRegion( pXRegB );
-                    }
+                    XXorRegion( pXRegA, pXRegB, pXRegA );
+                    XDestroyRegion( pXRegB );
                 }
             }
-
-            if( pXRegA )
-            {
-                XRectangle aXRect;
-                XClipBox( pXRegA, &aXRect );
-
-                GC pGC = _SelectBrush();
-                maGraphicsData.SetClipRegion( pGC, pXRegA ); // ??? doppelt
-                XDestroyRegion( pXRegA );
-                _IsBrushGC() = FALSE;
-
-                XFillRectangle( _GetXDisplay(),
-                                _GetDrawable(),
-                                pGC,
-                                aXRect.x, aXRect.y, aXRect.width, aXRect.height );
-            }
         }
-
-        if( _GetPenColor() != 0xFFFFFFFF )
-            for( ULONG i = 0; i < nPoly; i++ )
-                DrawPolyLine( pPoints[i], pPtAry[i], pOutDev );
-
-#ifndef _USE_PRINT_EXTENSION_
-    }
-#endif
+        
+        if( pXRegA )
+        {
+            XRectangle aXRect;
+            XClipBox( pXRegA, &aXRect );
+            
+            GC pGC = SelectBrush();
+            SetClipRegion( pGC, pXRegA ); // ??? doppelt
+            XDestroyRegion( pXRegA );
+            bBrushGC_ = FALSE;
+            
+            XFillRectangle( GetXDisplay(),
+                            GetDrawable(),
+                            pGC,
+                            aXRect.x, aXRect.y, aXRect.width, aXRect.height );
+        }
+   }
+        
+   if( nPenColor_ != 0xFFFFFFFF )
+       for( ULONG i = 0; i < nPoly; i++ )
+           drawPolyLine( pPoints[i], pPtAry[i] );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-sal_Bool SalGraphics::DrawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice* )
+sal_Bool X11SalGraphics::drawPolyLineBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-    {
-		maGraphicsData.m_pPrinterGfx->DrawPolyLineBezier (nPoints, (Point*)pPtAry, pFlgAry);
-        return sal_True;
-    }
-#endif
     return sal_False;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-sal_Bool SalGraphics::DrawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry, const OutputDevice* )
+sal_Bool X11SalGraphics::drawPolygonBezier( ULONG nPoints, const SalPoint* pPtAry, const BYTE* pFlgAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-    {
-		maGraphicsData.m_pPrinterGfx->DrawPolygonBezier (nPoints, (Point*)pPtAry, pFlgAry);
-        return sal_True;
-    }
-#endif
     return sal_False;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-sal_Bool SalGraphics::DrawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
-                                             const SalPoint* const* pPtAry, const BYTE* const* pFlgAry, const OutputDevice* )
+sal_Bool X11SalGraphics::drawPolyPolygonBezier( ULONG nPoly, const ULONG* pPoints,
+                                                const SalPoint* const* pPtAry, const BYTE* const* pFlgAry )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	// Point must be equal to SalPoint! see vcl/inc/salgtype.hxx
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-    {
-		maGraphicsData.m_pPrinterGfx->DrawPolyPolygonBezier (nPoly, pPoints, (Point**)pPtAry, (BYTE**)pFlgAry);
-        return sal_True;
-    }
-#endif
     return sal_False;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalGraphics::Invert( ULONG nPoints,
-						  const SalPoint* pPtAry,
-						  SalInvert nFlags,
-                          const OutputDevice* )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ASSERT( 0, "Error: PrinterGfx::Invert() not implemented" );
-	}
-	else
-	{
-#endif
-
-        SalDisplay *pDisp = _GetDisplay();
-        SalPolyLine Points ( nPoints, pPtAry );
-
-        GC pGC;
-        if( SAL_INVERT_50 & nFlags )
-            pGC = maGraphicsData.GetInvert50GC();
-        else
-            if ( SAL_INVERT_TRACKFRAME & nFlags )
-                pGC = maGraphicsData.GetTrackingGC();
-            else
-                pGC = maGraphicsData.GetInvertGC();
-
-        if( SAL_INVERT_TRACKFRAME & nFlags )
-            maGraphicsData.DrawLines ( nPoints, Points, pGC );
+void X11SalGraphics::invert( ULONG nPoints,
+                             const SalPoint* pPtAry,
+                             SalInvert nFlags )
+{
+    SalDisplay *pDisp = GetDisplay();
+    SalPolyLine Points ( nPoints, pPtAry );
+    
+    GC pGC;
+    if( SAL_INVERT_50 & nFlags )
+        pGC = GetInvert50GC();
+    else
+        if ( SAL_INVERT_TRACKFRAME & nFlags )
+            pGC = GetTrackingGC();
         else
-            XFillPolygon( _GetXDisplay(),
-                          _GetDrawable(),
-                          pGC,
-                          &Points[0], nPoints,
-                          Complex, CoordModeOrigin );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+            pGC = GetInvertGC();
+    
+    if( SAL_INVERT_TRACKFRAME & nFlags )
+        DrawLines ( nPoints, Points, pGC );
+    else
+        XFillPolygon( GetXDisplay(),
+                      GetDrawable(),
+                      pGC,
+                      &Points[0], nPoints,
+                      Complex, CoordModeOrigin );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-BOOL SalGraphics::DrawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize, const OutputDevice* )
+BOOL X11SalGraphics::drawEPS( long nX, long nY, long nWidth, long nHeight, void* pPtr, ULONG nSize )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		return maGraphicsData.m_pPrinterGfx->DrawEPS( Rectangle( Point( nX, nY ), Size( nWidth, nHeight ) ), pPtr, nSize );
-	}
-	else
-#endif
-        return FALSE;
+    return FALSE;
 }
-
Index: vcl/unx/source/gdi/salgdi2.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/salgdi2.cxx,v
retrieving revision 1.18.68.1
retrieving revision 1.25
diff -u -p -u -r1.18.68.1 -r1.25
--- vcl/unx/source/gdi/salgdi2.cxx	15 Jan 2004 12:53:52 -0000	1.18.68.1
+++ vcl/unx/source/gdi/salgdi2.cxx	22 Jun 2004 17:42:46 -0000	1.25
@@ -59,9 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALGDI2_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #include <stdio.h>
 
 #include <salunx.h>
@@ -72,17 +69,17 @@
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
-#ifndef _SV_SALBMP_HXX
-#include <salbmp.hxx>
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
 #endif
 #ifndef _SV_SALBTYPE_HXX
 #include <salbtype.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
 
 #ifndef _USE_PRINT_EXTENSION_
@@ -115,7 +112,7 @@ static void sal_PrintImage( char *s, XIm
 #if (OSL_DEBUG_LEVEL > 1) && defined SALGDI2_TESTTRANS
 #define DBG_TESTTRANS( _def_drawable )								\
 {																	\
-	XCopyArea( pXDisp, _def_drawable, aDrawable, _GetCopyGC(),		\
+	XCopyArea( pXDisp, _def_drawable, aDrawable, GetCopyGC(),		\
 			   0, 0,												\
 			   pPosAry->mnDestWidth, pPosAry->mnDestHeight,			\
 			   0, 0 );												\
@@ -124,15 +121,15 @@ static void sal_PrintImage( char *s, XIm
 #define DBG_TESTTRANS( _def_drawable )
 #endif // (OSL_DEBUG_LEVEL > 1) && defined SALGDI2_TESTTRANS
 
-// -=-= SalGraphicsData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+// -=-= X11SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::CreateGC( Drawable hDrawable, unsigned long nMask )
+GC X11SalGraphics::CreateGC( Drawable hDrawable, unsigned long nMask )
 {
 	XGCValues values;
 
 	values.graphics_exposures	= True;
-	values.foreground			= xColormap_->GetBlackPixel()
-		                          ^ xColormap_->GetWhitePixel();
+	values.foreground			= m_pColormap->GetBlackPixel()
+		                          ^ m_pColormap->GetWhitePixel();
 	values.function				= GXxor;
 	values.line_width			= 1;
 	values.fill_style			= FillStippled;
@@ -143,7 +140,7 @@ GC SalGraphicsData::CreateGC( Drawable h
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline GC SalGraphicsData::GetMonoGC( Pixmap hPixmap )
+inline GC X11SalGraphics::GetMonoGC( Pixmap hPixmap )
 {
 	if( !pMonoGC_ )
 		pMonoGC_ = CreateGC( hPixmap );
@@ -158,7 +155,7 @@ inline GC SalGraphicsData::GetMonoGC( Pi
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline GC SalGraphicsData::GetCopyGC()
+inline GC X11SalGraphics::GetCopyGC()
 {
 	if( bXORMode_ ) return GetInvertGC();
 
@@ -174,7 +171,7 @@ inline GC SalGraphicsData::GetCopyGC()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::GetInvertGC()
+GC X11SalGraphics::GetInvertGC()
 {
 	if( !pInvertGC_ )
 		pInvertGC_ = CreateGC( GetDrawable(),
@@ -192,15 +189,15 @@ GC SalGraphicsData::GetInvertGC()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::GetInvert50GC()
+GC X11SalGraphics::GetInvert50GC()
 {
 	if( !pInvert50GC_ )
 	{
 		XGCValues values;
 
 		values.graphics_exposures	= True;
-		values.foreground			= xColormap_->GetWhitePixel();
-		values.background			= xColormap_->GetBlackPixel();
+		values.foreground			= m_pColormap->GetWhitePixel();
+		values.background			= m_pColormap->GetBlackPixel();
 		values.function				= GXinvert;
 		values.line_width			= 1;
 		values.line_style			= LineSolid;
@@ -240,7 +237,7 @@ GC SalGraphicsData::GetInvert50GC()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline GC SalGraphicsData::GetStippleGC()
+inline GC X11SalGraphics::GetStippleGC()
 {
 	if( !pStippleGC_ )
 		pStippleGC_ = CreateGC( GetDrawable(),
@@ -259,7 +256,7 @@ inline GC SalGraphicsData::GetStippleGC(
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-int SalGraphicsData::Clip( XLIB_Region   pRegion,
+int X11SalGraphics::Clip( XLIB_Region   pRegion,
 								 int          &nX,
 								 int          &nY,
 								 unsigned int &nDX,
@@ -297,7 +294,7 @@ int SalGraphicsData::Clip( XLIB_Region  
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-int SalGraphicsData::Clip( int          &nX,
+int X11SalGraphics::Clip( int          &nX,
 								 int          &nY,
 								 unsigned int &nDX,
 								 unsigned int &nDY,
@@ -339,7 +336,7 @@ int SalGraphicsData::Clip( int          
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-GC SalGraphicsData::SetMask( int           &nX,
+GC X11SalGraphics::SetMask( int           &nX,
 								   int           &nY,
 								   unsigned int &nDX,
 								   unsigned int &nDY,
@@ -369,7 +366,7 @@ GC SalGraphicsData::SetMask( int        
 	if( !hPixmap )
 	{
 #if (OSL_DEBUG_LEVEL > 1) || defined DBG_UTIL
-		fprintf( stderr, "SalGraphicsData::SetMask !hPixmap\n" );
+		fprintf( stderr, "X11SalGraphics::SetMask !hPixmap\n" );
 #endif
 		return NULL;
 	}
@@ -399,771 +396,495 @@ GC SalGraphicsData::SetMask( int        
 	return pMaskGC_;
 }
 
-// ----- Implementation of PrinterBmp by means of SalBitmap/BitmapBuffer ---------------
-
-#ifndef _USE_PRINT_EXTENSION_
-class SalPrinterBmp : public psp::PrinterBmp
-{
-	private:
-
-		BitmapBuffer*		mpBmpBuffer;
-
-		FncGetPixel			mpFncGetPixel;
-		Scanline			mpScanAccess;
-		sal_Int32			mnScanOffset;
-
-		sal_uInt32			ColorOf (BitmapColor& rColor) const;
-		sal_uInt8			GrayOf  (BitmapColor& rColor) const;
-
-							SalPrinterBmp ();
-
-	public:
-
-							SalPrinterBmp (BitmapBuffer* pBitmap);
-		virtual				~SalPrinterBmp ();
-		virtual sal_uInt32	GetPaletteColor (sal_uInt32 nIdx) const;
-		virtual sal_uInt32	GetPaletteEntryCount () const;
-		virtual sal_uInt32	GetPixelRGB  (sal_uInt32 nRow, sal_uInt32 nColumn) const;
-		virtual sal_uInt8	GetPixelGray (sal_uInt32 nRow, sal_uInt32 nColumn) const;
-		virtual sal_uInt8	GetPixelIdx  (sal_uInt32 nRow, sal_uInt32 nColumn) const;
-		virtual sal_uInt32	GetWidth () const;
-		virtual sal_uInt32	GetHeight() const;
-		virtual sal_uInt32	GetDepth ()	const;
-};
-
-SalPrinterBmp::SalPrinterBmp (BitmapBuffer* pBuffer) :
-		mpBmpBuffer (pBuffer)
-{
-	DBG_ASSERT (mpBmpBuffer, "SalPrinterBmp::SalPrinterBmp () can't acquire Bitmap");
-
-	// calibrate scanline buffer
-	if( BMP_SCANLINE_ADJUSTMENT( mpBmpBuffer->mnFormat ) == BMP_FORMAT_TOP_DOWN )
-	{
-		mpScanAccess = mpBmpBuffer->mpBits;
-		mnScanOffset = mpBmpBuffer->mnScanlineSize;
-	}
-	else
-	{
-		mpScanAccess = mpBmpBuffer->mpBits
-					   + (mpBmpBuffer->mnHeight - 1) * mpBmpBuffer->mnScanlineSize;
-		mnScanOffset = - mpBmpBuffer->mnScanlineSize;
-	}
-
-	// request read access to the pixels
-	switch( BMP_SCANLINE_FORMAT( mpBmpBuffer->mnFormat ) )
-	{
-		case BMP_FORMAT_1BIT_MSB_PAL:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_1BIT_MSB_PAL;	 break;
-		case BMP_FORMAT_1BIT_LSB_PAL:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_1BIT_LSB_PAL;	 break;
-		case BMP_FORMAT_4BIT_MSN_PAL:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_4BIT_MSN_PAL;	 break;
-		case BMP_FORMAT_4BIT_LSN_PAL:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_4BIT_LSN_PAL;	 break;
-		case BMP_FORMAT_8BIT_PAL:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_8BIT_PAL; 	 break;
-		case BMP_FORMAT_8BIT_TC_MASK:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_8BIT_TC_MASK;	 break;
-		case BMP_FORMAT_16BIT_TC_MSB_MASK:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_16BIT_TC_MSB_MASK; break;
-		case BMP_FORMAT_16BIT_TC_LSB_MASK:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_16BIT_TC_LSB_MASK; break;
-		case BMP_FORMAT_24BIT_TC_BGR:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_BGR;  break;
-		case BMP_FORMAT_24BIT_TC_RGB:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_RGB;  break;
-		case BMP_FORMAT_24BIT_TC_MASK:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_24BIT_TC_MASK; break;
-		case BMP_FORMAT_32BIT_TC_ABGR:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_ABGR; break;
-		case BMP_FORMAT_32BIT_TC_ARGB:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_ARGB; break;
-		case BMP_FORMAT_32BIT_TC_BGRA:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_BGRA; break;
-		case BMP_FORMAT_32BIT_TC_RGBA:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_RGBA; break;
-		case BMP_FORMAT_32BIT_TC_MASK:
-			mpFncGetPixel = BitmapReadAccess::GetPixelFor_32BIT_TC_MASK; break;
-
-		default:
-			DBG_ERROR("Error: SalPrinterBmp::SalPrinterBmp() unknown bitmap format");
-		break;
-	}
-}
-
-SalPrinterBmp::~SalPrinterBmp ()
-{
-}
-
-sal_uInt32
-SalPrinterBmp::GetWidth () const
-{
-	return mpBmpBuffer->mnWidth;
-}
-
-sal_uInt32
-SalPrinterBmp::GetHeight () const
-{
-	return mpBmpBuffer->mnHeight;
-}
-
-sal_uInt32
-SalPrinterBmp::GetDepth () const
-{
-	sal_uInt32 nDepth;
-
-	switch (mpBmpBuffer->mnBitCount)
-	{
-		case 1:
-			nDepth = 1;
-			break;
-
-		case 4:
-		case 8:
-			nDepth = 8;
-			break;
-
-		case 16:
-		case 24:
-		case 32:
-			nDepth = 24;
-			break;
-
-		default:
-			DBG_ERROR ("Error: unsupported bitmap depth in SalPrinterBmp::GetDepth()");
-			break;
-	}
-
-	return nDepth;
-}
-
-sal_uInt32
-SalPrinterBmp::ColorOf (BitmapColor& rColor) const
-{
-	if (rColor.IsIndex())
-		return ColorOf (mpBmpBuffer->maPalette[rColor.GetIndex()]);
-	else
-		return 	  ((rColor.GetBlue()) 		 & 0x000000ff)
-				| ((rColor.GetGreen() <<  8) & 0x0000ff00)
-				| ((rColor.GetRed()   << 16) & 0x00ff0000);
-}
-
-sal_uInt8
-SalPrinterBmp::GrayOf (BitmapColor& rColor) const
-{
-	if (rColor.IsIndex())
-		return GrayOf (mpBmpBuffer->maPalette[rColor.GetIndex()]);
-	else
-		return (  rColor.GetBlue()  *  28UL
-				+ rColor.GetGreen() * 151UL
-				+ rColor.GetRed()   *  77UL ) >> 8;
-}
-
-sal_uInt32
-SalPrinterBmp::GetPaletteEntryCount () const
-{
-	return mpBmpBuffer->maPalette.GetEntryCount ();
-}
-
-sal_uInt32
-SalPrinterBmp::GetPaletteColor (sal_uInt32 nIdx) const
-{
-	return ColorOf (mpBmpBuffer->maPalette[nIdx]);
-}
+// -=-= SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-sal_uInt32
-SalPrinterBmp::GetPixelRGB (sal_uInt32 nRow, sal_uInt32 nColumn) const
+extern "C" 
 {
-	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
-	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
-
-	return ColorOf (aColor);
+    static Bool GraphicsExposePredicate( Display* pDisplay, XEvent* pEvent, XPointer pFrameWindow )
+    {
+        Bool bRet = False;
+        if( (pEvent->type == GraphicsExpose || pEvent->type == NoExpose) &&
+            pEvent->xnoexpose.drawable == (Drawable)pFrameWindow )
+        {
+            bRet = True;
+        }
+        return bRet;
+    }
 }
 
-sal_uInt8
-SalPrinterBmp::GetPixelGray (sal_uInt32 nRow, sal_uInt32 nColumn) const
-{
-	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
-	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
-
-	return GrayOf (aColor);
-}
 
-sal_uInt8
-SalPrinterBmp::GetPixelIdx (sal_uInt32 nRow, sal_uInt32 nColumn) const
+void X11SalGraphics::YieldGraphicsExpose( Display* pDisplay, SalFrame* pFrame, Drawable aWindow )
 {
-	Scanline pScan = mpScanAccess + nRow * mnScanOffset;
-	BitmapColor aColor = mpFncGetPixel (pScan, nColumn, mpBmpBuffer->maColorMask);
-
-	if (aColor.IsIndex())
-		return aColor.GetIndex();
-	else
-		return 0;
-}
-#endif
+    // get frame if necessary
+    if( ! pFrame )
+    {
+        const std::list< SalFrame* >& rFrames = GetSalData()->GetDisplay()->getFrames();
+        for( std::list< SalFrame* >::const_iterator it = rFrames.begin(); it != rFrames.end() && ! pFrame; ++it )
+        {
+            const SystemEnvData* pEnvData = (*it)->GetSystemData();
+            if( pEnvData->aWindow == aWindow )
+                pFrame = *it;
+        }
+        if( ! pFrame )
+            return;
+    }
 
-// -=-= SalGraphics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::CopyBits( const SalTwoRect *pPosAry,
-								  SalGraphics	   *pSrcGraphics,
-                                  const OutputDevice *pOutDev, const OutputDevice *pSrcOutDev)
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR( "Error: PrinterGfx::CopyBits() not implemented" );
-	}
-	else
-	{
-#endif
+    XEvent aEvent;
+    while( XCheckTypedWindowEvent( pDisplay, aWindow, Expose, &aEvent ) )
+    {
+        SalPaintEvent aPEvt;
+        aPEvt.mnBoundX			= aEvent.xexpose.x;
+        aPEvt.mnBoundY			= aEvent.xexpose.y;
+        aPEvt.mnBoundWidth		= aEvent.xexpose.width+1;
+        aPEvt.mnBoundHeight 	= aEvent.xexpose.height+1;
+        pFrame->CallCallback( SALEVENT_PAINT, &aPEvt );
+    }
+
+    do
+    {
+        XIfEvent( pDisplay, &aEvent, GraphicsExposePredicate, (XPointer)aWindow );
+        if( aEvent.type == NoExpose )
+            break;
 
-        if( pPosAry->mnSrcWidth <= 0
-            || pPosAry->mnSrcHeight <= 0
-            || pPosAry->mnDestWidth <= 0
-            || pPosAry->mnDestHeight <= 0 )
+        if( pFrame )
         {
-            return;
+            SalPaintEvent aPEvt;
+            aPEvt.mnBoundX			= aEvent.xgraphicsexpose.x;
+            aPEvt.mnBoundY			= aEvent.xgraphicsexpose.y;
+            aPEvt.mnBoundWidth		= aEvent.xgraphicsexpose.width+1;
+            aPEvt.mnBoundHeight 	= aEvent.xgraphicsexpose.height+1;
+            pFrame->CallCallback( SALEVENT_PAINT, &aPEvt );
         }
+    } while( aEvent.xgraphicsexpose.count != 0 );
+}
 
-        int n;
-        if( !pSrcGraphics )
+void X11SalGraphics::copyBits( const SalTwoRect *pPosAry,
+								  SalGraphics	   *pSSrcGraphics )
+{
+    X11SalGraphics* pSrcGraphics = pSSrcGraphics
+        ? static_cast<X11SalGraphics*>(pSSrcGraphics)
+        : this;
+    
+    if( pPosAry->mnSrcWidth <= 0
+        || pPosAry->mnSrcHeight <= 0
+        || pPosAry->mnDestWidth <= 0
+        || pPosAry->mnDestHeight <= 0 )
+    {
+        return;
+    }
+    
+    int n;
+    if( pSrcGraphics == this )
+    {
+        n = 2;
+    }
+    else if( pSrcGraphics->bWindow_ )
+    {
+        // window or compatible virtual device
+        if( pSrcGraphics->GetDisplay() == GetDisplay() )
+            n = 2; // same Display
+        else
+            n = 1; // printer or other display
+    }
+    else if( pSrcGraphics->bVirDev_ )
+    {
+        // printer compatible virtual device
+        if( bPrinter_ )
+            n = 2; // printer or compatible virtual device == same display
+        else
+            n = 1; // window or compatible virtual device
+    }
+    else
+        n = 0;
+    
+    if( n == 2
+        && pPosAry->mnSrcWidth	== pPosAry->mnDestWidth
+        && pPosAry->mnSrcHeight == pPosAry->mnDestHeight )
+    {
+        if( bXORMode_
+            && !pSrcGraphics->bVirDev_
+            && (GetDisplay()->GetProperties() & PROPERTY_BUG_XCopyArea_GXxor) )
         {
-            pSrcGraphics = this;
-            n = 2;
+            Pixmap hPixmap = XCreatePixmap( GetXDisplay(),
+                                            pSrcGraphics->GetDrawable(),		// source
+                                            pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
+                                            pSrcGraphics->GetBitCount() );
+            XCopyArea( GetXDisplay(),
+                       pSrcGraphics->GetDrawable(),		// source
+                       hPixmap,								// destination
+                       GetDisplay()->GetCopyGC(),			// no clipping
+                       pPosAry->mnSrcX,     pPosAry->mnSrcY,
+                       pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
+                       0,    				0 );			// destination
+            XCopyArea( GetXDisplay(),
+                       hPixmap,								// source
+                       GetDrawable(),						// destination
+                       GetInvertGC(),		// destination clipping
+                       0,				    0,				// source
+                       pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
+                       pPosAry->mnDestX,    pPosAry->mnDestY );
+            XFreePixmap( GetXDisplay(), hPixmap );
         }
-        else if( pSrcGraphics->_IsWindow() )
-            // window or compatible virtual device
-            if( pSrcGraphics->_GetDisplay() == _GetDisplay() )
-                n = 2; // same Display
-            else
-                n = 1; // printer or other display
-        else if( pSrcGraphics->_IsVirtualDevice() )
-            // printer compatible virtual device
-            if( _IsPrinter() )
-                n = 2; // printer or compatible virtual device == same display
-            else
-                n = 1; // window or compatible virtual device
         else
-            n = 0;
+            XCopyArea( GetXDisplay(),
+                       pSrcGraphics->GetDrawable(),		// source
+                       GetDrawable(),						// destination
+                       GetCopyGC(),			// destination clipping
+                       pPosAry->mnSrcX,     pPosAry->mnSrcY,
+                       pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
+                       pPosAry->mnDestX,    pPosAry->mnDestY );
 
-        if( n == 2
-            && pPosAry->mnSrcWidth	== pPosAry->mnDestWidth
-            && pPosAry->mnSrcHeight == pPosAry->mnDestHeight )
+        if( bWindow_ && ! bVirDev_ )
         {
-            if( _IsXORMode()
-                && !pSrcGraphics->_IsVirtualDevice()
-                && (_GetDisplay()->GetProperties() & PROPERTY_BUG_XCopyArea_GXxor) )
-            {
-                Pixmap hPixmap = XCreatePixmap( _GetXDisplay(),
-                                                pSrcGraphics->_GetDrawable(),		// source
-                                                pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
-                                                pSrcGraphics->GetBitCount() );
-                XCopyArea( _GetXDisplay(),
-                           pSrcGraphics->_GetDrawable(),		// source
-                           hPixmap,								// destination
-                           _GetDisplay()->GetCopyGC(),			// no clipping
-                           pPosAry->mnSrcX,     pPosAry->mnSrcY,
-                           pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
-                           0,    				0 );			// destination
-                XCopyArea( _GetXDisplay(),
-                           hPixmap,								// source
-                           _GetDrawable(),						// destination
-                           maGraphicsData.GetInvertGC(),		// destination clipping
-                           0,				    0,				// source
-                           pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
-                           pPosAry->mnDestX,    pPosAry->mnDestY );
-                XFreePixmap( _GetXDisplay(), hPixmap );
-            }
-            else
-                XCopyArea( _GetXDisplay(),
-                           pSrcGraphics->_GetDrawable(),		// source
-                           _GetDrawable(),						// destination
-                           maGraphicsData.GetCopyGC(),			// destination clipping
-                           pPosAry->mnSrcX,     pPosAry->mnSrcY,
-                           pPosAry->mnSrcWidth, pPosAry->mnSrcHeight,
-                           pPosAry->mnDestX,    pPosAry->mnDestY );
-
-            if( _IsWindow() && ! _IsVirtualDevice() )
-            {
-                maGraphicsData.m_pFrame->maFrameData.YieldGraphicsExpose();
-            }
+            YieldGraphicsExpose( GetXDisplay(), m_pFrame, GetDrawable() );
         }
-        else if( n )
+    }
+    else if( n )
+    {
+        SalBitmap *pDDB = pSrcGraphics->getBitmap( pPosAry->mnSrcX,
+                                                   pPosAry->mnSrcY,
+                                                   pPosAry->mnSrcWidth,
+                                                   pPosAry->mnSrcHeight );
+        
+        if( !pDDB )
         {
-            SalBitmap *pDDB = pSrcGraphics->GetBitmap( pPosAry->mnSrcX,
-                                                       pPosAry->mnSrcY,
-                                                       pPosAry->mnSrcWidth,
-                                                       pPosAry->mnSrcHeight, pSrcOutDev );
-
-            if( !pDDB )
-            {
-                stderr0( "SalGraphics::CopyBits !pSrcGraphics->GetBitmap()\n" );
-                return;
-            }
-
-            SalTwoRect aPosAry( *pPosAry );
-
-            aPosAry.mnSrcX = 0,	aPosAry.mnSrcY = 0;
-            DrawBitmap( &aPosAry, *pDDB, pOutDev );
-
-            delete pDDB;
+            stderr0( "SalGraphics::CopyBits !pSrcGraphics->GetBitmap()\n" );
+            return;
         }
-        else
-            stderr0( "SalGraphics::CopyBits from Printer not yet implemented\n" );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+        
+        SalTwoRect aPosAry( *pPosAry );
+        
+        aPosAry.mnSrcX = 0,	aPosAry.mnSrcY = 0;
+        drawBitmap( &aPosAry, *pDDB );
+        
+        delete pDDB;
+    }
+    else
+        stderr0( "X11SalGraphics::CopyBits from Printer not yet implemented\n" );
 }
 
 // --------------------------------------------------------------------------
 
-void SalGraphics::CopyArea ( long nDestX,    long nDestY,
+void X11SalGraphics::copyArea ( long nDestX,    long nDestY,
                                    long nSrcX,     long nSrcY,
                                    long nSrcWidth, long nSrcHeight,
-                                   USHORT nFlags, const OutputDevice *pOutDev )
+                                   USHORT nFlags )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR( "Error: PrinterGfx::CopyArea() not implemented" );
-	}
-	else
-	{
-#endif
-
-        SalTwoRect aPosAry;
-
-        aPosAry.mnDestX = nDestX;
-        aPosAry.mnDestY = nDestY;
-        aPosAry.mnDestWidth  = nSrcWidth;
-        aPosAry.mnDestHeight = nSrcHeight;
-
-        aPosAry.mnSrcX = nSrcX;
-        aPosAry.mnSrcY = nSrcY;
-        aPosAry.mnSrcWidth  = nSrcWidth;
-        aPosAry.mnSrcHeight = nSrcHeight;
-
-        SalGraphics::CopyBits ( &aPosAry, 0, pOutDev, pOutDev );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
-}
-
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap, const OutputDevice* )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		Rectangle aSrc (Point(pPosAry->mnSrcX, pPosAry->mnSrcY),
-						Size(pPosAry->mnSrcWidth, pPosAry->mnSrcHeight));
-		Rectangle aDst (Point(pPosAry->mnDestX, pPosAry->mnDestY),
-						Size(pPosAry->mnDestWidth, pPosAry->mnDestHeight));
-
-		BitmapBuffer* pBuffer= const_cast<SalBitmap&>(rSalBitmap).AcquireBuffer(sal_True);
-
-		SalPrinterBmp aBmp (pBuffer);
-		maGraphicsData.m_pPrinterGfx->DrawBitmap (aDst, aSrc, aBmp);
-
-		const_cast<SalBitmap&>(rSalBitmap).ReleaseBuffer (pBuffer, sal_True);
-	}
-	else
-	{
-#endif
-
-        SalDisplay*			pSalDisp = maGraphicsData.GetDisplay();
-        Display*			pXDisp = pSalDisp->GetDisplay();
-        const Drawable		aDrawable( maGraphicsData.GetDrawable() );
+    SalTwoRect aPosAry;
+    
+    aPosAry.mnDestX = nDestX;
+    aPosAry.mnDestY = nDestY;
+    aPosAry.mnDestWidth  = nSrcWidth;
+    aPosAry.mnDestHeight = nSrcHeight;
+    
+    aPosAry.mnSrcX = nSrcX;
+    aPosAry.mnSrcY = nSrcY;
+    aPosAry.mnSrcWidth  = nSrcWidth;
+    aPosAry.mnSrcHeight = nSrcHeight;
+    
+    copyBits ( &aPosAry, 0 );
+}
+
+// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+void X11SalGraphics::drawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap )
+{
+    SalDisplay*			pSalDisp = GetDisplay();
+    Display*			pXDisp = pSalDisp->GetDisplay();
+    const Drawable		aDrawable( GetDrawable() );
+    const SalColormap&	rColMap = pSalDisp->GetColormap();
+    const long			nDepth = GetDisplay()->GetVisual()->GetDepth();
+    GC					aGC( GetCopyGC() );
+    XGCValues			aOldVal, aNewVal;
+    int					nValues = GCForeground | GCBackground;
+    
+    if( rSalBitmap.GetBitCount() == 1 )
+    {
+        // set foreground/background values for 1Bit bitmaps
+        XGetGCValues( pXDisp, aGC, nValues, &aOldVal );
+        aNewVal.foreground = rColMap.GetWhitePixel(), aNewVal.background = rColMap.GetBlackPixel();
+        XChangeGC( pXDisp, aGC, nValues, &aNewVal );
+    }
+    
+    static_cast<const X11SalBitmap&>(rSalBitmap).ImplDraw( aDrawable, nDepth, *pPosAry, aGC, bWindow_ );
+    
+    if( rSalBitmap.GetBitCount() == 1 )
+        XChangeGC( pXDisp, aGC, nValues, &aOldVal );
+    XFlush( pXDisp );
+}
+
+// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+
+void X11SalGraphics::drawBitmap( const SalTwoRect* pPosAry,
+                                 const SalBitmap& rSalBitmap,
+                                 const SalBitmap& rTransBitmap )
+{
+    DBG_ASSERT( !bPrinter_, "Drawing of transparent bitmaps on printer devices is strictly forbidden" );
+
+    SalDisplay*		pSalDisp = GetDisplay();
+    Display*		pXDisp = pSalDisp->GetDisplay();
+    Drawable		aDrawable( GetDrawable() );
+    const USHORT	nDepth = pSalDisp->GetVisual()->GetDepth();
+    Pixmap			aFG( XCreatePixmap( pXDisp, aDrawable, pPosAry->mnDestWidth,
+                                        pPosAry->mnDestHeight, nDepth ) );
+    Pixmap			aBG( XCreatePixmap( pXDisp, aDrawable, pPosAry->mnDestWidth,
+                                        pPosAry->mnDestHeight, nDepth ) );
+    
+    if( aFG && aBG )
+    {
+        GC					aTmpGC;
+        XGCValues			aValues;
         const SalColormap&	rColMap = pSalDisp->GetColormap();
-        const long			nDepth = maGraphicsData.GetDisplay()->GetVisual()->GetDepth();
-        GC					aGC( maGraphicsData.GetCopyGC() );
-        XGCValues			aOldVal, aNewVal;
-        int					nValues = GCForeground | GCBackground;
-
-		if( rSalBitmap.GetBitCount() == 1 )
-		{
-				// set foreground/background values for 1Bit bitmaps
-				XGetGCValues( pXDisp, aGC, nValues, &aOldVal );
-				aNewVal.foreground = rColMap.GetWhitePixel(), aNewVal.background = rColMap.GetBlackPixel();
-				XChangeGC( pXDisp, aGC, nValues, &aNewVal );
-		}
-
-#if defined(_USE_PRINT_EXTENSION_)
-		rSalBitmap.ImplDraw( pSalDisp, aDrawable, nDepth, *pPosAry,  aGC );
-#else
-		rSalBitmap.ImplDraw( aDrawable, nDepth, *pPosAry, aGC );
-#endif
-
-		if( rSalBitmap.GetBitCount() == 1 )
-				XChangeGC( pXDisp, aGC, nValues, &aOldVal );
-        XFlush( pXDisp );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
-}
-
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap,
-									const SalBitmap& rTransBitmap, const OutputDevice *pOutDev )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR("Error: no PrinterGfx::DrawBitmap() for transparent bitmap");
-	}
-	else
-	{
-#endif
-
-        DBG_ASSERT( !_IsPrinter(), "Drawing of transparent bitmaps on printer devices is strictly forbidden" );
-
-        SalDisplay*		pSalDisp = maGraphicsData.GetDisplay();
-        Display*		pXDisp = pSalDisp->GetDisplay();
-        Drawable		aDrawable( maGraphicsData.GetDrawable() );
-        const USHORT	nDepth = pSalDisp->GetVisual()->GetDepth();
-        Pixmap			aFG( XCreatePixmap( pXDisp, aDrawable, pPosAry->mnDestWidth,
-                                            pPosAry->mnDestHeight, nDepth ) );
-        Pixmap			aBG( XCreatePixmap( pXDisp, aDrawable, pPosAry->mnDestWidth,
-                                            pPosAry->mnDestHeight, nDepth ) );
-
-        if( aFG && aBG )
+        const int			nBlack = rColMap.GetBlackPixel(), nWhite = rColMap.GetWhitePixel();
+        const int			nValues = GCFunction | GCForeground | GCBackground;
+        SalTwoRect			aTmpRect( *pPosAry ); aTmpRect.mnDestX = aTmpRect.mnDestY = 0;
+        
+        // draw paint bitmap in pixmap #1
+        aValues.function = GXcopy, aValues.foreground = nWhite, aValues.background = nBlack;
+        aTmpGC = XCreateGC( pXDisp, aFG, nValues, &aValues );
+        static_cast<const X11SalBitmap&>(rSalBitmap).ImplDraw( aFG, nDepth, aTmpRect, aTmpGC, false );
+        DBG_TESTTRANS( aFG );
+
+        // draw background in pixmap #2
+        XCopyArea( pXDisp, aDrawable, aBG, aTmpGC,
+                   pPosAry->mnDestX, pPosAry->mnDestY,
+                   pPosAry->mnDestWidth, pPosAry->mnDestHeight,
+                   0, 0 );
+
+        DBG_TESTTRANS( aBG );
+        
+        // mask out paint bitmap in pixmap #1 (transparent areas 0)
+        aValues.function = GXand, aValues.foreground = 0x00000000, aValues.background = 0xffffffff;
+        XChangeGC( pXDisp, aTmpGC, nValues, &aValues );
+        static_cast<const X11SalBitmap&>(rTransBitmap).ImplDraw( aFG, 1, aTmpRect, aTmpGC, false );
+        
+        DBG_TESTTRANS( aFG );
+        
+        // #105055# For XOR mode, keep background behind bitmap intact
+        if( !bXORMode_ )
         {
-            GC					aTmpGC;
-            XGCValues			aValues;
-            const SalColormap&	rColMap = pSalDisp->GetColormap();
-            const int			nBlack = rColMap.GetBlackPixel(), nWhite = rColMap.GetWhitePixel();
-            const int			nValues = GCFunction | GCForeground | GCBackground;
-            SalTwoRect			aTmpRect( *pPosAry ); aTmpRect.mnDestX = aTmpRect.mnDestY = 0;
-
-            // draw paint bitmap in pixmap #1
-            aValues.function = GXcopy, aValues.foreground = nWhite, aValues.background = nBlack;
-            aTmpGC = XCreateGC( pXDisp, aFG, nValues, &aValues );
-#ifdef _USE_PRINT_EXTENSION_
-            rSalBitmap.ImplDraw( pSalDisp, aFG, nDepth, aTmpRect, aTmpGC );
-#else
-            rSalBitmap.ImplDraw( aFG, nDepth, aTmpRect, aTmpGC );
-#endif
-            DBG_TESTTRANS( aFG );
-
-            // draw background in pixmap #2
-            XCopyArea( pXDisp, aDrawable, aBG, aTmpGC,
-                       pPosAry->mnDestX, pPosAry->mnDestY,
-                       pPosAry->mnDestWidth, pPosAry->mnDestHeight,
-                       0, 0 );
-            DBG_TESTTRANS( aBG );
-
-            // mask out paint bitmap in pixmap #1 (transparent areas 0)
-            aValues.function = GXand, aValues.foreground = 0x00000000, aValues.background = 0xffffffff;
+            // mask out background in pixmap #2 (nontransparent areas 0)
+            aValues.function = GXand, aValues.foreground = 0xffffffff, aValues.background = 0x00000000;
             XChangeGC( pXDisp, aTmpGC, nValues, &aValues );
-#ifdef _USE_PRINT_EXTENSION_
-            rTransBitmap.ImplDraw( pSalDisp, aFG, 1, aTmpRect, aTmpGC );
-#else
-            rTransBitmap.ImplDraw( aFG, 1, aTmpRect, aTmpGC );
-#endif
-
-            DBG_TESTTRANS( aFG );
-
-            // #105055# For XOR mode, keep background behind bitmap intact
-            if( !maGraphicsData.bXORMode_ )
-            {
-                // mask out background in pixmap #2 (nontransparent areas 0)
-                aValues.function = GXand, aValues.foreground = 0xffffffff, aValues.background = 0x00000000;
-                XChangeGC( pXDisp, aTmpGC, nValues, &aValues );
-#ifdef _USE_PRINT_EXTENSION_
-                rTransBitmap.ImplDraw( pSalDisp, aBG, 1, aTmpRect, aTmpGC );
-#else
-                rTransBitmap.ImplDraw( aBG, 1, aTmpRect, aTmpGC );
-#endif
-
-                DBG_TESTTRANS( aBG );
-            }
-
-            // merge pixmap #1 and pixmap #2 in pixmap #2
-            aValues.function = GXxor, aValues.foreground = 0xffffffff, aValues.background = 0x00000000;
-            XChangeGC( pXDisp, aTmpGC, nValues, &aValues );
-            XCopyArea( pXDisp, aFG, aBG, aTmpGC,
-                       0, 0,
-                       pPosAry->mnDestWidth, pPosAry->mnDestHeight,
-				   0, 0 );
-            DBG_TESTTRANS( aBG );
-
-            // #105055# Disable XOR temporarily
-            BOOL bOldXORMode( maGraphicsData.bXORMode_ );
-            maGraphicsData.bXORMode_ = FALSE;
-
-            // copy pixmap #2 (result) to background
-            XCopyArea( pXDisp, aBG, aDrawable, maGraphicsData.GetCopyGC(),
-                       0, 0,
-                       pPosAry->mnDestWidth, pPosAry->mnDestHeight,
-                       pPosAry->mnDestX, pPosAry->mnDestY );
+            static_cast<const X11SalBitmap&>(rTransBitmap).ImplDraw( aBG, 1, aTmpRect, aTmpGC, false );
+            
             DBG_TESTTRANS( aBG );
-
-            maGraphicsData.bXORMode_ = bOldXORMode;
-
-            XFreeGC( pXDisp, aTmpGC );
-            XFlush( pXDisp );
         }
-        else
-            DrawBitmap( pPosAry, rSalBitmap, pOutDev );
-
-        if( aFG )
-            XFreePixmap( pXDisp, aFG );
-
-        if( aBG )
-            XFreePixmap( pXDisp, aBG );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+        
+        // merge pixmap #1 and pixmap #2 in pixmap #2
+        aValues.function = GXxor, aValues.foreground = 0xffffffff, aValues.background = 0x00000000;
+        XChangeGC( pXDisp, aTmpGC, nValues, &aValues );
+        XCopyArea( pXDisp, aFG, aBG, aTmpGC,
+                   0, 0,
+                   pPosAry->mnDestWidth, pPosAry->mnDestHeight,
+				   0, 0 );
+        DBG_TESTTRANS( aBG );
+        
+        // #105055# Disable XOR temporarily
+        BOOL bOldXORMode( bXORMode_ );
+        bXORMode_ = FALSE;
+        
+        // copy pixmap #2 (result) to background
+        XCopyArea( pXDisp, aBG, aDrawable, GetCopyGC(),
+                   0, 0,
+                   pPosAry->mnDestWidth, pPosAry->mnDestHeight,
+                   pPosAry->mnDestX, pPosAry->mnDestY );
+        YieldGraphicsExpose( pXDisp, bWindow_ ? m_pFrame : NULL, aDrawable );
+        
+        DBG_TESTTRANS( aBG );
+        
+        bXORMode_ = bOldXORMode;
+        
+        XFreeGC( pXDisp, aTmpGC );
+        XFlush( pXDisp );
+    }
+    else
+        drawBitmap( pPosAry, rSalBitmap );
+    
+    if( aFG )
+        XFreePixmap( pXDisp, aFG );
+    
+    if( aBG )
+        XFreePixmap( pXDisp, aBG );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawBitmap( const SalTwoRect* pPosAry, const SalBitmap& rSalBitmap,
-							  SalColor nTransparentColor, const OutputDevice* )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR("Error: no PrinterGfx::DrawBitmap() for transparent color");
-	}
-	else
-	{
-#endif
-
-        DBG_ERROR( "::DrawBitmap with transparent color not supported" );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+void X11SalGraphics::drawBitmap( const SalTwoRect* pPosAry,
+                                 const SalBitmap& rSalBitmap,
+                                 SalColor nTransparentColor )
+{
+    DBG_ERROR( "::DrawBitmap with transparent color not supported" );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::DrawMask( const SalTwoRect* pPosAry, const SalBitmap &rSalBitmap,
-								  SalColor nMaskColor, const OutputDevice *pOutDev )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR("Error: PrinterGfx::DrawMask() not implemented");
-	}
-	else
-	{
-#endif
-
-        SalDisplay*	pSalDisp = maGraphicsData.GetDisplay();
-        Display*	pXDisp = pSalDisp->GetDisplay();
-        Drawable	aDrawable( maGraphicsData.GetDrawable() );
-        Pixmap		aStipple( XCreatePixmap( pXDisp, aDrawable,
-                                             pPosAry->mnDestWidth,
-                                             pPosAry->mnDestHeight, 1 ) );
-
-        if( aStipple )
-        {
-            SalTwoRect	aTwoRect( *pPosAry ); aTwoRect.mnDestX = aTwoRect.mnDestY = 0;
-            GC			aTmpGC;
-            XGCValues	aValues;
-
-            // create a stipple bitmap first (set bits are changed to unset bits and vice versa)
-            aValues.function = GXcopyInverted;
-            aValues.foreground = 1, aValues.background = 0;
-            aTmpGC = XCreateGC( pXDisp, aStipple, GCFunction | GCForeground | GCBackground, &aValues );
-#ifdef _USE_PRINT_EXTENSION_
-            rSalBitmap.ImplDraw( pSalDisp, aStipple, 1, aTwoRect, aTmpGC );
-#else
-            rSalBitmap.ImplDraw( aStipple, 1, aTwoRect, aTmpGC );
-#endif
-
-            XFreeGC( pXDisp, aTmpGC );
-
-            // Set stipple and draw rectangle
-            GC	aStippleGC( maGraphicsData.GetStippleGC() );
-            int	nX = pPosAry->mnDestX, nY = pPosAry->mnDestY;
-
-            XSetStipple( pXDisp, aStippleGC, aStipple );
-            XSetTSOrigin( pXDisp, aStippleGC, nX, nY );
-            XSetForeground( pXDisp, aStippleGC, _GetPixel( nMaskColor ) );
-            XFillRectangle( pXDisp, aDrawable, aStippleGC,
-                            nX, nY,
-                            pPosAry->mnDestWidth, pPosAry->mnDestHeight );
-            XFreePixmap( pXDisp, aStipple );
-            XFlush( pXDisp );
-        }
-        else
-            DrawBitmap( pPosAry, rSalBitmap, pOutDev );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+void X11SalGraphics::drawMask( const SalTwoRect* pPosAry,
+                               const SalBitmap &rSalBitmap,
+                               SalColor nMaskColor )
+{
+    SalDisplay*	pSalDisp = GetDisplay();
+    Display*	pXDisp = pSalDisp->GetDisplay();
+    Drawable	aDrawable( GetDrawable() );
+    Pixmap		aStipple( XCreatePixmap( pXDisp, aDrawable,
+                                         pPosAry->mnDestWidth,
+                                         pPosAry->mnDestHeight, 1 ) );
+    
+    if( aStipple )
+    {
+        SalTwoRect	aTwoRect( *pPosAry ); aTwoRect.mnDestX = aTwoRect.mnDestY = 0;
+        GC			aTmpGC;
+        XGCValues	aValues;
+        
+        // create a stipple bitmap first (set bits are changed to unset bits and vice versa)
+        aValues.function = GXcopyInverted;
+        aValues.foreground = 1, aValues.background = 0;
+        aTmpGC = XCreateGC( pXDisp, aStipple, GCFunction | GCForeground | GCBackground, &aValues );
+        static_cast<const X11SalBitmap&>(rSalBitmap).ImplDraw( aStipple, 1, aTwoRect, aTmpGC, false );
+        
+        XFreeGC( pXDisp, aTmpGC );
+        
+        // Set stipple and draw rectangle
+        GC	aStippleGC( GetStippleGC() );
+        int	nX = pPosAry->mnDestX, nY = pPosAry->mnDestY;
+        
+        XSetStipple( pXDisp, aStippleGC, aStipple );
+        XSetTSOrigin( pXDisp, aStippleGC, nX, nY );
+        XSetForeground( pXDisp, aStippleGC, GetPixel( nMaskColor ) );
+        XFillRectangle( pXDisp, aDrawable, aStippleGC,
+                        nX, nY,
+                        pPosAry->mnDestWidth, pPosAry->mnDestHeight );
+        XFreePixmap( pXDisp, aStipple );
+        XFlush( pXDisp );
+    }
+    else
+        drawBitmap( pPosAry, rSalBitmap );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalBitmap *SalGraphics::GetBitmap( long nX, long nY, long nDX, long nDY, const OutputDevice* )
+SalBitmap *X11SalGraphics::getBitmap( long nX, long nY, long nDX, long nDY )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_WARNING ("Warning: PrinterGfx::GetBitmap() not implemented");
-		return NULL;
-	}
-	else
-	{
-#endif
-
-        if( _IsPrinter() && !_IsVirtualDevice() )
+    if( bPrinter_ && !bVirDev_ )
+        return NULL;
+    
+    if( bWindow_ && !bVirDev_ )
+    {
+        // normalize
+        if( nDX < 0 )
+        {
+            nX += nDX;
+            nDX = -nDX;
+        }
+        if ( nDY < 0 )
+        {
+            nY += nDY;
+            nDY = -nDY;
+        }
+        
+        XWindowAttributes aAttrib;
+        
+        XGetWindowAttributes( GetXDisplay(), GetDrawable(), &aAttrib );
+        if( aAttrib.map_state != IsViewable )
+        {
+            stderr0( "X11SalGraphics::GetBitmap drawable not viewable\n" );
             return NULL;
-
-        if( _IsWindow() && !_IsVirtualDevice() )
+        }
+        
+        // am Window clippen (eg)
+        if ( nX < 0 )
         {
-            // normalize
-            if( nDX < 0 )
-            {
-                nX += nDX;
-                nDX = -nDX;
-            }
-            if ( nDY < 0 )
-            {
-                nY += nDY;
-                nDY = -nDY;
-            }
-
-            XWindowAttributes aAttrib;
-
-            XGetWindowAttributes( _GetXDisplay(), _GetDrawable(), &aAttrib );
-            if( aAttrib.map_state != IsViewable )
-            {
-                stderr0( "SalGraphics::GetBitmap drawable not viewable\n" );
-                return NULL;
-            }
-
-            // am Window clippen (eg)
-            if ( nX < 0 )
-            {
-                nDX += nX;
-                nX   = 0;
-            }
-            if ( nY < 0 )
-            {
-                nDY += nY;
-                nY   = 0;
-            }
-            if( nX + nDX > aAttrib.width )
-                nDX = aAttrib.width  - nX;
-            if( nY + nDY > aAttrib.height )
-                nDY = aAttrib.height - nY;
-
-            // nun alles ok ?
-            if( nDX <= 0 || nDY <= 0 )
-            {
-                stderr0( "SalGraphics::GetBitmap zero sized bitmap after clipping\n" );
-                return NULL;
-            }
+            nDX += nX;
+            nX   = 0;
         }
-
-        SalBitmap*	pSalBitmap = new SalBitmap;
-        USHORT		nBitCount = GetBitCount();
-
-        if( &_GetDisplay()->GetColormap() != &_GetColormap() )
-            nBitCount = 1;
-
-		pSalBitmap->ImplCreateLocalFromDrawable( _GetDrawable(), nBitCount, nX, nY, nDX, nDY );
-        return pSalBitmap;
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
-}
-
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalColor SalGraphics::GetPixel( long nX, long nY, const OutputDevice* )
-{
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR ("Warning: PrinterGfx::GetPixel() not implemented");
-		return 0;
-	}
-	else
-	{
-#endif
-
-        if( _IsWindow() && !_IsVirtualDevice() )
+        if ( nY < 0 )
         {
-            XWindowAttributes aAttrib;
-
-            XGetWindowAttributes( _GetXDisplay(), _GetDrawable(), &aAttrib );
-            if( aAttrib.map_state != IsViewable )
-            {
-                stderr0( "SalGraphics::GetPixel drawable not viewable\n" );
-                return 0;
-            }
+            nDY += nY;
+            nY   = 0;
+        }
+        if( nX + nDX > aAttrib.width )
+            nDX = aAttrib.width  - nX;
+        if( nY + nDY > aAttrib.height )
+            nDY = aAttrib.height - nY;
+        
+        // nun alles ok ?
+        if( nDX <= 0 || nDY <= 0 )
+        {
+            stderr0( "X11SalGraphics::GetBitmap zero sized bitmap after clipping\n" );
+            return NULL;
         }
+    }
+    
+    X11SalBitmap*	pSalBitmap = new X11SalBitmap;
+    USHORT			nBitCount = GetBitCount();
+    
+    if( &GetDisplay()->GetColormap() != &GetColormap() )
+        nBitCount = 1;
+    
+    
+    pSalBitmap->ImplCreateFromDrawable( GetDrawable(), nBitCount, nX, nY, nDX, nDY );
+    return pSalBitmap;
+}
 
-        XImage *pXImage = XGetImage( _GetXDisplay(),
-                                     _GetDrawable(),
-                                     nX, nY,
-                                     1,  1,
-                                     AllPlanes,
-                                     ZPixmap );
-        if( !pXImage )
+// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+SalColor X11SalGraphics::getPixel( long nX, long nY )
+{
+    if( bWindow_ && !bVirDev_ )
+    {
+        XWindowAttributes aAttrib;
+        
+        XGetWindowAttributes( GetXDisplay(), GetDrawable(), &aAttrib );
+        if( aAttrib.map_state != IsViewable )
         {
-            stderr0( "SalGraphics::GetPixel !XGetImage()\n" );
+            stderr0( "X11SalGraphics::GetPixel drawable not viewable\n" );
             return 0;
         }
-
-        XColor aXColor;
-
-        aXColor.pixel = XGetPixel( pXImage, 0, 0 );
-        XDestroyImage( pXImage );
-
-        return _GetColormap().GetColor( aXColor.pixel );
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+    }
+    
+    XImage *pXImage = XGetImage( GetXDisplay(),
+                                     GetDrawable(),
+                                 nX, nY,
+                                 1,  1,
+                                 AllPlanes,
+                                 ZPixmap );
+    if( !pXImage )
+    {
+        stderr0( "X11SalGraphics::GetPixel !XGetImage()\n" );
+        return 0;
+    }
+    
+    XColor aXColor;
+    
+    aXColor.pixel = XGetPixel( pXImage, 0, 0 );
+    XDestroyImage( pXImage );
+    
+    return GetColormap().GetColor( aXColor.pixel );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphics::Invert( long		nX,
+void X11SalGraphics::invert( long		nX,
 								long		nY,
 								long		nDX,
 								long		nDY,
-								SalInvert	nFlags, const OutputDevice* )
+								SalInvert	nFlags )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		DBG_ERROR ("Warning: PrinterGfx::Invert() not implemented");
-	}
-	else
-	{
-#endif
-
-        SalDisplay *pDisp = _GetDisplay();
-
-        GC pGC;
-        if( SAL_INVERT_50 & nFlags )
+    SalDisplay *pDisp = GetDisplay();
+    
+    GC pGC;
+    if( SAL_INVERT_50 & nFlags )
+    {
+        pGC = GetInvert50GC();
+        XFillRectangle( GetXDisplay(), GetDrawable(), pGC, nX, nY, nDX, nDY );
+    }
+    else
+    {
+        if ( SAL_INVERT_TRACKFRAME & nFlags )
         {
-            pGC = maGraphicsData.GetInvert50GC();
-            XFillRectangle( _GetXDisplay(), _GetDrawable(), pGC, nX, nY, nDX, nDY );
+            pGC = GetTrackingGC();
+            XDrawRectangle( GetXDisplay(), GetDrawable(),  pGC, nX, nY, nDX, nDY );
         }
         else
-            if ( SAL_INVERT_TRACKFRAME & nFlags )
-            {
-                pGC = maGraphicsData.GetTrackingGC();
-                XDrawRectangle( _GetXDisplay(), _GetDrawable(),  pGC, nX, nY, nDX, nDY );
-            }
-            else
-            {
-                pGC = maGraphicsData.GetInvertGC();
-                XFillRectangle( _GetXDisplay(), _GetDrawable(),  pGC, nX, nY, nDX, nDY );
-            }
-
-#ifndef _USE_PRINT_EXTENSION_
-	}
-#endif
+        {
+            pGC = GetInvertGC();
+            XFillRectangle( GetXDisplay(), GetDrawable(),  pGC, nX, nY, nDX, nDY );
+        }
+    }
 }
 
Index: vcl/unx/source/gdi/salgdi3.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/salgdi3.cxx,v
retrieving revision 1.105.46.5
retrieving revision 1.119
diff -u -p -u -r1.105.46.5 -r1.119
--- vcl/unx/source/gdi/salgdi3.cxx	13 Feb 2004 14:03:54 -0000	1.105.46.5
+++ vcl/unx/source/gdi/salgdi3.cxx	17 Jun 2004 12:29:09 -0000	1.119
@@ -59,10 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALGDI3_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -76,9 +72,7 @@
 #include <alloca.h>
 #endif
 
-#ifdef USE_BUILTIN_RASTERIZER
 #include <gcach_xpeer.hxx>
-#endif // USE_BUILTIN_RASTERIZER
 
 #ifndef _SAL_TYPES_H_
 #include <sal/types.h>
@@ -92,14 +86,17 @@
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
+#endif
+#ifndef _VCL_PSPGRAPHICS_H
+#include <pspgraphics.h>
 #endif
 #ifndef _SV_SALFRAME_HXX
 #include <salframe.hxx>
 #endif
-#ifndef _SV_SALVD_HXX
-#include <salvd.hxx>
+#ifndef _SV_SALVD_H
+#include <salvd.h>
 #endif
 #ifndef _SV_OUTDEV_H
 #include <outdev.h>
@@ -107,8 +104,8 @@
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
-#ifndef _SV_POLY_HXX
-#include <poly.hxx>
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
 #endif
 #ifndef _RTL_TENCINFO_H
 #include <rtl/tencinfo.h>
@@ -132,9 +129,6 @@
 #include <svapp.hxx>
 #endif
 
-#ifndef ANSI1252_HXX_
-#include "ansi1252.hxx"
-#endif
 #ifndef XLFD_ATTRIBUTE_HXX
 #include "xlfd_attr.hxx"
 #endif
@@ -155,106 +149,12 @@
 
 // -----------------------------------------------------------------------
 
-#ifdef USE_BUILTIN_RASTERIZER
 static X11GlyphPeer aX11GlyphPeer;
-#endif // USE_BUILTIN_RASTERIZER
 
 using namespace rtl;
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-/*
- *  returns:
- *  true: cut out positions rStart to rStop from output because fax number was swallowed
- *  false: do nothing
- */
-
-String SalGraphicsData::FaxPhoneComment( const String& rOrig, xub_StrLen nIndex, xub_StrLen& rLen, xub_StrLen& rCutStart, xub_StrLen& rCutStop ) const
-{
-    rCutStop = rCutStart = STRING_NOTFOUND;
-
-#ifdef _USE_PRINT_EXTENSION_
-    return String( rOrig );
-#else
-	if( ! m_pPhoneNr )
-		return String( rOrig );
-#endif
-
-#define FAX_PHONE_TOKEN          "@@#"
-#define FAX_PHONE_TOKEN_LENGTH   3
-#define FAX_END_TOKEN            "@@"
-#define FAX_END_TOKEN_LENGTH     2
-
-	bool bRet = false;
-	bool bStarted = false;
-	bool bStopped = false;
-	USHORT nPos;
-	USHORT nStart = 0;
-	USHORT nStop = rLen;
-	String aPhone = rOrig.Copy( nIndex, rLen );
-
-	static String aPhoneNumber;
-	static bool bIsCollecting = false;
-
-	if( ! bIsCollecting )
-	{
-		if( ( nPos = aPhone.SearchAscii( FAX_PHONE_TOKEN ) ) != STRING_NOTFOUND )
-		{
-			nStart = nPos;
-			bIsCollecting = true;
-			aPhoneNumber.Erase();
-			bRet = true;
-			bStarted = true;
-		}
-	}
-	if( bIsCollecting )
-	{
-		bRet = true;
-		nPos = bStarted ? nStart + FAX_PHONE_TOKEN_LENGTH : 0;
-		if( ( nPos = aPhone.SearchAscii( FAX_END_TOKEN, nPos ) ) != STRING_NOTFOUND )
-		{
-			bIsCollecting = false;
-			nStop = nPos + FAX_END_TOKEN_LENGTH;
-			bStopped = true;
-		}
-		int nTokenStart = nStart + (bStarted ? FAX_PHONE_TOKEN_LENGTH : 0);
-		int nTokenStop = nStop - (bStopped ? FAX_END_TOKEN_LENGTH : 0);
-		aPhoneNumber += aPhone.Copy( nTokenStart, nTokenStop - nTokenStart );
-		if( ! bIsCollecting )
-		{
-#ifndef PRINTER_DUMMY
-			*m_pPhoneNr = aPhoneNumber;
-#endif
-			aPhoneNumber.Erase();
-		}
-	}
-	if( aPhoneNumber.Len() > 1024 )
-	{
-		bIsCollecting = false;
-		aPhoneNumber.Erase();
-		bRet = false;
-	}
-
-    String aRet;
-    if( bRet
-#ifndef MACOSX
-        && m_bSwallowFaxNo
-#endif
-        )
-    {
-        rLen -= nStop - nStart;
-        rCutStart = nStart+nIndex;
-        rCutStop = nStop+nIndex;
-        if( rCutStart )
-            aRet = rOrig.Copy( 0, rCutStart );
-        aRet += rOrig.Copy( rCutStop );
-    }
-    else
-        aRet = rOrig;
-
-    return aRet;
-}
-
 // ----------------------------------------------------------------------------
 //
 // manage X11 fonts and self rastered fonts
@@ -263,9 +163,6 @@ String SalGraphicsData::FaxPhoneComment(
 
 #ifndef _USE_PRINT_EXTENSION_
 
-static FontItalic ToFontItalic (psp::italic::type eItalic);
-static FontWeight ToFontWeight (psp::weight::type eWeight);
-
 class FontLookup
 {
 	public:
@@ -278,21 +175,20 @@ class FontLookup
 
 	private:
 
+		rtl::OString		maName;
 		FontWeight 			mnWeight;
 		FontItalic 			mnItalic;
 		sal_Bool			mbDisplay;
 
-		rtl::OString		maName;
-
 	public:
 
 							FontLookup ( ::std::list< psp::fontID >::iterator& it,
 							 			 const psp::PrintFontManager& rMgr );
 							FontLookup (const Xlfd& rFont);
 							FontLookup (const FontLookup &rRef) :
+									maName   (rRef.maName),
 									mnWeight (rRef.mnWeight),
 									mnItalic (rRef.mnItalic),
-									maName   (rRef.maName),
 									mbDisplay(rRef.mbDisplay)
 							{}
 							~FontLookup ()
@@ -345,8 +241,8 @@ FontLookup::FontLookup ( ::std::list< ps
 	psp::FastPrintFontInfo aInfo;
 	if (rMgr.getFontFastInfo (*it, aInfo))
 	{
-		mnItalic = ToFontItalic (aInfo.m_eItalic);
-		mnWeight = ToFontWeight (aInfo.m_eWeight);
+		mnItalic = PspGraphics::ToFontItalic (aInfo.m_eItalic);
+		mnWeight = PspGraphics::ToFontWeight (aInfo.m_eWeight);
 		mbDisplay=    aInfo.m_eType == psp::fonttype::Builtin
 				   || aInfo.m_eType == psp::fonttype::Unknown ? False : True;
 		maName   = rtl::OUStringToOString
@@ -588,7 +484,7 @@ SalDisplay::GetFont( const ExtendedXlfd 
 				if( pFontCache_->GetCurPos() )
 				{
 					pFontCache_->Remove( pItem );
-					pFontCache_->Insert( pItem, 0UL );
+					pFontCache_->Insert( pItem, (sal_uInt32)0 );
 				}
 				return pItem;
 			}
@@ -618,7 +514,7 @@ SalDisplay::GetFont( const ExtendedXlfd 
 	ExtendedFontStruct *pItem = new ExtendedFontStruct( GetDisplay(),
 										rPixelSize, bVertical,
 										const_cast<ExtendedXlfd*>(pRequestedFont) );
-	pFontCache_->Insert( pItem, 0UL );
+	pFontCache_->Insert( pItem, (sal_uInt32)0 );
 	pItem->AddRef();
 
 	return pItem;
@@ -656,12 +552,12 @@ SalDisplay::DestroyFontCache()
 
 // ----------------------------------------------------------------------------
 //
-// SalGraphicsData
+// X11SalGraphics
 //
 // ----------------------------------------------------------------------------
 
 GC
-SalGraphicsData::SelectFont()
+X11SalGraphics::SelectFont()
 {
 	Display *pDisplay = GetXDisplay();
 
@@ -697,9 +593,8 @@ SalGraphicsData::SelectFont()
 
 //--------------------------------------------------------------------------
 
-bool SalGraphicsData::SetFont( const ImplFontSelectData *pEntry, int nFallbackLevel )
+bool X11SalGraphics::setFont( const ImplFontSelectData *pEntry, int nFallbackLevel )
 {
-    nFontOrientation_   = pEntry->mnOrientation;
     bFontVertical_      = pEntry->mbVertical;
 
 #ifdef HDU_DEBUG
@@ -740,9 +635,6 @@ bool SalGraphicsData::SetFont( const Imp
         return true;
     }
 
-    if( m_pPrinterGfx != NULL )
-        return false;
-
     bFontGC_    = FALSE;
     ExtendedXlfd *pSysFont = (ExtendedXlfd*)pEntry->mpFontData->mpSysData;
     if( !pSysFont )
@@ -834,8 +726,7 @@ ConvertTextItem16( XTextItem16* pTextIte
 
 //--------------------------------------------------------------------------
 
-#ifdef USE_BUILTIN_RASTERIZER
-void SalGraphicsData::DrawServerAAFontString( const ServerFontLayout& rLayout )
+void X11SalGraphics::DrawServerAAFontString( const ServerFontLayout& rLayout )
 {
     Display* pDisplay = GetXDisplay();
     Visual* pVisual = GetDisplay()->GetVisual()->GetVisual();
@@ -843,7 +734,7 @@ void SalGraphicsData::DrawServerAAFontSt
 
     // create xrender Picture for font foreground
     static Pixmap aPixmap;
-    static Picture aSrc = NULL;
+    static Picture aSrc = 0;
     if( !aSrc )
     {
         int iDummy;
@@ -879,7 +770,7 @@ void SalGraphicsData::DrawServerAAFontSt
 
     Point aPos;
     static const int MAXGLYPHS = 160;
-    long aGlyphAry[ MAXGLYPHS ];
+    sal_Int32 aGlyphAry[ MAXGLYPHS ];
     int nMaxGlyphs = rLayout.GetOrientation() ? 1 : MAXGLYPHS;
     for( int nStart = 0;;)
     {
@@ -900,7 +791,7 @@ void SalGraphicsData::DrawServerAAFontSt
 
 //--------------------------------------------------------------------------
 
-bool SalGraphicsData::DrawServerAAForcedString( const ServerFontLayout& rLayout )
+bool X11SalGraphics::DrawServerAAForcedString( const ServerFontLayout& rLayout )
 {
     ServerFont& rFont = rLayout.GetServerFont();
 
@@ -908,7 +799,7 @@ bool SalGraphicsData::DrawServerAAForced
     int nXmin, nXmax, nYmin, nYmax;
     int nStart = 0;
     Point aPos;
-    long nGlyph;
+    sal_Int32 nGlyph;
     for( bool bFirst=true; rLayout.GetNextGlyphs( 1, &nGlyph, aPos, nStart ); )
     {
         const RawBitmap* const pRawBitmap = aX11GlyphPeer.GetRawBitmap( rFont, nGlyph );
@@ -947,7 +838,7 @@ bool SalGraphicsData::DrawServerAAForced
     if( m_pFrame )
         nWidth = m_pFrame->maGeometry.nWidth, nHeight = m_pFrame->maGeometry.nHeight;
     else if( m_pVDev )
-        nWidth = m_pVDev->maVirDevData.GetWidth(), nHeight = m_pVDev->maVirDevData.GetHeight();
+        nWidth = m_pVDev->GetWidth(), nHeight = m_pVDev->GetHeight();
 
     if( pClipRegion_ && !XEmptyRegion( pClipRegion_ ) )
     {
@@ -1082,7 +973,7 @@ bool SalGraphicsData::DrawServerAAForced
 
 //--------------------------------------------------------------------------
 
-void SalGraphicsData::DrawServerSimpleFontString( const ServerFontLayout& rSalLayout )
+void X11SalGraphics::DrawServerSimpleFontString( const ServerFontLayout& rSalLayout )
 {
     ServerFont& rFont = rSalLayout.GetServerFont();
 
@@ -1096,7 +987,7 @@ void SalGraphicsData::DrawServerSimpleFo
     XCopyGC( pDisplay, nGC, (1<<GCLastBit)-(1+GCFillStyle+GCLineWidth), tmpGC );
 
     Point aPos;
-    long nGlyph;
+    sal_Int32 nGlyph;
     for( int nStart = 0; rSalLayout.GetNextGlyphs( 1, &nGlyph, aPos, nStart ); )
     {
         Pixmap aStipple = aX11GlyphPeer.GetPixmap( rFont, nGlyph );
@@ -1124,186 +1015,27 @@ void SalGraphicsData::DrawServerSimpleFo
 
 //--------------------------------------------------------------------------
 
-#ifndef _USE_PRINT_EXTENSION_
-
-class PspFontLayout : public GenericSalLayout
-{
-public:
-                        PspFontLayout( ::psp::PrinterGfx& );
-    virtual bool        LayoutText( ImplLayoutArgs& );
-    virtual void        InitFont() const;
-    virtual void        DrawText( SalGraphics& ) const;
-private:
-    ::psp::PrinterGfx&  mrPrinterGfx;
-    int                 mnFontID;
-    int                 mnFontHeight;
-    int                 mnFontWidth;
-    bool                mbVertical;
-};
-
-//--------------------------------------------------------------------------
-
-PspFontLayout::PspFontLayout( ::psp::PrinterGfx& rGfx )
-:   mrPrinterGfx( rGfx )
-{
-    mnFontID     = mrPrinterGfx.GetFontID();
-    mnFontHeight = mrPrinterGfx.GetFontHeight();
-    mnFontWidth  = mrPrinterGfx.GetFontWidth();
-    mbVertical   = mrPrinterGfx.GetFontVertical();
-}
-
-//--------------------------------------------------------------------------
-
-bool PspFontLayout::LayoutText( ImplLayoutArgs& rArgs )
-{
-    mbVertical = ((rArgs.mnFlags & SAL_LAYOUT_VERTICAL) != 0);
-
-    long nUnitsPerPixel = 1;
-    int nOldGlyphId = -1;
-    long nGlyphWidth = 0;
-    int nCharPos = -1;
-    Point aNewPos( 0, 0 );
-    GlyphItem aPrevItem;
-    rtl_TextEncoding aFontEnc = mrPrinterGfx.GetFontMgr().getFontEncoding( mnFontID );
-    for(;;)
-    {
-        bool bRightToLeft;
-        if( !rArgs.GetNextPos( &nCharPos, &bRightToLeft ) )
-            break;
-
-        sal_Unicode cChar = rArgs.mpStr[ nCharPos ];
-        if( bRightToLeft )
-            cChar = GetMirroredChar( cChar );
-        // symbol font aliasing: 0x0020-0x00ff -> 0xf020 -> 0xf0ff
-        if( aFontEnc == RTL_TEXTENCODING_SYMBOL )
-            if( cChar < 256 )
-                cChar += 0xf000;
-        int nGlyphIndex = cChar;  // printer glyphs = unicode
-
-        // update fallback_runs if needed
-        psp::CharacterMetric aMetric;
-        mrPrinterGfx.GetFontMgr().getMetrics( mnFontID, cChar, cChar, &aMetric, mbVertical );
-        if( aMetric.width == -1 && aMetric.height == -1 )
-            rArgs.NeedFallback( nCharPos, bRightToLeft );
-
-        // apply pair kerning to prev glyph if requested
-        if( SAL_LAYOUT_KERNING_PAIRS & rArgs.mnFlags )
-        {
-            // TODO: get kerning value from printer
-            int nKern = 0; //GetGlyphKernValue( nOldGlyphId, nGlyphIndex );
-            nGlyphWidth += nKern;
-            aPrevItem.mnNewWidth = nGlyphWidth;
-        }
-        
-        // finish previous glyph
-        if( nOldGlyphId >= 0 )
-            AppendGlyph( aPrevItem );
-        nOldGlyphId = nGlyphIndex;
-        aNewPos.X() += nGlyphWidth;
-
-        // prepare GlyphItem for appending it in next round
-        nUnitsPerPixel = mrPrinterGfx.GetCharWidth( cChar, cChar, &nGlyphWidth );
-        int nGlyphFlags = bRightToLeft ? GlyphItem::IS_RTL_GLYPH : 0;
-        nGlyphIndex |= GF_ISCHAR;
-        aPrevItem = GlyphItem( nCharPos, nGlyphIndex, aNewPos, nGlyphFlags, nGlyphWidth );
-    }
-
-    // append last glyph item if any
-    if( nOldGlyphId >= 0 )
-        AppendGlyph( aPrevItem );
-
-    SetOrientation( mrPrinterGfx.GetFontAngle() );
-    SetUnitsPerPixel( nUnitsPerPixel );
-    return (nOldGlyphId >= 0);
-}
-
-class PspServerFontLayout : public ServerFontLayout
-{
-public:
-    PspServerFontLayout( ::psp::PrinterGfx&, ServerFont& rFont );
-
-    virtual void        InitFont() const;
-private:
-    ::psp::PrinterGfx&  mrPrinterGfx;
-    int                 mnFontID;
-    int                 mnFontHeight;
-    int                 mnFontWidth;
-    bool                mbVertical;
-};
-
-PspServerFontLayout::PspServerFontLayout( ::psp::PrinterGfx& rGfx, ServerFont& rFont )
-        :   ServerFontLayout( rFont ),
-            mrPrinterGfx( rGfx )
-{
-    mnFontID     = mrPrinterGfx.GetFontID();
-    mnFontHeight = mrPrinterGfx.GetFontHeight();
-    mnFontWidth  = mrPrinterGfx.GetFontWidth();
-    mbVertical   = mrPrinterGfx.GetFontVertical();
-}
-
-void PspServerFontLayout::InitFont() const
-{
-    mrPrinterGfx.SetFont( mnFontID, mnFontHeight, mnFontWidth,
-        mnOrientation, mbVertical );
-}
-
-//--------------------------------------------------------------------------
-
-void DrawPrinterLayout( const SalLayout& rLayout, ::psp::PrinterGfx& rGfx )
-{
-    const int nMaxGlyphs = 200;
-    long        aGlyphAry[ nMaxGlyphs ];
-    long        aWidthAry[ nMaxGlyphs ];
-    sal_Int32   aIdxAry  [ nMaxGlyphs ];
-    sal_Unicode aUnicodes[ nMaxGlyphs ];
-    Point aPos;
-    long nUnitsPerPixel = rLayout.GetUnitsPerPixel();
-    for( int nStart = 0;; )
-    {
-        int nGlyphCount = rLayout.GetNextGlyphs( nMaxGlyphs, aGlyphAry, aPos, nStart, aWidthAry );
-        if( !nGlyphCount )
-            break;
-
-        long nXOffset = 0;
-        for( int i = 0; i < nGlyphCount; ++i )
-        {
-            nXOffset += aWidthAry[ i ];
-            aIdxAry[ i ] = nXOffset / nUnitsPerPixel;
-            long nGlyphIdx = aGlyphAry[i] & (GF_IDXMASK | GF_ROTMASK);
-            aUnicodes[i] = (aGlyphAry[i] & GF_ISCHAR) ? nGlyphIdx : 0;
-            aGlyphAry[i] = nGlyphIdx;
-        }
-
-        rGfx.DrawGlyphs( aPos, (unsigned long*)aGlyphAry, aUnicodes, nGlyphCount, aIdxAry );
-    }
-}
-
-//--------------------------------------------------------------------------
-
-void PspFontLayout::InitFont() const
-{
-    mrPrinterGfx.SetFont( mnFontID, mnFontHeight, mnFontWidth,
-        mnOrientation, mbVertical );
-}
-
-//--------------------------------------------------------------------------
-
-void PspFontLayout::DrawText( SalGraphics& ) const
+static Point
+RotatedPoint( Point &rOrigin, int nDx, int nAngle )
 {
-    DrawPrinterLayout( *this, mrPrinterGfx );
+    Point   aPos( rOrigin.X() + nDx, rOrigin.Y() );
+    Polygon aPolygon(1);
+    aPolygon.SetPoint( aPos, 0 );
+    aPolygon.Rotate( rOrigin, nAngle );
+    return aPolygon.GetPoint( 0 );
 }
 
-#endif // _USE_PRINT_EXTENSION_
-
 //--------------------------------------------------------------------------
 
-void SalGraphicsData::DispatchServerFontString( const ServerFontLayout& rLayout )
+void X11SalGraphics::DrawServerFontLayout( const ServerFontLayout& rLayout )
 {
-    if( m_pPrinterGfx != NULL )
-    {
-        // print complex text
-        DrawPrinterLayout( rLayout, *m_pPrinterGfx );
-    }
+    // draw complex text
+    ServerFont& rFont = rLayout.GetServerFont();
+    
+    if( aX11GlyphPeer.GetGlyphSet( rFont ) )
+        DrawServerAAFontString( rLayout );
+    else if( aX11GlyphPeer.ForcedAntialiasing( rFont ) )
+        DrawServerAAForcedString( rLayout );
     else
     {
         // draw complex text
@@ -1326,35 +1058,7 @@ void SalGraphicsData::DispatchServerFont
 
 //--------------------------------------------------------------------------
 
-void ServerFontLayout::DrawText( SalGraphics& rSalGraphics ) const
-{
-    rSalGraphics.maGraphicsData.DispatchServerFontString( *this );
-}
-
-//--------------------------------------------------------------------------
-
-static Point
-RotatedPoint( Point &rOrigin, int nDx, int nAngle )
-{
-    Point   aPos( rOrigin.X() + nDx, rOrigin.Y() );
-    Polygon aPolygon(1);
-    aPolygon.SetPoint( aPos, 0 );
-    aPolygon.Rotate( rOrigin, nAngle );
-    return aPolygon.GetPoint( 0 );
-}
-
-//--------------------------------------------------------------------------
-
-void SalGraphicsData::DrawServerFontString( const ServerFontLayout& rLayout )
-{
-    DispatchServerFontString( rLayout );
-}
-
-#endif // USE_BUILTIN_RASTERIZER
-
-//--------------------------------------------------------------------------
-
-void SalGraphicsData::DrawStringUCS2MB( ExtendedFontStruct& rFont,
+void X11SalGraphics::DrawStringUCS2MB( ExtendedFontStruct& rFont,
     const Point& rPoint, const sal_Unicode* pStr, int nLength )
 {
     Display* pDisplay   = GetXDisplay();
@@ -1383,8 +1087,9 @@ void SalGraphicsData::DrawStringUCS2MB( 
     {
         XTextItem16 *pTextItem = (XTextItem16*)alloca( nLength * sizeof(XTextItem16) );
         XChar2b     *pMBChar   = (XChar2b*)pStr;
+        int nItem = 0;
 
-        for( int nChar = 0, nItem = 0; nChar < nLength; ++nChar )
+        for( int nChar = 0; nChar < nLength; ++nChar )
         {
             rtl_TextEncoding  nEnc;
             XFontStruct* pFontStruct = rFont.GetFontStruct( pStr[nChar], &nEnc );
@@ -1406,15 +1111,13 @@ void SalGraphicsData::DrawStringUCS2MB( 
 
 //--------------------------------------------------------------------------
 
-ULONG SalGraphicsData::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
+ULONG X11SalGraphics::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
 
 {
     ULONG nPairs = 0;
-#ifdef USE_BUILTIN_RASTERIZER
     if( mpServerFont[0] )
         nPairs = mpServerFont[0]->GetFontCodeRanges( pCodePairs );
     else
-#endif //USE_BUILTIN_RASTERIZER
     if( mXFont[0] )
         nPairs = mXFont[0]->GetFontCodeRanges( pCodePairs );
     return nPairs;
@@ -1449,204 +1152,32 @@ CheckNoNegativeCoordinateWorkaround()
 //
 // ----------------------------------------------------------------------------
 
-USHORT SalGraphics::SetFont( ImplFontSelectData *pEntry, int nFallbackLevel )
+USHORT X11SalGraphics::SetFont( ImplFontSelectData *pEntry, int nFallbackLevel )
 {
-#ifndef _USE_PRINT_EXTENSION_
-    if( (maGraphicsData.m_pPrinterGfx != NULL) )
-    {
-        sal_Bool bVertical = pEntry->mbVertical;
-        sal_Int32 nID = pEntry->mpFontData ? (sal_Int32)pEntry->mpFontData->mpSysData : 0;
-
-        // also set the serverside font for layouting
-        maGraphicsData.SetFont( pEntry, nFallbackLevel );
-
-        // set the printer and the printer fallback font
-        return maGraphicsData.m_pPrinterGfx->SetFont(
-                                                    nID,
-                                                    pEntry->mnHeight,
-                                                    pEntry->mnWidth,
-                                                    pEntry->mnOrientation,
-                                                    pEntry->mbVertical
-                                                );
-    }
-    else
-#endif
-    {
-        USHORT nRetVal = 0;
-        if( !maGraphicsData.SetFont( pEntry, nFallbackLevel ) )
-            nRetVal |= SAL_SETFONT_BADFONT;
-        if( _IsPrinter() || (maGraphicsData.mpServerFont[ nFallbackLevel ] != NULL) )
-            nRetVal |= SAL_SETFONT_USEDRAWTEXTARRAY;
-        return nRetVal;
-    }
-}
-
-// ----------------------------------------------------------------------------
-
-void SalGraphics::RemovingFont( ImplFontData* pFontData )
-{
-    // ImplFontData gets removed => notify all caches
-    GlyphCache::GetInstance().RemoveFont( pFontData );
+    USHORT nRetVal = 0;
+    if( !setFont( pEntry, nFallbackLevel ) )
+        nRetVal |= SAL_SETFONT_BADFONT;
+    if( bPrinter_ || (mpServerFont[ nFallbackLevel ] != NULL) )
+        nRetVal |= SAL_SETFONT_USEDRAWTEXTARRAY;
+    return nRetVal;
 }
 
 // ----------------------------------------------------------------------------
 
 void
-SalGraphics::SetTextColor( SalColor nSalColor )
+X11SalGraphics::SetTextColor( SalColor nSalColor )
 {
-#ifndef _USE_PRINT_EXTENSION_
-    if (maGraphicsData.m_pPrinterGfx != NULL)
-    {
-        psp::PrinterColor aColor (SALCOLOR_RED   (nSalColor),
-                                  SALCOLOR_GREEN (nSalColor),
-                                  SALCOLOR_BLUE  (nSalColor));
-        maGraphicsData.m_pPrinterGfx->SetTextColor (aColor);
-    }
-    else
-    {
-#endif
-
-    if( _GetTextColor()	!= nSalColor )
+    if( nTextColor_	!= nSalColor )
     {
-        _GetTextColor()     = nSalColor;
-        _GetTextPixel()     = _GetPixel( nSalColor );
-        _IsFontGC()         = FALSE;
-    }
-
-#ifndef _USE_PRINT_EXTENSION_
+        nTextColor_     = nSalColor;
+        nTextPixel_     = GetPixel( nSalColor );
+        bFontGC_         = FALSE;
     }
-#endif
 }
 
 // ----------------------------------------------------------------------------
 
-#ifndef _USE_PRINT_EXTENSION_
-
-static FontWidth
-ToFontWidth (psp::width::type eWidth)
-{
-	switch (eWidth)
-	{
-		case psp::width::UltraCondensed: return WIDTH_ULTRA_CONDENSED;
-		case psp::width::ExtraCondensed: return WIDTH_EXTRA_CONDENSED;
-		case psp::width::Condensed:		 return WIDTH_CONDENSED;
-		case psp::width::SemiCondensed:	 return WIDTH_SEMI_CONDENSED;
-		case psp::width::Normal:		 return WIDTH_NORMAL;
-		case psp::width::SemiExpanded:	 return WIDTH_SEMI_EXPANDED;
-		case psp::width::Expanded:		 return WIDTH_EXPANDED;
-		case psp::width::ExtraExpanded:	 return WIDTH_EXTRA_EXPANDED;
-		case psp::width::UltraExpanded:	 return WIDTH_ULTRA_EXPANDED;
-	}
-	return WIDTH_DONTKNOW;
-}
-
-static FontWeight
-ToFontWeight (psp::weight::type eWeight)
-{
-	switch (eWeight)
-	{
-		case psp::weight::Thin:		  return WEIGHT_THIN;
-		case psp::weight::UltraLight: return WEIGHT_ULTRALIGHT;
-		case psp::weight::Light:	  return WEIGHT_LIGHT;
-		case psp::weight::SemiLight:  return WEIGHT_SEMILIGHT;
-		case psp::weight::Normal:	  return WEIGHT_NORMAL;
-		case psp::weight::Medium:	  return WEIGHT_MEDIUM;
-		case psp::weight::SemiBold:	  return WEIGHT_SEMIBOLD;
-		case psp::weight::Bold:		  return WEIGHT_BOLD;
-		case psp::weight::UltraBold:  return WEIGHT_ULTRABOLD;
-		case psp::weight::Black:	  return WEIGHT_BLACK;
-	}
-	return WEIGHT_DONTKNOW;
-}
-
-static FontPitch
-ToFontPitch (psp::pitch::type ePitch)
-{
-	switch (ePitch)
-	{
-		case psp::pitch::Fixed:		return PITCH_FIXED;
-		case psp::pitch::Variable:	return PITCH_VARIABLE;
-	}
-	return PITCH_DONTKNOW;
-}
-
-static FontItalic
-ToFontItalic (psp::italic::type eItalic)
-{
-	switch (eItalic)
-	{
-		case psp::italic::Upright:	return ITALIC_NONE;
-		case psp::italic::Oblique:	return ITALIC_OBLIQUE;
-		case psp::italic::Italic:	return ITALIC_NORMAL;
-	}
-	return ITALIC_DONTKNOW;
-}
-
-static FontFamily
-ToFontFamily (psp::family::type eFamily)
-{
-	switch (eFamily)
-	{
-		case psp::family::Decorative: return FAMILY_DECORATIVE;
-		case psp::family::Modern:	  return FAMILY_MODERN;
-		case psp::family::Roman:	  return FAMILY_ROMAN;
-		case psp::family::Script:	  return FAMILY_SCRIPT;
-		case psp::family::Swiss:	  return FAMILY_SWISS;
-		case psp::family::System:	  return FAMILY_SYSTEM;
-	}
-	return FAMILY_DONTKNOW;
-}
-
-static void SetImplFontData( const psp::FastPrintFontInfo& aInfo, ImplFontData& rData )
-{
-	rData.meFamily     	= ToFontFamily (aInfo.m_eFamilyStyle);
-	rData.meWeight     	= ToFontWeight (aInfo.m_eWeight);
-
-	rData.meItalic     	= ToFontItalic (aInfo.m_eItalic);
-	rData.meWidthType  	= ToFontWidth  (aInfo.m_eWidth);
-	rData.mePitch	   	= ToFontPitch  (aInfo.m_ePitch);
-	rData.meCharSet    	= aInfo.m_aEncoding;
-	rData.maName		= aInfo.m_aFamilyName;
-	// rData.meScript		= SCRIPT_DONTKNOW;
-	/*rData.maStyleName	= XXX */
-
-	rData.mnWidth		= 0;
-	rData.mnHeight		= 0;
-	rData.mbOrientation	= TRUE;
-	rData.mnQuality		= (aInfo.m_eType == psp::fonttype::Builtin ? 1024 : 0);
-	rData.mnVerticalOrientation= 0;
-	rData.meType		= TYPE_SCALABLE;
-	rData.mbDevice		= (aInfo.m_eType == psp::fonttype::Builtin);
-    String aMapNames;
-    for( ::std::list< OUString >::const_iterator it = aInfo.m_aAliases.begin(); it != aInfo.m_aAliases.end(); ++it )
-    {
-        if( it != aInfo.m_aAliases.begin() )
-            aMapNames.Append(';');
-        aMapNames.Append( String( *it ) );
-    }
-    rData.maMapNames	= aMapNames;
-    switch( aInfo.m_eType )
-    {
-        case psp::fonttype::TrueType:
-            rData.mbSubsettable	= TRUE;
-            rData.mbEmbeddable	= FALSE;
-            break;
-        case psp::fonttype::Type1:
-            rData.mbSubsettable	= FALSE;
-            rData.mbEmbeddable	= TRUE;
-            break;
-        default:
-            rData.mbSubsettable = FALSE;
-            rData.mbEmbeddable	= FALSE;
-            break;
-    }
-}
-
-#endif
-
-// ----------------------------------------------------------------------------
-
-ImplFontData* SalGraphics::AddTempDevFont( const String& rFileURL, const String& rFontName )
+ImplFontData* X11SalGraphics::AddTempDevFont( const String& rFileURL, const String& rFontName )
 {
     // inform font manager
     rtl::OUString aUSystemPath;
@@ -1662,7 +1193,7 @@ ImplFontData* SalGraphics::AddTempDevFon
     psp::FastPrintFontInfo aInfo;
     rMgr.getFontFastInfo( nFontId, aInfo );
     ImplFontData* pFontData = new ImplFontData;
-    SetImplFontData( aInfo, *pFontData );
+    PspGraphics::SetImplFontData( aInfo, *pFontData );
     pFontData->maName = rFontName;
     pFontData->mnQuality += 5800;
 
@@ -1676,148 +1207,83 @@ ImplFontData* SalGraphics::AddTempDevFon
 
 // ----------------------------------------------------------------------------
 
-void SalGraphics::GetDevFontList( ImplDevFontList *pList )
+void X11SalGraphics::GetDevFontList( ImplDevFontList *pList )
 {
-#ifndef _USE_PRINT_EXTENSION_
-    if (maGraphicsData.m_pJobData != NULL)
+    XlfdStorage* pFonts = GetDisplay()->GetXlfdList();
+    
+    for ( int nIdx = 0; nIdx < pFonts->GetCount(); nIdx++ )
+    {
+        ImplFontData *pFontData = new ImplFontData;
+        pFonts->Get(nIdx)->ToImplFontData( pFontData );
+        if( pFontData->maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
+            pFontData->maName = pFontData->maName.Copy( 4 );
+        pFontData->mbSubsettable    = FALSE;
+        pFontData->mbEmbeddable     = FALSE;
+        pList->Add( pFontData );
+    }
+    
+    aX11GlyphPeer.SetDisplay( GetXDisplay(),
+                              GetDisplay()->GetVisual()->GetVisual() );
+#ifdef MACOSX
+    GlyphCache::EnsureInstance( aX11GlyphPeer, true );
+#else
+    GlyphCache::EnsureInstance( aX11GlyphPeer, false );
+#endif
+    GlyphCache& rGC = GlyphCache::GetInstance();
+    
+    const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
+    ::std::list< psp::fontID > aList;
+    ::std::list< psp::fontID >::iterator it;
+    rMgr.getFontList( aList );
+    unicodeKernMap aKernTab;
+    for( it = aList.begin(); it != aList.end(); ++it )
     {
-        const char* pLangBoost = NULL;
-        const LanguageType aLang = Application::GetSettings().GetUILanguage();
-        switch( aLang )
-        {
-            case LANGUAGE_JAPANESE:
-                pLangBoost = "jan";    // japanese is default
-                break;
-            case LANGUAGE_CHINESE:
-            case LANGUAGE_CHINESE_SIMPLIFIED:
-            case LANGUAGE_CHINESE_SINGAPORE:
-                pLangBoost = "zhs";
-                break;
-            case LANGUAGE_CHINESE_TRADITIONAL:
-            case LANGUAGE_CHINESE_HONGKONG:
-            case LANGUAGE_CHINESE_MACAU:
-                pLangBoost = "zht";
-                break;
-            case LANGUAGE_KOREAN:
-            case LANGUAGE_KOREAN_JOHAB:
-                pLangBoost = "kor";
-                break;
-        }
-
-        ::std::list< psp::fontID > aList;
-        const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-        rMgr.getFontList( aList, maGraphicsData.m_pJobData->m_pParser );
-
-        ::std::list< psp::fontID >::iterator it;
-        for (it = aList.begin(); it != aList.end(); ++it)
+        psp::FastPrintFontInfo aInfo;
+        if( rMgr.getFontFastInfo( *it, aInfo ) )
         {
-            psp::FastPrintFontInfo aInfo;
-            if (rMgr.getFontFastInfo (*it, aInfo))
+            if( aInfo.m_eType == psp::fonttype::Builtin )
+                continue;
+            ImplFontData aFontData;
+            PspGraphics::SetImplFontData( aInfo, aFontData );
+            // prefer builtin_rasterizer fonts
+            aFontData.mnQuality += 4096;
+            // prefer truetype fonts
+            if( aInfo.m_eType == psp::fonttype::TrueType )
+                aFontData.mnQuality += 1000;
+            int nFaceNum = rMgr.getFontFaceNumber( aInfo.m_nID );
+            if( aFontData.maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
+                aFontData.maName = aFontData.maName.Copy( 4 );
+            if( nFaceNum < 0 )
+                nFaceNum = 0;
+
+            
+            const unicodeKernMap* pKernTab = NULL;
+            if( aInfo.m_eType == psp::fonttype::Type1 )
             {
-                ImplFontData *pFontData = new ImplFontData;
-                SetImplFontData( aInfo, *pFontData );
-                pFontData->mpSysData = (void*)*it;
-                if( pFontData->maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
-                    pFontData->maName = pFontData->maName.Copy( 4 );
-                if( aInfo.m_eType == psp::fonttype::TrueType )
+                const std::list< psp::KernPair >& rKernPairs = rMgr.getKernPairs( *it );
+                if( rKernPairs.size() )
                 {
-                    // prefer truetype fonts
-                    pFontData->mnQuality += 10;
-                    // asian type 1 fonts are not known
-                    ByteString aFileName( rMgr.getFontFileSysPath( *it ) );
-                    int nPos = aFileName.SearchBackward( '_' );
-                    if( nPos == STRING_NOTFOUND || aFileName.GetChar( nPos+1 ) == '.' )
-                        pFontData->mnQuality += 5;
-                    else
-                    {
-                        if( pLangBoost && aFileName.Copy( nPos+1, 3 ).EqualsIgnoreCaseAscii( pLangBoost ) )
-                            pFontData->mnQuality += 10;
-                    }
+                    aKernTab.clear();
+                    for( std::list< psp::KernPair >::const_iterator it = rKernPairs.begin();
+                         it != rKernPairs.end(); ++it )
+                        aKernTab[ it->first ][ it->second ] = it->kern_x;
+                    pKernTab = & aKernTab;
                 }
-                pList->Add( pFontData );
             }
+            
+            // handling of alias names is done by GlyphCache::FetchFontList
+            rGC.AddFontFile( rMgr.getFontFileSysPath( aInfo.m_nID ), nFaceNum,
+                             aInfo.m_nID, &aFontData, pKernTab );
         }
     }
-    else
-#endif
-    {
-        XlfdStorage* pFonts = _GetDisplay()->GetXlfdList();
 
-        for ( int nIdx = 0; nIdx < pFonts->GetCount(); nIdx++ )
-        {
-            ImplFontData *pFontData = new ImplFontData;
-#ifdef MACOSX
-            // don't use bitmap X fonts on OS X
-            if ( pFonts->Get(nIdx)->GetFontType() != TYPE_RASTER )
-#endif
-            {
-                pFonts->Get(nIdx)->ToImplFontData( pFontData );
-                if( pFontData->maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
-                    pFontData->maName = pFontData->maName.Copy( 4 );
-                pFontData->mbSubsettable    = FALSE;
-                pFontData->mbEmbeddable     = FALSE;
-                pList->Add( pFontData );
-            }
-        }
-
-#ifdef USE_BUILTIN_RASTERIZER
-        aX11GlyphPeer.SetDisplay( maGraphicsData.GetXDisplay(),
-            maGraphicsData.GetDisplay()->GetVisual()->GetVisual() );
-#ifdef MACOSX
-        GlyphCache::EnsureInstance( aX11GlyphPeer, true );
-#else
-        GlyphCache::EnsureInstance( aX11GlyphPeer, false );
-#endif
-        GlyphCache& rGC = GlyphCache::GetInstance();
-
-        const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-        ::std::list< psp::fontID > aList;
-        ::std::list< psp::fontID >::iterator it;
-        rMgr.getFontList( aList );
-        for( it = aList.begin(); it != aList.end(); ++it )
-        {
-            psp::FastPrintFontInfo aInfo;
-            if( rMgr.getFontFastInfo( *it, aInfo ) )
-            {
-                if( aInfo.m_eType == psp::fonttype::Builtin )
-                    continue;
-                ImplFontData aFontData;
-                SetImplFontData( aInfo, aFontData );
-                // prefer builtin_rasterizer fonts
-                aFontData.mnQuality += 4096;
-                // prefer truetype fonts
-                if( aInfo.m_eType == psp::fonttype::TrueType )
-                    aFontData.mnQuality += 1000;
-                int nFaceNum = rMgr.getFontFaceNumber( aInfo.m_nID );
-                if( aFontData.maName.CompareIgnoreCaseToAscii( "itc ", 4 ) == COMPARE_EQUAL )
-                    aFontData.maName = aFontData.maName.Copy( 4 );
-                if( nFaceNum < 0 )
-                    nFaceNum = 0;
-                rGC.AddFontFile( rMgr.getFontFileSysPath( aInfo.m_nID ), nFaceNum,
-                    aInfo.m_nID, &aFontData );
-            }
-        }
-
-        rGC.FetchFontList( pList );
-#endif // USE_BUILTIN_RASTERIZER
-    }
+    rGC.FetchFontList( pList );
 }
 
 // ----------------------------------------------------------------------------
 
-void SalGraphics::GetDevFontSubstList( OutputDevice* pOutDev )
+void X11SalGraphics::GetDevFontSubstList( OutputDevice* pOutDev )
 {
-#ifndef _USE_PRINT_EXTENSION_
-    if( maGraphicsData.m_pPrinterGfx != NULL )
-    {
-        const psp::PrinterInfo& rInfo = psp::PrinterInfoManager::get().getPrinterInfo( maGraphicsData.m_pJobData->m_aPrinterName );
-        if( rInfo.m_bPerformFontSubstitution )
-        {
-            for( std::hash_map< rtl::OUString, rtl::OUString, rtl::OUStringHash >::const_iterator it = rInfo.m_aFontSubstitutes.begin(); it != rInfo.m_aFontSubstitutes.end(); ++it )
-                pOutDev->ImplAddDevFontSubstitute( it->first, it->second, FONT_SUBSTITUTE_ALWAYS );
-        }
-    }
-#endif
 }
 
 // ----------------------------------------------------------------------------
@@ -1831,136 +1297,53 @@ sal_DivideNeg( long n1, long n2 )
 // ----------------------------------------------------------------------------
 
 void
-SalGraphics::GetFontMetric( ImplFontMetricData *pMetric )
+X11SalGraphics::GetFontMetric( ImplFontMetricData *pMetric )
 {
-#ifndef _USE_PRINT_EXTENSION_
-	if (maGraphicsData.m_pPrinterGfx != NULL)
-	{
-		const psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-		psp::PrintFontInfo aInfo;
-
-		if (rMgr.getFontInfo (maGraphicsData.m_pPrinterGfx->GetFontID(), aInfo))
-		{
-			sal_Int32 nTextHeight	= maGraphicsData.m_pPrinterGfx->GetFontHeight();
-			sal_Int32 nTextWidth	= maGraphicsData.m_pPrinterGfx->GetFontWidth();
-			if( ! nTextWidth )
-				nTextWidth = nTextHeight;
-
-			pMetric->mnOrientation 	= maGraphicsData.m_pPrinterGfx->GetFontAngle();
-			pMetric->mnSlant		= 0;
-			pMetric->mbDevice		= aInfo.m_eType == psp::fonttype::Builtin ? sal_True : sal_False;
-
-			pMetric->meCharSet		= aInfo.m_aEncoding;
-
-			pMetric->meFamily		= ToFontFamily (aInfo.m_eFamilyStyle);
-			pMetric->meWeight		= ToFontWeight (aInfo.m_eWeight);
-			pMetric->mePitch		= ToFontPitch  (aInfo.m_ePitch);
-			pMetric->meItalic		= ToFontItalic (aInfo.m_eItalic);
-			pMetric->meType			= TYPE_SCALABLE;
-
-			pMetric->mnFirstChar	=   0;
-			pMetric->mnLastChar		= 255;
-
-			pMetric->mnWidth		= nTextWidth;
-			pMetric->mnAscent		= ( aInfo.m_nAscend * nTextHeight + 500 ) / 1000;
-			pMetric->mnDescent		= ( aInfo.m_nDescend * nTextHeight + 500 ) / 1000;
-			pMetric->mnLeading		= ( aInfo.m_nLeading * nTextHeight + 500 ) / 1000;
-		}
-        return;
-    }
-#endif
-
-    if( maGraphicsData.mpServerFont[0] != NULL )
+    if( mpServerFont[0] != NULL )
     {
         long rDummyFactor;
-        maGraphicsData.mpServerFont[0]->FetchFontMetric( *pMetric, rDummyFactor );
+        mpServerFont[0]->FetchFontMetric( *pMetric, rDummyFactor );
         return;
     }
 
-    ExtendedFontStruct* pFont = maGraphicsData.mXFont[0];
+    ExtendedFontStruct* pFont = mXFont[0];
     if( pFont != NULL )
     {
         pFont->ToImplFontMetricData( pMetric );
-        if ( maGraphicsData.bFontVertical_ )
+        if ( bFontVertical_ )
             pMetric->mnOrientation = 0;
     }
 }
 
 // ---------------------------------------------------------------------------
 
-static long
-InitializeWidthArray( long *pWidthArray, sal_Size nItems, int nValue = 0  )
-{
-    const long nPrecision = 1;
-
-    for ( int i = 0; i < nItems; i++, pWidthArray++ )
-        *pWidthArray = nValue;
-
-    return nPrecision;
-}
-
-// ---------------------------------------------------------------------------
-
-extern unsigned char TranslateCharName( char* );
-
 ULONG
-SalGraphics::GetKernPairs( ULONG nPairs, ImplKernPairData *pKernPairs )
+X11SalGraphics::GetKernPairs( ULONG nPairs, ImplKernPairData *pKernPairs )
 {
-    if( ! _IsPrinter() )
+    if( ! bPrinter_ )
     {
-        if( maGraphicsData.mpServerFont[0] != NULL )
+        if( mpServerFont[0] != NULL )
         {
             ImplKernPairData* pTmpKernPairs;
-            ULONG nGotPairs = maGraphicsData.mpServerFont[0]->GetKernPairs( &pTmpKernPairs );
+            ULONG nGotPairs = mpServerFont[0]->GetKernPairs( &pTmpKernPairs );
             for( int i = 0; i < nPairs && i < nGotPairs; ++i )
                 pKernPairs[ i ] = pTmpKernPairs[ i ];
             delete[] pTmpKernPairs;
             return nGotPairs;
         }
     }
-    else
-    {
-#ifndef _USE_PRINT_EXTENSION_
-		const ::std::list< ::psp::KernPair >& rPairs( maGraphicsData.m_pPrinterGfx->getKernPairs() );
-		ULONG nHavePairs = rPairs.size();
-		if( pKernPairs && nPairs )
-		{
-			::std::list< ::psp::KernPair >::const_iterator it;
-			int i;
-			int nTextScale = maGraphicsData.m_pPrinterGfx->GetFontWidth();
-			if( ! nTextScale )
-				nTextScale = maGraphicsData.m_pPrinterGfx->GetFontHeight();
-			for( i = 0, it = rPairs.begin(); i < nPairs && i < nHavePairs; i++, ++it )
-			{
-				pKernPairs[i].mnChar1	= it->first;
-				pKernPairs[i].mnChar2	= it->second;
-				pKernPairs[i].mnKern	= it->kern_x * nTextScale / 1000;
-			}
-
-		}
-		return nHavePairs;
-#endif
-	}
-
 	return 0;
 }
 
 // ---------------------------------------------------------------------------
 
-ULONG SalGraphics::GetFontCodeRanges( sal_uInt32* pCodePairs ) const
-{
-    return maGraphicsData.GetFontCodeRanges( pCodePairs );
-}
-
-// ---------------------------------------------------------------------------
-
-BOOL SalGraphics::GetGlyphBoundRect( long nGlyphIndex, Rectangle& rRect, const OutputDevice* )
+BOOL X11SalGraphics::GetGlyphBoundRect( long nGlyphIndex, Rectangle& rRect )
 {
     int nLevel = nGlyphIndex >> GF_FONTSHIFT;
     if( nLevel >= MAX_FALLBACK )
         return FALSE;
 
-    ServerFont* pSF = maGraphicsData.mpServerFont[ nLevel ];
+    ServerFont* pSF = mpServerFont[ nLevel ];
     if( !pSF )
         return FALSE;
 
@@ -1972,13 +1355,13 @@ BOOL SalGraphics::GetGlyphBoundRect( lon
 
 // ---------------------------------------------------------------------------
 
-BOOL SalGraphics::GetGlyphOutline( long nGlyphIndex, PolyPolygon& rPolyPoly, const OutputDevice* )
+BOOL X11SalGraphics::GetGlyphOutline( long nGlyphIndex, PolyPolygon& rPolyPoly )
 {
     int nLevel = nGlyphIndex >> GF_FONTSHIFT;
     if( nLevel >= MAX_FALLBACK )
         return FALSE;
 
-    ServerFont* pSF = maGraphicsData.mpServerFont[ nLevel ];
+    ServerFont* pSF = mpServerFont[ nLevel ];
     if( !pSF )
         return FALSE;
 
@@ -1991,29 +1374,13 @@ BOOL SalGraphics::GetGlyphOutline( long 
 
 //--------------------------------------------------------------------------
 
-SalLayout* SalGraphicsData::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
+SalLayout* X11SalGraphics::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
 {
-#if !defined(_USE_PRINT_EXTENSION_)
-    // workaround for printers not handling glyph indexing for non-TT fonts
-    if( m_pPrinterGfx != NULL )
-    {
-        int nFontId = m_pPrinterGfx->GetFontID();
-        if( psp::fonttype::TrueType != psp::PrintFontManager::get().getFontType( nFontId ) )
-            rArgs.mnFlags |= SAL_LAYOUT_DISABLE_GLYPH_PROCESSING;
-        else if( nFallbackLevel > 0 )
-            rArgs.mnFlags &= ~SAL_LAYOUT_DISABLE_GLYPH_PROCESSING;
-    }
-#endif // !defined(_USE_PRINT_EXTENSION_)
-
     GenericSalLayout* pLayout = NULL;
 
     if( mpServerFont[ nFallbackLevel ]
     && !(rArgs.mnFlags & SAL_LAYOUT_DISABLE_GLYPH_PROCESSING) )
-        pLayout = m_pPrinterGfx ? new PspServerFontLayout( *m_pPrinterGfx, *mpServerFont[nFallbackLevel] ) : new ServerFontLayout( *mpServerFont[ nFallbackLevel ] );
-#if !defined(_USE_PRINT_EXTENSION_)
-    else if( m_pPrinterGfx != NULL )
-        pLayout = new PspFontLayout( *m_pPrinterGfx );
-#endif // !defined(_USE_PRINT_EXTENSION_)
+        pLayout = new ServerFontLayout( *mpServerFont[ nFallbackLevel ] );
     else if( mXFont[ nFallbackLevel ] )
         pLayout = new X11FontLayout( *mXFont[ nFallbackLevel ] );
     else
@@ -2024,18 +1391,10 @@ SalLayout* SalGraphicsData::GetTextLayou
 
 //--------------------------------------------------------------------------
 
-SalLayout* SalGraphics::GetTextLayout( ImplLayoutArgs& rArgs, int nFallbackLevel )
-{
-    SalLayout* pSalLayout = maGraphicsData.GetTextLayout( rArgs, nFallbackLevel );
-    return pSalLayout;
-}
-
-//--------------------------------------------------------------------------
-
-BOOL SalGraphics::CreateFontSubset(
+BOOL X11SalGraphics::CreateFontSubset(
                                    const rtl::OUString& rToFile,
                                    ImplFontData* pFont,
-                                   long* pGlyphIDs,
+                                   sal_Int32* pGlyphIDs,
                                    sal_uInt8* pEncoding,
                                    sal_Int32* pWidths,
                                    int nGlyphs,
@@ -2049,41 +1408,7 @@ BOOL SalGraphics::CreateFontSubset(
     // which this method was created). The correct way would
     // be to have the GlyphCache search for the ImplFontData pFont
     psp::fontID aFont = (psp::fontID)pFont->mpSysData;
-    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-
-    psp::PrintFontInfo aFontInfo;
-
-    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
-        return FALSE;
-
-    // fill in font info
-    switch( aFontInfo.m_eType )
-    {
-        case psp::fonttype::TrueType: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TRUETYPE;break;
-        case psp::fonttype::Type1: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TYPE1;break;
-        default:
-            return FALSE;
-    }
-    rInfo.m_nAscent     = aFontInfo.m_nAscend;
-    rInfo.m_nDescent    = aFontInfo.m_nDescend;
-    rInfo.m_aPSName     = rMgr.getPSName( aFont );
-
-    int xMin, yMin, xMax, yMax;
-    rMgr.getFontBoundingBox( aFont, xMin, yMin, xMax, yMax );
-
-    if( ! rMgr.createFontSubset( aFont,
-                                 rToFile,
-                                 pGlyphIDs,
-                                 pEncoding,
-                                 pWidths,
-                                 nGlyphs
-                                 ) )
-        return FALSE;
-
-    rInfo.m_aFontBBox	= Rectangle( Point( xMin, yMin ), Size( xMax-xMin, yMax-yMin ) );
-    rInfo.m_nCapHeight	= yMax; // Well ...
-
-    return TRUE;
+    return PspGraphics::DoCreateFontSubset( rToFile, aFont, pGlyphIDs, pEncoding, pWidths, nGlyphs, rInfo );
 #else
     return FALSE;
 #endif
@@ -2091,7 +1416,7 @@ BOOL SalGraphics::CreateFontSubset(
 
 //--------------------------------------------------------------------------
 
-const void* SalGraphics::GetEmbedFontData( ImplFontData* pFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
+const void* X11SalGraphics::GetEmbedFontData( ImplFontData* pFont, const sal_Unicode* pUnicodes, sal_Int32* pWidths, FontSubsetInfo& rInfo, long* pDataLen )
 {
 #ifndef _USE_PRINT_EXTENSION_
     // in this context the sysdata member of pFont should
@@ -2100,61 +1425,7 @@ const void* SalGraphics::GetEmbedFontDat
     // which this method was created). The correct way would
     // be to have the GlyphCache search for the ImplFontData pFont
     psp::fontID aFont = (psp::fontID)pFont->mpSysData;
-    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-
-    psp::PrintFontInfo aFontInfo;
-    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
-        return NULL;
-
-    // fill in font info
-    switch( aFontInfo.m_eType )
-    {
-        case psp::fonttype::TrueType: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TRUETYPE;break;
-        case psp::fonttype::Type1: rInfo.m_nFontType = SAL_FONTSUBSETINFO_TYPE_TYPE1;break;
-        default:
-            return NULL;
-    }
-    rInfo.m_nAscent		= aFontInfo.m_nAscend;
-    rInfo.m_nDescent	= aFontInfo.m_nDescend;
-    rInfo.m_aPSName		= rMgr.getPSName( aFont );
-
-    int xMin, yMin, xMax, yMax;
-    rMgr.getFontBoundingBox( aFont, xMin, yMin, xMax, yMax );
-
-    psp::CharacterMetric aMetrics[256];
-    sal_Unicode aUnicodes[256];
-    if( aFontInfo.m_aEncoding == RTL_TEXTENCODING_SYMBOL && aFontInfo.m_eType == psp::fonttype::Type1 )
-    {
-        for( int i = 0; i < 256; i++ )
-            aUnicodes[i] = pUnicodes[i] < 0x0100 ? pUnicodes[i] + 0xf000 : pUnicodes[i];
-        pUnicodes = aUnicodes;
-    }
-    if( ! rMgr.getMetrics( aFont, pUnicodes, 256, aMetrics ) )
-        return NULL;
-
-    OString aSysPath = rMgr.getFontFileSysPath( aFont );
-    struct stat aStat;
-    if( stat( aSysPath.getStr(), &aStat ) )
-        return NULL;
-    int fd = open( aSysPath.getStr(), O_RDONLY );
-    if( fd < 0 )
-        return NULL;
-    void* pFile = mmap( NULL, aStat.st_size, PROT_READ, MAP_SHARED, fd, 0 );
-    close( fd );
-    if( pFile == MAP_FAILED )
-        return NULL;
-
-    *pDataLen = aStat.st_size;
-
-    rInfo.m_aFontBBox	= Rectangle( Point( xMin, yMin ), Size( xMax-xMin, yMax-yMin ) );
-    rInfo.m_nCapHeight	= yMax; // Well ...
-
-    for( int i = 0; i < 256; i++ )
-
-        pWidths[i] = (aMetrics[i].width > 0 ? aMetrics[i].width : 0);
-
-    return pFile;
-
+    return PspGraphics::DoGetEmbedFontData( aFont, pUnicodes, pWidths, rInfo, pDataLen );
 #else
     return NULL;
 #endif
@@ -2162,14 +1433,16 @@ const void* SalGraphics::GetEmbedFontDat
 
 //--------------------------------------------------------------------------
 
-void SalGraphics::FreeEmbedFontData( const void* pData, long nLen )
+void X11SalGraphics::FreeEmbedFontData( const void* pData, long nLen )
 {
-    munmap( (char*)pData, nLen );
+#ifndef _USE_PRINT_EXTENSION_
+    PspGraphics::DoFreeEmbedFontData( pData, nLen );
+#endif
 }
 
 //--------------------------------------------------------------------------
 
-const std::map< sal_Unicode, sal_Int32 >* SalGraphics::GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
+const std::map< sal_Unicode, sal_Int32 >* X11SalGraphics::GetFontEncodingVector( ImplFontData* pFont, const std::map< sal_Unicode, rtl::OString >** pNonEncoded )
 {
 #ifndef _USE_PRINT_EXTENSION_
     // in this context the sysdata member of pFont should
@@ -2178,17 +1451,7 @@ const std::map< sal_Unicode, sal_Int32 >
     // which this method was created). The correct way would
     // be to have the GlyphCache search for the ImplFontData pFont
     psp::fontID aFont = (psp::fontID)pFont->mpSysData;
-    psp::PrintFontManager& rMgr = psp::PrintFontManager::get();
-
-    psp::PrintFontInfo aFontInfo;
-    if( ! rMgr.getFontInfo( aFont, aFontInfo ) )
-    {
-        if( pNonEncoded )
-            *pNonEncoded = NULL;
-        return NULL;
-    }
-
-    return rMgr.getEncodingMap( aFont, pNonEncoded );
+    return PspGraphics::DoGetFontEncodingVector( aFont, pNonEncoded );
 #else
     return NULL;
 #endif
Index: vcl/unx/source/gdi/salnativewidgets-kde.cxx
===================================================================
RCS file: vcl/unx/source/gdi/salnativewidgets-kde.cxx
diff -N vcl/unx/source/gdi/salnativewidgets-kde.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/source/gdi/salnativewidgets-kde.cxx	10 May 2004 15:59:25 -0000	1.2
@@ -0,0 +1,1633 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): Juergen Keil
+ *                  Jan Holesovsky <kendy@artax.karlin.mff.cuni.cz>
+ *                  Lukas Tinkl <lukas@kde.org>
+ *
+ *
+ ************************************************************************/
+
+#define _SV_SALNATIVEWIDGETS_KDE_CXX
+
+// Hack, but needed because of conflicting types...
+#define Region QtXRegion
+
+#include <qcheckbox.h>
+#include <qcombobox.h>
+#include <qframe.h>
+#include <qlineedit.h>
+#include <qlistview.h>
+#include <qpainter.h>
+#include <qpushbutton.h>
+#include <qradiobutton.h>
+#include <qrangecontrol.h>
+#include <qtabbar.h>
+#include <qtabwidget.h>
+#include <qwidget.h>
+
+#include <kaboutdata.h>
+#include <kapplication.h>
+#include <kcmdlineargs.h>
+#include <kconfig.h>
+#include <kglobal.h>
+#include <kmainwindow.h>
+#include <kmenubar.h>
+#include <kstyle.h>
+
+#undef Region
+
+#include <salunx.h>
+
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
+#endif
+
+#ifndef _SV_SALGDI_HXX
+#include <salgdi.hxx>
+#endif
+
+#ifndef _SV_KDEINT_HXX
+#include <kdeint.hxx>
+#endif
+
+#ifndef _SV_SETTINGS_HXX
+#include <settings.hxx>
+#endif
+
+#include <iostream>
+
+using namespace ::rtl;
+
+/** Cached native widgets.
+ 
+    A class which caches and paints the native widgets.
+*/
+class WidgetPainter
+{
+    protected:
+	/** Cached push button.
+
+	    It is necessary for the QStyle::drawControl(). The buttons are created
+	    on demand and they are still hidden (no QWidget::show() is called).
+	*/
+	QPushButton  *m_pPushButton;
+
+	/** Cached radio button.
+
+	    @see m_pPushButton
+	*/
+	QRadioButton *m_pRadioButton;
+
+	/** Cached check box.
+
+	    @see m_pPushButton
+	*/
+	QCheckBox    *m_pCheckBox;
+
+	/** Cached combo box.
+
+	    @see m_pPushButton
+	*/
+	QComboBox    *m_pComboBox;
+
+	/** Cached editable combo box.
+
+	    Needed, because some styles do not like dynamic changes
+	    (QComboBox::setEditable()).
+
+	    @see m_pPushButton
+	*/
+	QComboBox    *m_pEditableComboBox;
+
+	/** Cached line edit box.
+
+	    @see m_pPushButton
+	*/
+	QLineEdit    *m_pLineEdit;
+
+	/** Cached spin box.
+
+	    @see m_pPushButton
+	*/
+	QSpinWidget  *m_pSpinWidget;
+
+	/** Cached spin box'es line edit.
+
+	    @see m_pPushButton
+	*/
+	QLineEdit    *m_pSpinEdit;
+
+	/** Cached tab.
+
+	    Left, middle, right tab and a tab which is alone.
+
+	    @see m_pPushButton
+	*/
+	QTab         *m_pTabLeft, *m_pTabMiddle, *m_pTabRight, *m_pTabAlone;
+
+	/** Cached tab bar's parent widget.
+
+	    Needed, because the Qt windows style checks for the availability
+	    of tab bar's parent. We cannot use m_pTabWidget, because
+	    TabWidget::setTabBar() and TabWidget::tabBar() methods are
+	    protected.
+
+	    @see m_pPushButton, m_pTabWidget
+	*/
+	QWidget      *m_pTabBarParent;
+
+	/** Cached tab bar widget.
+
+	    @see m_pPushButton
+	*/
+	QTabBar      *m_pTabBar;
+
+	/** Cached tab widget.
+
+	    We need it to draw the tab page. It cannot be used to draw the
+	    tabs themselves, because the drawing has to be tweaked a little
+	    due to not enough information from VCL.
+
+	    @see m_pPushButton, m_pTabBarParent
+	*/
+	QTabWidget   *m_pTabWidget;
+
+	/** Cached list view.
+
+	    @see m_pPushButton
+	*/
+	QListView    *m_pListView;
+
+	/** Cached scroll bar.
+
+	    @see m_pPushButton
+	*/
+	QScrollBar   *m_pScrollBar;
+
+	// TODO other widgets
+
+    public:
+	/** Implicit constructor.
+
+	    It creates an empty WidgetPainter with all the cached widgets initialized
+	    to NULL. The widgets are created on demand and they are still hidden
+	    (no QWidget::show()), because they are needed just as a parameter for
+	    QStyle::drawControl().
+
+	    @see m_pPushButton
+	*/
+	WidgetPainter( void );
+
+	/** Destructor.
+
+	    Destruct all the cached widgets.
+	*/
+	virtual ~WidgetPainter( void );
+
+	/** Paints the specified widget to the X window.
+
+	    Use X calls to bitblt (bit block transfer) the widget qWidget to
+	    the window specified by drawable with the style defined by nStyle.
+
+	    @param qWidget
+	    A pointer to the cached widget.
+
+	    @param nState
+	    The state of the control (focused, on/off, ...)
+
+	    @param aValue
+	    The value (true/false, ...)
+
+	    @param dpy
+	    The display to be used by the X calls.
+
+	    @param drawable
+	    The destination X window.
+
+	    @param gc
+	    The graphics context.
+	*/
+	BOOL drawStyledWidget( QWidget *pWidget,
+		ControlState nState, const ImplControlValue& aValue,
+		Display *dpy, XLIB_Window drawable, GC gc );
+
+	/** 'Get' method for push button.
+
+	    The method returns the cached push button. It is constructed if it
+	    does not exist. It has NULL as a parent and it stays hidden, but it
+	    is necessary for the drawStyledWidget() method.
+
+	    @return valid push button.
+	*/
+	QPushButton  *pushButton( const Region& rControlRegion, BOOL bDefault );
+
+	/** 'Get' method for radio button.
+
+	    @see pushButton()
+	*/
+	QRadioButton *radioButton( const Region& rControlRegion );
+
+	/** 'Get' method for check box.
+
+	    @see pushButton()
+	*/
+	QCheckBox    *checkBox( const Region& rControlRegion );
+
+	/** 'Get' method for combo box.
+
+	    It returns m_pComboBox or m_pEditableComboBox according to
+	    bEditable.
+
+	    @see pushButton(), m_pEditableComboBox
+	*/
+	QComboBox    *comboBox( const Region& rControlRegion, BOOL bEditable );
+
+	/** 'Get' method for line edit box.
+
+	    @see pushButton()
+	*/
+	QLineEdit    *lineEdit( const Region& rControlRegion );
+
+	/** 'Get' method for spin box.
+
+	    @see pushButton()
+	*/
+	QSpinWidget  *spinWidget( const Region& rControlRegion );
+
+	/** 'Get' method for tab bar.
+
+	    @see pushButton()
+	*/
+	QTabBar      *tabBar( const Region& rControlRegion );
+
+	/** 'Get' method for tab widget.
+
+	    @see pushButton()
+	*/
+	QTabWidget   *tabWidget( const Region& rControlRegion );
+
+	/** 'Get' method for list view.
+
+	    @see pushButton()
+	*/
+	QListView    *listView( const Region& rControlRegion );
+
+	/** 'Get' method for scroll bar.
+
+	    @see pushButton()
+	*/
+	QScrollBar   *scrollBar( const Region& rControlRegion,
+		BOOL bHorizontal, const ImplControlValue& aValue );
+
+	// TODO other widgets
+
+    protected:
+	/** Style conversion function.
+
+	    Conversion function between VCL ControlState together with
+	    ImplControlValue and Qt state flags.
+
+	    @param nState
+	    State of the widget (default, focused, ...) as defined in Native
+	    Widget Framework.
+
+	    @param aValue
+	    Value held by the widget (on, off, ...)
+	*/
+	QStyle::SFlags vclStateValue2SFlags( ControlState nState, const ImplControlValue& aValue );
+
+    public:
+	/** Convert VCL Region to QRect.
+
+	    @param rControlRegion
+	    The region to convert.
+
+	    @return
+	    The bounding box of the region.
+	*/
+	static QRect region2QRect( const Region& rControlRegion );
+};
+
+WidgetPainter::WidgetPainter( void )
+    : m_pPushButton( NULL ),
+      m_pRadioButton( NULL ),
+      m_pCheckBox( NULL ),
+      m_pComboBox( NULL ),
+      m_pEditableComboBox( NULL ),
+      m_pLineEdit( NULL ),
+      m_pSpinWidget( NULL ),
+      m_pSpinEdit( NULL ),
+      m_pTabLeft( NULL ),
+      m_pTabMiddle( NULL ),
+      m_pTabRight( NULL ),
+      m_pTabAlone( NULL ),
+      m_pTabBarParent( NULL ),
+      m_pTabBar( NULL ),
+      m_pTabWidget( NULL ),
+      m_pListView( NULL ),
+      m_pScrollBar( NULL )
+{
+}
+
+WidgetPainter::~WidgetPainter( void )
+{
+    delete m_pPushButton, m_pPushButton = NULL;
+    delete m_pRadioButton, m_pRadioButton = NULL;
+    delete m_pCheckBox, m_pCheckBox = NULL;
+    delete m_pComboBox, m_pComboBox = NULL;
+    delete m_pEditableComboBox, m_pEditableComboBox = NULL;
+    delete m_pLineEdit, m_pLineEdit = NULL;
+    delete m_pSpinWidget, m_pSpinWidget = NULL;
+    delete m_pSpinEdit, m_pSpinEdit = NULL;
+    delete m_pTabLeft, m_pTabLeft = NULL;
+    delete m_pTabMiddle, m_pTabMiddle = NULL;
+    delete m_pTabRight, m_pTabRight = NULL;
+    delete m_pTabAlone, m_pTabAlone = NULL;
+    delete m_pTabBarParent, m_pTabBarParent = NULL;
+    delete m_pTabBar, m_pTabBar = NULL;
+    delete m_pTabWidget, m_pTabWidget = NULL;
+    delete m_pListView, m_pListView = NULL;
+    delete m_pScrollBar, m_pScrollBar = NULL;
+}
+
+BOOL WidgetPainter::drawStyledWidget( QWidget *pWidget,
+	ControlState nState, const ImplControlValue& aValue,
+	Display *dpy, XLIB_Window drawable, GC gc )
+{
+    if ( !pWidget )
+	return FALSE;
+
+    // Normalize the widget
+    QPoint   qWidgetPos( pWidget->pos() );
+    pWidget->move( 0, 0 );
+
+    // Enable/disable the widget
+    pWidget->setEnabled( nState & CTRL_STATE_ENABLED );
+
+    // Create pixmap to paint to
+    QPixmap  qPixmap( pWidget->width(), pWidget->height() );
+    QPainter qPainter( &qPixmap );
+    QRect    qRect( 0, 0, pWidget->width(), pWidget->height() );
+
+    // Use the background of the widget
+    qPixmap.fill( pWidget, QPoint(0, 0) );
+    
+    // Convert the flags
+    QStyle::SFlags nStyle = vclStateValue2SFlags( nState, aValue );
+    
+    // Store the widget class
+    const char *pClassName = pWidget->className();
+    
+    // Draw the widget to the pixmap
+    if ( strcmp( "QPushButton", pClassName ) == 0 )
+    {
+	// Workaround for the Platinum style.
+	// Platinum takes the state directly from the widget, not from SFlags.
+	QPushButton *pPushButton = static_cast<QPushButton *>( pWidget->qt_cast( "QPushButton" ) );
+	if ( pPushButton )
+	{
+	    pPushButton->setDown   ( nStyle & QStyle::Style_Down );
+	    pPushButton->setOn     ( nStyle & QStyle::Style_On );
+	    pPushButton->setEnabled( nStyle & QStyle::Style_Enabled );
+	}
+	
+	kapp->style().drawControl( QStyle::CE_PushButton,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QRadioButton", pClassName ) == 0 )
+    {
+	// Bitblt from the screen, because the radio buttons are usually not
+	// rectangular, and there could be a bitmap under them
+	GC aTmpGC = XCreateGC( dpy, qPixmap.handle(), 0, NULL );
+	XCopyArea( dpy,
+		drawable, qPixmap.handle(),
+		aTmpGC,
+		qWidgetPos.x(), qWidgetPos.y(), qRect.width(), qRect.height(),
+		0, 0 );
+	XFreeGC( dpy, aTmpGC );
+
+	kapp->style().drawControl( QStyle::CE_RadioButton,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QCheckBox", pClassName ) == 0 )
+    {
+	kapp->style().drawControl( QStyle::CE_CheckBox,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QComboBox", pClassName ) == 0 )
+    {
+	kapp->style().drawComplexControl( QStyle::CC_ComboBox,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle );
+	
+	// Editable combo box uses the background of the associated edit box
+	QComboBox *pComboBox = static_cast<QComboBox *>( pWidget->qt_cast( "QComboBox" ) );
+	if ( pComboBox && pComboBox->editable() && pComboBox->lineEdit() )
+	{
+	    QColorGroup::ColorRole eColorRole = ( pComboBox->isEnabled() )?
+		QColorGroup::Base: QColorGroup::Background;
+	    qPainter.fillRect( 
+		    kapp->style().querySubControlMetrics( QStyle::CC_ComboBox, 
+			pComboBox, QStyle::SC_ComboBoxEditField ),
+		    pComboBox->lineEdit()->colorGroup().brush( eColorRole ) );
+	}
+    }
+    else if ( strcmp( "QLineEdit", pClassName ) == 0 )
+    {
+	kapp->style().drawPrimitive( QStyle::PE_PanelLineEdit,
+		&qPainter, qRect,
+		pWidget->colorGroup(), nStyle | QStyle::Style_Sunken );
+    }
+    else if ( strcmp( "QSpinWidget", pClassName ) == 0 )
+    {
+	SpinbuttonValue *pValue = static_cast<SpinbuttonValue *> ( aValue.getOptionalVal() );
+	
+	// Is any of the buttons pressed?
+	QStyle::SCFlags eActive = QStyle::SC_None;
+	if ( pValue )
+	{
+	    if ( pValue->mnUpperState & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_SpinWidgetUp;
+	    else if ( pValue->mnLowerState & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_SpinWidgetDown;
+
+	    // Update the enable/disable state of the widget
+	    if ( ( nState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnUpperState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnLowerState & CTRL_STATE_ENABLED ) )
+	    {
+		pWidget->setEnabled( true );
+		nStyle |= QStyle::Style_Enabled;
+	    }
+	    else
+		pWidget->setEnabled( false );
+
+	    // Mouse-over effect
+	    if ( (pValue->mnUpperState & CTRL_STATE_ROLLOVER) ||
+		    (pValue->mnLowerState & CTRL_STATE_ROLLOVER) )
+		nStyle |= QStyle::Style_MouseOver;
+	}
+
+	// Spin widget uses the background of the associated edit box
+	QSpinWidget *pSpinWidget = static_cast<QSpinWidget *>( pWidget->qt_cast( "QSpinWidget" ) );
+	if ( pSpinWidget && pSpinWidget->editWidget() )
+	{
+	    QColorGroup::ColorRole eColorRole = ( pSpinWidget->isEnabled() )?
+		QColorGroup::Base: QColorGroup::Background;
+	    qPainter.fillRect( 
+		    kapp->style().querySubControlMetrics( QStyle::CC_SpinWidget, 
+			pSpinWidget, QStyle::SC_SpinWidgetEditField ),
+		    pSpinWidget->editWidget()->colorGroup().brush( eColorRole ) );
+	}
+
+	// Adjust the frame (needed for Motif Plus style)
+	QRect qFrameRect = kapp->style().querySubControlMetrics( QStyle::CC_SpinWidget,
+		pWidget, QStyle::SC_SpinWidgetFrame );
+	
+	kapp->style().drawComplexControl( QStyle::CC_SpinWidget,
+		&qPainter, pWidget, qFrameRect,
+		pWidget->colorGroup(), nStyle,
+		QStyle::SC_All, eActive );
+    }
+    else if ( strcmp( "QTabBar", pClassName ) == 0 )
+    {
+	TabitemValue *pValue = static_cast<TabitemValue *> ( aValue.getOptionalVal() );
+	
+	QTab *pTab = NULL;
+	if ( pValue )
+	{
+	    if ( ( pValue->isFirst() || pValue->isLeftAligned() ) && ( pValue->isLast() || pValue->isRightAligned() ) )
+		pTab = m_pTabAlone;
+	    else if ( pValue->isFirst() || pValue->isLeftAligned() )
+		pTab = m_pTabLeft;
+	    else if ( pValue->isLast() || pValue->isRightAligned() )
+		pTab = m_pTabRight;
+	    else
+		pTab = m_pTabMiddle;
+	}
+	if ( !pTab )
+	    return FALSE;
+	
+	pTab->setRect( qRect );
+	
+	kapp->style().drawControl( QStyle::CE_TabBarTab,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle,
+		QStyleOption( pTab ) );
+    }
+    else if ( strcmp( "QTabWidget", pClassName ) == 0 )
+    {
+	kapp->style().drawPrimitive( QStyle::PE_PanelTabWidget,
+		&qPainter, qRect,
+		pWidget->colorGroup(), nStyle );
+    }
+    else if ( strcmp( "QListView", pClassName ) == 0 )
+    {
+	kapp->style().drawPrimitive( QStyle::PE_Panel,
+		&qPainter, qRect,
+		pWidget->colorGroup(), nStyle | QStyle::Style_Sunken );
+    }
+    else if ( strcmp( "QScrollBar", pClassName ) == 0 )
+    {
+	ScrollbarValue *pValue = static_cast<ScrollbarValue *> ( aValue.getOptionalVal() );
+
+	QStyle::SCFlags eActive = QStyle::SC_None;
+	if ( pValue )
+	{
+	    // Workaround for Style_MouseOver-aware themes.
+	    // Quite ugly, but I do not know about a better solution.
+	    const char *pStyleName = kapp->style().className();
+	    if ( strcmp( "QMotifPlusStyle", pStyleName ) == 0 )
+	    {
+		nStyle |= QStyle::Style_MouseOver;
+		if ( pValue->mnThumbState & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarSlider;
+	    }
+	    else if ( strcmp( "QSGIStyle", pStyleName ) == 0 )
+	    {
+		nStyle |= QStyle::Style_MouseOver;
+		if ( pValue->mnButton1State & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarSubLine;
+		else if ( pValue->mnButton2State & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarAddLine;
+		else if ( pValue->mnThumbState & CTRL_STATE_ROLLOVER )
+		    eActive = QStyle::SC_ScrollBarSlider;
+	    }
+
+	    if ( pValue->mnButton1State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarSubLine;
+	    else if ( pValue->mnButton2State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarAddLine;
+	    else if ( pValue->mnThumbState & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarSlider;
+	    else if ( pValue->mnPage1State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarSubPage;
+	    else if ( pValue->mnPage2State & CTRL_STATE_PRESSED )
+		eActive = QStyle::SC_ScrollBarAddPage;
+
+	    // Update the enable/disable state of the widget
+	    if ( ( nState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnButton1State & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnButton2State & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnThumbState & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnPage1State & CTRL_STATE_ENABLED ) ||
+		    ( pValue->mnPage2State & CTRL_STATE_ENABLED ) )
+	    {
+		pWidget->setEnabled( true );
+		nStyle |= QStyle::Style_Enabled;
+	    }
+	    else
+		pWidget->setEnabled( false );
+	}
+	
+	// Is it a horizontal scroll bar?
+	QScrollBar *pScrollBar = static_cast<QScrollBar *> ( pWidget->qt_cast( "QScrollBar" ) );
+	QStyle::StyleFlags eHoriz = QStyle::Style_Default;
+	if ( pScrollBar && pScrollBar->orientation() == Qt::Horizontal )
+	    eHoriz = QStyle::Style_Horizontal;
+
+	kapp->style().drawComplexControl( QStyle::CC_ScrollBar,
+		&qPainter, pWidget, qRect,
+		pWidget->colorGroup(), nStyle | eHoriz,
+		QStyle::SC_All, eActive );
+    }
+    else
+	return FALSE;
+
+    // Bitblt it to the screen
+    XCopyArea( dpy,
+	       qPixmap.handle(), drawable,
+	       gc,
+	       0, 0, qRect.width(), qRect.height(),
+	       qWidgetPos.x(), qWidgetPos.y() );
+
+    // Restore widget's position
+    pWidget->move( qWidgetPos );
+
+    return TRUE;
+}
+
+QPushButton *WidgetPainter::pushButton( const Region& rControlRegion,
+	BOOL bDefault )
+{
+    if ( !m_pPushButton )
+	m_pPushButton = new QPushButton( NULL, "push_button" );
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    // Workaround for broken styles which do not add
+    // QStyle::PM_ButtonDefaultIndicator to the size of the default button
+    // (for example Keramik)
+    // FIXME Fix Keramik style to be consistant with Qt built-in styles. Aargh!
+    if ( bDefault )
+    {
+	QSize qContentsSize( 50, 50 );
+	m_pPushButton->setDefault( false );
+	QSize qNormalSize = kapp->style().sizeFromContents( QStyle::CT_PushButton,
+		m_pPushButton, qContentsSize );
+	m_pPushButton->setDefault( true );
+	QSize qDefSize = kapp->style().sizeFromContents( QStyle::CT_PushButton,
+		m_pPushButton, qContentsSize );
+	
+	int nIndicatorSize = kapp->style().pixelMetric(
+		QStyle::PM_ButtonDefaultIndicator, m_pPushButton );
+	if ( qNormalSize.width() == qDefSize.width() )
+	    qRect.addCoords( nIndicatorSize, 0, -nIndicatorSize, 0 );
+	if ( qNormalSize.height() == qDefSize.height() )
+	    qRect.addCoords( 0, nIndicatorSize, 0, -nIndicatorSize );
+    }
+    
+    m_pPushButton->move( qRect.topLeft() );
+    m_pPushButton->resize( qRect.size() );
+    m_pPushButton->setDefault( bDefault );
+
+    return m_pPushButton;
+}
+
+QRadioButton *WidgetPainter::radioButton( const Region& rControlRegion )
+{
+    if ( !m_pRadioButton )
+	m_pRadioButton = new QRadioButton( NULL, "radio_button" );
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    // Workaround for broken themes which do not honor the given size.
+    // Quite ugly, but I do not know about a better solution.
+    const char *pStyleName = kapp->style().className();
+    if ( strcmp( "KThemeStyle", pStyleName ) == 0 )
+    {
+	QRect qOldRect( qRect );
+	
+	qRect.setWidth( kapp->style().pixelMetric(
+		QStyle::PM_ExclusiveIndicatorWidth, m_pRadioButton ) );
+	qRect.setHeight( kapp->style().pixelMetric(
+		QStyle::PM_ExclusiveIndicatorHeight, m_pRadioButton ) );
+	
+	qRect.moveBy( ( qOldRect.width() - qRect.width() ) / 2,
+		( qOldRect.height() - qRect.height() ) / 2 );
+    }
+
+    m_pRadioButton->move( qRect.topLeft() );
+    m_pRadioButton->resize( qRect.size() );
+    
+    return m_pRadioButton;
+}
+
+QCheckBox *WidgetPainter::checkBox( const Region& rControlRegion )
+{
+    if ( !m_pCheckBox )
+	m_pCheckBox = new QCheckBox( NULL, "check_box" );
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    // Workaround for broken themes which do not honor the given size.
+    // Quite ugly, but I do not know about a better solution.
+    const char *pStyleName = kapp->style().className();
+    if ( strcmp( "KThemeStyle", pStyleName ) == 0 )
+    {
+	QRect qOldRect( qRect );
+	
+	qRect.setWidth( kapp->style().pixelMetric(
+		QStyle::PM_IndicatorWidth, m_pCheckBox ) );
+	qRect.setHeight( kapp->style().pixelMetric(
+		QStyle::PM_IndicatorHeight, m_pCheckBox ) );
+	
+	qRect.moveBy( ( qOldRect.width() - qRect.width() ) / 2,
+		( qOldRect.height() - qRect.height() ) / 2 );
+    }
+
+    m_pCheckBox->move( qRect.topLeft() );
+    m_pCheckBox->resize( qRect.size() );
+
+    return m_pCheckBox;
+}
+
+QComboBox *WidgetPainter::comboBox( const Region& rControlRegion,
+	BOOL bEditable )
+{
+    QComboBox *pComboBox = NULL;
+    if ( bEditable )
+    {
+	if ( !m_pEditableComboBox )
+	    m_pEditableComboBox = new QComboBox( true, NULL, "combo_box_edit" );
+	pComboBox = m_pEditableComboBox;
+    }
+    else
+    {
+	if ( !m_pComboBox )
+	    m_pComboBox = new QComboBox( false, NULL, "combo_box" );
+	pComboBox = m_pComboBox;
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    pComboBox->move( qRect.topLeft() );
+    pComboBox->resize( qRect.size() );
+
+    return pComboBox;
+}
+
+QLineEdit *WidgetPainter::lineEdit( const Region& rControlRegion )
+{
+    if ( !m_pLineEdit )
+	m_pLineEdit = new QLineEdit( NULL, "line_edit" );
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pLineEdit->move( qRect.topLeft() );
+    m_pLineEdit->resize( qRect.size() );
+
+    return m_pLineEdit;
+}
+
+QSpinWidget *WidgetPainter::spinWidget( const Region& rControlRegion )
+{
+    if ( !m_pSpinWidget )
+    {
+	m_pSpinWidget = new QSpinWidget( NULL, "spin_widget" );
+	
+	m_pSpinEdit = new QLineEdit( NULL, "line_edit_spin" );
+	m_pSpinWidget->setEditWidget( m_pSpinEdit );
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pSpinWidget->move( qRect.topLeft() );
+    m_pSpinWidget->resize( qRect.size() );
+    m_pSpinWidget->arrange();
+
+    return m_pSpinWidget;
+}
+
+QTabBar *WidgetPainter::tabBar( const Region& rControlRegion )
+{
+    if ( !m_pTabBar )
+    {
+	if ( !m_pTabBarParent )
+	    m_pTabBarParent = new QWidget( NULL, "tab_bar_parent" );
+
+	m_pTabBar = new QTabBar( m_pTabBarParent, "tab_bar" );
+	
+	m_pTabLeft = new QTab();
+	m_pTabMiddle = new QTab();
+	m_pTabRight = new QTab();
+	m_pTabAlone = new QTab();
+
+	m_pTabBar->addTab( m_pTabLeft );
+	m_pTabBar->addTab( m_pTabMiddle );
+	m_pTabBar->addTab( m_pTabRight );
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+
+    m_pTabBar->move( qRect.topLeft() );
+    m_pTabBar->resize( qRect.size() );
+    
+    m_pTabBar->setShape( QTabBar::RoundedAbove );
+
+    return m_pTabBar;
+}
+
+QTabWidget *WidgetPainter::tabWidget( const Region& rControlRegion )
+{
+    if ( !m_pTabWidget )
+	m_pTabWidget = new QTabWidget( NULL, "tab_widget" );
+
+    QRect qRect = region2QRect( rControlRegion );
+    --qRect.rTop();
+    
+    m_pTabWidget->move( qRect.topLeft() );
+    m_pTabWidget->resize( qRect.size() );
+    
+    return m_pTabWidget;
+}
+
+QListView *WidgetPainter::listView( const Region& rControlRegion )
+{
+    if ( !m_pListView )
+	m_pListView = new QListView( NULL, "list_view" );
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pListView->move( qRect.topLeft() );
+    m_pListView->resize( qRect.size() );
+
+    return m_pListView;
+}
+
+QScrollBar *WidgetPainter::scrollBar( const Region& rControlRegion,
+	BOOL bHorizontal, const ImplControlValue& aValue )
+{
+    if ( !m_pScrollBar )
+    {
+	m_pScrollBar = new QScrollBar( NULL, "scroll_bar" );
+	m_pScrollBar->setTracking( false );
+	m_pScrollBar->setLineStep( 1 );
+    }
+
+    QRect qRect = region2QRect( rControlRegion );
+    
+    m_pScrollBar->move( qRect.topLeft() );
+    m_pScrollBar->resize( qRect.size() );
+    m_pScrollBar->setOrientation( bHorizontal? Qt::Horizontal: Qt::Vertical );
+
+    ScrollbarValue *pValue = static_cast<ScrollbarValue *> ( aValue.getOptionalVal() );
+    if ( pValue )
+    {
+	m_pScrollBar->setMinValue( pValue->mnMin );
+	m_pScrollBar->setMaxValue( pValue->mnMax - pValue->mnVisibleSize );
+	m_pScrollBar->setValue( pValue->mnCur );
+	m_pScrollBar->setPageStep( pValue->mnVisibleSize );
+    }
+
+    return m_pScrollBar;
+}
+
+QStyle::SFlags WidgetPainter::vclStateValue2SFlags( ControlState nState,
+	const ImplControlValue& aValue )
+{
+    QStyle::SFlags nStyle =
+	( (nState & CTRL_STATE_DEFAULT)?  QStyle::Style_ButtonDefault: QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_ENABLED)?  QStyle::Style_Enabled:       QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_FOCUSED)?  QStyle::Style_HasFocus:      QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_PRESSED)?  QStyle::Style_Down:          QStyle::Style_Raised )  |
+	( (nState & CTRL_STATE_SELECTED)? QStyle::Style_Selected :     QStyle::Style_Default ) |
+	( (nState & CTRL_STATE_ROLLOVER)? QStyle::Style_MouseOver:     QStyle::Style_Default );
+	//TODO ( (nState & CTRL_STATE_HIDDEN)?   QStyle::Style_: QStyle::Style_Default ) |
+
+    switch ( aValue.getTristateVal() )
+    {
+	case BUTTONVALUE_ON:    nStyle |= QStyle::Style_On;       break;
+	case BUTTONVALUE_OFF:   nStyle |= QStyle::Style_Off;      break;
+	case BUTTONVALUE_MIXED: nStyle |= QStyle::Style_NoChange; break;
+    }
+
+    return nStyle;
+}
+
+QRect WidgetPainter::region2QRect( const Region& rControlRegion )
+{
+    Rectangle aRect = rControlRegion.GetBoundRect();
+
+    return QRect( QPoint( aRect.Left(), aRect.Top() ),
+		  QPoint( aRect.Right(), aRect.Bottom() ) );
+}
+
+/** Instance of WidgetPainter.
+
+    It is used to paint the widgets requested by NWF.
+*/
+static WidgetPainter widgetPainter;
+
+
+/** Initialization of KDE and local stuff.
+
+    It creates an instance of KApplication.
+*/
+void VCLInitNativeWidgets( void )
+{
+    KAboutData *kAboutData = new KAboutData( "OpenOffice.org",
+	    I18N_NOOP( "OpenOffice.org" ),
+	    "1.1.0",
+	    I18N_NOOP( "OpenOffice.org with KDE Native Widget Support." ),
+	    KAboutData::License_LGPL,
+	    "(c) 2003, Jan Holesovsky",
+	    I18N_NOOP( "OpenOffice.org is an office suite.\n" ),
+	    "http://kde.openoffice.org/index.html",
+	    "dev@kde.openoffice.org");
+    kAboutData->addAuthor( "Jan Holesovsky",
+	    I18N_NOOP( "Original author and maintainer of the KDE NWF." ),
+	    "kendy@artax.karlin.mff.cuni.cz",
+	    "http://artax.karlin.mff.cuni.cz/~kendy" );
+
+    // We ignore the arguments, KApplication has to be initialized according
+    // to the OOo's display.
+    int argc = 0;
+    char *argv[20] = { "soffice.bin", 0 };
+    KCmdLineArgs::init( argc, argv, kAboutData );
+
+    // Get display
+    SalDisplay *pSalDisplay = GetSalData()->GetCurDisp();
+    if ( !pSalDisplay )
+	::std::cerr << "Cannot get current display!" << ::std::endl;
+    else
+	new KApplication( pSalDisplay->GetDisplay(), argc, argv, "soffice.bin" );
+}
+
+/** Release KDE and local stuff
+
+    No operation for KDE.
+*/
+void VCLDeinitNativeWidgets( void )
+{
+}
+
+/** What widgets can be drawn the native way.
+
+    @param nType
+    Type of the widget.
+    
+    @param nPart
+    Specification of the widget's part if it consists of more than one.
+  
+    @return TRUE if the platform supports native drawing of the widget nType
+    defined by nPart.
+*/
+BOOL SalGraphics::IsNativeControlSupported( ControlType nType, ControlPart nPart )
+{
+    return
+	( (nType == CTRL_PUSHBUTTON)  && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_RADIOBUTTON) && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_CHECKBOX)    && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_COMBOBOX)    && (nPart == PART_ENTIRE_CONTROL || nPart == HAS_BACKGROUND_TEXTURE) ) ||
+	( (nType == CTRL_EDITBOX)     && (nPart == PART_ENTIRE_CONTROL || nPart == HAS_BACKGROUND_TEXTURE) ) ||
+	( (nType == CTRL_LISTBOX)     && (nPart == PART_ENTIRE_CONTROL || nPart == PART_WINDOW) ) ||
+	( (nType == CTRL_SPINBOX)     && (nPart == PART_ENTIRE_CONTROL || nPart == HAS_BACKGROUND_TEXTURE) ) ||
+	// no CTRL_SPINBUTTONS for KDE
+	( (nType == CTRL_TAB_ITEM)    && (nPart == PART_ENTIRE_CONTROL) ) ||
+	( (nType == CTRL_TAB_PANE)    && (nPart == PART_ENTIRE_CONTROL) ) ||
+	// no CTRL_TAB_BODY for KDE
+	( (nType == CTRL_SCROLLBAR)   && (nPart == PART_ENTIRE_CONTROL || nPart == PART_DRAW_BACKGROUND_HORZ || nPart == PART_DRAW_BACKGROUND_VERT) ) ||
+	( (nType == CTRL_SCROLLBAR)   && (nPart == HAS_THREE_BUTTONS) ); // TODO small optimization is possible here: return this only if the style really has 3 buttons
+	// CTRL_GROUPBOX not supported
+	// CTRL_FIXEDLINE not supported
+	// CTRL_FIXEDBORDER not supported
+}
+
+
+/** Test whether the position is in the native widget.
+
+    If the return value is TRUE, bIsInside contains information whether
+    aPos was or was not inside the native widget specified by the
+    nType/nPart combination.
+*/
+BOOL SalGraphics::HitTestNativeControl( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, const Point& aPos,
+	SalControlHandle& rControlHandle, BOOL& rIsInside,
+	const OutputDevice* )
+{
+    if ( nType == CTRL_SCROLLBAR )
+    {
+	rIsInside = FALSE;
+
+	BOOL bHorizontal = ( nPart == PART_BUTTON_LEFT || nPart == PART_BUTTON_RIGHT );
+	
+	QScrollBar *pScrollBar = widgetPainter.scrollBar( rControlRegion,
+		bHorizontal, ImplControlValue() );
+	QRect qRectSubLine = kapp->style().querySubControlMetrics(
+		QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarSubLine );
+	QRect qRectAddLine = kapp->style().querySubControlMetrics(
+		QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarAddLine );
+
+	// There are 2 buttons on the right/bottom side of the scrollbar
+	BOOL bTwoSubButtons = FALSE;
+
+	// It is a Platinum style scroll bar
+	BOOL bPlatinumStyle = FALSE;
+
+	// Workaround for Platinum and 3 button style scroll bars.
+	// It makes the right/down button bigger.
+	if ( bHorizontal )
+	{
+	    qRectAddLine.setLeft( kapp->style().querySubControlMetrics(
+			QStyle::CC_ScrollBar, pScrollBar,
+			QStyle::SC_ScrollBarAddPage ).right() + 1 );
+	    if ( qRectAddLine.width() > qRectSubLine.width() )
+		bTwoSubButtons = TRUE;
+	    if ( qRectSubLine.left() > kapp->style().querySubControlMetrics( QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarSubPage ).left() )
+		bPlatinumStyle = TRUE;
+	}
+	else
+	{
+	    qRectAddLine.setTop( kapp->style().querySubControlMetrics(
+			QStyle::CC_ScrollBar, pScrollBar,
+			QStyle::SC_ScrollBarAddPage ).bottom() + 1 );
+	    if ( qRectAddLine.height() > qRectSubLine.height() )
+		bTwoSubButtons = TRUE;
+	    if ( qRectSubLine.top() > kapp->style().querySubControlMetrics( QStyle::CC_ScrollBar, pScrollBar, QStyle::SC_ScrollBarSubPage ).top() )
+		bPlatinumStyle = TRUE;
+	}
+
+	switch ( nPart )
+	{
+	    case PART_BUTTON_LEFT:
+		if ( !bPlatinumStyle && qRectSubLine.contains( aPos.getX(), aPos.getY() ) )
+		    rIsInside = TRUE;
+		else if ( bTwoSubButtons )
+		{
+		    qRectAddLine.setWidth( qRectAddLine.width() / 2 );
+		    rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		}
+		break;
+		
+	    case PART_BUTTON_UP:
+		if ( !bPlatinumStyle && qRectSubLine.contains( aPos.getX(), aPos.getY() ) )
+		    rIsInside = TRUE;
+		else if ( bTwoSubButtons )
+		{
+		    qRectAddLine.setHeight( qRectAddLine.height() / 2 );
+		    rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		}
+		break;
+		
+	    case PART_BUTTON_RIGHT:
+		if ( bTwoSubButtons )
+		    qRectAddLine.setLeft( qRectAddLine.left() + qRectAddLine.width() / 2 );
+
+		rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		break;
+		
+	    case PART_BUTTON_DOWN:
+		if ( bTwoSubButtons )
+		    qRectAddLine.setTop( qRectAddLine.top() + qRectAddLine.height() / 2 );
+
+		rIsInside = qRectAddLine.contains( aPos.getX(), aPos.getY() );
+		break;
+	}
+
+	return TRUE;
+    }
+
+    return FALSE;
+}
+
+
+/** Draw the requested control described by nPart/nState.
+ 
+    @param rControlRegion
+    The bounding region of the complete control in VCL frame coordinates.
+    
+    @param aValue
+    An optional value (tristate/numerical/string).
+    
+    @param rControlHandle
+    Carries platform dependent data and is maintained by the SalFrame implementation.
+    
+    @param aCaption
+    A caption or title string (like button text etc.)
+*/
+BOOL SalGraphics::DrawNativeControl( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, ControlState nState,
+	const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+	OUString aCaption, const OutputDevice* )
+{
+    BOOL bReturn = FALSE;
+
+    Display *dpy = maGraphicsData.GetXDisplay();
+    XLIB_Window drawable = maGraphicsData.GetDrawable();
+    GC gc = maGraphicsData.SelectFont(); // GC with current clipping region set
+	
+    if ( (nType == CTRL_PUSHBUTTON) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.pushButton( rControlRegion, (nState & CTRL_STATE_DEFAULT) ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_RADIOBUTTON) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.radioButton( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_CHECKBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.checkBox( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_COMBOBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.comboBox( rControlRegion, TRUE ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_EDITBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.lineEdit( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_LISTBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.comboBox( rControlRegion, FALSE ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_LISTBOX) && (nPart == PART_WINDOW) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.listView( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_SPINBOX) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.spinWidget( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType==CTRL_TAB_ITEM) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.tabBar( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType==CTRL_TAB_PANE) && (nPart == PART_ENTIRE_CONTROL) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.tabWidget( rControlRegion ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+    else if ( (nType == CTRL_SCROLLBAR) && (nPart == PART_DRAW_BACKGROUND_HORZ || nPart == PART_DRAW_BACKGROUND_VERT) )
+    {
+	bReturn = widgetPainter.drawStyledWidget(
+		widgetPainter.scrollBar( rControlRegion, nPart == PART_DRAW_BACKGROUND_HORZ, aValue ),
+		nState, aValue,
+		dpy, drawable, gc );
+    }
+
+    return bReturn;
+}
+
+
+/** Draw text on the widget.
+ 
+    OPTIONAL. Draws the requested text for the control described by nPart/nState.
+    Used if text is not drawn by DrawNativeControl().
+ 
+    @param rControlRegion
+    The bounding region of the complete control in VCL frame coordinates.
+    
+    @param aValue
+    An optional value (tristate/numerical/string)
+    
+    @param rControlHandle
+    Carries platform dependent data and is maintained by the SalFrame implementation.
+    
+    @param aCaption
+    A caption or title string (like button text etc.)
+*/
+BOOL SalGraphics::DrawNativeControlText( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, ControlState nState,
+	const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+	OUString aCaption, const OutputDevice* )
+{
+    return FALSE;
+}
+
+/** Check if the bounding regions match.
+
+    If the return value is TRUE, rNativeBoundingRegion
+    contains the true bounding region covered by the control
+    including any adornment, while rNativeContentRegion contains the area
+    within the control that can be safely drawn into without drawing over
+    the borders of the control.
+
+    @param rControlRegion
+    The bounding region of the control in VCL frame coordinates.
+    
+    @param aValue
+    An optional value (tristate/numerical/string)
+    
+    @param rControlHandle
+    Carries platform dependent data and is maintained by the SalFrame implementation.
+    
+    @param aCaption
+    A caption or title string (like button text etc.)
+*/
+BOOL SalGraphics::GetNativeControlRegion( ControlType nType, ControlPart nPart,
+	const Region& rControlRegion, ControlState nState,
+	const ImplControlValue& aValue, SalControlHandle& rControlHandle,
+	OUString aCaption,
+	Region &rNativeBoundingRegion, Region &rNativeContentRegion,
+	const OutputDevice* )
+{
+    BOOL bReturn = FALSE;
+    QRect qBoundingRect = WidgetPainter::region2QRect( rControlRegion );
+    QRect qRect;
+    
+    QWidget *pWidget = NULL;
+    switch ( nType )
+    {
+	// Metrics of the push button
+	case CTRL_PUSHBUTTON:
+	    pWidget = widgetPainter.pushButton( rControlRegion, ( nState & CTRL_STATE_DEFAULT ) );
+
+	    switch ( nPart )
+	    {
+		case PART_ENTIRE_CONTROL:
+		    qRect = qBoundingRect;
+
+		    if ( nState & CTRL_STATE_DEFAULT )
+		    {
+			int nIndicatorSize = kapp->style().pixelMetric(
+				QStyle::PM_ButtonDefaultIndicator, pWidget );
+			qBoundingRect.addCoords( -nIndicatorSize, -nIndicatorSize,
+				nIndicatorSize, nIndicatorSize );
+			bReturn = TRUE;
+		    }
+		    break;
+	    }
+	    break;
+
+	// Metrics of the combo box
+	case CTRL_COMBOBOX:
+	case CTRL_LISTBOX:
+	    pWidget = widgetPainter.comboBox( rControlRegion, ( nType == CTRL_COMBOBOX ) );
+	    switch ( nPart )
+	    {
+		case PART_BUTTON_DOWN:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ComboBox, pWidget, QStyle::SC_ComboBoxArrow );
+		    qRect.setLeft( kapp->style().querySubControlMetrics(
+			    QStyle::CC_ComboBox, pWidget,
+			    QStyle::SC_ComboBoxEditField ).right() + 1 );
+		    bReturn = TRUE;
+		    break;
+
+		case PART_SUB_EDIT:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ComboBox, pWidget, QStyle::SC_ComboBoxEditField );
+		    bReturn = TRUE;
+		    break;
+	    }
+	    break;
+
+	// Metrics of the spin box
+	case CTRL_SPINBOX:
+	    pWidget = widgetPainter.spinWidget( rControlRegion );
+	    switch ( nPart )
+	    {
+		case PART_BUTTON_UP:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_SpinWidget, pWidget, QStyle::SC_SpinWidgetUp );
+		    bReturn = TRUE;
+		    break;
+
+		case PART_BUTTON_DOWN:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_SpinWidget, pWidget, QStyle::SC_SpinWidgetDown );
+		    bReturn = TRUE;
+		    break;
+	    }
+	    break;
+
+	// Metrics of the scroll bar
+	case CTRL_SCROLLBAR:
+	    pWidget = widgetPainter.scrollBar( rControlRegion,
+		    ( nPart == PART_BUTTON_LEFT || nPart == PART_BUTTON_RIGHT ),
+		    ImplControlValue() );
+	    switch ( nPart )
+	    {
+		case PART_BUTTON_LEFT:
+		case PART_BUTTON_UP:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ScrollBar, pWidget, QStyle::SC_ScrollBarSubLine );
+
+		    // Workaround for Platinum style scroll bars. It makes the
+		    // left/up button invisible.
+		    if ( nPart == PART_BUTTON_LEFT )
+		    {
+			if ( qRect.left() > kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarSubPage ).left() )
+			{
+			    qRect.setLeft( 0 );
+			    qRect.setRight( 0 );
+			}
+		    }
+		    else
+		    {
+			if ( qRect.top() > kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarSubPage ).top() )
+			{
+			    qRect.setTop( 0 );
+			    qRect.setBottom( 0 );
+			}
+		    }
+
+		    bReturn = TRUE;
+		    break;
+
+		case PART_BUTTON_RIGHT:
+		case PART_BUTTON_DOWN:
+		    qRect = kapp->style().querySubControlMetrics(
+			    QStyle::CC_ScrollBar, pWidget, QStyle::SC_ScrollBarAddLine );
+
+		    // Workaround for Platinum and 3 button style scroll bars.
+		    // It makes the right/down button bigger.
+		    if ( nPart == PART_BUTTON_RIGHT )
+			qRect.setLeft( kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarAddPage ).right() + 1 );
+		    else
+			qRect.setTop( kapp->style().querySubControlMetrics(
+				    QStyle::CC_ScrollBar, pWidget,
+				    QStyle::SC_ScrollBarAddPage ).bottom() + 1 );
+
+		    bReturn = TRUE;
+		    break;
+	    }
+    }
+
+    // Fill rNativeBoundingRegion and rNativeContentRegion
+    if ( bReturn )
+    {
+	// Bounding region
+	Point aBPoint( qBoundingRect.x(), qBoundingRect.y() );
+	Size aBSize( qBoundingRect.width(), qBoundingRect.height() );
+	rNativeBoundingRegion = Region( Rectangle( aBPoint, aBSize ) );
+
+	// Region of the content
+	Point aPoint( qRect.x(), qRect.y() );
+	Size  aSize( qRect.width(), qRect.height() );
+	rNativeContentRegion = Region( Rectangle( aPoint, aSize ) );
+    }
+    
+    return bReturn;
+}
+
+/** Constructor.
+*/
+SalControlHandleData::SalControlHandleData( void )
+{
+}
+
+/** Destructor.
+*/
+SalControlHandleData::~SalControlHandleData( void )
+{
+}
+
+// -----------------------------------------------------------------------
+// KDEIntegrator implementation
+// -----------------------------------------------------------------------
+
+/** Constructor of the KDE integrator.
+*/
+KDEIntegrator::KDEIntegrator( SalFrame* pFrame ) :
+    DtIntegrator( pFrame )
+{
+    meType = DtKDE;
+}
+
+/** Destructor of the KDE integrator.
+*/
+KDEIntegrator::~KDEIntegrator()
+{
+}
+
+/** Helper function to convert colors.
+*/
+Color toColor( const QColor &rColor )
+{
+    return Color( rColor.red(), rColor.green(), rColor.blue() );
+}
+
+/** Helper function to read color from KConfig configuration repository.
+*/
+Color readColor( KConfig *pConfig, const char *pKey )
+{
+    return toColor( pConfig->readColorEntry( pKey ) );
+}
+
+/** Helper function to add information to Font from QFont.
+*/
+void modifyFont( Font &rFont, const QFont &rQFont )
+{
+    QFontInfo qFontInfo( rQFont );
+    
+    rFont.SetName( String( qFontInfo.family().utf8(), RTL_TEXTENCODING_UTF8 ) );
+    
+    // Do not set the height, it does not look good
+    // rFont.SetHeight( qFontInfo.pointSize() );
+    
+    rFont.SetItalic( qFontInfo.italic()? ITALIC_NORMAL: ITALIC_NONE );
+    
+    FontWeight eWeight = WEIGHT_DONTKNOW;
+    int nWeight = qFontInfo.weight();
+    if ( nWeight <= QFont::Light )
+        eWeight = WEIGHT_LIGHT;
+    else if ( nWeight <= QFont::Normal )
+        eWeight = WEIGHT_NORMAL;
+    else if ( nWeight <= QFont::DemiBold )
+        eWeight = WEIGHT_SEMIBOLD;
+    else if ( nWeight <= QFont::Bold )
+        eWeight = WEIGHT_BOLD;
+    else
+        eWeight = WEIGHT_BLACK;
+    rFont.SetWeight( eWeight );
+}
+
+/** Implementation of KDE integration's main method.
+*/
+void KDEIntegrator::GetSystemLook( AllSettings& rSettings )
+{
+    StyleSettings aStyleSettings( rSettings.GetStyleSettings() );
+
+    // WM settings
+    KConfig *pConfig = KGlobal::config();
+    if ( pConfig )
+    {
+        pConfig->setGroup( "WM" );
+        const char *pKey;
+
+        pKey = "activeBackground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetActiveColor( readColor( pConfig, pKey ) );
+
+        pKey = "activeBlend";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetActiveColor2( readColor( pConfig, pKey ) );
+
+        pKey = "inactiveBackground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetDeactiveColor( readColor( pConfig, pKey ) );
+
+        pKey = "inactiveBlend";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetDeactiveColor2( readColor( pConfig, pKey ) );
+
+        pKey = "inactiveForeground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetDeactiveTextColor( readColor( pConfig, pKey ) );
+
+        pKey = "activeForeground";
+        if ( pConfig->hasKey( pKey ) )
+            aStyleSettings.SetActiveTextColor( readColor( pConfig, pKey ) );
+
+        pKey = "titleFont";
+        if ( pConfig->hasKey( pKey ) )
+        {
+            Font aFont= aStyleSettings.GetTitleFont();
+            modifyFont( aFont, pConfig->readFontEntry( pKey ) );
+            aStyleSettings.SetTitleFont( aFont );
+        }
+    }
+
+    // General settings
+    QColorGroup qColorGroup = kapp->palette().active();
+    
+    // Foreground
+    Color aFore = toColor( qColorGroup.foreground() );
+    aStyleSettings.SetRadioCheckTextColor( aFore );
+    aStyleSettings.SetLabelTextColor( aFore );
+    aStyleSettings.SetInfoTextColor( aFore );
+    aStyleSettings.SetDialogTextColor( aFore );
+    aStyleSettings.SetGroupTextColor( aFore );
+
+    // Input boxes, list boxes
+    aStyleSettings.SetFieldColor( toColor( qColorGroup.base() ) );
+    aStyleSettings.SetFieldTextColor( toColor( qColorGroup.text() ) );
+    
+    // Buttons
+    aStyleSettings.SetButtonTextColor( toColor( qColorGroup.buttonText() ) );
+
+    // Disable color
+    aStyleSettings.SetDisableColor( toColor( qColorGroup.mid() ) );
+
+    // Background
+    Color aBack = toColor( qColorGroup.background() );
+    aStyleSettings.Set3DColors( aBack );
+    aStyleSettings.SetFaceColor( aBack );
+    aStyleSettings.SetDialogColor( aBack );
+    if( aBack == COL_LIGHTGRAY )
+        aStyleSettings.SetCheckedColor( Color( 0xCC, 0xCC, 0xCC ) );
+    else
+    {
+        Color aColor2 = aStyleSettings.GetLightColor();
+        aStyleSettings.
+            SetCheckedColor( Color( (BYTE)(((USHORT)aBack.GetRed()+(USHORT)aColor2.GetRed())/2),
+                        (BYTE)(((USHORT)aBack.GetGreen()+(USHORT)aColor2.GetGreen())/2),
+                        (BYTE)(((USHORT)aBack.GetBlue()+(USHORT)aColor2.GetBlue())/2)
+                        ) );
+    }
+
+    // Selection
+    aStyleSettings.SetHighlightColor( toColor( qColorGroup.highlight() ) );
+    aStyleSettings.SetHighlightTextColor( toColor( qColorGroup.highlightedText() ) );
+
+    // Font
+    Font aFont= aStyleSettings.GetAppFont();
+    modifyFont( aFont, kapp->font() );
+
+    aStyleSettings.SetAppFont( aFont );
+    aStyleSettings.SetHelpFont( aFont );
+    aStyleSettings.SetMenuFont( aFont ); // will be changed according to pMenuBar
+    aStyleSettings.SetToolFont( aFont ); // will be changed according to pToolBar
+    aStyleSettings.SetLabelFont( aFont );
+    aStyleSettings.SetInfoFont( aFont );
+    aStyleSettings.SetRadioCheckFont( aFont );
+    aStyleSettings.SetPushButtonFont( aFont );
+    aStyleSettings.SetFieldFont( aFont );
+    aStyleSettings.SetIconFont( aFont );
+    aStyleSettings.SetGroupFont( aFont );
+
+    // Menu
+    KMainWindow qMainWindow;
+    qMainWindow.createGUI();
+
+    KMenuBar *pMenuBar = qMainWindow.menuBar();
+    if ( pMenuBar )
+    {
+        // Color
+        QColorGroup qMenuCG = pMenuBar->colorGroup();
+        aStyleSettings.SetMenuTextColor( toColor( qMenuCG.buttonText() ) );
+        aStyleSettings.SetMenuColor( toColor( qMenuCG.button() ) );
+        aStyleSettings.SetMenuBarColor( toColor( qMenuCG.button() ) );
+        aStyleSettings.SetMenuHighlightColor( toColor ( qMenuCG.highlight() ) );
+        aStyleSettings.SetMenuHighlightTextColor( toColor ( qMenuCG.highlightedText() ) );
+
+        // Font
+        Font aFont= aStyleSettings.GetMenuFont();
+        modifyFont( aFont, pMenuBar->font() );
+        aStyleSettings.SetMenuFont( aFont );
+    }
+
+    // Tool bar
+    KToolBar *pToolBar = qMainWindow.toolBar();
+    if ( pToolBar )
+    {
+        Font aFont= aStyleSettings.GetToolFont();
+        modifyFont( aFont, pToolBar->font() );
+        aStyleSettings.SetToolFont( aFont );
+    }
+
+    // Scroll bar size
+    aStyleSettings.SetScrollBarSize( kapp->style().pixelMetric( QStyle::PM_ScrollBarExtent ) );
+
+    rSettings.SetStyleSettings( aStyleSettings );
+}
+
+/* vim: set tabstop=8 shiftwidth=4: */
Index: vcl/unx/source/gdi/salogl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/salogl.cxx,v
retrieving revision 1.7
retrieving revision 1.11
diff -u -p -u -r1.7 -r1.11
--- vcl/unx/source/gdi/salogl.cxx	15 Apr 2003 16:10:05 -0000	1.7
+++ vcl/unx/source/gdi/salogl.cxx	10 May 2004 15:59:38 -0000	1.11
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALOGL_CXX
-
 #include <salunx.h>
 
 #ifndef _SV_SALDATA_HXX
@@ -71,18 +69,20 @@
 #include <saldisp.hxx>
 #endif
 
-#ifndef _SV_SALOGL_HXX
-#include <salogl.hxx>
+#ifndef _SV_SALOGL_H
+#include <salogl.h>
 #endif
 
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 
+using namespace rtl;
+
 // ------------
 // - Lib-Name -
 // ------------
@@ -97,55 +97,53 @@
 // - Macros -
 // ----------
 
-// NetBSD has neither RTLD_GLOBAL nor RTLD_NOW
-#if defined NETBSD
-#define DLOPEN_MODE 0
-#else
-#define DLOPEN_MODE (RTLD_NOW | RTLD_GLOBAL)
-#endif
-
-
 // -----------------
 // - Statics init. -
 // -----------------
 
 // Members
-GLXContext		SalOpenGL::maGLXContext = 0;
-Display*		SalOpenGL::mpDisplay    = 0;
-XVisualInfo*	SalOpenGL::mpVisualInfo = 0;
-BOOL			SalOpenGL::mbHaveGLVisual = FALSE;
-
-void *      SalOpenGL::mpGLLib    = 0;
-ULONG		SalOpenGL::mnOGLState = OGL_STATE_UNLOADED;
-
-GLXContext (*SalOpenGL::pCreateContext)( Display *, XVisualInfo *, GLXContext, Bool ) = 0;
-void       (*SalOpenGL::pDestroyContext)( Display *, GLXContext ) = 0;
-GLXContext (*SalOpenGL::pGetCurrentContext)( ) = 0;
-Bool       (*SalOpenGL::pMakeCurrent)( Display *, GLXDrawable, GLXContext ) = 0;
-void		(*SalOpenGL::pSwapBuffers)( Display*, GLXDrawable ) = 0;
-int			(*SalOpenGL::pGetConfig)( Display*, XVisualInfo*, int, int* ) = 0;
-void       (*SalOpenGL::pFlush)() = 0;
+GLXContext		X11SalOpenGL::maGLXContext = 0;
+Display*		X11SalOpenGL::mpDisplay    = 0;
+XVisualInfo*	X11SalOpenGL::mpVisualInfo = 0;
+BOOL			X11SalOpenGL::mbHaveGLVisual = FALSE;
+
+#ifdef MACOSX
+oslModule      X11SalOpenGL::mpGLLib    = 0;
+#else
+void *      X11SalOpenGL::mpGLLib    = 0;
+#endif
+
+ULONG		X11SalOpenGL::mnOGLState = OGL_STATE_UNLOADED;
+
+GLXContext (*X11SalOpenGL::pCreateContext)( Display *, XVisualInfo *, GLXContext, Bool ) = 0;
+void       (*X11SalOpenGL::pDestroyContext)( Display *, GLXContext ) = 0;
+GLXContext (*X11SalOpenGL::pGetCurrentContext)( ) = 0;
+Bool       (*X11SalOpenGL::pMakeCurrent)( Display *, GLXDrawable, GLXContext ) = 0;
+void		(*X11SalOpenGL::pSwapBuffers)( Display*, GLXDrawable ) = 0;
+int			(*X11SalOpenGL::pGetConfig)( Display*, XVisualInfo*, int, int* ) = 0;
+void       (*X11SalOpenGL::pFlush)() = 0;
 
 // -------------
-// - SalOpenGL -
+// - X11SalOpenGL -
 // -------------
 
-SalOpenGL::SalOpenGL( SalGraphics* pGraphics )
+X11SalOpenGL::X11SalOpenGL( SalGraphics* pSGraphics )
 {
-	mpDisplay    = pGraphics->maGraphicsData.GetXDisplay();
-	mpVisualInfo = pGraphics->maGraphicsData.GetDisplay()->GetVisual();
-	maDrawable   = pGraphics->maGraphicsData.GetDrawable();
+    X11SalGraphics* pGraphics = static_cast<X11SalGraphics*>(pSGraphics);
+	mpDisplay    = pGraphics->GetXDisplay();
+	mpVisualInfo = pGraphics->GetDisplay()->GetVisual();
+	maDrawable   = pGraphics->GetDrawable();
 }
 
 // ------------------------------------------------------------------------
 
-SalOpenGL::~SalOpenGL()
+X11SalOpenGL::~X11SalOpenGL()
 {
 }
 
 // ------------------------------------------------------------------------
 
-BOOL SalOpenGL::Create()
+bool X11SalOpenGL::IsValid()
 {
 	if( OGL_STATE_UNLOADED == mnOGLState )
 	{
@@ -205,7 +203,7 @@ BOOL SalOpenGL::Create()
 						GLX_DOUBLEBUFFER, &nDoubleBuffer );
 			if( nHaveGL && ! nDoubleBuffer )
 			{
-				SalDisplay* pSalDisplay = GetSalData()->GetDefDisp();
+				SalDisplay* pSalDisplay = GetSalData()->GetDisplay();
 				BOOL bPreviousState =
 					pSalDisplay->GetXLib()->GetIgnoreXErrors();
 				pSalDisplay->GetXLib()->SetIgnoreXErrors( TRUE );
@@ -244,36 +242,23 @@ BOOL SalOpenGL::Create()
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::Release()
+void X11SalOpenGL::Release()
 {
 	ImplFreeLib();
 }
 
 // ------------------------------------------------------------------------
 
-void* SalOpenGL::GetOGLFnc( const String& rFncName )
+void* X11SalOpenGL::GetOGLFnc( const char *pFncName )
 {
-	if( mpGLLib )
-	{
-		return dlsym( mpGLLib, ByteString( rFncName, RTL_TEXTENCODING_ASCII_US ).GetBuffer() );
-	}
-	return NULL;
-}
-
-void* SalOpenGL::GetOGLFnc( char *pFncName )
-{
-	if( mpGLLib )
-	{
-		return dlsym( mpGLLib, pFncName );
-	}
-	return NULL;
+    return resolveSymbol( pFncName );
 }
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::OGLEntry( SalGraphics* pGraphics )
+void X11SalOpenGL::OGLEntry( SalGraphics* pGraphics )
 {
-	GLXDrawable aDrawable = pGraphics->maGraphicsData.GetDrawable();
+	GLXDrawable aDrawable = static_cast<X11SalGraphics*>(pGraphics)->GetDrawable();
 	if( aDrawable != maDrawable )
 	{
 		maDrawable = aDrawable;
@@ -283,19 +268,23 @@ void SalOpenGL::OGLEntry( SalGraphics* p
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::OGLExit( SalGraphics* pGraphics )
+void X11SalOpenGL::OGLExit( SalGraphics* pGraphics )
 {
 }
 
 // ------------------------------------------------------------------------
 
-void SalOpenGL::ImplFreeLib()
+void X11SalOpenGL::ImplFreeLib()
 {
 	if( mpGLLib )
 	{
 		if( maGLXContext && pDestroyContext )
 			pDestroyContext( mpDisplay, maGLXContext );
-		dlclose( mpGLLib );
+#ifdef MACOSX
+		osl_unloadModule( (oslModule) mpGLLib );
+#else
+		osl_unloadModule( mpGLLib );
+#endif
 
 		mpGLLib				= 0;
 		pCreateContext		= 0;
@@ -309,37 +298,55 @@ void SalOpenGL::ImplFreeLib()
 
 // ------------------------------------------------------------------------
 
-BOOL SalOpenGL::ImplInit()
+void* X11SalOpenGL::resolveSymbol( const char* pSymbol )
+{
+    void* pSym = NULL;
+    if( mpGLLib )
+    {
+        OUString aSym = OUString::createFromAscii( pSymbol );
+#ifdef MACOSX
+        pSym = osl_getSymbol( (oslModule) mpGLLib, aSym.pData );
+#else
+        pSym = osl_getSymbol( mpGLLib, aSym.pData );
+#endif
+    }
+    return pSym;
+}
+
+
+BOOL X11SalOpenGL::ImplInit()
 {
 	if( ! mpGLLib )
 	{
 		ByteString sNoGL( getenv( "SAL_NOOPENGL" ) );
-		if( sNoGL.ToLowerAscii() == "true"  ) return FALSE;
-		mpGLLib = dlopen( OGL_LIBNAME, DLOPEN_MODE );
+		if( sNoGL.ToLowerAscii() == "true"  )
+            return FALSE;
+        OUString aLibName( RTL_CONSTASCII_USTRINGPARAM( OGL_LIBNAME ) );
+        mpGLLib = osl_loadModule( aLibName.pData, SAL_LOADMODULE_NOW );
 	}
 	if( ! mpGLLib )
 	{
 #if OSL_DEBUG_LEVEL > 1
-		fprintf( stderr, OGL_LIBNAME "could not be opened: %s\n", dlerror() );
+		fprintf( stderr, OGL_LIBNAME "could not be opened\n" );
 #endif
 		return FALSE;
 	}
 
 	// Internal use
 	pCreateContext     = (GLXContext(*)(Display*,XVisualInfo*,GLXContext,Bool ))
-		GetOGLFnc( "glXCreateContext" );
+		resolveSymbol( "glXCreateContext" );
 	pDestroyContext    = (void(*)(Display*,GLXContext))
-		GetOGLFnc( "glXDestroyContext" );
+		resolveSymbol( "glXDestroyContext" );
 	pGetCurrentContext = (GLXContext(*)())
-		GetOGLFnc( "glXGetCurrentContext" );
+		resolveSymbol( "glXGetCurrentContext" );
 	pMakeCurrent       = (Bool(*)(Display*,GLXDrawable,GLXContext))
-		GetOGLFnc( "glXMakeCurrent" );
+		resolveSymbol( "glXMakeCurrent" );
 	pSwapBuffers=(void(*)(Display*, GLXDrawable))
-		GetOGLFnc( "glXSwapBuffers" );
+		resolveSymbol( "glXSwapBuffers" );
 	pGetConfig = (int(*)(Display*, XVisualInfo*, int, int* ))
-		GetOGLFnc( "glXGetConfig" );
+		resolveSymbol( "glXGetConfig" );
 	pFlush = (void(*)())
-		GetOGLFnc( "glFlush" );
+		resolveSymbol( "glFlush" );
 
 	BOOL bRet = pCreateContext && pDestroyContext && pGetCurrentContext && pMakeCurrent && pSwapBuffers && pGetConfig ? TRUE : FALSE;
 
@@ -351,14 +358,14 @@ BOOL SalOpenGL::ImplInit()
 	return bRet;
 }
 
-void SalOpenGL::StartScene( SalGraphics* pGraphics )
+void X11SalOpenGL::StartScene( SalGraphics* pGraphics )
 {
 	// flush pending operations which otherwise might be drawn
 	// at the wrong time
 	XSync( mpDisplay, False );
 }
 
-void SalOpenGL::StopScene()
+void X11SalOpenGL::StopScene()
 {
 	if( maDrawable )
 	{
@@ -367,7 +374,7 @@ void SalOpenGL::StopScene()
 	}
 }
 
-void SalOpenGL::MakeVisualWeights( Display* pDisplay,
+void X11SalOpenGL::MakeVisualWeights( Display* pDisplay,
 								   XVisualInfo* pInfos,
 								   int *pWeights,
 								   int nVisuals )
Index: vcl/unx/source/gdi/salprnpsp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/salprnpsp.cxx,v
retrieving revision 1.27.40.2
retrieving revision 1.33
diff -u -p -u -r1.27.40.2 -r1.33
--- vcl/unx/source/gdi/salprnpsp.cxx	28 Jan 2004 15:25:52 -0000	1.27.40.2
+++ vcl/unx/source/gdi/salprnpsp.cxx	10 May 2004 15:59:51 -0000	1.33
@@ -79,14 +79,14 @@
 #ifndef _SV_JOBSET_H
 #include <jobset.h>
 #endif
-#ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
 #endif
-#ifndef _SV_SALPRN_HXX
-#include <salprn.hxx>
+#ifndef _SV_SALINST_H
+#include <salinst.h>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALPRN_H
+#include <salprn.h>
 #endif
 #ifndef _SV_PRINT_H
 #include <print.h>
@@ -94,8 +94,11 @@
 #ifndef _SV_SALPTYPE_HXX
 #include <salptype.hxx>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
+#endif
+#ifndef _VCL_PSPGRAPHICS_H
+#include <pspgraphics.h>
 #endif
 #ifndef _SV_SALDATA_HXX
 #include <saldata.hxx>
@@ -211,9 +214,9 @@ static void getPaLib()
 	}
 }
 
-inline PtTo10Mu( int nPoints ) { return (int)((((double)nPoints)*35.27777778)+0.5); }
+inline int PtTo10Mu( int nPoints ) { return (int)((((double)nPoints)*35.27777778)+0.5); }
 
-inline TenMuToPt( int nUnits ) { return (int)((((double)nUnits)/35.27777778)+0.5); }
+inline int TenMuToPt( int nUnits ) { return (int)((((double)nUnits)/35.27777778)+0.5); }
 
 static struct
 {
@@ -433,20 +436,19 @@ static bool createPdf( const String& rTo
 
 // -----------------------------------------------------------------------
 
-SalInfoPrinter* SalInstance::CreateInfoPrinter(
-	SalPrinterQueueInfo*	pQueueInfo,
-	ImplJobSetup*			pJobSetup )
+SalInfoPrinter* X11SalInstance::CreateInfoPrinter( SalPrinterQueueInfo*	pQueueInfo,
+                                                   ImplJobSetup*			pJobSetup )
 {
-    maInstData.mbPrinterInit = true;
+    mbPrinterInit = true;
 	// create and initialize SalInfoPrinter
-	SalInfoPrinter* pPrinter = new SalInfoPrinter;
+	PspSalInfoPrinter* pPrinter = new PspSalInfoPrinter;
 
 	if( pJobSetup )
 	{
 		PrinterInfoManager& rManager( PrinterInfoManager::get() );
 		PrinterInfo aInfo( rManager.getPrinterInfo( pQueueInfo->maPrinterName ) );
-		pPrinter->maPrinterData.m_aJobData = aInfo;
-		pPrinter->maPrinterData.m_aPrinterGfx.Init( pPrinter->maPrinterData.m_aJobData );
+		pPrinter->m_aJobData = aInfo;
+		pPrinter->m_aPrinterGfx.Init( pPrinter->m_aJobData );
 
 		if( pJobSetup->mpDriverData )
 			JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, aInfo );
@@ -463,35 +465,35 @@ SalInfoPrinter* SalInstance::CreateInfoP
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyInfoPrinter( SalInfoPrinter* pPrinter )
+void X11SalInstance::DestroyInfoPrinter( SalInfoPrinter* pPrinter )
 {
 	delete pPrinter;
 }
 
 // -----------------------------------------------------------------------
 
-SalPrinter* SalInstance::CreatePrinter( SalInfoPrinter* pInfoPrinter )
+SalPrinter* X11SalInstance::CreatePrinter( SalInfoPrinter* pInfoPrinter )
 {
-    maInstData.mbPrinterInit = true;
+    mbPrinterInit = true;
 	// create and initialize SalPrinter
-	SalPrinter* pPrinter = new SalPrinter;
-	pPrinter->maPrinterData.m_aJobData = pInfoPrinter->maPrinterData.m_aJobData;
+	PspSalPrinter* pPrinter = new PspSalPrinter;
+	pPrinter->m_aJobData = static_cast<PspSalInfoPrinter*>(pInfoPrinter)->m_aJobData;
 
 	return pPrinter;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DestroyPrinter( SalPrinter* pPrinter )
+void X11SalInstance::DestroyPrinter( SalPrinter* pPrinter )
 {
 	delete pPrinter;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::GetPrinterQueueInfo( ImplPrnQueueList* pList )
+void X11SalInstance::GetPrinterQueueInfo( ImplPrnQueueList* pList )
 {
-    maInstData.mbPrinterInit = true;
+    mbPrinterInit = true;
 	PrinterInfoManager& rManager( PrinterInfoManager::get() );
 	::std::list< OUString > aPrinters;
 	rManager.listPrinters( aPrinters );
@@ -524,56 +526,56 @@ void SalInstance::GetPrinterQueueInfo( I
 
 // -----------------------------------------------------------------------
 
-void SalInstance::DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo )
+void X11SalInstance::DeletePrinterQueueInfo( SalPrinterQueueInfo* pInfo )
 {
 	delete pInfo;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInstance::GetPrinterQueueState( SalPrinterQueueInfo* pInfo )
+void X11SalInstance::GetPrinterQueueState( SalPrinterQueueInfo* pInfo )
 {
-    maInstData.mbPrinterInit = true;
+    mbPrinterInit = true;
 }
 
 // -----------------------------------------------------------------------
 
-String SalInstance::GetDefaultPrinter()
+String X11SalInstance::GetDefaultPrinter()
 {
-    maInstData.mbPrinterInit = true;
+    mbPrinterInit = true;
 	PrinterInfoManager& rManager( PrinterInfoManager::get() );
 	return rManager.getDefaultPrinter();
 }
 
 // =======================================================================
 
-SalInfoPrinter::SalInfoPrinter()
+PspSalInfoPrinter::PspSalInfoPrinter()
 {
-	maPrinterData.m_pGraphics = NULL;
+	m_pGraphics = NULL;
     m_bPapersInit = false;
 }
 
 // -----------------------------------------------------------------------
 
-SalInfoPrinter::~SalInfoPrinter()
+PspSalInfoPrinter::~PspSalInfoPrinter()
 {
-	if( maPrinterData.m_pGraphics )
+	if( m_pGraphics )
 	{
-		delete maPrinterData.m_pGraphics;
-		maPrinterData.m_pGraphics = NULL;
+		delete m_pGraphics;
+		m_pGraphics = NULL;
 	}
 }
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::InitPaperFormats( const ImplJobSetup* pSetupData )
+void PspSalInfoPrinter::InitPaperFormats( const ImplJobSetup* pSetupData )
 {
     m_aPaperFormats.clear();
     m_bPapersInit = true;
 
-    if( maPrinterData.m_aJobData.m_pParser )
+    if( m_aJobData.m_pParser )
     {
-        const PPDKey* pKey = maPrinterData.m_aJobData.m_pParser->getKey( String( RTL_CONSTASCII_USTRINGPARAM( "PageSize" ) ) );
+        const PPDKey* pKey = m_aJobData.m_pParser->getKey( String( RTL_CONSTASCII_USTRINGPARAM( "PageSize" ) ) );
         if( pKey )
         {
             int nValues = pKey->countValues();
@@ -585,7 +587,7 @@ void SalInfoPrinter::InitPaperFormats( c
                 if( ! aInfo.m_aPaperName.Len() )
                     aInfo.m_aPaperName = pValue->m_aOption;
                 int nWidth = 0, nHeight = 0;
-                maPrinterData.m_aJobData.m_pParser->getPaperDimension( pValue->m_aOption, nWidth, nHeight );
+                m_aJobData.m_pParser->getPaperDimension( pValue->m_aOption, nWidth, nHeight );
                 aInfo.m_nPaperWidth = (unsigned long)((PtTo10Mu( nWidth )+50)/100);
                 aInfo.m_nPaperHeight = (unsigned long)((PtTo10Mu( nHeight )+50)/100);
                 m_aPaperFormats.push_back( aInfo );
@@ -596,46 +598,44 @@ void SalInfoPrinter::InitPaperFormats( c
 
 // -----------------------------------------------------------------------
 
-int SalInfoPrinter::GetLandscapeAngle( const ImplJobSetup* pSetupData )
+int PspSalInfoPrinter::GetLandscapeAngle( const ImplJobSetup* pSetupData )
 {
     return 900;
 }
 
 // -----------------------------------------------------------------------
 
-SalGraphics* SalInfoPrinter::GetGraphics()
+SalGraphics* PspSalInfoPrinter::GetGraphics()
 {
 	// return a valid pointer only once
 	// the reasoning behind this is that we could have different
 	// SalGraphics that can run in multiple threads
 	// (future plans)
 	SalGraphics* pRet = NULL;
-	if( ! maPrinterData.m_pGraphics )
+	if( ! m_pGraphics )
 	{
-		maPrinterData.m_pGraphics = new SalGraphics;
-		maPrinterData.m_pGraphics->maGraphicsData.m_pJobData	= &maPrinterData.m_aJobData;
-		maPrinterData.m_pGraphics->maGraphicsData.m_pPrinterGfx	= &maPrinterData.m_aPrinterGfx;
-		maPrinterData.m_pGraphics->maGraphicsData.bPrinter_		= TRUE;
-		pRet = maPrinterData.m_pGraphics;
+		m_pGraphics = new PspGraphics( &m_aJobData, &m_aPrinterGfx );
+        m_pGraphics->SetLayout( 0 );
+		pRet = m_pGraphics;
 	}
 	return pRet;
 }
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::ReleaseGraphics( SalGraphics* pGraphics )
+void PspSalInfoPrinter::ReleaseGraphics( SalGraphics* pGraphics )
 {
-	if( pGraphics == maPrinterData.m_pGraphics )
+	if( pGraphics == m_pGraphics )
 	{
 		delete pGraphics;
-		maPrinterData.m_pGraphics = NULL;
+		m_pGraphics = NULL;
 	}
 	return;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalInfoPrinter::Setup( SalFrame* pFrame, ImplJobSetup* pJobSetup )
+BOOL PspSalInfoPrinter::Setup( SalFrame* pFrame, ImplJobSetup* pJobSetup )
 {
 	if( ! pFrame || ! pJobSetup )
 		return FALSE;
@@ -679,12 +679,12 @@ BOOL SalInfoPrinter::Setup( SalFrame* pF
 // data should be merged into the driver data
 // If pJobSetup->mpDriverData IS NULL, then the driver defaults
 // should be merged into the independent data
-BOOL SalInfoPrinter::SetPrinterData( ImplJobSetup* pJobSetup )
+BOOL PspSalInfoPrinter::SetPrinterData( ImplJobSetup* pJobSetup )
 {
 	if( pJobSetup->mpDriverData )
 		return SetData( ~0, pJobSetup );
 
-	copyJobDataToJobSetup( pJobSetup, maPrinterData.m_aJobData );
+	copyJobDataToJobSetup( pJobSetup, m_aJobData );
 	return TRUE;
 }
 
@@ -694,7 +694,7 @@ BOOL SalInfoPrinter::SetPrinterData( Imp
 // and sets the new independ data in pJobSetup
 // Only the data must be changed, where the bit
 // in nGetDataFlags is set
-BOOL SalInfoPrinter::SetData(
+BOOL PspSalInfoPrinter::SetData(
 	ULONG nSetDataFlags,
 	ImplJobSetup* pJobSetup )
 {
@@ -804,7 +804,7 @@ BOOL SalInfoPrinter::SetData(
 		if( nSetDataFlags & SAL_JOBSET_ORIENTATION )
 			aData.m_eOrientation = pJobSetup->meOrientation == ORIENTATION_LANDSCAPE ? orientation::Landscape : orientation::Portrait;
 
-		maPrinterData.m_aJobData = aData;
+		m_aJobData = aData;
 		copyJobDataToJobSetup( pJobSetup, aData );
 		return TRUE;
 	}
@@ -814,7 +814,7 @@ BOOL SalInfoPrinter::SetData(
 
 // -----------------------------------------------------------------------
 
-void SalInfoPrinter::GetPageInfo(
+void PspSalInfoPrinter::GetPageInfo(
 	const ImplJobSetup* pJobSetup,
 	long& rOutWidth, long& rOutHeight,
 	long& rPageOffX, long& rPageOffY,
@@ -858,7 +858,7 @@ void SalInfoPrinter::GetPageInfo(
 
 // -----------------------------------------------------------------------
 
-ULONG SalInfoPrinter::GetPaperBinCount( const ImplJobSetup* pJobSetup )
+ULONG PspSalInfoPrinter::GetPaperBinCount( const ImplJobSetup* pJobSetup )
 {
 	if( ! pJobSetup )
 		return 0;
@@ -872,7 +872,7 @@ ULONG SalInfoPrinter::GetPaperBinCount( 
 
 // -----------------------------------------------------------------------
 
-String SalInfoPrinter::GetPaperBinName( const ImplJobSetup* pJobSetup, ULONG nPaperBin )
+String PspSalInfoPrinter::GetPaperBinName( const ImplJobSetup* pJobSetup, ULONG nPaperBin )
 {
 	JobData aData;
 	JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, aData );
@@ -896,7 +896,7 @@ String SalInfoPrinter::GetPaperBinName( 
 
 // -----------------------------------------------------------------------
 
-ULONG SalInfoPrinter::GetCapabilities( const ImplJobSetup* pJobSetup, USHORT nType )
+ULONG PspSalInfoPrinter::GetCapabilities( const ImplJobSetup* pJobSetup, USHORT nType )
 {
 	switch( nType )
 	{
@@ -951,13 +951,13 @@ ULONG SalInfoPrinter::GetCapabilities( c
  *	SalPrinter
  */
 
-SalPrinter::SalPrinter()
+PspSalPrinter::PspSalPrinter()
 {
 }
 
 // -----------------------------------------------------------------------
 
-SalPrinter::~SalPrinter()
+PspSalPrinter::~PspSalPrinter()
 {
 }
 
@@ -972,7 +972,7 @@ static String getTmpName()
     return aSys;
 }
 
-BOOL SalPrinter::StartJob(
+BOOL PspSalPrinter::StartJob(
 	const XubString* pFileName,
 	const XubString& rJobName,
 	const XubString& rAppName,
@@ -981,81 +981,81 @@ BOOL SalPrinter::StartJob(
 {
     vcl_sal::PrinterUpdate::jobStarted();
 
-	maPrinterData.m_bFax		= false;
-	maPrinterData.m_bPdf		= false;
-	maPrinterData.m_aFileName	= pFileName ? *pFileName : String();
-	maPrinterData.m_aTmpFile	= String();
-    maPrinterData.m_nCopies		= nCopies;
+	m_bFax		= false;
+	m_bPdf		= false;
+	m_aFileName	= pFileName ? *pFileName : String();
+	m_aTmpFile	= String();
+    m_nCopies		= nCopies;
 
-	JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, maPrinterData.m_aJobData );
-    if( maPrinterData.m_nCopies > 1 )
+	JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, m_aJobData );
+    if( m_nCopies > 1 )
         // in case user did not do anything (m_nCopies=1)
         // take the default from jobsetup
-        maPrinterData.m_aJobData.m_nCopies = maPrinterData.m_nCopies;
+        m_aJobData.m_nCopies = m_nCopies;
 
 	// check wether this printer is configured as fax
     int nMode = 0;
-	const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( maPrinterData.m_aJobData.m_aPrinterName ) );
+	const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( m_aJobData.m_aPrinterName ) );
     sal_Int32 nIndex = 0;
     while( nIndex != -1 )
 	{
 		OUString aToken( rInfo.m_aFeatures.getToken( 0, ',', nIndex ) );
 		if( ! aToken.compareToAscii( "fax", 3 ) )
 		{
-			maPrinterData.m_bFax = true;
-			maPrinterData.m_aTmpFile = getTmpName();
+			m_bFax = true;
+			m_aTmpFile = getTmpName();
             nMode = S_IRUSR | S_IWUSR;
 
 			::std::hash_map< ::rtl::OUString, ::rtl::OUString, ::rtl::OUStringHash >::const_iterator it;
 			it = pJobSetup->maValueMap.find( ::rtl::OUString::createFromAscii( "FAX#" ) );
 			if( it != pJobSetup->maValueMap.end() )
-				maPrinterData.m_aFaxNr = it->second;
+				m_aFaxNr = it->second;
 
             sal_Int32 nPos = 0;
-			maPrinterData.m_bSwallowFaxNo = ! aToken.getToken( 1, '=', nPos ).compareToAscii( "swallow", 7 ) ? true : false;
+			m_bSwallowFaxNo = ! aToken.getToken( 1, '=', nPos ).compareToAscii( "swallow", 7 ) ? true : false;
 
 			break;
 		}
 		if( ! aToken.compareToAscii( "pdf=", 4 ) )
 		{
-			maPrinterData.m_bPdf = true;
-			maPrinterData.m_aTmpFile = getTmpName();
+			m_bPdf = true;
+			m_aTmpFile = getTmpName();
             nMode = S_IRUSR | S_IWUSR;
 
-			if( ! maPrinterData.m_aFileName.Len() )
+			if( ! m_aFileName.Len() )
 			{
-				maPrinterData.m_aFileName = getPdfDir( rInfo );
-				maPrinterData.m_aFileName.Append( '/' );
-				maPrinterData.m_aFileName.Append( rJobName );
-				maPrinterData.m_aFileName.AppendAscii( ".pdf" );
+				m_aFileName = getPdfDir( rInfo );
+				m_aFileName.Append( '/' );
+				m_aFileName.Append( rJobName );
+				m_aFileName.AppendAscii( ".pdf" );
 			}
 			break;
 		}
 	}
-	maPrinterData.m_aPrinterGfx.Init( maPrinterData.m_aJobData );
-	return maPrinterData.m_aPrintJob.StartJob( maPrinterData.m_aTmpFile.Len() ? maPrinterData.m_aTmpFile : maPrinterData.m_aFileName, nMode, rJobName, rAppName, maPrinterData.m_aJobData, &maPrinterData.m_aPrinterGfx ) ? TRUE : FALSE;
+	m_aPrinterGfx.Init( m_aJobData );
+	return m_aPrintJob.StartJob( m_aTmpFile.Len() ? m_aTmpFile : m_aFileName, nMode, rJobName, rAppName, m_aJobData, &m_aPrinterGfx ) ? TRUE : FALSE;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::EndJob()
+BOOL PspSalPrinter::EndJob()
 {
-	BOOL bSuccess = maPrinterData.m_aPrintJob.EndJob();
+	BOOL bSuccess = m_aPrintJob.EndJob();
 
 	if( bSuccess )
 	{
 		// check for fax
-		if( maPrinterData.m_bFax )
+		if( m_bFax )
 		{
 
-			const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( maPrinterData.m_aJobData.m_aPrinterName ) );
+			const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( m_aJobData.m_aPrinterName ) );
 			// sendAFax removes the file after use
-			bSuccess = sendAFax( maPrinterData.m_aFaxNr, maPrinterData.m_aTmpFile, rInfo.m_aCommand );
+			bSuccess = sendAFax( m_aFaxNr, m_aTmpFile, rInfo.m_aCommand );
 		}
-		else if( maPrinterData.m_bPdf )
+		else if( m_bPdf )
 		{
-			const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( maPrinterData.m_aJobData.m_aPrinterName ) );
-			bSuccess = createPdf( maPrinterData.m_aFileName, maPrinterData.m_aTmpFile, rInfo.m_aCommand );
+			const PrinterInfo& rInfo( PrinterInfoManager::get().getPrinterInfo( m_aJobData.m_aPrinterName ) );
+			bSuccess = createPdf( m_aFileName, m_aTmpFile, rInfo.m_aCommand );
 		}
 	}
     vcl_sal::PrinterUpdate::jobEnded();
@@ -1064,47 +1064,43 @@ BOOL SalPrinter::EndJob()
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::AbortJob()
+BOOL PspSalPrinter::AbortJob()
 {
-    BOOL bAbort = maPrinterData.m_aPrintJob.AbortJob() ? TRUE : FALSE;
+    BOOL bAbort = m_aPrintJob.AbortJob() ? TRUE : FALSE;
     vcl_sal::PrinterUpdate::jobEnded();
 	return bAbort;
 }
 
 // -----------------------------------------------------------------------
 
-SalGraphics* SalPrinter::StartPage( ImplJobSetup* pJobSetup, BOOL bNewJobData )
+SalGraphics* PspSalPrinter::StartPage( ImplJobSetup* pJobSetup, BOOL bNewJobData )
 {
-	JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, maPrinterData.m_aJobData );
-	maPrinterData.m_pGraphics = new SalGraphics();
-	maPrinterData.m_pGraphics->maGraphicsData.m_pJobData		= &maPrinterData.m_aJobData;
-	maPrinterData.m_pGraphics->maGraphicsData.m_pPrinterGfx		= &maPrinterData.m_aPrinterGfx;
-	maPrinterData.m_pGraphics->maGraphicsData.bPrinter_			= true;
-	maPrinterData.m_pGraphics->maGraphicsData.m_pPhoneNr		= maPrinterData.m_bFax ? &maPrinterData.m_aFaxNr : NULL;
-	maPrinterData.m_pGraphics->maGraphicsData.m_bSwallowFaxNo	= maPrinterData.m_bSwallowFaxNo;
-    if( maPrinterData.m_nCopies > 1 )
+	JobData::constructFromStreamBuffer( pJobSetup->mpDriverData, pJobSetup->mnDriverDataLen, m_aJobData );
+	m_pGraphics = new PspGraphics( &m_aJobData, &m_aPrinterGfx, m_bFax ? &m_aFaxNr : NULL, m_bSwallowFaxNo  );
+    m_pGraphics->SetLayout( 0 );
+    if( m_nCopies > 1 )
         // in case user did not do anything (m_nCopies=1)
         // take the default from jobsetup
-        maPrinterData.m_aJobData.m_nCopies = maPrinterData.m_nCopies;
+        m_aJobData.m_nCopies = m_nCopies;
 
-	maPrinterData.m_aPrintJob.StartPage( maPrinterData.m_aJobData, bNewJobData ? sal_True : sal_False );
-	maPrinterData.m_aPrinterGfx.Init( maPrinterData.m_aPrintJob );
+	m_aPrintJob.StartPage( m_aJobData, bNewJobData ? sal_True : sal_False );
+	m_aPrinterGfx.Init( m_aPrintJob );
 
-	return maPrinterData.m_pGraphics;
+	return m_pGraphics;
 }
 
 // -----------------------------------------------------------------------
 
-BOOL SalPrinter::EndPage()
+BOOL PspSalPrinter::EndPage()
 {
-	sal_Bool bResult = maPrinterData.m_aPrintJob.EndPage();
-	maPrinterData.m_aPrinterGfx.Clear();
+	sal_Bool bResult = m_aPrintJob.EndPage();
+	m_aPrinterGfx.Clear();
 	return bResult ? TRUE : FALSE;
 }
 
 // -----------------------------------------------------------------------
 
-ULONG SalPrinter::GetErrorCode()
+ULONG PspSalPrinter::GetErrorCode()
 {
 	return 0;
 }
@@ -1116,39 +1112,16 @@ ULONG SalPrinter::GetErrorCode()
 Timer* vcl_sal::PrinterUpdate::pPrinterUpdateTimer = NULL;
 int vcl_sal::PrinterUpdate::nActiveJobs = 0;
 
-struct PrnFrameCall
-{
-    SalFrame* pFrame;
-    SalFrameDelData aDelData;
-
-    PrnFrameCall() : pFrame( NULL ) {}
-};
-
 void vcl_sal::PrinterUpdate::doUpdate()
 {
     ::psp::PrinterInfoManager& rManager( ::psp::PrinterInfoManager::get() );
     if( rManager.checkPrintersChanged() )
     {
-        std::list< PrnFrameCall > aList;
-        SalFrame* pFrame = GetSalData()->pFirstFrame_;
-        while( pFrame )
-        {
-            aList.push_back( PrnFrameCall() );
-            aList.back().pFrame = pFrame;
-            pFrame->maFrameData.RegisterDeleteData( &aList.back().aDelData );
-            pFrame = pFrame->maFrameData.GetNextFrame();
-        }
-
-        while( aList.begin() != aList.end() )
-        {
-            if( ! aList.front().aDelData.IsDeleted() )
-            {
-                aList.front().pFrame->maFrameData.Call( SALEVENT_PRINTERCHANGED, NULL );
-                if( !aList.front().aDelData.IsDeleted() )
-                    aList.front().pFrame->maFrameData.UnregisterDeleteData( &aList.front().aDelData );
-            }
-            aList.pop_front();
-        }
+        SalDisplay* pDisp = GetSalData()->GetDisplay();
+        const std::list< SalFrame* >& rList = pDisp->getFrames();
+        for( std::list< SalFrame* >::const_iterator it = rList.begin();
+             it != rList.end(); ++it )
+            pDisp->SendInternalEvent( *it, NULL, SALEVENT_PRINTERCHANGED );
     }
 }
 
Index: vcl/unx/source/gdi/salvd.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/salvd.cxx,v
retrieving revision 1.4
retrieving revision 1.8
diff -u -p -u -r1.4 -r1.8
--- vcl/unx/source/gdi/salvd.cxx	27 Mar 2003 17:58:52 -0000	1.4
+++ vcl/unx/source/gdi/salvd.cxx	10 May 2004 16:00:04 -0000	1.8
@@ -59,9 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALVD_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #include <salunx.h>
 
 #ifndef _SV_SALDATA_HXX
@@ -73,53 +70,53 @@
 #ifndef _SV_SALINST_HXX
 #include <salinst.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
-#ifndef _SV_SALVD_HXX
-#include <salvd.hxx>
+#ifndef _SV_SALVD_H
+#include <salvd.h>
 #endif
 
 // -=-= SalInstance =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalVirtualDevice* SalInstance::CreateVirtualDevice( SalGraphics* pGraphics,
-													long nDX, long nDY,
-													USHORT nBitCount )
+SalVirtualDevice* X11SalInstance::CreateVirtualDevice( SalGraphics* pGraphics,
+                                                       long nDX, long nDY,
+                                                       USHORT nBitCount )
 {
-	SalVirtualDevice *pVDev = new SalVirtualDevice();
+	X11SalVirtualDevice *pVDev = new X11SalVirtualDevice();
 	if( !nBitCount && pGraphics )
 		nBitCount = pGraphics->GetBitCount();
-	if( !pVDev->maVirDevData.Init( pGraphics->maGraphicsData.GetDisplay(),
-								   nDX, nDY, nBitCount ) )
+	if( !pVDev->Init( GetSalData()->GetDisplay(), nDX, nDY, nBitCount ) )
 	{
 		delete pVDev;
 		return NULL;
 	}
 
-	pVDev->maVirDevData.InitGraphics( pVDev, pGraphics );
+	pVDev->InitGraphics( pVDev );
 	return pVDev;
 }
 
-void SalInstance::DestroyVirtualDevice( SalVirtualDevice* pDevice )
-{ delete pDevice; }
+void X11SalInstance::DestroyVirtualDevice( SalVirtualDevice* pDevice )
+{
+    delete pDevice;
+}
 
 // -=-= SalGraphicsData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphicsData::Init( SalVirtualDevice *pDevice,
-								  SalGraphics      *pGraphics )
+void X11SalGraphics::Init( X11SalVirtualDevice *pDevice )
 {
-	SalDisplay *pDisplay  = pDevice->maVirDevData.GetDisplay();
+	SalDisplay *pDisplay  = pDevice->GetDisplay();
 	
 	int nVisualDepth = pDisplay->GetColormap().GetVisual()->GetDepth();
-	int nDeviceDepth = pDevice->maVirDevData.GetDepth();
+	int nDeviceDepth = pDevice->GetDepth();
 
 	if( nDeviceDepth == nVisualDepth )
-		xColormap_ = &pDisplay->GetColormap();
+		m_pColormap = &pDisplay->GetColormap();
 	else 
 	if( nDeviceDepth == 1 )
-		xColormap_ = new SalColormap();
+		m_pDeleteColormap = m_pColormap = new SalColormap();
 			 
-	hDrawable_   = pDevice->maVirDevData.GetDrawable();
+	hDrawable_   = pDevice->GetDrawable();
     m_pVDev		 = pDevice;
     m_pFrame	 = NULL;
 
@@ -133,12 +130,12 @@ void SalGraphicsData::Init( SalVirtualDe
 
 // -=-= SalVirDevData / SalVirtualDevice -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-BOOL SalVirDevData::Init( SalDisplay *pDisplay,
-								long nDX, long nDY,
+BOOL X11SalVirtualDevice::Init( SalDisplay *pDisplay,
+                                long nDX, long nDY,
 								USHORT nBitCount )
 {
-	pDisplay_               = pDisplay;
-	pGraphics_              = new SalGraphicsLayout();
+    pDisplay_               = pDisplay;
+    pGraphics_				= new X11SalGraphics();
     pGraphics_->SetLayout( 0 ); // by default no! mirroring for VirtualDevices, can be enabled with EnableRTL()
 	nDX_                    = nDX;
 	nDY_                    = nDY;
@@ -149,11 +146,13 @@ BOOL SalVirDevData::Init( SalDisplay *pD
 									 nDX_, nDY_,
 									 GetDepth() );
 
+    pGraphics_->Init( this );
+
 	return hDrawable_ != None ? TRUE : FALSE;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline SalVirDevData::SalVirDevData()
+X11SalVirtualDevice::X11SalVirtualDevice()
 {
 	pDisplay_               = (SalDisplay*)ILLEGAL_POINTER;
 	pGraphics_              = NULL;
@@ -164,78 +163,61 @@ inline SalVirDevData::SalVirDevData()
 	bGraphics_              = FALSE;
 }
 
-SalVirtualDevice::SalVirtualDevice() {}
-
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline SalVirDevData::~SalVirDevData()
+X11SalVirtualDevice::~X11SalVirtualDevice()
 {
 	if( pGraphics_ )
-	{
-		pGraphics_->maGraphicsData.DeInit();
 		delete pGraphics_;
-	}
 
 	if( GetDrawable() )
 		XFreePixmap( GetXDisplay(), GetDrawable() );
 }
 
-SalVirtualDevice::~SalVirtualDevice()
-{}
-
-// -=-= #defines -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-#define _GetDrawable()   maVirDevData.GetDrawable()
-#define _GetDisplay()    maVirDevData.GetDisplay()
-#define _GetXDisplay()   maVirDevData.GetXDisplay()
-#define _GetDepth()      maVirDevData.nDepth_
-
-// -=-= SalVirtualDevice -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalGraphics* SalVirtualDevice::GetGraphics()
+SalGraphics* X11SalVirtualDevice::GetGraphics()
 {
-	if( maVirDevData.bGraphics_ )
+	if( bGraphics_ )
 		return NULL;
 
-	if( maVirDevData.pGraphics_ )
-		maVirDevData.bGraphics_ = TRUE;
+	if( pGraphics_ )
+		bGraphics_ = TRUE;
 
-	return maVirDevData.pGraphics_;
+	return pGraphics_;
 }
 
-void SalVirtualDevice::ReleaseGraphics( SalGraphics* )
-{ maVirDevData.bGraphics_ = FALSE; }
+void X11SalVirtualDevice::ReleaseGraphics( SalGraphics* )
+{ bGraphics_ = FALSE; }
 
-BOOL SalVirtualDevice::SetSize( long nDX, long nDY )
+BOOL X11SalVirtualDevice::SetSize( long nDX, long nDY )
 {
 	if( !nDX ) nDX = 1;
 	if( !nDY ) nDY = 1;
 
-	Pixmap h = XCreatePixmap( _GetXDisplay(),
-							  maVirDevData.pDisplay_->GetDrawable(),
-							  nDX, nDY, _GetDepth() );
+	Pixmap h = XCreatePixmap( GetXDisplay(),
+							  pDisplay_->GetDrawable(),
+							  nDX, nDY, nDepth_ );
 
 	if( !h )
 	{
-		if( !_GetDrawable() )
+		if( !GetDrawable() )
 		{
-			maVirDevData.hDrawable_ = XCreatePixmap( _GetXDisplay(),
-										 maVirDevData.pDisplay_->GetDrawable(),
-										 1, 1, _GetDepth() );
-			maVirDevData.nDX_ = 1;
-			maVirDevData.nDY_ = 1;
+			hDrawable_ = XCreatePixmap( GetXDisplay(),
+                                        pDisplay_->GetDrawable(),
+                                        1, 1, nDepth_ );
+			nDX_ = 1;
+			nDY_ = 1;
 		}
 		return FALSE;
 	}
 
-	if( _GetDrawable() )
-		XFreePixmap( _GetXDisplay(), _GetDrawable() );
-	maVirDevData.hDrawable_ = h;
+	if( GetDrawable() )
+		XFreePixmap( GetXDisplay(), GetDrawable() );
+	hDrawable_ = h;
 
-	maVirDevData.nDX_ = nDX;
-	maVirDevData.nDY_ = nDY;
+	nDX_ = nDX;
+	nDY_ = nDY;
 
-	if( maVirDevData.pGraphics_ )
-		maVirDevData.InitGraphics( this, maVirDevData.pGraphics_ );
+	if( pGraphics_ )
+		InitGraphics( this );
 	
 	return TRUE;
 }
Index: vcl/unx/source/gdi/xfont.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/xfont.cxx,v
retrieving revision 1.29.82.2
retrieving revision 1.36
diff -u -p -u -r1.29.82.2 -r1.36
--- vcl/unx/source/gdi/xfont.cxx	26 Jan 2004 17:26:20 -0000	1.29.82.2
+++ vcl/unx/source/gdi/xfont.cxx	17 Jun 2004 12:29:36 -0000	1.36
@@ -76,8 +76,11 @@
 #ifndef _SV_OUTFONT_HXX
 #include <outfont.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
+#endif
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
 
 #if OSL_DEBUG_LEVEL > 1
@@ -122,8 +125,8 @@ ExtendedFontStruct::ExtendedFontStruct( 
 		maPixelSize( rPixelSize ),
 		mfXScale(1.0), mfYScale(1.0),
 		mbVertical( bVertical ),
-		mpXlfd( pXlfd ),
 		mnCachedEncoding( RTL_TEXTENCODING_DONTKNOW ),
+		mpXlfd( pXlfd ),
         mpRangeCodes(NULL),
         mnRangeCount(-1)
 {
@@ -434,7 +438,7 @@ ExtendedFontStruct::GetDefaultWidth()
 // is compatible with iso8859-X at least in the range to 0x7f
 sal_Size
 ExtendedFontStruct::GetCharWidth8( sal_Unicode nFrom, sal_Unicode nTo,
-		long* pWidthArray, rtl_TextEncoding nEncoding )
+		sal_Int32* pWidthArray, rtl_TextEncoding nEncoding )
 {
 	if ( !(nFrom <= nTo) )
 		return 0;
@@ -477,7 +481,7 @@ ExtendedFontStruct::GetCharWidth8( sal_U
 // Handle utf16 encoded fonts, which do not require conversion
 sal_Size
 ExtendedFontStruct::GetCharWidthUTF16( sal_Unicode nFrom, sal_Unicode nTo,
-		long* pWidthArray )
+		sal_Int32* pWidthArray )
 {
 	if ( !(nFrom <= nTo) )
 		return 0;
@@ -523,7 +527,7 @@ ExtendedFontStruct::GetCharWidthUTF16( s
 // font in fontstruct, 8 and 16 bit fonts are handled the same way
 sal_Size
 ExtendedFontStruct::GetCharWidth16( sal_Unicode nFrom, sal_Unicode nTo,
-    long* pWidthArray, ExtendedFontStruct *pFallback )
+    sal_Int32* pWidthArray, ExtendedFontStruct *pFallback )
 {
     if ( nFrom > nTo )
         return 0;
@@ -608,8 +612,8 @@ ExtendedFontStruct::GetCharWidth16( sal_
 }
 
 sal_Size
-ExtendedFontStruct::GetCharWidth( sal_Unicode cChar, long *pPhysicalWidth,
-    long *pLogicalWidth )
+ExtendedFontStruct::GetCharWidth( sal_Unicode cChar, sal_Int32 *pPhysicalWidth,
+    sal_Int32 *pLogicalWidth )
 {
     sal_Size nConverted = 0;
 
@@ -707,7 +711,9 @@ bool X11FontLayout::LayoutText( ImplLayo
 {
     Point aNewPos( 0, 0 );
     bool bRightToLeft;
-    for( int nCharPos = -1; rArgs.GetNextPos( &nCharPos, &bRightToLeft ); )
+    int nCharPos;
+
+    for( nCharPos = -1; rArgs.GetNextPos( &nCharPos, &bRightToLeft ); )
     {
         sal_Unicode cChar = rArgs.mpStr[ nCharPos ];
         if( bRightToLeft )
@@ -722,7 +728,7 @@ bool X11FontLayout::LayoutText( ImplLayo
                 nGlyphIndex = 0; // drop NotDef fallback glyphs
         }
 
-        long nPhysGlyphWidth, nLogGlyphWidth;
+        sal_Int32 nPhysGlyphWidth, nLogGlyphWidth;
         mrFont.GetCharWidth( cChar, &nPhysGlyphWidth, &nLogGlyphWidth );
         int nGlyphFlags = (nPhysGlyphWidth > 0) ? 0 : GlyphItem::IS_IN_CLUSTER;
         if( bRightToLeft )
@@ -753,7 +759,7 @@ void X11FontLayout::DrawText( SalGraphic
     int nMaxGlyphs = GetOrientation() ? 1 : MAXGLYPHS;
 
     Point aPos;
-    long aGlyphAry[ MAXGLYPHS ];
+    sal_Int32 aGlyphAry[ MAXGLYPHS ];
     sal_Unicode pStr[ MAXGLYPHS ];
     for( int nStart=0;;)
     {
@@ -764,7 +770,7 @@ void X11FontLayout::DrawText( SalGraphic
         for( int i = 0; i < nGlyphCount; ++i )
             pStr[ i ] = aGlyphAry[ i ] & GF_IDXMASK;
 
-        rSalGraphics.maGraphicsData.DrawStringUCS2MB( mrFont, aPos, pStr, nGlyphCount );
+        static_cast<X11SalGraphics&>(rSalGraphics).DrawStringUCS2MB( mrFont, aPos, pStr, nGlyphCount );
     }
 }
 
Index: vcl/unx/source/gdi/xlfd_attr.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/xlfd_attr.cxx,v
retrieving revision 1.14
retrieving revision 1.15
diff -u -p -u -r1.14 -r1.15
--- vcl/unx/source/gdi/xlfd_attr.cxx	12 Jun 2003 08:19:39 -0000	1.14
+++ vcl/unx/source/gdi/xlfd_attr.cxx	6 Jan 2004 14:41:47 -0000	1.15
@@ -120,10 +120,12 @@ Attribute::Compare( const char *p, int n
 const rtl::OString&
 Attribute::GetKey ()
 {
+    static rtl::OString aEmptyStr;
+
 	if (mpKeyName != NULL)
 		return *mpKeyName;
 	if (mnLength == NULL)
-		return rtl::OString();
+		return aEmptyStr;
 
 	sal_Char* pBuffer = (sal_Char*)alloca (mnLength);
 
Index: vcl/unx/source/gdi/xlfd_extd.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/xlfd_extd.cxx,v
retrieving revision 1.16.46.2
retrieving revision 1.21
diff -u -p -u -r1.16.46.2 -r1.21
--- vcl/unx/source/gdi/xlfd_extd.cxx	26 Jan 2004 17:26:45 -0000	1.16.46.2
+++ vcl/unx/source/gdi/xlfd_extd.cxx	30 Mar 2004 13:43:43 -0000	1.21
@@ -652,7 +652,7 @@ ScalableBitmapXlfd::ToString( ByteString
 	rString += '-';
 	rString += ByteString::CreateFromInt32( rInfo.mnResolutionY );
 	rString += '-';
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-0";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -673,10 +673,10 @@ ScalableBitmapXlfd::ToString( ByteString
 
 	rString += "-*-";
 	char pTmp[256];
-	sprintf( pTmp, pMatricsString, nPixelSize, nPixelSize );
+	snprintf( pTmp, sizeof(pTmp), pMatricsString, nPixelSize, nPixelSize );
 	rString += pTmp;
 	rString += "-*-*-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-*";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -697,10 +697,10 @@ BitmapXlfd::ToString( ByteString &rStrin
 
 	rString += "-*-";
 	char pTmp[256];
-	sprintf( pTmp, pMatricsString, nPixelSize, nPixelSize );
+	snprintf( pTmp, sizeof(pTmp), pMatricsString, nPixelSize, nPixelSize );
 	rString += pTmp;
 	rString += "-*-*-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-*";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -774,28 +774,9 @@ BitmapXlfd::ToString( ByteString &rStrin
 	AppendAttribute( mpFactory->RetrieveAddstyle(rInfo.mnAddstyle), rString );
 	rString += '-';   
 	rString += ByteString::CreateFromInt32( mnPixelSize );
-	#ifdef __notdef__
-		// since mnPointSize is not asked when comparing two bitmap font xlfd
-		// it may differ (and it does) for two fonts with same pixelsize
-		rString += "-";
-		rString += ByteString::CreateFromInt32( mnPointSize );
-		rString += "-";
-		rString += ByteString::CreateFromInt32( rInfo.mnResolutionX );
-		rString += '-';
-		rString += ByteString::CreateFromInt32( rInfo.mnResolutionY );
-		rString += '-';
-	#else
-		rString += "-*-*-*-";
-	#endif /* __notdef__ */
-
-	rString += rInfo.mcSpacing;
-
-	#ifdef __notdef__
-		rString += '-';
-		rString += ByteString::CreateFromInt32( mnAverageWidth );
-	#else
-		rString += "-*";
-	#endif
+	rString += "-*-*-*-";
+	rString += static_cast< char >(rInfo.mcSpacing);
+	rString += "-*";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
 }
@@ -836,7 +817,7 @@ ScalableXlfd::ToString( ByteString &rStr
 	rString += '-';
 	rString += ByteString::CreateFromInt32( nPixelSize );
 	rString += "-0-0-0-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-0";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -857,10 +838,10 @@ ScalableXlfd::ToString( ByteString &rStr
 
 	rString += "-*-";
 	char pTmp[256];
-	sprintf( pTmp, pMatricsString, nPixelSize, nPixelSize );
+	snprintf( pTmp, sizeof(pTmp), pMatricsString, nPixelSize, nPixelSize );
 	rString += pTmp;
 	rString += "-*-*-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-*";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -1018,7 +999,7 @@ VirtualXlfd::ToString( ByteString &rStri
 	rString += '-';
 	rString += ByteString::CreateFromInt32( nPixelSize );
 	rString += "-0-0-0-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-0";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
@@ -1045,10 +1026,10 @@ VirtualXlfd::ToString( ByteString &rStri
 
 	rString += "-*-";
 	char pTmp[256];
-	sprintf( pTmp, pMatricsString, nPixelSize, nPixelSize );
+	snprintf( pTmp, sizeof(pTmp), pMatricsString, nPixelSize, nPixelSize );
 	rString += pTmp;
 	rString += "-*-*-";
-	rString += rInfo.mcSpacing;
+	rString += static_cast< char >(rInfo.mcSpacing);
 	rString += "-*";
 
 	AppendAttribute( mpFactory->RetrieveCharset(rInfo.mnCharset), rString );
Index: vcl/unx/source/gdi/xlfd_extd.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/xlfd_extd.hxx,v
retrieving revision 1.9.120.2
retrieving revision 1.12
diff -u -p -u -r1.9.120.2 -r1.12
--- vcl/unx/source/gdi/xlfd_extd.hxx	26 Jan 2004 17:27:37 -0000	1.9.120.2
+++ vcl/unx/source/gdi/xlfd_extd.hxx	17 Mar 2004 10:07:56 -0000	1.12
@@ -93,8 +93,8 @@ class XlfdStorage;
 
 class ExtendedXlfd {
 
-	friend VirtualXlfd;
-	friend XlfdStorage;
+	friend class VirtualXlfd;
+	friend class XlfdStorage;
 
 	public:
 			 				ExtendedXlfd();
Index: vcl/unx/source/gdi/xlfd_smpl.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/xlfd_smpl.cxx,v
retrieving revision 1.5
retrieving revision 1.7
diff -u -p -u -r1.5 -r1.7
--- vcl/unx/source/gdi/xlfd_smpl.cxx	15 Apr 2003 16:11:23 -0000	1.5
+++ vcl/unx/source/gdi/xlfd_smpl.cxx	18 May 2004 13:49:24 -0000	1.7
@@ -282,12 +282,12 @@ Xlfd::ToString( ByteString &rString ) co
 	AppendAttribute( mpFactory->RetrieveSetwidth(mnSetwidth), rString );
 	AppendAttribute( mpFactory->RetrieveAddstyle(mnAddstyle), rString );
 
-	rString += '-'; rString += ByteString::CreateFromInt32( mnPixelSize );
-	rString += '-'; rString += ByteString::CreateFromInt32( mnPointSize );
-	rString += '-'; rString += ByteString::CreateFromInt32( mnResolutionX );
-	rString += '-'; rString += ByteString::CreateFromInt32( mnResolutionY );
-	rString += '-'; rString += mcSpacing;
-	rString += '-'; rString += ByteString::CreateFromInt32( mnAverageWidth );
+	rString.Append("-"); rString.Append( ByteString::CreateFromInt32( mnPixelSize ) );
+	rString.Append("-"); rString.Append( ByteString::CreateFromInt32( mnPointSize ) );
+	rString.Append("-"); rString.Append( ByteString::CreateFromInt32( mnResolutionX ) );
+	rString.Append("-"); rString.Append( ByteString::CreateFromInt32( mnResolutionY ) );
+	rString.Append("-"); rString.Append( (char)mcSpacing );
+	rString.Append("-"); rString.Append( ByteString::CreateFromInt32( mnAverageWidth ) );
 
 	AppendAttribute( mpFactory->RetrieveCharset(mnCharset), rString );
 
Index: vcl/unx/source/gdi/xprintext.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/xprintext.cxx,v
retrieving revision 1.6
retrieving revision 1.8
diff -u -p -u -r1.6 -r1.8
--- vcl/unx/source/gdi/xprintext.cxx	15 Apr 2003 16:11:42 -0000	1.6
+++ vcl/unx/source/gdi/xprintext.cxx	30 Mar 2004 13:43:56 -0000	1.8
@@ -59,8 +59,6 @@
  *
  ************************************************************************/
 
-#define _VCL_XPRINT_EXTENSION_CXX
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -432,7 +430,7 @@ SalPrinter::StartJob(
 	XpSelectInput (pDisplay, aContext, XPPrintMask);
 
 	char pJobName[ 64 ];
-	sprintf (pJobName, "%s.job-name: XPrint%d", pPrinterName, getpid() );
+	snprintf (pJobName, sizeof(pJobName), "%s.job-name: XPrint%d", pPrinterName, getpid() );
 
 	XpStartJob( pDisplay, XPSpool );
 
Index: vcl/unx/source/inc/salcursors.h
===================================================================
RCS file: vcl/unx/source/inc/salcursors.h
diff -N vcl/unx/source/inc/salcursors.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/source/inc/salcursors.h	20 Feb 2004 09:03:34 -0000	1.2
@@ -0,0 +1,196 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include "nodrop_curs.h"
+#include "nodrop_mask.h"
+#include "wait_curs.h"
+#include "wait_mask.h"
+#include "hsplit_curs.h"
+#include "hsplit_mask.h"
+#include "vsplit_curs.h"
+#include "vsplit_mask.h"
+#include "neswsize_curs.h"
+#include "neswsize_mask.h"
+#include "nwsesize_curs.h"
+#include "nwsesize_mask.h"
+#include "magnify_curs.h"
+#include "magnify_mask.h"
+#include "rotate_curs.h"
+#include "rotate_mask.h"
+#include "hshear_curs.h"
+#include "hshear_mask.h"
+#include "vshear_curs.h"
+#include "vshear_mask.h"
+#include "drawline_curs.h"
+#include "drawline_mask.h"
+#include "drawrect_curs.h"
+#include "drawrect_mask.h"
+#include "drawpolygon_curs.h"
+#include "drawpolygon_mask.h"
+#include "drawbezier_curs.h"
+#include "drawbezier_mask.h"
+#include "drawarc_curs.h"
+#include "drawarc_mask.h"
+#include "drawpie_curs.h"
+#include "drawpie_mask.h"
+#include "drawcirclecut_curs.h"
+#include "drawcirclecut_mask.h"
+#include "drawellipse_curs.h"
+#include "drawellipse_mask.h"
+#include "drawconnect_curs.h"
+#include "drawconnect_mask.h"
+#include "drawtext_curs.h"
+#include "drawtext_mask.h"
+#include "mirror_curs.h"
+#include "mirror_mask.h"
+#include "crook_curs.h"
+#include "crook_mask.h"
+#include "crop_curs.h"
+#include "crop_mask.h"
+#include "move_curs.h"
+#include "move_mask.h"
+#include "movepoint_curs.h"
+#include "movepoint_mask.h"
+#include "movebezierweight_curs.h"
+#include "movebezierweight_mask.h"
+#include "drawfreehand_curs.h"
+#include "drawfreehand_mask.h"
+#include "drawcaption_curs.h"
+#include "drawcaption_mask.h"
+#include "movedata_curs.h"
+#include "movedata_mask.h"
+#include "copydata_curs.h"
+#include "copydata_mask.h"
+#include "linkdata_curs.h"
+#include "linkdata_mask.h"
+#include "movedlnk_curs.h"
+#include "movedlnk_mask.h"
+#include "copydlnk_curs.h"
+#include "copydlnk_mask.h"
+#include "movefile_curs.h"
+#include "movefile_mask.h"
+#include "copyfile_curs.h"
+#include "copyfile_mask.h"
+#include "linkfile_curs.h"
+#include "linkfile_mask.h"
+#include "moveflnk_curs.h"
+#include "moveflnk_mask.h"
+#include "copyflnk_curs.h"
+#include "copyflnk_mask.h"
+#include "movefiles_curs.h"
+#include "movefiles_mask.h"
+#include "copyfiles_curs.h"
+#include "copyfiles_mask.h"
+
+#include "chart_curs.h"
+#include "chart_mask.h"
+#include "detective_curs.h"
+#include "detective_mask.h"
+#include "pivotcol_curs.h"
+#include "pivotcol_mask.h"
+#include "pivotfld_curs.h"
+#include "pivotfld_mask.h"
+#include "pivotrow_curs.h"
+#include "pivotrow_mask.h"
+#include "pivotdel_curs.h"
+#include "pivotdel_mask.h"
+
+#include "chain_curs.h"
+#include "chain_mask.h"
+#include "chainnot_curs.h"
+#include "chainnot_mask.h"
+
+#include "timemove_curs.h"
+#include "timemove_mask.h"
+#include "timesize_curs.h"
+#include "timesize_mask.h"
+
+#include "ase_curs.h"
+#include "ase_mask.h"
+#include "asn_curs.h"
+#include "asn_mask.h"
+#include "asne_curs.h"
+#include "asne_mask.h"
+#include "asns_curs.h"
+#include "asns_mask.h"
+#include "asnswe_curs.h"
+#include "asnswe_mask.h"
+#include "asnw_curs.h"
+#include "asnw_mask.h"
+#include "ass_curs.h"
+#include "ass_mask.h"
+#include "asse_curs.h"
+#include "asse_mask.h"
+#include "assw_curs.h"
+#include "assw_mask.h"
+#include "asw_curs.h"
+#include "asw_mask.h"
+#include "aswe_curs.h"
+#include "aswe_mask.h"
+#include "null_curs.h"
+#include "null_mask.h"
+
+#include "airbrush_curs.h"
+#include "airbrush_mask.h" 
+#include "fill_curs.h"
+#include "fill_mask.h"
+#include "vertcurs_curs.h" 
+#include "vertcurs_mask.h" 
Index: vcl/unx/source/window/FWS.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/window/FWS.cxx,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -u -r1.2 -r1.3
--- vcl/unx/source/window/FWS.cxx	15 Apr 2003 16:11:53 -0000	1.2
+++ vcl/unx/source/window/FWS.cxx	30 Mar 2004 13:44:17 -0000	1.3
@@ -116,7 +116,7 @@ WMSupportsFWS (Display *display, int scr
 	unsigned long   propItems;
 	unsigned long   propBytesAfter;
 	unsigned char   *propData;
-	char            propName[30];
+	char            propName[64];
 
 	FWS_CLIENT         = XInternAtom(display, "_SUN_FWS_CLIENT",         False);
 	FWS_COMM_WINDOW    = XInternAtom(display, "_SUN_FWS_COMM_WINDOW",    False);
@@ -133,7 +133,7 @@ WMSupportsFWS (Display *display, int scr
 	WM_PROTOCOLS       = XInternAtom(display, "WM_PROTOCOLS",            False);
 	WM_CHANGE_STATE    = XInternAtom(display, "WM_CHANGE_STATE",         False);
 
-	sprintf (propName, "_SUN_FWS_NEXT_ICON_%d", screen);
+	snprintf (propName, sizeof(propName), "_SUN_FWS_NEXT_ICON_%d", screen);
 	fwsIconAtom        = XInternAtom(display, propName, False);
 
 	if (XGetWindowProperty (display, DefaultRootWindow (display),
Index: vcl/unx/source/window/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/window/makefile.mk,v
retrieving revision 1.2
retrieving revision 1.5
diff -u -p -u -r1.2 -r1.5
--- vcl/unx/source/window/makefile.mk	27 Aug 2002 17:49:59 -0000	1.2
+++ vcl/unx/source/window/makefile.mk	10 May 2004 16:00:26 -0000	1.5
@@ -83,9 +83,11 @@ dummy:
 
 .ELSE		# "$(GUIBASE)"!="unx"
 
-.IF "$(remote)"
 SLOFILES=	\
-		$(SLO)/FWS.obj $(SLO)/salframe.obj $(SLO)/salobj.obj
+		$(SLO)/FWS.obj $(SLO)/salframe.obj $(SLO)/salobj.obj $(SLO)/salmenu.obj
+
+.IF "$(WITH_WIDGETSET)"!=""
+CFLAGS+= $(WIDGETSET_CFLAGS)
 .ENDIF
 
 .ENDIF		# "$(GUIBASE)"!="unx"
Index: vcl/unx/source/window/salframe.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/window/salframe.cxx,v
retrieving revision 1.163.46.5.22.1
retrieving revision 1.179
diff -u -p -u -r1.163.46.5.22.1 -r1.179
--- vcl/unx/source/window/salframe.cxx	9 May 2004 15:15:35 -0000	1.163.46.5.22.1
+++ vcl/unx/source/window/salframe.cxx	17 Jun 2004 12:29:52 -0000	1.179
@@ -58,9 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALFRAME_CXX
-
-// -=-= #includes =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 #include <string.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -89,11 +87,11 @@
 #ifndef _SV_SALINST_HXX
 #include <salinst.hxx>
 #endif
-#ifndef _SV_SALGDI_HXX
-#include <salgdi.hxx>
+#ifndef _SV_SALGDI_H
+#include <salgdi.h>
 #endif
-#ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#ifndef _SV_SALFRAME_H
+#include <salframe.h>
 #endif
 #ifndef _SV_KEYCOES_HXX
 #include <keycodes.hxx>
@@ -116,13 +114,11 @@
 #ifndef _VCL_WMADAPTOR_HXX_
 #include <wmadaptor.hxx>
 #endif
-#ifndef _USE_PRINT_EXTENSION_
 #ifndef _PSPRINT_PRINTERINFOMANAGER_HXX_
 #include <psprint/printerinfomanager.hxx>
 #endif
-#ifndef _SV_SALPRN_HXX
-#include <salprn.hxx>
-#endif
+#ifndef _SV_SALPRN_H
+#include <salprn.h>
 #endif
 #ifndef _SV_FLOATWIN_HXX
 #include <floatwin.hxx>
@@ -132,8 +128,8 @@
 #endif
 #include <svapp.hxx>
 
-#ifndef _SV_SALBMP_HXX
-#include <salbmp.hxx>
+#ifndef _SV_SALBMP_H
+#include <salbmp.h>
 #endif
 
 #ifndef _SAL_I18N_INPUTCONTEXT_HXX
@@ -177,24 +173,15 @@ using namespace vcl;
 								| ColormapChangeMask
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-#define _GetDrawable()		maFrameData.GetDrawable()
-#define _GetDisplay()		maFrameData.pDisplay_
-#define _GetXDisplay()		maFrameData.GetXDisplay()
-#define _GetColormap()		maFrameData.GetColormap()
-#define _GetPaintRegion()	maFrameData.GetPaintRegion()
-#define _IsMapped() 		maFrameData.bMapped_
 
 static XLIB_Window	hPresentationWindow = None, hPresFocusWindow = None;
 static ::std::list< XLIB_Window > aPresentationReparentList;
 static int			nVisibleFloats		= 0;
 
-SalFrame* SalFrameData::s_pSaveYourselfFrame = NULL;
+X11SalFrame* X11SalFrame::s_pSaveYourselfFrame = NULL;
 
 // -=-= C++ statics =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-static long sal_CallbackDummy( void*, SalFrame*, USHORT, const void* )
-{ return 0; }
-
 static void doReparentPresentationDialogues( SalDisplay* pDisplay )
 {
     BOOL bIgnore = pDisplay->GetXLib()->GetIgnoreXErrors();
@@ -255,10 +242,10 @@ static char* getFrameResName()
         {
             const char* pEnv = getenv( "RESOURCE_NAME" );
             if( pEnv && *pEnv )
-                strncpy( pResName, pEnv, sizeof(pResName)-1 );
+                snprintf( pResName, sizeof(pResName), "%s", pEnv );
         }
         if( !*pResName )
-            strcpy( pResName, "VCLSalFrame" );
+            snprintf( pResName, sizeof(pResName), "%s", "VCLSalFrame" );
     }
     return pResName;
 }
@@ -277,67 +264,18 @@ static char* getFrameClassName()
 
         if( aProduct.getLength() )
         {
-            strncpy( pClassName, ::rtl::OUStringToOString( aProduct, osl_getThreadTextEncoding() ).getStr(), sizeof( pClassName )-1 );
+            snprintf( pClassName, sizeof(pClassName), "%s", ::rtl::OUStringToOString( aProduct, osl_getThreadTextEncoding() ).getStr() );
         }
         else
-            strcpy( pClassName, "VCLSalFrame" );
+            snprintf( pClassName, sizeof(pClassName), "%s", "VCLSalFrame" );
     }
     return pClassName;
 }
 
-// -=-= SalInstance =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-SalFrame *SalInstance::CreateFrame( SalFrame *pParent,
-										  ULONG nSalFrameStyle )
-{
-	SalFrame *pFrame = new SalFrame;
-
-	pFrame->maFrameData.mpParent = pParent;
-	if( pParent )
-		pParent->maFrameData.maChildren.push_back( pFrame );
-	pFrame->maFrameData.Init( nSalFrameStyle );
-
-    // initialize system settings update
-    DtIntegrator* pIntegrator = DtIntegrator::CreateDtIntegrator( pFrame );
-    pIntegrator->Acquire();
-
-	return pFrame;
-}
-
-SalFrame* SalInstance::CreateChildFrame( SystemParentData* pParentData, ULONG nStyle )
-{
-	SalFrame* pFrame = new SalFrame;
-	pFrame->maFrameData.mpParent = NULL;
-	pFrame->maFrameData.Init( nStyle, pParentData );
-
-	return pFrame;
-}
-
-void SalInstance::DestroyFrame( SalFrame* pFrame )
-{
-	delete pFrame;
-}
-
-// -=-= SalGraphics / SalGraphicsData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalGraphicsData::Init( SalFrame *pFrame )
-{
-	xColormap_		= &pFrame->_GetColormap();
-	hDrawable_		= pFrame->_GetDrawable();
-
-	bWindow_		= TRUE;
-    m_pFrame		= pFrame;
-    m_pVDev			= NULL;
-
-	nPenPixel_		= GetPixel( nPenColor_ );
-	nTextPixel_ 	= GetPixel( nTextColor_ );
-	nBrushPixel_	= GetPixel( nBrushColor_ );
-}
-
-// -=-= SalFrame / SalFrameData =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+// -=-= SalFrame / X11SalFrame =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-bool SalFrameData::IsOverrideRedirect() const
+bool X11SalFrame::IsOverrideRedirect() const
 {
     return
         ((nStyle_ & SAL_FRAME_STYLE_INTRO) && !pDisplay_->getWMAdaptor()->supportsSplash())
@@ -346,7 +284,7 @@ bool SalFrameData::IsOverrideRedirect() 
         ;
 }
 
-bool SalFrameData::IsFloatGrabWindow() const
+bool X11SalFrame::IsFloatGrabWindow() const
 {
     static const char* pDisableGrab = getenv( "SAL_DISABLE_FLOATGRAB" );
 
@@ -357,7 +295,7 @@ bool SalFrameData::IsFloatGrabWindow() c
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalFrameData::Init( ULONG nSalFrameStyle, SystemParentData* pParentData )
+void X11SalFrame::Init( ULONG nSalFrameStyle, SystemParentData* pParentData )
 {
 	nStyle_ 	= nSalFrameStyle;
 	XWMHints Hints;
@@ -394,7 +332,7 @@ void SalFrameData::Init( ULONG nSalFrame
 	{
         // plugin parent may be killed unexpectedly by
         // plugging process; ignore XErrors in that case
-        GetDisplay()->GetXLib()->SetIgnoreXErrors( TRUE );
+        GetDisplay()->setHaveSystemChildFrame();
 
 		nStyle_ |= SAL_FRAME_STYLE_CHILD;
         Attributes.override_redirect = True;
@@ -430,11 +368,12 @@ void SalFrameData::Init( ULONG nSalFrame
 
 		// check if this is really one of our own frames
 		// do not change the input mask in that case
-		SalFrame* pFrame = GetSalData()->pFirstFrame_;
-		while( pFrame && mhForeignParent != pFrame->maFrameData.GetWindow() )
-			pFrame = pFrame->maFrameData.pNextFrame_;
+        const std::list< SalFrame* >& rFrames = GetDisplay()->getFrames();
+        std::list< SalFrame* >::const_iterator it = rFrames.begin();
+		while( it != rFrames.end() && mhForeignParent != static_cast<X11SalFrame*>(*it)->GetWindow() )
+            ++it;
 
-		if( ! pFrame )
+		if( it == rFrames.end() )
 		{
 			XSelectInput( GetDisplay()->GetDisplay(), mhForeignParent, StructureNotifyMask | FocusChangeMask );
 			XSelectInput( GetDisplay()->GetDisplay(), mhShellWindow, StructureNotifyMask | FocusChangeMask );
@@ -464,17 +403,24 @@ void SalFrameData::Init( ULONG nSalFrame
         if( ! mpParent )
         {
             // find the last document window (if any)
-            SalFrame* pFrame = pNextFrame_;
-            while( pFrame &&
-                   ( pFrame->maFrameData.mpParent
-                     || pFrame->maFrameData.mbFullScreen
-                     || ! ( pFrame->maFrameData.nStyle_ & SAL_FRAME_STYLE_SIZEABLE )
-                     || ! pFrame->GetUnmirroredGeometry().nWidth
-                     || ! pFrame->GetUnmirroredGeometry().nHeight
-                     )
-                   )
-                pFrame = pFrame->maFrameData.pNextFrame_;
-            if( pFrame )
+            X11SalFrame* pFrame = NULL;
+            const std::list< SalFrame* >& rFrames = GetDisplay()->getFrames();
+            std::list< SalFrame* >::const_iterator it = rFrames.begin();
+            while( it != rFrames.end() )
+            {
+                pFrame = static_cast< X11SalFrame* >(*it);
+                if( ! ( pFrame->mpParent
+                        || pFrame->mbFullScreen
+                        || ! ( pFrame->nStyle_ & SAL_FRAME_STYLE_SIZEABLE )
+                        || ! pFrame->GetUnmirroredGeometry().nWidth
+                        || ! pFrame->GetUnmirroredGeometry().nHeight
+                        )
+                    )
+                    break;
+                ++it;
+            }
+            
+            if( it != rFrames.end() )
             {
                 // set a document position and size
                 // the first frame gets positioned by the window manager
@@ -526,7 +472,7 @@ void SalFrameData::Init( ULONG nSalFrame
         if( IsOverrideRedirect() )
             Attributes.override_redirect = True;
         // default icon
-        if( SelectAppIconPixmap( pDisplay_, mpParent ? mpParent->maFrameData.mnIconID : 1, 32,
+        if( SelectAppIconPixmap( pDisplay_, mpParent ? mpParent->mnIconID : 1, 32,
                                  Hints.icon_pixmap, Hints.icon_mask ))
         {
             Hints.flags		|= IconPixmapHint;
@@ -535,28 +481,28 @@ void SalFrameData::Init( ULONG nSalFrame
         }
 
 		Hints.flags			|= WindowGroupHint;
-        SalFrame* pFrame = pFrame_;
-        while( pFrame->maFrameData.mpParent )
-            pFrame = pFrame->maFrameData.mpParent;
-		Hints.window_group	= pFrame->maFrameData.GetShellWindow();
+        X11SalFrame* pFrame = this;
+        while( pFrame->mpParent )
+            pFrame = pFrame->mpParent;
+		Hints.window_group	= pFrame->GetShellWindow();
     }
 
     mhWindow = XCreateWindow( GetXDisplay(),
-                               aFrameParent,
-                               x, y,
-                               w, h,
-                               0,
-                               pVis->GetDepth(),
-                               InputOutput,
-                               pVis->GetVisual(),
-                               nAttrMask,
-                               &Attributes );
+                              aFrameParent,
+                              x, y,
+                              w, h,
+                              0,
+                              pVis->GetDepth(),
+                              InputOutput,
+                              pVis->GetVisual(),
+                              nAttrMask,
+                              &Attributes );
     mhShellWindow = pParentData ? mhShellWindow : mhWindow;
 
-    pFrame_->maGeometry.nX		= x;
-    pFrame_->maGeometry.nY		= y;
-    pFrame_->maGeometry.nWidth	= w;
-    pFrame_->maGeometry.nHeight	= h;
+    maGeometry.nX		= x;
+    maGeometry.nY		= y;
+    maGeometry.nWidth	= w;
+    maGeometry.nHeight	= h;
 
     XSync( GetXDisplay(), False );
 
@@ -571,7 +517,7 @@ void SalFrameData::Init( ULONG nSalFrame
         {
             // at all times have only one frame with SaveYourself
             a[n++] = pDisplay_->getWMAdaptor()->getAtom( WMAdaptor::WM_SAVE_YOURSELF );
-            s_pSaveYourselfFrame = pFrame_;
+            s_pSaveYourselfFrame = this;
         }
 		XSetWMProtocols( GetXDisplay(), GetShellWindow(), a, n );
 
@@ -634,34 +580,35 @@ void SalFrameData::Init( ULONG nSalFrame
             eType = WMAdaptor::windowType_Utility;
 
         GetDisplay()->getWMAdaptor()->
-            setFrameTypeAndDecoration( pFrame_,
+            setFrameTypeAndDecoration( this,
                                        eType,
                                        nDecoFlags,
                                        hPresentationWindow ? NULL : mpParent );
 
 	    if( nStyle_ & SAL_FRAME_STYLE_DEFAULT )
-		pDisplay_->getWMAdaptor()->maximizeFrame( pFrame_, true, true );
+		pDisplay_->getWMAdaptor()->maximizeFrame( this, true, true );
 	}
 
 	// Pointer
-	pFrame_->SetPointer( POINTER_ARROW );
+	SetPointer( POINTER_ARROW );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline SalFrameData::SalFrameData( SalFrame *pFrame )
+X11SalFrame::X11SalFrame( SalFrame *pParent, ULONG nSalFrameStyle, SystemParentData* pSystemParent )
 {
 	SalData* pSalData = GetSalData();
 
-	// insert frame in framelist
-	pNextFrame_ 				= pSalData->pFirstFrame_;
-	pSalData->pFirstFrame_		= pFrame;
-	pFrame_ 					= pFrame;
+    // initialize frame geometry
+    memset( &maGeometry, 0, sizeof(maGeometry) );
+
+    mpParent					= static_cast< X11SalFrame* >( pParent );
+
     mbTransientForRoot			= false;
 
-	pProc_						= sal_CallbackDummy;
-	pInst_						= (void*)ILLEGAL_POINTER;
+	pDisplay_					= pSalData->GetDisplay();
+	// insert frame in framelist
+    pDisplay_->registerFrame( this );
 
-	pDisplay_					= pSalData->GetCurDisp();
     mhWindow					= None;
     mhShellWindow				= None;
     mhStackingWindow			= None;
@@ -702,10 +649,10 @@ inline SalFrameData::SalFrameData( SalFr
     mbDeleteInputContext		= false;
 	mbInputFocus				= False;
 
-	maResizeTimer.SetTimeoutHdl( LINK( this, SalFrameData, HandleResizeTimer ) );
+	maResizeTimer.SetTimeoutHdl( LINK( this, X11SalFrame, HandleResizeTimer ) );
 	maResizeTimer.SetTimeout( 50 );
 
-    maAlwaysOnTopRaiseTimer.SetTimeoutHdl( LINK( this, SalFrameData, HandleAlwaysOnTopRaise ) );
+    maAlwaysOnTopRaiseTimer.SetTimeoutHdl( LINK( this, X11SalFrame, HandleAlwaysOnTopRaise ) );
     maAlwaysOnTopRaiseTimer.SetTimeout( 100 );
 
     mpDeleteData                = NULL;
@@ -718,46 +665,72 @@ inline SalFrameData::SalFrameData( SalFr
     mbFullScreen				= false;
     mbMoved						= false;
     mbSized						= false;
-    mbWasGraphicsPaint			= false;
 
     mnIconID					= 0; // ICON_DEFAULT
-}
 
-SalFrame::SalFrame() : maFrameData( this )
-{
-    memset( &maGeometry, 0, sizeof(maGeometry) );
+	if( mpParent )
+		mpParent->maChildren.push_back( this );
+
+	Init( nSalFrameStyle, pSystemParent );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalFrameData::passOnSaveYourSelf()
+void X11SalFrame::passOnSaveYourSelf()
 {
-    if( pFrame_ == s_pSaveYourselfFrame )
+    if( this == s_pSaveYourselfFrame )
     {
         SalData* pSalData = GetSalData();
 
         // pass on SaveYourself
-        SalFrame* pFrame = pSalData->pFirstFrame_;
-        while( pFrame && ( ( pFrame->maFrameData.nStyle_ & (SAL_FRAME_STYLE_FLOAT|SAL_FRAME_STYLE_CHILD) ) || pFrame->maFrameData.mpParent  ) )
-            pFrame = pFrame->maFrameData.GetNextFrame();
-        s_pSaveYourselfFrame = pFrame;
-        if( pFrame )
+        X11SalFrame* pFrame = NULL;
+        const std::list< SalFrame* >& rFrames = GetDisplay()->getFrames();
+        std::list< SalFrame* >::const_iterator it = rFrames.begin();
+        while( it != rFrames.end() )
+        {
+            pFrame = static_cast< X11SalFrame* >(*it);
+            if( ! (pFrame->nStyle_ & (SAL_FRAME_STYLE_FLOAT|SAL_FRAME_STYLE_CHILD) || pFrame->mpParent ) )
+                break;
+            ++it;    
+        }
+        
+        s_pSaveYourselfFrame = (it != rFrames.end() ) ? pFrame : NULL;
+        if( s_pSaveYourselfFrame )
         {
             Atom a[4];
             int  n = 0;
             a[n++] = pDisplay_->getWMAdaptor()->getAtom( WMAdaptor::WM_DELETE_WINDOW );
             a[n++] = pDisplay_->getWMAdaptor()->getAtom( WMAdaptor::WM_SAVE_YOURSELF );
-            XSetWMProtocols( GetXDisplay(), pFrame->maFrameData.GetShellWindow(), a, n );
+            XSetWMProtocols( GetXDisplay(), s_pSaveYourselfFrame->GetShellWindow(), a, n );
         }
     }
 }
 
-inline SalFrameData::~SalFrameData()
+X11SalFrame::~X11SalFrame()
 {
+    if( mhStackingWindow )
+        aPresentationReparentList.remove( mhStackingWindow );
+
+	// remove from parent's list
+	if( mpParent )
+		mpParent->maChildren.remove( this );
+
+    // deregister on SalDisplay
+    pDisplay_->deregisterFrame( this );
+
+	// unselect all events, some may be still in the queue anyway
+	XSelectInput( GetXDisplay(), GetShellWindow(), 0 );
+	XSelectInput( GetXDisplay(), GetWindow(), 0 );
+
+	ShowFullScreen( FALSE );
+
+	if( bMapped_ )
+		Show( FALSE );
+
     if( mpInputContext )
     {
-        mpInputContext->UnsetICFocus( pFrame_ );
-        mpInputContext->Unmap( pFrame_ );
+        mpInputContext->UnsetICFocus( this );
+        mpInputContext->Unmap( this );
         if( mbDeleteInputContext )
             delete mpInputContext;
     }
@@ -772,82 +745,53 @@ inline SalFrameData::~SalFrameData()
 
 	if( pGraphics_ )
 	{
-		stderr0( "SalFrameData::~SalFrameData pGraphics_\n" );
-		pGraphics_->maGraphicsData.DeInit();
+		pGraphics_->DeInit();
 		delete pGraphics_;
 	}
 
 	if( pFreeGraphics_ )
 	{
-		pFreeGraphics_->maGraphicsData.DeInit();
+		pFreeGraphics_->DeInit();
 		delete pFreeGraphics_;
 	}
 
-    XDestroyWindow( GetXDisplay(), mhWindow );
-
-	SalData* pSalData = GetSalData();
 
-	if( pFrame_ == pSalData->pFirstFrame_ )
-		pSalData->pFirstFrame_ = GetNextFrame();
-	else
-	{
-		SalFrameData *pTemp = &pSalData->pFirstFrame_->maFrameData;
-		while( pTemp->GetNextFrame() != pFrame_ )
-			pTemp = &pTemp->GetNextFrame()->maFrameData;
+    XDestroyWindow( GetXDisplay(), mhWindow );
 
-		pTemp->pNextFrame_ = GetNextFrame();
-	}
     /*
-     *  check if there is only the status frame is left
+     *  check if there is only the status frame left
      *  if so, free it
      */
     SalFrame* pStatusFrame = I18NStatus::get().getStatusFrame();
+    std::list< SalFrame* >::const_iterator sit = GetDisplay()->getFrames().begin();
     if( pStatusFrame
-        && pSalData->pFirstFrame_ == pStatusFrame
-        && pSalData->pFirstFrame_->maFrameData.GetNextFrame() == NULL )
-        ::vcl::I18NStatus::free();
+        && *sit == pStatusFrame
+        && ++sit == GetDisplay()->getFrames().end() )
+        vcl::I18NStatus::free();
 
     passOnSaveYourSelf();
 }
 
-SalFrame::~SalFrame()
-{
-    if( maFrameData.mhStackingWindow )
-        aPresentationReparentList.remove( maFrameData.mhStackingWindow );
-	// aus papis child liste entfernen
-	if( maFrameData.mpParent )
-		maFrameData.mpParent->maFrameData.maChildren.remove( this );
-	// einige kommen trotzdem immer noch durch
-	XSelectInput( _GetXDisplay(), maFrameData.GetShellWindow(), 0 );
-	XSelectInput( _GetXDisplay(), maFrameData.GetWindow(), 0 );
-
-	ShowFullScreen( FALSE );
-
-	if( _IsMapped() )
-		Show( FALSE );
-}
-
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-// irgendwann auf Liste umstellen
 
-const SystemChildData* SalFrame::GetSystemData() const
+const SystemChildData* X11SalFrame::GetSystemData() const
 {
-	SalFrame *pFrame = const_cast<SalFrame*>(this);
-	pFrame->maFrameData.maSystemChildData.nSize 		= sizeof( SystemChildData );
-	pFrame->maFrameData.maSystemChildData.pDisplay		= _GetXDisplay();
-	pFrame->maFrameData.maSystemChildData.aWindow		= pFrame->maFrameData.GetWindow();
-	pFrame->maFrameData.maSystemChildData.pSalFrame 	= pFrame;
-	pFrame->maFrameData.maSystemChildData.pWidget		= NULL;
-	pFrame->maFrameData.maSystemChildData.pVisual		= _GetDisplay()->GetVisual()->GetVisual();
-	pFrame->maFrameData.maSystemChildData.nDepth		= _GetDisplay()->GetVisual()->GetDepth();
-	pFrame->maFrameData.maSystemChildData.aColormap		= _GetDisplay()->GetColormap().GetXColormap();
-	pFrame->maFrameData.maSystemChildData.pAppContext	= NULL;
-	pFrame->maFrameData.maSystemChildData.aShellWindow	= pFrame->maFrameData.GetShellWindow();
-	pFrame->maFrameData.maSystemChildData.pShellWidget	= NULL;
-	return &maFrameData.maSystemChildData;
+	X11SalFrame *pFrame = const_cast<X11SalFrame*>(this);
+	pFrame->maSystemChildData.nSize 		= sizeof( SystemChildData );
+	pFrame->maSystemChildData.pDisplay		= GetXDisplay();
+	pFrame->maSystemChildData.aWindow		= pFrame->GetWindow();
+	pFrame->maSystemChildData.pSalFrame 	= pFrame;
+	pFrame->maSystemChildData.pWidget		= NULL;
+	pFrame->maSystemChildData.pVisual		= GetDisplay()->GetVisual()->GetVisual();
+	pFrame->maSystemChildData.nDepth		= GetDisplay()->GetVisual()->GetDepth();
+	pFrame->maSystemChildData.aColormap		= GetDisplay()->GetColormap().GetXColormap();
+	pFrame->maSystemChildData.pAppContext	= NULL;
+	pFrame->maSystemChildData.aShellWindow	= pFrame->GetShellWindow();
+	pFrame->maSystemChildData.pShellWidget	= NULL;
+	return &maSystemChildData;
 }
 
-SalGraphics *SalFrameData::GetGraphics()
+SalGraphics *X11SalFrame::GetGraphics()
 {
 	if( pGraphics_ )
 		return NULL;
@@ -859,50 +803,46 @@ SalGraphics *SalFrameData::GetGraphics()
 	}
 	else
 	{
-		pGraphics_ = new SalGraphicsLayout;
-		pGraphics_->maGraphicsData.Init( pFrame_ );
+		pGraphics_ = new X11SalGraphics();
+		pGraphics_->Init( this, GetWindow() );
 	}
 
 	return pGraphics_;
 }
 
-SalGraphics *SalFrame::GetGraphics()
-{ return maFrameData.GetGraphics(); }
-
-void SalFrame::ReleaseGraphics( SalGraphics *pGraphics )
+void X11SalFrame::ReleaseGraphics( SalGraphics *pGraphics )
 {
-	if( pGraphics != maFrameData.pGraphics_ )
-	{
-		stderr0( "SalFrame::ReleaseGraphics pGraphics!=pGraphics_" );
+    DBG_ASSERT( pGraphics == pGraphics_, "SalFrame::ReleaseGraphics pGraphics!=pGraphics_" );
+
+	if( pGraphics != pGraphics_ )
 		return;
-	}
 
-	maFrameData.pFreeGraphics_	= pGraphics;
-	maFrameData.pGraphics_		= NULL;
+	pFreeGraphics_	= pGraphics_;
+	pGraphics_		= NULL;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalFrame::Enable( BOOL bEnable )
+void X11SalFrame::Enable( BOOL bEnable )
 {
 	// NYI: enable/disable frame
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalFrame::SetIcon( USHORT nIcon )
+void X11SalFrame::SetIcon( USHORT nIcon )
 {
-    if ( !( maFrameData.nStyle_ & (SAL_FRAME_STYLE_CHILD|SAL_FRAME_STYLE_FLOAT) ) )
+    if ( !( nStyle_ & (SAL_FRAME_STYLE_CHILD|SAL_FRAME_STYLE_FLOAT) ) )
     {
-        maFrameData.mnIconID = nIcon;
+        mnIconID = nIcon;
 
         XIconSize *pIconSize = NULL;
         int nSizes = 0;
         int iconSize = 32;
-        if ( XGetIconSizes( _GetXDisplay(), _GetDisplay()->GetRootWindow(), &pIconSize, &nSizes ) )
+        if ( XGetIconSizes( GetXDisplay(), GetDisplay()->GetRootWindow(), &pIconSize, &nSizes ) )
         {
 #if OSL_DEBUG_LEVEL > 1
-            fprintf(stderr, "SalFrame::SetIcon(): found %d IconSizes:\n", nSizes);
+            fprintf(stderr, "X11SalFrame::SetIcon(): found %d IconSizes:\n", nSizes);
 #endif
 
             const int ourLargestIconSize = 48;
@@ -941,7 +881,7 @@ void SalFrame::SetIcon( USHORT nIcon )
                // the max icon size from |XGetIconSizes()|.  Provide a
                // better icon size default value, in case our window manager
                // is olwm/olvwm.
-               const String& rWM( maFrameData.pDisplay_->getWMAdaptor()->getWindowManagerName() );
+               const String& rWM( pDisplay_->getWMAdaptor()->getWindowManagerName() );
 
                if ( rWM.EqualsAscii( "Olwm" ) )
                    iconSize = 48;
@@ -951,7 +891,7 @@ void SalFrame::SetIcon( USHORT nIcon )
         }
         else
         {
-            const String& rWM( maFrameData.pDisplay_->getWMAdaptor()->getWindowManagerName() );
+            const String& rWM( pDisplay_->getWMAdaptor()->getWindowManagerName() );
             if( rWM.EqualsAscii( "KWin" ) )			// assume KDE is running
                 iconSize = 16;
             static bool bGnomeIconSize = false;
@@ -960,12 +900,12 @@ void SalFrame::SetIcon( USHORT nIcon )
             {
                 bGnomeChecked=true;
                 int nCount = 0;
-                Atom* pProps = XListProperties( _GetXDisplay(),
-                                                _GetDisplay()->GetRootWindow(),
+                Atom* pProps = XListProperties( GetXDisplay(),
+                                                GetDisplay()->GetRootWindow(),
                                                 &nCount );
                 for( int i = 0; i < nCount && !bGnomeIconSize; i++ )
                  {
-                    char* pName = XGetAtomName( _GetXDisplay(), pProps[i] );
+                    char* pName = XGetAtomName( GetXDisplay(), pProps[i] );
                     if( !strcmp( pName, "GNOME_PANEL_DESKTOP_AREA" ) )
                         bGnomeIconSize = true;
                     if( pName )
@@ -980,7 +920,7 @@ void SalFrame::SetIcon( USHORT nIcon )
 
         XWMHints Hints;
         Hints.flags = 0;
-		XWMHints *pHints = XGetWMHints( _GetXDisplay(), maFrameData.GetShellWindow() );
+		XWMHints *pHints = XGetWMHints( GetXDisplay(), GetShellWindow() );
         if( pHints )
         {
             memcpy(&Hints, pHints, sizeof( XWMHints ));
@@ -988,12 +928,12 @@ void SalFrame::SetIcon( USHORT nIcon )
         }
         pHints = &Hints;
 
-		BOOL bOk = SelectAppIconPixmap( maFrameData.GetDisplay(), nIcon, iconSize,
+		BOOL bOk = SelectAppIconPixmap( GetDisplay(), nIcon, iconSize,
                 pHints->icon_pixmap, pHints->icon_mask );
         if ( !bOk )
         {
             // load default icon (0)
-		    bOk = SelectAppIconPixmap( maFrameData.GetDisplay(), 0, iconSize,
+		    bOk = SelectAppIconPixmap( GetDisplay(), 0, iconSize,
                 pHints->icon_pixmap, pHints->icon_mask );
         }
 		if( bOk )
@@ -1002,29 +942,29 @@ void SalFrame::SetIcon( USHORT nIcon )
 		    if( pHints->icon_mask )
 			    pHints->flags |= IconMaskHint;
 
-		    XSetWMHints( _GetXDisplay(), maFrameData.GetShellWindow(), pHints );
+		    XSetWMHints( GetXDisplay(), GetShellWindow(), pHints );
         }
 	}
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalFrame::SetMinClientSize( long nWidth, long nHeight )
+void X11SalFrame::SetMinClientSize( long nWidth, long nHeight )
 {
-	if( maFrameData.GetShellWindow() )
+	if( GetShellWindow() )
 	{
         XSizeHints* pHints = XAllocSizeHints();
         long nSupplied = 0;
-        XGetWMNormalHints( _GetXDisplay(),
-                           maFrameData.GetShellWindow(),
+        XGetWMNormalHints( GetXDisplay(),
+                           GetShellWindow(),
                            pHints,
                            &nSupplied
                            );
         pHints->min_width	= nWidth;
         pHints->min_height	= nHeight;
         pHints->flags |= PMinSize;
-        XSetWMNormalHints( _GetXDisplay(),
-                           maFrameData.GetShellWindow(),
+        XSetWMNormalHints( GetXDisplay(),
+                           GetShellWindow(),
                            pHints );
         XFree( pHints );
 	}
@@ -1032,28 +972,29 @@ void SalFrame::SetMinClientSize( long nW
 
 // Show + Pos (x,y,z) + Size (width,height)
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrame::Show( BOOL bVisible, BOOL /*bNoActivate*/ )
+void X11SalFrame::Show( BOOL bVisible, BOOL /*bNoActivate*/ )
 {
-    if( ( bVisible && maFrameData.bMapped_ )
-        || ( !bVisible && !maFrameData.bMapped_ ) )
+    if( ( bVisible && bMapped_ )
+        || ( !bVisible && !bMapped_ ) )
         return;
 
-	maFrameData.bMapped_   = bVisible;
-	maFrameData.bViewable_ = bVisible;
+	bMapped_   = bVisible;
+	bViewable_ = bVisible;
 	if( bVisible )
 	{
         SessionManagerClient::open(); // will simply return after the first time
 
-        maFrameData.mbInShow = TRUE;
-        if( ! (maFrameData.nStyle_ & SAL_FRAME_STYLE_INTRO) )
+        mbInShow = TRUE;
+        if( ! (nStyle_ & SAL_FRAME_STYLE_INTRO) )
         {
-            SalFrame* pFrame = GetSalData()->pFirstFrame_;
-            while( pFrame )
+            // hide all INTRO frames
+            const std::list< SalFrame* >& rFrames = GetDisplay()->getFrames();
+            for( std::list< SalFrame* >::const_iterator it = rFrames.begin(); it != rFrames.end(); ++it )
             {
+                X11SalFrame* pFrame = static_cast< X11SalFrame* >(*it);
                 // look for intro bit map; if present, hide it
-                if( pFrame->maFrameData.nStyle_ & SAL_FRAME_STYLE_INTRO )
+                if( pFrame->nStyle_ & SAL_FRAME_STYLE_INTRO )
                     pFrame->Show( FALSE );
-                pFrame = pFrame->maFrameData.pNextFrame_;
             }
         }
 
@@ -1067,38 +1008,38 @@ void SalFrame::Show( BOOL bVisible, BOOL
          *  withdraw the frame AND delete the WM_TRANSIENT_FOR property.
          *  In case the frame is shown again, the transient hint must be restored here.
          */
-        if( ! ( maFrameData.nStyle_ & ( SAL_FRAME_STYLE_FLOAT | SAL_FRAME_STYLE_CHILD ) )
-            && ! maFrameData.IsOverrideRedirect()
-            && maFrameData.mpParent
+        if( ! ( nStyle_ & ( SAL_FRAME_STYLE_FLOAT | SAL_FRAME_STYLE_CHILD ) )
+            && ! IsOverrideRedirect()
+            && mpParent
             )
         {
-            _GetDisplay()->getWMAdaptor()->changeReferenceFrame( this, maFrameData.mpParent );
+            GetDisplay()->getWMAdaptor()->changeReferenceFrame( this, mpParent );
         }
 
         // actually map the window
-        if( maFrameData.GetWindow() != maFrameData.GetShellWindow() )
+        if( GetWindow() != GetShellWindow() )
         {
-            XMapWindow( _GetXDisplay(), maFrameData.GetShellWindow() );
-            XSelectInput( _GetXDisplay(), maFrameData.GetShellWindow(), CLIENT_EVENTS );
+            XMapWindow( GetXDisplay(), GetShellWindow() );
+            XSelectInput( GetXDisplay(), GetShellWindow(), CLIENT_EVENTS );
         }
-        if( maFrameData.nStyle_ & SAL_FRAME_STYLE_FLOAT )
-            XMapRaised( _GetXDisplay(), maFrameData.GetWindow() );
+        if( nStyle_ & SAL_FRAME_STYLE_FLOAT )
+            XMapRaised( GetXDisplay(), GetWindow() );
         else
-            XMapWindow( _GetXDisplay(), maFrameData.GetWindow() );
-		XSelectInput( _GetXDisplay(), maFrameData.GetWindow(), CLIENT_EVENTS );
+            XMapWindow( GetXDisplay(), GetWindow() );
+		XSelectInput( GetXDisplay(), GetWindow(), CLIENT_EVENTS );
 
 		if( maGeometry.nWidth > 0
             && maGeometry.nHeight > 0
-			&& (   maFrameData.nWidth_  != (int)maGeometry.nWidth
-				|| maFrameData.nHeight_ != (int)maGeometry.nHeight ) )
+			&& (   nWidth_  != (int)maGeometry.nWidth
+				|| nHeight_ != (int)maGeometry.nHeight ) )
 		{
-			maFrameData.nWidth_  = maGeometry.nWidth;
-			maFrameData.nHeight_ = maGeometry.nHeight;
+			nWidth_  = maGeometry.nWidth;
+			nHeight_ = maGeometry.nHeight;
 		}
 
-		XSync( _GetXDisplay(), False );
+		XSync( GetXDisplay(), False );
 
-        if( maFrameData.IsFloatGrabWindow() )
+        if( IsFloatGrabWindow() )
         {
             /*
              *  #95453#
@@ -1109,21 +1050,21 @@ void SalFrame::Show( BOOL bVisible, BOOL
              *  a menu because it vanishes as soon as he enters it.
              */
             nVisibleFloats++;
-            if( nVisibleFloats == 1 && ! _GetDisplay()->GetCaptureFrame() )
+            if( nVisibleFloats == 1 && ! GetDisplay()->GetCaptureFrame() )
             {
-                XGrabPointer( _GetXDisplay(),
-                              maFrameData.GetWindow(),
+                XGrabPointer( GetXDisplay(),
+                              GetWindow(),
                               True,
                               PointerMotionMask | ButtonPressMask | ButtonReleaseMask,
                               GrabModeAsync,
                               GrabModeAsync,
                               None,
-                              maFrameData.mpParent ? maFrameData.mpParent->maFrameData.GetCursor() : None,
+                              mpParent ? mpParent->GetCursor() : None,
                               CurrentTime
                               );
             }
         }
-		maFrameData.Call( SALEVENT_RESIZE, NULL );
+		CallCallback( SALEVENT_RESIZE, NULL );
 
         /*
          *  sometimes a message box/dialogue is brought up when a frame is not mapped
@@ -1131,22 +1072,22 @@ void SalFrame::Show( BOOL bVisible, BOOL
          *  so that the dialogue shows in all cases. Correct it here if the
          *  frame is shown afterwards.
          */
-        if( ! ( maFrameData.nStyle_ & ( SAL_FRAME_STYLE_FLOAT | SAL_FRAME_STYLE_CHILD ) )
-            && ! maFrameData.IsOverrideRedirect() )
+        if( ! ( nStyle_ & ( SAL_FRAME_STYLE_FLOAT | SAL_FRAME_STYLE_CHILD ) )
+            && ! IsOverrideRedirect() )
         {
-            for( ::std::list< SalFrame* >::const_iterator it = maFrameData.maChildren.begin();
-                 it != maFrameData.maChildren.end(); ++it )
+            for( std::list< X11SalFrame* >::const_iterator it = maChildren.begin();
+                 it != maChildren.end(); ++it )
             {
-                if( (*it)->maFrameData.mbTransientForRoot )
-                    _GetDisplay()->getWMAdaptor()->changeReferenceFrame( *it, this );
+                if( (*it)->mbTransientForRoot )
+                    GetDisplay()->getWMAdaptor()->changeReferenceFrame( *it, this );
             }
         }
         /*
          *  leave SHOWSTATE_UNKNOWN as this indicates first mapping
          *  and is only reset int HandleSizeEvent
          */
-        if( maFrameData.nShowState_ != SHOWSTATE_UNKNOWN )
-            maFrameData.nShowState_ = SHOWSTATE_NORMAL;
+        if( nShowState_ != SHOWSTATE_UNKNOWN )
+            nShowState_ = SHOWSTATE_NORMAL;
 
         /*
          *  #98107# plugged windows don't necessarily get the
@@ -1154,75 +1095,75 @@ void SalFrame::Show( BOOL bVisible, BOOL
          *  and have the focus. So try to set the focus
          *  to the child on Show(TRUE)
          */
-        if( maFrameData.nStyle_ & SAL_FRAME_STYLE_CHILD )
-            XSetInputFocus( _GetXDisplay(),
-                            maFrameData.GetWindow(),
+        if( nStyle_ & SAL_FRAME_STYLE_CHILD )
+            XSetInputFocus( GetXDisplay(),
+                            GetWindow(),
                             RevertToParent,
                             CurrentTime );
 
-        if( maFrameData.mpParent )
+        if( mpParent )
         {
             // push this frame so it will be in front of its siblings
             // only necessary for insane transient behaviour of Dtwm/olwm
-            maFrameData.mpParent->maFrameData.maChildren.remove( this );
-            maFrameData.mpParent->maFrameData.maChildren.push_front(this);
+            mpParent->maChildren.remove( this );
+            mpParent->maChildren.push_front(this);
         }
 	}
 	else
 	{
-        if( maFrameData.getInputContext() )
-            maFrameData.getInputContext()->Unmap( this );
+        if( getInputContext() )
+            getInputContext()->Unmap( this );
 
-        if( maFrameData.mpParent )
-            XDeleteProperty( _GetXDisplay(), maFrameData.GetShellWindow(), _GetDisplay()->getWMAdaptor()->getAtom( WMAdaptor::WM_TRANSIENT_FOR ) );
-        XWithdrawWindow( _GetXDisplay(), maFrameData.GetWindow(), _GetDisplay()->GetScreenNumber() );
-        maFrameData.nShowState_ = SHOWSTATE_HIDDEN;
-        if( maFrameData.IsFloatGrabWindow() && nVisibleFloats )
+        if( mpParent )
+            XDeleteProperty( GetXDisplay(), GetShellWindow(), GetDisplay()->getWMAdaptor()->getAtom( WMAdaptor::WM_TRANSIENT_FOR ) );
+        XWithdrawWindow( GetXDisplay(), GetWindow(), GetDisplay()->GetScreenNumber() );
+        nShowState_ = SHOWSTATE_HIDDEN;
+        if( IsFloatGrabWindow() && nVisibleFloats )
         {
             nVisibleFloats--;
-            if( nVisibleFloats == 0  && ! _GetDisplay()->GetCaptureFrame() )
-                XUngrabPointer( _GetXDisplay(),
+            if( nVisibleFloats == 0  && ! GetDisplay()->GetCaptureFrame() )
+                XUngrabPointer( GetXDisplay(),
                                 CurrentTime );
         }
 	}
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrame::ToTop( USHORT nFlags )
+void X11SalFrame::ToTop( USHORT nFlags )
 {
 	if( ( nFlags & SAL_FRAME_TOTOP_RESTOREWHENMIN )
-        && ! ( maFrameData.nStyle_ & SAL_FRAME_STYLE_FLOAT )
-        && maFrameData.nShowState_ != SHOWSTATE_HIDDEN
-        && maFrameData.nShowState_ != SHOWSTATE_UNKNOWN
+        && ! ( nStyle_ & SAL_FRAME_STYLE_FLOAT )
+        && nShowState_ != SHOWSTATE_HIDDEN
+        && nShowState_ != SHOWSTATE_UNKNOWN
         )
     {
-        if( maFrameData.GetWindow() != maFrameData.GetShellWindow() )
-            XMapWindow( _GetXDisplay(), maFrameData.GetShellWindow() );
-        XMapWindow( _GetXDisplay(), maFrameData.GetWindow() );
+        if( GetWindow() != GetShellWindow() )
+            XMapWindow( GetXDisplay(), GetShellWindow() );
+        XMapWindow( GetXDisplay(), GetWindow() );
     }
 
     if( ! (nFlags & SAL_FRAME_TOTOP_GRABFOCUS_ONLY) )
     {
-        XRaiseWindow( _GetXDisplay(), maFrameData.GetShellWindow() );
-        if( ! _GetDisplay()->getWMAdaptor()->isTransientBehaviourAsExpected() )
-            for( std::list< SalFrame* >::const_iterator it = maFrameData.maChildren.begin();
-                 it != maFrameData.maChildren.end(); ++it )
+        XRaiseWindow( GetXDisplay(), GetShellWindow() );
+        if( ! GetDisplay()->getWMAdaptor()->isTransientBehaviourAsExpected() )
+            for( std::list< X11SalFrame* >::const_iterator it = maChildren.begin();
+                 it != maChildren.end(); ++it )
                 (*it)->ToTop( nFlags & ~SAL_FRAME_TOTOP_GRABFOCUS );
     }
 
     if( ( ( nFlags & SAL_FRAME_TOTOP_GRABFOCUS ) || ( nFlags & SAL_FRAME_TOTOP_GRABFOCUS_ONLY ) )
-        && maFrameData.bMapped_ )
-	    XSetInputFocus( _GetXDisplay(), maFrameData.GetShellWindow(), RevertToParent, CurrentTime );
+        && bMapped_ )
+	    XSetInputFocus( GetXDisplay(), GetShellWindow(), RevertToParent, CurrentTime );
 }
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrame::GetWorkArea( Rectangle& rWorkArea )
+void X11SalFrame::GetWorkArea( Rectangle& rWorkArea )
 {
-    rWorkArea = maFrameData.pDisplay_->getWMAdaptor()->getWorkArea( 0 );
+    rWorkArea = pDisplay_->getWMAdaptor()->getWorkArea( 0 );
 }
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrame::GetClientSize( long &rWidth, long &rHeight )
+void X11SalFrame::GetClientSize( long &rWidth, long &rHeight )
 {
-	if( ! maFrameData.bViewable_  )
+	if( ! bViewable_  )
 	{
 		rWidth = rHeight = 0;
 		return;
@@ -1235,7 +1176,7 @@ void SalFrame::GetClientSize( long &rWid
 	{
 		XWindowAttributes aAttrib;
 
-		XGetWindowAttributes( _GetXDisplay(), maFrameData.GetShellWindow(), &aAttrib );
+		XGetWindowAttributes( GetXDisplay(), GetShellWindow(), &aAttrib );
 
 		rWidth	= aAttrib.width;
 		rHeight = aAttrib.height;
@@ -1244,7 +1185,7 @@ void SalFrame::GetClientSize( long &rWid
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalFrameData::SetWindowGravity (int nGravity) const
+void X11SalFrame::SetWindowGravity (int nGravity) const
 {
     XSizeHints* pHint = XAllocSizeHints();
     long        nFlag;
@@ -1259,7 +1200,7 @@ void SalFrameData::SetWindowGravity (int
     XFree (pHint);
 }
 
-void SalFrameData::Center( )
+void X11SalFrame::Center( )
 {
 	int 			nX, nY, nScreenWidth, nScreenHeight;
 	int				nRealScreenWidth, nRealScreenHeight;
@@ -1304,25 +1245,25 @@ void SalFrameData::Center( )
 
 	if( mpParent )
 	{
-		SalFrame* pFrame = mpParent;
-		while( pFrame->maFrameData.mpParent )
-			pFrame = pFrame->maFrameData.mpParent;
+		X11SalFrame* pFrame = mpParent;
+		while( pFrame->mpParent )
+			pFrame = pFrame->mpParent;
 		if( pFrame->maGeometry.nWidth < 1  || pFrame->maGeometry.nHeight < 1 )
         {
             Rectangle aRect;
-			pFrame->maFrameData.GetPosSize( aRect );
+			pFrame->GetPosSize( aRect );
             pFrame->maGeometry.nX		= aRect.Left();
             pFrame->maGeometry.nY		= aRect.Top();
             pFrame->maGeometry.nWidth	= aRect.GetWidth();
             pFrame->maGeometry.nHeight	= aRect.GetHeight();
         }
 
-		if( pFrame->maFrameData.nStyle_ & SAL_FRAME_STYLE_CHILD )
+		if( pFrame->nStyle_ & SAL_FRAME_STYLE_CHILD )
 		{
 			XLIB_Window aRoot;
 			unsigned int bw, depth;
 			XGetGeometry( GetXDisplay(),
-						  pFrame->maFrameData.GetShellWindow(),
+						  pFrame->GetShellWindow(),
 						  &aRoot,
 						  &nScreenX, &nScreenY,
 						  (unsigned int*)&nScreenWidth,
@@ -1338,10 +1279,10 @@ void SalFrameData::Center( )
 		}
 	}
 
-	if( mpParent && mpParent->maFrameData.nShowState_ == SHOWSTATE_NORMAL )
+	if( mpParent && mpParent->nShowState_ == SHOWSTATE_NORMAL )
 	{
-		if( pFrame_->maGeometry.nWidth >= mpParent->maGeometry.nWidth &&
-			pFrame_->maGeometry.nHeight >= mpParent->maGeometry.nHeight )
+		if( maGeometry.nWidth >= mpParent->maGeometry.nWidth &&
+			maGeometry.nHeight >= mpParent->maGeometry.nHeight )
 		{
 			nX = nScreenX + 40;
 			nY = nScreenY + 40;
@@ -1349,15 +1290,15 @@ void SalFrameData::Center( )
 		else
 		{
 			// center the window relative to the top level frame
-			nX = (nScreenWidth	- (int)pFrame_->maGeometry.nWidth ) / 2 + nScreenX;
-			nY = (nScreenHeight - (int)pFrame_->maGeometry.nHeight) / 2 + nScreenY;
+			nX = (nScreenWidth	- (int)maGeometry.nWidth ) / 2 + nScreenX;
+			nY = (nScreenHeight - (int)maGeometry.nHeight) / 2 + nScreenY;
 		}
 	}
 	else
 	{
 		// center the window relative to screen
-		nX = (nRealScreenWidth	- (int)pFrame_->maGeometry.nWidth ) / 2 + nScreenX;
-		nY = (nRealScreenHeight - (int)pFrame_->maGeometry.nHeight) / 2 + nScreenY;
+		nX = (nRealScreenWidth	- (int)maGeometry.nWidth ) / 2 + nScreenX;
+		nY = (nRealScreenHeight - (int)maGeometry.nHeight) / 2 + nScreenY;
 	}
     nX = nX < 0 ? 0 : nX;
     nY = nY < 0 ? 0 : nY;
@@ -1370,30 +1311,30 @@ void SalFrameData::Center( )
     }
 
     Point aPoint(nX, nY);
-	SetPosSize( Rectangle( aPoint, Size( pFrame_->maGeometry.nWidth, pFrame_->maGeometry.nHeight ) ) );
+	SetPosSize( Rectangle( aPoint, Size( maGeometry.nWidth, maGeometry.nHeight ) ) );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrame::SetPosSize( long nX, long nY, long nWidth, long nHeight, USHORT nFlags )
+void X11SalFrame::SetPosSize( long nX, long nY, long nWidth, long nHeight, USHORT nFlags )
 {
-    if( maFrameData.nStyle_ & SAL_FRAME_STYLE_CHILD )
+    if( nStyle_ & SAL_FRAME_STYLE_CHILD )
         return;
 
-    // relative positioning in SalFrameData::SetPosSize
+    // relative positioning in X11SalFrame::SetPosSize
     Rectangle aPosSize( Point( maGeometry.nX, maGeometry.nY ), Size( maGeometry.nWidth, maGeometry.nHeight ) );
     aPosSize.Justify();
 
     if( ! ( nFlags & SAL_FRAME_POSSIZE_X ) )
     {
         nX = aPosSize.Left();
-        if( maFrameData.mpParent )
-            nX -= maFrameData.mpParent->maFrameData.pFrame_->maGeometry.nX;
+        if( mpParent )
+            nX -= mpParent->maGeometry.nX;
     }
     if( ! ( nFlags & SAL_FRAME_POSSIZE_Y ) )
     {
         nY = aPosSize.Top();
-        if( maFrameData.mpParent )
-            nY -= maFrameData.mpParent->maFrameData.pFrame_->maGeometry.nY;
+        if( mpParent )
+            nY -= mpParent->maGeometry.nY;
     }
     if( ! ( nFlags & SAL_FRAME_POSSIZE_WIDTH ) )
         nWidth = aPosSize.GetWidth();
@@ -1404,27 +1345,27 @@ void SalFrame::SetPosSize( long nX, long
 
     if( ! ( nFlags & ( SAL_FRAME_POSSIZE_X | SAL_FRAME_POSSIZE_Y ) ) )
     {
-        if( maFrameData.bDefaultPosition_ )
+        if( bDefaultPosition_ )
         {
             maGeometry.nWidth = aPosSize.GetWidth();
             maGeometry.nHeight = aPosSize.GetHeight();
-            maFrameData.Center();
+            Center();
         }
         else
-            maFrameData.SetSize( Size( nWidth, nHeight ) );
+            SetSize( Size( nWidth, nHeight ) );
     }
     else
-        maFrameData.SetPosSize( aPosSize );
-    maFrameData.bDefaultPosition_ = False;
+        SetPosSize( aPosSize );
+    bDefaultPosition_ = False;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrame::SetAlwaysOnTop( BOOL bOnTop )
+void X11SalFrame::SetAlwaysOnTop( BOOL bOnTop )
 {
-    if( ! maFrameData.IsOverrideRedirect() )
+    if( ! IsOverrideRedirect() )
     {
-        maFrameData.bAlwaysOnTop_ = bOnTop;
-        maFrameData.pDisplay_->getWMAdaptor()->enableAlwaysOnTop( this, bOnTop );
+        bAlwaysOnTop_ = bOnTop;
+        pDisplay_->getWMAdaptor()->enableAlwaysOnTop( this, bOnTop );
     }
 }
 
@@ -1434,8 +1375,7 @@ void SalFrame::SetAlwaysOnTop( BOOL bOnT
      (SAL_FRAMESTATE_MASK_X     | SAL_FRAMESTATE_MASK_Y |   \
       SAL_FRAMESTATE_MASK_WIDTH | SAL_FRAMESTATE_MASK_HEIGHT)
 
-void
-SalFrame::SetWindowState( const SalFrameState *pState )
+void X11SalFrame::SetWindowState( const SalFrameState *pState )
 {
     if (pState == NULL)
         return;
@@ -1447,7 +1387,7 @@ SalFrame::SetWindowState( const SalFrame
 
         // initialize with current geometry
         if ((pState->mnMask & _FRAMESTATE_MASK_GEOMETRY) != _FRAMESTATE_MASK_GEOMETRY)
-            maFrameData.GetPosSize (aPosSize);
+            GetPosSize (aPosSize);
 
         // change requested properties
         if (pState->mnMask & SAL_FRAMESTATE_MASK_X)
@@ -1469,23 +1409,21 @@ SalFrame::SetWindowState( const SalFrame
             aPosSize.setHeight (nHeight);
         }
 
-        const Size& rScreenSize( maFrameData.pDisplay_->GetScreenSize() );
-        const WMAdaptor *pWM = _GetDisplay()->getWMAdaptor();
-        int nGravity = pWM->getPositionWinGravity();
+        const Size& rScreenSize( pDisplay_->GetScreenSize() );
+        const WMAdaptor *pWM = GetDisplay()->getWMAdaptor();
 
-        bool bAdjusted = false;
         if( pState->mnMask & ( SAL_FRAMESTATE_MASK_HEIGHT | SAL_FRAMESTATE_MASK_WIDTH )
             && aPosSize.GetWidth() <= rScreenSize.Width()
             && aPosSize.GetHeight() <= rScreenSize.Height() )
         {
             SalFrameGeometry aGeom = maGeometry;
 
-            if( ! (maFrameData.nStyle_ & ( SAL_FRAME_STYLE_FLOAT | SAL_FRAME_STYLE_CHILD ) ) &&
-               maFrameData.mpParent &&
+            if( ! (nStyle_ & ( SAL_FRAME_STYLE_FLOAT | SAL_FRAME_STYLE_CHILD ) ) &&
+               mpParent &&
                 aGeom.nLeftDecoration == 0 &&
                 aGeom.nTopDecoration == 0 )
             {
-                aGeom = maFrameData.mpParent->maGeometry;
+                aGeom = mpParent->maGeometry;
                 if( aGeom.nLeftDecoration == 0 &&
                     aGeom.nTopDecoration == 0 )
                 {
@@ -1497,46 +1435,24 @@ SalFrame::SetWindowState( const SalFrame
             }
 
             // adjust position so that frame fits onto screen
-            if( aPosSize.Right()+(long)aGeom.nRightDecoration >= rScreenSize.Width() )
-            {
+            if( aPosSize.Right()+(long)aGeom.nRightDecoration > rScreenSize.Width()-1 )
                 aPosSize.Move( (long)rScreenSize.Width() - (long)aPosSize.Right() - (long)aGeom.nRightDecoration, 0 );
-                nGravity = EastGravity;
-                bAdjusted = true;
-            }
-            if( aPosSize.Bottom()+(long)aGeom.nBottomDecoration >= rScreenSize.Height() )
-            {
+            if( aPosSize.Bottom()+(long)aGeom.nBottomDecoration > rScreenSize.Height()-1 )
                 aPosSize.Move( 0, (long)rScreenSize.Height() - (long)aPosSize.Bottom() - (long)aGeom.nBottomDecoration );
-                nGravity = nGravity == EastGravity ? SouthEastGravity : SouthGravity;
-                bAdjusted = true;
-            }
             if( aPosSize.Left() < (long)aGeom.nLeftDecoration )
-            {
                 aPosSize.Move( (long)aGeom.nLeftDecoration - (long)aPosSize.Left(), 0 );
-                nGravity = ( nGravity == SouthGravity || nGravity == SouthEastGravity ) ? SouthWestGravity : WestGravity;
-                bAdjusted = true;
-            }
             if( aPosSize.Top() < (long)aGeom.nTopDecoration )
-            {
                 aPosSize.Move( 0, (long)aGeom.nTopDecoration - (long)aPosSize.Top() );
-                nGravity =
-                    ( nGravity == SouthEastGravity || nGravity == EastGravity ) ? NorthEastGravity :
-                    ( ( nGravity == SouthWestGravity || nGravity == WestGravity ) ? NorthWestGravity : NorthGravity );
-                bAdjusted = true;
-            }
         }
 
-         // demand correct positioning from the WM
-        if( bAdjusted )
-            maFrameData.SetWindowGravity ( nGravity );
-
          // resize with new args
          if (pWM->supportsICCCMPos())
          {
-             if( maFrameData.mpParent && ! bAdjusted )
-                 aPosSize.Move( -maFrameData.mpParent->maGeometry.nX,
-                                -maFrameData.mpParent->maGeometry.nY );
-             maFrameData.SetPosSize( aPosSize );
-             maFrameData.bDefaultPosition_ = False;
+             if( mpParent )
+                 aPosSize.Move( -mpParent->maGeometry.nX,
+                                -mpParent->maGeometry.nY );
+             SetPosSize( aPosSize );
+             bDefaultPosition_ = False;
          }
          else
              SetPosSize( 0, 0, aPosSize.GetWidth(), aPosSize.GetHeight(), SAL_FRAME_POSSIZE_WIDTH | SAL_FRAME_POSSIZE_HEIGHT );
@@ -1547,58 +1463,58 @@ SalFrame::SetWindowState( const SalFrame
     {
 	    if (pState->mnState & SAL_FRAMESTATE_MAXIMIZED)
 	    {
-		    maFrameData.nShowState_ = SHOWSTATE_NORMAL;
-            if( ! (pState->mnMask & (SAL_FRAMESTATE_MAXIMIZED_HORZ|SAL_FRAMESTATE_MAXIMIZED_VERT) ) )
-                maFrameData.Maximize();
+		    nShowState_ = SHOWSTATE_NORMAL;
+            if( ! (pState->mnState & (SAL_FRAMESTATE_MAXIMIZED_HORZ|SAL_FRAMESTATE_MAXIMIZED_VERT) ) )
+                Maximize();
             else
             {
                 bool bHorz = (pState->mnState & SAL_FRAMESTATE_MAXIMIZED_HORZ) ? true : false;
                 bool bVert = (pState->mnState & SAL_FRAMESTATE_MAXIMIZED_VERT) ? true : false;
-                _GetDisplay()->getWMAdaptor()->maximizeFrame( this, bHorz, bVert );
+                GetDisplay()->getWMAdaptor()->maximizeFrame( this, bHorz, bVert );
             }
 	    }
-        else if( maFrameData.mbMaximizedHorz || maFrameData.mbMaximizedVert )
-            _GetDisplay()->getWMAdaptor()->maximizeFrame( this, false, false );
+        else if( mbMaximizedHorz || mbMaximizedVert )
+            GetDisplay()->getWMAdaptor()->maximizeFrame( this, false, false );
 
 	    if (pState->mnState & SAL_FRAMESTATE_MINIMIZED)
 	    {
-		    if (maFrameData.nShowState_ == SHOWSTATE_UNKNOWN)
-			    maFrameData.nShowState_ = SHOWSTATE_NORMAL;
-		    maFrameData.Minimize();
+		    if (nShowState_ == SHOWSTATE_UNKNOWN)
+			    nShowState_ = SHOWSTATE_NORMAL;
+		    Minimize();
         }
         if (pState->mnState & SAL_FRAMESTATE_NORMAL)
         {
-            if (maFrameData.nShowState_ != SHOWSTATE_NORMAL)
-                maFrameData.Restore();
+            if (nShowState_ != SHOWSTATE_NORMAL)
+                Restore();
         }
         if (pState->mnState & SAL_FRAMESTATE_ROLLUP)
-            _GetDisplay()->getWMAdaptor()->shade( this, true );
+            GetDisplay()->getWMAdaptor()->shade( this, true );
 	}
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-BOOL SalFrame::GetWindowState( SalFrameState* pState )
+BOOL X11SalFrame::GetWindowState( SalFrameState* pState )
 {
-	if( SHOWSTATE_MINIMIZED == maFrameData.nShowState_ )
+	if( SHOWSTATE_MINIMIZED == nShowState_ )
 		pState->mnState = SAL_FRAMESTATE_MINIMIZED;
 	else
 		pState->mnState = SAL_FRAMESTATE_NORMAL;
 
 	Rectangle aPosSize;
-	if (! maFrameData.maRestorePosSize.IsEmpty() )
+	if (! maRestorePosSize.IsEmpty() )
 	{
-		aPosSize = maFrameData.maRestorePosSize;
+		aPosSize = maRestorePosSize;
 		pState->mnState |= SAL_FRAMESTATE_MAXIMIZED;
 	}
 	else
     {
-		maFrameData.GetPosSize( aPosSize );
+		GetPosSize( aPosSize );
     }
-    if( maFrameData.mbMaximizedHorz )
+    if( mbMaximizedHorz )
         pState->mnState |= SAL_FRAMESTATE_MAXIMIZED_HORZ;
-    if( maFrameData.mbMaximizedVert )
+    if( mbMaximizedVert )
         pState->mnState |= SAL_FRAMESTATE_MAXIMIZED_VERT;
-    if( maFrameData.mbShaded )
+    if( mbShaded )
         pState->mnState |= SAL_FRAMESTATE_ROLLUP;
 
 	pState->mnX 	 = aPosSize.Left();
@@ -1613,17 +1529,16 @@ BOOL SalFrame::GetWindowState( SalFrameS
 
 // ----------------------------------------------------------------------------
 // get a screenshot of the current frame including window manager decoration
-SalBitmap*
-SalFrame::SnapShot()
+SalBitmap* X11SalFrame::SnapShot()
 {
-    Display* pDisplay = _GetXDisplay();
+    Display* pDisplay = GetXDisplay();
 
     // make sure the frame has been reparented and all paint timer have been
     // expired
-    maFrameData.maResizeTimer.Stop();
-    if ( maFrameData.mbMoved || maFrameData.mbSized )
+    maResizeTimer.Stop();
+    if ( mbMoved || mbSized )
     {
-        maFrameData.HandleResizeTimer (&maFrameData.maResizeTimer);
+        HandleResizeTimer (&maResizeTimer);
     }
 
     do
@@ -1632,7 +1547,10 @@ SalFrame::SnapShot()
         Application::Reschedule ();
     }
     while (XPending(pDisplay));
-    usleep (50000);
+    TimeValue aVal;
+    aVal.Seconds = 0;
+    aVal.Nanosec = 50000000;
+    osl_waitThread( &aVal );
     do
     {
         XSync(pDisplay, False);
@@ -1642,18 +1560,18 @@ SalFrame::SnapShot()
 
     // get the most outer window, usually the window manager decoration
     Drawable hWindow = None;
-    if (maFrameData.IsOverrideRedirect())
-        hWindow = _GetDrawable();
+    if (IsOverrideRedirect())
+        hWindow = GetDrawable();
     else
     if (hPresentationWindow != None)
         hWindow = hPresentationWindow;
     else
-        hWindow = maFrameData.GetStackingWindow();
+        hWindow = GetStackingWindow();
 
     // query the contents of the window
     if (hWindow != None)
     {
-        SalBitmap *pBmp = new SalBitmap;
+        X11SalBitmap *pBmp = new X11SalBitmap;
         if (pBmp->SnapShot (pDisplay, hWindow))
             return pBmp;
         else
@@ -1664,22 +1582,33 @@ SalFrame::SnapShot()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrameData::GetPosSize( Rectangle &rPosSize )
+
+// native menu implementation - currently empty
+void X11SalFrame::DrawMenuBar()
+{
+}
+
+void X11SalFrame::SetMenu( SalMenu* )
+{
+}
+
+// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+void X11SalFrame::GetPosSize( Rectangle &rPosSize )
 {
-	if( pFrame_->maGeometry.nWidth < 1 || pFrame_->maGeometry.nHeight < 1 )
+	if( maGeometry.nWidth < 1 || maGeometry.nHeight < 1 )
 	{
-		long w = pDisplay_->GetScreenSize().Width()  - pFrame_->maGeometry.nLeftDecoration - pFrame_->maGeometry.nRightDecoration;
-		long h = pDisplay_->GetScreenSize().Height() - pFrame_->maGeometry.nTopDecoration - pFrame_->maGeometry.nBottomDecoration;
+		long w = pDisplay_->GetScreenSize().Width()  - maGeometry.nLeftDecoration - maGeometry.nRightDecoration;
+		long h = pDisplay_->GetScreenSize().Height() - maGeometry.nTopDecoration - maGeometry.nBottomDecoration;
 
-		rPosSize = Rectangle( Point( pFrame_->maGeometry.nX, pFrame_->maGeometry.nY ), Size( w, h ) );
+		rPosSize = Rectangle( Point( maGeometry.nX, maGeometry.nY ), Size( w, h ) );
 	}
 	else
-		rPosSize = Rectangle( Point( pFrame_->maGeometry.nX, pFrame_->maGeometry.nY ),
-                              Size( pFrame_->maGeometry.nWidth, pFrame_->maGeometry.nHeight ) );
+		rPosSize = Rectangle( Point( maGeometry.nX, maGeometry.nY ),
+                              Size( maGeometry.nWidth, maGeometry.nHeight ) );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrameData::SetSize( const Size &rSize )
+void X11SalFrame::SetSize( const Size &rSize )
 {
 	if( rSize.Width() > 0 && rSize.Height() > 0 )
 	{
@@ -1708,12 +1637,12 @@ void SalFrameData::SetSize( const Size &
         if( GetWindow() != GetShellWindow() )
             XMoveResizeWindow( GetXDisplay(), GetWindow(), 0, 0, rSize.Width(), rSize.Height() );
 
-        pFrame_->maGeometry.nWidth  = rSize.Width();
-        pFrame_->maGeometry.nHeight = rSize.Height();
+        maGeometry.nWidth  = rSize.Width();
+        maGeometry.nHeight = rSize.Height();
 
 		// allow the external status window to reposition
 		if (mbInputFocus && mpInputContext != NULL)
-			mpInputContext->SetICFocus ( pFrame_ );
+			mpInputContext->SetICFocus ( this );
 	}
 }
 
@@ -1721,7 +1650,7 @@ void SalFrameData::SetSize( const Size &
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalFrameData::SetPosSize( const Rectangle &rPosSize )
+void X11SalFrame::SetPosSize( const Rectangle &rPosSize )
 {
 	XWindowChanges values;
 	values.x		= rPosSize.Left();
@@ -1741,7 +1670,7 @@ void SalFrameData::SetPosSize( const Rec
  		XLIB_Window aChild;
  		// coordinates are relative to parent, so translate to root coordinates
  		XTranslateCoordinates( GetDisplay()->GetDisplay(),
- 							   mpParent->maFrameData.GetWindow(),
+ 							   mpParent->GetWindow(),
  							   GetDisplay()->GetRootWindow(),
  							   values.x, values.y,
  							   &values.x, &values.y,
@@ -1750,16 +1679,16 @@ void SalFrameData::SetPosSize( const Rec
 
     bool bMoved = false;
     bool bSized = false;
-    if( values.x != pFrame_->maGeometry.nX || values.y != pFrame_->maGeometry.nY )
+    if( values.x != maGeometry.nX || values.y != maGeometry.nY )
         bMoved = true;
-    if( values.width != (int)pFrame_->maGeometry.nWidth || values.height != (int)pFrame_->maGeometry.nHeight )
+    if( values.width != (int)maGeometry.nWidth || values.height != (int)maGeometry.nHeight )
         bSized = true;
 
 	if( ! ( nStyle_ & ( SAL_FRAME_STYLE_CHILD | SAL_FRAME_STYLE_FLOAT ) )
         && !(pDisplay_->GetProperties() & PROPERTY_SUPPORT_WM_ClientPos) )
     {
-        values.x	-= pFrame_->maGeometry.nLeftDecoration;
-        values.y	-= pFrame_->maGeometry.nTopDecoration;
+        values.x	-= maGeometry.nLeftDecoration;
+        values.y	-= maGeometry.nTopDecoration;
     }
 
     if( ( ! ( nStyle_ & SAL_FRAME_STYLE_CHILD )
@@ -1802,28 +1731,28 @@ void SalFrameData::SetPosSize( const Rec
     if( GetShellWindow() != GetWindow() )
         XMoveResizeWindow( GetXDisplay(), GetWindow(), 0, 0, values.width, values.height );
 
-    pFrame_->maGeometry.nX		= values.x;
-    pFrame_->maGeometry.nY		= values.y;
-    pFrame_->maGeometry.nWidth	= values.width;
-    pFrame_->maGeometry.nHeight	= values.height;
+    maGeometry.nX		= values.x;
+    maGeometry.nY		= values.y;
+    maGeometry.nWidth	= values.width;
+    maGeometry.nHeight	= values.height;
     if( bSized && ! bMoved )
-        Call ( SALEVENT_RESIZE, NULL );
+        CallCallback( SALEVENT_RESIZE, NULL );
     else if( bMoved && ! bSized )
-        Call ( SALEVENT_MOVE, NULL );
+        CallCallback( SALEVENT_MOVE, NULL );
     else
-        Call ( SALEVENT_MOVERESIZE, NULL );
+        CallCallback( SALEVENT_MOVERESIZE, NULL );
 
 	// allow the external status window to reposition
 	if (mbInputFocus && mpInputContext != NULL)
-		mpInputContext->SetICFocus ( pFrame_ );
+		mpInputContext->SetICFocus ( this );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrameData::Minimize()
+void X11SalFrame::Minimize()
 {
 	if( SHOWSTATE_UNKNOWN == nShowState_ || SHOWSTATE_HIDDEN == nShowState_ )
 	{
-		stderr0( "SalFrameData::Minimize on withdrawn window\n" );
+		stderr0( "X11SalFrame::Minimize on withdrawn window\n" );
 		return;
 	}
 
@@ -1834,7 +1763,7 @@ void SalFrameData::Minimize()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrameData::Maximize()
+void X11SalFrame::Maximize()
 {
 	if( SHOWSTATE_MINIMIZED == nShowState_ )
 	{
@@ -1842,15 +1771,15 @@ void SalFrameData::Maximize()
 		nShowState_ = SHOWSTATE_NORMAL;
 	}
 
-    pDisplay_->getWMAdaptor()->maximizeFrame( pFrame_, true, true );
+    pDisplay_->getWMAdaptor()->maximizeFrame( this, true, true );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrameData::Restore()
+void X11SalFrame::Restore()
 {
 	if( SHOWSTATE_UNKNOWN == nShowState_ || SHOWSTATE_HIDDEN == nShowState_ )
 	{
-		stderr0( "SalFrameData::Restore on withdrawn window\n" );
+		stderr0( "X11SalFrame::Restore on withdrawn window\n" );
 		return;
 	}
 
@@ -1860,22 +1789,22 @@ void SalFrameData::Restore()
 		nShowState_ = SHOWSTATE_NORMAL;
 	}
 
-    pDisplay_->getWMAdaptor()->maximizeFrame( pFrame_, false, false );
+    pDisplay_->getWMAdaptor()->maximizeFrame( this, false, false );
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalFrame::ShowFullScreen( BOOL bFullScreen )
+void X11SalFrame::ShowFullScreen( BOOL bFullScreen )
 {
-	if( maFrameData.mbFullScreen == (bool)bFullScreen )
+	if( mbFullScreen == (bool)bFullScreen )
 		return;
 
-    maFrameData.pDisplay_->getWMAdaptor()->showFullScreen( this, bFullScreen );
-    if( maFrameData.IsOverrideRedirect()
-        && WMSupportsFWS( maFrameData.GetXDisplay(), maFrameData.GetDisplay()->GetRootWindow()) )
+    pDisplay_->getWMAdaptor()->showFullScreen( this, bFullScreen );
+    if( IsOverrideRedirect()
+        && WMSupportsFWS( GetXDisplay(), GetDisplay()->GetRootWindow()) )
     {
-        AddFwsProtocols( maFrameData.GetXDisplay(), maFrameData.GetShellWindow() );
-        RegisterFwsWindow( maFrameData.GetXDisplay(), maFrameData.GetShellWindow() );
+        AddFwsProtocols( GetXDisplay(), GetShellWindow() );
+        RegisterFwsWindow( GetXDisplay(), GetShellWindow() );
     }
 }
 
@@ -1949,18 +1878,18 @@ MessageToXAutoLock( Display *p_display, 
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrame::StartPresentation( BOOL bStart )
+void X11SalFrame::StartPresentation( BOOL bStart )
 {
     I18NStatus::get().show( !bStart, I18NStatus::presentation );
 	if ( bStart )
-		MessageToXAutoLock( _GetXDisplay(), XAUTOLOCK_DISABLE );
+		MessageToXAutoLock( GetXDisplay(), XAUTOLOCK_DISABLE );
 	else
-		MessageToXAutoLock( _GetXDisplay(), XAUTOLOCK_ENABLE );
+		MessageToXAutoLock( GetXDisplay(), XAUTOLOCK_ENABLE );
 
     if( ! bStart && hPresentationWindow != None )
-        doReparentPresentationDialogues( _GetDisplay() );
-    hPresentationWindow = (bStart && maFrameData.IsOverrideRedirect() ) ? maFrameData.GetWindow() : None;
-	if( bStart || maFrameData.nScreenSaversTimeout_ )
+        doReparentPresentationDialogues( GetDisplay() );
+    hPresentationWindow = (bStart && IsOverrideRedirect() ) ? GetWindow() : None;
+	if( bStart || nScreenSaversTimeout_ )
 	{
         if( hPresentationWindow )
         {
@@ -1968,28 +1897,28 @@ void SalFrame::StartPresentation( BOOL b
              *  current focus after presentation window is gone
              */
             int revert_to = 0;
-            XGetInputFocus( _GetXDisplay(), &hPresFocusWindow, &revert_to );
+            XGetInputFocus( GetXDisplay(), &hPresFocusWindow, &revert_to );
         }
 		int timeout, interval, prefer_blanking, allow_exposures;
-		XGetScreenSaver( _GetXDisplay(),
+		XGetScreenSaver( GetXDisplay(),
 						 &timeout,
 						 &interval,
 						 &prefer_blanking,
 						 &allow_exposures );
 		if( !bStart )
 		{
-			XSetScreenSaver( _GetXDisplay(),
-							 maFrameData.nScreenSaversTimeout_,
+			XSetScreenSaver( GetXDisplay(),
+							 nScreenSaversTimeout_,
 							 interval,
 							 prefer_blanking,
 							 allow_exposures );
-			maFrameData.nScreenSaversTimeout_ = 0;
+			nScreenSaversTimeout_ = 0;
 		}
 		else if( timeout )
 		{
-			maFrameData.nScreenSaversTimeout_ = timeout;
-			XResetScreenSaver( _GetXDisplay() );
-			XSetScreenSaver( _GetXDisplay(),
+			nScreenSaversTimeout_ = timeout;
+			XResetScreenSaver( GetXDisplay() );
+			XSetScreenSaver( GetXDisplay(),
 							 0,
 							 interval,
 							 prefer_blanking,
@@ -2000,7 +1929,7 @@ void SalFrame::StartPresentation( BOOL b
 
 // Pointer
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-inline void SalFrameData::SetPointer( PointerStyle ePointerStyle )
+void X11SalFrame::SetPointer( PointerStyle ePointerStyle )
 {
 	hCursor_ = pDisplay_->GetPointer( ePointerStyle );
 	XDefineCursor( GetXDisplay(), GetWindow(), hCursor_ );
@@ -2012,13 +1941,7 @@ inline void SalFrameData::SetPointer( Po
 						CurrentTime );
 }
 
-void SalFrame::SetPointer( PointerStyle ePointerStyle )
-{ maFrameData.SetPointer( ePointerStyle ); }
-
-void SalFrame::CaptureMouse( BOOL bCapture )
-{ maFrameData.CaptureMouse( bCapture ); }
-
-void SalFrame::SetPointerPos(long nX, long nY)
+void X11SalFrame::SetPointerPos(long nX, long nY)
 {
     /* #87921# when the application tries to center the mouse in the dialog the
      * window isn't mapped already. So use coordinates relative to the root window.
@@ -2026,38 +1949,45 @@ void SalFrame::SetPointerPos(long nX, lo
     unsigned int nWindowLeft = maGeometry.nX + nX;
     unsigned int nWindowTop  = maGeometry.nY + nY;
 
-    XWarpPointer( _GetXDisplay(), None, maFrameData.pDisplay_->GetRootWindow(),
+    XWarpPointer( GetXDisplay(), None, pDisplay_->GetRootWindow(),
                   0, 0, 0, 0, nWindowLeft, nWindowTop);
 }
 
 // delay handling of extended text input
 #if !defined(__synchronous_extinput__)
 void
-SalFrameData::PostExtTextEvent (sal_uInt16 nExtTextEventType, void *pExtTextEvent)
+X11SalFrame::PostExtTextEvent (sal_uInt16 nExtTextEventType, void *pExtTextEvent)
 {
 	XLIB_Window nFocusWindow = GetWindow();
 	Atom 		nEventAtom	 = GetDisplay()->getWMAdaptor()->getAtom( WMAdaptor::SAL_EXTTEXTEVENT );
 
-	sal_uInt32 pEventData[5];
-
-#if __SIZEOFLONG > 4
-    pEventData[0] = (sal_uInt32)((long)pExtTextEvent & 0xffffffff);
-    pEventData[1] = (sal_uInt32)((long)pExtTextEvent >> 32);
+    XEvent aEvent;
+    aEvent.xclient.type			= ClientMessage;
+    aEvent.xclient.serial		= 0;
+    aEvent.xclient.send_event	= True;
+    aEvent.xclient.display		= GetXDisplay();
+    aEvent.xclient.window		= nFocusWindow;
+    aEvent.xclient.message_type	= nEventAtom;
+    aEvent.xclient.format		= 32;
+
+#if SAL_TYPES_SIZEOFLONG > 4
+    aEvent.xclient.data.l[0] = (sal_uInt32)((long)pExtTextEvent & 0xffffffff);
+    aEvent.xclient.data.l[1] = (sal_uInt32)((long)pExtTextEvent >> 32);
 #else
-    pEventData[0] = (sal_uInt32)((long)pExtTextEvent);
-    pEventData[1] = NULL;
+    aEvent.xclient.data.l[0] = (sal_uInt32)((long)pExtTextEvent);
+    aEvent.xclient.data.l[1] = NULL;
 #endif
-    pEventData[2] = (sal_uInt32)nExtTextEventType;
-    pEventData[3] = NULL;
-    pEventData[4] = NULL;
+    aEvent.xclient.data.l[2] = (sal_uInt32)nExtTextEventType;
+    aEvent.xclient.data.l[3] = NULL;
+    aEvent.xclient.data.l[4] = NULL;
 
-	GetDisplay()->SendEvent (nEventAtom, pEventData, nFocusWindow);
+    XPutBackEvent( GetXDisplay(), &aEvent );
 }
 
 void
-SalFrameData::HandleExtTextEvent (XClientMessageEvent *pEvent)
+X11SalFrame::HandleExtTextEvent (XClientMessageEvent *pEvent)
 {
-	#if __SIZEOFLONG > 4
+	#if SAL_TYPES_SIZEOFLONG > 4
 	void* pExtTextEvent = (void*)(  (pEvent->data.l[0] & 0xffffffff)
 								  | (pEvent->data.l[1] << 32) );
 	#else
@@ -2065,12 +1995,11 @@ SalFrameData::HandleExtTextEvent (XClien
 	#endif
 	sal_uInt16 nExtTextEventType = sal_uInt16(pEvent->data.l[2]);
 
-	Call(nExtTextEventType, pExtTextEvent);
+	CallCallback(nExtTextEventType, pExtTextEvent);
 
 	switch (nExtTextEventType)
 	{
 		case SALEVENT_ENDEXTTEXTINPUT:
-
 			break;
 
 		case SALEVENT_EXTTEXTINPUT:
@@ -2087,42 +2016,40 @@ SalFrameData::HandleExtTextEvent (XClien
 
 		default:
 
-			fprintf(stderr, "SalFrameData::HandleExtTextEvent: invalid extended input\n");
+			fprintf(stderr, "X11SalFrame::HandleExtTextEvent: invalid extended input\n");
 	}
 }
 #endif /* defined(__synchronous_extinput__) */
 
 // PostEvent
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-BOOL SalFrame::PostEvent( void *pData )
+BOOL X11SalFrame::PostEvent( void *pData )
 {
-	_GetDisplay()->SendEvent( _GetDisplay()->getWMAdaptor()->getAtom( WMAdaptor::SAL_USEREVENT ),
-							  pData,
-							  maFrameData.GetWindow() );
+    GetDisplay()->SendInternalEvent( this, pData );
 	return TRUE;
 }
 
 // Title
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrame::SetTitle( const XubString& rTitle )
+void X11SalFrame::SetTitle( const XubString& rTitle )
 {
-    if( ! ( (maFrameData.nStyle_ & SAL_FRAME_STYLE_CHILD ) ||
-            (maFrameData.nStyle_ & SAL_FRAME_STYLE_FLOAT ) ) )
-        _GetDisplay()->getWMAdaptor()->setWMName( this, rTitle );
+    if( ! ( (nStyle_ & SAL_FRAME_STYLE_CHILD ) ||
+            (nStyle_ & SAL_FRAME_STYLE_FLOAT ) ) )
+        GetDisplay()->getWMAdaptor()->setWMName( this, rTitle );
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::Flush()
+void X11SalFrame::Flush()
 {
-	XFlush( _GetDisplay()->GetDisplay() );
+	XFlush( GetDisplay()->GetDisplay() );
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::Sync()
+void X11SalFrame::Sync()
 {
-	XSync( _GetDisplay()->GetDisplay(), False );
+	XSync( GetDisplay()->GetDisplay(), False );
 }
 
 // Keyboard
@@ -2130,7 +2057,7 @@ void SalFrame::Sync()
 
 // -----------------------------------------------------------------------
 
-void SalFrame::SetInputContext( SalInputContext* pContext )
+void X11SalFrame::SetInputContext( SalInputContext* pContext )
 {
   	if (pContext == NULL)
 		return;
@@ -2140,54 +2067,54 @@ void SalFrame::SetInputContext( SalInput
 
   	if (!(pContext->mnOptions & SAL_INPUTCONTEXT_TEXT))
     {
-        if( maFrameData.mpInputContext )
-            maFrameData.mpInputContext->Unmap( this );
+        if( mpInputContext )
+            mpInputContext->Unmap( this );
 		return;
     }
 
 	// 2. We should use on-the-spot inputstyle
   	//    only when SAL_INPUTCONTEXT_EXTTEXTINPUT is set.
 
-  	if (maFrameData.mpInputContext == NULL)
+  	if (mpInputContext == NULL)
 	{
         I18NStatus& rStatus( I18NStatus::get() );
         rStatus.setParent( this );
-        maFrameData.mpInputContext = rStatus.getInputContext( maFrameData.mbDeleteInputContext );
-		if (maFrameData.mpInputContext->UseContext())
+        mpInputContext = rStatus.getInputContext( mbDeleteInputContext );
+		if (mpInputContext->UseContext())
 		{
-	  		maFrameData.mpInputContext->ExtendEventMask( maFrameData.GetShellWindow() );
+	  		mpInputContext->ExtendEventMask( GetShellWindow() );
 	  		if (pContext->mnOptions & SAL_INPUTCONTEXT_CHANGELANGUAGE)
-				maFrameData.mpInputContext->SetLanguage(pContext->meLanguage);
-			if (maFrameData.mbInputFocus)
-				maFrameData.mpInputContext->SetICFocus( this );
+				mpInputContext->SetLanguage(pContext->meLanguage);
+			if (mbInputFocus)
+				mpInputContext->SetICFocus( this );
 		}
   	}
     else
-        maFrameData.mpInputContext->Map( this );
+        mpInputContext->Map( this );
   	return;
 }
 
 // -----------------------------------------------------------------------
 
-void SalFrame::EndExtTextInput( USHORT nFlags )
+void X11SalFrame::EndExtTextInput( USHORT nFlags )
 {
-    if (maFrameData.mpInputContext != NULL)
-  	    maFrameData.mpInputContext->EndExtTextInput( nFlags );
+    if (mpInputContext != NULL)
+  	    mpInputContext->EndExtTextInput( nFlags );
 }
 
 // -----------------------------------------------------------------------
 
-XubString SalFrame::GetKeyName( USHORT nKeyCode )
+XubString X11SalFrame::GetKeyName( USHORT nKeyCode )
 {
-	return _GetDisplay()->GetKeyName( nKeyCode );
+	return GetDisplay()->GetKeyName( nKeyCode );
 }
 
-XubString SalFrame::GetSymbolKeyName( const XubString&, USHORT nKeyCode )
+XubString X11SalFrame::GetSymbolKeyName( const XubString&, USHORT nKeyCode )
 {
   return GetKeyName( nKeyCode );
 }
 
-LanguageType SalFrame::GetInputLanguage()
+LanguageType X11SalFrame::GetInputLanguage()
 {
     // could be improved by checking unicode ranges of the last input
     return LANGUAGE_DONTKNOW;
@@ -2201,10 +2128,10 @@ inline Color getColorFromLong( long nCol
 	return Color( (nColor & 0xff), (nColor & 0xff00)>>8, (nColor & 0xff0000)>>16);
 }
 
-void SalFrame::UpdateSettings( AllSettings& rSettings )
+void X11SalFrame::UpdateSettings( AllSettings& rSettings )
 {
 
-    DtIntegrator* pIntegrator = DtIntegrator::CreateDtIntegrator( this );
+    DtIntegrator* pIntegrator = DtIntegrator::CreateDtIntegrator();
 #if OSL_DEBUG_LEVEL > 1
     fprintf( stderr, "DtIntegrator: %d\n", pIntegrator ? pIntegrator->GetDtType() : -1 );
 #endif
@@ -2212,27 +2139,32 @@ void SalFrame::UpdateSettings( AllSettin
         pIntegrator->GetSystemLook( rSettings );
 }
 
+void X11SalFrame::CaptureMouse( BOOL bCapture )
+{
+    nCaptured_ = pDisplay_->CaptureMouse( bCapture ? this : NULL );
+}
+
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-void SalFrame::SetParent( SalFrame* pNewParent )
+void X11SalFrame::SetParent( SalFrame* pNewParent )
 {
-    if( maFrameData.mpParent != pNewParent )
+    if( mpParent != pNewParent )
     {
-        if( maFrameData.mpParent )
-            maFrameData.mpParent->maFrameData.maChildren.remove( this );
+        if( mpParent )
+            mpParent->maChildren.remove( this );
 
-        maFrameData.mpParent = pNewParent;
-        pNewParent->maFrameData.maChildren.push_back( this );
-        maFrameData.GetDisplay()->getWMAdaptor()->changeReferenceFrame( this, pNewParent );
+        mpParent = static_cast<X11SalFrame*>(pNewParent);
+        mpParent->maChildren.push_back( this );
+        GetDisplay()->getWMAdaptor()->changeReferenceFrame( this, mpParent );
     }
 }
 
-SalFrame* SalFrame::GetParent() const
+SalFrame* X11SalFrame::GetParent() const
 {
-    return maFrameData.mpParent;
+    return mpParent;
 }
 
-bool SalFrameData::SetPluginParent( SystemParentData* pNewParent )
+bool X11SalFrame::SetPluginParent( SystemParentData* pNewParent )
 {
     // plugin parent may be killed unexpectedly by
     // plugging process; ignore XErrors in that case
@@ -2241,8 +2173,8 @@ bool SalFrameData::SetPluginParent( Syst
     // first deinit frame
     if( mpInputContext )
     {
-        mpInputContext->UnsetICFocus( pFrame_ );
-        mpInputContext->Unmap( pFrame_ );
+        mpInputContext->UnsetICFocus( this );
+        mpInputContext->Unmap( this );
     }
     if( GetWindow() == hPresentationWindow )
     {
@@ -2262,28 +2194,24 @@ bool SalFrameData::SetPluginParent( Syst
     else
 	    Init( nStyle_ & ~SAL_FRAME_STYLE_CHILD, pNewParent );
 
-    // update graphics if necessary
-    if( pGraphics_ )
-        pGraphics_->maGraphicsData.SetDrawable( mhWindow );
+	// update graphics if necessary
+	if( pGraphics_ )
+        pGraphics_->SetDrawable( mhWindow );
+    if( pFreeGraphics_ )
+        pFreeGraphics_->SetDrawable( mhWindow );
 
     return true;
 }
 
-bool SalFrame::SetPluginParent( SystemParentData* pNewParent )
-{
-    return maFrameData.SetPluginParent( pNewParent );
-}
-
-
 // Sound
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrame::Beep( SoundType eSoundType ) // not fully suported
+void X11SalFrame::Beep( SoundType eSoundType ) // not fully suported
 {
     switch( eSoundType )
     {
         case SOUND_DEFAULT:
         case SOUND_ERROR:
-            _GetDisplay()->Beep();
+            GetDisplay()->Beep();
             break;
         default:
             // Excessive beeping averted
@@ -2291,14 +2219,6 @@ void SalFrame::Beep( SoundType eSoundTyp
     }
 }
 
-// Callback
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-void SalFrame::SetCallback( void* pInst, SALFRAMEPROC pProc )
-{
-	maFrameData.pInst_ = pInst;
-	maFrameData.pProc_ = pProc ? pProc : sal_CallbackDummy;
-}
-
 // Event Handling
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 static USHORT sal_GetCode( int state )
@@ -2314,11 +2234,7 @@ static USHORT sal_GetCode( int state )
 
 	if( state & ShiftMask )
 		nCode |= KEY_SHIFT;
-#ifdef MACOSX
-	if( ( state & ControlMask ) || ( state & Mod2Mask ) )
-#else
 	if( state & ControlMask )
-#endif
 		nCode |= KEY_MOD1;
 	if( state & Mod1Mask )
 		nCode |= KEY_MOD2;
@@ -2328,13 +2244,13 @@ static USHORT sal_GetCode( int state )
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-ULONG SalFrame::GetCurrentModButtons()
+ULONG X11SalFrame::GetCurrentModButtons()
 {
     XLIB_Window aRoot, aChild;
     int rx, ry, wx, wy;
     unsigned int nMask = 0;
-    XQueryPointer( maFrameData.GetXDisplay(),
-                   maFrameData.GetShellWindow(),
+    XQueryPointer( GetXDisplay(),
+                   GetShellWindow(),
                    &aRoot,
                    &aChild,
                    &rx, &ry,
@@ -2344,7 +2260,7 @@ ULONG SalFrame::GetCurrentModButtons()
     return sal_GetCode( nMask );
 }
 
-long SalFrameData::HandleMouseEvent( XEvent *pEvent )
+long X11SalFrame::HandleMouseEvent( XEvent *pEvent )
 {
 	SalMouseEvent		aMouseEvt;
 	USHORT				nEvent = 0;
@@ -2432,9 +2348,9 @@ long SalFrameData::HandleMouseEvent( XEv
 		nEvent				= SALEVENT_MOUSEMOVE;
         if( nVisibleFloats > 0 && mpParent )
         {
-            XLIB_Cursor aCursor = mpParent->maFrameData.GetCursor();
-            if( pEvent->xmotion.x >= 0 && pEvent->xmotion.x < (int)pFrame_->maGeometry.nWidth &&
-                pEvent->xmotion.y >= 0 && pEvent->xmotion.y < (int)pFrame_->maGeometry.nHeight )
+            XLIB_Cursor aCursor = mpParent->GetCursor();
+            if( pEvent->xmotion.x >= 0 && pEvent->xmotion.x < (int)maGeometry.nWidth &&
+                pEvent->xmotion.y >= 0 && pEvent->xmotion.y < (int)maGeometry.nHeight )
                 aCursor = None;
 
             XChangeActivePointerGrab( GetXDisplay(),
@@ -2453,10 +2369,12 @@ long SalFrameData::HandleMouseEvent( XEv
             // see if the user clicks outside all of the floats
             // if yes release the grab
             bool bInside = false;
- 			for( SalFrame* pFrame = GetSalData()->pFirstFrame_; pFrame; pFrame = pFrame->maFrameData.pNextFrame_ )
+            const std::list< SalFrame* >& rFrames = GetDisplay()->getFrames();
+            for( std::list< SalFrame* >::const_iterator it = rFrames.begin(); it != rFrames.end(); ++it )
             {
-                if( pFrame->maFrameData.IsFloatGrabWindow()										&&
-                    pFrame->maFrameData.bMapped_												&&
+                X11SalFrame* pFrame = static_cast< X11SalFrame* >(*it);
+                if( pFrame->IsFloatGrabWindow()										&&
+                    pFrame->bMapped_												&&
                     pEvent->xbutton.x_root >= pFrame->maGeometry.nX								&&
                     pEvent->xbutton.x_root < pFrame->maGeometry.nX + (int)pFrame->maGeometry.nWidth	&&
                     pEvent->xbutton.y_root >= pFrame->maGeometry.nY								&&
@@ -2473,6 +2391,38 @@ long SalFrameData::HandleMouseEvent( XEv
                 // is not grabbed
                 XUngrabPointer( GetXDisplay(), CurrentTime );
                 bClosePopups = true;
+
+                /*  #i15246# only close popups if pointer is outside all our frames
+                 *  cannot use our own geometry data here because stacking
+                 *  is unknown (the above case implicitly assumes
+                 *  that floats are on top which should be true)
+                 */
+                XLIB_Window aRoot, aChild;
+                int root_x, root_y, win_x, win_y;
+                unsigned int mask_return;
+                if( XQueryPointer( GetXDisplay(), GetDisplay()->GetRootWindow(),
+                                   &aRoot, &aChild,
+                                   &root_x, &root_y,
+                                   &win_x, &win_y,
+                                   &mask_return )
+                    && aChild // pointer may not be in any child
+                    )
+                {
+                    const std::list< SalFrame* >& rFrames = GetDisplay()->getFrames();
+                    for( std::list< SalFrame* >::const_iterator it = rFrames.begin(); it != rFrames.end(); ++it )
+                    {
+                        X11SalFrame* pFrame = static_cast< X11SalFrame* >(*it);
+                        if( ! pFrame->IsFloatGrabWindow()
+                            && ( pFrame->GetWindow() == aChild ||
+                                 pFrame->GetShellWindow() == aChild ||
+                                 pFrame->GetStackingWindow() == aChild )
+                            )
+                        {
+                            bClosePopups = false;
+                            break;
+                        }
+                    }
+                }
             }
         }
 
@@ -2528,7 +2478,7 @@ long SalFrameData::HandleMouseEvent( XEv
             // --- RTL --- (mirror mouse pos)
             if( Application::GetSettings().GetLayoutRTL() )
                 aWheelEvt.mnX = nWidth_-1-aWheelEvt.mnX;
-			return Call( nEvent, &aWheelEvt );
+			return CallCallback( nEvent, &aWheelEvt );
 		}
 	}
 
@@ -2542,7 +2492,7 @@ long SalFrameData::HandleMouseEvent( XEv
         // --- RTL --- (mirror mouse pos)
         if( Application::GetSettings().GetLayoutRTL() )
             aMouseEvt.mnX = nWidth_-1-aMouseEvt.mnX;
-		nRet = Call( nEvent, &aMouseEvt );
+		nRet = CallCallback( nEvent, &aMouseEvt );
     }
 
     if( bClosePopups )
@@ -2568,19 +2518,19 @@ long SalFrameData::HandleMouseEvent( XEv
 // rest of the eventhandler.
 //
 void
-SalFrameData::RegisterDeleteData (SalFrameDelData *pData)
+X11SalFrame::RegisterDeleteData (SalFrameDelData *pData)
 {
     pData->SetNext (mpDeleteData);
     mpDeleteData = pData;
 }
 void
-SalFrameData::NotifyDeleteData ()
+X11SalFrame::NotifyDeleteData ()
 {
     for (SalFrameDelData* pData = mpDeleteData; pData != NULL; pData = pData->GetNext())
         pData->Delete();
 }
 void
-SalFrameData::UnregisterDeleteData (SalFrameDelData *pData)
+X11SalFrame::UnregisterDeleteData (SalFrameDelData *pData)
 {
     if (mpDeleteData == pData)
     {
@@ -2620,7 +2570,7 @@ GetAlternateKeyCode( const USHORT nKeyCo
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-long SalFrameData::HandleKeyEvent( XKeyEvent *pEvent )
+long X11SalFrame::HandleKeyEvent( XKeyEvent *pEvent )
 {
 	KeySym			nKeySym;
 	int 			nLen = 2048;
@@ -2656,11 +2606,7 @@ long SalFrameData::HandleKeyEvent( XKeyE
 
 	if( pEvent->state & ShiftMask )
 		nModCode |= KEY_SHIFT;
-#ifdef MACOSX
-	if ( ( pEvent->state & ControlMask ) || ( pEvent->state & Mod2Mask ) )
-#else
 	if( pEvent->state & ControlMask )
-#endif
 		nModCode |= KEY_MOD1;
 	if( pEvent->state & Mod1Mask )
 	{
@@ -2716,16 +2662,6 @@ long SalFrameData::HandleKeyEvent( XKeyE
                 nExtModMask = MODKEY_RSHIFT;
                 nModMask = KEY_SHIFT;
                 break;
-#ifdef MACOSX
-            case XK_Meta_L:
-                nExtModMask = MODKEY_LMOD1;
-                nModMask = KEY_MOD1;
-                break;
-            case XK_Meta_R:
-                nExtModMask = MODKEY_RMOD1;
-                nModMask = KEY_MOD1;
-                break;
-#endif
         }
         if( pEvent->type == KeyRelease )
         {
@@ -2741,7 +2677,7 @@ long SalFrameData::HandleKeyEvent( XKeyE
 		aModEvt.mnCode = nModCode;
 		aModEvt.mnTime = pEvent->time;
 
-		int nRet = Call( SALEVENT_KEYMODCHANGE, &aModEvt );
+		int nRet = CallCallback( SALEVENT_KEYMODCHANGE, &aModEvt );
 
         // emulate KEY_MENU
         if ( ( (nKeySym == XK_Alt_L) || (nKeySym == XK_Alt_R) ) &&
@@ -2756,8 +2692,8 @@ long SalFrameData::HandleKeyEvent( XKeyE
                 aKeyEvt.mnRepeat   = 0;
                 aKeyEvt.mnTime	   = pEvent->time;
                 aKeyEvt.mnCharCode = 0;
-                nRet = Call( SALEVENT_KEYINPUT, &aKeyEvt );
-                nRet = Call( SALEVENT_KEYUP, &aKeyEvt );
+                nRet = CallCallback( SALEVENT_KEYINPUT, &aKeyEvt );
+                nRet = CallCallback( SALEVENT_KEYUP, &aKeyEvt );
             }
         }
         else
@@ -2852,11 +2788,11 @@ long SalFrameData::HandleKeyEvent( XKeyE
 
 		if( KeyRelease == pEvent->type )
 		{
-			Call( SALEVENT_KEYUP, &aKeyEvt );
+			CallCallback( SALEVENT_KEYUP, &aKeyEvt );
 		}
 		else
 		{
-			if ( ! Call(SALEVENT_KEYINPUT, &aKeyEvt) )
+			if ( ! CallCallback(SALEVENT_KEYINPUT, &aKeyEvt) )
 			{
 				// independent layer doesnt want to handle key-event, so check
 				// whether the keycode may have an alternate meaning
@@ -2866,7 +2802,7 @@ long SalFrameData::HandleKeyEvent( XKeyE
 					aKeyEvt.mnCode = aAlternate.nKeyCode | nModCode;
 					if( aAlternate.nCharCode )
 						aKeyEvt.mnCharCode = aAlternate.nCharCode;
-					Call(SALEVENT_KEYINPUT, &aKeyEvt);
+					CallCallback(SALEVENT_KEYINPUT, &aKeyEvt);
 				}
                 else
                 if (pEvent->keycode != 0)
@@ -2878,7 +2814,7 @@ long SalFrameData::HandleKeyEvent( XKeyE
                     if ((nKeyCode != 0) && ((nKeyCode | nModCode) != aKeyEvt.mnCode))
                     {
                         aKeyEvt.mnCode = nKeyCode | nModCode;
-					    Call(SALEVENT_KEYINPUT, &aKeyEvt);
+					    CallCallback(SALEVENT_KEYINPUT, &aKeyEvt);
                     }
                 }
 			}
@@ -2902,7 +2838,7 @@ long SalFrameData::HandleKeyEvent( XKeyE
 
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-long SalFrameData::HandleFocusEvent( XFocusChangeEvent *pEvent )
+long X11SalFrame::HandleFocusEvent( XFocusChangeEvent *pEvent )
 {
     // #107739# ReflectionX in Windows mode changes focus while mouse is grabbed
 	if( nVisibleFloats > 0 && GetDisplay()->getWMAdaptor()->getWindowManagerName().EqualsAscii( "ReflectionX Windows" ) )
@@ -2921,13 +2857,13 @@ long SalFrameData::HandleFocusEvent( XFo
 	if ( mpInputContext != NULL  )
 	{
 		if( FocusIn == pEvent->type )
-            mpInputContext->SetICFocus( pFrame_ );
+            mpInputContext->SetICFocus( this );
         else
         {
             /*
              *  do not unset the IC focuse here because would kill
              *  a lookup choice windows that might have the focus now
-             *  	mpInputContext->UnsetICFocus( pFrame_ );
+             *  	mpInputContext->UnsetICFocus( this );
              */
             I18NStatus::get().show( false, I18NStatus::focus );
         }
@@ -2944,7 +2880,7 @@ long SalFrameData::HandleFocusEvent( XFo
 		if( FocusIn == pEvent->type )
 		{
 #ifndef _USE_PRINT_EXTENSION_
-            if( GetSalData()->pFirstInstance_->maInstData.mbPrinterInit )
+            if( static_cast< X11SalInstance* >(GetSalData()->pInstance_)->isPrinterInit() )
                 vcl_sal::PrinterUpdate::update();
 #endif
 			mbInputFocus = True;
@@ -2952,7 +2888,7 @@ long SalFrameData::HandleFocusEvent( XFo
 
 
 
-			long nRet = Call( SALEVENT_GETFOCUS,  0 );
+			long nRet = CallCallback( SALEVENT_GETFOCUS,  0 );
             if ((mpParent != NULL && nStyle_ == 0)
                 && pSVData->maWinData.mpFirstFloat )
             {
@@ -2967,7 +2903,7 @@ long SalFrameData::HandleFocusEvent( XFo
 			mbInputFocus = False;
             mbSendExtKeyModChange = mbKeyMenu = false;
             mnExtKeyMod = 0;
-			return Call( SALEVENT_LOSEFOCUS, 0 );
+			return CallCallback( SALEVENT_LOSEFOCUS, 0 );
 		}
 	}
 
@@ -2976,41 +2912,7 @@ long SalFrameData::HandleFocusEvent( XFo
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-extern "C" 
-{
-    static Bool GraphicsExposePredicate( Display* pDisplay, XEvent* pEvent, XPointer pSFrame )
-    {
-        Bool bRet = False;
-        SalFrameData* pFrame = (SalFrameData*)pSFrame;
-        if( (pEvent->type == GraphicsExpose || pEvent->type == NoExpose) &&
-            pEvent->xnoexpose.drawable == pFrame->GetWindow() )
-        {
-            bRet = True;
-        }
-        return bRet;
-    }
-}
-
-void SalFrameData::YieldGraphicsExpose()
-{
-    XEvent aEvent;
-    do
-    {
-        while( XCheckTypedWindowEvent( GetXDisplay(), GetWindow(), Expose, &aEvent ) )
-            HandleExposeEvent( &aEvent );
-
-        XIfEvent( GetXDisplay(), &aEvent, GraphicsExposePredicate, (XPointer)this );
-        if( aEvent.type == NoExpose )
-            return;
-
-        HandleExposeEvent( &aEvent );
-    } while( aEvent.xgraphicsexpose.count != 0 );
-}
-
-
-// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-long SalFrameData::HandleExposeEvent( XEvent *pEvent )
+long X11SalFrame::HandleExposeEvent( XEvent *pEvent )
 {
 	XRectangle	aRect;
 	USHORT		nCount = 0;
@@ -3030,7 +2932,6 @@ long SalFrameData::HandleExposeEvent( XE
 		aRect.width 	= pEvent->xgraphicsexpose.width;
 		aRect.height	= pEvent->xgraphicsexpose.height;
 		nCount			= pEvent->xgraphicsexpose.count;
-        mbWasGraphicsPaint = true;
 	}
 
     if( IsOverrideRedirect() && mbFullScreen &&
@@ -3042,7 +2943,7 @@ long SalFrameData::HandleExposeEvent( XE
     // width and height are extents, so they are of by one for rectangle
     maPaintRegion.Union( Rectangle( Point(aRect.x, aRect.y), Size(aRect.width+1, aRect.height+1) ) );
 
-	if( nCount || (maResizeTimer.IsActive() && ! mbWasGraphicsPaint) )
+	if( nCount || maResizeTimer.IsActive() )
         // wait for last expose rectangle, do not wait for resize timer
         // if a completed graphics expose sequence is available
 		return 1;
@@ -3058,14 +2959,13 @@ long SalFrameData::HandleExposeEvent( XE
     if( Application::GetSettings().GetLayoutRTL() )
         aPEvt.mnBoundX = nWidth_-aPEvt.mnBoundWidth-aPEvt.mnBoundX;
 
- 	Call( SALEVENT_PAINT, &aPEvt );
-    mbWasGraphicsPaint = false;
+ 	CallCallback( SALEVENT_PAINT, &aPEvt );
     maPaintRegion = Rectangle();
 
 	return 1;
 }
 
-void SalFrameData::RestackChildren( XLIB_Window* pTopLevelWindows, int nTopLevelWindows )
+void X11SalFrame::RestackChildren( XLIB_Window* pTopLevelWindows, int nTopLevelWindows )
 {
     if( maChildren.begin() != maChildren.end() )
     {
@@ -3076,10 +2976,10 @@ void SalFrameData::RestackChildren( XLIB
         if( nWindow < 0 )
             return;
 
-        ::std::list< SalFrame* >::const_iterator it;
+        std::list< X11SalFrame* >::const_iterator it;
         for( it = maChildren.begin(); it != maChildren.end(); ++it )
         {
-            SalFrameData* pData = &(*it)->maFrameData;
+            X11SalFrame* pData = *it;
             if( pData->bMapped_ )
             {
                 int nChild = nWindow;
@@ -3100,13 +3000,13 @@ void SalFrameData::RestackChildren( XLIB
         }
         for( it = maChildren.begin(); it != maChildren.end(); ++it )
         {
-            SalFrameData* pData = &(*it)->maFrameData;
+            X11SalFrame* pData = *it;
             pData->RestackChildren( pTopLevelWindows, nTopLevelWindows );
         }
     }
 }
 
-void SalFrameData::RestackChildren()
+void X11SalFrame::RestackChildren()
 {
     if( ! GetDisplay()->getWMAdaptor()->isTransientBehaviourAsExpected()
         && maChildren.begin() != maChildren.end() )
@@ -3127,7 +3027,7 @@ void SalFrameData::RestackChildren()
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-long SalFrameData::HandleSizeEvent( XConfigureEvent *pEvent )
+long X11SalFrame::HandleSizeEvent( XConfigureEvent *pEvent )
 {
 	if (   pEvent->window != GetShellWindow()
            && pEvent->window != GetWindow()
@@ -3166,11 +3066,11 @@ long SalFrameData::HandleSizeEvent( XCon
 
     if( pEvent->window == GetStackingWindow() )
     {
-        if( pFrame_->maGeometry.nX != pEvent->x || pFrame_->maGeometry.nY != pEvent->y )
+        if( maGeometry.nX != pEvent->x || maGeometry.nY != pEvent->y )
         {
-            pFrame_->maGeometry.nX = pEvent->x;
-            pFrame_->maGeometry.nY = pEvent->y;
-            Call( SALEVENT_MOVE, NULL );
+            maGeometry.nX = pEvent->x;
+            maGeometry.nY = pEvent->y;
+            CallCallback( SALEVENT_MOVE, NULL );
         }
         return 1;
     }
@@ -3183,38 +3083,38 @@ long SalFrameData::HandleSizeEvent( XCon
     nHeight_	= pEvent->height;
 
     if( !mbMoved )
-        mbMoved = ( pEvent->x != pFrame_->maGeometry.nX || pEvent->y != pFrame_->maGeometry.nY );
+        mbMoved = ( pEvent->x != maGeometry.nX || pEvent->y != maGeometry.nY );
     if( !mbSized )
-        mbSized = ( pEvent->width != pFrame_->maGeometry.nWidth || pEvent->height != pFrame_->maGeometry.nHeight );
+        mbSized = ( pEvent->width != maGeometry.nWidth || pEvent->height != maGeometry.nHeight );
 
     maResizeTimer.Start();
 
-    pFrame_->maGeometry.nX		= pEvent->x;
-    pFrame_->maGeometry.nY		= pEvent->y;
-    pFrame_->maGeometry.nWidth	= pEvent->width;
-    pFrame_->maGeometry.nHeight	= pEvent->height;
+    maGeometry.nX		= pEvent->x;
+    maGeometry.nY		= pEvent->y;
+    maGeometry.nWidth	= pEvent->width;
+    maGeometry.nHeight	= pEvent->height;
 
 	return 1;
 }
 
-IMPL_LINK( SalFrameData, HandleAlwaysOnTopRaise, void*, pDummy )
+IMPL_LINK( X11SalFrame, HandleAlwaysOnTopRaise, void*, pDummy )
 {
     if( bMapped_ )
-        pFrame_->ToTop( 0 );
+        ToTop( 0 );
     return 0;
 }
 
-IMPL_LINK( SalFrameData, HandleResizeTimer, void*, pDummy )
+IMPL_LINK( X11SalFrame, HandleResizeTimer, void*, pDummy )
 {
 	// update children's position
 	RestackChildren();
 
     if( mbSized && ! mbMoved )
-        Call ( SALEVENT_RESIZE, NULL );
+        CallCallback( SALEVENT_RESIZE, NULL );
     else if( mbMoved && ! mbSized )
-        Call ( SALEVENT_MOVE, NULL );
+        CallCallback( SALEVENT_MOVE, NULL );
     else if( mbMoved && mbSized )
-        Call ( SALEVENT_MOVERESIZE, NULL );
+        CallCallback( SALEVENT_MOVERESIZE, NULL );
 
     mbMoved = mbSized = false;
 
@@ -3228,15 +3128,14 @@ IMPL_LINK( SalFrameData, HandleResizeTim
     if( Application::GetSettings().GetLayoutRTL() )
         aPEvt.mnBoundX = nWidth_-aPEvt.mnBoundWidth-aPEvt.mnBoundX;
 
-	Call( SALEVENT_PAINT, &aPEvt );
-    mbWasGraphicsPaint = false;
+	CallCallback( SALEVENT_PAINT, &aPEvt );
     maPaintRegion = Rectangle();
 
 	return 0;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-long SalFrameData::HandleReparentEvent( XReparentEvent *pEvent )
+long X11SalFrame::HandleReparentEvent( XReparentEvent *pEvent )
 {
 	Display 	   *pDisplay   = pEvent->display;
 	XLIB_Window 	hWM_Parent;
@@ -3274,7 +3173,7 @@ long SalFrameData::HandleReparentEvent( 
             hWM_Parent = GetShellWindow();
             break;
         }
-        /* #107048# this sometimes happens if a Show(TRUE) is
+         /* #107048# this sometimes happens if a Show(TRUE) is
          *  immediately followed by Show(FALSE) (which is braindead anyway)
          */
         if(  hDummy == hWM_Parent )
@@ -3343,20 +3242,6 @@ long SalFrameData::HandleReparentEvent( 
         aPresentationReparentList.push_back( GetStackingWindow() );
     }
 
-#ifdef NC_EVENTS
-	XQueryTree( pDisplay,
-				hWM_Parent,
-				&hRoot,
-				&hDummy,
-				&Children,
-				&nChildren );
-
-	for( n = 0; n < nChildren; n++ )
-		if( Children[n] != hShell_ && Children[n] != pEvent->parent )
-			XSelectInput( pDisplay, Children[n], NC_EVENTS );
-	XFree( Children );
-#endif
-
     int nLeft = 0, nTop = 0;
 	XTranslateCoordinates( GetXDisplay(),
                            GetShellWindow(),
@@ -3365,8 +3250,8 @@ long SalFrameData::HandleReparentEvent( 
                            &nLeft,
                            &nTop,
                            &hDummy );
-    pFrame_->maGeometry.nLeftDecoration	= nLeft > 0 ? nLeft-1 : 0;
-    pFrame_->maGeometry.nTopDecoration	= nTop  > 0 ? nTop-1  : 0;
+    maGeometry.nLeftDecoration	= nLeft > 0 ? nLeft-1 : 0;
+    maGeometry.nTopDecoration	= nTop  > 0 ? nTop-1  : 0;
 
     /*
      *  decorations are not symmetric,
@@ -3386,17 +3271,17 @@ long SalFrameData::HandleReparentEvent( 
     bool bResized = false;
     if( ! GetDisplay()->GetXLib()->WasXError() )
     {
-        pFrame_->maGeometry.nRightDecoration 	= wp - w - pFrame_->maGeometry.nLeftDecoration;
-        pFrame_->maGeometry.nBottomDecoration	= hp - h - pFrame_->maGeometry.nTopDecoration;
+        maGeometry.nRightDecoration 	= wp - w - maGeometry.nLeftDecoration;
+        maGeometry.nBottomDecoration	= hp - h - maGeometry.nTopDecoration;
         /*
          *  note: this works because hWM_Parent is direct child of root,
          *  not necessarily parent of GetShellWindow()
          */
-        pFrame_->maGeometry.nX		= xp + nLeft;
-        pFrame_->maGeometry.nY		= yp + nTop;
-        bResized = w != pFrame_->maGeometry.nWidth || h != pFrame_->maGeometry.nHeight;
-        pFrame_->maGeometry.nWidth	= w;
-        pFrame_->maGeometry.nHeight = h;
+        maGeometry.nX		= xp + nLeft;
+        maGeometry.nY		= yp + nTop;
+        bResized = w != maGeometry.nWidth || h != maGeometry.nHeight;
+        maGeometry.nWidth	= w;
+        maGeometry.nHeight = h;
     }
 
     // limit width and height if we are too large: #47757
@@ -3404,22 +3289,22 @@ long SalFrameData::HandleReparentEvent( 
 
     int nScreenWidth  = pDisplay_->GetScreenSize().Width();
     int nScreenHeight = pDisplay_->GetScreenSize().Height();
-    int nFrameWidth   = pFrame_->maGeometry.nWidth + pFrame_->maGeometry.nLeftDecoration + pFrame_->maGeometry.nRightDecoration;
-    int nFrameHeight  = pFrame_->maGeometry.nHeight + pFrame_->maGeometry.nTopDecoration  + pFrame_->maGeometry.nBottomDecoration;
+    int nFrameWidth   = maGeometry.nWidth + maGeometry.nLeftDecoration + maGeometry.nRightDecoration;
+    int nFrameHeight  = maGeometry.nHeight + maGeometry.nTopDecoration  + maGeometry.nBottomDecoration;
 
     if ((nFrameWidth > nScreenWidth) || (nFrameHeight > nScreenHeight))
     {
-        Size aSize(pFrame_->maGeometry.nWidth, pFrame_->maGeometry.nHeight);
+        Size aSize(maGeometry.nWidth, maGeometry.nHeight);
 
         if (nFrameWidth  > nScreenWidth)
-            aSize.Width()  = nScreenWidth  - pFrame_->maGeometry.nRightDecoration - pFrame_->maGeometry.nLeftDecoration;
+            aSize.Width()  = nScreenWidth  - maGeometry.nRightDecoration - maGeometry.nLeftDecoration;
         if (nFrameHeight > nScreenHeight)
-            aSize.Height() = nScreenHeight - pFrame_->maGeometry.nBottomDecoration - pFrame_->maGeometry.nTopDecoration;
+            aSize.Height() = nScreenHeight - maGeometry.nBottomDecoration - maGeometry.nTopDecoration;
 
         SetSize (aSize);
     }
     else if( bResized )
-        Call( SALEVENT_RESIZE, NULL );
+        CallCallback( SALEVENT_RESIZE, NULL );
 
     GetDisplay()->GetXLib()->SetIgnoreXErrors( bOldIgnore );
 
@@ -3427,13 +3312,13 @@ long SalFrameData::HandleReparentEvent( 
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-long SalFrameData::HandleColormapEvent( XColormapEvent *pEvent )
+long X11SalFrame::HandleColormapEvent( XColormapEvent *pEvent )
 {
 	return 0;
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-long SalFrameData::HandleStateEvent( XPropertyEvent *pEvent )
+long X11SalFrame::HandleStateEvent( XPropertyEvent *pEvent )
 {
 	Atom		  actual_type;
 	int 		  actual_format;
@@ -3471,21 +3356,10 @@ long SalFrameData::HandleStateEvent( XPr
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-long SalFrameData::HandleClientMessage( XClientMessageEvent *pEvent )
+long X11SalFrame::HandleClientMessage( XClientMessageEvent *pEvent )
 {
     const WMAdaptor& rWMAdaptor( *pDisplay_->getWMAdaptor() );
 
-	if( pEvent->message_type == rWMAdaptor.getAtom( WMAdaptor::SAL_USEREVENT ) )
-	{
-#if __SIZEOFLONG > 4
-		void* pData = (void*)
-			( (pEvent->data.l[0] & 0xffffffff) | (pEvent->data.l[1] << 32) );
-#else
-		void* pData = (void*)(pEvent->data.l[0]);
-#endif
-		Call( SALEVENT_USEREVENT, pData );
-		return 1;
-	}
 #if !defined(__synchronous_extinput__)
 	if( pEvent->message_type == rWMAdaptor.getAtom( WMAdaptor::SAL_EXTTEXTEVENT ) )
 	{
@@ -3495,7 +3369,7 @@ long SalFrameData::HandleClientMessage( 
 #endif
 	else if( pEvent->message_type == rWMAdaptor.getAtom( WMAdaptor::SAL_QUITEVENT ) )
 	{
-		stderr0( "SalFrameData::Dispatch Quit\n" );
+		stderr0( "X11SalFrame::Dispatch Quit\n" );
 		Close(); // ???
 		return 1;
 	}
@@ -3515,7 +3389,7 @@ long SalFrameData::HandleClientMessage( 
             
             if( ! bSession )
             {
-                if( pFrame_ == s_pSaveYourselfFrame )
+                if( this == s_pSaveYourselfFrame )
                 {
                     ByteString aExec( SessionManagerClient::getExecName(), osl_getThreadTextEncoding() );
                     const char* argv[2];
@@ -3535,17 +3409,17 @@ long SalFrameData::HandleClientMessage( 
                 // save open documents; would be good for non Dtwm, too,
                 // but there is no real Shutdown message in the ancient
                 // SM protocol; on Dtwm SaveYourself really means Shutdown, too.
-                IceSalSession::handleOldX11SaveYourself( pFrame_ );
+                IceSalSession::handleOldX11SaveYourself( this );
             }
 		}
 	}
 	return 0;
 }
 
-void SalFrameData::SaveYourselfDone( SalFrame* pSaveFrame )
+void X11SalFrame::SaveYourselfDone( SalFrame* pSaveFrame )
 {
     // session save was done, inform dtwm
-    if( s_pSaveYourselfFrame )
+    if( s_pSaveYourselfFrame && pSaveFrame )
     {
         ByteString aExec( SessionManagerClient::getExecName(), osl_getThreadTextEncoding() );
         const char* argv[2];
@@ -3554,32 +3428,39 @@ void SalFrameData::SaveYourselfDone( Sal
 #if OSL_DEBUG_LEVEL > 1
         fprintf( stderr, "SaveYourself request, setting command: %s %s\n", argv[0], argv[1] );
 #endif
-        XSetCommand( s_pSaveYourselfFrame->maFrameData.GetXDisplay(),
-                     s_pSaveYourselfFrame->maFrameData.GetShellWindow(),
+        XSetCommand( s_pSaveYourselfFrame->GetXDisplay(),
+                     s_pSaveYourselfFrame->GetShellWindow(),
                      (char**)argv, 2 );
         if( pSaveFrame != s_pSaveYourselfFrame )
         {
             // check if it still exists
-            SalFrame* pFrame = GetSalData()->pFirstFrame_;
-            while( pFrame && pFrame != pSaveFrame )
-                pFrame = pFrame->maFrameData.pNextFrame_;
-            if( pFrame )
-            {
-                const WMAdaptor& rWMAdaptor( *pFrame->maFrameData.pDisplay_->getWMAdaptor() );
-                XChangeProperty( pFrame->maFrameData.GetXDisplay(),
-                                 pFrame->maFrameData.GetShellWindow(),
+            X11SalFrame* pFrame = NULL;
+            const std::list< SalFrame* >& rFrames = static_cast<X11SalFrame*>(pSaveFrame)->GetDisplay()->getFrames();
+            std::list< SalFrame* >::const_iterator it = rFrames.begin();
+            while( it != rFrames.end() )
+            {
+                pFrame = static_cast< X11SalFrame* >(*it);
+                if( pFrame == pSaveFrame )
+                    break;
+                ++it; 
+            }
+            if( pFrame == pSaveFrame )
+            {
+                const WMAdaptor& rWMAdaptor( *pFrame->pDisplay_->getWMAdaptor() );
+                XChangeProperty( pFrame->GetXDisplay(),
+                                 pFrame->GetShellWindow(),
                                  rWMAdaptor.getAtom( WMAdaptor::WM_COMMAND ), XA_STRING, 8, PropModeReplace, (unsigned char*)"", 0 );
             }
         }
-        s_pSaveYourselfFrame->maFrameData.ShutDown();
+        s_pSaveYourselfFrame->ShutDown();
     }
 }
 
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
-Bool SalFrameData::checkKeyReleaseForRepeat( Display* pDisplay, XEvent* pCheck, XPointer pSalFrameData )
+Bool X11SalFrame::checkKeyReleaseForRepeat( Display* pDisplay, XEvent* pCheck, XPointer pX11SalFrame )
 {
-	SalFrameData* pThis = (SalFrameData*)pSalFrameData;
+	X11SalFrame* pThis = (X11SalFrame*)pX11SalFrame;
 	return
 		pCheck->type			== XLIB_KeyPress &&
 		pCheck->xkey.state		== pThis->nKeyState_ &&
@@ -3587,7 +3468,7 @@ Bool SalFrameData::checkKeyReleaseForRep
 		pCheck->xkey.time		== pThis->nReleaseTime_  ? True : False;
 }
 
-long SalFrameData::Dispatch( XEvent *pEvent )
+long X11SalFrame::Dispatch( XEvent *pEvent )
 {
 	long nRet = 0;
 
@@ -3667,8 +3548,8 @@ long SalFrameData::Dispatch( XEvent *pEv
 					bViewable_ = TRUE;
 					nRet = TRUE;
 					if ( mpInputContext != NULL )
-						mpInputContext->Map( pFrame_ );
-                    Call( SALEVENT_RESIZE, NULL );
+						mpInputContext->Map( this );
+                    CallCallback( SALEVENT_RESIZE, NULL );
                     if( pDisplay_->GetServerVendor() == vendor_hummingbird )
                     {
                         /*
@@ -3677,7 +3558,7 @@ long SalFrameData::Dispatch( XEvent *pEv
                          *  so start a paint via the timer here
                          *  to avoid duplicate paints
                          */
-                        maPaintRegion.Union( Rectangle( Point( 0, 0 ), Size( pFrame_->maGeometry.nWidth, pFrame_->maGeometry.nHeight ) ) );
+                        maPaintRegion.Union( Rectangle( Point( 0, 0 ), Size( maGeometry.nWidth, maGeometry.nHeight ) ) );
                         if( ! maResizeTimer.IsActive() )
                         {
                             mbSized = mbMoved = true;
@@ -3693,7 +3574,7 @@ long SalFrameData::Dispatch( XEvent *pEv
                         // #101775# don't set the focus into the IME status window
                         // since this will lead to a parent loose-focus, close status,
                         // reget focus, open status, .... flicker loop
-                        if ( (I18NStatus::get().getStatusFrame() != pFrame_) )
+                        if ( (I18NStatus::get().getStatusFrame() != this) )
                             XSetInputFocus( GetXDisplay(), GetShellWindow(), RevertToParent, CurrentTime );
                     }
 
@@ -3706,11 +3587,11 @@ long SalFrameData::Dispatch( XEvent *pEv
                     if( ! ( nStyle_ & ( SAL_FRAME_STYLE_FLOAT | SAL_FRAME_STYLE_CHILD ) )
                         && ! IsOverrideRedirect() )
                     {
-                        for( ::std::list< SalFrame* >::const_iterator it = maChildren.begin();
+                        for( std::list< X11SalFrame* >::const_iterator it = maChildren.begin();
                              it != maChildren.end(); ++it )
                         {
-                            if( (*it)->maFrameData.mbTransientForRoot )
-                                pDisplay_->getWMAdaptor()->changeReferenceFrame( *it, pFrame_ );
+                            if( (*it)->mbTransientForRoot )
+                                pDisplay_->getWMAdaptor()->changeReferenceFrame( *it, this );
                         }
                     }
 
@@ -3728,8 +3609,8 @@ long SalFrameData::Dispatch( XEvent *pEv
 					bViewable_ = FALSE;
 					nRet = TRUE;
 					if ( mpInputContext != NULL )
-						mpInputContext->Unmap( pFrame_ );
-					Call( SALEVENT_RESIZE, NULL );
+						mpInputContext->Unmap( this );
+					CallCallback( SALEVENT_RESIZE, NULL );
 				}
 				break;
 
@@ -3755,7 +3636,7 @@ long SalFrameData::Dispatch( XEvent *pEv
 
 			case MappingNotify:
 				if( MappingPointer != pEvent->xmapping.request )
-					nRet = Call( SALEVENT_KEYBOARDCHANGED, 0 );
+					nRet = CallCallback( SALEVENT_KEYBOARDCHANGED, 0 );
 				break;
 
 			case ColormapNotify:
@@ -3767,7 +3648,7 @@ long SalFrameData::Dispatch( XEvent *pEv
 				if( pEvent->xproperty.atom == pDisplay_->getWMAdaptor()->getAtom( WMAdaptor::WM_STATE ) )
 					nRet = HandleStateEvent( &pEvent->xproperty );
 				else
-					nRet = pDisplay_->getWMAdaptor()->handlePropertyNotify( pFrame_, &pEvent->xproperty );
+					nRet = pDisplay_->getWMAdaptor()->handlePropertyNotify( this, &pEvent->xproperty );
 				break;
 			}
 
@@ -3780,24 +3661,6 @@ long SalFrameData::Dispatch( XEvent *pEv
 	{
 		switch( pEvent->type )
 		{
-#ifdef NC_EVENTS
-			case XLIB_KeyPress:
-			case KeyRelease:
-				nRet = HandleNCKeyEvent()
-				break;
-
-			case ButtonPress:
-			case ButtonRelease:
-			case MotionNotify:
-			case EnterNotify:
-			case LeaveNotify:
-				nRet = HandleNCMouseEvent( pEvent );
-				break;
-
-			case Expose:
-				nRet = HandleNCExposeEvent( pEvent );
-				break;
-#endif
  			case FocusIn:
  			case FocusOut:
                 if( ( nStyle_ & SAL_FRAME_STYLE_CHILD )
Index: vcl/unx/source/window/salmenu.cxx
===================================================================
RCS file: vcl/unx/source/window/salmenu.cxx
diff -N vcl/unx/source/window/salmenu.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/source/window/salmenu.cxx	6 Jan 2004 14:45:30 -0000	1.5
@@ -0,0 +1,169 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+#ifndef _SV_SALINST_H
+#include <salinst.h>
+#endif
+#ifndef _SV_SALMENU_H
+#include <salmenu.h>
+#endif
+
+
+// =======================================================================
+
+// X11SalInst factory methods
+
+SalMenu* X11SalInstance::CreateMenu( BOOL bMenuBar )
+{
+    return NULL;  // no support for native menues
+}
+
+void X11SalInstance::DestroyMenu( SalMenu* pSalMenu )
+{
+    delete pSalMenu;
+}
+
+
+SalMenuItem* X11SalInstance::CreateMenuItem( const SalItemParams* pItemData )
+{
+    return NULL;  // no support for native menues
+}
+
+void X11SalInstance::DestroyMenuItem( SalMenuItem* pSalMenuItem )
+{
+    delete pSalMenuItem;
+}
+
+
+// =======================================================================
+
+
+/*
+ * X11SalMenu
+ */
+
+
+X11SalMenu::~X11SalMenu()
+{
+}
+
+BOOL X11SalMenu::VisibleMenuBar()
+{
+    return FALSE; 
+}
+
+void X11SalMenu::SetFrame( const SalFrame *pFrame )
+{
+}
+
+void X11SalMenu::InsertItem( SalMenuItem* pSalMenuItem, unsigned nPos )
+{
+}
+
+void X11SalMenu::RemoveItem( unsigned nPos )
+{
+}
+
+void X11SalMenu::SetSubMenu( SalMenuItem* pSalMenuItem, SalMenu* pSubMenu, unsigned nPos )
+{
+}
+
+void X11SalMenu::CheckItem( unsigned nPos, BOOL bCheck )
+{
+}
+
+void X11SalMenu::EnableItem( unsigned nPos, BOOL bEnable )
+{
+}
+
+void X11SalMenu::SetItemImage( unsigned nPos, SalMenuItem* pSalMenuItem, const Image& rImage )
+{
+}
+
+void X11SalMenu::SetItemText( unsigned nPos, SalMenuItem* pSalMenuItem, const XubString& rText )
+{
+}
+
+void X11SalMenu::SetAccelerator( unsigned nPos, SalMenuItem* pSalMenuItem, const KeyCode& rKeyCode, const XubString& rKeyName )
+{
+}
+
+void X11SalMenu::GetSystemMenuData( SystemMenuData* pData )
+{
+}
+
+// =======================================================================
+
+/*
+ * SalMenuItem
+ */
+
+
+X11SalMenuItem::~X11SalMenuItem()
+{
+}
+
+// -------------------------------------------------------------------
+
Index: vcl/unx/source/window/salobj.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/window/salobj.cxx,v
retrieving revision 1.6
retrieving revision 1.10
diff -u -p -u -r1.6 -r1.10
--- vcl/unx/source/window/salobj.cxx	24 Oct 2001 16:32:21 -0000	1.6
+++ vcl/unx/source/window/salobj.cxx	10 May 2004 16:00:55 -0000	1.10
@@ -59,7 +59,6 @@
  *
  ************************************************************************/
 
-#define _SV_SALOBJ_CXX
 #include <prex.h>
 #include <X11/Xlib.h>
 #include <X11/extensions/shape.h>
@@ -72,19 +71,19 @@
 #include <saldata.hxx>
 #endif
 #ifndef _SV_SALINST_HXX
-#include <salinst.hxx>
+#include <salinst.h>
 #endif
 #ifndef _SV_SALDISP_HXX
 #include <saldisp.hxx>
 #endif
 #ifndef _SV_SALFRAME_HXX
-#include <salframe.hxx>
+#include <salframe.h>
 #endif
-#ifndef _SV_SALOBJ_HXX
-#include <salobj.hxx>
+#ifndef _SV_SALOBJ_H
+#include <salobj.h>
 #endif
 
-SalObjectList SalObjectData::aAllObjects;
+SalObjectList X11SalObject::aAllObjects;
 
 // =======================================================================
 
@@ -96,11 +95,11 @@ long ImplSalObjCallbackDummy( void*, Sal
 // =======================================================================
 // SalInstance memberfkts to create and destroy a SalObject
 
-SalObject* SalInstance::CreateObject( SalFrame* pParent )
+SalObject* X11SalInstance::CreateObject( SalFrame* pParent )
 {
 	int error_base, event_base;
-	SalObject*		 pObject  = new SalObject;
-	SystemChildData* pObjData = const_cast<SystemChildData*>(pObject->GetSystemData());
+	X11SalObject*		pObject  = new X11SalObject();
+	SystemChildData*	pObjData = const_cast<SystemChildData*>(pObject->GetSystemData());
 
 	if ( ! XShapeQueryExtension( (Display*)pObjData->pDisplay,
 								  &event_base, &error_base ) )
@@ -109,31 +108,32 @@ SalObject* SalInstance::CreateObject( Sa
 		return NULL;
 	}
 
-	SalDisplay* pSalDisp		= pParent->maFrameData.GetDisplay();
-    Display* pDisp				= pParent->maFrameData.GetXDisplay();
-	XLIB_Window aObjectParent	= pParent->maFrameData.GetWindow();
+	SalDisplay* pSalDisp		= GetSalData()->GetDisplay();
+    const SystemEnvData* pEnv	= pParent->GetSystemData();
+    Display* pDisp				= pSalDisp->GetDisplay();
+	XLIB_Window aObjectParent	= (XLIB_Window)pEnv->aWindow;
 
-	pObject->maObjectData.maPrimary =
+	pObject->maPrimary =
         XCreateSimpleWindow( pDisp,
                              aObjectParent,
                              0, 0,
                              100, 100, 0,
-                             pParent->maFrameData.GetDisplay()->GetColormap().GetBlackPixel(),
-                             pParent->maFrameData.GetDisplay()->GetColormap().GetWhitePixel()
+                             pSalDisp->GetColormap().GetBlackPixel(),
+                             pSalDisp->GetColormap().GetWhitePixel()
                              );
-	pObject->maObjectData.maSecondary =
+	pObject->maSecondary =
         XCreateSimpleWindow( pDisp,
-                             pObject->maObjectData.maPrimary,
+                             pObject->maPrimary,
                              0, 0,
                              100, 100, 0,
-                             pParent->maFrameData.GetDisplay()->GetColormap().GetBlackPixel(),
-                             pParent->maFrameData.GetDisplay()->GetColormap().GetWhitePixel()
+                             pSalDisp->GetColormap().GetBlackPixel(),
+                             pSalDisp->GetColormap().GetWhitePixel()
                              );
-	XMapWindow( pDisp, pObject->maObjectData.maPrimary );
-	XMapWindow( pDisp, pObject->maObjectData.maSecondary );
+	XMapWindow( pDisp, pObject->maPrimary );
+	XMapWindow( pDisp, pObject->maSecondary );
 
 	pObjData->pDisplay		= pDisp;
-	pObjData->aWindow		= pObject->maObjectData.maSecondary;
+	pObjData->aWindow		= pObject->maSecondary;
 	pObjData->pWidget		= NULL;
 	pObjData->pVisual		= pSalDisp->GetVisual()->GetVisual();
 	pObjData->nDepth		= pSalDisp->GetVisual()->GetDepth();
@@ -144,7 +144,7 @@ SalObject* SalInstance::CreateObject( Sa
 }
 
 
-void SalInstance::DestroyObject( SalObject* pObject )
+void X11SalInstance::DestroyObject( SalObject* pObject )
 {
 	delete pObject;
 }
@@ -204,43 +204,43 @@ SalClipRegion::UnionClipRegion( long nX,
 // SalObject Implementation
 
 
-SalObject::SalObject()
+X11SalObject::X11SalObject()
 {
-	maObjectData.maSystemChildData.nSize		= sizeof( SystemChildData );
-	maObjectData.maSystemChildData.pDisplay 	= GetSalData()->GetDefDisp()->GetDisplay();
-	maObjectData.maSystemChildData.aWindow		= None;
-	maObjectData.maSystemChildData.pSalFrame	= 0;
-	maObjectData.maSystemChildData.pWidget		= 0;
-	maObjectData.maSystemChildData.pVisual		= 0;
-	maObjectData.maSystemChildData.nDepth		= 0;
-	maObjectData.maSystemChildData.aColormap	= 0;
-	maObjectData.maSystemChildData.pAppContext	= NULL;
-	maObjectData.maSystemChildData.aShellWindow	= 0;
-	maObjectData.maSystemChildData.pShellWidget	= NULL;
+	maSystemChildData.nSize		= sizeof( SystemChildData );
+	maSystemChildData.pDisplay 	= GetSalData()->GetDisplay()->GetDisplay();
+	maSystemChildData.aWindow		= None;
+	maSystemChildData.pSalFrame	= 0;
+	maSystemChildData.pWidget		= 0;
+	maSystemChildData.pVisual		= 0;
+	maSystemChildData.nDepth		= 0;
+	maSystemChildData.aColormap	= 0;
+	maSystemChildData.pAppContext	= NULL;
+	maSystemChildData.aShellWindow	= 0;
+	maSystemChildData.pShellWidget	= NULL;
 	
-	maObjectData.mpInst							= NULL;
-	maObjectData.mpProc							= ImplSalObjCallbackDummy;
-	maObjectData.maPrimary						= NULL;
-	maObjectData.maSecondary					= NULL;
+	mpInst							= NULL;
+	mpProc							= ImplSalObjCallbackDummy;
+	maPrimary						= 0;
+	maSecondary						= 0;
 
-	SalObjectData::aAllObjects.Insert( this, LIST_APPEND );
+	X11SalObject::aAllObjects.Insert( this, LIST_APPEND );
 }
 
 
-SalObject::~SalObject()
+X11SalObject::~X11SalObject()
 {
-	SalObjectData::aAllObjects.Remove( this );
-	if ( maObjectData.maSecondary ) 
-		XDestroyWindow( (Display*)maObjectData.maSystemChildData.pDisplay, maObjectData.maSecondary );
-	if ( maObjectData.maPrimary )
-		XDestroyWindow( (Display*)maObjectData.maSystemChildData.pDisplay, maObjectData.maPrimary );
+	X11SalObject::aAllObjects.Remove( this );
+	if ( maSecondary ) 
+		XDestroyWindow( (Display*)maSystemChildData.pDisplay, maSecondary );
+	if ( maPrimary )
+		XDestroyWindow( (Display*)maSystemChildData.pDisplay, maPrimary );
 }
 
 
 void
-SalObject::ResetClipRegion()
+X11SalObject::ResetClipRegion()
 {
-	maObjectData.maClipRegion.ResetClipRegion();
+	maClipRegion.ResetClipRegion();
 
 	const int	dest_kind	= ShapeBounding;
 	const int	op			= ShapeSet;
@@ -249,9 +249,9 @@ SalObject::ResetClipRegion()
 	XWindowAttributes win_attrib;
 	XRectangle		  win_size;
 
-	XLIB_Window aShapeWindow = maObjectData.maPrimary;
+	XLIB_Window aShapeWindow = maPrimary;
 
-	XGetWindowAttributes ( (Display*)maObjectData.maSystemChildData.pDisplay,
+	XGetWindowAttributes ( (Display*)maSystemChildData.pDisplay,
 						   aShapeWindow,
 						   &win_attrib );
 
@@ -260,7 +260,7 @@ SalObject::ResetClipRegion()
 	win_size.width	= win_attrib.width;
 	win_size.height = win_attrib.height;
 
-	XShapeCombineRectangles ( (Display*)maObjectData.maSystemChildData.pDisplay,
+	XShapeCombineRectangles ( (Display*)maSystemChildData.pDisplay,
 							  aShapeWindow,
 							  dest_kind,
 							  0, 0, 			// x_off, y_off
@@ -271,25 +271,25 @@ SalObject::ResetClipRegion()
 
 
 void
-SalObject::BeginSetClipRegion( ULONG nRectCount )
+X11SalObject::BeginSetClipRegion( ULONG nRectCount )
 {
-	maObjectData.maClipRegion.BeginSetClipRegion ( nRectCount );
+	maClipRegion.BeginSetClipRegion ( nRectCount );
 }
 
 
 void
-SalObject::UnionClipRegion( long nX, long nY, long nWidth, long nHeight )
+X11SalObject::UnionClipRegion( long nX, long nY, long nWidth, long nHeight )
 {
-	maObjectData.maClipRegion.UnionClipRegion ( nX, nY, nWidth, nHeight );
+	maClipRegion.UnionClipRegion ( nX, nY, nWidth, nHeight );
 }
 
 
 void
-SalObject::EndSetClipRegion()
+X11SalObject::EndSetClipRegion()
 {
-	XRectangle *pRectangles = maObjectData.maClipRegion.EndSetClipRegion ();
-	const int	nType		= maObjectData.maClipRegion.GetClipRegionType();
-	const int	nRectangles = maObjectData.maClipRegion.GetRectangleCount();
+	XRectangle *pRectangles = maClipRegion.EndSetClipRegion ();
+	const int	nType		= maClipRegion.GetClipRegionType();
+	const int	nRectangles = maClipRegion.GetRectangleCount();
 
 	const int	dest_kind	= ShapeBounding;
 	const int	ordering	= YSorted;
@@ -310,9 +310,9 @@ SalObject::EndSetClipRegion()
 			op = ShapeUnion;
 	}
 
-	XLIB_Window aShapeWindow = maObjectData.maPrimary;
+	XLIB_Window aShapeWindow = maPrimary;
 	
-	XShapeCombineRectangles ( (Display*)maObjectData.maSystemChildData.pDisplay,
+	XShapeCombineRectangles ( (Display*)maSystemChildData.pDisplay,
 							  aShapeWindow,
 							  dest_kind,
 							  0, 0, // x_off, y_off
@@ -323,127 +323,104 @@ SalObject::EndSetClipRegion()
 
 
 USHORT
-SalObject::GetClipRegionType()
+X11SalObject::GetClipRegionType()
 {
-	return maObjectData.maClipRegion.GetClipRegionType();
+	return maClipRegion.GetClipRegionType();
 }
 
 // -----------------------------------------------------------------------
 
 void
-SalObject::SetPosSize( long nX, long nY, long nWidth, long nHeight )
+X11SalObject::SetPosSize( long nX, long nY, long nWidth, long nHeight )
 {
-	if ( maObjectData.maPrimary && maObjectData.maSecondary && nWidth && nHeight )
+	if ( maPrimary && maSecondary && nWidth && nHeight )
 	{
-        XMoveResizeWindow( (Display*)maObjectData.maSystemChildData.pDisplay,
-                           maObjectData.maPrimary,
+        XMoveResizeWindow( (Display*)maSystemChildData.pDisplay,
+                           maPrimary,
  						   nX, nY, nWidth, nHeight );
-        XMoveResizeWindow( (Display*)maObjectData.maSystemChildData.pDisplay,
-                           maObjectData.maSecondary,
+        XMoveResizeWindow( (Display*)maSystemChildData.pDisplay,
+                           maSecondary,
  						   0, 0, nWidth, nHeight );
 	}
 }
 
 
 void
-SalObject::Show( BOOL bVisible )
+X11SalObject::Show( BOOL bVisible )
 {
-	if	( ! maObjectData.maSystemChildData.aWindow )
+	if	( ! maSystemChildData.aWindow )
 		return;
 
 	if ( bVisible ) 
-		XMapWindow( (Display*)maObjectData.maSystemChildData.pDisplay,
-                    maObjectData.maPrimary );
+		XMapWindow( (Display*)maSystemChildData.pDisplay,
+                    maPrimary );
 	else
-		XUnmapWindow( (Display*)maObjectData.maSystemChildData.pDisplay,
-                    maObjectData.maPrimary );
+		XUnmapWindow( (Display*)maSystemChildData.pDisplay,
+                    maPrimary );
 
-	maObjectData.mbVisible = bVisible;
+	mbVisible = bVisible;
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::Enable( BOOL bEnable )
+void X11SalObject::Enable( BOOL bEnable )
 {
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::GrabFocus()
+void X11SalObject::GrabFocus()
 {
-	if( maObjectData.mbVisible )
- 		XSetInputFocus( (Display*)maObjectData.maSystemChildData.pDisplay,
- 						maObjectData.maSystemChildData.aWindow,
+	if( mbVisible )
+ 		XSetInputFocus( (Display*)maSystemChildData.pDisplay,
+ 						maSystemChildData.aWindow,
  						RevertToNone,
  						CurrentTime );
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::SetBackground()
+void X11SalObject::SetBackground()
 {
 }
 
 // -----------------------------------------------------------------------
 
-void SalObject::SetBackground( SalColor nSalColor )
+void X11SalObject::SetBackground( SalColor nSalColor )
 {
 }
 
 // -----------------------------------------------------------------------
 
-const SystemChildData* SalObject::GetSystemData() const
+const SystemChildData* X11SalObject::GetSystemData() const
 {
-	return &maObjectData.maSystemChildData;
+	return &maSystemChildData;
 }
 
-// -----------------------------------------------------------------------
-
-void SalObject::SetCallback( void* pInst, SALOBJECTPROC pProc )
-{
-	  maObjectData.mpInst = pInst;
-	  if ( pProc )
-		  maObjectData.mpProc = pProc;
-	  else
-		  maObjectData.mpProc = ImplSalObjCallbackDummy;
-}
-
-long SalObjectData::Dispatch( XEvent* pEvent )
+long X11SalObject::Dispatch( XEvent* pEvent )
 {
 	for( int n= 0; n < aAllObjects.Count(); n++ )
 	{
-		SalObject* pObject = aAllObjects.GetObject( n );
-		if( pEvent->xany.window == pObject->maObjectData.maPrimary ||
-			pEvent->xany.window == pObject->maObjectData.maSecondary )
+		X11SalObject* pObject = aAllObjects.GetObject( n );
+		if( pEvent->xany.window == pObject->maPrimary ||
+			pEvent->xany.window == pObject->maSecondary )
 		{
 			switch( pEvent->type )
 			{
 				case UnmapNotify:
-					pObject->maObjectData.mbVisible = FALSE;
+					pObject->mbVisible = FALSE;
 					return 1;
 				case MapNotify:
-					pObject->maObjectData.mbVisible = TRUE;
+					pObject->mbVisible = TRUE;
 					return 1;
 				case ButtonPress:
-					pObject->maObjectData.mpProc(
-						pObject->maObjectData.mpInst,
-						pObject,
-						SALOBJ_EVENT_TOTOP,
-						NULL );
+					pObject->CallCallback( SALOBJ_EVENT_TOTOP, NULL );
 					return 1;
 				case FocusIn:
-					pObject->maObjectData.mpProc(
-						pObject->maObjectData.mpInst,
-						pObject,
-						SALOBJ_EVENT_GETFOCUS,
-						NULL );
+					pObject->CallCallback( SALOBJ_EVENT_GETFOCUS, NULL );
 					return 1;
 				case FocusOut:
-					pObject->maObjectData.mpProc(
-						pObject->maObjectData.mpInst,
-						pObject,
-						SALOBJ_EVENT_LOSEFOCUS,
-						NULL );
+					pObject->CallCallback( SALOBJ_EVENT_LOSEFOCUS, NULL );
 					return 1;
 				default: break;
 			}
Index: vcl/util/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/util/makefile.mk,v
retrieving revision 1.47.10.2
retrieving revision 1.54
diff -u -p -u -r1.47.10.2 -r1.54
--- vcl/util/makefile.mk	3 Mar 2004 14:33:18 -0000	1.47.10.2
+++ vcl/util/makefile.mk	10 May 2004 16:01:11 -0000	1.54
@@ -65,7 +65,6 @@ PRJ=..
 PRJNAME=vcl
 TARGET=vcl
 VERSION=$(UPD)
-USE_DEFFILE=TRUE
 
 # --- Settings -----------------------------------------------------------
 
@@ -84,8 +83,6 @@ HXXDEPNLST= $(INC)$/accel.hxx       \
             $(INC)$/btndlg.hxx      \
             $(INC)$/button.hxx      \
             $(INC)$/ctrl.hxx        \
-            $(INC)$/color.hxx       \
-            $(INC)$/config.hxx      \
             $(INC)$/cursor.hxx      \
             $(INC)$/cmdevt.hxx      \
             $(INC)$/decoview.hxx    \
@@ -106,7 +103,6 @@ HXXDEPNLST= $(INC)$/accel.hxx       \
             $(INC)$/keycodes.hxx    \
             $(INC)$/keycod.hxx      \
             $(INC)$/image.hxx       \
-            $(INC)$/line.hxx        \
             $(INC)$/lstbox.h        \
             $(INC)$/lstbox.hxx      \
             $(INC)$/mapmod.hxx      \
@@ -120,15 +116,11 @@ HXXDEPNLST= $(INC)$/accel.hxx       \
             $(INC)$/outdev.hxx      \
             $(INC)$/outdev3d.hxx    \
             $(INC)$/pointr.hxx      \
-            $(INC)$/poly.hxx        \
             $(INC)$/ptrstyle.hxx    \
             $(INC)$/prntypes.hxx    \
             $(INC)$/print.hxx       \
             $(INC)$/prndlg.hxx      \
             $(INC)$/region.hxx      \
-            $(INC)$/rc.hxx          \
-            $(INC)$/resid.hxx       \
-            $(INC)$/resary.hxx      \
             $(INC)$/salbtype.hxx    \
             $(INC)$/scrbar.hxx      \
             $(INC)$/slider.hxx      \
@@ -146,7 +138,6 @@ HXXDEPNLST= $(INC)$/accel.hxx       \
             $(INC)$/svapp.hxx       \
             $(INC)$/syschild.hxx    \
             $(INC)$/sysdata.hxx     \
-            $(INC)$/system.hxx      \
             $(INC)$/syswin.hxx      \
             $(INC)$/tabctrl.hxx     \
             $(INC)$/tabdlg.hxx      \
@@ -179,23 +170,14 @@ LIB1FILES=  $(SLB)$/app.lib     \
             $(SLB)$/helper.lib
 
 
-.IF "$(remote)" != ""
-    LIB1FILES+= $(SLB)$/remote.lib
-.IF "$(COM)"=="GCC"
-LIB1OBJFILES=$(SLO)$/salmain.obj
-.ENDIF
-.ELSE           # "$(remote)" != ""
+.IF "$(GUI)" == "UNX"
+LIB1FILES+=$(SLB)$/salplug.lib
+.ELSE
 LIB1FILES+= \
             $(SLB)$/salwin.lib  \
             $(SLB)$/salgdi.lib  \
             $(SLB)$/salapp.lib
-.ENDIF          # "$(remote)" != ""
-
-.IF "$(GUI)" == "UNX"
-.IF "$(USE_XPRINT)" != "TRUE"
-    SHL1STDLIBS=-lpsp$(VERSION)$(DLLPOSTFIX)
-.ENDIF # ! USE_XPRINT
-.ENDIF # UNX
+.ENDIF
 
 SHL1TARGET= vcl$(VERSION)$(DLLPOSTFIX)
 SHL1IMPLIB= ivcl
@@ -208,11 +190,9 @@ SHL1STDLIBS+=\
             $(CPPUHELPERLIB)    \
             $(CPPULIB)          \
             $(VOSLIB)           \
-            $(SALLIB)
-
-.IF "$(ENABLE_CTL)"!=""
-    SHL1STDLIBS+= $(ICUUCLIB) $(ICULELIB)
-.ENDIF # ENABLE_CTL
+            $(SALLIB)			\
+            $(ICUUCLIB)			\
+            $(ICULELIB)
 
 .IF "$(USE_BUILTIN_RASTERIZER)"!=""
     LIB1FILES +=    $(SLB)$/glyphs.lib
@@ -227,6 +207,8 @@ SHL1DEPN=   $(L)$/itools.lib $(L)$/sot.l
 SHL1LIBS=   $(LIB1TARGET)
 .IF "$(GUI)"!="UNX"
 SHL1OBJS=   $(SLO)$/salshl.obj
+.ELSE
+SHL1STDLIBS+=-ldl
 .ENDIF
 
 .IF "$(GUI)" != "MAC"
@@ -242,10 +224,6 @@ DEF1DEPN    =   $(MISC)$/$(SHL1TARGET).f
                 $(LIB1TARGET)
 DEF1DES     =VCL
 DEFLIB1NAME =vcl
-DEF1EXPORT1=component_getFactory
-DEF1EXPORT2=component_getImplementationEnvironment
-DEF1EXPORT3=component_writeInfo
-
 
 # --- W32 ----------------------------------------------------------------
 
@@ -263,9 +241,9 @@ SHL1STDLIBS += uwinapi.lib      \
 .IF "$(GUI)$(COM)$(CPU)" == "WNTMSCI"
 LINKFLAGSSHL += /ENTRY:LibMain@12
 .ENDIF
-
 .ENDIF
 
+
 # --- UNX ----------------------------------------------------------------
 
 .IF "$(GUI)"=="UNX"
@@ -278,47 +256,107 @@ SHL1STDLIBS += -ldl
 SHL1STDLIBS += -framework Cocoa
 .ENDIF
 
+
+SHL1STDLIBS += -lX11
+
+.ENDIF          # "$(GUI)"=="UNX"
+
+# UNX sal plugins
+.IF "$(GUI)" == "UNX"
+
+# basic pure X11 plugin
+LIB2TARGET=$(SLB)$/ipure_x
+LIB2FILES= \
+            $(SLB)$/salwin.lib  \
+            $(SLB)$/salgdi.lib  \
+            $(SLB)$/salapp.lib
+SHL2TARGET=vclplug_gen$(UPD)$(DLLPOSTFIX)
+SHL2IMPLIB=ipure_x
+SHL2LIBS=  $(LIB2TARGET)
+
+# libs for generic plugin
+SHL2STDLIBS=\
+			$(VCLLIB)\
+			-lpsp$(VERSION)$(DLLPOSTFIX)\
+            $(SOTLIB)           \
+            $(UNOTOOLSLIB)      \
+            $(TOOLSLIB)         \
+            $(COMPHELPERLIB)	\
+            $(UCBHELPERLIB)     \
+            $(CPPUHELPERLIB)    \
+            $(CPPULIB)          \
+            $(VOSLIB)           \
+            $(SALLIB)
+
+.IF "$(OS)"=="MACOSX"
+SHL2STDLIBS += -lXinerama
+.ENDIF
+
+.IF "$(OS)"=="LINUX" || "$(OS)"=="SOLARIS" || "$(OS)"=="FREEBSD"
+SHL2STDLIBS += -laudio
+.IF "$(OS)"=="SOLARIS"
+# needed by libaudio.a
+SHL2STDLIBS += -ldl -lnsl -lsocket
+.ENDIF # SOLARIS
+.ENDIF # "$(OS)"=="LINUX" || "$(OS)"=="SOLARIS" || "$(OS)"=="FREEBSD"
+
 .IF "$(GUIBASE)"=="unx"
 
 .IF "$(WITH_LIBSN)"=="YES"
-SHL1STDLIBS+=$(LIBSN_LIBS)
+SHL2STDLIBS+=$(LIBSN_LIBS)
 .ENDIF
 
 # Solaris
 .IF "$(OS)"=="SOLARIS"
-
-.IF "$(USE_XPRINT)" == "TRUE"
-SHL1STDLIBS += -lXp -lXext -lSM -lICE -lX11
-.ELSE
-SHL1STDLIBS += -lXext -lSM -lICE -lX11
-.ENDIF          # "$(USE_XPRINT)" == "TRUE"
-
+SHL2STDLIBS += -lXext -lSM -lICE -lX11
 # Others
 .ELSE           # "$(OS)"=="SOLARIS"
-.IF "$(USE_XPRINT)" == "TRUE"
-SHL1STDLIBS += -lXp -lXext -lSM -lICE -lX11
-.ELSE
 .IF "$(CPU)" == "I"
-SHL1STDLIBS += -Wl,-Bstatic -lXinerama -Wl,-Bdynamic 
-.ENDIF
-SHL1STDLIBS += -lXext -lSM -lICE -lX11
-.ENDIF          # "$(USE_XPRINT)" == "TRUE"
+SHL2STDLIBS += -Wl,-Bstatic -lXinerama -Wl,-Bdynamic 
+.ENDIF 			# "$(CPU)=="I"
+SHL2STDLIBS += -lXext -lSM -lICE -lX11
 .ENDIF          # "$(OS)"=="SOLARIS"
+
 .ENDIF          # "$(GUIBASE)"=="unx"
 
-.IF "$(OS)"=="MACOSX"
-SHL1STDLIBS += -lXinerama
-.ENDIF
+# dummy plugin
+LIB3TARGET=$(SLB)$/idummy_plug_
+LIB3FILES= \
+            $(SLB)$/dapp.lib
+SHL3TARGET=vclplug_dummy$(UPD)$(DLLPOSTFIX)
+SHL3IMPLIB=idummy_plug_
+SHL3LIBS=  $(LIB3TARGET)
+
+# libs for dummy plugin
+SHL3STDLIBS=\
+			$(VCLLIB)\
+            $(SOTLIB)           \
+            $(UNOTOOLSLIB)      \
+            $(TOOLSLIB)         \
+            $(COMPHELPERLIB)	\
+            $(UCBHELPERLIB)     \
+            $(CPPUHELPERLIB)    \
+            $(CPPULIB)          \
+            $(VOSLIB)           \
+            $(SALLIB)
 
-.IF "$(OS)"=="LINUX" || "$(OS)"=="SOLARIS" || "$(OS)"=="FREEBSD"
-SHL1STDLIBS += -laudio
-.IF "$(OS)"=="SOLARIS"
-# needed by libaudio.a
-SHL1STDLIBS += -ldl -lnsl -lsocket
-.ENDIF # SOLARIS
-.ENDIF          # "$(OS)"=="LINUX" || "$(OS)"=="SOLARIS" || "$(OS)"=="FREEBSD"
+# gtk plugin
+.IF "$(ENABLE_GTK)" != ""
+LIB4TARGET=$(SLB)$/igtk_plug_
+LIB4FILES=\
+			$(SLB)$/gtkapp.lib\
+			$(SLB)$/gtkgdi.lib\
+			$(SLB)$/gtkwin.lib
+SHL4TARGET=vclplug_gtk$(UPD)$(DLLPOSTFIX)
+SHL4IMPLIB=igtk_plug_
+SHL4LIBS=$(LIB4TARGET)
+# libs for gtk plugin
+SHL4STDLIBS=`pkg-config --libs gtk+-2.0 gthread-2.0`
+SHL4STDLIBS+=-l$(SHL2TARGET)
+SHL4STDLIBS+=$(SHL3STDLIBS) -lX11 -ldl
+.ENDIF # "$(ENABLE_GTK)" != ""
 
-.ENDIF          # "$(GUI)"=="UNX"
+.ENDIF # UNX
 
 # --- Allgemein ----------------------------------------------------------
 
@@ -348,16 +386,6 @@ $(MISC)$/$(SHL1TARGET).flt: makefile.mk
     @echo RmBitmap>> $@
     @echo RmSound>> $@
     @echo __CT>> $@
-    @echo _TI2>> $@
-    @echo _TI3>> $@
-    @echo _real@ >> $@
-    @echo xMonitorFrom >> $@
-    @echo xEnumDisplay >> $@
-    @echo xGetSystemMetrics >> $@
-    @echo xGetMonitorInfo >> $@
-    @echo WIN_ >> $@
-    @echo component_ >> $@
     @echo DNDEventDispatcher>> $@
     @echo DNDListenerContainer>> $@
     @echo vcl\ >> $@
-
Index: vcl/util/makefile.pmk
===================================================================
RCS file: /cvs/gsl/vcl/util/makefile.pmk,v
retrieving revision 1.14
retrieving revision 1.16
diff -u -p -u -r1.14 -r1.16
--- vcl/util/makefile.pmk	16 Jul 2003 17:47:17 -0000	1.14
+++ vcl/util/makefile.pmk	2 Mar 2004 11:32:11 -0000	1.16
@@ -59,24 +59,12 @@
 #
 #
 #*************************************************************************
-PROJECTPCH4DLL=TRUE
-PROJECTPCH=vclpch
-PROJECTPCHSOURCE=$(PRJ)$/util$/vclpch
 PDBTARGET=vcl
 
-.IF "$(remote)" != ""
-USE_BUILTIN_RASTERIZER=true
-.ENDIF
 .IF "$(GUI)" == "UNX"
 USE_BUILTIN_RASTERIZER=true
 .ENDIF
 
 .IF "$(USE_BUILTIN_RASTERIZER)" != ""
-ENVCDEFS += -DUSE_BUILTIN_RASTERIZER
+ADDCDEFS += -DUSE_BUILTIN_RASTERIZER
 .ENDIF
-
-ENABLE_CTL=true
-.IF "$(ENABLE_CTL)" != ""
-ENVCDEFS += -DENABLE_CTL
-.ENDIF
-
Index: vcl/util/makefile.prj
===================================================================
RCS file: /cvs/gsl/vcl/util/makefile.prj,v
retrieving revision 1.1.1.1
retrieving revision 1.2
diff -u -p -u -r1.1.1.1 -r1.2
--- vcl/util/makefile.prj	18 Sep 2000 17:05:48 -0000	1.1.1.1
+++ vcl/util/makefile.prj	6 Jan 2004 14:47:47 -0000	1.2
@@ -1,4 +1 @@
-PROJECTPCH4DLL=TRUE
-PROJECTPCH=vclpch
-PROJECTPCHSOURCE=$(PRJ)\util\vclpch
 PDBTARGET=vcl
Index: vcl/source/glyphs/gcach_ftyp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/glyphs/gcach_ftyp.cxx,v
retrieving revision 1.98.20.2
diff -u -p -u -r1.98.20.2 gcach_ftyp.cxx
--- vcl/source/glyphs/gcach_ftyp.cxx	28 Jan 2004 15:22:42 -0000	1.98.20.2
+++ vcl/source/glyphs/gcach_ftyp.cxx	5 Jul 2004 14:01:28 -0000
@@ -58,13 +59,10 @@
  *
  ************************************************************************/
 
-#if defined(WIN32)
-#ifndef _SV_SVSYS_HXX
-
+#ifdef WNT
 #include <svsys.h>
 #undef CreateFont
 #endif
-#endif
 
 #include <gcach_ftyp.hxx>
 
@@ -72,17 +70,25 @@
 #include <outfont.hxx>
 #include <bitmap.hxx>
 #include <bmpacc.hxx>
-#include <poly.hxx>
+
+#ifndef _TL_POLY_HXX
+#include <tools/poly.hxx>
+#endif
 
 #include <osl/file.hxx>
 #include <osl/thread.hxx>
 
-#include "freetype/freetype.h"
-#include "freetype/ftglyph.h"
-#include "freetype/ftoutln.h"
-#include "freetype/tttables.h"
-#include "freetype/tttags.h"
-#include "freetype/ttnameid.h"
+#ifndef INCLUDED_RTL_INSTANCE_HXX
+#include <rtl/instance.hxx>
+#endif
+
+#include "ft2build.h"
+#include  FT_FREETYPE_H
+#include  FT_GLYPH_H
+#include  FT_OUTLINE_H
+#include  FT_TRUETYPE_TABLES_H
+#include  FT_TRUETYPE_TAGS_H
+#include  FT_TRUETYPE_IDS_H
 
 #ifndef FREETYPE_PATCH
     // VERSION_MINOR in freetype.h is too coarse
@@ -104,7 +110,7 @@
     #include <fcntl.h>
     #include <sys/stat.h>
     #include <sys/mman.h>
-#elif defined(WIN32)
+#elif defined(WNT)
     #include <io.h>
     #define strncasecmp strnicmp
 #endif
@@ -199,7 +206,7 @@ bool FtFontFile::Map()
         mpFileMap = (const unsigned char*)
             mmap( NULL, mnFileSize, PROT_READ, MAP_SHARED, nFile, 0 );
         close( nFile );
-#elif defined(WIN32)
+#elif defined(WNT)
         void* pFileDesc = ::CreateFile( pFileName, GENERIC_READ, FILE_SHARE_READ,
                         NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0 );
         if( pFileDesc == INVALID_HANDLE_VALUE)
@@ -239,7 +246,7 @@ void FtFontFile::Unmap()
 
 #if defined(UNX)
     munmap( (char*)mpFileMap, mnFileSize );
-#elif defined(WIN32)
+#elif defined(WNT)
     UnmapViewOfFile( (LPCVOID)mpFileMap );
 #else
     delete[] mpFileMap;
@@ -251,15 +258,22 @@ void FtFontFile::Unmap()
 // =======================================================================
 
 FtFontInfo::FtFontInfo( const ImplFontData& rFontData,
-    const ::rtl::OString& rNativeFileName, int nFaceNum, int nFontId, int nSynthetic )
-:   mpFontFile( FtFontFile::FindFontFile( rNativeFileName ) ),
+                        const ::rtl::OString& rNativeFileName,
+                        int nFaceNum, int nFontId, int nSynthetic,
+                        const unicodeKernMap* pKern
+                        )
+:   
     maFontData( rFontData ),
+    mpFontFile( FtFontFile::FindFontFile( rNativeFileName ) ),
     mnFaceNum( nFaceNum ),
-    mnFontId( nFontId ),
     mnSynthetic( nSynthetic ),
+    mnFontId( nFontId ),
     maFaceFT( NULL ),
     mnRefCount( 0 )
 {
+    if( pKern )
+        maUnicodeKernPairs = *pKern;
+
     maFontData.mpSysData = (void*)nFontId;
     maFontData.mpNext    = NULL;
 
@@ -336,6 +350,43 @@ void FtFontInfo::ReleaseFaceFT( FT_FaceR
     }
 }
 
+void FtFontInfo::CacheGlyphIndex( sal_Unicode cChar, int nGI ) const
+{
+    maGlyphMap[ cChar ] = nGI;
+
+    if( maUnicodeKernPairs.size() != maGlyphKernPairs.size() )
+    {
+        // move kerning to glyph kerning map
+        unicodeKernMap::const_iterator left_it =
+            maUnicodeKernPairs.find( cChar );
+        std::map< sal_Unicode, int >::const_iterator right_it;
+        for( left_it = maUnicodeKernPairs.begin(); left_it != maUnicodeKernPairs.end(); ++left_it )
+        {
+            if( left_it->first == cChar )
+            {
+                for( right_it = left_it->second.begin(); right_it != left_it->second.end(); ++right_it )
+                {
+                    int nRightGlyph = GetGlyphIndex( right_it->first );
+                    if( nRightGlyph != -1 )
+                        maGlyphKernPairs[ nGI ][ nRightGlyph ] = right_it->second;
+                }
+            }
+            else
+            {
+                int nLeftGlyph = GetGlyphIndex( left_it->first );
+                if( nLeftGlyph != -1 )
+                {
+                    for( right_it = left_it->second.begin(); right_it != left_it->second.end(); ++right_it )
+                    {
+                        if( right_it->first == cChar )
+                            maGlyphKernPairs[ nLeftGlyph ][ nGI ] = right_it->second;
+                    }
+                }
+            }
+        }
+    }
+}
+
 // -----------------------------------------------------------------------
 
 static unsigned GetUInt( const unsigned char* p ) { return((p[0]<<24)+(p[1]<<16)+(p[2]<<8)+p[3]);}
@@ -382,11 +433,10 @@ const unsigned char* FtFontInfo::GetTabl
 // =======================================================================
 
 FreetypeManager::FreetypeManager()
-:   mnNextFontId( 0x1000 ),
-    mnMaxFontId( 0 )
+:   mnMaxFontId( 0 ), mnNextFontId( 0x1000 )
 {
     FT_Error rcFT = FT_Init_FreeType( &aLibFT );
-   
+  
 #ifdef RTLD_DEFAULT // true if a good dlfcn.h header was included
     // Get version of freetype library to enable workarounds.
     // Freetype <= 2.0.9 does not have FT_Library_Version().
@@ -449,7 +499,10 @@ void* FreetypeManager::GetFontHandle( in
 // -----------------------------------------------------------------------
 
 void FreetypeManager::AddFontFile( const rtl::OString& rNormalizedName,
-    int nFaceNum, int nFontId, const ImplFontData* pData )
+                                   int nFaceNum, int nFontId,
+                                   const ImplFontData* pData,
+                                   const unicodeKernMap* pKern
+                                   )
 {
     if( !rNormalizedName.getLength() )
         return;
@@ -457,7 +510,7 @@ void FreetypeManager::AddFontFile( const
     if( maFontList.find( nFontId ) != maFontList.end() )
         return;
 
-    FtFontInfo* pFI = new FtFontInfo( *pData, rNormalizedName, nFaceNum, nFontId, 0 );
+    FtFontInfo* pFI = new FtFontInfo( *pData, rNormalizedName, nFaceNum, nFontId, 0, pKern );
     maFontList[ nFontId ] = pFI;
     if( mnMaxFontId < nFontId )
         mnMaxFontId = nFontId;
@@ -482,8 +535,8 @@ long FreetypeManager::AddFontDir( const 
         rcOSL = aDirItem.getFileStatus( aFileStatus );
 
         ::rtl::OUString aUSytemPath;
-        OSL_VERIFY(  osl_File_E_None
-            == ::osl::FileBase::getSystemPathFromFileURL( aFileStatus.getFileURL(), aUSytemPath ));
+        OSL_VERIFY(  osl::FileBase::E_None
+            == osl::FileBase::getSystemPathFromFileURL( aFileStatus.getFileURL(), aUSytemPath ));
         ::rtl::OString aCFileName = rtl::OUStringToOString( aUSytemPath, theEncoding );
         const char* pszFontFileName = aCFileName.getStr();
 
@@ -556,8 +609,21 @@ long FreetypeManager::FetchFontList( Imp
     for( FontList::const_iterator it(maFontList.begin()); it != maFontList.end(); ++it, ++nCount )
     {
         const FtFontInfo& rFFI = *it->second;
-        ImplFontData* pFontData = new ImplFontData( rFFI.GetFontData() );
-        pToAdd->Add( pFontData );
+        rtl::OUString aFamilyName = rFFI.GetFontData().maName;
+        sal_Int32 nIndex = 0;
+        rtl::OUString aAliasNames = rFFI.GetFontData().maMapNames;
+        
+        do
+        {
+            ImplFontData* pFontData = new ImplFontData( rFFI.GetFontData() );
+            pFontData->maName = aFamilyName;
+            pFontData->maMapNames.Erase();
+            pToAdd->Add( pFontData );
+            if( nIndex >= 0 )
+                aFamilyName = aAliasNames.getToken( 0, ';', nIndex );
+            else
+                aFamilyName = rtl::OUString();
+        } while( aFamilyName.getLength() );
     }
 
     return nCount;
@@ -581,7 +647,7 @@ FreetypeServerFont* FreetypeManager::Cre
     if( it != maFontList.end() )
     {
         FtFontInfo* pFI = it->second;
-        FreetypeServerFont* pFont = new FreetypeServerFont( rFSD, pFI );
+        FreetypeServerFont* pFont = new FreetypeServerFont( rFSD, pFI, pFI->GetGlyphKernMap(), pFI->GetUnicodeKernMap() );
         return pFont;
     }
 
@@ -592,8 +658,8 @@ FreetypeServerFont* FreetypeManager::Cre
 // FreetypeServerFont
 // =======================================================================
 
-FreetypeServerFont::FreetypeServerFont( const ImplFontSelectData& rFSD, FtFontInfo* pFI )
-:   ServerFont( rFSD ),
+FreetypeServerFont::FreetypeServerFont( const ImplFontSelectData& rFSD, FtFontInfo* pFI, const glyphKernMap* pKern, const unicodeKernMap* pUniKern )
+:   ServerFont( rFSD, pKern, pUniKern ),
     mpFontInfo( pFI ),
     maFaceFT( NULL ),
     maSizeFT( NULL ),
@@ -856,23 +944,23 @@ int FreetypeServerFont::ApplyGlyphTransf
     case GF_ROTL:    // left
         nAngle += 900;
         bStretched = (mfStretch != 1.0);
-        aVector.x = +rMetrics.descender * mfStretch;
+        aVector.x = (long)((double)+rMetrics.descender * mfStretch);
         aVector.y = -rMetrics.ascender;
-        aMatrix.xx = -nSin / mfStretch;
-        aMatrix.yy = -nSin * mfStretch;
-        aMatrix.xy = -nCos * mfStretch;
-        aMatrix.yx = +nCos / mfStretch;
+        aMatrix.xx = (long)((double)-nSin / mfStretch);
+        aMatrix.yy = (long)((double)-nSin * mfStretch);
+        aMatrix.xy = (long)((double)-nCos * mfStretch);
+        aMatrix.yx = (long)((double)+nCos / mfStretch);
         break;
     case GF_ROTR:    // right
         nAngle -= 900;
         bStretched = (mfStretch != 1.0);
         aVector.x = -maFaceFT->glyph->metrics.horiAdvance;
-        aVector.x += (rMetrics.descender * nSin/65536.0);
-        aVector.y = -(rMetrics.descender * mfStretch * nCos/65536.0);
-        aMatrix.xx = +nSin / mfStretch;
-        aMatrix.yy = +nSin * mfStretch;
-        aMatrix.xy = +nCos * mfStretch;
-        aMatrix.yx = -nCos / mfStretch;
+        aVector.x += (long)((double)rMetrics.descender * nSin/65536.0);
+        aVector.y = -(long)((double)rMetrics.descender * mfStretch * nCos/65536.0);
+        aMatrix.xx = (long)((double)+nSin / mfStretch);
+        aMatrix.yy = (long)((double)+nSin * mfStretch);
+        aMatrix.xy = (long)((double)+nCos * mfStretch);
+        aMatrix.yx = (long)((double)-nCos / mfStretch);
         break;
     }
 
@@ -1049,9 +1137,9 @@ void FreetypeServerFont::InitGlyphData( 
     if( nGlyphFlags & GF_ROTMASK ) {  // for bVertical rotated glyphs
         const FT_Size_Metrics& rMetrics = maFaceFT->size->metrics;
 #if (FTVERSION < 2000)
-        nCharWidth = (rMetrics.height - rMetrics.descender) * mfStretch;
+        nCharWidth = (long)((double)(rMetrics.height - rMetrics.descender) * mfStretch);
 #else
-        nCharWidth = (rMetrics.height + rMetrics.descender) * mfStretch;
+        nCharWidth = (long)((double)(rMetrics.height + rMetrics.descender) * mfStretch);
 #endif
     }
     rGD.SetCharWidth( (nCharWidth + 32) >> 6 );
@@ -1314,34 +1402,6 @@ ULONG FreetypeServerFont::GetFontCodeRan
 {
     int nRangeCount = 0;
 
-#if 0 && (FTVERSION >= 2102)
-    // TODO: enable new version when it is fast enough for big fonts
-    // TODO: implement Get_Next_Missing_Char() and use this
-    FT_UInt nGlyphIndex = 0;
-    sal_uInt32 aChar = FT_Get_First_Char( maFaceFT, &nGlyphIndex );
-    if( nGlyphIndex )
-        nRangeCount = 1;
-    if( pCodes )
-        *(pCodes++) = aChar;            // start of first range
-    for(;;)
-    {
-        sal_uInt32 bChar = FT_Get_Next_Char( maFaceFT, aChar, &nGlyphIndex );
-        if( !nGlyphIndex )
-            break;
-        if( bChar != aChar+1 )
-        {
-            ++nRangeCount;
-            if( pCodes )
-            {
-                *(pCodes++) = aChar+1;  // end of old range
-                *(pCodes++) = bChar;    // start of new range
-            }
-        }
-        aChar = bChar;
-    }
-    if( pCodes && nRangeCount )
-        *(pCodes++) = aChar+1;          // end of last range
-#else
     const unsigned char* pCmap = NULL;
     ULONG nLength = 0;
     if( FT_IS_SFNT( maFaceFT ) )
@@ -1409,8 +1469,6 @@ ULONG FreetypeServerFont::GetFontCodeRan
                 *(pCodes++) = cCode;
         }
     }
-#endif
-
     return nRangeCount;
 }
 // -----------------------------------------------------------------------
@@ -1420,7 +1478,10 @@ ULONG FreetypeServerFont::GetFontCodeRan
 int FreetypeServerFont::GetGlyphKernValue( int nGlyphLeft, int nGlyphRight ) const
 {
     if( maSizeFT )
+
         pFTActivateSize( maSizeFT );
+    if( !FT_HAS_KERNING( maFaceFT ) || !FT_IS_SFNT( maFaceFT ) )
+        return ServerFont::GetGlyphKernValue( nGlyphLeft, nGlyphRight );
 
     FT_Vector aKernVal;
     FT_Error rcFT = FT_Get_Kerning( maFaceFT, nGlyphLeft, nGlyphRight,
@@ -1438,7 +1499,7 @@ ULONG FreetypeServerFont::GetKernPairs( 
 
     *ppKernPairs = NULL;
     if( !FT_HAS_KERNING( maFaceFT ) || !FT_IS_SFNT( maFaceFT ) )
-        return 0;
+        return ServerFont::GetKernPairs( ppKernPairs );
 
     // first figure out which glyph pairs are involved in kerning
     ULONG nKernLength = 0;
Index: vcl/source/gdi/makefile.mk
===================================================================
RCS file: /cvs/gsl/vcl/source/gdi/makefile.mk,v
retrieving revision 1.14
diff -u -p -u -r1.14 makefile.mk
--- vcl/source/gdi/makefile.mk	27 Mar 2003 17:57:58 -0000	1.14
+++ vcl/source/gdi/makefile.mk	5 Jul 2004 14:27:07 -0000
@@ -132,37 +132,19 @@ SLOFILES=	$(SLO)$/salmisc.obj 	\
 			$(SLO)$/fontcfg.obj		\
 			$(SLO)$/base14.obj		\
 			$(SLO)$/pdfwriter.obj	\
-			$(SLO)$/pdfwriter_impl.obj\
-			$(SLO)$/bmpconv.obj
+			$(SLO)$/pdfwriter_impl.obj	\
+			$(SLO)$/sallayout.obj		\
+			$(SLO)$/salgdilayout.obj	\
+			$(SLO)$/salnativewidgets-none.obj	\
+			$(SLO)$/bmpconv.obj		\
+			$(SLO)$/pngread.obj		\
+			$(SLO)$/pngwrite.obj	
 
-.IF "$(remote)"==""
-	SLOFILES += $(SLO)$/salgdilayout.obj
-.ENDIF
-
-.IF "$(ENABLE_CTL)"!=""
-	SLOFILES +=     $(SLO)$/sallayout.obj
-.ENDIF
-
-.IF "$(remote)"!=""
-EXCEPTIONSFILES=	$(SLO)$/bitmap.obj		\
-					$(SLO)$/color.obj		\
-					$(SLO)$/gfxlink.obj		\
-					$(SLO)$/impgraph.obj	\
-					$(SLO)$/impvect.obj 	\
-					$(SLO)$/outdev.obj		\
-					$(SLO)$/outdev3.obj 	\
-					$(SLO)$/outdev6.obj		\
-					$(SLO)$/print.obj		\
-					$(SLO)$/print2.obj		\
-					$(SLO)$/virdev.obj		
-
-.ELSE
 EXCEPTIONSFILES=	$(SLO)$/outdev.obj		\
 					$(SLO)$/gfxlink.obj		\
 					$(SLO)$/print.obj		\
 					$(SLO)$/impgraph.obj	\
 					$(SLO)$/bmpconv.obj
-.ENDIF
 
 # --- Targets ------------------------------------------------------
 
Index: vcl/unx/source/plugadapt/makefile.mk
===================================================================
RCS file: vcl/unx/source/plugadapt/makefile.mk
diff -N vcl/unx/source/plugadapt/makefile.mk
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/source/plugadapt/makefile.mk	18 Nov 2003 14:46:57 -0000	1.2
@@ -0,0 +1,98 @@
+#*************************************************************************
+#
+#   
+#
+#   
+#
+#   
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=vcl
+TARGET=salplug
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  svpre.mk
+.INCLUDE :  settings.mk
+.INCLUDE :  sv.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(GUIBASE)"!="unx"
+
+dummy:
+	@echo "Nothing to build for GUIBASE $(GUIBASE)"
+
+.ELSE		# "$(GUIBASE)"!="unx"
+
+CFLAGS+=-DSAL_DLLPOSTFIX=\"$(DLLPOSTFIX)\"
+
+OBJFILES=$(OBJ)$/salmain.obj
+
+SLOFILES=\
+	$(SLO)$/salplug.obj\
+	$(SLO)$/salmain.obj\
+
+.ENDIF		# "$(GUIBASE)"!="unx"
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+.INCLUDE :  $(PRJ)$/util$/target.pmk
Index: vcl/unx/source/plugadapt/salmain.cxx
===================================================================
RCS file: vcl/unx/source/plugadapt/salmain.cxx
diff -N vcl/unx/source/plugadapt/salmain.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/source/plugadapt/salmain.cxx	6 Jan 2004 14:44:11 -0000	1.3
@@ -0,0 +1,99 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifdef MACOSX
+// rlimit needs sys/types.h
+#include <sys/types.h>
+#include <sys/time.h>
+#endif
+
+#include <sys/resource.h>
+#include <unistd.h>
+#include <salunx.h>
+
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+#ifndef _SV_SALINST_HXX
+#include <salinst.hxx>
+#endif
+ 
+#include <svapp.hxx>
+
+// -=-= main() -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
+BEGIN_C
+
+int main( int argc, char *argv[] )
+{
+	rlimit aLimit;
+	if ( !getrlimit( RLIMIT_NOFILE, &aLimit ) )
+	{
+		aLimit.rlim_cur = aLimit.rlim_max;
+		setrlimit( RLIMIT_NOFILE, &aLimit );
+	}
+		
+    SVMain();
+
+    return 0;
+}
+
+END_C
+
Index: vcl/unx/source/plugadapt/salplug.cxx
===================================================================
RCS file: vcl/unx/source/plugadapt/salplug.cxx
diff -N vcl/unx/source/plugadapt/salplug.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vcl/unx/source/plugadapt/salplug.cxx	2 Jun 2004 14:55:50 -0000	1.9
@@ -0,0 +1,493 @@
+/*************************************************************************
+ *
+ *  
+ *
+ *  
+ *
+ *  
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef OSL_MODULE_H
+#include <osl/module.h>
+#endif
+#ifndef OSL_PROCESS_H
+#include <osl/process.h>
+#endif
+#ifndef RTL_STRING_HXX
+#include <rtl/ustrbuf.hxx>
+#endif
+
+#include <svunx.h>
+#include <prex.h>
+#include <X11/Xatom.h>
+#include <postx.h>
+
+#include <salinst.hxx>
+#include <saldata.hxx>
+
+#include <cstdio>
+#include <unistd.h>
+
+using namespace rtl;
+
+typedef SalInstance*(*salFactoryProc)( oslModule pModule);
+
+static oslModule pCloseModule = NULL;
+
+#define DESKTOP_NONE 0
+#define DESKTOP_UNKNOWN 1
+#define DESKTOP_GNOME 2
+#define DESKTOP_KDE 3
+#define DESKTOP_CDE 4
+
+static const char * desktop_strings[5] = { "none", "unknown", "GNOME", "KDE", "CDE" };
+
+static SalInstance* tryInstance( const OUString& rModuleBase )
+{
+    SalInstance* pInst = NULL;
+    
+    OUStringBuffer aModName( 128 );
+    aModName.appendAscii( SAL_DLLPREFIX"vclplug_" );
+    aModName.append( rModuleBase );
+    aModName.append( (sal_Int32)SUPD );
+    aModName.appendAscii( SAL_DLLPOSTFIX );
+    aModName.appendAscii( SAL_DLLEXTENSION );
+    OUString aModule = aModName.makeStringAndClear();
+
+    oslModule aMod = osl_loadModule( aModule.pData, SAL_LOADMODULE_DEFAULT );
+    if( aMod )
+    {
+        OUString aSym( RTL_CONSTASCII_USTRINGPARAM( "create_SalInstance" ) );
+        salFactoryProc aProc = (salFactoryProc)osl_getSymbol( aMod, aSym.pData );
+        if( aProc )
+        {
+            pInst = aProc( aMod );
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "sal plugin %s produced instance %p\n", 
+                     OUStringToOString( aModule, RTL_TEXTENCODING_ASCII_US ).getStr(),
+                     pInst );
+#endif
+            if( pInst )
+                pCloseModule = aMod;
+            else
+                osl_unloadModule( aMod );
+        }
+        else
+        {
+#if OSL_DEBUG_LEVEL > 1
+            fprintf( stderr, "could not load symbol %s from shared object %s\n",
+                     OUStringToOString( aSym, RTL_TEXTENCODING_ASCII_US ).getStr(),
+                     OUStringToOString( aModule, RTL_TEXTENCODING_ASCII_US ).getStr() );
+#endif
+            osl_unloadModule( aMod );
+        }
+    }
+#if OSL_DEBUG_LEVEL > 1
+    else
+        fprintf( stderr, "could not load shared object %s\n",
+                 OUStringToOString( aModule, RTL_TEXTENCODING_ASCII_US ).getStr() );
+#endif  
+
+    return pInst;
+}
+
+static bool is_gnome_desktop( Display* pDisplay )
+{
+    bool ret = false;
+    
+    // warning: this check is coincidental, GNOME does not
+    // explicitly advertise itself
+    Atom nAtom1 = XInternAtom( pDisplay, "GNOME_SM_PROXY", True );
+    Atom nAtom2 = XInternAtom( pDisplay, "NAUTILUS_DESKTOP_WINDOW_ID", True );
+    if( nAtom1 || nAtom2 )
+    {
+        int nProperties = 0;
+        Atom* pProperties = XListProperties( pDisplay, DefaultRootWindow( pDisplay ), &nProperties );
+        if( pProperties && nProperties )
+        {
+            for( int i = 0; i < nProperties; i++ )
+                if( pProperties[ i ] == nAtom1 ||
+                    pProperties[ i ] == nAtom2 )
+                {
+                    ret = true;
+                }
+            XFree( pProperties );
+        }
+    }
+    if( ! ret )
+    {
+        Atom nUTFAtom		= XInternAtom( pDisplay, "UTF8_STRING", True );
+        Atom nNetWMNameAtom	= XInternAtom( pDisplay, "_NET_WM_NAME", True );
+        if( nUTFAtom && nNetWMNameAtom )
+        {
+            // another, more expensive check: search for a gnome-panel
+            XLIB_Window aRoot, aParent, *pChildren = NULL;
+            unsigned int nChildren = 0;
+            XQueryTree( pDisplay, DefaultRootWindow( pDisplay ),
+                        &aRoot, &aParent, &pChildren, &nChildren );
+            if( pChildren && nChildren )
+            {
+                for( unsigned int i = 0; i < nChildren && ! ret; i++ )
+                {
+                    Atom nType = None;
+                    int nFormat = 0;
+                    unsigned long nItems = 0, nBytes = 0;
+                    unsigned char* pProp = NULL;
+                    XGetWindowProperty( pDisplay,
+                                        pChildren[i],
+                                        nNetWMNameAtom,
+                                        0, 8,
+                                        False,
+                                        nUTFAtom,
+                                        &nType,
+                                        &nFormat,
+                                        &nItems,
+                                        &nBytes,
+                                        &pProp );
+                    if( pProp && nType == nUTFAtom )
+                    {
+                        OString aWMName( (sal_Char*)pProp );
+                        if( aWMName.equalsIgnoreAsciiCase( "gnome-panel" ) )
+                            ret = true;
+                    }
+                    if( pProp )
+                        XFree( pProp );
+                }
+                XFree( pChildren );
+            }
+        }
+    }
+
+    return ret;
+}
+
+static bool bWasXError = false;
+
+static inline bool WasXError()
+{
+    bool bRet = bWasXError;
+    bWasXError = false;
+    return bRet;
+}
+
+extern "C"
+{
+    static int autodect_error_handler( Display*, XErrorEvent* )
+    {
+        bWasXError = true;
+        return 0;
+    }
+    
+    typedef int(* XErrorHandler)(Display*,XErrorEvent*);
+}
+
+static OUString getNetWMName( Display* pDisplay )
+{
+    OUString aRet;
+
+    Atom nWmCheck	= XInternAtom( pDisplay, "_NET_SUPPORTING_WM_CHECK", True );
+    Atom nWmName	= XInternAtom( pDisplay, "_NET_WM_NAME", True );
+    if( nWmName && nWmCheck )
+    {
+        XLIB_Window			aCheckWin	= None;
+        Atom				aRealType	= None;
+        int					nFormat		= 8;
+        unsigned long		nItems		= 0;
+        unsigned long		nBytesLeft	= 0;
+        unsigned char*	pProperty	= NULL;
+        XGetWindowProperty( pDisplay,
+                            DefaultRootWindow( pDisplay ),
+                            nWmCheck,
+                            0, 1,
+                            False,
+                            XA_WINDOW,
+                            &aRealType,
+                            &nFormat,
+                            &nItems,
+                            &nBytesLeft,
+                            &pProperty );
+        if( aRealType == XA_WINDOW && nFormat == 32 && nItems != 0 )
+            aCheckWin = *(XLIB_Window*)pProperty;
+        if( pProperty )
+        {
+            XFree( pProperty );
+            pProperty = NULL;
+        }
+
+        // see if that window really exists and has the check property set
+        if( aCheckWin != None )
+        {
+            // clear error flag
+            WasXError();
+            // get the property
+            XGetWindowProperty( pDisplay,
+                                aCheckWin,
+                                nWmCheck,
+                                0, 1,
+                                False,
+                                XA_WINDOW,
+                                &aRealType,
+                                &nFormat,
+                                &nItems,
+                                &nBytesLeft,
+                                &pProperty );
+            if( ! WasXError() && aRealType == XA_WINDOW && nFormat == 32 && nItems != 0 && pProperty )
+            {
+                if( aCheckWin == *(XLIB_Window*)pProperty )
+                {
+                    XFree( pProperty );
+                    pProperty = NULL;
+                    XGetWindowProperty( pDisplay,
+                                        aCheckWin,
+                                        nWmName,
+                                        0, 256,
+                                        False,
+                                        AnyPropertyType,
+                                        &aRealType,
+                                        &nFormat,
+                                        &nItems,
+                                        &nBytesLeft,
+                                        &pProperty );
+                    if( !WasXError() && nItems != 0 && pProperty && *pProperty )
+                    {
+                        if( aRealType == XA_STRING ) // some WM's use this although the should use UTF8_STRING
+                        {
+                            aRet = rtl::OStringToOUString( rtl::OString( (sal_Char*)pProperty ), RTL_TEXTENCODING_ISO_8859_1 );
+                        }
+                        else
+                            aRet = rtl::OStringToOUString( rtl::OString( (sal_Char*)pProperty ), RTL_TEXTENCODING_UTF8 );                        
+                    }
+                }
+            }
+            if( pProperty )
+            {
+                XFree( pProperty );
+                pProperty = NULL;
+            }
+        }
+    }
+    return aRet;
+}
+
+static bool is_kde_desktop( Display* pDisplay )
+{
+    // check for kwin
+    rtl::OUString aWM = getNetWMName( pDisplay );
+    if( aWM.equalsIgnoreAsciiCaseAscii( "KWin" ) )
+        return true;
+    
+    return false;
+}
+
+static bool is_cde_desktop( Display* pDisplay )
+{
+    void* pLibrary = NULL;
+
+    Atom nDtAtom = XInternAtom( pDisplay, "_DT_WM_READY", True );
+    OUString aPathName( RTL_CONSTASCII_USTRINGPARAM( "file:///usr/dt/lib/libDtSvc.so" ) );
+    if( nDtAtom && ( pLibrary = osl_loadModule( aPathName.pData, SAL_LOADMODULE_DEFAULT ) ) )
+    {
+        osl_unloadModule( pLibrary );
+        return true;
+    }
+    
+    return false;
+}
+
+
+static const char * get_desktop_environment()
+{
+    static const char *pRet = NULL;
+    
+    if ( NULL == pRet )
+    {
+        // get display to connect to
+        const char* pDisplayStr = getenv( "DISPLAY" );
+        int nParams = osl_getCommandArgCount();
+        OUString aParam;
+        OString aBParm;
+        for( int i = 0; i < nParams-1; i++ )
+        {
+            osl_getCommandArg( i, &aParam.pData );
+            if( aParam.equalsAscii( "-display" ) || aParam.equalsAscii( "--display" ) )
+            {
+                osl_getCommandArg( i+1, &aParam.pData );
+                aBParm = OUStringToOString( aParam, osl_getThreadTextEncoding() );
+                pDisplayStr = aBParm.getStr();
+                break;
+            }
+        }
+    
+        // no server at all
+        if( ! pDisplayStr || !*pDisplayStr )
+            pRet = desktop_strings[DESKTOP_NONE];
+        else
+        {
+            Display* pDisplay = XOpenDisplay( pDisplayStr );
+            if( pDisplay )
+            {
+                XErrorHandler pOldHdl = XSetErrorHandler( autodect_error_handler );
+            
+                if ( is_gnome_desktop( pDisplay ) )
+                    pRet = desktop_strings[DESKTOP_GNOME];
+                else if ( is_kde_desktop( pDisplay ) )
+                    pRet = desktop_strings[DESKTOP_KDE];
+                else if ( is_cde_desktop( pDisplay ) )
+                    pRet = desktop_strings[DESKTOP_CDE];
+                else
+                    pRet = desktop_strings[DESKTOP_UNKNOWN];
+                    
+                // set the default handler again
+                XSetErrorHandler( pOldHdl );
+                
+                XCloseDisplay( pDisplay );
+            }
+        }
+    }
+
+    return pRet;
+}
+
+
+static const char* autodetect_plugin()
+{
+    const char * desktop = get_desktop_environment();
+    const char * pRet = NULL;
+    
+    // no server at all: dummy plugin
+    if ( desktop == desktop_strings[DESKTOP_NONE] )
+        pRet = "dummy";
+    else if ( desktop == desktop_strings[DESKTOP_GNOME] )
+        pRet = "gtk";
+    else if( desktop == desktop_strings[DESKTOP_KDE] )
+        pRet = "kde";
+    else
+        pRet = "gen";
+        
+#if OSL_DEBUG_LEVEL > 1
+    fprintf( stderr, "plugin autodetection: %s\n", pRet );
+#endif
+
+    return pRet;
+}
+
+SalInstance *CreateSalInstance()
+{
+    SalInstance*	pInst = NULL;
+
+    static const char* pUsePlugin = getenv( "SAL_USE_VCLPLUGIN" );
+
+    if( !(pUsePlugin && *pUsePlugin) )
+        pUsePlugin = autodetect_plugin();
+    
+    if( pUsePlugin && *pUsePlugin )
+        pInst = tryInstance( OUString::createFromAscii( pUsePlugin ) );
+
+    // fallback to gen
+    if( ! pInst )
+        pInst = tryInstance( OUString( RTL_CONSTASCII_USTRINGPARAM( "gen" ) ) );
+
+    if( ! pInst )
+    {
+        fprintf( stderr, "no suitable windowing system found, exiting.\n" );
+        _exit( 1 );
+    }
+
+    // acquire SolarMutex
+    pInst->AcquireYieldMutex( 1 );
+    
+	return pInst;
+}
+
+void DestroySalInstance( SalInstance *pInst )
+{
+    // release SolarMutex
+    pInst->ReleaseYieldMutex();
+
+	delete pInst;
+    if( pCloseModule )
+        osl_unloadModule( pCloseModule );
+}
+
+void InitSalData()
+{
+}
+
+void DeInitSalData()
+{
+}
+
+void InitSalMain()
+{
+}
+
+void DeInitSalMain()
+{
+}
+
+void SalAbort( const XubString& rErrorText )
+{
+	if( !rErrorText.Len() )
+		fprintf( stderr, "Application Error" );
+	else
+		fprintf( stderr, ByteString( rErrorText, gsl_getSystemTextEncoding() ).GetBuffer() );
+	abort();
+}
+
+const OUString& SalGetDesktopEnvironment()
+{
+    static OUString aRet = OStringToOUString(OString(get_desktop_environment()), RTL_TEXTENCODING_ASCII_US);
+    return aRet;
+}
Index: vcl/source/app/access.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/Attic/access.cxx,v
retrieving revision 1.1.1.1
diff -u -p -u -r1.1.1.1 access.cxx
--- vcl/source/app/access.cxx	18 Sep 2000 17:05:35 -0000	1.1.1.1
+++ vcl/source/app/access.cxx	6 Jul 2004 01:20:06 -0000
@@ -335,7 +335,7 @@ void AccessObject::Execute( long nExtern
 	{
 		case ACCESS_TYPE_MENUITEM:
 			{
-			if ( ((Menu*)mpType)->bIsMenuBar )
+			if ( ((Menu*)mpType)->IsMenuBar() )
 				((MenuBar*)mpType)->SelectEntry( (USHORT) mnData1 );
 			else
 				((PopupMenu*)mpType)->SelectEntry( (USHORT) mnData1 );
@@ -662,7 +662,7 @@ XubString AccessObject::GetType()
 			{
 			Menu* pMenu = (Menu*)mpType;
 
-			if ( pMenu->bIsMenuBar )
+			if ( pMenu->IsMenuBar() )
 				pStr = "MenuBar";
 			else
 				pStr = "Menu";
Index: vcl/source/app/oldsv.cxx
===================================================================
RCS file: /cvs/gsl/vcl/source/app/Attic/oldsv.cxx,v
retrieving revision 1.9
diff -u -p -u -r1.9 oldsv.cxx
--- vcl/source/app/oldsv.cxx	11 Oct 2002 08:37:20 -0000	1.9
+++ vcl/source/app/oldsv.cxx	6 Jul 2004 02:11:39 -0000
@@ -98,25 +98,6 @@
 
 // ------------------------------------------------------------------------
 
-TYPEINIT0(ApplicationProperty)
-
-// ------------------------------------------------------------------------
-
-static PropertyHandler* pHandler=0;
-
-void Application::Property( ApplicationProperty& rProp )
-{
-    if ( pHandler )
-        pHandler->Property( rProp );
-}
-
-void Application::SetPropertyHandler( PropertyHandler* p )
-{
-    if ( pHandler )
-        delete pHandler;
-    pHandler = p;
-}
-
 void Application::EnterWait()
 {
     if ( Application::GetAppWindow() )
@@ -316,52 +297,6 @@ Color OutputDevice::GetSolidColor( const
     return rColor;
 }
 
-// ------------------------------------------------------------------------
-
-
-void WorkWindow::ImplSetFrameState( ULONG aFrameState )
-{
-    Window* pWindow = mpFrameWindow;
-
-#ifndef REMOTE_APPSERVER
-    SalFrameState   aState;
-    aState.mnMask   = SAL_FRAMESTATE_MASK_STATE;
-    aState.mnState  = aFrameState; //SAL_FRAMESTATE_MAXIMIZED;
-    mpFrame->SetWindowState( &aState );
-#else
-    //ByteString aStr;
-    //ImplWindowStateToStr( rData, aStr );
-    //mpFrame->SetWindowState( ::rtl::OUString( aStr.GetBuffer(), aStr.Len(), RTL_TEXTENCODING_ASCII_US ) );
-#endif
-
-    // Syncrones Resize ausloesen, damit wir nach Moeglichkeit gleich
-    // mit der richtigen Groesse rechnen
-    long nNewWidth;
-    long nNewHeight;
-    pWindow->mpFrame->GetClientSize( nNewWidth, nNewHeight );
-    ImplHandleResize( pWindow, nNewWidth, nNewHeight );
-}
-
-
-void WorkWindow::Minimize()
-{
-    ImplSetFrameState( SAL_FRAMESTATE_MINIMIZED );
-}
-
-void WorkWindow::Maximize()
-{
-    ImplSetFrameState( SAL_FRAMESTATE_MAXIMIZED );
-}
-
-void WorkWindow::Restore()
-{
-    ImplSetFrameState( SAL_FRAMESTATE_NORMAL );
-}
-
-BOOL WorkWindow::IsMaximized() const
-{
-    return FALSE;
-}
 
 // ------------------------------------------------------------------------
 /*
@@ -471,8 +406,4 @@ USHORT Application::DispatchAppEvents()
     }
 
     return nEvents;
-}
-
-void Application::AppEvent( const ApplicationEvent& rAppEvent )
-{
 }
Index: vcl/unx/inc/salbmp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/Attic/salbmp.hxx,v
retrieving revision 1.3.274.1
diff -u -p -u -r1.3.274.1 salbmp.hxx
--- vcl/unx/inc/salbmp.hxx	15 Jan 2004 12:51:23 -0000	1.3.274.1
+++ vcl/unx/inc/salbmp.hxx	6 Jul 2004 11:46:09 -0000
@@ -59,229 +59,5 @@
  *
  ************************************************************************/
 
-#ifndef _SV_SALBMP_HXX
-#define _SV_SALBMP_HXX
-
-#ifndef _SALSTD_HXX
-#include <salstd.hxx>
-#endif
-#ifndef _SV_SALGTYPE
-#include <salgtype.hxx>
-#endif
-#ifndef _SV_SALDISP_HXX
-#include <saldisp.hxx>
-#endif
-
-struct	BitmapBuffer;
-class	BitmapPalette;
-class	SalGraphics;
-class	ImplSalDDB;
-class	ImplSalBitmapCache;
-
-// -------------
-// - SalBitmap -
-// -------------
-
-class SalBitmap
-{
-private:
-
-	static BitmapBuffer*		ImplCreateDIB( const Size& rSize,
-											   USHORT nBitCount, 
-											   const BitmapPalette& rPal );
-	static BitmapBuffer*		ImplCreateDIB( Drawable aDrawable,
-											   long nDrawableDepth,
-											   long nX, long nY,
-											   long nWidth, long nHeight );
-
-public:
-
-	static ImplSalBitmapCache*	mpCache;
-	static ULONG				mnCacheInstCount;
-
-	static void					ImplCreateCache();
-	static void					ImplDestroyCache();
-    void				        ImplRemovedFromCache();
-
-    BOOL                        SnapShot (Display* pDisplay, XLIB_Window hWindow);
-    BOOL                        ImplCreateFromXImage (Display* pDisplay, XLIB_Window hWindow, 
-                                                      XImage* pImage);
-private:
-
-
-	BitmapBuffer*	mpDIB;
-	ImplSalDDB*		mpDDB;
-								
-public:
-
-	BOOL			ImplCreateFromDrawable( 
-#ifdef _USE_PRINT_EXTENSION_ 
-											SalDisplay* pDisplay,
-#endif
-											Drawable aDrawable, 
-											long nDrawableDepth,
-											long nX, long nY, 
-											long nWidth, long nHeight );
-
-	BOOL			ImplCreateLocalFromDrawable( 
-											Drawable aDrawable, 
-											long nDrawableDepth,
-											long nX, long nY, 
-											long nWidth, long nHeight );
-
-	XImage*			ImplCreateXImage( 
-											SalDisplay* pSalDisp, long nDepth, 
-									  		const SalTwoRect& rTwoRect ) const;
-#ifdef _USE_PRINT_EXTENSION_
-	void			ImplDraw( SalDisplay *pDisplay, Drawable aDrawable, long nDrawableDepth, 
-							  const SalTwoRect& rTwoRect, const GC& rGC ) const;
-#else
-	void			ImplDraw( Drawable aDrawable, long nDrawableDepth, 
-							  const SalTwoRect& rTwoRect, const GC& rGC ) const;
-#endif
-						
-public:					
-								
-					SalBitmap();
-					~SalBitmap();
-						
-	BOOL			Create( const Size& rSize, 
-							USHORT nBitCount, 
-							const BitmapPalette& rPal );
-	BOOL			Create( const SalBitmap& rSalBmp );
-	BOOL			Create( const SalBitmap& rSalBmp, 
-							SalGraphics* pGraphics );
-	BOOL			Create( const SalBitmap& rSalBmp,
-							USHORT nNewBitCount );
-						
-	void			Destroy();
-						
-	Size			GetSize() const;
-	USHORT			GetBitCount() const;
-						
-	BitmapBuffer*	AcquireBuffer( BOOL bReadOnly );
-	void			ReleaseBuffer( BitmapBuffer* pBuffer, BOOL bReadOnly );
-};
-
-// --------------
-// - ImplSalDDB -
-// --------------
-
-class ImplSalDDB
-{
-private:
-
-	Pixmap			maPixmap;
-	SalTwoRect		maTwoRect;
-	long			mnDepth;
-
-					ImplSalDDB() {}
-
-    static void	ImplDraw( 
-#ifdef _USE_PRINT_EXTENSION_ 
-								SalDisplay* pDisplay,
-#endif
-    Drawable aSrcDrawable, long nSrcDrawableDepth,
-						      Drawable aDstDrawable, long nDstDrawableDepth,
-						      long nSrcX, long nSrcY, 
-						      long nDestWidth, long nDestHeight, 
-						      long nDestX, long nDestY, const GC& rGC );
-					
-public:				
-					
-					ImplSalDDB( 
-#ifdef _USE_PRINT_EXTENSION_ 
-								SalDisplay* pDisplay,
-#endif
-								XImage* pImage, Drawable aDrawable, 
-								const SalTwoRect& rTwoRect );
-					ImplSalDDB( 
-#ifdef _USE_PRINT_EXTENSION_ 
-								SalDisplay* pDisplay,
-#endif
-								Drawable aDrawable, long nDrawableDepth, 
-								long nX, long nY, long nWidth, long nHeight );
-                    ImplSalDDB (Display* pDisplay, XLIB_Window hWindow, XImage* pImage); 
-					~ImplSalDDB();
-					
-	Pixmap			ImplGetPixmap() const { return maPixmap; }
-	long			ImplGetWidth() const { return maTwoRect.mnDestWidth; }
-	long			ImplGetHeight() const { return maTwoRect.mnDestHeight; }
-	long			ImplGetDepth() const { return mnDepth; }
-	ULONG			ImplGetMemSize() const { return( ( maTwoRect.mnDestWidth * maTwoRect.mnDestHeight * mnDepth ) >> 3 ); }
-					
-	BOOL			ImplMatches( long nDepth, const SalTwoRect& rTwoRect ) const;
-	void			ImplDraw( 
-#ifdef _USE_PRINT_EXTENSION_ 
-								SalDisplay* pDisplay,
-#endif
-								Drawable aDrawable, long nDrawableDepth, 
-								const SalTwoRect& rTwoRect, const GC& rGC ) const;
-};
-
-// ----------------------
-// - ImplSalBitmapCache -
-// ----------------------
-
-class ImplSalBitmapCache
-{
-private:
-
-	List			maBmpList;
-	ULONG			mnTotalSize;
-
-public:				
-					
-					ImplSalBitmapCache();
-					~ImplSalBitmapCache();
-
-	void			ImplAdd( SalBitmap* pBmp, ULONG nMemSize = 0UL, ULONG nFlags = 0UL );
-	void			ImplRemove( SalBitmap* pBmp );
-	void			ImplClear();
-};
-
-#endif // _SV_SALBMP_HXX
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
+// Having dollar Foos in files is _really_ painful
+#include "../../inc/salbmp.hxx"
