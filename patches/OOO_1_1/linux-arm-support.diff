diff --exclude=unxlngr.pro -urN openoffice.org-1.1.1/bridges/prj/build.lst openoffice.org-1.1.1-arm/bridges/prj/build.lst
--- bridges/prj/build.lst	2004-01-28 11:53:01.000000000 +0000
+++ bridges/prj/build.lst	2004-06-22 11:40:23.000000000 +0100
@@ -15,6 +15,7 @@
 br	bridges\source\cpp_uno\gcc3_linux_powerpc	nmake	-	u	br_gcclp3 br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_linux_s390		nmake	-	u	br_gccl33 br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_linux_sparc		nmake	-	u	br_gccl3s br_unotypes NULL
+br	bridges\source\cpp_uno\gcc3_linux_arm		nmake	-	u	br_gccl3r br_unotypes NULL
 br	bridges\source\cpp_uno\gcc2_macosx_powerpc			nmake	-	u	br_gccmacoxp br_unotypes NULL
 br	bridges\source\cpp_uno\gcc3_macosx_powerpc			nmake	-	u	br_gcc3macoxp br_unotypes NULL
 br	bridges\source\cpp_uno\cc50_solaris_sparc			nmake	-	u	br_cc50sols br_unotypes NULL
diff --exclude=unxlngr.pro -urN openoffice.org-1.1.1/bridges/source/cpp_uno/gcc3_linux_arm/armhelper.s openoffice.org-1.1.1-arm/bridges/source/cpp_uno/gcc3_linux_arm/armhelper.s
--- bridges/source/cpp_uno/gcc3_linux_arm/armhelper.s	1970-01-01 01:00:00.000000000 +0100
+++ bridges/source/cpp_uno/gcc3_linux_arm/armhelper.s	2004-07-20 15:11:10.000000000 +0100
@@ -0,0 +1,116 @@
+
+	.file	"armhelper.s"
+
+@ ARM support code for OpenOffice C++/UNO bridging
+@
+@ Written by Peter Naulls <peter@chocky.org>
+@
+@ This code avoids the dynamically generated code used on other
+@ platforms to intercept and make virtual method calls.  This
+@ avoids the need to flush the-icache, although it does mean some
+@ guessing to determine the index.
+
+
+@ Call a virtual function with an arbitrary number of words
+@
+@ With 4 or less parameters, the function is directly jumped to.
+@ With more, parameters are pushed on the stack, and a stack
+@ frame is saved so the state can be restored.
+@
+@ r0: pThis
+@ r1: nStackLongs
+@ r2: pStackLongs
+@ r3: nVtableIndex
+
+        .global arm_callVirtualMethod
+        .type   arm_callVirtualMethod, %function
+arm_callVirtualMethod:
+        ldr     r0, [r0, #0]           @ get class reference
+        ldr     ip, [r0, r3, lsl #2]   @ get method
+
+        cmp     r1, #5
+        ldmltia r2, {r0-r3}            @ load register params
+        movlt   pc, ip                 @ don't return to this function
+
+        mov     r0, ip
+
+        mov     ip, sp
+        stmfd   sp!, {fp, ip, lr, pc}
+        sub     fp, ip, #4
+
+
+        @ push paramters after #4 onto the stack
+        sub     r1, r1, #4
+        add     r2, r2, #16
+.Lstack:
+        cmp     r1, #0
+        subgt   r1, r1, #1
+        ldrgt   r3, [r2, r1, lsl #2]
+        strgt   r3, [sp, #-4]!
+        bgt     .Lstack
+
+        mov     ip, r0
+
+        ldmdb   r2, {r0-r3}        @ load register params
+        mov     lr, pc             @ save return address
+        mov     pc, ip             @ jump to function
+
+        ldmea   fp, {fp, sp, pc}   @ return
+
+
+
+
+@ Intercept a virtual call with a simple return type
+
+        .type   arm_codeSnippetSimple, %function
+        .global arm_codeSnippetSimple
+arm_codeSnippetSimple:
+        stmfd sp!, {r0-r3}         @  follow other parameters on stack
+        stmfd sp!, {lr}
+
+        ldr   r0, [lr, #-4]        @ Fetch the vtable LDR instruction
+        and   r1, r0, #0x05900000  @ Check that it's really an LDR
+        cmp   r1, #0x05900000      @ If not, fetch from further back
+        ldrne r0, [lr, #-20]
+        andne r1, r0, #0x05900000  @ Check again
+        cmpne r1, #0x05900000      @
+        ldrne r0, [lr, #-24]       @ If not, fetch from one more back
+
+        mov   r0, r0, lsr #2       @ Divide by 4 to get the table offset
+        and   r0, r0, #0xff        @ Get the index from the instruction
+
+        add   r1, sp, #4           @ r1 points to this and params
+        bl    cpp_vtable_call(PLT)
+
+        add  sp, sp, #20           @ restore stack
+        ldr  pc, [sp, #-20]        @ return
+
+
+@ Intercept a virtual call with a complex return type
+
+        .type   arm_codeSnippetComplex, %function
+        .global arm_codeSnippetComplex
+arm_codeSnippetComplex:
+        stmfd sp!, {r0-r3}         @ follow other parameters on stack
+        stmfd sp!, {lr}
+
+        ldr   r0, [lr, #-4]        @ Fetch the vtable LDR instruction
+        and   r1, r0, #0x05900000  @ Check that it's really an LDR
+        cmp   r1, #0x05900000      @ If not, fetch from further back
+        ldrne r0, [lr, #-20]
+        andne r1, r0, #0x05900000  @ Check again
+        cmpne r1, #0x05900000      @
+        ldrne r0, [lr, #-24]       @ If not, fetch from one more back
+
+        mov  r0, r0, lsr #2        @ Divide by 4 to get the table offset
+        and  r0, r0, #0xff         @ Get the index from the instruction
+        orr  r0, r0, #1<<31        @ Set top bit to indicate complex return
+        
+        add  r1, sp, #4            @ r1 points to this and params
+        bl   cpp_vtable_call(PLT)
+
+        add  sp, sp, #20           @ restore stack
+        ldr  pc, [sp, #-20]        @ return
+
+
+
diff --exclude=unxlngr.pro -urN openoffice.org-1.1.1/bridges/source/cpp_uno/gcc3_linux_arm/cpp2uno.cxx openoffice.org-1.1.1-arm/bridges/source/cpp_uno/gcc3_linux_arm/cpp2uno.cxx
--- bridges/source/cpp_uno/gcc3_linux_arm/cpp2uno.cxx	1970-01-01 01:00:00.000000000 +0100
+++ bridges/source/cpp_uno/gcc3_linux_arm/cpp2uno.cxx	2004-07-20 15:13:47.000000000 +0100
@@ -0,0 +1,560 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s):  Modified for ARM support by Peter Naulls <peter@chocky.org>
+ *
+ *
+ ************************************************************************/
+
+#include <malloc.h>
+#include <hash_map>
+
+#include <rtl/alloc.h>
+#include <osl/mutex.hxx>
+
+#include <uno/data.h>
+#include <typelib/typedescription.hxx>
+
+#include <bridges/cpp_uno/bridge.hxx>
+#include <bridges/cpp_uno/type_misc.hxx>
+
+#include "share.hxx"
+
+
+using namespace ::osl;
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+//==================================================================================================
+rtl_StandardModuleCount g_moduleCount = MODULE_COUNT_INIT;
+
+//==================================================================================================
+static typelib_TypeClass cpp2uno_call(
+	cppu_cppInterfaceProxy * pThis,
+	const typelib_TypeDescription * pMemberTypeDescr,
+	typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+	void ** pCallStack,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+	// pCallStack: ret, [return ptr], this, params
+	char * pCppStack = (char *)(pCallStack + 0);
+
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	if (pReturnTypeRef)
+		TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	
+	void * pUnoReturn = 0;
+	void * pCppReturn = 0; // complex return ptr: if != 0 && != pUnoReturn, reconversion need
+	
+	if (pReturnTypeDescr)
+	{
+		if (cppu_isSimpleType( pReturnTypeDescr ))
+		{
+			pUnoReturn = pRegisterReturn; // direct way for simple types
+		}
+		else // complex return via ptr (pCppReturn)
+		{
+			pCppReturn = *(void **)pCppStack;
+			pCppStack += sizeof(void *);
+			
+			pUnoReturn = (cppu_relatesToInterface( pReturnTypeDescr )
+						  ? alloca( pReturnTypeDescr->nSize )
+						  : pCppReturn); // direct way
+		}
+	}
+	// pop this
+	pCppStack += sizeof( void* );
+
+	// stack space
+	OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
+	// parameters
+	void ** pUnoArgs = (void **)alloca( 4 * sizeof(void *) * nParams );
+	void ** pCppArgs = pUnoArgs + nParams;
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pUnoArgs + (2 * nParams));
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
+	
+	sal_Int32 nTempIndizes   = 0;
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+
+		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr )) // value
+		{
+			pCppArgs[nPos] = pCppStack;
+			pUnoArgs[nPos] = pCppStack;
+			switch (pParamTypeDescr->eTypeClass)
+			{
+			case typelib_TypeClass_HYPER:
+			case typelib_TypeClass_UNSIGNED_HYPER:
+			case typelib_TypeClass_DOUBLE:
+				pCppStack += sizeof(sal_Int32); // extra long
+			}
+			// no longer needed
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+			pCppArgs[nPos] = *(void **)pCppStack;
+
+			if (! rParam.bIn) // is pure out
+			{
+				// uno out is unconstructed mem!
+				pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize );
+				pTempIndizes[nTempIndizes] = nPos;
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+										*(void **)pCppStack, pParamTypeDescr,
+										&pThis->pBridge->aCpp2Uno );
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				pUnoArgs[nPos] = *(void **)pCppStack;
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+		}
+		pCppStack += sizeof(sal_Int32); // standard parameter length
+	}
+	
+	// ExceptionHolder
+	uno_Any aUnoExc; // Any will be constructed by callee
+	uno_Any * pUnoExc = &aUnoExc;
+
+	// invoke uno dispatch call
+	(*pThis->pUnoI->pDispatcher)( pThis->pUnoI, pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
+
+	// in case an exception occured...
+	if (pUnoExc)
+	{
+		// destruct temporary in/inout params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			
+			if (pParams[nIndex].bIn) // is in/inout => was constructed
+				uno_destructData( pUnoArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], 0 );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+		
+		raiseException( &aUnoExc, &pThis->pBridge->aUno2Cpp ); // has to destruct the any
+		// is here for dummy
+		return typelib_TypeClass_VOID;
+	}
+	else // else no exception occured...
+	{
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bOut) // inout/out
+			{
+				// convert and assign
+				uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+				uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], pParamTypeDescr,
+										&pThis->pBridge->aUno2Cpp );
+			}
+			// destroy temp uno param
+			uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return
+		if (pCppReturn) // has complex return
+		{
+			if (pUnoReturn != pCppReturn) // needs reconversion
+			{
+				uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
+										&pThis->pBridge->aUno2Cpp );
+				// destroy temp uno return
+				uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
+			}
+			// complex return ptr is set to eax
+			*(void **)pRegisterReturn = pCppReturn;
+		}
+		if (pReturnTypeDescr)
+		{
+			typelib_TypeClass eRet = (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+			return eRet;
+		}
+		else
+			return typelib_TypeClass_VOID;
+	}
+}
+
+
+//==================================================================================================
+static typelib_TypeClass cpp_mediate(
+	sal_Int32 nVtableCall,
+	int ** pCallStack,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+	OSL_ENSURE( sizeof(sal_Int32)==sizeof(void *), "### unexpected!" );
+	
+	// pCallStack: [ret *], this, params
+	// _this_ ptr is patched cppu_XInterfaceProxy object
+	cppu_cppInterfaceProxy * pCppI = NULL;
+	if( nVtableCall & 0x80000000 )
+	{
+		nVtableCall &= 0x7fffffff;
+		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(pCallStack + 1);
+	}
+	else
+    {
+		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(pCallStack + 0);
+    }
+
+	typelib_InterfaceTypeDescription * pTypeDescr = pCppI->pTypeDescr;
+
+	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+	if (nVtableCall >= pTypeDescr->nMapFunctionIndexToMemberIndex)
+	{
+		throw RuntimeException(
+            OUString::createFromAscii("illegal vtable index!"),
+            (XInterface *)pCppI );
+	}
+	
+	// determine called method
+	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nVtableCall];
+	OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!" );
+
+	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
+
+	typelib_TypeClass eRet;
+	switch (aMemberDescr.get()->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nVtableCall)
+		{
+			// is GET method
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
+				0, 0, // no params
+				pCallStack, pRegisterReturn );
+		}
+		else
+		{
+			// is SET method
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+			
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				0, // indicates void return
+				1, &aParam,
+				pCallStack, pRegisterReturn );
+		}
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+		// is METHOD
+		switch (nVtableCall)
+		{
+		case 1: // acquire()
+			pCppI->acquireProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 2: // release()
+			pCppI->releaseProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pCallStack[2] )->getTypeLibType() );
+			if (pTD)
+			{
+                XInterface * pInterface = 0;
+                (*pCppI->pBridge->pCppEnv->getRegisteredInterface)(
+                    pCppI->pBridge->pCppEnv,
+                    (void **)&pInterface, pCppI->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( pCallStack[0] ),
+                        &pInterface, pTD, cpp_acquire );
+                    pInterface->release();
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *(void **)pRegisterReturn = pCallStack[0];
+                    eRet = typelib_TypeClass_ANY;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+		} // else perform queryInterface()
+		default:
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
+				pCallStack, pRegisterReturn );
+		}
+		break;
+	}
+	default:
+	{
+		throw RuntimeException(
+            OUString::createFromAscii("no member description found!"),
+            (XInterface *)pCppI );
+		// is here for dummy
+		eRet = typelib_TypeClass_VOID;
+	}
+	}
+
+	return eRet;
+}
+
+//==================================================================================================
+/**
+ * is called on incoming vtable calls
+ * (called by asm snippets)
+ */
+
+extern "C" {
+int64_t cpp_vtable_call( int nTableEntry, int **pCallStack);
+
+sal_Int64 cpp_vtable_call( int nTableEntry, int **pCallStack)
+{
+	sal_Int64 nRegReturn;
+	cpp_mediate( nTableEntry, pCallStack, &nRegReturn );
+
+	return nRegReturn;
+}
+
+}
+
+
+//==================================================================================================
+class MediateClassData
+{
+    typedef ::std::hash_map< OUString, void *, OUStringHash > t_classdata_map;
+	t_classdata_map m_map;
+	Mutex m_mutex;
+    
+public:
+	void const * get_vtable( typelib_InterfaceTypeDescription * pTD ) SAL_THROW( () );
+    
+	inline MediateClassData() SAL_THROW( () )
+        {}
+	~MediateClassData() SAL_THROW( () );
+};
+//__________________________________________________________________________________________________
+MediateClassData::~MediateClassData() SAL_THROW( () )
+{
+	OSL_TRACE( "> calling ~MediateClassData(): freeing mediate vtables." );
+	
+	for ( t_classdata_map::const_iterator iPos( m_map.begin() ); iPos != m_map.end(); ++iPos )
+	{
+		::rtl_freeMemory( iPos->second );
+	}
+}
+
+extern "C" {
+
+void arm_codeSnippetSimple(void);
+void arm_codeSnippetComplex(void);
+
+}
+
+
+//--------------------------------------------------------------------------------------------------
+static inline int *codeSnippet(bool simple_ret_type ) SAL_THROW( () )
+{
+       return simple_ret_type ? (int)arm_codeSnippetSimple : (int)arm_codeSnippetComplex;
+}
+//__________________________________________________________________________________________________
+void const * MediateClassData::get_vtable( typelib_InterfaceTypeDescription * pTD ) SAL_THROW( () )
+{
+    void * buffer;
+
+    // avoiding locked counts
+    OUString const & unoName = *(OUString const *)&((typelib_TypeDescription *)pTD)->pTypeName;
+    {
+	MutexGuard aGuard( m_mutex );
+	t_classdata_map::const_iterator iFind( m_map.find( unoName ) );
+	if (iFind == m_map.end())
+    {
+        // create new vtable
+        sal_Int32 nSlots = pTD->nMapFunctionIndexToMemberIndex;
+        buffer = ::rtl_allocateMemory( ((2 + nSlots) * sizeof (void *)));
+        
+        ::std::pair< t_classdata_map::iterator, bool > insertion(
+            m_map.insert( t_classdata_map::value_type( unoName, buffer ) ) );
+        OSL_ENSURE( insertion.second, "### inserting new vtable buffer failed?!" );
+        
+        void ** slots = (void **)buffer;
+        *slots++ = 0;
+        *slots++ = 0; // rtti
+
+        sal_uInt32 vtable_pos = 0;
+        sal_Int32 nAllMembers = pTD->nAllMembers;
+        typelib_TypeDescriptionReference ** ppAllMembers = pTD->ppAllMembers;
+        for ( sal_Int32 nPos = 0; nPos < nAllMembers; ++nPos )
+        {
+            typelib_TypeDescription * pTD = 0;
+            TYPELIB_DANGER_GET( &pTD, ppAllMembers[ nPos ] );
+            OSL_ASSERT( pTD );
+            if (typelib_TypeClass_INTERFACE_ATTRIBUTE == pTD->eTypeClass)
+            {
+                bool simple_ret = cppu_isSimpleType(
+                    ((typelib_InterfaceAttributeTypeDescription *)pTD)->pAttributeTypeRef->eTypeClass );
+                // get method
+                *slots++ = codeSnippet(simple_ret);
+
+                if (! ((typelib_InterfaceAttributeTypeDescription *)pTD)->bReadOnly)
+                {
+                    // set method
+                    *slots++ = codeSnippet(true);
+                }
+            }
+            else
+            {
+                bool simple_ret = cppu_isSimpleType(
+                    ((typelib_InterfaceMethodTypeDescription *)pTD)->pReturnTypeRef->eTypeClass );
+                *slots++ = codeSnippet(simple_ret);
+            }
+            TYPELIB_DANGER_RELEASE( pTD );
+        }
+        OSL_ASSERT( vtable_pos == nSlots );
+    }
+    else
+    {
+        buffer = iFind->second;
+    }
+    }
+    
+    return ((void **)buffer + 2);
+}
+
+//==================================================================================================
+void SAL_CALL cppu_cppInterfaceProxy_patchVtable(
+	XInterface * pCppI, typelib_InterfaceTypeDescription * pTypeDescr ) throw ()
+{
+	static MediateClassData * s_pMediateClassData = 0;
+	if (! s_pMediateClassData)
+	{
+		MutexGuard aGuard( Mutex::getGlobalMutex() );
+		if (! s_pMediateClassData)
+		{
+#ifdef LEAK_STATIC_DATA
+			s_pMediateClassData = new MediateClassData();
+#else
+			static MediateClassData s_aMediateClassData;
+			s_pMediateClassData = &s_aMediateClassData;
+#endif
+		}
+	}
+	*(void const **)pCppI = s_pMediateClassData->get_vtable( pTypeDescr );
+}
+
+}
+
+extern "C"
+{
+//##################################################################################################
+sal_Bool SAL_CALL component_canUnload( TimeValue * pTime )
+	SAL_THROW_EXTERN_C()
+{
+	return CPPU_CURRENT_NAMESPACE::g_moduleCount.canUnload(
+        &CPPU_CURRENT_NAMESPACE::g_moduleCount, pTime );
+}
+//##################################################################################################
+void SAL_CALL uno_initEnvironment( uno_Environment * pCppEnv )
+	SAL_THROW_EXTERN_C()
+{
+	CPPU_CURRENT_NAMESPACE::cppu_cppenv_initEnvironment(
+        pCppEnv );
+}
+//##################################################################################################
+void SAL_CALL uno_ext_getMapping(
+	uno_Mapping ** ppMapping, uno_Environment * pFrom, uno_Environment * pTo )
+	SAL_THROW_EXTERN_C()
+{
+	CPPU_CURRENT_NAMESPACE::cppu_ext_getMapping(
+        ppMapping, pFrom, pTo );
+}
+}
diff --exclude=unxlngr.pro -urN openoffice.org-1.1.1/bridges/source/cpp_uno/gcc3_linux_arm/except.cxx openoffice.org-1.1.1-arm/bridges/source/cpp_uno/gcc3_linux_arm/except.cxx
--- bridges/source/cpp_uno/gcc3_linux_arm/except.cxx	1970-01-01 01:00:00.000000000 +0100
+++ bridges/source/cpp_uno/gcc3_linux_arm/except.cxx	2004-07-13 23:44:57.000000000 +0100
@@ -0,0 +1,359 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <stdio.h>
+#include <dlfcn.h>
+#include <cxxabi.h>
+#include <hash_map>
+
+#include <rtl/strbuf.hxx>
+#include <rtl/ustrbuf.hxx>
+#include <osl/diagnose.h>
+#include <osl/mutex.hxx>
+
+#include <bridges/cpp_uno/bridge.hxx>
+#include <typelib/typedescription.hxx>
+#include <uno/any2.h>
+
+#include "share.hxx"
+
+
+using namespace ::std;
+using namespace ::osl;
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+using namespace ::__cxxabiv1;
+
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+void dummy_can_throw_anything( char const * )
+{
+}
+
+//==================================================================================================
+static OUString toUNOname( char const * p ) SAL_THROW( () )
+{
+#if OSL_DEBUG_LEVEL > 1
+    char const * start = p;
+#endif
+
+    // example: N3com3sun4star4lang24IllegalArgumentExceptionE
+
+	OUStringBuffer buf( 64 );
+    OSL_ASSERT( 'N' == *p );
+    ++p; // skip N
+
+    while ('E' != *p)
+    {
+        // read chars count
+        long n = (*p++ - '0');
+        while ('0' <= *p && '9' >= *p)
+        {
+            n *= 10;
+            n += (*p++ - '0');
+        }
+        buf.appendAscii( p, n );
+        p += n;
+        if ('E' != *p)
+            buf.append( (sal_Unicode)'.' );
+    }
+
+#if OSL_DEBUG_LEVEL > 1
+    OUString ret( buf.makeStringAndClear() );
+    OString c_ret( OUStringToOString( ret, RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> toUNOname(): %s => %s\n", start, c_ret.getStr() );
+    return ret;
+#else
+    return buf.makeStringAndClear();
+#endif
+}
+
+//==================================================================================================
+class RTTI
+{
+    typedef hash_map< OUString, type_info *, OUStringHash > t_rtti_map;
+
+    Mutex m_mutex;
+	t_rtti_map m_rttis;
+    t_rtti_map m_generatedRttis;
+
+    void * m_hApp;
+
+public:
+    RTTI() SAL_THROW( () );
+    ~RTTI() SAL_THROW( () );
+
+    type_info * getRTTI( typelib_CompoundTypeDescription * ) SAL_THROW( () );
+};
+//__________________________________________________________________________________________________
+RTTI::RTTI() SAL_THROW( () )
+    : m_hApp( dlopen( 0, RTLD_LAZY ) )
+{
+}
+//__________________________________________________________________________________________________
+RTTI::~RTTI() SAL_THROW( () )
+{
+    dlclose( m_hApp );
+}
+
+//__________________________________________________________________________________________________
+type_info * RTTI::getRTTI( typelib_CompoundTypeDescription *pTypeDescr ) SAL_THROW( () )
+{
+    type_info * rtti;
+
+    OUString const & unoName = *(OUString const *)&pTypeDescr->aBase.pTypeName;
+
+    MutexGuard guard( m_mutex );
+    t_rtti_map::const_iterator iFind( m_rttis.find( unoName ) );
+    if (iFind == m_rttis.end())
+    {
+        // RTTI symbol
+        OStringBuffer buf( 64 );
+        buf.append( RTL_CONSTASCII_STRINGPARAM("_ZTIN") );
+        sal_Int32 index = 0;
+        do
+        {
+            OUString token( unoName.getToken( 0, '.', index ) );
+            buf.append( token.getLength() );
+            OString c_token( OUStringToOString( token, RTL_TEXTENCODING_ASCII_US ) );
+            buf.append( c_token );
+        }
+        while (index >= 0);
+        buf.append( 'E' );
+
+        OString symName( buf.makeStringAndClear() );
+        rtti = (type_info *)dlsym( m_hApp, symName.getStr() );
+
+        if (rtti)
+        {
+            pair< t_rtti_map::iterator, bool > insertion(
+                m_rttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+            OSL_ENSURE( insertion.second, "### inserting new rtti failed?!" );
+        }
+        else
+        {
+            // try to lookup the symbol in the generated rtti map
+            t_rtti_map::const_iterator iFind( m_generatedRttis.find( unoName ) );
+            if (iFind == m_generatedRttis.end())
+            {
+                // we must generate it !
+                // symbol and rtti-name is nearly identical,
+                // the symbol is prefixed with _ZTI
+                char const * rttiName = symName.getStr() +4;
+#if OSL_DEBUG_LEVEL > 1
+                fprintf( stderr,"generated rtti for %s\n", rttiName );
+#endif
+                if (pTypeDescr->pBaseTypeDescription)
+                {
+                    // ensure availability of base
+                    type_info * base_rtti = getRTTI(
+                        (typelib_CompoundTypeDescription *)pTypeDescr->pBaseTypeDescription );
+                    rtti = new __si_class_type_info(
+                        strdup( rttiName ), (__class_type_info *)base_rtti );
+                }
+                else
+                {
+                    // this class has no base class
+                    rtti = new __class_type_info( strdup( rttiName ) );
+                }
+
+                pair< t_rtti_map::iterator, bool > insertion(
+                    m_generatedRttis.insert( t_rtti_map::value_type( unoName, rtti ) ) );
+                OSL_ENSURE( insertion.second, "### inserting new generated rtti failed?!" );
+            }
+            else // taking already generated rtti
+            {
+                rtti = iFind->second;
+            }
+        }
+    }
+    else
+    {
+        rtti = iFind->second;
+    }
+
+    return rtti;
+}
+
+//--------------------------------------------------------------------------------------------------
+static void deleteException( void * pExc )
+{
+    __cxa_exception const * header = ((__cxa_exception const *)pExc - 1);
+    typelib_TypeDescription * pTD = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+    ::typelib_typedescription_getByName( &pTD, unoName.pData );
+    OSL_ENSURE( pTD, "### unknown exception type! leaving out destruction => leaking!!!" );
+    if (pTD)
+    {
+		::uno_destructData( pExc, pTD, cpp_release );
+		::typelib_typedescription_release( pTD );
+	}
+}
+
+//==================================================================================================
+void raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp )
+{
+#if OSL_DEBUG_LEVEL > 1
+    OString cstr(
+        OUStringToOString(
+            *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
+            RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> uno exception occured: %s\n", cstr.getStr() );
+#endif
+    void * pCppExc;
+    type_info * rtti;
+
+    {
+    // construct cpp exception object
+	typelib_TypeDescription * pTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pTypeDescr, pUnoExc->pType );
+    OSL_ASSERT( pTypeDescr );
+    if (! pTypeDescr)
+    {
+        throw RuntimeException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("cannot get typedescription for type ") ) +
+            *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
+            Reference< XInterface >() );
+    }
+
+	pCppExc = __cxa_allocate_exception( pTypeDescr->nSize );
+	::uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
+
+	// destruct uno exception
+	::uno_any_destruct( pUnoExc, 0 );
+    // avoiding locked counts
+    static RTTI * s_rtti = 0;
+    if (! s_rtti)
+    {
+        MutexGuard guard( Mutex::getGlobalMutex() );
+        if (! s_rtti)
+        {
+#ifdef LEAK_STATIC_DATA
+            s_rtti = new RTTI();
+#else
+            static RTTI rtti_data;
+            s_rtti = &rtti_data;
+#endif
+        }
+    }
+	rtti = (type_info *)s_rtti->getRTTI( (typelib_CompoundTypeDescription *) pTypeDescr );
+    TYPELIB_DANGER_RELEASE( pTypeDescr );
+    OSL_ENSURE( rtti, "### no rtti for throwing exception!" );
+    if (! rtti)
+    {
+        throw RuntimeException(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("no rtti for type ") ) +
+            *reinterpret_cast< OUString const * >( &pUnoExc->pType->pTypeName ),
+            Reference< XInterface >() );
+    }
+    }
+
+	__cxa_throw( pCppExc, rtti, deleteException );
+}
+
+//==================================================================================================
+void fillUnoException( __cxa_exception * header, uno_Any * pUnoExc, uno_Mapping * pCpp2Uno )
+{
+    if (! header)
+    {
+        RuntimeException aRE(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("no exception header!") ),
+            Reference< XInterface >() );
+        Type const & rType = ::getCppuType( &aRE );
+        uno_type_any_constructAndConvert( pUnoExc, &aRE, rType.getTypeLibType(), pCpp2Uno );
+#if OSL_DEBUG_LEVEL > 0
+        OString cstr( OUStringToOString( aRE.Message, RTL_TEXTENCODING_ASCII_US ) );
+        OSL_ENSURE( 0, cstr.getStr() );
+#endif
+        return;
+    }
+
+	typelib_TypeDescription * pExcTypeDescr = 0;
+    OUString unoName( toUNOname( header->exceptionType->name() ) );
+#if OSL_DEBUG_LEVEL > 1
+    OString cstr_unoName( OUStringToOString( unoName, RTL_TEXTENCODING_ASCII_US ) );
+    fprintf( stderr, "> c++ exception occured: %s\n", cstr_unoName.getStr() );
+#endif
+	typelib_typedescription_getByName( &pExcTypeDescr, unoName.pData );
+    if (0 == pExcTypeDescr)
+    {
+        RuntimeException aRE(
+            OUString( RTL_CONSTASCII_USTRINGPARAM("exception type not found: ") ) + unoName,
+            Reference< XInterface >() );
+        Type const & rType = ::getCppuType( &aRE );
+        uno_type_any_constructAndConvert( pUnoExc, &aRE, rType.getTypeLibType(), pCpp2Uno );
+#if OSL_DEBUG_LEVEL > 0
+        OString cstr( OUStringToOString( aRE.Message, RTL_TEXTENCODING_ASCII_US ) );
+        OSL_ENSURE( 0, cstr.getStr() );
+#endif
+    }
+    else
+    {
+        // construct uno exception any
+        uno_any_constructAndConvert( pUnoExc, header->adjustedPtr, pExcTypeDescr, pCpp2Uno );
+        typelib_typedescription_release( pExcTypeDescr );
+    }
+}
+
+}
+
diff --exclude=unxlngr.pro -urN openoffice.org-1.1.1/bridges/source/cpp_uno/gcc3_linux_arm/makefile.mk openoffice.org-1.1.1-arm/bridges/source/cpp_uno/gcc3_linux_arm/makefile.mk
--- bridges/source/cpp_uno/gcc3_linux_arm/makefile.mk	1970-01-01 01:00:00.000000000 +0100
+++ bridges/source/cpp_uno/gcc3_linux_arm/makefile.mk	2004-07-02 14:29:08.000000000 +0100
@@ -0,0 +1,122 @@
+#*************************************************************************
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=bridges
+TARGET=gcc3_uno
+LIBTARGET=no
+ENABLE_EXCEPTIONS=TRUE
+NO_BSYMBOLIC=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  svpre.mk
+.INCLUDE :  settings.mk
+.INCLUDE :  sv.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(COM)$(OS)$(CPU)$(COMNAME)" == "GCCLINUXRgcc3"
+
+.IF "$(cppu_no_leak)" == ""
+CFLAGS += -DLEAK_STATIC_DATA
+.ENDIF
+
+CFLAGSNOOPT=-O0
+
+SLOFILES= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj		\
+	$(SLO)$/armhelper.obj
+
+SHL1TARGET= $(TARGET)
+
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+SHL1IMPLIB=i$(TARGET)
+SHL1VERSIONMAP=..$/..$/bridge_exports.map
+
+SHL1OBJS= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj		\
+	$(SLO)$/armhelper.obj
+
+
+SHL1STDLIBS= \
+	$(CPPULIB)			\
+	$(SALLIB)
+
+
+
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
+$(SLO)$/%.obj: %.s
+	$(CC) -c -o $(SLO)$/$(@:b).o $< -fPIC ; touch $@
+
+
+
diff --exclude=unxlngr.pro -urN openoffice.org-1.1.1/bridges/source/cpp_uno/gcc3_linux_arm/share.hxx openoffice.org-1.1.1-arm/bridges/source/cpp_uno/gcc3_linux_arm/share.hxx
--- bridges/source/cpp_uno/gcc3_linux_arm/share.hxx	1970-01-01 01:00:00.000000000 +0100
+++ bridges/source/cpp_uno/gcc3_linux_arm/share.hxx	2004-06-22 11:38:55.000000000 +0100
@@ -0,0 +1,120 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <typeinfo>
+#include <exception>
+#include <cstddef>
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+// ----- following decl from libstdc++-v3/libsupc++/unwind-cxx.h and unwind.h
+
+struct _Unwind_Exception
+{
+    unsigned exception_class __attribute__((__mode__(__DI__)));
+    void * exception_cleanup;
+    unsigned private_1 __attribute__((__mode__(__word__)));
+    unsigned private_2 __attribute__((__mode__(__word__)));
+} __attribute__((__aligned__));
+
+struct __cxa_exception
+{ 
+    ::std::type_info *exceptionType;
+    void (*exceptionDestructor)(void *); 
+    
+    ::std::unexpected_handler unexpectedHandler;
+    ::std::terminate_handler terminateHandler;
+    
+    __cxa_exception *nextException;
+    
+    int handlerCount;
+    
+    int handlerSwitchValue;
+    const unsigned char *actionRecord;
+    const unsigned char *languageSpecificData;
+    void *catchTemp;
+    void *adjustedPtr;
+    
+    _Unwind_Exception unwindHeader;
+};    
+
+extern "C" void *__cxa_allocate_exception(
+    std::size_t thrown_size ) throw();
+extern "C" void __cxa_throw (
+    void *thrown_exception, std::type_info *tinfo, void (*dest) (void *) ) __attribute__((noreturn));
+
+struct __cxa_eh_globals
+{
+    __cxa_exception *caughtExceptions;
+    unsigned int uncaughtExceptions;
+};
+extern "C" __cxa_eh_globals *__cxa_get_globals () throw();
+
+// -----
+
+//==================================================================================================
+void raiseException(
+    uno_Any * pUnoExc, uno_Mapping * pUno2Cpp );
+//==================================================================================================
+void fillUnoException(
+    __cxa_exception * header, uno_Any *, uno_Mapping * pCpp2Uno );
+}
diff --exclude=unxlngr.pro -urN openoffice.org-1.1.1/bridges/source/cpp_uno/gcc3_linux_arm/uno2cpp.cxx openoffice.org-1.1.1-arm/bridges/source/cpp_uno/gcc3_linux_arm/uno2cpp.cxx
--- bridges/source/cpp_uno/gcc3_linux_arm/uno2cpp.cxx	1970-01-01 01:00:00.000000000 +0100
+++ bridges/source/cpp_uno/gcc3_linux_arm/uno2cpp.cxx	2004-07-20 15:14:34.000000000 +0100
@@ -0,0 +1,429 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s):  Modified for ARM support by Peter Naulls <peter@chocky.org>
+ *
+ *
+ ************************************************************************/
+
+#include <malloc.h>
+#include <rtl/alloc.h>
+
+#include <uno/data.h>
+#include <bridges/cpp_uno/bridge.hxx>
+#include <bridges/cpp_uno/type_misc.hxx>
+
+#include "share.hxx"
+
+
+using namespace ::rtl;
+using namespace ::com::sun::star::uno;
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+void dummy_can_throw_anything( char const * );
+
+extern "C" {
+  sal_Int64 arm_callVirtualMethod(void *, sal_Int32, sal_Int32 *, sal_Int32);
+}
+
+//==================================================================================================
+static void callVirtualMethod(
+    void * pThis,
+    sal_Int32 nVtableIndex,
+    void * pRegisterReturn,
+    typelib_TypeClass eReturnType,
+    sal_Int32 * pStackLongs,
+    sal_Int32 nStackLongs )
+{
+        int regs[2];
+	// parameter list is mixed list of * and values
+	// reference parameters are pointers
+
+	OSL_ENSURE( pStackLongs && pThis, "### null ptr!" );
+	OSL_ENSURE( (sizeof(void *) == 4) && (sizeof(sal_Int32) == 4), "### unexpected size of int!" );
+	OSL_ENSURE( nStackLongs && pStackLongs, "### no stack in callVirtualMethod !" );
+
+    // never called
+    if (! pThis) dummy_can_throw_anything("xxx"); // address something
+
+        *((sal_Int64 *)regs) = arm_callVirtualMethod(pThis, nStackLongs, pStackLongs, nVtableIndex);
+
+	switch( eReturnType )
+	{
+		case typelib_TypeClass_HYPER:
+		case typelib_TypeClass_UNSIGNED_HYPER:
+			((long*)pRegisterReturn)[1] = regs[1];
+		case typelib_TypeClass_LONG:
+		case typelib_TypeClass_UNSIGNED_LONG:
+		case typelib_TypeClass_CHAR:
+		case typelib_TypeClass_ENUM:
+			((long*)pRegisterReturn)[0] = regs[0];
+			break;
+		case typelib_TypeClass_SHORT:
+		case typelib_TypeClass_UNSIGNED_SHORT:
+			*(unsigned short*)pRegisterReturn = regs[0];
+			break;
+		case typelib_TypeClass_BOOLEAN:
+		case typelib_TypeClass_BYTE:
+			*(unsigned char*)pRegisterReturn = regs[0];
+			break;
+		case typelib_TypeClass_DOUBLE:
+			((long*)pRegisterReturn)[1] = regs[0];
+		case typelib_TypeClass_FLOAT:
+			((long*)pRegisterReturn)[0] = regs[0];
+			break;
+	}
+}
+
+//================================================================================================== 
+static void cpp_call(
+	cppu_unoInterfaceProxy * pThis,
+	sal_Int32 nVtableCall,
+	typelib_TypeDescriptionReference * pReturnTypeRef,
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+	void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
+{
+  	// max space for: [complex ret ptr], values|ptr ...
+  	char * pCppStack		=
+  		(char *)alloca( sizeof(sal_Int32) + ((nParams+2) * sizeof(sal_Int64)) );
+  	char * pCppStackStart	= pCppStack;
+	
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	OSL_ENSURE( pReturnTypeDescr, "### expected return type description!" );
+	
+	void * pCppReturn = 0; // if != 0 && != pUnoReturn, needs reconversion
+	
+	if (pReturnTypeDescr)
+	{
+
+		if (cppu_isSimpleType( pReturnTypeDescr ))
+		{
+			pCppReturn = pUnoReturn; // direct way for simple types
+		}
+		else
+		{
+			// complex return via ptr
+			pCppReturn = *(void **)pCppStack = (cppu_relatesToInterface( pReturnTypeDescr )
+												? alloca( pReturnTypeDescr->nSize )
+												: pUnoReturn); // direct way
+			pCppStack += sizeof(void *);
+		}
+	}
+	// push this
+	*(void**)pCppStack = pThis->pCppI;
+	pCppStack += sizeof( void* );
+
+	// stack space
+	OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
+	// args
+	void ** pCppArgs  = (void **)alloca( 3 * sizeof(void *) * nParams );
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pCppArgs + nParams);
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pCppArgs + (2 * nParams));
+
+	sal_Int32 nTempIndizes   = 0;
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+
+		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr ))
+		{
+			uno_copyAndConvertData( pCppArgs[nPos] = pCppStack, pUnoArgs[nPos], pParamTypeDescr,
+									&pThis->pBridge->aUno2Cpp );
+			
+			switch (pParamTypeDescr->eTypeClass)
+			{
+			case typelib_TypeClass_HYPER:
+			case typelib_TypeClass_UNSIGNED_HYPER:
+			case typelib_TypeClass_DOUBLE:
+				pCppStack += sizeof(sal_Int32); // extra long
+			}
+			// no longer needed
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+			if (! rParam.bIn) // is pure out
+			{
+				// cpp out is constructed mem, uno out is not!
+				uno_constructData(
+					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+					pParamTypeDescr );
+				pTempIndizes[nTempIndizes] = nPos; // default constructed for cpp call
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData(
+					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+					pUnoArgs[nPos], pParamTypeDescr, &pThis->pBridge->aUno2Cpp );
+				
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				*(void **)pCppStack = pCppArgs[nPos] = pUnoArgs[nPos];
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+		}
+		pCppStack += sizeof(sal_Int32); // standard parameter length
+	}
+
+	try
+	{
+
+		OSL_ENSURE( !( (pCppStack - pCppStackStart ) & 3), "UNALIGNED STACK !!! (Please DO panic)" );
+
+		callVirtualMethod(
+			pThis->pCppI, nVtableCall,
+			pCppReturn, pReturnTypeDescr->eTypeClass,
+			(sal_Int32 *)pCppStackStart, (pCppStack - pCppStackStart) / sizeof(sal_Int32) );
+		// NO exception occured...
+		*ppUnoExc = 0;
+
+		// reconvert temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bIn)
+			{
+				if (pParams[nIndex].bOut) // inout
+				{
+					uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
+					uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+											&pThis->pBridge->aCpp2Uno );
+				}
+			}
+			else // pure out
+			{
+				uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+										&pThis->pBridge->aCpp2Uno );
+			}
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return value
+		if (pCppReturn && pUnoReturn != pCppReturn)
+		{
+			uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
+									&pThis->pBridge->aCpp2Uno );
+			uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
+		}
+	}
+ 	catch (...)
+ 	{
+           __asm__("sub sp, sp, #2048\n");
+
+		// fill uno exception
+		fillUnoException( __cxa_get_globals()->caughtExceptions, *ppUnoExc, &pThis->pBridge->aCpp2Uno );
+
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], cpp_release );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		// return type
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+	}
+}
+
+
+//==================================================================================================
+void SAL_CALL cppu_unoInterfaceProxy_dispatch(
+	uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
+	void * pReturn, void * pArgs[], uno_Any ** ppException ) throw ()
+{
+	// is my surrogate
+	cppu_unoInterfaceProxy * pThis = (cppu_unoInterfaceProxy *)pUnoI;
+	typelib_InterfaceTypeDescription * pTypeDescr = pThis->pTypeDescr;
+	
+	switch (pMemberDescr->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+		// determine vtable call index
+		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
+		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
+		
+		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
+		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		
+		if (pReturn)
+		{
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall,
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
+				0, 0, // no params
+				pReturn, pArgs, ppException );
+		}
+		else
+		{
+			// is SET
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+
+			typelib_TypeDescriptionReference * pReturnTypeRef = 0;
+			OUString aVoidName( RTL_CONSTASCII_USTRINGPARAM("void") );
+			typelib_typedescriptionreference_new(
+				&pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
+			
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall +1, // get, then set method
+				pReturnTypeRef,
+				1, &aParam,
+				pReturn, pArgs, ppException );
+			
+			typelib_typedescriptionreference_release( pReturnTypeRef );
+		}
+		
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+		// determine vtable call index
+		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
+		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
+		
+		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
+		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		
+		switch (nVtableCall)
+		{
+			// standard calls
+		case 1: // acquire uno interface
+			(*pUnoI->acquire)( pUnoI );
+			*ppException = 0;
+			break;
+		case 2: // release uno interface
+			(*pUnoI->release)( pUnoI );
+			*ppException = 0;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pArgs[0] )->getTypeLibType() );
+			if (pTD)
+			{
+                uno_Interface * pInterface = 0;
+                (*pThis->pBridge->pUnoEnv->getRegisteredInterface)(
+                    pThis->pBridge->pUnoEnv,
+                    (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( pReturn ),
+                        &pInterface, pTD, 0 );
+                    (*pInterface->release)( pInterface );
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *ppException = 0;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+		} // else perform queryInterface()
+		default:
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
+				pReturn, pArgs, ppException );
+		}
+		break;
+	}
+	default:
+	{
+		::com::sun::star::uno::RuntimeException aExc(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("illegal member type description!") ),
+			::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >() );
+		
+		Type const & rExcType = ::getCppuType( &aExc );
+		// binary identical null reference
+		::uno_type_any_construct( *ppException, &aExc, rExcType.getTypeLibType(), 0 );
+	}
+	}
+}
+
+}
+
diff --exclude=unxlngr.pro -urN openoffice.org-1.1.1/config_office/set_soenv.in openoffice.org-1.1.1-arm/config_office/set_soenv.in
--- config_office/set_soenv.in	2004-07-20 12:11:46.000000000 +0100
+++ config_office/set_soenv.in	2004-07-20 15:18:48.000000000 +0100
@@ -424,7 +424,7 @@
       $JRETOOLKITDIR  = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."alpha".$ds."client";
       $JRETHREADDIR   = '$JAVA_HOME'.$ds."jre".$ds."lib".$ds."alpha".$ds."native_threads";
    }
-   elsif ($machine_type eq "armv4l") 
+   elsif (($machine_type eq "armv4l") or ($machine_type eq "armv5l")) 
    {  print "Setting Linux ARM specific values... ";
       $outfile        = "LinuxARMEnv.Set"; 
       $CPU            = "R";
diff --exclude=unxlngr.pro -urN openoffice.org-1.1.1/cppu/source/uno/data.cxx openoffice.org-1.1.1-arm/cppu/source/uno/data.cxx
--- cppu/source/uno/data.cxx	2003-04-15 17:37:21.000000000 +0100
+++ cppu/source/uno/data.cxx	2004-07-13 23:39:01.000000000 +0100
@@ -394,7 +394,7 @@
 #	pragma pack(8)
 #endif
 
-#if defined(__GNUC__) && (defined(LINUX) || defined(FREEBSD)) && defined(INTEL)
+#if defined(__GNUC__) && (defined(LINUX) || defined(FREEBSD)) && (defined(INTEL) || defined(ARM))
 #define MAX_ALIGNMENT_4
 #endif
 
@@ -406,7 +406,7 @@
     if (OFFSET_OF(s, m) != n) { fprintf( stderr, "### OFFSET_OF(" #s ", "  #m ") = %d instead of expected %d!!!\n", OFFSET_OF(s, m), n ); abort(); }
 
 #if OSL_DEBUG_LEVEL > 1
-#if defined(__GNUC__) && (defined(LINUX) || defined(FREEBSD)) && (defined(INTEL) || defined(POWERPC) || defined(X86_64) || defined(S390))
+#if defined(__GNUC__) && (defined(LINUX) || defined(FREEBSD)) && (defined(INTEL) || defined(POWERPC) || defined(X86_64) || defined(S390) || defined(ARM))
 #define BINTEST_VERIFYSIZE( s, n ) \
     fprintf( stderr, "> sizeof(" #s ") = %d; __alignof__ (" #s ") = %d\n", sizeof(s), __alignof__ (s) ); \
     if (sizeof(s) != n) { fprintf( stderr, "### sizeof(" #s ") = %d instead of expected %d!!!\n", sizeof(s), n ); abort(); }
@@ -423,7 +423,7 @@
 struct C1
 {
     sal_Int16 n1;
-};
+} __attribute__ ((__packed__));
 struct C2 : public C1
 {
     sal_Int32 n2 CPPU_GCC3_ALIGN( C1 );
@@ -510,15 +510,15 @@
 struct Char1
 {
     char c1;
-};
+} __attribute__ ((__packed__));
 struct Char2 : public Char1
 {
     char c2 CPPU_GCC3_ALIGN( Char1 );
-};
+} __attribute__ ((__packed__));
 struct Char3 : public Char2
 {
     char c3 CPPU_GCC3_ALIGN( Char2 );
-};
+} __attribute__ ((__packed__));
 struct Char4
 {
     Char3 chars;
diff --exclude=unxlngr.pro -urN openoffice.org-1.1.1/desktop/source/pkgchk/pkgchk_misc.h openoffice.org-1.1.1-arm/desktop/source/pkgchk/pkgchk_misc.h
--- desktop/source/pkgchk/pkgchk_misc.h	2003-06-12 11:46:35.000000000 +0100
+++ desktop/source/pkgchk/pkgchk_misc.h	2004-06-21 15:06:42.000000000 +0100
@@ -242,6 +242,8 @@
 #define THIS_PLATFORM_PATH "/linux_s390.plt"
 #elif defined (LINUX) && defined (SPARC)
 #define THIS_PLATFORM_PATH "/linux_sparc.plt"
+#elif defined (LINUX) && defined (ARM)
+#define THIS_PLATFORM_PATH "/linux_arm.plt"
 #elif defined (MACOSX) && defined (POWERPC)
 #define THIS_PLATFORM_PATH "/macosx_powerpc.plt"
 #elif defined (NETBSD) && defined (SPARC)

Index: unxlngr.mk
===================================================================
RCS file: /cvs/tools/solenv/inc/unxlngr.mk,v
retrieving revision 1.5
diff -u -u -r1.5 unxlngr.mk
--- solenv/inc/unxlngr.mk	28 Apr 2003 16:47:30 -0000	1.5
+++ solenv/inc/unxlngr.mk	20 Jul 2004 21:32:01 -0000
@@ -54,28 +54,28 @@
 #
 #   All Rights Reserved.
 #
-#   Contributor(s): _______________________________________
-# 					Tak-Shing Chan <chan@aleph1.co.uk>
+#   Contributor(s): Peter Naulls <peter@chocky.org>
 #
 #
 #*************************************************************************
 
-# unxlngr.mk for armv4l
+# unxlngr.mk for ARM
 
 # mk file for unxlngr
 ASM=
 AFLAGS=
 
-SOLAR_JAVA=
+SOLAR_JAVA*=TRUE
 JAVAFLAGSDEBUG=-g
 
 # filter for supressing verbose messages from linker
-LINKOUTPUT_FILTER=" |& $(SOLARENV)$/bin$/msg_filter"
+#not needed at the moment
+#LINKOUTPUT_FILTER=" |& $(SOLARENV)$/bin$/msg_filter"
 
 # _PTHREADS is needed for the stl
 CDEFS+=-DGLIBC=2 -DARM32 -D_PTHREADS -D_REENTRANT -DNEW_SOLAR -D_USE_NAMESPACE=1 -DSTLPORT_VERSION=400
 
-# this is a platform with JAVA support
+# this is a platform with Java support
 .IF "$(SOLAR_JAVA)"!=""
 JAVADEF=-DSOLAR_JAVA
 .IF "$(debug)"==""
@@ -83,64 +83,91 @@
 .ELSE
 JAVA_RUNTIME=-ljava_g
 .ENDIF
-.ENDIF 
+.ENDIF
 
 # name of C++ Compiler
 CXX*=g++
 # name of C Compiler
 CC*=gcc
+.IF "$(SYSBASE)"!=""
+CFLAGS_SYSBASE:=-isystem $(SYSBASE)$/usr$/include
+CXX+:=$(CFLAGS_SYSBASE)
+CC+:=$(CFLAGS_SYSBASE)
+.ENDIF          # "$(SYSBASE)"!=""
 # flags for C and C++ Compiler
 # do not use standard header search paths
-# here the Compiler is installed in the solenv hierarchy, to be changed
 # if installed elsewhere
-CFLAGS=-nostdinc -c $(INCLUDE) -I$(SOLARENV)/unxlngr/lib/gcc-lib/arm-linux/2.95.2/include -I$(SOLARENV)/unxlngr/usr/include
-# flags for the C++ Compiler
-CFLAGSCC=
+.IF "$(BUILD_SOSL)"!=""
+CFLAGS=
+.ENDIF
+CFLAGS+=-fmessage-length=0 -c $(INCLUDE)
+
+# flags to enable build with symbols; required for crashdump feature
+.IF "$(ENABLE_SYMBOLS)"=="SMALL"
+CFLAGSENABLESYMBOLS=-g1
+.ELSE
+CFLAGSENABLESYMBOLS=-g
+.ENDIF
 
+# flags for the C++ Compiler
+CFLAGSCC= -pipe 
 # Flags for enabling exception handling
-CFLAGSEXCEPTIONS=-fexceptions
+CFLAGSEXCEPTIONS=-fexceptions -fno-enforce-eh-specs
 # Flags for disabling exception handling
 CFLAGS_NO_EXCEPTIONS=-fno-exceptions
 
 # -fpermissive should be removed as soon as possible
-CFLAGSCXX= -fno-for-scope -fpermissive
+CFLAGSCXX= -pipe -fno-for-scope -fpermissive -fno-rtti
+
+# Static objects are compiled with -fPIC too, because some static libraries end up in
+# shared libraries
 
 # Compiler flags for compiling static object in single threaded environment with graphical user interface
-CFLAGSOBJGUIST=
+CFLAGSOBJGUIST=-fPIC
 # Compiler flags for compiling static object in single threaded environment with character user interface
-CFLAGSOBJCUIST=
+CFLAGSOBJCUIST=-fPIC
 # Compiler flags for compiling static object in multi threaded environment with graphical user interface
-CFLAGSOBJGUIMT=
+CFLAGSOBJGUIMT=-fPIC
 # Compiler flags for compiling static object in multi threaded environment with character user interface
-CFLAGSOBJCUIMT=
+CFLAGSOBJCUIMT=-fPIC
 # Compiler flags for compiling shared object in multi threaded environment with graphical user interface
-CFLAGSSLOGUIMT=-fpic
+CFLAGSSLOGUIMT=-fPIC
 # Compiler flags for compiling shared object in multi threaded environment with character user interface
-CFLAGSSLOCUIMT=-fpic
+CFLAGSSLOCUIMT=-fPIC
 # Compiler flags for profiling
 CFLAGSPROF=
 # Compiler flags for debugging
 CFLAGSDEBUG=-g
 CFLAGSDBGUTIL=
 # Compiler flags for enabling optimazations
-CFLAGSOPT=-O2
+# CFLAGSOPT=-O2
+# reduce to -O1 to avoid optimisation problems
+CFLAGSOPT=-O1
 # Compiler flags for disabling optimazations
 CFLAGSNOOPT=-O
-# Compiler flags for discibing the output path
+# Compiler flags for describing the output path
 CFLAGSOUTOBJ=-o
+# Enable all warnings
+CFLAGSWALL=-Wall
+# Set default warn level
+CFLAGSDFLTWARN=-w
 
 # switches for dynamic and static linking
 STATIC		= -Wl,-Bstatic
 DYNAMIC		= -Wl,-Bdynamic
 
 # name of linker
-LINK=gcc
+LINK*=$(CC)
+
 # default linker flags
-LINKFLAGS=
+LINKFLAGSDEFS*=-Wl,-z,defs
+LINKFLAGSRUNPATH*=-Wl,-rpath,\''$$ORIGIN'\'
+LINKFLAGS= -O2 -Bsymbolic -Wl,-z,combreloc $(LINKFLAGSDEFS) $(LINKFLAGSRUNPATH)
 
 # linker flags for linking applications
-LINKFLAGSAPPGUI= -Wl,-export-dynamic 
-LINKFLAGSAPPCUI= -Wl,-export-dynamic
+LINKFLAGSAPPGUI= -Wl,-export-dynamic -Wl,--noinhibit-exec
+LINKFLAGSAPPCUI= -Wl,-export-dynamic -Wl,--noinhibit-exec
+
 # linker flags for linking shared libraries
 LINKFLAGSSHLGUI= -shared
 LINKFLAGSSHLCUI= -shared
@@ -150,14 +177,10 @@
 LINKFLAGSDEBUG=-g
 LINKFLAGSOPT=
 
-.IF "$(NO_BSYMBOLIC)"==""
-.IF "$(PRJNAME)" != "envtest"
-LINKFLAGSSHLGUI+=-Wl,-Bsymbolic
-LINKFLAGSSHLCUI+=-Wl,-Bsymbolic
-.ENDIF
-.ENDIF				# "$(NO_BSYMBOLIC)"==""
-
-LINKVERSIONMAPFLAG=-Wl,--version-script
+# linker flags for optimization (symbol hashtable)
+# for now, applied to symbol scoped libraries, only
+LINKFLAGSOPTIMIZE*=-Wl,-O1
+LINKVERSIONMAPFLAG=$(LINKFLAGSOPTIMIZE) -Wl,--version-script
 
 SONAME_SWITCH=-Wl,-h
 
@@ -172,13 +195,22 @@
 STDSLOCUI=
 
 # libraries for linking applications
-STDLIBCUIST=-ldl -lm -lstlport_gcc
-STDLIBGUIMT=-ldl -lpthread -lm -lstlport_gcc
-STDLIBCUIMT=-ldl -lpthread -lm -lstlport_gcc
+STDLIBCUIST=-ldl -lm
+STDLIBGUIMT=-lX11 -ldl -lpthread -lm
+STDLIBCUIMT=-ldl -lpthread -lm
 STDLIBGUIST=-lX11 -ldl -lm
 # libraries for linking shared libraries
-STDSHLGUIMT=-lX11 -lXext -ldl -lpthread -lm -lstlport_gcc
-STDSHLCUIMT=-ldl -lpthread -lm -lstlport_gcc
+STDSHLGUIMT=-lX11 -lXext -ldl -lpthread -lm
+STDSHLCUIMT=-ldl -lpthread -lm
+STDSHLGUIST=-lX11 -lXext -ldl -lm
+STDSHLCUIST=-ldl -lm
+
+LIBSALCPPRT*=-Wl,--whole-archive -lsalcpprt -Wl,--no-whole-archive
+
+LIBSTLPORT=$(DYNAMIC) -lstlport_gcc -lstdc++
+LIBSTLPORTST=$(STATIC) -lstlport_gcc $(DYNAMIC)
+
+#FILLUPARC=$(STATIC) -lsupc++ $(DYNAMIC)
 
 # name of library manager
 LIBMGR=ar
@@ -202,3 +234,4 @@
 DLLPRE=lib
 DLLPOST=.so
 
+
Index: boost_1_27_0.patch
===================================================================
RCS file: /cvs/external/boost/boost_1_27_0.patch,v
retrieving revision 1.4.10.5
diff -u -r1.4.10.5 boost_1_27_0.patch
--- boost/boost_1_27_0.patch	4 Oct 2004 18:04:11 -0000	1.4.10.5
+++ boost/boost_1_27_0.patch	10 Nov 2004 15:25:56 -0000
@@ -56,7 +56,7 @@
   
   #include <boost/detail/atomic_count_win32.hpp>
   
-! #elif (defined(linux) || defined(__linux) || defined(__linux__)) && !(defined(SPARC) || defined(sparc) || defined(sparc64))
+! #elif (defined(linux) || defined(__linux) || defined(__linux__)) && !(defined(SPARC) || defined(sparc) || defined(sparc64)) && !(defined(ARM) || defined(ARM32))
   
   #include <boost/detail/atomic_count_linux.hpp>
   
