diff --new-file -r -u /tmp/nothing/exports.dxp ucb/source/ucp/odma/exports.dxp
--- /tmp/nothing/exports.dxp	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/exports.dxp	2003-08-25 13:59:40.000000000 +0100
@@ -0,0 +1,3 @@
+component_getImplementationEnvironment
+component_writeInfo
+component_getFactory
diff --new-file -r -u /tmp/nothing/exports.map ucb/source/ucp/odma/exports.map
--- /tmp/nothing/exports.map	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/exports.map	2003-08-25 13:59:48.000000000 +0100
@@ -0,0 +1,8 @@
+VERS_1_0 {
+	global:
+		component_getImplementationEnvironment;
+		component_writeInfo;
+		component_getFactory;
+	local:
+		*;
+};
diff --new-file -r -u /tmp/nothing/makefile.mk ucb/source/ucp/odma/makefile.mk
--- /tmp/nothing/makefile.mk	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/makefile.mk	2003-08-25 13:59:56.000000000 +0100
@@ -0,0 +1,155 @@
+#*************************************************************************
+#
+#   $RCSfile$
+#
+#   $Revision$
+#
+#   last change: $Author$ $Date$
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+# @@@ UCP Version - Increase, if your UCP libraray becomes incompatible.
+UCP_VERSION=1
+
+# @@@ Name for your UCP. Will become part of the library name (See below).
+UCP_NAME=odma
+
+# @@@ Relative path to project root.
+PRJ=..$/..$/..
+
+# @@@ Name of the project your UCP code recides it.
+PRJNAME=ucb
+
+TARGET=ucp$(UCP_NAME)
+TARGET2=s$(UCP_NAME)
+
+ENABLE_EXCEPTIONS=TRUE
+USE_DEFFILE=TRUE
+NO_BSYMBOLIC=TRUE
+
+TARGET2TYPE=CUI
+LIB2TARGET=NO
+
+# --- Settings ---------------------------------------------------------
+
+.INCLUDE: svpre.mk
+.INCLUDE: settings.mk
+.INCLUDE: sv.mk
+
+# --- General -----------------------------------------------------
+
+# @@@ Adjust template file names. Add own files here.
+SLOFILES=\
+	$(SLO)$/odma_lib.obj    		\
+	$(SLO)$/odma_services.obj    	\
+	$(SLO)$/odma_provider.obj    	\
+	$(SLO)$/odma_content.obj     	\
+	$(SLO)$/odma_resultset.obj		\
+	$(SLO)$/odma_datasupplier.obj	\
+	$(SLO)$/odma_inputstream.obj	\
+	$(SLO)$/odma_contentcaps.obj
+
+
+LIB1TARGET=$(SLB)$/_$(TARGET).lib
+LIB1OBJFILES=$(SLOFILES)
+
+# --- Shared-Library ---------------------------------------------------
+
+SHL1TARGET=$(TARGET)$(UCP_VERSION)
+SHL1IMPLIB=i$(TARGET)
+SHL1VERSIONMAP=exports.map
+
+# @@@ Add additional libs here.
+SHL1STDLIBS=\
+	$(CPPUHELPERLIB) \
+	$(CPPULIB) \
+	$(SALLIB)  \
+	$(VOSLIB)  \
+	$(UCBHELPERLIB)
+
+SHL1DEF=$(MISC)$/$(SHL1TARGET).def
+SHL1LIBS=$(LIB1TARGET)
+
+# --- Def-File ---------------------------------------------------------
+
+DEF1NAME=$(SHL1TARGET)
+DEF1EXPORTFILE=exports.dxp
+
+# @@@ A description string for you UCP.
+DEF1DES=UCB ODMA Content Provider
+
+# --- SODMA executable -------------------------------------------------
+OBJ2FILES= $(OBJ)$/odma_main.obj 
+
+APP2TARGET= $(TARGET2)
+APP2OBJS=   $(OBJ2FILES)
+APP2STDLIBS=$(SALLIB)			\
+            $(VOSLIB)			\
+			$(CPPULIB)			\
+			$(CPPUHELPERLIB)
+
+APP2STDLIBS+=$(STDLIBCPP)
+
+.IF "$(GUI)"=="WNT"
+APP2STDLIBS+=$(LIBCIMT)
+.ENDIF
+
+# @@@ A description string for you UCP.
+DEF2DES=UCB ODMA URL converter
+
+# --- Targets ----------------------------------------------------------
+
+.INCLUDE: target.mk
+
diff --new-file -r -u /tmp/nothing/odma_contentcaps.cxx ucb/source/ucp/odma/odma_contentcaps.cxx
--- /tmp/nothing/odma_contentcaps.cxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_contentcaps.cxx	2003-08-25 14:00:29.000000000 +0100
@@ -0,0 +1,300 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+/**************************************************************************
+								TODO
+ **************************************************************************
+
+ *************************************************************************/
+
+#ifndef _COM_SUN_STAR_BEANS_PROPERTY_HPP_
+#include <com/sun/star/beans/Property.hpp>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYATTRIBUTE_HPP_
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_
+#include <com/sun/star/beans/PropertyValue.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_COMMANDINFO_HPP_
+#include <com/sun/star/ucb/CommandInfo.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_INSERTCOMMANDARGUMENT_HPP_
+#include <com/sun/star/ucb/InsertCommandArgument.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_OPENCOMMANDARGUMENT2_HPP_
+#include <com/sun/star/ucb/OpenCommandArgument2.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UNO_SEQUENCE_HXX_
+#include <com/sun/star/uno/Sequence.hxx>
+#endif
+#ifndef _COM_SUN_STAR_UTIL_DATETIME_HPP_
+#include <com/sun/star/util/DateTime.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_TRANSFERINFO_HPP_
+#include <com/sun/star/ucb/TransferInfo.hpp>
+#endif
+#ifndef ODMA_CONTENT_HXX
+#include "odma_content.hxx"
+#endif
+
+using namespace com::sun;
+using namespace com::sun::star;
+using namespace odma;
+
+//=========================================================================
+//
+// Content implementation.
+//
+//=========================================================================
+
+//=========================================================================
+//
+// IMPORTENT: If any property data ( name / type / ... ) are changed, then
+//            Content::getPropertyValues(...) must be adapted too!
+//
+//=========================================================================
+
+// virtual
+uno::Sequence< beans::Property > Content::getProperties(
+             const uno::Reference< star::ucb::XCommandEnvironment > & xEnv )
+{
+	// @@@ Add additional properties...
+
+	// @@@ Note: If your data source supports adding/removing properties,
+	//           you should implement the interface XPropertyContainer
+	//           by yourself and supply your own logic here. The base class
+	//           uses the service "com.sun.star.ucb.Store" to maintain
+	//           Additional Core properties. But using server functionality
+	//           is preferred! In fact you should return a table conatining
+	//           even that dynamicly added properties.
+
+//	osl::Guard< osl::Mutex > aGuard( m_aMutex );
+
+	//=================================================================
+	//
+	// Supported properties
+	//
+	//=================================================================
+
+	#define PROPERTY_COUNT 10
+
+    static beans::Property aPropertyInfoTable[] =
+	{
+		///////////////////////////////////////////////////////////////
+		// Required properties
+		///////////////////////////////////////////////////////////////
+        beans::Property(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "ContentType" ) ),
+			-1,
+            getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
+            beans::PropertyAttribute::BOUND | beans::PropertyAttribute::READONLY
+		),
+        beans::Property(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "IsDocument" ) ),
+			-1,
+			getCppuBooleanType(),
+            beans::PropertyAttribute::BOUND | beans::PropertyAttribute::READONLY
+		),
+        beans::Property(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "IsFolder" ) ),
+			-1,
+			getCppuBooleanType(),
+            beans::PropertyAttribute::BOUND | beans::PropertyAttribute::READONLY
+		),
+        beans::Property(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Title" ) ),
+			-1,
+            getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
+            beans::PropertyAttribute::BOUND
+		),
+		///////////////////////////////////////////////////////////////
+		// Optional standard properties
+		///////////////////////////////////////////////////////////////
+		beans::Property(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DateCreated" ) ),
+			-1,
+			getCppuType(static_cast< const com::sun::star::util::DateTime * >( 0 ) ),
+            beans::PropertyAttribute::BOUND | beans::PropertyAttribute::READONLY
+		),
+		beans::Property(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "DateModified" ) ),
+			-1,
+			getCppuType(static_cast< const com::sun::star::util::DateTime * >( 0 ) ),
+            beans::PropertyAttribute::BOUND | beans::PropertyAttribute::READONLY
+		),
+		beans::Property(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "IsReadOnly" ) ),
+			-1,
+			getCppuBooleanType(),
+            beans::PropertyAttribute::BOUND | beans::PropertyAttribute::READONLY
+		),
+		///////////////////////////////////////////////////////////////
+		// New properties
+		///////////////////////////////////////////////////////////////
+		beans::Property(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Author" ) ),
+			-1,
+            getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
+            beans::PropertyAttribute::BOUND
+		),
+		beans::Property(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Subject" ) ),
+			-1,
+            getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
+            beans::PropertyAttribute::BOUND
+		),
+		beans::Property(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "Keywords" ) ),
+			-1,
+            getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
+            beans::PropertyAttribute::BOUND
+		)
+	};
+    return uno::Sequence<
+            beans::Property >( aPropertyInfoTable, PROPERTY_COUNT );
+}
+
+//=========================================================================
+// virtual
+uno::Sequence< star::ucb::CommandInfo > Content::getCommands(
+            const uno::Reference< star::ucb::XCommandEnvironment > & xEnv )
+{
+	// @@@ Add additional commands...
+
+//	osl::Guard< osl::Mutex > aGuard( m_aMutex );
+
+	//=================================================================
+	//
+	// Supported commands
+	//
+	//=================================================================
+
+	#define COMMAND_COUNT 8
+
+    static star::ucb::CommandInfo aCommandInfoTable[] =
+	{
+		///////////////////////////////////////////////////////////////
+		// Required commands
+		///////////////////////////////////////////////////////////////
+        star::ucb::CommandInfo(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "getCommandInfo" ) ),
+			-1,
+			getCppuVoidType()
+		),
+        star::ucb::CommandInfo(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "getPropertySetInfo" ) ),
+			-1,
+			getCppuVoidType()
+		),
+        star::ucb::CommandInfo(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "getPropertyValues" ) ),
+			-1,
+            getCppuType(
+                static_cast< uno::Sequence< beans::Property > * >( 0 ) )
+		),
+        star::ucb::CommandInfo(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "setPropertyValues" ) ),
+			-1,
+            getCppuType(
+                static_cast< uno::Sequence< beans::PropertyValue > * >( 0 ) )
+		),
+		///////////////////////////////////////////////////////////////
+		// Optional standard commands
+		///////////////////////////////////////////////////////////////
+/*
+        star::ucb::CommandInfo(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "delete" ) ),
+			-1,
+			getCppuBooleanType()
+		),
+*/
+        star::ucb::CommandInfo(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "insert" ) ),
+			-1,
+            getCppuType(
+                static_cast< star::ucb::InsertCommandArgument * >( 0 ) )
+		),
+        star::ucb::CommandInfo(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "open" ) ),
+			-1,
+            getCppuType( static_cast< star::ucb::OpenCommandArgument2 * >( 0 ) )
+		),
+		star::ucb::CommandInfo(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "close" ) ),
+			-1,
+            getCppuVoidType( )
+		),
+		star::ucb::CommandInfo(
+            rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "transfer" ) ),
+			-1,
+            getCppuType( static_cast< star::ucb::TransferInfo * >( 0 ) )
+		)
+
+		///////////////////////////////////////////////////////////////
+		// New commands
+		///////////////////////////////////////////////////////////////
+	};
+
+    return uno::Sequence<
+            star::ucb::CommandInfo >( aCommandInfoTable, COMMAND_COUNT );
+}
+
diff --new-file -r -u /tmp/nothing/odma_content.cxx ucb/source/ucp/odma/odma_content.cxx
--- /tmp/nothing/odma_content.cxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_content.cxx	2003-08-25 14:00:13.000000000 +0100
@@ -0,0 +1,1313 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+/**************************************************************************
+								TODO
+ **************************************************************************
+
+ *************************************************************************/
+
+#ifndef _OSL_DIAGNOSE_H_
+#include <osl/diagnose.h>
+#endif
+#ifndef ODMA_CONTENTPROPS_HXX
+#include "odma_contentprops.hxx"
+#endif
+#ifndef _COM_SUN_STAR_UCB_XDYNAMICRESULTSET_HPP_
+#include <com/sun/star/ucb/XDynamicResultSet.hpp>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_PROPERTYATTRIBUTE_HPP_
+#include <com/sun/star/beans/PropertyAttribute.hpp>
+#endif
+#ifndef _COM_SUN_STAR_BEANS_XPROPERTYACCESS_HPP_
+#include <com/sun/star/beans/XPropertyAccess.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_ILLEGALACCESSEXCEPTION_HPP_
+#include <com/sun/star/lang/IllegalAccessException.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_UNSUPPORTEDDATASINKEXCEPTION_HPP_
+#include <com/sun/star/ucb/UnsupportedDataSinkException.hpp>
+#endif
+#ifndef _COM_SUN_STAR_SDBC_XROW_HPP_
+#include <com/sun/star/sdbc/XRow.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XOUTPUTSTREAM_HPP_
+#include <com/sun/star/io/XOutputStream.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XACTIVEDATASINK_HPP_
+#include <com/sun/star/io/XActiveDataSink.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_OPENCOMMANDARGUMENT2_HPP_
+#include <com/sun/star/ucb/OpenCommandArgument2.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_OPENMODE_HPP_
+#include <com/sun/star/ucb/OpenMode.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_XCOMMANDINFO_HPP_
+#include <com/sun/star/ucb/XCommandInfo.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_XPERSISTENTPROPERTYSET_HPP_
+#include <com/sun/star/ucb/XPersistentPropertySet.hpp>
+#endif
+#ifndef _UCBHELPER_CONTENTIDENTIFIER_HXX
+#include <ucbhelper/contentidentifier.hxx>
+#endif
+#ifndef _UCBHELPER_PROPERTYVALUESET_HXX
+#include <ucbhelper/propertyvalueset.hxx>
+#endif
+#ifndef _UCBHELPER_CANCELCOMMANDEXECUTION_HXX_
+#include <ucbhelper/cancelcommandexecution.hxx>
+#endif
+#ifndef _COM_SUN_STAR_UCB_UNSUPPORTEDOPENMODEEXCEPTION_HPP_
+#include <com/sun/star/ucb/UnsupportedOpenModeException.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_MISSINGINPUTSTREAMEXCEPTION_HPP_
+#include <com/sun/star/ucb/MissingInputStreamException.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_INSERTCOMMANDARGUMENT_HPP_
+#include <com/sun/star/ucb/InsertCommandArgument.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_MISSINGPROPERTIESEXCEPTION_HPP_
+#include <com/sun/star/ucb/MissingPropertiesException.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XACTIVEDATASTREAMER_HPP_
+#include <com/sun/star/io/XActiveDataStreamer.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_TRANSFERINFO_HPP_
+#include <com/sun/star/ucb/TransferInfo.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_NAMECLASH_HPP_
+#include <com/sun/star/ucb/NameClash.hpp>
+#endif
+#ifndef ODMA_CONTENT_HXX
+#include "odma_content.hxx"
+#endif
+#ifndef ODMA_PROVIDER_HXX
+#include "odma_provider.hxx"
+#endif
+#ifndef ODMA_RESULTSET_HXX
+#include "odma_resultset.hxx"
+#endif
+#ifndef ODMA_INPUTSTREAM_HXX
+#include "odma_inputstream.hxx"
+#endif
+#ifndef _UCBHELPER_CONTENT_HXX 
+#include <ucbhelper/content.hxx>
+#endif
+#ifndef _COM_SUN_STAR_UNO_EXCEPTION_HPP_
+#include <com/sun/star/uno/Exception.hpp>
+#endif
+#ifndef _RTL_REF_HXX_
+#include <rtl/ref.hxx>
+#endif
+#ifndef _OSL_FILE_HXX_ 
+#include <osl/file.hxx>
+#endif
+
+using namespace com::sun;
+using namespace com::sun::star;
+using namespace odma;
+
+//=========================================================================
+//=========================================================================
+//
+// Content Implementation.
+//
+//=========================================================================
+//=========================================================================
+
+Content::Content( const uno::Reference< lang::XMultiServiceFactory >& rxSMgr,
+                  ContentProvider* pProvider,
+                  const uno::Reference< star::ucb::XContentIdentifier >& Identifier,
+				  const ::vos::ORef<ContentProperties>& _rProps)
+	: ContentImplHelper( rxSMgr, pProvider, Identifier )
+	,m_aProps(_rProps)
+	,m_pProvider(pProvider)
+	,m_pContent(NULL)
+{
+	OSL_ENSURE(m_aProps.isValid(),"No valid ContentPropeties!");
+}
+
+//=========================================================================
+// virtual
+Content::~Content()
+{
+	delete m_pContent;
+}
+
+//=========================================================================
+//
+// XInterface methods.
+//
+//=========================================================================
+
+// virtual
+void SAL_CALL Content::acquire() throw()
+{
+	ContentImplHelper::acquire();
+}
+
+//=========================================================================
+// virtual
+void SAL_CALL Content::release() throw()
+{
+	ContentImplHelper::release();
+}
+
+//=========================================================================
+// virtual
+uno::Any SAL_CALL Content::queryInterface( const uno::Type & rType )
+    throw ( uno::RuntimeException )
+{
+    uno::Any aRet;
+
+	// @@@ Add support for additional interfaces.
+#if 0
+  	aRet = cppu::queryInterface( rType,
+                                 static_cast< yyy::Xxxxxxxxx * >( this ) );
+#endif
+
+ 	return aRet.hasValue() ? aRet : ContentImplHelper::queryInterface( rType );
+}
+
+//=========================================================================
+//
+// XTypeProvider methods.
+//
+//=========================================================================
+
+XTYPEPROVIDER_COMMON_IMPL( Content );
+
+//=========================================================================
+// virtual
+uno::Sequence< uno::Type > SAL_CALL Content::getTypes()
+    throw( uno::RuntimeException )
+{
+	// @@@ Add own interfaces.
+
+    static cppu::OTypeCollection* pCollection = 0;
+
+	if ( !pCollection )
+	{
+		osl::Guard< osl::Mutex > aGuard( osl::Mutex::getGlobalMutex() );
+	  	if ( !pCollection )
+	  	{
+            static cppu::OTypeCollection aCollection(
+                CPPU_TYPE_REF( lang::XTypeProvider ),
+                CPPU_TYPE_REF( lang::XServiceInfo ),
+                CPPU_TYPE_REF( lang::XComponent ),
+                CPPU_TYPE_REF( star::ucb::XContent ),
+                CPPU_TYPE_REF( star::ucb::XCommandProcessor ),
+                CPPU_TYPE_REF( beans::XPropertiesChangeNotifier ),
+                CPPU_TYPE_REF( star::ucb::XCommandInfoChangeNotifier ),
+                CPPU_TYPE_REF( beans::XPropertyContainer ),
+                CPPU_TYPE_REF( beans::XPropertySetInfoChangeNotifier ),
+                CPPU_TYPE_REF( container::XChild ) );
+	  		pCollection = &aCollection;
+		}
+	}
+
+	return (*pCollection).getTypes();
+}
+
+//=========================================================================
+//
+// XServiceInfo methods.
+//
+//=========================================================================
+
+// virtual
+rtl::OUString SAL_CALL Content::getImplementationName()
+    throw( uno::RuntimeException )
+{
+    // @@@ Adjust implementation name. Keep the prefix "com.sun.star.comp."!
+    return rtl::OUString::createFromAscii( "com.sun.star.comp.odma.Content" );
+}
+
+//=========================================================================
+// virtual
+uno::Sequence< rtl::OUString > SAL_CALL Content::getSupportedServiceNames()
+    throw( uno::RuntimeException )
+{
+	// @@@ Adjust macro name.
+    uno::Sequence< rtl::OUString > aSNS( 1 );
+	aSNS.getArray()[ 0 ]
+            = rtl::OUString::createFromAscii( ODMA_CONTENT_SERVICE_NAME );
+	return aSNS;
+}
+
+//=========================================================================
+//
+// XContent methods.
+//
+//=========================================================================
+
+// virtual
+rtl::OUString SAL_CALL Content::getContentType()
+    throw( uno::RuntimeException )
+{
+	// @@@ Adjust macro name ( def in odma_provider.hxx ).
+    return rtl::OUString::createFromAscii( ODMA_CONTENT_TYPE );
+}
+
+//=========================================================================
+//
+// XCommandProcessor methods.
+//
+//=========================================================================
+
+// virtual
+uno::Any SAL_CALL Content::execute(
+        const star::ucb::Command& aCommand,
+        sal_Int32 CommandId,
+        const uno::Reference< star::ucb::XCommandEnvironment >& Environment )
+    throw( uno::Exception,
+           star::ucb::CommandAbortedException,
+           uno::RuntimeException )
+{
+    uno::Any aRet;
+
+    if ( aCommand.Name.equalsAsciiL(
+			RTL_CONSTASCII_STRINGPARAM( "getPropertyValues" ) ) )
+	{
+		//////////////////////////////////////////////////////////////////
+		// getPropertyValues
+		//////////////////////////////////////////////////////////////////
+
+        uno::Sequence< beans::Property > Properties;
+		if ( !( aCommand.Argument >>= Properties ) )
+		{
+            OSL_ENSURE( sal_False, "Wrong argument type!" );
+            ucbhelper::cancelCommandExecution(
+                uno::makeAny( lang::IllegalArgumentException(
+                                    rtl::OUString(),
+                                    static_cast< cppu::OWeakObject * >( this ),
+                                    -1 ) ),
+                Environment );
+            // Unreachable
+		}
+
+        aRet <<= getPropertyValues( Properties, Environment );
+	}
+    else if ( aCommand.Name.equalsAsciiL(
+				RTL_CONSTASCII_STRINGPARAM( "setPropertyValues" ) ) )
+    {
+		//////////////////////////////////////////////////////////////////
+		// setPropertyValues
+		//////////////////////////////////////////////////////////////////
+
+        uno::Sequence< beans::PropertyValue > aProperties;
+		if ( !( aCommand.Argument >>= aProperties ) )
+		{
+            OSL_ENSURE( sal_False, "Wrong argument type!" );
+            ucbhelper::cancelCommandExecution(
+                uno::makeAny( lang::IllegalArgumentException(
+                                    rtl::OUString(),
+                                    static_cast< cppu::OWeakObject * >( this ),
+                                    -1 ) ),
+                Environment );
+            // Unreachable
+        }
+
+		if ( !aProperties.getLength() )
+		{
+            OSL_ENSURE( sal_False, "No properties!" );
+            ucbhelper::cancelCommandExecution(
+                uno::makeAny( lang::IllegalArgumentException(
+                                    rtl::OUString(),
+                                    static_cast< cppu::OWeakObject * >( this ),
+                                    -1 ) ),
+                Environment );
+            // Unreachable
+        }
+
+        aRet <<= setPropertyValues( aProperties, Environment );
+	}
+    else if ( aCommand.Name.equalsAsciiL(
+				RTL_CONSTASCII_STRINGPARAM( "getPropertySetInfo" ) ) )
+    {
+		//////////////////////////////////////////////////////////////////
+		// getPropertySetInfo
+		//////////////////////////////////////////////////////////////////
+
+		// Note: Implemented by base class.
+		aRet <<= getPropertySetInfo( Environment );
+	}
+    else if ( aCommand.Name.equalsAsciiL(
+				RTL_CONSTASCII_STRINGPARAM( "getCommandInfo" ) ) )
+    {
+		//////////////////////////////////////////////////////////////////
+		// getCommandInfo
+		//////////////////////////////////////////////////////////////////
+
+		// Note: Implemented by base class.
+		aRet <<= getCommandInfo( Environment );
+	}
+    else if ( aCommand.Name.equalsAsciiL(
+				RTL_CONSTASCII_STRINGPARAM( "open" ) ) )
+    {
+        star::ucb::OpenCommandArgument2 aOpenCommand;
+      	if ( !( aCommand.Argument >>= aOpenCommand ) )
+		{
+            OSL_ENSURE( sal_False, "Wrong argument type!" );
+            ucbhelper::cancelCommandExecution(
+                uno::makeAny( lang::IllegalArgumentException(
+                                    rtl::OUString(),
+                                    static_cast< cppu::OWeakObject * >( this ),
+                                    -1 ) ),
+                Environment );
+            // Unreachable
+        }
+
+        sal_Bool bOpenFolder =
+            ( ( aOpenCommand.Mode == star::ucb::OpenMode::ALL ) ||
+              ( aOpenCommand.Mode == star::ucb::OpenMode::FOLDERS ) ||
+              ( aOpenCommand.Mode == star::ucb::OpenMode::DOCUMENTS ) );
+
+        if ( bOpenFolder)
+		{
+            // open as folder - return result set
+
+            uno::Reference< star::ucb::XDynamicResultSet > xSet
+                            = new DynamicResultSet( m_xSMgr,
+													this,
+													aOpenCommand,
+													Environment );
+    		aRet <<= xSet;
+  		}
+
+        if ( aOpenCommand.Sink.is() )
+        {
+            // Open document - supply document data stream.
+
+            // Check open mode
+            if ( ( aOpenCommand.Mode
+                    == star::ucb::OpenMode::DOCUMENT_SHARE_DENY_NONE ) ||
+                 ( aOpenCommand.Mode
+                    == star::ucb::OpenMode::DOCUMENT_SHARE_DENY_WRITE ) )
+            {
+                // Unsupported.
+                ucbhelper::cancelCommandExecution(
+                    uno::makeAny( star::ucb::UnsupportedOpenModeException(
+                                    rtl::OUString(),
+                                    static_cast< cppu::OWeakObject * >( this ),
+                                    sal_Int16( aOpenCommand.Mode ) ) ),
+                    Environment );
+                // Unreachable
+            }
+
+
+            rtl::OUString aURL = m_xIdentifier->getContentIdentifier();
+			rtl::OUString sFileURL = openDoc();
+			delete m_pContent;
+			m_pContent = new ::ucb::Content(sFileURL,NULL);
+			if(!m_pContent->isDocument())
+			{
+				rtl::OUString sErrorMsg(RTL_CONSTASCII_USTRINGPARAM("File: "));
+				sErrorMsg += sFileURL;
+				sErrorMsg += rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(" could not be found."));
+				ucbhelper::cancelCommandExecution(
+						uno::makeAny( io::IOException(
+										sErrorMsg,
+										static_cast< cppu::OWeakObject * >( this )) ),
+						Environment );
+			}
+
+            uno::Reference< io::XOutputStream > xOut
+                = uno::Reference< io::XOutputStream >(
+                    aOpenCommand.Sink, uno::UNO_QUERY );
+    		if ( xOut.is() )
+      		{
+				// @@@ PUSH: write data into xOut
+				m_pContent->openStream(xOut);
+      		}
+    		else
+      		{
+                uno::Reference< io::XActiveDataSink > xDataSink
+                    = uno::Reference< io::XActiveDataSink >(
+                        aOpenCommand.Sink, uno::UNO_QUERY );
+      			if ( xDataSink.is() )
+				{
+	  				// @@@ PULL: wait for client read
+					uno::Reference< io::XInputStream > xIn;
+					try
+					{
+						xIn = m_pContent->openStream();
+					}
+					catch(uno::Exception&)
+					{
+						OSL_ENSURE(0,"Exception occured while creating the file content!");
+					}
+    				xDataSink->setInputStream( xIn );
+				}
+      			else
+				{
+					uno::Reference< io::XActiveDataStreamer > activeDataStreamer( aOpenCommand.Sink,uno::UNO_QUERY );
+					if(activeDataStreamer.is())
+					{
+						activeDataStreamer->setStream(new OOdmaStream(m_pContent,getContentProvider(),m_aProps));
+						m_pContent = NULL; // don't delete here because the stream is now the owner
+					}
+					else
+					{
+						// Note: aOpenCommand.Sink may contain an XStream
+						//       implementation. Support for this type of
+						//       sink is optional...
+						ucbhelper::cancelCommandExecution(
+							uno::makeAny( com::sun::star::ucb::UnsupportedDataSinkException(
+									rtl::OUString(),
+									static_cast< cppu::OWeakObject * >( this ),
+									aOpenCommand.Sink ) ),
+							Environment );
+						// Unreachable
+					}
+                }
+	  		}
+		}
+	}
+	else if ( aCommand.Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "close" ) ) )
+    {
+		getContentProvider()->closeDocument(m_aProps->m_sDocumentId);
+	}
+	else if ( aCommand.Name.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "delete" ) ) )
+    {
+		//////////////////////////////////////////////////////////////////
+		// delete
+		//////////////////////////////////////////////////////////////////
+
+		// Remove own and all children's Additional Core Properties.
+		removeAdditionalPropertySet( sal_True );
+		// Remove own and all childrens(!) persistent data.
+		if(!getContentProvider()->deleteDocument(m_aProps))
+			ucbhelper::cancelCommandExecution(
+                uno::makeAny( lang::IllegalArgumentException(
+                                    rtl::OUString(),
+                                    static_cast< cppu::OWeakObject * >( this ),
+                                    -1 ) ),
+                Environment );
+	}
+    else if ( aCommand.Name.equalsAsciiL(
+				RTL_CONSTASCII_STRINGPARAM( "insert" ) ) )
+    {
+		//////////////////////////////////////////////////////////////////
+		// insert
+		//////////////////////////////////////////////////////////////////
+
+        star::ucb::InsertCommandArgument arg;
+      	if ( !( aCommand.Argument >>= arg ) )
+		{
+	  		OSL_ENSURE( sal_False, "Wrong argument type!" );
+            ucbhelper::cancelCommandExecution(
+                uno::makeAny( lang::IllegalArgumentException(
+                                    rtl::OUString(),
+                                    static_cast< cppu::OWeakObject * >( this ),
+                                    -1 ) ),
+                Environment );
+            // Unreachable
+		}
+
+      	insert( arg.Data, arg.ReplaceExisting, Environment );
+    }
+	else if( ! aCommand.Name.compareToAscii( "transfer" ) )
+	{
+		com::sun::star::ucb::TransferInfo aTransferInfo;
+		if( ! ( aCommand.Argument >>= aTransferInfo ) )
+		{
+			OSL_ENSURE( sal_False, "Wrong argument type!" );
+            ucbhelper::cancelCommandExecution(
+                uno::makeAny( lang::IllegalArgumentException(
+                                    rtl::OUString(),
+                                    static_cast< cppu::OWeakObject * >( this ),
+                                    -1 ) ),
+                Environment );
+            // Unreachable
+		}
+		::vos::ORef<ContentProperties> aProp = m_aProps;
+		if(aProp->m_bIsFolder)
+		{
+			aProp = getContentProvider()->getContentPropertyWithTitle(aTransferInfo.NewTitle);
+			if(!aProp.isValid())
+				aProp = getContentProvider()->getContentPropertyWithSavedAsName(aTransferInfo.NewTitle);
+			sal_Bool bError = !aProp.isValid();
+			if(bError)
+			{
+				sal_Char* pExtension = NULL;
+				::rtl::OString sExt;
+				sal_Int32 nPos = aTransferInfo.NewTitle.lastIndexOf('.');
+				if(nPos != -1)
+				{
+					sExt = ::rtl::OUStringToOString(aTransferInfo.NewTitle.copy(nPos+1),RTL_TEXTENCODING_ASCII_US);
+					if(sExt.equalsIgnoreAsciiCase("txt"))
+						pExtension = ODM_FORMAT_TEXT;
+					else if(sExt.equalsIgnoreAsciiCase("rtf"))
+						pExtension = ODM_FORMAT_RTF;
+					else if(sExt.equalsIgnoreAsciiCase("ps"))
+						pExtension = ODM_FORMAT_PS;
+					else  
+						pExtension = const_cast<sal_Char*>(sExt.getStr());
+				}
+				else
+					pExtension = ODM_FORMAT_TEXT;
+
+				sal_Char* lpszNewDocId = new sal_Char[ODM_DOCID_MAX];
+				void *pData = NULL;
+				DWORD dwFlags = ODM_SILENT;
+				ODMSTATUS odm = NODMSaveAsEx(ContentProvider::getHandle(),
+											 NULL, // means it is saved the first time
+											 lpszNewDocId,
+											 pExtension,
+											 NULL, // no callback function here
+											 pData,
+											 &dwFlags);
+
+				// check if we have to call the DMS dialog
+				if(odm == ODM_E_USERINT) 
+				{ 
+					dwFlags = 0;
+					odm = NODMSaveAsEx(ContentProvider::getHandle(),
+											 NULL, // means it is saved the first time
+											 lpszNewDocId,
+											 pExtension,
+											 NULL, // no callback function here
+											 pData,
+											 &dwFlags);
+				}
+				bError = odm != ODM_SUCCESS;
+				if(!bError)
+				{
+					aProp = new ContentProperties();
+					aProp->m_sDocumentId	= ::rtl::OString(lpszNewDocId);
+					aProp->m_sContentType	= ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
+					aProp->m_sSavedAsName	= aTransferInfo.NewTitle;
+					getContentProvider()->append(aProp);
+
+					// now set the title
+					WORD nDocInfo = ODM_NAME;
+					::rtl::OUString sFileName = aTransferInfo.NewTitle;
+					sal_Int32 nIndex = aTransferInfo.NewTitle.lastIndexOf( sal_Unicode('.') );
+					if(nIndex != -1)
+						sFileName = aTransferInfo.NewTitle.copy(0,nIndex);
+
+					::rtl::OString sDocInfoValue = ::rtl::OUStringToOString(sFileName,RTL_TEXTENCODING_ASCII_US);
+					odm = NODMSetDocInfo(	ContentProvider::getHandle(),
+											lpszNewDocId,
+											nDocInfo,
+											const_cast<sal_Char*>(sDocInfoValue.getStr())
+											);
+
+				}
+				else if ( odm == ODM_E_CANCEL)
+					ODMSTATUS odm = NODMActivate(ContentProvider::getHandle(),
+												 ODM_DELETE,
+												 lpszNewDocId);
+
+				delete lpszNewDocId;
+			}
+			if(bError)
+				ucbhelper::cancelCommandExecution(
+						uno::makeAny( lang::IllegalArgumentException(
+											rtl::OUString(),
+											static_cast< cppu::OWeakObject * >( this ),
+											-1 ) ),
+						Environment );
+		}
+		rtl::OUString sFileURL = ContentProvider::openDoc(aProp);
+
+		sal_Int32 nLastIndex = sFileURL.lastIndexOf( sal_Unicode('/') );
+		::ucb::Content aContent(sFileURL.copy(0,nLastIndex),NULL);
+		//	aTransferInfo.NameClash = com::sun::star::ucb::NameClash::OVERWRITE;
+		aTransferInfo.NewTitle = sFileURL.copy( 1 + nLastIndex );
+		aContent.executeCommand(::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("transfer")),uno::makeAny(aTransferInfo));
+		getContentProvider()->saveDocument(aProp->m_sDocumentId);
+	}
+	else
+	{
+		//////////////////////////////////////////////////////////////////
+		// Unsupported command
+		//////////////////////////////////////////////////////////////////
+
+        OSL_ENSURE( sal_False, "Content::execute - unsupported command!" );
+
+        ucbhelper::cancelCommandExecution(
+            uno::makeAny( star::ucb::UnsupportedCommandException(
+                            rtl::OUString(),
+                            static_cast< cppu::OWeakObject * >( this ) ) ),
+            Environment );
+        // Unreachable
+    }
+
+	return aRet;
+}
+
+//=========================================================================
+// virtual
+void SAL_CALL Content::abort( sal_Int32 CommandId )
+    throw( uno::RuntimeException )
+{
+	// @@@ Implement logic to abort running commands, if this makes
+	//     sense for your content.
+}
+
+//=========================================================================
+//
+// Non-interface methods.
+//
+//=========================================================================
+
+// virtual
+::rtl::OUString Content::getParentURL()
+{
+    ::rtl::OUString sURL = m_xIdentifier->getContentIdentifier();
+
+    // @@@ Extract URL of parent from aURL and return it...
+	static ::rtl::OUString sScheme1(RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT "/"));
+	static ::rtl::OUString sScheme2(RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT));
+	if(sURL == sScheme1 || sURL == sScheme2)
+		sURL = ::rtl::OUString();
+	else
+		sURL = sScheme1;
+
+    return sURL;
+}
+
+//=========================================================================
+// static
+uno::Reference< sdbc::XRow > Content::getPropertyValues(
+            const uno::Reference< lang::XMultiServiceFactory >& rSMgr,
+            const uno::Sequence< beans::Property >& rProperties,
+            const ::vos::ORef<ContentProperties>& rData,
+            const vos::ORef< ::ucb::ContentProviderImplHelper >& rProvider,
+            const rtl::OUString& rContentId )
+{
+	// Note: Empty sequence means "get values of all supported properties".
+
+    rtl::Reference< ::ucb::PropertyValueSet > xRow
+                                = new ::ucb::PropertyValueSet( rSMgr );
+
+	sal_Int32 nCount = rProperties.getLength();
+	if ( nCount )
+	{
+        uno::Reference< beans::XPropertySet > xAdditionalPropSet;
+		sal_Bool bTriedToGetAdditonalPropSet = sal_False;
+
+        const beans::Property* pProps = rProperties.getConstArray();
+		for ( sal_Int32 n = 0; n < nCount; ++n )
+		{
+            const beans::Property& rProp = pProps[ n ];
+
+			// Process Core properties.
+
+            if ( rProp.Name.equalsAsciiL(
+					RTL_CONSTASCII_STRINGPARAM( "ContentType" ) ) )
+            {
+				xRow->appendString ( rProp, rData->m_sContentType );
+			}
+            else if ( rProp.Name.equalsAsciiL(
+                    RTL_CONSTASCII_STRINGPARAM( "Title" ) ) )
+			{
+				xRow->appendString ( rProp, rData->m_sTitle );
+			}
+            else if ( rProp.Name.equalsAsciiL(
+                    RTL_CONSTASCII_STRINGPARAM( "IsDocument" ) ) )
+			{
+				xRow->appendBoolean( rProp, rData->m_bIsDocument );
+			}
+            else if ( rProp.Name.equalsAsciiL(
+                    RTL_CONSTASCII_STRINGPARAM( "IsFolder" ) ) )
+			{
+				xRow->appendBoolean( rProp, rData->m_bIsFolder );
+			}
+            else if ( rProp.Name.equalsAsciiL(
+                    RTL_CONSTASCII_STRINGPARAM( "DateCreated" ) ) )
+			{
+				xRow->appendTimestamp( rProp, rData->m_aDateCreated );
+			}
+			else if ( rProp.Name.equalsAsciiL(
+                    RTL_CONSTASCII_STRINGPARAM( "DateModified" ) ) )
+			{
+				xRow->appendTimestamp( rProp, rData->m_aDateModified );
+			}
+			else if ( rProp.Name.equalsAsciiL(
+                    RTL_CONSTASCII_STRINGPARAM( "IsReadOnly" ) ) )
+			{
+				xRow->appendBoolean( rProp, rData->m_bIsReadOnly );
+			}
+			else if ( rProp.Name.equalsAsciiL(
+                    RTL_CONSTASCII_STRINGPARAM( "Author" ) ) )
+			{
+				xRow->appendString ( rProp, rData->m_sAuthor );
+			}
+			else if ( rProp.Name.equalsAsciiL(
+                    RTL_CONSTASCII_STRINGPARAM( "Subject" ) ) )
+			{
+				xRow->appendString ( rProp, rData->m_sSubject );
+			}
+			else if ( rProp.Name.equalsAsciiL(
+                    RTL_CONSTASCII_STRINGPARAM( "Keywords" ) ) )
+			{
+				xRow->appendString ( rProp, rData->m_sKeywords );
+			}
+			else
+			{
+				// @@@ Note: If your data source supports adding/removing
+				//     properties, you should implement the interface
+				//     XPropertyContainer by yourself and supply your own
+				//     logic here. The base class uses the service
+				//     "com.sun.star.ucb.Store" to maintain Additional Core
+				//     properties. But using server functionality is preferred!
+
+				// Not a Core Property! Maybe it's an Additional Core Property?!
+
+				if ( !bTriedToGetAdditonalPropSet && !xAdditionalPropSet.is() )
+				{
+					xAdditionalPropSet
+                        = uno::Reference< beans::XPropertySet >(
+							rProvider->getAdditionalPropertySet( rContentId,
+																 sal_False ),
+                            uno::UNO_QUERY );
+					bTriedToGetAdditonalPropSet = sal_True;
+				}
+
+				if ( xAdditionalPropSet.is() )
+				{
+					if ( !xRow->appendPropertySetValue(
+												xAdditionalPropSet,
+												rProp ) )
+					{
+						// Append empty entry.
+						xRow->appendVoid( rProp );
+					}
+				}
+				else
+				{
+					// Append empty entry.
+					xRow->appendVoid( rProp );
+				}
+			}
+		}
+	}
+	else
+	{
+		// Append all Core Properties.
+		xRow->appendString (
+            beans::Property( rtl::OUString::createFromAscii( "ContentType" ),
+					  -1,
+                      getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
+                      beans::PropertyAttribute::BOUND
+                        | beans::PropertyAttribute::READONLY ),
+			rData->m_sContentType );
+		xRow->appendString (
+            beans::Property( rtl::OUString::createFromAscii( "Title" ),
+					  -1,
+                      getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
+                      beans::PropertyAttribute::BOUND ),
+			rData->m_sTitle );
+		xRow->appendBoolean(
+            beans::Property( rtl::OUString::createFromAscii( "IsDocument" ),
+					  -1,
+					  getCppuBooleanType(),
+                      beans::PropertyAttribute::BOUND
+                        | beans::PropertyAttribute::READONLY ),
+			rData->m_bIsDocument );
+		xRow->appendBoolean(
+            beans::Property( rtl::OUString::createFromAscii( "IsFolder" ),
+					  -1,
+					  getCppuBooleanType(),
+                      beans::PropertyAttribute::BOUND
+                        | beans::PropertyAttribute::READONLY ),
+			rData->m_bIsFolder );
+
+		// @@@ Append other properties supported directly.
+		xRow->appendTimestamp(
+            beans::Property( rtl::OUString::createFromAscii( "DateCreated" ),
+					  -1,
+					  getCppuType(static_cast< const com::sun::star::util::DateTime * >( 0 ) ),
+                      beans::PropertyAttribute::BOUND
+                        | beans::PropertyAttribute::READONLY ),
+			rData->m_aDateCreated );
+		xRow->appendTimestamp(
+            beans::Property( rtl::OUString::createFromAscii( "DateModified" ),
+					  -1,
+					  getCppuType(static_cast< const com::sun::star::util::DateTime * >( 0 ) ),
+                      beans::PropertyAttribute::BOUND
+                        | beans::PropertyAttribute::READONLY ),
+			rData->m_aDateModified );
+		xRow->appendBoolean(
+            beans::Property( rtl::OUString::createFromAscii( "IsReadOnly" ),
+					  -1,
+					  getCppuBooleanType(),
+                      beans::PropertyAttribute::BOUND
+                        | beans::PropertyAttribute::READONLY ),
+			rData->m_bIsReadOnly );
+		xRow->appendString (
+            beans::Property( rtl::OUString::createFromAscii( "Author" ),
+					  -1,
+                      getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
+                      beans::PropertyAttribute::BOUND ),
+			rData->m_sAuthor );
+		xRow->appendString (
+            beans::Property( rtl::OUString::createFromAscii( "Subject" ),
+					  -1,
+                      getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
+                      beans::PropertyAttribute::BOUND ),
+			rData->m_sSubject );
+		xRow->appendString (
+            beans::Property( rtl::OUString::createFromAscii( "Keywords" ),
+					  -1,
+                      getCppuType( static_cast< const rtl::OUString * >( 0 ) ),
+                      beans::PropertyAttribute::BOUND ),
+			rData->m_sKeywords );
+
+		// @@@ Note: If your data source supports adding/removing
+		//     properties, you should implement the interface
+		//     XPropertyContainer by yourself and supply your own
+		//     logic here. The base class uses the service
+		//     "com.sun.star.ucb.Store" to maintain Additional Core
+		//     properties. But using server functionality is preferred!
+
+		// Append all Additional Core Properties.
+
+        uno::Reference< beans::XPropertySet > xSet(
+			rProvider->getAdditionalPropertySet( rContentId, sal_False ),
+            uno::UNO_QUERY );
+		xRow->appendPropertySet( xSet );
+	}
+
+    return uno::Reference< sdbc::XRow >( xRow.get() );
+}
+
+//=========================================================================
+uno::Reference< sdbc::XRow > Content::getPropertyValues(
+            const uno::Sequence< beans::Property >& rProperties,
+            const uno::Reference< star::ucb::XCommandEnvironment >& xEnv )
+{
+	osl::Guard< osl::Mutex > aGuard( m_aMutex );
+	return getPropertyValues( m_xSMgr,
+							  rProperties,
+							  m_aProps,
+                              vos::ORef<
+                                ::ucb::ContentProviderImplHelper >(
+                                    m_xProvider.getBodyPtr() ),
+							  m_xIdentifier->getContentIdentifier() );
+}
+
+//=========================================================================
+uno::Sequence< uno::Any > Content::setPropertyValues(
+            const uno::Sequence< beans::PropertyValue >& rValues,
+            const uno::Reference< star::ucb::XCommandEnvironment >& xEnv )
+{
+	osl::ClearableGuard< osl::Mutex > aGuard( m_aMutex );
+
+    uno::Sequence< uno::Any > aRet( rValues.getLength() );
+    uno::Sequence< beans::PropertyChangeEvent > aChanges( rValues.getLength() );
+	sal_Int32 nChanged = 0;
+
+    beans::PropertyChangeEvent aEvent;
+    aEvent.Source         = static_cast< cppu::OWeakObject * >( this );
+	aEvent.Further 		  = sal_False;
+//	aEvent.PropertyName	  =
+	aEvent.PropertyHandle = -1;
+//	aEvent.OldValue		  =
+//	aEvent.NewValue       =
+
+    const beans::PropertyValue* pValues = rValues.getConstArray();
+	sal_Int32 nCount = rValues.getLength();
+
+    uno::Reference< star::ucb::XPersistentPropertySet > xAdditionalPropSet;
+	sal_Bool bTriedToGetAdditonalPropSet = sal_False;
+
+	for ( sal_Int32 n = 0; n < nCount; ++n )
+	{
+        const beans::PropertyValue& rValue = pValues[ n ];
+
+        if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Title" ) ) )
+		{
+			changePropertyValue(rValue,n,m_aProps->m_sTitle,nChanged,aRet,aChanges);
+		}
+		else if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Author") ) )
+		{
+			changePropertyValue(rValue,n,m_aProps->m_sAuthor,nChanged,aRet,aChanges);
+		}
+		else if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Keywords") ) )
+		{
+			changePropertyValue(rValue,n,m_aProps->m_sKeywords,nChanged,aRet,aChanges);
+		}
+		else if ( rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "Subject") ) )
+		{
+			changePropertyValue(rValue,n,m_aProps->m_sSubject,nChanged,aRet,aChanges);
+		}
+		else if (	rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "ContentType" ) )	||
+					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "IsDocument" ) )	||
+					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "IsFolder" ) )		||
+					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "DateCreated" ) )	||
+					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "DateModified" ) )	||
+					rValue.Name.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM( "IsReadOnly" ) ) )
+        {
+			// Read-only property!
+            aRet[ n ] <<= lang::IllegalAccessException(
+                            rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(
+                                "Property is read-only!") ),
+                            static_cast< cppu::OWeakObject * >( this ) );
+		}
+		else
+		{
+			// @@@ Note: If your data source supports adding/removing
+			//     properties, you should implement the interface
+			//     XPropertyContainer by yourself and supply your own
+			//     logic here. The base class uses the service
+			//     "com.sun.star.ucb.Store" to maintain Additional Core
+			//     properties. But using server functionality is preferred!
+
+			// Not a Core Property! Maybe it's an Additional Core Property?!
+
+			if ( !bTriedToGetAdditonalPropSet && !xAdditionalPropSet.is() )
+			{
+				xAdditionalPropSet = getAdditionalPropertySet( sal_False );
+				bTriedToGetAdditonalPropSet = sal_True;
+			}
+
+			if ( xAdditionalPropSet.is() )
+			{
+				try
+				{
+                    uno::Any aOldValue
+                        = xAdditionalPropSet->getPropertyValue( rValue.Name );
+					if ( aOldValue != rValue.Value )
+					{
+						xAdditionalPropSet->setPropertyValue(
+												rValue.Name, rValue.Value );
+
+						aEvent.PropertyName = rValue.Name;
+						aEvent.OldValue		= aOldValue;
+						aEvent.NewValue     = rValue.Value;
+
+						aChanges.getArray()[ nChanged ] = aEvent;
+						nChanged++;
+					}
+                    else
+                    {
+                        // Old value equals new value. No error!
+                    }
+				}
+                catch ( beans::UnknownPropertyException const & e )
+				{
+                    aRet[ n ] <<= e;
+				}
+                catch ( lang::WrappedTargetException const & e )
+				{
+                    aRet[ n ] <<= e;
+				}
+                catch ( beans::PropertyVetoException const & e )
+				{
+                    aRet[ n ] <<= e;
+				}
+                catch ( lang::IllegalArgumentException const & e )
+				{
+                    aRet[ n ] <<= e;
+				}
+			}
+            else
+            {
+                aRet[ n ] <<= uno::Exception(
+                                rtl::OUString::createFromAscii(
+                                    "No property set for storing the value!" ),
+                                static_cast< cppu::OWeakObject * >( this ) );
+            }
+		}
+	}
+
+	if ( nChanged > 0 )
+	{
+		// @@@ Save changes.
+//		storeData();
+
+		aGuard.clear();
+		aChanges.realloc( nChanged );
+		notifyPropertiesChange( aChanges );
+	}
+
+    return aRet;
+}
+
+#if 0
+//=========================================================================
+void Content::queryChildren( ContentRefList& rChildren )
+{
+	// @@@ Adapt method to your URL scheme...
+
+	// Obtain a list with a snapshot of all currently instanciated contents
+	// from provider and extract the contents which are direct children
+	// of this content.
+
+	::ucb::ContentRefList aAllContents;
+	m_xProvider->queryExistingContents( aAllContents );
+
+	OUString aURL = m_xIdentifier->getContentIdentifier();
+	sal_Int32 nPos = aURL.lastIndexOf( '/' );
+
+	if ( nPos != ( aURL.getLength() - 1 ) )
+	{
+		// No trailing slash found. Append.
+		aURL += OUString::createFromAscii( "/" );
+	}
+
+	sal_Int32 nLen = aURL.getLength();
+
+	::ucb::ContentRefList::const_iterator it  = aAllContents.begin();
+	::ucb::ContentRefList::const_iterator end = aAllContents.end();
+
+	while ( it != end )
+	{
+		::ucb::ContentImplHelperRef xChild = (*it);
+		OUString aChildURL = xChild->getIdentifier()->getContentIdentifier();
+
+		// Is aURL a prefix of aChildURL?
+		if ( ( aChildURL.getLength() > nLen ) &&
+			 ( aChildURL.compareTo( aURL, nLen ) == 0 ) )
+		{
+			sal_Int32 nPos = nLen;
+			nPos = aChildURL.indexOf( '/', nPos );
+
+			if ( ( nPos == -1 ) ||
+				 ( nPos == ( aChildURL.getLength() - 1 ) ) )
+			{
+				// No further slashes / only a final slash. It's a child!
+				rChildren.push_back(
+					ContentRef(
+						static_cast< Content * >( xChild.getBodyPtr() ) ) );
+			}
+		}
+		++it;
+	}
+}
+#endif
+//=========================================================================
+void Content::insert(
+        const uno::Reference< io::XInputStream > & xInputStream,
+        sal_Bool bReplaceExisting,
+        const uno::Reference<
+            com::sun::star::ucb::XCommandEnvironment >& Environment )
+    throw( uno::Exception )
+{
+	osl::ClearableGuard< osl::Mutex > aGuard( m_aMutex );
+
+	// Check, if all required properties were set.
+	if ( !m_aProps->m_sTitle.getLength())
+	{
+        OSL_ENSURE( sal_False, "Content::insert - property value missing!" );
+
+        uno::Sequence< rtl::OUString > aProps( 1 );
+        aProps[ 0 ] = rtl::OUString::createFromAscii( "zzzz" );
+        ucbhelper::cancelCommandExecution(
+            uno::makeAny( star::ucb::MissingPropertiesException(
+                                rtl::OUString(),
+                                static_cast< cppu::OWeakObject * >( this ),
+                                aProps ) ),
+            Environment );
+        // Unreachable
+	}
+
+    if ( !xInputStream.is() )
+    {
+        OSL_ENSURE( sal_False, "Content::insert - No data stream!" );
+
+        ucbhelper::cancelCommandExecution(
+            uno::makeAny( star::ucb::MissingInputStreamException(
+                            rtl::OUString(),
+                            static_cast< cppu::OWeakObject * >( this ) ) ),
+            Environment );
+        // Unreachable
+    }
+
+	// Assemble new content identifier...
+
+    //	uno::Reference< star::ucb::XContentIdentifier > xId = ...;
+
+    // Fail, if a resource with given id already exists.
+    if ( !bReplaceExisting ) // && hasData( m_xIdentifier ) )
+    {
+		ucbhelper::cancelCommandExecution(
+            uno::makeAny( star::ucb::UnsupportedCommandException(
+                            rtl::OUString(),
+                            static_cast< cppu::OWeakObject * >( this ) ) ),
+            Environment );
+//        ucbhelper::cancelCommandExecution(
+//						star::ucb::IOErrorCode_ALREADY_EXISTING,
+//						Environment,
+//						uno::makeAny(static_cast< cppu::OWeakObject * >( this ))
+//                         );
+        // Unreachable
+    }
+
+	//	m_xIdentifier = xId;
+
+//  @@@
+//	storeData();
+
+	aGuard.clear();
+	inserted();
+}
+#if 0
+//=========================================================================
+void Content::destroy( sal_Bool bDeletePhysical )
+    throw( uno::Exception )
+{
+	// @@@ take care about bDeletePhysical -> trashcan support
+
+    uno::Reference< star::ucb::XContent > xThis = this;
+
+	deleted();
+
+	osl::Guard< osl::Mutex > aGuard( m_aMutex );
+
+	// Process instanciated children...
+
+	ContentRefList aChildren;
+	queryChildren( aChildren );
+
+	ContentRefList::const_iterator it  = aChildren.begin();
+	ContentRefList::const_iterator end = aChildren.end();
+
+	while ( it != end )
+	{
+		(*it)->destroy( bDeletePhysical );
+		++it;
+	}
+}
+#endif
+
+// -----------------------------------------------------------------------------
+::rtl::OUString Content::openDoc()
+{
+	OSL_ENSURE(m_aProps.isValid(),"No valid content properties!");
+	return ContentProvider::openDoc(m_aProps);
+}
+// -----------------------------------------------------------------------------
+void Content::changePropertyValue(const beans::PropertyValue& _rValue,
+								  sal_Int32 _rnCurrentPos,
+								  ::rtl::OUString& _rsMemberValue,
+								  sal_Int32& _rnChanged,
+								  uno::Sequence< uno::Any >& _rRet,
+								  uno::Sequence< beans::PropertyChangeEvent >& _rChanges) throw (beans::IllegalTypeException)
+{
+    rtl::OUString sNewValue;
+	sal_Bool bError = sal_False;
+	if ( _rValue.Value >>= sNewValue )
+	{
+		if ( sNewValue != _rsMemberValue )
+		{
+			osl::Guard< osl::Mutex > aGuard( m_aMutex );
+			// first we have to check if we could change the property inside the DMS
+			::rtl::OString sDocInfoValue = ::rtl::OUStringToOString(sNewValue,RTL_TEXTENCODING_ASCII_US);
+			WORD nDocInfo;
+			if(&_rsMemberValue == &m_aProps->m_sTitle)
+				nDocInfo = ODM_TITLETEXT;
+			else if(&_rsMemberValue == &m_aProps->m_sAuthor)
+				nDocInfo = ODM_AUTHOR;
+			else if(&_rsMemberValue == &m_aProps->m_sSubject)
+				nDocInfo = ODM_SUBJECT;
+			else if(&_rsMemberValue == &m_aProps->m_sKeywords)
+				nDocInfo = ODM_KEYWORDS;
+			else
+				bError = sal_True;
+
+			if(!bError)
+			{
+				ODMSTATUS odm = NODMSetDocInfo(	ContentProvider::getHandle(),
+												const_cast<sal_Char*>(m_aProps->m_sDocumentId.getStr()),
+												nDocInfo,
+												const_cast<sal_Char*>(sDocInfoValue.getStr())
+												);
+				if(odm == ODM_SUCCESS)
+				{
+					beans::PropertyChangeEvent aEvent;
+					aEvent.Source			= static_cast< cppu::OWeakObject * >( this );
+					aEvent.Further 			= sal_False;
+					aEvent.PropertyHandle	= -1;
+					aEvent.PropertyName		= _rValue.Name;
+					aEvent.OldValue			= uno::makeAny( _rsMemberValue );
+					aEvent.NewValue			= uno::makeAny( sNewValue );
+
+					_rChanges.getArray()[ _rnChanged ] = aEvent;
+
+					_rsMemberValue = sNewValue;
+					++_rnChanged;
+				}
+			}
+		}
+        else
+        {
+            // Old value equals new value. No error!
+        }
+	}
+    else
+		bError = sal_True;
+
+	if(bError)
+    {
+        _rRet[ _rnCurrentPos ] <<= beans::IllegalTypeException(
+                        rtl::OUString::createFromAscii(
+                            "Property value has wrong type!" ),
+                        static_cast< cppu::OWeakObject * >( this ) );
+    }
+}
+// -----------------------------------------------------------------------------
+
diff --new-file -r -u /tmp/nothing/odma_content.hxx ucb/source/ucp/odma/odma_content.hxx
--- /tmp/nothing/odma_content.hxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_content.hxx	2003-08-25 14:00:21.000000000 +0100
@@ -0,0 +1,234 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+// @@@ Adjust multi-include-protection-ifdef.
+#ifndef ODMA_CONTENT_HXX
+#define ODMA_CONTENT_HXX
+
+#include <list>
+
+#ifndef _UCBHELPER_CONTENTHELPER_HXX
+#include <ucbhelper/contenthelper.hxx>
+#endif
+
+namespace com { namespace sun { namespace star { 
+	namespace beans {
+		struct Property;
+		struct PropertyValue;
+	} 
+	namespace sdbc {
+		class XRow;
+	}
+	namespace io {
+		class XInputStream;
+	}
+}}}
+namespace ucb
+{
+	class Content;
+}
+
+
+// @@@ Adjust namespace name.
+namespace odma
+{
+
+//=========================================================================
+
+// @@@ Adjust service name.
+
+// UNO service name for the content.
+#define ODMA_CONTENT_SERVICE_NAME \
+							"com.sun.star.ucb.OdmaContent"
+
+//=========================================================================
+class ContentProvider;
+class ContentProperties;
+class Content : public ::ucb::ContentImplHelper
+{
+	::vos::ORef<ContentProperties>	m_aProps;
+	ContentProvider*				m_pProvider;
+	::ucb::Content*					m_pContent;
+
+private:
+	virtual com::sun::star::uno::Sequence< com::sun::star::beans::Property >
+	getProperties( const com::sun::star::uno::Reference<
+					com::sun::star::ucb::XCommandEnvironment > & xEnv );
+	virtual com::sun::star::uno::Sequence< com::sun::star::ucb::CommandInfo >
+	getCommands( const com::sun::star::uno::Reference<
+					com::sun::star::ucb::XCommandEnvironment > & xEnv );
+    virtual ::rtl::OUString getParentURL();
+
+	::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XRow >
+	getPropertyValues( const ::com::sun::star::uno::Sequence<
+                        ::com::sun::star::beans::Property >& rProperties,
+                       const ::com::sun::star::uno::Reference<
+						::com::sun::star::ucb::XCommandEnvironment >& xEnv );
+    ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >
+    setPropertyValues( const ::com::sun::star::uno::Sequence<
+                        ::com::sun::star::beans::PropertyValue >& rValues,
+                       const ::com::sun::star::uno::Reference<
+                        ::com::sun::star::ucb::XCommandEnvironment >& xEnv );
+
+	/** openDoc returns the file URL for the DOC ID
+		@return the url of the temporary file
+	*/
+	::rtl::OUString openDoc();
+
+	/** changePropertyValue sets the property referenced by _sMemberValue to the new value
+		@param	_rValue			the new value to set
+		@param	_rnCurrentPos	the current position inside the Any sequence _rRet
+		@param	_sMemberValue	the place where to set the property
+		@param	_rnChanged		will be incremented when property changed
+		@param	_rRet			collect the exceptions
+		@param	_rChanges		contains the changes done
+	*/
+	void changePropertyValue(const ::com::sun::star::beans::PropertyValue& _rValue,
+							 sal_Int32 _rnCurrentPos,
+							 ::rtl::OUString& _rsMemberValue,
+							 sal_Int32& _rnChanged,
+							 ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any >& _rRet,
+							 ::com::sun::star::uno::Sequence< ::com::sun::star::beans::PropertyChangeEvent >& _rChanges) throw (::com::sun::star::beans::IllegalTypeException);
+
+//    typedef rtl::Reference< Content > ContentRef;
+//    typedef std::list< ContentRef > ContentRefList;
+//    void queryChildren( ContentRefList& rChildren );
+
+  // Command "insert"
+    void insert( const ::com::sun::star::uno::Reference<
+                    ::com::sun::star::io::XInputStream > & xInputStream,
+                 sal_Bool bReplaceExisting,
+                 const com::sun::star::uno::Reference<
+                    com::sun::star::ucb::XCommandEnvironment >& Environment )
+        throw( ::com::sun::star::uno::Exception );
+
+//  // Command "delete"
+//	void destroy( sal_Bool bDeletePhysical )
+//      throw( ::com::sun::star::uno::Exception );
+
+public:
+	Content( const ::com::sun::star::uno::Reference<
+				::com::sun::star::lang::XMultiServiceFactory >& rxSMgr,
+				ContentProvider* pProvider,
+			 const ::com::sun::star::uno::Reference<
+				::com::sun::star::ucb::XContentIdentifier >& Identifier,
+				const ::vos::ORef<ContentProperties>& _rProps);
+	virtual ~Content();
+
+	// XInterface
+	XINTERFACE_DECL()
+
+	// XTypeProvider
+	XTYPEPROVIDER_DECL()
+
+    // XServiceInfo
+    virtual ::rtl::OUString SAL_CALL
+	getImplementationName()
+		throw( ::com::sun::star::uno::RuntimeException );
+    virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL
+	getSupportedServiceNames()
+		throw( ::com::sun::star::uno::RuntimeException );
+
+	// XContent
+    virtual rtl::OUString SAL_CALL
+	getContentType()
+		throw( com::sun::star::uno::RuntimeException );
+
+	// XCommandProcessor
+    virtual com::sun::star::uno::Any SAL_CALL
+	execute( const com::sun::star::ucb::Command& aCommand,
+			 sal_Int32 CommandId,
+			 const com::sun::star::uno::Reference<
+			 	com::sun::star::ucb::XCommandEnvironment >& Environment )
+    	throw( com::sun::star::uno::Exception,
+			   com::sun::star::ucb::CommandAbortedException,
+			   com::sun::star::uno::RuntimeException );
+    virtual void SAL_CALL
+	abort( sal_Int32 CommandId )
+		throw( com::sun::star::uno::RuntimeException );
+
+	//////////////////////////////////////////////////////////////////////
+	// Additional interfaces
+	//////////////////////////////////////////////////////////////////////
+
+	// @@@ Add additional interfaces ( like com::sun:.star::ucb::XContentCreator ).
+
+	//////////////////////////////////////////////////////////////////////
+	// Non-interface methods.
+	//////////////////////////////////////////////////////////////////////
+
+	// Called from resultset data supplier.
+	static ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XRow >
+	getPropertyValues( const ::com::sun::star::uno::Reference<
+						::com::sun::star::lang::XMultiServiceFactory >& rSMgr,
+					   const ::com::sun::star::uno::Sequence<
+					   	::com::sun::star::beans::Property >& rProperties,
+					   const ::vos::ORef<ContentProperties>& rData,
+                       const ::vos::ORef<
+					   	::ucb::ContentProviderImplHelper >&	rProvider,
+                       const ::rtl::OUString& rContentId );
+
+	ContentProvider* getContentProvider() const { return m_pProvider; }
+};
+
+}
+
+#endif
diff --new-file -r -u /tmp/nothing/odma_contentprops.hxx ucb/source/ucp/odma/odma_contentprops.hxx
--- /tmp/nothing/odma_contentprops.hxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_contentprops.hxx	2003-08-25 14:00:37.000000000 +0100
@@ -0,0 +1,127 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the License); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an AS IS basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef ODMA_CONTENTPROPS_HXX
+#define ODMA_CONTENTPROPS_HXX
+
+#ifndef _VOS_REFERNCE_HXX_ 
+#include <vos/refernce.hxx>
+#endif
+#ifndef _VOS_REF_HXX_ 
+#include <vos/ref.hxx>
+#endif
+#ifndef _RTL_USTRING_HXX_ 
+#include <rtl/ustring.hxx>
+#endif
+#ifndef _COM_SUN_STAR_UTIL_DATETIME_HPP_
+#include <com/sun/star/util/DateTime.hpp>
+#endif
+#include <functional>
+
+namespace odma
+{
+	class ContentProperties : public ::vos::OReference
+	{
+	public:
+		com::sun::star::util::DateTime	m_aDateCreated;	// when was the document created
+		com::sun::star::util::DateTime	m_aDateModified;	// when was the document last modified
+		::rtl::OUString					m_sTitle;    	// Title
+		::rtl::OUString					m_sContentType;	// ContentType
+		::rtl::OString					m_sDocumentId;	// the document id given from the DMS
+		::rtl::OUString					m_sDocumentName;// document name
+		::rtl::OUString					m_sFileURL;		// the temporary file location
+		::rtl::OUString					m_sAuthor;		// the Author of the document
+		::rtl::OUString					m_sSubject;		// the subject of the document
+		::rtl::OUString					m_sKeywords;	// the keywords of the document
+		::rtl::OUString					m_sSavedAsName;	// the name which was used to save it
+		sal_Bool						m_bIsDocument;  // IsDocument
+		sal_Bool						m_bIsFolder;    // IsFolder
+		sal_Bool						m_bIsOpen;		// is true when OpenDoc was called
+		sal_Bool						m_bIsReadOnly;	// true when the document is read-only
+
+		// @@@ Add other properties supported by your content.
+
+		ContentProperties()
+		:m_bIsDocument( sal_True )
+		,m_bIsFolder( sal_False )
+		,m_bIsOpen( sal_False ) 
+		,m_bIsReadOnly( sal_False )
+		{}
+
+		inline ::rtl::OUString getTitle()		const { return m_sTitle;		}
+		inline ::rtl::OUString getSavedAsName() const { return m_sSavedAsName;	}
+	};
+	typedef ::std::binary_function< ::vos::ORef<ContentProperties>, ::rtl::OUString,bool> TContentPropertiesFunctorBase;
+	/// binary_function Functor object for class ContentProperties return type is bool
+	class ContentPropertiesMemberFunctor : public TContentPropertiesFunctorBase 
+	{
+		::std::const_mem_fun_t< ::rtl::OUString,ContentProperties> m_aFunction;
+	public:
+		ContentPropertiesMemberFunctor(const ::std::const_mem_fun_t< ::rtl::OUString,ContentProperties>& _rFunc) 
+			: m_aFunction(_rFunc){}
+
+		inline bool operator()(const ::vos::ORef<ContentProperties>& lhs,const ::rtl::OUString& rhs) const
+		{
+			return !!(m_aFunction(lhs.getBodyPtr()) == rhs);
+		}
+	};
+}
+#endif // ODMA_CONTENTPROPS_HXX
+
diff --new-file -r -u /tmp/nothing/odma_datasupplier.cxx ucb/source/ucp/odma/odma_datasupplier.cxx
--- /tmp/nothing/odma_datasupplier.cxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_datasupplier.cxx	2003-08-25 14:00:46.000000000 +0100
@@ -0,0 +1,502 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+/**************************************************************************
+								TODO
+ **************************************************************************
+
+ *************************************************************************/
+
+#include <vector>
+
+#ifndef _UCBHELPER_CONTENTIDENTIFIER_HXX
+#include <ucbhelper/contentidentifier.hxx>
+#endif
+#ifndef _UCBHELPER_PROVIDERHELPER_HXX
+#include <ucbhelper/providerhelper.hxx>
+#endif
+
+#ifndef ODMA_DATASUPPLIER_HXX
+#include "odma_datasupplier.hxx"
+#endif
+#ifndef ODMA_CONTENT_HXX
+#include "odma_content.hxx"
+#endif
+#ifndef ODMA_CONTENTPROPS_HXX
+#include "odma_contentprops.hxx"
+#endif
+#ifndef ODMA_PROVIDER_HXX
+#include "odma_provider.hxx"
+#endif
+#ifndef ODMA_LIB_HXX
+#include "odma_lib.hxx"
+#endif
+
+using namespace com::sun::star::beans;
+using namespace com::sun::star::lang;
+using namespace com::sun::star::ucb;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::sdbc;
+using namespace ucb;
+
+using namespace odma;
+
+namespace odma
+{
+
+//=========================================================================
+//
+// struct ResultListEntry.
+//
+//=========================================================================
+
+struct ResultListEntry
+{
+	::rtl::OUString					aId;
+	Reference< XContentIdentifier > xId;
+	Reference< XContent > 			xContent;
+	Reference< XRow > 				xRow;
+	::vos::ORef<ContentProperties>	rData;
+
+	ResultListEntry( const ::vos::ORef<ContentProperties>& rEntry ) : rData( rEntry ) {}
+};
+
+//=========================================================================
+//
+// ResultList.
+//
+//=========================================================================
+
+typedef std::vector< ResultListEntry* > ResultList;
+
+//=========================================================================
+//
+// struct DataSupplier_Impl.
+//
+//=========================================================================
+
+struct DataSupplier_Impl
+{
+	osl::Mutex					      m_aMutex;
+	ResultList					      m_aResults;
+	vos::ORef< Content >     		  m_xContent;
+	Reference< XMultiServiceFactory > m_xSMgr;
+// @@@ The data source and an iterator for it
+//	Entry 		 	      	  		  m_aFolder;
+//	Entry::iterator 		  		  m_aIterator;
+  	sal_Int32					      m_nOpenMode;
+  	sal_Bool					      m_bCountFinal;
+														   
+	DataSupplier_Impl( const Reference< XMultiServiceFactory >& rxSMgr,
+	                   const vos::ORef< Content >& rContent,
+					   sal_Int32 nOpenMode )
+	: m_xContent( rContent ), m_xSMgr( rxSMgr ),
+//	  m_aFolder( rxSMgr, rContent->getIdentifier()->getContentIdentifier() ),
+	  m_nOpenMode( nOpenMode ), m_bCountFinal( sal_False ) {}
+	~DataSupplier_Impl();
+};
+
+//=========================================================================
+DataSupplier_Impl::~DataSupplier_Impl()
+{
+	ResultList::const_iterator it  = m_aResults.begin();
+	ResultList::const_iterator end = m_aResults.end();
+
+	while ( it != end )
+	{
+		delete (*it);
+		it++;
+	}
+}
+
+}
+
+//=========================================================================
+//=========================================================================
+//
+// DataSupplier Implementation.
+//
+//=========================================================================
+//=========================================================================
+
+DataSupplier::DataSupplier( const Reference<XMultiServiceFactory >& rxSMgr,
+						   const vos::ORef< ::odma::Content >& rContent,
+							sal_Int32 nOpenMode )
+: m_pImpl( new DataSupplier_Impl( rxSMgr, rContent, nOpenMode ) )
+{
+}
+
+//=========================================================================
+// virtual
+DataSupplier::~DataSupplier()
+{
+	delete m_pImpl;
+}
+
+//=========================================================================
+// virtual
+::rtl::OUString DataSupplier::queryContentIdentifierString( sal_uInt32 nIndex )
+{
+	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
+
+	if ( nIndex < m_pImpl->m_aResults.size() )
+	{
+		::rtl::OUString aId = m_pImpl->m_aResults[ nIndex ]->aId;
+		if ( aId.getLength() )
+		{
+			// Already cached.
+			return aId;
+		}
+	}
+
+	if ( getResult( nIndex ) )
+	{
+		::rtl::OUString aId
+			= m_pImpl->m_xContent->getIdentifier()->getContentIdentifier();
+
+		aId += m_pImpl->m_aResults[ nIndex ]->rData->m_sTitle;
+
+		m_pImpl->m_aResults[ nIndex ]->aId = aId;
+		return aId;
+	}
+	return ::rtl::OUString();
+}
+
+//=========================================================================
+// virtual
+Reference< XContentIdentifier > DataSupplier::queryContentIdentifier(
+														sal_uInt32 nIndex )
+{
+	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
+
+	if ( nIndex < m_pImpl->m_aResults.size() )
+	{
+		Reference< XContentIdentifier > xId
+								= m_pImpl->m_aResults[ nIndex ]->xId;
+		if ( xId.is() )
+		{
+			// Already cached.
+			return xId;
+		}
+	}
+
+	::rtl::OUString aId = queryContentIdentifierString( nIndex );
+	if ( aId.getLength() )
+	{
+		Reference< XContentIdentifier > xId = new ucb::ContentIdentifier( aId );
+		m_pImpl->m_aResults[ nIndex ]->xId = xId;
+		return xId;
+	}
+	return Reference< XContentIdentifier >();
+}
+
+//=========================================================================
+// virtual
+Reference< XContent > DataSupplier::queryContent( sal_uInt32 nIndex )
+{
+	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
+
+	if ( nIndex < m_pImpl->m_aResults.size() )
+	{
+		Reference< XContent > xContent
+								= m_pImpl->m_aResults[ nIndex ]->xContent;
+		if ( xContent.is() )
+		{
+			// Already cached.
+			return xContent;
+		}
+	}
+
+	Reference< XContentIdentifier > xId = queryContentIdentifier( nIndex );
+	if ( xId.is() )
+	{
+		try
+		{
+			Reference< XContent > xContent
+				= m_pImpl->m_xContent->getProvider()->queryContent( xId );
+			m_pImpl->m_aResults[ nIndex ]->xContent = xContent;
+			return xContent;
+
+		}
+		catch ( IllegalIdentifierException& )
+		{
+		}
+	}
+	return Reference< XContent >();
+}
+
+//=========================================================================
+// virtual
+sal_Bool DataSupplier::getResult( sal_uInt32 nIndex )
+{
+	osl::ClearableGuard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
+
+	if ( m_pImpl->m_aResults.size() > nIndex )
+	{
+		// Result already present.
+		return sal_True;
+	}
+
+	// Result not (yet) present.
+
+	if ( m_pImpl->m_bCountFinal )
+		return sal_False;
+
+	// Try to obtain result...
+
+	sal_uInt32 nOldCount = m_pImpl->m_aResults.size();
+	sal_Bool bFound = sal_False;
+	sal_uInt32 nPos = nOldCount;
+
+	// @@@ Obtain data and put it into result list...
+/*
+	while ( m_pImpl->m_aFolder.next( m_pImpl->m_aIterator ) )
+	{
+		m_pImpl->m_aResults.push_back(
+						new ResultListEntry( *m_pImpl->m_aIterator ) );
+
+		if ( nPos == nIndex )
+		{
+			// Result obtained.
+			bFound = sal_True;
+			break;
+		}
+
+		nPos++;
+	}
+*/
+	// now query for all documents in the DMS
+	OSL_ENSURE(ContentProvider::getHandle(),"No Handle!");
+	sal_Char* pQueryId		= new sal_Char[ODM_QUERYID_MAX];
+	sal_Char* lpszDMSList	= new sal_Char[ODM_DMSID_MAX];
+
+	ODMSTATUS odm = NODMGetDMS(ODMA_ODMA_REGNAME, lpszDMSList);
+	lpszDMSList[strlen(lpszDMSList)+1] = '\0';
+
+	::rtl::OString sQuery("SELECT ODM_DOCID, ODM_NAME");
+	
+	DWORD dwFlags = ODM_SPECIFIC;
+	odm = NODMQueryExecute(ContentProvider::getHandle(), sQuery,dwFlags, lpszDMSList, pQueryId );
+	if(odm != ODM_SUCCESS)
+		return sal_False;
+
+	sal_uInt16 nCount		= 10;
+	sal_uInt16 nMaxCount	= 10;
+	sal_Char* lpszDocId		= new sal_Char[ODM_DOCID_MAX * nMaxCount];
+	sal_Char* lpszDocName	= new sal_Char[ODM_NAME_MAX * nMaxCount];
+
+	
+	::rtl::OUString sContentType(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
+	sal_uInt32 nCurrentCount = 0;
+	do
+	{
+		if(nCount >= nMaxCount)
+		{
+			nCount = nMaxCount;
+			odm = NODMQueryGetResults(ContentProvider::getHandle(), pQueryId,lpszDocId, lpszDocName, ODM_NAME_MAX, (WORD*)&nCount);
+			nCurrentCount += nCount;
+		}
+		if(odm == ODM_SUCCESS && nIndex < nCurrentCount)
+		{
+			bFound = sal_True;
+			for(sal_uInt16 i = 0; i < nCount; ++i)
+			{
+				::vos::ORef<ContentProperties> rProps = new ContentProperties();
+				rProps->m_sDocumentId	= ::rtl::OString(&lpszDocId[ODM_DOCID_MAX*i]);
+				rProps->m_sContentType	= sContentType;
+				m_pImpl->m_xContent->getContentProvider()->append(rProps);
+				m_pImpl->m_aResults.push_back( new ResultListEntry(rProps));
+			}
+		}
+	}
+	while(nCount > nMaxCount);
+	
+
+	// now close the query
+	odm = NODMQueryClose(ContentProvider::getHandle(), pQueryId);
+
+	delete lpszDMSList;
+	delete pQueryId;
+	delete lpszDocId;
+	delete lpszDocName;
+
+	if ( !bFound )
+		m_pImpl->m_bCountFinal = sal_True;
+
+	vos::ORef< ResultSet > xResultSet = getResultSet();
+	if ( xResultSet.isValid() )
+	{
+		// Callbacks follow!
+		aGuard.clear();
+
+		if ( nOldCount < m_pImpl->m_aResults.size() )
+			xResultSet->rowCountChanged(
+									nOldCount, m_pImpl->m_aResults.size() );
+
+		if ( m_pImpl->m_bCountFinal )
+			xResultSet->rowCountFinal();
+	}
+
+	return bFound;
+}
+
+//=========================================================================
+// virtual
+sal_uInt32 DataSupplier::totalCount()
+{
+	osl::ClearableGuard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
+
+	if ( m_pImpl->m_bCountFinal )
+		return m_pImpl->m_aResults.size();
+
+	sal_uInt32 nOldCount = m_pImpl->m_aResults.size();
+
+	// @@@ Obtain data and put it into result list...
+/*
+	while ( m_pImpl->m_aFolder.next( m_pImpl->m_aIterator ) )
+		m_pImpl->m_aResults.push_back(
+						new ResultListEntry( *m_pImpl->m_aIterator ) );
+*/
+	m_pImpl->m_bCountFinal = sal_True;
+
+	vos::ORef< ResultSet > xResultSet = getResultSet();
+	if ( xResultSet.isValid() )
+	{
+		// Callbacks follow!
+		aGuard.clear();
+
+		if ( nOldCount < m_pImpl->m_aResults.size() )
+			xResultSet->rowCountChanged(
+									nOldCount, m_pImpl->m_aResults.size() );
+
+		xResultSet->rowCountFinal();
+	}
+
+	return m_pImpl->m_aResults.size();
+}
+
+//=========================================================================
+// virtual
+sal_uInt32 DataSupplier::currentCount()
+{
+	return m_pImpl->m_aResults.size();
+}
+
+//=========================================================================
+// virtual
+sal_Bool DataSupplier::isCountFinal()
+{
+	return m_pImpl->m_bCountFinal;
+}
+
+//=========================================================================
+// virtual
+Reference< XRow > DataSupplier::queryPropertyValues( sal_uInt32 nIndex  )
+{
+	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
+
+	if ( nIndex < m_pImpl->m_aResults.size() )
+	{
+		Reference< XRow > xRow = m_pImpl->m_aResults[ nIndex ]->xRow;
+		if ( xRow.is() )
+		{
+			// Already cached.
+			return xRow;
+		}
+	}
+
+	if ( getResult( nIndex ) )
+	{
+		Reference< XRow > xRow = Content::getPropertyValues(
+									m_pImpl->m_xSMgr,
+									getResultSet()->getProperties(),
+									m_pImpl->m_aResults[ nIndex ]->rData,
+									m_pImpl->m_xContent->getProvider(),
+									queryContentIdentifierString( nIndex ) );
+		m_pImpl->m_aResults[ nIndex ]->xRow = xRow;
+		return xRow;
+	}
+
+	return Reference< XRow >();
+}
+
+//=========================================================================
+// virtual
+void DataSupplier::releasePropertyValues( sal_uInt32 nIndex )
+{
+	osl::Guard< osl::Mutex > aGuard( m_pImpl->m_aMutex );
+
+	if ( nIndex < m_pImpl->m_aResults.size() )
+		m_pImpl->m_aResults[ nIndex ]->xRow = Reference< XRow >();
+}
+
+//=========================================================================
+// virtual
+void DataSupplier::close()
+{
+}
+
+//=========================================================================
+// virtual
+void DataSupplier::validate()
+	throw( ResultSetException )
+{
+}
diff --new-file -r -u /tmp/nothing/odma_datasupplier.hxx ucb/source/ucp/odma/odma_datasupplier.hxx
--- /tmp/nothing/odma_datasupplier.hxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_datasupplier.hxx	2003-08-25 14:00:54.000000000 +0100
@@ -0,1 +1,111 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef ODMA_DATASUPPLIER_HXX
+#define ODMA_DATASUPPLIER_HXX
+
+#ifndef _UCBHELPER_RESULTSET_HXX
+#include <ucbhelper/resultset.hxx>
+#endif
+
+namespace odma {
+
+struct DataSupplier_Impl;
+class Content;
+
+class DataSupplier : public ucb::ResultSetDataSupplier
+{
+	DataSupplier_Impl* m_pImpl;
+
+public:
+	DataSupplier( const com::sun::star::uno::Reference<
+				  	com::sun::star::lang::XMultiServiceFactory >& rxSMgr,
+				  const vos::ORef< Content >& rContent,
+				  sal_Int32 nOpenMode );
+	virtual ~DataSupplier();
+
+	virtual rtl::OUString queryContentIdentifierString( sal_uInt32 nIndex );
+	virtual com::sun::star::uno::Reference<
+				com::sun::star::ucb::XContentIdentifier >
+	queryContentIdentifier( sal_uInt32 nIndex );
+	virtual com::sun::star::uno::Reference< com::sun::star::ucb::XContent >
+	queryContent( sal_uInt32 nIndex );
+
+	virtual sal_Bool getResult( sal_uInt32 nIndex );
+
+	virtual sal_uInt32 totalCount();
+	virtual sal_uInt32 currentCount();
+	virtual sal_Bool isCountFinal();
+
+	virtual com::sun::star::uno::Reference< com::sun::star::sdbc::XRow >
+	queryPropertyValues( sal_uInt32 nIndex  );
+	virtual void releasePropertyValues( sal_uInt32 nIndex );
+
+	virtual void close();
+
+	virtual void validate()
+		throw( com::sun::star::ucb::ResultSetException );
+};
+
+}
+
+#endif
--- /tmp/nothing/odma_inputstream.cxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_inputstream.cxx	2003-10-06 16:47:43.000000000 +0100
@@ -0,0 +1,336 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the License); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an AS IS basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef ODMA_INPUTSTREAM_HXX
+#include "odma_inputstream.hxx"
+#endif
+#ifndef _COM_SUN_STAR_IO_IOEXCEPTION_HPP_
+#include "com/sun/star/io/IOException.hpp"
+#endif
+#ifndef _COM_SUN_STAR_UCB_OPENCOMMANDARGUMENT2_HPP_
+#include <com/sun/star/ucb/OpenCommandArgument2.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UCB_OPENMODE_HPP_
+#include <com/sun/star/ucb/OpenMode.hpp>
+#endif
+#ifndef _UCBHELPER_CONTENT_HXX 
+#include <ucbhelper/content.hxx>
+#endif
+#ifndef _COM_SUN_STAR_IO_XACTIVEDATASTREAMER_HPP_
+#include <com/sun/star/io/XActiveDataStreamer.hpp>
+#endif
+#ifndef _CPPUHELPER_IMPLBASE1_HXX_
+#include <cppuhelper/implbase1.hxx>
+#endif
+#ifndef ODMA_CONTENTPROPS_HXX
+#include "odma_contentprops.hxx"
+#endif
+#ifndef ODMA_PROVIDER_HXX
+#include "odma_provider.hxx"
+#endif
+
+using namespace odma;
+using namespace com::sun::star;
+
+class OActiveDataStreamer : public ::cppu::WeakImplHelper1< ::com::sun::star::io::XActiveDataStreamer>
+{
+	::com::sun::star::uno::Reference< ::com::sun::star::io::XStream > m_xStream;
+public:
+	OActiveDataStreamer(){}
+	virtual void SAL_CALL setStream( const ::com::sun::star::uno::Reference< ::com::sun::star::io::XStream >& _rStream ) throw (::com::sun::star::uno::RuntimeException)
+	{
+		m_xStream = _rStream;
+	}
+    virtual ::com::sun::star::uno::Reference< ::com::sun::star::io::XStream > SAL_CALL getStream(  ) throw (::com::sun::star::uno::RuntimeException)
+	{
+		return m_xStream;
+	}
+};
+// -----------------------------------------------------------------------------
+OOdmaStream::OOdmaStream(::ucb::Content* _pContent,
+						 ContentProvider* _pProvider,
+						 const ::vos::ORef<ContentProperties>& _rProp)
+ :m_pContent(_pContent)
+ ,m_bInputStreamCalled(sal_False)
+ ,m_bOutputStreamCalled(sal_False)
+ ,m_bModified(sal_False)
+ ,m_pProvider(_pProvider)
+ ,m_aProp(_rProp)
+{
+}
+// -----------------------------------------------------------------------------
+OOdmaStream::~OOdmaStream()
+{
+    try
+    {
+        closeStream();
+		delete m_pContent;
+    }
+    catch (io::IOException const &)
+    {
+        OSL_ENSURE(false, "unexpected situation");
+    }
+    catch (uno::RuntimeException const &)
+    {
+        OSL_ENSURE(false, "unexpected situation");
+    }
+}
+// -----------------------------------------------------------------------------
+uno::Reference< io::XInputStream > SAL_CALL OOdmaStream::getInputStream(  ) throw( uno::RuntimeException)
+{
+	{
+		osl::MutexGuard aGuard( m_aMutex );
+		m_bInputStreamCalled = sal_True;
+	}
+	return uno::Reference< io::XInputStream >( this );
+}
+// -----------------------------------------------------------------------------
+uno::Reference< io::XOutputStream > SAL_CALL OOdmaStream::getOutputStream(  ) throw( uno::RuntimeException )
+{
+	{
+		osl::MutexGuard aGuard( m_aMutex );
+		m_bOutputStreamCalled = sal_True;
+	}
+	return uno::Reference< io::XOutputStream >( this );
+}
+// -----------------------------------------------------------------------------
+sal_Int32 SAL_CALL OOdmaStream::readBytes( uno::Sequence< sal_Int8 >& aData, sal_Int32 nBytesToRead ) 
+	throw( io::NotConnectedException,
+		   io::BufferSizeExceededException,
+		   io::IOException,
+		   uno::RuntimeException)
+{
+	ensureInputStream();
+	
+	return m_xInput->readBytes(aData,nBytesToRead);
+}
+// -----------------------------------------------------------------------------
+sal_Int32 SAL_CALL OOdmaStream::readSomeBytes( uno::Sequence< sal_Int8 >& aData,sal_Int32 nMaxBytesToRead )
+	throw( io::NotConnectedException,
+		   io::BufferSizeExceededException,
+		   io::IOException,
+		   uno::RuntimeException)
+{
+	return readBytes( aData,nMaxBytesToRead );
+}
+// -----------------------------------------------------------------------------
+void SAL_CALL OOdmaStream::skipBytes( sal_Int32 nBytesToSkip )
+	throw( io::NotConnectedException,
+		   io::BufferSizeExceededException,
+		   io::IOException,
+		   uno::RuntimeException )
+{
+	ensureInputStream();
+	m_xInput->skipBytes(nBytesToSkip );
+}
+// -----------------------------------------------------------------------------
+sal_Int32 SAL_CALL OOdmaStream::available()
+	throw( io::NotConnectedException,
+		   io::IOException,
+		   uno::RuntimeException)
+{
+	ensureInputStream();
+	return m_xInput->available();
+}
+// -----------------------------------------------------------------------------
+void SAL_CALL OOdmaStream::writeBytes( const uno::Sequence< sal_Int8 >& aData )
+	throw( io::NotConnectedException,
+		   io::BufferSizeExceededException,
+		   io::IOException,
+		   uno::RuntimeException)
+{
+	ensureOutputStream();
+	m_xOutput->writeBytes(aData);
+	m_bModified = sal_True;
+}
+// -----------------------------------------------------------------------------
+void SAL_CALL OOdmaStream::closeStream() throw( io::NotConnectedException,io::IOException,uno::RuntimeException )
+{
+	if( m_xInput.is() )
+	{
+		m_xInput->closeInput();
+		m_xInput		= NULL;
+		m_xInputSeek	= NULL;
+	}
+	if(m_xOutput.is())
+	{
+		m_xOutput->closeOutput();
+		m_xOutput		= NULL;
+		m_xTruncate		= NULL;
+		if(m_bModified)
+			m_pProvider->saveDocument(m_aProp->m_sDocumentId);
+	}
+}
+// -----------------------------------------------------------------------------
+void SAL_CALL OOdmaStream::closeInput()
+	throw( io::NotConnectedException,
+		   io::IOException,
+		   uno::RuntimeException )
+{
+	osl::MutexGuard aGuard( m_aMutex );
+	m_bInputStreamCalled = sal_False;
+	
+	if( ! m_bOutputStreamCalled )
+		closeStream();
+}
+// -----------------------------------------------------------------------------
+void SAL_CALL OOdmaStream::closeOutput()
+	throw( io::NotConnectedException,
+		   io::IOException,
+		   uno::RuntimeException )
+{
+	osl::MutexGuard aGuard( m_aMutex );
+	m_bOutputStreamCalled = sal_False;
+	
+	if( ! m_bInputStreamCalled )
+		closeStream();
+}
+// -----------------------------------------------------------------------------
+void SAL_CALL OOdmaStream::flush()
+	throw( io::NotConnectedException,
+		   io::BufferSizeExceededException,
+		   io::IOException,
+		   uno::RuntimeException )
+{
+	ensureOutputStream();
+	m_xOutput->flush();
+}
+// -----------------------------------------------------------------------------
+void OOdmaStream::ensureInputStream() throw( io::IOException )
+{
+	try
+	{
+		if(!m_xInput.is())
+		{
+			m_xInput = m_pContent->openStream();
+			m_xInputSeek = uno::Reference< io::XSeekable>(m_xInput,uno::UNO_QUERY);
+		}
+	}
+	catch(const uno::Exception&)
+	{
+	}
+	if(!m_xInput.is())
+		throw io::IOException();
+}
+// -----------------------------------------------------------------------------
+void OOdmaStream::ensureOutputStream() throw( io::IOException )
+{
+	try
+	{
+		if(!m_xOutput.is())
+		{
+			::com::sun::star::ucb::OpenCommandArgument2 aCommand;
+			aCommand.Mode = ::com::sun::star::ucb::OpenMode::DOCUMENT;
+			uno::Reference< io::XActiveDataStreamer > xActiveStreamer = new OActiveDataStreamer();
+			aCommand.Sink = xActiveStreamer;
+			m_pContent->executeCommand(::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("open")),uno::makeAny(aCommand));
+			if(xActiveStreamer.is())
+			{
+				uno::Reference< io::XStream> xStream = xActiveStreamer->getStream();
+				if(xStream.is())
+					m_xOutput = xStream->getOutputStream();
+			}
+		}
+	}
+	catch(const uno::Exception&)
+	{
+	}
+	if(!m_xOutput.is())
+		throw io::IOException();
+	m_xTruncate = uno::Reference< io::XTruncate>(m_xOutput,uno::UNO_QUERY);
+}
+// -----------------------------------------------------------------------------
+// XTruncate
+void SAL_CALL OOdmaStream::truncate( void )
+	throw( com::sun::star::io::IOException,
+		   com::sun::star::uno::RuntimeException )
+{
+	if(m_xTruncate.is())
+		m_xTruncate->truncate();
+}
+// -----------------------------------------------------------------------------
+// XSeekable
+void SAL_CALL OOdmaStream::seek(sal_Int64 location )
+	throw( com::sun::star::lang::IllegalArgumentException,
+		   com::sun::star::io::IOException,
+		   com::sun::star::uno::RuntimeException )
+{
+	ensureInputStream();
+	if(m_xInputSeek.is())
+		m_xInputSeek->seek(location);
+}
+// -----------------------------------------------------------------------------
+sal_Int64 SAL_CALL OOdmaStream::getPosition()
+	throw( com::sun::star::io::IOException,
+		   com::sun::star::uno::RuntimeException )
+{
+	ensureInputStream();
+	return m_xInputSeek.is() ? m_xInputSeek->getPosition() : sal_Int64(0);
+}
+// -----------------------------------------------------------------------------
+sal_Int64 SAL_CALL OOdmaStream::getLength()
+	throw( com::sun::star::io::IOException,
+		   com::sun::star::uno::RuntimeException )
+{
+	ensureInputStream();
+	return m_xInputSeek.is() ? m_xInputSeek->getLength() : sal_Int64(0);
+}
+// -----------------------------------------------------------------------------
diff --new-file -r -u /tmp/nothing/odma_inputstream.hxx ucb/source/ucp/odma/odma_inputstream.hxx
--- /tmp/nothing/odma_inputstream.hxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_inputstream.hxx	2003-08-25 14:01:10.000000000 +0100
@@ -0,0 +1,187 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the License); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an AS IS basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef ODMA_INPUTSTREAM_HXX
+#define ODMA_INPUTSTREAM_HXX
+
+#ifndef _OSL_MUTEX_HXX_
+#include <osl/mutex.hxx>
+#endif
+#ifndef _COM_SUN_STAR_IO_XINPUTSTREAM_HPP_
+#include <com/sun/star/io/XInputStream.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XSTREAM_HPP_
+#include <com/sun/star/io/XStream.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XOUTPUTSTREAM_HPP_
+#include <com/sun/star/io/XOutputStream.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XTRUNCATE_HPP_
+#include <com/sun/star/io/XTruncate.hpp>
+#endif
+#ifndef _COM_SUN_STAR_IO_XSEEKABLE_HPP_
+#include <com/sun/star/io/XSeekable.hpp>
+#endif
+#ifndef _CPPUHELPER_IMPLBASE5_HXX_
+#include <cppuhelper/implbase5.hxx>
+#endif
+#ifndef _VOS_REF_HXX_ 
+#include <vos/ref.hxx>
+#endif
+
+namespace ucb
+{
+	class Content;
+}
+namespace odma
+{
+	typedef ::cppu::WeakImplHelper5<	::com::sun::star::io::XInputStream,
+										::com::sun::star::io::XStream,
+										::com::sun::star::io::XTruncate,
+										::com::sun::star::io::XSeekable,
+										::com::sun::star::io::XOutputStream> OOdmaStreamBase;
+
+	class ContentProvider;
+	class ContentProperties;
+	class OOdmaStream : public OOdmaStreamBase
+	{
+		::osl::Mutex	m_aMutex;
+		::com::sun::star::uno::Reference< ::com::sun::star::io::XOutputStream>	m_xOutput;
+		::com::sun::star::uno::Reference< ::com::sun::star::io::XTruncate>		m_xTruncate;
+		::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream>	m_xInput;
+		::com::sun::star::uno::Reference< ::com::sun::star::io::XSeekable>		m_xInputSeek;
+
+		::vos::ORef<ContentProperties>	m_aProp;
+		::ucb::Content*					m_pContent;
+		ContentProvider*				m_pProvider;
+		sal_Bool						m_bInputStreamCalled;
+		sal_Bool						m_bOutputStreamCalled;
+		sal_Bool						m_bModified;
+
+		void ensureInputStream()  throw( ::com::sun::star::io::IOException );
+		void ensureOutputStream()  throw( ::com::sun::star::io::IOException );
+		void SAL_CALL closeStream() throw(	::com::sun::star::io::NotConnectedException,
+											::com::sun::star::io::IOException,
+											::com::sun::star::uno::RuntimeException );
+	public:
+		OOdmaStream(::ucb::Content* _pContent,
+					ContentProvider* _pProvider,
+					const ::vos::ORef<ContentProperties>& _rProp);
+		virtual ~OOdmaStream();
+		// com::sun::star::io::XInputStream
+		virtual sal_Int32 SAL_CALL readBytes( ::com::sun::star::uno::Sequence<sal_Int8>& aData, sal_Int32 nBytesToRead )
+			throw(::com::sun::star::io::NotConnectedException, ::com::sun::star::io::BufferSizeExceededException,
+				  ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
+
+		virtual sal_Int32 SAL_CALL readSomeBytes( ::com::sun::star::uno::Sequence<sal_Int8>& aData, sal_Int32 nMaxBytesToRead )
+			throw(::com::sun::star::io::NotConnectedException, ::com::sun::star::io::BufferSizeExceededException,
+				  ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
+
+		virtual void SAL_CALL skipBytes( sal_Int32 nBytesToSkip )
+			throw(::com::sun::star::io::NotConnectedException, ::com::sun::star::io::BufferSizeExceededException,
+				  ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
+
+		virtual sal_Int32 SAL_CALL available(  )
+			throw(::com::sun::star::io::NotConnectedException, ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
+
+		virtual void SAL_CALL closeInput(  )
+			throw(::com::sun::star::io::NotConnectedException, ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
+
+		// com::sun::star::io::XStream
+		virtual com::sun::star::uno::Reference< com::sun::star::io::XInputStream > SAL_CALL getInputStream(  ) throw( com::sun::star::uno::RuntimeException );
+		virtual com::sun::star::uno::Reference< com::sun::star::io::XOutputStream > SAL_CALL getOutputStream(  ) throw( com::sun::star::uno::RuntimeException );
+
+		// com::sun::star::io::XOutputStream
+		void SAL_CALL writeBytes( const com::sun::star::uno::Sequence< sal_Int8 >& aData )
+					throw( com::sun::star::io::NotConnectedException,
+						   com::sun::star::io::BufferSizeExceededException,
+						   com::sun::star::io::IOException,
+						   com::sun::star::uno::RuntimeException);
+
+		void SAL_CALL flush()
+					throw( com::sun::star::io::NotConnectedException,
+						   com::sun::star::io::BufferSizeExceededException,
+						   com::sun::star::io::IOException,
+						   com::sun::star::uno::RuntimeException);
+        void SAL_CALL closeOutput()
+					throw( com::sun::star::io::NotConnectedException,
+						   com::sun::star::io::IOException,
+						   com::sun::star::uno::RuntimeException );
+		// XTruncate
+		virtual void SAL_CALL truncate( void )
+			throw( com::sun::star::io::IOException,
+				   com::sun::star::uno::RuntimeException );
+		// XSeekable
+		void SAL_CALL seek(sal_Int64 location )
+			throw( com::sun::star::lang::IllegalArgumentException,
+				   com::sun::star::io::IOException,
+				   com::sun::star::uno::RuntimeException );
+        
+		sal_Int64 SAL_CALL getPosition()
+			throw( com::sun::star::io::IOException,
+				   com::sun::star::uno::RuntimeException );
+        
+		sal_Int64 SAL_CALL getLength()
+			throw( com::sun::star::io::IOException,
+				   com::sun::star::uno::RuntimeException );
+	};
+}
+#endif // ODMA_INPUTSTREAM_HXX
diff --new-file -r -u /tmp/nothing/odma_lib.cxx ucb/source/ucp/odma/odma_lib.cxx
--- /tmp/nothing/odma_lib.cxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_lib.cxx	2003-08-25 14:01:18.000000000 +0100
@@ -0,0 +1,170 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the License); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an AS IS basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+//#ifndef _OSL_PROCESS_H_ 
+//#include <osl/process.h>
+//#endif
+#ifndef _OSL_MODULE_H_
+#include <osl/module.h>
+#endif
+#ifndef _RTL_USTRING_HXX_ 
+#include <rtl/ustring.hxx>
+#endif
+#ifndef ODMA_LIB_HXX
+#include "odma_lib.hxx"
+#endif
+
+
+namespace odma
+{
+
+	TODMRegisterApp			pODMRegisterApp;
+	TODMUnRegisterApp		pODMUnRegisterApp;
+	TODMSelectDoc			pODMSelectDoc;
+	TODMOpenDoc				pODMOpenDoc;
+	TODMSaveDoc				pODMSaveDoc;
+	TODMCloseDoc			pODMCloseDoc;
+	TODMNewDoc				pODMNewDoc;
+	TODMSaveAs				pODMSaveAs;
+	TODMActivate			pODMActivate;
+	TODMGetDocInfo			pODMGetDocInfo;
+	TODMSetDocInfo			pODMSetDocInfo;
+	TODMGetDMSInfo			pODMGetDMSInfo;
+	TODMGetDMSCount			pODMGetDMSCount;
+	TODMGetDMSList			pODMGetDMSList;
+	TODMGetDMS				pODMGetDMS;
+	TODMSetDMS				pODMSetDMS;
+	TODMQueryExecute		pODMQueryExecute;
+	TODMQueryGetResults		pODMQueryGetResults;
+	TODMQueryClose			pODMQueryClose;
+	TODMCloseDocEx			pODMCloseDocEx;
+	TODMSaveAsEx			pODMSaveAsEx;
+	TODMSaveDocEx			pODMSaveDocEx;
+	TODMSelectDocEx			pODMSelectDocEx;
+	TODMQueryCapability		pODMQueryCapability;
+	TODMSetDocEvent			pODMSetDocEvent;
+	TODMGetAlternateContent pODMGetAlternateContent;
+	TODMSetAlternateContent pODMSetAlternateContent;
+	TODMGetDocRelation		pODMGetDocRelation;
+	TODMSetDocRelation		pODMSetDocRelation;
+
+	sal_Bool LoadFunctions(oslModule _pODMA);
+
+	sal_Bool LoadLibrary()
+	{
+		static sal_Bool bLoaded = sal_False;
+		static oslModule pODMA = NULL;
+		
+		if (bLoaded) 
+			return sal_True;
+		::rtl::OUString sPath;
+	#ifdef WIN
+		sPath = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMA.DLL"));
+		
+	#endif
+	#ifdef WNT
+		sPath = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMA32.DLL"));
+	#endif
+	#ifdef UNX
+		sPath = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("libodma.so"));
+	#endif
+
+		pODMA = osl_loadModule( sPath.pData,SAL_LOADMODULE_NOW );
+		if( !pODMA)
+			return sal_False;
+
+		return bLoaded = LoadFunctions(pODMA);
+	}
+	// -------------------------------------------------------------------------
+
+	sal_Bool LoadFunctions(oslModule pODMA)
+	{
+		if ( ( pODMRegisterApp = (TODMRegisterApp)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMRegisterApp")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMUnRegisterApp = (TODMUnRegisterApp)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMUnRegisterApp")).pData)) == NULL ) return sal_False;		
+		if ( ( pODMSelectDoc = (TODMSelectDoc)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMSelectDoc")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMOpenDoc = (TODMOpenDoc)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMOpenDoc")).pData)) == NULL ) return sal_False;				
+		if ( ( pODMSaveDoc = (TODMSaveDoc)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMSaveDoc")).pData)) == NULL ) return sal_False;				
+		if ( ( pODMCloseDoc = (TODMCloseDoc)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMCloseDoc")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMNewDoc = (TODMNewDoc)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMNewDoc")).pData)) == NULL ) return sal_False;				
+		if ( ( pODMSaveAs = (TODMSaveAs)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMSaveAs")).pData)) == NULL ) return sal_False;				
+		if ( ( pODMActivate = (TODMActivate)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMActivate")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMGetDocInfo = (TODMGetDocInfo)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMGetDocInfo")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMSetDocInfo = (TODMSetDocInfo)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMSetDocInfo")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMGetDMSInfo = (TODMGetDMSInfo)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMGetDMSInfo")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMGetDMSCount = (TODMGetDMSCount)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMGetDMSCount")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMGetDMSList = (TODMGetDMSList)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMGetDMSList")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMGetDMS = (TODMGetDMS)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMGetDMS")).pData)) == NULL ) return sal_False;				
+		if ( ( pODMSetDMS = (TODMSetDMS)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMSetDMS")).pData)) == NULL ) return sal_False;				
+		if ( ( pODMQueryExecute = (TODMQueryExecute)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMQueryExecute")).pData)) == NULL ) return sal_False;		
+		if ( ( pODMQueryGetResults = (TODMQueryGetResults)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMQueryGetResults")).pData)) == NULL ) return sal_False;		
+		if ( ( pODMQueryClose = (TODMQueryClose)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMQueryClose")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMCloseDocEx = (TODMCloseDocEx)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMCloseDocEx")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMSaveAsEx = (TODMSaveAsEx)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMSaveAsEx")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMSaveDocEx = (TODMSaveDocEx)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMSaveDocEx")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMSelectDocEx = (TODMSelectDocEx)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMSelectDocEx")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMQueryCapability = (TODMQueryCapability)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMQueryCapability")).pData)) == NULL ) return sal_False;		
+		if ( ( pODMSetDocEvent = (TODMSetDocEvent)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMSetDocEvent")).pData)) == NULL ) return sal_False;			
+		if ( ( pODMGetAlternateContent = (TODMGetAlternateContent)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMGetAlternateContent")).pData)) == NULL ) return sal_False; 
+		if ( ( pODMSetAlternateContent = (TODMSetAlternateContent)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMSetAlternateContent")).pData)) == NULL ) return sal_False; 
+		if ( ( pODMGetDocRelation = (TODMGetDocRelation)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMGetDocRelation")).pData)) == NULL ) return sal_False;		
+		if ( ( pODMSetDocRelation = (TODMSetDocRelation)osl_getSymbol(pODMA,::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("ODMSetDocRelation")).pData)) == NULL ) return sal_False;		
+		return sal_True;
+	}
+}
diff --new-file -r -u /tmp/nothing/odma_lib.hxx ucb/source/ucp/odma/odma_lib.hxx
--- /tmp/nothing/odma_lib.hxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_lib.hxx	2003-08-25 14:01:26.000000000 +0100
@@ -0,0 +1,308 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the License); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an AS IS basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef ODMA_LIB_HXX
+#define ODMA_LIB_HXX
+
+typedef void	            *LPVOID;
+typedef char				*LPSTR, 
+							*PSTR;
+typedef const char			*LPCSTR;
+typedef unsigned long       DWORD;
+typedef unsigned short      WORD;
+typedef unsigned short      *LPWORD;
+typedef DWORD		        *LPDWORD;
+
+#define WINAPI				__stdcall
+#define FAR
+
+#ifndef ODMA_H
+#include "odma.h"
+#endif
+
+namespace odma
+{
+	typedef ODMSTATUS (WINAPI *TODMRegisterApp) (	ODMHANDLE FAR *pOdmHandle, 
+													WORD version,
+													LPSTR lpszAppId, 
+													DWORD dwEnvData, 
+													LPVOID pReserved);
+	
+	typedef void (WINAPI *TODMUnRegisterApp)(ODMHANDLE odmHandle);
+	
+
+	typedef ODMSTATUS (WINAPI *TODMSelectDoc)(		ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													LPDWORD pdwFlags);
+	
+
+	typedef ODMSTATUS (WINAPI *TODMOpenDoc)(		ODMHANDLE odmHandle,
+													DWORD flags,
+													LPSTR lpszDocId, 
+													LPSTR lpszDocLocation);
+
+	typedef ODMSTATUS (WINAPI *TODMSaveDoc)(		ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													LPSTR lpszNewDocId);
+
+	typedef ODMSTATUS (WINAPI *TODMCloseDoc)(		ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													DWORD activeTime, 
+													DWORD pagesPrinted, 
+													LPVOID sessionData, 
+													WORD dataLen);
+
+	typedef ODMSTATUS (WINAPI *TODMNewDoc)(			ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													DWORD dwFlags, 
+													LPSTR lpszFormat, 
+													LPSTR lpszDocLocation);
+
+	typedef ODMSTATUS (WINAPI *TODMSaveAs)(			ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													LPSTR lpszNewDocId, 
+													LPSTR lpszFormat, 
+													ODMSAVEASCALLBACK pcbCallBack,
+													LPVOID pInstanceData);
+
+	typedef ODMSTATUS (WINAPI *TODMActivate)(		ODMHANDLE odmHandle, 
+													WORD action,
+													LPSTR lpszDocId);
+
+	typedef ODMSTATUS (WINAPI *TODMGetDocInfo)(		ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													WORD item, 
+													LPSTR lpszData, 
+													WORD dataLen);
+
+	typedef ODMSTATUS (WINAPI *TODMSetDocInfo)(		ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													WORD item, 
+													LPSTR lpszData);
+
+	typedef ODMSTATUS (WINAPI *TODMGetDMSInfo)(		ODMHANDLE odmHandle, 
+													LPSTR lpszDmsId,
+													LPWORD pwVerNo, 
+													LPDWORD pdwExtensions);
+
+	/* Query Enhancements */
+	typedef WORD (WINAPI *TODMGetDMSCount)();
+
+	typedef WORD (WINAPI *TODMGetDMSList)(			LPSTR buffer, 
+													WORD buffer_size );
+
+	typedef ODMSTATUS (WINAPI *TODMGetDMS)(			LPCSTR lpszAppId, 
+													LPSTR lpszDMSId );
+
+	typedef ODMSTATUS (WINAPI *TODMSetDMS)(			LPCSTR lpszAppId, 
+													LPCSTR lpszDMSId );
+
+	typedef ODMSTATUS (WINAPI *TODMQueryExecute)(	ODMHANDLE odmHandle, 
+													LPCSTR lpszQuery,
+													DWORD flags, 
+													LPCSTR lpszDMSList, 
+													LPSTR queryId );
+
+	typedef ODMSTATUS (WINAPI *TODMQueryGetResults)(ODMHANDLE odmHandle, 
+													LPCSTR queryId,
+													LPSTR lpszDocId, 
+													LPSTR lpszDocName, 
+													WORD docNameLen,
+													WORD *docCount );
+
+	typedef ODMSTATUS (WINAPI *TODMQueryClose)(		ODMHANDLE odmHandle, 
+													LPCSTR queryId );
+
+	/* ODMA 2.0 Enhancements */
+	typedef ODMSTATUS (WINAPI *TODMCloseDocEx)(		ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													LPDWORD pdwFlags, 
+													DWORD activeTime, 
+													DWORD pagesPrinted,
+													LPVOID sessionData, 
+													WORD dataLen);
+
+	typedef ODMSTATUS (WINAPI *TODMSaveAsEx)(		ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													LPSTR lpszNewDocId, 
+													LPSTR lpszFormat, 
+													ODMSAVEASCALLBACK pcbCallBack,
+													LPVOID pInstanceData, 
+													LPDWORD pdwFlags);
+
+	typedef ODMSTATUS (WINAPI *TODMSaveDocEx)(		ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													LPSTR lpszNewDocId,	
+													LPDWORD pdwFlags);
+
+	typedef ODMSTATUS (WINAPI *TODMSelectDocEx)(	ODMHANDLE odmHandle, 
+													LPSTR lpszDocIds,
+													LPWORD pwDocIdsLen, 
+													LPWORD pwDocCount, 
+													LPDWORD pdwFlags,
+													LPSTR lpszFormatFilter);
+
+	typedef ODMSTATUS (WINAPI *TODMQueryCapability)(ODMHANDLE odmHandle, 
+													LPCSTR lpszDmsId,
+													DWORD function, 
+													DWORD item, 
+													DWORD flags);
+
+	typedef ODMSTATUS (WINAPI *TODMSetDocEvent)(	ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													DWORD flags, 
+													DWORD event, 
+													LPVOID lpData, 
+													DWORD dwDataLen,
+													LPSTR lpszComment);
+
+	typedef ODMSTATUS (WINAPI *TODMGetAlternateContent)(ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													LPDWORD pdwFlags, 
+													LPSTR lpszFormat, 
+													LPSTR lpszDocLocation);
+
+	typedef ODMSTATUS (WINAPI *TODMSetAlternateContent)(ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													LPDWORD pdwFlags, 
+													LPSTR lpszFormat, 
+													LPSTR lpszDocLocation);
+
+	typedef ODMSTATUS (WINAPI *TODMGetDocRelation)(	ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													LPDWORD pdwFlags, 
+													LPSTR lpszLinkedId, 
+													LPSTR lpszFormat,
+													LPSTR lpszPreviousId);
+
+	typedef ODMSTATUS (WINAPI *TODMSetDocRelation)(	ODMHANDLE odmHandle, 
+													LPSTR lpszDocId,
+													LPDWORD pdwFlags, 
+													LPSTR lpszLinkedId, 
+													LPSTR lpszFormat,
+													LPSTR lpszPreviousId);
+
+	// now we define some macros
+
+	#define NODMRegisterApp(a,b,c,d,e)			(*(pODMRegisterApp))(a,b,c,d,e)
+	#define NODMUnRegisterApp(a)				(*(pODMUnRegisterApp))(a)
+	#define NODMSelectDoc(a,b,c)				(*(pODMSelectDoc))(a,b,c)
+	#define NODMOpenDoc(a,b,c,d)				(*(pODMOpenDoc))(a,b,c,d)
+	#define NODMSaveDoc(a,b,c)					(*(pODMSaveDoc))(a,b,c)
+	#define NODMCloseDoc(a,b,c,d,e,f)			(*(pODMCloseDoc))(a,b,c,d,e,f)
+	#define NODMNewDoc(a,b,c,d,e)				(*(pODMNewDoc))(a,b,c,d,e)
+	#define NODMSaveAs(a,b,c,d,e,f)				(*(pODMSaveAs))(a,b,c,d,e,f)
+	#define NODMActivate(a,b,c)					(*(pODMActivate))(a,b,c)
+	#define NODMGetDocInfo(a,b,c,d,e)			(*(pODMGetDocInfo))(a,b,c,d,e)
+	#define NODMSetDocInfo(a,b,c,d)				(*(pODMSetDocInfo))(a,b,c,d)
+	#define NODMGetDMSInfo(a,b,c,d)				(*(pODMGetDMSInfo))(a,b,c,d)
+	#define NODMGetDMSCount()					(*(pODMGetDMSCount))()
+	#define NODMGetDMSList(a,b)					(*(pODMGetDMSList))(a,b)
+	#define NODMGetDMS(a,b)						(*(pODMGetDMS))(a,b)
+	#define NODMSetDMS(a,b)						(*(pODMSetDMS))(a,b)
+	#define NODMQueryExecute(a,b,c,d,e)			(*(pODMQueryExecute))(a,b,c,d,e)
+	#define NODMQueryGetResults(a,b,c,d,e,f)	(*(pODMQueryGetResults))(a,b,c,d,e,f)
+	#define NODMQueryClose(a,b)					(*(pODMQueryClose))(a,b)
+	#define NODMCloseDocEx(a,b,c,d,e,f,g)		(*(pODMCloseDocEx))(a,b,c,d,e,f,g)
+	#define NODMSaveAsEx(a,b,c,d,e,f,g)			(*(pODMSaveAsEx))(a,b,c,d,e,f,g)
+	#define NODMSaveDocEx(a,b,c,d)				(*(pODMSaveDocEx))(a,b,c,d)
+	#define NODMSelectDocEx(a,b,c,d,e,f)		(*(pODMSelectDocEx))(a,b,c,d,e,f)
+	#define NODMQueryCapability(a,b,c,d,e)		(*(pODMQueryCapability))(a,b,c,d,e)
+	#define NODMSetDocEvent(a,b,c,d,e,f,g)		(*(pODMSetDocEvent))(a,b,c,d,e,f,g)
+	#define NODMGetAlternateContent(a,b,c,d,e)	(*(pODMGetAlternateContent))(a,b,c,d,e)
+	#define NODMSetAlternateContent(a,b,c,d,e)	(*(pODMSetAlternateContent))(a,b,c,d,e)
+	#define NODMGetDocRelation(a,b,c,d,e,f)		(*(pODMGetDocRelation))(a,b,c,d,e,f)
+	#define NODMSetDocRelation(a,b,c,d,e,f)		(*(pODMSetDocRelation))(a,b,c,d,e,f)
+
+	sal_Bool LoadLibrary();
+
+	extern TODMRegisterApp			pODMRegisterApp;
+	extern TODMUnRegisterApp		pODMUnRegisterApp;
+	extern TODMSelectDoc			pODMSelectDoc;
+	extern TODMOpenDoc				pODMOpenDoc;
+	extern TODMSaveDoc				pODMSaveDoc;
+	extern TODMCloseDoc				pODMCloseDoc;
+	extern TODMNewDoc				pODMNewDoc;
+	extern TODMSaveAs				pODMSaveAs;
+	extern TODMActivate				pODMActivate;
+	extern TODMGetDocInfo			pODMGetDocInfo;
+	extern TODMSetDocInfo			pODMSetDocInfo;
+	extern TODMGetDMSInfo			pODMGetDMSInfo;
+	extern TODMGetDMSCount			pODMGetDMSCount;
+	extern TODMGetDMSList			pODMGetDMSList;
+	extern TODMGetDMS				pODMGetDMS;
+	extern TODMSetDMS				pODMSetDMS;
+	extern TODMQueryExecute			pODMQueryExecute;
+	extern TODMQueryGetResults		pODMQueryGetResults;
+	extern TODMQueryClose			pODMQueryClose;
+	extern TODMCloseDocEx			pODMCloseDocEx;
+	extern TODMSaveAsEx				pODMSaveAsEx;
+	extern TODMSaveDocEx			pODMSaveDocEx;
+	extern TODMSelectDocEx			pODMSelectDocEx;
+	extern TODMQueryCapability		pODMQueryCapability;
+	extern TODMSetDocEvent			pODMSetDocEvent;
+	extern TODMGetAlternateContent	pODMGetAlternateContent;
+	extern TODMSetAlternateContent	pODMSetAlternateContent;
+	extern TODMGetDocRelation		pODMGetDocRelation;
+	extern TODMSetDocRelation		pODMSetDocRelation;
+
+}
+
+#endif // ODMA_LIB_HXX
diff --new-file -r -u /tmp/nothing/odma_main.cxx ucb/source/ucp/odma/odma_main.cxx
--- /tmp/nothing/odma_main.cxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_main.cxx	2003-08-25 14:01:34.000000000 +0100
@@ -0,0 +1,110 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _VOS_PROCESS_HXX_
+#include <vos/process.hxx>
+#endif
+#ifndef _OSL_PROCESS_H_
+#include <osl/process.h>
+#endif
+#ifndef ODMA_PROVIDER_HXX
+#include "odma_provider.hxx"
+#endif
+
+#ifdef WNT
+#define SOFFICE "soffice.exe"
+#else
+#define SOFFICE "soffice"
+#endif
+
+using namespace vos;
+
+/** our main program to convert ODMAIDs to URLs
+*/
+
+#if (defined UNX) || (defined OS2)
+void main( int argc, char * argv[] )
+#else
+void _cdecl main( int argc, char * argv[] )
+#endif
+{
+	static ::rtl::OUString sProcess(RTL_CONSTASCII_USTRINGPARAM(SOFFICE));
+	if(argc > 1) // only chang when argument is docid
+	{
+		::rtl::OUString* pArguments = new ::rtl::OUString[argc-1];
+		for(int i = 1; i < argc;++i)
+		{
+			pArguments[i] = ::rtl::OUString::createFromAscii(argv[1]);
+			if( pArguments[i].matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_ODMAID)))
+			{
+				::rtl::OUString sArgument = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT "/"));
+				sArgument += pArguments[i];
+				pArguments[i] = sArgument;
+			}
+		}
+		{
+			OArgumentList aList(pArguments,argc-1);
+			OProcess aProcess( sProcess );
+			aProcess.execute(OProcess::TOption_Detached,aList);
+		}
+		delete [] pArguments;
+	}
+}
+
diff --new-file -r -u /tmp/nothing/odma_provider.cxx ucb/source/ucp/odma/odma_provider.cxx
--- /tmp/nothing/odma_provider.cxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_provider.cxx	2003-08-25 14:01:43.000000000 +0100
@@ -0,0 +1,651 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+/**************************************************************************
+								TODO
+ **************************************************************************
+
+ *************************************************************************/
+
+#ifndef _VOS_DIAGNOSE_HXX_
+#include <vos/diagnose.hxx>
+#endif
+#ifndef _UCBHELPER_CONTENTIDENTIFIER_HXX
+#include <ucbhelper/contentidentifier.hxx>
+#endif
+#ifndef ODMA_PROVIDER_HXX
+#include "odma_provider.hxx"
+#endif
+#ifndef ODMA_CONTENT_HXX
+#include "odma_content.hxx"
+#endif
+#ifndef ODMA_CONTENTPROPS_HXX
+#include "odma_contentprops.hxx"
+#endif
+#ifndef _COM_SUN_STAR_UTIL_DATE_HPP_
+#include <com/sun/star/util/Date.hpp>
+#endif
+#ifndef _COM_SUN_STAR_UTIL_TIME_HPP_
+#include <com/sun/star/util/Time.hpp>
+#endif
+#ifndef _RTL_URI_HXX_ 
+#include <rtl/uri.hxx>
+#endif
+#include <algorithm>
+#ifndef _OSL_FILE_HXX_ 
+#include <osl/file.hxx>
+#endif
+
+using namespace com::sun;
+using namespace com::sun::star;
+using namespace odma;
+
+//=========================================================================
+//=========================================================================
+//
+// ContentProvider Implementation.
+//
+//=========================================================================
+//=========================================================================
+ODMHANDLE ContentProvider::m_aOdmHandle = NULL;
+
+ContentProvider::ContentProvider(
+                const uno::Reference< lang::XMultiServiceFactory >& rSMgr )
+: ::ucb::ContentProviderImplHelper( rSMgr )
+{
+	
+}
+
+//=========================================================================
+// virtual
+ContentProvider::~ContentProvider()
+{
+	ContentsMap::iterator aIter = m_aContents.begin();
+	for (;aIter != m_aContents.begin() ;++aIter )
+	{
+		if(aIter->second->m_bIsOpen)
+			closeDocument(aIter->first);
+	}
+	if(m_aOdmHandle)
+	{
+		NODMUnRegisterApp(m_aOdmHandle);
+		m_aOdmHandle = NULL;
+	}
+}
+// -----------------------------------------------------------------------------
+ODMHANDLE ContentProvider::getHandle() 
+{ 
+	if(!m_aOdmHandle)
+	{
+		ODMSTATUS odm = NODMRegisterApp(&m_aOdmHandle,ODM_API_VERSION,ODMA_ODMA_REGNAME,NULL,NULL);
+		switch(odm)
+		{
+		case ODM_SUCCESS:
+			break;
+		case ODM_E_NODMS:
+			break;
+		case ODM_E_CANTINIT:
+			break;
+		case ODM_E_VERSION:
+			break;
+		default:
+			break;
+		}
+	}
+	return m_aOdmHandle; 
+}
+// -----------------------------------------------------------------------------
+
+//=========================================================================
+//
+// XInterface methods.
+//
+//=========================================================================
+
+// @@@ Add own interfaces.
+XINTERFACE_IMPL_3( ContentProvider,
+                   lang::XTypeProvider,
+                   lang::XServiceInfo,
+                   star::ucb::XContentProvider );
+
+//=========================================================================
+//
+// XTypeProvider methods.
+//
+//=========================================================================
+
+// @@@ Add own interfaces.
+XTYPEPROVIDER_IMPL_3( ContentProvider,
+                      lang::XTypeProvider,
+                      lang::XServiceInfo,
+                      star::ucb::XContentProvider );
+
+//=========================================================================
+//
+// XServiceInfo methods.
+//
+//=========================================================================
+
+// @@@ Adjust implementation name. Keep the prefix "com.sun.star.comp."!
+// @@@ Adjust service name.
+XSERVICEINFO_IMPL_1( ContentProvider,
+                     rtl::OUString::createFromAscii(
+                            "com.sun.star.comp.odma.ContentProvider" ),
+                     rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_PROVIDER_SERVICE_NAME) ) );
+
+//=========================================================================
+//
+// Service factory implementation.
+//
+//=========================================================================
+
+ONE_INSTANCE_SERVICE_FACTORY_IMPL( ContentProvider );
+
+//=========================================================================
+//
+// XContentProvider methods.
+//
+//=========================================================================
+
+// virtual
+uno::Reference< star::ucb::XContent > SAL_CALL ContentProvider::queryContent(
+        const uno::Reference< star::ucb::XContentIdentifier >& Identifier )
+    throw( star::ucb::IllegalIdentifierException, uno::RuntimeException )
+{
+	// Check URL scheme...
+	if(!getHandle())
+		throw star::ucb::IllegalIdentifierException();
+
+    rtl::OUString aScheme( rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(ODMA_URL_SCHEME) ) );
+	sal_Int32 nIndex = 0;
+	rtl::OUString sOdma = aScheme.getToken(3,'.',nIndex);
+	rtl::OUString sCanonicURL = Identifier->getContentIdentifier();
+	// check if url starts with odma
+    if ( !(Identifier->getContentProviderScheme().equalsIgnoreAsciiCase( aScheme ) || 
+		   Identifier->getContentProviderScheme().equalsIgnoreAsciiCase( sOdma )) )
+        throw star::ucb::IllegalIdentifierException();
+
+	if(!(	sCanonicURL.matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_SCHEME_SHORT ODMA_URL_SHORT)) ||
+			sCanonicURL.matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT))))
+		throw star::ucb::IllegalIdentifierException();
+
+	// @@@ Further id checks may go here...
+#if 0
+	if ( id-check-failes )
+        throw star::ucb::IllegalIdentifierException();
+#endif
+
+	// @@@ Id normalization may go here...
+#if 0
+	// Normalize URL and create new Id.
+    rtl::OUString aCanonicURL = ( Identifier->getContentIdentifier() );
+    uno::Reference< star::ucb::XContentIdentifier > xCanonicId
+        = new ::ucb::ContentIdentifier( m_xSMgr, aCanonicURL );
+#else
+    uno::Reference< star::ucb::XContentIdentifier > xCanonicId = Identifier;
+#endif
+
+	vos::OGuard aGuard( m_aMutex );
+
+	// Check, if a content with given id already exists...
+    uno::Reference< star::ucb::XContent > xContent
+		= queryExistingContent( xCanonicId ).getBodyPtr();
+	if ( xContent.is() )
+		return xContent;
+
+	// @@@ Decision, which content implementation to instanciate may be
+	//     made here ( in case you have different content classes ).
+
+	// Create a new content. Note that the content will insert itself
+	// into providers content list by calling addContent(...) from it's ctor.
+
+	sCanonicURL = convertURL(sCanonicURL);
+	
+	::vos::ORef<ContentProperties> aProp;
+	// first check if we got an ODMA ID from outside
+	if( sCanonicURL.matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_ODMAID)))
+	{// we get an orignal ODMA id so we have to look for the name
+		::rtl::OString sDocId = ::rtl::OUStringToOString(sCanonicURL,RTL_TEXTENCODING_MS_1252);
+		sal_Char* lpszDocName = new sal_Char[ODM_NAME_MAX];
+		
+		ODMSTATUS odm = NODMGetDocInfo(	getHandle(),
+										const_cast<sal_Char*>(sDocId.getStr()),
+										ODM_NAME,
+										lpszDocName,
+										ODM_NAME_MAX
+									);
+		if(odm == ODM_SUCCESS)
+		{
+			aProp = new ContentProperties();
+			aProp->m_sDocumentName = ::rtl::OStringToOUString(rtl::OString(lpszDocName),RTL_TEXTENCODING_ASCII_US);
+			aProp->m_sDocumentId   = sDocId;
+			aProp->m_sContentType  = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
+			append(aProp);
+		}
+		delete lpszDocName;
+	}
+	else // we got an already fetched name here so look for it
+	{
+		// we have a valid document name 
+		aProp = getContentPropertyWithTitle(sCanonicURL);
+		if(!aProp.isValid())
+			aProp = getContentPropertyWithSavedAsName(sCanonicURL);
+		if(!aProp.isValid())
+		{
+			if(sCanonicURL.equalsIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM("/")))
+			{ // found only the scheme
+				aProp = new ContentProperties();
+				aProp->m_sDocumentId = "/";
+				aProp->m_sTitle = sCanonicURL;
+				aProp->m_bIsFolder = sal_True;
+				aProp->m_bIsDocument = !aProp->m_bIsFolder;
+				m_aContents.insert(ContentsMap::value_type(aProp->m_sDocumentId,aProp));
+			}
+			else
+				aProp = queryContentProperty(sCanonicURL);
+		}
+	}
+	if(!aProp.isValid())
+		throw star::ucb::IllegalIdentifierException();
+
+	xContent = new Content( m_xSMgr, this, xCanonicId ,aProp);
+
+	if ( !xContent->getIdentifier().is() )
+        throw star::ucb::IllegalIdentifierException();
+
+	return xContent;
+}
+// -----------------------------------------------------------------------------
+void ContentProvider::closeDocument(const ::rtl::OString& _sDocumentId)
+{
+	ContentsMap::iterator aIter = m_aContents.find(_sDocumentId);
+	if(aIter != m_aContents.end())
+	{
+		DWORD dwFlags = ODM_SILENT;
+		ODMSTATUS odm = NODMCloseDocEx(	ContentProvider::getHandle(), 
+										const_cast<sal_Char*>(_sDocumentId.getStr()), 
+										&dwFlags,
+										0xFFFFFFFF,
+										0xFFFFFFFF,
+										NULL,
+										0);
+		OSL_ENSURE(odm == ODM_SUCCESS,"Error while closing a document!");
+		if(odm == ODM_SUCCESS)
+			aIter->second->m_bIsOpen = sal_False;
+	}
+}
+// -----------------------------------------------------------------------------
+void ContentProvider::saveDocument(const ::rtl::OString& _sDocumentId)
+{
+	ContentsMap::iterator aIter = m_aContents.find(_sDocumentId);
+	if(aIter != m_aContents.end())
+	{
+		sal_Char* lpszDocId = new sal_Char[ODM_DOCID_MAX];
+		DWORD dwFlags = ODM_SILENT;
+		ODMSTATUS odm = NODMSaveDocEx(getHandle(),
+									const_cast<sal_Char*>(_sDocumentId.getStr()),
+									lpszDocId,
+									&dwFlags);
+		OSL_ENSURE(odm == ODM_SUCCESS,"Could not save document!");
+		if(odm != ODM_SUCCESS)
+		{
+			delete lpszDocId;
+			throw uno::Exception();
+		}
+		aIter->second->m_sDocumentId = rtl::OString(lpszDocId);
+		delete lpszDocId;
+	}
+}
+// -----------------------------------------------------------------------------
+util::Date toDate(const ::rtl::OString& _sSQLString)
+{
+	sal_uInt16	nYear	= 0,
+				nMonth	= 0,
+				nDay	= 0;
+	nYear	= (sal_uInt16)_sSQLString.copy(0,4).toInt32();
+	nMonth	= (sal_uInt16)_sSQLString.copy(4,2).toInt32();
+	nDay	= (sal_uInt16)_sSQLString.copy(6,2).toInt32();
+
+	return util::Date(nDay,nMonth,nYear);
+}
+//-----------------------------------------------------------------------------
+util::Time toTime(const ::rtl::OString& _sSQLString)
+{
+	sal_uInt16	nHour	= 0,
+				nMinute	= 0,
+				nSecond	= 0;
+	nHour	= (sal_uInt16)_sSQLString.copy(8,2).toInt32();
+	nMinute = (sal_uInt16)_sSQLString.copy(10,2).toInt32();
+	nSecond = (sal_uInt16)_sSQLString.copy(12,2).toInt32();
+
+	return util::Time(0,nHour,nMinute,nSecond);
+}
+//-----------------------------------------------------------------------------
+util::DateTime toDateTime(const ::rtl::OString& _sSQLString)
+{
+	util::Date aDate = toDate(_sSQLString);
+	util::Time aTime = toTime(_sSQLString);
+
+	return util::DateTime(0,aTime.Seconds,aTime.Minutes,aTime.Hours,aDate.Day,aDate.Month,aDate.Year);
+}
+// -----------------------------------------------------------------------------
+void ContentProvider::fillDocumentProperties(const ::vos::ORef<ContentProperties>& _rProp)
+{
+	// read some properties from the DMS
+	sal_Char* lpszDocInfo = new sal_Char[ODM_DOCID_MAX];
+	sal_Char* pDocId = const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr());
+
+	// read the create date of the document
+	ODMSTATUS odm = NODMGetDocInfo(	getHandle(),
+									pDocId,
+									ODM_CREATEDDATE,
+									lpszDocInfo,
+									ODM_DOCID_MAX);
+	if(odm == ODM_SUCCESS)
+		_rProp->m_aDateCreated = toDateTime(::rtl::OString(lpszDocInfo));
+
+	// read the modified date of the document
+	odm = NODMGetDocInfo(	getHandle(),
+							pDocId,
+							ODM_MODIFYDATE,
+							lpszDocInfo,
+							ODM_DOCID_MAX);
+	if(odm == ODM_SUCCESS)
+		_rProp->m_aDateModified = toDateTime(::rtl::OString(lpszDocInfo));
+
+	// read the title of the document
+	odm = NODMGetDocInfo(	getHandle(),
+							pDocId,
+							ODM_TITLETEXT,
+							lpszDocInfo,
+							ODM_DOCID_MAX);
+	if(odm == ODM_SUCCESS)
+		_rProp->m_sTitle = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+
+	// read the name of the document
+	odm = NODMGetDocInfo(	getHandle(),
+							pDocId,
+							ODM_NAME,
+							lpszDocInfo,
+							ODM_DOCID_MAX);
+	if(odm == ODM_SUCCESS)
+		_rProp->m_sDocumentName = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+
+	// read the author of the document
+	odm = NODMGetDocInfo(	getHandle(),
+							pDocId,
+							ODM_AUTHOR,
+							lpszDocInfo,
+							ODM_DOCID_MAX);
+	if(odm == ODM_SUCCESS)
+		_rProp->m_sAuthor = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+
+	// read the subject of the document
+	odm = NODMGetDocInfo(	getHandle(),
+							pDocId,
+							ODM_SUBJECT,
+							lpszDocInfo,
+							ODM_DOCID_MAX);
+	if(odm == ODM_SUCCESS)
+		_rProp->m_sSubject = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+
+	// read the keywords of the document
+	odm = NODMGetDocInfo(	getHandle(),
+							pDocId,
+							ODM_KEYWORDS,
+							lpszDocInfo,
+							ODM_DOCID_MAX);
+	if(odm == ODM_SUCCESS)
+		_rProp->m_sKeywords = ::rtl::OStringToOUString(rtl::OString(lpszDocInfo),RTL_TEXTENCODING_ASCII_US);
+
+/*
+	odm = NODMGetDocInfo(	getHandle(),
+									const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()),
+									ODM_URL,
+									lpszDocInfo,
+									ODM_DOCID_MAX);
+*/
+	delete lpszDocInfo;
+}
+// -----------------------------------------------------------------------------
+void ContentProvider::append(const ::vos::ORef<ContentProperties>& _rProp)
+{
+	// now fill some more properties
+	fillDocumentProperties(_rProp);
+	// and append them
+	m_aContents.insert(ContentsMap::value_type(_rProp->m_sDocumentId,_rProp));
+}
+// -----------------------------------------------------------------------------
+::vos::ORef<ContentProperties> ContentProvider::queryContentProperty(const ::rtl::OUString& _sDocumentName)
+{
+	::vos::ORef<ContentProperties> aReturn;
+	sal_Char* lpszDMSList	= new sal_Char[ODM_DMSID_MAX];
+
+	ODMSTATUS odm = NODMGetDMS(ODMA_ODMA_REGNAME, lpszDMSList);
+	if(odm == ODM_SUCCESS)
+	{
+		sal_Char* pQueryId = new sal_Char[ODM_QUERYID_MAX];
+		lpszDMSList[strlen(lpszDMSList)+1] = '\0';
+
+		::rtl::OString sTitleText(::rtl::OUStringToOString(_sDocumentName,RTL_TEXTENCODING_ASCII_US));
+		::rtl::OString sQuery("SELECT ODM_DOCID, ODM_NAME WHERE ODM_TITLETEXT = '");
+		sQuery += sTitleText;
+		sQuery += "'";
+		
+		DWORD dwFlags = ODM_SPECIFIC;
+		odm = NODMQueryExecute(getHandle(), sQuery,dwFlags, lpszDMSList, pQueryId );
+		if(odm == ODM_SUCCESS)
+		{
+			sal_uInt16 nCount		= 10;
+			sal_uInt16 nMaxCount	= 10;
+			sal_Char* lpszDocId		= new sal_Char[ODM_DOCID_MAX * nMaxCount];
+			sal_Char* lpszDocName	= new sal_Char[ODM_NAME_MAX * nMaxCount];
+			sal_Char* lpszDocInfo	= new sal_Char[ODM_DOCID_MAX];
+			
+			::rtl::OUString sContentType(RTL_CONSTASCII_USTRINGPARAM(ODMA_CONTENT_TYPE));
+			do
+			{
+				if(nCount >= nMaxCount)
+				{
+					// get the result
+					nCount = nMaxCount;
+					odm = NODMQueryGetResults(getHandle(), pQueryId,lpszDocId, lpszDocName, ODM_NAME_MAX, (WORD*)&nCount);
+				}
+				if(odm == ODM_SUCCESS)
+					for(sal_uInt16 i = 0; i < nCount; ++i)
+					{
+						odm = NODMGetDocInfo(	getHandle(),
+												&lpszDocId[ODM_DOCID_MAX*i],
+												ODM_TITLETEXT,
+												lpszDocInfo,
+												ODM_DOCID_MAX);
+						if( odm == ODM_SUCCESS && sTitleText == ::rtl::OString(lpszDocInfo))
+						{
+							aReturn = new ContentProperties();
+							aReturn->m_sDocumentName	= ::rtl::OStringToOUString(rtl::OString(&lpszDocName[ODM_NAME_MAX*i]),RTL_TEXTENCODING_ASCII_US);
+							aReturn->m_sDocumentId	= ::rtl::OString(&lpszDocId[ODM_DOCID_MAX*i]);
+							aReturn->m_sContentType	= sContentType;
+							append(aReturn);
+							nCount = 0; // break condition from outer loop
+							break;
+						}
+					}
+			}
+			while(nCount > nMaxCount);
+
+			delete lpszDocInfo;
+			delete lpszDocId;
+			delete lpszDocName;
+		}
+
+		// now close the query
+		odm = NODMQueryClose(ContentProvider::getHandle(), pQueryId);
+		delete pQueryId;
+	}
+	delete lpszDMSList;
+	
+
+	return aReturn;
+}
+// -----------------------------------------------------------------------------
+::vos::ORef<ContentProperties> ContentProvider::getContentProperty(const ::rtl::OUString& _sName,
+																   const ContentPropertiesMemberFunctor& _aFunctor) const
+{
+	::vos::ORef<ContentProperties> aReturn;
+	ContentsMap::const_iterator aFind = ::std::find_if(	m_aContents.begin(),
+														m_aContents.end(),
+														::std::compose1(
+															::std::bind2nd(_aFunctor,_sName),
+															::std::select2nd<ContentsMap::value_type>()
+														)
+													);
+	if(aFind != m_aContents.end())
+		aReturn = aFind->second;
+	return aReturn;
+}
+// -----------------------------------------------------------------------------
+::vos::ORef<ContentProperties> ContentProvider::getContentPropertyWithSavedAsName(const ::rtl::OUString& _sSaveAsName) const
+{
+	ContentPropertiesMemberFunctor aFunc(::std::mem_fun(&ContentProperties::getSavedAsName));
+	return getContentProperty(_sSaveAsName,aFunc);
+}
+// -----------------------------------------------------------------------------
+::vos::ORef<ContentProperties> ContentProvider::getContentPropertyWithTitle(const ::rtl::OUString& _sTitle) const
+{
+	ContentPropertiesMemberFunctor aFunc(::std::mem_fun(&ContentProperties::getTitle));
+	return getContentProperty(_sTitle,aFunc);
+}
+// -----------------------------------------------------------------------------
+::rtl::OUString ContentProvider::openDoc(const ::vos::ORef<ContentProperties>& _rProp)  throw (::com::sun::star::uno::Exception)
+{
+	OSL_ENSURE(_rProp.isValid(),"No valid content properties!");
+	if(!_rProp->m_bIsOpen)
+	{
+		sal_Char *pFileName = new sal_Char[ODM_FILENAME_MAX];
+		
+		DWORD dwFlag = ODM_MODIFYMODE | ODM_SILENT;
+		ODMSTATUS odm = NODMOpenDoc(getHandle(), dwFlag, const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()), pFileName);
+		switch(odm)
+		{
+			case ODM_E_INUSE:
+				dwFlag = ODM_VIEWMODE;
+				if( NODMOpenDoc(getHandle(), dwFlag, const_cast<sal_Char*>(_rProp->m_sDocumentId.getStr()), pFileName) != ODM_SUCCESS)
+					break;
+				// else run through
+			case ODM_SUCCESS:
+				::osl::FileBase::getFileURLFromSystemPath(::rtl::OStringToOUString(rtl::OString(pFileName),RTL_TEXTENCODING_ASCII_US)
+															,_rProp->m_sFileURL);
+				_rProp->m_bIsOpen = sal_True;
+				break;
+			default:
+				delete pFileName;
+				throw uno::Exception();  // TODO give a more precise error message here
+		}
+
+		delete pFileName;
+	}
+	return _rProp->m_sFileURL;
+}
+// -----------------------------------------------------------------------------
+::rtl::OUString ContentProvider::convertURL(const ::rtl::OUString& _sCanonicURL)
+{
+	sal_Int32 nPos = 0;
+	// check if url starts with odma
+	if(_sCanonicURL.matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_SCHEME_SHORT ODMA_URL_SHORT)))
+	{ // URL starts with odma:// so we have to remove this
+		nPos = ODMA_URL_SHORT_LGTH;
+	}
+	else if(_sCanonicURL.matchIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(ODMA_URL_SCHEME ODMA_URL_SHORT)))
+	{ // URL starts with vnd.sun.star.odma:/// so we have to remove this
+		nPos = ODMA_URL_LGTH;
+	}
+
+	::rtl::OUString sCanonicURL = _sCanonicURL;
+	// now check what formats we allow
+	if(nPos == _sCanonicURL.getLength()) // only ask for root entry
+		sCanonicURL = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("/"));
+
+	if(nPos < sCanonicURL.getLength())
+	{
+		sCanonicURL = sCanonicURL.copy(nPos);
+		sCanonicURL = rtl::Uri::decode(sCanonicURL,rtl_UriDecodeWithCharset,RTL_TEXTENCODING_UTF8);
+	}
+	if(sCanonicURL.getLength() > 1 && sCanonicURL.getStr()[0] == sal_Unicode('/'))
+	{
+		sCanonicURL = sCanonicURL.copy(1);
+		if(sCanonicURL.getLength() == 1 && sCanonicURL.getStr()[0] == sal_Unicode('.'))
+			sCanonicURL = ::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM("/"));
+	}
+	return sCanonicURL;
+}
+// -----------------------------------------------------------------------------
+sal_Bool ContentProvider::deleteDocument(const ::vos::ORef<ContentProperties>& _rProp)
+{
+	closeDocument(_rProp->m_sDocumentId);
+	ODMSTATUS odm = NODMActivate(ContentProvider::getHandle(),
+								 ODM_DELETE,
+								 const_cast< sal_Char*>(_rProp->m_sDocumentId.getStr()));
+	if(odm == ODM_SUCCESS)
+		m_aContents.erase(_rProp->m_sDocumentId);
+	
+	return odm == ODM_SUCCESS;
+}
+// -----------------------------------------------------------------------------
diff --new-file -r -u /tmp/nothing/odma_provider.hxx ucb/source/ucp/odma/odma_provider.hxx
--- /tmp/nothing/odma_provider.hxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_provider.hxx	2003-08-25 14:01:52.000000000 +0100
@@ -0,0 +1,217 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+// @@@ Adjust multi-include-protection-ifdef.
+#ifndef ODMA_PROVIDER_HXX
+#define ODMA_PROVIDER_HXX
+
+#ifndef _UCBHELPER_PROVIDERHELPER_HXX
+#include <ucbhelper/providerhelper.hxx>
+#endif
+#ifndef ODMA_LIB_HXX
+#include "odma_lib.hxx"
+#endif
+#ifndef _VOS_REF_HXX_
+#include <vos/ref.hxx>
+#endif
+#include <map>
+#ifndef ODMA_CONTENTPROPS_HXX
+#include "odma_contentprops.hxx"
+#endif
+// @@@ Adjust namespace name.
+namespace odma {
+
+//=========================================================================
+
+// @@@ Adjust defines.
+
+// UNO service name for the provider. This name will be used by the UCB to
+// create instances of the provider.
+#define ODMA_CONTENT_PROVIDER_SERVICE_NAME \
+				"com.sun.star.ucb.OdmaContentProvider"
+//	#define ODMA_CONTENT_PROVIDER_SERVICE_NAME_LENGTH	34
+
+// URL scheme. This is the scheme the provider will be able to create
+// contents for. The UCB will select the provider ( i.e. in order to create
+// contents ) according to this scheme.
+#define ODMA_URL_ODMAID			"::ODMA"
+#define ODMA_URL_SCHEME			"vnd.sun.star.odma"
+#define ODMA_URL_SCHEME_SHORT	"odma"
+#define ODMA_URL_SHORT			":"
+#define ODMA_URL_SHORT_LGTH		5
+#define ODMA_URL_LGTH			18
+#define ODMA_URL_ODMAID_LGTH	6
+
+// UCB Content Type.
+#define ODMA_CONTENT_TYPE 		"application/" ODMA_URL_SCHEME "-content"
+#define ODMA_ODMA_REGNAME		"sodma"
+#define ODM_NAME_MAX			64		// Max length of a name document including
+										// the terminating NULL character.
+
+//=========================================================================
+class ContentProperties;
+class ContentProvider : public ::ucb::ContentProviderImplHelper
+{
+	typedef ::std::map< ::rtl::OString, ::vos::ORef<ContentProperties> > ContentsMap;
+	ContentsMap		 m_aContents;  // contains all ContentProperties
+	static ODMHANDLE m_aOdmHandle; // the one and only ODMA handle to our DMS
+
+	/** fillDocumentProperties fills the given _rProp with ODMA properties
+		@param	_rProp	the ContentProperties
+	*/
+	void fillDocumentProperties(const ::vos::ORef<ContentProperties>& _rProp);
+
+	/**
+	*/
+	::vos::ORef<ContentProperties> getContentProperty(const ::rtl::OUString& _sName,
+													   const ContentPropertiesMemberFunctor& _aFunctor) const;
+public:
+	ContentProvider( const ::com::sun::star::uno::Reference<
+						::com::sun::star::lang::XMultiServiceFactory >& rSMgr );
+	virtual ~ContentProvider();
+
+	// XInterface
+	XINTERFACE_DECL()
+
+	// XTypeProvider
+	XTYPEPROVIDER_DECL()
+
+    // XServiceInfo
+	XSERVICEINFO_DECL()
+
+	// XContentProvider
+	virtual ::com::sun::star::uno::Reference<
+				::com::sun::star::ucb::XContent > SAL_CALL
+	queryContent( const ::com::sun::star::uno::Reference<
+					::com::sun::star::ucb::XContentIdentifier >& Identifier )
+		throw( ::com::sun::star::ucb::IllegalIdentifierException,
+			   ::com::sun::star::uno::RuntimeException );
+
+	//////////////////////////////////////////////////////////////////////
+	// Additional interfaces
+	//////////////////////////////////////////////////////////////////////
+
+	//////////////////////////////////////////////////////////////////////
+	// Non-interface methods.
+	//////////////////////////////////////////////////////////////////////
+	static ODMHANDLE getHandle(); 
+
+	/** append add an entry to the internal map
+		@param	_rProp	the content properties
+	*/
+	void append(const ::vos::ORef<ContentProperties>& _rProp);
+	
+	/** closeDocument closes the document
+		@param	_sDocumentId	the id of the document
+	*/
+	void closeDocument(const ::rtl::OString& _sDocumentId);
+	
+	/** saveDocument saves the document in DMS 
+		@param	_sDocumentId	the id of the document
+	*/
+	void saveDocument(const ::rtl::OString& _sDocumentId);
+
+	/** queryContentProperty query in the DMS for a content which document name is equal to _sDocumentName
+		@param	_sDocumentName	the document to query for
+
+		@return	the content properties for this content or an empty refernce
+	*/
+	::vos::ORef<ContentProperties> queryContentProperty(const ::rtl::OUString& _sDocumentName);
+
+	/** getContentProperty returns the ContentProperties for the first content with that title
+		@param	_sTitle	the title of the document
+
+		@return	the content properties
+	*/
+	::vos::ORef<ContentProperties> getContentPropertyWithTitle(const ::rtl::OUString& _sTitle) const;
+
+	/** getContentProperty returns the ContentProperties for the first content with that SavedAsName
+		@param	_sSaveAsName	the SavedAsName of the document
+
+		@return	the content properties
+	*/
+	::vos::ORef<ContentProperties> getContentPropertyWithSavedAsName(const ::rtl::OUString& _sSaveAsName) const;
+
+	/** openDoc returns the URL for the temporary file for the specific Content and opens it
+		@param	_rProp	used for check if already open, the member m_sFileURL will be set if is wan't opened yet
+
+		@return the URL of the temporary file
+	*/
+	static ::rtl::OUString openDoc(const ::vos::ORef<ContentProperties>& _rProp) throw (::com::sun::star::uno::Exception);
+	
+	/** convertURL converts a normal URL into an ODMA understandable name
+		@param	_sCanonicURL	the URL from ContentIndentifier
+
+		@return	the ODMA name 
+	*/
+	static ::rtl::OUString convertURL(const ::rtl::OUString& _sCanonicURL);
+
+	/** deleteDocument deletes the document inside the DMS and remove the content properties from inside list
+		@param	_rProp	the ContentProperties
+
+		@return true when successful
+	*/
+	sal_Bool deleteDocument(const ::vos::ORef<ContentProperties>& _rProp);
+};
+
+}
+
+#endif
diff --new-file -r -u /tmp/nothing/odma_resultset.cxx ucb/source/ucp/odma/odma_resultset.cxx
--- /tmp/nothing/odma_resultset.cxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_resultset.cxx	2003-08-25 14:01:59.000000000 +0100
@@ -0,0 +1,135 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+/**************************************************************************
+								TODO
+ **************************************************************************
+
+ - This implementation is not a dynamic result set!!! It only implements
+   the necessary interfaces, but never recognizes/notifies changes!!!
+
+ *************************************************************************/
+
+// @@@ Adjust multi-include-protection-ifdef and header file name.
+#ifndef ODMA_DATASUPPLIER_HXX
+#include "odma_datasupplier.hxx"
+#endif
+// @@@ Adjust multi-include-protection-ifdef and header file name.
+#ifndef ODMA_RESULTSET_HXX
+#include "odma_resultset.hxx"
+#endif
+
+using namespace com::sun::star::lang;
+using namespace com::sun::star::ucb;
+using namespace com::sun::star::uno;
+
+// @@@ Adjust namespace name.
+using namespace odma;
+
+//=========================================================================
+//=========================================================================
+//
+// DynamicResultSet Implementation.
+//
+//=========================================================================
+//=========================================================================
+
+DynamicResultSet::DynamicResultSet(
+					  const Reference< XMultiServiceFactory >& rxSMgr,
+					  const vos::ORef< Content >& rxContent,
+					  const OpenCommandArgument2& rCommand,
+					  const Reference< XCommandEnvironment >& rxEnv )
+: ResultSetImplHelper( rxSMgr, rCommand ),
+  m_xContent( rxContent ),
+  m_xEnv( rxEnv )
+{
+}
+
+//=========================================================================
+//
+// Non-interface methods.
+//
+//=========================================================================
+
+void DynamicResultSet::initStatic()
+{
+	m_xResultSet1
+		= new ::ucb::ResultSet( m_xSMgr,
+								m_aCommand.Properties,
+								new DataSupplier( m_xSMgr,
+												  m_xContent,
+												  m_aCommand.Mode ),
+								m_xEnv );
+}
+
+//=========================================================================
+void DynamicResultSet::initDynamic()
+{
+	m_xResultSet1
+		= new ::ucb::ResultSet( m_xSMgr,
+								m_aCommand.Properties,
+								new DataSupplier( m_xSMgr,
+												  m_xContent,
+												  m_aCommand.Mode ),
+								m_xEnv );
+	m_xResultSet2 = m_xResultSet1;
+}
+
diff --new-file -r -u /tmp/nothing/odma_resultset.hxx ucb/source/ucp/odma/odma_resultset.hxx
--- /tmp/nothing/odma_resultset.hxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_resultset.hxx	2003-08-25 14:02:06.000000000 +0100
@@ -0,0 +1,103 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+// @@@ Adjust multi-include-protection-ifdef.
+#ifndef ODMA_RESULTSET_HXX
+#define ODMA_RESULTSET_HXX
+
+#ifndef _UCBHELPER_RESULTSETHELPER_HXX
+#include <ucbhelper/resultsethelper.hxx>
+#endif
+#ifndef _VOS_REF_HXX_
+#include <vos/ref.hxx>
+#endif
+
+// @@@ Adjust multi-include-protection-ifdef and header file name.
+#ifndef ODMA_CONTENT_HXX
+#include "odma_content.hxx"
+#endif
+
+// @@@ Adjust namespace name.
+namespace odma {
+
+class DynamicResultSet : public ::ucb::ResultSetImplHelper
+{
+  	vos::ORef< Content > m_xContent;
+	com::sun::star::uno::Reference<
+		com::sun::star::ucb::XCommandEnvironment > m_xEnv;
+
+private:
+	virtual void initStatic();
+	virtual void initDynamic();
+
+public:
+	DynamicResultSet(
+			const com::sun::star::uno::Reference<
+				com::sun::star::lang::XMultiServiceFactory >& rxSMgr,
+		  	const vos::ORef< Content >& rxContent,
+			const com::sun::star::ucb::OpenCommandArgument2& rCommand,
+		  	const com::sun::star::uno::Reference<
+				com::sun::star::ucb::XCommandEnvironment >& rxEnv );
+};
+
+}
+
+#endif
diff --new-file -r -u /tmp/nothing/odma_services.cxx ucb/source/ucp/odma/odma_services.cxx
--- /tmp/nothing/odma_services.cxx	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/odma_services.cxx	2003-08-25 14:02:15.000000000 +0100
@@ -0,0 +1,183 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _COM_SUN_STAR_LANG_XMULTISERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#endif
+#ifndef _COM_SUN_STAR_LANG_XSINGLESERVICEFACTORY_HPP_
+#include <com/sun/star/lang/XSingleServiceFactory.hpp>
+#endif
+#ifndef _COM_SUN_STAR_REGISTRY_XREGISTRYKEY_HPP_
+#include <com/sun/star/registry/XRegistryKey.hpp>
+#endif
+
+#ifndef ODMA_CONTENTPROPS_HXX
+#include "odma_contentprops.hxx"
+#endif
+#ifndef ODMA_PROVIDER_HXX
+#include "odma_provider.hxx"
+#endif
+#ifndef ODMA_LIB_HXX
+#include "odma_lib.hxx"
+#endif
+
+using namespace rtl;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::lang;
+using namespace com::sun::star::registry;
+
+//=========================================================================
+static sal_Bool writeInfo( void * pRegistryKey,
+						   const OUString & rImplementationName,
+   						   Sequence< OUString > const & rServiceNames )
+{
+	OUString aKeyName( OUString::createFromAscii( "/" ) );
+	aKeyName += rImplementationName;
+	aKeyName += OUString::createFromAscii( "/UNO/SERVICES" );
+
+	Reference< XRegistryKey > xKey;
+	try
+	{
+		xKey = static_cast< XRegistryKey * >(
+									pRegistryKey )->createKey( aKeyName );
+	}
+	catch ( InvalidRegistryException const & )
+	{
+	}
+
+	if ( !xKey.is() )
+		return sal_False;
+
+	sal_Bool bSuccess = sal_True;
+
+	for ( sal_Int32 n = 0; n < rServiceNames.getLength(); ++n )
+	{
+		try
+		{
+			xKey->createKey( rServiceNames[ n ] );
+		}
+		catch ( InvalidRegistryException const & )
+		{
+			bSuccess = sal_False;
+			break;
+		}
+	}
+	return bSuccess;
+}
+
+//=========================================================================
+extern "C" void SAL_CALL component_getImplementationEnvironment(
+	const sal_Char ** ppEnvTypeName, uno_Environment ** ppEnv )
+{
+	*ppEnvTypeName = CPPU_CURRENT_LANGUAGE_BINDING_NAME;
+}
+
+//=========================================================================
+extern "C" sal_Bool SAL_CALL component_writeInfo(
+	void * pServiceManager, void * pRegistryKey )
+{
+	return pRegistryKey &&
+
+	//////////////////////////////////////////////////////////////////////
+	// Write info into registry.
+	//////////////////////////////////////////////////////////////////////
+
+	// @@@ Adjust namespace names.
+	writeInfo( pRegistryKey,
+			   ::odma::ContentProvider::getImplementationName_Static(),
+			   ::odma::ContentProvider::getSupportedServiceNames_Static() );
+}
+
+//=========================================================================
+extern "C" void * SAL_CALL component_getFactory(
+	const sal_Char * pImplName, void * pServiceManager, void * pRegistryKey )
+{
+	void * pRet = 0;
+
+	Reference< XMultiServiceFactory > xSMgr(
+			reinterpret_cast< XMultiServiceFactory * >( pServiceManager ) );
+	Reference< XSingleServiceFactory > xFactory;
+
+	//////////////////////////////////////////////////////////////////////
+	// Create factory, if implementation name matches.
+	//////////////////////////////////////////////////////////////////////
+
+	// @@@ Adjust namespace names.
+	if ( ::odma::ContentProvider::getImplementationName_Static().
+				compareToAscii( pImplName ) == 0 )
+	{
+		if(::odma::LoadLibrary())
+			xFactory = ::odma::ContentProvider::createServiceFactory( xSMgr );
+		else
+			OSL_ASSERT(!"Could not load library!");
+	}
+
+	//////////////////////////////////////////////////////////////////////
+
+	if ( xFactory.is() )
+	{
+		xFactory->acquire();
+		pRet = xFactory.get();
+	}
+
+	return pRet;
+}
+
diff --new-file -r -u /tmp/nothing/ucpodma.xml ucb/source/ucp/odma/ucpodma.xml
--- /tmp/nothing/ucpodma.xml	1970-01-01 01:00:00.000000000 +0100
+++ ucb/source/ucp/odma/ucpodma.xml	2003-08-25 14:02:22.000000000 +0100
@@ -0,0 +1,102 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE module-description PUBLIC "-//StarOffice//DTD ComponentDescription 1.0//EN" "module-description.dtd">
+<module-description xmlns:xlink="http://www.w3.org/1999/xlink">
+
+    <module-name>
+	ucpodma
+    </module-name>
+
+    <component-description>
+        <author>
+            Ocke Janssen
+        </author>
+        <name>
+            com.sun.star.comp.ucb.OdmaContentProvider
+        </name>
+        <description>
+	    This component implements a Content Provider for the Universal
+            Content Broker. It provides access to contents stored on an document management
+            system (DMS).
+        </description>
+        <loader-name>
+            com.sun.star.loader.SharedLibrary
+        </loader-name>
+        <language>
+            c++
+        </language>
+        <status value="final"/>
+        <supported-service>
+            com.sun.star.ucb.ODMAContentProvider
+        </supported-service>
+
+        <service-dependency>
+            com.sun.star.configuration.ConfigurationAccess
+        </service-dependency>
+        <service-dependency>
+            com.sun.star.configuration.ConfigurationProvider
+        </service-dependency>
+    </component-description>
+
+    <project-build-dependency> external           </project-build-dependency>
+    <project-build-dependency> sal                </project-build-dependency>
+    <project-build-dependency> cppu               </project-build-dependency>
+    <project-build-dependency> cppuhelper         </project-build-dependency>
+    <project-build-dependency> vos                </project-build-dependency>
+    <project-build-dependency> ucbhelper          </project-build-dependency>
+
+    <runtime-module-dependency> sal3              </runtime-module-dependency>
+    <runtime-module-dependency> cppu3             </runtime-module-dependency>
+    <runtime-module-dependency>	cppuhelper3$(COM) </runtime-module-dependency>
+    <runtime-module-dependency>	vos2$(COM)        </runtime-module-dependency>
+    <runtime-module-dependency>	ucbhelper1$(COM)  </runtime-module-dependency>
+
+    <type> com.sun.star.beans.PropertyAttribute                </type>
+    <type> com.sun.star.beans.PropertyValue                    </type>
+    <type> com.sun.star.beans.XPropertiesChangeNotifier        </type>
+    <type> com.sun.star.beans.XPropertyAccess                  </type>
+    <type> com.sun.star.beans.XPropertyContainer               </type>
+    <type> com.sun.star.beans.XPropertySetInfoChangeNotifier   </type>
+    <type> com.sun.star.container.XChild                       </type>
+    <type> com.sun.star.container.XNameAccess                  </type>
+    <type> com.sun.star.io.XActiveDataSink                     </type>
+    <type> com.sun.star.io.XInputStream                        </type>
+    <type> com.sun.star.io.XOutputStream                       </type>
+    <type> com.sun.star.io.XSeekable                           </type>
+    <type> com.sun.star.lang.IllegalAccessException            </type>
+    <type> com.sun.star.lang.XComponent                        </type>
+    <type> com.sun.star.lang.XMultiServiceFactory              </type>
+    <type> com.sun.star.lang.XServiceInfo                      </type>
+    <type> com.sun.star.lang.XSingleServiceFactory             </type>
+    <type> com.sun.star.lang.XTypeProvider                     </type>
+    <type> com.sun.star.registry.XRegistryKey                  </type>
+    <type> com.sun.star.sdbc.XCloseable                        </type>
+    <type> com.sun.star.sdbc.XColumnLocate                     </type>
+    <type> com.sun.star.sdbc.XResultSetMetaDataSupplier        </type>
+    <type> com.sun.star.sdbc.XRow                              </type>
+    <type> com.sun.star.ucb.ContentCreationException           </type>
+    <type> com.sun.star.ucb.ContentInfoAttribute               </type>
+    <type> com.sun.star.ucb.InsertCommandArgument              </type>
+    <type> com.sun.star.ucb.MissingInputStreamException        </type>
+    <type> com.sun.star.ucb.MissingPropertiesException         </type>
+    <type> com.sun.star.ucb.NameClash                          </type>
+    <type> com.sun.star.ucb.NameClashException                 </type>
+    <type> com.sun.star.ucb.OpenCommandArgument2               </type>
+    <type> com.sun.star.ucb.OpenMode                           </type>
+    <type> com.sun.star.ucb.PostCommandArgument2               </type>
+    <type> com.sun.star.ucb.RememberAuthentication             </type>
+    <type> com.sun.star.ucb.ResultSetException                 </type>
+    <type> com.sun.star.ucb.TransferInfo                       </type>
+    <type> com.sun.star.ucb.XCommandEnvironment                </type>
+    <type> com.sun.star.ucb.UnsupportedCommandException        </type>
+    <type> com.sun.star.ucb.UnsupportedDataSinkException       </type>
+    <type> com.sun.star.ucb.UnsupportedNameClashException      </type>
+    <type> com.sun.star.ucb.UnsupportedOpenModeException       </type>
+    <type> com.sun.star.ucb.XCommandInfo                       </type>
+    <type> com.sun.star.ucb.XCommandInfoChangeNotifier         </type>
+    <type> com.sun.star.ucb.XCommandProcessor                  </type>
+    <type> com.sun.star.ucb.XContentAccess                     </type>
+    <type> com.sun.star.ucb.XContentProvider                   </type>
+    <type> com.sun.star.ucb.XDynamicResultSet                  </type>
+    <type> com.sun.star.ucb.XPersistentPropertySet             </type>
+    <type> com.sun.star.util.DateTime                          </type>
+</module-description>
