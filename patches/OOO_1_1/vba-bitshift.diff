Index: basic/source/runtime/runtime.cxx
===================================================================
--- basic/source/runtime/runtime.cxx	(revision 80)
+++ basic/source/runtime/runtime.cxx	(revision 81)
@@ -133,6 +133,8 @@
 	MEMBER(SbiRuntime::StepOR),
 	MEMBER(SbiRuntime::StepXOR),
 	MEMBER(SbiRuntime::StepEQV),
+	MEMBER(SbiRuntime::StepLSHIFT),
+	MEMBER(SbiRuntime::StepRSHIFT),
 	MEMBER(SbiRuntime::StepIMP),
 	MEMBER(SbiRuntime::StepNOT),
 	MEMBER(SbiRuntime::StepCAT),
Index: basic/source/inc/expr.hxx
===================================================================
--- basic/source/inc/expr.hxx	(revision 80)
+++ basic/source/inc/expr.hxx	(revision 81)
@@ -178,6 +178,7 @@
 	SbiExprNode* Operand();
 	SbiExprNode* Unary();
 	SbiExprNode* Exp();
+	SbiExprNode* Shift();
 	SbiExprNode* MulDiv();
 	SbiExprNode* IntDiv();
 	SbiExprNode* Mod();
Index: basic/source/inc/token.hxx
===================================================================
--- basic/source/inc/token.hxx	(revision 80)
+++ basic/source/inc/token.hxx	(revision 81)
@@ -127,7 +127,7 @@
 	// Operatoren:
 	EXPON, NEG, MUL,
 	DIV, IDIV, MOD, PLUS, MINUS,
-	EQ, NE, LT, GT, LE, GE,
+	EQ, NE, LT, GT, LE, GE, LSHIFT, RSHIFT,
 	NOT, AND, OR, XOR, EQV,
 	IMP, CAT, LIKE, IS,
 	// Sonstiges:
Index: basic/source/inc/runtime.hxx
===================================================================
--- basic/source/inc/runtime.hxx	(revision 80)
+++ basic/source/inc/runtime.hxx	(revision 81)
@@ -429,7 +430,7 @@
 	void StepMOD(),     StepPLUS(),     StepMINUS(),    StepNEG();
 	void StepEQ(),      StepNE(),       StepLT(),       StepGT();
 	void StepLE(),      StepGE(),       StepIDIV(),     StepAND();
-	void StepOR(),      StepXOR(),      StepEQV(),      StepIMP();
+	void StepOR(),      StepXOR(),      StepEQV(),	StepLSHIFT(),	StepRSHIFT(),      StepIMP();
 	void StepNOT(),     StepCAT(),      StepLIKE(),     StepIS();
 	void StepCLONE(),   StepOLDBASED(), StepARGC();
 	void StepARGV(),    StepINPUT(),	StepLINPUT(),	StepSTOP();
Index: basic/source/inc/opcodes.hxx
===================================================================
--- basic/source/inc/opcodes.hxx	(revision 80)
+++ basic/source/inc/opcodes.hxx	(revision 81)
@@ -82,7 +82,7 @@
 	// wie der enum SbxVarOp
 	_EXP, _MUL, _DIV, _MOD, _PLUS, _MINUS, _NEG,
 	_EQ,  _NE,  _LT,  _GT, _LE, _GE,
-	_IDIV, _AND, _OR, _XOR, _EQV, _IMP, _NOT,
+	_IDIV, _AND, _OR, _XOR, _EQV, _LSHIFT, _RSHIFT, _IMP, _NOT,
 	_CAT,
 	// Ende enum SbxVarOp
 	_LIKE, _IS,
Index: basic/source/classes/disas.cxx
===================================================================
--- basic/source/classes/disas.cxx	(revision 80)
+++ basic/source/classes/disas.cxx	(revision 81)
@@ -82,8 +82,8 @@
 	// wie der enum SbxVarOp
 	"EXP", "MUL", "DIV", "MOD", "PLUS", "MINUS", "NEG",
 	"EQ", "NE", "LT", "GT", "LE", "GE",
-	"IDIV", "AND", "OR", "XOR", "EQV", "IMP", "NOT",
-	"CAT",
+	"IDIV", "AND", "OR", "XOR", "EQV", "LSHIFT", "RSHIFT",
+	"IMP", "NOT", "CAT",
 	// Ende enum SbxVarOp
 	"LIKE", "IS",
 	// Laden/speichern
Index: basic/source/comp/exprtree.cxx
===================================================================
--- basic/source/comp/exprtree.cxx	(revision 80)
+++ basic/source/comp/exprtree.cxx	(revision 81)
@@ -542,16 +542,26 @@
 	return pNd;
 }
 
+SbiExprNode* SbiExpression::Shift()
+{
+	SbiExprNode* pNd = Exp();
+	while( pParser->Peek() == LSHIFT || pParser->Peek() == RSHIFT ) {
+		SbiToken eTok = pParser->Next();
+		pNd = new SbiExprNode( pParser, pNd, eTok, Exp() );
+	}
+	return pNd;
+}
+
 SbiExprNode* SbiExpression::MulDiv()
 {
-	SbiExprNode* pNd = Exp();
+	SbiExprNode* pNd = Shift();
 	for( ;; )
 	{
 		SbiToken eTok = pParser->Peek();
 		if( eTok != MUL && eTok != DIV )
 			break;
 		eTok = pParser->Next();
-		pNd = new SbiExprNode( pParser, pNd, eTok, Exp() );
+		pNd = new SbiExprNode( pParser, pNd, eTok, Shift() );
 	}
 	return pNd;
 }
Index: basic/source/comp/token.cxx
===================================================================
--- basic/source/comp/token.cxx	(revision 80)
+++ basic/source/comp/token.cxx	(revision 81)
@@ -78,11 +78,13 @@
 	{ EOS,		":" },
 	{ ASSIGN,	":=" },
 	{ LT,		"<" },
+	{ LSHIFT,		"<<" },
 	{ LE,		"<=" },
 	{ NE,		"<>" },
 	{ EQ,		"=" },
 	{ GT,		">" },
 	{ GE,		">=" },
+	{ RSHIFT,		">>" },
 	{ ACCESS,	"Access" },
 	{ ALIAS,	"Alias" },
 	{ AND,		"And" },
Index: basic/source/comp/exprnode.cxx
===================================================================
--- basic/source/comp/exprnode.cxx	(revision 80)
+++ basic/source/comp/exprnode.cxx	(revision 81)
@@ -413,6 +413,12 @@
 					case GE:
 						nVal = ( nl >= nr ) ? SbxTRUE : SbxFALSE;
 						eType = SbxINTEGER; break;
+					case LSHIFT:
+						nVal = (long)nl << (long)nr;
+						eType = SbxINTEGER; break;
+					case RSHIFT:
+						nVal = (long)nl >> (long)nr;
+						eType = SbxINTEGER; break;
 					case IDIV:
 						if( !lr )
 						{
Index: basic/source/comp/exprgen.cxx
===================================================================
--- basic/source/comp/exprgen.cxx	(revision 80)
+++ basic/source/comp/exprgen.cxx	(revision 81)
@@ -88,6 +88,8 @@
 	{ OR,	_OR },
 	{ XOR,	_XOR },
 	{ EQV,	_EQV },
+	{ LSHIFT,	_LSHIFT },
+	{ RSHIFT,	_RSHIFT },
 	{ IMP,	_IMP },
 	{ NOT,	_NOT },
 	{ NEG,	_NEG },
Index: basic/source/comp/scanner.cxx
===================================================================
--- basic/source/comp/scanner.cxx	(revision 80)
+++ basic/source/comp/scanner.cxx	(revision 81)
@@ -456,8 +456,8 @@
 		short n = 1;
 		switch( *pLine++ )
 		{
-			case '<': if( *pLine == '>' || *pLine == '=' ) n = 2; break;
-			case '>': if( *pLine == '=' ) n = 2; break;
+			case '<': if( *pLine == '<' || *pLine == '>' || *pLine == '=' ) n = 2; break;
+			case '>': if( *pLine == '>' || *pLine == '=' ) n = 2; break;
 			case ':': if( *pLine == '=' ) n = 2; break;
 		}
 		aSym = aLine.copy( nCol, n );
Index: svtools/source/sbx/sbxvalue.cxx
===================================================================
--- svtools/source/sbx/sbxvalue.cxx	(revision 77)
+++ svtools/source/sbx/sbxvalue.cxx	(revision 80)
@@ -1289,7 +1289,8 @@
 			}
 		}
 		else if( ( GetType() == SbxDECIMAL || rOp.GetType() == SbxDECIMAL ) && 
-			     ( eOp == SbxMUL || eOp == SbxDIV || eOp == SbxPLUS || eOp == SbxMINUS || eOp == SbxNEG ) )
+			     ( eOp == SbxMUL || eOp == SbxDIV || eOp == SbxPLUS || eOp == SbxMINUS || eOp == SbxNEG 
+			     || eOp == SbxLSHIFT || eOp == SbxRSHIFT) )
 		{
 			aL.eType = aR.eType = SbxDECIMAL;
 			bDecimal = true;
@@ -1401,6 +1402,10 @@
 							aL.nDouble -= aR.nDouble; break;
 						case SbxNEG:
 							aL.nDouble = -aL.nDouble; break;
+						case SbxLSHIFT:
+							aL.nDouble = (long)aL.nDouble << (long)aR.nDouble; break;
+						case SbxRSHIFT:
+							aL.nDouble = (long)aL.nDouble >> (long)aR.nDouble; break;
 						default:
 							SetError( SbxERR_NOTIMP );
 					}
Index: svtools/inc/sbxdef.hxx
===================================================================
--- svtools/inc/sbxdef.hxx	(revision 77)
+++ svtools/inc/sbxdef.hxx	(revision 80)
@@ -152,6 +152,8 @@
 	SbxPLUS, 			// this + var
 	SbxMINUS, 			// this - var
 	SbxNEG,				// -this (var wird ignoriert)
+	SbxLSHIFT, 				// this << var
+	SbxRSHIFT, 				// this >> var	
 	SbxIDIV,			// this / var (beide Operanden sind max. INT32!)
 						// Boolesche Operatoren (auch max INT32!):
 	SbxAND,				// this & var
Index: basic/source/runtime/step0.cxx
===================================================================
RCS file: /cvs/script/basic/source/runtime/step0.cxx,v
retrieving revision 1.15.42.1
diff -u -r1.15.42.1 step0.cxx
--- basic/source/runtime/step0.cxx	20 Jan 2004 10:04:27 -0000	1.15.42.1
+++ basic/source/runtime/step0.cxx	25 Aug 2004 16:17:05 -0000
@@ -149,6 +149,8 @@
 void SbiRuntime::StepOR()		{ StepArith( SbxOR );		}
 void SbiRuntime::StepXOR()		{ StepArith( SbxXOR );		}
 void SbiRuntime::StepEQV()		{ StepArith( SbxEQV );		}
+void SbiRuntime::StepLSHIFT()	{ StepArith( SbxLSHIFT );	}
+void SbiRuntime::StepRSHIFT()	{ StepArith( SbxRSHIFT );	}
 void SbiRuntime::StepIMP()		{ StepArith( SbxIMP );		}
 
 void SbiRuntime::StepNEG()		{ StepUnary( SbxNEG );		}
