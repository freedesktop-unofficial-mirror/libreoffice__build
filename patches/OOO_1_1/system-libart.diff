Index: config_office/configure.in
===================================================================
RCS file: /cvs/tools/config_office/configure.in,v
retrieving revision 1.54.2.1
diff -u -p -u -r1.54.2.1 configure.in
--- config_office/configure.in	7 Jul 2003 10:36:49 -0000	1.54.2.1
+++ config_office/configure.in	9 Jul 2003 09:20:25 -0000
@@ -23,6 +23,10 @@ AC_ARG_WITH(gpc,
                           This is required to allow some strict packagers to
                           comply with their distrubution policy.
 ],,)
+AC_ARG_ENABLE(libart,
+[  --enable-libart          Enables the use of libart, instead of GPC for
+			  polygon clipping.
+],,)
 AC_ARG_ENABLE(gcc3,
 [  --enable-gcc3          Deprecated: Now has no effect, checks compiler version.
 ],,)
@@ -1214,10 +1218,19 @@ else
 fi
 
 dnl ===================================================================
-dnl Test for the presence of the required gpc.{c,h} files
+dnl Test for the presence of the right polgyon clipping code
 dnl ===================================================================
 
-if test "$with_gpc" != "no" ; then
+WITH_GPC=NO
+WITH_LIBART=NO
+
+if test -n "$enable_libart"; then
+  PKG_CHECK_MODULES( LIBART, libart-2.0 >= 2.3.13 )
+  AC_SUBST(LIBART_CFLAGS)
+  AC_SUBST(LIBART_LIBS)
+  WITH_LIBART=YES
+	
+elif test "$with_gpc" != "no" ; then
   WITH_GPC=YES
 
   AC_MSG_CHECKING([GPC files])
@@ -1238,8 +1251,6 @@ if test "$with_gpc" != "no" ; then
 	AC_MSG_ERROR([GPC files not found
 ftp://ftp.cs.man.ac.uk/pub/toby/gpc/gpc231.tar.Z and untar in external/gpc])
   fi
-else
-  WITH_GPC=NO
 fi
 
 dnl ===================================================================
@@ -1416,6 +1427,9 @@ AC_SUBST(ENABLE_STATIC_GTK)
 AC_SUBST(ENVCFLAGSCXX)
 AC_SUBST(ENABLE_CRASHDUMP)
 AC_SUBST(WITH_GPC)
+AC_SUBST(WITH_LIBART)
+AC_SUBST(LIBART_CFLAGS)
+AC_SUBST(LIBART_LIBS)
 
 AC_OUTPUT([set_soenv])
 
Index: config_office/set_soenv.in
===================================================================
RCS file: /cvs/tools/config_office/set_soenv.in,v
retrieving revision 1.9.2.1
diff -u -p -u -r1.9.2.1 set_soenv.in
--- config_office/set_soenv.in	7 Jul 2003 10:36:50 -0000	1.9.2.1
+++ config_office/set_soenv.in	9 Jul 2003 09:20:26 -0000
@@ -1653,11 +1653,14 @@ ToFile( "CXX",               $CXX,      
 if ( $COM ne "MSC" ) {
   ToFile( "LINK",			 $CC,				 "e" );
 }
-ToFile( "ENVCFLAGSCXX",      "@ENVCFLAGSCXX@",    "e" );
-ToFile( "ENABLE_CRASHDUMP",  "@ENABLE_CRASHDUMP@","e" );
-ToFile( "WITH_GPC",          "@WITH_GPC@",      "e" );
-ToFile( "GXX_INCLUDE_PATH",  "@GXX_INCLUDE_PATH@","e" );
-ToFile( "COMMON_BUILD_TOOLS",$COMMON_BUILD_TOOLS, "e" );
+ToFile( "ENVCFLAGSCXX",      "@ENVCFLAGSCXX@",     "e" );
+ToFile( "ENABLE_CRASHDUMP",  "@ENABLE_CRASHDUMP@", "e" );
+ToFile( "WITH_GPC",          "@WITH_GPC@",         "e" );
+ToFile( "WITH_LIBART",       "@WITH_LIBART@",      "e" );
+ToFile( "LIBART_CFLAGS",     "@LIBART_CFLAGS@",    "e" );
+ToFile( "LIBART_LIBS",       "@LIBART_LIBS@",      "e" );
+ToFile( "GXX_INCLUDE_PATH",  "@GXX_INCLUDE_PATH@", "e" );
+ToFile( "COMMON_BUILD_TOOLS",$COMMON_BUILD_TOOLS,  "e" );
 if ($platform ne "$Winnt")
 {  ToFile( "TEMP",              $TEMP,              "e" );
    ToFile( "TMP",               $TEMP,              "e" );
Index: tools/util/makefile.mk
===================================================================
RCS file: /cvs/util/tools/util/makefile.mk,v
retrieving revision 1.10
diff -u -p -u -r1.10 makefile.mk
--- tools/util/makefile.mk	30 Apr 2003 08:25:57 -0000	1.10
+++ tools/util/makefile.mk	9 Jul 2003 09:24:29 -0000
@@ -191,7 +191,14 @@ SHL1TARGET=     tl$(VERSION)$(DLLPOSTFIX
 SHL1LIBS=       $(LIB1TARGET)
 SHL1DEF=        $(MISC)$/$(SHL1TARGET).def
 SHL1IMPLIB=     itools
-SHL1STDLIBS+=   $(SALLIB) $(VOSLIB) $(GPC3RDLIB)
+SHL1STDLIBS+=   $(SALLIB) $(VOSLIB)
+
+.IF "$(WITH_LIBART)"="YES"
+SHL1STDLIBS+=   $(LIBART_LIBS)
+.ELSE
+SHL1STDLIBS+=   $(GPC3RDLIB)
+.ENDIF
+
 
 .IF "$(GUI)"=="WNT"
 SHL1STDLIBS+=   shell32.lib     \
Index: tools/source/generic/makefile.mk
===================================================================
RCS file: /cvs/util/tools/source/generic/makefile.mk,v
retrieving revision 1.6
diff -u -p -u -r1.6 makefile.mk
--- tools/source/generic/makefile.mk	2 Jul 2003 14:21:12 -0000	1.6
+++ tools/source/generic/makefile.mk	9 Jul 2003 09:25:49 -0000
@@ -74,6 +74,10 @@ TARGET=gen
 .IF "$(WITH_GPC)"!="NO"
 CDEFS+=-DHAVE_GPC_H
 .ENDIF
+.IF "$(WITH_LIBART)"!="NO"
+CDEFS+=-DHAVE_LIBART_H
+CFLAGS+=$(LIBART_CFLAGS)
+.ENDIF
 
 # --- Files --------------------------------------------------------
 
Index: tools/inc/poly.hxx
===================================================================
RCS file: /cvs/util/tools/inc/poly.hxx,v
retrieving revision 1.2
diff -u -p -u -r1.2 poly.hxx
--- tools/inc/poly.hxx	27 Mar 2003 17:03:26 -0000	1.2
+++ tools/inc/poly.hxx	9 Jul 2003 10:46:54 -0000
@@ -280,10 +280,10 @@ private:
     ImplPolyPolygon*    mpImplPolyPolygon;
 
 #if _SOLAR__PRIVATE
-
-	void*				ImplCreateGPCPolygon() const;
-	void				ImplDoOperation( const PolyPolygon& rPolyPoly, PolyPolygon& rResult, ULONG nOperation ) const;
-
+    void *ImplCreateGPCPolygon() const;
+    void  ImplDoOperation( const PolyPolygon& rPolyPoly, PolyPolygon& rResult, ULONG nOperation ) const;
+    void *ImplCreateArtVpath() const;
+    void  ImplSetFromArtVpath( void *pVpath );
 #endif // __PRIVATE
 
 public:
Index: tools/source/generic/poly2.cxx
===================================================================
RCS file: /cvs/util/tools/source/generic/poly2.cxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 poly2.cxx
--- tools/source/generic/poly2.cxx	2 Jul 2003 14:21:27 -0000	1.3
+++ tools/source/generic/poly2.cxx	11 Jul 2003 11:50:02 -0000
@@ -61,24 +61,26 @@
 
 #define _SV_POLY2_CXX
 
-#ifdef HAVE_GPC_H
-
-#ifndef __gpc_h
-extern "C" 
+extern "C"
 {
-	#include <external/gpc/gpc.h> 
-}
-#endif
-
+#if defined (HAVE_GPC_H) && !defined (__gpc_h)
+#  include <external/gpc/gpc.h> 
 #else
-
-// No GPC
-#define GPC_INT 0
-#define GPC_UNION 0
-#define GPC_DIFF 0
-#define GPC_XOR 0
-
+#  ifdef HAVE_LIBART_H
+#    include <libart_lgpl/art_misc.h>
+#    include <libart_lgpl/art_vpath.h>
+#    include <libart_lgpl/art_svp.h>
+#    include <libart_lgpl/art_svp_vpath.h>
+#    include <libart_lgpl/art_vpath_svp.h>
+#    include <libart_lgpl/art_svp_ops.h>
+#    include <libart_lgpl/art_svp_intersect.h>
+#  endif
+#    define GPC_INT   0
+#    define GPC_UNION 1
+#    define GPC_DIFF  2
+#    define GPC_XOR   3
 #endif // HAVE_GPC_H
+}
 
 #include <cstring>
 #include <cmath>
@@ -366,7 +368,7 @@ void PolyPolygon::Optimize( ULONG nOptim
 		if( bEdges )
 		{
 			const Rectangle aBound( GetBoundRect() );
-		
+
 			fArea = ( aBound.GetWidth() + aBound.GetHeight() ) * 0.5;
 			nPercent = pData ? pData->GetPercentValue() : 50;
 			nOptimizeFlags &= ~POLY_OPTIMIZE_EDGES;
@@ -538,18 +540,246 @@ void PolyPolygon::ImplDoOperation( const
 }
 
 #else
-// No GPC implementation
+#ifdef HAVE_LIBART_H
 
-void* PolyPolygon::ImplCreateGPCPolygon() const
+/* Finds the index of the upper rightmost vertex of a polygon */
+static int
+upper_rightmost_vertex (const Polygon &poly)
+{
+	int n;
+	int i;
+	double x, y;
+	int k;
+
+	n = poly.GetSize ();
+
+	k = 0;
+	x = poly[0].X ();
+	y = poly[0].Y ();
+
+	for (i = 1; i < n; i++)
+		if (poly[i].Y () < y || (poly[0].Y () == y && poly[i].X () > x)) {
+			k = i;
+			x = poly[i].X ();
+			y = poly[i].Y ();
+		}
+
+	return k;
+}
+
+/* Returns whether a polygon is specified in counterclockwise order */
+static BOOL
+poly_is_ccw (const Polygon &poly)
+{
+	int n;
+	int k;
+	double cross;
+
+	n = poly.GetSize ();
+
+	if (n == 0)
+		return TRUE;
+
+	k = upper_rightmost_vertex (poly);
+
+	const Point &a = poly[(k + n - 1) % n];
+	const Point &b = poly[k];
+	const Point &c = poly[(k + 1) % n];
+
+	cross = -(a.X () * b.Y () - a.Y () * b.X () +
+		  a.Y () * c.X () - a.X () * c.Y () +
+		  b.X () * c.Y () - c.X () * b.Y ());
+
+  	return (cross > 0);
+}
+
+void *
+PolyPolygon::ImplCreateArtVpath () const
+{
+	ArtVpath *vpath;
+	int n_contours;
+	int n_vertices;
+	int i, v;
+
+	n_contours = Count ();
+	n_vertices = 0;
+	for (i = 0; i < n_contours; i++) {
+		const Polygon &poly = GetObject (i);
+		n_vertices += poly.GetSize () + 1; /* plus 1 for if we have to close the path */
+	}
+
+	n_vertices++; /* for the ART_END terminator */
+
+	vpath = art_new (ArtVpath, n_vertices);
+	v = 0;
+
+	for (i = 0; i < n_contours; i++) {
+		int j, k;
+		int n;
+		const Polygon &poly = GetObject (i);
+		BOOL ccw;
+
+		n = poly.GetSize ();
+
+		ccw = poly_is_ccw (poly);
+
+		/* Holes or inside contours need to be listed out in reverse
+		 * clockwise direction to the main outwards contour, but OO.o
+		 * does not seem to handle holes at all.  So we'll just list all
+		 * the contours as non-holes, e.g. in normal counterclockwise
+		 * order.
+		 */
+
+		if (ccw)
+			k = 0;
+		else
+			k = n - 1;
+
+		for (j = 0; j < n; j++) {
+			const Point &point = poly[k];
+			vpath[v].code = (j == 0) ? ART_MOVETO : ART_LINETO;
+			vpath[v].x = point.X ();
+			vpath[v].y = point.Y ();
+
+			if (ccw)
+				k++;
+			else
+				k--;
+
+			v++;
+		}
+
+		/* Close the path if needed */
+		if (n > 0 &&
+		    (vpath[v - 1].x != vpath[v - n].x ||
+		     vpath[v - 1].y != vpath[v - n].y)) {
+			vpath[v].code = ART_LINETO;
+			vpath[v].x = vpath[v - n].x;
+			vpath[v].y = vpath[v - n].y;
+			v++;
+		}
+	}
+
+	vpath[v].code = ART_END;
+
+	return vpath;
+}
+
+void
+PolyPolygon::ImplSetFromArtVpath (void *_vpath)
+{
+	ArtVpath *vpath;
+
+	vpath = (ArtVpath *) _vpath;
+
+	Clear ();
+
+	while (vpath->code != ART_END) {
+		ArtVpath *p;
+		int n, n_vertices;
+
+		n = 0;
+		for (p = vpath; n == 0 || p->code == ART_LINETO; p++)
+			n++;
+
+		/* Remove the last duplicated point from closed subpaths */
+		if (n > 0 &&
+		    vpath[n - 1].x == vpath[0].x &&
+		    vpath[n - 1].y == vpath[0].y)
+			n_vertices = n - 1;
+		else
+			n_vertices = n;
+
+		if (n_vertices != 0) {
+			int i;
+
+			Polygon poly (n_vertices);
+
+			p = vpath;
+			for (i = 0; i < n_vertices; i++) {
+				Point &point = poly[i];
+
+				point.X () = FRound (p->x);
+				point.Y () = FRound (p->y);
+
+				p++;
+			}
+
+			Insert (poly);
+		}
+
+		vpath += n;
+	}
+}
+
+/* Converts an arbitrary SVP to an even-odd SVP */
+static ArtSVP *
+svp_to_even_odd (ArtSVP *pSvp)
 {
-	return NULL;
+	ArtSVP *pResult;
+	ArtSvpWriter *pSvw;
+
+	pSvw = art_svp_writer_rewind_new( ART_WIND_RULE_ODDEVEN );
+	art_svp_intersector( pSvp, pSvw);
+
+ 	pResult = art_svp_writer_rewind_reap( pSvw );
+	/* Shallow free because the result contains shared segments */
+	art_free( pSvp );
+
+	return pResult;
 }
 
 void PolyPolygon::ImplDoOperation( const PolyPolygon& rPolyPoly, PolyPolygon& rResult, ULONG nOperation ) const
+{
+	ArtVpath *a, *b;
+	ArtSVP *sa, *sb, *s;
+
+	a = (ArtVpath *) ImplCreateArtVpath ();
+	b = (ArtVpath *) rPolyPoly.ImplCreateArtVpath ();
+
+	sa = svp_to_even_odd (art_svp_from_vpath (a));
+	sb = svp_to_even_odd (art_svp_from_vpath (b));
+
+	art_free (a);
+	art_free (b);
+
+	switch (nOperation) {
+	case GPC_UNION:
+		s = art_svp_union (sa, sb);
+		a = art_vpath_from_svp (s);
+		art_svp_free (s);
+		break;
+	case GPC_DIFF:
+		s = art_svp_minus (sa, sb);
+		a = art_vpath_from_svp (s);
+		art_svp_free (s);
+		break;
+	case GPC_XOR:
+		s = art_svp_diff (sa, sb); /* symmetric difference, *not* set difference */
+		a = art_vpath_from_svp (s);
+		art_svp_free (s);
+		break;
+	default:
+		/* Odd ... */
+	case GPC_INT:
+		s = art_svp_intersect (sa, sb);
+		a = art_vpath_from_svp (s);
+		art_svp_free (s);
+		break;
+	}
+
+
+	rResult.ImplSetFromArtVpath (a);
+	art_free (a);	
+}
+
+#else // No GPC or libart implementations
+
+void PolyPolygon::ImplDoOperation( const PolyPolygon& rPolyPoly, PolyPolygon& rResult, ULONG nOperation ) const
 { 
-	return;
 }
 
+#endif // HAVE_LIBART_H
 #endif // HAVE_GPC_H
 
 // -----------------------------------------------------------------------
