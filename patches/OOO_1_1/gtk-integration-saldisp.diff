Index: vcl/unx/source/app/saldisp.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/app/saldisp.cxx,v
retrieving revision 1.43.26.2
diff -u -p -u -r1.43.26.2 saldisp.cxx
--- vcl/unx/source/app/saldisp.cxx	29 Jul 2003 12:45:39 -0000	1.43.26.2
+++ vcl/unx/source/app/saldisp.cxx	21 Aug 2003 13:55:16 -0000
@@ -241,6 +241,11 @@ extern "C" {
 #  include <libsn/sn.h>
 #endif
 
+#ifndef DISABLE_GTK_INTEGRATION
+#  include <gdk/gdkx.h>
+#  include <gtk/gtk.h>
+#endif
+
 #include <postx.h>
 
 #include <salunx.h>
@@ -739,6 +744,60 @@ extern "C" {
 }
 #endif /* HAVE_LIBSN */
 
+#ifndef DISABLE_GTK_INTEGRATION
+
+extern "C" {
+    static GdkFilterReturn
+    sal_gdk_filter_func (GdkXEvent *sys_event,
+			 GdkEvent  *event,
+			 gpointer   data)
+    {
+        GdkFilterReturn retval;
+	XEvent *xevent = (XEvent *)sys_event;
+	SalDisplay *pDisplay = (SalDisplay *) data;
+	GdkDisplay *pGdkDisplay = (GdkDisplay *) pDisplay->GetGdkDisplay();
+
+	SalYieldMutex* pSalInstYieldMutex	=
+		GetSalData()->pFirstInstance_->maInstData.mpSalYieldMutex;
+
+	pSalInstYieldMutex->Grab();
+
+//	fprintf (stderr, "event type 0x%2x: ", xevent->type);
+//	if (pDisplay->GetDisplay() != xevent->xany.display)
+//            fprintf( stderr, "another display (%p): ", xevent->xany.display);
+
+	if (pDisplay->GetDisplay() != xevent->xany.display &&
+	    gdk_window_lookup_for_display (pGdkDisplay, xevent->xany.window)) {
+//	    fprintf( stderr, "GDK: Event on '%ld'\n", xevent->xany.window );
+	    retval = GDK_FILTER_CONTINUE;
+
+	} else {
+	    SalXEvent aEvent;
+	    aEvent.event_ = *xevent;
+
+//            fprintf( stderr, "VCL: Event on '%ld'\n", xevent->xany.window );
+
+	    pDisplay->DispatchXEvent( aEvent );
+
+	    if (pDisplay->GetDisplay() != xevent->xany.display)
+		    retval = GDK_FILTER_CONTINUE;
+	    else
+		    retval = GDK_FILTER_REMOVE;
+	}
+
+	pSalInstYieldMutex->UnGrab();
+
+	return retval;
+    }
+}
+
+struct _GdkDisplay *
+SalDisplay::GetGdkDisplay()
+{
+	return gdk_x11_lookup_xdisplay( pDisp_ );
+}
+#endif /* DISABLE_GTK_INTEGRATION */
+
 SalDisplay::SalDisplay( Display *display, Visual *pVisual, Colormap aColMap ) : 
 		pDisp_( display ),
 		mpFallbackFactory ( NULL ),
@@ -760,6 +819,10 @@ SalDisplay::SalDisplay( Display *display
 #endif
     nScreen_  = DefaultScreen( pDisp_ );
 
+#ifndef DISABLE_GTK_INTEGRATION
+	gdk_window_add_filter( NULL, sal_gdk_filter_func, this );
+#endif
+
 	if (!aColMap)
 		aColMap = DefaultColormap( display, nScreen_ );
     if( !IsDisplay() && !aColMap)
@@ -834,6 +897,12 @@ SalDisplay::~SalDisplay( )
 
 		delete mpInputMethod;
 		delete mpKbdExtension;
+
+#ifndef DISABLE_GTK_INTEGRATION
+	gdk_window_remove_filter( NULL, sal_gdk_filter_func, this );
+	g_object_unref( GetGdkDisplay() );
+#endif
+
         XCloseDisplay( pDisp_ );
     }
 
@@ -2554,13 +2634,41 @@ BOOL SalDisplay::IsEvent()
     if( pEventQueue_ )
         return TRUE;
 
+#ifdef DISABLE_GTK_INTEGRATION
     if( XEventsQueued( pDisp_, QueuedAlready ) )
         return TRUE;
 
     XFlush( pDisp_ );
+#endif
     return FALSE;
 }
 
+
+#ifndef DISABLE_GTK_INTEGRATION
+void SalDisplay::DispatchXEvent( SalXEvent &rEvent )
+{
+    nStateOfYield_ = 0;
+    BOOL bIgnoreXErrors = pXLib_->GetIgnoreXErrors();
+ 
+    rEvent.pNext_   = pDispatchStack_;
+    pDispatchStack_ = &rEvent;
+ 
+    Dispatch( &rEvent.event_ );
+ 
+    pDispatchStack_ = rEvent.pNext_;
+ 
+#ifdef DBG_UTIL
+    if( pXLib_->WasXError() )
+    {
+	XFlush( pDisp_ );
+	PrintEvent( "SalDisplay::Yield (WasXError)", &rEvent.event_ );
+    }
+#endif
+ 
+    pXLib_->SetIgnoreXErrors( bIgnoreXErrors );
+}
+#endif
+
 // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 
 void SalDisplay::Yield( BOOL bWait )
@@ -2601,6 +2709,15 @@ void SalDisplay::Yield( BOOL bWait )
 				   NAMESPACE_VOS(OThread)::getCurrentIdentifier(),
 					"will crash soon since solar mutex not locked in SalDisplay::Yield" );
 		
+#ifndef DISABLE_GTK_INTEGRATION
+		nStateOfYield_ = 0;
+		return; // Handled later by gdk.
+    } // while
+    DispatchXEvent( aEvent );
+#else
+       // note: alternate input is dispatched by XtAppNextEvent
+       XNextEvent( pDisp_, &aEvent.event_ );
+
 		// note: alternate input is dispatched by XtAppNextEvent
 		XNextEvent( pDisp_, &aEvent.event_ );		
 
@@ -2637,6 +2755,7 @@ void SalDisplay::Yield( BOOL bWait )
 #endif
 
     pXLib_->SetIgnoreXErrors( bIgnoreXErrors );
+#endif /* DISABLE_GTK_INTEGRATION */
 }
 
 long SalDisplay::Dispatch( XEvent *pEvent )
Index: vcl/unx/inc/saldisp.hxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/inc/saldisp.hxx,v
retrieving revision 1.16.104.1
diff -u -p -u -r1.16.104.1 saldisp.hxx
--- vcl/unx/inc/saldisp.hxx	21 Jul 2003 14:48:42 -0000	1.16.104.1
+++ vcl/unx/inc/saldisp.hxx	21 Aug 2003 13:55:29 -0000
@@ -279,7 +279,11 @@ class SalXLib
     int				nFDs_;
     fd_set	        aReadFDS_;
     fd_set	        aExceptionFDS_;
+#ifndef DISABLE_GTK_INTEGRATION
     YieldEntry		*pYieldEntries_;
+#else
+    struct _GList       *pSources;
+#endif
 
 public:
     SalXLib();
@@ -428,6 +432,11 @@ public:
 										Colormap aColMap = None);
     
     ~SalDisplay();
+
+#ifndef DISABLE_GTK_INTEGRATION
+    void                        DispatchXEvent( SalXEvent &rEvent );
+    struct _GdkDisplay         *GetGdkDisplay();
+#endif
     
     void			Init( Colormap hXColmap, const XVisualInfo* pXVI );
     
