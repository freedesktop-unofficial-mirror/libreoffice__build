--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ sc/source/filter/qpro/qpro.cxx	2004-12-15 14:43:15.017599352 +0530
@@ -0,0 +1,420 @@
+#ifdef PCH
+#include "filt_pch.hxx"
+#endif
+
+#pragma hdrstop
+
+//------------------------------------------------------------------------
+
+#include <stdio.h>
+#include <sfx2/docfile.hxx>
+#include <rtl/math.hxx>
+
+
+#include "qproform.hxx"
+#include "qpro.hxx"
+
+#include <tools/color.hxx>
+#include "scitems.hxx"
+#include <svx/algitem.hxx>
+#include <svx/align.hxx>
+#include <svx/udlnitem.hxx>
+#include <svx/wghtitem.hxx>
+#include <svx/postitem.hxx>
+#include <svx/crsditem.hxx>
+#include <svx/fhgtitem.hxx>
+#include <svx/fontitem.hxx>
+#include <svx/colritem.hxx>
+#include <map>
+
+#include "global.hxx"
+#include "sc.hrc" 
+#include "globstr.hrc"
+#include "attrib.hxx"
+#include "stlsheet.hxx"
+#include "stlpool.hxx"
+#include "docpool.hxx" 
+#include "patattr.hxx"
+#include "flttools.hxx"
+#include "filter.hxx"
+#include "scerrors.hxx"
+#include "document.hxx"
+#include "cell.hxx"
+#include "math.h"
+
+extern std::map<UINT16, ScPatternAttr> aPatternPool;
+
+BiffReader::BiffReader( SfxMedium & rMedium ) :
+               mnId(0),
+               mnLength(0),
+               mnOffset(0),
+               meCharSet( RTL_TEXTENCODING_ISO_8859_1 ) // FIXME detect as we parse
+{
+       mpStream = rMedium.GetInStream();
+       if( mpStream )
+               mpStream->SetBufferSize( 65536 );
+}
+
+BiffReader::~BiffReader()
+{
+       if( mpStream )
+               mpStream->SetBufferSize( 0 );
+}
+
+SvStream& BiffReader::operator>>( sal_uInt8 &rByte )
+{
+       *mpStream >> rByte;
+}
+
+SvStream& BiffReader::operator>>( sal_Int8 &rByte )
+{
+       *mpStream >> rByte;
+}
+
+SvStream& BiffReader::operator>>(sal_uInt16 &rWord)
+{
+       *mpStream >> rWord;
+}
+
+bool BiffReader::nextRecord()
+{
+       if( !recordsLeft() )
+               return false;
+
+       if( EndOfFile )
+               return false;
+
+       sal_uInt32 nPos = mpStream->Tell();
+       if( nPos != mnOffset + mnLength )
+               mpStream->Seek( mnOffset + mnLength );
+
+       mnLength = mnId = 0;
+       *mpStream >> mnId >> mnLength;
+
+       mnOffset = mpStream->Tell();
+#ifdef DEBUG
+       fprintf( stderr, "Read record 0x%x length 0x%x at offset 0x%x\n",
+                        mnId, mnLength, mnOffset );
+
+ #if 1  // rather verbose
+       int len = mnLength;
+       while (len > 0) {
+               int i, chunk = len < 16 ? len : 16;
+               unsigned char data[16];
+               mpStream->Read( data, chunk );
+
+               for (i = 0; i < chunk; i++)
+                       fprintf( stderr, "%.2x ", data[i] );
+               fprintf( stderr, "| " );
+               for (i = 0; i < chunk; i++)
+                       fprintf( stderr, "%c", data[i] < 127 && data[i] > 30 ? data[i] : '.' );
+               fprintf( stderr, "\n" );
+
+               len -= chunk;
+       }
+       mpStream->Seek( mnOffset );
+#endif 
+#endif
+       return true;
+}
+
+void BiffReader::readString( String &rString, sal_uInt16 nLength )
+{
+       sal_Char* pText = new sal_Char[ nLength + 1 ];
+       mpStream->Read( pText, nLength );
+       pText[ nLength ] = 0;
+       rString = String( pText, meCharSet );
+}
+
+void BiffReader::SetFormat( ScDocument *pDoc, sal_uInt8 nCol, sal_uInt16 nRow, sal_uInt8 nTab, sal_uInt16 nStyle ){
+       ScPatternAttr aPattern(pDoc->GetPool()); 
+       SfxItemSet& rItemSet = aPattern.GetItemSet();
+       
+       sal_uInt8 nTmp = Align[ nStyle ];
+       sal_uInt8 nHor = ( nTmp & 0x07 );
+       sal_uInt8 nVer = ( nTmp & 0x18 );
+       sal_uInt8 nOrient = ( nTmp & 0x60 );
+ 
+
+       // Horizontal Alignment
+       SvxHorJustifyItem ejustify = SVX_HOR_JUSTIFY_STANDARD;
+       switch( nHor )
+       {
+
+            case 0x00:
+                       ejustify = SVX_HOR_JUSTIFY_STANDARD;
+                       break;
+  
+            case 0x01: 
+                       ejustify = SVX_HOR_JUSTIFY_LEFT;
+                       break;
+  
+            case 0x02: 
+                       ejustify = SVX_HOR_JUSTIFY_CENTER;
+                       break;
+
+            case 0x03:
+                       ejustify = SVX_HOR_JUSTIFY_RIGHT;
+                       break;
+ 
+            case 0x04: 
+                       ejustify = SVX_HOR_JUSTIFY_BLOCK;
+                       break;
+
+         }
+	  rItemSet.Put( ejustify );
+
+	// Vertical Alignment
+        SvxVerJustifyItem verJustify = SVX_VER_JUSTIFY_STANDARD;
+        switch( nVer )
+        {
+         
+           case 0x00:
+                     verJustify = SVX_VER_JUSTIFY_BOTTOM;
+                     break;
+            
+           case 0x08:
+                     verJustify = SVX_VER_JUSTIFY_CENTER;
+                     break; 
+           
+           case 0x10:
+                     verJustify = SVX_VER_JUSTIFY_TOP;
+                     break;
+      
+         }
+         rItemSet.Put( verJustify ); 
+         
+	 // Orientation
+         SvxOrientationItem orientItem = SVX_ORIENTATION_STANDARD;
+         switch( nOrient )
+         {
+
+           case 0x20: 
+                      orientItem = SVX_ORIENTATION_TOPBOTTOM;
+                      break;
+ 
+         } 
+	 rItemSet.Put( orientItem );
+
+        // Wrap cell contents
+        if( nTmp & 0x80 )
+        {
+            SfxBoolItem WrapItem( ATTR_LINEBREAK );
+            WrapItem.SetValue( TRUE );
+            rItemSet.Put( WrapItem );
+        }
+
+        // Font Attributes
+	sal_uInt16 nTmpFnt = FontRecord[ Font[ nStyle ] ];
+        BOOL bIsBold, bIsItalic, bIsUnderLine, bIsStrikeThrough;
+
+        bIsBold = ( nTmpFnt & 0x0001 );
+        bIsItalic = ( nTmpFnt & 0x0002 );
+        bIsUnderLine = ( nTmpFnt & 0x0004 );
+        bIsStrikeThrough = (nTmpFnt & 0x0020 );
+
+        if( bIsBold )
+             rItemSet.Put( SvxWeightItem( WEIGHT_BOLD,ATTR_FONT_WEIGHT) );
+        if( bIsItalic )
+             rItemSet.Put( SvxPostureItem( ITALIC_NORMAL, ATTR_FONT_POSTURE ) );
+        if( bIsUnderLine )
+             rItemSet.Put( SvxUnderlineItem( UNDERLINE_SINGLE, ATTR_FONT_UNDERLINE ) );
+        if( bIsStrikeThrough )
+             rItemSet.Put( SvxCrossedOutItem( STRIKEOUT_SINGLE, ATTR_FONT_CROSSEDOUT ) ); 
+     
+	String fntName = FontType[ Font[ nStyle ] ];
+        rItemSet.Put( SvxFontItem( FAMILY_SYSTEM, fntName, EMPTY_STRING ) );
+
+	pDoc->ApplyPattern( nCol, nRow, nTab, aPattern );
+} 
+
+ColorData BiffReader::MapIntToColor( sal_uInt16 ColorId )
+{
+       ColorData fColor;
+       switch( ColorId )
+       {
+               case 0x0000: fColor = COL_WHITE;
+                             break;
+  
+               case 0x1000: fColor = COL_LIGHTGRAY;
+                             break;
+
+               case 0x2000: fColor = COL_GRAY;
+                             break;
+
+               case 0x3000: fColor = COL_BLACK;
+                             break;
+
+               case 0x4000: fColor = COL_RED;
+                             break;
+   
+                case 0x5000: fColor = COL_GREEN;
+                             break;
+
+               case 0x6000: fColor = COL_BLUE;
+                            break;
+
+               case 0x7000: fColor = COL_CYAN;
+                             break;
+
+               case 0x8000: fColor = COL_MAGENTA;
+                             break;
+
+               case 0x9000: fColor = COL_YELLOW;
+                             break;
+
+               case 0xb000: fColor = COL_LIGHTGREEN;
+                             break;
+        }
+       
+       return fColor;
+}
+      
+readQProSheet( BiffReader &rReader, ScDocument *pDoc, sal_uInt16 nTab )
+{
+       sal_uInt8  nCol, nDummy;
+       sal_uInt16 nRow;
+       sal_uInt16 nStyle;
+       bool bEndOfSheet = false;
+
+#ifdef DEBUG
+       fprintf( stderr, "Read sheet (%d)\n", nTab );
+#endif
+
+       while( !bEndOfSheet && rReader.nextRecord() ) {
+               switch( rReader.getId() )
+               {
+               case 0x000f: { // Label cell
+                       String aLabel;
+                       rReader >> nCol >> nDummy >> nRow >> nStyle >> nDummy;
+                       rReader.readString( aLabel, rReader.getLength() - 7 );
+#ifdef DEBUG
+                       fprintf( stderr, "Put Cell %d %d %d '%s'\n",
+                                        nCol, nRow, nTab,
+                                        (const sal_Char *)rtl::OUStringToOString( aLabel, RTL_TEXTENCODING_UTF8 ) );
+#endif
+                       nStyle = ( nStyle & 0xfff8 ) >> 3;
+                       rReader.SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+                       pDoc->PutCell( nCol, nRow, nTab, new ScStringCell( aLabel ), (BOOL) TRUE );
+                       break;
+               }
+               case 0x00cb: // End of sheet;
+                       bEndOfSheet = true;
+                       break;
+		
+               case 0x000c: // Blank cell
+                        rReader >> nCol >> nDummy >> nRow >> nStyle; 
+                        rReader.SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+			break; 
+               
+               case 0x000d:  { // Integer cell
+			sal_uInt16 nValue;
+			rReader >> nCol >> nDummy >> nRow >> nStyle >> nValue;	
+ 			ScValueCell* aInteger = new ScValueCell( ( double ) nValue ); 
+#ifdef DEBUG
+                        fprintf( stderr, "Put Cell %d %d %d %f\n", nCol, nRow, nTab, nValue );
+#endif
+			rReader.SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+			pDoc->PutCell(nCol ,nRow, nTab ,aInteger,(BOOL) TRUE);
+                        break;
+                       }
+
+               case 0x000e: { // Floating point cell
+                        double nValue;
+                        rReader >> nCol >> nDummy >> nRow >> nStyle >> nValue;
+                        ScValueCell* aFloat = new ScValueCell( nValue );
+#ifdef DEBUG
+                        fprintf( stderr, "Put Cell %d %d %d %f\n", nCol, nRow, nTab, nValue );
+#endif
+                        rReader.SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+			pDoc->PutCell( nCol, nRow, nTab, aFloat, (BOOL) TRUE );
+                       } 
+
+	       case 0x0010: { // Formula cell
+                        double nValue;
+                        sal_uInt16 nState, nLen; 
+                        rReader >> nCol >> nDummy >> nRow >> nStyle >> nValue >> nState >> nLen;
+                        ScAddress aAddr( nCol, nRow, nTab );
+                        const ScTokenArray *pErg;
+                        QProToSc aConv( rReader );
+                        aConv.Reset( aAddr );
+                        aConv.Convert( pErg, nLen );
+                        ScFormulaCell *pZelle = new ScFormulaCell( pDoc, aAddr, pErg );
+#ifdef DEBUG
+                        fprintf( stderr, "Put Cell %d %d %d %f\n", nCol, nRow, nTab, nValue );
+#endif
+                        pZelle->AddRecalcMode( RECALCMODE_ONLOAD_ONCE );
+			rReader.SetFormat( pDoc, nCol, nRow, nTab, nStyle );
+                        pDoc->PutCell( nCol, nRow, nTab, pZelle, ( BOOL ) TRUE );
+			break; } 
+    
+	       }
+       }
+       return eERR_OK;
+}
+
+FltError ScImportQuattroPro( SfxMedium &rMedium, ScDocument *pDoc )
+{
+       FltError   eRet = eERR_OK;
+       BiffReader aReader( rMedium );
+       sal_uInt16 nVersion;
+       int nTab = 0, i = 1, j = 1;
+       aReader.EndOfFile = FALSE;
+
+       if( !aReader.recordsLeft() )
+               return eERR_OPEN;
+
+       while( aReader.nextRecord() && eRet == eERR_OK) {
+               switch( aReader.getId() )
+               {
+               case 0x0000: // Begginning of file
+                       aReader >> nVersion;
+                       break;
+
+               case 0x00ca: // Beginning of sheet
+                       if( nTab < 26 )
+                       {
+                               String aName;
+                               aName.Append( sal_Unicode( 'A' + nTab ) );
+                               pDoc->InsertTab( nTab, aName );
+                       }
+                       eRet = readQProSheet( aReader, pDoc, nTab );
+                       nTab++;
+                       break;
+
+               case 0x0001: // End of file
+                       aReader.EndOfFile = TRUE;
+                       break;
+          
+               case 0x00ce: { // Attribute cell
+                       sal_uInt8 nFormat, nAlign, nFont;
+                       sal_Int16 nTextColor, nColor;
+                       aReader >> nFormat >> nAlign >> nColor >> nFont;
+                       aReader.Align[ i ] = nAlign;
+                       aReader.Font[ i ] = nFont;
+                       nTextColor = nColor & 0xf000;
+                       aReader.FontColor[ i ] = nTextColor;
+                       i++;
+                       break;
+                       }
+                                                                                                                  
+                case 0x00cf: { // Font description
+                      sal_uInt16 nPtSize, nFontAttr;
+		      String Label;
+                      aReader >> nPtSize >> nFontAttr;
+                      aReader.FontSize[ j ] = nPtSize;
+                      aReader.FontRecord[ j ] = nFontAttr;
+                      aReader.readString( Label, aReader.getLength() - 4 );
+                      aReader.FontType[ j ] = Label;
+                      j++;
+                      break;
+                     }
+
+               }
+       }
+       pDoc->CalcAfterLoad();
+       return eRet;
+}
+
+
+
