diff -u -p -r1.9.232.1 makefile.mk
--- vcl/unx/source/app/makefile.mk	21 Jul 2003 14:48:43 -0000	1.9.232.1
+++ vcl/unx/source/app/makefile.mk	12 Aug 2003 17:37:51 -0000
@@ -95,6 +95,7 @@ SLOFILES=\
 			$(SLO)$/i18n_keysym.obj		\
 			$(SLO)$/salmain.obj			\
 			$(SLO)$/saldata.obj			\
+			$(SLO)$/salgxlib.obj			\
 			$(SLO)$/saltimer.obj		\
 			$(SLO)$/saldisp.obj			\
 			$(SLO)$/salinst.obj			\
@@ -110,6 +111,8 @@ SLOFILES=\
 			$(SLO)$/stacktrace.obj		\
 			$(SLO)$/keysymnames.obj		\
 			$(SLO)$/wmadaptor.obj
+
+CFLAGS+=`pkg-config --cflags glib-2.0`
 
 .IF "$(WITH_LIBSN)"=="YES"
 CDEFS+=-DHAVE_LIBSN
--- /dev/null	2002-08-31 00:31:37.000000000 +0100
+++ vcl/unx/source/app/salgxlib.cxx	2003-08-19 17:07:27.000000000 +0100
@@ -0,0 +1,171 @@
+#ifndef _SV_SALDISP_HXX
+#include <saldisp.hxx>
+#endif
+#ifndef _SV_SALDATA_HXX
+#include <saldata.hxx>
+#endif
+
+#include <glib.h>
+
+typedef struct {
+	GSource       source;
+
+	GPollFD       pollfd;
+	GIOCondition  condition;
+	
+	YieldFunc     pending;
+	YieldFunc     handle;
+	gpointer      user_data;
+} SalWatch;
+
+extern "C" {
+
+static gboolean 
+sal_source_prepare (GSource *source,
+		    gint    *timeout)
+{
+	SalWatch *watch = (SalWatch *)source;
+
+	*timeout = -1;
+
+	if (watch->pending &&
+	    watch->pending (watch->pollfd.fd, watch->user_data)) {
+		watch->pollfd.revents |= watch->condition;
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static gboolean 
+sal_source_check (GSource *source)
+{
+	SalWatch *watch = (SalWatch *)source;
+
+	return watch->pollfd.revents & watch->condition;
+}
+
+static gboolean
+sal_source_dispatch (GSource    *source,
+		     GSourceFunc callback,
+		     gpointer    user_data)
+{
+	SalData *pSalData = GetSalData();
+	SalWatch *watch = (SalWatch *) source;
+
+	pSalData->pFirstInstance_->maInstData.mpSalYieldMutex->acquire();
+
+	watch->handle (watch->pollfd.fd, watch->user_data);
+
+	pSalData->pFirstInstance_->maInstData.mpSalYieldMutex->release();
+
+	return TRUE;
+}
+
+static void
+sal_source_finalize (GSource *source)
+{
+}
+
+static GSourceFuncs sal_source_watch_funcs = {
+	sal_source_prepare,
+	sal_source_check,
+	sal_source_dispatch,
+	sal_source_finalize
+};
+
+static GSource *
+sal_source_create_watch (int           fd,
+			 GIOCondition  condition,
+			 YieldFunc     pending,
+			 YieldFunc     handle,
+			 gpointer      user_data)
+{
+	GSource      *source;
+	SalWatch     *watch;
+	GMainContext *context = g_main_context_default ();
+
+	source = g_source_new (&sal_source_watch_funcs,
+			       sizeof (SalWatch));
+	watch = (SalWatch *) source;
+
+	watch->pollfd.fd     = fd;
+	watch->pollfd.events = condition;
+	watch->condition = condition;
+	watch->pending   = pending;
+	watch->handle    = handle;
+	watch->user_data = user_data;
+
+	g_source_set_can_recurse (source, TRUE);
+	g_source_add_poll (source, &watch->pollfd);
+	g_source_attach (source, context);
+
+	return source;
+}
+static gboolean
+dummy_fn (gpointer data)
+{
+	return FALSE;
+}
+
+} // extern "C"
+
+void SalXLib::Insert( int       nFD,
+		      void     *data,
+		      YieldFunc pending,
+		      YieldFunc queued,
+		      YieldFunc handle )
+{
+	GSource *source = sal_source_create_watch
+		( nFD, (GIOCondition) ((G_IO_IN|G_IO_PRI) |
+				       (G_IO_ERR|G_IO_HUP|G_IO_NVAL)),
+		  pending, handle, data);
+	pSources = g_list_prepend (pSources, source);
+}
+
+void SalXLib::Remove( int nFD )
+{
+	GList *l;
+
+	for (l = pSources; l; l = l->next) {
+		SalWatch *watch = (SalWatch *)l->data;
+
+		if (watch->pollfd.fd == nFD) {
+			pSources = g_list_delete_link (pSources, l);
+
+			g_source_destroy ((GSource *)watch);
+			g_source_unref   ((GSource *)watch);
+			return;
+		}
+	}
+}
+
+void SalXLib::Yield( BOOL bWait )
+{
+	timeval thisTimeout = { 0 };
+
+	if (bWait) {
+		if (Timeout_.tv_sec) {
+			// determine remaining timeout.
+			gettimeofday (&thisTimeout, 0);
+			thisTimeout = Timeout_ - thisTimeout;
+		}
+	}
+	guint wait_ms = (thisTimeout.tv_usec + 900)/1000 + thisTimeout.tv_sec * 1000;
+	if (wait_ms > 0)
+		g_timeout_add (wait_ms, dummy_fn, NULL);
+
+//	fprintf (stderr, "Wait (%d) %dms ", bWait, wait_ms);
+	{
+		YieldMutexReleaser aReleaser;
+		g_main_context_iteration (NULL, bWait);
+	}
+//	fprintf (stderr, " done\n");
+
+	CheckTimeout();
+}
+
+void SalXLib::Wakeup()
+{
+	g_main_context_wakeup (g_main_context_default ());
+}
