Index: tools/bootstrp/static.mk
===================================================================
RCS file: /cvs/util/tools/bootstrp/Attic/static.mk,v
retrieving revision 1.26.46.1
diff -u -p -r1.26.46.1 static.mk
--- tools/bootstrp/static.mk	28 Jan 2004 10:54:08 -0000	1.26.46.1
+++ tools/bootstrp/static.mk	26 Aug 2004 15:01:26 -0000
@@ -141,6 +141,7 @@ STATIC_LIBS		+=	-lX11 -lXext 
 .ELSE
 STATIC_LIBS		+=	-lsupc++ -lX11 -lXext 
 .ENDIF
+STATIC_LIBS             += `pkg-config --libs gnome-vfs-2.0`
 .ENDIF
 
 # -----------------------------------------------------------
Index: tools/source/fsys/makefile.mk
===================================================================
RCS file: /cvs/util/tools/source/fsys/makefile.mk,v
retrieving revision 1.7
diff -u -p -r1.7 makefile.mk
--- tools/source/fsys/makefile.mk	30 Apr 2003 08:25:46 -0000	1.7
+++ tools/source/fsys/makefile.mk	26 Aug 2004 15:01:59 -0000
@@ -101,6 +101,8 @@ OBJFILES=   $(OBJ)$/wldcrd.obj   \
             $(OBJ)$/tdir.obj	\
             $(OBJ)$/urlobj.obj
 
+CFLAGS+=`pkg-config --cflags gnome-vfs-2.0`
+
 # --- Targets ------------------------------------------------------
 
 .INCLUDE :  target.mk

Index: tools/util/makefile.mk
===================================================================
RCS file: /cvs/util/tools/util/makefile.mk,v
retrieving revision 1.11.12.1
diff -u -p -r1.11.12.1 makefile.mk
--- tools/util/makefile.mk	15 Aug 2003 11:30:50 -0000	1.11.12.1
+++ tools/util/makefile.mk	26 Aug 2004 15:02:41 -0000
@@ -213,6 +213,10 @@ SHL1STDLIBS+=   shell32.lib     \
                 uuid.lib        \
                 advapi32.lib
 .ENDIF
+.IF "$(GUI)"=="UNX"
+SHL1STDLIBS+=`pkg-config --libs gnome-vfs-2.0`
+.ENDIF
+
 
 DEF1NAME        =$(SHL1TARGET)
 DEF1DEPN = \

Index: tools/source/fsys/urlobj.cxx
===================================================================
RCS file: /cvs/util/tools/source/fsys/urlobj.cxx,v
retrieving revision 1.40
diff -u -w -r1.40 urlobj.cxx
--- tools/source/fsys/urlobj.cxx	22 May 2003 08:45:17 -0000	1.40
+++ tools/source/fsys/urlobj.cxx	27 Aug 2004 10:00:06 -0000
@@ -107,6 +107,16 @@
 #define INCLUDED_LIMITS
 #endif
 
+#ifndef _VOS_MUTEX_HXX
+#include <vos/mutex.hxx>
+#endif
+
+#include <stdio.h>
+#include <signal.h>
+
+#include <libgnomevfs/gnome-vfs.h>
+
+
 namespace unnamed_tools_urlobj {} using namespace unnamed_tools_urlobj;
 	// unnamed namespaces don't work well yet...
 
@@ -393,6 +403,8 @@
 };
 
 //============================================================================
+static INetURLObject::SchemeInfo *vfs_schemeinfo_map = NULL;
+
 static INetURLObject::SchemeInfo const aSchemeInfoMap[INET_PROT_END]
 	= { { "", "", 0, false, false, false, false, false, false, false,
 		  false },
@@ -459,6 +471,9 @@
 inline INetURLObject::SchemeInfo const &
 INetURLObject::getSchemeInfo(INetProtocol eTheScheme)
 {
+   if (eTheScheme >= INET_PROT_END)
+     return vfs_schemeinfo_map [eTheScheme - INET_PROT_END];
+   else
 	return aSchemeInfoMap[eTheScheme];
 };
 
@@ -720,6 +735,10 @@
 	// Parse <scheme>:
 	sal_Unicode const * p = pPos;
 	PrefixInfo const * pPrefix = getPrefix(p, pEnd);
+	::rtl::OString tmpStr (rTheAbsURIRef.GetBuffer (),
+			       rTheAbsURIRef.Len (),
+			       RTL_TEXTENCODING_UTF8);
+       
 	if (pPrefix)
 	{
 		pPos = p;
@@ -1329,14 +1348,17 @@
 				case INET_PROT_LDAP:
 					if (pHostPortBegin == pPort && pPort != pHostPortEnd)
 					{
+//			  fprintf (stderr, "bogus port 0\n");
 						setInvalid();
 						return false;
 					}
 					break;
 
 				default:
-					if (pHostPortBegin == pPort)
+				        if (m_eScheme < INET_PROT_END && /* else might have a port */
+					    pHostPortBegin == pPort)
 					{
+//			  fprintf (stderr, "bogus port\n");
 						setInvalid();
 						return false;
 					}
@@ -2082,13 +2104,91 @@
 			{ "vnd.sun.star.wfs:", 0, INET_PROT_VND_SUN_STAR_WFS,
 			  PrefixInfo::OFFICIAL },
 			{ "wfs:", "vnd.sun.star.wfs:", INET_PROT_VND_SUN_STAR_WFS,
-			  PrefixInfo::ALIAS } };
-	PrefixInfo const * pFirst = aMap + 1;
-	PrefixInfo const * pLast = aMap + sizeof aMap / sizeof (PrefixInfo) - 1;
-	PrefixInfo const * pMatch = 0;
-	sal_Unicode const * pMatched = rBegin;
-	sal_Unicode const * p = rBegin;
-	xub_StrLen i = 0;
+			  PrefixInfo::ALIAS }
+		};
+
+static GHashTable *fast_lookup = NULL;
+	int i;
+	static int vfs_map_size=0;
+
+	::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+	if (!gnome_vfs_initialized ())
+		gnome_vfs_init ();      
+		
+	if (!fast_lookup) {
+
+		fast_lookup = g_hash_table_new (g_str_hash, g_str_equal);
+		for (i = 1; i < G_N_ELEMENTS (aMap); i++)
+			g_hash_table_insert (fast_lookup, (void *) aMap[i].m_pPrefix,
+           			     (void *) (aMap + i));
+	}
+	
+	char *rstr;
+	const int max_vfs_schemes = 256; 
+	int  length_to_colon;
+
+	rstr = ( char * )g_alloca( pEnd - rBegin + 4 );
+
+	for( i = 0; i < pEnd - rBegin && rBegin [i] != ':'; i++)  
+		    rstr[i] = INetMIME::toLowerCase( rBegin [i] );
+
+
+       length_to_colon = i;
+
+       rstr[i++] = ':';
+	   rstr[i] = '\0';
+	
+	PrefixInfo *pi;
+
+	if( !( pi = ( PrefixInfo * )g_hash_table_lookup( fast_lookup, rstr ) ) )
+	{	
+		GnomeVFSURI* pUri;
+
+		rstr[i++]='/'; rstr[i++]='/';
+		rstr[i] = '\0';
+
+		if( ( pUri = gnome_vfs_uri_new( rstr ) ) &&
+			strcmp( gnome_vfs_uri_get_scheme( pUri ), "file" ) != 0 )
+		{                              
+			pi = new PrefixInfo; 
+			pi->m_pPrefix = g_strndup( rstr, length_to_colon + 1 );
+			pi->m_pTranslatedPrefix = NULL;
+			pi->m_eScheme = ( INetProtocol )( vfs_map_size + INET_PROT_END );
+			pi->m_eKind = PrefixInfo::OFFICIAL;
+		  	g_hash_table_insert ( fast_lookup, ( void * )pi->m_pPrefix, ( void * )pi );   			              
+			
+			if( ! vfs_schemeinfo_map )
+				vfs_schemeinfo_map = g_new0( INetURLObject::SchemeInfo, max_vfs_schemes );
+			
+			if( vfs_map_size < max_vfs_schemes )
+			{
+				vfs_schemeinfo_map[vfs_map_size].m_pScheme = g_strndup( rstr, length_to_colon );
+				vfs_schemeinfo_map[vfs_map_size].m_pPrefix = g_strdup( rstr );
+				vfs_schemeinfo_map[vfs_map_size].m_nDefaultPort = 0;
+				vfs_schemeinfo_map[vfs_map_size].m_bAuthority = true;
+				vfs_schemeinfo_map[vfs_map_size].m_bUser = false;
+				vfs_schemeinfo_map[vfs_map_size].m_bAuth = false;
+				vfs_schemeinfo_map[vfs_map_size].m_bPassword = false;
+				vfs_schemeinfo_map[vfs_map_size].m_bHost = true;
+				vfs_schemeinfo_map[vfs_map_size].m_bPort = false;
+				vfs_schemeinfo_map[vfs_map_size].m_bHierarchical = true;
+				vfs_schemeinfo_map[vfs_map_size].m_bQuery = false;								
+				vfs_map_size++;
+			}	   		 				 
+			else
+				g_warning( "Number of URI schemes exceeded maximum allocated value" );
+
+			gnome_vfs_uri_unref( pUri );
+       	}		
+	}
+       		
+	if( pi )
+		  rBegin += length_to_colon+1 ;
+
+	return pi;
+
+
+#ifdef OVER_COMPLICATED_CODE
 	for (; pFirst < pLast; ++i)
 	{
 		if (pFirst->m_pPrefix[i] == '\0')
@@ -2120,7 +2220,9 @@
 		}
 	}
 	rBegin = pMatched;
+
 	return pMatch;
+#endif
 }
 
 //============================================================================
@@ -2359,7 +2461,7 @@
 			break;
 
 		default:
-			if (aSynHost.Len() == 0)
+			if (aSynHost.Len() == 0 && m_eScheme < INET_PROT_END)
 				return false;
 			break;
 	}
@@ -2436,6 +2538,7 @@
 				aTheSynPath = '/';
 			break;
 
+		default: /* All INET_PROT_END+ drop through here */
 		case INET_PROT_FILE:
 		case INET_PROT_VND_SUN_STAR_WFS:
 		{
@@ -3618,7 +3721,8 @@
 					break;
 
 				default:
-					if (aSynHost.Len() == 0)
+					if (aSynHost.Len() == 0 &&
+					    m_eScheme < INET_PROT_END) /* valid perhaps */
 					{
 						setInvalid();
 						return false;
