Index: config_office/configure.in
===================================================================
--- config_office/configure.in.orig	2004-01-11 13:37:00.000000000 +0100
+++ config_office/configure.in	2004-01-11 13:38:49.000000000 +0100
@@ -2007,7 +2007,7 @@ WITH_GPC=NO
 WITH_LIBART=NO
 
 if test -n "$enable_libart"; then
-  PKG_CHECK_MODULES( LIBART, libart-2.0 >= 2.3.13 )
+  PKG_CHECK_MODULES( LIBART, libart-2.0 >= 2.3.11 )
   WITH_LIBART=YES
 	
 elif test "$with_gpc" != "no" ; then
Index: tools/source/generic/poly2.cxx
===================================================================
--- tools/source/generic/poly2.cxx.orig	2003-07-16 19:15:25.000000000 +0200
+++ tools/source/generic/poly2.cxx	2004-01-11 13:38:49.000000000 +0100
@@ -100,6 +100,10 @@ extern "C"
 #include <vcompat.hxx>
 #endif
 
+#ifdef HAVE_LIBART_H
+static ArtSVP *private_art_svp_minus (const ArtSVP *svp1, const ArtSVP *svp2);
+#endif
+
 // ---------------
 // - PolyPolygon -
 // ---------------
@@ -750,7 +754,7 @@ void PolyPolygon::ImplDoOperation( const
 		art_svp_free (s);
 		break;
 	case GPC_DIFF:
-		s = art_svp_minus (sa, sb);
+		s = private_art_svp_minus (sa, sb);
 		a = art_vpath_from_svp (s);
 		art_svp_free (s);
 		break;
@@ -1190,3 +1194,93 @@ void PolyPolygon::Write( SvStream& rOStr
 	for ( USHORT i = 0; i < nPolyCount; i++ )
 		mpImplPolyPolygon->mpPolyAry[i]->ImplWrite( rOStream );;
 }
+
+
+/* This code copied & pasted from libart_lgpl, available from gnome.org */
+
+/* Libart_LGPL - library of basic graphic primitives
+ * Copyright (C) 1998-2000 Raph Levien
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/* Merge the segments of the two svp's. The resulting svp will share
+   segments with args passed in, so be super-careful with the
+   allocation.  */
+/**
+ * art_svp_merge: Merge the segments of two svp's.
+ * @svp1: One svp to merge.
+ * @svp2: The other svp to merge.
+ *
+ * Merges the segments of two SVP's into a new one. The resulting
+ * #ArtSVP data structure will share the segments of the argument
+ * svp's, so it is probably a good idea to free it shallowly,
+ * especially if the arguments will be freed with art_svp_free().
+ *
+ * Return value: The merged #ArtSVP.
+ **/
+static ArtSVP *
+private_art_svp_merge (const ArtSVP *svp1, const ArtSVP *svp2)
+{
+  ArtSVP *svp_new;
+  int ix;
+  int ix1, ix2;
+
+  svp_new = (ArtSVP *)art_alloc (sizeof(ArtSVP) +
+				 (svp1->n_segs + svp2->n_segs - 1) *
+				 sizeof(ArtSVPSeg));
+  ix1 = 0;
+  ix2 = 0;
+  for (ix = 0; ix < svp1->n_segs + svp2->n_segs; ix++)
+    {
+      if (ix1 < svp1->n_segs &&
+	  (ix2 == svp2->n_segs ||
+	   art_svp_seg_compare (&svp1->segs[ix1], &svp2->segs[ix2]) < 1))
+	svp_new->segs[ix] = svp1->segs[ix1++];
+      else
+	svp_new->segs[ix] = svp2->segs[ix2++];
+    }
+
+  svp_new->n_segs = ix;
+  return svp_new;
+}
+
+static ArtSVP *private_art_svp_minus (const ArtSVP *svp1, const ArtSVP *svp2)
+{
+	ArtSVP *svp2_mod;
+	ArtSVP *svp3, *svp_new;
+	ArtSvpWriter *swr;
+	int i;
+
+	svp2_mod = (ArtSVP *) svp2; /* get rid of the const for a while */
+
+	/* First invert svp2 to "turn it inside out" */
+	for (i = 0; i < svp2_mod->n_segs; i++)
+		svp2_mod->segs[i].dir = !svp2_mod->segs[i].dir;
+
+	svp3 = private_art_svp_merge (svp1, svp2_mod);
+	swr = art_svp_writer_rewind_new (ART_WIND_RULE_POSITIVE);
+	art_svp_intersector (svp3, swr);
+	svp_new = art_svp_writer_rewind_reap (swr);
+	art_free (svp3); /* shallow free because svp3 contains shared segments */
+
+	/* Flip svp2 back to its original state */
+	for (i = 0; i < svp2_mod->n_segs; i++)
+		svp2_mod->segs[i].dir = !svp2_mod->segs[i].dir;
+
+	return svp_new;
+}
+
