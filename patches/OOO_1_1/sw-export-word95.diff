diff -u -r1.53.72.2 wrtw8nds.cxx
--- sw/source/filter/ww8/wrtw8nds.cxx	18 Mar 2004 12:17:47 -0000	1.53.72.2
+++ sw/source/filter/ww8/wrtw8nds.cxx	19 Aug 2004 10:14:27 -0000
@@ -219,6 +219,9 @@
 #ifndef _COM_SUN_STAR_I18N_SCRIPTTYPE_HDL_
 #include <com/sun/star/i18n/ScriptType.hdl>
 #endif
+#ifndef INCLUDED_I18NUTIL_UNICODE_HXX
+#include <i18nutil/unicode.hxx>  //unicode::getUnicodeScriptType
+#endif
 
 #ifndef _WRTWW8_HXX
 #include "wrtww8.hxx"
@@ -280,24 +283,57 @@
     :   mpFlyFrm(pFlyFrm), mpNode(pNode), maPos(rPos) {}
 };
 
+struct CharRunEntry
+{
+    xub_StrLen mnEndPos;
+    sal_uInt16 mnScript;
+    rtl_TextEncoding meCharSet;
+    bool mbRTL;
+    CharRunEntry(xub_StrLen nEndPos, sal_uInt16 nScript,
+        rtl_TextEncoding eCharSet, bool bRTL)
+    : mnEndPos(nEndPos), mnScript(nScript), meCharSet(eCharSet),
+    mbRTL(bRTL)
+    {
+    }
+};
+
+typedef std::vector<CharRunEntry> CharRuns;
+typedef CharRuns::const_iterator cCharRunIter;
+
+namespace
+{
+    //Utility to remove entries before a given starting position
+    class IfBeforeStart
+        : public std::unary_function<const CharRunEntry&, bool>
+    {
+    private:
+        xub_StrLen mnStart;
+    public:
+        IfBeforeStart(xub_StrLen nStart) : mnStart(nStart) {}
+        bool operator()(const CharRunEntry &rEntry) const
+        {
+            return rEntry.mnEndPos < mnStart;
+        }
+    };
+}
+
 class WW8_SwAttrIter : public WW8_AttrIter
 {
 private:
 	const SwTxtNode& rNd;
-    std::list<CurrentCharSet> maCharSets;
-    typedef std::list<CurrentCharSet>::iterator mychsiter;
+
+    CharRuns maCharRuns;
+    cCharRunIter maCharRunIter;
+
+	rtl_TextEncoding meChrSet;
+    USHORT mnScript;
+    bool mbCharIsRTL;
+
 	const SwRedline* pCurRedline;
 	xub_StrLen nAktSwPos;
 	xub_StrLen nTmpSwPos;					// fuer HasItem()
 	USHORT nCurRedlinePos;
-	rtl_TextEncoding eNdChrSet;
-    USHORT nScript;
 
-    typedef std::pair<UTextOffset, bool> Entry;
-    std::vector<Entry> maDirChanges;
-    typedef std::vector<Entry>::const_iterator myciter;
-    myciter maBiDiIter;
-    bool mbCharIsRTL;
     bool mbParaIsRTL;
 
     std::vector<swFlyFrm> maFlyFrms;     // #i2916#
@@ -305,7 +341,6 @@
     myflyiter maFlyIter;
 
 	xub_StrLen SearchNext( xub_StrLen nStartPos );
-	void SetCharSet(const SwTxtAttr& rTxtAttr, bool bStart);
 	void FieldVanish( const String& rTxt );
 
 	void OutSwFmtINetFmt(const SwFmtINetFmt& rAttr, bool bStart);
@@ -313,6 +348,8 @@
 	void OutSwTOXMark(const SwTOXMark& rAttr, bool bStart);
 	void OutSwFmtRuby(const SwFmtRuby& rRuby, bool bStart);
 
+    void IterToCurrent();
+
     //No copying
     WW8_SwAttrIter(const WW8_SwAttrIter&);
     WW8_SwAttrIter& operator=(const WW8_SwAttrIter&);
@@ -332,11 +369,12 @@
     void OutFlys(xub_StrLen nSwPos);
 
 	xub_StrLen WhereNext() const					{ return nAktSwPos; }
-	rtl_TextEncoding GetNextCharSet() const;
-	rtl_TextEncoding GetNodeCharSet() const				{ return eNdChrSet; }
-
+    sal_uInt16 GetScript() const { return mnScript; }
     bool IsCharRTL() const {return mbCharIsRTL; }
     bool IsParaRTL() const {return mbParaIsRTL; }
+    rtl_TextEncoding GetCharSet() const { return meChrSet; }
+    String GetSnippet(const String &rStr, xub_StrLen nAktPos,
+        xub_StrLen nLen) const;
 };
 
 class sortswflys :
@@ -349,43 +387,107 @@
     }
 };
 
-WW8_SwAttrIter::WW8_SwAttrIter(SwWW8Writer& rWr, const SwTxtNode& rTxtNd)
-	: WW8_AttrIter(rWr), rNd(rTxtNd), pCurRedline(0), nAktSwPos(0),
-	nTmpSwPos(0), nCurRedlinePos(USHRT_MAX), mbCharIsRTL(false)
+void WW8_SwAttrIter::IterToCurrent()
 {
-    SwPosition aPos(rTxtNd);
-    if (FRMDIR_HORI_RIGHT_TOP == rWr.pDoc->GetTextDirection(aPos))
-        mbParaIsRTL = true;
-    else
-        mbParaIsRTL = false;
+    ASSERT(maCharRuns.begin() != maCharRuns.end(), "Impossible");
+    mnScript = maCharRunIter->mnScript;
+    meChrSet = maCharRunIter->meCharSet;
+    mbCharIsRTL = maCharRunIter->mbRTL;
+}
 
-	// Attributwechsel an Pos 0 wird ignoriert, da davon ausgegangen
-	// wird, dass am Absatzanfang sowieso die Attribute neu ausgegeben
-	// werden.
-	eNdChrSet =
-        ((SvxFontItem&)rNd.SwCntntNode::GetAttr(RES_CHRATR_FONT)).GetCharSet();
-    eNdChrSet = GetExtendedTextEncoding(eNdChrSet);
+namespace
+{
+    /*
+     Utility to categorize unicode characters into the best fit windows charset
+     range for exporting to ww6, or as a hint to non \u unicode token aware rtf
+     readers
+    */
+    rtl_TextEncoding getScriptClass(sal_Unicode cChar)
+    {
+        using namespace com::sun::star::i18n;
 
-    const String &rTxt = rTxtNd.GetTxt();
+        static ScriptTypeList aScripts[] =
+        {
+            { UnicodeScript_kBasicLatin, RTL_TEXTENCODING_MS_1252},
+            { UnicodeScript_kLatin1Supplement, RTL_TEXTENCODING_MS_1252},
+            { UnicodeScript_kLatinExtendedA, RTL_TEXTENCODING_MS_1250},
+            { UnicodeScript_kLatinExtendedB, RTL_TEXTENCODING_MS_1257},
+            { UnicodeScript_kGreek, RTL_TEXTENCODING_MS_1253},
+            { UnicodeScript_kCyrillic, RTL_TEXTENCODING_MS_1251},
+            { UnicodeScript_kHebrew, RTL_TEXTENCODING_MS_1255},
+            { UnicodeScript_kArabic, RTL_TEXTENCODING_MS_1256},
+            { UnicodeScript_kThai, RTL_TEXTENCODING_MS_1258},
+            { UnicodeScript_kScriptCount, RTL_TEXTENCODING_MS_1252}
+        };
+
+        return unicode::getUnicodeScriptType(cChar, aScripts,
+            RTL_TEXTENCODING_MS_1252);
+    }
 
-    if( pBreakIt->xBreak.is() )
-        nScript = pBreakIt->xBreak->getScriptType(rTxt, 0);
-    else
-        nScript = ScriptType::LATIN;
 
-    if (rTxt.Len())
+    CharRuns GetPseudoCharRuns(const SwTxtNode& rTxtNd,
+        xub_StrLen nTxtStart, bool bSplitOnCharSet)
     {
-        UBiDiDirection eDefaultDir = mbParaIsRTL ? UBIDI_RTL : UBIDI_LTR;
+        const String &rTxt = rTxtNd.GetTxt();
+
+        bool bParaIsRTL = false;
+        ASSERT(rTxtNd.GetDoc(), "No document for node?, suspicious");
+        if (rTxtNd.GetDoc())
+        {
+            if (FRMDIR_HORI_RIGHT_TOP ==
+                rTxtNd.GetDoc()->GetTextDirection(SwPosition(rTxtNd)))
+            {
+                bParaIsRTL = true;
+            }
+        }
+
+        using namespace com::sun::star::i18n;
+
+        sal_uInt16 nScript = ScriptType::LATIN;
+        if (rTxt.Len() && pBreakIt && pBreakIt->xBreak.is())
+            nScript = pBreakIt->xBreak->getScriptType(rTxt, 0);
+
+        rtl_TextEncoding eChrSet = ((const SvxFontItem&)
+        (rTxtNd.SwCntntNode::GetAttr(GetWhichOfScript(RES_CHRATR_FONT, nScript))))
+        .GetCharSet();
+        eChrSet = GetExtendedTextEncoding(eChrSet);
+
+        CharRuns aRunChanges;
+
+        if (!rTxt.Len())
+        {
+            aRunChanges.push_back(CharRunEntry(0, nScript, eChrSet,
+                bParaIsRTL));
+            return aRunChanges;
+        }
+
+        typedef std::pair<int32_t, bool> DirEntry;
+        typedef std::vector<DirEntry> DirChanges;
+        typedef DirChanges::const_iterator cDirIter;
+
+        typedef std::pair<xub_StrLen, sal_Int16> CharSetEntry;
+        typedef std::vector<CharSetEntry> CharSetChanges;
+        typedef CharSetChanges::const_iterator cCharSetIter;
+
+        typedef std::pair<xub_StrLen, sal_uInt16> ScriptEntry;
+        typedef std::vector<ScriptEntry> ScriptChanges;
+        typedef ScriptChanges::const_iterator cScriptIter;
+
+        DirChanges aDirChanges;
+        CharSetChanges aCharSets;
+        ScriptChanges aScripts;
+
+        UBiDiDirection eDefaultDir = bParaIsRTL ? UBIDI_RTL : UBIDI_LTR;
         UErrorCode nError = U_ZERO_ERROR;
         UBiDi* pBidi = ubidi_openSized(rTxt.Len(), 0, &nError);
-        ubidi_setPara(pBidi, rTxt.GetBuffer(), rTxt.Len(), eDefaultDir, NULL,
-            &nError);
+        ubidi_setPara(pBidi, rTxt.GetBuffer(), rTxt.Len(), eDefaultDir,
+            0, &nError);
 
         sal_Int32 nCount = ubidi_countRuns(pBidi, &nError);
-        maDirChanges.reserve(nCount);
+        aDirChanges.reserve(nCount);
 
-        UTextOffset nStart = 0;
-        UTextOffset nEnd;
+        int32_t nStart = 0;
+        int32_t nEnd;
         UBiDiLevel nCurrDir;
 
         for (sal_Int32 nIdx = 0; nIdx < nCount; ++nIdx)
@@ -395,21 +497,137 @@
             UBiDiLevel is the type of the level values in this BiDi
             implementation.
 
-            It holds an embedding level and indicates the visual direction by
-            its bit 0 (even/odd value).
+            It holds an embedding level and indicates the visual direction
+            by its bit 0 (even/odd value).
 
             The value for UBIDI_DEFAULT_LTR is even and the one for
             UBIDI_DEFAULT_RTL is odd
             */
-            maDirChanges.push_back(Entry(nEnd, nCurrDir & 0x1));
+            aDirChanges.push_back(DirEntry(nEnd, nCurrDir & 0x1));
             nStart = nEnd;
         }
         ubidi_close(pBidi);
 
-        if (!maDirChanges.empty())
-            mbCharIsRTL = maDirChanges.begin()->second;
+        if (bSplitOnCharSet)
+        {
+            //Split unicode text into plausable 8bit ranges for export to
+            //older non unicode aware format
+            xub_StrLen nLen = rTxt.Len();
+            xub_StrLen nPos = 0;
+            while (nPos != nLen)
+            {
+                rtl_TextEncoding ScriptType =
+                    getScriptClass(rTxt.GetChar(nPos++));
+                while (
+                        (nPos != nLen) &&
+                        (ScriptType == getScriptClass(rTxt.GetChar(nPos)))
+                      )
+                {
+                    ++nPos;
+                }
+                
+                aCharSets.push_back(CharSetEntry(nPos, ScriptType));
+            }
+        }
+
+        if (pBreakIt && pBreakIt->xBreak.is())
+        {
+            xub_StrLen nLen = rTxt.Len();
+            xub_StrLen nPos = 0;
+            while (nPos < nLen)
+            {
+                sal_Int32 nEnd = pBreakIt->xBreak->endOfScript(rTxt, nPos,
+                    nScript);
+                if (nEnd < 0)
+                    break;
+                nPos = nEnd;
+                aScripts.push_back(ScriptEntry(nPos, nScript));
+                nScript = pBreakIt->xBreak->getScriptType(rTxt, nPos);
+            }
+        }
+
+        cDirIter aBiDiEnd = aDirChanges.end();
+        cCharSetIter aCharSetEnd = aCharSets.end();
+        cScriptIter aScriptEnd = aScripts.end();
+
+        cDirIter aBiDiIter = aDirChanges.begin();
+        cCharSetIter aCharSetIter = aCharSets.begin();
+        cScriptIter aScriptIter = aScripts.begin();
+
+        bool bCharIsRTL = bParaIsRTL;
+
+        while (
+                aBiDiIter != aBiDiEnd ||
+                aCharSetIter != aCharSetEnd ||
+                aScriptIter != aScriptEnd
+              )
+        {
+            xub_StrLen nMinPos = rTxt.Len();
+
+            if (aBiDiIter != aBiDiEnd)
+            {
+                if (aBiDiIter->first < nMinPos)
+                    nMinPos = aBiDiIter->first;
+                bCharIsRTL = aBiDiIter->second;
+            }
+
+            if (aCharSetIter != aCharSetEnd)
+            {
+                if (aCharSetIter->first < nMinPos)
+                    nMinPos = aCharSetIter->first;
+                eChrSet = aCharSetIter->second;
+            }
+
+            if (aScriptIter != aScriptEnd)
+            {
+                if (aScriptIter->first < nMinPos)
+                    nMinPos = aScriptIter->first;
+                nScript = aScriptIter->second;
+            }
+
+            aRunChanges.push_back(
+                CharRunEntry(nMinPos, nScript, eChrSet, bCharIsRTL));
+
+            if (aBiDiIter != aBiDiEnd)
+            {
+                if (aBiDiIter->first == nMinPos)
+                    ++aBiDiIter;
+            }
+
+            if (aCharSetIter != aCharSetEnd)
+            {
+                if (aCharSetIter->first == nMinPos)
+                    ++aCharSetIter;
+            }
+
+            if (aScriptIter != aScriptEnd)
+            {
+                if (aScriptIter->first == nMinPos)
+                    ++aScriptIter;
+            }
+        }
+
+        aRunChanges.erase(std::remove_if(aRunChanges.begin(),
+            aRunChanges.end(), IfBeforeStart(nTxtStart)), aRunChanges.end());
+
+        return aRunChanges;
     }
-    maBiDiIter = maDirChanges.begin();
+}
+
+                                                                                
+WW8_SwAttrIter::WW8_SwAttrIter(SwWW8Writer& rWr, const SwTxtNode& rTxtNd)
+	: WW8_AttrIter(rWr), maCharRuns(GetPseudoCharRuns(rTxtNd, 0, !rWr.bWrtWW8)),
+    rNd(rTxtNd), pCurRedline(0), nAktSwPos(0), nTmpSwPos(0), 
+    nCurRedlinePos(USHRT_MAX), mbCharIsRTL(false)
+{
+    SwPosition aPos(rTxtNd);
+    if (FRMDIR_HORI_RIGHT_TOP == rWr.pDoc->GetTextDirection(aPos))
+        mbParaIsRTL = true;
+    else
+        mbParaIsRTL = false;
+
+    maCharRunIter = maCharRuns.begin();
+    IterToCurrent();
 
 	/*
      #i2916#
@@ -453,13 +671,6 @@
 	nAktSwPos = SearchNext( 1 );
 }
 
-rtl_TextEncoding WW8_SwAttrIter::GetNextCharSet() const
-{
-    if (!maCharSets.empty())
-		return maCharSets.back().CharSet();
-	return eNdChrSet;
-}
-
 xub_StrLen WW8_SwAttrIter::SearchNext( xub_StrLen nStartPos )
 {
     xub_StrLen nPos;
@@ -518,38 +729,29 @@
 			const SwTxtAttr* pHt = (*pTxtAttrs)[i];
 			nPos = *pHt->GetStart();	// gibt erstes Attr-Zeichen
 			if( nPos >= nStartPos && nPos <= nMinPos )
-			{
 				nMinPos = nPos;
-				SetCharSet(*pHt, true);
-			}
 
 			if( pHt->GetEnd() )			// Attr mit Ende
 			{
 				nPos = *pHt->GetEnd();		// gibt letztes Attr-Zeichen + 1
 				if( nPos >= nStartPos && nPos <= nMinPos )
-				{
 					nMinPos = nPos;
-					SetCharSet(*pHt, false);
-				}
 			}
 			else
 			{
                 // Attr ohne Ende Laenge 1 wegen CH_TXTATR im Text
 				nPos = *pHt->GetStart() + 1;
 				if( nPos >= nStartPos && nPos <= nMinPos )
-				{
 					nMinPos = nPos;
-					SetCharSet(*pHt, false);
-				}
 			}
 		}
 	}
 
-    if (maBiDiIter != maDirChanges.end())
+    if (maCharRunIter != maCharRuns.end())
     {
-        if (maBiDiIter->first < nMinPos)
-            nMinPos = maBiDiIter->first;
-        mbCharIsRTL = maBiDiIter->second;
+        if (maCharRunIter->mnEndPos < nMinPos)
+            nMinPos = maCharRunIter->mnEndPos;
+        IterToCurrent();
     }
 
 	/*
@@ -576,59 +778,20 @@
 	}
 
     //nMinPos found and not going to change at this point
-    if (maBiDiIter != maDirChanges.end())
+
+    if (maCharRunIter != maCharRuns.end())
     {
-        if (maBiDiIter->first == nMinPos)
-            ++maBiDiIter;
+        if (maCharRunIter->mnEndPos == nMinPos)
+            ++maCharRunIter;
     }
 
 	return nMinPos;
 }
 
-void WW8_SwAttrIter::SetCharSet(const SwTxtAttr& rAttr, bool bStart)
-{
-	const SwTxtAttr* p = 0;
-	rtl_TextEncoding eChrSet(RTL_TEXTENCODING_DONTKNOW);
-	const SfxPoolItem& rItem = rAttr.GetAttr();
-	switch(rItem.Which())
-	{
-        case RES_CHRATR_FONT:
-            p = &rAttr;
-            eChrSet = ((const SvxFontItem&)rItem).GetCharSet();
-            break;
-        case RES_TXTATR_CHARFMT:
-            {
-                const SfxPoolItem* pItem;
-                if( ((SwFmtCharFmt&)rItem).GetCharFmt() && SFX_ITEM_SET ==
-                    ((SwFmtCharFmt&)rItem).GetCharFmt()->GetItemState(
-                        RES_CHRATR_FONT, true, &pItem ))
-                {
-                    p = &rAttr;
-                    eChrSet = ((const SvxFontItem*)pItem)->GetCharSet();
-                }
-            }
-            break;
-	}
-
-	if (p)
-	{
-        CurrentCharSet aEntry(p, GetExtendedTextEncoding(eChrSet));
-		if (bStart)
-            maCharSets.push_back(aEntry);
-		else
-        {
-            mychsiter aIter = std::find(maCharSets.begin(), maCharSets.end(),
-                aEntry);
-            if (aIter != maCharSets.end())
-                maCharSets.erase(aIter);
-        }
-	}
-}
-
 void WW8_SwAttrIter::OutAttr( xub_StrLen nSwPos )
 {
 	if (rNd.GetpSwAttrSet())
-		rWrt.Out_SfxItemSet(*rNd.GetpSwAttrSet(), false, true, nScript);
+		rWrt.Out_SfxItemSet(*rNd.GetpSwAttrSet(), false, true, mnScript);
 
     if (rWrt.bWrtWW8 && IsCharRTL())
     {
@@ -653,7 +816,7 @@
 			if( pEnd ? ( nSwPos >= *pHt->GetStart() && nSwPos < *pEnd )
 						: nSwPos == *pHt->GetStart() )
             {
-                if (rWrt.CollapseScriptsforWordOk(nScript,
+                if (rWrt.CollapseScriptsforWordOk(mnScript,
                     pHt->GetAttr().Which()))
                 {
                     Out(aWW8AttrFnTab, pHt->GetAttr(), rWrt);
@@ -1371,6 +1534,23 @@
     return aRet;
 }
 
+String WW8_SwAttrIter::GetSnippet(const String &rStr, xub_StrLen nAktPos,
+    xub_StrLen nLen) const
+{
+    String aSnippet(rStr, nAktPos, nLen);
+    if (!nLen)
+        return aSnippet;
+
+    // 0x0a     ( Hard Line Break ) -> 0x0b
+    // 0xad     ( soft hyphen )     -> 0x1f
+    // 0x2011   ( hard hyphen )     -> 0x1e
+    aSnippet.SearchAndReplaceAll(0x0A, 0x0B);
+    aSnippet.SearchAndReplaceAll(CHAR_HARDHYPHEN, 0x1e);
+    aSnippet.SearchAndReplaceAll(CHAR_SOFTHYPHEN, 0x1f);
+
+    return aSnippet;
+}
+
 Writer& OutWW8_SwTxtNode( Writer& rWrt, SwCntntNode& rNode )
 {
 	SwWW8Writer& rWW8Wrt = (SwWW8Writer&)rWrt;
@@ -1415,21 +1595,12 @@
 	}
 
 	WW8_SwAttrIter aAttrIter( rWW8Wrt, *pNd );
-	rtl_TextEncoding eChrSet = aAttrIter.GetNodeCharSet();
+	rtl_TextEncoding eChrSet = aAttrIter.GetCharSet();
 
 	ASSERT( !pO->Count(), " pO ist am Zeilenanfang nicht leer" );
 
 	String aStr( pNd->GetTxt() );
 
-	// 0x0a		( Hard Line Break )	-> 0x0b
-	// 0xad		( soft hyphen ) 	-> 0x1f
-	// 0x2011	( hard hyphen )		-> 0x1e
-	if( aStr.Len() )
-	{
-		aStr.SearchAndReplaceAll( 0x0A, 0x0B );
-		aStr.SearchAndReplaceAll( CHAR_HARDHYPHEN, 0x1e );
-		aStr.SearchAndReplaceAll( CHAR_SOFTHYPHEN, 0x1f );
-	}
 	xub_StrLen nAktPos = 0;
 	xub_StrLen nEnd = aStr.Len();
 	bool bUnicode = rWW8Wrt.bWrtWW8, bRedlineAtEnd = false;
@@ -1437,7 +1608,6 @@
 
 	do {
 		xub_StrLen nNextAttr = aAttrIter.WhereNext();
-		rtl_TextEncoding eNextChrSet = aAttrIter.GetNextCharSet();
 
 		if( nNextAttr > nEnd )
 			nNextAttr = nEnd;
@@ -1449,9 +1619,12 @@
 		bool bTxtAtr = aAttrIter.IsTxtAttr( nAktPos );
 		nOpenAttrWithRange += aAttrIter.OutAttrWithRange( nAktPos );
 
-		if( !bTxtAtr )
-			rWW8Wrt.OutSwString( aStr, nAktPos, nNextAttr - nAktPos,
-									bUnicode, eChrSet );
+        xub_StrLen nLen = nNextAttr - nAktPos;
+		if (!bTxtAtr && nLen)
+        {
+            String aSnippet(aAttrIter.GetSnippet(aStr, nAktPos, nLen));
+            rWW8Wrt.OutSwString(aSnippet, 0, nLen, bUnicode, eChrSet );
+        }
 
         // Am Zeilenende werden die Attribute bis ueber das CR aufgezogen.
         // Ausnahme: Fussnoten am Zeilenende
@@ -1517,8 +1690,8 @@
 			}
 		}
 		nAktPos = nNextAttr;
-		eChrSet = eNextChrSet;
 		aAttrIter.NextPos();
+		eChrSet = aAttrIter.GetCharSet();
 	}
 	while( nAktPos < nEnd );
 

diff -u -r1.24.104.1 makefile.mk
--- sw/util/makefile.mk	15 Aug 2003 11:47:10 -0000	1.24.104.1
+++ sw/util/makefile.mk	19 Aug 2004 10:15:56 -0000
@@ -193,7 +193,8 @@
 	$(CPPULIB) \
 	$(VOSLIB) \
 	$(SALLIB) \
-	$(ICUUCLIB)
+	$(ICUUCLIB) \
+	$(I18NUTILLIB)
 
 .IF "$(OS)"=="MACOSX"
 # static libraries at end for OS X
