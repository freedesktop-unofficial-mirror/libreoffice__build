--- /dev/null	2004-08-25 23:04:59.000000000 +0530
+++ sc/source/filter/qpro/qproform.cxx	2004-12-15 14:04:52.678608080 +0530
@@ -0,0 +1,601 @@
+#ifdef PCH
+#include "filt_pch.hxx"
+#endif
+                                                                                                                  
+#pragma hdrstop
+                                                                                                                  
+//------------------------------------------------------------------------
+                                                                                                                  
+#include "decl.h"
+
+#ifndef _QPRO_HXX
+#include "qpro.hxx"
+#endif
+
+#include "qproform.hxx"
+#include "compiler.hxx"
+#include "namebuff.hxx"
+#include "root.hxx"
+#include "ftools.hxx"
+#include "tool.h"
+#include <math.h>
+
+static const sal_Char*          GetAddInName( const UINT8 nIndex );
+                                                                                                                  
+static DefTokenId                       lcl_KnownAddIn( const ByteString& sTest );
+                                                                                                                  
+void QProToSc::ReadSRD( SingleRefData& rSRD, sal_Int8 nPage, sal_Int8 nCol, sal_uInt16 nRelBit )
+{
+
+	UINT16 nTmp = nRelBit & 0x1fff;
+	rSRD.InitAddress( ScAddress( nCol, (~nTmp + 1), 0 ) );
+	if( nRelBit & 0x4000 )
+	{
+                rSRD.nRelCol = nCol;
+        	rSRD.SetColRel( TRUE );
+	}
+	else
+	{
+		rSRD.nCol = nCol;
+        	rSRD.SetColRel( FALSE );
+	}
+	if( nRelBit & 0x2000 )
+	{
+		rSRD.nRelRow = (~nTmp + 1);
+		rSRD.nRelRow = (UINT16)(nTmp << 3);
+		rSRD.nRelRow /= 8;
+		
+        	rSRD.SetRowRel( TRUE );
+	}
+	else
+	{
+		rSRD.nRow = nTmp;
+        	rSRD.SetRowRel( FALSE );
+	}
+        if( nRelBit & 0x8000 )
+        {
+                rSRD.nRelTab = nPage;
+                rSRD.SetTabRel( TRUE );
+        }
+        else
+        {
+                rSRD.nTab = nPage;
+                rSRD.SetTabRel( FALSE );
+        }
+        
+}
+  
+void QProToSc::Reset( ScAddress aEingPos )
+{
+        QProConverterBase::Reset();
+                                                                                                                  
+        TokenId nEins = aPool.Store( 1.0 );
+                                                                                                                  
+        aPool << ocClose << ocAdd << nEins;
+        nAddToken = aPool.Store();
+                                                                                                                  
+        aPool << ocClose << ocSub << nEins;
+        nSubToken = aPool.Store();
+                                                                                                                  
+        n0Token = aPool.Store( 0.0 );
+}
+
+QProToSc::QProToSc( BiffReader& rStream ) :
+        QProConverterBase( rStream, 128 )
+{
+}
+void QProToSc::DoFunc( DefTokenId eOc, BYTE nArgs, const sal_Char* pExtString )
+{
+        TokenId                                         eParam[ 256 ];
+        INT32                                           nLauf;
+        TokenId                                         nPush, nPush1;
+                                                                                                                  
+        BOOL                                            bAddIn = FALSE;
+        BOOL                                            bNeg = FALSE;
+                                                                                                                  
+                if( eOc == ocNoName )
+                {
+                        bAddIn = TRUE;
+                        nPush = aPool.Store( eOc );
+                        aPool << nPush;
+                }
+        
+                                                                                                                  
+        for( nLauf = 0 ; nLauf < nArgs; nLauf++ )
+                aStack >> eParam[ nLauf ];
+                                                                                                                  
+        switch( eOc )
+        {
+                case ocIndex:
+                        nPush = eParam[ 0 ];
+                        eParam[ 0 ] = eParam[ 1 ];
+                        eParam[ 1 ] = nPush;
+                        IncToken( eParam[ 0 ] );
+                        IncToken( eParam[ 1 ] );
+                        break;
+                case ocIKV:
+                {
+                        nPush = eParam[ 0 ];
+                        eParam[ 0 ] = eParam[ 1 ];
+                        eParam[ 1 ] = nPush;
+                }
+                        break;
+                case ocGetYear:
+                {
+                        nPush = aPool.Store( 1900.0 );
+                        aPool << ocOpen;
+                }
+                        break;
+                case ocChose:
+                {
+                        IncToken( eParam[ nArgs- 1 ] );
+                }
+                        break;
+                case ocFind:
+                case ocHLookup:
+                case ocVLookup:
+                {
+                        IncToken( eParam[ 0 ] );
+                }
+                        break;
+                case ocMid:
+                case ocReplace:
+                {
+                        IncToken( eParam[ nArgs- 2 ] );
+                }
+                        break;
+                case ocZins:
+                {
+                        nArgs= 4;
+                        eParam[ 3 ] = eParam[ 0 ];      // 3. -> 1.
+                        eParam[ 0 ] = eParam[ 2 ];      // 1. -> 4.
+                        NegToken( eParam[ 1 ] );        // 2. -> -2. (+ 2. -> 3.)
+                        eParam[ 2 ] = n0Token;          //    -> 2. als Default
+                }
+                        break;
+        }
+                                                                                                                  
+        if( !bAddIn )
+                aPool << eOc;
+
+        aPool << ocOpen;
+                                                                                                                  
+        if( nArgs> 0 )
+        {
+                INT16 nNull = -1;       
+                                                                                                                  
+                INT16 nLast = nArgs- 1;
+                                                                                                                  
+                if( eOc == ocRMZ )
+                {        aPool << eParam[ 1 ] << ocSep << eParam[ 0 ] << ocSep
+                                << ocNegSub << eParam[ 2 ];
+                }
+                else
+                {        aPool << eParam[ nLast ];
+                                                                                                                  
+                        for( nLauf = nLast - 1 ; nLauf >= 0 ; nLauf-- )
+                        {
+                                if( nLauf != nNull )
+                                        aPool << ocSep << eParam[ nLauf ];
+                        }
+                }
+        }
+                                                                                                                  
+                                                                                                                  
+        if( eOc == ocGetYear )
+        {
+                aPool << ocClose << ocSub << nPush;
+        }
+        else if( eOc == ocFixed )
+        {
+                aPool << ocSep << ocTrue << ocOpen << ocClose;
+        }
+        else if( eOc == ocFind )
+        {
+                nPush1 = aPool.Store();
+                DecToken( nPush1 );
+                aPool << nPush1;
+        }
+                                                                                                                  
+        aPool << ocClose;
+                                                                                                                  
+        aPool >> aStack;
+                                                                                                                  
+        if( bNeg )
+        {
+                aPool << ocOpen << ocSub << aStack << ocClose;
+                aPool >> aStack;
+        }
+}
+
+void QProToSc::IncToken( TokenId &rParam )
+{
+        aPool << ocOpen << rParam << nAddToken;
+        rParam = aPool.Store();
+}
+                                                                                                                  
+                                                                                                                  
+void QProToSc::DecToken( TokenId &rParam )
+{
+        aPool << ocOpen << rParam << nSubToken;
+        rParam = aPool.Store();
+}
+                                                                                                                  
+                                                                                                                  
+void QProToSc::NegToken( TokenId &rParam )
+{
+        aPool << ocNegSub << ocOpen << rParam << ocClose;
+        rParam = aPool.Store();
+}
+                                                                                                                  
+
+ConvErr QProToSc::Convert( const ScTokenArray*& rpErg, sal_uInt16 nLen, const FORMULA_TYPE eFT ) 
+{
+	sal_uInt8 nFmla[ 256 ];
+ 	sal_Int8  nCol, nPage;
+        sal_uInt16 nCRefCount = 0, nBRefCount = 0;
+  	sal_uInt16 nNote, nRef, nRelBits;
+  	TokenId  nPush;
+        BOOL FirstCRef = TRUE, FirstBRef = TRUE;
+ 	ComplRefData    aCRD;
+  	SingleRefData   aSRD;
+  	FUNC_TYPE       eType;
+  	DefTokenId	  eOc;
+  	const sal_Char* pExtName;
+ 
+  	aCRD.InitFlags();
+  	aSRD.InitFlags();
+  	aIn >> nRef;
+   
+  	for(int i=0; i < ( int )nRef; i++)
+    		aIn >> nFmla[i];
+        
+	i = 0;
+        
+	while( nFmla[ i ] != 0x03 )
+        { 
+    		eType = IndexToType( nFmla[ i ] );
+    		eOc = IndexToToken( nFmla[ i ] );
+    		if( eOc == ocNoName )
+       			pExtName = GetAddInName( eOc );
+                           
+    		switch( eType )
+    		{
+       			case FT_NotImpl:
+                        case FT_FuncFix0:       DoFunc( eOc, 0, pExtName ); break;
+                        case FT_FuncFix1:       DoFunc( eOc, 1, pExtName ); break;
+                        case FT_FuncFix2:       DoFunc( eOc, 2, pExtName ); break;
+                        case FT_FuncFix3:       DoFunc( eOc, 3, pExtName ); break;
+                        case FT_FuncFix4:       DoFunc( eOc, 4, pExtName ); break;
+
+			case FT_Cref : { // Single cell reference
+				aIn >> nNote >> nCol >> nPage >> nRelBits;  
+                       		ReadSRD( aSRD, nPage, nCol, nRelBits );
+                       		aStack << aPool.Store( aSRD );
+                       		break;
+                      		}
+    
+       			case FT_Range: { // Block reference
+				aIn >> nNote >> nCol >> nPage >> nRelBits;
+                   		ReadSRD( aCRD.Ref1, nPage, nCol, nRelBits );
+                   		aIn >> nCol >> nPage >> nRelBits;
+                   		ReadSRD( aCRD.Ref2, nPage, nCol, nRelBits );
+                   		aStack << aPool.Store( aCRD );
+                   		break;
+                  		}
+   
+       			case FT_FuncVar: { // Sum of a sequence of numbers
+                   		sal_uInt8 nArg;
+                                i++;
+                                nArg = nFmla[ i ];
+                   		DoFunc( eOc, nArg , pExtName );
+                   		break;
+		  		}
+
+       			case FT_Op: { // operators
+                   		aStack >> nPush;
+                   		aPool << aStack << eOc << nPush;
+                   		aPool >> aStack;
+                   		break; 
+                  		}
+      
+       			case FT_Braces: 
+                    		aPool << ocOpen << aStack << ocClose;
+                    		aPool >> aStack;
+                    		break;
+
+       			case FT_ConstInt:{
+                        	 sal_uInt16 nVal;
+                         	 aIn >> nVal;
+                         	 aStack << aPool.Store( ( double ) nVal );
+                        	}
+      
+       			case FT_Erref:
+                        	aPool << ocBad;
+                        	aPool >> aStack;
+                        	break;
+
+       			case FT_Ecref:
+                        	aPool << ocBad;
+                        	aPool >> aStack;
+                        	break;
+
+       			case FT_Econstant:
+                        	aPool << ocBad;
+                        	aPool >> aStack;
+                      	 	break;
+ 		}
+		i++;
+	}
+  
+
+   rpErg = aPool[ aStack.Get() ];
+   return ConvOK;
+}
+
+
+DefTokenId lcl_KnownAddIn( const ByteString& sTest )
+{
+        DefTokenId      eId = ocNoName;
+                                                                                                                  
+        if( sTest == "FACT" )
+    		eId = ocFact;
+        else if( sTest == "ISEMPTY")
+                 eId = ocIsEmpty;
+        else if( sTest == "DEGTORAD")
+                 eId = ocRad;
+        else if( sTest == "RADTODEG")
+                 eId = ocDeg;
+        else if( sTest == "SIGN")
+                 eId = ocPlusMinus;
+        else if( sTest == "ACOSH")
+                 eId = ocArcCosHyp;
+        else if( sTest == "ACOTH")
+                 eId = ocArcCotHyp;
+        else if( sTest == "ASINH")
+                 eId = ocArcSinHyp;
+        else if( sTest == "ATANH")
+                 eId = ocArcTanHyp;
+        else if( sTest == "COSH")
+                 eId = ocCosHyp;
+        else if( sTest == "COTH")
+                 eId = ocCotHyp;
+        else if( sTest == "SINH")
+                 eId = ocSinHyp;
+        else if( sTest == "TANH")
+                 eId = ocTanHyp;
+        else if( sTest == "EVEN")
+                 eId = ocIsEven;
+        else if( sTest == "ODD")
+                 eId = ocIsOdd;
+        else if( sTest == "ACOT")
+                 eId = ocArcCot;
+        else if( sTest == "COT")
+                 eId = ocCot;
+        else if( sTest == "ACOT")
+		 eId = ocArcCot;
+        else if( sTest == "TRUNC")
+                 eId = ocTrunc;
+        else if( sTest == "GEOMEAN")
+                 eId = ocGeoMean;
+        else if( sTest == "HARMEAN")
+                 eId = ocHarMean;
+        else if( sTest == "CORREL")
+                 eId = ocCorrel;
+        else if( sTest == "MEDIAN")
+                 eId = ocMedian;
+        else if( sTest == "COV")
+                 eId = ocCovar;
+        else if( sTest == "SKEWNESS")
+                 eId = ocSchiefe;
+        else if( sTest == "CHITEST")
+                 eId = ocChiTest;
+        else if( sTest == "FTEST")
+                 eId = ocFTest;
+        else if( sTest == "AVEDEV")
+                 eId = ocAveDev;
+        else if( sTest == "PRODUCT")
+                 eId = ocProduct;
+        else if( sTest == "PERMUT")
+                 eId = ocVariationen;
+        else if( sTest == "GAMMALN")
+                 eId = ocGammaLn;
+        else if( sTest == "POISSON")
+                 eId = ocPoissonDist;
+        else if( sTest == "NORMAL")
+                 eId = ocNormDist;
+        else if( sTest == "CRITBINOMIAL")
+                 eId = ocKritBinom;
+        
+	return  eId;
+}
+
+static const struct {
+	DefTokenId nToken;
+        FUNC_TYPE   nType;
+	const sal_Char *addInName;
+} aFuncMap[ 162 ] = {
+
+                { ocPush, FT_ConstFloat, NULL },                       
+                { ocPush, FT_Cref, NULL },                        
+		{ ocPush, FT_Range, NULL },                        
+	        { ocPush, FT_Return, NULL },                        
+                { ocPush, FT_Braces, NULL },                       
+                { ocPush, FT_ConstInt, NULL },                       
+                { ocPush, FT_ConstString, NULL },
+                { ocPush, FT_NOP, NULL },
+                { ocNegSub, FT_Neg, NULL },                       
+                { ocAdd, FT_Op, NULL },                           
+                { ocSub, FT_Op, NULL },                         
+                { ocMul, FT_Op, NULL },                         
+                { ocDiv, FT_Op, NULL },                         
+                { ocPow, FT_Op, NULL },                         
+                { ocEqual, FT_Op, NULL },                        
+                { ocNotEqual, FT_Op, NULL },                    
+                { ocLessEqual, FT_Op, NULL },           
+                { ocGreaterEqual, FT_Op, NULL },        
+                { ocLess, FT_Op, NULL },                
+                { ocGreater, FT_Op, NULL },             
+                { ocAnd, FT_Op, NULL },                 
+                { ocOr, FT_Op, NULL },                  
+                { ocNot, FT_FuncFix1, NULL },                 
+                { ocPush, FT_NOP, NULL },
+		{ ocNoName, FT_NotImpl, NULL },              
+                { ocNoName, FT_NotImpl, NULL },               
+                { ocNoName, FT_NotImpl, NULL },              
+                { ocNoName, FT_NotImpl, NULL },              
+                { ocNoName, FT_NotImpl, NULL },              
+                { ocNoName, FT_NotImpl, NULL },              
+                { ocNoName, FT_NotImpl, NULL },              
+                { ocNoValue, FT_FuncFix0, NULL },              
+                { ocNoName, FT_FuncFix0, NULL },              
+                { ocAbs, FT_FuncFix1, NULL },                  
+                { ocInt, FT_FuncFix1, NULL },                 
+                { ocSqrt, FT_FuncFix1, NULL },                
+                { ocLog10, FT_FuncFix1, NULL },               
+                { ocLn, FT_FuncFix1, NULL },                  
+                { ocPi, FT_FuncFix0, NULL },                   
+		{ ocSin, FT_FuncFix1, NULL },                   
+                { ocCos, FT_FuncFix1, NULL },                 
+                { ocTan, FT_FuncFix1, NULL },                 
+                { ocArcTan2, FT_FuncFix2, NULL },              
+                { ocArcTan, FT_FuncFix1, NULL },              
+                { ocArcSin, FT_FuncFix1, NULL },              
+                { ocArcCos, FT_FuncFix1, NULL },              
+                { ocExp, FT_FuncFix1, NULL },                  
+                { ocMod, FT_FuncFix2, NULL },    
+                { ocChose, FT_FuncVar, NULL },                
+                { ocIsNV, FT_FuncFix1, NULL },                
+                { ocIsError, FT_FuncFix1, NULL },              
+                { ocFalse, FT_FuncFix0, NULL },               
+                { ocTrue, FT_FuncFix0, NULL },                
+                { ocRandom, FT_FuncFix0, NULL },                      
+                { ocGetDate, FT_FuncFix3, NULL },                    
+                { ocGetActDate, FT_FuncFix0, NULL },          
+                { ocRMZ, FT_FuncFix3, NULL },                
+                { ocBW, FT_FuncFix3, NULL },               
+                { ocZW, FT_FuncFix3, NULL },            
+                { ocIf, FT_FuncFix3, NULL },          
+                { ocGetDay, FT_FuncFix1, NULL },                     
+                { ocGetMonth, FT_FuncFix1, NULL },                   
+                { ocGetYear, FT_FuncFix1, NULL },                    
+                { ocRound, FT_FuncFix2, NULL },                      
+                { ocGetTime, FT_FuncFix3, NULL },                    
+                { ocGetHour, FT_FuncFix1, NULL },                    
+                { ocGetMin, FT_FuncFix1, NULL },                      
+                { ocGetSec, FT_FuncFix1, NULL },                     
+                { ocIsValue, FT_FuncFix1, NULL },                     
+                { ocIsString, FT_FuncFix1, NULL },                    
+                { ocLen, FT_FuncFix1, NULL },                        
+                { ocValue, FT_FuncFix1, NULL },    
+		{ ocFixed, FT_FuncFix2, NULL },                      
+                { ocMid, FT_FuncFix3, NULL },                         
+                { ocChar, FT_FuncFix1, NULL },                        
+                { ocCode, FT_FuncFix1, NULL },                       
+                { ocFind, FT_FuncFix3, NULL },                       
+                { ocGetDateValue, FT_FuncFix1, NULL },        
+		{ ocGetTimeValue, FT_FuncFix1, NULL },        
+                { ocNoName, FT_FuncFix1, "CELLPOINTER" },              
+		{ ocSum, FT_FuncVar, NULL },                 
+                { ocAverage, FT_FuncVar, NULL },              
+                { ocCount, FT_FuncVar, NULL },               
+                { ocMin, FT_FuncVar, NULL },                  
+                { ocMax, FT_FuncVar, NULL },                 
+                { ocVLookup, FT_FuncFix3, NULL },             
+                { ocNBW, FT_FuncFix2, NULL },                 
+                { ocVar, FT_FuncVar, NULL },                 
+                { ocNormDist, FT_FuncVar, NULL },           
+                { ocIKV, FT_FuncFix2, NULL },                  
+                { ocHLookup, FT_FuncFix3, NULL },              
+                { ocDBSum, FT_FuncFix3, NULL },                
+                { ocDBAverage, FT_FuncFix3, NULL },           
+                { ocDBCount, FT_FuncFix3, NULL },             
+                { ocDBMin, FT_FuncFix3, NULL },                
+		{ ocDBMax, FT_FuncFix3, NULL }, 
+                { ocDBVar, FT_FuncFix3, NULL },               
+                { ocDBStdDev, FT_FuncFix3, NULL },            
+                { ocIndex, FT_FuncFix3, NULL },               
+                { ocColumns, FT_FuncFix1, NULL },             
+                { ocRows, FT_FuncFix1, NULL },                 
+                { ocRept, FT_FuncFix2, NULL },                 
+                { ocUpper, FT_FuncFix1, NULL },               
+                { ocLower, FT_FuncFix1, NULL },               
+                { ocLeft, FT_FuncFix2, NULL },                
+                { ocRight, FT_FuncFix2, NULL },               
+                { ocReplace, FT_FuncFix4, NULL },              
+                { ocPropper, FT_FuncFix1, NULL },              
+                { ocNoName, FT_FuncFix2, "CELL" },              
+                { ocTrim, FT_FuncFix1, NULL },                
+                { ocClean, FT_FuncFix1, NULL },               
+                { ocFalse, FT_FuncFix1, "F" },               
+                { ocTrue, FT_FuncFix1, "W" },                 
+                { ocExact, FT_FuncFix2, NULL },               
+                { ocNoName, FT_NotImpl, NULL },              
+                { ocIndirect, FT_FuncFix1, NULL },             
+                { ocZins, FT_FuncFix3, "RATE" },                
+		{ ocNoName, FT_FuncFix1, "TERM" },              
+                { ocNoName, FT_FuncFix1, "CTERM" },              
+        	{ ocLIA, FT_FuncFix3, NULL },
+		{ ocDIA, FT_FuncFix4, NULL },                  
+                { ocGDA, FT_FuncFix4, NULL },                 
+                { ocNoName, FT_NotImpl,"STDS" },         
+                { ocNoName, FT_NotImpl, "VARS" },          
+                { ocNoName, FT_NotImpl, "DSTDS" },              
+                { ocNoName, FT_NotImpl, "DVARS" },              
+                { ocNoName, FT_NotImpl, "PVAL" },              
+                { ocNoName, FT_NotImpl, "PAYMT" },              
+                { ocNoName, FT_NotImpl, "FVAL" },              
+                { ocNoName, FT_NotImpl, "NPER" },              
+                { ocNoName, FT_NotImpl, "IRATE" },              
+                { ocNoName, FT_NotImpl, "IPAYMT" },              
+                { ocNoName, FT_NotImpl, "PPAYMT" },              
+                { ocNoName, FT_NotImpl, "SUMPRODUCT" },              
+                { ocNoName, FT_NotImpl, "MEMAVAIL" },              
+                { ocNoName, FT_NotImpl, "MEMEMSAVAIL" },              
+                { ocNoName, FT_NotImpl, "FILEEXISTS" },              
+                { ocNoName, FT_NotImpl, "CURVALUE" },              
+                { ocNoName, FT_NotImpl, "DEGREES" },              
+                { ocNoName, FT_NotImpl, "RADIANS" },              
+                { ocNoName, FT_NotImpl, "HEXTONUM" },              
+                { ocNoName, FT_NotImpl, "NUMTOHEX" },              
+                { ocNoName, FT_NotImpl, "TODAY" },              
+                { ocNoName, FT_NotImpl, "NPV" },   
+		{ ocNoName, FT_NotImpl, "CELLINDEX2D" }, 
+		{ ocNoName, FT_NotImpl, "VERSION" }, 
+		{ ocNoName, FT_NotImpl, NULL }, 
+		{ ocNoName, FT_NotImpl, NULL }, 
+                { ocNoName, FT_NotImpl, NULL },
+		{ ocNoName, FT_NotImpl, NULL }, 
+		{ ocNoName, FT_NotImpl, NULL }, 
+		{ ocNoName, FT_NotImpl, NULL }, 
+		{ ocNoName, FT_NotImpl, NULL }, 
+		{ ocNoName, FT_NotImpl, NULL }, 
+		{ ocNoName, FT_NotImpl, "SHEETS" }, 
+		{ ocNoName, FT_NotImpl, NULL },
+		{ ocNoName, FT_FuncVar, NULL },
+		{ ocNoName, FT_NotImpl, "INDEX3D" },
+		{ ocNoName, FT_NotImpl, "CELLINDEX3D" }, 
+		{ ocNoName, FT_NotImpl, "PROPERTY" },
+		{ ocNoName, FT_NotImpl, "DDELINK" },
+		{ ocNoName, FT_NotImpl, "COMMAND" }
+};
+
+DefTokenId QProToSc::IndexToToken( sal_uInt16 nIndex )
+{
+	if( nIndex >= 0 && nIndex <= 161 )
+      		return aFuncMap[ nIndex ].nToken;
+}
+                                                                                                                  
+FUNC_TYPE QProToSc::IndexToType( sal_uInt8 nIndex )
+{
+	if( nIndex >= 0 && nIndex <= 161 )	
+      		return aFuncMap[ nIndex ].nType;
+}
+
+const sal_Char* QProToSc::GetAddInName( const UINT8 nIndex )
+{
+	if( nIndex >= 0 && nIndex <= 161 )
+		return aFuncMap[ nIndex ].addInName;
+}
+                                                                                                                  
+
