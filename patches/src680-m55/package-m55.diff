Index: package/inc/ZipPackage.hxx
===================================================================
RCS file: /cvs/xml/package/inc/ZipPackage.hxx,v
retrieving revision 1.36
diff -u -r1.36 ZipPackage.hxx
--- package/inc/ZipPackage.hxx	4 Oct 2004 21:07:34 -0000	1.36
+++ package/inc/ZipPackage.hxx	8 Oct 2004 09:00:48 -0000
@@ -156,9 +156,7 @@
 	sal_Bool writeFileIsTemp();
 	::com::sun::star::uno::Reference < ::com::sun::star::io::XActiveDataStreamer > openOriginalForOutput();
 	void WriteMimetypeMagicFile( ZipOutputStream& aZipOut );
-	void DisconnectFromTargetAndThrowException_Impl(
-			const ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream >& xTempStream );
-
+	
 public:
 	ZipPackage (const ::com::sun::star::uno::Reference < com::sun::star::lang::XMultiServiceFactory > &xNewFactory);
 	virtual ~ZipPackage( void );
Index: package/source/xstor/register.cxx
===================================================================
RCS file: /cvs/xml/package/source/xstor/register.cxx,v
retrieving revision 1.4
diff -u -r1.4 register.cxx
--- package/source/xstor/register.cxx	4 Oct 2004 21:08:09 -0000	1.4
+++ package/source/xstor/register.cxx	8 Oct 2004 09:00:49 -0000
@@ -121,9 +121,9 @@
 										OStorageFactory::impl_staticGetImplementationName() +
 										::rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "/UNO/SERVICES") )  );
 
-			const uno::Sequence< ::rtl::OUString > aServices = OStorageFactory::impl_staticGetSupportedServiceNames();
-			for( sal_Int32 ind = 0; ind < aServices.getLength(); ind++ )
-				xNewKey->createKey( aServices.getConstArray()[ind] );
+			const uno::Sequence< ::rtl::OUString > &rServices = OStorageFactory::impl_staticGetSupportedServiceNames();
+			for( sal_Int32 ind = 0; ind < rServices.getLength(); ind++ )
+				xNewKey->createKey( rServices.getConstArray()[ind] );
 
 			return sal_True;
 		}
Index: package/source/xstor/xfactory.cxx
===================================================================
RCS file: /cvs/xml/package/source/xstor/xfactory.cxx,v
retrieving revision 1.4
diff -u -r1.4 xfactory.cxx
--- package/source/xstor/xfactory.cxx	4 Oct 2004 21:08:20 -0000	1.4
+++ package/source/xstor/xfactory.cxx	8 Oct 2004 09:00:49 -0000
@@ -210,13 +210,14 @@
 				aPropsToSet[0].Name = ::rtl::OUString::createFromAscii( "URL" );
 				aPropsToSet[0].Value <<= aURL;
 			}
+			// TODO: fill in aPropsToSet
 
 			for ( sal_Int32 nInd = 0, nNumArgs = 1; nInd < aDescr.getLength(); nInd++ )
 			{
 				if ( aDescr[nInd].Name.equalsAscii( "InteractionHandler" )
 				  || aDescr[nInd].Name.equalsAscii( "Password" )
-				  || aDescr[nInd].Name.equalsAscii( "RepairPackage" )
-				  || aDescr[nInd].Name.equalsAscii( "StatusIndicator" ) )
+				  || aDescr[nInd].Name.equalsAscii( "RepairPackage" ) )
+				  // || aDescr[nInd].Name.equalsAscii( "StatusIndicator" ) ) // TODO: may be should be changed to ProgressHandler
 				  // || aDescr[nInd].Name.equalsAscii( "Unpacked" ) // TODO:
 				{
 					aPropsToSet.realloc( ++nNumArgs );
Index: package/source/xstor/xstorage.cxx
===================================================================
RCS file: /cvs/xml/package/source/xstor/xstorage.cxx,v
retrieving revision 1.13
diff -u -r1.13 xstorage.cxx
--- package/source/xstor/xstorage.cxx	4 Oct 2004 21:08:31 -0000	1.13
+++ package/source/xstor/xstorage.cxx	8 Oct 2004 09:00:52 -0000
@@ -66,9 +66,6 @@
 #ifndef _COM_SUN_STAR_EMBED_ELEMENTMODES_HPP_
 #include <com/sun/star/embed/ElementModes.hpp>
 #endif
-#ifndef _COM_SUN_STAR_EMBED_USEBACKUPEXCEPTION_HPP_
-#include <com/sun/star/embed/UseBackupException.hpp>
-#endif
 
 #ifndef _COM_SUN_STAR_UCB_XPROGRESSHANDLER_HPP_
 #include <com/sun/star/ucb/XProgressHandler.hpp>
@@ -289,7 +286,6 @@
 , m_xFactory( xFactory )
 , m_xStream( xStream )
 , m_xProperties( xProperties )
-, m_bHasCommonPassword( sal_False )
 , m_pParent( NULL )
 , m_bControlMediaType( sal_False )
 {
@@ -324,7 +320,6 @@
 , m_xPackageFolder( xPackageFolder )
 , m_xPackage( xPackage )
 , m_xFactory( xFactory )
-, m_bHasCommonPassword( sal_False )
 , m_pParent( pParent ) // can be empty in case of temporary readonly substorages
 , m_bControlMediaType( sal_False )
 {
@@ -767,16 +762,6 @@
 {
 	::osl::MutexGuard aGuard( m_rMutexRef->GetMutex() );
 
-	if ( !m_bListCreated )
-	{
-		// nothing was changed, but a new empty storage must be marked as commited one
-		ReadContents();
-		if ( !m_bIsRoot && !m_aChildrenList.size() )
-			m_bCommited = sal_True;
-
-		return;
-	}
-
 	// if storage is commited it should have a valid Package representation
 	OSL_ENSURE( m_xPackageFolder.is(), "The package representation should exist!\n" );
 	if ( !m_xPackageFolder.is() )
@@ -951,23 +936,7 @@
 		if ( !xChangesBatch.is() )
 			throw uno::RuntimeException(); // TODO
 
-		try
-		{
-			xChangesBatch->commitChanges();
-		}
-		catch( lang::WrappedTargetException& r )
-		{
-			// the wrapped UseBackupException means that the target medium can be corrupted
-			embed::UseBackupException aException;
-			if ( r.TargetException >>= aException )
-			{
-				m_xStream = uno::Reference< io::XStream >();
-				m_xInputStream = uno::Reference< io::XInputStream >();
-				throw aException;
-			}
-
-			throw;
-		}
+		xChangesBatch->commitChanges();
 	}
 	else if ( !m_bCommited )
 	{
@@ -1655,7 +1624,6 @@
 					,	static_cast<lang::XTypeProvider*> ( this )
 					,	static_cast<embed::XStorage*> ( this )
 					,	static_cast<embed::XTransactedObject*> ( this )
-					,	static_cast<embed::XTransactionBroadcaster*> ( this )
 					,	static_cast<util::XModifiable*> ( this )
 					,	static_cast<container::XNameAccess*> ( this )
 					,	static_cast<container::XElementAccess*> ( this )
@@ -1714,7 +1682,6 @@
 									(	::getCppuType( ( const uno::Reference< lang::XTypeProvider >* )NULL )
 									,	::getCppuType( ( const uno::Reference< embed::XStorage >* )NULL )
 									,	::getCppuType( ( const uno::Reference< embed::XTransactedObject >* )NULL )
-									,	::getCppuType( ( const uno::Reference< embed::XTransactionBroadcaster >* )NULL )
 									,	::getCppuType( ( const uno::Reference< util::XModifiable >* )NULL )
 									// ,	::getCppuType( ( const uno::Reference< container::XNameAccess >* )NULL )
 									// ,	::getCppuType( ( const uno::Reference< lang::XComponent >* )NULL )
@@ -2218,8 +2185,8 @@
 	if ( !m_pImpl )
 		throw lang::DisposedException();
 
-	if ( !aElementName.getLength() || !aNewName.getLength() || !xDest.is() ) 
-		// || xDest == uno::Reference< uno::XInterface >( static_cast< OWeakObject* >( this ), uno::UNO_QUERY ) )
+	if ( !aElementName.getLength() || !aNewName.getLength()
+	  || !xDest.is() || xDest == uno::Reference< uno::XInterface >( static_cast< OWeakObject* >( this ), uno::UNO_QUERY ) )
 		throw lang::IllegalArgumentException();
 
 	SotElement_Impl* pElement = m_pImpl->FindElement( aElementName );
@@ -2322,6 +2289,9 @@
 
     if ( m_pData->m_bReadOnlyWrap )
 		throw io::IOException(); // TODO: access_denied
+
+	if ( !m_pImpl->m_bListCreated )
+		return; // nothing was changed
 
 	try {
 		BroadcastTransaction( STOR_MESS_PRECOMMIT );
Index: package/source/zippackage/ContentInfo.hxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ContentInfo.hxx,v
retrieving revision 1.6
diff -u -r1.6 ContentInfo.hxx
--- package/source/zippackage/ContentInfo.hxx	4 Oct 2004 21:08:42 -0000	1.6
+++ package/source/zippackage/ContentInfo.hxx	8 Oct 2004 09:00:52 -0000
@@ -101,8 +101,6 @@
 	{
 		if ( bFolder )
 			pFolder->releaseUpwardRef();
-		else
-			pStream->clearParent();
 	}
 };
 } } } };
Index: package/source/zippackage/ZipPackage.cxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ZipPackage.cxx,v
retrieving revision 1.94
diff -u -r1.94 ZipPackage.cxx
--- package/source/zippackage/ZipPackage.cxx	4 Oct 2004 21:09:39 -0000	1.94
+++ package/source/zippackage/ZipPackage.cxx	8 Oct 2004 09:00:54 -0000
@@ -88,9 +88,6 @@
 #ifndef _COM_SUN_STAR_BEANS_PROPERTYVALUE_HPP_
 #include <com/sun/star/beans/PropertyValue.hpp>
 #endif
-#ifndef _COM_SUN_STAR_BEANS_NAMEDVALUE_HPP_
-#include <com/sun/star/beans/NamedValue.hpp>
-#endif
 #ifndef _COM_SUN_STAR_PACKAGES_ZIP_ZIPCONSTANTS_HPP_
 #include <com/sun/star/packages/zip/ZipConstants.hpp>
 #endif
@@ -145,15 +142,9 @@
 #ifndef _COM_SUN_STAR_UCB_XPROGRESSHANDLER_HPP_
 #include <com/sun/star/ucb/XProgressHandler.hpp>
 #endif
-#ifndef _COM_SUN_STAR_UCB_XSIMPLEFILEACCESS_HPP_
-#include <com/sun/star/ucb/XSimpleFileAccess.hpp>
-#endif
 #ifndef _COM_SUN_STAR_IO_XACTIVEDATASTREAMER_HPP_
 #include <com/sun/star/io/XActiveDataStreamer.hpp>
 #endif
-#ifndef _COM_SUN_STAR_EMBED_USEBACKUPEXCEPTION_HPP_
-#include <com/sun/star/embed/UseBackupException.hpp>
-#endif
 #ifndef _COM_SUN_STAR_BEANS_NAMEDVALUE_HPP_
 #include <com/sun/star/beans/NamedValue.hpp>
 #endif
@@ -313,23 +304,14 @@
 ZipPackage::~ZipPackage( void )
 {
 	delete pZipFile;
-
-	// All folders and streams contain pointers to their parents, when a parent diappeares
-	// it should disconnect all the children from itself during destruction automatically.
-	// So there is no need in explicit pRootFolder->releaseUpwardRef() call here any more
-	// since pRootFolder has no parent and cleaning of it's children will be done automatically
-	// during pRootFolder dieing by refcount.
-
-#if 0
 	// As all folders and streams contain references to their parents,
 	// we must remove these references so that they will be deleted when
 	// the hash_map of the root folder is cleared, releasing all subfolders
 	// and substreams which in turn release theirs, etc. When xRootFolder is
 	// released when this destructor completes, the folder tree should be
 	// deleted fully (and automagically).
-
+	
 	pRootFolder->releaseUpwardRef();
-#endif
 }
 
 void ZipPackage::getZipFileContents()
@@ -667,9 +649,7 @@
 			{
 				// clean up the memory, and tell the UCB about the error
 				if( pZipFile ) { delete pZipFile; pZipFile = NULL; }
-
-				throw com::sun::star::packages::zip::ZipIOException (
-					OUString( RTL_CONSTASCII_USTRINGPARAM ( "Bad Zip File." ) ),
+				throw com::sun::star::uno::Exception ( OUString( RTL_CONSTASCII_USTRINGPARAM ( "Bad Zip File." ) ),
 					static_cast < ::cppu::OWeakObject * > ( this ) );
 			}
 		}
@@ -1082,6 +1062,29 @@
 				makeAny( r ) );
 	}
 	
+	if ( eMode == e_IMode_XStream )
+	{
+		// First truncate our output stream
+		Reference < XOutputStream > xOutputStream = xStream->getOutputStream();
+		Reference < XTruncate > xTruncate ( xOutputStream, UNO_QUERY );
+		if ( !xTruncate.is() )
+		{
+			IOException aException;
+			throw WrappedTargetException( OUString( RTL_CONSTASCII_USTRINGPARAM ( "This package is read only!" ) ),
+					static_cast < OWeakObject * > ( this ), makeAny ( aException ) );
+		}
+		xTruncate->truncate();
+
+		// Then set up the tempfile to be read from
+		Reference < XInputStream > xTempIn ( xTempOut, UNO_QUERY );
+		Reference < XSeekable > xTempSeek ( xTempOut, UNO_QUERY );
+		xTempSeek->seek ( 0 );
+
+		// then copy the contents of the tempfile to our output stream
+		copyInputToOutput_Impl( xTempIn, xOutputStream );
+		xOutputStream->flush();
+	}
+
 	// Update our References to point to the new temp file
 	if( aUseTemp )
 	{
@@ -1184,163 +1187,82 @@
 	// xContentSeek and xContentStream will reference the new temporary file.
 	// Exception - empty or nonexistent local file that is written directly
 
-	if ( writeFileIsTemp() )
+	if ( writeFileIsTemp() && eMode == e_IMode_URL )
 	{
-		if ( eMode == e_IMode_XStream )
-		{
-			// First truncate our output stream
-			Reference < XOutputStream > xOutputStream;
-
-			// preparation for copy step
-			try
-			{
-				xContentSeek->seek( 0 );
+		Reference< XOutputStream > aOrigFileStream;
 
-				xOutputStream = xStream->getOutputStream();
-				Reference < XTruncate > xTruncate ( xOutputStream, UNO_QUERY );
-				if ( !xTruncate.is() )
-					throw uno::RuntimeException();
-
-				// after successful truncation the original file contents are already lost
-				xTruncate->truncate();
-			}
-			catch( uno::Exception& r )
-			{
-				throw WrappedTargetException( OUString( RTL_CONSTASCII_USTRINGPARAM ( "This package is read only!" ) ),
-						static_cast < OWeakObject * > ( this ), makeAny ( r ) );
-			}
-
-			try
-			{
-				// then copy the contents of the tempfile to our output stream
-				copyInputToOutput_Impl( xContentStream, xOutputStream );
-				xOutputStream->flush();
-			}
-			catch( uno::Exception& )
-			{
-				// if anything goes wrong in this block the target file becomes corrupted
-				// so an exception should be thrown as a notification about it
-				// and the package must disconnect from the stream
-				DisconnectFromTargetAndThrowException_Impl( xContentStream );
-			}
-		}
-		else if ( eMode == e_IMode_URL )
+		if( isLocalFile_Impl( sURL ) )
 		{
-			Reference< XOutputStream > aOrigFileStream;
-			sal_Bool bCanBeCorrupted = sal_False;
-	
-			if( isLocalFile_Impl( sURL ) )
+			// write directly in case of local file
+			Reference< XActiveDataStreamer > xSink = openOriginalForOutput();
+			
+			if( xSink.is() )
 			{
-				// write directly in case of local file
-				uno::Reference< ::com::sun::star::ucb::XSimpleFileAccess > xSimpleAccess(
-					xFactory->createInstance( ::rtl::OUString::createFromAscii( "com.sun.star.ucb.SimpleFileAccess" ) ),
-					uno::UNO_QUERY );
-				OSL_ENSURE( xSimpleAccess.is(), "Can't instatiate SimpleFileAccess service!\n" );
-				uno::Reference< io::XTruncate > xOrigTruncate;
-				if ( xSimpleAccess.is() )
+				Reference< XStream > xStr = xSink->getStream();
+				if( xStr.is() )
 				{
-					try
-					{
-						aOrigFileStream = xSimpleAccess->openFileWrite( sURL );
-						xOrigTruncate = uno::Reference< io::XTruncate >( aOrigFileStream, uno::UNO_QUERY_THROW );
-						// after successful truncation the file is already corrupted
-						xOrigTruncate->truncate();
-					}
-					catch( uno::Exception& )
-					{}
-				}
-
-				if( xOrigTruncate.is() )
-				{
-					try
+					aOrigFileStream = xStr->getOutputStream();
+					if( aOrigFileStream.is() )
 					{
 						copyInputToOutput_Impl( xContentStream, aOrigFileStream );
 						aOrigFileStream->closeOutput();
-					}
-					catch( uno::Exception& )
-					{
-						try {
-							aOrigFileStream->closeOutput();
-						} catch ( uno::Exception& ) {}
-
-						aOrigFileStream = uno::Reference< XOutputStream >();
-						// the original file can already be corrupted
-						bCanBeCorrupted = sal_True;
+						xContentSeek->seek ( 0 );
 					}
 				}
 			}
-	
-			if( !aOrigFileStream.is() )
+		}
+
+		if( !aOrigFileStream.is() )
+		{
+			Reference < XPropertySet > xPropSet ( xContentStream, UNO_QUERY );
+			if ( xPropSet.is() )
 			{
+				OUString sTargetFolder = sURL.copy ( 0, sURL.lastIndexOf ( static_cast < sal_Unicode > ( '/' ) ) );
+				Content aContent ( sTargetFolder, Reference < XCommandEnvironment > () );
+
+				OUString sTempURL;
+				Any aAny = xPropSet->getPropertyValue ( OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Uri" ) ) );
+				aAny >>= sTempURL;
+
+				TransferInfo aInfo;
+				aInfo.NameClash = NameClash::OVERWRITE;
+				aInfo.MoveData = sal_False;
+				aInfo.SourceURL = sTempURL;
+				aInfo.NewTitle = rtl::Uri::decode ( sURL.copy ( 1 + sURL.lastIndexOf ( static_cast < sal_Unicode > ( '/' ) ) ),
+													rtl_UriDecodeWithCharset,
+													RTL_TEXTENCODING_UTF8 );
+				aAny <<= aInfo;
 				try
 				{
-					Reference < XPropertySet > xPropSet ( xContentStream, UNO_QUERY );
-					OSL_ENSURE( xPropSet.is(), "This is a temporary file that must implement XPropertySet!\n" );
-					if ( !xPropSet.is() )
-						throw uno::RuntimeException();
-
-					OUString sTargetFolder = sURL.copy ( 0, sURL.lastIndexOf ( static_cast < sal_Unicode > ( '/' ) ) );
-					Content aContent ( sTargetFolder, Reference < XCommandEnvironment > () );
-	
-					OUString sTempURL;
-					Any aAny = xPropSet->getPropertyValue ( OUString ( RTL_CONSTASCII_USTRINGPARAM ( "Uri" ) ) );
-					aAny >>= sTempURL;
-	
-					TransferInfo aInfo;
-					aInfo.NameClash = NameClash::OVERWRITE;
-					aInfo.MoveData = sal_False;
-					aInfo.SourceURL = sTempURL;
-					aInfo.NewTitle = rtl::Uri::decode ( sURL.copy ( 1 + sURL.lastIndexOf ( static_cast < sal_Unicode > ( '/' ) ) ),
-														rtl_UriDecodeWithCharset,
-														RTL_TEXTENCODING_UTF8 );
-					aAny <<= aInfo;
-
-					// if the file is still not corrupted, it can become after the next step
 					aContent.executeCommand ( OUString ( RTL_CONSTASCII_USTRINGPARAM ( "transfer" ) ), aAny );
 				}
 				catch (::com::sun::star::uno::Exception& r)
 				{
-					if ( bCanBeCorrupted )
-						DisconnectFromTargetAndThrowException_Impl( xContentStream );
+					throw WrappedTargetException( OUString( RTL_CONSTASCII_USTRINGPARAM ( "Unable to write Zip File to disk!" ) ),
+							static_cast < OWeakObject * > ( this ), makeAny( r ) );
+				}
+			}
+			else
+			{
+				// not quite sure how it could happen that xContentStream WOULDN'T support
+				// XPropertySet, but just in case... :)
 
-					throw WrappedTargetException(
-												OUString( RTL_CONSTASCII_USTRINGPARAM ( "This package may be read only!" ) ),
-												static_cast < OWeakObject * > ( this ),
-												makeAny ( r ) );
+				Content aOriginalContent (sURL, Reference < XCommandEnvironment >() );
+	
+				try
+				{
+					aOriginalContent.writeStream ( xContentStream, sal_True );
+				}
+				catch (::com::sun::star::uno::Exception& r)
+				{
+					throw WrappedTargetException( OUString( RTL_CONSTASCII_USTRINGPARAM ( "Unable to write Zip File to disk!" ) ),
+							static_cast < OWeakObject * > ( this ), makeAny( r ) );
 				}
 			}
 		}
 	}
 
 	RTL_LOGFILE_TRACE_AUTHOR ( "package", LOGFILE_AUTHOR, "} ZipPackage::commitChanges" );	
-}
-
-void ZipPackage::DisconnectFromTargetAndThrowException_Impl( const uno::Reference< io::XInputStream >& xTempStream )
-{
-	xStream = uno::Reference< io::XStream >( xTempStream, uno::UNO_QUERY );
-	if ( xStream.is() )
-		eMode = e_IMode_XStream;
-	else
-		eMode = e_IMode_XInputStream;
-
-	::rtl::OUString aTempURL;
-	try {
-		uno::Reference< beans::XPropertySet > xTempFile( xContentStream, uno::UNO_QUERY_THROW );
-		uno::Any aUrl = xTempFile->getPropertyValue( ::rtl::OUString::createFromAscii( "Uri" ) );
-		aUrl >>= aTempURL;
-		xTempFile->setPropertyValue( ::rtl::OUString::createFromAscii( "RemoveFile" ),
-									 uno::makeAny( sal_False ) );
-	}
-	catch ( uno::Exception& )
-	{
-		OSL_ENSURE( sal_False, "This calls are pretty simple, they should not fail!\n" );
-	}
-
-	::rtl::OUString aErrTxt( RTL_CONSTASCII_USTRINGPARAM ( "This package is read only!" ) );
-	embed::UseBackupException aException( aErrTxt, uno::Reference< uno::XInterface >(), aTempURL );
-	throw WrappedTargetException( aErrTxt,
-									static_cast < OWeakObject * > ( this ),
-									makeAny ( aException ) );
 }
 
 sal_Bool SAL_CALL ZipPackage::hasPendingChanges(  ) 
Index: package/source/zippackage/ZipPackageEntry.cxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ZipPackageEntry.cxx,v
retrieving revision 1.25
diff -u -r1.25 ZipPackageEntry.cxx
--- package/source/zippackage/ZipPackageEntry.cxx	4 Oct 2004 21:09:49 -0000	1.25
+++ package/source/zippackage/ZipPackageEntry.cxx	8 Oct 2004 09:00:54 -0000
@@ -96,10 +96,7 @@
 
 ZipPackageEntry::~ZipPackageEntry()
 {
-	// When the entry is destroyed it must be already disconnected from the parent
-	OSL_ENSURE( !pParent, "The parent must be disconnected already! Memory corruption is possible!\n" );
 }
-
 // XChild
 OUString SAL_CALL ZipPackageEntry::getName(  ) 
 	throw(RuntimeException)
@@ -123,14 +120,12 @@
 Reference< XInterface > SAL_CALL ZipPackageEntry::getParent(  ) 
 		throw(RuntimeException)
 {
-	// return Reference< XInterface >( xParent, UNO_QUERY );
-	return Reference< XInterface >( static_cast< ::cppu::OWeakObject* >( pParent ), UNO_QUERY );
+	return Reference< XInterface >( xParent, UNO_QUERY );
 }
 
 void ZipPackageEntry::doSetParent ( ZipPackageFolder * pNewParent, sal_Bool bInsert )
 {
-	// xParent = pParent = pNewParent;
-	pParent = pNewParent;
+	xParent = pParent = pNewParent;
 	if ( bInsert && !pNewParent->hasByName ( aEntry.sName ) )
 		pNewParent->doInsertByName ( this, sal_False );
 }
Index: package/source/zippackage/ZipPackageEntry.hxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ZipPackageEntry.hxx,v
retrieving revision 1.12
diff -u -r1.12 ZipPackageEntry.hxx
--- package/source/zippackage/ZipPackageEntry.hxx	4 Oct 2004 21:10:01 -0000	1.12
+++ package/source/zippackage/ZipPackageEntry.hxx	8 Oct 2004 09:00:54 -0000
@@ -99,7 +99,7 @@
 {
 protected:
 	bool mbIsFolder:1;
-	// com::sun::star::uno::Reference < com::sun::star::container::XNameContainer > xParent;
+	com::sun::star::uno::Reference < com::sun::star::container::XNameContainer > xParent;
 	::rtl::OUString		sMediaType;
 	ZipPackageFolder * pParent;
 public:
@@ -116,8 +116,7 @@
 
 	void clearParent ( void )
 	{
-		// xParent.clear();
-		pParent = NULL;
+		xParent.clear();
 	}
 	// XNamed
     virtual ::rtl::OUString SAL_CALL getName(  ) 
Index: package/source/zippackage/ZipPackageFolder.cxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ZipPackageFolder.cxx,v
retrieving revision 1.69
diff -u -r1.69 ZipPackageFolder.cxx
--- package/source/zippackage/ZipPackageFolder.cxx	4 Oct 2004 21:10:12 -0000	1.69
+++ package/source/zippackage/ZipPackageFolder.cxx	8 Oct 2004 09:00:55 -0000
@@ -146,7 +146,6 @@
 ZipPackageFolder::~ZipPackageFolder()
 {
 }
-
 void ZipPackageFolder::copyZipEntry( ZipEntry &rDest, const ZipEntry &rSource)
 {
   	rDest.nVersion			= rSource.nVersion;
@@ -292,33 +291,6 @@
 
 	sal_Bool bHaveEncryptionKey = rEncryptionKey.getLength() ? sal_True : sal_False;
 
-	if ( maContents.begin() == maContents.end() )
-	{
-		// it is an empty folder, use workaround to store it
-		ZipEntry* pTempEntry = new ZipEntry();
-		ZipPackageFolder::copyZipEntry ( *pTempEntry, aEntry );
-		pTempEntry->nNameLen = (sal_Int16)rPath.getLength();
-		pTempEntry->nExtraLen = -1;
-		pTempEntry->sName = rPath;
-
-		try
-		{
-			vos::ORef < EncryptionData > aEmptyEncr;
-			rZipOut.putNextEntry ( *pTempEntry, aEmptyEncr, sal_False );
-			rZipOut.rawCloseEntry();
-		}
-		catch ( ZipException& )
-		{
-			VOS_ENSURE( 0, "Error writing ZipOutputStream" );
-			bWritingFailed = sal_True;
-		}
-		catch ( IOException& )
-		{
-			VOS_ENSURE( 0, "Error writing ZipOutputStream" );
-			bWritingFailed = sal_True;
-		}
-	}
-
 	for ( ContentHash::const_iterator aCI = maContents.begin(), aEnd = maContents.end();
 	      aCI != aEnd; 
 		  aCI++)
@@ -356,7 +328,7 @@
 
 			ZipPackageFolder::copyZipEntry ( *pTempEntry, pStream->aEntry );
 			pTempEntry->sName = rPath + rShortName;
-			pTempEntry->nNameLen = (sal_Int16)( pTempEntry->sName.getLength() );
+			pTempEntry->nNameLen = pTempEntry->sName.getLength();
 
 			sal_Bool bToBeEncrypted = pStream->IsToBeEncrypted() && (bHaveEncryptionKey || pStream->HasOwnKey());
 			sal_Bool bToBeCompressed = bToBeEncrypted ? sal_True : pStream->IsToBeCompressed();
@@ -498,12 +470,12 @@
 
 					rZipOut.rawCloseEntry();
 				}
-				catch ( ZipException& )
+				catch ( ZipException& r )
 				{
 					VOS_ENSURE( 0, "Error writing ZipOutputStream" );
 					bWritingFailed = sal_True;
 				}
-				catch ( IOException& )
+				catch ( IOException& r )
 				{
 					VOS_ENSURE( 0, "Error writing ZipOutputStream" );
 					bWritingFailed = sal_True;
@@ -547,12 +519,12 @@
 
 					rZipOut.closeEntry();
 				}
-				catch ( ZipException& )
+				catch ( ZipException& r )
 				{
 					VOS_ENSURE( 0, "Error writing ZipOutputStream" );
 					bWritingFailed = sal_True;
 				}
-				catch ( IOException& )
+				catch ( IOException& r )
 				{
 					VOS_ENSURE( 0, "Error writing ZipOutputStream" );
 					bWritingFailed = sal_True;
@@ -605,17 +577,6 @@
 
 void ZipPackageFolder::releaseUpwardRef( void )
 {
-	// Now it is possible that a package folder is disconnected from the package before removing of the folder.
-	// Such a scenario is used in storage implementation. When a new version of a folder is provided the old
-	// one is retrieved, removed from the package but preserved for the error handling.
-	// In this scenario the referencing to the parent is not really useful, since it requires disposing.
-
-	// Actually there is no need in having a reference to the parent, it even make things more complicated and
-	// requires disposing mechanics. Using of a simple pointer seems to be easier solution and also a safe enough.
-
-	clearParent();
-
-#if 0
 	for ( ContentHash::const_iterator aCI = maContents.begin();
 		  aCI!=maContents.end();
 		  aCI++)
@@ -627,9 +588,6 @@
 			rInfo.pStream->clearParent();
 	}
 	clearParent();
-
-	VOS_ENSURE ( m_refCount == 1, "Ref-count is not 1!" );
-#endif
 }
 
 sal_Int64 SAL_CALL ZipPackageFolder::getSomething( const Sequence< sal_Int8 >& aIdentifier ) 
Index: package/source/zippackage/ZipPackageFolderEnumeration.hxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ZipPackageFolderEnumeration.hxx,v
retrieving revision 1.5
diff -u -r1.5 ZipPackageFolderEnumeration.hxx
--- package/source/zippackage/ZipPackageFolderEnumeration.hxx	4 Oct 2004 21:10:22 -0000	1.5
+++ package/source/zippackage/ZipPackageFolderEnumeration.hxx	8 Oct 2004 09:00:55 -0000
@@ -81,7 +81,7 @@
 >
 {
 protected:
-	ContentHash rContents;
+	ContentHash &rContents;
 	ContentHash::const_iterator aIterator;
 public:
 	//ZipPackageFolderEnumeration (std::hash_map < rtl::OUString, com::sun::star::uno::Reference < com::sun::star::container::XNamed >, hashFunc, eqFunc > &rInput);
