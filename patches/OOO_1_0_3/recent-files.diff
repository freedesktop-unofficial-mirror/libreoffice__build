First the makefile blurb:

Index: svtools/util/makefile.mk
===================================================================
RCS file: /cvs/oo/util/svtools/util/makefile.mk,v
retrieving revision 1.31.4.2
diff -u -p -u -r1.31.4.2 makefile.mk
--- svtools/util/makefile.mk    30 May 2002 11:46:50 -0000      1.31.4.2
+++ svtools/util/makefile.mk    5 Mar 2003 12:07:27 -0000
@@ -238,6 +238,10 @@
 		$(UNOTOOLSLIB)		\
 		$(UCBHELPERLIB)
 
+.IF "$(GUI)"=="UNX"
+SHL2STDLIBS+= $(EXPATASCII3RDLIB) `pkg-config --libs glib-2.0`
+.ENDIF
+
 .IF "$(GUI)"=="WNT"
 SHL2STDLIBS+= \
 			$(LIBPRE) advapi32.lib	\
Index: svtools/source/config/makefile.mk
===================================================================
RCS file: /cvs/oo/util/svtools/source/config/makefile.mk,v
retrieving revision 1.31.2.1
diff -u -p -u -r1.31.2.1 makefile.mk
--- svtools/source/config/makefile.mk   31 Oct 2002 20:37:05 -0000      1.31.2.1
+++ svtools/source/config/makefile.mk   5 Mar 2003 12:07:42 -0000
@@ -104,7 +104,13 @@
     $(SLO)$/syslocaleoptions.obj        \
 	$(SLO)$/cacheoptions.obj			\
 	$(SLO)$/regoptions.obj				\
-	$(SLO)$/extendedsecurityoptions.obj
+       $(SLO)$/extendedsecurityoptions.obj             \
+       $(SLO)$/recent-files.obj
+
+.IF "$(GUI)"=="UNX"
+CFLAGS+=-Wall
+CFLAGS+=`pkg-config --cflags glib-2.0`
+.ENDIF
 
 EXCEPTIONSFILES = \
     $(SLO)$/accelcfg.obj				\
--- svtools/prj/build.lst	Tue Jul 31 09:16:40 2001
+++ svtools/prj/build.lst	Tue Mar  4 18:48:00 2003
@@ -1,4 +1,4 @@
-st	svtools	:	toolkit ucbhelper unotools NULL
+st	svtools	:	toolkit ucbhelper unotools expat NULL
 st	svtools									usr1	-	all	st_mkout NULL
 st	svtools\inc								get		-	all	st_inc NULL
 st	svtools\inc\sane						get		-	all	st_incsa NULL

Now changes to the existing source:

--- svtools/inc/historyoptions.hxx	Fri Dec  7 06:29:14 2001
+++ svtools/inc/historyoptions.hxx	Mon Apr 14 16:28:44 2003
@@ -239,6 +239,7 @@
 			@param		"eHistory" select right history.
 			@param		"sURL" URL to save in history
 			@param		"sFilter" filter name to save in history
+			@param		"sMimeType" MIME type of the URL; used only for ePICKLIST.
 			@param		"sTitle" document title to save in history
 			@param		"sPassword" password to save in history
 			@return		-
@@ -249,6 +250,7 @@
 		void AppendItem(			EHistoryType		eHistory	,
 							const	::rtl::OUString&	sURL		,
 							const	::rtl::OUString&	sFilter		,
+							const	::rtl::OUString&	sMimeType	,
 							const	::rtl::OUString&	sTitle		,
 							const	::rtl::OUString&	sPassword	);
 
Index: svtools/source/config/historyoptions.cxx
===================================================================
RCS file: /cvs/oo/util/svtools/source/config/historyoptions.cxx,v
retrieving revision 1.11
diff -u -p -u -r1.11 historyoptions.cxx
--- svtools/source/config/historyoptions.cxx	7 Dec 2001 12:30:39 -0000	1.11
+++ svtools/source/config/historyoptions.cxx	5 Mar 2003 12:08:22 -0000
@@ -95,6 +95,8 @@
 #include <algorithm>
 #endif
 
+#include "recent-files.hxx"
+
 //_________________________________________________________________________________________________________________
 //	namespaces
 //_________________________________________________________________________________________________________________
@@ -403,8 +405,10 @@
     sal_uInt32 nPosition = FIXPROPERTYCOUNT; // step over first three readed size values! but count begins at 0!
 	// Get names/values for picklist.
 	// 4 subkeys for every item!
+	sal_uInt32 nItem;
+#if 0
 	OUString sName;
-    for( sal_uInt32 nItem=0; nItem<nPicklistCount; ++nItem )
+    for( nItem=0; nItem<nPicklistCount; ++nItem )
 	{
 		seqValues[nPosition] >>= aItem.sURL			;
 		++nPosition;
@@ -416,6 +420,26 @@
 		++nPosition;
 		m_aPicklist.push_back( aItem );
 	}
+#endif
+	/* The user may already have a pick list from OOo, so we have to skip over it --- we now fetch the list from GNOME */
+	nPosition += nPicklistCount * 4;
+
+	::svl::RecentFileItem *items;
+	int n_items;
+	int i;
+
+	::svl::recent_files_get_list (&items, &n_items);
+
+	aItem.sFilter = OUString ("", 0, RTL_TEXTENCODING_ASCII_US);
+	aItem.sPassword = OUString ("", 0, RTL_TEXTENCODING_ASCII_US);
+
+	for (i = 0; i < n_items; i++) {
+		aItem.sURL = OUString(items[i].uri);
+		aItem.sTitle = OUString (items[i].uri); /* We don't have a title, so just use the filename */
+		m_aPicklist.push_back (aItem);
+	}
+
+	::svl::recent_files_free (items, n_items);
 
 	// Attention: Don't reset nPosition here!
 
@@ -506,9 +530,11 @@
 	OUString					sNode					;
 	Sequence< PropertyValue >	seqPropertyValues( 4 )	;
 
+	sal_uInt32 nItem;
+#if 0
 	// Copy picklist entries to save-list!
     sal_uInt32 nPicklistCount = m_aPicklist.size();
-    for( sal_uInt32 nItem=0; nItem<nPicklistCount; ++nItem )
+    for( nItem=0; nItem<nPicklistCount; ++nItem )
 	{
 		aItem	= m_aPicklist[nItem];
 		sNode	= PROPERTYNAME_PICKLIST + PATHDELIMITER + FIXP + OUString::valueOf( (sal_Int32)nItem ) + PATHDELIMITER;
@@ -523,7 +549,7 @@
 
 		SetSetProperties( PROPERTYNAME_PICKLIST, seqPropertyValues );
 	}
-
+#endif
 	// Copy URL-list entries to save-list!
     sal_uInt32 nHistoryCount = m_aHistory.size();
 	for( nItem=0; nItem<nHistoryCount; ++nItem )
@@ -909,11 +935,16 @@
 void SvtHistoryOptions::AppendItem(			EHistoryType	eHistory	,
 									const	OUString&		sURL		,
 									const	OUString&		sFilter		,
+									const	OUString&		sMimeType	,
 									const	OUString&		sTitle		,
 									const	OUString&		sPassword	)
 {
     MutexGuard aGuard( GetOwnStaticMutex() );
-	m_pDataContainer->AppendItem( eHistory, sURL, sFilter, sTitle, sPassword );
+
+	if (eHistory == ePICKLIST)
+		::svl::recent_files_add_item (sURL.pData, sMimeType.pData);
+	else
+		m_pDataContainer->AppendItem( eHistory, sURL, sFilter, sTitle, sPassword );
 }
 
 //*****************************************************************************************************************
--- sfx2/source/appl/newhelp.cxx	Thu Jan 10 07:56:28 2002
+++ sfx2/source/appl/newhelp.cxx	Mon Apr 14 16:44:12 2003
@@ -1231,7 +1231,7 @@
 	{
 		String aTitle = GetEntry(i);
 		String* pURL = (String*)(ULONG)GetEntryData(i);
-		aHistOpt.AppendItem( eHELPBOOKMARKS, rtl::OUString( *pURL ), sEmpty, rtl::OUString( aTitle ), sEmpty );
+		aHistOpt.AppendItem( eHELPBOOKMARKS, rtl::OUString( *pURL ), sEmpty, sEmpty, rtl::OUString( aTitle ), sEmpty );
 		delete pURL;
 	}
 }
--- sfx2/source/appl/picklist.cxx Nov 28 11:00:48 2001
+++ sfx2/source/appl/picklist.cxx Mon Apr 14 16:47:21 2003
@@ -548,6 +548,7 @@
 				aHistoryCFG.AppendItem( eHISTORY						,
 										aURL.GetURLNoPass()				,
 										pEntry->aFilter					,
+										::rtl::OUString()				,
 										pEntry->aTitle					,
 										SfxStringEncode( aURL.GetPass() ));
 			}
@@ -557,6 +558,7 @@
 										aURL.GetURLNoPass()						,
 										::rtl::OUString()						,
 										::rtl::OUString()						,
+										::rtl::OUString()						,
 										::rtl::OUString()						);
 				bBreak = sal_True;
 			}
--- sfx2/source/appl/sfxpicklist.cxx	Fri May 31 06:08:46 2002
+++ sfx2/source/appl/sfxpicklist.cxx	Mon Apr 14 16:53:00 2003
@@ -455,17 +455,21 @@
 
 					::rtl::OUString		aTitle = pDocSh->GetTitle(SFX_TITLE_PICKLIST);
 					::rtl::OUString		aFilter;
+					::rtl::OUString		aMimeType;
 
 					INetURLObject		aURL( pMed->GetOrigURL() );
 					const SfxFilter*	pFilter = pMed->GetOrigFilter();
 
-					if ( pFilter )
+					if ( pFilter ) {
                         aFilter = pFilter->GetFilterName();
+						aMimeType = pFilter->GetMimeType();
+					}
 
 					// add to svtool history options
 					SvtHistoryOptions().AppendItem( ePICKLIST,
 							aURL.GetURLNoPass(),
 							aFilter,
+							aMimeType,
 							aTitle,
 							SfxStringEncode( aURL.GetPass() ) );
 
--- sd/source/ui/dlg/dlgass.cxx	Tue Jan  8 08:22:24 2002
+++ sd/source/ui/dlg/dlgass.cxx	Tue Apr  1 20:31:43 2003
@@ -174,6 +174,11 @@
 #include <osl/file.hxx>
 #endif
 
+#include <com/sun/star/system/XSystemShellExecute.hpp>
+#include <com/sun/star/document/XTypeDetection.hpp>
+#include <com/sun/star/util/URL.hpp>
+#include <com/sun/star/util/XURLTransformer.hpp>
+#include <sfx2/fcontnr.hxx>
 
 #include "sdpage.hxx"
 #include "helpids.h"
@@ -186,6 +191,8 @@
 #include "TemplateThread.hxx"
 
 using namespace ::com::sun::star;
+using namespace ::com::sun::star::uno;
+using namespace ::com::sun::star::system;
 
 
 void InterpolateFixedBitmap( FixedBitmap * pBitmap )
@@ -758,7 +765,38 @@
 }
 
 
+/* Queries the name of the filter that we can use to open a file */
+static const String &
+get_filter_name_for_file (rtl_uString *uri)
+{
+	Reference< ::com::sun::star::document::XTypeDetection >	type_detection (
+		::comphelper::getProcessServiceFactory ()->createInstance (
+			::rtl::OUString::createFromAscii ("com.sun.star.comp.framework.TypeDetection" )),
+		UNO_QUERY );
+
+	if (!type_detection.is())
+		return;
+
+	::com::sun::star::util::URL url;
+	::rtl::OUString type_name;
+
+	url.Complete = uri;
+
+	Reference < ::com::sun::star::util::XURLTransformer > trans (
+		::comphelper::getProcessServiceFactory ()->createInstance (
+			::rtl::OUString::createFromAscii ("com.sun.star.util.URLTransformer" )),
+		UNO_QUERY);
 
+	trans->parseStrict (url);
+
+	type_name = type_detection->queryTypeByURL (url.Main);
+	SfxFilterMatcher &filter_matcher = SFX_APP ()->GetFilterMatcher ();
+	const SfxFilter *filter = filter_matcher.GetFilter4EA (type_name);
+	if (!filter)
+		return String ();
+
+	return filter->GetFilterName ();
+}
 
 void	AssistentDlgImpl::ScanDocmenu	(void)
 {
@@ -788,6 +826,10 @@
 			else if (aPropertySet[nProperty].Name == HISTORY_PROPERTYNAME_PASSWORD)
 				aPropertySet[nProperty].Value >>= sPassword;
 
+		sFilter = rtl::OUString (get_filter_name_for_file (sURL.pData).GetBuffer ());
+		if (sFilter.getLength () == 0)
+			continue;
+
 		//	If the entry is an impress file then insert it into the
 		//	history list and the list box.
         uno::Any aFilterPropSet = xFilterFactory->getByName( sFilter );


And then the new files:

--- svtools/source/config/recent-files.cxx
+++ svtools/source/config/recent-files.cxx
@@ -0,0 +1,802 @@
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <unistd.h>
+#include <sys/file.h>
+#include <glib.h>
+#include <tools/string.hxx>
+#include "expat/xmlparse.h"
+#include "recent-files.hxx"
+
+namespace svl {
+
+/*
+  example:
+<?xml version="1.0"?>
+<RecentFiles>
+  <RecentItem>
+    <URI>file:///home/federico/gedit.txt</URI>
+    <Mime-Type>text/plain</Mime-Type>
+    <Timestamp>1046485966</Timestamp>
+    <Groups>
+      <Group>gedit</Group>
+    </Groups>
+  </RecentItem>
+  <RecentItem>
+    <URI>file:///home/federico/gedit-2.2.0.tar.bz2</URI>
+    <Mime-Type>application/x-bzip</Mime-Type>
+    <Timestamp>1046209851</Timestamp>
+    <Private/>
+    <Groups>
+    </Groups>
+  </RecentItem>
+</RecentFiles>
+*/
+
+/* Name of the standard ~/.recently-used file */
+#define RECENT_FILE_NAME ".recently-used"
+
+/* Items without a MIME type get assigned this by default */
+#define APPLICATION_OCTET_STREAM "application/octet-stream"
+
+/* Buffer size for reading ~/.recently-used */
+#define BUFFER_SIZE 16384
+
+/* Maximum number of entries to keep before pruning */
+#define MAX_ITEMS 20
+
+/* The group we use for OO.o files */
+#define GROUP_OPENOFFICE_ORG	"OpenOffice.org"
+
+/* Tags we understand in the ~/.recently-used XML */
+#define TAG_RECENT_FILES	"RecentFiles"
+#define TAG_RECENT_ITEM		"RecentItem"
+#define TAG_URI			"URI"
+#define TAG_MIME_TYPE		"Mime-Type"
+#define TAG_TIMESTAMP		"Timestamp"
+#define TAG_PRIVATE		"Private"
+#define TAG_GROUPS		"Groups"
+#define TAG_GROUP		"Group"
+
+/* Recent item as parsed from the file */
+struct Item {
+	char *uri;
+	char *mime_type;
+	time_t timestamp;
+	gboolean is_private;
+	GSList *groups;
+};
+
+/* Parser state */
+enum State {
+	STATE_BEGIN,		/* No elements read yet */
+	STATE_RECENT_FILES,	/* Inside the toplevel RecentFiles element */
+	STATE_RECENT_ITEM,	/* Inside RecentItem */
+	STATE_URI,		/* Inside URI */
+	STATE_MIME_TYPE,	/* Inside Mime-Type */
+	STATE_TIMESTAMP,	/* Inside Timestamp */
+	STATE_PRIVATE,		/* Inside Private */
+	STATE_GROUPS,		/* Inside Groups */
+	STATE_GROUP,		/* Inside Group */
+	STATE_END,		/* Finished parsing the toplevel element */
+	STATE_ERROR		/* Bad XML */
+};
+
+/* XML parsing context */
+struct ParseContext {
+	GSList *items;
+
+	State state;
+};
+
+/* Computes the name of the ~/.recent-files file */
+static char *
+get_recent_filename (void)
+{
+	return g_strdup_printf ("%s/" RECENT_FILE_NAME, g_get_home_dir ());
+}
+
+/* Returns whether a string is null or empty */
+static gboolean
+string_is_empty (const char *s)
+{
+	return (s == NULL || strlen (s) == 0);
+}
+
+/* Frees the contents of str, if any, and g_strdup()s the new_str into it */
+static void
+replace_string (char **str, const char *new_str, int new_str_len)
+{
+	g_free (*str);
+	*str = g_strndup (new_str, new_str_len);
+}
+
+/* Creates a new item in the context as a result of entering a RecentItem element */
+static void
+start_recent_item (ParseContext *context)
+{
+	Item *item;
+
+	item = g_new (Item, 1);
+
+	item->uri = NULL;
+	item->mime_type = NULL;
+	item->timestamp = -1;
+	item->is_private = FALSE;
+	item->groups = NULL;
+
+	context->items = g_slist_prepend (context->items, item);
+}
+
+/* Frees an Item */
+static void
+free_item (Item *item)
+{
+	GSList *l;
+
+	g_free (item->uri);
+	g_free (item->mime_type);
+
+	for (l = item->groups; l; l = l->next) {
+		char *group;
+
+		group = l->data;
+		g_free (group);
+	}
+	g_slist_free (item->groups);
+
+	g_free (item);
+}
+
+/* Terminates a RecentItem element by ensuring that the basic properties of the
+ * current are fulfilled.  If the URI is empty, removes the item from the
+ * context.
+ */
+static void
+end_recent_item (ParseContext *context)
+{
+	Item *item;
+	GSList *list_item;
+
+	g_assert (context->items != NULL);
+	item = context->items->data;
+
+	if (string_is_empty (item->uri)) {
+		free_item (item);
+		context->items = g_slist_delete_link (context->items, context->items);
+		return;
+	}
+
+	if (string_is_empty (item->mime_type))
+		replace_string (&item->mime_type, APPLICATION_OCTET_STREAM, strlen (APPLICATION_OCTET_STREAM));
+
+	if (item->timestamp == -1)
+		item->timestamp = time (NULL);
+}
+
+/* Handles entering a Private element */
+static void
+start_private (ParseContext *context)
+{
+	Item *item;
+
+	g_assert (context->items != NULL);
+	item = context->items->data;
+
+	item->is_private = TRUE;
+}
+
+/* Start element handler for the parser */
+static void
+start_element_cb (void *data, const XML_Char *name, const XML_Char **attributes)
+{
+	ParseContext *context;
+
+	context = data;
+
+	if (context->state == STATE_ERROR || context->state == STATE_END)
+		return;
+
+	switch (context->state) {
+	case STATE_BEGIN:
+		if (strcmp (name, TAG_RECENT_FILES) == 0)
+			context->state = STATE_RECENT_FILES;
+		else
+			context->state = STATE_ERROR;
+		break;
+
+	case STATE_RECENT_FILES:
+		if (strcmp (name, TAG_RECENT_ITEM) == 0) {
+			start_recent_item (context);
+			context->state = STATE_RECENT_ITEM;
+		} else
+			context->state = STATE_ERROR;
+		break;
+
+	case STATE_RECENT_ITEM:
+		if (strcmp (name, TAG_URI) == 0)
+			context->state = STATE_URI;
+		else if (strcmp (name, TAG_MIME_TYPE) == 0)
+			context->state = STATE_MIME_TYPE;
+		else if (strcmp (name, TAG_TIMESTAMP) == 0)
+			context->state = STATE_TIMESTAMP;
+		else if (strcmp (name, TAG_PRIVATE) == 0) {
+			start_private (context);
+			context->state = STATE_PRIVATE;
+		} else if (strcmp (name, TAG_GROUPS) == 0)
+			context->state = STATE_GROUPS;
+		else
+			context->state = STATE_ERROR;
+		break;
+
+	case STATE_URI:
+	case STATE_MIME_TYPE:
+	case STATE_TIMESTAMP:
+	case STATE_PRIVATE:
+	case STATE_GROUP:
+	case STATE_END:
+	case STATE_ERROR:
+		context->state = STATE_ERROR;
+		break;
+
+	case STATE_GROUPS:
+		if (strcmp (name, TAG_GROUP) == 0)
+			context->state = STATE_GROUP;
+		else
+			context->state = STATE_ERROR;
+		break;
+
+	default:
+		g_assert_not_reached ();
+	}
+}
+
+/* End element handler for the parser */
+static void
+end_element_cb (void *data, const XML_Char *name)
+{
+	ParseContext *context;
+
+	context = data;
+
+	switch (context->state) {
+	case STATE_RECENT_FILES:
+		if (strcmp (name, TAG_RECENT_FILES) == 0)
+			context->state = STATE_END;
+		else
+			context->state = STATE_ERROR;
+		break;
+
+	case STATE_RECENT_ITEM:
+		if (strcmp (name, TAG_RECENT_ITEM) == 0) {
+			end_recent_item (context);
+			context->state = STATE_RECENT_FILES;
+		} else
+			context->state = STATE_ERROR;
+		break;
+
+	case STATE_URI:
+		if (strcmp (name, TAG_URI) == 0)
+			context->state = STATE_RECENT_ITEM;
+		else
+			context->state = STATE_ERROR;
+		break;
+
+	case STATE_MIME_TYPE:
+		if (strcmp (name, TAG_MIME_TYPE) == 0)
+			context->state = STATE_RECENT_ITEM;
+		else
+			context->state = STATE_ERROR;
+		break;
+
+	case STATE_TIMESTAMP:
+		if (strcmp (name, TAG_TIMESTAMP) == 0)
+			context->state = STATE_RECENT_ITEM;
+		else
+			context->state = STATE_ERROR;
+		break;
+
+	case STATE_PRIVATE:
+		if (strcmp (name, TAG_PRIVATE) == 0) {
+			start_private (context); /* I don't know if expat calls the start or end element handler for <foo/> */
+			context->state = STATE_RECENT_ITEM;
+		} else
+			context->state = STATE_ERROR;
+		break;
+
+	case STATE_GROUPS:
+		if (strcmp (name, TAG_GROUPS) == 0)
+			context->state = STATE_RECENT_ITEM;
+		else
+			context->state = STATE_ERROR;
+		break;
+
+	case STATE_GROUP:
+		if (strcmp (name, TAG_GROUP) == 0)
+			context->state = STATE_GROUPS;
+		else
+			context->state = STATE_ERROR;
+		break;
+
+	case STATE_BEGIN:
+	case STATE_END:
+	case STATE_ERROR:
+		context->state = STATE_ERROR;
+		break;
+
+	default:
+		g_assert_not_reached ();
+	}
+}
+
+/* Sets the timestamp field of an Item */
+static void
+set_timestamp (Item *item, const char *s, int len)
+{
+	char *dup;
+	long t;
+
+	dup = g_strndup (s, len);
+	if (sscanf (dup, "%ld", &t) != 1)
+		item->timestamp = -1;
+	else
+		item->timestamp = t;
+
+	g_free (dup);
+}
+
+/* Adds a group to an item */
+static void
+add_group (Item *item, const char *s, int len)
+{
+	GSList *l;
+
+	for (l = item->groups; l; l = l->next) {
+		const char *group;
+
+		group = l->data;
+		if (strncmp (group, s, len) == 0)
+			return;
+	}
+
+	item->groups = g_slist_prepend (item->groups, g_strndup (s, len));
+}
+
+/* Handler for character data between tags */
+static void
+character_data_cb (void *data, const XML_Char *s, int len)
+{
+	ParseContext *context;
+	Item *item;
+
+	context = data;
+	item = context->items ? context->items->data : NULL;
+
+	switch (context->state) {
+	case STATE_URI:
+		replace_string (&item->uri, s, len);
+		break;
+
+	case STATE_MIME_TYPE:
+		replace_string (&item->mime_type, s, len);
+		break;
+
+	case STATE_TIMESTAMP:
+		set_timestamp (item, s, len);
+		break;
+
+	case STATE_GROUP:
+		add_group (item, s, len);
+		break;
+
+	case STATE_BEGIN:
+	case STATE_RECENT_FILES:
+	case STATE_RECENT_ITEM:
+	case STATE_PRIVATE:
+	case STATE_GROUPS:
+	case STATE_END:
+	case STATE_ERROR:
+		/* Ignore character data that may appear elsewhere */
+		break;
+
+	default:
+		g_assert_not_reached ();
+	}
+}
+
+/* Creates an XML parser for .recent-files */
+static XML_Parser
+create_parser (ParseContext *context)
+{
+	XML_Parser parser;
+
+	parser = XML_ParserCreate (NULL);
+	if (!parser)
+		return NULL;
+
+	XML_SetUserData (parser, context);
+	XML_SetElementHandler (parser, start_element_cb, end_element_cb);
+	XML_SetCharacterDataHandler (parser, character_data_cb);
+
+	return parser;
+}
+
+/* Compares items by timestamps so as to sort them in DECREASING order */
+static gint
+compare_timestamps_cb (gconstpointer a, gconstpointer b, gpointer data)
+{
+	Item *ia, *ib;
+	time_t ta, tb;
+
+	ia = a;
+	ta = ia->timestamp;
+
+	ib = b;
+	tb = ib->timestamp;
+
+	return (ta < tb) ? 1 : (ta > tb) ? -1 : 0;
+}
+
+/* Returns whether an item has a certain group */
+static gboolean
+has_group (Item *item, const char *group)
+{
+	GSList *l;
+
+	for (l = item->groups; l; l = l->next) {
+		const char *g;
+
+		g = l->data;
+		if (strcmp (g, group) == 0)
+			return TRUE;
+	}
+
+	return FALSE;
+}
+
+/* Removes the oldest items from the context */
+static void
+trim_old_items (ParseContext *context)
+{
+	GSList *l, *next;
+	int i;
+
+	i = 0;
+	l = context->items;
+
+	while (l) {
+		Item *item;
+
+		item = l->data;
+		next = l->next;
+
+		if (has_group (item, GROUP_OPENOFFICE_ORG)) {
+			i++;
+
+			if (i > MAX_ITEMS) {
+				free_item (item);
+				context->items = g_slist_remove_link (context->items, l);
+				g_slist_free_1 (l);
+			}
+		}
+
+		l = next;
+	}
+}
+
+/* Parses the file and fills in the context */
+static void
+parse (FILE *file, ParseContext *context)
+{
+	XML_Parser parser;
+	char buf[BUFFER_SIZE];
+
+	context->items = NULL;
+	context->state = STATE_BEGIN;
+
+	parser = create_parser (context);
+
+	if (!parser)
+		return FALSE;
+
+	while (1) {
+		int len;
+		gboolean eof;
+
+		len = fread (buf, 1, sizeof (buf), file);
+		if (ferror (file))
+			break;
+
+		eof = feof (file);
+
+		if (!XML_Parse (parser, buf, len, eof)) {
+			context->state = STATE_ERROR;
+			break;
+		}
+
+		if (eof)
+			break;
+	}
+
+	if (context->items)
+		end_recent_item (context); /* Finish it off for if we terminated prematurely on error */
+
+	XML_ParserFree (parser);
+
+	context->items = g_slist_sort (context->items, compare_timestamps_cb);
+	trim_old_items (context);
+}
+
+/* Frees the contents of a parse context */
+static void
+free_context(ParseContext *context)
+{
+	GSList *l;
+
+	for (l = context->items; l; l = l->next) {
+		Item *item;
+
+		item = l->data;
+		free_item (item);
+	}
+
+	g_slist_free (context->items);
+}
+
+/* CONVERTS our nice items into ugly OOo structures */
+static void
+convert_items (ParseContext *context, RecentFileItem **items, int *n_items)
+{
+	GSList *l;
+	int i;
+
+	/* Count items with the OpenOffice.org group */
+
+	*n_items = 0;
+	for (l = context->items; l; l = l->next) {
+		Item *item;
+
+		item = l->data;
+		if (has_group (item, GROUP_OPENOFFICE_ORG))
+			(*n_items)++;
+	}
+
+	if (*n_items == 0)
+		return;
+
+	/* Add only the items we want */
+
+	*items = g_new (RecentFileItem, *n_items);
+
+	i = 0;
+
+	for (l = context->items; l; l = l->next) {
+		Item *item;
+
+		item = l->data;
+
+		if (has_group (item, GROUP_OPENOFFICE_ORG)) {
+			RecentFileItem *rfi;
+
+			rfi = (*items) + i;
+
+			rfi->uri = NULL;
+			rtl_string2UString (&rfi->uri, item->uri, strlen (item->uri), RTL_TEXTENCODING_UTF8, 0);
+			rfi->mime_type = NULL;
+			rtl_string2UString (&rfi->mime_type, item->mime_type, strlen (item->mime_type), RTL_TEXTENCODING_UTF8, 0);
+
+			rfi->timestamp = item->timestamp;
+
+			i++;
+		}
+	}
+}
+
+/* Opens ~/.recent-files and locks it.  If something fails, returns NULL. */
+static FILE *
+open_and_lock (void)
+{
+	char *filename;
+	FILE *file;
+	int fd;
+	ParseContext context;
+
+	filename = get_recent_filename ();
+
+	file = fopen (filename, "r+");
+	g_free (filename);
+
+	if (!file)
+		return NULL;
+
+	fd = fileno (file);
+	if (lockf (fd, F_LOCK, 0) != 0) {
+		fclose (file);
+		return NULL;
+	}
+
+	return file;
+}
+
+/* Unlocks ~/.recent-files and closes it. */
+static void
+unlock_and_close (FILE *file)
+{
+	int fd;
+
+	fd = fileno (file);
+	lockf (fd, F_ULOCK, 0);
+	fclose (file);
+}
+
+
+/**
+ * recent_files_get_list:
+ * @items: Return value; pointer to an array of items.  Should be freed with recent_files_free().
+ * @n_items: Return value; number of items returned.
+ * 
+ * Queries the list of GNOME recent file items.
+ **/
+void
+recent_files_get_list (RecentFileItem **items, int *n_items)
+{
+	FILE *file;
+	ParseContext context;
+
+	*items = NULL;
+	*n_items = 0;
+
+	file = open_and_lock ();
+	if (!file)
+		return;
+
+	parse (file, &context);
+
+	unlock_and_close (file);
+
+	convert_items (&context, items, n_items);
+	free_context (&context);
+}
+
+/* Writes the ~/.recent-files file */
+static void
+write_xml (FILE *file, ParseContext *context)
+{
+	GSList *l;
+
+	fputs ("<?xml version=\"1.0\"?>\n"
+	       "<" TAG_RECENT_FILES ">\n",
+	       file);
+
+	for (l = context->items; l; l = l->next) {
+		Item *item;
+		GSList *gl;
+
+		item = l->data;
+
+		fputs ("  <" TAG_RECENT_ITEM ">\n", file);
+		fprintf (file,
+			 "    <" TAG_URI ">%s</" TAG_URI ">\n"
+			 "    <" TAG_MIME_TYPE ">%s</" TAG_MIME_TYPE ">\n"
+			 "    <" TAG_TIMESTAMP ">%ld</" TAG_TIMESTAMP ">\n"
+			 "%s"
+			 "    <" TAG_GROUPS ">\n",
+			 item->uri,
+			 item->mime_type,
+			 (long) item->timestamp,
+			 item->is_private ? "    <" TAG_PRIVATE "/>\n" : "");
+
+		for (gl = item->groups; gl; gl = gl->next) {
+			const char *group;
+
+			group = gl->data;
+			fprintf (file,
+				 "      <" TAG_GROUP ">%s</" TAG_GROUP ">\n",
+				 group);
+		}
+
+		fputs ("    </" TAG_GROUPS ">\n"
+		       "  </" TAG_RECENT_ITEM ">\n",
+		       file);
+	}
+
+	fputs ("</" TAG_RECENT_FILES ">\n", file);
+}
+
+/**
+ * recent_files_free:
+ * @items: Array of items.
+ * @n_items: Number of items in the array.
+ * 
+ * Frees an array of #RecentFileItem structures as returned by recent_files_get_list().
+ **/
+void
+recent_files_free (RecentFileItem *items, int n_items)
+{
+	int i;
+
+	for (i = 0; i < n_items; i++) {
+		rtl_uString_release (items[i].uri);
+		rtl_uString_release (items[i].mime_type);
+	}
+
+	g_free (items);
+}
+
+/**
+ * recent_files_add_item:
+ * @uri: URI to add.
+ * @mime_type: MIME type of the item.
+ * 
+ * Adds an item to GNOME's recent files list.  Automatically adds the "OpenOffice.org" group.
+ **/
+void
+recent_files_add_item (rtl_uString *uri, const rtl_uString *mime_type)
+{
+	FILE *file;
+	ParseContext context;
+	GSList *l;
+	gboolean already_exists;
+	int fd;
+	rtl_String *uri_string;
+	rtl_String *mime_type_string;
+
+	file = open_and_lock ();
+	if (!file)
+		return;
+
+	parse (file, &context);
+
+	already_exists = FALSE;
+
+	uri_string = NULL;
+	mime_type_string = NULL;
+	rtl_uString2String (&uri_string, uri->buffer, uri->length, RTL_TEXTENCODING_UTF8, 0);
+	rtl_uString2String (&mime_type_string, mime_type->buffer, mime_type->length, RTL_TEXTENCODING_UTF8, 0);
+
+	for (l = context.items; l; l = l->next) {
+		Item *item;
+
+		item = l->data;
+		if (strcmp (item->uri, uri_string->buffer) == 0) {
+			g_free (item->mime_type);
+			item->mime_type = g_strdup (mime_type_string->buffer);
+			item->timestamp = time (NULL);
+			already_exists = TRUE;
+			break;
+		}
+	}
+
+	if (!already_exists) {
+		Item *item;
+
+		item = g_new (Item, 1);
+		item->uri = g_strdup (uri_string->buffer);
+		item->mime_type = g_strdup (mime_type_string->buffer);
+		item->timestamp = time (NULL);
+		item->is_private = FALSE;
+		item->groups = g_slist_prepend (NULL, g_strdup (GROUP_OPENOFFICE_ORG));
+
+		context.items = g_slist_prepend (context.items, item);
+	}
+
+	rtl_string_release (uri_string);
+	rtl_string_release (mime_type_string);
+
+	fd = fileno (file);
+
+	/* FIXME: we should do a write to a temporary file, then do an atomic rename() */
+
+	rewind (file);
+	if (ftruncate (fd, 0) != 0)
+		goto out;
+
+	write_xml (file, &context);
+
+out:
+
+	unlock_and_close (file);
+	free_context (&context);
+}
+
+};
--- svtools/source/config/recent-files.hxx
+++ svtools/source/config/recent-files.hxx
@@ -0,0 +1,30 @@
+#ifndef RECENT_FILES_HXX
+#define RECENT_FILES_HXX
+
+#ifndef _RTL_USTRING_
+#include <rtl/ustring.h>
+#endif
+
+#include <time.h>
+
+namespace svl {
+
+/* A recent file item */
+struct RecentFileItem {
+	rtl_uString *uri;	/* URI of the file */
+	rtl_uString *mime_type;	/* MIME type */
+	time_t timestamp;	/* Timestamp for when the item was added */
+};
+
+/* Queries the list of recent file items for OpenOffice.org */
+void recent_files_get_list (RecentFileItem **items, int *n_items);
+
+/* Frees an array of RecentFileItem structures */
+void recent_files_free (RecentFileItem *items, int n_items);
+
+/* Adds an item to the list of recent file items */
+void recent_files_add_item (rtl_uString *uri, const rtl_uString *mime_type);
+
+};
+
+#endif
