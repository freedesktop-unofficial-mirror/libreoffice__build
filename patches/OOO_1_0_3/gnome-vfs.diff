--- sal/util/makefile.mk
+++ sal/util/makefile.mk
@@ -188,6 +188,11 @@
 .ENDIF
 .ENDIF
 
+.IF "$(GUI)"=="UNX"
+SHL1OBJS=
+SHL1STDLIBS+=`pkg-config --libs gnome-vfs-2.0`
+.ENDIF
+
 SHL1DEPN=
 SHL1DEF=    $(MISC)$/$(SHL1TARGET).def
 
--- sal/osl/unx/makefile.mk
+++ sal/osl/unx/makefile.mk
@@ -96,6 +98,7 @@
 			$(SLO)$/profile.obj  \
 			$(SLO)$/time.obj     \
 			$(SLO)$/file.obj     \
+			$(SLO)$/file-gvfs.obj     \
 			$(SLO)$/signal.obj   \
 			$(SLO)$/pipe.obj   	 \
 			$(SLO)$/system.obj	 \
@@ -116,11 +119,14 @@
 			$(OBJ)$/profile.obj  \
 			$(OBJ)$/time.obj     \
 			$(OBJ)$/file.obj     \
+			$(OBJ)$/file-gvfs.obj     \
 			$(OBJ)$/signal.obj   \
 			$(OBJ)$/pipe.obj   	 \
 			$(OBJ)$/system.obj	 \
 			$(OBJ)$/util.obj
 #.ENDIF
+
+CFLAGS+=`pkg-config --cflags gnome-vfs-2.0`
 
 # --- Targets ------------------------------------------------------

--- tools/bootstrp/static.mk  2001/10/16 14:21:13     1.14
+++ tools/bootstrp/static.mk  2002/10/28 14:54:45
@@ -155,7 +155,7 @@
 STATIC_LIBS		+= -lnsl -lsocket -lposix4 -lc
 .ENDIF
 .IF "$(OS)"=="LINUX"
-STATIC_LIBS		+= -lsupc++	-lX11 -lXext 
+STATIC_LIBS		+= -lsupc++	-lX11 -lXext `pkg-config --libs gnome-vfs-2.0`
 .ENDIF
 
 # -----------------------------------------------------------
--- sal/osl/unx/file.c
+++ sal/osl/unx/file.c
@@ -70,6 +70,8 @@
  *   - check size/use of oslFileHandle
  */
 
+#define USE_GNOME_VFS
+
 #include "system.h"
 #include <rtl/alloc.h>
 #include <rtl/memory.h>
@@ -184,19 +186,19 @@
 } oslDirectoryItemImpl;
 #endif
 
+#ifndef USE_GNOME_VFS
 typedef struct
 {
     rtl_uString* ustrPath;           /* holds native directory path */
     DIR*         pDirStruct;  
 } oslDirectoryImpl;
 
-
 typedef struct
 {
     rtl_uString* ustrFilePath;      /* holds native file path */
     int fd;
 } oslFileHandleImpl;
-
+#endif
 
 typedef struct _oslVolumeDeviceHandleImpl
 {
@@ -240,7 +242,7 @@
  *
  *****************************************************************************/
 
-static oslFileError  oslIsMountPoint( sal_Char* pszFileName, sal_Bool* bMountPoint );
+oslFileError  oslIsMountPoint( sal_Char* pszFileName, sal_Bool* bMountPoint );
 static sal_Char*     oslSeparatePathEntry( sal_Char* pszUNCPath, sal_Char cSeparator );
 
 static void          oslMakeUniqueName( sal_Char* pszRequested, sal_Char* pszUnique, sal_uInt32 nIndex );
@@ -321,6 +323,7 @@
 static void           osl_printFloppyHandle(oslVolumeDeviceHandleImpl* hFloppy);
 #endif
 
+#ifndef USE_GNOME_VFS
 
 /******************************************************************************
  *
@@ -427,6 +430,7 @@
     }
  
     /* protocol and server should not be encoded, so decode the whole string */
+    rtl_uString_acquire( ustrFileURL );
     rtl_uriDecode( ustrFileURL, rtl_UriDecodeWithCharset, RTL_TEXTENCODING_UTF8, &pTmp );
     
     /* check if file protocol specified */    
@@ -500,6 +504,11 @@
 	*/
         
     *pustrSystemPath = pTmp;
+
+//    fprintf (stderr, "+CSU: '%s' '%s'\n",
+//	     osl_debugUString (ustrFileURL),
+//	     osl_debugUString (*pustrSystemPath));
+
     return osl_File_E_None;
 }
 
@@ -602,6 +611,7 @@
 	*/
         
     /* file URLs must be URI encoded */
+    rtl_uString_acquire( pTmp );
     rtl_uriEncode( pTmp, uriCharClass, rtl_UriEncodeIgnoreEscapes, RTL_TEXTENCODING_UTF8, pustrFileURL );
     
     rtl_uString_release( pTmp );    
@@ -616,10 +626,13 @@
         rtl_uString_release( pProtocol );
     }
 
+//    fprintf (stderr, "+CUS: '%s' '%s'\n",
+//	     osl_debugUString (ustrSystemPath),
+//	     osl_debugUString (*pustrFileURL));
+
     return osl_File_E_None;
 }
 
-
 /****************************************************************************/
 /*	osl_openDirectory */
 /****************************************************************************/
@@ -1411,6 +1424,7 @@
 
     return osl_File_E_INVAL;
 }
+#endif
 
 /****************************************************************************/
 /*	osl_moveFile */
@@ -1880,6 +1894,7 @@
  *****************************************************************************/
 
 
+#ifndef USE_GNOME_VFS
 /*******************************************
     osl_writeFile
 ********************************************/
@@ -2098,7 +2113,6 @@
     return osl_File_E_None;
 }
 
-
 oslFileError osl_setFileSize( oslFileHandle Handle, sal_uInt64 uSize )
 {
     oslFileHandleImpl* pHandleImpl=0;
@@ -2198,6 +2212,7 @@
 #endif /* TRACE_OSL_FILE */
 	return (osl_File_E_None);
 }
+#endif
 
 /******************************************************************************
  *
@@ -4168,7 +4183,7 @@
 
 #include<fstab.h>
 
-static oslFileError oslIsMountPoint(sal_Char* pszFileName, sal_Bool* bMountPoint )
+oslFileError oslIsMountPoint(sal_Char* pszFileName, sal_Bool* bMountPoint )
 {
  struct fstab *fs;
 		 
@@ -4192,7 +4207,7 @@
 #include <sys/mount.h>
 #endif
 
-static oslFileError oslIsMountPoint(sal_Char* pszFileName, sal_Bool* bMountPoint )
+oslFileError oslIsMountPoint(sal_Char* pszFileName, sal_Bool* bMountPoint )
 {
     int nRet=0;
     FILE* mntfile=0;
--- sal/osl/unx/file-gvfs.c	Thu Jan  1 01:00:00 1970
+++ sal/osl/unx/file-gvfs.c	Wed Dec 18 09:57:42 2002
@@ -0,0 +1,867 @@
+/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 8; tab-width: 8 -*- */
+#define USE_GNOME_VFS
+
+#ifdef USE_GNOME_VFS
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <libgnomevfs/gnome-vfs.h>
+
+#include <pthread.h>
+#include <rtl/uri.h>
+#include <osl/file.h>
+
+/* FIXME: this method needs serious work [!] */
+extern oslFileError oslIsMountPoint (sal_Char *pszFileName,
+				     sal_Bool *bMountPoint);
+
+#ifndef DEBUG
+static inline void dprintf (const char *format, ...) {} ;
+#else
+#define dprintf g_warning
+#endif
+
+typedef struct {
+	rtl_String     *uri;
+	GnomeVFSHandle *handle;
+	gboolean        hit_eof;
+} oslFileHandleImpl;
+
+#define v_return_if_fail(v) \
+	G_STMT_START { \
+		if (!(v)) \
+			return osl_File_E_INVAL; \
+	} G_STMT_END
+
+#define MAP_ERR(result) oslMapErr ((result), G_STRLOC)
+
+static oslFileError
+oslMapErr (GnomeVFSResult result, const char *where)
+{
+	oslFileError res;
+
+	if (result)
+		dprintf ("%s returns %s\n", where,
+			 gnome_vfs_result_to_string (result));
+
+#define MAP_ERR_CASE(gname,oname) \
+	case GNOME_VFS_##gname: \
+		res = osl_File_E_##oname; \
+		break
+
+	switch (result) {
+		MAP_ERR_CASE (OK, None);
+		MAP_ERR_CASE (ERROR_NOT_FOUND, NOENT);
+		MAP_ERR_CASE (ERROR_INTERNAL, FAULT);
+		MAP_ERR_CASE (ERROR_BAD_PARAMETERS, INVAL);
+		MAP_ERR_CASE (ERROR_IO, IO);
+		MAP_ERR_CASE (ERROR_BAD_FILE, BADF);
+		MAP_ERR_CASE (ERROR_TOO_BIG, 2BIG);
+		MAP_ERR_CASE (ERROR_NO_SPACE, NOSPC);
+		MAP_ERR_CASE (ERROR_READ_ONLY, ROFS);
+		MAP_ERR_CASE (ERROR_INVALID_URI, NOENT); /* guess */
+		MAP_ERR_CASE (ERROR_ACCESS_DENIED, ACCES);
+		MAP_ERR_CASE (ERROR_TOO_MANY_OPEN_FILES, MFILE);
+		MAP_ERR_CASE (ERROR_NOT_A_DIRECTORY, NOTDIR);
+		MAP_ERR_CASE (ERROR_INTERRUPTED, INTR);
+		MAP_ERR_CASE (ERROR_FILE_EXISTS, EXIST);
+		MAP_ERR_CASE (ERROR_LOOP, LOOP);
+		MAP_ERR_CASE (ERROR_NOT_PERMITTED, PERM);
+		MAP_ERR_CASE (ERROR_IS_DIRECTORY, ISDIR);
+		MAP_ERR_CASE (ERROR_NO_MEMORY, NOMEM);
+		MAP_ERR_CASE (ERROR_DIRECTORY_BUSY, BUSY);
+		MAP_ERR_CASE (ERROR_DIRECTORY_NOT_EMPTY, NOTEMPTY);
+		MAP_ERR_CASE (ERROR_TOO_MANY_LINKS, MLINK);
+		MAP_ERR_CASE (ERROR_READ_ONLY_FILE_SYSTEM, ROFS);
+		MAP_ERR_CASE (ERROR_NOT_SAME_FILE_SYSTEM, XDEV);
+		/*
+		 * Stuff without entries ...
+		 * 
+		MAP_ERR_CASE (ERROR_HOST_NOT_FOUND,
+		MAP_ERR_CASE (ERROR_GENERIC, 
+		MAP_ERR_CASE (ERROR_NOT_SUPPORTED, NOSYS);
+		MAP_ERR_CASE (ERROR_CORRUPTED_DATA,
+		MAP_ERR_CASE (ERROR_WRONG_FORMAT, );
+		MAP_ERR_CASE (ERROR_NOT_OPEN, - wierd !
+		MAP_ERR_CASE (ERROR_INVALID_OPEN_MODE, 
+		MAP_ERR_CASE (ERROR_EOF, -- very odd !
+		MAP_ERR_CASE (ERROR_IN_PROGRESS,
+		MAP_ERR_CASE (ERROR_INVALID_HOST_NAME, 
+		MAP_ERR_CASE (ERROR_HOST_HAS_NO_ADDRESS,
+		MAP_ERR_CASE (ERROR_LOGIN_FAILED,
+		MAP_ERR_CASE (ERROR_CANCELLED,
+		MAP_ERR_CASE (ERROR_NAME_TOO_LONG, 
+		MAP_ERR_CASE (ERROR_SERVICE_NOT_AVAILABLE,
+		MAP_ERR_CASE (ERROR_SERVICE_OBSOLETE,
+		MAP_ERR_CASE (ERROR_PROTOCOL_ERROR, */
+	default:
+		fprintf (stderr, "Can't map VFS err '%s' (%d): "
+			 "return generic error\n",
+			 gnome_vfs_result_to_string (result),
+			 result);
+		res = osl_File_E_invalidError;
+		break;
+	};
+#undef MAP_ERR_CASE
+
+	return res;
+}
+/*
+ * Gnome VFS file abstraction
+ */
+oslFileHandle
+osl_createFileHandleFromFD( int fd )
+{
+	fprintf (stderr, "lxr says this never happens (%d) ...\n", fd);
+	*((char *)0) = '\0'; /* segv ? */
+	_exit (179);
+}
+
+static GnomeVFSResult
+convertToURI( rtl_String **uri, rtl_uString *fileURL )
+{
+	*uri = NULL;
+	rtl_uString2String (uri, fileURL->buffer,
+			    fileURL->length,
+			    RTL_TEXTENCODING_UTF8, 0);
+
+	if (!fileURL || fileURL->buffer [0] == '/') {
+		dprintf ("Invalid URI '%s'\n", (*uri)->buffer);
+		rtl_string_release (*uri);
+		return GNOME_VFS_ERROR_BAD_PARAMETERS;
+	}
+
+	return GNOME_VFS_OK;
+}
+
+static void
+osl_vfs_do_init (void)
+{
+	/*
+	 * FIXME: this is badly performing, we need to be able
+	 * to initialize once when we start OO.o before cloning
+	 * the first thread instead of constantly taking this lock.
+	 */
+	static pthread_mutex_t aLocalMutex = PTHREAD_MUTEX_INITIALIZER;
+	static gboolean initialized = FALSE;
+
+	pthread_mutex_lock( &aLocalMutex );
+	if (!initialized) {
+		initialized = TRUE;
+		if (!gnome_vfs_initialized ()) {
+			dprintf ("\n\n\n ---- Doing init ! ---- \n\n\n\n");
+			gnome_vfs_init ();
+		}
+	}
+        pthread_mutex_unlock(&aLocalMutex);
+}
+
+oslFileError
+osl_openFile( rtl_uString* ustrFileURL, oslFileHandle* pHandle, sal_uInt32 uFlags )
+{
+	rtl_String      *uri;
+	GnomeVFSResult   result;
+	GnomeVFSHandle  *handle;
+	GnomeVFSOpenMode mode;
+	GnomeVFSFilePermissions perm;
+	oslFileHandleImpl **fh = (oslFileHandleImpl **) pHandle;
+
+	v_return_if_fail (fh != NULL);
+	*fh = NULL;
+
+	osl_vfs_do_init ();
+
+	if ((result = convertToURI (&uri, ustrFileURL)))
+		return MAP_ERR (result);
+
+	dprintf ("Opening '%s'\n", uri->buffer);
+
+        mode = GNOME_VFS_OPEN_READ | GNOME_VFS_OPEN_RANDOM;
+	perm = (GNOME_VFS_PERM_USER_READ |
+		GNOME_VFS_PERM_GROUP_READ |
+		GNOME_VFS_PERM_OTHER_READ);
+	if (uFlags & osl_File_OpenFlag_Write ||
+	    uFlags & osl_File_OpenFlag_Create) {
+		mode |= GNOME_VFS_OPEN_WRITE;
+		perm |= (GNOME_VFS_PERM_USER_WRITE |
+			 GNOME_VFS_PERM_GROUP_WRITE);
+	}
+
+	result = gnome_vfs_open (&handle, uri->buffer, mode);
+
+	if (result == GNOME_VFS_ERROR_NOT_FOUND &&
+	    uFlags & osl_File_OpenFlag_Create) {
+		dprintf ("Not found '%s', creating ...", uri->buffer);
+		result = gnome_vfs_create (&handle, uri->buffer,
+					   mode, TRUE, perm);
+		/* Sometimes we get INVALID_URI - but the URI is
+		 * valid for open, but not create eg. applications:
+		 * must end in .desktop etc. */
+		if (result == GNOME_VFS_ERROR_INVALID_URI)
+			result = GNOME_VFS_ERROR_ACCESS_DENIED;
+	}
+
+	/*
+	 * FIXME: it seems the W32 backend doesn't bother with
+	 * locking so neither will we for now, also there's 0 point
+	 * continually doing flock locking on system files
+	 */
+
+	if (result) {
+		*fh = NULL;
+		return MAP_ERR (result);
+	}
+
+	*fh = g_new0 (oslFileHandleImpl, 1);
+	(*fh)->uri = uri;
+	(*fh)->handle = handle;
+
+	return osl_File_E_None;
+}
+
+oslFileError
+osl_closeFile( oslFileHandle Handle )
+{
+	GnomeVFSResult result;
+	oslFileHandleImpl *fh = Handle;
+
+	v_return_if_fail (fh != NULL);
+
+	dprintf ("Closed '%s'\n", fh->uri->buffer);
+
+	result = gnome_vfs_close (fh->handle);
+	rtl_string_release (fh->uri);
+	g_free (fh);
+
+	return MAP_ERR (result);
+}
+
+oslFileError
+osl_isEndOfFile( oslFileHandle Handle, sal_Bool *pIsEOF )
+{
+	oslFileHandleImpl *fh = Handle;
+
+	v_return_if_fail (fh != NULL);
+
+	dprintf ("Is EOF on '%s' : %d\n", fh->uri->buffer, fh->hit_eof);
+
+	return fh->hit_eof;
+}
+
+oslFileError
+osl_readFile( oslFileHandle Handle, void* pBuffer,
+	      sal_uInt64 uBytesRequested, sal_uInt64* pBytesRead )
+{
+	GnomeVFSResult result;
+	GnomeVFSFileSize len;
+	oslFileHandleImpl *fh = Handle;
+
+	v_return_if_fail (fh != NULL);
+	v_return_if_fail (pBuffer != NULL);
+	v_return_if_fail (pBytesRead != NULL);
+	
+	result = gnome_vfs_read (fh->handle, pBuffer, uBytesRequested, &len);
+
+	if (result == GNOME_VFS_ERROR_EOF) {
+		len = 0;
+		fh->hit_eof = TRUE;
+		result = GNOME_VFS_OK; /* Most odd handling here */
+	}
+	*pBytesRead = len;
+
+	dprintf ("Read %ld bytes from '%s'\n",
+		 (long) len, fh->uri->buffer);
+
+	return MAP_ERR (result);
+}
+
+oslFileError
+osl_writeFile( oslFileHandle Handle, const void* pBuffer,
+	       sal_uInt64 uBytesToWrite, sal_uInt64* pBytesWritten )
+{
+	GnomeVFSResult result;
+	GnomeVFSFileSize len;
+	oslFileHandleImpl *fh = Handle;
+
+	v_return_if_fail (fh != NULL);
+	v_return_if_fail (pBuffer != NULL);
+	v_return_if_fail (pBytesWritten != NULL);
+
+	result = gnome_vfs_write (fh->handle, pBuffer, uBytesToWrite, &len);
+
+	*pBytesWritten = len;
+
+	dprintf ("Wrote %ld bytes to '%s'\n",
+		 (long) len, fh->uri->buffer);
+
+	return MAP_ERR (result);
+}
+
+oslFileError
+osl_setFilePos( oslFileHandle Handle, sal_uInt32 uHow, sal_Int64 uPos )
+{
+	GnomeVFSResult result;
+	oslFileHandleImpl *fh = Handle;
+	GnomeVFSSeekPosition whence;
+
+	v_return_if_fail (fh != NULL);
+
+	switch (uHow) {
+        case osl_Pos_Absolut:
+		whence = GNOME_VFS_SEEK_START;
+		break;
+        case osl_Pos_Current:
+		whence = GNOME_VFS_SEEK_CURRENT;
+		break;
+        case osl_Pos_End:
+		whence = GNOME_VFS_SEEK_END;
+		break;
+	default:
+		return osl_File_E_INVAL;
+	}
+
+	result = gnome_vfs_seek (fh->handle, whence, uPos);
+
+	dprintf ("Seek inside '%s' to %ld (%d)\n",
+		 fh->uri->buffer, (long) uPos, (int) whence);
+
+	return MAP_ERR (result);
+}
+
+oslFileError
+osl_getFilePos( oslFileHandle Handle, sal_uInt64* pPos )
+{
+	GnomeVFSResult result;
+	GnomeVFSFileSize pos;
+	oslFileHandleImpl *fh = Handle;
+
+	v_return_if_fail (fh != NULL);
+
+	result = gnome_vfs_tell (fh->handle, &pos);
+	*pPos = pos;
+
+	dprintf ("Get filepos inside '%s' == %ld\n",
+		 fh->uri->buffer, (long) pos);
+
+	return MAP_ERR (result);
+}
+
+oslFileError
+osl_setFileSize( oslFileHandle Handle, sal_uInt64 uSize )
+{
+	GnomeVFSResult result;
+	oslFileHandleImpl *fh = Handle;
+
+	v_return_if_fail (fh != NULL);
+
+	result = gnome_vfs_truncate_handle (fh->handle, uSize);
+
+	return MAP_ERR (result);
+}
+
+/*
+ * Gnome VFS directory abstraction
+ */
+
+oslFileError
+osl_createDirectoryItemFromHandle( oslFileHandle Handle,
+				   oslDirectoryItem* pItem )
+{
+	GnomeVFSURI **uri = (GnomeVFSURI **) pItem;
+	oslFileHandleImpl *fh = (oslFileHandleImpl *) Handle;
+    
+	v_return_if_fail (fh != NULL);
+	v_return_if_fail (pItem != NULL);
+
+	*uri = gnome_vfs_uri_new (fh->uri->buffer);
+	v_return_if_fail (*uri != NULL);
+    
+        return osl_File_E_None;
+}
+
+typedef struct {
+	GnomeVFSURI             *uri; /* Of base directory */
+	GnomeVFSDirectoryHandle *handle;
+} oslDirectoryImpl;
+
+oslFileError
+osl_openDirectory( rtl_uString* ustrDirectoryURL, oslDirectory* pDirectory )
+{
+	rtl_String *uri_str = NULL;
+	GnomeVFSURI *uri;
+	GnomeVFSResult result;
+	oslDirectoryImpl **dh = (oslDirectoryImpl **) pDirectory;
+	GnomeVFSDirectoryHandle *handle;
+
+	v_return_if_fail (pDirectory != NULL);
+	*pDirectory = NULL;
+
+	v_return_if_fail (ustrDirectoryURL != NULL);
+	
+	if ((result = convertToURI (&uri_str, ustrDirectoryURL)))
+		return MAP_ERR (result);
+	uri = gnome_vfs_uri_new (uri_str->buffer);
+	rtl_string_release (uri_str);
+	v_return_if_fail (uri != NULL);
+
+	result = gnome_vfs_directory_open_from_uri
+		(&handle, uri, GNOME_VFS_FILE_INFO_DEFAULT);
+
+	dprintf ("Open directory '%s'\n",
+		 gnome_vfs_uri_to_string (uri, 0));
+
+	if (result)
+		return MAP_ERR (result);
+
+	*dh = g_new0 (oslDirectoryImpl, 1);
+	(*dh)->uri = uri;
+	(*dh)->handle = handle;
+
+	return osl_File_E_None;
+}
+
+oslFileError
+osl_closeDirectory( oslDirectory Directory )
+{
+	GnomeVFSResult result;
+	oslDirectoryImpl *dh = Directory;
+
+	v_return_if_fail (dh != NULL);
+
+	dprintf ("Close directory '%s'\n",
+		 gnome_vfs_uri_to_string (dh->uri, 0));
+
+	result = gnome_vfs_directory_close (dh->handle);
+	
+	gnome_vfs_uri_unref (dh->uri);
+	g_free (dh);
+
+	return MAP_ERR (result);
+}
+
+oslFileError
+osl_getNextDirectoryItem( oslDirectory      Directory,
+			  oslDirectoryItem* pItem,
+			  sal_uInt32        uHint )
+{
+	GnomeVFSResult result;
+	GnomeVFSURI     **di = (GnomeVFSURI **) pItem;
+	oslDirectoryImpl *dh = Directory;
+	GnomeVFSFileInfo  file_info = { 0 };
+
+	v_return_if_fail (dh != NULL);
+	v_return_if_fail (di != NULL);
+
+	/* FIXME: I believe this leaks, like the original did
+	 * cf. getNextItem (file.hxx). */
+	*di = NULL;
+
+	result = gnome_vfs_directory_read_next
+		(dh->handle, &file_info);
+
+	/* The expected error at EOF - it seems */
+	if (result == GNOME_VFS_ERROR_EOF)
+		result = GNOME_VFS_ERROR_NOT_FOUND;
+
+	if (result)
+		return MAP_ERR (result);
+
+	dprintf ("Get Next directory item in '%s' is '%s'\n",
+		 gnome_vfs_uri_to_string (dh->uri, 0), file_info.name);
+
+	if (file_info.name &&
+	    !strcmp (file_info.name, ".") ||
+	    !strcmp (file_info.name, ".."))
+		return osl_getNextDirectoryItem
+			(Directory, pItem, uHint);
+
+	*di = gnome_vfs_uri_append_file_name (dh->uri, file_info.name);
+
+	gnome_vfs_file_info_clear (&file_info);
+
+	return osl_File_E_None;
+}
+
+oslFileError
+osl_getDirectoryItem( rtl_uString* ustrFileURL,
+		      oslDirectoryItem* pItem )
+{
+	rtl_String *uri = NULL;
+	GnomeVFSURI **di = (GnomeVFSURI **) pItem;
+	GnomeVFSResult result;
+	GnomeVFSFileInfo file_info = { 0 };
+
+	v_return_if_fail (pItem != NULL);
+	v_return_if_fail (ustrFileURL != NULL);
+
+	if ((result = convertToURI (&uri, ustrFileURL)))
+		return MAP_ERR (result);
+
+	dprintf ("Get directory item for '%s'\n", uri->buffer);
+
+	*di = gnome_vfs_uri_new (uri->buffer);
+	v_return_if_fail (*di != NULL);
+	rtl_string_release (uri);
+
+	/* FIXME: could be more efficient by a long way */
+	result = gnome_vfs_get_file_info_uri
+		(*di, &file_info, GNOME_VFS_FILE_INFO_DEFAULT);
+
+	if (result == GNOME_VFS_OK)
+		gnome_vfs_file_info_clear (&file_info);
+	else {
+		gnome_vfs_uri_unref (*di);
+		*di = NULL;
+	}
+
+	return MAP_ERR (result);
+}
+
+oslFileError
+osl_acquireDirectoryItem( oslDirectoryItem Item )
+{
+	GnomeVFSURI *di = Item;
+
+	if (di)
+		gnome_vfs_uri_ref (di);
+
+	return osl_File_E_None;
+}
+
+oslFileError
+osl_releaseDirectoryItem( oslDirectoryItem Item )
+{
+	GnomeVFSURI *di = Item;
+
+	if (di)
+		gnome_vfs_uri_unref (di);
+
+	return osl_File_E_None;
+}
+
+oslFileError
+osl_getFileStatus( oslDirectoryItem Item, 
+		   oslFileStatus*   pStat,
+		   sal_uInt32       uFieldMask )
+{
+	GnomeVFSURI *di = Item;
+	GnomeVFSResult result;
+	GnomeVFSFileInfo file_info = { 0 };
+
+	v_return_if_fail (Item != NULL);
+	v_return_if_fail (pStat != NULL);
+
+	if (!uFieldMask)
+		return osl_File_E_None;
+
+	result = gnome_vfs_get_file_info_uri
+		(di, &file_info,
+		 GNOME_VFS_FILE_INFO_FOLLOW_LINKS);
+
+	if (result)
+		return MAP_ERR (result);
+
+	pStat->uValidFields = osl_FileStatus_Mask_Type;
+	pStat->uAttributes = 0;
+
+	if (file_info.valid_fields &
+	    GNOME_VFS_FILE_INFO_FIELDS_TYPE) {
+		switch (file_info.type) {
+		case GNOME_VFS_FILE_TYPE_DIRECTORY: {
+			const gchar *dir_path;
+
+			pStat->eType = osl_File_Type_Directory;
+
+			if (GNOME_VFS_FILE_INFO_LOCAL (&file_info) &&
+			    (dir_path = gnome_vfs_uri_get_path (di))) {
+				sal_Bool bMountPoint;
+
+				/* FIXME - should care more about an error ? */
+				if (oslIsMountPoint (dir_path, &bMountPoint)
+				    == osl_File_E_None &&
+				    bMountPoint)
+				    pStat->eType = osl_File_Type_Volume;
+				dprintf ("is %s a mount point %d", dir_path, bMountPoint);
+			}
+			pStat->eType = osl_File_Type_Directory;
+			break;
+		}
+
+#define MAP_TYPE(a,b) \
+		case GNOME_VFS_FILE_TYPE_##a: \
+			pStat->eType = osl_File_Type_##b; \
+			break
+
+		MAP_TYPE(REGULAR, Regular);
+		MAP_TYPE(SOCKET, Socket);
+		MAP_TYPE(FIFO, Fifo);
+		MAP_TYPE(CHARACTER_DEVICE, Special);
+		MAP_TYPE(BLOCK_DEVICE, Special);
+		MAP_TYPE(SYMBOLIC_LINK, Link);
+		MAP_TYPE(UNKNOWN, Unknown);
+		default:
+			g_warning ("Unknown VFS type");
+			pStat->eType = osl_File_Type_Unknown;
+			break;
+		}
+#undef MAP_TYPE
+	} else
+		pStat->eType = osl_File_Type_Unknown;
+
+	if (file_info.valid_fields &
+	    GNOME_VFS_FILE_INFO_FIELDS_SIZE) {
+		pStat->uValidFields |= osl_FileStatus_Mask_FileSize;
+		pStat->uFileSize = file_info.size;
+	}
+
+	if (uFieldMask & osl_FileStatus_Mask_FileURL) {
+		char *str;
+		pStat->uValidFields |= osl_FileStatus_Mask_FileURL;
+		str = gnome_vfs_uri_to_string (di, 0);
+		rtl_uString_newFromAscii (&pStat->ustrFileURL, str);
+		g_free (str);
+	}
+
+	if (uFieldMask & osl_FileStatus_Mask_FileName) {
+		pStat->uValidFields |= osl_FileStatus_Mask_FileName;
+		rtl_uString_newFromAscii (&pStat->ustrFileName,
+					  file_info.name ? file_info.name : "");
+	}
+
+	if (uFieldMask & osl_FileStatus_Mask_LinkTargetURL &&
+	    file_info.valid_fields & GNOME_VFS_FILE_INFO_FIELDS_SYMLINK_NAME &&
+	    file_info.symlink_name) {
+		char *uri;
+		pStat->uValidFields |= osl_FileStatus_Mask_LinkTargetURL;
+		if (file_info.symlink_name[0] == '/')
+			uri = gnome_vfs_get_uri_from_local_path (file_info.symlink_name);
+		else {
+			GnomeVFSURI *abs_uri, *dir_uri;
+			dir_uri = gnome_vfs_uri_get_parent (di);
+			abs_uri = gnome_vfs_uri_append_path
+				(dir_uri, file_info.symlink_name);
+			gnome_vfs_uri_unref (dir_uri);
+
+			uri = gnome_vfs_uri_to_string (abs_uri, 0);
+			gnome_vfs_uri_unref (abs_uri);
+		}
+		rtl_uString_newFromAscii (&pStat->ustrLinkTargetURL, uri);
+		g_free (uri);
+	}
+
+	if (file_info.valid_fields &
+	    GNOME_VFS_FILE_INFO_FIELDS_ATIME) {
+		pStat->uValidFields |= osl_FileStatus_Mask_AccessTime;
+		pStat->aAccessTime.Nanosec = 0;
+		pStat->aAccessTime.Seconds = file_info.atime;
+	}
+
+	if (file_info.valid_fields &
+	    GNOME_VFS_FILE_INFO_FIELDS_MTIME) {
+		pStat->uValidFields |= osl_FileStatus_Mask_ModifyTime;
+		pStat->aModifyTime.Nanosec = 0;
+		pStat->aModifyTime.Seconds = file_info.mtime;
+	}
+
+	if (file_info.valid_fields & 
+	    GNOME_VFS_FILE_INFO_FIELDS_PERMISSIONS) {
+		gboolean read_only;
+
+		/*
+		 * FIXME: is this always going to work right ?
+		 * what if we can't get the permissions ?
+		 */
+#define MAP_PERM(a,b) \
+		if (file_info.permissions & GNOME_VFS_PERM_##a) \
+			pStat->uAttributes |= osl_File_Attribute_##b;
+
+		/* Mappings of base permissions */
+		MAP_PERM (USER_READ,  OwnRead);
+		MAP_PERM (USER_WRITE, OwnWrite);
+		MAP_PERM (USER_EXEC,  OwnExe);
+		
+		MAP_PERM (GROUP_READ,  GrpRead);
+		MAP_PERM (GROUP_WRITE, GrpWrite);
+		MAP_PERM (GROUP_EXEC,  GrpExe);
+
+		MAP_PERM (OTHER_READ,  OthRead);
+		MAP_PERM (OTHER_WRITE, OthWrite);
+		MAP_PERM (OTHER_EXEC,  OthExe);
+
+		/* Whether we can access it */
+		read_only = TRUE;
+		if (file_info.uid == getuid ()) {
+			if (file_info.permissions & GNOME_VFS_PERM_USER_READ)
+				pStat->uValidFields |= osl_FileStatus_Mask_Attributes;
+			if (file_info.permissions & GNOME_VFS_PERM_USER_WRITE)
+				read_only = FALSE;
+			MAP_PERM (USER_EXEC, Executable);
+		}
+
+		if (file_info.gid == getgid ()) {
+			if (file_info.permissions & GNOME_VFS_PERM_GROUP_READ)
+				pStat->uValidFields |= osl_FileStatus_Mask_Attributes;
+			if (file_info.permissions & GNOME_VFS_PERM_GROUP_WRITE)
+				read_only = FALSE;
+			MAP_PERM (GROUP_EXEC, Executable);
+		}
+
+		if (file_info.permissions & GNOME_VFS_PERM_OTHER_READ)
+			pStat->uValidFields |= osl_FileStatus_Mask_Attributes;
+		if (file_info.permissions & GNOME_VFS_PERM_OTHER_WRITE)
+			read_only = FALSE;
+		MAP_PERM (OTHER_EXEC, Executable);
+#undef MAP_PERM
+		if (read_only)
+			pStat->uAttributes |= osl_File_Attribute_ReadOnly;
+	} else {
+		pStat->uValidFields |= osl_FileStatus_Mask_Attributes;
+		pStat->uAttributes |= osl_File_Attribute_ReadOnly;
+		g_warning ("Faking permissions on path '%s'",
+			   gnome_vfs_uri_to_string (di, 0));
+	}
+		
+	if (file_info.name && file_info.name[0] == '.')
+		pStat->uAttributes |= osl_File_Attribute_Hidden;
+
+	gnome_vfs_file_info_clear (&file_info);
+
+	return osl_File_E_None;
+}
+
+char *
+osl_debugUString (rtl_uString *str)
+{
+	rtl_String *uri = NULL;
+
+	if (!str)
+		return "<Null>";
+
+	rtl_uString2String
+		(&uri, str->buffer, str->length,
+		 RTL_TEXTENCODING_UTF8, 0);
+
+	return uri->buffer;
+}
+
+oslFileError SAL_CALL
+osl_getSystemPathFromFileURL (rtl_uString  *ustrFileURL,
+			      rtl_uString **pustrSystemPath)
+{
+	rtl_uString *tmp = NULL;
+	const char *scheme;
+	GnomeVFSURI *uri;
+	sal_Unicode encodedSlash[3] = { '%', '2', 'F' };
+	const int furi_len = 7;
+	const sal_Unicode furi[] = { 'f', 'i', 'l', 'e', ':', '/', '/', '\0' };
+
+	if (ustrFileURL->length == 0 ||
+	    ustrFileURL->buffer[0] == '/')
+		return osl_File_E_INVAL;
+
+	osl_vfs_do_init ();
+
+	rtl_uString_acquire (ustrFileURL);
+
+	dprintf ("getSystemPathFromFileURL '%s' ->",
+		 osl_debugUString (ustrFileURL));
+
+	if (rtl_ustr_indexOfStr_WithLength
+	    (ustrFileURL->buffer, ustrFileURL->length,
+	     encodedSlash, 3) != -1)
+		g_warning ("Error: extraordinary - encoded '/'s in URL");
+
+
+	rtl_uriDecode (ustrFileURL, rtl_UriDecodeWithCharset,
+		       RTL_TEXTENCODING_UTF8, &tmp);
+
+	if (!rtl_ustr_shortenedCompareIgnoreAsciiCase_WithLength (
+		tmp->buffer, tmp->length, furi, furi_len, furi_len))
+
+		rtl_uString_newFromStr_WithLength
+			(pustrSystemPath, tmp->buffer + furi_len,
+			 tmp->length - furi_len);
+	else
+		rtl_uString_newFromString (pustrSystemPath, ustrFileURL); 
+
+	rtl_uString_release (tmp);
+
+	dprintf ("-> '%s'", osl_debugUString (*pustrSystemPath));
+
+	rtl_uString_release (ustrFileURL);
+
+	return osl_File_E_None;
+}
+
+/* a slightly modified version of Pchar in rtl/source/uri.c */
+static const sal_Bool uriCharClass[128] =  
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* Pchar but without encoding slashes */
+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+      0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* !"#$%&'()*+,-./*/
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, /*0123456789:;<=>?*/
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /*@ABCDEFGHIJKLMNO*/
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, /*PQRSTUVWXYZ[\]^_*/
+      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /*`abcdefghijklmno*/
+      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0  /*pqrstuvwxyz{|}~ */
+    };
+
+oslFileError SAL_CALL
+osl_getFileURLFromSystemPath (rtl_uString  *ustrSystemPath,
+			      rtl_uString **pustrFileURL)
+{
+	if (ustrSystemPath->length == 0)
+		return osl_File_E_INVAL;
+
+	rtl_uString_acquire (ustrSystemPath);
+
+	dprintf ("getFileURLFromSystemPath '%s' ->",
+		 osl_debugUString (ustrSystemPath));
+
+	if (ustrSystemPath->buffer[0] == '~') {
+		char *expanded;
+		rtl_String *uri = NULL;
+		rtl_uString *uuri = NULL;
+
+		rtl_uString2String
+			(&uri, ustrSystemPath->buffer,
+			 ustrSystemPath->length,
+			 RTL_TEXTENCODING_UTF8, 0);
+
+		expanded = gnome_vfs_expand_initial_tilde (uri->buffer);
+		rtl_string_release (uri);
+
+		rtl_string2UString
+			(&uuri, expanded, strlen (expanded),
+			 RTL_TEXTENCODING_UTF8, 
+			 OSTRING_TO_OUSTRING_CVTFLAGS);
+
+		rtl_uriEncode (uuri, uriCharClass, 
+			       rtl_UriEncodeIgnoreEscapes,
+			       RTL_TEXTENCODING_UTF8,
+			       pustrFileURL);
+
+		rtl_uString_release (uuri);
+	} else
+		rtl_uriEncode (ustrSystemPath, uriCharClass, 
+			       rtl_UriEncodeIgnoreEscapes,
+			       RTL_TEXTENCODING_UTF8,
+			       pustrFileURL);
+
+	/* FIXME: presumably double '//'s get ignored by unix anyway */
+
+	/* other things non paths */
+	if (ustrSystemPath->buffer [0] == '/') {
+		rtl_uString *proto = NULL;
+        
+		rtl_uString_newFromAscii (&proto, "file://");
+		rtl_uString_newConcat (pustrFileURL, proto, *pustrFileURL);
+		rtl_uString_release (proto);
+	}
+	dprintf ("-> '%s'", osl_debugUString (*pustrFileURL));
+
+	rtl_uString_release (ustrSystemPath);
+
+	return osl_File_E_None;
+}
+
+#endif /* USE_GNOME_VFS */
