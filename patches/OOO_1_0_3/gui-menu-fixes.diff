Index: vcl/inc/menu.hxx
===================================================================
RCS file: /cvs/gsl/vcl/inc/menu.hxx,v
retrieving revision 1.5.4.1
diff -u -p -u -r1.5.4.1 menu.hxx
--- vcl/inc/menu.hxx    24 May 2002 14:10:44 -0000      1.5.4.1
+++ vcl/inc/menu.hxx    14 Feb 2003 12:32:26 -0000
@@ -124,6 +124,7 @@ typedef USHORT MenuItemBits;
                                                                                                                             
 #define MENU_FLAG_NOAUTOMNEMONICS              0x0001
 #define MENU_FLAG_HIDEDISABLEDENTRIES  0x0002
+#define MENU_FLAG_SHOWCHECKIMAGES       0x0100
  
 // --------
 // - Menu -

--- vcl/source/window/menu-checkbox-off.xpm	Thu Apr 11 09:25:15 2002
+++ vcl/source/window/menu-checkbox-off.xpm	Thu Apr 10 19:47:09 2003
@@ -0,0 +1,12 @@
+/* XPM */
+static char * menu_checkbox_off_xpm[] = {
+"8 8 1 1",
+" 	c None",
+"        ",
+"        ",
+"        ",
+"        ",
+"        ",
+"        ",
+"        ",
+"        "};
--- vcl/source/window/menu-checkbox-on.xpm	Thu Apr 11 09:25:15 2002
+++ vcl/source/window/menu-checkbox-on.xpm	Thu Apr 10 19:47:09 2003
@@ -0,0 +1,16 @@
+/* XPM */
+static char * menu_checkbox_on_xpm[] = {
+"8 8 5 1",
+" 	c None",
+"+	c #DEDEDE",
+"@	c #000000",
+"#	c #989898",
+"$	c #C9C9C9",
+"        ",
+"        ",
+"     +@#",
+"+@+ +@@+",
+"@@@$@@+ ",
+"+@@@@+  ",
+" +@@+   ",
+"        "};
--- vcl/source/window/menu-radio-off.xpm	Thu Apr 11 09:25:15 2002
+++ vcl/source/window/menu-radio-off.xpm	Thu Apr 10 19:47:09 2003
@@ -0,0 +1,18 @@
+/* XPM */
+static char * menu_radio_off_xpm[] = {
+"8 8 7 1",
+" 	c None",
+".	c #FDFDFD",
+"+	c #CDCDCD",
+"@	c #4F4F4F",
+"#	c #0A0A0A",
+"$	c #D3D3D3",
+"%	c #FEFEFE",
+" +@##@+ ",
+"+#$%%$#+",
+"@$....$@",
+"#%....%#",
+"#%....%#",
+"@$....$@",
+"+#$%%$#+",
+" +@##@+ "};
--- vcl/source/window/menu-radio-on.xpm	Thu Apr 11 09:25:15 2002
+++ vcl/source/window/menu-radio-on.xpm	Thu Apr 10 19:47:09 2003
@@ -0,0 +1,20 @@
+/* XPM */
+static char * menu_radio_on_xpm[] = {
+"8 8 9 1",
+" 	c None",
+"+	c #CDCDCD",
+"@	c #4F4F4F",
+"#	c #0A0A0A",
+"$	c #D3D3D3",
+"%	c #FEFEFE",
+"&	c #9F9F9F",
+"*	c #151515",
+"=	c #000000",
+" +@##@+ ",
+"+#$%%$#+",
+"@$&**&$@",
+"#%*==*%#",
+"#%*==*%#",
+"@$&**&$@",
+"+#$%%$#+",
+" +@##@+ "};
--- vcl/source/window/menu.cxx	Fri May 24 09:10:50 2002
+++ vcl/source/window/menu.cxx	Tue Apr 22 18:26:15 2003
@@ -141,6 +141,17 @@
 
 #include <unohelp.hxx>
 
+#include <ctype.h>
+#include <stdio.h>
+
+#include <salbtype.hxx>
+#include <bmpacc.hxx>
+
+#include "menu-checkbox-off.xpm"
+#include "menu-checkbox-on.xpm"
+#include "menu-radio-off.xpm"
+#include "menu-radio-on.xpm"
+
 using namespace ::com::sun::star;
 
 DBG_NAME( Menu );
@@ -1489,8 +1500,7 @@
 
     Size aSz;
     Size aMaxImgSz;
-    long nMaxTextWidth = 0;
-    long nMaxAccWidth = 0;
+    long nMaxWidth = 0;
 
     for ( USHORT n = (USHORT)pItemList->Count(); n; )
     {
@@ -1501,6 +1511,7 @@
 
         if ( ImplIsVisible( n ) )
         {
+	    long nWidth = 0;
 
             // Separator
             if ( !bIsMenuBar && ( pData->eType == MENUITEM_SEPARATOR ) )
@@ -1525,8 +1536,6 @@
             if ( (pData->eType == MENUITEM_STRING) || (pData->eType == MENUITEM_STRINGIMAGE) )
             {
                 long nTextWidth = pWin->GetCtrlTextWidth( pData->aText );
-                if ( nTextWidth > nMaxTextWidth )
-                    nMaxTextWidth = nTextWidth;
                 long nTextHeight = pWin->GetTextHeight();
                 if ( nTextHeight > pData->aSz.Height() )
                     pData->aSz.Height() = nTextHeight;
@@ -1536,6 +1545,7 @@
                     pData->aSz.Width() = nTextWidth + 4*nExtra;
                     aSz.Width() += pData->aSz.Width();
                 }
+		nWidth += nTextWidth;
             }
 
             // Accel
@@ -1544,15 +1554,15 @@
                 String aName = pData->aAccelKey.GetName();
                 long nAccWidth = pWin->GetTextWidth( aName );
                 nAccWidth += nExtra;
-                if ( nAccWidth > nMaxAccWidth )
-                    nMaxAccWidth = nAccWidth;
+
+		nWidth += nAccWidth;
             }
 
             // SubMenu?
             if ( !bIsMenuBar && pData->pSubMenu )
             {
-                if ( nFontHeight > nMaxAccWidth )
-                    nMaxAccWidth = nFontHeight;
+                if ( nFontHeight > nWidth )
+		    nWidth += nFontHeight;
                 if ( nFontHeight > pData->aSz.Height() )
                     pData->aSz.Height() = nFontHeight;
             }
@@ -1561,19 +1571,27 @@
 
             if ( !bIsMenuBar )
                 aSz.Height() += (long)pData->aSz.Height();
+
+
+	    if ( nWidth > nMaxWidth )
+	        nMaxWidth = nWidth;
         }
     }
 
     if ( !bIsMenuBar )
     {
+        int check_width = 0;
+	if ((nMenuFlags & MENU_FLAG_SHOWCHECKIMAGES) || aMaxImgSz.Width() <= 0)
+	  check_width = nFontHeight/2 + nExtra;
         nCheckPos = (USHORT)nExtra;
-        nImagePos = (USHORT)(nCheckPos + nFontHeight/2 + nExtra );
+        nImagePos = (USHORT)(nCheckPos + check_width);
         nTextPos = (USHORT)(nImagePos+aMaxImgSz.Width());
         if ( aMaxImgSz.Width() )
             nTextPos += (USHORT)nExtra;
 
-        aSz.Width() = nTextPos + nMaxTextWidth + nExtra + nMaxAccWidth;
-        aSz.Width() += 10*nExtra;   // etwas mehr...
+        aSz.Width() = nTextPos + nMaxWidth + nExtra;
+
+        aSz.Width() += 4*nExtra;   // not so much bloat
     }
     else
     {
@@ -1587,6 +1605,327 @@
     return aSz;
 }
 
+static void
+rgb_to_hls (double *r,
+            double *g,
+            double *b)
+{
+	double min;
+	double max;
+	double red;
+	double green;
+	double blue;
+	double h, l, s;
+	double delta;
+  
+	red = *r;
+	green = *g;
+	blue = *b;
+  
+	if (red > green) {
+		if (red > blue)
+			max = red;
+		else
+			max = blue;
+      
+		if (green < blue)
+			min = green;
+		else
+			min = blue;
+    } else {
+		if (green > blue)
+			max = green;
+		else
+			max = blue;
+      
+		if (red < blue)
+			min = red;
+		else
+			min = blue;
+    }
+  
+	l = (max + min) / 2;
+	s = 0;
+	h = 0;
+  
+	if (max != min) {
+		if (l <= 0.5)
+			s = (max - min) / (max + min);
+		else
+			s = (max - min) / (2 - max - min);
+      
+		delta = max -min;
+		if (red == max)
+			h = (green - blue) / delta;
+		else if (green == max)
+			h = 2 + (blue - red) / delta;
+		else if (blue == max)
+			h = 4 + (red - green) / delta;
+      
+		h *= 60;
+		if (h < 0.0)
+			h += 360;
+    }
+  
+	*r = h;
+	*g = l;
+	*b = s;
+}
+
+static void
+hls_to_rgb (double *h,
+            double *l,
+            double *s)
+{
+	double hue;
+	double lightness;
+	double saturation;
+	double m1, m2;
+	double r, g, b;
+  
+	lightness = *l;
+	saturation = *s;
+  
+	if (lightness <= 0.5)
+		m2 = lightness * (1 + saturation);
+	else
+		m2 = lightness + saturation - lightness * saturation;
+	m1 = 2 * lightness - m2;
+  
+	if (saturation == 0) {
+		*h = lightness;
+		*l = lightness;
+		*s = lightness;
+    } else {
+		hue = *h + 120;
+		while (hue > 360)
+			hue -= 360;
+		while (hue < 0)
+			hue += 360;
+      
+		if (hue < 60)
+			r = m1 + (m2 - m1) * hue / 60;
+		else if (hue < 180)
+			r = m2;
+		else if (hue < 240)
+			r = m1 + (m2 - m1) * (240 - hue) / 60;
+		else
+			r = m1;
+      
+		hue = *h;
+		while (hue > 360)
+			hue -= 360;
+		while (hue < 0)
+			hue += 360;
+      
+		if (hue < 60)
+			g = m1 + (m2 - m1) * hue / 60;
+		else if (hue < 180)
+			g = m2;
+		else if (hue < 240)
+			g = m1 + (m2 - m1) * (240 - hue) / 60;
+		else
+			g = m1;
+      
+		hue = *h - 120;
+		while (hue > 360)
+			hue -= 360;
+		while (hue < 0)
+			hue += 360;
+      
+		if (hue < 60)
+			b = m1 + (m2 - m1) * hue / 60;
+		else if (hue < 180)
+			b = m2;
+		else if (hue < 240)
+			b = m1 + (m2 - m1) * (240 - hue) / 60;
+		else
+			b = m1;
+      
+		*h = r;
+		*l = g;
+		*s = b;
+    }
+}
+
+/* Does some weird shading from the bg and fg colors and puts the result in (ir, ig, ib) */
+static void
+shade_rgb (int *ir, int *ig, int *ib, const Color &fg_color, const Color &bg_color, double value)
+{
+	double r, g, b;
+	double f_r, f_g, f_b;
+
+	r = bg_color.GetRed () / 255.0;
+	g = bg_color.GetGreen () / 255.0;
+	b = bg_color.GetBlue () / 255.0;
+
+	f_r = fg_color.GetRed () / 255.0;
+	f_g = fg_color.GetGreen () / 255.0;
+	f_b = fg_color.GetBlue () / 255.0;
+
+	rgb_to_hls (&r, &g, &b);
+	rgb_to_hls (&f_r, &f_g, &f_b);
+
+	/* now green is the lightness */
+
+	g = (g - f_g) * value + f_g;
+	if (g > 1.0)
+		g = 1.0;
+	else if (g < 0.0)
+		g = 0.0;
+
+	hls_to_rgb (&r, &g, &b);
+
+	*ir = (r * 255.0) + 0.5;
+	*ig = (g * 255.0) + 0.5;
+	*ib = (b * 255.0) + 0.5;
+}
+
+/* Takes a grayscale XPM and shades it into a Bitmap */
+static Bitmap *
+create_shaded_bitmap (char **xpm, const Color &fg_color, const Color &bg_color)
+{
+	char *line;
+	int width, height, n_colors, color_len;
+	int palette[256]; /* 0xRRGGBBAA */
+	Bitmap *bitmap;
+	BitmapWriteAccess *wa;
+	int i;
+	int y;
+	int br, bg, bb;
+
+	line = xpm[0];
+
+	if (sscanf (line, "%d%d%d%d", &width, &height, &n_colors, &color_len) != 4)
+		return NULL;
+
+	if (color_len != 1)
+		return NULL;
+
+	/* Read the palette */
+
+	for (i = 0; i < 256; i++)
+		palette[i] = 0;
+
+	for (i = 0; i < n_colors; i++) {
+		char *p;
+		int color_id;
+		int color;
+		BOOL is_transparent;
+
+		line = xpm[i + 1];
+		p = line;
+
+		color_id = *p++;
+
+		while (*p && isspace (*p))
+			p++;
+
+		if (*p != 'c')
+			return NULL;
+
+		p++;
+
+		while (*p && isspace (*p))
+			p++;
+
+		color = 0;
+		is_transparent = TRUE;
+
+		if (*p == '#') {
+			p++;
+			is_transparent = FALSE;
+
+			while (*p) {
+				color = (color << 4);
+
+				if (*p >= '0' && *p <= '9')
+					color += *p - '0';
+				else if (*p >= 'A' && *p <= 'Z')
+					color += *p - 'A' + 10;
+				else
+					break;
+
+				p++;
+			}
+		}
+
+		color = color << 8;
+		if (!is_transparent)
+			color = color | 0xFF;
+
+		palette[color_id] = color;
+	}
+
+	/* Create the bitmap */
+
+	bitmap = new Bitmap (Size (width, height), 24);
+	if (!bitmap)
+		return NULL;
+
+	wa = bitmap->AcquireWriteAccess ();
+	if (!wa) {
+		delete bitmap;
+		return NULL;
+	}
+
+	br = bg_color.GetRed ();
+	bg = bg_color.GetGreen ();
+	bb = bg_color.GetBlue ();
+
+	for (y = 0; y < height; y++) {
+		int x;
+
+		line = xpm[y + n_colors + 1];
+
+		for (x = 0; x < width; x++) {
+			int color;
+			double gray;
+			int r, g, b, a;
+			int tmp;
+
+			color = palette[line[x]];
+			gray = ((color & 0xFF00) >> 8) / 254.0; /* who knows why that is the maximum value in the files */
+			a = color & 0xFF;
+
+			shade_rgb (&r, &g, &b, fg_color, bg_color, gray);
+
+			tmp = (r - br) * a;
+			r = br + ((tmp + (tmp >> 8) + 0x80) >> 8);
+
+			tmp = (g - bg) * a;
+			g = bg + ((tmp + (tmp >> 8) + 0x80) >> 8);
+
+			tmp = (b - bb) * a;
+			b = bb + ((tmp + (tmp >> 8) + 0x80) >> 8);
+
+			wa->SetPixel (y, x, BitmapColor (r, g, b));
+		}
+	}
+
+	bitmap->ReleaseAccess (wa);
+
+	return bitmap;
+}
+
+/* Generates the appropriate image for a check or radio menu item */
+static Bitmap *
+create_option_bitmap (BOOL is_radio, BOOL is_active, const Color &fg_color, const Color &bg_color)
+{
+	static char **xpms[] = {
+		menu_checkbox_off_xpm,
+		menu_checkbox_on_xpm,
+		menu_radio_off_xpm,
+		menu_radio_on_xpm
+	};
+
+	char **xpm;
+
+	xpm = xpms[(is_radio ? 2 : 0) | (is_active ? 1 : 0)];
+
+	return create_shaded_bitmap (xpm, fg_color, bg_color);
+}
+
 void Menu::ImplPaint( Window* pWin, USHORT nBorder, long nStartY, MenuItemData* pThisItemOnly, BOOL bHighlighted )
 {
     // Fuer Symbole: nFontHeight x nFontHeight
@@ -1649,10 +1988,14 @@
                 // Image:
                 if ( !bIsMenuBar && ( ( pData->eType == MENUITEM_IMAGE ) || ( pData->eType == MENUITEM_STRINGIMAGE ) ) )
                 {
+		  // Don't render an image for a check thing
+		  if ((nMenuFlags & MENU_FLAG_SHOWCHECKIMAGES) ||
+                     (!(pData->nBits & (MIB_RADIOCHECK | MIB_CHECKABLE | MIB_AUTOCHECK)) && !pData->bChecked)) {
                     aTmpPos.Y() = aPos.Y();
                     aTmpPos.X() = aPos.X() + nImagePos;
                     aTmpPos.Y() += (pData->aSz.Height()-pData->aImage.GetSizePixel().Height())/2;
                     pWin->DrawImage( aTmpPos, pData->aImage, nImageStyle );
+		  }
                 }
 
                 // Text:
@@ -1679,28 +2022,35 @@
                 }
 
                 // CheckMark
-                if ( !bIsMenuBar && pData->bChecked )
-                {
-                    Rectangle aRect;
-                    SymbolType eSymbol;
-                    aTmpPos.Y() = aPos.Y();
-                    aTmpPos.Y() += nExtra/2;
-                    aTmpPos.Y() += pData->aSz.Height() / 2;
-                    if ( pData->nBits & MIB_RADIOCHECK )
-                    {
-                        aTmpPos.X() = aPos.X() + nCheckPos;
-                        eSymbol = SYMBOL_RADIOCHECKMARK;
-                        aTmpPos.Y() -= nFontHeight/4;
-                        aRect = Rectangle( aTmpPos, Size( nFontHeight/2, nFontHeight/2 ) );
-                    }
-                    else
-                    {
-                        aTmpPos.X() = aPos.X() + nCheckPos;
-                        eSymbol = SYMBOL_CHECKMARK;
-                        aTmpPos.Y() -= nFontHeight/4;
-                        aRect = Rectangle( aTmpPos, Size( (nFontHeight*25)/40, nFontHeight/2 ) );
-                    }
-                    aDecoView.DrawSymbol( aRect, eSymbol, pWin->GetTextColor(), nSymbolStyle );
+                if ( !bIsMenuBar
+					 && !pData->pSubMenu
+					 && (pData->bChecked || (pData->nBits & MIB_CHECKABLE) != 0 || (pData->nBits & MIB_RADIOCHECK) != 0) )
+                {
+					Bitmap *bitmap;
+					BOOL is_radio;
+					BOOL is_active;
+					const StyleSettings &settings = pWin->GetSettings().GetStyleSettings();
+
+					is_radio = (pData->nBits & MIB_RADIOCHECK) != 0;
+					is_active = pData->bChecked;
+
+					bitmap = create_option_bitmap (is_radio,
+												   is_active,
+												   settings.GetMenuTextColor (),
+												   pWin->GetFillColor ());
+
+					if (bitmap) {
+						Point p;
+						int text_yofs;
+
+						text_yofs = (pData->aSz.Height() - nFontHeight) / 2;
+
+						p.X () = aPos.X () + nCheckPos;
+						p.Y () = aPos.Y () + text_yofs + nFontHeight / 2 - bitmap->GetSizePixel ().Height () / 2;
+
+						pWin->DrawBitmap (p, *bitmap);
+						delete bitmap;
+					}
                 }
 
                 // SubMenu?
@@ -3099,6 +3449,7 @@
         ImplDrawScroller( TRUE );
         ImplDrawScroller( FALSE );
     }
+    SetFillColor (GetSettings ().GetStyleSettings ().GetMenuColor ());
     pMenu->ImplPaint( this, nScrollerHeight, ImplGetStartY() );
     if ( nHighlightedItem != ITEMPOS_INVALID )
         HighlightItem( nHighlightedItem, TRUE );
@@ -3547,6 +3898,7 @@
 
 void MenuBarWindow::Paint( const Rectangle& rRect )
 {
+    SetFillColor (GetSettings ().GetStyleSettings ().GetMenuColor ());
     pMenu->ImplPaint( this, 0 );
     if ( nHighlightedItem != ITEMPOS_INVALID )
         HighlightItem( nHighlightedItem, TRUE );
Index: sfx2/source/toolbox/tbxchild.cxx
===================================================================
RCS file: /cvs/framework/sfx2/source/toolbox/tbxchild.cxx,v
retrieving revision 1.9.2.2
diff -u -p -u -r1.9.2.2 tbxchild.cxx
--- sfx2/source/toolbox/tbxchild.cxx	31 May 2002 11:08:56 -0000	1.9.2.2
+++ sfx2/source/toolbox/tbxchild.cxx	14 Feb 2003 13:03:48 -0000
@@ -713,9 +713,11 @@ void SfxToolbox::Command ( const Command
 		{
 			pMenu->RemoveItem( pMenu->GetItemPos( ITEM_ID_VISIBLE_ITEMS ) );
 		}
-
 		SfxUInt16Item aConfigItem ( SID_CONFIGITEMID, pMgr->GetType() );
 		SfxUInt16Item *pItem = &aConfigItem;
+
+		pItemMenu->SetMenuFlags (pItemMenu->GetMenuFlags () | 
+ 					 MENU_FLAG_SHOWCHECKIMAGES);
 
 		USHORT nId = aPop.Execute( this, (const SfxPoolItem*)pItem, 0L );
 

