--- vcl/unx/source/gdi/dtsetenum.hxx
+++ vcl/unx/source/gdi/dtsetenum.hxx
@@ -0,0 +1,177 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _VCL_DTSETENUM_HXX
+#define _VCL_DTSETENUM_HXX
+
+enum DtSetEnum
+{
+    /* settings for mouse */
+    MouseOptions = 1,
+    DoubleClickTime,
+    DoubleClickWidth,
+    DoubleClickHeight,
+    StartDragWidth,
+    StartDragHeight,
+    DragMoveCode,
+    DragCopyCode,
+    DragLinkCode,
+    ContextMenuCode,
+    ContextMenuClicks,
+    ContextMenuDown,
+    ScrollRepeat,
+    ButtonStartRepeat,
+    ButtonRepeat,
+    ActionDelay,
+    MenuDelay,
+    Follow,
+    MiddleButtonAction,
+    /* settings for keyboard */
+    KeyboardOptions=64,
+    /* style settings */
+    StyleOptions = 128,
+    BorderSize,
+    TitleHeight,
+    FloatTitleHeight,
+    TearOffTitleHeight,
+    MenuBarHeight,
+    ScrollBarSize,
+    SpinSize,
+    SplitSize,
+    IconHorzSpace,
+    IconVertSpace,
+    CursorSize,
+    CursorBlinkTime,
+    ScreenZoom,
+    ScreenFontZoom,
+    LogoDisplayTime,
+    DragFullOptions,
+    AnimationOptions,
+    SelectionOptions,
+    DisplayOptions,
+    AntialiasingMinPixelHeight,
+    /* style colors */
+    AllTextColors, /* convenience, sets all control text colors */
+    AllBackColors, /* convenience, sets all control background colors */
+    ThreeDColor,
+    FaceColor,
+    CheckedColor,
+    LightColor,
+    LightBorderColor,
+    ShadowColor,
+    DarkShadowColor,
+    ButtonTextColor,
+    RadioCheckTextColor,
+    GroupTextColor,
+    LabelTextColor,
+    InfoTextColor,
+    WindowColor,
+    WindowTextColor,
+    DialogColor,
+    DialogTextColor,
+    WorkspaceColor,
+    FieldColor,
+    FieldTextColor,
+    ActiveColor,
+    ActiveColor2,
+    ActiveTextColor,
+    ActiveBorderColor,
+    DeactiveColor,
+    DeactiveColor2,
+    DeactiveTextColor,
+    DeactiveBorderColor,
+    HighlightColor,
+    HighlightTextColor,
+    DisableColor,
+    HelpColor,
+    HelpTextColor,
+    MenuColor,
+    MenuBarColor,
+    MenuTextColor,
+    MenuHighlightColor,
+    MenuHighlightTextColor,
+    LinkColor,
+    VisitedLinkColor,
+    HighlightLinkColor,
+    HighContrastMode,
+    /* style fonts */
+    UIFont, /* convenience, sets all fonts but TitleFont and FloatTitleFont */
+    AppFont,
+    HelpFont,
+    TitleFont,
+    FloatTitleFont,
+    MenuFont,
+    ToolFont,
+    GroupFont,
+    LabelFont,
+    InfoFont,
+    RadioCheckFont,
+    PushButtonFont,
+    FieldFont,
+    IconFont,
+    /* style numeric styles */
+    RadioButtonStyle,
+    CheckBoxStyle,
+    PushButtonStyle,
+    TabControlStyle
+};
+
+#endif // _VCL_DTSETENUM_HXX
--- vcl/unx/source/gdi/getstyle/getstyle-gnome.c
+++ vcl/unx/source/gdi/getstyle/getstyle-gnome.c
@@ -0,0 +1,312 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+/*
+ *  to produce getstyle-gnome compile this file like this:
+ *  $(CC) `pkg-config --cflags gtk+-2.0` `pkg-config --libs gtk+-2.0` -o getstyle-gnome getstyle-gnome.c ; strip getstyle-gnome
+ *  where $(CC) is the c-compiler of your choice
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+
+#include <gdk/gdk.h>
+#include <gtk/gtk.h>
+#include <pango/pango.h>
+
+#include <X11/Xlib.h>
+
+#include "../dtsetenum.hxx"
+
+char* pBuffer = NULL;
+char* pCurrent = NULL;
+int   nBufLen = 0;
+
+#ifdef GDK_TYPE_DISPLAY
+GdkWindow* pOutputWindow = NULL;
+#else
+#include <X11/Xatom.h>
+#include <gdk/gdkx.h>
+#endif
+Window	   nOutputWindow = 0;
+GdkAtom aPropertyName;
+GdkAtom aPropertyType;
+
+void buffer_print( const char* pFormat, ... )
+{
+    va_list ap;
+    int nLen;
+    char* pOldBuffer;
+
+    if( !pBuffer )
+    {
+        pBuffer = pCurrent = (char*)g_malloc( nBufLen = 1024 );
+        if( ! pBuffer )
+            return;
+    }
+
+    /* check length of string to append */
+    va_start(ap, pFormat);
+    nLen = vsnprintf( NULL, 0, pFormat, ap );
+    va_end(ap);
+
+    if( (pCurrent-pBuffer)+nLen <= nBufLen )
+    {
+        pOldBuffer = pBuffer;
+        while( nBufLen <= (pCurrent-pBuffer)+nLen )
+            nBufLen = nBufLen*2;
+
+        pBuffer = (char*)g_realloc(pBuffer, nBufLen);
+        if( !pBuffer )
+        {
+            g_free( pOldBuffer );
+            return;
+        }
+        pCurrent = pBuffer + (pCurrent-pOldBuffer);
+    }
+
+    va_start(ap, pFormat);
+    nLen = vsnprintf( pCurrent, nBufLen - (pCurrent-pBuffer), pFormat, ap );
+    va_end(ap);
+
+    pCurrent += nLen;
+}
+
+inline void printColor( int eStyle, GdkColor* pColor )
+{
+    buffer_print( "%d=(%d,%d,%d)\n",
+                  eStyle,
+                  pColor->red/256,
+                  pColor->green/256,
+                  pColor->blue/256 );
+}
+
+inline void printFont( int eStyle, PangoFontDescription* pFont )
+{
+    PangoWeight eWeight;
+    PangoStyle eItalic;
+
+    buffer_print( "%d=\"%s\",%d",
+                  eStyle,
+                  pango_font_description_get_family( pFont ),
+                  pango_font_description_get_size( pFont )/PANGO_SCALE );
+    eWeight = pango_font_description_get_weight( pFont );
+    if( eWeight >= PANGO_WEIGHT_BOLD )
+        buffer_print( ",bold" );
+    else if( eWeight <= PANGO_WEIGHT_LIGHT )
+        buffer_print( ",light" );
+    eItalic = pango_font_description_get_style( pFont );
+    if( eItalic == PANGO_STYLE_ITALIC || eItalic == PANGO_STYLE_OBLIQUE )
+        buffer_print( ",italic" );
+    buffer_print( "\n" );
+}
+
+/* We special case menu items because they use a "menuitem" detail field when
+ * calling gtk_paint_flat_box().
+ */
+static void
+print_menu_color (void)
+{
+	GtkWidget *item;
+	GtkStyle *style;
+
+	item = gtk_menu_item_new ();
+	gtk_widget_ensure_style (item);
+
+	style = gtk_rc_get_style (item);
+	printColor (MenuHighlightColor, &style->bg[GTK_STATE_PRELIGHT]);
+	printColor (MenuHighlightTextColor, &style->fg[GTK_STATE_PRELIGHT]);
+
+	gtk_widget_destroy (item);
+}
+
+void printVCLStyle( GtkWidget* widget )
+{
+    PangoFontDescription* pDesc = NULL;
+    GtkStyle* pStyle = gtk_widget_get_style( widget );
+
+    if( pStyle )
+    {
+        pCurrent = pBuffer;
+        printColor( AllTextColors, &pStyle->text[GTK_STATE_NORMAL] );
+	printColor( DisableColor, &pStyle->text[GTK_STATE_INSENSITIVE] );
+        printColor( AllBackColors, &pStyle->bg[GTK_STATE_NORMAL] );
+        printColor( HighlightColor, &pStyle->base[GTK_STATE_SELECTED] );
+        printColor( HighlightTextColor, &pStyle->text[GTK_STATE_SELECTED] );
+        printColor( FieldColor, &pStyle->base[GTK_STATE_NORMAL] );
+        printColor( WindowColor, &pStyle->base[GTK_STATE_NORMAL] );
+        printColor( CheckedColor, &pStyle->bg[GTK_STATE_ACTIVE] );
+
+	print_menu_color ();
+        
+        printFont( UIFont, pStyle->font_desc );
+
+        /* output the buffer to the VCL_SYSTEM_SETTINGS property of the
+           VCL reference window. */
+#ifdef GDK_TYPE_DISPLAY
+        gdk_property_change( pOutputWindow,
+                             aPropertyName,
+                             aPropertyType,
+                             8,
+                             GDK_PROP_MODE_REPLACE,
+                             (unsigned char*)pBuffer,
+                             pCurrent - pBuffer );
+#else
+	XChangeProperty( gdk_x11_get_default_xdisplay(),
+			 nOutputWindow,
+			 XInternAtom( gdk_x11_get_default_xdisplay(),
+				      "VCL_SYSTEM_SETTINGS",
+				      False ),
+			 XA_STRING,
+			 8,
+			 PropModeReplace,
+			 (unsigned char*)pBuffer,
+			 pCurrent - pBuffer );
+
+#endif
+    }
+}
+
+void style_set( GtkWidget* widget,
+                GtkStyle* style,
+                gpointer data
+                )
+{
+    printVCLStyle( widget );
+}
+
+GdkFilterReturn reference_window_deleted( GdkXEvent* xevent,
+                                          GdkEvent* event,
+                                          gpointer data )
+{
+    if( ((XEvent*)xevent)->type == DestroyNotify &&
+        ((XEvent*)xevent)->xdestroywindow.window == nOutputWindow )
+        gtk_main_quit();
+
+    return GDK_FILTER_CONTINUE;
+}
+
+int main (int argc, char **argv)
+{
+#ifdef GDK_TYPE_DISPLAY
+    GdkDisplay* pDisplay = NULL;
+#endif
+    GtkWidget* mainwin = NULL;
+    int i;
+
+    /* get the reference window */
+    for( i=1; i < argc-1; i++ )
+    {
+        if( !strcmp( argv[i], "--vcl-system-settings-window" ) )
+        {
+            sscanf( argv[i+1], "%d", &nOutputWindow );
+            break;
+        }
+    }
+
+    if( nOutputWindow != 0 )
+    {
+    
+        /* Initialize i18n support */
+        gtk_set_locale ();
+
+        /* Initialize the widget set */
+        gtk_init (&argc, &argv);
+
+        /* Create the main window */
+        mainwin = gtk_window_new (GTK_WINDOW_POPUP);
+        
+        g_signal_connect (G_OBJECT(mainwin), "style-set",
+                          G_CALLBACK (style_set), NULL );
+
+        /* prepare VCL ref window */
+#ifdef GDK_TYPE_DISPLAY
+        pDisplay = gtk_widget_get_display( mainwin );
+        pOutputWindow = gdk_window_foreign_new_for_display( pDisplay, nOutputWindow );
+        gdk_window_set_events( pOutputWindow, GDK_STRUCTURE_MASK );
+        gdk_window_add_filter( pOutputWindow, reference_window_deleted, NULL );
+
+        /* prepare property name and type */
+        aPropertyName = gdk_atom_intern( "VCL_SYSTEM_SETTINGS", FALSE );
+        aPropertyType = gdk_atom_intern( "STRING", FALSE );
+#else
+	XSelectInput( gdk_x11_get_default_xdisplay(),
+		      nOutputWindow,
+		      StructureNotifyMask );
+        gdk_window_add_filter( NULL, reference_window_deleted, NULL );
+#endif
+
+        /* Show the application window */
+        gtk_widget_realize (mainwin);
+        /* hide it again; we just want the styles to be set */
+        /* gtk_widget_hide(mainwin); */
+
+        /* Enter the main event loop, and wait for user interaction */
+        gtk_main ();
+        
+        gtk_widget_destroy( mainwin );
+
+        g_free( pBuffer );
+    }
+    
+    return 0;
+}
--- vcl/unx/source/gdi/gnomeint.cxx	Thu Jan  1 01:00:00 1970
+++ vcl/unx/source/gdi/gnomeint.cxx	Mon Jun 10 18:27:28 2002
@@ -0,0 +1,78 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <gnomeint.hxx>
+
+GNOMEIntegrator::GNOMEIntegrator( SalFrame* pFrame ) :
+		DtIntegrator( pFrame )
+{
+	meType = DtGNOME;
+    StartSystemLookProcess( "getstyle-gnome" );
+}
+
+GNOMEIntegrator::~GNOMEIntegrator()
+{
+}
+
+void GNOMEIntegrator::GetSystemLook( AllSettings& rSettings )
+{
+    DtIntegrator::GetSystemLook( NULL, rSettings );
+}
--- vcl/unx/source/gdi/makefile.mk	Tue Aug 27 15:50:30 2002
+++ vcl/unx/source/gdi/makefile.mk	Tue Aug 27 15:52:35 2002
@@ -89,7 +89,7 @@
 		$(SLO)$/salogl.obj		\
 		$(SLO)$/charnames.obj	\
 		$(SLO)$/dtint.obj		\
-		$(SLO)$/kdeint.obj		\
+		$(SLO)$/gnomeint.obj		\
 		$(SLO)$/salcvt.obj		\
 		$(SLO)$/ansi1252.obj	\
 		$(SLO)$/xfont.obj		\
--- vcl/unx/inc/wmadaptor.hxx	Tue Nov 27 18:13:48 2001
+++ vcl/unx/inc/wmadaptor.hxx	Mon Jun 10 18:27:27 2002
@@ -144,6 +144,7 @@
         DTWM_IS_RUNNING,
 	SUN_WM_PROTOCOLS,
 	SUN_OL_WIN_ATTR_5,
+        VCL_SYSTEM_SETTINGS,
         NetAtomMax
     };
 
--- vcl/unx/inc/gnomeint.hxx	Thu Jan  1 01:00:00 1970
+++ vcl/unx/inc/gnomeint.hxx	Mon Jun 10 18:27:27 2002
@@ -0,0 +1,80 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#ifndef _SV_GNOMEINT_HXX
+#define _SV_GNOMEINT_HXX
+
+#ifndef _SV_DTINT_HXX
+#include <dtint.hxx>
+#endif
+
+class GNOMEIntegrator : public DtIntegrator
+{
+	friend DtIntegrator* DtIntegrator::CreateDtIntegrator( SalFrame* );
+private:
+	GNOMEIntegrator( SalFrame* );
+
+public:
+	virtual ~GNOMEIntegrator();
+
+	virtual void GetSystemLook( AllSettings& rSettings );
+};
+
+#endif
--- vcl/unx/inc/dtint.hxx	Mon Aug 20 12:05:08 2001
+++ vcl/unx/inc/dtint.hxx	Mon Jun 10 18:27:27 2002
@@ -62,7 +62,6 @@
 #define _SV_DTINT_HXX
 
 #include <cstdio>
-#include <dlfcn.h>
 
 #ifndef _LIST_HXX
 #include <tools/list.hxx>
@@ -77,9 +76,8 @@
 
 class SalFrame;
 class SalBitmap;
-class String;
 class SalDisplay;
-class FastItemInfo;
+class AllSettings;
 
 #ifndef _XLIB_H_
 // forwards from X
@@ -89,69 +87,10 @@
 #define XLIB_Window UINT32
 #endif
 
-#define XDND_PROTOCOL_VERSION 3
-
-// NETBSD has no RTLD_GLOBAL
-#ifndef RTLD_GLOBAL
-#define DLOPEN_MODE (RTLD_LAZY)
-#else
-#define DLOPEN_MODE (RTLD_GLOBAL | RTLD_LAZY)
-#endif
-
 class DtIntegrator;
 
 DECLARE_LIST( DtIntegratorList, DtIntegrator* );
 
-struct SystemLookInfo
-{
-	/** system foreground color */
-	Color							foreground;
-	/** system background color */
-	Color							background;
-	/** system foreground color for a selection */
-	Color							selectForeground;
-	/** system background color for a selection */
-	Color							selectBackground;
-
-	/** gradient for an active window */
-	Color							windowActiveStart;
-	Color							windowActiveEnd;
-	/** border color for active window */
-	Color							activeBorder;
-	/** text color for active window bar */
-	Color							activeForeground;
-	/** gradient of an inactive window */
-	Color							windowInactiveStart;
-	Color							windowInactiveEnd;
-	/** border color for inactive window */
-	Color							inactiveBorder;
-	/** text color for inactive window bar */
-	Color							inactiveForeground;
-	
-	/** font to use for controls. Empty if not set. */
-	String							controlFont;
-	/** font to use for dragbars. Empty if not set. */
-	String							windowFont;
-
-	SystemLookInfo()
-		{
-			foreground.SetColor( COL_TRANSPARENT );
-			background.SetColor( COL_TRANSPARENT );
-			selectBackground.SetColor( COL_TRANSPARENT );
-			selectForeground.SetColor( COL_TRANSPARENT );
-
-			windowActiveStart.SetColor( COL_TRANSPARENT );
-			windowActiveEnd.SetColor( COL_TRANSPARENT );
-			activeBorder.SetColor( COL_TRANSPARENT );
-			activeForeground.SetColor( COL_TRANSPARENT );
-
-			windowInactiveStart.SetColor( COL_TRANSPARENT );
-			windowInactiveEnd.SetColor( COL_TRANSPARENT );
-			inactiveBorder.SetColor( COL_TRANSPARENT );
-			inactiveForeground.SetColor( COL_TRANSPARENT );
-		}
-};
-
 enum DtType {
 	DtGeneric,
 	DtCDE,
@@ -169,6 +108,7 @@
 	SalDisplay*			mpSalDisplay;
 	SalFrame*			mpSalFrame;
 	int					mnRefCount;
+    int					mnSystemLookCommandProcess;
 
 
 	DtIntegrator( SalFrame* );
@@ -176,13 +116,21 @@
 	static DtIntegratorList	aIntegratorList;
 	static String			aHomeDir;
 
+    // executes pCommand and parses its output
+    // to get system look information
+    // different DtIntegrators can rely
+    // on native programs to query system settings
+    // pass NULL as command to read the VCL_SYSTEM_SETTINGS property
+    void GetSystemLook( const char* pCommand, AllSettings& rSettings );
+    bool StartSystemLookProcess( const char* pCommand );
+
 public:
 	static DtIntegrator* CreateDtIntegrator( SalFrame* );
 	
 	virtual ~DtIntegrator();
 
 	// SystemLook
-	virtual BOOL GetSystemLook( SystemLookInfo& rInfo );
+	virtual void GetSystemLook( AllSettings& rSettings );
 	
 	DtType			GetDtType() { return meType; }
 	SalFrame*		GetFrame() { return mpSalFrame; }
@@ -203,33 +151,4 @@
 	}
 }
 
-// helper funktions for dynamic loading
-extern BOOL bSymbolLoadFailed;
-
-inline void* _LoadSymbol( void* pLibrary, char* pSymbolname )
-{
-	void *pRet = dlsym( pLibrary, pSymbolname );
-	if( ! pRet )
-	{
-		fprintf( stderr, "Could not load symbol %s: %s\n",
-				 pSymbolname, dlerror() );
-		bSymbolLoadFailed = TRUE;
-	}
-	return pRet;
-}
-inline void* _LoadLibrary( char* pLibname )
-{
-	bSymbolLoadFailed = FALSE;
-	void *pRet = dlopen( pLibname, DLOPEN_MODE );
-	if( ! pRet )
-	{
-#ifdef DEBUG
-		fprintf( stderr, "%s could not be opened: %s\n",
-				 pLibname, dlerror() );
-#endif
-		bSymbolLoadFailed = TRUE;
-	}
-	return pRet;
-}
-
 #endif
--- vcl/unx/source/window/salframe.cxx
+++ vcl/unx/source/window/salframe.cxx
@@ -294,6 +294,10 @@
 		pParent->maFrameData.maChildren.push_back( pFrame );
 	pFrame->maFrameData.Init( nSalFrameStyle );
 
+	// initialize system settings update
+	DtIntegrator* pIntegrator = DtIntegrator::CreateDtIntegrator( pFrame );
+	pIntegrator->Acquire();
+
 	return pFrame;
 }
 
@@ -2016,85 +2020,12 @@
 
 void SalFrame::UpdateSettings( AllSettings& rSettings )
 {
-
-	static SystemLookInfo aInfo;
-	static BOOL bHaveInfo = FALSE;
-	static BOOL bInit = FALSE;
-
-	if( ! bInit )
-	{
-		bInit = TRUE;
-		DtIntegrator* pIntegrator = DtIntegrator::CreateDtIntegrator( this );
-		if( pIntegrator )
-			bHaveInfo = pIntegrator->GetSystemLook( aInfo );
-	}
-
-	if( bHaveInfo )
-	{
-		StyleSettings aStyleSettings = rSettings.GetStyleSettings();
-		if( aInfo.windowActiveStart.GetColor() != COL_TRANSPARENT )
-		{
-			aStyleSettings.SetActiveColor( aInfo.windowActiveStart );
-			if( aInfo.windowActiveEnd.GetColor() != COL_TRANSPARENT )
-				aStyleSettings.SetActiveColor2( aInfo.windowActiveEnd );
-		}
-		if( aInfo.windowInactiveStart.GetColor() != COL_TRANSPARENT )
-		{
-			aStyleSettings.SetDeactiveColor( aInfo.windowInactiveStart );
-			if( aInfo.windowInactiveEnd.GetColor() != COL_TRANSPARENT )
-				aStyleSettings.SetDeactiveColor2( aInfo.windowInactiveEnd );
-		}
-		if( aInfo.activeBorder.GetColor() != COL_TRANSPARENT )
-			aStyleSettings.SetActiveBorderColor( aInfo.activeBorder );
-		if( aInfo.inactiveBorder.GetColor() != COL_TRANSPARENT )
-			aStyleSettings.SetDeactiveBorderColor( aInfo.inactiveBorder );
-		if( aInfo.activeForeground.GetColor() != COL_TRANSPARENT )
-			aStyleSettings.SetActiveTextColor( aInfo.activeForeground );
-		if( aInfo.inactiveForeground.GetColor() != COL_TRANSPARENT )
-			aStyleSettings.SetDeactiveTextColor( aInfo.inactiveForeground );
-		if( aInfo.selectForeground.GetColor() != COL_TRANSPARENT )
-			aStyleSettings.SetHighlightTextColor( aInfo.selectForeground );
-		if( aInfo.selectBackground.GetColor() != COL_TRANSPARENT )
-			aStyleSettings.SetHighlightColor( aInfo.selectBackground );
-		if( aInfo.foreground.GetColor() != COL_TRANSPARENT )
-		{
-			aStyleSettings.SetDialogTextColor( aInfo.foreground );
-			aStyleSettings.SetMenuTextColor( aInfo.foreground );
-			aStyleSettings.SetButtonTextColor( aInfo.foreground );
-			aStyleSettings.SetRadioCheckTextColor( aInfo.foreground );
-			aStyleSettings.SetGroupTextColor( aInfo.foreground );
-			aStyleSettings.SetLabelTextColor( aInfo.foreground );
-			aStyleSettings.SetInfoTextColor( aInfo.foreground );
-		}
-		if( aInfo.background.GetColor() != COL_TRANSPARENT )
-		{
-			aStyleSettings.Set3DColors( aInfo.background );
-			aStyleSettings.SetFaceColor( aInfo.background );
-			aStyleSettings.SetDialogColor( aInfo.background );
-			aStyleSettings.SetMenuColor( aInfo.background );
-			aStyleSettings.SetMenuBarColor( aInfo.background );
-			if ( aStyleSettings.GetFaceColor() == COL_LIGHTGRAY )
-        		aStyleSettings.SetCheckedColor( Color( 0xCC, 0xCC, 0xCC ) );
-			else
-			{
-        		// calculate Checked color
-        		Color   aColor2 = aStyleSettings.GetLightColor();
-        		BYTE    nRed    = (BYTE)(((USHORT)aInfo.background.GetRed()   + (USHORT)aColor2.GetRed())/2);
-        		BYTE    nGreen  = (BYTE)(((USHORT)aInfo.background.GetGreen() + (USHORT)aColor2.GetGreen())/2);
-        		BYTE    nBlue   = (BYTE)(((USHORT)aInfo.background.GetBlue()  + (USHORT)aColor2.GetBlue())/2);
-        		aStyleSettings.SetCheckedColor( Color( nRed, nGreen, nBlue ) );
-			}
-		}
-	
-		if( aInfo.windowFont.Len() )
-		{
-			Font aWindowFont = aStyleSettings.GetTitleFont();
-			aWindowFont.SetName( aInfo.windowFont );
-			aStyleSettings.SetTitleFont( aWindowFont );
-		}
-		
-		rSettings.SetStyleSettings( aStyleSettings );
-	}
+    DtIntegrator* pIntegrator = DtIntegrator::CreateDtIntegrator( this );
+#ifdef DEBUG
+    fprintf( stderr, "DtIntegrator: %d\n", pIntegrator ? pIntegrator->GetDtType() : -1 );
+#endif
+    if( pIntegrator )
+        pIntegrator->GetSystemLook( rSettings );
 }
 
 // Sound
--- vcl/unx/source/app/saldisp.cxx	Wed Aug  7 21:49:59 2002
+++ vcl/unx/source/app/saldisp.cxx	Sun Jan  5 19:21:27 2003
@@ -886,13 +886,14 @@
         aXWAttributes.border_pixel      = 0;
         aXWAttributes.background_pixel  = 0;
         aXWAttributes.colormap          = hXColmap;
+	aXWAttributes.event_mask        = PropertyChangeMask;
         hRefWindow_     = XCreateWindow( pDisp_,
                                          hRootWindow_,
                                          0,0, 16,16, 0,
                                          pVisual_->GetDepth(),
                                          InputOutput,
                                          pVisual_->GetVisual(),
-                                         CWBorderPixel|CWBackPixel|CWColormap,
+                                         CWBorderPixel|CWBackPixel|CWColormap|CWEventMask,
                                          &aXWAttributes );
 
 		// set client leader and session id
@@ -1137,13 +1138,14 @@
       aXWAttributes.border_pixel              = 0;
       aXWAttributes.background_pixel          = 0;
       aXWAttributes.colormap                  = hXColmap;
+      aXWAttributes.event_mask                = PropertyChangeMask;
       hRefWindow_                             = XCreateWindow( pDisp_,
                                                                hRootWindow_,
                                                                0, 0, 16, 16, 0,
                                                                pVisual_->GetDepth(),
                                                                InputOutput,
                                                                pVisual_->GetVisual(),
-                                                               CWBorderPixel|CWBackPixel|CWColormap,
+                                                               CWBorderPixel|CWBackPixel|CWColormap|CWEventMask,
                                                                &aXWAttributes );
 
 #endif
@@ -2572,6 +2574,17 @@
     pXLib_->SetIgnoreXErrors( bIgnoreXErrors );
 }
 
+static void
+notify_settings_changed (SalDisplay *display)
+{
+	SalFrame *frame;
+
+	for (frame = GetSalData ()->pFirstFrame_; 
+	     frame;
+	     frame = frame->maFrameData.GetNextFrame ())
+		frame->maFrameData.Call (SALEVENT_SETTINGSCHANGED, NULL);
+}
+
 long SalDisplay::Dispatch( XEvent *pEvent )
 {
 	if( pEvent->type == XLIB_KeyPress || pEvent->type == KeyRelease )
@@ -2611,6 +2624,13 @@
                 ;
             break;
 
+        case PropertyNotify:
+            if( pEvent->xproperty.window == hRefWindow_ &&
+                pEvent->xproperty.atom == getWMAdaptor()->getAtom( ::vcl_sal::WMAdaptor::VCL_SYSTEM_SETTINGS ) )
+		    notify_settings_changed (this);
+
+            return 0;
+
         case MappingNotify:
             if( MappingKeyboard == pEvent->xmapping.request )
                 XRefreshKeyboardMapping( &pEvent->xmapping );
--- vcl/unx/source/app/wmadaptor.cxx
+++ vcl/unx/source/app/wmadaptor.cxx
@@ -200,7 +200,8 @@
     { "SAL_EXTTEXTEVENT", WMAdaptor::SAL_EXTTEXTEVENT },
     { "DTWM_IS_RUNNING", WMAdaptor::DTWM_IS_RUNNING },
     { "_SUN_WM_PROTOCOLS", WMAdaptor::SUN_WM_PROTOCOLS },
-    { "_SUN_OL_WIN_ATTR_5", WMAdaptor::SUN_OL_WIN_ATTR_5 }
+    { "_SUN_OL_WIN_ATTR_5", WMAdaptor::SUN_OL_WIN_ATTR_5 },
+    { "VCL_SYSTEM_SETTINGS", WMAdaptor::VCL_SYSTEM_SETTINGS }
 };
 
 extern "C" {
--- scp/source/office/files.scp
+++ scp/source/office/files.scp
@@ -2552,6 +2529,13 @@
         Styles          = (PACKED);
 End
 
+File Gid_FILE_BIN_GETSTYLEGNOME
+               BIN_FILE_BODY;
+               Name                    = "getstyle-gnome";
+               Dir                             = GID_DIR_PROGRAM;
+               Styles                  = (PACKED);
+End
+
 #ifndef OSL_PRODUCT
 
 STD_FONTUNX_FILE( GID_FILE_FNT_STARSYMB, starsymb.ttf, StarSymbol)
--- vcl/unx/source/gdi/getstyle/makefile.mk
+++ vcl/unx/source/gdi/getstyle/makefile.mk
@@ -0,0 +1,14 @@
+PRJ=..$/..$/..$/..
+PRJNAME=vcl
+TARGET=salgdigetstyle
+
+.INCLUDE :  $(PRJ)$/util$/makefile.pmk
+.INCLUDE :  settings.mk
+.INCLUDE :  target.mk
+.INCLUDE :  $(PRJ)$/util$/target.pmk
+ALLTAR: $(BIN)$/getstyle-gnome
+$(BIN)$/getstyle-gnome: getstyle-gnome.c
+	setenv UGLY_HACK_INDEED "$/LD_LIBRARY_PATH"; \
+	unsetenv LD_LIBRARY_PATH; \
+	$(CC) `pkg-config --cflags gtk+-2.0` `pkg-config --libs gtk+-2.0` -o $(BIN)$/getstyle-gnome getstyle-gnome.c; \
+	setenv LD_LIBRARY_PATH "$/UGLY_HACK_INDEED"
--- vcl/prj/build.lst
+++ vcl/prj/build.lst
@@ -19,6 +19,7 @@
 vc	vcl\os2\source\src						nmake	-	p	vc__srcp vc_unot NULL
 vc	vcl\unx\source\app						nmake	-	u	vc__appu vc_unot NULL
 vc	vcl\unx\source\gdi						nmake	-	u	vc__gdiu vc_unot NULL
+vc	vcl\unx\source\gdi\getstyle					nmake	-	u	vc__gdus vc_unot NULL
 vc	vcl\unx\source\window					nmake	-	u	vc__winu vc_unot NULL
 vc	vcl\unx\source\src						nmake	-	u	vc__srcu vc_unot NULL
 vc	vcl\aqua\source\app						nmake	-	u	vc__appa vc_unot NULL
--- vcl/prj/d.lst
+++ vcl/prj/d.lst
@@ -12,6 +13,7 @@
 ..\%__SRC%\bin\vcl?????.res %_DEST%\bin%_EXT%\vcl?????.res
 ..\%__SRC%\bin\vcl?????.dll %_DEST%\bin%_EXT%\vcl?????.dll
 ..\%__SRC%\bin\vcl?????.sym %_DEST%\bin%_EXT%\vcl?????.sym
+..\%__SRC%\bin\getstyle-gnome %_DEST%\bin%_EXT%\getstyle-gnome
 ..\%__SRC%\lib\*.a %_DEST%\lib%_EXT%\*.a
 ..\%__SRC%\lib\*.sl %_DEST%\lib%_EXT%\*.sl
 ..\%__SRC%\lib\*.so %_DEST%\lib%_EXT%\*.so


Index: vcl/unx/source/gdi/dtint.cxx
===================================================================
RCS file: /cvs/gsl/vcl/unx/source/gdi/dtint.cxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 dtint.cxx
--- vcl/unx/source/gdi/dtint.cxx	24 Oct 2001 16:32:21 -0000	1.5
+++ vcl/unx/source/gdi/dtint.cxx	14 Jan 2003 20:31:04 -0000
@@ -59,39 +59,44 @@
  *
  ************************************************************************/
 
-#include <prex.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <dlfcn.h>
+
+#include <salunx.h>
 #include <X11/Xatom.h>
-#include <X11/keysym.h>
-#include <postx.h>
 
 #ifdef USE_CDE
 #include <cdeint.hxx>
 #endif
-#include <kdeint.hxx>
-#include <soicon.hxx>
+#include <gnomeint.hxx>
 #include <saldisp.hxx>
 #include <saldata.hxx>
-#include <salbmp.hxx>
 #include <salframe.hxx>
+#include <wmadaptor.hxx>
 
-#include <strhelper.hxx>
 #include <svapp.hxx>
+#include <dtsetenum.hxx>
 
-#include <unistd.h>
-
-#ifndef _VOS_PROCESS_HXX
-#include <vos/process.hxx>
-#endif
+#include <osl/file.h>
+#include <osl/process.h>
 
-#include <tools/urlobj.hxx>
+#include <set>
+#include <stdio.h>
 
-#ifdef SOLARIS
-// Solaris 2.5.1 misses it in unistd.h
-extern "C" int usleep(unsigned int);
+// NETBSD has no RTLD_GLOBAL
+#ifndef RTLD_GLOBAL
+#define DLOPEN_MODE (RTLD_LAZY)
+#else
+#define DLOPEN_MODE (RTLD_GLOBAL | RTLD_LAZY)
 #endif
 
-#define MAX_TRY_CONVERTSELECTION 40
-#define EVENTMASK_WHILE_DRAGGING ButtonPressMask | ButtonReleaseMask | PointerMotionMask
+//#define DEBUG
+
+using namespace rtl;
+using namespace vcl_sal;
 
 BOOL bSymbolLoadFailed = FALSE;
 
@@ -100,13 +105,18 @@
 
 DtIntegrator::DtIntegrator( SalFrame* pFrame ) :
 		mpSalFrame( pFrame ),
-		mpSalDisplay( pFrame->maFrameData.GetDisplay() ),
 		meType( DtGeneric ),
-		mnRefCount( 0 )
+		mnRefCount( 0 ),
+        mnSystemLookCommandProcess( -1 )
 {
+    if( pFrame )
+        mpSalDisplay = pFrame->maFrameData.GetDisplay();
+    else
+        mpSalDisplay = GetSalData()->GetDefDisp();
 	mpDisplay = mpSalDisplay->GetDisplay();
 	aIntegratorList.Insert( this, LIST_APPEND );
-	aHomeDir = String( getenv( "HOME" ), gsl_getSystemTextEncoding() );
+    static const char* pHome = getenv( "HOME" );
+	aHomeDir = String( pHome, osl_getThreadTextEncoding() );
 }
 
 DtIntegrator::~DtIntegrator()
@@ -119,41 +129,446 @@
 	if( ! pFrame && aIntegratorList.Count() )
 		return aIntegratorList.GetObject( 0 );
 
+	SalDisplay* pSalDisplay = pFrame ? pFrame->maFrameData.GetDisplay() : GetSalData()->GetDefDisp();
+	Display* pDisplay = pSalDisplay->GetDisplay();
+
 	for( int i = 0; i < aIntegratorList.Count(); i++ )
 	{
 		DtIntegrator* pIntegrator = aIntegratorList.GetObject( i );
-		if( pIntegrator->mpDisplay == pFrame->maFrameData.GetXDisplay() )
+		if( pIntegrator->mpDisplay == pDisplay )
 			return pIntegrator;
 	}
 
-	if( ! pFrame )
-		pFrame = GetSalData()->pFirstFrame_;
-	
-#ifndef REMOTE_APPSERVER
-	Display* pDisplay = pFrame->maFrameData.GetXDisplay();
-	Atom nDtAtom;
-	void* pLibrary = NULL;
+	Atom nDtAtom = None;
 
 #ifdef USE_CDE
+	void* pLibrary = NULL;
+
 	// check dt type
 	// CDE
 	nDtAtom = XInternAtom( pDisplay, "_DT_WM_READY", True );
-	if( nDtAtom && ( pLibrary = _LoadLibrary( "libDtSvc.so" ) ) )
+	if( nDtAtom && ( pLibrary = dlopen( "libDtSvc.so", DLOPEN_MODE ) ) )
 	{
         dlclose( pLibrary );
 		return new CDEIntegrator( pFrame );
 	}
 #endif
 
-	nDtAtom = XInternAtom( pDisplay, "KWM_RUNNING", True );
-	if( nDtAtom ) // perhaps should check getenv( "KDEDIR" )
-		return new KDEIntegrator( pFrame );
+	return new GNOMEIntegrator( pFrame );
+}
+
+void DtIntegrator::GetSystemLook( AllSettings& rSettings )
+{
+}
+
+static Color parseColor( const ByteString& rLine )
+{
+    Color aColor;
+
+    xub_StrLen nPos1 = rLine.Search( '(' );
+    xub_StrLen nPos2 = rLine.Search( ')', nPos1 != STRING_NOTFOUND ? nPos1 : 0 );
+    if( nPos1 != STRING_NOTFOUND && nPos2 != STRING_NOTFOUND
+        && (int)nPos2 - (int)nPos1 > 5 )
+    {
+        ByteString aTriple( rLine.Copy( nPos1+1, nPos2-nPos1-1 ) );
+        xub_StrLen nIndex = 0;
+        int nRed, nGreen, nBlue, nColor = 0;
+        do
+        {
+            switch( nColor )
+            {
+                case 0: nRed = aTriple.GetToken( 0, ',', nIndex ).ToInt32();break;
+                case 1: nGreen = aTriple.GetToken( 0, ',', nIndex ).ToInt32();break;
+                case 2: nBlue = aTriple.GetToken( 0, ',', nIndex ).ToInt32();break;
+            }
+            nColor++;
+        } while(  nIndex != STRING_NOTFOUND );
+        if( nColor == 3 )
+        {
+            aColor = Color( nRed, nGreen, nBlue );
+        }
+    }
+    return aColor;
+}
+
+static Font parseFont( const ByteString& rLine )
+{
+    Font aFont;
+
+    xub_StrLen nPos1 = rLine.Search( '"' );
+    xub_StrLen nPos2 = rLine.Search( '"', nPos1 != STRING_NOTFOUND ? nPos1+1 : 0 );
+    if( nPos1 != STRING_NOTFOUND && nPos2 != STRING_NOTFOUND
+        && (int)nPos2 - (int)nPos1 > 1 )
+    {
+      String fontName( rLine.Copy( nPos1+1, nPos2-nPos1-1 ), osl_getThreadTextEncoding() );
+
+
+      /// nasty hack (of mine) removed from here ...
+
+
+
+      aFont.SetName( fontName );
+
+      xub_StrLen nIndex = nPos2;
+      ByteString aToken;
+      aToken = rLine.GetToken( 1, ',', nIndex );
+      if( aToken.Len() )
+        {
+	  int nHeight = aToken.ToInt32();
+	  if( nHeight > 5 )
+	    aFont.SetHeight( nHeight );
+        }
+
+      while( nIndex != STRING_NOTFOUND )
+        {
+            aToken = rLine.GetToken( 0, ',', nIndex );
+            if( aToken.Equals( "bold" ) )
+                aFont.SetWeight( WEIGHT_BOLD );
+            else if( aToken.Equals( "light" ) )
+                aFont.SetWeight( WEIGHT_LIGHT );
+            else if( aToken.Equals( "italic" ) )
+                aFont.SetItalic( ITALIC_NORMAL );
+        }
+    }
+    return aFont;
+}
+
+bool DtIntegrator::StartSystemLookProcess( const char* pCommand )
+{
+    ByteString aCommand, aArgWindow;
+    if( pCommand[0] == '/' )
+        aCommand = pCommand;
+    else
+    {
+        OUString aExec;
+        OUString aSys;
+        osl_getExecutableFile( &aExec.pData );
+        if( osl_File_E_None != osl_getSystemPathFromFileURL( aExec.pData, &aSys.pData ) )
+            return false; // huh ?
+        aCommand = ByteString( String( aSys ), osl_getThreadTextEncoding() );
+        aCommand.Erase( aCommand.SearchBackward( '/' )+1 );
+        aCommand.Append( pCommand );
+    }
+    aArgWindow = ByteString::CreateFromInt32( mpSalDisplay->GetDrawable() );
+    mnSystemLookCommandProcess = fork();
+    if( mnSystemLookCommandProcess == 0 )
+    {
+#ifdef DEBUG
+        fprintf( stderr, "exec( \"%s --vcl-system-settings-window %s\" )\n", aCommand.GetBuffer(), aArgWindow.GetBuffer() );
 #endif
-	// default: generic implementation
-	return new DtIntegrator( pFrame );
+        int nRedirect = open( "/dev/null", O_WRONLY );
+        if( nRedirect != -1 )
+        {
+            dup2( nRedirect, STDOUT_FILENO );
+            dup2( nRedirect, STDERR_FILENO );
+        }
+        execl( aCommand.GetBuffer(), aCommand.GetBuffer(), "--vcl-system-settings-window", aArgWindow.GetBuffer(), NULL );
+        _exit(1);
+    }
+    return mnSystemLookCommandProcess != -1;
 }
 
-BOOL DtIntegrator::GetSystemLook( SystemLookInfo& rInfo )
+void DtIntegrator::GetSystemLook( const char* pCommand, AllSettings& rSettings )
 {
-	return FALSE;
+    BOOL bRet = FALSE;
+    std::list< ByteString > aLines;
+
+    if( pCommand )
+    {
+        char pBuffer[1024];
+        FILE* pOutput = NULL;
+
+        ByteString aCommand;
+        if( pCommand[0] == '/' )
+            aCommand = pCommand;
+        else
+        {
+            OUString aExec;
+            OUString aSys;
+            osl_getExecutableFile( &aExec.pData );
+            if( osl_File_E_None != osl_getSystemPathFromFileURL( aExec.pData, &aSys.pData ) )
+                return; // huh ?
+            aCommand = ByteString( String( aSys ), osl_getThreadTextEncoding() );
+            aCommand.Erase( aCommand.SearchBackward( '/' )+1 );
+            aCommand.Append( pCommand );
+        }
+#ifndef DEBUG
+        aCommand.Append( " 2>/dev/null" );
+#endif
+        pOutput = popen( aCommand.GetBuffer(), "r" );
+#ifdef DEBUG
+        fprintf( stderr, "popen( \"%s\", \"r\" ) = %p\n", aCommand.GetBuffer(), pOutput );
+#endif
+        while( fgets( pBuffer, sizeof( pBuffer ), pOutput ) )
+        {
+            aLines.push_back( ByteString( pBuffer ) );
+        }
+        pclose( pOutput );
+    }
+    else if( ! pCommand && mnSystemLookCommandProcess != -1 )
+    {
+        // get the lines from the VCL_SYSTEM_SETTINGS property
+        Atom nType = 0;
+        int nFormat = 0;
+        unsigned long nItems = 0, nBytes = 0;
+        char* pData = NULL;
+        // query size of the property
+        XGetWindowProperty( mpSalDisplay->GetDisplay(),
+                            mpSalDisplay->GetDrawable(),
+                            mpSalDisplay->getWMAdaptor()->getAtom( WMAdaptor::VCL_SYSTEM_SETTINGS ),
+                            0, 0,
+                            False,
+                            XA_STRING,
+                            &nType,
+                            &nFormat,
+                            &nItems,
+                            &nBytes,
+                            (unsigned char**)&pData );
+        if( nBytes )
+        {
+            // query the actual data
+            XGetWindowProperty( mpSalDisplay->GetDisplay(),
+                                mpSalDisplay->GetDrawable(),
+                                mpSalDisplay->getWMAdaptor()->getAtom( WMAdaptor::VCL_SYSTEM_SETTINGS ),
+                                0, (nBytes+3)/4,
+                                False,
+                                XA_STRING,
+                                &nType,
+                                &nFormat,
+                                &nItems,
+                                &nBytes,
+                                (unsigned char**)&pData );
+            // sanity check
+            if( nFormat == 8 && nType == XA_STRING && nItems )
+            {
+#ifdef DEBUG
+                fprintf( stderr, "got %d data items:\n%.*s", nItems, nItems, pData );
+#endif
+                // fill in the lines
+                char* pRun = pData;
+                char* pLastLine = pData;
+                while( (pRun-pData) <= nItems )
+                {
+                    if( *pRun == '\n' )
+                    {
+                        if( pRun-pLastLine > 1 )
+                        {
+                            aLines.push_back( ByteString( pLastLine, pRun - pLastLine ) );
+                            pLastLine = pRun+1;
+                        }
+                    }
+                    pRun++;
+                }
+            }
+#ifdef DEBUG
+            else
+                fprintf( stderr, "query of data failed with nFormat = %d, nType = %d, nItems = %d\n", nFormat, nType, nItems );
+#endif
+            XFree( pData );
+        }
+#ifdef DEBUG
+        else
+            fprintf( stderr, "query of bytes failed\n" );
+#endif
+    }
+
+    // nothing to do ?
+    if( aLines.begin() == aLines.end() )
+        return;
+    
+    StyleSettings aStyleSettings( rSettings.GetStyleSettings() );
+    MouseSettings aMouseSettings( rSettings.GetMouseSettings() );
+    KeyboardSettings aKeyboardSettings( rSettings.GetKeyboardSettings() );
+    
+    std::set< DtSetEnum > aItemSet;
+    
+    while( aLines.begin() != aLines.end() )
+    {
+        ByteString aLine( aLines.front() );
+        aLines.pop_front();
+        if( aLine.GetChar( aLine.Len()-1 ) == '\n' )
+            aLine.Erase( aLine.Len()-1 ); // cut newline
+
+        USHORT nPos = aLine.Search( '=' );
+        if( nPos == STRING_NOTFOUND )
+            continue;
+        
+        DtSetEnum aToken = (DtSetEnum)aLine.Copy( 0, nPos ).ToInt32();
+        aLine.Erase( 0, nPos+1 );
+        
+        if( aToken )
+        {
+            bRet = TRUE;
+            aItemSet.insert( aToken );
+        }
+        
+        switch( aToken )
+        {
+            case MouseOptions:			aMouseSettings.SetOptions( aLine.ToInt32() );break;
+            case DoubleClickTime:		aMouseSettings.SetDoubleClickTime( aLine.ToInt32() );break;
+            case DoubleClickWidth:		aMouseSettings.SetDoubleClickWidth( aLine.ToInt32() );break;
+            case DoubleClickHeight:		aMouseSettings.SetDoubleClickHeight( aLine.ToInt32() );break;
+            case StartDragWidth:		aMouseSettings.SetStartDragWidth( aLine.ToInt32() );break;
+            case StartDragHeight:		aMouseSettings.SetStartDragHeight( aLine.ToInt32() );break;
+            case DragMoveCode:			aMouseSettings.SetDragMoveCode( aLine.ToInt32() );break;
+            case DragCopyCode:			aMouseSettings.SetDragCopyCode( aLine.ToInt32() );break;
+            case DragLinkCode:			aMouseSettings.SetDragLinkCode( aLine.ToInt32() );break;
+            case ContextMenuCode:		aMouseSettings.SetContextMenuCode( aLine.ToInt32() );break;
+            case ContextMenuClicks:		aMouseSettings.SetContextMenuClicks( aLine.ToInt32() );break;
+            case ContextMenuDown:		aMouseSettings.SetContextMenuDown( aLine.ToInt32() );break;
+            case ScrollRepeat:			aMouseSettings.SetScrollRepeat( aLine.ToInt32() );break;
+            case ButtonStartRepeat:		aMouseSettings.SetButtonStartRepeat( aLine.ToInt32() );break;
+            case ButtonRepeat:			aMouseSettings.SetButtonRepeat( aLine.ToInt32() );break;
+            case ActionDelay:			aMouseSettings.SetActionDelay( aLine.ToInt32() );break;
+            case MenuDelay:				aMouseSettings.SetMenuDelay( aLine.ToInt32() );break;
+            case Follow:				aMouseSettings.SetFollow( aLine.ToInt32() );break;
+            case MiddleButtonAction:	aMouseSettings.SetMiddleButtonAction( aLine.ToInt32() );break;
+            case KeyboardOptions:		aKeyboardSettings.SetOptions( aLine.ToInt32() );break;
+            case StyleOptions:			aStyleSettings.SetOptions( aLine.ToInt32() );break;
+            case BorderSize:			aStyleSettings.SetBorderSize( aLine.ToInt32() );break;
+            case TitleHeight:			aStyleSettings.SetTitleHeight( aLine.ToInt32() );break;
+            case FloatTitleHeight:		aStyleSettings.SetFloatTitleHeight( aLine.ToInt32() );break;
+            case TearOffTitleHeight:	aStyleSettings.SetTearOffTitleHeight( aLine.ToInt32() );break;
+            case MenuBarHeight:			aStyleSettings.SetMenuBarHeight( aLine.ToInt32() );break;
+            case ScrollBarSize:			aStyleSettings.SetScrollBarSize( aLine.ToInt32() );break;
+            case SpinSize:				aStyleSettings.SetSpinSize( aLine.ToInt32() );break;
+            case SplitSize:				aStyleSettings.SetSplitSize( aLine.ToInt32() );break;
+            case IconHorzSpace:			aStyleSettings.SetIconHorzSpace( aLine.ToInt32() );break;
+            case IconVertSpace:			aStyleSettings.SetIconVertSpace( aLine.ToInt32() );break;
+            case CursorSize:			aStyleSettings.SetCursorSize( aLine.ToInt32() );break;
+            case CursorBlinkTime:		aStyleSettings.SetCursorBlinkTime( aLine.ToInt32() );break;
+            case ScreenZoom:			aStyleSettings.SetScreenZoom( aLine.ToInt32() );break;
+            case ScreenFontZoom:		aStyleSettings.SetScreenFontZoom( aLine.ToInt32() );break;
+            case LogoDisplayTime:		aStyleSettings.SetLogoDisplayTime( aLine.ToInt32() );break;
+            case DragFullOptions:		aStyleSettings.SetDragFullOptions( aLine.ToInt32() );break;
+            case AnimationOptions:		aStyleSettings.SetAnimationOptions( aLine.ToInt32() );break;
+            case SelectionOptions:		aStyleSettings.SetSelectionOptions( aLine.ToInt32() );break;
+            case DisplayOptions:		aStyleSettings.SetDisplayOptions( aLine.ToInt32() );break;
+            case AntialiasingMinPixelHeight: aStyleSettings.SetAntialiasingMinPixelHeight( aLine.ToInt32() );break;
+            case ThreeDColor:			aStyleSettings.Set3DColors( parseColor( aLine ) );break;
+            case FaceColor:				aStyleSettings.SetFaceColor( parseColor( aLine ) );break;
+            case CheckedColor:			aStyleSettings.SetCheckedColor( parseColor( aLine ) );break;
+            case LightColor:			aStyleSettings.SetLightColor( parseColor( aLine ) );break;
+            case LightBorderColor:		aStyleSettings.SetLightBorderColor( parseColor( aLine ) );break;
+            case ShadowColor:			aStyleSettings.SetShadowColor( parseColor( aLine ) );break;
+            case DarkShadowColor:		aStyleSettings.SetDarkShadowColor( parseColor( aLine ) );break;
+            case ButtonTextColor:		aStyleSettings.SetButtonTextColor( parseColor( aLine ) );break;
+            case RadioCheckTextColor:	aStyleSettings.SetRadioCheckTextColor( parseColor( aLine ) );break;
+            case GroupTextColor:		aStyleSettings.SetGroupTextColor( parseColor( aLine ) );break;
+            case LabelTextColor:		aStyleSettings.SetLabelTextColor( parseColor(aLine ) );break;
+            case InfoTextColor:			aStyleSettings.SetInfoTextColor( parseColor( aLine ) );break;
+            case WindowColor:			aStyleSettings.SetWindowColor( parseColor( aLine ) );break;
+            case WindowTextColor:		aStyleSettings.SetWindowTextColor( parseColor( aLine ) );break;
+            case DialogColor:			aStyleSettings.SetDialogColor( parseColor( aLine ) );break;
+            case DialogTextColor:		aStyleSettings.SetDialogTextColor( parseColor( aLine ) );break;
+            case WorkspaceColor:		aStyleSettings.SetWorkspaceColor( parseColor( aLine ) );break;
+            case FieldColor:			aStyleSettings.SetFieldColor( parseColor( aLine ) );break;
+            case FieldTextColor:		aStyleSettings.SetFieldTextColor( parseColor( aLine ) );break;
+            case ActiveColor:			aStyleSettings.SetActiveColor( parseColor( aLine ) );break;
+            case ActiveColor2:			aStyleSettings.SetActiveColor2( parseColor( aLine ) );break;
+            case ActiveTextColor:		aStyleSettings.SetActiveTextColor( parseColor( aLine ) );break;
+            case ActiveBorderColor:		aStyleSettings.SetActiveBorderColor( parseColor( aLine ) );break;
+            case DeactiveColor:			aStyleSettings.SetDeactiveColor( parseColor( aLine ) );break;
+            case DeactiveColor2:		aStyleSettings.SetDeactiveColor2( parseColor( aLine ) );break;
+            case DeactiveTextColor:		aStyleSettings.SetDeactiveTextColor( parseColor( aLine ) );break;
+            case DeactiveBorderColor:	aStyleSettings.SetDeactiveBorderColor( parseColor( aLine ) );break;
+            case HighlightColor:		aStyleSettings.SetHighlightColor( parseColor( aLine ) );break;
+            case HighlightTextColor:	aStyleSettings.SetHighlightTextColor( parseColor( aLine ) );break;
+            case DisableColor:			aStyleSettings.SetDisableColor( parseColor( aLine ) );break;
+            case HelpColor:				aStyleSettings.SetHelpColor( parseColor( aLine ) );break;
+            case HelpTextColor:			aStyleSettings.SetHelpTextColor( parseColor( aLine ) );break;
+            case MenuColor:				aStyleSettings.SetMenuColor( parseColor( aLine ) );break;
+            case MenuBarColor:			aStyleSettings.SetMenuBarColor( parseColor( aLine ) );break;
+            case MenuTextColor:			aStyleSettings.SetMenuTextColor( parseColor( aLine ) );break;
+            case MenuHighlightColor:	aStyleSettings.SetMenuHighlightColor( parseColor( aLine ) );break;
+            case MenuHighlightTextColor: aStyleSettings.SetMenuHighlightTextColor( parseColor( aLine ) );break;
+            case LinkColor:				aStyleSettings.SetLinkColor( parseColor( aLine ) );break;
+            case VisitedLinkColor:		aStyleSettings.SetVisitedLinkColor( parseColor( aLine ) );break;
+            case HighlightLinkColor:	aStyleSettings.SetHighlightLinkColor( parseColor( aLine ) );break;
+//            case HighContrastMode:		aStyleSettings.SetHighContrastMode( aLine.ToInt32() );break;
+            case AppFont:				aStyleSettings.SetAppFont( parseFont( aLine ) );break;
+            case HelpFont:				aStyleSettings.SetHelpFont( parseFont( aLine ) );break;
+            case TitleFont:				aStyleSettings.SetTitleFont( parseFont( aLine ) );break;
+            case FloatTitleFont:		aStyleSettings.SetFloatTitleFont( parseFont( aLine ) );break;
+            case MenuFont:				aStyleSettings.SetMenuFont( parseFont( aLine ) );break;
+            case ToolFont:				aStyleSettings.SetToolFont( parseFont( aLine ) );break;
+            case GroupFont:				aStyleSettings.SetGroupFont( parseFont( aLine ) );break;
+            case LabelFont:				aStyleSettings.SetLabelFont( parseFont( aLine ) );break;
+            case InfoFont:				aStyleSettings.SetInfoFont( parseFont( aLine ) );break;
+            case RadioCheckFont:		aStyleSettings.SetRadioCheckFont( parseFont( aLine ) );break;
+            case PushButtonFont:		aStyleSettings.SetPushButtonFont( parseFont( aLine ) );break;
+            case FieldFont:				aStyleSettings.SetFieldFont( parseFont( aLine ) );break;
+            case IconFont:				aStyleSettings.SetIconFont( parseFont( aLine ) );break;
+            case RadioButtonStyle:		aStyleSettings.SetRadioButtonStyle( aLine.ToInt32() );break;
+            case CheckBoxStyle:			aStyleSettings.SetCheckBoxStyle( aLine.ToInt32() );break;
+            case PushButtonStyle:		aStyleSettings.SetPushButtonStyle( aLine.ToInt32() );break;
+            case TabControlStyle:		aStyleSettings.SetTabControlStyle( aLine.ToInt32() );
+                break;
+                
+            case AllTextColors:
+            {
+                Color aTextColor = parseColor( aLine );
+                aStyleSettings.SetDialogTextColor( aTextColor );
+                aStyleSettings.SetMenuTextColor( aTextColor );
+                aStyleSettings.SetButtonTextColor( aTextColor );
+                aStyleSettings.SetRadioCheckTextColor( aTextColor );
+                aStyleSettings.SetGroupTextColor( aTextColor );
+                aStyleSettings.SetLabelTextColor( aTextColor );
+                aStyleSettings.SetInfoTextColor( aTextColor );
+                aStyleSettings.SetWindowTextColor( aTextColor );
+                aStyleSettings.SetFieldTextColor( aTextColor );
+            }
+            break;
+            case AllBackColors:
+            {
+                Color aBack = parseColor( aLine );
+                aStyleSettings.Set3DColors( aBack );
+                aStyleSettings.SetFaceColor( aBack );
+                aStyleSettings.SetDialogColor( aBack );
+                aStyleSettings.SetMenuColor( aBack );
+                aStyleSettings.SetMenuBarColor( aBack );
+                aStyleSettings.SetWindowColor( aBack );
+                aStyleSettings.SetFieldColor( aBack );
+                if( aBack == COL_LIGHTGRAY )
+                    aStyleSettings.SetCheckedColor( Color( 0xCC, 0xCC, 0xCC ) );
+                else
+                {
+                    Color aColor2 = aStyleSettings.GetLightColor();
+                    aStyleSettings.
+                        SetCheckedColor( Color(
+                                               (BYTE)(((USHORT)aBack.GetRed()+(USHORT)aColor2.GetRed())/2),
+                                               (BYTE)(((USHORT)aBack.GetGreen()+(USHORT)aColor2.GetGreen())/2),
+                                               (BYTE)(((USHORT)aBack.GetBlue()+(USHORT)aColor2.GetBlue())/2)
+                                               ) );
+                }
+            }
+            break;
+	case UIFont: {
+	      Font aFont = parseFont( aLine );
+	      aStyleSettings.SetAppFont( aFont );
+	      aStyleSettings.SetHelpFont( aFont );
+	      aStyleSettings.SetMenuFont( aFont );
+	      aStyleSettings.SetToolFont( aFont );
+	      aStyleSettings.SetLabelFont( aFont );
+	      aStyleSettings.SetInfoFont( aFont );
+	      aStyleSettings.SetRadioCheckFont( aFont );
+	      aStyleSettings.SetPushButtonFont( aFont );
+	      aStyleSettings.SetFieldFont( aFont );
+	      aStyleSettings.SetIconFont( aFont );
+	      aStyleSettings.SetGroupFont( aFont );
+	      break;
+	}
+#ifdef DEBUG    
+	default:
+	  fprintf( stderr, "don't understand \"%d=%s\"\n", aToken, aLine.GetBuffer() );
+	  break;
+#endif  
+        }
+    }
+    if( bRet )
+    {
+        rSettings.SetKeyboardSettings( aKeyboardSettings );
+        rSettings.SetMouseSettings( aMouseSettings );
+        rSettings.SetStyleSettings( aStyleSettings );
+    }
 }
--- vcl/source/gdi/outdev3.cxx	Fri May 24 09:10:47 2002
+++ vcl/source/gdi/outdev3.cxx	Wed Jan 15 22:15:52 2003
@@ -7666,45 +7675,35 @@
         }
     }
 
+    Color aOldTextColor;
+    Color aOldTextFillColor;
+    BOOL  bRestoreFillColor;
+
+    bRestoreFillColor = FALSE;
+
     if ( nStyle & TEXT_DRAW_DISABLE )
     {
-        Color aOldTextColor;
-        Color aOldTextFillColor;
-        BOOL  bRestoreFillColor;
         aOldTextColor = GetTextColor();
         if ( IsTextFillColor() )
         {
             bRestoreFillColor = TRUE;
             aOldTextFillColor = GetTextFillColor();
         }
-        else
-            bRestoreFillColor = FALSE;
-        SetTextColor( GetSettings().GetStyleSettings().GetLightColor() );
-        DrawText( Point( rPos.X()+1, rPos.Y()+1 ), aStr, nIndex, nLen );
-        if ( !(GetSettings().GetStyleSettings().GetOptions() & STYLE_OPTION_NOMNEMONICS) )
-        {
-            if ( nMnemonicPos != STRING_NOTFOUND )
-                ImplDrawMnemonicLine( nMnemonicX+1, nMnemonicY+1, cMnemonic );
-        }
-        SetTextColor( GetSettings().GetStyleSettings().GetShadowColor() );
-        DrawText( rPos, aStr, nIndex, nLen );
-        if ( !(GetSettings().GetStyleSettings().GetOptions() & STYLE_OPTION_NOMNEMONICS) )
-        {
-            if ( nMnemonicPos != STRING_NOTFOUND )
-                ImplDrawMnemonicLine( nMnemonicX, nMnemonicY, cMnemonic );
-        }
-        SetTextColor( aOldTextColor );
-        if ( bRestoreFillColor )
-            SetTextFillColor( aOldTextFillColor );
+        SetTextColor( GetSettings().GetStyleSettings().GetDisableColor () );
     }
-    else
+
+    DrawText( rPos, aStr, nIndex, nLen );
+    if ( !(GetSettings().GetStyleSettings().GetOptions() & STYLE_OPTION_NOMNEMONICS) )
     {
-        DrawText( rPos, aStr, nIndex, nLen );
-        if ( !(GetSettings().GetStyleSettings().GetOptions() & STYLE_OPTION_NOMNEMONICS) )
-        {
-            if ( nMnemonicPos != STRING_NOTFOUND )
-                ImplDrawMnemonicLine( nMnemonicX, nMnemonicY, cMnemonic );
-        }
+	if ( nMnemonicPos != STRING_NOTFOUND )
+	    ImplDrawMnemonicLine( nMnemonicX, nMnemonicY, cMnemonic );
+    }
+
+    if ( nStyle & TEXT_DRAW_DISABLE )
+    {
+	SetTextColor( aOldTextColor );
+	if ( bRestoreFillColor )
+	    SetTextFillColor( aOldTextFillColor );
     }
 }
 
