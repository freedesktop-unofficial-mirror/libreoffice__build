Index: tools/source/fsys/makefile.mk
===================================================================
RCS file: /cvs/util/tools/tools/source/fsys/makefile.mk,v
retrieving revision 1.3
diff -u -r1.3 makefile.mk
--- tools/source/fsys/makefile.mk	11 Oct 2001 11:17:18 -0000	1.3
+++ tools/source/fsys/makefile.mk	11 Nov 2002 18:16:47 -0000
@@ -94,6 +94,8 @@
             $(OBJ)$/urlobj.obj
 .ENDIF
 
+CFLAGS+=`pkg-config --cflags gnome-vfs-2.0`
+
 # --- Targets ------------------------------------------------------
 
 .INCLUDE :  target.mk

--- tools/bootstrp/static.mk  2001/10/16 14:21:13     1.14
+++ tools/bootstrp/static.mk  2002/10/28 14:54:45
@@ -155,7 +155,7 @@
 STATIC_LIBS            += -lnsl -lsocket -lposix4 -lc
 .ENDIF
 .IF "$(OS)"=="LINUX"
-STATIC_LIBS            += -lsupc++     -lX11 -lXext 
+STATIC_LIBS            += -lsupc++     -lX11 -lXext `pkg-config --libs gnome-vfs-2.0`
 .ENDIF

 # -----------------------------------------------------------

Index: tools/util/makefile.mk
===================================================================
RCS file: /cvs/oo/util/tools/util/makefile.mk,v
retrieving revision 1.7.8.1
diff -u -p -u -r1.7.8.1 makefile.mk
--- tools/util/makefile.mk	30 May 2002 13:56:14 -0000	1.7.8.1
+++ tools/util/makefile.mk	15 Apr 2003 17:53:02 -0000
@@ -197,6 +197,10 @@ SHL1STDLIBS+=   $(SALLIB) $(VOSLIB)
 .IF "$(OS)$(CPU)$(PRODUCT)"=="SOLARISSfull"
 SHL1VERSIONMAP=libtl641ss.so.mapfile
 .ENDIF
+.IF "$(GUI)"=="UNX"
+SHL1STDLIBS+=`pkg-config --libs gnome-vfs-2.0`
+.ENDIF
+
 
 .IF "$(GUI)"=="WNT"
 SHL1STDLIBS+=   shell32.lib     \
Index: tools/source/fsys/urlobj.cxx
===================================================================
RCS file: /cvs/oo/util/tools/source/fsys/urlobj.cxx,v
retrieving revision 1.29.2.1
diff -u -p -u -r1.29.2.1 urlobj.cxx
--- tools/source/fsys/urlobj.cxx	30 May 2002 13:56:12 -0000	1.29.2.1
+++ tools/source/fsys/urlobj.cxx	28 Apr 2003 14:47:35 -0000
@@ -107,6 +107,43 @@
 #define INCLUDED_LIMITS
 #endif
 
+#ifndef _VOS_MUTEX_HXX
+#include <vos/mutex.hxx>
+#endif
+
+#include <stdio.h>
+#include <signal.h>
+
+#include <libgnomevfs/gnome-vfs.h>
+
+#undef USE_GNOME_VFS_2_2
+
+#ifdef USE_GNOME_VFS_2_2
+extern "C" {
+  GList *_gnome_vfs_configuration_get_methods_list (void);
+}
+#endif
+
+static GList *
+get_methods_list (void)
+{
+#ifdef USE_GNOME_VFS_2_2
+  return _gnome_vfs_configuration_get_methods_list ();
+#else
+  /* This sucks utterly */
+  const char *methods[] = {
+    "smb", "pipe", "ssh", "nntp", "gnome-help", "preferences",
+    "applications", "favorites", "cdda", "system", "nfs", "camera"
+// "mailfs", "hp8", "patchfs" - broken extfs stuff ...
+  };
+  int i;
+  GList *ret = NULL;
+  for (i = 0; i < G_N_ELEMENTS (methods); i++)
+    ret = g_list_prepend (ret, (void *) methods [i]);
+  return ret;
+#endif
+}
+
 namespace unnamed_tools_urlobj {} using namespace unnamed_tools_urlobj;
 	// unnamed namespaces don't work well yet...
 
@@ -390,6 +427,8 @@ struct INetURLObject::PrefixInfo
 //============================================================================
 // static
 
+static INetURLObject::SchemeInfo *vfs_schemeinfo_map = NULL;
+
 static INetURLObject::SchemeInfo const aSchemeInfoMap[INET_PROT_END]
 	= { { "", "", 0, false, false, false, false, false, false, false,
 		  false },
@@ -449,12 +488,16 @@ static INetURLObject::SchemeInfo const a
           false, false, false, false, false, false },
 
 		{ "vnd.sun.star.odma", "vnd.sun.star.odma:", 0, false, false, false, 
-		  false, false, false, true, false }}; 
+		  false, false, false, true, false }
+}; 
 
 inline INetURLObject::SchemeInfo const &
 INetURLObject::getSchemeInfo(INetProtocol eTheScheme)
 {
-	return aSchemeInfoMap[eTheScheme];
+  if (eTheScheme >= INET_PROT_END)
+    return vfs_schemeinfo_map [eTheScheme - INET_PROT_END];
+  else
+    return aSchemeInfoMap[eTheScheme];
 };
 
 //============================================================================
@@ -714,15 +757,21 @@ bool INetURLObject::setAbsURIRef(UniStri
 	// Parse <scheme>:
 	sal_Unicode const * p = pPos;
 	PrefixInfo const * pPrefix = getPrefix(p, pEnd);
+	::rtl::OString tmpStr (rTheAbsURIRef.GetBuffer (),
+			       rTheAbsURIRef.Len (),
+			       RTL_TEXTENCODING_UTF8);
+
+	//	fprintf (stderr, "setAbsURIRef '%s' %d\n", tmpStr.getStr(),
+	//		 (int) (pPrefix ? pPrefix->m_eScheme : -17));
 	if (pPrefix)
 	{
 		pPos = p;
 		m_eScheme = pPrefix->m_eScheme;
 		aSynAbsURIRef
 			= UniString::CreateFromAscii(pPrefix->m_eKind
-										         >= PrefixInfo::EXTERNAL ?
-										     pPrefix->m_pTranslatedPrefix :
-										     pPrefix->m_pPrefix);
+						     >= PrefixInfo::EXTERNAL ?
+						     pPrefix->m_pTranslatedPrefix :
+						     pPrefix->m_pPrefix);
 	}
 	else
 	{
@@ -865,6 +914,8 @@ bool INetURLObject::setAbsURIRef(UniStri
 		sal_Unicode const * pHostPortBegin = 0;
 		sal_Unicode const * pHostPortEnd = 0;
 
+//		fprintf (stderr, "Got Authority\n");
+
 		switch (m_eScheme)
 		{
 			case INET_PROT_VND_SUN_STAR_HELP:
@@ -1139,6 +1190,7 @@ bool INetURLObject::setAbsURIRef(UniStri
 					pPos += 2;
 				else if (!bSmart)
 				{
+//			  fprintf (stderr, "not smart\n");
 					setInvalid();
 					return false;
 				}
@@ -1180,6 +1232,7 @@ bool INetURLObject::setAbsURIRef(UniStri
 				}
 				else if (pPos != pAuthority)
 				{
+//			  fprintf (stderr, "bogus auth\n");
 					setInvalid();
 					return false;
 				}
@@ -1259,6 +1312,7 @@ bool INetURLObject::setAbsURIRef(UniStri
 													 eEscapeType);
 						if (!INetMIME::isIMAPAtomChar(nUTF32))
 						{
+//			  fprintf (stderr, "bogus char\n");
 							setInvalid();
 							return false;
 						}
@@ -1296,14 +1350,17 @@ bool INetURLObject::setAbsURIRef(UniStri
 				case INET_PROT_LDAP:
 					if (pHostPortBegin == pPort && pPort != pHostPortEnd)
 					{
+//			  fprintf (stderr, "bogus port 0\n");
 						setInvalid();
 						return false;
 					}
 					break;
 
 				default:
-					if (pHostPortBegin == pPort)
+				        if (m_eScheme < INET_PROT_END && /* else might have a port */
+					    pHostPortBegin == pPort)
 					{
+//			  fprintf (stderr, "bogus port\n");
 						setInvalid();
 						return false;
 					}
@@ -1315,6 +1372,7 @@ bool INetURLObject::setAbsURIRef(UniStri
 							   eCharset, aSynHost)
 					|| pHostPortBegin != pPort))
 			{
+//			  fprintf (stderr, "bogus host\n");
 				setInvalid();
 				return false;
 			}
@@ -1329,6 +1387,10 @@ bool INetURLObject::setAbsURIRef(UniStri
 		}
 	}
 
+//	::rtl::OString tmpStrPP (pPos, pEnd - pPos,
+//				 RTL_TEXTENCODING_UTF8);
+//	fprintf (stderr, "Pre path parse '%s'\n", tmpStrPP.getStr());
+
 	// Parse <path>
 	UniString aSynPath;
 	if (!parsePath(&pPos, pEnd, bOctets, eMechanism, eCharset,
@@ -1337,6 +1399,7 @@ bool INetURLObject::setAbsURIRef(UniStri
 				   getSchemeInfo().m_bQuery ? '?' : 0x80000000,
 				   nFragmentDelimiter, &aSynPath))
 	{
+//	  fprintf (stderr, "Invalid path\n");
 		setInvalid();
 		return false;
 	}
@@ -1376,12 +1439,20 @@ bool INetURLObject::setAbsURIRef(UniStri
 
 	if (pPos != pEnd)
 	{
+//	  ::rtl::OString tmpStrZ (pPos, pEnd - pPos,
+//				 RTL_TEXTENCODING_UTF8);
+//	  fprintf (stderr, "Invalid fragment '%s'\n", tmpStrZ.getStr());
 		setInvalid();
 		return false;
 	}
 
 	m_aAbsURIRef = aSynAbsURIRef;
 
+//	::rtl::OString tmpStr2 (aSynAbsURIRef.GetBuffer (),
+//				aSynAbsURIRef.Len (),
+//				RTL_TEXTENCODING_UTF8);
+//	fprintf (stderr, "setAbsURIRef result '%s'\n", tmpStr2.getStr());
+
 	return true;
 }
 
@@ -1391,13 +1462,13 @@ INetURLObject INetURLObject::m_aBaseURIR
 
 //============================================================================
 bool INetURLObject::convertRelToAbs(UniString const & rTheRelURIRef,
-									bool bOctets,
-									INetURLObject & rTheAbsURIRef,
-									bool & rWasAbsolute,
-									EncodeMechanism eMechanism,
-									rtl_TextEncoding eCharset,
-									bool bIgnoreFragment, bool bSmart,
-									bool bRelativeNonURIs, FSysStyle eStyle)
+				    bool bOctets,
+				    INetURLObject & rTheAbsURIRef,
+				    bool & rWasAbsolute,
+				    EncodeMechanism eMechanism,
+				    rtl_TextEncoding eCharset,
+				    bool bIgnoreFragment, bool bSmart,
+				    bool bRelativeNonURIs, FSysStyle eStyle)
 	const
 {
 	sal_Unicode const * p = rTheRelURIRef.GetBuffer();
@@ -1412,6 +1483,11 @@ bool INetURLObject::convertRelToAbs(UniS
 	sal_uInt32 nFragmentDelimiter = '#';
 	Part ePart = PART_VISIBLE;
 
+//	if (pPrefix)
+//	  fprintf (stderr, "Got pPrefix\n");
+//	else
+//	  fprintf (stderr, "No pPrefix\n");
+
 	if (!pPrefix && bSmart)
 	{
 		// If the input matches any of the following productions (for which
@@ -1514,9 +1590,12 @@ bool INetURLObject::convertRelToAbs(UniS
 	// Fast solution for non-relative URIs:
 	if (pPrefix)
 	{
+//		fprintf (stderr, "Fast pPrefix path\n");
+
 		INetURLObject aNewURI(rTheRelURIRef, eMechanism, eCharset);
 		if (aNewURI.HasError())
 		{
+//		  fprintf (stderr, "Had error!\n");
 			rWasAbsolute = false;
 			return false;
 		}
@@ -1524,14 +1603,22 @@ bool INetURLObject::convertRelToAbs(UniS
 		if (bIgnoreFragment)
 			aNewURI.clearFragment();
 		rTheAbsURIRef = aNewURI;
+
+//		::rtl::OString tmpStr2 (m_aAbsURIRef.GetBuffer (),
+//					m_aAbsURIRef.Len (),
+//					RTL_TEXTENCODING_UTF8);
+//		fprintf (stderr, "Hard set to '%s' \n", tmpStr2.getStr());
+
 		return true;
 	}
 
+//	fprintf (stderr, "Slow non pPrefix path\n");
+
 	enum State { STATE_AUTH, STATE_ABS_PATH, STATE_REL_PATH, STATE_FRAGMENT,
 				 STATE_DONE };
 
 	UniString aSynAbsURIRef(UniString::CreateFromAscii(getSchemeInfo().
-													       m_pScheme));
+							   m_pScheme));
 	aSynAbsURIRef += ':';
 
 	sal_Char cEscapePrefix = getEscapePrefix();
@@ -2050,13 +2137,95 @@ INetURLObject::getPrefix(sal_Unicode con
 			{ "vnd.sun.star.wfs:", 0, INET_PROT_VND_SUN_STAR_WFS,
 			  PrefixInfo::OFFICIAL },
 			{ "wfs:", "vnd.sun.star.wfs:", INET_PROT_VND_SUN_STAR_WFS,
-			  PrefixInfo::ALIAS } };
-	PrefixInfo const * pFirst = aMap + 1;
-	PrefixInfo const * pLast = aMap + sizeof aMap / sizeof (PrefixInfo) - 1;
-	PrefixInfo const * pMatch = 0;
-	sal_Unicode const * pMatched = rBegin;
-	sal_Unicode const * p = rBegin;
-	xub_StrLen i = 0;
+			  PrefixInfo::ALIAS }
+		};
+
+	static GHashTable *fast_lookup = NULL;
+	int i;
+
+	if (!fast_lookup) {
+		::osl::MutexGuard aGuard( ::osl::Mutex::getGlobalMutex() );
+		if (!fast_lookup) {
+			// FIXME: This code should be re-factored, but C++ is
+			// broken by design for re-factoring.
+			GList *methods, *l;
+
+			fast_lookup = g_hash_table_new (g_str_hash, g_str_equal);
+	  
+			for (i = 1; i < G_N_ELEMENTS (aMap); i++) {
+				g_hash_table_insert (fast_lookup, (void *) aMap[i].m_pPrefix,
+						     (void *) (aMap + i));
+			}
+
+			methods = get_methods_list ();
+			vfs_schemeinfo_map = g_new0 (INetURLObject::SchemeInfo, g_list_length (methods));
+
+			i = INET_PROT_END;
+			for (l = methods; l; l = l->next) {
+				PrefixInfo *pi;
+				INetURLObject::SchemeInfo *si;
+				char *name;
+
+				name = g_strconcat ((gchar *) l->data, ":", NULL);
+
+				//	    g_warning ("AddV '%s'", name);
+				if (g_hash_table_lookup (fast_lookup, name)) {
+					fprintf (stderr, "Discarding URI scheme '%s'", name);
+					g_free (name);
+					continue;
+				}
+
+				pi = new PrefixInfo;
+
+				pi->m_pPrefix = (sal_Char *) name;
+				pi->m_pTranslatedPrefix = NULL;
+				pi->m_eScheme = (INetProtocol) i;
+				pi->m_eKind = PrefixInfo::OFFICIAL;
+
+				si = &vfs_schemeinfo_map [i - INET_PROT_END];
+
+				si->m_pScheme = (sal_Char *) l->data;
+				si->m_pPrefix = g_strconcat (name, "//", NULL); // what a waste
+
+				// FIXME: these are just wrong, set all to true ?
+				si->m_nDefaultPort = 0;
+				si->m_bAuthority = true;
+				si->m_bUser = false;
+				si->m_bAuth = false;
+				si->m_bPassword = false;
+				si->m_bHost = true;
+				si->m_bPort = false;
+				si->m_bHierarchical = true;
+				si->m_bQuery = false;
+
+				g_hash_table_insert (fast_lookup, (void *) pi->m_pPrefix, (void *) pi);
+				i++;
+			}
+		}
+
+		// FIXME: add write barrier when this reaches OOO_STABLE_1
+	}
+
+	char *rstr;
+
+	rstr = (char *) g_alloca (pEnd - rBegin + 2);
+	for (i = 0; i < pEnd - rBegin && rBegin [i] != ':'; i++)
+	  rstr[i] = INetMIME::toLowerCase (rBegin [i]);
+	if (i >= pEnd - rBegin) return NULL;
+	rstr [i++] = ':'; rstr [i] = '\0';
+
+	const PrefixInfo *pi;
+
+	pi = (PrefixInfo *) g_hash_table_lookup (fast_lookup, rstr);
+
+//	g_warning ("Lookup '%s' -> %d", rstr, (int) (pi ? pi->m_eScheme : -17));
+
+	if (pi)
+	  rBegin += i;
+
+	return pi;
+
+#ifdef OVER_COMPLICATED_CODE
 	for (; pFirst < pLast; ++i)
 	{
 		if (pFirst->m_pPrefix[i] == '\0')
@@ -2088,7 +2257,9 @@ INetURLObject::getPrefix(sal_Unicode con
 		}
 	}
 	rBegin = pMatched;
+
 	return pMatch;
+#endif
 }
 
 //============================================================================
@@ -2267,7 +2438,7 @@ bool INetURLObject::setHost(UniString co
 			break;
 
 		default:
-			if (aSynHost.Len() == 0)
+			if (aSynHost.Len() == 0 && m_eScheme < INET_PROT_END)
 				return false;
 			break;
 	}
@@ -2355,6 +2526,7 @@ bool INetURLObject::parsePath(sal_Unicod
 				aTheSynPath = '/';
 			break;
 
+		default: /* All INET_PROT_END+ drop through here */
 		case INET_PROT_FILE:
 		case INET_PROT_VND_SUN_STAR_WFS:
 		{
@@ -3687,7 +3859,8 @@ bool INetURLObject::ConcatData(INetProto
 					break;
 
 				default:
-					if (aSynHost.Len() == 0)
+					if (aSynHost.Len() == 0 &&
+					    m_eScheme < INET_PROT_END) /* valid perhaps */
 					{
 						setInvalid();
 						return false;
@@ -3738,7 +3911,8 @@ bool INetURLObject::ConcatData(INetProto
 	m_aPath.set(m_aAbsURIRef,
 				encodeText(aSynPath, false,
 						   m_eScheme == INET_PROT_FILE
-						   || m_eScheme == INET_PROT_VND_SUN_STAR_WFS ?
+						   || m_eScheme == INET_PROT_VND_SUN_STAR_WFS
+					   || m_eScheme >= INET_PROT_END ?
 							   PART_PATH_SEGMENTS_EXTRA :
 						   m_eScheme == INET_PROT_NEWS
 						   || m_eScheme == INET_PROT_POP3 ?
