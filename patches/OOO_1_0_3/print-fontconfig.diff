Index: psprint/util/makefile.mk
===================================================================
RCS file: /cvs/gsl/psprint/util/makefile.mk,v
retrieving revision 1.4.10.1
diff -u -p -u -r1.4.10.1 makefile.mk
--- psprint/util/makefile.mk	20 Aug 2002 15:19:46 -0000	1.4.10.1
+++ psprint/util/makefile.mk	28 Feb 2003 15:50:18 -0000
@@ -92,7 +92,7 @@ SHL1STDLIBS=$(UNOTOOLSLIB)		\
 			$(CPPUHELPERLIB)	\
 			$(CPPULIB)			\
 			$(SALLIB)			\
-			-lX11
+			-lX11 `pkg-config --libs fontconfig`
 
 SHL1DEF=	$(MISC)$/$(SHL1TARGET).def
 
Index: psprint/source/fontmanager/makefile.mk
===================================================================
RCS file: /cvs/oo/gsl/psprint/source/fontmanager/makefile.mk,v
retrieving revision 1.4
diff -u -p -u -r1.4 makefile.mk
--- psprint/source/fontmanager/makefile.mk	20 Aug 2002 15:00:13 -0000	1.4
+++ psprint/source/fontmanager/makefile.mk	10 Mar 2003 17:10:07 -0000
@@ -75,13 +75,14 @@ ENVCFLAGS+= -I..$/fontsubset
 # --- Files --------------------------------------------------------
 
 SLOFILES=\
-	$(SLO)$/fontmanager.obj		\
+	$(SLO)$/fcfontmanager.obj		\
 	$(SLO)$/fontcache.obj		\
 	$(SLO)$/parseAFM.obj
 
 .IF "$(OS)$(CPU)"=="SOLARISI"
 NOOPTFILES=$(SLO)$/fontmanager.obj
 .ENDIF
+CFLAGS+=`pkg-config --cflags fontconfig` -Wall
 
 # --- Targets ------------------------------------------------------
 
Index: psprint/inc/psprint/fontmanager.hxx
===================================================================
RCS file: /cvs/oo/gsl/psprint/inc/psprint/fontmanager.hxx,v
retrieving revision 1.11
diff -u -p -u -r1.11 fontmanager.hxx
--- psprint/inc/psprint/fontmanager.hxx	28 Feb 2002 11:49:51 -0000	1.11
+++ psprint/inc/psprint/fontmanager.hxx	10 Mar 2003 17:10:32 -0000
@@ -78,6 +78,16 @@
 #define ATOM_FAMILYNAME                     2
 #define ATOM_PSNAME                         3
 
+#define FONTCONFIG_FONTS
+
+#ifdef FONTCONFIG_FONTS
+/* C++ sucks great big, huge, ugly, smelly rocks */
+extern "C" {
+  struct _FcFontSet;
+  struct _FcPattern;
+};
+#endif
+
 /*
  *  some words on metrics: every length returned by PrintFontManager and
  *  friends are PostScript afm style, that is they are 1/1000 font height
@@ -290,7 +300,9 @@ class PrintFontManager
         int                 m_nDirectory;       // atom containing system dependent path
         ::rtl::OString      m_aFontFile;        // relative to directory
         ::rtl::OString      m_aMetricFile;      // dito
+#ifndef FONTCONFIG_FONTS
         ::rtl::OString      m_aXLFD;            // mainly for administration, contains the XLFD from fonts.dir
+#endif
 
         /* note: m_aFontFile and Metric file are not atoms
            because they should be fairly unique */
@@ -304,7 +316,9 @@ class PrintFontManager
     {
         int					    m_nDirectory;       // atom containing system dependent path
         ::rtl::OString          m_aFontFile;        // relative to directory
+#ifndef FONTCONFIG_FONTS
         ::rtl::OString          m_aXLFD;            // mainly for administration, contains the XLFD from fonts.dir
+#endif
         int                     m_nCollectionEntry; // -1 for regular fonts, 0 to ... for fonts stemming from collections
         unsigned int           m_nTypeFlags;		// from TrueType file; only known use is for copyright flags
 
@@ -329,12 +343,13 @@ class PrintFontManager
     ::std::hash_map< fontID, PrintFont* >       m_aFonts;
     ::std::hash_map< int, family::type >        m_aFamilyTypes;
     ::std::list< ::rtl::OUString >              m_aPrinterDrivers;
+#ifndef FONTCONFIG_FONTS
     ::std::list< ::rtl::OString >               m_aFontDirectories;
-    ::std::list< int >							m_aPrivateFontDirectories;
-    ::utl::MultiAtomProvider*                   m_pAtoms;
+    ::std::list< int >                          m_aPrivateFontDirectories;
     // for speeding up findFontFileID
-    ::std::hash_map< ::rtl::OString, ::std::set< fontID >, ::rtl::OStringHash >
-    											m_aFontFileToFontID;
+    ::std::hash_map< ::rtl::OString, ::std::set< fontID >, ::rtl::OStringHash > m_aFontFileToFontID;
+#endif
+    ::utl::MultiAtomProvider*                   m_pAtoms;
 
     ::std::hash_map< ::rtl::OString, int, ::rtl::OStringHash >
     m_aDirToAtom;
@@ -354,15 +369,36 @@ class PrintFontManager
     ::rtl::OString getAfmFile( PrintFont* pFont ) const;
     ::rtl::OString getFontFile( PrintFont* pFont ) const;
 
+#ifndef FONTCONFIG_FONTS
     void getFontAttributesFromXLFD( PrintFont* pFont, const ByteString& rXLFD ) const;
-
+    // finds the FIRST id for this font file; there may be more
+    // for TrueType collections
+    fontID findFontFileID( int nDirID, const ::rtl::OString& rFile ) const;
     bool analyzeFontFile( int nDirID, const ::rtl::OString& rFileName, bool bReadFile, const ::std::list< ::rtl::OString >& rXLFDs, ::std::list< PrintFont* >& rNewFonts ) const;
+#else
+    void getFontAttributesFromFcPattern( PrintFont* pFont, const struct _FcPattern *fc_font ) const;
+    void addFcSystemFont    (struct _FcPattern *fc_pattern);
+    void addFcSystemFontSet (struct _FcFontSet *fc_set);
+    int  addFontFile( const ::rtl::OString& rFilePath, const struct _FcPattern *fc_font, bool bMergeBuiltin );
+#endif
+
     ::rtl::OUString convertTrueTypeName( void* pNameRecord ) const; // actually a NameRecord* formt font subsetting code
     void analyzeTrueTypeFamilyName( void* pTTFont, ::std::list< ::rtl::OUString >& rnames ) const; // actually a TrueTypeFont* from font subsetting code
     bool analyzeTrueTypeFile( PrintFont* pFont ) const;
-    // finds the FIRST id for this font file; there may be more
-    // for TrueType collections
-    fontID findFontFileID( int nDirID, const ::rtl::OString& rFile ) const;
+
+#ifdef FONTCONFIG_FONTS
+    void ensureAnalysed( PrintFont* pFont ) const
+    {
+      if ( pFont && pFont->m_nAscend == 0 && pFont->m_nDescend == 0 )
+	{
+	  if (pFont->m_eType == fonttype::TrueType )
+	    analyzeTrueTypeFile( pFont );
+	  else if (pFont->m_eType == fonttype::Type1 )
+            pFont->readAfmMetrics( getAfmFile( pFont ), m_pAtoms );
+	}
+    }
+#endif
+
     fontID findFontBuiltinID( int nPSNameAtom ) const;
 
     family::type matchFamilyName( const ::rtl::OUString& rFamily ) const;
@@ -373,22 +409,21 @@ class PrintFontManager
         it = m_aFonts.find( nID );
         return it == m_aFonts.end() ? NULL : it->second;
     }
+#ifndef FONTCONFIG_FONTS
     ByteString getXLFD( PrintFont* pFont ) const;
+    void getServerDirectories(); // get font server directories on e.g. redhat
+#endif
     void fillPrintFontInfo( PrintFont* pFont, FastPrintFontInfo& rInfo ) const;
     void fillPrintFontInfo( PrintFont* pFont, PrintFontInfo& rInfo ) const;
 
     const ::rtl::OString& getDirectory( int nAtom ) const;
     int getDirectoryAtom( const ::rtl::OString& rDirectory, bool bCreate = false );
 
-    void getServerDirectories(); // get font server directories on e.g. redhat
-
     PrintFontManager();
     ~PrintFontManager();
 public:
     static PrintFontManager& get(); // one instance only
 
-    int addFontFile( const ::rtl::OString& rFileName, int nFaceNum ); 
-
     // initialize takes an X Display*
     // if NULL then an XOpendDisplay( NULL ) is performed
     // the Display connection is used to get the font path
@@ -500,11 +535,13 @@ public:
     void hasVerticalSubstitutions( fontID nFontID, const sal_Unicode* pCharacters,
         int nCharacters, bool* pHasSubst ) const;
 
+#ifndef FONTCONFIG_FONTS
     // get the XLFD for a font that originated from the X fontpath
     // note: this may not be the original line that was in the fonts.dir
     // returns a string for every font, but only TrueType and Type1
     // fonts originated from the X font path, so check for the font type
     ::rtl::OUString getFontXLFD( fontID nFontID ) const;
+#endif
 
     // get a specific fonts metrics
 
@@ -564,26 +601,33 @@ public:
         virtual bool isCanceled() = 0;
     };
 
+#ifndef FONTCONFIG_FONTS
+    int addFontFile( const ::rtl::OString& rFileName, int nFaceNum ); 
+
     // checks wether font import would fail due to no writeable directory
     bool checkImportPossible() const;
+
     // expects system paths not UNC paths
     // returns the number of fonts successfully imported
     int importFonts( const ::std::list< ::rtl::OString >& rFiles, bool bLinkOnly = false, ImportFontCallback* pCallback = NULL );
 
+    // get properties of a not imported font file
+    bool getImportableFontProperties( const ::rtl::OString& rFile, ::std::list< FastPrintFontInfo >& rFontProps );
+
+    bool isPrivateFontFile( fontID ) const;
+
     // check wether changeFontProperties would fail due to not writable fonts.dir
     bool checkChangeFontPropertiesPossible( fontID nFont ) const;
     // change fonts.dir entry for font
     bool changeFontProperties( fontID nFont, const ::rtl::OUString& rXLFD );
-
-    // get properties of a not imported font file
-    bool getImportableFontProperties( const ::rtl::OString& rFile, ::std::list< FastPrintFontInfo >& rFontProps );
+    // remove font files
+    bool removeFonts( const ::std::list< fontID >& rFonts );
 
     // get fonts that come from the same font file
     bool getFileDuplicates( fontID nFont, ::std::list< fontID >& rFonts ) const;
-    // remove font files
-    bool removeFonts( const ::std::list< fontID >& rFonts );
+#endif
+
 
-    bool isPrivateFontFile( fontID ) const;
 
     // returns false if there were not any
     bool getAlternativeFamilyNames( fontID nFont, ::std::list< ::rtl::OUString >& rNames ) const;


And the new file ...

--- psprint/source/fontmanager/fcfontmanager.cxx
+++ psprint/source/fontmanager/fcfontmanager.cxx
@@ -0,0 +1,1968 @@
+/*************************************************************************
+ *
+ *  $RCSfile$
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#define Window XLIB_Window
+#define Time XLIB_Time
+#include <X11/Xlib.h>
+#undef Window
+#undef Time
+#include <unistd.h>
+#include <sys/stat.h>
+#include <dirent.h>
+
+#ifndef _OSL_THREAD_H_
+#include <osl/thread.h>
+#endif
+#ifndef _UTL_ATOM_HXX_
+#include <unotools/atom.hxx>
+#endif
+#ifndef _PSPRINT_FONTMANAGER_HXX_
+#include <psprint/fontmanager.hxx>
+#endif
+#ifndef _PSPRINT_FONTCACHE_HXX_
+#include <psprint/fontcache.hxx>
+#endif
+#ifndef _URLOBJ_HXX
+#include <tools/urlobj.hxx>
+#endif
+#ifndef _STREAM_HXX
+#include <tools/stream.hxx>
+#endif
+#ifndef _PSPRINT_HELPER_HXX_
+#include <psprint/helper.hxx>
+#endif
+#ifndef _OSL_FILE_HXX_
+#include <osl/file.hxx>
+#endif
+#ifndef _PSPRINT_STRHELPER_HXX_
+#include <psprint/strhelper.hxx>
+#endif
+#ifndef _PSPRINT_PPDPARSER_HXX_
+#include <psprint/ppdparser.hxx>
+#endif
+#ifndef _RTL_TENCINFO_H
+#include <rtl/tencinfo.h>
+#endif
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+#ifndef _CONFIG_HXX
+#include <tools/config.hxx>
+#endif
+#ifndef _RTL_USTRBUF_HXX_
+#include <rtl/ustrbuf.hxx>
+#endif
+#ifndef _RTL_STRBUF_HXX_
+#include <rtl/strbuf.hxx>
+#endif
+#ifndef _TOOLS_INTN_HXX
+#include <tools/intn.hxx>
+#endif
+
+
+#include <parseAFM.hxx>
+#define NO_LIST
+#include <sft.h>
+#undef NO_LIST
+
+#ifdef DEBUG
+#include <sys/times.h>
+#include <stdio.h>
+#endif
+
+#if defined(SOLARIS) || defined(IRIX)
+#include <alloca.h>
+#endif
+
+#include <set>
+
+#include <adobeenc.tab> // get encoding table for AFM metrics
+
+#include <stdio.h>
+#include <fontconfig/fontconfig.h>
+
+#define PRINTER_METRICDIR "fontmetric"
+
+using namespace utl;
+using namespace psp;
+using namespace osl;
+using namespace rtl;
+
+/*
+ *  static helpers
+ */
+
+inline sal_uInt16 getUInt16BE( const byte*& pBuffer )
+{
+    sal_uInt16 nRet = (sal_uInt16)pBuffer[1] |
+        (((sal_uInt16)pBuffer[0]) << 8);
+    pBuffer+=2;
+    return nRet;
+}
+
+
+// -------------------------------------------------------------------------
+
+static weight::type parseWeight( const ByteString& rWeight )
+{
+    weight::type eWeight = weight::Unknown;
+    if( rWeight.Search( "bold" ) != STRING_NOTFOUND )
+    {
+        if( rWeight.Search( "emi" ) != STRING_NOTFOUND ) // semi, demi
+            eWeight = weight::SemiBold;
+        else if( rWeight.Search( "ultra" ) != STRING_NOTFOUND )
+            eWeight = weight::UltraBold;
+        else
+            eWeight = weight::Bold;
+    }
+    else if( rWeight.Search( "light" ) != STRING_NOTFOUND )
+    {
+        if( rWeight.Search( "emi" ) != STRING_NOTFOUND ) // semi, demi
+            eWeight = weight::SemiLight;
+        else if( rWeight.Search( "ultra" ) != STRING_NOTFOUND )
+            eWeight = weight::UltraLight;
+        else
+            eWeight = weight::Light;
+    }
+    else if( rWeight.Search( "black" ) != STRING_NOTFOUND )
+        eWeight = weight::Black;
+    else if( rWeight.Equals( "demi" ) )
+        eWeight = weight::SemiBold;
+    else if( rWeight.Equals( "book" ) ||
+             rWeight.Equals( "semicondensed" ) )
+        eWeight = weight::Light;
+    else if( rWeight.Equals( "medium" ) || rWeight.Equals( "roman" ) )
+        eWeight = weight::Medium;
+    else
+        eWeight = weight::Normal;
+    return eWeight;
+}
+
+// -------------------------------------------------------------------------
+
+/*
+ *  PrintFont implementations
+ */
+PrintFontManager::PrintFont::PrintFont( fonttype::type eType ) :
+        m_eType( eType ),
+        m_nFamilyName( 0 ),
+        m_nPSName( 0 ),
+        m_eItalic( italic::Unknown ),
+        m_eWidth( width::Unknown ),
+        m_eWeight( weight::Unknown ),
+        m_ePitch( pitch::Unknown ),
+        m_aEncoding( RTL_TEXTENCODING_DONTKNOW ),
+        m_pMetrics( NULL ),
+        m_nAscend( 0 ),
+        m_nDescend( 0 ),
+        m_nLeading( 0 ),
+        m_bHaveVerticalSubstitutedGlyphs( false )
+{
+}
+
+// -------------------------------------------------------------------------
+
+PrintFontManager::PrintFont::~PrintFont()
+{
+    if( m_pMetrics )
+        delete m_pMetrics;
+}
+
+// -------------------------------------------------------------------------
+
+PrintFontManager::Type1FontFile::~Type1FontFile()
+{
+}
+
+// -------------------------------------------------------------------------
+
+PrintFontManager::TrueTypeFontFile::~TrueTypeFontFile()
+{
+}
+
+// -------------------------------------------------------------------------
+
+PrintFontManager::BuiltinFont::~BuiltinFont()
+{
+}
+
+// -------------------------------------------------------------------------
+
+bool PrintFontManager::Type1FontFile::queryMetricPage( int nPage, MultiAtomProvider* pProvider )
+{
+    return readAfmMetrics( PrintFontManager::get().getAfmFile( this ), pProvider );
+}
+
+// -------------------------------------------------------------------------
+
+bool PrintFontManager::BuiltinFont::queryMetricPage( int nPage, MultiAtomProvider* pProvider )
+{
+    return readAfmMetrics( PrintFontManager::get().getAfmFile( this ), pProvider );
+}
+
+// -------------------------------------------------------------------------
+
+bool PrintFontManager::TrueTypeFontFile::queryMetricPage( int nPage, MultiAtomProvider* pProvider )
+{
+    bool bSuccess = false;
+
+    ByteString aFile( PrintFontManager::get().getFontFile( this ) );
+
+    TrueTypeFont* pTTFont = NULL;
+    
+    if( OpenTTFont( aFile.GetBuffer(), m_nCollectionEntry < 0 ? 0 : m_nCollectionEntry, &pTTFont ) == SF_OK )
+    {
+        if( ! m_pMetrics )
+        {
+            m_pMetrics = new PrintFontMetrics;
+            memset (m_pMetrics->m_aPages, 0, sizeof(m_pMetrics->m_aPages));
+        }
+        m_pMetrics->m_aPages[ nPage/8 ] |= (1 << ( nPage & 7 ));
+        int i;
+        uint16 table[256], table_vert[256];
+
+        for( i = 0; i < 256; i++ )
+            table[ i ] = 256*nPage + i;
+
+        int nCharacters = nPage < 255 ? 256 : 254;
+        MapString( pTTFont, table, nCharacters, NULL, 0 );
+        TTSimpleGlyphMetrics* pMetrics = GetTTSimpleCharMetrics( pTTFont, nPage*256, nCharacters, 0 );
+        if( pMetrics )
+        {
+            for( i = 0; i < nCharacters; i++ )
+            {
+                if( table[i] )
+                {
+                    CharacterMetric& rChar = m_pMetrics->m_aMetrics[ nPage*256 + i ];
+                    rChar.width = pMetrics[ i ].adv;
+                    rChar.height = m_aGlobalMetricX.height;
+                }
+            }
+
+            free( pMetrics );
+        }
+
+        for( i = 0; i < 256; i++ )
+            table_vert[ i ] = 256*nPage + i;
+        MapString( pTTFont, table_vert, nCharacters, NULL, 1 );
+        pMetrics = GetTTSimpleCharMetrics( pTTFont, nPage*256, nCharacters, 1 );
+        if( pMetrics )
+        {
+            for( i = 0; i < nCharacters; i++ )
+            {
+                if( table_vert[i] )
+                {
+                    CharacterMetric& rChar = m_pMetrics->m_aMetrics[ nPage*256 + i + ( 1 << 16 ) ];
+                    rChar.width = m_aGlobalMetricY.width;
+                    rChar.height = pMetrics[ i ].adv;
+                    if( table_vert[i] != table[i] )
+                        m_pMetrics->m_bVerticalSubstitutions[ nPage*256 + i ] = 1;
+                }
+            }
+            free( pMetrics );
+        }
+
+        if( ! m_pMetrics->m_bKernPairsQueried )
+        {
+            m_pMetrics->m_bKernPairsQueried = true;
+            // this is really a hack
+            // in future MapString/KernGlyphs should be used
+            // but vcl is not in a state where that could be used
+            // so currently we get kernpairs by accessing the raw data
+            struct _TrueTypeFont* pImplTTFont = (struct _TrueTypeFont*)pTTFont;
+            
+            if( pImplTTFont->nkern && pImplTTFont->kerntype == KT_MICROSOFT )
+            {
+                // create a glyph -> character mapping
+                ::std::hash_map< sal_uInt16, sal_Unicode > aGlyphMap;
+                ::std::hash_map< sal_uInt16, sal_Unicode >::iterator left, right;
+                for( i = 21; i < 0xfffd; i++ )
+                {
+                    sal_uInt16 nGlyph = MapChar( pTTFont, (sal_Unicode)i, 0 ); // kerning for horz only
+                    if( nGlyph != 0 )
+                        aGlyphMap[ nGlyph ] = (sal_Unicode)i;
+                }
+                
+
+                KernPair aPair;
+                for( i = 0; i < pImplTTFont->nkern; i++ )
+                {
+                    const byte* pTable = pImplTTFont->kerntables[i];
+                    
+                    sal_uInt16 nVersion     = getUInt16BE( pTable );
+                    sal_uInt16 nLength      = getUInt16BE( pTable );
+                    sal_uInt16 nCoverage    = getUInt16BE( pTable );
+                    
+                    aPair.kern_x    = 0;
+                    aPair.kern_y    = 0;
+                    switch( nCoverage >> 8 )
+                    {
+                        case 0:
+                        {
+                            sal_uInt16 nPairs = getUInt16BE( pTable );
+                            pTable += 6;
+                            for( int n = 0; n < nPairs; n++ )
+                            {
+                                sal_uInt16 nLeftGlyph   = getUInt16BE( pTable );
+                                sal_uInt16 nRightGlyph  = getUInt16BE( pTable );
+                                sal_Int16 nKern         = (sal_Int16)getUInt16BE( pTable );
+                                
+                                left = aGlyphMap.find( nLeftGlyph );
+                                right = aGlyphMap.find( nRightGlyph );
+                                if( left != aGlyphMap.end() && right != aGlyphMap.end() )
+                                {
+                                    aPair.first     = left->second;
+                                    aPair.second    = right->second;
+                                    switch( nCoverage & 1 )
+                                    {
+                                        case 1:
+                                            aPair.kern_x = (int)nKern * 1000 / pImplTTFont->unitsPerEm;
+                                            m_pMetrics->m_aXKernPairs.push_back( aPair );
+                                            break;
+                                        case 0:
+                                            aPair.kern_y = (int)nKern * 1000 / pImplTTFont->unitsPerEm;
+                                            m_pMetrics->m_aYKernPairs.push_back( aPair );
+                                            break;                                          
+                                    }
+                                }
+                            }
+                        }
+                        break;
+                        case 2:
+
+                        {
+                            const byte* pSubTable = pTable;
+                            sal_uInt16 nRowWidth    = getUInt16BE( pTable );
+                            sal_uInt16 nOfLeft      = getUInt16BE( pTable );
+                            sal_uInt16 nOfRight     = getUInt16BE( pTable );
+                            sal_uInt16 nOfArray     = getUInt16BE( pTable );
+                            const byte* pTmp = pSubTable + nOfLeft;
+                            sal_uInt16 nFirstLeft   = getUInt16BE( pTmp );
+                            sal_uInt16 nLastLeft    = getUInt16BE( pTmp ) + nFirstLeft - 1;
+                            pTmp = pSubTable + nOfRight;
+                            sal_uInt16 nFirstRight  = getUInt16BE( pTmp );
+                            sal_uInt16 nLastRight   = getUInt16BE( pTmp ) + nFirstRight -1;
+                            
+                            int nPairs = (int)(nLastLeft-nFirstLeft+1)*(int)(nLastRight-nFirstRight+1);
+                            for( aPair.first = nFirstLeft; aPair.first < nLastLeft; aPair.first++ )
+                            {
+                                for( aPair.second = 0; aPair.second < nLastRight; aPair.second++ )
+                                {
+                                    sal_Int16 nKern = (sal_Int16)getUInt16BE( pTmp );
+                                    switch( nCoverage & 1 )
+                                    {
+                                        case 1:
+                                            aPair.kern_x = (int)nKern * 1000 / pImplTTFont->unitsPerEm;
+                                            m_pMetrics->m_aXKernPairs.push_back( aPair );
+                                            break;
+                                        case 0:
+                                            aPair.kern_y = (int)nKern * 1000 / pImplTTFont->unitsPerEm;
+                                            m_pMetrics->m_aYKernPairs.push_back( aPair );
+                                            break;                                          
+                                    }
+                                }
+                            }
+                        }
+                        break;
+                    }
+                }
+            }
+#ifdef DEBUG
+            fprintf( stderr, "found %d/%d kern pairs for %s\n",
+                     m_pMetrics->m_aXKernPairs.size(),
+                     m_pMetrics->m_aYKernPairs.size(),
+                     OUStringToOString( pProvider->getString( ATOM_FAMILYNAME, m_nFamilyName ), RTL_TEXTENCODING_MS_1252 ).getStr() );
+#endif
+        }
+
+        CloseTTFont( pTTFont );
+        bSuccess = true;
+    }
+    return bSuccess;
+}
+
+// -------------------------------------------------------------------------
+
+bool PrintFontManager::PrintFont::readAfmMetrics( const OString& rFileName, MultiAtomProvider* pProvider )
+{
+    PrintFontManager& rManager( PrintFontManager::get() );
+
+    int i;
+    FILE* fp = fopen( rFileName.getStr(), "r" );
+    if( ! fp )
+        return false;
+    FontInfo* pInfo = NULL;
+    int nResult = parseFile( fp, &pInfo, P_ALL );
+    fclose( fp );
+    if( ! pInfo || ! pInfo->numOfChars )
+    {
+        if( pInfo )
+            freeFontInfo( pInfo );
+        return false;
+    }
+    
+    // fill in global info
+
+    // family name (if not already set)
+    if( ! m_nFamilyName )
+    {
+        OUString aFamily( OStringToOUString( pInfo->gfi->familyName, RTL_TEXTENCODING_ISO_8859_1 ) );
+        if( ! aFamily.getLength() )
+            aFamily = OStringToOUString( pInfo->gfi->fontName, RTL_TEXTENCODING_ISO_8859_1 );
+        m_nFamilyName = pProvider->getAtom( ATOM_FAMILYNAME, aFamily, sal_True );
+    }
+
+    // PSName
+    OUString aPSName( OStringToOUString( pInfo->gfi->fontName, RTL_TEXTENCODING_ISO_8859_1 ) );
+    m_nPSName = pProvider->getAtom( ATOM_PSNAME, aPSName, sal_True );
+    
+    // italic
+    if( pInfo->gfi->italicAngle > 0 )
+        m_eItalic = italic::Oblique;
+    else if( pInfo->gfi->italicAngle < 0 )
+        m_eItalic = italic::Italic;
+    else
+        m_eItalic = italic::Upright;
+
+    // weight
+    m_eWeight = parseWeight( ByteString( pInfo->gfi->weight ).ToLowerAscii() );
+
+    // pitch
+    m_ePitch = pInfo->gfi->isFixedPitch ? pitch::Fixed : pitch::Variable;
+
+    // encoding - only set if unknown
+    // try to parse the font name and decide wether it might be a
+    // japanese font. Who invented this PITA ?
+    OUString aPSNameLastToken( aPSName.copy( aPSName.lastIndexOf( '-' )+1 ) );
+    if( m_aEncoding == RTL_TEXTENCODING_DONTKNOW &&
+        ( ! aPSNameLastToken.compareToAscii( "H" )    ||
+          ! aPSNameLastToken.compareToAscii( "V" ) )
+        )
+    {
+        static const char* pEncs[] = 
+            {
+                "EUC",
+                "RKSJ",
+                "SJ"
+            };
+        static const rtl_TextEncoding aEncs[] =
+            {
+                RTL_TEXTENCODING_EUC_JP,
+                RTL_TEXTENCODING_SHIFT_JIS,
+                RTL_TEXTENCODING_JIS_X_0208
+            };
+        
+        for( int enc = 0; enc < sizeof( aEncs )/sizeof(aEncs[0]) && m_aEncoding == RTL_TEXTENCODING_DONTKNOW; enc++ )
+        {
+            sal_Int32 nIndex = 0, nOffset = 1;
+            do
+            {
+                OUString aToken( aPSName.getToken( nOffset, '-', nIndex ) );
+                if( nIndex == -1 )
+                    break;
+                nOffset = 0;
+                if( ! aToken.compareToAscii( pEncs[enc] ) )
+                    m_aEncoding = aEncs[ enc ];              
+            } while( nIndex != -1 );
+        }
+
+        // default is jis
+        if( m_aEncoding == RTL_TEXTENCODING_DONTKNOW )
+            m_aEncoding = RTL_TEXTENCODING_JIS_X_0208;
+#ifdef DEBUG
+        fprintf( stderr, "Encoding %d for %s\n", m_aEncoding, pInfo->gfi->fontName );
+#endif
+    }
+    int nAdobeEncoding = 0;
+    if( pInfo->gfi->encodingScheme )
+    {
+        if( !strcmp( pInfo->gfi->encodingScheme, "AdobeStandardEncoding" ) )
+            nAdobeEncoding = 1;
+        else if( !strcmp( pInfo->gfi->encodingScheme, "Symbol") )
+            nAdobeEncoding = 2;
+        else if( !strcmp( pInfo->gfi->encodingScheme, "FontSpecific") )
+            nAdobeEncoding = 3;
+
+        if( m_aEncoding == RTL_TEXTENCODING_DONTKNOW )
+            m_aEncoding = nAdobeEncoding == 1 ?
+                RTL_TEXTENCODING_MS_1252 : RTL_TEXTENCODING_SYMBOL;
+    }
+    else if( m_aEncoding == RTL_TEXTENCODING_DONTKNOW )
+        m_aEncoding = RTL_TEXTENCODING_MS_1252;
+
+    // ascend
+    m_nAscend = pInfo->gfi->fontBBox.ury;
+
+    // descend
+    // descends have opposite sign of our definition
+    m_nDescend = -pInfo->gfi->fontBBox.lly;
+
+    // fallback to ascender, descender
+    // interesting: the BBox seems to describe Ascender and Descender better
+    // as we understand it
+    if( m_nAscend == 0 )
+        m_nAscend = pInfo->gfi->ascender;
+    if( m_nDescend == 0)
+        m_nDescend = -pInfo->gfi->descender;
+
+    m_nLeading = m_nAscend + m_nDescend - 1000;
+
+    if( m_pMetrics )
+        delete m_pMetrics;
+    m_pMetrics = new PrintFontMetrics;
+    // mark all pages as queried
+    memset( m_pMetrics->m_aPages, 0xff, sizeof( m_pMetrics->m_aPages ) );
+
+    m_aGlobalMetricX.width = m_aGlobalMetricY.width =
+        pInfo->gfi->charwidth ? pInfo->gfi->charwidth : pInfo->gfi->fontBBox.urx;
+    m_aGlobalMetricX.height = m_aGlobalMetricY.height =
+        pInfo->gfi->capHeight ? pInfo->gfi->capHeight : pInfo->gfi->fontBBox.ury;
+
+    // fill in character metrics
+
+    // first transform the character codes to unicode
+    // note: this only works with single byte encodings
+    sal_Unicode* pUnicodes = (sal_Unicode*)alloca( pInfo->numOfChars * sizeof(sal_Unicode));
+    CharMetricInfo* pChar = pInfo->cmi;
+
+    for( i = 0; i < pInfo->numOfChars; i++, pChar++ )
+    {
+        if( pChar->code != -1 )
+        {
+            if( nAdobeEncoding == 3 && m_aEncoding == RTL_TEXTENCODING_SYMBOL )
+            {
+                pUnicodes[i] = pChar->code + 0xf000;
+                continue;
+            }
+
+            ByteString aTranslate;
+            if( pChar->code & 0xff000000 )
+                aTranslate += (char)(pChar->code >> 24 );
+            if( pChar->code & 0xffff0000 )
+                aTranslate += (char)((pChar->code & 0x00ff0000) >> 16 );
+            if( pChar->code & 0xffffff00 )
+                aTranslate += (char)((pChar->code & 0x0000ff00) >> 8 );
+            aTranslate += (char)(pChar->code & 0xff);
+            String aUni( aTranslate, m_aEncoding );
+            pUnicodes[i] = *aUni.GetBuffer();
+        }
+        else
+            pUnicodes[i] = 0;
+    }
+
+    // now fill in the character metrics
+    // parseAFM.cxx effectively only supports direction 0 (horizontal)
+    pChar = pInfo->cmi;
+    CharacterMetric aMetric;
+    for( i = 0; i < pInfo->numOfChars; i++, pChar++ )
+    {
+        if( pChar->code == -1 && ! pChar->name )
+            continue;
+
+        aMetric.width   = pChar->wx ? pChar->wx : pChar->charBBox.urx;
+        aMetric.height  = pChar->wy ? pChar->wy : pChar->charBBox.ury - pChar->charBBox.lly;
+        if( aMetric.width == 0 && aMetric.height == 0 )
+            // guess something for e.g. space
+            aMetric.width = m_aGlobalMetricX.width/4;
+
+        if( ( nAdobeEncoding == 0 ) ||
+            ( ( nAdobeEncoding == 3 ) && ( m_aEncoding != RTL_TEXTENCODING_SYMBOL ) ) )
+        {
+            if( pChar->code != -1 )
+            {
+                m_pMetrics->m_aMetrics[ pUnicodes[i] ] = aMetric;
+            }
+            else if( pChar->name )
+            {
+                ::std::pair< ::std::hash_multimap< ::rtl::OString, sal_Unicode, ::rtl::OStringHash >::const_iterator,
+                      ::std::hash_multimap< ::rtl::OString, sal_Unicode, ::rtl::OStringHash >::const_iterator >
+                      aCodes = rManager.getUnicodeFromAdobeName( pChar->name );
+                while( aCodes.first != aCodes.second )
+                {
+                    if( (*aCodes.first).second != 0 )
+                        m_pMetrics->m_aMetrics[ (*aCodes.first).second ] = aMetric;
+                    ++aCodes.first;
+                }
+            }
+        }
+        else if( nAdobeEncoding == 1 || nAdobeEncoding == 2 )
+        {
+            if( pChar->name )
+            {
+                ::std::pair< ::std::hash_multimap< ::rtl::OString, sal_Unicode, ::rtl::OStringHash >::const_iterator,
+                      ::std::hash_multimap< ::rtl::OString, sal_Unicode, ::rtl::OStringHash >::const_iterator >
+                      aCodes = rManager.getUnicodeFromAdobeName( pChar->name );
+                while( aCodes.first != aCodes.second )
+                {
+                    if( (*aCodes.first).second != 0 )
+                        m_pMetrics->m_aMetrics[ (*aCodes.first).second ] = aMetric;
+                    ++aCodes.first;
+                }
+            }
+            else if( pChar->code != -1 )
+            {
+                ::std::pair< ::std::hash_multimap< sal_uInt8, sal_Unicode >::const_iterator,
+                      ::std::hash_multimap< sal_uInt8, sal_Unicode >::const_iterator >
+                      aCodes = rManager.getUnicodeFromAdobeCode( pChar->code );
+                while( aCodes.first != aCodes.second )
+                {
+                    if( (*aCodes.first).second != 0 )
+                        m_pMetrics->m_aMetrics[ (*aCodes.first).second ] = aMetric;
+                    ++aCodes.first;
+                }
+            }
+        }
+        else if( nAdobeEncoding == 3 )
+        {
+            if( pChar->code != -1 )
+            {
+                sal_Unicode code = 0xf000 + pChar->code;
+                m_pMetrics->m_aMetrics[ code ] = aMetric;
+                // maybe should try to find the name in the convtabs ?
+            }
+        }
+    }
+        
+    m_pMetrics->m_aXKernPairs.clear();
+    m_pMetrics->m_aYKernPairs.clear();
+
+    // now fill in the kern pairs
+    // parseAFM.cxx effectively only supports direction 0 (horizontal)
+    PairKernData* pKern = pInfo->pkd;
+    KernPair aPair;
+    for( i = 0; i < pInfo->numOfPairs; i++, pKern++ )
+    {
+        aPair.first = 0;
+        aPair.second = 0;
+        // currently we have to find the adobe character names
+        // in the already parsed character metrics to find
+        // the corresponding UCS2 code which is a bit dangerous
+        // since the character names are not required
+        // in the metric descriptions
+        pChar = pInfo->cmi;     
+        for( int j = 0;
+             j < pInfo->numOfChars && ( aPair.first == 0 || aPair.second == 0 );
+             j++, pChar++ )
+        {
+            if( pChar->code != -1 )
+            {
+                if( ! strcmp( pKern->name1, pChar->name ? pChar->name : "" ) )
+                    aPair.first = pUnicodes[ j ];
+                if( ! strcmp( pKern->name2, pChar->name ? pChar->name : "" ) )
+                    aPair.second = pUnicodes[ j ];
+            }
+        }
+        if( aPair.first && aPair.second )
+        {
+            aPair.kern_x = pKern->xamt;
+            aPair.kern_y = pKern->yamt;
+            m_pMetrics->m_aXKernPairs.push_back( aPair );
+        }
+    }
+    m_pMetrics->m_bKernPairsQueried = true;
+
+    freeFontInfo( pInfo );
+    rManager.m_pFontCache->updateFontCacheEntry( this, rManager.m_bFlushFontCache );
+    return true;
+}
+
+// -------------------------------------------------------------------------
+
+OString PrintFontManager::s_aEmptyOString;
+
+/*
+ *  one instance only
+ */
+PrintFontManager& PrintFontManager::get()
+{
+    static PrintFontManager* theManager = NULL;
+    if( ! theManager )
+    {
+        theManager = new PrintFontManager();
+        theManager->initialize();
+    }
+    return *theManager;
+}
+
+// -------------------------------------------------------------------------
+
+/*
+ *  the PrintFontManager
+ */
+
+PrintFontManager::PrintFontManager() :
+        m_pAtoms( new MultiAtomProvider() ),
+        m_nNextFontID( 1 ),
+        m_nNextDirAtom( 1 ),
+        m_pFontCache( NULL ),
+        m_bFlushFontCache( true )
+{
+    for( int i = 0; i < sizeof( aAdobeCodes )/sizeof( aAdobeCodes[0] ); i++ )
+    {
+        m_aUnicodeToAdobename.insert( ::std::hash_multimap< sal_Unicode, ::rtl::OString >::value_type( aAdobeCodes[i].aUnicode, aAdobeCodes[i].pAdobename ) );
+        m_aAdobenameToUnicode.insert( ::std::hash_multimap< ::rtl::OString, sal_Unicode, ::rtl::OStringHash >::value_type( aAdobeCodes[i].pAdobename, aAdobeCodes[i].aUnicode ) );
+        if( aAdobeCodes[i].aAdobeStandardCode )
+        {
+            m_aUnicodeToAdobecode.insert( ::std::hash_multimap< sal_Unicode, sal_uInt8 >::value_type( aAdobeCodes[i].aUnicode, aAdobeCodes[i].aAdobeStandardCode ) );
+            m_aAdobecodeToUnicode.insert( ::std::hash_multimap< sal_uInt8, sal_Unicode >::value_type( aAdobeCodes[i].aAdobeStandardCode, aAdobeCodes[i].aUnicode ) );
+        }
+#if 0
+        m_aUnicodeToAdobename[ aAdobeCodes[i].aUnicode ] = aAdobeCodes[i].pAdobename;
+        m_aAdobenameToUnicode[ aAdobeCodes[i].pAdobename ] = aAdobeCodes[i].aUnicode;
+        if( aAdobeCodes[i].aAdobeStandardCode )
+        {
+            m_aUnicodeToAdobecode[ aAdobeCodes[i].aUnicode ] = aAdobeCodes[i].aAdobeStandardCode;
+            m_aAdobecodeToUnicode[ aAdobeCodes[i].aAdobeStandardCode ] = aAdobeCodes[i].aUnicode;
+        }
+#endif
+    }
+}
+
+// -------------------------------------------------------------------------
+
+PrintFontManager::~PrintFontManager()
+{
+    for( ::std::hash_map< fontID, PrintFont* >::const_iterator it = m_aFonts.begin(); it != m_aFonts.end(); ++it )
+        delete (*it).second;
+    delete m_pAtoms;
+    if( m_pFontCache )
+        delete m_pFontCache;
+}
+
+// -------------------------------------------------------------------------
+
+const OString& PrintFontManager::getDirectory( int nAtom ) const
+{
+    ::std::hash_map< int, OString >::const_iterator it( m_aAtomToDir.find( nAtom ) );
+    return it != m_aAtomToDir.end() ? it->second : s_aEmptyOString;
+}
+
+// -------------------------------------------------------------------------
+
+int PrintFontManager::getDirectoryAtom( const OString& rDirectory, bool bCreate )
+{
+    int nAtom = 0;
+    ::std::hash_map< OString, int, OStringHash >::const_iterator it
+          ( m_aDirToAtom.find( rDirectory ) );
+    if( it != m_aDirToAtom.end() )
+        nAtom = it->second;
+    else if( bCreate )
+    {
+        nAtom = m_nNextDirAtom++;
+        m_aDirToAtom[ rDirectory ] = nAtom;
+        m_aAtomToDir[ nAtom ] = rDirectory;
+    }
+    return nAtom;
+}
+
+// -------------------------------------------------------------------------
+
+int PrintFontManager::addFontFile( const OString& rFontPath,
+				   const FcPattern *fc_font,
+				   bool bMergeBuiltin)
+{
+    sal_Int32 idx;
+    ::std::list< PrintFontManager::PrintFont* > aNewFonts;
+
+    idx = rFontPath.lastIndexOf ('/');
+    if (idx < 0)
+      {
+	fprintf (stderr, "Invalid path\n");
+	return;
+      }
+    // Split the directory
+    OString aDir (rFontPath, idx);
+    // And the filename
+    OString aFontFile( rFontPath + idx + 1, rFontPath.getLength() - idx - 1);
+    // And the extension
+    ByteString aExt( aFontFile.copy( aFontFile.lastIndexOf( '.' )+1 ) );
+
+    int nDirID = getDirectoryAtom( aDir, true );
+
+    if( m_pFontCache->getFontCacheFile( nDirID, aDir, aFontFile, aNewFonts ) )
+      {
+#ifdef DEBUG
+	fprintf( stderr, "Hit cache for '%s'", (sal_Char *) rFontPath );
+#endif
+      /* got it from the cache */ ;
+      }
+    else if( aExt.EqualsIgnoreCaseAscii( "pfb" ) || aExt.EqualsIgnoreCaseAscii( "pfa" ) )
+    {
+        // check for corresponding afm metric
+        // first look for an adjacent file
+
+        ByteString aName( aFontFile );
+        aName.Erase( aName.Len()-4 );
+        aName.Append( ".afm" );
+        
+        ByteString aFilePath( aDir );
+        aFilePath.Append( '/' );
+        aFilePath.Append( aName );
+        
+        ByteString aAfmFile;
+        if( access( aFilePath.GetBuffer(), F_OK ) )
+        {
+            // try in subdirectory afm instead
+            aFilePath = aDir;
+            aFilePath.Append( "/afm/" );
+            aFilePath.Append( aName );
+            
+            if( ! access( aFilePath.GetBuffer(), F_OK ) )
+            {
+                aAfmFile = "afm/";
+                aAfmFile += aName;
+            }
+        }
+        else
+            aAfmFile = aName;
+
+        if( aAfmFile.Len() )
+        {
+            Type1FontFile* pFont = new Type1FontFile();
+            pFont->m_nDirectory     = nDirID;
+
+            pFont->m_aFontFile      = aFontFile;
+            pFont->m_aMetricFile    = aAfmFile;
+
+	    if (fc_font)
+		getFontAttributesFromFcPattern( pFont, fc_font );
+            else if( ! pFont->readAfmMetrics( getAfmFile( pFont ), m_pAtoms ) )
+            {
+                delete pFont;
+                pFont = NULL;
+            }
+            if( pFont )
+                aNewFonts.push_back( pFont );
+        }
+    }
+    else if( aExt.EqualsIgnoreCaseAscii( "afm" ) )
+    {
+        ByteString aFilePath( aDir );
+        aFilePath.Append( '/' );
+        aFilePath.Append( ByteString( aFontFile ) );
+        BuiltinFont* pFont = new BuiltinFont();
+        pFont->m_nDirectory		= nDirID;
+        pFont->m_aMetricFile	= aFontFile;
+        if( pFont->readAfmMetrics( aFilePath, m_pAtoms ) )
+            aNewFonts.push_back( pFont );
+        else
+            delete pFont;
+    }
+    else if( aExt.EqualsIgnoreCaseAscii( "ttf" ) )
+    {
+        TrueTypeFontFile* pFont     = new TrueTypeFontFile();
+        pFont->m_nDirectory         = nDirID;
+        pFont->m_aFontFile          = aFontFile;
+        pFont->m_nCollectionEntry   = -1;
+
+	getFontAttributesFromFcPattern( pFont, fc_font );
+        // need to read the font anyway to get aliases
+        if( ! analyzeTrueTypeFile( pFont ) )
+        {
+            delete pFont;
+            pFont = NULL;
+        }
+        else
+            aNewFonts.push_back( pFont );
+    }
+#warning Disabled ttc parsing, do we need to use the 'index' property for 'nCollectionEntry' ?
+
+    for( ::std::list< PrintFont* >::iterator it = aNewFonts.begin(); it != aNewFonts.end(); ++it )
+      {
+	if (!bMergeBuiltin ||
+	    !findFontBuiltinID( (*it)->m_nPSName ) )
+	  {
+	    fontID aFont = m_nNextFontID++;
+	    m_aFonts[ aFont ] = *it;
+	  }
+	else
+	  delete (*it);
+      }
+}
+
+// -------------------------------------------------------------------------
+
+fontID PrintFontManager::findFontBuiltinID( int nPSNameAtom ) const
+{
+    fontID nID = 0;
+    ::std::hash_map< int, PrintFont* >::const_iterator it;
+    for( it = m_aFonts.begin(); nID == 0 && it != m_aFonts.end(); ++it )
+    {
+        if( it->second->m_eType == fonttype::Builtin &&
+            it->second->m_nPSName == nPSNameAtom )
+            nID = it->first;
+    }
+    return nID;
+}
+
+// -------------------------------------------------------------------------
+
+void PrintFontManager::getFontAttributesFromFcPattern( PrintFont* pFont, const FcPattern *fc_font ) const
+{
+    FcChar8 *fc_str;
+    int      fc_int;
+
+    if (!FcPatternGetString (fc_font, FC_FAMILY, 0, &fc_str) && fc_str)
+	pFont->m_nFamilyName =
+	  m_pAtoms->getAtom( ATOM_FAMILYNAME,
+			     String( ByteString((sal_Char *) fc_str ), RTL_TEXTENCODING_UTF8 ),
+			     sal_True );
+
+    if (!FcPatternGetInteger (fc_font, FC_WEIGHT, 0, &fc_int))
+      {
+	if (fc_int < FC_WEIGHT_LIGHT)
+	  pFont->m_eWeight = weight::UltraLight;
+	else if (fc_int == FC_WEIGHT_LIGHT)
+	  pFont->m_eWeight = weight::Light;
+	else if (fc_int < FC_WEIGHT_MEDIUM)
+	  pFont->m_eWeight = weight::SemiLight;
+	else if (fc_int == FC_WEIGHT_MEDIUM)
+	  pFont->m_eWeight = weight::Normal;
+	else if (fc_int < FC_WEIGHT_DEMIBOLD)
+	  pFont->m_eWeight = weight::Medium;
+	else if (fc_int == FC_WEIGHT_DEMIBOLD)
+	  pFont->m_eWeight = weight::SemiBold;
+	else if (fc_int <= FC_WEIGHT_BOLD)
+	  pFont->m_eWeight = weight::Bold;
+	else if (fc_int < FC_WEIGHT_BLACK)
+	  pFont->m_eWeight = weight::UltraBold;
+	else
+	  pFont->m_eWeight = weight::Black;
+      }
+
+    if (!FcPatternGetInteger (fc_font, FC_SLANT, 0, &fc_int))
+      {
+	if (fc_int <= FC_SLANT_ROMAN)
+	  pFont->m_eItalic = italic::Upright;
+	else if (fc_int <= FC_SLANT_ITALIC)
+	  pFont->m_eItalic = italic::Italic;
+	else if (fc_int <= FC_SLANT_ITALIC)
+	  pFont->m_eItalic = italic::Oblique;
+      }
+
+    /* FIXME: this used to be parsed from XLFD (parseWidth) */
+    pFont->m_eWidth = width::Normal;
+
+    if (!FcPatternGetInteger (fc_font, FC_SLANT, 0, &fc_int))
+      {
+	if (fc_int > FC_PROPORTIONAL && (fc_int <= FC_MONO ||
+					      fc_int <= FC_CHARCELL))
+	  pFont->m_ePitch = pitch::Fixed;
+	else
+	  pFont->m_ePitch = pitch::Variable;
+      }
+    else
+        pFont->m_ePitch = pitch::Variable;
+
+#if 0
+    // get encoding
+    aToken = rXLFD.GetToken( 6, '-' ).ToLowerAscii();
+    if( aToken.Search( "symbol" ) != STRING_NOTFOUND )
+        pFont->m_aEncoding = RTL_TEXTENCODING_SYMBOL;
+    else
+    {
+        aToken =WhitespaceToSpace(  rXLFD.GetToken( 14 ) );
+        if( aToken.EqualsIgnoreCaseAscii( "symbol" ) )
+            pFont->m_aEncoding = RTL_TEXTENCODING_SYMBOL;
+        else
+        {
+            aToken = rXLFD.GetToken( 13, '-' );
+            aToken += '-';
+            aToken += WhitespaceToSpace( rXLFD.GetToken( 14, '-' ) );
+            pFont->m_aEncoding = rtl_getTextEncodingFromUnixCharset( aToken.GetBuffer() );
+        }
+    }
+#endif
+#warning Missing encoding fixup !
+    
+    // handle iso8859-1 as ms1252 to fill the "gap" starting at 0x80
+    if( pFont->m_aEncoding == RTL_TEXTENCODING_ISO_8859_1 )
+        pFont->m_aEncoding = RTL_TEXTENCODING_MS_1252;
+}
+
+// -------------------------------------------------------------------------
+
+OUString PrintFontManager::convertTrueTypeName( void* pRecord ) const
+{
+    NameRecord* pNameRecord = (NameRecord*)pRecord;
+    OUString aValue;
+    if(
+       ( pNameRecord->platformID == 3 && ( pNameRecord->encodingID == 0 || pNameRecord->encodingID == 1 ) )  // MS, Unicode
+       ||
+       ( pNameRecord->platformID == 0 ) // Apple, Unicode
+       )
+    {
+        OUStringBuffer aName( pNameRecord->slen/2 );
+        const byte* pNameBuffer = pNameRecord->sptr;
+        for(int n = 0; n < pNameRecord->slen/2; n++ )
+            aName.append( (sal_Unicode)getUInt16BE( pNameBuffer ) );
+        aValue = aName.makeStringAndClear();
+    }
+    else if( pNameRecord->platformID == 3 )
+    {
+        if( pNameRecord->encodingID >= 2 && pNameRecord->encodingID <= 6 )
+        {
+            /*
+             *  and now for a special kind of madness:
+             *  some fonts encode their byte value string as BE uint16
+             *  (leading to stray zero bytes in the string)
+             *  while others code two bytes as a uint16 and swap to BE
+             */
+            OStringBuffer aName;
+            const byte* pNameBuffer = pNameRecord->sptr;
+            for(int n = 0; n < pNameRecord->slen/2; n++ )
+            {
+                sal_Unicode aCode = (sal_Unicode)getUInt16BE( pNameBuffer );
+                sal_Char aChar = aCode >> 8;
+                if( aChar )
+                    aName.append( aChar );
+                aChar = aCode & 0x00ff;
+                if( aChar )
+                    aName.append( aChar );
+            }
+            switch( pNameRecord->encodingID )
+            {
+                case 2:
+                    aValue = OStringToOUString( aName.makeStringAndClear(), RTL_TEXTENCODING_MS_932 );
+                    break;
+                case 3:
+                    aValue = OStringToOUString( aName.makeStringAndClear(), RTL_TEXTENCODING_MS_936 );
+                    break;
+                case 4:
+                    aValue = OStringToOUString( aName.makeStringAndClear(), RTL_TEXTENCODING_MS_950 );
+                    break;
+                case 5:
+                    aValue = OStringToOUString( aName.makeStringAndClear(), RTL_TEXTENCODING_MS_949 );
+                    break;
+                case 6:
+                    aValue = OStringToOUString( aName.makeStringAndClear(), RTL_TEXTENCODING_MS_1361 );
+                    break;
+            }
+        }
+    }
+    return aValue;
+}
+
+// -------------------------------------------------------------------------
+
+void PrintFontManager::analyzeTrueTypeFamilyName( void* pTTFont, ::std::list< OUString >& rNames ) const
+{
+    OUString aFamily;
+
+    rNames.clear();
+    ::std::set< OUString > aSet;
+
+    NameRecord* pNameRecords = NULL;
+    int nNameRecords = GetTTNameRecords( (TrueTypeFont*)pTTFont, &pNameRecords );
+    if( nNameRecords && pNameRecords )
+    {
+        LanguageType aLang = GetSystemLanguage();
+        int nLastMatch = -1;
+        for( int i = 0; i < nNameRecords; i++ )
+        {
+            if( pNameRecords[i].nameID != 1 )
+                continue;
+            int nMatch = -1;
+            if( pNameRecords[i].platformID == 0 ) // Unicode
+                nMatch = 4000;
+            else if( pNameRecords[i].platformID == 3 )
+            {
+                // this bases on the LanguageType actually being a Win LCID
+                if( pNameRecords[i].languageID == aLang )
+                    nMatch = 8000;
+                else if( pNameRecords[i].languageID == LANGUAGE_ENGLISH_US )
+                    nMatch = 2000;
+                else if( pNameRecords[i].languageID == LANGUAGE_ENGLISH ||
+                         pNameRecords[i].languageID == LANGUAGE_ENGLISH_UK )
+                    nMatch = 1500;
+                else
+                    nMatch = 1000;
+            }
+            OUString aName = convertTrueTypeName( pNameRecords + i );
+            aSet.insert( aName );
+            if( nMatch > nLastMatch )
+            {
+                nLastMatch = nMatch;
+                aFamily = aName;
+            }
+        }
+        DisposeNameRecords( pNameRecords, nNameRecords );
+    }
+    if( aFamily.getLength() )
+    {
+        rNames.push_front( aFamily );
+        for( ::std::set< OUString >::const_iterator it = aSet.begin(); it != aSet.end(); ++it )
+            if( *it != aFamily )
+                rNames.push_back( *it );
+    }
+    return;
+}
+
+// -------------------------------------------------------------------------
+
+bool PrintFontManager::analyzeTrueTypeFile( PrintFont* pFont ) const
+{
+    bool bSuccess = false;
+    rtl_TextEncoding aEncoding = osl_getThreadTextEncoding();
+    ByteString aFile = getFontFile( pFont );
+    TrueTypeFont* pTTFont = NULL;
+    
+    TrueTypeFontFile* pTTFontFile = static_cast< TrueTypeFontFile* >(pFont);
+    if( OpenTTFont( aFile.GetBuffer(), pTTFontFile->m_nCollectionEntry < 0 ? 0 : pTTFontFile->m_nCollectionEntry, &pTTFont ) == SF_OK )
+    {
+        TTGlobalFontInfo aInfo;
+        GetTTGlobalFontInfo( pTTFont, & aInfo );
+
+        ::std::list< OUString > aNames;
+        analyzeTrueTypeFamilyName( pTTFont, aNames );
+
+        // set family name from XLFD if possible
+        if( ! pFont->m_nFamilyName )
+        {
+            if( aNames.begin() != aNames.end() )
+            {
+                pFont->m_nFamilyName = m_pAtoms->getAtom( ATOM_FAMILYNAME, aNames.front(), sal_True );
+                aNames.pop_front();
+            }
+            else
+                // poor font does not have a family name
+                // name it to file name minus ".tt{f|c}"
+                pFont->m_nFamilyName = m_pAtoms->getAtom( ATOM_FAMILYNAME, OStringToOUString( pTTFontFile->m_aFontFile.copy( 0, pTTFontFile->m_aFontFile.getLength()-4 ), aEncoding ), sal_True );
+        }
+        pFont->m_aAliases.clear();
+        for( ::std::list< OUString >::iterator it = aNames.begin(); it != aNames.end(); ++it )
+        {
+            if( it->getLength() )
+            {
+                int nAlias = m_pAtoms->getAtom( ATOM_FAMILYNAME, *it, sal_True );
+                if( nAlias != pFont->m_nFamilyName )
+                    pFont->m_aAliases.push_back( nAlias );
+            }
+        }
+        
+        
+        pFont->m_nPSName = m_pAtoms->getAtom( ATOM_PSNAME, String( ByteString( aInfo.psname ), aEncoding ), sal_True );
+        switch( aInfo.weight )
+        {
+            case FW_THIN:           pFont->m_eWeight = weight::Thin; break;
+            case FW_EXTRALIGHT: pFont->m_eWeight = weight::UltraLight; break;
+            case FW_LIGHT:          pFont->m_eWeight = weight::Light; break;
+            case FW_MEDIUM:     pFont->m_eWeight = weight::Medium; break;
+            case FW_SEMIBOLD:       pFont->m_eWeight = weight::SemiBold; break;
+            case FW_BOLD:           pFont->m_eWeight = weight::Bold; break;
+            case FW_EXTRABOLD:      pFont->m_eWeight = weight::UltraBold; break;
+            case FW_BLACK:          pFont->m_eWeight = weight::Black; break;
+                
+            case FW_NORMAL:
+            default:        pFont->m_eWeight = weight::Normal; break;
+        }
+
+        switch( aInfo.width )
+        {
+            case FWIDTH_ULTRA_CONDENSED:    pFont->m_eWidth = width::UltraCondensed; break;
+            case FWIDTH_EXTRA_CONDENSED:    pFont->m_eWidth = width::ExtraCondensed; break;
+            case FWIDTH_CONDENSED:          pFont->m_eWidth = width::Condensed; break;
+            case FWIDTH_SEMI_CONDENSED: pFont->m_eWidth = width::SemiCondensed; break;
+            case FWIDTH_SEMI_EXPANDED:      pFont->m_eWidth = width::SemiExpanded; break;
+            case FWIDTH_EXPANDED:           pFont->m_eWidth = width::Expanded; break;
+            case FWIDTH_EXTRA_EXPANDED: pFont->m_eWidth = width::ExtraExpanded; break;
+            case FWIDTH_ULTRA_EXPANDED: pFont->m_eWidth = width::UltraExpanded; break;
+
+            case FWIDTH_NORMAL:
+            default:                        pFont->m_eWidth = width::Normal; break;
+        }
+
+        pFont->m_ePitch = aInfo.pitch ? pitch::Fixed : pitch::Variable;
+        pFont->m_eItalic = aInfo.italicAngle == 0 ? italic::Upright : ( aInfo.italicAngle < 0 ? italic::Italic : italic::Oblique );
+
+        pFont->m_aEncoding = aInfo.symbolEncoded ? RTL_TEXTENCODING_SYMBOL : RTL_TEXTENCODING_UCS2;
+
+        pFont->m_aGlobalMetricY.width = pFont->m_aGlobalMetricX.width = aInfo.xMax - aInfo.xMin;
+        pFont->m_aGlobalMetricY.height = pFont->m_aGlobalMetricX.height = aInfo.yMax - aInfo.yMin;
+
+        if( aInfo.winAscent && aInfo.winDescent )
+        {
+            pFont->m_nAscend    = aInfo.winAscent;
+            pFont->m_nDescend   = aInfo.winDescent;
+            pFont->m_nLeading   = pFont->m_nAscend + pFont->m_nDescend - 1000;
+        }
+        else if( aInfo.typoAscender && aInfo.typoDescender )
+        {
+            pFont->m_nLeading   = aInfo.typoLineGap;
+            pFont->m_nAscend    = aInfo.typoAscender;
+            pFont->m_nDescend   = -aInfo.typoDescender;
+        }
+        else
+        {
+            pFont->m_nLeading   = aInfo.linegap;
+            pFont->m_nAscend    = aInfo.ascender;
+            pFont->m_nDescend   = -aInfo.descender;
+        }
+        
+        // last try: font bounding box
+        if( pFont->m_nAscend == 0 )
+            pFont->m_nAscend = aInfo.yMax;
+        if( pFont->m_nDescend == 0 )
+            pFont->m_nDescend = -aInfo.yMin;
+        if( pFont->m_nLeading == 0 )
+            pFont->m_nLeading = 15 * (pFont->m_nAscend+pFont->m_nDescend) / 100;
+
+        if( pFont->m_nAscend )
+            pFont->m_aGlobalMetricX.height = pFont->m_aGlobalMetricY.height = pFont->m_nAscend + pFont->m_nDescend;
+
+        // get type flags
+        pTTFontFile->m_nTypeFlags = (unsigned int)aInfo.typeFlags;
+
+        // get vertical substitutions flag
+        pFont->m_bHaveVerticalSubstitutedGlyphs = DoesVerticalSubstitution( pTTFont, 1 );
+
+        CloseTTFont( pTTFont );
+        bSuccess = true;
+    }
+#ifdef DEBUG
+    else
+        fprintf( stderr, "could not OpenTTFont \"%s\"\n", aFile.GetBuffer() );
+#endif
+
+    if( bSuccess )
+        m_pFontCache->updateFontCacheEntry( pFont, m_bFlushFontCache );
+    
+    return bSuccess;
+}
+
+// -------------------------------------------------------------------------
+
+void 
+PrintFontManager::addFcSystemFont (struct _FcPattern *fc_pattern)
+{
+  FcChar8 *fc_str = NULL;
+
+  if( FcPatternGetString( fc_pattern, FC_FILE, 0, &fc_str ) || !fc_str)
+    return;
+  
+  OString aFileName( (sal_Char *) fc_str );
+
+  addFontFile( aFileName, fc_pattern, false );
+}
+
+void
+PrintFontManager::addFcSystemFontSet( FcFontSet *fc_set )
+{
+  int i;
+  if (!fc_set)
+    return;
+
+  for (i = 0; i < fc_set->nfont; i++)
+    {
+      FcPattern *font = fc_set->fonts[i];
+      if (!font)
+	continue;
+      addFcSystemFont( font );
+    }
+}
+
+void PrintFontManager::initialize( void* pInitDisplay )
+{
+    long aDirEntBuffer[ (sizeof(struct dirent)+_PC_NAME_MAX)+1 ];
+
+    if( ! m_pFontCache )
+    {
+#ifdef DEBUG
+        fprintf( stderr, "creating font cache ... " );
+        clock_t aStart;
+        struct tms tms;
+        aStart = times( &tms );
+#endif
+        m_pFontCache = new FontCache();
+#ifdef DEBUG
+#ifndef CLK_TCK
+#define CLK_TCK 1000
+#endif
+        clock_t aStop = times( &tms );
+        fprintf( stderr, "done in %lf s\n", (double)(aStop - aStart)/(double)CLK_TCK );
+#endif
+    }
+
+    m_bFlushFontCache = false;
+
+    // initialize may be called twice in the future
+    {
+        for( ::std::hash_map< fontID, PrintFont* >::const_iterator it = m_aFonts.begin(); it != m_aFonts.end(); ++it )
+            delete (*it).second;
+        m_nNextFontID = 1;
+        m_aFonts.clear();
+    }
+
+#ifdef DEBUG
+    clock_t aStart;
+    clock_t aStep1;
+    clock_t aStep2;
+    clock_t aStep3;
+    int nBuiltinFonts = 0;
+    
+    struct tms tms;
+
+    aStart = times( &tms );
+#endif
+
+    // part one - look for downloadable fonts
+    FcConfig *config = FcInitLoadConfigAndFonts ();
+    if (!config)
+      fprintf (stderr, "Can't init fontconfig\n");
+
+    addFcSystemFontSet( FcConfigGetFonts( config, FcSetSystem ) );
+    addFcSystemFontSet( FcConfigGetFonts( config, FcSetApplication ) );
+
+#ifdef DEBUG
+    aStep1 = times( &tms );
+#endif
+
+    // part two - look for metrics for builtin printer fonts
+    OString aPath( OUStringToOString( getPrinterPath(), osl_getThreadTextEncoding() ) );
+    sal_Int32 nIndex = 0;
+    do
+    {
+        OString aDir( aPath.getToken( 0, ':', nIndex ) );
+        aDir += "/"PRINTER_METRICDIR;
+        DIR* pDIR = opendir( aDir.getStr() );
+        if( pDIR )
+        {
+            struct dirent* pDirEntry = (struct dirent*)aDirEntBuffer;
+
+            // get cache information
+            while( ! readdir_r( pDIR, (struct dirent*)aDirEntBuffer, &pDirEntry ) &&
+		   pDirEntry )
+            {
+                ByteString aFile( aDir );
+                aFile += '/';
+                aFile += pDirEntry->d_name;
+
+                struct stat aStat;
+                if( ! stat( aFile.GetBuffer(), &aStat )
+                    && S_ISREG( aStat.st_mode ) )
+                {
+		    OString aFileName( aFile );
+                    OString aExt( aFileName.copy( aFileName.lastIndexOf( '.' )+1 ) );
+
+                    if( aExt.equalsIgnoreAsciiCase( "afm" ) )
+			addFontFile( aFileName, NULL, true );
+                }
+            }
+            closedir( pDIR );
+        }
+    } while( nIndex != -1 );
+
+#ifdef DEBUG
+    aStep2 = times( &tms );
+#endif
+
+    // part three - fill in family styles
+    ::std::hash_map< fontID, PrintFont* >::iterator font_it;
+    for (font_it = m_aFonts.begin(); font_it != m_aFonts.end(); ++font_it)
+    {
+        ::std::hash_map< int, family::type >::const_iterator it = 
+              m_aFamilyTypes.find( font_it->second->m_nFamilyName );
+        if (it != m_aFamilyTypes.end())
+            continue;
+        const ::rtl::OUString& rFamily =
+            m_pAtoms->getString( ATOM_FAMILYNAME, font_it->second->m_nFamilyName);
+        family::type eType = matchFamilyName( rFamily );
+        m_aFamilyTypes[ font_it->second->m_nFamilyName ] = eType;
+    }
+
+#ifdef DEBUG
+    aStep3 = times( &tms );
+    fprintf( stderr, "PrintFontManager::initialize: collected %d fonts (%d builtin)\n", m_aFonts.size(), nBuiltinFonts );
+    fprintf( stderr, "Step 1 took %lf seconds\n", (double)(aStep1 - aStart)/(double)CLK_TCK );
+    fprintf( stderr, "Step 2 took %lf seconds\n", (double)(aStep2 - aStep1)/(double)CLK_TCK );
+    fprintf( stderr, "Step 3 took %lf seconds\n", (double)(aStep3 - aStep2)/(double)CLK_TCK );
+#endif
+
+    m_bFlushFontCache = true;
+    m_pFontCache->flush();
+}
+
+// -------------------------------------------------------------------------
+inline bool
+equalPitch (psp::pitch::type from, psp::pitch::type to)
+{
+    return from == to;
+} 
+
+inline bool
+equalWeight (psp::weight::type from, psp::weight::type to)
+{
+    return from > to ? (from - to) <= 3 : (to - from) <= 3;
+}
+
+inline bool
+equalItalic (psp::italic::type from, psp::italic::type to)
+{
+    if ( (from == psp::italic::Italic) || (from == psp::italic::Oblique) )
+        return (to == psp::italic::Italic) || (to == psp::italic::Oblique); 
+    return to == from;
+}
+inline bool
+equalEncoding (rtl_TextEncoding from, rtl_TextEncoding to)
+{
+    if ((from == RTL_TEXTENCODING_ISO_8859_1) || (from == RTL_TEXTENCODING_MS_1252))
+        return (to == RTL_TEXTENCODING_ISO_8859_1) || (to == RTL_TEXTENCODING_MS_1252);
+    return from == to;
+}
+
+void PrintFontManager::getFontList( ::std::list< fontID >& rFontIDs, const PPDParser* pParser ) const
+{
+    rFontIDs.clear();
+    ::std::hash_map< fontID, PrintFont* >::const_iterator it;
+    ::std::list< PrintFont* > aBuiltinFonts;
+
+    for( it = m_aFonts.begin(); it != m_aFonts.end(); ++it )
+    {
+        if( pParser && it->second->m_eType == fonttype::Builtin )
+        {
+            int nFonts = pParser->getFonts();
+            String aPSName = m_pAtoms->getString( ATOM_PSNAME, it->second->m_nPSName );
+            for( int j = 0; j < nFonts; j++ )
+            {
+                if( aPSName.Equals( pParser->getFont( j ) ) )
+                {
+                    rFontIDs.push_back( it->first );
+                    aBuiltinFonts.push_back( it->second );
+                    break;
+                }
+            }
+        }
+        else
+            rFontIDs.push_back( it->first );
+    }
+
+    if( pParser )
+    {
+        // remove doubles for builtins
+        ::std::list< fontID >::iterator font_it;
+        ::std::list< fontID >::iterator temp_it;
+        font_it = rFontIDs.begin();
+        while( font_it != rFontIDs.end() )
+        {
+            temp_it = font_it;
+            ++temp_it;
+            PrintFont* pFont = getFont( *font_it );
+            if( pFont->m_eType != fonttype::Builtin )
+            {
+                const OUString& rFontFamily( m_pAtoms->getString( ATOM_FAMILYNAME, pFont->m_nFamilyName ) );
+
+                for( ::std::list< PrintFont* >::const_iterator bit = aBuiltinFonts.begin();
+                     bit != aBuiltinFonts.end(); ++bit )
+                {
+                    if( ! equalItalic  (pFont->m_eItalic, (*bit)->m_eItalic) )
+                        continue;
+                    if( ! equalWeight  (pFont->m_eWeight, (*bit)->m_eWeight) )
+                        continue;
+                    if( ! equalPitch   (pFont->m_ePitch,  (*bit)->m_ePitch) )
+                        continue;
+                    if( ! equalEncoding(pFont->m_aEncoding, (*bit)->m_aEncoding) )
+                        continue;
+                    const OUString& rBuiltinFamily( m_pAtoms->getString( ATOM_FAMILYNAME, (*bit)->m_nFamilyName ) );
+                    if( rFontFamily.equalsIgnoreAsciiCase( rBuiltinFamily ) )
+                    {
+                        // remove double
+                        rFontIDs.erase( font_it );
+                        break;
+                    }
+                }
+            }
+            font_it = temp_it;
+        }
+    }
+}
+
+// -------------------------------------------------------------------------
+
+void PrintFontManager::fillPrintFontInfo( PrintFont* pFont, FastPrintFontInfo& rInfo ) const
+{
+    ::std::hash_map< int, family::type >::const_iterator style_it =
+          m_aFamilyTypes.find( pFont->m_nFamilyName );
+    rInfo.m_eType           = pFont->m_eType;
+    rInfo.m_aFamilyName     = m_pAtoms->getString( ATOM_FAMILYNAME, pFont->m_nFamilyName );
+    rInfo.m_eFamilyStyle    = style_it != m_aFamilyTypes.end() ? style_it->second : family::Unknown;
+    rInfo.m_eItalic         = pFont->m_eItalic;
+    rInfo.m_eWidth          = pFont->m_eWidth;
+    rInfo.m_eWeight         = pFont->m_eWeight;
+    rInfo.m_ePitch          = pFont->m_ePitch;
+    rInfo.m_aEncoding       = pFont->m_aEncoding;
+    rInfo.m_aAliases.clear();
+    for( ::std::list< int >::iterator it = pFont->m_aAliases.begin(); it != pFont->m_aAliases.end(); ++it )
+        rInfo.m_aAliases.push_back( m_pAtoms->getString( ATOM_FAMILYNAME, *it ) );
+}
+
+// -------------------------------------------------------------------------
+
+void PrintFontManager::fillPrintFontInfo( PrintFont* pFont, PrintFontInfo& rInfo ) const
+{
+    ensureAnalysed( pFont );
+
+    fillPrintFontInfo( pFont, static_cast< FastPrintFontInfo& >( rInfo ) );
+
+    rInfo.m_nAscend         = pFont->m_nAscend;
+    rInfo.m_nDescend        = pFont->m_nDescend;
+    rInfo.m_nLeading        = pFont->m_nLeading;
+    rInfo.m_nWidth          = pFont->m_aGlobalMetricX.width < pFont->m_aGlobalMetricY.width ? pFont->m_aGlobalMetricY.width : pFont->m_aGlobalMetricX.width;
+}
+
+// -------------------------------------------------------------------------
+
+void PrintFontManager::getFontListWithInfo( ::std::list< PrintFontInfo >& rFonts, const PPDParser* pParser ) const
+{
+    rFonts.clear();
+    ::std::list< fontID > aFontList;
+    getFontList( aFontList, pParser );
+
+    ::std::list< fontID >::iterator it;
+    for( it = aFontList.begin(); it != aFontList.end(); ++it )
+    {
+        PrintFontInfo aInfo;
+        aInfo.m_nID = *it;
+        fillPrintFontInfo( getFont( *it ), aInfo );
+        rFonts.push_back( aInfo );
+    }
+}
+
+// -------------------------------------------------------------------------
+
+void PrintFontManager::getFontListWithFastInfo( ::std::list< FastPrintFontInfo >& rFonts, const PPDParser* pParser ) const
+{
+    rFonts.clear();
+    ::std::list< fontID > aFontList;
+    getFontList( aFontList, pParser );
+
+    ::std::list< fontID >::iterator it;
+    for( it = aFontList.begin(); it != aFontList.end(); ++it )
+    {
+        FastPrintFontInfo aInfo;
+        aInfo.m_nID = *it;
+        fillPrintFontInfo( getFont( *it ), aInfo );
+        rFonts.push_back( aInfo );
+    }
+}
+
+// -------------------------------------------------------------------------
+
+bool PrintFontManager::getFontInfo( fontID nFontID, PrintFontInfo& rInfo ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    if( pFont )
+    {
+        rInfo.m_nID = nFontID;
+        fillPrintFontInfo( pFont, rInfo );
+    }
+    return pFont ? true : false;
+}
+
+// -------------------------------------------------------------------------
+
+bool PrintFontManager::getFontFastInfo( fontID nFontID, FastPrintFontInfo& rInfo ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    if( pFont )
+    {
+        rInfo.m_nID = nFontID;
+        fillPrintFontInfo( pFont, rInfo );
+    }
+    return pFont ? true : false;
+}
+
+// -------------------------------------------------------------------------
+
+family::type PrintFontManager::matchFamilyName( const ::rtl::OUString& rFamily ) const
+{
+    typedef struct { 
+        const char*  mpName; 
+        sal_uInt16   mnLength; 
+        family::type meType; 
+    } family_t; 
+
+#define InitializeClass( p, a ) p, sizeof(p) - 1, a
+    const family_t pFamilyMatch[] =  {
+        { InitializeClass( "arial",                  family::Swiss )  },
+        { InitializeClass( "arioso",                 family::Script ) },
+        { InitializeClass( "avant garde",            family::Swiss )  },
+        { InitializeClass( "avantgarde",             family::Swiss )  },
+        { InitializeClass( "bembo",                  family::Roman )  },
+        { InitializeClass( "bookman",                family::Roman )  },
+        { InitializeClass( "conga",                  family::Roman )  },
+        { InitializeClass( "courier",                family::Modern ) },
+        { InitializeClass( "curl",                   family::Script ) },
+        { InitializeClass( "fixed",                  family::Modern ) },
+        { InitializeClass( "gill",                   family::Swiss )  },
+        { InitializeClass( "helmet",                 family::Modern ) },
+        { InitializeClass( "helvetica",              family::Swiss )  },
+        { InitializeClass( "international",          family::Modern ) },
+        { InitializeClass( "lucida",                 family::Swiss )  },
+        { InitializeClass( "new century schoolbook", family::Roman )  },
+        { InitializeClass( "palatino",               family::Roman )  },
+        { InitializeClass( "roman",                  family::Roman )  },
+        { InitializeClass( "sans serif",             family::Swiss )  },
+        { InitializeClass( "sansserif",              family::Swiss )  },
+        { InitializeClass( "serf",                   family::Roman )  },
+        { InitializeClass( "serif",                  family::Roman )  },
+        { InitializeClass( "times",                  family::Roman )  },
+        { InitializeClass( "utopia",                 family::Roman )  },
+        { InitializeClass( "zapf chancery",          family::Script ) },
+        { InitializeClass( "zapfchancery",           family::Script ) }
+    };
+
+    rtl::OString aFamily = rtl::OUStringToOString( rFamily, RTL_TEXTENCODING_ASCII_US );
+    sal_uInt32 nLower = 0; 
+    sal_uInt32 nUpper = sizeof(pFamilyMatch) / sizeof(pFamilyMatch[0]); 
+
+    while( nLower < nUpper )
+    {
+        sal_uInt32 nCurrent = (nLower + nUpper) / 2;
+        const family_t* pHaystack = pFamilyMatch + nCurrent;
+        sal_Int32  nComparison =
+            rtl_str_compareIgnoreAsciiCase_WithLength
+            ( 
+             aFamily.getStr(), aFamily.getLength(),
+             pHaystack->mpName, pHaystack->mnLength
+             );
+        
+        if( nComparison < 0 )
+            nUpper = nCurrent;
+        else 
+            if( nComparison > 0 )
+                nLower = nCurrent + 1;
+            else
+                return pHaystack->meType;
+    }
+
+    return family::Unknown;
+}
+
+// -------------------------------------------------------------------------
+
+family::type PrintFontManager::getFontFamilyType( fontID nFontID ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    if( !pFont )
+        return family::Unknown;
+
+    ::std::hash_map< int, family::type >::const_iterator it = 
+          m_aFamilyTypes.find( pFont->m_nFamilyName );
+    return (it != m_aFamilyTypes.end()) ? it->second : family::Unknown;
+}
+
+
+// -------------------------------------------------------------------------
+
+const ::rtl::OUString& PrintFontManager::getFontFamily( fontID nFontID ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    ensureAnalysed( pFont );
+    return m_pAtoms->getString( ATOM_FAMILYNAME, pFont ? pFont->m_nFamilyName : INVALID_ATOM );
+}
+
+// -------------------------------------------------------------------------
+
+OString PrintFontManager::getAfmFile( PrintFont* pFont ) const
+{
+    OString aMetricPath;
+    if( pFont )
+    {
+        switch( pFont->m_eType )
+        {
+            case fonttype::Type1:
+            {
+                Type1FontFile* pPSFont = static_cast< Type1FontFile* >(pFont);
+                aMetricPath = getDirectory( pPSFont->m_nDirectory );
+                aMetricPath += "/";
+                aMetricPath += pPSFont->m_aMetricFile;
+            }
+            break;
+            case fonttype::Builtin:
+            {
+                BuiltinFont* pBuiltinFont = static_cast< BuiltinFont* >(pFont);
+                aMetricPath = getDirectory( pBuiltinFont->m_nDirectory );
+                aMetricPath += "/";
+                aMetricPath += pBuiltinFont->m_aMetricFile;
+            }
+            break;
+        }
+    }
+    return aMetricPath;
+}
+
+// -------------------------------------------------------------------------
+
+OString PrintFontManager::getFontFile( PrintFont* pFont ) const
+{
+    OString aPath;
+
+    if( pFont && pFont->m_eType == fonttype::Type1 )
+    {
+        Type1FontFile* pPSFont = static_cast< Type1FontFile* >(pFont);
+        ::std::hash_map< int, OString >::const_iterator it = m_aAtomToDir.find( pPSFont->m_nDirectory );
+        aPath = it->second;
+        aPath += "/";
+        aPath += pPSFont->m_aFontFile;
+    }
+    else if( pFont && pFont->m_eType == fonttype::TrueType )
+    {
+        TrueTypeFontFile* pTTFont = static_cast< TrueTypeFontFile* >(pFont);
+        ::std::hash_map< int, OString >::const_iterator it = m_aAtomToDir.find( pTTFont->m_nDirectory );
+        aPath = it->second;
+        aPath += "/";
+        aPath += pTTFont->m_aFontFile;
+    }
+    return aPath;
+}
+
+// -------------------------------------------------------------------------
+
+const ::rtl::OUString& PrintFontManager::getPSName( fontID nFontID ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    ensureAnalysed( pFont );
+    return m_pAtoms->getString( ATOM_PSNAME, pFont ? pFont->m_nPSName : INVALID_ATOM );
+}
+
+// -------------------------------------------------------------------------
+
+const CharacterMetric& PrintFontManager::getGlobalFontMetric( fontID nFontID, bool bHorizontal ) const
+{
+    static CharacterMetric aMetric;
+    PrintFont* pFont = getFont( nFontID );
+    return pFont ? ( bHorizontal ? pFont->m_aGlobalMetricX : pFont->m_aGlobalMetricY ) : aMetric;
+}
+
+// -------------------------------------------------------------------------
+
+int PrintFontManager::getFontAscend( fontID nFontID ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    ensureAnalysed( pFont );
+    return pFont->m_nAscend;
+}
+
+// -------------------------------------------------------------------------
+
+int PrintFontManager::getFontDescend( fontID nFontID ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    ensureAnalysed( pFont );
+    return pFont->m_nDescend;
+}
+
+// -------------------------------------------------------------------------
+
+int PrintFontManager::getFontLeading( fontID nFontID ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    ensureAnalysed( pFont );
+    return pFont->m_nLeading;
+}
+
+// -------------------------------------------------------------------------
+
+bool PrintFontManager::hasVerticalSubstitutions( fontID nFontID ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    ensureAnalysed( pFont );
+    return pFont->m_bHaveVerticalSubstitutedGlyphs;
+}
+
+// -------------------------------------------------------------------------
+
+void PrintFontManager::hasVerticalSubstitutions( fontID nFontID,
+    const sal_Unicode* pCharacters, int nCharacters, bool* pHasSubst ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    ensureAnalysed( pFont );
+
+    if( ! pFont->m_bHaveVerticalSubstitutedGlyphs )
+        memset( pHasSubst, 0, sizeof(bool)*nCharacters );
+    else
+    {
+        for( int i = 0; i < nCharacters; i++ )
+        {
+            sal_Unicode code = pCharacters[i];
+            if( ! pFont->m_pMetrics ||
+                ! ( pFont->m_pMetrics->m_aPages[ code >> 11 ] & ( 1 << ( ( code >> 8 ) & 7 ) ) ) )
+                pFont->queryMetricPage( code >> 8, m_pAtoms );
+            ::std::hash_map< sal_Unicode, bool >::const_iterator it = pFont->m_pMetrics->m_bVerticalSubstitutions.find( code );
+            pHasSubst[i] = it != pFont->m_pMetrics->m_bVerticalSubstitutions.end();
+        }
+    }
+}
+
+// -------------------------------------------------------------------------
+
+const ::std::list< KernPair >& PrintFontManager::getKernPairs( fontID nFontID, bool bVertical ) const
+{
+    static ::std::list< KernPair > aEmpty;
+    
+    PrintFont* pFont = getFont( nFontID );
+    if( ! pFont )
+        return aEmpty;
+    
+    if( ! pFont->m_pMetrics || ! pFont->m_pMetrics->m_bKernPairsQueried )
+        pFont->queryMetricPage( 0, m_pAtoms );
+    if( ! pFont->m_pMetrics || ! pFont->m_pMetrics->m_bKernPairsQueried )
+        return aEmpty;
+    return bVertical ? pFont->m_pMetrics->m_aYKernPairs : pFont->m_pMetrics->m_aXKernPairs;
+}
+
+// -------------------------------------------------------------------------
+
+bool PrintFontManager::isFontDownloadingAllowed( fontID nFont ) const
+{
+    static const char* pEnable = getenv( "PSPRINT_ENABLE_TTF_COPYRIGHTAWARENESS" );
+    bool bRet = true;
+
+    if( pEnable && *pEnable )
+    {
+        PrintFont* pFont = getFont( nFont );
+        if( pFont && pFont->m_eType == fonttype::TrueType )
+        {
+            TrueTypeFontFile* pTTFontFile = static_cast<TrueTypeFontFile*>(pFont);
+            if( pTTFontFile->m_nTypeFlags & 0x80000000 )
+            {
+                TrueTypeFont* pTTFont = NULL;
+                ByteString aFile = getFontFile( pFont );
+                if( OpenTTFont( aFile.GetBuffer(), pTTFontFile->m_nCollectionEntry < 0 ? 0 : pTTFontFile->m_nCollectionEntry, &pTTFont ) == SF_OK )
+                {
+                    // get type flags
+                    TTGlobalFontInfo aInfo;
+                    GetTTGlobalFontInfo( pTTFont, & aInfo );
+                    pTTFontFile->m_nTypeFlags = (unsigned int)aInfo.typeFlags;
+                    CloseTTFont( pTTFont );
+                }
+            }
+
+            unsigned int nCopyrightFlags = pTTFontFile->m_nTypeFlags & 0x0e;
+
+            // font embedding is allowed if either
+            //   no restriction at all (bit 1 clear)
+            //   printing allowed (bit 1 set, bit 2 set )
+            bRet = ! ( nCopyrightFlags & 0x02 ) || ( nCopyrightFlags & 0x04 );
+        }
+    }
+    return bRet;
+}
+
+// -------------------------------------------------------------------------
+
+bool PrintFontManager::getMetrics( fontID nFontID, const sal_Unicode* pString, int nLen, CharacterMetric* pArray, bool bVertical ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    if( ! pFont )
+        return false;
+
+    ensureAnalysed( pFont );
+
+    for( int i = 0; i < nLen; i++ )
+    {
+        if( ! pFont->m_pMetrics ||
+            ! ( pFont->m_pMetrics->m_aPages[ pString[i] >> 11 ] & ( 1 << ( ( pString[i] >> 8 ) & 7 ) ) ) )
+            pFont->queryMetricPage( pString[i] >> 8, m_pAtoms );
+        pArray[i].width = pArray[i].height = -1;
+        if( pFont->m_pMetrics )
+        {
+            int effectiveCode = pString[i];
+            effectiveCode |= bVertical ? 1 << 16 : 0;
+            ::std::hash_map< int, CharacterMetric >::const_iterator it =
+                  pFont->m_pMetrics->m_aMetrics.find( effectiveCode );
+            if( it != pFont->m_pMetrics->m_aMetrics.end() )
+                pArray[ i ] = it->second;
+        }
+    }
+
+    return true;
+}
+
+// -------------------------------------------------------------------------
+
+bool PrintFontManager::getMetrics( fontID nFontID, sal_Unicode minCharacter, sal_Unicode maxCharacter, CharacterMetric* pArray, bool bVertical ) const
+{
+    PrintFont* pFont = getFont( nFontID );
+    if( ! pFont )
+        return false;
+
+    ensureAnalysed( pFont );
+
+    for( sal_Unicode code = minCharacter; code <= maxCharacter; code++ )
+    {
+        if( ! pFont->m_pMetrics ||
+            ! ( pFont->m_pMetrics->m_aPages[ code >> 11 ] & ( 1 << ( ( code >> 8 ) & 7 ) ) ) )
+            pFont->queryMetricPage( code >> 8, m_pAtoms );
+        pArray[ code - minCharacter ].width     = -1;
+        pArray[ code - minCharacter ].height    = -1;
+        if( pFont->m_pMetrics )
+        {
+            int effectiveCode = code;
+            effectiveCode |= bVertical ? 1 << 16 : 0;
+            ::std::hash_map< int, CharacterMetric >::const_iterator it =
+                  pFont->m_pMetrics->m_aMetrics.find( effectiveCode );
+            if( it != pFont->m_pMetrics->m_aMetrics.end() )
+                pArray[ code - minCharacter ] = it->second;
+        }
+    }
+    return true;
+}
