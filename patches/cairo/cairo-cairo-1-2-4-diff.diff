--- /dev/null
+++ cairo/cairo-1.2.4.diff
@@ -0,0 +1,805 @@
+--- /dev/null
++++ misc/build/cairo-1.2.4/makefile.mk
+@@ -0,0 +1,11 @@
++PRJ=..$/..$/..$/..
++
++TARGET=source
++
++.INCLUDE :  svpre.mk
++.INCLUDE :  settings.mk
++.INCLUDE :  sv.mk
++
++all:
++	cd pixman$/src; $(MAKECMD) subdmake=true $(MFLAGS) $(CALLMACROS)
++	cd src; $(MAKECMD) subdmake=true $(MFLAGS) $(CALLMACROS)
+dummy line to avoid confusing diff-mode
+--- /dev/null
++++ misc/build/cairo-1.2.4/config.h
+@@ -0,0 +1,122 @@
++/* define if glitz backend can be tested against agl */
++/* #undef CAIRO_CAN_TEST_GLITZ_AGL_SURFACE */
++
++/* define if glitz backend can be tested against egl */
++/* #undef CAIRO_CAN_TEST_GLITZ_EGL_SURFACE */
++
++/* define if glitz backend can be tested against glx */
++/* #undef CAIRO_CAN_TEST_GLITZ_GLX_SURFACE */
++
++/* define if glitz backend can be tested against wgl */
++/* #undef CAIRO_CAN_TEST_GLITZ_WGL_SURFACE */
++
++/* Define to 1 if the PDF backend can be tested (need poppler and other
++   dependencies for pdf2png) */
++/* #undef CAIRO_CAN_TEST_PDF_SURFACE */
++
++/* Define to 1 if the SVG backend can be tested (need librsvg) */
++/* #undef CAIRO_CAN_TEST_SVG_SURFACE */
++
++/* define in the extra test surface have been built into cairo for the test
++   suite */
++/* #undef CAIRO_HAS_TEST_SURFACES */
++
++/* Define to 1 if you have the <dlfcn.h> header file. */
++/* #undef HAVE_DLFCN_H */
++
++/* Define to 1 if you have the `FcFini' function. */
++/* #undef HAVE_FCFINI */
++
++/* FT_Bitmap_Size structure includes y_ppem field */
++/* #undef HAVE_FT_BITMAP_SIZE_Y_PPEM */
++
++/* Define to 1 if you have the `FT_GlyphSlot_Embolden' function. */
++/* #undef HAVE_FT_GLYPHSLOT_EMBOLDEN */
++
++/* Define to 1 if you have the `FT_Load_Sfnt_Table' function. */
++/* #undef HAVE_FT_LOAD_SFNT_TABLE */
++
++/* Whether you have gcov */
++/* #undef HAVE_GCOV */
++
++/* Define to 1 if you have the <inttypes.h> header file. */
++/* #undef HAVE_INTTYPES_H */
++
++/* Define to 1 if you have the <memory.h> header file. */
++#define HAVE_MEMORY_H 1
++
++/* Define to 1 if you have the <pthread.h> header file. */
++/* #undef HAVE_PTHREAD_H */
++
++/* Define to 1 if you have the <signal.h> header file. */
++#define HAVE_SIGNAL_H 1
++
++/* Define to 1 if you have the <stdint.h> header file. */
++/* #undef HAVE_STDINT_H */
++
++/* Define to 1 if you have the <stdlib.h> header file. */
++#define HAVE_STDLIB_H 1
++
++/* Define to 1 if you have the <strings.h> header file. */
++/* #undef HAVE_STRINGS_H */
++
++/* Define to 1 if you have the <string.h> header file. */
++#define HAVE_STRING_H 1
++
++/* Define to 1 if you have the <sys/int_types.h> header file. */
++/* #undef HAVE_SYS_INT_TYPES_H */
++
++/* Define to 1 if you have the <sys/stat.h> header file. */
++#define HAVE_SYS_STAT_H 1
++
++/* Define to 1 if you have the <sys/types.h> header file. */
++#define HAVE_SYS_TYPES_H 1
++
++/* Define to 1 if the system has the type `uint128_t'. */
++/* #undef HAVE_UINT128_T */
++
++/* Define to 1 if the system has the type `uint64_t'. */
++#define HAVE_UINT64_T 1
++
++/* Define to 1 if you have the <unistd.h> header file. */
++#define HAVE_UNISTD_H 1
++
++/* Define to 1 if you have the `vasnprintf' function. */
++/* #undef HAVE_VASNPRINTF */
++
++/* Define to 1 if you have the `XrmFinalize' function. */
++/* #undef HAVE_XRMFINALIZE */
++
++/* Name of package */
++#define PACKAGE "cairo"
++
++/* Define to the address where bug reports for this package should be sent. */
++#define PACKAGE_BUGREPORT "http://bugs.freedesktop.org/enter_bug.cgi?product=cairo"
++
++/* Define to the full name of this package. */
++#define PACKAGE_NAME "cairo"
++
++/* Define to the full name and version of this package. */
++#define PACKAGE_STRING "cairo 1.2.4"
++
++/* Define to the one symbol short name of this package. */
++#define PACKAGE_TARNAME "cairo"
++
++/* Define to the version of this package. */
++#define PACKAGE_VERSION "1.2.4"
++
++/* Define to 1 if you have the ANSI C header files. */
++#define STDC_HEADERS 1
++
++/* use MMX compiler intrinsics */
++#define USE_MMX 1
++
++/* Version number of package */
++#define VERSION "1.2.4"
++
++/* Define to 1 if your processor stores words with the most significant byte
++   first (like Motorola and SPARC, unlike Intel and VAX). */
++/* #undef WORDS_BIGENDIAN */
++
++/* Define to 1 if the X Window System is missing or not being used. */
++#define X_DISPLAY_MISSING 1
+dummy line to avoid confusing diff-mode
+--- misc/build/cairo-1.2.4/pixman/src/fbpict.c
++++ misc/build/cairo-1.2.4/pixman/src/fbpict.c
+@@ -1923,8 +1923,13 @@
+ static unsigned int detectCPUFeatures(void) {
+     unsigned int result, features;
+     char vendor[13];
++#ifdef _MSC_VER
++    int vendor0 = 0, vendor1, vendor2;
++#endif
+     vendor[0] = 0;
+     vendor[12] = 0;
++
++#ifdef __GNUC__
+     /* see p. 118 of amd64 instruction set manual Vol3 */
+     /* We need to be careful about the handling of %ebx and
+      * %esp here. We can't declare either one as clobbered
+@@ -1966,6 +1966,41 @@
+              :
+              : "%eax", "%ecx", "%edx"
+         );
++#elif defined (_MSC_VER)
++    _asm {
++      pushfd
++      pop eax
++      mov ecx, eax
++      xor eax, 00200000h
++      push eax
++      popfd
++      pushfd
++      pop eax
++      mov edx, 0
++      xor eax, ecx
++      jz nocpuid
++
++      mov eax, 0
++      push ebx
++      cpuid
++      mov eax, ebx
++      pop ebx
++      mov vendor0, eax
++      mov vendor1, edx
++      mov vendor2, ecx
++      mov eax, 1
++      push ebx
++      cpuid
++      pop ebx
++    nocpuid:
++      mov result, edx
++    }
++    memmove (vendor+0, &vendor0, 4);
++    memmove (vendor+4, &vendor1, 4);
++    memmove (vendor+8, &vendor2, 4);
++#else
++#error unsupported compiler
++#endif
+ 
+     features = 0;
+     if (result) {
+@@ -1980,6 +1980,7 @@
+             features |= SSE2;
+         if ((result & MMX) && !(result & SSE) && (strcmp(vendor, "AuthenticAMD") == 0)) {
+             /* check for AMD MMX extensions */
++#ifdef __GNUC__
+ 
+             unsigned int result;
+             __asm__("push %%ebx\n"
+@@ -1997,6 +1997,22 @@
+                     :
+                     : "%eax", "%ecx", "%edx"
+                 );
++#endif
++#ifdef _MSC_VER
++	    _asm {
++	      push ebx
++	      mov eax, 80000000h
++	      cpuid
++	      xor edx, edx
++	      cmp eax, 1
++	      jge notamd
++	      mov eax, 80000001h
++	      cpuid
++	    notamd:
++	      pop ebx
++	      mov result, edx
++	    }
++#endif
+             if (result & (1<<22))
+                 features |= MMX_Extensions;
+         }
+dummy line to avoid confusing diff-mode
+--- misc/build/cairo-1.2.4/pixman/src/fbmmx.c
++++ misc/build/cairo-1.2.4/pixman/src/fbmmx.c
+@@ -80,47 +80,82 @@
+ 
+ /* --------------- MMX primitivess ------------------------------------ */
+ 
++#ifdef __GNUC__
+ typedef unsigned long long ullong;
++typedef ullong mmxdatafield;
++#endif
++#ifdef _MSC_VER
++typedef unsigned __int64 ullong;
++typedef __m64 mmxdatafield;
++#endif
+ 
+ typedef struct
+ {
+-    ullong mmx_4x00ff;
+-    ullong mmx_4x0080;
+-    ullong mmx_565_rgb;
+-    ullong mmx_565_unpack_multiplier;
+-    ullong mmx_565_r;
+-    ullong mmx_565_g;
+-    ullong mmx_565_b;
+-    ullong mmx_mask_0;
+-    ullong mmx_mask_1;
+-    ullong mmx_mask_2;
+-    ullong mmx_mask_3;
+-    ullong mmx_full_alpha;
+-    ullong mmx_ffff0000ffff0000;
+-    ullong mmx_0000ffff00000000;
+-    ullong mmx_000000000000ffff;
++    mmxdatafield mmx_4x00ff;
++    mmxdatafield mmx_4x0080;
++    mmxdatafield mmx_565_rgb;
++    mmxdatafield mmx_565_unpack_multiplier;
++    mmxdatafield mmx_565_r;
++    mmxdatafield mmx_565_g;
++    mmxdatafield mmx_565_b;
++    mmxdatafield mmx_mask_0;
++    mmxdatafield mmx_mask_1;
++    mmxdatafield mmx_mask_2;
++    mmxdatafield mmx_mask_3;
++    mmxdatafield mmx_full_alpha;
++    mmxdatafield mmx_ffff0000ffff0000;
++    mmxdatafield mmx_0000ffff00000000;
++    mmxdatafield mmx_000000000000ffff;
+ } MMXData;
+ 
+ static const MMXData c =
+ {
++#ifdef __GNUC__
+     .mmx_4x00ff =			0x00ff00ff00ff00ffULL,
+     .mmx_4x0080 =			0x0080008000800080ULL,
+     .mmx_565_rgb =			0x000001f0003f001fULL,
++    .mmx_565_unpack_multiplier =	0x0000008404100840ULL,
+     .mmx_565_r =			0x000000f800000000ULL,
+     .mmx_565_g =			0x0000000000fc0000ULL,
+     .mmx_565_b =			0x00000000000000f8ULL,
+     .mmx_mask_0 =			0xffffffffffff0000ULL,
+     .mmx_mask_1 =			0xffffffff0000ffffULL,
+     .mmx_mask_2 =			0xffff0000ffffffffULL,
+     .mmx_mask_3 =			0x0000ffffffffffffULL,
+     .mmx_full_alpha =			0x00ff000000000000ULL,
+-    .mmx_565_unpack_multiplier =	0x0000008404100840ULL,
+     .mmx_ffff0000ffff0000 =		0xffff0000ffff0000ULL,
+     .mmx_0000ffff00000000 =		0x0000ffff00000000ULL,
+     .mmx_000000000000ffff =		0x000000000000ffffULL,
++#endif
++#ifdef _MSC_VER
++    { 0x00ff00ff00ff00ffUI64 },
++    { 0x0080008000800080UI64 },
++    { 0x000001f0003f001fUI64 },
++    { 0x0000008404100840UI64 },
++    { 0x000000f800000000UI64 },
++    { 0x0000000000fc0000UI64 },
++    { 0x00000000000000f8UI64 },
++    { 0xffffffffffff0000UI64 },
++    { 0xffffffff0000ffffUI64 },
++    { 0xffff0000ffffffffUI64 },
++    { 0x0000ffffffffffffUI64 },
++    { 0x00ff000000000000UI64 },
++    { 0xffff0000ffff0000UI64 },
++    { 0x0000ffff00000000UI64 },
++    { 0x000000000000ffffUI64 },
++#endif
+ };
+ 
++#ifdef _MSC_VER
++#define __inline__ __forceinline
++#endif
++
++#ifdef __GNUC__
+ #define MC(x) ((__m64) c.mmx_##x)
++#endif
++#ifdef _MSC_VER
++#define MC(x) c.mmx_##x
++#endif
+ 
+ static __inline__ __m64
+ shift (__m64 v, int s)
+@@ -255,14 +255,18 @@
+     return pix_multiply (src, mask);
+ }
+ 
++#ifndef _MSC_VER
+ static __inline__ __m64
+ in_over (__m64 src,
+ 	 __m64 srca,
+ 	 __m64 mask,
+ 	 __m64 dest)
+ {
+     return over(in(src, mask), pix_multiply(srca, mask), dest);
+ }
++#else
++#define in_over(src, srca, mask, dest) over(in(src, mask), pix_multiply(srca, mask), dest)
++#endif
+ 
+ static __inline__ __m64
+ load8888 (CARD32 v)
+@@ -355,18 +355,28 @@
+     return _mm_or_si64 (b, p);
+ }
+ 
++#ifndef _MSC_VER
+ static __inline__ __m64
+ pix_add_mul (__m64 x, __m64 a, __m64 y, __m64 b)
+ {
+     x = _mm_mullo_pi16 (x, a);
+     y = _mm_mullo_pi16 (y, b);
+     x = _mm_adds_pu16 (x, MC(4x0080));
+     x = _mm_adds_pu16 (x, y);
+     x = _mm_adds_pu16 (x, _mm_srli_pi16 (x, 8));
+     x = _mm_srli_pi16 (x, 8);
+ 
+     return x;
+ }
++#else
++#define pix_add_mul(x, a, y, b) \
++( x = _mm_mullo_pi16 (x, a), \
++  y = _mm_mullo_pi16 (y, b), \
++  x = _mm_adds_pu16 (x, MC(4x0080)), \
++  x = _mm_adds_pu16 (x, y), \
++  x = _mm_adds_pu16 (x, _mm_srli_pi16 (x, 8)), \
++  _mm_srli_pi16 (x, 8) )
++#endif
+ 
+ /* --------------- MMX code patch for fbcompose.c --------------------- */
+ 
+@@ -981,10 +981,9 @@
+ 
+ 	while (w && (unsigned long)dst & 7)
+ 	{
+-	    ullong d = *dst;
+-	    __m64 vdest = expand565 ((__m64)d, 0);
++	    __m64 vdest = expand565 (_mm_cvtsi32_si64 (*dst), 0);
+ 	    vdest = pack565(over(vsrc, vsrca, vdest), vdest, 0);
+-	    *dst = (ullong)vdest;
++	    *dst = _mm_cvtsi64_si32 (vdest);
+ 
+ 	    w--;
+ 	    dst++;
+@@ -1011,10 +1011,9 @@
+ 
+ 	while (w)
+ 	{
+-	    ullong d = *dst;
+-	    __m64 vdest = expand565 ((__m64)d, 0);
++	    __m64 vdest = expand565 (_mm_cvtsi32_si64 (*dst), 0);
+ 	    vdest = pack565(over(vsrc, vsrca, vdest), vdest, 0);
+-	    *dst = (ullong)vdest;
++	    *dst = _mm_cvtsi64_si32 (vdest);
+ 
+ 	    w--;
+ 	    dst++;
+@@ -1187,7 +1187,7 @@
+ 	    __m64 vsrc0 = expand8888 (vs, 0);
+ 	    __m64 vsrc1 = expand8888 (vs, 1);
+ 
+-	    *(__m64 *)dst = (__m64)pack8888 (
++	    *(__m64 *)dst = pack8888 (
+ 		in_over (vsrc0, expand_alpha (vsrc0), vmask, expand8888 (vd, 0)),
+ 		in_over (vsrc1, expand_alpha (vsrc1), vmask, expand8888 (vd, 1)));
+ 
+@@ -1285,35 +1285,35 @@
+ 	    __m64 vs6 = *(__m64 *)(src + 12);
+ 	    __m64 vs7 = *(__m64 *)(src + 14);
+ 
+-	    vd0 = (__m64)pack8888 (
++	    vd0 = pack8888 (
+ 		in_over (expand8888 (vs0, 0), srca, vmask, expand8888 (vd0, 0)),
+ 		in_over (expand8888 (vs0, 1), srca, vmask, expand8888 (vd0, 1)));
+ 
+-	    vd1 = (__m64)pack8888 (
++	    vd1 = pack8888 (
+ 		in_over (expand8888 (vs1, 0), srca, vmask, expand8888 (vd1, 0)),
+ 		in_over (expand8888 (vs1, 1), srca, vmask, expand8888 (vd1, 1)));
+ 
+-	    vd2 = (__m64)pack8888 (
++	    vd2 = pack8888 (
+ 		in_over (expand8888 (vs2, 0), srca, vmask, expand8888 (vd2, 0)),
+ 		in_over (expand8888 (vs2, 1), srca, vmask, expand8888 (vd2, 1)));
+ 
+-	    vd3 = (__m64)pack8888 (
++	    vd3 = pack8888 (
+ 		in_over (expand8888 (vs3, 0), srca, vmask, expand8888 (vd3, 0)),
+ 		in_over (expand8888 (vs3, 1), srca, vmask, expand8888 (vd3, 1)));
+ 
+-	    vd4 = (__m64)pack8888 (
++	    vd4 = pack8888 (
+ 		in_over (expand8888 (vs4, 0), srca, vmask, expand8888 (vd4, 0)),
+ 		in_over (expand8888 (vs4, 1), srca, vmask, expand8888 (vd4, 1)));
+ 
+-	    vd5 = (__m64)pack8888 (
++	    vd5 = pack8888 (
+ 		in_over (expand8888 (vs5, 0), srca, vmask, expand8888 (vd5, 0)),
+ 		in_over (expand8888 (vs5, 1), srca, vmask, expand8888 (vd5, 1)));
+ 
+-	    vd6 = (__m64)pack8888 (
++	    vd6 = pack8888 (
+ 		in_over (expand8888 (vs6, 0), srca, vmask, expand8888 (vd6, 0)),
+ 		in_over (expand8888 (vs6, 1), srca, vmask, expand8888 (vd6, 1)));
+ 
+-	    vd7 = (__m64)pack8888 (
++	    vd7 = pack8888 (
+ 		in_over (expand8888 (vs7, 0), srca, vmask, expand8888 (vd7, 0)),
+ 		in_over (expand8888 (vs7, 1), srca, vmask, expand8888 (vd7, 1)));
+ 
+@@ -1450,7 +1450,7 @@
+ 
+ 	    if (m)
+ 	    {
+-		__m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev ((__m64)m), load8888(*dst));
++		__m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev (*(__m64*)(&m)), load8888(*dst));
+ 		*dst = store8888(vdest);
+ 	    }
+ 
+@@ -1478,8 +1478,8 @@
+ 
+ 		vdest = *(__m64 *)dst;
+ 
+-		dest0 = in_over(vsrc, vsrca, expand_alpha_rev ((__m64)m0), expand8888(vdest, 0));
+-		dest1 = in_over(vsrc, vsrca, expand_alpha_rev ((__m64)m1), expand8888(vdest, 1));
++		dest0 = in_over(vsrc, vsrca, expand_alpha_rev (*(__m64*)(&m0)), expand8888(vdest, 0));
++		dest1 = in_over(vsrc, vsrca, expand_alpha_rev (*(__m64*)(&m1)), expand8888(vdest, 1));
+ 
+ 		*(__m64 *)dst = pack8888(dest0, dest1);
+ 	    }
+@@ -1498,7 +1498,7 @@
+ 	    if (m)
+ 	    {
+ 		__m64 vdest = load8888(*dst);
+-		vdest = in_over(vsrc, vsrca, expand_alpha_rev ((__m64)m), vdest);
++		vdest = in_over(vsrc, vsrca, expand_alpha_rev (*(__m64*)(&m)), vdest);
+ 		*dst = store8888(vdest);
+ 	    }
+ 
+@@ -1568,7 +1568,7 @@
+ 
+ 	    if (m)
+ 	    {
+-		  __m64 vdest = in(vsrc, expand_alpha_rev ((__m64)m));
++		  __m64 vdest = in(vsrc, expand_alpha_rev (*(__m64*)(&m)));
+ 		  *dst = store8888(vdest);
+ 	    }
+ 	    else
+@@ -1600,8 +1600,8 @@
+ 
+ 		vdest = *(__m64 *)dst;
+ 
+-		dest0 = in(vsrc, expand_alpha_rev ((__m64)m0));
+-		dest1 = in(vsrc, expand_alpha_rev ((__m64)m1));
++		dest0 = in(vsrc, expand_alpha_rev (*(__m64*)(&m0)));
++		dest1 = in(vsrc, expand_alpha_rev (*(__m64*)(&m1)));
+ 
+ 		*(__m64 *)dst = pack8888(dest0, dest1);
+ 	    }
+@@ -1624,7 +1624,7 @@
+ 	    if (m)
+ 	    {
+ 		__m64 vdest = load8888(*dst);
+-		vdest = in(vsrc, expand_alpha_rev ((__m64)m));
++		vdest = in(vsrc, expand_alpha_rev (*(__m64*)(&m)));
+ 		*dst = store8888(vdest);
+ 	    }
+ 	    else
+@@ -1661,7 +1661,8 @@
+     FbStride	dstStride, maskStride;
+     CARD16	w;
+     __m64	vsrc, vsrca;
+-    unsigned long long srcsrcsrcsrc, src16;
++    ullong srcsrcsrcsrc, src16;
++    __m64 vsrc16;
+ 
+     CHECKPOINT();
+ 
+@@ -1677,7 +1677,8 @@
+     vsrc = load8888 (src);
+     vsrca = expand_alpha (vsrc);
+ 
+-    src16 = (ullong)pack565(vsrc, _mm_setzero_si64(), 0);
++    vsrc16 = pack565(vsrc, _mm_setzero_si64(), 0);
++    src16 = *(ullong*)(&vsrc16);
+ 
+     srcsrcsrcsrc = (ullong)src16 << 48 | (ullong)src16 << 32 |
+ 	(ullong)src16 << 16 | (ullong)src16;
+@@ -1698,10 +1698,9 @@
+ 
+ 	    if (m)
+ 	    {
+-		ullong d = *dst;
+-		__m64 vd = (__m64)d;
+-		__m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev ((__m64)m), expand565(vd, 0));
+-		*dst = (ullong)pack565(vdest, _mm_setzero_si64(), 0);
++		__m64 vd = _mm_cvtsi32_si64 (*dst);
++		__m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev (*(__m64*)(&m)), expand565(vd, 0));
++		*dst = _mm_cvtsi64_si32 (pack565(vdest, _mm_setzero_si64(), 0));
+ 	    }
+ 
+ 	    w--;
+@@ -1730,13 +1730,13 @@
+ 
+ 		vdest = *(__m64 *)dst;
+ 
+-		vm0 = (__m64)m0;
++		vm0 = *(__m64*)(&m0);
+ 		vdest = pack565(in_over(vsrc, vsrca, expand_alpha_rev(vm0), expand565(vdest, 0)), vdest, 0);
+-		vm1 = (__m64)m1;
++		vm1 = *(__m64*)(&m1);
+ 		vdest = pack565(in_over(vsrc, vsrca, expand_alpha_rev(vm1), expand565(vdest, 1)), vdest, 1);
+-		vm2 = (__m64)m2;
++		vm2 = *(__m64*)(&m2);
+ 		vdest = pack565(in_over(vsrc, vsrca, expand_alpha_rev(vm2), expand565(vdest, 2)), vdest, 2);
+-		vm3 = (__m64)m3;
++		vm3 = *(__m64*)(&m3);
+ 		vdest = pack565(in_over(vsrc, vsrca, expand_alpha_rev(vm3), expand565(vdest, 3)), vdest, 3);
+ 
+ 		*(__m64 *)dst = vdest;
+@@ -1755,10 +1755,9 @@
+ 
+ 	    if (m)
+ 	    {
+-		ullong d = *dst;
+-		__m64 vd = (__m64)d;
+-		__m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev ((__m64)m), expand565(vd, 0));
+-		*dst = (ullong)pack565(vdest, _mm_setzero_si64(), 0);
++		__m64 vd = _mm_cvtsi32_si64 (*dst);
++		__m64 vdest = in_over(vsrc, vsrca, expand_alpha_rev (*(__m64*)(&m)), expand565(vd, 0));
++		*dst = _mm_cvtsi64_si32 (pack565(vdest, _mm_setzero_si64(), 0));
+ 	    }
+ 
+ 	    w--;
+@@ -1809,12 +1809,11 @@
+ 	while (w && (unsigned long)dst & 7)
+ 	{
+ 	    __m64 vsrc = load8888 (*src);
+-	    ullong d = *dst;
+-	    __m64 vdest = expand565 ((__m64)d, 0);
++	    __m64 vdest = expand565 (_mm_cvtsi32_si64 (*dst), 0);
+ 
+ 	    vdest = pack565(over_rev_non_pre(vsrc, vdest), vdest, 0);
+ 
+-	    *dst = (ullong)vdest;
++	    *dst = _mm_cvtsi64_si32 (vdest);
+ 
+ 	    w--;
+ 	    dst++;
+@@ -1870,12 +1870,11 @@
+ 	while (w)
+ 	{
+ 	    __m64 vsrc = load8888 (*src);
+-	    ullong d = *dst;
+-	    __m64 vdest = expand565 ((__m64)d, 0);
++	    __m64 vdest = expand565 (_mm_cvtsi32_si64 (*dst), 0);
+ 
+ 	    vdest = pack565(over_rev_non_pre(vsrc, vdest), vdest, 0);
+ 
+-	    *dst = (ullong)vdest;
++	    *dst = _mm_cvtsi64_si32 (vdest);
+ 
+ 	    w--;
+ 	    dst++;
+@@ -2030,10 +2030,9 @@
+ 
+ 	    if (m)
+ 	    {
+-		ullong d = *q;
+-		__m64 vdest = expand565 ((__m64)d, 0);
++		__m64 vdest = expand565 (_mm_cvtsi32_si64 (*q), 0);
+ 		vdest = pack565 (in_over (vsrc, vsrca, load8888 (m), vdest), vdest, 0);
+-		*q = (ullong)vdest;
++		*q = _mm_cvtsi64_si32 (vdest);
+ 	    }
+ 
+ 	    twidth--;
+@@ -2073,10 +2073,9 @@
+ 	    m = *(CARD32 *)p;
+ 	    if (m)
+ 	    {
+-		ullong d = *q;
+-		__m64 vdest = expand565((__m64)d, 0);
++		__m64 vdest = expand565(_mm_cvtsi32_si64 (*q), 0);
+ 		vdest = pack565 (in_over(vsrc, vsrca, load8888(m), vdest), vdest, 0);
+-		*q = (ullong)vdest;
++		*q = _mm_cvtsi64_si32 (vdest);
+ 	    }
+ 
+ 	    twidth--;
+@@ -2206,7 +2206,7 @@
+ 
+ 	while (w >= 2)
+ 	{
+-	    *(ullong*)dst = (ullong) _mm_adds_pu8(*(__m64*)src, *(__m64*)dst);
++	    *(__m64*)dst =  _mm_adds_pu8(*(__m64*)src, *(__m64*)dst);
+ 	    dst += 2;
+ 	    src += 2;
+ 	    w -= 2;
+@@ -2309,7 +2309,7 @@
+     }
+ 
+     fill = ((ullong)xor << 32) | xor;
+-    vfill = (__m64)fill;
++    vfill = *(__m64*)&fill;
+ 
+     while (height--)
+     {
+dummy line to avoid confusing diff-mode
+--- misc/build/cairo-1.2.4/src/cairo-features.h
++++ misc/build/cairo-1.2.4/src/cairo-features.h
+@@ -20,12 +20,7 @@
+ 
+ #define CAIRO_VERSION_STRING "1.2.4"
+ 
+-#define CAIRO_HAS_SVG_SURFACE 1
+-#define CAIRO_HAS_PDF_SURFACE 1
+-#define CAIRO_HAS_PS_SURFACE 1
+-#define CAIRO_HAS_FT_FONT 1
+-#define CAIRO_HAS_PNG_FUNCTIONS 1
+-#define CAIRO_HAS_XLIB_XRENDER_SURFACE 1
+-#define CAIRO_HAS_XLIB_SURFACE 1
++#define CAIRO_HAS_WIN32_FONT 1
++#define CAIRO_HAS_WIN32_SURFACE 1
+ 
+ #endif
+dummy line to avoid confusing diff-mode
+--- /dev/null
++++ misc/build/cairo-1.2.4/pixman/src/makefile.mk
+@@ -0,0 +1,38 @@
++PRJ=..$/..$/..$/..$/..$/..
++
++PRJNAME=cairo
++TARGET=pixman
++ENABLE_EXCEPTIONS=TRUE
++LIBTARGET=NO
++
++.INCLUDE :  settings.mk
++
++CFLAGS+=-I..$/..
++CDEFS+=-DHAVE_CONFIG_H
++
++SLOFILES = \
++	$(SLO)$/pixregion.obj \
++	$(SLO)$/fbpict.obj \
++	$(SLO)$/icblt.obj \
++	$(SLO)$/icbltone.obj \
++	$(SLO)$/iccolor.obj \
++	$(SLO)$/icformat.obj \
++	$(SLO)$/icimage.obj \
++	$(SLO)$/icpixels.obj \
++	$(SLO)$/icrect.obj \
++	$(SLO)$/icstipple.obj \
++	$(SLO)$/ictrap.obj \
++	$(SLO)$/ictransform.obj \
++	$(SLO)$/ictri.obj \
++	$(SLO)$/icutil.obj \
++	$(SLO)$/fbedge.obj \
++	$(SLO)$/fbtrap.obj \
++	$(SLO)$/fbcompose.obj \
++	$(SLO)$/renderedge.obj \
++	$(SLO)$/fbmmx.obj
++
++LIB1ARCHIV=$(LB)$/lib$(TARGET).a
++LIB1TARGET=$(SLB)$/$(TARGET).lib
++LIB1OBJFILES= $(SLOFILES)
++
++.INCLUDE :  target.mk
+dummy line to avoid confusing diff-mode
+--- misc/build/cairo-1.2.4/src/cairo-win32-surface.c
++++ misc/build/cairo-1.2.4/src/cairo-win32-surface.c
+@@ -1116,7 +1116,7 @@
+     if (GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY) {
+ 	depth = GetDeviceCaps(hdc, BITSPIXEL);
+ 	if (depth == 32)
+-	    format = CAIRO_FORMAT_ARGB32;
++	    format = CAIRO_FORMAT_RGB24;
+ 	else if (depth == 24)
+ 	    format = CAIRO_FORMAT_RGB24;
+ 	else if (depth == 16)
+@@ -1267,7 +1267,7 @@
+     NULL, /* mask */
+     NULL, /* stroke */
+     NULL, /* fill */
+-    _cairo_win32_surface_show_glyphs,
++    NULL, /* show_glyphs */
+ 
+     NULL  /* snapshot */
+ };
+dummy line to avoid confusing diff-mode
+--- /dev/null
++++ misc/build/cairo-1.2.4/src/makefile.mk
+@@ -0,0 +1,62 @@
++PRJ=..$/..$/..$/..$/..
++
++PRJNAME=cairo
++TARGET=cairo
++ENABLE_EXCEPTIONS=TRUE
++LIBTARGET=NO
++
++.INCLUDE :	settings.mk
++
++CFLAGS+=-I.. -I..$/pixman$/src
++CDEFS+=-DHAVE_CONFIG_H
++
++SLOFILES = \
++	$(SLO)$/cairo-win32-surface.obj \
++	$(SLO)$/cairo-win32-font.obj \
++	$(SLO)$/cairo.obj \
++	$(SLO)$/cairo-arc.obj \
++	$(SLO)$/cairo-array.obj \
++	$(SLO)$/cairo-base85-stream.obj \
++	$(SLO)$/cairo-cache.obj \
++	$(SLO)$/cairo-clip.obj \
++	$(SLO)$/cairo-color.obj \
++	$(SLO)$/cairo-debug.obj \
++	$(SLO)$/cairo-fixed.obj \
++	$(SLO)$/cairo-font.obj \
++	$(SLO)$/cairo-font-options.obj \
++	$(SLO)$/cairo-gstate.obj \
++	$(SLO)$/cairo-hash.obj \
++	$(SLO)$/cairo-hull.obj \
++	$(SLO)$/cairo-image-surface.obj \
++	$(SLO)$/cairo-lzw.obj \
++	$(SLO)$/cairo-matrix.obj \
++	$(SLO)$/cairo-operator.obj \
++	$(SLO)$/cairo-path.obj \
++	$(SLO)$/cairo-path-bounds.obj \
++	$(SLO)$/cairo-path-data.obj \
++	$(SLO)$/cairo-path-fill.obj \
++	$(SLO)$/cairo-path-stroke.obj \
++	$(SLO)$/cairo-pen.obj \
++	$(SLO)$/cairo-polygon.obj \
++	$(SLO)$/cairo-rectangle.obj \
++	$(SLO)$/cairo-region.obj \
++	$(SLO)$/cairo-scaled-font.obj \
++	$(SLO)$/cairo-slope.obj \
++	$(SLO)$/cairo-spline.obj \
++	$(SLO)$/cairo-stroke-style.obj \
++	$(SLO)$/cairo-surface.obj \
++	$(SLO)$/cairo-surface-fallback.obj \
++	$(SLO)$/cairo-traps.obj \
++	$(SLO)$/cairo-pattern.obj \
++	$(SLO)$/cairo-unicode.obj \
++	$(SLO)$/cairo-output-stream.obj \
++	$(SLO)$/cairo-wideint.obj \
++	$(SLO)$/cairo-meta-surface.obj \
++	$(SLO)$/cairo-paginated-surface.obj \
++	$(SLO)$/cairo-analysis-surface.obj
++
++LIB1ARCHIV=$(LB)$/lib$(TARGET).a
++LIB1TARGET=$(SLB)$/$(TARGET).lib
++LIB1OBJFILES= $(SLOFILES)
++
++.INCLUDE :  target.mk
+dummy line to avoid confusing diff-mode
