--- /dev/null	
+++ vcl/unx/gtk/a11y/atkwrapper.cxx	
@@ -0,0 +1,335 @@
+#include <com/sun/star/uno/Any.hxx>
+#include <com/sun/star/uno/Type.hxx>
+#include <com/sun/star/uno/Sequence.hxx>
+#include <com/sun/star/accessibility/AccessibleRole.hpp>
+#include <com/sun/star/accessibility/XAccessible.hpp>
+#include <com/sun/star/accessibility/XAccessibleContext.hpp>
+#include <com/sun/star/accessibility/XAccessibleComponent.hpp>
+#include <com/sun/star/awt/XExtendedToolkit.hpp>
+#include <com/sun/star/awt/XTopWindow.hpp>
+#include <com/sun/star/awt/XTopWindowListener.hpp>
+#include <com/sun/star/awt/XWindow.hpp>
+#include <com/sun/star/lang/XComponent.hpp>
+#include <com/sun/star/lang/XServiceInfo.hpp>
+#include <com/sun/star/lang/XInitialization.hpp>
+#include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/lang/XSingleServiceFactory.hpp>
+#include <com/sun/star/beans/Property.hpp>
+
+#include <rtl/ref.hxx>
+#include <cppuhelper/factory.hxx>
+#include <cppuhelper/queryinterface.hxx>
+
+#include "atkwrapper.hxx"
+
+#define ATK_TYPE_OBJECT_WRAPPER atk_object_wrapper_get_type()
+#define ATK_OBJECT_WRAPPER(obj) \
+	(G_TYPE_CHECK_INSTANCE_CAST ((obj), ATK_TYPE_OBJECT_WRAPPER, AtkObjectWrapper))
+
+static GObjectClass *parent_class = NULL;
+static GHashTable   *uno_to_gobject = NULL;
+
+extern "C" {
+
+static gint
+wrapper_get_n_children (AtkObject *accessible)
+{
+	AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( accessible );
+	return pWrap->mpContext ? pWrap->mpContext->getAccessibleChildCount() : 0;
+}
+
+static AtkObject *
+wrapper_ref_child (AtkObject *accessible,
+				   gint       i)
+{
+	AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( accessible );
+	AtkObject *pChild = NULL;
+	try {
+			pChild = atk_object_wrapper_construct( pWrap->mpContext->getAccessibleChild( i ) );
+	} catch( const uno::Exception &e) {
+			g_warning ("Exception getting child %d", i );
+	}
+	return pChild;
+}
+
+static gint
+wrapper_get_index_in_parent (AtkObject *accessible)
+{
+	AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( accessible );
+	return pWrap->mpContext ? pWrap->mpContext->getAccessibleIndexInParent() : 0;
+}
+
+static void
+atk_object_wrapper_finalize (GObject *obj)
+{
+	AtkObjectWrapper *wrapper = ATK_OBJECT_WRAPPER (obj);
+
+	if (wrapper->mpAccessible)
+	{
+		g_hash_table_remove (uno_to_gobject, wrapper->mpAccessible);
+		wrapper->mpAccessible->release();
+		wrapper->mpAccessible = NULL;
+	}
+	if (wrapper->mpContext)
+	{
+		wrapper->mpContext->release();
+		wrapper->mpContext = NULL;
+	}
+
+	parent_class->finalize (obj);
+}
+
+static void
+atk_object_wrapper_class_init (AtkObjectWrapperClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS( klass );
+  AtkObjectClass *atk_class = ATK_OBJECT_CLASS( klass );
+
+  parent_class = (GObjectClass *) g_type_class_peek_parent (klass);
+
+  // GObject methods
+  gobject_class->finalize = atk_object_wrapper_finalize;
+
+  // AtkObject methods
+  atk_class->get_n_children = wrapper_get_n_children;
+  atk_class->ref_child = wrapper_ref_child;
+  atk_class->get_index_in_parent = wrapper_get_index_in_parent;
+
+  // We assume direct pointer comparison is sufficient...
+  uno_to_gobject = g_hash_table_new (NULL, NULL);
+}
+
+static void
+atk_object_wrapper_init (AtkObjectWrapper      *accessible,
+						 AtkObjectWrapperClass *klass)
+{
+}
+
+GType
+atk_object_wrapper_get_type (void)
+{
+  static GType type = 0;
+
+  if (!type)
+    {
+      static const GTypeInfo typeInfo =
+      {
+        sizeof (AtkObjectWrapperClass),
+        (GBaseInitFunc) NULL,
+        (GBaseFinalizeFunc) NULL,
+        (GClassInitFunc) atk_object_wrapper_class_init,
+        (GClassFinalizeFunc) NULL,
+        NULL,
+        sizeof (AtkObjectWrapper),
+        0,
+        (GInstanceInitFunc) atk_object_wrapper_init,
+      } ;
+      type = g_type_register_static (ATK_TYPE_OBJECT,
+									 "OOoAtkObj",
+									 &typeInfo, (GTypeFlags)0) ;
+    }
+  return type;
+}
+
+static bool
+isOfType( uno::XInterface *pInterface, const uno::Type & rType )
+{
+	g_return_val_if_fail( pInterface != NULL, false );
+
+	bool bIs = false;
+	try {
+		uno::Any aRet = pInterface->queryInterface( rType );
+
+		bIs = ( ( typelib_TypeClass_INTERFACE == aRet.pType->eTypeClass ) &&
+				( aRet.pReserved != NULL ) );
+	} catch( const uno::Exception &e) { }
+	
+	return bIs;
+}
+
+// I suck: bite me.
+#include "atkcomponent.cxx"
+
+static GType
+ensureTypeFor( uno::XInterface *pAccessible )
+{
+	bool bIsComponent = false;
+	rtl::OString aTypeName( "OOoAtkObj" );
+
+	if( isOfType( pAccessible, accessibility::XAccessibleComponent::static_type() ) )
+	{
+		aTypeName += rtl::OString( "Comp" );
+		bIsComponent = true;
+	}
+
+	GType nType = g_type_from_name( aTypeName );
+	if( nType == G_TYPE_INVALID )
+	{
+		GTypeInfo aTypeInfo = {
+			sizeof( AtkObjectWrapperClass ),
+			NULL, NULL, NULL, NULL, NULL,
+			sizeof( AtkObjectWrapper ),
+			0, NULL
+		} ;
+		nType = g_type_register_static( ATK_TYPE_OBJECT_WRAPPER,
+										aTypeName, &aTypeInfo, (GTypeFlags)0 ) ;
+
+		if( bIsComponent )
+		{
+			static const GInterfaceInfo aComponentInfo =
+			{
+				(GInterfaceInitFunc) componentIfaceInit, NULL, NULL
+			};
+			g_type_add_interface_static (nType, ATK_TYPE_COMPONENT,
+										 &aComponentInfo);
+		}
+    }
+	return nType;
+}
+
+static AtkRole mapToAtkRole( sal_Int16 nRole )
+{
+	switch( nRole )
+	{
+#define MAP(a,b) \
+		case a: return b; break
+			
+		MAP( ::accessibility::AccessibleRole::UNKNOWN, ATK_ROLE_UNKNOWN );
+		MAP( ::accessibility::AccessibleRole::ALERT, ATK_ROLE_ALERT );
+		MAP( ::accessibility::AccessibleRole::COLUMN_HEADER, ATK_ROLE_COLUMN_HEADER );
+		MAP( ::accessibility::AccessibleRole::CANVAS, ATK_ROLE_CANVAS );
+		MAP( ::accessibility::AccessibleRole::CHECK_BOX, ATK_ROLE_CHECK_BOX );
+		MAP( ::accessibility::AccessibleRole::CHECK_MENU_ITEM, ATK_ROLE_CHECK_MENU_ITEM );
+		MAP( ::accessibility::AccessibleRole::COLOR_CHOOSER, ATK_ROLE_COLOR_CHOOSER );
+		MAP( ::accessibility::AccessibleRole::COMBO_BOX, ATK_ROLE_COMBO_BOX );
+		MAP( ::accessibility::AccessibleRole::DATE_EDITOR, ATK_ROLE_DATE_EDITOR );
+		MAP( ::accessibility::AccessibleRole::DESKTOP_ICON, ATK_ROLE_DESKTOP_ICON );
+		MAP( ::accessibility::AccessibleRole::DESKTOP_PANE, ATK_ROLE_DESKTOP_FRAME ); // ? pane
+		MAP( ::accessibility::AccessibleRole::DIRECTORY_PANE, ATK_ROLE_DIRECTORY_PANE );
+		MAP( ::accessibility::AccessibleRole::DIALOG, ATK_ROLE_DIALOG );
+		MAP( ::accessibility::AccessibleRole::DOCUMENT, ATK_ROLE_UNKNOWN ); // - FIXME -
+		MAP( ::accessibility::AccessibleRole::EMBEDDED_OBJECT, ATK_ROLE_UNKNOWN ); // - FIXME -
+		MAP( ::accessibility::AccessibleRole::END_NOTE, ATK_ROLE_UNKNOWN ); // - FIXME -
+		MAP( ::accessibility::AccessibleRole::FILE_CHOOSER, ATK_ROLE_FILE_CHOOSER );
+		MAP( ::accessibility::AccessibleRole::FILLER, ATK_ROLE_FILLER );
+		MAP( ::accessibility::AccessibleRole::FONT_CHOOSER, ATK_ROLE_FONT_CHOOSER );
+		MAP( ::accessibility::AccessibleRole::FOOTER, ATK_ROLE_FOOTER );
+		MAP( ::accessibility::AccessibleRole::FOOTNOTE, ATK_ROLE_TEXT ); // - FIXME -
+		MAP( ::accessibility::AccessibleRole::FRAME, ATK_ROLE_FRAME );
+		MAP( ::accessibility::AccessibleRole::GLASS_PANE, ATK_ROLE_GLASS_PANE );
+		MAP( ::accessibility::AccessibleRole::GRAPHIC, ATK_ROLE_UNKNOWN ); // - FIXME -
+		MAP( ::accessibility::AccessibleRole::GROUP_BOX, ATK_ROLE_UNKNOWN ); // - FIXME -
+		MAP( ::accessibility::AccessibleRole::HEADER, ATK_ROLE_HEADER );
+		MAP( ::accessibility::AccessibleRole::HEADING, ATK_ROLE_HEADER ); // - FIXME -
+		MAP( ::accessibility::AccessibleRole::HYPER_LINK, ATK_ROLE_TEXT ); // - FIXME -
+		MAP( ::accessibility::AccessibleRole::ICON, ATK_ROLE_ICON );
+		MAP( ::accessibility::AccessibleRole::INTERNAL_FRAME, ATK_ROLE_INTERNAL_FRAME );
+		MAP( ::accessibility::AccessibleRole::LABEL, ATK_ROLE_LABEL );
+		MAP( ::accessibility::AccessibleRole::LAYERED_PANE, ATK_ROLE_LAYERED_PANE );
+		MAP( ::accessibility::AccessibleRole::LIST, ATK_ROLE_LIST );
+		MAP( ::accessibility::AccessibleRole::LIST_ITEM, ATK_ROLE_LIST_ITEM );
+		MAP( ::accessibility::AccessibleRole::MENU, ATK_ROLE_MENU );
+		MAP( ::accessibility::AccessibleRole::MENU_BAR, ATK_ROLE_MENU_BAR );
+		MAP( ::accessibility::AccessibleRole::MENU_ITEM, ATK_ROLE_MENU_ITEM );
+		MAP( ::accessibility::AccessibleRole::OPTION_PANE, ATK_ROLE_OPTION_PANE );
+		MAP( ::accessibility::AccessibleRole::PAGE_TAB, ATK_ROLE_PAGE_TAB );
+		MAP( ::accessibility::AccessibleRole::PAGE_TAB_LIST, ATK_ROLE_PAGE_TAB_LIST );
+		MAP( ::accessibility::AccessibleRole::PANEL, ATK_ROLE_PANEL );
+		MAP( ::accessibility::AccessibleRole::PARAGRAPH, ATK_ROLE_PARAGRAPH );
+		MAP( ::accessibility::AccessibleRole::PASSWORD_TEXT, ATK_ROLE_PASSWORD_TEXT );
+		MAP( ::accessibility::AccessibleRole::POPUP_MENU, ATK_ROLE_POPUP_MENU );
+		MAP( ::accessibility::AccessibleRole::PUSH_BUTTON, ATK_ROLE_PUSH_BUTTON );
+		MAP( ::accessibility::AccessibleRole::PROGRESS_BAR, ATK_ROLE_PROGRESS_BAR );
+		MAP( ::accessibility::AccessibleRole::RADIO_BUTTON, ATK_ROLE_RADIO_BUTTON );
+		MAP( ::accessibility::AccessibleRole::RADIO_MENU_ITEM, ATK_ROLE_RADIO_MENU_ITEM );
+		MAP( ::accessibility::AccessibleRole::ROW_HEADER, ATK_ROLE_ROW_HEADER );
+		MAP( ::accessibility::AccessibleRole::ROOT_PANE, ATK_ROLE_ROOT_PANE );
+		MAP( ::accessibility::AccessibleRole::SCROLL_BAR, ATK_ROLE_SCROLL_BAR );
+		MAP( ::accessibility::AccessibleRole::SCROLL_PANE, ATK_ROLE_SCROLL_PANE );
+		MAP( ::accessibility::AccessibleRole::SHAPE, ATK_ROLE_UNKNOWN ); // - FIXME -
+		MAP( ::accessibility::AccessibleRole::SEPARATOR, ATK_ROLE_SEPARATOR );
+		MAP( ::accessibility::AccessibleRole::SLIDER, ATK_ROLE_SLIDER );
+		MAP( ::accessibility::AccessibleRole::SPIN_BOX, ATK_ROLE_SPIN_BUTTON ); // ?
+		MAP( ::accessibility::AccessibleRole::SPLIT_PANE, ATK_ROLE_SPLIT_PANE );
+		MAP( ::accessibility::AccessibleRole::STATUS_BAR, ATK_ROLE_STATUSBAR );
+		MAP( ::accessibility::AccessibleRole::TABLE, ATK_ROLE_TABLE );
+		MAP( ::accessibility::AccessibleRole::TABLE_CELL, ATK_ROLE_TABLE_CELL );
+		MAP( ::accessibility::AccessibleRole::TEXT, ATK_ROLE_TEXT );
+		MAP( ::accessibility::AccessibleRole::TEXT_FRAME, ATK_ROLE_UNKNOWN ); // - FIXME -
+		MAP( ::accessibility::AccessibleRole::TOGGLE_BUTTON, ATK_ROLE_TOGGLE_BUTTON );
+		MAP( ::accessibility::AccessibleRole::TOOL_BAR, ATK_ROLE_TOOL_BAR );
+		MAP( ::accessibility::AccessibleRole::TOOL_TIP, ATK_ROLE_TOOL_TIP );
+		MAP( ::accessibility::AccessibleRole::TREE, ATK_ROLE_TREE );
+		MAP( ::accessibility::AccessibleRole::VIEW_PORT, ATK_ROLE_VIEWPORT );
+		MAP( ::accessibility::AccessibleRole::WINDOW, ATK_ROLE_WINDOW );
+#undef MAP
+	}
+/* Roles unimplemented by OO.o / a11y:
+  ATK_ROLE_INVALID,      ATK_ROLE_ACCEL_LABEL,    ATK_ROLE_ANIMATION,
+  ATK_ROLE_ARROW,        ATK_ROLE_CALENDAR,       ATK_ROLE_DIAL,
+  ATK_ROLE_DRAWING_AREA, ATK_ROLE_HTML_CONTAINER, ATK_ROLE_IMAGE,
+  ATK_ROLE_TABLE_COLUMN_HEADER, ATK_ROLE_TABLE_ROW_HEADER, ATK_ROLE_TEAR_OFF_MENU_ITEM,
+  ATK_ROLE_TERMINAL,            ATK_ROLE_TREE_TABLE,       ATK_ROLE_RULER,
+  ATK_ROLE_APPLICATION,         ATK_ROLE_AUTOCOMPLETE,     ATK_ROLE_EDITBAR */
+
+	return ATK_ROLE_UNKNOWN;
+}
+
+static void initialize( AtkObjectWrapper *pWrap )
+{
+	AtkObject *pAObj = ATK_OBJECT( pWrap );
+
+	try {
+		uno::Reference< accessibility::XAccessibleContext > xContext = pWrap->mpContext;
+		rtl::OString aValue;
+		atk_object_set_role( pAObj, mapToAtkRole( xContext->getAccessibleRole() ) );
+		aValue = rtl::OUStringToOString( xContext->getAccessibleName(), RTL_TEXTENCODING_UTF8 );
+		atk_object_set_name( pAObj, aValue );
+		aValue = rtl::OUStringToOString( xContext->getAccessibleDescription(), RTL_TEXTENCODING_UTF8 );
+		atk_object_set_description( pAObj, aValue );
+		uno::Reference< accessibility::XAccessible > xParent;
+		xParent = xContext->getAccessibleParent();
+		if( xParent.is() )
+			atk_object_set_parent( pAObj, atk_object_wrapper_construct( xParent ) );
+		else
+			atk_object_set_parent( pAObj, atk_get_root() );
+	} catch (const uno::Exception &e)
+	{
+		g_warning( "exception initializing accessible" );
+	}
+}
+
+AtkObject *
+atk_object_wrapper_construct( const uno::Reference< accessibility::XAccessible > &rAccessible )
+{
+	gpointer cached;
+	accessibility::XAccessible *pAccessible = rAccessible.get();
+
+	g_return_val_if_fail( pAccessible != NULL, NULL );
+
+	if( (cached = g_hash_table_lookup (uno_to_gobject, (gpointer) pAccessible) ) )
+		return ATK_OBJECT (g_object_ref (cached));
+
+	uno::Reference< accessibility::XAccessibleContext > xContext;
+	xContext = pAccessible->getAccessibleContext();
+
+	accessibility::XAccessibleContext *pContext = xContext.get();
+
+	g_return_val_if_fail( xContext != NULL, NULL );
+
+	GType nType = ensureTypeFor( pContext );
+	cached = g_object_new( nType, NULL);
+	g_hash_table_insert( uno_to_gobject, (gpointer) pAccessible, cached );
+	AtkObjectWrapper *pWrap = ATK_OBJECT_WRAPPER( cached );
+
+	pAccessible->acquire();
+	pWrap->mpAccessible = pAccessible;
+	pContext->acquire();
+	pWrap->mpContext = pContext;
+
+	initialize( pWrap );
+
+	return ATK_OBJECT( pWrap );
+}
+
+}; // extern C
