--- /dev/null	
+++ vcl/unx/gtk/a11y/atklistener.cxx	
@@ -0,0 +1,219 @@
+#include <cppuhelper/queryinterface.hxx>
+#include <com/sun/star/accessibility/TextSegment.hpp>
+#include <com/sun/star/accessibility/AccessibleEventId.hpp>
+#include <com/sun/star/accessibility/AccessibleStateType.hpp>
+
+#include "atklistener.hxx"
+
+static AtkState mapState( const uno::Any &rAny )
+{
+	sal_Int16 nState = accessibility::AccessibleStateType::INVALID;
+	rAny >>= nState;
+
+	// A perfect / complete mapping ...
+	switch( nState )
+	{
+#define MAP_DIRECT( a ) \
+	case accessibility::AccessibleStateType::a: \
+		return ATK_STATE_##a; break
+
+		MAP_DIRECT( INVALID );
+		MAP_DIRECT( ACTIVE );
+		MAP_DIRECT( ARMED );
+		MAP_DIRECT( BUSY );
+		MAP_DIRECT( CHECKED );
+		MAP_DIRECT( EDITABLE );
+		MAP_DIRECT( ENABLED );
+		MAP_DIRECT( EXPANDABLE );
+		MAP_DIRECT( EXPANDED );
+		MAP_DIRECT( FOCUSABLE );
+		MAP_DIRECT( FOCUSED );
+		MAP_DIRECT( HORIZONTAL );
+		MAP_DIRECT( ICONIFIED );
+		MAP_DIRECT( INDETERMINATE );
+		MAP_DIRECT( MANAGES_DESCENDANTS );
+		MAP_DIRECT( MODAL );
+		MAP_DIRECT( MULTI_LINE );
+		MAP_DIRECT( OPAQUE );
+		MAP_DIRECT( PRESSED );
+		MAP_DIRECT( RESIZABLE );
+		MAP_DIRECT( SELECTABLE );
+		MAP_DIRECT( SELECTED );
+		MAP_DIRECT( SENSITIVE );
+		MAP_DIRECT( SHOWING );
+		MAP_DIRECT( SINGLE_LINE );
+		MAP_DIRECT( STALE );
+		MAP_DIRECT( TRANSIENT );
+		MAP_DIRECT( VERTICAL );
+		MAP_DIRECT( VISIBLE );
+		// a spelling error ...
+		case accessibility::AccessibleStateType::DEFUNC:
+			return ATK_STATE_DEFUNCT; break;
+		case accessibility::AccessibleStateType::MULTI_SELECTABLE:
+			return ATK_STATE_MULTISELECTABLE; break;
+	default:
+		return ATK_STATE_INVALID;
+		break;
+	}
+}
+
+AtkListener::AtkListener( AtkObject *pObj )
+{
+	mnRefCount = 1;
+    mpAccessible = pObj;
+}
+AtkListener::~AtkListener()
+{
+}
+
+// XInterface implementation
+uno::Any AtkListener::queryInterface( const uno::Type & rType ) throw (uno::RuntimeException)
+{
+    return cppu::queryInterface
+			(rType, 
+			 static_cast< uno::XInterface * >( static_cast< accessibility::XAccessibleEventListener * >( this ) ),
+			 static_cast< accessibility::XAccessibleEventListener * >( this ) );
+}
+
+// XEventListener implementation
+void AtkListener::disposing( const lang::EventObject& Source ) throw (uno::RuntimeException)
+{
+    fprintf( stderr, "disposing\n" );
+}
+
+static AtkObject *getObjFromAny( const uno::Any &rAny )
+{
+	uno::Reference< accessibility::XAccessible > xAccessible;
+	rAny >>= xAccessible;
+	return xAccessible.is() ? atk_wrapper_get( xAccessible ) : NULL;
+}
+
+// XAccessibleEventListener
+void AtkListener::notifyEvent( const accessibility::AccessibleEventObject& aEvent ) throw( uno::RuntimeException )
+{
+    //    ::sal_Int16 EventId CPPU_GCC3_ALIGN(::com::sun::star::lang::EventObject);
+    //    ::com::sun::star::uno::Any NewValue;
+    //    ::com::sun::star::uno::Any OldValue;
+    switch( aEvent.EventId )
+    {
+	// AtkObject signals:
+		// Hierarchy signals
+	    case accessibility::AccessibleEventId::CHILD:
+		{
+			AtkObject *pChild;
+
+			// TESTME - are these the correct insertion indexes ?
+			if( ( pChild = getObjFromAny( aEvent.OldValue ) ) )
+			{
+				g_signal_emit_by_name( mpAccessible, "children_changed::remove",
+									   atk_object_get_index_in_parent( pChild ), pChild, NULL );
+				g_object_unref( G_OBJECT( pChild ) );
+			}
+			if( ( pChild = getObjFromAny( aEvent.NewValue ) ) )
+			{
+				g_signal_emit_by_name( mpAccessible, "children_changed::add",
+									   atk_object_get_index_in_parent( pChild ), pChild, NULL );
+				g_object_unref( G_OBJECT( pChild ) );
+			}
+			break;
+		}
+	    case accessibility::AccessibleEventId::INVALIDATE_ALL_CHILDREN:
+			g_warning( "FIXME: invalidate all children signal ?" );
+			break;
+	    case accessibility::AccessibleEventId::NAME_CHANGED:
+			g_object_notify( G_OBJECT( mpAccessible ), "accessible-name" );
+			break;
+	    case accessibility::AccessibleEventId::DESCRIPTION_CHANGED:
+			g_object_notify( G_OBJECT( mpAccessible ), "accessible-description" );
+			break;
+	    case accessibility::AccessibleEventId::STATE_CHANGED:
+		{
+			AtkState eOldState = mapState( aEvent.OldValue );
+			AtkState eNewState = mapState( aEvent.NewValue );
+
+			gboolean bState = eNewState != ATK_STATE_INVALID;
+			AtkState eRealState = bState ? eNewState : eOldState;
+
+			g_warning( "Test me state changed %d to %s", eRealState, bState ? "set" : "unset" );
+			atk_object_notify_state_change( mpAccessible, eRealState, bState );
+			// If this is a focus change should we emit 'focus_event' ?
+			break;
+		}
+	    case accessibility::AccessibleEventId::VISIBLE_DATA_CHANGED:
+			g_signal_emit_by_name( mpAccessible, "visible-data-changed" );
+			break;
+	    case accessibility::AccessibleEventId::ACTIVE_DESCENDANT_CHANGED:
+		{
+			AtkObject *pChild = getObjFromAny( aEvent.NewValue );
+			g_signal_emit_by_name( mpAccessible, "active-descendant-changed", pChild );
+			g_object_unref( G_OBJECT( pChild ) );
+			break;
+		}
+
+		// AtkAction signals ...
+	    case accessibility::AccessibleEventId::ACTION_CHANGED:
+			// FIXME: nothing to map this to ...
+			break;
+
+		// AtkText
+	    case accessibility::AccessibleEventId::CARET_CHANGED:
+		{
+			sal_Int32 nPos;
+			aEvent.NewValue >>= nPos;
+			g_signal_emit_by_name( mpAccessible, "text_caret_moved", nPos );
+			break;
+		}
+	    case accessibility::AccessibleEventId::TEXT_CHANGED:
+		{
+			// TESTME: and remove this comment:
+			// cf. comphelper/source/misc/accessibletexthelper.cxx (implInitTextChangedEvent)
+			g_warning( "TESTME: text insertion" );
+			accessibility::TextSegment aDeletedText;
+			accessibility::TextSegment aInsertedText;
+			aEvent.OldValue >>= aDeletedText;
+			aEvent.NewValue >>= aInsertedText;
+
+			if( aDeletedText.SegmentStart > 0 )
+				g_signal_emit_by_name( mpAccessible, "text_changed::delete",
+									   (gint) aDeletedText.SegmentStart,
+									   (gint)( aDeletedText.SegmentEnd - aDeletedText.SegmentStart ) );
+			if( aInsertedText.SegmentStart > 0 )
+				g_signal_emit_by_name( mpAccessible, "text_changed::add",
+									   (gint) aInsertedText.SegmentStart,
+									   (gint)( aInsertedText.SegmentEnd - aInsertedText.SegmentStart ) );
+			break;
+		}
+	    case accessibility::AccessibleEventId::TEXT_SELECTION_CHANGED:
+		{ // FIXME: suffers from the same selection problems ...
+			break;
+		}
+	    case accessibility::AccessibleEventId::TEXT_ATTRIBUTE_CHANGED:
+		{ // FIXME: implement attribute support
+			break;
+		}
+
+	    case accessibility::AccessibleEventId::BOUNDRECT_CHANGED:
+	    case accessibility::AccessibleEventId::SELECTION_CHANGED:
+	    case accessibility::AccessibleEventId::VALUE_CHANGED:
+	    case accessibility::AccessibleEventId::CONTENT_FLOWS_FROM_RELATION_CHANGED:
+	    case accessibility::AccessibleEventId::CONTENT_FLOWS_TO_RELATION_CHANGED:
+	    case accessibility::AccessibleEventId::CONTROLLED_BY_RELATION_CHANGED:
+	    case accessibility::AccessibleEventId::CONTROLLER_FOR_RELATION_CHANGED:
+	    case accessibility::AccessibleEventId::LABEL_FOR_RELATION_CHANGED:
+	    case accessibility::AccessibleEventId::LABELED_BY_RELATION_CHANGED:
+	    case accessibility::AccessibleEventId::MEMBER_OF_RELATION_CHANGED:
+	    case accessibility::AccessibleEventId::SUB_WINDOW_OF_RELATION_CHANGED:
+	    case accessibility::AccessibleEventId::HYPERTEXT_CHANGED:
+	    case accessibility::AccessibleEventId::TABLE_CAPTION_CHANGED:
+	    case accessibility::AccessibleEventId::TABLE_COLUMN_DESCRIPTION_CHANGED:
+	    case accessibility::AccessibleEventId::TABLE_COLUMN_HEADER_CHANGED:
+	    case accessibility::AccessibleEventId::TABLE_MODEL_CHANGED:
+	    case accessibility::AccessibleEventId::TABLE_ROW_DESCRIPTION_CHANGED:
+	    case accessibility::AccessibleEventId::TABLE_ROW_HEADER_CHANGED:
+	    case accessibility::AccessibleEventId::TABLE_SUMMARY_CHANGED:
+		    break;
+	default:
+			g_warning( "Unknown event notification" );
+			break;
+    }
+}
