? sc/Debug
? sc/sc.vpj
? sc/inc/dpcachetable.hxx
? sc/source/core/data/dpcachetable.cxx
Index: sc/inc/dpgroup.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpgroup.hxx,v
retrieving revision 1.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.4 dpgroup.hxx
--- sc/inc/dpgroup.hxx	8 Sep 2005 17:34:35 -0000	1.4
+++ sc/inc/dpgroup.hxx	25 Oct 2007 18:11:17 -0000
@@ -37,6 +37,7 @@
 #define SC_DPGROUP_HXX
 
 #include <vector>
+#include <hash_set>
 
 #ifndef SC_DPTABDAT_HXX
 #include "dptabdat.hxx"
@@ -180,13 +181,17 @@
 
 class ScDPGroupTableData : public ScDPTableData
 {
+    typedef ::std::hash_set< ::rtl::OUString, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > StringHashSet;
+
     ScDPTableData*          pSourceData;
     long                    nSourceCount;
     ScDPGroupDimensionVec   aGroups;
     ScDPNumGroupDimension*  pNumGroups;     // array[nSourceCount]
     ScDocument*             pDoc;
+    StringHashSet           aGroupNames;
 
     void        FillGroupValues( ScDPItemData* pItemData, long nCount, const long* pDims );
+    void        CopyFields(const ::std::vector<long>& rFieldDims, ::std::vector<long>& rNewFieldDims);
     long*       CopyFields( const long* pSourceDims, long nCount );
 
     bool        IsNumGroupDimension( long nDimension ) const;
@@ -213,6 +218,13 @@
     virtual void                    DisposeData();
     virtual void                    SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
 
+    virtual void                    CreateCacheTable();
+    virtual void                    FilterCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters,
+                                                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+    virtual void                    CalcResults(CalcInfo& rInfo, bool bAutoShow);
+    virtual const ScDPCacheTable&   GetCacheTable() const;
+
     virtual void                    ResetIterator();
     virtual BOOL                    GetNextRow( const ScDPTableIteratorParam& rParam );
 
Index: sc/inc/dpobject.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpobject.hxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dpobject.hxx
--- sc/inc/dpobject.hxx	27 Jun 2007 13:41:57 -0000	1.12
+++ sc/inc/dpobject.hxx	25 Oct 2007 18:11:17 -0000
@@ -78,7 +78,7 @@
 class StrCollection;
 class TypedStrCollection;
 struct PivotField;
-
+class ScDPCacheTable;
 
 struct ScDPServiceDesc
 {
@@ -223,6 +223,9 @@
 	BOOL				RefsEqual( const ScDPObject& r ) const;
 	void				WriteRefsTo( ScDPObject& r ) const;
 
+    void                GetDrillDownData(const ScAddress& rPos, 
+                                         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTableData);
+
 	// apply drop-down attribute, initialize nHeaderRows, without accessing the source
 	// (button attribute must be present)
 	void				RefreshAfterLoad();
Index: sc/inc/dpoutput.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpoutput.hxx,v
retrieving revision 1.8
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.8 dpoutput.hxx
--- sc/inc/dpoutput.hxx	27 Jun 2007 13:42:13 -0000	1.8
+++ sc/inc/dpoutput.hxx	25 Oct 2007 18:11:17 -0000
@@ -60,8 +60,13 @@
 #include "address.hxx"
 #endif
 
+#include "dpcachetable.hxx"
 #include <vector>
 
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+}}}}
+
 class Rectangle;
 class SvStream;
 class ScDocument;
@@ -166,6 +171,11 @@
 	BOOL			HasError();			// range overflow or exception from source
 
 	void			GetPositionData( ScDPPositionData& rData, const ScAddress& rPos );
+
+    /** Get filtering criteria based on the position of the cell within data
+        field region. */
+    bool            GetDataFieldPositionData(::std::vector< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters, const ScAddress& rPos);
+
     BOOL            GetPivotData( ScDPGetPivotDataField& rTarget, /* returns result */
                                   const std::vector< ScDPGetPivotDataField >& rFilters );
 	long			GetHeaderDim( const ScAddress& rPos, USHORT& rOrient );
Index: sc/inc/dpsdbtab.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpsdbtab.hxx,v
retrieving revision 1.3
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.3 dpsdbtab.hxx
--- sc/inc/dpsdbtab.hxx	8 Sep 2005 17:35:48 -0000	1.3
+++ sc/inc/dpsdbtab.hxx	25 Oct 2007 18:11:17 -0000
@@ -50,6 +50,11 @@
 #include "dptabdat.hxx"
 #endif
 
+#include <vector>
+#include <set>
+
+class ScDPCacheTable;
+
 // --------------------------------------------------------------------
 //
 //	implementation of ScDPTableData with database data
@@ -94,6 +99,13 @@
 	virtual void					DisposeData();
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
 
+    virtual void                    CreateCacheTable();
+    virtual void                    FilterCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters,
+                                                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+    virtual void                    CalcResults(CalcInfo& rInfo, bool bAutoShow);
+    virtual const ScDPCacheTable&   GetCacheTable() const;
+
 	virtual void					ResetIterator();
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam );
 };
Index: sc/inc/dpshttab.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpshttab.hxx,v
retrieving revision 1.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.4 dpshttab.hxx
--- sc/inc/dpshttab.hxx	8 Sep 2005 17:36:03 -0000	1.4
+++ sc/inc/dpshttab.hxx	25 Oct 2007 18:11:18 -0000
@@ -48,6 +48,14 @@
 #include "address.hxx"
 #endif
 
+#include <vector>
+
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+}}}}
+
+class ScDPDimension;
+class ScDPItemData;
 
 // --------------------------------------------------------------------
 //
@@ -70,7 +78,6 @@
 {
 private:
 	ScSheetDPData_Impl* pImpl;
-    BOOL* pSpecial;
 
 public:
 					ScSheetDPData( ScDocument* pD, const ScSheetSourceDesc& rDesc );
@@ -85,6 +92,13 @@
 	virtual void					DisposeData();
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
 
+    virtual void                    CreateCacheTable();
+    virtual void                    FilterCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters,
+                                                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rData);
+    virtual void                    CalcResults(CalcInfo& rInfo, bool bAutoShow);
+    virtual const ScDPCacheTable&   GetCacheTable() const;
+
 	virtual void					ResetIterator();
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam );
 };
Index: sc/inc/dptabdat.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dptabdat.hxx,v
retrieving revision 1.6
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.6 dptabdat.hxx
--- sc/inc/dptabdat.hxx	25 Jan 2007 11:03:15 -0000	1.6
+++ sc/inc/dptabdat.hxx	25 Oct 2007 18:11:18 -0000
@@ -40,11 +40,21 @@
 #include "address.hxx"
 #endif
 
+#include "dpoutput.hxx"
+
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
 
+#include <vector>
+#include <set>
+
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+}}}}
+
 class TypedStrCollection;
+class ScDPDimension;
 
 // -----------------------------------------------------------------------
 
@@ -110,18 +120,18 @@
 {
 	//	all pointers are just copied
 
-	SCSIZE			nColCount;
-	const long*		pCols;
-	ScDPItemData*	pColData;
-	SCSIZE			nRowCount;
-	const long*		pRows;
-	ScDPItemData*	pRowData;
-	SCSIZE			nPageCount;
-	const long*		pPages;
-	ScDPItemData*	pPageData;
-	SCSIZE			nDatCount;
-	const long*		pDats;
-	ScDPValueData*	pValues;
+	const SCSIZE	nColCount;      // nColLevelCount
+	const long*		pCols;          // nColLevelDims (pSourceCols for group)
+	ScDPItemData*	pColData;       // aColData
+	const SCSIZE	nRowCount;      // nRowLevelCount
+	const long*		pRows;          // nRowLevelDims (pSourceRows for group)
+	ScDPItemData*	pRowData;       // aRowData
+	const SCSIZE	nPageCount;     // nPageDimCount
+	const long*		pPages;         // nPageDims (pSourcePages for group)
+	ScDPItemData*	pPageData;      // aPageData
+	const SCSIZE	nDatCount;      // nDataDimCount
+	const long*		pDats;          // nDataSrcCols (pSourceDats for group)
+	ScDPValueData*	pValues;        // aValues
 
 	ScDPTableIteratorParam( long nCCount, const long* pC, ScDPItemData* pCDat,
 							long nRCount, const long* pR, ScDPItemData* pRDat,
@@ -129,6 +139,13 @@
 							long nDCount, const long* pD, ScDPValueData* pV );
 };
 
+class ScDPResultMember;
+class ScDPDimension;
+class ScDPLevel;
+class ScDPInitState;
+class ScDPCacheTable;
+class ScDPResultMember;
+
 class ScDPTableData
 {
 	//	cached data for GetDatePart
@@ -138,6 +155,36 @@
 	long 	nLastRet;
 
 public:
+    struct CalcInfo
+    {
+        ::std::vector<long>             aColLevelDims;
+        ::std::vector<ScDPDimension*>   aColDims;
+        ::std::vector<ScDPLevel*>       aColLevels;
+        ::std::vector<long>             aRowLevelDims;
+        ::std::vector<ScDPDimension*>   aRowDims;
+        ::std::vector<ScDPLevel*>       aRowLevels;
+        ::std::vector<long>             aPageDims;
+        ::std::vector<long>             aDataSrcCols;
+
+        ScDPInitState*                  pInitState;
+        ScDPResultMember*               pColRoot;
+        ScDPResultMember*               pRowRoot;
+
+        CalcInfo();
+        CalcInfo(const CalcInfo& rOther);
+        CalcInfo& operator =(const CalcInfo& rOther);
+    private:
+        void assign(const CalcInfo& rOther);
+    };
+
+    struct CalcRowData
+    {
+        ::std::vector<ScDPItemData>  aColData;
+        ::std::vector<ScDPItemData>  aRowData;
+        ::std::vector<ScDPItemData>  aPageData;
+        ::std::vector<ScDPValueData> aValues;
+    };
+
 				ScDPTableData();
 	virtual		~ScDPTableData();
 
@@ -155,6 +202,13 @@
 	virtual void					DisposeData() = 0;
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty ) = 0;
 
+    virtual void                    CreateCacheTable();
+    virtual void                    FilterCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& aFilters,
+                                                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+    virtual void                    CalcResults(CalcInfo& rInfo, bool bAutoShow);
+    virtual const ScDPCacheTable&   GetCacheTable() const = 0;
+
 	virtual void					ResetIterator() = 0;
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam ) = 0;
 
@@ -166,6 +220,14 @@
                                                const ScDPItemData& rBaseData, long nBaseIndex ) const;
     virtual BOOL                    HasCommonElement( const ScDPItemData& rFirstData, long nFirstIndex,
                                                       const ScDPItemData& rSecondData, long nSecondIndex ) const;
+
+protected:
+    void            FillRowDataFromCacheTable(sal_Int32 nRow, const ScDPCacheTable& rCacheTable, const CalcInfo& rInfo, CalcRowData& rData);
+    void            ProcessRowData(CalcInfo& rInfo, CalcRowData& rData, bool bAutoShow);
+    void            CalcResultsFromCacheTable(const ScDPCacheTable& rCacheTable, CalcInfo& rInfo, bool bAutoShow);
+
+private:
+    void            GetItemData(const ScDPCacheTable& rCacheTable, sal_Int32 nRow, const ::std::vector<long>& rDims, ::std::vector<ScDPItemData>& rItemData);
 };
 
 
Index: sc/inc/dptabsrc.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dptabsrc.hxx,v
retrieving revision 1.8
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.8 dptabsrc.hxx
--- sc/inc/dptabsrc.hxx	25 Jan 2007 11:03:43 -0000	1.8
+++ sc/inc/dptabsrc.hxx	25 Oct 2007 18:11:18 -0000
@@ -93,6 +93,7 @@
 #ifndef _COM_SUN_STAR_UTIL_XREFRESHABLE_HPP_
 #include <com/sun/star/util/XRefreshable.hpp>
 #endif
+#include <com/sun/star/sheet/XDrillDownDataSupplier.hpp>
 #ifndef _COM_SUN_STAR_UTIL_XCLONEABLE_HPP_
 #include <com/sun/star/util/XCloneable.hpp>
 #endif
@@ -115,11 +116,16 @@
 #ifndef _CPPUHELPER_IMPLBASE5_HXX_
 #include <cppuhelper/implbase5.hxx>
 #endif
+#include <cppuhelper/implbase6.hxx>
 
 #ifndef SC_DPTABDAT_HXX
 #include "dptabdat.hxx"
 #endif
 
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+}}}}
+
 class ScDPResultMember;
 class ScDPResultData;
 struct ScDPItemData;
@@ -148,14 +154,18 @@
 class ScDPMember;
 
 
-class ScDPSource : public cppu::WeakImplHelper5<
+class ScDPSource : public cppu::WeakImplHelper6<
 							com::sun::star::sheet::XDimensionsSupplier,
 							com::sun::star::sheet::XDataPilotResults,
 							com::sun::star::util::XRefreshable,
+                            com::sun::star::sheet::XDrillDownDataSupplier,
 							com::sun::star::beans::XPropertySet,
 							com::sun::star::lang::XServiceInfo >
 {
 private:
+    void FillCalcInfo(bool bIsRow, ScDPTableData::CalcInfo& rInfo, bool &bHasAutoShow);
+
+private:
 	ScDPTableData*			pData;				// data source
 	ScDPDimensions*			pDimensions;		// api objects
 												// settings:
@@ -242,6 +252,14 @@
 									::com::sun::star::util::XRefreshListener >& l )
 								throw(::com::sun::star::uno::RuntimeException);
 
+                            // XDrillDownDataSupplier
+    virtual void SAL_CALL   getDrillDownData(const ::com::sun::star::uno::Sequence< 
+                                                ::com::sun::star::sheet::DataPilotFieldFilter >& aFilters,
+                                             ::com::sun::star::uno::Sequence< 
+                                                ::com::sun::star::uno::Sequence< 
+                                                    ::com::sun::star::uno::Any > >& rTabData)
+                                throw(::com::sun::star::uno::RuntimeException);
+
 							// XPropertySet
 	virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo >
 							SAL_CALL getPropertySetInfo(  )
@@ -358,7 +376,7 @@
 {
 private:
 	ScDPSource*			pSource;
-	long				nDim;
+	long				nDim;               // dimension index (== column ID)
 	ScDPHierarchies*	pHierarchies;
 	long				nUsedHier;
 	USHORT				nFunction;			// enum GeneralFunction
Index: sc/source/core/data/dpgroup.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpgroup.cxx,v
retrieving revision 1.7
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.7 dpgroup.cxx
--- sc/source/core/data/dpgroup.cxx	27 Feb 2007 12:03:31 -0000	1.7
+++ sc/source/core/data/dpgroup.cxx	25 Oct 2007 18:11:18 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -51,10 +51,24 @@
 #include "collect.hxx"
 #include "global.hxx"
 #include "document.hxx"
+#include "dpcachetable.hxx"
+#include "dptabsrc.hxx"
+#include "dptabres.hxx"
 
-#ifndef _COM_SUN_STAR_SHEET_DATAPILOTFIELDGROUPBY_HPP_
 #include <com/sun/star/sheet/DataPilotFieldGroupBy.hpp>
-#endif
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+
+#include <vector>
+
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::rtl::OUString;
+
+using ::std::vector;
 
 #define D_TIMEFACTOR              86400.0
 
@@ -840,6 +854,7 @@
     ScDPGroupDimension aNewGroup( rGroup );
     aNewGroup.SetGroupDim( GetColumnCount() );      // new dimension will be at the end
     aGroups.push_back( aNewGroup );
+    aGroupNames.insert( OUString(aNewGroup.GetName()) );
 }
 
 void ScDPGroupTableData::SetNumGroupDimension( long nIndex, const ScDPNumGroupDimension& rGroup )
@@ -972,11 +987,105 @@
     pSourceData->SetEmptyFlags( bIgnoreEmptyRows, bRepeatIfEmpty );
 }
 
+void ScDPGroupTableData::CreateCacheTable()
+{
+    pSourceData->CreateCacheTable();
+}
+
+void ScDPGroupTableData::FilterCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+    pSourceData->FilterCacheTable(rPageDims);
+}
+
+void ScDPGroupTableData::GetDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& aFilters, Sequence< Sequence<Any> >& rTabData)
+{
+    // Go through the field names and skip group name(s) if any.
+    vector<sheet::DataPilotFieldFilter> filters;
+    sal_Int32 nOrigSize = aFilters.getLength();
+    filters.reserve(nOrigSize);
+    StringHashSet::const_iterator itrEnd = aGroupNames.end();
+    for (sal_Int32 i = 0; i < nOrigSize; ++i)
+    {
+        if (aGroupNames.find(aFilters[i].FieldName) == itrEnd)
+            filters.push_back(aFilters[i]);
+    }
+
+    // Convert vector to Sequence.
+    size_t nSize = filters.size();
+    Sequence<sheet::DataPilotFieldFilter> filters2(nSize);
+    for (size_t i = 0; i < nSize; ++i)
+        filters2[i] = filters[i];
+
+    pSourceData->GetDrillDownData(filters2, rTabData);
+}
+
+void ScDPGroupTableData::CalcResults(CalcInfo& rInfo, bool bAutoShow)
+{
+    // This CalcInfo instance is used only to retrive data from the original
+    // data source.
+    CalcInfo aInfoSrc(rInfo);
+    CopyFields(rInfo.aColLevelDims, aInfoSrc.aColLevelDims);
+    CopyFields(rInfo.aRowLevelDims, aInfoSrc.aRowLevelDims);
+    CopyFields(rInfo.aPageDims,     aInfoSrc.aPageDims);
+    CopyFields(rInfo.aDataSrcCols,  aInfoSrc.aDataSrcCols);
+
+    const ScDPCacheTable& rCacheTable = pSourceData->GetCacheTable();
+    sal_Int32 nRowSize = rCacheTable.getRowSize();
+    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+    {
+        if (!rCacheTable.isRowActive(nRow))
+            continue;
+
+        CalcRowData aData;
+        FillRowDataFromCacheTable(nRow, rCacheTable, aInfoSrc, aData);
+
+        FillGroupValues(&aData.aColData[0], rInfo.aColLevelDims.size(), &rInfo.aColLevelDims[0]);
+        FillGroupValues(&aData.aRowData[0], rInfo.aRowLevelDims.size(), &rInfo.aRowLevelDims[0]);
+        FillGroupValues(&aData.aPageData[0], rInfo.aPageDims.size(), &rInfo.aPageDims[0]);
+
+        ProcessRowData(rInfo, aData, bAutoShow);
+    }
+}
+
+const ScDPCacheTable& ScDPGroupTableData::GetCacheTable() const
+{
+    return pSourceData->GetCacheTable();
+}
+
 void ScDPGroupTableData::ResetIterator()
 {
     pSourceData->ResetIterator();
 }
 
+void ScDPGroupTableData::CopyFields(const vector<long>& rFieldDims, vector<long>& rNewFieldDims)
+{
+    size_t nCount = rFieldDims.size();
+    if (!nCount)
+        return;
+
+    long nGroupedColumns = aGroups.size();
+
+    rNewFieldDims.clear();
+    rNewFieldDims.reserve(nCount);
+    for (long i = 0; i < nCount; ++i)
+    {
+        if ( rFieldDims[i] >= nSourceCount )
+        {
+            if ( rFieldDims[i] == nSourceCount + nGroupedColumns )
+                // data layout in source
+                rNewFieldDims.push_back(nSourceCount);
+            else
+            {
+                // original dimension
+                long n = rFieldDims[i] - nSourceCount;
+                rNewFieldDims.push_back(aGroups[n].GetSourceDim());
+            }
+        }
+        else
+            rNewFieldDims.push_back(rFieldDims[i]);
+    }
+}
+
 long* ScDPGroupTableData::CopyFields( const long* pSourceDims, long nCount )
 {
     if (!nCount)
Index: sc/source/core/data/dpobject.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpobject.cxx,v
retrieving revision 1.21
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 dpobject.cxx
--- sc/source/core/data/dpobject.cxx	27 Jun 2007 13:43:19 -0000	1.21
+++ sc/source/core/data/dpobject.cxx	25 Oct 2007 18:11:18 -0000
@@ -62,18 +62,27 @@
 #include "unonames.hxx"
 
 #include <com/sun/star/sheet/GeneralFunction.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 #include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
 #include <com/sun/star/sheet/DataPilotFieldReferenceType.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/lang/XSingleServiceFactory.hpp>
 #include <com/sun/star/lang/XInitialization.hpp>
 #include <com/sun/star/container/XContentEnumerationAccess.hpp>
+#include <com/sun/star/sheet/XDrillDownDataSupplier.hpp>
 
 #include <comphelper/processfactory.hxx>
 #include <tools/debug.hxx>
 #include <svtools/zforlist.hxx>		// IsNumberFormat
 
+#include <vector>
+
 using namespace com::sun::star;
+using ::std::vector;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::Any;
 
 // -----------------------------------------------------------------------
 
@@ -601,6 +610,26 @@
 		r.SetSheetDesc( *pSheetDesc );
 }
 
+void ScDPObject::GetDrillDownData(const ScAddress& rPos, Sequence< Sequence<Any> >& rTableData)
+{
+    CreateOutput();
+
+    vector<sheet::DataPilotFieldFilter> aFilters;
+    if ( !pOutput->GetDataFieldPositionData(aFilters, rPos) )
+        return;
+
+    sal_Int32 n = static_cast<sal_Int32>(aFilters.size());
+    ::com::sun::star::uno::Sequence<sheet::DataPilotFieldFilter> aFilters2(n);
+    for (sal_Int32 i = 0; i < n; ++i)
+        aFilters2[i] = aFilters[i];
+
+    Reference<sheet::XDrillDownDataSupplier> xDrillDownData(xSource, UNO_QUERY);
+    if (!xDrillDownData.is())
+        return;
+
+    xDrillDownData->getDrillDownData(aFilters2, rTableData);
+}
+
 BOOL ScDPObject::IsDimNameInUse( const String& rName ) const
 {
 	if ( xSource.is() )
Index: sc/source/core/data/dpoutput.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpoutput.cxx,v
retrieving revision 1.15
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.15 dpoutput.cxx
--- sc/source/core/data/dpoutput.cxx	27 Jun 2007 13:43:33 -0000	1.15
+++ sc/source/core/data/dpoutput.cxx	25 Oct 2007 18:11:19 -0000
@@ -48,6 +48,8 @@
 #include <unotools/transliterationwrapper.hxx>
 
 #include "dpoutput.hxx"
+#include "dptabsrc.hxx"
+#include "dpcachetable.hxx"
 #include "document.hxx"
 #include "patattr.hxx"
 #include "docpool.hxx"
@@ -68,12 +70,17 @@
 #include <com/sun/star/sheet/XDataPilotMemberResults.hpp>
 #include <com/sun/star/sheet/DataResultFlags.hpp>
 #include <com/sun/star/sheet/MemberResultFlags.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 #include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
 #include <com/sun/star/sheet/TableFilterField.hpp>
 #include <com/sun/star/sheet/GeneralFunction.hpp>
 #include <com/sun/star/container/XNamed.hpp>
 
+#include <vector>
+
 using namespace com::sun::star;
+using ::std::vector;
+using ::com::sun::star::uno::Sequence;
 
 // -----------------------------------------------------------------------
 
@@ -995,6 +1002,70 @@
 	}
 }
 
+bool ScDPOutput::GetDataFieldPositionData(vector<sheet::DataPilotFieldFilter>& rFilters, const ScAddress& rPos)
+{
+    SCCOL nCol = rPos.Col();
+    SCROW nRow = rPos.Row();
+    SCTAB nTab = rPos.Tab();
+    if ( nTab != aStartPos.Tab() )
+        return false;                                     // wrong sheet
+
+    CalcSizes();
+
+    // test for data area.
+    if (nCol < nDataStartCol || nCol > nTabEndCol || nRow < nDataStartRow || nRow > nTabEndRow)
+    {
+        // Cell is outside the data field area.
+        return false;
+    }
+
+    // column fields
+    for (SCCOL nColField = 0; nColField < nColFieldCount; ++nColField)
+    {
+        sheet::DataPilotFieldFilter filter;
+        filter.FieldName = pColFields[nColField].aCaption;
+
+        const uno::Sequence<sheet::MemberResult> rSequence = pColFields[nColField].aResult;
+        long nThisColCount = rSequence.getLength();
+        const sheet::MemberResult* pArray = rSequence.getConstArray();
+
+        DBG_ASSERT(nDataStartCol + nThisColCount - 1 == nTabEndCol, "ScDPOutput::GetDataFieldCellData: error in geometric assumption");
+
+        long nItem = nCol - nDataStartCol;
+                //	get origin of "continue" fields
+        while ( nItem > 0 && (pArray[nItem].Flags & sheet::MemberResultFlags::CONTINUE) )
+            --nItem;
+
+        filter.MatchValue = pArray[nItem].Name;
+        if (pArray[nItem].Name.getLength() > 0 && !pArray[nItem].Name.equalsAscii("Total"))
+            rFilters.push_back(filter);
+    }
+
+    // row fields
+    for (SCROW nRowField = 0; nRowField < nRowFieldCount; ++nRowField)
+    {
+        sheet::DataPilotFieldFilter filter;
+        filter.FieldName = pRowFields[nRowField].aCaption;
+
+        const uno::Sequence<sheet::MemberResult> rSequence = pRowFields[nRowField].aResult;
+        long nThisRowCount = rSequence.getLength();
+        const sheet::MemberResult* pArray = rSequence.getConstArray();
+
+        DBG_ASSERT(nDataStartRow + nThisRowCount - 1 == nTabEndRow, "ScDPOutput::GetDataFieldCellData: error in geometric assumption");
+
+        long nItem = nRow - nDataStartRow;
+			//	get origin of "continue" fields
+        while ( nItem > 0 && (pArray[nItem].Flags & sheet::MemberResultFlags::CONTINUE) )
+            --nItem;
+
+        filter.MatchValue = pArray[nItem].Name;
+        if (pArray[nItem].Name.getLength() > 0 && !pArray[nItem].Name.equalsAscii("Total"))
+            rFilters.push_back(filter);
+    }
+
+    return true;
+}
+
 //
 //  helper functions for ScDPOutput::GetPivotData
 //
Index: sc/source/core/data/dpsdbtab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpsdbtab.cxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dpsdbtab.cxx
--- sc/source/core/data/dpsdbtab.cxx	27 Feb 2007 12:04:37 -0000	1.12
+++ sc/source/core/data/dpsdbtab.cxx	25 Oct 2007 18:11:19 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE --------------------------------------------------------------
 
@@ -55,14 +55,24 @@
 #include <com/sun/star/sdbc/XRowSet.hpp>
 #include <com/sun/star/sdbc/XResultSetMetaDataSupplier.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 
 #include "dpsdbtab.hxx"
 #include "collect.hxx"
 #include "global.hxx"
 #include "globstr.hrc"
+#include "dpcachetable.hxx"
+#include "dptabres.hxx"
 
 using namespace com::sun::star;
 
+using ::std::vector;
+using ::std::set;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::UNO_QUERY;
+
 #define SC_SERVICE_ROWSET			"com.sun.star.sdb.RowSet"
 #define SC_SERVICE_INTHANDLER		"com.sun.star.sdb.InteractionHandler"
 
@@ -87,6 +97,8 @@
 	sal_Int32*			pTypes;
 	SvNumberFormatter*	pFormatter;
 
+    ScDPCacheTable      aCacheTable;
+
 	ScDatabaseDPData_Impl() {}
 };
 
@@ -148,6 +160,7 @@
 
 BOOL ScDatabaseDPData::OpenDatabase()
 {
+    fprintf(stdout, "ScDatabaseDPData::OpenDatabase: --begins (TODO: remove this function)\n");fflush(stdout);
 	sal_Int32 nSdbType = -1;
 	switch ( pImpl->aDesc.nType )
 	{
@@ -369,6 +382,7 @@
 
 void ScDatabaseDPData::InitAllColumnEntries()
 {
+    fprintf(stdout, "ScDatabaseDPData::InitAllColumnEntries: --begins (TODO: remove this function)\n");fflush(stdout);
 	DBG_ASSERT( pImpl->ppStrings, "GetColumnEntries: no entries" );
 	long nCol;
 	for ( nCol=0; nCol<pImpl->nColCount; nCol++ )
@@ -418,53 +432,8 @@
 
 const TypedStrCollection& ScDatabaseDPData::GetColumnEntries(long nColumn)
 {
-	DBG_ASSERT( pImpl->ppStrings && nColumn < pImpl->nColCount, "GetColumnEntries: no entries" );
-	if (!pImpl->ppStrings[nColumn])
-	{
-		TypedStrCollection* pColl = new TypedStrCollection;
-
-		//!	select distinct values directly from database
-
-//		Sound::Beep();		//! Test !!!
-
-		uno::Reference<sdbc::XRowSet> xRowSet = pImpl->xRowSet;
-		uno::Reference<sdbc::XRow> xRow( xRowSet, uno::UNO_QUERY );
-		if ( xRow.is() )
-		{
-			ScDPItemData aItemData;
-
-			try
-			{
-				if ( !pImpl->bAtStart )
-					lcl_Reset( xRowSet );
-
-				pImpl->bAtStart = FALSE;
-				while ( xRowSet->next() )
-				{
-					//!	get string for value data only if value hasn't been inserted yet
-					lcl_FillItemData( aItemData, xRow, nColumn+1, pImpl->pTypes[nColumn], TRUE, pImpl );
-					TypedStrData* pNew = new TypedStrData(
-							aItemData.aString, aItemData.fValue,
-							aItemData.bHasValue ? SC_STRTYPE_VALUE : SC_STRTYPE_STANDARD );
-					if (!pColl->Insert(pNew))
-						delete pNew;
-				}
-			}
-			catch ( sdbc::SQLException& rError )
-			{
-				//!	store error message
-				InfoBox aInfoBox( 0, String(rError.Message) );
-				aInfoBox.Execute();
-			}
-			catch ( uno::Exception& )
-			{
-				DBG_ERROR("Unexpected exception in database");
-			}
-		}
-
-		pImpl->ppStrings[nColumn] = pColl;
-	}
-	return *pImpl->ppStrings[nColumn];
+    CreateCacheTable();
+    return pImpl->aCacheTable.getFieldEntries(nColumn);
 }
 
 String ScDatabaseDPData::getDimensionName(long nColumn)
@@ -500,6 +469,38 @@
 	//!	disable flags
 }
 
+void ScDatabaseDPData::CreateCacheTable()
+{
+    if (!pImpl->aCacheTable.empty())
+        return;
+
+    // Get null date.
+    if (!pImpl->pFormatter)
+        pImpl->pFormatter = new SvNumberFormatter(pImpl->xServiceManager, ScGlobal::eLnge);
+
+    pImpl->aCacheTable.fillTable(pImpl->xRowSet, *pImpl->pFormatter->GetNullDate());
+}
+
+void ScDatabaseDPData::FilterCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+    pImpl->aCacheTable.filterByPageDimension(rPageDims);
+}
+
+void ScDatabaseDPData::GetDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& rFilters, Sequence< Sequence<Any> >& rTabData)
+{
+    pImpl->aCacheTable.filterTable(rFilters, rTabData);
+}
+
+void ScDatabaseDPData::CalcResults(CalcInfo& rInfo, bool bAutoShow)
+{
+    CalcResultsFromCacheTable(pImpl->aCacheTable, rInfo, bAutoShow);
+}
+
+const ScDPCacheTable& ScDatabaseDPData::GetCacheTable() const
+{
+    return pImpl->aCacheTable;
+}
+
 void ScDatabaseDPData::ResetIterator()
 {
 	try
Index: sc/source/core/data/dpshttab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpshttab.cxx,v
retrieving revision 1.9
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.9 dpshttab.cxx
--- sc/source/core/data/dpshttab.cxx	27 Feb 2007 12:04:49 -0000	1.9
+++ sc/source/core/data/dpshttab.cxx	25 Oct 2007 18:11:19 -0000
@@ -44,11 +44,24 @@
 #include <svtools/zforlist.hxx>
 
 #include "dpshttab.hxx"
+#include "dptabres.hxx"
 #include "document.hxx"
 #include "collect.hxx"
 #include "cell.hxx"
+#include "dpcachetable.hxx"
 #include "globstr.hrc"
 
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+
+#include <vector>
+#include <set>
+
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::Sequence;
+using ::std::vector;
+using ::std::set;
+
 // -----------------------------------------------------------------------
 
 class ScSheetDPData_Impl
@@ -57,49 +70,47 @@
 	ScDocument*		pDoc;
 	ScRange			aRange;
 	ScQueryParam	aQuery;
-	long			nColCount;
+    BOOL*           pSpecial;           // to flag special handling of query parameters in ValidQuery.
 	BOOL			bIgnoreEmptyRows;
 	BOOL			bRepeatIfEmpty;
-	TypedStrCollection**	ppStrings;
 	BOOL*			pDateDim;
 	SCROW			nNextRow;		// for iterator, within range
 
-	ScSheetDPData_Impl() {}
+    ScDPCacheTable  aCacheTable;
+
+	ScSheetDPData_Impl() :
+        pSpecial(NULL)
+    {
+    }
 };
 
 // -----------------------------------------------------------------------
 
 ScSheetDPData::ScSheetDPData( ScDocument* pD, const ScSheetSourceDesc& rDesc )
-    : pSpecial(NULL)
 {
-	long nCount = rDesc.aSourceRange.aEnd.Col() - rDesc.aSourceRange.aStart.Col() + 1;
 	pImpl = new ScSheetDPData_Impl;
 	pImpl->pDoc = pD;
 	pImpl->aRange = rDesc.aSourceRange;
 	pImpl->aQuery = rDesc.aQueryParam;
 	pImpl->bIgnoreEmptyRows = FALSE;
 	pImpl->bRepeatIfEmpty = FALSE;
-	pImpl->nColCount = nCount;
-	pImpl->ppStrings = new TypedStrCollection*[nCount];
 	pImpl->pDateDim = NULL;
-	for (long i=0; i<nCount; i++)
-		pImpl->ppStrings[i] = NULL;
 
 	pImpl->nNextRow = pImpl->aRange.aStart.Row() + 1;
 
     SCSIZE nEntryCount(pImpl->aQuery.GetEntryCount());
-    pSpecial = new BOOL[nEntryCount];
+    pImpl->pSpecial = new BOOL[nEntryCount];
     for (SCSIZE j = 0; j < nEntryCount; ++j )
     {
         ScQueryEntry& rEntry = pImpl->aQuery.GetEntry(j);
         if (rEntry.bDoQuery)
         {
-            pSpecial[j] = false;
+            pImpl->pSpecial[j] = false;
             if (!rEntry.bQueryByString)
             {
                 if (*rEntry.pStr == EMPTY_STRING &&
                    ((rEntry.nVal == SC_EMPTYFIELDS) || (rEntry.nVal == SC_NONEMPTYFIELDS)))
-                    pSpecial[j] = true;
+                    pImpl->pSpecial[j] = true;
             }
             else
             {
@@ -110,30 +121,23 @@
             }
     	}
     }
+    CreateCacheTable();
 }
 
 ScSheetDPData::~ScSheetDPData()
 {
-	for (long i=0; i<pImpl->nColCount; i++)
-		delete pImpl->ppStrings[i];
-	delete[] pImpl->ppStrings;
 	delete[] pImpl->pDateDim;
+    delete[] pImpl->pSpecial;
 	delete pImpl;
-    delete[] pSpecial;
 }
 
 void ScSheetDPData::DisposeData()
 {
-	for (long i=0; i<pImpl->nColCount; i++)
-	{
-		delete pImpl->ppStrings[i];
-		pImpl->ppStrings[i] = NULL;
-	}
 }
 
 long ScSheetDPData::GetColumnCount()
 {
-	return pImpl->nColCount;
+    return pImpl->aCacheTable.getColSize();
 }
 
 BOOL lcl_HasQuery( const ScQueryParam& rParam )
@@ -144,58 +148,9 @@
 
 const TypedStrCollection& ScSheetDPData::GetColumnEntries(long nColumn)
 {
-	DBG_ASSERT(nColumn>=0 && nColumn<pImpl->nColCount, "ScSheetDPData: wrong column");
-
-	if (!pImpl->ppStrings[nColumn])
-	{
-		TypedStrCollection* pColl = new TypedStrCollection;
-
-		//!	document must have function to fill collection!!!
-		String aDocStr;
-		SCCOL nDocCol = (SCCOL)(pImpl->aRange.aStart.Col() + nColumn);
-		SCTAB nDocTab = pImpl->aRange.aStart.Tab();
-		SCROW nStartRow = pImpl->aRange.aStart.Row()+1;	// start of data
-		SCROW nEndRow = pImpl->aRange.aEnd.Row();
-		SCCOL nStartCol = pImpl->aRange.aStart.Col();
-		SCCOL nEndCol = pImpl->aRange.aEnd.Col();
-		for (SCROW nRow = nStartRow; nRow <= nEndRow; nRow++)
-		{
-			if ( pImpl->bIgnoreEmptyRows &&
-					pImpl->pDoc->IsBlockEmpty( nDocTab, nStartCol, nRow, nEndCol, nRow ) )
-			{
-				//	ignore this (empty) row
-				//!	count and skip empty rows?
-			}
-			else if ( pImpl->bRepeatIfEmpty && nRow > nStartRow &&
-						!pImpl->pDoc->HasData( nDocCol, nRow, nDocTab ) )
-			{
-				//	ignore empty member (if it's not the first row)
-			}
-			else if ( lcl_HasQuery(pImpl->aQuery) &&
-						!pImpl->pDoc->ValidQuery( nRow, nDocTab, pImpl->aQuery, pSpecial ) )
-			{
-				//	this row is filtered out
-			}
-			else
-			{
-				TypedStrData* pNew;
-				pImpl->pDoc->GetString( nDocCol, nRow, nDocTab, aDocStr );
-				if ( pImpl->pDoc->HasValueData( nDocCol, nRow, nDocTab ) )
-				{
-					double fVal = pImpl->pDoc->GetValue(ScAddress(nDocCol, nRow, nDocTab));
-					pNew = new TypedStrData( aDocStr, fVal, SC_STRTYPE_VALUE );
-				}
-				else
-					pNew = new TypedStrData( aDocStr );
-
-				if (!pColl->Insert(pNew))
-					delete pNew;
-			}
-		}
-
-		pImpl->ppStrings[nColumn] = pColl;
-	}
-	return *pImpl->ppStrings[nColumn];
+    DBG_ASSERT(nColumn>=0 && nColumn < pImpl->aCacheTable.getColSize(), "ScSheetDPData: wrong column");
+    CreateCacheTable();
+    return pImpl->aCacheTable.getFieldEntries(nColumn);
 }
 
 String ScSheetDPData::getDimensionName(long nColumn)
@@ -206,7 +161,7 @@
 		//return "Data";
 		return ScGlobal::GetRscString(STR_PIVOT_DATA);
 	}
-	else if ( nColumn >= pImpl->nColCount )
+    else if (nColumn >= pImpl->aCacheTable.getColSize())
 	{
 		DBG_ERROR("getDimensionName: invalid dimension");
 		return String();
@@ -235,11 +190,12 @@
 
 BOOL ScSheetDPData::IsDateDimension(long nDim)
 {
+    long nColCount = pImpl->aCacheTable.getColSize();
 	if (getIsDataLayoutDimension(nDim))
 	{
 		return FALSE;
 	}
-	else if ( nDim >= pImpl->nColCount )
+    else if (nDim >= nColCount)
 	{
 		DBG_ERROR("IsDateDimension: invalid dimension");
 		return FALSE;
@@ -248,9 +204,9 @@
 	{
 		if (!pImpl->pDateDim)
 		{
-			pImpl->pDateDim = new BOOL[pImpl->nColCount];
+            pImpl->pDateDim = new BOOL[nColCount];
 			ScRange aTestRange = pImpl->aRange;
-			for (long i=0; i<pImpl->nColCount; i++)
+			for (long i = 0; i < nColCount; ++i)
 			{
 				SCCOL nCol = (SCCOL)( pImpl->aRange.aStart.Col() + i );
 				aTestRange.aStart.SetCol(nCol);
@@ -268,7 +224,7 @@
 	{
 		return 0;
 	}
-	else if ( nDim >= pImpl->nColCount )
+    else if (nDim >= pImpl->aCacheTable.getColSize())
 	{
 		DBG_ERROR("GetNumberFormat: invalid dimension");
 		return 0;
@@ -286,7 +242,7 @@
 
 BOOL ScSheetDPData::getIsDataLayoutDimension(long nColumn)
 {
-	return ( nColumn == pImpl->nColCount );
+    return (nColumn == pImpl->aCacheTable.getColSize());
 }
 
 void ScSheetDPData::SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty )
@@ -295,9 +251,28 @@
 	pImpl->bRepeatIfEmpty   = bRepeatIfEmpty;
 }
 
-void ScSheetDPData::ResetIterator()
+void ScSheetDPData::CreateCacheTable()
 {
-	pImpl->nNextRow = pImpl->aRange.aStart.Row() + 1;
+    // Scan and store the data from the source range.
+    if (!pImpl->aCacheTable.empty())
+        // already cached.
+        return;
+
+    pImpl->aCacheTable.fillTable(pImpl->pDoc, pImpl->aRange, pImpl->aQuery, pImpl->pSpecial);
+}
+
+void ScSheetDPData::FilterCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+    pImpl->aCacheTable.filterByPageDimension(rPageDims);
+}
+
+void ScSheetDPData::GetDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& rFilters, Sequence< Sequence<Any> >& rData)
+{
+    sal_Int32 nRowSize = pImpl->aCacheTable.getRowSize();
+    if (!nRowSize)
+        return;
+
+    pImpl->aCacheTable.filterTable(rFilters, rData);
 }
 
 void lcl_GetStringOrValue( ScDPItemData& rData, ScDocument* pDoc,
@@ -322,6 +297,22 @@
 		pDoc->GetString( nCol, nRow, nTab, rData.aString );
 }
 
+void ScSheetDPData::CalcResults(CalcInfo& rInfo, bool bAutoShow)
+{
+    CalcResultsFromCacheTable(pImpl->aCacheTable, rInfo, bAutoShow);
+}
+
+const ScDPCacheTable& ScSheetDPData::GetCacheTable() const
+{
+    return pImpl->aCacheTable;
+}
+
+void ScSheetDPData::ResetIterator()
+{
+    // skipping the header row.
+	pImpl->nNextRow = pImpl->aRange.aStart.Row() + 1;
+}
+
 BOOL ScSheetDPData::GetNextRow( const ScDPTableIteratorParam& rParam )
 {
 	if ( pImpl->nNextRow > pImpl->aRange.aEnd.Row() )
@@ -348,7 +339,7 @@
 		}
 
 		bFilteredOut = ( lcl_HasQuery(pImpl->aQuery) && 
-				!pImpl->pDoc->ValidQuery( pImpl->nNextRow, nDocTab, pImpl->aQuery, pSpecial ) );
+				!pImpl->pDoc->ValidQuery( pImpl->nNextRow, nDocTab, pImpl->aQuery, pImpl->pSpecial ) );
 		if ( bFilteredOut )
 		{
 			++pImpl->nNextRow;
@@ -360,6 +351,7 @@
 
 	//!	use more efficient iterators
 
+    // Populate column field information.
 	for (i=0; i<rParam.nColCount; i++)
 	{
 		long nDim = rParam.pCols[i];
@@ -371,6 +363,7 @@
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
 	}
 
+    // Populate row field information.
 	for (i=0; i<rParam.nRowCount; i++)
 	{
 		long nDim = rParam.pRows[i];
@@ -382,6 +375,7 @@
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
 	}
 
+    // Populate page dimension information from the sheet.
 	for (i=0; i<rParam.nPageCount; i++)
 	{
 		long nDim = rParam.pPages[i];
@@ -393,6 +387,7 @@
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
 	}
 
+    // Populate data dimension information from the row.
 	for (i=0; i<rParam.nDatCount; i++)
 	{
 		long nDim = rParam.pDats[i];
Index: sc/source/core/data/dptabdat.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabdat.cxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dptabdat.cxx
--- sc/source/core/data/dptabdat.cxx	27 Feb 2007 12:05:02 -0000	1.12
+++ sc/source/core/data/dptabdat.cxx	25 Oct 2007 18:11:19 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -50,8 +50,18 @@
 #include <unotools/collatorwrapper.hxx>
 #endif
 
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+
 #include "dptabdat.hxx"
 #include "global.hxx"
+#include "dpcachetable.hxx"
+#include "dptabres.hxx"
+
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
+using ::std::vector;
+using ::std::set;
 
 // -----------------------------------------------------------------------
 
@@ -135,7 +145,43 @@
 {
 }
 
-// -----------------------------------------------------------------------
+// ---------------------------------------------------------------------------
+
+ScDPTableData::CalcInfo::CalcInfo()
+{
+}
+
+ScDPTableData::CalcInfo::CalcInfo(const CalcInfo& rOther)
+{
+    assign(rOther);
+}
+
+ScDPTableData::CalcInfo& ScDPTableData::CalcInfo::operator =(const CalcInfo& rOther)
+{
+    if (this == &rOther)
+        return *this;
+
+    assign(rOther);
+    return *this;
+}
+
+void ScDPTableData::CalcInfo::assign(const CalcInfo& rOther)
+{
+    aColLevelDims.assign(rOther.aColLevelDims.begin(), rOther.aColLevelDims.end());
+    aColDims.assign(rOther.aColDims.begin(), rOther.aColDims.end());
+    aColLevels.assign(rOther.aColLevels.begin(), rOther.aColLevels.end());
+    aRowLevelDims.assign(rOther.aRowLevelDims.begin(), rOther.aRowLevelDims.end());
+    aRowDims.assign(rOther.aRowDims.begin(), rOther.aRowDims.end());
+    aRowLevels.assign(rOther.aRowLevels.begin(), rOther.aRowLevels.end());
+    aPageDims.assign(rOther.aPageDims.begin(), rOther.aPageDims.end());
+    aDataSrcCols.assign(rOther.aDataSrcCols.begin(), rOther.aDataSrcCols.end());
+
+    pInitState = rOther.pInitState;
+    pColRoot = rOther.pColRoot;
+    pRowRoot = rOther.pRowRoot;
+}
+
+// ---------------------------------------------------------------------------
 
 ScDPTableData::ScDPTableData()
 {
@@ -193,6 +239,26 @@
 	return nRet;
 }
 
+void ScDPTableData::CreateCacheTable()
+{
+    fprintf(stdout, "ScDPTableData::CreateCacheTable: un-implemented...\n");fflush(stdout);
+}
+
+void ScDPTableData::FilterCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+    fprintf(stdout, "ScDPTableData::FilterCacheTable: un-implemented...\n");fflush(stdout);
+}
+
+void ScDPTableData::GetDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& aFilters, Sequence< Sequence<Any> >& rTabData)
+{
+    fprintf(stdout, "ScDPTableData::GetDrillDownData: un-implemented...\n");fflush(stdout);
+}
+
+void ScDPTableData::CalcResults(CalcInfo& rInfo, bool bAutoShow)
+{
+    fprintf(stdout, "ScDPTableData::CalcResults: un-implemented...\n");fflush(stdout);
+}
+
 UINT32 ScDPTableData::GetNumberFormat(long)
 {
 	return 0;			// default format
@@ -227,6 +293,98 @@
     return FALSE;
 }
 
+void ScDPTableData::FillRowDataFromCacheTable(sal_Int32 nRow, const ScDPCacheTable& rCacheTable, 
+                                        const CalcInfo& rInfo, CalcRowData& rData)
+{
+    // column dimensions
+    GetItemData(rCacheTable, nRow, rInfo.aColLevelDims, rData.aColData);
+
+    // row dimensions
+    GetItemData(rCacheTable, nRow, rInfo.aRowLevelDims, rData.aRowData);
+
+    // page dimensions
+    GetItemData(rCacheTable, nRow, rInfo.aPageDims, rData.aPageData);
+
+    for (sal_Int32 i = 0; i < rInfo.aDataSrcCols.size(); ++i)
+    {
+        long nDim = rInfo.aDataSrcCols[i];
+        rData.aValues.push_back( ScDPValueData() );
+        ScDPValueData& rVal = rData.aValues.back();
+        const ScDPCacheTable::Cell* pCell = rCacheTable.getCell(nDim, nRow);
+        if (pCell)
+        {
+            rVal.fValue = pCell->mbNumeric ? pCell->mfValue : 0.0;
+            rVal.nType = pCell->mnType;
+        }
+        else
+            rVal.Set(0.0, SC_VALTYPE_EMPTY);
+    }
+}
+
+void ScDPTableData::ProcessRowData(CalcInfo& rInfo, CalcRowData& rData, bool bAutoShow)
+{
+    if (!bAutoShow)
+    {
+        rInfo.pColRoot->LateInitFrom(&rInfo.aColDims[0], &rInfo.aColLevels[0], &rData.aColData[0], *rInfo.pInitState);
+        rInfo.pRowRoot->LateInitFrom(&rInfo.aRowDims[0], &rInfo.aRowLevels[0], &rData.aRowData[0], *rInfo.pInitState);
+    }
+
+    if ( ( !rInfo.pColRoot->GetChildDimension() || rInfo.pColRoot->GetChildDimension()->IsValidEntry(&rData.aColData[0]) ) &&
+         ( !rInfo.pRowRoot->GetChildDimension() || rInfo.pRowRoot->GetChildDimension()->IsValidEntry(&rData.aRowData[0]) ) )
+    {
+        //! single process method with ColMembers, RowMembers and data !!!
+        if (rInfo.pColRoot->GetChildDimension())
+            rInfo.pColRoot->GetChildDimension()->ProcessData(&rData.aColData[0], NULL, NULL, &rData.aValues[0]);
+
+        rInfo.pRowRoot->ProcessData(&rData.aRowData[0], rInfo.pColRoot->GetChildDimension(), 
+                                    &rData.aColData[0], &rData.aValues[0]);
+    }
+}
+
+void ScDPTableData::CalcResultsFromCacheTable(const ScDPCacheTable& rCacheTable, CalcInfo& rInfo, bool bAutoShow)
+{
+    sal_Int32 nRowSize = rCacheTable.getRowSize();
+    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+    {
+        if (!rCacheTable.isRowActive(nRow))
+            continue;
+
+        CalcRowData aData;
+        FillRowDataFromCacheTable(nRow, rCacheTable, rInfo, aData);
+        ProcessRowData(rInfo, aData, bAutoShow);
+    }
+}
+
+void ScDPTableData::GetItemData(const ScDPCacheTable& rCacheTable, sal_Int32 nRow, const vector<long>& rDims, vector<ScDPItemData>& rItemData)
+{
+    for (sal_Int32 i = 0; i < rDims.size(); ++i)
+    {
+        long nDim = rDims[i];
+        rItemData.push_back( ScDPItemData() );
+        ScDPItemData& rData = rItemData.back();
+        if (getIsDataLayoutDimension(nDim))
+            rData.SetString(String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("x")));
+        else
+        {
+            const ScDPCacheTable::Cell* pCell = rCacheTable.getCell(nDim, nRow);
+            if (pCell)
+            {
+                const String* pString = ScDPCacheTable::getString(pCell->mnStrId);
+                if (pString)
+                {
+                    rData.aString = *pString;
+                    rData.bHasValue = false;
+                    if (pCell->mbNumeric)
+                    {
+                        rData.bHasValue = true;
+                        rData.fValue = pCell->mfValue;
+                    }
+                }
+            }
+        }
+    }
+}
+
 // -----------------------------------------------------------------------
 
 
Index: sc/source/core/data/dptabres.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabres.cxx,v
retrieving revision 1.11
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.11 dptabres.cxx
--- sc/source/core/data/dptabres.cxx	27 Feb 2007 12:05:33 -0000	1.11
+++ sc/source/core/data/dptabres.cxx	25 Oct 2007 18:11:20 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -989,6 +989,25 @@
 
 	bInitialized = TRUE;
 
+#if 1
+    if (!*ppDim)
+        // No next dimension.  Bail out.
+        return;
+
+    //	skip child dimension if details are not shown
+    if ( pMemberDesc && !pMemberDesc->getShowDetails() )
+    {
+        bHasHiddenDetails = TRUE;   // only if there is a next dimension
+        return;
+    }
+
+    //	LateInitFrom is called several times...
+    if ( !pChildDimension )
+        pChildDimension = new ScDPResultDimension( pResultData );
+
+    pChildDimension->LateInitFrom( ppDim, ppLev, pItemData, rInitState );
+
+#else	
 	//	skip child dimension if details are not shown
 	if ( pMemberDesc && !pMemberDesc->getShowDetails() )
 	{
@@ -1004,6 +1023,7 @@
 			pChildDimension = new ScDPResultDimension( pResultData );
 		pChildDimension->LateInitFrom( ppDim, ppLev, pItemData, rInitState );
 	}
+#endif    
 }
 
 BOOL ScDPResultMember::IsSubTotalInTitle(long nMeasure) const
Index: sc/source/core/data/dptabsrc.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabsrc.cxx,v
retrieving revision 1.20
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.20 dptabsrc.cxx
--- sc/source/core/data/dptabsrc.cxx	27 Sep 2007 13:52:51 -0000	1.20
+++ sc/source/core/data/dptabsrc.cxx	25 Oct 2007 18:11:20 -0000
@@ -36,11 +36,15 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
+#include <stdio.h>
 
+#define USE_NEW_CODE 1
 
 // INCLUDE ---------------------------------------------------------------
 
 #include <algorithm>
+#include <vector>
+#include <set>
 
 #include <tools/debug.hxx>
 #include <rtl/math.hxx>
@@ -58,6 +62,7 @@
 
 #include <com/sun/star/beans/PropertyAttribute.hpp>
 #include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 #include <com/sun/star/sheet/DataPilotFieldReferenceType.hpp>
 #include <com/sun/star/sheet/DataPilotFieldSortMode.hpp>
 
@@ -72,6 +77,11 @@
 #endif
 
 using namespace com::sun::star;
+using ::std::vector;
+using ::std::set;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
 
 // -----------------------------------------------------------------------
 
@@ -409,6 +419,13 @@
 	DBG_ERROR("not implemented");	//! exception?
 }
 
+void SAL_CALL ScDPSource::getDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& aFilters, 
+                                           Sequence< Sequence<Any> >& rTabData)
+    throw (uno::RuntimeException)
+{
+    pData->GetDrillDownData(aFilters, rTabData);
+}
+
 String ScDPSource::getDataDescription()
 {
 	CreateRes_Impl();		// create pResData
@@ -500,6 +517,68 @@
 	bResultOverflow = FALSE;
 }
 
+#if USE_NEW_CODE
+long lcl_CountMinMembers(const vector<ScDPDimension*>& ppDim, const vector<ScDPLevel*>& ppLevel, long nLevels )
+{
+    //	Calculate the product of the member count for those consecutive levels that
+    //	have the "show all" flag, one following level, and the data layout dimension.
+
+    long nTotal = 1;
+    long nDataCount = 1;
+    BOOL bWasShowAll = TRUE;
+    long nPos = nLevels;
+    while ( nPos > 0 )
+    {
+        --nPos;
+
+        if ( nPos < nLevels && ppDim[nPos] == ppDim[nPos+1] )
+        {
+            DBG_ERROR("lcl_CountMinMembers: multiple levels from one dimension not implemented");
+            return 0;
+        }
+
+        BOOL bDo = FALSE;
+        if ( ppDim[nPos]->getIsDataLayoutDimension() )
+        {
+            //	data layout dim doesn't interfere with "show all" flags
+            nDataCount = ppLevel[nPos]->GetMembersObject()->getCount();
+            if ( nDataCount == 0 )
+                nDataCount = 1;
+        }
+        else if ( bWasShowAll )     // "show all" set for all following levels?
+        {
+            bDo = TRUE;
+            if ( !ppLevel[nPos]->getShowEmpty() )
+            {
+                //	this level is counted, following ones are not
+                bWasShowAll = FALSE;
+            }
+        }
+        if ( bDo )
+        {
+            long nThisCount = ppLevel[nPos]->GetMembersObject()->getMinMembers();
+            if ( nThisCount == 0 )
+            {
+                nTotal = 1;         //	empty level -> start counting from here
+                                    //!	start with visible elements in this level?
+            }
+            else
+            {
+                if ( nTotal >= LONG_MAX / nThisCount )
+                    return LONG_MAX;                        //	overflow
+                nTotal *= nThisCount;
+            }
+        }
+    }
+
+    //	always include data layout dim, even after restarting
+    if ( nTotal >= LONG_MAX / nDataCount )
+        return LONG_MAX;                        //	overflow
+    nTotal *= nDataCount;
+
+    return nTotal;
+}
+#else
 long lcl_CountMinMembers( ScDPDimension** ppDim, ScDPLevel** ppLevel, long nLevels )
 {
 	//	Calculate the product of the member count for those consecutive levels that
@@ -560,6 +639,7 @@
 
 	return nTotal;
 }
+#endif
 
 long lcl_GetIndexFromName( const rtl::OUString rName, const uno::Sequence<rtl::OUString>& rElements )
 {
@@ -572,6 +652,53 @@
     return -1;  // not found
 }
 
+void ScDPSource::FillCalcInfo(bool bIsRow, ScDPTableData::CalcInfo& rInfo, bool &rHasAutoShow)
+{
+    long* nDims = bIsRow ? nRowDims : nColDims;
+    long nDimCount = bIsRow ? nRowDimCount : nColDimCount;
+    for (long i = 0; i<nDimCount; ++i)
+    {
+        ScDPDimension* pDim = GetDimensionsObject()->getByIndex( nDims[i] );
+        long nHierarchy = pDim->getUsedHierarchy();
+        if ( nHierarchy >= pDim->GetHierarchiesObject()->getCount() )
+            nHierarchy = 0;
+        ScDPLevels* pLevels = pDim->GetHierarchiesObject()->getByIndex(nHierarchy)->GetLevelsObject();
+        long nCount = pLevels->getCount();
+
+        //!	Test
+        if ( pDim->getIsDataLayoutDimension() && nDataDimCount < 2 )
+            nCount = 0;
+        //!	Test
+
+        for (long j = 0; j < nCount; ++j)
+        {
+            ScDPLevel* pLevel = pLevels->getByIndex(j);
+            pLevel->EvaluateSortOrder();
+
+            // no layout flags for column fields, only for row fields
+            pLevel->SetEnableLayout( bIsRow == true );           
+
+            if ( pLevel->GetAutoShow().IsEnabled )
+                rHasAutoShow = TRUE;
+
+            if (bIsRow)
+            {
+                rInfo.aRowLevelDims.push_back(nDims[i]);
+                rInfo.aRowDims.push_back(pDim);
+                rInfo.aRowLevels.push_back(pLevel);
+            }
+            else
+            {
+                rInfo.aColLevelDims.push_back(nDims[i]);
+                rInfo.aColDims.push_back(pDim);
+                rInfo.aColLevels.push_back(pLevel);
+            }
+
+            pLevel->GetMembersObject();                 // initialize for groups
+        }
+    }
+}
+
 void ScDPSource::CreateRes_Impl()
 {
 	if ( !pResData )
@@ -593,7 +720,12 @@
 			pDataRefValues = new sheet::DataPilotFieldReference[nDataDimCount];
 		}
 
+#if USE_NEW_CODE
+        ScDPTableData::CalcInfo aInfo;
+#else
 		long nDataSrcCols[SC_DAPI_MAXFIELDS];
+#endif
+
 		USHORT nDataRefOrient[SC_DAPI_MAXFIELDS];
 
 		//	LateInit (initialize only those rows/children that are used) can be used unless
@@ -645,10 +777,17 @@
 			//!	the complete name (function and field) must be stored at the dimension
 
 			long nSource = ((ScDPDimension*)pDim)->GetSourceDim();
+#if USE_NEW_CODE
+            if (nSource >= 0)
+                aInfo.aDataSrcCols.push_back(nSource);
+            else
+                aInfo.aDataSrcCols.push_back(nDimIndex);
+#else			
 			if ( nSource >= 0 )
 				nDataSrcCols[i] = nSource;
 			else
 				nDataSrcCols[i] = nDimIndex;
+#endif            
 		}
 
 		pResData = new ScDPResultData( this );
@@ -659,7 +798,7 @@
 		delete[] pDataNames;
 		delete[] pDataRefValues;
 
-        BOOL bHasAutoShow = FALSE;
+        bool bHasAutoShow = false;
 
         ScDPInitState aInitState;
 
@@ -677,6 +816,58 @@
 		pColResRoot = new ScDPResultMember( pResData, NULL, NULL, NULL, bColumnGrand );
 		pRowResRoot = new ScDPResultMember( pResData, NULL, NULL, NULL, bRowGrand );
 
+#if USE_NEW_CODE
+        FillCalcInfo(false, aInfo, bHasAutoShow);
+        long nColLevelCount = aInfo.aColLevels.size();
+
+        // Some legacy code expects them to be NULL terminated (TODO: fix this!)
+        aInfo.aColDims.push_back(NULL);
+        aInfo.aColLevels.push_back(NULL);
+
+        pColResRoot->InitFrom( &aInfo.aColDims[0], &aInfo.aColLevels[0], aInitState );
+        pColResRoot->SetHasElements();
+
+        FillCalcInfo(true, aInfo, bHasAutoShow);
+        long nRowLevelCount = aInfo.aRowLevels.size();
+
+        // Some legacy code expects them to be NULL terminated (TODO: fix this!)
+        aInfo.aRowDims.push_back(NULL);
+        aInfo.aRowLevels.push_back(NULL);
+
+        if ( nRowLevelCount > 0 )
+        {
+            // disable layout flags for the innermost row field (level)
+            aInfo.aRowLevels[nRowLevelCount-1]->SetEnableLayout( FALSE );
+        }
+
+        pRowResRoot->InitFrom( &aInfo.aRowDims[0], &aInfo.aRowLevels[0], aInitState );
+        pRowResRoot->SetHasElements();
+
+        // initialize members object also for all page dimensions (needed for numeric groups)
+        fprintf(stdout, "ScDPSource::CreateRes_Impl: page dim count = %ld\n", nPageDimCount);fflush(stdout);
+        for (i=0; i<nPageDimCount; i++)
+        {
+            fprintf(stdout, "ScDPSource::CreateRes_Impl:   page dim = %ld\n", nPageDims[i]);fflush(stdout);
+            ScDPDimension* pDim = GetDimensionsObject()->getByIndex( nPageDims[i] );
+            long nHierarchy = pDim->getUsedHierarchy();
+            if ( nHierarchy >= pDim->GetHierarchiesObject()->getCount() )
+                nHierarchy = 0;
+
+            fprintf(stdout, "ScDPSource::CreateRes_Impl:   hierarchy = %ld\n", nHierarchy);fflush(stdout);
+
+            ScDPLevels* pLevels = pDim->GetHierarchiesObject()->getByIndex(nHierarchy)->GetLevelsObject();
+            long nCount = pLevels->getCount();
+            fprintf(stdout, "ScDPSource::CreateRes_Impl:   level count = %ld\n", nCount);fflush(stdout);
+            for (long j=0; j<nCount; j++)
+                pLevels->getByIndex(j)->GetMembersObject();             // initialize for groups
+        }
+
+		//	pre-check: calculate minimum number of result columns / rows from
+		//	levels that have the "show all" flag set
+
+		long nMinColMembers = lcl_CountMinMembers( aInfo.aColDims, aInfo.aColLevels, nColLevelCount );
+		long nMinRowMembers = lcl_CountMinMembers( aInfo.aRowDims, aInfo.aRowLevels, nRowLevelCount );
+#else		
 		ScDPDimension* ppColDim[SC_DAPI_MAXFIELDS];		//! Ref?
 		ScDPLevel* ppColLevel[SC_DAPI_MAXFIELDS];		//! Ref?
 		long nColLevelDims[SC_DAPI_MAXFIELDS];
@@ -777,6 +968,8 @@
 
 		long nMinColMembers = lcl_CountMinMembers( ppColDim, ppColLevel, nColLevelCount );
 		long nMinRowMembers = lcl_CountMinMembers( ppRowDim, ppRowLevel, nRowLevelCount );
+#endif        
+        fprintf(stdout, "ScDPSource::CreateRes_Impl: min col members = %ld  min row members = %ld\n", nMinColMembers, nMinRowMembers);fflush(stdout);
 		if ( nMinColMembers > SC_MINCOUNT_LIMIT || nMinRowMembers > SC_MINCOUNT_LIMIT )
 		{
 			//	resulting table is too big -> abort before calculating
@@ -786,6 +979,27 @@
 		}
 		else
 		{
+            {
+                vector<ScDPDimension*> aPageDims;
+                aPageDims.reserve(nPageDimCount);
+                for (i = 0; i < nPageDimCount; ++i)
+                {
+                    ScDPDimension* pDim = GetDimensionsObject()->getByIndex(nPageDims[i]);
+                    if (pDim)
+                        aPageDims.push_back(pDim);
+                }
+                pData->FilterCacheTable(aPageDims);
+            }
+#if USE_NEW_CODE
+            aInfo.aPageDims.reserve(nPageDimCount);
+            for (i = 0; i < nPageDimCount; ++i)
+                aInfo.aPageDims.push_back(nPageDims[i]);
+
+            aInfo.pInitState = &aInitState;
+            aInfo.pColRoot   = pColResRoot;
+            aInfo.pRowRoot   = pRowResRoot;
+            pData->CalcResults(aInfo, false);
+#else
 			ScDPItemData aColData[SC_DAPI_MAXFIELDS];
 			ScDPItemData aRowData[SC_DAPI_MAXFIELDS];
 			ScDPItemData aPageData[SC_DAPI_MAXFIELDS];
@@ -829,6 +1043,7 @@
 					}
 				}
 			}
+#endif            
 
 			// ----------------------------------------------------------------
 			//  With all data processed, calculate the final results:
@@ -839,6 +1054,7 @@
 
 			if ( bHasAutoShow )     // do the double calculation only if AutoShow is used
 			{
+                fprintf(stdout, "ScDPSource::CreateRes_Impl: AutoShow is enabled\n");fflush(stdout);
 			    //  Find the desired members and set bAutoHidden flag for the others
     			pRowResRoot->DoAutoShow( pColResRoot );
 
@@ -846,7 +1062,9 @@
     			//  desired members only.
     			pColResRoot->ResetResults( TRUE );
     			pRowResRoot->ResetResults( TRUE );
-
+#if USE_NEW_CODE
+                pData->CalcResults(aInfo, true);
+#else
     			//  Again loop over the source data.
     			//  LateInitFrom is not needed again.
     			pData->ResetIterator();
@@ -861,10 +1079,15 @@
     					pRowResRoot->ProcessData( aRowData, pColResRoot->GetChildDimension(), aColData, aValues );
     				}
     			}
+#endif                
 
     			//  Call UpdateDataResults again, with the new (limited) values.
     			pRowResRoot->UpdateDataResults( pColResRoot, pResData->GetRowStartMeasure() );
 			}
+            else
+            {
+                fprintf(stdout, "ScDPSource::CreateRes_Impl: AutoShow is disabled.\n");fflush(stdout);
+            }
 
 			//  SortMembers does the sorting by a result dimension, using the orginal results,
 			//  but not running totals etc.
Index: sc/source/core/data/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/core/data/makefile.mk,v
retrieving revision 1.21
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 makefile.mk
--- sc/source/core/data/makefile.mk	27 Feb 2007 12:06:42 -0000	1.21
+++ sc/source/core/data/makefile.mk	25 Oct 2007 18:11:20 -0000
@@ -77,6 +77,7 @@
 	$(SLO)$/documen8.obj \
 	$(SLO)$/documen9.obj \
 	$(SLO)$/document.obj \
+        $(SLO)$/dpcachetable.obj \
         $(SLO)$/dpdimsave.obj \
         $(SLO)$/dpgroup.obj \
 	$(SLO)$/dpobject.obj \
@@ -131,6 +132,7 @@
 	$(SLO)$/documen5.obj \
 	$(SLO)$/documen6.obj \
 	$(SLO)$/documen9.obj \
+        $(SLO)$/dpcachetable.obj \
 	$(SLO)$/dpsdbtab.obj \
 	$(SLO)$/dpobject.obj \
 	$(SLO)$/dpoutput.obj \
Index: sc/source/ui/view/gridwin.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/gridwin.cxx,v
retrieving revision 1.85
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.85 gridwin.cxx
--- sc/source/ui/view/gridwin.cxx	27 Sep 2007 13:56:11 -0000	1.85
+++ sc/source/ui/view/gridwin.cxx	25 Oct 2007 18:11:22 -0000
@@ -159,6 +159,8 @@
 #endif
 
 using namespace com::sun::star;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
 
 const BYTE SC_NESTEDBUTTON_NONE = 0;
 const BYTE SC_NESTEDBUTTON_DOWN = 1;
@@ -2032,7 +2034,38 @@
                 }
 			}
 			else
-				Sound::Beep();		// nothing to expand/collapse
+            {
+                // Check if the data area is double-clicked.
+                Sequence< Sequence<Any> > aArrayData;
+                pDPObj->GetDrillDownData(aCellPos, aArrayData);
+                sal_Int32 nRowSize = aArrayData.getLength();
+                if (nRowSize > 0)
+                {
+                    ScTabViewShell* pViewShell = pViewData->GetViewShell();
+                    String aNewTabName;
+                    pViewData->GetDocument()->CreateValidTabName(aNewTabName);
+                    SCTAB nNewTab = pViewData->GetTabNo();
+                    if ( pViewShell->InsertTable(aNewTabName, nNewTab, false) )
+                    {
+                        for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+                        {
+                            sal_Int32 nColSize = aArrayData[nRow].getLength();
+                            for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+                            {
+                                const Any& rAny = aArrayData[nRow][nCol];
+                                rtl::OUString aStr;
+                                double fVal;
+                                if (rAny >>= aStr)
+                                    pDoc->SetString(nCol, nRow, nNewTab, String(aStr));
+                                else if (rAny >>= fVal)
+                                    pDoc->SetValue(nCol, nRow, nNewTab, fVal);
+                            }
+                        }
+                    }
+                }
+                else
+                    ::Sound::Beep();
+            }
 
 			return;
 		}
--- /dev/null	2007-05-04 06:54:36.000000000 -0400
+++ sc/inc/dpcachetable.hxx	2007-10-16 00:10:28.000000000 -0400
@@ -0,0 +1,189 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: dpobject.hxx,v $
+ *
+ *  $Revision: 1.12 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 13:41:57 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_DPCACHETABLE_HXX
+#define SC_DPCACHETABLE_HXX
+
+#include "sal/types.h"
+#include "osl/mutex.hxx"
+#include "global.hxx"
+#include "collect.hxx"
+#include "dptabdat.hxx"
+
+#include <vector>
+#include <set>
+#include <hash_map>
+#include <boost/shared_ptr.hpp>
+#include <com/sun/star/uno/Reference.hxx>
+
+namespace com { namespace sun { namespace star {
+    namespace sdbc {
+        class XRowSet;
+    }
+    namespace sheet {
+        struct DataPilotFieldFilter;
+    }
+}}}
+
+class Date;
+
+class ScDocument;
+class ScRange;
+class ScDPDimension;
+
+class ScSharedStringTable
+{
+public:
+    static const sal_Int32 EMPTY = 0;
+
+    sal_Int32 insertString(const String& aStr);
+    sal_Int32 getStringId(const String& aStr);
+    const String* getString(sal_Int32 nId) const;
+
+    ScSharedStringTable();
+    ~ScSharedStringTable();
+
+private:
+    typedef ::std::hash_map< String, sal_Int32, ScStringHashCode, ::std::equal_to< String > > SharedStrMap;
+
+    ::std::vector<String> maSharedStrings;
+    SharedStrMap maSharedStringIds;
+    sal_Int32 mnStrCount;
+};
+
+// ----------------------------------------------------------------------------
+
+class ScDPCacheTable
+{
+public:
+    /** individual cell within table. */
+    struct Cell
+    {
+        sal_Int32   mnStrId;
+        double      mfValue;
+        bool        mbNumeric;
+        sal_uInt8   mnType;
+
+        Cell();
+    };
+
+    /** filtering criteria */
+    struct Filter
+    {
+        sal_Int32   mnFieldIndex;
+        sal_Int32   mnMatchStrId;
+
+        Filter();
+    };
+
+    ScDPCacheTable();
+    ~ScDPCacheTable();
+
+    sal_Int32 getHeaderSize() const;
+    sal_Int32 getRowSize() const;
+    sal_Int32 getColSize() const;
+
+    /** Fill the internal table from the cell range provided.  This function
+        assumes that the first row is the column header. */
+    void fillTable(ScDocument* pDoc, const ScRange& rRange, const ScQueryParam& rQuery, BOOL* pSpecial);
+
+    /** Fill the internal table from database connection object.  This function
+        assumes that the first row is the column header. */
+    void fillTable(const ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XRowSet >& xRowSet,
+                   const Date& rNullDate);
+
+    /** Check whether a specified row is active or not.  When a row is active,
+        it is used in calculation of the results data.  A row becomes inactive
+        when it is filtered out by page field. */
+    bool isRowActive(sal_Int32 nRow) const;
+
+    /** Set filter on/off flag to each row to control visibility.  The caller
+        must ensure that the table is filled before calling this function. */
+    void filterByPageDimension(const ::std::vector<ScDPDimension*>& rPageDims);
+
+    /** Get the cell instance at specified location within the data grid. Note
+        that the data grid doesn't include the header row.  Don't delete the
+        returned object! */
+    const ::ScDPCacheTable::Cell* getCell(SCCOL nCol, SCROW nRow) const;
+
+    const String* getFieldName(sal_Int32 nIndex) const;
+
+    /** Get the field index (i.e. column ID in the original data source) based
+        on the string value that corresponds with the column title.  It returns
+        -1 if no field matching the string value exists. */
+    sal_Int32 getFieldIndex(const String& rStr) const;
+
+    /** Get the unique entries for a field specified by index.  The caller must
+        make sure that the table is filled before calling function, or it will
+        get an empty collection. */
+    const TypedStrCollection& getFieldEntries(sal_Int32 nIndex) const;
+
+    void filterTable(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters,
+                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+
+    void clear();
+    void swap(ScDPCacheTable& rOther);
+    bool empty() const;
+
+    static const String* getString(sal_Int32 nId);
+    static sal_Int32 getStringId(const String& aStr);
+
+private:
+    void getValueData(ScDocument* pDoc, const ScAddress& rPos, Cell& rCell);
+    ScDPCacheTable::Cell getSelectedDimension(ScDPDimension* pDim) const;
+
+private:
+    typedef ::boost::shared_ptr<TypedStrCollection> TypedStrCollectionPtr;
+
+    /** main data table. */
+    ::std::vector< ::std::vector< ::ScDPCacheTable::Cell > > maTable;
+
+    /** header string IDs */
+    ::std::vector<sal_Int32> maHeader;
+
+    /** unique field entires for each field (column). */
+    ::std::vector<TypedStrCollectionPtr> maFieldEntries;
+
+    /** used to track visibility of rows.  The first row below the header row
+        has the index of 0. */
+    ::std::vector<bool> maRowsVisible;
+
+    static sal_Int32 insertString(const String& aStr);
+    static ::osl::Mutex maStrMutex;
+    static ScSharedStringTable maStringTable;
+};
+
+
+#endif
--- /dev/null	2007-05-04 06:54:36.000000000 -0400
+++ sc/source/core/data/dpcachetable.cxx	2007-10-23 17:09:34.000000000 -0400
@@ -0,0 +1,653 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: dpobject.hxx,v $
+ *
+ *  $Revision: 1.12 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 13:41:57 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "dpcachetable.hxx"
+#include "document.hxx"
+#include "address.hxx"
+#include "cell.hxx"
+#include "dptabdat.hxx"
+#include "dptabsrc.hxx"
+
+#include <stdio.h>
+
+#include <com/sun/star/sdbc/DataType.hpp>
+#include <com/sun/star/sdbc/XRow.hpp>
+#include <com/sun/star/sdbc/XRowSet.hpp>
+#include <com/sun/star/sdbc/XResultSetMetaData.hpp>
+#include <com/sun/star/sdbc/XResultSetMetaDataSupplier.hpp>
+#include <com/sun/star/util/Date.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+
+using namespace ::com::sun::star;
+
+using ::rtl::OUString;
+using ::std::vector;
+using ::std::set;
+using ::com::sun::star::uno::Exception;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::com::sun::star::sheet::DataPilotFieldFilter;
+
+static BOOL lcl_HasQueryEntry( const ScQueryParam& rParam )
+{
+    return rParam.GetEntryCount() > 0 &&
+            rParam.GetEntry(0).bDoQuery;
+}
+
+ScSharedStringTable::ScSharedStringTable() :
+    mnStrCount(0)
+{
+    // empty string (ID = 0)
+    maSharedStrings.push_back(String());
+    maSharedStringIds.insert( SharedStrMap::value_type(String(), mnStrCount++) );
+}
+
+ScSharedStringTable::~ScSharedStringTable()
+{
+}
+
+sal_Int32 ScSharedStringTable::insertString(const String& aStr)
+{
+    SharedStrMap::const_iterator itr = maSharedStringIds.find(aStr), 
+        itrEnd = maSharedStringIds.end();
+
+    if (itr == itrEnd)
+    {
+        // new string.
+        maSharedStrings.push_back(aStr);
+        maSharedStringIds.insert( SharedStrMap::value_type(aStr, mnStrCount) );
+        return mnStrCount++;
+    }
+
+    // existing string.
+    return itr->second;
+}
+
+sal_Int32 ScSharedStringTable::getStringId(const String& aStr)
+{
+    SharedStrMap::const_iterator itr = maSharedStringIds.find(aStr), 
+        itrEnd = maSharedStringIds.end();
+    if (itr == itrEnd)
+    {
+        // string not found.
+        return insertString(aStr);
+    }
+    return itr->second;
+}
+
+const String* ScSharedStringTable::getString(sal_Int32 nId) const
+{
+    if (nId >= mnStrCount)
+        return NULL;
+
+    return &maSharedStrings[nId];
+}
+
+// ----------------------------------------------------------------------------
+
+ScDPCacheTable::Cell::Cell() :
+    mfValue(0.0),
+    mbNumeric(false),
+    mnType(SC_VALTYPE_EMPTY)
+{
+}
+
+ScDPCacheTable::Filter::Filter()
+{
+}
+
+::osl::Mutex ScDPCacheTable::maStrMutex;
+ScSharedStringTable ScDPCacheTable::maStringTable;
+
+ScDPCacheTable::ScDPCacheTable()
+{
+}
+
+ScDPCacheTable::~ScDPCacheTable()
+{
+}
+
+sal_Int32 ScDPCacheTable::getHeaderSize() const
+{
+    return maHeader.size();
+}
+
+sal_Int32 ScDPCacheTable::getRowSize() const
+{
+    return maTable.size();
+}
+
+sal_Int32 ScDPCacheTable::getColSize() const
+{
+    return maTable.empty() ? 0 : maTable[0].size();
+}
+
+void ScDPCacheTable::fillTable(ScDocument* pDoc, const ScRange& rRange, const ScQueryParam& rQuery, BOOL* pSpecial)
+{
+    SCTAB nTab = rRange.aStart.Tab();
+    SCCOL nStartCol = rRange.aStart.Col();
+    SCROW nStartRow = rRange.aStart.Row();
+    SCCOL nColCount = rRange.aEnd.Col() - rRange.aStart.Col() + 1;
+    SCROW nRowCount = rRange.aEnd.Row() - rRange.aStart.Row() + 1;
+
+    if (nRowCount <= 1 || nColCount <= 0)
+        return;
+
+    maTable.clear();
+    maTable.reserve(nRowCount);
+    maHeader.clear();
+    maHeader.reserve(nColCount);
+    maRowsVisible.clear();
+    maRowsVisible.reserve(nRowCount);
+
+    // Header row
+    for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+    {
+        String aStr;
+        pDoc->GetString(nCol, 0, nTab, aStr);
+        sal_Int32 nStrId = maStringTable.insertString(aStr);
+        maHeader.push_back(nStrId);
+    }
+
+    // Initialize field entries container.
+    maFieldEntries.clear();
+    maFieldEntries.reserve(nColCount);
+    for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+    {
+        TypedStrCollectionPtr p(new TypedStrCollection);
+        maFieldEntries.push_back(p);
+    }
+
+    // Data rows
+    for (SCROW nRow = 1; nRow < nRowCount; ++nRow)
+    {
+        if ( lcl_HasQueryEntry(rQuery) && !pDoc->ValidQuery(nRow + nStartRow, nTab, rQuery, pSpecial) )
+            // filtered out by standard filter.
+            continue;
+
+        // Insert a new row into cache table.
+        maRowsVisible.push_back(true);
+        maTable.push_back( vector<Cell>() );
+        maTable.back().reserve(nColCount);
+
+        for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+        {
+            maTable.back().push_back( ScDPCacheTable::Cell() );
+            Cell& rCell = maTable.back().back();
+                
+            String aStr;
+            pDoc->GetString(nStartCol + nCol, nStartRow + nRow, nTab, aStr);
+            rCell.mnStrId = maStringTable.insertString(aStr);
+            rCell.mnType = SC_VALTYPE_STRING;
+            rCell.mbNumeric = false;
+            ScAddress aPos(nStartCol + nCol, nStartRow + nRow, nTab);
+            getValueData(pDoc, aPos, rCell);
+
+            TypedStrData* pNew;
+            if (rCell.mbNumeric)
+                pNew = new TypedStrData(aStr, rCell.mfValue, SC_STRTYPE_VALUE);
+            else
+                pNew = new TypedStrData(aStr);
+
+            if (!maFieldEntries[nCol]->Insert(pNew))
+                delete pNew;
+        }
+    }
+}
+
+void lcl_GetCellValue(const Reference<sdbc::XRow>& xRow, sal_Int32 nType, long nCol,
+             const Date& rNullDate, ScDPCacheTable::Cell& rCell, String& rStr)
+{
+    short nNumType = NUMBERFORMAT_NUMBER;
+    BOOL bEmptyFlag = FALSE;
+    try
+    {
+        rStr = xRow->getString(nCol);
+        rCell.mnStrId = ScDPCacheTable::getStringId(rStr);
+        rCell.mnType = SC_VALTYPE_STRING;
+
+        switch (nType)
+        {
+            case sdbc::DataType::BIT:
+            case sdbc::DataType::BOOLEAN:
+            {
+                nNumType = NUMBERFORMAT_LOGICAL;
+                rCell.mfValue = xRow->getBoolean(nCol) ? 1 : 0;    
+                bEmptyFlag = (rCell.mfValue == 0.0 && xRow->wasNull());
+                rCell.mbNumeric = true;
+                rCell.mnType = SC_VALTYPE_VALUE;
+            }
+            break;
+
+            case sdbc::DataType::TINYINT:
+            case sdbc::DataType::SMALLINT:
+            case sdbc::DataType::INTEGER:
+            case sdbc::DataType::BIGINT:
+            case sdbc::DataType::FLOAT:
+            case sdbc::DataType::REAL:
+            case sdbc::DataType::DOUBLE:
+            case sdbc::DataType::NUMERIC:
+            case sdbc::DataType::DECIMAL:
+            {
+                //! do the conversion here?
+                rCell.mfValue = xRow->getDouble(nCol);
+                bEmptyFlag = (rCell.mfValue == 0.0 && xRow->wasNull());
+                rCell.mbNumeric = true;
+                rCell.mnType = SC_VALTYPE_VALUE;
+            }
+            break;
+
+            case sdbc::DataType::CHAR:
+            case sdbc::DataType::VARCHAR:
+            case sdbc::DataType::LONGVARCHAR:
+                bEmptyFlag = (rStr.Len() == 0 && xRow->wasNull());
+            break;
+
+            case sdbc::DataType::DATE:
+            {
+                nNumType = NUMBERFORMAT_DATE;
+
+                util::Date aDate = xRow->getDate(nCol);
+                rCell.mfValue = Date(aDate.Day, aDate.Month, aDate.Year) - rNullDate;
+                bEmptyFlag = xRow->wasNull();
+                rCell.mbNumeric = true;
+                rCell.mnType = SC_VALTYPE_VALUE;
+            }
+            break;
+
+                //! case sdbc::DataType::TIME:
+                //! case sdbc::DataType::TIMESTAMP:
+
+            case sdbc::DataType::SQLNULL:
+            case sdbc::DataType::BINARY:
+            case sdbc::DataType::VARBINARY:
+            case sdbc::DataType::LONGVARBINARY:
+            default:
+            break;
+        }
+    }
+    catch (uno::Exception&)
+    {
+    }
+}
+
+void ScDPCacheTable::fillTable(const Reference<sdbc::XRowSet>& xRowSet, const Date& rNullDate)
+{
+    try
+    {
+        Reference<sdbc::XResultSetMetaDataSupplier> xMetaSupp(xRowSet, UNO_QUERY_THROW);
+        Reference<sdbc::XResultSetMetaData> xMeta = xMetaSupp->getMetaData();
+        if (!xMeta.is())
+            return;
+
+        sal_Int32 nColCount = xMeta->getColumnCount();
+
+        // Get column titles and types.
+        vector<sal_Int32> aColTypes(nColCount);
+        maHeader.clear();
+        maHeader.reserve(nColCount);
+        for (sal_Int32 nCol = 0; nCol < nColCount; ++nCol)
+        {
+            String aColTitle = xMeta->getColumnLabel(nCol+1);
+            aColTypes[nCol]  = xMeta->getColumnType(nCol+1);
+            maHeader.push_back( ScDPCacheTable::getStringId(aColTitle) );
+        }
+
+        // Initialize field entries container.
+        maFieldEntries.clear();
+        maFieldEntries.reserve(nColCount);
+        for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+        {
+            TypedStrCollectionPtr p(new TypedStrCollection);
+            maFieldEntries.push_back(p);
+        }
+
+        // Now get the data rows.
+        Reference<sdbc::XRow> xRow(xRowSet, UNO_QUERY_THROW);
+        xRowSet->first();
+        maTable.clear();
+        maRowsVisible.clear();
+        do
+        {
+            maRowsVisible.push_back(true);
+            maTable.push_back( vector<Cell>() );
+            maTable.back().reserve(nColCount);
+            for (sal_Int32 nCol = 0; nCol < nColCount; ++nCol)
+            {
+                maTable.back().push_back( Cell() );
+                Cell& rCell = maTable.back().back();
+                String aStr;
+                lcl_GetCellValue(xRow, aColTypes[nCol], nCol+1, rNullDate, rCell, aStr);
+
+                TypedStrData* pNew;
+                if (rCell.mbNumeric)
+                    pNew = new TypedStrData(aStr, rCell.mfValue, SC_STRTYPE_VALUE);
+                else
+                    pNew = new TypedStrData(aStr);
+
+                if (!maFieldEntries[nCol]->Insert(pNew))
+                    delete pNew;
+            }
+        }
+        while (xRowSet->next());
+    }
+    catch (const Exception&)
+    {
+    }
+
+    xRowSet->beforeFirst();
+}
+
+bool ScDPCacheTable::isRowActive(sal_Int32 nRow) const
+{
+    if (nRow < 0 || nRow >= maRowsVisible.size())
+        // row index out of bound
+        return false;
+
+    return maRowsVisible[nRow];
+}
+
+void ScDPCacheTable::filterByPageDimension(const vector<ScDPDimension*>& rPageDims)
+{
+    sal_Int32 nRowSize = getRowSize();
+
+    if (nRowSize != static_cast<sal_Int32>(maRowsVisible.size()))
+    {
+        fprintf(stdout, "ScDPCacheTable::filterByPageDimension: the sizes of the two tables differ.\n");fflush(stdout);
+        return;
+    }
+
+    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+    {
+        maRowsVisible[nRow] = true;
+        const vector<Cell>& rRow = maTable[nRow];
+        vector<ScDPDimension*>::const_iterator itr = rPageDims.begin(), itrEnd = rPageDims.end();
+        for (; itr != itrEnd; ++itr)
+        {
+            ScDPDimension* pDim = *itr;
+            ScDPCacheTable::Cell aDimCell = getSelectedDimension(pDim);
+            
+            sal_Int32 nCol = pDim->GetDimension();
+            const Cell& rCell = rRow[nCol];
+            if (aDimCell.mnStrId != ScSharedStringTable::EMPTY && aDimCell.mnStrId != rCell.mnStrId)
+            {
+                // Selected page dimension value does not match the current value.  Skip it 
+                // (note: when the selected page dimension value is empty, '- all -' is 
+                // selected.
+                maRowsVisible[nRow] = false;
+                break;
+            }
+        }
+    }
+}
+
+const ::ScDPCacheTable::Cell* ScDPCacheTable::getCell(SCCOL nCol, SCROW nRow) const
+{
+    if ( nRow >= static_cast<SCROW>(maTable.size()) )
+        return NULL;
+
+    const vector<Cell>& rRow = maTable.at(nRow);
+    if ( nCol < 0 || static_cast<size_t>(nCol) >= rRow.size() )
+        return NULL;
+
+    return &rRow.at(nCol);
+}
+
+const String* ScDPCacheTable::getFieldName(sal_Int32 nIndex) const
+{
+    if (nIndex >= static_cast<sal_Int32>(maHeader.size()))
+        return NULL;
+
+    return getString(maHeader[nIndex]);
+}
+
+sal_Int32 ScDPCacheTable::getFieldIndex(const String& rStr) const
+{
+    sal_Int32 nStrId = getStringId(rStr);
+    if (nStrId < 0)
+        // string not found.
+        return nStrId;
+
+    sal_Int32 n = maHeader.size();
+    for (sal_Int32 i = 0; i < n; ++i)
+    {
+        if (maHeader[i] == nStrId)
+            return i;
+    }
+
+    return -1;
+}
+
+const TypedStrCollection& ScDPCacheTable::getFieldEntries(sal_Int32 nIndex) const
+{
+    if (nIndex < 0 || nIndex >= maFieldEntries.size())
+    {
+        fprintf(stdout, "ScDPCacheTable::getFieldEntries: OUT OF BOUND\n");fflush(stdout);
+        // index out of bound.  Hopefully this code will never be reached.
+        static const TypedStrCollection emptyCollection;
+        return emptyCollection;
+    }
+
+    return *maFieldEntries[nIndex].get();
+}
+
+void ScDPCacheTable::filterTable(const Sequence<DataPilotFieldFilter>& rFilters, 
+                                 Sequence< Sequence<Any> >& rTabData)
+{
+    sal_Int32 nRowSize = getRowSize();
+    sal_Int32 nColSize = getColSize();
+
+    if (!nRowSize)
+        // no data to filter.
+        return;
+
+    // Convert filters first.
+    vector<Filter> filters;
+    sal_Int32 nFilterSize = rFilters.getLength();
+    filters.reserve(nFilterSize);
+    for (sal_Int32 i = 0; i < nFilterSize; ++i)
+    {
+        Filter fil;
+        fil.mnFieldIndex = getFieldIndex(String(rFilters[i].FieldName));
+        fil.mnMatchStrId = getStringId(String(rFilters[i].MatchValue));
+        if (fil.mnFieldIndex >= 0)
+            filters.push_back(fil);
+    }
+    
+    // Row first, then column.
+    vector< Sequence<Any> > tableData;
+    tableData.reserve(nRowSize+1);
+
+    // Header first.
+    Sequence<Any> headerRow(nColSize);
+    for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+    {
+        OUString str;
+        const String* pStr = getString(maHeader[nCol]);
+        if (pStr)
+            str = *pStr;
+
+        Any any;
+        any <<= str;
+        headerRow[nCol] = any;
+    }
+    tableData.push_back(headerRow);
+
+    // Data rows.
+    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+    {
+        if (!maRowsVisible[nRow])
+            // This row is filtered out.
+            continue;
+
+        bool bRetainRow = true;
+        vector<Filter>::const_iterator itr, itrEnd = filters.end();
+        for (itr = filters.begin(); itr != itrEnd; ++itr)
+        {
+            if (itr->mnFieldIndex >= nColSize)
+            {
+                // specified field is outside the source data columns.
+                bRetainRow = false;
+                break;
+            }
+
+            if ( maTable[nRow][itr->mnFieldIndex].mnStrId != itr->mnMatchStrId )
+            {
+                // The string value does not match.
+                bRetainRow = false;
+                break;
+            }
+        }
+
+        if (bRetainRow)
+        {
+            Sequence<Any> row(nColSize);
+            for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+            {
+                Any any;
+                const Cell& rCell = maTable[nRow][nCol];
+                if (rCell.mbNumeric)
+                    any <<= rCell.mfValue;
+                else
+                {
+                    OUString str;
+                    const String* pStr = getString(rCell.mnStrId);
+                    if (pStr)
+                        str = *pStr;
+                    any <<= str;
+                }
+                row[nCol] = any;
+            }
+            tableData.push_back(row);
+        }
+    }
+
+    // convert vector to Seqeunce
+    sal_Int32 nTabSize = static_cast<sal_Int32>(tableData.size());
+    rTabData.realloc(nTabSize);
+    for (sal_Int32 i = 0; i < nTabSize; ++i)
+        rTabData[i] = tableData[i];
+}
+
+void ScDPCacheTable::clear()
+{
+    maTable.clear();
+    maHeader.clear();
+    maFieldEntries.clear();
+    maRowsVisible.clear();
+}
+
+void ScDPCacheTable::swap(ScDPCacheTable& rOther)
+{
+    maTable.swap(rOther.maTable);
+    maHeader.swap(rOther.maHeader);
+    maFieldEntries.swap(rOther.maFieldEntries);
+    maRowsVisible.swap(rOther.maRowsVisible);
+}
+
+bool ScDPCacheTable::empty() const
+{
+    return maTable.empty();
+}
+
+void ScDPCacheTable::getValueData(ScDocument* pDoc, const ScAddress& rPos, Cell& rCell)
+{
+    ScBaseCell* pCell = pDoc->GetCell(rPos);
+    if (!pCell)
+    {
+        rCell.mnType = SC_VALTYPE_EMPTY;
+        return;
+    }
+
+    CellType eType = pCell->GetCellType();
+    if (eType == CELLTYPE_NOTE)
+    {
+        // note cell
+        rCell.mnType = SC_VALTYPE_EMPTY;
+        return;
+    }
+
+    if (eType == CELLTYPE_FORMULA && static_cast<ScFormulaCell*>(pCell)->GetErrCode())
+    {
+        // formula cell with error
+        rCell.mnType = SC_VALTYPE_ERROR;
+        return;
+    }
+
+    if ( pCell->HasValueData() )
+    {
+        if (eType == CELLTYPE_VALUE)
+            // value cell
+            rCell.mfValue = static_cast<ScValueCell*>(pCell)->GetValue();
+        else if (eType == CELLTYPE_FORMULA)
+            // formula cell
+            rCell.mfValue = static_cast<ScFormulaCell*>(pCell)->GetValue();
+
+        rCell.mbNumeric = true;
+        rCell.mnType = SC_VALTYPE_VALUE;
+    }
+}
+
+ScDPCacheTable::Cell ScDPCacheTable::getSelectedDimension(ScDPDimension* pDim) const
+{
+    const ScDPItemData& rData = pDim->GetSelectedData();
+    Cell aCell;
+    aCell.mfValue = rData.fValue;
+    aCell.mbNumeric = rData.bHasValue;
+    aCell.mnStrId = getStringId(rData.aString);
+    return aCell;
+}
+
+// static 
+sal_Int32 ScDPCacheTable::insertString(const String& aStr)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.insertString(aStr);
+}
+
+const String* ScDPCacheTable::getString(sal_Int32 nId)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.getString(nId);
+}
+
+sal_Int32 ScDPCacheTable::getStringId(const String& aStr)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.getStringId(aStr);
+}
? offapi/offapi.vpj
? offapi/com/sun/star/sheet/DataPilotFieldFilter.idl
? offapi/com/sun/star/sheet/XDrillDownDataSupplier.idl
Index: offapi/com/sun/star/sheet/makefile.mk
===================================================================
RCS file: /cvs/api/offapi/com/sun/star/sheet/makefile.mk,v
retrieving revision 1.24
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.24 makefile.mk
--- offapi/com/sun/star/sheet/makefile.mk	22 May 2007 15:11:32 -0000	1.24
+++ offapi/com/sun/star/sheet/makefile.mk	25 Oct 2007 18:11:35 -0000
@@ -59,6 +59,8 @@
 	CellAreaLinksEnumeration.idl\
 	DatabaseRangesEnumeration.idl\
 	DataPilotFieldsEnumeration.idl\
+	DataPilotFieldFilter.idl\
+	XDrillDownDataSupplier.idl\
 	DataPilotItem.idl\
 	DataPilotItems.idl\
 	DataPilotItemsEnumeration.idl\
--- /dev/null	2007-05-04 06:54:36.000000000 -0400
+++ offapi/com/sun/star/sheet/DataPilotFieldFilter.idl	2007-10-08 20:19:06.000000000 -0400
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: DataPilotItem.idl,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 04:33:20 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_sheet_DataPilotFieldFilter_idl__
+#define __com_sun_star_sheet_DataPilotFieldFilter_idl__
+
+//=============================================================================
+
+module com {  module sun {  module star {  module sheet {
+
+//=============================================================================
+
+struct DataPilotFieldFilter
+{
+    /** Field name. */
+    string FieldName;
+
+    /** String value that needs to match against. */
+    string MatchValue;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
+
--- /dev/null	2007-05-04 06:54:36.000000000 -0400
+++ offapi/com/sun/star/sheet/XDrillDownDataSupplier.idl	2007-10-22 14:01:54.000000000 -0400
@@ -0,0 +1,64 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: DataPilotItem.idl,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 04:33:20 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_sheet_XDrillDownDataSupplier_idl__
+#define __com_sun_star_sheet_XDrillDownDataSupplier_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __com_sun_star_sheet_DataPilotFieldFilter_idl__
+#include <com/sun/star/sheet/DataPilotFieldFilter.idl>
+#endif
+
+//=============================================================================
+
+module com {  module sun {  module star {  module sheet {
+
+//=============================================================================
+
+interface XDrillDownDataSupplier: com::sun::star::uno::XInterface
+{
+    void getDrillDownData( [in] sequence< com::sun::star::sheet::DataPilotFieldFilter > aFilters, 
+                           [out] sequence< sequence< any > > rData );
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
+
