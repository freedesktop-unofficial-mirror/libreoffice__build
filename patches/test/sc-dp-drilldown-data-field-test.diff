
? sc/output.log
? sc/sc.vpj
? sc/inc/dpcachetable.hxx
? sc/source/core/data/dpcachetable.cxx
Index: sc/inc/dpobject.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpobject.hxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dpobject.hxx
--- sc/inc/dpobject.hxx	27 Jun 2007 13:41:57 -0000	1.12
+++ sc/inc/dpobject.hxx	12 Oct 2007 01:27:39 -0000
@@ -78,7 +78,7 @@
 class StrCollection;
 class TypedStrCollection;
 struct PivotField;
-
+class ScDPCacheTable;
 
 struct ScDPServiceDesc
 {
@@ -223,6 +223,9 @@
 	BOOL				RefsEqual( const ScDPObject& r ) const;
 	void				WriteRefsTo( ScDPObject& r ) const;
 
+    void                GetDrillDownData(const ScAddress& rPos, 
+                                         ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTableData);
+
 	// apply drop-down attribute, initialize nHeaderRows, without accessing the source
 	// (button attribute must be present)
 	void				RefreshAfterLoad();
Index: sc/inc/dpoutput.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpoutput.hxx,v
retrieving revision 1.8
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.8 dpoutput.hxx
--- sc/inc/dpoutput.hxx	27 Jun 2007 13:42:13 -0000	1.8
+++ sc/inc/dpoutput.hxx	12 Oct 2007 01:27:39 -0000
@@ -60,8 +60,13 @@
 #include "address.hxx"
 #endif
 
+#include "dpcachetable.hxx"
 #include <vector>
 
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+}}}}
+
 class Rectangle;
 class SvStream;
 class ScDocument;
@@ -166,6 +171,11 @@
 	BOOL			HasError();			// range overflow or exception from source
 
 	void			GetPositionData( ScDPPositionData& rData, const ScAddress& rPos );
+
+    /** Get filtering criteria based on the position of the cell within data
+        field region. */
+    bool            GetDataFieldPositionData(::std::vector< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters, const ScAddress& rPos);
+
     BOOL            GetPivotData( ScDPGetPivotDataField& rTarget, /* returns result */
                                   const std::vector< ScDPGetPivotDataField >& rFilters );
 	long			GetHeaderDim( const ScAddress& rPos, USHORT& rOrient );
Index: sc/inc/dpsdbtab.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpsdbtab.hxx,v
retrieving revision 1.3
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.3 dpsdbtab.hxx
--- sc/inc/dpsdbtab.hxx	8 Sep 2005 17:35:48 -0000	1.3
+++ sc/inc/dpsdbtab.hxx	12 Oct 2007 01:27:39 -0000
@@ -50,6 +50,11 @@
 #include "dptabdat.hxx"
 #endif
 
+#include <vector>
+#include <set>
+
+class ScDPCacheTable;
+
 // --------------------------------------------------------------------
 //
 //	implementation of ScDPTableData with database data
@@ -94,6 +99,12 @@
 	virtual void					DisposeData();
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
 
+    virtual void                    CreateCacheTable();
+    virtual void                    FilterCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters,
+                                                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+    virtual sal_Int32               GetFieldIndex(const String& rStr);
+
 	virtual void					ResetIterator();
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam );
 };
Index: sc/inc/dpshttab.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpshttab.hxx,v
retrieving revision 1.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.4 dpshttab.hxx
--- sc/inc/dpshttab.hxx	8 Sep 2005 17:36:03 -0000	1.4
+++ sc/inc/dpshttab.hxx	12 Oct 2007 01:27:39 -0000
@@ -48,6 +48,13 @@
 #include "address.hxx"
 #endif
 
+#include <vector>
+
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+}}}}
+
+class ScDPDimension;
 
 // --------------------------------------------------------------------
 //
@@ -70,7 +77,6 @@
 {
 private:
 	ScSheetDPData_Impl* pImpl;
-    BOOL* pSpecial;
 
 public:
 					ScSheetDPData( ScDocument* pD, const ScSheetSourceDesc& rDesc );
@@ -85,6 +91,12 @@
 	virtual void					DisposeData();
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
 
+    virtual void                    CreateCacheTable();
+    virtual void                    FilterCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters,
+                                                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rData);
+    virtual sal_Int32               GetFieldIndex(const String& rStr);
+
 	virtual void					ResetIterator();
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam );
 };
Index: sc/inc/dptabdat.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dptabdat.hxx,v
retrieving revision 1.6
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.6 dptabdat.hxx
--- sc/inc/dptabdat.hxx	25 Jan 2007 11:03:15 -0000	1.6
+++ sc/inc/dptabdat.hxx	12 Oct 2007 01:27:39 -0000
@@ -40,11 +40,21 @@
 #include "address.hxx"
 #endif
 
+#include "dpoutput.hxx"
+
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
 
+#include <vector>
+#include <set>
+
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+}}}}
+
 class TypedStrCollection;
+class ScDPDimension;
 
 // -----------------------------------------------------------------------
 
@@ -110,16 +120,16 @@
 {
 	//	all pointers are just copied
 
-	SCSIZE			nColCount;
+	SCSIZE			nColCount;      // # column fields
 	const long*		pCols;
 	ScDPItemData*	pColData;
-	SCSIZE			nRowCount;
+	SCSIZE			nRowCount;      // # row fields
 	const long*		pRows;
 	ScDPItemData*	pRowData;
-	SCSIZE			nPageCount;
+	SCSIZE			nPageCount;     // # page fields
 	const long*		pPages;
 	ScDPItemData*	pPageData;
-	SCSIZE			nDatCount;
+	SCSIZE			nDatCount;      // # data fields
 	const long*		pDats;
 	ScDPValueData*	pValues;
 
@@ -155,6 +165,12 @@
 	virtual void					DisposeData() = 0;
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty ) = 0;
 
+    virtual void                    CreateCacheTable();
+    virtual void                    FilterCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& aFilters,
+                                                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+    virtual sal_Int32               GetFieldIndex(const String& rStr);
+
 	virtual void					ResetIterator() = 0;
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam ) = 0;
 
Index: sc/inc/dptabsrc.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dptabsrc.hxx,v
retrieving revision 1.8
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.8 dptabsrc.hxx
--- sc/inc/dptabsrc.hxx	25 Jan 2007 11:03:43 -0000	1.8
+++ sc/inc/dptabsrc.hxx	12 Oct 2007 01:27:39 -0000
@@ -120,6 +120,10 @@
 #include "dptabdat.hxx"
 #endif
 
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+}}}}
+
 class ScDPResultMember;
 class ScDPResultData;
 struct ScDPItemData;
@@ -242,6 +246,9 @@
 									::com::sun::star::util::XRefreshListener >& l )
 								throw(::com::sun::star::uno::RuntimeException);
 
+    void getDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& aFilters,
+                          ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+
 							// XPropertySet
 	virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo >
 							SAL_CALL getPropertySetInfo(  )
@@ -358,7 +365,7 @@
 {
 private:
 	ScDPSource*			pSource;
-	long				nDim;
+	long				nDim;               // dimension index (== column ID)
 	ScDPHierarchies*	pHierarchies;
 	long				nUsedHier;
 	USHORT				nFunction;			// enum GeneralFunction
Index: sc/source/core/data/dpgroup.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpgroup.cxx,v
retrieving revision 1.7
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.7 dpgroup.cxx
--- sc/source/core/data/dpgroup.cxx	27 Feb 2007 12:03:31 -0000	1.7
+++ sc/source/core/data/dpgroup.cxx	12 Oct 2007 01:27:39 -0000
@@ -51,6 +51,7 @@
 #include "collect.hxx"
 #include "global.hxx"
 #include "document.hxx"
+#include "dpcachetable.hxx"
 
 #ifndef _COM_SUN_STAR_SHEET_DATAPILOTFIELDGROUPBY_HPP_
 #include <com/sun/star/sheet/DataPilotFieldGroupBy.hpp>
Index: sc/source/core/data/dpobject.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpobject.cxx,v
retrieving revision 1.21
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 dpobject.cxx
--- sc/source/core/data/dpobject.cxx	27 Jun 2007 13:43:19 -0000	1.21
+++ sc/source/core/data/dpobject.cxx	12 Oct 2007 01:27:40 -0000
@@ -62,6 +62,7 @@
 #include "unonames.hxx"
 
 #include <com/sun/star/sheet/GeneralFunction.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 #include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
 #include <com/sun/star/sheet/DataPilotFieldReferenceType.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
@@ -73,7 +74,12 @@
 #include <tools/debug.hxx>
 #include <svtools/zforlist.hxx>		// IsNumberFormat
 
+#include <vector>
+
 using namespace com::sun::star;
+using ::std::vector;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
 
 // -----------------------------------------------------------------------
 
@@ -601,6 +607,24 @@
 		r.SetSheetDesc( *pSheetDesc );
 }
 
+void ScDPObject::GetDrillDownData(const ScAddress& rPos, Sequence< Sequence<Any> >& rTableData)
+{
+    CreateOutput();
+
+    vector<sheet::DataPilotFieldFilter> aFilters;
+    if ( !pOutput->GetDataFieldPositionData(aFilters, rPos) )
+        return;
+
+    sal_Int32 n = static_cast<sal_Int32>(aFilters.size());
+    ::com::sun::star::uno::Sequence<sheet::DataPilotFieldFilter> aFilters2(n);
+    for (sal_Int32 i = 0; i < n; ++i)
+        aFilters2[i] = aFilters[i];
+
+    // TODO: We need to change the UNO API.
+    ScDPSource* pSource = static_cast<ScDPSource*>(xSource.get());
+    pSource->getDrillDownData(aFilters2, rTableData);
+}
+
 BOOL ScDPObject::IsDimNameInUse( const String& rName ) const
 {
 	if ( xSource.is() )
Index: sc/source/core/data/dpoutput.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpoutput.cxx,v
retrieving revision 1.15
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.15 dpoutput.cxx
--- sc/source/core/data/dpoutput.cxx	27 Jun 2007 13:43:33 -0000	1.15
+++ sc/source/core/data/dpoutput.cxx	12 Oct 2007 01:27:40 -0000
@@ -48,6 +48,8 @@
 #include <unotools/transliterationwrapper.hxx>
 
 #include "dpoutput.hxx"
+#include "dptabsrc.hxx"
+#include "dpcachetable.hxx"
 #include "document.hxx"
 #include "patattr.hxx"
 #include "docpool.hxx"
@@ -68,12 +70,17 @@
 #include <com/sun/star/sheet/XDataPilotMemberResults.hpp>
 #include <com/sun/star/sheet/DataResultFlags.hpp>
 #include <com/sun/star/sheet/MemberResultFlags.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 #include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
 #include <com/sun/star/sheet/TableFilterField.hpp>
 #include <com/sun/star/sheet/GeneralFunction.hpp>
 #include <com/sun/star/container/XNamed.hpp>
 
+#include <vector>
+
 using namespace com::sun::star;
+using ::std::vector;
+using ::com::sun::star::uno::Sequence;
 
 // -----------------------------------------------------------------------
 
@@ -995,6 +1002,70 @@
 	}
 }
 
+bool ScDPOutput::GetDataFieldPositionData(vector<sheet::DataPilotFieldFilter>& rFilters, const ScAddress& rPos)
+{
+    SCCOL nCol = rPos.Col();
+    SCROW nRow = rPos.Row();
+    SCTAB nTab = rPos.Tab();
+    if ( nTab != aStartPos.Tab() )
+        return false;                                     // wrong sheet
+
+    CalcSizes();
+
+    // test for data area.
+    if (nCol < nDataStartCol || nCol > nTabEndCol || nRow < nDataStartRow || nRow > nTabEndRow)
+    {
+        // Cell is outside the data field area.
+        return false;
+    }
+
+    // column fields
+    for (SCCOL nColField = 0; nColField < nColFieldCount; ++nColField)
+    {
+        sheet::DataPilotFieldFilter filter;
+        filter.FieldName = pColFields[nColField].aCaption;
+
+        const uno::Sequence<sheet::MemberResult> rSequence = pColFields[nColField].aResult;
+        long nThisColCount = rSequence.getLength();
+        const sheet::MemberResult* pArray = rSequence.getConstArray();
+
+        DBG_ASSERT(nDataStartCol + nThisColCount - 1 == nTabEndCol, "ScDPOutput::GetDataFieldCellData: error in geometric assumption");
+
+        long nItem = nCol - nDataStartCol;
+                //	get origin of "continue" fields
+        while ( nItem > 0 && (pArray[nItem].Flags & sheet::MemberResultFlags::CONTINUE) )
+            --nItem;
+
+        filter.MatchValue = pArray[nItem].Name;
+        if (pArray[nItem].Name.getLength() > 0 && !pArray[nItem].Name.equalsAscii("Total"))
+            rFilters.push_back(filter);
+    }
+
+    // row fields
+    for (SCROW nRowField = 0; nRowField < nRowFieldCount; ++nRowField)
+    {
+        sheet::DataPilotFieldFilter filter;
+        filter.FieldName = pRowFields[nRowField].aCaption;
+
+        const uno::Sequence<sheet::MemberResult> rSequence = pRowFields[nRowField].aResult;
+        long nThisRowCount = rSequence.getLength();
+        const sheet::MemberResult* pArray = rSequence.getConstArray();
+
+        DBG_ASSERT(nDataStartRow + nThisRowCount - 1 == nTabEndRow, "ScDPOutput::GetDataFieldCellData: error in geometric assumption");
+
+        long nItem = nRow - nDataStartRow;
+			//	get origin of "continue" fields
+        while ( nItem > 0 && (pArray[nItem].Flags & sheet::MemberResultFlags::CONTINUE) )
+            --nItem;
+
+        filter.MatchValue = pArray[nItem].Name;
+        if (pArray[nItem].Name.getLength() > 0 && !pArray[nItem].Name.equalsAscii("Total"))
+            rFilters.push_back(filter);
+    }
+
+    return true;
+}
+
 //
 //  helper functions for ScDPOutput::GetPivotData
 //
Index: sc/source/core/data/dpsdbtab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpsdbtab.cxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dpsdbtab.cxx
--- sc/source/core/data/dpsdbtab.cxx	27 Feb 2007 12:04:37 -0000	1.12
+++ sc/source/core/data/dpsdbtab.cxx	12 Oct 2007 01:27:40 -0000
@@ -55,14 +55,23 @@
 #include <com/sun/star/sdbc/XRowSet.hpp>
 #include <com/sun/star/sdbc/XResultSetMetaDataSupplier.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 
 #include "dpsdbtab.hxx"
 #include "collect.hxx"
 #include "global.hxx"
 #include "globstr.hrc"
+#include "dpcachetable.hxx"
 
 using namespace com::sun::star;
 
+using ::std::vector;
+using ::std::set;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::UNO_QUERY;
+
 #define SC_SERVICE_ROWSET			"com.sun.star.sdb.RowSet"
 #define SC_SERVICE_INTHANDLER		"com.sun.star.sdb.InteractionHandler"
 
@@ -87,6 +96,8 @@
 	sal_Int32*			pTypes;
 	SvNumberFormatter*	pFormatter;
 
+    ScDPCacheTable      aCacheTable;
+
 	ScDatabaseDPData_Impl() {}
 };
 
@@ -418,53 +429,8 @@
 
 const TypedStrCollection& ScDatabaseDPData::GetColumnEntries(long nColumn)
 {
-	DBG_ASSERT( pImpl->ppStrings && nColumn < pImpl->nColCount, "GetColumnEntries: no entries" );
-	if (!pImpl->ppStrings[nColumn])
-	{
-		TypedStrCollection* pColl = new TypedStrCollection;
-
-		//!	select distinct values directly from database
-
-//		Sound::Beep();		//! Test !!!
-
-		uno::Reference<sdbc::XRowSet> xRowSet = pImpl->xRowSet;
-		uno::Reference<sdbc::XRow> xRow( xRowSet, uno::UNO_QUERY );
-		if ( xRow.is() )
-		{
-			ScDPItemData aItemData;
-
-			try
-			{
-				if ( !pImpl->bAtStart )
-					lcl_Reset( xRowSet );
-
-				pImpl->bAtStart = FALSE;
-				while ( xRowSet->next() )
-				{
-					//!	get string for value data only if value hasn't been inserted yet
-					lcl_FillItemData( aItemData, xRow, nColumn+1, pImpl->pTypes[nColumn], TRUE, pImpl );
-					TypedStrData* pNew = new TypedStrData(
-							aItemData.aString, aItemData.fValue,
-							aItemData.bHasValue ? SC_STRTYPE_VALUE : SC_STRTYPE_STANDARD );
-					if (!pColl->Insert(pNew))
-						delete pNew;
-				}
-			}
-			catch ( sdbc::SQLException& rError )
-			{
-				//!	store error message
-				InfoBox aInfoBox( 0, String(rError.Message) );
-				aInfoBox.Execute();
-			}
-			catch ( uno::Exception& )
-			{
-				DBG_ERROR("Unexpected exception in database");
-			}
-		}
-
-		pImpl->ppStrings[nColumn] = pColl;
-	}
-	return *pImpl->ppStrings[nColumn];
+    CreateCacheTable();
+    return pImpl->aCacheTable.getFieldEntries(nColumn);
 }
 
 String ScDatabaseDPData::getDimensionName(long nColumn)
@@ -500,6 +466,33 @@
 	//!	disable flags
 }
 
+void ScDatabaseDPData::CreateCacheTable()
+{
+    if (!pImpl->aCacheTable.empty())
+        return;
+
+    // Get null date.
+    if (!pImpl->pFormatter)
+        pImpl->pFormatter = new SvNumberFormatter(pImpl->xServiceManager, ScGlobal::eLnge);
+
+    pImpl->aCacheTable.fillTable(pImpl->xRowSet, *pImpl->pFormatter->GetNullDate());
+}
+
+void ScDatabaseDPData::FilterCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+    pImpl->aCacheTable.filterByPageDimension(rPageDims);
+}
+
+void ScDatabaseDPData::GetDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& rFilters, Sequence< Sequence<Any> >& rTabData)
+{
+    pImpl->aCacheTable.filterTable(rFilters, rTabData);
+}
+
+sal_Int32 ScDatabaseDPData::GetFieldIndex(const String& rStr)
+{
+    return pImpl->aCacheTable.getFieldIndex(rStr);
+}
+
 void ScDatabaseDPData::ResetIterator()
 {
 	try
Index: sc/source/core/data/dpshttab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpshttab.cxx,v
retrieving revision 1.9
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.9 dpshttab.cxx
--- sc/source/core/data/dpshttab.cxx	27 Feb 2007 12:04:49 -0000	1.9
+++ sc/source/core/data/dpshttab.cxx	12 Oct 2007 01:27:40 -0000
@@ -47,8 +47,20 @@
 #include "document.hxx"
 #include "collect.hxx"
 #include "cell.hxx"
+#include "dpcachetable.hxx"
 #include "globstr.hrc"
 
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+
+#include <vector>
+#include <set>
+
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::Sequence;
+using ::std::vector;
+using ::std::set;
+
 // -----------------------------------------------------------------------
 
 class ScSheetDPData_Impl
@@ -57,49 +69,47 @@
 	ScDocument*		pDoc;
 	ScRange			aRange;
 	ScQueryParam	aQuery;
-	long			nColCount;
+    BOOL*           pSpecial;           // to flag special handling of query parameters in ValidQuery.
 	BOOL			bIgnoreEmptyRows;
 	BOOL			bRepeatIfEmpty;
-	TypedStrCollection**	ppStrings;
 	BOOL*			pDateDim;
 	SCROW			nNextRow;		// for iterator, within range
 
-	ScSheetDPData_Impl() {}
+    ScDPCacheTable  aCacheTable;
+
+	ScSheetDPData_Impl() :
+        pSpecial(NULL)
+    {
+    }
 };
 
 // -----------------------------------------------------------------------
 
 ScSheetDPData::ScSheetDPData( ScDocument* pD, const ScSheetSourceDesc& rDesc )
-    : pSpecial(NULL)
 {
-	long nCount = rDesc.aSourceRange.aEnd.Col() - rDesc.aSourceRange.aStart.Col() + 1;
 	pImpl = new ScSheetDPData_Impl;
 	pImpl->pDoc = pD;
 	pImpl->aRange = rDesc.aSourceRange;
 	pImpl->aQuery = rDesc.aQueryParam;
 	pImpl->bIgnoreEmptyRows = FALSE;
 	pImpl->bRepeatIfEmpty = FALSE;
-	pImpl->nColCount = nCount;
-	pImpl->ppStrings = new TypedStrCollection*[nCount];
 	pImpl->pDateDim = NULL;
-	for (long i=0; i<nCount; i++)
-		pImpl->ppStrings[i] = NULL;
 
 	pImpl->nNextRow = pImpl->aRange.aStart.Row() + 1;
 
     SCSIZE nEntryCount(pImpl->aQuery.GetEntryCount());
-    pSpecial = new BOOL[nEntryCount];
+    pImpl->pSpecial = new BOOL[nEntryCount];
     for (SCSIZE j = 0; j < nEntryCount; ++j )
     {
         ScQueryEntry& rEntry = pImpl->aQuery.GetEntry(j);
         if (rEntry.bDoQuery)
         {
-            pSpecial[j] = false;
+            pImpl->pSpecial[j] = false;
             if (!rEntry.bQueryByString)
             {
                 if (*rEntry.pStr == EMPTY_STRING &&
                    ((rEntry.nVal == SC_EMPTYFIELDS) || (rEntry.nVal == SC_NONEMPTYFIELDS)))
-                    pSpecial[j] = true;
+                    pImpl->pSpecial[j] = true;
             }
             else
             {
@@ -110,30 +120,23 @@
             }
     	}
     }
+    CreateCacheTable();
 }
 
 ScSheetDPData::~ScSheetDPData()
 {
-	for (long i=0; i<pImpl->nColCount; i++)
-		delete pImpl->ppStrings[i];
-	delete[] pImpl->ppStrings;
 	delete[] pImpl->pDateDim;
+    delete[] pImpl->pSpecial;
 	delete pImpl;
-    delete[] pSpecial;
 }
 
 void ScSheetDPData::DisposeData()
 {
-	for (long i=0; i<pImpl->nColCount; i++)
-	{
-		delete pImpl->ppStrings[i];
-		pImpl->ppStrings[i] = NULL;
-	}
 }
 
 long ScSheetDPData::GetColumnCount()
 {
-	return pImpl->nColCount;
+    return pImpl->aCacheTable.getColSize();
 }
 
 BOOL lcl_HasQuery( const ScQueryParam& rParam )
@@ -144,58 +147,9 @@
 
 const TypedStrCollection& ScSheetDPData::GetColumnEntries(long nColumn)
 {
-	DBG_ASSERT(nColumn>=0 && nColumn<pImpl->nColCount, "ScSheetDPData: wrong column");
-
-	if (!pImpl->ppStrings[nColumn])
-	{
-		TypedStrCollection* pColl = new TypedStrCollection;
-
-		//!	document must have function to fill collection!!!
-		String aDocStr;
-		SCCOL nDocCol = (SCCOL)(pImpl->aRange.aStart.Col() + nColumn);
-		SCTAB nDocTab = pImpl->aRange.aStart.Tab();
-		SCROW nStartRow = pImpl->aRange.aStart.Row()+1;	// start of data
-		SCROW nEndRow = pImpl->aRange.aEnd.Row();
-		SCCOL nStartCol = pImpl->aRange.aStart.Col();
-		SCCOL nEndCol = pImpl->aRange.aEnd.Col();
-		for (SCROW nRow = nStartRow; nRow <= nEndRow; nRow++)
-		{
-			if ( pImpl->bIgnoreEmptyRows &&
-					pImpl->pDoc->IsBlockEmpty( nDocTab, nStartCol, nRow, nEndCol, nRow ) )
-			{
-				//	ignore this (empty) row
-				//!	count and skip empty rows?
-			}
-			else if ( pImpl->bRepeatIfEmpty && nRow > nStartRow &&
-						!pImpl->pDoc->HasData( nDocCol, nRow, nDocTab ) )
-			{
-				//	ignore empty member (if it's not the first row)
-			}
-			else if ( lcl_HasQuery(pImpl->aQuery) &&
-						!pImpl->pDoc->ValidQuery( nRow, nDocTab, pImpl->aQuery, pSpecial ) )
-			{
-				//	this row is filtered out
-			}
-			else
-			{
-				TypedStrData* pNew;
-				pImpl->pDoc->GetString( nDocCol, nRow, nDocTab, aDocStr );
-				if ( pImpl->pDoc->HasValueData( nDocCol, nRow, nDocTab ) )
-				{
-					double fVal = pImpl->pDoc->GetValue(ScAddress(nDocCol, nRow, nDocTab));
-					pNew = new TypedStrData( aDocStr, fVal, SC_STRTYPE_VALUE );
-				}
-				else
-					pNew = new TypedStrData( aDocStr );
-
-				if (!pColl->Insert(pNew))
-					delete pNew;
-			}
-		}
-
-		pImpl->ppStrings[nColumn] = pColl;
-	}
-	return *pImpl->ppStrings[nColumn];
+    DBG_ASSERT(nColumn>=0 && nColumn < pImpl->aCacheTable.getColSize(), "ScSheetDPData: wrong column");
+    CreateCacheTable();
+    return pImpl->aCacheTable.getFieldEntries(nColumn);
 }
 
 String ScSheetDPData::getDimensionName(long nColumn)
@@ -206,7 +160,7 @@
 		//return "Data";
 		return ScGlobal::GetRscString(STR_PIVOT_DATA);
 	}
-	else if ( nColumn >= pImpl->nColCount )
+    else if (nColumn >= pImpl->aCacheTable.getColSize())
 	{
 		DBG_ERROR("getDimensionName: invalid dimension");
 		return String();
@@ -235,11 +189,12 @@
 
 BOOL ScSheetDPData::IsDateDimension(long nDim)
 {
+    long nColCount = pImpl->aCacheTable.getColSize();
 	if (getIsDataLayoutDimension(nDim))
 	{
 		return FALSE;
 	}
-	else if ( nDim >= pImpl->nColCount )
+    else if (nDim >= nColCount)
 	{
 		DBG_ERROR("IsDateDimension: invalid dimension");
 		return FALSE;
@@ -248,9 +203,9 @@
 	{
 		if (!pImpl->pDateDim)
 		{
-			pImpl->pDateDim = new BOOL[pImpl->nColCount];
+            pImpl->pDateDim = new BOOL[nColCount];
 			ScRange aTestRange = pImpl->aRange;
-			for (long i=0; i<pImpl->nColCount; i++)
+			for (long i = 0; i < nColCount; ++i)
 			{
 				SCCOL nCol = (SCCOL)( pImpl->aRange.aStart.Col() + i );
 				aTestRange.aStart.SetCol(nCol);
@@ -268,7 +223,7 @@
 	{
 		return 0;
 	}
-	else if ( nDim >= pImpl->nColCount )
+    else if (nDim >= pImpl->aCacheTable.getColSize())
 	{
 		DBG_ERROR("GetNumberFormat: invalid dimension");
 		return 0;
@@ -286,7 +241,7 @@
 
 BOOL ScSheetDPData::getIsDataLayoutDimension(long nColumn)
 {
-	return ( nColumn == pImpl->nColCount );
+    return (nColumn == pImpl->aCacheTable.getColSize());
 }
 
 void ScSheetDPData::SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty )
@@ -295,8 +250,38 @@
 	pImpl->bRepeatIfEmpty   = bRepeatIfEmpty;
 }
 
+void ScSheetDPData::CreateCacheTable()
+{
+    // Scan and store the data from the source range.
+    if (!pImpl->aCacheTable.empty())
+        // already cached.
+        return;
+
+    pImpl->aCacheTable.fillTable(pImpl->pDoc, pImpl->aRange, pImpl->aQuery, pImpl->pSpecial);
+}
+
+void ScSheetDPData::FilterCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+    pImpl->aCacheTable.filterByPageDimension(rPageDims);
+}
+
+void ScSheetDPData::GetDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& rFilters, Sequence< Sequence<Any> >& rData)
+{
+    sal_Int32 nRowSize = pImpl->aCacheTable.getRowSize();
+    if (!nRowSize)
+        return;
+
+    pImpl->aCacheTable.filterTable(rFilters, rData);
+}
+
+sal_Int32 ScSheetDPData::GetFieldIndex(const String& rStr)
+{
+    return pImpl->aCacheTable.getFieldIndex(rStr);
+}
+
 void ScSheetDPData::ResetIterator()
 {
+    // skipping the header row.
 	pImpl->nNextRow = pImpl->aRange.aStart.Row() + 1;
 }
 
@@ -348,7 +333,7 @@
 		}
 
 		bFilteredOut = ( lcl_HasQuery(pImpl->aQuery) && 
-				!pImpl->pDoc->ValidQuery( pImpl->nNextRow, nDocTab, pImpl->aQuery, pSpecial ) );
+				!pImpl->pDoc->ValidQuery( pImpl->nNextRow, nDocTab, pImpl->aQuery, pImpl->pSpecial ) );
 		if ( bFilteredOut )
 		{
 			++pImpl->nNextRow;
@@ -360,6 +345,7 @@
 
 	//!	use more efficient iterators
 
+    // Populate column field information.
 	for (i=0; i<rParam.nColCount; i++)
 	{
 		long nDim = rParam.pCols[i];
@@ -371,6 +357,7 @@
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
 	}
 
+    // Populate row field information.
 	for (i=0; i<rParam.nRowCount; i++)
 	{
 		long nDim = rParam.pRows[i];
@@ -382,6 +369,7 @@
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
 	}
 
+    // Populate page dimension information from the sheet.
 	for (i=0; i<rParam.nPageCount; i++)
 	{
 		long nDim = rParam.pPages[i];
@@ -393,6 +381,7 @@
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
 	}
 
+    // Populate data dimension information from the row.
 	for (i=0; i<rParam.nDatCount; i++)
 	{
 		long nDim = rParam.pDats[i];
Index: sc/source/core/data/dptabdat.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabdat.cxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 dptabdat.cxx
--- sc/source/core/data/dptabdat.cxx	27 Feb 2007 12:05:02 -0000	1.12
+++ sc/source/core/data/dptabdat.cxx	12 Oct 2007 01:27:40 -0000
@@ -50,9 +50,17 @@
 #include <unotools/collatorwrapper.hxx>
 #endif
 
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+
 #include "dptabdat.hxx"
 #include "global.hxx"
 
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
+using ::std::vector;
+using ::std::set;
+
 // -----------------------------------------------------------------------
 
 BOOL ScDPItemData::IsCaseInsEqual( const ScDPItemData& r ) const
@@ -193,6 +201,26 @@
 	return nRet;
 }
 
+void ScDPTableData::CreateCacheTable()
+{
+    fprintf(stdout, "ScDPTableData::CreateCacheTable: un-implemented...\n");fflush(stdout);
+}
+
+void ScDPTableData::FilterCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+    fprintf(stdout, "ScDPTableData::FilterCacheTable: un-implemented...\n");fflush(stdout);
+}
+
+void ScDPTableData::GetDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& aFilters, Sequence< Sequence<Any> >& rTabData)
+{
+    fprintf(stdout, "ScDPTableData::GetDrillDownData: un-implemented...\n");fflush(stdout);
+}
+
+sal_Int32 ScDPTableData::GetFieldIndex(const String& rStr)
+{
+    return -1;
+}
+
 UINT32 ScDPTableData::GetNumberFormat(long)
 {
 	return 0;			// default format
Index: sc/source/core/data/dptabsrc.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabsrc.cxx,v
retrieving revision 1.20
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.20 dptabsrc.cxx
--- sc/source/core/data/dptabsrc.cxx	27 Sep 2007 13:52:51 -0000	1.20
+++ sc/source/core/data/dptabsrc.cxx	12 Oct 2007 01:27:41 -0000
@@ -41,6 +41,8 @@
 // INCLUDE ---------------------------------------------------------------
 
 #include <algorithm>
+#include <vector>
+#include <set>
 
 #include <tools/debug.hxx>
 #include <rtl/math.hxx>
@@ -58,6 +60,7 @@
 
 #include <com/sun/star/beans/PropertyAttribute.hpp>
 #include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 #include <com/sun/star/sheet/DataPilotFieldReferenceType.hpp>
 #include <com/sun/star/sheet/DataPilotFieldSortMode.hpp>
 
@@ -72,6 +75,11 @@
 #endif
 
 using namespace com::sun::star;
+using ::std::vector;
+using ::std::set;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
 
 // -----------------------------------------------------------------------
 
@@ -409,6 +417,11 @@
 	DBG_ERROR("not implemented");	//! exception?
 }
 
+void ScDPSource::getDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& aFilters, Sequence< Sequence<Any> >& rTabData)
+{
+    pData->GetDrillDownData(aFilters, rTabData);
+}
+
 String ScDPSource::getDataDescription()
 {
 	CreateRes_Impl();		// create pResData
@@ -576,6 +589,7 @@
 {
 	if ( !pResData )
 	{
+        pData->CreateCacheTable();
 		USHORT nDataOrient = GetDataLayoutOrientation();
         if ( nDataDimCount > 1 && ( nDataOrient != sheet::DataPilotFieldOrientation_COLUMN &&
                                     nDataOrient != sheet::DataPilotFieldOrientation_ROW ) )
@@ -797,6 +811,16 @@
 						nPageDimCount,   nPageDims,      aPageData,
 						nDataDimCount,   nDataSrcCols,   aValues );
 
+            vector<ScDPDimension*> aPageDims;
+            aPageDims.reserve(nPageDimCount);
+            for (i = 0; i < nPageDimCount; ++i)
+            {
+                ScDPDimension* pDim = GetDimensionsObject()->getByIndex(nPageDims[i]);
+                if (pDim)
+                    aPageDims.push_back(pDim);
+            }
+            pData->FilterCacheTable(aPageDims);
+
 			pData->ResetIterator();
 			while ( pData->GetNextRow( aIterPar ) )
 			{
Index: sc/source/core/data/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/core/data/makefile.mk,v
retrieving revision 1.21
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 makefile.mk
--- sc/source/core/data/makefile.mk	27 Feb 2007 12:06:42 -0000	1.21
+++ sc/source/core/data/makefile.mk	12 Oct 2007 01:27:41 -0000
@@ -77,6 +77,7 @@
 	$(SLO)$/documen8.obj \
 	$(SLO)$/documen9.obj \
 	$(SLO)$/document.obj \
+        $(SLO)$/dpcachetable.obj \
         $(SLO)$/dpdimsave.obj \
         $(SLO)$/dpgroup.obj \
 	$(SLO)$/dpobject.obj \
@@ -131,6 +132,7 @@
 	$(SLO)$/documen5.obj \
 	$(SLO)$/documen6.obj \
 	$(SLO)$/documen9.obj \
+        $(SLO)$/dpcachetable.obj \
 	$(SLO)$/dpsdbtab.obj \
 	$(SLO)$/dpobject.obj \
 	$(SLO)$/dpoutput.obj \
Index: sc/source/ui/view/gridwin.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/gridwin.cxx,v
retrieving revision 1.85
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.85 gridwin.cxx
--- sc/source/ui/view/gridwin.cxx	27 Sep 2007 13:56:11 -0000	1.85
+++ sc/source/ui/view/gridwin.cxx	12 Oct 2007 01:27:42 -0000
@@ -159,6 +159,8 @@
 #endif
 
 using namespace com::sun::star;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
 
 const BYTE SC_NESTEDBUTTON_NONE = 0;
 const BYTE SC_NESTEDBUTTON_DOWN = 1;
@@ -2032,7 +2034,38 @@
                 }
 			}
 			else
-				Sound::Beep();		// nothing to expand/collapse
+            {
+                // Check if the data area is double-clicked.
+                Sequence< Sequence<Any> > aArrayData;
+                pDPObj->GetDrillDownData(aCellPos, aArrayData);
+                sal_Int32 nRowSize = aArrayData.getLength();
+                if (nRowSize > 0)
+                {
+                    ScTabViewShell* pViewShell = pViewData->GetViewShell();
+                    String aNewTabName;
+                    pViewData->GetDocument()->CreateValidTabName(aNewTabName);
+                    SCTAB nNewTab = pViewData->GetTabNo();
+                    if ( pViewShell->InsertTable(aNewTabName, nNewTab, false) )
+                    {
+                        for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+                        {
+                            sal_Int32 nColSize = aArrayData[nRow].getLength();
+                            for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+                            {
+                                const Any& rAny = aArrayData[nRow][nCol];
+                                rtl::OUString aStr;
+                                double fVal;
+                                if (rAny >>= aStr)
+                                    pDoc->SetString(nCol, nRow, nNewTab, String(aStr));
+                                else if (rAny >>= fVal)
+                                    pDoc->SetValue(nCol, nRow, nNewTab, fVal);
+                            }
+                        }
+                    }
+                }
+                else
+                    ::Sound::Beep();
+            }
 
 			return;
 		}
--- /dev/null	2007-05-04 06:54:36.000000000 -0400
+++ sc/inc/dpcachetable.hxx	2007-10-11 15:31:45.000000000 -0400
@@ -0,0 +1,182 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: dpobject.hxx,v $
+ *
+ *  $Revision: 1.12 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 13:41:57 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_DPCACHETABLE_HXX
+#define SC_DPCACHETABLE_HXX
+
+#include "sal/types.h"
+#include "osl/mutex.hxx"
+#include "global.hxx"
+#include "collect.hxx"
+
+#include <vector>
+#include <set>
+#include <hash_map>
+#include <boost/shared_ptr.hpp>
+#include <com/sun/star/uno/Reference.hxx>
+
+namespace com { namespace sun { namespace star {
+    namespace sdbc {
+        class XRowSet;
+    }
+    namespace sheet {
+        struct DataPilotFieldFilter;
+    }
+}}}
+
+class Date;
+
+class ScDocument;
+class ScRange;
+class ScDPDimension;
+
+class ScSharedStringTable
+{
+public:
+    static const sal_Int32 EMPTY = 0;
+
+    sal_Int32 insertString(const String& aStr);
+    sal_Int32 getStringId(const String& aStr);
+    const String* getString(sal_Int32 nId) const;
+
+    ScSharedStringTable();
+    ~ScSharedStringTable();
+
+private:
+    typedef ::std::hash_map< String, sal_Int32, ScStringHashCode, ::std::equal_to< String > > SharedStrMap;
+
+    ::std::vector<String> maSharedStrings;
+    SharedStrMap maSharedStringIds;
+    sal_Int32 mnStrCount;
+};
+
+// ----------------------------------------------------------------------------
+
+class ScDPCacheTable
+{
+public:
+    /** individual cell within table. */
+    struct Cell
+    {
+        sal_Int32 mnStrId;
+        double  mfValue;
+        bool    mbNumeric;
+
+        Cell();
+    };
+
+    /** filtering criteria */
+    struct Filter
+    {
+        sal_Int32   mnFieldIndex;
+        sal_Int32   mnMatchStrId;
+
+        Filter();
+    };
+
+    ScDPCacheTable();
+    ~ScDPCacheTable();
+
+    sal_Int32 getHeaderSize() const;
+    sal_Int32 getRowSize() const;
+    sal_Int32 getColSize() const;
+
+    /** Fill the internal table from the cell range provided.  This function
+        assumes that the first row is the column header. */
+    void fillTable(ScDocument* pDoc, const ScRange& rRange, const ScQueryParam& rQuery, BOOL* pSpecial);
+
+    /** Fill the internal table from database connection object.  This function
+        assumes that the first row is the column header. */
+    void fillTable(const ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XRowSet >& xRowSet,
+                   const Date& rNullDate);
+
+    /** Set filter on/off flag to each row to control visibility.  The caller
+        must ensure that the table is filled before calling this function. */
+    void filterByPageDimension(const ::std::vector<ScDPDimension*>& rPageDims);
+
+    /** Get the cell instance at specified location within the data grid. Note
+        that the data grid doesn't include the header row.  Don't delete the
+        returned object! */
+    const ::ScDPCacheTable::Cell* getCell(SCCOL nCol, SCROW nRow) const;
+
+    const String* getFieldName(sal_Int32 nIndex) const;
+
+    /** Get the field index (i.e. column ID in the original data source) based
+        on the string value that corresponds with the column title.  It returns
+        -1 if no field matching the string value exists. */
+    sal_Int32 getFieldIndex(const String& rStr) const;
+
+    /** Get the unique entries for a field specified by index.  The caller must
+        make sure that the table is filled before calling function, or it will
+        get an empty collection. */
+    const TypedStrCollection& getFieldEntries(sal_Int32 nIndex) const;
+
+    void filterTable(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters,
+                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+
+    void clear();
+    void swap(ScDPCacheTable& rOther);
+    bool empty() const;
+
+    static const String* getString(sal_Int32 nId);
+    static sal_Int32 getStringId(const String& aStr);
+
+private:
+    void getValueData(ScDocument* pDoc, const ScAddress& rPos, Cell& rCell);
+    ScDPCacheTable::Cell getSelectedDimension(ScDPDimension* pDim) const;
+
+private:
+    typedef ::boost::shared_ptr<TypedStrCollection> TypedStrCollectionPtr;
+
+    /** main data table. */
+    ::std::vector< ::std::vector< ::ScDPCacheTable::Cell > > maTable;
+
+    /** header string IDs */
+    ::std::vector<sal_Int32> maHeader;
+
+    /** unique field entires for each field (column). */
+    ::std::vector<TypedStrCollectionPtr> maFieldEntries;
+
+    /** used to track visibility of rows.  The first row below the header row
+        has the index of 0. */
+    ::std::vector<bool> maRowsVisible;
+
+    static sal_Int32 insertString(const String& aStr);
+    static ::osl::Mutex maStrMutex;
+    static ScSharedStringTable maStringTable;
+};
+
+
+#endif
--- /dev/null	2007-05-04 06:54:36.000000000 -0400
+++ sc/source/core/data/dpcachetable.cxx	2007-10-11 15:34:36.000000000 -0400
@@ -0,0 +1,620 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: dpobject.hxx,v $
+ *
+ *  $Revision: 1.12 $
+ *
+ *  last change: $Author: hr $ $Date: 2007/06/27 13:41:57 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "dpcachetable.hxx"
+#include "document.hxx"
+#include "address.hxx"
+#include "cell.hxx"
+#include "dptabdat.hxx"
+#include "dptabsrc.hxx"
+
+#include <stdio.h>
+
+#include <com/sun/star/sdbc/DataType.hpp>
+#include <com/sun/star/sdbc/XRow.hpp>
+#include <com/sun/star/sdbc/XRowSet.hpp>
+#include <com/sun/star/sdbc/XResultSetMetaData.hpp>
+#include <com/sun/star/sdbc/XResultSetMetaDataSupplier.hpp>
+#include <com/sun/star/util/Date.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+
+using namespace ::com::sun::star;
+
+using ::rtl::OUString;
+using ::std::vector;
+using ::std::set;
+using ::com::sun::star::uno::Exception;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::com::sun::star::sheet::DataPilotFieldFilter;
+
+static BOOL lcl_HasQueryEntry( const ScQueryParam& rParam )
+{
+    return rParam.GetEntryCount() > 0 &&
+            rParam.GetEntry(0).bDoQuery;
+}
+
+ScSharedStringTable::ScSharedStringTable() :
+    mnStrCount(0)
+{
+    // empty string (ID = 0)
+    maSharedStrings.push_back(String());
+    maSharedStringIds.insert( SharedStrMap::value_type(String(), mnStrCount++) );
+}
+
+ScSharedStringTable::~ScSharedStringTable()
+{
+}
+
+sal_Int32 ScSharedStringTable::insertString(const String& aStr)
+{
+    SharedStrMap::const_iterator itr = maSharedStringIds.find(aStr), 
+        itrEnd = maSharedStringIds.end();
+
+    if (itr == itrEnd)
+    {
+        // new string.
+        maSharedStrings.push_back(aStr);
+        maSharedStringIds.insert( SharedStrMap::value_type(aStr, mnStrCount) );
+        return mnStrCount++;
+    }
+
+    // existing string.
+    return itr->second;
+}
+
+sal_Int32 ScSharedStringTable::getStringId(const String& aStr)
+{
+    SharedStrMap::const_iterator itr = maSharedStringIds.find(aStr), 
+        itrEnd = maSharedStringIds.end();
+    if (itr == itrEnd)
+    {
+        // string not found.
+        return insertString(aStr);
+    }
+    return itr->second;
+}
+
+const String* ScSharedStringTable::getString(sal_Int32 nId) const
+{
+    if (nId >= mnStrCount)
+        return NULL;
+
+    return &maSharedStrings[nId];
+}
+
+// ----------------------------------------------------------------------------
+
+ScDPCacheTable::Cell::Cell() :
+    mfValue(0.0),
+    mbNumeric(false)
+{
+}
+
+ScDPCacheTable::Filter::Filter()
+{
+}
+
+::osl::Mutex ScDPCacheTable::maStrMutex;
+ScSharedStringTable ScDPCacheTable::maStringTable;
+
+ScDPCacheTable::ScDPCacheTable()
+{
+}
+
+ScDPCacheTable::~ScDPCacheTable()
+{
+}
+
+sal_Int32 ScDPCacheTable::getHeaderSize() const
+{
+    return maHeader.size();
+}
+
+sal_Int32 ScDPCacheTable::getRowSize() const
+{
+    return maTable.size();
+}
+
+sal_Int32 ScDPCacheTable::getColSize() const
+{
+    return maTable.empty() ? 0 : maTable[0].size();
+}
+
+void ScDPCacheTable::fillTable(ScDocument* pDoc, const ScRange& rRange, const ScQueryParam& rQuery, BOOL* pSpecial)
+{
+    SCTAB nTab = rRange.aStart.Tab();
+    SCCOL nStartCol = rRange.aStart.Col();
+    SCROW nStartRow = rRange.aStart.Row();
+    SCCOL nColCount = rRange.aEnd.Col() - rRange.aStart.Col() + 1;
+    SCROW nRowCount = rRange.aEnd.Row() - rRange.aStart.Row() + 1;
+
+    if (nRowCount <= 1 || nColCount <= 0)
+        return;
+
+    maTable.clear();
+    maTable.reserve(nRowCount);
+    maHeader.clear();
+    maHeader.reserve(nColCount);
+    maRowsVisible.clear();
+    maRowsVisible.reserve(nRowCount);
+
+    // Header row
+    for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+    {
+        String aStr;
+        pDoc->GetString(nCol, 0, nTab, aStr);
+        sal_Int32 nStrId = maStringTable.insertString(aStr);
+        maHeader.push_back(nStrId);
+    }
+
+    // Initialize field entries container.
+    maFieldEntries.clear();
+    maFieldEntries.reserve(nColCount);
+    for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+    {
+        TypedStrCollectionPtr p(new TypedStrCollection);
+        maFieldEntries.push_back(p);
+    }
+
+    // Data rows
+    for (SCROW nRow = 1; nRow < nRowCount; ++nRow)
+    {
+        if ( lcl_HasQueryEntry(rQuery) && !pDoc->ValidQuery(nRow + nStartRow, nTab, rQuery, pSpecial) )
+            // filtered out by standard filter.
+            continue;
+
+        // Insert a new row into cache table.
+        maRowsVisible.push_back(true);
+        maTable.push_back( vector<Cell>() );
+        maTable.back().reserve(nColCount);
+
+        for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+        {
+            maTable.back().push_back( ScDPCacheTable::Cell() );
+            Cell& rCell = maTable.back().back();
+                
+            String aStr;
+            pDoc->GetString(nStartCol + nCol, nStartRow + nRow, nTab, aStr);
+            rCell.mnStrId = maStringTable.insertString(aStr);
+            ScAddress aPos(nStartCol + nCol, nStartRow + nRow, nTab);
+            getValueData(pDoc, aPos, rCell);
+
+            TypedStrData* pNew;
+            if (rCell.mbNumeric)
+                pNew = new TypedStrData(aStr, rCell.mfValue, SC_STRTYPE_VALUE);
+            else
+                pNew = new TypedStrData(aStr);
+
+            if (!maFieldEntries[nCol]->Insert(pNew))
+                delete pNew;
+        }
+    }
+}
+
+void lcl_GetCellValue(const Reference<sdbc::XRow>& xRow, sal_Int32 nType, long nCol,
+             const Date& rNullDate, ScDPCacheTable::Cell& rCell, String& rStr)
+{
+    short nNumType = NUMBERFORMAT_NUMBER;
+    BOOL bEmptyFlag = FALSE;
+    try
+    {
+        rStr = xRow->getString(nCol);
+        rCell.mnStrId = ScDPCacheTable::getStringId(rStr);
+
+        switch (nType)
+        {
+            case sdbc::DataType::BIT:
+            case sdbc::DataType::BOOLEAN:
+            {
+                nNumType = NUMBERFORMAT_LOGICAL;
+                rCell.mfValue = xRow->getBoolean(nCol) ? 1 : 0;    
+                bEmptyFlag = (rCell.mfValue == 0.0 && xRow->wasNull());
+                rCell.mbNumeric = true;
+            }
+            break;
+
+            case sdbc::DataType::TINYINT:
+            case sdbc::DataType::SMALLINT:
+            case sdbc::DataType::INTEGER:
+            case sdbc::DataType::BIGINT:
+            case sdbc::DataType::FLOAT:
+            case sdbc::DataType::REAL:
+            case sdbc::DataType::DOUBLE:
+            case sdbc::DataType::NUMERIC:
+            case sdbc::DataType::DECIMAL:
+            {
+                //! do the conversion here?
+                rCell.mfValue = xRow->getDouble(nCol);
+                bEmptyFlag = (rCell.mfValue == 0.0 && xRow->wasNull());
+                rCell.mbNumeric = true;
+            }
+            break;
+
+            case sdbc::DataType::CHAR:
+            case sdbc::DataType::VARCHAR:
+            case sdbc::DataType::LONGVARCHAR:
+                bEmptyFlag = (rStr.Len() == 0 && xRow->wasNull());
+            break;
+
+            case sdbc::DataType::DATE:
+            {
+                nNumType = NUMBERFORMAT_DATE;
+
+                util::Date aDate = xRow->getDate(nCol);
+                rCell.mfValue = Date(aDate.Day, aDate.Month, aDate.Year) - rNullDate;
+                bEmptyFlag = xRow->wasNull();
+                rCell.mbNumeric = true;
+            }
+            break;
+
+                //! case sdbc::DataType::TIME:
+                //! case sdbc::DataType::TIMESTAMP:
+
+            case sdbc::DataType::SQLNULL:
+            case sdbc::DataType::BINARY:
+            case sdbc::DataType::VARBINARY:
+            case sdbc::DataType::LONGVARBINARY:
+            default:
+            break;
+        }
+    }
+    catch (uno::Exception&)
+    {
+    }
+}
+
+void ScDPCacheTable::fillTable(const Reference<sdbc::XRowSet>& xRowSet, const Date& rNullDate)
+{
+    try
+    {
+        Reference<sdbc::XResultSetMetaDataSupplier> xMetaSupp(xRowSet, UNO_QUERY_THROW);
+        Reference<sdbc::XResultSetMetaData> xMeta = xMetaSupp->getMetaData();
+        if (!xMeta.is())
+            return;
+
+        sal_Int32 nColCount = xMeta->getColumnCount();
+
+        // Get column titles and types.
+        vector<sal_Int32> aColTypes(nColCount);
+        maHeader.clear();
+        maHeader.reserve(nColCount);
+        for (sal_Int32 nCol = 0; nCol < nColCount; ++nCol)
+        {
+            String aColTitle = xMeta->getColumnLabel(nCol+1);
+            aColTypes[nCol]  = xMeta->getColumnType(nCol+1);
+            maHeader.push_back( ScDPCacheTable::getStringId(aColTitle) );
+        }
+
+        // Initialize field entries container.
+        maFieldEntries.clear();
+        maFieldEntries.reserve(nColCount);
+        for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+        {
+            TypedStrCollectionPtr p(new TypedStrCollection);
+            maFieldEntries.push_back(p);
+        }
+
+        // Now get the data rows.
+        Reference<sdbc::XRow> xRow(xRowSet, UNO_QUERY_THROW);
+        xRowSet->first();
+        maTable.clear();
+        maRowsVisible.clear();
+        do
+        {
+            maRowsVisible.push_back(true);
+            maTable.push_back( vector<Cell>() );
+            maTable.back().reserve(nColCount);
+            for (sal_Int32 nCol = 0; nCol < nColCount; ++nCol)
+            {
+                maTable.back().push_back( Cell() );
+                Cell& rCell = maTable.back().back();
+                String aStr;
+                lcl_GetCellValue(xRow, aColTypes[nCol], nCol+1, rNullDate, rCell, aStr);
+
+                TypedStrData* pNew;
+                if (rCell.mbNumeric)
+                    pNew = new TypedStrData(aStr, rCell.mfValue, SC_STRTYPE_VALUE);
+                else
+                    pNew = new TypedStrData(aStr);
+
+                if (!maFieldEntries[nCol]->Insert(pNew))
+                    delete pNew;
+            }
+        }
+        while (xRowSet->next());
+    }
+    catch (const Exception&)
+    {
+    }
+
+    xRowSet->beforeFirst();
+}
+
+void ScDPCacheTable::filterByPageDimension(const vector<ScDPDimension*>& rPageDims)
+{
+    sal_Int32 nRowSize = getRowSize();
+
+    if (nRowSize != static_cast<sal_Int32>(maRowsVisible.size()))
+    {
+        fprintf(stdout, "ScDPCacheTable::filterByPageDimension: the sizes of the two tables differ.\n");fflush(stdout);
+        return;
+    }
+
+    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+    {
+        maRowsVisible[nRow] = true;
+        const vector<Cell>& rRow = maTable[nRow];
+        vector<ScDPDimension*>::const_iterator itr = rPageDims.begin(), itrEnd = rPageDims.end();
+        for (; itr != itrEnd; ++itr)
+        {
+            ScDPDimension* pDim = *itr;
+            ScDPCacheTable::Cell aDimCell = getSelectedDimension(pDim);
+            
+            sal_Int32 nCol = pDim->GetDimension();
+            const Cell& rCell = rRow[nCol];
+            if (aDimCell.mnStrId != ScSharedStringTable::EMPTY && aDimCell.mnStrId != rCell.mnStrId)
+            {
+                // Selected page dimension value does not match the current value.  Skip it 
+                // (note: when the selected page dimension value is empty, '- all -' is 
+                // selected.
+                maRowsVisible[nRow] = false;
+                break;
+            }
+        }
+    }
+}
+
+const ::ScDPCacheTable::Cell* ScDPCacheTable::getCell(SCCOL nCol, SCROW nRow) const
+{
+    if ( nRow >= static_cast<SCROW>(maTable.size()) )
+        return NULL;
+
+    const vector<Cell>& rRow = maTable[nRow];
+    if ( nCol < 0 || static_cast<size_t>(nCol) >= rRow.size() )
+        return NULL;
+
+    return &rRow[nCol];
+}
+
+const String* ScDPCacheTable::getFieldName(sal_Int32 nIndex) const
+{
+    if (nIndex >= static_cast<sal_Int32>(maHeader.size()))
+        return NULL;
+
+    return getString(maHeader[nIndex]);
+}
+
+sal_Int32 ScDPCacheTable::getFieldIndex(const String& rStr) const
+{
+    sal_Int32 nStrId = getStringId(rStr);
+    if (nStrId < 0)
+        // string not found.
+        return nStrId;
+
+    sal_Int32 n = maHeader.size();
+    for (sal_Int32 i = 0; i < n; ++i)
+    {
+        if (maHeader[i] == nStrId)
+            return i;
+    }
+
+    return -1;
+}
+
+const TypedStrCollection& ScDPCacheTable::getFieldEntries(sal_Int32 nIndex) const
+{
+    if (nIndex < 0 || nIndex >= maFieldEntries.size())
+    {
+        fprintf(stdout, "ScDPCacheTable::getFieldEntries: OUT OF BOUND\n");fflush(stdout);
+        // index out of bound.  Hopefully this code will never be reached.
+        static const TypedStrCollection empty;
+        return empty;
+    }
+
+    return *maFieldEntries[nIndex].get();
+}
+
+void ScDPCacheTable::filterTable(const Sequence<DataPilotFieldFilter>& rFilters, 
+                                 Sequence< Sequence<Any> >& rTabData)
+{
+    sal_Int32 nRowSize = getRowSize();
+    sal_Int32 nColSize = getColSize();
+
+    if (!nRowSize)
+        // no data to filter.
+        return;
+
+    // Convert filters first.
+    vector<Filter> filters;
+    sal_Int32 nFilterSize = rFilters.getLength();
+    filters.reserve(nFilterSize);
+    for (sal_Int32 i = 0; i < nFilterSize; ++i)
+    {
+        Filter fil;
+        fil.mnFieldIndex = getFieldIndex(String(rFilters[i].FieldName));
+        fil.mnMatchStrId = getStringId(String(rFilters[i].MatchValue));
+        if (fil.mnFieldIndex >= 0)
+            filters.push_back(fil);
+    }
+    
+    // Row first, then column.
+    vector< Sequence<Any> > tableData;
+    tableData.reserve(nRowSize+1);
+
+    // Header first.
+    Sequence<Any> headerRow(nColSize);
+    for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+    {
+        OUString str;
+        const String* pStr = getString(maHeader[nCol]);
+        if (pStr)
+            str = *pStr;
+
+        Any any;
+        any <<= str;
+        headerRow[nCol] = any;
+    }
+    tableData.push_back(headerRow);
+
+    // Data rows.
+    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+    {
+        if (!maRowsVisible[nRow])
+            // This row is filtered out.
+            continue;
+
+        bool bRetainRow = true;
+        vector<Filter>::const_iterator itr, itrEnd = filters.end();
+        for (itr = filters.begin(); itr != itrEnd; ++itr)
+        {
+            if (itr->mnFieldIndex >= nColSize)
+            {
+                // specified field is outside the source data columns.
+                bRetainRow = false;
+                break;
+            }
+
+            if ( maTable[nRow][itr->mnFieldIndex].mnStrId != itr->mnMatchStrId )
+            {
+                // The string value does not match.
+                bRetainRow = false;
+                break;
+            }
+        }
+
+        if (bRetainRow)
+        {
+            Sequence<Any> row(nColSize);
+            for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+            {
+                Any any;
+                const Cell& rCell = maTable[nRow][nCol];
+                if (rCell.mbNumeric)
+                    any <<= rCell.mfValue;
+                else
+                {
+                    OUString str;
+                    const String* pStr = getString(rCell.mnStrId);
+                    if (pStr)
+                        str = *pStr;
+                    any <<= str;
+                }
+                row[nCol] = any;
+            }
+            tableData.push_back(row);
+        }
+    }
+
+    // convert vector to Seqeunce
+    sal_Int32 nTabSize = static_cast<sal_Int32>(tableData.size());
+    rTabData.realloc(nTabSize);
+    for (sal_Int32 i = 0; i < nTabSize; ++i)
+        rTabData[i] = tableData[i];
+}
+
+void ScDPCacheTable::clear()
+{
+    maTable.clear();
+    maHeader.clear();
+    maFieldEntries.clear();
+}
+
+void ScDPCacheTable::swap(ScDPCacheTable& rOther)
+{
+    maTable.swap(rOther.maTable);
+    maHeader.swap(rOther.maHeader);
+    maFieldEntries.swap(rOther.maFieldEntries);
+}
+
+bool ScDPCacheTable::empty() const
+{
+    return maTable.empty();
+}
+
+void ScDPCacheTable::getValueData(ScDocument* pDoc, const ScAddress& rPos, Cell& rCell)
+{
+    ScBaseCell* pCell = pDoc->GetCell(rPos);
+    if ( !pCell )
+        return;
+
+    if ( pCell->HasValueData() )
+    {
+        CellType eType = pCell->GetCellType();
+        if (eType == CELLTYPE_VALUE)
+        {
+            // value cell
+            rCell.mfValue = static_cast<ScValueCell*>(pCell)->GetValue();
+        }
+        else if (eType == CELLTYPE_FORMULA)
+        {
+            // formula cell
+            rCell.mfValue = static_cast<ScFormulaCell*>(pCell)->GetValue();
+        }
+        rCell.mbNumeric = true;
+    }
+}
+
+ScDPCacheTable::Cell ScDPCacheTable::getSelectedDimension(ScDPDimension* pDim) const
+{
+    const ScDPItemData& rData = pDim->GetSelectedData();
+    Cell aCell;
+    aCell.mfValue = rData.fValue;
+    aCell.mbNumeric = rData.bHasValue;
+    aCell.mnStrId = getStringId(rData.aString);
+    return aCell;
+}
+
+// static 
+sal_Int32 ScDPCacheTable::insertString(const String& aStr)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.insertString(aStr);
+}
+
+const String* ScDPCacheTable::getString(sal_Int32 nId)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.getString(nId);
+}
+
+sal_Int32 ScDPCacheTable::getStringId(const String& aStr)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.getStringId(aStr);
+}
? offapi/offapi.vpj
? offapi/com/sun/star/sheet/DataPilotFieldFilter.idl
Index: offapi/com/sun/star/sheet/makefile.mk
===================================================================
RCS file: /cvs/api/offapi/com/sun/star/sheet/makefile.mk,v
retrieving revision 1.24
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.24 makefile.mk
--- offapi/com/sun/star/sheet/makefile.mk	22 May 2007 15:11:32 -0000	1.24
+++ offapi/com/sun/star/sheet/makefile.mk	12 Oct 2007 01:27:59 -0000
@@ -59,6 +59,7 @@
 	CellAreaLinksEnumeration.idl\
 	DatabaseRangesEnumeration.idl\
 	DataPilotFieldsEnumeration.idl\
+	DataPilotFieldFilter.idl\
 	DataPilotItem.idl\
 	DataPilotItems.idl\
 	DataPilotItemsEnumeration.idl\
--- /dev/null	2007-05-04 06:54:36.000000000 -0400
+++ offapi/com/sun/star/sheet/DataPilotFieldFilter.idl	2007-10-08 20:19:06.000000000 -0400
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: DataPilotItem.idl,v $
+ *
+ *  $Revision: 1.4 $
+ *
+ *  last change: $Author: rt $ $Date: 2005/09/08 04:33:20 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_sheet_DataPilotFieldFilter_idl__
+#define __com_sun_star_sheet_DataPilotFieldFilter_idl__
+
+//=============================================================================
+
+module com {  module sun {  module star {  module sheet {
+
+//=============================================================================
+
+struct DataPilotFieldFilter
+{
+    /** Field name. */
+    string FieldName;
+
+    /** String value that needs to match against. */
+    string MatchValue;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
+
