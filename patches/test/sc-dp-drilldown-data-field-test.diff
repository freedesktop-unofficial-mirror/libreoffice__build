? sc/Debug
? sc/sc.diff
? sc/sc.vpj
Index: sc/inc/dapiuno.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dapiuno.hxx,v
retrieving revision 1.9
retrieving revision 1.9.508.3
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.9 -r1.9.508.3
--- sc/inc/dapiuno.hxx	13 Jan 2006 16:51:24 -0000	1.9
+++ sc/inc/dapiuno.hxx	8 Nov 2007 18:03:19 -0000	1.9.508.3
@@ -56,9 +56,7 @@
 #include <svtools/itemprop.hxx>
 #endif
 
-#ifndef _COM_SUN_STAR_SHEET_XDATAPILOTTABLE_HPP_
-#include <com/sun/star/sheet/XDataPilotTable.hpp>
-#endif
+#include <com/sun/star/sheet/XDataPilotTable2.hpp>
 #ifndef _COM_SUN_STAR_SHEET_XDATAPILOTTABLES_HPP_
 #include <com/sun/star/sheet/XDataPilotTables.hpp>
 #endif
@@ -124,6 +122,11 @@
 #include <memory> 
 #include <vector>
 
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+    struct DataPilotTablePositionData;
+}}}}
+
 class ScDocShell;
 class ScPivot;
 class ScDPSaveDimension;
@@ -360,7 +363,7 @@
 
 
 class ScDataPilotTableObj : public ScDataPilotDescriptorBase,
-							public com::sun::star::sheet::XDataPilotTable
+							public com::sun::star::sheet::XDataPilotTable2
 {
 private:
 	SCTAB					nTab;
@@ -392,6 +395,18 @@
 								throw(::com::sun::star::uno::RuntimeException);
 	virtual void SAL_CALL	refresh() throw(::com::sun::star::uno::RuntimeException);
 
+                            // XDataPilotTable2
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > > 
+        SAL_CALL getDrillDownData(const ::com::sun::star::table::CellAddress& aAddr)
+                                throw(::com::sun::star::uno::RuntimeException);
+
+    virtual ::com::sun::star::sheet::DataPilotTablePositionData
+        SAL_CALL getPositionData(const ::com::sun::star::table::CellAddress& aAddr)
+                                throw(::com::sun::star::uno::RuntimeException);
+
+    virtual ::com::sun::star::table::CellRangeAddress SAL_CALL getOutputRangeByType( sal_Int32 nType )
+                                throw(::com::sun::star::uno::RuntimeException);
+
 							// XTypeProvider (overloaded)
 	virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Type > SAL_CALL getTypes()
 								throw(::com::sun::star::uno::RuntimeException);
Index: sc/inc/dpcachetable.hxx
===================================================================
RCS file: sc/inc/dpcachetable.hxx
diff -N sc/inc/dpcachetable.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/inc/dpcachetable.hxx	29 Oct 2007 17:44:39 -0000	1.1.2.1
@@ -0,0 +1,189 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: dpcachetable.hxx,v $
+ *
+ *  $Revision: 1.1.2.1 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/10/29 17:44:39 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_DPCACHETABLE_HXX
+#define SC_DPCACHETABLE_HXX
+
+#include "sal/types.h"
+#include "osl/mutex.hxx"
+#include "global.hxx"
+#include "collect.hxx"
+#include "dptabdat.hxx"
+
+#include <vector>
+#include <set>
+#include <hash_map>
+#include <boost/shared_ptr.hpp>
+#include <com/sun/star/uno/Reference.hxx>
+
+namespace com { namespace sun { namespace star {
+    namespace sdbc {
+        class XRowSet;
+    }
+    namespace sheet {
+        struct DataPilotFieldFilter;
+    }
+}}}
+
+class Date;
+
+class ScDocument;
+class ScRange;
+class ScDPDimension;
+
+class ScSharedStringTable
+{
+public:
+    static const sal_Int32 EMPTY = 0;
+
+    sal_Int32 insertString(const String& aStr);
+    sal_Int32 getStringId(const String& aStr);
+    const String* getString(sal_Int32 nId) const;
+
+    ScSharedStringTable();
+    ~ScSharedStringTable();
+
+private:
+    typedef ::std::hash_map< String, sal_Int32, ScStringHashCode, ::std::equal_to< String > > SharedStrMap;
+
+    ::std::vector<String> maSharedStrings;
+    SharedStrMap maSharedStringIds;
+    sal_Int32 mnStrCount;
+};
+
+// ----------------------------------------------------------------------------
+
+class ScDPCacheTable
+{
+public:
+    /** individual cell within table. */
+    struct Cell
+    {
+        sal_Int32   mnStrId;
+        double      mfValue;
+        bool        mbNumeric;
+        sal_uInt8   mnType;
+
+        Cell();
+    };
+
+    /** filtering criteria */
+    struct Filter
+    {
+        sal_Int32   mnFieldIndex;
+        sal_Int32   mnMatchStrId;
+
+        Filter();
+    };
+
+    ScDPCacheTable();
+    ~ScDPCacheTable();
+
+    sal_Int32 getHeaderSize() const;
+    sal_Int32 getRowSize() const;
+    sal_Int32 getColSize() const;
+
+    /** Fill the internal table from the cell range provided.  This function
+        assumes that the first row is the column header. */
+    void fillTable(ScDocument* pDoc, const ScRange& rRange, const ScQueryParam& rQuery, BOOL* pSpecial);
+
+    /** Fill the internal table from database connection object.  This function
+        assumes that the first row is the column header. */
+    void fillTable(const ::com::sun::star::uno::Reference< ::com::sun::star::sdbc::XRowSet >& xRowSet,
+                   const Date& rNullDate);
+
+    /** Check whether a specified row is active or not.  When a row is active,
+        it is used in calculation of the results data.  A row becomes inactive
+        when it is filtered out by page field. */
+    bool isRowActive(sal_Int32 nRow) const;
+
+    /** Set filter on/off flag to each row to control visibility.  The caller
+        must ensure that the table is filled before calling this function. */
+    void filterByPageDimension(const ::std::vector<ScDPDimension*>& rPageDims);
+
+    /** Get the cell instance at specified location within the data grid. Note
+        that the data grid doesn't include the header row.  Don't delete the
+        returned object! */
+    const ::ScDPCacheTable::Cell* getCell(SCCOL nCol, SCROW nRow) const;
+
+    const String* getFieldName(sal_Int32 nIndex) const;
+
+    /** Get the field index (i.e. column ID in the original data source) based
+        on the string value that corresponds with the column title.  It returns
+        -1 if no field matching the string value exists. */
+    sal_Int32 getFieldIndex(const String& rStr) const;
+
+    /** Get the unique entries for a field specified by index.  The caller must
+        make sure that the table is filled before calling function, or it will
+        get an empty collection. */
+    const TypedStrCollection& getFieldEntries(sal_Int32 nIndex) const;
+
+    void filterTable(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters,
+                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+
+    void clear();
+    void swap(ScDPCacheTable& rOther);
+    bool empty() const;
+
+    static const String* getString(sal_Int32 nId);
+    static sal_Int32 getStringId(const String& aStr);
+
+private:
+    void getValueData(ScDocument* pDoc, const ScAddress& rPos, Cell& rCell);
+    ScDPCacheTable::Cell getSelectedDimension(ScDPDimension* pDim) const;
+
+private:
+    typedef ::boost::shared_ptr<TypedStrCollection> TypedStrCollectionPtr;
+
+    /** main data table. */
+    ::std::vector< ::std::vector< ::ScDPCacheTable::Cell > > maTable;
+
+    /** header string IDs */
+    ::std::vector<sal_Int32> maHeader;
+
+    /** unique field entires for each field (column). */
+    ::std::vector<TypedStrCollectionPtr> maFieldEntries;
+
+    /** used to track visibility of rows.  The first row below the header row
+        has the index of 0. */
+    ::std::vector<bool> maRowsVisible;
+
+    static sal_Int32 insertString(const String& aStr);
+    static ::osl::Mutex maStrMutex;
+    static ScSharedStringTable maStringTable;
+};
+
+
+#endif
Index: sc/inc/dpgroup.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpgroup.hxx,v
retrieving revision 1.4
retrieving revision 1.4.570.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.4 -r1.4.570.1
--- sc/inc/dpgroup.hxx	8 Sep 2005 17:34:35 -0000	1.4
+++ sc/inc/dpgroup.hxx	29 Oct 2007 17:44:39 -0000	1.4.570.1
@@ -37,6 +37,7 @@
 #define SC_DPGROUP_HXX
 
 #include <vector>
+#include <hash_set>
 
 #ifndef SC_DPTABDAT_HXX
 #include "dptabdat.hxx"
@@ -180,13 +181,17 @@
 
 class ScDPGroupTableData : public ScDPTableData
 {
+    typedef ::std::hash_set< ::rtl::OUString, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > StringHashSet;
+
     ScDPTableData*          pSourceData;
     long                    nSourceCount;
     ScDPGroupDimensionVec   aGroups;
     ScDPNumGroupDimension*  pNumGroups;     // array[nSourceCount]
     ScDocument*             pDoc;
+    StringHashSet           aGroupNames;
 
     void        FillGroupValues( ScDPItemData* pItemData, long nCount, const long* pDims );
+    void        CopyFields(const ::std::vector<long>& rFieldDims, ::std::vector<long>& rNewFieldDims);
     long*       CopyFields( const long* pSourceDims, long nCount );
 
     bool        IsNumGroupDimension( long nDimension ) const;
@@ -213,8 +218,17 @@
     virtual void                    DisposeData();
     virtual void                    SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
 
+    virtual void                    CreateCacheTable();
+    virtual void                    FilterCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters,
+                                                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+    virtual void                    CalcResults(CalcInfo& rInfo, bool bAutoShow);
+    virtual const ScDPCacheTable&   GetCacheTable() const;
+
+#if not USE_NEW_CODE    
     virtual void                    ResetIterator();
     virtual BOOL                    GetNextRow( const ScDPTableIteratorParam& rParam );
+#endif    
 
     virtual BOOL                    IsBaseForGroup(long nDim) const;
     virtual long                    GetGroupBase(long nGroupDim) const;
Index: sc/inc/dpobject.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpobject.hxx,v
retrieving revision 1.12
retrieving revision 1.12.112.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 -r1.12.112.4
--- sc/inc/dpobject.hxx	27 Jun 2007 13:41:57 -0000	1.12
+++ sc/inc/dpobject.hxx	8 Nov 2007 18:03:19 -0000	1.12.112.4
@@ -62,6 +62,11 @@
 
 //------------------------------------------------------------------
 
+namespace com { namespace sun { namespace star { namespace sheet {
+
+    struct DataPilotTablePositionData;
+
+}}}}
 
 class Rectangle;
 class SvStream;
@@ -78,7 +83,7 @@
 class StrCollection;
 class TypedStrCollection;
 struct PivotField;
-
+class ScDPCacheTable;
 
 struct ScDPServiceDesc
 {
@@ -142,6 +147,7 @@
 
 	void				Output();
 	ScRange				GetNewOutputRange( BOOL& rOverflow );
+    const ScRange       GetOutputRangeByType( sal_Int32 nType );
 
 	void				SetSaveData(const ScDPSaveData& rData);
 	ScDPSaveData*		GetSaveData() const		{ return pSaveData; }
@@ -223,6 +229,17 @@
 	BOOL				RefsEqual( const ScDPObject& r ) const;
 	void				WriteRefsTo( ScDPObject& r ) const;
 
+    void                GetPositionData(const ScAddress& rPos, ::com::sun::star::sheet::DataPilotTablePositionData& rPosData);
+
+    bool                GetDataFieldPositionData(const ScAddress& rPos, 
+                                                 ::com::sun::star::uno::Sequence< 
+                                                    ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters);
+
+    void                GetDrillDownData(const ScAddress& rPos, 
+                                         ::com::sun::star::uno::Sequence< 
+                                            ::com::sun::star::uno::Sequence< 
+                                                ::com::sun::star::uno::Any > >& rTableData);
+
 	// apply drop-down attribute, initialize nHeaderRows, without accessing the source
 	// (button attribute must be present)
 	void				RefreshAfterLoad();
Index: sc/inc/dpoutput.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpoutput.hxx,v
retrieving revision 1.8
retrieving revision 1.8.112.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.8 -r1.8.112.4
--- sc/inc/dpoutput.hxx	27 Jun 2007 13:42:13 -0000	1.8
+++ sc/inc/dpoutput.hxx	9 Nov 2007 02:12:08 -0000	1.8.112.4
@@ -52,6 +52,8 @@
 #include <com/sun/star/sheet/GeneralFunction.hpp>
 #endif
 
+#include <com/sun/star/sheet/DataPilotTableRegion.hpp>
+
 #ifndef SC_SCGLOB_HXX
 #include "global.hxx"
 #endif
@@ -60,8 +62,14 @@
 #include "address.hxx"
 #endif
 
+#include "dpcachetable.hxx"
 #include <vector>
 
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+    struct DataPilotTablePositionData;
+}}}}
+
 class Rectangle;
 class SvStream;
 class ScDocument;
@@ -122,12 +130,15 @@
 			com::sun::star::sheet::DataResult> > aData;
 	BOOL					bResultsError;
 	String					aDataDescription;
+
+    // Number format related parameters
 	UINT32*					pColNumFmt;
 	UINT32*					pRowNumFmt;
 	long					nColFmtCount;
 	long					nRowFmtCount;
     UINT32                  nSingleNumFmt;
 
+    // Output geometry related parameters
 	BOOL					bSizesValid;
 	BOOL					bSizeOverflow;
 	long					nColCount;
@@ -151,6 +162,11 @@
 								BOOL bFrame = TRUE );
 	void			CalcSizes();
 
+    /** Query which sub-area of the table the cell is in.  See
+        com.sun.star.sheet.DataPilotTablePositionType for the
+        interpretation of the return value. */
+    sal_Int32       GetPositionType(const ScAddress& rPos);
+
 public:
 					ScDPOutput( ScDocument* pD,
 								const com::sun::star::uno::Reference<
@@ -161,11 +177,17 @@
 	void			SetPosition( const ScAddress& rPos );
 
 	void			Output();			//! Refresh?
-	ScRange			GetOutputRange();
+    ScRange			GetOutputRange( sal_Int32 nRegionType = ::com::sun::star::sheet::DataPilotTableRegion::WHOLE );
 	long			GetHeaderRows();
 	BOOL			HasError();			// range overflow or exception from source
 
 	void			GetPositionData( ScDPPositionData& rData, const ScAddress& rPos );
+    void            GetPositionData(const ScAddress& rPos, ::com::sun::star::sheet::DataPilotTablePositionData& rPosData);
+
+    /** Get filtering criteria based on the position of the cell within data
+        field region. */
+    bool            GetDataResultPositionData(::std::vector< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters, const ScAddress& rPos);
+
     BOOL            GetPivotData( ScDPGetPivotDataField& rTarget, /* returns result */
                                   const std::vector< ScDPGetPivotDataField >& rFilters );
 	long			GetHeaderDim( const ScAddress& rPos, USHORT& rOrient );
Index: sc/inc/dpsdbtab.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpsdbtab.hxx,v
retrieving revision 1.3
retrieving revision 1.3.570.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.3 -r1.3.570.1
--- sc/inc/dpsdbtab.hxx	8 Sep 2005 17:35:48 -0000	1.3
+++ sc/inc/dpsdbtab.hxx	29 Oct 2007 17:44:39 -0000	1.3.570.1
@@ -50,6 +50,11 @@
 #include "dptabdat.hxx"
 #endif
 
+#include <vector>
+#include <set>
+
+class ScDPCacheTable;
+
 // --------------------------------------------------------------------
 //
 //	implementation of ScDPTableData with database data
@@ -77,7 +82,6 @@
 	ScDatabaseDPData_Impl* pImpl;
 
 	BOOL			OpenDatabase();
-	void			InitAllColumnEntries();
 
 public:
 					ScDatabaseDPData(
@@ -94,8 +98,17 @@
 	virtual void					DisposeData();
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
 
+    virtual void                    CreateCacheTable();
+    virtual void                    FilterCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters,
+                                                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+    virtual void                    CalcResults(CalcInfo& rInfo, bool bAutoShow);
+    virtual const ScDPCacheTable&   GetCacheTable() const;
+
+#if not USE_NEW_CODE	
 	virtual void					ResetIterator();
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam );
+#endif    
 };
 
 
Index: sc/inc/dpshttab.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dpshttab.hxx,v
retrieving revision 1.4
retrieving revision 1.4.570.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.4 -r1.4.570.1
--- sc/inc/dpshttab.hxx	8 Sep 2005 17:36:03 -0000	1.4
+++ sc/inc/dpshttab.hxx	29 Oct 2007 17:44:39 -0000	1.4.570.1
@@ -48,6 +48,14 @@
 #include "address.hxx"
 #endif
 
+#include <vector>
+
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+}}}}
+
+class ScDPDimension;
+class ScDPItemData;
 
 // --------------------------------------------------------------------
 //
@@ -70,7 +78,6 @@
 {
 private:
 	ScSheetDPData_Impl* pImpl;
-    BOOL* pSpecial;
 
 public:
 					ScSheetDPData( ScDocument* pD, const ScSheetSourceDesc& rDesc );
@@ -85,8 +92,17 @@
 	virtual void					DisposeData();
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty );
 
+    virtual void                    CreateCacheTable();
+    virtual void                    FilterCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& rFilters,
+                                                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rData);
+    virtual void                    CalcResults(CalcInfo& rInfo, bool bAutoShow);
+    virtual const ScDPCacheTable&   GetCacheTable() const;
+
+#if not USE_NEW_CODE	
 	virtual void					ResetIterator();
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam );
+#endif    
 };
 
 
Index: sc/inc/dptabdat.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dptabdat.hxx,v
retrieving revision 1.6
retrieving revision 1.6.216.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.6 -r1.6.216.1
--- sc/inc/dptabdat.hxx	25 Jan 2007 11:03:15 -0000	1.6
+++ sc/inc/dptabdat.hxx	29 Oct 2007 17:44:39 -0000	1.6.216.1
@@ -40,11 +40,21 @@
 #include "address.hxx"
 #endif
 
+#include "dpoutput.hxx"
+
 #ifndef _STRING_HXX
 #include <tools/string.hxx>
 #endif
 
+#include <vector>
+#include <set>
+
+namespace com { namespace sun { namespace star { namespace sheet {
+    struct DataPilotFieldFilter;
+}}}}
+
 class TypedStrCollection;
+class ScDPDimension;
 
 // -----------------------------------------------------------------------
 
@@ -65,6 +75,8 @@
 #define SC_DAPI_LEVEL_WEEK		1
 #define SC_DAPI_LEVEL_WEEKDAY	2
 
+#define USE_NEW_CODE 1
+
 // --------------------------------------------------------------------
 //
 //	base class ScDPTableData to allow implementation with tabular data
@@ -105,29 +117,37 @@
 	void	Set( double fV, BYTE nT ) { fValue = fV; nType = nT; }
 };
 
-
+#if not USE_NEW_CODE
 struct ScDPTableIteratorParam
 {
 	//	all pointers are just copied
 
-	SCSIZE			nColCount;
-	const long*		pCols;
-	ScDPItemData*	pColData;
-	SCSIZE			nRowCount;
-	const long*		pRows;
-	ScDPItemData*	pRowData;
-	SCSIZE			nPageCount;
-	const long*		pPages;
-	ScDPItemData*	pPageData;
-	SCSIZE			nDatCount;
-	const long*		pDats;
-	ScDPValueData*	pValues;
+	const SCSIZE	nColCount;      // nColLevelCount
+	const long*		pCols;          // nColLevelDims (pSourceCols for group)
+	ScDPItemData*	pColData;       // aColData
+	const SCSIZE	nRowCount;      // nRowLevelCount
+	const long*		pRows;          // nRowLevelDims (pSourceRows for group)
+	ScDPItemData*	pRowData;       // aRowData
+	const SCSIZE	nPageCount;     // nPageDimCount
+	const long*		pPages;         // nPageDims (pSourcePages for group)
+	ScDPItemData*	pPageData;      // aPageData
+	const SCSIZE	nDatCount;      // nDataDimCount
+	const long*		pDats;          // nDataSrcCols (pSourceDats for group)
+	ScDPValueData*	pValues;        // aValues
 
 	ScDPTableIteratorParam( long nCCount, const long* pC, ScDPItemData* pCDat,
 							long nRCount, const long* pR, ScDPItemData* pRDat,
 							long nPCount, const long* pP, ScDPItemData* pPDat,
 							long nDCount, const long* pD, ScDPValueData* pV );
 };
+#endif
+
+class ScDPResultMember;
+class ScDPDimension;
+class ScDPLevel;
+class ScDPInitState;
+class ScDPCacheTable;
+class ScDPResultMember;
 
 class ScDPTableData
 {
@@ -138,6 +158,25 @@
 	long 	nLastRet;
 
 public:
+    /** This structure stores dimension information used when calculating
+        results.  These data are read only during result calculation, so it
+        should be passed as a const instance. */
+    struct CalcInfo
+    {
+        ::std::vector<long>             aColLevelDims;
+        ::std::vector<ScDPDimension*>   aColDims;
+        ::std::vector<ScDPLevel*>       aColLevels;
+        ::std::vector<long>             aRowLevelDims;
+        ::std::vector<ScDPDimension*>   aRowDims;
+        ::std::vector<ScDPLevel*>       aRowLevels;
+        ::std::vector<long>             aPageDims;
+        ::std::vector<long>             aDataSrcCols;
+
+        ScDPInitState*                  pInitState;
+        ScDPResultMember*               pColRoot;
+        ScDPResultMember*               pRowRoot;
+    };
+
 				ScDPTableData();
 	virtual		~ScDPTableData();
 
@@ -155,8 +194,17 @@
 	virtual void					DisposeData() = 0;
 	virtual void					SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty ) = 0;
 
+    virtual void                    CreateCacheTable();
+    virtual void                    FilterCacheTable(const ::std::vector<ScDPDimension*>& rPageDims);
+    virtual void                    GetDrillDownData(const ::com::sun::star::uno::Sequence< ::com::sun::star::sheet::DataPilotFieldFilter >& aFilters,
+                                                     ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > >& rTabData);
+    virtual void                    CalcResults(CalcInfo& rInfo, bool bAutoShow);
+    virtual const ScDPCacheTable&   GetCacheTable() const = 0;
+
+#if not USE_NEW_CODE	
 	virtual void					ResetIterator() = 0;
 	virtual BOOL					GetNextRow( const ScDPTableIteratorParam& rParam ) = 0;
+#endif    
 
                                     // overloaded in ScDPGroupTableData:
     virtual BOOL                    IsBaseForGroup(long nDim) const;
@@ -166,6 +214,25 @@
                                                const ScDPItemData& rBaseData, long nBaseIndex ) const;
     virtual BOOL                    HasCommonElement( const ScDPItemData& rFirstData, long nFirstIndex,
                                                       const ScDPItemData& rSecondData, long nSecondIndex ) const;
+
+protected:
+    /** This structure stores vector arrays that hold intermediate data for
+        each row during cache table iteration. */
+    struct CalcRowData
+    {
+        ::std::vector<ScDPItemData>  aColData;
+        ::std::vector<ScDPItemData>  aRowData;
+        ::std::vector<ScDPItemData>  aPageData;
+        ::std::vector<ScDPValueData> aValues;
+    };
+
+    void            FillRowDataFromCacheTable(sal_Int32 nRow, const ScDPCacheTable& rCacheTable, const CalcInfo& rInfo, CalcRowData& rData);
+    void            ProcessRowData(CalcInfo& rInfo, CalcRowData& rData, bool bAutoShow);
+    void            CalcResultsFromCacheTable(const ScDPCacheTable& rCacheTable, CalcInfo& rInfo, bool bAutoShow);
+
+private:
+    void            GetItemData(const ScDPCacheTable& rCacheTable, sal_Int32 nRow, 
+                                const ::std::vector<long>& rDims, ::std::vector<ScDPItemData>& rItemData);
 };
 
 
Index: sc/inc/dptabres.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dptabres.hxx,v
retrieving revision 1.7
retrieving revision 1.7.202.5
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.7 -r1.7.202.5
--- sc/inc/dptabres.hxx	27 Feb 2007 11:55:52 -0000	1.7
+++ sc/inc/dptabres.hxx	7 Nov 2007 04:28:31 -0000	1.7.202.5
@@ -302,15 +302,17 @@
                                     const ScDPItemData& rBaseData, long nBaseIndex ) const;
     BOOL                HasCommonElement( const ScDPItemData& rFirstData, long nFirstIndex,
                                           const ScDPItemData& rSecondData, long nSecondIndex ) const;
+
+    void                Debug() const;
 };
 
 
 class ScDPResultMember
 {
 private:
-	ScDPResultData*			pResultData;
-	ScDPDimension*			pParentDim;				//! Ref
-	ScDPLevel*				pParentLevel;			//! Ref
+    const ScDPResultData*   pResultData;
+    const ScDPDimension*    pParentDim;             //! Ref
+    const ScDPLevel*        pParentLevel;           //! Ref
 	const ScDPMember*		pMemberDesc;			//! Ref
 	ScDPResultDimension*	pChildDimension;
 	ScDPDataMember*			pDataRoot;
@@ -322,15 +324,26 @@
 	ScDPAggData				aColTotal;				// to store column totals
 
 public:
-						ScDPResultMember( ScDPResultData* pData, ScDPDimension* pDim,
-											ScDPLevel* pLev, ScDPMember* pDesc,
+                        ScDPResultMember( const ScDPResultData* pData, const ScDPDimension* pDim,
+                                          const ScDPLevel* pLev, const ScDPMember* pDesc,
 											BOOL bForceSub );	//! Ref
 						~ScDPResultMember();
 
+#if USE_NEW_CODE
+    void                InitFrom( const ::std::vector<ScDPDimension*>& ppDim, 
+                                  const ::std::vector<ScDPLevel*>& ppLev,
+                                  size_t nPos,
+                                  ScDPInitState& rInitState );
+    void                LateInitFrom( const ::std::vector<ScDPDimension*>& ppDim, 
+                                      const ::std::vector<ScDPLevel*>& ppLev, 
+                                      const ::std::vector<ScDPItemData>& pItemData,
+                                      size_t nPos,
+                                      ScDPInitState& rInitState );
+#else
 	void				InitFrom( ScDPDimension** ppDim, ScDPLevel** ppLev, ScDPInitState& rInitState );
 	void				LateInitFrom( ScDPDimension** ppDim, ScDPLevel** ppLev, ScDPItemData* pItemData,
                                         ScDPInitState& rInitState );
-
+#endif
 	String				GetName() const;
     void                FillItemData( ScDPItemData& rData ) const;
 	BOOL				IsValid() const;
@@ -343,15 +356,26 @@
 	long				GetSubTotalCount( long* pUserSubStart = NULL ) const;
 
 	BOOL				IsNamedItem( const ScDPItemData& r ) const;
+#if USE_NEW_CODE	
+    bool                IsValidEntry( const ::std::vector<ScDPItemData>& aMembers ) const;
+#else
 	BOOL				IsValidEntry( const ScDPItemData* pMembers ) const;
+#endif    
 
 	void				SetHasElements()	{ bHasElements = TRUE; }
 	void                SetAutoHidden()     { bAutoHidden = TRUE; }
 
+#if USE_NEW_CODE
+    void                ProcessData( const ::std::vector<ScDPItemData>& aChildMembers,
+                                     const ScDPResultDimension* pDataDim,
+                                     const ::std::vector<ScDPItemData>& aDataMembers,
+                                     const ::std::vector<ScDPValueData>& aValues );
+#else	
 	void				ProcessData( const ScDPItemData* pChildMembers,
 										ScDPResultDimension* pDataDim,
 										const ScDPItemData* pDataMembers,
 										const ScDPValueData* pValues );
+#endif    
 
 	void				FillMemberResults( com::sun::star::uno::Sequence<
 												com::sun::star::sheet::MemberResult>* pSequences,
@@ -391,15 +415,19 @@
 class ScDPDataMember
 {
 private:
-	ScDPResultData*			pResultData;
+    const ScDPResultData*       pResultData;
 	const ScDPResultMember*		pResultMember;			//! Ref?
 	ScDPDataDimension*		pChildDimension;
 	ScDPAggData				aAggregate;
 
+#if USE_NEW_CODE
+    void                UpdateValues( const ::std::vector<ScDPValueData>& aValues, const ScDPSubTotalState& rSubState );
+#else	
 	void				UpdateValues( const ScDPValueData* pValues, const ScDPSubTotalState& rSubState );
+#endif    
 
 public:
-						ScDPDataMember( ScDPResultData* pData, const ScDPResultMember* pRes );
+                        ScDPDataMember( const ScDPResultData* pData, const ScDPResultMember* pRes );
 						~ScDPDataMember();
 
 	void				InitFrom( const ScDPResultDimension* pDim );
@@ -412,8 +440,13 @@
 
 	BOOL				HasHiddenDetails() const;
 
+#if USE_NEW_CODE
+    void                ProcessData( const ::std::vector<ScDPItemData>& aChildMembers, const ::std::vector<ScDPValueData>& aValues,
+                                     const ScDPSubTotalState& rSubState );
+#else	
 	void				ProcessData( const ScDPItemData* pChildMembers, const ScDPValueData* pValues,
 									const ScDPSubTotalState& rSubState );
+#endif    
 
 	BOOL				HasError( long nMeasure, const ScDPSubTotalState& rSubState ) const;
 	double				GetAggregate( long nMeasure, const ScDPSubTotalState& rSubState ) const;
@@ -462,7 +495,7 @@
 	typedef	std::hash_map <ScDPItemData, ScDPResultMember *, MemberHashFunc>	MemberHash;
 
 private:
-	ScDPResultData*			pResultData;
+    const ScDPResultData*   pResultData;
 	MemberArray				maMemberArray;
 	MemberHash				maMemberHash;
 	BOOL                    bInitialized;
@@ -479,16 +512,36 @@
 
 	ScDPResultMember* 		FindMember( const ScDPItemData& rData ) const;
 public:
-						ScDPResultDimension( ScDPResultData* pData );
+                        ScDPResultDimension( const ScDPResultData* pData );
 						~ScDPResultDimension();
 
+#if USE_NEW_CODE
+    void                InitFrom( const ::std::vector<ScDPDimension*>& ppDim, 
+                                  const ::std::vector<ScDPLevel*>& ppLev,
+                                  size_t nPos,
+                                  ScDPInitState& rInitState );
+    void                LateInitFrom( const ::std::vector<ScDPDimension*>& ppDim, 
+                                      const ::std::vector<ScDPLevel*>& ppLev, 
+                                      const ::std::vector<ScDPItemData>& pItemData,
+                                      size_t nPos,
+                                      ScDPInitState& rInitState );
+#else						
 						//	allocates new members
 	void				InitFrom( ScDPDimension** ppDim, ScDPLevel** ppLev, ScDPInitState& rInitState );
 	void				LateInitFrom( ScDPDimension** ppDim, ScDPLevel** ppLev, ScDPItemData* pItemData,
                                         ScDPInitState& rInitState );
+#endif                        
 
 	long				GetSize(long nMeasure) const;
 
+#if USE_NEW_CODE
+    bool                IsValidEntry( const ::std::vector<ScDPItemData>& aMembers ) const;
+						//	modifies existing members, allocates data dimensions
+	void				ProcessData( const ::std::vector<ScDPItemData>& aMembers,
+                                     const ScDPResultDimension* pDataDim,
+                                     const ::std::vector<ScDPItemData>& aDataMembers,
+                                     const ::std::vector<ScDPValueData>& aValues ) const;	//! Test
+#else	
 	BOOL				IsValidEntry( const ScDPItemData* pMembers ) const;
 
 						//	modifies existing members, allocates data dimensions
@@ -496,6 +549,7 @@
 										ScDPResultDimension* pDataDim,
 										const ScDPItemData* pDataMembers,
 										const ScDPValueData* pValues );	//! Test
+#endif    
 
 	void				FillMemberResults( com::sun::star::uno::Sequence<
 												com::sun::star::sheet::MemberResult>* pSequences,
@@ -554,18 +608,23 @@
 class ScDPDataDimension
 {
 private:
-	ScDPResultData*		pResultData;
+    const ScDPResultData*		pResultData;
 	const ScDPResultDimension* pResultDimension;  // column
 	ScDPDataMembers		aMembers;
 	BOOL				bIsDataLayout;		//! or ptr to IntDimension?
 
 public:
-						ScDPDataDimension( ScDPResultData* pData );
+                        ScDPDataDimension( const ScDPResultData* pData );
 						~ScDPDataDimension();
 
 	void				InitFrom( const ScDPResultDimension* pDim );		// recursive
+#if USE_NEW_CODE
+    void                ProcessData( const ::std::vector<ScDPItemData>& aDataMembers, const ::std::vector<ScDPValueData>& aValues,
+                                     const ScDPSubTotalState& rSubState );
+#else	
 	void				ProcessData( const ScDPItemData* pDataMembers, const ScDPValueData* pValues,
 									const ScDPSubTotalState& rSubState );
+#endif    
 
 	void				FillDataRow( const ScDPResultDimension* pRefDim,
 									com::sun::star::uno::Sequence<com::sun::star::sheet::DataResult>& rSequence,
Index: sc/inc/dptabsrc.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/dptabsrc.hxx,v
retrieving revision 1.8
retrieving revision 1.8.216.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.8 -r1.8.216.2
--- sc/inc/dptabsrc.hxx	25 Jan 2007 11:03:43 -0000	1.8
+++ sc/inc/dptabsrc.hxx	7 Nov 2007 03:12:54 -0000	1.8.216.2
@@ -93,6 +93,7 @@
 #ifndef _COM_SUN_STAR_UTIL_XREFRESHABLE_HPP_
 #include <com/sun/star/util/XRefreshable.hpp>
 #endif
+#include <com/sun/star/sheet/XDrillDownDataSupplier.hpp>
 #ifndef _COM_SUN_STAR_UTIL_XCLONEABLE_HPP_
 #include <com/sun/star/util/XCloneable.hpp>
 #endif
@@ -115,11 +116,21 @@
 #ifndef _CPPUHELPER_IMPLBASE5_HXX_
 #include <cppuhelper/implbase5.hxx>
 #endif
+#include <cppuhelper/implbase6.hxx>
 
 #ifndef SC_DPTABDAT_HXX
 #include "dptabdat.hxx"
 #endif
 
+namespace com { namespace sun { namespace star { 
+    namespace sheet {
+        struct DataPilotFieldFilter;
+    }
+    namespace table {
+        struct CellAddress;
+    }
+}}}
+
 class ScDPResultMember;
 class ScDPResultData;
 struct ScDPItemData;
@@ -148,14 +159,18 @@
 class ScDPMember;
 
 
-class ScDPSource : public cppu::WeakImplHelper5<
+class ScDPSource : public cppu::WeakImplHelper6<
 							com::sun::star::sheet::XDimensionsSupplier,
 							com::sun::star::sheet::XDataPilotResults,
 							com::sun::star::util::XRefreshable,
+                            com::sun::star::sheet::XDrillDownDataSupplier,
 							com::sun::star::beans::XPropertySet,
 							com::sun::star::lang::XServiceInfo >
 {
 private:
+    void FillCalcInfo(bool bIsRow, ScDPTableData::CalcInfo& rInfo, bool &bHasAutoShow);
+
+private:
 	ScDPTableData*			pData;				// data source
 	ScDPDimensions*			pDimensions;		// api objects
 												// settings:
@@ -182,7 +197,6 @@
 	com::sun::star::uno::Sequence<com::sun::star::sheet::MemberResult>* pRowResults;
 	List					aColLevelList;
 	List					aRowLevelList;
-	ScSubTotalFunc			eDataFunctions[SC_DAPI_MAXFIELDS];
 	BOOL					bResultOverflow;
 
 	void					CreateRes_Impl();
@@ -242,6 +256,12 @@
 									::com::sun::star::util::XRefreshListener >& l )
 								throw(::com::sun::star::uno::RuntimeException);
 
+                            // XDrillDownDataSupplier
+    virtual ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > > 
+        SAL_CALL getDrillDownData(const ::com::sun::star::uno::Sequence< 
+                                      ::com::sun::star::sheet::DataPilotFieldFilter >& aFilters )
+                                throw(::com::sun::star::uno::RuntimeException);
+
 							// XPropertySet
 	virtual ::com::sun::star::uno::Reference< ::com::sun::star::beans::XPropertySetInfo >
 							SAL_CALL getPropertySetInfo(  )
@@ -358,7 +378,7 @@
 {
 private:
 	ScDPSource*			pSource;
-	long				nDim;
+	long				nDim;               // dimension index (== column ID)
 	ScDPHierarchies*	pHierarchies;
 	long				nUsedHier;
 	USHORT				nFunction;			// enum GeneralFunction
Index: sc/source/core/data/dpcachetable.cxx
===================================================================
RCS file: sc/source/core/data/dpcachetable.cxx
diff -N sc/source/core/data/dpcachetable.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/core/data/dpcachetable.cxx	31 Oct 2007 19:58:43 -0000	1.1.2.4
@@ -0,0 +1,657 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: dpcachetable.cxx,v $
+ *
+ *  $Revision: 1.1.2.4 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/10/31 19:58:43 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "dpcachetable.hxx"
+#include "document.hxx"
+#include "address.hxx"
+#include "cell.hxx"
+#include "dptabdat.hxx"
+#include "dptabsrc.hxx"
+
+#include <stdio.h>
+
+#include <com/sun/star/sdbc/DataType.hpp>
+#include <com/sun/star/sdbc/XRow.hpp>
+#include <com/sun/star/sdbc/XRowSet.hpp>
+#include <com/sun/star/sdbc/XResultSetMetaData.hpp>
+#include <com/sun/star/sdbc/XResultSetMetaDataSupplier.hpp>
+#include <com/sun/star/util/Date.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+
+using namespace ::com::sun::star;
+
+using ::rtl::OUString;
+using ::std::vector;
+using ::std::set;
+using ::com::sun::star::uno::Exception;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::com::sun::star::sheet::DataPilotFieldFilter;
+
+static BOOL lcl_HasQueryEntry( const ScQueryParam& rParam )
+{
+    return rParam.GetEntryCount() > 0 &&
+            rParam.GetEntry(0).bDoQuery;
+}
+
+ScSharedStringTable::ScSharedStringTable() :
+    mnStrCount(0)
+{
+    // empty string (ID = 0)
+    maSharedStrings.push_back(String());
+    maSharedStringIds.insert( SharedStrMap::value_type(String(), mnStrCount++) );
+}
+
+ScSharedStringTable::~ScSharedStringTable()
+{
+}
+
+sal_Int32 ScSharedStringTable::insertString(const String& aStr)
+{
+    SharedStrMap::const_iterator itr = maSharedStringIds.find(aStr), 
+        itrEnd = maSharedStringIds.end();
+
+    if (itr == itrEnd)
+    {
+        // new string.
+        maSharedStrings.push_back(aStr);
+        maSharedStringIds.insert( SharedStrMap::value_type(aStr, mnStrCount) );
+        return mnStrCount++;
+    }
+
+    // existing string.
+    return itr->second;
+}
+
+sal_Int32 ScSharedStringTable::getStringId(const String& aStr)
+{
+    SharedStrMap::const_iterator itr = maSharedStringIds.find(aStr), 
+        itrEnd = maSharedStringIds.end();
+    if (itr == itrEnd)
+    {
+        // string not found.
+        return insertString(aStr);
+    }
+    return itr->second;
+}
+
+const String* ScSharedStringTable::getString(sal_Int32 nId) const
+{
+    if (nId >= mnStrCount)
+        return NULL;
+
+    return &maSharedStrings[nId];
+}
+
+// ----------------------------------------------------------------------------
+
+ScDPCacheTable::Cell::Cell() :
+    mfValue(0.0),
+    mbNumeric(false),
+    mnType(SC_VALTYPE_EMPTY)
+{
+}
+
+ScDPCacheTable::Filter::Filter()
+{
+}
+
+::osl::Mutex ScDPCacheTable::maStrMutex;
+ScSharedStringTable ScDPCacheTable::maStringTable;
+
+ScDPCacheTable::ScDPCacheTable()
+{
+}
+
+ScDPCacheTable::~ScDPCacheTable()
+{
+}
+
+sal_Int32 ScDPCacheTable::getHeaderSize() const
+{
+    return maHeader.size();
+}
+
+sal_Int32 ScDPCacheTable::getRowSize() const
+{
+    return maTable.size();
+}
+
+sal_Int32 ScDPCacheTable::getColSize() const
+{
+    return maTable.empty() ? 0 : maTable[0].size();
+}
+
+void ScDPCacheTable::fillTable(ScDocument* pDoc, const ScRange& rRange, const ScQueryParam& rQuery, BOOL* pSpecial)
+{
+    SCTAB nTab = rRange.aStart.Tab();
+    SCCOL nStartCol = rRange.aStart.Col();
+    SCROW nStartRow = rRange.aStart.Row();
+    SCCOL nColCount = rRange.aEnd.Col() - rRange.aStart.Col() + 1;
+    SCROW nRowCount = rRange.aEnd.Row() - rRange.aStart.Row() + 1;
+
+    if (nRowCount <= 1 || nColCount <= 0)
+        return;
+
+    maTable.clear();
+    maTable.reserve(nRowCount);
+    maHeader.clear();
+    maHeader.reserve(nColCount);
+    maRowsVisible.clear();
+    maRowsVisible.reserve(nRowCount);
+
+    // Header row
+    for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+    {
+        String aStr;
+        pDoc->GetString(nCol + nStartCol, nStartRow, nTab, aStr);
+        sal_Int32 nStrId = maStringTable.insertString(aStr);
+        maHeader.push_back(nStrId);
+    }
+
+    // Initialize field entries container.
+    maFieldEntries.clear();
+    maFieldEntries.reserve(nColCount);
+    for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+    {
+        TypedStrCollectionPtr p(new TypedStrCollection);
+        maFieldEntries.push_back(p);
+    }
+
+    // Data rows
+    for (SCROW nRow = 1; nRow < nRowCount; ++nRow)
+    {
+        if ( lcl_HasQueryEntry(rQuery) && !pDoc->ValidQuery(nRow + nStartRow, nTab, rQuery, pSpecial) )
+            // filtered out by standard filter.
+            continue;
+
+        // Insert a new row into cache table.
+        maRowsVisible.push_back(true);
+        maTable.push_back( vector<Cell>() );
+        maTable.back().reserve(nColCount);
+
+        for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+        {
+            maTable.back().push_back( ScDPCacheTable::Cell() );
+            Cell& rCell = maTable.back().back();
+                
+            String aStr;
+            pDoc->GetString(nStartCol + nCol, nStartRow + nRow, nTab, aStr);
+            rCell.mnStrId = maStringTable.insertString(aStr);
+            rCell.mnType = SC_VALTYPE_STRING;
+            rCell.mbNumeric = false;
+            ScAddress aPos(nStartCol + nCol, nStartRow + nRow, nTab);
+            getValueData(pDoc, aPos, rCell);
+
+            TypedStrData* pNew;
+            if (rCell.mbNumeric)
+                pNew = new TypedStrData(aStr, rCell.mfValue, SC_STRTYPE_VALUE);
+            else
+                pNew = new TypedStrData(aStr);
+
+            if (!maFieldEntries[nCol]->Insert(pNew))
+                delete pNew;
+        }
+    }
+}
+
+void lcl_GetCellValue(const Reference<sdbc::XRow>& xRow, sal_Int32 nType, long nCol,
+             const Date& rNullDate, ScDPCacheTable::Cell& rCell, String& rStr)
+{
+    short nNumType = NUMBERFORMAT_NUMBER;
+    BOOL bEmptyFlag = FALSE;
+    try
+    {
+        rStr = xRow->getString(nCol);
+        rCell.mnStrId = ScDPCacheTable::getStringId(rStr);
+        rCell.mnType = SC_VALTYPE_STRING;
+
+        switch (nType)
+        {
+            case sdbc::DataType::BIT:
+            case sdbc::DataType::BOOLEAN:
+            {
+                nNumType = NUMBERFORMAT_LOGICAL;
+                rCell.mfValue = xRow->getBoolean(nCol) ? 1 : 0;    
+                bEmptyFlag = (rCell.mfValue == 0.0 && xRow->wasNull());
+                rCell.mbNumeric = true;
+                rCell.mnType = SC_VALTYPE_VALUE;
+            }
+            break;
+
+            case sdbc::DataType::TINYINT:
+            case sdbc::DataType::SMALLINT:
+            case sdbc::DataType::INTEGER:
+            case sdbc::DataType::BIGINT:
+            case sdbc::DataType::FLOAT:
+            case sdbc::DataType::REAL:
+            case sdbc::DataType::DOUBLE:
+            case sdbc::DataType::NUMERIC:
+            case sdbc::DataType::DECIMAL:
+            {
+                //! do the conversion here?
+                rCell.mfValue = xRow->getDouble(nCol);
+                bEmptyFlag = (rCell.mfValue == 0.0 && xRow->wasNull());
+                rCell.mbNumeric = true;
+                rCell.mnType = SC_VALTYPE_VALUE;
+            }
+            break;
+
+            case sdbc::DataType::CHAR:
+            case sdbc::DataType::VARCHAR:
+            case sdbc::DataType::LONGVARCHAR:
+                bEmptyFlag = (rStr.Len() == 0 && xRow->wasNull());
+            break;
+
+            case sdbc::DataType::DATE:
+            {
+                nNumType = NUMBERFORMAT_DATE;
+
+                util::Date aDate = xRow->getDate(nCol);
+                rCell.mfValue = Date(aDate.Day, aDate.Month, aDate.Year) - rNullDate;
+                bEmptyFlag = xRow->wasNull();
+                rCell.mbNumeric = true;
+                rCell.mnType = SC_VALTYPE_VALUE;
+            }
+            break;
+
+                //! case sdbc::DataType::TIME:
+                //! case sdbc::DataType::TIMESTAMP:
+
+            case sdbc::DataType::SQLNULL:
+            case sdbc::DataType::BINARY:
+            case sdbc::DataType::VARBINARY:
+            case sdbc::DataType::LONGVARBINARY:
+            default:
+            break;
+        }
+    }
+    catch (uno::Exception&)
+    {
+    }
+}
+
+void ScDPCacheTable::fillTable(const Reference<sdbc::XRowSet>& xRowSet, const Date& rNullDate)
+{
+    if (!xRowSet.is())
+        // Dont' even waste time to go any further.
+        return;
+
+    try
+    {
+        Reference<sdbc::XResultSetMetaDataSupplier> xMetaSupp(xRowSet, UNO_QUERY_THROW);
+        Reference<sdbc::XResultSetMetaData> xMeta = xMetaSupp->getMetaData();
+        if (!xMeta.is())
+            return;
+
+        sal_Int32 nColCount = xMeta->getColumnCount();
+
+        // Get column titles and types.
+        vector<sal_Int32> aColTypes(nColCount);
+        maHeader.clear();
+        maHeader.reserve(nColCount);
+        for (sal_Int32 nCol = 0; nCol < nColCount; ++nCol)
+        {
+            String aColTitle = xMeta->getColumnLabel(nCol+1);
+            aColTypes[nCol]  = xMeta->getColumnType(nCol+1);
+            maHeader.push_back( ScDPCacheTable::getStringId(aColTitle) );
+        }
+
+        // Initialize field entries container.
+        maFieldEntries.clear();
+        maFieldEntries.reserve(nColCount);
+        for (SCCOL nCol = 0; nCol < nColCount; ++nCol)
+        {
+            TypedStrCollectionPtr p(new TypedStrCollection);
+            maFieldEntries.push_back(p);
+        }
+
+        // Now get the data rows.
+        Reference<sdbc::XRow> xRow(xRowSet, UNO_QUERY_THROW);
+        xRowSet->first();
+        maTable.clear();
+        maRowsVisible.clear();
+        do
+        {
+            maRowsVisible.push_back(true);
+            maTable.push_back( vector<Cell>() );
+            maTable.back().reserve(nColCount);
+            for (sal_Int32 nCol = 0; nCol < nColCount; ++nCol)
+            {
+                maTable.back().push_back( Cell() );
+                Cell& rCell = maTable.back().back();
+                String aStr;
+                lcl_GetCellValue(xRow, aColTypes[nCol], nCol+1, rNullDate, rCell, aStr);
+
+                TypedStrData* pNew;
+                if (rCell.mbNumeric)
+                    pNew = new TypedStrData(aStr, rCell.mfValue, SC_STRTYPE_VALUE);
+                else
+                    pNew = new TypedStrData(aStr);
+
+                if (!maFieldEntries[nCol]->Insert(pNew))
+                    delete pNew;
+            }
+        }
+        while (xRowSet->next());
+
+        xRowSet->beforeFirst();
+    }
+    catch (const Exception&)
+    {
+    }
+}
+
+bool ScDPCacheTable::isRowActive(sal_Int32 nRow) const
+{
+    if (nRow < 0 || nRow >= maRowsVisible.size())
+        // row index out of bound
+        return false;
+
+    return maRowsVisible[nRow];
+}
+
+void ScDPCacheTable::filterByPageDimension(const vector<ScDPDimension*>& rPageDims)
+{
+    sal_Int32 nRowSize = getRowSize();
+
+    if (nRowSize != static_cast<sal_Int32>(maRowsVisible.size()))
+    {
+        fprintf(stdout, "ScDPCacheTable::filterByPageDimension: the sizes of the two tables differ.\n");fflush(stdout);
+        return;
+    }
+
+    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+    {
+        maRowsVisible[nRow] = true;
+        const vector<Cell>& rRow = maTable[nRow];
+        vector<ScDPDimension*>::const_iterator itr = rPageDims.begin(), itrEnd = rPageDims.end();
+        for (; itr != itrEnd; ++itr)
+        {
+            ScDPDimension* pDim = *itr;
+            ScDPCacheTable::Cell aDimCell = getSelectedDimension(pDim);
+            
+            sal_Int32 nCol = pDim->GetDimension();
+            const Cell& rCell = rRow[nCol];
+            if (aDimCell.mnStrId != ScSharedStringTable::EMPTY && aDimCell.mnStrId != rCell.mnStrId)
+            {
+                // Selected page dimension value does not match the current value.  Skip it 
+                // (note: when the selected page dimension value is empty, '- all -' is 
+                // selected.
+                maRowsVisible[nRow] = false;
+                break;
+            }
+        }
+    }
+}
+
+const ::ScDPCacheTable::Cell* ScDPCacheTable::getCell(SCCOL nCol, SCROW nRow) const
+{
+    if ( nRow >= static_cast<SCROW>(maTable.size()) )
+        return NULL;
+
+    const vector<Cell>& rRow = maTable.at(nRow);
+    if ( nCol < 0 || static_cast<size_t>(nCol) >= rRow.size() )
+        return NULL;
+
+    return &rRow.at(nCol);
+}
+
+const String* ScDPCacheTable::getFieldName(sal_Int32 nIndex) const
+{
+    if (nIndex >= static_cast<sal_Int32>(maHeader.size()))
+        return NULL;
+
+    return getString(maHeader[nIndex]);
+}
+
+sal_Int32 ScDPCacheTable::getFieldIndex(const String& rStr) const
+{
+    sal_Int32 nStrId = getStringId(rStr);
+    if (nStrId < 0)
+        // string not found.
+        return nStrId;
+
+    sal_Int32 n = maHeader.size();
+    for (sal_Int32 i = 0; i < n; ++i)
+    {
+        if (maHeader[i] == nStrId)
+            return i;
+    }
+
+    return -1;
+}
+
+const TypedStrCollection& ScDPCacheTable::getFieldEntries(sal_Int32 nIndex) const
+{
+    if (nIndex < 0 || nIndex >= maFieldEntries.size())
+    {
+        fprintf(stdout, "ScDPCacheTable::getFieldEntries: OUT OF BOUND\n");fflush(stdout);
+        // index out of bound.  Hopefully this code will never be reached.
+        static const TypedStrCollection emptyCollection;
+        return emptyCollection;
+    }
+
+    return *maFieldEntries[nIndex].get();
+}
+
+void ScDPCacheTable::filterTable(const Sequence<DataPilotFieldFilter>& rFilters, 
+                                 Sequence< Sequence<Any> >& rTabData)
+{
+    sal_Int32 nRowSize = getRowSize();
+    sal_Int32 nColSize = getColSize();
+
+    if (!nRowSize)
+        // no data to filter.
+        return;
+
+    // Convert filters first.
+    vector<Filter> filters;
+    sal_Int32 nFilterSize = rFilters.getLength();
+    filters.reserve(nFilterSize);
+    for (sal_Int32 i = 0; i < nFilterSize; ++i)
+    {
+        Filter fil;
+        fil.mnFieldIndex = getFieldIndex(String(rFilters[i].FieldName));
+        fil.mnMatchStrId = getStringId(String(rFilters[i].MatchValue));
+        if (fil.mnFieldIndex >= 0)
+            filters.push_back(fil);
+    }
+    
+    // Row first, then column.
+    vector< Sequence<Any> > tableData;
+    tableData.reserve(nRowSize+1);
+
+    // Header first.
+    Sequence<Any> headerRow(nColSize);
+    for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+    {
+        OUString str;
+        const String* pStr = getString(maHeader[nCol]);
+        if (pStr)
+            str = *pStr;
+
+        Any any;
+        any <<= str;
+        headerRow[nCol] = any;
+    }
+    tableData.push_back(headerRow);
+
+    // Data rows.
+    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+    {
+        if (!maRowsVisible[nRow])
+            // This row is filtered out.
+            continue;
+
+        bool bRetainRow = true;
+        vector<Filter>::const_iterator itr, itrEnd = filters.end();
+        for (itr = filters.begin(); itr != itrEnd; ++itr)
+        {
+            if (itr->mnFieldIndex >= nColSize)
+            {
+                // specified field is outside the source data columns.
+                bRetainRow = false;
+                break;
+            }
+
+            if ( maTable[nRow][itr->mnFieldIndex].mnStrId != itr->mnMatchStrId )
+            {
+                // The string value does not match.
+                bRetainRow = false;
+                break;
+            }
+        }
+
+        if (bRetainRow)
+        {
+            Sequence<Any> row(nColSize);
+            for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+            {
+                Any any;
+                const Cell& rCell = maTable[nRow][nCol];
+                if (rCell.mbNumeric)
+                    any <<= rCell.mfValue;
+                else
+                {
+                    OUString str;
+                    const String* pStr = getString(rCell.mnStrId);
+                    if (pStr)
+                        str = *pStr;
+                    any <<= str;
+                }
+                row[nCol] = any;
+            }
+            tableData.push_back(row);
+        }
+    }
+
+    // convert vector to Seqeunce
+    sal_Int32 nTabSize = static_cast<sal_Int32>(tableData.size());
+    rTabData.realloc(nTabSize);
+    for (sal_Int32 i = 0; i < nTabSize; ++i)
+        rTabData[i] = tableData[i];
+}
+
+void ScDPCacheTable::clear()
+{
+    maTable.clear();
+    maHeader.clear();
+    maFieldEntries.clear();
+    maRowsVisible.clear();
+}
+
+void ScDPCacheTable::swap(ScDPCacheTable& rOther)
+{
+    maTable.swap(rOther.maTable);
+    maHeader.swap(rOther.maHeader);
+    maFieldEntries.swap(rOther.maFieldEntries);
+    maRowsVisible.swap(rOther.maRowsVisible);
+}
+
+bool ScDPCacheTable::empty() const
+{
+    return maTable.empty();
+}
+
+void ScDPCacheTable::getValueData(ScDocument* pDoc, const ScAddress& rPos, Cell& rCell)
+{
+    ScBaseCell* pCell = pDoc->GetCell(rPos);
+    if (!pCell)
+    {
+        rCell.mnType = SC_VALTYPE_EMPTY;
+        return;
+    }
+
+    CellType eType = pCell->GetCellType();
+    if (eType == CELLTYPE_NOTE)
+    {
+        // note cell
+        rCell.mnType = SC_VALTYPE_EMPTY;
+        return;
+    }
+
+    if (eType == CELLTYPE_FORMULA && static_cast<ScFormulaCell*>(pCell)->GetErrCode())
+    {
+        // formula cell with error
+        rCell.mnType = SC_VALTYPE_ERROR;
+        return;
+    }
+
+    if ( pCell->HasValueData() )
+    {
+        if (eType == CELLTYPE_VALUE)
+            // value cell
+            rCell.mfValue = static_cast<ScValueCell*>(pCell)->GetValue();
+        else if (eType == CELLTYPE_FORMULA)
+            // formula cell
+            rCell.mfValue = static_cast<ScFormulaCell*>(pCell)->GetValue();
+
+        rCell.mbNumeric = true;
+        rCell.mnType = SC_VALTYPE_VALUE;
+    }
+}
+
+ScDPCacheTable::Cell ScDPCacheTable::getSelectedDimension(ScDPDimension* pDim) const
+{
+    const ScDPItemData& rData = pDim->GetSelectedData();
+    Cell aCell;
+    aCell.mfValue = rData.fValue;
+    aCell.mbNumeric = rData.bHasValue;
+    aCell.mnStrId = getStringId(rData.aString);
+    return aCell;
+}
+
+// static 
+sal_Int32 ScDPCacheTable::insertString(const String& aStr)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.insertString(aStr);
+}
+
+const String* ScDPCacheTable::getString(sal_Int32 nId)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.getString(nId);
+}
+
+sal_Int32 ScDPCacheTable::getStringId(const String& aStr)
+{
+    ::osl::MutexGuard aGuard(maStrMutex);
+    return maStringTable.getStringId(aStr);
+}
Index: sc/source/core/data/dpgroup.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpgroup.cxx,v
retrieving revision 1.7
retrieving revision 1.7.202.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.7 -r1.7.202.1
--- sc/source/core/data/dpgroup.cxx	27 Feb 2007 12:03:31 -0000	1.7
+++ sc/source/core/data/dpgroup.cxx	29 Oct 2007 17:44:40 -0000	1.7.202.1
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -51,10 +51,24 @@
 #include "collect.hxx"
 #include "global.hxx"
 #include "document.hxx"
+#include "dpcachetable.hxx"
+#include "dptabsrc.hxx"
+#include "dptabres.hxx"
 
-#ifndef _COM_SUN_STAR_SHEET_DATAPILOTFIELDGROUPBY_HPP_
 #include <com/sun/star/sheet/DataPilotFieldGroupBy.hpp>
-#endif
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+
+#include <vector>
+
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::UNO_QUERY_THROW;
+using ::rtl::OUString;
+
+using ::std::vector;
 
 #define D_TIMEFACTOR              86400.0
 
@@ -840,6 +854,7 @@
     ScDPGroupDimension aNewGroup( rGroup );
     aNewGroup.SetGroupDim( GetColumnCount() );      // new dimension will be at the end
     aGroups.push_back( aNewGroup );
+    aGroupNames.insert( OUString(aNewGroup.GetName()) );
 }
 
 void ScDPGroupTableData::SetNumGroupDimension( long nIndex, const ScDPNumGroupDimension& rGroup )
@@ -972,10 +987,106 @@
     pSourceData->SetEmptyFlags( bIgnoreEmptyRows, bRepeatIfEmpty );
 }
 
+void ScDPGroupTableData::CreateCacheTable()
+{
+    pSourceData->CreateCacheTable();
+}
+
+void ScDPGroupTableData::FilterCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+    pSourceData->FilterCacheTable(rPageDims);
+}
+
+void ScDPGroupTableData::GetDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& aFilters, Sequence< Sequence<Any> >& rTabData)
+{
+    // Go through the field names and skip group name(s) if any.
+    vector<sheet::DataPilotFieldFilter> filters;
+    sal_Int32 nOrigSize = aFilters.getLength();
+    filters.reserve(nOrigSize);
+    StringHashSet::const_iterator itrEnd = aGroupNames.end();
+    for (sal_Int32 i = 0; i < nOrigSize; ++i)
+    {
+        if (aGroupNames.find(aFilters[i].FieldName) == itrEnd)
+            filters.push_back(aFilters[i]);
+    }
+
+    // Convert vector to Sequence.
+    size_t nSize = filters.size();
+    Sequence<sheet::DataPilotFieldFilter> filters2(nSize);
+    for (size_t i = 0; i < nSize; ++i)
+        filters2[i] = filters[i];
+
+    pSourceData->GetDrillDownData(filters2, rTabData);
+}
+
+void ScDPGroupTableData::CalcResults(CalcInfo& rInfo, bool bAutoShow)
+{
+    // This CalcInfo instance is used only to retrive data from the original
+    // data source.
+    CalcInfo aInfoSrc = rInfo;
+    CopyFields(rInfo.aColLevelDims, aInfoSrc.aColLevelDims);
+    CopyFields(rInfo.aRowLevelDims, aInfoSrc.aRowLevelDims);
+    CopyFields(rInfo.aPageDims,     aInfoSrc.aPageDims);
+    CopyFields(rInfo.aDataSrcCols,  aInfoSrc.aDataSrcCols);
+
+    const ScDPCacheTable& rCacheTable = pSourceData->GetCacheTable();
+    sal_Int32 nRowSize = rCacheTable.getRowSize();
+    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+    {
+        if (!rCacheTable.isRowActive(nRow))
+            continue;
+
+        CalcRowData aData;
+        FillRowDataFromCacheTable(nRow, rCacheTable, aInfoSrc, aData);
+
+        FillGroupValues(&aData.aColData[0], rInfo.aColLevelDims.size(), &rInfo.aColLevelDims[0]);
+        FillGroupValues(&aData.aRowData[0], rInfo.aRowLevelDims.size(), &rInfo.aRowLevelDims[0]);
+        FillGroupValues(&aData.aPageData[0], rInfo.aPageDims.size(), &rInfo.aPageDims[0]);
+
+        ProcessRowData(rInfo, aData, bAutoShow);
+    }
+}
+
+const ScDPCacheTable& ScDPGroupTableData::GetCacheTable() const
+{
+    return pSourceData->GetCacheTable();
+}
+
+#if not USE_NEW_CODE
 void ScDPGroupTableData::ResetIterator()
 {
     pSourceData->ResetIterator();
 }
+#endif
+
+void ScDPGroupTableData::CopyFields(const vector<long>& rFieldDims, vector<long>& rNewFieldDims)
+{
+    size_t nCount = rFieldDims.size();
+    if (!nCount)
+        return;
+
+    long nGroupedColumns = aGroups.size();
+
+    rNewFieldDims.clear();
+    rNewFieldDims.reserve(nCount);
+    for (long i = 0; i < nCount; ++i)
+    {
+        if ( rFieldDims[i] >= nSourceCount )
+        {
+            if ( rFieldDims[i] == nSourceCount + nGroupedColumns )
+                // data layout in source
+                rNewFieldDims.push_back(nSourceCount);
+            else
+            {
+                // original dimension
+                long n = rFieldDims[i] - nSourceCount;
+                rNewFieldDims.push_back(aGroups[n].GetSourceDim());
+            }
+        }
+        else
+            rNewFieldDims.push_back(rFieldDims[i]);
+    }
+}
 
 long* ScDPGroupTableData::CopyFields( const long* pSourceDims, long nCount )
 {
@@ -1055,6 +1166,7 @@
     }
 }
 
+#if not USE_NEW_CODE
 BOOL ScDPGroupTableData::GetNextRow( const ScDPTableIteratorParam& rParam )
 {
     //
@@ -1090,6 +1202,7 @@
 
     return bRet;
 }
+#endif
 
 BOOL ScDPGroupTableData::IsBaseForGroup(long nDim) const
 {
Index: sc/source/core/data/dpobject.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpobject.cxx,v
retrieving revision 1.21
retrieving revision 1.21.112.5
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 -r1.21.112.5
--- sc/source/core/data/dpobject.cxx	27 Jun 2007 13:43:19 -0000	1.21
+++ sc/source/core/data/dpobject.cxx	9 Nov 2007 02:12:09 -0000	1.21.112.5
@@ -62,18 +62,29 @@
 #include "unonames.hxx"
 
 #include <com/sun/star/sheet/GeneralFunction.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 #include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
 #include <com/sun/star/sheet/DataPilotFieldReferenceType.hpp>
+#include <com/sun/star/sheet/DataPilotTablePositionData.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
 #include <com/sun/star/lang/XSingleServiceFactory.hpp>
 #include <com/sun/star/lang/XInitialization.hpp>
 #include <com/sun/star/container/XContentEnumerationAccess.hpp>
+#include <com/sun/star/sheet/XDrillDownDataSupplier.hpp>
 
 #include <comphelper/processfactory.hxx>
 #include <tools/debug.hxx>
 #include <svtools/zforlist.hxx>		// IsNumberFormat
 
+#include <vector>
+
 using namespace com::sun::star;
+using ::std::vector;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::sheet::DataPilotTablePositionData;
 
 // -----------------------------------------------------------------------
 
@@ -478,6 +489,16 @@
 	aOutRange = pOutput->GetOutputRange();
 }
 
+const ScRange ScDPObject::GetOutputRangeByType( sal_Int32 nType )
+{
+    CreateOutput();
+
+    if (pOutput->HasError())
+        return ScRange(aOutRange.aStart);
+
+    return pOutput->GetOutputRange(nType);
+}
+
 BOOL lcl_HasButton( ScDocument* pDoc, SCCOL nCol, SCROW nRow, SCTAB nTab )
 {
 	return ((const ScMergeFlagAttr*)pDoc->GetAttr( nCol, nRow, nTab, ATTR_MERGE_FLAG ))->HasButton();
@@ -601,6 +622,44 @@
 		r.SetSheetDesc( *pSheetDesc );
 }
 
+void ScDPObject::GetPositionData(const ScAddress& rPos, DataPilotTablePositionData& rPosData)
+{
+    CreateOutput();
+    pOutput->GetPositionData(rPos, rPosData);
+}
+
+bool ScDPObject::GetDataFieldPositionData(
+    const ScAddress& rPos, Sequence<sheet::DataPilotFieldFilter>& rFilters)
+{
+    CreateOutput();
+
+    vector<sheet::DataPilotFieldFilter> aFilters;
+    if (!pOutput->GetDataResultPositionData(aFilters, rPos))
+        return false;
+
+    sal_Int32 n = static_cast<sal_Int32>(aFilters.size());
+    rFilters.realloc(n);
+    for (sal_Int32 i = 0; i < n; ++i)
+        rFilters[i] = aFilters[i];
+
+    return true;
+}
+
+void ScDPObject::GetDrillDownData(const ScAddress& rPos, Sequence< Sequence<Any> >& rTableData)
+{
+    CreateOutput();
+
+    Reference<sheet::XDrillDownDataSupplier> xDrillDownData(xSource, UNO_QUERY);
+    if (!xDrillDownData.is())
+        return;
+
+    Sequence<sheet::DataPilotFieldFilter> filters;
+    if (!GetDataFieldPositionData(rPos, filters))
+        return;
+
+    rTableData = xDrillDownData->getDrillDownData(filters);
+}
+
 BOOL ScDPObject::IsDimNameInUse( const String& rName ) const
 {
 	if ( xSource.is() )
Index: sc/source/core/data/dpoutput.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpoutput.cxx,v
retrieving revision 1.15
retrieving revision 1.15.112.5
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.15 -r1.15.112.5
--- sc/source/core/data/dpoutput.cxx	27 Jun 2007 13:43:33 -0000	1.15
+++ sc/source/core/data/dpoutput.cxx	19 Nov 2007 22:22:55 -0000	1.15.112.5
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -48,6 +48,8 @@
 #include <unotools/transliterationwrapper.hxx>
 
 #include "dpoutput.hxx"
+#include "dptabsrc.hxx"
+#include "dpcachetable.hxx"
 #include "document.hxx"
 #include "patattr.hxx"
 #include "docpool.hxx"
@@ -60,6 +62,7 @@
 #include "stlsheet.hxx"
 #include "collect.hxx"
 #include "scresid.hxx"
+#include "unonames.hxx"
 #include "sc.hrc"
 
 #include <com/sun/star/sheet/XLevelsSupplier.hpp>
@@ -68,12 +71,26 @@
 #include <com/sun/star/sheet/XDataPilotMemberResults.hpp>
 #include <com/sun/star/sheet/DataResultFlags.hpp>
 #include <com/sun/star/sheet/MemberResultFlags.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 #include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
+#include <com/sun/star/sheet/DataPilotTablePositionData.hpp>
+#include <com/sun/star/sheet/DataPilotTableResultData.hpp>
+#include <com/sun/star/sheet/DataPilotTablePositionType.hpp>
 #include <com/sun/star/sheet/TableFilterField.hpp>
 #include <com/sun/star/sheet/GeneralFunction.hpp>
 #include <com/sun/star/container/XNamed.hpp>
 
+#include <vector>
+
 using namespace com::sun::star;
+using ::std::vector;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::UNO_QUERY;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::sheet::DataPilotTablePositionData;
+using ::com::sun::star::sheet::DataPilotTableResultData;
+using ::com::sun::star::uno::makeAny;
+using ::com::sun::star::uno::Any;
 
 // -----------------------------------------------------------------------
 
@@ -701,6 +718,29 @@
 	}
 }
 
+sal_Int32 ScDPOutput::GetPositionType(const ScAddress& rPos)
+{
+    using namespace ::com::sun::star::sheet;
+
+    SCCOL nCol = rPos.Col();
+    SCROW nRow = rPos.Row();
+    SCTAB nTab = rPos.Tab();
+    if ( nTab != aStartPos.Tab() )
+        return DataPilotTablePositionType::NOT_IN_TABLE;
+
+    CalcSizes();
+
+    // test for result data area.
+    if (nCol >= nDataStartCol && nCol <= nTabEndCol && nRow >= nDataStartRow && nRow <= nTabEndRow)
+    {
+        return DataPilotTablePositionType::RESULT;
+    }
+
+    // TODO (kohei): Add more position type detection.
+
+    return DataPilotTablePositionType::NOT_IN_TABLE;
+}
+
 void ScDPOutput::Output()
 {
 	long nField;
@@ -861,12 +901,29 @@
 	lcl_SetFrame( pDoc,nTab, nTabStartCol,nTabStartRow, nTabEndCol,nTabEndRow, 40 );
 }
 
-ScRange ScDPOutput::GetOutputRange()
+ScRange ScDPOutput::GetOutputRange( sal_Int32 nRegionType )
 {
+    using namespace ::com::sun::star::sheet;
+
 	CalcSizes();
 
+//  fprintf(stdout, "ScDPOutput::GetOutputRange: nTabStart (Row = %ld, Col = %ld)\n", nTabStartRow, nTabStartCol);fflush(stdout);
+//  fprintf(stdout, "ScDPOutput::GetOutputRange: nMemberStart (Row = %ld, Col = %ld)\n", nMemberStartRow, nMemberStartCol);fflush(stdout);
+//  fprintf(stdout, "ScDPOutput::GetOutputRange: nDataStart (Row = %ld, Col = %ld)\n", nDataStartRow, nDataStartCol);fflush(stdout);
+//  fprintf(stdout, "ScDPOutput::GetOutputRange: nTabEnd (Row = %ld, Col = %ld)\n", nTabEndRow, nTabStartCol);fflush(stdout);
+
 	SCTAB nTab = aStartPos.Tab();
-	return ScRange( aStartPos.Col(), aStartPos.Row(), nTab, nTabEndCol, nTabEndRow, nTab);
+    switch (nRegionType)
+    {
+        case DataPilotTableRegion::RESULT:
+            return ScRange(nDataStartCol, nDataStartRow, nTab, nTabEndCol, nTabEndRow, nTab);
+        case DataPilotTableRegion::TABLE:
+            return ScRange(aStartPos.Col(), nTabStartRow, nTab, nTabEndCol, nTabEndRow, nTab);
+        default:
+            DBG_ASSERT(nRegionType == DataPilotTableRegion::WHOLE, "ScDPOutput::GetOutputRange: unknown region type");
+        break;
+    }
+    return ScRange(aStartPos.Col(), aStartPos.Row(), nTab, nTabEndCol, nTabEndRow, nTab);
 }
 
 BOOL ScDPOutput::HasError()
@@ -995,6 +1052,119 @@
 	}
 }
 
+void ScDPOutput::GetPositionData(const ScAddress& rPos, DataPilotTablePositionData& rPosData)
+{
+    using namespace ::com::sun::star::sheet;
+
+	SCCOL nCol = rPos.Col();
+	SCROW nRow = rPos.Row();
+	SCTAB nTab = rPos.Tab();
+	if ( nTab != aStartPos.Tab() )
+		return;										// wrong sheet
+
+	//	calculate output positions and sizes
+
+	CalcSizes();
+
+    rPosData.PositionType = GetPositionType(rPos);
+    switch (rPosData.PositionType)
+    {
+        case DataPilotTablePositionType::RESULT:
+        {
+            vector<DataPilotFieldFilter> aFilters;
+            GetDataResultPositionData(aFilters, rPos);
+            sal_Int32 nSize = aFilters.size();
+    
+            DataPilotTableResultData aResData;
+            aResData.FieldFilters.realloc(nSize);
+            for (sal_Int32 i = 0; i < nSize; ++i)
+                aResData.FieldFilters[i] = aFilters[i];
+    
+            aResData.DataFieldIndex = 0;
+            Reference<beans::XPropertySet> xPropSet(xSource, UNO_QUERY);
+            if (xPropSet.is())
+            {
+                sal_Int32 nDataFieldCount;
+                Any any = xPropSet->getPropertyValue(rtl::OUString::createFromAscii("DataFieldCount"));
+                if (any >>= nDataFieldCount)
+                    aResData.DataFieldIndex = (nRow - nDataStartRow) % nDataFieldCount;
+            }
+
+            // Copy appropriate DataResult object from the cached sheet::DataResult table.
+            if (aData.getLength() > nRow - nDataStartRow && 
+                aData[nRow-nDataStartRow].getLength() > nCol-nDataStartCol)
+                aResData.Result = aData[nRow-nDataStartRow][nCol-nDataStartCol];
+    
+            rPosData.PositionData = makeAny(aResData);
+            return;
+        }
+    }
+}
+
+bool ScDPOutput::GetDataResultPositionData(vector<sheet::DataPilotFieldFilter>& rFilters, const ScAddress& rPos)
+{
+    SCCOL nCol = rPos.Col();
+    SCROW nRow = rPos.Row();
+    SCTAB nTab = rPos.Tab();
+    if ( nTab != aStartPos.Tab() )
+        return false;                                     // wrong sheet
+
+    CalcSizes();
+
+    // test for data area.
+    if (nCol < nDataStartCol || nCol > nTabEndCol || nRow < nDataStartRow || nRow > nTabEndRow)
+    {
+        // Cell is outside the data field area.
+        return false;
+    }
+
+    // column fields
+    for (SCCOL nColField = 0; nColField < nColFieldCount; ++nColField)
+    {
+        sheet::DataPilotFieldFilter filter;
+        filter.FieldName = pColFields[nColField].aCaption;
+
+        const uno::Sequence<sheet::MemberResult> rSequence = pColFields[nColField].aResult;
+        long nThisColCount = rSequence.getLength();
+        const sheet::MemberResult* pArray = rSequence.getConstArray();
+
+        DBG_ASSERT(nDataStartCol + nThisColCount - 1 == nTabEndCol, "ScDPOutput::GetDataFieldCellData: error in geometric assumption");
+
+        long nItem = nCol - nDataStartCol;
+                //	get origin of "continue" fields
+        while ( nItem > 0 && (pArray[nItem].Flags & sheet::MemberResultFlags::CONTINUE) )
+            --nItem;
+
+        filter.MatchValue = pArray[nItem].Name;
+        if (pArray[nItem].Name.getLength() > 0 && !pArray[nItem].Name.equalsAscii("Total"))
+            rFilters.push_back(filter);
+    }
+
+    // row fields
+    for (SCROW nRowField = 0; nRowField < nRowFieldCount; ++nRowField)
+    {
+        sheet::DataPilotFieldFilter filter;
+        filter.FieldName = pRowFields[nRowField].aCaption;
+
+        const uno::Sequence<sheet::MemberResult> rSequence = pRowFields[nRowField].aResult;
+        long nThisRowCount = rSequence.getLength();
+        const sheet::MemberResult* pArray = rSequence.getConstArray();
+
+        DBG_ASSERT(nDataStartRow + nThisRowCount - 1 == nTabEndRow, "ScDPOutput::GetDataFieldCellData: error in geometric assumption");
+
+        long nItem = nRow - nDataStartRow;
+			//	get origin of "continue" fields
+        while ( nItem > 0 && (pArray[nItem].Flags & sheet::MemberResultFlags::CONTINUE) )
+            --nItem;
+
+        filter.MatchValue = pArray[nItem].Name;
+        if (pArray[nItem].Name.getLength() > 0 && !pArray[nItem].Name.equalsAscii("Total"))
+            rFilters.push_back(filter);
+    }
+
+    return true;
+}
+
 //
 //  helper functions for ScDPOutput::GetPivotData
 //
Index: sc/source/core/data/dpsdbtab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpsdbtab.cxx,v
retrieving revision 1.12
retrieving revision 1.12.202.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 -r1.12.202.1
--- sc/source/core/data/dpsdbtab.cxx	27 Feb 2007 12:04:37 -0000	1.12
+++ sc/source/core/data/dpsdbtab.cxx	29 Oct 2007 17:44:40 -0000	1.12.202.1
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE --------------------------------------------------------------
 
@@ -55,14 +55,24 @@
 #include <com/sun/star/sdbc/XRowSet.hpp>
 #include <com/sun/star/sdbc/XResultSetMetaDataSupplier.hpp>
 #include <com/sun/star/lang/XMultiServiceFactory.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 
 #include "dpsdbtab.hxx"
 #include "collect.hxx"
 #include "global.hxx"
 #include "globstr.hrc"
+#include "dpcachetable.hxx"
+#include "dptabres.hxx"
 
 using namespace com::sun::star;
 
+using ::std::vector;
+using ::std::set;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::UNO_QUERY;
+
 #define SC_SERVICE_ROWSET			"com.sun.star.sdb.RowSet"
 #define SC_SERVICE_INTHANDLER		"com.sun.star.sdb.InteractionHandler"
 
@@ -79,14 +89,15 @@
 	::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory > xServiceManager;
 	ScImportSourceDesc	aDesc;
 	long				nColCount;
-	BOOL				bValid;
+#if not USE_NEW_CODE	
 	BOOL				bAtStart;
-	String*				pTitles;
-	TypedStrCollection** ppStrings;
+#endif    
 	uno::Reference<sdbc::XRowSet> xRowSet;
 	sal_Int32*			pTypes;
 	SvNumberFormatter*	pFormatter;
 
+    ScDPCacheTable      aCacheTable;
+
 	ScDatabaseDPData_Impl() {}
 };
 
@@ -100,14 +111,14 @@
 	pImpl->xServiceManager = xSMgr;
 	pImpl->aDesc = rImport;
 	pImpl->nColCount = 0;
-	pImpl->bValid = FALSE;
+#if not USE_NEW_CODE    
 	pImpl->bAtStart = FALSE;
-	pImpl->pTitles = NULL;
-	pImpl->ppStrings = NULL;
+#endif    
 	pImpl->pTypes = NULL;
 	pImpl->pFormatter = NULL;		// created on demand
 
 	OpenDatabase();
+    CreateCacheTable();
 }
 
 ScDatabaseDPData::~ScDatabaseDPData()
@@ -115,13 +126,6 @@
 	::comphelper::disposeComponent( pImpl->xRowSet );
 
 	delete[] pImpl->pTypes;
-	if ( pImpl->ppStrings )
-	{
-		for (long i=0; i<pImpl->nColCount; i++)
-			delete pImpl->ppStrings[i];
-		delete[] pImpl->ppStrings;
-	}
-	delete[] pImpl->pTitles;
 	delete pImpl->pFormatter;		// NumberFormatter is local for this object
 	delete pImpl;
 }
@@ -129,21 +133,6 @@
 void ScDatabaseDPData::DisposeData()
 {
 	//!	use OpenDatabase here?
-
-	//!	column titles ???
-
-	//	collections for column entries
-	if ( pImpl->ppStrings )
-	{
-		for (long i=0; i<pImpl->nColCount; i++)
-		{
-			delete pImpl->ppStrings[i];
-			pImpl->ppStrings[i] = NULL;
-		}
-	}
-
-	//!	init entries on demand!
-	InitAllColumnEntries();				//! configurable ???
 }
 
 BOOL ScDatabaseDPData::OpenDatabase()
@@ -199,7 +188,9 @@
 			else
 				pImpl->xRowSet->execute();
 
+#if not USE_NEW_CODE            
 			pImpl->bAtStart = TRUE;
+#endif            
 
 			//
 			//	get column descriptions
@@ -216,22 +207,9 @@
 			uno::Reference<sdbc::XResultSet> xResSet( pImpl->xRowSet, uno::UNO_QUERY );
 			if ( pImpl->nColCount > 0 && xResSet.is() )
 			{
-				//	get column titles
-				pImpl->pTitles = new String[pImpl->nColCount];
 				pImpl->pTypes = new sal_Int32[pImpl->nColCount];
 				for (long nCol=0; nCol<pImpl->nColCount; nCol++)
-				{
-					pImpl->pTitles[nCol] = xMeta->getColumnLabel( nCol+1 );
 					pImpl->pTypes[nCol]  = xMeta->getColumnType( nCol+1 );
-				}
-
-				//	collections for column entries
-				pImpl->ppStrings = new TypedStrCollection*[pImpl->nColCount];
-				for (long i=0; i<pImpl->nColCount; i++)
-					pImpl->ppStrings[i] = NULL;
-
-				//!	init entries on demand!
-				InitAllColumnEntries();				//! configurable ???
 
 				bSuccess = TRUE;
 			}
@@ -252,7 +230,6 @@
 	if (!bSuccess)
 		::comphelper::disposeComponent( pImpl->xRowSet );
 
-	pImpl->bValid = bSuccess;
 	return bSuccess;
 }
 
@@ -261,6 +238,7 @@
 	return pImpl->nColCount;
 }
 
+#if not USE_NEW_CODE
 void lcl_FillItemData( ScDPItemData& rData,
 						const uno::Reference<sdbc::XRow>& xRow, long nRowPos,
 						long nType, BOOL bStringForVal, ScDatabaseDPData_Impl* pImpl )
@@ -357,6 +335,7 @@
 		pImpl->pFormatter->GetInputLineString( rData.fValue, nIndex, rData.aString );
 	}
 }
+#endif
 
 void lcl_Reset( const uno::Reference<sdbc::XRowSet>& xRowSet )
 					throw(sdbc::SQLException, uno::RuntimeException)
@@ -367,104 +346,9 @@
 	xRowSet->execute();		// restart
 }
 
-void ScDatabaseDPData::InitAllColumnEntries()
-{
-	DBG_ASSERT( pImpl->ppStrings, "GetColumnEntries: no entries" );
-	long nCol;
-	for ( nCol=0; nCol<pImpl->nColCount; nCol++ )
-		if (!pImpl->ppStrings[nCol])
-			pImpl->ppStrings[nCol] = new TypedStrCollection;
-
-//	Sound::Beep();		//! Test !!!
-
-	uno::Reference<sdbc::XRowSet> xRowSet = pImpl->xRowSet;
-	uno::Reference<sdbc::XRow> xRow( xRowSet, uno::UNO_QUERY );
-	if ( xRow.is() )
-	{
-		ScDPItemData aItemData;
-
-		try
-		{
-			if ( !pImpl->bAtStart )
-				lcl_Reset( xRowSet );
-
-			pImpl->bAtStart = FALSE;
-			while ( xRowSet->next() )
-			{
-				for ( nCol=0; nCol<pImpl->nColCount; nCol++ )
-				{
-					//!	get string for value data only if value hasn't been inserted yet
-					lcl_FillItemData( aItemData, xRow, nCol+1, pImpl->pTypes[nCol], TRUE, pImpl );
-					TypedStrData* pNew = new TypedStrData(
-							aItemData.aString, aItemData.fValue,
-							aItemData.bHasValue ? SC_STRTYPE_VALUE : SC_STRTYPE_STANDARD );
-					if (!pImpl->ppStrings[nCol]->Insert(pNew))
-						delete pNew;
-				}
-			}
-		}
-		catch ( sdbc::SQLException& rError )
-		{
-			//!	store error message
-			InfoBox aInfoBox( 0, String(rError.Message) );
-			aInfoBox.Execute();
-		}
-		catch ( uno::Exception& )
-		{
-			DBG_ERROR("Unexpected exception in database");
-		}
-	}
-}
-
 const TypedStrCollection& ScDatabaseDPData::GetColumnEntries(long nColumn)
 {
-	DBG_ASSERT( pImpl->ppStrings && nColumn < pImpl->nColCount, "GetColumnEntries: no entries" );
-	if (!pImpl->ppStrings[nColumn])
-	{
-		TypedStrCollection* pColl = new TypedStrCollection;
-
-		//!	select distinct values directly from database
-
-//		Sound::Beep();		//! Test !!!
-
-		uno::Reference<sdbc::XRowSet> xRowSet = pImpl->xRowSet;
-		uno::Reference<sdbc::XRow> xRow( xRowSet, uno::UNO_QUERY );
-		if ( xRow.is() )
-		{
-			ScDPItemData aItemData;
-
-			try
-			{
-				if ( !pImpl->bAtStart )
-					lcl_Reset( xRowSet );
-
-				pImpl->bAtStart = FALSE;
-				while ( xRowSet->next() )
-				{
-					//!	get string for value data only if value hasn't been inserted yet
-					lcl_FillItemData( aItemData, xRow, nColumn+1, pImpl->pTypes[nColumn], TRUE, pImpl );
-					TypedStrData* pNew = new TypedStrData(
-							aItemData.aString, aItemData.fValue,
-							aItemData.bHasValue ? SC_STRTYPE_VALUE : SC_STRTYPE_STANDARD );
-					if (!pColl->Insert(pNew))
-						delete pNew;
-				}
-			}
-			catch ( sdbc::SQLException& rError )
-			{
-				//!	store error message
-				InfoBox aInfoBox( 0, String(rError.Message) );
-				aInfoBox.Execute();
-			}
-			catch ( uno::Exception& )
-			{
-				DBG_ERROR("Unexpected exception in database");
-			}
-		}
-
-		pImpl->ppStrings[nColumn] = pColl;
-	}
-	return *pImpl->ppStrings[nColumn];
+    return pImpl->aCacheTable.getFieldEntries(nColumn);
 }
 
 String ScDatabaseDPData::getDimensionName(long nColumn)
@@ -475,10 +359,11 @@
 		//return "Data";
 		return ScGlobal::GetRscString(STR_PIVOT_DATA);
 	}
-	else if ( pImpl->pTitles && nColumn < pImpl->nColCount )
-	{
-		return pImpl->pTitles[nColumn];
-	}
+
+    const String* pStr = pImpl->aCacheTable.getFieldName(nColumn);
+    if (pStr)
+        return *pStr;
+
 	DBG_ERROR("getDimensionName: invalid dimension");
 	return String();
 }
@@ -500,6 +385,39 @@
 	//!	disable flags
 }
 
+void ScDatabaseDPData::CreateCacheTable()
+{
+    if (!pImpl->aCacheTable.empty())
+        return;
+
+    // Get null date.
+    if (!pImpl->pFormatter)
+        pImpl->pFormatter = new SvNumberFormatter(pImpl->xServiceManager, ScGlobal::eLnge);
+
+    pImpl->aCacheTable.fillTable(pImpl->xRowSet, *pImpl->pFormatter->GetNullDate());
+}
+
+void ScDatabaseDPData::FilterCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+    pImpl->aCacheTable.filterByPageDimension(rPageDims);
+}
+
+void ScDatabaseDPData::GetDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& rFilters, Sequence< Sequence<Any> >& rTabData)
+{
+    pImpl->aCacheTable.filterTable(rFilters, rTabData);
+}
+
+void ScDatabaseDPData::CalcResults(CalcInfo& rInfo, bool bAutoShow)
+{
+    CalcResultsFromCacheTable(pImpl->aCacheTable, rInfo, bAutoShow);
+}
+
+const ScDPCacheTable& ScDatabaseDPData::GetCacheTable() const
+{
+    return pImpl->aCacheTable;
+}
+
+#if not USE_NEW_CODE
 void ScDatabaseDPData::ResetIterator()
 {
 	try
@@ -601,6 +519,7 @@
 
 	return bSuccess;
 }
+#endif
 
 // -----------------------------------------------------------------------
 
Index: sc/source/core/data/dpshttab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dpshttab.cxx,v
retrieving revision 1.9
retrieving revision 1.9.202.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.9 -r1.9.202.2
--- sc/source/core/data/dpshttab.cxx	27 Feb 2007 12:04:49 -0000	1.9
+++ sc/source/core/data/dpshttab.cxx	9 Nov 2007 02:12:09 -0000	1.9.202.2
@@ -44,11 +44,24 @@
 #include <svtools/zforlist.hxx>
 
 #include "dpshttab.hxx"
+#include "dptabres.hxx"
 #include "document.hxx"
 #include "collect.hxx"
 #include "cell.hxx"
+#include "dpcachetable.hxx"
 #include "globstr.hrc"
 
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+
+#include <vector>
+#include <set>
+
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::Any;
+using ::com::sun::star::uno::Sequence;
+using ::std::vector;
+using ::std::set;
+
 // -----------------------------------------------------------------------
 
 class ScSheetDPData_Impl
@@ -57,49 +70,47 @@
 	ScDocument*		pDoc;
 	ScRange			aRange;
 	ScQueryParam	aQuery;
-	long			nColCount;
+    BOOL*           pSpecial;           // to flag special handling of query parameters in ValidQuery.
 	BOOL			bIgnoreEmptyRows;
 	BOOL			bRepeatIfEmpty;
-	TypedStrCollection**	ppStrings;
 	BOOL*			pDateDim;
 	SCROW			nNextRow;		// for iterator, within range
 
-	ScSheetDPData_Impl() {}
+    ScDPCacheTable  aCacheTable;
+
+	ScSheetDPData_Impl() :
+        pSpecial(NULL)
+    {
+    }
 };
 
 // -----------------------------------------------------------------------
 
 ScSheetDPData::ScSheetDPData( ScDocument* pD, const ScSheetSourceDesc& rDesc )
-    : pSpecial(NULL)
 {
-	long nCount = rDesc.aSourceRange.aEnd.Col() - rDesc.aSourceRange.aStart.Col() + 1;
 	pImpl = new ScSheetDPData_Impl;
 	pImpl->pDoc = pD;
 	pImpl->aRange = rDesc.aSourceRange;
 	pImpl->aQuery = rDesc.aQueryParam;
 	pImpl->bIgnoreEmptyRows = FALSE;
 	pImpl->bRepeatIfEmpty = FALSE;
-	pImpl->nColCount = nCount;
-	pImpl->ppStrings = new TypedStrCollection*[nCount];
 	pImpl->pDateDim = NULL;
-	for (long i=0; i<nCount; i++)
-		pImpl->ppStrings[i] = NULL;
 
 	pImpl->nNextRow = pImpl->aRange.aStart.Row() + 1;
 
     SCSIZE nEntryCount(pImpl->aQuery.GetEntryCount());
-    pSpecial = new BOOL[nEntryCount];
+    pImpl->pSpecial = new BOOL[nEntryCount];
     for (SCSIZE j = 0; j < nEntryCount; ++j )
     {
         ScQueryEntry& rEntry = pImpl->aQuery.GetEntry(j);
         if (rEntry.bDoQuery)
         {
-            pSpecial[j] = false;
+            pImpl->pSpecial[j] = false;
             if (!rEntry.bQueryByString)
             {
                 if (*rEntry.pStr == EMPTY_STRING &&
                    ((rEntry.nVal == SC_EMPTYFIELDS) || (rEntry.nVal == SC_NONEMPTYFIELDS)))
-                    pSpecial[j] = true;
+                    pImpl->pSpecial[j] = true;
             }
             else
             {
@@ -110,30 +121,23 @@
             }
     	}
     }
+    CreateCacheTable();
 }
 
 ScSheetDPData::~ScSheetDPData()
 {
-	for (long i=0; i<pImpl->nColCount; i++)
-		delete pImpl->ppStrings[i];
-	delete[] pImpl->ppStrings;
 	delete[] pImpl->pDateDim;
+    delete[] pImpl->pSpecial;
 	delete pImpl;
-    delete[] pSpecial;
 }
 
 void ScSheetDPData::DisposeData()
 {
-	for (long i=0; i<pImpl->nColCount; i++)
-	{
-		delete pImpl->ppStrings[i];
-		pImpl->ppStrings[i] = NULL;
-	}
 }
 
 long ScSheetDPData::GetColumnCount()
 {
-	return pImpl->nColCount;
+    return pImpl->aCacheTable.getColSize();
 }
 
 BOOL lcl_HasQuery( const ScQueryParam& rParam )
@@ -144,58 +148,9 @@
 
 const TypedStrCollection& ScSheetDPData::GetColumnEntries(long nColumn)
 {
-	DBG_ASSERT(nColumn>=0 && nColumn<pImpl->nColCount, "ScSheetDPData: wrong column");
-
-	if (!pImpl->ppStrings[nColumn])
-	{
-		TypedStrCollection* pColl = new TypedStrCollection;
-
-		//!	document must have function to fill collection!!!
-		String aDocStr;
-		SCCOL nDocCol = (SCCOL)(pImpl->aRange.aStart.Col() + nColumn);
-		SCTAB nDocTab = pImpl->aRange.aStart.Tab();
-		SCROW nStartRow = pImpl->aRange.aStart.Row()+1;	// start of data
-		SCROW nEndRow = pImpl->aRange.aEnd.Row();
-		SCCOL nStartCol = pImpl->aRange.aStart.Col();
-		SCCOL nEndCol = pImpl->aRange.aEnd.Col();
-		for (SCROW nRow = nStartRow; nRow <= nEndRow; nRow++)
-		{
-			if ( pImpl->bIgnoreEmptyRows &&
-					pImpl->pDoc->IsBlockEmpty( nDocTab, nStartCol, nRow, nEndCol, nRow ) )
-			{
-				//	ignore this (empty) row
-				//!	count and skip empty rows?
-			}
-			else if ( pImpl->bRepeatIfEmpty && nRow > nStartRow &&
-						!pImpl->pDoc->HasData( nDocCol, nRow, nDocTab ) )
-			{
-				//	ignore empty member (if it's not the first row)
-			}
-			else if ( lcl_HasQuery(pImpl->aQuery) &&
-						!pImpl->pDoc->ValidQuery( nRow, nDocTab, pImpl->aQuery, pSpecial ) )
-			{
-				//	this row is filtered out
-			}
-			else
-			{
-				TypedStrData* pNew;
-				pImpl->pDoc->GetString( nDocCol, nRow, nDocTab, aDocStr );
-				if ( pImpl->pDoc->HasValueData( nDocCol, nRow, nDocTab ) )
-				{
-					double fVal = pImpl->pDoc->GetValue(ScAddress(nDocCol, nRow, nDocTab));
-					pNew = new TypedStrData( aDocStr, fVal, SC_STRTYPE_VALUE );
-				}
-				else
-					pNew = new TypedStrData( aDocStr );
-
-				if (!pColl->Insert(pNew))
-					delete pNew;
-			}
-		}
-
-		pImpl->ppStrings[nColumn] = pColl;
-	}
-	return *pImpl->ppStrings[nColumn];
+    DBG_ASSERT(nColumn>=0 && nColumn < pImpl->aCacheTable.getColSize(), "ScSheetDPData: wrong column");
+    CreateCacheTable();
+    return pImpl->aCacheTable.getFieldEntries(nColumn);
 }
 
 String ScSheetDPData::getDimensionName(long nColumn)
@@ -206,19 +161,26 @@
 		//return "Data";
 		return ScGlobal::GetRscString(STR_PIVOT_DATA);
 	}
-	else if ( nColumn >= pImpl->nColCount )
+    else if (nColumn >= pImpl->aCacheTable.getColSize())
 	{
 		DBG_ERROR("getDimensionName: invalid dimension");
 		return String();
 	}
 	else
 	{
+#if USE_NEW_CODE
+        const String* pStr = pImpl->aCacheTable.getFieldName(nColumn);
+        if (pStr)
+            return *pStr;
+        else return String();
+#else        
 		SCCOL nDocCol = (SCCOL)(pImpl->aRange.aStart.Col() + nColumn);
 		SCROW nDocRow = pImpl->aRange.aStart.Row();
 		SCTAB nDocTab = pImpl->aRange.aStart.Tab();
 		String aDocStr;
 		pImpl->pDoc->GetString( nDocCol, nDocRow, nDocTab, aDocStr );
 		return aDocStr;
+#endif        
 	}
 }
 
@@ -235,11 +197,12 @@
 
 BOOL ScSheetDPData::IsDateDimension(long nDim)
 {
+    long nColCount = pImpl->aCacheTable.getColSize();
 	if (getIsDataLayoutDimension(nDim))
 	{
 		return FALSE;
 	}
-	else if ( nDim >= pImpl->nColCount )
+    else if (nDim >= nColCount)
 	{
 		DBG_ERROR("IsDateDimension: invalid dimension");
 		return FALSE;
@@ -248,9 +211,9 @@
 	{
 		if (!pImpl->pDateDim)
 		{
-			pImpl->pDateDim = new BOOL[pImpl->nColCount];
+            pImpl->pDateDim = new BOOL[nColCount];
 			ScRange aTestRange = pImpl->aRange;
-			for (long i=0; i<pImpl->nColCount; i++)
+			for (long i = 0; i < nColCount; ++i)
 			{
 				SCCOL nCol = (SCCOL)( pImpl->aRange.aStart.Col() + i );
 				aTestRange.aStart.SetCol(nCol);
@@ -268,7 +231,7 @@
 	{
 		return 0;
 	}
-	else if ( nDim >= pImpl->nColCount )
+    else if (nDim >= pImpl->aCacheTable.getColSize())
 	{
 		DBG_ERROR("GetNumberFormat: invalid dimension");
 		return 0;
@@ -286,7 +249,7 @@
 
 BOOL ScSheetDPData::getIsDataLayoutDimension(long nColumn)
 {
-	return ( nColumn == pImpl->nColCount );
+    return (nColumn == pImpl->aCacheTable.getColSize());
 }
 
 void ScSheetDPData::SetEmptyFlags( BOOL bIgnoreEmptyRows, BOOL bRepeatIfEmpty )
@@ -295,11 +258,31 @@
 	pImpl->bRepeatIfEmpty   = bRepeatIfEmpty;
 }
 
-void ScSheetDPData::ResetIterator()
+void ScSheetDPData::CreateCacheTable()
 {
-	pImpl->nNextRow = pImpl->aRange.aStart.Row() + 1;
+    // Scan and store the data from the source range.
+    if (!pImpl->aCacheTable.empty())
+        // already cached.
+        return;
+
+    pImpl->aCacheTable.fillTable(pImpl->pDoc, pImpl->aRange, pImpl->aQuery, pImpl->pSpecial);
+}
+
+void ScSheetDPData::FilterCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+    pImpl->aCacheTable.filterByPageDimension(rPageDims);
+}
+
+void ScSheetDPData::GetDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& rFilters, Sequence< Sequence<Any> >& rData)
+{
+    sal_Int32 nRowSize = pImpl->aCacheTable.getRowSize();
+    if (!nRowSize)
+        return;
+
+    pImpl->aCacheTable.filterTable(rFilters, rData);
 }
 
+#if not USE_NEW_CODE
 void lcl_GetStringOrValue( ScDPItemData& rData, ScDocument* pDoc,
 							SCCOL nCol, SCROW nRow, SCTAB nTab,
 							BOOL bRepeatIfEmpty, SCROW nFirstDataRow )
@@ -321,6 +304,24 @@
 	else
 		pDoc->GetString( nCol, nRow, nTab, rData.aString );
 }
+#endif
+
+void ScSheetDPData::CalcResults(CalcInfo& rInfo, bool bAutoShow)
+{
+    CalcResultsFromCacheTable(pImpl->aCacheTable, rInfo, bAutoShow);
+}
+
+const ScDPCacheTable& ScSheetDPData::GetCacheTable() const
+{
+    return pImpl->aCacheTable;
+}
+
+#if not USE_NEW_CODE
+void ScSheetDPData::ResetIterator()
+{
+    // skipping the header row.
+    pImpl->nNextRow = pImpl->aRange.aStart.Row() + 1;
+}
 
 BOOL ScSheetDPData::GetNextRow( const ScDPTableIteratorParam& rParam )
 {
@@ -348,7 +349,7 @@
 		}
 
 		bFilteredOut = ( lcl_HasQuery(pImpl->aQuery) && 
-				!pImpl->pDoc->ValidQuery( pImpl->nNextRow, nDocTab, pImpl->aQuery, pSpecial ) );
+                         !pImpl->pDoc->ValidQuery( pImpl->nNextRow, nDocTab, pImpl->aQuery, pImpl->pSpecial ) );
 		if ( bFilteredOut )
 		{
 			++pImpl->nNextRow;
@@ -360,6 +361,7 @@
 
 	//!	use more efficient iterators
 
+    // Populate column field information.
 	for (i=0; i<rParam.nColCount; i++)
 	{
 		long nDim = rParam.pCols[i];
@@ -371,6 +373,7 @@
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
 	}
 
+    // Populate row field information.
 	for (i=0; i<rParam.nRowCount; i++)
 	{
 		long nDim = rParam.pRows[i];
@@ -382,6 +385,7 @@
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
 	}
 
+    // Populate page dimension information from the sheet.
 	for (i=0; i<rParam.nPageCount; i++)
 	{
 		long nDim = rParam.pPages[i];
@@ -393,6 +397,7 @@
 									pImpl->bRepeatIfEmpty, nFirstDataRow );
 	}
 
+    // Populate data dimension information from the row.
 	for (i=0; i<rParam.nDatCount; i++)
 	{
 		long nDim = rParam.pDats[i];
@@ -421,6 +426,7 @@
 	pImpl->nNextRow++;
 	return TRUE;
 }
+#endif
 
 // -----------------------------------------------------------------------
 
Index: sc/source/core/data/dptabdat.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabdat.cxx,v
retrieving revision 1.12
retrieving revision 1.12.202.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 -r1.12.202.4
--- sc/source/core/data/dptabdat.cxx	27 Feb 2007 12:05:02 -0000	1.12
+++ sc/source/core/data/dptabdat.cxx	7 Nov 2007 04:28:31 -0000	1.12.202.4
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -50,8 +50,18 @@
 #include <unotools/collatorwrapper.hxx>
 #endif
 
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+
 #include "dptabdat.hxx"
 #include "global.hxx"
+#include "dpcachetable.hxx"
+#include "dptabres.hxx"
+
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
+using ::std::vector;
+using ::std::set;
 
 // -----------------------------------------------------------------------
 
@@ -114,7 +124,7 @@
 }
 
 // -----------------------------------------------------------------------
-
+#if not USE_NEW_CODE
 ScDPTableIteratorParam::ScDPTableIteratorParam(
 							long nCCount, const long* pC, ScDPItemData* pCDat,
 							long nRCount, const long* pR, ScDPItemData* pRDat,
@@ -134,8 +144,9 @@
 	pValues	 ( pV )
 {
 }
+#endif
 
-// -----------------------------------------------------------------------
+// ---------------------------------------------------------------------------
 
 ScDPTableData::ScDPTableData()
 {
@@ -193,6 +204,26 @@
 	return nRet;
 }
 
+void ScDPTableData::CreateCacheTable()
+{
+    fprintf(stdout, "ScDPTableData::CreateCacheTable: un-implemented...\n");fflush(stdout);
+}
+
+void ScDPTableData::FilterCacheTable(const vector<ScDPDimension*>& rPageDims)
+{
+    fprintf(stdout, "ScDPTableData::FilterCacheTable: un-implemented...\n");fflush(stdout);
+}
+
+void ScDPTableData::GetDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& aFilters, Sequence< Sequence<Any> >& rTabData)
+{
+    fprintf(stdout, "ScDPTableData::GetDrillDownData: un-implemented...\n");fflush(stdout);
+}
+
+void ScDPTableData::CalcResults(CalcInfo& rInfo, bool bAutoShow)
+{
+    fprintf(stdout, "ScDPTableData::CalcResults: un-implemented...\n");fflush(stdout);
+}
+
 UINT32 ScDPTableData::GetNumberFormat(long)
 {
 	return 0;			// default format
@@ -227,6 +258,107 @@
     return FALSE;
 }
 
+void ScDPTableData::FillRowDataFromCacheTable(sal_Int32 nRow, const ScDPCacheTable& rCacheTable, 
+                                        const CalcInfo& rInfo, CalcRowData& rData)
+{
+    // column dimensions
+    GetItemData(rCacheTable, nRow, rInfo.aColLevelDims, rData.aColData);
+
+    // row dimensions
+    GetItemData(rCacheTable, nRow, rInfo.aRowLevelDims, rData.aRowData);
+
+    // page dimensions
+    GetItemData(rCacheTable, nRow, rInfo.aPageDims, rData.aPageData);
+
+    sal_Int32 n = rInfo.aDataSrcCols.size();
+    for (sal_Int32 i = 0; i < n; ++i)
+    {
+        long nDim = rInfo.aDataSrcCols[i];
+        rData.aValues.push_back( ScDPValueData() );
+        ScDPValueData& rVal = rData.aValues.back();
+        const ScDPCacheTable::Cell* pCell = rCacheTable.getCell(nDim, nRow);
+        if (pCell)
+        {
+            rVal.fValue = pCell->mbNumeric ? pCell->mfValue : 0.0;
+            rVal.nType = pCell->mnType;
+        }
+        else
+            rVal.Set(0.0, SC_VALTYPE_EMPTY);
+    }
+}
+
+void ScDPTableData::ProcessRowData(CalcInfo& rInfo, CalcRowData& rData, bool bAutoShow)
+{
+#if USE_NEW_CODE    
+    if (!bAutoShow)
+    {
+        rInfo.pColRoot->LateInitFrom(rInfo.aColDims, rInfo.aColLevels, rData.aColData, 0, *rInfo.pInitState);
+        rInfo.pRowRoot->LateInitFrom(rInfo.aRowDims, rInfo.aRowLevels, rData.aRowData, 0, *rInfo.pInitState);
+    }
+
+    if ( ( !rInfo.pColRoot->GetChildDimension() || rInfo.pColRoot->GetChildDimension()->IsValidEntry(rData.aColData) ) &&
+         ( !rInfo.pRowRoot->GetChildDimension() || rInfo.pRowRoot->GetChildDimension()->IsValidEntry(rData.aRowData) ) )
+    {
+        //! single process method with ColMembers, RowMembers and data !!!
+        if (rInfo.pColRoot->GetChildDimension())
+        {
+            vector<ScDPItemData> aEmptyData;
+            rInfo.pColRoot->GetChildDimension()->ProcessData(rData.aColData, NULL, aEmptyData, rData.aValues);
+        }
+
+        rInfo.pRowRoot->ProcessData(rData.aRowData, rInfo.pColRoot->GetChildDimension(), 
+                                    rData.aColData, rData.aValues);
+    }
+#endif    
+}
+
+void ScDPTableData::CalcResultsFromCacheTable(const ScDPCacheTable& rCacheTable, CalcInfo& rInfo, bool bAutoShow)
+{
+    sal_Int32 nRowSize = rCacheTable.getRowSize();
+    for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+    {
+        if (!rCacheTable.isRowActive(nRow))
+            continue;
+
+        CalcRowData aData;
+        FillRowDataFromCacheTable(nRow, rCacheTable, rInfo, aData);
+        ProcessRowData(rInfo, aData, bAutoShow);
+    }
+}
+
+void ScDPTableData::GetItemData(const ScDPCacheTable& rCacheTable, sal_Int32 nRow, 
+                                const vector<long>& rDims, vector<ScDPItemData>& rItemData)
+{
+    sal_Int32 nDimSize = rDims.size();
+    for (sal_Int32 i = 0; i < nDimSize; ++i)
+    {
+        long nDim = rDims[i];
+        rItemData.push_back( ScDPItemData() );
+        ScDPItemData& rData = rItemData.back();
+        if (getIsDataLayoutDimension(nDim))
+        {
+            rData.SetString(String::CreateFromAscii(RTL_CONSTASCII_STRINGPARAM("x")));
+            continue;
+        }
+
+        const ScDPCacheTable::Cell* pCell = rCacheTable.getCell(nDim, nRow);
+        if (!pCell)
+            continue;
+
+        const String* pString = ScDPCacheTable::getString(pCell->mnStrId);
+        if (!pString)
+            continue;
+
+        rData.aString = *pString;
+        rData.bHasValue = false;
+        if (pCell->mbNumeric)
+        {
+            rData.bHasValue = true;
+            rData.fValue = pCell->mfValue;
+        }
+    }
+}
+
 // -----------------------------------------------------------------------
 
 
Index: sc/source/core/data/dptabres.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabres.cxx,v
retrieving revision 1.11
retrieving revision 1.11.200.8
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.11 -r1.11.200.8
--- sc/source/core/data/dptabres.cxx	27 Feb 2007 12:05:33 -0000	1.11
+++ sc/source/core/data/dptabres.cxx	19 Nov 2007 22:21:08 -0000	1.11.200.8
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -66,6 +66,7 @@
 #include <com/sun/star/sheet/DataPilotFieldSortMode.hpp>
 
 using namespace com::sun::star;
+using ::std::vector;
 
 // -----------------------------------------------------------------------
 
@@ -563,6 +564,7 @@
 	if ( bEmpty || bError )
 		fResult = 0.0;		// default, in case the state is later modified
 
+//  fprintf(stdout, "ScDPAggData::Calculate: result = %g\n", fResult);fflush(stdout);
 	fVal = fResult;			// used directly from now on
 	fAux = 0.0;				// used for running total or original result of reference value
 }
@@ -894,11 +896,30 @@
     return pSource->GetData()->HasCommonElement( rFirstData, nFirstIndex, rSecondData, nSecondIndex );
 }
 
+void ScDPResultData::Debug() const
+{
+    fprintf(stdout, "------------------------------ ScDPResultData::Debug ------------------------------\n");
+    fprintf(stdout, "data at col (%d);  data at row (%d);  late init(%d)\n", bDataAtCol, bDataAtRow, bLateInit);
+    for (long i = 0; i < nMeasCount; ++i)
+    {
+        fprintf(stdout, "  measure id = %ld --------------------\n", i);
+        fprintf(stdout, "    measure function = %d\n", pMeasFuncs[i]);
+        fprintf(stdout, "    measure name = '%s'\n", 
+                OUStringToOString(rtl::OUString(pMeasNames[i]), RTL_TEXTENCODING_UTF8).getStr());
+        fprintf(stdout, "    measure ref orientation = %d\n", pMeasRefOrient[i]);
+        fprintf(stdout, "    measure ref type = %ld  field = '%s'  item type = %ld  item name = '%s'\n", 
+                pMeasRefs[i].ReferenceType, 
+                OUStringToOString(pMeasRefs[i].ReferenceField, RTL_TEXTENCODING_UTF8).getStr(),
+                pMeasRefs[i].ReferenceItemType,
+                OUStringToOString(pMeasRefs[i].ReferenceItemName, RTL_TEXTENCODING_UTF8).getStr());
+    }
+}
+
 // -----------------------------------------------------------------------
 
 
-ScDPResultMember::ScDPResultMember( ScDPResultData* pData, ScDPDimension* pDim,
-									ScDPLevel* pLev, ScDPMember* pDesc,
+ScDPResultMember::ScDPResultMember( const ScDPResultData* pData, const ScDPDimension* pDim,
+									const ScDPLevel* pLev, const ScDPMember* pDesc,
 									BOOL bForceSub ) :
 	pResultData( pData ),
 	pParentDim( pDim ),
@@ -945,6 +966,27 @@
 		return ((ScDPMember*)pMemberDesc)->IsNamedItem( r );
 	return FALSE;
 }
+
+#if USE_NEW_CODE
+bool ScDPResultMember::IsValidEntry( const vector<ScDPItemData>& aMembers ) const
+{
+    if ( !IsValid() )
+        return false;
+
+    const ScDPResultDimension* pChildDim = GetChildDimension();
+    if (pChildDim)
+    {
+        if (aMembers.size() < 2)
+            return false;
+
+        vector<ScDPItemData>::const_iterator itr = aMembers.begin();
+        vector<ScDPItemData> aChildMembers(++itr, aMembers.end());
+        return pChildDim->IsValidEntry(aChildMembers);
+    }
+    else
+        return true;
+}
+#else
 BOOL ScDPResultMember::IsValidEntry( const ScDPItemData* pMembers ) const
 {
 	if ( !IsValid() )
@@ -956,7 +998,60 @@
 	else
 		return TRUE;
 }
+#endif
+
+#if USE_NEW_CODE
+void ScDPResultMember::InitFrom( const vector<ScDPDimension*>& ppDim, const vector<ScDPLevel*>& ppLev, 
+                                 size_t nPos, ScDPInitState& rInitState )
+{
+	//	with LateInit, initialize only those members that have data
+	if ( pResultData->IsLateInit() )
+		return;
+
+	bInitialized = TRUE;
+
+    if (nPos >= ppDim.size())
+        return;
+
+	//	skip child dimension if details are not shown
+	if ( pMemberDesc && !pMemberDesc->getShowDetails() )
+	{
+        bHasHiddenDetails = TRUE;	// only if there is a next dimension
+		return;
+	}
+
+    pChildDimension = new ScDPResultDimension( pResultData );
+    pChildDimension->InitFrom( ppDim, ppLev, nPos, rInitState );
+}
 
+void ScDPResultMember::LateInitFrom( const vector<ScDPDimension*>& ppDim, const vector<ScDPLevel*>& ppLev, 
+                                     const vector<ScDPItemData>& pItemData, size_t nPos,
+                                     ScDPInitState& rInitState )
+{
+	//	without LateInit, everything has already been initialized
+	if ( !pResultData->IsLateInit() )
+		return;
+
+	bInitialized = TRUE;
+
+    if (nPos >= ppDim.size())
+        // No next dimension.  Bail out.
+        return;
+
+    //	skip child dimension if details are not shown
+    if ( pMemberDesc && !pMemberDesc->getShowDetails() )
+    {
+        bHasHiddenDetails = TRUE;   // only if there is a next dimension
+        return;
+    }
+
+    //	LateInitFrom is called several times...
+    if ( !pChildDimension )
+        pChildDimension = new ScDPResultDimension( pResultData );
+
+    pChildDimension->LateInitFrom( ppDim, ppLev, pItemData, nPos, rInitState );
+}
+#else
 void ScDPResultMember::InitFrom( ScDPDimension** ppDim, ScDPLevel** ppLev, ScDPInitState& rInitState )
 {
 	//	with LateInit, initialize only those members that have data
@@ -989,6 +1084,25 @@
 
 	bInitialized = TRUE;
 
+#if 1
+    if (!*ppDim)
+        // No next dimension.  Bail out.
+        return;
+
+    //	skip child dimension if details are not shown
+    if ( pMemberDesc && !pMemberDesc->getShowDetails() )
+    {
+        bHasHiddenDetails = TRUE;   // only if there is a next dimension
+        return;
+    }
+
+    //	LateInitFrom is called several times...
+    if ( !pChildDimension )
+        pChildDimension = new ScDPResultDimension( pResultData );
+
+    pChildDimension->LateInitFrom( ppDim, ppLev, pItemData, rInitState );
+
+#else	
 	//	skip child dimension if details are not shown
 	if ( pMemberDesc && !pMemberDesc->getShowDetails() )
 	{
@@ -1004,7 +1118,9 @@
 			pChildDimension = new ScDPResultDimension( pResultData );
 		pChildDimension->LateInitFrom( ppDim, ppLev, pItemData, rInitState );
 	}
+#endif    
 }
+#endif
 
 BOOL ScDPResultMember::IsSubTotalInTitle(long nMeasure) const
 {
@@ -1123,6 +1239,44 @@
 		return 0;
 }
 
+#if USE_NEW_CODE
+void ScDPResultMember::ProcessData( const vector<ScDPItemData>& aChildMembers, const ScDPResultDimension* pDataDim,
+                                    const vector<ScDPItemData>& aDataMembers, const vector<ScDPValueData>& aValues )
+{
+    SetHasElements();
+
+    if (pChildDimension)
+        pChildDimension->ProcessData( aChildMembers, pDataDim, aDataMembers, aValues );
+
+    if ( !pDataRoot )
+    {
+        pDataRoot = new ScDPDataMember( pResultData, NULL );
+        if ( pDataDim )
+            pDataRoot->InitFrom( pDataDim );            // recursive
+    }
+
+    ScDPSubTotalState aSubState;        // initial state
+
+    long nUserSubCount = GetSubTotalCount();
+
+    // Calculate at least automatic if no subtotals are selected,
+    // show only own values if there's no child dimension (innermost).
+    if ( !nUserSubCount || !pChildDimension )
+        nUserSubCount = 1;
+
+    for (long nUserPos=0; nUserPos<nUserSubCount; nUserPos++)   // including hidden "automatic"
+    {
+        // #i68338# if nUserSubCount is 1 (automatic only), don't set nRowSubTotalFunc
+        if ( pChildDimension && nUserSubCount > 1 )
+        {
+            aSubState.nRowSubTotalFunc = nUserPos;
+            aSubState.eRowForce = lcl_GetForceFunc( pParentLevel, nUserPos );
+        }
+
+        pDataRoot->ProcessData( aDataMembers, aValues, aSubState );
+    }
+}
+#else
 void ScDPResultMember::ProcessData( const ScDPItemData* pChildMembers, ScDPResultDimension* pDataDim,
 										const ScDPItemData* pDataMembers, const ScDPValueData* pValues )
 {
@@ -1131,8 +1285,8 @@
 	if (pChildDimension)
 		pChildDimension->ProcessData( pChildMembers, pDataDim, pDataMembers, pValues );
 
-	if ( pDataMembers )
-	{
+//  if ( pDataMembers )
+//  {
 		if ( !pDataRoot )
 		{
 			pDataRoot = new ScDPDataMember( pResultData, NULL );
@@ -1160,8 +1314,9 @@
 
 			pDataRoot->ProcessData( pDataMembers, pValues, aSubState );
 		}
-	}
+//  }
 }
+#endif
 
 void ScDPResultMember::FillMemberResults( uno::Sequence<sheet::MemberResult>* pSequences,
 											long& rPos, long nMeasure, BOOL bRoot,
@@ -1575,7 +1730,7 @@
 
 // -----------------------------------------------------------------------
 
-ScDPDataMember::ScDPDataMember( ScDPResultData* pData, const ScDPResultMember* pRes ) :
+ScDPDataMember::ScDPDataMember( const ScDPResultData* pData, const ScDPResultMember* pRes ) :
 	pResultData( pData ),
 	pResultMember( pRes ),
 	pChildDimension( NULL )
@@ -1647,6 +1802,31 @@
 	return nRet;
 }
 
+#if USE_NEW_CODE
+void ScDPDataMember::UpdateValues( const vector<ScDPValueData>& aValues, const ScDPSubTotalState& rSubState )
+{
+    //!	find out how many and which subtotals are used
+
+    ScDPAggData* pAgg = &aAggregate;
+
+    long nSubPos = lcl_GetSubTotalPos(rSubState);
+    if (nSubPos == SC_SUBTOTALPOS_SKIP)
+        return;
+    if (nSubPos > 0)
+    {
+        long nSkip = nSubPos * pResultData->GetMeasureCount();
+        for (long i=0; i<nSkip; i++)
+            pAgg = pAgg->GetChild();        // created if not there
+    }
+
+    size_t nCount = aValues.size();
+    for (size_t nPos = 0; nPos < nCount; ++nPos)
+    {
+        pAgg->Update(aValues[nPos], pResultData->GetMeasureFunction(nPos), rSubState);
+        pAgg = pAgg->GetChild();
+    }
+}
+#else
 void ScDPDataMember::UpdateValues( const ScDPValueData* pValues, const ScDPSubTotalState& rSubState )
 {
 	//!	find out how many and which subtotals are used
@@ -1674,8 +1854,46 @@
 		}
 	}
 }
+#endif
+
+#if USE_NEW_CODE
+void ScDPDataMember::ProcessData( const vector<ScDPItemData>& aChildMembers, const vector<ScDPValueData>& aValues,
+									const ScDPSubTotalState& rSubState )
+{
+	if ( pResultData->IsLateInit() && !pChildDimension && pResultMember && pResultMember->GetChildDimension() )
+	{
+		//	if this DataMember doesn't have a child dimension because the ResultMember's
+		//	child dimension wasn't there yet during this DataMembers's creation,
+		//	create the child dimension now
+		InitFrom( pResultMember->GetChildDimension() );
+	}
+
+	ScDPSubTotalState aLocalSubState(rSubState);		// keep row state, modify column
+
+	long nUserSubCount = pResultMember ? pResultMember->GetSubTotalCount() : 0;
+
+    // Calculate at least automatic if no subtotals are selected,
+    // show only own values if there's no child dimension (innermost).
+	if ( !nUserSubCount || !pChildDimension )
+		nUserSubCount = 1;
+
+	for (long nUserPos=0; nUserPos<nUserSubCount; nUserPos++)   // including hidden "automatic"
+	{
+		if ( pChildDimension && nUserSubCount > 1 )
+		{
+			const ScDPLevel* pForceLevel = pResultMember ? pResultMember->GetParentLevel() : NULL;
+			aLocalSubState.nColSubTotalFunc = nUserPos;
+			aLocalSubState.eColForce = lcl_GetForceFunc( pForceLevel, nUserPos );
+		}
 
-void ScDPDataMember::ProcessData( const ScDPItemData* pChildMembers, const ScDPValueData* pValues,
+		UpdateValues( aValues, aLocalSubState );
+	}
+
+	if (pChildDimension)
+		pChildDimension->ProcessData( aChildMembers, aValues, rSubState );		// with unmodified subtotal state
+}
+#else
+void ScDPDataMember::ProcessData( const ScDPItemData* pChildMembers, const ScDPValueData* aValues,
 									const ScDPSubTotalState& rSubState )
 {
 	if ( pResultData->IsLateInit() && !pChildDimension && pResultMember && pResultMember->GetChildDimension() )
@@ -1704,12 +1922,13 @@
 			aLocalSubState.eColForce = lcl_GetForceFunc( pForceLevel, nUserPos );
 		}
 
-		UpdateValues( pValues, aLocalSubState );
+        UpdateValues( aValues, aLocalSubState );
 	}
 
 	if (pChildDimension)
-		pChildDimension->ProcessData( pChildMembers, pValues, rSubState );		// with unmodified subtotal state
+        pChildDimension->ProcessData( pChildMembers, aValues, rSubState );      // with unmodified subtotal state
 }
+#endif
 
 BOOL ScDPDataMember::HasData( long nMeasure, const ScDPSubTotalState& rSubState ) const
 {
@@ -2413,7 +2632,7 @@
 class ScDPGroupCompare
 {
 private:
-    ScDPResultData*      pResultData;
+    const ScDPResultData* pResultData;
     const ScDPInitState& rInitState;
     long                 nDimSource;
     BOOL                 bIncludeAll;
@@ -2422,14 +2641,14 @@
     const ScDPItemData*  pBaseData;
 
 public:
-            ScDPGroupCompare( ScDPResultData* pData, const ScDPInitState& rState, long nDimension );
+            ScDPGroupCompare( const ScDPResultData* pData, const ScDPInitState& rState, long nDimension );
             ~ScDPGroupCompare() {}
 
     BOOL    IsIncluded( const ScDPMember& rMember )     { return bIncludeAll || TestIncluded( rMember ); }
     BOOL    TestIncluded( const ScDPMember& rMember );
 };
 
-ScDPGroupCompare::ScDPGroupCompare( ScDPResultData* pData, const ScDPInitState& rState, long nDimension ) :
+ScDPGroupCompare::ScDPGroupCompare( const ScDPResultData* pData, const ScDPInitState& rState, long nDimension ) :
     pResultData( pData ),
     rInitState( rState ),
     nDimSource( nDimension ),
@@ -2494,7 +2713,7 @@
 
 // -----------------------------------------------------------------------
 
-ScDPResultDimension::ScDPResultDimension( ScDPResultData* pData ) :
+ScDPResultDimension::ScDPResultDimension( const ScDPResultData* pData ) :
 	pResultData( pData ),
 	bInitialized( FALSE ),
 	bIsDataLayout( FALSE ),
@@ -2538,6 +2757,183 @@
 	return NULL;
 }
 
+#if USE_NEW_CODE
+void ScDPResultDimension::InitFrom( const vector<ScDPDimension*>& ppDim, const vector<ScDPLevel*>& ppLev, 
+                                    size_t nPos, ScDPInitState& rInitState )
+{
+    if (nPos >= ppDim.size() || nPos >= ppLev.size())
+    {
+        bInitialized = true;
+        return;
+    }
+
+	ScDPDimension* pThisDim = ppDim[nPos];
+	ScDPLevel* pThisLevel = ppLev[nPos];
+
+    if (!pThisDim || !pThisLevel)
+    {
+        bInitialized = true;
+        return;
+    }
+
+    bIsDataLayout = pThisDim->getIsDataLayoutDimension();   // member
+    aDimensionName = pThisDim->getName();                   // member 
+
+    // Check the autoshow setting.  If it's enabled, store the settings.
+    const sheet::DataPilotFieldAutoShowInfo& rAutoInfo = pThisLevel->GetAutoShow();
+    if ( rAutoInfo.IsEnabled )
+    {
+        bAutoShow     = TRUE;
+        bAutoTopItems = ( rAutoInfo.ShowItemsMode == sheet::DataPilotFieldShowItemsMode::FROM_TOP );
+        nAutoMeasure  = pThisLevel->GetAutoMeasure();
+        nAutoCount    = rAutoInfo.ItemCount;
+    }
+
+    // Check the sort info, and store the settings if appropriate.
+    const sheet::DataPilotFieldSortInfo& rSortInfo = pThisLevel->GetSortInfo();
+    if ( rSortInfo.Mode == sheet::DataPilotFieldSortMode::DATA )
+    {
+        bSortByData = TRUE;
+        bSortAscending = rSortInfo.IsAscending;
+        nSortMeasure = pThisLevel->GetSortMeasure();
+    }
+
+    // global order is used to initialize aMembers, so it doesn't have to be looked at later
+    const ScMemberSortOrder& rGlobalOrder = pThisLevel->GetGlobalOrder();
+
+    long nDimSource = pThisDim->GetDimension();     //! check GetSourceDim?
+    ScDPGroupCompare aCompare( pResultData, rInitState, nDimSource );
+
+    // Now, go through all members and initialize them.
+    ScDPMembers* pMembers = pThisLevel->GetMembersObject();
+    long nMembCount = pMembers->getCount();
+    for ( long i=0; i<nMembCount; i++ )
+    {
+        long nSorted = rGlobalOrder.empty() ? i : rGlobalOrder[i];
+
+        ScDPMember* pMember = pMembers->getByIndex(nSorted);
+        if ( aCompare.IsIncluded( *pMember ) )
+        {
+            ScDPResultMember* pNew = new ScDPResultMember( pResultData, pThisDim,
+                                            pThisLevel, pMember, FALSE );
+            maMemberArray.push_back( pNew );
+
+            ScDPItemData aMemberData;
+            pMember->FillItemData( aMemberData );
+
+            // honour order of maMemberArray and only insert if it does not
+            // already exist
+            if ( maMemberHash.end() == maMemberHash.find( aMemberData ) )
+                maMemberHash.insert( std::pair< const ScDPItemData, ScDPResultMember *>( aMemberData, pNew ) );
+
+            rInitState.AddMember( nDimSource, aMemberData );
+            pNew->InitFrom( ppDim, ppLev, nPos+1, rInitState );
+            rInitState.RemoveMember();
+        }
+    }
+	bInitialized = TRUE;
+}
+
+void ScDPResultDimension::LateInitFrom( const vector<ScDPDimension*>& ppDim, const vector<ScDPLevel*>& ppLev, 
+                                        const vector<ScDPItemData>& pItemData, size_t nPos,
+                                        ScDPInitState& rInitState )
+{
+    if (nPos >= ppDim.size() || nPos >= ppLev.size() || nPos >= pItemData.size())
+        return;
+
+	ScDPDimension* pThisDim = ppDim[nPos];
+	ScDPLevel* pThisLevel = ppLev[nPos];
+	const ScDPItemData& rThisData = pItemData[nPos];
+
+    if (!pThisDim || !pThisLevel)
+        return;
+
+    long nDimSource = pThisDim->GetDimension();     //! check GetSourceDim?
+
+    if ( !bInitialized )
+    {
+			//	create all members at the first call (preserve order)
+
+        bIsDataLayout = pThisDim->getIsDataLayoutDimension();
+        aDimensionName = pThisDim->getName();
+
+        const sheet::DataPilotFieldAutoShowInfo& rAutoInfo = pThisLevel->GetAutoShow();
+        if ( rAutoInfo.IsEnabled )
+        {
+            bAutoShow     = TRUE;
+            bAutoTopItems = ( rAutoInfo.ShowItemsMode == sheet::DataPilotFieldShowItemsMode::FROM_TOP );
+            nAutoMeasure  = pThisLevel->GetAutoMeasure();
+            nAutoCount    = rAutoInfo.ItemCount;
+        }
+
+        const sheet::DataPilotFieldSortInfo& rSortInfo = pThisLevel->GetSortInfo();
+        if ( rSortInfo.Mode == sheet::DataPilotFieldSortMode::DATA )
+        {
+            bSortByData = TRUE;
+            bSortAscending = rSortInfo.IsAscending;
+            nSortMeasure = pThisLevel->GetSortMeasure();
+        }
+
+            // global order is used to initialize aMembers, so it doesn't have to be looked at later
+        const ScMemberSortOrder& rGlobalOrder = pThisLevel->GetGlobalOrder();
+
+        ScDPGroupCompare aCompare( pResultData, rInitState, nDimSource );
+
+        ScDPMembers* pMembers = pThisLevel->GetMembersObject();
+        long nMembCount = pMembers->getCount();
+        for ( long i=0; i<nMembCount; i++ )
+        {
+            long nSorted = rGlobalOrder.empty() ? i : rGlobalOrder[i];
+
+            ScDPMember* pMember = pMembers->getByIndex(nSorted);
+            if ( aCompare.IsIncluded( *pMember ) )
+            {
+                ScDPResultMember* pNew = new ScDPResultMember( pResultData, pThisDim,
+                                                pThisLevel, pMember, FALSE );
+                maMemberArray.push_back( pNew );
+
+                ScDPItemData aMemberData;
+                pMember->FillItemData( aMemberData );
+
+                    // honour order of maMemberArray and only insert if it does not
+                    // already exist
+                if ( maMemberHash.end() == maMemberHash.find( aMemberData ) )
+                    maMemberHash.insert( std::pair< const ScDPItemData, ScDPResultMember *>( aMemberData, pNew ) );
+            }
+        }
+        bInitialized = TRUE;    // don't call again, even if no members were included
+    }
+
+		//	initialize only specific member (or all if "show empty" flag is set)
+
+    BOOL bShowEmpty = pThisLevel->getShowEmpty();
+    if ( bIsDataLayout || bShowEmpty )
+    {
+        long nCount = maMemberArray.size();
+        for (long i=0; i<nCount; i++)
+        {
+            ScDPResultMember* pResultMember = maMemberArray[i];
+            ScDPItemData aMemberData;
+            pResultMember->FillItemData( aMemberData );
+            rInitState.AddMember( nDimSource, aMemberData );
+            pResultMember->LateInitFrom( ppDim, ppLev, pItemData, nPos+1, rInitState );
+            rInitState.RemoveMember();
+        }
+    }
+    else
+    {
+        ScDPResultMember* pResultMember = FindMember( rThisData );
+        if( NULL != pResultMember )
+        {
+            ScDPItemData aMemberData;
+            pResultMember->FillItemData( aMemberData );
+            rInitState.AddMember( nDimSource, aMemberData );
+            pResultMember->LateInitFrom( ppDim, ppLev, pItemData, nPos+1, rInitState );
+            rInitState.RemoveMember();
+        }
+    }
+}
+#else
 void ScDPResultDimension::InitFrom( ScDPDimension** ppDim, ScDPLevel** ppLev, ScDPInitState& rInitState )
 {
 	ScDPDimension* pThisDim = *ppDim;
@@ -2701,6 +3097,7 @@
 		}
 	}
 }
+#endif
 
 long ScDPResultDimension::GetSize(long nMeasure) const
 {
@@ -2722,6 +3119,45 @@
 	return nTotal;
 }
 
+#if USE_NEW_CODE
+bool ScDPResultDimension::IsValidEntry( const vector<ScDPItemData>& aMembers ) const
+{
+    if (aMembers.empty())
+        return false;
+
+    const ScDPResultMember* pMember = FindMember( aMembers[0] );
+    if ( NULL != pMember )
+        return pMember->IsValidEntry( aMembers );
+
+    DBG_ERROR("IsValidEntry: Member not found");
+    return false;
+}
+
+void ScDPResultDimension::ProcessData( const vector<ScDPItemData>& aMembers,
+                                       const ScDPResultDimension* pDataDim, 
+                                       const vector<ScDPItemData>& aDataMembers,
+                                       const vector<ScDPValueData>& aValues ) const
+{
+    if (aMembers.empty())
+        return;
+
+	ScDPResultMember* pMember = FindMember( aMembers[0] );
+	if ( NULL != pMember )
+	{
+        vector<ScDPItemData> aChildMembers;
+        if (aMembers.size() > 1)
+        {
+            vector<ScDPItemData>::const_iterator itr = aMembers.begin();
+            aChildMembers.assign(++itr, aMembers.end());
+        }
+        pMember->ProcessData( aChildMembers, pDataDim, aDataMembers, aValues );
+        return;
+    }
+
+	DBG_ERROR("ProcessData: Member not found");
+}
+
+#else
 BOOL ScDPResultDimension::IsValidEntry( const ScDPItemData* pMembers ) const
 {
     // the ScDPItemData array must contain enough entries for all dimensions - this isn't checked
@@ -2747,6 +3183,7 @@
 
 	DBG_ERROR("ProcessData: Member not found");
 }
+#endif
 
 void ScDPResultDimension::FillMemberResults( uno::Sequence<sheet::MemberResult>* pSequences,
 												long nStart, long nMeasure )
@@ -3210,7 +3647,7 @@
 
 // -----------------------------------------------------------------------
 
-ScDPDataDimension::ScDPDataDimension( ScDPResultData* pData ) :
+ScDPDataDimension::ScDPDataDimension( const ScDPResultData* pData ) :
 	pResultData( pData ),
 	pResultDimension( NULL ),
 	bIsDataLayout( FALSE )
@@ -3229,6 +3666,8 @@
     pResultDimension = pDim;
 	bIsDataLayout = pDim->IsDataLayout();
 
+    // Go through all result members under the given result dimension, and
+    // create a new data member instance for each result member.
 	long nCount = pDim->GetMemberCount();
 	for (long i=0; i<nCount; i++)
 	{
@@ -3249,6 +3688,34 @@
 	}
 }
 
+#if USE_NEW_CODE
+void ScDPDataDimension::ProcessData( const vector<ScDPItemData>& aDataMembers, const vector<ScDPValueData>& aValues,
+                                     const ScDPSubTotalState& rSubState )
+{
+    // the ScDPItemData array must contain enough entries for all dimensions - this isn't checked
+
+    long nCount = aMembers.Count();
+    for (long i=0; i<nCount; i++)
+    {
+        ScDPDataMember* pMember = aMembers[(USHORT)i];
+
+        // always first member for data layout dim
+        if ( bIsDataLayout || ( !aDataMembers.empty() && pMember->IsNamedItem(aDataMembers[0]) ) )
+        {
+            vector<ScDPItemData> aChildDataMembers;
+            if (aDataMembers.size() > 1)
+            {
+                vector<ScDPItemData>::const_iterator itr = aDataMembers.begin();
+                aChildDataMembers.assign(++itr, aDataMembers.end());
+            }
+            pMember->ProcessData( aChildDataMembers, aValues, rSubState );
+            return;
+        }
+    }
+
+    DBG_ERROR("ProcessData: Member not found");
+}
+#else
 void ScDPDataDimension::ProcessData( const ScDPItemData* pDataMembers, const ScDPValueData* pValues,
 									const ScDPSubTotalState& rSubState )
 {
@@ -3269,6 +3736,7 @@
 
 	DBG_ERROR("ProcessData: Member not found");
 }
+#endif
 
 void ScDPDataDimension::FillDataRow( const ScDPResultDimension* pRefDim,
 									uno::Sequence<sheet::DataResult>& rSequence,
Index: sc/source/core/data/dptabsrc.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/dptabsrc.cxx,v
retrieving revision 1.20
retrieving revision 1.20.42.6
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.20 -r1.20.42.6
--- sc/source/core/data/dptabsrc.cxx	27 Sep 2007 13:52:51 -0000	1.20
+++ sc/source/core/data/dptabsrc.cxx	19 Nov 2007 22:20:29 -0000	1.20.42.6
@@ -36,11 +36,14 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
+#include <stdio.h>
 
 
 // INCLUDE ---------------------------------------------------------------
 
 #include <algorithm>
+#include <vector>
+#include <set>
 
 #include <tools/debug.hxx>
 #include <rtl/math.hxx>
@@ -58,8 +61,10 @@
 
 #include <com/sun/star/beans/PropertyAttribute.hpp>
 #include <com/sun/star/sheet/DataPilotFieldOrientation.hpp>
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
 #include <com/sun/star/sheet/DataPilotFieldReferenceType.hpp>
 #include <com/sun/star/sheet/DataPilotFieldSortMode.hpp>
+#include <com/sun/star/table/CellAddress.hpp>
 
 #ifndef _UNOTOOLS_COLLATORWRAPPER_HXX
 #include <unotools/collatorwrapper.hxx>
@@ -72,6 +77,11 @@
 #endif
 
 using namespace com::sun::star;
+using ::std::vector;
+using ::std::set;
+using ::com::sun::star::uno::Reference;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
 
 // -----------------------------------------------------------------------
 
@@ -409,6 +419,14 @@
 	DBG_ERROR("not implemented");	//! exception?
 }
 
+Sequence< Sequence<Any> > SAL_CALL ScDPSource::getDrillDownData(const Sequence<sheet::DataPilotFieldFilter>& aFilters)
+    throw (uno::RuntimeException)
+{
+    Sequence< Sequence<Any> > aTabData;
+    pData->GetDrillDownData(aFilters, aTabData);
+    return aTabData;
+}
+
 String ScDPSource::getDataDescription()
 {
 	CreateRes_Impl();		// create pResData
@@ -500,6 +518,68 @@
 	bResultOverflow = FALSE;
 }
 
+#if USE_NEW_CODE
+long lcl_CountMinMembers(const vector<ScDPDimension*>& ppDim, const vector<ScDPLevel*>& ppLevel, long nLevels )
+{
+    //	Calculate the product of the member count for those consecutive levels that
+    //	have the "show all" flag, one following level, and the data layout dimension.
+
+    long nTotal = 1;
+    long nDataCount = 1;
+    BOOL bWasShowAll = TRUE;
+    long nPos = nLevels;
+    while ( nPos > 0 )
+    {
+        --nPos;
+
+        if ( nPos < nLevels && ppDim[nPos] == ppDim[nPos+1] )
+        {
+            DBG_ERROR("lcl_CountMinMembers: multiple levels from one dimension not implemented");
+            return 0;
+        }
+
+        BOOL bDo = FALSE;
+        if ( ppDim[nPos]->getIsDataLayoutDimension() )
+        {
+            //	data layout dim doesn't interfere with "show all" flags
+            nDataCount = ppLevel[nPos]->GetMembersObject()->getCount();
+            if ( nDataCount == 0 )
+                nDataCount = 1;
+        }
+        else if ( bWasShowAll )     // "show all" set for all following levels?
+        {
+            bDo = TRUE;
+            if ( !ppLevel[nPos]->getShowEmpty() )
+            {
+                //	this level is counted, following ones are not
+                bWasShowAll = FALSE;
+            }
+        }
+        if ( bDo )
+        {
+            long nThisCount = ppLevel[nPos]->GetMembersObject()->getMinMembers();
+            if ( nThisCount == 0 )
+            {
+                nTotal = 1;         //	empty level -> start counting from here
+                                    //!	start with visible elements in this level?
+            }
+            else
+            {
+                if ( nTotal >= LONG_MAX / nThisCount )
+                    return LONG_MAX;                        //	overflow
+                nTotal *= nThisCount;
+            }
+        }
+    }
+
+    //	always include data layout dim, even after restarting
+    if ( nTotal >= LONG_MAX / nDataCount )
+        return LONG_MAX;                        //	overflow
+    nTotal *= nDataCount;
+
+    return nTotal;
+}
+#else
 long lcl_CountMinMembers( ScDPDimension** ppDim, ScDPLevel** ppLevel, long nLevels )
 {
 	//	Calculate the product of the member count for those consecutive levels that
@@ -560,6 +640,7 @@
 
 	return nTotal;
 }
+#endif
 
 long lcl_GetIndexFromName( const rtl::OUString rName, const uno::Sequence<rtl::OUString>& rElements )
 {
@@ -572,10 +653,59 @@
     return -1;  // not found
 }
 
+void ScDPSource::FillCalcInfo(bool bIsRow, ScDPTableData::CalcInfo& rInfo, bool &rHasAutoShow)
+{
+    long* nDims = bIsRow ? nRowDims : nColDims;
+    long nDimCount = bIsRow ? nRowDimCount : nColDimCount;
+
+    for (long i = 0; i < nDimCount; ++i)
+    {
+        ScDPDimension* pDim = GetDimensionsObject()->getByIndex( nDims[i] );
+        long nHierarchy = pDim->getUsedHierarchy();
+        if ( nHierarchy >= pDim->GetHierarchiesObject()->getCount() )
+            nHierarchy = 0;
+        ScDPLevels* pLevels = pDim->GetHierarchiesObject()->getByIndex(nHierarchy)->GetLevelsObject();
+        long nCount = pLevels->getCount();
+
+        //!	Test
+        if ( pDim->getIsDataLayoutDimension() && nDataDimCount < 2 )
+            nCount = 0;
+        //!	Test
+
+        for (long j = 0; j < nCount; ++j)
+        {
+            ScDPLevel* pLevel = pLevels->getByIndex(j);
+            pLevel->EvaluateSortOrder();
+
+            // no layout flags for column fields, only for row fields
+            pLevel->SetEnableLayout( bIsRow );           
+
+            if ( pLevel->GetAutoShow().IsEnabled )
+                rHasAutoShow = TRUE;
+
+            if (bIsRow)
+            {
+                rInfo.aRowLevelDims.push_back(nDims[i]);
+                rInfo.aRowDims.push_back(pDim);
+                rInfo.aRowLevels.push_back(pLevel);
+            }
+            else
+            {
+                rInfo.aColLevelDims.push_back(nDims[i]);
+                rInfo.aColDims.push_back(pDim);
+                rInfo.aColLevels.push_back(pLevel);
+            }
+
+            pLevel->GetMembersObject();                 // initialize for groups
+        }
+    }
+}
+
 void ScDPSource::CreateRes_Impl()
 {
 	if ( !pResData )
 	{
+//      fprintf(stdout, "ScDPSource::CreateRes_Impl: --begins (pResData == NULL)\n");fflush(stdout);
 		USHORT nDataOrient = GetDataLayoutOrientation();
         if ( nDataDimCount > 1 && ( nDataOrient != sheet::DataPilotFieldOrientation_COLUMN &&
                                     nDataOrient != sheet::DataPilotFieldOrientation_ROW ) )
@@ -585,24 +715,37 @@
 			nDataOrient = sheet::DataPilotFieldOrientation_ROW;
 		}
 
+        // TODO: Aggreate pDataNames, pDataRefValues, nDataRefOrient, and 
+        // eDataFunctions into a structure and use vector instead of static 
+        // or pointer arrays.
 		String* pDataNames = NULL;
 		sheet::DataPilotFieldReference* pDataRefValues = NULL;
+        ScSubTotalFunc eDataFunctions[SC_DAPI_MAXFIELDS];
+		USHORT nDataRefOrient[SC_DAPI_MAXFIELDS];
 		if (nDataDimCount)
 		{
 			pDataNames = new String[nDataDimCount];
 			pDataRefValues = new sheet::DataPilotFieldReference[nDataDimCount];
 		}
 
+#if USE_NEW_CODE
+        ScDPTableData::CalcInfo aInfo;
+#else
 		long nDataSrcCols[SC_DAPI_MAXFIELDS];
-		USHORT nDataRefOrient[SC_DAPI_MAXFIELDS];
+#endif
+
 
 		//	LateInit (initialize only those rows/children that are used) can be used unless
 		//	any data dimension needs reference values from column/row dimensions
 		BOOL bLateInit = TRUE;
 
+        // Go through all data dimensions (i.e. fields) and build their meta data
+        // so that they can be passed on to ScDPResultData instance later.
+        // TODO: aggregate all of data dimension info into a structure.
 		long i;
 		for (i=0; i<nDataDimCount; i++)
 		{
+            // Get function for each data field.
 			long nDimIndex = nDataDims[i];
 			ScDPDimension* pDim = GetDimensionsObject()->getByIndex(nDimIndex);
 			sheet::GeneralFunction eUser = (sheet::GeneralFunction)pDim->getFunction();
@@ -611,7 +754,11 @@
 				//!	test for numeric data
 				eUser = sheet::GeneralFunction_SUM;
 			}
+
+            // Map UNO's enum to internal enum ScSubTotalFunc.
 			eDataFunctions[i] = ScDataUnoConversion::GeneralToSubTotal( eUser );
+
+            // Get reference field/item information.
 			pDataRefValues[i] = pDim->GetReferenceValue();
 			nDataRefOrient[i] = sheet::DataPilotFieldOrientation_HIDDEN;	// default if not used
 			sal_Int32 eRefType = pDataRefValues[i].ReferenceType;
@@ -645,10 +792,17 @@
 			//!	the complete name (function and field) must be stored at the dimension
 
 			long nSource = ((ScDPDimension*)pDim)->GetSourceDim();
+#if USE_NEW_CODE
+            if (nSource >= 0)
+                aInfo.aDataSrcCols.push_back(nSource);
+            else
+                aInfo.aDataSrcCols.push_back(nDimIndex);
+#else			
 			if ( nSource >= 0 )
 				nDataSrcCols[i] = nSource;
 			else
 				nDataSrcCols[i] = nDimIndex;
+#endif            
 		}
 
 		pResData = new ScDPResultData( this );
@@ -659,7 +813,7 @@
 		delete[] pDataNames;
 		delete[] pDataRefValues;
 
-        BOOL bHasAutoShow = FALSE;
+        bool bHasAutoShow = false;
 
         ScDPInitState aInitState;
 
@@ -674,9 +828,58 @@
                 aInitState.AddMember( nPageDims[i], pDim->GetSelectedData() );
         }
 
+//      pResData->Debug();
+
 		pColResRoot = new ScDPResultMember( pResData, NULL, NULL, NULL, bColumnGrand );
 		pRowResRoot = new ScDPResultMember( pResData, NULL, NULL, NULL, bRowGrand );
 
+#if USE_NEW_CODE
+        FillCalcInfo(false, aInfo, bHasAutoShow);
+        long nColLevelCount = aInfo.aColLevels.size();
+
+        // Some legacy code expects them to be NULL terminated (TODO: fix this!)
+//      aInfo.aColDims.push_back(NULL);
+//      aInfo.aColLevels.push_back(NULL);
+
+        pColResRoot->InitFrom( aInfo.aColDims, aInfo.aColLevels, 0, aInitState );
+        pColResRoot->SetHasElements();
+
+        FillCalcInfo(true, aInfo, bHasAutoShow);
+        long nRowLevelCount = aInfo.aRowLevels.size();
+
+        // Some legacy code expects them to be NULL terminated (TODO: fix this!)
+//      aInfo.aRowDims.push_back(NULL);
+//      aInfo.aRowLevels.push_back(NULL);
+
+        if ( nRowLevelCount > 0 )
+        {
+            // disable layout flags for the innermost row field (level)
+            aInfo.aRowLevels[nRowLevelCount-1]->SetEnableLayout( FALSE );
+        }
+
+        pRowResRoot->InitFrom( aInfo.aRowDims, aInfo.aRowLevels, 0, aInitState );
+        pRowResRoot->SetHasElements();
+
+        // initialize members object also for all page dimensions (needed for numeric groups)
+        for (i=0; i<nPageDimCount; i++)
+        {
+            ScDPDimension* pDim = GetDimensionsObject()->getByIndex( nPageDims[i] );
+            long nHierarchy = pDim->getUsedHierarchy();
+            if ( nHierarchy >= pDim->GetHierarchiesObject()->getCount() )
+                nHierarchy = 0;
+
+            ScDPLevels* pLevels = pDim->GetHierarchiesObject()->getByIndex(nHierarchy)->GetLevelsObject();
+            long nCount = pLevels->getCount();
+            for (long j=0; j<nCount; j++)
+                pLevels->getByIndex(j)->GetMembersObject();             // initialize for groups
+        }
+
+		//	pre-check: calculate minimum number of result columns / rows from
+		//	levels that have the "show all" flag set
+
+		long nMinColMembers = lcl_CountMinMembers( aInfo.aColDims, aInfo.aColLevels, nColLevelCount );
+		long nMinRowMembers = lcl_CountMinMembers( aInfo.aRowDims, aInfo.aRowLevels, nRowLevelCount );
+#else		
 		ScDPDimension* ppColDim[SC_DAPI_MAXFIELDS];		//! Ref?
 		ScDPLevel* ppColLevel[SC_DAPI_MAXFIELDS];		//! Ref?
 		long nColLevelDims[SC_DAPI_MAXFIELDS];
@@ -777,6 +980,11 @@
 
 		long nMinColMembers = lcl_CountMinMembers( ppColDim, ppColLevel, nColLevelCount );
 		long nMinRowMembers = lcl_CountMinMembers( ppRowDim, ppRowLevel, nRowLevelCount );
+#endif        
+//      fprintf(stdout, "ScDPSource::CreateRes_Impl: nColDimCount = %ld\n", nColDimCount);fflush(stdout);
+//      fprintf(stdout, "ScDPSource::CreateRes_Impl: min col members = %ld  min row members = %ld\n", nMinColMembers, nMinRowMembers);fflush(stdout);
+//      fprintf(stdout, "ScDPSource::CreateRes_Impl: nColLevelCount = %ld  nRowLevelCount = %ld\n",
+//              nColLevelCount, nRowLevelCount);fflush(stdout);
 		if ( nMinColMembers > SC_MINCOUNT_LIMIT || nMinRowMembers > SC_MINCOUNT_LIMIT )
 		{
 			//	resulting table is too big -> abort before calculating
@@ -786,6 +994,27 @@
 		}
 		else
 		{
+            {
+                vector<ScDPDimension*> aPageDims;
+                aPageDims.reserve(nPageDimCount);
+                for (i = 0; i < nPageDimCount; ++i)
+                {
+                    ScDPDimension* pDim = GetDimensionsObject()->getByIndex(nPageDims[i]);
+                    if (pDim)
+                        aPageDims.push_back(pDim);
+                }
+                pData->FilterCacheTable(aPageDims);
+            }
+#if USE_NEW_CODE
+            aInfo.aPageDims.reserve(nPageDimCount);
+            for (i = 0; i < nPageDimCount; ++i)
+                aInfo.aPageDims.push_back(nPageDims[i]);
+
+            aInfo.pInitState = &aInitState;
+            aInfo.pColRoot   = pColResRoot;
+            aInfo.pRowRoot   = pRowResRoot;
+            pData->CalcResults(aInfo, false);
+#else
 			ScDPItemData aColData[SC_DAPI_MAXFIELDS];
 			ScDPItemData aRowData[SC_DAPI_MAXFIELDS];
 			ScDPItemData aPageData[SC_DAPI_MAXFIELDS];
@@ -829,6 +1058,7 @@
 					}
 				}
 			}
+#endif            
 
 			// ----------------------------------------------------------------
 			//  With all data processed, calculate the final results:
@@ -839,6 +1069,7 @@
 
 			if ( bHasAutoShow )     // do the double calculation only if AutoShow is used
 			{
+//              fprintf(stdout, "ScDPSource::CreateRes_Impl: AutoShow is enabled\n");fflush(stdout);
 			    //  Find the desired members and set bAutoHidden flag for the others
     			pRowResRoot->DoAutoShow( pColResRoot );
 
@@ -846,7 +1077,9 @@
     			//  desired members only.
     			pColResRoot->ResetResults( TRUE );
     			pRowResRoot->ResetResults( TRUE );
-
+#if USE_NEW_CODE
+                pData->CalcResults(aInfo, true);
+#else
     			//  Again loop over the source data.
     			//  LateInitFrom is not needed again.
     			pData->ResetIterator();
@@ -861,10 +1094,15 @@
     					pRowResRoot->ProcessData( aRowData, pColResRoot->GetChildDimension(), aColData, aValues );
     				}
     			}
+#endif                
 
     			//  Call UpdateDataResults again, with the new (limited) values.
     			pRowResRoot->UpdateDataResults( pColResRoot, pResData->GetRowStartMeasure() );
 			}
+            else
+            {
+//              fprintf(stdout, "ScDPSource::CreateRes_Impl: AutoShow is disabled.\n");fflush(stdout);
+            }
 
 			//  SortMembers does the sorting by a result dimension, using the orginal results,
 			//  but not running totals etc.
@@ -883,6 +1121,7 @@
 
 			// ----------------------------------------------------------------
 		}
+//      fprintf(stdout, "ScDPSource::CreateRes_Impl: --ends\n");fflush(stdout);
 	}
 }
 
@@ -1079,6 +1318,12 @@
 		lcl_SetBoolInAny( aRet, getRepeatIfEmpty() );
 	else if ( aNameStr.EqualsAscii( SC_UNO_DATADESC ) )				// read-only
 		aRet <<= rtl::OUString( getDataDescription() );
+    else if ( aNameStr.EqualsAscii("RowFieldCount") )
+        aRet <<= static_cast<sal_Int32>(nRowDimCount);
+    else if ( aNameStr.EqualsAscii("ColumnFieldCount") )
+        aRet <<= static_cast<sal_Int32>(nColDimCount);
+    else if ( aNameStr.EqualsAscii("DataFieldCount") )
+        aRet <<= static_cast<sal_Int32>(nDataDimCount);
 	else
 	{
 		DBG_ERROR("unknown property");
Index: sc/source/core/data/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/core/data/makefile.mk,v
retrieving revision 1.21
retrieving revision 1.21.202.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 -r1.21.202.1
--- sc/source/core/data/makefile.mk	27 Feb 2007 12:06:42 -0000	1.21
+++ sc/source/core/data/makefile.mk	29 Oct 2007 17:44:40 -0000	1.21.202.1
@@ -77,6 +77,7 @@
 	$(SLO)$/documen8.obj \
 	$(SLO)$/documen9.obj \
 	$(SLO)$/document.obj \
+        $(SLO)$/dpcachetable.obj \
         $(SLO)$/dpdimsave.obj \
         $(SLO)$/dpgroup.obj \
 	$(SLO)$/dpobject.obj \
@@ -131,6 +132,7 @@
 	$(SLO)$/documen5.obj \
 	$(SLO)$/documen6.obj \
 	$(SLO)$/documen9.obj \
+        $(SLO)$/dpcachetable.obj \
 	$(SLO)$/dpsdbtab.obj \
 	$(SLO)$/dpobject.obj \
 	$(SLO)$/dpoutput.obj \
Index: sc/source/ui/unoobj/dapiuno.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/unoobj/dapiuno.cxx,v
retrieving revision 1.19
retrieving revision 1.19.202.3
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.19 -r1.19.202.3
--- sc/source/ui/unoobj/dapiuno.cxx	27 Feb 2007 13:42:43 -0000	1.19
+++ sc/source/ui/unoobj/dapiuno.cxx	8 Nov 2007 18:03:20 -0000	1.19.202.3
@@ -76,12 +76,23 @@
 #include <com/sun/star/sheet/DataPilotFieldGroupBy.hpp>
 #endif
 
+#include <com/sun/star/sheet/DataPilotFieldFilter.hpp>
+#include <com/sun/star/sheet/DataPilotTableRegion.hpp>
+#include <com/sun/star/sheet/DataPilotTablePositionData.hpp>
+
 #ifndef _COMPHELPER_EXTRACT_HXX_
 #include <comphelper/extract.hxx>
 #endif
 
 using namespace com::sun::star;
 
+using ::com::sun::star::sheet::DataPilotFieldFilter;
+using ::com::sun::star::sheet::DataPilotTablePositionData;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::table::CellAddress;
+using ::com::sun::star::table::CellRangeAddress;
+using ::com::sun::star::uno::RuntimeException;
+using ::com::sun::star::uno::Any;
 
 //------------------------------------------------------------------------
 
@@ -531,7 +542,7 @@
 									lang::WrappedTargetException, uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	uno::Reference<sheet::XDataPilotTable> xTable(GetObjectByIndex_Impl(static_cast<SCSIZE>(nIndex)));
+    uno::Reference<sheet::XDataPilotTable2> xTable(GetObjectByIndex_Impl(static_cast<SCSIZE>(nIndex)));
 	if (xTable.is())
         return uno::makeAny(xTable);
 	else
@@ -542,7 +553,7 @@
 uno::Type SAL_CALL ScDataPilotTablesObj::getElementType() throw(uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	return getCppuType((uno::Reference<sheet::XDataPilotTable>*)0);
+    return getCppuType((uno::Reference<sheet::XDataPilotTable2>*)0);
 }
 
 sal_Bool SAL_CALL ScDataPilotTablesObj::hasElements() throw(uno::RuntimeException)
@@ -558,7 +569,7 @@
 					lang::WrappedTargetException, uno::RuntimeException)
 {
 	ScUnoGuard aGuard;
-	uno::Reference<sheet::XDataPilotTable> xTable(GetObjectByName_Impl(aName));
+    uno::Reference<sheet::XDataPilotTable2> xTable(GetObjectByName_Impl(aName));
 	if (xTable.is())
         return uno::makeAny(xTable);
 	else
@@ -1013,7 +1024,7 @@
 uno::Any SAL_CALL ScDataPilotTableObj::queryInterface( const uno::Type& rType )
 												throw(uno::RuntimeException)
 {
-	SC_QUERYINTERFACE( sheet::XDataPilotTable )
+    SC_QUERYINTERFACE( sheet::XDataPilotTable2 )
 
 	return ScDataPilotDescriptorBase::queryInterface( rType );
 }
@@ -1040,7 +1051,7 @@
 
 		aTypes.realloc( nParentLen + 1 );
 		uno::Type* pPtr = aTypes.getArray();
-		pPtr[nParentLen + 0] = getCppuType((const uno::Reference<sheet::XDataPilotTable>*)0);
+        pPtr[nParentLen + 0] = getCppuType((const uno::Reference<sheet::XDataPilotTable2>*)0);
 
 		for (long i=0; i<nParentLen; i++)
 			pPtr[i] = pParentPtr[i];				// parent types first
@@ -1163,6 +1174,43 @@
 	}
 }
 
+Sequence< Sequence<Any> > SAL_CALL ScDataPilotTableObj::getDrillDownData(const CellAddress& aAddr)
+    throw (RuntimeException)
+{
+    Sequence< Sequence<Any> > aTabData;
+    ScAddress aAddr2(aAddr.Column, aAddr.Row, aAddr.Sheet);
+    GetDPObject()->GetDrillDownData(aAddr2, aTabData);
+    return aTabData;
+}
+
+DataPilotTablePositionData SAL_CALL ScDataPilotTableObj::getPositionData(const CellAddress& aAddr)
+    throw (RuntimeException)
+{
+    DataPilotTablePositionData aPosData;
+    ScAddress aAddr2(aAddr.Column, aAddr.Row, aAddr.Sheet);
+    GetDPObject()->GetPositionData(aAddr2, aPosData);
+    return aPosData;
+}
+
+CellRangeAddress SAL_CALL ScDataPilotTableObj::getOutputRangeByType( sal_Int32 nType )
+    throw (RuntimeException)
+{
+    ScUnoGuard aGuard;
+    table::CellRangeAddress aRet;
+    ScDPObject* pDPObj = lcl_GetDPObject(GetDocShell(), nTab, aName);
+    if (!pDPObj)
+        return aRet;
+
+    const ScRange aRange = pDPObj->GetOutputRangeByType(nType);
+    aRet.Sheet       = aRange.aStart.Tab();
+    aRet.StartColumn = aRange.aStart.Col();
+    aRet.StartRow    = aRange.aStart.Row();
+    aRet.EndColumn   = aRange.aEnd.Col();
+    aRet.EndRow      = aRange.aEnd.Row();
+
+    return aRet;
+}
+
 //------------------------------------------------------------------------
 
 ScDataPilotDescriptor::ScDataPilotDescriptor(ScDocShell* pDocSh) :
Index: sc/source/ui/view/cellsh1.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/cellsh1.cxx,v
retrieving revision 1.46
retrieving revision 1.46.172.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.46 -r1.46.172.1
--- sc/source/ui/view/cellsh1.cxx	26 Apr 2007 09:55:48 -0000	1.46
+++ sc/source/ui/view/cellsh1.cxx	29 Oct 2007 17:44:41 -0000	1.46.172.1
@@ -35,7 +35,7 @@
 
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
-
+#include <stdio.h>
 
 //------------------------------------------------------------------
 
Index: sc/source/ui/view/dbfunc3.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/dbfunc3.cxx,v
retrieving revision 1.13
retrieving revision 1.13.202.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.13 -r1.13.202.1
--- sc/source/ui/view/dbfunc3.cxx	27 Feb 2007 13:49:45 -0000	1.13
+++ sc/source/ui/view/dbfunc3.cxx	29 Oct 2007 17:44:41 -0000	1.13.202.1
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
Index: sc/source/ui/view/gridwin.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/gridwin.cxx,v
retrieving revision 1.85
retrieving revision 1.85.36.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.85 -r1.85.36.1
--- sc/source/ui/view/gridwin.cxx	27 Sep 2007 13:56:11 -0000	1.85
+++ sc/source/ui/view/gridwin.cxx	29 Oct 2007 17:44:41 -0000	1.85.36.1
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 //------------------------------------------------------------------
 
@@ -159,6 +159,8 @@
 #endif
 
 using namespace com::sun::star;
+using ::com::sun::star::uno::Sequence;
+using ::com::sun::star::uno::Any;
 
 const BYTE SC_NESTEDBUTTON_NONE = 0;
 const BYTE SC_NESTEDBUTTON_DOWN = 1;
@@ -2032,7 +2034,38 @@
                 }
 			}
 			else
-				Sound::Beep();		// nothing to expand/collapse
+            {
+                // Check if the data area is double-clicked.
+                Sequence< Sequence<Any> > aArrayData;
+                pDPObj->GetDrillDownData(aCellPos, aArrayData);
+                sal_Int32 nRowSize = aArrayData.getLength();
+                if (nRowSize > 0)
+                {
+                    ScTabViewShell* pViewShell = pViewData->GetViewShell();
+                    String aNewTabName;
+                    pViewData->GetDocument()->CreateValidTabName(aNewTabName);
+                    SCTAB nNewTab = pViewData->GetTabNo();
+                    if ( pViewShell->InsertTable(aNewTabName, nNewTab, false) )
+                    {
+                        for (sal_Int32 nRow = 0; nRow < nRowSize; ++nRow)
+                        {
+                            sal_Int32 nColSize = aArrayData[nRow].getLength();
+                            for (sal_Int32 nCol = 0; nCol < nColSize; ++nCol)
+                            {
+                                const Any& rAny = aArrayData[nRow][nCol];
+                                rtl::OUString aStr;
+                                double fVal;
+                                if (rAny >>= aStr)
+                                    pDoc->SetString(nCol, nRow, nNewTab, String(aStr));
+                                else if (rAny >>= fVal)
+                                    pDoc->SetValue(nCol, nRow, nNewTab, fVal);
+                            }
+                        }
+                    }
+                }
+                else
+                    ::Sound::Beep();
+            }
 
 			return;
 		}
? offapi/offapi.vpj
? offapi/offapi_project.sca
Index: offapi/com/sun/star/sheet/DataPilotFieldFilter.idl
===================================================================
RCS file: offapi/com/sun/star/sheet/DataPilotFieldFilter.idl
diff -N offapi/com/sun/star/sheet/DataPilotFieldFilter.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ offapi/com/sun/star/sheet/DataPilotFieldFilter.idl	29 Oct 2007 17:42:54 -0000	1.1.2.1
@@ -0,0 +1,59 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: DataPilotFieldFilter.idl,v $
+ *
+ *  $Revision: 1.1.2.1 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/10/29 17:42:54 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_sheet_DataPilotFieldFilter_idl__
+#define __com_sun_star_sheet_DataPilotFieldFilter_idl__
+
+//=============================================================================
+
+module com {  module sun {  module star {  module sheet {
+
+//=============================================================================
+
+struct DataPilotFieldFilter
+{
+    /** Field name. */
+    string FieldName;
+
+    /** String value that needs to match against. */
+    string MatchValue;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
+
Index: offapi/com/sun/star/sheet/DataPilotTablePositionData.idl
===================================================================
RCS file: offapi/com/sun/star/sheet/DataPilotTablePositionData.idl
diff -N offapi/com/sun/star/sheet/DataPilotTablePositionData.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ offapi/com/sun/star/sheet/DataPilotTablePositionData.idl	8 Nov 2007 17:56:41 -0000	1.1.2.1
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: DataPilotTablePositionData.idl,v $
+ *
+ *  $Revision: 1.1.2.1 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/11/08 17:56:41 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_sheet_DataPilotTablePositionData_idl__
+#define __com_sun_star_sheet_DataPilotTablePositionData_idl__
+
+#include <com/sun/star/sheet/DataPilotFieldFilter.idl>
+
+//=============================================================================
+
+module com {  module sun {  module star {  module sheet {
+
+//=============================================================================
+
+struct DataPilotTablePositionData
+{
+    /** See DataPilotTablePositionType. */
+    long    PositionType;
+
+    /** Different depending on the position type. */
+    any     PositionData;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
+
Index: offapi/com/sun/star/sheet/DataPilotTablePositionType.idl
===================================================================
RCS file: offapi/com/sun/star/sheet/DataPilotTablePositionType.idl
diff -N offapi/com/sun/star/sheet/DataPilotTablePositionType.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ offapi/com/sun/star/sheet/DataPilotTablePositionType.idl	19 Nov 2007 22:25:26 -0000	1.1.2.2
@@ -0,0 +1,35 @@
+#ifndef __com_sun_star_sheet_DataPilotTablePositionType_idl__
+#define __com_sun_star_sheet_DataPilotTablePositionType_idl__
+
+module com { module sun { module star { module sheet {
+
+//============================================================================
+
+constants DataPilotTablePositionType
+{
+	//------------------------------------------------------------------------
+
+	const long NOT_IN_TABLE = 0;
+
+	//------------------------------------------------------------------------
+
+	const long RESULT = 1;
+
+	//------------------------------------------------------------------------
+
+    const long ROW_HEADER = 2;
+
+	//------------------------------------------------------------------------
+
+    const long COLUMN_HEADER = 3;
+
+	//------------------------------------------------------------------------
+};
+
+//============================================================================
+
+}; }; }; };
+
+
+
+#endif
Index: offapi/com/sun/star/sheet/DataPilotTableRegion.idl
===================================================================
RCS file: offapi/com/sun/star/sheet/DataPilotTableRegion.idl
diff -N offapi/com/sun/star/sheet/DataPilotTableRegion.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ offapi/com/sun/star/sheet/DataPilotTableRegion.idl	8 Nov 2007 17:56:42 -0000	1.1.2.2
@@ -0,0 +1,29 @@
+#ifndef __com_sun_star_sheet_DataPilotTableRegion_idl__
+#define __com_sun_star_sheet_DataPilotTableRegion_idl__
+
+module com { module sun { module star { module sheet {
+
+//============================================================================
+
+constants DataPilotTableRegion
+{
+	//------------------------------------------------------------------------
+
+	const long WHOLE = 0;
+
+	//------------------------------------------------------------------------
+
+	const long TABLE = 1;
+
+	//------------------------------------------------------------------------
+
+    const long RESULT = 2;
+};
+
+//============================================================================
+
+}; }; }; };
+
+
+
+#endif
Index: offapi/com/sun/star/sheet/DataPilotTableResultData.idl
===================================================================
RCS file: offapi/com/sun/star/sheet/DataPilotTableResultData.idl
diff -N offapi/com/sun/star/sheet/DataPilotTableResultData.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ offapi/com/sun/star/sheet/DataPilotTableResultData.idl	19 Nov 2007 22:25:26 -0000	1.1.2.2
@@ -0,0 +1,27 @@
+#ifndef __com_sun_star_sheet_DataPilotTableResultData_idl__
+#define __com_sun_star_sheet_DataPilotTableResultData_idl__
+
+#include <com/sun/star/sheet/DataPilotFieldFilter.idl>
+#include <com/sun/star/sheet/DataResult.idl>
+
+//=============================================================================
+
+module com {  module sun {  module star {  module sheet {
+
+//=============================================================================
+
+struct DataPilotTableResultData
+{
+    sequence< DataPilotFieldFilter >    FieldFilters;
+
+    long                                DataFieldIndex;
+
+    DataResult                          Result;
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
+
Index: offapi/com/sun/star/sheet/XDataPilotTable2.idl
===================================================================
RCS file: offapi/com/sun/star/sheet/XDataPilotTable2.idl
diff -N offapi/com/sun/star/sheet/XDataPilotTable2.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ offapi/com/sun/star/sheet/XDataPilotTable2.idl	8 Nov 2007 17:56:42 -0000	1.1.2.3
@@ -0,0 +1,79 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XDataPilotTable2.idl,v $
+ *
+ *  $Revision: 1.1.2.3 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/11/08 17:56:42 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_sheet_XDataPilotTable2_idl__
+#define __com_sun_star_sheet_XDataPilotTable2_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __com_sun_star_table_CellAddress_idl__
+#include <com/sun/star/table/CellAddress.idl>
+#endif
+
+#ifndef __com_sun_star_table_CellRangeAddress_idl__
+#include <com/sun/star/table/CellRangeAddress.idl>
+#endif
+
+#ifndef __com_sun_star_sheet_XDataPilotTable_idl__
+#include <com/sun/star/sheet/XDataPilotTable.idl>
+#endif
+
+#ifndef __com_sun_star_sheet_DataPilotTableRegion_idl__
+#include <com/sun/star/sheet/DataPilotTableRegion.idl>
+#endif
+
+#ifndef __com_sun_star_sheet_DataPilotFieldFilter_idl__
+#include <com/sun/star/sheet/DataPilotFieldFilter.idl>
+#endif
+
+#include <com/sun/star/sheet/DataPilotTablePositionData.idl>
+
+module com {  module sun {  module star {  module sheet {
+
+interface XDataPilotTable2: com::sun::star::sheet::XDataPilotTable
+{
+    sequence< sequence< any > > getDrillDownData( [in] com::sun::star::table::CellAddress aAddr );
+
+    DataPilotTablePositionData getPositionData( [in] com::sun::star::table::CellAddress aAddr );
+
+    com::sun::star::table::CellRangeAddress getOutputRangeByType( [in] long nRegionType );
+};
+
+}; }; }; };
+
+#endif
+
Index: offapi/com/sun/star/sheet/XDrillDownDataSupplier.idl
===================================================================
RCS file: offapi/com/sun/star/sheet/XDrillDownDataSupplier.idl
diff -N offapi/com/sun/star/sheet/XDrillDownDataSupplier.idl
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ offapi/com/sun/star/sheet/XDrillDownDataSupplier.idl	29 Oct 2007 17:42:54 -0000	1.1.2.1
@@ -0,0 +1,68 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XDrillDownDataSupplier.idl,v $
+ *
+ *  $Revision: 1.1.2.1 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/10/29 17:42:54 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef __com_sun_star_sheet_XDrillDownDataSupplier_idl__
+#define __com_sun_star_sheet_XDrillDownDataSupplier_idl__
+
+#ifndef __com_sun_star_uno_XInterface_idl__
+#include <com/sun/star/uno/XInterface.idl>
+#endif
+
+#ifndef __com_sun_star_sheet_DataPilotFieldFilter_idl__
+#include <com/sun/star/sheet/DataPilotFieldFilter.idl>
+#endif
+
+#ifndef __com_sun_star_table_CellAddress_idl__
+#include <com/sun/star/table/CellAddress.idl>
+#endif
+
+//=============================================================================
+
+module com {  module sun {  module star {  module sheet {
+
+//=============================================================================
+
+interface XDrillDownDataSupplier: com::sun::star::uno::XInterface
+{
+    sequence< sequence< any > > getDrillDownData( 
+        [in] sequence< com::sun::star::sheet::DataPilotFieldFilter > aFilters );
+};
+
+//=============================================================================
+
+}; }; }; };
+
+#endif
+
diff -urp offapi.ooo-build/com/sun/star/sheet/makefile.mk offapi/com/sun/star/sheet/makefile.mk
--- offapi.ooo-build/com/sun/star/sheet/makefile.mk	2007-11-20 12:00:48.000000000 -0500
+++ offapi/com/sun/star/sheet/makefile.mk	2007-11-20 12:02:05.000000000 -0500
@@ -310,7 +310,14 @@ IDLFILES=\
 	XViewPanesSupplier.idl\
 	XViewSplitable.idl\
 	XVolatileResult.idl\
-	_NamedRange.idl
+	_NamedRange.idl\
+	DataPilotFieldFilter.idl\
+	DataPilotTablePositionData.idl\
+	DataPilotTablePositionType.idl\
+	DataPilotTableRegion.idl\
+	DataPilotTableResultData.idl\
+	XDataPilotTable2.idl\
+	XDrillDownDataSupplier.idl
 
 # ------------------------------------------------------------------
 
