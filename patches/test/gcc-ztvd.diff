diff -u -r /share/gcc-pristine/cp/class.c cp/class.c
--- /share/gcc-pristine/cp/class.c	2005-08-09 15:45:55.000000000 +0100
+++ cp/class.c	2005-08-09 15:45:28.087906616 +0100
@@ -169,6 +169,7 @@
 static void dump_thunk (FILE *, int, tree);
 static tree build_vtable (tree, tree, tree);
 static void initialize_vtable (tree, tree);
+static void initialize_vtable_description (tree, tree, tree);
 static void layout_nonempty_base_or_field (record_layout_info,
 					   tree, tree, splay_tree);
 static tree end_of_class (tree, int);
@@ -6609,7 +6610,10 @@
     }
 
   if (BINFO_VTABLE (TYPE_BINFO (t)))
-    initialize_vtable (TYPE_BINFO (t), TREE_VALUE (list));
+    {
+      initialize_vtable (TYPE_BINFO (t), TREE_VALUE (list));
+      initialize_vtable_description (t, TYPE_BINFO (t), TREE_VALUE (list));
+    }
 }
 
 /* Initialize the vtable for BINFO with the INITS.  */
@@ -6625,6 +6629,60 @@
   dump_vtable (BINFO_TYPE (binfo), binfo, decl);
 }
 
+
+static tree
+build_string_literal (int len, const char *str)
+{
+  tree t, elem, index, type;
+
+  t = build_string (len, str);
+  elem = build_type_variant (char_type_node, 1, 0);
+  index = build_index_type (build_int_cst (NULL_TREE, len - 1));
+  type = build_array_type (elem, index);
+  TREE_TYPE (t) = type;
+  TREE_CONSTANT (t) = 1;
+  TREE_INVARIANT (t) = 1;
+  TREE_READONLY (t) = 1;
+  TREE_STATIC (t) = 1;
+
+  return t;
+}
+
+/* Create initializers for vtable descriptors */
+static void
+initialize_vtable_description (tree type, tree binfo, tree vt_inits)
+{
+    tree decl, clist, carray;
+    tree name = mangle_vtbl_descr_for_type (type);
+
+    decl = build_vtable (type, name, vtbl_descr_type_node);
+    carray = build_cplus_array_type (string_type_node,
+				     build_index_type (size_int (list_length (vt_inits) - 1)));
+    layout_type (carray);
+    TREE_TYPE (decl) = carray;
+    DECL_SIZE (decl) = DECL_SIZE_UNIT (decl) = NULL_TREE;
+    layout_decl (decl, 0);
+
+    clist = build_tree_list (string_type_node, NULL_TREE);
+    TREE_VALUE (clist) = build_string_literal (strlen ("ZTVD") + 1, "ZTVD");
+    /* Critical - for output - what is it for ? */
+    TREE_PURPOSE (clist) = NULL_TREE;
+
+    //    warning ("Type size of descr %qD is %T from node type %T",
+    //	     decl, TREE_TYPE (decl), vtbl_descr_type_node);
+
+    initialize_artificial_var (decl, clist);
+
+    // FIXME: looks broken (?)
+    if (!CLASSTYPE_VTABLE_DESCRS (type))
+        CLASSTYPE_VTABLE_DESCRS (type) = decl;
+    else
+    {
+        TREE_CHAIN (decl) = TREE_CHAIN (CLASSTYPE_VTABLE_DESCRS (type));
+	TREE_CHAIN (CLASSTYPE_VTABLE_DESCRS (type)) = decl;
+    }
+}
+
 /* Build the VTT (virtual table table) for T.
    A class requires a VTT if it has virtual bases.
    
diff -u -r /share/gcc-pristine/cp/class.c~ cp/class.c~
--- /share/gcc-pristine/cp/class.c~	2005-08-06 20:50:56.000000000 +0100
+++ cp/class.c~	2005-08-08 16:07:49.000000000 +0100
@@ -6629,24 +6629,47 @@
   dump_vtable (BINFO_TYPE (binfo), binfo, decl);
 }
 
-/* A vector of all tinfo decls that haven't yet been emitted.  */
-// VEC (tree) *unemitted_tinfo_decls;
 
+static tree
+build_string_literal (int len, const char *str)
+{
+  tree t, elem, index, type;
+
+  t = build_string (len, str);
+  elem = build_type_variant (char_type_node, 1, 0);
+  index = build_index_type (build_int_cst (NULL_TREE, len - 1));
+  type = build_array_type (elem, index);
+  TREE_TYPE (t) = type;
+  TREE_CONSTANT (t) = 1;
+  TREE_INVARIANT (t) = 1;
+  TREE_READONLY (t) = 1;
+  TREE_STATIC (t) = 1;
+
+  type = build_pointer_type (type);
+  t = build1 (ADDR_EXPR, type, t);
+
+  type = build_pointer_type (elem);
+  t = build1 (NOP_EXPR, type, t);
+
+  return t;
+}
+
+/* Create initializers for vtable descriptors */
 static void
 initialize_vtable_description (tree type, tree binfo, tree vt_inits)
 {
-    tree decl;
-    tree content;
+    tree decl, content, clist;
 
-    fprintf (stderr, "init vtable descr\n");
-
-    content = build_string (strlen ("ZTVD") + 1, "ZTVD");
     tree name = mangle_vtbl_descr_for_type (type);
-    decl = build_vtable (type, name, string_type_node); //vtbl_descr_type_node);
+    decl = build_vtable (type, name, vtbl_descr_type_node);
+
+    clist = build_tree_list (build_pointer_type (string_type_node), NULL_TREE);
+    TREE_VALUE (clist) = chainon (TREE_VALUE (clist),
+				  build_string_literal (strlen ("ZTVD") + 1, "ZTVD"));
 
-    initialize_artificial_var (decl, content);
+    initialize_artificial_var (decl, clist);
 
-    // FIXME: looks deadly broken ...
+    // FIXME: looks broken (?)
     if (!CLASSTYPE_VTABLE_DESCRS (type))
         CLASSTYPE_VTABLE_DESCRS (type) = decl;
     else
Only in /share/gcc-pristine/cp: cppdefault.c
Only in /share/gcc-pristine/cp: cppdefault.h
Only in /share/gcc-pristine/cp: cppspec.c
diff -u -r /share/gcc-pristine/cp/cp-tree.h cp/cp-tree.h
--- /share/gcc-pristine/cp/cp-tree.h	2005-08-09 15:45:55.000000000 +0100
+++ cp/cp-tree.h	2005-08-08 16:07:49.000000000 +0100
@@ -484,6 +484,7 @@
     CPTI_UNKNOWN_TYPE,
     CPTI_VTBL_TYPE,
     CPTI_VTBL_PTR_TYPE,
+    CPTI_VTBL_DESCR_TYPE,
     CPTI_STD,
     CPTI_ABI,
     CPTI_CONST_TYPE_INFO_TYPE,
@@ -560,6 +561,7 @@
 #define unknown_type_node		cp_global_trees[CPTI_UNKNOWN_TYPE]
 #define vtbl_type_node			cp_global_trees[CPTI_VTBL_TYPE]
 #define vtbl_ptr_type_node		cp_global_trees[CPTI_VTBL_PTR_TYPE]
+#define vtbl_descr_type_node		cp_global_trees[CPTI_VTBL_DESCR_TYPE]
 #define std_node			cp_global_trees[CPTI_STD]
 #define abi_node                        cp_global_trees[CPTI_ABI]
 #define const_type_info_type_node	cp_global_trees[CPTI_CONST_TYPE_INFO_TYPE]
@@ -1052,6 +1054,7 @@
   tree primary_base;
   VEC (tree_pair_s) *vcall_indices;
   tree vtables;
+  tree vtable_descrs;
   tree typeinfo_var;
   VEC (tree) *vbases;
   binding_table nested_udts;
@@ -1444,6 +1447,10 @@
 #define CLASSTYPE_VTABLES(NODE) \
   (LANG_TYPE_CLASS_CHECK (NODE)->vtables)
 
+/* Vtable descriptions for the class NODE. */
+#define CLASSTYPE_VTABLE_DESCRS(NODE) \
+  (LANG_TYPE_CLASS_CHECK (NODE)->vtable_descrs)
+
 /* The std::type_info variable representing this class, or NULL if no
    such variable has been created.  This field is only set for the
    TYPE_MAIN_VARIANT of the class.  */
@@ -4365,6 +4372,7 @@
 extern tree mangle_typeinfo_for_type            (tree);
 extern tree mangle_typeinfo_string_for_type     (tree);
 extern tree mangle_vtbl_for_type                (tree);
+extern tree mangle_vtbl_descr_for_type          (tree);
 extern tree mangle_vtt_for_type                 (tree);
 extern tree mangle_ctor_vtbl_for_type           (tree, tree);
 extern tree mangle_thunk                        (tree, int, tree, tree);
diff -u -r /share/gcc-pristine/cp/cp-tree.h~ cp/cp-tree.h~
--- /share/gcc-pristine/cp/cp-tree.h~	2005-07-29 13:47:34.000000000 +0100
+++ cp/cp-tree.h~	2005-06-24 17:33:07.000000000 +0100
@@ -1052,7 +1052,6 @@
   tree primary_base;
   VEC (tree_pair_s) *vcall_indices;
   tree vtables;
-  tree vtable_descrs;
   tree typeinfo_var;
   VEC (tree) *vbases;
   binding_table nested_udts;
@@ -1445,10 +1444,6 @@
 #define CLASSTYPE_VTABLES(NODE) \
   (LANG_TYPE_CLASS_CHECK (NODE)->vtables)
 
-/* Vtable descriptions for the class NODE. */
-#define CLASSTYPE_VTABLE_DESCRS(NODE) \
-  (LANG_TYPE_CLASS_CHECK (NODE)->vtables)
-
 /* The std::type_info variable representing this class, or NULL if no
    such variable has been created.  This field is only set for the
    TYPE_MAIN_VARIANT of the class.  */
@@ -4370,7 +4365,6 @@
 extern tree mangle_typeinfo_for_type            (tree);
 extern tree mangle_typeinfo_string_for_type     (tree);
 extern tree mangle_vtbl_for_type                (tree);
-extern tree mangle_vtbl_descr_for_type          (tree);
 extern tree mangle_vtt_for_type                 (tree);
 extern tree mangle_ctor_vtbl_for_type           (tree, tree);
 extern tree mangle_thunk                        (tree, int, tree, tree);
diff -u -r /share/gcc-pristine/cp/decl2.c cp/decl2.c
--- /share/gcc-pristine/cp/decl2.c	2005-08-09 15:45:55.000000000 +0100
+++ cp/decl2.c	2005-08-09 15:40:11.426046536 +0100
@@ -1514,6 +1514,35 @@
 /* If necessary, write out the vtables for the dynamic class CTYPE.
    Returns true if any vtables were emitted.  */
 
+static void
+emit_vt_descrs (tree ctype)
+{
+  tree vtbl;
+
+  for (vtbl = CLASSTYPE_VTABLE_DESCRS (ctype); vtbl; vtbl = TREE_CHAIN (vtbl))
+    {
+      tree content;
+
+//      fprintf (stderr, "Finish TVDecl\n");
+      TREE_PUBLIC (vtbl) = 1;
+      DECL_EXTERNAL (vtbl) = 1;
+      DECL_INTERFACE_KNOWN (vtbl) = 1;
+      import_export_decl (vtbl);
+      mark_used (vtbl);
+
+      if (TREE_TYPE (DECL_INITIAL (vtbl)) == 0)
+	{
+	  tree expr = store_init_value (vtbl, DECL_INITIAL (vtbl));
+	  
+	  /* It had better be all done at compile-time.  */
+	  gcc_assert (!expr);
+	}
+
+      DECL_EXTERNAL (vtbl) = 0;
+      rest_of_decl_compilation (vtbl, 1, 1);
+    }
+}    
+
 static bool
 maybe_emit_vtables (tree ctype)
 {
@@ -1583,6 +1612,8 @@
      info.  */
   note_debug_info_needed (ctype);
 
+  emit_vt_descrs (ctype);
+
   return true;
 }
 
diff -u -r /share/gcc-pristine/cp/decl2.c~ cp/decl2.c~
--- /share/gcc-pristine/cp/decl2.c~	2005-08-06 20:51:48.000000000 +0100
+++ cp/decl2.c~	2005-08-08 16:07:49.000000000 +0100
@@ -1514,6 +1514,30 @@
 /* If necessary, write out the vtables for the dynamic class CTYPE.
    Returns true if any vtables were emitted.  */
 
+static tree
+build_string_literal (int len, const char *str)
+{
+  tree t, elem, index, type;
+
+  t = build_string (len, str);
+  elem = build_type_variant (char_type_node, 1, 0);
+  index = build_index_type (build_int_cst (NULL_TREE, len - 1));
+  type = build_array_type (elem, index);
+  TREE_TYPE (t) = type;
+  TREE_CONSTANT (t) = 1;
+  TREE_INVARIANT (t) = 1;
+  TREE_READONLY (t) = 1;
+  TREE_STATIC (t) = 1;
+
+  type = build_pointer_type (type);
+  t = build1 (ADDR_EXPR, type, t);
+
+  type = build_pointer_type (elem);
+  t = build1 (NOP_EXPR, type, t);
+
+  return t;
+}
+
 static void
 emit_vt_descrs (tree ctype)
 {
@@ -1524,12 +1548,16 @@
       tree content;
 
       fprintf (stderr, "Finish TVDecl\n");
+      TREE_PUBLIC (vtbl) = 1;
+      DECL_EXTERNAL (vtbl) = 1;
+      DECL_INTERFACE_KNOWN (vtbl) = 1;
       import_export_decl (vtbl);
-      DECL_EXTERNAL (vtbl) = 0;
       mark_used (vtbl);
-      content = build_string (strlen ("ZTVD") + 1, "ZTVD");
-
+      DECL_EXTERNAL (vtbl) = 0;
+      //      content = build_string_literal (strlen ("ZTVD") + 1, "ZTVD");
+      //      DECL_INITIAL (vtbl) = content; // initial value ?
       cp_finish_decl (vtbl, content, NULL_TREE, 0);
+      rest_of_decl_compilation (vtbl, 1, 1);
     }
 }    
 
diff -u -r /share/gcc-pristine/cp/decl.c cp/decl.c
--- /share/gcc-pristine/cp/decl.c	2005-08-09 15:45:55.000000000 +0100
+++ cp/decl.c	2005-08-09 14:28:22.351125496 +0100
@@ -142,6 +142,7 @@
 
 	tree vtbl_type_node;
 	tree vtbl_ptr_type_node;
+	tree vtbl_descr_type_node;
 
    Namespaces,
 
@@ -2984,6 +2985,24 @@
   layout_type (vtbl_ptr_type_node);
   record_builtin_type (RID_MAX, NULL, vtbl_ptr_type_node);
 
+  vtbl_descr_type_node
+    = build_cplus_array_type (string_type_node, NULL_TREE);
+  fprintf (stderr, "Setup vtbl_descr_type_node %p\n", vtbl_descr_type_node);
+  layout_type (vtbl_descr_type_node);
+  if (!TYPE_SIZE (vtbl_descr_type_node))
+	  fprintf (stderr, "UNFAIR!\n");
+  fprintf (stderr, "Setup vtbl_descr_type_node 2 %p\n", vtbl_descr_type_node);
+  vtbl_descr_type_node = build_qualified_type (vtbl_descr_type_node, TYPE_QUAL_CONST);
+  if (!TYPE_SIZE (vtbl_descr_type_node))
+	  {
+	  fprintf (stderr, "UNFAIR - take 2 %p %p!\n",
+		   TYPE_SIZE (vtbl_type_node),
+		   TYPE_SIZE (vtbl_descr_type_node));
+	  layout_type (vtbl_descr_type_node);
+	  }
+  fprintf (stderr, "Setup vtbl_descr_type_node 3 %p\n", vtbl_descr_type_node);
+  record_builtin_type (RID_MAX, NULL, vtbl_descr_type_node);
+
   push_namespace (get_identifier ("__cxxabiv1"));
   abi_node = current_namespace;
   pop_namespace ();
@@ -3964,14 +3983,24 @@
 	  || (TREE_CODE (type) == ARRAY_TYPE
 	      && !TYPE_DOMAIN (type)
 	      && COMPLETE_TYPE_P (TREE_TYPE (type)))))
+	  {
+	  fprintf( stderr, "do layout decl\n");
     layout_decl (decl, 0);
+	  }
 
   if (!DECL_EXTERNAL (decl) && DECL_SIZE (decl) == NULL_TREE)
     {
       /* An automatic variable with an incomplete type: that is an error.
 	 Don't talk about array types here, since we took care of that
 	 message in grokdeclarator.  */
-      error ("storage size of %qD isn't known", decl);
+      error ("storage +1 size of %qD isn't known %d %d %d %d", decl,
+	     !DECL_SIZE (decl),
+	     TREE_TYPE (decl) != error_mark_node,
+	     COMPLETE_TYPE_P (type),
+	     (TREE_CODE (type) == ARRAY_TYPE
+	      && !TYPE_DOMAIN (type)
+	      && COMPLETE_TYPE_P (TREE_TYPE (type))));
+
       TREE_TYPE (decl) = error_mark_node;
     }
 #if 0
@@ -3993,7 +4022,7 @@
       if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)
 	constant_expression_warning (DECL_SIZE (decl));
       else
-	error ("storage size of %qD isn't constant", decl);
+	error ("storage +2 size of %qD isn't constant", decl);
     }
 
   if (TREE_STATIC (decl)
diff -u -r /share/gcc-pristine/cp/decl.c~ cp/decl.c~
--- /share/gcc-pristine/cp/decl.c~	2005-06-24 17:33:08.000000000 +0100
+++ cp/decl.c~	2005-08-08 16:07:49.000000000 +0100
@@ -142,6 +142,7 @@
 
 	tree vtbl_type_node;
 	tree vtbl_ptr_type_node;
+	tree vtbl_descr_type_node;
 
    Namespaces,
 
@@ -2984,6 +2985,12 @@
   layout_type (vtbl_ptr_type_node);
   record_builtin_type (RID_MAX, NULL, vtbl_ptr_type_node);
 
+  vtbl_descr_type_node
+    = build_cplus_array_type (string_type_node, NULL_TREE);
+  layout_type (vtbl_descr_type_node);
+  vtbl_descr_type_node = build_qualified_type (vtbl_descr_type_node, TYPE_QUAL_CONST);
+  record_builtin_type (RID_MAX, NULL, vtbl_descr_type_node);
+
   push_namespace (get_identifier ("__cxxabiv1"));
   abi_node = current_namespace;
   pop_namespace ();
diff -u -r /share/gcc-pristine/cp/init.c cp/init.c
--- /share/gcc-pristine/cp/init.c	2005-08-09 15:45:55.000000000 +0100
+++ cp/init.c	2005-08-08 16:07:49.000000000 +0100
@@ -803,6 +803,25 @@
   /* Assign the vtable to the vptr.  */
   vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl, 0);
   finish_expr_stmt (build_modify_expr (vtbl_ptr, NOP_EXPR, vtbl));
+
+#if 1
+  /* Get pointer to information table */
+  /* call vtable constructor */
+  {
+    tree vtbl_init;
+    static tree vtbl_init_fndecl = NULL;
+    if (!vtbl_init_fndecl) {
+	    tree args = build_function_type_list (ptr_type_node, NULL_TREE);
+	    vtbl_init_fndecl = build_decl (FUNCTION_DECL, get_identifier ("__vt_fixup"), args);
+	    TREE_PUBLIC (vtbl_init_fndecl) = 1;
+	    DECL_EXTERNAL (vtbl_init_fndecl) = 1;
+	    pushdecl_top_level (vtbl_init_fndecl);
+    }
+
+    vtbl_init = build_tree_list (NULL_TREE, vtbl);
+    finish_expr_stmt (build_function_call_expr (vtbl_init_fndecl, vtbl_init));
+  }
+#endif
 }
 
 /* If an exception is thrown in a constructor, those base classes already
diff -u -r /share/gcc-pristine/cp/mangle.c cp/mangle.c
--- /share/gcc-pristine/cp/mangle.c	2005-08-09 15:45:55.000000000 +0100
+++ cp/mangle.c	2005-08-08 16:07:49.000000000 +0100
@@ -2619,6 +2619,14 @@
   return mangle_special_for_type (type, "TV");
 }
 
+/* Create an identifier for the mangled name of the vtable for TYPE.  */
+
+tree
+mangle_vtbl_descr_for_type (const tree type)
+{
+  return mangle_special_for_type (type, "TVD");
+}
+
 /* Returns an identifier for the mangled name of the VTT for TYPE.  */
 
 tree
diff -u -r /share/gcc-pristine/cp/typeck2.c cp/typeck2.c
--- /share/gcc-pristine/cp/typeck2.c	2005-06-24 17:33:09.000000000 +0100
+++ cp/typeck2.c	2005-08-09 15:40:20.007741920 +0100
@@ -874,10 +874,15 @@
 	{
 	  if (tail)
 	    {
+
+//	      warning ("process_init_constructor %d %qD, on %qT init %qD",
+//		       TREE_PURPOSE (tail), tail, type, init );
+
 	      if (TREE_PURPOSE (tail)
 		  && (TREE_CODE (TREE_PURPOSE (tail)) != INTEGER_CST
 		      || compare_tree_int (TREE_PURPOSE (tail), i) != 0))
-		sorry ("non-trivial labeled initializers");
+		sorry ("non-trivial labeled initializers %qD on %qT init %qD",
+		       tail, type, init);
 
 	      if (TREE_VALUE (tail) != 0)
 		{
Only in cp: typeck2.c~
diff -u -r /share/gcc-pristine/cp/typeck.c cp/typeck.c
--- /share/gcc-pristine/cp/typeck.c	2005-07-28 15:24:07.000000000 +0100
+++ cp/typeck.c	2005-08-09 15:25:06.192662928 +0100
@@ -5868,7 +5868,11 @@
 	     overloaded function.  Call instantiate_type to get error
 	     messages.  */
 	  if (rhstype == unknown_type_node)
+	  {
+	    warning ("Function: did convert %qT to %qT for argument %qP to %qD",
+		     rhstype, type, parmnum, fndecl);
 	    instantiate_type (type, rhs, tf_error | tf_warning);
+	  }
 	  else if (fndecl)
 	    error ("cannot convert %qT to %qT for argument %qP to %qD",
                    rhstype, type, parmnum, fndecl);
