? package/unxlngi6.pro.debug
? package/qa/makefile.mk
? package/qa/ptest.cxx
? package/source/zipapi/ZipEntry.cxx
Index: package/inc/ByteChucker.hxx
===================================================================
RCS file: /cvs/xml/package/inc/ByteChucker.hxx,v
retrieving revision 1.12
diff -u -p -u -r1.12 ByteChucker.hxx
--- package/inc/ByteChucker.hxx	8 Sep 2005 15:54:18 -0000	1.12
+++ package/inc/ByteChucker.hxx	25 Jul 2006 15:50:28 -0000
@@ -73,7 +73,7 @@ public:
 	~ByteChucker();
 
 	// XOutputStream
-    void SAL_CALL writeBytes( const ::com::sun::star::uno::Sequence< sal_Int8 >& aData, sal_Int32 nLength = -1, const sal_Int8 * const pData = NULL) 
+    void SAL_CALL writeBytes( const ::com::sun::star::uno::Sequence< sal_Int8 >& aData) 
 		throw(::com::sun::star::io::NotConnectedException, ::com::sun::star::io::BufferSizeExceededException, ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
     void SAL_CALL flush(  ) 
 		throw(::com::sun::star::io::NotConnectedException, ::com::sun::star::io::BufferSizeExceededException, ::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
Index: package/inc/HashMaps.hxx
===================================================================
RCS file: /cvs/xml/package/inc/HashMaps.hxx,v
retrieving revision 1.7
diff -u -p -u -r1.7 HashMaps.hxx
--- package/inc/HashMaps.hxx	8 Sep 2005 15:56:10 -0000	1.7
+++ package/inc/HashMaps.hxx	25 Jul 2006 15:50:28 -0000
@@ -50,6 +50,16 @@ struct eqFunc
 	{
 		return r1 == r2;
 	}
+	sal_Bool operator()( const rtl::OString &r1,
+				    	 const rtl::OString &r2) const
+	{
+		return r1 == r2;
+	}
+	sal_Bool operator()( const ZipPath *r1,
+						 const ZipPath *r2) const
+	{
+		return r1 == r2;
+	}
 };
 
 class ZipPackageFolder;
@@ -67,9 +77,21 @@ typedef std::hash_map < rtl::OUString, 
 						::rtl::OUStringHash, 
 						eqFunc > ContentHash;
 
-typedef std::hash_map < rtl::OUString, 
+typedef std::hashtable < ZipEntryPtr, ZipPath,
+						 ZipPathHash, ZipEntry,
+						 ZipPathEqual,
+						 std::allocator< ZipEntryPtr > > EntryHash;
+#define ENTRY_HASH_ARGS(var) (var).hash_funct(), (var).key_eq(), (var).get_allocator()
+
+/*
+typedef std::hashtable < ZipEntry *, ZipPath,
+						 ZipPathHash, ZipEntry,
+						 ZipPathEqual,
+						 std::allocator< ZipEntry * > > EntryHash;
+*/
+/* typedef std::hash_map < ZipPath *, 
 						ZipEntry, 
-						rtl::OUStringHash, 
-						eqFunc > EntryHash;
+						rtl::OStringHash, 
+						eqFunc > EntryHash;*/
 
 #endif
Index: package/inc/ZipEntry.hxx
===================================================================
RCS file: /cvs/xml/package/inc/ZipEntry.hxx,v
retrieving revision 1.4
diff -u -p -u -r1.4 ZipEntry.hxx
--- package/inc/ZipEntry.hxx	8 Sep 2005 15:58:11 -0000	1.4
+++ package/inc/ZipEntry.hxx	25 Jul 2006 15:50:28 -0000
@@ -1,3 +1,4 @@
+#include <stdio.h>
 /*************************************************************************
  *
  *  OpenOffice.org - a multi-platform office productivity suite
@@ -39,18 +40,138 @@
 #include <rtl/ustring.hxx>
 #endif
 
+#ifndef _OSL_INTERLOCK_H_
+#include <osl/interlck.h>
+#endif
+
+#include <hash_map>
+
+class ByteChucker;
+class ZipPathShareHash;
+
+struct ZipPath
+{
+    ::rtl::OString sPath;
+    ::rtl::OString sElem;
+
+	ZipPath() : sPath(), sElem() {}
+	ZipPath( const rtl::OString &rName );
+
+	rtl::OString getName() const;
+	sal_Int32 getNameLength() const;
+	void setName( const rtl::OString &rName, ZipPathShareHash *pHash = NULL );
+	void setName( const sal_Char *nStr, sal_Int16 nNameLen,
+				  ZipPathShareHash *pHash = NULL );
+
+	void writeName( ByteChucker &rStream ) const;
+	sal_Bool operator==( const ZipPath &rPath ) const
+	{
+		return sElem.getLength() == rPath.sElem.getLength() &&
+			   sElem.compareTo( rPath.sElem ) == 0 &&
+			   sPath.compareTo( rPath.sPath ) == 0;
+	}
+	size_t hashCode() const
+	{ return (size_t)( sPath.hashCode() ^ sElem.hashCode() ); }
+};
+
+struct ZipPathEqual {
+	bool operator() ( const ZipPath& aEntry1, const ZipPath& aEntry2 ) const
+	{
+		return aEntry1 == aEntry2;
+	}
+	sal_Bool operator()( const rtl::OString &r1,
+				    	 const rtl::OString &r2) const
+	{
+		return r1 == r2;
+	}
+};
+
+struct ZipPathShareHash {
+	std::hash_map < rtl::OString, rtl::OString,
+					rtl::OStringHash, ZipPathEqual > maHash;
+};
+
+struct ZipEntry;
+
+class ZipEntryPtr
+{
+	ZipEntry *mpEntry;
+public:
+	ZipEntryPtr() :
+		mpEntry( NULL )
+	{ }
+
+	ZipEntryPtr( const ZipEntryPtr &rEntryPtr ) :
+		mpEntry( rEntryPtr.mpEntry )
+	{ acquire(); }
+
+	ZipEntryPtr( ZipEntry *pEntry ) :
+		mpEntry( pEntry )
+	{ acquire(); }
+
+	~ZipEntryPtr()
+	{ if ( mpEntry ) release(); }
+
+	void operator = ( const ZipEntryPtr &rEntry )
+ 	{
+	    if (rEntry.mpEntry == mpEntry)
+			return;
+	    release();
+	    mpEntry = rEntry.mpEntry;
+	    acquire();
+	}
+
+	void acquire();
+	void release();
+	bool is() { return mpEntry != NULL; }
+	ZipEntry *get() const { return mpEntry; }
+	inline ZipEntry * operator -> () const { return mpEntry; }
+	static const ZipEntryPtr &null();
+};
+
 struct ZipEntry
 {
-    sal_Int16 nVersion;
-    sal_Int16 nFlag;
-    sal_Int16 nMethod;
+ 	// NB. no derivation from IReference
+	// we don't want a pointless vtable pointer
+	oslInterlockedCount nCount;
+
+	sal_Int16 nVersion;    // checked on read [ for same version ]
+	sal_Int16 nFlag : 4;   // seemingly we only use bit 3 ( & 8 ) and -1 as a marker
+	sal_Int16 nMethod : 6; // 1 bit - STORED or DEFLATED ... [ ZipConstants.idl: 'BEST_COMPRESSION: 9': and -1 as a marker
     sal_Int32 nTime;
     sal_Int32 nCrc;
     sal_Int32 nCompressedSize;
     sal_Int32 nSize;
     sal_Int32 nOffset;
-    sal_Int16 nNameLen;
     sal_Int16 nExtraLen;
-    ::rtl::OUString sName;
+	ZipPath   aPath;
+	ZipEntry();
+	ZipEntry(const ZipEntry &rEntry);
+	ZipEntry(const ZipEntryPtr &xEntry);
+	~ZipEntry();
+
+	rtl::OUString getName() const
+	{ // FIXME: convert into a buffer ?
+		rtl::OString sName = aPath.getName();
+		return rtl::OStringToOUString( sName, RTL_TEXTENCODING_UTF8 );
+	}
+	void setName(const rtl::OUString &rName)
+	{
+		setName( rtl::OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ) );
+	}
+	void setName(const rtl::OString &rName)
+	{
+		aPath.setName( rName );
+	}
+	const ZipPath &operator()(const ZipEntryPtr &pEntry) const
+	{ return pEntry->aPath; }
+
 };
+
+struct ZipPathHash
+{
+    size_t operator()( const ZipPath &rPath ) const
+	{ return rPath.hashCode(); }
+};
+
 #endif 
Index: package/inc/ZipEnumeration.hxx
===================================================================
RCS file: /cvs/xml/package/inc/ZipEnumeration.hxx,v
retrieving revision 1.10
diff -u -p -u -r1.10 ZipEnumeration.hxx
--- package/inc/ZipEnumeration.hxx	8 Sep 2005 15:58:30 -0000	1.10
+++ package/inc/ZipEnumeration.hxx	25 Jul 2006 15:50:28 -0000
@@ -46,7 +46,7 @@ protected: 
 	EntryHash::const_iterator aIterator;
 public:
 	sal_Bool SAL_CALL hasMoreElements();
-	const ZipEntry * SAL_CALL nextElement();
+	const ZipEntryPtr & SAL_CALL nextElement();
 	ZipEnumeration( EntryHash &rNewEntryHash );
 	~ZipEnumeration();
 };
Index: package/inc/ZipFile.hxx
===================================================================
RCS file: /cvs/xml/package/inc/ZipFile.hxx,v
retrieving revision 1.21
diff -u -p -u -r1.21 ZipFile.hxx
--- package/inc/ZipFile.hxx	8 Sep 2005 15:58:44 -0000	1.21
+++ package/inc/ZipFile.hxx	25 Jul 2006 15:50:28 -0000
@@ -96,28 +96,28 @@ protected:
 	sal_Bool bRecoveryMode;
 
 	com::sun::star::uno::Reference < com::sun::star::io::XInputStream >  createMemoryStream( 
-			ZipEntry & rEntry,
+			const ZipEntryPtr & xEntry,
 			const vos::ORef < EncryptionData > &rData, 
 			sal_Bool bRawStream,
 			sal_Bool bDecrypt );
 
 	com::sun::star::uno::Reference < com::sun::star::io::XInputStream >  createFileStream(
-			ZipEntry & rEntry,
+			const ZipEntryPtr & xEntry,
 			const vos::ORef < EncryptionData > &rData, 
 			sal_Bool bRawStream,
 			sal_Bool bDecrypt );
 
 	// aMediaType parameter is used only for raw stream header creation
 	com::sun::star::uno::Reference < com::sun::star::io::XInputStream >  createUnbufferedStream(
-			ZipEntry & rEntry,
+			const ZipEntryPtr & xEntry,
 			const vos::ORef < EncryptionData > &rData, 
 			sal_Int8 nStreamMode,
 			sal_Bool bDecrypt,
 			::rtl::OUString aMediaType = ::rtl::OUString() );
 
-	sal_Bool hasValidPassword ( ZipEntry & rEntry, const vos::ORef < EncryptionData > &rData );
+	sal_Bool hasValidPassword ( const ZipEntryPtr & xEntry, const vos::ORef < EncryptionData > &rData );
 
-	sal_Bool checkSizeAndCRC( const ZipEntry& aEntry );
+	sal_Bool checkSizeAndCRC( const ZipEntryPtr &xEntry );
 
 	sal_Int32 getCRC( sal_Int32 nOffset, sal_Int32 nSize );
 
@@ -143,7 +143,7 @@ public:
 
 	void setInputStream ( com::sun::star::uno::Reference < com::sun::star::io::XInputStream > xNewStream );
     ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream > SAL_CALL getRawData( 
-			ZipEntry& rEntry,
+			const ZipEntryPtr& xEntry,
 			const vos::ORef < EncryptionData > &rData,
 			sal_Bool bDecrypt)
 		throw(::com::sun::star::io::IOException, ::com::sun::star::packages::zip::ZipException, ::com::sun::star::uno::RuntimeException);
@@ -172,13 +172,13 @@ public:
 	
 
     ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream > SAL_CALL getInputStream( 
-			ZipEntry& rEntry,
+			const ZipEntryPtr& xEntry,
 			const vos::ORef < EncryptionData > &rData,
 			sal_Bool bDecrypt )
 		throw(::com::sun::star::io::IOException, ::com::sun::star::packages::zip::ZipException, ::com::sun::star::uno::RuntimeException);
 
     ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream > SAL_CALL getDataStream( 
-			ZipEntry& rEntry,
+			const ZipEntryPtr& xEntry,
 			const vos::ORef < EncryptionData > &rData,
 			sal_Bool bDecrypt )
 		throw ( ::com::sun::star::packages::WrongPasswordException,
@@ -187,7 +187,7 @@ public:
 				::com::sun::star::uno::RuntimeException );
 
     ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream > SAL_CALL getWrappedRawStream( 
-			ZipEntry& rEntry,
+			const ZipEntryPtr& xEntry,
 			const vos::ORef < EncryptionData > &rData,
 			const ::rtl::OUString& aMediaType )
 		throw ( ::com::sun::star::packages::NoEncryptionException,
@@ -201,8 +201,10 @@ public:
 		throw(::com::sun::star::uno::RuntimeException);
 
     ZipEnumeration * SAL_CALL entries(  );
+	void             SAL_CALL copyEntries( EntryHash &rDestEntries );
+
 protected:
-	sal_Bool		readLOC ( ZipEntry &rEntry)
+	sal_Bool		readLOC ( const ZipEntryPtr &xEntry)
 		throw(::com::sun::star::io::IOException, com::sun::star::packages::zip::ZipException, com::sun::star::uno::RuntimeException);
 	sal_Int32		readCEN()
 		throw(::com::sun::star::io::IOException, com::sun::star::packages::zip::ZipException, com::sun::star::uno::RuntimeException);
Index: package/inc/ZipOutputStream.hxx
===================================================================
RCS file: /cvs/xml/package/inc/ZipOutputStream.hxx,v
retrieving revision 1.23
diff -u -p -u -r1.23 ZipOutputStream.hxx
--- package/inc/ZipOutputStream.hxx	8 Sep 2005 15:59:00 -0000	1.23
+++ package/inc/ZipOutputStream.hxx	25 Jul 2006 15:50:28 -0000
@@ -41,6 +41,9 @@
 #ifndef _DEFLATER_HXX
 #include <Deflater.hxx>
 #endif
+#ifndef _ZIP_ENTRY_HXX_
+#include <ZipEntry.hxx>
+#endif
 #ifndef _CRC32_HXX
 #include <CRC32.hxx>
 #endif
@@ -54,6 +57,7 @@
 #include <vector>
 
 struct ZipEntry;
+struct ZipEntryPtr;
 class EncryptionData;
 namespace vos 
 {
@@ -63,7 +67,7 @@ class ZipOutputStream
 {
 protected:
 	com::sun::star::uno::Reference < com::sun::star::io::XOutputStream > xStream;
-	::std::vector < ZipEntry * >			aZipList;
+	::std::vector < ZipEntryPtr > aZipList;
 	com::sun::star::uno::Sequence < sal_Int8 > aBuffer, aEncryptionBuffer;
 	::rtl::OUString		sComment;
 	Deflater			aDeflater;
@@ -71,7 +75,7 @@ protected:
 	rtlDigest 			aDigest;
 	CRC32				aCRC;
 	ByteChucker			aChucker;
-	ZipEntry 			*pCurrentEntry;
+	ZipEntryPtr 		xCurrentEntry;
 	sal_Int16			nMethod, nLevel, mnDigested;
 	sal_Bool			bFinished, bEncryptCurrentEntry;
 	EncryptionData 		*pCurrentEncryptData;
@@ -93,7 +97,7 @@ public:
 		throw(::com::sun::star::uno::RuntimeException);
     void SAL_CALL setLevel( sal_Int32 nNewLevel )
 		throw(::com::sun::star::uno::RuntimeException);
-    void SAL_CALL putNextEntry( ZipEntry& rEntry, 
+    void SAL_CALL putNextEntry( const ZipEntryPtr &xEntry, 
 			vos::ORef < EncryptionData > &rData,
 			sal_Bool bEncrypt = sal_False )
 		throw(::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
@@ -110,11 +114,11 @@ protected:
 	void doDeflate();
 	void writeEND(sal_uInt32 nOffset, sal_uInt32 nLength)
 		throw(::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
-	void writeCEN( const ZipEntry &rEntry )
+	void writeCEN( const ZipEntryPtr &xEntry )
 		throw(::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
-	void writeEXT( const ZipEntry &rEntry )
+	void writeEXT( const ZipEntryPtr &xEntry )
 		throw(::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
-	sal_Int32 writeLOC( const ZipEntry &rEntry )
+	sal_Int32 writeLOC( const ZipEntryPtr &xEntry )
 		throw(::com::sun::star::io::IOException, ::com::sun::star::uno::RuntimeException);
 };
 
Index: package/inc/ZipPackageFolder.hxx
===================================================================
RCS file: /cvs/xml/package/inc/ZipPackageFolder.hxx,v
retrieving revision 1.35
diff -u -p -u -r1.35 ZipPackageFolder.hxx
--- package/inc/ZipPackageFolder.hxx	8 Sep 2005 15:59:56 -0000	1.35
+++ package/inc/ZipPackageFolder.hxx	25 Jul 2006 15:50:28 -0000
@@ -63,12 +63,13 @@ class ZipOutputStream;
 struct ZipEntry;
 typedef void* rtlRandomPool;
 
-class ZipPackageFolder : public cppu::ImplInheritanceHelper2
-<
-	ZipPackageEntry,
-	::com::sun::star::container::XNameContainer,
-	::com::sun::star::container::XEnumerationAccess
->
+typedef cppu::ImplInheritanceHelper2 <
+			ZipPackageEntry,
+			::com::sun::star::container::XNameContainer,
+			::com::sun::star::container::XEnumerationAccess
+		> ZipPackageFolderParent;
+
+class ZipPackageFolder : public ZipPackageFolderParent
 {
 	static com::sun::star::uno::Sequence < sal_Int8 > aImplementationId;
 
@@ -88,7 +89,6 @@ public:
 		throw(::com::sun::star::lang::IllegalArgumentException, ::com::sun::star::container::ElementExistException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException);
 	com::sun::star::packages::ContentInfo & doGetByName( const ::rtl::OUString& aName )
 		throw(::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException);
-	static void copyZipEntry( ZipEntry &rDest, const ZipEntry &rSource);
 	static ::com::sun::star::uno::Sequence < sal_Int8 > static_getImplementationId()
 	{
 		return aImplementationId;
Index: package/source/zipapi/ByteChucker.cxx
===================================================================
RCS file: /cvs/xml/package/source/zipapi/ByteChucker.cxx,v
retrieving revision 1.18
diff -u -p -u -r1.18 ByteChucker.cxx
--- package/source/zipapi/ByteChucker.cxx	8 Sep 2005 16:10:45 -0000	1.18
+++ package/source/zipapi/ByteChucker.cxx	25 Jul 2006 15:50:28 -0000
@@ -66,7 +66,7 @@ ByteChucker::~ByteChucker()
 }
 
 // XOutputStream chained...
-void SAL_CALL ByteChucker::writeBytes( const Sequence< sal_Int8 >& aData, sal_Int32 nLength, const sal_Int8 * const pData )
+void SAL_CALL ByteChucker::writeBytes( const Sequence< sal_Int8 >& aData )
 	throw(NotConnectedException, BufferSizeExceededException, IOException, RuntimeException)
 {
 	xStream->writeBytes(aData);
@@ -108,7 +108,7 @@ sal_Int64 SAL_CALL ByteChucker::getLengt
 ByteChucker& ByteChucker::operator << (sal_Int8 nInt8)
 {
 	p1Sequence[0] = nInt8  & 0xFF;
-	writeBytes( a1Sequence, 1, p1Sequence );
+	writeBytes( a1Sequence );
 	return *this;
 }
 
@@ -116,7 +116,7 @@ ByteChucker& ByteChucker::operator << (s
 {
 	p2Sequence[0] = (nInt16 >>  0 ) & 0xFF;
 	p2Sequence[1] = (nInt16 >>  8 ) & 0xFF;
-	writeBytes( a2Sequence, 2, p2Sequence );
+	writeBytes( a2Sequence );
 	return *this;
 }
 ByteChucker& ByteChucker::operator << (sal_Int32 nInt32)
@@ -125,21 +125,21 @@ ByteChucker& ByteChucker::operator << (s
 	p4Sequence[1] = (nInt32 >>  8 ) & 0xFF;
 	p4Sequence[2] = (nInt32 >> 16 ) & 0xFF;
 	p4Sequence[3] = (nInt32 >> 24 ) & 0xFF;
-	writeBytes( a4Sequence, 4, p4Sequence );
+	writeBytes( a4Sequence );
 	return *this;
 }
 
 ByteChucker& ByteChucker::operator << (sal_uInt8 nuInt8)
 {
 	p1Sequence[0] = nuInt8  & 0xFF;
-	writeBytes( a1Sequence, 1, p1Sequence );
+	writeBytes( a1Sequence );
 	return *this;
 }
 ByteChucker& ByteChucker::operator << (sal_uInt16 nuInt16)
 {
 	p2Sequence[0] = (nuInt16 >>  0 ) & 0xFF;
 	p2Sequence[1] = (nuInt16 >>  8 ) & 0xFF;
-	writeBytes( a2Sequence, 2, p2Sequence );
+	writeBytes( a2Sequence );
 	return *this;
 }
 ByteChucker& ByteChucker::operator << (sal_uInt32 nuInt32)
@@ -148,6 +148,6 @@ ByteChucker& ByteChucker::operator << (s
 	p4Sequence[1] = static_cast < sal_Int8 > ((nuInt32 >>  8 ) & 0xFF);
 	p4Sequence[2] = static_cast < sal_Int8 > ((nuInt32 >> 16 ) & 0xFF);
 	p4Sequence[3] = static_cast < sal_Int8 > ((nuInt32 >> 24 ) & 0xFF);
-	writeBytes( a4Sequence, 4, p4Sequence );
+	writeBytes( a4Sequence );
 	return *this;
 }
Index: package/source/zipapi/XFileStream.cxx
===================================================================
RCS file: /cvs/xml/package/source/zipapi/XFileStream.cxx,v
retrieving revision 1.7
diff -u -p -u -r1.7 XFileStream.cxx
--- package/source/zipapi/XFileStream.cxx	8 Sep 2005 16:13:13 -0000	1.7
+++ package/source/zipapi/XFileStream.cxx	25 Jul 2006 15:50:28 -0000
@@ -69,7 +69,7 @@ XFileStream::XFileStream( ZipEntry & rEn
 			 			  const vos::ORef < EncryptionData > &rData, 
 			 			  sal_Bool bNewRawStream,
 			 			  sal_Bool bIsEncrypted )
-: maEntry ( rEntry )
+: mxEntry ( new ZipEntry( rEntry ) )
 , mxData ( rData )
 , mbRawStream ( bNewRawStream )
 , mbFinished ( sal_False )
@@ -81,16 +81,16 @@ XFileStream::XFileStream( ZipEntry & rEn
 , maInflater ( sal_True )
 , maCipher ( NULL )
 {
-	mnZipCurrent = maEntry.nOffset;
+	mnZipCurrent = mxEntry->nOffset;
 	if (mbRawStream)
 	{
-		mnZipSize = maEntry.nMethod == DEFLATED ? maEntry.nCompressedSize : maEntry.nSize;
-		mnZipEnd = maEntry.nOffset + mnZipSize;
+		mnZipSize = mxEntry->nMethod == DEFLATED ? mxEntry->nCompressedSize : mxEntry->nSize;
+		mnZipEnd = mxEntry->nOffset + mnZipSize;
 	}
 	else
 	{
-		mnZipSize = maEntry.nSize;
-		mnZipEnd = maEntry.nMethod == DEFLATED ? maEntry.nOffset + maEntry.nCompressedSize : maEntry.nOffset + maEntry.nSize;
+		mnZipSize = mxEntry->nSize;
+		mnZipEnd = mxEntry->nMethod == DEFLATED ? mxEntry->nOffset + mxEntry->nCompressedSize : mxEntry->nOffset + mxEntry->nSize;
 	}
 
 	if ( bIsEncrypted )
Index: package/source/zipapi/XFileStream.hxx
===================================================================
RCS file: /cvs/xml/package/source/zipapi/XFileStream.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 XFileStream.hxx
--- package/source/zipapi/XFileStream.hxx	8 Sep 2005 16:13:33 -0000	1.5
+++ package/source/zipapi/XFileStream.hxx	25 Jul 2006 15:50:28 -0000
@@ -75,7 +75,7 @@ protected:
 	com::sun::star::uno::Reference < com::sun::star::io::XSeekable > mxTempSeek;
 	com::sun::star::uno::Reference < com::sun::star::io::XOutputStream > mxTempOut;
 	com::sun::star::uno::Sequence < sal_Int8 > maBuffer, maCompBuffer;
-	ZipEntry maEntry;
+	ZipEntryPtr mxEntry;
 	vos::ORef < EncryptionData > mxData;
 	rtlCipher maCipher;
 	Inflater maInflater;
Index: package/source/zipapi/XUnbufferedStream.cxx
===================================================================
RCS file: /cvs/xml/package/source/zipapi/XUnbufferedStream.cxx,v
retrieving revision 1.10
diff -u -p -u -r1.10 XUnbufferedStream.cxx
--- package/source/zipapi/XUnbufferedStream.cxx	8 Sep 2005 16:14:43 -0000	1.10
+++ package/source/zipapi/XUnbufferedStream.cxx	25 Jul 2006 15:50:28 -0000
@@ -72,14 +72,14 @@ using com::sun::star::lang::IllegalArgum
 using com::sun::star::packages::zip::ZipIOException;
 using ::rtl::OUString;
 
-XUnbufferedStream::XUnbufferedStream( ZipEntry & rEntry,
+XUnbufferedStream::XUnbufferedStream( const ZipEntryPtr & xEntry,
 			 			  Reference < XInputStream > xNewZipStream,
 			 			  const vos::ORef < EncryptionData > &rData, 
 			 			  sal_Int8 nStreamMode,
 			 			  sal_Bool bIsEncrypted,
 						  const ::rtl::OUString& aMediaType,
 						  sal_Bool bRecoveryMode )
-: maEntry ( rEntry )
+: mxEntry ( new ZipEntry( xEntry ) )
 , mxData ( rData )
 , mbRawStream ( nStreamMode == UNBUFF_STREAM_RAW || nStreamMode == UNBUFF_STREAM_WRAPPEDRAW )
 , mbWrappedRaw ( nStreamMode == UNBUFF_STREAM_WRAPPEDRAW )
@@ -95,16 +95,16 @@ XUnbufferedStream::XUnbufferedStream( Zi
 , mnHeaderToRead ( 0 )
 , mbCheckCRC( !bRecoveryMode )
 {
-	mnZipCurrent = maEntry.nOffset;
+	mnZipCurrent = mxEntry->nOffset;
 	if ( mbRawStream )
 	{
-		mnZipSize = maEntry.nMethod == DEFLATED ? maEntry.nCompressedSize : maEntry.nSize;
-		mnZipEnd = maEntry.nOffset + mnZipSize;
+		mnZipSize = mxEntry->nMethod == DEFLATED ? mxEntry->nCompressedSize : mxEntry->nSize;
+		mnZipEnd = mxEntry->nOffset + mnZipSize;
 	}
 	else
 	{
-		mnZipSize = maEntry.nSize;
-		mnZipEnd = maEntry.nMethod == DEFLATED ? maEntry.nOffset + maEntry.nCompressedSize : maEntry.nOffset + maEntry.nSize;
+		mnZipSize = mxEntry->nSize;
+		mnZipEnd = mxEntry->nMethod == DEFLATED ? mxEntry->nOffset + mxEntry->nCompressedSize : mxEntry->nOffset + mxEntry->nSize;
 	}
 	sal_Bool bHaveEncryptData = ( !rData.isEmpty() && rData->aSalt.getLength() && rData->aInitVector.getLength() && rData->nIterationCount != 0 ) ? sal_True : sal_False;
 	sal_Bool bMustDecrypt = ( nStreamMode == UNBUFF_STREAM_DATA && bHaveEncryptData && bIsEncrypted ) ? sal_True : sal_False;
@@ -124,7 +124,7 @@ XUnbufferedStream::XUnbufferedStream( Zi
 							rData->aDigest.getLength() +
 							aMediaType.getLength() * sizeof( sal_Unicode ) );
 		sal_Int8 * pHeader = maHeader.getArray();
-		ZipFile::StaticFillHeader ( rData, rEntry.nSize, aMediaType, pHeader );
+		ZipFile::StaticFillHeader ( rData, xEntry->nSize, aMediaType, pHeader );
 		mnHeaderToRead = static_cast < sal_Int16 > ( maHeader.getLength() );
 	}
 }
@@ -261,6 +261,11 @@ sal_Int32 SAL_CALL XUnbufferedStream::re
 					mxZipSeek->seek ( mnZipCurrent );
 					sal_Int32 nToRead = std::min ( nDiff, std::max ( nRequestedBytes, static_cast< sal_Int32 >( 8192 ) ) );
 					sal_Int32 nZipRead = mxZipStream->readBytes ( maCompBuffer, nToRead );
+					if (!nZipRead)
+					{
+						fprintf (stderr, "Short read !\n");
+						break;
+					}
 					mnZipCurrent += nZipRead;
 					// maCompBuffer now has the data, check if we need to decrypt
 					// before passing to the Inflater
@@ -314,7 +319,7 @@ sal_Int32 SAL_CALL XUnbufferedStream::re
 			}
 #endif
 			
-			if ( mnZipSize + maHeader.getLength() == mnMyCurrent && maCRC.getValue() != maEntry.nCrc )
+			if ( mnZipSize + maHeader.getLength() == mnMyCurrent && maCRC.getValue() != mxEntry->nCrc )
 				throw ZipIOException( OUString( RTL_CONSTASCII_USTRINGPARAM( "The stream seems to be broken!" ) ),
 									Reference< XInterface >() );
 		}
Index: package/source/zipapi/XUnbufferedStream.hxx
===================================================================
RCS file: /cvs/xml/package/source/zipapi/XUnbufferedStream.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 XUnbufferedStream.hxx
--- package/source/zipapi/XUnbufferedStream.hxx	8 Sep 2005 16:14:59 -0000	1.5
+++ package/source/zipapi/XUnbufferedStream.hxx	25 Jul 2006 15:50:28 -0000
@@ -81,7 +81,7 @@ protected:
 	com::sun::star::uno::Reference < com::sun::star::io::XInputStream > mxZipStream;
 	com::sun::star::uno::Reference < com::sun::star::io::XSeekable > mxZipSeek;
 	com::sun::star::uno::Sequence < sal_Int8 > maCompBuffer, maHeader;
-	ZipEntry maEntry;
+	ZipEntryPtr mxEntry;
 	vos::ORef < EncryptionData > mxData;
 	rtlCipher maCipher;
 	Inflater maInflater;
@@ -92,7 +92,7 @@ protected:
 	sal_Bool mbCheckCRC;
 
 public:
-	XUnbufferedStream( ZipEntry & rEntry,
+	XUnbufferedStream( const ZipEntryPtr & xEntry,
 				 com::sun::star::uno::Reference < com::sun::star::io::XInputStream > xNewZipStream,
 				 const vos::ORef < EncryptionData > &rData, 
 				 sal_Int8 nStreamMode,
Index: package/source/zipapi/ZipEnumeration.cxx
===================================================================
RCS file: /cvs/xml/package/source/zipapi/ZipEnumeration.cxx,v
retrieving revision 1.12
diff -u -p -u -r1.12 ZipEnumeration.cxx
--- package/source/zipapi/ZipEnumeration.cxx	8 Sep 2005 16:15:15 -0000	1.12
+++ package/source/zipapi/ZipEnumeration.cxx	25 Jul 2006 15:50:28 -0000
@@ -43,18 +43,20 @@ ZipEnumeration::ZipEnumeration( EntryHas
 , aIterator(rEntryHash.begin())
 {
 }
+
 ZipEnumeration::~ZipEnumeration( void )
 {
 }
+
 sal_Bool SAL_CALL ZipEnumeration::hasMoreElements()
 {
 	return (aIterator != rEntryHash.end());
 }
 
-const ZipEntry* SAL_CALL ZipEnumeration::nextElement()
+const ZipEntryPtr & SAL_CALL ZipEnumeration::nextElement()
 {
 	if (aIterator != rEntryHash.end())
-		return &((*aIterator++).second);
+		return *aIterator++;
 	else
-		return NULL;
+		return ZipEntryPtr::null();
 }
Index: package/source/zipapi/ZipFile.cxx
===================================================================
RCS file: /cvs/xml/package/source/zipapi/ZipFile.cxx,v
retrieving revision 1.43
diff -u -p -u -r1.43 ZipFile.cxx
--- package/source/zipapi/ZipFile.cxx	8 Sep 2005 16:15:32 -0000	1.43
+++ package/source/zipapi/ZipFile.cxx	25 Jul 2006 15:50:28 -0000
@@ -80,6 +80,7 @@
 #ifndef _CRC32_HXX_
 #include <CRC32.hxx>
 #endif
+#include <ByteChucker.hxx>
 
 #include <string.h> // for memcpy
 #include <vector>
@@ -95,7 +96,6 @@ using namespace com::sun::star::packages
 using namespace com::sun::star::packages::zip;
 using namespace com::sun::star::packages::zip::ZipConstants;
 
-
 /** This class is used to read entries from a zip file
  */
 ZipFile::ZipFile( Reference < XInputStream > &xInput, const Reference < XMultiServiceFactory > &xNewFactory, sal_Bool bInitialise )
@@ -106,7 +106,9 @@ ZipFile::ZipFile( Reference < XInputStre
 , aInflater (sal_True)
 , xFactory ( xNewFactory )
 , bRecoveryMode( sal_False )
+, aEntries( 10, ENTRY_HASH_ARGS( aEntries ) )
 {
+	fprintf (stderr, "New ZipFile %p\n", this);
 	if (bInitialise)
 	{
 		if ( readCEN() == -1 )
@@ -128,7 +130,9 @@ ZipFile::ZipFile( Reference < XInputStre
 , xFactory ( xNewFactory )
 , xProgressHandler( xProgress )
 , bRecoveryMode( bForceRecovery )
+, aEntries( 10, ENTRY_HASH_ARGS( aEntries ) )
 {
+	fprintf (stderr, "New ZipFile(2) %p\n", this);
 	if (bInitialise)
 	{
 		if ( bForceRecovery )
@@ -145,6 +149,7 @@ ZipFile::ZipFile( Reference < XInputStre
 
 ZipFile::~ZipFile()
 {
+	fprintf (stderr, "Delete ZipFile %p\n", this);
     aEntries.clear();
 }
 
@@ -400,13 +405,13 @@ sal_Bool ZipFile::StaticHasValidPassword
 	return bRet;
 }
 
-sal_Bool ZipFile::hasValidPassword ( ZipEntry & rEntry, const ORef < EncryptionData > &rData )
+sal_Bool ZipFile::hasValidPassword ( const ZipEntryPtr & xEntry, const ORef < EncryptionData > &rData )
 {
 	sal_Bool bRet = sal_False;
 	if ( rData->aKey.getLength() )
 	{
-		xSeek->seek( rEntry.nOffset );
-		sal_Int32 nSize = rEntry.nMethod == DEFLATED ? rEntry.nCompressedSize : rEntry.nSize;
+		xSeek->seek( xEntry->nOffset );
+		sal_Int32 nSize = xEntry->nMethod == DEFLATED ? xEntry->nCompressedSize : xEntry->nSize;
 
 		// Only want to read enough to verify the digest
 		nSize = nSize > n_ConstDigestLength ? n_ConstDigestLength : nSize;
@@ -421,17 +426,17 @@ sal_Bool ZipFile::hasValidPassword ( Zip
 
 #if 0
 Reference < XInputStream > ZipFile::createFileStream(
-			ZipEntry & rEntry,
+			const ZipEntryPtr & xEntry,
 			const ORef < EncryptionData > &rData,
 			sal_Bool bRawStream,
 			sal_Bool bIsEncrypted )
 {
 	static OUString sServiceName ( RTL_CONSTASCII_USTRINGPARAM ( "com.sun.star.io.TempFile" ) );
 	Reference < XInputStream > xTempStream = Reference < XInputStream > ( xFactory->createInstance ( sServiceName ), UNO_QUERY );
-	return new XFileStream ( rEntry, xStream, xTempStream, rData, bRawStream, bIsEncrypted );
+	return new XFileStream ( xEntry, xStream, xTempStream, rData, bRawStream, bIsEncrypted );
 }
 Reference < XInputStream > ZipFile::createMemoryStream(
-			ZipEntry & rEntry,
+			const ZipEntryPtr & xEntry,
 			const ORef < EncryptionData > &rData,
 			sal_Bool bRawStream, 
 			sal_Bool bIsEncrypted )
@@ -439,15 +444,15 @@ Reference < XInputStream > ZipFile::crea
 	sal_Int32 nUncompressedSize, nEnd;
 	if (bRawStream)
 	{
-		nUncompressedSize = rEntry.nMethod == DEFLATED ? rEntry.nCompressedSize : rEntry.nSize;
-		nEnd = rEntry.nOffset + nUncompressedSize;
+		nUncompressedSize = xEntry->nMethod == DEFLATED ? xEntry->nCompressedSize : xEntry->nSize;
+		nEnd = xEntry->nOffset + nUncompressedSize;
 	}
 	else
 	{
-		nUncompressedSize = rEntry.nSize;
-		nEnd = rEntry.nMethod == DEFLATED ? rEntry.nOffset + rEntry.nCompressedSize : rEntry.nOffset + rEntry.nSize;
+		nUncompressedSize = xEntry->nSize;
+		nEnd = xEntry->nMethod == DEFLATED ? xEntry->nOffset + xEntry->nCompressedSize : xEntry->nOffset + xEntry->nSize;
 	}
-	sal_Int32 nSize = rEntry.nMethod == DEFLATED ? rEntry.nCompressedSize : rEntry.nSize;
+	sal_Int32 nSize = xEntry->nMethod == DEFLATED ? xEntry->nCompressedSize : xEntry->nSize;
 	Sequence < sal_Int8 > aReadBuffer ( nSize ), aDecryptBuffer, aWriteBuffer;
 	rtlCipher aCipher;
 
@@ -467,7 +472,7 @@ Reference < XInputStream > ZipFile::crea
 	if ( nSize <0 )
 		throw IOException ( );
 
-	xSeek->seek( rEntry.nOffset );
+	xSeek->seek( xEntry->nOffset );
 	xStream->readBytes( aReadBuffer, nSize ); // Now it holds the raw stuff from disk
 
 	if ( bMustDecrypt )
@@ -480,7 +485,7 @@ Reference < XInputStream > ZipFile::crea
 		OSL_ASSERT (aResult == rtl_Cipher_E_None);
 		aReadBuffer = aDecryptBuffer; // Now it holds the decrypted data
 	}
-	if (bRawStream || rEntry.nMethod == STORED)
+	if (bRawStream || xEntry->nMethod == STORED)
 		aWriteBuffer = aReadBuffer; // bRawStream means the caller doesn't want it decompressed
 	else
 	{
@@ -503,7 +508,7 @@ Reference < XInputStream > ZipFile::crea
 													 rData->aDigest.getLength() + 
 													 aWriteBuffer.getLength() );
 		sal_Int8 * pHeader = aEncryptedDataHeader.getArray();
-		StaticFillHeader ( rData, rEntry.nSize, pHeader );
+		StaticFillHeader ( rData, xEntry->nSize, pHeader );
 		memcpy ( pHeader, aWriteBuffer.getConstArray(), aWriteBuffer.getLength() );
 
 		// dump old buffer and point aWriteBuffer to the new one with the header
@@ -513,13 +518,13 @@ Reference < XInputStream > ZipFile::crea
 }
 #endif
 Reference < XInputStream > ZipFile::createUnbufferedStream(
-			ZipEntry & rEntry,
+			const ZipEntryPtr & xEntry,
 			const ORef < EncryptionData > &rData,
 			sal_Int8 nStreamMode,
 			sal_Bool bIsEncrypted,
 			::rtl::OUString aMediaType )
 {
-	return new XUnbufferedStream ( rEntry, xStream, rData, nStreamMode, bIsEncrypted, aMediaType, bRecoveryMode );
+	return new XUnbufferedStream ( xEntry, xStream, rData, nStreamMode, bIsEncrypted, aMediaType, bRecoveryMode );
 }
 
 
@@ -528,7 +533,7 @@ ZipEnumeration * SAL_CALL ZipFile::entri
 	return new ZipEnumeration ( aEntries );
 }
 
-::rtl::OUString SAL_CALL ZipFile::getName(  )
+::rtl::OUString SAL_CALL ZipFile::getName()
 	throw(RuntimeException)
 {
 	return sName;
@@ -540,31 +545,33 @@ sal_Int32 SAL_CALL ZipFile::getSize(  )
 	return aEntries.size();
 }
 
-Reference< XInputStream > SAL_CALL ZipFile::getInputStream( ZipEntry& rEntry,
+Reference< XInputStream > SAL_CALL ZipFile::getInputStream(
+		const ZipEntryPtr& xEntry,
 		const vos::ORef < EncryptionData > &rData,
 		sal_Bool bIsEncrypted )
 	throw(IOException, ZipException, RuntimeException)
 {
-	if ( rEntry.nOffset <= 0 )
-		readLOC( rEntry );
+	if ( xEntry->nOffset <= 0 )
+		readLOC( xEntry );
 
 	// We want to return a rawStream if we either don't have a key or if the 
 	// key is wrong
 	
-	sal_Bool bNeedRawStream = rEntry.nMethod == STORED;
+	sal_Bool bNeedRawStream = xEntry->nMethod == STORED;
 	
 	// if we have a digest, then this file is an encrypted one and we should
 	// check if we can decrypt it or not
 	if ( bIsEncrypted && !rData.isEmpty() && rData->aDigest.getLength() )
-		bNeedRawStream = !hasValidPassword ( rEntry, rData );
+		bNeedRawStream = !hasValidPassword ( xEntry, rData );
 
-	return createUnbufferedStream ( rEntry,
+	return createUnbufferedStream ( xEntry,
 									rData,
 									bNeedRawStream ? UNBUFF_STREAM_RAW : UNBUFF_STREAM_DATA,
 									bIsEncrypted );
 }
 
-Reference< XInputStream > SAL_CALL ZipFile::getDataStream( ZipEntry& rEntry,
+Reference< XInputStream > SAL_CALL ZipFile::getDataStream(
+		const ZipEntryPtr& xEntry,
 		const vos::ORef < EncryptionData > &rData,
 		sal_Bool bIsEncrypted )
 	throw ( packages::WrongPasswordException,
@@ -572,8 +579,8 @@ Reference< XInputStream > SAL_CALL ZipFi
 			ZipException,
 			RuntimeException )
 {
-	if ( rEntry.nOffset <= 0 )
-		readLOC( rEntry );
+	if ( xEntry->nOffset <= 0 )
+		readLOC( xEntry );
 
 	// An exception must be thrown in case stream is encrypted and 
 	// there is no key or the key is wrong
@@ -589,31 +596,31 @@ Reference< XInputStream > SAL_CALL ZipFi
 		// if we have a digest, then this file is an encrypted one and we should
 		// check if we can decrypt it or not
 		OSL_ENSURE( rData->aDigest.getLength(), "Can't detect password correctness without digest!\n" );
-		if ( rData->aDigest.getLength() && !hasValidPassword ( rEntry, rData ) )
+		if ( rData->aDigest.getLength() && !hasValidPassword ( xEntry, rData ) )
 				throw packages::WrongPasswordException();
 	}
 	else
-		bNeedRawStream = ( rEntry.nMethod == STORED );
+		bNeedRawStream = ( xEntry->nMethod == STORED );
 
-	return createUnbufferedStream ( rEntry,
+	return createUnbufferedStream ( xEntry,
 									rData,
 									bNeedRawStream ? UNBUFF_STREAM_RAW : UNBUFF_STREAM_DATA,
 									bIsEncrypted );
 }
 
-Reference< XInputStream > SAL_CALL ZipFile::getRawData( ZipEntry& rEntry,
+Reference< XInputStream > SAL_CALL ZipFile::getRawData( const ZipEntryPtr& xEntry,
 		const vos::ORef < EncryptionData > &rData,
 		sal_Bool bIsEncrypted )
 	throw(IOException, ZipException, RuntimeException)
 {
-	if ( rEntry.nOffset <= 0 )
-		readLOC( rEntry );
+	if ( xEntry->nOffset <= 0 )
+		readLOC( xEntry );
 
-	return createUnbufferedStream ( rEntry, rData, UNBUFF_STREAM_RAW, bIsEncrypted );
+	return createUnbufferedStream ( xEntry, rData, UNBUFF_STREAM_RAW, bIsEncrypted );
 }
 
 Reference< XInputStream > SAL_CALL ZipFile::getWrappedRawStream(
-		ZipEntry& rEntry,
+		const ZipEntryPtr& xEntry,
 		const vos::ORef < EncryptionData > &rData,
 		const ::rtl::OUString& aMediaType )
 	throw ( packages::NoEncryptionException,
@@ -624,18 +631,18 @@ Reference< XInputStream > SAL_CALL ZipFi
 	if ( rData.isEmpty() )
 		throw packages::NoEncryptionException();
 
-	if ( rEntry.nOffset <= 0 )
-		readLOC( rEntry );
+	if ( xEntry->nOffset <= 0 )
+		readLOC( xEntry );
 
-	return createUnbufferedStream ( rEntry, rData, UNBUFF_STREAM_WRAPPEDRAW, sal_True, aMediaType );
+	return createUnbufferedStream ( xEntry, rData, UNBUFF_STREAM_WRAPPEDRAW, sal_True, aMediaType );
 }
 
-sal_Bool ZipFile::readLOC( ZipEntry &rEntry )
+sal_Bool ZipFile::readLOC( const ZipEntryPtr &xEntry )
 	throw(IOException, ZipException, RuntimeException)
 {
 	sal_Int32 nTestSig, nTime, nCRC, nSize, nCompressedSize;
 	sal_Int16 nVersion, nFlag, nHow, nNameLen, nExtraLen;
-	sal_Int32 nPos = -rEntry.nOffset;
+	sal_Int32 nPos = -xEntry->nOffset;
 
 	aGrabber.seek(nPos);
 	aGrabber >> nTestSig;
@@ -643,7 +650,9 @@ sal_Bool ZipFile::readLOC( ZipEntry &rEn
 	if (nTestSig != LOCSIG)
 		throw ZipIOException( OUString( RTL_CONSTASCII_USTRINGPARAM ( "Invalid LOC header (bad signature") ), Reference < XInterface > () );
 	aGrabber >> nVersion;
-	aGrabber >> nFlag;
+	sal_Int16 nTmp;
+	aGrabber >> nTmp;
+	nFlag = nTmp;
 	aGrabber >> nHow;
 	aGrabber >> nTime;
 	aGrabber >> nCRC;
@@ -651,16 +660,16 @@ sal_Bool ZipFile::readLOC( ZipEntry &rEn
 	aGrabber >> nSize;
 	aGrabber >> nNameLen;
 	aGrabber >> nExtraLen;
-	rEntry.nOffset = static_cast < sal_Int32 > (aGrabber.getPosition()) + nNameLen + nExtraLen;
+	xEntry->nOffset = static_cast < sal_Int32 > (aGrabber.getPosition()) + nNameLen + nExtraLen;
 
-	if ( rEntry.nNameLen == -1 ) // the file was created
-		rEntry.nNameLen = nNameLen;
+	if ( xEntry->nSize == -1 ) // the file was created
+		nNameLen = xEntry->aPath.getNameLength();
 
 	// the method can be reset for internal use so it is not checked
-	sal_Bool bBroken = rEntry.nVersion != nVersion
-					|| rEntry.nFlag != nFlag
-					|| rEntry.nTime != nTime
-					|| rEntry.nNameLen != nNameLen;
+	sal_Bool bBroken = xEntry->nVersion != nVersion
+					|| xEntry->nFlag != nFlag
+					|| xEntry->nTime != nTime
+					|| xEntry->aPath.getNameLength() != nNameLen;
 
 	if ( bBroken && !bRecoveryMode )
 		throw ZipIOException( OUString( RTL_CONSTASCII_USTRINGPARAM( "The stream seems to be broken!" ) ),
@@ -749,56 +758,63 @@ sal_Int32 ZipFile::readCEN()
 
 		MemoryByteGrabber aMemGrabber ( aCENBuffer );
 
-		ZipEntry aEntry;
 		sal_Int32 nTestSig;
 		sal_Int16 nCommentLen;
 
+		ZipPathShareHash aPathHash;
+
 		for (nCount = 0 ; nCount < nTotal; nCount++)
 		{
+			ZipEntryPtr xEntry = new ZipEntry();
+
 			aMemGrabber >> nTestSig;
 			if ( nTestSig != CENSIG )
 				throw ZipException(OUString( RTL_CONSTASCII_USTRINGPARAM ( "Invalid CEN header (bad signature)") ), Reference < XInterface > () );
 
 			aMemGrabber.skipBytes ( 2 );
-			aMemGrabber >> aEntry.nVersion;
+			aMemGrabber >> xEntry->nVersion;
 
-			if ( ( aEntry.nVersion & 1 ) == 1 )
+			if ( ( xEntry->nVersion & 1 ) == 1 )
 				throw ZipException(OUString( RTL_CONSTASCII_USTRINGPARAM ( "Invalid CEN header (encrypted entry)") ), Reference < XInterface > () );
 
-			aMemGrabber >> aEntry.nFlag;
-			aMemGrabber >> aEntry.nMethod;
+			sal_Int16 nTmp;
+			aMemGrabber >> nTmp;
+			xEntry->nFlag = nTmp;
+			aMemGrabber >> nTmp;
+			xEntry->nMethod = nTmp;
 
-			if ( aEntry.nMethod != STORED && aEntry.nMethod != DEFLATED)
+			if ( xEntry->nMethod != STORED && xEntry->nMethod != DEFLATED)
 				throw ZipException(OUString( RTL_CONSTASCII_USTRINGPARAM ( "Invalid CEN header (bad compression method)") ), Reference < XInterface > () );
 
-			aMemGrabber >> aEntry.nTime;
-			aMemGrabber >> aEntry.nCrc;
-			aMemGrabber >> aEntry.nCompressedSize;
-			aMemGrabber >> aEntry.nSize;
-			aMemGrabber >> aEntry.nNameLen;
-			aMemGrabber >> aEntry.nExtraLen;
+			aMemGrabber >> xEntry->nTime;
+			aMemGrabber >> xEntry->nCrc;
+			aMemGrabber >> xEntry->nCompressedSize;
+			aMemGrabber >> xEntry->nSize;
+			sal_Int16 nNameLen;
+			aMemGrabber >> nNameLen;
+			aMemGrabber >> xEntry->nExtraLen;
 			aMemGrabber >> nCommentLen;
 			aMemGrabber.skipBytes ( 8 );
-			aMemGrabber >> aEntry.nOffset;
+			aMemGrabber >> xEntry->nOffset;
 
-			aEntry.nOffset += nLocPos;
-			aEntry.nOffset *= -1;
+			xEntry->nOffset += nLocPos;
+			xEntry->nOffset *= -1;
 
-			if ( aEntry.nNameLen > ZIP_MAXNAMELEN )
+			if ( nNameLen > ZIP_MAXNAMELEN )
 				throw ZipException( OUString( RTL_CONSTASCII_USTRINGPARAM ( "name length exceeds ZIP_MAXNAMELEN bytes" ) ), Reference < XInterface > () );
 
 			if ( nCommentLen > ZIP_MAXNAMELEN )
 				throw ZipException( OUString( RTL_CONSTASCII_USTRINGPARAM ( "comment length exceeds ZIP_MAXNAMELEN bytes" ) ), Reference < XInterface > () );
 
-			if ( aEntry.nExtraLen > ZIP_MAXEXTRA )
+			if ( xEntry->nExtraLen > ZIP_MAXEXTRA )
 				throw ZipException( OUString( RTL_CONSTASCII_USTRINGPARAM ( "extra header info exceeds ZIP_MAXEXTRA bytes") ), Reference < XInterface > () );
 
-			aEntry.sName = OUString ( (sal_Char *) aMemGrabber.getCurrentPos(), 
-									  aEntry.nNameLen, 
-									  RTL_TEXTENCODING_ASCII_US);
+			xEntry->aPath.setName( (sal_Char *) aMemGrabber.getCurrentPos(), nNameLen, &aPathHash );
 
-			aMemGrabber.skipBytes( aEntry.nNameLen + aEntry.nExtraLen + nCommentLen );
-			aEntries[aEntry.sName] = aEntry;	
+			aMemGrabber.skipBytes( nNameLen + xEntry->nExtraLen + nCommentLen );
+			if ( aEntries.find( xEntry->aPath ) == aEntries.end() )
+				aEntries.insert_unique( xEntry );
+//			fprintf( stderr, "Accumulate entries %d\n", aEntries.size() );
 		}
 
 		if (nCount != nTotal)
@@ -809,6 +825,9 @@ sal_Int32 ZipFile::readCEN()
 		// seek can throw this...
 		nCenPos = -1; // make sure we return -1 to indicate an error
 	}
+
+	fprintf (stderr, "ZipFile::readCEN %p (%d entries)\n",
+			 this, aEntries.size());
 	return nCenPos;
 }
 
@@ -838,68 +857,69 @@ sal_Int32 ZipFile::recover()
 			{
 				if ( nPos < nBufSize - 30 && pBuffer[nPos] == 'P' && pBuffer[nPos+1] == 'K' && pBuffer[nPos+2] == 3 && pBuffer[nPos+3] == 4 )
 				{
-					ZipEntry aEntry;
+					ZipEntryPtr xEntry( new ZipEntry() );
 					MemoryByteGrabber aMemGrabber ( Sequence< sal_Int8 >( ((sal_Int8*)(&(pBuffer[nPos+4]))), 26 ) );
 
-					aMemGrabber >> aEntry.nVersion;
-					if ( ( aEntry.nVersion & 1 ) != 1 )
+					aMemGrabber >> xEntry->nVersion;
+					if ( ( xEntry->nVersion & 1 ) != 1 )
 					{
-						aMemGrabber >> aEntry.nFlag;
-						aMemGrabber >> aEntry.nMethod;
+						sal_Int16 nTmp;
+						aMemGrabber >> nTmp;
+						xEntry->nFlag = nTmp;
+						aMemGrabber >> nTmp;
+						xEntry->nMethod = nTmp;
 
-						if ( aEntry.nMethod == STORED || aEntry.nMethod == DEFLATED )
+						if ( xEntry->nMethod == STORED || xEntry->nMethod == DEFLATED )
 						{
-							aMemGrabber >> aEntry.nTime;
-							aMemGrabber >> aEntry.nCrc;
-							aMemGrabber >> aEntry.nCompressedSize;
-							aMemGrabber >> aEntry.nSize;
-							aMemGrabber >> aEntry.nNameLen;
-							aMemGrabber >> aEntry.nExtraLen;
+							aMemGrabber >> xEntry->nTime;
+							aMemGrabber >> xEntry->nCrc;
+							aMemGrabber >> xEntry->nCompressedSize;
+							aMemGrabber >> xEntry->nSize;
+							sal_Int16 nNameLen;
+							aMemGrabber >> nNameLen;
+							aMemGrabber >> xEntry->nExtraLen;
 
 							sal_Int32 nDescrLength = 
-								( aEntry.nMethod == DEFLATED && ( aEntry.nFlag & 8 ) ) ?
+								( xEntry->nMethod == DEFLATED && ( xEntry->nFlag & 8 ) ) ?
 														16 : 0;
 
 
 							// This is a quick fix for OOo1.1RC
 							// For OOo2.0 the whole package must be switched to unsigned values
-							if ( aEntry.nCompressedSize < 0 ) aEntry.nCompressedSize = 0x7FFFFFFF;
-							if ( aEntry.nSize < 0 ) aEntry.nSize = 0x7FFFFFFF;
-							if ( aEntry.nNameLen < 0 ) aEntry.nNameLen = 0x7FFF;
-							if ( aEntry.nExtraLen < 0 ) aEntry.nExtraLen = 0x7FFF;
+							if ( xEntry->nCompressedSize < 0 ) xEntry->nCompressedSize = 0x7FFFFFFF;
+							if ( xEntry->nSize < 0 ) xEntry->nSize = 0x7FFFFFFF;
+							if ( nNameLen < 0 ) nNameLen = 0x7FFF;
+							if ( xEntry->nExtraLen < 0 ) xEntry->nExtraLen = 0x7FFF;
 							// End of quick fix
 
 
-							sal_Int32 nBlockLength = aEntry.nSize + aEntry.nNameLen + aEntry.nExtraLen + 30 + nDescrLength;
-							if ( aEntry.nNameLen <= ZIP_MAXNAMELEN && aEntry.nExtraLen < ZIP_MAXEXTRA 
+							sal_Int32 nBlockLength = xEntry->nSize + nNameLen + xEntry->nExtraLen + 30 + nDescrLength;
+							if ( nNameLen <= ZIP_MAXNAMELEN && xEntry->nExtraLen < ZIP_MAXEXTRA 
 								&& ( nGenPos + nPos + nBlockLength ) <= nLength )
 							{
-								if( nPos + 30 + aEntry.nNameLen <= nBufSize )
-									aEntry.sName = OUString ( (sal_Char *) &pBuffer[nPos + 30], 
-									  							aEntry.nNameLen, 
-																RTL_TEXTENCODING_ASCII_US);
+								if( nPos + 30 + nNameLen <= nBufSize )
+									xEntry->setName( OString ( (sal_Char *) &pBuffer[nPos + 30], 
+															 nNameLen ) );
 								else
 								{
 									Sequence < sal_Int8 > aFileName;
 									aGrabber.seek( nGenPos + nPos + 30 );
-									aGrabber.readBytes( aFileName, aEntry.nNameLen );
-									aEntry.sName = OUString ( (sal_Char *) aFileName.getArray(), 
-																aFileName.getLength(), 
-																RTL_TEXTENCODING_ASCII_US);
-									aEntry.nNameLen = aFileName.getLength();
+									aGrabber.readBytes( aFileName, nNameLen );
+									xEntry->setName( OString ( (sal_Char *) aFileName.getArray(), 
+															  aFileName.getLength() ) );
 								}
 
-								aEntry.nOffset = nGenPos + nPos + 30 + aEntry.nNameLen + aEntry.nExtraLen;
+								xEntry->nOffset = nGenPos + nPos + 30 + nNameLen + xEntry->nExtraLen;
 
-								if ( ( aEntry.nSize || aEntry.nCompressedSize ) && !checkSizeAndCRC( aEntry ) )
+								if ( ( xEntry->nSize || xEntry->nCompressedSize ) && !checkSizeAndCRC( xEntry ) )
 								{
-									aEntry.nCrc = 0;
-									aEntry.nCompressedSize = 0;
-									aEntry.nSize = 0;
+									xEntry->nCrc = 0;
+									xEntry->nCompressedSize = 0;
+									xEntry->nSize = 0;
 								}
 
-								if ( aEntries.find( aEntry.sName ) == aEntries.end() )
-									aEntries[aEntry.sName] = aEntry;
+								if ( aEntries.find( xEntry->aPath ) == aEntries.end() )
+									aEntries.insert_unique( xEntry );
 							}
 						}
 					}
@@ -916,30 +936,30 @@ sal_Int32 ZipFile::recover()
 
 					for( EntryHash::iterator aIter = aEntries.begin(); aIter != aEntries.end(); aIter++ )
 					{
-						ZipEntry aTmp = (*aIter).second;
-						if( (*aIter).second.nMethod == DEFLATED && (*aIter).second.nFlag & 8 )
+						ZipEntry *pEntry = (*aIter).get();
+						if( pEntry->nMethod == DEFLATED && pEntry->nFlag & 8 )
 						{
 							sal_Int32 nStreamOffset = nGenPos + nPos - nCompressedSize;
-							sal_Int32 nTmp1 = (*aIter).second.nOffset;
-							if ( nStreamOffset == (*aIter).second.nOffset && nCompressedSize > (*aIter).second.nCompressedSize )
+							sal_Int32 nTmp1 = pEntry->nOffset;
+							if ( nStreamOffset == pEntry->nOffset && nCompressedSize > pEntry->nCompressedSize )
 							{
 								sal_Int32 nRealSize = 0, nRealCRC = 0;
 								getSizeAndCRC( nStreamOffset, nCompressedSize, &nRealSize, &nRealCRC );
 								if ( nRealSize == nSize && nRealCRC == nCRC32 )
 								{
-									(*aIter).second.nCrc = nCRC32;
-									(*aIter).second.nCompressedSize = nCompressedSize;
-									(*aIter).second.nSize = nSize;
+									pEntry->nCrc = nCRC32;
+									pEntry->nCompressedSize = nCompressedSize;
+									pEntry->nSize = nSize;
 								}
 							}
 #if 0
 // for now ignore clearly broken streams
-							else if( !(*aIter).second.nCompressedSize )
+							else if( !pEntry->nCompressedSize )
 							{
-								(*aIter).second.nCrc = nCRC32;
-								sal_Int32 nRealStreamSize = nGenPos + nPos - (*aIter).second.nOffset;
-								(*aIter).second.nCompressedSize = nGenPos + nPos - (*aIter).second.nOffset;
-								(*aIter).second.nSize = nSize;
+								pEntry->nCrc = nCRC32;
+								sal_Int32 nRealStreamSize = nGenPos + nPos - pEntry->nOffset;
+								pEntry->nCompressedSize = nGenPos + nPos - pEntry->nOffset;
+								pEntry->nSize = nSize;
 							}
 #endif
 						}
@@ -973,15 +993,15 @@ sal_Int32 ZipFile::recover()
 
 }
 
-sal_Bool ZipFile::checkSizeAndCRC( const ZipEntry& aEntry )
+sal_Bool ZipFile::checkSizeAndCRC( const ZipEntryPtr &xEntry )
 {
 	sal_Int32 nSize = 0, nCRC = 0;
 
-	if( aEntry.nMethod == STORED )
-		return ( getCRC( aEntry.nOffset, aEntry.nSize ) == aEntry.nCrc );
+	if( xEntry->nMethod == STORED )
+		return ( getCRC( xEntry->nOffset, xEntry->nSize ) == xEntry->nCrc );
 
-	getSizeAndCRC( aEntry.nOffset, aEntry.nCompressedSize, &nSize, &nCRC );
-	return ( aEntry.nSize == nSize && aEntry.nCrc == nCRC );
+	getSizeAndCRC( xEntry->nOffset, xEntry->nCompressedSize, &nSize, &nCRC );
+	return ( xEntry->nSize == nSize && xEntry->nCrc == nCRC );
 }
 
 sal_Int32 ZipFile::getCRC( sal_Int32 nOffset, sal_Int32 nSize )
@@ -1038,3 +1058,8 @@ void ZipFile::getSizeAndCRC( sal_Int32 n
 		*nSize = *nCRC = 0;
 		
 }
+
+void ZipFile::copyEntries( EntryHash &rDestEntries )
+{
+	rDestEntries = aEntries;
+}
Index: package/source/zipapi/ZipOutputStream.cxx
===================================================================
RCS file: /cvs/xml/package/source/zipapi/ZipOutputStream.cxx,v
retrieving revision 1.37
diff -u -p -u -r1.37 ZipOutputStream.cxx
--- package/source/zipapi/ZipOutputStream.cxx	24 Mar 2006 13:21:55 -0000	1.37
+++ package/source/zipapi/ZipOutputStream.cxx	25 Jul 2006 15:50:29 -0000
@@ -77,7 +77,7 @@ ZipOutputStream::ZipOutputStream( Refere
 : xStream(xOStream)
 , aChucker(xOStream)
 , nMethod(DEFLATED)
-, pCurrentEntry(NULL)
+, xCurrentEntry()
 , bFinished(sal_False)
 , bEncryptCurrentEntry(sal_False)
 , aBuffer(n_ConstBufferSize)
@@ -87,8 +87,7 @@ ZipOutputStream::ZipOutputStream( Refere
 
 ZipOutputStream::~ZipOutputStream( void )
 {
-	for (sal_Int32 i = 0, nEnd = aZipList.size(); i < nEnd; i++)
-		delete aZipList[i];
+	aZipList.clear();
 }
 
 void SAL_CALL ZipOutputStream::setComment( const ::rtl::OUString& rComment ) 
@@ -107,24 +106,24 @@ void SAL_CALL ZipOutputStream::setLevel(
 	aDeflater.setLevel( nNewLevel);
 }
 
-void SAL_CALL ZipOutputStream::putNextEntry( ZipEntry& rEntry, 
+void SAL_CALL ZipOutputStream::putNextEntry( const ZipEntryPtr &xEntry, 
 						vos::ORef < EncryptionData > &xEncryptData,
 						sal_Bool bEncrypt)
 	throw(IOException, RuntimeException)
 {
-	if (pCurrentEntry != NULL)
+	if (xCurrentEntry.is())
 		closeEntry();
-	if (rEntry.nTime == -1)
-		rEntry.nTime = getCurrentDosTime();
-	if (rEntry.nMethod == -1)
-		rEntry.nMethod = nMethod;
-	rEntry.nVersion = 20;
-	if (rEntry.nSize == -1 || rEntry.nCompressedSize == -1 ||
-		rEntry.nCrc == -1)
-		rEntry.nFlag = 8;
-	else if (rEntry.nSize != -1 && rEntry.nCompressedSize != -1 &&
-		rEntry.nCrc != -1)
-		rEntry.nFlag = 0;
+	if (xEntry->nTime == -1)
+		xEntry->nTime = getCurrentDosTime();
+	if (xEntry->nMethod == -1)
+		xEntry->nMethod = nMethod;
+	xEntry->nVersion = 20;
+	if (xEntry->nSize == -1 || xEntry->nCompressedSize == -1 ||
+		xEntry->nCrc == -1)
+		xEntry->nFlag = 8;
+	else if (xEntry->nSize != -1 && xEntry->nCompressedSize != -1 &&
+		xEntry->nCrc != -1)
+		xEntry->nFlag = 0;
 
 	if (bEncrypt)
 	{
@@ -140,13 +139,13 @@ void SAL_CALL ZipOutputStream::putNextEn
 		OSL_ASSERT( aResult == rtl_Cipher_E_None );
 		aDigest = rtl_digest_createSHA1();
 		mnDigested = 0;
-		rEntry.nFlag |= 1 << 4;
+		xEntry->nFlag |= 1 << 4;
 		pCurrentEncryptData = xEncryptData.getBodyPtr();
 	}
-	sal_Int32 nLOCLength = writeLOC(rEntry);
-	rEntry.nOffset = static_cast < sal_Int32 > (aChucker.getPosition()) - nLOCLength;
-	aZipList.push_back( &rEntry );
-	pCurrentEntry = &rEntry;
+	sal_Int32 nLOCLength = writeLOC( xEntry );
+	xEntry->nOffset = static_cast < sal_Int32 > (aChucker.getPosition()) - nLOCLength;
+	aZipList.push_back( xEntry );
+	xCurrentEntry = xEntry;
 }
 void SAL_CALL ZipOutputStream::close(  ) 
 	throw(IOException, RuntimeException)
@@ -157,47 +156,47 @@ void SAL_CALL ZipOutputStream::close(  )
 void SAL_CALL ZipOutputStream::closeEntry(  ) 
 	throw(IOException, RuntimeException)
 {
-	ZipEntry *pEntry = pCurrentEntry;
-	if (pEntry)
+	ZipEntryPtr &xEntry = xCurrentEntry;
+	if (xEntry.is())
 	{
-		switch (pEntry->nMethod)
+		switch (xEntry->nMethod)
 		{
 			case DEFLATED:
 				aDeflater.finish();
 				while (!aDeflater.finished())
 					doDeflate();
-				if ((pEntry->nFlag & 8) == 0)
+				if ((xEntry->nFlag & 8) == 0)
 				{
-					if (pEntry->nSize != aDeflater.getTotalIn())
+					if (xEntry->nSize != aDeflater.getTotalIn())
 					{
 						VOS_DEBUG_ONLY("Invalid entry size");
 					}
-					if (pEntry->nCompressedSize != aDeflater.getTotalOut())
+					if (xEntry->nCompressedSize != aDeflater.getTotalOut())
 					{
 						//VOS_DEBUG_ONLY("Invalid entry compressed size");
 						// Different compression strategies make the merit of this
 						// test somewhat dubious
-						pEntry->nCompressedSize = aDeflater.getTotalOut();
+						xEntry->nCompressedSize = aDeflater.getTotalOut();
 					}
-					if (pEntry->nCrc != aCRC.getValue())
+					if (xEntry->nCrc != aCRC.getValue())
 					{
 						VOS_DEBUG_ONLY("Invalid entry CRC-32");
 					}
 				}
 				else
 				{
-					pEntry->nSize = aDeflater.getTotalIn();
-					pEntry->nCompressedSize = aDeflater.getTotalOut();
-					pEntry->nCrc = aCRC.getValue();
+					xEntry->nSize = aDeflater.getTotalIn();
+					xEntry->nCompressedSize = aDeflater.getTotalOut();
+					xEntry->nCrc = aCRC.getValue();
 					if ( bEncryptCurrentEntry )
-						pEntry->nSize = pEntry->nCompressedSize;
-					writeEXT(*pEntry);
+						xEntry->nSize = xEntry->nCompressedSize;
+					writeEXT( xEntry );
 				}
 				aDeflater.reset();
 				aCRC.reset();
 				break;
 			case STORED:
-				if (!((pEntry->nFlag & 8) == 0))
+				if (!((xEntry->nFlag & 8) == 0))
 					VOS_ENSURE ( 0, "Serious error, one of compressed size, size or CRC was -1 in a STORED stream");
 				break;
 			default:
@@ -218,14 +217,14 @@ void SAL_CALL ZipOutputStream::closeEntr
 			OSL_ASSERT( aDigestResult == rtl_Digest_E_None );
 			rtl_digest_destroySHA1 ( aDigest );
 		}
-		pCurrentEntry = NULL;
+		xCurrentEntry = ZipEntryPtr();
 	}
 }
 
 void SAL_CALL ZipOutputStream::write( const Sequence< sal_Int8 >& rBuffer, sal_Int32 nNewOffset, sal_Int32 nNewLength ) 
 	throw(IOException, RuntimeException)
 {
-	switch (pCurrentEntry->nMethod)
+	switch (xCurrentEntry->nMethod)
 	{
 		case DEFLATED:
 			if (!aDeflater.finished())
@@ -256,9 +255,9 @@ void SAL_CALL ZipOutputStream::rawWrite(
 void SAL_CALL ZipOutputStream::rawCloseEntry(  ) 
 	throw(IOException, RuntimeException)
 {
-	if ( pCurrentEntry->nMethod == DEFLATED && ( pCurrentEntry->nFlag & 8 ) )
-		writeEXT(*pCurrentEntry);
-	pCurrentEntry = NULL;
+	if ( xCurrentEntry->nMethod == DEFLATED && ( xCurrentEntry->nFlag & 8 ) )
+		writeEXT( xCurrentEntry );
+	xCurrentEntry = ZipEntryPtr();
 }
 
 void SAL_CALL ZipOutputStream::finish(  ) 
@@ -267,7 +266,7 @@ void SAL_CALL ZipOutputStream::finish(  
 	if (bFinished)
 		return;
 
-	if (pCurrentEntry != NULL)
+	if (xCurrentEntry.is())
 		closeEntry();
 
 	if (aZipList.size() < 1)
@@ -275,7 +274,7 @@ void SAL_CALL ZipOutputStream::finish(  
 
 	sal_Int32 nOffset= static_cast < sal_Int32 > (aChucker.getPosition());
 	for (sal_Int32 i =0, nEnd = aZipList.size(); i < nEnd; i++)
-		writeCEN( *aZipList[i] );
+		writeCEN( aZipList[i] );
 	writeEND( nOffset, static_cast < sal_Int32 > (aChucker.getPosition()) - nOffset);
 	bFinished = sal_True;
 	xStream->flush();
@@ -330,84 +329,78 @@ void ZipOutputStream::writeEND(sal_uInt3
 	aChucker << nOffset;
 	aChucker << static_cast < sal_Int16 > ( 0 );
 }
-void ZipOutputStream::writeCEN( const ZipEntry &rEntry )
+
+void ZipOutputStream::writeCEN( const ZipEntryPtr &xEntry )
 	throw(IOException, RuntimeException)
 {
-	sal_Int16 nNameLength 		= static_cast < sal_Int16 > ( rEntry.sName.getLength() );
+	sal_Int16 nNameLength = static_cast < sal_Int16 > ( xEntry->aPath.getNameLength() );
 
 	aChucker << CENSIG;
-	aChucker << rEntry.nVersion;
-	aChucker << rEntry.nVersion;
-	if (rEntry.nFlag & (1 << 4) )
+	aChucker << xEntry->nVersion;
+	aChucker << xEntry->nVersion;
+	if (xEntry->nFlag & (1 << 4) )
 	{
 		// If it's an encrypted entry, we pretend its stored plain text
-		ZipEntry *pEntry = const_cast < ZipEntry * > ( &rEntry );
-		pEntry->nFlag &= ~(1 <<4 );
-		aChucker << rEntry.nFlag;
+// FIXME: do we really want to change the XEntry ? why not use a temporary
+		xEntry->nFlag &= ~(1 <<4 );
+		aChucker << xEntry->nFlag;
 		aChucker << static_cast < sal_Int16 > ( STORED );
 	}
 	else
 	{
-		aChucker << rEntry.nFlag;
-		aChucker << rEntry.nMethod;
+		aChucker << xEntry->nFlag;
+		aChucker << xEntry->nMethod;
 	}
-	aChucker << static_cast < sal_uInt32> ( rEntry.nTime );
-	aChucker << static_cast < sal_uInt32> ( rEntry.nCrc );
-	aChucker << rEntry.nCompressedSize;
-	aChucker << rEntry.nSize;
+	aChucker << static_cast < sal_uInt32> ( xEntry->nTime );
+	aChucker << static_cast < sal_uInt32> ( xEntry->nCrc );
+	aChucker << xEntry->nCompressedSize;
+	aChucker << xEntry->nSize;
 	aChucker << nNameLength;
 	aChucker << static_cast < sal_Int16> (0);
 	aChucker << static_cast < sal_Int16> (0);
 	aChucker << static_cast < sal_Int16> (0);
 	aChucker << static_cast < sal_Int16> (0);
 	aChucker << static_cast < sal_Int32> (0);
-	aChucker << rEntry.nOffset;
-
-	const sal_Unicode *pChar = rEntry.sName.getStr();
-	Sequence < sal_Int8 > aSequence (nNameLength);
-	sal_Int8 *pArray = aSequence.getArray();
+	aChucker << xEntry->nOffset;
 
-	VOS_ENSURE ( Impl_IsValidChar ( pChar, nNameLength, sal_True ), "Non US ASCII character in zipentry name!");
-	for ( sal_Int16 i = 0; i < nNameLength; i++)
-		pArray[i] = static_cast < const sal_Int8 > (pChar[i]);
-
-	aChucker.writeBytes( aSequence, nNameLength, pArray );
+	xEntry->aPath.writeName( aChucker );
 }
-void ZipOutputStream::writeEXT( const ZipEntry &rEntry )
+
+void ZipOutputStream::writeEXT( const ZipEntryPtr &xEntry )
 	throw(IOException, RuntimeException)
 {
 	aChucker << EXTSIG;
-	aChucker << static_cast < sal_uInt32> ( rEntry.nCrc );
-	aChucker << rEntry.nCompressedSize;
-	aChucker << rEntry.nSize;
+	aChucker << static_cast < sal_uInt32> ( xEntry->nCrc );
+	aChucker << xEntry->nCompressedSize;
+	aChucker << xEntry->nSize;
 }
 
-sal_Int32 ZipOutputStream::writeLOC( const ZipEntry &rEntry )
+sal_Int32 ZipOutputStream::writeLOC( const ZipEntryPtr &xEntry )
 	throw(IOException, RuntimeException)
 {
-	sal_Int16 nNameLength = static_cast < sal_Int16 > (rEntry.sName.getLength());
+	sal_Int16 nNameLength = static_cast < sal_Int16 > (xEntry->aPath.getNameLength());
 	Sequence < sal_Int8 > aSequence(nNameLength);
 	sal_Int8 *pArray = aSequence.getArray();
 
 	aChucker << LOCSIG;
-	aChucker << rEntry.nVersion;
+	aChucker << xEntry->nVersion;
 
-	if (rEntry.nFlag & (1 << 4) )
+	if (xEntry->nFlag & (1 << 4) )
 	{
 		// If it's an encrypted entry, we pretend its stored plain text
-		sal_Int16 nTmpFlag = rEntry.nFlag;
+		sal_Int16 nTmpFlag = xEntry->nFlag;
 		nTmpFlag &= ~(1 <<4 );
 		aChucker << nTmpFlag;
 		aChucker << static_cast < sal_Int16 > ( STORED );
 	}
 	else
 	{
-		aChucker << rEntry.nFlag;
-		aChucker << rEntry.nMethod;
+		aChucker << xEntry->nFlag;
+		aChucker << xEntry->nMethod;
 	}
 
-	aChucker << static_cast < sal_uInt32 > (rEntry.nTime);
-	if ((rEntry.nFlag & 8) == 8 )
+	aChucker << static_cast < sal_uInt32 > (xEntry->nTime);
+	if ((xEntry->nFlag & 8) == 8 )
 	{
 		aChucker << static_cast < sal_Int32 > (0);
 		aChucker << static_cast < sal_Int32 > (0);
@@ -415,18 +408,15 @@ sal_Int32 ZipOutputStream::writeLOC( con
 	}
 	else
 	{
-		aChucker << static_cast < sal_uInt32 > (rEntry.nCrc);
-		aChucker << rEntry.nCompressedSize;
-		aChucker << rEntry.nSize;
+		aChucker << static_cast < sal_uInt32 > (xEntry->nCrc);
+		aChucker << xEntry->nCompressedSize;
+		aChucker << xEntry->nSize;
 	}
 	aChucker << nNameLength;
 	aChucker << static_cast < sal_Int16 > (0);
 
-	const sal_Unicode *pChar = rEntry.sName.getStr();
-	VOS_ENSURE ( Impl_IsValidChar ( pChar, nNameLength, sal_True ), "Non US ASCII character in zipentry name!");
-	for ( sal_Int16 i = 0; i < nNameLength; i++)
-		pArray[i] = static_cast < const sal_Int8 > (pChar[i]);
-	aChucker.writeBytes( aSequence, nNameLength, pArray );
+	xEntry->aPath.writeName( aChucker );
+
 	return LOCHDR + nNameLength;
 }
 sal_uInt32 ZipOutputStream::getCurrentDosTime( )
Index: package/source/zipapi/makefile.mk
===================================================================
RCS file: /cvs/xml/package/source/zipapi/makefile.mk,v
retrieving revision 1.16
diff -u -p -u -r1.16 makefile.mk
--- package/source/zipapi/makefile.mk	8 Sep 2005 16:16:13 -0000	1.16
+++ package/source/zipapi/makefile.mk	25 Jul 2006 15:50:29 -0000
@@ -40,6 +40,8 @@ AUTOSEG=true
 
 ENABLE_EXCEPTIONS=TRUE
 
+CFLAGS+= -O0
+
 # --- Settings -----------------------------------------------------
 
 .INCLUDE : svpre.mk
@@ -52,6 +54,7 @@ ENABLE_EXCEPTIONS=TRUE
 CFLAGS+=-DSYSTEM_ZLIB
 .ENDIF
 SLOFILES= \
+		$(SLO)$/ZipEntry.obj			\
 		$(SLO)$/Adler32.obj			\
 		$(SLO)$/CRC32.obj			\
 		$(SLO)$/ByteChucker.obj		\
Index: package/source/zippackage/ZipPackage.cxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ZipPackage.cxx,v
retrieving revision 1.103
diff -u -p -u -r1.103 ZipPackage.cxx
--- package/source/zippackage/ZipPackage.cxx	1 Feb 2006 19:14:50 -0000	1.103
+++ package/source/zippackage/ZipPackage.cxx	25 Jul 2006 15:50:29 -0000
@@ -310,8 +310,8 @@ void ZipPackage::getZipFileContents()
 	{
 		nIndex = nOldIndex = 0;
 		pCurrent = pRootFolder;
-		const ZipEntry & rEntry = *pEnum->nextElement();
-		const OUString & rName = rEntry.sName;
+		const ZipEntryPtr &xEntry = pEnum->nextElement();
+		OUString rName = xEntry->getName();
 
 		nStreamIndex = rName.lastIndexOf ( '/' );
 		if ( nStreamIndex != -1 )
@@ -322,6 +322,8 @@ void ZipPackage::getZipFileContents()
 				pCurrent = (*aIter).second;
 		}
 
+		// FIXME: this can be made more efficient:
+		//        we can know all the path information ahead of time ...
 		if ( pCurrent == pRootFolder )
 		{
 			while ( (nIndex = rName.indexOf('/', nOldIndex) ) != -1 )
@@ -349,7 +351,7 @@ void ZipPackage::getZipFileContents()
 			sTemp = rName.copy( nStreamIndex, rName.getLength() - nStreamIndex);
 			pPkgStream = new ZipPackageStream( *this, xFactory, m_bAllowRemoveOnInsert );
 			pPkgStream->SetPackageMember( sal_True );
-			pPkgStream->setZipEntry( rEntry );
+			pPkgStream->setZipEntry( xEntry );
 			pPkgStream->setName( sTemp );
 			pPkgStream->doSetParent( pCurrent, sal_True );
 		} 
@@ -872,26 +874,25 @@ void ZipPackage::WriteMimetypeMagicFile(
 	if (xRootFolder->hasByName( sMime ) )
 		xRootFolder->removeByName( sMime );
 
-	ZipEntry * pEntry = new ZipEntry;
+	ZipEntryPtr xEntry( new ZipEntry );
 	sal_Int32 nBufferLength = pRootFolder->GetMediaType( ).getLength();
 	OString sMediaType = OUStringToOString( pRootFolder->GetMediaType(), RTL_TEXTENCODING_ASCII_US );
 	Sequence< sal_Int8 > aType( (sal_Int8*)sMediaType.getStr(),
 								nBufferLength );
 
-	
-	pEntry->sName = sMime;
-	pEntry->nMethod = STORED;
-	pEntry->nSize = pEntry->nCompressedSize = nBufferLength;
-	pEntry->nTime = ZipOutputStream::getCurrentDosTime();
+	xEntry->setName( sMime );
+	xEntry->nMethod = STORED;
+	xEntry->nSize = xEntry->nCompressedSize = nBufferLength;
+	xEntry->nTime = ZipOutputStream::getCurrentDosTime();
 
 	CRC32 aCRC32;
 	aCRC32.update( aType );
-	pEntry->nCrc = aCRC32.getValue();
+	xEntry->nCrc = aCRC32.getValue();
 
 	try
 	{
 		vos::ORef < EncryptionData > xEmpty;
-		aZipOut.putNextEntry( *pEntry, xEmpty );
+		aZipOut.putNextEntry( xEntry, xEmpty );
 		aZipOut.write( aType, 0, nBufferLength );
 		aZipOut.closeEntry();
 	}
@@ -1013,14 +1014,14 @@ sal_Bool ZipPackage::writeFileIsTemp()
 			Reference < XManifestWriter > xWriter ( xFactory->createInstance( sManifestWriter ), UNO_QUERY );
 			if ( xWriter.is() )
 			{
-				ZipEntry * pEntry = new ZipEntry;
+				ZipEntryPtr xEntry( new ZipEntry );
 				ZipPackageBuffer *pBuffer = new ZipPackageBuffer( n_ConstBufferSize );
 				xManOutStream = Reference < XOutputStream > (*pBuffer, UNO_QUERY);
 
-				pEntry->sName = OUString( RTL_CONSTASCII_USTRINGPARAM ( "META-INF/manifest.xml") );
-				pEntry->nMethod = DEFLATED;
-				pEntry->nCrc = pEntry->nSize = pEntry->nCompressedSize = -1;
-				pEntry->nTime = ZipOutputStream::getCurrentDosTime();
+				xEntry->aPath.setName( OString( "META-INF/manifest.xml") );
+				xEntry->nMethod = DEFLATED;
+				xEntry->nCrc = xEntry->nSize = xEntry->nCompressedSize = -1;
+				xEntry->nTime = ZipOutputStream::getCurrentDosTime();
 		
 				// Convert vector into a Sequence
 				Sequence < Sequence < PropertyValue > > aManifestSequence ( aManList.size() );
@@ -1036,7 +1037,7 @@ sal_Bool ZipPackage::writeFileIsTemp()
 
 				// the manifest.xml is never encrypted - so pass an empty reference
 				vos::ORef < EncryptionData > xEmpty;
-				aZipOut.putNextEntry( *pEntry, xEmpty );
+				aZipOut.putNextEntry( xEntry, xEmpty );
 				aZipOut.write( pBuffer->getSequence(), 0, nBufferLength );
 				aZipOut.closeEntry();
 			}
Index: package/source/zippackage/ZipPackageEntry.cxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ZipPackageEntry.cxx,v
retrieving revision 1.27
diff -u -p -u -r1.27 ZipPackageEntry.cxx
--- package/source/zippackage/ZipPackageEntry.cxx	8 Sep 2005 16:17:29 -0000	1.27
+++ package/source/zippackage/ZipPackageEntry.cxx	25 Jul 2006 15:50:29 -0000
@@ -66,6 +66,7 @@ ZipPackageEntry::ZipPackageEntry ( bool 
 : pParent ( NULL )
 , mbIsFolder ( bNewFolder )
 , mbAllowRemoveOnInsert( sal_True )
+, xEntry( new ZipEntry() )
 {
 }
 
@@ -79,22 +80,23 @@ ZipPackageEntry::~ZipPackageEntry()
 OUString SAL_CALL ZipPackageEntry::getName(  ) 
 	throw(RuntimeException)
 {
-	return aEntry.sName;
+	return xEntry->getName();
 }
 void SAL_CALL ZipPackageEntry::setName( const OUString& aName ) 
 	throw(RuntimeException)
 {
-	if ( pParent && pParent->hasByName ( aEntry.sName ) )
-		pParent->removeByName ( aEntry.sName );
+	if ( pParent && pParent->hasByName ( xEntry->getName() ) )
+		pParent->removeByName ( xEntry->getName() );
 
 	const sal_Unicode *pChar = aName.getStr();
 	VOS_ENSURE ( Impl_IsValidChar (pChar, static_cast < sal_Int16 > ( aName.getLength() ), sal_False), "Invalid character in new zip package entry name!");
 	
-	aEntry.sName = aName;
+	xEntry->setName( aName );
 
 	if ( pParent )
 		pParent->doInsertByName ( this, sal_False );
 }
+
 Reference< XInterface > SAL_CALL ZipPackageEntry::getParent(  ) 
 		throw(RuntimeException)
 {
@@ -106,7 +108,7 @@ void ZipPackageEntry::doSetParent ( ZipP
 {
 	// xParent = pParent = pNewParent;
 	pParent = pNewParent;
-	if ( bInsert && !pNewParent->hasByName ( aEntry.sName ) )
+	if ( bInsert && !pNewParent->hasByName ( xEntry->getName() ) )
 		pNewParent->doInsertByName ( this, sal_False );
 }
 
@@ -122,8 +124,8 @@ void SAL_CALL ZipPackageEntry::setParent
 
 	if ( pNewParent != pParent )
 	{
-		if ( pParent && pParent->hasByName ( aEntry.sName ) && mbAllowRemoveOnInsert )
-			pParent->removeByName( aEntry.sName );
+		if ( pParent && pParent->hasByName ( xEntry->getName() ) && mbAllowRemoveOnInsert )
+			pParent->removeByName( xEntry->getName() );
 		doSetParent ( pNewParent, sal_True );
 	}
 }
Index: package/source/zippackage/ZipPackageEntry.hxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ZipPackageEntry.hxx,v
retrieving revision 1.14
diff -u -p -u -r1.14 ZipPackageEntry.hxx
--- package/source/zippackage/ZipPackageEntry.hxx	8 Sep 2005 16:17:49 -0000	1.14
+++ package/source/zippackage/ZipPackageEntry.hxx	25 Jul 2006 15:50:29 -0000
@@ -78,7 +78,7 @@ protected:
 	::rtl::OUString		sMediaType;
 	ZipPackageFolder * pParent;
 public:
-	ZipEntry aEntry;
+	ZipEntryPtr xEntry;
 	ZipPackageEntry ( bool bNewFolder = sal_False );
 	virtual ~ZipPackageEntry( void );
 
Index: package/source/zippackage/ZipPackageFolder.cxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ZipPackageFolder.cxx,v
retrieving revision 1.80
diff -u -p -u -r1.80 ZipPackageFolder.cxx
--- package/source/zippackage/ZipPackageFolder.cxx	10 Nov 2005 15:51:45 -0000	1.80
+++ package/source/zippackage/ZipPackageFolder.cxx	25 Jul 2006 15:50:29 -0000
@@ -97,26 +97,24 @@ Sequence < sal_Int8 > ZipPackageFolder::
 ZipPackageFolder::ZipPackageFolder ( const Reference< XMultiServiceFactory >& xFactory,
 									 sal_Bool bPackageFormat,
 									 sal_Bool bAllowRemoveOnInsert ) 
-: m_xFactory( xFactory )
+: ZipPackageFolderParent( sal_True )
+, m_xFactory( xFactory )
 , m_bPackageFormat( bPackageFormat )
 {
 	OSL_ENSURE( m_xFactory.is(), "No factory is provided to the package folder!" );
 
 	this->mbAllowRemoveOnInsert = bAllowRemoveOnInsert;
 
-	SetFolder ( sal_True );
-	aEntry.nVersion		= -1;
-	aEntry.nFlag		= 0;
-	aEntry.nMethod		= STORED;
-	aEntry.nTime		= -1;
-	aEntry.nCrc			= 0;
-	aEntry.nCompressedSize	= 0;
-	aEntry.nSize		= 0;
-	aEntry.nOffset		= -1;
+	xEntry->nVersion		= -1;
+	xEntry->nFlag		= 0;
+	xEntry->nMethod		= STORED;
+	xEntry->nTime		= -1;
+	xEntry->nCrc			= 0;
+	xEntry->nCompressedSize	= 0;
+	xEntry->nSize		= 0;
+	xEntry->nOffset		= -1;
 	if ( !aImplementationId.getLength() )
-        {
 		aImplementationId = getImplementationId();
-        }
 }
 
 
@@ -124,22 +122,7 @@ ZipPackageFolder::~ZipPackageFolder()
 {
 }
 
-void ZipPackageFolder::copyZipEntry( ZipEntry &rDest, const ZipEntry &rSource)
-{
-  	rDest.nVersion			= rSource.nVersion;
-    rDest.nFlag				= rSource.nFlag;
-    rDest.nMethod			= rSource.nMethod;
-    rDest.nTime				= rSource.nTime;
-    rDest.nCrc				= rSource.nCrc;
-    rDest.nCompressedSize	= rSource.nCompressedSize;
-    rDest.nSize				= rSource.nSize;
-    rDest.nOffset			= rSource.nOffset;
-    rDest.sName				= rSource.sName;
-    rDest.nNameLen			= rSource.nNameLen;
-    rDest.nExtraLen			= rSource.nExtraLen;
-}
-
-	// XNameContainer
+// XNameContainer
 void SAL_CALL ZipPackageFolder::insertByName( const OUString& aName, const Any& aElement ) 
 		throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
 {
@@ -241,16 +224,16 @@ void SAL_CALL ZipPackageFolder::replaceB
 	insertByName(aName, aElement);
 }
 
-static void ImplSetStoredData( ZipEntry & rEntry, Reference < XInputStream> & rStream )
+static void ImplSetStoredData( const ZipEntryPtr &xEntry, Reference < XInputStream> & rStream )
 {
 	// It's very annoying that we have to do this, but lots of zip packages
 	// don't allow data descriptors for STORED streams, meaning we have to 
 	// know the size and CRC32 of uncompressed streams before we actually
 	// write them !
 	CRC32 aCRC32;
-	rEntry.nMethod = STORED;
-	rEntry.nCompressedSize = rEntry.nSize = aCRC32.updateStream ( rStream );
-	rEntry.nCrc = aCRC32.getValue();
+	xEntry->nMethod = STORED;
+	xEntry->nCompressedSize = xEntry->nSize = aCRC32.updateStream ( rStream );
+	xEntry->nCrc = aCRC32.getValue();
 }
 
 void ZipPackageFolder::saveContents(OUString &rPath, std::vector < Sequence < PropertyValue > > &rManList, ZipOutputStream & rZipOut, Sequence < sal_Int8 > &rEncryptionKey, rtlRandomPool &rRandomPool)
@@ -272,16 +255,14 @@ void ZipPackageFolder::saveContents(OUSt
 	if ( maContents.begin() == maContents.end() && rPath.getLength() )
 	{
 		// it is an empty subfolder, use workaround to store it
-		ZipEntry* pTempEntry = new ZipEntry();
-		ZipPackageFolder::copyZipEntry ( *pTempEntry, aEntry );
-		pTempEntry->nNameLen = (sal_Int16)rPath.getLength();
-		pTempEntry->nExtraLen = -1;
-		pTempEntry->sName = rPath;
+		ZipEntryPtr xTempEntry( new ZipEntry( xEntry ) );
+		xTempEntry->nExtraLen = -1;
+		xTempEntry->setName( rPath );
 
 		try
 		{
 			vos::ORef < EncryptionData > aEmptyEncr;
-			rZipOut.putNextEntry ( *pTempEntry, aEmptyEncr, sal_False );
+			rZipOut.putNextEntry ( xTempEntry, aEmptyEncr, sal_False );
 			rZipOut.rawCloseEntry();
 		}
 		catch ( ZipException& )
@@ -324,17 +305,12 @@ void ZipPackageFolder::saveContents(OUSt
 		}
 		else
 		{
-			// if pTempEntry is necessary, it will be released and passed to the ZipOutputStream
-			// and be deleted in the ZipOutputStream destructor 
-			auto_ptr < ZipEntry > pAutoTempEntry ( new ZipEntry );
-			ZipEntry* pTempEntry = pAutoTempEntry.get();
 
 			// In case the entry we are reading is also the entry we are writing, we will
-			// store the ZipEntry data in pTempEntry
+			// store the ZipEntry data in xTempEntry
+			ZipEntryPtr xTempEntry( new ZipEntry( pStream->xEntry ) );
 
-			ZipPackageFolder::copyZipEntry ( *pTempEntry, pStream->aEntry );
-			pTempEntry->sName = rPath + rShortName;
-			pTempEntry->nNameLen = (sal_Int16)( pTempEntry->sName.getLength() );
+			xTempEntry->setName( rPath + rShortName );
 
 			sal_Bool bToBeEncrypted = pStream->IsToBeEncrypted() && (bHaveEncryptionKey || pStream->HasOwnKey());
 			sal_Bool bToBeCompressed = bToBeEncrypted ? sal_True : pStream->IsToBeCompressed();
@@ -342,7 +318,7 @@ void ZipPackageFolder::saveContents(OUSt
 			pValue[0].Name = sMediaTypeProperty;
 			pValue[0].Value <<= pStream->GetMediaType( );
 			pValue[1].Name = sFullPathProperty;
-			pValue[1].Value <<= pTempEntry->sName;
+			pValue[1].Value <<= xTempEntry->getName();
 
 
 			OSL_ENSURE( pStream->GetStreamMode() != PACKAGE_STREAM_NOTSET, "Unacceptable ZipPackageStream mode!" );
@@ -395,15 +371,15 @@ void ZipPackageFolder::saveContents(OUSt
 							// The raw stream can neither be encrypted nor connected
 							OSL_ENSURE( !bRawStream || !bToBeCompressed && !bToBeEncrypted, "The stream is already encrypted!\n" );
 							xSeek->seek ( bRawStream ? pStream->GetMagicalHackPos() : 0 );
-							ImplSetStoredData ( *pTempEntry, xStream );
+							ImplSetStoredData ( xTempEntry, xStream );
 	
 							// TODO/LATER: Get rid of hacks related to switching of Flag Method and Size properties!
 						}
 						else if ( bToBeEncrypted )
 						{
 							// this is the correct original size
-							pTempEntry->nSize = static_cast < sal_Int32 > ( xSeek->getLength() );
-							nOwnStreamOrigSize = pTempEntry->nSize;
+							xTempEntry->nSize = static_cast < sal_Int32 > ( xSeek->getLength() );
+							nOwnStreamOrigSize = xTempEntry->nSize;
 						}
 		
 						xSeek->seek ( 0 );
@@ -421,12 +397,12 @@ void ZipPackageFolder::saveContents(OUSt
     						{
     							// Should be handled close to the raw stream handling
     							bTransportOwnEncrStreamAsRaw = sal_True;
-    							pTempEntry->nMethod = STORED;
+    							xTempEntry->nMethod = STORED;
 	
 								// TODO/LATER: get rid of this situation
 								// this size should be different from the one that will be stored in manifest.xml
 								// it is used in storing algorithms and after storing the correct size will be set
-    							pTempEntry->nSize = pTempEntry->nCompressedSize;
+    							xTempEntry->nSize = xTempEntry->nCompressedSize;
 	    					}
     					}
     					else
@@ -497,8 +473,8 @@ void ZipPackageFolder::saveContents(OUSt
 			if ( !bUseNonSeekableAccess &&
 				( bRawStream || bTransportOwnEncrStreamAsRaw ||
 					( pStream->IsPackageMember() 		  && !bToBeEncrypted && 
-						( pStream->aEntry.nMethod == DEFLATED &&  bToBeCompressed ) ||
-						( pStream->aEntry.nMethod == STORED   && !bToBeCompressed ) ) ) )
+						( pStream->xEntry->nMethod == DEFLATED &&  bToBeCompressed ) ||
+						( pStream->xEntry->nMethod == STORED   && !bToBeCompressed ) ) ) )
 			{
 				// If it's a PackageMember, then it's an unbuffered stream and we need
 				// to get a new version of it as we can't seek backwards.
@@ -518,9 +494,7 @@ void ZipPackageFolder::saveContents(OUSt
 					if ( bRawStream )
 						xStream->skipBytes( pStream->GetMagicalHackPos() );
 
-					rZipOut.putNextEntry ( *pTempEntry, pStream->getEncryptionData(), sal_False );
-					// the entry is provided to the ZipOutputStream that will delete it
-					pAutoTempEntry.release();
+					rZipOut.putNextEntry ( xTempEntry, pStream->getEncryptionData(), sal_False );
 
 					Sequence < sal_Int8 > aSeq ( n_ConstBufferSize );
 					sal_Int32 nLength;
@@ -570,15 +544,13 @@ void ZipPackageFolder::saveContents(OUSt
 
 				if ( bToBeCompressed )
 				{
-					pTempEntry->nMethod = DEFLATED;
-					pTempEntry->nCrc = pTempEntry->nCompressedSize = pTempEntry->nSize = -1;
+					xTempEntry->nMethod = DEFLATED;
+					xTempEntry->nCrc = xTempEntry->nCompressedSize = xTempEntry->nSize = -1;
 				}
 
 				try
 				{
-					rZipOut.putNextEntry ( *pTempEntry, pStream->getEncryptionData(), bToBeEncrypted);
-					// the entry is provided to the ZipOutputStream that will delete it
-					pAutoTempEntry.release();
+					rZipOut.putNextEntry ( xTempEntry, pStream->getEncryptionData(), bToBeEncrypted);
 
 					sal_Int32 nLength;
 					Sequence < sal_Int8 > aSeq (n_ConstBufferSize);
@@ -626,21 +598,21 @@ void ZipPackageFolder::saveContents(OUSt
 				}
 	
 				// Remove hacky bit from entry flags
-				if ( pTempEntry->nFlag & ( 1 << 4 ) )
+				if ( xTempEntry->nFlag & ( 1 << 4 ) )
 				{
-					pTempEntry->nFlag &= ~( 1 << 4 );
-					pTempEntry->nMethod = STORED;
+					xTempEntry->nFlag &= ~( 1 << 4 );
+					xTempEntry->nMethod = STORED;
 				}
 
 				// Then copy it back afterwards...
-				ZipPackageFolder::copyZipEntry ( pStream->aEntry, *pTempEntry );
+				pStream->xEntry = xTempEntry;
 
 				// TODO/LATER: get rid of this hack ( the encrypted stream size property is changed during saving )
 				if ( pStream->IsEncrypted() )
 					pStream->setSize( nOwnStreamOrigSize );
 
-				pStream->aEntry.sName = rShortName;
-				pStream->aEntry.nOffset *= -1;
+				pStream->xEntry->setName( rShortName );
+				pStream->xEntry->nOffset *= -1;
 			}
 		}
 		rManList.push_back (aPropSet);
@@ -699,7 +671,7 @@ void SAL_CALL ZipPackageFolder::setPrope
 		aValue >>= sMediaType;
 	}
 	else if (aPropertyName.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM("Size") ) )
-		aValue >>= aEntry.nSize;
+		aValue >>= xEntry->nSize;
 	else
 		throw UnknownPropertyException();
 }
@@ -709,7 +681,7 @@ Any SAL_CALL ZipPackageFolder::getProper
 	if (PropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM( "MediaType" ) ) )
 		return makeAny ( sMediaType );
 	else if (PropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM ( "Size" ) ) )
-		return makeAny ( aEntry.nSize );
+		return makeAny ( xEntry->nSize );
 	else
 		throw UnknownPropertyException();
 }
@@ -718,9 +690,9 @@ void ZipPackageFolder::doInsertByName ( 
 		throw(IllegalArgumentException, ElementExistException, WrappedTargetException, RuntimeException)
 {
 	if ( pEntry->IsFolder() )
-		maContents[pEntry->aEntry.sName] = new ContentInfo ( static_cast < ZipPackageFolder *> ( pEntry ) );
+		maContents[pEntry->xEntry->getName()] = new ContentInfo ( static_cast < ZipPackageFolder *> ( pEntry ) );
 	else
-		maContents[pEntry->aEntry.sName] = new ContentInfo ( static_cast < ZipPackageStream *> ( pEntry ) );
+		maContents[pEntry->xEntry->getName()] = new ContentInfo ( static_cast < ZipPackageStream *> ( pEntry ) );
 
 	if ( bSetParent )
 		pEntry->setParent ( *this );
Index: package/source/zippackage/ZipPackageStream.cxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ZipPackageStream.cxx,v
retrieving revision 1.46
diff -u -p -u -r1.46 ZipPackageStream.cxx
--- package/source/zippackage/ZipPackageStream.cxx	1 Feb 2006 19:15:02 -0000	1.46
+++ package/source/zippackage/ZipPackageStream.cxx	25 Jul 2006 15:50:29 -0000
@@ -114,16 +114,16 @@ ZipPackageStream::ZipPackageStream ( Zip
 	this->mbAllowRemoveOnInsert = bAllowRemoveOnInsert;
 
 	SetFolder ( sal_False );
-	aEntry.nVersion		= -1;
-	aEntry.nFlag		= 0;
-	aEntry.nMethod		= -1;
-	aEntry.nTime		= -1;
-	aEntry.nCrc			= -1;
-	aEntry.nCompressedSize	= -1;
-	aEntry.nSize		= -1;
-	aEntry.nOffset		= -1;
-	aEntry.nNameLen		= -1;
-	aEntry.nExtraLen	= -1;
+#warning FIXME: we need a nice set_uninitialized method or something ...
+	xEntry->nVersion		= -1;
+	xEntry->nFlag		= 0;
+	xEntry->nMethod		= -1;
+	xEntry->nTime		= -1;
+	xEntry->nCrc			= -1;
+	xEntry->nCompressedSize	= -1;
+	xEntry->nSize		= -1;
+	xEntry->nOffset		= -1;
+	xEntry->nExtraLen	= -1;
 
 	if ( !aImplementationId.getLength() )
         {
@@ -135,19 +135,9 @@ ZipPackageStream::~ZipPackageStream( voi
 {
 }
 
-void ZipPackageStream::setZipEntry( const ZipEntry &rInEntry)
+void ZipPackageStream::setZipEntry( const ZipEntryPtr &xInEntry)
 {
-	aEntry.nVersion = rInEntry.nVersion;
-	aEntry.nFlag = rInEntry.nFlag;
-	aEntry.nMethod = rInEntry.nMethod;
-	aEntry.nTime = rInEntry.nTime;
-	aEntry.nCrc = rInEntry.nCrc;
-	aEntry.nCompressedSize = rInEntry.nCompressedSize;
-	aEntry.nSize = rInEntry.nSize;
-	aEntry.nOffset = rInEntry.nOffset;
-	aEntry.sName = rInEntry.sName;
-	aEntry.nNameLen = rInEntry.nNameLen;
-	aEntry.nExtraLen = rInEntry.nExtraLen;
+	xEntry = xInEntry;
 }
 
 //--------------------------------------------------------------------------
@@ -420,7 +410,7 @@ void SAL_CALL ZipPackageStream::setInput
 	xStream = aStream;
 	m_bHasSeekable = sal_False;
 	SetPackageMember ( sal_False );
-	aEntry.nTime = -1;
+	xEntry->nTime = -1;
 	m_nStreamMode = PACKAGE_STREAM_DETECT;
 }
 
@@ -434,7 +424,7 @@ Reference< io::XInputStream > SAL_CALL Z
 		{
 			if ( !xEncryptionData.isEmpty() && !bHaveOwnKey )
 				xEncryptionData->aKey = rZipPackage.getEncryptionKey();
-			return rZipPackage.getZipFile().getRawData( aEntry, xEncryptionData, bIsEncrypted );
+			return rZipPackage.getZipFile().getRawData( xEntry, xEncryptionData, bIsEncrypted );
 		}
 		else if ( GetOwnSeekStream().is() )
 		{
@@ -467,7 +457,7 @@ Reference< io::XInputStream > SAL_CALL Z
 		{
 			if ( !xEncryptionData.isEmpty() && !bHaveOwnKey )
 				xEncryptionData->aKey = rZipPackage.getEncryptionKey();
-			return rZipPackage.getZipFile().getInputStream( aEntry, xEncryptionData, bIsEncrypted );
+			return rZipPackage.getZipFile().getInputStream( xEntry, xEncryptionData, bIsEncrypted );
 		}
 		else if ( GetOwnSeekStream().is() )
 		{
@@ -513,7 +503,7 @@ Reference< io::XInputStream > SAL_CALL Z
 		if ( !xEncryptionData.isEmpty() && !bHaveOwnKey )
 			xEncryptionData->aKey = rZipPackage.getEncryptionKey();
 
-		return rZipPackage.getZipFile().getDataStream( aEntry, xEncryptionData, bIsEncrypted );
+		return rZipPackage.getZipFile().getDataStream( xEntry, xEncryptionData, bIsEncrypted );
 	}
 	else if ( m_nStreamMode == PACKAGE_STREAM_RAW )
 		return ZipFile::StaticGetDataFromRawStream( GetOwnSeekStream(), xEncryptionData );
@@ -546,7 +536,7 @@ Reference< io::XInputStream > SAL_CALL Z
 		if ( !bIsEncrypted || xEncryptionData.isEmpty() )
 			throw packages::NoEncryptionException(); // TODO
 
-		return rZipPackage.getZipFile().getWrappedRawStream( aEntry, xEncryptionData, sMediaType );
+		return rZipPackage.getZipFile().getWrappedRawStream( xEntry, xEncryptionData, sMediaType );
 	}
 	else if ( GetOwnSeekStream().is() )
 	{
@@ -601,7 +591,7 @@ void SAL_CALL ZipPackageStream::setRawSt
 	
 	m_aSharedMutexRef = new SotMutexHolder();
 	SetPackageMember ( sal_False );
-	aEntry.nTime = -1;
+	xEntry->nTime = -1;
 	m_nStreamMode = PACKAGE_STREAM_RAW;
 }
 
@@ -620,7 +610,7 @@ uno::Reference< io::XInputStream > SAL_C
 
 	if (IsPackageMember())
 	{
-		return rZipPackage.getZipFile().getRawData( aEntry, xEncryptionData, bIsEncrypted );
+		return rZipPackage.getZipFile().getRawData( xEntry, xEncryptionData, bIsEncrypted );
 	}
 	else if ( GetOwnSeekStream().is() )
 	{
@@ -678,7 +668,7 @@ void SAL_CALL ZipPackageStream::setPrope
 	}
 	else if (aPropertyName.equalsAsciiL(RTL_CONSTASCII_STRINGPARAM("Size") ) )
 	{
-		if ( !( aValue >>= aEntry.nSize ) )
+		if ( !( aValue >>= xEntry->nSize ) )
 			throw IllegalArgumentException( OUString::createFromAscii( "Wrong type for Size property!\n" ),
 											Reference< XInterface >(),
 											2 );
@@ -786,7 +776,7 @@ Any SAL_CALL ZipPackageStream::getProper
 	}
 	else if (PropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM ( "Size" ) ) )
 	{
-		aAny <<= aEntry.nSize;
+		aAny <<= xEntry->nSize;
 		return aAny;
 	}
 	else if (PropertyName.equalsAsciiL( RTL_CONSTASCII_STRINGPARAM ( "Encrypted" ) ) )
@@ -816,9 +806,9 @@ Any SAL_CALL ZipPackageStream::getProper
 //--------------------------------------------------------------------------
 void ZipPackageStream::setSize (const sal_Int32 nNewSize)
 { 
-	if (aEntry.nCompressedSize != nNewSize )
-		aEntry.nMethod = DEFLATED;
-	aEntry.nSize = nNewSize;
+	if (xEntry->nCompressedSize != nNewSize )
+		xEntry->nMethod = DEFLATED;
+	xEntry->nSize = nNewSize;
 }
 //--------------------------------------------------------------------------
 OUString ZipPackageStream::getImplementationName()
Index: package/source/zippackage/ZipPackageStream.hxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/ZipPackageStream.hxx,v
retrieving revision 1.21
diff -u -p -u -r1.21 ZipPackageStream.hxx
--- package/source/zippackage/ZipPackageStream.hxx	19 Oct 2005 12:50:01 -0000	1.21
+++ package/source/zippackage/ZipPackageStream.hxx	25 Jul 2006 15:50:29 -0000
@@ -115,7 +115,7 @@ public:
 	const sal_Int32 getIterationCount ()
 	{ return xEncryptionData->nIterationCount;}
 	const sal_Int32 getSize ()
-	{ return aEntry.nSize;}
+	{ return xEntry->nSize;}
 
 	sal_uInt8 GetStreamMode() { return m_nStreamMode; }
 	sal_uInt32 GetMagicalHackPos() { return m_nMagicalHackPos; }
@@ -159,7 +159,7 @@ public:
 
 	sal_Bool ParsePackageRawStream();
 
-	void setZipEntry( const ZipEntry &rInEntry);
+	void setZipEntry( const ZipEntryPtr &xInEntry);
     ::com::sun::star::uno::Reference< ::com::sun::star::io::XInputStream > SAL_CALL getRawData()
 		throw(::com::sun::star::uno::RuntimeException);
 	
Index: package/source/zippackage/zipfileaccess.cxx
===================================================================
RCS file: /cvs/xml/package/source/zippackage/zipfileaccess.cxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 zipfileaccess.cxx
--- package/source/zippackage/zipfileaccess.cxx	1 Feb 2006 19:15:18 -0000	1.5
+++ package/source/zippackage/zipfileaccess.cxx	25 Jul 2006 15:50:30 -0000
@@ -53,7 +53,6 @@
 #endif
 
 #include <zipfileaccess.hxx>
-#include <ZipEnumeration.hxx>
 #include <ZipPackageSink.hxx>
 #include <EncryptionData.hxx>
 
@@ -66,10 +65,11 @@ using namespace ::com::sun::star;
 
 // ----------------------------------------------------------------
 OZipFileAccess::OZipFileAccess( const uno::Reference< lang::XMultiServiceFactory >& xFactory )
-: m_xFactory( xFactory )
-, m_pZipFile( NULL )
-, m_pListenersContainer( NULL )
-, m_bDisposed( sal_False )
+    : m_xFactory( xFactory )
+    , m_pZipFile( NULL )
+    , m_pListenersContainer( NULL )
+    , m_bDisposed( sal_False )
+    , m_aEntries( 10, ENTRY_HASH_ARGS( m_aEntries ) )
 {
 	if ( !xFactory.is() )
 		throw uno::RuntimeException();
@@ -95,15 +95,9 @@ OZipFileAccess::~OZipFileAccess()
 EntryHash& OZipFileAccess::GetEntryHash_Impl()
 {
 	OSL_ENSURE( m_pZipFile, "ZipFile must be set already!\n" );
+
 	if ( !m_aEntries.size() && m_pZipFile )
-	{
-		::std::auto_ptr< ZipEnumeration > pZipEnum( m_pZipFile->entries() );
-		while( pZipEnum->hasMoreElements() )
-		{
-			const ZipEntry* pZipEntry = pZipEnum->nextElement();
-			m_aEntries[pZipEntry->sName] = *pZipEntry;
-		}
-	}
+		m_pZipFile->copyEntries( m_aEntries );
 
 	return m_aEntries;
 }
@@ -282,13 +276,15 @@ uno::Any SAL_CALL OZipFileAccess::getByN
 		throw io::NotConnectedException();
 
 	GetEntryHash_Impl();
-	EntryHash::iterator aIter = m_aEntries.find( aName );
+	rtl::OString aLookup = rtl::OUStringToOString( aName, RTL_TEXTENCODING_ASCII_US );
+	EntryHash::iterator aIter = m_aEntries.find( aLookup );
 	if ( aIter == m_aEntries.end() )
 		throw container::NoSuchElementException();
 
-	uno::Reference< io::XInputStream > xEntryStream( m_pZipFile->getDataStream( (*aIter).second,
-                                                                                new EncryptionData(),
-                                                                                sal_False ) );
+	uno::Reference< io::XInputStream > xEntryStream
+		( m_pZipFile->getDataStream( *aIter,
+					     new EncryptionData(),
+					     sal_False ) );
 
 	if ( !xEntryStream.is() )
 		throw uno::RuntimeException(); // TODO:
@@ -316,7 +312,7 @@ uno::Sequence< ::rtl::OUString > SAL_CAL
 	for ( EntryHash::iterator aIter = m_aEntries.begin(); aIter != m_aEntries.end(); aIter++ )
 	{
 		aNames.realloc( ++nLen );
-		aNames[nLen-1] = (*aIter).second.sName;
+		aNames[nLen-1] = (*aIter)->getName();
 	}
 
 	return aNames;
@@ -335,7 +331,8 @@ sal_Bool SAL_CALL OZipFileAccess::hasByN
 		throw io::NotConnectedException();
 
 	GetEntryHash_Impl();
-	EntryHash::iterator aIter = m_aEntries.find( aName );
+	rtl::OString aLookup = rtl::OUStringToOString( aName, RTL_TEXTENCODING_ASCII_US );
+	EntryHash::iterator aIter = m_aEntries.find( aLookup );
 
 	return ( aIter != m_aEntries.end() );
 }
@@ -393,9 +390,9 @@ uno::Reference< io::XInputStream > SAL_C
 
 	for ( EntryHash::iterator aIter = m_aEntries.begin(); aIter != m_aEntries.end(); aIter++ )
 	{
-		if ( StringGoodForPattern_Impl( (*aIter).second.sName, aPattern ) )
+		if ( StringGoodForPattern_Impl( (*aIter)->getName(), aPattern ) )
 		{
-			uno::Reference< io::XInputStream > xEntryStream( m_pZipFile->getDataStream( (*aIter).second, 
+			uno::Reference< io::XInputStream > xEntryStream( m_pZipFile->getDataStream( *aIter, 
                                                                                         new EncryptionData(), 
                                                                                         sal_False ) );
 
