? sc/sc.vpj
? sc/sc_project.sca
Index: sc/inc/document.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/document.hxx,v
retrieving revision 1.105
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.105 document.hxx
--- sc/inc/document.hxx	7 Dec 2007 10:40:50 -0000	1.105
+++ sc/inc/document.hxx	22 Dec 2007 07:18:56 -0000
@@ -132,6 +132,7 @@
 class ScStyleSheet;
 class ScStyleSheetPool;
 class ScTable;
+class ScTableProtection;
 class ScTokenArray;
 class ScValidationData;
 class ScValidationDataList;
@@ -532,13 +533,18 @@
 	inline SCTAB	GetTableCount() const { return nMaxTableNumber; }
 	SvNumberFormatterIndexTable* GetFormatExchangeList() const { return pFormatExchangeList; }
 
-	void			SetDocProtection( BOOL bProtect, const com::sun::star::uno::Sequence <sal_Int8>& aPass );
-	void			SetTabProtection( SCTAB nTab, BOOL bProtect, const com::sun::star::uno::Sequence <sal_Int8>& aPass );
+	void			SetDocProtection(bool bProtect, const String& aPassText);
+	void			SetDocProtection(bool bProtect, const com::sun::star::uno::Sequence <sal_Int8>& aPass);
+//  void            SetTabProtection( SCTAB nTab, BOOL bProtect, const com::sun::star::uno::Sequence <sal_Int8>& aPass );
 	BOOL			IsDocProtected() const;
 	BOOL			IsDocEditable() const;
 	BOOL			IsTabProtected( SCTAB nTab ) const;
+    ScTableProtection* GetTabProtection( SCTAB nTab ) const;
+    void            SetTabProtection(SCTAB nTab, bool bProtect, const String& aPassText);
+    void            SetTabProtection(SCTAB nTab, const ScTableProtection* pProtect);
+    void            CopyTabProtection(SCTAB nTabSrc, SCTAB nTabDest);
+
 	const com::sun::star::uno::Sequence <sal_Int8>&	GetDocPassword() const;
-	const com::sun::star::uno::Sequence <sal_Int8>&	GetTabPassword( SCTAB nTab ) const;
 
 	void			LockTable(SCTAB nTab);
 	void			UnlockTable(SCTAB nTab);
Index: sc/inc/table.hxx
===================================================================
RCS file: /cvs/sc/sc/inc/table.hxx,v
retrieving revision 1.32
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.32 table.hxx
--- sc/inc/table.hxx	21 Sep 2007 09:22:40 -0000	1.32
+++ sc/inc/table.hxx	22 Dec 2007 07:18:56 -0000
@@ -58,6 +58,8 @@
 #include "compressedarray.hxx"
 #endif
 
+#include <memory>
+
 namespace utl {
 	class SearchParam;
 	class TextSearch;
@@ -84,6 +86,7 @@
 class ScSortInfoArray;
 class ScStyleSheet;
 class ScTableLink;
+class ScTableProtection;
 class ScUserListData;
 class ScIndexMap;
 struct RowInfo;
@@ -121,8 +124,7 @@
 	SCROW			nRepeatStartY;
 	SCROW			nRepeatEndY;
 
-	BOOL			bProtected;
-	com::sun::star::uno::Sequence<sal_Int8>	aProtectPass;
+    ::std::auto_ptr<ScTableProtection> pTabProtection;
 
 	USHORT*			pColWidth;
 	ScSummableCompressedArray< SCROW, USHORT>*  pRowHeight;
@@ -237,10 +239,12 @@
 	void			SetPageStyle( const String& rName );
 	void			PageStyleModified( const String& rNewName );
 
-	BOOL			IsProtected() const						{ return bProtected; }
-	const com::sun::star::uno::Sequence<sal_Int8>&	GetPassword() const						{ return aProtectPass; }
-	void			SetProtection( BOOL bProtect, const com::sun::star::uno::Sequence<sal_Int8>& rPasswd )
-										{ bProtected = bProtect; aProtectPass = rPasswd; }
+    BOOL            IsProtected() const;
+    com::sun::star::uno::Sequence<sal_Int8> GetPassword() const;
+    void            SetProtection(BOOL bProtect, const com::sun::star::uno::Sequence<sal_Int8>& rPasswd);
+    void            SetProtection(bool bProtect, const String& aPassText);
+    void            SetProtection(const ScTableProtection* pProtect);
+    ScTableProtection* GetProtection();
 
 	Size			GetPageSize() const;
 	void			SetPageSize( const Size& rSize );
Index: sc/inc/tabprotection.hxx
===================================================================
RCS file: sc/inc/tabprotection.hxx
diff -N sc/inc/tabprotection.hxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/inc/tabprotection.hxx	22 Dec 2007 07:18:56 -0000
@@ -0,0 +1,103 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: tabprotection.hxx,v $
+ *
+ *  $Revision: 1.1.2.1 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/09/05 04:12:54 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#ifndef SC_TAB_PROTECTION_HXX
+#define SC_TAB_PROTECTION_HXX
+
+#include "sal/types.h"
+#include <com/sun/star/uno/Sequence.hxx>
+
+#include "global.hxx"
+#include <vector>
+
+
+class ScTableProtection
+{
+public:
+    enum Option
+    {
+        AUTOFILTER = 0,
+        DELETE_COLUMNS,
+        DELETE_ROWS,
+        FORMAT_CELLS,
+        FORMAT_COLUMNS,
+        FORMAT_ROWS,
+        INSERT_COLUMNS,
+        INSERT_HYPERLINKS,
+        INSERT_ROWS,
+        OBJECTS,
+        PIVOT_TABLES,
+        SCENARIOS,
+        SELECT_LOCKED_CELLS,
+        SELECT_UNLOCKED_CELLS,
+        SHEET,
+        SORT,
+        NONE        // last item - used to resize the vector;
+    };
+
+    enum PasswordHash
+    {
+        HASH_OOO = 0,
+        HASH_XL
+    };
+
+    static ::com::sun::star::uno::Sequence<sal_Int8> hashPassword(const String& aPassText, PasswordHash eHash = HASH_OOO);
+
+    explicit ScTableProtection();
+    explicit ScTableProtection(const ScTableProtection& r);
+
+    bool isProtected() const;
+    bool isProtectedWithPass() const;
+    void setProtected(bool bProtected);
+
+    const String getPassword() const;
+    void setPassword(const String& aPassText);
+    ::com::sun::star::uno::Sequence<sal_Int8> getPasswordHash(PasswordHash eHash) const;
+    void setPasswordHash(const ::com::sun::star::uno::Sequence<sal_Int8>& aPassword, PasswordHash eHash = HASH_OOO);
+    bool verifyPassword(const String& aPassText) const;
+    
+    bool isOptionEnabled(Option eOption) const;
+    void setOption(Option eOption, bool bEnabled);
+
+private:
+    String maPassText;
+    ::com::sun::star::uno::Sequence<sal_Int8>   maPassHash;
+    ::std::vector<bool> maOptions;
+    bool mbProtected;
+    PasswordHash meHash;
+};
+
+
+#endif
Index: sc/source/core/data/documen3.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/documen3.cxx,v
retrieving revision 1.38
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.38 documen3.cxx
--- sc/source/core/data/documen3.cxx	21 Sep 2007 09:22:54 -0000	1.38
+++ sc/source/core/data/documen3.cxx	22 Dec 2007 07:18:57 -0000
@@ -37,7 +37,7 @@
 #include "precompiled_sc.hxx"
 // System - Includes -----------------------------------------------------
 
-
+#include <stdio.h>
 
 #ifdef WIN
 // SFX
@@ -140,6 +140,7 @@
 #ifndef SC_EDITUTIL_HXX
 #include "editutil.hxx"    // ScPostIt EditTextObject
 #endif
+#include "svtools/PasswordHelper.hxx"
 
 using namespace com::sun::star;
 
@@ -1745,19 +1746,28 @@
         ScDrawLayer::MirrorRectRTL( rRect );        // back to real rectangle
 }
 
-void ScDocument::SetDocProtection( BOOL bProtect, const uno::Sequence<sal_Int8>& rPasswd )
+void ScDocument::SetDocProtection(bool bProtect, const String& aPassText)
 {
+    uno::Sequence<sal_Int8> aPass;
+    if (aPassText.Len())
+        SvPasswordHelper::GetHashPassword(aPass, aPassText);
 	bProtected = bProtect;
-	aProtectPass = rPasswd;
+	aProtectPass = aPass;
 }
 
-void ScDocument::SetTabProtection( SCTAB nTab, BOOL bProtect, const uno::Sequence<sal_Int8>& rPasswd )
+void ScDocument::SetDocProtection(bool bProtect, const uno::Sequence<sal_Int8>& aPass)
 {
-	if (VALIDTAB(nTab))
-		if (pTab[nTab])
-			pTab[nTab]->SetProtection( bProtect, rPasswd );
+	bProtected = bProtect;
+	aProtectPass = aPass;
 }
 
+//void ScDocument::SetTabProtection( SCTAB nTab, BOOL bProtect, const uno::Sequence<sal_Int8>& rPasswd )
+//{
+//    if (VALIDTAB(nTab))
+//        if (pTab[nTab])
+//            pTab[nTab]->SetProtection( bProtect, rPasswd );
+//}
+
 BOOL ScDocument::IsDocProtected() const
 {
 	return bProtected;
@@ -1780,18 +1790,38 @@
 	return FALSE;
 }
 
-const uno::Sequence<sal_Int8>& ScDocument::GetDocPassword() const
+ScTableProtection* ScDocument::GetTabProtection( SCTAB nTab ) const
 {
-	return aProtectPass;
+    if (VALIDTAB(nTab) && pTab[nTab])
+        return pTab[nTab]->GetProtection();
+
+    return NULL;
 }
 
-const uno::Sequence<sal_Int8>& ScDocument::GetTabPassword( SCTAB nTab ) const
+void ScDocument::SetTabProtection(SCTAB nTab, bool bProtect, const String& aPassText)
 {
-	if (VALIDTAB(nTab))
-		if (pTab[nTab])
-			return pTab[nTab]->GetPassword();
+    if (ValidTab(nTab) && pTab[nTab])
+        pTab[nTab]->SetProtection(bProtect, aPassText);
+}
 
-	DBG_ERROR("Falsche Tabellennummer");
+void ScDocument::SetTabProtection(SCTAB nTab, const ScTableProtection* pProtect)
+{
+    if (!ValidTab(nTab))
+        return;
+
+    pTab[nTab]->SetProtection(pProtect);
+}
+
+void ScDocument::CopyTabProtection(SCTAB nTabSrc, SCTAB nTabDest)
+{
+    if (!ValidTab(nTabSrc) || !ValidTab(nTabDest))
+        return;
+
+    pTab[nTabDest]->SetProtection( pTab[nTabSrc]->GetProtection() );
+}
+
+const uno::Sequence<sal_Int8>& ScDocument::GetDocPassword() const
+{
 	return aProtectPass;
 }
 
Index: sc/source/core/data/makefile.mk
===================================================================
RCS file: /cvs/sc/sc/source/core/data/makefile.mk,v
retrieving revision 1.21
retrieving revision 1.21.166.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 -r1.21.166.1
--- sc/source/core/data/makefile.mk	27 Feb 2007 12:06:42 -0000	1.21
+++ sc/source/core/data/makefile.mk	5 Sep 2007 04:12:54 -0000	1.21.166.1
@@ -111,6 +111,7 @@
 	$(SLO)$/table4.obj \
 	$(SLO)$/table5.obj \
 	$(SLO)$/table6.obj \
+	$(SLO)$/tabprotection.obj \
 	$(SLO)$/userdat.obj \
 	$(SLO)$/validat.obj \
 	$(SLO)$/postit.obj
Index: sc/source/core/data/table1.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/table1.cxx,v
retrieving revision 1.20
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.20 table1.cxx
--- sc/source/core/data/table1.cxx	27 Feb 2007 12:09:14 -0000	1.20
+++ sc/source/core/data/table1.cxx	22 Dec 2007 07:18:57 -0000
@@ -119,6 +119,7 @@
 #include "progress.hxx"
 #include "hints.hxx"		// fuer Paint-Broadcast
 #include "prnsave.hxx"
+#include "tabprotection.hxx"
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -137,7 +138,7 @@
 	bPageSizeValid( FALSE ),
 	nRepeatStartX( SCCOL_REPEAT_NONE ),
 	nRepeatStartY( SCROW_REPEAT_NONE ),
-	bProtected( FALSE ),
+    pTabProtection( new ScTableProtection ),
 	pColWidth( NULL ),
 	pRowHeight( NULL ),
 	pColFlags( NULL ),
Index: sc/source/core/data/table2.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/table2.cxx,v
retrieving revision 1.38
retrieving revision 1.37.164.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.38 -r1.37.164.2
--- sc/source/core/data/table2.cxx	27 Sep 2007 13:53:05 -0000	1.38
+++ sc/source/core/data/table2.cxx	7 Dec 2007 01:17:32 -0000	1.37.164.2
@@ -304,7 +304,7 @@
 			// Zellschutz auf geschuetzter Tabelle nicht setzen
 			//
 
-		if ( bProtected && (nDelFlag & IDF_ATTRIB) )
+		if ( IsProtected() && (nDelFlag & IDF_ATTRIB) )
 		{
 			ScPatternAttr aPattern(pDocument->GetPool());
 			aPattern.GetItemSet().Put( ScProtectionAttr( FALSE ) );
@@ -330,7 +330,7 @@
 		// Zellschutz auf geschuetzter Tabelle nicht setzen
 		//
 
-	if ( bProtected && (nDelFlag & IDF_ATTRIB) )
+	if ( IsProtected() && (nDelFlag & IDF_ATTRIB) )
 	{
 		ScDocumentPool* pPool = pDocument->GetPool();
 		SfxItemSet aSet( *pPool, ATTR_PATTERN_START, ATTR_PATTERN_END );
@@ -373,7 +373,7 @@
 
 		//	ggf. Formeln durch Werte ersetzen
 
-		if (bProtected)
+		if ( IsProtected() )
 			for (i = nCol1; i <= nCol2; i++)
 				pTable->aCol[i].RemoveProtected(nRow1, nRow2);
 	}
@@ -418,7 +418,7 @@
 				// Zellschutz auf geschuetzter Tabelle nicht setzen
 				//
 
-			if ( bProtected && (nInsFlag & IDF_ATTRIB) )
+			if ( IsProtected() && (nInsFlag & IDF_ATTRIB) )
 			{
 				ScPatternAttr aPattern(pDocument->GetPool());
 				aPattern.GetItemSet().Put( ScProtectionAttr( FALSE ) );
@@ -1448,7 +1448,7 @@
 	BOOL bIsEditable = TRUE;
 	if ( nLockCount )
 		bIsEditable = FALSE;
-    else if ( bProtected && !pDocument->IsScenario(nTab) )
+    else if ( IsProtected() && !pDocument->IsScenario(nTab) )
     {
         if((bIsEditable = !HasAttrib( nCol1, nRow1, nCol2, nRow2, HASATTR_PROTECTED )) != FALSE)
         {
@@ -1515,7 +1515,7 @@
 	BOOL bIsEditable = TRUE;
 	if ( nLockCount )
 		bIsEditable = FALSE;
-    else if ( bProtected && !pDocument->IsScenario(nTab))
+    else if ( IsProtected() && !pDocument->IsScenario(nTab) )
     {
         if((bIsEditable = !HasAttribSelection( rMark, HASATTR_PROTECTED )) != FALSE)
         {
@@ -2797,11 +2797,16 @@
 					rStream >> bScenario;
 					rStream.ReadByteString( aComment, rStream.GetStreamCharSet() );
 
+                    BOOL bProtected;
 					rStream >> bProtected;
 					String aPass;
 					rStream.ReadByteString( aPass, rStream.GetStreamCharSet() );
 					if (aPass.Len())
+                    {
+                        ::com::sun::star::uno::Sequence<sal_Int8> aProtectPass;
 						SvPasswordHelper::GetHashPassword(aProtectPass, aPass);
+                        SetProtection(bProtected, aProtectPass);
+                    }
 
 					BOOL bOutline;
 					rStream >> bOutline;
@@ -3073,6 +3078,7 @@
 		rStream << bScenario;
 		rStream.WriteByteString( aComment, rStream.GetStreamCharSet() );
 
+        BOOL bProtected = IsProtected();
 		rStream << bProtected;
 		String aPass;
 		//rStream.WriteByteString( aProtectPass, rStream.GetStreamCharSet() );
Index: sc/source/core/data/table5.cxx
===================================================================
RCS file: /cvs/sc/sc/source/core/data/table5.cxx,v
retrieving revision 1.13
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.13 table5.cxx
--- sc/source/core/data/table5.cxx	27 Feb 2007 12:10:06 -0000	1.13
+++ sc/source/core/data/table5.cxx	22 Dec 2007 07:18:57 -0000
@@ -56,8 +56,11 @@
 #include "stlpool.hxx"
 #include "stlsheet.hxx"
 #include "brdcst.hxx"
+#include "tabprotection.hxx"
 #include "globstr.hrc"
 
+using ::com::sun::star::uno::Sequence;
+
 // STATIC DATA -----------------------------------------------------------
 
 #define GET_SCALEVALUE(set,id) 	((const SfxUInt16Item&)(set.Get( id ))).GetValue()
@@ -278,6 +281,49 @@
 		bPageSizeValid = FALSE;
 }
 
+BOOL ScTable::IsProtected() const
+{
+    return pTabProtection.get() && pTabProtection->isProtected();
+}
+
+Sequence<sal_Int8> ScTable::GetPassword() const
+{
+    if (!pTabProtection.get())
+    {
+        Sequence<sal_Int8> aEmpty;
+        return aEmpty;
+    }
+    return pTabProtection->getPasswordHash(ScTableProtection::HASH_OOO);
+}
+
+void ScTable::SetProtection(BOOL bProtect, const com::sun::star::uno::Sequence<sal_Int8>& rPasswd)
+{
+    pTabProtection->setProtected( bProtect );
+    pTabProtection->setPasswordHash(rPasswd, ScTableProtection::HASH_OOO);
+}
+
+void ScTable::SetProtection(bool bProtect, const String& aPassText)
+{
+    pTabProtection->setProtected( bProtect );
+    pTabProtection->setPassword(aPassText);
+}
+
+void ScTable::SetProtection(const ScTableProtection* pProtect)
+{
+    if (pProtect)
+        pTabProtection.reset(new ScTableProtection(*pProtect));
+    else
+        pTabProtection.reset(new ScTableProtection);
+}
+
+ScTableProtection* ScTable::GetProtection()
+{
+    if (!pTabProtection.get())
+        pTabProtection.reset(new ScTableProtection);
+
+    return pTabProtection.get();
+}
+
 Size ScTable::GetPageSize() const
 {
 	if ( bPageSizeValid )
Index: sc/source/core/data/tabprotection.cxx
===================================================================
RCS file: sc/source/core/data/tabprotection.cxx
diff -N sc/source/core/data/tabprotection.cxx
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ sc/source/core/data/tabprotection.cxx	22 Dec 2007 07:18:57 -0000
@@ -0,0 +1,196 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: tabprotection.cxx,v $
+ *
+ *  $Revision: 1.1.2.1 $
+ *
+ *  last change: $Author: kohei $ $Date: 2007/09/05 04:12:55 $
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+
+#include "tabprotection.hxx"
+#include "tools/debug.hxx"
+#include "svtools/PasswordHelper.hxx"
+
+using namespace ::com::sun::star;
+using ::com::sun::star::uno::Sequence;
+using ::rtl::OUString;
+
+static sal_uInt16 lcl_getXLHashFromChar(const sal_Char* szPassword)
+{
+    sal_uInt16 cchPassword = strlen(szPassword);
+    sal_uInt16 wPasswordHash = 0;
+    if (!cchPassword)
+        return wPasswordHash;
+
+    const char* pch = &szPassword[cchPassword];
+    while (pch-- != szPassword)
+    {
+        wPasswordHash = ((wPasswordHash >> 14) & 0x01) | 
+                        ((wPasswordHash << 1) & 0x7fff);
+        wPasswordHash ^= *pch;
+    }
+
+    wPasswordHash = ((wPasswordHash >> 14) & 0x01) | 
+                    ((wPasswordHash << 1) & 0x7fff);
+    wPasswordHash ^= *pch;
+
+    wPasswordHash ^= (0x8000 | ('N' << 8) | 'K');
+    wPasswordHash ^= cchPassword;
+
+    return wPasswordHash;
+}
+
+static Sequence<sal_Int8> lcl_getXLHash(const String& aPassText)
+{
+    const sal_Char* szBuf = OUStringToOString(OUString(aPassText), RTL_TEXTENCODING_UTF8).getStr();
+    sal_uInt16 nHash = lcl_getXLHashFromChar(szBuf);
+    Sequence<sal_Int8> aHash(2);
+    aHash[0] = (nHash >> 8) & 0xFF;
+    aHash[1] = nHash & 0xFF;
+    return aHash;
+}
+
+Sequence<sal_Int8> ScTableProtection::hashPassword(const String& aPassText, PasswordHash eHash)
+{
+    Sequence<sal_Int8> aHash;
+    switch (eHash)
+    {
+        case HASH_XL:
+            aHash = lcl_getXLHash(aPassText);
+        break;
+        case HASH_OOO:
+        default:            
+            SvPasswordHelper::GetHashPassword(aHash, aPassText);
+        break;
+    }
+    return aHash;
+}
+
+ScTableProtection::ScTableProtection() :
+    maOptions(NONE),
+    mbProtected(false),
+    meHash(HASH_OOO)
+{
+    // Set default values for the options.
+    maOptions[SELECT_LOCKED_CELLS]   = true;
+    maOptions[SELECT_UNLOCKED_CELLS] = true;
+}
+
+ScTableProtection::ScTableProtection(const ScTableProtection& r) :
+    maPassText(r.maPassText),
+    maPassHash(r.maPassHash),
+    maOptions(r.maOptions),
+    mbProtected(r.mbProtected),
+    meHash(r.meHash)
+{
+}
+
+bool ScTableProtection::isProtected() const
+{
+    return mbProtected;
+}
+
+bool ScTableProtection::isProtectedWithPass() const
+{
+    if (!mbProtected)
+        return false;
+
+    return maPassText.Len() || maPassHash.getLength();
+}
+
+void ScTableProtection::setProtected(bool bProtected)
+{
+    mbProtected = bProtected;
+}
+
+const String ScTableProtection::getPassword() const
+{
+    return maPassText;
+}
+
+void ScTableProtection::setPassword(const String& aPassText)
+{
+    fprintf(stdout, "ScTableProtection::setPassword: --begin\n");fflush(stdout);
+    // TODO: We can't hash it here because we don't know whether this document
+    // will get saved to Excel or ODF, depending on which we will need to use
+    // a different hashing algorithm.
+    maPassText = aPassText;
+}
+
+uno::Sequence<sal_Int8> ScTableProtection::getPasswordHash(PasswordHash eHash) const
+{
+    // TODO: Calculate hash from the clear text based on specified hash algorithm.
+    return maPassHash;
+}
+
+void ScTableProtection::setPasswordHash(const uno::Sequence<sal_Int8>& aPassword, PasswordHash eHash)
+{
+    fprintf(stdout, "ScTableProtection::setPasswordHash: --begin\n");fflush(stdout);
+    meHash = eHash;
+    for (sal_Int32 i = 0; i < aPassword.getLength(); ++i)
+        printf("%2.2X ", static_cast<sal_uInt8>(aPassword[i]));
+    printf("\n");
+    maPassHash = aPassword;
+}
+
+bool ScTableProtection::verifyPassword(const String& aPassText) const
+{
+    fprintf(stdout, "ScTableProtection::verifyPassword: \n");fflush(stdout);
+    if (maPassText.Len())
+        // Clear text password exists, and this one takes precedence.
+        return aPassText.Equals(maPassText);
+
+    Sequence<sal_Int8> aHash = hashPassword(aPassText, meHash);
+    for (sal_Int32 i = 0; i < aHash.getLength(); ++i)
+        printf("%2.2X ", static_cast<sal_uInt8>(aHash[i]));
+    printf("\n");
+    return aHash == maPassHash;
+}
+
+bool ScTableProtection::isOptionEnabled(Option eOption) const
+{
+    if ( maOptions.size() <= static_cast<size_t>(eOption) )
+    {
+        DBG_ERROR("ScTableProtection::isOptionEnabled: wrong size");
+        return false;
+    }
+
+    return maOptions[eOption];
+}
+
+void ScTableProtection::setOption(Option eOption, bool bEnabled)
+{
+    if ( maOptions.size() <= static_cast<size_t>(eOption) )
+    {
+        DBG_ERROR("ScTableProtection::setOption: wrong size");
+        return;
+    }
+
+    maOptions[eOption] = bEnabled;
+}
Index: sc/source/filter/excel/excdoc.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excdoc.cxx,v
retrieving revision 1.67
retrieving revision 1.67.124.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.67 -r1.67.124.1
--- sc/source/filter/excel/excdoc.cxx	22 May 2007 19:44:28 -0000	1.67
+++ sc/source/filter/excel/excdoc.cxx	5 Sep 2007 04:12:55 -0000	1.67.124.1
@@ -393,6 +393,9 @@
 
     if( eBiff == EXC_BIFF8 )
 	{
+        // sheet protection options
+        Add( new XclExpSheetProtect( GetRoot(), mnScTab ) );
+
 		// web queries
         Add( new XclExpWebQueryBuffer( GetRoot() ) );
 
Index: sc/source/filter/excel/excimp8.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/excimp8.cxx,v
retrieving revision 1.121
retrieving revision 1.120.64.2
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.121 -r1.120.64.2
--- sc/source/filter/excel/excimp8.cxx	7 Dec 2007 10:41:47 -0000	1.121
+++ sc/source/filter/excel/excimp8.cxx	10 Dec 2007 23:08:48 -0000	1.120.64.2
@@ -291,6 +291,11 @@
 	}
 }
 
+void ImportExcel8::SheetProtection( void )
+{
+    GetSheetProtectBuffer().ReadOptions( aIn, GetCurrScTab() );
+}
+
 bool lcl_hasVBAEnabled()
 {
 	uno::Reference< beans::XPropertySet > xProps( ::comphelper::getProcessServiceFactory(), uno::UNO_QUERY);
@@ -335,6 +340,7 @@
         pExcRoot->pAutoFilterBuffer->Apply();
 
     GetWebQueryBuffer().Apply();    //! test if extant
+    GetSheetProtectBuffer().Apply();
 
 	ImportExcel::PostDocLoad();
 
Index: sc/source/filter/excel/impop.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/impop.cxx,v
retrieving revision 1.90
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.90 impop.cxx
--- sc/source/filter/excel/impop.cxx	26 Nov 2007 14:41:54 -0000	1.90
+++ sc/source/filter/excel/impop.cxx	22 Dec 2007 07:18:57 -0000
@@ -36,6 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
+#include <stdio.h>
 
 #include "paramisc.hxx"
 #ifndef _IMP_OP_HXX
@@ -120,6 +121,7 @@
 #ifndef SC_XIESCHER_HXX
 #include "xiescher.hxx"
 #endif
+#include "xicontent.hxx"
 
 #include "excimp8.hxx"
 #include "excform.hxx"
@@ -448,14 +450,9 @@
 }
 
 
-BOOL ImportExcel::Password( void )
+void ImportExcel::Password( void )
 {
-	// POST: return = TRUE, wenn Password <> 0
-	UINT16 nPasswd;
-
-	aIn >> nPasswd;
-
-	return nPasswd != 0x0000;
+    GetSheetProtectBuffer().ReadPasswordHash( aIn, GetCurrScTab() );
 }
 
 
@@ -619,7 +616,10 @@
 {
     if( aIn.ReaduInt16() )
     {
-        uno::Sequence<sal_Int8> aEmptyPass;
+        fprintf(stdout, "ImportExcel::Protect: set empty password for sheet %ld\n", 
+                GetCurrScTab());fflush(stdout);
+//      uno::Sequence<sal_Int8> aEmptyPass;
+        String aEmptyPass;
         GetDoc().SetTabProtection( GetCurrScTab(), TRUE, aEmptyPass );
     }
 }
@@ -628,7 +628,8 @@
 {
     if( aIn.ReaduInt16() )
     {
-        uno::Sequence<sal_Int8> aEmptyPass;
+//      uno::Sequence<sal_Int8> aEmptyPass;
+        String aEmptyPass;
         GetDoc().SetDocProtection( TRUE, aEmptyPass );
     }
 }
Index: sc/source/filter/excel/read.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/read.cxx,v
retrieving revision 1.68
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.68 read.cxx
--- sc/source/filter/excel/read.cxx	27 Jun 2007 13:45:32 -0000	1.68
+++ sc/source/filter/excel/read.cxx	22 Dec 2007 07:18:57 -0000
@@ -1080,6 +1080,7 @@
                         aIn.SeekGlobalPosition();         // und zurueck an alte Position
                         break;
                     case 0x12:  Protect(); break;
+                    case 0x13:  Password(); break;
                     case 0x42:  Codepage(); break;      // CODEPAGE     [ 2345   ]
                     case 0x55:  DefColWidth(); break;
                     case 0x7D:  Colinfo(); break;       // COLINFO      [  345   ]
@@ -1095,6 +1096,7 @@
                     case 0x0221: Array34(); break;      // ARRAY        [  34    ]
                     case 0x0225: Defrowheight345();break;//DEFAULTROWHEI[  345   ]
                     case 0x04BC: Shrfmla(); break;      // SHRFMLA      [    5   ]
+                    case 0x0867: SheetProtection(); break; // SHEETPROTECTION
                 }
             }
             break;
Index: sc/source/filter/excel/xetable.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xetable.cxx,v
retrieving revision 1.16
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.16 xetable.cxx
--- sc/source/filter/excel/xetable.cxx	22 May 2007 19:48:53 -0000	1.16
+++ sc/source/filter/excel/xetable.cxx	22 Dec 2007 07:18:58 -0000
@@ -81,6 +81,7 @@
 #ifndef SC_XEESCHER_HXX
 #include "xeescher.hxx"
 #endif
+#include "tabprotection.hxx"
 
 namespace ApiScriptType = ::com::sun::star::i18n::ScriptType;
 
@@ -2238,3 +2239,66 @@
 
 // ============================================================================
 
+struct XclExpTabProtectOption
+{
+    ScTableProtection::Option   eOption;
+    sal_uInt16                  nMask;
+};
+
+XclExpSheetProtect::XclExpSheetProtect( const XclExpRoot& rRoot, SCTAB nTab ) :
+    XclExpRecord( 0x0867, 23 )
+{
+    static const XclExpTabProtectOption aTable[] =
+    {
+        { ScTableProtection::OBJECTS,               0x0001 },
+        { ScTableProtection::SCENARIOS,             0x0002 },
+        { ScTableProtection::FORMAT_CELLS,          0x0004 },
+        { ScTableProtection::FORMAT_COLUMNS,        0x0008 },
+        { ScTableProtection::FORMAT_ROWS,           0x0010 },
+        { ScTableProtection::INSERT_COLUMNS,        0x0020 },
+        { ScTableProtection::INSERT_ROWS,           0x0040 },
+        { ScTableProtection::INSERT_HYPERLINKS,     0x0080 },
+
+        { ScTableProtection::DELETE_COLUMNS,        0x0100 },
+        { ScTableProtection::DELETE_ROWS,           0x0200 },
+        { ScTableProtection::SELECT_LOCKED_CELLS,   0x0400 },
+        { ScTableProtection::SORT,                  0x0800 },
+        { ScTableProtection::AUTOFILTER,            0x1000 },
+        { ScTableProtection::PIVOT_TABLES,          0x2000 },
+        { ScTableProtection::SELECT_UNLOCKED_CELLS, 0x4000 },
+
+        { ScTableProtection::NONE,                  0x0000 }
+    };
+
+    mnOptions = 0x0000;
+    ScTableProtection* pProtect = rRoot.GetDoc().GetTabProtection(nTab);
+    if (!pProtect)
+        return;
+
+    for (int i = 0; aTable[i].nMask != 0x0000; ++i)
+    {
+        if ( pProtect->isOptionEnabled(aTable[i].eOption) )
+            mnOptions |= aTable[i].nMask;
+    }
+}
+
+void XclExpSheetProtect::WriteBody( XclExpStream& rStrm )
+{
+    sal_uInt16 nBytes = 0x0867;
+    rStrm << nBytes;
+
+    sal_uChar nZero = 0x00;
+    for (int i = 0; i < 9; ++i)
+        rStrm << nZero;
+
+    nBytes = 0x0200;
+    rStrm << nBytes;
+    nBytes = 0x0100;
+    rStrm << nBytes;
+    nBytes = 0xFFFF;
+    rStrm << nBytes << nBytes;
+
+    rStrm << mnOptions;
+    nBytes = 0;
+    rStrm << nBytes;
+}
Index: sc/source/filter/excel/xicontent.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xicontent.cxx,v
retrieving revision 1.29
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.29 xicontent.cxx
--- sc/source/filter/excel/xicontent.cxx	2 Aug 2007 13:31:10 -0000	1.29
+++ sc/source/filter/excel/xicontent.cxx	22 Dec 2007 07:18:58 -0000
@@ -147,6 +147,11 @@
 #endif
 
 #include "excform.hxx"
+#include "tabprotection.hxx"
+
+#include <stdio.h>
+
+using ::com::sun::star::uno::Sequence;
 
 // Shared string table ========================================================
 
@@ -1005,6 +1010,7 @@
 
 XclImpDecrypterRef lclReadFilepass5( XclImpStream& rStrm )
 {
+    fprintf(stdout, "lclReadFilepass5: --begin\n");fflush(stdout);
     XclImpDecrypterRef xDecr;
     DBG_ASSERT( rStrm.GetRecLeft() == 4, "lclReadFilepass5 - wrong record size" );
     if( rStrm.GetRecLeft() == 4 )
@@ -1018,6 +1024,7 @@
 
 XclImpDecrypterRef lclReadFilepass8_Standard( XclImpStream& rStrm )
 {
+    fprintf(stdout, "lclReadFilepass8_Standard: \n");fflush(stdout);
     XclImpDecrypterRef xDecr;
     DBG_ASSERT( rStrm.GetRecLeft() == 48, "lclReadFilepass8 - wrong record size" );
     if( rStrm.GetRecLeft() == 48 )
@@ -1026,8 +1033,20 @@
         sal_uInt8 pnSaltData[ 16 ];
         sal_uInt8 pnSaltHash[ 16 ];
         rStrm.Read( pnDocId, 16 );
+        printf("doc ID:\n");
+        for (int i = 0; i < 16; ++i)
+            printf("%2.2x ", pnDocId[i]);
+        printf("\n");
         rStrm.Read( pnSaltData, 16 );
+        printf("salt:\n");
+        for (int i = 0; i < 16; ++i)
+            printf("%2.2x ", pnSaltData[i]);
+        printf("\n");
         rStrm.Read( pnSaltHash, 16 );
+        printf("salt hash:\n");
+        for (int i = 0; i < 16; ++i)
+            printf("%2.2x ", pnSaltHash[i]);
+        printf("\n");
         xDecr.reset( new XclImpBiff8Decrypter(
             rStrm.GetRoot(), pnDocId, pnSaltData, pnSaltHash ) );
     }
@@ -1036,12 +1055,14 @@
 
 XclImpDecrypterRef lclReadFilepass8_Strong( XclImpStream& /*rStrm*/ )
 {
+    fprintf(stdout, "lclReadFilepass8_Strong: \n");fflush(stdout);
     // not supported
     return XclImpDecrypterRef();
 }
 
 XclImpDecrypterRef lclReadFilepass8( XclImpStream& rStrm )
 {
+    fprintf(stdout, "lclReadFilepass8: \n");fflush(stdout);
     XclImpDecrypterRef xDecr;
 
     sal_uInt16 nMode;
@@ -1084,6 +1105,7 @@
 
 ErrCode XclImpDecryptHelper::ReadFilepass( XclImpStream& rStrm )
 {
+    fprintf(stdout, "XclImpDecryptHelper::ReadFilepass: --begin\n");fflush(stdout);
     XclImpDecrypterRef xDecr;
     rStrm.DisableDecryption();
 
@@ -1100,9 +1122,102 @@
     rStrm.SetDecrypter( xDecr );
     // remember encryption for export
     rStrm.GetRoot().GetExtDocOptions().GetDocSettings().mbEncrypted = true;
-
+    fprintf(stdout, "XclImpDecryptHelper::ReadFilepass: --end\n");fflush(stdout);
     return xDecr.is() ? xDecr->GetError() : EXC_ENCR_ERROR_UNSUPP_CRYPT;
 }
 
+// Sheet Protection ===========================================================
+
+XclImpSheetProtectBuffer::Sheet::Sheet() :
+    mnPasswordHash(0x0000), mnOptions(0x4400)
+{
+}
+
+// ----------------------------------------------------------------------------
+
+XclImpSheetProtectBuffer::Sheet::Sheet(const Sheet& r) :
+    mnPasswordHash(r.mnPasswordHash), mnOptions(r.mnOptions)
+{
+}
+
+XclImpSheetProtectBuffer::XclImpSheetProtectBuffer( const XclImpRoot& rRoot ) :
+    XclImpRoot( rRoot )
+{
+}
+
+void XclImpSheetProtectBuffer::ReadOptions( XclImpStream& rStrm, SCTAB nTab )
+{
+    rStrm.Ignore(19);
+    sal_uInt16 nOptions;
+    rStrm >> nOptions;
+
+    Sheet* pSheet = GetSheetItem(nTab);
+    if (pSheet)
+        pSheet->mnOptions = nOptions;
+}
+
+void XclImpSheetProtectBuffer::ReadPasswordHash( XclImpStream& rStrm, SCTAB nTab )
+{
+    sal_uInt16 nHash;
+    rStrm >> nHash;
+    fprintf(stdout, "XclImpSheetProtectBuffer::ReadPasswordHash: password hash = %4.4X\n", nHash);fflush(stdout);
+    Sheet* pSheet = GetSheetItem(nTab);
+    if (pSheet)
+        pSheet->mnPasswordHash = nHash;
+}
+
+void XclImpSheetProtectBuffer::Apply() const
+{
+    ScDocument& rDoc = GetDoc();
+    for (ProtectedSheetMap::const_iterator itr = maProtectedSheets.begin(), itrEnd = maProtectedSheets.end();
+         itr != itrEnd; ++itr)
+    {
+        ScTableProtection* pProtect = rDoc.GetTabProtection(itr->first);
+        if (!pProtect)
+            // This should not happen!
+            continue;
+
+        // 16-bit hash password
+        const sal_uInt16 nHash = itr->second.mnPasswordHash;
+        Sequence<sal_Int8> aPass(2);
+        aPass[0] = (nHash >> 8) & 0xFF;
+        aPass[1] = nHash & 0xFF;
+        pProtect->setPasswordHash(aPass, ScTableProtection::HASH_XL);
+
+        // sheet protection options
+        const sal_uInt16 rOptions = itr->second.mnOptions;
+        pProtect->setOption( ScTableProtection::OBJECTS,               (rOptions & 0x0001) );
+        pProtect->setOption( ScTableProtection::SCENARIOS,             (rOptions & 0x0002) );
+        pProtect->setOption( ScTableProtection::FORMAT_CELLS,          (rOptions & 0x0004) );
+        pProtect->setOption( ScTableProtection::FORMAT_COLUMNS,        (rOptions & 0x0008) );
+        pProtect->setOption( ScTableProtection::FORMAT_ROWS,           (rOptions & 0x0010) );
+        pProtect->setOption( ScTableProtection::INSERT_COLUMNS,        (rOptions & 0x0020) );
+        pProtect->setOption( ScTableProtection::INSERT_ROWS,           (rOptions & 0x0040) );
+        pProtect->setOption( ScTableProtection::INSERT_HYPERLINKS,     (rOptions & 0x0080) );
+        pProtect->setOption( ScTableProtection::DELETE_COLUMNS,        (rOptions & 0x0100) );
+        pProtect->setOption( ScTableProtection::DELETE_ROWS,           (rOptions & 0x0200) );
+        pProtect->setOption( ScTableProtection::SELECT_LOCKED_CELLS,   (rOptions & 0x0400) );
+        pProtect->setOption( ScTableProtection::SORT,                  (rOptions & 0x0800) );
+        pProtect->setOption( ScTableProtection::AUTOFILTER,            (rOptions & 0x1000) );
+        pProtect->setOption( ScTableProtection::PIVOT_TABLES,          (rOptions & 0x2000) );
+        pProtect->setOption( ScTableProtection::SELECT_UNLOCKED_CELLS, (rOptions & 0x4000) );
+    }
+}
+
+XclImpSheetProtectBuffer::Sheet* XclImpSheetProtectBuffer::GetSheetItem( SCTAB nTab )
+{
+    ProtectedSheetMap::iterator itr = maProtectedSheets.find(nTab);
+    if (itr == maProtectedSheets.end())
+    {
+        // new sheet
+        if ( !maProtectedSheets.insert( ProtectedSheetMap::value_type(nTab, Sheet()) ).second )
+            return NULL;
+
+        itr = maProtectedSheets.find(nTab);
+    }
+
+    return &itr->second;
+}
+
 // ============================================================================
 
Index: sc/source/filter/excel/xiroot.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xiroot.cxx,v
retrieving revision 1.23
retrieving revision 1.23.126.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.23 -r1.23.126.1
--- sc/source/filter/excel/xiroot.cxx	22 May 2007 19:50:21 -0000	1.23
+++ sc/source/filter/excel/xiroot.cxx	5 Sep 2007 04:12:55 -0000	1.23.126.1
@@ -120,6 +120,7 @@
         GetOldRoot().pAutoFilterBuffer = new XclImpAutoFilterBuffer;
         mrImpData.mxWebQueryBfr.reset( new XclImpWebQueryBuffer( GetRoot() ) );
         mrImpData.mxPTableMgr.reset( new XclImpPivotTableManager( GetRoot() ) );
+        mrImpData.mxTabProtect.reset( new XclImpSheetProtectBuffer( GetRoot() ) );
     }
 
     mrImpData.mxPageSett.reset( new XclImpPageSettings( GetRoot() ) );
@@ -258,6 +259,12 @@
     return *mrImpData.mxPTableMgr;
 }
 
+XclImpSheetProtectBuffer& XclImpRoot::GetSheetProtectBuffer() const
+{
+    DBG_ASSERT( mrImpData.mxTabProtect.is(), "XclImpRoot::GetSheetProtectBuffer - invalid call, wrong BIFF" );
+    return *mrImpData.mxTabProtect;
+}
+
 XclImpPageSettings& XclImpRoot::GetPageSettings() const
 {
     return *mrImpData.mxPageSett;
Index: sc/source/filter/excel/xistream.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xistream.cxx,v
retrieving revision 1.21
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 xistream.cxx
--- sc/source/filter/excel/xistream.cxx	27 Feb 2007 12:28:06 -0000	1.21
+++ sc/source/filter/excel/xistream.cxx	22 Dec 2007 07:18:58 -0000
@@ -49,6 +49,9 @@
 #include "xiroot.hxx"
 #endif
 
+#include <stdio.h>
+#include <vector>
+
 // ============================================================================
 // Decryption
 // ============================================================================
@@ -194,6 +197,7 @@
         memcpy( mpnPassw, rSrc.mpnPassw, sizeof( mpnPassw ) );
         memcpy( mpnDocId, rSrc.mpnDocId, sizeof( mpnDocId ) );
         maCodec.InitKey( mpnPassw, mpnDocId );
+        maCodec2.InitKey( mpnPassw, mpnDocId );
     }
 }
 
@@ -216,17 +220,23 @@
         if( (nNewBlock != nOldBlock) || (nNewOffset < nOldOffset) )
         {
             maCodec.InitCipher( nNewBlock );
+            maCodec2.InitCipher( nNewBlock );
             nOldOffset = 0;     // reset nOldOffset for next if() statement
         }
 
         /*  Seek to correct offset. */
         if( nNewOffset > nOldOffset )
+        {
             maCodec.Skip( nNewOffset - nOldOffset );
+            maCodec2.Skip( nNewOffset - nOldOffset );
+        }
     }
 }
 
 sal_uInt16 XclImpBiff8Decrypter::OnRead( SvStream& rStrm, sal_uInt8* pnData, sal_uInt16 nBytes )
 {
+    fprintf(stdout, "XclImpBiff8Decrypter::OnRead: --begin (bytes to read = %d) ------------------------------\n", nBytes);fflush(stdout);
+
     sal_uInt16 nRet = 0;
 
     sal_uInt8* pnCurrData = pnData;
@@ -235,13 +245,44 @@
     {
         sal_uInt16 nBlockLeft = EXC_ENCR_BLOCKSIZE - GetOffset( rStrm.Tell() );
         sal_uInt16 nDecBytes = ::std::min< sal_uInt16 >( nBytesLeft, nBlockLeft );
+        fprintf(stdout, "XclImpBiff8Decrypter::OnRead:   nDecBytes = %d\n", nDecBytes);fflush(stdout);
 
         // read the block from stream
         nRet = nRet + static_cast< sal_uInt16 >( rStrm.Read( pnCurrData, nDecBytes ) );
+        fprintf(stdout, "raw bytes:\n");
+        for (sal_uInt16 i = 0; i < nDecBytes; ++i)
+            fprintf(stdout, "%2.2x ", pnCurrData[i]);
+        fprintf(stdout, "\n");
+
         // decode the block inplace
         maCodec.Decode( pnCurrData, nDecBytes, pnCurrData, nDecBytes );
+        fprintf(stdout, "decoded bytes:\n");
+        for (sal_uInt16 i = 0; i < nDecBytes; ++i)
+            fprintf(stdout, "%2.2x ", pnCurrData[i]);
+        fprintf(stdout, "\n");
+
+        if (nDecBytes)
+        {
+            ::std::vector<sal_uInt8> pnEncData(nDecBytes);
+            bool result = maCodec2.Encode(pnCurrData, nDecBytes, &pnEncData[0], nDecBytes);
+            if (result)
+            {
+                fprintf(stdout, "re-encoded bytes:\n");
+                for (sal_uInt16 i = 0; i < nDecBytes; ++i)
+                    fprintf(stdout, "%2.2x ", pnEncData.at(i));
+                fprintf(stdout, "\n");
+            }
+            else
+            {
+                fprintf(stdout, "re-encoding failed\n");
+            }
+        }
+
         if( GetOffset( rStrm.Tell() ) == 0 )
+        {
             maCodec.InitCipher( GetBlock( rStrm.Tell() ) );
+            maCodec2.InitCipher( GetBlock( rStrm.Tell() ) );
+        }
 
         pnCurrData += nDecBytes;
         nBytesLeft = nBytesLeft - nDecBytes;
@@ -254,6 +295,8 @@
         const String& rPass, sal_uInt8 pnDocId[ 16 ],
         sal_uInt8 pnSaltData[ 16 ], sal_uInt8 pnSaltHash[ 16 ] )
 {
+    fprintf(stdout, "XclImpBiff8Decrypter::Init: password = '%s'\n",
+            OUStringToOString(rtl::OUString(rPass), RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
     xub_StrLen nLen = rPass.Len();
     bool bValid = (0 < nLen) && (nLen < 16);
 
@@ -268,6 +311,8 @@
         // init codec
         maCodec.InitKey( mpnPassw, mpnDocId );
         bValid = maCodec.VerifyKey( pnSaltData, pnSaltHash );
+        maCodec2.InitKey( mpnPassw, mpnDocId );
+        bValid = maCodec2.VerifyKey( pnSaltData, pnSaltHash );
     }
 
     SetHasValidPassword( bValid );
@@ -461,6 +506,11 @@
 void XclImpStream::EnableDecryption( bool bEnable )
 {
     mbUseDecr = bEnable && HasValidDecrypter();
+//  fprintf(stdout, "XclImpStream::EnableDecryption: (%s)\n", mbUseDecr?"true":"false");fflush(stdout);
+//  if (!mbUseDecr)
+//  {
+//      fprintf(stdout, "XclImpStream::EnableDecryption: decryption disabled\n");fflush(stdout);
+//  }
 }
 
 // ----------------------------------------------------------------------------
@@ -1007,11 +1057,33 @@
 
 bool XclImpStream::ReadNextRawRecHeader()
 {
+#if 1
+    mrStrm.Seek( mnNextRecPos );
+    bool bRet = mnNextRecPos + 4 <= mnStreamSize;
+    if( bRet )
+        mrStrm >> mnRawRecId >> mnRawRecSize;
+    return bRet;
+#else
     mrStrm.Seek( mnNextRecPos );
     bool bRet = mnNextRecPos + 4 <= mnStreamSize;
     if( bRet )
+    {
         mrStrm >> mnRawRecId >> mnRawRecSize;
+        fprintf(stdout, "---------- record (%4.4X) (size = %d) -----\n", mnRawRecId, mnRawRecSize);
+        for (sal_uInt16 i = 0; i < mnRawRecSize; ++i)
+        {
+            sal_uInt8 byte;
+            mrStrm >> byte;
+            printf("%2.2X ", byte);
+            if ((i+1) % 16 == 0)
+                printf("\n");
+        }
+        printf("\n");
+        fflush(stdout);
+        mrStrm.Seek( mnNextRecPos+4 );
+    }
     return bRet;
+#endif
 }
 
 void XclImpStream::SetupDecrypter()
Index: sc/source/filter/excel/xlroot.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/excel/xlroot.cxx,v
retrieving revision 1.31
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.31 xlroot.cxx
--- sc/source/filter/excel/xlroot.cxx	3 Jul 2007 15:52:14 -0000	1.31
+++ sc/source/filter/excel/xlroot.cxx	22 Dec 2007 07:18:58 -0000
@@ -264,6 +264,8 @@
         mrData.maPassw = ScfApiHelper::QueryPasswordForMedium( GetMedium() );
         // set to true, even if dialog has been cancelled (never ask twice)
         mrData.mbHasPassw = true;
+        fprintf(stdout, "XclRoot::QueryPassword: password = '%s'\n",
+                OUStringToOString(rtl::OUString(mrData.maPassw), RTL_TEXTENCODING_UTF8).getStr());fflush(stdout);
     }
     return mrData.maPassw;
 }
Index: sc/source/filter/inc/excimp8.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/excimp8.hxx,v
retrieving revision 1.68
retrieving revision 1.68.164.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.68 -r1.68.164.1
--- sc/source/filter/inc/excimp8.hxx	27 Feb 2007 12:32:31 -0000	1.68
+++ sc/source/filter/inc/excimp8.hxx	5 Sep 2007 04:12:55 -0000	1.68.164.1
@@ -91,6 +91,7 @@
 
 		void					Hlink( void );					// 0x01B8
 		void					Codename( BOOL bWBGlobals );	// 0x01BA
+        void                    SheetProtection( void );        // 0x0867
 
         virtual void            EndSheet( void );
 		virtual void			PostDocLoad( void );
Index: sc/source/filter/inc/imp_op.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/imp_op.hxx,v
retrieving revision 1.41
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.41 imp_op.hxx
--- sc/source/filter/inc/imp_op.hxx	22 May 2007 19:55:08 -0000	1.41
+++ sc/source/filter/inc/imp_op.hxx	22 Dec 2007 07:18:58 -0000
@@ -163,7 +163,7 @@
 	void					Eof( void );					// 0x0A
 	void					DocProtect( void );             // 0x12
 	void					Protect( void );				// 0x12	Sheet Protection
-	BOOL					Password( void );				// 0x13
+    void                    Password( void );               // 0x13
 	void					Externsheet( void );			// 0x17
 	void					Note( void );					// 0x1C
 	void					Columndefault( void );			// 0x20
Index: sc/source/filter/inc/xetable.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xetable.hxx,v
retrieving revision 1.9
retrieving revision 1.9.126.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.9 -r1.9.126.1
--- sc/source/filter/inc/xetable.hxx	22 May 2007 19:56:57 -0000	1.9
+++ sc/source/filter/inc/xetable.hxx	5 Sep 2007 04:12:55 -0000	1.9.126.1
@@ -1091,5 +1091,20 @@
 
 // ============================================================================
 
+/** Represents a SHEETPROTECTION record that stores sheet protection
+    options.  Note that a sheet still needs to save its sheet protection
+    options even when it's not protected. */
+class XclExpSheetProtect : public XclExpRecord
+{
+public:
+    explicit            XclExpSheetProtect( const XclExpRoot& rRoot, SCTAB nTab );
+
+private:
+    virtual void        WriteBody( XclExpStream& rStrm );
+
+private:
+    sal_uInt16      mnOptions;      /// Encoded sheet protection options.
+};
+
 #endif
 
Index: sc/source/filter/inc/xicontent.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xicontent.hxx,v
retrieving revision 1.14
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.14 xicontent.hxx
--- sc/source/filter/inc/xicontent.hxx	6 Jul 2007 12:38:28 -0000	1.14
+++ sc/source/filter/inc/xicontent.hxx	22 Dec 2007 07:18:58 -0000
@@ -53,6 +53,8 @@
 #include "xiroot.hxx"
 #endif
 
+#include <map>
+
 /* ============================================================================
 Classes to import the big Excel document contents (related to several cells or
 globals for the document).
@@ -261,5 +263,39 @@
 
 // ============================================================================
 
+
+// Sheet protection ===========================================================
+
+class XclImpSheetProtectBuffer : protected XclImpRoot
+{
+public:
+    explicit            XclImpSheetProtectBuffer( const XclImpRoot& rRoot );
+
+    void                ReadOptions( XclImpStream& rStrm, SCTAB nTab );
+
+    void                ReadPasswordHash( XclImpStream& rStrm, SCTAB nTab );
+
+    void                Apply() const;
+
+private:
+    struct Sheet
+    {
+        sal_uInt16  mnPasswordHash;
+        sal_uInt16  mnOptions;
+
+        Sheet();
+        Sheet(const Sheet& r);
+    };
+
+    Sheet* GetSheetItem( SCTAB nTab );
+
+private:
+    typedef ::std::map<SCTAB, Sheet> ProtectedSheetMap;
+    ProtectedSheetMap   maProtectedSheets;
+};
+
+
+// ============================================================================
+
 #endif
 
Index: sc/source/filter/inc/xiroot.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xiroot.hxx,v
retrieving revision 1.21
retrieving revision 1.21.220.1
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 -r1.21.220.1
--- sc/source/filter/inc/xiroot.hxx	19 Dec 2006 13:24:31 -0000	1.21
+++ sc/source/filter/inc/xiroot.hxx	5 Sep 2007 04:12:56 -0000	1.21.220.1
@@ -68,6 +68,7 @@
 class XclImpPageSettings;
 class XclImpDocViewSettings;
 class XclImpTabViewSettings;
+class XclImpSheetProtectBuffer;
 
 class _ScRangeListTabs;
 class ExcelToSc;
@@ -94,6 +95,7 @@
     typedef ScfRef< XclImpPageSettings >        XclImpPageSettRef;
     typedef ScfRef< XclImpDocViewSettings >     XclImpDocViewSettRef;
     typedef ScfRef< XclImpTabViewSettings >     XclImpTabViewSettRef;
+    typedef ScfRef< XclImpSheetProtectBuffer >  XclImpTabProtectRef;
 
     XclImpAddrConvRef   mxAddrConv;         /// The address converter.
     XclImpFmlaCompRef   mxFmlaComp;         /// The formula compiler.
@@ -117,6 +119,7 @@
     XclImpPageSettRef   mxPageSett;         /// Page settings for current sheet.
     XclImpDocViewSettRef mxDocViewSett;     /// View settings for entire document.
     XclImpTabViewSettRef mxTabViewSett;     /// View settings for current sheet.
+    XclImpTabProtectRef mxTabProtect;       /// Sheet protection options for current sheet.
 
     bool                mbHasCodePage;      /// true = CODEPAGE record exists.
 
@@ -188,6 +191,9 @@
     XclImpWebQueryBuffer& GetWebQueryBuffer() const;
     /** Returns the pivot table manager. */
     XclImpPivotTableManager& GetPivotTableManager() const;
+    /** Returns the sheet protection options of the current sheet. */
+    XclImpSheetProtectBuffer& GetSheetProtectBuffer() const;
+
 
     /** Returns the page settings of the current sheet. */
     XclImpPageSettings& GetPageSettings() const;
Index: sc/source/filter/inc/xistream.hxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/inc/xistream.hxx,v
retrieving revision 1.12
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.12 xistream.hxx
--- sc/source/filter/inc/xistream.hxx	27 Feb 2007 12:37:18 -0000	1.12
+++ sc/source/filter/inc/xistream.hxx	22 Dec 2007 07:18:58 -0000
@@ -176,6 +176,7 @@
 
 private:
     ::svx::MSCodec_Std97 maCodec;       /// Crypto algorithm implementation.
+    ::svx::MSCodec_Std97 maCodec2;       /// Crypto algorithm implementation.
     sal_uInt16          mpnPassw[ 16 ]; /// Cached password data for copy construction.
     sal_uInt8           mpnDocId[ 16 ]; /// Cached document ID for copy construction.
 };
Index: sc/source/filter/starcalc/scflt.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/starcalc/scflt.cxx,v
retrieving revision 1.21
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.21 scflt.cxx
--- sc/source/filter/starcalc/scflt.cxx	26 Nov 2007 14:42:17 -0000	1.21
+++ sc/source/filter/starcalc/scflt.cxx	22 Dec 2007 07:18:59 -0000
@@ -1156,9 +1156,9 @@
 	//rStream.Read(&SheetProtect, sizeof(SheetProtect));
 	lcl_ReadSheetProtect(rStream, SheetProtect);
 	nError = rStream.GetError();
-	uno::Sequence<sal_Int8> aPass;
-	SvPasswordHelper::GetHashPassword(aPass, SC10TOSTRING( SheetProtect.PassWord ));
-	pDoc->SetDocProtection( SheetProtect.Protect,  aPass);
+//  uno::Sequence<sal_Int8> aPass;
+//  SvPasswordHelper::GetHashPassword(aPass, SC10TOSTRING( SheetProtect.PassWord ));
+	pDoc->SetDocProtection( SheetProtect.Protect, SC10TOSTRING( SheetProtect.PassWord ));
 }
 
 
@@ -1510,10 +1510,10 @@
 
 		//rStream.Read(&TabProtect, sizeof(TabProtect));
 		lcl_ReadTabProtect(rStream, TabProtect);
-		uno::Sequence<sal_Int8> aPass;
-		SvPasswordHelper::GetHashPassword(aPass, SC10TOSTRING( TabProtect.PassWord ));
+//      uno::Sequence<sal_Int8> aPass;
+//      SvPasswordHelper::GetHashPassword(aPass, SC10TOSTRING( TabProtect.PassWord ));
 
-		pDoc->SetTabProtection( static_cast<SCTAB>(Tab), TabProtect.Protect, aPass);
+		pDoc->SetTabProtection( static_cast<SCTAB>(Tab), TabProtect.Protect, SC10TOSTRING( TabProtect.PassWord ));
 
 		rStream >> TabNo;
 
Index: sc/source/filter/xml/xmlexprt.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlexprt.cxx,v
retrieving revision 1.207
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.207 xmlexprt.cxx
--- sc/source/filter/xml/xmlexprt.cxx	6 Jul 2007 12:40:24 -0000	1.207
+++ sc/source/filter/xml/xmlexprt.cxx	22 Dec 2007 07:18:59 -0000
@@ -136,6 +136,7 @@
 #ifndef SC_CONVUNO_HXX
 #include "convuno.hxx"
 #endif
+#include "tabprotection.hxx"
 
 #ifndef _XMLOFF_XMLTOKEN_HXX
 #include <xmloff/xmltoken.hxx>
@@ -1571,11 +1572,13 @@
 		DBG_ERROR("no shared data setted");
 	}
 	ScXMLExportDatabaseRanges aExportDatabaseRanges(*this);
-	if (GetModel().is())
-	{
+	if (!GetModel().is())
+        return;
+
 		uno::Reference <sheet::XSpreadsheetDocument> xSpreadDoc( GetModel(), uno::UNO_QUERY );
-		if ( xSpreadDoc.is() )
-		{
+    if ( !xSpreadDoc.is() )
+        return;
+
 			uno::Reference<container::XIndexAccess> xIndex( xSpreadDoc->getSheets(), uno::UNO_QUERY );
 			if ( xIndex.is() )
 			{
@@ -1625,7 +1628,11 @@
 								AddAttribute(XML_NAMESPACE_TABLE, XML_PROTECTED, XML_TRUE);
 								rtl::OUStringBuffer aBuffer;
 								if (pDoc)
-									SvXMLUnitConverter::encodeBase64(aBuffer, pDoc->GetTabPassword(static_cast<SCTAB>(nTable)));
+                        {
+                            ScTableProtection* pProtect = pDoc->GetTabProtection(static_cast<SCTAB>(nTable));
+                            if (pProtect)
+                                SvXMLUnitConverter::encodeBase64(aBuffer, pProtect->getPasswordHash(ScTableProtection::HASH_OOO));
+                        }
 								if (aBuffer.getLength())
 									AddAttribute(XML_NAMESPACE_TABLE, XML_PROTECTION_KEY, aBuffer.makeStringAndClear());
 							}
@@ -1730,6 +1737,7 @@
 					IncrementProgressBar(sal_False);
 				}
 			}
+
 			WriteNamedExpressions(xSpreadDoc);
 			aExportDatabaseRanges.WriteDatabaseRanges(xSpreadDoc);
 			ScXMLExportDataPilot aExportDataPilot(*this);
@@ -1739,8 +1747,6 @@
 			aExportDDELinks.WriteDDELinks(xSpreadDoc);
             IncrementProgressBar(sal_True, 0);
 			GetProgressBarHelper()->SetValue(GetProgressBarHelper()->GetReference());
-		}
-	}
 }
 
 void ScXMLExport::_ExportStyles( sal_Bool bUsed )
Index: sc/source/filter/xml/xmlsubti.cxx
===================================================================
RCS file: /cvs/sc/sc/source/filter/xml/xmlsubti.cxx,v
retrieving revision 1.47
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.47 xmlsubti.cxx
--- sc/source/filter/xml/xmlsubti.cxx	27 Feb 2007 12:53:21 -0000	1.47
+++ sc/source/filter/xml/xmlsubti.cxx	22 Dec 2007 07:19:00 -0000
@@ -55,6 +55,7 @@
 #ifndef _SC_XMLSTYLESIMPORTHELPER_HXX
 #include "XMLStylesImportHelper.hxx"
 #endif
+#include "tabprotection.hxx"
 
 #include <xmloff/xmltkmap.hxx>
 #include <xmloff/nmspmap.hxx>
@@ -679,7 +680,10 @@
 	{
 		uno::Sequence<sal_Int8> aPass;
 		SvXMLUnitConverter::decodeBase64(aPass, sPassword);
-		rImport.GetDocument()->SetTabProtection(static_cast<SCTAB>(nCurrentSheet), bProtection, aPass);
+        ScTableProtection* pProtect = rImport.GetDocument()->GetTabProtection(static_cast<SCTAB>(nCurrentSheet));
+        pProtect->setProtected(bProtection);
+        pProtect->setPasswordHash(aPass, ScTableProtection::HASH_OOO);
+//      rImport.GetDocument()->SetTabProtection(static_cast<SCTAB>(nCurrentSheet), bProtection, sPassword);
 		/*uno::Reference <util::XProtectable> xProtectable(xCurrentSheet, uno::UNO_QUERY);
 		if (xProtectable.is())
 		{
Index: sc/source/ui/docshell/docfunc.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/docshell/docfunc.cxx,v
retrieving revision 1.66
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.66 docfunc.cxx
--- sc/source/ui/docshell/docfunc.cxx	27 Jun 2007 12:45:25 -0000	1.66
+++ sc/source/ui/docshell/docfunc.cxx	22 Dec 2007 07:19:01 -0000
@@ -99,7 +99,10 @@
 #include "editable.hxx"
 #include "compiler.hxx"
 #include "scui_def.hxx" //CHINA001
+#include "tabprotection.hxx"
+
 using namespace com::sun::star;
+using ::com::sun::star::uno::Sequence;
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -2602,6 +2605,7 @@
 
 //------------------------------------------------------------------------
 
+#if 0
 BOOL lcl_ValidPassword( ScDocument* pDoc, SCTAB nTab,
 						const String& rPassword,
 						uno::Sequence<sal_Int8>* pReturnOld = NULL )
@@ -2621,34 +2625,36 @@
 	if (pReturnOld)
 		*pReturnOld = aOldPassword;
 
-	return ((aOldPassword.getLength() == 0) || SvPasswordHelper::CompareHashPassword(aOldPassword, rPassword));
+    return((aOldPassword.getLength() == 0) || SvPasswordHelper::CompareHashPassword(aOldPassword, rPassword));
 }
+#endif
 
 BOOL ScDocFunc::Protect( SCTAB nTab, const String& rPassword, BOOL bApi )
 {
-	ScDocShellModificator aModificator( rDocShell );
-
 	ScDocument* pDoc = rDocShell.GetDocument();
-	BOOL bUndo(pDoc->IsUndoEnabled());
-	BOOL bOk = lcl_ValidPassword( pDoc, nTab, rPassword);
+    ScTableProtection* pTabProtect = pDoc->GetTabProtection(nTab);
+    if (!pTabProtect)
+        return false;
+
+    bool bOk = false;
+    if (nTab != TABLEID_DOC)
+        bOk = pTabProtect->verifyPassword(rPassword);
+//  BOOL bOk = lcl_ValidPassword( pDoc, nTab, rPassword);
 	if ( bOk )
 	{
-	    uno::Sequence<sal_Int8> aPass;
-	    if (rPassword.Len())
-	        SvPasswordHelper::GetHashPassword(aPass, rPassword);
-
-		if (bUndo)
+		if (pDoc->IsUndoEnabled())
 		{
 			rDocShell.GetUndoManager()->AddUndoAction(
-						new ScUndoProtect( &rDocShell, nTab, TRUE, aPass ) );
+						new ScUndoProtect( &rDocShell, nTab, TRUE, rPassword ) );
 		}
 
 		if ( nTab == TABLEID_DOC )
-			pDoc->SetDocProtection( TRUE, aPass );
+            pDoc->SetDocProtection(true, rPassword);
 		else
-			pDoc->SetTabProtection( nTab, TRUE, aPass );
+			pDoc->SetTabProtection(nTab, true, rPassword);
 
 		rDocShell.PostPaintGridAll();
+        ScDocShellModificator aModificator( rDocShell );
 		aModificator.SetDocumentModified();
 	}
 	else if (!bApi)
@@ -2666,34 +2672,38 @@
 
 BOOL ScDocFunc::Unprotect( SCTAB nTab, const String& rPassword, BOOL bApi )
 {
-	ScDocShellModificator aModificator( rDocShell );
-
 	ScDocument* pDoc = rDocShell.GetDocument();
-	BOOL bUndo(pDoc->IsUndoEnabled());
-	uno::Sequence<sal_Int8> aOldPassword;
-	uno::Sequence<sal_Int8> aPass;
-	BOOL bOk = lcl_ValidPassword( pDoc, nTab, rPassword, &aOldPassword );
+    ScTableProtection* pTabProtect = pDoc->GetTabProtection(nTab);
+    if (!pTabProtect)
+        return false;
+
+    bool bOk = false;
+    if (nTab != TABLEID_DOC)
+        bOk = pTabProtect->verifyPassword(rPassword);
+//  BOOL bOk = lcl_ValidPassword( pDoc, nTab, rPassword, &aOldPassword );
 	if ( bOk )
 	{
-		uno::Sequence<sal_Int8> aEmptyPass;
+//      Sequence<sal_Int8> aOldPassword = pTabProtect->getPasswordHash();
+        const String aOldPassword = pTabProtect->getPassword();
+
+        String aEmptyPass;
 		if ( nTab == TABLEID_DOC )
 			pDoc->SetDocProtection( FALSE, aEmptyPass );
 		else
 			pDoc->SetTabProtection( nTab, FALSE, aEmptyPass );
 
-		if (bUndo)
+		if (pDoc->IsUndoEnabled())
 		{
 			rDocShell.GetUndoManager()->AddUndoAction(
 						new ScUndoProtect( &rDocShell, nTab, FALSE, aOldPassword ) );
 		}
 
 		rDocShell.PostPaintGridAll();
+        ScDocShellModificator aModificator( rDocShell );
 		aModificator.SetDocumentModified();
 	}
 	else if (!bApi)
 	{
-//!		rDocShell.ErrorMessage(...);
-
 		InfoBox aBox( rDocShell.GetActiveDialogParent(), String( ScResId( SCSTR_WRONGPASSWORD ) ) );
 		aBox.Execute();
 	}
Index: sc/source/ui/docshell/docsh5.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/docshell/docsh5.cxx,v
retrieving revision 1.17
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.17 docsh5.cxx
--- sc/source/ui/docshell/docsh5.cxx	27 Feb 2007 13:07:51 -0000	1.17
+++ sc/source/ui/docshell/docsh5.cxx	22 Dec 2007 07:19:01 -0000
@@ -826,7 +826,7 @@
 				++nAdjSource;				// new position of source table after CopyTab
 
 			if ( aDocument.IsTabProtected( nAdjSource ) )
-				aDocument.SetTabProtection( nDestTab, TRUE, aDocument.GetTabPassword( nAdjSource ) );
+                aDocument.CopyTabProtection(nAdjSource, nDestTab);
 
 			if (bRecord)
 			{
Index: sc/source/ui/inc/undotab.hxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/inc/undotab.hxx,v
retrieving revision 1.9
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.9 undotab.hxx
--- sc/source/ui/inc/undotab.hxx	18 Oct 2006 12:28:14 -0000	1.9
+++ sc/source/ui/inc/undotab.hxx	22 Dec 2007 07:19:01 -0000
@@ -354,7 +354,7 @@
 public:
 					TYPEINFO();
 					ScUndoProtect( ScDocShell* pShell, SCTAB nNewTab,
-									BOOL bNewProtect, const com::sun::star::uno::Sequence<sal_Int8>& rNewPassword );
+									BOOL bNewProtect, const String& aNewPass );
 	virtual			~ScUndoProtect();
 
 	virtual void	Undo();
@@ -367,7 +367,7 @@
 private:
 	SCTAB	nTab;
 	BOOL	bProtect;
-	com::sun::star::uno::Sequence<sal_Int8>	aPassword;
+    String  aPassword;
 
 	void	DoProtect( BOOL bDo );
 };
Index: sc/source/ui/undo/undotab.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/undo/undotab.cxx,v
retrieving revision 1.16
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.16 undotab.cxx
--- sc/source/ui/undo/undotab.cxx	27 Feb 2007 13:39:54 -0000	1.16
+++ sc/source/ui/undo/undotab.cxx	22 Dec 2007 07:19:01 -0000
@@ -66,6 +66,7 @@
 #include "prnsave.hxx"
 #include "printfun.hxx"
 #include "chgtrack.hxx"
+#include "tabprotection.hxx"
 
 // for ScUndoRenameObject - might me moved to another file later
 #include <svx/svditer.hxx>
@@ -77,6 +78,7 @@
 extern BOOL bDrawIsInUndo;			//! irgendwo als Member !!!
 
 using namespace com::sun::star;
+using ::com::sun::star::uno::Sequence;
 
 // STATIC DATA -----------------------------------------------------------
 
@@ -419,7 +421,8 @@
             pDoc->SetVisible( nTab, pRefUndoDoc->IsVisible( nTab ) );
 
             if ( pRefUndoDoc->IsTabProtected( nTab ) )
-                pDoc->SetTabProtection( nTab, TRUE, pRefUndoDoc->GetTabPassword( nTab ) );
+                pDoc->SetTabProtection(nTab, pRefUndoDoc->GetTabProtection(nTab));
+//              pDoc->SetTabProtection( nTab, TRUE, pRefUndoDoc->GetTabPassword( nTab ) );
 
 			//	Drawing-Layer passiert beim MoveUndo::EndUndo
 	//		pDoc->TransferDrawPage(pRefUndoDoc, nTab,nTab);
@@ -761,7 +764,8 @@
 		}
 
 		if ( pDoc->IsTabProtected( nAdjSource ) )
-			pDoc->SetTabProtection( nNewTab, TRUE, pDoc->GetTabPassword( nAdjSource ) );
+            pDoc->CopyTabProtection(nAdjSource, nNewTab);
+//          pDoc->SetTabProtection( nNewTab, TRUE, pDoc->GetTabPassword( nAdjSource ) );
 	}
 
     RedoSdrUndoAction( pDrawUndo );             // after the sheets are inserted
@@ -947,7 +951,8 @@
 			}
 
 			if ( pDoc->IsTabProtected( nTabPos ) )
-				pRedoDoc->SetTabProtection( nTabPos, TRUE, pDoc->GetTabPassword( nTabPos ) );
+                pRedoDoc->SetTabProtection(nTabPos, pDoc->GetTabProtection(nTabPos));
+//              pRedoDoc->SetTabProtection( nTabPos, TRUE, pDoc->GetTabPassword( nTabPos ) );
 		}
 
 	}
@@ -1001,7 +1006,8 @@
 		}
 
 		if ( pRedoDoc->IsTabProtected( nTabPos ) )
-			pDoc->SetTabProtection( nTabPos, TRUE, pRedoDoc->GetTabPassword( nTabPos ) );
+            pDoc->SetTabProtection(nTabPos, pRedoDoc->GetTabProtection(nTabPos));
+//          pDoc->SetTabProtection( nTabPos, TRUE, pRedoDoc->GetTabPassword( nTabPos ) );
 	}
 
     RedoSdrUndoAction( pDrawUndo );     // after the sheets are inserted
@@ -1171,11 +1177,11 @@
 //
 
 ScUndoProtect::ScUndoProtect( ScDocShell* pShell, SCTAB nNewTab,
-							BOOL bNewProtect, const uno::Sequence<sal_Int8>& rNewPassword ) :
+							BOOL bNewProtect, const String& aNewPass ) :
 	ScSimpleUndo( pShell ),
 	nTab( nNewTab ),
 	bProtect( bNewProtect ),
-	aPassword( rNewPassword )
+	aPassword( aNewPass )
 {
 }
 
@@ -1190,13 +1196,16 @@
 	if (bDo)
 	{
 		if ( nTab == TABLEID_DOC )
+        {
+//          Sequence<sal_Int8> aPassHash = ScTableProtection::hashPassword(aPassword);
 			pDoc->SetDocProtection( TRUE, aPassword );
+        }
 		else
 			pDoc->SetTabProtection( nTab, TRUE, aPassword );
 	}
 	else
 	{
-		uno::Sequence<sal_Int8> aEmptyPass;
+        String aEmptyPass;
 		if ( nTab == TABLEID_DOC )
 			pDoc->SetDocProtection( FALSE, aEmptyPass );
 		else
Index: sc/source/ui/view/gridwin.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/gridwin.cxx,v
retrieving revision 1.87
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.87 gridwin.cxx
--- sc/source/ui/view/gridwin.cxx	26 Nov 2007 15:21:16 -0000	1.87
+++ sc/source/ui/view/gridwin.cxx	22 Dec 2007 07:19:02 -0000
@@ -138,6 +138,7 @@
 #include "compiler.hxx"
 #include "editable.hxx"
 #include "fillinfo.hxx"
+#include "tabprotection.hxx"
 
 // #114409#
 #ifndef _SV_SALBTYPE_HXX
@@ -2005,11 +2006,12 @@
 		Point aPos = rMEvt.GetPosPixel();
         SCsCOL nPosX;
         SCsROW nPosY;
+        SCTAB nTab = pViewData->GetTabNo();
         pViewData->GetPosFromPixel( aPos.X(), aPos.Y(), eWhich, nPosX, nPosY );
-		ScDPObject*	pDPObj	= pDoc->GetDPAtCursor( nPosX, nPosY, pViewData->GetTabNo() );
+		ScDPObject*	pDPObj	= pDoc->GetDPAtCursor( nPosX, nPosY, nTab );
 		if ( pDPObj && pDPObj->GetSaveData()->GetDrillDown() )
 		{
-			ScAddress aCellPos( nPosX, nPosY, pViewData->GetTabNo() );
+			ScAddress aCellPos( nPosX, nPosY, nTab );
 			ScDPPositionData aData;
 			pDPObj->GetPositionData( aData, aCellPos );
 
@@ -2046,6 +2048,23 @@
 			return;
 		}
 
+        // Check for cell protection attribute.
+        ScTableProtection* pProtect = pDoc->GetTabProtection( nTab );
+        bool bEditAllowed = true;
+        if ( pProtect && pProtect->isProtected() )
+        {
+            bool bCellProtected = pDoc->HasAttrib(nPosX, nPosY, nTab, nPosX, nPosY, nTab, HASATTR_PROTECTED);
+            bool bSkipProtected = !pProtect->isOptionEnabled(ScTableProtection::SELECT_LOCKED_CELLS);
+            bool bSkipUnprotected = !pProtect->isOptionEnabled(ScTableProtection::SELECT_UNLOCKED_CELLS);
+
+            if ( bSkipProtected && bSkipUnprotected )
+                bEditAllowed = false;
+            else if ( (bCellProtected && bSkipProtected) || (!bCellProtected && bSkipUnprotected) )
+                bEditAllowed = false;
+        }
+
+        if ( bEditAllowed )
+        {
 		//	edit cell contents
 		pViewData->GetViewShell()->UpdateInputHandler();
 		pScMod->SetInputMode( SC_INPUT_TABLE );
@@ -2056,9 +2075,10 @@
 			MouseEvent aEditEvt( rMEvt.GetPosPixel(), 1, MOUSE_SYNTHETIC, MOUSE_LEFT, 0 );
 			pEditView->MouseButtonDown( aEditEvt );
 			pEditView->MouseButtonUp( aEditEvt );
-            return;
 		}
 	}
+        return;
+	}
 
 			//
 			//		Links in edit cells
Index: sc/source/ui/view/select.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/select.cxx,v
retrieving revision 1.18
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.18 select.cxx
--- sc/source/ui/view/select.cxx	27 Feb 2007 13:56:10 -0000	1.18
+++ sc/source/ui/view/select.cxx	22 Dec 2007 07:19:03 -0000
@@ -52,6 +52,7 @@
 //#include "dataobj.hxx"
 #include "transobj.hxx"
 #include "docsh.hxx"
+#include "tabprotection.hxx"
 
 extern USHORT nScFillModeMouseModifier;				// global.cxx
 
@@ -327,6 +328,23 @@
 {
 	ScTabView* pView = pViewData->GetView();
 	SCTAB nTab = pViewData->GetTabNo();
+    ScDocument* pDoc = pViewData->GetDocument();
+
+    if ( pDoc->IsTabProtected(nTab) )
+    {
+        ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+        bool bSkipProtected   = !pProtect->isOptionEnabled(ScTableProtection::SELECT_LOCKED_CELLS);
+        bool bSkipUnprotected = !pProtect->isOptionEnabled(ScTableProtection::SELECT_UNLOCKED_CELLS);
+
+        if ( bSkipProtected && bSkipUnprotected )
+            return FALSE;
+
+        bool bCellProtected = pDoc->HasAttrib(nPosX, nPosY, nTab, nPosX, nPosY, nTab, HASATTR_PROTECTED);
+        if ( (bCellProtected && bSkipProtected) || (!bCellProtected && bSkipUnprotected) )
+            // Don't select this cell!
+            return FALSE;
+    }
+
 	ScModule* pScMod = SC_MOD();
 	BOOL bRefMode = pScMod->IsFormulaMode();
 
@@ -379,7 +397,6 @@
 
 		ScRange aDelRange;
 		BOOL bOldDelMark = pViewData->GetDelMark( aDelRange );
-		ScDocument* pDoc = pViewData->GetDocument();
 
 		if ( nPosX+1 >= (SCsCOL) nStartX && nPosX <= (SCsCOL) nEndX &&
 			 nPosY+1 >= (SCsROW) nStartY && nPosY <= (SCsROW) nEndY &&
@@ -515,7 +532,6 @@
 		BYTE nMode = pViewData->GetFillMode();
 		if ( nMode == SC_FILL_EMBED_LT || nMode == SC_FILL_EMBED_RB )
 		{
-			ScDocument* pDoc = pViewData->GetDocument();
 			DBG_ASSERT( pDoc->IsEmbedded(), "!pDoc->IsEmbedded()" );
             ScRange aRange;
 			pDoc->GetEmbedded( aRange);
Index: sc/source/ui/view/tabview3.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/tabview3.cxx,v
retrieving revision 1.62
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.62 tabview3.cxx
--- sc/source/ui/view/tabview3.cxx	21 Nov 2007 19:11:39 -0000	1.62
+++ sc/source/ui/view/tabview3.cxx	22 Dec 2007 07:19:03 -0000
@@ -84,6 +84,7 @@
 #include "AccessibilityHints.hxx"
 #include "rangeutl.hxx"
 #include "client.hxx"
+#include "tabprotection.hxx"
 
 #include <com/sun/star/chart2/data/HighlightedRange.hpp>
 
@@ -1024,6 +1025,17 @@
 	ScDocument* pDoc = aViewData.GetDocument();
 	SCTAB nTab = aViewData.GetTabNo();
 
+    bool bSkipProtected = false, bSkipUnprotected = false;
+    ScTableProtection* pProtect = pDoc->GetTabProtection(nTab);
+    if ( pProtect && pProtect->isProtected() )
+    {
+        bSkipProtected   = !pProtect->isOptionEnabled(ScTableProtection::SELECT_LOCKED_CELLS);
+        bSkipUnprotected = !pProtect->isOptionEnabled(ScTableProtection::SELECT_UNLOCKED_CELLS);
+    }
+
+    if ( bSkipProtected && bSkipUnprotected )
+        return;
+
 	SCsCOL nOldX;
 	SCsROW nOldY;
 	SCsCOL nCurX;
@@ -1043,7 +1055,7 @@
 		nCurY = (nMovY != 0) ? nOldY+nMovY : (SCsROW) aViewData.GetOldCurY();
 	}
 
-	BOOL bHidden;
+	BOOL bSkipCell = FALSE;
 	aViewData.ResetOldCursor();
 
 	if (nMovX != 0 && VALIDCOLROW(nCurX,nCurY))
@@ -1052,15 +1064,20 @@
 		do
 		{
 			BYTE nColFlags = pDoc->GetColFlags( nCurX, nTab );
-			bHidden = (nColFlags & CR_HIDDEN) || pDoc->IsHorOverlapped( nCurX, nCurY, nTab );
-			if (bHidden)
+            bSkipCell = (nColFlags & CR_HIDDEN) || pDoc->IsHorOverlapped( nCurX, nCurY, nTab );
+            if (bSkipProtected && !bSkipCell)
+                bSkipCell = pDoc->HasAttrib(nCurX, nCurY, nTab, nCurX, nCurY, nTab, HASATTR_PROTECTED);
+            if (bSkipUnprotected && !bSkipCell)
+                bSkipCell = !pDoc->HasAttrib(nCurX, nCurY, nTab, nCurX, nCurY, nTab, HASATTR_PROTECTED);
+
+			if (bSkipCell)
 			{
 				if ( nCurX<=0 || nCurX>=MAXCOL )
 				{
 					if (bHFlip)
 					{
 						nCurX = nOldX;
-						bHidden = FALSE;
+						bSkipCell = FALSE;
 					}
 					else
 					{
@@ -1073,7 +1090,8 @@
 					if (nMovX > 0) ++nCurX; else --nCurX;
 			}
 		}
-		while (bHidden);
+		while (bSkipCell);
+
 		if (pDoc->IsVerOverlapped( nCurX, nCurY, nTab ))
 		{
 			aViewData.SetOldCursor( nCurX,nCurY );
@@ -1088,15 +1106,20 @@
 		do
 		{
 			BYTE nRowFlags = pDoc->GetRowFlags( nCurY, nTab );
-			bHidden = (nRowFlags & CR_HIDDEN) || pDoc->IsVerOverlapped( nCurX, nCurY, nTab );
-			if (bHidden)
+            bSkipCell = (nRowFlags & CR_HIDDEN) || pDoc->IsVerOverlapped( nCurX, nCurY, nTab );
+            if (bSkipProtected && !bSkipCell)
+                bSkipCell = pDoc->HasAttrib(nCurX, nCurY, nTab, nCurX, nCurY, nTab, HASATTR_PROTECTED);
+            if (bSkipUnprotected && !bSkipCell)
+                bSkipCell = !pDoc->HasAttrib(nCurX, nCurY, nTab, nCurX, nCurY, nTab, HASATTR_PROTECTED);
+
+			if (bSkipCell)
 			{
 				if ( nCurY<=0 || nCurY>=MAXROW )
 				{
 					if (bVFlip)
 					{
 						nCurY = nOldY;
-						bHidden = FALSE;
+						bSkipCell = FALSE;
 					}
 					else
 					{
@@ -1109,7 +1132,8 @@
 					if (nMovY > 0) ++nCurY; else --nCurY;
 			}
 		}
-		while (bHidden);
+		while (bSkipCell);
+
 		if (pDoc->IsHorOverlapped( nCurX, nCurY, nTab ))
 		{
 			aViewData.SetOldCursor( nCurX,nCurY );
Index: sc/source/ui/view/tabvwsh3.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/tabvwsh3.cxx,v
retrieving revision 1.36
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.36 tabvwsh3.cxx
--- sc/source/ui/view/tabvwsh3.cxx	21 Nov 2007 19:12:15 -0000	1.36
+++ sc/source/ui/view/tabvwsh3.cxx	22 Dec 2007 07:19:03 -0000
@@ -36,7 +36,7 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_sc.hxx"
 
-
+#include <stdio.h>
 
 // INCLUDE ---------------------------------------------------------------
 
@@ -80,6 +80,7 @@
 #include "autofmt.hxx"
 #include "dwfunctr.hxx"
 #include "shtabdlg.hxx"
+#include "tabprotection.hxx"
 
 #include <svtools/ilstitem.hxx>
 #define _SVSTDARR_ULONGS
@@ -1010,6 +1011,7 @@
 
 		case FID_PROTECT_TABLE:
 			{
+                fprintf(stdout, "ScTabViewShell::Execute: FID_PROTECT_TABLE\n");fflush(stdout);
 				ScDocument* 		pDoc = GetViewData()->GetDocument();
 				SCTAB				nTab = GetViewData()->GetTabNo();
 				SfxPasswordDialog*	pDlg;
@@ -1032,7 +1034,7 @@
 
                     if ( bOldProtection)
                     {
-                        if (pDoc->GetTabPassword(nTab).getLength())
+                        if (pDoc->GetTabProtection(nTab)->isProtectedWithPass())
                         {
                             String  aText( ScResId(SCSTR_PASSWORD) );
 
Index: sc/source/ui/view/viewfun2.cxx
===================================================================
RCS file: /cvs/sc/sc/source/ui/view/viewfun2.cxx,v
retrieving revision 1.35
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.35 viewfun2.cxx
--- sc/source/ui/view/viewfun2.cxx	31 Jul 2007 16:38:18 -0000	1.35
+++ sc/source/ui/view/viewfun2.cxx	22 Dec 2007 07:19:03 -0000
@@ -2143,7 +2143,8 @@
 			pUndoDoc->SetVisible( nTab, pDoc->IsVisible( nTab ) );
 
 			if ( pDoc->IsTabProtected( nTab ) )
-				pUndoDoc->SetTabProtection( nTab, TRUE, pDoc->GetTabPassword( nTab ) );
+                pUndoDoc->SetTabProtection(nTab, pDoc->GetTabProtection(nTab));
+//              pUndoDoc->SetTabProtection( nTab, TRUE, pDoc->GetTabPassword( nTab ) );
 
 			//	Drawing-Layer muss sein Undo selbst in der Hand behalten !!!
 			//		pUndoDoc->TransferDrawPage(pDoc, nTab,nTab);
@@ -2558,7 +2559,8 @@
 				}
 
 				if ( nErrVal > 0 && pDoc->IsTabProtected( TheTabs[i] ) )
-					pDestDoc->SetTabProtection( nDestTab1, TRUE, pDoc->GetTabPassword( TheTabs[i] ) );
+                    pDestDoc->SetTabProtection(nDestTab1, pDoc->GetTabProtection(TheTabs[i]));
+//                  pDestDoc->SetTabProtection( nDestTab1, TRUE, pDoc->GetTabPassword( TheTabs[i] ) );
 
 				nDestTab1++;
 			}
? svx/svx.vpj
Index: svx/inc/mscodec.hxx
===================================================================
RCS file: /cvs/graphics/svx/inc/mscodec.hxx,v
retrieving revision 1.4
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.4 mscodec.hxx
--- svx/inc/mscodec.hxx	8 Sep 2005 18:04:23 -0000	1.4
+++ svx/inc/mscodec.hxx	22 Dec 2007 07:19:15 -0000
@@ -247,6 +247,10 @@
      */
     bool                InitCipher( sal_uInt32 nCounter );
 
+    bool                Encode(
+                            const void* pData, sal_Size nDatLen,
+                            sal_uInt8* pBuffer, sal_Size nBufLen );
+
     /** Decodes a block of memory.
 
         @see rtl_cipher_decode()
Index: svx/source/msfilter/mscodec.cxx
===================================================================
RCS file: /cvs/graphics/svx/source/msfilter/mscodec.cxx,v
retrieving revision 1.5
diff -u -b -I $Revision.*$ -I $Author.*$ -r1.5 mscodec.cxx
--- svx/source/msfilter/mscodec.cxx	12 Oct 2006 12:58:20 -0000	1.5
+++ svx/source/msfilter/mscodec.cxx	22 Dec 2007 07:19:15 -0000
@@ -44,6 +44,8 @@
 #include <algorithm>
 #include <tools/solar.h>
 
+#include <stdio.h>
+
 namespace svx {
 
 // ============================================================================
@@ -248,15 +250,36 @@
     rtl_cipher_destroy (m_hCipher);
 }
 
+static void lcl_PrintKeyData(const sal_uInt8* pKeyData, const char* msg)
+{
+    printf("pKeyData: (%s)\n", msg);
+    for (int j = 0; j < 4; ++j)
+    {
+        for (int i = 0; i < 16; ++i)
+            printf("%2.2x ", pKeyData[j*16+i]);
+        printf("\n");
+    }
+}
+
+static void lcl_PrintDigest(const sal_uInt8* pDigest)
+{
+    printf("digest:\n");
+    for (int i = 0; i < 16; ++i)
+        printf("%2.2x ", pDigest[i]);
+    printf("\n");
+}
+
 void MSCodec_Std97::InitKey (
     const sal_uInt16 pPassData[16],
     const sal_uInt8  pUnique[16])
 {
+    fprintf(stdout, "MSCodec_Std97::InitKey: --begin\n");fflush(stdout);
     sal_uInt8 pKeyData[64];
     int       i, n;
 
     // Fill PassData into KeyData.
     (void)memset (pKeyData, 0, sizeof(pKeyData));
+    lcl_PrintKeyData(pKeyData, "initial");
     for (i = 0, n = 16; (i < n) && pPassData[i]; i++)
     {
         pKeyData[2*i    ] = sal::static_int_cast< sal_uInt8 >(
@@ -267,12 +290,16 @@
     pKeyData[2*i] = 0x80;
     pKeyData[ 56] = sal::static_int_cast< sal_uInt8 >(i << 4);
 
+    lcl_PrintKeyData(pKeyData, "password data");
+
     // Fill raw digest of KeyData into KeyData.
     (void)rtl_digest_updateMD5 (
         m_hDigest, pKeyData, sizeof(pKeyData));
     (void)rtl_digest_rawMD5 (
         m_hDigest, pKeyData, RTL_DIGEST_LENGTH_MD5);
 
+    lcl_PrintKeyData(pKeyData, "raw digest of key data");
+
     // Update digest with KeyData and Unique.
     for (i = 0; i < 16; i++)
     {
@@ -286,6 +313,8 @@
     pKeyData[56] = 0x80;
     pKeyData[57] = 0x0a;
 
+    lcl_PrintKeyData(pKeyData, "update digest with padding");
+
     rtl_digest_updateMD5 (
         m_hDigest, &(pKeyData[16]), sizeof(pKeyData) - 16);
 
@@ -293,6 +322,8 @@
     rtl_digest_rawMD5 (
         m_hDigest, m_pDigestValue, sizeof(m_pDigestValue));
 
+    lcl_PrintDigest(m_pDigestValue);
+
     // Erase KeyData array and leave.
     (void)memset (pKeyData, 0, sizeof(pKeyData));
 }
@@ -301,6 +332,9 @@
     const sal_uInt8 pSaltData[16],
     const sal_uInt8 pSaltDigest[16])
 {
+    // both the salt data and salt digest (hash) come from the document being imported.
+
+    fprintf(stdout, "MSCodec_Std97::VerifyKey: \n");fflush(stdout);
     bool result = false;
 
     if (InitCipher(0))
@@ -312,6 +346,18 @@
         rtl_cipher_decode (
             m_hCipher, pSaltData, 16, pBuffer, sizeof(pBuffer));
 
+        fprintf(stdout, "salt:\n");
+        for (int i = 0; i < 16; ++i)
+            fprintf(stdout, "%2.2x ", pSaltData[i]);
+        fprintf(stdout, "\n");
+        fprintf(stdout, "decoded salt:\n");
+        for (int i = 0; i < 4; ++i)
+        {
+            for (int j = 0; j < 16; ++j)
+                fprintf(stdout, "%2.2x ", pBuffer[i*16+j]);
+            fprintf(stdout, "\n");
+        }
+
         pBuffer[16] = 0x80;
         (void)memset (pBuffer + 17, 0, sizeof(pBuffer) - 17);
         pBuffer[56] = 0x80;
@@ -322,6 +368,11 @@
         rtl_digest_rawMD5 (
             m_hDigest, pDigest, sizeof(pDigest));
 
+        printf("raw digest:\n");
+        for (int i = 0; i < 16; ++i)
+            printf("%2.2x ", pDigest[i]);
+        printf("\n");
+
         // Decode original SaltDigest into Buffer.
         rtl_cipher_decode (
             m_hCipher, pSaltDigest, 16, pBuffer, sizeof(pBuffer));
@@ -339,8 +390,9 @@
 
 bool MSCodec_Std97::InitCipher (sal_uInt32 nCounter)
 {
+    fprintf(stdout, "MSCodec_Std97::InitCipher: \n");fflush(stdout);
     rtlCipherError result;
-    sal_uInt8      pKeyData[64];
+    sal_uInt8      pKeyData[64]; // 512-bit message block
 
     // Initialize KeyData array.
     (void)memset (pKeyData, 0, sizeof(pKeyData));
@@ -365,7 +417,7 @@
 
     // Initialize Cipher with KeyData (for decoding).
     result = rtl_cipher_init (
-        m_hCipher, rtl_Cipher_DirectionDecode,
+        m_hCipher, rtl_Cipher_DirectionBoth,
         pKeyData, RTL_DIGEST_LENGTH_MD5, 0, 0);
 
     // Erase KeyData array and leave.
@@ -374,6 +426,17 @@
     return (result == rtl_Cipher_E_None);
 }
 
+bool MSCodec_Std97::Encode(
+    const void *pData,   sal_Size nDatLen,
+    sal_uInt8  *pBuffer, sal_Size nBufLen)
+{
+    rtlCipherError result;
+    result = rtl_cipher_encode (
+        m_hCipher, pData, nDatLen, pBuffer, nBufLen);
+
+    return (result == rtl_Cipher_E_None);
+}
+
 bool MSCodec_Std97::Decode (
     const void *pData,   sal_Size nDatLen,
     sal_uInt8  *pBuffer, sal_Size nBufLen)
@@ -388,6 +451,7 @@
 
 bool MSCodec_Std97::Skip( sal_Size nDatLen )
 {
+    fprintf(stdout, "MSCodec_Std97::Skip: \n");fflush(stdout);
     sal_uInt8 pnDummy[ 1024 ];
     sal_Size nDatLeft = nDatLen;
     bool bResult = true;
