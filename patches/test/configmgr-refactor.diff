diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/accessor.cxx configmgr/source/data/accessor.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/accessor.cxx	2006-06-20 00:22:07.000000000 +0100
+++ configmgr/source/data/accessor.cxx	2006-10-04 11:35:13.000000000 +0100
@@ -55,20 +55,13 @@
         : m_segment(segment)
         , m_refs(1)
         {
-            void const * base = m_segment ? m_segment->acquireReadAccess() : NULL;
-            m_base = static_cast<char const *>(base);
-        }
-    // -------------------------------------------------------------------------
-        Accessor::Impl::Impl(Segment const * segment, void const * base)
-        : m_segment(segment)
-        , m_base(static_cast<char const *>(base))
-        , m_refs(1)
-        {
+	    if (m_segment)
+		m_segment->acquireReadAccess();
         }
     // -------------------------------------------------------------------------
         Accessor::Impl::~Impl()
         {
-            if (m_segment) m_segment->releaseReadAccess(m_base);
+            if (m_segment) m_segment->releaseReadAccess();
         }
     // -------------------------------------------------------------------------
          /// Copies an Accessor
@@ -90,42 +83,12 @@
         {
             if (m_impl->is()) 
             {
-                Impl * pNewImpl = new Impl(0,0);
+                Impl * pNewImpl = new Impl(0);
                 releaseImpl();
                 m_impl = pNewImpl;
             }
             OSL_POSTCOND(!this->is(),"Accessor::clear: Could not clear");
         }
-
-    // -------------------------------------------------------------------------
-        void * Accessor::failNull()
-        {
-            OSL_ENSURE(false,"Unexpected NULL Address or Accessor");
-            return NULL;
-        }
-    // -------------------------------------------------------------------------
-
-    #if OSL_DEBUG_LEVEL > 0
-        void const * Accessor::resolve(AddressType _p) const 
-        { 
-            OSL_ENSURE( !_p.is() || segment_()->isValidAddress(_p.value()), "Address does not belong to this segment");
-            return _p.is() ? base_() + _p.value() : NULL; 
-        }
-
-        Pointer  Accessor::reduce(void const * _p) const
-        {
-            if (_p)
-            {
-                Pointer::RawAddress addr = static_cast<char const *>(_p) - base_();
-                OSL_ENSURE( segment_()->isValidAddress(addr), "Pointer does not belong to this segment");
-                return Pointer(addr); 
-            }
-            else
-                return Pointer();
-        }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/anydata.cxx configmgr/source/data/anydata.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/anydata.cxx	2006-06-20 00:22:20.000000000 +0100
+++ configmgr/source/data/anydata.cxx	2006-10-04 12:35:54.000000000 +0100
@@ -58,7 +58,6 @@
         namespace Type = data::Type;
         namespace uno = ::com::sun::star::uno;
         typedef AnyData::TypeCode TypeCode;
-        using memory::Pointer;
 //-----------------------------------------------------------------------------	
 
 TypeCode getTypeCode(uno::Type const & _aType)
@@ -197,7 +196,7 @@
 //-----------------------------------------------------------------------------	
 
 static
-AnyData allocSimpleData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, uno::Any const & _aAny)
+AnyData allocSimpleData(TypeCode _aSimpleType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -210,7 +209,7 @@
         {
             rtl::OUString sValue;
             OSL_VERIFY(_aAny >>= sValue );
-            aResult.stringValue = allocString(_anAllocator,sValue);
+            aResult.stringValue = allocString(sValue);
         }
         break;
 
@@ -231,9 +230,7 @@
             sal_Int64 nValue;
             OSL_VERIFY(_aAny >>= nValue);
 
-            Address aStorage = _anAllocator.allocate( sizeof nValue );
-            *static_cast<sal_Int64*>( _anAllocator.access(aStorage) ) = nValue;
-            aResult.longValue = aStorage;
+            aResult.longValue = Address( new sal_Int64( nValue ) );
         }
         break;
 
@@ -242,9 +239,7 @@
             double dValue;
             OSL_VERIFY(_aAny >>= dValue);
 
-            Address aStorage = _anAllocator.allocate( sizeof dValue );
-            *static_cast<double*>( _anAllocator.access(aStorage) ) = dValue;
-            aResult.doubleValue = aStorage;
+            aResult.doubleValue = Address( new double( dValue ) );
         }
         break;
 
@@ -252,7 +247,7 @@
         {
             uno::Sequence<sal_Int8> aValue;
             OSL_VERIFY(_aAny >>= aValue);
-            aResult.binaryValue = allocBinary(_anAllocator,aValue);
+            aResult.binaryValue = allocBinary(aValue);
         }
         break;
 
@@ -287,7 +282,7 @@
 //-----------------------------------------------------------------------------	
 
 static
-AnyData allocSequenceData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, uno::Any const & _aAny)
+AnyData allocSequenceData(TypeCode _aSimpleType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -299,7 +294,7 @@
         {
             uno::Sequence<rtl::OUString> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -307,7 +302,7 @@
         {
             uno::Sequence<sal_Bool> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -315,7 +310,7 @@
         {
             uno::Sequence<sal_Int16> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -323,7 +318,7 @@
         {
             uno::Sequence<sal_Int32> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -331,7 +326,7 @@
         {
             uno::Sequence<sal_Int64> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -339,7 +334,7 @@
         {
             uno::Sequence<double> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -347,7 +342,7 @@
         {
             uno::Sequence<uno::Sequence<sal_Int8> > aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -363,35 +358,29 @@
 }
 //-----------------------------------------------------------------------------	
 
-AnyData allocData(memory::Allocator const& _anAllocator, TypeCode _aType, uno::Any const & _aAny)
+AnyData allocData(TypeCode _aType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
     OSL_ENSURE( _aType == getTypeCode(_aAny.getValueType()), "Type code does not match value" );
 
     if (_aType & Type::flag_sequence)
-        return allocSequenceData(_anAllocator,TypeCode( _aType & Type::mask_basetype),_aAny);
+        return allocSequenceData(TypeCode( _aType & Type::mask_basetype),_aAny);
 
     else
-        return allocSimpleData(_anAllocator,_aType,_aAny);
+        return allocSimpleData(_aType,_aAny);
 }
-//-----------------------------------------------------------------------------	
-/*
-AnyData copyData(memory::Allocator const& _anAllocator, TypeCode _aType, AnyData _aData)
-{
-    OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
-}
-*/
+
 //-----------------------------------------------------------------------------	
 
 static
-void freeSimpleData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, AnyData const & _aData)
+void freeSimpleData(TypeCode _aSimpleType, AnyData const & _aData)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
     switch (_aSimpleType)
     {
     case Type::value_string:
-        freeString(_anAllocator, _aData.stringValue);
+        freeString(_aData.stringValue);
         break;
 
     case Type::value_boolean:
@@ -402,15 +391,15 @@
 
         // free memory for oversized values
     case Type::value_long:
-        _anAllocator.deallocate(_aData.longValue);
+        delete (sal_uInt64 *)_aData.longValue;
         break;
 
     case Type::value_double:
-        _anAllocator.deallocate(_aData.doubleValue);
+        delete (double *)_aData.doubleValue;
         break;
 
     case Type::value_binary:
-        freeBinary(_anAllocator, _aData.binaryValue);
+        freeBinary(_aData.binaryValue);
         break;
 
     case Type::value_any: 
@@ -424,15 +413,15 @@
 }
 //-----------------------------------------------------------------------------	
 
-void    freeData(memory::Allocator const& _anAllocator, TypeCode _aType, AnyData _aData)
+void    freeData(TypeCode _aType, AnyData _aData)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
 
     if (_aType & Type::flag_sequence)
-        freeSequence(_anAllocator,TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
+        freeSequence(TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
 
     else
-        freeSimpleData(_anAllocator,_aType,_aData);
+        freeSimpleData(_aType,_aData);
 }
 //-----------------------------------------------------------------------------	
 
@@ -445,7 +434,7 @@
     {
     case Type::value_string:
         {
-            rtl::OUString sValue = readString(_anAccessor,_aData.stringValue);
+            rtl::OUString sValue = readString(_aData.stringValue);
             return uno::makeAny(sValue);
         }
 
@@ -459,18 +448,10 @@
         return uno::makeAny( _aData.intValue );
 
     case Type::value_long:
-        {
-            void const * pStorage = _anAccessor.validate( Pointer(_aData.longValue) );
-            sal_Int64 const * pValue = static_cast<sal_Int64 const *>(pStorage);
-            return uno::makeAny( *pValue );
-        }
+	return uno::makeAny( *(sal_Int64 const *)_aData.longValue );
 
     case Type::value_double:
-        {
-            void const * pStorage = _anAccessor.validate( Pointer(_aData.doubleValue) );
-            double const * pValue = static_cast<double const *>(pStorage);
-            return uno::makeAny( *pValue );
-        }
+	return uno::makeAny( *(double const *)_aData.doubleValue );
 
     case Type::value_binary:
         {
Only in configmgr/source/data: anydata.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/heap.cxx configmgr/source/data/heap.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/heap.cxx	2005-09-08 04:39:13.000000000 +0100
+++ configmgr/source/data/heap.cxx	2006-10-03 17:35:20.000000000 +0100
@@ -39,61 +39,5 @@
 #include <osl/diagnose.h>
 #endif
 
-// -----------------------------------------------------------------------------	
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        const Heap::Size c_nDefaultSize = 4096;
-    // -------------------------------------------------------------------------
-        Heap::Heap(HeapManager& _impl)
-        : m_impl(_impl)
-        , m_heap(_impl.createHeap(c_nDefaultSize))
-        , m_size(c_nDefaultSize)
-        {
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Heap(HeapManager& _impl, Size _nInitialSize)
-        : m_impl(_impl)
-        , m_heap(_impl.createHeap(_nInitialSize))
-        , m_size(_nInitialSize)
-        {
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Heap(HeapManager& _impl, HeapId const & _anId)
-        : m_impl(_impl)
-        , m_size(0)
-        {
-            m_heap = _impl.attachHeap(_anId,m_size);
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::~Heap()
-        {
-            m_impl.destroyHeap(m_heap);
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Size Heap::grow(Size _nReqSize) // returns the (possibly new) base
-        {
-            Size nNewSize = m_impl.growHeap(m_heap, _nReqSize);
-
-            if (nNewSize)
-            {
-                OSL_ENSURE(nNewSize >= _nReqSize, "Error: Heapmanager returns invalid size from grow method");
-                m_size = nNewSize;
-            }
-
-            return nNewSize;
-        }
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
 
 
Only in configmgr/source/data: heap.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/segmentheap.cxx configmgr/source/data/segmentheap.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/segmentheap.cxx	2005-09-08 04:39:41.000000000 +0100
+++ configmgr/source/data/segmentheap.cxx	2006-10-04 13:07:31.000000000 +0100
@@ -33,73 +33,3 @@
  *
  ************************************************************************/
 
-#include "segmentheap.hxx"
-
-#ifndef _OSL_DIAGNOSE_H_
-#include <osl/diagnose.h>
-#endif
-
-// -----------------------------------------------------------------------------	
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        const Heap::Size c_nMaxHeapSize = 0x40000000;
-        const Heap::Size c_nGrowFactor  = 2;
-
-    // -------------------------------------------------------------------------
-
-        SegmentHeap::~SegmentHeap()
-        {
-            m_heap.destroyLock(m_lock);
-        }
-    // -------------------------------------------------------------------------
-
-        void SegmentHeap::init()
-        {
-            m_lock = m_heap.createLock();
-            m_base = m_heap.base();
-
-            OSL_ENSURE(m_lock,"Could not create heap lock");
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Address SegmentHeap::allocateMore(Size _sz)
-        {
-            Size nCurSize = m_heap.size();
-
-            OSL_ENSURE(_sz <= c_nMaxHeapSize,"Cannot allocate: Allocation request too large");
-            if (_sz > c_nMaxHeapSize) return 0;
-
-            Size nCurSizeLimit = (c_nMaxHeapSize-_sz)/c_nGrowFactor;
-            OSL_ENSURE(nCurSize < nCurSizeLimit,"Allocation will reach heap limit");
-
-            Size nNewSize = (nCurSize < nCurSizeLimit ) 
-                                ? nCurSize * c_nGrowFactor + _sz 
-                                : c_nMaxHeapSize;
-
-            if (m_heap.grow(nNewSize))
-            {
-                m_base = m_heap.base();
-
-                Address aResult = m_heap.allocate(_sz);
-
-                OSL_ENSURE(aResult,"Cannot allocate even after growing heap");
-
-                return aResult;
-            }
-            else
-            {
-                OSL_ENSURE(false,"Cannot allocate: Heap could not be grown");
-                return 0;
-            }
-        }
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-
Only in configmgr/source/data: segmentheap.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/sequence.cxx configmgr/source/data/sequence.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/sequence.cxx	2006-06-20 00:22:33.000000000 +0100
+++ configmgr/source/data/sequence.cxx	2006-10-04 12:36:09.000000000 +0100
@@ -61,9 +61,7 @@
         namespace Type = data::Type;
         namespace uno = ::com::sun::star::uno;
         typedef AnyData::TypeCode TypeCode;
-        using memory::Allocator;
         using memory::Accessor;
-        using memory::Pointer;
 //-----------------------------------------------------------------------------	
 static 
 sal_uInt32 implGetElementSize(TypeCode _aElementType)
@@ -105,32 +103,20 @@
 //-----------------------------------------------------------------------------	
 static 
 inline
-sal_Int32& implGetSize(Allocator const& _anAllocator, Sequence _aSeq)
+sal_Int32& implGetSize(Sequence _aSeq)
 {
-    OSL_ASSERT(_aSeq != 0);
-    void * pBase = _anAllocator.access(_aSeq);
-    return * static_cast<sal_Int32 *>(pBase);
+    return * (sal_Int32 *) _aSeq;
 }
 
 //-----------------------------------------------------------------------------	
 static 
-inline
-sal_Int32 implGetSize(Accessor const& _anAccessor, Sequence _aSeq)
-{
-    OSL_ASSERT(_aSeq != 0);
-    void const * pBase = _anAccessor.access( Pointer(_aSeq) );
-    return * static_cast<sal_Int32 const *>(pBase);
-}
-
-//-----------------------------------------------------------------------------	
-static 
-Sequence implSeqAlloc(Allocator const& _anAllocator, sal_Int32 _nElements, sal_uInt32 _nElemSize)
+Sequence implSeqAlloc(sal_Int32 _nElements, sal_uInt32 _nElemSize)
 {
     sal_uInt32 nTotalSize = implGetHeaderSize(_nElemSize) + _nElements * _nElemSize;
 
-    Sequence aResult = _anAllocator.allocate(nTotalSize);
+    Sequence aResult = (Sequence) (new sal_uInt8[nTotalSize]);
 
-    implGetSize(_anAllocator,aResult) = _nElements;
+    implGetSize(aResult) = _nElements;
 
     return aResult;
 }
@@ -138,7 +124,7 @@
 //-----------------------------------------------------------------------------	
 
 static
-void allocSeqData(Allocator const& _anAllocator, Address _aDestAddr, 
+void allocSeqData(Address _aDestAddr, 
                  TypeCode _aElementType, 
                  sal_Int32 _nElements, sal_uInt32 _nElementSize, 
                  void const * _pSourceData)
@@ -152,7 +138,7 @@
     case Type::value_int:
     case Type::value_long:
     case Type::value_double:
-        ::memcpy(_anAllocator.access(_aDestAddr),_pSourceData,_nElements * _nElementSize);
+        ::memcpy(_aDestAddr,_pSourceData,_nElements * _nElementSize);
         break;
 
     case Type::value_string: 
@@ -163,9 +149,9 @@
 
             while (--_nElements >= 0)
             {
-                String aElement = allocString(_anAllocator,*pSource);
+                String aElement = allocString(*pSource);
 
-                String * pDest = static_cast<String*>( _anAllocator.access(_aDestAddr) );
+                String * pDest = (String *)( _aDestAddr );
                 *pDest = aElement;
                 
                 ++pSource;
@@ -183,9 +169,9 @@
 
             while (--_nElements >= 0)
             {
-                Vector aElement = allocBinary(_anAllocator,*pSource);
+                Vector aElement = allocBinary(*pSource);
 
-                Vector * pDest = static_cast<Vector*>( _anAllocator.access(_aDestAddr) );
+                Vector * pDest = (Vector *) _aDestAddr;
                 *pDest = aElement;
                 
                 ++pSource;
@@ -202,7 +188,7 @@
 }
 
 //-----------------------------------------------------------------------------	
-Sequence allocSequence(Allocator const& _anAllocator, TypeCode _aElementType, ::sal_Sequence const * _pSeqData)
+Sequence allocSequence(TypeCode _aElementType, ::sal_Sequence const * _pSeqData)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -215,10 +201,10 @@
     sal_uInt32 const nElementSize = implGetElementSize(_aElementType);
     sal_Int32  const nElements = _pSeqData->nElements;
 
-    Sequence aResult = implSeqAlloc(_anAllocator,nElements,nElementSize);
+    Sequence aResult = implSeqAlloc(nElements,nElementSize);
 
     if (aResult)
-        allocSeqData( _anAllocator, aResult + implGetHeaderSize(nElementSize), 
+        allocSeqData( aResult + implGetHeaderSize(nElementSize), 
                         _aElementType, nElements, nElementSize,
                         _pSeqData->elements);
 
@@ -226,31 +212,25 @@
 }
 
 //-----------------------------------------------------------------------------	
-Sequence allocBinary(Allocator const& _anAllocator, uno::Sequence<sal_Int8> const & _aBinaryValue)
+Sequence allocBinary(uno::Sequence<sal_Int8> const & _aBinaryValue)
 {
     sal_uInt32 const nElementSize = 1;
     sal_Int32  const nLength = _aBinaryValue.getLength();
 
-    Sequence aResult = implSeqAlloc(_anAllocator,nLength,nElementSize);
+    Sequence aResult = implSeqAlloc(nLength,nElementSize);
 
     if (aResult)
     {
         Address aElementBaseAddr = aResult + implGetHeaderSize(nElementSize);
-        ::memcpy(_anAllocator.access(aElementBaseAddr), _aBinaryValue.getConstArray(), nLength);
+        ::memcpy(aElementBaseAddr, _aBinaryValue.getConstArray(), nLength);
     }
 
     return aResult;
 }
 
 //-----------------------------------------------------------------------------	
-// Sequence copySequence(Allocator const& _anAllocator, TypeCode _aElementType, Sequence _aSeq)
-
-//-----------------------------------------------------------------------------	
-// Sequence copyBinary(Allocator const& _anAllocator, Sequence _aSeq)
-
-//-----------------------------------------------------------------------------	
 static
-void freeSeqData(Allocator const& _anAllocator, Address _aDataAddr, 
+void freeSeqData(Address _aDataAddr, 
                  TypeCode _aElementType, sal_Int32 _nElements)
 {
     OSL_ASSERT(_aElementType == (_aElementType & Type::mask_basetype));
@@ -267,22 +247,22 @@
 
     case Type::value_string: 
         {
-            String * pElements = static_cast<String*>( _anAllocator.access(_aDataAddr) );
+            String * pElements = (String *)_aDataAddr;
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
-                freeString(_anAllocator,pElements[i]);
+                freeString(pElements[i]);
             }
         }
         break;
 
     case Type::value_binary:
         {
-            Vector * pElements = static_cast<Vector*>( _anAllocator.access(_aDataAddr) );
+            Vector * pElements = (Vector *)_aDataAddr;
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
-                freeBinary(_anAllocator,pElements[i]);
+                freeBinary(pElements[i]);
             }
         }
         break;
@@ -295,7 +275,7 @@
 }
 
 //-----------------------------------------------------------------------------	
-void freeSequence(Allocator const& _anAllocator, TypeCode _aElementType, Sequence _aSeq)
+void freeSequence(TypeCode _aElementType, Sequence _aSeq)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -307,18 +287,18 @@
 
     sal_uInt32 nHeaderSize = implGetHeaderSize( implGetElementSize( _aElementType ) );
 
-    freeSeqData(_anAllocator,_aSeq + nHeaderSize, _aElementType, implGetSize(_anAllocator,_aSeq));
+    freeSeqData(_aSeq + nHeaderSize, _aElementType, implGetSize(_aSeq));
 
-    _anAllocator.deallocate(_aSeq);
+    delete[] (sal_uInt8 *)_aSeq;
 }
 
 //-----------------------------------------------------------------------------	
-void freeBinary(memory::Allocator const& _anAllocator, Sequence _aSeq)
+void freeBinary(Sequence _aSeq)
 {
     OSL_ENSURE(_aSeq, "ERROR: Trying to free a NULL sequence");
     if (_aSeq == 0) return;
 
-    _anAllocator.deallocate(_aSeq);
+    delete[] (sal_uInt8 *)_aSeq;
 }
 
 //-----------------------------------------------------------------------------	
@@ -343,7 +323,7 @@
 {
     OSL_ASSERT(_aElementType == (_aElementType & Type::mask_basetype));
 
-    void const * pElementData = _anAccessor.validate( Pointer(_aDataAddr) );
+    void const * pElementData = (void const *)_aDataAddr;
     switch (_aElementType)
     {
     case Type::value_boolean:
@@ -361,9 +341,7 @@
             String const * pElements = static_cast<String const *>( pElementData );
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
-            {
-                pResult[i] = readString(_anAccessor,pElements[i]);
-            }
+                pResult[i] = readString(pElements[i]);
 
             sal_Sequence * pRet = aResult.get();
             ++pRet->nRefCount;
@@ -410,7 +388,8 @@
 
     sal_uInt32 nHeaderSize = implGetHeaderSize( implGetElementSize( _aElementType ) );
 
-    return readSeqData(_anAccessor,_aSeq + nHeaderSize, _aElementType, implGetSize(_anAccessor,_aSeq));
+    // URG - accidentally removed an accessor instead of an allocator ... :-)
+    return readSeqData(_anAccessor,_aSeq + nHeaderSize, _aElementType, implGetSize(_aSeq));
 }
 
 //-----------------------------------------------------------------------------	
@@ -484,20 +463,13 @@
 }
 
 //-----------------------------------------------------------------------------	
-uno::Sequence<sal_Int8> readBinary(Accessor const& _anAccessor, Sequence _aSeq)
+uno::Sequence<sal_Int8> readBinary(Accessor const&, Sequence _aSeq)
 {
     OSL_ENSURE(_aSeq, "ERROR: Trying to read from a NULL sequence");
     if (_aSeq == 0) return uno::Sequence<sal_Int8>();
 
-    sal_Int32 const nElements = implGetSize(_anAccessor,_aSeq);
-
-    void const * const pElementData = _anAccessor.validate( Pointer(_aSeq + implGetHeaderSize(1)) );
-
-    sal_Int8 const * const pBinaryData = static_cast<sal_Int8 const *>(pElementData);
-
-    uno::Sequence< sal_Int8 > aSequence(pBinaryData,nElements); 
-
-    return aSequence;
+    return uno::Sequence< sal_Int8 >((const sal_Int8 *)(_aSeq + implGetHeaderSize(1)),
+				     implGetSize(_aSeq));
 }
 
 //-----------------------------------------------------------------------------	
Only in configmgr/source/data: sequence.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/simpleheap.cxx configmgr/source/data/simpleheap.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/simpleheap.cxx	2006-06-20 00:22:46.000000000 +0100
+++ configmgr/source/data/simpleheap.cxx	2006-10-03 16:33:03.000000000 +0100
@@ -1,3 +1,4 @@
+#include <stdio.h>
 /*************************************************************************
  *
  *  OpenOffice.org - a multi-platform office productivity suite
@@ -54,418 +55,3 @@
 #include <map>
 #define INCLUDED_MAP
 #endif
-
-#ifdef _MSC_VER
-#pragma warning( disable : 4355 )
-#endif
-
-// -----------------------------------------------------------------------------	
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        extern HeapManager & localHeap();
-    // -------------------------------------------------------------------------
-        struct OrderByHeapId
-        {
-            typedef HeapManager::HeapIdParam HeapIdParam;
-
-            bool operator()(HeapIdParam lhs, HeapIdParam rhs) const 
-            {
-                return lhs.compareTo(rhs) < 0;
-            }
-        };
-    // -------------------------------------------------------------------------
-        struct HeapSet
-        {
-            typedef HeapManager::HeapIdParam    HeapIdParam;
-            typedef HeapManager::HeapId         HeapId;
-            typedef HeapManager::Handle         Heap;
-
-            typedef std::map<HeapId,Heap,OrderByHeapId> Map;
-
-            HeapSet(HeapManager & _mgr) : m_mgr(_mgr) {}
-
-            Heap add(Heap _aHeap) { return m_heaps[m_mgr.id(_aHeap)] = _aHeap; }
-            void remove(Heap _aHeap) { m_heaps.erase(m_mgr.id(_aHeap)); }
-
-            Heap heap(HeapIdParam _anId) const 
-            {
-                Map::const_iterator it = m_heaps.find(_anId);
-                return it != m_heaps.end() ? it->second : NULL;
-            }
-        private:
-            HeapManager &   m_mgr;
-            Map             m_heaps;
-        };
-    // -------------------------------------------------------------------------
-        class SimpleHeapManagerBase : public HeapManager
-        {
-            static void * ptr(Address _address) { return reinterpret_cast<void*>(_address); }
-            static Address address(void * _ptr) { return reinterpret_cast<Address>(_ptr); }
-            // if this static assertion breaks, a less simple heap manager is needed (-> 64 bit ports)
-            static char address_can_hold_any_pointer[sizeof(Address) - sizeof(void*) + 1];
-
-            virtual void *  base(Handle _aHeap);
-        protected: 
-            SimpleHeapManagerBase() : m_heaps( *(HeapManager*)this) {}
-            virtual ~SimpleHeapManagerBase() {}
-
-            Handle  addHeap(Handle _aHeap)      { return m_heaps.add(_aHeap);   }
-            void    removeHeap(Handle _aHeap)   { m_heaps.remove(_aHeap);       }
-
-            Handle  findHeap( HeapId _anId )    
-            { 
-                osl::MutexGuard aGuard(m_mutex); 
-                return m_heaps.heap(_anId);  
-            }
-
-            osl::Mutex & getHeapListMutex()     { return m_mutex; }
-        protected:      
-            Address allocateMemory(Size _sz);
-            Address reallocateMemory(Address _p, Size _sz);
-            void    deallocateMemory(Address _p);
-
-        protected:      
-            virtual Lock *  createHeapLock(Handle _aHeap);
-            virtual void    destroyHeapLock(Handle _aHeap, Lock * _pLock);
-
-        private:
-            osl::Mutex  m_mutex;
-            HeapSet     m_heaps;
-        };
-    // -------------------------------------------------------------------------
-        class SimpleCheckingHeapManager : public SimpleHeapManagerBase
-        {
-            struct HeapData
-            {
-                HeapId      id;
-                
-                oslInterlockedCount  refs;
-
-                Size        requested;
-                Size        allocated;
-
-                Size available() const { return requested-allocated; }
-
-                typedef std::map<Address, Size> Map;
-                Map allocations;
-            };
-
-            static HeapData * heap(Handle _handle) { return reinterpret_cast<HeapData*>(_handle); }
-            static Handle handle(HeapData * _data) { return reinterpret_cast<Handle>(_data); }
-
-            static void makeNewId(HeapData * _data);
-       public:      
-            virtual Handle createHeap(Size _sInitialSize);
-            virtual Handle attachHeap(HeapIdParam  _anId, Size & _rInitialSize);
-            virtual Size   growHeap(Handle _aHeap, Size _sNewSize);
-            virtual void   destroyHeap(Handle _aHeap);
-
-            virtual HeapId  id(Handle _aHeap);
-
-            virtual Address allocate(Handle _aHeap, Size _sNewSize);
-            virtual Address reallocate(Handle _aHeap, Address _aOldAddress, Size _sNewSize);
-            virtual void    deallocate(Handle _aHeap, Address _aAddress);
-            virtual bool    didAllocate(Handle _aHeap, Address _aAddress);
-        };
-    // -------------------------------------------------------------------------
-        class SimpleHeapLock : public DataLock
-        {
-            osl::Mutex m_mutex;
-        public:   
-            virtual void acquireReadAccess() { m_mutex.acquire(); }
-            virtual void releaseReadAccess() { m_mutex.release(); }
-
-            virtual void acquireWriteAccess() { m_mutex.acquire(); }     
-            virtual void releaseWriteAccess() { m_mutex.release(); }
-        };
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-        HeapManager & cacheHeap()
-        {
-            static SimpleCheckingHeapManager aInstance;
-            return aInstance;
-        }
-    // -------------------------------------------------------------------------
-        HeapManager & localHeap()
-        {
-            static SimpleCheckingHeapManager aInstance;
-            return aInstance;
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleHeapManagerBase::allocateMemory(Size _sz)
-        {
-            void * p = ::rtl_allocateMemory(_sz);
-
-            OSL_ENSURE(p,"Could not allocate: std::malloc failed");
-
-            return address(p);
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleHeapManagerBase::reallocateMemory(Address _p, Size _sz)
-        {
-            void * pOld = ptr(_p);
-
-            void * pNew = ::rtl_reallocateMemory(pOld,_sz);
-
-            OSL_ENSURE(pNew,"Could not reallocate: std::realloc failed");
-
-            return address(pNew);
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleHeapManagerBase::deallocateMemory(Address _p)
-        {
-            void * p = ptr(_p);
-
-            ::rtl_freeMemory(p); 
-        }
-    // -------------------------------------------------------------------------
-
-        void *  SimpleHeapManagerBase::base(Handle /*_aHeap*/)
-        {
-            return NULL;
-        }
-    // -------------------------------------------------------------------------
-
-        DataLock *  SimpleHeapManagerBase::createHeapLock(Handle )
-        {
-            return new SimpleHeapLock();
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleHeapManagerBase::destroyHeapLock(Handle , DataLock * _pLock)
-        {
-            if (SimpleHeapLock* pMyLock = /*dynamic_*/ static_cast<SimpleHeapLock*>(_pLock))
-            {
-                delete pMyLock;
-            }
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-
-        void SimpleCheckingHeapManager::makeNewId(HeapData * _data)
-        {
-            OSL_PRECOND( _data, "Internal Error: NULL data");
-
-            sal_Int64 nData = reinterpret_cast<sal_Int64>(_data);
-
-            HeapId aNewId = HeapId::valueOf(nData,16);
-
-            _data->id = aNewId;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::HeapId SimpleCheckingHeapManager::id(Handle _aHeap)
-        {
-            if (_aHeap == 0) return HeapId();
-
-            HeapData * data = heap(_aHeap);
-
-            return data->id;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Handle SimpleCheckingHeapManager::createHeap(Size _sInitialSize)
-        {
-            // need to have 4-byte pointers for this implementation
-            OSL_ASSERT(sizeof(void *) == sizeof(Address));
-
-            HeapData * pHeap = new HeapData();
-
-            pHeap->refs      = 1;
-
-            pHeap->requested = _sInitialSize;
-            pHeap->allocated = 0;
-
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            makeNewId( pHeap );
-
-            OSL_ENSURE( ! findHeap(pHeap->id), "Internal Error: New heap id already registered");
-
-            return addHeap(handle(pHeap) );
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Handle SimpleCheckingHeapManager::attachHeap(HeapIdParam  _anId, Size & _rInitialSize)
-        {
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            Handle aHeap = findHeap(_anId);
-
-            OSL_ENSURE( aHeap, "Error: No such Heap");
-
-            if (aHeap != 0)
-            {
-                HeapData * data = heap(aHeap);
-
-                OSL_ENSURE( data->id == _anId, "Internal error: Inconsistent heap id");
-
-                _rInitialSize = data->requested;
-             
-                ++data->refs;
-            }
-            else
-                _rInitialSize = 0;
-
-            return aHeap;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Size   SimpleCheckingHeapManager::growHeap(Handle _aHeap, Size _sNewSize)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            if (data->requested < _sNewSize) data->requested = _sNewSize; 
-
-            return data->requested;
-        }
-    // -------------------------------------------------------------------------
-
-        void   SimpleCheckingHeapManager::destroyHeap(Handle _aHeap)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            if (0 == --data->refs)
-            {
-                OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-    //            OSL_ENSURE(data->allocations.empty(), "Memory leaks found");
-                for (HeapData::Map::iterator it = data->allocations.begin();
-                     it != data->allocations.end();
-                     ++it)
-                {
-                    deallocateMemory(it->first);
-                    data->allocated -= it->second;
-
-                }
-                OSL_ENSURE(data->allocated == 0, "Memory tracking error detected");
-
-                removeHeap(_aHeap);
-
-                delete data;
-            }
-        }
-    // -------------------------------------------------------------------------
-
-        bool SimpleCheckingHeapManager::didAllocate(Handle _aHeap, Address _aAddress)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-            OSL_PRECOND( _aAddress, "Warning: checking NULL address - will fail");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            /* Condition is:
-                    allocationAddress <= _aAddress &&
-                    _aAddress <= allocationAddress + allocationSize
-               (<= to allow past-the-end pointer)
-            */
-
-            HeapData::Map::iterator it = data->allocations.upper_bound(_aAddress);
-
-            if (it == data->allocations.begin()) 
-                return false;
-
-            --it; // Now it is the last iterator that is less than or equal to _aAddress
-
-            OSL_ASSERT( it->first <= _aAddress ); // first part of condition handled by map
-
-            return _aAddress <= it->first + it->second;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleCheckingHeapManager::allocate(Handle _aHeap, Size _nSize)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            if (_nSize > data->available()) 
-                return 0;
-
-            Address p = allocateMemory(_nSize);
-            if (p)
-            {
-                data->allocations[p] = _nSize;
-                data->allocated += _nSize;
-            }
-            return p;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleCheckingHeapManager::reallocate(Handle _aHeap, Address _aOld, Size _nNewSize)
-        {
-            if (_aOld == 0) return allocate(_aHeap,_nNewSize);
-
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            OSL_ENSURE( data->allocations.count(_aOld), "Error: pointer being reallocated is not from this data");
-
-            Size nOldSize = data->allocations[_aOld];
-
-            if (nOldSize >= _nNewSize) 
-                return _aOld;
-
-            if (_nNewSize-nOldSize > data->available()) 
-                return 0;
-
-            Address aNew = reallocateMemory(_aOld,_nNewSize);
-            if (aNew)
-            {
-                if (aNew != _aOld) data->allocations.erase(_aOld);
-
-                data->allocations[aNew] = _nNewSize;
-                data->allocated += _nNewSize - nOldSize;
-            }
-
-            return aNew;
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleCheckingHeapManager::deallocate(Handle _aHeap, Address _p)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-            OSL_PRECOND( _p, "Error: Trying to free NULL address");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            OSL_ENSURE( data->allocations.count(_p), "Error: pointer being freed is not from this data");
-
-            Size freed = data->allocations[_p];
-            data->allocated -= freed;
-            data->allocations.erase(_p);
-
-            deallocateMemory(_p);
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-
Only in configmgr/source/data: simpleheap.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/types.cxx configmgr/source/data/types.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/types.cxx	2006-09-29 15:44:58.000000000 +0100
+++ configmgr/source/data/types.cxx	2006-10-04 10:30:25.000000000 +0100
@@ -58,57 +58,44 @@
     namespace sharable
     {
 //-----------------------------------------------------------------------------	
-        using memory::Allocator;
-        using memory::Accessor;
-
-//-----------------------------------------------------------------------------	
-//-----------------------------------------------------------------------------	
 // for now, Name == String
 //-----------------------------------------------------------------------------	
 
-Name allocName(Allocator const& _anAllocator, rtl::OUString const & _sString)
+Name allocName(rtl::OUString const & _sString)
 {
 	rtl_uString_acquire(_sString.pData);
 	return _sString.pData;
 }
-//-----------------------------------------------------------------------------	
-// Name copyName(Allocator const& _anAllocator, Name _aName);
-//-----------------------------------------------------------------------------	
 
-void freeName(memory::Allocator const& _anAllocator, Name _aName)
+void freeName(Name _aName)
 {
 	rtl_uString_release(_aName);
 }
 
-//-----------------------------------------------------------------------------	
-
-::rtl::OUString readName(memory::Accessor const& _anAccessor, Name _aName)
+::rtl::OUString readName(Name _aName)
 {
 	return rtl::OUString(_aName);
 }
 
 //-----------------------------------------------------------------------------	
-//-----------------------------------------------------------------------------	
 
-String allocString(Allocator const& _anAllocator, rtl::OUString const & _sString)
+String allocString(rtl::OUString const & _sString)
 {
-	return allocName(_anAllocator, _sString);
+	return allocName(_sString);
 }
 
-//-----------------------------------------------------------------------------	
-
-void freeString(Allocator const& _anAllocator, String _aString)
+void freeString(String _aString)
 {
-	return freeName(_anAllocator, _aString);
+	return freeName(_aString);
 }
-//-----------------------------------------------------------------------------	
 
-::rtl::OUString readString(Accessor const& _anAccessor, String _aString)
+::rtl::OUString readString(String _aString)
 {
-	return readName(_anAccessor, _aString);
+	return readName(_aString);
 }
+
 //-----------------------------------------------------------------------------	
+
     }
-//-----------------------------------------------------------------------------	
 } // namespace
  
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/updateaccessor.cxx configmgr/source/data/updateaccessor.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/data/updateaccessor.cxx	2005-09-08 04:40:43.000000000 +0100
+++ configmgr/source/data/updateaccessor.cxx	2006-10-04 13:59:38.000000000 +0100
@@ -54,13 +54,13 @@
         UpdateAccessor::UpdateAccessor(Segment * segment)
         : m_segment(segment)
         {
-            m_heap = (m_segment) ? &m_segment->acquireWriteAccess() : 0;
-            OSL_ASSERT( m_heap || !m_segment );
+			m_segment->acquireWriteAccess();
         }
     // -------------------------------------------------------------------------
         UpdateAccessor::~UpdateAccessor()
         {
-            if (m_segment) m_segment->releaseWriteAccess(*m_heap);
+			if (m_segment)
+				m_segment->releaseWriteAccess();
         }
     // -------------------------------------------------------------------------
         Accessor UpdateAccessor::accessor() const
@@ -72,15 +72,14 @@
         Accessor UpdateAccessor::downgrade()
         {
             Segment * segment = m_segment;
-            void const * base = NULL;
+
             if (m_segment)
             {
-                base = m_segment->acquireReadAccess();
-                m_segment->releaseWriteAccess(*m_heap);
+				m_segment->downgradeAccess();
                 m_segment = 0;
             }
 
-            return Accessor(segment, base, SAL_NO_ACQUIRE);
+            return Accessor(segment, SAL_NO_ACQUIRE);
         }
 
     // -------------------------------------------------------------------------
@@ -88,79 +87,10 @@
         {
             if (m_segment)
             {
-                m_segment->releaseWriteAccess(*m_heap);
+                m_segment->releaseWriteAccess();
                 m_segment = NULL;
             }
         }
-
-    // -------------------------------------------------------------------------
-        char * UpdateAccessor::heap_base() const
-        {
-            return static_cast<char *>(m_heap ? m_heap->base() : NULL);
-        }
-
-    // -------------------------------------------------------------------------
-        char * Allocator::heap_base() const
-        {
-            return static_cast<char *>(m_heap ? m_heap->base() : NULL);
-        }
-
-    // -------------------------------------------------------------------------
-        Allocator::Address Allocator::allocate(Size _sz) const
-        {
-            OSL_ENSURE(m_heap,"Cannot allocate: Invalid heap");
-            return m_heap ? m_heap->allocate(_sz) : Allocator::Address();
-        }
-
-    // -------------------------------------------------------------------------
-        void Allocator::deallocate(Address _addr) const
-        {
-            OSL_ENSURE(m_heap,"Cannot deallocate: Invalid heap");
-            if (m_heap) m_heap->deallocate(_addr);
-        }
-
-    // -------------------------------------------------------------------------
-
-    #if OSL_DEBUG_LEVEL > 0
-        void * UpdateAccessor::resolve(AddressType _p) const
-        {
-            OSL_ENSURE( !_p.is() || m_segment->isValidAddress(_p.value()), "Address does not belong to this segment");
-            return _p.is() ? heap_base() + _p.value() : NULL;
-        }
-
-        Pointer  UpdateAccessor::reduce(void const * _p) const
-        {
-            if (_p)
-            {
-                Pointer::RawAddress addr = static_cast<char const *>(_p) - heap_base();
-                OSL_ENSURE( m_segment->isValidAddress(addr), "Pointer does not belong to this segment");
-                return Pointer(addr);
-            }
-            else
-                return Pointer();
-        }
-
-        void * Allocator::access(Address _addr) const
-        {
-            OSL_ENSURE( !_addr || m_heap->isValidAddress(_addr), "Address does not belong to this segment");
-            return _addr ? heap_base() + _addr : NULL;
-        }
-
-
-        Allocator::Address  Allocator::address(void const * _p) const
-        {
-            if (_p)
-            {
-                Address addr = static_cast<char const *>(_p) - heap_base();
-                OSL_ENSURE( m_heap->isValidAddress(addr), "Pointer does not belong to this segment");
-                return addr;
-            }
-            else
-                return 0;
-        }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
Only in configmgr/source/data: updateaccessor.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/accessor.hxx configmgr/source/inc/accessor.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/accessor.hxx	2005-09-08 04:41:00.000000000 +0100
+++ configmgr/source/inc/accessor.hxx	2006-10-04 12:56:03.000000000 +0100
@@ -36,8 +36,8 @@
 #ifndef CONFIGMGR_ACCESSOR_HXX
 #define CONFIGMGR_ACCESSOR_HXX
 
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
 #endif
 
 #ifndef _OSL_INTERLOCK_H_
@@ -57,14 +57,11 @@
             struct Impl
             {
                 Impl(Segment const * segment);
-                Impl(Segment const * segment, void const * base);
-
                 ~Impl();
 
                 bool is() const { return m_segment != NULL; }
 
                 Segment const * m_segment;
-                char    const * m_base;
                 oslInterlockedCount m_refs;
             private:
                 // disallow copying
@@ -78,9 +75,6 @@
 
             Impl * m_impl;
         public:
-            /// type of addresses used in the Segment
-            typedef Pointer AddressType;
-
             /// constructs an accessor on the given Segment
             explicit Accessor(Segment const * _pSegment) : m_impl(new Impl(_pSegment)) {}
 
@@ -90,45 +84,12 @@
 
             ~Accessor() { releaseImpl(); }
             
-            void swap(Accessor & _rOther);
-
             bool is() const { return m_impl->is(); }
             void clear();
-
-            AddressType address(void const * _p) const
-            { return (this->is()) ? reduce(_p) : Pointer();}
-
-            void const * access(AddressType _p) const
-            { return (this->is()) ? resolve(_p) : failNull();}
-
-            void const * validate(AddressType _p) const
-            { return (this->is() && _p.is()) ? resolve(_p) : failNull(); }
-
         private:
-            char    const * base_()    const { return m_impl->m_base; }
-            Segment const * segment_() const { return m_impl->m_segment; }
-
-            void const * resolve(AddressType _p) const;
-            AddressType  reduce(void const * _p) const;
-
             friend class UpdateAccessor;
-            Accessor(Segment * _s, void const * _b, __sal_NoAcquire) : m_impl(new Impl(_s,_b)) {}
-            static void * failNull();
+            Accessor(Segment * _s, __sal_NoAcquire) : m_impl(new Impl(_s)) {}
         };
-
-    // -------------------------------------------------------------------------
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline 
-        void const * Accessor::resolve(AddressType _p) const 
-        { return _p.is() ? this->base_() + _p.value() : NULL; }
-
-        inline 
-        Pointer  Accessor::reduce(void const * _p) const 
-        { return _p ? Pointer(static_cast<char const *>(_p) - this->base_()) : Pointer(); }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/anydata.hxx configmgr/source/inc/anydata.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/anydata.hxx	2005-09-08 04:41:13.000000000 +0100
+++ configmgr/source/inc/anydata.hxx	2006-10-03 18:04:25.000000000 +0100
@@ -51,9 +51,6 @@
 {
 //-----------------------------------------------------------------------------
 
-    namespace memory { class Allocator; class Accessor; }
-    //-----------------------------------------------------------------------------
-
     namespace sharable
     {
     //-----------------------------------------------------------------------------
@@ -80,9 +77,8 @@
         AnyData::TypeCode getTypeCode(::com::sun::star::uno::Type const & _aType);
         ::com::sun::star::uno::Type getUnoType( AnyData::TypeCode _aType);
 
-        AnyData allocData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, ::com::sun::star::uno::Any const & _aAny);
-    //    AnyData copyData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, AnyData _aData);
-        void    freeData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, AnyData _aData);
+        AnyData allocData(AnyData::TypeCode _aType, ::com::sun::star::uno::Any const & _aAny);
+        void    freeData(AnyData::TypeCode _aType, AnyData _aData);
         ::com::sun::star::uno::Any readData(memory::Accessor const& _anAccessor, AnyData::TypeCode _aType, AnyData _aData);
 
     //-----------------------------------------------------------------------------
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/cacheddataprovider.hxx configmgr/source/inc/cacheddataprovider.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/cacheddataprovider.hxx	2005-09-08 04:43:49.000000000 +0100
+++ configmgr/source/inc/cacheddataprovider.hxx	2006-10-04 14:06:10.000000000 +0100
@@ -67,10 +67,10 @@
 // ---------------------------------------------------------------------------
     struct CacheLocation
     {
-        memory::SegmentAddress          segment;
-        memory::SegmentHeap::Address    address;
+        memory::SegmentAddress segment;
+        memory::Address        address;
             
-        bool isNull() const { return segment.isNull() || address == 0; }
+        bool isNull() const { return segment == NULL || address == 0; }
     };
 // ---------------------------------------------------------------------------
     struct IDirectDataProvider;
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/datalock.hxx configmgr/source/inc/datalock.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/datalock.hxx	2005-09-08 04:46:50.000000000 +0100
+++ configmgr/source/inc/datalock.hxx	2006-10-04 13:02:15.000000000 +0100
@@ -33,31 +33,3 @@
  *
  ************************************************************************/
 
-#ifndef CONFIGMGR_DATALOCK_HXX
-#define CONFIGMGR_DATALOCK_HXX
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-
-        /// class controlling access to a memory::Segment
-        struct DataLock
-        {
-	        virtual void acquireReadAccess() = 0;
-	        virtual void releaseReadAccess() = 0;
-
-	        virtual void acquireWriteAccess() = 0; 	        
-	        virtual void releaseWriteAccess() = 0;
-        protected:
-            virtual ~DataLock() {}
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-#endif // CONFIGMGR_DATALOCK_HXX
-
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/groupnodeaccess.hxx configmgr/source/inc/groupnodeaccess.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/groupnodeaccess.hxx	2005-09-08 04:48:05.000000000 +0100
+++ configmgr/source/inc/groupnodeaccess.hxx	2006-10-04 11:33:50.000000000 +0100
@@ -107,7 +107,7 @@
 
             operator NodeAccessRef()    const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            DataType& data() const { return *(NodePointerType)m_pData; }
 
         private:
             static AddressType check(NodeAccessRef const&);
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/heapfactory.hxx configmgr/source/inc/heapfactory.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/heapfactory.hxx	2005-09-08 04:48:33.000000000 +0100
+++ configmgr/source/inc/heapfactory.hxx	2006-10-03 16:29:52.000000000 +0100
@@ -36,21 +36,5 @@
 #ifndef CONFIGMGR_HEAPFACTORY_HXX
 #define CONFIGMGR_HEAPFACTORY_HXX
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-        class HeapManager;
-
-        HeapManager & localHeap();
-        HeapManager & cacheHeap();
-
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
 #endif // CONFIGMGR_HEAPFACTORY_HXX
 
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/heap.hxx configmgr/source/inc/heap.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/heap.hxx	2005-12-28 17:29:58.000000000 +0000
+++ configmgr/source/inc/heap.hxx	2006-10-03 17:35:02.000000000 +0100
@@ -46,50 +46,5 @@
 #include <rtl/string.hxx>
 #endif
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class Heap : Noncopyable
-        {
-            HeapManager       & m_impl;
-            HeapManager::Handle m_heap;
-            HeapManager::Size   m_size;
-        public:
-            typedef HeapManager::Lock        Lock;
-            typedef HeapManager::Size        Size;
-            typedef HeapManager::HeapId      HeapId;
-            typedef HeapManager::HeapIdParam HeapIdParam;
-            typedef HeapManager::Address     Address;
-
-            Heap(HeapManager& _impl);
-            Heap(HeapManager& _impl, Size _nInitialSize);
-            Heap(HeapManager& _impl, HeapIdParam _anId);
-            ~Heap();
-
-            Size    size() const { return m_size; }
-
-            Size    grow(Size _nReqSize); 
-
-            void *  base() const   { return m_impl.base(m_heap); }
-            HeapId  id()   const   { return m_impl.id(m_heap); }
-
-            Address allocate(Size _sNewSize)    { return m_impl.allocate(m_heap, _sNewSize); }
-            Address reallocate(Address _aOldAddress, Size _sNewSize)    
-            { return m_impl.reallocate(m_heap, _aOldAddress, _sNewSize); }
-            void    deallocate(Address _aAddress)    { m_impl.deallocate(m_heap, _aAddress); }
-            bool    didAllocate(Address _aAddress) const 
-            { return m_impl.didAllocate(m_heap, _aAddress); }
-
-            Lock *  createLock()                { return m_impl.createHeapLock(m_heap); }
-            void    destroyLock(Lock * _pLock)  { m_impl.destroyHeapLock(m_heap,_pLock); }
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
 #endif // CONFIGMGR_DATAHEAP_HXX
 
Only in configmgr/source/inc: heap.hxx.rej
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/heapmanager.hxx configmgr/source/inc/heapmanager.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/heapmanager.hxx	2005-12-28 17:30:19.000000000 +0000
+++ configmgr/source/inc/heapmanager.hxx	2006-10-03 16:26:25.000000000 +0100
@@ -50,45 +50,7 @@
 #include <rtl/string.hxx>
 #endif
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class HeapManager
-        {
-        public:
-            typedef struct Opaque_ * Handle;
-
-            typedef memory::HeapSize    Size;
-            typedef memory::Address     Address;
-            typedef rtl::OString        HeapId;
-            typedef rtl::OString const & HeapIdParam;
-
-        //    virtual HeapId newHeapId() = 0;
-            virtual Handle createHeap(/*HeapIdParam _anId, */Size _sInitialSize) = 0;
-            virtual Handle attachHeap(HeapIdParam _anId, Size & _rInitialSize) = 0;
-            virtual Size   growHeap(Handle _aHeap, Size _sNewSize) = 0;
-            virtual void   destroyHeap(Handle _aHeap) = 0;
-
-            virtual void *  base(Handle _aHeap) = 0;
-            virtual HeapId  id(Handle _aHeap) = 0;
-
-            virtual Address allocate(Handle _aHeap, Size _sNewSize) = 0;
-            virtual Address reallocate(Handle _aHeap, Address _aOldAddress, Size _sNewSize) = 0;
-            virtual void    deallocate(Handle _aHeap, Address _aAddress) = 0;
-            virtual bool    didAllocate(Handle _aHeap, Address _aAddress) = 0;
-
-            typedef DataLock Lock;
-
-            virtual Lock *  createHeapLock(Handle _aHeap) = 0;
-            virtual void    destroyHeapLock(Handle _aHeap, Lock * _pLock) = 0;
-        };
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
+#include <osl/mutex.hxx>
 
 #endif // CONFIGMGR_DATAHEAPMANAGER_HXX
 
Only in configmgr/source/inc: heapmanager.hxx.rej
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/memorymodel.hxx configmgr/source/inc/memorymodel.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/memorymodel.hxx	2005-12-28 17:30:28.000000000 +0000
+++ configmgr/source/inc/memorymodel.hxx	2006-10-04 10:55:44.000000000 +0100
@@ -40,30 +40,13 @@
 #include <sal/types.h>
 #endif
 
-//-----------------------------------------------------------------------------
-// no full heap implementation available yet - storing pointer value in Address
-#define CFG_ADDRESS_HOLDS_POINTER
-//-----------------------------------------------------------------------------
-
 namespace configmgr
 {
-//-----------------------------------------------------------------------------
-
     namespace memory 
     {
-    //-----------------------------------------------------------------------------
-    // some base types that describe our memory model
-#ifndef CFG_ADDRESS_HOLDS_POINTER
-        typedef sal_uInt32 Address; // points to relative location in memory segment
-#else
-        typedef sal_uIntPtr Address; // points to absolute location in memory
-#endif
-        typedef sal_uInt32 HeapSize; // memory block size within private heap
+        typedef sal_uInt8 *Address;
         typedef sal_uInt8  Byte;  
-    //-----------------------------------------------------------------------------
     }
-//-----------------------------------------------------------------------------
 }
 
-
 #endif // CONFIGMGR_MEMORYMODEL_HXX 
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/nodeaccess.hxx configmgr/source/inc/nodeaccess.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/nodeaccess.hxx	2005-09-08 04:51:08.000000000 +0100
+++ configmgr/source/inc/nodeaccess.hxx	2006-10-04 12:39:38.000000000 +0100
@@ -53,11 +53,13 @@
 namespace configmgr
 {
 // -----------------------------------------------------------------------------	
+    namespace memory { class UpdateAccessor; }
+	
     namespace data
     {
     // -------------------------------------------------------------------------
         using memory::Accessor;
-    // -------------------------------------------------------------------------
+	    
     // -------------------------------------------------------------------------	
         class NodeAccess
 	    {
@@ -74,15 +76,15 @@
 
             NodeAccess(Accessor const& _aAccessor, NodeAddressType const& _aNodeRef) 
             : m_aAccessor(_aAccessor)
-            , m_pData(_aNodeRef.m_pData) 
+            , m_pData((NodePointerType)_aNodeRef.m_pData) 
             {}
 
-            NodeAccess(Accessor const& _aAccessor, NodePointerType _pNode) 
+            NodeAccess(Accessor const& _aAccessor, DataType *_pNode) 
             : m_aAccessor(_aAccessor)
-            , m_pData(_aAccessor.address(_pNode)) 
+            , m_pData(_pNode) 
             {}
 
-            bool isValid() const { return m_pData.is(); }
+            bool isValid() const { return m_pData != NULL; }
             bool isLocalRoot() const { return data().isFragmentRoot(); }
 
             Name getName() const { return wrapName( data().getName(m_aAccessor) ); }
@@ -91,25 +93,26 @@
             bool isDefault()   const { return data().isDefault(); }
             bool isLocalized() const { return data().isLocalized(); }
 
-            NodeAddressType address() const { return NodeAddressType(m_pData); }
+            NodeAddressType address() const { return NodeAddressType((AddressType)m_pData); }
             Accessor const& accessor() const { return m_aAccessor; }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
-            NodePointerType getDataPtr() const { return static_cast<NodePointerType>(m_aAccessor.access(m_pData)); }
-
-            AddressType rawAddress() const { return m_pData; }
+            DataType& data() const { return *m_pData; }
+            DataType *getDataPtr() const { return m_pData; }
 
             static Name wrapName(rtl::OUString const& _aNameString)
             { return configuration::makeName( _aNameString, Name::NoValidate() ); }
 
             static NodeAddress::DataType* access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor& _rUpdateAccess);
-            static NodeAddress::DataType const* access(NodeAddressType const& _aNodeRef, Accessor const& _rReaderAccess)
-            { return static_cast<NodePointerType>(_rReaderAccess.access(_aNodeRef.m_pData)); }
+            static NodeAddress::DataType const* access(NodeAddressType const& _aNodeRef, Accessor const&)
+            { return (NodeAddress::DataType *)_aNodeRef.m_pData; }
+
+	    operator AddressType () { return (AddressType) m_pData; }
+	    operator const AddressType () const { return (AddressType) m_pData; }
         private:
             NodeAccess() : m_aAccessor(NULL), m_pData() {}
 
-            Accessor    m_aAccessor;
-		    AddressType m_pData;
+            Accessor        m_aAccessor;
+	    NodePointerType m_pData;
         };
     // -------------------------------------------------------------------------	
         class NodeAccessRef
@@ -125,7 +128,7 @@
 
             NodeAccessRef(NodeAccess const& _aNodeAccess) 
             : m_pAccessor(&_aNodeAccess.accessor())
-            , m_pData(_aNodeAccess.rawAddress()) 
+            , m_pData(_aNodeAccess) 
             {}
 
             NodeAccessRef(Accessor const * _pAccessor, NodeAddressType const& _aNodeRef) 
@@ -135,12 +138,12 @@
 
             NodeAccessRef(Accessor const * _pAccessor, NodePointerType _pNode) 
             : m_pAccessor(_pAccessor)
-            , m_pData(_pAccessor->address(_pNode)) 
+            , m_pData((AddressType) _pNode) 
             {}
 
             NodeAccess toNodeAccess () const { return NodeAccess(accessor(),address()); }
 
-            bool isValid() const { return m_pData.is(); }
+            bool isValid() const { return m_pData != NULL; }
             bool isLocalRoot() const { return data().isFragmentRoot(); }
 
             Name getName() const { return NodeAccess::wrapName( data().getName(*m_pAccessor) ); }
@@ -152,14 +155,13 @@
             NodeAddressType address() const { return NodeAddressType(m_pData); }
             Accessor const& accessor() const { return *m_pAccessor; }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_pAccessor->validate(m_pData)); }
-            NodePointerType getDataPtr() const { return static_cast<NodePointerType>(m_pAccessor->access(m_pData)); }
-
-            AddressType rawAddress() const { return m_pData; }
+            DataType& data() const { return *(DataType *)m_pData; }
+            DataType* getDataPtr() { return (DataType *)m_pData; }
+            DataType* getDataPtr() const { return (DataType *)m_pData; }
 
         private:
             Accessor const *   m_pAccessor;
-		    AddressType m_pData;
+	    AddressType m_pData;
         };
     // -------------------------------------------------------------------------
     // helper - finds child or element
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/nodeaddress.hxx configmgr/source/inc/nodeaddress.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/nodeaddress.hxx	2006-01-19 17:53:30.000000000 +0000
+++ configmgr/source/inc/nodeaddress.hxx	2006-10-04 12:51:28.000000000 +0100
@@ -36,8 +36,8 @@
 #ifndef CONFIGMGR_NODEADDRESS_HXX
 #define CONFIGMGR_NODEADDRESS_HXX
 
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
 #endif
 
 #ifndef INCLUDED_SHARABLE_NODE_HXX
@@ -60,7 +60,7 @@
             friend class NodeAccessRef;
         public:
             typedef sharable::Node      DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
         public:
             NodeAddress() : m_pData() {}
@@ -68,17 +68,18 @@
             explicit
             NodeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+	    bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
-            AddressType::RawAddress addressValue() const { return m_pData.value(); }
+            AddressType addressValue() const { return m_pData; }
 
             friend bool operator == (NodeAddress const& lhs, NodeAddress const& rhs);
 
             friend bool operator != (NodeAddress const& lhs, NodeAddress const& rhs);
 
+	    operator AddressType () { return m_pData; }
         private:
-		    AddressType                 m_pData;
+	    AddressType                 m_pData;
         };
 
         inline bool operator == (NodeAddress const& lhs, NodeAddress const& rhs)
@@ -93,17 +94,17 @@
             friend class ValueNodeAccess;
         public:
             typedef sharable::ValueNode DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+            bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
             operator NodeAddress() const { return NodeAddress(m_pData); }
         private:
             explicit
             ValueNodeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
 
-		    AddressType m_pData;
+	    AddressType m_pData;
         };
     // -------------------------------------------------------------------------
 
@@ -112,10 +113,10 @@
             friend class GroupNodeAccess;
         public:
             typedef sharable::GroupNode DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+	    bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
             operator NodeAddress()        const { return NodeAddress(m_pData); }
         private:
@@ -131,10 +132,10 @@
             friend class SetNodeAccess;
         public:
             typedef sharable::SetNode   DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+	    bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
             operator NodeAddress()        const { return NodeAddress(m_pData); }
         private:
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/node.hxx configmgr/source/inc/node.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/node.hxx	2006-09-29 15:44:58.000000000 +0100
+++ configmgr/source/inc/node.hxx	2006-10-03 18:04:46.000000000 +0100
@@ -114,15 +114,13 @@
 
             // low-level helper for template data abstraction
             static
-            Address allocTemplateData(memory::Allocator const & _anAllocator,
-									  const rtl::OUString &rName,
+            Address allocTemplateData(const rtl::OUString &rName,
 									  const rtl::OUString &rModule);
             static 
-			Address copyTemplateData(memory::Allocator const & _anAllocator,
-									 memory::Accessor  const & _aSourceAccessor,
+			Address copyTemplateData(memory::Accessor  const & _aSourceAccessor,
 									 Address _aTemplateData);
             static
-            void releaseTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData);
+            void releaseTemplateData(Address _aTemplateData);
         };
     //-----------------------------------------------------------------------------
         struct ValueNode
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/pointer.hxx configmgr/source/inc/pointer.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/pointer.hxx	2005-12-28 17:30:54.000000000 +0000
+++ configmgr/source/inc/pointer.hxx	2006-10-04 12:42:08.000000000 +0100
@@ -32,59 +32,3 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-
-#ifndef CONFIGMGR_POINTER_HXX
-#define CONFIGMGR_POINTER_HXX
-
-#ifndef CONFIGMGR_MEMORYMODEL_HXX
-#include "memorymodel.hxx"
-#endif
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class Accessor;
-        class UpdateAccessor;
-    // -------------------------------------------------------------------------	
-        /// class mediating read-only access to a memory::Segment
-        class Pointer 
-        {
-            friend class Accessor;
-            friend class UpdateAccessor;
-
-            typedef memory::Address AddressType;
-
-            AddressType m_value;
-
-            struct Opaque_;
-        public:
-            typedef AddressType RawAddress;
-
-            Pointer() : m_value(0) {}
-            explicit Pointer(AddressType p) : m_value(p) {}
-
-            RawAddress value() const { return m_value; }
-
-            bool isNull()   const { return m_value == 0; }
-            bool is()       const { return m_value != 0; }
-
-            operator Opaque_ const * () const { return reinterpret_cast<Opaque_ const *>(m_value); }
-
-            friend bool operator == (Pointer lhs, Pointer rhs)
-            { return lhs.value() == rhs.value(); }
-
-            friend bool operator != (Pointer lhs, Pointer rhs)
-            { return lhs.value() != rhs.value(); }
-        };
-
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-// -----------------------------------------------------------------------------
-
-#endif // CONFIGMGR_POINTER_HXX
-
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/segmentheap.hxx configmgr/source/inc/segmentheap.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/segmentheap.hxx	2005-09-08 04:55:20.000000000 +0100
+++ configmgr/source/inc/segmentheap.hxx	2006-10-04 13:07:48.000000000 +0100
@@ -32,82 +32,3 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-
-#ifndef CONFIGMGR_SEGMENTHEAP_HXX
-#define CONFIGMGR_SEGMENTHEAP_HXX
-
-#ifndef CONFIGMGR_DATAHEAP_HXX
-#include "heap.hxx"
-#endif
-#ifndef CONFIGMGR_UTILITY_HXX_
-#include "utility.hxx"
-#endif
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-        class SegmentHeap : Noncopyable
-        {
-            friend class Segment;
-            typedef Heap::Lock Lock;
-
-            Heap   m_heap;
-            void * m_base;
-            Lock * m_lock;
-
-            Lock & lock() const { return *m_lock; }
-        public:
-            typedef Heap::HeapId        HeapId;
-            typedef Heap::HeapIdParam   HeapIdParam;
-            typedef Heap::Size          Size;
-            typedef Heap::Address       Address;
-            
-            SegmentHeap(HeapManager & _rImpl)
-            : m_heap(_rImpl)
-            { init(); }
-
-            SegmentHeap(HeapManager & _rImpl, Size _aInitialSize)
-            : m_heap(_rImpl,_aInitialSize)
-            { init(); }
-
-            SegmentHeap(HeapManager & _rImpl, HeapIdParam _anId)
-            : m_heap(_rImpl,_anId)
-            { init(); }
-
-            ~SegmentHeap();
-
-            // PRE: lock must be acquired
-            void*   base() const { return m_base; }
-            HeapId  id() const { return m_heap.id(); }
-
-            Address allocate(Size _sz) 
-            {
-                Address aResult = m_heap.allocate(_sz);
-                if (!aResult)
-                    aResult = this->allocateMore(_sz);
-                return aResult;
-            }
-
-            void deallocate(Address _addr) 
-            { 
-                m_heap.deallocate(_addr); 
-            }
-
-            bool isValidAddress(Address _addr) const
-            { 
-                return m_heap.didAllocate(_addr); 
-            }
-        private:
-            void init();
-            Address allocateMore(Size _sz);
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-#endif // CONFIGMGR_SEGMENT_HXX
-
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/segment.hxx configmgr/source/inc/segment.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/segment.hxx	2005-09-08 04:55:04.000000000 +0100
+++ configmgr/source/inc/segment.hxx	2006-10-04 14:05:58.000000000 +0100
@@ -39,13 +39,15 @@
 #ifndef CONFIGMGR_DATALOCK_HXX
 #include "datalock.hxx"
 #endif
-#ifndef CONFIGMGR_SEGMENTHEAP_HXX
-#include "segmentheap.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
 #endif
 #ifndef _RTL_STRING_HXX_
 #include <rtl/string.hxx>
 #endif
 
+#include <osl/mutex.hxx>
+
 namespace configmgr
 {
 // -----------------------------------------------------------------------------	
@@ -54,65 +56,20 @@
     // -------------------------------------------------------------------------	
         class Segment
         {
-            SegmentHeap m_heap;
-        public:
-            typedef SegmentHeap     Heap;
-            typedef Heap::Lock      Lock;
-            typedef rtl::OString    Id;
-
+            osl::Mutex m_mutex;
         public:
-            explicit Segment(HeapManager & _aHeapImpl) 
-            : m_heap(_aHeapImpl) {}
-
-            explicit Segment(HeapManager & _aHeapImpl, Heap::Size _aInitialSize) 
-            : m_heap(_aHeapImpl,_aInitialSize) {}
+            explicit Segment() 
+            : m_mutex() {}
 
-            explicit Segment(HeapManager & _aHeapImpl, Id const & _anId) 
-            : m_heap(_aHeapImpl,_anId) {}
+			void acquireWriteAccess() { m_mutex.acquire(); }
+			void releaseWriteAccess() { m_mutex.release(); }
+			void downgradeAccess()    {}
 
-            Id getId() const { return m_heap.id(); }
-
-            bool isValidAddress(Heap::Address _aAddress) const
-            {
-                return m_heap.isValidAddress(_aAddress); 
-            }
-
-            Heap& acquireWriteAccess()       
-            { 
-                this->lock().acquireWriteAccess(); 
-                return this->heap(); 
-            }
-
-            void  releaseWriteAccess(Heap&)  
-            { 
-                this->lock().releaseWriteAccess(); 
-            }
-
-            void const * acquireReadAccess() const 
-            { 
-                this->lock().acquireReadAccess();
-                return base();
-            }
-            void releaseReadAccess (void const * ) const 
-            { 
-                this->lock().releaseReadAccess(); 
-            }
-        private:
-            Heap & heap()       { return m_heap; }
-            Lock & lock() const { return m_heap.lock(); }
-            void * base() const { return m_heap.base(); }
+			void acquireReadAccess() const { ((Segment *)this)->m_mutex.acquire(); }
+			void releaseReadAccess() const { ((Segment *)this)->m_mutex.release(); }
         };
-    // -------------------------------------------------------------------------
-        typedef Segment::Id SegmentID;
-    // -------------------------------------------------------------------------
-        struct SegmentAddress
-        {
-            SegmentID               id;
-            SegmentHeap::Address    base;
 
-            bool isNull() const { return base == 0; }
-        };
-    // -------------------------------------------------------------------------	
+		typedef memory::Address SegmentAddress;
     }
 // -----------------------------------------------------------------------------	
 } // namespace configmgr
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/sequence.hxx configmgr/source/inc/sequence.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/sequence.hxx	2005-09-08 04:55:37.000000000 +0100
+++ configmgr/source/inc/sequence.hxx	2006-10-03 18:05:22.000000000 +0100
@@ -56,17 +56,15 @@
         typedef Vector Sequence; // alternative name
     //-----------------------------------------------------------------------------
        
-        Sequence allocSequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, ::sal_Sequence const * _pSeqData);
-    //    Sequence copySequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, Sequence _aSeq);
-        void     freeSequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, Sequence _aSeq);
+        Sequence allocSequence(AnyData::TypeCode _aElementType, ::sal_Sequence const * _pSeqData);
+        void     freeSequence(AnyData::TypeCode _aElementType, Sequence _aSeq);
 
         ::sal_Sequence * readSequence(memory::Accessor const& _anAccessor, AnyData::TypeCode _aElementType, Sequence _aSeq);
         ::com::sun::star::uno::Any readAnySequence(memory::Accessor const& _anAccessor, AnyData::TypeCode _aElementType, Sequence _aSeq);
     //-----------------------------------------------------------------------------
 
-        Sequence allocBinary(memory::Allocator const& _anAllocator, ::com::sun::star::uno::Sequence<sal_Int8> const & _aBinaryValue);
-    //    Sequence copyBinary(memory::Allocator const& _anAllocator, Sequence _aSeq);
-        void freeBinary(memory::Allocator const& _anAllocator, Sequence _aSeq);
+        Sequence allocBinary(::com::sun::star::uno::Sequence<sal_Int8> const & _aBinaryValue);
+        void freeBinary(Sequence _aSeq);
 
         ::com::sun::star::uno::Sequence<sal_Int8> readBinary(memory::Accessor const& _anAccessor, Sequence _aSeq);
     //-----------------------------------------------------------------------------
@@ -80,11 +78,11 @@
         }
 
         template <class ET>
-        Sequence allocSequence(memory::Allocator const& _anAllocator, ::com::sun::star::uno::Sequence<ET> const & _aSeq)
+        Sequence allocSequence(::com::sun::star::uno::Sequence<ET> const & _aSeq)
         {
             AnyData::TypeCode aTC = getElementTypeCode(_aSeq);
             ::sal_Sequence const * pSeqData = _aSeq.get();
-            return allocSequence(_anAllocator, aTC, pSeqData);
+            return allocSequence(aTC, pSeqData);
         }
 
         template <class ET>
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/setnodeaccess.hxx configmgr/source/inc/setnodeaccess.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/setnodeaccess.hxx	2005-09-08 04:56:11.000000000 +0100
+++ configmgr/source/inc/setnodeaccess.hxx	2006-10-04 11:34:46.000000000 +0100
@@ -113,7 +113,7 @@
 
             operator NodeAccessRef() const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            DataType& data() const { return *(NodePointerType)m_pData; }
 
             static void addElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, ElementAddress _aNewElement);
             static ElementAddress removeElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, Name const & _aName);
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/treeaccessor.hxx configmgr/source/inc/treeaccessor.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/treeaccessor.hxx	2005-09-08 04:58:18.000000000 +0100
+++ configmgr/source/inc/treeaccessor.hxx	2006-10-04 11:32:13.000000000 +0100
@@ -86,7 +86,7 @@
 
             TreeAccessor(Accessor const& _aAccessor, DataPointerType _pTree) 
             : m_aAccessor(_aAccessor)
-            , m_pBase(_aAccessor.address(_pTree)) 
+            , m_pBase((TreeAddress::AddressType)_pTree)
             {}
 
             bool isValid() const { return m_pBase.is(); }
@@ -101,8 +101,8 @@
             DataAddressType address() const { return m_pBase; }
             Accessor const& accessor() const { return m_aAccessor; }
 
-            DataType& data() const { return *static_cast<DataPointerType>(m_aAccessor.validate(m_pBase.m_pData)); }
-            DataPointerType getDataPtr() const { return access(m_pBase,m_aAccessor); }
+            DataType& data() const { return *(DataPointerType )m_pBase.m_pData; }
+            DataPointerType getDataPtr() const { return (DataPointerType )m_pBase.m_pData; }
 
             TreeAddress copyTree(memory::UpdateAccessor & _aTargetSpace) const;
             static void freeTree(memory::UpdateAccessor & _aTargetSpace, TreeAddress _aTree);
@@ -111,15 +111,15 @@
             { return configuration::makeName( _aNameString, Name::NoValidate() ); }
 
             static TreeAddress::DataType* access(DataAddressType const& _aTreeRef, memory::UpdateAccessor& _rUpdateAccess);
-            static TreeAddress::DataType const* access(DataAddressType const& _aTreeRef, Accessor const& _rReaderAccess)
-            { return static_cast<DataPointerType>(_rReaderAccess.access(_aTreeRef.m_pData)); }
+            static TreeAddress::DataType const* access(DataAddressType const& _aTreeRef, Accessor const&)
+            { return (DataPointerType)_aTreeRef.m_pData; }
         private:
             NodeAddress rootAddress(DataAddressType const& p) const;
 
             TreeAccessor();
         private:
             Accessor            m_aAccessor;
-		    DataAddressType     m_pBase;
+	    DataAddressType     m_pBase;
         };
     // -------------------------------------------------------------------------
     // -------------------------------------------------------------------------
@@ -136,7 +136,7 @@
 
             if (aAddr) aAddr += offsetof(TreeAddress::DataType,nodes);
 
-            return NodeAddress( memory::Pointer(aAddr) ); 
+            return NodeAddress( (memory::Address) aAddr ); 
         }
     // -------------------------------------------------------------------------
     }
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/treeaddress.hxx configmgr/source/inc/treeaddress.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/treeaddress.hxx	2005-09-08 04:58:45.000000000 +0100
+++ configmgr/source/inc/treeaddress.hxx	2006-10-04 12:42:55.000000000 +0100
@@ -36,8 +36,8 @@
 #ifndef CONFIGMGR_TREEADDRESS_HXX
 #define CONFIGMGR_TREEADDRESS_HXX
 
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
 #endif
 
 #ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
@@ -58,17 +58,17 @@
             friend class TreeAccessor;
         public:
             typedef sharable::TreeFragment  DataType;
-            typedef memory::Pointer         AddressType;
+            typedef memory::Address         AddressType;
         public:
             TreeAddress() : m_pData() {}
 
             explicit
             TreeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+            bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
-            AddressType::RawAddress addressValue() const { return m_pData.value(); }
+            memory::Address addressValue() const { return m_pData; }
 
             friend bool operator == (TreeAddress const& lhs, TreeAddress const& rhs)
             { return lhs.m_pData == rhs.m_pData; }
@@ -77,7 +77,7 @@
             { return lhs.m_pData != rhs.m_pData; }
 
         private:
-		    AddressType m_pData;
+	    AddressType m_pData;
         };
     // -------------------------------------------------------------------------
     }
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/treemanager.hxx configmgr/source/inc/treemanager.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/treemanager.hxx	2005-09-08 04:59:42.000000000 +0100
+++ configmgr/source/inc/treemanager.hxx	2006-10-03 16:30:16.000000000 +0100
@@ -104,12 +104,10 @@
 		/** ctor
 		*/
         explicit
-        TreeManager(BackendCacheRef const & _xBackend, memory::HeapManager & _rCacheHeapManager);
+        TreeManager(BackendCacheRef const & _xBackend);
 
 		// disposing the cache before destroying		
 		void dispose();
-		
-        memory::HeapManager & getCacheHeapManager() const;
 
 		// ITreeManager
         virtual memory::Segment* getDataSegment(AbsolutePath const& _rAccessor, 
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/types.hxx configmgr/source/inc/types.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/types.hxx	2006-09-29 15:44:58.000000000 +0100
+++ configmgr/source/inc/types.hxx	2006-10-04 10:20:47.000000000 +0100
@@ -55,15 +55,12 @@
 {
 //-----------------------------------------------------------------------------
 
-    namespace memory { class Allocator; class Accessor; }
-    //-----------------------------------------------------------------------------
-
+    namespace memory { class Accessor; };
     namespace sharable
     {
     //-----------------------------------------------------------------------------
     // some base types
         typedef memory::Address  Address;  // points to absolute location in memory segment
-        typedef memory::HeapSize HeapSize; // size of memory block within heap
         typedef sal_uInt16 Offset;  // Offset relative to 'this' in array of nodes
         typedef sal_uInt8  Byte;  
 
@@ -73,21 +70,15 @@
         typedef Address List;    // singly linked intrusive, used for set elements
         typedef Address Vector;   // points to counted sequence of some type
 
-    //-----------------------------------------------------------------------------
-
-        Name allocName(memory::Allocator const& _anAllocator, ::rtl::OUString const & _sString);
-        void freeName(memory::Allocator const& _anAllocator, Name _aName);
-        ::rtl::OUString readName(memory::Accessor const& _anAccessor, Name _aName);
-
-    //-----------------------------------------------------------------------------
-
-        String allocString(memory::Allocator const& _anAllocator, ::rtl::OUString const & _sString);
-        void   freeString(memory::Allocator const& _anAllocator, String _aString);
-        ::rtl::OUString readString(memory::Accessor const& _anAccessor, String _aString);
-
-    //-----------------------------------------------------------------------------
-    }
-//-----------------------------------------------------------------------------
+    // wrappers for string:
+        String allocString(::rtl::OUString const & _sString);
+        void   freeString(String _aString);
+        ::rtl::OUString readString(String _aString);
+
+        Name allocName(::rtl::OUString const & _sString);
+        void freeName(Name _aName);
+        ::rtl::OUString readName(Name _aName);
+     }
 }
 
 
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/updateaccessor.hxx configmgr/source/inc/updateaccessor.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/updateaccessor.hxx	2005-12-28 17:31:29.000000000 +0000
+++ configmgr/source/inc/updateaccessor.hxx	2006-10-04 11:33:16.000000000 +0100
@@ -54,35 +54,13 @@
     // -------------------------------------------------------------------------
         class Segment;
         class SegmentHeap;
-    // -------------------------------------------------------------------------
-
-        class Allocator
-        {
-            SegmentHeap *   m_heap;
-
-        public:
-            typedef memory::Address Address;
-            typedef memory::HeapSize Size;
 
-            Address allocate(Size _sz) const;
-            void deallocate(Address _addr) const;
-
-            void *      access(Address _addr) const;
-            Address     address(void const * _p) const;
-
-        private:
-            friend class UpdateAccessor;
-
-            Allocator(SegmentHeap * _heap) : m_heap(_heap) {}
-            char * heap_base() const;
-        };
     // -------------------------------------------------------------------------
         class UpdateAccessor : Noncopyable
         {
             Segment *       m_segment;
-            SegmentHeap *   m_heap;
         public:
-            typedef Accessor::AddressType AddressType;
+            typedef memory::Address AddressType;
 
             /// constructs an accessor on the given Segment
             explicit UpdateAccessor(Segment * segment);
@@ -95,46 +73,7 @@
             Accessor accessor() const;
             Accessor downgrade(); // return accessor and clear
             void clear();
-
-            AddressType address(void const * _p) const
-            { return (this->is()) ? reduce(_p) : Pointer();}
-
-            void * access(AddressType _p) const
-            { return (this->is()) ? resolve(_p) : Accessor::failNull();}
-
-            void * validate(AddressType _p) const
-            { return (this->is() && _p.is()) ? resolve(_p) : Accessor::failNull(); }
-
-        // allocation support
-            Allocator allocator() const { return Allocator(m_heap); }
-        private:
-            char * heap_base() const;
-            void * resolve(AddressType _p) const;
-            AddressType  reduce(void const * _p) const;
         };
-    // -------------------------------------------------------------------------
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline
-        void * UpdateAccessor::resolve(AddressType _p) const
-        { return _p.is() ? heap_base() + _p.value() : NULL; }
-
-        inline
-        Pointer  UpdateAccessor::reduce(void const * _p) const
-        { return _p ? Pointer(static_cast<char const *>(_p) - heap_base()) : Pointer(); }
-  #endif // OSL_DEBUG_LEVEL
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline
-        void * Allocator::access(Address _addr) const
-        { return _addr ? heap_base() + _addr : NULL; }
-
-        inline
-        Allocator::Address  Allocator::address(void const * _p) const
-        { return _p ? (static_cast<char const *>(_p) - heap_base()) : 0; }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/valuenodeaccess.hxx configmgr/source/inc/valuenodeaccess.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/inc/valuenodeaccess.hxx	2005-09-08 05:02:20.000000000 +0100
+++ configmgr/source/inc/valuenodeaccess.hxx	2006-10-04 12:01:18.000000000 +0100
@@ -110,15 +110,15 @@
             NodeAddressType address()   const { return NodeAddressType(m_pData); }
             Accessor const& accessor()  const { return m_aAccessor; }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            DataType& data() const { return *(NodePointerType)m_pData; }
 
             operator NodeAccessRef() const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
         private:
-            static AddressType check(Accessor const& _acc, NodePointerType _p) { return _acc.address(_p); }
+            static AddressType check(Accessor const&, NodePointerType _p) { return (AddressType)_p; }
             static AddressType check(NodeAccessRef const& _aNodeData);
 
             Accessor    m_aAccessor;
-		    AddressType m_pData;
+	    AddressType m_pData;
         };
 
         ValueNodeAddress toValueNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr);
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/builddata.cxx configmgr/source/tree/builddata.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/builddata.cxx	2006-09-29 15:44:58.000000000 +0100
+++ configmgr/source/tree/builddata.cxx	2006-10-04 11:38:37.000000000 +0100
@@ -97,9 +97,7 @@
     {
     //-------------------------------------------------------------------------
         using namespace sharable;
-        using memory::Pointer;
         using memory::Accessor;
-        using memory::Allocator;
         using memory::UpdateAccessor;
 //-----------------------------------------------------------------------------
 
@@ -109,7 +107,7 @@
     {
         Address aRawAddr = _aNode.addressValue() + _nOffset * sizeof(Node);
 
-        return NodeAddress(Pointer(aRawAddr));
+        return NodeAddress(aRawAddr);
     }
 
     static 
@@ -120,7 +118,7 @@
                             offsetof(TreeFragment,nodes) + 
                             _nOffset * sizeof(Node);
 
-        return NodeAddress(Pointer(aRawAddr));
+        return NodeAddress(aRawAddr);
     }
 
 //-----------------------------------------------------------------------------
@@ -225,7 +223,6 @@
         TreeNodeBuilder&    builder()         { return m_builder; }
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
         TreeNodeBuilder     m_builder;
@@ -396,7 +393,6 @@
     protected:
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
     };
@@ -424,7 +420,6 @@
     private:
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
     };
@@ -643,9 +638,9 @@
 
     OSL_ASSERT(nFragmentSize >= sizeof m_header + m_header.count*sizeof(Node));
 
-    Address aBaseAddress = _anUpdater.allocator().allocate(nFragmentSize);
+    Address aBaseAddress = Address(new sal_uInt8[ nFragmentSize ]);
 
-    TreeAddress aResult = TreeAddress( memory::Pointer(aBaseAddress) );
+    TreeAddress aResult = TreeAddress( aBaseAddress );
 
     if (TreeFragment * pFragment = TreeAccessor::access(aResult,_anUpdater))
     {
@@ -740,7 +735,7 @@
 
     TreeFragment const & aSrc = _aSourceTree.data();
 
-    sharable::String aTreeName = allocString( allocator(), aSrc.getName(_aSourceTree.accessor()));
+    sharable::String aTreeName = allocString( aSrc.getName(_aSourceTree.accessor()));
     this->builder().resetTreeFragment(aTreeName, aSrc.header.state);
     
     this->visitNode(_aSourceTree.getRootNode());
@@ -753,19 +748,19 @@
 {
     sharable::ValueNode const & aSrc = _aNode.data();
 
-    sharable::Name aNodeName = allocName( allocator(), aSrc.info.getName(_aNode.accessor()));
+    sharable::Name aNodeName = allocName( aSrc.info.getName(_aNode.accessor()));
     Flags::Field aFlags = aSrc.info.flags;
 
     AnyData::TypeCode aType = AnyData::TypeCode( aSrc.info.type & Type::mask_valuetype );
 
     AnyData aNewValue, aNewDefault;
     if (aFlags & Flags::valueAvailable)   
-        aNewValue = allocData(allocator(), aType, aSrc.getUserValue(_aNode.accessor()));
+        aNewValue = allocData(aType, aSrc.getUserValue(_aNode.accessor()));
     else
         aNewValue.data = 0;
 
     if (aFlags & Flags::defaultAvailable)   
-        aNewDefault = allocData(allocator(), aType, aSrc.getDefaultValue(_aNode.accessor()));
+        aNewDefault = allocData(aType, aSrc.getDefaultValue(_aNode.accessor()));
     else
         aNewDefault.data = 0;
     
@@ -779,7 +774,7 @@
 {
     sharable::GroupNode const & aSrc = _aNode.data();
 
-    sharable::Name aNodeName = allocName( allocator(), aSrc.info.getName(_aNode.accessor()));
+    sharable::Name aNodeName = allocName( aSrc.info.getName(_aNode.accessor()));
     Flags::Field aFlags = aSrc.info.flags;
 
     Offset nGroupOffset = this->builder().startGroup(aNodeName,aFlags);
@@ -794,7 +789,7 @@
 {
     sharable::SetNode const & aSrc = _aNode.data();
 
-    sharable::Name aNodeName = allocName( allocator(), aSrc.info.getName(_aNode.accessor()));
+    sharable::Name aNodeName = allocName( aSrc.info.getName(_aNode.accessor()));
     Flags::Field aFlags = aSrc.info.flags;
     Address aTemplate = this->makeTemplateData(_aNode.accessor(), aSrc.elementType);
     
@@ -811,7 +806,7 @@
         
 Address CopyingDataTreeBuilder::makeTemplateData(Accessor const & _aSourceAccessor, Address _aSourceTemplate)
 {
-    return SetNode::copyTemplateData(allocator(), _aSourceAccessor, _aSourceTemplate);
+    return SetNode::copyTemplateData(_aSourceAccessor, _aSourceTemplate);
 }
 //-----------------------------------------------------------------------------
 
@@ -848,7 +843,7 @@
         m_sRootName = rtl::OUString();
     }
 
-    return sharable::allocName( allocator(), sNextName);
+    return sharable::allocName( sNextName);
 }
 //-----------------------------------------------------------------------------
 
@@ -857,7 +852,7 @@
     m_sRootName = _aTypeName;
     m_bWithDefaults = _bWithDefaults;
 
-    sharable::String aTreeName = allocString( allocator(), _aNode.getName());
+    sharable::String aTreeName = allocString( _aNode.getName());
     this->builder().resetTreeFragment(aTreeName, makeState(_aNode.getAttributes()));
     
 
@@ -872,7 +867,7 @@
     m_sRootName = OUString();
     m_bWithDefaults = _bWithDefaults;
 
-    sharable::String aTreeName = allocString( allocator(), _aTreeName );
+    sharable::String aTreeName = allocString( _aTreeName );
     this->builder().resetTreeFragment(aTreeName, makeState(_aNode.getAttributes()));
     
 
@@ -924,7 +919,7 @@
         uno::Any aValue = _aNode.getValue();
         if (aValue.hasValue())
         {
-            aNewValue = allocData(allocator(), aType, aValue);
+            aNewValue = allocData(aType, aValue);
             aFlags |= Flags::valueAvailable;
         }
     }
@@ -934,7 +929,7 @@
         uno::Any aDefault = _aNode.getDefault();
         if (aDefault.hasValue())
         {
-            aNewDefault = allocData(allocator(), aType, aDefault);
+            aNewDefault = allocData(aType, aDefault);
             aFlags |= Flags::defaultAvailable;
         }
     }
@@ -1001,7 +996,7 @@
 
 Address ConvertingDataTreeBuilder::makeTemplateData(rtl::OUString const & _aTemplateName, rtl::OUString const & _aTemplateModule)
 {
-    return SetNode::allocTemplateData(allocator(), _aTemplateName, _aTemplateModule );
+    return SetNode::allocTemplateData(_aTemplateName, _aTemplateModule );
 }
 //-----------------------------------------------------------------------------
 
@@ -1198,9 +1193,9 @@
         destroyNode( addressOfNodeAt(_aBaseAddress,i) );
     }
 
-    allocator().deallocate( _aBaseAddress.addressValue() );
+    delete [] (sal_uInt8 *) _aBaseAddress.addressValue();
 
-    return TreeAddress( Pointer(aNext) );
+    return TreeAddress( aNext );
 }
 //-----------------------------------------------------------------------------
 
@@ -1233,7 +1228,7 @@
 
     sharable::String aName = _pHeader->name;
 
-    freeString( allocator(), aName );
+    freeString( aName );
 }
 //-----------------------------------------------------------------------------
 
@@ -1241,13 +1236,13 @@
 {
     Name aName = _pNodeInfo->name;
 
-    if (aName) freeName( allocator(), aName );
+    if (aName) freeName( aName );
 }
 //-----------------------------------------------------------------------------
 
 void DataTreeCleanup::destroyData(sharable::SetNode * _pNode)
 {
-    TreeAddress aElement( Pointer( _pNode->elements ) );
+    TreeAddress aElement( _pNode->elements );
 
     Address aTemplate = _pNode->elementType;;
 
@@ -1256,7 +1251,7 @@
     while (aElement.is())
         aElement = destroyTree(aElement);
 
-    SetNode::releaseTemplateData( allocator(), aTemplate );
+    SetNode::releaseTemplateData( aTemplate );
 }
 //-----------------------------------------------------------------------------
 	
@@ -1275,10 +1270,10 @@
     destroyData(&_pNode->info);
 
     if (aFlags & Flags::valueAvailable) 
-        freeData( allocator(), aValueType, _pNode->value );
+        freeData( aValueType, _pNode->value );
 
     if (aFlags & Flags::defaultAvailable) 
-        freeData( allocator(), aValueType, _pNode->defaultValue );
+        freeData( aValueType, _pNode->defaultValue );
     
 }
 //-----------------------------------------------------------------------------
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/cmtree.cxx configmgr/source/tree/cmtree.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/cmtree.cxx	2005-09-08 05:16:32.000000000 +0100
+++ configmgr/source/tree/cmtree.cxx	2006-10-04 10:22:20.000000000 +0100
@@ -248,13 +248,14 @@
 		SearchNode searchObj(aName);
 
 #if OSL_DEBUG_LEVEL > 1
+#warning This looks -totally- whacked out !
 		for (ChildList::iterator it2 = m_aChildren.GetSet().begin();
 			it2 != m_aChildren.GetSet().end();
 			++it2)
 		{
 			INode* pINode = *it2;
 			OUString aName2 = pINode->getName();
-			volatile int dummy = 0;
+			volatile int sdummy = 0;
 		}
 #endif
 
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/groupnodeaccess.cxx configmgr/source/tree/groupnodeaccess.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/groupnodeaccess.cxx	2005-09-08 05:17:02.000000000 +0100
+++ configmgr/source/tree/groupnodeaccess.cxx	2006-10-04 12:40:00.000000000 +0100
@@ -47,23 +47,19 @@
     namespace data
     {
     // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
 
-        Pointer GroupNodeAccess::check(Accessor const& _aAccessor, sharable::GroupNode const* pInnerNode)
+        GroupNodeAccess::AddressType GroupNodeAccess::check(Accessor const&, sharable::GroupNode const* pInnerNode)
         {
-            return _aAccessor.address(pInnerNode);      
+            return (GroupNodeAccess::AddressType) pInnerNode;
         }
     // -------------------------------------------------------------------------
 
-        Pointer GroupNodeAccess::check(NodeAccessRef const& _aNode)
+        GroupNodeAccess::AddressType GroupNodeAccess::check(NodeAccessRef const& _aNode)
         {
             if (sharable::Node const* pNode = _aNode.getDataPtr())
                 return check(_aNode.accessor(), pNode->groupData());
-
             else
-                return Pointer();
+		return NULL;
         }
     // -------------------------------------------------------------------------
         bool GroupNodeAccess::hasChildren() const
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/nodeaccess.cxx configmgr/source/tree/nodeaccess.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/nodeaccess.cxx	2005-09-08 05:18:25.000000000 +0100
+++ configmgr/source/tree/nodeaccess.cxx	2006-10-04 11:52:08.000000000 +0100
@@ -65,9 +65,9 @@
     {
     // -------------------------------------------------------------------------
         
-        NodeAddress::DataType* NodeAccess::access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor& _rUpdateAccess)
+        NodeAddress::DataType* NodeAccess::access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor&)
         { 
-            return static_cast<NodeAddress::DataType*>(_rUpdateAccess.access(_aNodeRef.m_pData)); 
+            return (NodeAddress::DataType *)_aNodeRef.addressValue();
         }
     // -------------------------------------------------------------------------
 
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/node.cxx configmgr/source/tree/node.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/node.cxx	2006-09-29 15:44:58.000000000 +0100
+++ configmgr/source/tree/node.cxx	2006-10-04 11:48:06.000000000 +0100
@@ -77,9 +77,9 @@
     //        Flags::Field    flags;
       //      Type ::Field    type;   // contains discriminator for union
 
-rtl::OUString NodeInfo::getName(memory::Accessor const & _aAccessor) const
+rtl::OUString NodeInfo::getName(memory::Accessor const &) const
 {
-    return readName(_aAccessor,this->name);
+    return readName(this->name);
 }
 //-----------------------------------------------------------------------------
 
@@ -223,62 +223,49 @@
 };
 //-----------------------------------------------------------------------------
 static inline
-SetNodeTemplateData * readTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData)
+SetNodeTemplateData * readTemplateData(Address _aTemplateData)
 {
-    return static_cast<SetNodeTemplateData *>( _anAllocator.access(_aTemplateData) );
+    return (SetNodeTemplateData *) _aTemplateData;
 }
 //-----------------------------------------------------------------------------
 static inline
-SetNodeTemplateData const * readTemplateData(memory::Accessor const & _anAccessor, Address _aTemplateData)
+SetNodeTemplateData const * readTemplateData(memory::Accessor const &, Address _aTemplateData)
 {
-    return static_cast<SetNodeTemplateData const*>( _anAccessor.access(memory::Pointer(_aTemplateData)) );
+    return (SetNodeTemplateData const*)_aTemplateData;
 }
 //-----------------------------------------------------------------------------
 
-Address SetNode::allocTemplateData(memory::Allocator const & _anAllocator,
-								   const rtl::OUString &rName,
-								   const rtl::OUString &rModule)
+Address SetNode::allocTemplateData(const rtl::OUString &rName,
+				   const rtl::OUString &rModule)
 {
-    Address aData = _anAllocator.allocate(sizeof(SetNodeTemplateData));
+    SetNodeTemplateData *pData = new SetNodeTemplateData();
 
-    if (aData)
-    {
-        SetNodeTemplateData * pData = readTemplateData(_anAllocator,aData);
+    pData->name   = allocName(rName);
+    pData->module = allocName(rModule);
 
-        OSL_ENSURE(pData, "Creating template data: unexpected NULL data");
-    
-        pData->name   = allocName(_anAllocator,rName);
-        pData->module = allocName(_anAllocator,rModule);
-    }
-    return aData;
+    return (Address)pData;
 }
 
-Address SetNode::copyTemplateData(memory::Allocator const & _anAllocator, 
-								  memory::Accessor const & _aSourceAccessor,
-								  Address _aTemplateData)
+Address SetNode::copyTemplateData(memory::Accessor const &,
+				  Address _aTemplateData)
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAllocator,_aTemplateData);
+    SetNodeTemplateData const * pData = (SetNodeTemplateData const *)_aTemplateData;
 
-    OSL_ENSURE(pData, "Freeing template data: unexpected NULL data");
-
-    return allocTemplateData(_anAllocator, readName(_aSourceAccessor, pData->name),
-							 readName(_aSourceAccessor, pData->module));
+    return allocTemplateData(readName(pData->name), readName(pData->module));
 }
 
 //-----------------------------------------------------------------------------
 
-void SetNode::releaseTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData)
+void SetNode::releaseTemplateData(Address _aTemplateData)
 {
     if (!_aTemplateData) return;
 
-    SetNodeTemplateData const * pData = readTemplateData(_anAllocator,_aTemplateData);
+    SetNodeTemplateData const * pData = (SetNodeTemplateData const *)_aTemplateData;
 
-    OSL_ENSURE(pData, "Freeing template data: unexpected NULL data");
-    
-    freeName(_anAllocator,pData->name);
-    freeName(_anAllocator,pData->module);
+    freeName(pData->name);
+    freeName(pData->module);
 
-    _anAllocator.deallocate(_aTemplateData);
+    delete pData;
 }
 
 //-----------------------------------------------------------------------------
@@ -289,7 +276,7 @@
 
     OSL_ENSURE(pData, "ERROR: No template data found for set");
     
-    return readName(_anAccessor,pData->name);
+    return readName(pData->name);
 }
 //-----------------------------------------------------------------------------
 
@@ -299,30 +286,29 @@
 
     OSL_ENSURE(pData, "ERROR: No template data found for set");
     
-    return readName(_anAccessor,pData->module);
+    return readName(pData->module);
 }
 //-----------------------------------------------------------------------------
 
 static inline
-TreeFragment const * implGetFragmentFromList(memory::Accessor const & _anAccessor, List _aListEntry)
+TreeFragment const * implGetFragmentFromList(List _aListEntry)
 {
-    return static_cast<TreeFragment const *>(_anAccessor.access(memory::Pointer(_aListEntry)));
+    return (TreeFragment const *)_aListEntry;
 }
 //-----------------------------------------------------------------------------
 
-TreeFragment const  * SetNode::getFirstElement(memory::Accessor const & _anAccessor) const   
+TreeFragment const  * SetNode::getFirstElement(memory::Accessor const &) const   
 {
-    return implGetFragmentFromList(_anAccessor, this->elements);
+    return implGetFragmentFromList(this->elements);
 }
 //-----------------------------------------------------------------------------
 
-TreeFragment const  * SetNode::getNextElement(memory::Accessor const & _anAccessor, TreeFragment const * _pElement) const    
+TreeFragment const  * SetNode::getNextElement(memory::Accessor const &, TreeFragment const * _pElement) const    
 {
-    OSL_PRECOND(_pElement, "getNextElement: previous element must not be NULL");
-    OSL_PRECOND(_pElement->header.parent == _anAccessor.address(this).value(), 
+    OSL_PRECOND(_pElement->header.parent == (memory::Address) this, 
                 "getNextElement: not an element of this node");
 
-    return implGetFragmentFromList(_anAccessor, _pElement->header.next);
+    return implGetFragmentFromList(_pElement->header.next);
 }
 //-----------------------------------------------------------------------------
 
@@ -395,9 +381,9 @@
 }
 //-----------------------------------------------------------------------------
 
-bool Node::isNamed(rtl::OUString const & _aName, memory::Accessor const & _aAccessor) const
+bool Node::isNamed(rtl::OUString const & _aName, memory::Accessor const &) const
 {
-    return _aName == readName(_aAccessor,node.info.name);
+    return _aName == readName(node.info.name);
 }
 //-----------------------------------------------------------------------------
 
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/setnodeaccess.cxx configmgr/source/tree/setnodeaccess.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/setnodeaccess.cxx	2005-09-08 05:19:12.000000000 +0100
+++ configmgr/source/tree/setnodeaccess.cxx	2006-10-04 12:40:09.000000000 +0100
@@ -54,22 +54,18 @@
     namespace data
     {
     // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-        Pointer SetNodeAccess::check(Accessor const& _aAccessor, sharable::SetNode const* pInnerNode)
+        SetNodeAccess::AddressType SetNodeAccess::check(Accessor const&, sharable::SetNode const* pInnerNode)
         {
-            return _aAccessor.address(pInnerNode);      
+            return (SetNodeAccess::AddressType) pInnerNode;
         }
     // -------------------------------------------------------------------------
 
-        Pointer SetNodeAccess::check(NodeAccessRef const& _aNode)
+        SetNodeAccess::AddressType SetNodeAccess::check(NodeAccessRef const& _aNode)
         {
             if (sharable::Node const* pNode = _aNode.getDataPtr())
                 return check(_aNode.accessor(),pNode->setData());
-
             else
-                return Pointer();
+                return NULL;
         }
     // -------------------------------------------------------------------------
     
@@ -95,7 +91,7 @@
         {
             using namespace sharable;
 
-            SetNode * pNode = static_cast<SetNode *>( _aAccessor.access( _aSetAddress.m_pData) );
+            SetNode * pNode = (SetNode *)_aSetAddress.m_pData;
             OSL_ENSURE(pNode, "ERROR: Trying to add an element to a NULL set node");
 
             // To do (?): insert sorted - find location here
@@ -103,7 +99,7 @@
             OSL_ENSURE(pElement, "ERROR: Trying to add a NULL element to a set node");
 
             pElement->header.next   = pNode->elements;
-            pElement->header.parent = _aSetAddress.m_pData.value();
+            pElement->header.parent = _aSetAddress.m_pData;
 
             pNode->elements = _aNewElement.addressValue();
         }
@@ -112,22 +108,19 @@
         TreeAddress SetNodeAccess::removeElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, Name const & _aName)
         {
             using namespace sharable;
-            using memory::Pointer;
-            
             memory::Accessor _aReadAccessor = _aAccessor.accessor();
 
-            SetNode * pNode = static_cast<SetNode *>( _aAccessor.access( _aSetAddress.m_pData) );
+            SetNode * pNode = (SetNode *)_aSetAddress.m_pData;
             OSL_ENSURE(pNode, "ERROR: Trying to add an element to a NULL set node");
 
             TreeAddress aRemoved;
             
             List * pLink = & pNode->elements;
-            while( TreeFragment * pElement = static_cast<TreeFragment *>(_aAccessor.access(Pointer(*pLink))) )
+            while( TreeFragment * pElement = (TreeFragment *)(*pLink) )
             {
                 if (pElement->isNamed(_aName.toString(), _aReadAccessor))
                 {
-                    aRemoved = TreeAddress( Pointer(*pLink) );
-                   // aRemoved = TreeAccessor(_aReadAccessor,pElement).address();
+                    aRemoved = TreeAddress( *pLink );
 
                     *pLink = pElement->header.next;
                     pElement->header.next   = 0;
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/treeaccessor.cxx configmgr/source/tree/treeaccessor.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/treeaccessor.cxx	2005-09-08 05:19:41.000000000 +0100
+++ configmgr/source/tree/treeaccessor.cxx	2006-10-04 11:59:29.000000000 +0100
@@ -56,15 +56,15 @@
     // -------------------------------------------------------------------------
         TreeAccessor::TreeAccessor()
         : m_aAccessor(NULL)
-        , m_pBase( memory::Pointer() )
+        , m_pBase( NULL )
         {
         }
 
     // -------------------------------------------------------------------------
 
-        TreeAddress::DataType* TreeAccessor::access(DataAddressType const& _aTreeRef, memory::UpdateAccessor& _rUpdateAccess)
+        TreeAddress::DataType* TreeAccessor::access(DataAddressType const& _aTreeRef, memory::UpdateAccessor&)
         { 
-            return static_cast<TreeAddress::DataType*>(_rUpdateAccess.access(_aTreeRef.m_pData)); 
+            return (TreeAddress::DataType *)_aTreeRef.m_pData;
         }
     // -------------------------------------------------------------------------
         TreeAddress TreeAccessor::copyTree(memory::UpdateAccessor & _aTargetSpace) const
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/treefragment.cxx configmgr/source/tree/treefragment.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/treefragment.cxx	2005-09-08 05:20:23.000000000 +0100
+++ configmgr/source/tree/treefragment.cxx	2006-10-04 10:37:43.000000000 +0100
@@ -49,9 +49,9 @@
     namespace sharable
     {
 //-----------------------------------------------------------------------------
-rtl::OUString TreeFragment::getName(memory::Accessor const & _aAccessor) const
+rtl::OUString TreeFragment::getName(memory::Accessor const &) const
 {
-    return readString(_aAccessor,this->header.name);
+    return readString(this->header.name);
 }
 //-----------------------------------------------------------------------------
 
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/treesegment.cxx configmgr/source/tree/treesegment.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/treesegment.cxx	2005-09-08 05:20:50.000000000 +0100
+++ configmgr/source/tree/treesegment.cxx	2006-10-04 12:40:17.000000000 +0100
@@ -69,23 +69,14 @@
     namespace data
     {
 // -----------------------------------------------------------------------------	
-
-//        typedef std::auto_ptr<INode> RawTreeData;
-//        typedef configuration::Name  Name;
-        using memory::Pointer;
-
-// -----------------------------------------------------------------------------	
-// -----------------------------------------------------------------------------	
 struct TreeSegment::Impl : salhelper::SimpleReferenceObject
 {
-    Impl() : data( memory::localHeap() ), base() {}
+    Impl() : data(), base() {}
     ~Impl();
 
     memory::Segment     data;
     data::TreeAddress   base;
 };
-// -----------------------------------------------------------------------------	
-// -----------------------------------------------------------------------------	
 
 // -----------------------------------------------------------------------------	
 TreeSegment::TreeSegment()
@@ -244,11 +235,11 @@
 
         sharable::String aOldName = getTreeDataForUpdate(aUpdater)->header.name;
 
-        sharable::String aNewName = sharable::allocString(aUpdater.allocator(),_aNewName.toString());
+        sharable::String aNewName = sharable::allocString(_aNewName.toString());
 
         getTreeDataForUpdate(aUpdater)->header.name = aNewName;
 
-        sharable::freeString(aUpdater.allocator(),aOldName);
+        sharable::freeString(aOldName);
     }
 }
 // -----------------------------------------------------------------------------	
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/valuenodeaccess.cxx configmgr/source/tree/valuenodeaccess.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/tree/valuenodeaccess.cxx	2006-06-20 00:30:52.000000000 +0100
+++ configmgr/source/tree/valuenodeaccess.cxx	2006-10-04 12:10:32.000000000 +0100
@@ -51,29 +51,24 @@
     namespace data
     {
     // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-        static 
-        ValueNodeAddress::DataType* accessValue(Pointer const& _p, memory::UpdateAccessor& _rUpdateAccess)
+	static inline
+	ValueNodeAddress::DataType* accessValue(ValueNodeAddress::AddressType _p)
         {
-            return static_cast<ValueNodeAddress::DataType*>( _rUpdateAccess.validate(_p) );
+            return (ValueNodeAddress::DataType *) _p;
         }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
 
-        Pointer ValueNodeAccess::check(NodeAccessRef const& _aNode)
+        ValueNodeAddress::AddressType ValueNodeAccess::check(NodeAccessRef const& _aNode)
         {
             if (sharable::Node const* pNode = _aNode.getDataPtr())
-                return _aNode.accessor().address(pNode->valueData());
-
+                return (ValueNodeAddress::AddressType) pNode->valueData();
             else
-                return Pointer();
+		return NULL;
         }
     // -------------------------------------------------------------------------
 		    
-void ValueNodeAccess::setValue(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue)
+void ValueNodeAccess::setValue(memory::UpdateAccessor &, NodeAddressType _aValueNode, uno::Any const& _aValue)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = accessValue(_aValueNode.m_pData);
 
     using namespace sharable;
     AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
@@ -83,8 +78,8 @@
     {
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->value);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->value);
+        node = accessValue(_aValueNode.m_pData);
 
         node->value.data = 0;
         node->info.flags ^= Flags::valueAvailable;
@@ -111,8 +106,8 @@
         if (aType == aNewType)
         {
             // store the data
-            sharable::AnyData aNewData = allocData(_aUpdater.allocator(),aType,_aValue);
-            node = accessValue(_aValueNode.m_pData,_aUpdater);
+            sharable::AnyData aNewData = allocData(aType,_aValue);
+            node = accessValue(_aValueNode.m_pData);
 
             node->value = aNewData;
             node->info.flags |= Flags::valueAvailable;
@@ -122,9 +117,9 @@
 }
 //-----------------------------------------------------------------------------
 
-void ValueNodeAccess::setToDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode)
+void ValueNodeAccess::setToDefault(memory::UpdateAccessor &, NodeAddressType _aValueNode)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = accessValue(_aValueNode.m_pData);
 
     using namespace sharable;
     OSL_ENSURE(node->hasUsableDefault(), "ERROR: setToDefault() - Value does not have a default");
@@ -135,8 +130,8 @@
         AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->value);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->value);
+        node = accessValue(_aValueNode.m_pData);
 
         node->value.data = 0;
         node->info.flags ^= Flags::valueAvailable;
@@ -146,9 +141,9 @@
 }
 //-----------------------------------------------------------------------------
 
-void ValueNodeAccess::changeDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue)
+void ValueNodeAccess::changeDefault(memory::UpdateAccessor &, NodeAddressType _aValueNode, uno::Any const& _aValue)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = accessValue(_aValueNode.m_pData);
 
     using namespace sharable;
     AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
@@ -158,8 +153,8 @@
     {
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->defaultValue);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->defaultValue);
+        node = accessValue(_aValueNode.m_pData);
 
         node->defaultValue.data = 0;
         node->info.flags ^= Flags::defaultAvailable;
@@ -186,8 +181,8 @@
         if (aType == aNewType)
         {
             // store the data
-            sharable::AnyData aNewData = allocData(_aUpdater.allocator(),aType,_aValue);
-            node = accessValue(_aValueNode.m_pData,_aUpdater);
+            sharable::AnyData aNewData = allocData(aType,_aValue);
+            node = accessValue(_aValueNode.m_pData);
 
             node->defaultValue = aNewData;
             node->info.flags |= Flags::defaultAvailable;
@@ -195,32 +190,7 @@
     }
 }
 
-//-----------------------------------------------------------------------------
-/*
-void ValueNode::clearData(data::Allocator const & _aAlloc)
-{
-    AnyData::TypeCode aType = info.type & Type::mask_valuetype;
-
-    if (info.flags & Flags::valueAvailable)
-    {
-        OSL_ASSERT(aType != Type::value_any);
-        freeData(_aAlloc,aType,this->value);
-        info.flags ^= Flags::valueAvailable;
-        this->value.data = 0;
-    }
-
-    if (info.flags & Flags::defaultAvailable)
-    {
-        OSL_ASSERT(aType != Type::value_any);
-        freeData(_aAlloc,aType,this->defaultValue);
-        info.flags ^= Flags::defaultAvailable;
-        this->defaultValue.data = 0;
-    }
-}
-*/
-//-----------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
+    } // namespace data
 } // namespace configmgr
 
 
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cacheaccess.cxx configmgr/source/treecache/cacheaccess.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cacheaccess.cxx	2005-09-08 05:21:33.000000000 +0100
+++ configmgr/source/treecache/cacheaccess.cxx	2006-10-03 16:34:57.000000000 +0100
@@ -59,10 +59,8 @@
 
 // -------------------------------------------------------------------------
 
-CacheClientAccess::CacheClientAccess(memory::HeapManager & _rHeapManager,
-                                     ConfigChangeBroadcastHelper *  _pBroadcastHelper)
+CacheClientAccess::CacheClientAccess(ConfigChangeBroadcastHelper *  _pBroadcastHelper)
 : m_aMutex()
-, m_aData(_rHeapManager)
 , m_pBroadcastHelper( _pBroadcastHelper )
 {
 }
@@ -207,9 +205,8 @@
 // -------------------------------------------------------------------------
 // -------------------------------------------------------------------------
 
-CacheLoadingAccess::CacheLoadingAccess(memory::HeapManager & _rHeapManager)
+CacheLoadingAccess::CacheLoadingAccess()
 : m_aMutex()
-, m_aData(_rHeapManager)
 , m_aDeadModules()
 {
 }
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cacheaccess.hxx configmgr/source/treecache/cacheaccess.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cacheaccess.hxx	2005-09-08 05:21:46.000000000 +0100
+++ configmgr/source/treecache/cacheaccess.hxx	2006-10-03 16:34:40.000000000 +0100
@@ -82,8 +82,7 @@
 		ConfigChangeBroadcastHelper* m_pBroadcastHelper;
 	public:
         explicit
-		CacheClientAccess(memory::HeapManager & _rHeapManager,
-                          ConfigChangeBroadcastHelper* _pBroadcastHelper);
+		CacheClientAccess(ConfigChangeBroadcastHelper* _pBroadcastHelper);
 
 		~CacheClientAccess();
 		
@@ -148,7 +147,7 @@
 		DeadModuleList		m_aDeadModules;			/// list of nodes which are registered for throwing away
 	public:
         explicit
-		CacheLoadingAccess(memory::HeapManager & _rHeapManager);
+		CacheLoadingAccess();
 		~CacheLoadingAccess();
 		
         /// gets a data segment reference for the given path if exists
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cachecontroller.cxx configmgr/source/treecache/cachecontroller.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cachecontroller.cxx	2006-06-20 00:31:07.000000000 +0100
+++ configmgr/source/treecache/cachecontroller.cxx	2006-10-04 14:07:02.000000000 +0100
@@ -144,7 +144,7 @@
     CacheRef aResult = m_aCacheList.get(_aOptions);
     if (!aResult.is())
     {
-        CacheRef aNewCache( new Cache(getCacheHeapManager()) );
+        CacheRef aNewCache( new Cache() );
         aResult = m_aCacheList.insert(_aOptions,aNewCache);
     }
     return aResult;
@@ -152,12 +152,6 @@
 
 // -------------------------------------------------------------------------
 
-memory::HeapManager & CacheController::getCacheHeapManager() const
-{
-    return m_aTemplates.getHeapManager();
-}
-// -------------------------------------------------------------------------
-
 // disposing
 // -------------------------------------------------------------------------
 void CacheController::disposeAll(bool _bFlushRemainingUpdates)
@@ -340,12 +334,11 @@
 
 // -------------------------------------------------------------------------
 CacheController::CacheController(BackendRef const & _xBackend, 
-								 memory::HeapManager & _rCacheHeapManager,
 								 const uno::Reference<uno::XComponentContext>& xContext)
 : m_aNotifier()
 , m_xBackend(_xBackend)
 , m_aCacheList()
-, m_aTemplates(_rCacheHeapManager)
+, m_aTemplates()
 , m_pDisposer()
 , m_pCacheWriter()
 , m_bDisposing(false)
@@ -406,16 +399,16 @@
 // -------------------------------------------------------------------------
 
 static
-CacheLocation makeCacheLocation(memory::SegmentAddress const & _aSegment, memory::Heap::Address const & _anAddress)
+CacheLocation makeCacheLocation(memory::SegmentAddress const & _aSegment, memory::Address const & _anAddress)
 {
-    OSL_PRECOND(!_aSegment.isNull() || _anAddress == 0,"ERROR: Got Non-null address for NULL segment ?!");
+    OSL_PRECOND(_aSegment != NULL || _anAddress == 0,"ERROR: Got Non-null address for NULL segment ?!");
 
     CacheLocation aResult;
 
     aResult.segment = _aSegment;
     aResult.address = _anAddress;
 
-    OSL_ASSERT(!_aSegment.isNull() || aResult.isNull());
+    OSL_ASSERT(_aSegment != NULL || aResult.isNull());
 
     return aResult;
 }
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cachecontroller.hxx configmgr/source/treecache/cachecontroller.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cachecontroller.hxx	2005-09-08 05:22:14.000000000 +0100
+++ configmgr/source/treecache/cachecontroller.hxx	2006-10-03 16:35:12.000000000 +0100
@@ -96,7 +96,6 @@
 		*/
         explicit
         CacheController(BackendRef const & _xBackend, 
-						memory::HeapManager & _rCacheHeapManager,
 						const uno::Reference<uno::XComponentContext>& xContext);
 
     // ICachedDataProvider implementation
@@ -309,8 +308,6 @@
 	protected:
 		// ref counted, that's why no public dtor
 		~CacheController();
-
-        memory::HeapManager & getCacheHeapManager() const;
     // implementation 
     private:
         typedef CacheLoadingAccess      Cache;
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cachedata.cxx configmgr/source/treecache/cachedata.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cachedata.cxx	2005-09-08 05:22:31.000000000 +0100
+++ configmgr/source/treecache/cachedata.cxx	2006-10-03 16:36:36.000000000 +0100
@@ -124,8 +124,7 @@
 
 // -----------------------------------------------------------------------------
 	
-	CacheData::CacheData(memory::HeapManager & _rHeapManager)
-    : m_rHeapManager(_rHeapManager)
+	CacheData::CacheData()
 	{
 	}
 // -----------------------------------------------------------------------------
@@ -172,7 +171,7 @@
 
     CacheLineRef CacheData::internalAttachModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
 	{
-        CacheLineRef aNewModule = doCreateAttachedModule(this->internalHeapManager(), _aLocation,_aName);
+        CacheLineRef aNewModule = doCreateAttachedModule(_aLocation,_aName);
 
 		internalAddModule( _aName, aNewModule );
 		
@@ -189,9 +188,9 @@
     }
 // -------------------------------------------------------------------------
 
-    CacheLineRef CacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef CacheData::doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
     {
-        return CacheLine::createAttached( _aName, _rHeapManager, _aLocation ); 
+        return CacheLine::createAttached( _aName, _aLocation ); 
     }
 // -----------------------------------------------------------------------------
 
@@ -426,10 +425,10 @@
 	}
 // -----------------------------------------------------------------------------
 
-    CacheLineRef TemplateCacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef TemplateCacheData::doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
     {
         CacheLineRef aNewModule = 
-            CacheLine::createAttached(_aName, _rHeapManager, _aLocation);
+            CacheLine::createAttached(_aName, _aLocation);
 
         return aNewModule.get();
     }
@@ -437,8 +436,7 @@
 
 	CacheLineRef TemplateCacheData::implNewCacheLine(const ModuleName& _aModule) CFG_UNO_THROW_RTE(  )
 	{
-        CacheLineRef aNewModule = 
-            CacheLine::createNew(_aModule, this->internalHeapManager());
+        CacheLineRef aNewModule = CacheLine::createNew(_aModule);
 
 		internalAddModule( _aModule, aNewModule.get() );
 
@@ -456,10 +454,10 @@
 
 // -----------------------------------------------------------------------------
 
-    CacheLineRef ExtendedCacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef ExtendedCacheData::doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
     {
         ExtendedCacheLineRef aNewModule = 
-            ExtendedCacheLine::createAttached(_aName, _rHeapManager, _aLocation);
+            ExtendedCacheLine::createAttached(_aName, _aLocation);
 
         return CacheLineRef( aNewModule.get() );
     }
@@ -467,8 +465,7 @@
 
 	ExtendedCacheLineRef ExtendedCacheData::implNewCacheLine(const ModuleName& _aModule) CFG_UNO_THROW_RTE(  )
 	{
-        ExtendedCacheLineRef aNewModule = 
-            ExtendedCacheLine::createNew(_aModule, this->internalHeapManager());
+        ExtendedCacheLineRef aNewModule = ExtendedCacheLine::createNew(_aModule);
 
 		internalAddModule( _aModule, aNewModule.get() );
 
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cachedata.hxx configmgr/source/treecache/cachedata.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cachedata.hxx	2005-09-08 05:22:46.000000000 +0100
+++ configmgr/source/treecache/cachedata.hxx	2006-10-03 16:34:25.000000000 +0100
@@ -75,7 +75,7 @@
         typedef CacheLine::Path     Path;
         typedef CacheLine::Name     ModuleName;
 	public:
-		CacheData(memory::HeapManager & _rHeapManager);
+		CacheData();
 		virtual ~CacheData();
 
 		/// retrieve the module tree name for the given path
@@ -120,9 +120,8 @@
         typedef std::map<ModuleName, ModuleRef> ModuleList;
 		ModuleList& accessModuleList() { return m_aModules; }
 
-        memory::HeapManager & getHeapManager() const { return m_rHeapManager; }
 	protected:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual ModuleRef doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
 
         data::TreeAddress internalGetPartialTree(memory::Accessor const & _aAccessor, Path const & _aPath ) const;
 		data::NodeAddress internalGetNode(memory::Accessor const & _aAccessor, const Path& _rPath) const;
@@ -133,11 +132,8 @@
 		ModuleRef internalGetModule(const ModuleName& _aName) const;
 		ModuleRef internalGetModule(const Path& _aLocation) const;
 
-        memory::HeapManager & internalHeapManager() { return m_rHeapManager; }
 	private:
 		ModuleList m_aModules;
-
-        memory::HeapManager & m_rHeapManager;
 	};
 ////////////////////////////////////////////////////////////////////////////////
 	/** A collection of CacheLines for templates
@@ -146,8 +142,7 @@
     class TemplateCacheData : public CacheData	
 	{
 	public:
-		TemplateCacheData(memory::HeapManager & _rHeapManager)
-        : CacheData(_rHeapManager)
+		TemplateCacheData() : CacheData()
         {
         }
 
@@ -162,7 +157,7 @@
                                        ) CFG_UNO_THROW_RTE();
 
 	private:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual ModuleRef doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
 
 		CacheLineRef implNewCacheLine(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
 	};
@@ -173,8 +168,7 @@
     class ExtendedCacheData : public CacheData	
 	{
 	public:
-		ExtendedCacheData(memory::HeapManager & _rHeapManager)
-        : CacheData(_rHeapManager)
+		ExtendedCacheData() : CacheData()
         {
         }
 
@@ -200,7 +194,7 @@
 		/// remove and return pending changes for the given component
 		std::auto_ptr<SubtreeChange> releasePending(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
 	private:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual ModuleRef doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
 
 		ExtendedCacheLineRef implNewCacheLine(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
 
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cachefactory.cxx configmgr/source/treecache/cachefactory.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cachefactory.cxx	2005-09-08 05:23:00.000000000 +0100
+++ configmgr/source/treecache/cachefactory.cxx	2006-10-03 16:36:53.000000000 +0100
@@ -63,12 +63,10 @@
 
         if (_xBackend.is())
         {
-            memory::HeapManager & rHeap = memory::cacheHeap();
-
             rtl::Reference< backend::ICachedDataProvider > xLoader
-                = new backend::CacheController(_xBackend.get(),rHeap, _xContext);
+                = new backend::CacheController(_xBackend.get(), _xContext);
 
-            xCache.set( new TreeManager(xLoader.get(),rHeap) );
+            xCache.set( new TreeManager(xLoader.get()) );
         }
 
         return xCache;
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cacheline.cxx configmgr/source/treecache/cacheline.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cacheline.cxx	2005-09-08 05:23:13.000000000 +0100
+++ configmgr/source/treecache/cacheline.cxx	2006-10-04 14:08:42.000000000 +0100
@@ -77,8 +77,8 @@
 
 // -----------------------------------------------------------------------------	
 
-    CacheLine::CacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl)
-    : m_storage(_rHeapImpl  )
+    CacheLine::CacheLine(Name const & _aModuleName)
+    : m_storage()
     , m_base()
     , m_name(_aModuleName)
     , m_nDataRefs(0)
@@ -86,10 +86,10 @@
 	}
 // -----------------------------------------------------------------------------	
 	
-    CacheLine::CacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+    CacheLine::CacheLine(Name const & _aModuleName, 
                             memory::SegmentAddress const & _aSegment)
-    : m_storage(_rHeapImpl,_aSegment.id)
-    , m_base( memory::Pointer(_aSegment.base) )
+    : m_storage()
+    , m_base(_aSegment)
     , m_name(_aModuleName)
     , m_nDataRefs(0)
 	{
@@ -98,12 +98,7 @@
 
     memory::SegmentAddress CacheLine::getDataSegmentAddress() const
     {
-        memory::SegmentAddress aResult;
-
-        aResult.id      = m_storage.getId();
-        aResult.base    = m_base.addressValue();
-
-        return aResult;
+	return m_base.addressValue();
     }
 
 // -----------------------------------------------------------------------------
@@ -117,7 +112,6 @@
 // -----------------------------------------------------------------------------
    
     CacheLineRef CacheLine::createAttached( Name const & _aModuleName, 
-                                            memory::HeapManager & _rHeapImpl, 
                                             memory::SegmentAddress const & _aSegment
                                           ) CFG_UNO_THROW_RTE(  )
 	{
@@ -126,20 +120,19 @@
 			OSL_ENSURE(false, "Cannot make a cache line without a name");
 			return NULL;
 		}
-		if (_aSegment.isNull())
+		if (_aSegment == NULL)
 		{
 			OSL_ENSURE(false, "Cannot attach a cache line to a NULL segment");
 			return NULL;
 		}
 
-		CacheLineRef xResult = new CacheLine(_aModuleName,_rHeapImpl,_aSegment);
+		CacheLineRef xResult = new CacheLine(_aModuleName,_aSegment);
 
 		return xResult;
 	}
 // -----------------------------------------------------------------------------
  
-    CacheLineRef CacheLine::createNew(  Name const & _aModuleName, 
-                                        memory::HeapManager & _rHeapImpl
+    CacheLineRef CacheLine::createNew(  Name const & _aModuleName
                                       ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -148,7 +141,7 @@
 			return NULL;
 		}
 
-		CacheLineRef xResult = new CacheLine(_aModuleName,_rHeapImpl);
+		CacheLineRef xResult = new CacheLine(_aModuleName);
 
 		return xResult;
 	}
@@ -193,7 +186,7 @@
 
 		Path::Iterator it = aConfigName.begin();
 		OSL_ENSURE( it != aConfigName.end(), "Empty Path can't match any module");
-		OSL_ENSURE( aNode.getName() == it->getInternalName(), "Module part in config path does not match selected CacheLine");
+		OSL_ENSURE( aNode.isValid() && aNode.getName() == it->getInternalName(), "Module part in config path does not match selected CacheLine");
 
         // find child of node
         // might be done using a visitor
@@ -251,17 +244,17 @@
 // -----------------------------------------------------------------------------	
 // -----------------------------------------------------------------------------	
 
-    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl)
-    : CacheLine(_aModuleName,_rHeapImpl)
+    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName)
+    : CacheLine(_aModuleName)
     , m_pPending()
 	{
 	}
 
 // -----------------------------------------------------------------------------	
 
-    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName,
                                             memory::SegmentAddress const & _aSegment)
-    : CacheLine(_aModuleName,_rHeapImpl,_aSegment)
+    : CacheLine(_aModuleName,_aSegment)
     , m_pPending()
 	{
 	}
@@ -269,7 +262,6 @@
 // -----------------------------------------------------------------------------
   
     ExtendedCacheLineRef ExtendedCacheLine::createAttached( Name const & _aModuleName, 
-                                                            memory::HeapManager & _rHeapImpl, 
                                                             memory::SegmentAddress const & _aSegment
                                                           ) CFG_UNO_THROW_RTE(  )
 	{
@@ -278,20 +270,19 @@
 			OSL_ENSURE(false, "Cannot make a cache line without a name");
 			return NULL;
 		}
-		if (_aSegment.isNull())
+		if (_aSegment == NULL)
 		{
 			OSL_ENSURE(false, "Cannot attach a cache line to a NULL segment");
 			return NULL;
 		}
 
-		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_rHeapImpl,_aSegment);
+		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_aSegment);
 
 		return xResult;
 	}
 // -----------------------------------------------------------------------------
  
-    ExtendedCacheLineRef ExtendedCacheLine::createNew(  Name const & _aModuleName, 
-                                                        memory::HeapManager & _rHeapImpl
+ExtendedCacheLineRef ExtendedCacheLine::createNew(  Name const & _aModuleName
                                                       ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -300,7 +291,7 @@
 			return NULL;
 		}
 
-		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_rHeapImpl);
+		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName);
 
 		return xResult;
 	}
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cacheline.hxx configmgr/source/treecache/cacheline.hxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/cacheline.hxx	2005-09-08 05:23:30.000000000 +0100
+++ configmgr/source/treecache/cacheline.hxx	2006-10-03 16:32:50.000000000 +0100
@@ -81,11 +81,11 @@
 
         // create a new CacheLine for the given component name
         static rtl::Reference<CacheLine> 
-            createNew( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+            createNew( Name const & _aModuleName ); 
        
         // create a new CacheLine attached to the given memory location
         static rtl::Reference<CacheLine> 
-            createAttached( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+            createAttached( Name const & _aModuleName, 
                             memory::SegmentAddress const & _aLocation ); 
        
         memory::Segment * getDataSegment();
@@ -123,12 +123,12 @@
     protected:
         // create a new CacheLine attached to the given memory location
         explicit 
-        CacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+        CacheLine( Name const & _aModuleName,
                     memory::SegmentAddress const & _aLocation ); 
        
         // create a new empty CacheLine for the given component name
         explicit 
-        CacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+        CacheLine( Name const & _aModuleName );
 
         data::NodeAccess internalGetNode(memory::Accessor const & _anAccessor, Path const & _rPath) const;
 
@@ -152,11 +152,11 @@
 	public:
         // create a new CacheLine for the given component name
         static rtl::Reference<ExtendedCacheLine> 
-            createNew( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+            createNew( Name const & _aModuleName ); 
        
         // create a new CacheLine attached to the given memory location
         static rtl::Reference<ExtendedCacheLine> 
-            createAttached( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+            createAttached( Name const & _aModuleName,
                             memory::SegmentAddress const & _aLocation ); 
        
     // management of pending changes
@@ -168,11 +168,11 @@
     private:
         // create a new empty CacheLine for the given component name
         explicit 
-        ExtendedCacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl );
+        ExtendedCacheLine( Name const & _aModuleName );
         
         // create a new CacheLine attached to the given memory location
         explicit 
-        ExtendedCacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+        ExtendedCacheLine( Name const & _aModuleName, 
                             memory::SegmentAddress const & _aLocation ); 
 
     private:
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/treemanager.cxx configmgr/source/treecache/treemanager.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treecache/treemanager.cxx	2006-06-20 00:31:44.000000000 +0100
+++ configmgr/source/treecache/treemanager.cxx	2006-10-03 16:39:16.000000000 +0100
@@ -238,10 +238,10 @@
 
 
 // -------------------------------------------------------------------------
-TreeManager::TreeManager(BackendCacheRef const & _xBackend, memory::HeapManager & _rCacheHeapManager) 
+TreeManager::TreeManager(BackendCacheRef const & _xBackend) 
 : m_xCacheController(_xBackend)
 , m_aCacheList()
-, m_aTemplates(new CacheData(_rCacheHeapManager))
+, m_aTemplates(new CacheData())
 , m_bEnableAsync(true)
 {
     OSL_PRECOND(_xBackend.is(),"Trying to create a TreeManager without a backend");
@@ -290,12 +290,6 @@
 
 // -------------------------------------------------------------------------
 
-memory::HeapManager & TreeManager::getCacheHeapManager() const
-{
-    return m_aTemplates.get()->getHeapManager();
-}
-// -------------------------------------------------------------------------
-
 TreeManager::CacheRef TreeManager::getCacheAlways(RequestOptions const & _aOptions)
 {
     osl::MutexGuard aGuard( m_aCacheList.mutex() );
@@ -303,7 +297,7 @@
     CacheRef aResult = m_aCacheList.get(_aOptions);
     if (!aResult.is())
     {
-        CacheRef aNewCache( new Cache(getCacheHeapManager(), ConfigChangeBroadcaster::newBroadcastHelper()) );
+        CacheRef aNewCache( new Cache(ConfigChangeBroadcaster::newBroadcastHelper()) );
         aResult = m_aCacheList.insert(_aOptions,aNewCache);
     }
     return aResult;
diff -x '*~' -u -r -x 'unxlng*' /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treemgr/viewstrategy.cxx configmgr/source/treemgr/viewstrategy.cxx
--- /opt/OpenOffice/HEAD/build/ood680-m4/configmgr/source/treemgr/viewstrategy.cxx	2006-06-20 00:35:12.000000000 +0100
+++ configmgr/source/treemgr/viewstrategy.cxx	2006-10-04 11:59:12.000000000 +0100
@@ -190,15 +190,8 @@
 //-----------------------------------------------------------------------------
         data::NodeAddress::DataType * ViewStrategy::implAccessForUpdate(data::NodeAccessRef const & _aNode)
         {
-            if (memory::Segment * pUpdatableSegment = doGetDataSegmentForUpdate())
-            {
-                void * p = memory::UpdateAccessor(pUpdatableSegment).validate(_aNode.rawAddress());
-             
-                OSL_ASSERT(const_cast<const void *>(p) == _aNode.getDataPtr());
-
-                return static_cast<data::NodeAddress::DataType*>(p);
-            }
-
+            if (doGetDataSegmentForUpdate())
+                return (data::NodeAddress::DataType *)_aNode.getDataPtr();
             else
                 return NULL;
         }
