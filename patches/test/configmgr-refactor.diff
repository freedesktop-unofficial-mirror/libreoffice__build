diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/data/accessor.cxx configmgr/source/data/accessor.cxx
--- configmgr-before-refactor/source/data/accessor.cxx	2006-12-14 17:32:30.000000000 +0000
+++ configmgr/source/data/accessor.cxx	2006-12-14 17:35:45.000000000 +0000
@@ -58,20 +58,13 @@
         : m_segment(segment)
         , m_refs(1)
         {
-            void const * base = m_segment ? m_segment->acquireReadAccess() : NULL;
-            m_base = static_cast<char const *>(base);
-        }
-    // -------------------------------------------------------------------------
-        Accessor::Impl::Impl(Segment const * segment, void const * base)
-        : m_segment(segment)
-        , m_base(static_cast<char const *>(base))
-        , m_refs(1)
-        {
+	    if (m_segment)
+		m_segment->acquireReadAccess();
         }
     // -------------------------------------------------------------------------
         Accessor::Impl::~Impl()
         {
-            if (m_segment) m_segment->releaseReadAccess(m_base);
+            if (m_segment) m_segment->releaseReadAccess();
         }
     // -------------------------------------------------------------------------
          /// Copies an Accessor
@@ -93,42 +86,12 @@
         {
             if (m_impl->is()) 
             {
-                Impl * pNewImpl = new Impl(0,0);
+                Impl * pNewImpl = new Impl(0);
                 releaseImpl();
                 m_impl = pNewImpl;
             }
             OSL_POSTCOND(!this->is(),"Accessor::clear: Could not clear");
         }
-
-    // -------------------------------------------------------------------------
-        void * Accessor::failNull()
-        {
-            OSL_ENSURE(false,"Unexpected NULL Address or Accessor");
-            return NULL;
-        }
-    // -------------------------------------------------------------------------
-
-    #if OSL_DEBUG_LEVEL > 0
-        void const * Accessor::resolve(AddressType _p) const 
-        { 
-            OSL_ENSURE( !_p.is() || segment_()->isValidAddress(_p.value()), "Address does not belong to this segment");
-            return _p.is() ? base_() + _p.value() : NULL; 
-        }
-
-        Pointer  Accessor::reduce(void const * _p) const
-        {
-            if (_p)
-            {
-                Pointer::RawAddress addr = static_cast<char const *>(_p) - base_();
-                OSL_ENSURE( segment_()->isValidAddress(addr), "Pointer does not belong to this segment");
-                return Pointer(addr); 
-            }
-            else
-                return Pointer();
-        }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
Only in configmgr/source/data: accessor.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/data/anydata.cxx configmgr/source/data/anydata.cxx
--- configmgr-before-refactor/source/data/anydata.cxx	2006-11-03 11:34:29.000000000 +0000
+++ configmgr/source/data/anydata.cxx	2006-12-14 18:00:02.000000000 +0000
@@ -61,7 +61,6 @@
         namespace Type = data::Type;
         namespace uno = ::com::sun::star::uno;
         typedef AnyData::TypeCode TypeCode;
-        using memory::Pointer;
 //-----------------------------------------------------------------------------	
 
 TypeCode getTypeCode(uno::Type const & _aType)
@@ -200,7 +199,7 @@
 //-----------------------------------------------------------------------------	
 
 static
-AnyData allocSimpleData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, uno::Any const & _aAny)
+AnyData allocSimpleData(TypeCode _aSimpleType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -234,9 +233,7 @@
             sal_Int64 nValue;
             OSL_VERIFY(_aAny >>= nValue);
 
-            Address aStorage = _anAllocator.allocate( sizeof nValue );
-            *static_cast<sal_Int64*>( _anAllocator.access(aStorage) ) = nValue;
-            aResult.longValue = aStorage;
+            aResult.longValue = Address( new sal_Int64( nValue ) );
         }
         break;
 
@@ -245,9 +242,7 @@
             double dValue;
             OSL_VERIFY(_aAny >>= dValue);
 
-            Address aStorage = _anAllocator.allocate( sizeof dValue );
-            *static_cast<double*>( _anAllocator.access(aStorage) ) = dValue;
-            aResult.doubleValue = aStorage;
+            aResult.doubleValue = Address( new double( dValue ) );
         }
         break;
 
@@ -255,7 +250,7 @@
         {
             uno::Sequence<sal_Int8> aValue;
             OSL_VERIFY(_aAny >>= aValue);
-            aResult.binaryValue = allocBinary(_anAllocator,aValue);
+            aResult.binaryValue = allocBinary(aValue);
         }
         break;
 
@@ -290,7 +285,7 @@
 //-----------------------------------------------------------------------------	
 
 static
-AnyData allocSequenceData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, uno::Any const & _aAny)
+AnyData allocSequenceData(TypeCode _aSimpleType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -302,7 +297,7 @@
         {
             uno::Sequence<rtl::OUString> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -310,7 +305,7 @@
         {
             uno::Sequence<sal_Bool> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -318,7 +313,7 @@
         {
             uno::Sequence<sal_Int16> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -326,7 +321,7 @@
         {
             uno::Sequence<sal_Int32> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -334,7 +329,7 @@
         {
             uno::Sequence<sal_Int64> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -342,7 +337,7 @@
         {
             uno::Sequence<double> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -350,7 +345,7 @@
         {
             uno::Sequence<uno::Sequence<sal_Int8> > aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -366,28 +361,20 @@
 }
 //-----------------------------------------------------------------------------	
 
-AnyData allocData(memory::Allocator const& _anAllocator, TypeCode _aType, uno::Any const & _aAny)
+AnyData allocData(TypeCode _aType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
     OSL_ENSURE( _aType == getTypeCode(_aAny.getValueType()), "Type code does not match value" );
 
     if (_aType & Type::flag_sequence)
-        return allocSequenceData(_anAllocator,TypeCode( _aType & Type::mask_basetype),_aAny);
-
+        return allocSequenceData(TypeCode( _aType & Type::mask_basetype),_aAny);
     else
-        return allocSimpleData(_anAllocator,_aType,_aAny);
-}
-//-----------------------------------------------------------------------------	
-/*
-AnyData copyData(memory::Allocator const& _anAllocator, TypeCode _aType, AnyData _aData)
-{
-    OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
+        return allocSimpleData(_aType,_aAny);
 }
-*/
 //-----------------------------------------------------------------------------	
 
 static
-void freeSimpleData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, AnyData const & _aData)
+void freeSimpleData(TypeCode _aSimpleType, AnyData const & _aData)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -405,15 +392,15 @@
 
         // free memory for oversized values
     case Type::value_long:
-        _anAllocator.deallocate(_aData.longValue);
+        delete (sal_uInt64 *)_aData.longValue;
         break;
 
     case Type::value_double:
-        _anAllocator.deallocate(_aData.doubleValue);
+        delete (double *)_aData.doubleValue;
         break;
 
     case Type::value_binary:
-        freeBinary(_anAllocator, _aData.binaryValue);
+        freeBinary(_aData.binaryValue);
         break;
 
     case Type::value_any: 
@@ -427,15 +414,15 @@
 }
 //-----------------------------------------------------------------------------	
 
-void    freeData(memory::Allocator const& _anAllocator, TypeCode _aType, AnyData _aData)
+void    freeData(TypeCode _aType, AnyData _aData)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
 
     if (_aType & Type::flag_sequence)
-        freeSequence(_anAllocator,TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
+        freeSequence(TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
 
     else
-        freeSimpleData(_anAllocator,_aType,_aData);
+        freeSimpleData(_aType,_aData);
 }
 //-----------------------------------------------------------------------------	
 
@@ -462,22 +449,14 @@
         return uno::makeAny( _aData.intValue );
 
     case Type::value_long:
-        {
-            void const * pStorage = _anAccessor.validate( Pointer(_aData.longValue) );
-            sal_Int64 const * pValue = static_cast<sal_Int64 const *>(pStorage);
-            return uno::makeAny( *pValue );
-        }
+	return uno::makeAny( *(sal_Int64 const *)_aData.longValue );
 
     case Type::value_double:
-        {
-            void const * pStorage = _anAccessor.validate( Pointer(_aData.doubleValue) );
-            double const * pValue = static_cast<double const *>(pStorage);
-            return uno::makeAny( *pValue );
-        }
+	return uno::makeAny( *(double const *)_aData.doubleValue );
 
     case Type::value_binary:
         {
-            uno::Sequence<sal_Int8> aValue = readBinary( _anAccessor, _aData.binaryValue );
+            uno::Sequence<sal_Int8> aValue = readBinary( _aData.binaryValue );
             return uno::makeAny( aValue );
         }
 
Only in configmgr/source/data: anydata.cxx.orig
Only in configmgr/source/data: anydata.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/data/heap.cxx configmgr/source/data/heap.cxx
--- configmgr-before-refactor/source/data/heap.cxx	2006-09-16 16:09:54.000000000 +0100
+++ configmgr/source/data/heap.cxx	2006-12-14 17:35:45.000000000 +0000
@@ -42,61 +42,5 @@
 #include <osl/diagnose.h>
 #endif
 
-// -----------------------------------------------------------------------------	
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        const Heap::Size c_nDefaultSize = 4096;
-    // -------------------------------------------------------------------------
-        Heap::Heap(HeapManager& _impl)
-        : m_impl(_impl)
-        , m_heap(_impl.createHeap(c_nDefaultSize))
-        , m_size(c_nDefaultSize)
-        {
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Heap(HeapManager& _impl, Size _nInitialSize)
-        : m_impl(_impl)
-        , m_heap(_impl.createHeap(_nInitialSize))
-        , m_size(_nInitialSize)
-        {
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Heap(HeapManager& _impl, HeapId const & _anId)
-        : m_impl(_impl)
-        , m_size(0)
-        {
-            m_heap = _impl.attachHeap(_anId,m_size);
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::~Heap()
-        {
-            m_impl.destroyHeap(m_heap);
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Size Heap::grow(Size _nReqSize) // returns the (possibly new) base
-        {
-            Size nNewSize = m_impl.growHeap(m_heap, _nReqSize);
-
-            if (nNewSize)
-            {
-                OSL_ENSURE(nNewSize >= _nReqSize, "Error: Heapmanager returns invalid size from grow method");
-                m_size = nNewSize;
-            }
-
-            return nNewSize;
-        }
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
 
 
Only in configmgr/source/data: heap.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/data/segmentheap.cxx configmgr/source/data/segmentheap.cxx
--- configmgr-before-refactor/source/data/segmentheap.cxx	2006-09-16 16:10:09.000000000 +0100
+++ configmgr/source/data/segmentheap.cxx	2006-12-14 17:35:45.000000000 +0000
@@ -36,73 +36,3 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_configmgr.hxx"
 
-#include "segmentheap.hxx"
-
-#ifndef _OSL_DIAGNOSE_H_
-#include <osl/diagnose.h>
-#endif
-
-// -----------------------------------------------------------------------------	
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        const Heap::Size c_nMaxHeapSize = 0x40000000;
-        const Heap::Size c_nGrowFactor  = 2;
-
-    // -------------------------------------------------------------------------
-
-        SegmentHeap::~SegmentHeap()
-        {
-            m_heap.destroyLock(m_lock);
-        }
-    // -------------------------------------------------------------------------
-
-        void SegmentHeap::init()
-        {
-            m_lock = m_heap.createLock();
-            m_base = m_heap.base();
-
-            OSL_ENSURE(m_lock,"Could not create heap lock");
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Address SegmentHeap::allocateMore(Size _sz)
-        {
-            Size nCurSize = m_heap.size();
-
-            OSL_ENSURE(_sz <= c_nMaxHeapSize,"Cannot allocate: Allocation request too large");
-            if (_sz > c_nMaxHeapSize) return 0;
-
-            Size nCurSizeLimit = (c_nMaxHeapSize-_sz)/c_nGrowFactor;
-            OSL_ENSURE(nCurSize < nCurSizeLimit,"Allocation will reach heap limit");
-
-            Size nNewSize = (nCurSize < nCurSizeLimit ) 
-                                ? nCurSize * c_nGrowFactor + _sz 
-                                : c_nMaxHeapSize;
-
-            if (m_heap.grow(nNewSize))
-            {
-                m_base = m_heap.base();
-
-                Address aResult = m_heap.allocate(_sz);
-
-                OSL_ENSURE(aResult,"Cannot allocate even after growing heap");
-
-                return aResult;
-            }
-            else
-            {
-                OSL_ENSURE(false,"Cannot allocate: Heap could not be grown");
-                return 0;
-            }
-        }
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-
Only in configmgr/source/data: segmentheap.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/data/sequence.cxx configmgr/source/data/sequence.cxx
--- configmgr-before-refactor/source/data/sequence.cxx	2006-11-03 11:34:42.000000000 +0000
+++ configmgr/source/data/sequence.cxx	2006-12-14 17:58:12.000000000 +0000
@@ -64,9 +64,7 @@
         namespace Type = data::Type;
         namespace uno = ::com::sun::star::uno;
         typedef AnyData::TypeCode TypeCode;
-        using memory::Allocator;
         using memory::Accessor;
-        using memory::Pointer;
 //-----------------------------------------------------------------------------	
 static 
 sal_uInt32 implGetElementSize(TypeCode _aElementType)
@@ -108,32 +106,20 @@
 //-----------------------------------------------------------------------------	
 static 
 inline
-sal_Int32& implGetSize(Allocator const& _anAllocator, Sequence _aSeq)
+sal_Int32& implGetSize(Sequence _aSeq)
 {
-    OSL_ASSERT(_aSeq != 0);
-    void * pBase = _anAllocator.access(_aSeq);
-    return * static_cast<sal_Int32 *>(pBase);
+    return * (sal_Int32 *) _aSeq;
 }
 
 //-----------------------------------------------------------------------------	
 static 
-inline
-sal_Int32 implGetSize(Accessor const& _anAccessor, Sequence _aSeq)
-{
-    OSL_ASSERT(_aSeq != 0);
-    void const * pBase = _anAccessor.access( Pointer(_aSeq) );
-    return * static_cast<sal_Int32 const *>(pBase);
-}
-
-//-----------------------------------------------------------------------------	
-static 
-Sequence implSeqAlloc(Allocator const& _anAllocator, sal_Int32 _nElements, sal_uInt32 _nElemSize)
+Sequence implSeqAlloc(sal_Int32 _nElements, sal_uInt32 _nElemSize)
 {
     sal_uInt32 nTotalSize = implGetHeaderSize(_nElemSize) + _nElements * _nElemSize;
 
-    Sequence aResult = _anAllocator.allocate(nTotalSize);
+    Sequence aResult = (Sequence) (new sal_uInt8[nTotalSize]);
 
-    implGetSize(_anAllocator,aResult) = _nElements;
+    implGetSize(aResult) = _nElements;
 
     return aResult;
 }
@@ -141,7 +127,7 @@
 //-----------------------------------------------------------------------------	
 
 static
-void allocSeqData(Allocator const& _anAllocator, Address _aDestAddr, 
+void allocSeqData(Address _aDestAddr, 
                  TypeCode _aElementType, 
                  sal_Int32 _nElements, sal_uInt32 _nElementSize, 
                  void const * _pSourceData)
@@ -155,7 +141,7 @@
     case Type::value_int:
     case Type::value_long:
     case Type::value_double:
-        ::memcpy(_anAllocator.access(_aDestAddr),_pSourceData,_nElements * _nElementSize);
+        ::memcpy(_aDestAddr,_pSourceData,_nElements * _nElementSize);
         break;
 
     case Type::value_string: 
@@ -168,7 +154,7 @@
             {
                 String aElement = allocString(*pSource);
 
-                String * pDest = static_cast<String*>( _anAllocator.access(_aDestAddr) );
+                String * pDest = reinterpret_cast<String*>(_aDestAddr);
                 *pDest = aElement;
                 
                 ++pSource;
@@ -186,9 +172,9 @@
 
             while (--_nElements >= 0)
             {
-                Vector aElement = allocBinary(_anAllocator,*pSource);
+                Vector aElement = allocBinary(*pSource);
 
-                Vector * pDest = static_cast<Vector*>( _anAllocator.access(_aDestAddr) );
+                Vector * pDest = (Vector *) _aDestAddr;
                 *pDest = aElement;
                 
                 ++pSource;
@@ -205,7 +191,7 @@
 }
 
 //-----------------------------------------------------------------------------	
-Sequence allocSequence(Allocator const& _anAllocator, TypeCode _aElementType, ::sal_Sequence const * _pSeqData)
+Sequence allocSequence(TypeCode _aElementType, ::sal_Sequence const * _pSeqData)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -218,10 +204,10 @@
     sal_uInt32 const nElementSize = implGetElementSize(_aElementType);
     sal_Int32  const nElements = _pSeqData->nElements;
 
-    Sequence aResult = implSeqAlloc(_anAllocator,nElements,nElementSize);
+    Sequence aResult = implSeqAlloc(nElements,nElementSize);
 
     if (aResult)
-        allocSeqData( _anAllocator, aResult + implGetHeaderSize(nElementSize), 
+        allocSeqData( aResult + implGetHeaderSize(nElementSize), 
                         _aElementType, nElements, nElementSize,
                         _pSeqData->elements);
 
@@ -229,31 +215,25 @@
 }
 
 //-----------------------------------------------------------------------------	
-Sequence allocBinary(Allocator const& _anAllocator, uno::Sequence<sal_Int8> const & _aBinaryValue)
+Sequence allocBinary(uno::Sequence<sal_Int8> const & _aBinaryValue)
 {
     sal_uInt32 const nElementSize = 1;
     sal_Int32  const nLength = _aBinaryValue.getLength();
 
-    Sequence aResult = implSeqAlloc(_anAllocator,nLength,nElementSize);
+    Sequence aResult = implSeqAlloc(nLength,nElementSize);
 
     if (aResult)
     {
         Address aElementBaseAddr = aResult + implGetHeaderSize(nElementSize);
-        ::memcpy(_anAllocator.access(aElementBaseAddr), _aBinaryValue.getConstArray(), nLength);
+        ::memcpy(aElementBaseAddr, _aBinaryValue.getConstArray(), nLength);
     }
 
     return aResult;
 }
 
 //-----------------------------------------------------------------------------	
-// Sequence copySequence(Allocator const& _anAllocator, TypeCode _aElementType, Sequence _aSeq)
-
-//-----------------------------------------------------------------------------	
-// Sequence copyBinary(Allocator const& _anAllocator, Sequence _aSeq)
-
-//-----------------------------------------------------------------------------	
 static
-void freeSeqData(Allocator const& _anAllocator, Address _aDataAddr, 
+void freeSeqData(Address _aDataAddr, 
                  TypeCode _aElementType, sal_Int32 _nElements)
 {
     OSL_ASSERT(_aElementType == (_aElementType & Type::mask_basetype));
@@ -270,7 +250,7 @@
 
     case Type::value_string: 
         {
-            String * pElements = static_cast<String*>( _anAllocator.access(_aDataAddr) );
+            String * pElements = reinterpret_cast<String*>( _aDataAddr );
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
@@ -281,11 +261,11 @@
 
     case Type::value_binary:
         {
-            Vector * pElements = static_cast<Vector*>( _anAllocator.access(_aDataAddr) );
+            Vector * pElements = reinterpret_cast<Vector*>( _aDataAddr );
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
-                freeBinary(_anAllocator,pElements[i]);
+                freeBinary(pElements[i]);
             }
         }
         break;
@@ -298,7 +278,7 @@
 }
 
 //-----------------------------------------------------------------------------	
-void freeSequence(Allocator const& _anAllocator, TypeCode _aElementType, Sequence _aSeq)
+void freeSequence(TypeCode _aElementType, Sequence _aSeq)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -310,18 +290,18 @@
 
     sal_uInt32 nHeaderSize = implGetHeaderSize( implGetElementSize( _aElementType ) );
 
-    freeSeqData(_anAllocator,_aSeq + nHeaderSize, _aElementType, implGetSize(_anAllocator,_aSeq));
+    freeSeqData(_aSeq + nHeaderSize, _aElementType, implGetSize(_aSeq));
 
-    _anAllocator.deallocate(_aSeq);
+    delete[] (sal_uInt8 *)_aSeq;
 }
 
 //-----------------------------------------------------------------------------	
-void freeBinary(memory::Allocator const& _anAllocator, Sequence _aSeq)
+void freeBinary(Sequence _aSeq)
 {
     OSL_ENSURE(_aSeq, "ERROR: Trying to free a NULL sequence");
     if (_aSeq == 0) return;
 
-    _anAllocator.deallocate(_aSeq);
+    delete[] (sal_uInt8 *)_aSeq;
 }
 
 //-----------------------------------------------------------------------------	
@@ -346,7 +326,7 @@
 {
     OSL_ASSERT(_aElementType == (_aElementType & Type::mask_basetype));
 
-    void const * pElementData = _anAccessor.validate( Pointer(_aDataAddr) );
+    void const * pElementData = (void const *)_aDataAddr;
     switch (_aElementType)
     {
     case Type::value_boolean:
@@ -384,7 +364,7 @@
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
-                pResult[i] = readBinary(_anAccessor,pElements[i]);
+                pResult[i] = readBinary(pElements[i]);
             }
 
             sal_Sequence * pRet = aResult.get();
@@ -413,7 +393,8 @@
 
     sal_uInt32 nHeaderSize = implGetHeaderSize( implGetElementSize( _aElementType ) );
 
-    return readSeqData(_anAccessor,_aSeq + nHeaderSize, _aElementType, implGetSize(_anAccessor,_aSeq));
+    // URG - accidentally removed an accessor instead of an allocator ... :-)
+    return readSeqData(_anAccessor,_aSeq + nHeaderSize, _aElementType, implGetSize(_aSeq));
 }
 
 //-----------------------------------------------------------------------------	
@@ -487,20 +468,13 @@
 }
 
 //-----------------------------------------------------------------------------	
-uno::Sequence<sal_Int8> readBinary(Accessor const& _anAccessor, Sequence _aSeq)
+uno::Sequence<sal_Int8> readBinary(Sequence _aSeq)
 {
     OSL_ENSURE(_aSeq, "ERROR: Trying to read from a NULL sequence");
     if (_aSeq == 0) return uno::Sequence<sal_Int8>();
 
-    sal_Int32 const nElements = implGetSize(_anAccessor,_aSeq);
-
-    void const * const pElementData = _anAccessor.validate( Pointer(_aSeq + implGetHeaderSize(1)) );
-
-    sal_Int8 const * const pBinaryData = static_cast<sal_Int8 const *>(pElementData);
-
-    uno::Sequence< sal_Int8 > aSequence(pBinaryData,nElements); 
-
-    return aSequence;
+    return uno::Sequence< sal_Int8 >((const sal_Int8 *)(_aSeq + implGetHeaderSize(1)),
+				     implGetSize(_aSeq));
 }
 
 //-----------------------------------------------------------------------------	
Only in configmgr/source/data: sequence.cxx.orig
Only in configmgr/source/data: sequence.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/data/simpleheap.cxx configmgr/source/data/simpleheap.cxx
--- configmgr-before-refactor/source/data/simpleheap.cxx	2006-12-14 17:32:30.000000000 +0000
+++ configmgr/source/data/simpleheap.cxx	2006-12-14 17:35:45.000000000 +0000
@@ -1,3 +1,4 @@
+#include <stdio.h>
 /*************************************************************************
  *
  *  OpenOffice.org - a multi-platform office productivity suite
@@ -57,418 +58,3 @@
 #include <map>
 #define INCLUDED_MAP
 #endif
-
-#ifdef _MSC_VER
-#pragma warning( disable : 4355 )
-#endif
-
-// -----------------------------------------------------------------------------	
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        extern HeapManager & localHeap();
-    // -------------------------------------------------------------------------
-        struct OrderByHeapId
-        {
-            typedef HeapManager::HeapIdParam HeapIdParam;
-
-            bool operator()(HeapIdParam lhs, HeapIdParam rhs) const 
-            {
-                return lhs.compareTo(rhs) < 0;
-            }
-        };
-    // -------------------------------------------------------------------------
-        struct HeapSet
-        {
-            typedef HeapManager::HeapIdParam    HeapIdParam;
-            typedef HeapManager::HeapId         HeapId;
-            typedef HeapManager::Handle         Heap;
-
-            typedef std::map<HeapId,Heap,OrderByHeapId> Map;
-
-            HeapSet(HeapManager & _mgr) : m_mgr(_mgr) {}
-
-            Heap add(Heap _aHeap) { return m_heaps[m_mgr.id(_aHeap)] = _aHeap; }
-            void remove(Heap _aHeap) { m_heaps.erase(m_mgr.id(_aHeap)); }
-
-            Heap heap(HeapIdParam _anId) const 
-            {
-                Map::const_iterator it = m_heaps.find(_anId);
-                return it != m_heaps.end() ? it->second : NULL;
-            }
-        private:
-            HeapManager &   m_mgr;
-            Map             m_heaps;
-        };
-    // -------------------------------------------------------------------------
-        class SimpleHeapManagerBase : public HeapManager
-        {
-            static void * ptr(Address _address) { return reinterpret_cast<void*>(_address); }
-            static Address address(void * _ptr) { return reinterpret_cast<Address>(_ptr); }
-            // if this static assertion breaks, a less simple heap manager is needed (-> 64 bit ports)
-            static char address_can_hold_any_pointer[sizeof(Address) - sizeof(void*) + 1];
-
-            virtual void *  base(Handle _aHeap);
-        protected: 
-            SimpleHeapManagerBase() : m_heaps( *(HeapManager*)this) {}
-            virtual ~SimpleHeapManagerBase() {}
-
-            Handle  addHeap(Handle _aHeap)      { return m_heaps.add(_aHeap);   }
-            void    removeHeap(Handle _aHeap)   { m_heaps.remove(_aHeap);       }
-
-            Handle  findHeap( HeapId _anId )    
-            { 
-                osl::MutexGuard aGuard(m_mutex); 
-                return m_heaps.heap(_anId);  
-            }
-
-            osl::Mutex & getHeapListMutex()     { return m_mutex; }
-        protected:      
-            Address allocateMemory(Size _sz);
-            Address reallocateMemory(Address _p, Size _sz);
-            void    deallocateMemory(Address _p);
-
-        protected:      
-            virtual Lock *  createHeapLock(Handle _aHeap);
-            virtual void    destroyHeapLock(Handle _aHeap, Lock * _pLock);
-
-        private:
-            osl::Mutex  m_mutex;
-            HeapSet     m_heaps;
-        };
-    // -------------------------------------------------------------------------
-        class SimpleCheckingHeapManager : public SimpleHeapManagerBase
-        {
-            struct HeapData
-            {
-                HeapId      id;
-                
-                oslInterlockedCount  refs;
-
-                Size        requested;
-                Size        allocated;
-
-                Size available() const { return requested-allocated; }
-
-                typedef std::map<Address, Size> Map;
-                Map allocations;
-            };
-
-            static HeapData * heap(Handle _handle) { return reinterpret_cast<HeapData*>(_handle); }
-            static Handle handle(HeapData * _data) { return reinterpret_cast<Handle>(_data); }
-
-            static void makeNewId(HeapData * _data);
-       public:      
-            virtual Handle createHeap(Size _sInitialSize);
-            virtual Handle attachHeap(HeapIdParam  _anId, Size & _rInitialSize);
-            virtual Size   growHeap(Handle _aHeap, Size _sNewSize);
-            virtual void   destroyHeap(Handle _aHeap);
-
-            virtual HeapId  id(Handle _aHeap);
-
-            virtual Address allocate(Handle _aHeap, Size _sNewSize);
-            virtual Address reallocate(Handle _aHeap, Address _aOldAddress, Size _sNewSize);
-            virtual void    deallocate(Handle _aHeap, Address _aAddress);
-            virtual bool    didAllocate(Handle _aHeap, Address _aAddress);
-        };
-    // -------------------------------------------------------------------------
-        class SimpleHeapLock : public DataLock
-        {
-            osl::Mutex m_mutex;
-        public:   
-            virtual void acquireReadAccess() { m_mutex.acquire(); }
-            virtual void releaseReadAccess() { m_mutex.release(); }
-
-            virtual void acquireWriteAccess() { m_mutex.acquire(); }     
-            virtual void releaseWriteAccess() { m_mutex.release(); }
-        };
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-        HeapManager & cacheHeap()
-        {
-            static SimpleCheckingHeapManager aInstance;
-            return aInstance;
-        }
-    // -------------------------------------------------------------------------
-        HeapManager & localHeap()
-        {
-            static SimpleCheckingHeapManager aInstance;
-            return aInstance;
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleHeapManagerBase::allocateMemory(Size _sz)
-        {
-            void * p = ::rtl_allocateMemory(_sz);
-
-            OSL_ENSURE(p,"Could not allocate: std::malloc failed");
-
-            return address(p);
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleHeapManagerBase::reallocateMemory(Address _p, Size _sz)
-        {
-            void * pOld = ptr(_p);
-
-            void * pNew = ::rtl_reallocateMemory(pOld,_sz);
-
-            OSL_ENSURE(pNew,"Could not reallocate: std::realloc failed");
-
-            return address(pNew);
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleHeapManagerBase::deallocateMemory(Address _p)
-        {
-            void * p = ptr(_p);
-
-            ::rtl_freeMemory(p); 
-        }
-    // -------------------------------------------------------------------------
-
-        void *  SimpleHeapManagerBase::base(Handle /*_aHeap*/)
-        {
-            return NULL;
-        }
-    // -------------------------------------------------------------------------
-
-        DataLock *  SimpleHeapManagerBase::createHeapLock(Handle )
-        {
-            return new SimpleHeapLock();
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleHeapManagerBase::destroyHeapLock(Handle , DataLock * _pLock)
-        {
-            if (SimpleHeapLock* pMyLock = /*dynamic_*/ static_cast<SimpleHeapLock*>(_pLock))
-            {
-                delete pMyLock;
-            }
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-
-        void SimpleCheckingHeapManager::makeNewId(HeapData * _data)
-        {
-            OSL_PRECOND( _data, "Internal Error: NULL data");
-
-            sal_Int64 nData = reinterpret_cast<sal_Int64>(_data);
-
-            HeapId aNewId = HeapId::valueOf(nData,16);
-
-            _data->id = aNewId;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::HeapId SimpleCheckingHeapManager::id(Handle _aHeap)
-        {
-            if (_aHeap == 0) return HeapId();
-
-            HeapData * data = heap(_aHeap);
-
-            return data->id;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Handle SimpleCheckingHeapManager::createHeap(Size _sInitialSize)
-        {
-            // need to have 4-byte pointers for this implementation
-            OSL_ASSERT(sizeof(void *) == sizeof(Address));
-
-            HeapData * pHeap = new HeapData();
-
-            pHeap->refs      = 1;
-
-            pHeap->requested = _sInitialSize;
-            pHeap->allocated = 0;
-
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            makeNewId( pHeap );
-
-            OSL_ENSURE( ! findHeap(pHeap->id), "Internal Error: New heap id already registered");
-
-            return addHeap(handle(pHeap) );
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Handle SimpleCheckingHeapManager::attachHeap(HeapIdParam  _anId, Size & _rInitialSize)
-        {
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            Handle aHeap = findHeap(_anId);
-
-            OSL_ENSURE( aHeap, "Error: No such Heap");
-
-            if (aHeap != 0)
-            {
-                HeapData * data = heap(aHeap);
-
-                OSL_ENSURE( data->id == _anId, "Internal error: Inconsistent heap id");
-
-                _rInitialSize = data->requested;
-             
-                ++data->refs;
-            }
-            else
-                _rInitialSize = 0;
-
-            return aHeap;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Size   SimpleCheckingHeapManager::growHeap(Handle _aHeap, Size _sNewSize)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            if (data->requested < _sNewSize) data->requested = _sNewSize; 
-
-            return data->requested;
-        }
-    // -------------------------------------------------------------------------
-
-        void   SimpleCheckingHeapManager::destroyHeap(Handle _aHeap)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            if (0 == --data->refs)
-            {
-                OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-    //            OSL_ENSURE(data->allocations.empty(), "Memory leaks found");
-                for (HeapData::Map::iterator it = data->allocations.begin();
-                     it != data->allocations.end();
-                     ++it)
-                {
-                    deallocateMemory(it->first);
-                    data->allocated -= it->second;
-
-                }
-                OSL_ENSURE(data->allocated == 0, "Memory tracking error detected");
-
-                removeHeap(_aHeap);
-
-                delete data;
-            }
-        }
-    // -------------------------------------------------------------------------
-
-        bool SimpleCheckingHeapManager::didAllocate(Handle _aHeap, Address _aAddress)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-            OSL_PRECOND( _aAddress, "Warning: checking NULL address - will fail");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            /* Condition is:
-                    allocationAddress <= _aAddress &&
-                    _aAddress <= allocationAddress + allocationSize
-               (<= to allow past-the-end pointer)
-            */
-
-            HeapData::Map::iterator it = data->allocations.upper_bound(_aAddress);
-
-            if (it == data->allocations.begin()) 
-                return false;
-
-            --it; // Now it is the last iterator that is less than or equal to _aAddress
-
-            OSL_ASSERT( it->first <= _aAddress ); // first part of condition handled by map
-
-            return _aAddress <= it->first + it->second;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleCheckingHeapManager::allocate(Handle _aHeap, Size _nSize)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            if (_nSize > data->available()) 
-                return 0;
-
-            Address p = allocateMemory(_nSize);
-            if (p)
-            {
-                data->allocations[p] = _nSize;
-                data->allocated += _nSize;
-            }
-            return p;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleCheckingHeapManager::reallocate(Handle _aHeap, Address _aOld, Size _nNewSize)
-        {
-            if (_aOld == 0) return allocate(_aHeap,_nNewSize);
-
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            OSL_ENSURE( data->allocations.count(_aOld), "Error: pointer being reallocated is not from this data");
-
-            Size nOldSize = data->allocations[_aOld];
-
-            if (nOldSize >= _nNewSize) 
-                return _aOld;
-
-            if (_nNewSize-nOldSize > data->available()) 
-                return 0;
-
-            Address aNew = reallocateMemory(_aOld,_nNewSize);
-            if (aNew)
-            {
-                if (aNew != _aOld) data->allocations.erase(_aOld);
-
-                data->allocations[aNew] = _nNewSize;
-                data->allocated += _nNewSize - nOldSize;
-            }
-
-            return aNew;
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleCheckingHeapManager::deallocate(Handle _aHeap, Address _p)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-            OSL_PRECOND( _p, "Error: Trying to free NULL address");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            OSL_ENSURE( data->allocations.count(_p), "Error: pointer being freed is not from this data");
-
-            Size freed = data->allocations[_p];
-            data->allocated -= freed;
-            data->allocations.erase(_p);
-
-            deallocateMemory(_p);
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-
Only in configmgr/source/data: simpleheap.cxx.orig
Only in configmgr/source/data: types.cxx.orig
Only in configmgr/source/data: types.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/data/updateaccessor.cxx configmgr/source/data/updateaccessor.cxx
--- configmgr-before-refactor/source/data/updateaccessor.cxx	2006-09-16 16:11:05.000000000 +0100
+++ configmgr/source/data/updateaccessor.cxx	2006-12-14 17:35:45.000000000 +0000
@@ -57,13 +57,13 @@
         UpdateAccessor::UpdateAccessor(Segment * segment)
         : m_segment(segment)
         {
-            m_heap = (m_segment) ? &m_segment->acquireWriteAccess() : 0;
-            OSL_ASSERT( m_heap || !m_segment );
+			m_segment->acquireWriteAccess();
         }
     // -------------------------------------------------------------------------
         UpdateAccessor::~UpdateAccessor()
         {
-            if (m_segment) m_segment->releaseWriteAccess(*m_heap);
+			if (m_segment)
+				m_segment->releaseWriteAccess();
         }
     // -------------------------------------------------------------------------
         Accessor UpdateAccessor::accessor() const
@@ -75,15 +75,14 @@
         Accessor UpdateAccessor::downgrade()
         {
             Segment * segment = m_segment;
-            void const * base = NULL;
+
             if (m_segment)
             {
-                base = m_segment->acquireReadAccess();
-                m_segment->releaseWriteAccess(*m_heap);
+				m_segment->downgradeAccess();
                 m_segment = 0;
             }
 
-            return Accessor(segment, base, SAL_NO_ACQUIRE);
+            return Accessor(segment, SAL_NO_ACQUIRE);
         }
 
     // -------------------------------------------------------------------------
@@ -91,79 +90,10 @@
         {
             if (m_segment)
             {
-                m_segment->releaseWriteAccess(*m_heap);
+                m_segment->releaseWriteAccess();
                 m_segment = NULL;
             }
         }
-
-    // -------------------------------------------------------------------------
-        char * UpdateAccessor::heap_base() const
-        {
-            return static_cast<char *>(m_heap ? m_heap->base() : NULL);
-        }
-
-    // -------------------------------------------------------------------------
-        char * Allocator::heap_base() const
-        {
-            return static_cast<char *>(m_heap ? m_heap->base() : NULL);
-        }
-
-    // -------------------------------------------------------------------------
-        Allocator::Address Allocator::allocate(Size _sz) const
-        {
-            OSL_ENSURE(m_heap,"Cannot allocate: Invalid heap");
-            return m_heap ? m_heap->allocate(_sz) : Allocator::Address();
-        }
-
-    // -------------------------------------------------------------------------
-        void Allocator::deallocate(Address _addr) const
-        {
-            OSL_ENSURE(m_heap,"Cannot deallocate: Invalid heap");
-            if (m_heap) m_heap->deallocate(_addr);
-        }
-
-    // -------------------------------------------------------------------------
-
-    #if OSL_DEBUG_LEVEL > 0
-        void * UpdateAccessor::resolve(AddressType _p) const
-        {
-            OSL_ENSURE( !_p.is() || m_segment->isValidAddress(_p.value()), "Address does not belong to this segment");
-            return _p.is() ? heap_base() + _p.value() : NULL;
-        }
-
-        Pointer  UpdateAccessor::reduce(void const * _p) const
-        {
-            if (_p)
-            {
-                Pointer::RawAddress addr = static_cast<char const *>(_p) - heap_base();
-                OSL_ENSURE( m_segment->isValidAddress(addr), "Pointer does not belong to this segment");
-                return Pointer(addr);
-            }
-            else
-                return Pointer();
-        }
-
-        void * Allocator::access(Address _addr) const
-        {
-            OSL_ENSURE( !_addr || m_heap->isValidAddress(_addr), "Address does not belong to this segment");
-            return _addr ? heap_base() + _addr : NULL;
-        }
-
-
-        Allocator::Address  Allocator::address(void const * _p) const
-        {
-            if (_p)
-            {
-                Address addr = static_cast<char const *>(_p) - heap_base();
-                OSL_ENSURE( m_heap->isValidAddress(addr), "Pointer does not belong to this segment");
-                return addr;
-            }
-            else
-                return 0;
-        }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
Only in configmgr/source/data: updateaccessor.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/accessor.hxx configmgr/source/inc/accessor.hxx
--- configmgr-before-refactor/source/inc/accessor.hxx	2005-09-08 04:41:00.000000000 +0100
+++ configmgr/source/inc/accessor.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -36,8 +36,8 @@
 #ifndef CONFIGMGR_ACCESSOR_HXX
 #define CONFIGMGR_ACCESSOR_HXX
 
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
 #endif
 
 #ifndef _OSL_INTERLOCK_H_
@@ -57,14 +57,11 @@
             struct Impl
             {
                 Impl(Segment const * segment);
-                Impl(Segment const * segment, void const * base);
-
                 ~Impl();
 
                 bool is() const { return m_segment != NULL; }
 
                 Segment const * m_segment;
-                char    const * m_base;
                 oslInterlockedCount m_refs;
             private:
                 // disallow copying
@@ -78,9 +75,6 @@
 
             Impl * m_impl;
         public:
-            /// type of addresses used in the Segment
-            typedef Pointer AddressType;
-
             /// constructs an accessor on the given Segment
             explicit Accessor(Segment const * _pSegment) : m_impl(new Impl(_pSegment)) {}
 
@@ -90,45 +84,12 @@
 
             ~Accessor() { releaseImpl(); }
             
-            void swap(Accessor & _rOther);
-
             bool is() const { return m_impl->is(); }
             void clear();
-
-            AddressType address(void const * _p) const
-            { return (this->is()) ? reduce(_p) : Pointer();}
-
-            void const * access(AddressType _p) const
-            { return (this->is()) ? resolve(_p) : failNull();}
-
-            void const * validate(AddressType _p) const
-            { return (this->is() && _p.is()) ? resolve(_p) : failNull(); }
-
         private:
-            char    const * base_()    const { return m_impl->m_base; }
-            Segment const * segment_() const { return m_impl->m_segment; }
-
-            void const * resolve(AddressType _p) const;
-            AddressType  reduce(void const * _p) const;
-
             friend class UpdateAccessor;
-            Accessor(Segment * _s, void const * _b, __sal_NoAcquire) : m_impl(new Impl(_s,_b)) {}
-            static void * failNull();
+            Accessor(Segment * _s, __sal_NoAcquire) : m_impl(new Impl(_s)) {}
         };
-
-    // -------------------------------------------------------------------------
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline 
-        void const * Accessor::resolve(AddressType _p) const 
-        { return _p.is() ? this->base_() + _p.value() : NULL; }
-
-        inline 
-        Pointer  Accessor::reduce(void const * _p) const 
-        { return _p ? Pointer(static_cast<char const *>(_p) - this->base_()) : Pointer(); }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/anydata.hxx configmgr/source/inc/anydata.hxx
--- configmgr-before-refactor/source/inc/anydata.hxx	2005-09-08 04:41:13.000000000 +0100
+++ configmgr/source/inc/anydata.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -51,9 +51,6 @@
 {
 //-----------------------------------------------------------------------------
 
-    namespace memory { class Allocator; class Accessor; }
-    //-----------------------------------------------------------------------------
-
     namespace sharable
     {
     //-----------------------------------------------------------------------------
@@ -80,9 +77,8 @@
         AnyData::TypeCode getTypeCode(::com::sun::star::uno::Type const & _aType);
         ::com::sun::star::uno::Type getUnoType( AnyData::TypeCode _aType);
 
-        AnyData allocData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, ::com::sun::star::uno::Any const & _aAny);
-    //    AnyData copyData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, AnyData _aData);
-        void    freeData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, AnyData _aData);
+        AnyData allocData(AnyData::TypeCode _aType, ::com::sun::star::uno::Any const & _aAny);
+        void    freeData(AnyData::TypeCode _aType, AnyData _aData);
         ::com::sun::star::uno::Any readData(memory::Accessor const& _anAccessor, AnyData::TypeCode _aType, AnyData _aData);
 
     //-----------------------------------------------------------------------------
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/cacheddataprovider.hxx configmgr/source/inc/cacheddataprovider.hxx
--- configmgr-before-refactor/source/inc/cacheddataprovider.hxx	2005-09-08 04:43:49.000000000 +0100
+++ configmgr/source/inc/cacheddataprovider.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -67,10 +67,10 @@
 // ---------------------------------------------------------------------------
     struct CacheLocation
     {
-        memory::SegmentAddress          segment;
-        memory::SegmentHeap::Address    address;
+        memory::SegmentAddress segment;
+        memory::Address        address;
             
-        bool isNull() const { return segment.isNull() || address == 0; }
+        bool isNull() const { return segment == NULL || address == 0; }
     };
 // ---------------------------------------------------------------------------
     struct IDirectDataProvider;
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/datalock.hxx configmgr/source/inc/datalock.hxx
--- configmgr-before-refactor/source/inc/datalock.hxx	2005-09-08 04:46:50.000000000 +0100
+++ configmgr/source/inc/datalock.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -33,31 +33,3 @@
  *
  ************************************************************************/
 
-#ifndef CONFIGMGR_DATALOCK_HXX
-#define CONFIGMGR_DATALOCK_HXX
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-
-        /// class controlling access to a memory::Segment
-        struct DataLock
-        {
-	        virtual void acquireReadAccess() = 0;
-	        virtual void releaseReadAccess() = 0;
-
-	        virtual void acquireWriteAccess() = 0; 	        
-	        virtual void releaseWriteAccess() = 0;
-        protected:
-            virtual ~DataLock() {}
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-#endif // CONFIGMGR_DATALOCK_HXX
-
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/groupnodeaccess.hxx configmgr/source/inc/groupnodeaccess.hxx
--- configmgr-before-refactor/source/inc/groupnodeaccess.hxx	2006-11-03 11:35:17.000000000 +0000
+++ configmgr/source/inc/groupnodeaccess.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -107,7 +107,7 @@
 
             operator NodeAccessRef()    const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            DataType& data() const { return *(NodePointerType)m_pData; }
 
         private:
             static AddressType check(NodeAccessRef const&);
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/heapfactory.hxx configmgr/source/inc/heapfactory.hxx
--- configmgr-before-refactor/source/inc/heapfactory.hxx	2005-09-08 04:48:33.000000000 +0100
+++ configmgr/source/inc/heapfactory.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -36,21 +36,5 @@
 #ifndef CONFIGMGR_HEAPFACTORY_HXX
 #define CONFIGMGR_HEAPFACTORY_HXX
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-        class HeapManager;
-
-        HeapManager & localHeap();
-        HeapManager & cacheHeap();
-
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
 #endif // CONFIGMGR_HEAPFACTORY_HXX
 
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/heap.hxx configmgr/source/inc/heap.hxx
--- configmgr-before-refactor/source/inc/heap.hxx	2005-12-28 17:29:58.000000000 +0000
+++ configmgr/source/inc/heap.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -46,50 +46,5 @@
 #include <rtl/string.hxx>
 #endif
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class Heap : Noncopyable
-        {
-            HeapManager       & m_impl;
-            HeapManager::Handle m_heap;
-            HeapManager::Size   m_size;
-        public:
-            typedef HeapManager::Lock        Lock;
-            typedef HeapManager::Size        Size;
-            typedef HeapManager::HeapId      HeapId;
-            typedef HeapManager::HeapIdParam HeapIdParam;
-            typedef HeapManager::Address     Address;
-
-            Heap(HeapManager& _impl);
-            Heap(HeapManager& _impl, Size _nInitialSize);
-            Heap(HeapManager& _impl, HeapIdParam _anId);
-            ~Heap();
-
-            Size    size() const { return m_size; }
-
-            Size    grow(Size _nReqSize); 
-
-            void *  base() const   { return m_impl.base(m_heap); }
-            HeapId  id()   const   { return m_impl.id(m_heap); }
-
-            Address allocate(Size _sNewSize)    { return m_impl.allocate(m_heap, _sNewSize); }
-            Address reallocate(Address _aOldAddress, Size _sNewSize)    
-            { return m_impl.reallocate(m_heap, _aOldAddress, _sNewSize); }
-            void    deallocate(Address _aAddress)    { m_impl.deallocate(m_heap, _aAddress); }
-            bool    didAllocate(Address _aAddress) const 
-            { return m_impl.didAllocate(m_heap, _aAddress); }
-
-            Lock *  createLock()                { return m_impl.createHeapLock(m_heap); }
-            void    destroyLock(Lock * _pLock)  { m_impl.destroyHeapLock(m_heap,_pLock); }
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
 #endif // CONFIGMGR_DATAHEAP_HXX
 
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/heapmanager.hxx configmgr/source/inc/heapmanager.hxx
--- configmgr-before-refactor/source/inc/heapmanager.hxx	2005-12-28 17:30:19.000000000 +0000
+++ configmgr/source/inc/heapmanager.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -50,45 +50,7 @@
 #include <rtl/string.hxx>
 #endif
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class HeapManager
-        {
-        public:
-            typedef struct Opaque_ * Handle;
-
-            typedef memory::HeapSize    Size;
-            typedef memory::Address     Address;
-            typedef rtl::OString        HeapId;
-            typedef rtl::OString const & HeapIdParam;
-
-        //    virtual HeapId newHeapId() = 0;
-            virtual Handle createHeap(/*HeapIdParam _anId, */Size _sInitialSize) = 0;
-            virtual Handle attachHeap(HeapIdParam _anId, Size & _rInitialSize) = 0;
-            virtual Size   growHeap(Handle _aHeap, Size _sNewSize) = 0;
-            virtual void   destroyHeap(Handle _aHeap) = 0;
-
-            virtual void *  base(Handle _aHeap) = 0;
-            virtual HeapId  id(Handle _aHeap) = 0;
-
-            virtual Address allocate(Handle _aHeap, Size _sNewSize) = 0;
-            virtual Address reallocate(Handle _aHeap, Address _aOldAddress, Size _sNewSize) = 0;
-            virtual void    deallocate(Handle _aHeap, Address _aAddress) = 0;
-            virtual bool    didAllocate(Handle _aHeap, Address _aAddress) = 0;
-
-            typedef DataLock Lock;
-
-            virtual Lock *  createHeapLock(Handle _aHeap) = 0;
-            virtual void    destroyHeapLock(Handle _aHeap, Lock * _pLock) = 0;
-        };
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
+#include <osl/mutex.hxx>
 
 #endif // CONFIGMGR_DATAHEAPMANAGER_HXX
 
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/memorymodel.hxx configmgr/source/inc/memorymodel.hxx
--- configmgr-before-refactor/source/inc/memorymodel.hxx	2005-12-28 17:30:28.000000000 +0000
+++ configmgr/source/inc/memorymodel.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -40,30 +40,13 @@
 #include <sal/types.h>
 #endif
 
-//-----------------------------------------------------------------------------
-// no full heap implementation available yet - storing pointer value in Address
-#define CFG_ADDRESS_HOLDS_POINTER
-//-----------------------------------------------------------------------------
-
 namespace configmgr
 {
-//-----------------------------------------------------------------------------
-
     namespace memory 
     {
-    //-----------------------------------------------------------------------------
-    // some base types that describe our memory model
-#ifndef CFG_ADDRESS_HOLDS_POINTER
-        typedef sal_uInt32 Address; // points to relative location in memory segment
-#else
-        typedef sal_uIntPtr Address; // points to absolute location in memory
-#endif
-        typedef sal_uInt32 HeapSize; // memory block size within private heap
+        typedef sal_uInt8 *Address;
         typedef sal_uInt8  Byte;  
-    //-----------------------------------------------------------------------------
     }
-//-----------------------------------------------------------------------------
 }
 
-
 #endif // CONFIGMGR_MEMORYMODEL_HXX 
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/nodeaccess.hxx configmgr/source/inc/nodeaccess.hxx
--- configmgr-before-refactor/source/inc/nodeaccess.hxx	2006-11-03 11:35:43.000000000 +0000
+++ configmgr/source/inc/nodeaccess.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -53,11 +53,13 @@
 namespace configmgr
 {
 // -----------------------------------------------------------------------------	
+    namespace memory { class UpdateAccessor; }
+	
     namespace data
     {
     // -------------------------------------------------------------------------
         using memory::Accessor;
-    // -------------------------------------------------------------------------
+	    
     // -------------------------------------------------------------------------	
         class NodeAccess
 	    {
@@ -74,15 +76,15 @@
 
             NodeAccess(Accessor const& _aAccessor, NodeAddressType const& _aNodeRef) 
             : m_aAccessor(_aAccessor)
-            , m_pData(_aNodeRef.m_pData) 
+            , m_pData((NodePointerType)_aNodeRef.m_pData) 
             {}
 
-            NodeAccess(Accessor const& _aAccessor, NodePointerType _pNode) 
+            NodeAccess(Accessor const& _aAccessor, DataType *_pNode) 
             : m_aAccessor(_aAccessor)
-            , m_pData(_aAccessor.address(_pNode)) 
+            , m_pData(_pNode) 
             {}
 
-            bool isValid() const { return m_pData.is(); }
+            bool isValid() const { return m_pData != NULL; }
             bool isLocalRoot() const { return data().isFragmentRoot(); }
 
             Name getName() const { return wrapName( data().getName() ); }
@@ -91,25 +93,26 @@
             bool isDefault()   const { return data().isDefault(); }
             bool isLocalized() const { return data().isLocalized(); }
 
-            NodeAddressType address() const { return NodeAddressType(m_pData); }
+            NodeAddressType address() const { return NodeAddressType((AddressType)m_pData); }
             Accessor const& accessor() const { return m_aAccessor; }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
-            NodePointerType getDataPtr() const { return static_cast<NodePointerType>(m_aAccessor.access(m_pData)); }
-
-            AddressType rawAddress() const { return m_pData; }
+            DataType& data() const { return *m_pData; }
+            DataType *getDataPtr() const { return m_pData; }
 
             static Name wrapName(rtl::OUString const& _aNameString)
             { return configuration::makeName( _aNameString, Name::NoValidate() ); }
 
             static NodeAddress::DataType* access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor& _rUpdateAccess);
-            static NodeAddress::DataType const* access(NodeAddressType const& _aNodeRef, Accessor const& _rReaderAccess)
-            { return static_cast<NodePointerType>(_rReaderAccess.access(_aNodeRef.m_pData)); }
+            static NodeAddress::DataType const* access(NodeAddressType const& _aNodeRef, Accessor const&)
+            { return (NodeAddress::DataType *)_aNodeRef.m_pData; }
+
+	    operator AddressType () { return (AddressType) m_pData; }
+	    operator const AddressType () const { return (AddressType) m_pData; }
         private:
             NodeAccess() : m_aAccessor(NULL), m_pData() {}
 
-            Accessor    m_aAccessor;
-		    AddressType m_pData;
+            Accessor        m_aAccessor;
+	    NodePointerType m_pData;
         };
     // -------------------------------------------------------------------------	
         class NodeAccessRef
@@ -125,7 +128,7 @@
 
             NodeAccessRef(NodeAccess const& _aNodeAccess) 
             : m_pAccessor(&_aNodeAccess.accessor())
-            , m_pData(_aNodeAccess.rawAddress()) 
+            , m_pData(_aNodeAccess) 
             {}
 
             NodeAccessRef(Accessor const * _pAccessor, NodeAddressType const& _aNodeRef) 
@@ -135,12 +138,12 @@
 
             NodeAccessRef(Accessor const * _pAccessor, NodePointerType _pNode) 
             : m_pAccessor(_pAccessor)
-            , m_pData(_pAccessor->address(_pNode)) 
+            , m_pData((AddressType) _pNode) 
             {}
 
             NodeAccess toNodeAccess () const { return NodeAccess(accessor(),address()); }
 
-            bool isValid() const { return m_pData.is(); }
+            bool isValid() const { return m_pData != NULL; }
             bool isLocalRoot() const { return data().isFragmentRoot(); }
 
             Name getName() const { return NodeAccess::wrapName( data().getName() ); }
@@ -152,14 +155,13 @@
             NodeAddressType address() const { return NodeAddressType(m_pData); }
             Accessor const& accessor() const { return *m_pAccessor; }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_pAccessor->validate(m_pData)); }
-            NodePointerType getDataPtr() const { return static_cast<NodePointerType>(m_pAccessor->access(m_pData)); }
-
-            AddressType rawAddress() const { return m_pData; }
+            DataType& data() const { return *(DataType *)m_pData; }
+            DataType* getDataPtr() { return (DataType *)m_pData; }
+            DataType* getDataPtr() const { return (DataType *)m_pData; }
 
         private:
             Accessor const *   m_pAccessor;
-		    AddressType m_pData;
+	    AddressType m_pData;
         };
     // -------------------------------------------------------------------------
     // helper - finds child or element
Only in configmgr/source/inc: nodeaccess.hxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/nodeaddress.hxx configmgr/source/inc/nodeaddress.hxx
--- configmgr-before-refactor/source/inc/nodeaddress.hxx	2006-01-19 17:53:30.000000000 +0000
+++ configmgr/source/inc/nodeaddress.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -36,8 +36,8 @@
 #ifndef CONFIGMGR_NODEADDRESS_HXX
 #define CONFIGMGR_NODEADDRESS_HXX
 
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
 #endif
 
 #ifndef INCLUDED_SHARABLE_NODE_HXX
@@ -60,7 +60,7 @@
             friend class NodeAccessRef;
         public:
             typedef sharable::Node      DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
         public:
             NodeAddress() : m_pData() {}
@@ -68,17 +68,18 @@
             explicit
             NodeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+	    bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
-            AddressType::RawAddress addressValue() const { return m_pData.value(); }
+            AddressType addressValue() const { return m_pData; }
 
             friend bool operator == (NodeAddress const& lhs, NodeAddress const& rhs);
 
             friend bool operator != (NodeAddress const& lhs, NodeAddress const& rhs);
 
+	    operator AddressType () { return m_pData; }
         private:
-		    AddressType                 m_pData;
+	    AddressType                 m_pData;
         };
 
         inline bool operator == (NodeAddress const& lhs, NodeAddress const& rhs)
@@ -93,17 +94,17 @@
             friend class ValueNodeAccess;
         public:
             typedef sharable::ValueNode DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+            bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
             operator NodeAddress() const { return NodeAddress(m_pData); }
         private:
             explicit
             ValueNodeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
 
-		    AddressType m_pData;
+	    AddressType m_pData;
         };
     // -------------------------------------------------------------------------
 
@@ -112,10 +113,10 @@
             friend class GroupNodeAccess;
         public:
             typedef sharable::GroupNode DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+	    bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
             operator NodeAddress()        const { return NodeAddress(m_pData); }
         private:
@@ -131,10 +132,10 @@
             friend class SetNodeAccess;
         public:
             typedef sharable::SetNode   DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+	    bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
             operator NodeAddress()        const { return NodeAddress(m_pData); }
         private:
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/node.hxx configmgr/source/inc/node.hxx
--- configmgr-before-refactor/source/inc/node.hxx	2006-12-14 17:32:30.000000000 +0000
+++ configmgr/source/inc/node.hxx	2006-12-14 18:02:41.000000000 +0000
@@ -106,22 +106,20 @@
 
             bool isLocalizedValue() const;
 
-		    rtl::OUString getElementTemplateName  (memory::Accessor const & _anAccessor) const;		
-		    rtl::OUString getElementTemplateModule(memory::Accessor const & _anAccessor) const;
+		    rtl::OUString getElementTemplateName() const;		
+		    rtl::OUString getElementTemplateModule() const;
 
-            TreeFragment const  * getFirstElement(memory::Accessor const & _anAccessor) const;
-            TreeFragment const  * getNextElement(memory::Accessor const & _anAccessor, TreeFragment const * _pElement) const;
+            TreeFragment const  * getFirstElement() const;
+            TreeFragment const  * getNextElement(TreeFragment const * _pElement) const;
 
             // low-level helper for template data abstraction
             static
-            Address allocTemplateData(memory::Allocator const & _anAllocator,
-									  const rtl::OUString &rName,
+            Address allocTemplateData(const rtl::OUString &rName,
 									  const rtl::OUString &rModule);
             static 
-			Address copyTemplateData(memory::Allocator const & _anAllocator,
-									 Address _aTemplateData);
+			Address copyTemplateData(Address _aTemplateData);
             static
-            void releaseTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData);
+            void releaseTemplateData(Address _aTemplateData);
         };
     //-----------------------------------------------------------------------------
         struct ValueNode
Only in configmgr/source/inc: node.hxx.orig
Only in configmgr/source/inc: node.hxx.rej
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/pointer.hxx configmgr/source/inc/pointer.hxx
--- configmgr-before-refactor/source/inc/pointer.hxx	2005-12-28 17:30:54.000000000 +0000
+++ configmgr/source/inc/pointer.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -32,59 +32,3 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-
-#ifndef CONFIGMGR_POINTER_HXX
-#define CONFIGMGR_POINTER_HXX
-
-#ifndef CONFIGMGR_MEMORYMODEL_HXX
-#include "memorymodel.hxx"
-#endif
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class Accessor;
-        class UpdateAccessor;
-    // -------------------------------------------------------------------------	
-        /// class mediating read-only access to a memory::Segment
-        class Pointer 
-        {
-            friend class Accessor;
-            friend class UpdateAccessor;
-
-            typedef memory::Address AddressType;
-
-            AddressType m_value;
-
-            struct Opaque_;
-        public:
-            typedef AddressType RawAddress;
-
-            Pointer() : m_value(0) {}
-            explicit Pointer(AddressType p) : m_value(p) {}
-
-            RawAddress value() const { return m_value; }
-
-            bool isNull()   const { return m_value == 0; }
-            bool is()       const { return m_value != 0; }
-
-            operator Opaque_ const * () const { return reinterpret_cast<Opaque_ const *>(m_value); }
-
-            friend bool operator == (Pointer lhs, Pointer rhs)
-            { return lhs.value() == rhs.value(); }
-
-            friend bool operator != (Pointer lhs, Pointer rhs)
-            { return lhs.value() != rhs.value(); }
-        };
-
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-// -----------------------------------------------------------------------------
-
-#endif // CONFIGMGR_POINTER_HXX
-
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/segmentheap.hxx configmgr/source/inc/segmentheap.hxx
--- configmgr-before-refactor/source/inc/segmentheap.hxx	2005-09-08 04:55:20.000000000 +0100
+++ configmgr/source/inc/segmentheap.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -32,82 +32,3 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-
-#ifndef CONFIGMGR_SEGMENTHEAP_HXX
-#define CONFIGMGR_SEGMENTHEAP_HXX
-
-#ifndef CONFIGMGR_DATAHEAP_HXX
-#include "heap.hxx"
-#endif
-#ifndef CONFIGMGR_UTILITY_HXX_
-#include "utility.hxx"
-#endif
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-        class SegmentHeap : Noncopyable
-        {
-            friend class Segment;
-            typedef Heap::Lock Lock;
-
-            Heap   m_heap;
-            void * m_base;
-            Lock * m_lock;
-
-            Lock & lock() const { return *m_lock; }
-        public:
-            typedef Heap::HeapId        HeapId;
-            typedef Heap::HeapIdParam   HeapIdParam;
-            typedef Heap::Size          Size;
-            typedef Heap::Address       Address;
-            
-            SegmentHeap(HeapManager & _rImpl)
-            : m_heap(_rImpl)
-            { init(); }
-
-            SegmentHeap(HeapManager & _rImpl, Size _aInitialSize)
-            : m_heap(_rImpl,_aInitialSize)
-            { init(); }
-
-            SegmentHeap(HeapManager & _rImpl, HeapIdParam _anId)
-            : m_heap(_rImpl,_anId)
-            { init(); }
-
-            ~SegmentHeap();
-
-            // PRE: lock must be acquired
-            void*   base() const { return m_base; }
-            HeapId  id() const { return m_heap.id(); }
-
-            Address allocate(Size _sz) 
-            {
-                Address aResult = m_heap.allocate(_sz);
-                if (!aResult)
-                    aResult = this->allocateMore(_sz);
-                return aResult;
-            }
-
-            void deallocate(Address _addr) 
-            { 
-                m_heap.deallocate(_addr); 
-            }
-
-            bool isValidAddress(Address _addr) const
-            { 
-                return m_heap.didAllocate(_addr); 
-            }
-        private:
-            void init();
-            Address allocateMore(Size _sz);
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-#endif // CONFIGMGR_SEGMENT_HXX
-
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/segment.hxx configmgr/source/inc/segment.hxx
--- configmgr-before-refactor/source/inc/segment.hxx	2005-09-08 04:55:04.000000000 +0100
+++ configmgr/source/inc/segment.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -39,13 +39,15 @@
 #ifndef CONFIGMGR_DATALOCK_HXX
 #include "datalock.hxx"
 #endif
-#ifndef CONFIGMGR_SEGMENTHEAP_HXX
-#include "segmentheap.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
 #endif
 #ifndef _RTL_STRING_HXX_
 #include <rtl/string.hxx>
 #endif
 
+#include <osl/mutex.hxx>
+
 namespace configmgr
 {
 // -----------------------------------------------------------------------------	
@@ -54,65 +56,20 @@
     // -------------------------------------------------------------------------	
         class Segment
         {
-            SegmentHeap m_heap;
-        public:
-            typedef SegmentHeap     Heap;
-            typedef Heap::Lock      Lock;
-            typedef rtl::OString    Id;
-
+            osl::Mutex m_mutex;
         public:
-            explicit Segment(HeapManager & _aHeapImpl) 
-            : m_heap(_aHeapImpl) {}
-
-            explicit Segment(HeapManager & _aHeapImpl, Heap::Size _aInitialSize) 
-            : m_heap(_aHeapImpl,_aInitialSize) {}
+            explicit Segment() 
+            : m_mutex() {}
 
-            explicit Segment(HeapManager & _aHeapImpl, Id const & _anId) 
-            : m_heap(_aHeapImpl,_anId) {}
+			void acquireWriteAccess() { m_mutex.acquire(); }
+			void releaseWriteAccess() { m_mutex.release(); }
+			void downgradeAccess()    {}
 
-            Id getId() const { return m_heap.id(); }
-
-            bool isValidAddress(Heap::Address _aAddress) const
-            {
-                return m_heap.isValidAddress(_aAddress); 
-            }
-
-            Heap& acquireWriteAccess()       
-            { 
-                this->lock().acquireWriteAccess(); 
-                return this->heap(); 
-            }
-
-            void  releaseWriteAccess(Heap&)  
-            { 
-                this->lock().releaseWriteAccess(); 
-            }
-
-            void const * acquireReadAccess() const 
-            { 
-                this->lock().acquireReadAccess();
-                return base();
-            }
-            void releaseReadAccess (void const * ) const 
-            { 
-                this->lock().releaseReadAccess(); 
-            }
-        private:
-            Heap & heap()       { return m_heap; }
-            Lock & lock() const { return m_heap.lock(); }
-            void * base() const { return m_heap.base(); }
+			void acquireReadAccess() const { ((Segment *)this)->m_mutex.acquire(); }
+			void releaseReadAccess() const { ((Segment *)this)->m_mutex.release(); }
         };
-    // -------------------------------------------------------------------------
-        typedef Segment::Id SegmentID;
-    // -------------------------------------------------------------------------
-        struct SegmentAddress
-        {
-            SegmentID               id;
-            SegmentHeap::Address    base;
 
-            bool isNull() const { return base == 0; }
-        };
-    // -------------------------------------------------------------------------	
+		typedef memory::Address SegmentAddress;
     }
 // -----------------------------------------------------------------------------	
 } // namespace configmgr
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/sequence.hxx configmgr/source/inc/sequence.hxx
--- configmgr-before-refactor/source/inc/sequence.hxx	2005-09-08 04:55:37.000000000 +0100
+++ configmgr/source/inc/sequence.hxx	2006-12-14 17:59:12.000000000 +0000
@@ -56,19 +56,17 @@
         typedef Vector Sequence; // alternative name
     //-----------------------------------------------------------------------------
        
-        Sequence allocSequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, ::sal_Sequence const * _pSeqData);
-    //    Sequence copySequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, Sequence _aSeq);
-        void     freeSequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, Sequence _aSeq);
+        Sequence allocSequence(AnyData::TypeCode _aElementType, ::sal_Sequence const * _pSeqData);
+        void     freeSequence(AnyData::TypeCode _aElementType, Sequence _aSeq);
 
         ::sal_Sequence * readSequence(memory::Accessor const& _anAccessor, AnyData::TypeCode _aElementType, Sequence _aSeq);
         ::com::sun::star::uno::Any readAnySequence(memory::Accessor const& _anAccessor, AnyData::TypeCode _aElementType, Sequence _aSeq);
     //-----------------------------------------------------------------------------
 
-        Sequence allocBinary(memory::Allocator const& _anAllocator, ::com::sun::star::uno::Sequence<sal_Int8> const & _aBinaryValue);
-    //    Sequence copyBinary(memory::Allocator const& _anAllocator, Sequence _aSeq);
-        void freeBinary(memory::Allocator const& _anAllocator, Sequence _aSeq);
+        Sequence allocBinary(::com::sun::star::uno::Sequence<sal_Int8> const & _aBinaryValue);
+        void freeBinary(Sequence _aSeq);
 
-        ::com::sun::star::uno::Sequence<sal_Int8> readBinary(memory::Accessor const& _anAccessor, Sequence _aSeq);
+        ::com::sun::star::uno::Sequence<sal_Int8> readBinary(Sequence _aSeq);
     //-----------------------------------------------------------------------------
 
         template <class ET>
@@ -80,11 +78,11 @@
         }
 
         template <class ET>
-        Sequence allocSequence(memory::Allocator const& _anAllocator, ::com::sun::star::uno::Sequence<ET> const & _aSeq)
+        Sequence allocSequence(::com::sun::star::uno::Sequence<ET> const & _aSeq)
         {
             AnyData::TypeCode aTC = getElementTypeCode(_aSeq);
             ::sal_Sequence const * pSeqData = _aSeq.get();
-            return allocSequence(_anAllocator, aTC, pSeqData);
+            return allocSequence(aTC, pSeqData);
         }
 
         template <class ET>
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/setnodeaccess.hxx configmgr/source/inc/setnodeaccess.hxx
--- configmgr-before-refactor/source/inc/setnodeaccess.hxx	2006-11-03 11:35:56.000000000 +0000
+++ configmgr/source/inc/setnodeaccess.hxx	2006-12-14 18:02:36.000000000 +0000
@@ -113,7 +113,7 @@
 
             operator NodeAccessRef() const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            DataType& data() const { return *(NodePointerType)m_pData; }
 
             static void addElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, ElementAddress _aNewElement);
             static ElementAddress removeElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, Name const & _aName);
@@ -136,11 +136,11 @@
         
         inline 
 		NodeAccess::Name SetNodeAccess::getElementTemplateName()   const 
-        { return NodeAccess::wrapName( data().getElementTemplateName(m_aAccessor) ); }	
+        { return NodeAccess::wrapName( data().getElementTemplateName() ); }	
         
         inline 
 		NodeAccess::Name SetNodeAccess::getElementTemplateModule() const 
-        { return NodeAccess::wrapName( data().getElementTemplateModule(m_aAccessor) ); }	
+        { return NodeAccess::wrapName( data().getElementTemplateModule() ); }	
         
         inline           
         NodeAccess::Attributes SetNodeAccess::getAttributes() const 
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/treeaccessor.hxx configmgr/source/inc/treeaccessor.hxx
--- configmgr-before-refactor/source/inc/treeaccessor.hxx	2006-11-03 11:36:16.000000000 +0000
+++ configmgr/source/inc/treeaccessor.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -86,7 +86,7 @@
 
             TreeAccessor(Accessor const& _aAccessor, DataPointerType _pTree) 
             : m_aAccessor(_aAccessor)
-            , m_pBase(_aAccessor.address(_pTree)) 
+            , m_pBase((TreeAddress::AddressType)_pTree)
             {}
 
             bool isValid() const { return m_pBase.is(); }
@@ -101,8 +101,8 @@
             DataAddressType address() const { return m_pBase; }
             Accessor const& accessor() const { return m_aAccessor; }
 
-            DataType& data() const { return *static_cast<DataPointerType>(m_aAccessor.validate(m_pBase.m_pData)); }
-            DataPointerType getDataPtr() const { return access(m_pBase,m_aAccessor); }
+            DataType& data() const { return *(DataPointerType )m_pBase.m_pData; }
+            DataPointerType getDataPtr() const { return (DataPointerType )m_pBase.m_pData; }
 
             TreeAddress copyTree(memory::UpdateAccessor & _aTargetSpace) const;
             static void freeTree(memory::UpdateAccessor & _aTargetSpace, TreeAddress _aTree);
@@ -111,15 +111,15 @@
             { return configuration::makeName( _aNameString, Name::NoValidate() ); }
 
             static TreeAddress::DataType* access(DataAddressType const& _aTreeRef, memory::UpdateAccessor& _rUpdateAccess);
-            static TreeAddress::DataType const* access(DataAddressType const& _aTreeRef, Accessor const& _rReaderAccess)
-            { return static_cast<DataPointerType>(_rReaderAccess.access(_aTreeRef.m_pData)); }
+            static TreeAddress::DataType const* access(DataAddressType const& _aTreeRef, Accessor const&)
+            { return (DataPointerType)_aTreeRef.m_pData; }
         private:
             NodeAddress rootAddress(DataAddressType const& p) const;
 
             TreeAccessor();
         private:
             Accessor            m_aAccessor;
-		    DataAddressType     m_pBase;
+	    DataAddressType     m_pBase;
         };
     // -------------------------------------------------------------------------
     // -------------------------------------------------------------------------
@@ -136,7 +136,7 @@
 
             if (aAddr) aAddr += offsetof(TreeAddress::DataType,nodes);
 
-            return NodeAddress( memory::Pointer(aAddr) ); 
+            return NodeAddress( (memory::Address) aAddr ); 
         }
     // -------------------------------------------------------------------------
     }
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/treeaddress.hxx configmgr/source/inc/treeaddress.hxx
--- configmgr-before-refactor/source/inc/treeaddress.hxx	2005-09-08 04:58:45.000000000 +0100
+++ configmgr/source/inc/treeaddress.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -36,8 +36,8 @@
 #ifndef CONFIGMGR_TREEADDRESS_HXX
 #define CONFIGMGR_TREEADDRESS_HXX
 
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
 #endif
 
 #ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
@@ -58,17 +58,17 @@
             friend class TreeAccessor;
         public:
             typedef sharable::TreeFragment  DataType;
-            typedef memory::Pointer         AddressType;
+            typedef memory::Address         AddressType;
         public:
             TreeAddress() : m_pData() {}
 
             explicit
             TreeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+            bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
-            AddressType::RawAddress addressValue() const { return m_pData.value(); }
+            memory::Address addressValue() const { return m_pData; }
 
             friend bool operator == (TreeAddress const& lhs, TreeAddress const& rhs)
             { return lhs.m_pData == rhs.m_pData; }
@@ -77,7 +77,7 @@
             { return lhs.m_pData != rhs.m_pData; }
 
         private:
-		    AddressType m_pData;
+	    AddressType m_pData;
         };
     // -------------------------------------------------------------------------
     }
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/treemanager.hxx configmgr/source/inc/treemanager.hxx
--- configmgr-before-refactor/source/inc/treemanager.hxx	2005-09-08 04:59:42.000000000 +0100
+++ configmgr/source/inc/treemanager.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -104,12 +104,10 @@
 		/** ctor
 		*/
         explicit
-        TreeManager(BackendCacheRef const & _xBackend, memory::HeapManager & _rCacheHeapManager);
+        TreeManager(BackendCacheRef const & _xBackend);
 
 		// disposing the cache before destroying		
 		void dispose();
-		
-        memory::HeapManager & getCacheHeapManager() const;
 
 		// ITreeManager
         virtual memory::Segment* getDataSegment(AbsolutePath const& _rAccessor, 
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/types.hxx configmgr/source/inc/types.hxx
--- configmgr-before-refactor/source/inc/types.hxx	2006-11-03 11:36:43.000000000 +0000
+++ configmgr/source/inc/types.hxx	2006-12-14 17:56:34.000000000 +0000
@@ -53,12 +53,12 @@
 
 namespace configmgr
 {
+    namespace memory { class Accessor; };
     namespace sharable
     {
     //-----------------------------------------------------------------------------
     // some base types
         typedef memory::Address  Address;  // points to absolute location in memory segment
-        typedef memory::HeapSize HeapSize; // size of memory block within heap
         typedef sal_uInt16 Offset;  // Offset relative to 'this' in array of nodes
         typedef sal_uInt8  Byte;  
 
Only in configmgr/source/inc: types.hxx.orig
Only in configmgr/source/inc: types.hxx.rej
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/updateaccessor.hxx configmgr/source/inc/updateaccessor.hxx
--- configmgr-before-refactor/source/inc/updateaccessor.hxx	2005-12-28 17:31:29.000000000 +0000
+++ configmgr/source/inc/updateaccessor.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -54,35 +54,13 @@
     // -------------------------------------------------------------------------
         class Segment;
         class SegmentHeap;
-    // -------------------------------------------------------------------------
-
-        class Allocator
-        {
-            SegmentHeap *   m_heap;
-
-        public:
-            typedef memory::Address Address;
-            typedef memory::HeapSize Size;
 
-            Address allocate(Size _sz) const;
-            void deallocate(Address _addr) const;
-
-            void *      access(Address _addr) const;
-            Address     address(void const * _p) const;
-
-        private:
-            friend class UpdateAccessor;
-
-            Allocator(SegmentHeap * _heap) : m_heap(_heap) {}
-            char * heap_base() const;
-        };
     // -------------------------------------------------------------------------
         class UpdateAccessor : Noncopyable
         {
             Segment *       m_segment;
-            SegmentHeap *   m_heap;
         public:
-            typedef Accessor::AddressType AddressType;
+            typedef memory::Address AddressType;
 
             /// constructs an accessor on the given Segment
             explicit UpdateAccessor(Segment * segment);
@@ -95,46 +73,7 @@
             Accessor accessor() const;
             Accessor downgrade(); // return accessor and clear
             void clear();
-
-            AddressType address(void const * _p) const
-            { return (this->is()) ? reduce(_p) : Pointer();}
-
-            void * access(AddressType _p) const
-            { return (this->is()) ? resolve(_p) : Accessor::failNull();}
-
-            void * validate(AddressType _p) const
-            { return (this->is() && _p.is()) ? resolve(_p) : Accessor::failNull(); }
-
-        // allocation support
-            Allocator allocator() const { return Allocator(m_heap); }
-        private:
-            char * heap_base() const;
-            void * resolve(AddressType _p) const;
-            AddressType  reduce(void const * _p) const;
         };
-    // -------------------------------------------------------------------------
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline
-        void * UpdateAccessor::resolve(AddressType _p) const
-        { return _p.is() ? heap_base() + _p.value() : NULL; }
-
-        inline
-        Pointer  UpdateAccessor::reduce(void const * _p) const
-        { return _p ? Pointer(static_cast<char const *>(_p) - heap_base()) : Pointer(); }
-  #endif // OSL_DEBUG_LEVEL
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline
-        void * Allocator::access(Address _addr) const
-        { return _addr ? heap_base() + _addr : NULL; }
-
-        inline
-        Allocator::Address  Allocator::address(void const * _p) const
-        { return _p ? (static_cast<char const *>(_p) - heap_base()) : 0; }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/inc/valuenodeaccess.hxx configmgr/source/inc/valuenodeaccess.hxx
--- configmgr-before-refactor/source/inc/valuenodeaccess.hxx	2006-11-03 11:36:56.000000000 +0000
+++ configmgr/source/inc/valuenodeaccess.hxx	2006-12-14 17:35:45.000000000 +0000
@@ -110,15 +110,15 @@
             NodeAddressType address()   const { return NodeAddressType(m_pData); }
             Accessor const& accessor()  const { return m_aAccessor; }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            DataType& data() const { return *(NodePointerType)m_pData; }
 
             operator NodeAccessRef() const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
         private:
-            static AddressType check(Accessor const& _acc, NodePointerType _p) { return _acc.address(_p); }
+            static AddressType check(Accessor const&, NodePointerType _p) { return (AddressType)_p; }
             static AddressType check(NodeAccessRef const& _aNodeData);
 
             Accessor    m_aAccessor;
-		    AddressType m_pData;
+	    AddressType m_pData;
         };
 
         ValueNodeAddress toValueNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr);
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/tree/builddata.cxx configmgr/source/tree/builddata.cxx
--- configmgr-before-refactor/source/tree/builddata.cxx	2006-12-14 17:32:30.000000000 +0000
+++ configmgr/source/tree/builddata.cxx	2006-12-14 17:44:26.000000000 +0000
@@ -100,9 +100,7 @@
     {
     //-------------------------------------------------------------------------
         using namespace sharable;
-        using memory::Pointer;
         using memory::Accessor;
-        using memory::Allocator;
         using memory::UpdateAccessor;
 //-----------------------------------------------------------------------------
 
@@ -112,7 +110,7 @@
     {
         Address aRawAddr = _aNode.addressValue() + _nOffset * sizeof(Node);
 
-        return NodeAddress(Pointer(aRawAddr));
+        return NodeAddress(aRawAddr);
     }
 
     static 
@@ -123,7 +121,7 @@
                             offsetof(TreeFragment,nodes) + 
                             _nOffset * sizeof(Node);
 
-        return NodeAddress(Pointer(aRawAddr));
+        return NodeAddress(aRawAddr);
     }
 
 //-----------------------------------------------------------------------------
@@ -228,7 +226,6 @@
         TreeNodeBuilder&    builder()         { return m_builder; }
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
         TreeNodeBuilder     m_builder;
@@ -399,7 +396,6 @@
     protected:
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
     };
@@ -427,7 +423,6 @@
     private:
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
     };
@@ -646,9 +641,9 @@
 
     OSL_ASSERT(nFragmentSize >= sizeof m_header + m_header.count*sizeof(Node));
 
-    Address aBaseAddress = _anUpdater.allocator().allocate(nFragmentSize);
+    Address aBaseAddress = Address(new sal_uInt8[ nFragmentSize ]);
 
-    TreeAddress aResult = TreeAddress( memory::Pointer(aBaseAddress) );
+    TreeAddress aResult = TreeAddress( aBaseAddress );
 
     if (TreeFragment * pFragment = TreeAccessor::access(aResult,_anUpdater))
     {
@@ -763,12 +758,12 @@
 
     AnyData aNewValue, aNewDefault;
     if (aFlags & Flags::valueAvailable)   
-        aNewValue = allocData(allocator(), aType, aSrc.getUserValue(_aNode.accessor()));
+        aNewValue = allocData(aType, aSrc.getUserValue(_aNode.accessor()));
     else
         aNewValue.data = 0;
 
     if (aFlags & Flags::defaultAvailable)   
-        aNewDefault = allocData(allocator(), aType, aSrc.getDefaultValue(_aNode.accessor()));
+        aNewDefault = allocData(aType, aSrc.getDefaultValue(_aNode.accessor()));
     else
         aNewDefault.data = 0;
     
@@ -814,7 +809,7 @@
         
 Address CopyingDataTreeBuilder::makeTemplateData(Address _aSourceTemplate)
 {
-    return SetNode::copyTemplateData(allocator(), _aSourceTemplate);
+    return SetNode::copyTemplateData(_aSourceTemplate);
 }
 //-----------------------------------------------------------------------------
 
@@ -927,7 +922,7 @@
         uno::Any aValue = _aNode.getValue();
         if (aValue.hasValue())
         {
-            aNewValue = allocData(allocator(), aType, aValue);
+            aNewValue = allocData(aType, aValue);
             aFlags |= Flags::valueAvailable;
         }
     }
@@ -937,7 +932,7 @@
         uno::Any aDefault = _aNode.getDefault();
         if (aDefault.hasValue())
         {
-            aNewDefault = allocData(allocator(), aType, aDefault);
+            aNewDefault = allocData(aType, aDefault);
             aFlags |= Flags::defaultAvailable;
         }
     }
@@ -1004,7 +999,7 @@
 
 Address ConvertingDataTreeBuilder::makeTemplateData(rtl::OUString const & _aTemplateName, rtl::OUString const & _aTemplateModule)
 {
-    return SetNode::allocTemplateData(allocator(), _aTemplateName, _aTemplateModule );
+    return SetNode::allocTemplateData(_aTemplateName, _aTemplateModule );
 }
 //-----------------------------------------------------------------------------
 
@@ -1201,9 +1196,9 @@
         destroyNode( addressOfNodeAt(_aBaseAddress,i) );
     }
 
-    allocator().deallocate( _aBaseAddress.addressValue() );
+    delete [] (sal_uInt8 *) _aBaseAddress.addressValue();
 
-    return TreeAddress( Pointer(aNext) );
+    return TreeAddress( aNext );
 }
 //-----------------------------------------------------------------------------
 
@@ -1250,7 +1245,7 @@
 
 void DataTreeCleanup::destroyData(sharable::SetNode * _pNode)
 {
-    TreeAddress aElement( Pointer( _pNode->elements ) );
+    TreeAddress aElement( _pNode->elements );
 
     Address aTemplate = _pNode->elementType;;
 
@@ -1259,7 +1254,7 @@
     while (aElement.is())
         aElement = destroyTree(aElement);
 
-    SetNode::releaseTemplateData( allocator(), aTemplate );
+    SetNode::releaseTemplateData( aTemplate );
 }
 //-----------------------------------------------------------------------------
 	
@@ -1278,10 +1273,10 @@
     destroyData(&_pNode->info);
 
     if (aFlags & Flags::valueAvailable) 
-        freeData( allocator(), aValueType, _pNode->value );
+        freeData( aValueType, _pNode->value );
 
     if (aFlags & Flags::defaultAvailable) 
-        freeData( allocator(), aValueType, _pNode->defaultValue );
+        freeData( aValueType, _pNode->defaultValue );
     
 }
 //-----------------------------------------------------------------------------
Only in configmgr/source/tree: builddata.cxx.orig
Only in configmgr/source/tree: builddata.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/tree/cmtree.cxx configmgr/source/tree/cmtree.cxx
--- configmgr-before-refactor/source/tree/cmtree.cxx	2006-11-03 11:37:26.000000000 +0000
+++ configmgr/source/tree/cmtree.cxx	2006-12-14 17:44:58.000000000 +0000
@@ -253,7 +253,7 @@
 		{
 			INode* pINode = *it2;
 			OUString aName2 = pINode->getName();
-			volatile int dummy;
+			volatile int dummy = 0;
             dummy = 0;
 		}
 #endif
Only in configmgr/source/tree: cmtree.cxx.orig
Only in configmgr/source/tree: cmtree.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/tree/groupnodeaccess.cxx configmgr/source/tree/groupnodeaccess.cxx
--- configmgr-before-refactor/source/tree/groupnodeaccess.cxx	2006-11-03 11:37:40.000000000 +0000
+++ configmgr/source/tree/groupnodeaccess.cxx	2006-12-14 17:35:45.000000000 +0000
@@ -50,23 +50,19 @@
     namespace data
     {
     // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
 
-        Pointer GroupNodeAccess::check(Accessor const& _aAccessor, sharable::GroupNode const* pInnerNode)
+        GroupNodeAccess::AddressType GroupNodeAccess::check(Accessor const&, sharable::GroupNode const* pInnerNode)
         {
-            return _aAccessor.address(pInnerNode);      
+            return (GroupNodeAccess::AddressType) pInnerNode;
         }
     // -------------------------------------------------------------------------
 
-        Pointer GroupNodeAccess::check(NodeAccessRef const& _aNode)
+        GroupNodeAccess::AddressType GroupNodeAccess::check(NodeAccessRef const& _aNode)
         {
             if (sharable::Node const* pNode = _aNode.getDataPtr())
                 return check(_aNode.accessor(), pNode->groupData());
-
             else
-                return Pointer();
+		return NULL;
         }
     // -------------------------------------------------------------------------
         bool GroupNodeAccess::hasChildren() const
Only in configmgr/source/tree: groupnodeaccess.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/tree/nodeaccess.cxx configmgr/source/tree/nodeaccess.cxx
--- configmgr-before-refactor/source/tree/nodeaccess.cxx	2006-09-16 16:21:45.000000000 +0100
+++ configmgr/source/tree/nodeaccess.cxx	2006-12-14 17:35:45.000000000 +0000
@@ -68,9 +68,9 @@
     {
     // -------------------------------------------------------------------------
         
-        NodeAddress::DataType* NodeAccess::access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor& _rUpdateAccess)
+        NodeAddress::DataType* NodeAccess::access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor&)
         { 
-            return static_cast<NodeAddress::DataType*>(_rUpdateAccess.access(_aNodeRef.m_pData)); 
+            return (NodeAddress::DataType *)_aNodeRef.addressValue();
         }
     // -------------------------------------------------------------------------
 
Only in configmgr/source/tree: nodeaccess.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/tree/node.cxx configmgr/source/tree/node.cxx
--- configmgr-before-refactor/source/tree/node.cxx	2006-12-14 17:32:30.000000000 +0000
+++ configmgr/source/tree/node.cxx	2006-12-14 18:04:17.000000000 +0000
@@ -226,68 +226,55 @@
 };
 //-----------------------------------------------------------------------------
 static inline
-SetNodeTemplateData * readTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData)
+SetNodeTemplateData * readTemplateData(Address _aTemplateData)
 {
-    return static_cast<SetNodeTemplateData *>( _anAllocator.access(_aTemplateData) );
-}
-//-----------------------------------------------------------------------------
-static inline
-SetNodeTemplateData const * readTemplateData(memory::Accessor const & _anAccessor, Address _aTemplateData)
-{
-    return static_cast<SetNodeTemplateData const*>( _anAccessor.access(memory::Pointer(_aTemplateData)) );
+    return reinterpret_cast<SetNodeTemplateData *>( _aTemplateData );
 }
 //-----------------------------------------------------------------------------
 
-Address SetNode::allocTemplateData(memory::Allocator const & _anAllocator,
-								   const rtl::OUString &rName,
+Address SetNode::allocTemplateData(const rtl::OUString &rName,
 								   const rtl::OUString &rModule)
 {
-    Address aData = _anAllocator.allocate(sizeof(SetNodeTemplateData));
+    SetNodeTemplateData * pData = new SetNodeTemplateData();
 
-    if (aData)
-    {
-        SetNodeTemplateData * pData = readTemplateData(_anAllocator,aData);
-
-        OSL_ENSURE(pData, "Creating template data: unexpected NULL data");
+    OSL_ENSURE(pData, "Creating template data: unexpected NULL data");
     
-        pData->name   = allocName(rName);
-        pData->module = allocName(rModule);
-    }
-    return aData;
+    pData->name   = allocName(rName);
+    pData->module = allocName(rModule);
+
+    return reinterpret_cast<memory::Address>( pData );
 }
 
-Address SetNode::copyTemplateData(memory::Allocator const & _anAllocator, 
-								  Address _aTemplateData)
+Address SetNode::copyTemplateData(Address _aTemplateData)
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAllocator,_aTemplateData);
+    SetNodeTemplateData const * pData = readTemplateData(_aTemplateData);
 
     OSL_ENSURE(pData, "Copying template data: unexpected NULL data");
 
-    return allocTemplateData(_anAllocator, readName(pData->name),
-							 readName(pData->module));
+    return allocTemplateData(readName(pData->name), readName(pData->module));
 }
 
 //-----------------------------------------------------------------------------
 
-void SetNode::releaseTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData)
+void SetNode::releaseTemplateData(Address _aTemplateData)
 {
     if (!_aTemplateData) return;
 
-    SetNodeTemplateData const * pData = readTemplateData(_anAllocator,_aTemplateData);
+    SetNodeTemplateData const * pData = readTemplateData(_aTemplateData);
 
     OSL_ENSURE(pData, "Freeing template data: unexpected NULL data");
     
     freeName(pData->name);
     freeName(pData->module);
 
-    _anAllocator.deallocate(_aTemplateData);
+    delete pData;
 }
 
 //-----------------------------------------------------------------------------
 
-rtl::OUString SetNode::getElementTemplateName(memory::Accessor const & _anAccessor)   const
+rtl::OUString SetNode::getElementTemplateName() const
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAccessor,this->elementType);
+    SetNodeTemplateData const * pData = readTemplateData(this->elementType);
 
     OSL_ENSURE(pData, "ERROR: No template data found for set");
     
@@ -295,9 +282,9 @@
 }
 //-----------------------------------------------------------------------------
 
-rtl::OUString SetNode::getElementTemplateModule(memory::Accessor const & _anAccessor) const
+rtl::OUString SetNode::getElementTemplateModule() const
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAccessor,this->elementType);
+    SetNodeTemplateData const * pData = readTemplateData(this->elementType);
 
     OSL_ENSURE(pData, "ERROR: No template data found for set");
     
@@ -306,25 +293,25 @@
 //-----------------------------------------------------------------------------
 
 static inline
-TreeFragment const * implGetFragmentFromList(memory::Accessor const & _anAccessor, List _aListEntry)
+TreeFragment const * implGetFragmentFromList(List _aListEntry)
 {
-    return static_cast<TreeFragment const *>(_anAccessor.access(memory::Pointer(_aListEntry)));
+    return reinterpret_cast<TreeFragment const *>(_aListEntry);
 }
 //-----------------------------------------------------------------------------
 
-TreeFragment const  * SetNode::getFirstElement(memory::Accessor const & _anAccessor) const   
+TreeFragment const  * SetNode::getFirstElement() const   
 {
-    return implGetFragmentFromList(_anAccessor, this->elements);
+    return implGetFragmentFromList(this->elements);
 }
 //-----------------------------------------------------------------------------
 
-TreeFragment const  * SetNode::getNextElement(memory::Accessor const & _anAccessor, TreeFragment const * _pElement) const    
+TreeFragment const  * SetNode::getNextElement(TreeFragment const * _pElement) const    
 {
     OSL_PRECOND(_pElement, "getNextElement: previous element must not be NULL");
-    OSL_PRECOND(_pElement->header.parent == _anAccessor.address(this).value(), 
+    OSL_PRECOND(_pElement->header.parent == (memory::Address)this, 
                 "getNextElement: not an element of this node");
 
-    return implGetFragmentFromList(_anAccessor, _pElement->header.next);
+    return implGetFragmentFromList(_pElement->header.next);
 }
 //-----------------------------------------------------------------------------
 
Only in configmgr/source/tree: node.cxx.orig
Only in configmgr/source/tree: node.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/tree/nodevisitor.cxx configmgr/source/tree/nodevisitor.cxx
--- configmgr-before-refactor/source/tree/nodevisitor.cxx	2006-09-16 16:22:12.000000000 +0100
+++ configmgr/source/tree/nodevisitor.cxx	2006-12-14 18:04:41.000000000 +0000
@@ -169,9 +169,9 @@
     void SetVisitor::Dispatcher::applyToElements(sharable::SetNode const & _aNode)
     {
         using sharable::TreeFragment;
-        for (TreeFragment const * pElement = _aNode.getFirstElement(m_accessor);
+        for (TreeFragment const * pElement = _aNode.getFirstElement();
                 pElement != NULL && m_result != NodeVisitor::DONE;
-                pElement = _aNode.getNextElement(m_accessor,pElement) )
+                pElement = _aNode.getNextElement(pElement) )
             m_result = dispatch(*pElement);
 
     }
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/tree/setnodeaccess.cxx configmgr/source/tree/setnodeaccess.cxx
--- configmgr-before-refactor/source/tree/setnodeaccess.cxx	2006-11-03 11:38:06.000000000 +0000
+++ configmgr/source/tree/setnodeaccess.cxx	2006-12-14 18:05:43.000000000 +0000
@@ -57,22 +57,18 @@
     namespace data
     {
     // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-        Pointer SetNodeAccess::check(Accessor const& _aAccessor, sharable::SetNode const* pInnerNode)
+        SetNodeAccess::AddressType SetNodeAccess::check(Accessor const&, sharable::SetNode const* pInnerNode)
         {
-            return _aAccessor.address(pInnerNode);      
+            return (SetNodeAccess::AddressType) pInnerNode;
         }
     // -------------------------------------------------------------------------
 
-        Pointer SetNodeAccess::check(NodeAccessRef const& _aNode)
+        SetNodeAccess::AddressType SetNodeAccess::check(NodeAccessRef const& _aNode)
         {
             if (sharable::Node const* pNode = _aNode.getDataPtr())
                 return check(_aNode.accessor(),pNode->setData());
-
             else
-                return Pointer();
+                return NULL;
         }
     // -------------------------------------------------------------------------
     
@@ -80,9 +76,9 @@
         {
             using namespace sharable;
             SetNode const  & aNode = data();
-            for (TreeFragment const * pElement = aNode.getFirstElement(m_aAccessor);
+            for (TreeFragment const * pElement = aNode.getFirstElement();
                        pElement  != NULL;
-                       pElement  = aNode.getNextElement(m_aAccessor, pElement))
+                       pElement  = aNode.getNextElement(pElement))
             {
                 if (pElement->isNamed(_aName.toString()))
                 {
@@ -98,7 +94,7 @@
         {
             using namespace sharable;
 
-            SetNode * pNode = static_cast<SetNode *>( _aAccessor.access( _aSetAddress.m_pData) );
+            SetNode * pNode = (SetNode *)_aSetAddress.m_pData;
             OSL_ENSURE(pNode, "ERROR: Trying to add an element to a NULL set node");
 
             // To do (?): insert sorted - find location here
@@ -106,7 +102,7 @@
             OSL_ENSURE(pElement, "ERROR: Trying to add a NULL element to a set node");
 
             pElement->header.next   = pNode->elements;
-            pElement->header.parent = _aSetAddress.m_pData.value();
+            pElement->header.parent = _aSetAddress.m_pData;
 
             pNode->elements = _aNewElement.addressValue();
         }
@@ -115,20 +111,18 @@
         TreeAddress SetNodeAccess::removeElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, Name const & _aName)
         {
             using namespace sharable;
-            using memory::Pointer;
             
-            SetNode * pNode = static_cast<SetNode *>( _aAccessor.access( _aSetAddress.m_pData) );
+            SetNode * pNode = reinterpret_cast<SetNode *>(  _aSetAddress.m_pData );
             OSL_ENSURE(pNode, "ERROR: Trying to add an element to a NULL set node");
 
             TreeAddress aRemoved;
             
             List * pLink = & pNode->elements;
-            while( TreeFragment * pElement = static_cast<TreeFragment *>(_aAccessor.access(Pointer(*pLink))) )
+            while( TreeFragment * pElement = reinterpret_cast<TreeFragment *>(*pLink) )
             {
                 if (pElement->isNamed(_aName.toString()))
                 {
-                    aRemoved = TreeAddress( Pointer(*pLink) );
-                   // aRemoved = TreeAccessor(_aReadAccessor,pElement).address();
+                    aRemoved = TreeAddress( *pLink );
 
                     *pLink = pElement->header.next;
                     pElement->header.next   = 0;
Only in configmgr/source/tree: setnodeaccess.cxx.orig
Only in configmgr/source/tree: setnodeaccess.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/tree/treeaccessor.cxx configmgr/source/tree/treeaccessor.cxx
--- configmgr-before-refactor/source/tree/treeaccessor.cxx	2006-09-16 16:22:40.000000000 +0100
+++ configmgr/source/tree/treeaccessor.cxx	2006-12-14 17:35:45.000000000 +0000
@@ -59,15 +59,15 @@
     // -------------------------------------------------------------------------
         TreeAccessor::TreeAccessor()
         : m_aAccessor(NULL)
-        , m_pBase( memory::Pointer() )
+        , m_pBase( NULL )
         {
         }
 
     // -------------------------------------------------------------------------
 
-        TreeAddress::DataType* TreeAccessor::access(DataAddressType const& _aTreeRef, memory::UpdateAccessor& _rUpdateAccess)
+        TreeAddress::DataType* TreeAccessor::access(DataAddressType const& _aTreeRef, memory::UpdateAccessor&)
         { 
-            return static_cast<TreeAddress::DataType*>(_rUpdateAccess.access(_aTreeRef.m_pData)); 
+            return (TreeAddress::DataType *)_aTreeRef.m_pData;
         }
     // -------------------------------------------------------------------------
         TreeAddress TreeAccessor::copyTree(memory::UpdateAccessor & _aTargetSpace) const
Only in configmgr/source/tree: treeaccessor.cxx.orig
Only in configmgr/source/tree: treefragment.cxx.orig
Only in configmgr/source/tree: treefragment.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/tree/treesegment.cxx configmgr/source/tree/treesegment.cxx
--- configmgr-before-refactor/source/tree/treesegment.cxx	2006-11-03 11:38:31.000000000 +0000
+++ configmgr/source/tree/treesegment.cxx	2006-12-14 17:35:45.000000000 +0000
@@ -72,23 +72,14 @@
     namespace data
     {
 // -----------------------------------------------------------------------------	
-
-//        typedef std::auto_ptr<INode> RawTreeData;
-//        typedef configuration::Name  Name;
-        using memory::Pointer;
-
-// -----------------------------------------------------------------------------	
-// -----------------------------------------------------------------------------	
 struct TreeSegment::Impl : salhelper::SimpleReferenceObject
 {
-    Impl() : data( memory::localHeap() ), base() {}
+    Impl() : data(), base() {}
     ~Impl();
 
     memory::Segment     data;
     data::TreeAddress   base;
 };
-// -----------------------------------------------------------------------------	
-// -----------------------------------------------------------------------------	
 
 // -----------------------------------------------------------------------------	
 TreeSegment::TreeSegment()
Only in configmgr/source/tree: treesegment.cxx.orig
Only in configmgr/source/tree: treesegment.cxx.rej
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/tree/valuenodeaccess.cxx configmgr/source/tree/valuenodeaccess.cxx
--- configmgr-before-refactor/source/tree/valuenodeaccess.cxx	2006-09-16 16:24:22.000000000 +0100
+++ configmgr/source/tree/valuenodeaccess.cxx	2006-12-14 17:35:45.000000000 +0000
@@ -54,29 +54,24 @@
     namespace data
     {
     // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-        static 
-        ValueNodeAddress::DataType* accessValue(Pointer const& _p, memory::UpdateAccessor& _rUpdateAccess)
+	static inline
+	ValueNodeAddress::DataType* accessValue(ValueNodeAddress::AddressType _p)
         {
-            return static_cast<ValueNodeAddress::DataType*>( _rUpdateAccess.validate(_p) );
+            return (ValueNodeAddress::DataType *) _p;
         }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
 
-        Pointer ValueNodeAccess::check(NodeAccessRef const& _aNode)
+        ValueNodeAddress::AddressType ValueNodeAccess::check(NodeAccessRef const& _aNode)
         {
             if (sharable::Node const* pNode = _aNode.getDataPtr())
-                return _aNode.accessor().address(pNode->valueData());
-
+                return (ValueNodeAddress::AddressType) pNode->valueData();
             else
-                return Pointer();
+		return NULL;
         }
     // -------------------------------------------------------------------------
 		    
-void ValueNodeAccess::setValue(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue)
+void ValueNodeAccess::setValue(memory::UpdateAccessor &, NodeAddressType _aValueNode, uno::Any const& _aValue)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = accessValue(_aValueNode.m_pData);
 
     using namespace sharable;
     AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
@@ -86,8 +81,8 @@
     {
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->value);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->value);
+        node = accessValue(_aValueNode.m_pData);
 
         node->value.data = 0;
         node->info.flags ^= Flags::valueAvailable;
@@ -114,8 +109,8 @@
         if (aType == aNewType)
         {
             // store the data
-            sharable::AnyData aNewData = allocData(_aUpdater.allocator(),aType,_aValue);
-            node = accessValue(_aValueNode.m_pData,_aUpdater);
+            sharable::AnyData aNewData = allocData(aType,_aValue);
+            node = accessValue(_aValueNode.m_pData);
 
             node->value = aNewData;
             node->info.flags |= Flags::valueAvailable;
@@ -125,9 +120,9 @@
 }
 //-----------------------------------------------------------------------------
 
-void ValueNodeAccess::setToDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode)
+void ValueNodeAccess::setToDefault(memory::UpdateAccessor &, NodeAddressType _aValueNode)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = accessValue(_aValueNode.m_pData);
 
     using namespace sharable;
     OSL_ENSURE(node->hasUsableDefault(), "ERROR: setToDefault() - Value does not have a default");
@@ -138,8 +133,8 @@
         AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->value);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->value);
+        node = accessValue(_aValueNode.m_pData);
 
         node->value.data = 0;
         node->info.flags ^= Flags::valueAvailable;
@@ -149,9 +144,9 @@
 }
 //-----------------------------------------------------------------------------
 
-void ValueNodeAccess::changeDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue)
+void ValueNodeAccess::changeDefault(memory::UpdateAccessor &, NodeAddressType _aValueNode, uno::Any const& _aValue)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = accessValue(_aValueNode.m_pData);
 
     using namespace sharable;
     AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
@@ -161,8 +156,8 @@
     {
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->defaultValue);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->defaultValue);
+        node = accessValue(_aValueNode.m_pData);
 
         node->defaultValue.data = 0;
         node->info.flags ^= Flags::defaultAvailable;
@@ -189,8 +184,8 @@
         if (aType == aNewType)
         {
             // store the data
-            sharable::AnyData aNewData = allocData(_aUpdater.allocator(),aType,_aValue);
-            node = accessValue(_aValueNode.m_pData,_aUpdater);
+            sharable::AnyData aNewData = allocData(aType,_aValue);
+            node = accessValue(_aValueNode.m_pData);
 
             node->defaultValue = aNewData;
             node->info.flags |= Flags::defaultAvailable;
@@ -198,32 +193,7 @@
     }
 }
 
-//-----------------------------------------------------------------------------
-/*
-void ValueNode::clearData(data::Allocator const & _aAlloc)
-{
-    AnyData::TypeCode aType = info.type & Type::mask_valuetype;
-
-    if (info.flags & Flags::valueAvailable)
-    {
-        OSL_ASSERT(aType != Type::value_any);
-        freeData(_aAlloc,aType,this->value);
-        info.flags ^= Flags::valueAvailable;
-        this->value.data = 0;
-    }
-
-    if (info.flags & Flags::defaultAvailable)
-    {
-        OSL_ASSERT(aType != Type::value_any);
-        freeData(_aAlloc,aType,this->defaultValue);
-        info.flags ^= Flags::defaultAvailable;
-        this->defaultValue.data = 0;
-    }
-}
-*/
-//-----------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
+    } // namespace data
 } // namespace configmgr
 
 
Only in configmgr/source/tree: valuenodeaccess.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/treecache/cacheaccess.cxx configmgr/source/treecache/cacheaccess.cxx
--- configmgr-before-refactor/source/treecache/cacheaccess.cxx	2006-12-14 17:32:30.000000000 +0000
+++ configmgr/source/treecache/cacheaccess.cxx	2006-12-14 17:35:45.000000000 +0000
@@ -62,10 +62,8 @@
 
 // -------------------------------------------------------------------------
 
-CacheClientAccess::CacheClientAccess(memory::HeapManager & _rHeapManager,
-                                     ConfigChangeBroadcastHelper *  _pBroadcastHelper)
+CacheClientAccess::CacheClientAccess(ConfigChangeBroadcastHelper *  _pBroadcastHelper)
 : m_aMutex()
-, m_aData(_rHeapManager)
 , m_pBroadcastHelper( _pBroadcastHelper )
 {
 }
@@ -210,9 +208,8 @@
 // -------------------------------------------------------------------------
 // -------------------------------------------------------------------------
 
-CacheLoadingAccess::CacheLoadingAccess(memory::HeapManager & _rHeapManager)
+CacheLoadingAccess::CacheLoadingAccess()
 : m_aMutex()
-, m_aData(_rHeapManager)
 , m_aDeadModules()
 {
 }
Only in configmgr/source/treecache: cacheaccess.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/treecache/cacheaccess.hxx configmgr/source/treecache/cacheaccess.hxx
--- configmgr-before-refactor/source/treecache/cacheaccess.hxx	2005-09-08 05:21:46.000000000 +0100
+++ configmgr/source/treecache/cacheaccess.hxx	2006-12-14 17:35:46.000000000 +0000
@@ -82,8 +82,7 @@
 		ConfigChangeBroadcastHelper* m_pBroadcastHelper;
 	public:
         explicit
-		CacheClientAccess(memory::HeapManager & _rHeapManager,
-                          ConfigChangeBroadcastHelper* _pBroadcastHelper);
+		CacheClientAccess(ConfigChangeBroadcastHelper* _pBroadcastHelper);
 
 		~CacheClientAccess();
 		
@@ -148,7 +147,7 @@
 		DeadModuleList		m_aDeadModules;			/// list of nodes which are registered for throwing away
 	public:
         explicit
-		CacheLoadingAccess(memory::HeapManager & _rHeapManager);
+		CacheLoadingAccess();
 		~CacheLoadingAccess();
 		
         /// gets a data segment reference for the given path if exists
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/treecache/cachecontroller.cxx configmgr/source/treecache/cachecontroller.cxx
--- configmgr-before-refactor/source/treecache/cachecontroller.cxx	2006-09-16 16:24:50.000000000 +0100
+++ configmgr/source/treecache/cachecontroller.cxx	2006-12-14 17:35:46.000000000 +0000
@@ -147,7 +147,7 @@
     CacheRef aResult = m_aCacheList.get(_aOptions);
     if (!aResult.is())
     {
-        CacheRef aNewCache( new Cache(getCacheHeapManager()) );
+        CacheRef aNewCache( new Cache() );
         aResult = m_aCacheList.insert(_aOptions,aNewCache);
     }
     return aResult;
@@ -155,12 +155,6 @@
 
 // -------------------------------------------------------------------------
 
-memory::HeapManager & CacheController::getCacheHeapManager() const
-{
-    return m_aTemplates.getHeapManager();
-}
-// -------------------------------------------------------------------------
-
 // disposing
 // -------------------------------------------------------------------------
 void CacheController::disposeAll(bool _bFlushRemainingUpdates)
@@ -343,12 +337,11 @@
 
 // -------------------------------------------------------------------------
 CacheController::CacheController(BackendRef const & _xBackend, 
-								 memory::HeapManager & _rCacheHeapManager,
 								 const uno::Reference<uno::XComponentContext>& xContext)
 : m_aNotifier()
 , m_xBackend(_xBackend)
 , m_aCacheList()
-, m_aTemplates(_rCacheHeapManager)
+, m_aTemplates()
 , m_pDisposer()
 , m_pCacheWriter()
 , m_bDisposing(false)
@@ -409,16 +402,16 @@
 // -------------------------------------------------------------------------
 
 static
-CacheLocation makeCacheLocation(memory::SegmentAddress const & _aSegment, memory::Heap::Address const & _anAddress)
+CacheLocation makeCacheLocation(memory::SegmentAddress const & _aSegment, memory::Address const & _anAddress)
 {
-    OSL_PRECOND(!_aSegment.isNull() || _anAddress == 0,"ERROR: Got Non-null address for NULL segment ?!");
+    OSL_PRECOND(_aSegment != NULL || _anAddress == 0,"ERROR: Got Non-null address for NULL segment ?!");
 
     CacheLocation aResult;
 
     aResult.segment = _aSegment;
     aResult.address = _anAddress;
 
-    OSL_ASSERT(!_aSegment.isNull() || aResult.isNull());
+    OSL_ASSERT(_aSegment != NULL || aResult.isNull());
 
     return aResult;
 }
Only in configmgr/source/treecache: cachecontroller.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/treecache/cachecontroller.hxx configmgr/source/treecache/cachecontroller.hxx
--- configmgr-before-refactor/source/treecache/cachecontroller.hxx	2005-09-08 05:22:14.000000000 +0100
+++ configmgr/source/treecache/cachecontroller.hxx	2006-12-14 17:35:46.000000000 +0000
@@ -96,7 +96,6 @@
 		*/
         explicit
         CacheController(BackendRef const & _xBackend, 
-						memory::HeapManager & _rCacheHeapManager,
 						const uno::Reference<uno::XComponentContext>& xContext);
 
     // ICachedDataProvider implementation
@@ -309,8 +308,6 @@
 	protected:
 		// ref counted, that's why no public dtor
 		~CacheController();
-
-        memory::HeapManager & getCacheHeapManager() const;
     // implementation 
     private:
         typedef CacheLoadingAccess      Cache;
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/treecache/cachedata.cxx configmgr/source/treecache/cachedata.cxx
--- configmgr-before-refactor/source/treecache/cachedata.cxx	2006-12-14 17:32:30.000000000 +0000
+++ configmgr/source/treecache/cachedata.cxx	2006-12-14 17:35:46.000000000 +0000
@@ -127,8 +127,7 @@
 
 // -----------------------------------------------------------------------------
 	
-	CacheData::CacheData(memory::HeapManager & _rHeapManager)
-    : m_rHeapManager(_rHeapManager)
+	CacheData::CacheData()
 	{
 	}
 // -----------------------------------------------------------------------------
@@ -175,7 +174,7 @@
 
     CacheLineRef CacheData::internalAttachModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
 	{
-        CacheLineRef aNewModule = doCreateAttachedModule(this->internalHeapManager(), _aLocation,_aName);
+        CacheLineRef aNewModule = doCreateAttachedModule(_aLocation,_aName);
 
 		internalAddModule( _aName, aNewModule );
 		
@@ -192,9 +191,9 @@
     }
 // -------------------------------------------------------------------------
 
-    CacheLineRef CacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef CacheData::doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
     {
-        return CacheLine::createAttached( _aName, _rHeapManager, _aLocation ); 
+        return CacheLine::createAttached( _aName, _aLocation ); 
     }
 // -----------------------------------------------------------------------------
 
@@ -429,10 +428,10 @@
 	}
 // -----------------------------------------------------------------------------
 
-    CacheLineRef TemplateCacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef TemplateCacheData::doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
     {
         CacheLineRef aNewModule = 
-            CacheLine::createAttached(_aName, _rHeapManager, _aLocation);
+            CacheLine::createAttached(_aName, _aLocation);
 
         return aNewModule.get();
     }
@@ -440,8 +439,7 @@
 
 	CacheLineRef TemplateCacheData::implNewCacheLine(const ModuleName& _aModule) CFG_UNO_THROW_RTE(  )
 	{
-        CacheLineRef aNewModule = 
-            CacheLine::createNew(_aModule, this->internalHeapManager());
+        CacheLineRef aNewModule = CacheLine::createNew(_aModule);
 
 		internalAddModule( _aModule, aNewModule.get() );
 
@@ -459,10 +457,10 @@
 
 // -----------------------------------------------------------------------------
 
-    CacheLineRef ExtendedCacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef ExtendedCacheData::doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
     {
         ExtendedCacheLineRef aNewModule = 
-            ExtendedCacheLine::createAttached(_aName, _rHeapManager, _aLocation);
+            ExtendedCacheLine::createAttached(_aName, _aLocation);
 
         return CacheLineRef( aNewModule.get() );
     }
@@ -470,8 +468,7 @@
 
 	ExtendedCacheLineRef ExtendedCacheData::implNewCacheLine(const ModuleName& _aModule) CFG_UNO_THROW_RTE(  )
 	{
-        ExtendedCacheLineRef aNewModule = 
-            ExtendedCacheLine::createNew(_aModule, this->internalHeapManager());
+        ExtendedCacheLineRef aNewModule = ExtendedCacheLine::createNew(_aModule);
 
 		internalAddModule( _aModule, aNewModule.get() );
 
Only in configmgr/source/treecache: cachedata.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/treecache/cachedata.hxx configmgr/source/treecache/cachedata.hxx
--- configmgr-before-refactor/source/treecache/cachedata.hxx	2005-09-08 05:22:46.000000000 +0100
+++ configmgr/source/treecache/cachedata.hxx	2006-12-14 17:35:46.000000000 +0000
@@ -75,7 +75,7 @@
         typedef CacheLine::Path     Path;
         typedef CacheLine::Name     ModuleName;
 	public:
-		CacheData(memory::HeapManager & _rHeapManager);
+		CacheData();
 		virtual ~CacheData();
 
 		/// retrieve the module tree name for the given path
@@ -120,9 +120,8 @@
         typedef std::map<ModuleName, ModuleRef> ModuleList;
 		ModuleList& accessModuleList() { return m_aModules; }
 
-        memory::HeapManager & getHeapManager() const { return m_rHeapManager; }
 	protected:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual ModuleRef doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
 
         data::TreeAddress internalGetPartialTree(memory::Accessor const & _aAccessor, Path const & _aPath ) const;
 		data::NodeAddress internalGetNode(memory::Accessor const & _aAccessor, const Path& _rPath) const;
@@ -133,11 +132,8 @@
 		ModuleRef internalGetModule(const ModuleName& _aName) const;
 		ModuleRef internalGetModule(const Path& _aLocation) const;
 
-        memory::HeapManager & internalHeapManager() { return m_rHeapManager; }
 	private:
 		ModuleList m_aModules;
-
-        memory::HeapManager & m_rHeapManager;
 	};
 ////////////////////////////////////////////////////////////////////////////////
 	/** A collection of CacheLines for templates
@@ -146,8 +142,7 @@
     class TemplateCacheData : public CacheData	
 	{
 	public:
-		TemplateCacheData(memory::HeapManager & _rHeapManager)
-        : CacheData(_rHeapManager)
+		TemplateCacheData() : CacheData()
         {
         }
 
@@ -162,7 +157,7 @@
                                        ) CFG_UNO_THROW_RTE();
 
 	private:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual ModuleRef doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
 
 		CacheLineRef implNewCacheLine(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
 	};
@@ -173,8 +168,7 @@
     class ExtendedCacheData : public CacheData	
 	{
 	public:
-		ExtendedCacheData(memory::HeapManager & _rHeapManager)
-        : CacheData(_rHeapManager)
+		ExtendedCacheData() : CacheData()
         {
         }
 
@@ -200,7 +194,7 @@
 		/// remove and return pending changes for the given component
 		std::auto_ptr<SubtreeChange> releasePending(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
 	private:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual ModuleRef doCreateAttachedModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
 
 		ExtendedCacheLineRef implNewCacheLine(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
 
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/treecache/cachefactory.cxx configmgr/source/treecache/cachefactory.cxx
--- configmgr-before-refactor/source/treecache/cachefactory.cxx	2006-09-16 16:25:24.000000000 +0100
+++ configmgr/source/treecache/cachefactory.cxx	2006-12-14 17:35:46.000000000 +0000
@@ -66,12 +66,10 @@
 
         if (_xBackend.is())
         {
-            memory::HeapManager & rHeap = memory::cacheHeap();
-
             rtl::Reference< backend::ICachedDataProvider > xLoader
-                = new backend::CacheController(_xBackend.get(),rHeap, _xContext);
+                = new backend::CacheController(_xBackend.get(), _xContext);
 
-            xCache.set( new TreeManager(xLoader.get(),rHeap) );
+            xCache.set( new TreeManager(xLoader.get()) );
         }
 
         return xCache;
Only in configmgr/source/treecache: cachefactory.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/treecache/cacheline.cxx configmgr/source/treecache/cacheline.cxx
--- configmgr-before-refactor/source/treecache/cacheline.cxx	2006-12-14 17:32:30.000000000 +0000
+++ configmgr/source/treecache/cacheline.cxx	2006-12-14 17:35:46.000000000 +0000
@@ -80,8 +80,8 @@
 
 // -----------------------------------------------------------------------------	
 
-    CacheLine::CacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl)
-    : m_storage(_rHeapImpl  )
+    CacheLine::CacheLine(Name const & _aModuleName)
+    : m_storage()
     , m_base()
     , m_name(_aModuleName)
     , m_nDataRefs(0)
@@ -89,10 +89,10 @@
 	}
 // -----------------------------------------------------------------------------	
 	
-    CacheLine::CacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+    CacheLine::CacheLine(Name const & _aModuleName, 
                             memory::SegmentAddress const & _aSegment)
-    : m_storage(_rHeapImpl,_aSegment.id)
-    , m_base( memory::Pointer(_aSegment.base) )
+    : m_storage()
+    , m_base(_aSegment)
     , m_name(_aModuleName)
     , m_nDataRefs(0)
 	{
@@ -101,12 +101,7 @@
 
     memory::SegmentAddress CacheLine::getDataSegmentAddress() const
     {
-        memory::SegmentAddress aResult;
-
-        aResult.id      = m_storage.getId();
-        aResult.base    = m_base.addressValue();
-
-        return aResult;
+	return m_base.addressValue();
     }
 
 // -----------------------------------------------------------------------------
@@ -120,7 +115,6 @@
 // -----------------------------------------------------------------------------
    
     CacheLineRef CacheLine::createAttached( Name const & _aModuleName, 
-                                            memory::HeapManager & _rHeapImpl, 
                                             memory::SegmentAddress const & _aSegment
                                           ) CFG_UNO_THROW_RTE(  )
 	{
@@ -129,20 +123,19 @@
 			OSL_ENSURE(false, "Cannot make a cache line without a name");
 			return NULL;
 		}
-		if (_aSegment.isNull())
+		if (_aSegment == NULL)
 		{
 			OSL_ENSURE(false, "Cannot attach a cache line to a NULL segment");
 			return NULL;
 		}
 
-		CacheLineRef xResult = new CacheLine(_aModuleName,_rHeapImpl,_aSegment);
+		CacheLineRef xResult = new CacheLine(_aModuleName,_aSegment);
 
 		return xResult;
 	}
 // -----------------------------------------------------------------------------
  
-    CacheLineRef CacheLine::createNew(  Name const & _aModuleName, 
-                                        memory::HeapManager & _rHeapImpl
+    CacheLineRef CacheLine::createNew(  Name const & _aModuleName
                                       ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -151,7 +144,7 @@
 			return NULL;
 		}
 
-		CacheLineRef xResult = new CacheLine(_aModuleName,_rHeapImpl);
+		CacheLineRef xResult = new CacheLine(_aModuleName);
 
 		return xResult;
 	}
@@ -196,7 +189,7 @@
 
 		Path::Iterator it = aConfigName.begin();
 		OSL_ENSURE( it != aConfigName.end(), "Empty Path can't match any module");
-		OSL_ENSURE( aNode.getName() == it->getInternalName(), "Module part in config path does not match selected CacheLine");
+		OSL_ENSURE( aNode.isValid() && aNode.getName() == it->getInternalName(), "Module part in config path does not match selected CacheLine");
 
         // find child of node
         // might be done using a visitor
@@ -254,17 +247,17 @@
 // -----------------------------------------------------------------------------	
 // -----------------------------------------------------------------------------	
 
-    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl)
-    : CacheLine(_aModuleName,_rHeapImpl)
+    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName)
+    : CacheLine(_aModuleName)
     , m_pPending()
 	{
 	}
 
 // -----------------------------------------------------------------------------	
 
-    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName,
                                             memory::SegmentAddress const & _aSegment)
-    : CacheLine(_aModuleName,_rHeapImpl,_aSegment)
+    : CacheLine(_aModuleName,_aSegment)
     , m_pPending()
 	{
 	}
@@ -272,7 +265,6 @@
 // -----------------------------------------------------------------------------
   
     ExtendedCacheLineRef ExtendedCacheLine::createAttached( Name const & _aModuleName, 
-                                                            memory::HeapManager & _rHeapImpl, 
                                                             memory::SegmentAddress const & _aSegment
                                                           ) CFG_UNO_THROW_RTE(  )
 	{
@@ -281,20 +273,19 @@
 			OSL_ENSURE(false, "Cannot make a cache line without a name");
 			return NULL;
 		}
-		if (_aSegment.isNull())
+		if (_aSegment == NULL)
 		{
 			OSL_ENSURE(false, "Cannot attach a cache line to a NULL segment");
 			return NULL;
 		}
 
-		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_rHeapImpl,_aSegment);
+		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_aSegment);
 
 		return xResult;
 	}
 // -----------------------------------------------------------------------------
  
-    ExtendedCacheLineRef ExtendedCacheLine::createNew(  Name const & _aModuleName, 
-                                                        memory::HeapManager & _rHeapImpl
+ExtendedCacheLineRef ExtendedCacheLine::createNew(  Name const & _aModuleName
                                                       ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -303,7 +294,7 @@
 			return NULL;
 		}
 
-		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_rHeapImpl);
+		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName);
 
 		return xResult;
 	}
Only in configmgr/source/treecache: cacheline.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/treecache/cacheline.hxx configmgr/source/treecache/cacheline.hxx
--- configmgr-before-refactor/source/treecache/cacheline.hxx	2006-12-14 17:32:30.000000000 +0000
+++ configmgr/source/treecache/cacheline.hxx	2006-12-14 17:35:46.000000000 +0000
@@ -81,11 +81,11 @@
 
         // create a new CacheLine for the given component name
         static rtl::Reference<CacheLine> 
-            createNew( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+            createNew( Name const & _aModuleName ); 
        
         // create a new CacheLine attached to the given memory location
         static rtl::Reference<CacheLine> 
-            createAttached( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+            createAttached( Name const & _aModuleName, 
                             memory::SegmentAddress const & _aLocation ); 
        
         memory::Segment * getDataSegment();
@@ -123,12 +123,12 @@
     protected:
         // create a new CacheLine attached to the given memory location
         explicit 
-        CacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+        CacheLine( Name const & _aModuleName,
                     memory::SegmentAddress const & _aLocation ); 
        
         // create a new empty CacheLine for the given component name
         explicit 
-        CacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+        CacheLine( Name const & _aModuleName );
 
         data::NodeAccess internalGetNode(memory::Accessor const & _anAccessor, Path const & _rPath) const;
 
@@ -152,11 +152,11 @@
 	public:
         // create a new CacheLine for the given component name
         static rtl::Reference<ExtendedCacheLine> 
-            createNew( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+            createNew( Name const & _aModuleName ); 
        
         // create a new CacheLine attached to the given memory location
         static rtl::Reference<ExtendedCacheLine> 
-            createAttached( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+            createAttached( Name const & _aModuleName,
                             memory::SegmentAddress const & _aLocation ); 
        
     // management of pending changes
@@ -168,11 +168,11 @@
     private:
         // create a new empty CacheLine for the given component name
         explicit 
-        ExtendedCacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl );
+        ExtendedCacheLine( Name const & _aModuleName );
         
         // create a new CacheLine attached to the given memory location
         explicit 
-        ExtendedCacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
+        ExtendedCacheLine( Name const & _aModuleName, 
                             memory::SegmentAddress const & _aLocation ); 
 
     private:
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/treecache/treemanager.cxx configmgr/source/treecache/treemanager.cxx
--- configmgr-before-refactor/source/treecache/treemanager.cxx	2006-12-14 17:32:30.000000000 +0000
+++ configmgr/source/treecache/treemanager.cxx	2006-12-14 17:35:46.000000000 +0000
@@ -241,10 +241,10 @@
 
 
 // -------------------------------------------------------------------------
-TreeManager::TreeManager(BackendCacheRef const & _xBackend, memory::HeapManager & _rCacheHeapManager) 
+TreeManager::TreeManager(BackendCacheRef const & _xBackend) 
 : m_xCacheController(_xBackend)
 , m_aCacheList()
-, m_aTemplates(new CacheData(_rCacheHeapManager))
+, m_aTemplates(new CacheData())
 , m_bEnableAsync(true)
 {
     OSL_PRECOND(_xBackend.is(),"Trying to create a TreeManager without a backend");
@@ -293,12 +293,6 @@
 
 // -------------------------------------------------------------------------
 
-memory::HeapManager & TreeManager::getCacheHeapManager() const
-{
-    return m_aTemplates.get()->getHeapManager();
-}
-// -------------------------------------------------------------------------
-
 TreeManager::CacheRef TreeManager::getCacheAlways(RequestOptions const & _aOptions)
 {
     osl::MutexGuard aGuard( m_aCacheList.mutex() );
@@ -306,7 +300,7 @@
     CacheRef aResult = m_aCacheList.get(_aOptions);
     if (!aResult.is())
     {
-        CacheRef aNewCache( new Cache(getCacheHeapManager(), ConfigChangeBroadcaster::newBroadcastHelper()) );
+        CacheRef aNewCache( new Cache(ConfigChangeBroadcaster::newBroadcastHelper()) );
         aResult = m_aCacheList.insert(_aOptions,aNewCache);
     }
     return aResult;
Only in configmgr/source/treecache: treemanager.cxx.orig
diff -x '*~' -u -r -x 'unxlng*' configmgr-before-refactor/source/treemgr/viewstrategy.cxx configmgr/source/treemgr/viewstrategy.cxx
--- configmgr-before-refactor/source/treemgr/viewstrategy.cxx	2006-09-16 16:33:07.000000000 +0100
+++ configmgr/source/treemgr/viewstrategy.cxx	2006-12-14 17:35:46.000000000 +0000
@@ -193,15 +193,8 @@
 //-----------------------------------------------------------------------------
         data::NodeAddress::DataType * ViewStrategy::implAccessForUpdate(data::NodeAccessRef const & _aNode)
         {
-            if (memory::Segment * pUpdatableSegment = doGetDataSegmentForUpdate())
-            {
-                void * p = memory::UpdateAccessor(pUpdatableSegment).validate(_aNode.rawAddress());
-             
-                OSL_ASSERT(const_cast<const void *>(p) == _aNode.getDataPtr());
-
-                return static_cast<data::NodeAddress::DataType*>(p);
-            }
-
+            if (doGetDataSegmentForUpdate())
+                return (data::NodeAddress::DataType *)_aNode.getDataPtr();
             else
                 return NULL;
         }
Only in configmgr/source/treemgr: viewstrategy.cxx.orig
