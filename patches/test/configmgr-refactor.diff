? configmgr/workben/testapp.cxx
Index: configmgr/source/api2/apinodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apinodeaccess.cxx,v
retrieving revision 1.13
diff -u -p -u -r1.13 apinodeaccess.cxx
--- configmgr/source/api2/apinodeaccess.cxx	16 Sep 2006 14:54:31 -0000	1.13
+++ configmgr/source/api2/apinodeaccess.cxx	5 Jan 2007 22:25:40 -0000
@@ -77,7 +77,7 @@ configuration::TreeRef	NodeAccess::getTr
 }
 //-----------------------------------------------------------------------------
 
-configuration::Tree	NodeAccess::getTree(data::Accessor const & _aAccessor) const
+configuration::Tree	NodeAccess::getTree(memory::Accessor const & _aAccessor) const
 {
 	return configuration::Tree(_aAccessor,getApiTree().getTree());
 }
@@ -216,7 +216,7 @@ SetElement* findSetElement(Factory& rFac
 }
 //-----------------------------------------------------------------------------
 
-configuration::SetElementInfo NodeSetInfoAccess::getElementInfo(data::Accessor const& _aAccessor) const
+configuration::SetElementInfo NodeSetInfoAccess::getElementInfo(memory::Accessor const& _aAccessor) const
 {
 	using configuration::SetElementInfo;
 	using configuration::TemplateHolder;
@@ -242,7 +242,7 @@ NodeReadGuardImpl::~NodeReadGuardImpl() 
 }
 //-----------------------------------------------------------------------------
 
-configuration::Tree NodeReadGuardImpl::getTree(data::Accessor const& _aAccessor) const
+configuration::Tree NodeReadGuardImpl::getTree(memory::Accessor const& _aAccessor) const
 {
     return this->get().getTree(_aAccessor);
 }
Index: configmgr/source/api2/apinodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apinodeaccess.hxx,v
retrieving revision 1.10
diff -u -p -u -r1.10 apinodeaccess.hxx
--- configmgr/source/api2/apinodeaccess.hxx	4 Aug 2006 10:01:32 -0000	1.10
+++ configmgr/source/api2/apinodeaccess.hxx	5 Jan 2007 22:25:40 -0000
@@ -82,7 +82,7 @@ namespace configmgr
 		typedef uno::XInterface UnoInterface;
 		typedef uno::Any UnoAny;
 
-	// API object implementation wrappers
+        // API object implementation wrappers
 		// these objects just provide the pieces needed to navigate and manipulate trees and nodes
 
 		// The common part of all nodes, provides all you need to read and listen
@@ -167,8 +167,9 @@ namespace configmgr
 		/// finds a existing <type>SetElement</type> for a given <type scope='configmgr::configuration'>ElementTree</type>
 		SetElement* findSetElement(Factory& rFactory, configuration::ElementRef const& aElementTree);
 
-	// Guarding and locking implementations
-		/// guards a NodeAccess; provides an object (read) lock, ensures object was not disposed
+        // Guarding and locking implementations
+		/// guards a NodeAccess; provides an object (read) lock,
+        /// ensures object was not disposed
 		class NodeReadGuardImpl : Noncopyable
 		{
             osl::MutexGuard	    m_aLock;
@@ -197,7 +198,8 @@ namespace configmgr
 		};
 		typedef GuardedNode<NodeAccess> GuardedNodeAccess;
 
-		/// wraps a NodeAccess; provides both object and provider (read) locks, ensures object was not disposed
+		/// wraps a NodeAccess; provides both object and provider (read) locks,
+        // ensures object was not disposed
 		template <class Access>
 		class GuardedNodeData
 		{	
Index: configmgr/source/api2/apinodeupdate.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apinodeupdate.cxx,v
retrieving revision 1.11
diff -u -p -u -r1.11 apinodeupdate.cxx
--- configmgr/source/api2/apinodeupdate.cxx	16 Sep 2006 14:54:45 -0000	1.11
+++ configmgr/source/api2/apinodeupdate.cxx	5 Jan 2007 22:25:40 -0000
@@ -75,19 +75,19 @@ NodeGroupAccess& withDefaultData(NodeGro
 }
 //-----------------------------------------------------------------------------
 
-configuration::GroupUpdater NodeGroupAccess::getNodeUpdater(data::Accessor const& _aAccessor)
+configuration::GroupUpdater NodeGroupAccess::getNodeUpdater(memory::Accessor const& _aAccessor)
 {
 	return configuration::GroupUpdater(getTree(_aAccessor),getNodeRef(), getApiTree().getProvider().getTypeConverter());
 }
 //-----------------------------------------------------------------------------
 
-configuration::GroupDefaulter NodeGroupAccess::getNodeDefaulter(data::Accessor const& _aAccessor)
+configuration::GroupDefaulter NodeGroupAccess::getNodeDefaulter(memory::Accessor const& _aAccessor)
 {
 	return configuration::GroupDefaulter(getTree(_aAccessor),getNodeRef(), getApiTree().getDefaultProvider());
 }
 //-----------------------------------------------------------------------------
 
-configuration::SetElementFactory NodeTreeSetAccess::getElementFactory(data::Accessor const& _aAccessor)
+configuration::SetElementFactory NodeTreeSetAccess::getElementFactory(memory::Accessor const& _aAccessor)
 {
 	using namespace configuration;
 	TemplateProvider aProvider = SetElementFactory::findTemplateProvider(getTree(_aAccessor),getNodeRef());
@@ -95,20 +95,20 @@ configuration::SetElementFactory NodeTre
 }
 //-----------------------------------------------------------------------------
 
-configuration::SetDefaulter NodeSetAccess::getNodeDefaulter(data::Accessor const& _aAccessor)
+configuration::SetDefaulter NodeSetAccess::getNodeDefaulter(memory::Accessor const& _aAccessor)
 {
 	return configuration::SetDefaulter(getTree(_aAccessor),getNodeRef(), getApiTree().getDefaultProvider());
 }
 //-----------------------------------------------------------------------------
 
-configuration::TreeSetUpdater NodeTreeSetAccess::getNodeUpdater(data::Accessor const& _aAccessor)
+configuration::TreeSetUpdater NodeTreeSetAccess::getNodeUpdater(memory::Accessor const& _aAccessor)
 {
 	return configuration::TreeSetUpdater(getTree(_aAccessor),getNodeRef(),getElementInfo(_aAccessor));
 }
 //-----------------------------------------------------------------------------
 
 
-configuration::ValueSetUpdater NodeValueSetAccess::getNodeUpdater(data::Accessor const& _aAccessor)
+configuration::ValueSetUpdater NodeValueSetAccess::getNodeUpdater(memory::Accessor const& _aAccessor)
 {
 	return configuration::ValueSetUpdater(getTree(_aAccessor),getNodeRef(),getElementInfo(_aAccessor), getApiTree().getProvider().getTypeConverter());
 }
Index: configmgr/source/api2/apitreeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apitreeaccess.cxx,v
retrieving revision 1.9
diff -u -p -u -r1.9 apitreeaccess.cxx
--- configmgr/source/api2/apitreeaccess.cxx	16 Sep 2006 14:55:24 -0000	1.9
+++ configmgr/source/api2/apitreeaccess.cxx	5 Jan 2007 22:25:40 -0000
@@ -58,7 +58,7 @@ void NodeElement::checkAlive() const
 }
 //-----------------------------------------------------------------------------
 
-configuration::Tree	TreeElement::getTree(data::Accessor const& _aAccessor) const
+configuration::Tree	TreeElement::getTree(memory::Accessor const& _aAccessor) const
 {
     return configuration::Tree(_aAccessor, this->getTreeRef());
 }
Index: configmgr/source/api2/apitreeimplobj.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apitreeimplobj.cxx,v
retrieving revision 1.41
diff -u -p -u -r1.41 apitreeimplobj.cxx
--- configmgr/source/api2/apitreeimplobj.cxx	16 Sep 2006 14:55:43 -0000	1.41
+++ configmgr/source/api2/apitreeimplobj.cxx	5 Jan 2007 22:25:40 -0000
@@ -345,8 +345,8 @@ public:
 
 	// Interfaces
 	virtual void disposing(IConfigBroadcaster* pSource);
-	virtual void nodeChanged(data::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& sPath, IConfigBroadcaster* pSource);
-	virtual void nodeDeleted(data::Accessor const& _aChangedDataAccessor, AbsolutePath const& sPath, IConfigBroadcaster* pSource);
+	virtual void nodeChanged(memory::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& sPath, IConfigBroadcaster* pSource);
+	virtual void nodeDeleted(memory::Accessor const& _aChangedDataAccessor, AbsolutePath const& sPath, IConfigBroadcaster* pSource);
 };
 
 //-------------------------------------------------------------------------
@@ -514,7 +514,7 @@ bool ApiTreeImpl::disposeTree(bool bForc
     if (!isAlive())
         return false;
 
-    data::Accessor aSourceAccessor( getSourceData() );
+    memory::Accessor aSourceAccessor( getSourceData() );
 
     osl::MutexGuard aLocalGuard(getDataLock());
 	if (!bForce)
@@ -540,7 +540,7 @@ bool ApiTreeImpl::disposeTreeNow()
 	CFG_TRACE_INFO("ApiTreeImpl: Disposing Tree Now (unless disposed)");
 	if (isAlive() )
 	{
-        data::Accessor aSourceAccessor( getSourceData() );
+        memory::Accessor aSourceAccessor( getSourceData() );
 
         osl::MutexGuard aLocalGuard(getDataLock());
 
@@ -576,7 +576,7 @@ bool ApiRootTreeImpl::disposeTree()
 	return bDisposed;
 }
 //-------------------------------------------------------------------------
-bool ApiTreeImpl::implDisposeTree(data::Accessor const& _aAccessor)
+bool ApiTreeImpl::implDisposeTree(memory::Accessor const& _aAccessor)
 {
 	OSL_ENSURE(m_pParentTree == 0,"WARNING: Disposing a tree that still has a parent tree set");
 
@@ -626,7 +626,7 @@ void ApiTreeImpl::disposeNode(NodeRef co
 {
 	if (isAlive())
 	{
-        data::Accessor aSourceAccessor( getSourceData() );
+        memory::Accessor aSourceAccessor( getSourceData() );
         if (isAlive())
         {
             osl::MutexGuard aLocalGuard(getDataLock());
@@ -636,7 +636,7 @@ void ApiTreeImpl::disposeNode(NodeRef co
 	}
 }
 //-------------------------------------------------------------------------
-void ApiTreeImpl::implDisposeNode(data::Accessor const & _anAccessor, NodeRef const& aNode, UnoInterface* )
+void ApiTreeImpl::implDisposeNode(memory::Accessor const & _anAccessor, NodeRef const& aNode, UnoInterface* )
 {
 	CFG_TRACE_INFO("ApiTreeImpl: Disposing a single node.");
 	OSL_ENSURE(aNode.isValid(),"INTERNAL ERROR: Disposing NULL node");
@@ -925,7 +925,7 @@ void disposeRemovedNodes(configuration::
 }
 // ---------------------------------------------------------------------------------------------------
 //INodeListener : IConfigListener
-void ApiRootTreeImpl::NodeListener::nodeChanged(data::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& sPath, IConfigBroadcaster* _pSource)
+void ApiRootTreeImpl::NodeListener::nodeChanged(memory::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& sPath, IConfigBroadcaster* _pSource)
 {
 	osl::ClearableMutexGuard aGuard(mutex);
 
@@ -943,7 +943,7 @@ void ApiRootTreeImpl::NodeListener::node
 // ---------------------------------------------------------------------------------------------------
 
 //INodeListener : IConfigListener
-void ApiRootTreeImpl::nodeChanged(data::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& aChangePath, IConfigBroadcaster* /*pSource*/)
+void ApiRootTreeImpl::nodeChanged(memory::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& aChangePath, IConfigBroadcaster* /*pSource*/)
 {
 	using configuration::AnyNodeRef;
 	using configuration::NodeChanges;
@@ -1049,7 +1049,7 @@ void ApiRootTreeImpl::nodeChanged(data::
 }
 // ---------------------------------------------------------------------------------------------------
 
-void ApiRootTreeImpl::NodeListener::nodeDeleted(data::Accessor const& _aChangedDataAccessor, AbsolutePath const& _aPath, IConfigBroadcaster* _pSource)
+void ApiRootTreeImpl::NodeListener::nodeDeleted(memory::Accessor const& _aChangedDataAccessor, AbsolutePath const& _aPath, IConfigBroadcaster* _pSource)
 {
 	osl::ClearableMutexGuard aGuard(mutex);
 
@@ -1065,7 +1065,7 @@ void ApiRootTreeImpl::NodeListener::node
 	}
 }
 // ---------------------------------------------------------------------------------------------------
-void ApiRootTreeImpl::nodeDeleted(data::Accessor const& /*_aChangedDataAccessor*/, AbsolutePath const& _aDeletedPath, IConfigBroadcaster* /*pSource*/)
+void ApiRootTreeImpl::nodeDeleted(memory::Accessor const& /*_aChangedDataAccessor*/, AbsolutePath const& _aDeletedPath, IConfigBroadcaster* /*pSource*/)
 {
     { (void)_aDeletedPath; }
 
Index: configmgr/source/api2/apitreeimplobj.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/apitreeimplobj.hxx,v
retrieving revision 1.25
diff -u -p -u -r1.25 apitreeimplobj.hxx
--- configmgr/source/api2/apitreeimplobj.hxx	8 Sep 2005 03:09:54 -0000	1.25
+++ configmgr/source/api2/apitreeimplobj.hxx	5 Jan 2007 22:25:40 -0000
@@ -183,8 +183,8 @@ namespace configmgr
 			void setParentTree(ApiTreeImpl*	pNewParentTree);
 			void deinit();
 
-			bool implDisposeTree(data::Accessor const& _aAccessor);
-			void implDisposeNode(data::Accessor const & _anAccessor, configuration::NodeRef const& aNode, UnoInterface* pInstance);
+			bool implDisposeTree(memory::Accessor const& _aAccessor);
+			void implDisposeNode(memory::Accessor const & _anAccessor, configuration::NodeRef const& aNode, UnoInterface* pInstance);
 
 			friend class ComponentAdapter;
 			void disposing(com::sun::star::lang::EventObject const& rEvt) throw();
@@ -227,8 +227,8 @@ namespace configmgr
 		// IConfigListener
 			void disposing(IConfigBroadcaster* pSource) ;
 		//INodeListener : IConfigListener
-			void nodeChanged(data::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& aPath, IConfigBroadcaster* pSource);
-			void nodeDeleted(data::Accessor const& _aChangedDataAccessor, AbsolutePath const& aPath, IConfigBroadcaster* pSource);
+			void nodeChanged(memory::Accessor const& _aChangedDataAccessor, Change const& aChange, AbsolutePath const& aPath, IConfigBroadcaster* pSource);
+			void nodeDeleted(memory::Accessor const& _aChangedDataAccessor, AbsolutePath const& aPath, IConfigBroadcaster* pSource);
 
 		private:
 			ApiTreeImpl				    m_aTreeImpl;
Index: configmgr/source/api2/notifierimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/notifierimpl.hxx,v
retrieving revision 1.8
diff -u -p -u -r1.8 notifierimpl.hxx
--- configmgr/source/api2/notifierimpl.hxx	19 Jun 2006 23:16:03 -0000	1.8
+++ configmgr/source/api2/notifierimpl.hxx	5 Jan 2007 22:25:40 -0000
@@ -80,15 +80,15 @@ namespace configmgr
 			};
 			struct SubNodeToIndex 
 			{  
-                typedef data::Accessor const & KeyFinder;
+				typedef memory::Accessor const & KeyFinder;
 				configuration::TreeRef aTree;
 
 				SubNodeToIndex( configuration::TreeRef const& rTree ) : aTree(rTree) {}
 
-                bool findKeysForIndex(KeyFinder _anAccessor, NodeOffset nNode, SubNodeList& aList)
+				bool findKeysForIndex(KeyFinder _anAccessor, NodeOffset nNode, SubNodeList& aList)
 				{
-                    using configuration::getAllChildrenHelper;
-                    using configuration::findNodeFromIndex;
+					using configuration::getAllChildrenHelper;
+					using configuration::findNodeFromIndex;
 					aList.clear();
 					getAllChildrenHelper(_anAccessor,findNodeFromIndex(aTree,nNode), aList);
 					return !aList.empty();
Index: configmgr/source/api2/propsetaccessimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/propsetaccessimpl.cxx,v
retrieving revision 1.21
diff -u -p -u -r1.21 propsetaccessimpl.cxx
--- configmgr/source/api2/propsetaccessimpl.cxx	16 Sep 2006 14:59:10 -0000	1.21
+++ configmgr/source/api2/propsetaccessimpl.cxx	5 Jan 2007 22:25:40 -0000
@@ -299,7 +299,7 @@ public:
 	{
 	}
 
-    static NodePropertySetInfo* create(NodeGroupInfoAccess& _rNode, data::Accessor const& _aDataAccessor, sal_Bool _bReadonly ) throw(RuntimeException);
+    static NodePropertySetInfo* create(NodeGroupInfoAccess& _rNode, memory::Accessor const& _aDataAccessor, sal_Bool _bReadonly ) throw(RuntimeException);
 	Property const* begin() const throw() { return m_aProperties.getConstArray(); }
 	Property const* end()   const throw() { return m_aProperties.getConstArray() + m_aProperties.getLength(); }
 
@@ -313,7 +313,7 @@ public:
 
 //-----------------------------------------------------------------------------------
 //-----------------------------------------------------------------------------------
-NodePropertySetInfo* NodePropertySetInfo::create(NodeGroupInfoAccess& _rNode, data::Accessor const& _aDataAccessor, sal_Bool _bReadonly ) throw(RuntimeException)
+NodePropertySetInfo* NodePropertySetInfo::create(NodeGroupInfoAccess& _rNode, memory::Accessor const& _aDataAccessor, sal_Bool _bReadonly ) throw(RuntimeException)
 {
     osl::MutexGuard aGuard(_rNode.getDataLock());
 
Index: configmgr/source/api2/translatechanges.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/translatechanges.cxx,v
retrieving revision 1.10
diff -u -p -u -r1.10 translatechanges.cxx
--- configmgr/source/api2/translatechanges.cxx	16 Sep 2006 15:00:31 -0000	1.10
+++ configmgr/source/api2/translatechanges.cxx	5 Jan 2007 22:25:41 -0000
@@ -154,11 +154,11 @@ bool resolveChangeLocation(RelativePath&
 
 // ---------------------------------------------------------------------------------------------------
 // change path and base settings to start from the given base
-bool rebaseChange(data::Accessor const& _aAccessor, NodeChangeLocation& aChange, TreeRef const& _aBaseTreeRef)
+bool rebaseChange(memory::Accessor const& _aAccessor, NodeChangeLocation& aChange, TreeRef const& _aBaseTreeRef)
 {
 	return rebaseChange(_aAccessor, aChange,_aBaseTreeRef,_aBaseTreeRef.getRootNode());
 }
-bool rebaseChange(data::Accessor const& _aAccessor, NodeChangeLocation& aChange, TreeRef const& _aBaseTreeRef, NodeRef const& aBaseNode)
+bool rebaseChange(memory::Accessor const& _aAccessor, NodeChangeLocation& aChange, TreeRef const& _aBaseTreeRef, NodeRef const& aBaseNode)
 {
 	OSL_ENSURE(aChange.isValidLocation(_aAccessor), "Trying to rebase change location that wasn't set up properly");
 
Index: configmgr/source/api2/updateimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/api2/updateimpl.cxx,v
retrieving revision 1.13
diff -u -p -u -r1.13 updateimpl.cxx
--- configmgr/source/api2/updateimpl.cxx	16 Sep 2006 15:00:59 -0000	1.13
+++ configmgr/source/api2/updateimpl.cxx	5 Jan 2007 22:25:41 -0000
@@ -715,7 +715,7 @@ Reference< uno::XInterface > implCreateE
 	{
 		GuardedNodeData<NodeSetAccess> lock( rNode ); // no provider lock needed ? => if template lock is separate - OK
 
-        data::Accessor aDataAccess = lock.getDataAccessor();
+        memory::Accessor aDataAccess = lock.getDataAccessor();
 		ElementTree aNewElement( rNode.getElementFactory(aDataAccess).instantiateTemplate(rNode.getElementInfo(aDataAccess).getTemplate()) );
 	
 		Any aAny = configapi::makeElement( rNode.getFactory(), aNewElement );
Index: configmgr/source/data/accessor.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/accessor.cxx,v
retrieving revision 1.7
diff -u -p -u -r1.7 accessor.cxx
--- configmgr/source/data/accessor.cxx	16 Sep 2006 15:09:26 -0000	1.7
+++ configmgr/source/data/accessor.cxx	5 Jan 2007 22:25:41 -0000
@@ -58,20 +58,13 @@ namespace configmgr
         : m_segment(segment)
         , m_refs(1)
         {
-            void const * base = m_segment ? m_segment->acquireReadAccess() : NULL;
-            m_base = static_cast<char const *>(base);
-        }
-    // -------------------------------------------------------------------------
-        Accessor::Impl::Impl(Segment const * segment, void const * base)
-        : m_segment(segment)
-        , m_base(static_cast<char const *>(base))
-        , m_refs(1)
-        {
+	    if (m_segment)
+		m_segment->acquireReadAccess();
         }
     // -------------------------------------------------------------------------
         Accessor::Impl::~Impl()
         {
-            if (m_segment) m_segment->releaseReadAccess(m_base);
+            if (m_segment) m_segment->releaseReadAccess();
         }
     // -------------------------------------------------------------------------
          /// Copies an Accessor
@@ -93,42 +86,28 @@ namespace configmgr
         {
             if (m_impl->is()) 
             {
-                Impl * pNewImpl = new Impl(0,0);
+                Impl * pNewImpl = new Impl(0);
                 releaseImpl();
                 m_impl = pNewImpl;
             }
             OSL_POSTCOND(!this->is(),"Accessor::clear: Could not clear");
         }
 
-    // -------------------------------------------------------------------------
-        void * Accessor::failNull()
-        {
-            OSL_ENSURE(false,"Unexpected NULL Address or Accessor");
-            return NULL;
-        }
-    // -------------------------------------------------------------------------
+        bool Segment::countLocks = false;
+        oslInterlockedCount Segment::numLocks = 0;
 
-    #if OSL_DEBUG_LEVEL > 0
-        void const * Accessor::resolve(AddressType _p) const 
-        { 
-            OSL_ENSURE( !_p.is() || segment_()->isValidAddress(_p.value()), "Address does not belong to this segment");
-            return _p.is() ? base_() + _p.value() : NULL; 
+        void Segment::acquireWriteAccess()
+        {
+            m_mutex.acquire();
+            if (countLocks)
+                osl_incrementInterlockedCount(&numLocks);
         }
 
-        Pointer  Accessor::reduce(void const * _p) const
+        void Segment::releaseWriteAccess()
         {
-            if (_p)
-            {
-                Pointer::RawAddress addr = static_cast<char const *>(_p) - base_();
-                OSL_ENSURE( segment_()->isValidAddress(addr), "Pointer does not belong to this segment");
-                return Pointer(addr); 
-            }
-            else
-                return Pointer();
+            m_mutex.release();
         }
-  #endif // OSL_DEBUG_LEVEL
 
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
Index: configmgr/source/data/anydata.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/anydata.cxx,v
retrieving revision 1.4.12.1
diff -u -p -u -r1.4.12.1 anydata.cxx
--- configmgr/source/data/anydata.cxx	3 Nov 2006 11:34:29 -0000	1.4.12.1
+++ configmgr/source/data/anydata.cxx	5 Jan 2007 22:25:41 -0000
@@ -61,7 +61,6 @@ namespace configmgr
         namespace Type = data::Type;
         namespace uno = ::com::sun::star::uno;
         typedef AnyData::TypeCode TypeCode;
-        using memory::Pointer;
 //-----------------------------------------------------------------------------	
 
 TypeCode getTypeCode(uno::Type const & _aType)
@@ -200,7 +199,7 @@ uno::Type getUnoType( TypeCode _aType)
 //-----------------------------------------------------------------------------	
 
 static
-AnyData allocSimpleData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, uno::Any const & _aAny)
+AnyData allocSimpleData(TypeCode _aSimpleType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -234,9 +233,7 @@ AnyData allocSimpleData(memory::Allocato
             sal_Int64 nValue;
             OSL_VERIFY(_aAny >>= nValue);
 
-            Address aStorage = _anAllocator.allocate( sizeof nValue );
-            *static_cast<sal_Int64*>( _anAllocator.access(aStorage) ) = nValue;
-            aResult.longValue = aStorage;
+            aResult.longValue = new sal_Int64( nValue );
         }
         break;
 
@@ -245,9 +242,7 @@ AnyData allocSimpleData(memory::Allocato
             double dValue;
             OSL_VERIFY(_aAny >>= dValue);
 
-            Address aStorage = _anAllocator.allocate( sizeof dValue );
-            *static_cast<double*>( _anAllocator.access(aStorage) ) = dValue;
-            aResult.doubleValue = aStorage;
+            aResult.doubleValue = new double( dValue );
         }
         break;
 
@@ -255,7 +250,7 @@ AnyData allocSimpleData(memory::Allocato
         {
             uno::Sequence<sal_Int8> aValue;
             OSL_VERIFY(_aAny >>= aValue);
-            aResult.binaryValue = allocBinary(_anAllocator,aValue);
+            aResult.binaryValue = allocBinary(aValue);
         }
         break;
 
@@ -290,7 +285,7 @@ sal_Sequence const * extractSequenceData
 //-----------------------------------------------------------------------------	
 
 static
-AnyData allocSequenceData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, uno::Any const & _aAny)
+AnyData allocSequenceData(TypeCode _aSimpleType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -302,7 +297,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<rtl::OUString> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -310,7 +305,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Bool> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -318,7 +313,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Int16> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -326,7 +321,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Int32> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -334,7 +329,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Int64> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -342,7 +337,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<double> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -350,7 +345,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<uno::Sequence<sal_Int8> > aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -366,28 +361,20 @@ AnyData allocSequenceData(memory::Alloca
 }
 //-----------------------------------------------------------------------------	
 
-AnyData allocData(memory::Allocator const& _anAllocator, TypeCode _aType, uno::Any const & _aAny)
+AnyData allocData(TypeCode _aType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
     OSL_ENSURE( _aType == getTypeCode(_aAny.getValueType()), "Type code does not match value" );
 
     if (_aType & Type::flag_sequence)
-        return allocSequenceData(_anAllocator,TypeCode( _aType & Type::mask_basetype),_aAny);
-
+        return allocSequenceData(TypeCode( _aType & Type::mask_basetype),_aAny);
     else
-        return allocSimpleData(_anAllocator,_aType,_aAny);
-}
-//-----------------------------------------------------------------------------	
-/*
-AnyData copyData(memory::Allocator const& _anAllocator, TypeCode _aType, AnyData _aData)
-{
-    OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
+        return allocSimpleData(_aType,_aAny);
 }
-*/
 //-----------------------------------------------------------------------------	
 
 static
-void freeSimpleData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, AnyData const & _aData)
+void freeSimpleData(TypeCode _aSimpleType, AnyData const & _aData)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -405,15 +392,15 @@ void freeSimpleData(memory::Allocator co
 
         // free memory for oversized values
     case Type::value_long:
-        _anAllocator.deallocate(_aData.longValue);
+        delete _aData.longValue;
         break;
 
     case Type::value_double:
-        _anAllocator.deallocate(_aData.doubleValue);
+        delete _aData.doubleValue;
         break;
 
     case Type::value_binary:
-        freeBinary(_anAllocator, _aData.binaryValue);
+        freeBinary(_aData.binaryValue);
         break;
 
     case Type::value_any: 
@@ -427,20 +414,20 @@ void freeSimpleData(memory::Allocator co
 }
 //-----------------------------------------------------------------------------	
 
-void    freeData(memory::Allocator const& _anAllocator, TypeCode _aType, AnyData _aData)
+void    freeData(TypeCode _aType, AnyData _aData)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
 
     if (_aType & Type::flag_sequence)
-        freeSequence(_anAllocator,TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
+        freeSequence(TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
 
     else
-        freeSimpleData(_anAllocator,_aType,_aData);
+        freeSimpleData(_aType,_aData);
 }
 //-----------------------------------------------------------------------------	
 
 static
-uno::Any readSimpleData(memory::Accessor const& _anAccessor, TypeCode _aSimpleType, AnyData const & _aData)
+uno::Any readSimpleData(TypeCode _aSimpleType, AnyData const & _aData)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -462,22 +449,14 @@ uno::Any readSimpleData(memory::Accessor
         return uno::makeAny( _aData.intValue );
 
     case Type::value_long:
-        {
-            void const * pStorage = _anAccessor.validate( Pointer(_aData.longValue) );
-            sal_Int64 const * pValue = static_cast<sal_Int64 const *>(pStorage);
-            return uno::makeAny( *pValue );
-        }
+	return uno::makeAny( *_aData.longValue );
 
     case Type::value_double:
-        {
-            void const * pStorage = _anAccessor.validate( Pointer(_aData.doubleValue) );
-            double const * pValue = static_cast<double const *>(pStorage);
-            return uno::makeAny( *pValue );
-        }
+	return uno::makeAny( *_aData.doubleValue );
 
     case Type::value_binary:
         {
-            uno::Sequence<sal_Int8> aValue = readBinary( _anAccessor, _aData.binaryValue );
+            uno::Sequence<sal_Int8> aValue = readBinary( _aData.binaryValue );
             return uno::makeAny( aValue );
         }
 
@@ -491,15 +470,15 @@ uno::Any readSimpleData(memory::Accessor
 }
 //-----------------------------------------------------------------------------	
 
-uno::Any readData(memory::Accessor const& _anAccessor, TypeCode _aType, AnyData _aData)
+uno::Any readData(TypeCode _aType, AnyData _aData)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
 
     if (_aType & Type::flag_sequence)
-        return readAnySequence(_anAccessor,TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
+        return readAnySequence(TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
 
     else
-        return readSimpleData(_anAccessor,_aType,_aData);
+        return readSimpleData(_aType,_aData);
 }
 
 //-----------------------------------------------------------------------------	
Index: configmgr/source/data/heap.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/heap.cxx,v
retrieving revision 1.4
diff -u -p -u -r1.4 heap.cxx
--- configmgr/source/data/heap.cxx	16 Sep 2006 15:09:54 -0000	1.4
+++ configmgr/source/data/heap.cxx	5 Jan 2007 22:25:41 -0000
@@ -42,61 +42,5 @@
 #include <osl/diagnose.h>
 #endif
 
-// -----------------------------------------------------------------------------	
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        const Heap::Size c_nDefaultSize = 4096;
-    // -------------------------------------------------------------------------
-        Heap::Heap(HeapManager& _impl)
-        : m_impl(_impl)
-        , m_heap(_impl.createHeap(c_nDefaultSize))
-        , m_size(c_nDefaultSize)
-        {
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Heap(HeapManager& _impl, Size _nInitialSize)
-        : m_impl(_impl)
-        , m_heap(_impl.createHeap(_nInitialSize))
-        , m_size(_nInitialSize)
-        {
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Heap(HeapManager& _impl, HeapId const & _anId)
-        : m_impl(_impl)
-        , m_size(0)
-        {
-            m_heap = _impl.attachHeap(_anId,m_size);
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::~Heap()
-        {
-            m_impl.destroyHeap(m_heap);
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Size Heap::grow(Size _nReqSize) // returns the (possibly new) base
-        {
-            Size nNewSize = m_impl.growHeap(m_heap, _nReqSize);
-
-            if (nNewSize)
-            {
-                OSL_ENSURE(nNewSize >= _nReqSize, "Error: Heapmanager returns invalid size from grow method");
-                m_size = nNewSize;
-            }
-
-            return nNewSize;
-        }
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
 
 
Index: configmgr/source/data/segmentheap.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/segmentheap.cxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 segmentheap.cxx
--- configmgr/source/data/segmentheap.cxx	16 Sep 2006 15:10:09 -0000	1.3
+++ configmgr/source/data/segmentheap.cxx	5 Jan 2007 22:25:41 -0000
@@ -36,73 +36,3 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_configmgr.hxx"
 
-#include "segmentheap.hxx"
-
-#ifndef _OSL_DIAGNOSE_H_
-#include <osl/diagnose.h>
-#endif
-
-// -----------------------------------------------------------------------------	
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        const Heap::Size c_nMaxHeapSize = 0x40000000;
-        const Heap::Size c_nGrowFactor  = 2;
-
-    // -------------------------------------------------------------------------
-
-        SegmentHeap::~SegmentHeap()
-        {
-            m_heap.destroyLock(m_lock);
-        }
-    // -------------------------------------------------------------------------
-
-        void SegmentHeap::init()
-        {
-            m_lock = m_heap.createLock();
-            m_base = m_heap.base();
-
-            OSL_ENSURE(m_lock,"Could not create heap lock");
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Address SegmentHeap::allocateMore(Size _sz)
-        {
-            Size nCurSize = m_heap.size();
-
-            OSL_ENSURE(_sz <= c_nMaxHeapSize,"Cannot allocate: Allocation request too large");
-            if (_sz > c_nMaxHeapSize) return 0;
-
-            Size nCurSizeLimit = (c_nMaxHeapSize-_sz)/c_nGrowFactor;
-            OSL_ENSURE(nCurSize < nCurSizeLimit,"Allocation will reach heap limit");
-
-            Size nNewSize = (nCurSize < nCurSizeLimit ) 
-                                ? nCurSize * c_nGrowFactor + _sz 
-                                : c_nMaxHeapSize;
-
-            if (m_heap.grow(nNewSize))
-            {
-                m_base = m_heap.base();
-
-                Address aResult = m_heap.allocate(_sz);
-
-                OSL_ENSURE(aResult,"Cannot allocate even after growing heap");
-
-                return aResult;
-            }
-            else
-            {
-                OSL_ENSURE(false,"Cannot allocate: Heap could not be grown");
-                return 0;
-            }
-        }
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-
Index: configmgr/source/data/sequence.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/sequence.cxx,v
retrieving revision 1.6.12.1
diff -u -p -u -r1.6.12.1 sequence.cxx
--- configmgr/source/data/sequence.cxx	3 Nov 2006 11:34:42 -0000	1.6.12.1
+++ configmgr/source/data/sequence.cxx	5 Jan 2007 22:25:41 -0000
@@ -64,9 +64,7 @@ namespace configmgr
         namespace Type = data::Type;
         namespace uno = ::com::sun::star::uno;
         typedef AnyData::TypeCode TypeCode;
-        using memory::Allocator;
         using memory::Accessor;
-        using memory::Pointer;
 //-----------------------------------------------------------------------------	
 static 
 sal_uInt32 implGetElementSize(TypeCode _aElementType)
@@ -108,32 +106,20 @@ sal_uInt32 implGetHeaderSize(sal_uInt32 
 //-----------------------------------------------------------------------------	
 static 
 inline
-sal_Int32& implGetSize(Allocator const& _anAllocator, Sequence _aSeq)
+sal_Int32& implGetSize(Sequence _aSeq)
 {
-    OSL_ASSERT(_aSeq != 0);
-    void * pBase = _anAllocator.access(_aSeq);
-    return * static_cast<sal_Int32 *>(pBase);
+    return * (sal_Int32 *) _aSeq;
 }
 
 //-----------------------------------------------------------------------------	
 static 
-inline
-sal_Int32 implGetSize(Accessor const& _anAccessor, Sequence _aSeq)
-{
-    OSL_ASSERT(_aSeq != 0);
-    void const * pBase = _anAccessor.access( Pointer(_aSeq) );
-    return * static_cast<sal_Int32 const *>(pBase);
-}
-
-//-----------------------------------------------------------------------------	
-static 
-Sequence implSeqAlloc(Allocator const& _anAllocator, sal_Int32 _nElements, sal_uInt32 _nElemSize)
+Sequence implSeqAlloc(sal_Int32 _nElements, sal_uInt32 _nElemSize)
 {
     sal_uInt32 nTotalSize = implGetHeaderSize(_nElemSize) + _nElements * _nElemSize;
 
-    Sequence aResult = _anAllocator.allocate(nTotalSize);
+    Sequence aResult = (Sequence) (new sal_uInt8[nTotalSize]);
 
-    implGetSize(_anAllocator,aResult) = _nElements;
+    implGetSize(aResult) = _nElements;
 
     return aResult;
 }
@@ -141,7 +127,7 @@ Sequence implSeqAlloc(Allocator const& _
 //-----------------------------------------------------------------------------	
 
 static
-void allocSeqData(Allocator const& _anAllocator, Address _aDestAddr, 
+void allocSeqData(sal_uInt8 *_pDestAddr, 
                  TypeCode _aElementType, 
                  sal_Int32 _nElements, sal_uInt32 _nElementSize, 
                  void const * _pSourceData)
@@ -155,7 +141,7 @@ void allocSeqData(Allocator const& _anAl
     case Type::value_int:
     case Type::value_long:
     case Type::value_double:
-        ::memcpy(_anAllocator.access(_aDestAddr),_pSourceData,_nElements * _nElementSize);
+        ::memcpy(_pDestAddr,_pSourceData,_nElements * _nElementSize);
         break;
 
     case Type::value_string: 
@@ -168,11 +154,11 @@ void allocSeqData(Allocator const& _anAl
             {
                 String aElement = allocString(*pSource);
 
-                String * pDest = static_cast<String*>( _anAllocator.access(_aDestAddr) );
+                String * pDest = reinterpret_cast<String*>(_pDestAddr);
                 *pDest = aElement;
                 
                 ++pSource;
-                _aDestAddr += sizeof *pDest;
+                _pDestAddr += sizeof *pDest;
             }
         }
         break;
@@ -186,13 +172,13 @@ void allocSeqData(Allocator const& _anAl
 
             while (--_nElements >= 0)
             {
-                Vector aElement = allocBinary(_anAllocator,*pSource);
+                Vector aElement = allocBinary(*pSource);
 
-                Vector * pDest = static_cast<Vector*>( _anAllocator.access(_aDestAddr) );
+                Vector * pDest = (Vector *) _pDestAddr;
                 *pDest = aElement;
                 
                 ++pSource;
-                _aDestAddr += sizeof *pDest;
+                _pDestAddr += sizeof *pDest;
             }
         }
         break;
@@ -205,7 +191,7 @@ void allocSeqData(Allocator const& _anAl
 }
 
 //-----------------------------------------------------------------------------	
-Sequence allocSequence(Allocator const& _anAllocator, TypeCode _aElementType, ::sal_Sequence const * _pSeqData)
+Sequence allocSequence(TypeCode _aElementType, ::sal_Sequence const * _pSeqData)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -218,10 +204,10 @@ Sequence allocSequence(Allocator const& 
     sal_uInt32 const nElementSize = implGetElementSize(_aElementType);
     sal_Int32  const nElements = _pSeqData->nElements;
 
-    Sequence aResult = implSeqAlloc(_anAllocator,nElements,nElementSize);
+    Sequence aResult = implSeqAlloc(nElements,nElementSize);
 
     if (aResult)
-        allocSeqData( _anAllocator, aResult + implGetHeaderSize(nElementSize), 
+        allocSeqData( aResult + implGetHeaderSize(nElementSize), 
                         _aElementType, nElements, nElementSize,
                         _pSeqData->elements);
 
@@ -229,31 +215,25 @@ Sequence allocSequence(Allocator const& 
 }
 
 //-----------------------------------------------------------------------------	
-Sequence allocBinary(Allocator const& _anAllocator, uno::Sequence<sal_Int8> const & _aBinaryValue)
+Sequence allocBinary(uno::Sequence<sal_Int8> const & _aBinaryValue)
 {
     sal_uInt32 const nElementSize = 1;
     sal_Int32  const nLength = _aBinaryValue.getLength();
 
-    Sequence aResult = implSeqAlloc(_anAllocator,nLength,nElementSize);
+    Sequence aResult = implSeqAlloc(nLength,nElementSize);
 
     if (aResult)
     {
-        Address aElementBaseAddr = aResult + implGetHeaderSize(nElementSize);
-        ::memcpy(_anAllocator.access(aElementBaseAddr), _aBinaryValue.getConstArray(), nLength);
+        sal_uInt8 *pElementBaseAddr = aResult + implGetHeaderSize(nElementSize);
+        ::memcpy(pElementBaseAddr, _aBinaryValue.getConstArray(), nLength);
     }
 
     return aResult;
 }
 
 //-----------------------------------------------------------------------------	
-// Sequence copySequence(Allocator const& _anAllocator, TypeCode _aElementType, Sequence _aSeq)
-
-//-----------------------------------------------------------------------------	
-// Sequence copyBinary(Allocator const& _anAllocator, Sequence _aSeq)
-
-//-----------------------------------------------------------------------------	
 static
-void freeSeqData(Allocator const& _anAllocator, Address _aDataAddr, 
+void freeSeqData(sal_uInt8 *_pDataAddr, 
                  TypeCode _aElementType, sal_Int32 _nElements)
 {
     OSL_ASSERT(_aElementType == (_aElementType & Type::mask_basetype));
@@ -270,7 +250,7 @@ void freeSeqData(Allocator const& _anAll
 
     case Type::value_string: 
         {
-            String * pElements = static_cast<String*>( _anAllocator.access(_aDataAddr) );
+            String * pElements = reinterpret_cast<String*>( _pDataAddr );
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
@@ -281,11 +261,11 @@ void freeSeqData(Allocator const& _anAll
 
     case Type::value_binary:
         {
-            Vector * pElements = static_cast<Vector*>( _anAllocator.access(_aDataAddr) );
+            Vector * pElements = reinterpret_cast<Vector*>( _pDataAddr );
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
-                freeBinary(_anAllocator,pElements[i]);
+                freeBinary(pElements[i]);
             }
         }
         break;
@@ -298,7 +278,7 @@ void freeSeqData(Allocator const& _anAll
 }
 
 //-----------------------------------------------------------------------------	
-void freeSequence(Allocator const& _anAllocator, TypeCode _aElementType, Sequence _aSeq)
+void freeSequence(TypeCode _aElementType, Sequence _aSeq)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -310,18 +290,18 @@ void freeSequence(Allocator const& _anAl
 
     sal_uInt32 nHeaderSize = implGetHeaderSize( implGetElementSize( _aElementType ) );
 
-    freeSeqData(_anAllocator,_aSeq + nHeaderSize, _aElementType, implGetSize(_anAllocator,_aSeq));
+    freeSeqData(_aSeq + nHeaderSize, _aElementType, implGetSize(_aSeq));
 
-    _anAllocator.deallocate(_aSeq);
+    delete[] (sal_uInt8 *)_aSeq;
 }
 
 //-----------------------------------------------------------------------------	
-void freeBinary(memory::Allocator const& _anAllocator, Sequence _aSeq)
+void freeBinary(Sequence _aSeq)
 {
     OSL_ENSURE(_aSeq, "ERROR: Trying to free a NULL sequence");
     if (_aSeq == 0) return;
 
-    _anAllocator.deallocate(_aSeq);
+    delete[] (sal_uInt8 *)_aSeq;
 }
 
 //-----------------------------------------------------------------------------	
@@ -342,11 +322,11 @@ sal_Sequence * implCreateSequence(void c
 
 //-----------------------------------------------------------------------------	
 static
-sal_Sequence * readSeqData(Accessor const & _anAccessor, Address _aDataAddr, TypeCode _aElementType, sal_Int32 _nElements)
+sal_Sequence * readSeqData(sal_uInt8 *_pDataAddr, TypeCode _aElementType, sal_Int32 _nElements)
 {
     OSL_ASSERT(_aElementType == (_aElementType & Type::mask_basetype));
 
-    void const * pElementData = _anAccessor.validate( Pointer(_aDataAddr) );
+    void const * pElementData = (void const *)_pDataAddr;
     switch (_aElementType)
     {
     case Type::value_boolean:
@@ -384,7 +364,7 @@ sal_Sequence * readSeqData(Accessor cons
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
-                pResult[i] = readBinary(_anAccessor,pElements[i]);
+                pResult[i] = readBinary(pElements[i]);
             }
 
             sal_Sequence * pRet = aResult.get();
@@ -401,7 +381,7 @@ sal_Sequence * readSeqData(Accessor cons
 
 //-----------------------------------------------------------------------------	
 
-::sal_Sequence * readSequence(Accessor const& _anAccessor, TypeCode _aElementType, Sequence _aSeq)
+::sal_Sequence * readSequence(TypeCode _aElementType, Sequence _aSeq)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -413,13 +393,14 @@ sal_Sequence * readSeqData(Accessor cons
 
     sal_uInt32 nHeaderSize = implGetHeaderSize( implGetElementSize( _aElementType ) );
 
-    return readSeqData(_anAccessor,_aSeq + nHeaderSize, _aElementType, implGetSize(_anAccessor,_aSeq));
+    // URG - accidentally removed an accessor instead of an allocator ... :-)
+    return readSeqData(_aSeq + nHeaderSize, _aElementType, implGetSize(_aSeq));
 }
 
 //-----------------------------------------------------------------------------	
-uno::Any readAnySequence(Accessor const& _anAccessor, TypeCode _aElementType, Sequence _aSeq)
+uno::Any readAnySequence(TypeCode _aElementType, Sequence _aSeq)
 {
-    sal_Sequence * pRawSequence = readSequence(_anAccessor, _aElementType, _aSeq);
+    sal_Sequence * pRawSequence = readSequence(_aElementType, _aSeq);
 
     uno::Any aResult;
 
@@ -487,20 +468,13 @@ uno::Any readAnySequence(Accessor const&
 }
 
 //-----------------------------------------------------------------------------	
-uno::Sequence<sal_Int8> readBinary(Accessor const& _anAccessor, Sequence _aSeq)
+uno::Sequence<sal_Int8> readBinary(Sequence _aSeq)
 {
     OSL_ENSURE(_aSeq, "ERROR: Trying to read from a NULL sequence");
     if (_aSeq == 0) return uno::Sequence<sal_Int8>();
 
-    sal_Int32 const nElements = implGetSize(_anAccessor,_aSeq);
-
-    void const * const pElementData = _anAccessor.validate( Pointer(_aSeq + implGetHeaderSize(1)) );
-
-    sal_Int8 const * const pBinaryData = static_cast<sal_Int8 const *>(pElementData);
-
-    uno::Sequence< sal_Int8 > aSequence(pBinaryData,nElements); 
-
-    return aSequence;
+    return uno::Sequence< sal_Int8 >((const sal_Int8 *)(_aSeq + implGetHeaderSize(1)),
+				     implGetSize(_aSeq));
 }
 
 //-----------------------------------------------------------------------------	
Index: configmgr/source/data/simpleheap.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/simpleheap.cxx,v
retrieving revision 1.8
diff -u -p -u -r1.8 simpleheap.cxx
--- configmgr/source/data/simpleheap.cxx	16 Sep 2006 15:10:36 -0000	1.8
+++ configmgr/source/data/simpleheap.cxx	5 Jan 2007 22:25:41 -0000
@@ -1,3 +1,4 @@
+#include <stdio.h>
 /*************************************************************************
  *
  *  OpenOffice.org - a multi-platform office productivity suite
@@ -57,418 +58,3 @@
 #include <map>
 #define INCLUDED_MAP
 #endif
-
-#ifdef _MSC_VER
-#pragma warning( disable : 4355 )
-#endif
-
-// -----------------------------------------------------------------------------	
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        extern HeapManager & localHeap();
-    // -------------------------------------------------------------------------
-        struct OrderByHeapId
-        {
-            typedef HeapManager::HeapIdParam HeapIdParam;
-
-            bool operator()(HeapIdParam lhs, HeapIdParam rhs) const 
-            {
-                return lhs.compareTo(rhs) < 0;
-            }
-        };
-    // -------------------------------------------------------------------------
-        struct HeapSet
-        {
-            typedef HeapManager::HeapIdParam    HeapIdParam;
-            typedef HeapManager::HeapId         HeapId;
-            typedef HeapManager::Handle         Heap;
-
-            typedef std::map<HeapId,Heap,OrderByHeapId> Map;
-
-            HeapSet(HeapManager & _mgr) : m_mgr(_mgr) {}
-
-            Heap add(Heap _aHeap) { return m_heaps[m_mgr.id(_aHeap)] = _aHeap; }
-            void remove(Heap _aHeap) { m_heaps.erase(m_mgr.id(_aHeap)); }
-
-            Heap heap(HeapIdParam _anId) const 
-            {
-                Map::const_iterator it = m_heaps.find(_anId);
-                return it != m_heaps.end() ? it->second : NULL;
-            }
-        private:
-            HeapManager &   m_mgr;
-            Map             m_heaps;
-        };
-    // -------------------------------------------------------------------------
-        class SimpleHeapManagerBase : public HeapManager
-        {
-            static void * ptr(Address _address) { return reinterpret_cast<void*>(_address); }
-            static Address address(void * _ptr) { return reinterpret_cast<Address>(_ptr); }
-            // if this static assertion breaks, a less simple heap manager is needed (-> 64 bit ports)
-            static char address_can_hold_any_pointer[sizeof(Address) - sizeof(void*) + 1];
-
-            virtual void *  base(Handle _aHeap);
-        protected: 
-            SimpleHeapManagerBase() : m_heaps( *(HeapManager*)this) {}
-            virtual ~SimpleHeapManagerBase() {}
-
-            Handle  addHeap(Handle _aHeap)      { return m_heaps.add(_aHeap);   }
-            void    removeHeap(Handle _aHeap)   { m_heaps.remove(_aHeap);       }
-
-            Handle  findHeap( HeapId _anId )    
-            { 
-                osl::MutexGuard aGuard(m_mutex); 
-                return m_heaps.heap(_anId);  
-            }
-
-            osl::Mutex & getHeapListMutex()     { return m_mutex; }
-        protected:      
-            Address allocateMemory(Size _sz);
-            Address reallocateMemory(Address _p, Size _sz);
-            void    deallocateMemory(Address _p);
-
-        protected:      
-            virtual Lock *  createHeapLock(Handle _aHeap);
-            virtual void    destroyHeapLock(Handle _aHeap, Lock * _pLock);
-
-        private:
-            osl::Mutex  m_mutex;
-            HeapSet     m_heaps;
-        };
-    // -------------------------------------------------------------------------
-        class SimpleCheckingHeapManager : public SimpleHeapManagerBase
-        {
-            struct HeapData
-            {
-                HeapId      id;
-                
-                oslInterlockedCount  refs;
-
-                Size        requested;
-                Size        allocated;
-
-                Size available() const { return requested-allocated; }
-
-                typedef std::map<Address, Size> Map;
-                Map allocations;
-            };
-
-            static HeapData * heap(Handle _handle) { return reinterpret_cast<HeapData*>(_handle); }
-            static Handle handle(HeapData * _data) { return reinterpret_cast<Handle>(_data); }
-
-            static void makeNewId(HeapData * _data);
-       public:      
-            virtual Handle createHeap(Size _sInitialSize);
-            virtual Handle attachHeap(HeapIdParam  _anId, Size & _rInitialSize);
-            virtual Size   growHeap(Handle _aHeap, Size _sNewSize);
-            virtual void   destroyHeap(Handle _aHeap);
-
-            virtual HeapId  id(Handle _aHeap);
-
-            virtual Address allocate(Handle _aHeap, Size _sNewSize);
-            virtual Address reallocate(Handle _aHeap, Address _aOldAddress, Size _sNewSize);
-            virtual void    deallocate(Handle _aHeap, Address _aAddress);
-            virtual bool    didAllocate(Handle _aHeap, Address _aAddress);
-        };
-    // -------------------------------------------------------------------------
-        class SimpleHeapLock : public DataLock
-        {
-            osl::Mutex m_mutex;
-        public:   
-            virtual void acquireReadAccess() { m_mutex.acquire(); }
-            virtual void releaseReadAccess() { m_mutex.release(); }
-
-            virtual void acquireWriteAccess() { m_mutex.acquire(); }     
-            virtual void releaseWriteAccess() { m_mutex.release(); }
-        };
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-        HeapManager & cacheHeap()
-        {
-            static SimpleCheckingHeapManager aInstance;
-            return aInstance;
-        }
-    // -------------------------------------------------------------------------
-        HeapManager & localHeap()
-        {
-            static SimpleCheckingHeapManager aInstance;
-            return aInstance;
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleHeapManagerBase::allocateMemory(Size _sz)
-        {
-            void * p = ::rtl_allocateMemory(_sz);
-
-            OSL_ENSURE(p,"Could not allocate: std::malloc failed");
-
-            return address(p);
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleHeapManagerBase::reallocateMemory(Address _p, Size _sz)
-        {
-            void * pOld = ptr(_p);
-
-            void * pNew = ::rtl_reallocateMemory(pOld,_sz);
-
-            OSL_ENSURE(pNew,"Could not reallocate: std::realloc failed");
-
-            return address(pNew);
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleHeapManagerBase::deallocateMemory(Address _p)
-        {
-            void * p = ptr(_p);
-
-            ::rtl_freeMemory(p); 
-        }
-    // -------------------------------------------------------------------------
-
-        void *  SimpleHeapManagerBase::base(Handle /*_aHeap*/)
-        {
-            return NULL;
-        }
-    // -------------------------------------------------------------------------
-
-        DataLock *  SimpleHeapManagerBase::createHeapLock(Handle )
-        {
-            return new SimpleHeapLock();
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleHeapManagerBase::destroyHeapLock(Handle , DataLock * _pLock)
-        {
-            if (SimpleHeapLock* pMyLock = /*dynamic_*/ static_cast<SimpleHeapLock*>(_pLock))
-            {
-                delete pMyLock;
-            }
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-
-        void SimpleCheckingHeapManager::makeNewId(HeapData * _data)
-        {
-            OSL_PRECOND( _data, "Internal Error: NULL data");
-
-            sal_Int64 nData = reinterpret_cast<sal_Int64>(_data);
-
-            HeapId aNewId = HeapId::valueOf(nData,16);
-
-            _data->id = aNewId;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::HeapId SimpleCheckingHeapManager::id(Handle _aHeap)
-        {
-            if (_aHeap == 0) return HeapId();
-
-            HeapData * data = heap(_aHeap);
-
-            return data->id;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Handle SimpleCheckingHeapManager::createHeap(Size _sInitialSize)
-        {
-            // need to have 4-byte pointers for this implementation
-            OSL_ASSERT(sizeof(void *) == sizeof(Address));
-
-            HeapData * pHeap = new HeapData();
-
-            pHeap->refs      = 1;
-
-            pHeap->requested = _sInitialSize;
-            pHeap->allocated = 0;
-
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            makeNewId( pHeap );
-
-            OSL_ENSURE( ! findHeap(pHeap->id), "Internal Error: New heap id already registered");
-
-            return addHeap(handle(pHeap) );
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Handle SimpleCheckingHeapManager::attachHeap(HeapIdParam  _anId, Size & _rInitialSize)
-        {
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            Handle aHeap = findHeap(_anId);
-
-            OSL_ENSURE( aHeap, "Error: No such Heap");
-
-            if (aHeap != 0)
-            {
-                HeapData * data = heap(aHeap);
-
-                OSL_ENSURE( data->id == _anId, "Internal error: Inconsistent heap id");
-
-                _rInitialSize = data->requested;
-             
-                ++data->refs;
-            }
-            else
-                _rInitialSize = 0;
-
-            return aHeap;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Size   SimpleCheckingHeapManager::growHeap(Handle _aHeap, Size _sNewSize)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            if (data->requested < _sNewSize) data->requested = _sNewSize; 
-
-            return data->requested;
-        }
-    // -------------------------------------------------------------------------
-
-        void   SimpleCheckingHeapManager::destroyHeap(Handle _aHeap)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            if (0 == --data->refs)
-            {
-                OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-    //            OSL_ENSURE(data->allocations.empty(), "Memory leaks found");
-                for (HeapData::Map::iterator it = data->allocations.begin();
-                     it != data->allocations.end();
-                     ++it)
-                {
-                    deallocateMemory(it->first);
-                    data->allocated -= it->second;
-
-                }
-                OSL_ENSURE(data->allocated == 0, "Memory tracking error detected");
-
-                removeHeap(_aHeap);
-
-                delete data;
-            }
-        }
-    // -------------------------------------------------------------------------
-
-        bool SimpleCheckingHeapManager::didAllocate(Handle _aHeap, Address _aAddress)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-            OSL_PRECOND( _aAddress, "Warning: checking NULL address - will fail");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            /* Condition is:
-                    allocationAddress <= _aAddress &&
-                    _aAddress <= allocationAddress + allocationSize
-               (<= to allow past-the-end pointer)
-            */
-
-            HeapData::Map::iterator it = data->allocations.upper_bound(_aAddress);
-
-            if (it == data->allocations.begin()) 
-                return false;
-
-            --it; // Now it is the last iterator that is less than or equal to _aAddress
-
-            OSL_ASSERT( it->first <= _aAddress ); // first part of condition handled by map
-
-            return _aAddress <= it->first + it->second;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleCheckingHeapManager::allocate(Handle _aHeap, Size _nSize)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            if (_nSize > data->available()) 
-                return 0;
-
-            Address p = allocateMemory(_nSize);
-            if (p)
-            {
-                data->allocations[p] = _nSize;
-                data->allocated += _nSize;
-            }
-            return p;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleCheckingHeapManager::reallocate(Handle _aHeap, Address _aOld, Size _nNewSize)
-        {
-            if (_aOld == 0) return allocate(_aHeap,_nNewSize);
-
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            OSL_ENSURE( data->allocations.count(_aOld), "Error: pointer being reallocated is not from this data");
-
-            Size nOldSize = data->allocations[_aOld];
-
-            if (nOldSize >= _nNewSize) 
-                return _aOld;
-
-            if (_nNewSize-nOldSize > data->available()) 
-                return 0;
-
-            Address aNew = reallocateMemory(_aOld,_nNewSize);
-            if (aNew)
-            {
-                if (aNew != _aOld) data->allocations.erase(_aOld);
-
-                data->allocations[aNew] = _nNewSize;
-                data->allocated += _nNewSize - nOldSize;
-            }
-
-            return aNew;
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleCheckingHeapManager::deallocate(Handle _aHeap, Address _p)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-            OSL_PRECOND( _p, "Error: Trying to free NULL address");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            OSL_ENSURE( data->allocations.count(_p), "Error: pointer being freed is not from this data");
-
-            Size freed = data->allocations[_p];
-            data->allocated -= freed;
-            data->allocations.erase(_p);
-
-            deallocateMemory(_p);
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-
Index: configmgr/source/data/updateaccessor.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/updateaccessor.cxx,v
retrieving revision 1.7
diff -u -p -u -r1.7 updateaccessor.cxx
--- configmgr/source/data/updateaccessor.cxx	16 Sep 2006 15:11:05 -0000	1.7
+++ configmgr/source/data/updateaccessor.cxx	5 Jan 2007 22:25:41 -0000
@@ -57,13 +57,13 @@ namespace configmgr
         UpdateAccessor::UpdateAccessor(Segment * segment)
         : m_segment(segment)
         {
-            m_heap = (m_segment) ? &m_segment->acquireWriteAccess() : 0;
-            OSL_ASSERT( m_heap || !m_segment );
+			m_segment->acquireWriteAccess();
         }
     // -------------------------------------------------------------------------
         UpdateAccessor::~UpdateAccessor()
         {
-            if (m_segment) m_segment->releaseWriteAccess(*m_heap);
+			if (m_segment)
+				m_segment->releaseWriteAccess();
         }
     // -------------------------------------------------------------------------
         Accessor UpdateAccessor::accessor() const
@@ -75,15 +75,14 @@ namespace configmgr
         Accessor UpdateAccessor::downgrade()
         {
             Segment * segment = m_segment;
-            void const * base = NULL;
+
             if (m_segment)
             {
-                base = m_segment->acquireReadAccess();
-                m_segment->releaseWriteAccess(*m_heap);
+				m_segment->downgradeAccess();
                 m_segment = 0;
             }
 
-            return Accessor(segment, base, SAL_NO_ACQUIRE);
+            return Accessor(segment, SAL_NO_ACQUIRE);
         }
 
     // -------------------------------------------------------------------------
@@ -91,79 +90,10 @@ namespace configmgr
         {
             if (m_segment)
             {
-                m_segment->releaseWriteAccess(*m_heap);
+                m_segment->releaseWriteAccess();
                 m_segment = NULL;
             }
         }
-
-    // -------------------------------------------------------------------------
-        char * UpdateAccessor::heap_base() const
-        {
-            return static_cast<char *>(m_heap ? m_heap->base() : NULL);
-        }
-
-    // -------------------------------------------------------------------------
-        char * Allocator::heap_base() const
-        {
-            return static_cast<char *>(m_heap ? m_heap->base() : NULL);
-        }
-
-    // -------------------------------------------------------------------------
-        Allocator::Address Allocator::allocate(Size _sz) const
-        {
-            OSL_ENSURE(m_heap,"Cannot allocate: Invalid heap");
-            return m_heap ? m_heap->allocate(_sz) : Allocator::Address();
-        }
-
-    // -------------------------------------------------------------------------
-        void Allocator::deallocate(Address _addr) const
-        {
-            OSL_ENSURE(m_heap,"Cannot deallocate: Invalid heap");
-            if (m_heap) m_heap->deallocate(_addr);
-        }
-
-    // -------------------------------------------------------------------------
-
-    #if OSL_DEBUG_LEVEL > 0
-        void * UpdateAccessor::resolve(AddressType _p) const
-        {
-            OSL_ENSURE( !_p.is() || m_segment->isValidAddress(_p.value()), "Address does not belong to this segment");
-            return _p.is() ? heap_base() + _p.value() : NULL;
-        }
-
-        Pointer  UpdateAccessor::reduce(void const * _p) const
-        {
-            if (_p)
-            {
-                Pointer::RawAddress addr = static_cast<char const *>(_p) - heap_base();
-                OSL_ENSURE( m_segment->isValidAddress(addr), "Pointer does not belong to this segment");
-                return Pointer(addr);
-            }
-            else
-                return Pointer();
-        }
-
-        void * Allocator::access(Address _addr) const
-        {
-            OSL_ENSURE( !_addr || m_heap->isValidAddress(_addr), "Address does not belong to this segment");
-            return _addr ? heap_base() + _addr : NULL;
-        }
-
-
-        Allocator::Address  Allocator::address(void const * _p) const
-        {
-            if (_p)
-            {
-                Address addr = static_cast<char const *>(_p) - heap_base();
-                OSL_ENSURE( m_heap->isValidAddress(addr), "Pointer does not belong to this segment");
-                return addr;
-            }
-            else
-                return 0;
-        }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
Index: configmgr/source/inc/accessor.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/accessor.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 accessor.hxx
--- configmgr/source/inc/accessor.hxx	8 Sep 2005 03:41:00 -0000	1.5
+++ configmgr/source/inc/accessor.hxx	5 Jan 2007 22:25:41 -0000
@@ -36,10 +36,6 @@
 #ifndef CONFIGMGR_ACCESSOR_HXX
 #define CONFIGMGR_ACCESSOR_HXX
 
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
-#endif
-
 #ifndef _OSL_INTERLOCK_H_
 #include <osl/interlck.h>
 #endif
@@ -57,14 +53,11 @@ namespace configmgr
             struct Impl
             {
                 Impl(Segment const * segment);
-                Impl(Segment const * segment, void const * base);
-
                 ~Impl();
 
                 bool is() const { return m_segment != NULL; }
 
                 Segment const * m_segment;
-                char    const * m_base;
                 oslInterlockedCount m_refs;
             private:
                 // disallow copying
@@ -78,9 +71,6 @@ namespace configmgr
 
             Impl * m_impl;
         public:
-            /// type of addresses used in the Segment
-            typedef Pointer AddressType;
-
             /// constructs an accessor on the given Segment
             explicit Accessor(Segment const * _pSegment) : m_impl(new Impl(_pSegment)) {}
 
@@ -90,45 +80,12 @@ namespace configmgr
 
             ~Accessor() { releaseImpl(); }
             
-            void swap(Accessor & _rOther);
-
             bool is() const { return m_impl->is(); }
             void clear();
-
-            AddressType address(void const * _p) const
-            { return (this->is()) ? reduce(_p) : Pointer();}
-
-            void const * access(AddressType _p) const
-            { return (this->is()) ? resolve(_p) : failNull();}
-
-            void const * validate(AddressType _p) const
-            { return (this->is() && _p.is()) ? resolve(_p) : failNull(); }
-
         private:
-            char    const * base_()    const { return m_impl->m_base; }
-            Segment const * segment_() const { return m_impl->m_segment; }
-
-            void const * resolve(AddressType _p) const;
-            AddressType  reduce(void const * _p) const;
-
             friend class UpdateAccessor;
-            Accessor(Segment * _s, void const * _b, __sal_NoAcquire) : m_impl(new Impl(_s,_b)) {}
-            static void * failNull();
+            Accessor(Segment * _s, __sal_NoAcquire) : m_impl(new Impl(_s)) {}
         };
-
-    // -------------------------------------------------------------------------
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline 
-        void const * Accessor::resolve(AddressType _p) const 
-        { return _p.is() ? this->base_() + _p.value() : NULL; }
-
-        inline 
-        Pointer  Accessor::reduce(void const * _p) const 
-        { return _p ? Pointer(static_cast<char const *>(_p) - this->base_()) : Pointer(); }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
Index: configmgr/source/inc/anydata.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/anydata.hxx,v
retrieving revision 1.2
diff -u -p -u -r1.2 anydata.hxx
--- configmgr/source/inc/anydata.hxx	8 Sep 2005 03:41:13 -0000	1.2
+++ configmgr/source/inc/anydata.hxx	5 Jan 2007 22:25:41 -0000
@@ -51,28 +51,25 @@ namespace configmgr
 {
 //-----------------------------------------------------------------------------
 
-    namespace memory { class Allocator; class Accessor; }
-    //-----------------------------------------------------------------------------
+    namespace memory { class Accessor; };
 
     namespace sharable
     {
     //-----------------------------------------------------------------------------
 
-        //typedef Address AnyData; // data that fits is stored inline
         union AnyData
         {
-            typedef Byte TypeCode;
+            typedef sal_uInt8 TypeCode;
 
-            Address     data;
             sal_Bool    boolValue;
             sal_Int16   shortValue;
             sal_Int32   intValue;
-            Address     longValue;      // points to sal_Int64
-            Address     doubleValue;    // points to double (IEEE 8-bit) ...
-       //     float       floatValue;     // ... or should we use float (IEEE 4-bit) ?  
+            sal_Int64  *longValue;
+            double     *doubleValue;
             Vector      binaryValue;    // points to counted sal_(u)Int8 []
             String      stringValue;    // points to counted sal_Unicode []
             Vector      sequenceValue;  // points to counted AnyData [] (or SomeType [] ?)
+            void       *data;           // used to initialize to 0
         };
 
     //-----------------------------------------------------------------------------
@@ -80,10 +77,9 @@ namespace configmgr
         AnyData::TypeCode getTypeCode(::com::sun::star::uno::Type const & _aType);
         ::com::sun::star::uno::Type getUnoType( AnyData::TypeCode _aType);
 
-        AnyData allocData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, ::com::sun::star::uno::Any const & _aAny);
-    //    AnyData copyData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, AnyData _aData);
-        void    freeData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, AnyData _aData);
-        ::com::sun::star::uno::Any readData(memory::Accessor const& _anAccessor, AnyData::TypeCode _aType, AnyData _aData);
+        AnyData allocData(AnyData::TypeCode _aType, ::com::sun::star::uno::Any const & _aAny);
+        void    freeData(AnyData::TypeCode _aType, AnyData _aData);
+        ::com::sun::star::uno::Any readData(AnyData::TypeCode _aType, AnyData _aData);
 
     //-----------------------------------------------------------------------------
     } 
Index: configmgr/source/inc/builddata.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/builddata.hxx,v
retrieving revision 1.2
diff -u -p -u -r1.2 builddata.hxx
--- configmgr/source/inc/builddata.hxx	8 Sep 2005 03:43:35 -0000	1.2
+++ configmgr/source/inc/builddata.hxx	5 Jan 2007 22:25:41 -0000
@@ -36,6 +36,9 @@
 #ifndef CONFIGMGR_BUILDDATA_HXX
 #define CONFIGMGR_BUILDDATA_HXX
 
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 #ifndef INCLUDED_MEMORY
 #define INCLUDED_MEMORY
 #include <memory>
@@ -52,10 +55,10 @@ namespace configmgr
 //-----------------------------------------------------------------------------
     namespace memory { class Accessor; class UpdateAccessor; }
 //-----------------------------------------------------------------------------
+    namespace sharable { struct TreeFragment; }
     namespace data
     {
 //-----------------------------------------------------------------------------
-        class TreeAddress;
         class TreeAccessor;
 //-----------------------------------------------------------------------------
         TreeAddress buildTree(memory::UpdateAccessor& _aTargetMemory, TreeAccessor const& _aTree);
Index: configmgr/source/inc/cacheddataprovider.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/cacheddataprovider.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 cacheddataprovider.hxx
--- configmgr/source/inc/cacheddataprovider.hxx	8 Sep 2005 03:43:49 -0000	1.5
+++ configmgr/source/inc/cacheddataprovider.hxx	5 Jan 2007 22:25:41 -0000
@@ -51,7 +51,9 @@
 #ifndef CONFIGMGR_UTILITY_HXX_
 #include "utility.hxx"
 #endif
-
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 #ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
 #include <salhelper/simplereferenceobject.hxx>
 #endif
@@ -65,13 +67,7 @@ namespace configmgr
     namespace backend
     {
 // ---------------------------------------------------------------------------
-    struct CacheLocation
-    {
-        memory::SegmentAddress          segment;
-        memory::SegmentHeap::Address    address;
-            
-        bool isNull() const { return segment.isNull() || address == 0; }
-    };
+    typedef data::TreeAddress CacheLocation;
 // ---------------------------------------------------------------------------
     struct IDirectDataProvider;
     struct ICachedDataNotifier;
Index: configmgr/source/inc/change.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/change.hxx,v
retrieving revision 1.25
diff -u -p -u -r1.25 change.hxx
--- configmgr/source/inc/change.hxx	25 Sep 2006 12:48:57 -0000	1.25
+++ configmgr/source/inc/change.hxx	5 Jan 2007 22:25:41 -0000
@@ -45,9 +45,6 @@
 #ifndef CONFIGMGR_TREESEGMENT_HXX
 #include "treesegment.hxx"
 #endif
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
-#endif
 
 #ifndef _SAL_TYPES_H_
 #include <sal/types.h>
@@ -242,7 +239,7 @@ namespace configmgr
 		bool isReplacing() const { return m_bReplacing; }
 
 		/// has this been applied and inserted
-		bool wasInserted() const { return m_aInsertedTree.is(); }
+		bool wasInserted() const { return m_aInsertedTree != NULL; }
 
 		/** returns the node this change represents, even if this node does not own the new Node object any more. 
 			This is somewhat dangerous if the node referenced by this object dies before the object itself does.<BR>
Index: configmgr/source/inc/configset.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/configset.hxx,v
retrieving revision 1.15
diff -u -p -u -r1.15 configset.hxx
--- configmgr/source/inc/configset.hxx	8 Sep 2005 03:46:23 -0000	1.15
+++ configmgr/source/inc/configset.hxx	5 Jan 2007 22:25:41 -0000
@@ -107,7 +107,7 @@ namespace configmgr
 
 			TemplateHolder getTemplate() const;
 
-			ElementTree getElementTree(data::Accessor const& _accessor) const;
+			ElementTree getElementTree(memory::Accessor const& _accessor) const;
             osl::Mutex& getTreeLock() const;
 
 			TreeRef getTreeRef() const;
@@ -120,12 +120,12 @@ namespace configmgr
 		class ElementTree
 		{
 			ElementTreeHolder m_aTreeHolder;
-            data::Accessor    m_accessor;
+            memory::Accessor    m_accessor;
 		public:
             static ElementTree emptyElement() { return ElementTree(); }
 
-			ElementTree(data::Accessor const& _accessor, ElementTreeImpl* pTree);
-			ElementTree(data::Accessor const& _accessor, ElementTreeHolder const& pTree);
+			ElementTree(memory::Accessor const& _accessor, ElementTreeImpl* pTree);
+			ElementTree(memory::Accessor const& _accessor, ElementTreeHolder const& pTree);
 			ElementTree(ElementTree const& aOther);
 			ElementTree& operator=(ElementTree const& aOther);
 			~ElementTree();
@@ -171,16 +171,16 @@ namespace configmgr
         class SetElementInfo
 		{
             TemplateInfo    m_aTemplateInfo;
-            data::Accessor  m_aSetAccessor;
+            memory::Accessor  m_aSetAccessor;
 		public:
-			SetElementInfo(data::Accessor const& _aSetAccessor, TemplateHolder const& aTemplate);
+			SetElementInfo(memory::Accessor const& _aSetAccessor, TemplateHolder const& aTemplate);
 
 			TemplateHolder getTemplate()        const;
 			TemplateInfo   getTemplateInfo()    const;
 
             UnoType	 getElementType() const { return m_aTemplateInfo.getType(); }
 
-            data::Accessor  getSetDataAccessor() const { return m_aSetAccessor; }
+            memory::Accessor  getSetDataAccessor() const { return m_aSetAccessor; }
 
 			static TemplateHolder extractElementInfo(Tree const& aTree, NodeRef const& aNode);
 		};
@@ -189,11 +189,11 @@ namespace configmgr
 		class SetElementFactory
 		{
 			TemplateProvider m_aProvider;
-            data::Accessor m_aDataAccessor;
+            memory::Accessor m_aDataAccessor;
 
-            data::Accessor const& getDataAccessor() const { return m_aDataAccessor; };
+            memory::Accessor const& getDataAccessor() const { return m_aDataAccessor; };
 		public:
-			SetElementFactory(data::Accessor const& _aDataAccessor, TemplateProvider const& aProvider);
+			SetElementFactory(memory::Accessor const& _aDataAccessor, TemplateProvider const& aProvider);
 			SetElementFactory(SetElementFactory const& aOther);
 			SetElementFactory& operator=(SetElementFactory const& aOther);
 			~SetElementFactory();
Index: configmgr/source/inc/datalock.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/datalock.hxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 datalock.hxx
--- configmgr/source/inc/datalock.hxx	8 Sep 2005 03:46:50 -0000	1.3
+++ configmgr/source/inc/datalock.hxx	5 Jan 2007 22:25:41 -0000
@@ -33,31 +33,3 @@
  *
  ************************************************************************/
 
-#ifndef CONFIGMGR_DATALOCK_HXX
-#define CONFIGMGR_DATALOCK_HXX
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-
-        /// class controlling access to a memory::Segment
-        struct DataLock
-        {
-	        virtual void acquireReadAccess() = 0;
-	        virtual void releaseReadAccess() = 0;
-
-	        virtual void acquireWriteAccess() = 0; 	        
-	        virtual void releaseWriteAccess() = 0;
-        protected:
-            virtual ~DataLock() {}
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-#endif // CONFIGMGR_DATALOCK_HXX
-
Index: configmgr/source/inc/groupnodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/groupnodeaccess.hxx,v
retrieving revision 1.5.74.1
diff -u -p -u -r1.5.74.1 groupnodeaccess.hxx
--- configmgr/source/inc/groupnodeaccess.hxx	3 Nov 2006 11:35:17 -0000	1.5.74.1
+++ configmgr/source/inc/groupnodeaccess.hxx	5 Jan 2007 22:25:41 -0000
@@ -51,27 +51,20 @@ namespace configmgr
         public:
             typedef NodeAccess::Name        Name;
             typedef NodeAccess::Attributes  Attributes;
-            typedef GroupNodeAddress                    NodeAddressType;
-            typedef GroupNodeAddress::AddressType       AddressType;
-            typedef GroupNodeAddress::DataType const    DataType;
-            typedef DataType * NodePointerType;
             typedef NodeAddress                         ChildAddressType;
             typedef NodeAccessRef                       ChildAccessType;
 
-            GroupNodeAccess(Accessor const& _aAccessor, NodeAddressType const& _aNodeRef) 
+            GroupNodeAccess(memory::Accessor const& _aAccessor, const sharable::GroupNode *_pNodeRef)
             : m_aAccessor(_aAccessor)
-            , m_pData(_aNodeRef.m_pData) 
-            {}
-
-            GroupNodeAccess(Accessor const& _aAccessor, NodePointerType _pNode) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(check(_aAccessor,_pNode)) 
+            , m_pData((GroupNodeAddress)_pNodeRef) 
+            , m_pCache(NULL)
             {}
 
             explicit
             GroupNodeAccess(NodeAccess const & _aNode) 
             : m_aAccessor(_aNode.accessor())
             , m_pData(check(_aNode)) 
+            , m_pCache(NULL)
             {
             }
 
@@ -79,8 +72,10 @@ namespace configmgr
             GroupNodeAccess(NodeAccessRef const & _aNode) 
             : m_aAccessor(_aNode.accessor())
             , m_pData(check(_aNode)) 
+            , m_pCache(NULL)
             {
             }
+            ~GroupNodeAccess();
 
             static bool isInstance(NodeAccessRef const & _aNode) 
             {
@@ -95,31 +90,30 @@ namespace configmgr
             bool isDefault()   const;
 
             bool hasChild(Name const& _aName) const 
-            { return implGetChild(_aName).is(); }
+            { return implGetChild(_aName) != NULL; }
           
             bool hasChildren() const;
 
             ChildAccessType getChildNode(Name const& _aName) const
             { return NodeAccessRef(&m_aAccessor, implGetChild(_aName)); }
 
-            NodeAddressType address()   const { return NodeAddressType(m_pData); }
-            Accessor const& accessor()  const { return m_aAccessor; }
+            memory::Accessor const& accessor()  const { return m_aAccessor; }
 
             operator NodeAccessRef()    const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            sharable::GroupNode& data() const { return *m_pData; }
+            operator GroupNodeAddress () const { return (GroupNodeAddress)m_pData; }
 
         private:
-            static AddressType check(NodeAccessRef const&);
-            static AddressType check(Accessor const&, NodePointerType);
+            static GroupNodeAddress check(NodeAccessRef const&);
 
             ChildAddressType implGetChild(Name const& _aName) const;
 
-            Accessor    m_aAccessor;
-		    AddressType m_pData;
+            memory::Accessor   m_aAccessor;
+		    GroupNodeAddress   m_pData;
+		    mutable const sharable::Node *m_pCache;
         };
 
-        GroupNodeAddress toGroupNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr);
         GroupNodeAddress toGroupNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr);
     // -------------------------------------------------------------------------
         inline 
Index: configmgr/source/inc/heap.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/heap.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 heap.hxx
--- configmgr/source/inc/heap.hxx	28 Dec 2005 17:29:58 -0000	1.5
+++ configmgr/source/inc/heap.hxx	5 Jan 2007 22:25:41 -0000
@@ -46,50 +46,5 @@
 #include <rtl/string.hxx>
 #endif
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class Heap : Noncopyable
-        {
-            HeapManager       & m_impl;
-            HeapManager::Handle m_heap;
-            HeapManager::Size   m_size;
-        public:
-            typedef HeapManager::Lock        Lock;
-            typedef HeapManager::Size        Size;
-            typedef HeapManager::HeapId      HeapId;
-            typedef HeapManager::HeapIdParam HeapIdParam;
-            typedef HeapManager::Address     Address;
-
-            Heap(HeapManager& _impl);
-            Heap(HeapManager& _impl, Size _nInitialSize);
-            Heap(HeapManager& _impl, HeapIdParam _anId);
-            ~Heap();
-
-            Size    size() const { return m_size; }
-
-            Size    grow(Size _nReqSize); 
-
-            void *  base() const   { return m_impl.base(m_heap); }
-            HeapId  id()   const   { return m_impl.id(m_heap); }
-
-            Address allocate(Size _sNewSize)    { return m_impl.allocate(m_heap, _sNewSize); }
-            Address reallocate(Address _aOldAddress, Size _sNewSize)    
-            { return m_impl.reallocate(m_heap, _aOldAddress, _sNewSize); }
-            void    deallocate(Address _aAddress)    { m_impl.deallocate(m_heap, _aAddress); }
-            bool    didAllocate(Address _aAddress) const 
-            { return m_impl.didAllocate(m_heap, _aAddress); }
-
-            Lock *  createLock()                { return m_impl.createHeapLock(m_heap); }
-            void    destroyLock(Lock * _pLock)  { m_impl.destroyHeapLock(m_heap,_pLock); }
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
 #endif // CONFIGMGR_DATAHEAP_HXX
 
Index: configmgr/source/inc/heapfactory.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/heapfactory.hxx,v
retrieving revision 1.2
diff -u -p -u -r1.2 heapfactory.hxx
--- configmgr/source/inc/heapfactory.hxx	8 Sep 2005 03:48:33 -0000	1.2
+++ configmgr/source/inc/heapfactory.hxx	5 Jan 2007 22:25:41 -0000
@@ -36,21 +36,5 @@
 #ifndef CONFIGMGR_HEAPFACTORY_HXX
 #define CONFIGMGR_HEAPFACTORY_HXX
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-        class HeapManager;
-
-        HeapManager & localHeap();
-        HeapManager & cacheHeap();
-
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
 #endif // CONFIGMGR_HEAPFACTORY_HXX
 
Index: configmgr/source/inc/heapmanager.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/heapmanager.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 heapmanager.hxx
--- configmgr/source/inc/heapmanager.hxx	28 Dec 2005 17:30:19 -0000	1.5
+++ configmgr/source/inc/heapmanager.hxx	5 Jan 2007 22:25:41 -0000
@@ -36,9 +36,6 @@
 #ifndef CONFIGMGR_DATAHEAPMANAGER_HXX
 #define CONFIGMGR_DATAHEAPMANAGER_HXX
 
-#ifndef CONFIGMGR_MEMORYMODEL_HXX
-#include "memorymodel.hxx"
-#endif
 #ifndef CONFIGMGR_DATALOCK_HXX
 #include "datalock.hxx"
 #endif
@@ -50,45 +47,7 @@
 #include <rtl/string.hxx>
 #endif
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class HeapManager
-        {
-        public:
-            typedef struct Opaque_ * Handle;
-
-            typedef memory::HeapSize    Size;
-            typedef memory::Address     Address;
-            typedef rtl::OString        HeapId;
-            typedef rtl::OString const & HeapIdParam;
-
-        //    virtual HeapId newHeapId() = 0;
-            virtual Handle createHeap(/*HeapIdParam _anId, */Size _sInitialSize) = 0;
-            virtual Handle attachHeap(HeapIdParam _anId, Size & _rInitialSize) = 0;
-            virtual Size   growHeap(Handle _aHeap, Size _sNewSize) = 0;
-            virtual void   destroyHeap(Handle _aHeap) = 0;
-
-            virtual void *  base(Handle _aHeap) = 0;
-            virtual HeapId  id(Handle _aHeap) = 0;
-
-            virtual Address allocate(Handle _aHeap, Size _sNewSize) = 0;
-            virtual Address reallocate(Handle _aHeap, Address _aOldAddress, Size _sNewSize) = 0;
-            virtual void    deallocate(Handle _aHeap, Address _aAddress) = 0;
-            virtual bool    didAllocate(Handle _aHeap, Address _aAddress) = 0;
-
-            typedef DataLock Lock;
-
-            virtual Lock *  createHeapLock(Handle _aHeap) = 0;
-            virtual void    destroyHeapLock(Handle _aHeap, Lock * _pLock) = 0;
-        };
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
+#include <osl/mutex.hxx>
 
 #endif // CONFIGMGR_DATAHEAPMANAGER_HXX
 
Index: configmgr/source/inc/memorymodel.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/memorymodel.hxx,v
retrieving revision 1.2
diff -u -p -u -r1.2 memorymodel.hxx
--- configmgr/source/inc/memorymodel.hxx	28 Dec 2005 17:30:28 -0000	1.2
+++ configmgr/source/inc/memorymodel.hxx	5 Jan 2007 22:25:41 -0000
@@ -1,69 +1 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile: memorymodel.hxx,v $
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-
-#ifndef CONFIGMGR_MEMORYMODEL_HXX
-#define CONFIGMGR_MEMORYMODEL_HXX
-
-#ifndef _SAL_TYPES_H_
-#include <sal/types.h>
-#endif
-
-//-----------------------------------------------------------------------------
-// no full heap implementation available yet - storing pointer value in Address
-#define CFG_ADDRESS_HOLDS_POINTER
-//-----------------------------------------------------------------------------
-
-namespace configmgr
-{
-//-----------------------------------------------------------------------------
-
-    namespace memory 
-    {
-    //-----------------------------------------------------------------------------
-    // some base types that describe our memory model
-#ifndef CFG_ADDRESS_HOLDS_POINTER
-        typedef sal_uInt32 Address; // points to relative location in memory segment
-#else
-        typedef sal_uIntPtr Address; // points to absolute location in memory
-#endif
-        typedef sal_uInt32 HeapSize; // memory block size within private heap
-        typedef sal_uInt8  Byte;  
-    //-----------------------------------------------------------------------------
-    }
-//-----------------------------------------------------------------------------
-}
-
-
-#endif // CONFIGMGR_MEMORYMODEL_HXX 
+#error Do not include me ...
Index: configmgr/source/inc/mergechange.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/mergechange.hxx,v
retrieving revision 1.8
diff -u -p -u -r1.8 mergechange.hxx
--- configmgr/source/inc/mergechange.hxx	8 Sep 2005 03:49:58 -0000	1.8
+++ configmgr/source/inc/mergechange.hxx	5 Jan 2007 22:25:41 -0000
@@ -51,7 +51,7 @@ namespace configmgr 
 {
 	// -----------------------------------------------------------------------------
     namespace memory    { class UpdateAccessor; }
-    namespace data      { class NodeAddress; }
+//    namespace data      { class NodeAddress; }
 
 	// method that applies changes on a existing subtree
     void applyUpdateWithAdjustment(TreeChangeList & _anUpdate, memory::UpdateAccessor& _aUpdateAccess, data::NodeAddress const & _aBaseAddress);
Index: configmgr/source/inc/node.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/node.hxx,v
retrieving revision 1.4.74.1
diff -u -p -u -r1.4.74.1 node.hxx
--- configmgr/source/inc/node.hxx	3 Nov 2006 11:35:30 -0000	1.4.74.1
+++ configmgr/source/inc/node.hxx	5 Jan 2007 22:25:41 -0000
@@ -93,35 +93,35 @@ namespace configmgr
 
             Node * getFirstChild();
             Node * getNextChild(Node * _pChild);
-
             Node const * getFirstChild()  const;
             Node const * getNextChild(Node const * _pChild) const;
+
         };
     //-----------------------------------------------------------------------------
+        typedef sal_uInt8 * SetElementAddress;
         struct SetNode
         {
+
             NodeInfo info;
-            Address  elementType; // points to template
+            SetElementAddress  elementType; // points to template [MM:SetNode *?]
             List     elements;    // points to first element (TreeFragmentHeader)
 
             bool isLocalizedValue() const;
 
-		    rtl::OUString getElementTemplateName  (memory::Accessor const & _anAccessor) const;		
-		    rtl::OUString getElementTemplateModule(memory::Accessor const & _anAccessor) const;
+		    rtl::OUString getElementTemplateName() const;		
+		    rtl::OUString getElementTemplateModule() const;
 
-            TreeFragment const  * getFirstElement(memory::Accessor const & _anAccessor) const;
-            TreeFragment const  * getNextElement(memory::Accessor const & _anAccessor, TreeFragment const * _pElement) const;
+            TreeFragment const  * getFirstElement() const;
+            TreeFragment const  * getNextElement(TreeFragment const * _pElement) const;
 
             // low-level helper for template data abstraction
             static
-            Address allocTemplateData(memory::Allocator const & _anAllocator,
-									  const rtl::OUString &rName,
+            SetElementAddress allocTemplateData(const rtl::OUString &rName,
 									  const rtl::OUString &rModule);
             static 
-			Address copyTemplateData(memory::Allocator const & _anAllocator,
-									 Address _aTemplateData);
+			SetElementAddress copyTemplateData(SetElementAddress _aTemplateData);
             static
-            void releaseTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData);
+            void releaseTemplateData(SetElementAddress _aTemplateData);
         };
     //-----------------------------------------------------------------------------
         struct ValueNode
@@ -134,10 +134,10 @@ namespace configmgr
 		    bool isNull()       const;
 		    bool hasUsableDefault()   const;
 		    
-		    uno::Type   getValueType()  const;
-		    uno::Any    getValue(memory::Accessor const & _aAccessor)      const;
-		    uno::Any    getUserValue(memory::Accessor const & _aAccessor)    const;
-		    uno::Any    getDefaultValue(memory::Accessor const & _aAccessor) const;
+		    uno::Any    getValue() const;
+		    uno::Type   getValueType() const;
+		    uno::Any    getUserValue() const;
+		    uno::Any    getDefaultValue() const;
         };
     //-----------------------------------------------------------------------------
         // TODO: optimized representation of localized values (now as set; mapping locale->element-name)
@@ -209,6 +209,13 @@ namespace configmgr
         { return reinterpret_cast<Node const&>(pNode); }
     //-----------------------------------------------------------------------------
     }
+
+    namespace data {
+        typedef sharable::Node      * NodeAddress;
+        typedef sharable::ValueNode * ValueNodeAddress;
+        typedef sharable::GroupNode * GroupNodeAddress;
+        typedef sharable::SetNode   * SetNodeAddress;
+    };
 //-----------------------------------------------------------------------------
 }
 
Index: configmgr/source/inc/nodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/nodeaccess.hxx,v
retrieving revision 1.5.74.1
diff -u -p -u -r1.5.74.1 nodeaccess.hxx
--- configmgr/source/inc/nodeaccess.hxx	3 Nov 2006 11:35:43 -0000	1.5.74.1
+++ configmgr/source/inc/nodeaccess.hxx	5 Jan 2007 22:25:41 -0000
@@ -36,13 +36,12 @@
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #define CONFIGMGR_NODEACCESS_HXX
 
-#ifndef CONFIGMGR_NODEADDRESS_HXX
-#include "nodeaddress.hxx"
+#ifndef INCLUDED_SHARABLE_NODE_HXX
+#include "node.hxx"
 #endif
 #ifndef CONFIGMGR_ACCESSOR_HXX
 #include "accessor.hxx"
 #endif
-
 #ifndef _CONFIGMGR_TREE_VALUENODE_HXX
 #include "valuenode.hxx"
 #endif
@@ -53,118 +52,97 @@
 namespace configmgr
 {
 // -----------------------------------------------------------------------------	
+    namespace memory { class UpdateAccessor; class Accessor; }
+	
     namespace data
     {
-    // -------------------------------------------------------------------------
-        using memory::Accessor;
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------	
+        // -------------------------------------------------------------------------	
         class NodeAccess
-	    {
+        {
         public:
-            typedef configuration::Name     Name;
-            typedef node::Attributes        Attributes;
-
-            typedef NodeAddress                     NodeAddressType;
-            typedef NodeAddress::AddressType        AddressType;
-            typedef NodeAddress::DataType const     DataType;
-            typedef DataType * NodePointerType;
+            typedef configuration::Name    Name;
+            typedef node::Attributes       Attributes;
 
             static NodeAccess emptyNode() { return NodeAccess(); }
 
-            NodeAccess(Accessor const& _aAccessor, NodeAddressType const& _aNodeRef) 
+            NodeAccess(memory::Accessor const& _aAccessor, NodeAddress const& _aNodeRef) 
             : m_aAccessor(_aAccessor)
-            , m_pData(_aNodeRef.m_pData) 
+            , m_pData(_aNodeRef) 
             {}
 
-            NodeAccess(Accessor const& _aAccessor, NodePointerType _pNode) 
+            NodeAccess(memory::Accessor const& _aAccessor, const sharable::Node *_pNode) 
             : m_aAccessor(_aAccessor)
-            , m_pData(_aAccessor.address(_pNode)) 
+            , m_pData(_pNode) 
             {}
 
-            bool isValid() const { return m_pData.is(); }
-            bool isLocalRoot() const { return data().isFragmentRoot(); }
-
-            Name getName() const { return wrapName( data().getName() ); }
-            Attributes getAttributes() const { return data().getAttributes(); }
+            bool isValid() const { return m_pData != NULL; }
+            bool isLocalRoot() const { return m_pData->isFragmentRoot(); }
 
-            bool isDefault()   const { return data().isDefault(); }
-            bool isLocalized() const { return data().isLocalized(); }
+            Name getName() const { return wrapName( m_pData->getName() ); }
+            Attributes getAttributes() const { return m_pData->getAttributes(); }
 
-            NodeAddressType address() const { return NodeAddressType(m_pData); }
-            Accessor const& accessor() const { return m_aAccessor; }
+            bool isDefault()   const { return m_pData->isDefault(); }
+            bool isLocalized() const { return m_pData->isLocalized(); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
-            NodePointerType getDataPtr() const { return static_cast<NodePointerType>(m_aAccessor.access(m_pData)); }
-
-            AddressType rawAddress() const { return m_pData; }
+            memory::Accessor const& accessor() const { return m_aAccessor; }
+            sharable::Node const & data() const { return *m_pData; }
 
             static Name wrapName(rtl::OUString const& _aNameString)
-            { return configuration::makeName( _aNameString, Name::NoValidate() ); }
+                { return configuration::makeName( _aNameString, Name::NoValidate() ); }
 
-            static NodeAddress::DataType* access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor& _rUpdateAccess);
-            static NodeAddress::DataType const* access(NodeAddressType const& _aNodeRef, Accessor const& _rReaderAccess)
-            { return static_cast<NodePointerType>(_rReaderAccess.access(_aNodeRef.m_pData)); }
+            operator sharable::Node *() const { return (sharable::Node *)m_pData; }
+            operator const sharable::Node * () const { return m_pData; }
+            bool operator ==(const sharable::Node *pNode) const { return m_pData == pNode; }
         private:
-            NodeAccess() : m_aAccessor(NULL), m_pData() {}
+            NodeAccess() : m_aAccessor(NULL), m_pData(NULL) {}
 
-            Accessor    m_aAccessor;
-		    AddressType m_pData;
+            memory::Accessor m_aAccessor;
+            const sharable::Node * m_pData;
         };
-    // -------------------------------------------------------------------------	
+        // -------------------------------------------------------------------------	
         class NodeAccessRef
-	    {
+        {
         public:
-            typedef NodeAccess::Name                Name;
-            typedef NodeAccess::Attributes          Attributes;
-
-            typedef NodeAccess::NodeAddressType     NodeAddressType;
-            typedef NodeAccess::AddressType         AddressType;
-            typedef NodeAccess::DataType            DataType;
-            typedef NodeAccess::NodePointerType     NodePointerType;
+            typedef configuration::Name    Name;
+            typedef node::Attributes       Attributes;
 
             NodeAccessRef(NodeAccess const& _aNodeAccess) 
             : m_pAccessor(&_aNodeAccess.accessor())
-            , m_pData(_aNodeAccess.rawAddress()) 
+            , m_pData(_aNodeAccess) 
             {}
 
-            NodeAccessRef(Accessor const * _pAccessor, NodeAddressType const& _aNodeRef) 
+            NodeAccessRef(memory::Accessor const * _pAccessor, NodeAddress const& _aNodeRef) 
             : m_pAccessor(_pAccessor)
-            , m_pData(_aNodeRef.m_pData) 
+            , m_pData(_aNodeRef) 
             {}
 
-            NodeAccessRef(Accessor const * _pAccessor, NodePointerType _pNode) 
+            NodeAccessRef(memory::Accessor const * _pAccessor, sharable::Node const *_pNode) 
             : m_pAccessor(_pAccessor)
-            , m_pData(_pAccessor->address(_pNode)) 
+            , m_pData((sharable::Node *)_pNode) 
             {}
 
-            NodeAccess toNodeAccess () const { return NodeAccess(accessor(),address()); }
-
-            bool isValid() const { return m_pData.is(); }
-            bool isLocalRoot() const { return data().isFragmentRoot(); }
-
-            Name getName() const { return NodeAccess::wrapName( data().getName() ); }
-            Attributes getAttributes() const { return data().getAttributes(); }
+            NodeAccess toNodeAccess () const { return NodeAccess(accessor(),m_pData); }
 
-            bool isDefault()   const { return data().isDefault(); }
-            bool isLocalized() const { return data().isLocalized(); }
+            bool isValid() const { return m_pData != NULL; }
+            bool isLocalRoot() const { return m_pData->isFragmentRoot(); }
+            bool isDefault()   const { return m_pData->isDefault(); }
+            bool isLocalized() const { return m_pData->isLocalized(); }
 
-            NodeAddressType address() const { return NodeAddressType(m_pData); }
-            Accessor const& accessor() const { return *m_pAccessor; }
+            Name getName() const { return NodeAccess::wrapName( m_pData->getName() ); }
+            Attributes getAttributes() const { return m_pData->getAttributes(); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_pAccessor->validate(m_pData)); }
-            NodePointerType getDataPtr() const { return static_cast<NodePointerType>(m_pAccessor->access(m_pData)); }
+            memory::Accessor const& accessor() const { return *m_pAccessor; }
 
-            AddressType rawAddress() const { return m_pData; }
+            sharable::Node const & data() const { return *m_pData; }
+            operator NodeAddress () const { return (NodeAddress)m_pData; }
 
         private:
-            Accessor const *   m_pAccessor;
-		    AddressType m_pData;
+            memory::Accessor const *m_pAccessor;
+            NodeAddress     m_pData;
         };
     // -------------------------------------------------------------------------
     // helper - finds child or element
         NodeAccess  getSubnode(NodeAccessRef const & _aNode, NodeAccess::Name const & _aName);
-        NodeAddress getSubnodeAddress(memory::Accessor const& _aAccess, NodeAddress const & _aNodeAddress, NodeAccess::Name const & _aName);
         NodeAddress getSubnodeAddress(memory::UpdateAccessor& _aAccess, NodeAddress const & _aNodeAddress, NodeAccess::Name const & _aName);
     // -------------------------------------------------------------------------
     }
Index: configmgr/source/inc/nodeaddress.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/nodeaddress.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 nodeaddress.hxx
--- configmgr/source/inc/nodeaddress.hxx	19 Jan 2006 17:53:30 -0000	1.5
+++ configmgr/source/inc/nodeaddress.hxx	5 Jan 2007 22:25:41 -0000
@@ -1,153 +1 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile: nodeaddress.hxx,v $
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-
-#ifndef CONFIGMGR_NODEADDRESS_HXX
-#define CONFIGMGR_NODEADDRESS_HXX
-
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
-#endif
-
-#ifndef INCLUDED_SHARABLE_NODE_HXX
-#include "node.hxx"
-#endif
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory { class Accessor; }
-// -----------------------------------------------------------------------------	
-    namespace data
-    {
-    // -------------------------------------------------------------------------	
-        using memory::Accessor;
-    // -------------------------------------------------------------------------	
-        class NodeAddress
-	    {
-            friend class NodeAccess;
-            friend class NodeAccessRef;
-        public:
-            typedef sharable::Node      DataType;
-            typedef memory::Pointer     AddressType;
-
-        public:
-            NodeAddress() : m_pData() {}
-
-            explicit
-            NodeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
-
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
-
-            AddressType::RawAddress addressValue() const { return m_pData.value(); }
-
-            friend bool operator == (NodeAddress const& lhs, NodeAddress const& rhs);
-
-            friend bool operator != (NodeAddress const& lhs, NodeAddress const& rhs);
-
-        private:
-		    AddressType                 m_pData;
-        };
-
-        inline bool operator == (NodeAddress const& lhs, NodeAddress const& rhs)
-        { return lhs.m_pData == rhs.m_pData; }
-
-        inline bool operator != (NodeAddress const& lhs, NodeAddress const& rhs)
-        { return lhs.m_pData != rhs.m_pData; }
-    // -------------------------------------------------------------------------
-
-        class ValueNodeAddress
-	    {
-            friend class ValueNodeAccess;
-        public:
-            typedef sharable::ValueNode DataType;
-            typedef memory::Pointer     AddressType;
-
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
-
-            operator NodeAddress() const { return NodeAddress(m_pData); }
-        private:
-            explicit
-            ValueNodeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
-
-		    AddressType m_pData;
-        };
-    // -------------------------------------------------------------------------
-
-        class GroupNodeAddress
-	    {
-            friend class GroupNodeAccess;
-        public:
-            typedef sharable::GroupNode DataType;
-            typedef memory::Pointer     AddressType;
-
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
-
-            operator NodeAddress()        const { return NodeAddress(m_pData); }
-        private:
-            explicit
-            GroupNodeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
-
-		    AddressType m_pData;
-        };
-    // -------------------------------------------------------------------------
-
-        class SetNodeAddress
-	    {
-            friend class SetNodeAccess;
-        public:
-            typedef sharable::SetNode   DataType;
-            typedef memory::Pointer     AddressType;
-
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
-
-            operator NodeAddress()        const { return NodeAddress(m_pData); }
-        private:
-            explicit
-            SetNodeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
-
-		    AddressType m_pData;
-        };
-    // -------------------------------------------------------------------------
-    } 
-
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-#endif // CONFIGMGR_NODEADDRESS_HXX
-
+#warning Don't include me ... 
Index: configmgr/source/inc/nodechangeinfo.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/nodechangeinfo.hxx,v
retrieving revision 1.9
diff -u -p -u -r1.9 nodechangeinfo.hxx
--- configmgr/source/inc/nodechangeinfo.hxx	25 Sep 2006 12:49:10 -0000	1.9
+++ configmgr/source/inc/nodechangeinfo.hxx	5 Jan 2007 22:25:42 -0000
@@ -128,8 +128,8 @@ namespace configmgr
 
 		//-------------------------------------------------
 		// wrapper object creation 
-			Tree	getNewElementTree(data::Accessor const& aAccessor) const;
-			Tree	getOldElementTree(data::Accessor const& aAccessor) const;
+			Tree	getNewElementTree(memory::Accessor const& aAccessor) const;
+			Tree	getOldElementTree(memory::Accessor const& aAccessor) const;
 
 			NodeRef getNewElementNodeRef() const;
 			NodeRef getOldElementNodeRef() const;
@@ -166,19 +166,19 @@ namespace configmgr
 			bool isValidData() const;
 
 			/// check whether the location is for a valid object
-			bool isValidLocation(data::Accessor const& aAccessor) const;
+			bool isValidLocation(memory::Accessor const& aAccessor) const;
 
 		//-------------------------------------------------
 			/// retrieve the path from the base node to the changed node (which might be a child of the affected node)
 			RelativePath getAccessor() const { return m_path; }
 
 			/// retrieve the tree where the change is actually initiated/reported
-			Tree getBaseTree(data::Accessor const& aAccessor) const;
+			Tree getBaseTree(memory::Accessor const& aAccessor) const;
 			/// retrieve the node where the change is actually initiated/reported
 			NodeRef getBaseNode() const;
 
 			/// retrieve the tree where the change is actually taking place (may be Empty, if the tree has never been accessed)
-			Tree getAffectedTree(data::Accessor const& aAccessor) const;
+			Tree getAffectedTree(memory::Accessor const& aAccessor) const;
 			/// retrieve the tree where the change is actually taking place (may be Empty, if the tree has never been accessed)
 			TreeRef getAffectedTreeRef() const;
 			/// retrieve the node where the change is actually taking place (if the affected Tree is not empty)
@@ -220,14 +220,14 @@ namespace configmgr
 		public:
 		//-------------------------------------------------
             explicit
-            NodeChangeInformation(data::Accessor const& _accessor)
+            NodeChangeInformation(memory::Accessor const& _accessor)
             : accessor(_accessor)
             , change()
             , location()
             {
             }
 		//-------------------------------------------------
-            data::Accessor      accessor;
+            memory::Accessor      accessor;
 			NodeChangeData		change;
 			NodeChangeLocation	location;
 
Index: configmgr/source/inc/noderef.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/noderef.hxx,v
retrieving revision 1.18
diff -u -p -u -r1.18 noderef.hxx
--- configmgr/source/inc/noderef.hxx	19 Jan 2006 17:53:48 -0000	1.18
+++ configmgr/source/inc/noderef.hxx	5 Jan 2007 22:25:43 -0000
@@ -53,18 +53,18 @@
 
 namespace configmgr
 {
-	class INode;
+    class INode;
 
-    namespace data      { using memory::Accessor; class TreeAccessor; }
-	namespace view      { class ViewTreeAccess; }
-	namespace configapi { class Factory; }
-	namespace node      { struct Attributes; }
-	namespace configuration
-	{
-	//-------------------------------------------------------------------------
-		class Name;
-		class AbsolutePath;
-		class RelativePath;
+    namespace data      { class TreeAccessor; }
+    namespace view      { class ViewTreeAccess; }
+    namespace configapi { class Factory; }
+    namespace node      { struct Attributes; }
+    namespace configuration
+    {
+	//-------------------------------------------------------------------------
+	class Name;
+	class AbsolutePath;
+	class RelativePath;
         namespace Path { class Component; }
 
 		class NodeChange;
@@ -222,9 +222,9 @@ namespace configmgr
             typedef node::Attributes NodeAttributes;
 		public:
 			/// create a tree with a given implementation
-            Tree(data::Accessor const& _accessor, TreeImpl* pImpl);
+            Tree(memory::Accessor const& _accessor, TreeImpl* pImpl);
 			/// create a tree with a given implementation
-            Tree(data::Accessor const& _accessor, TreeRef const& _aTree);
+            Tree(memory::Accessor const& _accessor, TreeRef const& _aTree);
 
 			/// checks, if this refers to an existing tree
 			bool isValid() const
@@ -467,18 +467,18 @@ namespace configmgr
 
         // view & data layer binding
         public:
-            data::Accessor const & getDataAccessor() const { return m_accessor; }
+            memory::Accessor const & getDataAccessor() const { return m_accessor; }
 
             view::ViewTreeAccess getView() const;
 
-			void rebind(data::Accessor const& _aAccessor);
+			void rebind(memory::Accessor const& _aAccessor);
 			void unbind();
 		// Comparison
 		public:
 			friend bool equalTree(Tree const& lhs, Tree const& rhs) { return equalTreeRef(lhs.m_ref, rhs.m_ref); }
 		private:
 			friend class TreeImplHelper;
-            data::Accessor  m_accessor;
+            memory::Accessor  m_accessor;
 			TreeRef         m_ref;
 		};
 	//-------------------------------------------------------------------------
Index: configmgr/source/inc/pointer.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/pointer.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 pointer.hxx
--- configmgr/source/inc/pointer.hxx	28 Dec 2005 17:30:54 -0000	1.5
+++ configmgr/source/inc/pointer.hxx	5 Jan 2007 22:25:43 -0000
@@ -32,59 +32,3 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-
-#ifndef CONFIGMGR_POINTER_HXX
-#define CONFIGMGR_POINTER_HXX
-
-#ifndef CONFIGMGR_MEMORYMODEL_HXX
-#include "memorymodel.hxx"
-#endif
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class Accessor;
-        class UpdateAccessor;
-    // -------------------------------------------------------------------------	
-        /// class mediating read-only access to a memory::Segment
-        class Pointer 
-        {
-            friend class Accessor;
-            friend class UpdateAccessor;
-
-            typedef memory::Address AddressType;
-
-            AddressType m_value;
-
-            struct Opaque_;
-        public:
-            typedef AddressType RawAddress;
-
-            Pointer() : m_value(0) {}
-            explicit Pointer(AddressType p) : m_value(p) {}
-
-            RawAddress value() const { return m_value; }
-
-            bool isNull()   const { return m_value == 0; }
-            bool is()       const { return m_value != 0; }
-
-            operator Opaque_ const * () const { return reinterpret_cast<Opaque_ const *>(m_value); }
-
-            friend bool operator == (Pointer lhs, Pointer rhs)
-            { return lhs.value() == rhs.value(); }
-
-            friend bool operator != (Pointer lhs, Pointer rhs)
-            { return lhs.value() != rhs.value(); }
-        };
-
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-// -----------------------------------------------------------------------------
-
-#endif // CONFIGMGR_POINTER_HXX
-
Index: configmgr/source/inc/segment.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/segment.hxx,v
retrieving revision 1.4
diff -u -p -u -r1.4 segment.hxx
--- configmgr/source/inc/segment.hxx	8 Sep 2005 03:55:04 -0000	1.4
+++ configmgr/source/inc/segment.hxx	5 Jan 2007 22:25:43 -0000
@@ -36,16 +36,18 @@
 #ifndef CONFIGMGR_SEGMENT_HXX
 #define CONFIGMGR_SEGMENT_HXX
 
+#ifndef _OSL_INTERLOCK_H_
+#include <osl/interlck.h>
+#endif
 #ifndef CONFIGMGR_DATALOCK_HXX
 #include "datalock.hxx"
 #endif
-#ifndef CONFIGMGR_SEGMENTHEAP_HXX
-#include "segmentheap.hxx"
-#endif
 #ifndef _RTL_STRING_HXX_
 #include <rtl/string.hxx>
 #endif
 
+#include <osl/mutex.hxx>
+
 namespace configmgr
 {
 // -----------------------------------------------------------------------------	
@@ -54,65 +56,22 @@ namespace configmgr
     // -------------------------------------------------------------------------	
         class Segment
         {
-            SegmentHeap m_heap;
+            osl::Mutex m_mutex;
         public:
-            typedef SegmentHeap     Heap;
-            typedef Heap::Lock      Lock;
-            typedef rtl::OString    Id;
-
-        public:
-            explicit Segment(HeapManager & _aHeapImpl) 
-            : m_heap(_aHeapImpl) {}
-
-            explicit Segment(HeapManager & _aHeapImpl, Heap::Size _aInitialSize) 
-            : m_heap(_aHeapImpl,_aInitialSize) {}
+            explicit Segment() 
+            : m_mutex() {}
 
-            explicit Segment(HeapManager & _aHeapImpl, Id const & _anId) 
-            : m_heap(_aHeapImpl,_anId) {}
-
-            Id getId() const { return m_heap.id(); }
-
-            bool isValidAddress(Heap::Address _aAddress) const
-            {
-                return m_heap.isValidAddress(_aAddress); 
-            }
-
-            Heap& acquireWriteAccess()       
-            { 
-                this->lock().acquireWriteAccess(); 
-                return this->heap(); 
-            }
-
-            void  releaseWriteAccess(Heap&)  
-            { 
-                this->lock().releaseWriteAccess(); 
-            }
-
-            void const * acquireReadAccess() const 
-            { 
-                this->lock().acquireReadAccess();
-                return base();
-            }
-            void releaseReadAccess (void const * ) const 
-            { 
-                this->lock().releaseReadAccess(); 
-            }
-        private:
-            Heap & heap()       { return m_heap; }
-            Lock & lock() const { return m_heap.lock(); }
-            void * base() const { return m_heap.base(); }
+			void acquireWriteAccess();
+			void releaseWriteAccess();
+			void downgradeAccess()    {}
+
+			void acquireReadAccess() const { ((Segment *)this)->acquireWriteAccess(); }
+			void releaseReadAccess() const { ((Segment *)this)->acquireReadAccess(); }
+
+            // debugging
+            static bool countLocks;
+            static oslInterlockedCount numLocks;
         };
-    // -------------------------------------------------------------------------
-        typedef Segment::Id SegmentID;
-    // -------------------------------------------------------------------------
-        struct SegmentAddress
-        {
-            SegmentID               id;
-            SegmentHeap::Address    base;
-
-            bool isNull() const { return base == 0; }
-        };
-    // -------------------------------------------------------------------------	
     }
 // -----------------------------------------------------------------------------	
 } // namespace configmgr
Index: configmgr/source/inc/segmentheap.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/segmentheap.hxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 segmentheap.hxx
--- configmgr/source/inc/segmentheap.hxx	8 Sep 2005 03:55:20 -0000	1.3
+++ configmgr/source/inc/segmentheap.hxx	5 Jan 2007 22:25:43 -0000
@@ -32,82 +32,3 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-
-#ifndef CONFIGMGR_SEGMENTHEAP_HXX
-#define CONFIGMGR_SEGMENTHEAP_HXX
-
-#ifndef CONFIGMGR_DATAHEAP_HXX
-#include "heap.hxx"
-#endif
-#ifndef CONFIGMGR_UTILITY_HXX_
-#include "utility.hxx"
-#endif
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-        class SegmentHeap : Noncopyable
-        {
-            friend class Segment;
-            typedef Heap::Lock Lock;
-
-            Heap   m_heap;
-            void * m_base;
-            Lock * m_lock;
-
-            Lock & lock() const { return *m_lock; }
-        public:
-            typedef Heap::HeapId        HeapId;
-            typedef Heap::HeapIdParam   HeapIdParam;
-            typedef Heap::Size          Size;
-            typedef Heap::Address       Address;
-            
-            SegmentHeap(HeapManager & _rImpl)
-            : m_heap(_rImpl)
-            { init(); }
-
-            SegmentHeap(HeapManager & _rImpl, Size _aInitialSize)
-            : m_heap(_rImpl,_aInitialSize)
-            { init(); }
-
-            SegmentHeap(HeapManager & _rImpl, HeapIdParam _anId)
-            : m_heap(_rImpl,_anId)
-            { init(); }
-
-            ~SegmentHeap();
-
-            // PRE: lock must be acquired
-            void*   base() const { return m_base; }
-            HeapId  id() const { return m_heap.id(); }
-
-            Address allocate(Size _sz) 
-            {
-                Address aResult = m_heap.allocate(_sz);
-                if (!aResult)
-                    aResult = this->allocateMore(_sz);
-                return aResult;
-            }
-
-            void deallocate(Address _addr) 
-            { 
-                m_heap.deallocate(_addr); 
-            }
-
-            bool isValidAddress(Address _addr) const
-            { 
-                return m_heap.didAllocate(_addr); 
-            }
-        private:
-            void init();
-            Address allocateMore(Size _sz);
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-#endif // CONFIGMGR_SEGMENT_HXX
-
Index: configmgr/source/inc/sequence.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/sequence.hxx,v
retrieving revision 1.2
diff -u -p -u -r1.2 sequence.hxx
--- configmgr/source/inc/sequence.hxx	8 Sep 2005 03:55:37 -0000	1.2
+++ configmgr/source/inc/sequence.hxx	5 Jan 2007 22:25:43 -0000
@@ -56,19 +56,17 @@ namespace configmgr
         typedef Vector Sequence; // alternative name
     //-----------------------------------------------------------------------------
        
-        Sequence allocSequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, ::sal_Sequence const * _pSeqData);
-    //    Sequence copySequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, Sequence _aSeq);
-        void     freeSequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, Sequence _aSeq);
+        Sequence allocSequence(AnyData::TypeCode _aElementType, ::sal_Sequence const * _pSeqData);
+        void     freeSequence(AnyData::TypeCode _aElementType, Sequence _aSeq);
 
-        ::sal_Sequence * readSequence(memory::Accessor const& _anAccessor, AnyData::TypeCode _aElementType, Sequence _aSeq);
-        ::com::sun::star::uno::Any readAnySequence(memory::Accessor const& _anAccessor, AnyData::TypeCode _aElementType, Sequence _aSeq);
+        ::sal_Sequence * readSequence(AnyData::TypeCode _aElementType, Sequence _aSeq);
+        ::com::sun::star::uno::Any readAnySequence(AnyData::TypeCode _aElementType, Sequence _aSeq);
     //-----------------------------------------------------------------------------
 
-        Sequence allocBinary(memory::Allocator const& _anAllocator, ::com::sun::star::uno::Sequence<sal_Int8> const & _aBinaryValue);
-    //    Sequence copyBinary(memory::Allocator const& _anAllocator, Sequence _aSeq);
-        void freeBinary(memory::Allocator const& _anAllocator, Sequence _aSeq);
+        Sequence allocBinary(::com::sun::star::uno::Sequence<sal_Int8> const & _aBinaryValue);
+        void freeBinary(Sequence _aSeq);
 
-        ::com::sun::star::uno::Sequence<sal_Int8> readBinary(memory::Accessor const& _anAccessor, Sequence _aSeq);
+        ::com::sun::star::uno::Sequence<sal_Int8> readBinary(Sequence _aSeq);
     //-----------------------------------------------------------------------------
 
         template <class ET>
@@ -80,11 +78,11 @@ namespace configmgr
         }
 
         template <class ET>
-        Sequence allocSequence(memory::Allocator const& _anAllocator, ::com::sun::star::uno::Sequence<ET> const & _aSeq)
+        Sequence allocSequence(::com::sun::star::uno::Sequence<ET> const & _aSeq)
         {
             AnyData::TypeCode aTC = getElementTypeCode(_aSeq);
             ::sal_Sequence const * pSeqData = _aSeq.get();
-            return allocSequence(_anAllocator, aTC, pSeqData);
+            return allocSequence(aTC, pSeqData);
         }
 
         template <class ET>
@@ -92,7 +90,7 @@ namespace configmgr
         {
             AnyData::TypeCode aElementType = getElementTypeCode(_rSeq);
 
-            ::sal_Sequence * pNewSequence = readSequence(_anAccessor, aElementType, _aSeq);
+            ::sal_Sequence * pNewSequence = readSequence(aElementType, _aSeq);
 
             if (!pNewSequence) return;
 
@@ -106,7 +104,7 @@ namespace configmgr
         {
             if (getElementTypeCode(_rSeq) != _aElementType) return false;
 
-            ::sal_Sequence * pNewSequence = readSequence(_anAccessor, _aElementType, _aSeq);
+            ::sal_Sequence * pNewSequence = readSequence(_aElementType, _aSeq);
 
             if (!pNewSequence) return false;
 
Index: configmgr/source/inc/setnodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/setnodeaccess.hxx,v
retrieving revision 1.4.74.1
diff -u -p -u -r1.4.74.1 setnodeaccess.hxx
--- configmgr/source/inc/setnodeaccess.hxx	3 Nov 2006 11:35:56 -0000	1.4.74.1
+++ configmgr/source/inc/setnodeaccess.hxx	5 Jan 2007 22:25:43 -0000
@@ -39,6 +39,9 @@
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #include "nodeaccess.hxx"
 #endif
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 
 namespace configmgr
 {
@@ -46,7 +49,6 @@ namespace configmgr
     namespace data
     {
     // -------------------------------------------------------------------------
-        class TreeAddress;
         class TreeAccessor;
     // -------------------------------------------------------------------------
         /** class that mediates access to the data of a Set node
@@ -57,21 +59,12 @@ namespace configmgr
         public:
             typedef NodeAccess::Name        Name;
             typedef NodeAccess::Attributes  Attributes;
-            typedef SetNodeAddress                    NodeAddressType;
-            typedef SetNodeAddress::AddressType       AddressType;
-            typedef SetNodeAddress::DataType const    DataType;
-            typedef DataType * NodePointerType;
             typedef TreeAddress                       ElementAddress;
             typedef TreeAccessor                      ElementAccess;
 
-            SetNodeAccess(Accessor const& _aAccessor, NodeAddressType const& _aNodeRef) 
+            SetNodeAccess(memory::Accessor const& _aAccessor, const sharable::SetNode *_pNodeRef) 
             : m_aAccessor(_aAccessor)
-            , m_pData(_aNodeRef.m_pData) 
-            {}
-
-            SetNodeAccess(Accessor const& _aAccessor, NodePointerType _pNode) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(check(_aAccessor,_pNode)) 
+            , m_pData((SetNodeAddress)_pNodeRef) 
             {}
 
             explicit
@@ -108,26 +101,25 @@ namespace configmgr
             bool            hasElement      (Name const& _aName) const; 
             ElementAccess   getElementTree  (Name const& _aName) const;
 
-            NodeAddressType address()   const { return NodeAddressType(m_pData); }
-            Accessor const& accessor()  const { return m_aAccessor; }
+            memory::Accessor const& accessor()  const { return m_aAccessor; }
 
             operator NodeAccessRef() const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            sharable::SetNode & data() const { return *m_pData; }
+            operator SetNodeAddress () const { return (SetNodeAddress)m_pData; }
+            operator NodeAddress () const { return (NodeAddress)m_pData; }
 
-            static void addElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, ElementAddress _aNewElement);
-            static ElementAddress removeElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, Name const & _aName);
+            static void addElement(SetNodeAddress _aSetAddress, ElementAddress _aNewElement);
+            static ElementAddress removeElement(SetNodeAddress _aSetAddress, Name const & _aName);
         private:
-            static AddressType check(NodeAccessRef const&);
-            static AddressType check(Accessor const&, NodePointerType);
+            static SetNodeAddress check(NodeAccessRef const&);
 
             ElementAddress implGetElement(Name const& _aName) const;
 
-            Accessor    m_aAccessor;
-		    AddressType m_pData;
+            memory::Accessor       m_aAccessor;
+		    SetNodeAddress m_pData;
         };
 
-        SetNodeAddress toSetNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr);
         SetNodeAddress toSetNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr);
     // -------------------------------------------------------------------------
         inline 
@@ -136,11 +128,11 @@ namespace configmgr
         
         inline 
 		NodeAccess::Name SetNodeAccess::getElementTemplateName()   const 
-        { return NodeAccess::wrapName( data().getElementTemplateName(m_aAccessor) ); }	
+        { return NodeAccess::wrapName( data().getElementTemplateName() ); }	
         
         inline 
 		NodeAccess::Name SetNodeAccess::getElementTemplateModule() const 
-        { return NodeAccess::wrapName( data().getElementTemplateModule(m_aAccessor) ); }	
+        { return NodeAccess::wrapName( data().getElementTemplateModule() ); }	
         
         inline           
         NodeAccess::Attributes SetNodeAccess::getAttributes() const 
Index: configmgr/source/inc/treeaccessor.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treeaccessor.hxx,v
retrieving revision 1.5.74.1
diff -u -p -u -r1.5.74.1 treeaccessor.hxx
--- configmgr/source/inc/treeaccessor.hxx	3 Nov 2006 11:36:16 -0000	1.5.74.1
+++ configmgr/source/inc/treeaccessor.hxx	5 Jan 2007 22:25:43 -0000
@@ -36,20 +36,23 @@
 #ifndef CONFIGMGR_TREEACCESSOR_HXX
 #define CONFIGMGR_TREEACCESSOR_HXX
 
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
-#endif
 #ifndef CONFIGMGR_ACCESSOR_HXX
 #include "accessor.hxx"
 #endif
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #include "nodeaccess.hxx"
 #endif
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 
 #ifndef INCLUDED_CSTDDEF
 #include <cstddef>
 #define INCLUDED_CSTDDEF
 #endif
+#ifndef CONFIGMGR_BUILDDATA_HXX
+#include <builddata.hxx>
+#endif
 
 namespace configmgr
 {
@@ -73,70 +76,62 @@ namespace configmgr
         public:
             typedef configuration::Name     Name;
             typedef node::Attributes        Attributes;
-            typedef TreeAddress                 DataAddressType;
-            typedef TreeAddress::DataType const DataType;
-            typedef DataType  * DataPointerType;
 
             static TreeAccessor emptyTree() { return TreeAccessor(); }
 
-            TreeAccessor(Accessor const& _aAccessor, DataAddressType const& _aTreeRef) 
+            TreeAccessor(Accessor const& _aAccessor, TreeAddress const& _aTreeRef)
             : m_aAccessor(_aAccessor)
-            , m_pBase(_aTreeRef.m_pData) 
+            , m_pBase(_aTreeRef) 
             {}
 
-            TreeAccessor(Accessor const& _aAccessor, DataPointerType _pTree) 
+            TreeAccessor(Accessor const& _aAccessor, const sharable::TreeFragment * _pTree) 
             : m_aAccessor(_aAccessor)
-            , m_pBase(_aAccessor.address(_pTree)) 
+            , m_pBase((sharable::TreeFragment *)_pTree)
             {}
 
-            bool isValid() const { return m_pBase.is(); }
-
-            bool isDefault() const { return data().isDefault(); }
+            bool isValid() const { return m_pBase != NULL; }
 
-            Attributes getAttributes() const { return data().getAttributes(); }
+            Attributes getAttributes() const { return m_pBase->getAttributes(); }
             Name getName() const;
 
             NodeAccessRef getRootNode() const { return NodeAccessRef(&m_aAccessor,rootAddress(m_pBase)); }
 
-            DataAddressType address() const { return m_pBase; }
             Accessor const& accessor() const { return m_aAccessor; }
 
-            DataType& data() const { return *static_cast<DataPointerType>(m_aAccessor.validate(m_pBase.m_pData)); }
-            DataPointerType getDataPtr() const { return access(m_pBase,m_aAccessor); }
-
-            TreeAddress copyTree(memory::UpdateAccessor & _aTargetSpace) const;
-            static void freeTree(memory::UpdateAccessor & _aTargetSpace, TreeAddress _aTree);
+            sharable::TreeFragment& data() const { return *m_pBase; }
+            operator sharable::TreeFragment *() const { return (sharable::TreeFragment *)m_pBase; }
+            sharable::TreeFragment* operator->() const { return m_pBase; }
 
             static Name wrapName(rtl::OUString const& _aNameString)
-            { return configuration::makeName( _aNameString, Name::NoValidate() ); }
+                { return configuration::makeName( _aNameString, Name::NoValidate() ); }
+//            static sharable::TreeFragment* access(TreeAddress const& _aTreeRef) { return _aTreeRef; }
+            TreeAddress copyTree(memory::UpdateAccessor & _aTargetSpace) const
+                { return data::buildTree(_aTargetSpace, *this); }
+            static void freeTree(memory::UpdateAccessor & _aTargetSpace, TreeAddress _aTree)
+                { data::destroyTree(_aTargetSpace,_aTree); }
 
-            static TreeAddress::DataType* access(DataAddressType const& _aTreeRef, memory::UpdateAccessor& _rUpdateAccess);
-            static TreeAddress::DataType const* access(DataAddressType const& _aTreeRef, Accessor const& _rReaderAccess)
-            { return static_cast<DataPointerType>(_rReaderAccess.access(_aTreeRef.m_pData)); }
         private:
-            NodeAddress rootAddress(DataAddressType const& p) const;
+            NodeAddress rootAddress(TreeAddress const& p) const;
+            TreeAccessor() : m_aAccessor(NULL), m_pBase(NULL) { }
 
-            TreeAccessor();
-        private:
-            Accessor            m_aAccessor;
-		    DataAddressType     m_pBase;
+            Accessor     m_aAccessor;
+            TreeAddress  m_pBase;
         };
     // -------------------------------------------------------------------------
     // -------------------------------------------------------------------------
         inline
         TreeAccessor::Name TreeAccessor::getName() const 
         { 
-            return wrapName( data().getName() );
+            return wrapName( m_pBase->getName() );
         }
     // -------------------------------------------------------------------------
         inline
-        NodeAddress TreeAccessor::rootAddress(DataAddressType const& p) const 
+        NodeAddress TreeAccessor::rootAddress(TreeAddress const& p) const 
         { 
-            sharable::Address aAddr = p.addressValue();
-
-            if (aAddr) aAddr += offsetof(TreeAddress::DataType,nodes);
-
-            return NodeAddress( memory::Pointer(aAddr) ); 
+            if (p == NULL)
+                return NULL;
+            sharable::TreeFragment const *pFrag = p;
+            return const_cast<NodeAddress>(pFrag->nodes);
         }
     // -------------------------------------------------------------------------
     }
Index: configmgr/source/inc/treeaddress.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treeaddress.hxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 treeaddress.hxx
--- configmgr/source/inc/treeaddress.hxx	8 Sep 2005 03:58:45 -0000	1.3
+++ configmgr/source/inc/treeaddress.hxx	5 Jan 2007 22:25:43 -0000
@@ -1,88 +1,2 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile: treeaddress.hxx,v $
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#define CONFIGMGR_TREEADDRESS_HXX
-
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
-#endif
-
-#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
-#include "treefragment.hxx"
-#endif
-
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    class INode;
-// -----------------------------------------------------------------------------	
-    namespace data
-    {
-    // -------------------------------------------------------------------------	
-        class TreeAddress
-	    {
-            friend class TreeAccessor;
-        public:
-            typedef sharable::TreeFragment  DataType;
-            typedef memory::Pointer         AddressType;
-        public:
-            TreeAddress() : m_pData() {}
-
-            explicit
-            TreeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
-
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
-
-            AddressType::RawAddress addressValue() const { return m_pData.value(); }
-
-            friend bool operator == (TreeAddress const& lhs, TreeAddress const& rhs)
-            { return lhs.m_pData == rhs.m_pData; }
-
-            friend bool operator != (TreeAddress const& lhs, TreeAddress const& rhs)
-            { return lhs.m_pData != rhs.m_pData; }
-
-        private:
-		    AddressType m_pData;
-        };
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-#endif // CONFIGMGR_TREEADDRESS_HXX
-
+/* cvs remove me ... */
+#error do not include me...
Index: configmgr/source/inc/treefragment.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treefragment.hxx,v
retrieving revision 1.4.74.1
diff -u -p -u -r1.4.74.1 treefragment.hxx
--- configmgr/source/inc/treefragment.hxx	3 Nov 2006 11:36:29 -0000	1.4.74.1
+++ configmgr/source/inc/treefragment.hxx	5 Jan 2007 22:25:43 -0000
@@ -79,16 +79,16 @@ namespace configmgr
     */
         struct TreeFragmentHeader
         {
-            List            next;       // next sibling set element or template
-            String          name;       // element-name/template name
+            struct TreeFragment *next;       // next sibling set element or template
+            String               name;       // element-name/template name
             union // context
             {
-                Address     parent;     // parent node
-                String      component;  // component name 
+                union Node *parent;          // parent node
+                String      component;       // component name 
             };
-            Offset          count;      // number of contained nodes
-            State::Field    state;      
-            Byte            reserved;
+            Offset               count;      // number of contained nodes
+            State::Field         state;      
+            sal_uInt8            reserved;
        };
     //-----------------------------------------------------------------------------
     /* a tree fragment is stored as a variable-sized struct
@@ -138,9 +138,16 @@ namespace configmgr
 
             rtl::OUString               getName() const;
             configmgr::node::Attributes getAttributes()const;
+
+            static TreeFragment *allocate(sal_uInt32 nFragments);
+            static void free_shallow( TreeFragment *pFragment );
         };
     //-----------------------------------------------------------------------------
+
     }
+  namespace data {
+    typedef sharable::TreeFragment * TreeAddress;
+  }
 //-----------------------------------------------------------------------------
 }
 
Index: configmgr/source/inc/treemanager.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treemanager.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 treemanager.hxx
--- configmgr/source/inc/treemanager.hxx	8 Sep 2005 03:59:42 -0000	1.5
+++ configmgr/source/inc/treemanager.hxx	5 Jan 2007 22:25:43 -0000
@@ -104,12 +104,10 @@ namespace configmgr
 		/** ctor
 		*/
         explicit
-        TreeManager(BackendCacheRef const & _xBackend, memory::HeapManager & _rCacheHeapManager);
+        TreeManager(BackendCacheRef const & _xBackend);
 
 		// disposing the cache before destroying		
 		void dispose();
-		
-        memory::HeapManager & getCacheHeapManager() const;
 
 		// ITreeManager
         virtual memory::Segment* getDataSegment(AbsolutePath const& _rAccessor, 
Index: configmgr/source/inc/treesegment.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treesegment.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 treesegment.hxx
--- configmgr/source/inc/treesegment.hxx	8 Sep 2005 04:00:27 -0000	1.5
+++ configmgr/source/inc/treesegment.hxx	5 Jan 2007 22:25:43 -0000
@@ -43,12 +43,15 @@
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
-
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 #ifndef INCLUDED_MEMORY
 #include <memory>
 #define INCLUDED_MEMORY
 #endif // INCLUDED_MEMORY
 
+
 // -----------------------------------------------------------------------------
 namespace rtl { class OUString; }
 // -----------------------------------------------------------------------------
@@ -70,7 +73,6 @@ namespace configmgr
     namespace data
     {
     // -------------------------------------------------------------------------	
-        class TreeAddress;
         class TreeAccessor;
     // -------------------------------------------------------------------------	
         class TreeSegment
Index: configmgr/source/inc/types.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/types.hxx,v
retrieving revision 1.3.58.1
diff -u -p -u -r1.3.58.1 types.hxx
--- configmgr/source/inc/types.hxx	3 Nov 2006 11:36:43 -0000	1.3.58.1
+++ configmgr/source/inc/types.hxx	5 Jan 2007 22:25:43 -0000
@@ -36,10 +36,6 @@
 #ifndef INCLUDED_SHARABLE_BASETYPES_HXX
 #define INCLUDED_SHARABLE_BASETYPES_HXX
 
-#ifndef CONFIGMGR_MEMORYMODEL_HXX
-#include "memorymodel.hxx"
-#endif
-
 #ifndef _SAL_TYPES_H_
 #include <sal/types.h>
 #endif
@@ -55,35 +51,31 @@ namespace configmgr
 {
     namespace sharable
     {
-    //-----------------------------------------------------------------------------
-    // some base types
-        typedef memory::Address  Address;  // points to absolute location in memory segment
-        typedef memory::HeapSize HeapSize; // size of memory block within heap
+	//-----------------------------------------------------------------------------
+	// some base types
         typedef sal_uInt16 Offset;  // Offset relative to 'this' in array of nodes
-        typedef sal_uInt8  Byte;  
 
-    // some derived types 
+	// some derived types 
         typedef rtl_uString *  Name;
         typedef rtl_uString *  String;
-        typedef Address List;    // singly linked intrusive, used for set elements
-        typedef Address Vector;   // points to counted sequence of some type
+        typedef struct TreeFragment * List;	// singly linked intrusive, used for set elements
+        typedef sal_uInt8 *           Vector;	// points to counted sequence of some type
 
-    //-----------------------------------------------------------------------------
+	//-----------------------------------------------------------------------------
 
         Name allocName(::rtl::OUString const & _sString);
         void freeName(Name _aName);
         ::rtl::OUString readName(Name _aName);
 
-    //-----------------------------------------------------------------------------
+	//-----------------------------------------------------------------------------
 
         String allocString(::rtl::OUString const & _sString);
         void   freeString(String _aString);
         ::rtl::OUString readString(String _aString);
 
-    //-----------------------------------------------------------------------------
+	//-----------------------------------------------------------------------------
     }
 //-----------------------------------------------------------------------------
 }
 
-
 #endif // INCLUDED_SHARABLE_BASETYPES_HXX 
Index: configmgr/source/inc/updateaccessor.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/updateaccessor.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 updateaccessor.hxx
--- configmgr/source/inc/updateaccessor.hxx	28 Dec 2005 17:31:29 -0000	1.5
+++ configmgr/source/inc/updateaccessor.hxx	5 Jan 2007 22:25:43 -0000
@@ -39,9 +39,6 @@
 #ifndef CONFIGMGR_UTILITY_HXX_
 #include "utility.hxx"
 #endif
-#ifndef CONFIGMGR_MEMORYMODEL_HXX
-#include "memorymodel.hxx"
-#endif
 #ifndef CONFIGMGR_ACCESSOR_HXX
 #include "accessor.hxx"
 #endif
@@ -54,87 +51,22 @@ namespace configmgr
     // -------------------------------------------------------------------------
         class Segment;
         class SegmentHeap;
-    // -------------------------------------------------------------------------
-
-        class Allocator
-        {
-            SegmentHeap *   m_heap;
-
-        public:
-            typedef memory::Address Address;
-            typedef memory::HeapSize Size;
-
-            Address allocate(Size _sz) const;
-            void deallocate(Address _addr) const;
-
-            void *      access(Address _addr) const;
-            Address     address(void const * _p) const;
 
-        private:
-            friend class UpdateAccessor;
-
-            Allocator(SegmentHeap * _heap) : m_heap(_heap) {}
-            char * heap_base() const;
-        };
     // -------------------------------------------------------------------------
         class UpdateAccessor : Noncopyable
         {
             Segment *       m_segment;
-            SegmentHeap *   m_heap;
         public:
-            typedef Accessor::AddressType AddressType;
-
             /// constructs an accessor on the given Segment
             explicit UpdateAccessor(Segment * segment);
             ~UpdateAccessor();
 
             bool is() const { return m_segment != 0; }
 
-        // Warning: The accessor and any addresses validated by it
-        //          will be valid only until the next call on this->allocator()
             Accessor accessor() const;
             Accessor downgrade(); // return accessor and clear
             void clear();
-
-            AddressType address(void const * _p) const
-            { return (this->is()) ? reduce(_p) : Pointer();}
-
-            void * access(AddressType _p) const
-            { return (this->is()) ? resolve(_p) : Accessor::failNull();}
-
-            void * validate(AddressType _p) const
-            { return (this->is() && _p.is()) ? resolve(_p) : Accessor::failNull(); }
-
-        // allocation support
-            Allocator allocator() const { return Allocator(m_heap); }
-        private:
-            char * heap_base() const;
-            void * resolve(AddressType _p) const;
-            AddressType  reduce(void const * _p) const;
         };
-    // -------------------------------------------------------------------------
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline
-        void * UpdateAccessor::resolve(AddressType _p) const
-        { return _p.is() ? heap_base() + _p.value() : NULL; }
-
-        inline
-        Pointer  UpdateAccessor::reduce(void const * _p) const
-        { return _p ? Pointer(static_cast<char const *>(_p) - heap_base()) : Pointer(); }
-  #endif // OSL_DEBUG_LEVEL
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline
-        void * Allocator::access(Address _addr) const
-        { return _addr ? heap_base() + _addr : NULL; }
-
-        inline
-        Allocator::Address  Allocator::address(void const * _p) const
-        { return _p ? (static_cast<char const *>(_p) - heap_base()) : 0; }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
Index: configmgr/source/inc/updatehelper.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/updatehelper.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 updatehelper.hxx
--- configmgr/source/inc/updatehelper.hxx	8 Sep 2005 04:01:35 -0000	1.5
+++ configmgr/source/inc/updatehelper.hxx	5 Jan 2007 22:25:43 -0000
@@ -45,7 +45,7 @@ namespace configmgr
 {
 //..........................................................................
     namespace memory    { class UpdateAccessor; }
-    namespace data      { class NodeAddress; class NodeAccessRef; }
+    namespace data      { /* class NodeAddress; */ class NodeAccessRef; }
 
 //..........................................................................
 
Index: configmgr/source/inc/valuenodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/valuenodeaccess.hxx,v
retrieving revision 1.4.74.1
diff -u -p -u -r1.4.74.1 valuenodeaccess.hxx
--- configmgr/source/inc/valuenodeaccess.hxx	3 Nov 2006 11:36:56 -0000	1.4.74.1
+++ configmgr/source/inc/valuenodeaccess.hxx	5 Jan 2007 22:25:43 -0000
@@ -51,34 +51,20 @@ namespace configmgr
         public:
             typedef NodeAccess::Name        Name;
             typedef NodeAccess::Attributes  Attributes;
-            typedef ValueNodeAddress                    NodeAddressType;
-            typedef ValueNodeAddress::AddressType       AddressType;
-            typedef ValueNodeAddress::DataType const    DataType;
-            typedef DataType * NodePointerType;
-
-            ValueNodeAccess(Accessor const& _aAccessor, NodeAddressType const& _aNodeRef) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(_aNodeRef.m_pData) 
-            {}
-
-            ValueNodeAccess(Accessor const& _aAccessor, NodePointerType _pNode) 
-            : m_aAccessor(_aAccessor)
-            , m_pData(check(_aAccessor,_pNode)) 
-            {}
 
+            ValueNodeAccess(memory::Accessor const& _aAccessor, const sharable::ValueNode *_pNodeRef) 
+                : m_aAccessor(_aAccessor)
+                , m_pData((ValueNodeAddress)_pNodeRef) {}
+    
             explicit
             ValueNodeAccess(NodeAccess const & _aNode) 
-            : m_aAccessor(_aNode.accessor())
-            , m_pData(check(_aNode)) 
-            {
-            }
+                : m_aAccessor(_aNode.accessor())
+                , m_pData(check(_aNode)) {}
 
             explicit
             ValueNodeAccess(NodeAccessRef const & _aNode) 
-            : m_aAccessor(_aNode.accessor())
-            , m_pData(check(_aNode)) 
-            {
-            }
+                : m_aAccessor(_aNode.accessor())
+                , m_pData(check(_aNode))  {}
 
             static bool isInstance(NodeAccessRef const & _aNode) 
             {
@@ -103,26 +89,25 @@ namespace configmgr
             uno::Any    getUserValue()      const;
             uno::Any    getDefaultValue()   const;
 
-		    static void setValue(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue);
-		    static void setToDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode);
-		    static void changeDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue);
+		    static void setValue(memory::UpdateAccessor & _aUpdater, ValueNodeAddress _aValueNode, uno::Any const& _aValue);
+		    static void setToDefault(memory::UpdateAccessor & _aUpdater, ValueNodeAddress _aValueNode);
+		    static void changeDefault(memory::UpdateAccessor & _aUpdater, ValueNodeAddress _aValueNode, uno::Any const& _aValue);
 
-            NodeAddressType address()   const { return NodeAddressType(m_pData); }
-            Accessor const& accessor()  const { return m_aAccessor; }
+            memory::Accessor const& accessor()  const { return m_aAccessor; }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            sharable::ValueNode& data() const { return *m_pData; }
+            operator ValueNodeAddress () const { return (ValueNodeAddress)m_pData; }
 
             operator NodeAccessRef() const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
+            bool operator == (const NodeAddress &rAddr) const { return NodeAddress(m_pData) == rAddr; }
+            bool operator == (const ValueNodeAddress &rAddr) const { return m_pData == rAddr; }
         private:
-            static AddressType check(Accessor const& _acc, NodePointerType _p) { return _acc.address(_p); }
-            static AddressType check(NodeAccessRef const& _aNodeData);
+            static ValueNodeAddress check(NodeAccessRef const& _aNodeData);
 
-            Accessor    m_aAccessor;
-		    AddressType m_pData;
+            memory::Accessor         m_aAccessor;
+            ValueNodeAddress m_pData;
         };
 
-        ValueNodeAddress toValueNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr);
-        ValueNodeAddress toValueNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr);
     // -------------------------------------------------------------------------
 
         inline 
@@ -143,15 +128,15 @@ namespace configmgr
 
         inline           
         uno::Any    ValueNodeAccess::getValue()      const 
-        { return data().getValue(m_aAccessor); }
+        { return data().getValue(); }
 
         inline           
         uno::Any    ValueNodeAccess::getUserValue()    const 
-        { return data().getUserValue(m_aAccessor); }
+        { return data().getUserValue(); }
 
         inline           
         uno::Any    ValueNodeAccess::getDefaultValue()    const 
-        { return data().getDefaultValue(m_aAccessor); }
+        { return data().getDefaultValue(); }
 
     // -------------------------------------------------------------------------
     }
Index: configmgr/source/inc/valueref.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/valueref.hxx,v
retrieving revision 1.4
diff -u -p -u -r1.4 valueref.hxx
--- configmgr/source/inc/valueref.hxx	8 Sep 2005 04:02:40 -0000	1.4
+++ configmgr/source/inc/valueref.hxx	5 Jan 2007 22:25:43 -0000
@@ -125,7 +125,7 @@ namespace configmgr
 			// checking
 			bool isEmpty() const;
 			// checking
-			bool isValidNode(data::Accessor const& _accessor) const;
+			bool isValidNode(memory::Accessor const& _accessor) const;
 			// hashing
 			size_t hashCode() const;
 			// containing node this
@@ -141,7 +141,7 @@ namespace configmgr
 	//-------------------------------------------------------------------------
 
 		typedef std::vector<SubNodeID>		SubNodeIDList;
-		void getAllChildrenHelper(data::Accessor const& _aAccessor, NodeID const& aNode, SubNodeIDList& aList);
+		void getAllChildrenHelper(memory::Accessor const& _aAccessor, NodeID const& aNode, SubNodeIDList& aList);
 
 	//-------------------------------------------------------------------------
 		inline bool operator!=(SubNodeID const& lhs, SubNodeID const& rhs)
Index: configmgr/source/localbe/localfilehelper.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/localbe/localfilehelper.cxx,v
retrieving revision 1.4
diff -u -p -u -r1.4 localfilehelper.cxx
--- configmgr/source/localbe/localfilehelper.cxx	16 Sep 2006 15:11:34 -0000	1.4
+++ configmgr/source/localbe/localfilehelper.cxx	5 Jan 2007 22:25:43 -0000
@@ -164,6 +164,10 @@ namespace configmgr 
         if (_sURL.getLength() == 0)
             return false;
 
+		// This method has no right to be so under-performing to
+		// achieve so, so little of any usefulness.
+		return true;
+
         DirectoryItem aDirItem;
         
         DirectoryItem::RC rc = DirectoryItem::get(_sURL, aDirItem);
Index: configmgr/source/localbe/localmultistratum.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/localbe/localmultistratum.cxx,v
retrieving revision 1.8
diff -u -p -u -r1.8 localmultistratum.cxx
--- configmgr/source/localbe/localmultistratum.cxx	16 Sep 2006 15:12:17 -0000	1.8
+++ configmgr/source/localbe/localmultistratum.cxx	5 Jan 2007 22:25:43 -0000
@@ -110,7 +110,7 @@ uno::Sequence< rtl::OUString > SAL_CALL 
     rtl::OUString const aComponentUrl = aLayerUrl + componentToPath(aComponent);
     
     using namespace osl;
-    const sal_uInt32 k_STATUS_FIELDS =  FileStatusMask_Type | FileStatusMask_FileName; 
+    const sal_uInt32 k_STATUS_FIELDS = FileStatusMask_FileName; 
     Directory aComponentDirectory(aComponentUrl);
     DirectoryItem aItem;
     std::vector< rtl::OUString > aResult;
@@ -135,13 +135,12 @@ uno::Sequence< rtl::OUString > SAL_CALL 
                 OSL_TRACE("Reading Component Directory - Error (%u) getting status of directory item.\n", unsigned(errcode));
                 break;
             }
-
-            OSL_ENSURE( aItemDescriptor.isValid(FileStatusMask_Type), "Could not get type of directory item");
-            if (aItemDescriptor.getFileType() != FileStatus::Regular)
-                continue;
                     
             OSL_ENSURE( aItemDescriptor.isValid(FileStatusMask_FileName), "Could not get Name of component found");
             OUString const aFileName = aItemDescriptor.getFileName();
+
+			// It is reasonable to assume a .xcu file is not a directory & =>
+			// not stat each directory entry at considerable cost.
             if (!aFileName.endsWithIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(kLocalDataSuffix)))
                 continue;
 
Index: configmgr/source/misc/filehelper.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/misc/filehelper.cxx,v
retrieving revision 1.17
diff -u -p -u -r1.17 filehelper.cxx
--- configmgr/source/misc/filehelper.cxx	16 Sep 2006 15:15:25 -0000	1.17
+++ configmgr/source/misc/filehelper.cxx	5 Jan 2007 22:25:43 -0000
@@ -146,9 +146,22 @@ namespace configmgr 
 		static const TimeValue k_NullTime = {0,0};		
         sal_uInt64 aSize = 0;
         rModifyTime = k_NullTime;
+		rtl::OUString aURL;
 
-		DirectoryItem aItem;		
-		if (osl::FileBase::E_None == DirectoryItem::get(_sURL, aItem))
+		DirectoryItem aItem;
+
+#ifndef STAT_LOTS_OF_UNUSED_FILES
+		// Statting every file takes way to long - we can use the directory
+		// time-stamp & size instead, if we need to provoke an update
+		// a simple cat > foo; rm foo will do that.
+		// The dir size is (hopefully) non-0 and a good enough proxy value.
+
+		aURL = FileHelper::getParentDir(_sURL);
+#else
+		aURL = _sURL;
+#endif
+
+		if (osl::FileBase::E_None == DirectoryItem::get(aURL, aItem))
 		{
 			FileStatus aStatus(osl_FileStatus_Mask_ModifyTime|osl_FileStatus_Mask_Type|osl_FileStatus_Mask_FileSize);			
 			if (osl::FileBase::E_None == aItem.getFileStatus(aStatus))
Index: configmgr/source/misc/mergechange.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/misc/mergechange.cxx,v
retrieving revision 1.24
diff -u -p -u -r1.24 mergechange.cxx
--- configmgr/source/misc/mergechange.cxx	16 Sep 2006 15:16:11 -0000	1.24
+++ configmgr/source/misc/mergechange.cxx	5 Jan 2007 22:25:43 -0000
@@ -95,7 +95,7 @@ namespace configmgr
     // TODO: check name match
 	void applyUpdateWithAdjustment(TreeChangeList & _anUpdate, memory::UpdateAccessor& _aUpdateAccess, data::NodeAddress const & _aBaseAddress)
     {
-        OSL_ASSERT(_aBaseAddress.is());
+        OSL_ASSERT(_aBaseAddress != NULL);
 
         applyUpdateWithAdjustmentToTree(_anUpdate.root,_aUpdateAccess,_aBaseAddress);
     }
@@ -104,7 +104,7 @@ namespace configmgr
     // TODO: check name match
 	bool adjustUpdate(TreeChangeList & _anUpdate, memory::UpdateAccessor& _aUpdateAccess, data::NodeAddress const & _aBaseAddress)
     {
-        OSL_ASSERT(_aBaseAddress.is());
+        OSL_ASSERT(_aBaseAddress != NULL);
 
         return adjustUpdateToTree(_anUpdate.root,_aUpdateAccess,_aBaseAddress);
     }
Index: configmgr/source/tree/builddata.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/builddata.cxx,v
retrieving revision 1.9.12.1
diff -u -p -u -r1.9.12.1 builddata.cxx
--- configmgr/source/tree/builddata.cxx	3 Nov 2006 11:37:09 -0000	1.9.12.1
+++ configmgr/source/tree/builddata.cxx	5 Jan 2007 22:25:43 -0000
@@ -38,9 +38,6 @@
 
 #include "builddata.hxx"
 
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
-#endif
 #ifndef CONFIGMGR_TREEACCESSOR_HXX
 #include "treeaccessor.hxx"
 #endif
@@ -100,9 +97,7 @@ namespace configmgr
     {
     //-------------------------------------------------------------------------
         using namespace sharable;
-        using memory::Pointer;
         using memory::Accessor;
-        using memory::Allocator;
         using memory::UpdateAccessor;
 //-----------------------------------------------------------------------------
 
@@ -110,20 +105,18 @@ namespace configmgr
     inline
     NodeAddress offsetNodeBy(NodeAddress _aNode, Offset _nOffset)
     {
-        Address aRawAddr = _aNode.addressValue() + _nOffset * sizeof(Node);
-
-        return NodeAddress(Pointer(aRawAddr));
+	sharable::Node *pNode = _aNode;
+	pNode += _nOffset;
+        return NodeAddress(pNode);
     }
 
     static 
     inline
     NodeAddress addressOfNodeAt(TreeAddress _aTree, Offset _nOffset)
     {
-        Address aRawAddr = _aTree.addressValue() + 
-                            offsetof(TreeFragment,nodes) + 
-                            _nOffset * sizeof(Node);
-
-        return NodeAddress(Pointer(aRawAddr));
+        sharable::TreeFragment *pRaw = _aTree;
+//        return NodeAddress( (memory::Address)( pRaw->nodes + _nOffset ));
+	return &pRaw->nodes[_nOffset];
     }
 
 //-----------------------------------------------------------------------------
@@ -152,7 +145,7 @@ namespace configmgr
         Offset  startGroup( Name _aName, Flags::Field _aFlags ); 
         void    endGroup( Offset _nPos ); 
 
-        void    addSet( Name _aName, Flags::Field _aFlags, Address _aElementType ); 
+        void    addSet( Name _aName, Flags::Field _aFlags, SetElementAddress _aElementType ); 
 
         void    addValue( Name _aName, Flags::Field _aFlags, 
                             AnyData::TypeCode _aValueType, 
@@ -163,7 +156,7 @@ namespace configmgr
         class LinkSetNodes;
 
     private: 
-        TreeAddress allocTreeFragment(UpdateAccessor & _anUpdater);
+	TreeAddress allocTreeFragment();
         void linkTreeFragment(UpdateAccessor & _anUpdater, TreeAddress _aTreeAddr);
 
         Offset addNode(Name _aName, Flags::Field _aFlags, Type::Field _aType);
@@ -178,7 +171,8 @@ namespace configmgr
     public:
         explicit
         CollectSetElements(UpdateAccessor & _anUpdater)
-        : m_updater(_anUpdater)
+            : m_updater(_anUpdater)
+            , m_head(NULL)
         {
         }
 
@@ -198,7 +192,7 @@ namespace configmgr
         explicit
         LinkSetNodes(UpdateAccessor & _anUpdater)
         : m_updater(_anUpdater)
-        , m_aParentAddr()
+        , m_aParentAddr(NULL)
         {
         }
 
@@ -228,7 +222,6 @@ namespace configmgr
         TreeNodeBuilder&    builder()         { return m_builder; }
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
         TreeNodeBuilder     m_builder;
@@ -253,7 +246,7 @@ namespace configmgr
         virtual void handle(ISubtree  const & _aNode);
         virtual void handle(OValueNode const & _aNode);
 
-        Address makeTemplateData(rtl::OUString const & _aTemplateName, rtl::OUString const & _aTemplateModule);
+        SetElementAddress makeTemplateData(rtl::OUString const & _aTemplateName, rtl::OUString const & _aTemplateModule);
 
         Name allocName(INode const & _aNode);
         State::Field makeState(node::Attributes const & _aAttributes);
@@ -275,7 +268,7 @@ namespace configmgr
         , m_bWithDefaults()
         {}
 
-        List buildElementList(ISubtree const & _aSet, bool _bWithDefaults);
+        TreeFragment *buildElementList(ISubtree const & _aSet, bool _bWithDefaults);
     private:
         void handleNode(INode const & _aSourceNode);
 
@@ -304,7 +297,7 @@ namespace configmgr
         Result handle(GroupNodeAccess const & _aNode);
         Result handle(SetNodeAccess const & _aNode);
 
-        Address makeTemplateData(Address _aSourceTemplate);
+        SetElementAddress makeTemplateData(SetElementAddress _aSourceTemplate);
     };
 //-----------------------------------------------------------------------------
 
@@ -399,7 +392,6 @@ namespace configmgr
     protected:
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
     };
@@ -427,7 +419,6 @@ namespace configmgr
     private:
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
     };
@@ -493,25 +484,25 @@ std::auto_ptr<INode> convertTree(TreeAcc
 inline 
 void TreeNodeBuilder::CollectSetElements::resetElementList()
 {
-    OSL_ENSURE(m_head.isNull(), "Joining to a element list that was forgotten");
+    OSL_ENSURE(m_head == NULL, "Joining to a element list that was forgotten");
 }
 //-----------------------------------------------------------------------------
 
 inline 
 List TreeNodeBuilder::CollectSetElements::getElementListAndClear()
 {
-    List aResult = m_head.addressValue();
-    m_head = TreeAddress();
+    List aResult = m_head;
+    m_head = NULL;
     return aResult;
 }
 //-----------------------------------------------------------------------------
 
 void TreeNodeBuilder::CollectSetElements::addElement(TreeAddress _aNewElement)
 {
-    if (TreeFragment * pNewFragment = TreeAccessor::access(_aNewElement,m_updater))
+    if (TreeFragment * pNewFragment = _aNewElement)
     {
         pNewFragment->header.parent = 0; // data not available here
-        pNewFragment->header.next   = m_head.addressValue();
+        pNewFragment->header.next   = m_head;
 
         m_head = _aNewElement;
     }
@@ -528,7 +519,7 @@ NodeVisitor::Result TreeNodeBuilder::Lin
     TreeFragment const & rTreeData = aTreeAccess.data();
 
     NodeAddress aOldParent = m_aParentAddr;
-    m_aParentAddr = NodeAddress();
+    m_aParentAddr = NULL;
 
     Result eResult = CONTINUE;
 
@@ -549,12 +540,12 @@ NodeVisitor::Result TreeNodeBuilder::Lin
 
 NodeVisitor::Result TreeNodeBuilder::LinkSetNodes::linkSet(SetNodeAccess const & _aSet)
 {
-    OSL_ENSURE(m_aParentAddr.isNull(),"Linking set data already in progress");
-    m_aParentAddr = _aSet.address();
+    OSL_ENSURE(m_aParentAddr == NULL,"Linking set data already in progress");
+    m_aParentAddr = _aSet;
 
     Result aResult = this->visitElements(_aSet);
 
-    m_aParentAddr = NodeAddress();
+    m_aParentAddr = NULL;
 
     return aResult;
 }
@@ -562,11 +553,12 @@ NodeVisitor::Result TreeNodeBuilder::Lin
 
 NodeVisitor::Result TreeNodeBuilder::LinkSetNodes::handle(TreeAccessor const & _aSourceTree)
 {
-    OSL_ENSURE(m_aParentAddr.is(),"Cannot link set element without parent address");
+    OSL_ENSURE(m_aParentAddr != NULL,"Cannot link set element without parent address");
 
-    TreeFragment * pFragment = _aSourceTree.access(_aSourceTree.address(), m_updater);
+    //    TreeFragment * pFragment = _aSourceTree;
 
-    pFragment->header.parent = m_aParentAddr.addressValue();
+    //    pFragment->header.parent = m_aParentAddr;
+    _aSourceTree->header.parent = m_aParentAddr;
 
     return CONTINUE;
 }
@@ -638,25 +630,15 @@ void TreeNodeBuilder::resetTreeFragment(
 }
 //-----------------------------------------------------------------------------
 
-TreeAddress TreeNodeBuilder::allocTreeFragment(UpdateAccessor & _anUpdater)
+TreeAddress TreeNodeBuilder::allocTreeFragment()
 {
     OSL_ENSURE(m_nodes.size() == m_header.count, "TreeNodeBuilder: node count mismatch");
 
-    sal_uInt32 const nFragmentSize = sizeof(TreeFragment) + (m_header.count-1)*sizeof(Node);
-
-    OSL_ASSERT(nFragmentSize >= sizeof m_header + m_header.count*sizeof(Node));
-
-    Address aBaseAddress = _anUpdater.allocator().allocate(nFragmentSize);
+    TreeFragment *pFragment = TreeFragment::allocate(m_header.count);
+    pFragment->header = m_header;
+    std::copy(m_nodes.begin(),m_nodes.end(),pFragment->nodes);
 
-    TreeAddress aResult = TreeAddress( memory::Pointer(aBaseAddress) );
-
-    if (TreeFragment * pFragment = TreeAccessor::access(aResult,_anUpdater))
-    {
-        pFragment->header = m_header;
-        std::copy(m_nodes.begin(),m_nodes.end(),pFragment->nodes);
-    }
-    
-    return aResult;
+    return TreeAddress( pFragment );
 }
 //-----------------------------------------------------------------------------
 
@@ -668,9 +650,9 @@ void TreeNodeBuilder::linkTreeFragment(U
 
 TreeAddress TreeNodeBuilder::createTreeFragment(UpdateAccessor & _anUpdater)
 {
-    TreeAddress aResult = allocTreeFragment(_anUpdater);
+    TreeAddress aResult = allocTreeFragment();
 
-    if (aResult.is())
+    if (aResult != NULL)
     {
         linkTreeFragment(_anUpdater,aResult);
 
@@ -708,7 +690,7 @@ void TreeNodeBuilder::endGroup( Offset _
 }
 //-----------------------------------------------------------------------------
 
-void TreeNodeBuilder::addSet( Name _aName, Flags::Field _aFlags, Address _aElementType ) 
+void TreeNodeBuilder::addSet( Name _aName, Flags::Field _aFlags, SetElementAddress _aElementType ) 
 {
     addNode(_aName,_aFlags,Type::nodetype_set);
 
@@ -739,7 +721,7 @@ void TreeNodeBuilder::addValue( Name _aN
 TreeAddress CopyingDataTreeBuilder::buildTree(TreeAccessor const & _aSourceTree)
 {
     OSL_ENSURE(_aSourceTree.isValid(), "Trying to build a tree from  NULL data");
-    if (!_aSourceTree.isValid()) return TreeAddress();
+    if (!_aSourceTree.isValid()) return NULL;
 
     TreeFragment const & aSrc = _aSourceTree.data();
 
@@ -763,12 +745,12 @@ NodeVisitor::Result CopyingDataTreeBuild
 
     AnyData aNewValue, aNewDefault;
     if (aFlags & Flags::valueAvailable)   
-        aNewValue = allocData(allocator(), aType, aSrc.getUserValue(_aNode.accessor()));
+        aNewValue = allocData(aType, aSrc.getUserValue());
     else
         aNewValue.data = 0;
 
     if (aFlags & Flags::defaultAvailable)   
-        aNewDefault = allocData(allocator(), aType, aSrc.getDefaultValue(_aNode.accessor()));
+        aNewDefault = allocData(aType, aSrc.getDefaultValue());
     else
         aNewDefault.data = 0;
     
@@ -799,7 +781,7 @@ NodeVisitor::Result CopyingDataTreeBuild
 
     sharable::Name aNodeName = allocName( aSrc.info.getName());
     Flags::Field aFlags = aSrc.info.flags;
-    Address aTemplate = this->makeTemplateData(aSrc.elementType);
+    SetElementAddress aTemplate = this->makeTemplateData(aSrc.elementType);
     
     this->builder().addSet(aNodeName,aFlags,aTemplate);
 
@@ -812,9 +794,9 @@ NodeVisitor::Result CopyingDataTreeBuild
 }
 //-----------------------------------------------------------------------------
         
-Address CopyingDataTreeBuilder::makeTemplateData(Address _aSourceTemplate)
+SetElementAddress CopyingDataTreeBuilder::makeTemplateData(SetElementAddress _aSourceTemplate)
 {
-    return SetNode::copyTemplateData(allocator(), _aSourceTemplate);
+    return SetNode::copyTemplateData(_aSourceTemplate);
 }
 //-----------------------------------------------------------------------------
 
@@ -892,7 +874,8 @@ void ConvertingDataTreeBuilder::handle(I
 
     if (_aNode.isSetNode())
     {
-        Address aTemplate = this->makeTemplateData(_aNode.getElementTemplateName(),_aNode.getElementTemplateModule());
+        SetElementAddress aTemplate = this->makeTemplateData(_aNode.getElementTemplateName(),
+							     _aNode.getElementTemplateModule());
     
         this->builder().addSet(aNodeName,aFlags,aTemplate);
 
@@ -927,7 +910,7 @@ void ConvertingDataTreeBuilder::handle(O
         uno::Any aValue = _aNode.getValue();
         if (aValue.hasValue())
         {
-            aNewValue = allocData(allocator(), aType, aValue);
+            aNewValue = allocData(aType, aValue);
             aFlags |= Flags::valueAvailable;
         }
     }
@@ -937,7 +920,7 @@ void ConvertingDataTreeBuilder::handle(O
         uno::Any aDefault = _aNode.getDefault();
         if (aDefault.hasValue())
         {
-            aNewDefault = allocData(allocator(), aType, aDefault);
+            aNewDefault = allocData(aType, aDefault);
             aFlags |= Flags::defaultAvailable;
         }
     }
@@ -1002,9 +985,9 @@ Flags::Field ConvertingDataTreeBuilder::
 }
 //-----------------------------------------------------------------------------
 
-Address ConvertingDataTreeBuilder::makeTemplateData(rtl::OUString const & _aTemplateName, rtl::OUString const & _aTemplateModule)
+SetElementAddress ConvertingDataTreeBuilder::makeTemplateData(rtl::OUString const & _aTemplateName, rtl::OUString const & _aTemplateModule)
 {
-    return SetNode::allocTemplateData(allocator(), _aTemplateName, _aTemplateModule );
+    return SetNode::allocTemplateData(_aTemplateName, _aTemplateModule );
 }
 //-----------------------------------------------------------------------------
 
@@ -1188,9 +1171,9 @@ void DataTreeDefaultMerger::handle(OValu
 
 TreeAddress DataTreeCleanup::destroyTree(TreeAddress _aBaseAddress)
 {
-    TreeFragment * pData = TreeAccessor::access(_aBaseAddress,updater());
+    TreeFragment *pData = _aBaseAddress;
 
-    List aNext = pData->header.next;
+    TreeFragment *pNext = pData->header.next;
 
     Offset const nCount = pData->header.count;
 
@@ -1201,15 +1184,15 @@ TreeAddress DataTreeCleanup::destroyTree
         destroyNode( addressOfNodeAt(_aBaseAddress,i) );
     }
 
-    allocator().deallocate( _aBaseAddress.addressValue() );
+    TreeFragment::free_shallow( pData );
 
-    return TreeAddress( Pointer(aNext) );
+    return TreeAddress( pNext );
 }
 //-----------------------------------------------------------------------------
 
 void DataTreeCleanup::destroyNode(NodeAddress _aNodeAddress)
 {
-    Node * pNode = NodeAccess::access(_aNodeAddress,updater());
+    Node * pNode = _aNodeAddress;
 
     Type::Field aTypeTag = pNode->node.info.type;
     switch ( aTypeTag & Type::mask_nodetype )
@@ -1250,16 +1233,16 @@ void DataTreeCleanup::destroyData(NodeIn
 
 void DataTreeCleanup::destroyData(sharable::SetNode * _pNode)
 {
-    TreeAddress aElement( Pointer( _pNode->elements ) );
+    TreeAddress aElement( _pNode->elements );
 
-    Address aTemplate = _pNode->elementType;;
+    SetElementAddress aTemplate = _pNode->elementType;;
 
     destroyData(&_pNode->info);
 
-    while (aElement.is())
+    while (aElement != NULL)
         aElement = destroyTree(aElement);
 
-    SetNode::releaseTemplateData( allocator(), aTemplate );
+    SetNode::releaseTemplateData( aTemplate );
 }
 //-----------------------------------------------------------------------------
 	
@@ -1278,10 +1261,10 @@ void DataTreeCleanup::destroyData(sharab
     destroyData(&_pNode->info);
 
     if (aFlags & Flags::valueAvailable) 
-        freeData( allocator(), aValueType, _pNode->value );
+        freeData( aValueType, _pNode->value );
 
     if (aFlags & Flags::defaultAvailable) 
-        freeData( allocator(), aValueType, _pNode->defaultValue );
+        freeData( aValueType, _pNode->defaultValue );
     
 }
 //-----------------------------------------------------------------------------
Index: configmgr/source/tree/changes.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/changes.cxx,v
retrieving revision 1.19
diff -u -p -u -r1.19 changes.cxx
--- configmgr/source/tree/changes.cxx	16 Sep 2006 15:20:06 -0000	1.19
+++ configmgr/source/tree/changes.cxx	5 Jan 2007 22:25:44 -0000
@@ -259,7 +259,7 @@ AddNode::AddNode(TreeSegment const & _aA
 	:Change(_rName,_bToDefault)
 	,m_aOwnNewNode(_aAddedTree)
 	,m_aOwnOldNode()
-	,m_aInsertedTree()
+	,m_aInsertedTree(NULL)
 	,m_bReplacing(false)
 {
 }
@@ -288,7 +288,7 @@ std::auto_ptr<Change> AddNode::clone() c
 //--------------------------------------------------------------------------
 void AddNode::setInsertedAddress(data::TreeAddress const & _aInsertedTree)	
 {  
-    OSL_ENSURE( !m_aInsertedTree.is(), "AddNode already was applied - inserted a second time ?");
+    OSL_ENSURE( m_aInsertedTree == NULL, "AddNode already was applied - inserted a second time ?");
     m_aInsertedTree = _aInsertedTree;
 }
 //--------------------------------------------------------------------------
Index: configmgr/source/tree/cmtree.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/cmtree.cxx,v
retrieving revision 1.37.12.1
diff -u -p -u -r1.37.12.1 cmtree.cxx
--- configmgr/source/tree/cmtree.cxx	3 Nov 2006 11:37:26 -0000	1.37.12.1
+++ configmgr/source/tree/cmtree.cxx	5 Jan 2007 22:25:44 -0000
@@ -253,7 +253,7 @@ namespace configmgr
 		{
 			INode* pINode = *it2;
 			OUString aName2 = pINode->getName();
-			volatile int dummy;
+			volatile int dummy = 0;
             dummy = 0;
 		}
 #endif
Index: configmgr/source/tree/groupnodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/groupnodeaccess.cxx,v
retrieving revision 1.6.12.1
diff -u -p -u -r1.6.12.1 groupnodeaccess.cxx
--- configmgr/source/tree/groupnodeaccess.cxx	3 Nov 2006 11:37:40 -0000	1.6.12.1
+++ configmgr/source/tree/groupnodeaccess.cxx	5 Jan 2007 22:25:44 -0000
@@ -50,23 +50,13 @@ namespace configmgr
     namespace data
     {
     // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
 
-        Pointer GroupNodeAccess::check(Accessor const& _aAccessor, sharable::GroupNode const* pInnerNode)
+        GroupNodeAddress GroupNodeAccess::check(NodeAccessRef const& _aNode)
         {
-            return _aAccessor.address(pInnerNode);      
-        }
-    // -------------------------------------------------------------------------
-
-        Pointer GroupNodeAccess::check(NodeAccessRef const& _aNode)
-        {
-            if (sharable::Node const* pNode = _aNode.getDataPtr())
-                return check(_aNode.accessor(), pNode->groupData());
-
+            if (sharable::Node const* pNode = _aNode)
+                return const_cast<GroupNodeAddress>(pNode->groupData());
             else
-                return Pointer();
+                return NULL;
         }
     // -------------------------------------------------------------------------
         bool GroupNodeAccess::hasChildren() const
@@ -76,21 +66,61 @@ namespace configmgr
             return aNode.numDescendants > 0 ? true:false;
         }
 
-
     // -------------------------------------------------------------------------
 
+        GroupNodeAccess::~GroupNodeAccess()
+        {
+            fprintf (stderr, "~GroupNodeAccess %p\n", this);
+        }
+
         NodeAddress GroupNodeAccess::implGetChild(Name const& _aName) const
         {
             using namespace sharable;
+            rtl::OUString aNodeName = _aName.toString();
+            fprintf (stderr, "implGetChild %p '%s' ", this,
+                     rtl::OUStringToOString(aNodeName,
+                                            RTL_TEXTENCODING_UTF8).getStr());
+            fprintf (stderr, "cache '%s'\n",
+                     m_pCache ? rtl::OUStringToOString(m_pCache->getName(),
+                                                       RTL_TEXTENCODING_UTF8).getStr()
+                     : "<null>");
+
             GroupNode const  & aNode = data();
+#warning Abhortive cache here needs removing ...        
+#if 0
+            if (m_pCache)
+            {
+                fprintf (stderr, "\t compare '%s'\n",
+                         rtl::OUStringToOString(m_pCache->getName(),
+                                                RTL_TEXTENCODING_UTF8).getStr());
+                if (m_pCache->isNamed(aNodeName))
+                    return NodeAccessRef(&m_aAccessor, m_pCache);
+
+                m_pCache = aNode.getNextChild(m_pCache);
+
+                if (m_pCache && m_pCache->isNamed(aNodeName))
+                {
+                    fprintf (stderr, "\t compare '%s'\n",
+                             rtl::OUStringToOString(m_pCache->getName(),
+                                                    RTL_TEXTENCODING_UTF8).getStr());
+                    return NodeAccessRef(&m_aAccessor, m_pCache);
+                }
+                m_pCache = NULL;
+            }
+#endif
+
             for (Node const * pChild = aNode.getFirstChild();
                               pChild != NULL;
                               pChild = aNode.getNextChild(pChild))
             {
-                if (pChild->isNamed(_aName.toString()))
+                fprintf (stderr, "\t compare '%s'\n",
+                         rtl::OUStringToOString(pChild->getName(),
+                                                RTL_TEXTENCODING_UTF8).getStr());
+                if (pChild->isNamed(aNodeName))
                 {
                     NodeAccessRef aChildNode(&m_aAccessor,pChild);
-                    return aChildNode.address();
+                    m_pCache = pChild;
+                    return aChildNode;
                 }            
             }
             return NodeAddress();
Index: configmgr/source/tree/makefile.mk
===================================================================
RCS file: /cvs/util/configmgr/source/tree/makefile.mk,v
retrieving revision 1.11
diff -u -p -u -r1.11 makefile.mk
--- configmgr/source/tree/makefile.mk	8 Mar 2006 14:01:27 -0000	1.11
+++ configmgr/source/tree/makefile.mk	5 Jan 2007 22:25:44 -0000
@@ -57,7 +57,6 @@ SLOFILES=\
 	$(SLO)$/treesegment.obj		\
 	$(SLO)$/nodevisitor.obj		\
 	$(SLO)$/nodeaccess.obj		\
-	$(SLO)$/treeaccessor.obj	\
 	$(SLO)$/valuenodeaccess.obj	\
 	$(SLO)$/groupnodeaccess.obj	\
 	$(SLO)$/setnodeaccess.obj	\
Index: configmgr/source/tree/node.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/node.cxx,v
retrieving revision 1.8.12.1
diff -u -p -u -r1.8.12.1 node.cxx
--- configmgr/source/tree/node.cxx	3 Nov 2006 11:37:53 -0000	1.8.12.1
+++ configmgr/source/tree/node.cxx	5 Jan 2007 22:25:44 -0000
@@ -226,68 +226,55 @@ struct SetNodeTemplateData 
 };
 //-----------------------------------------------------------------------------
 static inline
-SetNodeTemplateData * readTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData)
+SetNodeTemplateData * readTemplateData(SetElementAddress _aTemplateData)
 {
-    return static_cast<SetNodeTemplateData *>( _anAllocator.access(_aTemplateData) );
-}
-//-----------------------------------------------------------------------------
-static inline
-SetNodeTemplateData const * readTemplateData(memory::Accessor const & _anAccessor, Address _aTemplateData)
-{
-    return static_cast<SetNodeTemplateData const*>( _anAccessor.access(memory::Pointer(_aTemplateData)) );
+    return reinterpret_cast<SetNodeTemplateData *>( _aTemplateData );
 }
 //-----------------------------------------------------------------------------
 
-Address SetNode::allocTemplateData(memory::Allocator const & _anAllocator,
-								   const rtl::OUString &rName,
+SetElementAddress SetNode::allocTemplateData(const rtl::OUString &rName,
 								   const rtl::OUString &rModule)
 {
-    Address aData = _anAllocator.allocate(sizeof(SetNodeTemplateData));
+    SetNodeTemplateData * pData = new SetNodeTemplateData();
 
-    if (aData)
-    {
-        SetNodeTemplateData * pData = readTemplateData(_anAllocator,aData);
-
-        OSL_ENSURE(pData, "Creating template data: unexpected NULL data");
+    OSL_ENSURE(pData, "Creating template data: unexpected NULL data");
     
-        pData->name   = allocName(rName);
-        pData->module = allocName(rModule);
-    }
-    return aData;
+    pData->name   = allocName(rName);
+    pData->module = allocName(rModule);
+
+    return reinterpret_cast<SetElementAddress>( pData );
 }
 
-Address SetNode::copyTemplateData(memory::Allocator const & _anAllocator, 
-								  Address _aTemplateData)
+SetElementAddress SetNode::copyTemplateData(SetElementAddress _aTemplateData)
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAllocator,_aTemplateData);
+    SetNodeTemplateData const * pData = readTemplateData(_aTemplateData);
 
     OSL_ENSURE(pData, "Copying template data: unexpected NULL data");
 
-    return allocTemplateData(_anAllocator, readName(pData->name),
-							 readName(pData->module));
+    return allocTemplateData(readName(pData->name), readName(pData->module));
 }
 
 //-----------------------------------------------------------------------------
 
-void SetNode::releaseTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData)
+void SetNode::releaseTemplateData(SetElementAddress _aTemplateData)
 {
     if (!_aTemplateData) return;
 
-    SetNodeTemplateData const * pData = readTemplateData(_anAllocator,_aTemplateData);
+    SetNodeTemplateData const * pData = readTemplateData(_aTemplateData);
 
     OSL_ENSURE(pData, "Freeing template data: unexpected NULL data");
     
     freeName(pData->name);
     freeName(pData->module);
 
-    _anAllocator.deallocate(_aTemplateData);
+    delete pData;
 }
 
 //-----------------------------------------------------------------------------
 
-rtl::OUString SetNode::getElementTemplateName(memory::Accessor const & _anAccessor)   const
+rtl::OUString SetNode::getElementTemplateName() const
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAccessor,this->elementType);
+    SetNodeTemplateData const * pData = readTemplateData(this->elementType);
 
     OSL_ENSURE(pData, "ERROR: No template data found for set");
     
@@ -295,9 +282,9 @@ rtl::OUString SetNode::getElementTemplat
 }
 //-----------------------------------------------------------------------------
 
-rtl::OUString SetNode::getElementTemplateModule(memory::Accessor const & _anAccessor) const
+rtl::OUString SetNode::getElementTemplateModule() const
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAccessor,this->elementType);
+    SetNodeTemplateData const * pData = readTemplateData(this->elementType);
 
     OSL_ENSURE(pData, "ERROR: No template data found for set");
     
@@ -306,25 +293,25 @@ rtl::OUString SetNode::getElementTemplat
 //-----------------------------------------------------------------------------
 
 static inline
-TreeFragment const * implGetFragmentFromList(memory::Accessor const & _anAccessor, List _aListEntry)
+TreeFragment const * implGetFragmentFromList(List _aListEntry)
 {
-    return static_cast<TreeFragment const *>(_anAccessor.access(memory::Pointer(_aListEntry)));
+    return reinterpret_cast<TreeFragment const *>(_aListEntry);
 }
 //-----------------------------------------------------------------------------
 
-TreeFragment const  * SetNode::getFirstElement(memory::Accessor const & _anAccessor) const   
+TreeFragment const  * SetNode::getFirstElement() const   
 {
-    return implGetFragmentFromList(_anAccessor, this->elements);
+    return implGetFragmentFromList(this->elements);
 }
 //-----------------------------------------------------------------------------
 
-TreeFragment const  * SetNode::getNextElement(memory::Accessor const & _anAccessor, TreeFragment const * _pElement) const    
+TreeFragment const  * SetNode::getNextElement(TreeFragment const * _pElement) const    
 {
     OSL_PRECOND(_pElement, "getNextElement: previous element must not be NULL");
-    OSL_PRECOND(_pElement->header.parent == _anAccessor.address(this).value(), 
+    OSL_PRECOND(_pElement->header.parent == (Node *)this, 
                 "getNextElement: not an element of this node");
 
-    return implGetFragmentFromList(_anAccessor, _pElement->header.next);
+    return implGetFragmentFromList(_pElement->header.next);
 }
 //-----------------------------------------------------------------------------
 
@@ -353,7 +340,7 @@ bool ValueNode::hasUsableDefault() const
 }
 //-----------------------------------------------------------------------------
 	
-uno::Type   ValueNode::getValueType()  const
+uno::Type   ValueNode::getValueType() const
 {
     AnyData::TypeCode aType = AnyData::TypeCode( info.type & Type::mask_valuetype );
 
@@ -361,36 +348,36 @@ uno::Type   ValueNode::getValueType()  c
 }
 //-----------------------------------------------------------------------------
 
-uno::Any    ValueNode::getValue(memory::Accessor const & _aAccessor)      const
+uno::Any    ValueNode::getValue() const
 {
     if (info.flags & Flags::defaulted) 
-        return getDefaultValue(_aAccessor);
+        return getDefaultValue();
 
     else
-        return getUserValue(_aAccessor);
+        return getUserValue();
 }
 //-----------------------------------------------------------------------------
 
-uno::Any    ValueNode::getUserValue(memory::Accessor const & _aAccessor)      const
+uno::Any ValueNode::getUserValue() const
 {
     if (info.flags & Flags::valueAvailable)
     {
         AnyData::TypeCode aType = AnyData::TypeCode( info.type & Type::mask_valuetype );
 
-        return readData(_aAccessor,aType,this->value);
+        return readData(aType,this->value);
     }
     else
         return uno::Any();
 }
 //-----------------------------------------------------------------------------
 
-uno::Any    ValueNode::getDefaultValue(memory::Accessor const & _aAccessor)    const
+uno::Any ValueNode::getDefaultValue() const
 {
     if (info.flags & Flags::defaultAvailable)
     {
         AnyData::TypeCode aType = AnyData::TypeCode( info.type & Type::mask_valuetype );
 
-        return readData(_aAccessor,aType,this->defaultValue);
+        return readData(aType,this->defaultValue);
     }
     else
         return uno::Any();
Index: configmgr/source/tree/nodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/nodeaccess.cxx,v
retrieving revision 1.4
diff -u -p -u -r1.4 nodeaccess.cxx
--- configmgr/source/tree/nodeaccess.cxx	16 Sep 2006 15:21:45 -0000	1.4
+++ configmgr/source/tree/nodeaccess.cxx	5 Jan 2007 22:25:44 -0000
@@ -66,13 +66,7 @@ namespace configmgr
 // -----------------------------------------------------------------------------	
     namespace data
     {
-    // -------------------------------------------------------------------------
-        
-        NodeAddress::DataType* NodeAccess::access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor& _rUpdateAccess)
-        { 
-            return static_cast<NodeAddress::DataType*>(_rUpdateAccess.access(_aNodeRef.m_pData)); 
-        }
-    // -------------------------------------------------------------------------
+        // -------------------------------------------------------------------------
 
         NodeAccess getSubnode(NodeAccessRef const & _aParent, NodeAccess::Name const & _aName)
         {
@@ -92,62 +86,28 @@ namespace configmgr
                 return NodeAccess::emptyNode();
             }
         }
-    // -------------------------------------------------------------------------
-
-        NodeAddress getSubnodeAddress(memory::Accessor const& _aAccess, NodeAddress const & _aNodeAddress, NodeAccess::Name const & _aName)
-        {
-            return getSubnode( NodeAccessRef(&_aAccess,_aNodeAddress), _aName ).address();
-        }
-    // -------------------------------------------------------------------------
+        // -------------------------------------------------------------------------
 
         NodeAddress getSubnodeAddress(memory::UpdateAccessor& _aAccess, NodeAddress const & _aNodeAddress, NodeAccess::Name const & _aName)
         {
             memory::Accessor aAccess = _aAccess.accessor();
-            return getSubnode( NodeAccessRef(&aAccess,_aNodeAddress), _aName ).address();
+            return getSubnode( NodeAccessRef(&aAccess,_aNodeAddress), _aName );
         }
-    // -------------------------------------------------------------------------
-    
-        SetNodeAddress toSetNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr)
-        {
-            SetNodeAccess aNodeAccess( NodeAccessRef(&_aAccess,_aNodeAddr) );
-            return aNodeAccess.address();
-        }
-    // -------------------------------------------------------------------------
+        // -------------------------------------------------------------------------
      
         SetNodeAddress toSetNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr)
         {
             SetNodeAccess aNodeAccess( NodeAccess(_aAccess.accessor(),_aNodeAddr) );
-            return aNodeAccess.address();
+            return aNodeAccess;
         }
-    // -------------------------------------------------------------------------
-
-        GroupNodeAddress toGroupNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr)
-        {
-            GroupNodeAccess aNodeAccess( NodeAccess(_aAccess,_aNodeAddr) );
-            return aNodeAccess.address();
-        }
-    // -------------------------------------------------------------------------
+        // -------------------------------------------------------------------------
 
         GroupNodeAddress toGroupNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr)
         {
             GroupNodeAccess aNodeAccess( NodeAccess(_aAccess.accessor(),_aNodeAddr) );
-            return aNodeAccess.address();
-        }
-    // -------------------------------------------------------------------------
-        
-        ValueNodeAddress toValueNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr)
-        {
-            ValueNodeAccess aNodeAccess( NodeAccess(_aAccess,_aNodeAddr) );
-            return aNodeAccess.address();
-        }
-    // -------------------------------------------------------------------------
-        
-        ValueNodeAddress toValueNodeAddress(memory::UpdateAccessor & _aAccess, NodeAddress const & _aNodeAddr)
-        {
-            ValueNodeAccess aNodeAccess( NodeAccess(_aAccess.accessor(),_aNodeAddr) );
-            return aNodeAccess.address();
+            return aNodeAccess;
         }
-    // -------------------------------------------------------------------------
+        // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------	
 } // namespace configmgr
Index: configmgr/source/tree/nodevisitor.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/nodevisitor.cxx,v
retrieving revision 1.6
diff -u -p -u -r1.6 nodevisitor.cxx
--- configmgr/source/tree/nodevisitor.cxx	16 Sep 2006 15:22:12 -0000	1.6
+++ configmgr/source/tree/nodevisitor.cxx	5 Jan 2007 22:25:44 -0000
@@ -108,7 +108,7 @@ typedef NodeVisitor::Result Result;
         void applyToTree(sharable::TreeFragment const & _aElement);
         void applyToElements(sharable::SetNode const & _aNode);
 
-	    Result dispatch(sharable::TreeFragment const& _aElement);
+	Result dispatch(sharable::TreeFragment const & _aElement);
     };
 
     // -------------------------------------------------------------------------
@@ -138,7 +138,9 @@ typedef NodeVisitor::Result Result;
     inline
     Result SetVisitor::Dispatcher::dispatch(sharable::TreeFragment const& _aElement)
     {
-        return m_target.handle( TreeAccessor(m_accessor, &_aElement) );
+        return m_target.handle
+	  (TreeAccessor(m_accessor,
+			(sharable::TreeFragment *)(& _aElement )));
     }
     // -------------------------------------------------------------------------
 
@@ -169,9 +171,9 @@ typedef NodeVisitor::Result Result;
     void SetVisitor::Dispatcher::applyToElements(sharable::SetNode const & _aNode)
     {
         using sharable::TreeFragment;
-        for (TreeFragment const * pElement = _aNode.getFirstElement(m_accessor);
+        for (TreeFragment const * pElement = _aNode.getFirstElement();
                 pElement != NULL && m_result != NodeVisitor::DONE;
-                pElement = _aNode.getNextElement(m_accessor,pElement) )
+                pElement = _aNode.getNextElement(pElement) )
             m_result = dispatch(*pElement);
 
     }
Index: configmgr/source/tree/setnodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/setnodeaccess.cxx,v
retrieving revision 1.5.12.1
diff -u -p -u -r1.5.12.1 setnodeaccess.cxx
--- configmgr/source/tree/setnodeaccess.cxx	3 Nov 2006 11:38:06 -0000	1.5.12.1
+++ configmgr/source/tree/setnodeaccess.cxx	5 Jan 2007 22:25:44 -0000
@@ -56,23 +56,12 @@ namespace configmgr
 // -----------------------------------------------------------------------------	
     namespace data
     {
-    // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-        Pointer SetNodeAccess::check(Accessor const& _aAccessor, sharable::SetNode const* pInnerNode)
+        SetNodeAddress SetNodeAccess::check(NodeAccessRef const& _aNode)
         {
-            return _aAccessor.address(pInnerNode);      
-        }
-    // -------------------------------------------------------------------------
-
-        Pointer SetNodeAccess::check(NodeAccessRef const& _aNode)
-        {
-            if (sharable::Node const* pNode = _aNode.getDataPtr())
-                return check(_aNode.accessor(),pNode->setData());
-
+            if (sharable::Node const* pNode = _aNode)
+                return const_cast<SetNodeAddress>(pNode->setData());
             else
-                return Pointer();
+                return NULL;
         }
     // -------------------------------------------------------------------------
     
@@ -80,55 +69,51 @@ namespace configmgr
         {
             using namespace sharable;
             SetNode const  & aNode = data();
-            for (TreeFragment const * pElement = aNode.getFirstElement(m_aAccessor);
-                       pElement  != NULL;
-                       pElement  = aNode.getNextElement(m_aAccessor, pElement))
+            for (TreeFragment const * pElement = aNode.getFirstElement();
+                 pElement  != NULL;
+                 pElement  = aNode.getNextElement(pElement))
             {
                 if (pElement->isNamed(_aName.toString()))
-                {
-                    TreeAccessor aElementTree(m_aAccessor,pElement);
-                    return aElementTree.address();
-                }            
+                    return (TreeAddress)pElement;
             }
-            return TreeAddress();
+            return NULL;
         }
     // -------------------------------------------------------------------------*/
         
-        void SetNodeAccess::addElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, ElementAddress _aNewElement)
+        void SetNodeAccess::addElement(SetNodeAddress _aSetAddress,
+				       ElementAddress _aNewElement)
         {
             using namespace sharable;
 
-            SetNode * pNode = static_cast<SetNode *>( _aAccessor.access( _aSetAddress.m_pData) );
+            SetNode * pNode = _aSetAddress;
             OSL_ENSURE(pNode, "ERROR: Trying to add an element to a NULL set node");
 
             // To do (?): insert sorted - find location here
-            TreeFragment * pElement = TreeAccessor::access(_aNewElement, _aAccessor);
+            TreeFragment * pElement = _aNewElement;
             OSL_ENSURE(pElement, "ERROR: Trying to add a NULL element to a set node");
 
             pElement->header.next   = pNode->elements;
-            pElement->header.parent = _aSetAddress.m_pData.value();
+            pElement->header.parent = reinterpret_cast<Node *>(pNode);
 
-            pNode->elements = _aNewElement.addressValue();
+            pNode->elements = _aNewElement;
         }
     // -------------------------------------------------------------------------*/
         
-        TreeAddress SetNodeAccess::removeElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, Name const & _aName)
+        TreeAddress SetNodeAccess::removeElement(SetNodeAddress _aSetAddress, Name const & _aName)
         {
             using namespace sharable;
-            using memory::Pointer;
             
-            SetNode * pNode = static_cast<SetNode *>( _aAccessor.access( _aSetAddress.m_pData) );
+            SetNode * pNode = _aSetAddress;
             OSL_ENSURE(pNode, "ERROR: Trying to add an element to a NULL set node");
 
-            TreeAddress aRemoved;
+            TreeAddress aRemoved = NULL;
             
             List * pLink = & pNode->elements;
-            while( TreeFragment * pElement = static_cast<TreeFragment *>(_aAccessor.access(Pointer(*pLink))) )
+            while( TreeFragment * pElement = reinterpret_cast<TreeFragment *>(*pLink) )
             {
                 if (pElement->isNamed(_aName.toString()))
                 {
-                    aRemoved = TreeAddress( Pointer(*pLink) );
-                   // aRemoved = TreeAccessor(_aReadAccessor,pElement).address();
+                    aRemoved = *pLink;
 
                     *pLink = pElement->header.next;
                     pElement->header.next   = 0;
@@ -149,7 +134,7 @@ namespace configmgr
         
         bool SetNodeAccess::hasElement(Name const& _aName) const 
         { 
-            return SetNodeAccess::implGetElement(_aName).is(); 
+            return SetNodeAccess::implGetElement(_aName) != NULL; 
         }
     // -------------------------------------------------------------------------
 
Index: configmgr/source/tree/treeaccessor.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/treeaccessor.cxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 treeaccessor.cxx
--- configmgr/source/tree/treeaccessor.cxx	16 Sep 2006 15:22:40 -0000	1.3
+++ configmgr/source/tree/treeaccessor.cxx	5 Jan 2007 22:25:44 -0000
@@ -1,87 +1 @@
-/*************************************************************************
- *
- *  OpenOffice.org - a multi-platform office productivity suite
- *
- *  $RCSfile: treeaccessor.cxx,v $
- *
- *  $Revision$
- *
- *  last change: $Author$ $Date$
- *
- *  The Contents of this file are made available subject to
- *  the terms of GNU Lesser General Public License Version 2.1.
- *
- *
- *    GNU Lesser General Public License Version 2.1
- *    =============================================
- *    Copyright 2005 by Sun Microsystems, Inc.
- *    901 San Antonio Road, Palo Alto, CA 94303, USA
- *
- *    This library is free software; you can redistribute it and/or
- *    modify it under the terms of the GNU Lesser General Public
- *    License version 2.1, as published by the Free Software Foundation.
- *
- *    This library is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *    Lesser General Public License for more details.
- *
- *    You should have received a copy of the GNU Lesser General Public
- *    License along with this library; if not, write to the Free Software
- *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- *    MA  02111-1307  USA
- *
- ************************************************************************/
-
-// MARKER(update_precomp.py): autogen include statement, do not remove
-#include "precompiled_configmgr.hxx"
-
-#include "treeaccessor.hxx"
-
-#ifndef CONFIGMGR_UPDATEACCESSOR_HXX
-#include "updateaccessor.hxx"
-#endif
-#ifndef CONFIGMGR_BUILDDATA_HXX
-#include "builddata.hxx"
-#endif
-
-#ifndef _OSL_DIAGNOSE_H_
-#include <osl/diagnose.h>
-#endif
-
-// -----------------------------------------------------------------------------	
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace data
-    {
-    // -------------------------------------------------------------------------
-        TreeAccessor::TreeAccessor()
-        : m_aAccessor(NULL)
-        , m_pBase( memory::Pointer() )
-        {
-        }
-
-    // -------------------------------------------------------------------------
-
-        TreeAddress::DataType* TreeAccessor::access(DataAddressType const& _aTreeRef, memory::UpdateAccessor& _rUpdateAccess)
-        { 
-            return static_cast<TreeAddress::DataType*>(_rUpdateAccess.access(_aTreeRef.m_pData)); 
-        }
-    // -------------------------------------------------------------------------
-        TreeAddress TreeAccessor::copyTree(memory::UpdateAccessor & _aTargetSpace) const
-        {
-            return buildTree(_aTargetSpace, *this);
-        }
-    // -------------------------------------------------------------------------
-        void TreeAccessor::freeTree(memory::UpdateAccessor & _aTargetSpace, TreeAddress _aTree)
-        {
-            destroyTree(_aTargetSpace,_aTree);
-        }
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-
+#error Do not compile me
Index: configmgr/source/tree/treefragment.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/treefragment.cxx,v
retrieving revision 1.5.12.1
diff -u -p -u -r1.5.12.1 treefragment.cxx
--- configmgr/source/tree/treefragment.cxx	3 Nov 2006 11:38:18 -0000	1.5.12.1
+++ configmgr/source/tree/treefragment.cxx	5 Jan 2007 22:25:44 -0000
@@ -127,6 +127,19 @@ configmgr::node::Attributes TreeFragment
     return aResult;
 }
 
+TreeFragment *TreeFragment::allocate(sal_uInt32 nFragments)
+{
+    sal_uInt32 nSize = sizeof(TreeFragment) + sizeof(Node) * (nFragments-1);
+    sal_uInt8 *pMem = new sal_uInt8 [nSize];
+    memset (pMem, 0, nSize);
+    return reinterpret_cast<TreeFragment *>(pMem);
+}
+
+void TreeFragment::free_shallow(TreeFragment *pFragment )
+{
+    delete[] (sal_uInt8 *) pFragment;
+}
+
 //-----------------------------------------------------------------------------
     } // namespace sharable
 //-----------------------------------------------------------------------------
Index: configmgr/source/tree/treesegment.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/treesegment.cxx,v
retrieving revision 1.5.12.1
diff -u -p -u -r1.5.12.1 treesegment.cxx
--- configmgr/source/tree/treesegment.cxx	3 Nov 2006 11:38:31 -0000	1.5.12.1
+++ configmgr/source/tree/treesegment.cxx	5 Jan 2007 22:25:44 -0000
@@ -72,23 +72,14 @@ namespace configmgr
     namespace data
     {
 // -----------------------------------------------------------------------------	
-
-//        typedef std::auto_ptr<INode> RawTreeData;
-//        typedef configuration::Name  Name;
-        using memory::Pointer;
-
-// -----------------------------------------------------------------------------	
-// -----------------------------------------------------------------------------	
 struct TreeSegment::Impl : salhelper::SimpleReferenceObject
 {
-    Impl() : data( memory::localHeap() ), base() {}
+    Impl() : data(), base() {}
     ~Impl();
 
     memory::Segment     data;
     data::TreeAddress   base;
 };
-// -----------------------------------------------------------------------------	
-// -----------------------------------------------------------------------------	
 
 // -----------------------------------------------------------------------------	
 TreeSegment::TreeSegment()
@@ -148,7 +139,7 @@ TreeAccessor    TreeSegment::getTreeAcce
 // -----------------------------------------------------------------------------	
 TreeSegment::Impl::~Impl()
 {   
-    if (base.is())
+    if (base != NULL)
     {
         memory::UpdateAccessor aAccess( & this->data );
         destroyTree(aAccess,base);
@@ -166,7 +157,7 @@ TreeSegment::Impl* TreeSegment::createNe
 
     aNewImpl->base = buildElementTree(aNewAccess,*_aTree,_aTypeName,false); // no defaults for set element trees
 
-    if (!aNewImpl->base.is()) aNewImpl.reset();
+    if (aNewImpl->base == NULL) aNewImpl.reset();
 
     return aNewImpl.release();
 }
@@ -182,7 +173,7 @@ TreeSegment::Impl* TreeSegment::createNe
 
     aNewImpl->base = buildTree(aNewAccess,_aTreeName,*_aTree,false); // no defaults for set element trees
 
-    if (!aNewImpl->base.is()) aNewImpl.reset();
+    if (aNewImpl->base == NULL) aNewImpl.reset();
 
     return aNewImpl.release();
 }
@@ -199,7 +190,7 @@ TreeSegment::Impl* TreeSegment::createNe
 
     aNewImpl->base = _aTree.copyTree(aNewAccess);
 
-    if (!aNewImpl->base.is()) aNewImpl.reset();
+    if (aNewImpl->base == NULL) aNewImpl.reset();
 
     return aNewImpl.release();
 }
@@ -221,7 +212,7 @@ TreeSegment TreeSegment::cloneSegment() 
 // -----------------------------------------------------------------------------	
 bool TreeSegment::is() const
 {
-    return hasData() && m_pImpl->base.is();
+    return hasData() && m_pImpl->base != NULL;
 }
 
 // -----------------------------------------------------------------------------	
@@ -266,7 +257,7 @@ void TreeSegment::markRemovable()
 // -----------------------------------------------------------------------------	
 TreeAddress TreeSegment::getBaseAddress() const
 {
-    return hasData() ? m_pImpl->base : TreeAddress();
+    return hasData() ? m_pImpl->base : NULL;
 }
 
 // -----------------------------------------------------------------------------	
@@ -274,7 +265,7 @@ TreeSegment::TreeDataPtr TreeSegment::ge
 {
     if (!is()) return NULL;
 
-    return TreeAccessor::access(m_pImpl->base, this->getAccessor());
+    return m_pImpl->base;
 }
 
 // -----------------------------------------------------------------------------	
@@ -285,7 +276,7 @@ TreeSegment::TreeDataUpdatePtr TreeSegme
 
     if (!is()) return NULL;
 
-    return TreeAccessor::access(m_pImpl->base,_anUpdater);
+    return m_pImpl->base;
 }
 
 // -----------------------------------------------------------------------------	
Index: configmgr/source/tree/updatehelper.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/updatehelper.cxx,v
retrieving revision 1.11
diff -u -p -u -r1.11 updatehelper.cxx
--- configmgr/source/tree/updatehelper.cxx	16 Sep 2006 15:24:10 -0000	1.11
+++ configmgr/source/tree/updatehelper.cxx	5 Jan 2007 22:25:44 -0000
@@ -455,35 +455,35 @@ void ApplyValueChange::apply(ValueChange
 
 void ApplyUpdate::handle(ValueChange& _rChange)
 {
-	// Change a Value
-	OSL_ENSURE(m_aCurrentNode.is(),"Cannot apply ValueChange without node");
+    // Change a Value
+    OSL_ENSURE(m_aCurrentNode != NULL,"Cannot apply ValueChange without node");
 
     data::NodeAddress aChildNodeAddr = data::getSubnodeAddress(m_rUpdateAccess, m_aCurrentNode, getChangeNodeName(_rChange));		
-	OSL_ENSURE(aChildNodeAddr.is(),"Cannot apply Change: No node to change");
+    OSL_ENSURE(aChildNodeAddr != NULL,"Cannot apply Change: No node to change");
 
-    data::ValueNodeAddress aValueAddr = data::toValueNodeAddress(m_rUpdateAccess, aChildNodeAddr);
-	OSL_ENSURE(aValueAddr.is(),"Cannot apply ValueChange: Node is not a value");
+    data::ValueNodeAddress aValueAddr = aChildNodeAddr->valueData();
+    OSL_ENSURE(aValueAddr != NULL,"Cannot apply ValueChange: Node is not a value");
 
-	if (aValueAddr.is())
-		ApplyValueChange::apply(_rChange,m_rUpdateAccess,aValueAddr);
+    if (aValueAddr != NULL)
+	ApplyValueChange::apply(_rChange,m_rUpdateAccess,aValueAddr);
 }
 //--------------------------------------------------------------------------
 	
 void ApplyUpdate::handle(SubtreeChange& _rChange)
 {
-	// handle traversion
-	OSL_ENSURE(m_aCurrentNode.is(),"Cannot apply SubtreeChange without node");
+    // handle traversion
+    OSL_ENSURE(m_aCurrentNode != NULL,"Cannot apply SubtreeChange without node");
 
     data::NodeAddress aChildNodeAddr = data::getSubnodeAddress(m_rUpdateAccess, m_aCurrentNode, getChangeNodeName(_rChange));		
-	OSL_ENSURE(aChildNodeAddr.is(),"Cannot apply Change: No node to change");
+    OSL_ENSURE(aChildNodeAddr != NULL,"Cannot apply Change: No node to change");
 
-	OSL_ENSURE( data::toGroupNodeAddress(m_rUpdateAccess, aChildNodeAddr).is() ||
-                data::toSetNodeAddress(m_rUpdateAccess, aChildNodeAddr).is() ,
+    OSL_ENSURE( data::toGroupNodeAddress(m_rUpdateAccess, aChildNodeAddr) != NULL ||
+                data::toSetNodeAddress(m_rUpdateAccess, aChildNodeAddr) != NULL ,
                 "Cannot Apply SubtreeChange: Node is not an inner node");
 
-    if (aChildNodeAddr.is())
+    if (aChildNodeAddr != NULL)
     {
-        data::NodeAccess::access(aChildNodeAddr, m_rUpdateAccess)->node.info.markAsDefault( _rChange.isToDefault() );
+        aChildNodeAddr->node.info.markAsDefault( _rChange.isToDefault() );
 
         data::NodeAddress aOldNode = m_aCurrentNode;
         m_aCurrentNode = aChildNodeAddr;
@@ -497,29 +497,29 @@ void ApplyUpdate::handle(SubtreeChange& 
 
 void ApplyUpdate::handle(AddNode& _rChange)
 {
-	OSL_ENSURE(m_aCurrentNode.is(),"Cannot apply AddNode without node");
+    OSL_ENSURE(m_aCurrentNode != NULL,"Cannot apply AddNode without node");
 
     data::SetNodeAddress aSetNodeAddr = data::toSetNodeAddress(m_rUpdateAccess, m_aCurrentNode);		
-	OSL_ENSURE(aSetNodeAddr.is(),"Cannot apply AddNode: Node is not a set node");
+    OSL_ENSURE(aSetNodeAddr != NULL,"Cannot apply AddNode: Node is not a set node");
 
-	// Add a new element
-	if (aSetNodeAddr.is())
+    // Add a new element
+    if (aSetNodeAddr != NULL)
+    {
+	if (_rChange.isReplacing())
 	{
-		if (_rChange.isReplacing())
-		{
             data::TreeAddress aOldNodeAddr = 
-                data::SetNodeAccess::removeElement(m_rUpdateAccess,aSetNodeAddr,getChangeNodeName(_rChange));
+                data::SetNodeAccess::removeElement(aSetNodeAddr,getChangeNodeName(_rChange));
 
-            OSL_ENSURE(aOldNodeAddr.is(), "ApplyUpdate: AddNode: can't recover node being replaced");
+            OSL_ENSURE(aOldNodeAddr != NULL, "ApplyUpdate: AddNode: can't recover node being replaced");
 
             data::TreeAccessor aOldNodeAccess(m_rUpdateAccess.accessor(),aOldNodeAddr);
             _rChange.takeReplacedTree( data::TreeSegment::createNew(aOldNodeAccess) );
 		}
 
         data::TreeAddress aNewAddress = data::buildTree(m_rUpdateAccess, _rChange.getNewTree().getTreeAccess());
-        OSL_ENSURE(aNewAddress.is(), "ApplyUpdate: AddNode: could not create new element");
+        OSL_ENSURE(aNewAddress != NULL, "ApplyUpdate: AddNode: could not create new element");
 
-        data::SetNodeAccess::addElement(m_rUpdateAccess,aSetNodeAddr,aNewAddress);
+        data::SetNodeAccess::addElement(aSetNodeAddr,aNewAddress);
 
         _rChange.setInsertedAddress( aNewAddress );
 	}	
@@ -528,18 +528,18 @@ void ApplyUpdate::handle(AddNode& _rChan
 	
 void ApplyUpdate::handle(RemoveNode& _rChange)
 {
-	OSL_ENSURE(m_aCurrentNode.is(),"Cannot apply RemoveNode without node");
+    OSL_ENSURE(m_aCurrentNode != NULL,"Cannot apply RemoveNode without node");
 
     data::SetNodeAddress aSetNodeAddr = data::toSetNodeAddress(m_rUpdateAccess, m_aCurrentNode);		
-	OSL_ENSURE(aSetNodeAddr.is(),"Cannot apply RemoveNode: Node is not a set node");
+    OSL_ENSURE(aSetNodeAddr != NULL,"Cannot apply RemoveNode: Node is not a set node");
 
-	// Remove an element
-	if (aSetNodeAddr.is())
-	{
+    // Remove an element
+    if (aSetNodeAddr != NULL)
+    {
         data::TreeAddress aOldNodeAddr = 
-            data::SetNodeAccess::removeElement(m_rUpdateAccess,aSetNodeAddr,getChangeNodeName(_rChange));
+            data::SetNodeAccess::removeElement(aSetNodeAddr,getChangeNodeName(_rChange));
 
-        OSL_ENSURE(aOldNodeAddr.is(), "ApplyUpdate: Remove: can't recover node being removed");
+        OSL_ENSURE(aOldNodeAddr != NULL, "ApplyUpdate: Remove: can't recover node being removed");
 
         data::TreeAccessor aOldNodeAccess(m_rUpdateAccess.accessor(),aOldNodeAddr);
         _rChange.takeRemovedTree( data::TreeSegment::createNew(aOldNodeAccess) );
Index: configmgr/source/tree/valuenodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/valuenodeaccess.cxx,v
retrieving revision 1.6
diff -u -p -u -r1.6 valuenodeaccess.cxx
--- configmgr/source/tree/valuenodeaccess.cxx	16 Sep 2006 15:24:22 -0000	1.6
+++ configmgr/source/tree/valuenodeaccess.cxx	5 Jan 2007 22:25:44 -0000
@@ -53,30 +53,20 @@ namespace configmgr
 // -----------------------------------------------------------------------------	
     namespace data
     {
-    // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-        static 
-        ValueNodeAddress::DataType* accessValue(Pointer const& _p, memory::UpdateAccessor& _rUpdateAccess)
+        ValueNodeAddress ValueNodeAccess::check(NodeAccessRef const& _aNode)
         {
-            return static_cast<ValueNodeAddress::DataType*>( _rUpdateAccess.validate(_p) );
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-
-        Pointer ValueNodeAccess::check(NodeAccessRef const& _aNode)
-        {
-            if (sharable::Node const* pNode = _aNode.getDataPtr())
-                return _aNode.accessor().address(pNode->valueData());
-
+            if (sharable::Node const* pNode = _aNode)
+                return const_cast<ValueNodeAddress>(pNode->valueData());
             else
-                return Pointer();
+                return NULL;
         }
     // -------------------------------------------------------------------------
 		    
-void ValueNodeAccess::setValue(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue)
+void ValueNodeAccess::setValue(memory::UpdateAccessor &,
+                               ValueNodeAddress _aValueNode,
+                               uno::Any const& _aValue)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = _aValueNode;
 
     using namespace sharable;
     AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
@@ -86,8 +76,8 @@ void ValueNodeAccess::setValue(memory::U
     {
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->value);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->value);
+        node = _aValueNode;
 
         node->value.data = 0;
         node->info.flags ^= Flags::valueAvailable;
@@ -114,8 +104,8 @@ void ValueNodeAccess::setValue(memory::U
         if (aType == aNewType)
         {
             // store the data
-            sharable::AnyData aNewData = allocData(_aUpdater.allocator(),aType,_aValue);
-            node = accessValue(_aValueNode.m_pData,_aUpdater);
+            sharable::AnyData aNewData = allocData(aType,_aValue);
+            node = _aValueNode;
 
             node->value = aNewData;
             node->info.flags |= Flags::valueAvailable;
@@ -125,9 +115,10 @@ void ValueNodeAccess::setValue(memory::U
 }
 //-----------------------------------------------------------------------------
 
-void ValueNodeAccess::setToDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode)
+void ValueNodeAccess::setToDefault(memory::UpdateAccessor &,
+                                   ValueNodeAddress _aValueNode)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = _aValueNode;
 
     using namespace sharable;
     OSL_ENSURE(node->hasUsableDefault(), "ERROR: setToDefault() - Value does not have a default");
@@ -138,8 +129,8 @@ void ValueNodeAccess::setToDefault(memor
         AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->value);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->value);
+        node = _aValueNode;
 
         node->value.data = 0;
         node->info.flags ^= Flags::valueAvailable;
@@ -149,9 +140,11 @@ void ValueNodeAccess::setToDefault(memor
 }
 //-----------------------------------------------------------------------------
 
-void ValueNodeAccess::changeDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue)
+void ValueNodeAccess::changeDefault(memory::UpdateAccessor &,
+                                    ValueNodeAddress _aValueNode,
+                                    uno::Any const& _aValue)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = _aValueNode;
 
     using namespace sharable;
     AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
@@ -161,8 +154,8 @@ void ValueNodeAccess::changeDefault(memo
     {
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->defaultValue);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->defaultValue);
+        node = _aValueNode;
 
         node->defaultValue.data = 0;
         node->info.flags ^= Flags::defaultAvailable;
@@ -189,8 +182,8 @@ void ValueNodeAccess::changeDefault(memo
         if (aType == aNewType)
         {
             // store the data
-            sharable::AnyData aNewData = allocData(_aUpdater.allocator(),aType,_aValue);
-            node = accessValue(_aValueNode.m_pData,_aUpdater);
+            sharable::AnyData aNewData = allocData(aType,_aValue);
+            node = _aValueNode;
 
             node->defaultValue = aNewData;
             node->info.flags |= Flags::defaultAvailable;
@@ -198,32 +191,7 @@ void ValueNodeAccess::changeDefault(memo
     }
 }
 
-//-----------------------------------------------------------------------------
-/*
-void ValueNode::clearData(data::Allocator const & _aAlloc)
-{
-    AnyData::TypeCode aType = info.type & Type::mask_valuetype;
-
-    if (info.flags & Flags::valueAvailable)
-    {
-        OSL_ASSERT(aType != Type::value_any);
-        freeData(_aAlloc,aType,this->value);
-        info.flags ^= Flags::valueAvailable;
-        this->value.data = 0;
-    }
-
-    if (info.flags & Flags::defaultAvailable)
-    {
-        OSL_ASSERT(aType != Type::value_any);
-        freeData(_aAlloc,aType,this->defaultValue);
-        info.flags ^= Flags::defaultAvailable;
-        this->defaultValue.data = 0;
-    }
-}
-*/
-//-----------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
+    } // namespace data
 } // namespace configmgr
 
 
Index: configmgr/source/treecache/cacheaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheaccess.cxx,v
retrieving revision 1.9
diff -u -p -u -r1.9 cacheaccess.cxx
--- configmgr/source/treecache/cacheaccess.cxx	16 Sep 2006 15:24:36 -0000	1.9
+++ configmgr/source/treecache/cacheaccess.cxx	5 Jan 2007 22:25:44 -0000
@@ -41,9 +41,6 @@
 #ifndef CONFIGMGR_ACCESSOR_HXX
 #include "accessor.hxx"
 #endif
-#ifndef CONFIGMGR_NODEADDRESS_HXX
-#include "nodeaddress.hxx"
-#endif
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #include "nodeaccess.hxx"
 #endif
@@ -62,10 +59,8 @@ namespace configmgr
 
 // -------------------------------------------------------------------------
 
-CacheClientAccess::CacheClientAccess(memory::HeapManager & _rHeapManager,
-                                     ConfigChangeBroadcastHelper *  _pBroadcastHelper)
+CacheClientAccess::CacheClientAccess(ConfigChangeBroadcastHelper *  _pBroadcastHelper)
 : m_aMutex()
-, m_aData(_rHeapManager)
 , m_pBroadcastHelper( _pBroadcastHelper )
 {
 }
@@ -87,7 +82,7 @@ ConfigChangeBroadcastHelper *  CacheClie
 // -------------------------------------------------------------------------
 
 /// gets a data segment reference for the given path - creates if necessary
-memory::Segment * CacheLoadingAccess::createNewDataSegment(ModuleName const & _aModule)
+memory::Segment * CacheLoadingAccess::createNewDataSegment(CacheLine::Name const & _aModule)
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
@@ -96,24 +91,24 @@ memory::Segment * CacheLoadingAccess::cr
 // -------------------------------------------------------------------------
 
 /// gets a data segment reference for the given path - creates if necessary
-memory::Segment * CacheClientAccess::attachDataSegment(const memory::SegmentAddress & _aSegment, const Path& _aLocation)
+memory::Segment * CacheClientAccess::attachDataSegment(data::TreeAddress _aSegment, const CacheLine::Path& _aLocation)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
     return this->m_aData.attachDataSegment(_aSegment,_aLocation.getModuleName());
 }
 // -------------------------------------------------------------------------
 
 /// gets a data segment reference for the given path if exists
-memory::Segment * CacheClientAccess::getDataSegment(const Path& _aLocation)
+memory::Segment * CacheClientAccess::getDataSegment(const CacheLine::Path& _aLocation)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
     return this->m_aData.getDataSegment(_aLocation.getModuleName());
 }
 // -------------------------------------------------------------------------
 
-bool CacheClientAccess::hasModule(const Path& _aLocation)
+bool CacheClientAccess::hasModule(const CacheLine::Path& _aLocation)
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
@@ -121,7 +116,7 @@ bool CacheClientAccess::hasModule(const 
 }
 // -------------------------------------------------------------------------
 
-bool CacheClientAccess::hasModuleDefaults(memory::Accessor const& _aAccessor, Path const& _aLocation)
+bool CacheClientAccess::hasModuleDefaults(memory::Accessor const& _aAccessor, CacheLine::Path const& _aLocation)
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
@@ -129,7 +124,7 @@ bool CacheClientAccess::hasModuleDefault
 }
 // -------------------------------------------------------------------------
 
-data::NodeAddress CacheClientAccess::acquireNode(memory::Accessor const& _aAccessor, Path const& rLocation )
+data::NodeAddress CacheClientAccess::acquireNode(memory::Accessor const& _aAccessor, CacheLine::Path const& rLocation )
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
@@ -137,7 +132,7 @@ data::NodeAddress CacheClientAccess::acq
 
     data::NodeAddress aResult = this->m_aData.acquireNode(_aAccessor,rLocation);
 
-	if (aResult.is())
+	if (aResult != NULL)
 	{
 		CFG_TRACE_INFO_NI("- Data is available - returning Subtree");
 	}
@@ -148,13 +143,13 @@ data::NodeAddress CacheClientAccess::acq
 }
 // -------------------------------------------------------------------------
 
-CacheLine::RefCount CacheClientAccess::releaseNode( Path const& rLocation )
+oslInterlockedCount CacheClientAccess::releaseNode( CacheLine::Path const& rLocation )
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
 	CFG_TRACE_INFO("Tree Info: Releasing subtree data for path '%s'", OUSTRING2ASCII(rLocation.toString()) );
 
-	Module::RefCount nRet = this->m_aData.releaseModule(rLocation.getModuleName(),false);
+	oslInterlockedCount nRet = this->m_aData.releaseModule(rLocation.getModuleName(),false);
 
 	return nRet;
 }
@@ -170,13 +165,13 @@ void CacheClientAccess::applyUpdate(memo
 }
 
 // -----------------------------------------------------------------------------
-data::NodeAddress CacheClientAccess::findInnerNode( data::Accessor const& _aAccess, Path const& aComponentName )
+data::NodeAddress CacheClientAccess::findInnerNode( memory::Accessor const& _aAccess, CacheLine::Path const& aComponentName )
 {
-	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Tree
+    osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Tree
 
     data::NodeAddress aNode = this->m_aData.getNode(_aAccess, aComponentName);
 
-    if (aNode.is() && data::NodeAccessRef(&_aAccess,aNode).data().isValue() )
+    if (aNode != NULL && data::NodeAccessRef(&_aAccess,aNode).data().isValue() )
         aNode = data::NodeAddress();
 
     return aNode;
@@ -199,7 +194,7 @@ bool CacheClientAccess::isEmpty()
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
-	Data::ModuleList& rModules = this->m_aData.accessModuleList();
+	CacheData::ModuleList& rModules = this->m_aData.accessModuleList();
 
 	bool bRet = rModules.empty();
 
@@ -210,9 +205,8 @@ bool CacheClientAccess::isEmpty()
 // -------------------------------------------------------------------------
 // -------------------------------------------------------------------------
 
-CacheLoadingAccess::CacheLoadingAccess(memory::HeapManager & _rHeapManager)
+CacheLoadingAccess::CacheLoadingAccess()
 : m_aMutex()
-, m_aData(_rHeapManager)
 , m_aDeadModules()
 {
 }
@@ -224,67 +218,67 @@ CacheLoadingAccess::~CacheLoadingAccess(
 // -------------------------------------------------------------------------
 
 /// gets a data segment reference for the given path - creates if necessary
-memory::Segment * CacheLoadingAccess::attachDataSegment(const memory::SegmentAddress & _aSegment, ModuleName const & _aModule)
+memory::Segment * CacheLoadingAccess::attachDataSegment(data::TreeAddress _aSegment, CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
     return this->m_aData.attachDataSegment(_aSegment,_aModule);
 }
 // -------------------------------------------------------------------------
 
 /// gets a data segment reference for the given path if exists
-memory::Segment * CacheLoadingAccess::getDataSegment(ModuleName const & _aModule)
+memory::Segment * CacheLoadingAccess::getDataSegment(CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
     return this->m_aData.getDataSegment(_aModule);
 }
 // -------------------------------------------------------------------------
 
-/// gets a data segment reference for the given path if exists
-memory::SegmentAddress CacheLoadingAccess::getDataSegmentAddress(ModuleName const & _aModule)
+/// gets a tree reference for the given path if exists
+data::TreeAddress CacheLoadingAccess::getTreeAddress(CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
-    return this->m_aData.getDataSegmentAddress(_aModule);
+    return this->m_aData.getTreeAddress(_aModule);
 }
 // -------------------------------------------------------------------------
 
-bool CacheLoadingAccess::hasModule(ModuleName const & _aModule)
+bool CacheLoadingAccess::hasModule(CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
     return this->m_aData.hasModule(_aModule);
 }
 // -------------------------------------------------------------------------
 
-data::TreeAddress CacheLoadingAccess::acquireModule(ModuleName const & _aModule )
+bool CacheLoadingAccess::acquireModule(CacheLine::Name const & _aModule )
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
-
-	CFG_TRACE_INFO("Tree Info: Requesting data for module '%s'", OUSTRING2ASCII(_aModule.toString()) );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
-    data::TreeAddress aResult = this->m_aData.acquireModule(_aModule);
+    CFG_TRACE_INFO("Tree Info: Requesting data for module '%s'", OUSTRING2ASCII(_aModule.toString()) );
 
-	if (aResult.is())
-	{
-		m_aDeadModules.erase( _aModule );
-		CFG_TRACE_INFO_NI("- Data is available - returning Subtree");
-	}
-	else
-		CFG_TRACE_INFO_NI("- Data is not available - returning NULL");
-
-    return aResult;
+    if (this->m_aData.acquireModule(_aModule))
+    {
+	m_aDeadModules.erase( _aModule );
+	CFG_TRACE_INFO_NI("- Data is available - returning Subtree");
+	return true;
+    }
+    else
+    {
+	CFG_TRACE_INFO_NI("- Data is not available - returning NULL");
+	return false;
+    }
 }
 // -------------------------------------------------------------------------
 
-CacheLine::RefCount CacheLoadingAccess::releaseModule( ModuleName const & _aModule )
+oslInterlockedCount CacheLoadingAccess::releaseModule( CacheLine::Name const & _aModule )
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
 	CFG_TRACE_INFO("Tree Info: Releasing data for module '%s'", OUSTRING2ASCII(_aModule.toString()) );
 
-	Module::RefCount nRet = this->m_aData.releaseModule(_aModule,true); // keep
+	oslInterlockedCount nRet = this->m_aData.releaseModule(_aModule,true); // keep
     if (nRet == 0)
 	{
         m_aDeadModules[ _aModule ] = TimeStamp::getCurrentTime();
@@ -305,7 +299,7 @@ void CacheLoadingAccess::applyUpdate(mem
 }
 
 // -----------------------------------------------------------------------------
-data::NodeAddress CacheLoadingAccess::findNode( data::Accessor const& _aAccess, Path const& aComponentName )
+data::NodeAddress CacheLoadingAccess::findNode( memory::Accessor const& _aAccess, CacheLine::Path const& aComponentName )
 {
 	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Tree
 
@@ -320,7 +314,7 @@ bool CacheLoadingAccess::isEmpty()
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
-	Data::ModuleList& rModules = this->m_aData.accessModuleList();
+	ExtendedCacheData::ModuleList& rModules = this->m_aData.accessModuleList();
 
 	bool bRet = rModules.empty();
 
@@ -342,7 +336,7 @@ data::TreeAddress CacheLoadingAccess::ad
                     _bIncludesDefaults ? "Data includes defaults." : "Data does not include defaults." );
 
     data::TreeAddress aResult = this->m_aData.addComponentData(_aAccessToken, _aComponentInstance, _bIncludesDefaults);
-	if (aResult.is())
+	if (aResult != NULL)
 	{
 		m_aDeadModules.erase( _aComponentInstance.component() );
 		CFG_TRACE_INFO_NI("- Data added successfully - returning Subtree");
@@ -366,7 +360,7 @@ void CacheLoadingAccess::addChangesToPen
 }
 
 // -----------------------------------------------------------------------------
-std::auto_ptr<SubtreeChange> CacheLoadingAccess::releasePendingChanges(ModuleName const& _aComponentName)
+std::auto_ptr<SubtreeChange> CacheLoadingAccess::releasePendingChanges(CacheLine::Name const& _aComponentName)
 {
 	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Data
 	CFG_TRACE_INFO("Tree Info: extract pending changes from subtree '%s'", OUSTRING2ASCII(_aComponentName.toString()) );
@@ -374,7 +368,7 @@ std::auto_ptr<SubtreeChange> CacheLoadin
 }
 
 // -----------------------------------------------------------------------------
-bool CacheLoadingAccess::findPendingChangedModules( Data::PendingModuleList & _rPendingList )
+bool CacheLoadingAccess::findPendingChangedModules( ExtendedCacheData::PendingModuleList & _rPendingList )
 {
 	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Data
     this->m_aData.findPendingModules(_rPendingList);
@@ -388,7 +382,7 @@ void CacheLoadingAccess::clearData(Dispo
 
 	CFG_TRACE_INFO("Tree Info: Removing all module trees for cleanup" );
 
-	typedef Data::ModuleList ModuleList;
+	typedef ExtendedCacheData::ModuleList ModuleList;
 
 	ModuleList& rModules = this->m_aData.accessModuleList();
 
@@ -413,7 +407,7 @@ TimeStamp CacheLoadingAccess::collectDis
 
 	CFG_TRACE_INFO("Tree Info: Collecting disposable module trees for cleanup" );
 
-	Data::ModuleList& rActiveModules = this->m_aData.accessModuleList();
+	ExtendedCacheData::ModuleList& rActiveModules = this->m_aData.accessModuleList();
 
 	DeadModuleList::iterator it = m_aDeadModules.begin();
 
@@ -429,11 +423,11 @@ TimeStamp CacheLoadingAccess::collectDis
         TimeStamp aExpireTime = current->second + _aDelay;
 		if (aExpireTime <= _aLimitTime)
 		{
-            Data::ModuleList::iterator itModule = rActiveModules.find( current->first );
+            ExtendedCacheData::ModuleList::iterator itModule = rActiveModules.find( current->first );
 
 			if (itModule != rActiveModules.end())
 			{
-				ModuleRef xModule = itModule->second;
+				CacheLineRef xModule = itModule->second;
 
 				bool bHandled = false;
 
Index: configmgr/source/treecache/cacheaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheaccess.hxx,v
retrieving revision 1.6
diff -u -p -u -r1.6 cacheaccess.hxx
--- configmgr/source/treecache/cacheaccess.hxx	8 Sep 2005 04:21:46 -0000	1.6
+++ configmgr/source/treecache/cacheaccess.hxx	5 Jan 2007 22:25:44 -0000
@@ -69,21 +69,14 @@ namespace configmgr
 
     class CacheClientAccess : public salhelper::SimpleReferenceObject, Noncopyable
 	{
-	public:
-        typedef CacheData   Data;
-        typedef Data::Module       Module;
-        typedef Data::ModuleRef    ModuleRef;
-        typedef Data::ModuleName   ModuleName;
-        typedef Data::Path         Path;
 	private:
-		osl::Mutex			m_aMutex;
-		Data			    m_aData;		
+	    osl::Mutex  m_aMutex;
+	    CacheData   m_aData;
 
 		ConfigChangeBroadcastHelper* m_pBroadcastHelper;
 	public:
         explicit
-		CacheClientAccess(memory::HeapManager & _rHeapManager,
-                          ConfigChangeBroadcastHelper* _pBroadcastHelper);
+		CacheClientAccess(ConfigChangeBroadcastHelper* _pBroadcastHelper);
 
 		~CacheClientAccess();
 		
@@ -95,20 +88,20 @@ namespace configmgr
         ConfigChangeBroadcastHelper * releaseBroadcaster();
 
         /// gets a data segment reference for the given path - creates if necessary
-        memory::Segment * attachDataSegment(const memory::SegmentAddress & _aSegment, const Path& _aLocation);
+        memory::Segment * attachDataSegment(data::TreeAddress _aSegment, const CacheLine::Path& _aLocation);
         /// gets a data segment reference for the given path if exists
-        memory::Segment * getDataSegment(const Path& _aLocation);
+        memory::Segment * getDataSegment(const CacheLine::Path& _aLocation);
 
 		/// return TRUE if there is no data (left) in this object's cache data 
 		bool isEmpty();
 
         /// check if the given module exists already (and is not empty)
-        bool hasModule(const Path& _aLocation);
+        bool hasModule(const CacheLine::Path& _aLocation);
         /// checks if the given module exists and has defaults available
-        bool hasModuleDefaults(memory::Accessor const & _aAccessor, Path const & _aLocation);
+        bool hasModuleDefaults(memory::Accessor const & _aAccessor, CacheLine::Path const & _aLocation);
 
 		/// retrieve the subtree at _aPath (maybe if it has the requested defaults) and clientAcquire() it
-		data::NodeAddress acquireNode(memory::Accessor const& _aAccessToken, Path const& _aPath); 
+		data::NodeAddress acquireNode(memory::Accessor const& _aAccessToken, CacheLine::Path const& _aPath); 
 
 		/** add or merge the given subtree at the given location,
 			return <TRUE/> if the tree has defaults then
@@ -116,10 +109,10 @@ namespace configmgr
         bool insertDefaults(memory::UpdateAccessor& _aUpdateToken, backend::NodeInstance const & _aDefaultData ) CFG_UNO_THROW_RTE(  );
 
 		/// clientRelease() the tree at aComponentName, and return the resulting reference count
-        CacheLine::RefCount releaseNode( Path const& _aPath ); 
+        oslInterlockedCount releaseNode( CacheLine::Path const& _aPath ); 
 
 		/// retrieve the given subtree without changing its ref count
-		data::NodeAddress	findInnerNode(memory::Accessor const& _aAccessToken, Path const& _aPath );
+		data::NodeAddress	findInnerNode(memory::Accessor const& _aAccessToken, CacheLine::Path const& _aPath );
 
 		/// merge the given change list into this tree - reflects old data to _aUpdate
         void applyUpdate(memory::UpdateAccessor& _aUpdateToken,  backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( );	
@@ -130,50 +123,44 @@ namespace configmgr
 	
     class CacheLoadingAccess : public salhelper::SimpleReferenceObject, Noncopyable
 	{
-	public:
-        typedef ExtendedCacheData  Data;
-        typedef Data::Module       Module;
-        typedef Data::ModuleRef    ModuleRef;
-        typedef Data::ModuleName   ModuleName;
-        typedef Data::Path         Path;
-
-		typedef std::vector< ModuleRef >  DisposeList;
+    public:
+		typedef std::vector< CacheLineRef >  DisposeList;
         friend class backend::CacheController;
 	private:
         friend class CacheDisposeScheduler;
-        typedef std::map< ModuleName, TimeStamp > DeadModuleList;
+        typedef std::map< CacheLine::Name, TimeStamp > DeadModuleList;
 
 		osl::Mutex			m_aMutex;
-		Data			    m_aData;		
+		ExtendedCacheData   m_aData;		
 		DeadModuleList		m_aDeadModules;			/// list of nodes which are registered for throwing away
 	public:
         explicit
-		CacheLoadingAccess(memory::HeapManager & _rHeapManager);
+		CacheLoadingAccess();
 		~CacheLoadingAccess();
 		
         /// gets a data segment reference for the given path if exists
-        memory::Segment * createNewDataSegment(ModuleName const & _aModule);
+        memory::Segment * createNewDataSegment(CacheLine::Name const & _aModule);
         /// gets a data segment reference for the given path - creates if necessary
-        memory::Segment * attachDataSegment(const memory::SegmentAddress & _aSegment, ModuleName const & _aModule);
+        memory::Segment * attachDataSegment(data::TreeAddress _aSegment, CacheLine::Name const & _aModule);
         /// gets a data segment reference for the given path if exists
-        memory::Segment * getDataSegment(ModuleName const & _aModule);
-        /// gets a data segment address for the given module if it exists
-        memory::SegmentAddress getDataSegmentAddress(ModuleName const & _aModule);
+        memory::Segment * getDataSegment(CacheLine::Name const & _aModule);
+        /// gets a tree address for the given module if it exists
+        data::TreeAddress getTreeAddress(CacheLine::Name const & _aModule);
 
 		/// return TRUE if there is no data (left) in this object's cache data 
 		bool isEmpty();
 
         /// check if the given module exists already (and is not empty)
-        bool hasModule(ModuleName const & _aLocation);
+        bool hasModule(CacheLine::Name const & _aLocation);
 
-		/// retrieve the subtree at aComponentName and clientAcquire() it
-		data::TreeAddress acquireModule(ModuleName const & _aModule); 
+		/// retrieve the subtree at aComponentName and clientAcquire() it, true if succeeded
+		bool acquireModule(CacheLine::Name const & _aModule); 
 
 		/// clientRelease() the tree at aComponentName, and return the resulting reference count
-        CacheLine::RefCount releaseModule( ModuleName const & _aModule ); 
+        oslInterlockedCount releaseModule( CacheLine::Name const & _aModule ); 
 
 		/// retrieve the given subtree without changing its ref count
-		data::NodeAddress	findNode(memory::Accessor const& _aAccessToken, Path const& _aPath );
+		data::NodeAddress	findNode(memory::Accessor const& _aAccessToken, CacheLine::Path const& _aPath );
 
 		/// merge the given change list into this tree - reflects old data to _aUpdate
         void applyUpdate(memory::UpdateAccessor& _aUpdateToken,  backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( );	
@@ -198,10 +185,10 @@ namespace configmgr
 		/// merge the given change list into the pending change list of this tree
 		void addChangesToPending( backend::ConstUpdateInstance const& _anUpdate ) CFG_UNO_THROW_RTE(  );
 		/// retrieve accumulated pending changes
-		std::auto_ptr<SubtreeChange> releasePendingChanges(ModuleName const& _aModule);
+		std::auto_ptr<SubtreeChange> releasePendingChanges(CacheLine::Name const& _aModule);
 
         /// find the modules having pending changes
-        bool findPendingChangedModules( Data::PendingModuleList & _rPendingList );
+        bool findPendingChangedModules( ExtendedCacheData::PendingModuleList & _rPendingList );
 
         /// get a local lock for this cache line
         osl::Mutex & mutex() { return m_aMutex; }
Index: configmgr/source/treecache/cachecontroller.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachecontroller.cxx,v
retrieving revision 1.18
diff -u -p -u -r1.18 cachecontroller.cxx
--- configmgr/source/treecache/cachecontroller.cxx	16 Sep 2006 15:24:50 -0000	1.18
+++ configmgr/source/treecache/cachecontroller.cxx	5 Jan 2007 22:25:44 -0000
@@ -1,3 +1,4 @@
+#include <stdio.h>
 /*************************************************************************
  *
  *  OpenOffice.org - a multi-platform office productivity suite
@@ -51,9 +52,6 @@
 #ifndef CONFIGMGR_UPDATEACCESSOR_HXX
 #include "updateaccessor.hxx"
 #endif
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
-#endif
 #ifndef CONFIGMGR_TREEACCESSOR_HXX
 #include "treeaccessor.hxx"
 #endif
@@ -142,43 +140,37 @@ OCacheWriteScheduler* CacheController::c
 
 CacheController::CacheRef CacheController::getCacheAlways(RequestOptions const & _aOptions)
 {
-    osl::MutexGuard aGuard( m_aCacheList.mutex() );
+    osl::MutexGuard aGuard( m_aCacheMap.mutex() );
 
-    CacheRef aResult = m_aCacheList.get(_aOptions);
+    CacheRef aResult = m_aCacheMap.get(_aOptions);
     if (!aResult.is())
     {
-        CacheRef aNewCache( new Cache(getCacheHeapManager()) );
-        aResult = m_aCacheList.insert(_aOptions,aNewCache);
+        CacheRef aNewCache( new Cache() );
+        aResult = m_aCacheMap.insert(_aOptions,aNewCache);
     }
     return aResult;
 }
 
 // -------------------------------------------------------------------------
 
-memory::HeapManager & CacheController::getCacheHeapManager() const
-{
-    return m_aTemplates.getHeapManager();
-}
-// -------------------------------------------------------------------------
-
 // disposing
 // -------------------------------------------------------------------------
 void CacheController::disposeAll(bool _bFlushRemainingUpdates)
 {
 	CFG_TRACE_INFO("CacheController: Disposing all data" );
-    CacheList::Map aReleaseList;
+    CacheMap::Map aReleaseList;
 
 	if (m_pDisposer)
 	{
 		osl::MutexGuard aShotGuard(m_pDisposer->getShotMutex());
-		osl::MutexGuard aGuard(m_aCacheList.mutex());
+		osl::MutexGuard aGuard(m_aCacheMap.mutex());
 		m_pDisposer->stopAndClearTasks();
-		m_aCacheList.swap(aReleaseList); // move data out of m_aCacheList and empty m_aCacheList
+		m_aCacheMap.swap(aReleaseList); // move data out of m_aCacheMap and empty m_aCacheMap
 	}
 
     if (_bFlushRemainingUpdates)
     {
-        for (CacheList::Map::iterator it = aReleaseList.begin(); it != aReleaseList.end(); ++it)
+        for (CacheMap::Map::iterator it = aReleaseList.begin(); it != aReleaseList.end(); ++it)
             saveAllPendingChanges(it->second,it->first);
     }
 	// free all the trees
@@ -203,7 +195,7 @@ void CacheController::dispose() CFG_UNO_
 // -------------------------------------------------------------------------
 void CacheController::disposeOne(RequestOptions const & _aOptions, bool _bFlushUpdates)
 {
-	osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
+	osl::ClearableMutexGuard aGuard(m_aCacheMap.mutex());
 
 	CFG_TRACE_INFO("CacheController: Disposing data and TreeInfo for user '%s' with locale '%s'",
 					OUSTRING2ASCII(_aOptions.getEntity()), OUSTRING2ASCII(_aOptions.getLocale()) );
@@ -218,7 +210,7 @@ void CacheController::disposeOne(Request
 		CFG_TRACE_WARNING_NI("Found orphaned Changes in the cache - Discarding.");
     }
 
-    CacheRef aRemoved = m_aCacheList.remove(_aOptions);
+    CacheRef aRemoved = m_aCacheMap.remove(_aOptions);
 	
 	if (aRemoved.is())
 	{
@@ -233,7 +225,7 @@ void CacheController::disposeOne(Request
 // -------------------------------------------------------------------------
 void CacheController::disposeUser(RequestOptions const & _aUserOptions, bool _bFlushUpdates)
 {
-	osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
+	osl::ClearableMutexGuard aGuard(m_aCacheMap.mutex());
 
 	CFG_TRACE_INFO("CacheController: Disposing data and TreeInfo(s) for user '%s'",
 					OUSTRING2ASCII(_aUserOptions.getEntity()) );
@@ -250,14 +242,14 @@ void CacheController::disposeUser(Reques
 		// so that all options belonging to one user are together
 		// (and that options with only a user set, sort first)
 
-        CacheList::Map aCacheData;
-        m_aCacheList.swap(aCacheData);
+        CacheMap::Map aCacheData;
+        m_aCacheMap.swap(aCacheData);
 
 		// find the lower_bound of all options for the user
-		CacheList::Map::iterator const aFirst = aCacheData.lower_bound(_aUserOptions);
+		CacheMap::Map::iterator const aFirst = aCacheData.lower_bound(_aUserOptions);
 
 		// find the upper_bound of all options for the user (using the lower one)
-		CacheList::Map::iterator aLast = aFirst;
+		CacheMap::Map::iterator aLast = aFirst;
 		while (aLast != aCacheData.end() && aLast->first.getEntity() == sUser)
 			++aLast;
 
@@ -267,7 +259,7 @@ void CacheController::disposeUser(Reques
 
 			bool bHasPendingChanges = false;
 
-			for (CacheList::Map::iterator it = aFirst; it != aLast; ++it)
+			for (CacheMap::Map::iterator it = aFirst; it != aLast; ++it)
 			{
 				CFG_TRACE_INFO_NI("- Found TreeInfo for locale '%s'", OUSTRING2ASCII(it->first.getLocale()) );
 				m_pDisposer->clearTasks(it->first);
@@ -295,7 +287,7 @@ void CacheController::disposeUser(Reques
 			CFG_TRACE_INFO_NI("- No affected TreeInfo found" );
 
         // replace the data into the map
-        m_aCacheList.swap(aCacheData);
+        m_aCacheMap.swap(aCacheData);
 	}
 
 	// got all out of external reach - now dispose/notify without lock
@@ -343,12 +335,11 @@ void CacheController::implDisposeOne(Cac
 
 // -------------------------------------------------------------------------
 CacheController::CacheController(BackendRef const & _xBackend, 
-								 memory::HeapManager & _rCacheHeapManager,
 								 const uno::Reference<uno::XComponentContext>& xContext)
 : m_aNotifier()
 , m_xBackend(_xBackend)
-, m_aCacheList()
-, m_aTemplates(_rCacheHeapManager)
+, m_aCacheMap()
+, m_aTemplates()
 , m_pDisposer()
 , m_pCacheWriter()
 , m_bDisposing(false)
@@ -406,22 +397,7 @@ std::auto_ptr<ISubtree> reduceSubtreeFor
     return aRet;
 }
 #endif
-// -------------------------------------------------------------------------
-
-static
-CacheLocation makeCacheLocation(memory::SegmentAddress const & _aSegment, memory::Heap::Address const & _anAddress)
-{
-    OSL_PRECOND(!_aSegment.isNull() || _anAddress == 0,"ERROR: Got Non-null address for NULL segment ?!");
 
-    CacheLocation aResult;
-
-    aResult.segment = _aSegment;
-    aResult.address = _anAddress;
-
-    OSL_ASSERT(!_aSegment.isNull() || aResult.isNull());
-
-    return aResult;
-}
 // -------------------------------------------------------------------------
 CacheLocation CacheController::loadComponent(ComponentRequest const & _aRequest)
 {
@@ -436,7 +412,6 @@ CacheLocation CacheController::loadCompo
 
     osl::MutexGuard aCacheLineGuard(aCache->mutex());
 
-    data::TreeAddress aResultAddress;
     data::TreeAddress aTemplateResultAdddress;
 
 	OSL_ENSURE(!_aRequest.isForcingReload(),"CacheController: No support for forced requests");
@@ -447,7 +422,7 @@ CacheLocation CacheController::loadCompo
         {
             refreshComponent(_aRequest);
         }
-        aResultAddress = aCache->acquireModule(_aRequest.getComponentName());
+        aCache->acquireModule(_aRequest.getComponentName());
     }
     else
 	{
@@ -459,18 +434,15 @@ CacheLocation CacheController::loadCompo
 
         memory::UpdateAccessor aTargetSpace( aCache->createNewDataSegment(_aRequest.getComponentName()) );
 
-        aResultAddress = aCache->addComponentData(aTargetSpace, aData.instance(), bWithDefaults);
+        aCache->addComponentData(aTargetSpace, aData.instance(), bWithDefaults);
         if (aData.instance().templateData().get()!=NULL)
-        {
-            aTemplateResultAdddress = addTemplates(aData.mutableInstance().componentTemplateData () );
-        }
+            aTemplateResultAdddress = addTemplates(aData.mutableInstance().componentTemplateData() );
+
         // notify the new data to all clients
         m_aNotifier.notifyCreated(_aRequest);
 	}
 
-    return makeCacheLocation( aCache->getDataSegmentAddress(_aRequest.getComponentName()),
-                              aResultAddress.addressValue());
-
+    return aCache->getTreeAddress(_aRequest.getComponentName());
 }
 // -------------------------------------------------------------------------
 
@@ -478,11 +450,10 @@ ComponentResult CacheController::getComp
 												  bool _bAddListenter ) CFG_UNO_THROW_ALL()
 {
     // TODO: Insert check here, if the data is in the cache already - and then clone
-	RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getComponentData()");
-	RTL_LOGFILE_CONTEXT_TRACE1(aLog, "component: %s", RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) );
+    RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getComponentData()");
+    RTL_LOGFILE_CONTEXT_TRACE1(aLog, "component: %s", RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) );
 
-    
-	ComponentResult aRet = this->loadDirectly(_aRequest, _bAddListenter);
+    ComponentResult aRet = this->loadDirectly(_aRequest, _bAddListenter);
 
     return aRet;
 }
@@ -491,8 +462,8 @@ ComponentResult CacheController::getComp
 NodeResult CacheController::getDefaultData(NodeRequest const & _aRequest) CFG_UNO_THROW_ALL(  )
 {
     // TODO: Insert check here, if the data is in the cache already - and then clone
-	RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getDefaultData()");
-	RTL_LOGFILE_CONTEXT_TRACE1(aLog, "path: %s", RTL_LOGFILE_OU2A(_aRequest.getPath().toString()) );
+    RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getDefaultData()");
+    RTL_LOGFILE_CONTEXT_TRACE1(aLog, "path: %s", RTL_LOGFILE_OU2A(_aRequest.getPath().toString()) );
 
     NodeResult aRet = this->loadDefaultsDirectly(_aRequest);
 
@@ -514,7 +485,7 @@ AbsolutePath CacheController::encodeTemp
     aResult.prepend(aTemplateModule);
 //    aResult.prepend(aTemplateRoot);
 
-	return AbsolutePath(aResult);
+    return AbsolutePath(aResult);
 }
 // -------------------------------------------------------------------------
 #if 0
@@ -564,7 +535,7 @@ data::TreeAddress CacheController::addTe
 {
     OSL_PRECOND(_aComponentInstance.data.get(), "addTemplates: Data must not be NULL");
     osl::MutexGuard aGuard(m_aTemplatesMutex);
-    TemplateCacheData::ModuleName aModuleName = _aComponentInstance.name;
+    CacheLine::Name aModuleName = _aComponentInstance.name;
     memory::UpdateAccessor aTemplatesUpdater( m_aTemplates.createDataSegment(aModuleName) );
     AbsolutePath aTemplateLocation = AbsolutePath::makeModulePath(_aComponentInstance.name , AbsolutePath::NoValidate());
     data::TreeAddress aTemplateAddr;
@@ -573,7 +544,7 @@ data::TreeAddress CacheController::addTe
         CFG_TRACE_INFO_NI("CacheController: cache miss for that template - loading from backend");
         aTemplateAddr = m_aTemplates.addTemplates(aTemplatesUpdater, _aComponentInstance );
     }
-    OSL_ASSERT (aTemplateAddr.is());
+    OSL_ASSERT (aTemplateAddr != NULL);
     return aTemplateAddr;
  }
 // -------------------------------------------------------------------------
@@ -591,7 +562,7 @@ CacheLocation CacheController::loadTempl
 
     AbsolutePath aTemplateLocation = encodeTemplateLocation(_aRequest.getTemplateName(), _aRequest.getComponentName());
 
-    TemplateCacheData::ModuleName aModuleName =  aTemplateLocation.getModuleName();
+    CacheLine::Name aModuleName =  aTemplateLocation.getModuleName();
     osl::MutexGuard aGuard(m_aTemplatesMutex);
     memory::Accessor aTemplatesAccessor( m_aTemplates.getDataSegment(aModuleName) );
     AbsolutePath aTemplateParent (aTemplateLocation.getParentPath());
@@ -609,24 +580,23 @@ CacheLocation CacheController::loadTempl
 
     }
     memory::Accessor aTemplateAccessor( m_aTemplates.getDataSegment(aModuleName) );
+#warning unwind locking implications here too ... 'getTemplateTree' ...
     data::TreeAddress aTemplateAddr = m_aTemplates.getTemplateTree(aTemplateAccessor,aTemplateLocation);
-	if (aTemplateAddr.isNull())
-		throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
+    if (aTemplateAddr == NULL)
+        throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
 
-    return makeCacheLocation( m_aTemplates.getDataSegmentAddress(aTemplateLocation.getModuleName()) , aTemplateAddr.addressValue());
+    return m_aTemplates.getTreeAddress(aTemplateLocation.getModuleName());
 }
 // -----------------------------------------------------------------------------
 
 TemplateResult CacheController::getTemplateData(TemplateRequest const & _aRequest)
     CFG_UNO_THROW_ALL()
 {
-	RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getTemplateData()");
-	RTL_LOGFILE_CONTEXT_TRACE2(aLog, "requested template: %s/%s",
-                                    RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) ,
-                                    _aRequest.isComponentRequest() ?
-                                        "*" : RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) );
-
-
+    RTL_LOGFILE_CONTEXT_AUTHOR(aLog, "configmgr::backend::CacheController", "jb99855", "configmgr: CacheController::getTemplateData()");
+    RTL_LOGFILE_CONTEXT_TRACE2(aLog, "requested template: %s/%s",
+			       RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) ,
+			       _aRequest.isComponentRequest() ?
+			       "*" : RTL_LOGFILE_OU2A(_aRequest.getComponentName().toString()) );
 
     AbsolutePath aTemplateLocation = encodeTemplateLocation(_aRequest.getTemplateName(), _aRequest.getComponentName());
 
@@ -638,8 +608,8 @@ TemplateResult CacheController::getTempl
     memory::Accessor aTemplatesAccessor( pTemplatesSegment );
 
     data::TreeAddress aTemplateAddr = m_aTemplates.getTemplateTree(aTemplatesAccessor,aTemplateLocation);
-	if (aTemplateAddr.isNull())
-		throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
+    if (aTemplateAddr == NULL)
+	throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
 
     data::TreeAccessor aTemplateTree(aTemplatesAccessor,aTemplateAddr);
 
@@ -661,7 +631,7 @@ void CacheController::saveAndNotify(Upda
 	    // caller must own a read lock on this cache line
 	    CFG_TRACE_INFO("CacheController: saving an update for '%s'",OUSTRING2ASCII(_anUpdate.getUpdateRoot().toString()));
 
-        CacheRef aCache = m_aCacheList.get(_anUpdate.getOptions());
+        CacheRef aCache = m_aCacheMap.get(_anUpdate.getOptions());
 
 	    OSL_ENSURE(aCache.is(), "No cache data to update in saveAndNotify");
 
@@ -697,11 +667,11 @@ void CacheController::saveAndNotify(Upda
 
 void CacheController::flushPendingUpdates()CFG_UNO_THROW_ALL()
 {
-    osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
-    CacheList::Map aFlushList = m_aCacheList.copy();
+    osl::ClearableMutexGuard aGuard(m_aCacheMap.mutex());
+    CacheMap::Map aFlushList = m_aCacheMap.copy();
     aGuard.clear();
 
-    for (CacheList::Map::iterator it = aFlushList.begin(); it != aFlushList.end(); ++it)
+    for (CacheMap::Map::iterator it = aFlushList.begin(); it != aFlushList.end(); ++it)
         saveAllPendingChanges(it->second,it->first);
 }
 
@@ -754,13 +724,13 @@ bool CacheController::normalizeResult(st
 
 ComponentResult CacheController::loadDirectly(ComponentRequest const & _aRequest, bool _bAddListenter) CFG_UNO_THROW_ALL(  )
 {
-	CFG_TRACE_INFO("CacheController: loading data for component '%s' from the backend", OUSTRING2ASCII(_aRequest.getComponentName().toString()));
+    CFG_TRACE_INFO("CacheController: loading data for component '%s' from the backend", OUSTRING2ASCII(_aRequest.getComponentName().toString()));
 
     AbsolutePath aRequestPath = AbsolutePath::makeModulePath(_aRequest.getComponentName(), AbsolutePath::NoValidate());
 
     NodeRequest aNodeRequest(aRequestPath, _aRequest.getOptions());
 
-	ComponentResult aResult = m_xBackend->getNodeData(_aRequest, this, _bAddListenter?this:NULL);
+    ComponentResult aResult = m_xBackend->getNodeData(_aRequest, this, _bAddListenter?this:NULL);
 
     OSL_PRECOND(aResult.mutableInstance().mutableData().get(), "loadDirectly: Data must not be NULL");
 
@@ -768,7 +738,7 @@ ComponentResult CacheController::loadDir
 
     if (!normalizeResult( aResult.mutableInstance().mutableData(),_aRequest.getOptions()))
     {
-	    CFG_TRACE_ERROR_NI(" - cannot normalized result: failing");
+	CFG_TRACE_ERROR_NI(" - cannot normalized result: failing");
 
         OUString sMsg(RTL_CONSTASCII_USTRINGPARAM("Requested data at '"));
         sMsg += aRequestPath.toString();
@@ -777,7 +747,7 @@ ComponentResult CacheController::loadDir
         throw com::sun::star::container::NoSuchElementException(sMsg,NULL);
     }
 
-	CFG_TRACE_INFO_NI(" - returning normalized defaults");
+    CFG_TRACE_INFO_NI(" - returning normalized defaults");
 
     return aResult;
 }
@@ -785,15 +755,15 @@ ComponentResult CacheController::loadDir
 
 NodeResult CacheController::loadDefaultsDirectly(NodeRequest const & _aRequest) CFG_UNO_THROW_ALL(  )
 {
-	CFG_TRACE_INFO("CacheController: loading defaults for '%s' from the backend", OUSTRING2ASCII(_aRequest.getPath().toString()));
+    CFG_TRACE_INFO("CacheController: loading defaults for '%s' from the backend", OUSTRING2ASCII(_aRequest.getPath().toString()));
 
     NodeResult aResult = m_xBackend->getDefaultData(_aRequest);
 
-	CFG_TRACE_INFO_NI("- loading defaultscompleted - normalizing result");
+    CFG_TRACE_INFO_NI("- loading defaultscompleted - normalizing result");
 
     normalizeResult(aResult.mutableInstance().mutableData(),_aRequest.getOptions());
 
-	CFG_TRACE_INFO_NI(" - returning normalized defaults");
+    CFG_TRACE_INFO_NI(" - returning normalized defaults");
 
     return aResult;
 }
@@ -801,23 +771,23 @@ NodeResult CacheController::loadDefaults
 
 void CacheController::saveDirectly(UpdateRequest const & _anUpdate) CFG_UNO_THROW_ALL(  )
 {
-        m_xBackend->updateNodeData(_anUpdate);
+    m_xBackend->updateNodeData(_anUpdate);
 }
 // -----------------------------------------------------------------------------
 
 void CacheController::savePendingChanges(CacheRef const & _aCache, ComponentRequest const & _aComponent) CFG_UNO_THROW_ALL(  )
 {
-	CFG_TRACE_INFO("CacheController: saving updates for tree: '%s'", OUSTRING2ASCII(_aComponent.getComponentName().toString()));
+    CFG_TRACE_INFO("CacheController: saving updates for tree: '%s'", OUSTRING2ASCII(_aComponent.getComponentName().toString()));
 
-	try
-	{
-		CFG_TRACE_INFO2("CacheController: saving updates for tree: '%s'", OUSTRING2ASCII(_aComponent.getComponentName().toString()));
+    try
+    {
+	CFG_TRACE_INFO2("CacheController: saving updates for tree: '%s'", OUSTRING2ASCII(_aComponent.getComponentName().toString()));
 
-  		std::auto_ptr<SubtreeChange> aChangeData = _aCache->releasePendingChanges(_aComponent.getComponentName());
+	std::auto_ptr<SubtreeChange> aChangeData = _aCache->releasePendingChanges(_aComponent.getComponentName());
 
         if (aChangeData.get())
         {
-			CFG_TRACE_INFO_NI("- found changes - sending to backend");
+	    CFG_TRACE_INFO_NI("- found changes - sending to backend");
 
             AbsolutePath aRootPath = AbsolutePath::makeModulePath(_aComponent.getComponentName(), AbsolutePath::NoValidate());
 
@@ -827,23 +797,23 @@ void CacheController::savePendingChanges
 
             this->saveDirectly(anUpdateSpec);
 
-			CFG_TRACE_INFO_NI("- saving changes completed successfully");
+	    CFG_TRACE_INFO_NI("- saving changes completed successfully");
         }
         else
-			CFG_TRACE_WARNING_NI("- no changes found - cannot save");
-	}
-	catch(uno::Exception& e)
-	{
-            (void)e;
-		CFG_TRACE_ERROR_NI("CacheController: saving tree '%s' failed: %s",
-                                OUSTRING2ASCII(_aComponent.getComponentName().toString()),
-                                OUSTRING2ASCII(e.Message) );
+	    CFG_TRACE_WARNING_NI("- no changes found - cannot save");
+    }
+    catch(uno::Exception& e)
+    {
+	(void)e;
+	CFG_TRACE_ERROR_NI("CacheController: saving tree '%s' failed: %s",
+			   OUSTRING2ASCII(_aComponent.getComponentName().toString()),
+			   OUSTRING2ASCII(e.Message) );
 
-        this->invalidateComponent(_aComponent);
-		CFG_TRACE_INFO_NI("- component data invalidated");
+	this->invalidateComponent(_aComponent);
+	CFG_TRACE_INFO_NI("- component data invalidated");
 
-	    throw;
-	}
+	throw;
+    }
 }
 // -----------------------------------------------------------------------------
 
@@ -853,7 +823,7 @@ bool CacheController::saveAllPendingChan
     CFG_TRACE_INFO("CacheController: Saving all pending changes for cache line");
     OSL_ASSERT(_aCache.is());
 
-    typedef Cache::Data::PendingModuleList PMList;
+    typedef ExtendedCacheData::PendingModuleList PMList;
 
     PMList aPendingModules;
     _aCache->findPendingChangedModules(aPendingModules);
@@ -890,7 +860,7 @@ void CacheController::freeComponent(Comp
                     OUSTRING2ASCII(_aRequest.getOptions().getEntity()),
                     OUSTRING2ASCII(_aRequest.getOptions().getLocale()) );
 
-    CacheRef aCache = m_aCacheList.get(_aRequest.getOptions());
+    CacheRef aCache = m_aCacheMap.get(_aRequest.getOptions());
 
     OSL_ENSURE(aCache.is(), "Releasing a nonexisting module");
 
@@ -911,11 +881,11 @@ void CacheController::dataChanged(const 
 // -----------------------------------------------------------------------------
 void CacheController::refreshAllComponents() CFG_UNO_THROW_ALL()
 {
-    osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
-    CacheList::Map aRefreshList = m_aCacheList.copy();
+    osl::ClearableMutexGuard aGuard(m_aCacheMap.mutex());
+    CacheMap::Map aRefreshList = m_aCacheMap.copy();
     aGuard.clear();
 
-    for (CacheList::Map::iterator i = aRefreshList.begin(); 
+    for (CacheMap::Map::iterator i = aRefreshList.begin(); 
         i != aRefreshList.end(); ++i)
 	{
         if (!i->second->isEmpty())
Index: configmgr/source/treecache/cachecontroller.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachecontroller.hxx,v
retrieving revision 1.10
diff -u -p -u -r1.10 cachecontroller.hxx
--- configmgr/source/treecache/cachecontroller.hxx	8 Sep 2005 04:22:14 -0000	1.10
+++ configmgr/source/treecache/cachecontroller.hxx	5 Jan 2007 22:25:44 -0000
@@ -85,7 +85,7 @@ namespace configmgr
 
     : public ICachedDataProvider
     , public IDirectDataProvider // Refcounted
-	, public INodeDataListener
+    , public INodeDataListener
 	{
         typedef backend::IMergedDataProvider Backend;
         typedef rtl::Reference< Backend > BackendRef;
@@ -96,7 +96,6 @@ namespace configmgr
 		*/
         explicit
         CacheController(BackendRef const & _xBackend, 
-						memory::HeapManager & _rCacheHeapManager,
 						const uno::Reference<uno::XComponentContext>& xContext);
 
     // ICachedDataProvider implementation
@@ -309,8 +308,6 @@ namespace configmgr
 	protected:
 		// ref counted, that's why no public dtor
 		~CacheController();
-
-        memory::HeapManager & getCacheHeapManager() const;
     // implementation 
     private:
         typedef CacheLoadingAccess      Cache;
@@ -364,15 +361,12 @@ namespace configmgr
  
         void closeModules(Cache::DisposeList & _aList, RequestOptions const & _aOptions);
     private:
-        typedef AutoReferenceMap<RequestOptions,Cache,lessRequestOptions>   CacheList;
-        typedef TemplateCacheData TemplateCache;
-
+        typedef AutoReferenceMap<RequestOptions,Cache,lessRequestOptions>   CacheMap;
 
         CacheChangeMulticaster  m_aNotifier;
-		BackendRef			    m_xBackend;  
-
-		CacheList				m_aCacheList; // Map
-		TemplateCache			m_aTemplates;
+	BackendRef		m_xBackend;  
+	CacheMap		m_aCacheMap;
+	TemplateCacheData	m_aTemplates;
 		
         osl::Mutex              m_aTemplatesMutex;
 
Index: configmgr/source/treecache/cachedata.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachedata.cxx,v
retrieving revision 1.7
diff -u -p -u -r1.7 cachedata.cxx
--- configmgr/source/treecache/cachedata.cxx	16 Sep 2006 15:25:09 -0000	1.7
+++ configmgr/source/treecache/cachedata.cxx	5 Jan 2007 22:25:44 -0000
@@ -44,11 +44,8 @@
 #ifndef CONFIGMGR_UPDATEACCESSOR_HXX
 #include "updateaccessor.hxx"
 #endif
-#ifndef CONFIGMGR_NODEADDRESS_HXX
-#include "nodeaddress.hxx"
-#endif
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
+#ifndef INCLUDED_SHARABLE_NODE_HXX
+#include "node.hxx"
 #endif
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #include "nodeaccess.hxx"
@@ -120,15 +117,14 @@ namespace configmgr
 	};
 
 // -----------------------------------------------------------------------------
-    static inline CacheData::ModuleName implExtractModuleName(CacheData::Path const& aConfigPath)
+    static inline CacheLine::Name implExtractModuleName(CacheLine::Path const& aConfigPath)
 	{
 		return aConfigPath.getModuleName();
 	}
 
 // -----------------------------------------------------------------------------
 	
-	CacheData::CacheData(memory::HeapManager & _rHeapManager)
-    : m_rHeapManager(_rHeapManager)
+	CacheData::CacheData()
 	{
 	}
 // -----------------------------------------------------------------------------
@@ -139,13 +135,13 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
 
-	CacheData::ModuleName CacheData::extractModuleName(Path const& _aPath)
+	CacheLine::Name CacheData::extractModuleName(CacheLine::Path const& _aPath)
 	{
 		return implExtractModuleName(_aPath);
 	}
 // -----------------------------------------------------------------------------
 	inline
-    CacheLineRef CacheData::internalGetModule(const ModuleName& _aModuleName ) const
+    CacheLineRef CacheData::internalGetModule(const CacheLine::Name& _aModuleName ) const
 	{
 		OSL_ASSERT(!_aModuleName.isEmpty());
 
@@ -155,14 +151,14 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
 	inline
-    CacheLineRef CacheData::internalGetModule(const Path&  _aPath) const
+    CacheLineRef CacheData::internalGetModule(const CacheLine::Path&  _aPath) const
 	{
 		return internalGetModule( implExtractModuleName(_aPath) );
 	}
 // -----------------------------------------------------------------------------
 
 	inline
-    void CacheData::internalAddModule(const ModuleName& _aName, const ModuleRef & _aModule)
+    void CacheData::internalAddModule(const CacheLine::Name& _aName, const CacheLineRef & _aModule)
 	{
 		//OSL_PRECOND(m_aModules.find(_aName) == m_aModules.end(), "ERROR: Module already present in CacheData");
 
@@ -173,9 +169,9 @@ namespace configmgr
 // -----------------------------------------------------------------------------
 // -----------------------------------------------------------------------------
 
-    CacheLineRef CacheData::internalAttachModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef CacheData::internalAttachModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
 	{
-        CacheLineRef aNewModule = doCreateAttachedModule(this->internalHeapManager(), _aLocation,_aName);
+        CacheLineRef aNewModule = doCreateAttachedModule(_aLocation,_aName);
 
 		internalAddModule( _aName, aNewModule );
 		
@@ -184,7 +180,7 @@ namespace configmgr
 // -----------------------------------------------------------------------------
 
     /// creates a new data segment reference for the given path - creates if necessary
-    memory::Segment * CacheData::attachDataSegment(memory::SegmentAddress const & _aLocation, ModuleName const & _aModule)
+    memory::Segment * CacheData::attachDataSegment(data::TreeAddress _aLocation, CacheLine::Name const & _aModule)
     {
         CacheLineRef aModule = this->internalAttachModule(_aLocation,_aModule);
 
@@ -192,14 +188,14 @@ namespace configmgr
     }
 // -------------------------------------------------------------------------
 
-    CacheLineRef CacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef CacheData::doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
     {
-        return CacheLine::createAttached( _aName, _rHeapManager, _aLocation ); 
+        return CacheLine::createAttached( _aName, _aLocation ); 
     }
 // -----------------------------------------------------------------------------
 
     /// gets a data segment reference for the given path if exists
-    memory::Segment * CacheData::getDataSegment(const ModuleName & _aModule)
+    memory::Segment * CacheData::getDataSegment(const CacheLine::Name & _aModule)
     {
         CacheLineRef aModule = internalGetModule(_aModule);
 
@@ -208,15 +204,15 @@ namespace configmgr
 // -------------------------------------------------------------------------
 
     /// gets a data segment reference for the given path if exists
-    memory::SegmentAddress CacheData::getDataSegmentAddress(const ModuleName & _aModule) const
+    data::TreeAddress CacheData::getTreeAddress(const CacheLine::Name & _aModule) const
     {
         CacheLineRef aModule = internalGetModule(_aModule);
 
-        return aModule.is() ? aModule->getDataSegmentAddress() : memory::SegmentAddress();
+        return aModule.is() ? aModule->getTreeAddress() : NULL;
     }
 // -------------------------------------------------------------------------
         
-    bool CacheData::hasModule(const ModuleName & _aModule) const
+    bool CacheData::hasModule(const CacheLine::Name & _aModule) const
     {
         CacheLineRef aModule = internalGetModule(_aModule);
 
@@ -224,7 +220,7 @@ namespace configmgr
     }
 // -------------------------------------------------------------------------
         
-    bool CacheData::hasModuleDefaults(memory::Accessor const & _aAccessor, const ModuleName & _aModule) const
+    bool CacheData::hasModuleDefaults(memory::Accessor const & _aAccessor, const CacheLine::Name & _aModule) const
     {
         CacheLineRef aModule = internalGetModule(_aModule);
 
@@ -232,19 +228,19 @@ namespace configmgr
     }
 // -------------------------------------------------------------------------
 
-    data::TreeAddress CacheData::internalGetPartialTree(memory::Accessor const & _aAccessor, const Path& aComponentName ) const
-	{
-		CacheLineRef xModule = internalGetModule(aComponentName);
+    data::TreeAddress CacheData::internalGetPartialTree(memory::Accessor const & _aAccessor, const CacheLine::Path& aComponentName ) const
+    {
+	CacheLineRef xModule = internalGetModule(aComponentName);
 		
-		if ( !xModule.is() )
-            return data::TreeAddress();
+	if ( !xModule.is() )
+            return NULL;
 
         data::TreeAddress pSubtree = xModule->getPartialTree(_aAccessor,aComponentName);
 
-		OSL_ENSURE( pSubtree.isNull() || xModule->clientReferences() != 0 , 
+		OSL_ENSURE( pSubtree == NULL || xModule->clientReferences() != 0 , 
 					"WARNING: returning subtree from module without clients\n" );
 #ifdef CFG_ENABLE_TRACING
-		if( pSubtree.is() && xModule->clientReferences() == 0) 
+		if( pSubtree != NULL && xModule->clientReferences() == 0) 
 		{
 			CFG_TRACE_WARNING("CacheData data: returning subtree %s from module without clients", OUSTRING2ASCII( aComponentName.toString() ) );
 		}
@@ -253,7 +249,7 @@ namespace configmgr
 		return pSubtree;	
 	}
 // -----------------------------------------------------------------------------
-    data::NodeAddress CacheData::internalGetNode(memory::Accessor const & _aAccessor, const Path& aComponentName ) const
+    data::NodeAddress CacheData::internalGetNode(memory::Accessor const & _aAccessor, const CacheLine::Path& aComponentName ) const
 	{
 		CacheLineRef xModule = internalGetModule(aComponentName);
 		
@@ -265,10 +261,10 @@ namespace configmgr
 
         data::NodeAddress pNode = xModule->getNode(_aAccessor,aComponentName);
 
-		OSL_ENSURE( pNode.isNull() || xModule->clientReferences() != 0, 
+		OSL_ENSURE( pNode == NULL || xModule->clientReferences() != 0, 
 					"WARNING: returning node from module without clients\n" );
 	#ifdef CFG_ENABLE_TRACING
-		if( pNode.is() && xModule->clientReferences() == 0) 
+		if( pNode != NULL && xModule->clientReferences() == 0) 
 		{
 			CFG_TRACE_WARNING("CacheData data: returning node %s from module without clients", OUSTRING2ASCII( aComponentName.toString() ) );
 		}
@@ -278,35 +274,34 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
 // -----------------------------------------------------------------------------	
-    data::TreeAddress CacheData::acquireModule(ModuleName const & _aModule)
-	{
+    bool CacheData::acquireModule(CacheLine::Name const & _aModule)
+    {
         CacheLineRef xModule = internalGetModule(_aModule);
 
-		CacheLineClientRef aClientRef(xModule);
-
-        data::TreeAddress aModuleAddr = xModule.is() ? xModule->getModuleRootAddress() : data::TreeAddress();
-
-		if (aModuleAddr.is()) 
+        if (xModule.is())
+        {
+            CacheLineClientRef aClientRef(xModule);
             aClientRef.keep();
-
-        return aModuleAddr;
-	}
+        }
+        
+        return xModule.is();
+    }
 // -----------------------------------------------------------------------------	
-    data::NodeAddress CacheData::acquireNode(memory::Accessor const & _aAccessor, Path const& _aPath)
-	{
-		CacheLineClientRef aClientRef(internalGetModule(_aPath));
+    data::NodeAddress CacheData::acquireNode(memory::Accessor const & _aAccessor, CacheLine::Path const& _aPath)
+    {
+	CacheLineClientRef aClientRef(internalGetModule(_aPath));
 
         data::NodeAddress aNodeAddr = internalGetNode(_aAccessor,_aPath);
 
-        if (sharable::Node const * pNode = data::NodeAccess::access(aNodeAddr,_aAccessor))
-		{
+        if (sharable::Node const * pNode = aNodeAddr)
+	{
             if (pNode->isValue())
                 aNodeAddr = data::NodeAddress(); // invalid: cannot acquire single value
-		}
+	}
         else
-            OSL_ASSERT( !aNodeAddr.is() );
+            OSL_ASSERT( aNodeAddr == NULL );
 
-		if (aNodeAddr.is()) 
+		if (aNodeAddr != NULL) 
             aClientRef.keep();
 
         return aNodeAddr;
@@ -327,12 +322,12 @@ namespace configmgr
         if (!xModule.is()) return false;
 
         // make sure to keep the module alive
-		CacheLineClientRef( xModule ).keep();
+	CacheLineClientRef( xModule ).keep();
 
-        data::TreeAddress aResultTree = xModule->insertDefaults(_aAccessToken, _aDefaultInstance);
+	data::TreeAddress aResultTree = xModule->insertDefaults(_aAccessToken, _aDefaultInstance);
 
-		return aResultTree.is();
-	}
+	return aResultTree != NULL;
+    }
 // -----------------------------------------------------------------------------
 
     void CacheData::applyUpdate(memory::UpdateAccessor & _aAccessToken, backend::UpdateInstance & _anUpdate ) CFG_UNO_THROW_RTE(  )
@@ -340,7 +335,7 @@ namespace configmgr
 		// request the subtree, atleast one level must exist!
         data::NodeAddress aNodeAddr = internalGetNode(_aAccessToken.accessor(),_anUpdate.root().location());
 
-		if (aNodeAddr.is())
+		if (aNodeAddr != NULL)
 		{
             applyUpdateToTree(*_anUpdate.data(),_aAccessToken,aNodeAddr);
 		}
@@ -355,18 +350,18 @@ namespace configmgr
 		}
 	}
 // -----------------------------------------------------------------------------	
-    CacheLine::RefCount CacheData::releaseModule( ModuleName const & _aModule, bool _bKeepDeadModule )
+    oslInterlockedCount CacheData::releaseModule( CacheLine::Name const & _aModule, bool _bKeepDeadModule )
 	{
 		CacheLineRef xModule = internalGetModule(_aModule);
 
-		const CacheLine::RefCount c_nErrorCount = -1;
+		const oslInterlockedCount c_nErrorCount = -1;
 		
 		OSL_ENSURE( xModule.is(), "ERROR: Releasing non-existent subtree");
 		if ( !xModule.is()) return c_nErrorCount;
 		
 		OSL_ENSURE( xModule->clientReferences() > 0, "ERROR: Releasing non-referenced subtree");
 
-		CacheLine::RefCount nResult = xModule->clientRelease();
+		oslInterlockedCount nResult = xModule->clientRelease();
 
         if (nResult == 0 && !_bKeepDeadModule)
         {
@@ -376,25 +371,25 @@ namespace configmgr
 	}
 
 // -----------------------------------------------------------------------------
-    data::TreeAddress CacheData::getTemplateTree( memory::Accessor const & _aAccessor, Path const& aTemplateName ) const
+    data::TreeAddress CacheData::getTemplateTree( memory::Accessor const & _aAccessor, CacheLine::Path const& aTemplateName ) const
 	{
 		return internalGetPartialTree(_aAccessor,aTemplateName);
 	}
 // -----------------------------------------------------------------------------
-    data::NodeAddress CacheData::getNode(memory::Accessor const & _aAccessor, const Path& _rPath)
+    data::NodeAddress CacheData::getNode(memory::Accessor const & _aAccessor, const CacheLine::Path& _rPath)
 	{
 		return internalGetNode(_aAccessor,_rPath);
 	}
 // -----------------------------------------------------------------------------
-    bool CacheData::hasNode(memory::Accessor const & _aAccessor, const Path& _rPath) const
+    bool CacheData::hasNode(memory::Accessor const & _aAccessor, const CacheLine::Path& _rPath) const
 	{
-		return internalGetNode(_aAccessor,_rPath).is();
+		return internalGetNode(_aAccessor,_rPath) != NULL;
 	}
 // -----------------------------------------------------------------------------
 // -----------------------------------------------------------------------------
 
     /// gets a data segment reference for the given path - creates if necessary
-    memory::Segment * TemplateCacheData::createDataSegment(ModuleName const & _aModule)
+    memory::Segment * TemplateCacheData::createDataSegment(CacheLine::Name const & _aModule)
     {
         CacheLineRef aModule = implNewCacheLine(_aModule);
 
@@ -407,12 +402,12 @@ namespace configmgr
 	{
         OSL_PRECOND(_aComponentInstance.data.get(), "addTemplates: Data must not be NULL");
         // we should already have the module in cache !
-		ModuleName aModuleName ( _aComponentInstance.name); 
+		CacheLine::Name aModuleName ( _aComponentInstance.name); 
         CacheLineRef xModule = internalGetModule(aModuleName);
 
 		OSL_ENSURE( xModule.is(), "ExtendedCacheData::addTemplates: No module to add the templates to - where did the data segment come from ?");
 		
-        if (!xModule.is()) return data::TreeAddress();
+        if (!xModule.is()) return NULL;
 
         // make sure to keep the module alive
 		CacheLineClientRef( xModule ).keep();
@@ -423,25 +418,23 @@ namespace configmgr
 
         data::TreeAddress aResult = xModule->setComponentData(_aUpdateToken, _aComponentInstance, true);
         
-        OSL_ASSERT(aResult.is());
+        OSL_ASSERT(aResult != NULL);
 
-		return aResult;
-	}
+	return aResult;
+    }
 // -----------------------------------------------------------------------------
 
-    CacheLineRef TemplateCacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef TemplateCacheData::doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
     {
-        CacheLineRef aNewModule = 
-            CacheLine::createAttached(_aName, _rHeapManager, _aLocation);
+        CacheLineRef aNewModule =  CacheLine::createAttached(_aName, _aLocation);
 
         return aNewModule.get();
     }
 // -----------------------------------------------------------------------------
 
-	CacheLineRef TemplateCacheData::implNewCacheLine(const ModuleName& _aModule) CFG_UNO_THROW_RTE(  )
+	CacheLineRef TemplateCacheData::implNewCacheLine(const CacheLine::Name& _aModule) CFG_UNO_THROW_RTE(  )
 	{
-        CacheLineRef aNewModule = 
-            CacheLine::createNew(_aModule, this->internalHeapManager());
+        CacheLineRef aNewModule = CacheLine::createNew(_aModule);
 
 		internalAddModule( _aModule, aNewModule.get() );
 
@@ -459,19 +452,18 @@ namespace configmgr
 
 // -----------------------------------------------------------------------------
 
-    CacheLineRef ExtendedCacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef ExtendedCacheData::doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
     {
         ExtendedCacheLineRef aNewModule = 
-            ExtendedCacheLine::createAttached(_aName, _rHeapManager, _aLocation);
+            ExtendedCacheLine::createAttached(_aName, _aLocation);
 
         return CacheLineRef( aNewModule.get() );
     }
 // -----------------------------------------------------------------------------
 
-	ExtendedCacheLineRef ExtendedCacheData::implNewCacheLine(const ModuleName& _aModule) CFG_UNO_THROW_RTE(  )
+	ExtendedCacheLineRef ExtendedCacheData::implNewCacheLine(const CacheLine::Name& _aModule) CFG_UNO_THROW_RTE(  )
 	{
-        ExtendedCacheLineRef aNewModule = 
-            ExtendedCacheLine::createNew(_aModule, this->internalHeapManager());
+        ExtendedCacheLineRef aNewModule = ExtendedCacheLine::createNew(_aModule);
 
 		internalAddModule( _aModule, aNewModule.get() );
 
@@ -480,7 +472,7 @@ namespace configmgr
 // -----------------------------------------------------------------------------
 
     /// gets a data segment reference for the given path - creates if necessary
-    memory::Segment * ExtendedCacheData::createDataSegment(ModuleName const & _aModule)
+    memory::Segment * ExtendedCacheData::createDataSegment(CacheLine::Name const & _aModule)
     {
         ExtendedCacheLineRef aModule = implNewCacheLine(_aModule);
 
@@ -499,18 +491,18 @@ namespace configmgr
 		
         OSL_ENSURE( xModule.is(), "ExtendedCacheData::addComponentData: No module to add the subtree to - where did the data segment come from ?");
 		
-        if (!xModule.is()) return data::TreeAddress();
+        if (!xModule.is()) return NULL;
 
 		CacheLineClientRef aClientRef( xModule );
 
         data::TreeAddress aResult = xModule->setComponentData(_aUpdateToken,_aComponentInstance.componentNodeData(), _bWithDefaults);
 
-        OSL_ASSERT(aResult.is());
+        OSL_ASSERT(aResult != NULL);
 
-		if (aResult.is()) aClientRef.keep();
+	if (aResult != NULL) aClientRef.keep();
 
-		return aResult;
-	}
+	return aResult;
+    }
 // -----------------------------------------------------------------------------
 
     void ExtendedCacheData::addPending(backend::ConstUpdateInstance const & _anUpdate) CFG_UNO_THROW_RTE(  )
@@ -529,7 +521,7 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
     
-    std::auto_ptr<SubtreeChange> ExtendedCacheData::releasePending(ModuleName const& _aModule)
+    std::auto_ptr<SubtreeChange> ExtendedCacheData::releasePending(CacheLine::Name const& _aModule)
 	{
 		ExtendedCacheLineRef xModule = implExtended(internalGetModule(_aModule));
 
@@ -548,12 +540,13 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------	
         
-    bool ExtendedCacheData::hasPending(ModuleName const & _aModule)
+    bool ExtendedCacheData::hasPending(CacheLine::Name const & _aModule)
     {		
-		ExtendedCacheLineRef xModule = implExtended(internalGetModule(_aModule));
+        ExtendedCacheLineRef xModule = implExtended(internalGetModule(_aModule));
 
-        return xModule.is() && xModule->hasPending();
+	return xModule.is() && xModule->hasPending();
     }
+
 // -----------------------------------------------------------------------------	
         
     void ExtendedCacheData::findPendingModules( PendingModuleList & _rPendingList )
Index: configmgr/source/treecache/cachedata.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachedata.hxx,v
retrieving revision 1.7
diff -u -p -u -r1.7 cachedata.hxx
--- configmgr/source/treecache/cachedata.hxx	8 Sep 2005 04:22:46 -0000	1.7
+++ configmgr/source/treecache/cachedata.hxx	5 Jan 2007 22:25:44 -0000
@@ -53,7 +53,7 @@
 namespace configmgr
 {
 ////////////////////////////////////////////////////////////////////////////////
-	using ::rtl::OUString;
+    using ::rtl::OUString;
 
     namespace backend
     {
@@ -70,43 +70,38 @@ namespace configmgr
 	class CacheData			
 	{
 	public:
-        typedef CacheLine        Module;
-        typedef CacheLineRef     ModuleRef;
-        typedef CacheLine::Path     Path;
-        typedef CacheLine::Name     ModuleName;
-	public:
-		CacheData(memory::HeapManager & _rHeapManager);
+		CacheData();
 		virtual ~CacheData();
 
 		/// retrieve the module tree name for the given path
-		static ModuleName extractModuleName(Path const& _aPath);
+		static CacheLine::Name extractModuleName(CacheLine::Path const& _aPath);
 
         /// check if the given module exists already (and is not empty)
-        bool hasModule(ModuleName const & _aModule) const;
+        bool hasModule(CacheLine::Name const & _aModule) const;
         /// checks if the given module exists and has defaults available
-        bool hasModuleDefaults(memory::Accessor const & _aAccessor, ModuleName const & _aModule) const;
+        bool hasModuleDefaults(memory::Accessor const & _aAccessor, CacheLine::Name const & _aModule) const;
 
         /// creates a new data segment reference for the given path if exists
-        memory::Segment * attachDataSegment(memory::SegmentAddress const & _aLocation, ModuleName const & _aModule);
+        memory::Segment * attachDataSegment(data::TreeAddress _aLocation, CacheLine::Name const & _aModule);
         /// gets a data segment reference for the given path if it exists
-        memory::Segment * getDataSegment(ModuleName const & _aModule);
-        /// gets a data segment address for the given module if it exists
-        memory::SegmentAddress getDataSegmentAddress(ModuleName const & _aModule) const;
+        memory::Segment * getDataSegment(CacheLine::Name const & _aModule);
+        /// gets a tree address for the given module if it exists
+        data::TreeAddress getTreeAddress(CacheLine::Name const & _aModule) const;
 
         /// checks whether a certain node exists in the tree
-        bool  hasNode(memory::Accessor const & _aAccessor, Path const & _aLocation) const;
+        bool  hasNode(memory::Accessor const & _aAccessor, CacheLine::Path const & _aLocation) const;
 
 		/// retrieve the given node without changing its ref count
-		data::NodeAddress   getNode(memory::Accessor const & _aAccessor, Path const & _rPath);
+		data::NodeAddress   getNode(memory::Accessor const & _aAccessor, CacheLine::Path const & _rPath);
 		/// retrieve the given template tree without changing its ref count
-		data::TreeAddress	getTemplateTree(memory::Accessor const & _aAccessor, Path const & aTemplateName ) const;
+		data::TreeAddress	getTemplateTree(memory::Accessor const & _aAccessor, CacheLine::Path const & aTemplateName ) const;
 
 		/// retrieve the subtree at _aPath and clientAcquire() it
-        data::NodeAddress acquireNode(memory::Accessor const & _aAccessor, Path const & _aPath ); 
-		/// retrieve the subtree at _aPath and clientAcquire() it
-        data::TreeAddress acquireModule( ModuleName const & _aModule ); 
+        data::NodeAddress acquireNode(memory::Accessor const & _aAccessor, CacheLine::Path const & _aPath ); 
+		/// retrieve the subtree at _aPath and clientAcquire() it, return true on success
+        bool acquireModule( CacheLine::Name const & _aModule ); 
 		/// clientRelease() the tree at aComponentName, and return the resulting reference count
-        CacheLine::RefCount releaseModule( ModuleName const & _aModule, bool _bKeepDeadModule = false ); 
+        oslInterlockedCount releaseModule( CacheLine::Name const & _aModule, bool _bKeepDeadModule = false ); 
 
         bool insertDefaults( memory::UpdateAccessor& _aAccessToken, 
                              backend::NodeInstance const & _aDefaultInstance
@@ -117,27 +112,23 @@ namespace configmgr
                             backend::UpdateInstance & _anUpdate) CFG_UNO_THROW_RTE(  );
 
 		// low-level interface for cache management
-        typedef std::map<ModuleName, ModuleRef> ModuleList;
+        typedef std::map<CacheLine::Name, CacheLineRef> ModuleList;
 		ModuleList& accessModuleList() { return m_aModules; }
 
-        memory::HeapManager & getHeapManager() const { return m_rHeapManager; }
 	protected:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual CacheLineRef doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
 
-        data::TreeAddress internalGetPartialTree(memory::Accessor const & _aAccessor, Path const & _aPath ) const;
-		data::NodeAddress internalGetNode(memory::Accessor const & _aAccessor, const Path& _rPath) const;
+        data::TreeAddress internalGetPartialTree(memory::Accessor const & _aAccessor, CacheLine::Path const & _aPath ) const;
+		data::NodeAddress internalGetNode(memory::Accessor const & _aAccessor, const CacheLine::Path& _rPath) const;
 
-        ModuleRef internalAttachModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
-        void internalAddModule(ModuleName const & _aName, ModuleRef const & _aModule);
+        CacheLineRef internalAttachModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
+        void internalAddModule(CacheLine::Name const & _aName, CacheLineRef const & _aModule);
 
-		ModuleRef internalGetModule(const ModuleName& _aName) const;
-		ModuleRef internalGetModule(const Path& _aLocation) const;
+		CacheLineRef internalGetModule(const CacheLine::Name& _aName) const;
+		CacheLineRef internalGetModule(const CacheLine::Path& _aLocation) const;
 
-        memory::HeapManager & internalHeapManager() { return m_rHeapManager; }
 	private:
 		ModuleList m_aModules;
-
-        memory::HeapManager & m_rHeapManager;
 	};
 ////////////////////////////////////////////////////////////////////////////////
 	/** A collection of CacheLines for templates
@@ -146,13 +137,12 @@ namespace configmgr
     class TemplateCacheData : public CacheData	
 	{
 	public:
-		TemplateCacheData(memory::HeapManager & _rHeapManager)
-        : CacheData(_rHeapManager)
+		TemplateCacheData() : CacheData()
         {
         }
 
         /// gets a data segment reference for the given path - creates if necessary 
-        memory::Segment * createDataSegment(ModuleName const & _aModule);
+        memory::Segment * createDataSegment(CacheLine::Name const & _aModule);
 
 		/** add the given template tree at the given location,
 			return the tree that is now pertinent and clientAcquire() it once
@@ -162,9 +152,9 @@ namespace configmgr
                                        ) CFG_UNO_THROW_RTE();
 
 	private:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual CacheLineRef doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
 
-		CacheLineRef implNewCacheLine(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
+		CacheLineRef implNewCacheLine(CacheLine::Name const & _aModule) CFG_UNO_THROW_RTE(  );
 	};
 //-----------------------------------------------------------------------------
 	/** A collection of CacheLines
@@ -173,13 +163,12 @@ namespace configmgr
     class ExtendedCacheData : public CacheData	
 	{
 	public:
-		ExtendedCacheData(memory::HeapManager & _rHeapManager)
-        : CacheData(_rHeapManager)
+		ExtendedCacheData() : CacheData()
         {
         }
 
         /// gets a data segment reference for the given path - creates if necessary 
-        memory::Segment * createDataSegment(ModuleName const & _aModule);
+        memory::Segment * createDataSegment(CacheLine::Name const & _aModule);
 
 		/** add the given subtree at the given location,
 			return the tree that is now pertinent and clientAcquire() it once
@@ -189,22 +178,22 @@ namespace configmgr
                                             bool _bWithDefaults
                                            ) CFG_UNO_THROW_RTE();
 
-		typedef std::vector< ModuleName >  PendingModuleList;
+		typedef std::vector< CacheLine::Name >  PendingModuleList;
         /// find the modules having pending changes
-        bool hasPending(ModuleName const & _aModule);
+        bool hasPending(CacheLine::Name const & _aModule);
         /// find the modules having pending changes
         void findPendingModules( PendingModuleList & _rPendingList );
 
 		/// add or merge the given subtreechange at the given location
 		void addPending(backend::ConstUpdateInstance const & _anUpdate) CFG_UNO_THROW_RTE(  );
 		/// remove and return pending changes for the given component
-		std::auto_ptr<SubtreeChange> releasePending(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
+		std::auto_ptr<SubtreeChange> releasePending(CacheLine::Name const & _aModule) CFG_UNO_THROW_RTE(  );
 	private:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual CacheLineRef doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
 
-		ExtendedCacheLineRef implNewCacheLine(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
+		ExtendedCacheLineRef implNewCacheLine(CacheLine::Name const & _aModule) CFG_UNO_THROW_RTE(  );
 
-		ExtendedCacheLineRef implExtended(ModuleRef const & _aSimpleRef) const;
+		ExtendedCacheLineRef implExtended(CacheLineRef const & _aSimpleRef) const;
 	};
 //-----------------------------------------------------------------------------
 	
Index: configmgr/source/treecache/cachefactory.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachefactory.cxx,v
retrieving revision 1.8
diff -u -p -u -r1.8 cachefactory.cxx
--- configmgr/source/treecache/cachefactory.cxx	16 Sep 2006 15:25:24 -0000	1.8
+++ configmgr/source/treecache/cachefactory.cxx	5 Jan 2007 22:25:44 -0000
@@ -66,12 +66,10 @@ namespace configmgr
 
         if (_xBackend.is())
         {
-            memory::HeapManager & rHeap = memory::cacheHeap();
-
             rtl::Reference< backend::ICachedDataProvider > xLoader
-                = new backend::CacheController(_xBackend.get(),rHeap, _xContext);
+                = new backend::CacheController(_xBackend.get(), _xContext);
 
-            xCache.set( new TreeManager(xLoader.get(),rHeap) );
+            xCache.set( new TreeManager(xLoader.get()) );
         }
 
         return xCache;
Index: configmgr/source/treecache/cacheline.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheline.cxx,v
retrieving revision 1.9
diff -u -p -u -r1.9 cacheline.cxx
--- configmgr/source/treecache/cacheline.cxx	16 Sep 2006 15:25:36 -0000	1.9
+++ configmgr/source/treecache/cacheline.cxx	5 Jan 2007 22:25:45 -0000
@@ -80,48 +80,35 @@ namespace configmgr
 
 // -----------------------------------------------------------------------------	
 
-    CacheLine::CacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl)
-    : m_storage(_rHeapImpl  )
-    , m_base()
+    CacheLine::CacheLine(Name const & _aModuleName)
+    : m_storage()
+    , m_base(NULL)
     , m_name(_aModuleName)
     , m_nDataRefs(0)
 	{
 	}
 // -----------------------------------------------------------------------------	
-	
-    CacheLine::CacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aSegment)
-    : m_storage(_rHeapImpl,_aSegment.id)
-    , m_base( memory::Pointer(_aSegment.base) )
+
+    CacheLine::CacheLine(Name const & _aModuleName, data::TreeAddress _pSegment)
+    : m_storage()
+    , m_base(_pSegment)
     , m_name(_aModuleName)
     , m_nDataRefs(0)
 	{
 	}
-// -----------------------------------------------------------------------------
-
-    memory::SegmentAddress CacheLine::getDataSegmentAddress() const
-    {
-        memory::SegmentAddress aResult;
-
-        aResult.id      = m_storage.getId();
-        aResult.base    = m_base.addressValue();
-
-        return aResult;
-    }
 
 // -----------------------------------------------------------------------------
 
     void CacheLine::setBase(data::TreeAddress _base)
-	{
-        OSL_PRECOND(!m_base.is(), "CacheLine: Data base address was already set");
-        OSL_PRECOND(  _base.is(), "CacheLine: Cannot set NULL base address");
+    {
+        OSL_PRECOND(m_base == NULL, "CacheLine: Data base address was already set");
+        OSL_PRECOND( _base != NULL, "CacheLine: Cannot set NULL base address");
         m_base = _base;
     }
 // -----------------------------------------------------------------------------
    
     CacheLineRef CacheLine::createAttached( Name const & _aModuleName, 
-                                            memory::HeapManager & _rHeapImpl, 
-                                            memory::SegmentAddress const & _aSegment
+                                            data::TreeAddress _aSegment
                                           ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -129,20 +116,19 @@ namespace configmgr
 			OSL_ENSURE(false, "Cannot make a cache line without a name");
 			return NULL;
 		}
-		if (_aSegment.isNull())
+		if (_aSegment == NULL)
 		{
 			OSL_ENSURE(false, "Cannot attach a cache line to a NULL segment");
 			return NULL;
 		}
 
-		CacheLineRef xResult = new CacheLine(_aModuleName,_rHeapImpl,_aSegment);
+		CacheLineRef xResult = new CacheLine(_aModuleName,_aSegment);
 
 		return xResult;
 	}
 // -----------------------------------------------------------------------------
  
-    CacheLineRef CacheLine::createNew(  Name const & _aModuleName, 
-                                        memory::HeapManager & _rHeapImpl
+    CacheLineRef CacheLine::createNew(  Name const & _aModuleName
                                       ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -151,7 +137,7 @@ namespace configmgr
 			return NULL;
 		}
 
-		CacheLineRef xResult = new CacheLine(_aModuleName,_rHeapImpl);
+		CacheLineRef xResult = new CacheLine(_aModuleName);
 
 		return xResult;
 	}
@@ -168,25 +154,25 @@ namespace configmgr
         data::SetNodeAccess aParentSet( internalGetNode(_aAccessor, aConfigName.getParentPath()) );
 
         if (aParentSet.isValid())
-            return aParentSet.getElementTree(aConfigName.getLocalName().getName()).address();
+            return aParentSet.getElementTree(aConfigName.getLocalName().getName());
         else
-            return data::TreeAddress();
+            return NULL;
 	}
 // -----------------------------------------------------------------------------
   
     bool CacheLine::hasDefaults(memory::Accessor const & _anAccessor) const
-	{
-		if ( !m_base.is() ) return false; // cannot get defaults without data
+    {
+	if ( m_base != NULL ) return false; // cannot get defaults without data
 
         data::TreeAccessor aModuleTree(_anAccessor, m_base);
-		OSL_ASSERT( aModuleTree.isValid());
+	OSL_ASSERT( aModuleTree.isValid());
         
         return aModuleTree.data().hasDefaultsAvailable();
     }
 // -----------------------------------------------------------------------------
     data::NodeAccess CacheLine::internalGetNode(memory::Accessor const & _anAccessor, Path const& aConfigName) const
-	{
-		OSL_ENSURE( m_base.is(), "Cannot get a node from a dataless module");
+    {
+	OSL_ENSURE( m_base != NULL, "Cannot get a node from a dataless module");
 
         data::TreeAccessor aModuleTree(_anAccessor, m_base);
 		OSL_ASSERT( aModuleTree.isValid());
@@ -196,7 +182,7 @@ namespace configmgr
 
 		Path::Iterator it = aConfigName.begin();
 		OSL_ENSURE( it != aConfigName.end(), "Empty Path can't match any module");
-		OSL_ENSURE( aNode.getName() == it->getInternalName(), "Module part in config path does not match selected CacheLine");
+		OSL_ENSURE( aNode.isValid() && aNode.getName() == it->getInternalName(), "Module part in config path does not match selected CacheLine");
 
         // find child of node
         // might be done using a visitor
@@ -209,10 +195,10 @@ namespace configmgr
 // -----------------------------------------------------------------------------
    
     data::NodeAddress CacheLine::getNode(memory::Accessor const & _aAccessor, Path const& aConfigName) const
-	{
+    {
         data::NodeAccess aNode = internalGetNode(_aAccessor, aConfigName);
-        return aNode.address();
-	}
+        return aNode;
+    }
 // -------------------------------------------------------------------------
 
     data::TreeAddress CacheLine::setComponentData( memory::UpdateAccessor& _aAccessToken,
@@ -223,9 +209,9 @@ namespace configmgr
 		OSL_PRECOND(_aComponentInstance.data.get(), "CacheLine::insertDefaults: inserting NULL defaults !");
         OSL_PRECOND(_aComponentInstance.name == this->getModuleName(),"Data location does not match module");
 	
-        OSL_PRECOND(!base().is(), "Data is already loaded");
+        OSL_PRECOND(base() == NULL, "Data is already loaded");
 
-        if (!base().is()) // no data yet
+        if (base() == NULL) // no data yet
         {
             this->setBase( data::buildTree(_aAccessToken, _aComponentInstance.data->getName(), *_aComponentInstance.data, _bWithDefaults) );
         }
@@ -242,9 +228,9 @@ namespace configmgr
         OSL_PRECOND(_aDefaultInstance.root().isModuleRoot(), "Should have complete component to fill tree with defaults");
         OSL_PRECOND(_aDefaultInstance.root().getModuleName() == this->getModuleName(),"Data location does not match module");
 
-        OSL_PRECOND(m_base.is(), "Data must already be loaded to insert defaults");
+        OSL_PRECOND(m_base != NULL, "Data must already be loaded to insert defaults");
 
-        if (m_base.is()) 
+        if (m_base != NULL) 
         {
             data::mergeDefaults(_aAccessToken,m_base,*_aDefaultInstance.data());
         }
@@ -254,17 +240,17 @@ namespace configmgr
 // -----------------------------------------------------------------------------	
 // -----------------------------------------------------------------------------	
 
-    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl)
-    : CacheLine(_aModuleName,_rHeapImpl)
+    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName)
+    : CacheLine(_aModuleName)
     , m_pPending()
 	{
 	}
 
 // -----------------------------------------------------------------------------	
 
-    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                                            memory::SegmentAddress const & _aSegment)
-    : CacheLine(_aModuleName,_rHeapImpl,_aSegment)
+    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName,
+                                         data::TreeAddress _aSegment)
+    : CacheLine(_aModuleName,_aSegment)
     , m_pPending()
 	{
 	}
@@ -272,8 +258,7 @@ namespace configmgr
 // -----------------------------------------------------------------------------
   
     ExtendedCacheLineRef ExtendedCacheLine::createAttached( Name const & _aModuleName, 
-                                                            memory::HeapManager & _rHeapImpl, 
-                                                            memory::SegmentAddress const & _aSegment
+                                                            data::TreeAddress _aSegment
                                                           ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -281,20 +266,19 @@ namespace configmgr
 			OSL_ENSURE(false, "Cannot make a cache line without a name");
 			return NULL;
 		}
-		if (_aSegment.isNull())
+		if (_aSegment == NULL)
 		{
 			OSL_ENSURE(false, "Cannot attach a cache line to a NULL segment");
 			return NULL;
 		}
 
-		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_rHeapImpl,_aSegment);
+		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_aSegment);
 
 		return xResult;
 	}
 // -----------------------------------------------------------------------------
  
-    ExtendedCacheLineRef ExtendedCacheLine::createNew(  Name const & _aModuleName, 
-                                                        memory::HeapManager & _rHeapImpl
+ExtendedCacheLineRef ExtendedCacheLine::createNew(  Name const & _aModuleName
                                                       ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -303,7 +287,7 @@ namespace configmgr
 			return NULL;
 		}
 
-		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_rHeapImpl);
+		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName);
 
 		return xResult;
 	}
Index: configmgr/source/treecache/cacheline.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheline.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 cacheline.hxx
--- configmgr/source/treecache/cacheline.hxx	8 Sep 2005 04:23:30 -0000	1.5
+++ configmgr/source/treecache/cacheline.hxx	5 Jan 2007 22:25:45 -0000
@@ -36,9 +36,6 @@
 #ifndef CONFIGMGR_CACHELINE_HXX
 #define CONFIGMGR_CACHELINE_HXX
 
-#ifndef CONFIGMGR_TREEADDRESS_HXX
-#include "treeaddress.hxx"
-#endif
 #ifndef CONFIGMGR_SEGMENT_HXX
 #include "segment.hxx"
 #endif
@@ -51,6 +48,9 @@
 #ifndef CONFIGMGR_UTILITY_HXX_
 #include "utility.hxx"
 #endif
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 
 #ifndef _OSL_INTERLOCK_H_
 #include <osl/interlck.h>
@@ -67,37 +67,31 @@ namespace configmgr
 ////////////////////////////////////////////////////////////////////////////////
 	using ::rtl::OUString;
 
-    namespace data { class NodeAddress; class TreeAddress; class NodeAccess; }
+    namespace data { 
+        /* class NodeAddress; */ class NodeAccess;
+    }
 ////////////////////////////////////////////////////////////////////////////////
 	/** This object represents a cache line for a single configuration tree
 	*/
     class CacheLine : public salhelper::SimpleReferenceObject, Noncopyable
 	{
 	public:
-        typedef oslInterlockedCount RefCount;
-
         typedef configuration::Name         Name;
         typedef configuration::AbsolutePath Path;
 
         // create a new CacheLine for the given component name
         static rtl::Reference<CacheLine> 
-            createNew( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+            createNew( Name const & _aModuleName ); 
        
         // create a new CacheLine attached to the given memory location
         static rtl::Reference<CacheLine> 
-            createAttached( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aLocation ); 
-       
-        memory::Segment * getDataSegment();
-
-        memory::SegmentAddress getDataSegmentAddress() const;
-
-        bool isEmpty() const { return m_base.isNull(); }
+            createAttached( Name const & _aModuleName, data::TreeAddress _aLocation );
 
         bool hasDefaults(memory::Accessor const & _aAccessor) const;
 
-        data::TreeAddress getModuleRootAddress( ) const { return m_base; }
-
+        bool isEmpty() const { return m_base == NULL; }
+        memory::Segment    *getDataSegment() { return &m_storage; }
+        data::TreeAddress   getTreeAddress() const { return m_base; }
 		data::TreeAddress	getPartialTree(memory::Accessor const & _aAccessor, Path const & _aTemplatePath ) const;
         data::NodeAddress	getNode(memory::Accessor const & _aAccessor, Path const & _aPath) const;
 
@@ -114,21 +108,20 @@ namespace configmgr
 		Name getModuleName() const;
 
 		/// add a client for this module's data
-		RefCount clientReferences() const { return m_nDataRefs; }
+		oslInterlockedCount clientReferences() const { return m_nDataRefs; }
 		/// add a client for this modules data
-		RefCount clientAcquire() { return osl_incrementInterlockedCount(&m_nDataRefs); }			
+		oslInterlockedCount clientAcquire() { return osl_incrementInterlockedCount(&m_nDataRefs); }			
 		/// subtract a client for this modules data
-		RefCount clientRelease() { return osl_decrementInterlockedCount(&m_nDataRefs); }		
+		oslInterlockedCount clientRelease() { return osl_decrementInterlockedCount(&m_nDataRefs); }		
 
     protected:
         // create a new CacheLine attached to the given memory location
         explicit 
-        CacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                    memory::SegmentAddress const & _aLocation ); 
+        CacheLine( Name const & _aModuleName, data::TreeAddress _pLocation );
        
         // create a new empty CacheLine for the given component name
         explicit 
-        CacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+        CacheLine( Name const & _aModuleName );
 
         data::NodeAccess internalGetNode(memory::Accessor const & _anAccessor, Path const & _rPath) const;
 
@@ -152,12 +145,12 @@ namespace configmgr
 	public:
         // create a new CacheLine for the given component name
         static rtl::Reference<ExtendedCacheLine> 
-            createNew( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+            createNew( Name const & _aModuleName ); 
        
         // create a new CacheLine attached to the given memory location
         static rtl::Reference<ExtendedCacheLine> 
-            createAttached( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aLocation ); 
+            createAttached( Name const & _aModuleName,
+                            data::TreeAddress _aLocation );
        
     // management of pending changes
 		bool hasPending() const {return m_pPending.get() != NULL;}
@@ -168,24 +161,17 @@ namespace configmgr
     private:
         // create a new empty CacheLine for the given component name
         explicit 
-        ExtendedCacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl );
+        ExtendedCacheLine( Name const & _aModuleName );
         
         // create a new CacheLine attached to the given memory location
         explicit 
-        ExtendedCacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aLocation ); 
+        ExtendedCacheLine( Name const & _aModuleName, 
+                           data::TreeAddress _aLocation );
 
     private:
 		std::auto_ptr<SubtreeChange> m_pPending;
 	};
     typedef rtl::Reference<ExtendedCacheLine> ExtendedCacheLineRef;
-////////////////////////////////////////////////////////////////////////////////
-
-    inline
-    memory::Segment * CacheLine::getDataSegment() 
-    { return &m_storage; }
-
-////////////////////////////////////////////////////////////////////////////////
 	
 } // namespace configmgr
 
Index: configmgr/source/treecache/cachewritescheduler.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachewritescheduler.cxx,v
retrieving revision 1.8
diff -u -p -u -r1.8 cachewritescheduler.cxx
--- configmgr/source/treecache/cachewritescheduler.cxx	16 Sep 2006 15:26:03 -0000	1.8
+++ configmgr/source/treecache/cachewritescheduler.cxx	5 Jan 2007 22:25:45 -0000
@@ -147,12 +147,14 @@ void OCacheWriteScheduler::runWriter()
 // -----------------------------------------------------------------------------
 void OCacheWriteScheduler::writeOneTreeFoundByOption(RequestOptions const& _aOptions) CFG_UNO_THROW_ALL(  )
 {
-	CFG_TRACE_INFO("Writeing one cache tree for user '%s' with locale '%s'", 
-					OUSTRING2ASCII(_aOptions.getEntity()), 
-                    OUSTRING2ASCII(_aOptions.getLocale()));
+    CFG_TRACE_INFO("Writeing one cache tree for user '%s' with locale '%s'", 
+		   OUSTRING2ASCII(_aOptions.getEntity()), 
+                   OUSTRING2ASCII(_aOptions.getLocale()));
+
+    // PRE: m_aUpdateMutex of TreeMgr must be acuired
+    backend::CacheController::CacheRef aCache;
+    aCache = m_rTreeManager.m_aCacheMap.get(_aOptions);
 
-	// PRE: m_aUpdateMutex of TreeMgr must be acuired
-    CacheManager::CacheRef aCache = m_rTreeManager.m_aCacheList.get(_aOptions);
     if (aCache.is())
 	{
 		CFG_TRACE_INFO_NI("- Found matching data container  - starting write task");		
Index: configmgr/source/treecache/cachewritescheduler.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachewritescheduler.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 cachewritescheduler.hxx
--- configmgr/source/treecache/cachewritescheduler.hxx	8 Sep 2005 04:24:23 -0000	1.5
+++ configmgr/source/treecache/cachewritescheduler.hxx	5 Jan 2007 22:25:45 -0000
@@ -73,7 +73,6 @@ namespace configmgr
 	class OCacheWriteScheduler
 	{
 		typedef std::set< RequestOptions, lessRequestOptions > CacheWriteList; // fire and forget!
-        typedef backend::CacheController CacheManager;
 
 		class Timer : public vos::OTimer
 		{
@@ -98,18 +97,16 @@ namespace configmgr
 		};
 		friend void Timer::onShot();
 	private:
-		mutable osl::Mutex	m_aMutex;
-		vos::ORef<Timer>	m_xTimer;
-		CacheManager&		m_rTreeManager;
-
-		CacheWriteList		m_aWriteList;
-
-        TimeInterval m_aWriteInterval;		
+	    mutable osl::Mutex	      m_aMutex;
+	    vos::ORef<Timer>	      m_xTimer;
+	    backend::CacheController &m_rTreeManager;
+	    CacheWriteList	      m_aWriteList;
+	    TimeInterval	      m_aWriteInterval;
 		
 	public:
 	//-------- Construction and destruction -----------------------------------
 		explicit
-		OCacheWriteScheduler(CacheManager& _rTreeManager, TimeInterval const& _aWriteInterval) 
+		OCacheWriteScheduler(backend::CacheController& _rTreeManager, TimeInterval const& _aWriteInterval) 
 			: m_rTreeManager(_rTreeManager)
 			, m_aWriteInterval(_aWriteInterval)			
 		{
Index: configmgr/source/treecache/disposetimer.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/disposetimer.cxx,v
retrieving revision 1.22
diff -u -p -u -r1.22 disposetimer.cxx
--- configmgr/source/treecache/disposetimer.cxx	16 Sep 2006 15:26:19 -0000	1.22
+++ configmgr/source/treecache/disposetimer.cxx	5 Jan 2007 22:25:45 -0000
@@ -205,10 +205,10 @@ void OTreeDisposeScheduler::onTimerShot(
 // this really should be a member of the TreeManager (see TreeManager::disposeOne etc.)
 TimeStamp OTreeDisposeScheduler::runDisposer(TimeStamp const& _aActualTime)
 {
-	TimeStamp aNextTime = TimeStamp::never();
-	OSL_ASSERT(aNextTime.isNever());
+    TimeStamp aNextTime = TimeStamp::never();
+    OSL_ASSERT(aNextTime.isNever());
 
-	osl::ClearableMutexGuard aGuard( m_rTreeManager.m_aCacheList.mutex() );
+    osl::ClearableMutexGuard aGuard( m_rTreeManager.m_aCacheMap.mutex() );
 
     Task aTask = this->getTask( _aActualTime, aNextTime );
     if (aTask.first)
@@ -219,7 +219,7 @@ TimeStamp OTreeDisposeScheduler::runDisp
 						OUSTRING2ASCII(rTaskOptions.getEntity()),
                         OUSTRING2ASCII(rTaskOptions.getLocale()));
 
-        CacheManager::CacheRef aCache = m_rTreeManager.m_aCacheList.get(rTaskOptions);
+        CacheManager::CacheRef aCache = m_rTreeManager.m_aCacheMap.get(rTaskOptions);
         if (aCache.is())
 		{
 			CFG_TRACE_INFO_NI("- Found matching data container (TreeInfo) - collecting data");
Index: configmgr/source/treecache/invalidatetree.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/invalidatetree.cxx,v
retrieving revision 1.21
diff -u -p -u -r1.21 invalidatetree.cxx
--- configmgr/source/treecache/invalidatetree.cxx	16 Sep 2006 15:26:33 -0000	1.21
+++ configmgr/source/treecache/invalidatetree.cxx	5 Jan 2007 22:25:45 -0000
@@ -193,11 +193,11 @@ void CacheController::invalidateComponen
 
 CacheLocation CacheController::refreshComponent(ComponentRequest const & _aRequest) CFG_UNO_THROW_ALL()
 {
-    if (m_bDisposing) return CacheLocation();
+    if (m_bDisposing) return NULL;
 
     CacheRef aCache = this->getCacheAlways(_aRequest.getOptions());
 
-    if (!aCache.is()) return CacheLocation();
+    if (!aCache.is()) return NULL;
 	
     osl::MutexGuard aCacheLineGuard(aCache->mutex());
 	
@@ -210,37 +210,35 @@ CacheLocation CacheController::refreshCo
     NodeInstance aNodeInstance(aLoadedInstance.mutableInstance().mutableData(),aRequestPath) ;
     NodeResult aLoadedNodeInstance(aNodeInstance) ;
     
-    CacheLocation aResult;
-	if (aLoadedNodeInstance.is())
-	{
+    data::TreeAddress aResult = NULL;
+    if (aLoadedNodeInstance.is())
+    {
         Name aModuleName = aLoadedNodeInstance->root().getModuleName();
 
         memory::UpdateAccessor aChangingAccessor( aCache->getDataSegment(aModuleName) ); 
         OSL_ENSURE(aChangingAccessor.is(), "No existing cache line for tree being refreshed");
 
-        data::TreeAddress aCachedTreeAddress = aCache->acquireModule(aModuleName);
-
-        aResult.segment = aCache->getDataSegmentAddress(aModuleName);
-        aResult.address = aCachedTreeAddress.addressValue();
+        bool bAcquired = aCache->acquireModule(aModuleName);
+	aResult = CacheLocation( aCache->getTreeAddress(aModuleName) );
 
-        if (aCachedTreeAddress.is())
+        if (bAcquired)
         try
-		{
+	{
             std::auto_ptr<SubtreeChange> aTreeChanges;
             data::NodeAddress aRootAddress;
 
             {
-                data::TreeAccessor aTreeAccess(aChangingAccessor.accessor(),aCachedTreeAddress);
+                data::TreeAccessor aTreeAccess(aChangingAccessor.accessor(),aResult);
                 data::NodeAccessRef aRootNode = aTreeAccess.getRootNode();
 
                 aTreeChanges = createDiffs(aRootNode, aLoadedNodeInstance->data().get(), aLoadedNodeInstance->root().location());
-                aRootAddress = aRootNode.address();
+                aRootAddress = aRootNode;
             }
 
             if (aTreeChanges.get() != NULL)
             {
-				// change all Values... found in the Subtree in the CacheTree
-				applyUpdateWithAdjustmentToTree(*aTreeChanges, aChangingAccessor, aRootAddress);
+		// change all Values... found in the Subtree in the CacheTree
+		applyUpdateWithAdjustmentToTree(*aTreeChanges, aChangingAccessor, aRootAddress);
 				
                 data::Accessor aNotifyLock = aChangingAccessor.downgrade(); // keep a read lock during notification
 				
@@ -251,15 +249,14 @@ CacheLocation CacheController::refreshCo
 
                 m_aNotifier.notifyChanged(anUpdateReq);
             }
-
-			aCache->releaseModule(aModuleName);
+	    aCache->releaseModule(aModuleName);
         }
         catch (...)
         {
-			aCache->releaseModule(aModuleName);
+	    aCache->releaseModule(aModuleName);
             throw;
         }
-	}
+    }
     return aResult;
 }
 
Index: configmgr/source/treecache/treemanager.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/treemanager.cxx,v
retrieving revision 1.11
diff -u -p -u -r1.11 treemanager.cxx
--- configmgr/source/treecache/treemanager.cxx	16 Sep 2006 15:27:00 -0000	1.11
+++ configmgr/source/treecache/treemanager.cxx	5 Jan 2007 22:25:45 -0000
@@ -241,10 +241,10 @@ ConfigChangeBroadcastHelper* TreeManager
 
 
 // -------------------------------------------------------------------------
-TreeManager::TreeManager(BackendCacheRef const & _xBackend, memory::HeapManager & _rCacheHeapManager) 
+TreeManager::TreeManager(BackendCacheRef const & _xBackend) 
 : m_xCacheController(_xBackend)
 , m_aCacheList()
-, m_aTemplates(new CacheData(_rCacheHeapManager))
+, m_aTemplates(new CacheData())
 , m_bEnableAsync(true)
 {
     OSL_PRECOND(_xBackend.is(),"Trying to create a TreeManager without a backend");
@@ -293,12 +293,6 @@ void TreeManager::disposeBackendCache() 
 
 // -------------------------------------------------------------------------
 
-memory::HeapManager & TreeManager::getCacheHeapManager() const
-{
-    return m_aTemplates.get()->getHeapManager();
-}
-// -------------------------------------------------------------------------
-
 TreeManager::CacheRef TreeManager::getCacheAlways(RequestOptions const & _aOptions)
 {
     osl::MutexGuard aGuard( m_aCacheList.mutex() );
@@ -306,7 +300,7 @@ TreeManager::CacheRef TreeManager::getCa
     CacheRef aResult = m_aCacheList.get(_aOptions);
     if (!aResult.is())
     {
-        CacheRef aNewCache( new Cache(getCacheHeapManager(), ConfigChangeBroadcaster::newBroadcastHelper()) );
+        CacheRef aNewCache( new Cache(ConfigChangeBroadcaster::newBroadcastHelper()) );
         aResult = m_aCacheList.insert(_aOptions,aNewCache);
     }
     return aResult;
@@ -329,37 +323,37 @@ memory::Segment* TreeManager::getDataSeg
 // -------------------------------------------------------------------------
 
 data::NodeAccess TreeManager::requestSubtree(AbsolutePath const& aSubtreePath, 
-									            const RequestOptions& _aOptions)  
-                                             CFG_UNO_THROW_ALL(  )
+					     const RequestOptions& _aOptions)  
+						CFG_UNO_THROW_ALL()
 {
-	CFG_TRACE_INFO("TreeManager: request for subtree '%s'", OUSTRING2ASCII(aSubtreePath.toString()));
+    CFG_TRACE_INFO("TreeManager: request for subtree '%s'", OUSTRING2ASCII(aSubtreePath.toString()));
 
     CacheRef aCache = getCacheAlways(_aOptions);
-	OSL_ENSURE(aCache.is(),"TreeManager: Cannot create cache access for loading node");
+    OSL_ENSURE(aCache.is(),"TreeManager: Cannot create cache access for loading node");
 
     data::Accessor aAccessor(NULL);
     
     if (!aCache->hasModule(aSubtreePath))
     {
-		CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the node");
+	CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the node");
         backend::ComponentRequest aQuery( aSubtreePath.getModuleName(), _aOptions );
 
         backend::CacheLocation aLoadedLocation = getCacheLoader()->loadComponent(aQuery);
-        if (aLoadedLocation.isNull())
+        if (aLoadedLocation == NULL)
         {
-		    CFG_TRACE_WARNING_NI("TreeManager: requested component not found");
+	    CFG_TRACE_WARNING_NI("TreeManager: requested component not found");
             throw com::sun::star::container::
                     NoSuchElementException( MAKEUSTRING("Requested component not found"), NULL);
         }
 
-		CFG_TRACE_INFO_NI("TreeManager: attaching loaded cache segment ");
+	CFG_TRACE_INFO_NI("TreeManager: attaching loaded cache segment ");
 
-        aAccessor = data::Accessor(aCache->attachDataSegment(aLoadedLocation.segment,aSubtreePath));
+        aAccessor = data::Accessor(aCache->attachDataSegment(aLoadedLocation,aSubtreePath));
         OSL_ENSURE(aAccessor.is(),"Cannot attach to loaded component");
     }
     else
-	{ 
-	    CFG_TRACE_INFO_NI("TreeManager: found node in cache");
+    { 
+	CFG_TRACE_INFO_NI("TreeManager: found node in cache");
         if (_aOptions.isRefreshEnabled())
         {
              backend::ComponentRequest aRequest( aSubtreePath.getModuleName(), _aOptions );
@@ -368,7 +362,6 @@ data::NodeAccess TreeManager::requestSub
        
         aAccessor = data::Accessor(aCache->getDataSegment(aSubtreePath));
         OSL_ENSURE(aAccessor.is(),"Cannot get accessor for existing component");
-        
     }
 
     data::NodeAddress aResultAddress = aCache->acquireNode(aAccessor,aSubtreePath);
@@ -380,28 +373,28 @@ data::NodeAccess TreeManager::requestSub
 void TreeManager::fetchSubtree(AbsolutePath const& aSubtreePath, const RequestOptions&  ) CFG_NOTHROW()
 {
     (void) aSubtreePath; // avoid warning about unused parameter
-	CFG_TRACE_WARNING("TreeManager: Prefetching not implemented. (Request to prefetch component %s.", OUSTRING2ASCII(aSubtreePath.toString()));
+    CFG_TRACE_WARNING("TreeManager: Prefetching not implemented. (Request to prefetch component %s.", OUSTRING2ASCII(aSubtreePath.toString()));
 }
 
 // -------------------------------------------------------------------------
 sal_Bool TreeManager::fetchDefaultData( memory::UpdateAccessor& _aAccessToken, 
                                         AbsolutePath const& aSubtreePath, 
-									    const RequestOptions& _aOptions
-									  ) CFG_UNO_THROW_ALL(  )
+					const RequestOptions& _aOptions
+					) CFG_UNO_THROW_ALL()
 {
-	CFG_TRACE_INFO("tree manager: checking the cache for defaults");
+    CFG_TRACE_INFO("tree manager: checking the cache for defaults");
 
     CacheRef aCache = m_aCacheList.get(_aOptions);
 
     if (!aCache.is())
     {
-	    OSL_ENSURE(aCache.is(),"TreeManager: Cache access to fetch defaults for does not exist ! Where does the node access come from ?");
+	OSL_ENSURE(aCache.is(),"TreeManager: Cache access to fetch defaults for does not exist ! Where does the node access come from ?");
         return false;
     }
 
     if (aCache->hasModuleDefaults(_aAccessToken.accessor(),aSubtreePath))
     {
-		CFG_TRACE_INFO_NI("TreeManager: found default data in cache");
+	CFG_TRACE_INFO_NI("TreeManager: found default data in cache");
         return true;
     }
 
@@ -412,15 +405,15 @@ sal_Bool TreeManager::fetchDefaultData( 
     backend::NodeResult aDefaults = getCacheLoader()->getDirectDataProvider().getDefaultData( aRequest );
 
     if (!aDefaults.is())
-	{
-		CFG_TRACE_INFO_NI("TreeManager: merging loaded defaults into cache");
+    {
+	CFG_TRACE_INFO_NI("TreeManager: merging loaded defaults into cache");
         return aCache->insertDefaults(_aAccessToken,aDefaults.instance());
-	}
-	else
-	{
+    }
+    else
+    {
         CFG_TRACE_WARNING_NI("TreeManager: cannot load defaults: no data available or not supported");
         return false;
-	}
+    }
 }
 
 // -------------------------------------------------------------------------
@@ -429,7 +422,7 @@ std::auto_ptr<ISubtree> TreeManager::req
 										               ) CFG_UNO_THROW_ALL(  )
 {
     // to do: check cache for existing default data (?!)
-	CFG_TRACE_INFO_NI("TreeManager: loading default data directly");
+    CFG_TRACE_INFO_NI("TreeManager: loading default data directly");
 
     backend::NodeRequest aRequest(aSubtreePath,_aOptions);
 
@@ -453,7 +446,7 @@ AbsolutePath TreeManager::encodeTemplate
     aResult.prepend(aTemplateModule);
 //    aResult.prepend(aTemplateRoot);
 
-	return AbsolutePath(aResult);
+    return AbsolutePath(aResult);
 }
         
 // -------------------------------------------------------------------------
@@ -476,33 +469,33 @@ data::TreeAccessor TreeManager::requestT
     {
         aTemplatesAccessor.clear();
 
-		CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the template");
+	CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the template");
         backend::TemplateRequest aQuery( _rName, _rModule );
 
         backend::CacheLocation aLoadedLocation = getCacheLoader()->loadTemplate(aQuery);
-        if (aLoadedLocation.isNull())
+        if (aLoadedLocation == NULL)
         {
-		    CFG_TRACE_ERROR_NI("TreeManager: requested template module not found");
+	    CFG_TRACE_ERROR_NI("TreeManager: requested template module not found");
             throw com::sun::star::container::
                     NoSuchElementException( MAKEUSTRING("Requested template module not found"), NULL);
         }
 
-		CFG_TRACE_INFO_NI("TreeManager: attaching to loaded template module");
+	CFG_TRACE_INFO_NI("TreeManager: attaching to loaded template module");
 
-        aTemplatesAccessor = data::Accessor(getTemplates().attachDataSegment(aLoadedLocation.segment,aCacheModule));
+        aTemplatesAccessor = data::Accessor(getTemplates().attachDataSegment(aLoadedLocation,aCacheModule));
         OSL_ENSURE(aTemplatesAccessor.is(),"Cannot attach to loaded component");
 
         // create a client ref count on the template module
         getTemplates().acquireNode(aTemplatesAccessor,aTemplateLocation);
     }
     else
-	{ 
-		CFG_TRACE_INFO_NI("TreeManager: template module found in cache");
+    { 
+	CFG_TRACE_INFO_NI("TreeManager: template module found in cache");
         OSL_ENSURE(aTemplatesAccessor.is(),"No accessor for existing data ?");
     }
 
     data::TreeAddress aTemplateAddr = getTemplates().getTemplateTree(aTemplatesAccessor,aTemplateLocation);
-	if (aTemplateAddr.isNull())
+    if (aTemplateAddr == NULL)
     {
 		CFG_TRACE_ERROR_NI("TreeManager: template not found in module");
 		throw com::sun::star::container::
@@ -635,31 +628,31 @@ void TreeManager::disposeData(const Requ
 // ----------------------------------------------------------------------------
 void TreeManager::nodeUpdated(TreeChangeList& _rChanges)
 {
-	CFG_TRACE_INFO("TreeManager: nodeUpdated");	
-	try
-	{		
-        CacheRef aCache = m_aCacheList.get(_rChanges.getOptions());
+    CFG_TRACE_INFO("TreeManager: nodeUpdated");	
+    try
+    {		
+	CacheRef aCache = m_aCacheList.get(_rChanges.getOptions());
 
-		if (aCache.is())
-		{
-			// first approve the changes and merge them with the current tree
-			AbsolutePath aSubtreeName = _rChanges.getRootNodePath();
+	if (aCache.is())
+	{
+	    // first approve the changes and merge them with the current tree
+	    AbsolutePath aSubtreeName = _rChanges.getRootNodePath();
 
             memory::Accessor aAccessor( aCache->getDataSegment(aSubtreeName) );
             OSL_ENSURE(aAccessor.is(), "TreeManager::nodeUpdated : cannot access cache !"); 
 
             data::NodeAddress aCacheTree = aCache->findInnerNode(aAccessor,aSubtreeName);
-            OSL_ENSURE(aCacheTree.is(), "TreeManager::nodeUpdated : node not found in cache!");
+            OSL_ENSURE(aCacheTree != NULL, "TreeManager::nodeUpdated : node not found in cache!");
 
-			if (aCacheTree.is())
-			    this->fireChanges(aAccessor,_rChanges,false);
-		}	
-	}
-	catch (uno::RuntimeException&)
-	{
-		CFG_TRACE_ERROR_NI("TreeManager::nodeUpdated : could not notify !");
-	}
-	CFG_TRACE_INFO_NI("TreeManager: nodeUpdated done");	
+	    if (aCacheTree != NULL)
+		this->fireChanges(aAccessor,_rChanges,false);
+	}	
+    }
+    catch (uno::RuntimeException&)
+    {
+	CFG_TRACE_ERROR_NI("TreeManager::nodeUpdated : could not notify !");
+    }
+    CFG_TRACE_INFO_NI("TreeManager: nodeUpdated done");	
 }
 
 // ----------------------------------------------------------------------------
Index: configmgr/source/treemgr/groupnodeimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/groupnodeimpl.hxx,v
retrieving revision 1.6
diff -u -p -u -r1.6 groupnodeimpl.hxx
--- configmgr/source/treemgr/groupnodeimpl.hxx	8 Sep 2005 04:29:29 -0000	1.6
+++ configmgr/source/treemgr/groupnodeimpl.hxx	5 Jan 2007 22:25:45 -0000
@@ -89,15 +89,15 @@ namespace configmgr
 		class GroupNodeImpl : public NodeImpl
 		{
 		public:
-            explicit GroupNodeImpl(data::GroupNodeAddress const& _aNodeRef);
+            explicit GroupNodeImpl(data::GroupNodeAddress _pNodeRef);
 
             typedef data::GroupNodeAccess DataAccess;
 
-            DataAccess getDataAccess(data::Accessor const& _aAccessor) const;
+            DataAccess getDataAccess(memory::Accessor const& _aAccessor) const;
 
-            bool areValueDefaultsAvailable(data::Accessor const& _aAccessor) const;
+            bool areValueDefaultsAvailable(memory::Accessor const& _aAccessor) const;
 
-            data::ValueNodeAccess getOriginalValueNode(data::Accessor const& _aAccessor, Name const& aName) const;
+            data::ValueNodeAccess getOriginalValueNode(memory::Accessor const& _aAccessor, Name const& aName) const;
 
             ValueMemberNode makeValueMember(data::ValueNodeAccess const& _aValueNode);
 		};
Index: configmgr/source/treemgr/nodefactory.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodefactory.cxx,v
retrieving revision 1.7
diff -u -p -u -r1.7 nodefactory.cxx
--- configmgr/source/treemgr/nodefactory.cxx	16 Sep 2006 15:30:03 -0000	1.7
+++ configmgr/source/treemgr/nodefactory.cxx	5 Jan 2007 22:25:45 -0000
@@ -97,19 +97,19 @@ namespace 
 
 	NodeImplHolder BasicNodeFactory::makeValueNode(ValueNodeAccess const& _aNodeAccess)
 	{
-        return new configuration::ValueElementNodeImpl(_aNodeAccess.address());
+	    return new configuration::ValueElementNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
 	NodeImplHolder BasicNodeFactory::makeGroupNode(GroupNodeAccess const& _aNodeAccess)
 	{
-		return new configuration::GroupNodeImpl(_aNodeAccess.address());
+	    return new configuration::GroupNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
 	NodeImplHolder BasicNodeFactory::makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate)
 	{
-		return new configuration::SetNodeImpl(_aNodeAccess.address(),pTemplate);
+	    return new configuration::SetNodeImpl(_aNodeAccess,pTemplate);
 	}
 	//-------------------------------------------------------------------------
 
@@ -125,22 +125,22 @@ namespace 
 
 	NodeImplHolder DirectNodeFactory::makeValueNode(ValueNodeAccess const& _aNodeAccess)
 	{
-		return new DirectValueElementNodeImpl(_aNodeAccess.address());
+		return new DirectValueElementNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
 	NodeImplHolder DirectNodeFactory::makeGroupNode(GroupNodeAccess const& _aNodeAccess)
 	{
-		return new DirectGroupNodeImpl(_aNodeAccess.address());
+		return new DirectGroupNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
 	NodeImplHolder DirectNodeFactory::makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate)
 	{
 		if (isTreeSet(_aNodeAccess,pTemplate))
-			return new DirectTreeSetNodeImpl(_aNodeAccess.address(),pTemplate);
+			return new DirectTreeSetNodeImpl(_aNodeAccess,pTemplate);
 		else
-			return new DirectValueSetNodeImpl(_aNodeAccess.address(),pTemplate);
+			return new DirectValueSetNodeImpl(_aNodeAccess,pTemplate);
 	}
 	//-------------------------------------------------------------------------
 */
@@ -148,28 +148,28 @@ namespace 
 
 	struct DeferredNodeFactory : NodeFactory
 	{
-		NodeImplHolder makeValueNode(ValueNodeAccess const& _aNodeAccess);
-		NodeImplHolder makeGroupNode(GroupNodeAccess const& _aNodeAccess);
-		NodeImplHolder makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate);
+	    NodeImplHolder makeValueNode(ValueNodeAccess const& _aNodeAccess);
+	    NodeImplHolder makeGroupNode(GroupNodeAccess const& _aNodeAccess);
+	    NodeImplHolder makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate);
 	};
 	//-------------------------------------------------------------------------
 
 	NodeImplHolder DeferredNodeFactory::makeValueNode(ValueNodeAccess const& _aNodeAccess)
 	{
     //    OSL_ENSURE(false, "Wrong factory for value elements - should be immutable (=read-only)");
-        return new configuration::ValueElementNodeImpl(_aNodeAccess.address());
+	    return new configuration::ValueElementNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
 	NodeImplHolder DeferredNodeFactory::makeGroupNode(GroupNodeAccess const& _aNodeAccess)
 	{
-		return new configuration::DeferredGroupNodeImpl(_aNodeAccess.address());
+	    return new configuration::DeferredGroupNodeImpl(_aNodeAccess);
 	}
 	//-------------------------------------------------------------------------
 
 	NodeImplHolder DeferredNodeFactory::makeSetNode  (SetNodeAccess const& _aNodeAccess, Template* pTemplate)
 	{
-		return new configuration::DeferredSetNodeImpl(_aNodeAccess.address(),pTemplate);
+	    return new configuration::DeferredSetNodeImpl(_aNodeAccess,pTemplate);
 	}
 	//-------------------------------------------------------------------------
 
Index: configmgr/source/treemgr/nodeimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodeimpl.cxx,v
retrieving revision 1.24
diff -u -p -u -r1.24 nodeimpl.cxx
--- configmgr/source/treemgr/nodeimpl.cxx	16 Sep 2006 15:30:17 -0000	1.24
+++ configmgr/source/treemgr/nodeimpl.cxx	5 Jan 2007 22:25:45 -0000
@@ -91,7 +91,7 @@ namespace configmgr
 /// provide access to the data of the underlying node
 data::NodeAccessRef NodeImpl::getOriginalNodeAccessRef(data::Accessor const * _pAccessor) const
 {
-    return data::NodeAccessRef(_pAccessor,m_aNodeRef_);
+    return data::NodeAccessRef(_pAccessor,m_pNodeRef);
 }
 //-----------------------------------------------------------------------------
 
@@ -117,8 +117,8 @@ data::GroupNodeAccess GroupNodeImpl::get
 }
 //-----------------------------------------------------------------------------
 
-GroupNodeImpl::GroupNodeImpl(data::GroupNodeAddress const& _aNodeRef)
-: NodeImpl(_aNodeRef)
+GroupNodeImpl::GroupNodeImpl(data::GroupNodeAddress _pNodeRef)
+: NodeImpl(reinterpret_cast<data::NodeAddress>(_pNodeRef))
 {
 }
 //-----------------------------------------------------------------------------
@@ -167,7 +167,7 @@ data::ValueNodeAccess ValueElementNodeIm
 //-----------------------------------------------------------------------------
 
 ValueElementNodeImpl::ValueElementNodeImpl(data::ValueNodeAddress const& _aNodeRef)
-: NodeImpl(_aNodeRef)
+    : NodeImpl(reinterpret_cast<data::NodeAddress>(_aNodeRef))
 {
 }
 //-----------------------------------------------------------------------------
Index: configmgr/source/treemgr/nodeimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodeimpl.hxx,v
retrieving revision 1.14
diff -u -p -u -r1.14 nodeimpl.hxx
--- configmgr/source/treemgr/nodeimpl.hxx	8 Sep 2005 04:31:49 -0000	1.14
+++ configmgr/source/treemgr/nodeimpl.hxx	5 Jan 2007 22:25:45 -0000
@@ -39,8 +39,8 @@
 #ifndef CONFIGMGR_CONFIGURATION_ATTRIBUTES_HXX_
 #include "attributes.hxx"
 #endif
-#ifndef CONFIGMGR_NODEADDRESS_HXX
-#include "nodeaddress.hxx"
+#ifndef INCLUDED_SHARABLE_NODE_HXX
+#include "node.hxx"
 #endif
 
 #ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
@@ -57,48 +57,44 @@ namespace configmgr
     namespace data { class NodeAccessRef; }
     namespace view { class ViewStrategy; }
 //-----------------------------------------------------------------------------
-	namespace configuration
-	{
-//-----------------------------------------------------------------------------
-		typedef unsigned int NodeOffset;
-
-		class TreeImpl;
+    namespace configuration
+    {
+	//-----------------------------------------------------------------------------
+	typedef unsigned int NodeOffset;
+
+	class TreeImpl;
+
+	class Name;
+
+	class NodeChange;
+	class NodeChanges;
+	class NodeChangesInformation;
 
-		class Name;
-
-		class NodeChange;
-		class NodeChanges;
-		class NodeChangesInformation;
 //-----------------------------------------------------------------------------
-
 // Specific types of nodes
 //-----------------------------------------------------------------------------
 
         class NodeImpl;
-		typedef rtl::Reference<NodeImpl> NodeImplHolder;
+	typedef rtl::Reference<NodeImpl> NodeImplHolder;
+	struct INodeHandler;
 
-		struct INodeHandler;
-
-		// Almost an interface, but derives from concrete OReference
-		class NodeImpl : public salhelper::SimpleReferenceObject
-		{
-            friend class view::ViewStrategy;
-            data::NodeAddress m_aNodeRef_;
-		public:
-            NodeImpl(data::NodeAddress const & _aNodeRef)
-            : m_aNodeRef_(_aNodeRef)
-            {}
-
-		public:
-//			void directCommitChanges(memory::Accessor const& _aAccessor) { doCommitChanges(_aAccessor); }
-
-            /// provide access to the address of the underlying node
-            data::NodeAddress getOriginalNodeAddress() const
-            { return m_aNodeRef_; }
-
-            /// provide access to the data of the underlying node
-            data::NodeAccessRef getOriginalNodeAccessRef(memory::Accessor const * _pAccessor) const;
-		};
+	// Almost an interface, but derives from concrete OReference
+	class NodeImpl : public salhelper::SimpleReferenceObject
+	{
+	    friend class view::ViewStrategy;
+            data::NodeAddress m_pNodeRef;
+	public:
+            NodeImpl(data::NodeAddress _pNodeRef)
+		: m_pNodeRef(_pNodeRef) {}
+
+	public:
+        /// provide access to the address of the underlying node
+        data::NodeAddress getOriginalNodeAddress() const
+            { return m_pNodeRef; }
+
+        /// provide access to the data of the underlying node
+        data::NodeAccessRef getOriginalNodeAccessRef(memory::Accessor const * _pAccessor) const;
+	};
 
 //-----------------------------------------------------------------------------
 		class ValueElementNodeImpl;
Index: configmgr/source/treemgr/nodeimplobj.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodeimplobj.cxx,v
retrieving revision 1.24
diff -u -p -u -r1.24 nodeimplobj.cxx
--- configmgr/source/treemgr/nodeimplobj.cxx	16 Sep 2006 15:30:31 -0000	1.24
+++ configmgr/source/treemgr/nodeimplobj.cxx	5 Jan 2007 22:25:46 -0000
@@ -201,24 +201,6 @@ DeferredGroupNodeImpl::MemberChange Defe
 }
 
 //-----------------------------------------------------------------------------
-/*
-void DeferredGroupNodeImpl::doCommitChanges(data::Accessor const& _aAccessor)
-{
-    for (ValueChanges::iterator pos = m_aChanges.begin(); pos != m_aChanges.end(); )
-    {
-        ValueChanges::iterator it = pos++; // this is used to allow erasing below
-        if (it->second.is())
-        {
-            it->second->commitDirect(_aAccessor); 
-            m_aChanges.erase(it); // this goes here to ensure exception safety
-        }
-        else
-            OSL_ASSERT(it->first.isEmpty());
-    }
-    m_aChanges.clear();
-}
-*/
-//-----------------------------------------------------------------------------
 
 std::auto_ptr<SubtreeChange> DeferredGroupNodeImpl::preCommitValueChanges(data::Accessor const& _aAccessor)
 {	
@@ -512,7 +494,7 @@ void DeferredSetNodeImpl::collectElement
 		if (m_aChangedData.getElement(it->first) == 0) 
 		{
 			OSL_ASSERT(it->second.isValid());
-            view::ViewTreeAccess aElementView(_aAccessor, *it->second);
+			view::ViewTreeAccess aElementView(_aAccessor, *it->second);
 
 			if (aElementView.hasChanges())
 				aElementView.collectChanges(rChanges);
@@ -876,8 +858,8 @@ void DeferredSetNodeImpl::failedCommit(d
 
 				if (rAddNode.wasInserted())
 				{ // it has been integrated into the master tree
-                    OSL_ENSURE(getDataAccess(_aAccessor).getElementTree(aElementName).address() == rAddNode.getInsertedTree(),
-                                "Internal Error: Inserted tree address does not match actual data");
+				    OSL_ENSURE(getDataAccess(_aAccessor).getElementTree(aElementName) == rAddNode.getInsertedTree(),
+					       "Internal Error: Inserted tree address does not match actual data");
 
 					// so add it
 					if (aOriginal.isValid())
Index: configmgr/source/treemgr/nodeimplobj.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/nodeimplobj.hxx,v
retrieving revision 1.14
diff -u -p -u -r1.14 nodeimplobj.hxx
--- configmgr/source/treemgr/nodeimplobj.hxx	19 Jun 2006 23:33:36 -0000	1.14
+++ configmgr/source/treemgr/nodeimplobj.hxx	5 Jan 2007 22:25:46 -0000
@@ -36,6 +36,9 @@
 #ifndef CONFIGMGR_NODEIMPLOBJECTS_HXX_
 #define CONFIGMGR_NODEIMPLOBJECTS_HXX_
 
+#ifndef INCLUDED_SHARABLE_NODE_HXX
+#include "node.hxx"
+#endif
 #ifndef CONFIGMGR_CONFIGNODEBEHAVIOR_HXX_
 #include "nodeimpl.hxx"
 #endif
@@ -48,9 +51,6 @@
 #ifndef CONFIGMGR_VALUENODEBEHAVIOR_HXX_
 #include "valuenodeimpl.hxx"
 #endif
-#ifndef CONFIGMGR_NODEADDRESS_HXX
-#include "nodeaddress.hxx"
-#endif
 
 #ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
 #include <salhelper/simplereferenceobject.hxx>
@@ -63,8 +63,8 @@
 
 namespace configmgr
 {
-	namespace configuration
-	{
+    namespace configuration
+    {
 //-----------------------------------------------------------------------------
 
 // Specific types of nodes for direct or read only access
@@ -74,21 +74,21 @@ namespace configmgr
 //-----------------------------------------------------------------------------
 
         class ValueMemberNode::DeferredImpl : public salhelper::SimpleReferenceObject
-		{
+        {
             data::ValueNodeAddress m_aValueRef;
 
             UnoAny      m_aNewValue;
             bool	    m_bToDefault;
             bool	    m_bChange;
 		public:
-			explicit DeferredImpl(data::ValueNodeAccess const& _aValueNode) ;
+            explicit DeferredImpl(data::ValueNodeAccess const& _aValueNode);
 
 			/// does this wrap a change
             bool isChange() const   { return m_bChange; }
 
 			/// retrieve the underlying (original) node location
             data::ValueNodeAddress getOriginalNodeAddress() const
-            { return m_aValueRef; }
+                { return m_aValueRef; }
 
 			/// retrieve the underlying (original) node
             data::ValueNodeAccess getOriginalNode(data::Accessor const& _aAccessor) const
Index: configmgr/source/treemgr/setnodeimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/setnodeimpl.cxx,v
retrieving revision 1.24
diff -u -p -u -r1.24 setnodeimpl.cxx
--- configmgr/source/treemgr/setnodeimpl.cxx	16 Sep 2006 15:31:34 -0000	1.24
+++ configmgr/source/treemgr/setnodeimpl.cxx	5 Jan 2007 22:25:46 -0000
@@ -374,8 +374,8 @@ view::ViewTreeAccess SetEntry::getTreeVi
 // class SetNodeImpl
 //-------------------------------------------------------------------------
 
-SetNodeImpl::SetNodeImpl(data::SetNodeAddress const& _aNodeRef,Template* pTemplate) 
-: NodeImpl(_aNodeRef)
+SetNodeImpl::SetNodeImpl(data::SetNodeAddress _pNodeRef,Template* pTemplate) 
+: NodeImpl(reinterpret_cast<NodeAddress>(_pNodeRef))
 ,m_aTemplate(pTemplate)
 ,m_aTemplateProvider()
 ,m_pParentTree(0)
@@ -870,7 +870,7 @@ Element SetNodeImpl::makeAdditionalEleme
 
     data::TreeAddress aAddedTree = aAddNodeChange.getInsertedTree();
 	// need 'unsafe', because ownership would be gone when notifications are sent
-	if (aAddedTree.is())
+	if (aAddedTree != NULL)
 	{
 		// OSL_ENSURE( pNode->ISA(ISubtree), "Type mismatch when adjusting to update: value element found in tree set");
 
Index: configmgr/source/treemgr/setnodeimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/setnodeimpl.hxx,v
retrieving revision 1.11
diff -u -p -u -r1.11 setnodeimpl.hxx
--- configmgr/source/treemgr/setnodeimpl.hxx	8 Sep 2005 04:33:57 -0000	1.11
+++ configmgr/source/treemgr/setnodeimpl.hxx	5 Jan 2007 22:25:46 -0000
@@ -214,7 +214,7 @@ namespace configmgr
 	//-------------------------------------------------------------------------
 
         class SetNodeImpl : public NodeImpl
-		{
+	{
             friend class view::ViewStrategy;
 			ElementSet          m_aDataSet;
 			TemplateHolder	    m_aTemplate;
@@ -228,7 +228,7 @@ namespace configmgr
 		public:
 			typedef ElementSet::Element Element;
 
-			SetNodeImpl(data::SetNodeAddress const& _aNodeRef, Template* pTemplate);
+			SetNodeImpl(data::SetNodeAddress _pNodeRef, Template* pTemplate);
 
             typedef data::SetNodeAccess	DataAccess; 
             DataAccess getDataAccess(data::Accessor const& _aAccessor) const;
Index: configmgr/source/treemgr/treeimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/treeimpl.cxx,v
retrieving revision 1.30
diff -u -p -u -r1.30 treeimpl.cxx
--- configmgr/source/treemgr/treeimpl.cxx	16 Sep 2006 15:32:13 -0000	1.30
+++ configmgr/source/treemgr/treeimpl.cxx	5 Jan 2007 22:25:46 -0000
@@ -780,7 +780,7 @@ ElementTreeImpl::ElementTreeImpl(	rtl::R
 : TreeImpl()
 , m_aInstanceInfo(aTemplateInfo)
 , m_aElementName(_aCacheTree.getName())
-, m_aDataAddress(_aCacheTree.address())
+, m_aDataAddress(_aCacheTree)
 , m_aOwnData()
 {
 	TreeImpl::build( _xStrategy, _aCacheTree.getRootNode(), nDepth, aTemplateProvider );
@@ -795,7 +795,7 @@ ElementTreeImpl::ElementTreeImpl(	rtl::R
 : TreeImpl( rParentTree, nParentNode )
 , m_aInstanceInfo(aTemplateInfo)
 , m_aElementName(_aCacheTree.getName())
-, m_aDataAddress(_aCacheTree.address())
+, m_aDataAddress(_aCacheTree)
 , m_aOwnData()
 {
 	TreeImpl::build( _xStrategy, _aCacheTree.getRootNode(), nDepth, aTemplateProvider );
@@ -885,7 +885,7 @@ Path::Component ElementTreeImpl::makeExt
 void ElementTreeImpl::rebuild(rtl::Reference<view::ViewStrategy> const & _aStrategy, data::TreeAccessor const & _aNewTree, data::Accessor const& _aOldAccessor)
 {
     TreeImpl::rebuild(_aStrategy,_aNewTree.getRootNode(),_aOldAccessor);
-    m_aDataAddress = _aNewTree.address();
+    m_aDataAddress = _aNewTree;
     m_aElementName = _aNewTree.getName();
 }
 
@@ -922,7 +922,7 @@ void ElementTreeImpl::attachTo(data::Set
             // copy over to the new segment
             data::TreeAddress aNewElement = m_aOwnData.getTreeAccess().copyTree(aTargetAccessor);
 
-            data::SetNodeAccess::addElement(aTargetAccessor,aOwningSet.address(),  aNewElement);
+            data::SetNodeAccess::addElement(aOwningSet,  aNewElement);
 
             data::TreeAccessor aNewAccessor(aTargetAccessor.downgrade(),aNewElement);
 
@@ -963,8 +963,8 @@ void ElementTreeImpl::detachFrom(data::S
 
             memory::UpdateAccessor aTargetAccessor(pTargetSpace);
 
-            TreeAddress aOldElement = data::SetNodeAccess::removeElement(aTargetAccessor,aOwningSet.address(), aElementName );
-		    OSL_ENSURE(aOldElement.is(),"ERROR: Detached node not found in the given subtree");
+            TreeAddress aOldElement = data::SetNodeAccess::removeElement(aOwningSet, aElementName );
+	    OSL_ENSURE(aOldElement != NULL,"ERROR: Detached node not found in the given subtree");
 
             TreeAccessor::freeTree(aTargetAccessor,aOldElement);
         }
Index: configmgr/source/treemgr/valuemembernode.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/valuemembernode.cxx,v
retrieving revision 1.9
diff -u -p -u -r1.9 valuemembernode.cxx
--- configmgr/source/treemgr/valuemembernode.cxx	16 Sep 2006 15:32:27 -0000	1.9
+++ configmgr/source/treemgr/valuemembernode.cxx	5 Jan 2007 22:25:46 -0000
@@ -144,7 +144,7 @@ ValueMemberNode::~ValueMemberNode()
 bool ValueMemberNode::isValid() const
 {
     OSL_ASSERT( !m_xDeferredOperation.is() || 
-                 m_xDeferredOperation->getOriginalNodeAddress() == m_aNodeRef.address() );
+                 m_aNodeRef == m_xDeferredOperation->getOriginalNodeAddress());
     
     return m_aNodeRef.isValid();
 }
@@ -220,7 +220,7 @@ void ValueMemberUpdate::setValue(UnoAny 
     else if (memory::Segment * pUpdatableSegment = m_pStrategy->getDataSegmentForUpdate())
     {
         memory::UpdateAccessor aUpdater(pUpdatableSegment);
-        setOriginalValue( aUpdater, m_aMemberNode.m_aNodeRef.address(), aNewValue );
+        setOriginalValue( aUpdater, m_aMemberNode.m_aNodeRef, aNewValue );
     }
 }
 //-----------------------------------------------------------------------------
@@ -233,7 +233,7 @@ void ValueMemberUpdate::setDefault() 
     else if (memory::Segment * pUpdatableSegment = m_pStrategy->getDataSegmentForUpdate())
     {
         memory::UpdateAccessor aUpdater(pUpdatableSegment);
-        setOriginalToDefault( aUpdater, m_aMemberNode.m_aNodeRef.address() );
+        setOriginalToDefault( aUpdater, m_aMemberNode.m_aNodeRef );
     }
 }
 
@@ -242,7 +242,7 @@ void ValueMemberUpdate::setDefault() 
 //-----------------------------------------------------------------------------
 
 ValueMemberNode::DeferredImpl::DeferredImpl(data::ValueNodeAccess const& _aValueNode)
-: m_aValueRef(_aValueNode.address())
+: m_aValueRef(_aValueNode)
 , m_aNewValue(_aValueNode.getValue())
 , m_bToDefault(false)
 , m_bChange(false)
@@ -251,7 +251,7 @@ ValueMemberNode::DeferredImpl::DeferredI
 
 void ValueMemberNode::DeferredImpl::setValue(UnoAny const& aNewValue, data::ValueNodeAccess const& _aOriginalNode)
 {
-    OSL_ENSURE(_aOriginalNode.address() == m_aValueRef, "Incorrect original node passed");
+    OSL_ENSURE(_aOriginalNode == m_aValueRef, "Incorrect original node passed");
     
     m_aNewValue = aNewValue;
     m_bToDefault = false;
@@ -262,7 +262,7 @@ void ValueMemberNode::DeferredImpl::setV
 
 void ValueMemberNode::DeferredImpl::setValueToDefault(data::ValueNodeAccess const& _aOriginalNode)
 {
-    OSL_ENSURE(_aOriginalNode.address() == m_aValueRef, "Incorrect original node passed");
+    OSL_ENSURE(_aOriginalNode == m_aValueRef, "Incorrect original node passed");
     
     m_aNewValue = _aOriginalNode.getDefaultValue();
     m_bToDefault = true;
Index: configmgr/source/treemgr/valuemembernode.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/valuemembernode.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 valuemembernode.hxx
--- configmgr/source/treemgr/valuemembernode.hxx	8 Sep 2005 04:35:43 -0000	1.5
+++ configmgr/source/treemgr/valuemembernode.hxx	5 Jan 2007 22:25:46 -0000
@@ -68,7 +68,7 @@ namespace configmgr
             /// create a ValueMemberNode for a given node
 			explicit ValueMemberNode(data::ValueNodeAccess const& _aNodeAccess);
             /// create a deferred ValueMemberNode (xOriginal must not be empty)
-            ValueMemberNode(data::Accessor const& _aAccessor, DeferredImplRef const& _xDeferred);
+            ValueMemberNode(memory::Accessor const& _aAccessor, DeferredImplRef const& _xDeferred);
 		public:
 			ValueMemberNode(ValueMemberNode const& rOriginal);
 			ValueMemberNode& operator=(ValueMemberNode const& rOriginal);
Index: configmgr/source/treemgr/valuenodeimpl.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/valuenodeimpl.hxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 valuenodeimpl.hxx
--- configmgr/source/treemgr/valuenodeimpl.hxx	8 Sep 2005 04:35:58 -0000	1.3
+++ configmgr/source/treemgr/valuenodeimpl.hxx	5 Jan 2007 22:25:46 -0000
@@ -42,10 +42,7 @@
 
 namespace configmgr
 {
-//-----------------------------------------------------------------------------
-
-	class ValueChange;
-//-----------------------------------------------------------------------------
+    class ValueChange;
 
     namespace data 
     { 
@@ -54,17 +51,11 @@ namespace configmgr
     }
 //-----------------------------------------------------------------------------
 
-	namespace configuration
-	{
-//-----------------------------------------------------------------------------
-		typedef com::sun::star::uno::Any UnoAny;
-		typedef com::sun::star::uno::Type UnoType;
-
-		class ValueChangeImpl;
-
-		class Name;
+    namespace configuration
+    {
+	typedef com::sun::star::uno::Any UnoAny;
+	typedef com::sun::star::uno::Type UnoType;
 //-----------------------------------------------------------------------------
-
 // Another types of node
 //-----------------------------------------------------------------------------
 
@@ -72,29 +63,27 @@ namespace configmgr
             <p> This is an immutable value (changes are done by adding/replacing/removing set elements)
             </p>
         */
-		class ValueElementNodeImpl : public NodeImpl
-		{
-		public:
+	class ValueElementNodeImpl : public NodeImpl
+	{
+	public:
             explicit ValueElementNodeImpl(data::ValueNodeAddress const& _aNodeRef) ;
 
-		// the following delegate directly to the original node
-		public:
-			/// Does this node assume its default value
-			/// retrieve the current value of this node
-			UnoAny	getValue(data::Accessor const& _aAccessor) const;
-
-			/// get the type of this value
-			UnoType	getValueType(data::Accessor const& _aAccessor)	const;
-
-            typedef data::ValueNodeAccess DataAccess;
-            DataAccess getDataAccess(data::Accessor const& _aAccessor) const;
-		};
+	// the following delegate directly to the original node
+	public:
+	    /// Does this node assume its default value
+	    /// retrieve the current value of this node
+	    UnoAny	getValue(memory::Accessor const& _aAccessor) const;
+
+	    /// get the type of this value
+	    UnoType	getValueType(memory::Accessor const& _aAccessor)	const;
+
+	    typedef data::ValueNodeAccess DataAccess;
+            DataAccess getDataAccess(memory::Accessor const& _aAccessor) const;
+	};
 
-//-----------------------------------------------------------------------------
-		// domain-specific 'dynamic_cast' replacement
-		ValueElementNodeImpl&	AsValueNode(NodeImpl& rNode);
-//-----------------------------------------------------------------------------
-	}
+	// domain-specific 'dynamic_cast' replacement
+	ValueElementNodeImpl&	AsValueNode(NodeImpl& rNode);
+    }
 }
 
 #endif // CONFIGMGR_VALUENODEBEHAVIOR_HXX_
Index: configmgr/source/treemgr/viewnode.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/viewnode.hxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 viewnode.hxx
--- configmgr/source/treemgr/viewnode.hxx	8 Sep 2005 04:37:13 -0000	1.3
+++ configmgr/source/treemgr/viewnode.hxx	5 Jan 2007 22:25:46 -0000
@@ -71,8 +71,6 @@ namespace configmgr
             data::Accessor const& accessor() const   // has a Accessor
             { return m_accessor; }
 
-        //    data::TreeAccessor getAccess() const;   // has a TreeAccessor
-
         private:
             data::Accessor m_accessor;   // has a TreeAccessor
             TreeData *  m_addr;  // has a TreeAddress or NodeAddress
Index: configmgr/source/treemgr/viewstrategy.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/viewstrategy.cxx,v
retrieving revision 1.10
diff -u -p -u -r1.10 viewstrategy.cxx
--- configmgr/source/treemgr/viewstrategy.cxx	16 Sep 2006 15:33:07 -0000	1.10
+++ configmgr/source/treemgr/viewstrategy.cxx	5 Jan 2007 22:25:47 -0000
@@ -84,8 +84,6 @@ namespace configmgr
         using configuration::ElementList;
         using configuration::GroupMemberVisitor;
         using configuration::SetNodeVisitor;
-//-----------------------------------------------------------------------------
-// virtual void doInitElements( data::SetNodeAccess const& _aNode, TreeDepth nDepth);
 	
         static
         inline
@@ -148,62 +146,11 @@ namespace configmgr
 	        }
         }
 
-//-----------------------------------------------------------------------------
-        data::NodeAddress::DataType * ViewStrategy::getDataForUpdate(data::NodeAccessRef const & _aNode)
-        {
-            typedef data::NodeAddress::DataType DataType;
-            DataType * pResult = implAccessForUpdate(_aNode);
-            OSL_ASSERT(!pResult || _aNode.getDataPtr() == pResult);
-            return pResult;
-        }
-
-        data::SetNodeAddress::DataType * ViewStrategy::getDataForUpdate(data::SetNodeAccess const & _aNode)
-        {
-            typedef data::SetNodeAddress::DataType DataType;
-
-            sharable::Node * pNode = implAccessForUpdate(_aNode);
-            DataType * pResult = pNode ? pNode->setData() : 0;
-
-            OSL_ASSERT(!pResult || &_aNode.data() == pResult);
-            return pResult;
-        }
-
-        data::GroupNodeAddress::DataType * ViewStrategy::getDataForUpdate(data::GroupNodeAccess const & _aNode)
-        {
-            typedef data::GroupNodeAddress::DataType DataType;
-
-            sharable::Node * pNode = implAccessForUpdate(_aNode);
-            DataType * pResult = pNode ? pNode->groupData() : 0;
-
-            OSL_ASSERT(!pResult || &_aNode.data() == pResult);
-            return pResult;
-        }
-
-        data::ValueNodeAddress::DataType * ViewStrategy::getDataForUpdate(data::ValueNodeAccess const & _aNode)
+        data::SetNodeAddress ViewStrategy::getDataForUpdate(data::SetNodeAccess const & _aNode)
         {
-            typedef data::ValueNodeAddress::DataType DataType;
-
-            sharable::Node * pNode = implAccessForUpdate(_aNode);
-            DataType * pResult = pNode ? pNode->valueData() : 0;
-
-            OSL_ASSERT(!pResult || &_aNode.data() == pResult);
-            return pResult;
-        }
-
-//-----------------------------------------------------------------------------
-        data::NodeAddress::DataType * ViewStrategy::implAccessForUpdate(data::NodeAccessRef const & _aNode)
-        {
-            if (memory::Segment * pUpdatableSegment = doGetDataSegmentForUpdate())
-            {
-                void * p = memory::UpdateAccessor(pUpdatableSegment).validate(_aNode.rawAddress());
-             
-                OSL_ASSERT(const_cast<const void *>(p) == _aNode.getDataPtr());
-
-                return static_cast<data::NodeAddress::DataType*>(p);
-            }
-
-            else
-                return NULL;
+            if (doGetDataSegmentForUpdate())
+                return _aNode;
+            return NULL;
         }
 
 //-----------------------------------------------------------------------------
@@ -702,48 +649,6 @@ namespace configmgr
         }
 
 //-----------------------------------------------------------------------------
-/*       //  virtual rtl::Reference<ViewStrategy> doCloneIndirect(); // fails* /
-        rtl::Reference<ViewStrategy> ViewStrategy::makeIndirect(Tree const& _aTree)
-        {
-            _aTree->makeIndirect(true);
-            return this;
-        }
-
-		void ViewStrategy::doCommitChanges(Node const& _aNode)
-        {
-            // nothing to do
-        }
-
-        // TODO: move this to deferred impl
-        void ViewStrategy::implCommitDirectIn(data::TreeAccessor const& _aPlaceHolder, Node const& _aNode)
-        {
-	        if (this->hasChanges(_aNode) )
-	        {
-                this->doCommitChanges(_aNode);
-
-                GroupNode aGroup(_aNode);
-
-                for (Node aChild = aGroup.getFirstChild(); aChild.is(); aChild = aGroup.getNextChild(aChild) )
-		        {
-			        implCommitDirectIn(_aPlaceHolder, aChild);
-		        }
-	        }
-        }
-
-        void ViewStrategy::commitDirectly(data::TreeAccessor const& _aPlaceHolder, Tree const& _aTree)
-        {
-            implCommitDirectIn( _aPlaceHolder, getRootNode(_aTree) );
-        }
-
-        //  virtual rtl::Reference<ViewStrategy> doCloneDirect();   // returns 'this'
-        rtl::Reference<ViewStrategy> ViewStrategy::makeDirect  (Tree const& _aTree)
-        {
-            commitDirectly(_aTree.accessor(), _aTree);
-            _aTree->makeIndirect(false);
-            return this;
-        }
-*/
-//-----------------------------------------------------------------------------
         data::NodeAccessRef ViewStrategy::getNodeAccessRef(Node const& _aNode) const
         { 
             checkInstance(_aNode.tree());
Index: configmgr/source/treemgr/viewstrategy.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/viewstrategy.hxx,v
retrieving revision 1.6
diff -u -p -u -r1.6 viewstrategy.hxx
--- configmgr/source/treemgr/viewstrategy.hxx	8 Sep 2005 04:37:43 -0000	1.6
+++ configmgr/source/treemgr/viewstrategy.hxx	5 Jan 2007 22:25:47 -0000
@@ -202,10 +202,7 @@ namespace configmgr
             memory::Segment const * getDataSegment() const;
             memory::Segment  * getDataSegmentForUpdate();
 
-            data::NodeAddress   ::DataType * getDataForUpdate(data::NodeAccessRef const & _aNode);
-            data::SetNodeAddress::DataType * getDataForUpdate(data::SetNodeAccess const & _aNode);
-            data::GroupNodeAddress::DataType * getDataForUpdate(data::GroupNodeAccess const & _aNode);
-            data::ValueNodeAddress::DataType * getDataForUpdate(data::ValueNodeAccess const & _aNode);
+            data::SetNodeAddress   getDataForUpdate(data::SetNodeAccess const & _aNode);
 
         // access to node innards
         protected:
@@ -250,7 +247,6 @@ namespace configmgr
             virtual void doReleaseDataSegment() = 0;
 
             // special support for direct changes to underlying data - default is no support
-            virtual data::NodeAddress::DataType * implAccessForUpdate(data::NodeAccessRef const & _aDataAccess);
             virtual memory::Segment const * doGetDataSegment() const = 0;
             virtual memory::Segment       * doGetDataSegmentForUpdate();
 
@@ -275,12 +271,7 @@ namespace configmgr
             // set element access
             virtual void doInsertElement(SetNode const& _aNode, Name const& aName, SetNodeEntry const& aNewEntry) = 0;
 			virtual void doRemoveElement(SetNode const& _aNode, Name const& aName) = 0;
-
-            // strategy change support
-/*			virtual void doCommitChanges(Node const& _aNode);
-            virtual rtl::Reference<ViewStrategy> doCloneDirect() = 0;   
-            virtual rtl::Reference<ViewStrategy> doCloneIndirect() = 0; 
-*/		};
+		};
 
 //-----------------------------------------------------------------------------
         inline Name ViewStrategy::getName(Node const& _aNode)	const	
Index: configmgr/util/makefile.mk
===================================================================
RCS file: /cvs/util/configmgr/util/makefile.mk,v
retrieving revision 1.19
diff -u -p -u -r1.19 makefile.mk
--- configmgr/util/makefile.mk	8 Sep 2005 04:44:27 -0000	1.19
+++ configmgr/util/makefile.mk	5 Jan 2007 22:25:49 -0000
@@ -49,7 +49,7 @@ SHL1TARGET=	$(CFGMGR_TARGET)$(CFGMGR_MAJ
 .IF "$(OS)"=="MACOSX"
 #SHL1VERSIONMAP= $(TARGET).$(DLLPOSTFIX).map
 .ELSE
-SHL1VERSIONMAP= $(TARGET).map
+#SHL1VERSIONMAP= $(TARGET).map
 .ENDIF
 SHL1OBJS=$(SLOFILES)
 SHL1STDLIBS=\
@@ -91,7 +91,7 @@ SHL2TARGET=	$(CFGMGR_TARGET)$(CFGMGR_MAJ
 .IF "$(OS)"=="MACOSX"
 #SHL2VERSIONMAP= $(TARGET).$(DLLPOSTFIX).map
 .ELSE
-SHL2VERSIONMAP= $(TARGET)l.map
+#SHL2VERSIONMAP= $(TARGET)l.map
 .ENDIF
 SHL2OBJS=$(SLOFILES)
 SHL2STDLIBS=\
Index: configmgr/workben/makefile.mk
===================================================================
RCS file: /cvs/util/configmgr/workben/makefile.mk,v
retrieving revision 1.4
diff -u -p -u -r1.4 makefile.mk
--- configmgr/workben/makefile.mk	8 Mar 2006 14:02:03 -0000	1.4
+++ configmgr/workben/makefile.mk	5 Jan 2007 22:25:49 -0000
@@ -55,35 +55,7 @@ USE_LDUMP2=TRUE
 # CFGDEMO
 #
 APP1TARGET=	cfgdemo
-APP1OBJS=\
-	$(OBJ)$/treetests.obj \
-	$(SLO)$/xmltreebuilder.obj \
-	$(SLO)$/xmlformater.obj \
-	$(SLO)$/attributes.obj \
-	$(SLO)$/changes.obj \
-	$(SLO)$/confname.obj \
-	$(SLO)$/typeconverter.obj \
-	$(SLO)$/synchronize.obj	\
-	$(SLO)$/cmtree.obj \
-	$(SLO)$/cmtreemodel.obj \
-	$(SLO)$/localsession.obj \
-	$(SLO)$/mergeupdates.obj \
-	$(SLO)$/oslstream.obj \
-	$(SLO)$/saxtools.obj \
-	$(SLO)$/configsession.obj \
-	$(SLO)$/strimpl.obj \
-	$(SLO)$/tracer.obj \
-	$(SLO)$/confchangesset.obj \
-	$(SLO)$/filehelper.obj \
-	$(SLO)$/strconverter.obj \
-	$(SLO)$/updatedom.obj \
-	$(SLO)$/valuehandler.obj \
-	$(SLO)$/dataconverter.obj \
-
-#	$(OBJ)$/cmxmlexport.obj \
-#	$(OBJ)$/cmxmlimport.obj \
-
-#APP1RES=	$(RES)$/ucbdemo.res
+APP1OBJS= $(OBJ)$/testapp.obj 
 
 APP1STDLIBS=\
 	$(SALLIB) \
@@ -95,7 +67,8 @@ APP1STDLIBS=\
 	$(TOOLSLIB) \
 	$(UUILIB) \
 	$(SVTOOLLIB) \
-	$(SVLIB) 
+	$(SVLIB) \
+	-lconfigmgr2.uno
 
 .IF "$(GUI)"=="WNT"
 APP1STDLIBS+=$(LIBCIMT)
