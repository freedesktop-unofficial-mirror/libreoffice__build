? configmgr/workben/testapp.cxx
Index: configmgr/source/data/accessor.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/accessor.cxx,v
retrieving revision 1.7
diff -u -p -u -r1.7 accessor.cxx
--- configmgr/source/data/accessor.cxx	16 Sep 2006 15:09:26 -0000	1.7
+++ configmgr/source/data/accessor.cxx	21 Dec 2006 11:21:20 -0000
@@ -58,20 +58,13 @@ namespace configmgr
         : m_segment(segment)
         , m_refs(1)
         {
-            void const * base = m_segment ? m_segment->acquireReadAccess() : NULL;
-            m_base = static_cast<char const *>(base);
-        }
-    // -------------------------------------------------------------------------
-        Accessor::Impl::Impl(Segment const * segment, void const * base)
-        : m_segment(segment)
-        , m_base(static_cast<char const *>(base))
-        , m_refs(1)
-        {
+	    if (m_segment)
+		m_segment->acquireReadAccess();
         }
     // -------------------------------------------------------------------------
         Accessor::Impl::~Impl()
         {
-            if (m_segment) m_segment->releaseReadAccess(m_base);
+            if (m_segment) m_segment->releaseReadAccess();
         }
     // -------------------------------------------------------------------------
          /// Copies an Accessor
@@ -93,42 +86,12 @@ namespace configmgr
         {
             if (m_impl->is()) 
             {
-                Impl * pNewImpl = new Impl(0,0);
+                Impl * pNewImpl = new Impl(0);
                 releaseImpl();
                 m_impl = pNewImpl;
             }
             OSL_POSTCOND(!this->is(),"Accessor::clear: Could not clear");
         }
-
-    // -------------------------------------------------------------------------
-        void * Accessor::failNull()
-        {
-            OSL_ENSURE(false,"Unexpected NULL Address or Accessor");
-            return NULL;
-        }
-    // -------------------------------------------------------------------------
-
-    #if OSL_DEBUG_LEVEL > 0
-        void const * Accessor::resolve(AddressType _p) const 
-        { 
-            OSL_ENSURE( !_p.is() || segment_()->isValidAddress(_p.value()), "Address does not belong to this segment");
-            return _p.is() ? base_() + _p.value() : NULL; 
-        }
-
-        Pointer  Accessor::reduce(void const * _p) const
-        {
-            if (_p)
-            {
-                Pointer::RawAddress addr = static_cast<char const *>(_p) - base_();
-                OSL_ENSURE( segment_()->isValidAddress(addr), "Pointer does not belong to this segment");
-                return Pointer(addr); 
-            }
-            else
-                return Pointer();
-        }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
Index: configmgr/source/data/anydata.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/anydata.cxx,v
retrieving revision 1.4.12.1
diff -u -p -u -r1.4.12.1 anydata.cxx
--- configmgr/source/data/anydata.cxx	3 Nov 2006 11:34:29 -0000	1.4.12.1
+++ configmgr/source/data/anydata.cxx	21 Dec 2006 11:21:20 -0000
@@ -61,7 +61,6 @@ namespace configmgr
         namespace Type = data::Type;
         namespace uno = ::com::sun::star::uno;
         typedef AnyData::TypeCode TypeCode;
-        using memory::Pointer;
 //-----------------------------------------------------------------------------	
 
 TypeCode getTypeCode(uno::Type const & _aType)
@@ -200,7 +199,7 @@ uno::Type getUnoType( TypeCode _aType)
 //-----------------------------------------------------------------------------	
 
 static
-AnyData allocSimpleData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, uno::Any const & _aAny)
+AnyData allocSimpleData(TypeCode _aSimpleType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -234,9 +233,7 @@ AnyData allocSimpleData(memory::Allocato
             sal_Int64 nValue;
             OSL_VERIFY(_aAny >>= nValue);
 
-            Address aStorage = _anAllocator.allocate( sizeof nValue );
-            *static_cast<sal_Int64*>( _anAllocator.access(aStorage) ) = nValue;
-            aResult.longValue = aStorage;
+            aResult.longValue = Address( new sal_Int64( nValue ) );
         }
         break;
 
@@ -245,9 +242,7 @@ AnyData allocSimpleData(memory::Allocato
             double dValue;
             OSL_VERIFY(_aAny >>= dValue);
 
-            Address aStorage = _anAllocator.allocate( sizeof dValue );
-            *static_cast<double*>( _anAllocator.access(aStorage) ) = dValue;
-            aResult.doubleValue = aStorage;
+            aResult.doubleValue = Address( new double( dValue ) );
         }
         break;
 
@@ -255,7 +250,7 @@ AnyData allocSimpleData(memory::Allocato
         {
             uno::Sequence<sal_Int8> aValue;
             OSL_VERIFY(_aAny >>= aValue);
-            aResult.binaryValue = allocBinary(_anAllocator,aValue);
+            aResult.binaryValue = allocBinary(aValue);
         }
         break;
 
@@ -290,7 +285,7 @@ sal_Sequence const * extractSequenceData
 //-----------------------------------------------------------------------------	
 
 static
-AnyData allocSequenceData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, uno::Any const & _aAny)
+AnyData allocSequenceData(TypeCode _aSimpleType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -302,7 +297,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<rtl::OUString> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -310,7 +305,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Bool> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -318,7 +313,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Int16> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -326,7 +321,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Int32> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -334,7 +329,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<sal_Int64> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -342,7 +337,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<double> aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -350,7 +345,7 @@ AnyData allocSequenceData(memory::Alloca
         {
             uno::Sequence<uno::Sequence<sal_Int8> > aSeqValue;
             if (sal_Sequence const * pData = extractSequenceData(aSeqValue,_aAny))
-                aSequence = allocSequence(_anAllocator,_aSimpleType,pData);
+                aSequence = allocSequence(_aSimpleType,pData);
         }
         break;
 
@@ -366,28 +361,20 @@ AnyData allocSequenceData(memory::Alloca
 }
 //-----------------------------------------------------------------------------	
 
-AnyData allocData(memory::Allocator const& _anAllocator, TypeCode _aType, uno::Any const & _aAny)
+AnyData allocData(TypeCode _aType, uno::Any const & _aAny)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
     OSL_ENSURE( _aType == getTypeCode(_aAny.getValueType()), "Type code does not match value" );
 
     if (_aType & Type::flag_sequence)
-        return allocSequenceData(_anAllocator,TypeCode( _aType & Type::mask_basetype),_aAny);
-
+        return allocSequenceData(TypeCode( _aType & Type::mask_basetype),_aAny);
     else
-        return allocSimpleData(_anAllocator,_aType,_aAny);
-}
-//-----------------------------------------------------------------------------	
-/*
-AnyData copyData(memory::Allocator const& _anAllocator, TypeCode _aType, AnyData _aData)
-{
-    OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
+        return allocSimpleData(_aType,_aAny);
 }
-*/
 //-----------------------------------------------------------------------------	
 
 static
-void freeSimpleData(memory::Allocator const& _anAllocator, TypeCode _aSimpleType, AnyData const & _aData)
+void freeSimpleData(TypeCode _aSimpleType, AnyData const & _aData)
 {
     OSL_ENSURE( _aSimpleType == (_aSimpleType & Type::mask_basetype), "Invalid type code" );
 
@@ -405,15 +392,15 @@ void freeSimpleData(memory::Allocator co
 
         // free memory for oversized values
     case Type::value_long:
-        _anAllocator.deallocate(_aData.longValue);
+        delete (sal_uInt64 *)_aData.longValue;
         break;
 
     case Type::value_double:
-        _anAllocator.deallocate(_aData.doubleValue);
+        delete (double *)_aData.doubleValue;
         break;
 
     case Type::value_binary:
-        freeBinary(_anAllocator, _aData.binaryValue);
+        freeBinary(_aData.binaryValue);
         break;
 
     case Type::value_any: 
@@ -427,15 +414,15 @@ void freeSimpleData(memory::Allocator co
 }
 //-----------------------------------------------------------------------------	
 
-void    freeData(memory::Allocator const& _anAllocator, TypeCode _aType, AnyData _aData)
+void    freeData(TypeCode _aType, AnyData _aData)
 {
     OSL_ENSURE( _aType == (_aType & Type::mask_valuetype), "Invalid type code" );
 
     if (_aType & Type::flag_sequence)
-        freeSequence(_anAllocator,TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
+        freeSequence(TypeCode(_aType & Type::mask_basetype),_aData.sequenceValue);
 
     else
-        freeSimpleData(_anAllocator,_aType,_aData);
+        freeSimpleData(_aType,_aData);
 }
 //-----------------------------------------------------------------------------	
 
@@ -462,22 +449,14 @@ uno::Any readSimpleData(memory::Accessor
         return uno::makeAny( _aData.intValue );
 
     case Type::value_long:
-        {
-            void const * pStorage = _anAccessor.validate( Pointer(_aData.longValue) );
-            sal_Int64 const * pValue = static_cast<sal_Int64 const *>(pStorage);
-            return uno::makeAny( *pValue );
-        }
+	return uno::makeAny( *(sal_Int64 const *)_aData.longValue );
 
     case Type::value_double:
-        {
-            void const * pStorage = _anAccessor.validate( Pointer(_aData.doubleValue) );
-            double const * pValue = static_cast<double const *>(pStorage);
-            return uno::makeAny( *pValue );
-        }
+	return uno::makeAny( *(double const *)_aData.doubleValue );
 
     case Type::value_binary:
         {
-            uno::Sequence<sal_Int8> aValue = readBinary( _anAccessor, _aData.binaryValue );
+            uno::Sequence<sal_Int8> aValue = readBinary( _aData.binaryValue );
             return uno::makeAny( aValue );
         }
 
Index: configmgr/source/data/heap.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/heap.cxx,v
retrieving revision 1.4
diff -u -p -u -r1.4 heap.cxx
--- configmgr/source/data/heap.cxx	16 Sep 2006 15:09:54 -0000	1.4
+++ configmgr/source/data/heap.cxx	21 Dec 2006 11:21:20 -0000
@@ -42,61 +42,5 @@
 #include <osl/diagnose.h>
 #endif
 
-// -----------------------------------------------------------------------------	
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        const Heap::Size c_nDefaultSize = 4096;
-    // -------------------------------------------------------------------------
-        Heap::Heap(HeapManager& _impl)
-        : m_impl(_impl)
-        , m_heap(_impl.createHeap(c_nDefaultSize))
-        , m_size(c_nDefaultSize)
-        {
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Heap(HeapManager& _impl, Size _nInitialSize)
-        : m_impl(_impl)
-        , m_heap(_impl.createHeap(_nInitialSize))
-        , m_size(_nInitialSize)
-        {
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Heap(HeapManager& _impl, HeapId const & _anId)
-        : m_impl(_impl)
-        , m_size(0)
-        {
-            m_heap = _impl.attachHeap(_anId,m_size);
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::~Heap()
-        {
-            m_impl.destroyHeap(m_heap);
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Size Heap::grow(Size _nReqSize) // returns the (possibly new) base
-        {
-            Size nNewSize = m_impl.growHeap(m_heap, _nReqSize);
-
-            if (nNewSize)
-            {
-                OSL_ENSURE(nNewSize >= _nReqSize, "Error: Heapmanager returns invalid size from grow method");
-                m_size = nNewSize;
-            }
-
-            return nNewSize;
-        }
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
 
 
Index: configmgr/source/data/segmentheap.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/segmentheap.cxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 segmentheap.cxx
--- configmgr/source/data/segmentheap.cxx	16 Sep 2006 15:10:09 -0000	1.3
+++ configmgr/source/data/segmentheap.cxx	21 Dec 2006 11:21:20 -0000
@@ -36,73 +36,3 @@
 // MARKER(update_precomp.py): autogen include statement, do not remove
 #include "precompiled_configmgr.hxx"
 
-#include "segmentheap.hxx"
-
-#ifndef _OSL_DIAGNOSE_H_
-#include <osl/diagnose.h>
-#endif
-
-// -----------------------------------------------------------------------------	
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        const Heap::Size c_nMaxHeapSize = 0x40000000;
-        const Heap::Size c_nGrowFactor  = 2;
-
-    // -------------------------------------------------------------------------
-
-        SegmentHeap::~SegmentHeap()
-        {
-            m_heap.destroyLock(m_lock);
-        }
-    // -------------------------------------------------------------------------
-
-        void SegmentHeap::init()
-        {
-            m_lock = m_heap.createLock();
-            m_base = m_heap.base();
-
-            OSL_ENSURE(m_lock,"Could not create heap lock");
-        }
-    // -------------------------------------------------------------------------
-
-        Heap::Address SegmentHeap::allocateMore(Size _sz)
-        {
-            Size nCurSize = m_heap.size();
-
-            OSL_ENSURE(_sz <= c_nMaxHeapSize,"Cannot allocate: Allocation request too large");
-            if (_sz > c_nMaxHeapSize) return 0;
-
-            Size nCurSizeLimit = (c_nMaxHeapSize-_sz)/c_nGrowFactor;
-            OSL_ENSURE(nCurSize < nCurSizeLimit,"Allocation will reach heap limit");
-
-            Size nNewSize = (nCurSize < nCurSizeLimit ) 
-                                ? nCurSize * c_nGrowFactor + _sz 
-                                : c_nMaxHeapSize;
-
-            if (m_heap.grow(nNewSize))
-            {
-                m_base = m_heap.base();
-
-                Address aResult = m_heap.allocate(_sz);
-
-                OSL_ENSURE(aResult,"Cannot allocate even after growing heap");
-
-                return aResult;
-            }
-            else
-            {
-                OSL_ENSURE(false,"Cannot allocate: Heap could not be grown");
-                return 0;
-            }
-        }
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-
Index: configmgr/source/data/sequence.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/sequence.cxx,v
retrieving revision 1.6.12.1
diff -u -p -u -r1.6.12.1 sequence.cxx
--- configmgr/source/data/sequence.cxx	3 Nov 2006 11:34:42 -0000	1.6.12.1
+++ configmgr/source/data/sequence.cxx	21 Dec 2006 11:21:20 -0000
@@ -64,9 +64,7 @@ namespace configmgr
         namespace Type = data::Type;
         namespace uno = ::com::sun::star::uno;
         typedef AnyData::TypeCode TypeCode;
-        using memory::Allocator;
         using memory::Accessor;
-        using memory::Pointer;
 //-----------------------------------------------------------------------------	
 static 
 sal_uInt32 implGetElementSize(TypeCode _aElementType)
@@ -108,32 +106,20 @@ sal_uInt32 implGetHeaderSize(sal_uInt32 
 //-----------------------------------------------------------------------------	
 static 
 inline
-sal_Int32& implGetSize(Allocator const& _anAllocator, Sequence _aSeq)
+sal_Int32& implGetSize(Sequence _aSeq)
 {
-    OSL_ASSERT(_aSeq != 0);
-    void * pBase = _anAllocator.access(_aSeq);
-    return * static_cast<sal_Int32 *>(pBase);
+    return * (sal_Int32 *) _aSeq;
 }
 
 //-----------------------------------------------------------------------------	
 static 
-inline
-sal_Int32 implGetSize(Accessor const& _anAccessor, Sequence _aSeq)
-{
-    OSL_ASSERT(_aSeq != 0);
-    void const * pBase = _anAccessor.access( Pointer(_aSeq) );
-    return * static_cast<sal_Int32 const *>(pBase);
-}
-
-//-----------------------------------------------------------------------------	
-static 
-Sequence implSeqAlloc(Allocator const& _anAllocator, sal_Int32 _nElements, sal_uInt32 _nElemSize)
+Sequence implSeqAlloc(sal_Int32 _nElements, sal_uInt32 _nElemSize)
 {
     sal_uInt32 nTotalSize = implGetHeaderSize(_nElemSize) + _nElements * _nElemSize;
 
-    Sequence aResult = _anAllocator.allocate(nTotalSize);
+    Sequence aResult = (Sequence) (new sal_uInt8[nTotalSize]);
 
-    implGetSize(_anAllocator,aResult) = _nElements;
+    implGetSize(aResult) = _nElements;
 
     return aResult;
 }
@@ -141,7 +127,7 @@ Sequence implSeqAlloc(Allocator const& _
 //-----------------------------------------------------------------------------	
 
 static
-void allocSeqData(Allocator const& _anAllocator, Address _aDestAddr, 
+void allocSeqData(Address _aDestAddr, 
                  TypeCode _aElementType, 
                  sal_Int32 _nElements, sal_uInt32 _nElementSize, 
                  void const * _pSourceData)
@@ -155,7 +141,7 @@ void allocSeqData(Allocator const& _anAl
     case Type::value_int:
     case Type::value_long:
     case Type::value_double:
-        ::memcpy(_anAllocator.access(_aDestAddr),_pSourceData,_nElements * _nElementSize);
+        ::memcpy(_aDestAddr,_pSourceData,_nElements * _nElementSize);
         break;
 
     case Type::value_string: 
@@ -168,7 +154,7 @@ void allocSeqData(Allocator const& _anAl
             {
                 String aElement = allocString(*pSource);
 
-                String * pDest = static_cast<String*>( _anAllocator.access(_aDestAddr) );
+                String * pDest = reinterpret_cast<String*>(_aDestAddr);
                 *pDest = aElement;
                 
                 ++pSource;
@@ -186,9 +172,9 @@ void allocSeqData(Allocator const& _anAl
 
             while (--_nElements >= 0)
             {
-                Vector aElement = allocBinary(_anAllocator,*pSource);
+                Vector aElement = allocBinary(*pSource);
 
-                Vector * pDest = static_cast<Vector*>( _anAllocator.access(_aDestAddr) );
+                Vector * pDest = (Vector *) _aDestAddr;
                 *pDest = aElement;
                 
                 ++pSource;
@@ -205,7 +191,7 @@ void allocSeqData(Allocator const& _anAl
 }
 
 //-----------------------------------------------------------------------------	
-Sequence allocSequence(Allocator const& _anAllocator, TypeCode _aElementType, ::sal_Sequence const * _pSeqData)
+Sequence allocSequence(TypeCode _aElementType, ::sal_Sequence const * _pSeqData)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -218,10 +204,10 @@ Sequence allocSequence(Allocator const& 
     sal_uInt32 const nElementSize = implGetElementSize(_aElementType);
     sal_Int32  const nElements = _pSeqData->nElements;
 
-    Sequence aResult = implSeqAlloc(_anAllocator,nElements,nElementSize);
+    Sequence aResult = implSeqAlloc(nElements,nElementSize);
 
     if (aResult)
-        allocSeqData( _anAllocator, aResult + implGetHeaderSize(nElementSize), 
+        allocSeqData( aResult + implGetHeaderSize(nElementSize), 
                         _aElementType, nElements, nElementSize,
                         _pSeqData->elements);
 
@@ -229,31 +215,25 @@ Sequence allocSequence(Allocator const& 
 }
 
 //-----------------------------------------------------------------------------	
-Sequence allocBinary(Allocator const& _anAllocator, uno::Sequence<sal_Int8> const & _aBinaryValue)
+Sequence allocBinary(uno::Sequence<sal_Int8> const & _aBinaryValue)
 {
     sal_uInt32 const nElementSize = 1;
     sal_Int32  const nLength = _aBinaryValue.getLength();
 
-    Sequence aResult = implSeqAlloc(_anAllocator,nLength,nElementSize);
+    Sequence aResult = implSeqAlloc(nLength,nElementSize);
 
     if (aResult)
     {
         Address aElementBaseAddr = aResult + implGetHeaderSize(nElementSize);
-        ::memcpy(_anAllocator.access(aElementBaseAddr), _aBinaryValue.getConstArray(), nLength);
+        ::memcpy(aElementBaseAddr, _aBinaryValue.getConstArray(), nLength);
     }
 
     return aResult;
 }
 
 //-----------------------------------------------------------------------------	
-// Sequence copySequence(Allocator const& _anAllocator, TypeCode _aElementType, Sequence _aSeq)
-
-//-----------------------------------------------------------------------------	
-// Sequence copyBinary(Allocator const& _anAllocator, Sequence _aSeq)
-
-//-----------------------------------------------------------------------------	
 static
-void freeSeqData(Allocator const& _anAllocator, Address _aDataAddr, 
+void freeSeqData(Address _aDataAddr, 
                  TypeCode _aElementType, sal_Int32 _nElements)
 {
     OSL_ASSERT(_aElementType == (_aElementType & Type::mask_basetype));
@@ -270,7 +250,7 @@ void freeSeqData(Allocator const& _anAll
 
     case Type::value_string: 
         {
-            String * pElements = static_cast<String*>( _anAllocator.access(_aDataAddr) );
+            String * pElements = reinterpret_cast<String*>( _aDataAddr );
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
@@ -281,11 +261,11 @@ void freeSeqData(Allocator const& _anAll
 
     case Type::value_binary:
         {
-            Vector * pElements = static_cast<Vector*>( _anAllocator.access(_aDataAddr) );
+            Vector * pElements = reinterpret_cast<Vector*>( _aDataAddr );
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
-                freeBinary(_anAllocator,pElements[i]);
+                freeBinary(pElements[i]);
             }
         }
         break;
@@ -298,7 +278,7 @@ void freeSeqData(Allocator const& _anAll
 }
 
 //-----------------------------------------------------------------------------	
-void freeSequence(Allocator const& _anAllocator, TypeCode _aElementType, Sequence _aSeq)
+void freeSequence(TypeCode _aElementType, Sequence _aSeq)
 {
     OSL_ENSURE(_aElementType == (_aElementType & Type::mask_valuetype), "Invalid type code");
 
@@ -310,18 +290,18 @@ void freeSequence(Allocator const& _anAl
 
     sal_uInt32 nHeaderSize = implGetHeaderSize( implGetElementSize( _aElementType ) );
 
-    freeSeqData(_anAllocator,_aSeq + nHeaderSize, _aElementType, implGetSize(_anAllocator,_aSeq));
+    freeSeqData(_aSeq + nHeaderSize, _aElementType, implGetSize(_aSeq));
 
-    _anAllocator.deallocate(_aSeq);
+    delete[] (sal_uInt8 *)_aSeq;
 }
 
 //-----------------------------------------------------------------------------	
-void freeBinary(memory::Allocator const& _anAllocator, Sequence _aSeq)
+void freeBinary(Sequence _aSeq)
 {
     OSL_ENSURE(_aSeq, "ERROR: Trying to free a NULL sequence");
     if (_aSeq == 0) return;
 
-    _anAllocator.deallocate(_aSeq);
+    delete[] (sal_uInt8 *)_aSeq;
 }
 
 //-----------------------------------------------------------------------------	
@@ -342,11 +322,11 @@ sal_Sequence * implCreateSequence(void c
 
 //-----------------------------------------------------------------------------	
 static
-sal_Sequence * readSeqData(Accessor const & _anAccessor, Address _aDataAddr, TypeCode _aElementType, sal_Int32 _nElements)
+sal_Sequence * readSeqData(Address _aDataAddr, TypeCode _aElementType, sal_Int32 _nElements)
 {
     OSL_ASSERT(_aElementType == (_aElementType & Type::mask_basetype));
 
-    void const * pElementData = _anAccessor.validate( Pointer(_aDataAddr) );
+    void const * pElementData = (void const *)_aDataAddr;
     switch (_aElementType)
     {
     case Type::value_boolean:
@@ -384,7 +364,7 @@ sal_Sequence * readSeqData(Accessor cons
 
             for (sal_Int32 i = 0; i < _nElements; ++i)
             {
-                pResult[i] = readBinary(_anAccessor,pElements[i]);
+                pResult[i] = readBinary(pElements[i]);
             }
 
             sal_Sequence * pRet = aResult.get();
@@ -413,7 +393,8 @@ sal_Sequence * readSeqData(Accessor cons
 
     sal_uInt32 nHeaderSize = implGetHeaderSize( implGetElementSize( _aElementType ) );
 
-    return readSeqData(_anAccessor,_aSeq + nHeaderSize, _aElementType, implGetSize(_anAccessor,_aSeq));
+    // URG - accidentally removed an accessor instead of an allocator ... :-)
+    return readSeqData(_aSeq + nHeaderSize, _aElementType, implGetSize(_aSeq));
 }
 
 //-----------------------------------------------------------------------------	
@@ -487,20 +468,13 @@ uno::Any readAnySequence(Accessor const&
 }
 
 //-----------------------------------------------------------------------------	
-uno::Sequence<sal_Int8> readBinary(Accessor const& _anAccessor, Sequence _aSeq)
+uno::Sequence<sal_Int8> readBinary(Sequence _aSeq)
 {
     OSL_ENSURE(_aSeq, "ERROR: Trying to read from a NULL sequence");
     if (_aSeq == 0) return uno::Sequence<sal_Int8>();
 
-    sal_Int32 const nElements = implGetSize(_anAccessor,_aSeq);
-
-    void const * const pElementData = _anAccessor.validate( Pointer(_aSeq + implGetHeaderSize(1)) );
-
-    sal_Int8 const * const pBinaryData = static_cast<sal_Int8 const *>(pElementData);
-
-    uno::Sequence< sal_Int8 > aSequence(pBinaryData,nElements); 
-
-    return aSequence;
+    return uno::Sequence< sal_Int8 >((const sal_Int8 *)(_aSeq + implGetHeaderSize(1)),
+				     implGetSize(_aSeq));
 }
 
 //-----------------------------------------------------------------------------	
Index: configmgr/source/data/simpleheap.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/simpleheap.cxx,v
retrieving revision 1.8
diff -u -p -u -r1.8 simpleheap.cxx
--- configmgr/source/data/simpleheap.cxx	16 Sep 2006 15:10:36 -0000	1.8
+++ configmgr/source/data/simpleheap.cxx	21 Dec 2006 11:21:20 -0000
@@ -1,3 +1,4 @@
+#include <stdio.h>
 /*************************************************************************
  *
  *  OpenOffice.org - a multi-platform office productivity suite
@@ -57,418 +58,3 @@
 #include <map>
 #define INCLUDED_MAP
 #endif
-
-#ifdef _MSC_VER
-#pragma warning( disable : 4355 )
-#endif
-
-// -----------------------------------------------------------------------------	
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        extern HeapManager & localHeap();
-    // -------------------------------------------------------------------------
-        struct OrderByHeapId
-        {
-            typedef HeapManager::HeapIdParam HeapIdParam;
-
-            bool operator()(HeapIdParam lhs, HeapIdParam rhs) const 
-            {
-                return lhs.compareTo(rhs) < 0;
-            }
-        };
-    // -------------------------------------------------------------------------
-        struct HeapSet
-        {
-            typedef HeapManager::HeapIdParam    HeapIdParam;
-            typedef HeapManager::HeapId         HeapId;
-            typedef HeapManager::Handle         Heap;
-
-            typedef std::map<HeapId,Heap,OrderByHeapId> Map;
-
-            HeapSet(HeapManager & _mgr) : m_mgr(_mgr) {}
-
-            Heap add(Heap _aHeap) { return m_heaps[m_mgr.id(_aHeap)] = _aHeap; }
-            void remove(Heap _aHeap) { m_heaps.erase(m_mgr.id(_aHeap)); }
-
-            Heap heap(HeapIdParam _anId) const 
-            {
-                Map::const_iterator it = m_heaps.find(_anId);
-                return it != m_heaps.end() ? it->second : NULL;
-            }
-        private:
-            HeapManager &   m_mgr;
-            Map             m_heaps;
-        };
-    // -------------------------------------------------------------------------
-        class SimpleHeapManagerBase : public HeapManager
-        {
-            static void * ptr(Address _address) { return reinterpret_cast<void*>(_address); }
-            static Address address(void * _ptr) { return reinterpret_cast<Address>(_ptr); }
-            // if this static assertion breaks, a less simple heap manager is needed (-> 64 bit ports)
-            static char address_can_hold_any_pointer[sizeof(Address) - sizeof(void*) + 1];
-
-            virtual void *  base(Handle _aHeap);
-        protected: 
-            SimpleHeapManagerBase() : m_heaps( *(HeapManager*)this) {}
-            virtual ~SimpleHeapManagerBase() {}
-
-            Handle  addHeap(Handle _aHeap)      { return m_heaps.add(_aHeap);   }
-            void    removeHeap(Handle _aHeap)   { m_heaps.remove(_aHeap);       }
-
-            Handle  findHeap( HeapId _anId )    
-            { 
-                osl::MutexGuard aGuard(m_mutex); 
-                return m_heaps.heap(_anId);  
-            }
-
-            osl::Mutex & getHeapListMutex()     { return m_mutex; }
-        protected:      
-            Address allocateMemory(Size _sz);
-            Address reallocateMemory(Address _p, Size _sz);
-            void    deallocateMemory(Address _p);
-
-        protected:      
-            virtual Lock *  createHeapLock(Handle _aHeap);
-            virtual void    destroyHeapLock(Handle _aHeap, Lock * _pLock);
-
-        private:
-            osl::Mutex  m_mutex;
-            HeapSet     m_heaps;
-        };
-    // -------------------------------------------------------------------------
-        class SimpleCheckingHeapManager : public SimpleHeapManagerBase
-        {
-            struct HeapData
-            {
-                HeapId      id;
-                
-                oslInterlockedCount  refs;
-
-                Size        requested;
-                Size        allocated;
-
-                Size available() const { return requested-allocated; }
-
-                typedef std::map<Address, Size> Map;
-                Map allocations;
-            };
-
-            static HeapData * heap(Handle _handle) { return reinterpret_cast<HeapData*>(_handle); }
-            static Handle handle(HeapData * _data) { return reinterpret_cast<Handle>(_data); }
-
-            static void makeNewId(HeapData * _data);
-       public:      
-            virtual Handle createHeap(Size _sInitialSize);
-            virtual Handle attachHeap(HeapIdParam  _anId, Size & _rInitialSize);
-            virtual Size   growHeap(Handle _aHeap, Size _sNewSize);
-            virtual void   destroyHeap(Handle _aHeap);
-
-            virtual HeapId  id(Handle _aHeap);
-
-            virtual Address allocate(Handle _aHeap, Size _sNewSize);
-            virtual Address reallocate(Handle _aHeap, Address _aOldAddress, Size _sNewSize);
-            virtual void    deallocate(Handle _aHeap, Address _aAddress);
-            virtual bool    didAllocate(Handle _aHeap, Address _aAddress);
-        };
-    // -------------------------------------------------------------------------
-        class SimpleHeapLock : public DataLock
-        {
-            osl::Mutex m_mutex;
-        public:   
-            virtual void acquireReadAccess() { m_mutex.acquire(); }
-            virtual void releaseReadAccess() { m_mutex.release(); }
-
-            virtual void acquireWriteAccess() { m_mutex.acquire(); }     
-            virtual void releaseWriteAccess() { m_mutex.release(); }
-        };
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-        HeapManager & cacheHeap()
-        {
-            static SimpleCheckingHeapManager aInstance;
-            return aInstance;
-        }
-    // -------------------------------------------------------------------------
-        HeapManager & localHeap()
-        {
-            static SimpleCheckingHeapManager aInstance;
-            return aInstance;
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleHeapManagerBase::allocateMemory(Size _sz)
-        {
-            void * p = ::rtl_allocateMemory(_sz);
-
-            OSL_ENSURE(p,"Could not allocate: std::malloc failed");
-
-            return address(p);
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleHeapManagerBase::reallocateMemory(Address _p, Size _sz)
-        {
-            void * pOld = ptr(_p);
-
-            void * pNew = ::rtl_reallocateMemory(pOld,_sz);
-
-            OSL_ENSURE(pNew,"Could not reallocate: std::realloc failed");
-
-            return address(pNew);
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleHeapManagerBase::deallocateMemory(Address _p)
-        {
-            void * p = ptr(_p);
-
-            ::rtl_freeMemory(p); 
-        }
-    // -------------------------------------------------------------------------
-
-        void *  SimpleHeapManagerBase::base(Handle /*_aHeap*/)
-        {
-            return NULL;
-        }
-    // -------------------------------------------------------------------------
-
-        DataLock *  SimpleHeapManagerBase::createHeapLock(Handle )
-        {
-            return new SimpleHeapLock();
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleHeapManagerBase::destroyHeapLock(Handle , DataLock * _pLock)
-        {
-            if (SimpleHeapLock* pMyLock = /*dynamic_*/ static_cast<SimpleHeapLock*>(_pLock))
-            {
-                delete pMyLock;
-            }
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-
-        void SimpleCheckingHeapManager::makeNewId(HeapData * _data)
-        {
-            OSL_PRECOND( _data, "Internal Error: NULL data");
-
-            sal_Int64 nData = reinterpret_cast<sal_Int64>(_data);
-
-            HeapId aNewId = HeapId::valueOf(nData,16);
-
-            _data->id = aNewId;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::HeapId SimpleCheckingHeapManager::id(Handle _aHeap)
-        {
-            if (_aHeap == 0) return HeapId();
-
-            HeapData * data = heap(_aHeap);
-
-            return data->id;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Handle SimpleCheckingHeapManager::createHeap(Size _sInitialSize)
-        {
-            // need to have 4-byte pointers for this implementation
-            OSL_ASSERT(sizeof(void *) == sizeof(Address));
-
-            HeapData * pHeap = new HeapData();
-
-            pHeap->refs      = 1;
-
-            pHeap->requested = _sInitialSize;
-            pHeap->allocated = 0;
-
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            makeNewId( pHeap );
-
-            OSL_ENSURE( ! findHeap(pHeap->id), "Internal Error: New heap id already registered");
-
-            return addHeap(handle(pHeap) );
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Handle SimpleCheckingHeapManager::attachHeap(HeapIdParam  _anId, Size & _rInitialSize)
-        {
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            Handle aHeap = findHeap(_anId);
-
-            OSL_ENSURE( aHeap, "Error: No such Heap");
-
-            if (aHeap != 0)
-            {
-                HeapData * data = heap(aHeap);
-
-                OSL_ENSURE( data->id == _anId, "Internal error: Inconsistent heap id");
-
-                _rInitialSize = data->requested;
-             
-                ++data->refs;
-            }
-            else
-                _rInitialSize = 0;
-
-            return aHeap;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Size   SimpleCheckingHeapManager::growHeap(Handle _aHeap, Size _sNewSize)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            if (data->requested < _sNewSize) data->requested = _sNewSize; 
-
-            return data->requested;
-        }
-    // -------------------------------------------------------------------------
-
-        void   SimpleCheckingHeapManager::destroyHeap(Handle _aHeap)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            osl::MutexGuard aGuard( getHeapListMutex() );
-
-            if (0 == --data->refs)
-            {
-                OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-    //            OSL_ENSURE(data->allocations.empty(), "Memory leaks found");
-                for (HeapData::Map::iterator it = data->allocations.begin();
-                     it != data->allocations.end();
-                     ++it)
-                {
-                    deallocateMemory(it->first);
-                    data->allocated -= it->second;
-
-                }
-                OSL_ENSURE(data->allocated == 0, "Memory tracking error detected");
-
-                removeHeap(_aHeap);
-
-                delete data;
-            }
-        }
-    // -------------------------------------------------------------------------
-
-        bool SimpleCheckingHeapManager::didAllocate(Handle _aHeap, Address _aAddress)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-            OSL_PRECOND( _aAddress, "Warning: checking NULL address - will fail");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            /* Condition is:
-                    allocationAddress <= _aAddress &&
-                    _aAddress <= allocationAddress + allocationSize
-               (<= to allow past-the-end pointer)
-            */
-
-            HeapData::Map::iterator it = data->allocations.upper_bound(_aAddress);
-
-            if (it == data->allocations.begin()) 
-                return false;
-
-            --it; // Now it is the last iterator that is less than or equal to _aAddress
-
-            OSL_ASSERT( it->first <= _aAddress ); // first part of condition handled by map
-
-            return _aAddress <= it->first + it->second;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleCheckingHeapManager::allocate(Handle _aHeap, Size _nSize)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            if (_nSize > data->available()) 
-                return 0;
-
-            Address p = allocateMemory(_nSize);
-            if (p)
-            {
-                data->allocations[p] = _nSize;
-                data->allocated += _nSize;
-            }
-            return p;
-        }
-    // -------------------------------------------------------------------------
-
-        HeapManager::Address SimpleCheckingHeapManager::reallocate(Handle _aHeap, Address _aOld, Size _nNewSize)
-        {
-            if (_aOld == 0) return allocate(_aHeap,_nNewSize);
-
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            OSL_ENSURE( data->allocations.count(_aOld), "Error: pointer being reallocated is not from this data");
-
-            Size nOldSize = data->allocations[_aOld];
-
-            if (nOldSize >= _nNewSize) 
-                return _aOld;
-
-            if (_nNewSize-nOldSize > data->available()) 
-                return 0;
-
-            Address aNew = reallocateMemory(_aOld,_nNewSize);
-            if (aNew)
-            {
-                if (aNew != _aOld) data->allocations.erase(_aOld);
-
-                data->allocations[aNew] = _nNewSize;
-                data->allocated += _nNewSize - nOldSize;
-            }
-
-            return aNew;
-        }
-    // -------------------------------------------------------------------------
-
-        void SimpleCheckingHeapManager::deallocate(Handle _aHeap, Address _p)
-        {
-            OSL_PRECOND( _aHeap, "Error: NULL data");
-            OSL_PRECOND( _p, "Error: Trying to free NULL address");
-
-            HeapData * data = heap(_aHeap);
-
-            OSL_ENSURE( findHeap(data->id) == _aHeap, "Internal error: Inconsistent heap id");
-
-            OSL_ENSURE( data->allocations.count(_p), "Error: pointer being freed is not from this data");
-
-            Size freed = data->allocations[_p];
-            data->allocated -= freed;
-            data->allocations.erase(_p);
-
-            deallocateMemory(_p);
-        }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-
Index: configmgr/source/data/updateaccessor.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/data/updateaccessor.cxx,v
retrieving revision 1.7
diff -u -p -u -r1.7 updateaccessor.cxx
--- configmgr/source/data/updateaccessor.cxx	16 Sep 2006 15:11:05 -0000	1.7
+++ configmgr/source/data/updateaccessor.cxx	21 Dec 2006 11:21:20 -0000
@@ -57,13 +57,13 @@ namespace configmgr
         UpdateAccessor::UpdateAccessor(Segment * segment)
         : m_segment(segment)
         {
-            m_heap = (m_segment) ? &m_segment->acquireWriteAccess() : 0;
-            OSL_ASSERT( m_heap || !m_segment );
+			m_segment->acquireWriteAccess();
         }
     // -------------------------------------------------------------------------
         UpdateAccessor::~UpdateAccessor()
         {
-            if (m_segment) m_segment->releaseWriteAccess(*m_heap);
+			if (m_segment)
+				m_segment->releaseWriteAccess();
         }
     // -------------------------------------------------------------------------
         Accessor UpdateAccessor::accessor() const
@@ -75,15 +75,14 @@ namespace configmgr
         Accessor UpdateAccessor::downgrade()
         {
             Segment * segment = m_segment;
-            void const * base = NULL;
+
             if (m_segment)
             {
-                base = m_segment->acquireReadAccess();
-                m_segment->releaseWriteAccess(*m_heap);
+				m_segment->downgradeAccess();
                 m_segment = 0;
             }
 
-            return Accessor(segment, base, SAL_NO_ACQUIRE);
+            return Accessor(segment, SAL_NO_ACQUIRE);
         }
 
     // -------------------------------------------------------------------------
@@ -91,79 +90,10 @@ namespace configmgr
         {
             if (m_segment)
             {
-                m_segment->releaseWriteAccess(*m_heap);
+                m_segment->releaseWriteAccess();
                 m_segment = NULL;
             }
         }
-
-    // -------------------------------------------------------------------------
-        char * UpdateAccessor::heap_base() const
-        {
-            return static_cast<char *>(m_heap ? m_heap->base() : NULL);
-        }
-
-    // -------------------------------------------------------------------------
-        char * Allocator::heap_base() const
-        {
-            return static_cast<char *>(m_heap ? m_heap->base() : NULL);
-        }
-
-    // -------------------------------------------------------------------------
-        Allocator::Address Allocator::allocate(Size _sz) const
-        {
-            OSL_ENSURE(m_heap,"Cannot allocate: Invalid heap");
-            return m_heap ? m_heap->allocate(_sz) : Allocator::Address();
-        }
-
-    // -------------------------------------------------------------------------
-        void Allocator::deallocate(Address _addr) const
-        {
-            OSL_ENSURE(m_heap,"Cannot deallocate: Invalid heap");
-            if (m_heap) m_heap->deallocate(_addr);
-        }
-
-    // -------------------------------------------------------------------------
-
-    #if OSL_DEBUG_LEVEL > 0
-        void * UpdateAccessor::resolve(AddressType _p) const
-        {
-            OSL_ENSURE( !_p.is() || m_segment->isValidAddress(_p.value()), "Address does not belong to this segment");
-            return _p.is() ? heap_base() + _p.value() : NULL;
-        }
-
-        Pointer  UpdateAccessor::reduce(void const * _p) const
-        {
-            if (_p)
-            {
-                Pointer::RawAddress addr = static_cast<char const *>(_p) - heap_base();
-                OSL_ENSURE( m_segment->isValidAddress(addr), "Pointer does not belong to this segment");
-                return Pointer(addr);
-            }
-            else
-                return Pointer();
-        }
-
-        void * Allocator::access(Address _addr) const
-        {
-            OSL_ENSURE( !_addr || m_heap->isValidAddress(_addr), "Address does not belong to this segment");
-            return _addr ? heap_base() + _addr : NULL;
-        }
-
-
-        Allocator::Address  Allocator::address(void const * _p) const
-        {
-            if (_p)
-            {
-                Address addr = static_cast<char const *>(_p) - heap_base();
-                OSL_ENSURE( m_heap->isValidAddress(addr), "Pointer does not belong to this segment");
-                return addr;
-            }
-            else
-                return 0;
-        }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
Index: configmgr/source/inc/accessor.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/accessor.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 accessor.hxx
--- configmgr/source/inc/accessor.hxx	8 Sep 2005 03:41:00 -0000	1.5
+++ configmgr/source/inc/accessor.hxx	21 Dec 2006 11:21:20 -0000
@@ -36,8 +36,8 @@
 #ifndef CONFIGMGR_ACCESSOR_HXX
 #define CONFIGMGR_ACCESSOR_HXX
 
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
 #endif
 
 #ifndef _OSL_INTERLOCK_H_
@@ -57,14 +57,11 @@ namespace configmgr
             struct Impl
             {
                 Impl(Segment const * segment);
-                Impl(Segment const * segment, void const * base);
-
                 ~Impl();
 
                 bool is() const { return m_segment != NULL; }
 
                 Segment const * m_segment;
-                char    const * m_base;
                 oslInterlockedCount m_refs;
             private:
                 // disallow copying
@@ -78,9 +75,6 @@ namespace configmgr
 
             Impl * m_impl;
         public:
-            /// type of addresses used in the Segment
-            typedef Pointer AddressType;
-
             /// constructs an accessor on the given Segment
             explicit Accessor(Segment const * _pSegment) : m_impl(new Impl(_pSegment)) {}
 
@@ -90,45 +84,12 @@ namespace configmgr
 
             ~Accessor() { releaseImpl(); }
             
-            void swap(Accessor & _rOther);
-
             bool is() const { return m_impl->is(); }
             void clear();
-
-            AddressType address(void const * _p) const
-            { return (this->is()) ? reduce(_p) : Pointer();}
-
-            void const * access(AddressType _p) const
-            { return (this->is()) ? resolve(_p) : failNull();}
-
-            void const * validate(AddressType _p) const
-            { return (this->is() && _p.is()) ? resolve(_p) : failNull(); }
-
         private:
-            char    const * base_()    const { return m_impl->m_base; }
-            Segment const * segment_() const { return m_impl->m_segment; }
-
-            void const * resolve(AddressType _p) const;
-            AddressType  reduce(void const * _p) const;
-
             friend class UpdateAccessor;
-            Accessor(Segment * _s, void const * _b, __sal_NoAcquire) : m_impl(new Impl(_s,_b)) {}
-            static void * failNull();
+            Accessor(Segment * _s, __sal_NoAcquire) : m_impl(new Impl(_s)) {}
         };
-
-    // -------------------------------------------------------------------------
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline 
-        void const * Accessor::resolve(AddressType _p) const 
-        { return _p.is() ? this->base_() + _p.value() : NULL; }
-
-        inline 
-        Pointer  Accessor::reduce(void const * _p) const 
-        { return _p ? Pointer(static_cast<char const *>(_p) - this->base_()) : Pointer(); }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
Index: configmgr/source/inc/anydata.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/anydata.hxx,v
retrieving revision 1.2
diff -u -p -u -r1.2 anydata.hxx
--- configmgr/source/inc/anydata.hxx	8 Sep 2005 03:41:13 -0000	1.2
+++ configmgr/source/inc/anydata.hxx	21 Dec 2006 11:21:20 -0000
@@ -51,14 +51,10 @@ namespace configmgr
 {
 //-----------------------------------------------------------------------------
 
-    namespace memory { class Allocator; class Accessor; }
-    //-----------------------------------------------------------------------------
-
     namespace sharable
     {
     //-----------------------------------------------------------------------------
 
-        //typedef Address AnyData; // data that fits is stored inline
         union AnyData
         {
             typedef Byte TypeCode;
@@ -69,7 +65,6 @@ namespace configmgr
             sal_Int32   intValue;
             Address     longValue;      // points to sal_Int64
             Address     doubleValue;    // points to double (IEEE 8-bit) ...
-       //     float       floatValue;     // ... or should we use float (IEEE 4-bit) ?  
             Vector      binaryValue;    // points to counted sal_(u)Int8 []
             String      stringValue;    // points to counted sal_Unicode []
             Vector      sequenceValue;  // points to counted AnyData [] (or SomeType [] ?)
@@ -80,9 +75,8 @@ namespace configmgr
         AnyData::TypeCode getTypeCode(::com::sun::star::uno::Type const & _aType);
         ::com::sun::star::uno::Type getUnoType( AnyData::TypeCode _aType);
 
-        AnyData allocData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, ::com::sun::star::uno::Any const & _aAny);
-    //    AnyData copyData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, AnyData _aData);
-        void    freeData(memory::Allocator const& _anAllocator, AnyData::TypeCode _aType, AnyData _aData);
+        AnyData allocData(AnyData::TypeCode _aType, ::com::sun::star::uno::Any const & _aAny);
+        void    freeData(AnyData::TypeCode _aType, AnyData _aData);
         ::com::sun::star::uno::Any readData(memory::Accessor const& _anAccessor, AnyData::TypeCode _aType, AnyData _aData);
 
     //-----------------------------------------------------------------------------
Index: configmgr/source/inc/builddata.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/builddata.hxx,v
retrieving revision 1.2
diff -u -p -u -r1.2 builddata.hxx
--- configmgr/source/inc/builddata.hxx	8 Sep 2005 03:43:35 -0000	1.2
+++ configmgr/source/inc/builddata.hxx	21 Dec 2006 11:21:20 -0000
@@ -36,6 +36,9 @@
 #ifndef CONFIGMGR_BUILDDATA_HXX
 #define CONFIGMGR_BUILDDATA_HXX
 
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 #ifndef INCLUDED_MEMORY
 #define INCLUDED_MEMORY
 #include <memory>
@@ -52,10 +55,10 @@ namespace configmgr
 //-----------------------------------------------------------------------------
     namespace memory { class Accessor; class UpdateAccessor; }
 //-----------------------------------------------------------------------------
+    namespace sharable { struct TreeFragment; }
     namespace data
     {
 //-----------------------------------------------------------------------------
-        class TreeAddress;
         class TreeAccessor;
 //-----------------------------------------------------------------------------
         TreeAddress buildTree(memory::UpdateAccessor& _aTargetMemory, TreeAccessor const& _aTree);
Index: configmgr/source/inc/cacheddataprovider.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/cacheddataprovider.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 cacheddataprovider.hxx
--- configmgr/source/inc/cacheddataprovider.hxx	8 Sep 2005 03:43:49 -0000	1.5
+++ configmgr/source/inc/cacheddataprovider.hxx	21 Dec 2006 11:21:20 -0000
@@ -51,7 +51,9 @@
 #ifndef CONFIGMGR_UTILITY_HXX_
 #include "utility.hxx"
 #endif
-
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 #ifndef _SALHELPER_SIMPLEREFERENCEOBJECT_HXX_
 #include <salhelper/simplereferenceobject.hxx>
 #endif
@@ -65,13 +67,7 @@ namespace configmgr
     namespace backend
     {
 // ---------------------------------------------------------------------------
-    struct CacheLocation
-    {
-        memory::SegmentAddress          segment;
-        memory::SegmentHeap::Address    address;
-            
-        bool isNull() const { return segment.isNull() || address == 0; }
-    };
+    typedef data::TreeAddress CacheLocation;
 // ---------------------------------------------------------------------------
     struct IDirectDataProvider;
     struct ICachedDataNotifier;
Index: configmgr/source/inc/change.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/change.hxx,v
retrieving revision 1.25
diff -u -p -u -r1.25 change.hxx
--- configmgr/source/inc/change.hxx	25 Sep 2006 12:48:57 -0000	1.25
+++ configmgr/source/inc/change.hxx	21 Dec 2006 11:21:20 -0000
@@ -242,7 +242,7 @@ namespace configmgr
 		bool isReplacing() const { return m_bReplacing; }
 
 		/// has this been applied and inserted
-		bool wasInserted() const { return m_aInsertedTree.is(); }
+		bool wasInserted() const { return m_aInsertedTree != NULL; }
 
 		/** returns the node this change represents, even if this node does not own the new Node object any more. 
 			This is somewhat dangerous if the node referenced by this object dies before the object itself does.<BR>
Index: configmgr/source/inc/datalock.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/datalock.hxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 datalock.hxx
--- configmgr/source/inc/datalock.hxx	8 Sep 2005 03:46:50 -0000	1.3
+++ configmgr/source/inc/datalock.hxx	21 Dec 2006 11:21:20 -0000
@@ -33,31 +33,3 @@
  *
  ************************************************************************/
 
-#ifndef CONFIGMGR_DATALOCK_HXX
-#define CONFIGMGR_DATALOCK_HXX
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-
-        /// class controlling access to a memory::Segment
-        struct DataLock
-        {
-	        virtual void acquireReadAccess() = 0;
-	        virtual void releaseReadAccess() = 0;
-
-	        virtual void acquireWriteAccess() = 0; 	        
-	        virtual void releaseWriteAccess() = 0;
-        protected:
-            virtual ~DataLock() {}
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-#endif // CONFIGMGR_DATALOCK_HXX
-
Index: configmgr/source/inc/groupnodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/groupnodeaccess.hxx,v
retrieving revision 1.5.74.1
diff -u -p -u -r1.5.74.1 groupnodeaccess.hxx
--- configmgr/source/inc/groupnodeaccess.hxx	3 Nov 2006 11:35:17 -0000	1.5.74.1
+++ configmgr/source/inc/groupnodeaccess.hxx	21 Dec 2006 11:21:20 -0000
@@ -107,7 +107,7 @@ namespace configmgr
 
             operator NodeAccessRef()    const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            DataType& data() const { return *(NodePointerType)m_pData; }
 
         private:
             static AddressType check(NodeAccessRef const&);
Index: configmgr/source/inc/heap.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/heap.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 heap.hxx
--- configmgr/source/inc/heap.hxx	28 Dec 2005 17:29:58 -0000	1.5
+++ configmgr/source/inc/heap.hxx	21 Dec 2006 11:21:20 -0000
@@ -46,50 +46,5 @@
 #include <rtl/string.hxx>
 #endif
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class Heap : Noncopyable
-        {
-            HeapManager       & m_impl;
-            HeapManager::Handle m_heap;
-            HeapManager::Size   m_size;
-        public:
-            typedef HeapManager::Lock        Lock;
-            typedef HeapManager::Size        Size;
-            typedef HeapManager::HeapId      HeapId;
-            typedef HeapManager::HeapIdParam HeapIdParam;
-            typedef HeapManager::Address     Address;
-
-            Heap(HeapManager& _impl);
-            Heap(HeapManager& _impl, Size _nInitialSize);
-            Heap(HeapManager& _impl, HeapIdParam _anId);
-            ~Heap();
-
-            Size    size() const { return m_size; }
-
-            Size    grow(Size _nReqSize); 
-
-            void *  base() const   { return m_impl.base(m_heap); }
-            HeapId  id()   const   { return m_impl.id(m_heap); }
-
-            Address allocate(Size _sNewSize)    { return m_impl.allocate(m_heap, _sNewSize); }
-            Address reallocate(Address _aOldAddress, Size _sNewSize)    
-            { return m_impl.reallocate(m_heap, _aOldAddress, _sNewSize); }
-            void    deallocate(Address _aAddress)    { m_impl.deallocate(m_heap, _aAddress); }
-            bool    didAllocate(Address _aAddress) const 
-            { return m_impl.didAllocate(m_heap, _aAddress); }
-
-            Lock *  createLock()                { return m_impl.createHeapLock(m_heap); }
-            void    destroyLock(Lock * _pLock)  { m_impl.destroyHeapLock(m_heap,_pLock); }
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
 #endif // CONFIGMGR_DATAHEAP_HXX
 
Index: configmgr/source/inc/heapfactory.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/heapfactory.hxx,v
retrieving revision 1.2
diff -u -p -u -r1.2 heapfactory.hxx
--- configmgr/source/inc/heapfactory.hxx	8 Sep 2005 03:48:33 -0000	1.2
+++ configmgr/source/inc/heapfactory.hxx	21 Dec 2006 11:21:20 -0000
@@ -36,21 +36,5 @@
 #ifndef CONFIGMGR_HEAPFACTORY_HXX
 #define CONFIGMGR_HEAPFACTORY_HXX
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-        class HeapManager;
-
-        HeapManager & localHeap();
-        HeapManager & cacheHeap();
-
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
 #endif // CONFIGMGR_HEAPFACTORY_HXX
 
Index: configmgr/source/inc/heapmanager.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/heapmanager.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 heapmanager.hxx
--- configmgr/source/inc/heapmanager.hxx	28 Dec 2005 17:30:19 -0000	1.5
+++ configmgr/source/inc/heapmanager.hxx	21 Dec 2006 11:21:20 -0000
@@ -50,45 +50,7 @@
 #include <rtl/string.hxx>
 #endif
 
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class HeapManager
-        {
-        public:
-            typedef struct Opaque_ * Handle;
-
-            typedef memory::HeapSize    Size;
-            typedef memory::Address     Address;
-            typedef rtl::OString        HeapId;
-            typedef rtl::OString const & HeapIdParam;
-
-        //    virtual HeapId newHeapId() = 0;
-            virtual Handle createHeap(/*HeapIdParam _anId, */Size _sInitialSize) = 0;
-            virtual Handle attachHeap(HeapIdParam _anId, Size & _rInitialSize) = 0;
-            virtual Size   growHeap(Handle _aHeap, Size _sNewSize) = 0;
-            virtual void   destroyHeap(Handle _aHeap) = 0;
-
-            virtual void *  base(Handle _aHeap) = 0;
-            virtual HeapId  id(Handle _aHeap) = 0;
-
-            virtual Address allocate(Handle _aHeap, Size _sNewSize) = 0;
-            virtual Address reallocate(Handle _aHeap, Address _aOldAddress, Size _sNewSize) = 0;
-            virtual void    deallocate(Handle _aHeap, Address _aAddress) = 0;
-            virtual bool    didAllocate(Handle _aHeap, Address _aAddress) = 0;
-
-            typedef DataLock Lock;
-
-            virtual Lock *  createHeapLock(Handle _aHeap) = 0;
-            virtual void    destroyHeapLock(Handle _aHeap, Lock * _pLock) = 0;
-        };
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
+#include <osl/mutex.hxx>
 
 #endif // CONFIGMGR_DATAHEAPMANAGER_HXX
 
Index: configmgr/source/inc/memorymodel.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/memorymodel.hxx,v
retrieving revision 1.2
diff -u -p -u -r1.2 memorymodel.hxx
--- configmgr/source/inc/memorymodel.hxx	28 Dec 2005 17:30:28 -0000	1.2
+++ configmgr/source/inc/memorymodel.hxx	21 Dec 2006 11:21:20 -0000
@@ -40,30 +40,13 @@
 #include <sal/types.h>
 #endif
 
-//-----------------------------------------------------------------------------
-// no full heap implementation available yet - storing pointer value in Address
-#define CFG_ADDRESS_HOLDS_POINTER
-//-----------------------------------------------------------------------------
-
 namespace configmgr
 {
-//-----------------------------------------------------------------------------
-
     namespace memory 
     {
-    //-----------------------------------------------------------------------------
-    // some base types that describe our memory model
-#ifndef CFG_ADDRESS_HOLDS_POINTER
-        typedef sal_uInt32 Address; // points to relative location in memory segment
-#else
-        typedef sal_uIntPtr Address; // points to absolute location in memory
-#endif
-        typedef sal_uInt32 HeapSize; // memory block size within private heap
+        typedef sal_uInt8 *Address;
         typedef sal_uInt8  Byte;  
-    //-----------------------------------------------------------------------------
     }
-//-----------------------------------------------------------------------------
 }
 
-
 #endif // CONFIGMGR_MEMORYMODEL_HXX 
Index: configmgr/source/inc/node.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/node.hxx,v
retrieving revision 1.4.74.1
diff -u -p -u -r1.4.74.1 node.hxx
--- configmgr/source/inc/node.hxx	3 Nov 2006 11:35:30 -0000	1.4.74.1
+++ configmgr/source/inc/node.hxx	21 Dec 2006 11:21:20 -0000
@@ -106,22 +106,20 @@ namespace configmgr
 
             bool isLocalizedValue() const;
 
-		    rtl::OUString getElementTemplateName  (memory::Accessor const & _anAccessor) const;		
-		    rtl::OUString getElementTemplateModule(memory::Accessor const & _anAccessor) const;
+		    rtl::OUString getElementTemplateName() const;		
+		    rtl::OUString getElementTemplateModule() const;
 
-            TreeFragment const  * getFirstElement(memory::Accessor const & _anAccessor) const;
-            TreeFragment const  * getNextElement(memory::Accessor const & _anAccessor, TreeFragment const * _pElement) const;
+            TreeFragment const  * getFirstElement() const;
+            TreeFragment const  * getNextElement(TreeFragment const * _pElement) const;
 
             // low-level helper for template data abstraction
             static
-            Address allocTemplateData(memory::Allocator const & _anAllocator,
-									  const rtl::OUString &rName,
+            Address allocTemplateData(const rtl::OUString &rName,
 									  const rtl::OUString &rModule);
             static 
-			Address copyTemplateData(memory::Allocator const & _anAllocator,
-									 Address _aTemplateData);
+			Address copyTemplateData(Address _aTemplateData);
             static
-            void releaseTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData);
+            void releaseTemplateData(Address _aTemplateData);
         };
     //-----------------------------------------------------------------------------
         struct ValueNode
Index: configmgr/source/inc/nodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/nodeaccess.hxx,v
retrieving revision 1.5.74.1
diff -u -p -u -r1.5.74.1 nodeaccess.hxx
--- configmgr/source/inc/nodeaccess.hxx	3 Nov 2006 11:35:43 -0000	1.5.74.1
+++ configmgr/source/inc/nodeaccess.hxx	21 Dec 2006 11:21:20 -0000
@@ -53,11 +53,13 @@
 namespace configmgr
 {
 // -----------------------------------------------------------------------------	
+    namespace memory { class UpdateAccessor; }
+	
     namespace data
     {
     // -------------------------------------------------------------------------
         using memory::Accessor;
-    // -------------------------------------------------------------------------
+	    
     // -------------------------------------------------------------------------	
         class NodeAccess
 	    {
@@ -74,15 +76,15 @@ namespace configmgr
 
             NodeAccess(Accessor const& _aAccessor, NodeAddressType const& _aNodeRef) 
             : m_aAccessor(_aAccessor)
-            , m_pData(_aNodeRef.m_pData) 
+            , m_pData((NodePointerType)_aNodeRef.m_pData) 
             {}
 
-            NodeAccess(Accessor const& _aAccessor, NodePointerType _pNode) 
+            NodeAccess(Accessor const& _aAccessor, DataType *_pNode) 
             : m_aAccessor(_aAccessor)
-            , m_pData(_aAccessor.address(_pNode)) 
+            , m_pData(_pNode) 
             {}
 
-            bool isValid() const { return m_pData.is(); }
+            bool isValid() const { return m_pData != NULL; }
             bool isLocalRoot() const { return data().isFragmentRoot(); }
 
             Name getName() const { return wrapName( data().getName() ); }
@@ -91,25 +93,26 @@ namespace configmgr
             bool isDefault()   const { return data().isDefault(); }
             bool isLocalized() const { return data().isLocalized(); }
 
-            NodeAddressType address() const { return NodeAddressType(m_pData); }
+            NodeAddressType address() const { return NodeAddressType((AddressType)m_pData); }
             Accessor const& accessor() const { return m_aAccessor; }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
-            NodePointerType getDataPtr() const { return static_cast<NodePointerType>(m_aAccessor.access(m_pData)); }
-
-            AddressType rawAddress() const { return m_pData; }
+            DataType& data() const { return *m_pData; }
+            DataType *getDataPtr() const { return m_pData; }
 
             static Name wrapName(rtl::OUString const& _aNameString)
             { return configuration::makeName( _aNameString, Name::NoValidate() ); }
 
             static NodeAddress::DataType* access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor& _rUpdateAccess);
-            static NodeAddress::DataType const* access(NodeAddressType const& _aNodeRef, Accessor const& _rReaderAccess)
-            { return static_cast<NodePointerType>(_rReaderAccess.access(_aNodeRef.m_pData)); }
+            static NodeAddress::DataType const* access(NodeAddressType const& _aNodeRef, Accessor const&)
+            { return (NodeAddress::DataType *)_aNodeRef.m_pData; }
+
+	    operator AddressType () { return (AddressType) m_pData; }
+	    operator const AddressType () const { return (AddressType) m_pData; }
         private:
             NodeAccess() : m_aAccessor(NULL), m_pData() {}
 
-            Accessor    m_aAccessor;
-		    AddressType m_pData;
+            Accessor        m_aAccessor;
+	    NodePointerType m_pData;
         };
     // -------------------------------------------------------------------------	
         class NodeAccessRef
@@ -125,7 +128,7 @@ namespace configmgr
 
             NodeAccessRef(NodeAccess const& _aNodeAccess) 
             : m_pAccessor(&_aNodeAccess.accessor())
-            , m_pData(_aNodeAccess.rawAddress()) 
+            , m_pData(_aNodeAccess) 
             {}
 
             NodeAccessRef(Accessor const * _pAccessor, NodeAddressType const& _aNodeRef) 
@@ -135,12 +138,12 @@ namespace configmgr
 
             NodeAccessRef(Accessor const * _pAccessor, NodePointerType _pNode) 
             : m_pAccessor(_pAccessor)
-            , m_pData(_pAccessor->address(_pNode)) 
+            , m_pData((AddressType) _pNode) 
             {}
 
             NodeAccess toNodeAccess () const { return NodeAccess(accessor(),address()); }
 
-            bool isValid() const { return m_pData.is(); }
+            bool isValid() const { return m_pData != NULL; }
             bool isLocalRoot() const { return data().isFragmentRoot(); }
 
             Name getName() const { return NodeAccess::wrapName( data().getName() ); }
@@ -152,14 +155,13 @@ namespace configmgr
             NodeAddressType address() const { return NodeAddressType(m_pData); }
             Accessor const& accessor() const { return *m_pAccessor; }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_pAccessor->validate(m_pData)); }
-            NodePointerType getDataPtr() const { return static_cast<NodePointerType>(m_pAccessor->access(m_pData)); }
-
-            AddressType rawAddress() const { return m_pData; }
+            DataType& data() const { return *(DataType *)m_pData; }
+            DataType* getDataPtr() { return (DataType *)m_pData; }
+            DataType* getDataPtr() const { return (DataType *)m_pData; }
 
         private:
             Accessor const *   m_pAccessor;
-		    AddressType m_pData;
+	    AddressType m_pData;
         };
     // -------------------------------------------------------------------------
     // helper - finds child or element
Index: configmgr/source/inc/nodeaddress.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/nodeaddress.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 nodeaddress.hxx
--- configmgr/source/inc/nodeaddress.hxx	19 Jan 2006 17:53:30 -0000	1.5
+++ configmgr/source/inc/nodeaddress.hxx	21 Dec 2006 11:21:20 -0000
@@ -36,8 +36,8 @@
 #ifndef CONFIGMGR_NODEADDRESS_HXX
 #define CONFIGMGR_NODEADDRESS_HXX
 
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
 #endif
 
 #ifndef INCLUDED_SHARABLE_NODE_HXX
@@ -60,7 +60,7 @@ namespace configmgr
             friend class NodeAccessRef;
         public:
             typedef sharable::Node      DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
         public:
             NodeAddress() : m_pData() {}
@@ -68,17 +68,18 @@ namespace configmgr
             explicit
             NodeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+	    bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
-            AddressType::RawAddress addressValue() const { return m_pData.value(); }
+            AddressType addressValue() const { return m_pData; }
 
             friend bool operator == (NodeAddress const& lhs, NodeAddress const& rhs);
 
             friend bool operator != (NodeAddress const& lhs, NodeAddress const& rhs);
 
+	    operator AddressType () { return m_pData; }
         private:
-		    AddressType                 m_pData;
+	    AddressType                 m_pData;
         };
 
         inline bool operator == (NodeAddress const& lhs, NodeAddress const& rhs)
@@ -93,17 +94,17 @@ namespace configmgr
             friend class ValueNodeAccess;
         public:
             typedef sharable::ValueNode DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+            bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
             operator NodeAddress() const { return NodeAddress(m_pData); }
         private:
             explicit
             ValueNodeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
 
-		    AddressType m_pData;
+	    AddressType m_pData;
         };
     // -------------------------------------------------------------------------
 
@@ -112,10 +113,10 @@ namespace configmgr
             friend class GroupNodeAccess;
         public:
             typedef sharable::GroupNode DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+	    bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
             operator NodeAddress()        const { return NodeAddress(m_pData); }
         private:
@@ -131,10 +132,10 @@ namespace configmgr
             friend class SetNodeAccess;
         public:
             typedef sharable::SetNode   DataType;
-            typedef memory::Pointer     AddressType;
+            typedef memory::Address     AddressType;
 
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
+	    bool is()       const { return !isNull(); }
+            bool isNull()   const { return m_pData == NULL; }
 
             operator NodeAddress()        const { return NodeAddress(m_pData); }
         private:
Index: configmgr/source/inc/pointer.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/pointer.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 pointer.hxx
--- configmgr/source/inc/pointer.hxx	28 Dec 2005 17:30:54 -0000	1.5
+++ configmgr/source/inc/pointer.hxx	21 Dec 2006 11:21:20 -0000
@@ -32,59 +32,3 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-
-#ifndef CONFIGMGR_POINTER_HXX
-#define CONFIGMGR_POINTER_HXX
-
-#ifndef CONFIGMGR_MEMORYMODEL_HXX
-#include "memorymodel.hxx"
-#endif
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------
-        class Accessor;
-        class UpdateAccessor;
-    // -------------------------------------------------------------------------	
-        /// class mediating read-only access to a memory::Segment
-        class Pointer 
-        {
-            friend class Accessor;
-            friend class UpdateAccessor;
-
-            typedef memory::Address AddressType;
-
-            AddressType m_value;
-
-            struct Opaque_;
-        public:
-            typedef AddressType RawAddress;
-
-            Pointer() : m_value(0) {}
-            explicit Pointer(AddressType p) : m_value(p) {}
-
-            RawAddress value() const { return m_value; }
-
-            bool isNull()   const { return m_value == 0; }
-            bool is()       const { return m_value != 0; }
-
-            operator Opaque_ const * () const { return reinterpret_cast<Opaque_ const *>(m_value); }
-
-            friend bool operator == (Pointer lhs, Pointer rhs)
-            { return lhs.value() == rhs.value(); }
-
-            friend bool operator != (Pointer lhs, Pointer rhs)
-            { return lhs.value() != rhs.value(); }
-        };
-
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-// -----------------------------------------------------------------------------
-
-#endif // CONFIGMGR_POINTER_HXX
-
Index: configmgr/source/inc/segment.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/segment.hxx,v
retrieving revision 1.4
diff -u -p -u -r1.4 segment.hxx
--- configmgr/source/inc/segment.hxx	8 Sep 2005 03:55:04 -0000	1.4
+++ configmgr/source/inc/segment.hxx	21 Dec 2006 11:21:20 -0000
@@ -39,13 +39,15 @@
 #ifndef CONFIGMGR_DATALOCK_HXX
 #include "datalock.hxx"
 #endif
-#ifndef CONFIGMGR_SEGMENTHEAP_HXX
-#include "segmentheap.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
 #endif
 #ifndef _RTL_STRING_HXX_
 #include <rtl/string.hxx>
 #endif
 
+#include <osl/mutex.hxx>
+
 namespace configmgr
 {
 // -----------------------------------------------------------------------------	
@@ -54,65 +56,20 @@ namespace configmgr
     // -------------------------------------------------------------------------	
         class Segment
         {
-            SegmentHeap m_heap;
-        public:
-            typedef SegmentHeap     Heap;
-            typedef Heap::Lock      Lock;
-            typedef rtl::OString    Id;
-
+            osl::Mutex m_mutex;
         public:
-            explicit Segment(HeapManager & _aHeapImpl) 
-            : m_heap(_aHeapImpl) {}
-
-            explicit Segment(HeapManager & _aHeapImpl, Heap::Size _aInitialSize) 
-            : m_heap(_aHeapImpl,_aInitialSize) {}
+            explicit Segment() 
+            : m_mutex() {}
 
-            explicit Segment(HeapManager & _aHeapImpl, Id const & _anId) 
-            : m_heap(_aHeapImpl,_anId) {}
+			void acquireWriteAccess() { m_mutex.acquire(); }
+			void releaseWriteAccess() { m_mutex.release(); }
+			void downgradeAccess()    {}
 
-            Id getId() const { return m_heap.id(); }
-
-            bool isValidAddress(Heap::Address _aAddress) const
-            {
-                return m_heap.isValidAddress(_aAddress); 
-            }
-
-            Heap& acquireWriteAccess()       
-            { 
-                this->lock().acquireWriteAccess(); 
-                return this->heap(); 
-            }
-
-            void  releaseWriteAccess(Heap&)  
-            { 
-                this->lock().releaseWriteAccess(); 
-            }
-
-            void const * acquireReadAccess() const 
-            { 
-                this->lock().acquireReadAccess();
-                return base();
-            }
-            void releaseReadAccess (void const * ) const 
-            { 
-                this->lock().releaseReadAccess(); 
-            }
-        private:
-            Heap & heap()       { return m_heap; }
-            Lock & lock() const { return m_heap.lock(); }
-            void * base() const { return m_heap.base(); }
+			void acquireReadAccess() const { ((Segment *)this)->m_mutex.acquire(); }
+			void releaseReadAccess() const { ((Segment *)this)->m_mutex.release(); }
         };
-    // -------------------------------------------------------------------------
-        typedef Segment::Id SegmentID;
-    // -------------------------------------------------------------------------
-        struct SegmentAddress
-        {
-            SegmentID               id;
-            SegmentHeap::Address    base;
 
-            bool isNull() const { return base == 0; }
-        };
-    // -------------------------------------------------------------------------	
+		typedef memory::Address SegmentAddress;
     }
 // -----------------------------------------------------------------------------	
 } // namespace configmgr
Index: configmgr/source/inc/segmentheap.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/segmentheap.hxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 segmentheap.hxx
--- configmgr/source/inc/segmentheap.hxx	8 Sep 2005 03:55:20 -0000	1.3
+++ configmgr/source/inc/segmentheap.hxx	21 Dec 2006 11:21:20 -0000
@@ -32,82 +32,3 @@
  *    MA  02111-1307  USA
  *
  ************************************************************************/
-
-#ifndef CONFIGMGR_SEGMENTHEAP_HXX
-#define CONFIGMGR_SEGMENTHEAP_HXX
-
-#ifndef CONFIGMGR_DATAHEAP_HXX
-#include "heap.hxx"
-#endif
-#ifndef CONFIGMGR_UTILITY_HXX_
-#include "utility.hxx"
-#endif
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    namespace memory
-    {
-    // -------------------------------------------------------------------------	
-        class SegmentHeap : Noncopyable
-        {
-            friend class Segment;
-            typedef Heap::Lock Lock;
-
-            Heap   m_heap;
-            void * m_base;
-            Lock * m_lock;
-
-            Lock & lock() const { return *m_lock; }
-        public:
-            typedef Heap::HeapId        HeapId;
-            typedef Heap::HeapIdParam   HeapIdParam;
-            typedef Heap::Size          Size;
-            typedef Heap::Address       Address;
-            
-            SegmentHeap(HeapManager & _rImpl)
-            : m_heap(_rImpl)
-            { init(); }
-
-            SegmentHeap(HeapManager & _rImpl, Size _aInitialSize)
-            : m_heap(_rImpl,_aInitialSize)
-            { init(); }
-
-            SegmentHeap(HeapManager & _rImpl, HeapIdParam _anId)
-            : m_heap(_rImpl,_anId)
-            { init(); }
-
-            ~SegmentHeap();
-
-            // PRE: lock must be acquired
-            void*   base() const { return m_base; }
-            HeapId  id() const { return m_heap.id(); }
-
-            Address allocate(Size _sz) 
-            {
-                Address aResult = m_heap.allocate(_sz);
-                if (!aResult)
-                    aResult = this->allocateMore(_sz);
-                return aResult;
-            }
-
-            void deallocate(Address _addr) 
-            { 
-                m_heap.deallocate(_addr); 
-            }
-
-            bool isValidAddress(Address _addr) const
-            { 
-                return m_heap.didAllocate(_addr); 
-            }
-        private:
-            void init();
-            Address allocateMore(Size _sz);
-        };
-    // -------------------------------------------------------------------------	
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
-#endif // CONFIGMGR_SEGMENT_HXX
-
Index: configmgr/source/inc/sequence.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/sequence.hxx,v
retrieving revision 1.2
diff -u -p -u -r1.2 sequence.hxx
--- configmgr/source/inc/sequence.hxx	8 Sep 2005 03:55:37 -0000	1.2
+++ configmgr/source/inc/sequence.hxx	21 Dec 2006 11:21:20 -0000
@@ -56,19 +56,17 @@ namespace configmgr
         typedef Vector Sequence; // alternative name
     //-----------------------------------------------------------------------------
        
-        Sequence allocSequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, ::sal_Sequence const * _pSeqData);
-    //    Sequence copySequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, Sequence _aSeq);
-        void     freeSequence(memory::Allocator const& _anAllocator, AnyData::TypeCode _aElementType, Sequence _aSeq);
+        Sequence allocSequence(AnyData::TypeCode _aElementType, ::sal_Sequence const * _pSeqData);
+        void     freeSequence(AnyData::TypeCode _aElementType, Sequence _aSeq);
 
         ::sal_Sequence * readSequence(memory::Accessor const& _anAccessor, AnyData::TypeCode _aElementType, Sequence _aSeq);
         ::com::sun::star::uno::Any readAnySequence(memory::Accessor const& _anAccessor, AnyData::TypeCode _aElementType, Sequence _aSeq);
     //-----------------------------------------------------------------------------
 
-        Sequence allocBinary(memory::Allocator const& _anAllocator, ::com::sun::star::uno::Sequence<sal_Int8> const & _aBinaryValue);
-    //    Sequence copyBinary(memory::Allocator const& _anAllocator, Sequence _aSeq);
-        void freeBinary(memory::Allocator const& _anAllocator, Sequence _aSeq);
+        Sequence allocBinary(::com::sun::star::uno::Sequence<sal_Int8> const & _aBinaryValue);
+        void freeBinary(Sequence _aSeq);
 
-        ::com::sun::star::uno::Sequence<sal_Int8> readBinary(memory::Accessor const& _anAccessor, Sequence _aSeq);
+        ::com::sun::star::uno::Sequence<sal_Int8> readBinary(Sequence _aSeq);
     //-----------------------------------------------------------------------------
 
         template <class ET>
@@ -80,11 +78,11 @@ namespace configmgr
         }
 
         template <class ET>
-        Sequence allocSequence(memory::Allocator const& _anAllocator, ::com::sun::star::uno::Sequence<ET> const & _aSeq)
+        Sequence allocSequence(::com::sun::star::uno::Sequence<ET> const & _aSeq)
         {
             AnyData::TypeCode aTC = getElementTypeCode(_aSeq);
             ::sal_Sequence const * pSeqData = _aSeq.get();
-            return allocSequence(_anAllocator, aTC, pSeqData);
+            return allocSequence(aTC, pSeqData);
         }
 
         template <class ET>
Index: configmgr/source/inc/setnodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/setnodeaccess.hxx,v
retrieving revision 1.4.74.1
diff -u -p -u -r1.4.74.1 setnodeaccess.hxx
--- configmgr/source/inc/setnodeaccess.hxx	3 Nov 2006 11:35:56 -0000	1.4.74.1
+++ configmgr/source/inc/setnodeaccess.hxx	21 Dec 2006 11:21:20 -0000
@@ -39,6 +39,9 @@
 #ifndef CONFIGMGR_NODEACCESS_HXX
 #include "nodeaccess.hxx"
 #endif
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 
 namespace configmgr
 {
@@ -46,7 +49,6 @@ namespace configmgr
     namespace data
     {
     // -------------------------------------------------------------------------
-        class TreeAddress;
         class TreeAccessor;
     // -------------------------------------------------------------------------
         /** class that mediates access to the data of a Set node
@@ -113,7 +115,7 @@ namespace configmgr
 
             operator NodeAccessRef() const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            DataType& data() const { return *(NodePointerType)m_pData; }
 
             static void addElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, ElementAddress _aNewElement);
             static ElementAddress removeElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, Name const & _aName);
@@ -136,11 +138,11 @@ namespace configmgr
         
         inline 
 		NodeAccess::Name SetNodeAccess::getElementTemplateName()   const 
-        { return NodeAccess::wrapName( data().getElementTemplateName(m_aAccessor) ); }	
+        { return NodeAccess::wrapName( data().getElementTemplateName() ); }	
         
         inline 
 		NodeAccess::Name SetNodeAccess::getElementTemplateModule() const 
-        { return NodeAccess::wrapName( data().getElementTemplateModule(m_aAccessor) ); }	
+        { return NodeAccess::wrapName( data().getElementTemplateModule() ); }	
         
         inline           
         NodeAccess::Attributes SetNodeAccess::getAttributes() const 
Index: configmgr/source/inc/treeaccessor.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treeaccessor.hxx,v
retrieving revision 1.5.74.1
diff -u -p -u -r1.5.74.1 treeaccessor.hxx
--- configmgr/source/inc/treeaccessor.hxx	3 Nov 2006 11:36:16 -0000	1.5.74.1
+++ configmgr/source/inc/treeaccessor.hxx	21 Dec 2006 11:21:20 -0000
@@ -73,36 +73,31 @@ namespace configmgr
         public:
             typedef configuration::Name     Name;
             typedef node::Attributes        Attributes;
-            typedef TreeAddress                 DataAddressType;
-            typedef TreeAddress::DataType const DataType;
-            typedef DataType  * DataPointerType;
 
             static TreeAccessor emptyTree() { return TreeAccessor(); }
 
-            TreeAccessor(Accessor const& _aAccessor, DataAddressType const& _aTreeRef) 
+            TreeAccessor(Accessor const& _aAccessor, TreeAddress const& _aTreeRef)
             : m_aAccessor(_aAccessor)
-            , m_pBase(_aTreeRef.m_pData) 
+            , m_pBase(_aTreeRef) 
             {}
 
-            TreeAccessor(Accessor const& _aAccessor, DataPointerType _pTree) 
+            TreeAccessor(Accessor const& _aAccessor, const sharable::TreeFragment * _pTree) 
             : m_aAccessor(_aAccessor)
-            , m_pBase(_aAccessor.address(_pTree)) 
+            , m_pBase((sharable::TreeFragment *)_pTree)
             {}
 
-            bool isValid() const { return m_pBase.is(); }
-
-            bool isDefault() const { return data().isDefault(); }
+            bool isValid() const { return m_pBase != NULL; }
 
             Attributes getAttributes() const { return data().getAttributes(); }
             Name getName() const;
 
             NodeAccessRef getRootNode() const { return NodeAccessRef(&m_aAccessor,rootAddress(m_pBase)); }
 
-            DataAddressType address() const { return m_pBase; }
+            TreeAddress address() const { return m_pBase; }
             Accessor const& accessor() const { return m_aAccessor; }
 
-            DataType& data() const { return *static_cast<DataPointerType>(m_aAccessor.validate(m_pBase.m_pData)); }
-            DataPointerType getDataPtr() const { return access(m_pBase,m_aAccessor); }
+            sharable::TreeFragment& data() const { return *m_pBase; }
+            sharable::TreeFragment * getDataPtr() const { return m_pBase; }
 
             TreeAddress copyTree(memory::UpdateAccessor & _aTargetSpace) const;
             static void freeTree(memory::UpdateAccessor & _aTargetSpace, TreeAddress _aTree);
@@ -110,16 +105,16 @@ namespace configmgr
             static Name wrapName(rtl::OUString const& _aNameString)
             { return configuration::makeName( _aNameString, Name::NoValidate() ); }
 
-            static TreeAddress::DataType* access(DataAddressType const& _aTreeRef, memory::UpdateAccessor& _rUpdateAccess);
-            static TreeAddress::DataType const* access(DataAddressType const& _aTreeRef, Accessor const& _rReaderAccess)
-            { return static_cast<DataPointerType>(_rReaderAccess.access(_aTreeRef.m_pData)); }
+            static sharable::TreeFragment* access(TreeAddress const& _aTreeRef, memory::UpdateAccessor& _rUpdateAccess);
+            static sharable::TreeFragment const* access(TreeAddress const& _aTreeRef, Accessor const&)
+            { return (sharable::TreeFragment *)_aTreeRef; }
         private:
-            NodeAddress rootAddress(DataAddressType const& p) const;
+            NodeAddress rootAddress(TreeAddress const& p) const;
 
             TreeAccessor();
         private:
-            Accessor            m_aAccessor;
-		    DataAddressType     m_pBase;
+            Accessor     m_aAccessor;
+            TreeAddress  m_pBase;
         };
     // -------------------------------------------------------------------------
     // -------------------------------------------------------------------------
@@ -130,13 +125,12 @@ namespace configmgr
         }
     // -------------------------------------------------------------------------
         inline
-        NodeAddress TreeAccessor::rootAddress(DataAddressType const& p) const 
+        NodeAddress TreeAccessor::rootAddress(TreeAddress const& p) const 
         { 
-            sharable::Address aAddr = p.addressValue();
-
-            if (aAddr) aAddr += offsetof(TreeAddress::DataType,nodes);
-
-            return NodeAddress( memory::Pointer(aAddr) ); 
+            if (p == NULL)
+                return NodeAddress();
+            sharable::TreeFragment const *pFrag = p;
+            return NodeAddress( (memory::Address) pFrag->nodes ); 
         }
     // -------------------------------------------------------------------------
     }
Index: configmgr/source/inc/treeaddress.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treeaddress.hxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 treeaddress.hxx
--- configmgr/source/inc/treeaddress.hxx	8 Sep 2005 03:58:45 -0000	1.3
+++ configmgr/source/inc/treeaddress.hxx	21 Dec 2006 11:21:20 -0000
@@ -36,53 +36,15 @@
 #ifndef CONFIGMGR_TREEADDRESS_HXX
 #define CONFIGMGR_TREEADDRESS_HXX
 
-#ifndef CONFIGMGR_POINTER_HXX
-#include "pointer.hxx"
+#ifndef CONFIGMGR_MEMORYMODEL_HXX
+#include <memorymodel.hxx>
+#endif
+#ifndef CONFIGMGR_SEGMENT_HXX
+#include "segment.hxx"
 #endif
-
 #ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
 #include "treefragment.hxx"
 #endif
 
-
-namespace configmgr
-{
-// -----------------------------------------------------------------------------	
-    class INode;
-// -----------------------------------------------------------------------------	
-    namespace data
-    {
-    // -------------------------------------------------------------------------	
-        class TreeAddress
-	    {
-            friend class TreeAccessor;
-        public:
-            typedef sharable::TreeFragment  DataType;
-            typedef memory::Pointer         AddressType;
-        public:
-            TreeAddress() : m_pData() {}
-
-            explicit
-            TreeAddress(AddressType _aNodeData) : m_pData(_aNodeData) {}
-
-            bool is()       const { return m_pData.is(); }
-            bool isNull()   const { return m_pData.isNull(); }
-
-            AddressType::RawAddress addressValue() const { return m_pData.value(); }
-
-            friend bool operator == (TreeAddress const& lhs, TreeAddress const& rhs)
-            { return lhs.m_pData == rhs.m_pData; }
-
-            friend bool operator != (TreeAddress const& lhs, TreeAddress const& rhs)
-            { return lhs.m_pData != rhs.m_pData; }
-
-        private:
-		    AddressType m_pData;
-        };
-    // -------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
-} // namespace configmgr
-
 #endif // CONFIGMGR_TREEADDRESS_HXX
 
Index: configmgr/source/inc/treefragment.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treefragment.hxx,v
retrieving revision 1.4.74.1
diff -u -p -u -r1.4.74.1 treefragment.hxx
--- configmgr/source/inc/treefragment.hxx	3 Nov 2006 11:36:29 -0000	1.4.74.1
+++ configmgr/source/inc/treefragment.hxx	21 Dec 2006 11:21:21 -0000
@@ -79,16 +79,16 @@ namespace configmgr
     */
         struct TreeFragmentHeader
         {
-            List            next;       // next sibling set element or template
-            String          name;       // element-name/template name
+            struct TreeFragment *next;       // next sibling set element or template
+            String               name;       // element-name/template name
             union // context
             {
-                Address     parent;     // parent node
-                String      component;  // component name 
+                Address          parent;     // parent node
+                String           component;  // component name 
             };
-            Offset          count;      // number of contained nodes
-            State::Field    state;      
-            Byte            reserved;
+            Offset               count;      // number of contained nodes
+            State::Field         state;      
+            Byte                 reserved;
        };
     //-----------------------------------------------------------------------------
     /* a tree fragment is stored as a variable-sized struct
@@ -138,9 +138,16 @@ namespace configmgr
 
             rtl::OUString               getName() const;
             configmgr::node::Attributes getAttributes()const;
+
+	    static TreeFragment *allocate(sal_uInt32 nFragments);
+	    static void free_shallow( TreeFragment *pFragment );
         };
     //-----------------------------------------------------------------------------
+
     }
+  namespace data {
+    typedef sharable::TreeFragment * TreeAddress;
+  }
 //-----------------------------------------------------------------------------
 }
 
Index: configmgr/source/inc/treemanager.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treemanager.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 treemanager.hxx
--- configmgr/source/inc/treemanager.hxx	8 Sep 2005 03:59:42 -0000	1.5
+++ configmgr/source/inc/treemanager.hxx	21 Dec 2006 11:21:21 -0000
@@ -104,12 +104,10 @@ namespace configmgr
 		/** ctor
 		*/
         explicit
-        TreeManager(BackendCacheRef const & _xBackend, memory::HeapManager & _rCacheHeapManager);
+        TreeManager(BackendCacheRef const & _xBackend);
 
 		// disposing the cache before destroying		
 		void dispose();
-		
-        memory::HeapManager & getCacheHeapManager() const;
 
 		// ITreeManager
         virtual memory::Segment* getDataSegment(AbsolutePath const& _rAccessor, 
Index: configmgr/source/inc/treesegment.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/treesegment.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 treesegment.hxx
--- configmgr/source/inc/treesegment.hxx	8 Sep 2005 04:00:27 -0000	1.5
+++ configmgr/source/inc/treesegment.hxx	21 Dec 2006 11:21:21 -0000
@@ -43,12 +43,15 @@
 #ifndef _RTL_REF_HXX_
 #include <rtl/ref.hxx>
 #endif
-
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 #ifndef INCLUDED_MEMORY
 #include <memory>
 #define INCLUDED_MEMORY
 #endif // INCLUDED_MEMORY
 
+
 // -----------------------------------------------------------------------------
 namespace rtl { class OUString; }
 // -----------------------------------------------------------------------------
@@ -70,7 +73,6 @@ namespace configmgr
     namespace data
     {
     // -------------------------------------------------------------------------	
-        class TreeAddress;
         class TreeAccessor;
     // -------------------------------------------------------------------------	
         class TreeSegment
Index: configmgr/source/inc/types.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/types.hxx,v
retrieving revision 1.3.58.1
diff -u -p -u -r1.3.58.1 types.hxx
--- configmgr/source/inc/types.hxx	3 Nov 2006 11:36:43 -0000	1.3.58.1
+++ configmgr/source/inc/types.hxx	21 Dec 2006 11:21:21 -0000
@@ -53,19 +53,19 @@ namespace rtl { class OUString; }
 
 namespace configmgr
 {
+    namespace memory { class Accessor; };
     namespace sharable
     {
     //-----------------------------------------------------------------------------
     // some base types
         typedef memory::Address  Address;  // points to absolute location in memory segment
-        typedef memory::HeapSize HeapSize; // size of memory block within heap
         typedef sal_uInt16 Offset;  // Offset relative to 'this' in array of nodes
         typedef sal_uInt8  Byte;  
 
     // some derived types 
         typedef rtl_uString *  Name;
         typedef rtl_uString *  String;
-        typedef Address List;    // singly linked intrusive, used for set elements
+        typedef struct TreeFragment * List;    // singly linked intrusive, used for set elements
         typedef Address Vector;   // points to counted sequence of some type
 
     //-----------------------------------------------------------------------------
Index: configmgr/source/inc/updateaccessor.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/updateaccessor.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 updateaccessor.hxx
--- configmgr/source/inc/updateaccessor.hxx	28 Dec 2005 17:31:29 -0000	1.5
+++ configmgr/source/inc/updateaccessor.hxx	21 Dec 2006 11:21:21 -0000
@@ -54,35 +54,13 @@ namespace configmgr
     // -------------------------------------------------------------------------
         class Segment;
         class SegmentHeap;
-    // -------------------------------------------------------------------------
-
-        class Allocator
-        {
-            SegmentHeap *   m_heap;
-
-        public:
-            typedef memory::Address Address;
-            typedef memory::HeapSize Size;
 
-            Address allocate(Size _sz) const;
-            void deallocate(Address _addr) const;
-
-            void *      access(Address _addr) const;
-            Address     address(void const * _p) const;
-
-        private:
-            friend class UpdateAccessor;
-
-            Allocator(SegmentHeap * _heap) : m_heap(_heap) {}
-            char * heap_base() const;
-        };
     // -------------------------------------------------------------------------
         class UpdateAccessor : Noncopyable
         {
             Segment *       m_segment;
-            SegmentHeap *   m_heap;
         public:
-            typedef Accessor::AddressType AddressType;
+            typedef memory::Address AddressType;
 
             /// constructs an accessor on the given Segment
             explicit UpdateAccessor(Segment * segment);
@@ -95,46 +73,7 @@ namespace configmgr
             Accessor accessor() const;
             Accessor downgrade(); // return accessor and clear
             void clear();
-
-            AddressType address(void const * _p) const
-            { return (this->is()) ? reduce(_p) : Pointer();}
-
-            void * access(AddressType _p) const
-            { return (this->is()) ? resolve(_p) : Accessor::failNull();}
-
-            void * validate(AddressType _p) const
-            { return (this->is() && _p.is()) ? resolve(_p) : Accessor::failNull(); }
-
-        // allocation support
-            Allocator allocator() const { return Allocator(m_heap); }
-        private:
-            char * heap_base() const;
-            void * resolve(AddressType _p) const;
-            AddressType  reduce(void const * _p) const;
         };
-    // -------------------------------------------------------------------------
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline
-        void * UpdateAccessor::resolve(AddressType _p) const
-        { return _p.is() ? heap_base() + _p.value() : NULL; }
-
-        inline
-        Pointer  UpdateAccessor::reduce(void const * _p) const
-        { return _p ? Pointer(static_cast<char const *>(_p) - heap_base()) : Pointer(); }
-  #endif // OSL_DEBUG_LEVEL
-
-  #if OSL_DEBUG_LEVEL == 0
-        inline
-        void * Allocator::access(Address _addr) const
-        { return _addr ? heap_base() + _addr : NULL; }
-
-        inline
-        Allocator::Address  Allocator::address(void const * _p) const
-        { return _p ? (static_cast<char const *>(_p) - heap_base()) : 0; }
-  #endif // OSL_DEBUG_LEVEL
-
-    // -------------------------------------------------------------------------
     }
 // -----------------------------------------------------------------------------
 } // namespace configmgr
Index: configmgr/source/inc/valuenodeaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/inc/valuenodeaccess.hxx,v
retrieving revision 1.4.74.1
diff -u -p -u -r1.4.74.1 valuenodeaccess.hxx
--- configmgr/source/inc/valuenodeaccess.hxx	3 Nov 2006 11:36:56 -0000	1.4.74.1
+++ configmgr/source/inc/valuenodeaccess.hxx	21 Dec 2006 11:21:21 -0000
@@ -110,15 +110,15 @@ namespace configmgr
             NodeAddressType address()   const { return NodeAddressType(m_pData); }
             Accessor const& accessor()  const { return m_aAccessor; }
 
-            DataType& data() const { return *static_cast<NodePointerType>(m_aAccessor.validate(m_pData)); }
+            DataType& data() const { return *(NodePointerType)m_pData; }
 
             operator NodeAccessRef() const { return NodeAccessRef(&m_aAccessor,NodeAddress(m_pData)); }
         private:
-            static AddressType check(Accessor const& _acc, NodePointerType _p) { return _acc.address(_p); }
+            static AddressType check(Accessor const&, NodePointerType _p) { return (AddressType)_p; }
             static AddressType check(NodeAccessRef const& _aNodeData);
 
             Accessor    m_aAccessor;
-		    AddressType m_pData;
+	    AddressType m_pData;
         };
 
         ValueNodeAddress toValueNodeAddress(memory::Accessor const & _aAccess, NodeAddress const & _aNodeAddr);
Index: configmgr/source/localbe/localfilehelper.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/localbe/localfilehelper.cxx,v
retrieving revision 1.4
diff -u -p -u -r1.4 localfilehelper.cxx
--- configmgr/source/localbe/localfilehelper.cxx	16 Sep 2006 15:11:34 -0000	1.4
+++ configmgr/source/localbe/localfilehelper.cxx	21 Dec 2006 11:21:21 -0000
@@ -164,6 +164,10 @@ namespace configmgr 
         if (_sURL.getLength() == 0)
             return false;
 
+		// This method has no right to be so under-performing to
+		// achieve so, so little of any usefulness.
+		return true;
+
         DirectoryItem aDirItem;
         
         DirectoryItem::RC rc = DirectoryItem::get(_sURL, aDirItem);
Index: configmgr/source/localbe/localmultistratum.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/localbe/localmultistratum.cxx,v
retrieving revision 1.8
diff -u -p -u -r1.8 localmultistratum.cxx
--- configmgr/source/localbe/localmultistratum.cxx	16 Sep 2006 15:12:17 -0000	1.8
+++ configmgr/source/localbe/localmultistratum.cxx	21 Dec 2006 11:21:21 -0000
@@ -110,7 +110,7 @@ uno::Sequence< rtl::OUString > SAL_CALL 
     rtl::OUString const aComponentUrl = aLayerUrl + componentToPath(aComponent);
     
     using namespace osl;
-    const sal_uInt32 k_STATUS_FIELDS =  FileStatusMask_Type | FileStatusMask_FileName; 
+    const sal_uInt32 k_STATUS_FIELDS = FileStatusMask_FileName; 
     Directory aComponentDirectory(aComponentUrl);
     DirectoryItem aItem;
     std::vector< rtl::OUString > aResult;
@@ -135,13 +135,12 @@ uno::Sequence< rtl::OUString > SAL_CALL 
                 OSL_TRACE("Reading Component Directory - Error (%u) getting status of directory item.\n", unsigned(errcode));
                 break;
             }
-
-            OSL_ENSURE( aItemDescriptor.isValid(FileStatusMask_Type), "Could not get type of directory item");
-            if (aItemDescriptor.getFileType() != FileStatus::Regular)
-                continue;
                     
             OSL_ENSURE( aItemDescriptor.isValid(FileStatusMask_FileName), "Could not get Name of component found");
             OUString const aFileName = aItemDescriptor.getFileName();
+
+			// It is reasonable to assume a .xcu file is not a directory & =>
+			// not stat each directory entry at considerable cost.
             if (!aFileName.endsWithIgnoreAsciiCaseAsciiL(RTL_CONSTASCII_STRINGPARAM(kLocalDataSuffix)))
                 continue;
 
Index: configmgr/source/misc/filehelper.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/misc/filehelper.cxx,v
retrieving revision 1.17
diff -u -p -u -r1.17 filehelper.cxx
--- configmgr/source/misc/filehelper.cxx	16 Sep 2006 15:15:25 -0000	1.17
+++ configmgr/source/misc/filehelper.cxx	21 Dec 2006 11:21:21 -0000
@@ -146,9 +146,22 @@ namespace configmgr 
 		static const TimeValue k_NullTime = {0,0};		
         sal_uInt64 aSize = 0;
         rModifyTime = k_NullTime;
+		rtl::OUString aURL;
 
-		DirectoryItem aItem;		
-		if (osl::FileBase::E_None == DirectoryItem::get(_sURL, aItem))
+		DirectoryItem aItem;
+
+#ifndef STAT_LOTS_OF_UNUSED_FILES
+		// Statting every file takes way to long - we can use the directory
+		// time-stamp & size instead, if we need to provoke an update
+		// a simple cat > foo; rm foo will do that.
+		// The dir size is (hopefully) non-0 and a good enough proxy value.
+
+		aURL = FileHelper::getParentDir(_sURL);
+#else
+		aURL = _sURL;
+#endif
+
+		if (osl::FileBase::E_None == DirectoryItem::get(aURL, aItem))
 		{
 			FileStatus aStatus(osl_FileStatus_Mask_ModifyTime|osl_FileStatus_Mask_Type|osl_FileStatus_Mask_FileSize);			
 			if (osl::FileBase::E_None == aItem.getFileStatus(aStatus))
Index: configmgr/source/tree/builddata.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/builddata.cxx,v
retrieving revision 1.9.12.1
diff -u -p -u -r1.9.12.1 builddata.cxx
--- configmgr/source/tree/builddata.cxx	3 Nov 2006 11:37:09 -0000	1.9.12.1
+++ configmgr/source/tree/builddata.cxx	21 Dec 2006 11:21:21 -0000
@@ -100,9 +100,7 @@ namespace configmgr
     {
     //-------------------------------------------------------------------------
         using namespace sharable;
-        using memory::Pointer;
         using memory::Accessor;
-        using memory::Allocator;
         using memory::UpdateAccessor;
 //-----------------------------------------------------------------------------
 
@@ -112,18 +110,15 @@ namespace configmgr
     {
         Address aRawAddr = _aNode.addressValue() + _nOffset * sizeof(Node);
 
-        return NodeAddress(Pointer(aRawAddr));
+        return NodeAddress(aRawAddr);
     }
 
     static 
     inline
     NodeAddress addressOfNodeAt(TreeAddress _aTree, Offset _nOffset)
     {
-        Address aRawAddr = _aTree.addressValue() + 
-                            offsetof(TreeFragment,nodes) + 
-                            _nOffset * sizeof(Node);
-
-        return NodeAddress(Pointer(aRawAddr));
+        sharable::TreeFragment *pRaw = _aTree;
+        return NodeAddress( (memory::Address)( pRaw->nodes + _nOffset ));
     }
 
 //-----------------------------------------------------------------------------
@@ -178,7 +173,8 @@ namespace configmgr
     public:
         explicit
         CollectSetElements(UpdateAccessor & _anUpdater)
-        : m_updater(_anUpdater)
+            : m_updater(_anUpdater)
+            , m_head(NULL)
         {
         }
 
@@ -228,7 +224,6 @@ namespace configmgr
         TreeNodeBuilder&    builder()         { return m_builder; }
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
         TreeNodeBuilder     m_builder;
@@ -275,7 +270,7 @@ namespace configmgr
         , m_bWithDefaults()
         {}
 
-        List buildElementList(ISubtree const & _aSet, bool _bWithDefaults);
+        TreeFragment *buildElementList(ISubtree const & _aSet, bool _bWithDefaults);
     private:
         void handleNode(INode const & _aSourceNode);
 
@@ -399,7 +394,6 @@ namespace configmgr
     protected:
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
     };
@@ -427,7 +421,6 @@ namespace configmgr
     private:
         UpdateAccessor &    updater()   const { return m_updater; }
         Accessor            accessor()  const { return m_updater.accessor(); }
-        Allocator           allocator() const { return m_updater.allocator(); }
     private:
         UpdateAccessor &    m_updater;
     };
@@ -493,15 +486,15 @@ std::auto_ptr<INode> convertTree(TreeAcc
 inline 
 void TreeNodeBuilder::CollectSetElements::resetElementList()
 {
-    OSL_ENSURE(m_head.isNull(), "Joining to a element list that was forgotten");
+    OSL_ENSURE(m_head == NULL, "Joining to a element list that was forgotten");
 }
 //-----------------------------------------------------------------------------
 
 inline 
 List TreeNodeBuilder::CollectSetElements::getElementListAndClear()
 {
-    List aResult = m_head.addressValue();
-    m_head = TreeAddress();
+    List aResult = m_head;
+    m_head = NULL;
     return aResult;
 }
 //-----------------------------------------------------------------------------
@@ -511,7 +504,7 @@ void TreeNodeBuilder::CollectSetElements
     if (TreeFragment * pNewFragment = TreeAccessor::access(_aNewElement,m_updater))
     {
         pNewFragment->header.parent = 0; // data not available here
-        pNewFragment->header.next   = m_head.addressValue();
+        pNewFragment->header.next   = m_head;
 
         m_head = _aNewElement;
     }
@@ -638,25 +631,15 @@ void TreeNodeBuilder::resetTreeFragment(
 }
 //-----------------------------------------------------------------------------
 
-TreeAddress TreeNodeBuilder::allocTreeFragment(UpdateAccessor & _anUpdater)
+TreeAddress TreeNodeBuilder::allocTreeFragment(UpdateAccessor &)
 {
     OSL_ENSURE(m_nodes.size() == m_header.count, "TreeNodeBuilder: node count mismatch");
 
-    sal_uInt32 const nFragmentSize = sizeof(TreeFragment) + (m_header.count-1)*sizeof(Node);
-
-    OSL_ASSERT(nFragmentSize >= sizeof m_header + m_header.count*sizeof(Node));
-
-    Address aBaseAddress = _anUpdater.allocator().allocate(nFragmentSize);
-
-    TreeAddress aResult = TreeAddress( memory::Pointer(aBaseAddress) );
+    TreeFragment *pFragment = TreeFragment::allocate(m_header.count);
+    pFragment->header = m_header;
+    std::copy(m_nodes.begin(),m_nodes.end(),pFragment->nodes);
 
-    if (TreeFragment * pFragment = TreeAccessor::access(aResult,_anUpdater))
-    {
-        pFragment->header = m_header;
-        std::copy(m_nodes.begin(),m_nodes.end(),pFragment->nodes);
-    }
-    
-    return aResult;
+    return TreeAddress( pFragment );
 }
 //-----------------------------------------------------------------------------
 
@@ -670,7 +653,7 @@ TreeAddress TreeNodeBuilder::createTreeF
 {
     TreeAddress aResult = allocTreeFragment(_anUpdater);
 
-    if (aResult.is())
+    if (aResult != NULL)
     {
         linkTreeFragment(_anUpdater,aResult);
 
@@ -739,7 +722,7 @@ void TreeNodeBuilder::addValue( Name _aN
 TreeAddress CopyingDataTreeBuilder::buildTree(TreeAccessor const & _aSourceTree)
 {
     OSL_ENSURE(_aSourceTree.isValid(), "Trying to build a tree from  NULL data");
-    if (!_aSourceTree.isValid()) return TreeAddress();
+    if (!_aSourceTree.isValid()) return NULL;
 
     TreeFragment const & aSrc = _aSourceTree.data();
 
@@ -763,12 +746,12 @@ NodeVisitor::Result CopyingDataTreeBuild
 
     AnyData aNewValue, aNewDefault;
     if (aFlags & Flags::valueAvailable)   
-        aNewValue = allocData(allocator(), aType, aSrc.getUserValue(_aNode.accessor()));
+        aNewValue = allocData(aType, aSrc.getUserValue(_aNode.accessor()));
     else
         aNewValue.data = 0;
 
     if (aFlags & Flags::defaultAvailable)   
-        aNewDefault = allocData(allocator(), aType, aSrc.getDefaultValue(_aNode.accessor()));
+        aNewDefault = allocData(aType, aSrc.getDefaultValue(_aNode.accessor()));
     else
         aNewDefault.data = 0;
     
@@ -814,7 +797,7 @@ NodeVisitor::Result CopyingDataTreeBuild
         
 Address CopyingDataTreeBuilder::makeTemplateData(Address _aSourceTemplate)
 {
-    return SetNode::copyTemplateData(allocator(), _aSourceTemplate);
+    return SetNode::copyTemplateData(_aSourceTemplate);
 }
 //-----------------------------------------------------------------------------
 
@@ -927,7 +910,7 @@ void ConvertingDataTreeBuilder::handle(O
         uno::Any aValue = _aNode.getValue();
         if (aValue.hasValue())
         {
-            aNewValue = allocData(allocator(), aType, aValue);
+            aNewValue = allocData(aType, aValue);
             aFlags |= Flags::valueAvailable;
         }
     }
@@ -937,7 +920,7 @@ void ConvertingDataTreeBuilder::handle(O
         uno::Any aDefault = _aNode.getDefault();
         if (aDefault.hasValue())
         {
-            aNewDefault = allocData(allocator(), aType, aDefault);
+            aNewDefault = allocData(aType, aDefault);
             aFlags |= Flags::defaultAvailable;
         }
     }
@@ -1004,7 +987,7 @@ Flags::Field ConvertingDataTreeBuilder::
 
 Address ConvertingDataTreeBuilder::makeTemplateData(rtl::OUString const & _aTemplateName, rtl::OUString const & _aTemplateModule)
 {
-    return SetNode::allocTemplateData(allocator(), _aTemplateName, _aTemplateModule );
+    return SetNode::allocTemplateData(_aTemplateName, _aTemplateModule );
 }
 //-----------------------------------------------------------------------------
 
@@ -1188,9 +1171,9 @@ void DataTreeDefaultMerger::handle(OValu
 
 TreeAddress DataTreeCleanup::destroyTree(TreeAddress _aBaseAddress)
 {
-    TreeFragment * pData = TreeAccessor::access(_aBaseAddress,updater());
+    TreeFragment *pData = TreeAccessor::access(_aBaseAddress,updater());
 
-    List aNext = pData->header.next;
+    TreeFragment *pNext = pData->header.next;
 
     Offset const nCount = pData->header.count;
 
@@ -1201,9 +1184,9 @@ TreeAddress DataTreeCleanup::destroyTree
         destroyNode( addressOfNodeAt(_aBaseAddress,i) );
     }
 
-    allocator().deallocate( _aBaseAddress.addressValue() );
+    TreeFragment::free_shallow( pData );
 
-    return TreeAddress( Pointer(aNext) );
+    return TreeAddress( pNext );
 }
 //-----------------------------------------------------------------------------
 
@@ -1250,16 +1233,16 @@ void DataTreeCleanup::destroyData(NodeIn
 
 void DataTreeCleanup::destroyData(sharable::SetNode * _pNode)
 {
-    TreeAddress aElement( Pointer( _pNode->elements ) );
+    TreeAddress aElement( _pNode->elements );
 
     Address aTemplate = _pNode->elementType;;
 
     destroyData(&_pNode->info);
 
-    while (aElement.is())
+    while (aElement != NULL)
         aElement = destroyTree(aElement);
 
-    SetNode::releaseTemplateData( allocator(), aTemplate );
+    SetNode::releaseTemplateData( aTemplate );
 }
 //-----------------------------------------------------------------------------
 	
@@ -1278,10 +1261,10 @@ void DataTreeCleanup::destroyData(sharab
     destroyData(&_pNode->info);
 
     if (aFlags & Flags::valueAvailable) 
-        freeData( allocator(), aValueType, _pNode->value );
+        freeData( aValueType, _pNode->value );
 
     if (aFlags & Flags::defaultAvailable) 
-        freeData( allocator(), aValueType, _pNode->defaultValue );
+        freeData( aValueType, _pNode->defaultValue );
     
 }
 //-----------------------------------------------------------------------------
Index: configmgr/source/tree/changes.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/changes.cxx,v
retrieving revision 1.19
diff -u -p -u -r1.19 changes.cxx
--- configmgr/source/tree/changes.cxx	16 Sep 2006 15:20:06 -0000	1.19
+++ configmgr/source/tree/changes.cxx	21 Dec 2006 11:21:21 -0000
@@ -259,7 +259,7 @@ AddNode::AddNode(TreeSegment const & _aA
 	:Change(_rName,_bToDefault)
 	,m_aOwnNewNode(_aAddedTree)
 	,m_aOwnOldNode()
-	,m_aInsertedTree()
+	,m_aInsertedTree(NULL)
 	,m_bReplacing(false)
 {
 }
@@ -288,7 +288,7 @@ std::auto_ptr<Change> AddNode::clone() c
 //--------------------------------------------------------------------------
 void AddNode::setInsertedAddress(data::TreeAddress const & _aInsertedTree)	
 {  
-    OSL_ENSURE( !m_aInsertedTree.is(), "AddNode already was applied - inserted a second time ?");
+    OSL_ENSURE( m_aInsertedTree == NULL, "AddNode already was applied - inserted a second time ?");
     m_aInsertedTree = _aInsertedTree;
 }
 //--------------------------------------------------------------------------
Index: configmgr/source/tree/cmtree.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/cmtree.cxx,v
retrieving revision 1.37.12.1
diff -u -p -u -r1.37.12.1 cmtree.cxx
--- configmgr/source/tree/cmtree.cxx	3 Nov 2006 11:37:26 -0000	1.37.12.1
+++ configmgr/source/tree/cmtree.cxx	21 Dec 2006 11:21:21 -0000
@@ -253,7 +253,7 @@ namespace configmgr
 		{
 			INode* pINode = *it2;
 			OUString aName2 = pINode->getName();
-			volatile int dummy;
+			volatile int dummy = 0;
             dummy = 0;
 		}
 #endif
Index: configmgr/source/tree/groupnodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/groupnodeaccess.cxx,v
retrieving revision 1.6.12.1
diff -u -p -u -r1.6.12.1 groupnodeaccess.cxx
--- configmgr/source/tree/groupnodeaccess.cxx	3 Nov 2006 11:37:40 -0000	1.6.12.1
+++ configmgr/source/tree/groupnodeaccess.cxx	21 Dec 2006 11:21:21 -0000
@@ -50,23 +50,19 @@ namespace configmgr
     namespace data
     {
     // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
 
-        Pointer GroupNodeAccess::check(Accessor const& _aAccessor, sharable::GroupNode const* pInnerNode)
+        GroupNodeAccess::AddressType GroupNodeAccess::check(Accessor const&, sharable::GroupNode const* pInnerNode)
         {
-            return _aAccessor.address(pInnerNode);      
+            return (GroupNodeAccess::AddressType) pInnerNode;
         }
     // -------------------------------------------------------------------------
 
-        Pointer GroupNodeAccess::check(NodeAccessRef const& _aNode)
+        GroupNodeAccess::AddressType GroupNodeAccess::check(NodeAccessRef const& _aNode)
         {
             if (sharable::Node const* pNode = _aNode.getDataPtr())
                 return check(_aNode.accessor(), pNode->groupData());
-
             else
-                return Pointer();
+		return NULL;
         }
     // -------------------------------------------------------------------------
         bool GroupNodeAccess::hasChildren() const
Index: configmgr/source/tree/node.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/node.cxx,v
retrieving revision 1.8.12.1
diff -u -p -u -r1.8.12.1 node.cxx
--- configmgr/source/tree/node.cxx	3 Nov 2006 11:37:53 -0000	1.8.12.1
+++ configmgr/source/tree/node.cxx	21 Dec 2006 11:21:21 -0000
@@ -226,68 +226,55 @@ struct SetNodeTemplateData 
 };
 //-----------------------------------------------------------------------------
 static inline
-SetNodeTemplateData * readTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData)
+SetNodeTemplateData * readTemplateData(Address _aTemplateData)
 {
-    return static_cast<SetNodeTemplateData *>( _anAllocator.access(_aTemplateData) );
-}
-//-----------------------------------------------------------------------------
-static inline
-SetNodeTemplateData const * readTemplateData(memory::Accessor const & _anAccessor, Address _aTemplateData)
-{
-    return static_cast<SetNodeTemplateData const*>( _anAccessor.access(memory::Pointer(_aTemplateData)) );
+    return reinterpret_cast<SetNodeTemplateData *>( _aTemplateData );
 }
 //-----------------------------------------------------------------------------
 
-Address SetNode::allocTemplateData(memory::Allocator const & _anAllocator,
-								   const rtl::OUString &rName,
+Address SetNode::allocTemplateData(const rtl::OUString &rName,
 								   const rtl::OUString &rModule)
 {
-    Address aData = _anAllocator.allocate(sizeof(SetNodeTemplateData));
+    SetNodeTemplateData * pData = new SetNodeTemplateData();
 
-    if (aData)
-    {
-        SetNodeTemplateData * pData = readTemplateData(_anAllocator,aData);
-
-        OSL_ENSURE(pData, "Creating template data: unexpected NULL data");
+    OSL_ENSURE(pData, "Creating template data: unexpected NULL data");
     
-        pData->name   = allocName(rName);
-        pData->module = allocName(rModule);
-    }
-    return aData;
+    pData->name   = allocName(rName);
+    pData->module = allocName(rModule);
+
+    return reinterpret_cast<memory::Address>( pData );
 }
 
-Address SetNode::copyTemplateData(memory::Allocator const & _anAllocator, 
-								  Address _aTemplateData)
+Address SetNode::copyTemplateData(Address _aTemplateData)
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAllocator,_aTemplateData);
+    SetNodeTemplateData const * pData = readTemplateData(_aTemplateData);
 
     OSL_ENSURE(pData, "Copying template data: unexpected NULL data");
 
-    return allocTemplateData(_anAllocator, readName(pData->name),
-							 readName(pData->module));
+    return allocTemplateData(readName(pData->name), readName(pData->module));
 }
 
 //-----------------------------------------------------------------------------
 
-void SetNode::releaseTemplateData(memory::Allocator const & _anAllocator, Address _aTemplateData)
+void SetNode::releaseTemplateData(Address _aTemplateData)
 {
     if (!_aTemplateData) return;
 
-    SetNodeTemplateData const * pData = readTemplateData(_anAllocator,_aTemplateData);
+    SetNodeTemplateData const * pData = readTemplateData(_aTemplateData);
 
     OSL_ENSURE(pData, "Freeing template data: unexpected NULL data");
     
     freeName(pData->name);
     freeName(pData->module);
 
-    _anAllocator.deallocate(_aTemplateData);
+    delete pData;
 }
 
 //-----------------------------------------------------------------------------
 
-rtl::OUString SetNode::getElementTemplateName(memory::Accessor const & _anAccessor)   const
+rtl::OUString SetNode::getElementTemplateName() const
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAccessor,this->elementType);
+    SetNodeTemplateData const * pData = readTemplateData(this->elementType);
 
     OSL_ENSURE(pData, "ERROR: No template data found for set");
     
@@ -295,9 +282,9 @@ rtl::OUString SetNode::getElementTemplat
 }
 //-----------------------------------------------------------------------------
 
-rtl::OUString SetNode::getElementTemplateModule(memory::Accessor const & _anAccessor) const
+rtl::OUString SetNode::getElementTemplateModule() const
 {
-    SetNodeTemplateData const * pData = readTemplateData(_anAccessor,this->elementType);
+    SetNodeTemplateData const * pData = readTemplateData(this->elementType);
 
     OSL_ENSURE(pData, "ERROR: No template data found for set");
     
@@ -306,25 +293,25 @@ rtl::OUString SetNode::getElementTemplat
 //-----------------------------------------------------------------------------
 
 static inline
-TreeFragment const * implGetFragmentFromList(memory::Accessor const & _anAccessor, List _aListEntry)
+TreeFragment const * implGetFragmentFromList(List _aListEntry)
 {
-    return static_cast<TreeFragment const *>(_anAccessor.access(memory::Pointer(_aListEntry)));
+    return reinterpret_cast<TreeFragment const *>(_aListEntry);
 }
 //-----------------------------------------------------------------------------
 
-TreeFragment const  * SetNode::getFirstElement(memory::Accessor const & _anAccessor) const   
+TreeFragment const  * SetNode::getFirstElement() const   
 {
-    return implGetFragmentFromList(_anAccessor, this->elements);
+    return implGetFragmentFromList(this->elements);
 }
 //-----------------------------------------------------------------------------
 
-TreeFragment const  * SetNode::getNextElement(memory::Accessor const & _anAccessor, TreeFragment const * _pElement) const    
+TreeFragment const  * SetNode::getNextElement(TreeFragment const * _pElement) const    
 {
     OSL_PRECOND(_pElement, "getNextElement: previous element must not be NULL");
-    OSL_PRECOND(_pElement->header.parent == _anAccessor.address(this).value(), 
+    OSL_PRECOND(_pElement->header.parent == (memory::Address)this, 
                 "getNextElement: not an element of this node");
 
-    return implGetFragmentFromList(_anAccessor, _pElement->header.next);
+    return implGetFragmentFromList(_pElement->header.next);
 }
 //-----------------------------------------------------------------------------
 
Index: configmgr/source/tree/nodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/nodeaccess.cxx,v
retrieving revision 1.4
diff -u -p -u -r1.4 nodeaccess.cxx
--- configmgr/source/tree/nodeaccess.cxx	16 Sep 2006 15:21:45 -0000	1.4
+++ configmgr/source/tree/nodeaccess.cxx	21 Dec 2006 11:21:21 -0000
@@ -68,9 +68,9 @@ namespace configmgr
     {
     // -------------------------------------------------------------------------
         
-        NodeAddress::DataType* NodeAccess::access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor& _rUpdateAccess)
+        NodeAddress::DataType* NodeAccess::access(NodeAddressType const& _aNodeRef, memory::UpdateAccessor&)
         { 
-            return static_cast<NodeAddress::DataType*>(_rUpdateAccess.access(_aNodeRef.m_pData)); 
+            return (NodeAddress::DataType *)_aNodeRef.addressValue();
         }
     // -------------------------------------------------------------------------
 
Index: configmgr/source/tree/nodevisitor.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/nodevisitor.cxx,v
retrieving revision 1.6
diff -u -p -u -r1.6 nodevisitor.cxx
--- configmgr/source/tree/nodevisitor.cxx	16 Sep 2006 15:22:12 -0000	1.6
+++ configmgr/source/tree/nodevisitor.cxx	21 Dec 2006 11:21:22 -0000
@@ -108,7 +108,7 @@ typedef NodeVisitor::Result Result;
         void applyToTree(sharable::TreeFragment const & _aElement);
         void applyToElements(sharable::SetNode const & _aNode);
 
-	    Result dispatch(sharable::TreeFragment const& _aElement);
+	Result dispatch(sharable::TreeFragment const & _aElement);
     };
 
     // -------------------------------------------------------------------------
@@ -138,7 +138,9 @@ typedef NodeVisitor::Result Result;
     inline
     Result SetVisitor::Dispatcher::dispatch(sharable::TreeFragment const& _aElement)
     {
-        return m_target.handle( TreeAccessor(m_accessor, &_aElement) );
+        return m_target.handle
+	  (TreeAccessor(m_accessor,
+			(sharable::TreeFragment *)(& _aElement )));
     }
     // -------------------------------------------------------------------------
 
@@ -169,9 +171,9 @@ typedef NodeVisitor::Result Result;
     void SetVisitor::Dispatcher::applyToElements(sharable::SetNode const & _aNode)
     {
         using sharable::TreeFragment;
-        for (TreeFragment const * pElement = _aNode.getFirstElement(m_accessor);
+        for (TreeFragment const * pElement = _aNode.getFirstElement();
                 pElement != NULL && m_result != NodeVisitor::DONE;
-                pElement = _aNode.getNextElement(m_accessor,pElement) )
+                pElement = _aNode.getNextElement(pElement) )
             m_result = dispatch(*pElement);
 
     }
Index: configmgr/source/tree/setnodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/setnodeaccess.cxx,v
retrieving revision 1.5.12.1
diff -u -p -u -r1.5.12.1 setnodeaccess.cxx
--- configmgr/source/tree/setnodeaccess.cxx	3 Nov 2006 11:38:06 -0000	1.5.12.1
+++ configmgr/source/tree/setnodeaccess.cxx	21 Dec 2006 11:21:22 -0000
@@ -57,22 +57,18 @@ namespace configmgr
     namespace data
     {
     // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
-        Pointer SetNodeAccess::check(Accessor const& _aAccessor, sharable::SetNode const* pInnerNode)
+        SetNodeAccess::AddressType SetNodeAccess::check(Accessor const&, sharable::SetNode const* pInnerNode)
         {
-            return _aAccessor.address(pInnerNode);      
+            return (SetNodeAccess::AddressType) pInnerNode;
         }
     // -------------------------------------------------------------------------
 
-        Pointer SetNodeAccess::check(NodeAccessRef const& _aNode)
+        SetNodeAccess::AddressType SetNodeAccess::check(NodeAccessRef const& _aNode)
         {
             if (sharable::Node const* pNode = _aNode.getDataPtr())
                 return check(_aNode.accessor(),pNode->setData());
-
             else
-                return Pointer();
+                return NULL;
         }
     // -------------------------------------------------------------------------
     
@@ -80,17 +76,14 @@ namespace configmgr
         {
             using namespace sharable;
             SetNode const  & aNode = data();
-            for (TreeFragment const * pElement = aNode.getFirstElement(m_aAccessor);
-                       pElement  != NULL;
-                       pElement  = aNode.getNextElement(m_aAccessor, pElement))
+            for (TreeFragment const * pElement = aNode.getFirstElement();
+                 pElement  != NULL;
+                 pElement  = aNode.getNextElement(pElement))
             {
                 if (pElement->isNamed(_aName.toString()))
-                {
-                    TreeAccessor aElementTree(m_aAccessor,pElement);
-                    return aElementTree.address();
-                }            
+                    return (TreeAddress)pElement;
             }
-            return TreeAddress();
+            return NULL;
         }
     // -------------------------------------------------------------------------*/
         
@@ -98,7 +91,7 @@ namespace configmgr
         {
             using namespace sharable;
 
-            SetNode * pNode = static_cast<SetNode *>( _aAccessor.access( _aSetAddress.m_pData) );
+            SetNode * pNode = (SetNode *)_aSetAddress.m_pData;
             OSL_ENSURE(pNode, "ERROR: Trying to add an element to a NULL set node");
 
             // To do (?): insert sorted - find location here
@@ -106,29 +99,27 @@ namespace configmgr
             OSL_ENSURE(pElement, "ERROR: Trying to add a NULL element to a set node");
 
             pElement->header.next   = pNode->elements;
-            pElement->header.parent = _aSetAddress.m_pData.value();
+            pElement->header.parent = _aSetAddress.m_pData;
 
-            pNode->elements = _aNewElement.addressValue();
+            pNode->elements = _aNewElement;
         }
     // -------------------------------------------------------------------------*/
         
         TreeAddress SetNodeAccess::removeElement(memory::UpdateAccessor & _aAccessor, SetNodeAddress _aSetAddress, Name const & _aName)
         {
             using namespace sharable;
-            using memory::Pointer;
             
-            SetNode * pNode = static_cast<SetNode *>( _aAccessor.access( _aSetAddress.m_pData) );
+            SetNode * pNode = reinterpret_cast<SetNode *>(  _aSetAddress.m_pData );
             OSL_ENSURE(pNode, "ERROR: Trying to add an element to a NULL set node");
 
             TreeAddress aRemoved;
             
             List * pLink = & pNode->elements;
-            while( TreeFragment * pElement = static_cast<TreeFragment *>(_aAccessor.access(Pointer(*pLink))) )
+            while( TreeFragment * pElement = reinterpret_cast<TreeFragment *>(*pLink) )
             {
                 if (pElement->isNamed(_aName.toString()))
                 {
-                    aRemoved = TreeAddress( Pointer(*pLink) );
-                   // aRemoved = TreeAccessor(_aReadAccessor,pElement).address();
+                    aRemoved = *pLink;
 
                     *pLink = pElement->header.next;
                     pElement->header.next   = 0;
@@ -149,7 +140,7 @@ namespace configmgr
         
         bool SetNodeAccess::hasElement(Name const& _aName) const 
         { 
-            return SetNodeAccess::implGetElement(_aName).is(); 
+            return SetNodeAccess::implGetElement(_aName) != NULL; 
         }
     // -------------------------------------------------------------------------
 
Index: configmgr/source/tree/treeaccessor.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/treeaccessor.cxx,v
retrieving revision 1.3
diff -u -p -u -r1.3 treeaccessor.cxx
--- configmgr/source/tree/treeaccessor.cxx	16 Sep 2006 15:22:40 -0000	1.3
+++ configmgr/source/tree/treeaccessor.cxx	21 Dec 2006 11:21:22 -0000
@@ -59,15 +59,15 @@ namespace configmgr
     // -------------------------------------------------------------------------
         TreeAccessor::TreeAccessor()
         : m_aAccessor(NULL)
-        , m_pBase( memory::Pointer() )
+        , m_pBase(NULL)
         {
         }
 
     // -------------------------------------------------------------------------
 
-        TreeAddress::DataType* TreeAccessor::access(DataAddressType const& _aTreeRef, memory::UpdateAccessor& _rUpdateAccess)
+        sharable::TreeFragment* TreeAccessor::access(TreeAddress const& _aTreeRef, memory::UpdateAccessor&)
         { 
-            return static_cast<TreeAddress::DataType*>(_rUpdateAccess.access(_aTreeRef.m_pData)); 
+            return (sharable::TreeFragment *)_aTreeRef;
         }
     // -------------------------------------------------------------------------
         TreeAddress TreeAccessor::copyTree(memory::UpdateAccessor & _aTargetSpace) const
Index: configmgr/source/tree/treefragment.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/treefragment.cxx,v
retrieving revision 1.5.12.1
diff -u -p -u -r1.5.12.1 treefragment.cxx
--- configmgr/source/tree/treefragment.cxx	3 Nov 2006 11:38:18 -0000	1.5.12.1
+++ configmgr/source/tree/treefragment.cxx	21 Dec 2006 11:21:22 -0000
@@ -127,6 +127,19 @@ configmgr::node::Attributes TreeFragment
     return aResult;
 }
 
+TreeFragment *TreeFragment::allocate(sal_uInt32 nFragments)
+{
+    sal_uInt32 nSize = sizeof(TreeFragment) + sizeof(Node) * (nFragments-1);
+    sal_uInt8 *pMem = new sal_uInt8 [nSize];
+    memset (pMem, 0, nSize);
+    return reinterpret_cast<TreeFragment *>(pMem);
+}
+
+void TreeFragment::free_shallow(TreeFragment *pFragment )
+{
+    delete[] (sal_uInt8 *) pFragment;
+}
+
 //-----------------------------------------------------------------------------
     } // namespace sharable
 //-----------------------------------------------------------------------------
Index: configmgr/source/tree/treesegment.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/treesegment.cxx,v
retrieving revision 1.5.12.1
diff -u -p -u -r1.5.12.1 treesegment.cxx
--- configmgr/source/tree/treesegment.cxx	3 Nov 2006 11:38:31 -0000	1.5.12.1
+++ configmgr/source/tree/treesegment.cxx	21 Dec 2006 11:21:22 -0000
@@ -72,23 +72,14 @@ namespace configmgr
     namespace data
     {
 // -----------------------------------------------------------------------------	
-
-//        typedef std::auto_ptr<INode> RawTreeData;
-//        typedef configuration::Name  Name;
-        using memory::Pointer;
-
-// -----------------------------------------------------------------------------	
-// -----------------------------------------------------------------------------	
 struct TreeSegment::Impl : salhelper::SimpleReferenceObject
 {
-    Impl() : data( memory::localHeap() ), base() {}
+    Impl() : data(), base() {}
     ~Impl();
 
     memory::Segment     data;
     data::TreeAddress   base;
 };
-// -----------------------------------------------------------------------------	
-// -----------------------------------------------------------------------------	
 
 // -----------------------------------------------------------------------------	
 TreeSegment::TreeSegment()
@@ -148,7 +139,7 @@ TreeAccessor    TreeSegment::getTreeAcce
 // -----------------------------------------------------------------------------	
 TreeSegment::Impl::~Impl()
 {   
-    if (base.is())
+    if (base != NULL)
     {
         memory::UpdateAccessor aAccess( & this->data );
         destroyTree(aAccess,base);
@@ -166,7 +157,7 @@ TreeSegment::Impl* TreeSegment::createNe
 
     aNewImpl->base = buildElementTree(aNewAccess,*_aTree,_aTypeName,false); // no defaults for set element trees
 
-    if (!aNewImpl->base.is()) aNewImpl.reset();
+    if (aNewImpl->base == NULL) aNewImpl.reset();
 
     return aNewImpl.release();
 }
@@ -182,7 +173,7 @@ TreeSegment::Impl* TreeSegment::createNe
 
     aNewImpl->base = buildTree(aNewAccess,_aTreeName,*_aTree,false); // no defaults for set element trees
 
-    if (!aNewImpl->base.is()) aNewImpl.reset();
+    if (aNewImpl->base == NULL) aNewImpl.reset();
 
     return aNewImpl.release();
 }
@@ -199,7 +190,7 @@ TreeSegment::Impl* TreeSegment::createNe
 
     aNewImpl->base = _aTree.copyTree(aNewAccess);
 
-    if (!aNewImpl->base.is()) aNewImpl.reset();
+    if (aNewImpl->base == NULL) aNewImpl.reset();
 
     return aNewImpl.release();
 }
@@ -221,7 +212,7 @@ TreeSegment TreeSegment::cloneSegment() 
 // -----------------------------------------------------------------------------	
 bool TreeSegment::is() const
 {
-    return hasData() && m_pImpl->base.is();
+    return hasData() && m_pImpl->base != NULL;
 }
 
 // -----------------------------------------------------------------------------	
@@ -266,7 +257,7 @@ void TreeSegment::markRemovable()
 // -----------------------------------------------------------------------------	
 TreeAddress TreeSegment::getBaseAddress() const
 {
-    return hasData() ? m_pImpl->base : TreeAddress();
+    return hasData() ? m_pImpl->base : NULL;
 }
 
 // -----------------------------------------------------------------------------	
Index: configmgr/source/tree/updatehelper.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/updatehelper.cxx,v
retrieving revision 1.11
diff -u -p -u -r1.11 updatehelper.cxx
--- configmgr/source/tree/updatehelper.cxx	16 Sep 2006 15:24:10 -0000	1.11
+++ configmgr/source/tree/updatehelper.cxx	21 Dec 2006 11:21:22 -0000
@@ -510,14 +510,14 @@ void ApplyUpdate::handle(AddNode& _rChan
             data::TreeAddress aOldNodeAddr = 
                 data::SetNodeAccess::removeElement(m_rUpdateAccess,aSetNodeAddr,getChangeNodeName(_rChange));
 
-            OSL_ENSURE(aOldNodeAddr.is(), "ApplyUpdate: AddNode: can't recover node being replaced");
+            OSL_ENSURE(aOldNodeAddr != NULL, "ApplyUpdate: AddNode: can't recover node being replaced");
 
             data::TreeAccessor aOldNodeAccess(m_rUpdateAccess.accessor(),aOldNodeAddr);
             _rChange.takeReplacedTree( data::TreeSegment::createNew(aOldNodeAccess) );
 		}
 
         data::TreeAddress aNewAddress = data::buildTree(m_rUpdateAccess, _rChange.getNewTree().getTreeAccess());
-        OSL_ENSURE(aNewAddress.is(), "ApplyUpdate: AddNode: could not create new element");
+        OSL_ENSURE(aNewAddress != NULL, "ApplyUpdate: AddNode: could not create new element");
 
         data::SetNodeAccess::addElement(m_rUpdateAccess,aSetNodeAddr,aNewAddress);
 
@@ -539,7 +539,7 @@ void ApplyUpdate::handle(RemoveNode& _rC
         data::TreeAddress aOldNodeAddr = 
             data::SetNodeAccess::removeElement(m_rUpdateAccess,aSetNodeAddr,getChangeNodeName(_rChange));
 
-        OSL_ENSURE(aOldNodeAddr.is(), "ApplyUpdate: Remove: can't recover node being removed");
+        OSL_ENSURE(aOldNodeAddr != NULL, "ApplyUpdate: Remove: can't recover node being removed");
 
         data::TreeAccessor aOldNodeAccess(m_rUpdateAccess.accessor(),aOldNodeAddr);
         _rChange.takeRemovedTree( data::TreeSegment::createNew(aOldNodeAccess) );
Index: configmgr/source/tree/valuenodeaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/tree/valuenodeaccess.cxx,v
retrieving revision 1.6
diff -u -p -u -r1.6 valuenodeaccess.cxx
--- configmgr/source/tree/valuenodeaccess.cxx	16 Sep 2006 15:24:22 -0000	1.6
+++ configmgr/source/tree/valuenodeaccess.cxx	21 Dec 2006 11:21:22 -0000
@@ -54,29 +54,24 @@ namespace configmgr
     namespace data
     {
     // -------------------------------------------------------------------------
-        using memory::Pointer;
-    // -------------------------------------------------------------------------
-        static 
-        ValueNodeAddress::DataType* accessValue(Pointer const& _p, memory::UpdateAccessor& _rUpdateAccess)
+	static inline
+	ValueNodeAddress::DataType* accessValue(ValueNodeAddress::AddressType _p)
         {
-            return static_cast<ValueNodeAddress::DataType*>( _rUpdateAccess.validate(_p) );
+            return (ValueNodeAddress::DataType *) _p;
         }
-    // -------------------------------------------------------------------------
-    // -------------------------------------------------------------------------
 
-        Pointer ValueNodeAccess::check(NodeAccessRef const& _aNode)
+        ValueNodeAddress::AddressType ValueNodeAccess::check(NodeAccessRef const& _aNode)
         {
             if (sharable::Node const* pNode = _aNode.getDataPtr())
-                return _aNode.accessor().address(pNode->valueData());
-
+                return (ValueNodeAddress::AddressType) pNode->valueData();
             else
-                return Pointer();
+		return NULL;
         }
     // -------------------------------------------------------------------------
 		    
-void ValueNodeAccess::setValue(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue)
+void ValueNodeAccess::setValue(memory::UpdateAccessor &, NodeAddressType _aValueNode, uno::Any const& _aValue)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = accessValue(_aValueNode.m_pData);
 
     using namespace sharable;
     AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
@@ -86,8 +81,8 @@ void ValueNodeAccess::setValue(memory::U
     {
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->value);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->value);
+        node = accessValue(_aValueNode.m_pData);
 
         node->value.data = 0;
         node->info.flags ^= Flags::valueAvailable;
@@ -114,8 +109,8 @@ void ValueNodeAccess::setValue(memory::U
         if (aType == aNewType)
         {
             // store the data
-            sharable::AnyData aNewData = allocData(_aUpdater.allocator(),aType,_aValue);
-            node = accessValue(_aValueNode.m_pData,_aUpdater);
+            sharable::AnyData aNewData = allocData(aType,_aValue);
+            node = accessValue(_aValueNode.m_pData);
 
             node->value = aNewData;
             node->info.flags |= Flags::valueAvailable;
@@ -125,9 +120,9 @@ void ValueNodeAccess::setValue(memory::U
 }
 //-----------------------------------------------------------------------------
 
-void ValueNodeAccess::setToDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode)
+void ValueNodeAccess::setToDefault(memory::UpdateAccessor &, NodeAddressType _aValueNode)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = accessValue(_aValueNode.m_pData);
 
     using namespace sharable;
     OSL_ENSURE(node->hasUsableDefault(), "ERROR: setToDefault() - Value does not have a default");
@@ -138,8 +133,8 @@ void ValueNodeAccess::setToDefault(memor
         AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->value);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->value);
+        node = accessValue(_aValueNode.m_pData);
 
         node->value.data = 0;
         node->info.flags ^= Flags::valueAvailable;
@@ -149,9 +144,9 @@ void ValueNodeAccess::setToDefault(memor
 }
 //-----------------------------------------------------------------------------
 
-void ValueNodeAccess::changeDefault(memory::UpdateAccessor & _aUpdater, NodeAddressType _aValueNode, uno::Any const& _aValue)
+void ValueNodeAccess::changeDefault(memory::UpdateAccessor &, NodeAddressType _aValueNode, uno::Any const& _aValue)
 {
-    sharable::ValueNode * node = accessValue(_aValueNode.m_pData,_aUpdater);
+    sharable::ValueNode * node = accessValue(_aValueNode.m_pData);
 
     using namespace sharable;
     AnyData::TypeCode aType = AnyData::TypeCode( node->info.type & Type::mask_valuetype );
@@ -161,8 +156,8 @@ void ValueNodeAccess::changeDefault(memo
     {
         OSL_ASSERT(aType != Type::value_any);
 
-        freeData(_aUpdater.allocator(),aType,node->defaultValue);
-        node = accessValue(_aValueNode.m_pData,_aUpdater);
+        freeData(aType,node->defaultValue);
+        node = accessValue(_aValueNode.m_pData);
 
         node->defaultValue.data = 0;
         node->info.flags ^= Flags::defaultAvailable;
@@ -189,8 +184,8 @@ void ValueNodeAccess::changeDefault(memo
         if (aType == aNewType)
         {
             // store the data
-            sharable::AnyData aNewData = allocData(_aUpdater.allocator(),aType,_aValue);
-            node = accessValue(_aValueNode.m_pData,_aUpdater);
+            sharable::AnyData aNewData = allocData(aType,_aValue);
+            node = accessValue(_aValueNode.m_pData);
 
             node->defaultValue = aNewData;
             node->info.flags |= Flags::defaultAvailable;
@@ -198,32 +193,7 @@ void ValueNodeAccess::changeDefault(memo
     }
 }
 
-//-----------------------------------------------------------------------------
-/*
-void ValueNode::clearData(data::Allocator const & _aAlloc)
-{
-    AnyData::TypeCode aType = info.type & Type::mask_valuetype;
-
-    if (info.flags & Flags::valueAvailable)
-    {
-        OSL_ASSERT(aType != Type::value_any);
-        freeData(_aAlloc,aType,this->value);
-        info.flags ^= Flags::valueAvailable;
-        this->value.data = 0;
-    }
-
-    if (info.flags & Flags::defaultAvailable)
-    {
-        OSL_ASSERT(aType != Type::value_any);
-        freeData(_aAlloc,aType,this->defaultValue);
-        info.flags ^= Flags::defaultAvailable;
-        this->defaultValue.data = 0;
-    }
-}
-*/
-//-----------------------------------------------------------------------------
-    }
-// -----------------------------------------------------------------------------	
+    } // namespace data
 } // namespace configmgr
 
 
Index: configmgr/source/treecache/cacheaccess.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheaccess.cxx,v
retrieving revision 1.9
diff -u -p -u -r1.9 cacheaccess.cxx
--- configmgr/source/treecache/cacheaccess.cxx	16 Sep 2006 15:24:36 -0000	1.9
+++ configmgr/source/treecache/cacheaccess.cxx	21 Dec 2006 11:21:22 -0000
@@ -62,10 +62,8 @@ namespace configmgr
 
 // -------------------------------------------------------------------------
 
-CacheClientAccess::CacheClientAccess(memory::HeapManager & _rHeapManager,
-                                     ConfigChangeBroadcastHelper *  _pBroadcastHelper)
+CacheClientAccess::CacheClientAccess(ConfigChangeBroadcastHelper *  _pBroadcastHelper)
 : m_aMutex()
-, m_aData(_rHeapManager)
 , m_pBroadcastHelper( _pBroadcastHelper )
 {
 }
@@ -87,7 +85,7 @@ ConfigChangeBroadcastHelper *  CacheClie
 // -------------------------------------------------------------------------
 
 /// gets a data segment reference for the given path - creates if necessary
-memory::Segment * CacheLoadingAccess::createNewDataSegment(ModuleName const & _aModule)
+memory::Segment * CacheLoadingAccess::createNewDataSegment(CacheLine::Name const & _aModule)
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
@@ -96,24 +94,24 @@ memory::Segment * CacheLoadingAccess::cr
 // -------------------------------------------------------------------------
 
 /// gets a data segment reference for the given path - creates if necessary
-memory::Segment * CacheClientAccess::attachDataSegment(const memory::SegmentAddress & _aSegment, const Path& _aLocation)
+memory::Segment * CacheClientAccess::attachDataSegment(data::TreeAddress _aSegment, const CacheLine::Path& _aLocation)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
     return this->m_aData.attachDataSegment(_aSegment,_aLocation.getModuleName());
 }
 // -------------------------------------------------------------------------
 
 /// gets a data segment reference for the given path if exists
-memory::Segment * CacheClientAccess::getDataSegment(const Path& _aLocation)
+memory::Segment * CacheClientAccess::getDataSegment(const CacheLine::Path& _aLocation)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
     return this->m_aData.getDataSegment(_aLocation.getModuleName());
 }
 // -------------------------------------------------------------------------
 
-bool CacheClientAccess::hasModule(const Path& _aLocation)
+bool CacheClientAccess::hasModule(const CacheLine::Path& _aLocation)
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
@@ -121,7 +119,7 @@ bool CacheClientAccess::hasModule(const 
 }
 // -------------------------------------------------------------------------
 
-bool CacheClientAccess::hasModuleDefaults(memory::Accessor const& _aAccessor, Path const& _aLocation)
+bool CacheClientAccess::hasModuleDefaults(memory::Accessor const& _aAccessor, CacheLine::Path const& _aLocation)
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
@@ -129,7 +127,7 @@ bool CacheClientAccess::hasModuleDefault
 }
 // -------------------------------------------------------------------------
 
-data::NodeAddress CacheClientAccess::acquireNode(memory::Accessor const& _aAccessor, Path const& rLocation )
+data::NodeAddress CacheClientAccess::acquireNode(memory::Accessor const& _aAccessor, CacheLine::Path const& rLocation )
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
@@ -148,13 +146,13 @@ data::NodeAddress CacheClientAccess::acq
 }
 // -------------------------------------------------------------------------
 
-CacheLine::RefCount CacheClientAccess::releaseNode( Path const& rLocation )
+CacheLine::RefCount CacheClientAccess::releaseNode( CacheLine::Path const& rLocation )
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
 	CFG_TRACE_INFO("Tree Info: Releasing subtree data for path '%s'", OUSTRING2ASCII(rLocation.toString()) );
 
-	Module::RefCount nRet = this->m_aData.releaseModule(rLocation.getModuleName(),false);
+	CacheLine::RefCount nRet = this->m_aData.releaseModule(rLocation.getModuleName(),false);
 
 	return nRet;
 }
@@ -170,7 +168,7 @@ void CacheClientAccess::applyUpdate(memo
 }
 
 // -----------------------------------------------------------------------------
-data::NodeAddress CacheClientAccess::findInnerNode( data::Accessor const& _aAccess, Path const& aComponentName )
+data::NodeAddress CacheClientAccess::findInnerNode( data::Accessor const& _aAccess, CacheLine::Path const& aComponentName )
 {
 	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Tree
 
@@ -199,7 +197,7 @@ bool CacheClientAccess::isEmpty()
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
-	Data::ModuleList& rModules = this->m_aData.accessModuleList();
+	CacheData::ModuleList& rModules = this->m_aData.accessModuleList();
 
 	bool bRet = rModules.empty();
 
@@ -210,9 +208,8 @@ bool CacheClientAccess::isEmpty()
 // -------------------------------------------------------------------------
 // -------------------------------------------------------------------------
 
-CacheLoadingAccess::CacheLoadingAccess(memory::HeapManager & _rHeapManager)
+CacheLoadingAccess::CacheLoadingAccess()
 : m_aMutex()
-, m_aData(_rHeapManager)
 , m_aDeadModules()
 {
 }
@@ -224,41 +221,41 @@ CacheLoadingAccess::~CacheLoadingAccess(
 // -------------------------------------------------------------------------
 
 /// gets a data segment reference for the given path - creates if necessary
-memory::Segment * CacheLoadingAccess::attachDataSegment(const memory::SegmentAddress & _aSegment, ModuleName const & _aModule)
+memory::Segment * CacheLoadingAccess::attachDataSegment(data::TreeAddress _aSegment, CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
     return this->m_aData.attachDataSegment(_aSegment,_aModule);
 }
 // -------------------------------------------------------------------------
 
 /// gets a data segment reference for the given path if exists
-memory::Segment * CacheLoadingAccess::getDataSegment(ModuleName const & _aModule)
+memory::Segment * CacheLoadingAccess::getDataSegment(CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
     return this->m_aData.getDataSegment(_aModule);
 }
 // -------------------------------------------------------------------------
 
 /// gets a data segment reference for the given path if exists
-memory::SegmentAddress CacheLoadingAccess::getDataSegmentAddress(ModuleName const & _aModule)
+data::TreeAddress CacheLoadingAccess::getDataSegmentAddress(CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
     return this->m_aData.getDataSegmentAddress(_aModule);
 }
 // -------------------------------------------------------------------------
 
-bool CacheLoadingAccess::hasModule(ModuleName const & _aModule)
+bool CacheLoadingAccess::hasModule(CacheLine::Name const & _aModule)
 {
-	osl::MutexGuard aGuard( this->m_aMutex );
+    osl::MutexGuard aGuard( this->m_aMutex );
 
     return this->m_aData.hasModule(_aModule);
 }
 // -------------------------------------------------------------------------
 
-data::TreeAddress CacheLoadingAccess::acquireModule(ModuleName const & _aModule )
+data::TreeAddress CacheLoadingAccess::acquireModule(CacheLine::Name const & _aModule )
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
@@ -266,7 +263,7 @@ data::TreeAddress CacheLoadingAccess::ac
 
     data::TreeAddress aResult = this->m_aData.acquireModule(_aModule);
 
-	if (aResult.is())
+	if (aResult != NULL)
 	{
 		m_aDeadModules.erase( _aModule );
 		CFG_TRACE_INFO_NI("- Data is available - returning Subtree");
@@ -278,13 +275,13 @@ data::TreeAddress CacheLoadingAccess::ac
 }
 // -------------------------------------------------------------------------
 
-CacheLine::RefCount CacheLoadingAccess::releaseModule( ModuleName const & _aModule )
+CacheLine::RefCount CacheLoadingAccess::releaseModule( CacheLine::Name const & _aModule )
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
 	CFG_TRACE_INFO("Tree Info: Releasing data for module '%s'", OUSTRING2ASCII(_aModule.toString()) );
 
-	Module::RefCount nRet = this->m_aData.releaseModule(_aModule,true); // keep
+	CacheLine::RefCount nRet = this->m_aData.releaseModule(_aModule,true); // keep
     if (nRet == 0)
 	{
         m_aDeadModules[ _aModule ] = TimeStamp::getCurrentTime();
@@ -305,7 +302,7 @@ void CacheLoadingAccess::applyUpdate(mem
 }
 
 // -----------------------------------------------------------------------------
-data::NodeAddress CacheLoadingAccess::findNode( data::Accessor const& _aAccess, Path const& aComponentName )
+data::NodeAddress CacheLoadingAccess::findNode( data::Accessor const& _aAccess, CacheLine::Path const& aComponentName )
 {
 	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Tree
 
@@ -320,7 +317,7 @@ bool CacheLoadingAccess::isEmpty()
 {
 	osl::MutexGuard aGuard( this->m_aMutex );
 
-	Data::ModuleList& rModules = this->m_aData.accessModuleList();
+	ExtendedCacheData::ModuleList& rModules = this->m_aData.accessModuleList();
 
 	bool bRet = rModules.empty();
 
@@ -342,7 +339,7 @@ data::TreeAddress CacheLoadingAccess::ad
                     _bIncludesDefaults ? "Data includes defaults." : "Data does not include defaults." );
 
     data::TreeAddress aResult = this->m_aData.addComponentData(_aAccessToken, _aComponentInstance, _bIncludesDefaults);
-	if (aResult.is())
+	if (aResult != NULL)
 	{
 		m_aDeadModules.erase( _aComponentInstance.component() );
 		CFG_TRACE_INFO_NI("- Data added successfully - returning Subtree");
@@ -366,7 +363,7 @@ void CacheLoadingAccess::addChangesToPen
 }
 
 // -----------------------------------------------------------------------------
-std::auto_ptr<SubtreeChange> CacheLoadingAccess::releasePendingChanges(ModuleName const& _aComponentName)
+std::auto_ptr<SubtreeChange> CacheLoadingAccess::releasePendingChanges(CacheLine::Name const& _aComponentName)
 {
 	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Data
 	CFG_TRACE_INFO("Tree Info: extract pending changes from subtree '%s'", OUSTRING2ASCII(_aComponentName.toString()) );
@@ -374,7 +371,7 @@ std::auto_ptr<SubtreeChange> CacheLoadin
 }
 
 // -----------------------------------------------------------------------------
-bool CacheLoadingAccess::findPendingChangedModules( Data::PendingModuleList & _rPendingList )
+bool CacheLoadingAccess::findPendingChangedModules( ExtendedCacheData::PendingModuleList & _rPendingList )
 {
 	osl::MutexGuard aGuard( this->m_aMutex ); // needed to protect the map access in the Data
     this->m_aData.findPendingModules(_rPendingList);
@@ -388,7 +385,7 @@ void CacheLoadingAccess::clearData(Dispo
 
 	CFG_TRACE_INFO("Tree Info: Removing all module trees for cleanup" );
 
-	typedef Data::ModuleList ModuleList;
+	typedef ExtendedCacheData::ModuleList ModuleList;
 
 	ModuleList& rModules = this->m_aData.accessModuleList();
 
@@ -413,7 +410,7 @@ TimeStamp CacheLoadingAccess::collectDis
 
 	CFG_TRACE_INFO("Tree Info: Collecting disposable module trees for cleanup" );
 
-	Data::ModuleList& rActiveModules = this->m_aData.accessModuleList();
+	ExtendedCacheData::ModuleList& rActiveModules = this->m_aData.accessModuleList();
 
 	DeadModuleList::iterator it = m_aDeadModules.begin();
 
@@ -429,11 +426,11 @@ TimeStamp CacheLoadingAccess::collectDis
         TimeStamp aExpireTime = current->second + _aDelay;
 		if (aExpireTime <= _aLimitTime)
 		{
-            Data::ModuleList::iterator itModule = rActiveModules.find( current->first );
+            ExtendedCacheData::ModuleList::iterator itModule = rActiveModules.find( current->first );
 
 			if (itModule != rActiveModules.end())
 			{
-				ModuleRef xModule = itModule->second;
+				CacheLineRef xModule = itModule->second;
 
 				bool bHandled = false;
 
Index: configmgr/source/treecache/cacheaccess.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheaccess.hxx,v
retrieving revision 1.6
diff -u -p -u -r1.6 cacheaccess.hxx
--- configmgr/source/treecache/cacheaccess.hxx	8 Sep 2005 04:21:46 -0000	1.6
+++ configmgr/source/treecache/cacheaccess.hxx	21 Dec 2006 11:21:22 -0000
@@ -69,21 +69,14 @@ namespace configmgr
 
     class CacheClientAccess : public salhelper::SimpleReferenceObject, Noncopyable
 	{
-	public:
-        typedef CacheData   Data;
-        typedef Data::Module       Module;
-        typedef Data::ModuleRef    ModuleRef;
-        typedef Data::ModuleName   ModuleName;
-        typedef Data::Path         Path;
 	private:
-		osl::Mutex			m_aMutex;
-		Data			    m_aData;		
+	    osl::Mutex  m_aMutex;
+	    CacheData   m_aData;
 
 		ConfigChangeBroadcastHelper* m_pBroadcastHelper;
 	public:
         explicit
-		CacheClientAccess(memory::HeapManager & _rHeapManager,
-                          ConfigChangeBroadcastHelper* _pBroadcastHelper);
+		CacheClientAccess(ConfigChangeBroadcastHelper* _pBroadcastHelper);
 
 		~CacheClientAccess();
 		
@@ -95,20 +88,20 @@ namespace configmgr
         ConfigChangeBroadcastHelper * releaseBroadcaster();
 
         /// gets a data segment reference for the given path - creates if necessary
-        memory::Segment * attachDataSegment(const memory::SegmentAddress & _aSegment, const Path& _aLocation);
+        memory::Segment * attachDataSegment(data::TreeAddress _aSegment, const CacheLine::Path& _aLocation);
         /// gets a data segment reference for the given path if exists
-        memory::Segment * getDataSegment(const Path& _aLocation);
+        memory::Segment * getDataSegment(const CacheLine::Path& _aLocation);
 
 		/// return TRUE if there is no data (left) in this object's cache data 
 		bool isEmpty();
 
         /// check if the given module exists already (and is not empty)
-        bool hasModule(const Path& _aLocation);
+        bool hasModule(const CacheLine::Path& _aLocation);
         /// checks if the given module exists and has defaults available
-        bool hasModuleDefaults(memory::Accessor const & _aAccessor, Path const & _aLocation);
+        bool hasModuleDefaults(memory::Accessor const & _aAccessor, CacheLine::Path const & _aLocation);
 
 		/// retrieve the subtree at _aPath (maybe if it has the requested defaults) and clientAcquire() it
-		data::NodeAddress acquireNode(memory::Accessor const& _aAccessToken, Path const& _aPath); 
+		data::NodeAddress acquireNode(memory::Accessor const& _aAccessToken, CacheLine::Path const& _aPath); 
 
 		/** add or merge the given subtree at the given location,
 			return <TRUE/> if the tree has defaults then
@@ -116,10 +109,10 @@ namespace configmgr
         bool insertDefaults(memory::UpdateAccessor& _aUpdateToken, backend::NodeInstance const & _aDefaultData ) CFG_UNO_THROW_RTE(  );
 
 		/// clientRelease() the tree at aComponentName, and return the resulting reference count
-        CacheLine::RefCount releaseNode( Path const& _aPath ); 
+        CacheLine::RefCount releaseNode( CacheLine::Path const& _aPath ); 
 
 		/// retrieve the given subtree without changing its ref count
-		data::NodeAddress	findInnerNode(memory::Accessor const& _aAccessToken, Path const& _aPath );
+		data::NodeAddress	findInnerNode(memory::Accessor const& _aAccessToken, CacheLine::Path const& _aPath );
 
 		/// merge the given change list into this tree - reflects old data to _aUpdate
         void applyUpdate(memory::UpdateAccessor& _aUpdateToken,  backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( );	
@@ -130,50 +123,44 @@ namespace configmgr
 	
     class CacheLoadingAccess : public salhelper::SimpleReferenceObject, Noncopyable
 	{
-	public:
-        typedef ExtendedCacheData  Data;
-        typedef Data::Module       Module;
-        typedef Data::ModuleRef    ModuleRef;
-        typedef Data::ModuleName   ModuleName;
-        typedef Data::Path         Path;
-
-		typedef std::vector< ModuleRef >  DisposeList;
+    public:
+		typedef std::vector< CacheLineRef >  DisposeList;
         friend class backend::CacheController;
 	private:
         friend class CacheDisposeScheduler;
-        typedef std::map< ModuleName, TimeStamp > DeadModuleList;
+        typedef std::map< CacheLine::Name, TimeStamp > DeadModuleList;
 
 		osl::Mutex			m_aMutex;
-		Data			    m_aData;		
+		ExtendedCacheData   m_aData;		
 		DeadModuleList		m_aDeadModules;			/// list of nodes which are registered for throwing away
 	public:
         explicit
-		CacheLoadingAccess(memory::HeapManager & _rHeapManager);
+		CacheLoadingAccess();
 		~CacheLoadingAccess();
 		
         /// gets a data segment reference for the given path if exists
-        memory::Segment * createNewDataSegment(ModuleName const & _aModule);
+        memory::Segment * createNewDataSegment(CacheLine::Name const & _aModule);
         /// gets a data segment reference for the given path - creates if necessary
-        memory::Segment * attachDataSegment(const memory::SegmentAddress & _aSegment, ModuleName const & _aModule);
+        memory::Segment * attachDataSegment(data::TreeAddress _aSegment, CacheLine::Name const & _aModule);
         /// gets a data segment reference for the given path if exists
-        memory::Segment * getDataSegment(ModuleName const & _aModule);
+        memory::Segment * getDataSegment(CacheLine::Name const & _aModule);
         /// gets a data segment address for the given module if it exists
-        memory::SegmentAddress getDataSegmentAddress(ModuleName const & _aModule);
+        data::TreeAddress getDataSegmentAddress(CacheLine::Name const & _aModule);
 
 		/// return TRUE if there is no data (left) in this object's cache data 
 		bool isEmpty();
 
         /// check if the given module exists already (and is not empty)
-        bool hasModule(ModuleName const & _aLocation);
+        bool hasModule(CacheLine::Name const & _aLocation);
 
 		/// retrieve the subtree at aComponentName and clientAcquire() it
-		data::TreeAddress acquireModule(ModuleName const & _aModule); 
+		data::TreeAddress acquireModule(CacheLine::Name const & _aModule); 
 
 		/// clientRelease() the tree at aComponentName, and return the resulting reference count
-        CacheLine::RefCount releaseModule( ModuleName const & _aModule ); 
+        CacheLine::RefCount releaseModule( CacheLine::Name const & _aModule ); 
 
 		/// retrieve the given subtree without changing its ref count
-		data::NodeAddress	findNode(memory::Accessor const& _aAccessToken, Path const& _aPath );
+		data::NodeAddress	findNode(memory::Accessor const& _aAccessToken, CacheLine::Path const& _aPath );
 
 		/// merge the given change list into this tree - reflects old data to _aUpdate
         void applyUpdate(memory::UpdateAccessor& _aUpdateToken,  backend::UpdateInstance & _aUpdate) CFG_UNO_THROW_RTE( );	
@@ -198,10 +185,10 @@ namespace configmgr
 		/// merge the given change list into the pending change list of this tree
 		void addChangesToPending( backend::ConstUpdateInstance const& _anUpdate ) CFG_UNO_THROW_RTE(  );
 		/// retrieve accumulated pending changes
-		std::auto_ptr<SubtreeChange> releasePendingChanges(ModuleName const& _aModule);
+		std::auto_ptr<SubtreeChange> releasePendingChanges(CacheLine::Name const& _aModule);
 
         /// find the modules having pending changes
-        bool findPendingChangedModules( Data::PendingModuleList & _rPendingList );
+        bool findPendingChangedModules( ExtendedCacheData::PendingModuleList & _rPendingList );
 
         /// get a local lock for this cache line
         osl::Mutex & mutex() { return m_aMutex; }
Index: configmgr/source/treecache/cachecontroller.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachecontroller.cxx,v
retrieving revision 1.18
diff -u -p -u -r1.18 cachecontroller.cxx
--- configmgr/source/treecache/cachecontroller.cxx	16 Sep 2006 15:24:50 -0000	1.18
+++ configmgr/source/treecache/cachecontroller.cxx	21 Dec 2006 11:21:23 -0000
@@ -1,3 +1,4 @@
+#include <stdio.h>
 /*************************************************************************
  *
  *  OpenOffice.org - a multi-platform office productivity suite
@@ -142,43 +143,37 @@ OCacheWriteScheduler* CacheController::c
 
 CacheController::CacheRef CacheController::getCacheAlways(RequestOptions const & _aOptions)
 {
-    osl::MutexGuard aGuard( m_aCacheList.mutex() );
+    osl::MutexGuard aGuard( m_aCacheMap.mutex() );
 
-    CacheRef aResult = m_aCacheList.get(_aOptions);
+    CacheRef aResult = m_aCacheMap.get(_aOptions);
     if (!aResult.is())
     {
-        CacheRef aNewCache( new Cache(getCacheHeapManager()) );
-        aResult = m_aCacheList.insert(_aOptions,aNewCache);
+        CacheRef aNewCache( new Cache() );
+        aResult = m_aCacheMap.insert(_aOptions,aNewCache);
     }
     return aResult;
 }
 
 // -------------------------------------------------------------------------
 
-memory::HeapManager & CacheController::getCacheHeapManager() const
-{
-    return m_aTemplates.getHeapManager();
-}
-// -------------------------------------------------------------------------
-
 // disposing
 // -------------------------------------------------------------------------
 void CacheController::disposeAll(bool _bFlushRemainingUpdates)
 {
 	CFG_TRACE_INFO("CacheController: Disposing all data" );
-    CacheList::Map aReleaseList;
+    CacheMap::Map aReleaseList;
 
 	if (m_pDisposer)
 	{
 		osl::MutexGuard aShotGuard(m_pDisposer->getShotMutex());
-		osl::MutexGuard aGuard(m_aCacheList.mutex());
+		osl::MutexGuard aGuard(m_aCacheMap.mutex());
 		m_pDisposer->stopAndClearTasks();
-		m_aCacheList.swap(aReleaseList); // move data out of m_aCacheList and empty m_aCacheList
+		m_aCacheMap.swap(aReleaseList); // move data out of m_aCacheMap and empty m_aCacheMap
 	}
 
     if (_bFlushRemainingUpdates)
     {
-        for (CacheList::Map::iterator it = aReleaseList.begin(); it != aReleaseList.end(); ++it)
+        for (CacheMap::Map::iterator it = aReleaseList.begin(); it != aReleaseList.end(); ++it)
             saveAllPendingChanges(it->second,it->first);
     }
 	// free all the trees
@@ -203,7 +198,7 @@ void CacheController::dispose() CFG_UNO_
 // -------------------------------------------------------------------------
 void CacheController::disposeOne(RequestOptions const & _aOptions, bool _bFlushUpdates)
 {
-	osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
+	osl::ClearableMutexGuard aGuard(m_aCacheMap.mutex());
 
 	CFG_TRACE_INFO("CacheController: Disposing data and TreeInfo for user '%s' with locale '%s'",
 					OUSTRING2ASCII(_aOptions.getEntity()), OUSTRING2ASCII(_aOptions.getLocale()) );
@@ -218,7 +213,7 @@ void CacheController::disposeOne(Request
 		CFG_TRACE_WARNING_NI("Found orphaned Changes in the cache - Discarding.");
     }
 
-    CacheRef aRemoved = m_aCacheList.remove(_aOptions);
+    CacheRef aRemoved = m_aCacheMap.remove(_aOptions);
 	
 	if (aRemoved.is())
 	{
@@ -233,7 +228,7 @@ void CacheController::disposeOne(Request
 // -------------------------------------------------------------------------
 void CacheController::disposeUser(RequestOptions const & _aUserOptions, bool _bFlushUpdates)
 {
-	osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
+	osl::ClearableMutexGuard aGuard(m_aCacheMap.mutex());
 
 	CFG_TRACE_INFO("CacheController: Disposing data and TreeInfo(s) for user '%s'",
 					OUSTRING2ASCII(_aUserOptions.getEntity()) );
@@ -250,14 +245,14 @@ void CacheController::disposeUser(Reques
 		// so that all options belonging to one user are together
 		// (and that options with only a user set, sort first)
 
-        CacheList::Map aCacheData;
-        m_aCacheList.swap(aCacheData);
+        CacheMap::Map aCacheData;
+        m_aCacheMap.swap(aCacheData);
 
 		// find the lower_bound of all options for the user
-		CacheList::Map::iterator const aFirst = aCacheData.lower_bound(_aUserOptions);
+		CacheMap::Map::iterator const aFirst = aCacheData.lower_bound(_aUserOptions);
 
 		// find the upper_bound of all options for the user (using the lower one)
-		CacheList::Map::iterator aLast = aFirst;
+		CacheMap::Map::iterator aLast = aFirst;
 		while (aLast != aCacheData.end() && aLast->first.getEntity() == sUser)
 			++aLast;
 
@@ -267,7 +262,7 @@ void CacheController::disposeUser(Reques
 
 			bool bHasPendingChanges = false;
 
-			for (CacheList::Map::iterator it = aFirst; it != aLast; ++it)
+			for (CacheMap::Map::iterator it = aFirst; it != aLast; ++it)
 			{
 				CFG_TRACE_INFO_NI("- Found TreeInfo for locale '%s'", OUSTRING2ASCII(it->first.getLocale()) );
 				m_pDisposer->clearTasks(it->first);
@@ -295,7 +290,7 @@ void CacheController::disposeUser(Reques
 			CFG_TRACE_INFO_NI("- No affected TreeInfo found" );
 
         // replace the data into the map
-        m_aCacheList.swap(aCacheData);
+        m_aCacheMap.swap(aCacheData);
 	}
 
 	// got all out of external reach - now dispose/notify without lock
@@ -343,12 +338,11 @@ void CacheController::implDisposeOne(Cac
 
 // -------------------------------------------------------------------------
 CacheController::CacheController(BackendRef const & _xBackend, 
-								 memory::HeapManager & _rCacheHeapManager,
 								 const uno::Reference<uno::XComponentContext>& xContext)
 : m_aNotifier()
 , m_xBackend(_xBackend)
-, m_aCacheList()
-, m_aTemplates(_rCacheHeapManager)
+, m_aCacheMap()
+, m_aTemplates()
 , m_pDisposer()
 , m_pCacheWriter()
 , m_bDisposing(false)
@@ -409,18 +403,27 @@ std::auto_ptr<ISubtree> reduceSubtreeFor
 // -------------------------------------------------------------------------
 
 static
-CacheLocation makeCacheLocation(memory::SegmentAddress const & _aSegment, memory::Heap::Address const & _anAddress)
+CacheLocation makeCacheLocation(sharable::TreeFragment *_pSegment,
+                                sharable::TreeFragment *_pAddress)
 {
-    OSL_PRECOND(!_aSegment.isNull() || _anAddress == 0,"ERROR: Got Non-null address for NULL segment ?!");
-
-    CacheLocation aResult;
+    OSL_PRECOND(_pSegment != NULL || _pAddress == NULL,"ERROR: Got Non-null address for NULL segment ?!");
+    return _pSegment;
+#if 0
+//    OSL_PRECOND(_pSegment == _pAddress, "ERROR: non-matching cachelocation ptrs");
+    if (_pSegment != _pAddress)
+    {
+        fprintf (stderr, "makeCacheLocation %p %p\n", _pSegment, _pAddress);
+        fscanf (stdin, ""); // BREAK HERE ...
+    }
+    else
+        fprintf (stderr, "match\n");
 
-    aResult.segment = _aSegment;
-    aResult.address = _anAddress;
+    CacheLocation aResult(_pSegment, _pAddress);
 
-    OSL_ASSERT(!_aSegment.isNull() || aResult.isNull());
+    OSL_ASSERT(_pSegment != NULL || aResult.isNull());
 
     return aResult;
+#endif
 }
 // -------------------------------------------------------------------------
 CacheLocation CacheController::loadComponent(ComponentRequest const & _aRequest)
@@ -469,8 +472,7 @@ CacheLocation CacheController::loadCompo
 	}
 
     return makeCacheLocation( aCache->getDataSegmentAddress(_aRequest.getComponentName()),
-                              aResultAddress.addressValue());
-
+                              aResultAddress);
 }
 // -------------------------------------------------------------------------
 
@@ -564,7 +566,7 @@ data::TreeAddress CacheController::addTe
 {
     OSL_PRECOND(_aComponentInstance.data.get(), "addTemplates: Data must not be NULL");
     osl::MutexGuard aGuard(m_aTemplatesMutex);
-    TemplateCacheData::ModuleName aModuleName = _aComponentInstance.name;
+    CacheLine::Name aModuleName = _aComponentInstance.name;
     memory::UpdateAccessor aTemplatesUpdater( m_aTemplates.createDataSegment(aModuleName) );
     AbsolutePath aTemplateLocation = AbsolutePath::makeModulePath(_aComponentInstance.name , AbsolutePath::NoValidate());
     data::TreeAddress aTemplateAddr;
@@ -573,7 +575,7 @@ data::TreeAddress CacheController::addTe
         CFG_TRACE_INFO_NI("CacheController: cache miss for that template - loading from backend");
         aTemplateAddr = m_aTemplates.addTemplates(aTemplatesUpdater, _aComponentInstance );
     }
-    OSL_ASSERT (aTemplateAddr.is());
+    OSL_ASSERT (aTemplateAddr != NULL);
     return aTemplateAddr;
  }
 // -------------------------------------------------------------------------
@@ -591,7 +593,7 @@ CacheLocation CacheController::loadTempl
 
     AbsolutePath aTemplateLocation = encodeTemplateLocation(_aRequest.getTemplateName(), _aRequest.getComponentName());
 
-    TemplateCacheData::ModuleName aModuleName =  aTemplateLocation.getModuleName();
+    CacheLine::Name aModuleName =  aTemplateLocation.getModuleName();
     osl::MutexGuard aGuard(m_aTemplatesMutex);
     memory::Accessor aTemplatesAccessor( m_aTemplates.getDataSegment(aModuleName) );
     AbsolutePath aTemplateParent (aTemplateLocation.getParentPath());
@@ -610,10 +612,11 @@ CacheLocation CacheController::loadTempl
     }
     memory::Accessor aTemplateAccessor( m_aTemplates.getDataSegment(aModuleName) );
     data::TreeAddress aTemplateAddr = m_aTemplates.getTemplateTree(aTemplateAccessor,aTemplateLocation);
-	if (aTemplateAddr.isNull())
-		throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
+    if (aTemplateAddr == NULL)
+        throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
 
-    return makeCacheLocation( m_aTemplates.getDataSegmentAddress(aTemplateLocation.getModuleName()) , aTemplateAddr.addressValue());
+    return makeCacheLocation( m_aTemplates.getDataSegmentAddress(aTemplateLocation.getModuleName()),
+                              aTemplateAddr);
 }
 // -----------------------------------------------------------------------------
 
@@ -638,8 +641,8 @@ TemplateResult CacheController::getTempl
     memory::Accessor aTemplatesAccessor( pTemplatesSegment );
 
     data::TreeAddress aTemplateAddr = m_aTemplates.getTemplateTree(aTemplatesAccessor,aTemplateLocation);
-	if (aTemplateAddr.isNull())
-		throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
+    if (aTemplateAddr == NULL)
+	throw uno::Exception(::rtl::OUString::createFromAscii("Unknown template. Type description could not be found in the given module."), NULL);
 
     data::TreeAccessor aTemplateTree(aTemplatesAccessor,aTemplateAddr);
 
@@ -661,7 +664,7 @@ void CacheController::saveAndNotify(Upda
 	    // caller must own a read lock on this cache line
 	    CFG_TRACE_INFO("CacheController: saving an update for '%s'",OUSTRING2ASCII(_anUpdate.getUpdateRoot().toString()));
 
-        CacheRef aCache = m_aCacheList.get(_anUpdate.getOptions());
+        CacheRef aCache = m_aCacheMap.get(_anUpdate.getOptions());
 
 	    OSL_ENSURE(aCache.is(), "No cache data to update in saveAndNotify");
 
@@ -697,11 +700,11 @@ void CacheController::saveAndNotify(Upda
 
 void CacheController::flushPendingUpdates()CFG_UNO_THROW_ALL()
 {
-    osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
-    CacheList::Map aFlushList = m_aCacheList.copy();
+    osl::ClearableMutexGuard aGuard(m_aCacheMap.mutex());
+    CacheMap::Map aFlushList = m_aCacheMap.copy();
     aGuard.clear();
 
-    for (CacheList::Map::iterator it = aFlushList.begin(); it != aFlushList.end(); ++it)
+    for (CacheMap::Map::iterator it = aFlushList.begin(); it != aFlushList.end(); ++it)
         saveAllPendingChanges(it->second,it->first);
 }
 
@@ -853,7 +856,7 @@ bool CacheController::saveAllPendingChan
     CFG_TRACE_INFO("CacheController: Saving all pending changes for cache line");
     OSL_ASSERT(_aCache.is());
 
-    typedef Cache::Data::PendingModuleList PMList;
+    typedef ExtendedCacheData::PendingModuleList PMList;
 
     PMList aPendingModules;
     _aCache->findPendingChangedModules(aPendingModules);
@@ -890,7 +893,7 @@ void CacheController::freeComponent(Comp
                     OUSTRING2ASCII(_aRequest.getOptions().getEntity()),
                     OUSTRING2ASCII(_aRequest.getOptions().getLocale()) );
 
-    CacheRef aCache = m_aCacheList.get(_aRequest.getOptions());
+    CacheRef aCache = m_aCacheMap.get(_aRequest.getOptions());
 
     OSL_ENSURE(aCache.is(), "Releasing a nonexisting module");
 
@@ -911,11 +914,11 @@ void CacheController::dataChanged(const 
 // -----------------------------------------------------------------------------
 void CacheController::refreshAllComponents() CFG_UNO_THROW_ALL()
 {
-    osl::ClearableMutexGuard aGuard(m_aCacheList.mutex());
-    CacheList::Map aRefreshList = m_aCacheList.copy();
+    osl::ClearableMutexGuard aGuard(m_aCacheMap.mutex());
+    CacheMap::Map aRefreshList = m_aCacheMap.copy();
     aGuard.clear();
 
-    for (CacheList::Map::iterator i = aRefreshList.begin(); 
+    for (CacheMap::Map::iterator i = aRefreshList.begin(); 
         i != aRefreshList.end(); ++i)
 	{
         if (!i->second->isEmpty())
Index: configmgr/source/treecache/cachecontroller.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachecontroller.hxx,v
retrieving revision 1.10
diff -u -p -u -r1.10 cachecontroller.hxx
--- configmgr/source/treecache/cachecontroller.hxx	8 Sep 2005 04:22:14 -0000	1.10
+++ configmgr/source/treecache/cachecontroller.hxx	21 Dec 2006 11:21:23 -0000
@@ -85,7 +85,7 @@ namespace configmgr
 
     : public ICachedDataProvider
     , public IDirectDataProvider // Refcounted
-	, public INodeDataListener
+    , public INodeDataListener
 	{
         typedef backend::IMergedDataProvider Backend;
         typedef rtl::Reference< Backend > BackendRef;
@@ -96,7 +96,6 @@ namespace configmgr
 		*/
         explicit
         CacheController(BackendRef const & _xBackend, 
-						memory::HeapManager & _rCacheHeapManager,
 						const uno::Reference<uno::XComponentContext>& xContext);
 
     // ICachedDataProvider implementation
@@ -309,8 +308,6 @@ namespace configmgr
 	protected:
 		// ref counted, that's why no public dtor
 		~CacheController();
-
-        memory::HeapManager & getCacheHeapManager() const;
     // implementation 
     private:
         typedef CacheLoadingAccess      Cache;
@@ -364,15 +361,12 @@ namespace configmgr
  
         void closeModules(Cache::DisposeList & _aList, RequestOptions const & _aOptions);
     private:
-        typedef AutoReferenceMap<RequestOptions,Cache,lessRequestOptions>   CacheList;
-        typedef TemplateCacheData TemplateCache;
-
+        typedef AutoReferenceMap<RequestOptions,Cache,lessRequestOptions>   CacheMap;
 
         CacheChangeMulticaster  m_aNotifier;
-		BackendRef			    m_xBackend;  
-
-		CacheList				m_aCacheList; // Map
-		TemplateCache			m_aTemplates;
+	BackendRef		m_xBackend;  
+	CacheMap		m_aCacheMap;
+	TemplateCacheData	m_aTemplates;
 		
         osl::Mutex              m_aTemplatesMutex;
 
Index: configmgr/source/treecache/cachedata.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachedata.cxx,v
retrieving revision 1.7
diff -u -p -u -r1.7 cachedata.cxx
--- configmgr/source/treecache/cachedata.cxx	16 Sep 2006 15:25:09 -0000	1.7
+++ configmgr/source/treecache/cachedata.cxx	21 Dec 2006 11:21:23 -0000
@@ -120,15 +120,14 @@ namespace configmgr
 	};
 
 // -----------------------------------------------------------------------------
-    static inline CacheData::ModuleName implExtractModuleName(CacheData::Path const& aConfigPath)
+    static inline CacheLine::Name implExtractModuleName(CacheLine::Path const& aConfigPath)
 	{
 		return aConfigPath.getModuleName();
 	}
 
 // -----------------------------------------------------------------------------
 	
-	CacheData::CacheData(memory::HeapManager & _rHeapManager)
-    : m_rHeapManager(_rHeapManager)
+	CacheData::CacheData()
 	{
 	}
 // -----------------------------------------------------------------------------
@@ -139,13 +138,13 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
 
-	CacheData::ModuleName CacheData::extractModuleName(Path const& _aPath)
+	CacheLine::Name CacheData::extractModuleName(CacheLine::Path const& _aPath)
 	{
 		return implExtractModuleName(_aPath);
 	}
 // -----------------------------------------------------------------------------
 	inline
-    CacheLineRef CacheData::internalGetModule(const ModuleName& _aModuleName ) const
+    CacheLineRef CacheData::internalGetModule(const CacheLine::Name& _aModuleName ) const
 	{
 		OSL_ASSERT(!_aModuleName.isEmpty());
 
@@ -155,14 +154,14 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
 	inline
-    CacheLineRef CacheData::internalGetModule(const Path&  _aPath) const
+    CacheLineRef CacheData::internalGetModule(const CacheLine::Path&  _aPath) const
 	{
 		return internalGetModule( implExtractModuleName(_aPath) );
 	}
 // -----------------------------------------------------------------------------
 
 	inline
-    void CacheData::internalAddModule(const ModuleName& _aName, const ModuleRef & _aModule)
+    void CacheData::internalAddModule(const CacheLine::Name& _aName, const CacheLineRef & _aModule)
 	{
 		//OSL_PRECOND(m_aModules.find(_aName) == m_aModules.end(), "ERROR: Module already present in CacheData");
 
@@ -173,9 +172,9 @@ namespace configmgr
 // -----------------------------------------------------------------------------
 // -----------------------------------------------------------------------------
 
-    CacheLineRef CacheData::internalAttachModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef CacheData::internalAttachModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
 	{
-        CacheLineRef aNewModule = doCreateAttachedModule(this->internalHeapManager(), _aLocation,_aName);
+        CacheLineRef aNewModule = doCreateAttachedModule(_aLocation,_aName);
 
 		internalAddModule( _aName, aNewModule );
 		
@@ -184,7 +183,7 @@ namespace configmgr
 // -----------------------------------------------------------------------------
 
     /// creates a new data segment reference for the given path - creates if necessary
-    memory::Segment * CacheData::attachDataSegment(memory::SegmentAddress const & _aLocation, ModuleName const & _aModule)
+    memory::Segment * CacheData::attachDataSegment(data::TreeAddress _aLocation, CacheLine::Name const & _aModule)
     {
         CacheLineRef aModule = this->internalAttachModule(_aLocation,_aModule);
 
@@ -192,14 +191,14 @@ namespace configmgr
     }
 // -------------------------------------------------------------------------
 
-    CacheLineRef CacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef CacheData::doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
     {
-        return CacheLine::createAttached( _aName, _rHeapManager, _aLocation ); 
+        return CacheLine::createAttached( _aName, _aLocation ); 
     }
 // -----------------------------------------------------------------------------
 
     /// gets a data segment reference for the given path if exists
-    memory::Segment * CacheData::getDataSegment(const ModuleName & _aModule)
+    memory::Segment * CacheData::getDataSegment(const CacheLine::Name & _aModule)
     {
         CacheLineRef aModule = internalGetModule(_aModule);
 
@@ -208,15 +207,15 @@ namespace configmgr
 // -------------------------------------------------------------------------
 
     /// gets a data segment reference for the given path if exists
-    memory::SegmentAddress CacheData::getDataSegmentAddress(const ModuleName & _aModule) const
+    data::TreeAddress CacheData::getDataSegmentAddress(const CacheLine::Name & _aModule) const
     {
         CacheLineRef aModule = internalGetModule(_aModule);
 
-        return aModule.is() ? aModule->getDataSegmentAddress() : memory::SegmentAddress();
+        return aModule.is() ? aModule->getDataSegmentAddress() : NULL;
     }
 // -------------------------------------------------------------------------
         
-    bool CacheData::hasModule(const ModuleName & _aModule) const
+    bool CacheData::hasModule(const CacheLine::Name & _aModule) const
     {
         CacheLineRef aModule = internalGetModule(_aModule);
 
@@ -224,7 +223,7 @@ namespace configmgr
     }
 // -------------------------------------------------------------------------
         
-    bool CacheData::hasModuleDefaults(memory::Accessor const & _aAccessor, const ModuleName & _aModule) const
+    bool CacheData::hasModuleDefaults(memory::Accessor const & _aAccessor, const CacheLine::Name & _aModule) const
     {
         CacheLineRef aModule = internalGetModule(_aModule);
 
@@ -232,19 +231,19 @@ namespace configmgr
     }
 // -------------------------------------------------------------------------
 
-    data::TreeAddress CacheData::internalGetPartialTree(memory::Accessor const & _aAccessor, const Path& aComponentName ) const
-	{
-		CacheLineRef xModule = internalGetModule(aComponentName);
+    data::TreeAddress CacheData::internalGetPartialTree(memory::Accessor const & _aAccessor, const CacheLine::Path& aComponentName ) const
+    {
+	CacheLineRef xModule = internalGetModule(aComponentName);
 		
-		if ( !xModule.is() )
-            return data::TreeAddress();
+	if ( !xModule.is() )
+            return NULL;
 
         data::TreeAddress pSubtree = xModule->getPartialTree(_aAccessor,aComponentName);
 
-		OSL_ENSURE( pSubtree.isNull() || xModule->clientReferences() != 0 , 
+		OSL_ENSURE( pSubtree == NULL || xModule->clientReferences() != 0 , 
 					"WARNING: returning subtree from module without clients\n" );
 #ifdef CFG_ENABLE_TRACING
-		if( pSubtree.is() && xModule->clientReferences() == 0) 
+		if( pSubtree != NULL && xModule->clientReferences() == 0) 
 		{
 			CFG_TRACE_WARNING("CacheData data: returning subtree %s from module without clients", OUSTRING2ASCII( aComponentName.toString() ) );
 		}
@@ -253,7 +252,7 @@ namespace configmgr
 		return pSubtree;	
 	}
 // -----------------------------------------------------------------------------
-    data::NodeAddress CacheData::internalGetNode(memory::Accessor const & _aAccessor, const Path& aComponentName ) const
+    data::NodeAddress CacheData::internalGetNode(memory::Accessor const & _aAccessor, const CacheLine::Path& aComponentName ) const
 	{
 		CacheLineRef xModule = internalGetModule(aComponentName);
 		
@@ -278,21 +277,21 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
 // -----------------------------------------------------------------------------	
-    data::TreeAddress CacheData::acquireModule(ModuleName const & _aModule)
-	{
+    data::TreeAddress CacheData::acquireModule(CacheLine::Name const & _aModule)
+    {
         CacheLineRef xModule = internalGetModule(_aModule);
 
-		CacheLineClientRef aClientRef(xModule);
+	CacheLineClientRef aClientRef(xModule);
 
-        data::TreeAddress aModuleAddr = xModule.is() ? xModule->getModuleRootAddress() : data::TreeAddress();
+        data::TreeAddress aModuleAddr = xModule.is() ? xModule->getModuleRootAddress() : NULL;
 
-		if (aModuleAddr.is()) 
-            aClientRef.keep();
+	if (aModuleAddr != NULL) 
+	    aClientRef.keep();
 
         return aModuleAddr;
-	}
+    }
 // -----------------------------------------------------------------------------	
-    data::NodeAddress CacheData::acquireNode(memory::Accessor const & _aAccessor, Path const& _aPath)
+    data::NodeAddress CacheData::acquireNode(memory::Accessor const & _aAccessor, CacheLine::Path const& _aPath)
 	{
 		CacheLineClientRef aClientRef(internalGetModule(_aPath));
 
@@ -327,12 +326,12 @@ namespace configmgr
         if (!xModule.is()) return false;
 
         // make sure to keep the module alive
-		CacheLineClientRef( xModule ).keep();
+	CacheLineClientRef( xModule ).keep();
 
-        data::TreeAddress aResultTree = xModule->insertDefaults(_aAccessToken, _aDefaultInstance);
+	data::TreeAddress aResultTree = xModule->insertDefaults(_aAccessToken, _aDefaultInstance);
 
-		return aResultTree.is();
-	}
+	return aResultTree != NULL;
+    }
 // -----------------------------------------------------------------------------
 
     void CacheData::applyUpdate(memory::UpdateAccessor & _aAccessToken, backend::UpdateInstance & _anUpdate ) CFG_UNO_THROW_RTE(  )
@@ -355,7 +354,7 @@ namespace configmgr
 		}
 	}
 // -----------------------------------------------------------------------------	
-    CacheLine::RefCount CacheData::releaseModule( ModuleName const & _aModule, bool _bKeepDeadModule )
+    CacheLine::RefCount CacheData::releaseModule( CacheLine::Name const & _aModule, bool _bKeepDeadModule )
 	{
 		CacheLineRef xModule = internalGetModule(_aModule);
 
@@ -376,17 +375,17 @@ namespace configmgr
 	}
 
 // -----------------------------------------------------------------------------
-    data::TreeAddress CacheData::getTemplateTree( memory::Accessor const & _aAccessor, Path const& aTemplateName ) const
+    data::TreeAddress CacheData::getTemplateTree( memory::Accessor const & _aAccessor, CacheLine::Path const& aTemplateName ) const
 	{
 		return internalGetPartialTree(_aAccessor,aTemplateName);
 	}
 // -----------------------------------------------------------------------------
-    data::NodeAddress CacheData::getNode(memory::Accessor const & _aAccessor, const Path& _rPath)
+    data::NodeAddress CacheData::getNode(memory::Accessor const & _aAccessor, const CacheLine::Path& _rPath)
 	{
 		return internalGetNode(_aAccessor,_rPath);
 	}
 // -----------------------------------------------------------------------------
-    bool CacheData::hasNode(memory::Accessor const & _aAccessor, const Path& _rPath) const
+    bool CacheData::hasNode(memory::Accessor const & _aAccessor, const CacheLine::Path& _rPath) const
 	{
 		return internalGetNode(_aAccessor,_rPath).is();
 	}
@@ -394,7 +393,7 @@ namespace configmgr
 // -----------------------------------------------------------------------------
 
     /// gets a data segment reference for the given path - creates if necessary
-    memory::Segment * TemplateCacheData::createDataSegment(ModuleName const & _aModule)
+    memory::Segment * TemplateCacheData::createDataSegment(CacheLine::Name const & _aModule)
     {
         CacheLineRef aModule = implNewCacheLine(_aModule);
 
@@ -407,12 +406,12 @@ namespace configmgr
 	{
         OSL_PRECOND(_aComponentInstance.data.get(), "addTemplates: Data must not be NULL");
         // we should already have the module in cache !
-		ModuleName aModuleName ( _aComponentInstance.name); 
+		CacheLine::Name aModuleName ( _aComponentInstance.name); 
         CacheLineRef xModule = internalGetModule(aModuleName);
 
 		OSL_ENSURE( xModule.is(), "ExtendedCacheData::addTemplates: No module to add the templates to - where did the data segment come from ?");
 		
-        if (!xModule.is()) return data::TreeAddress();
+        if (!xModule.is()) return NULL;
 
         // make sure to keep the module alive
 		CacheLineClientRef( xModule ).keep();
@@ -423,25 +422,23 @@ namespace configmgr
 
         data::TreeAddress aResult = xModule->setComponentData(_aUpdateToken, _aComponentInstance, true);
         
-        OSL_ASSERT(aResult.is());
+        OSL_ASSERT(aResult != NULL);
 
-		return aResult;
-	}
+	return aResult;
+    }
 // -----------------------------------------------------------------------------
 
-    CacheLineRef TemplateCacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef TemplateCacheData::doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
     {
-        CacheLineRef aNewModule = 
-            CacheLine::createAttached(_aName, _rHeapManager, _aLocation);
+        CacheLineRef aNewModule =  CacheLine::createAttached(_aName, _aLocation);
 
         return aNewModule.get();
     }
 // -----------------------------------------------------------------------------
 
-	CacheLineRef TemplateCacheData::implNewCacheLine(const ModuleName& _aModule) CFG_UNO_THROW_RTE(  )
+	CacheLineRef TemplateCacheData::implNewCacheLine(const CacheLine::Name& _aModule) CFG_UNO_THROW_RTE(  )
 	{
-        CacheLineRef aNewModule = 
-            CacheLine::createNew(_aModule, this->internalHeapManager());
+        CacheLineRef aNewModule = CacheLine::createNew(_aModule);
 
 		internalAddModule( _aModule, aNewModule.get() );
 
@@ -459,19 +456,18 @@ namespace configmgr
 
 // -----------------------------------------------------------------------------
 
-    CacheLineRef ExtendedCacheData::doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  )
+    CacheLineRef ExtendedCacheData::doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  )
     {
         ExtendedCacheLineRef aNewModule = 
-            ExtendedCacheLine::createAttached(_aName, _rHeapManager, _aLocation);
+            ExtendedCacheLine::createAttached(_aName, _aLocation);
 
         return CacheLineRef( aNewModule.get() );
     }
 // -----------------------------------------------------------------------------
 
-	ExtendedCacheLineRef ExtendedCacheData::implNewCacheLine(const ModuleName& _aModule) CFG_UNO_THROW_RTE(  )
+	ExtendedCacheLineRef ExtendedCacheData::implNewCacheLine(const CacheLine::Name& _aModule) CFG_UNO_THROW_RTE(  )
 	{
-        ExtendedCacheLineRef aNewModule = 
-            ExtendedCacheLine::createNew(_aModule, this->internalHeapManager());
+        ExtendedCacheLineRef aNewModule = ExtendedCacheLine::createNew(_aModule);
 
 		internalAddModule( _aModule, aNewModule.get() );
 
@@ -480,7 +476,7 @@ namespace configmgr
 // -----------------------------------------------------------------------------
 
     /// gets a data segment reference for the given path - creates if necessary
-    memory::Segment * ExtendedCacheData::createDataSegment(ModuleName const & _aModule)
+    memory::Segment * ExtendedCacheData::createDataSegment(CacheLine::Name const & _aModule)
     {
         ExtendedCacheLineRef aModule = implNewCacheLine(_aModule);
 
@@ -499,18 +495,18 @@ namespace configmgr
 		
         OSL_ENSURE( xModule.is(), "ExtendedCacheData::addComponentData: No module to add the subtree to - where did the data segment come from ?");
 		
-        if (!xModule.is()) return data::TreeAddress();
+        if (!xModule.is()) return NULL;
 
 		CacheLineClientRef aClientRef( xModule );
 
         data::TreeAddress aResult = xModule->setComponentData(_aUpdateToken,_aComponentInstance.componentNodeData(), _bWithDefaults);
 
-        OSL_ASSERT(aResult.is());
+        OSL_ASSERT(aResult != NULL);
 
-		if (aResult.is()) aClientRef.keep();
+	if (aResult != NULL) aClientRef.keep();
 
-		return aResult;
-	}
+	return aResult;
+    }
 // -----------------------------------------------------------------------------
 
     void ExtendedCacheData::addPending(backend::ConstUpdateInstance const & _anUpdate) CFG_UNO_THROW_RTE(  )
@@ -529,7 +525,7 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------
     
-    std::auto_ptr<SubtreeChange> ExtendedCacheData::releasePending(ModuleName const& _aModule)
+    std::auto_ptr<SubtreeChange> ExtendedCacheData::releasePending(CacheLine::Name const& _aModule)
 	{
 		ExtendedCacheLineRef xModule = implExtended(internalGetModule(_aModule));
 
@@ -548,12 +544,13 @@ namespace configmgr
 	}
 // -----------------------------------------------------------------------------	
         
-    bool ExtendedCacheData::hasPending(ModuleName const & _aModule)
+    bool ExtendedCacheData::hasPending(CacheLine::Name const & _aModule)
     {		
-		ExtendedCacheLineRef xModule = implExtended(internalGetModule(_aModule));
+        ExtendedCacheLineRef xModule = implExtended(internalGetModule(_aModule));
 
-        return xModule.is() && xModule->hasPending();
+	return xModule.is() && xModule->hasPending();
     }
+
 // -----------------------------------------------------------------------------	
         
     void ExtendedCacheData::findPendingModules( PendingModuleList & _rPendingList )
Index: configmgr/source/treecache/cachedata.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachedata.hxx,v
retrieving revision 1.7
diff -u -p -u -r1.7 cachedata.hxx
--- configmgr/source/treecache/cachedata.hxx	8 Sep 2005 04:22:46 -0000	1.7
+++ configmgr/source/treecache/cachedata.hxx	21 Dec 2006 11:21:23 -0000
@@ -70,43 +70,38 @@ namespace configmgr
 	class CacheData			
 	{
 	public:
-        typedef CacheLine        Module;
-        typedef CacheLineRef     ModuleRef;
-        typedef CacheLine::Path     Path;
-        typedef CacheLine::Name     ModuleName;
-	public:
-		CacheData(memory::HeapManager & _rHeapManager);
+		CacheData();
 		virtual ~CacheData();
 
 		/// retrieve the module tree name for the given path
-		static ModuleName extractModuleName(Path const& _aPath);
+		static CacheLine::Name extractModuleName(CacheLine::Path const& _aPath);
 
         /// check if the given module exists already (and is not empty)
-        bool hasModule(ModuleName const & _aModule) const;
+        bool hasModule(CacheLine::Name const & _aModule) const;
         /// checks if the given module exists and has defaults available
-        bool hasModuleDefaults(memory::Accessor const & _aAccessor, ModuleName const & _aModule) const;
+        bool hasModuleDefaults(memory::Accessor const & _aAccessor, CacheLine::Name const & _aModule) const;
 
         /// creates a new data segment reference for the given path if exists
-        memory::Segment * attachDataSegment(memory::SegmentAddress const & _aLocation, ModuleName const & _aModule);
+        memory::Segment * attachDataSegment(data::TreeAddress _aLocation, CacheLine::Name const & _aModule);
         /// gets a data segment reference for the given path if it exists
-        memory::Segment * getDataSegment(ModuleName const & _aModule);
+        memory::Segment * getDataSegment(CacheLine::Name const & _aModule);
         /// gets a data segment address for the given module if it exists
-        memory::SegmentAddress getDataSegmentAddress(ModuleName const & _aModule) const;
+        data::TreeAddress getDataSegmentAddress(CacheLine::Name const & _aModule) const;
 
         /// checks whether a certain node exists in the tree
-        bool  hasNode(memory::Accessor const & _aAccessor, Path const & _aLocation) const;
+        bool  hasNode(memory::Accessor const & _aAccessor, CacheLine::Path const & _aLocation) const;
 
 		/// retrieve the given node without changing its ref count
-		data::NodeAddress   getNode(memory::Accessor const & _aAccessor, Path const & _rPath);
+		data::NodeAddress   getNode(memory::Accessor const & _aAccessor, CacheLine::Path const & _rPath);
 		/// retrieve the given template tree without changing its ref count
-		data::TreeAddress	getTemplateTree(memory::Accessor const & _aAccessor, Path const & aTemplateName ) const;
+		data::TreeAddress	getTemplateTree(memory::Accessor const & _aAccessor, CacheLine::Path const & aTemplateName ) const;
 
 		/// retrieve the subtree at _aPath and clientAcquire() it
-        data::NodeAddress acquireNode(memory::Accessor const & _aAccessor, Path const & _aPath ); 
+        data::NodeAddress acquireNode(memory::Accessor const & _aAccessor, CacheLine::Path const & _aPath ); 
 		/// retrieve the subtree at _aPath and clientAcquire() it
-        data::TreeAddress acquireModule( ModuleName const & _aModule ); 
+        data::TreeAddress acquireModule( CacheLine::Name const & _aModule ); 
 		/// clientRelease() the tree at aComponentName, and return the resulting reference count
-        CacheLine::RefCount releaseModule( ModuleName const & _aModule, bool _bKeepDeadModule = false ); 
+        CacheLine::RefCount releaseModule( CacheLine::Name const & _aModule, bool _bKeepDeadModule = false ); 
 
         bool insertDefaults( memory::UpdateAccessor& _aAccessToken, 
                              backend::NodeInstance const & _aDefaultInstance
@@ -117,27 +112,23 @@ namespace configmgr
                             backend::UpdateInstance & _anUpdate) CFG_UNO_THROW_RTE(  );
 
 		// low-level interface for cache management
-        typedef std::map<ModuleName, ModuleRef> ModuleList;
+        typedef std::map<CacheLine::Name, CacheLineRef> ModuleList;
 		ModuleList& accessModuleList() { return m_aModules; }
 
-        memory::HeapManager & getHeapManager() const { return m_rHeapManager; }
 	protected:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual CacheLineRef doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
 
-        data::TreeAddress internalGetPartialTree(memory::Accessor const & _aAccessor, Path const & _aPath ) const;
-		data::NodeAddress internalGetNode(memory::Accessor const & _aAccessor, const Path& _rPath) const;
+        data::TreeAddress internalGetPartialTree(memory::Accessor const & _aAccessor, CacheLine::Path const & _aPath ) const;
+		data::NodeAddress internalGetNode(memory::Accessor const & _aAccessor, const CacheLine::Path& _rPath) const;
 
-        ModuleRef internalAttachModule(const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
-        void internalAddModule(ModuleName const & _aName, ModuleRef const & _aModule);
+        CacheLineRef internalAttachModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
+        void internalAddModule(CacheLine::Name const & _aName, CacheLineRef const & _aModule);
 
-		ModuleRef internalGetModule(const ModuleName& _aName) const;
-		ModuleRef internalGetModule(const Path& _aLocation) const;
+		CacheLineRef internalGetModule(const CacheLine::Name& _aName) const;
+		CacheLineRef internalGetModule(const CacheLine::Path& _aLocation) const;
 
-        memory::HeapManager & internalHeapManager() { return m_rHeapManager; }
 	private:
 		ModuleList m_aModules;
-
-        memory::HeapManager & m_rHeapManager;
 	};
 ////////////////////////////////////////////////////////////////////////////////
 	/** A collection of CacheLines for templates
@@ -146,13 +137,12 @@ namespace configmgr
     class TemplateCacheData : public CacheData	
 	{
 	public:
-		TemplateCacheData(memory::HeapManager & _rHeapManager)
-        : CacheData(_rHeapManager)
+		TemplateCacheData() : CacheData()
         {
         }
 
         /// gets a data segment reference for the given path - creates if necessary 
-        memory::Segment * createDataSegment(ModuleName const & _aModule);
+        memory::Segment * createDataSegment(CacheLine::Name const & _aModule);
 
 		/** add the given template tree at the given location,
 			return the tree that is now pertinent and clientAcquire() it once
@@ -162,9 +152,9 @@ namespace configmgr
                                        ) CFG_UNO_THROW_RTE();
 
 	private:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual CacheLineRef doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
 
-		CacheLineRef implNewCacheLine(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
+		CacheLineRef implNewCacheLine(CacheLine::Name const & _aModule) CFG_UNO_THROW_RTE(  );
 	};
 //-----------------------------------------------------------------------------
 	/** A collection of CacheLines
@@ -173,13 +163,12 @@ namespace configmgr
     class ExtendedCacheData : public CacheData	
 	{
 	public:
-		ExtendedCacheData(memory::HeapManager & _rHeapManager)
-        : CacheData(_rHeapManager)
+		ExtendedCacheData() : CacheData()
         {
         }
 
         /// gets a data segment reference for the given path - creates if necessary 
-        memory::Segment * createDataSegment(ModuleName const & _aModule);
+        memory::Segment * createDataSegment(CacheLine::Name const & _aModule);
 
 		/** add the given subtree at the given location,
 			return the tree that is now pertinent and clientAcquire() it once
@@ -189,22 +178,22 @@ namespace configmgr
                                             bool _bWithDefaults
                                            ) CFG_UNO_THROW_RTE();
 
-		typedef std::vector< ModuleName >  PendingModuleList;
+		typedef std::vector< CacheLine::Name >  PendingModuleList;
         /// find the modules having pending changes
-        bool hasPending(ModuleName const & _aModule);
+        bool hasPending(CacheLine::Name const & _aModule);
         /// find the modules having pending changes
         void findPendingModules( PendingModuleList & _rPendingList );
 
 		/// add or merge the given subtreechange at the given location
 		void addPending(backend::ConstUpdateInstance const & _anUpdate) CFG_UNO_THROW_RTE(  );
 		/// remove and return pending changes for the given component
-		std::auto_ptr<SubtreeChange> releasePending(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
+		std::auto_ptr<SubtreeChange> releasePending(CacheLine::Name const & _aModule) CFG_UNO_THROW_RTE(  );
 	private:
-        virtual ModuleRef doCreateAttachedModule(memory::HeapManager & _rHeapManager, const memory::SegmentAddress & _aLocation, const ModuleName& _aName) CFG_UNO_THROW_RTE(  );
+        virtual CacheLineRef doCreateAttachedModule(data::TreeAddress _aLocation, const CacheLine::Name& _aName) CFG_UNO_THROW_RTE(  );
 
-		ExtendedCacheLineRef implNewCacheLine(ModuleName const & _aModule) CFG_UNO_THROW_RTE(  );
+		ExtendedCacheLineRef implNewCacheLine(CacheLine::Name const & _aModule) CFG_UNO_THROW_RTE(  );
 
-		ExtendedCacheLineRef implExtended(ModuleRef const & _aSimpleRef) const;
+		ExtendedCacheLineRef implExtended(CacheLineRef const & _aSimpleRef) const;
 	};
 //-----------------------------------------------------------------------------
 	
Index: configmgr/source/treecache/cachefactory.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachefactory.cxx,v
retrieving revision 1.8
diff -u -p -u -r1.8 cachefactory.cxx
--- configmgr/source/treecache/cachefactory.cxx	16 Sep 2006 15:25:24 -0000	1.8
+++ configmgr/source/treecache/cachefactory.cxx	21 Dec 2006 11:21:23 -0000
@@ -66,12 +66,10 @@ namespace configmgr
 
         if (_xBackend.is())
         {
-            memory::HeapManager & rHeap = memory::cacheHeap();
-
             rtl::Reference< backend::ICachedDataProvider > xLoader
-                = new backend::CacheController(_xBackend.get(),rHeap, _xContext);
+                = new backend::CacheController(_xBackend.get(), _xContext);
 
-            xCache.set( new TreeManager(xLoader.get(),rHeap) );
+            xCache.set( new TreeManager(xLoader.get()) );
         }
 
         return xCache;
Index: configmgr/source/treecache/cacheline.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheline.cxx,v
retrieving revision 1.9
diff -u -p -u -r1.9 cacheline.cxx
--- configmgr/source/treecache/cacheline.cxx	16 Sep 2006 15:25:36 -0000	1.9
+++ configmgr/source/treecache/cacheline.cxx	21 Dec 2006 11:21:24 -0000
@@ -80,48 +80,36 @@ namespace configmgr
 
 // -----------------------------------------------------------------------------	
 
-    CacheLine::CacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl)
-    : m_storage(_rHeapImpl  )
-    , m_base()
+    CacheLine::CacheLine(Name const & _aModuleName)
+    : m_storage()
+    , m_base(NULL)
     , m_name(_aModuleName)
     , m_nDataRefs(0)
 	{
 	}
 // -----------------------------------------------------------------------------	
-	
-    CacheLine::CacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aSegment)
-    : m_storage(_rHeapImpl,_aSegment.id)
-    , m_base( memory::Pointer(_aSegment.base) )
+
+    CacheLine::CacheLine(Name const & _aModuleName, data::TreeAddress _pSegment)
+// was memory::SegmentAddress
+    : m_storage()
+    , m_base(_pSegment)
     , m_name(_aModuleName)
     , m_nDataRefs(0)
 	{
 	}
-// -----------------------------------------------------------------------------
-
-    memory::SegmentAddress CacheLine::getDataSegmentAddress() const
-    {
-        memory::SegmentAddress aResult;
-
-        aResult.id      = m_storage.getId();
-        aResult.base    = m_base.addressValue();
-
-        return aResult;
-    }
 
 // -----------------------------------------------------------------------------
 
     void CacheLine::setBase(data::TreeAddress _base)
-	{
-        OSL_PRECOND(!m_base.is(), "CacheLine: Data base address was already set");
-        OSL_PRECOND(  _base.is(), "CacheLine: Cannot set NULL base address");
+    {
+        OSL_PRECOND(m_base == NULL, "CacheLine: Data base address was already set");
+        OSL_PRECOND( _base != NULL, "CacheLine: Cannot set NULL base address");
         m_base = _base;
     }
 // -----------------------------------------------------------------------------
    
     CacheLineRef CacheLine::createAttached( Name const & _aModuleName, 
-                                            memory::HeapManager & _rHeapImpl, 
-                                            memory::SegmentAddress const & _aSegment
+                                            data::TreeAddress _aSegment
                                           ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -129,20 +117,19 @@ namespace configmgr
 			OSL_ENSURE(false, "Cannot make a cache line without a name");
 			return NULL;
 		}
-		if (_aSegment.isNull())
+		if (_aSegment == NULL)
 		{
 			OSL_ENSURE(false, "Cannot attach a cache line to a NULL segment");
 			return NULL;
 		}
 
-		CacheLineRef xResult = new CacheLine(_aModuleName,_rHeapImpl,_aSegment);
+		CacheLineRef xResult = new CacheLine(_aModuleName,_aSegment);
 
 		return xResult;
 	}
 // -----------------------------------------------------------------------------
  
-    CacheLineRef CacheLine::createNew(  Name const & _aModuleName, 
-                                        memory::HeapManager & _rHeapImpl
+    CacheLineRef CacheLine::createNew(  Name const & _aModuleName
                                       ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -151,7 +138,7 @@ namespace configmgr
 			return NULL;
 		}
 
-		CacheLineRef xResult = new CacheLine(_aModuleName,_rHeapImpl);
+		CacheLineRef xResult = new CacheLine(_aModuleName);
 
 		return xResult;
 	}
@@ -170,23 +157,23 @@ namespace configmgr
         if (aParentSet.isValid())
             return aParentSet.getElementTree(aConfigName.getLocalName().getName()).address();
         else
-            return data::TreeAddress();
+            return NULL;
 	}
 // -----------------------------------------------------------------------------
   
     bool CacheLine::hasDefaults(memory::Accessor const & _anAccessor) const
-	{
-		if ( !m_base.is() ) return false; // cannot get defaults without data
+    {
+	if ( m_base != NULL ) return false; // cannot get defaults without data
 
         data::TreeAccessor aModuleTree(_anAccessor, m_base);
-		OSL_ASSERT( aModuleTree.isValid());
+	OSL_ASSERT( aModuleTree.isValid());
         
         return aModuleTree.data().hasDefaultsAvailable();
     }
 // -----------------------------------------------------------------------------
     data::NodeAccess CacheLine::internalGetNode(memory::Accessor const & _anAccessor, Path const& aConfigName) const
-	{
-		OSL_ENSURE( m_base.is(), "Cannot get a node from a dataless module");
+    {
+	OSL_ENSURE( m_base != NULL, "Cannot get a node from a dataless module");
 
         data::TreeAccessor aModuleTree(_anAccessor, m_base);
 		OSL_ASSERT( aModuleTree.isValid());
@@ -196,7 +183,7 @@ namespace configmgr
 
 		Path::Iterator it = aConfigName.begin();
 		OSL_ENSURE( it != aConfigName.end(), "Empty Path can't match any module");
-		OSL_ENSURE( aNode.getName() == it->getInternalName(), "Module part in config path does not match selected CacheLine");
+		OSL_ENSURE( aNode.isValid() && aNode.getName() == it->getInternalName(), "Module part in config path does not match selected CacheLine");
 
         // find child of node
         // might be done using a visitor
@@ -223,9 +210,9 @@ namespace configmgr
 		OSL_PRECOND(_aComponentInstance.data.get(), "CacheLine::insertDefaults: inserting NULL defaults !");
         OSL_PRECOND(_aComponentInstance.name == this->getModuleName(),"Data location does not match module");
 	
-        OSL_PRECOND(!base().is(), "Data is already loaded");
+        OSL_PRECOND(base() == NULL, "Data is already loaded");
 
-        if (!base().is()) // no data yet
+        if (base() == NULL) // no data yet
         {
             this->setBase( data::buildTree(_aAccessToken, _aComponentInstance.data->getName(), *_aComponentInstance.data, _bWithDefaults) );
         }
@@ -242,9 +229,9 @@ namespace configmgr
         OSL_PRECOND(_aDefaultInstance.root().isModuleRoot(), "Should have complete component to fill tree with defaults");
         OSL_PRECOND(_aDefaultInstance.root().getModuleName() == this->getModuleName(),"Data location does not match module");
 
-        OSL_PRECOND(m_base.is(), "Data must already be loaded to insert defaults");
+        OSL_PRECOND(m_base != NULL, "Data must already be loaded to insert defaults");
 
-        if (m_base.is()) 
+        if (m_base != NULL) 
         {
             data::mergeDefaults(_aAccessToken,m_base,*_aDefaultInstance.data());
         }
@@ -254,17 +241,17 @@ namespace configmgr
 // -----------------------------------------------------------------------------	
 // -----------------------------------------------------------------------------	
 
-    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl)
-    : CacheLine(_aModuleName,_rHeapImpl)
+    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName)
+    : CacheLine(_aModuleName)
     , m_pPending()
 	{
 	}
 
 // -----------------------------------------------------------------------------	
 
-    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                                            memory::SegmentAddress const & _aSegment)
-    : CacheLine(_aModuleName,_rHeapImpl,_aSegment)
+    ExtendedCacheLine::ExtendedCacheLine(Name const & _aModuleName,
+                                         data::TreeAddress _aSegment)
+    : CacheLine(_aModuleName,_aSegment)
     , m_pPending()
 	{
 	}
@@ -272,8 +259,7 @@ namespace configmgr
 // -----------------------------------------------------------------------------
   
     ExtendedCacheLineRef ExtendedCacheLine::createAttached( Name const & _aModuleName, 
-                                                            memory::HeapManager & _rHeapImpl, 
-                                                            memory::SegmentAddress const & _aSegment
+                                                            data::TreeAddress _aSegment
                                                           ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -281,20 +267,19 @@ namespace configmgr
 			OSL_ENSURE(false, "Cannot make a cache line without a name");
 			return NULL;
 		}
-		if (_aSegment.isNull())
+		if (_aSegment == NULL)
 		{
 			OSL_ENSURE(false, "Cannot attach a cache line to a NULL segment");
 			return NULL;
 		}
 
-		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_rHeapImpl,_aSegment);
+		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_aSegment);
 
 		return xResult;
 	}
 // -----------------------------------------------------------------------------
  
-    ExtendedCacheLineRef ExtendedCacheLine::createNew(  Name const & _aModuleName, 
-                                                        memory::HeapManager & _rHeapImpl
+ExtendedCacheLineRef ExtendedCacheLine::createNew(  Name const & _aModuleName
                                                       ) CFG_UNO_THROW_RTE(  )
 	{
 		if (_aModuleName.isEmpty())
@@ -303,7 +288,7 @@ namespace configmgr
 			return NULL;
 		}
 
-		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName,_rHeapImpl);
+		ExtendedCacheLineRef xResult = new ExtendedCacheLine(_aModuleName);
 
 		return xResult;
 	}
Index: configmgr/source/treecache/cacheline.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cacheline.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 cacheline.hxx
--- configmgr/source/treecache/cacheline.hxx	8 Sep 2005 04:23:30 -0000	1.5
+++ configmgr/source/treecache/cacheline.hxx	21 Dec 2006 11:21:24 -0000
@@ -51,6 +51,9 @@
 #ifndef CONFIGMGR_UTILITY_HXX_
 #include "utility.hxx"
 #endif
+#ifndef INCLUDED_SHARABLE_TREEFRAGMENT_HXX
+#include "treefragment.hxx"
+#endif
 
 #ifndef _OSL_INTERLOCK_H_
 #include <osl/interlck.h>
@@ -67,7 +70,9 @@ namespace configmgr
 ////////////////////////////////////////////////////////////////////////////////
 	using ::rtl::OUString;
 
-    namespace data { class NodeAddress; class TreeAddress; class NodeAccess; }
+    namespace data { 
+        class NodeAddress; class NodeAccess;
+    }
 ////////////////////////////////////////////////////////////////////////////////
 	/** This object represents a cache line for a single configuration tree
 	*/
@@ -81,21 +86,20 @@ namespace configmgr
 
         // create a new CacheLine for the given component name
         static rtl::Reference<CacheLine> 
-            createNew( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+            createNew( Name const & _aModuleName ); 
        
         // create a new CacheLine attached to the given memory location
         static rtl::Reference<CacheLine> 
-            createAttached( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aLocation ); 
+            createAttached( Name const & _aModuleName, data::TreeAddress _aLocation );
        
         memory::Segment * getDataSegment();
 
-        memory::SegmentAddress getDataSegmentAddress() const;
 
-        bool isEmpty() const { return m_base.isNull(); }
+        bool isEmpty() const { return m_base == NULL; }
 
         bool hasDefaults(memory::Accessor const & _aAccessor) const;
 
+        data::TreeAddress getDataSegmentAddress() const { return m_base; }
         data::TreeAddress getModuleRootAddress( ) const { return m_base; }
 
 		data::TreeAddress	getPartialTree(memory::Accessor const & _aAccessor, Path const & _aTemplatePath ) const;
@@ -123,12 +127,11 @@ namespace configmgr
     protected:
         // create a new CacheLine attached to the given memory location
         explicit 
-        CacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                    memory::SegmentAddress const & _aLocation ); 
+        CacheLine( Name const & _aModuleName, data::TreeAddress _pLocation );
        
         // create a new empty CacheLine for the given component name
         explicit 
-        CacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+        CacheLine( Name const & _aModuleName );
 
         data::NodeAccess internalGetNode(memory::Accessor const & _anAccessor, Path const & _rPath) const;
 
@@ -152,12 +155,12 @@ namespace configmgr
 	public:
         // create a new CacheLine for the given component name
         static rtl::Reference<ExtendedCacheLine> 
-            createNew( Name const & _aModuleName, memory::HeapManager & _rHeapImpl ); 
+            createNew( Name const & _aModuleName ); 
        
         // create a new CacheLine attached to the given memory location
         static rtl::Reference<ExtendedCacheLine> 
-            createAttached( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aLocation ); 
+            createAttached( Name const & _aModuleName,
+                            data::TreeAddress _aLocation );
        
     // management of pending changes
 		bool hasPending() const {return m_pPending.get() != NULL;}
@@ -168,12 +171,12 @@ namespace configmgr
     private:
         // create a new empty CacheLine for the given component name
         explicit 
-        ExtendedCacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl );
+        ExtendedCacheLine( Name const & _aModuleName );
         
         // create a new CacheLine attached to the given memory location
         explicit 
-        ExtendedCacheLine( Name const & _aModuleName, memory::HeapManager & _rHeapImpl, 
-                            memory::SegmentAddress const & _aLocation ); 
+        ExtendedCacheLine( Name const & _aModuleName, 
+                           data::TreeAddress _aLocation );
 
     private:
 		std::auto_ptr<SubtreeChange> m_pPending;
Index: configmgr/source/treecache/cachewritescheduler.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachewritescheduler.cxx,v
retrieving revision 1.8
diff -u -p -u -r1.8 cachewritescheduler.cxx
--- configmgr/source/treecache/cachewritescheduler.cxx	16 Sep 2006 15:26:03 -0000	1.8
+++ configmgr/source/treecache/cachewritescheduler.cxx	21 Dec 2006 11:21:24 -0000
@@ -147,12 +147,14 @@ void OCacheWriteScheduler::runWriter()
 // -----------------------------------------------------------------------------
 void OCacheWriteScheduler::writeOneTreeFoundByOption(RequestOptions const& _aOptions) CFG_UNO_THROW_ALL(  )
 {
-	CFG_TRACE_INFO("Writeing one cache tree for user '%s' with locale '%s'", 
-					OUSTRING2ASCII(_aOptions.getEntity()), 
-                    OUSTRING2ASCII(_aOptions.getLocale()));
+    CFG_TRACE_INFO("Writeing one cache tree for user '%s' with locale '%s'", 
+		   OUSTRING2ASCII(_aOptions.getEntity()), 
+                   OUSTRING2ASCII(_aOptions.getLocale()));
+
+    // PRE: m_aUpdateMutex of TreeMgr must be acuired
+    backend::CacheController::CacheRef aCache;
+    aCache = m_rTreeManager.m_aCacheMap.get(_aOptions);
 
-	// PRE: m_aUpdateMutex of TreeMgr must be acuired
-    CacheManager::CacheRef aCache = m_rTreeManager.m_aCacheList.get(_aOptions);
     if (aCache.is())
 	{
 		CFG_TRACE_INFO_NI("- Found matching data container  - starting write task");		
Index: configmgr/source/treecache/cachewritescheduler.hxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/cachewritescheduler.hxx,v
retrieving revision 1.5
diff -u -p -u -r1.5 cachewritescheduler.hxx
--- configmgr/source/treecache/cachewritescheduler.hxx	8 Sep 2005 04:24:23 -0000	1.5
+++ configmgr/source/treecache/cachewritescheduler.hxx	21 Dec 2006 11:21:24 -0000
@@ -73,7 +73,6 @@ namespace configmgr
 	class OCacheWriteScheduler
 	{
 		typedef std::set< RequestOptions, lessRequestOptions > CacheWriteList; // fire and forget!
-        typedef backend::CacheController CacheManager;
 
 		class Timer : public vos::OTimer
 		{
@@ -98,18 +97,16 @@ namespace configmgr
 		};
 		friend void Timer::onShot();
 	private:
-		mutable osl::Mutex	m_aMutex;
-		vos::ORef<Timer>	m_xTimer;
-		CacheManager&		m_rTreeManager;
-
-		CacheWriteList		m_aWriteList;
-
-        TimeInterval m_aWriteInterval;		
+	    mutable osl::Mutex	      m_aMutex;
+	    vos::ORef<Timer>	      m_xTimer;
+	    backend::CacheController &m_rTreeManager;
+	    CacheWriteList	      m_aWriteList;
+	    TimeInterval	      m_aWriteInterval;
 		
 	public:
 	//-------- Construction and destruction -----------------------------------
 		explicit
-		OCacheWriteScheduler(CacheManager& _rTreeManager, TimeInterval const& _aWriteInterval) 
+		OCacheWriteScheduler(backend::CacheController& _rTreeManager, TimeInterval const& _aWriteInterval) 
 			: m_rTreeManager(_rTreeManager)
 			, m_aWriteInterval(_aWriteInterval)			
 		{
Index: configmgr/source/treecache/disposetimer.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/disposetimer.cxx,v
retrieving revision 1.22
diff -u -p -u -r1.22 disposetimer.cxx
--- configmgr/source/treecache/disposetimer.cxx	16 Sep 2006 15:26:19 -0000	1.22
+++ configmgr/source/treecache/disposetimer.cxx	21 Dec 2006 11:21:24 -0000
@@ -205,10 +205,10 @@ void OTreeDisposeScheduler::onTimerShot(
 // this really should be a member of the TreeManager (see TreeManager::disposeOne etc.)
 TimeStamp OTreeDisposeScheduler::runDisposer(TimeStamp const& _aActualTime)
 {
-	TimeStamp aNextTime = TimeStamp::never();
-	OSL_ASSERT(aNextTime.isNever());
+    TimeStamp aNextTime = TimeStamp::never();
+    OSL_ASSERT(aNextTime.isNever());
 
-	osl::ClearableMutexGuard aGuard( m_rTreeManager.m_aCacheList.mutex() );
+    osl::ClearableMutexGuard aGuard( m_rTreeManager.m_aCacheMap.mutex() );
 
     Task aTask = this->getTask( _aActualTime, aNextTime );
     if (aTask.first)
@@ -219,7 +219,7 @@ TimeStamp OTreeDisposeScheduler::runDisp
 						OUSTRING2ASCII(rTaskOptions.getEntity()),
                         OUSTRING2ASCII(rTaskOptions.getLocale()));
 
-        CacheManager::CacheRef aCache = m_rTreeManager.m_aCacheList.get(rTaskOptions);
+        CacheManager::CacheRef aCache = m_rTreeManager.m_aCacheMap.get(rTaskOptions);
         if (aCache.is())
 		{
 			CFG_TRACE_INFO_NI("- Found matching data container (TreeInfo) - collecting data");
Index: configmgr/source/treecache/invalidatetree.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/invalidatetree.cxx,v
retrieving revision 1.21
diff -u -p -u -r1.21 invalidatetree.cxx
--- configmgr/source/treecache/invalidatetree.cxx	16 Sep 2006 15:26:33 -0000	1.21
+++ configmgr/source/treecache/invalidatetree.cxx	21 Dec 2006 11:21:24 -0000
@@ -193,11 +193,11 @@ void CacheController::invalidateComponen
 
 CacheLocation CacheController::refreshComponent(ComponentRequest const & _aRequest) CFG_UNO_THROW_ALL()
 {
-    if (m_bDisposing) return CacheLocation();
+    if (m_bDisposing) return NULL;
 
     CacheRef aCache = this->getCacheAlways(_aRequest.getOptions());
 
-    if (!aCache.is()) return CacheLocation();
+    if (!aCache.is()) return NULL;
 	
     osl::MutexGuard aCacheLineGuard(aCache->mutex());
 	
@@ -211,21 +211,22 @@ CacheLocation CacheController::refreshCo
     NodeResult aLoadedNodeInstance(aNodeInstance) ;
     
     CacheLocation aResult;
-	if (aLoadedNodeInstance.is())
-	{
+    if (aLoadedNodeInstance.is())
+    {
         Name aModuleName = aLoadedNodeInstance->root().getModuleName();
 
         memory::UpdateAccessor aChangingAccessor( aCache->getDataSegment(aModuleName) ); 
         OSL_ENSURE(aChangingAccessor.is(), "No existing cache line for tree being refreshed");
 
+#warning FIXME: get acquire / releases right etc. - dont screw that up ...
         data::TreeAddress aCachedTreeAddress = aCache->acquireModule(aModuleName);
 
-        aResult.segment = aCache->getDataSegmentAddress(aModuleName);
-        aResult.address = aCachedTreeAddress.addressValue();
+	aResult = CacheLocation( aCache->getDataSegmentAddress(aModuleName) );
+//				 aCachedTreeAddress );
 
-        if (aCachedTreeAddress.is())
+        if (aCachedTreeAddress != NULL)
         try
-		{
+	{
             std::auto_ptr<SubtreeChange> aTreeChanges;
             data::NodeAddress aRootAddress;
 
@@ -259,7 +260,7 @@ CacheLocation CacheController::refreshCo
 			aCache->releaseModule(aModuleName);
             throw;
         }
-	}
+    }
     return aResult;
 }
 
Index: configmgr/source/treecache/treemanager.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treecache/treemanager.cxx,v
retrieving revision 1.11
diff -u -p -u -r1.11 treemanager.cxx
--- configmgr/source/treecache/treemanager.cxx	16 Sep 2006 15:27:00 -0000	1.11
+++ configmgr/source/treecache/treemanager.cxx	21 Dec 2006 11:21:24 -0000
@@ -241,10 +241,10 @@ ConfigChangeBroadcastHelper* TreeManager
 
 
 // -------------------------------------------------------------------------
-TreeManager::TreeManager(BackendCacheRef const & _xBackend, memory::HeapManager & _rCacheHeapManager) 
+TreeManager::TreeManager(BackendCacheRef const & _xBackend) 
 : m_xCacheController(_xBackend)
 , m_aCacheList()
-, m_aTemplates(new CacheData(_rCacheHeapManager))
+, m_aTemplates(new CacheData())
 , m_bEnableAsync(true)
 {
     OSL_PRECOND(_xBackend.is(),"Trying to create a TreeManager without a backend");
@@ -293,12 +293,6 @@ void TreeManager::disposeBackendCache() 
 
 // -------------------------------------------------------------------------
 
-memory::HeapManager & TreeManager::getCacheHeapManager() const
-{
-    return m_aTemplates.get()->getHeapManager();
-}
-// -------------------------------------------------------------------------
-
 TreeManager::CacheRef TreeManager::getCacheAlways(RequestOptions const & _aOptions)
 {
     osl::MutexGuard aGuard( m_aCacheList.mutex() );
@@ -306,7 +300,7 @@ TreeManager::CacheRef TreeManager::getCa
     CacheRef aResult = m_aCacheList.get(_aOptions);
     if (!aResult.is())
     {
-        CacheRef aNewCache( new Cache(getCacheHeapManager(), ConfigChangeBroadcaster::newBroadcastHelper()) );
+        CacheRef aNewCache( new Cache(ConfigChangeBroadcaster::newBroadcastHelper()) );
         aResult = m_aCacheList.insert(_aOptions,aNewCache);
     }
     return aResult;
@@ -329,37 +323,37 @@ memory::Segment* TreeManager::getDataSeg
 // -------------------------------------------------------------------------
 
 data::NodeAccess TreeManager::requestSubtree(AbsolutePath const& aSubtreePath, 
-									            const RequestOptions& _aOptions)  
-                                             CFG_UNO_THROW_ALL(  )
+					     const RequestOptions& _aOptions)  
+						CFG_UNO_THROW_ALL()
 {
-	CFG_TRACE_INFO("TreeManager: request for subtree '%s'", OUSTRING2ASCII(aSubtreePath.toString()));
+    CFG_TRACE_INFO("TreeManager: request for subtree '%s'", OUSTRING2ASCII(aSubtreePath.toString()));
 
     CacheRef aCache = getCacheAlways(_aOptions);
-	OSL_ENSURE(aCache.is(),"TreeManager: Cannot create cache access for loading node");
+    OSL_ENSURE(aCache.is(),"TreeManager: Cannot create cache access for loading node");
 
     data::Accessor aAccessor(NULL);
     
     if (!aCache->hasModule(aSubtreePath))
     {
-		CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the node");
+	CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the node");
         backend::ComponentRequest aQuery( aSubtreePath.getModuleName(), _aOptions );
 
         backend::CacheLocation aLoadedLocation = getCacheLoader()->loadComponent(aQuery);
-        if (aLoadedLocation.isNull())
+        if (aLoadedLocation == NULL)
         {
-		    CFG_TRACE_WARNING_NI("TreeManager: requested component not found");
+	    CFG_TRACE_WARNING_NI("TreeManager: requested component not found");
             throw com::sun::star::container::
                     NoSuchElementException( MAKEUSTRING("Requested component not found"), NULL);
         }
 
-		CFG_TRACE_INFO_NI("TreeManager: attaching loaded cache segment ");
+	CFG_TRACE_INFO_NI("TreeManager: attaching loaded cache segment ");
 
-        aAccessor = data::Accessor(aCache->attachDataSegment(aLoadedLocation.segment,aSubtreePath));
+        aAccessor = data::Accessor(aCache->attachDataSegment(aLoadedLocation,aSubtreePath));
         OSL_ENSURE(aAccessor.is(),"Cannot attach to loaded component");
     }
     else
-	{ 
-	    CFG_TRACE_INFO_NI("TreeManager: found node in cache");
+    { 
+	CFG_TRACE_INFO_NI("TreeManager: found node in cache");
         if (_aOptions.isRefreshEnabled())
         {
              backend::ComponentRequest aRequest( aSubtreePath.getModuleName(), _aOptions );
@@ -368,7 +362,6 @@ data::NodeAccess TreeManager::requestSub
        
         aAccessor = data::Accessor(aCache->getDataSegment(aSubtreePath));
         OSL_ENSURE(aAccessor.is(),"Cannot get accessor for existing component");
-        
     }
 
     data::NodeAddress aResultAddress = aCache->acquireNode(aAccessor,aSubtreePath);
@@ -380,28 +373,28 @@ data::NodeAccess TreeManager::requestSub
 void TreeManager::fetchSubtree(AbsolutePath const& aSubtreePath, const RequestOptions&  ) CFG_NOTHROW()
 {
     (void) aSubtreePath; // avoid warning about unused parameter
-	CFG_TRACE_WARNING("TreeManager: Prefetching not implemented. (Request to prefetch component %s.", OUSTRING2ASCII(aSubtreePath.toString()));
+    CFG_TRACE_WARNING("TreeManager: Prefetching not implemented. (Request to prefetch component %s.", OUSTRING2ASCII(aSubtreePath.toString()));
 }
 
 // -------------------------------------------------------------------------
 sal_Bool TreeManager::fetchDefaultData( memory::UpdateAccessor& _aAccessToken, 
                                         AbsolutePath const& aSubtreePath, 
-									    const RequestOptions& _aOptions
-									  ) CFG_UNO_THROW_ALL(  )
+					const RequestOptions& _aOptions
+					) CFG_UNO_THROW_ALL()
 {
-	CFG_TRACE_INFO("tree manager: checking the cache for defaults");
+    CFG_TRACE_INFO("tree manager: checking the cache for defaults");
 
     CacheRef aCache = m_aCacheList.get(_aOptions);
 
     if (!aCache.is())
     {
-	    OSL_ENSURE(aCache.is(),"TreeManager: Cache access to fetch defaults for does not exist ! Where does the node access come from ?");
+	OSL_ENSURE(aCache.is(),"TreeManager: Cache access to fetch defaults for does not exist ! Where does the node access come from ?");
         return false;
     }
 
     if (aCache->hasModuleDefaults(_aAccessToken.accessor(),aSubtreePath))
     {
-		CFG_TRACE_INFO_NI("TreeManager: found default data in cache");
+	CFG_TRACE_INFO_NI("TreeManager: found default data in cache");
         return true;
     }
 
@@ -412,15 +405,15 @@ sal_Bool TreeManager::fetchDefaultData( 
     backend::NodeResult aDefaults = getCacheLoader()->getDirectDataProvider().getDefaultData( aRequest );
 
     if (!aDefaults.is())
-	{
-		CFG_TRACE_INFO_NI("TreeManager: merging loaded defaults into cache");
+    {
+	CFG_TRACE_INFO_NI("TreeManager: merging loaded defaults into cache");
         return aCache->insertDefaults(_aAccessToken,aDefaults.instance());
-	}
-	else
-	{
+    }
+    else
+    {
         CFG_TRACE_WARNING_NI("TreeManager: cannot load defaults: no data available or not supported");
         return false;
-	}
+    }
 }
 
 // -------------------------------------------------------------------------
@@ -429,7 +422,7 @@ std::auto_ptr<ISubtree> TreeManager::req
 										               ) CFG_UNO_THROW_ALL(  )
 {
     // to do: check cache for existing default data (?!)
-	CFG_TRACE_INFO_NI("TreeManager: loading default data directly");
+    CFG_TRACE_INFO_NI("TreeManager: loading default data directly");
 
     backend::NodeRequest aRequest(aSubtreePath,_aOptions);
 
@@ -453,7 +446,7 @@ AbsolutePath TreeManager::encodeTemplate
     aResult.prepend(aTemplateModule);
 //    aResult.prepend(aTemplateRoot);
 
-	return AbsolutePath(aResult);
+    return AbsolutePath(aResult);
 }
         
 // -------------------------------------------------------------------------
@@ -476,33 +469,33 @@ data::TreeAccessor TreeManager::requestT
     {
         aTemplatesAccessor.clear();
 
-		CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the template");
+	CFG_TRACE_INFO_NI("TreeManager: cache miss. going to load the template");
         backend::TemplateRequest aQuery( _rName, _rModule );
 
         backend::CacheLocation aLoadedLocation = getCacheLoader()->loadTemplate(aQuery);
-        if (aLoadedLocation.isNull())
+        if (aLoadedLocation == NULL)
         {
-		    CFG_TRACE_ERROR_NI("TreeManager: requested template module not found");
+	    CFG_TRACE_ERROR_NI("TreeManager: requested template module not found");
             throw com::sun::star::container::
                     NoSuchElementException( MAKEUSTRING("Requested template module not found"), NULL);
         }
 
-		CFG_TRACE_INFO_NI("TreeManager: attaching to loaded template module");
+	CFG_TRACE_INFO_NI("TreeManager: attaching to loaded template module");
 
-        aTemplatesAccessor = data::Accessor(getTemplates().attachDataSegment(aLoadedLocation.segment,aCacheModule));
+        aTemplatesAccessor = data::Accessor(getTemplates().attachDataSegment(aLoadedLocation,aCacheModule));
         OSL_ENSURE(aTemplatesAccessor.is(),"Cannot attach to loaded component");
 
         // create a client ref count on the template module
         getTemplates().acquireNode(aTemplatesAccessor,aTemplateLocation);
     }
     else
-	{ 
-		CFG_TRACE_INFO_NI("TreeManager: template module found in cache");
+    { 
+	CFG_TRACE_INFO_NI("TreeManager: template module found in cache");
         OSL_ENSURE(aTemplatesAccessor.is(),"No accessor for existing data ?");
     }
 
     data::TreeAddress aTemplateAddr = getTemplates().getTemplateTree(aTemplatesAccessor,aTemplateLocation);
-	if (aTemplateAddr.isNull())
+    if (aTemplateAddr == NULL)
     {
 		CFG_TRACE_ERROR_NI("TreeManager: template not found in module");
 		throw com::sun::star::container::
Index: configmgr/source/treemgr/setnodeimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/setnodeimpl.cxx,v
retrieving revision 1.24
diff -u -p -u -r1.24 setnodeimpl.cxx
--- configmgr/source/treemgr/setnodeimpl.cxx	16 Sep 2006 15:31:34 -0000	1.24
+++ configmgr/source/treemgr/setnodeimpl.cxx	21 Dec 2006 11:21:24 -0000
@@ -870,7 +870,7 @@ Element SetNodeImpl::makeAdditionalEleme
 
     data::TreeAddress aAddedTree = aAddNodeChange.getInsertedTree();
 	// need 'unsafe', because ownership would be gone when notifications are sent
-	if (aAddedTree.is())
+	if (aAddedTree != NULL)
 	{
 		// OSL_ENSURE( pNode->ISA(ISubtree), "Type mismatch when adjusting to update: value element found in tree set");
 
Index: configmgr/source/treemgr/treeimpl.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/treeimpl.cxx,v
retrieving revision 1.30
diff -u -p -u -r1.30 treeimpl.cxx
--- configmgr/source/treemgr/treeimpl.cxx	16 Sep 2006 15:32:13 -0000	1.30
+++ configmgr/source/treemgr/treeimpl.cxx	21 Dec 2006 11:21:24 -0000
@@ -964,7 +964,7 @@ void ElementTreeImpl::detachFrom(data::S
             memory::UpdateAccessor aTargetAccessor(pTargetSpace);
 
             TreeAddress aOldElement = data::SetNodeAccess::removeElement(aTargetAccessor,aOwningSet.address(), aElementName );
-		    OSL_ENSURE(aOldElement.is(),"ERROR: Detached node not found in the given subtree");
+	    OSL_ENSURE(aOldElement != NULL,"ERROR: Detached node not found in the given subtree");
 
             TreeAccessor::freeTree(aTargetAccessor,aOldElement);
         }
Index: configmgr/source/treemgr/viewstrategy.cxx
===================================================================
RCS file: /cvs/util/configmgr/source/treemgr/viewstrategy.cxx,v
retrieving revision 1.10
diff -u -p -u -r1.10 viewstrategy.cxx
--- configmgr/source/treemgr/viewstrategy.cxx	16 Sep 2006 15:33:07 -0000	1.10
+++ configmgr/source/treemgr/viewstrategy.cxx	21 Dec 2006 11:21:24 -0000
@@ -193,15 +193,8 @@ namespace configmgr
 //-----------------------------------------------------------------------------
         data::NodeAddress::DataType * ViewStrategy::implAccessForUpdate(data::NodeAccessRef const & _aNode)
         {
-            if (memory::Segment * pUpdatableSegment = doGetDataSegmentForUpdate())
-            {
-                void * p = memory::UpdateAccessor(pUpdatableSegment).validate(_aNode.rawAddress());
-             
-                OSL_ASSERT(const_cast<const void *>(p) == _aNode.getDataPtr());
-
-                return static_cast<data::NodeAddress::DataType*>(p);
-            }
-
+            if (doGetDataSegmentForUpdate())
+                return (data::NodeAddress::DataType *)_aNode.getDataPtr();
             else
                 return NULL;
         }
Index: configmgr/workben/makefile.mk
===================================================================
RCS file: /cvs/util/configmgr/workben/makefile.mk,v
retrieving revision 1.4
diff -u -p -u -r1.4 makefile.mk
--- configmgr/workben/makefile.mk	8 Mar 2006 14:02:03 -0000	1.4
+++ configmgr/workben/makefile.mk	21 Dec 2006 11:21:24 -0000
@@ -55,35 +55,7 @@ USE_LDUMP2=TRUE
 # CFGDEMO
 #
 APP1TARGET=	cfgdemo
-APP1OBJS=\
-	$(OBJ)$/treetests.obj \
-	$(SLO)$/xmltreebuilder.obj \
-	$(SLO)$/xmlformater.obj \
-	$(SLO)$/attributes.obj \
-	$(SLO)$/changes.obj \
-	$(SLO)$/confname.obj \
-	$(SLO)$/typeconverter.obj \
-	$(SLO)$/synchronize.obj	\
-	$(SLO)$/cmtree.obj \
-	$(SLO)$/cmtreemodel.obj \
-	$(SLO)$/localsession.obj \
-	$(SLO)$/mergeupdates.obj \
-	$(SLO)$/oslstream.obj \
-	$(SLO)$/saxtools.obj \
-	$(SLO)$/configsession.obj \
-	$(SLO)$/strimpl.obj \
-	$(SLO)$/tracer.obj \
-	$(SLO)$/confchangesset.obj \
-	$(SLO)$/filehelper.obj \
-	$(SLO)$/strconverter.obj \
-	$(SLO)$/updatedom.obj \
-	$(SLO)$/valuehandler.obj \
-	$(SLO)$/dataconverter.obj \
-
-#	$(OBJ)$/cmxmlexport.obj \
-#	$(OBJ)$/cmxmlimport.obj \
-
-#APP1RES=	$(RES)$/ucbdemo.res
+APP1OBJS= $(OBJ)$/testapp.obj 
 
 APP1STDLIBS=\
 	$(SALLIB) \
