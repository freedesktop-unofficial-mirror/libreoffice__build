--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ svx/source/msfilter/msvbasicdir.hxx	2007-06-29 16:21:42.000000000 +0100
@@ -0,0 +1,95 @@
+#ifndef _MSVBASICDIR_HXX
+#define _MSVBASICDIR_HXX
+
+#ifdef _SOLAR_H
+#include <tools/solar.h>
+#endif
+#ifndef _TOOLS_DEBUG_HXX
+#include <tools/debug.hxx>
+#endif
+#ifndef _SVSTOR_HXX //autogen
+#include <sot/storage.hxx>
+#endif
+#ifndef _DYNARY_HXX
+#include <tools/dynary.hxx>
+#endif
+#ifndef __SGI_STL_VECTOR
+#include <vector>
+#endif
+#include <map>
+#include "svxmsbas.hxx"
+namespace MSLZSS {
+    void	        compressString( SvStream *pStream, const rtl::OString &rString );
+    void	        compressStream( SvStream *pStream, SvStream *pInStream );
+    SvMemoryStream *decompressAsStream( SvStream *pStream, sal_uInt32 nOffset, sal_uInt32 *pCompressedLength = NULL, sal_uInt32 *pLength = NULL );
+    rtl::OString    decompressAsString( SvStream *pStream, sal_uInt32 nOffset, sal_uInt32 *pCompressedLength = NULL, sal_uInt32 *pLength = NULL );
+};
+
+// An unset strings is 0 length & looks like a flag ...
+
+#define VBA_DIR_LONG_START			0x01 // seemingly always 1
+#define VBA_DIR_LONG_ENCODING_1		0x02 // normally 0x409
+#define VBA_DIR_SHORT_VERSION_1		0x03 // seemingly always 0x4e4
+#define VBA_DIR_STR_PROJECT_NAME	0x04
+#define VBA_DIR_STR_DESCRIPTION		0x05
+#define VBA_DIR_STR_HELP_FILENAME	0x06
+#define VBA_DIR_LONG_HELP_CTXT_ID	0x07
+#define VBA_DIR_LONG_UNKNOWN_0x08	0x08
+#define VBA_DIR_OP_PAPER_SIZE		0x09
+#define VBA_DIR_STR_COND_COMP_ARGS	0x0c
+#define VBA_DIR_EXTERNAL_LINKAGE	0x0d
+#define VBA_DIR_SHORT_OBJECT_COUNT	0x0f
+#define VBA_DIR_FLAG_END			0x10 // ?
+#define VBA_DIR_SHORT_UNKNOWN_0x13	0x13
+#define VBA_DIR_LONG_ENCODING_2		0x14 // normally 0x409
+#define VBA_DIR_STR_STREAM_TYPE		0x16
+#define VBA_DIR_STR_USER_NAME		0x19
+#define VBA_DIR_STR_STREAM_NAME		0x1a
+#define VBA_DIR_STR_UNKNOWN_0x1c	0x1c
+#define VBA_DIR_LONG_UNKNOWN_0x1e	0x1e
+#define VBA_DIR_FLAG_MACRO			0x21
+#define VBA_DIR_FLAG_DOCUMENT		0x22
+#define VBA_DIR_CLASS_MODULE		0x28
+#define VBA_DIR_SHORT_UNKNOWN_0x2c	0x2c
+#define VBA_DIR_OBJECT_END			0x2b
+#define VBA_DIR_LONG_VBA_OFFSET		0x31
+#define VBA_DIR_USTR_STREAM_NAME	0x32
+#define VBA_DIR_USTR_COND_COMP_ARGS	0x3c
+#define VBA_DIR_USTR_HELP_FILENAME	0x3d
+#define VBA_DIR_USTR_STREAM_TYPE	0x3e
+#define VBA_DIR_USTR_DESCRIPTION	0x40
+#define VBA_DIR_USTR_USER_NAME		0x47
+#define VBA_DIR_USTR_UNKNOWN_0x48	0x48
+typedef ::std::map< UniString, sal_Int16 > ModuleTypeHash;
+class VBADir
+{
+private:
+    SvStorageRef mxStorage;
+    SvStorageRef mxProjectStorage;
+    // #117718# member map of module names to types of module
+    ModuleTypeHash mhModHash;
+    bool mbMac; 
+    bool mbInited; 
+    rtl_TextEncoding meCharSet;
+    void deleteSRPs();
+    void clobberProject();
+    rtl::OUString stripOptions( const rtl::OUString &rSource, sal_Int16 rType );
+    void writeModule( const rtl::OUString &rName, const rtl::OUString &rSource, sal_Int16 rType );
+    void init();
+    //0 for failure, anything else for success, determines encoding, 
+    //product, if this is a mac doc etc.
+    int Read_VBA_PROJECT();
+    //reads the PROJECT stream to determine Module types
+    void Read_VBAPROJECT();
+public:
+    VBADir( SvStorageRef &xProjectStorage, SvStorageRef &xStorage );
+    ~VBADir();
+
+    bool readBasic( SfxObjectShell &rDocSh, bool bComment, bool bStripped );
+    bool writeBasic( SfxObjectShell &rDocSh );
+    // #117718# member map of module names to types of module
+    sal_Int16 GetModuleType( const UniString& rModuleName ) const;
+};
+
+
+#endif // _MSVBASICDIR_HXX
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ svx/source/msfilter/msvbasicdir.cxx	2007-06-29 16:23:34.000000000 +0100
@@ -0,0 +1,1521 @@
+#include <string.h> 	// memset(), ...
+#ifndef UNX
+#include <io.h> 		// access()
+#endif
+#ifndef _SFX_OBJSH_HXX
+#include <sfx2/objsh.hxx>
+#endif
+#ifndef _SFXAPP_HXX
+#include <sfx2/app.hxx>
+#endif
+#ifndef _BASMGR_HXX
+#include <basic/basmgr.hxx>
+#endif
+#ifndef _SB_SBMOD_HXX
+#include <basic/sbmod.hxx>
+#endif
+#ifndef _SVXERR_HXX
+#include <svxerr.hxx>
+#endif
+#ifndef _SOT_STORINFO_HXX
+#include <sot/storinfo.hxx>
+#endif
+#ifndef _MSVBASIC_HXX
+#include "msvbasicdir.hxx"
+#endif
+#ifndef _RTL_TENCINFO_H
+#include <rtl/tencinfo.h>   //rtl_getTextEncodingFromWindowsCodePage
+#endif
+
+#include <com/sun/star/container/XNameContainer.hpp>
+#include <com/sun/star/script/XLibraryContainer.hpp>
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/i18n/TransliterationModules.hpp>
+#include <com/sun/star/embed/XStorage.hpp>
+
+#include <vcl/svapp.hxx>
+#include <unotools/textsearch.hxx>
+#include <fstream>
+using namespace com::sun::star::container;
+using namespace com::sun::star::script;
+using namespace com::sun::star::script::ModuleType;
+using namespace com::sun::star::uno;
+using namespace com::sun::star::lang;
+using namespace com::sun::star::embed;
+using namespace rtl;
+
+#define nWINDOWLEN 4096
+#define STANDARD RTL_CONSTASCII_USTRINGPARAM("Standard")
+
+static unsigned int
+getShift( sal_uInt32 nPos )
+{
+    if (nPos <= 0x80) {
+        if (nPos <= 0x20)
+            return (nPos <= 0x10) ? 12 : 11;
+        else
+            return (nPos <= 0x40) ? 10 : 9;
+    } else {
+        if (nPos <= 0x200)
+            return (nPos <= 0x100) ? 8 : 7;
+        else if (nPos <= 0x800)
+            return (nPos <= 0x400) ? 6 : 5;
+        else
+            return 4;
+    }
+}
+
+struct CompressBuffer {
+    // buffer for match making
+    UINT8 mpBuffer[ nWINDOWLEN ];
+    sal_Int32 mnLength;
+
+    // output buffering
+    SvStream   *mpOutput;
+    UINT8       mnMask;
+    UINT8       maBlock[16];
+    UINT8		mnBlockLength;
+    UINT8		mnShift;
+
+    CompressBuffer( SvStream *pOutput )
+    {
+        memset( mpBuffer, 0, sizeof( mpBuffer ) );
+        mnLength = 0;
+        mnBlockLength = 0;
+        mpOutput = pOutput;
+        mnShift  = 0;
+        mnMask   = 0;
+    }
+
+    void
+    flush()
+    {
+        if( mnBlockLength ) {
+            *mpOutput << mnMask;
+            mpOutput->Write( maBlock, mnBlockLength );
+            mnBlockLength = 0;
+            mnMask = mnShift = 0;
+        }
+    }
+
+    void outputData( UINT8 *pData, bool bCompressed )
+    {
+        if (bCompressed)
+        {
+            mnMask |= 1 << mnShift;
+            maBlock[ mnBlockLength++ ] = pData[0];
+            maBlock[ mnBlockLength++ ] = pData[1];
+        }
+        else
+            maBlock[ mnBlockLength++ ] = pData[0];
+
+        if( ++mnShift == 8)
+            flush();
+    }
+
+    void
+    outputMatch( sal_uInt32 nCurPos, sal_uInt32 nMatchPos, sal_uInt32 nLength )
+    {
+        sal_uInt32 nShift, nToken, nDistance;
+        UINT8 aData[2];
+
+        nShift = getShift( nCurPos );
+
+        nDistance = nCurPos - nMatchPos - 1;
+        nToken = (nDistance << nShift) + ((nLength - 3) & ((1<<nShift)-1));
+
+        aData[0] = nToken & 0xff;
+        aData[1] = nToken >> 8;
+
+        outputData( aData, TRUE );
+    }
+
+    sal_Int32 /* Unbelievably slow, but ... */
+    findMatch (sal_Int32 nPos, sal_Int32 &rnLen)
+    {
+        sal_Int32 i;
+        sal_Int32 max_match = (1 << getShift( nPos ) ) - 1;
+
+        /* FIXME: the MS impl. does different to a linear search here
+           and is not very good at this either; is happy to get much
+           worse matches; perhaps some single-entry match lookup table ?
+           it seems to ~regularly truncate strings, and get earlier
+           / later matches of equivalent length with no predictability
+           ( hashing ? ).
+        */
+        for (i = nPos - 1; i >= 0; i--)
+        {
+            sal_Int32 j;
+
+            for (j = 0; j < mnLength - nPos && j < nPos; j++)
+                if (mpBuffer[nPos + j] != mpBuffer[i + j])
+                    break;
+
+            if (j >= 3)
+            {
+                if( j > max_match )
+                    j = max_match;
+                rnLen = j;
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    bool
+    readBlock( SvStream *pInStream )
+    {
+        mnLength = pInStream->Read( mpBuffer, nWINDOWLEN );
+        return mnLength > 0;
+    }
+};
+
+static void
+compressBlock( CompressBuffer &rBuffer )
+{
+    sal_Int32 nPos, nMatchLen;
+    int   nMatchPos;
+
+    for (nPos = 0; nPos < rBuffer.mnLength;)
+    {
+        if ((nMatchPos = rBuffer.findMatch( nPos, /* ref */ nMatchLen )) >= 0)
+        {
+            rBuffer.outputMatch( nPos, nMatchPos, nMatchLen );
+            nPos += nMatchLen;
+        }
+        else
+            rBuffer.outputData( &(rBuffer.mpBuffer[ nPos++ ]), FALSE );
+    }
+}
+namespace MSLZSS {
+
+void compressStream( SvStream *pStream, SvStream *pInStream )
+{
+    sal_uInt32 nStartPos = pStream->Tell();
+    pStream->Seek( nStartPos + 3 );
+    CompressBuffer aBuffer( pStream );
+
+    while( aBuffer.readBlock( pInStream ) )
+            compressBlock( aBuffer );
+    aBuffer.flush();
+
+    sal_uInt32 nSize = pStream->Tell() - nStartPos;
+    sal_uInt32 nLength = nSize - 3 - 1;
+
+    if( nLength > 0x0c0c ) /* TESTME: really right ? */
+        nLength = 0x0c0c;  /* follow-on chunk sizes ? */
+
+    pStream->Seek( nStartPos );
+    *pStream << UINT8(0x01);
+    *pStream << UINT8( nLength & 0xff);
+    *pStream << UINT8( nLength >> 8 | 0xb0 );
+}
+
+void
+compressString( SvStream *pStream, const OString &rString )
+{
+    SvMemoryStream aStream( (void *) rString.getStr(), rString.getLength(), STREAM_READ );
+    compressStream( pStream, &aStream );
+}
+
+SvMemoryStream *decompressAsStream( SvStream *pStream, sal_uInt32 nOffset, sal_uInt32 *pCompressedLength, sal_uInt32 *pLength )
+{
+    SvMemoryStream *pResult;
+
+    pResult = new SvMemoryStream();
+    
+    sal_uInt8 nLeadbyte;
+    unsigned int nPos = 0;
+    int nLen, nDistance, nShift, nClean=1;
+    sal_uInt8 aHistory[ nWINDOWLEN ];
+
+    pStream->Seek( nOffset + 3 );
+
+    while( pStream->Read( &nLeadbyte, 1 ) )
+    {
+        for(int nMask=0x01; nMask < 0x100; nMask = nMask<<1)
+        {
+            // we see if the leadbyte has flagged this location as a dataunit
+            // which is actually a token which must be looked up in the history
+            if( nLeadbyte & nMask )
+            {
+                sal_uInt16 nToken;
+
+                *pStream >> nToken;
+
+                if (nClean == 0)
+                    nClean=1;
+
+                //For some reason the division of the token into the length
+                //field of the data to be inserted, and the distance back into
+                //the history differs depending on how full the history is
+                nShift = getShift( nPos % nWINDOWLEN );
+
+                nLen = (nToken & ((1<<nShift) - 1)) + 3;
+                nDistance = nToken >> nShift;
+
+                //read the len of data from the history, wrapping around the
+                //nWINDOWLEN boundary if necessary data read from the history
+                //is also copied into the recent part of the history as well.
+                for (int i = 0; i < nLen; i++)
+                {
+                    unsigned char c;
+                    c = aHistory[(nPos-nDistance-1) % nWINDOWLEN];
+                    aHistory[nPos % nWINDOWLEN] = c;
+                    nPos++;
+                }
+            }
+            else
+            {
+                // special boundary case code, not guarantueed to be correct
+                // seems to work though, there is something wrong with the
+                // compression scheme (or maybe a feature) where when the data
+                // ends on a nWINDOWLEN boundary and the excess bytes in the 8
+                // dataunit list are discarded, and not interpreted as tokens
+                // or normal data.
+                if ((nPos != 0) && ((nPos % nWINDOWLEN) == 0) && (nClean))
+                {
+                    pStream->SeekRel(2);
+                    nClean=0;
+                    pResult->Write( aHistory, nWINDOWLEN );
+                    break;
+                }
+                //This is the normal case for when the data unit is not a
+                //token to be looked up, but instead some normal data which
+                //can be output, and placed in the history.
+                if (pStream->Read(&aHistory[nPos % nWINDOWLEN],1))
+                    nPos++;
+
+                if (nClean == 0)
+                    nClean=1;
+            }
+        }
+    }
+    if (nPos % nWINDOWLEN)
+        pResult->Write( aHistory, nPos % nWINDOWLEN );
+    pResult->Flush();
+
+    if( pCompressedLength )
+        *pCompressedLength = nPos;
+
+    if( pLength )
+        *pLength = pResult->Tell();
+
+#if 0
+ {
+    fprintf( stderr, "Decompressed stream: %d bytes, size: %d\n",
+             pResult->Tell(), pResult->GetSize() );
+    pResult->Seek( 0 );
+    UINT8 aData[8];
+    sal_uInt32 nUrk = 0;
+    UINT8 nCnt;
+    while( ( nCnt = pResult->Read( aData, 8 ) ) > 0 )
+    {
+        int i;
+        fprintf( stderr, "%.8x : ", nUrk);
+        nUrk += nCnt;
+        for( i = 0; i < nCnt; i++ )
+            fprintf( stderr, "%.2x ", aData[i] );
+
+        fprintf( stderr," | " );
+        for( i = 0; i < nCnt; i++ )
+            fprintf( stderr, "%c", aData[i] >= 0x20 ? aData[i] : '.' );
+        fprintf( stderr, "\n" );
+    }
+ }
+#endif	
+
+    pResult->Seek( 0 );
+
+    return pResult;
+}
+
+OString decompressAsString( SvStream *pStream, sal_uInt32 nOffset, sal_uInt32 *pCompressedLength, sal_uInt32 *pLength )
+{
+    sal_uInt32 nResultLength;
+    SvMemoryStream *pResultStream = decompressAsStream( pStream, nOffset, pCompressedLength, &nResultLength );
+
+    // Isn't it just marvelous that SvMemoryStream has no sensible 'size'
+    // method that returns nEndOfData [!]
+    if( pLength )
+        *pLength = nResultLength;
+
+    OString aResult( (const sal_Char *)pResultStream->GetData(), nResultLength );
+    delete pResultStream;
+    return aResult;
+}
+
+}; /* End MSLZSS */
+
+static void
+stripAttributes( OUString &rVBA, bool bIsMac )
+{
+    OSL_TRACE("Strip Attributes - bIsMac = %d", bIsMac );
+    const sal_Unicode cLineEnd = bIsMac ? '\x0D' : '\x0A';
+    const rtl::OUString sAttribute( OUString::createFromAscii( "Attribute" ) );
+    //OSL_TRACE("** Before strip %s", rtl::OUStringToOString( rVBA, RTL_TEXTENCODING_UTF8 ).getStr() );
+    while( rVBA.indexOf( sAttribute ) == 0 )
+    {
+        sal_Int32 nEnd = rVBA.indexOf( cLineEnd );
+        if( nEnd == -1 )
+     		break;
+        rVBA = rVBA.copy( nEnd + 1 );
+    }
+    //OSL_TRACE("** After strip %s", rtl::OUStringToOString( rVBA, RTL_TEXTENCODING_UTF8 ).getStr() );
+}
+
+static void
+commentSource( OUString &rVBA, const OUString &rName, bool bIsMac )
+{
+    OUString sTempStringa(OUString::createFromAscii(
+                                  bIsMac ? "\x0D": "\x0D\x0A"));
+    OUString sTempStringb( sTempStringa );
+    OUString sTempRem = OUString::createFromAscii( "Rem " );
+    sTempStringb += sTempRem;
+    sal_Int32 nFromIndex = 0;
+    sal_Int32 nToIndex = -1;
+    while( (nToIndex = rVBA.indexOf( sTempStringa, nFromIndex ) ) != -1 )
+    {
+        rVBA = rVBA.replaceAt( nToIndex, sTempStringa.getLength(), sTempStringb);
+        nFromIndex = nToIndex += sTempStringb.getLength();
+    }
+    rVBA = sTempRem + rVBA;
+
+    // Streams can have spaces in them, but modulenames
+    // cannot !
+    rtl::OUString sTemp( rtl::OUString::createFromAscii( "Sub " ) );
+    sTemp += rName.replace( sal_Unicode(' '), sal_Unicode('_') );
+    sTemp += OUString::createFromAscii("\n");
+    rVBA = sTemp + rVBA;
+    rVBA += OUString::createFromAscii("\nEnd Sub");
+}
+
+struct DirTokenizer {
+    SvStream *mpStream;
+    sal_uInt16    mnToken;
+    sal_Int32    mnLength;
+    sal_uInt32    mnConsumed;
+    bool	  mnbEof;
+
+    DirTokenizer( SvStream *pStream ) :
+        mpStream(pStream), mnToken(0),
+        mnLength(0), mnConsumed(0),
+        mnbEof(false) {}
+    ~DirTokenizer() {}
+
+    bool
+    nextToken()
+    {
+        mpStream->SeekRel( mnLength - mnConsumed );
+
+        mnToken = mnLength = mnConsumed = 0;
+
+        // Seeking clears the eof marker - so read first ...
+        *mpStream >> mnToken;
+        if( mpStream->IsEof() )
+            return !(mnbEof = true);
+
+        *mpStream >> mnLength;
+        if( mpStream->IsEof() )
+            return !(mnbEof = true);
+    
+        if( mnToken == VBA_DIR_OP_PAPER_SIZE ) /* Quirk */
+            mnLength += 2;
+
+        OSL_TRACE("Next token 0x%x (%d long)", mnToken, mnLength );
+
+        return true;
+    }
+
+    bool
+    isEof()
+    {
+        return mnbEof;
+    }
+
+    sal_uInt32
+    getLong()
+    {
+        sal_uInt32 nResult;
+        mnConsumed += 4;
+        *mpStream >> nResult;
+        return nResult;
+    }
+
+    sal_uInt16
+    getShort()
+    {
+        sal_uInt16 nResult;
+        mnConsumed += 2;
+        *mpStream >> nResult;
+        return nResult;
+    }
+
+    OUString
+    getUString()
+    {
+        sal_Unicode aData[ ( mnLength + 1 ) / 2 ];
+        mpStream->Read( aData, mnLength );
+        mnConsumed += mnLength;
+        return OUString( aData, mnLength/2 );
+    }
+
+    OUString
+    getString()
+    {
+        sal_Char aData[ mnLength ];
+        mpStream->Read( aData, mnLength );
+        mnConsumed += mnLength;
+        return OUString( aData, mnLength, RTL_TEXTENCODING_MS_1252 );
+    }
+
+    Reference< XNameContainer > 
+    parseHeader( const Reference< XLibraryContainer > &xLibContainer )
+    {
+        Reference< XNameContainer > xLib;
+
+        if( !xLibContainer.is() )
+            return xLib;
+
+        // Parse the header
+        while( nextToken() && mnToken != VBA_DIR_SHORT_OBJECT_COUNT )
+        {
+            switch( mnToken )
+            {
+            case VBA_DIR_STR_PROJECT_NAME:
+//				aProjectName = getString(); - this causes export grief.
+                break;
+            }
+        }
+
+        if( !mnToken )
+            return xLib;
+
+        OUString aProjectName = OUString::createFromAscii( "Standard" );
+        OSL_TRACE( "CreateLibrary: '%s'",
+                     (const sal_Char *) rtl::OUStringToOString(
+                             aProjectName, RTL_TEXTENCODING_UTF8 ) );
+                 
+        if( !xLibContainer->hasByName( aProjectName ) )
+            xLibContainer->createLibrary( aProjectName );
+
+        Any aLibAny = xLibContainer->getByName( aProjectName );
+        aLibAny >>= xLib;
+
+        return xLib;
+    }
+
+    bool
+    readObject( const SvStorageRef &xStorage,
+                Reference< XNameContainer > &xLib,
+                const VBADir& rVBA,
+                bool bStripped, bool bAsComment, bool bIsMac )
+    {
+        OUString aName;
+        sal_uInt32    nOffset = 0;
+        OUString aStreamName;
+
+        while( nextToken() && mnToken != VBA_DIR_OBJECT_END )
+        {
+            switch( mnToken )
+            {
+            case VBA_DIR_STR_USER_NAME:
+                aName = getString();
+                break;
+            case VBA_DIR_USTR_USER_NAME:
+                aName = getUString();
+                break;
+            case VBA_DIR_STR_STREAM_NAME:
+                aStreamName = getString();
+                break;
+            case VBA_DIR_USTR_STREAM_NAME:
+                aStreamName = getUString();
+                break;
+            case VBA_DIR_LONG_VBA_OFFSET:
+                nOffset = getLong();
+                break;
+            default:
+                break;
+            }
+        }
+        if( aStreamName.getLength() )
+        {
+            OSL_TRACE("Open stream: '%s' (0x%x)",
+                     (const sal_Char *) rtl::OUStringToOString(
+                             aStreamName, RTL_TEXTENCODING_UTF8 ),
+                     nOffset );
+
+            SotStorageStreamRef xVBA;
+
+            xVBA = xStorage->OpenSotStream( aStreamName, STREAM_STD_READ );
+            if( !xVBA.Is() )
+            {
+                OSL_TRACE("Failed to open stream" );
+                return false;
+            }
+            xVBA->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN ); // #TODO CHECKME ( but I think module streams are always littleendian )
+
+            OUString sSource = OStringToOUString(
+                    MSLZSS::decompressAsString( xVBA, nOffset ),
+                    RTL_TEXTENCODING_MS_1252 );
+
+            if( bStripped )
+                stripAttributes( sSource, bIsMac );
+
+            if( sSource.getLength() <= 0 )
+                return true;
+
+            sal_Int16 mType = rVBA.GetModuleType( aName );
+
+            rtl::OUString modeTypeComment;
+            prependHelperAPIInfo( modeTypeComment, mType );
+
+            if( bAsComment )
+                commentSource( sSource, aName, bIsMac );
+            else
+            {
+                static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) );
+                static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) );
+                modeTypeComment = modeTypeComment + sVBAOption;
+                if ( mType == Class )
+                    modeTypeComment = modeTypeComment + sClassOption;
+            }
+
+            sSource = modeTypeComment + sSource;
+
+            rtl::OUString aModName( aName );
+            Any aSourceAny;
+            aSourceAny <<= sSource;
+            if (xLib->hasByName(aModName))
+                xLib->replaceByName(aModName, aSourceAny);
+            else
+                xLib->insertByName(aModName, aSourceAny);
+
+            return true;
+        }
+        else
+        {
+            OSL_TRACE( "Duff stream name" );
+        }
+        return false;
+    }
+
+    bool prependHelperAPIInfo( OUString& sSource, sal_Int16 mType )
+    {
+        rtl::OUString sClassRem( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=" ) );
+
+        rtl::OUString modeTypeComment;
+        switch( mType )
+        {
+            case ModuleType::Class:
+                modeTypeComment = sClassRem +
+                    ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAClassModule\n" ) );
+                break;
+            case ModuleType::Form:
+                modeTypeComment = sClassRem +
+                    ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAFormModule\n" ) );
+                break;
+            case ModuleType::Document:
+                modeTypeComment = sClassRem +
+                    ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADocumentModule\n" ) );
+                break;
+            case ModuleType::Normal:
+                modeTypeComment = sClassRem +
+                    ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAModule\n" ) );
+                break;
+            case ModuleType::Unknown:
+                modeTypeComment = sClassRem +
+                    ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAUnknown\n" ) );
+            
+            default:
+                DBG_ERRORFILE( "SvxImportMSVBasic::ImportCode_Impl - unknown module type" );
+                return false;
+        }
+        sSource = modeTypeComment + sSource;
+        return true;
+    }
+};
+
+VBADir::VBADir( SvStorageRef &xProjectStorage, SvStorageRef &xStorage  ) :
+        mxStorage( xStorage ), mxProjectStorage( xProjectStorage ), mbMac( false ), meCharSet( RTL_TEXTENCODING_MS_1252)
+{
+    init();
+}
+
+VBADir::~VBADir()
+{
+}
+
+void 
+VBADir::init()
+{
+    Read_VBA_PROJECT();		
+    Read_VBAPROJECT();		
+}
+int 
+VBADir::Read_VBA_PROJECT()
+{
+    SvStorageStreamRef xVBAProject;
+    xVBAProject = mxStorage->OpenSotStream(
+    String( RTL_CONSTASCII_USTRINGPARAM( "_VBA_PROJECT" ) ),
+        STREAM_STD_READ | STREAM_NOCREATE );
+    
+    if( !xVBAProject.Is() || SVSTREAM_OK != xVBAProject->GetError() )
+    {
+        DBG_WARNING("Not able to find vba project, cannot find macros");
+        return 0;
+    }
+
+    static const sal_uInt8 aKnownId[] = {0xCC, 0x61};
+    sal_uInt8 aId[2];
+    xVBAProject->Read( aId, sizeof(aId) );
+    if (memcmp( aId, aKnownId, sizeof(aId)))
+    {
+        DBG_WARNING("unrecognized VBA macro project type");
+        return 0;
+    }
+
+    static const sal_uInt8 aOffice2003LE_2[] =
+    {
+        0x79, 0x00, 0x00, 0x01, 0x00, 0xFF
+    };
+    
+    static const sal_uInt8 aOffice2003LE[] =
+    {
+        0x76, 0x00, 0x00, 0x01, 0x00, 0xFF
+    };
+
+    static const sal_uInt8 aOfficeXPLE[] =
+    {
+        0x73, 0x00, 0x00, 0x01, 0x00, 0xFF
+    };
+
+    static const sal_uInt8 aOfficeXPBE[] =
+    {
+        0x63, 0x00, 0x00, 0x0E, 0x00, 0xFF
+    };
+
+    static const sal_uInt8 aOffice2000LE[] =
+    {
+        0x6D, 0x00, 0x00, 0x01, 0x00, 0xFF
+    };
+    static const sal_uInt8 aOffice98BE[] =
+    {
+        0x60, 0x00, 0x00, 0x0E, 0x00, 0xFF
+    };
+    static const sal_uInt8 aOffice97LE[] =
+    {
+        0x5E, 0x00, 0x00, 0x01, 0x00, 0xFF
+    };
+    sal_uInt8 aProduct[6];
+    xVBAProject->Read( aProduct, sizeof(aProduct) );
+
+    bool bIsUnicode = false;
+    if (!(memcmp(aProduct, aOffice2003LE, sizeof(aProduct))) ||
+        !(memcmp(aProduct, aOffice2003LE_2, sizeof(aProduct))) )
+    {
+        xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
+        bIsUnicode = true;
+    }
+    else if (!(memcmp(aProduct, aOfficeXPLE, sizeof(aProduct))))
+    {
+        xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
+        bIsUnicode = true;
+    }
+    else if (!(memcmp(aProduct, aOfficeXPBE, sizeof(aProduct))))
+    {
+        xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_BIGENDIAN );
+        mbMac = true;
+        bIsUnicode = false;
+    }
+    else if (!(memcmp(aProduct, aOffice2000LE, sizeof(aProduct))))
+    {
+        xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
+        bIsUnicode = true;
+    }
+    else if (!(memcmp(aProduct, aOffice98BE, sizeof(aProduct))))
+    {
+        xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_BIGENDIAN );
+        mbMac = true;
+        bIsUnicode = false;
+    }
+    else if (!(memcmp(aProduct, aOffice97LE, sizeof(aProduct))))
+    {
+        xVBAProject->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN );
+        bIsUnicode = true;
+    }
+    else
+    {
+        switch (aProduct[3])
+        {
+            case 0x1:
+                xVBAProject->SetNumberFormatInt(NUMBERFORMAT_INT_LITTLEENDIAN);
+                bIsUnicode = true;
+                DBG_ASSERT(!this, "unrecognized VBA macro version, report to cmc. Guessing at unicode little endian");
+                break;
+            case 0xe:
+                xVBAProject->SetNumberFormatInt(NUMBERFORMAT_INT_BIGENDIAN);
+                mbMac = true;
+                bIsUnicode = false;
+                DBG_ASSERT(!this, "unrecognized VBA macro version, report to cmc. Guessing at 8bit big endian");
+                break;
+            default:
+                DBG_ASSERT(!this, "totally unrecognized VBA macro version, report to cmc");
+                return 0;
+        }
+    }
+
+    sal_uInt32 nLidA;  //Language identifiers
+    sal_uInt32 nLidB;
+    sal_uInt16 nCharSet;
+    sal_uInt16 nLenA;
+    sal_uInt32 nUnknownB;
+    sal_uInt32 nUnknownC;
+    sal_uInt16 nLenB;
+    sal_uInt16 nLenC;
+    sal_uInt16 nLenD;
+    
+    *xVBAProject >> nLidA >> nLidB >> nCharSet >> nLenA >> nUnknownB;
+    *xVBAProject >> nUnknownC >> nLenB >> nLenC >> nLenD;
+    
+    meCharSet = rtl_getTextEncodingFromWindowsCodePage(nCharSet);
+    
+    DBG_ASSERT(meCharSet != RTL_TEXTENCODING_DONTKNOW,
+    "don't know what vba charset to use");
+    if (meCharSet == RTL_TEXTENCODING_DONTKNOW)
+        meCharSet = RTL_TEXTENCODING_MS_1252;
+
+    if (nLenD != 0x02)
+    {
+        DBG_WARNING("Warning VBA number is different, please report");
+        return 0;
+    }
+    OSL_TRACE( "mbMac = %d", mbMac );
+    return 1;
+}
+
+void 
+VBADir::Read_VBAPROJECT()
+{
+    // #TODO revisit
+
+    // Probably its possible to do this in the DirTokeniser also ( but
+    // I didn't *easily* see something to distinguish between the different
+    // 'Object' Modules ( Document & Form for instance )
+    // But also ....  *easily* meaning I didn't look that hard either.
+
+        /* #117718#
+         * Information regarding the type of module is contained in the
+         * "PROJECT" stream, this stream consists of a number of ascii lines
+         * entries are of the form Key=Value, the ones that we are interested
+         * in have the keys; Class, BaseClass & Module indicating the module
+         * ( value ) is either a Class Module, Form Module or a plain VB Module.        */
+        SvStorageStreamRef xProject = mxProjectStorage->OpenSotStream(
+            String( RTL_CONSTASCII_USTRINGPARAM( "PROJECT" ) ) );
+        SvStorageStream* pStp = xProject;
+        UniString tmp;
+        static const String sThisDoc(   RTL_CONSTASCII_USTRINGPARAM( "ThisDocument" ) );
+        static const String sModule(    RTL_CONSTASCII_USTRINGPARAM( "Module" ) );
+        static const String sClass(     RTL_CONSTASCII_USTRINGPARAM( "Class" ) );
+        static const String sBaseClass( RTL_CONSTASCII_USTRINGPARAM( "BaseClass" ) );
+        static const String sDocument(  RTL_CONSTASCII_USTRINGPARAM( "Document" ) );
+        mhModHash[ sThisDoc ] = Class;
+        while ( pStp->ReadByteStringLine( tmp, meCharSet ) )
+        {
+            xub_StrLen index = tmp.Search( '=' );
+            if ( index != STRING_NOTFOUND )
+            {
+                String key = tmp.Copy( 0, index  );
+                String value = tmp.Copy( index + 1 );
+                if ( key == sClass )
+                {
+                    mhModHash[ value ] = Class;
+                    OSL_TRACE("Module %s is of type Class",
+                        ::rtl::OUStringToOString( value ,
+                            RTL_TEXTENCODING_ASCII_US ).pData->buffer );
+                }
+                else if ( key == sBaseClass )
+                {
+                    mhModHash[ value ] =  Form;
+                    OSL_TRACE("Module %s is of type Form",
+                        ::rtl::OUStringToOString( value ,
+                            RTL_TEXTENCODING_ASCII_US ).pData->buffer );
+                }
+                else if ( key == sDocument )
+                {
+                    /*  #i37965# DR 2004-12-03: add "Document", used i.e.
+                        in Excel for macros attached to sheet or document. */
+
+                    // value is of form <name>/&H<identifier>, strip the identifier
+                    value.Erase( value.Search( '/' ) );
+
+                    mhModHash[ value ] = Document;
+                    OSL_TRACE("Module %s is of type Document VBA",
+                        ::rtl::OUStringToOString( value ,
+                            RTL_TEXTENCODING_ASCII_US ).pData->buffer );
+                }
+                else if ( key == sModule )
+                {
+                    mhModHash[ value ] = Normal;
+                    OSL_TRACE("Module %s is of type Normal VBA",
+                        ::rtl::OUStringToOString( value ,
+                            RTL_TEXTENCODING_ASCII_US ).pData->buffer );
+                }
+            }
+        }
+}
+
+sal_Int16 
+VBADir::GetModuleType( const UniString& rModuleName ) const
+{
+    ModuleTypeHash::const_iterator iter = mhModHash.find( rModuleName );
+    ModuleTypeHash::const_iterator iterEnd = mhModHash.end();
+    if ( iter != iterEnd )
+    {
+        return iter->second;
+    }
+    return Unknown;
+}
+
+bool
+VBADir::readBasic( SfxObjectShell &rDocSh, bool bAsComment, bool bStripped )
+{
+    bool bRet = false;
+    SotStorageStreamRef xDir;
+
+    xDir = mxStorage->OpenSotStream( OUString::createFromAscii( "dir"),
+                                     STREAM_STD_READ );
+    if( !xDir.Is() )
+    {
+        DBG_WARNING( "No 'dir' stream" );
+        return FALSE;
+    }
+    xDir->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN ); // #TODO - CHECKME ( is dir's endian-ness determined mbMac ( e.g. creating platfrom ) or is it always littleendian )
+
+    SvMemoryStream *pPlain = MSLZSS::decompressAsStream( xDir, 0 );
+#if 0
+    // hacky dump 
+    std::ofstream aOut("/home/npower/dir.out", std::ios::out );
+    sal_uInt8 aChar;
+    while (  !pPlain->IsEof() )
+    {
+        *pPlain >> aChar;
+        aOut << aChar;
+    }
+    pPlain->Seek(0);
+#endif
+    if( !pPlain )
+    {
+        DBG_WARNING( "Failed to decompress 'dir' stream" );
+        return FALSE;
+    }
+
+    SFX_APP()->EnterBasicCall();
+
+    Reference< XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+
+    DirTokenizer aTok( pPlain );
+    Reference< XNameContainer > xLib;
+
+    xLib = aTok.parseHeader( xLibContainer );
+    if( !xLib.is() )
+    {
+        DBG_WARNING( "Broken header /library" );
+        return FALSE;
+    }
+        
+    // Parse the objects
+    USHORT nItems = aTok.getShort();
+    for( USHORT nItem = 0; nItem < nItems && !aTok.isEof(); nItem++)
+        aTok.readObject( mxStorage, xLib, *this, bStripped, bAsComment, mbMac );
+    
+    bRet = true;
+    delete pPlain;
+
+    SFX_APP()->LeaveBasicCall();
+
+    return bRet;
+}
+
+void
+VBADir::deleteSRPs()
+{
+    SvStorageInfoList aInfoList;
+
+    mxStorage->FillInfoList( &aInfoList );
+
+    // Remove highly version specific compiled VBA streams
+    for( sal_uInt32 i = 0; i < aInfoList.Count(); i++ )
+    {
+        SvStorageInfo& rInfo = aInfoList[i];
+
+        if( rInfo.IsStream() &&
+            rInfo.GetName().EqualsAscii( "__SRP_", 0, 6 ) )
+            mxStorage->Remove( rInfo.GetName() );
+    }
+}
+
+void
+VBADir::clobberProject()
+{
+    SotStorageStreamRef xProject;
+
+    xProject = mxStorage->OpenSotStream( OUString::createFromAscii( "_VBA_PROJECT" ),
+                                         STREAM_STD_WRITE );
+    if( !xProject.Is() )
+    {
+        DBG_WARNING( "Failed to clobber VBA project" );
+        return;
+    }
+
+    UINT8 nMagicVersion = 0xa0;
+    UINT8 nData[8] = { 0xcc, 0x61, 0x00, 0, 0,1,0,0 };
+    UINT8 nZeros[8] = { 0,0,0,0, 0,0,0,0 };
+    nData[2] = nMagicVersion;
+
+    xProject->Seek( 0 );
+    xProject->Write( nData, 8 );
+    xProject->Write( nZeros, 8 );
+    xProject->Write( nZeros, 8 );
+    for (int i = 0; i < 100; i++)
+            xProject->Write( nZeros, 8 );
+    xProject->Flush();
+}
+
+struct DirOutput {
+    SvStream *mpStream;
+
+    DirOutput( SvStream *pDirStream ) :
+        mpStream( pDirStream ) {}
+    ~DirOutput() {}
+
+    void
+    writeLong( sal_uInt16 nToken, sal_uInt32 nLong )
+    {
+        *mpStream << nToken;
+        *mpStream << sal_uInt32(4);
+        *mpStream << nLong;
+    }
+
+    void
+    writeShort( sal_uInt16 nToken, sal_uInt16 nShort )
+    {
+        *mpStream << nToken;
+        *mpStream << sal_uInt32(2);
+        *mpStream << nShort;
+    }
+
+    void	
+    writeUString( sal_uInt16 nToken, const OUString &rString )
+    {
+        *mpStream << nToken;
+        *mpStream << sal_uInt32( rString.getLength() * 2 );
+        mpStream->Write( (const sal_Unicode *)rString,
+                         rString.getLength() * 2 );
+    }
+
+    void
+    writeString( sal_uInt16 nToken, const OString &rString )
+    {
+        *mpStream << nToken;
+        *mpStream << sal_uInt32( rString.getLength() );
+        mpStream->Write( (const sal_Char *)rString,
+                         rString.getLength() );
+    }
+
+    void
+    writeUStringPair( sal_uInt16 nPlainToken, sal_uInt16 nUniToken, const OUString &rString )
+    {
+        writeString( nPlainToken, OUStringToOString( rString, RTL_TEXTENCODING_MS_1252 ) );
+        writeUString( nUniToken, rString );
+    }
+
+    void
+    writeHeader()
+    {
+        writeLong( VBA_DIR_LONG_START, 1 );
+        writeLong( VBA_DIR_LONG_ENCODING_1, 0x409 );
+        writeLong( VBA_DIR_LONG_ENCODING_2, 0x409 );
+        writeShort( VBA_DIR_SHORT_VERSION_1, 0x4e4 );
+        writeString( VBA_DIR_STR_PROJECT_NAME, OString( "ProjectFoo" ) );
+        writeUStringPair( VBA_DIR_STR_DESCRIPTION,
+                          VBA_DIR_USTR_DESCRIPTION, OUString() );
+        writeUStringPair( VBA_DIR_STR_HELP_FILENAME,
+                          VBA_DIR_USTR_HELP_FILENAME, OUString() );
+        writeLong( VBA_DIR_LONG_HELP_CTXT_ID, 0 );
+        writeLong( VBA_DIR_LONG_UNKNOWN_0x08, 0 );
+
+        // Whacked out 0x09 token:
+        *mpStream << sal_uInt16( VBA_DIR_OP_PAPER_SIZE );
+        *mpStream << sal_uInt32( 6 - 2 ); // totally magic: A4
+        *mpStream << sal_uInt16( 0x4b0 ) << sal_uInt16( 0x419a ) << sal_uInt16( 0x34 );
+
+        writeUStringPair( VBA_DIR_STR_COND_COMP_ARGS,
+                          VBA_DIR_USTR_COND_COMP_ARGS, OUString() );
+
+/*		// Magic libraries we use
+        writeString( VBA_DIR_STR_STREAM_TYPE, OString( "stdole" ) );
+        writeUString( VBA_DIR_USTR_STREAM_TYPE,
+                        OUString::createFromAscii( "stdole" ) ); */
+    }
+
+    void
+    writeModuleCount( sal_uInt32 nModules )
+    {
+        writeShort( VBA_DIR_SHORT_OBJECT_COUNT, nModules );
+        writeShort( VBA_DIR_SHORT_UNKNOWN_0x13, 0x7384 ); // Concerning ...
+    }
+
+    void
+    writeFlag( sal_uInt16 nToken )
+    {
+        *mpStream << sal_uInt16( nToken );
+        *mpStream << sal_uInt32( 0 );
+    }
+
+    void
+    writeEnd()
+    {
+        writeFlag( VBA_DIR_FLAG_END );
+        mpStream->Flush();
+    }
+
+    void
+    writeModule( const OUString &rName, sal_Int16 rType = Normal )
+    {
+        writeUStringPair( VBA_DIR_STR_USER_NAME,
+                          VBA_DIR_USTR_USER_NAME, rName );
+        writeUStringPair( VBA_DIR_STR_STREAM_NAME,
+                          VBA_DIR_USTR_STREAM_NAME, rName );
+        writeUStringPair( VBA_DIR_STR_UNKNOWN_0x1c,
+                          VBA_DIR_USTR_UNKNOWN_0x48, OUString() );
+        // Our streams start after 16 bytes of padded 0s ( to please Office97 )
+        writeLong( VBA_DIR_LONG_VBA_OFFSET, 0x10 );
+        writeLong( VBA_DIR_LONG_UNKNOWN_0x1e, 0x0 );
+        writeShort( VBA_DIR_SHORT_UNKNOWN_0x2c, 0x3672 ); // Concerning ...
+        switch ( rType )
+        {
+            case Document:
+            case Form:
+                writeFlag( VBA_DIR_FLAG_DOCUMENT );
+                break;
+            case Class: 
+                writeFlag( VBA_DIR_CLASS_MODULE );
+                break;
+            case Normal: 
+                writeFlag( VBA_DIR_FLAG_MACRO );
+                break;
+            case Unknown:
+                DBG_WARNING( "Unknown module type" );
+        }
+        writeFlag( VBA_DIR_OBJECT_END );
+    }
+
+    void
+    writeModules( const vecModuleTypes& rModTypes )
+    { 
+        // a hack - these are the hard-coded names from the 'CODENAME'
+        // records in the Excel stream.
+        vecModuleTypes::const_iterator it = rModTypes.begin();
+        vecModuleTypes::const_iterator it_end = rModTypes.end();
+        for ( ; it != it_end; ++it )
+            writeModule( it->first, it->second );
+    }
+};
+
+struct ProjectOutput {
+    SotStorageStreamRef mxProject;
+    SotStorageStreamRef mxProjectWm;
+
+    ProjectOutput() {}
+    ~ProjectOutput() {}
+
+    bool initialize( const SvStorageRef &xStorage )
+    {
+        mxProject = xStorage->OpenSotStream(
+                rtl::OUString::createFromAscii( "PROJECT" ),
+                STREAM_STD_WRITE );
+        mxProjectWm = xStorage->OpenSotStream(
+                rtl::OUString::createFromAscii( "PROJECTwm" ),
+                STREAM_STD_WRITE );
+
+        return mxProject.Is() && mxProjectWm.Is();
+    }
+
+    void writeString( const OString &rString )
+    {
+        OString sTempStringa( "\n" );
+        OString sTempStringb( "\x0D\x0A" );
+        OString sOutput = rString;
+        
+       	sal_Int32 nFromIndex = 0;
+        sal_Int32 nToIndex = -1;
+        while( (nToIndex = sOutput.indexOf( sTempStringa, nFromIndex ) ) != -1 )
+        {
+            sOutput = sOutput.replaceAt( nToIndex, sTempStringa.getLength(), sTempStringb);
+            nFromIndex = nToIndex += sTempStringb.getLength();
+        }
+        mxProject->Write( (const sal_Char *) sOutput, sOutput.getLength() );
+    }
+
+    void writeModule( const OUString &rName, sal_Int16 rType = Normal )
+    {
+        OString sName = OUStringToOString( rName, RTL_TEXTENCODING_MS_1252 );
+        OSL_TRACE("writeModeule %s, type %d", sName.getStr(), rType );
+        switch( rType )
+        {
+            case Document:
+                writeString( "Document=" );
+                break;
+            case Normal:
+                writeString( "Module=" );
+                break;
+            case Class:
+                writeString( "Class=" );
+                break;
+            case Form:
+                writeString( "BaseClass=" );
+                break;
+            case Unknown:
+                writeString( "Module=" );
+                break;
+        }
+        writeString( sName );
+        if( rType == Document )
+            writeString( "/&H00000000" );
+        writeString( "\n" );
+        mxProjectWm->Write( (const sal_Char *) sName, sName.getLength() );
+        *mxProjectWm << UINT8( 0 );
+        mxProjectWm->Write( (const sal_Unicode *) rName, rName.getLength() * 2);
+        *mxProjectWm << sal_uInt16( 0 );
+    }
+
+    void writeHeader()
+    {
+        writeString("ID=\"{33C90A8B-9E30-406E-BC0F-D2863F9025D7}\"\n");
+    }
+
+    void writeModules( const vecModuleTypes& rModTypes )
+    {
+        vecModuleTypes::const_iterator it = rModTypes.begin();
+        vecModuleTypes::const_iterator it_end = rModTypes.end();
+        for ( ; it != it_end; ++it )
+            writeModule( it->first, it->second );
+    }
+
+    void writeEnd()
+    {
+        *mxProjectWm << sal_uInt16( 0 );
+
+        mxProject->Flush();
+        mxProjectWm->Flush();
+    }
+};
+
+OUString 
+VBADir::stripOptions( const OUString& rSource, sal_Int16 rType )
+{
+    OUString newSource( rSource );
+    sal_Int32 nFromIndex = 0;
+    sal_Int32 nToIndex = -1;
+    OUString sNewLine( '\n' );
+
+    com::sun::star::util::SearchOptions aVBAOpt;
+    ::com::sun::star::util::SearchResult aVBARes;
+    ::com::sun::star::util::SearchResult aClassRes;
+    aVBAOpt.algorithmType = com::sun::star::util::SearchAlgorithms_REGEXP;
+
+    aVBAOpt.Locale = Application::GetSettings().GetLocale();
+
+    //aVBAOptSearch.searchString = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("^\\s*Option\\s+VBASupport\\s+1") );;		
+    aVBAOpt.searchString = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("^\\s*Option VBASupport 1") );;		
+
+    aVBAOpt.transliterateFlags |= com::sun::star::i18n::TransliterationModules_IGNORE_CASE;
+    com::sun::star::util::SearchOptions aClassOpt( aVBAOpt);
+
+    //aClassOpt.searchString = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("^\\s*Option\\s+ClassModule\\s*$") );;		
+    aClassOpt.searchString = rtl::OUString( RTL_CONSTASCII_USTRINGPARAM("Option ClassModule") );;		
+    utl::TextSearch aVBASearch(aVBAOpt);
+    utl::TextSearch aClassSearch(aClassOpt);
+    bool bFoundVBA = false;
+    bool bFoundClass = false;
+    xub_StrLen nStart=0, nEnd=rSource.getLength();
+    while( (nToIndex = rSource.indexOf( sNewLine, nFromIndex ) ) != -1 )
+    {
+        OUString nLine = rSource.copy( nFromIndex, ( nToIndex - nFromIndex ) + 1 );
+        if ( !bFoundVBA ) // always search until found
+        {
+            if ( aVBASearch.SearchFrwrd(nLine, &nStart, &nEnd, &aVBARes ) )
+            {
+                // add index to the line we are processing
+                aVBARes.startOffset[0] += nFromIndex;
+                aVBARes.endOffset[0] += nFromIndex;
+                bFoundVBA = true;		
+            }
+        }
+        if ( ( rType == Class ) && !bFoundClass ) // always search until found
+        {
+            if ( aClassSearch.SearchFrwrd(nLine, &nStart, &nEnd, &aClassRes ) )
+            {
+                // add index to the line we are processing
+                aClassRes.startOffset[0] += nFromIndex;
+                aClassRes.endOffset[0] += nFromIndex;
+                bFoundClass = true;		
+            }
+        }
+        // determine if we are finished
+        if ( ( bFoundVBA && rType != Class ) || 
+        ( ( rType == Class ) && bFoundClass ) && bFoundVBA )
+        {
+            break;
+        }
+        nFromIndex = nToIndex +  sNewLine.getLength();
+    }
+    if ( bFoundClass || bFoundVBA )
+    {
+        sal_Int32 nStartFirstOption = -1;
+        sal_Int32 nEndFirstOption = -1;
+        sal_Int32 nStartSecondOption = -1;
+        sal_Int32 nEndSecondOption = -1;
+
+        if ( bFoundClass )
+        {
+            if ( aClassRes.startOffset[0] > aVBARes.startOffset[0] )
+            {
+                nStartFirstOption =  aVBARes.startOffset[0];
+                nEndFirstOption =  aVBARes.endOffset[0];
+                nStartSecondOption = aClassRes.startOffset[0];
+                nEndSecondOption = aClassRes.endOffset[0];
+            }
+            else
+            {
+                nStartFirstOption =  aClassRes.startOffset[0];
+                nEndFirstOption =  aClassRes.endOffset[0];
+                nStartSecondOption = aVBARes.startOffset[0];
+                nEndSecondOption = aVBARes.endOffset[0];
+            }
+
+        }
+        else
+        {
+            nStartFirstOption =  aVBARes.startOffset[0];
+            nEndFirstOption =  aVBARes.endOffset[0];
+        }
+        // Copy up to First Option 
+        newSource = rSource.copy( 0, nStartFirstOption ); //
+        if ( bFoundClass )
+        {
+            newSource += rSource.copy( nEndFirstOption, nStartSecondOption - nEndFirstOption ); 
+            newSource += rSource.copy( nEndSecondOption, rSource.getLength() - nEndSecondOption );
+        }
+        else
+            newSource += rSource.copy( nEndFirstOption, rSource.getLength() - nEndFirstOption );
+    }
+    return newSource;
+}
+
+void
+VBADir::writeModule( const OUString &rName, const OUString &rSource, sal_Int16 rType = Normal)
+{
+    SvStorageStreamRef xStream;
+    xStream = mxStorage->OpenSotStream( rName, STREAM_STD_WRITE );
+    xStream->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN ); // #TODO - CHECKME are module stream always little endian
+        
+    UINT8 aData[16] = { 0, };
+    xStream->Write( aData, 16 );
+
+    OString sAttribute;
+    if ( rType == Normal )
+        sAttribute = sAttribute + "Attribute VB_Name = \"" + OUStringToOString( rName, RTL_TEXTENCODING_MS_1252 ) + "\"";
+    else if ( rType == Document )
+    {
+        // #FIXME wacky hack, this will become an issue also for
+        // word :-( possibly we need another constant to handle this 
+        // special document module type
+        // Better still would be a distinct module object type in basic
+        if ( rName.equals(  OUString::createFromAscii( "ThisWorkbook" ) ) )
+        {
+            sAttribute = "Attribute VB_Base = \"0{00020819-0000-0000-C000-000000000046}\"";
+        }
+        else
+        {
+            sAttribute = "Attribute VB_Base = \"0{00020820-0000-0000-C000-000000000046}\"";
+        }
+
+    }
+    else if ( rType == Class )
+    {
+            sAttribute = "Attribute VB_Base = \"0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}\"";
+/*
+            sAttribute = sAttribute + "\r\nAttribute VB_GlobalNameSpace = False";
+            sAttribute = sAttribute + "\r\nAttribute VB_Creatable = False";
+            sAttribute = sAttribute + "\r\nAttribute VB_PredeclaredId = False";
+            sAttribute = sAttribute + "\r\nAttribute VB_Exposed = False";
+            sAttribute = sAttribute + "\r\nAttribute VB_TemplateDerived = False";
+            sAttribute = sAttribute + "\r\nAttribute VB_Customizable = False";
+*/
+    }
+    else if ( rType == Form )
+    {
+            sAttribute = "Attribute VB_Base = \"0{6FE35EE2-F5D3-4FD9-BBB2-A3253B2C0650}{D22BB890-287D-42D9-85E8-F98E3EB8559C}\"";
+    }
+    
+    // Remove any instances of Option VBASupport and/or Option ClassModule
+
+    OString sSource = OUStringToOString( stripOptions( rSource, rType ), RTL_TEXTENCODING_MS_1252 );
+
+    sSource = sAttribute + "\r\n" + sSource;
+    //OSL_TRACE("***************************");
+    //OSL_TRACE("source for %s", OUStringToOString( rName, RTL_TEXTENCODING_UTF8 ).getStr() );
+    //OSL_TRACE("->START\n%s<-END", sSource.getStr() );
+    
+
+    MSLZSS::compressString( xStream, sSource );
+}
+
+bool
+VBADir::writeBasic( SfxObjectShell &rDocSh )
+{
+    bool bRet = true;
+
+    OSL_TRACE("writeBasic");
+    deleteSRPs();
+    clobberProject();
+
+    SvMemoryStream aMemStream;
+    ProjectOutput  aProject;
+
+    if( !aProject.initialize( mxProjectStorage ) )
+    {
+        OSL_TRACE( "Error opening project streams");
+        return false;
+    }
+    aProject.writeHeader();
+
+    DirOutput aDir( &aMemStream );
+    aDir.writeHeader();
+
+    SFX_APP()->EnterBasicCall();
+
+    Reference< XNameAccess> xVBAObjects;
+    Reference< XMultiServiceFactory> xSF(rDocSh.GetModel(), UNO_QUERY);
+
+    if ( xSF.is() )
+        xVBAObjects.set ( xSF->createInstance( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "org.openoffice.vba.VBAObjectsToExport"))), UNO_QUERY);
+
+    Reference< XLibraryContainer > xLibContainer = rDocSh.GetBasicContainer();
+    Reference< XNameContainer > xLib;
+    OSL_TRACE("about to test xLibContainer");
+    if ( xLibContainer.is() )
+    {
+        try
+        {
+            xLib.set( xLibContainer->getByName( rtl::OUString( STANDARD ) ), UNO_QUERY );
+        }
+        catch( Exception& ){}
+    }
+    if( xVBAObjects.is() && xLib.is() )
+    {
+        OSL_TRACE("Got document specific vbaobject service");
+        Sequence< OUString > aProjects;
+        aProjects = xVBAObjects->getElementNames();
+        sal_Int32 nLen = aProjects.getLength();	
+        Reference < XStorage > xSrcRoot( rDocSh.GetStorage() );
+        SvStorageRef xMSProject = SotStorage::OpenOLEStorage( xSrcRoot, SvxImportMSVBasic::GetMSBasicStorageName(), STREAM_STD_READ );
+
+        OSL_TRACE("******* aProjects has %d entries", nLen );
+
+        SvxMSUserFormHelper userformHelper( xMSProject, String( RTL_CONSTASCII_USTRINGPARAM("VBA"))) ;
+        vecModuleTypes vbaModuleTypes;
+        for ( sal_Int32 nIndex = 0; nIndex < nLen; ++nIndex )
+        {
+            sal_Int16 nType = Unknown;
+            xVBAObjects->getByName( aProjects[ nIndex ] ) >>= nType;
+            // Check to see if this is an imported Userform,
+            // If this module doesn't match a previously imported
+            // userform then we can't export a 'real' Userform 
+            // ( Object and code ). We can only export the code
+            // in this case ( so it can't be exported as a Userform
+            // code/object combination )
+            
+            if ( userformHelper.isUserFormModuleName( aProjects[ nIndex ] ) )
+                nType = Form;
+
+            vbaModuleTypes.push_back( ModuleDesc(  aProjects[ nIndex ], nType ) );
+            OSL_TRACE("about to export %s type %d", rtl::OUStringToOString( aProjects[ nIndex ], RTL_TEXTENCODING_UTF8 ).getStr(), nType );
+            
+        }
+        aProject.writeModules( vbaModuleTypes );		
+
+        aDir.writeModuleCount(  vbaModuleTypes.size() );
+
+        // really this is write modules	
+        aDir.writeModules( vbaModuleTypes );
+
+        vecModuleTypes::iterator it = vbaModuleTypes.begin();
+        vecModuleTypes::iterator it_end = vbaModuleTypes.end();
+        for ( ; it != it_end; ++it )
+        {
+            Any aSourceAny;
+            OUString sSource;
+            // its possible that e.g. sheet1..3 have no code therefore they don't exist in openoffice, ditto for ThisWorkbook
+            try
+            {
+                aSourceAny = xLib->getByName( it->first );
+                aSourceAny >>= sSource;
+            }
+            catch( com::sun::star::uno::Exception& )
+            {
+            }
+            if( sSource.getLength() >= 0 )
+                writeModule( it->first, sSource, it->second );
+
+            // copy userform streams
+            if ( it->second == Form )
+            {
+                OSL_TRACE("Copying userform %s", rtl::OUStringToOString( it->first, RTL_TEXTENCODING_UTF8 ).getStr() );
+                SvStorageRef xFormSrc = xMSProject->OpenOLEStorage( it->first, STREAM_STD_READ );
+                SvStorageRef xDst = mxProjectStorage->OpenSotStorage( it->first, STREAM_READWRITE | STREAM_TRUNC );
+
+                xFormSrc->CopyTo( xDst );	
+                xDst->Commit();
+                ErrCode nError = xDst->GetError();
+                if ( nError == ERRCODE_NONE )
+                    nError = xFormSrc->GetError();
+                if ( nError != ERRCODE_NONE )
+                {
+                    OSL_TRACE("Error writing %s", rtl::OUStringToOString( it->first, RTL_TEXTENCODING_UTF8 ).getStr() );
+                    //return false;
+                }
+            }
+        }
+        
+    }
+    else
+        aDir.writeModuleCount( 0 );
+
+    aDir.writeEnd();
+    aProject.writeEnd();
+
+    aMemStream.Seek( 0 );
+
+    // Compress dir to the real stream
+    SvStorageStreamRef xDir;
+    xDir = mxStorage->OpenSotStream( OUString::createFromAscii( "dir" ),
+                                     STREAM_STD_WRITE );
+    if( !xDir.Is() )
+    {
+        OSL_TRACE("Failed to open dir" );
+        bRet = false;
+    }
+    else
+    {
+        xDir->SetNumberFormatInt( NUMBERFORMAT_INT_LITTLEENDIAN ); // #TODO - CHECKME for endianess ( e.g. should Dir always be littleendian or not )
+        MSLZSS::compressStream( xDir, &aMemStream );
+        xDir->Flush();
+    }
+
+    SFX_APP()->LeaveBasicCall();
+
+    return bRet;
+}
