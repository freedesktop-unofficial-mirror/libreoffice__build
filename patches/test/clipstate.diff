A clipstate object, performing lazy updates of clip polygon

From: Thorsten Behrens <thb@openoffice.org>


---

 basegfx/inc/basegfx/tools/b2dclipstate.hxx |  111 +++++++
 basegfx/prj/d.lst                          |    2 
 basegfx/qa/mkpolygons.pl                   |    0 
 basegfx/source/tools/b2dclipstate.cxx      |  431 ++++++++++++++++++++++++++++
 basegfx/source/tools/makefile.mk           |    3 
 basegfx/test/basegfx2d.cxx                 |    6 
 basegfx/test/genericclipper.cxx            |  168 +++++++++++
 basegfx/test/makefile.mk                   |    1 
 slideshow/source/engine/slide/layer.cxx    |   11 -
 slideshow/source/engine/slide/layer.hxx    |    6 
 10 files changed, 729 insertions(+), 10 deletions(-)
 create mode 100644 basegfx/inc/basegfx/tools/b2dclipstate.hxx
 mode change 100644 => 100755 basegfx/qa/mkpolygons.pl
 create mode 100644 basegfx/source/tools/b2dclipstate.cxx
 create mode 100644 basegfx/test/genericclipper.cxx


diff --git basegfx/inc/basegfx/tools/b2dclipstate.hxx basegfx/inc/basegfx/tools/b2dclipstate.hxx
new file mode 100644
index 0000000..4ea041b
--- /dev/null
+++ basegfx/inc/basegfx/tools/b2dclipstate.hxx
@@ -0,0 +1,111 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: rectcliptools.hxx,v $
+ * $Revision: 1.3 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef _BGFX_TOOLS_CLIPSTATE_HXX
+#define _BGFX_TOOLS_CLIPSTATE_HXX
+
+#include <sal/types.h>
+#include <o3tl/cow_wrapper.hxx>
+
+//////////////////////////////////////////////////////////////////////////////
+
+namespace basegfx
+{
+    class B2DRange;
+    class B2DPolyRange;
+    class B2DPolygon;
+    class B2DPolyPolygon;
+
+    namespace tools
+    {
+        class ImplB2DClipState;
+
+        /** This class provides an optimized, symbolic clip state for graphical output
+
+            Having a current 'clip' state is a common attribute of
+            almost all graphic output APIs, most of which internally
+            represent it via a list of rectangular bands. In contrast,
+            this implementation purely uses symbolic clips, but in a
+            quite efficient manner, deferring actual evaluation until
+            a clip representation is requested, and using faster code
+            paths for common special cases (like all-rectangle clips)
+         */
+        class B2DClipState
+        {
+        public:
+            typedef o3tl::cow_wrapper< ImplB2DClipState > ImplType;
+
+        private:
+            ImplType mpImpl;
+
+        public:
+            B2DClipState();
+            ~B2DClipState();
+            B2DClipState( const B2DClipState& );
+            explicit B2DClipState( const B2DRange& );
+            explicit B2DClipState( const B2DPolygon& );
+            explicit B2DClipState( const B2DPolyPolygon& );
+            B2DClipState& operator=( const B2DClipState& );
+
+            /// unshare this poly-range with all internally shared instances
+            void makeUnique();
+            
+            void clear();
+
+            bool operator==(const B2DClipState&) const;
+            bool operator!=(const B2DClipState&) const;
+
+            void unionRange(const B2DRange& );
+            void unionPolygon(const B2DPolygon& );
+            void unionPolyPolygon(const B2DPolyPolygon& );
+            void unionClipState(const B2DClipState& );
+
+            void intersectRange(const B2DRange& );
+            void intersectPolygon(const B2DPolygon& );
+            void intersectPolyPolygon(const B2DPolyPolygon& );
+            void intersectClipState(const B2DClipState& );
+
+            void subtractRange(const B2DRange& );
+            void subtractPolygon(const B2DPolygon& );
+            void subtractPolyPolygon(const B2DPolyPolygon& );
+            void subtractClipState(const B2DClipState& );
+
+            void xorRange(const B2DRange& );
+            void xorPolygon(const B2DPolygon& );
+            void xorPolyPolygon(const B2DPolyPolygon& );
+            void xorClipState(const B2DClipState& );
+
+            B2DPolyPolygon getClipPoly() const;
+            B2DPolyRange   getClipRanges() const;
+        };
+    }
+}
+
+#endif // _BGFX_TOOLS_CLIPSTATE_HXX
diff --git basegfx/prj/d.lst basegfx/prj/d.lst
index 9dd6085..b9d3a10 100644
--- basegfx/prj/d.lst
+++ basegfx/prj/d.lst
@@ -27,7 +27,7 @@ mkdir: %_DEST%\inc%_EXT%\basegfx\range
 ..\inc\basegfx\range\basicrange.hxx %_DEST%\inc%_EXT%\basegfx\range\basicrange.hxx
 ..\inc\basegfx\range\basicbox.hxx %_DEST%\inc%_EXT%\basegfx\range\basicbox.hxx
 ..\inc\basegfx\range\b1drange.hxx %_DEST%\inc%_EXT%\basegfx\range\b1drange.hxx
-..\inc\basegfx\range\b2dmultirange.hxx %_DEST%\inc%_EXT%\basegfx\range\b2dmultirange.hxx
+..\inc\basegfx\range\b2dpolyrange.hxx %_DEST%\inc%_EXT%\basegfx\range\b2dpolyrange.hxx
 ..\inc\basegfx\range\b2drange.hxx %_DEST%\inc%_EXT%\basegfx\range\b2drange.hxx
 ..\inc\basegfx\range\b2drectangle.hxx %_DEST%\inc%_EXT%\basegfx\range\b2drectangle.hxx
 ..\inc\basegfx\range\b2dconnectedranges.hxx %_DEST%\inc%_EXT%\basegfx\range\b2dconnectedranges.hxx
diff --git basegfx/qa/mkpolygons.pl basegfx/qa/mkpolygons.pl
old mode 100644
new mode 100755
diff --git basegfx/source/tools/b2dclipstate.cxx basegfx/source/tools/b2dclipstate.cxx
new file mode 100644
index 0000000..76e2aaf
--- /dev/null
+++ basegfx/source/tools/b2dclipstate.cxx
@@ -0,0 +1,431 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: b2dmultirange.cxx,v $
+ * $Revision: 1.8 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_basegfx.hxx"
+#include <basegfx/tools/b2dclipstate.hxx>
+
+#include <basegfx/range/b2drange.hxx>
+#include <basegfx/range/b2dpolyrange.hxx>
+#include <basegfx/polygon/b2dpolygon.hxx>
+#include <basegfx/polygon/b2dpolygontools.hxx>
+#include <basegfx/polygon/b2dpolypolygon.hxx>
+#include <basegfx/polygon/b2dpolypolygontools.hxx>
+#include <basegfx/polygon/b2dpolypolygoncutter.hxx>
+
+namespace basegfx
+{
+namespace tools
+{
+    struct ImplB2DClipState
+    {
+    public:
+        enum Operation {UNION, INTERSECT, XOR};
+
+        ImplB2DClipState() :
+            maPending(),
+            maClipPoly(),
+            mePendingOps(UNION)
+        {}
+
+        explicit ImplB2DClipState( const B2DRange& rRange ) :
+            maPending(),
+            maClipPoly(
+                tools::createPolygonFromRect(rRange)),
+            mePendingOps(UNION)
+        {}
+
+        explicit ImplB2DClipState( const B2DPolygon& rPoly ) :
+            maPending(),
+            maClipPoly(rPoly),
+            mePendingOps(UNION)
+        {}
+
+        explicit ImplB2DClipState( const B2DPolyPolygon& rPoly ) :
+            maPending(),
+            maClipPoly(rPoly),
+            mePendingOps(UNION)
+        {}
+
+        void clear()
+        {
+            maPending.clear();
+            maClipPoly.clear();
+            mePendingOps = UNION;
+        }
+
+        bool operator==(const ImplB2DClipState& rRHS) const
+        {
+            return maPending == rRHS.maPending 
+                && maClipPoly == rRHS.maClipPoly 
+                && mePendingOps == rRHS.mePendingOps;
+        }
+
+        void unionRange(const B2DRange& rRange)
+        {
+            if( rRange.isEmpty() )
+                return;
+
+            if( maPending.count() && mePendingOps != UNION )
+                commitToPolygon();
+
+            mePendingOps = UNION;
+            maPending.append(
+                tools::createPolygonFromRect(rRange));
+        }
+
+        void unionPolygon(const B2DPolygon& rPoly)
+        {
+            if( maPending.count() && mePendingOps != UNION )
+                commitToPolygon();
+
+            mePendingOps = UNION;
+            maPending.append(
+                tools::prepareForPolygonOperation(rPoly));
+        }
+
+        void unionPolyPolygon(const B2DPolyPolygon& rPolyPoly)
+        {
+            if( maPending.count() && mePendingOps != UNION )
+                commitToPolygon();
+
+            mePendingOps = UNION;
+            maPending.append(
+                tools::prepareForPolygonOperation(rPolyPoly));
+        }
+
+        void unionClipState(const B2DClipState&)
+        {}
+        
+        void intersectRange(const B2DRange& rRange)
+        {
+            if( rRange.isEmpty() )
+                return;
+
+            if( maPending.count() && mePendingOps != INTERSECT )
+                commitToPolygon();
+
+            mePendingOps = INTERSECT;
+            maPending.append(
+                tools::createPolygonFromRect(rRange));
+        }
+
+        void intersectPolygon(const B2DPolygon& rPoly)
+        {
+            if( maPending.count() && mePendingOps != INTERSECT )
+                commitToPolygon();
+
+            mePendingOps = INTERSECT;
+            maPending.append(rPoly);
+        }
+
+        void intersectPolyPolygon(const B2DPolyPolygon& rPolyPoly)
+        {
+            if( maPending.count() && mePendingOps != INTERSECT )
+                commitToPolygon();
+
+            mePendingOps = INTERSECT;
+            maPending.append(rPolyPoly);
+        }
+
+        void intersectClipState(const tools::B2DClipState& )
+        {}
+        
+        void subtractRange(const B2DRange& rRange )
+        {
+            if( rRange.isEmpty() )
+                return;
+
+            // how unfortunate. subtract is not associative, cannot
+            // lump together
+            commitToPolygon();
+
+            maClipPoly = tools::solvePolygonOperationDiff(
+                maClipPoly,
+                B2DPolyPolygon(
+                    tools::createPolygonFromRect(rRange)));
+        }
+
+        void subtractPolygon(const B2DPolygon& rPoly)
+        {
+            // how unfortunate. subtract is not associative, cannot
+            // lump together
+            commitToPolygon();
+
+            maClipPoly = tools::solvePolygonOperationDiff(
+                maClipPoly, 
+                prepareForPolygonOperation(rPoly));
+        }
+
+        void subtractPolyPolygon(const B2DPolyPolygon& rPoly)
+        {
+            // how unfortunate. subtract is not associative, cannot
+            // lump together
+            commitToPolygon();
+
+            maClipPoly = tools::solvePolygonOperationDiff(
+                maClipPoly, 
+                prepareForPolygonOperation(rPoly));
+        }
+        
+        void subtractClipState(const B2DClipState& )
+        {}
+        
+        void xorRange(const B2DRange& rRange)
+        {
+            if( rRange.isEmpty() )
+                return;
+
+            if( maPending.count() && mePendingOps != XOR )
+                commitToPolygon();
+
+            mePendingOps = XOR;
+            maPending.append(
+                tools::createPolygonFromRect(rRange));
+        }
+
+        void xorPolygon(const B2DPolygon& rPoly)
+        {
+            if( maPending.count() && mePendingOps != XOR )
+                commitToPolygon();
+
+            mePendingOps = XOR;
+            maPending.append(rPoly);
+        }
+
+        void xorPolyPolygon(const B2DPolyPolygon& rPolyPoly)
+        {
+            if( maPending.count() && mePendingOps != XOR )
+                commitToPolygon();
+
+            mePendingOps = XOR;
+            maPending.append(rPolyPoly);
+        }
+
+        void xorClipState(const B2DClipState& )
+        {}
+        
+        B2DPolyPolygon getClipPoly() const
+        {
+            commitToPolygon();
+            return maClipPoly;
+        }
+
+        B2DPolyRange getClipRanges() const
+        {
+            return B2DPolyRange();
+        }
+
+    private:
+        void commitToPolygon() const
+        {
+            if( !maPending.count() )
+                return;
+
+            // assumption: maClipPoly has kept polygons prepared for
+            // clipping; i.e. no neutral polygons & correct
+            // orientation
+            maPending = tools::prepareForPolygonOperation(maPending);
+            switch(mePendingOps)
+            {
+                case UNION:
+                    maClipPoly = tools::solvePolygonOperationOr(
+                        maClipPoly,
+                        maPending);
+                    break;
+                case INTERSECT:
+                    maClipPoly = tools::solvePolygonOperationAnd(
+                        maClipPoly,
+                        maPending);
+                    break;
+                case XOR:
+                    maClipPoly = tools::solvePolygonOperationXor(
+                        maClipPoly,
+                        maPending);
+                    break;
+                default:
+                    OSL_ASSERT(false);
+            }
+
+            maPending.clear();
+            mePendingOps = UNION;
+        }
+        
+        mutable B2DPolyPolygon maPending;
+        mutable B2DPolyPolygon maClipPoly;
+        mutable Operation      mePendingOps;
+    };
+
+    B2DClipState::B2DClipState() :
+        mpImpl()
+    {}
+
+    B2DClipState::~B2DClipState()
+    {}
+
+    B2DClipState::B2DClipState( const B2DClipState& rOrig ) :
+        mpImpl(rOrig.mpImpl)
+    {}
+
+    B2DClipState::B2DClipState( const B2DRange& rRange ) :
+        mpImpl( ImplB2DClipState(rRange) )
+    {}
+
+    B2DClipState::B2DClipState( const B2DPolygon& rPoly ) :
+        mpImpl( ImplB2DClipState(rPoly) )
+    {}
+
+    B2DClipState::B2DClipState( const B2DPolyPolygon& rPolyPoly ) :
+        mpImpl( ImplB2DClipState(rPolyPoly) )
+    {}
+
+    B2DClipState& B2DClipState::operator=( const B2DClipState& rRHS )
+    {
+        mpImpl = rRHS.mpImpl;
+        return *this;
+    }
+
+    void B2DClipState::makeUnique()
+    {
+        mpImpl.make_unique();
+    }
+    
+    void B2DClipState::clear()
+    {
+        mpImpl->clear();
+    }
+
+    bool B2DClipState::operator==(const B2DClipState& rRHS) const
+    {
+        if(mpImpl.same_object(rRHS.mpImpl))
+            return true;
+
+        return ((*mpImpl) == (*rRHS.mpImpl));
+    }
+
+    bool B2DClipState::operator!=(const B2DClipState& rRHS) const
+    {
+        return !(*this == rRHS);
+    }
+
+    void B2DClipState::unionRange(const B2DRange& rRange)
+    {
+        mpImpl->unionRange(rRange);
+    }
+
+    void B2DClipState::unionPolygon(const B2DPolygon& rPoly)
+    {
+        mpImpl->unionPolygon(rPoly);
+    }
+
+    void B2DClipState::unionPolyPolygon(const B2DPolyPolygon& rPolyPoly)
+    {
+        mpImpl->unionPolyPolygon(rPolyPoly);
+    }
+
+    void B2DClipState::unionClipState(const B2DClipState& rState)
+    {
+        mpImpl->unionClipState(rState);
+    }
+
+    void B2DClipState::intersectRange(const B2DRange& rRange)
+    {
+        mpImpl->intersectRange(rRange);
+    }
+
+    void B2DClipState::intersectPolygon(const B2DPolygon& rPoly)
+    {
+        mpImpl->intersectPolygon(rPoly);
+    }
+
+    void B2DClipState::intersectPolyPolygon(const B2DPolyPolygon& rPolyPoly)
+    {
+        mpImpl->intersectPolyPolygon(rPolyPoly);
+    }
+
+    void B2DClipState::intersectClipState(const B2DClipState& rState)
+    {
+        mpImpl->intersectClipState(rState);
+    }
+
+    void B2DClipState::subtractRange(const B2DRange& rRange)
+    {
+        mpImpl->subtractRange(rRange);
+    }
+
+    void B2DClipState::subtractPolygon(const B2DPolygon& rPoly)
+    {
+        mpImpl->subtractPolygon(rPoly);
+    }
+
+    void B2DClipState::subtractPolyPolygon(const B2DPolyPolygon& rPolyPoly)
+    {
+        mpImpl->subtractPolyPolygon(rPolyPoly);
+    }
+
+    void B2DClipState::subtractClipState(const B2DClipState& rState)
+    {
+        mpImpl->subtractClipState(rState);
+    }
+    
+    void B2DClipState::xorRange(const B2DRange& rRange)
+    {
+        mpImpl->xorRange(rRange);
+    }
+
+    void B2DClipState::xorPolygon(const B2DPolygon& rPoly)
+    {
+        mpImpl->xorPolygon(rPoly);
+    }
+
+    void B2DClipState::xorPolyPolygon(const B2DPolyPolygon& rPolyPoly)
+    {
+        mpImpl->xorPolyPolygon(rPolyPoly);
+    }
+
+    void B2DClipState::xorClipState(const B2DClipState& rState)
+    {
+        mpImpl->xorClipState(rState);
+    }
+
+    B2DPolyPolygon B2DClipState::getClipPoly() const
+    {
+        return mpImpl->getClipPoly();
+    }
+
+    B2DPolyRange B2DClipState::getClipRanges() const
+    {
+        return mpImpl->getClipRanges();
+    }
+
+} // end of namespace tools
+} // end of namespace basegfx
+
+// eof
diff --git basegfx/source/tools/makefile.mk basegfx/source/tools/makefile.mk
index 1bede8b..01a6818 100755
--- basegfx/source/tools/makefile.mk
+++ basegfx/source/tools/makefile.mk
@@ -41,7 +41,8 @@ ENABLE_EXCEPTIONS=TRUE
 
 # --- Files -------------------------------------
 
-SLOFILES= $(SLO)$/canvastools.obj	\
+SLOFILES= $(SLO)$/b2dclipstate.obj	\
+          $(SLO)$/canvastools.obj	\
           $(SLO)$/gradienttools.obj	\
           $(SLO)$/debugplotter.obj	\
           $(SLO)$/liangbarsky.obj	\
diff --git basegfx/test/basegfx2d.cxx basegfx/test/basegfx2d.cxx
index 8b1d659..ef49c2e 100644
--- basegfx/test/basegfx2d.cxx
+++ basegfx/test/basegfx2d.cxx
@@ -319,6 +319,12 @@ public:
                                aRange.getElement(0).head == B2DRange(0,0,1,1));
         CPPUNIT_ASSERT_MESSAGE("simple poly range - second element", 
                                aRange.getElement(1).head == B2DRange(2,2,3,3));
+
+        // B2DPolyRange relies on correctly orientated rects
+        const B2DRange aRect(0,0,1,1);
+        CPPUNIT_ASSERT_MESSAGE("createPolygonFromRect - correct orientation", 
+                               tools::getOrientation(
+                                   tools::createPolygonFromRect(aRect)) == ORIENTATION_POSITIVE );
     }
 
     // Change the following lines only, if you add, remove or rename 
diff --git basegfx/test/genericclipper.cxx basegfx/test/genericclipper.cxx
new file mode 100644
index 0000000..70455fd
--- /dev/null
+++ basegfx/test/genericclipper.cxx
@@ -0,0 +1,168 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: basegfx2d.cxx,v $
+ * $Revision: 1.14 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_basegfx.hxx"
+// autogenerated file with codegen.pl
+
+#include <cppunit/simpleheader.hxx>
+
+#include <basegfx/matrix/b2dhommatrix.hxx>
+#include <basegfx/curve/b2dcubicbezier.hxx>
+#include <basegfx/curve/b2dbeziertools.hxx>
+#include <basegfx/range/b2dpolyrange.hxx>
+#include <basegfx/polygon/b2dpolygon.hxx>
+#include <basegfx/polygon/b2dpolygontools.hxx>
+#include <basegfx/polygon/b2dpolypolygontools.hxx>
+#include <basegfx/polygon/b2dpolypolygoncutter.hxx>
+#include <basegfx/polygon/b2dpolygonclipper.hxx>
+#include <basegfx/polygon/b2dpolypolygon.hxx>
+#include <basegfx/numeric/ftools.hxx>
+
+#include <boost/bind.hpp>
+
+using namespace ::basegfx;
+
+
+namespace basegfx2d
+{
+
+class genericclipper : public CppUnit::TestFixture
+{
+private:
+    B2DPolygon aSelfIntersecting;
+    B2DPolygon aShiftedRectangle;
+
+public:
+    // initialise your test code values here.
+    void setUp()
+    {
+        aSelfIntersecting.append(B2DPoint(0,  0));
+        aSelfIntersecting.append(B2DPoint(0,  100));
+        aSelfIntersecting.append(B2DPoint(75, 100));
+        aSelfIntersecting.append(B2DPoint(75, 50));
+        aSelfIntersecting.append(B2DPoint(25, 50));
+        aSelfIntersecting.append(B2DPoint(25, 150));
+        aSelfIntersecting.append(B2DPoint(100,150));
+        aSelfIntersecting.append(B2DPoint(100,0));
+        aSelfIntersecting.setClosed(true);
+
+        aShiftedRectangle = tools::createPolygonFromRect(
+            B2DRange(0,90,20,150));
+    }
+
+    void tearDown()
+    {}
+
+    void validate(const char* pName, 
+                  const char* pValidSvgD, 
+                  B2DPolyPolygon (*pFunc)(const B2DPolyPolygon&, const B2DPolyPolygon&))
+    {
+        const B2DPolyPolygon aSelfIntersect(
+            tools::prepareForPolygonOperation(aSelfIntersecting));
+        const B2DPolyPolygon aRect(
+            tools::prepareForPolygonOperation(aShiftedRectangle));
+#if defined(VERBOSE)
+        fprintf(stderr, "%s input LHS - svg:d=\"%s\"\n", 
+                pName, rtl::OUStringToOString(
+                    basegfx::tools::exportToSvgD(
+                        aSelfIntersect),
+                    RTL_TEXTENCODING_UTF8).getStr() );
+        fprintf(stderr, "%s input RHS - svg:d=\"%s\"\n", 
+                pName, rtl::OUStringToOString(
+                    basegfx::tools::exportToSvgD(
+                        aRect),
+                    RTL_TEXTENCODING_UTF8).getStr() );
+#endif
+
+        const B2DPolyPolygon aRes=
+            pFunc(aSelfIntersect, aRect);
+
+#if defined(VERBOSE)
+        fprintf(stderr, "%s - svg:d=\"%s\"\n", 
+                pName, rtl::OUStringToOString(
+                    basegfx::tools::exportToSvgD(aRes),
+                    RTL_TEXTENCODING_UTF8).getStr() );
+#endif
+
+        rtl::OUString aValid=rtl::OUString::createFromAscii(pValidSvgD);
+
+        CPPUNIT_ASSERT_MESSAGE(pName,
+                               basegfx::tools::exportToSvgD(aRes) == aValid);
+    }
+
+    void validateOr()
+    {
+        const char* pValid="m0 0h100v150h-75v-50h-5v50h-20v-50-10zm75 10v-50h-50v50z";
+        validate("validateOr", pValid, &tools::solvePolygonOperationOr);
+    }
+
+    void validateXor()
+    {
+        const char* pValid="m0 0h100v150h-75v-50h-5v50h-20v-50-10zm0 10h20v-10h-20zm75 10v-50h-50v50z";
+        validate("validateXor", pValid, &tools::solvePolygonOperationXor);
+    }
+
+    void validateAnd()
+    {
+        const char* pValid="m0 100v-10h20v10z";
+        validate("validateAnd", pValid, &tools::solvePolygonOperationAnd);
+    }
+
+    void validateDiff()
+    {
+        const char* pValid="m0 90v-90h100v150h-75v-50h-5v-10zm55 10v-50h-50v50z";
+        validate("validateDiff", pValid, &tools::solvePolygonOperationDiff);
+    }
+
+    // Change the following lines only, if you add, remove or rename 
+    // member functions of the current class, 
+    // because these macros are need by auto register mechanism.
+
+    CPPUNIT_TEST_SUITE(genericclipper);
+    CPPUNIT_TEST(validateOr);
+    CPPUNIT_TEST(validateXor);
+    CPPUNIT_TEST(validateAnd);
+    CPPUNIT_TEST(validateDiff);
+    CPPUNIT_TEST_SUITE_END();
+};
+
+// -----------------------------------------------------------------------------
+CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(basegfx2d::genericclipper, "genericclipper");
+} // namespace basegfx2d
+
+
+// -----------------------------------------------------------------------------
+
+// this macro creates an empty function, which will called by the RegisterAllFunctions()
+// to let the user the possibility to also register some functions by hand.
+// NOADDITIONAL;
+
diff --git basegfx/test/makefile.mk basegfx/test/makefile.mk
index 320bd0c..4ca75c1 100644
--- basegfx/test/makefile.mk
+++ basegfx/test/makefile.mk
@@ -47,6 +47,7 @@ SHL1OBJS=  \
     $(SLO)$/basegfx2d.obj \
     $(SLO)$/basegfx3d.obj \
     $(SLO)$/boxclipper.obj \
+    $(SLO)$/genericclipper.obj \
     $(SLO)$/testtools.obj	
 
 # linking statically against basegfx parts
diff --git slideshow/source/engine/slide/layer.cxx slideshow/source/engine/slide/layer.cxx
index f56de72..f9d35b6 100644
--- slideshow/source/engine/slide/layer.cxx
+++ slideshow/source/engine/slide/layer.cxx
@@ -36,7 +36,7 @@
 
 #include <basegfx/range/b2drange.hxx>
 #include <basegfx/range/b1drange.hxx>
-#include <basegfx/range/b2dmultirange.hxx>
+#include <basegfx/range/b2dpolyrange.hxx>
 #include <basegfx/matrix/b2dhommatrix.hxx>
 #include <basegfx/polygon/b2dpolypolygon.hxx>
 
@@ -202,7 +202,8 @@ namespace slideshow
         {
             // TODO(Q1): move this to B2DMultiRange
             if( !rUpdateRange.isEmpty() )
-                maUpdateAreas.addRange( rUpdateRange );
+                maUpdateAreas.appendElement( rUpdateRange, 
+                                             basegfx::ORIENTATION_POSITIVE );
         }
 
         void Layer::updateBounds( ShapeSharedPtr const& rShape )
@@ -248,7 +249,7 @@ namespace slideshow
         
         void Layer::clearUpdateRanges()
         {
-            maUpdateAreas.reset();
+            maUpdateAreas.clear();
         }
 
         void Layer::clearContent()
@@ -284,12 +285,12 @@ namespace slideshow
 
         Layer::EndUpdater Layer::beginUpdate()
         {
-            if( !maUpdateAreas.isEmpty() )
+            if( maUpdateAreas.count() )
             {
                 // perform proper layer update. That means, setup proper
                 // clipping, and render each shape that intersects with 
                 // the calculated update area
-                ::basegfx::B2DPolyPolygon aClip( maUpdateAreas.getPolyPolygon() );
+                ::basegfx::B2DPolyPolygon aClip( maUpdateAreas.solveCrossovers() );
 
                 // actually, if there happen to be shapes with zero
                 // update area in the maUpdateAreas vector, the
diff --git slideshow/source/engine/slide/layer.hxx slideshow/source/engine/slide/layer.hxx
index 619f1e9..3f293ca 100644
--- slideshow/source/engine/slide/layer.hxx
+++ slideshow/source/engine/slide/layer.hxx
@@ -31,7 +31,7 @@
 #ifndef INCLUDED_SLIDESHOW_LAYER_HXX
 #define INCLUDED_SLIDESHOW_LAYER_HXX
 
-#include <basegfx/range/b2dmultirange.hxx>
+#include <basegfx/range/b2dpolyrange.hxx>
 #include <cppcanvas/spritecanvas.hxx>
 
 #include "view.hxx"
@@ -187,7 +187,7 @@ namespace slideshow
                 @return true, if any non-empty addUpdateRange() calls
                 have been made since the last render()/update() call.
              */
-            bool isUpdatePending() const { return !maUpdateAreas.isEmpty(); }
+            bool isUpdatePending() const { return maUpdateAreas.count()!=0; }
 
             /** Update layer bound rect from shape bounds
              */
@@ -297,7 +297,7 @@ namespace slideshow
             typedef ::std::vector< ViewEntry > ViewEntryVector;
 
             ViewEntryVector            maViewEntries;
-            basegfx::B2DMultiRange     maUpdateAreas;
+            basegfx::B2DPolyRange      maUpdateAreas;
             basegfx::B2DRange          maBounds;
             basegfx::B2DRange          maNewBounds;
             const basegfx::B2DRange    maMaxBounds;       // maBounds is clipped against this
