Move slideshow to drawinglayer primitives

From: Thorsten Behrens <thb@openoffice.org>


---

 slideshow/source/engine/shapes/drawshape.cxx |   15 ++++-
 slideshow/source/engine/shapes/drawshape.hxx |    5 ++
 slideshow/source/engine/shapes/viewshape.cxx |   84 ++++++++++++++++----------
 slideshow/source/engine/shapes/viewshape.hxx |   33 ++++++++++
 slideshow/source/engine/slide/slideimpl.cxx  |    9 ++-
 slideshow/source/engine/slideshowcontext.cxx |    8 ++
 slideshow/source/engine/slideshowimpl.cxx    |    3 +
 slideshow/source/inc/slideshowcontext.hxx    |   14 +++-
 slideshow/util/makefile.mk                   |    1 
 .../drawinglayer/processor2d/canvasprocessor.hxx   |    4 
 .../source/processor2d/canvasprocessor.cxx         | 1480 ++------------------
 offapi/com/sun/star/graphic/XPrimitive2D.idl       |   21 
 .../com/sun/star/graphic/XPrimitiveFactory2D.idl   |   72 +
 13 files changed, 252 insertions(+), 1325 deletions(-)


diff --git drawinglayer/inc/drawinglayer/processor2d/canvasprocessor.hxx drawinglayer/inc/drawinglayer/processor2d/canvasprocessor.hxx
index 8e46feb..55e89e3 100644
--- drawinglayer/inc/drawinglayer/processor2d/canvasprocessor.hxx
+++ drawinglayer/inc/drawinglayer/processor2d/canvasprocessor.hxx
@@ -120,6 +120,10 @@ namespace drawinglayer
 			canvasProcessor2D(
 				const geometry::ViewInformation2D& rViewInformation, 
                 OutputDevice& rOutDev);
+			canvasProcessor2D(
+				const geometry::ViewInformation2D& rViewInformation, 
+                const com::sun::star::uno::Reference< com::sun::star::rendering::XCanvas >& xCanvas,
+                const com::sun::star::rendering::ViewState& rViewState );
 			virtual ~canvasProcessor2D();
 
 			// access to Drawinglayer configuration options
diff --git drawinglayer/source/processor2d/canvasprocessor.cxx drawinglayer/source/processor2d/canvasprocessor.cxx
index f99634f..6695cb4 100644
--- drawinglayer/source/processor2d/canvasprocessor.cxx
+++ drawinglayer/source/processor2d/canvasprocessor.cxx
@@ -81,1206 +81,6 @@
 
 using namespace com::sun::star;
 
-//////////////////////////////////////////////////////////////////////////////
-// AW: Adding the canvas example from THB here to extract stuff later
-/*
-        // TODO(Q3): share impCreateEmptyBitmapWithPattern() and other
-        // helper methods with vclprocessor.cxx
-		Bitmap impCreateEmptyBitmapWithPattern(Bitmap aSource, const Size& aTargetSizePixel)
-		{
-			Bitmap aRetval;
-			BitmapReadAccess* pReadAccess = aSource.AcquireReadAccess();
-
-			if(pReadAccess)
-			{
-				if(aSource.GetBitCount() <= 8)
-				{
-					BitmapPalette aPalette(pReadAccess->GetPalette());
-					aRetval = Bitmap(aTargetSizePixel, aSource.GetBitCount(), &aPalette);
-				}
-				else
-				{
-					aRetval = Bitmap(aTargetSizePixel, aSource.GetBitCount());
-				}
-
-				delete pReadAccess;
-			}
-
-			return aRetval;
-		}
-
-		Bitmap impModifyBitmap(const basegfx::BColorModifier& rModifier, const Bitmap& rSource)
-		{
-			Bitmap aRetval(rSource);
-
-			switch(rModifier.getMode())
-			{
-				case basegfx::BCOLORMODIFYMODE_REPLACE :
-				{
-					aRetval = impCreateEmptyBitmapWithPattern(aRetval, Size(1L, 1L));
-					aRetval.Erase(Color(rModifier.getBColor()));
-					break;
-				}
-
-				default : // BCOLORMODIFYMODE_INTERPOLATE, BCOLORMODIFYMODE_GRAY, BCOLORMODIFYMODE_BLACKANDWHITE
-				{
-					BitmapWriteAccess* pContent = aRetval.AcquireWriteAccess();
-
-					if(pContent)
-					{
-						for(sal_uInt32 y(0L); y < (sal_uInt32)pContent->Height(); y++)
-						{
-							for(sal_uInt32 x(0L); x < (sal_uInt32)pContent->Width(); x++)
-							{
-                                const Color aColor = pContent->GetPixel(y, x);
-								const basegfx::BColor aBColor(rModifier.getModifiedColor(aColor.getBColor()));
-								pContent->SetPixel(y, x, BitmapColor(Color(aBColor)));
-							}
-						}
-
-						delete pContent;
-					}
-					
-					break;
-				}
-			}
-
-			return aRetval;
-		}
-
-		Bitmap impModifyBitmap(const basegfx::BColorModifierStack& rBColorModifierStack, const Bitmap& rSource)
-		{
-			Bitmap aRetval(rSource);
-
-			for(sal_uInt32 a(rBColorModifierStack.count()); a; )
-			{
-				const basegfx::BColorModifier& rModifier = rBColorModifierStack.getBColorModifier(--a);
-				aRetval = impModifyBitmap(rModifier, aRetval);
-			}
-
-			return aRetval;
-		}
-
-		sal_uInt32 impCalcGradientSteps(sal_uInt32 nSteps, const basegfx::B2DRange& rRange, sal_uInt32 nMaxDist)
-		{
-			if(nSteps == 0L)
-				nSteps = (sal_uInt32)(rRange.getWidth() + rRange.getHeight()) / 8;
-
-			if(nSteps < 2L)
-			{
-				nSteps = 2L;
-			}
-
-			if(nSteps > nMaxDist)
-			{
-				nSteps = nMaxDist;
-			}
-
-			return nSteps;
-		}
-
-        void canvasProcessor::impDrawGradientSimple(
-			const basegfx::B2DPolyPolygon& rTargetForm,
-			const ::std::vector< basegfx::B2DHomMatrix >& rMatrices,
-			const ::std::vector< basegfx::BColor >& rColors,
-			const basegfx::B2DPolygon& rUnitPolygon)
-		{
-            uno::Reference< rendering::XPolyPolygon2D > xPoly(
-                basegfx::unotools::xPolyPolygonFromB2DPolygon(
-                    mxCanvas->getDevice(),
-                    rUnitPolygon));
-            uno::Reference< rendering::XPolyPolygon2D > xTargetPoly(
-                basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(
-                    mxCanvas->getDevice(),
-                    rTargetForm));
-                                                       
-			for(sal_uInt32 a(0L); a < rColors.size(); a++)
-			{
-				// set correct color
-				const basegfx::BColor aFillColor(rColors[a]);
-
-                maRenderState.DeviceColor = basegfx::unotools::colorToDoubleSequence(
-                    mxCanvas->getDevice(),
-                    aFillColor);
-
-				if(a)
-				{
-					if(a - 1L < rMatrices.size())
-					{
-                        canvas::tools::setRenderStateTransform( maRenderState, 
-                                                                rMatrices[a - 1L] );
-						mxCanvas->fillPolyPolygon(xPoly,maViewState,maRenderState);
-					}
-				}
-				else
-				{
-                    canvas::tools::setRenderStateTransform( maRenderState, 
-                                                            basegfx::B2DHomMatrix() );
-					mxCanvas->fillPolyPolygon(xTargetPoly,maViewState,maRenderState);
-				}
-			}
-		}
-
-		void canvasProcessor::impDrawGradientComplex(
-			const basegfx::B2DPolyPolygon& rTargetForm,
-			const ::std::vector< basegfx::B2DHomMatrix >& rMatrices,
-			const ::std::vector< basegfx::BColor >& rColors,
-			const basegfx::B2DPolygon& rUnitPolygon)
-		{
-            uno::Reference< rendering::XPolyPolygon2D > xPoly(
-                basegfx::unotools::xPolyPolygonFromB2DPolygon(
-                    mxCanvas->getDevice(),
-                    rUnitPolygon));
-            uno::Reference< rendering::XPolyPolygon2D > xTargetPoly(
-                basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(
-                    mxCanvas->getDevice(),
-                    rTargetForm));
-
-            maRenderState.Clip = xTargetPoly;
-
-			// draw gradient PolyPolygons
-			for(std::size_t a = 0L; a < rMatrices.size(); a++)
-			{
-				// set correct color
-				if(rColors.size() > a)
-				{
-                    const basegfx::BColor aFillColor(rColors[a]);
-                    
-                    maRenderState.DeviceColor = basegfx::unotools::colorToDoubleSequence(
-                        mxCanvas->getDevice(),
-                        aFillColor);
-				}
-                
-                canvas::tools::setRenderStateTransform( maRenderState, 
-                                                        rMatrices[a] );
-                
-				if(a)
-                    mxCanvas->fillPolyPolygon(xPoly,maViewState,maRenderState);
-				else
-					mxCanvas->fillPolyPolygon(xTargetPoly,maViewState,maRenderState);
-            }
-
-            maRenderState.Clip.clear();
-		}
-
-		void canvasProcessor::impDrawGradient(
-			const basegfx::B2DPolyPolygon& rTargetForm, 
-			::drawinglayer::primitive::GradientStyle eGradientStyle, 
-			sal_uInt32 nSteps,
-			const basegfx::BColor& rStart,
-			const basegfx::BColor& rEnd,
-			double fBorder, double fAngle, double fOffsetX, double fOffsetY, bool bSimple)
-		{
-            fprintf(stderr,"impDrawGradient\n");
-
-			basegfx::B2DPolyPolygon aTmp(rTargetForm);
-            aTmp.transform( maWorldToView );
-			const basegfx::B2DRange aOutlineRangePixel(basegfx::tools::getRange(aTmp));
-			const basegfx::B2DRange aOutlineRange(basegfx::tools::getRange(rTargetForm));
-
-            fprintf(stderr,"impDrawGradient: #%d\n",nSteps);
-
-            if( // step count is infinite, can use native canvas
-                // gradients here
-                nSteps == 0 ||
-                // step count is sufficiently high, such that no
-                // discernible difference should be visible.
-                nSteps > 64 ) 
-            {
-                uno::Reference< rendering::XParametricPolyPolygon2DFactory > xFactory(
-                    mxCanvas->getDevice()->getParametricPolyPolygonFactory() );
-
-                if( xFactory.is() )
-                {
-                    fprintf(stderr,"native gradient #1\n");
-
-                    basegfx::B2DHomMatrix aTextureTransformation;
-                    rendering::Texture 		aTexture;
-
-                    aTexture.RepeatModeX = rendering::TexturingMode::CLAMP;
-                    aTexture.RepeatModeY = rendering::TexturingMode::CLAMP;
-                    aTexture.Alpha = 1.0;
-
-
-                    // setup start/end color values
-                    // ----------------------------
-
-                    const uno::Sequence< double > aStartColor(
-                        basegfx::unotools::colorToDoubleSequence( mxCanvas->getDevice(),
-                                                                  rStart ));
-                    const uno::Sequence< double > aEndColor(
-                        basegfx::unotools::colorToDoubleSequence( mxCanvas->getDevice(),
-                                                                  rEnd ));
-
-                    // Setup texture transformation
-                    // ----------------------------
-                    
-                    const basegfx::B2DRange& rBounds( 
-                        basegfx::tools::getRange( rTargetForm ));
-
-                    // setup rotation angle. VCL rotates
-                    // counter-clockwise, while canvas transformation
-                    // rotates clockwise
-                    //fAngle = -fAngle;
-
-                    switch(eGradientStyle)
-                    {
-                        case ::drawinglayer::primitive::GRADIENTSTYLE_LINEAR:
-                            // FALLTHROUGH intended
-                        case ::drawinglayer::primitive::GRADIENTSTYLE_AXIAL:
-                        {
-                            // standard orientation for VCL linear
-                            // gradient is vertical, thus, rotate 90
-                            // degrees
-                            fAngle += M_PI/2.0;
-
-                            // shrink texture, to account for border
-                            // (only in x direction, linear gradient
-                            // is constant in y direction, anyway)
-                            aTextureTransformation.scale( 
-                                basegfx::pruneScaleValue(1.0 - fBorder),
-                                1.0 );
-
-                            double fBorderX(0.0);
-
-                            // determine type of gradient (and necessary
-                            // transformation matrix, should it be emulated by a
-                            // generic gradient)
-                            switch(eGradientStyle)
-                            {
-                                case ::drawinglayer::primitive::GRADIENTSTYLE_LINEAR:
-                                    // linear gradients don't respect
-                                    // offsets (they are implicitely
-                                    // assumed to be 50%). linear
-                                    // gradients don't have border on
-                                    // both sides, only on the
-                                    // startColor side. Gradient is
-                                    // invariant in y direction: leave
-                                    // y offset alone.
-                                    fBorderX = fBorder;
-                                    aTexture.Gradient = xFactory->createLinearHorizontalGradient( aStartColor,
-                                                                                                  aEndColor );
-                                    break;
-
-                                case ::drawinglayer::primitive::GRADIENTSTYLE_AXIAL:
-                                    // axial gradients have border on
-                                    // both sides. Gradient is
-                                    // invariant in y direction: leave
-                                    // y offset alone.
-                                    fBorderX = fBorder * .5;
-                                    aTexture.Gradient = xFactory->createAxialHorizontalGradient( aStartColor,
-                                                                                                 aEndColor );
-                                    break;
-                            }
-
-                            // apply border offset values
-                            aTextureTransformation.translate( fBorderX, 
-                                                              0.0 );
-
-                            // rotate texture according to gradient rotation
-                            aTextureTransformation.translate( -0.5, -0.5 );
-                            aTextureTransformation.rotate( fAngle );
-
-                            // to let the first strip of a rotated
-                            // gradient start at the _edge_ of the
-                            // bound rect (and not, due to rotation,
-                            // slightly inside), slightly enlarge the
-                            // gradient:
-                            // 
-                            // y/2 sin(alpha) + x/2 cos(alpha)
-                            //
-                            // (values to change are not actual
-                            // gradient scales, but original bound
-                            // rect dimensions. Since we still want
-                            // the border setting to apply after that,
-                            // we multiply with that as above for
-                            // nScaleX)
-                            const double nScale( 
-                                basegfx::pruneScaleValue(
-                                    fabs( rBounds.getHeight()*sin(fAngle) ) + 
-                                    fabs( rBounds.getWidth()*cos(fAngle) )));
-
-                            aTextureTransformation.scale( nScale, nScale );
-
-                            // translate back origin to center of
-                            // primitive
-                            aTextureTransformation.translate( 0.5*rBounds.getWidth(),
-                                                              0.5*rBounds.getHeight() );
-                            break;
-                        }
-
-                        case ::drawinglayer::primitive::GRADIENTSTYLE_RADIAL:
-                            // FALLTHROUGH intended
-                        case ::drawinglayer::primitive::GRADIENTSTYLE_ELLIPTICAL:
-                            // FALLTHROUGH intended
-                        case ::drawinglayer::primitive::GRADIENTSTYLE_SQUARE:
-                            // FALLTHROUGH intended
-                        case ::drawinglayer::primitive::GRADIENTSTYLE_RECT:
-                        {
-                            fprintf(stderr,"native gradient #2\n");
-
-                            // determine scale factors for the gradient (must
-                            // be scaled up from [0,1]x[0,1] rect to object
-                            // bounds). Will potentially changed in switch
-                            // statement below.
-                            // Respect border value, while doing so, the VCL
-                            // gradient's border will effectively shrink the
-                            // resulting gradient.
-                            double nScaleX( rBounds.getWidth() * (1.0 - fBorder) );
-                            double nScaleY( rBounds.getHeight()* (1.0 - fBorder) );
-
-                            // determine offset values. Since the
-                            // border is divided half-by-half to both
-                            // sides of the gradient, divide
-                            // translation offset by an additional
-                            // factor of 2. Also respect offset here,
-                            // but since VCL gradients have their
-                            // center at [0,0] for zero offset, but
-                            // canvas gradients have their top, left
-                            // edge aligned with the primitive, and
-                            // offset of 50% effectively must yield
-                            // zero shift. Both values will
-                            // potentially be adapted in switch
-                            // statement below.
-                            double nOffsetX( rBounds.getWidth() * 
-                                             (2.0 * fOffsetX - 1.0 + fBorder)*.5 );
-                            double nOffsetY( rBounds.getHeight() * 
-                                             (2.0 * fOffsetY - 1.0 + fBorder)*.5 );
-
-                            // determine type of gradient (and necessary
-                            // transformation matrix, should it be emulated by a
-                            // generic gradient)
-                            switch(eGradientStyle)
-                            {
-                                case ::drawinglayer::primitive::GRADIENTSTYLE_RADIAL:
-                                {
-                                    // create isotrophic scaling
-                                    if( nScaleX > nScaleY )
-                                    {
-                                        nOffsetY -= (nScaleX - nScaleY) * 0.5;
-                                        nScaleY = nScaleX;
-                                    }
-                                    else
-                                    {
-                                        nOffsetX -= (nScaleY - nScaleX) * 0.5;
-                                        nScaleX = nScaleY;
-                                    }
-
-                                    // enlarge gradient to match bound rect diagonal
-                                    aTextureTransformation.translate( -0.5, -0.5 );
-                                    const double nScale( hypot(rBounds.getWidth(), 
-                                                               rBounds.getHeight()) / nScaleX );
-                                    aTextureTransformation.scale( nScale, nScale );
-                                    aTextureTransformation.translate( 0.5, 0.5 );
-
-                                    aTexture.Gradient = xFactory->createEllipticalGradient( 
-                                        aEndColor,
-                                        aStartColor,
-                                        cssgeom::RealRectangle2D(0.0,0.0,
-                                                                 1.0,1.0) );
-                                }
-                                break;
-
-                                case ::drawinglayer::primitive::GRADIENTSTYLE_ELLIPTICAL:
-                                {
-                                    // enlarge gradient slightly
-                                    aTextureTransformation.translate( -0.5, -0.5 );
-                                    const double nSqrt2( sqrt(2.0) );
-                                    aTextureTransformation.scale( nSqrt2,nSqrt2 );
-                                    aTextureTransformation.translate( 0.5, 0.5 );
-
-                                    aTexture.Gradient = xFactory->createEllipticalGradient( 
-                                        aEndColor,
-                                        aStartColor,
-                                        cssgeom::RealRectangle2D( rBounds.getMinX(),
-                                                                  rBounds.getMinY(),
-                                                                  rBounds.getMaxX(),
-                                                                  rBounds.getMaxY() ));
-                                }
-                                break;
-
-                                case ::drawinglayer::primitive::GRADIENTSTYLE_SQUARE:
-                                {
-                                    // create isotrophic scaling
-                                    if( nScaleX > nScaleY )
-                                    {
-                                        nOffsetY -= (nScaleX - nScaleY) * 0.5;
-                                        nScaleY = nScaleX;
-                                    }
-                                    else
-                                    {
-                                        nOffsetX -= (nScaleY - nScaleX) * 0.5;
-                                        nScaleX = nScaleY;
-                                    }
-
-                                    aTexture.Gradient = xFactory->createRectangularGradient( 
-                                        aEndColor,
-                                        aStartColor,
-                                        cssgeom::RealRectangle2D(0.0,0.0,
-                                                                 1.0,1.0));
-                                }
-                                break;
-
-                                case ::drawinglayer::primitive::GRADIENTSTYLE_RECT:
-                                {
-                                    aTexture.Gradient = xFactory->createRectangularGradient( 
-                                        aEndColor,
-                                        aStartColor,
-                                        cssgeom::RealRectangle2D( rBounds.getMinX(),
-                                                                  rBounds.getMinY(),
-                                                                  rBounds.getMaxX(),
-                                                                  rBounds.getMaxY() ));
-                                }
-                                break;
-                            }
-
-                            nScaleX = basegfx::pruneScaleValue( nScaleX );
-                            nScaleY = basegfx::pruneScaleValue( nScaleY );
-
-                            aTextureTransformation.scale( nScaleX, nScaleY );
-
-                            // rotate texture according to gradient rotation
-                            aTextureTransformation.translate( -0.5*nScaleX, -0.5*nScaleY );
-                            aTextureTransformation.rotate( fAngle );
-                            aTextureTransformation.translate( 0.5*nScaleX, 0.5*nScaleY );
-                            
-                            aTextureTransformation.translate( nOffsetX, nOffsetY );
-                        }
-                        break;
-
-                        default:
-                            OSL_ENSURE( false,
-                                        "canvasProcessor::impDrawGradient(): Unexpected gradient type" );
-                            break;
-                    }
-
-                    // As the texture coordinate space is relative to
-                    // the polygon coordinate space (NOT to the
-                    // polygon itself), move gradient to the start of
-                    // the actual polygon. If we skip this, the
-                    // gradient will always display at the origin, and
-                    // not within the polygon bound (which might be
-                    // miles away from the origin).
-                    aTextureTransformation.translate( rBounds.getMinX(), 
-                                                      rBounds.getMinY() );
-
-                    basegfx::unotools::affineMatrixFromHomMatrix( aTexture.AffineTransform, 
-                                                                    aTextureTransformation );
-                    uno::Sequence< rendering::Texture > aSeq(1);
-                    aSeq[0] = aTexture;
-
-                    mxCanvas->fillTexturedPolyPolygon( 
-                        basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(
-                            mxCanvas->getDevice(),
-                            rTargetForm),
-                        maViewState,
-                        maRenderState,
-                        aSeq );
-
-                    // done, using native gradients
-                    return;
-                }
-            }
-            else
-            {
-                // make sure steps is not too high/low
-                nSteps = impCalcGradientSteps(nSteps, 
-                                              aOutlineRangePixel, 
-                                              sal_uInt32((rStart.getMaximumDistance(rEnd) * 127.5) + 0.5));
-
-
-                ::std::vector< basegfx::B2DHomMatrix > aMatrices;
-                ::std::vector< basegfx::BColor > aColors;
-                basegfx::B2DPolygon aUnitPolygon;
-
-                if( drawinglayer::primitive::GRADIENTSTYLE_RADIAL == eGradientStyle || 
-                    drawinglayer::primitive::GRADIENTSTYLE_ELLIPTICAL == eGradientStyle)
-                {
-                    const basegfx::B2DPoint aCircleCenter(0.5, 0.5);
-                    aUnitPolygon = basegfx::tools::createPolygonFromEllipse(aCircleCenter, 0.5, 0.5);
-                    aUnitPolygon = basegfx::tools::adaptiveSubdivideByAngle(aUnitPolygon);
-                }
-                else
-                {
-                    aUnitPolygon = basegfx::tools::createPolygonFromRect(
-                        basegfx::B2DRange(0.0, 0.0, 1.0, 1.0));
-                }
-
-                // create geometries
-                switch(eGradientStyle)
-                {
-                    case ::drawinglayer::primitive::GRADIENTSTYLE_LINEAR:
-                    {
-                        ::drawinglayer::primitive::geoTexSvxGradientLinear aGradient(aOutlineRange, rStart, rEnd, nSteps, fBorder, fAngle);
-                        aGradient.appendTransformations(aMatrices);
-                        aGradient.appendColors(aColors);
-                        break;
-                    }
-                    case ::drawinglayer::primitive::GRADIENTSTYLE_AXIAL:
-                    {
-                        ::drawinglayer::primitive::geoTexSvxGradientAxial aGradient(aOutlineRange, rStart, rEnd, nSteps, fBorder, fAngle);
-                        aGradient.appendTransformations(aMatrices);
-                        aGradient.appendColors(aColors);
-                        break;
-                    }
-                    case ::drawinglayer::primitive::GRADIENTSTYLE_RADIAL:
-                    {
-                        ::drawinglayer::primitive::geoTexSvxGradientRadial aGradient(aOutlineRange, rStart, rEnd, nSteps, fBorder, fOffsetX, fOffsetY);
-                        aGradient.appendTransformations(aMatrices);
-                        aGradient.appendColors(aColors);
-                        break;
-                    }
-                    case ::drawinglayer::primitive::GRADIENTSTYLE_ELLIPTICAL:
-                    {
-                        ::drawinglayer::primitive::geoTexSvxGradientElliptical aGradient(aOutlineRange, rStart, rEnd, nSteps, fBorder, fOffsetX, fOffsetX, fAngle);
-                        aGradient.appendTransformations(aMatrices);
-                        aGradient.appendColors(aColors);
-                        break;
-                    }
-                    case ::drawinglayer::primitive::GRADIENTSTYLE_SQUARE:
-                    {
-                        ::drawinglayer::primitive::geoTexSvxGradientSquare aGradient(aOutlineRange, rStart, rEnd, nSteps, fBorder, fOffsetX, fOffsetX, fAngle);
-                        aGradient.appendTransformations(aMatrices);
-                        aGradient.appendColors(aColors);
-                        break;
-                    }
-                    case ::drawinglayer::primitive::GRADIENTSTYLE_RECT:
-                    {
-                        ::drawinglayer::primitive::geoTexSvxGradientRect aGradient(aOutlineRange, rStart, rEnd, nSteps, fBorder, fOffsetX, fOffsetX, fAngle);
-                        aGradient.appendTransformations(aMatrices);
-                        aGradient.appendColors(aColors);
-                        break;
-                    }
-                }
-
-                // paint them with mask using the XOR method
-                if(aMatrices.size())
-                {
-                    if(bSimple)
-                    {
-                        impDrawGradientSimple(rTargetForm, aMatrices, aColors, aUnitPolygon);
-                    }
-                    else
-                    {
-                        impDrawGradientComplex(rTargetForm, aMatrices, aColors, aUnitPolygon);
-                    }
-                }
-            }
-		}
-
-
-		//////////////////////////////////////////////////////////////////////////////
-		// rendering support
-
-		// directdraw of text simple portion
-		void canvasProcessor::impRender_STXP(const textSimplePortionPrimitive& rTextCandidate)
-		{
-            const fontAttributes&  rFontAttrs( rTextCandidate.getFontAttributes() );
-            rendering::FontRequest aFontRequest;
-
-            aFontRequest.FontDescription.FamilyName   = rFontAttrs.maFamilyName;
-            aFontRequest.FontDescription.StyleName    = rFontAttrs.maStyleName;
-            aFontRequest.FontDescription.IsSymbolFont = rFontAttrs.mbSymbol ? util::TriState_YES : util::TriState_NO;
-            aFontRequest.FontDescription.IsVertical   = rFontAttrs.mbVertical ? util::TriState_YES : util::TriState_NO;
-
-            // TODO(F2): improve vclenum->panose conversion
-            aFontRequest.FontDescription.FontDescription.Weight = 
-                rFontAttrs.mnWeight;
-            aFontRequest.FontDescription.FontDescription.Letterform = 
-                rFontAttrs.mbItalic ? 9 : 0;
-
-            // font matrix should only be used for glyph rotations etc.
-            css::geometry::Matrix2D aFontMatrix;
-            canvas::tools::setIdentityMatrix2D( aFontMatrix );
-
-            uno::Reference<rendering::XCanvasFont> xFont(
-                mxCanvas->createFont( aFontRequest,
-                                      uno::Sequence< beans::PropertyValue >(),
-                                      aFontMatrix ));
-
-            if( !xFont.is() )
-                return;
-
-            uno::Reference<rendering::XTextLayout> xLayout(
-                xFont->createTextLayout( 
-                    rendering::StringContext( rTextCandidate.getText(), 
-                                              0, 
-                                              rTextCandidate.getText().Len() ), 
-                    // TODO(F3): Is this sufficient?
-                    rendering::TextDirection::WEAK_LEFT_TO_RIGHT, 
-                    0 ));
-            if( !xLayout.is() )
-                return;
-
-            xLayout->applyLogicalAdvancements( 
-                uno::Sequence<double>(&rTextCandidate.getDXArray()[0],
-                                      rTextCandidate.getDXArray().size() ));
-
-			const basegfx::BColor aRGBColor(
-                maBColorModifierStack.getModifiedColor(
-                    rTextCandidate.getFontColor()));
-
-            maRenderState.DeviceColor = basegfx::unotools::colorToDoubleSequence(
-                mxCanvas->getDevice(),
-                aRGBColor);
-
-            // get render parameters and paint
-            mxCanvas->drawTextLayout( xLayout, 
-                                      maViewState, 
-                                      maRenderState );
-        }
-
-		// direct draw of hairline
-		void canvasProcessor::impRender_POHL(const polygonHairlinePrimitive& rPolygonCandidate)
-		{
-			const basegfx::BColor aRGBColor(
-                maBColorModifierStack.getModifiedColor(
-                    rPolygonCandidate.getBColor()));
-
-            maRenderState.DeviceColor = basegfx::unotools::colorToDoubleSequence(
-                mxCanvas->getDevice(),
-                aRGBColor);
-
-            mxCanvas->drawPolyPolygon( basegfx::unotools::xPolyPolygonFromB2DPolygon(
-                                           mxCanvas->getDevice(),
-                                           rPolygonCandidate.getB2DPolygon()),
-                                       maViewState, 
-                                       maRenderState );
-		}
-
-		// direct draw of transformed BitmapEx primitive
-		void canvasProcessor::impRender_BMPR(const bitmapPrimitive& rBitmapCandidate)
-		{
-			BitmapEx aBitmapEx(rBitmapCandidate.getBitmapEx());
-
-			if(maBColorModifierStack.count())
-			{
-                // TODO(Q3): Share common bmp modification code with
-                // vclprocessor.cxx
-				Bitmap aChangedBitmap(impModifyBitmap(maBColorModifierStack, aBitmapEx.GetBitmap()));
-
-                if(aBitmapEx.IsTransparent())
-                {
-                    if(aBitmapEx.IsAlpha())
-                        aBitmapEx = BitmapEx(aChangedBitmap, aBitmapEx.GetAlpha());
-                    else
-                        aBitmapEx = BitmapEx(aChangedBitmap, aBitmapEx.GetMask());
-                }
-                else
-                    aBitmapEx = BitmapEx(aChangedBitmap);
-            }
-
-            mxCanvas->drawBitmap( 
-                vcl::unotools::xBitmapFromBitmapEx( mxCanvas->getDevice(), 
-                                                    aBitmapEx ),
-                maViewState,
-                maRenderState);
-		}
-
-        void canvasProcessor::impRender_PPLB(const polyPolygonBitmapPrimitive& rPolyBitmapCandidate )
-        {
-            const fillBitmapAttribute& rFillBmpAttr( rPolyBitmapCandidate.getFillBitmap() );
-            const basegfx::B2DPolyPolygon& rPoly( rPolyBitmapCandidate.getB2DPolyPolygon() );
-            
-            // TODO(Q3): Share common bmp modification code with
-            // vclprocessor.cxx
-            Bitmap aChangedBitmap(
-                impModifyBitmap(maBColorModifierStack, 
-                                rFillBmpAttr.getBitmap()));
-
-            rendering::Texture aTexture;
-			const basegfx::B2DVector aBmpSize( rFillBmpAttr.getSize() );
-
-            const basegfx::B2DRange& rBounds( 
-                basegfx::tools::getRange( rPoly ));
-
-            basegfx::B2DHomMatrix aScale;
-            aScale.scale( aBmpSize.getX() * rBounds.getWidth(),
-                          aBmpSize.getY() * rBounds.getHeight() );
-
-            basegfx::unotools::affineMatrixFromHomMatrix( 
-                aTexture.AffineTransform,
-                aScale );
-
-            aTexture.Alpha = 1.0;
-            aTexture.Bitmap = 
-                ::vcl::unotools::xBitmapFromBitmapEx( 
-                    mxCanvas->getDevice(), 
-                    aChangedBitmap );
-            aTexture.RepeatModeX = rendering::TexturingMode::REPEAT;
-            aTexture.RepeatModeY = rendering::TexturingMode::REPEAT;
-
-            uno::Sequence< rendering::Texture > aSeq(1);
-            aSeq[0] = aTexture;
-
-            mxCanvas->fillTexturedPolyPolygon( 
-                basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(
-                    mxCanvas->getDevice(),
-                    rPoly),
-                maViewState,
-                maRenderState,
-                aSeq );           
-        }
-
-		// direct draw of gradient
-		void canvasProcessor::impRender_PPLG(const polyPolygonGradientPrimitive& rPolygonCandidate)
-		{
-			const fillGradientAttribute& rGradient(rPolygonCandidate.getFillGradient());
-			basegfx::BColor aStartColor(maBColorModifierStack.getModifiedColor(rGradient.getStartColor()));
-			basegfx::BColor aEndColor(maBColorModifierStack.getModifiedColor(rGradient.getEndColor()));
-			basegfx::B2DPolyPolygon aLocalPolyPolygon(rPolygonCandidate.getB2DPolyPolygon());
-
-			if(aStartColor == aEndColor)
-			{
-				// no gradient at all, draw as polygon
-
-                maRenderState.DeviceColor = basegfx::unotools::colorToDoubleSequence(
-                    mxCanvas->getDevice(),
-                    aStartColor);
-                
-                mxCanvas->drawPolyPolygon( basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(
-                                               mxCanvas->getDevice(),
-                                               aLocalPolyPolygon),
-                                           maViewState, 
-                                           maRenderState );
-			}
-			else
-			{
-                // TODO(F3): if rGradient.getSteps() > 0, render
-                // gradient manually!
-				impDrawGradient(
-					aLocalPolyPolygon, rGradient.getStyle(), rGradient.getSteps(),
-					aStartColor, aEndColor, rGradient.getBorder(), 
-					-rGradient.getAngle(), rGradient.getOffsetX(), rGradient.getOffsetY(), false);
-			}
-		}
-
-		// direct draw of PolyPolygon with color
-		void canvasProcessor::impRender_PPLC(const polyPolygonColorPrimitive& rPolygonCandidate)
-		{
-			const basegfx::BColor aRGBColor(
-                maBColorModifierStack.getModifiedColor(
-                    rPolygonCandidate.getBColor()));
-
-            maRenderState.DeviceColor = basegfx::unotools::colorToDoubleSequence(
-                mxCanvas->getDevice(),
-                aRGBColor);
-
-            mxCanvas->fillPolyPolygon( basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(
-                                           mxCanvas->getDevice(),
-                                           rPolygonCandidate.getB2DPolyPolygon()),
-                                       maViewState, 
-                                       maRenderState );
-		}
-
-		// direct draw of MetaFile
-		void canvasProcessor::impRender_META(const metafilePrimitive& rMetaCandidate)
-		{
-			// get metafile (copy it)
-			GDIMetaFile aMetaFile;
-
-            // TODO(Q3): Share common metafile modification code with
-            // vclprocessor.cxx
-			if(maBColorModifierStack.count())
-			{
-				const basegfx::BColor aRGBBaseColor(0, 0, 0);
-				const basegfx::BColor aRGBColor(maBColorModifierStack.getModifiedColor(aRGBBaseColor));
-				aMetaFile = rMetaCandidate.getMetaFile().GetMonochromeMtf(Color(aRGBColor));
-			}
-			else
-			{
-				aMetaFile = rMetaCandidate.getMetaFile();
-			}
-
-            cppcanvas::BitmapCanvasSharedPtr pCanvas(
-                cppcanvas::VCLFactory::getInstance().createCanvas(
-                    uno::Reference<rendering::XBitmapCanvas>(
-                        mxCanvas,
-                        uno::UNO_QUERY_THROW) ));
-            cppcanvas::RendererSharedPtr pMtfRenderer( 
-                cppcanvas::VCLFactory::getInstance().createRenderer( 
-                    pCanvas,
-                    aMetaFile,
-                    cppcanvas::Renderer::Parameters() ));
-            if( pMtfRenderer )
-            {
-                pCanvas->setTransformation(maWorldToView);
-                pMtfRenderer->setTransformation(rMetaCandidate.getTransform());
-                pMtfRenderer->draw();
-            }
-		}
-
-		// mask group. Set mask polygon as clip
-		void canvasProcessor::impRender_MASK(const maskPrimitive& rMaskCandidate)
-		{
-			const primitiveVector& rSubList = rMaskCandidate.getPrimitiveVector();
-
-			if(!rSubList.empty())
-			{
-                // TODO(F3): cannot use state-global renderstate, when recursing!
-				maRenderState.Clip = 
-                    basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(
-                        mxCanvas->getDevice(),
-                        rMaskCandidate.getMask());
-
-                // paint to it
-                process(rSubList);
-
-                maRenderState.Clip.clear();
-			}
-		}
-
-		// modified color group. Force output to unified color.
-		void canvasProcessor::impRender_MCOL(const modifiedColorPrimitive& rModifiedCandidate)
-		{
-			const primitiveVector& rSubList = rModifiedCandidate.getPrimitiveVector();
-
-			if(!rSubList.empty())
-			{
-				maBColorModifierStack.push(rModifiedCandidate.getColorModifier());
-				process(rModifiedCandidate.getPrimitiveVector());
-				maBColorModifierStack.pop();
-			}
-		}
-
-		// sub-transparence group. Draw to bitmap device first.
-		void canvasProcessor::impRender_TRPR(const transparencePrimitive& rTransCandidate)
-		{
-			const primitiveVector& rSubList = rTransCandidate.getPrimitiveVector();
-
-			if(!rSubList.empty())
-			{
-				basegfx::B2DRange aRange(
-                    get2DRangeFromVector(rSubList, 
-                                         getViewInformation()));
-				aRange.transform(maWorldToView);
-                const basegfx::B2I64Tuple& rSize(
-                    canvas::tools::spritePixelAreaFromB2DRange(aRange).getRange());
-                uno::Reference< rendering::XCanvas > xBitmap(
-                    mxCanvas->getDevice()->createCompatibleAlphaBitmap( 
-                        css::geometry::IntegerSize2D(rSize.getX(),
-                                                     rSize.getY())),
-                    uno::UNO_QUERY_THROW);
-                
-                //  remember last worldToView and add pixel offset
-                basegfx::B2DHomMatrix aLastWorldToView(maWorldToView);
-                basegfx::B2DHomMatrix aPixelOffset;
-                aPixelOffset.translate(aRange.getMinX(),
-                                       aRange.getMinY());
-                setWorldToView(aPixelOffset * maWorldToView);
-
-                // remember last canvas, set bitmap as target
-                uno::Reference< rendering::XCanvas > xLastCanvas( mxCanvas );
-                mxCanvas = xBitmap;
-
-                // paint content to it  
-                process(rSubList);
-					
-                // TODO(F3): render transparent list to alpha
-                // channel. Note that the OutDev implementation has a
-                // shortcoming, in that nested transparency groups
-                // don't work - alpha is not combined properly.
-
-                // process(rTransCandidate.getTransparenceList());
-
-                // back to old OutDev and worldToView   
-                mxCanvas = xLastCanvas;
-                setWorldToView(aLastWorldToView);
-
-                // DUMMY: add alpha modulation value to DeviceColor
-                // TODO(F3): color management
-                canvas::tools::setDeviceColor( maRenderState,
-                                               1.0, 1.0, 1.0, 0.5 );
-                // finally, draw bitmap
-                mxCanvas->drawBitmapModulated(                 
-                    uno::Reference< rendering::XBitmap >(
-                        xBitmap,
-                        uno::UNO_QUERY_THROW),
-                    maViewState,
-                    maRenderState );
-			}
-		}
-
-		// transform group.
-		void canvasProcessor::impRender_TRN2(const transformPrimitive& rTransformCandidate)
-		{
-			// remember current transformation
-			basegfx::B2DHomMatrix aLastWorldToView(maWorldToView);
-
-			// create new transformations
-			setWorldToView(maWorldToView * rTransformCandidate.getTransformation());
-
-			// let break down
-			process(rTransformCandidate.getPrimitiveVector());
-
-			// restore transformations
-			setWorldToView(aLastWorldToView);
-		}
-
-		// marker
-		void canvasProcessor::impRender_MARK(const markerPrimitive& rMarkCandidate)
-		{
-			const basegfx::BColor aRGBColor(maBColorModifierStack.getModifiedColor(rMarkCandidate.getRGBColor()));
-
-            canvas::tools::initRenderState(maMarkerRenderState);
-            maMarkerRenderState.DeviceColor = basegfx::unotools::colorToDoubleSequence(
-                mxCanvas->getDevice(),
-                aRGBColor);
-
-            // Markers are special objects - their position is
-            // determined by the view transformation, but their size
-            // is always the same
-            const basegfx::B2DPoint aViewPos(maWorldToView * rMarkCandidate.getPosition());
-
-            uno::Reference< rendering::XPolyPolygon2D > xMarkerPoly;
-            uno::Reference< rendering::XPolyPolygon2D > xHighlightMarkerPoly;
-            switch(rMarkCandidate.getStyle())
-            {
-                default: 
-                case MARKERSTYLE_POINT:
-                    mxCanvas->drawPoint( basegfx::unotools::point2DFromB2DPoint(aViewPos),
-                                         maMarkerViewState,
-                                         maMarkerRenderState );
-                    return;
-
-                case MARKERSTYLE_CROSS:
-                    if( !mxCrossMarkerPoly.is() )
-                    {
-                        basegfx::B2DPolyPolygon aPoly;
-                        basegfx::tools::importFromSvgD( 
-                            aPoly, 
-                            rtl::OUString::createFromAscii( 
-                                "m-1 0 h2 m0 -1 v2" ));
-                        mxCrossMarkerPoly = 
-                            basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(
-                                mxCanvas->getDevice(),
-                                aPoly );
-                    }
-                    xMarkerPoly = mxCrossMarkerPoly;
-                    break;
-
-                case MARKERSTYLE_GLUEPOINT :
-                    if( !mxGluePointPoly.is() )
-                    {
-                        basegfx::B2DPolyPolygon aPoly;
-                        basegfx::tools::importFromSvgD( 
-                            aPoly, 
-                            rtl::OUString::createFromAscii( 
-                                "m-2 -3 l5 5 m-3 -2 l5 5 m-3 2 l5 -5 m-2 3 l5 -5" ));
-                        mxGluePointPoly = 
-                            basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(
-                                mxCanvas->getDevice(),
-                                aPoly );
-                    }
-                    if( !mxGluePointHighlightPoly.is() )
-                    {
-                        basegfx::B2DPolyPolygon aPoly;
-                        basegfx::tools::importFromSvgD( 
-                            aPoly, 
-                            rtl::OUString::createFromAscii( 
-                                "m-2 -2 l4 4 m-2 2 l4 -4" ));
-                        mxGluePointHighlightPoly = 
-                            basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(
-                                mxCanvas->getDevice(),
-                                aPoly );
-                    }
-                    xMarkerPoly = mxGluePointPoly;
-                    xHighlightMarkerPoly = mxGluePointHighlightPoly;
-                    break;
-            }
-
-            basegfx::B2DRange aRange;
-            rMarkCandidate.getRealtiveViewRange(aRange);
-            const basegfx::B2DPoint aCenter(aRange.getCenter());
-            
-            basegfx::B2DHomMatrix aTranslate;
-            aTranslate.translate(aViewPos.getX()+aCenter.getX(),
-                                 aViewPos.getY()+aCenter.getY());
-            
-            canvas::tools::setRenderStateTransform( maMarkerRenderState, 
-                                                    aTranslate );
-            
-            
-            mxCanvas->drawPolyPolygon( xMarkerPoly,
-                                       maMarkerViewState,
-                                       maMarkerRenderState );
-            if( xHighlightMarkerPoly.is() )
-            {
-                // TODO(F3): color management
-                canvas::tools::setDeviceColor(maMarkerRenderState,
-                                              0.0, 0.0, 1.0, 1.0);
-                mxCanvas->drawPolyPolygon( xMarkerPoly,
-                                           maMarkerViewState,
-                                           maMarkerRenderState );
-			}
-		}
-
-        void canvasProcessor::setWorldToView(const basegfx::B2DHomMatrix& rMat)
-        {
-            maWorldToView = rMat;
-            canvas::tools::setViewStateTransform(maViewState,
-                                                 maWorldToView);
-        }
-
-		//////////////////////////////////////////////////////////////////////////////
-		// internal processing support
-
-		void canvasProcessor::process(const primitiveVector& rSource)
-		{
-            primitiveVector::const_iterator       aCurr = rSource.begin();
-            const primitiveVector::const_iterator aEnd = rSource.end();
-			while( aCurr != aEnd )
-			{
-				const referencedPrimitive& rCandidate = *aCurr;
-
-				switch(rCandidate.getID())
-				{
-					case CreatePrimitiveID('S', 'T', 'X', 'P'):
-					{
-						// directdraw of text simple portion
-						impRender_STXP(static_cast< const textSimplePortionPrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-					}
-
-					case CreatePrimitiveID('P', 'O', 'H', 'L'):
-					{
-						// direct draw of hairline
-						impRender_POHL(static_cast< const polygonHairlinePrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-					}
-
-					case CreatePrimitiveID('B', 'M', 'P', 'R'):
-					{
-						// direct draw of transformed BitmapEx primitive
-						impRender_BMPR(static_cast< const bitmapPrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-					}
-
-					case CreatePrimitiveID('F', 'B', 'M', 'P'):
-					{
-                        OSL_ENSURE(false,"fillBitmapPrimitive not yet implemented");
-						break;
-					}
-
-                    case CreatePrimitiveID('P', 'P', 'L', 'B'):
-                    {
-						// direct draw of polygon with bitmap fill
-						impRender_PPLB(static_cast< const polyPolygonBitmapPrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-                    }
-
-					case CreatePrimitiveID('P', 'P', 'L', 'G'):
-					{
-						// direct draw of gradient
-						impRender_PPLG(static_cast< const polyPolygonGradientPrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-					}
-
-					case CreatePrimitiveID('P', 'P', 'L', 'C'):
-					{
-						// direct draw of PolyPolygon with color
-						impRender_PPLC(static_cast< const polyPolygonColorPrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-					}
-
-					case CreatePrimitiveID('M', 'E', 'T', 'A'):
-					{
-						// direct draw of MetaFile
-						impRender_META(static_cast< const metafilePrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-					}
-
-					case CreatePrimitiveID('M', 'A', 'S', 'K'):
-					{
-						// mask group. Force output to VDev and create mask from given mask
-						impRender_MASK(static_cast< const maskPrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-					}
-
-					case CreatePrimitiveID('M', 'C', 'O', 'L'):
-					{
-						// modified color group. Force output to unified color.
-						impRender_MCOL(static_cast< const modifiedColorPrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-					}
-
-					case CreatePrimitiveID('T', 'R', 'P', 'R'):
-					{
-						// sub-transparence group. Draw to VDev first.
-						impRender_TRPR(static_cast< const transparencePrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-					}
-
-					case CreatePrimitiveID('T', 'R', 'N', '2'):
-					{
-						// transform group.
-						impRender_TRN2(static_cast< const transformPrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-					}
-
-					case CreatePrimitiveID('M', 'A', 'R', 'K'):
-					{
-						// marker
-						impRender_MARK(static_cast< const markerPrimitive& >(rCandidate.getBasePrimitive()));
-						break;
-					}
-
-					case CreatePrimitiveID('A', 'N', 'S', 'W'):
-					case CreatePrimitiveID('A', 'N', 'B', 'L'):
-					case CreatePrimitiveID('A', 'N', 'I', 'N'):
-					{
-						// check timing, but do not accept
-						const animatedSwitchPrimitive& rAnimatedCandidate(static_cast< const animatedSwitchPrimitive& >(rCandidate.getBasePrimitive()));
-						const ::drawinglayer::animation::animationEntryList& rAnimationList = rAnimatedCandidate.getAnimationList();
-						const double fNewTime(rAnimationList.getNextEventTime(getViewInformation().getViewTime()));
-
-						// let break down
-						process(rAnimatedCandidate.getDecomposition(getViewInformation()));
-
-						break;
-					}
-
-					default:
-					{
-						// let break down
-						process(rCandidate.getBasePrimitive().getDecomposition(getViewInformation()));
-					}
-				}
-
-                ++aCurr;
-			}
-		}
-
-		canvasProcessor::canvasProcessor( const ::drawinglayer::geometry::viewInformation& rViewInformation, 
-                                          const uno::Reference<rendering::XCanvas>&        rCanvas ) :
-            processor(rViewInformation),
-            mxCanvas( rCanvas ),
-            mxCrossMarkerPoly(),
-            mxGluePointPoly(),
-            mxGluePointHighlightPoly(),
-            maBColorModifierStack(),
-            maWorldToView(),
-            maViewState(),
-            maRenderState(),
-            maMarkerViewState(),
-            maMarkerRenderState()
-		{
-            canvas::tools::initViewState(maViewState);
-            canvas::tools::initRenderState(maRenderState);
-            canvas::tools::initViewState(maMarkerViewState);
-            canvas::tools::initRenderState(maMarkerRenderState);
-
-			maWorldToView = maViewInformation.getViewTransformation();
-
-            canvas::tools::setViewStateTransform(maViewState,
-                                                 maWorldToView);
-        }
-
-		canvasProcessor::~canvasProcessor()
-		{}
-*/
-//////////////////////////////////////////////////////////////////////////////
-
 namespace drawinglayer
 {
 	namespace processor2d
@@ -1309,7 +109,7 @@ namespace drawinglayer
                     // alpha-using XBitmap for content and draw the mask as alpha. Both have their
                     // advantages and disadvantages, so here are both with a bool allowing simple
                     // change
-                    if(bUseMaskBitmapMethod)
+                    if(bUseMaskBitmapMethod && mpOutputDevice)
                     {
                         // get logic range of transparent part, clip with ViewRange
 		                basegfx::B2DRange aLogicRange(aMask.getB2DRange());
@@ -1415,55 +215,45 @@ namespace drawinglayer
                     }
                     else
                     {
-                        // transform new mask polygon to view coordinates for processing. All masks
-                        // are processed in view coordinates and clipped against each other evtl. to
+                        // transform new mask polygon to view
+                        // coordinates for processing. All masks are
+                        // processed in view coordinates and clipped
+                        // against each other (if necessary), to
                         // create multi-clips
 			            aMask.transform(getViewInformation2D().getObjectTransformation());
 
-                        // remember last current clip polygon
                         const basegfx::B2DPolyPolygon aLastClipPolyPolygon(maClipPolyPolygon);
+                        const uno::Reference<rendering::XPolyPolygon2D> xLastClipPoly = maViewState.Clip;
     			        
-                        if(maClipPolyPolygon.count())
+                        if(xLastClipPoly.is())
                         {
-						    // there is already a clip polygon set; build clipped union of 
-						    // current mask polygon and new one
+						    // build clipped union of current mask
+						    // polygon and new one - this is to avoid
+						    // costly, repeated clip calculations
+						    // inside the canvas impls for all the
+						    // mask group contents
 						    maClipPolyPolygon = basegfx::tools::clipPolyPolygonOnPolyPolygon(aMask, maClipPolyPolygon, false, false);
                         }
                         else
                         {
-                            // use mask directly
                             maClipPolyPolygon = aMask;
                         }
 
-                        // set at ViewState
-                        if(maClipPolyPolygon.count())
-                        {
-                            // set new as clip polygon
-		                    maViewState.Clip = basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(mxCanvas->getDevice(), maClipPolyPolygon);
-                        }
-                        else
-                        {
-                            // empty, reset
-                            maViewState.Clip.clear();
-                        }
+                        // set new clip polygon at viewstate -
+                        // unconditionally, an empty maClipPolyPolygon
+                        // denotes the empty clip (nothing visible),
+                        // and need not be confused with the empty
+                        // interface (the null clip, i.e. everything
+                        // visible)
+                        maViewState.Clip = basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(mxCanvas->getDevice(), 
+                                                                                             maClipPolyPolygon);
 
 		                // paint content
 		                process(rChildren);
 
                         // restore local current to rescued clip polygon
                         maClipPolyPolygon = aLastClipPolyPolygon;
-
-                        // set at ViewState
-                        if(maClipPolyPolygon.count())
-                        {
-                            // set new as clip polygon
-		                    maViewState.Clip = basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(mxCanvas->getDevice(), maClipPolyPolygon);
-                        }
-                        else
-                        {
-                            // empty, reset
-                            maViewState.Clip.clear();
-                        }
+                        maViewState.Clip = xLastClipPoly;
                     }
 		        }
             }
@@ -1499,6 +289,8 @@ namespace drawinglayer
 
         void canvasProcessor2D::impRenderTextSimplePortionPrimitive2D(const primitive2d::TextSimplePortionPrimitive2D& rTextCandidate)
         {
+            static bool bAvoidShearedText(true);
+
             if(rTextCandidate.getTextLength())
             {
                 double fShearX(0.0);
@@ -1509,10 +301,12 @@ namespace drawinglayer
     			    aLocalTransform.decompose(aScale, aTranslate, fRotate, fShearX);
                 }
 
-			    if(!basegfx::fTools::equalZero(fShearX))
+			    if(bAvoidShearedText && !basegfx::fTools::equalZero(fShearX))
 			    {
-                    // text is sheared. As long as the canvas renderers do not support this,
-                    // use the decomposed primitive
+                    // text is sheared. As long as the canvas
+                    // renderers do not support this, use the
+                    // decomposed primitive (iirc this is only a
+                    // problem with vclcanvas)
 				    process(rTextCandidate.get2DDecomposition(getViewInformation2D()));
                 }
                 else
@@ -1532,7 +326,9 @@ namespace drawinglayer
                     aFontRequest.CellSize = 1.0;
                     aFontRequest.Locale = rTextCandidate.getLocale();
 
-                    // font matrix should only be used for glyph rotations etc.
+                    // font matrix should only be used for glyph
+                    // rotations etc. - why, then use it for sheared
+                    // text, no?
                     com::sun::star::geometry::Matrix2D aFontMatrix;
                     canvas::tools::setIdentityMatrix2D(aFontMatrix);
 
@@ -1640,86 +436,93 @@ namespace drawinglayer
                 {
                     // get discrete range of transparent part
                     basegfx::B2DRange aDiscreteRange(aLogicRange);
-		            aDiscreteRange.transform(getViewInformation2D().getObjectToViewTransformation());
-
-                    // expand to next covering discrete values (pixel bounds)
+                    aDiscreteRange.transform(getViewInformation2D().getObjectToViewTransformation());
+                    
+                    // expand to next covering discrete values (pixel bounds)   
                     aDiscreteRange.expand(basegfx::B2DTuple(floor(aDiscreteRange.getMinX()), floor(aDiscreteRange.getMinY())));
                     aDiscreteRange.expand(basegfx::B2DTuple(ceil(aDiscreteRange.getMaxX()), ceil(aDiscreteRange.getMaxY())));
 
-                    // use VCL-based buffer device
-				    impBufferDevice aBufferDevice(*mpOutputDevice, aDiscreteRange, false);
+                    if( mpOutputDevice )
+                    {
+                        // use VCL-based buffer device
+                        impBufferDevice aBufferDevice(*mpOutputDevice, aDiscreteRange, false);
 
-				    if(aBufferDevice.isVisible())
-				    {
-					    // remember current OutDev, Canvas and ViewInformation
-					    OutputDevice* pLastOutputDevice = mpOutputDevice;
-                        uno::Reference< rendering::XCanvas > xLastCanvas(mxCanvas);
-			            const geometry::ViewInformation2D aLastViewInformation2D(getViewInformation2D());
-
-						// prepare discrete offset for XBitmap, do not forget that the buffer bitmap
-                        // may be truncated to discrete visible pixels
-						basegfx::B2DHomMatrix aDiscreteOffset;
-						aDiscreteOffset.translate(
-                            aDiscreteRange.getMinX() > 0.0 ? -aDiscreteRange.getMinX() : 0.0, 
-                            aDiscreteRange.getMinY() > 0.0 ? -aDiscreteRange.getMinY() : 0.0);
-
-			            // create new local ViewInformation2D with new transformation
-			            const geometry::ViewInformation2D aViewInformation2D(
-				            getViewInformation2D().getObjectTransformation(), 
-				            aDiscreteOffset * getViewInformation2D().getViewTransformation(), 
-				            getViewInformation2D().getViewport(),
-				            getViewInformation2D().getVisualizedPage(),
-				            getViewInformation2D().getViewTime(),
-				            getViewInformation2D().getExtendedInformationSequence());
-			            updateViewInformation(aViewInformation2D);
-
-                        // set OutDev and Canvas to content target
-					    mpOutputDevice = &aBufferDevice.getContent();
-                        mxCanvas = mpOutputDevice->GetCanvas();
-			            canvas::tools::setViewStateTransform(maViewState, getViewInformation2D().getViewTransformation());
-
-                        // if ViewState transform is changed, the clipping polygon needs to be adapted, too
-                        const basegfx::B2DPolyPolygon aOldClipPolyPolygon(maClipPolyPolygon);
-
-                        if(maClipPolyPolygon.count())
+                        if(aBufferDevice.isVisible())
                         {
-                            maClipPolyPolygon.transform(aDiscreteOffset);
-		                    maViewState.Clip = basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(mxCanvas->getDevice(), maClipPolyPolygon);
-                        }
+                            // remember current OutDev, Canvas and ViewInformation
+                            OutputDevice* pLastOutputDevice = mpOutputDevice;
+                            uno::Reference< rendering::XCanvas > xLastCanvas(mxCanvas);
+                            const geometry::ViewInformation2D aLastViewInformation2D(getViewInformation2D());
+
+                            // prepare discrete offset for XBitmap, do not forget that the buffer bitmap
+                            // may be truncated to discrete visible pixels
+                            basegfx::B2DHomMatrix aDiscreteOffset;
+                            aDiscreteOffset.translate(
+                                aDiscreteRange.getMinX() > 0.0 ? -aDiscreteRange.getMinX() : 0.0, 
+                                aDiscreteRange.getMinY() > 0.0 ? -aDiscreteRange.getMinY() : 0.0);
+
+                            // create new local ViewInformation2D with new transformation
+                            const geometry::ViewInformation2D aViewInformation2D(
+                                getViewInformation2D().getObjectTransformation(), 
+                                aDiscreteOffset * getViewInformation2D().getViewTransformation(), 
+                                getViewInformation2D().getViewport(),
+                                getViewInformation2D().getVisualizedPage(),
+                                getViewInformation2D().getViewTime(),
+                                getViewInformation2D().getExtendedInformationSequence());
+                            updateViewInformation(aViewInformation2D);
+
+                            // set OutDev and Canvas to content target
+                            mpOutputDevice = &aBufferDevice.getContent();
+                            mxCanvas = mpOutputDevice->GetCanvas();
+                            canvas::tools::setViewStateTransform(maViewState, getViewInformation2D().getViewTransformation());
+
+                            // if ViewState transform is changed, the clipping polygon needs to be adapted, too
+                            const basegfx::B2DPolyPolygon aOldClipPolyPolygon(maClipPolyPolygon);
+
+                            if(maClipPolyPolygon.count())
+                            {
+                                maClipPolyPolygon.transform(aDiscreteOffset);
+                                maViewState.Clip = basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(mxCanvas->getDevice(), maClipPolyPolygon);
+                            }
 
-					    // paint content
-					    process(rChildren);
+                            // paint content
+                            process(rChildren);
     					
-					    // set to mask
-					    mpOutputDevice = &aBufferDevice.getAlpha();
-                        mxCanvas = mpOutputDevice->GetCanvas();
-			            canvas::tools::setViewStateTransform(maViewState, getViewInformation2D().getViewTransformation());
+                            // set to mask
+                            mpOutputDevice = &aBufferDevice.getAlpha();
+                            mxCanvas = mpOutputDevice->GetCanvas();
+                            canvas::tools::setViewStateTransform(maViewState, getViewInformation2D().getViewTransformation());
 
-					    // when painting alpha masks, reset the color stack
-					    basegfx::BColorModifierStack aLastBColorModifierStack(maBColorModifierStack);
-					    maBColorModifierStack = basegfx::BColorModifierStack();
+                            // when painting alpha masks, reset the color stack
+                            basegfx::BColorModifierStack aLastBColorModifierStack(maBColorModifierStack);
+                            maBColorModifierStack = basegfx::BColorModifierStack();
 
-					    // paint mask to it (always with alpha intensities, evtl. with AA)
-					    process(rAlpha);
+                            // paint mask to it (always with alpha intensities, evtl. with AA)
+                            process(rAlpha);
 
-					    // back to old color stack, OutDev, Canvas and ViewTransform
-					    maBColorModifierStack = aLastBColorModifierStack;
-					    mpOutputDevice = pLastOutputDevice;
-                        mxCanvas = xLastCanvas;
-				        updateViewInformation(aLastViewInformation2D);
-				        canvas::tools::setViewStateTransform(maViewState, getViewInformation2D().getViewTransformation());
+                            // back to old color stack, OutDev, Canvas and ViewTransform
+                            maBColorModifierStack = aLastBColorModifierStack;
+                            mpOutputDevice = pLastOutputDevice;
+                            mxCanvas = xLastCanvas;
+                            updateViewInformation(aLastViewInformation2D);
+                            canvas::tools::setViewStateTransform(maViewState, getViewInformation2D().getViewTransformation());
 
-                        // restore clipping polygon
-                        maClipPolyPolygon = aOldClipPolyPolygon;
+                            // restore clipping polygon
+                            maClipPolyPolygon = aOldClipPolyPolygon;
 
-                        if(maClipPolyPolygon.count())
-                        {
-		                    maViewState.Clip = basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(mxCanvas->getDevice(), maClipPolyPolygon);
-                        }
+                            if(maClipPolyPolygon.count())
+                            {
+                                maViewState.Clip = basegfx::unotools::xPolyPolygonFromB2DPolyPolygon(mxCanvas->getDevice(), maClipPolyPolygon);
+                            }
 
-                        // dump buffer to outdev
-					    aBufferDevice.paint();
-				    }
+                            // dump buffer to outdev
+                            aBufferDevice.paint();
+                        }
+                    }
+                    else
+                    {
+                        // do it the canvas way
+                    }
                 }
             }
         }
@@ -2100,19 +903,27 @@ namespace drawinglayer
 				}
 				case PRIMITIVE2D_ID_CHARTPRIMITIVE2D :
 				{
+                    const primitive2d::ChartPrimitive2D& rChartPrimitive = static_cast< const primitive2d::ChartPrimitive2D& >(rCandidate);
+
 					// chart primitive in canvas renderer; restore original DrawMode during call
 					// since the evtl. used ChartPrettyPainter will use the MapMode
-					const primitive2d::ChartPrimitive2D& rChartPrimitive = static_cast< const primitive2d::ChartPrimitive2D& >(rCandidate);
-		   			mpOutputDevice->Push(PUSH_MAPMODE);
-					mpOutputDevice->SetMapMode(maOriginalMapMode);
+                    bool bDone=false;
+                    if( mpOutputDevice )
+                    {
+                        mpOutputDevice->Push(PUSH_MAPMODE);
+                        mpOutputDevice->SetMapMode(maOriginalMapMode);
 					
-					if(!renderChartPrimitive2D(rChartPrimitive, *mpOutputDevice))
-					{
-						// fallback to decomposition (MetaFile)
-						process(rChartPrimitive.get2DDecomposition(getViewInformation2D()));
-					}
+                        if(renderChartPrimitive2D(rChartPrimitive, *mpOutputDevice))
+                            bDone=true;
+
+                        mpOutputDevice->Pop();
+                    }
 
-					mpOutputDevice->Pop();
+                    if( !bDone )
+                    {
+                        // fallback to decomposition (MetaFile)
+                        process(rChartPrimitive.get2DDecomposition(getViewInformation2D()));
+                    }
 					break;
 				}
                 case PRIMITIVE2D_ID_WRONGSPELLPRIMITIVE2D :
@@ -2122,7 +933,8 @@ namespace drawinglayer
 					// this can be removed anytime and the decomposition may be used
 					const primitive2d::WrongSpellPrimitive2D& rWrongSpellPrimitive = static_cast< const primitive2d::WrongSpellPrimitive2D& >(rCandidate);
 
-					if(!renderWrongSpellPrimitive2D(
+					if(!mpOutputDevice ||
+                       !renderWrongSpellPrimitive2D(
 						rWrongSpellPrimitive, 
 						*mpOutputDevice, 
 						getViewInformation2D().getObjectToViewTransformation(),
@@ -2157,6 +969,28 @@ namespace drawinglayer
 		// process support
 
 		canvasProcessor2D::canvasProcessor2D(
+			const geometry::ViewInformation2D& rViewInformation,
+            const uno::Reference< rendering::XCanvas >& xCanvas,
+            const rendering::ViewState& rViewState )
+		:	BaseProcessor2D(rViewInformation),
+            maOriginalMapMode(),
+            mpOutputDevice(NULL),
+			mxCanvas(xCanvas),
+			maViewState(rViewState),
+			maRenderState(),
+			maBColorModifierStack(),
+			maDrawinglayerOpt(),
+            maClipPolyPolygon()
+		{
+            canvas::tools::initRenderState(maRenderState);
+            canvas::tools::appendToViewState(maViewState, 
+                                             getViewInformation2D().getViewTransformation());
+            if( maViewState.Clip.is() )
+                maClipPolyPolygon = basegfx::unotools::b2DPolyPolygonFromXPolyPolygon2D(
+                    maViewState.Clip);
+        }
+
+		canvasProcessor2D::canvasProcessor2D(
 			const geometry::ViewInformation2D& rViewInformation, 
 			OutputDevice& rOutDev) 
 		:	BaseProcessor2D(rViewInformation),
@@ -2178,20 +1012,21 @@ namespace drawinglayer
 
             // set digit language, derived from SvtCTLOptions to have the correct
             // number display for arabic/hindi numerals
+            LanguageType eLang;
             if(SvtCTLOptions::NUMERALS_HINDI == aSvtCTLOptions.GetCTLTextNumerals())
             {
-                meLang = LANGUAGE_ARABIC_SAUDI_ARABIA;
+                eLang = LANGUAGE_ARABIC_SAUDI_ARABIA;
             }
             else if(SvtCTLOptions::NUMERALS_ARABIC == aSvtCTLOptions.GetCTLTextNumerals())
             {
-                meLang = LANGUAGE_ENGLISH;
+                eLang = LANGUAGE_ENGLISH;
             }
             else
             {
-                meLang = (LanguageType)Application::GetSettings().GetLanguage();
+                eLang = (LanguageType)Application::GetSettings().GetLanguage();
             }
 
-            rOutDev.SetDigitLanguage(meLang);
+            rOutDev.SetDigitLanguage(eLang);
 
             // prepare output directly to pixels
    			mpOutputDevice->Push(PUSH_MAPMODE);
@@ -2210,11 +1045,14 @@ namespace drawinglayer
 
 		canvasProcessor2D::~canvasProcessor2D()
 		{
-            // restore MapMode
-   			mpOutputDevice->Pop();
-
-            // restore AntiAliasing
-            mpOutputDevice->SetAntialiasing(mpOutputDevice->GetAntialiasing() & ~ANTIALIASING_ENABLE_B2DDRAW);
+            if( mpOutputDevice )
+            {
+                // restore MapMode
+                mpOutputDevice->Pop();
+                
+                // restore AntiAliasing 
+                mpOutputDevice->SetAntialiasing(mpOutputDevice->GetAntialiasing() & ~ANTIALIASING_ENABLE_B2DDRAW);
+            }
 		}
 	} // end of namespace processor2d
 } // end of namespace drawinglayer
diff --git offapi/com/sun/star/graphic/XPrimitive2D.idl offapi/com/sun/star/graphic/XPrimitive2D.idl
index ccdc91d..00b41b8 100644
--- offapi/com/sun/star/graphic/XPrimitive2D.idl
+++ offapi/com/sun/star/graphic/XPrimitive2D.idl
@@ -57,11 +57,19 @@ interface XPrimitive2D : ::com::sun::star::uno::XInterface
         2D View-specific parameter set. The defined but not mandatory
 		parameters include:
 		
-		::com::sun::star::geometry::AffineMatrix2D Transformation
+		::com::sun::star::geometry::AffineMatrix2D ObjectTransformation
 
-		A transformation matrix which maps between world coordinates (which
-		is equal to object's local coordinates) to view coordinates. If not
-		defined, an empty transformation is implied.
+		A transformation matrix which maps between object coordinates
+		(which is equal to object's local coordinates) to world
+		coordinates. If not defined, the identity transformation is
+		implied.
+
+		::com::sun::star::geometry::AffineMatrix2D ViewTransformation
+
+		A transformation matrix which maps between world coordinates
+		to view coordinates, i.e. usually the actual pixel on
+		screen. If not defined, the identity transformation is
+		implied.
 
 		::com::sun::star::geometry::RealRectangle2D Viewport
 
@@ -76,6 +84,11 @@ interface XPrimitive2D : ::com::sun::star::uno::XInterface
 		lead to varied results for animated objects. This value is defined in the
 		range [0.0 .. n[, negative values are not allowed. If not given, a value of
 		0.0 is implied.
+
+        ::com::sun::star::drawing::XDrawPage VisualizedPage
+
+        The page object this is displayed on. Used to e.g. resolve
+        page number placeholders and the like.
      */
     sequence< XPrimitive2D > getDecomposition( [in] sequence< ::com::sun::star::beans::PropertyValue > aViewParameters );
 
diff --git offapi/com/sun/star/graphic/XPrimitiveFactory2D.idl offapi/com/sun/star/graphic/XPrimitiveFactory2D.idl
index 8022207..643e7a4 100644
--- offapi/com/sun/star/graphic/XPrimitiveFactory2D.idl
+++ offapi/com/sun/star/graphic/XPrimitiveFactory2D.idl
@@ -69,6 +69,42 @@ interface XPrimitiveFactory2D : ::com::sun::star::uno::XInterface
         Sequence of factory parameters, whose semantics depend on the
         shape to be generated.
 
+        2D View-specific parameter set. The defined but not mandatory
+		parameters include:
+		
+		::com::sun::star::geometry::AffineMatrix2D ObjectTransformation
+
+		A transformation matrix which maps between object coordinates
+		(which is equal to object's local coordinates) to world
+		coordinates. If not defined, the identity transformation is
+		implied.
+
+		::com::sun::star::geometry::AffineMatrix2D ViewTransformation
+
+		A transformation matrix which maps between world coordinates
+		to view coordinates, i.e. usually the actual pixel on
+		screen. If not defined, the identity transformation is
+		implied.
+
+		::com::sun::star::geometry::RealRectangle2D Viewport
+
+		Defines the visible part of the view in world coordinates. May be used
+		to optimize decompositions, e.g. for 3d scenes only the visible part
+		needs to be created. If not given, an empty Viewport is implied which
+		means all is visible.
+
+		double Time
+
+		Defines the point in time for which the geometry is defined. This may
+		lead to varied results for animated objects. This value is defined in the
+		range [0.0 .. n[, negative values are not allowed. If not given, a value of
+		0.0 is implied.
+
+        ::com::sun::star::drawing::XDrawPage VisualizedPage
+
+        The page object this is displayed on. Used to e.g. resolve
+        page number placeholders and the like.
+
         @return a sequence of primitives, that consists of the
         geometrical representation from the given XShape.
      */
@@ -87,6 +123,42 @@ interface XPrimitiveFactory2D : ::com::sun::star::uno::XInterface
         Sequence of factory parameters, whose semantics depend on the
         page to be generated.         
 
+        2D View-specific parameter set. The defined but not mandatory
+		parameters include:
+		
+		::com::sun::star::geometry::AffineMatrix2D ObjectTransformation
+
+		A transformation matrix which maps between object coordinates
+		(which is equal to object's local coordinates) to world
+		coordinates. If not defined, the identity transformation is
+		implied.
+
+		::com::sun::star::geometry::AffineMatrix2D ViewTransformation
+
+		A transformation matrix which maps between world coordinates
+		to view coordinates, i.e. usually the actual pixel on
+		screen. If not defined, the identity transformation is
+		implied.
+
+		::com::sun::star::geometry::RealRectangle2D Viewport
+
+		Defines the visible part of the view in world coordinates. May be used
+		to optimize decompositions, e.g. for 3d scenes only the visible part
+		needs to be created. If not given, an empty Viewport is implied which
+		means all is visible.
+
+		double Time
+
+		Defines the point in time for which the geometry is defined. This may
+		lead to varied results for animated objects. This value is defined in the
+		range [0.0 .. n[, negative values are not allowed. If not given, a value of
+		0.0 is implied.
+
+        ::com::sun::star::drawing::XDrawPage VisualizedPage
+
+        The page object this is displayed on. Used to e.g. resolve
+        page number placeholders and the like.
+
         @return a sequence of primitives, that consists of the
         geometrical representation for the given XDrawPage.
      */
diff --git slideshow/source/engine/shapes/drawshape.cxx slideshow/source/engine/shapes/drawshape.cxx
index 8894073..6ddf1e8 100644
--- slideshow/source/engine/shapes/drawshape.cxx
+++ slideshow/source/engine/shapes/drawshape.cxx
@@ -350,6 +350,9 @@ namespace slideshow
                                      										// it does _not_ for MSVC without
                                      										// the extra mem_fn. WTF.
                                      _1,
+                                     ::boost::cref( mxShape ),
+                                     ::boost::cref( mxPage ),
+                                     ::boost::cref( mxPrimitives ),
                                      ::boost::cref( mpCurrMtf ),
                                      ::boost::cref(
                                          getViewRenderArgs() ), 
@@ -563,6 +566,9 @@ namespace slideshow
             mnAttributeVisibilityState(0),
             maViewShapes(),
             mxComponentContext( rContext.mxComponentContext ),
+            mxPrimitives( 
+                rContext.mxPrimitiveFactory->createPrimitivesFromXShape(xShape,
+                                                                        uno::Sequence<beans::PropertyValue>()) ),
             maHyperlinkIndices(),
             maHyperlinkRegions(),
             maSubsetting(),
@@ -624,6 +630,9 @@ namespace slideshow
             mnAttributeVisibilityState(0),
             maViewShapes(),
             mxComponentContext( rContext.mxComponentContext ),
+            mxPrimitives( 
+                rContext.mxPrimitiveFactory->createPrimitivesFromXShape(xShape,
+                                                                        uno::Sequence<beans::PropertyValue>()) ),
             maHyperlinkIndices(),
             maHyperlinkRegions(),
             maSubsetting(),
@@ -676,6 +685,7 @@ namespace slideshow
             mnAttributeVisibilityState(0),
             maViewShapes(),
             mxComponentContext( rSrc.mxComponentContext ),
+            mxPrimitives( rSrc.mxPrimitives ),
             maHyperlinkIndices(),
             maHyperlinkRegions(),
             maSubsetting( rTreeNode, mpCurrMtf ),
@@ -837,7 +847,10 @@ namespace slideshow
             // render the Shape on the newly added ViewLayer
             if( bRedrawLayer )
             {
-                pNewShape->update( mpCurrMtf, 
+                pNewShape->update( mxShape,
+                                   mxPage,
+                                   mxPrimitives,
+                                   mpCurrMtf,
                                    getViewRenderArgs(),
                                    ViewShape::FORCE, 
                                    isVisible() );
diff --git slideshow/source/engine/shapes/drawshape.hxx slideshow/source/engine/shapes/drawshape.hxx
index 4c8fb8d..3d06488 100644
--- slideshow/source/engine/shapes/drawshape.hxx
+++ slideshow/source/engine/shapes/drawshape.hxx
@@ -33,6 +33,7 @@
 
 #include <osl/diagnose.hxx>
 #include <com/sun/star/drawing/XShape.hpp>
+#include <com/sun/star/graphic/XPrimitiveFactory2D.hpp>
 
 #include "attributableshape.hxx"
 #include "doctreenodesupplier.hxx"
@@ -347,6 +348,10 @@ namespace slideshow
             ::com::sun::star::uno::Reference< 
                 ::com::sun::star::uno::XComponentContext>                           mxComponentContext;
 
+            ::com::sun::star::uno::Sequence< 
+                ::com::sun::star::uno::Reference< 
+                    ::com::sun::star::graphic::XPrimitive2D > >                     mxPrimitives;
+
             /// hyperlink support
             typedef ::std::pair<sal_Int32 /* mtf start */,
                                 sal_Int32 /* mtf end */> HyperlinkIndexPair;
diff --git slideshow/source/engine/shapes/viewshape.cxx slideshow/source/engine/shapes/viewshape.cxx
index 84094db..5eeb0e5 100644
--- slideshow/source/engine/shapes/viewshape.cxx
+++ slideshow/source/engine/shapes/viewshape.cxx
@@ -56,6 +56,7 @@
 #include <canvas/canvastools.hxx>
 #include <cppcanvas/vclfactory.hxx>
 #include <cppcanvas/basegfxfactory.hxx>
+#include <drawinglayer/processor2d/canvasprocessor.hxx>
 
 #include "viewshape.hxx"
 #include "tools.hxx"
@@ -194,6 +195,9 @@ namespace slideshow
         }
 
         bool ViewShape::draw( const ::cppcanvas::CanvasSharedPtr&	rDestinationCanvas,
+                              const uno::Reference<drawing::XShape>&    xShape,
+                              const uno::Reference<drawing::XDrawPage>& xPage,
+                              const uno::Sequence<uno::Reference<graphic::XPrimitive2D> >& xPrimitives,
                               const GDIMetaFileSharedPtr&			rMtf,
                               const ShapeAttributeLayerSharedPtr&	rAttr,
                               const ::basegfx::B2DHomMatrix&		rTransform,
@@ -202,12 +206,6 @@ namespace slideshow
         {
             RTL_LOGFILE_CONTEXT( aLog, "::presentation::internal::ViewShape::draw()" );
 
-            ::cppcanvas::RendererSharedPtr pRenderer( 
-                getRenderer( rDestinationCanvas, rMtf, rAttr ) );
-
-            ENSURE_OR_RETURN( pRenderer, "ViewShape::draw(): Invalid renderer" );
-
-            pRenderer->setTransformation( rTransform );
 #if defined(VERBOSE) && OSL_DEBUG_LEVEL > 0
             rendering::RenderState aRenderState;
             ::canvas::tools::initRenderState(aRenderState);
@@ -235,34 +233,30 @@ namespace slideshow
                 DBG_UNHANDLED_EXCEPTION();
             }
 #endif
+            
+            drawinglayer::geometry::ViewInformation2D aViewInfo(
+				basegfx::B2DHomMatrix(), rTransform,  
+				basegfx::B2DRange(-10000,-10000,10000,10000), // HACK
+				xPage, 0.0, 
+				uno::Sequence<beans::PropertyValue>());
+
+            drawinglayer::processor2d::canvasProcessor2D::canvasProcessor2D aProcessor(
+                aViewInfo,
+                rDestinationCanvas->getUNOCanvas(),
+                rDestinationCanvas->getViewState());
+
+            aProcessor.process(xPrimitives);
+
+#if 0
+            pRenderer->setTransformation( rTransform );
             if( pClip )
                 pRenderer->setClip( *pClip );
             else
                 pRenderer->setClip();
 
-            if( rSubsets.empty() )
-            {
-                return pRenderer->draw();
-            }
-            else
-            {
-                // render subsets of whole metafile
-                // --------------------------------
-
-                bool bRet(true);
-                VectorOfDocTreeNodes::const_iterator 		aIter( rSubsets.begin() );
-                const VectorOfDocTreeNodes::const_iterator	aEnd ( rSubsets.end() );
-                while( aIter != aEnd )
-                {
-                    if( !pRenderer->drawSubset( aIter->getStartIndex(),
-                                                aIter->getEndIndex() ) )
-                        bRet = false;
-
-                    ++aIter;
-                }
-
-                return bRet;
-            }
+            return pRenderer->draw();
+#endif
+            return true;
         }
 
         namespace
@@ -307,6 +301,9 @@ namespace slideshow
         }
 
         bool ViewShape::renderSprite( const ViewLayerSharedPtr&             rViewLayer,
+                                      const uno::Reference<drawing::XShape>&    xShape,
+                                      const uno::Reference<drawing::XDrawPage>& xPage,
+                                      const uno::Sequence<uno::Reference<graphic::XPrimitive2D> >& xPrimitives,
                                       const GDIMetaFileSharedPtr&			rMtf,
                                       const ::basegfx::B2DRectangle&		rOrigBounds,
                                       const ::basegfx::B2DRectangle&		rBounds,
@@ -520,6 +517,9 @@ namespace slideshow
             ::cppcanvas::CanvasSharedPtr pContentCanvas( mpSprite->getContentCanvas() );
 
             return draw( pContentCanvas,
+                         xShape,
+                         xPage,
+                         xPrimitives,
                          rMtf,
                          pAttr,
                          aShapeTransformation,
@@ -528,6 +528,9 @@ namespace slideshow
         }
 
         bool ViewShape::render( const ::cppcanvas::CanvasSharedPtr&	rDestinationCanvas,
+                                const uno::Reference<drawing::XShape>&    xShape,
+                                const uno::Reference<drawing::XDrawPage>& xPage,
+                                const uno::Sequence<uno::Reference<graphic::XPrimitive2D> >& xPrimitives,
                                 const GDIMetaFileSharedPtr&			rMtf,
                                 const ::basegfx::B2DRectangle&		rBounds,
                                 const ::basegfx::B2DRectangle&		rUpdateBounds,
@@ -689,6 +692,9 @@ namespace slideshow
 
                         // render into this bitmap
                         if( !draw( pBitmapCanvas,
+                                   xShape,
+                                   xPage,
+                                   xPrimitives,
                                    rMtf,
                                    pAttr,
                                    aTransform,
@@ -734,6 +740,9 @@ namespace slideshow
                                         pAttr ) );
 
             return draw( rDestinationCanvas,
+                         xShape,
+                         xPage,
+                         xPrimitives,
                          rMtf,
                          pAttr,
                          aTransform,
@@ -866,10 +875,13 @@ namespace slideshow
             mbForceUpdate   = true;
         }
 
-        bool ViewShape::update( const GDIMetaFileSharedPtr&	rMtf,
-                                const RenderArgs&			rArgs,
-                                int							nUpdateFlags,
-                                bool						bIsVisible ) const
+        bool ViewShape::update( const uno::Reference<drawing::XShape>&    xShape,
+                                const uno::Reference<drawing::XDrawPage>& xPage,
+                                const uno::Sequence<uno::Reference<graphic::XPrimitive2D> >& xPrimitives,
+                                const GDIMetaFileSharedPtr&	              rMtf,
+                                const RenderArgs&			              rArgs,
+                                int							              nUpdateFlags,
+                                bool						              bIsVisible ) const
         {
             RTL_LOGFILE_CONTEXT( aLog, "::presentation::internal::ViewShape::update()" );
             ENSURE_OR_RETURN( mpViewLayer->getCanvas(), "ViewShape::update(): Invalid layer canvas" );
@@ -877,6 +889,9 @@ namespace slideshow
             // Shall we render to a sprite, or to a plain canvas?
             if( isBackgroundDetached() )
                 return renderSprite( mpViewLayer,
+                                     xShape,
+                                     xPage,
+                                     xPrimitives,
                                      rMtf,
                                      rArgs.maOrigBounds,
                                      rArgs.maBounds,
@@ -888,6 +903,9 @@ namespace slideshow
                                      bIsVisible );
             else
                 return render( mpViewLayer->getCanvas(),
+                               xShape,
+                               xPage,
+                               xPrimitives,
                                rMtf,
                                rArgs.maBounds,
                                rArgs.maUpdateBounds,
diff --git slideshow/source/engine/shapes/viewshape.hxx slideshow/source/engine/shapes/viewshape.hxx
index 684a93a..3c95171 100644
--- slideshow/source/engine/shapes/viewshape.hxx
+++ slideshow/source/engine/shapes/viewshape.hxx
@@ -48,6 +48,9 @@
 
 #include <vector>
 
+namespace com{ namespace sun{ namespace star{ namespace graphic {
+    class XPrimitive2D;
+}}}}
 
 namespace slideshow
 {
@@ -200,7 +203,14 @@ namespace slideshow
 
 	            @return whether the rendering finished successfully.
             */
-            bool update( const GDIMetaFileSharedPtr&	rMtf,
+            bool update( const ::com::sun::star::uno::Reference< 
+                            ::com::sun::star::drawing::XShape >& xShape,
+                         const ::com::sun::star::uno::Reference< 
+                            ::com::sun::star::drawing::XDrawPage >& xPage,
+                         const ::com::sun::star::uno::Sequence< 
+                         ::com::sun::star::uno::Reference< 
+                         ::com::sun::star::graphic::XPrimitive2D > >& xPrimitives,
+                         const GDIMetaFileSharedPtr&	rMtf,
                          const RenderArgs&				rArgs,
                          int							nUpdateFlags,
                          bool							bIsVisible ) const;
@@ -258,6 +268,13 @@ namespace slideshow
             	associated canvas (which happens to be mpLastCanvas).
              */
             bool draw( const ::cppcanvas::CanvasSharedPtr&	rDestinationCanvas,
+                       const ::com::sun::star::uno::Reference< 
+                       ::com::sun::star::drawing::XShape >& xShape,
+                       const ::com::sun::star::uno::Reference< 
+                       ::com::sun::star::drawing::XDrawPage >& xPage,
+                       const ::com::sun::star::uno::Sequence< 
+                       ::com::sun::star::uno::Reference< 
+                       ::com::sun::star::graphic::XPrimitive2D > >& xPrimitives,
                        const GDIMetaFileSharedPtr&			rMtf,
                        const ShapeAttributeLayerSharedPtr&	rAttr,
                        const ::basegfx::B2DHomMatrix&		rTransform,
@@ -267,6 +284,13 @@ namespace slideshow
             /** Render shape to an active sprite
              */
             bool renderSprite( const ViewLayerSharedPtr&            rViewLayer,
+                               const ::com::sun::star::uno::Reference< 
+                               ::com::sun::star::drawing::XShape >& xShape,
+                               const ::com::sun::star::uno::Reference< 
+                               ::com::sun::star::drawing::XDrawPage >& xPage,
+                               const ::com::sun::star::uno::Sequence< 
+                               ::com::sun::star::uno::Reference< 
+                               ::com::sun::star::graphic::XPrimitive2D > >& xPrimitives,
                                const GDIMetaFileSharedPtr&			rMtf,
                                const ::basegfx::B2DRectangle&		rOrigBounds,
                                const ::basegfx::B2DRectangle&		rBounds,
@@ -280,6 +304,13 @@ namespace slideshow
             /** Render shape to given canvas
              */
             bool render( const ::cppcanvas::CanvasSharedPtr&	rDestinationCanvas,
+                         const ::com::sun::star::uno::Reference< 
+                         ::com::sun::star::drawing::XShape >& xShape,
+                         const ::com::sun::star::uno::Reference< 
+                         ::com::sun::star::drawing::XDrawPage >& xPage,
+                         const ::com::sun::star::uno::Sequence< 
+                         ::com::sun::star::uno::Reference< 
+                         ::com::sun::star::graphic::XPrimitive2D > >& xPrimitives,
                          const GDIMetaFileSharedPtr&			rMtf,
                          const ::basegfx::B2DRectangle&			rBounds,
                          const ::basegfx::B2DRectangle&			rUpdateBounds,
diff --git slideshow/source/engine/slide/slideimpl.cxx slideshow/source/engine/slide/slideimpl.cxx
index 4cc5b05..aeaecc8 100644
--- slideshow/source/engine/slide/slideimpl.cxx
+++ slideshow/source/engine/slide/slideimpl.cxx
@@ -49,6 +49,7 @@
 #include <com/sun/star/beans/XPropertySet.hpp>
 #include <com/sun/star/container/XEnumerationAccess.hpp>
 #include <com/sun/star/awt/Rectangle.hpp>
+#include <com/sun/star/graphic/XPrimitiveFactory2D.hpp>
 #include <com/sun/star/presentation/ParagraphTarget.hpp>
 #include <com/sun/star/presentation/EffectNodeType.hpp>
 #include <com/sun/star/animations/XAnimationNodeSupplier.hpp>
@@ -374,7 +375,13 @@ SlideImpl::SlideImpl( const uno::Reference< drawing::XDrawPage >&			xDrawPage,
                rUserEventQueue,
                *this,
                rViewContainer,
-               xComponentContext ),
+               xComponentContext,
+               uno::Reference<com::sun::star::graphic::XPrimitiveFactory2D>(
+                   xComponentContext->getServiceManager()->createInstanceWithContext(
+                       ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM(
+                                            "com.sun.star.graphic.PrimitiveFactory2D") ),
+                       xComponentContext ), 
+                   uno::UNO_QUERY_THROW ) ),
     mrCursorManager( rCursorManager ),
     maAnimations( maContext,
                   getSlideSizeImpl() ),
diff --git slideshow/source/engine/slideshowcontext.cxx slideshow/source/engine/slideshowcontext.cxx
index 2b1b481..90108a7 100644
--- slideshow/source/engine/slideshowcontext.cxx
+++ slideshow/source/engine/slideshowcontext.cxx
@@ -31,6 +31,7 @@
 
 #include <com/sun/star/uno/Reference.hxx>
 #include <com/sun/star/uno/XComponentContext.hpp>
+#include <com/sun/star/graphic/XPrimitiveFactory2D.hpp>
 
 #include "slideshowcontext.hxx"
 #include "subsettableshapemanager.hxx"
@@ -58,7 +59,9 @@ SlideShowContext::SlideShowContext( SubsettableShapeManagerSharedPtr& rSubsettab
                                     CursorManager&                    rCursorManager,
                                     const UnoViewContainer&           rViewContainer,
                                     const uno::Reference< 
-                                          uno::XComponentContext>&    rComponentContext ) :
+                                          uno::XComponentContext>&    rComponentContext,
+                                    const uno::Reference< 
+                                          graphic::XPrimitiveFactory2D>& rPrimitiveFactory ) :
         mpSubsettableShapeManager( rSubsettableShapeManager ),
         mrEventQueue( rEventQueue ),
         mrEventMultiplexer( rEventMultiplexer ),
@@ -67,7 +70,8 @@ SlideShowContext::SlideShowContext( SubsettableShapeManagerSharedPtr& rSubsettab
         mrUserEventQueue( rUserEventQueue ),
         mrCursorManager( rCursorManager ),
         mrViewContainer( rViewContainer ),
-        mxComponentContext( rComponentContext )
+        mxComponentContext( rComponentContext ),
+        mxPrimitiveFactory( rPrimitiveFactory )
     {}
 
 void SlideShowContext::dispose() 
diff --git slideshow/source/engine/slideshowimpl.cxx slideshow/source/engine/slideshowimpl.cxx
index dce6f79..ede4b86 100644
--- slideshow/source/engine/slideshowimpl.cxx
+++ slideshow/source/engine/slideshowimpl.cxx
@@ -1459,7 +1459,8 @@ sal_Bool SlideShowImpl::setProperty( beans::PropertyValue const& rProperty )
                     maUserEventQueue,
                     *this,
                     maViewContainer,
-                    mxComponentContext) );
+                    mxComponentContext,
+                    0) );
         }
         else if (mpRehearseTimingsActivity) 
         {
diff --git slideshow/source/inc/slideshowcontext.hxx slideshow/source/inc/slideshowcontext.hxx
index 595829b..4995f18 100644
--- slideshow/source/inc/slideshowcontext.hxx
+++ slideshow/source/inc/slideshowcontext.hxx
@@ -34,9 +34,11 @@
 #include <com/sun/star/uno/Reference.hxx>
 #include <boost/shared_ptr.hpp>
 
-namespace com{ namespace sun{ namespace star{ namespace uno
-{
-    class XComponentContext;
+namespace com{ namespace sun{ namespace star{ 
+namespace uno {
+    class XComponentContext; }
+namespace graphic {
+    class XPrimitiveFactory2D;
 }}}}
 
 
@@ -101,7 +103,9 @@ namespace slideshow
                               CursorManager&                                    rCursorManager,
                               const UnoViewContainer&                           rViewContainer,
                               const ::com::sun::star::uno::Reference< 
-                                  ::com::sun::star::uno::XComponentContext>&    rComponentContext );
+                                  ::com::sun::star::uno::XComponentContext>&    rComponentContext,
+                              const ::com::sun::star::uno::Reference< 
+                                  ::com::sun::star::graphic::XPrimitiveFactory2D>& rPrimitiveFactory );
             void dispose();
 
             boost::shared_ptr<SubsettableShapeManager>&     mpSubsettableShapeManager;
@@ -114,6 +118,8 @@ namespace slideshow
             const UnoViewContainer&                         mrViewContainer;
             ::com::sun::star::uno::Reference< 
                 ::com::sun::star::uno::XComponentContext>	mxComponentContext;
+            ::com::sun::star::uno::Reference< 
+                ::com::sun::star::graphic::XPrimitiveFactory2D> mxPrimitiveFactory;
         };
     }
 }
diff --git slideshow/util/makefile.mk slideshow/util/makefile.mk
index f3fe923..5ece86f 100644
--- slideshow/util/makefile.mk
+++ slideshow/util/makefile.mk
@@ -64,6 +64,7 @@ SHL1STDLIBS= $(TOOLSLIB) \
 			 $(COMPHELPERLIB) \
 			 $(CPPUHELPERLIB) \
 			 $(BASEGFXLIB) \
+             $(DRAWINGLAYERLIB) \
 			 $(CANVASTOOLSLIB) \
 			 $(CPPCANVASLIB) \
 			 $(UNOTOOLSLIB) \
