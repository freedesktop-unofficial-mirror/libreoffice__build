--- svx.orig/inc/svxmsbas.hxx	2005-09-08 20:02:27.000000000 +0100
+++ svx/inc/svxmsbas.hxx	2007-06-29 16:32:38.000000000 +0100
@@ -45,8 +45,23 @@
 #endif
 
 #include <sot/storage.hxx>
+#include <vector>
+
+typedef ::std::pair< rtl::OUString, sal_Int16 > ModuleDesc; // type and group combination
+typedef ::std::vector< ModuleDesc > vecModuleTypes;
+typedef ::std::vector< String > vecStrings;
 
 class SfxObjectShell;
+class SVX_DLLPUBLIC SvxMSUserFormHelper
+{
+    vecStrings mvUserFormNames;
+
+public:
+    SvxMSUserFormHelper( SvStorageRef& xVBAStg, const String& rSubStorage );
+
+    vecStrings getUserFormNames();
+    bool isUserFormModuleName( const String& sName );
+};
 
 /* Construct with the root storage of the MS document, with bImportCode
  * set the visual basic code will be imported into the stardocument when Import
@@ -65,12 +80,15 @@ class SfxObjectShell;
 
 class SVX_DLLPUBLIC SvxImportMSVBasic
 {
+
 public:
+	enum MacroExportOption { Copy, Delete, Save };
+
 	SvxImportMSVBasic( SfxObjectShell &rDocS, SotStorage &rRoot,
 						BOOL bImportCode = TRUE, BOOL bCopyStorage = TRUE )
 		:	xRoot(&rRoot), rDocSh(rDocS),
 			bImport(bImportCode), bCopy(bCopyStorage)
-		{}
+		{ }
 	// returns the status of import:
 	// 0 - nothing has done
 	// bit 0 = 1 -> any code is imported to the SO-Basic
@@ -83,6 +101,8 @@ public:
 	// - returns a warning code if a modified basic exist, in all other
 	//   cases return ERRCODE_NONE.
 	ULONG SaveOrDelMSVBAStorage( BOOL bSaveInto, const String& rStorageName );
+	ULONG SaveOrCopyOrDeleteMSVBAStorage( const MacroExportOption& nOption, const String& rStorageName );
+
 
 	// check if the MS-VBA-Storage exist in the RootStorage of the DocShell.
 	// If it exist, then return the WarningId for loosing the information.
@@ -95,6 +115,11 @@ private:
 	BOOL bImport;
 	BOOL bCopy;
 
+	SVX_DLLPRIVATE BOOL GetVBAStorage(const String& rStorageName,
+					   const String &rSubStorageName,
+					   SvStorageRef &rProject,
+					   SvStorageRef &rVBA,
+					   bool  bCreate);
 	SVX_DLLPRIVATE BOOL ImportCode_Impl( const String& rStorageName,
 						  const String &rSubStorageName,
 						  BOOL bAsComment, BOOL bStripped);
--- svx.orig/source/msfilter/svxmsbas.cxx	2007-06-21 23:28:02.000000000 +0100
+++ svx/source/msfilter/svxmsbas.cxx	2007-06-29 17:25:04.000000000 +0100
@@ -61,7 +61,7 @@
 #include <svxmsbas.hxx>
 #endif
 #ifndef _MSVBASIC_HXX
-#include <msvbasic.hxx>
+#include <msvbasicdir.hxx>
 #endif
 #ifndef _MSOCXIMEX_HXX
 #include <msocximex.hxx>
@@ -110,6 +110,48 @@ bool lcl_hasVBAEnabled()
 	return false;
 }
 
+
+
+SvxMSUserFormHelper::SvxMSUserFormHelper( SvStorageRef& rxVBAStg, const String& sIgnore ) 
+{
+	if (rxVBAStg.Is() && !rxVBAStg->GetError())
+	{
+		SvStorageInfoList aContents;
+		rxVBAStg->FillInfoList(&aContents);
+		OSL_TRACE("lcl_getUserFormNames info list gives %d entries",  aContents.Count() );
+		for (USHORT nI = 0; nI < aContents.Count(); ++nI)
+		{
+			SvStorageInfo& rInfo = aContents.GetObject(nI);
+			OSL_TRACE("substorage item %d is %s ", nI, rtl::OUStringToOString( rInfo.GetName(), RTL_TEXTENCODING_UTF8 ).getStr() );
+			if (!rInfo.IsStream() && rInfo.GetName() != sIgnore ) 
+				mvUserFormNames.push_back(rInfo.GetName());
+		}	
+	}
+}
+
+vecStrings 
+SvxMSUserFormHelper::getUserFormNames()
+{
+	return mvUserFormNames;
+}
+
+bool
+SvxMSUserFormHelper::isUserFormModuleName( const String& sFormName )
+{
+	bool bFound = false;
+	vecStrings::const_iterator it = mvUserFormNames.begin();
+	vecStrings::const_iterator it_end = mvUserFormNames.end();
+	for ( ; it != it_end; ++it )
+	{
+		if ( sFormName == *it )
+		{
+			bFound = true;
+			break;
+		}
+	}
+	return bFound;
+}
+
 int SvxImportMSVBasic::Import( const String& rStorageName,
 								const String &rSubStorageName,
 								BOOL bAsComment, BOOL bStripped )
@@ -138,15 +180,8 @@ bool SvxImportMSVBasic::ImportForms_Impl
     if (!xVBAStg.Is() || xVBAStg->GetError())
         return false;
 
-    std::vector<String> aUserForms;
-    SvStorageInfoList aContents;
-    xVBAStg->FillInfoList(&aContents);
-    for (USHORT nI = 0; nI < aContents.Count(); ++nI)
-    {
-          SvStorageInfo& rInfo = aContents.GetObject(nI);
-          if (!rInfo.IsStream() && rInfo.GetName() != rSubStorageName)
-              aUserForms.push_back(rInfo.GetName());
-    }
+    SvxMSUserFormHelper userFormsHelper( xVBAStg, rSubStorageName );
+    vecStrings aUserForms = userFormsHelper.getUserFormNames();
 
     if (aUserForms.empty())
         return false;
@@ -215,7 +250,7 @@ bool SvxImportMSVBasic::ImportForms_Impl
                     xSF->createInstance(
                        OUString(RTL_CONSTASCII_USTRINGPARAM(
                            "com.sun.star.awt.UnoControlDialogModel"))), uno::UNO_QUERY);
-
+		OSL_TRACE("About to try and create userform %s", rtl::OUStringToOString( *aIter, RTL_TEXTENCODING_UTF8 ).getStr() );
                 OCX_UserForm aForm(xVBAStg, *aIter, *aIter, xDialog, xSF );
                 aForm.pDocSh = &rDocSh;
                 sal_Bool bOk = aForm.Read(xTypes);
@@ -277,180 +312,43 @@ BOOL SvxImportMSVBasic::CopyStorage_Impl
 	return bValidStg;
 }
 
+BOOL
+SvxImportMSVBasic::GetVBAStorage(const String &rStorageName,
+								 const String &rSubStorageName,
+								 SvStorageRef &rProject,
+								 SvStorageRef &rVBA,
+								 bool bCreate)
+{
+	ULONG nFlags = STREAM_READWRITE | STREAM_SHARE_DENYALL;
+	
+
+	if( !bCreate )
+			nFlags |= STREAM_NOCREATE;
+	OSL_TRACE("VBA Storage is extracted from %s in %s", rtl::OUStringToOString( rSubStorageName, RTL_TEXTENCODING_UTF8 ).getStr(),  rtl::OUStringToOString( rStorageName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	rProject = xRoot->OpenSotStorage( rStorageName, nFlags );
+	if( rProject.Is() && SVSTREAM_OK == rProject->GetError() )
+	{
+		rVBA = rProject->OpenSotStorage( rSubStorageName, nFlags );
+		if( rVBA.Is() && SVSTREAM_OK == rVBA->GetError() )
+			return true;
+		else
+			DBG_WARNING("No Visual Basic in Storage");
+	}
+	else
+		DBG_WARNING("No Macros Storage");
+
+	return false;
+}
 BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
 										const String &rSubStorageName,
 										BOOL bAsComment, BOOL bStripped )
 {
-	BOOL bRet = FALSE;
-	bAsComment = FALSE;
-	VBA_Impl aVBA( *xRoot, bAsComment );
-	if( aVBA.Open(rStorageName,rSubStorageName) )
+	bool bRet = false;
+	SvStorageRef xProject, xVBA;
+	if( GetVBAStorage( rStorageName, rSubStorageName, xProject, xVBA, false ) )
 	{
-		SFX_APP()->EnterBasicCall();
-        Reference<XLibraryContainer> xLibContainer = rDocSh.GetBasicContainer();
-		DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
-
-        UINT16 nStreamCount = aVBA.GetNoStreams();
-		Reference<XNameContainer> xLib;
-        if( xLibContainer.is() && nStreamCount )
-        {
-            String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
-		    if( !xLibContainer->hasByName( aLibName ) )
-			    xLibContainer->createLibrary( aLibName );
-
-            Any aLibAny = xLibContainer->getByName( aLibName );
-		    aLibAny >>= xLib;
-        }
-		if( xLib.is() )
-		{
-			for( UINT16 i=0; i<nStreamCount;i++)
-			{
-				StringArray aDecompressed = aVBA.Decompress(i);
-#if 0
-/*  DR 2005-08-11 #124850# Do not filter special characters from module name.
-    Just put the original module name and let the Basic interpreter deal with
-    it. Needed for roundtrip...
- */
-				ByteString sByteBasic(aVBA.GetStreamName(i),
-					RTL_TEXTENCODING_ASCII_US,
-						(RTL_UNICODETOTEXT_FLAGS_UNDEFINED_UNDERLINE|
-						RTL_UNICODETOTEXT_FLAGS_INVALID_UNDERLINE |
-						RTL_UNICODETOTEXT_FLAGS_PRIVATE_MAPTO0 |
-						RTL_UNICODETOTEXT_FLAGS_NOCOMPOSITE)
-				);
-
-				const String sBasicModule(sByteBasic,
-					RTL_TEXTENCODING_ASCII_US);
-#else
-                const String &sBasicModule = aVBA.GetStreamName( i);
-#endif
-                /* #117718# expose information regarding type of Module
-                * Class, Form or plain 'ould VBA module with a REM statment
-                * at the top of the module. Mapping of Module Name
-                * to type is performed in  VBA_Impl::Open() method,
-                * ( msvbasic.cxx ) by examining the PROJECT stream.
-                */
-
-                // using name from aVBA.GetStreamName
-                // because the encoding of the same returned
-                // is the same as the encoding for the names
-                // that are keys in the map used by GetModuleType method
-                const String &sOrigVBAModName = aVBA.GetStreamName( i );
-                ModuleType mType = aVBA.GetModuleType( sOrigVBAModName );
-
-                rtl::OUString sClassRem( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=" ) );
-
-                rtl::OUString modeTypeComment;
-
-                switch( mType )
-                {
-                    case Class:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAClassModule\n" ) );
-                        break;
-                    case Form:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAFormModule\n" ) );
-                        break;
-                    case Document:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADocumentModule\n" ) );
-                        break;
-                    case Normal:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAModule\n" ) );
-                        break;
-                    case Unknown:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAUnknown\n" ) );
-                        break;
-                    default:
-                        DBG_ERRORFILE( "SvxImportMSVBasic::ImportCode_Impl - unknown module type" );
-                        break;
-                }
-				static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
-				static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) ); 
-				if ( !bAsComment )
-				{
-					modeTypeComment = modeTypeComment + sVBAOption;
-					if ( mType == Class )
-						modeTypeComment = modeTypeComment + sClassOption;
-
-				}
-
-				String sModule(sBasicModule); //#i52606# no need to split Macros in 64KB blocks any more!
-				String sTemp;
-				if (bAsComment)
-				{
-					sTemp+=String(RTL_CONSTASCII_USTRINGPARAM( "Sub " ));
-					String sMunge(sModule);
-					//Streams can have spaces in them, but modulenames
-					//cannot !
-					sMunge.SearchAndReplaceAll(' ','_');
-
-					sTemp += sMunge;
-					sTemp.AppendAscii("\n");
-				};
-	            ::rtl::OUString aSource(sTemp);
-
-				for(ULONG j=0;j<aDecompressed.GetSize();j++)
-				{
-					if (bStripped)
-					{
-                        String *pStr = aDecompressed.Get(j);
-                        bool bMac = true;
-                        xub_StrLen nBegin = pStr->Search('\x0D');
-                        if ((STRING_NOTFOUND != nBegin) && (pStr->Len() > 1) && (pStr->GetChar(nBegin+1) == '\x0A'))
-                            bMac = false;
-
-                        const char cLineEnd = bMac ? '\x0D' : '\x0A';
-                        const String sAttribute(String::CreateFromAscii(
-                            bAsComment ? "Rem Attribute" : "Attribute"));
-						nBegin = 0;
-						while (STRING_NOTFOUND != (nBegin =	pStr->Search(sAttribute, nBegin)))
-						{
-                            if ((nBegin) && pStr->GetChar(nBegin-1) != cLineEnd)
-							{
-                                // npower #i63766# Need to skip instances of Attribute
-								// that are NOT Attribute statements
-								nBegin = nBegin + sAttribute.Len();
-                                continue;
-							}
-							xub_StrLen nEnd = pStr->Search(cLineEnd ,nBegin);
-                            // DR #i26521# catch STRING_NOTFOUND, will loop endless otherwise
-                            if( nEnd == STRING_NOTFOUND )
-                                pStr->Erase();
-                            else
-                                pStr->Erase(nBegin, (nEnd-nBegin)+1);
-						}
-					}
-					if( aDecompressed.Get(j)->Len() )
-					{
-			            aSource+=::rtl::OUString( *aDecompressed.Get(j) );
-					}
-
-				}
-				if (bAsComment)
-				{
-						aSource += rtl::OUString::createFromAscii("\nEnd Sub");
-				}
-				::rtl::OUString aModName( sModule );
-				if ( aSource.getLength() )
-				{
-					aSource = modeTypeComment + aSource;
-
-					Any aSourceAny;
-					aSourceAny <<= aSource;
-					if( xLib->hasByName( aModName ) )
-						xLib->replaceByName( aModName, aSourceAny );
-					else
-						xLib->insertByName( aModName, aSourceAny );
-				}                                
-
-				bRet = true;
-			}
-		}
-		SFX_APP()->LeaveBasicCall();
+		VBADir aVBA( xProject, xVBA );
+		bRet = aVBA.readBasic( rDocSh, bAsComment, bStripped );
 	}
 	return bRet;
 }
@@ -458,6 +356,15 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 ULONG SvxImportMSVBasic::SaveOrDelMSVBAStorage( BOOL bSaveInto,
 												const String& rStorageName )
 {
+	MacroExportOption aOption = Delete;
+	if ( bSaveInto )
+		aOption = Copy;
+	return SaveOrCopyOrDeleteMSVBAStorage( aOption, rStorageName );
+}
+
+ULONG SvxImportMSVBasic::SaveOrCopyOrDeleteMSVBAStorage( const MacroExportOption& nOption,
+												const String& rStorageName )
+{
 	ULONG nRet = ERRCODE_NONE;
     uno::Reference < embed::XStorage > xSrcRoot( rDocSh.GetStorage() );
 	String aDstStgName( GetMSBasicStorageName() );
@@ -465,23 +372,55 @@ ULONG SvxImportMSVBasic::SaveOrDelMSVBAS
                                 STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYALL ) );
 	if( xVBAStg.Is() && !xVBAStg->GetError() )
 	{
-		xVBAStg = 0;
-		if( bSaveInto )
+		xVBAStg = 0; 
+		// Copying from previous, why enterbasic call?  ( mmm seems like re-entrency
+		// detection foo ) 
+		SFX_APP()->EnterBasicCall();
+
+		BasicManager *pBasicMan = rDocSh.GetBasicManager();
+		bool bIsModified = ( pBasicMan && pBasicMan->IsBasicModified() );
+		bIsModified = true; 
+		SFX_APP()->LeaveBasicCall();
+		if( false /*bIsModified*/ ) // doesn't work, bIsModified is not reliable
+		{
+			OSL_TRACE("BASIC has being MODIFIED correct? ..." );
+			nRet = ERRCODE_SVX_MODIFIED_VBASIC_STORAGE;
+		}
+		if( nOption == Save /*&& bIsModified*/ )
+		{
+
+			OSL_TRACE("Crazy VBA writing hack !" );
+			SvStorageRef xProject, xVBA;
+			OUString sProject = OUString::createFromAscii( "_VBA_PROJECT_CUR" );
+			OUString sVBA = OUString::createFromAscii( "VBA" );
+			if( GetVBAStorage( // HACK:
+				sProject,sVBA,
+				xProject, xVBA, true ) )
+			{
+				SvStorageRef xMSProject = SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName, STREAM_STD_READ );
+				VBADir aDir( xProject, xVBA );
+				// Todo test for error ( and set error on 
+				// xRoot storage 
+				aDir.writeBasic( rDocSh ); // probably should return Error
+			}
+			else
+			{
+				OSL_TRACE( "Failed to create VBA storage" );
+			}
+		}
+		else if ( nOption == Copy )// Copy basic streams
 		{
-			BasicManager *pBasicMan = rDocSh.GetBasicManager();
-			if( pBasicMan && pBasicMan->IsBasicModified() )
-				nRet = ERRCODE_SVX_MODIFIED_VBASIC_STORAGE;
-
-            SotStorageRef xSrc = SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName, STREAM_STD_READ );
-            SotStorageRef xDst = xRoot->OpenSotStorage( rStorageName, STREAM_READWRITE | STREAM_TRUNC );
-            xSrc->CopyTo( xDst );
-            xDst->Commit();
-            ErrCode nError = xDst->GetError();
-            if ( nError == ERRCODE_NONE )
-                nError = xSrc->GetError();
-            if ( nError != ERRCODE_NONE )
-                xRoot->SetError( nError );
+			SotStorageRef xSrc = SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName, STREAM_STD_READ );
+			SotStorageRef xDst = xRoot->OpenSotStorage( rStorageName, STREAM_READWRITE | STREAM_TRUNC );
+			xSrc->CopyTo( xDst );
+			xDst->Commit();
+			ErrCode nError = xDst->GetError();
+			if ( nError == ERRCODE_NONE )
+				nError = xSrc->GetError();
+			if ( nError != ERRCODE_NONE )
+				xRoot->SetError( nError );
 		}
+				
 	}
 
 	return nRet;
--- svx.orig/source/msfilter/makefile.mk	2006-06-19 17:18:37.000000000 +0100
+++ svx/source/msfilter/makefile.mk	2007-06-28 10:18:35.000000000 +0100
@@ -53,6 +53,7 @@ SLOFILES=\
 	$(SLO)$/msdffimp.obj	\
 	$(SLO)$/msoleexp.obj	\
 	$(SLO)$/msvbasic.obj	\
+	$(SLO)$/msvbasicdir.obj	\
 	$(SLO)$/msashape.obj	\
 	$(SLO)$/svxmsbas.obj	\
 	$(SLO)$/msocximex.obj	\
@@ -65,6 +66,7 @@ EXCEPTIONSFILES= \
 	$(SLO)$/escherex.obj	\
 	$(SLO)$/msdffimp.obj	\
 	$(SLO)$/msashape3d.obj	\
+	$(SLO)$/msvbasicdir.obj	\
 	$(SLO)$/msvbasic.obj	\
 	$(SLO)$/msocximex.obj	\
 	$(SLO)$/msoleexp.obj	\
--- svx.orig/source/dialog/optfltr.src	2007-04-19 15:15:45.000000000 +0100
+++ svx/source/dialog/optfltr.src	2007-06-29 17:42:28.000000000 +0100
@@ -85,7 +85,7 @@ TabPage RID_OFAPAGE_MSFILTEROPT
 		Pos = MAP_APPFONT ( 12 , 69 ) ;
 		Size = MAP_APPFONT ( 236 , 10 ) ;
 		TabStop = TRUE ;
-		Text [ en-US ] = "Sa~ve original Basic code again";
+		Text [ en-US ] = "Sa~ve modifed Basic code";
 	};
 
     FixedLine GB_PPOINT
Index: udkapi/com/sun/star/script/makefile.mk
===================================================================
RCS file: /cvs/api/udkapi/com/sun/star/script/makefile.mk,v
retrieving revision 1.13
diff -r1.13 makefile.mk
91a92
> 	XModuleType.idl\
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ udkapi/com/sun/star/script/XModuleType.idl	2007-06-27 12:04:53.000000000 +0100
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XInvocation.idl,v $
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XInvocation_idl__ 
+#define __com_sun_star_script_XInvocation_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module script {  
+constants ModuleType
+{
+ 	const short Unknown = 0;
+	const short  Normal = 1;
+	const short  Class = 2;
+	const short Form = 3;
+	const short  Document = 4;
+};
+interface XModuleTypeAccess: com::sun::star::uno::XInterface
+{ 
+	short getModuleType( [in] string sModule );
+}; 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
--- sc.orig/inc/servuno.hxx	2005-09-08 18:56:51.000000000 +0100
+++ sc/inc/servuno.hxx	2007-06-26 17:24:50.000000000 +0100
@@ -99,8 +99,9 @@ class ScDocShell;
 
 // BM
 #define SC_SERVICE_CHDATAPROV   37
+#define SC_SERVICE_VBAOBJECTSTOEXPORT   38
 
-#define SC_SERVICE_COUNT        38
+#define SC_SERVICE_COUNT        39
 #define SC_SERVICE_INVALID		USHRT_MAX
 
 
--- sc.orig/source/filter/excel/expop2.cxx	2007-02-27 12:22:53.000000000 +0000
+++ sc/source/filter/excel/expop2.cxx	2007-06-29 17:39:44.000000000 +0100
@@ -65,7 +65,7 @@
 #ifndef SC_XELINK_HXX
 #include "xelink.hxx"
 #endif
-
+#include <hash_map>
 
 ExportBiff5::ExportBiff5( XclExpRootData& rExpData, SvStream& rStrm ):
     ExportTyp( rStrm, &rExpData.mrDoc, rExpData.meTextEnc ),
@@ -107,11 +107,11 @@ FltError ExportBiff5::Write()
     if( pDocShell && xRootStrg.Is() && bWriteBasicStrg )
 	{
         SvxImportMSVBasic aBasicImport( *pDocShell, *xRootStrg, bWriteBasicCode, bWriteBasicStrg );
-        ULONG nErr = aBasicImport.SaveOrDelMSVBAStorage( TRUE, EXC_STORAGE_VBA_PROJECT );
+	
+        ULONG nErr = aBasicImport.SaveOrCopyOrDeleteMSVBAStorage( bWriteBasicStrg ? SvxImportMSVBasic::Save : SvxImportMSVBasic::Copy , EXC_STORAGE_VBA_PROJECT );
 		if( nErr != ERRCODE_NONE )
             pDocShell->SetError( nErr );
 	}
-
 	pExcDoc->ReadDoc();			// ScDoc -> ExcDoc
 	pExcDoc->Write( aOut );		// wechstreamen
 
--- sc.orig/source/ui/unoobj/servuno.cxx	2006-07-21 15:45:27.000000000 +0100
+++ sc/source/ui/unoobj/servuno.cxx	2007-06-28 00:10:48.000000000 +0100
@@ -76,6 +76,108 @@
 #include <svx/xmlgrhlp.hxx>
 #endif
 
+
+//#include <cppuhelper/implbase1.hxx>
+//#include <map>
+#include "scextopt.hxx"
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/XModuleTypeAccess.hpp>
+#include <comphelper/processfactory.hxx>
+//#include <com/sun/star/container/XNameAccess.hxx>
+
+typedef std::hash_map< rtl::OUString, sal_Int16, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > ModuleTypeMap;
+
+class ScVbaObjectsToExport : public ::cppu::WeakImplHelper1< ::com::sun::star::container::XNameAccess > 
+{
+	ModuleTypeMap mModules;
+public:
+	ScVbaObjectsToExport( ScDocShell* pDocShell )
+	{
+		// The purpose of this service is to inform the vba export code what
+		// target application ( e.g. excel  ) Object modules ( and other ) to
+		// export. In the case of excel ( or a calc document to be exported as
+		// excel ) there are a number of modules that need to be exported
+		// Sheet modules ( and if this is an imported excel document we MUST use the codenames )
+		// ThisWorkbook
+		// Ordinary modules.
+		//
+
+		::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > aArgs(1);
+		aArgs[0] <<= pDocShell->GetModel();
+
+		::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory> xSF(comphelper::getProcessServiceFactory());
+		::com::sun::star::uno::Reference< ::com::sun::star::script::XModuleTypeAccess> xModuleTypeAccess ( xSF->createInstanceWithArguments( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.script.ExportableVBAModuleTypeAccess")), aArgs ), ::com::sun::star::uno::UNO_QUERY);
+
+		::com::sun::star::uno::Reference< ::com::sun::star::script::XLibraryContainer > xLibContainer = pDocShell->GetBasicContainer();		
+		if ( xLibContainer.is() && xModuleTypeAccess.is() )
+		{
+			// Populate Calc VBA Objects with Sheet Names, ThisWorkbook
+			String sStandard( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+			com::sun::star::uno::Reference< com::sun::star::container::XNameContainer > xLibrary( xLibContainer->getByName( sStandard ), com::sun::star::uno::UNO_QUERY );	
+			ScDocument* pDoc = pDocShell->GetDocument();
+			if ( xLibrary.is() && pDoc ) 
+			{
+				rtl::OUString sThisWorkbook( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
+				// Always a ThisWorkbook
+				mModules[ sThisWorkbook ] = ::com::sun::star::script::ModuleType::Document;
+				// Get the codenames for the sheets ( if they exist )
+				ScExtDocOptions* pOpts = pDoc->GetExtDocOptions();
+				for ( SCTAB n=0; n< pDoc->GetTableCount(); ++n )
+				{
+					String sCodeName;
+					if ( pOpts )
+						sCodeName = pOpts->GetCodeName( n );
+					if ( !sCodeName.Len() )
+						pDoc->GetName( n, sCodeName );
+					mModules[ sCodeName ] = ::com::sun::star::script::ModuleType::Document;
+				}
+				::com::sun::star::uno::Sequence< ::rtl::OUString > aNames = xLibrary->getElementNames();	
+				sal_Int32 nElems = aNames.getLength();
+				for ( sal_Int32 index = 0; index < nElems; ++index )
+				{
+					rtl::OUString sModName = aNames[ index ];
+					ModuleTypeMap::iterator it = mModules.find( sModName );
+					OSL_TRACE("->>>>> checking module %s, exists? %d", rtl::OUStringToOString( aNames[ index ], RTL_TEXTENCODING_UTF8 ).getStr(), it != mModules.end() );
+					if ( it == mModules.end() ) // doesn't exist
+						mModules[ sModName ] = xModuleTypeAccess->getModuleType( sModName );
+					
+				}
+
+			}
+		}
+	}
+// XNameAccess
+	virtual ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+	{
+		if  ( !hasByName( aName ) )
+			throw ::com::sun::star::container::NoSuchElementException();
+		ModuleTypeMap::iterator it = mModules.find( aName );
+		return ::com::sun::star::uno::makeAny( sal_Int16( it->second ) );
+	}
+	virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames() throw (::com::sun::star::uno::RuntimeException)
+	{
+		::com::sun::star::uno::Sequence< ::rtl::OUString > aNames( mModules.size() );
+		ModuleTypeMap::iterator it = mModules.begin();
+		ModuleTypeMap::iterator it_end = mModules.end();
+		::rtl::OUString* pDest = aNames.getArray();
+		for ( ; it != it_end ; ++it, ++pDest )
+			*pDest = it->first;
+		return aNames;
+	}
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException)
+	{
+		ModuleTypeMap::iterator it = mModules.find( aName );
+		return ( ( it != mModules.end() ) ? sal_True : sal_False );
+	}
+	virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException) { return getCppuType((sal_Int16*)0); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException) { return ( ( mModules.size() > 0 ) ? sal_True : sal_False); }
+
+
+// XElementAccess
+
+};
+
+
 using namespace ::com::sun::star;
 
 
@@ -125,7 +227,8 @@ static const sal_Char* __FAR_DATA aProvN
 
         "com.sun.star.sheet.DocumentSettings",      // SC_SERVICE_SHEETDOCSET
 
-        SC_SERVICENAME_CHDATAPROV                  // SC_SERVICE_CHDATAPROV
+        SC_SERVICENAME_CHDATAPROV,                  // SC_SERVICE_CHDATAPROV
+        "org.openoffice.vba.VBAObjectsToExport",    // SC_SERVICE_VBAOBJECTSTOEXPORT
 	};
 
 //
@@ -175,7 +278,8 @@ static const sal_Char* __FAR_DATA aOldNa
 		"",											// SC_SERVICE_CELLADDRESS
 		"",											// SC_SERVICE_RANGEADDRESS
         "",                                         // SC_SERVICE_SHEETDOCSET
-		""											// SC_SERVICE_CHDATAPROV
+		"",											// SC_SERVICE_CHDATAPROV
+		"",											// SC_SERVICE_VBAOBJECTSTOEXPORT
 	};
 
 
@@ -356,7 +460,13 @@ uno::Reference<uno::XInterface> ScServic
             if (pDocShell)
                 xRet = *new ScChart2DataProvider( pDocShell );
             break;
+		case SC_SERVICE_VBAOBJECTSTOEXPORT:
+		{
+			xRet = *new ScVbaObjectsToExport( pDocShell );
+			break;
+		}
 	}
+		
 	return xRet;
 }
 
@@ -370,5 +480,3 @@ uno::Sequence<rtl::OUString> ScServicePr
 }
 
 
-
-
--- basic.orig/source/classes/sbxmod.cxx	2007-06-21 23:28:04.000000000 +0100
+++ basic/source/classes/sbxmod.cxx	2007-06-27 15:20:09.000000000 +0100
@@ -239,7 +239,7 @@ extern "C" int CDECL compare_strings( co
 
 SbModule::SbModule( const String& rName )
 		 : SbxObject( String( RTL_CONSTASCII_USTRINGPARAM("StarBASICModule") ) ),
-		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL ), bThisWorkBook( false )
+		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL ), bThisWorkBook( false ), mnModuleType( ::com::sun::star::script::ModuleType::Normal )
 {
 	SetName( rName );
 	SetFlag( SBX_EXTSEARCH | SBX_GBLSEARCH );
@@ -523,6 +523,8 @@ void SbModule::SetSource( const String& 
 
 void SbModule::SetSource32( const ::rtl::OUString& r )
 {
+	OSL_TRACE("SetSource32");
+	mnModuleType = ::com::sun::star::script::ModuleType::Normal;
 	aOUSource = r;
 	StartDefinitions();
 	SbiTokenizer aTok( r );
@@ -553,6 +555,8 @@ void SbModule::SetSource32( const ::rtl:
 				if( eCurTok == OPTION )
 				{
 					eCurTok = aTok.Next();
+					if ( eCurTok == CLASSMODULE )
+						mnModuleType = ::com::sun::star::script::ModuleType::Class;
 					if( eCurTok == COMPATIBLE 
 					|| ( ( eCurTok == VBASUPPORT ) && ( aTok.Next() == NUMBER ) && ( aTok.GetDbl()== 1 ) ) )
 						aTok.SetCompatible( true );
--- basic.orig/source/comp/codegen.cxx	2007-06-21 23:28:02.000000000 +0100
+++ basic/source/comp/codegen.cxx	2007-06-27 15:21:46.000000000 +0100
@@ -40,7 +40,7 @@
 #include "sbcomp.hxx"
 #include "image.hxx"
 #include <limits>
-
+#include <com/sun/star/script/ModuleType.hpp>
 // nInc ist die Inkrementgroesse der Puffer
 
 SbiCodeGen::SbiCodeGen( SbModule& r, SbiParser* p, short nInc )
@@ -141,6 +141,7 @@ void SbiCodeGen::Save()
 	int nIfaceCount = 0;
 	if( pParser->bClassModule )
 	{
+		rMod.SetModuleTypeHint( ::com::sun::star::script::ModuleType::Class );
 		p->SetFlag( SBIMG_CLASSMODULE );
 		pCLASSFAC->AddClassModule( &rMod );
 
@@ -162,6 +163,7 @@ void SbiCodeGen::Save()
 	}
 	else
 	{
+		rMod.SetModuleTypeHint( ::com::sun::star::script::ModuleType::Normal );
 		pCLASSFAC->RemoveClassModule( &rMod );
 	}
 	if( pParser->bText )
--- basic.orig/source/inc/scriptcont.hxx	2007-03-15 15:38:46.000000000 +0000
+++ basic/source/inc/scriptcont.hxx	2007-06-27 16:45:37.000000000 +0100
@@ -44,6 +44,8 @@
 #include "basmgr.hxx"
 #endif
 
+#include <com/sun/star/script/XModuleTypeAccess.hpp>
+
 class BasicManager;
 
 //============================================================================
@@ -182,6 +184,31 @@ public:
     );
 };
 
+
+class ExportableVBAModuleTypeAccess : public ::cppu::WeakImplHelper2< ::com::sun::star::script::XModuleTypeAccess, ::com::sun::star::lang::XInitialization >
+{
+	bool m_bInit;
+	BasicManager* m_pBasicMgr;
+	::com::sun::star::uno::Reference< ::com::sun::star::container::XNameAccess > m_xDialogs;
+public:
+	ExportableVBAModuleTypeAccess() : m_bInit(false), m_pBasicMgr(NULL){}
+	::rtl::OUString SAL_CALL getImplementationName( ) throw (::com::sun::star::uno::RuntimeException);
+	static ::rtl::OUString getImplementationName_static();
+
+	::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames() throw (::com::sun::star::uno::RuntimeException);
+	static ::com::sun::star::uno::Sequence< ::rtl::OUString > getSupportedServiceNames_static();
+
+	static ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL Create ( const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XComponentContext >& ) throw ( ::com::sun::star::uno::Exception );
+	
+// Methods XInitialization
+	virtual void SAL_CALL initialize( const ::com::sun::star::uno::Sequence< 
+		::com::sun::star::uno::Any >& aArguments ) 
+			throw (::com::sun::star::uno::Exception, 
+				::com::sun::star::uno::RuntimeException);	
+// Methods XModuleTypeAccess
+	virtual ::sal_Int16 SAL_CALL getModuleType( const ::rtl::OUString& sModule ) 
+		throw (::com::sun::star::uno::RuntimeException); 
+};
 }   // namespace base
 
 #endif
--- basic.orig/source/uno/sbservices.cxx	2006-12-05 12:04:54.000000000 +0000
+++ basic/source/uno/sbservices.cxx	2007-06-27 15:42:44.000000000 +0100
@@ -51,6 +51,7 @@ namespace basic
     //--------------------------------------------------------------------
     extern void createRegistryInfo_SfxDialogLibraryContainer();
     extern void createRegistryInfo_SfxScriptLibraryContainer();
+    extern void createRegistryInfo_ExportableVBAModuleTypeAccess();
 
     static void initializeModule()
     {
@@ -62,6 +63,7 @@ namespace basic
             {
                 createRegistryInfo_SfxDialogLibraryContainer();
                 createRegistryInfo_SfxScriptLibraryContainer();
+		createRegistryInfo_ExportableVBAModuleTypeAccess();
             }
         }
     }
--- basic.orig/source/uno/scriptcont.cxx	2007-03-15 15:39:48.000000000 +0000
+++ basic/source/uno/scriptcont.cxx	2007-06-27 16:48:24.000000000 +0100
@@ -117,6 +117,10 @@
 #include <cppuhelper/factory.hxx>
 #include <com/sun/star/util/VetoException.hpp>
 
+// start includes for BasicModuleTypeAccess
+#include "basicmanagerrepository.hxx"
+#include <com/sun/star/script/ModuleType.hpp>
+// end includes for BasicModuleTypeAccess
 namespace basic
 {
 
@@ -1190,6 +1194,104 @@ void SfxScriptLibrary::storeResourcesToS
 	(void)xStorage;
 }
 
+
+// hacky service for determining the Module type, class, normal ( eventually other
+// 'object' module types as support is added )
+
+#define STANDARD String( RTL_CONSTASCII_USTRINGPARAM("Standard") )
+
+void createRegistryInfo_ExportableVBAModuleTypeAccess()
+{
+    static OAutoRegistration< ExportableVBAModuleTypeAccess > aAutoRegistration;
+}
+
+::rtl::OUString SAL_CALL ExportableVBAModuleTypeAccess::getImplementationName( ) throw (RuntimeException)
+{
+    return getImplementationName_static();
+}
+
+Sequence< ::rtl::OUString > SAL_CALL ExportableVBAModuleTypeAccess::getSupportedServiceNames( ) throw (RuntimeException)
+{
+    return getSupportedServiceNames_static();
+}
+
+Sequence< OUString > ExportableVBAModuleTypeAccess::getSupportedServiceNames_static()
+{
+    Sequence< OUString > aServiceNames( 1 );
+    aServiceNames[0] = OUString::createFromAscii( "com.sun.star.script.ExportableVBAModuleTypeAccess" );
+    return aServiceNames;
+}
+
+rtl::OUString ExportableVBAModuleTypeAccess::getImplementationName_static()
+{
+    static OUString aImplName;
+    static sal_Bool bNeedsInit = sal_True;
+
+	MutexGuard aGuard( Mutex::getGlobalMutex() );
+    if( bNeedsInit )
+    {
+        aImplName = OUString::createFromAscii( "ExportableVBAModuleTypeAccess" );
+        bNeedsInit = sal_False;
+    }
+    return aImplName;
+}
+
+Reference< XInterface > SAL_CALL ExportableVBAModuleTypeAccess::Create
+    ( const Reference< XComponentContext >& )
+        throw( Exception )
+{
+    Reference< XInterface > xRet =
+        static_cast< XInterface* >( static_cast< OWeakObject* >(new ExportableVBAModuleTypeAccess()) );
+    return xRet;
+}
+
+void
+ExportableVBAModuleTypeAccess::initialize( const ::com::sun::star::uno::Sequence< 
+		::com::sun::star::uno::Any >& aArguments ) 
+			throw (::com::sun::star::uno::Exception, 
+				::com::sun::star::uno::RuntimeException)
+{
+	if ( m_bInit )
+		throw ::com::sun::star::uno::RuntimeException(); // already initialiazed
+	::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > xDocument;
+	if ( aArguments.getLength() == 0 )	
+		throw ::com::sun::star::uno::RuntimeException(); // args expected
+	xDocument.set( aArguments[ 0 ], ::com::sun::star::uno::UNO_QUERY_THROW ); // we only care about first argument ( should only be one anyway )
+	m_pBasicMgr =  BasicManagerRepository::getDocumentBasicManager( xDocument );	
+	if ( m_pBasicMgr )
+	{
+		::com::sun::star::uno::Reference< ::com::sun::star::script::XLibraryContainer > xLibContainer( m_pBasicMgr->GetDialogLibraryContainer(), ::com::sun::star::uno::UNO_QUERY );
+		if ( xLibContainer.is() )
+		{
+			m_xDialogs.set( xLibContainer->getByName( rtl::OUString( STANDARD ) ), ::com::sun::star::uno::UNO_QUERY );
+		}
+		
+	}
+}
+
+::sal_Int16 SAL_CALL 
+ExportableVBAModuleTypeAccess::getModuleType( const ::rtl::OUString& sModule ) 
+		throw (::com::sun::star::uno::RuntimeException)
+{
+	sal_Int16 nType = ::com::sun::star::script::ModuleType::Unknown;
+	StarBASIC* pLib =  NULL;
+	if ( m_pBasicMgr )
+		pLib = m_pBasicMgr->GetLib( String( STANDARD ) );
+	if ( pLib )
+	{
+		SbModule* pMod = dynamic_cast< SbModule* >( pLib->Find( sModule,  SbxCLASS_DONTCARE ) );
+		if ( pMod )
+		{
+			// Check if it's a Dialog first
+			if ( m_xDialogs.is() && m_xDialogs->hasByName( sModule ) )	
+				nType = ::com::sun::star::script::ModuleType::Form;
+			else
+				nType = pMod->GetModuleTypeHint();
+		}
+	}
+	return nType;
+}
+
 //============================================================================
 
 }   // namespace basic
--- basic.orig/inc/basic/sbmod.hxx	2007-06-21 23:28:04.000000000 +0100
+++ basic/inc/basic/sbmod.hxx	2007-06-27 15:20:29.000000000 +0100
@@ -46,6 +46,7 @@
 #ifndef _RTL_USTRING_HXX
 #include <rtl/ustring.hxx>
 #endif
+#include <com/sun/star/script/ModuleType.hpp>
 
 class SbMethod;
 class SbProperty;
@@ -76,6 +77,7 @@ protected:
 	SbiBreakpoints*	pBreaks;			// Breakpoints
 	SbClassData*	pClassData;
 	bool bThisWorkBook; // Should really subclass the module
+	sal_Int16	mnModuleType;
 
 	void			StartDefinitions();
 	SbMethod*		GetMethod( const String&, SbxDataType );
@@ -128,6 +130,8 @@ public:
 
 	// Zeilenbereiche von Subs
 	virtual SbMethod*	GetFunctionForLine( USHORT );
+	virtual sal_Int16 GetModuleTypeHint() { return mnModuleType; }
+	virtual void SetModuleTypeHint( sal_Int16 nType ) { mnModuleType = nType; };
 
     // Store only image, no source (needed for new password protection)
    	BOOL StoreBinaryData( SvStream& );    
