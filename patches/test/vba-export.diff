diff -rup /data4/scratch/oog680-m5/sc/inc/servuno.hxx sc/inc/servuno.hxx
--- /data4/scratch/oog680-m5/sc/inc/servuno.hxx	2007-09-24 15:00:30.000000000 +0100
+++ sc/inc/servuno.hxx	2007-09-16 22:04:01.000000000 +0100
@@ -102,8 +102,9 @@ class ScDocShell;
 
 #define SC_SERVICE_FORMULAPARS  38
 #define SC_SERVICE_OPCODEMAPPER 39
+#define SC_SERVICE_VBAOBJECTSTOEXPORT   40
 
-#define SC_SERVICE_COUNT        40
+#define SC_SERVICE_COUNT        41
 #define SC_SERVICE_INVALID		USHRT_MAX
 
 
diff -rup /data4/scratch/oog680-m5/sc/source/core/tool/compiler.cxx sc/source/core/tool/compiler.cxx
--- /data4/scratch/oog680-m5/sc/source/core/tool/compiler.cxx	2007-09-24 15:00:30.000000000 +0100
+++ sc/source/core/tool/compiler.cxx	2007-09-19 01:05:47.000000000 +0100
@@ -1543,6 +1546,8 @@ ScCompiler::ScCompiler( ScDocument* pDoc
     nMaxTab = pDoc ? pDoc->GetTableCount() - 1 : 0;
     pStack = NULL;
     nNumFmt = NUMBERFORMAT_UNDEFINED;
+    SetCompileEnglish( TRUE ); 
+
 }
 
 ScCompiler::ScCompiler(ScDocument* pDocument, const ScAddress& rPos )
diff -rup /data4/scratch/oog680-m5/sc/source/filter/excel/excdoc.cxx sc/source/filter/excel/excdoc.cxx
--- /data4/scratch/oog680-m5/sc/source/filter/excel/excdoc.cxx	2007-09-24 15:00:14.000000000 +0100
+++ sc/source/filter/excel/excdoc.cxx	2007-09-17 12:29:36.000000000 +0100
@@ -181,12 +181,14 @@ void ExcTable::FillAsHeader( ExcBoundshe
 		Add( rR.pTabId );
         if( HasVbaStorage() )
 		{
+			OSL_TRACE("*** hmm exporting doc codename");
 			Add( new XclObproj );
-            const String& rCodeName = GetExtDocOptions().GetDocSettings().maGlobCodeName;
-            if( rCodeName.Len() )
-                Add( new XclCodename( rCodeName ) );
+            String rCodeName = GetExtDocOptions().GetDocSettings().maGlobCodeName;
+            if( rCodeName.Len() == 0 )
+				// should 'ThisWorkbook' be localized?
+				rCodeName = String( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
+            Add( new XclCodename( rCodeName ) );
 		}
-		Add( new ExcDummy8_00b );
 	}
 
 	// erst Namen- und Tabellen-Eintraege aufbauen
@@ -403,8 +405,17 @@ void ExcTable::FillAsTable( size_t nCode
         Add( new XclExpCondFormatBuffer( GetRoot() ) );
 
         if( HasVbaStorage() )
+		{
+			String cName;
             if( nCodeNameIdx < GetExtDocOptions().GetCodeNameCount() )
-                Add( new XclCodename( GetExtDocOptions().GetCodeName( nCodeNameIdx ) ) );
+                cName = GetExtDocOptions().GetCodeName( nCodeNameIdx );
+			else
+				// CodeName = SheetName
+				GetDoc().GetName( nCodeNameIdx, cName );
+				
+			if ( cName.Len() > 0 )
+            	Add( new XclCodename( cName ) );
+		}
 	}
 
     // list of HLINK records, generated by the cell table
diff -rup /data4/scratch/oog680-m5/sc/source/filter/excel/excimp8.cxx sc/source/filter/excel/excimp8.cxx
--- /data4/scratch/oog680-m5/sc/source/filter/excel/excimp8.cxx	2007-09-24 15:00:14.000000000 +0100
+++ sc/source/filter/excel/excimp8.cxx	2007-09-20 09:18:20.000000000 +0100
@@ -221,7 +221,8 @@ void ImportExcel8::Boundsheet( void )
 
     String aName( aIn.ReadUniString( nLen ) );
     GetTabInfo().AppendXclTabName( aName, nBdshtTab );
-
+    if ( ( nGrbit & 0x600 ) )
+	return;
     ScfTools::ConvertToScSheetName( aName );
 	*pExcRoot->pTabNameBuff << aName;
 
diff -rup /data4/scratch/oog680-m5/sc/source/filter/excel/expop2.cxx sc/source/filter/excel/expop2.cxx
--- /data4/scratch/oog680-m5/sc/source/filter/excel/expop2.cxx	2007-07-17 14:33:35.000000000 +0100
+++ sc/source/filter/excel/expop2.cxx	2007-09-16 22:04:01.000000000 +0100
@@ -65,7 +65,7 @@
 #ifndef SC_XELINK_HXX
 #include "xelink.hxx"
 #endif
-
+#include <hash_map>
 
 ExportBiff5::ExportBiff5( XclExpRootData& rExpData, SvStream& rStrm ):
     ExportTyp( rStrm, &rExpData.mrDoc, rExpData.meTextEnc ),
@@ -107,11 +107,11 @@ FltError ExportBiff5::Write()
     if( pDocShell && xRootStrg.Is() && bWriteBasicStrg )
 	{
         SvxImportMSVBasic aBasicImport( *pDocShell, *xRootStrg, bWriteBasicCode, bWriteBasicStrg );
-        ULONG nErr = aBasicImport.SaveOrDelMSVBAStorage( TRUE, EXC_STORAGE_VBA_PROJECT );
+	
+        ULONG nErr = aBasicImport.SaveOrCopyOrDeleteMSVBAStorage( bWriteBasicStrg ? SvxImportMSVBasic::Save : SvxImportMSVBasic::Copy , EXC_STORAGE_VBA_PROJECT );
 		if( nErr != ERRCODE_NONE )
             pDocShell->SetError( nErr );
 	}
-
 	pExcDoc->ReadDoc();			// ScDoc -> ExcDoc
 	pExcDoc->Write( aOut );		// wechstreamen
 
diff -rup /data4/scratch/oog680-m5/sc/source/filter/excel/read.cxx sc/source/filter/excel/read.cxx
--- /data4/scratch/oog680-m5/sc/source/filter/excel/read.cxx	2007-09-24 15:00:14.000000000 +0100
+++ sc/source/filter/excel/read.cxx	2007-09-20 09:46:05.000000000 +0100
@@ -1047,6 +1047,7 @@ FltError ImportExcel8::Read( void )
                             default:
                                 // TODO: do not create a sheet in the Calc document
                                 pD->SetVisible( GetCurrScTab(), FALSE );
+				pD->DeleteTab( GetCurrScTab(), 0 );
                                 XclTools::SkipSubStream( maStrm );
                                 IncCurrScTab();
                         }
diff -rup /data4/scratch/oog680-m5/sc/source/ui/unoobj/servuno.cxx sc/source/ui/unoobj/servuno.cxx
--- /data4/scratch/oog680-m5/sc/source/ui/unoobj/servuno.cxx	2007-09-24 15:00:30.000000000 +0100
+++ sc/source/ui/unoobj/servuno.cxx	2007-09-20 08:55:34.000000000 +0100
@@ -77,6 +77,121 @@
 #include <svx/xmlgrhlp.hxx>
 #endif
 
+
+//#include <cppuhelper/implbase1.hxx>
+//#include <map>
+#include "scextopt.hxx"
+#include <com/sun/star/script/ModuleType.hpp>
+#include <com/sun/star/script/XModuleTypeAccess.hpp>
+#include <comphelper/processfactory.hxx>
+//#include <com/sun/star/container/XNameAccess.hxx>
+#include <sfx2/docfilt.hxx>
+#include <sfx2/docfile.hxx>
+typedef std::hash_map< rtl::OUString, sal_Int16, ::rtl::OUStringHash, ::std::equal_to< ::rtl::OUString > > ModuleTypeMap;
+
+class ScVbaObjectsToExport : public ::cppu::WeakImplHelper1< ::com::sun::star::container::XNameAccess > 
+{
+	ModuleTypeMap mModules;
+public:
+	ScVbaObjectsToExport( ScDocShell* pDocShell )
+	{
+		// The purpose of this service is to inform the vba export code what
+		// target application ( e.g. excel  ) Object modules ( and other ) to
+		// export. In the case of excel ( or a calc document to be exported as
+		// excel ) there are a number of modules that need to be exported
+		// Sheet modules ( and if this is an imported excel document we MUST use the codenames )
+		// ThisWorkbook
+		// Ordinary modules.
+		//
+
+		::com::sun::star::uno::Sequence< ::com::sun::star::uno::Any > aArgs(1);
+		aArgs[0] <<= pDocShell->GetModel();
+
+		::com::sun::star::uno::Reference< ::com::sun::star::lang::XMultiServiceFactory> xSF(comphelper::getProcessServiceFactory());
+		::com::sun::star::uno::Reference< ::com::sun::star::script::XModuleTypeAccess> xModuleTypeAccess ( xSF->createInstanceWithArguments( rtl::OUString(RTL_CONSTASCII_USTRINGPARAM( "com.sun.star.script.ExportableVBAModuleTypeAccess")), aArgs ), ::com::sun::star::uno::UNO_QUERY);
+
+		::com::sun::star::uno::Reference< ::com::sun::star::script::XLibraryContainer > xLibContainer = pDocShell->GetBasicContainer();		
+		if ( xLibContainer.is() && xModuleTypeAccess.is() )
+		{
+			// Populate Calc VBA Objects with Sheet Names, ThisWorkbook
+			String sStandard( RTL_CONSTASCII_USTRINGPARAM("Standard") );
+			com::sun::star::uno::Reference< com::sun::star::container::XNameContainer > xLibrary( xLibContainer->getByName( sStandard ), com::sun::star::uno::UNO_QUERY );	
+			ScDocument* pDoc = pDocShell->GetDocument();
+			if ( xLibrary.is() && pDoc ) 
+			{
+				rtl::OUString sThisWorkbook( RTL_CONSTASCII_USTRINGPARAM("ThisWorkbook") );
+				// Always a ThisWorkbook
+				mModules[ sThisWorkbook ] = ::com::sun::star::script::ModuleType::Document;
+				// Get the codenames for the sheets ( if they exist )
+				ScExtDocOptions* pOpts = pDoc->GetExtDocOptions();
+				for ( SCTAB n=0; n< pDoc->GetTableCount(); ++n )
+				{
+					String sCodeName;
+					if ( pOpts )
+						sCodeName = pOpts->GetCodeName( n );
+					if ( !sCodeName.Len() )
+					{
+						pDoc->GetName( n, sCodeName );
+						//some times there is a bogus sheet name from the import where ( sheetname = modulename )
+						bool bIsMSDoc = ( pOpts != 0 );
+						OSL_TRACE("bIsMSDoc = %d", bIsMSDoc );
+						//if ( bIsMSDoc && xLibrary->hasByName( sCodeName ) )
+						if ( false && xLibrary->hasByName( sCodeName ) )
+						{
+							OSL_TRACE("Detected bogus module %s", rtl::OUStringToOString( sCodeName, RTL_TEXTENCODING_UTF8 ).getStr() );
+							sCodeName = String();
+						}
+					}
+					if ( sCodeName.Len() > 0 )
+						mModules[ sCodeName ] = ::com::sun::star::script::ModuleType::Document;
+				}
+				::com::sun::star::uno::Sequence< ::rtl::OUString > aNames = xLibrary->getElementNames();	
+				sal_Int32 nElems = aNames.getLength();
+				for ( sal_Int32 index = 0; index < nElems; ++index )
+				{
+					rtl::OUString sModName = aNames[ index ];
+					ModuleTypeMap::iterator it = mModules.find( sModName );
+					OSL_TRACE("->>>>> checking module %s, exists? %d", rtl::OUStringToOString( aNames[ index ], RTL_TEXTENCODING_UTF8 ).getStr(), it != mModules.end() );
+					if ( it == mModules.end() ) // doesn't exist
+						mModules[ sModName ] = xModuleTypeAccess->getModuleType( sModName );
+					
+				}
+
+			}
+		}
+	}
+// XNameAccess
+	virtual ::com::sun::star::uno::Any SAL_CALL getByName( const ::rtl::OUString& aName ) throw (::com::sun::star::container::NoSuchElementException, ::com::sun::star::lang::WrappedTargetException, ::com::sun::star::uno::RuntimeException)
+	{
+		if  ( !hasByName( aName ) )
+			throw ::com::sun::star::container::NoSuchElementException();
+		ModuleTypeMap::iterator it = mModules.find( aName );
+		return ::com::sun::star::uno::makeAny( sal_Int16( it->second ) );
+	}
+	virtual ::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getElementNames() throw (::com::sun::star::uno::RuntimeException)
+	{
+		::com::sun::star::uno::Sequence< ::rtl::OUString > aNames( mModules.size() );
+		ModuleTypeMap::iterator it = mModules.begin();
+		ModuleTypeMap::iterator it_end = mModules.end();
+		::rtl::OUString* pDest = aNames.getArray();
+		for ( ; it != it_end ; ++it, ++pDest )
+			*pDest = it->first;
+		return aNames;
+	}
+	virtual ::sal_Bool SAL_CALL hasByName( const ::rtl::OUString& aName ) throw (::com::sun::star::uno::RuntimeException)
+	{
+		ModuleTypeMap::iterator it = mModules.find( aName );
+		return ( ( it != mModules.end() ) ? sal_True : sal_False );
+	}
+	virtual ::com::sun::star::uno::Type SAL_CALL getElementType(  ) throw (::com::sun::star::uno::RuntimeException) { return getCppuType((sal_Int16*)0); }
+	virtual ::sal_Bool SAL_CALL hasElements(  ) throw (::com::sun::star::uno::RuntimeException) { return ( ( mModules.size() > 0 ) ? sal_True : sal_False); }
+
+
+// XElementAccess
+
+};
+
+
 using namespace ::com::sun::star;
 
 
@@ -128,7 +243,8 @@ static const sal_Char* __FAR_DATA aProvN
 
         SC_SERVICENAME_CHDATAPROV,                  // SC_SERVICE_CHDATAPROV
         SC_SERVICENAME_FORMULAPARS,                 // SC_SERVICE_FORMULAPARS
-        SC_SERVICENAME_OPCODEMAPPER                 // SC_SERVICE_OPCODEMAPPER
+        SC_SERVICENAME_OPCODEMAPPER,                 // SC_SERVICE_OPCODEMAPPER
+        "org.openoffice.vba.VBAObjectsToExport",    // SC_SERVICE_VBAOBJECTSTOEXPORT
 	};
 
 //
@@ -180,7 +296,8 @@ static const sal_Char* __FAR_DATA aOldNa
         "",                                         // SC_SERVICE_SHEETDOCSET
         "",                                         // SC_SERVICE_CHDATAPROV
         "",                                         // SC_SERVICE_FORMULAPARS
-        ""                                          // SC_SERVICE_OPCODEMAPPER
+        "",                                          // SC_SERVICE_OPCODEMAPPER
+        ""                                          // SC_SERVICE_VBAOBJECTSTOEXPORT
 	};
 
 
@@ -373,7 +490,13 @@ uno::Reference<uno::XInterface> ScServic
         case SC_SERVICE_OPCODEMAPPER:
             xRet.set(static_cast<sheet::XFormulaOpCodeMapper*>(new ScFormulaOpCodeMapperObj));
             break;
+		case SC_SERVICE_VBAOBJECTSTOEXPORT:
+		{
+			xRet = *new ScVbaObjectsToExport( pDocShell );
+			break;
+		}
 	}
+		
 	return xRet;
 }
 
diff -rup /data4/scratch/oog680-m5/basic/inc/basic/sbmod.hxx basic/inc/basic/sbmod.hxx
--- /data4/scratch/oog680-m5/basic/inc/basic/sbmod.hxx	2007-09-24 15:00:27.000000000 +0100
+++ basic/inc/basic/sbmod.hxx	2007-09-16 22:04:01.000000000 +0100
@@ -46,6 +46,7 @@
 #ifndef _RTL_USTRING_HXX
 #include <rtl/ustring.hxx>
 #endif
+#include <com/sun/star/script/ModuleType.hpp>
 
 class SbMethod;
 class SbProperty;
@@ -77,6 +78,7 @@ protected:
 	SbClassData*	pClassData;
 	bool bThisWorkBook; // Should really subclass the module
 	bool mbVBACompat;
+	sal_Int16	mnModuleType;
 
 	void			StartDefinitions();
 	SbMethod*		GetMethod( const String&, SbxDataType );
@@ -129,6 +131,8 @@ public:
 
 	// Zeilenbereiche von Subs
 	virtual SbMethod*	GetFunctionForLine( USHORT );
+	virtual sal_Int16 GetModuleTypeHint() { return mnModuleType; }
+	virtual void SetModuleTypeHint( sal_Int16 nType ) { mnModuleType = nType; };
 
     // Store only image, no source (needed for new password protection)
    	BOOL StoreBinaryData( SvStream& );    
diff -rup /data4/scratch/oog680-m5/basic/source/classes/sbxmod.cxx basic/source/classes/sbxmod.cxx
--- /data4/scratch/oog680-m5/basic/source/classes/sbxmod.cxx	2007-09-24 15:00:27.000000000 +0100
+++ basic/source/classes/sbxmod.cxx	2007-09-16 22:04:01.000000000 +0100
@@ -239,7 +239,7 @@ extern "C" int CDECL compare_strings( co
 
 SbModule::SbModule( const String& rName )
 		 : SbxObject( String( RTL_CONSTASCII_USTRINGPARAM("StarBASICModule") ) ),
-		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL ), bThisWorkBook( false ), mbVBACompat( false )
+		   pImage( NULL ), pBreaks( NULL ), pClassData( NULL ), bThisWorkBook( false ), mbVBACompat( false ), mnModuleType( ::com::sun::star::script::ModuleType::Normal )
 {
 	SetName( rName );
 	SetFlag( SBX_EXTSEARCH | SBX_GBLSEARCH );
@@ -523,6 +523,7 @@ void SbModule::SetSource( const String& 
 
 void SbModule::SetSource32( const ::rtl::OUString& r )
 {
+	mnModuleType = ::com::sun::star::script::ModuleType::Normal;
 	aOUSource = r;
 	StartDefinitions();
 	SbiTokenizer aTok( r );
@@ -554,6 +556,8 @@ void SbModule::SetSource32( const ::rtl:
 				{
 					eCurTok = aTok.Next();
 					mbVBACompat = ( eCurTok == VBASUPPORT ) && ( aTok.Next() == NUMBER ) && ( aTok.GetDbl()== 1 );
+					if ( eCurTok == CLASSMODULE )
+						mnModuleType = ::com::sun::star::script::ModuleType::Class;
 					if( eCurTok == COMPATIBLE 
 					|| mbVBACompat )
 						aTok.SetCompatible( true );
diff -rup /data4/scratch/oog680-m5/basic/source/comp/codegen.cxx basic/source/comp/codegen.cxx
--- /data4/scratch/oog680-m5/basic/source/comp/codegen.cxx	2007-09-24 15:00:08.000000000 +0100
+++ basic/source/comp/codegen.cxx	2007-09-16 22:04:01.000000000 +0100
@@ -40,7 +40,7 @@
 #include "sbcomp.hxx"
 #include "image.hxx"
 #include <limits>
-
+#include <com/sun/star/script/ModuleType.hpp>
 // nInc ist die Inkrementgroesse der Puffer
 
 SbiCodeGen::SbiCodeGen( SbModule& r, SbiParser* p, short nInc )
@@ -141,6 +141,7 @@ void SbiCodeGen::Save()
 	int nIfaceCount = 0;
 	if( pParser->bClassModule )
 	{
+		rMod.SetModuleTypeHint( ::com::sun::star::script::ModuleType::Class );
 		p->SetFlag( SBIMG_CLASSMODULE );
 		pCLASSFAC->AddClassModule( &rMod );
 
@@ -162,6 +163,7 @@ void SbiCodeGen::Save()
 	}
 	else
 	{
+		rMod.SetModuleTypeHint( ::com::sun::star::script::ModuleType::Normal );
 		pCLASSFAC->RemoveClassModule( &rMod );
 	}
 	if( pParser->bText )
diff -rup /data4/scratch/oog680-m5/basic/source/inc/scriptcont.hxx basic/source/inc/scriptcont.hxx
--- /data4/scratch/oog680-m5/basic/source/inc/scriptcont.hxx	2007-06-27 15:23:39.000000000 +0100
+++ basic/source/inc/scriptcont.hxx	2007-09-16 22:04:01.000000000 +0100
@@ -44,6 +44,8 @@
 #include <basic/basmgr.hxx>
 #endif
 
+#include <com/sun/star/script/XModuleTypeAccess.hpp>
+
 class BasicManager;
 
 //============================================================================
@@ -182,6 +184,31 @@ public:
     );
 };
 
+
+class ExportableVBAModuleTypeAccess : public ::cppu::WeakImplHelper2< ::com::sun::star::script::XModuleTypeAccess, ::com::sun::star::lang::XInitialization >
+{
+	bool m_bInit;
+	BasicManager* m_pBasicMgr;
+	::com::sun::star::uno::Reference< ::com::sun::star::container::XNameAccess > m_xDialogs;
+public:
+	ExportableVBAModuleTypeAccess() : m_bInit(false), m_pBasicMgr(NULL){}
+	::rtl::OUString SAL_CALL getImplementationName( ) throw (::com::sun::star::uno::RuntimeException);
+	static ::rtl::OUString getImplementationName_static();
+
+	::com::sun::star::uno::Sequence< ::rtl::OUString > SAL_CALL getSupportedServiceNames() throw (::com::sun::star::uno::RuntimeException);
+	static ::com::sun::star::uno::Sequence< ::rtl::OUString > getSupportedServiceNames_static();
+
+	static ::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface > SAL_CALL Create ( const ::com::sun::star::uno::Reference< ::com::sun::star::uno::XComponentContext >& ) throw ( ::com::sun::star::uno::Exception );
+	
+// Methods XInitialization
+	virtual void SAL_CALL initialize( const ::com::sun::star::uno::Sequence< 
+		::com::sun::star::uno::Any >& aArguments ) 
+			throw (::com::sun::star::uno::Exception, 
+				::com::sun::star::uno::RuntimeException);	
+// Methods XModuleTypeAccess
+	virtual ::sal_Int16 SAL_CALL getModuleType( const ::rtl::OUString& sModule ) 
+		throw (::com::sun::star::uno::RuntimeException); 
+};
 }   // namespace base
 
 #endif
diff -rup /data4/scratch/oog680-m5/basic/source/uno/sbservices.cxx basic/source/uno/sbservices.cxx
--- /data4/scratch/oog680-m5/basic/source/uno/sbservices.cxx	2006-12-05 12:04:54.000000000 +0000
+++ basic/source/uno/sbservices.cxx	2007-09-16 22:04:01.000000000 +0100
@@ -51,6 +51,7 @@ namespace basic
     //--------------------------------------------------------------------
     extern void createRegistryInfo_SfxDialogLibraryContainer();
     extern void createRegistryInfo_SfxScriptLibraryContainer();
+    extern void createRegistryInfo_ExportableVBAModuleTypeAccess();
 
     static void initializeModule()
     {
@@ -62,6 +63,7 @@ namespace basic
             {
                 createRegistryInfo_SfxDialogLibraryContainer();
                 createRegistryInfo_SfxScriptLibraryContainer();
+		createRegistryInfo_ExportableVBAModuleTypeAccess();
             }
         }
     }
diff -rup /data4/scratch/oog680-m5/basic/source/uno/scriptcont.cxx basic/source/uno/scriptcont.cxx
--- /data4/scratch/oog680-m5/basic/source/uno/scriptcont.cxx	2007-06-27 15:34:11.000000000 +0100
+++ basic/source/uno/scriptcont.cxx	2007-09-16 22:12:22.000000000 +0100
@@ -117,6 +117,10 @@
 #include <cppuhelper/factory.hxx>
 #include <com/sun/star/util/VetoException.hpp>
 
+// start includes for BasicModuleTypeAccess
+#include <basic/basicmanagerrepository.hxx>
+#include <com/sun/star/script/ModuleType.hpp>
+// end includes for BasicModuleTypeAccess
 namespace basic
 {
 
@@ -1192,6 +1196,104 @@ void SfxScriptLibrary::storeResourcesToS
 	(void)xStorage;
 }
 
+
+// hacky service for determining the Module type, class, normal ( eventually other
+// 'object' module types as support is added )
+
+#define STANDARD String( RTL_CONSTASCII_USTRINGPARAM("Standard") )
+
+void createRegistryInfo_ExportableVBAModuleTypeAccess()
+{
+    static OAutoRegistration< ExportableVBAModuleTypeAccess > aAutoRegistration;
+}
+
+::rtl::OUString SAL_CALL ExportableVBAModuleTypeAccess::getImplementationName( ) throw (RuntimeException)
+{
+    return getImplementationName_static();
+}
+
+Sequence< ::rtl::OUString > SAL_CALL ExportableVBAModuleTypeAccess::getSupportedServiceNames( ) throw (RuntimeException)
+{
+    return getSupportedServiceNames_static();
+}
+
+Sequence< OUString > ExportableVBAModuleTypeAccess::getSupportedServiceNames_static()
+{
+    Sequence< OUString > aServiceNames( 1 );
+    aServiceNames[0] = OUString::createFromAscii( "com.sun.star.script.ExportableVBAModuleTypeAccess" );
+    return aServiceNames;
+}
+
+rtl::OUString ExportableVBAModuleTypeAccess::getImplementationName_static()
+{
+    static OUString aImplName;
+    static sal_Bool bNeedsInit = sal_True;
+
+	MutexGuard aGuard( Mutex::getGlobalMutex() );
+    if( bNeedsInit )
+    {
+        aImplName = OUString::createFromAscii( "ExportableVBAModuleTypeAccess" );
+        bNeedsInit = sal_False;
+    }
+    return aImplName;
+}
+
+Reference< XInterface > SAL_CALL ExportableVBAModuleTypeAccess::Create
+    ( const Reference< XComponentContext >& )
+        throw( Exception )
+{
+    Reference< XInterface > xRet =
+        static_cast< XInterface* >( static_cast< OWeakObject* >(new ExportableVBAModuleTypeAccess()) );
+    return xRet;
+}
+
+void
+ExportableVBAModuleTypeAccess::initialize( const ::com::sun::star::uno::Sequence< 
+		::com::sun::star::uno::Any >& aArguments ) 
+			throw (::com::sun::star::uno::Exception, 
+				::com::sun::star::uno::RuntimeException)
+{
+	if ( m_bInit )
+		throw ::com::sun::star::uno::RuntimeException(); // already initialiazed
+	::com::sun::star::uno::Reference< ::com::sun::star::frame::XModel > xDocument;
+	if ( aArguments.getLength() == 0 )	
+		throw ::com::sun::star::uno::RuntimeException(); // args expected
+	xDocument.set( aArguments[ 0 ], ::com::sun::star::uno::UNO_QUERY_THROW ); // we only care about first argument ( should only be one anyway )
+	m_pBasicMgr =  BasicManagerRepository::getDocumentBasicManager( xDocument );	
+	if ( m_pBasicMgr )
+	{
+		::com::sun::star::uno::Reference< ::com::sun::star::script::XLibraryContainer > xLibContainer( m_pBasicMgr->GetDialogLibraryContainer(), ::com::sun::star::uno::UNO_QUERY );
+		if ( xLibContainer.is() )
+		{
+			m_xDialogs.set( xLibContainer->getByName( rtl::OUString( STANDARD ) ), ::com::sun::star::uno::UNO_QUERY );
+		}
+		
+	}
+}
+
+::sal_Int16 SAL_CALL 
+ExportableVBAModuleTypeAccess::getModuleType( const ::rtl::OUString& sModule ) 
+		throw (::com::sun::star::uno::RuntimeException)
+{
+	sal_Int16 nType = ::com::sun::star::script::ModuleType::Unknown;
+	StarBASIC* pLib =  NULL;
+	if ( m_pBasicMgr )
+		pLib = m_pBasicMgr->GetLib( String( STANDARD ) );
+	if ( pLib )
+	{
+		SbModule* pMod = dynamic_cast< SbModule* >( pLib->Find( sModule,  SbxCLASS_DONTCARE ) );
+		if ( pMod )
+		{
+			// Check if it's a Dialog first
+			if ( m_xDialogs.is() && m_xDialogs->hasByName( sModule ) )	
+				nType = ::com::sun::star::script::ModuleType::Form;
+			else
+				nType = pMod->GetModuleTypeHint();
+		}
+	}
+	return nType;
+}
+
 //============================================================================
 
 }   // namespace basic
diff -rup /data4/scratch/oog680-m5/svx/inc/svxmsbas.hxx svx/inc/svxmsbas.hxx
--- /data4/scratch/oog680-m5/svx/inc/svxmsbas.hxx	2005-09-08 20:02:27.000000000 +0100
+++ svx/inc/svxmsbas.hxx	2007-09-16 22:04:01.000000000 +0100
@@ -45,8 +45,23 @@
 #endif
 
 #include <sot/storage.hxx>
+#include <vector>
+
+typedef ::std::pair< rtl::OUString, sal_Int16 > ModuleDesc; // type and group combination
+typedef ::std::vector< ModuleDesc > vecModuleTypes;
+typedef ::std::vector< String > vecStrings;
 
 class SfxObjectShell;
+class SVX_DLLPUBLIC SvxMSUserFormHelper
+{
+    vecStrings mvUserFormNames;
+
+public:
+    SvxMSUserFormHelper( SvStorageRef& xVBAStg, const String& rSubStorage );
+
+    vecStrings getUserFormNames();
+    bool isUserFormModuleName( const String& sName );
+};
 
 /* Construct with the root storage of the MS document, with bImportCode
  * set the visual basic code will be imported into the stardocument when Import
@@ -65,12 +80,15 @@ class SfxObjectShell;
 
 class SVX_DLLPUBLIC SvxImportMSVBasic
 {
+
 public:
+	enum MacroExportOption { Copy, Delete, Save };
+
 	SvxImportMSVBasic( SfxObjectShell &rDocS, SotStorage &rRoot,
 						BOOL bImportCode = TRUE, BOOL bCopyStorage = TRUE )
 		:	xRoot(&rRoot), rDocSh(rDocS),
 			bImport(bImportCode), bCopy(bCopyStorage)
-		{}
+		{ }
 	// returns the status of import:
 	// 0 - nothing has done
 	// bit 0 = 1 -> any code is imported to the SO-Basic
@@ -83,6 +101,8 @@ public:
 	// - returns a warning code if a modified basic exist, in all other
 	//   cases return ERRCODE_NONE.
 	ULONG SaveOrDelMSVBAStorage( BOOL bSaveInto, const String& rStorageName );
+	ULONG SaveOrCopyOrDeleteMSVBAStorage( const MacroExportOption& nOption, const String& rStorageName );
+
 
 	// check if the MS-VBA-Storage exist in the RootStorage of the DocShell.
 	// If it exist, then return the WarningId for loosing the information.
@@ -95,6 +115,11 @@ private:
 	BOOL bImport;
 	BOOL bCopy;
 
+	SVX_DLLPRIVATE BOOL GetVBAStorage(const String& rStorageName,
+					   const String &rSubStorageName,
+					   SvStorageRef &rProject,
+					   SvStorageRef &rVBA,
+					   bool  bCreate);
 	SVX_DLLPRIVATE BOOL ImportCode_Impl( const String& rStorageName,
 						  const String &rSubStorageName,
 						  BOOL bAsComment, BOOL bStripped);
--- /data4/latestBuild/ooo-build/build/oog680-m5/udkapi/com/sun/star/script/makefile.mk	2006-11-02 16:35:10.000000000 +0000
+++ udkapi/com/sun/star/script/makefile.mk	2007-09-16 22:04:01.000000000 +0100
@@ -89,6 +89,7 @@ IDLFILES=\
 	XScriptEventsAttacher.idl\
 	XDefaultMethod.idl\
 	XDefaultProperty.idl\
+	XModuleType.idl\
 
 # ------------------------------------------------------------------
 
--- /dev/null	2007-05-04 11:54:36.000000000 +0100
+++ udkapi/com/sun/star/script/XModuleType.idl	2007-09-16 22:04:01.000000000 +0100
@@ -0,0 +1,61 @@
+/*************************************************************************
+ *
+ *  OpenOffice.org - a multi-platform office productivity suite
+ *
+ *  $RCSfile: XInvocation.idl,v $
+ *
+ *  $Revision$
+ *
+ *  last change: $Author$ $Date$
+ *
+ *  The Contents of this file are made available subject to
+ *  the terms of GNU Lesser General Public License Version 2.1.
+ *
+ *
+ *    GNU Lesser General Public License Version 2.1
+ *    =============================================
+ *    Copyright 2005 by Sun Microsystems, Inc.
+ *    901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *    This library is free software; you can redistribute it and/or
+ *    modify it under the terms of the GNU Lesser General Public
+ *    License version 2.1, as published by the Free Software Foundation.
+ *
+ *    This library is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *    Lesser General Public License for more details.
+ *
+ *    You should have received a copy of the GNU Lesser General Public
+ *    License along with this library; if not, write to the Free Software
+ *    Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *    MA  02111-1307  USA
+ *
+ ************************************************************************/
+#ifndef __com_sun_star_script_XInvocation_idl__ 
+#define __com_sun_star_script_XInvocation_idl__ 
+ 
+#ifndef __com_sun_star_uno_XInterface_idl__ 
+#include <com/sun/star/uno/XInterface.idl> 
+#endif 
+ 
+//============================================================================= 
+ 
+module com {  module sun {  module star {  module script {  
+constants ModuleType
+{
+ 	const short Unknown = 0;
+	const short  Normal = 1;
+	const short  Class = 2;
+	const short Form = 3;
+	const short  Document = 4;
+};
+interface XModuleTypeAccess: com::sun::star::uno::XInterface
+{ 
+	short getModuleType( [in] string sModule );
+}; 
+//============================================================================= 
+ 
+}; }; }; };  
+ 
+#endif 
diff -rup ../../build/oog680-m5/svx/source/msfilter/makefile.mk svx/source/msfilter/makefile.mk
--- ../../build/oog680-m5/svx/source/msfilter/makefile.mk	2006-06-19 17:18:37.000000000 +0100
+++ svx/source/msfilter/makefile.mk	2007-09-16 22:18:33.000000000 +0100
@@ -53,6 +53,7 @@ SLOFILES=\
 	$(SLO)$/msdffimp.obj	\
 	$(SLO)$/msoleexp.obj	\
 	$(SLO)$/msvbasic.obj	\
+	$(SLO)$/msvbasicdir.obj	\
 	$(SLO)$/msashape.obj	\
 	$(SLO)$/svxmsbas.obj	\
 	$(SLO)$/msocximex.obj	\
@@ -65,6 +66,7 @@ EXCEPTIONSFILES= \
 	$(SLO)$/escherex.obj	\
 	$(SLO)$/msdffimp.obj	\
 	$(SLO)$/msashape3d.obj	\
+	$(SLO)$/msvbasicdir.obj	\
 	$(SLO)$/msvbasic.obj	\
 	$(SLO)$/msocximex.obj	\
 	$(SLO)$/msoleexp.obj	\
diff -rup ../../build/oog680-m5/svx/source/msfilter/svxmsbas.cxx svx/source/msfilter/svxmsbas.cxx
--- ../../build/oog680-m5/svx/source/msfilter/svxmsbas.cxx	2007-09-24 15:44:27.000000000 +0100
+++ svx/source/msfilter/svxmsbas.cxx	2007-09-17 12:01:57.000000000 +0100
@@ -61,7 +61,7 @@
 #include <svxmsbas.hxx>
 #endif
 #ifndef _MSVBASIC_HXX
-#include <msvbasic.hxx>
+#include <msvbasicdir.hxx>
 #endif
 #ifndef _MSOCXIMEX_HXX
 #include <svx/msocximex.hxx>
@@ -110,6 +110,48 @@ bool lcl_hasVBAEnabled()
 	return false;
 }
 
+
+
+SvxMSUserFormHelper::SvxMSUserFormHelper( SvStorageRef& rxVBAStg, const String& sIgnore ) 
+{
+	if (rxVBAStg.Is() && !rxVBAStg->GetError())
+	{
+		SvStorageInfoList aContents;
+		rxVBAStg->FillInfoList(&aContents);
+		OSL_TRACE("lcl_getUserFormNames info list gives %d entries",  aContents.Count() );
+		for (USHORT nI = 0; nI < aContents.Count(); ++nI)
+		{
+			SvStorageInfo& rInfo = aContents.GetObject(nI);
+			OSL_TRACE("substorage item %d is %s ", nI, rtl::OUStringToOString( rInfo.GetName(), RTL_TEXTENCODING_UTF8 ).getStr() );
+			if (!rInfo.IsStream() && rInfo.GetName() != sIgnore ) 
+				mvUserFormNames.push_back(rInfo.GetName());
+		}	
+	}
+}
+
+vecStrings 
+SvxMSUserFormHelper::getUserFormNames()
+{
+	return mvUserFormNames;
+}
+
+bool
+SvxMSUserFormHelper::isUserFormModuleName( const String& sFormName )
+{
+	bool bFound = false;
+	vecStrings::const_iterator it = mvUserFormNames.begin();
+	vecStrings::const_iterator it_end = mvUserFormNames.end();
+	for ( ; it != it_end; ++it )
+	{
+		if ( sFormName == *it )
+		{
+			bFound = true;
+			break;
+		}
+	}
+	return bFound;
+}
+
 int SvxImportMSVBasic::Import( const String& rStorageName,
 								const String &rSubStorageName,
 								BOOL bAsComment, BOOL bStripped )
@@ -138,15 +180,8 @@ bool SvxImportMSVBasic::ImportForms_Impl
     if (!xVBAStg.Is() || xVBAStg->GetError())
         return false;
 
-    std::vector<String> aUserForms;
-    SvStorageInfoList aContents;
-    xVBAStg->FillInfoList(&aContents);
-    for (USHORT nI = 0; nI < aContents.Count(); ++nI)
-    {
-          SvStorageInfo& rInfo = aContents.GetObject(nI);
-          if (!rInfo.IsStream() && rInfo.GetName() != rSubStorageName)
-              aUserForms.push_back(rInfo.GetName());
-    }
+    SvxMSUserFormHelper userFormsHelper( xVBAStg, rSubStorageName );
+    vecStrings aUserForms = userFormsHelper.getUserFormNames();
 
     if (aUserForms.empty())
         return false;
@@ -215,7 +250,7 @@ bool SvxImportMSVBasic::ImportForms_Impl
                     xSF->createInstance(
                        OUString(RTL_CONSTASCII_USTRINGPARAM(
                            "com.sun.star.awt.UnoControlDialogModel"))), uno::UNO_QUERY);
-
+		OSL_TRACE("About to try and create userform %s", rtl::OUStringToOString( *aIter, RTL_TEXTENCODING_UTF8 ).getStr() );
                 OCX_UserForm aForm(xVBAStg, *aIter, *aIter, xDialog, xSF );
                 aForm.pDocSh = &rDocSh;
                 sal_Bool bOk = aForm.Read(xTypes);
@@ -277,180 +312,43 @@ BOOL SvxImportMSVBasic::CopyStorage_Impl
 	return bValidStg;
 }
 
+BOOL
+SvxImportMSVBasic::GetVBAStorage(const String &rStorageName,
+								 const String &rSubStorageName,
+								 SvStorageRef &rProject,
+								 SvStorageRef &rVBA,
+								 bool bCreate)
+{
+	ULONG nFlags = STREAM_READWRITE | STREAM_SHARE_DENYALL;
+	
+
+	if( !bCreate )
+			nFlags |= STREAM_NOCREATE;
+	OSL_TRACE("VBA Storage is extracted from %s in %s", rtl::OUStringToOString( rSubStorageName, RTL_TEXTENCODING_UTF8 ).getStr(),  rtl::OUStringToOString( rStorageName, RTL_TEXTENCODING_UTF8 ).getStr() );
+	rProject = xRoot->OpenSotStorage( rStorageName, nFlags );
+	if( rProject.Is() && SVSTREAM_OK == rProject->GetError() )
+	{
+		rVBA = rProject->OpenSotStorage( rSubStorageName, nFlags );
+		if( rVBA.Is() && SVSTREAM_OK == rVBA->GetError() )
+			return true;
+		else
+			DBG_WARNING("No Visual Basic in Storage");
+	}
+	else
+		DBG_WARNING("No Macros Storage");
+
+	return false;
+}
 BOOL SvxImportMSVBasic::ImportCode_Impl( const String& rStorageName,
 										const String &rSubStorageName,
 										BOOL bAsComment, BOOL bStripped )
 {
-	BOOL bRet = FALSE;
-	bAsComment = FALSE;
-	VBA_Impl aVBA( *xRoot, bAsComment );
-	if( aVBA.Open(rStorageName,rSubStorageName) )
+	bool bRet = false;
+	SvStorageRef xProject, xVBA;
+	if( GetVBAStorage( rStorageName, rSubStorageName, xProject, xVBA, false ) )
 	{
-		SFX_APP()->EnterBasicCall();
-        Reference<XLibraryContainer> xLibContainer = rDocSh.GetBasicContainer();
-		DBG_ASSERT( xLibContainer.is(), "No BasicContainer!" );
-
-        UINT16 nStreamCount = aVBA.GetNoStreams();
-		Reference<XNameContainer> xLib;
-        if( xLibContainer.is() && nStreamCount )
-        {
-            String aLibName( RTL_CONSTASCII_USTRINGPARAM( "Standard" ) );
-		    if( !xLibContainer->hasByName( aLibName ) )
-			    xLibContainer->createLibrary( aLibName );
-
-            Any aLibAny = xLibContainer->getByName( aLibName );
-		    aLibAny >>= xLib;
-        }
-		if( xLib.is() )
-		{
-			for( UINT16 i=0; i<nStreamCount;i++)
-			{
-				StringArray aDecompressed = aVBA.Decompress(i);
-#if 0
-/*  DR 2005-08-11 #124850# Do not filter special characters from module name.
-    Just put the original module name and let the Basic interpreter deal with
-    it. Needed for roundtrip...
- */
-				ByteString sByteBasic(aVBA.GetStreamName(i),
-					RTL_TEXTENCODING_ASCII_US,
-						(RTL_UNICODETOTEXT_FLAGS_UNDEFINED_UNDERLINE|
-						RTL_UNICODETOTEXT_FLAGS_INVALID_UNDERLINE |
-						RTL_UNICODETOTEXT_FLAGS_PRIVATE_MAPTO0 |
-						RTL_UNICODETOTEXT_FLAGS_NOCOMPOSITE)
-				);
-
-				const String sBasicModule(sByteBasic,
-					RTL_TEXTENCODING_ASCII_US);
-#else
-                const String &sBasicModule = aVBA.GetStreamName( i);
-#endif
-                /* #117718# expose information regarding type of Module
-                * Class, Form or plain 'ould VBA module with a REM statment
-                * at the top of the module. Mapping of Module Name
-                * to type is performed in  VBA_Impl::Open() method,
-                * ( msvbasic.cxx ) by examining the PROJECT stream.
-                */
-
-                // using name from aVBA.GetStreamName
-                // because the encoding of the same returned
-                // is the same as the encoding for the names
-                // that are keys in the map used by GetModuleType method
-                const String &sOrigVBAModName = aVBA.GetStreamName( i );
-                ModuleType mType = aVBA.GetModuleType( sOrigVBAModName );
-
-                rtl::OUString sClassRem( RTL_CONSTASCII_USTRINGPARAM( "Rem Attribute VBA_ModuleType=" ) );
-
-                rtl::OUString modeTypeComment;
-
-                switch( mType )
-                {
-                    case Class:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAClassModule\n" ) );
-                        break;
-                    case Form:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAFormModule\n" ) );
-                        break;
-                    case Document:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBADocumentModule\n" ) );
-                        break;
-                    case Normal:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAModule\n" ) );
-                        break;
-                    case Unknown:
-                        modeTypeComment = sClassRem +
-                            ::rtl::OUString( RTL_CONSTASCII_USTRINGPARAM( "VBAUnknown\n" ) );
-                        break;
-                    default:
-                        DBG_ERRORFILE( "SvxImportMSVBasic::ImportCode_Impl - unknown module type" );
-                        break;
-                }
-				static ::rtl::OUString sVBAOption( RTL_CONSTASCII_USTRINGPARAM( "Option VBASupport 1\n" ) ); 
-				static ::rtl::OUString sClassOption( RTL_CONSTASCII_USTRINGPARAM( "Option ClassModule\n" ) ); 
-				if ( !bAsComment )
-				{
-					modeTypeComment = modeTypeComment + sVBAOption;
-					if ( mType == Class )
-						modeTypeComment = modeTypeComment + sClassOption;
-
-				}
-
-				String sModule(sBasicModule); //#i52606# no need to split Macros in 64KB blocks any more!
-				String sTemp;
-				if (bAsComment)
-				{
-					sTemp+=String(RTL_CONSTASCII_USTRINGPARAM( "Sub " ));
-					String sMunge(sModule);
-					//Streams can have spaces in them, but modulenames
-					//cannot !
-					sMunge.SearchAndReplaceAll(' ','_');
-
-					sTemp += sMunge;
-					sTemp.AppendAscii("\n");
-				};
-	            ::rtl::OUString aSource(sTemp);
-
-				for(ULONG j=0;j<aDecompressed.GetSize();j++)
-				{
-					if (bStripped)
-					{
-                        String *pStr = aDecompressed.Get(j);
-                        bool bMac = true;
-                        xub_StrLen nBegin = pStr->Search('\x0D');
-                        if ((STRING_NOTFOUND != nBegin) && (pStr->Len() > 1) && (pStr->GetChar(nBegin+1) == '\x0A'))
-                            bMac = false;
-
-                        const char cLineEnd = bMac ? '\x0D' : '\x0A';
-                        const String sAttribute(String::CreateFromAscii(
-                            bAsComment ? "Rem Attribute" : "Attribute"));
-						nBegin = 0;
-						while (STRING_NOTFOUND != (nBegin =	pStr->Search(sAttribute, nBegin)))
-						{
-                            if ((nBegin) && pStr->GetChar(nBegin-1) != cLineEnd)
-							{
-                                // npower #i63766# Need to skip instances of Attribute
-								// that are NOT Attribute statements
-								nBegin = nBegin + sAttribute.Len();
-                                continue;
-							}
-							xub_StrLen nEnd = pStr->Search(cLineEnd ,nBegin);
-                            // DR #i26521# catch STRING_NOTFOUND, will loop endless otherwise
-                            if( nEnd == STRING_NOTFOUND )
-                                pStr->Erase();
-                            else
-                                pStr->Erase(nBegin, (nEnd-nBegin)+1);
-						}
-					}
-					if( aDecompressed.Get(j)->Len() )
-					{
-			            aSource+=::rtl::OUString( *aDecompressed.Get(j) );
-					}
-
-				}
-				if (bAsComment)
-				{
-						aSource += rtl::OUString::createFromAscii("\nEnd Sub");
-				}
-				::rtl::OUString aModName( sModule );
-				if ( aSource.getLength() )
-				{
-					aSource = modeTypeComment + aSource;
-
-					Any aSourceAny;
-					aSourceAny <<= aSource;
-					if( xLib->hasByName( aModName ) )
-						xLib->replaceByName( aModName, aSourceAny );
-					else
-						xLib->insertByName( aModName, aSourceAny );
-				}                                
-
-				bRet = true;
-			}
-		}
-		SFX_APP()->LeaveBasicCall();
+		VBADir aVBA( xProject, xVBA );
+		bRet = aVBA.readBasic( rDocSh, bAsComment, bStripped );
 	}
 	return bRet;
 }
@@ -458,30 +356,73 @@ BOOL SvxImportMSVBasic::ImportCode_Impl(
 ULONG SvxImportMSVBasic::SaveOrDelMSVBAStorage( BOOL bSaveInto,
 												const String& rStorageName )
 {
+	MacroExportOption aOption = Delete;
+	if ( bSaveInto )
+		aOption = Copy;
+	return SaveOrCopyOrDeleteMSVBAStorage( aOption, rStorageName );
+}
+
+ULONG SvxImportMSVBasic::SaveOrCopyOrDeleteMSVBAStorage( const MacroExportOption& nOption,
+												const String& rStorageName )
+{
+	OSL_TRACE("**** SvxImportMSVBasic::SaveOrCopyOrDeleteMSVBAStorage");
 	ULONG nRet = ERRCODE_NONE;
     uno::Reference < embed::XStorage > xSrcRoot( rDocSh.GetStorage() );
 	String aDstStgName( GetMSBasicStorageName() );
     SotStorageRef xVBAStg( SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName,
-                                STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYALL ) );
+//                                STREAM_READWRITE | STREAM_NOCREATE | STREAM_SHARE_DENYALL ) );
+                                STREAM_READWRITE | STREAM_SHARE_DENYALL ) );
 	if( xVBAStg.Is() && !xVBAStg->GetError() )
 	{
-		xVBAStg = 0;
-		if( bSaveInto )
+		xVBAStg = 0; 
+		// Copying from previous, why enterbasic call?  ( mmm seems like re-entrency
+		// detection foo ) 
+		SFX_APP()->EnterBasicCall();
+
+		BasicManager *pBasicMan = rDocSh.GetBasicManager();
+		bool bIsModified = ( pBasicMan && pBasicMan->IsBasicModified() );
+		bIsModified = true; 
+		SFX_APP()->LeaveBasicCall();
+		if( false /*bIsModified*/ ) // doesn't work, bIsModified is not reliable
+		{
+			OSL_TRACE("BASIC has being MODIFIED correct? ..." );
+			nRet = ERRCODE_SVX_MODIFIED_VBASIC_STORAGE;
+		}
+		if( nOption == Save /*&& bIsModified*/ )
+		{
+
+			OSL_TRACE("Crazy VBA writing hack !" );
+			SvStorageRef xProject, xVBA;
+			OUString sProject = OUString::createFromAscii( "_VBA_PROJECT_CUR" );
+			OUString sVBA = OUString::createFromAscii( "VBA" );
+			if( GetVBAStorage( // HACK:
+				sProject,sVBA,
+				xProject, xVBA, true ) )
+			{
+				SvStorageRef xMSProject = SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName, STREAM_STD_READ );
+				VBADir aDir( xProject, xVBA );
+				// Todo test for error ( and set error on 
+				// xRoot storage 
+				aDir.writeBasic( rDocSh ); // probably should return Error
+			}
+			else
+			{
+				OSL_TRACE( "Failed to create VBA storage" );
+			}
+		}
+		else if ( nOption == Copy )// Copy basic streams
 		{
-			BasicManager *pBasicMan = rDocSh.GetBasicManager();
-			if( pBasicMan && pBasicMan->IsBasicModified() )
-				nRet = ERRCODE_SVX_MODIFIED_VBASIC_STORAGE;
-
-            SotStorageRef xSrc = SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName, STREAM_STD_READ );
-            SotStorageRef xDst = xRoot->OpenSotStorage( rStorageName, STREAM_READWRITE | STREAM_TRUNC );
-            xSrc->CopyTo( xDst );
-            xDst->Commit();
-            ErrCode nError = xDst->GetError();
-            if ( nError == ERRCODE_NONE )
-                nError = xSrc->GetError();
-            if ( nError != ERRCODE_NONE )
-                xRoot->SetError( nError );
+			SotStorageRef xSrc = SotStorage::OpenOLEStorage( xSrcRoot, aDstStgName, STREAM_STD_READ );
+			SotStorageRef xDst = xRoot->OpenSotStorage( rStorageName, STREAM_READWRITE | STREAM_TRUNC );
+			xSrc->CopyTo( xDst );
+			xDst->Commit();
+			ErrCode nError = xDst->GetError();
+			if ( nError == ERRCODE_NONE )
+				nError = xSrc->GetError();
+			if ( nError != ERRCODE_NONE )
+				xRoot->SetError( nError );
 		}
+				
 	}
 
 	return nRet;
