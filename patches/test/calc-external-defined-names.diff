diff --git sc/inc/compiler.hrc sc/inc/compiler.hrc
index 92b7e82..22d77cb 100644
--- sc/inc/compiler.hrc
+++ sc/inc/compiler.hrc
@@ -39,25 +39,26 @@
 #define SC_OPCODE_STOP                2
 #define SC_OPCODE_EXTERNAL            3
 #define SC_OPCODE_NAME                4
-#define SC_OPCODE_IF                  5     /* jump commands */
-#define SC_OPCODE_CHOSE               6
-#define SC_OPCODE_OPEN                7     /* parentheses and separators */
-#define SC_OPCODE_CLOSE               8
-#define SC_OPCODE_SEP                 9
-#define SC_OPCODE_MISSING            10     /* special OpCodes */
-#define SC_OPCODE_BAD                11
-#define SC_OPCODE_SPACES             12
-#define SC_OPCODE_MAT_REF            13
-#define SC_OPCODE_DB_AREA            14     /* additional access operators */
-#define SC_OPCODE_MACRO              15
-#define SC_OPCODE_COL_ROW_NAME       16
-#define SC_OPCODE_COL_ROW_NAME_AUTO  17
-#define SC_OPCODE_PERCENT_SIGN       18     /* operator _follows_ value */
-#define SC_OPCODE_ARRAY_OPEN         19
-#define SC_OPCODE_ARRAY_CLOSE        20
-#define SC_OPCODE_ARRAY_ROW_SEP      21
-#define SC_OPCODE_ARRAY_COL_SEP      22     /* some convs use sep != col_sep */
-#define SC_OPCODE_STOP_DIV           23
+#define SC_OPCODE_EXTERNAL_NAME       5
+#define SC_OPCODE_IF                  6     /* jump commands */
+#define SC_OPCODE_CHOSE               7
+#define SC_OPCODE_OPEN                8     /* parentheses and separators */
+#define SC_OPCODE_CLOSE               9
+#define SC_OPCODE_SEP                10
+#define SC_OPCODE_MISSING            11     /* special OpCodes */
+#define SC_OPCODE_BAD                12
+#define SC_OPCODE_SPACES             13
+#define SC_OPCODE_MAT_REF            14
+#define SC_OPCODE_DB_AREA            15     /* additional access operators */
+#define SC_OPCODE_MACRO              16
+#define SC_OPCODE_COL_ROW_NAME       17
+#define SC_OPCODE_COL_ROW_NAME_AUTO  18
+#define SC_OPCODE_PERCENT_SIGN       19     /* operator _follows_ value */
+#define SC_OPCODE_ARRAY_OPEN         20
+#define SC_OPCODE_ARRAY_CLOSE        21
+#define SC_OPCODE_ARRAY_ROW_SEP      22
+#define SC_OPCODE_ARRAY_COL_SEP      23     /* some convs use sep != col_sep */
+#define SC_OPCODE_STOP_DIV           24
 
 /*** error constants #... ***/
 #define SC_OPCODE_START_ERRORS       30
diff --git sc/inc/compiler.hxx sc/inc/compiler.hxx
index 8036115..047ff2c 100644
--- sc/inc/compiler.hxx
+++ sc/inc/compiler.hxx
@@ -45,6 +45,7 @@
 #include <unotools/charclass.hxx>
 #include <rtl/ustrbuf.hxx>
 #include <com/sun/star/uno/Sequence.hxx>
+#include <vector>
 
 namespace com { namespace sun { namespace star {
     namespace sheet {
@@ -150,6 +151,10 @@ public:
             bool        bHasForceArray;
         } sbyte;
         ComplRefData aRef;
+        struct {
+            sal_uInt16  nFileId;
+            sal_Unicode cName[MAXSTRLEN+1];
+        } extname;
         ScMatrix*    pMat;
         USHORT       nIndex;                // index into name collection
         sal_Unicode  cStr[ MAXSTRLEN+1 ];   // string (up to 255 characters + 0)
@@ -179,6 +184,7 @@ public:
     void SetDouble( double fVal );
     void SetInt( int nVal );
     void SetName( USHORT n );
+    void SetExternalName( sal_uInt16 nFileId, const String& rName );
     void SetMatrix( ScMatrix* p );
     void SetExternal(const sal_Unicode* pStr);
     // These methods are ok to use, reference count not cleared.
@@ -227,6 +233,16 @@ public:
                                    xub_StrLen nSrcPos,
                                    const CharClass* pCharClass) const = 0;
 
+        /** 
+         * Parse the symbol string and pick up the file name and the external 
+         * range name. 
+         *
+         * @return true on successful parse, or false otherwise.
+         */
+        virtual bool parseExternalName( const String& rSymbol, String& rFile, String& rName ) const = 0;
+
+        virtual String makeExternalNameStr( const String& rFile, const String& rName ) const = 0;
+
         enum SpecialSymbolType
         {
             /** 
@@ -443,6 +459,7 @@ private:
     BOOL IsDoubleReference( const String& );
     BOOL IsMacro( const String& );
     BOOL IsNamedRange( const String& );
+    bool IsExternalNamedRange( const String& rSymbol );
     BOOL IsDBRange( const String& );
     BOOL IsColRowName( const String& );
     BOOL IsBoolean( const String& );
diff --git sc/inc/document.hxx sc/inc/document.hxx
index 8a648d3..9b373cc 100644
--- sc/inc/document.hxx
+++ sc/inc/document.hxx
@@ -92,6 +92,7 @@ class ScDocOptions;
 class ScDocumentPool;
 class ScDrawLayer;
 class ScExtDocOptions;
+class ScExternalRefManager;
 class ScFormulaCell;
 class ScMarkData;
 class ScOutlineTable;
@@ -281,6 +282,7 @@ private:
 	ScFieldEditEngine*	pCacheFieldEditEngine;
 
     ::std::auto_ptr<ScDocProtection> pDocProtection;
+    ::std::auto_ptr<ScExternalRefManager> pExternalRefMgr;
 	String              aDocName;                       // opt: Dokumentname
 	String              aDocCodeName;                       // opt: Dokumentname
 	ScRangePairListRef	xColNameRanges;
@@ -624,6 +626,8 @@ SC_DLLPUBLIC	ScDBCollection*	GetDBCollection() const;
 									const String& aFileName,
 									const String& aTabName );
 
+    ScExternalRefManager* GetExternalRefManager();
+
     /** Creates a new sheet, and makes it linked to the specified sheet in an external document.
         @param rnTab  (out-param) Returns the sheet index, if sheet could be inserted).
         @return  TRUE = Sheet created, rnTab contains valid sheet index. */
diff --git sc/inc/externalrefmgr.hxx sc/inc/externalrefmgr.hxx
new file mode 100644
index 0000000..2af580a
--- /dev/null
+++ sc/inc/externalrefmgr.hxx
@@ -0,0 +1,217 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: document.hxx,v $
+ * $Revision: 1.112 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+#ifndef SC_EXTERNALREFMGR_HXX
+#define SC_EXTERNALREFMGR_HXX
+
+#include "global.hxx"
+#include "address.hxx"
+#include "sfx2/objsh.hxx"
+#include "sfx2/lnkbase.hxx"
+#include "tools/time.hxx"
+#include "vcl/timer.hxx"
+
+#include <hash_map>
+#include <hash_set>
+#include <boost/shared_ptr.hpp>
+#include <vector>
+
+class ScDocument;
+class ScToken;
+class ScTokenArray;
+class String;
+class SfxObjectShellRef;
+class Window;
+
+class ScExternalRefLink : public ::sfx2::SvBaseLink
+{
+public:
+    ScExternalRefLink(ScDocument* pDoc, sal_uInt16 nFileId, const String& rFilter);
+    virtual ~ScExternalRefLink();
+
+    virtual void Closed();
+    virtual void DataChanged(const String& rMimeType, const ::com::sun::star::uno::Any & rValue);
+    virtual void Edit(Window* pParent, const Link& rEndEditHdl);
+
+    void SetDoReferesh(bool b);
+
+private:
+    ScExternalRefLink(); // disabled
+    ScExternalRefLink(const ScExternalRefLink&); // disabled
+
+    DECL_LINK(EndEditHdl, void*);
+
+    sal_uInt16  mnFileId;
+    String      maFilterName;
+    ScDocument* mpDoc;
+    bool        mbDoRefresh;
+};
+
+// ============================================================================
+
+class ScExternalRefManager
+{
+private:
+    struct AddressHash
+    {
+        size_t operator()(const ScAddress& rAddr) const
+        {
+            // dumb hashing - how do we properly hash a cell address?
+            return rAddr.Tab() + rAddr.Col() + rAddr.Row();
+        }
+    };
+
+    struct RangeHash
+    {
+        size_t operator()(const ScRange& rRange) const
+        {
+            const ScAddress& s = rRange.aStart;
+            const ScAddress& e = rRange.aEnd;
+            return s.Tab() + s.Col() + s.Row() + e.Tab() + e.Col() + e.Row();
+        }
+    };
+
+    struct SrcDoc
+    {
+        SfxObjectShellRef   maShell;
+        Time                maLastAccess;
+    };
+
+    typedef ::boost::shared_ptr<ScToken>        TokenRef;
+    typedef ::boost::shared_ptr<ScTokenArray>   TokenArrayRef;
+
+    typedef ::std::hash_map<sal_uInt16, SrcDoc>                                                 DocShellMap;
+    typedef ::std::hash_map<ScAddress, TokenRef, AddressHash, ::std::equal_to<ScAddress> >      SingleTokenMap;
+    typedef ::std::hash_map<ScRange, TokenArrayRef, RangeHash, ::std::equal_to<ScRange> >       DoubleTokenMap;
+    typedef ::std::hash_map<String, TokenArrayRef, ScStringHashCode, ::std::equal_to<String> >  RangeNameMap;
+    typedef ::std::hash_set<sal_uInt16, ScStringHashCode>                                       LinkedDocSet;
+
+    typedef ::std::hash_set<ScAddress, AddressHash, ::std::equal_to<ScAddress> >    RefCellSet;
+    typedef ::std::hash_map<sal_uInt16, RefCellSet>                                 RefCellMap;
+
+    /** 
+     * Cached content of a single external document
+     */
+    struct DocCache
+    {
+        SingleTokenMap  maSingleTokens;
+        DoubleTokenMap  maDoubleTokens;
+        RangeNameMap    maRangeNames;
+        ::std::vector<String> maTableNames;
+    };
+    typedef ::boost::shared_ptr<DocCache> DocCacheRef;
+    typedef ::std::hash_map<sal_uInt16, DocCacheRef>   DocCacheMap;
+
+public:
+    explicit ScExternalRefManager(ScDocument* pDoc);
+    ~ScExternalRefManager();
+
+    ScToken* getSingleRefToken(sal_uInt16 nFileId, const ScAddress& rCell, const ScAddress* pCurPos);
+    ScTokenArray* getDoubleRefTokens(sal_uInt16 nFileId, const ScRange& rRange, const ScAddress* pCurPos);
+
+    /** 
+     * Get an array of tokens corresponding with a specified name in a 
+     * specified file. 
+     *  
+     * @param pCurPos currnet cell address where this name token is used. 
+     *                This is purely to keep track of all cells containing
+     *                external names for refreshing purposes.  If this is
+     *                NULL, then the cell will not be added to the list.
+     * 
+     * @return array of tokens composing the name
+     */
+    ScTokenArray* getRangeNameTokens(sal_uInt16 nFileId, const String& rName, const ScAddress* pCurPos = NULL);
+
+    sal_uInt16 getExternalFileId(const String& rFile);
+    const String* getExternalFileName(sal_uInt16 nFileId) const;
+    const String* getExternalTableName(sal_uInt16 nFileId, SCTAB nTabId);
+    
+    void refreshNames(sal_uInt16 nFileId);
+    void switchSrcFile(sal_uInt16 nFileId, const String& rNewFile);
+    void removeSrcDocument(sal_uInt16 nFileId, bool bBreakLink);
+    void clear();
+
+private:
+    ScExternalRefManager();
+    ScExternalRefManager(const ScExternalRefManager&); 
+
+    ScToken* getSingleRefToken(sal_uInt16 nFileId, const ScAddress& rCell);
+    ScTokenArray* getDoubleRefTokens(sal_uInt16 nFileId, const ScRange& rRange);
+
+    void refreshAllReferencingCells(sal_uInt16 nFileId);
+
+    void insertReferencingCell(sal_uInt16 nFileId, const ScAddress& rCell);
+
+    DocCache* getDocumentCache(sal_uInt16 nFileId);
+    ScDocument* getSrcDocument(sal_uInt16 nFileId);
+    SfxObjectShellRef loadSrcDocument(const String& rFile, String& rFilter);
+    void insertExternalFileLink(sal_uInt16 nFileId, const String& rFilterName);
+
+    bool compileTokensByCell(const ScAddress& rCell);
+
+    /** 
+     * Purge those source document instances that have not been accessed for 
+     * the specified duration.
+     *  
+     * @param nTimeOut time out value in 100th of a second 
+     */
+    void purgeStaleSrcDocument(sal_Int32 nTimeOut);
+
+private:
+    ScDocument* mpDoc;
+
+    /** 
+     * Source document cache.  This stores the original source document 
+     * instances.  The source documents get purged after certain period of 
+     * time. 
+     */
+    DocShellMap maDocShells;
+
+    /** cache only of referenced ranges and names from source documents. */
+    DocCacheMap maCachedDocContents;
+
+    /** list of source documents that are managed by the link manager. */
+    LinkedDocSet maLinkedDocs;
+
+    /** 
+     *  List of referencing cells that may contain external names.  There is
+     *  one list per source document.
+     */
+    RefCellMap maRefCells;
+
+    /** original source file index. */
+    ::std::vector<String> maFileNames;
+
+    AutoTimer maSrcDocTimer;
+    DECL_LINK(TimeOutHdl, AutoTimer*);
+};
+
+
+#endif
diff --git sc/inc/opcode.hxx sc/inc/opcode.hxx
index 285104d..b72ebad 100644
--- sc/inc/opcode.hxx
+++ sc/inc/opcode.hxx
@@ -44,6 +44,7 @@ enum OpCodeEnum
 		ocStop				= SC_OPCODE_STOP,
 		ocExternal			= SC_OPCODE_EXTERNAL,
 		ocName				= SC_OPCODE_NAME,
+        ocExternalName      = SC_OPCODE_EXTERNAL_NAME,
 	// Jump commands
 		ocIf				= SC_OPCODE_IF,
 		ocChose				= SC_OPCODE_CHOSE,
diff --git sc/inc/token.hxx sc/inc/token.hxx
index 23decd6..1181360 100644
--- sc/inc/token.hxx
+++ sc/inc/token.hxx
@@ -64,7 +64,7 @@ enum StackVarEnum
                                         // cell during import, having a double
                                         // and/or string result and a formula
                                         // string to be compiled.
-
+    svExternalName,
     svError,                            // error token
     svMissing = 0x70,                   // 0 or ""
     svUnknown                           // unknown StackType
@@ -447,6 +447,61 @@ public:
 };
 
 
+class ScExternalSingleRefToken : public ScOpToken
+{
+private:
+    sal_uInt16                  mnFileId;
+    SingleRefData               maSingleRef;
+
+                                ScExternalSingleRefToken(); // disabled
+public:
+                                ScExternalSingleRefToken( sal_uInt16 nFileId, const SingleRefData& r );
+                                ScExternalSingleRefToken( const ScExternalSingleRefToken& r );
+    virtual                     ~ScExternalSingleRefToken();
+
+    virtual USHORT                  GetIndex() const;
+    virtual const SingleRefData&    GetSingleRef() const;
+    virtual SingleRefData&          GetSingleRef();
+    virtual BOOL                    operator==( const ScToken& rToken ) const;
+};
+
+
+class ScExternalDoubleRefToken : public ScOpToken
+{
+private:
+    sal_uInt16                  mnFileId;
+    ComplRefData               maDoubleRef;
+
+                                ScExternalDoubleRefToken(); // disabled
+public:
+                                ScExternalDoubleRefToken( sal_uInt16 nFileId, const ComplRefData& r );
+                                ScExternalDoubleRefToken( const ScExternalDoubleRefToken& r );
+    virtual                     ~ScExternalDoubleRefToken();
+
+    virtual USHORT                  GetIndex() const;
+    virtual const ComplRefData&    GetDoubleRef() const;
+    virtual ComplRefData&          GetDoubleRef();
+    virtual BOOL                    operator==( const ScToken& rToken ) const;
+};
+
+
+class ScExternalNameToken : public ScOpToken
+{
+private:
+    sal_uInt16                  mnFileId;
+    String                      maName;
+private:
+                                ScExternalNameToken(); // disabled
+public:
+                                ScExternalNameToken( sal_uInt16 nFileId, const String& rName );
+                                ScExternalNameToken( const ScExternalNameToken& r );
+    virtual                     ~ScExternalNameToken();
+    virtual USHORT              GetIndex() const;
+    virtual const String&       GetString() const;
+    virtual BOOL                operator==( const ScToken& rToken ) const;
+};
+
+
 class ScJumpToken : public ScOpToken
 {
 private:
diff --git sc/inc/tokenarray.hxx sc/inc/tokenarray.hxx
index 1d903ce..f7c4d6b 100644
--- sc/inc/tokenarray.hxx
+++ sc/inc/tokenarray.hxx
@@ -193,6 +193,7 @@ public:
     ScToken* AddDoubleReference( const ComplRefData& rRef );
     ScToken* AddName( USHORT n );
     ScToken* AddMatrix( ScMatrix* p );
+    ScToken* AddExternalName( sal_uInt16 nFileId, const String& rName );
     ScToken* AddExternal( const sal_Unicode* pStr );
     /** Xcl import may play dirty tricks with OpCode!=ocExternal.
         Others don't use! */
diff --git sc/source/core/data/documen2.cxx sc/source/core/data/documen2.cxx
index 6dd6697..60a3a4a 100644
--- sc/source/core/data/documen2.cxx
+++ sc/source/core/data/documen2.cxx
@@ -93,6 +93,7 @@
 #include "listenercalls.hxx"
 #include "recursionhelper.hxx"
 #include "lookupcache.hxx"
+#include "externalrefmgr.hxx"
 #include <com/sun/star/document/XVbaEventsHelper.hpp>
 
 // pImpl because including lookupcache.hxx in document.hxx isn't wanted, and
@@ -140,6 +141,7 @@ ScDocument::ScDocument( ScDocumentMode	eMode,
 		pScriptTypeData( NULL ),
         pCacheFieldEditEngine( NULL ),
         pDocProtection( NULL ),
+        pExternalRefMgr( NULL ),
 		pViewOptions( NULL ),
 		pDocOptions( NULL ),
 		pExtDocOptions( NULL ),
@@ -369,6 +371,11 @@ ScDocument::~ScDocument()
 			pLinkManager->Remove( 0, pLinkManager->GetLinks().Count() );
 	}
 
+    if (pExternalRefMgr.get())
+        // Destroy the external ref mgr instance here because it has a timer 
+        // which needs to be stopped before the app closes.
+        pExternalRefMgr.reset(NULL);
+
 	ScAddInAsync::RemoveDocument( this );
 	ScAddInListener::RemoveDocument( this );
 	delete pChartListenerCollection;	// vor pBASM wg. evtl. Listener!
diff --git sc/source/core/data/documen3.cxx sc/source/core/data/documen3.cxx
index 541e2e4..20dae1e 100644
--- sc/source/core/data/documen3.cxx
+++ sc/source/core/data/documen3.cxx
@@ -61,6 +61,7 @@
 #include "brdcst.hxx"
 #include "bcaslot.hxx"
 #include "tablink.hxx"
+#include "externalrefmgr.hxx"
 #include "markdata.hxx"
 #include "validat.hxx"
 #include "dociter.hxx"
@@ -81,7 +82,10 @@
 #include "svtools/PasswordHelper.hxx"
 #include "tabprotection.hxx"
 
+#include <memory>
+
 using namespace com::sun::star;
+using ::std::auto_ptr;
 
 //------------------------------------------------------------------------
 
@@ -478,6 +482,14 @@ BOOL ScDocument::LinkExternalTab( SCTAB& rTab, const String& aDocTab,
 	return TRUE;
 }
 
+ScExternalRefManager* ScDocument::GetExternalRefManager()
+{
+    if (!pExternalRefMgr.get())
+        pExternalRefMgr.reset(new ScExternalRefManager(this));
+
+    return pExternalRefMgr.get();
+}
+
 BOOL ScDocument::InsertLinkedEmptyTab( SCTAB& rnTab, const String& rFileName,
         const String& rFilterName, const String& rFilterOpt, const String& rTabName )
 {
diff --git sc/source/core/tool/compiler.cxx sc/source/core/tool/compiler.cxx
index 7caea76..c2d36c4 100644
--- sc/source/core/tool/compiler.cxx
+++ sc/source/core/tool/compiler.cxx
@@ -73,9 +73,13 @@
 #include "errorcodes.hxx"
 #include "parclass.hxx"
 #include "autonamecache.hxx"
+#include "externalrefmgr.hxx"
+
+#include <stdio.h>
 
 using namespace ::com::sun::star;
 using rtl::OUString;
+using ::std::vector;
 
 #if OSL_DEBUG_LEVEL > 1
 // For some unknown reason the identical dbg_dump utilities in
@@ -1361,6 +1365,64 @@ struct ConventionOOO_A1 : public Convention_A1
 
         return sal_Unicode(0);
     }
+
+    virtual bool parseExternalName( const String& rSymbol, String& rFile, String& rName ) const
+    {
+        // in OOO A1, an external name syntax is as follows:
+        // 
+        //   'file:///path/to/source'#ExternalName
+
+        String aTmpFile, aTmpName;
+        xub_StrLen nLen = rSymbol.Len();
+        const sal_Unicode* p = rSymbol.GetBuffer();
+        bool bInFilePath = false;
+        bool bInName = false;
+        sal_Unicode cPrev = 0;
+        for (xub_StrLen i = 0; i < nLen; ++i, ++p)
+        {
+            const sal_Unicode c = *p;
+            if (c == '\'')
+            {
+                if (!bInFilePath && i != 0)
+                    // The first character must be a single quote.
+                    return false;
+
+                bInFilePath = !bInFilePath;
+            }
+            else if (bInFilePath)
+                aTmpFile.Append(c);
+            else if (bInName)
+                aTmpName.Append(c);
+            else if (c == '#')
+            {
+                if (cPrev != '\'')
+                    // '#' must immediately follow the closing single quote.
+                    return false;
+
+                bInName = true;
+            }
+
+            cPrev = c;
+        }
+
+        if (aTmpFile.Len() == 0 || aTmpName.Len() == 0)
+            return false;
+
+        rFile = aTmpFile;
+        rName = aTmpName;
+
+        return true;
+    }
+
+    virtual String makeExternalNameStr( const String& rFile, const String& rName ) const
+    {
+        String aStr;
+        aStr.Append(sal_Unicode('\''));
+        aStr.Append(rFile);
+        aStr.AppendAscii("\'#");
+        aStr.Append(rName);
+        return aStr;
+    }
 };
 
 
@@ -1480,6 +1542,16 @@ struct ConventionXL
         }
         return sal_Unicode(0);
     }
+
+    static bool parseExternalName( const String& rSymbol, String& rFile, String& rName )
+    {
+        return false;
+    }
+
+    static String makeExternalNameStr( const String& rFile, const String& rName )
+    {
+        return String();
+    }
 };
 
 struct ConventionXL_A1 : public Convention_A1, public ConventionXL
@@ -1561,6 +1633,16 @@ struct ConventionXL_A1 : public Convention_A1, public ConventionXL
     {
         return ConventionXL::getSpecialSymbol(eSymType);
     }
+
+    virtual bool parseExternalName( const String& rSymbol, String& rFile, String& rName ) const
+    {
+        return ConventionXL::parseExternalName(rSymbol, rFile, rName);
+    }
+
+    virtual String makeExternalNameStr( const String& rFile, const String& rName ) const
+    {
+        return ConventionXL::makeExternalNameStr(rFile, rName);
+    }
 };
 
 static const ConventionXL_A1 ConvXL_A1;
@@ -1688,6 +1770,16 @@ struct ConventionXL_R1C1 : public ScCompiler::Convention, public ConventionXL
     {
         return ConventionXL::getSpecialSymbol(eSymType);
     }
+
+    virtual bool parseExternalName( const String& rSymbol, String& rFile, String& rName ) const
+    {
+        return ConventionXL::parseExternalName(rSymbol, rFile, rName);
+    }
+
+    virtual String makeExternalNameStr( const String& rFile, const String& rName ) const
+    {
+        return ConventionXL::makeExternalNameStr(rFile, rName);
+    }
 };
 
 static const ConventionXL_R1C1 ConvXL_R1C1;
@@ -2597,6 +2689,28 @@ BOOL ScCompiler::IsNamedRange( const String& rUpperName )
         return FALSE;
 }
 
+bool ScCompiler::IsExternalNamedRange( const String& rSymbol )
+{
+    if (!pConv)
+        return false;
+
+    String aFile, aName;
+    if (!pConv->parseExternalName(rSymbol, aFile, aName))
+        return false;
+
+    ScRawToken aToken;
+    if (aFile.Len() > MAXSTRLEN || aName.Len() > MAXSTRLEN)
+        return false;
+
+    sal_uInt16 nFileId = pDoc->GetExternalRefManager()->getExternalFileId(aFile);
+    fprintf(stdout, "ScCompiler::IsExternalNamedRange:   file name = '%s'; file id = %d\n",
+            rtl::OUStringToOString(aFile, RTL_TEXTENCODING_UTF8).getStr(), nFileId);
+
+    aToken.SetExternalName(nFileId, aName);
+    pRawToken = aToken.Clone();
+    return true;
+}
+
 BOOL ScCompiler::IsDBRange( const String& rName )
 {
     USHORT n;
@@ -3190,10 +3304,11 @@ BOOL ScCompiler::NextNewToken( bool bAllowBooleans )
             // IsBoolean before isValue to catch inline bools without the kludge
             //    for inline arrays.
             if ( !(bMayBeFuncName && IsOpCode( aUpper ))
-              && !IsReference( aOrg )
+              && !IsReference(aOrg)
               && !(bAllowBooleans && IsBoolean( aUpper ))
               && !IsValue( aUpper )
-              && !IsNamedRange( aUpper )
+              && !IsNamedRange(aUpper)
+              && !IsExternalNamedRange(aOrg)
               && !IsDBRange( aUpper )
               && !IsColRowName( aUpper )
               && !(bMayBeFuncName && IsMacro( aUpper ))
@@ -3452,6 +3567,69 @@ BOOL ScCompiler::GetToken()
     }
     if( pToken->GetOpCode() == ocSubTotal )
         glSubTotal = TRUE;
+    else if ( pToken->GetOpCode() == ocExternalName )
+    {
+        // Handle external single and double references, or names.
+
+        ScExternalRefManager* pRefMgr = pDoc->GetExternalRefManager();
+        const String* pFile = pRefMgr->getExternalFileName(pToken->GetIndex());
+        if (!pFile)
+            SetError(errNoName);
+
+        switch (pToken->GetType())
+        {
+            case svExternalName:
+            {
+                fprintf(stdout, "ScCompiler::GetToken:   external name token\n");
+                const String& rName = pToken->GetString();
+                ScTokenArray* pNew = pRefMgr->getRangeNameTokens(pToken->GetIndex(), rName, &aPos);
+                if (pNew)
+                {
+                    PushTokenArray(pNew->Clone(), true);
+                    return GetToken();
+                }
+            }
+            break;
+            case svSingleRef:
+            {
+                fprintf(stdout, "ScCompiler::GetToken:   external single ref (file id = %d)\n", pToken->GetIndex());
+                SingleRefData aData(pToken->GetSingleRef());
+                if (aData.IsTabRel())
+                    // external single reference must have an absolute table reference!
+                    break;
+
+                aData.CalcAbsIfRel(aPos);
+                ScAddress aAddr(aData.nCol, aData.nRow, aData.nTab);
+                ScToken* pNew = pRefMgr->getSingleRefToken(pToken->GetIndex(), aAddr, &aPos);
+                if (pNew)
+                {
+                    pToken = pNew->Clone();
+                    return false;
+                }
+            }
+            break;
+            case svDoubleRef:
+            {
+                fprintf(stdout, "ScCompiler::GetToken:   external double ref (file id = %d)\n", pToken->GetIndex());
+                ComplRefData aData(pToken->GetDoubleRef());
+                if (aData.Ref1.IsTabRel() || aData.Ref2.IsTabRel())
+                    // external double reference must have an absolute table reference!
+                    break;
+
+                aData.CalcAbsIfRel(aPos);
+                ScRange aRange(aData.Ref1.nCol, aData.Ref1.nRow, aData.Ref1.nTab, 
+                               aData.Ref2.nCol, aData.Ref2.nRow, aData.Ref2.nTab);
+                ScTokenArray* pNew = pRefMgr->getDoubleRefTokens(pToken->GetIndex(), aRange, &aPos);
+                if (pNew)
+                {
+                    PushTokenArray(pNew->Clone(), true);
+                    return GetToken();
+                }
+            }
+            break;
+        }
+        SetError(errNoName);
+    }
     else if( pToken->GetOpCode() == ocName )
     {
         ScRangeData* pRangeData = pDoc->GetRangeName()->FindIndex( pToken->GetIndex() );
@@ -5402,6 +5580,15 @@ ScToken* ScCompiler::CreateStringFromToken( rtl::OUStringBuffer& rBuffer, ScToke
     BOOL bSpaces = FALSE;
     ScToken* t = pTokenP;
     OpCode eOp = t->GetOpCode();
+    if (eOp == ocExternalName)
+    {
+        const String *pStr = pDoc->GetExternalRefManager()->getExternalFileName(t->GetIndex());
+        if (pStr)
+        {
+            rBuffer.append(pConv->makeExternalNameStr(*pStr, t->GetString()));
+        }
+    }
+
     if( eOp >= ocAnd && eOp <= ocOr )
     {
         // AND, OR infix?
diff --git sc/source/core/tool/token.cxx sc/source/core/tool/token.cxx
index 7312257..5d1f006 100644
--- sc/source/core/tool/token.cxx
+++ sc/source/core/tool/token.cxx
@@ -52,6 +52,8 @@
 #include "parclass.hxx"
 #include "jumpmatrix.hxx"
 
+using ::std::vector;
+
 // ImpTokenIterator wird je Interpreter angelegt, mehrfache auch durch
 // SubCode via ScTokenIterator Push/Pop moeglich
 IMPL_FIXEDMEMPOOL_NEWDEL( ImpTokenIterator, 32, 16 )
@@ -196,6 +198,19 @@ void ScRawToken::SetName( USHORT n )
     nRefCnt = 0;
 }
 
+void ScRawToken::SetExternalName( sal_uInt16 nFileId, const String& rName )
+{
+    eOp = ocExternalName;
+    eType = svExternalName;
+    nRefCnt = 0;
+
+    extname.nFileId = nFileId;
+
+    xub_StrLen n = rName.Len();
+    memcpy(extname.cName, rName.GetBuffer(), n*sizeof(sal_Unicode));
+    extname.cName[n] = 0;
+}
+
 ComplRefData& ScRawToken::GetReference()
 {
     DBG_ASSERT( lcl_IsReference( eOp, GetType() ), "GetReference: no Ref" );
@@ -255,6 +270,7 @@ ScRawToken* ScRawToken::Clone() const
             case svSingleRef:
             case svDoubleRef:   n += sizeof(aRef); break;
             case svMatrix:      n += sizeof(ScMatrix*); break;
+            case svExternalName: n += sizeof(extname); break;
             case svIndex:       n += sizeof(USHORT); break;
             case svJump:        n += nJump[ 0 ] * 2 + 2; break;
             case svExternal:    n = sal::static_int_cast<USHORT>( n + GetStrLenBytes( cStr+1 ) + GetStrLenBytes( 2 ) ); break;
@@ -311,8 +327,14 @@ ScToken* ScRawToken::CreateToken() const
             return new ScMatrixToken( pMat );
         //break;
         case svIndex :
+            fprintf(stdout, "ScRawToken::CreateToken:   creating index token ... (op = %d)\n", eOp);
             return new ScIndexToken( eOp, nIndex );
         //break;
+        case svExternalName:
+        {
+            String aName(extname.cName);
+            return new ScExternalNameToken( extname.nFileId, aName );
+        }
         case svJump :
             return new ScJumpToken( eOp, (short*) nJump );
         //break;
@@ -461,6 +483,7 @@ BOOL ScToken::IsMatrixFunction() const
 
 ScToken* ScToken::Clone() const
 {
+    OpCode nOp = GetOpCode();
     switch ( GetType() )
     {
         case svByte :
@@ -470,20 +493,24 @@ ScToken* ScToken::Clone() const
             return new ScDoubleToken( *static_cast<const ScDoubleToken*>(this) );
         //break;
         case svString :
-            if (GetOpCode() == ocPush)
+            if (nOp == ocPush)
                 return new ScStringToken( *static_cast<const ScStringToken*>(this) );
             else
                 return new ScStringOpToken( *static_cast<const ScStringOpToken*>(this) );
         //break;
         case svSingleRef :
-            if (GetOpCode() == ocPush)
+            if (nOp == ocPush)
                 return new ScSingleRefToken( *static_cast<const ScSingleRefToken*>(this) );
+            else if (nOp == ocExternalName)
+                return new ScExternalSingleRefToken( *static_cast<const ScExternalSingleRefToken*>(this) );
             else
                 return new ScSingleRefOpToken( *static_cast<const ScSingleRefOpToken*>(this) );
         //break;
         case svDoubleRef :
-            if (GetOpCode() == ocPush)
+            if (nOp == ocPush)
                 return new ScDoubleRefToken( *static_cast<const ScDoubleRefToken*>(this) );
+            else if (nOp == ocExternalName)
+                return new ScExternalDoubleRefToken( *static_cast<const ScExternalDoubleRefToken*>(this) );
             else
                 return new ScDoubleRefOpToken( *static_cast<const ScDoubleRefOpToken*>(this) );
         //break;
@@ -505,6 +532,9 @@ ScToken* ScToken::Clone() const
         case svExternal :
             return new ScExternalToken( *static_cast<const ScExternalToken*>(this) );
         //break;
+        case svExternalName :
+            return new ScExternalNameToken( *static_cast<const ScExternalNameToken*>(this) );
+        //break;
         case svFAP :
             return new ScFAPToken( *static_cast<const ScFAPToken*>(this) );
         //break;
@@ -1015,6 +1045,150 @@ BOOL ScIndexToken::operator==( const ScToken& r ) const
     return ScToken::operator==( r ) && nIndex == r.GetIndex();
 }
 
+// ============================================================================
+
+ScExternalSingleRefToken::ScExternalSingleRefToken( sal_uInt16 nFileId, const SingleRefData& r ) :
+    ScOpToken(ocExternalName, svSingleRef),
+    mnFileId(nFileId),
+    maSingleRef(r)
+{
+}
+
+ScExternalSingleRefToken::ScExternalSingleRefToken( const ScExternalSingleRefToken& r ) :
+    ScOpToken(r), 
+    mnFileId(r.mnFileId),
+    maSingleRef(r.maSingleRef)
+{
+}
+
+ScExternalSingleRefToken::~ScExternalSingleRefToken()
+{
+}
+
+USHORT ScExternalSingleRefToken::GetIndex() const
+{
+    return mnFileId;
+}
+
+const SingleRefData& ScExternalSingleRefToken::GetSingleRef() const
+{
+    return maSingleRef;
+}
+
+SingleRefData& ScExternalSingleRefToken::GetSingleRef()
+{
+    return maSingleRef;
+}
+
+BOOL ScExternalSingleRefToken::operator ==( const ScToken& r ) const
+{
+    if (!ScToken::operator==(r))
+        return false;
+
+    if (mnFileId != r.GetIndex())
+        return false;
+
+    return maSingleRef == r.GetSingleRef();
+}
+
+// ============================================================================
+
+ScExternalDoubleRefToken::ScExternalDoubleRefToken( sal_uInt16 nFileId, const ComplRefData& r ) :
+    ScOpToken(ocExternalName, svDoubleRef),
+    mnFileId(nFileId),
+    maDoubleRef(r)
+{
+}
+
+ScExternalDoubleRefToken::ScExternalDoubleRefToken( const ScExternalDoubleRefToken& r ) :
+    ScOpToken(r), 
+    mnFileId(r.mnFileId),
+    maDoubleRef(r.maDoubleRef)
+{
+}
+
+ScExternalDoubleRefToken::~ScExternalDoubleRefToken()
+{
+}
+
+USHORT ScExternalDoubleRefToken::GetIndex() const
+{
+    return mnFileId;
+}
+
+const ComplRefData& ScExternalDoubleRefToken::GetDoubleRef() const
+{
+    return maDoubleRef;
+}
+
+ComplRefData& ScExternalDoubleRefToken::GetDoubleRef()
+{
+    return maDoubleRef;
+}
+
+BOOL ScExternalDoubleRefToken::operator ==( const ScToken& r ) const
+{
+    if (!ScToken::operator==(r))
+        return false;
+
+    if (mnFileId != r.GetIndex())
+        return false;
+
+    return maDoubleRef == r.GetDoubleRef();
+}
+
+// ============================================================================
+
+ScExternalNameToken::ScExternalNameToken( sal_uInt16 nFileId, const String& rName ) :
+    ScOpToken(ocExternalName, svExternalName),
+    mnFileId(nFileId),
+    maName(rName)
+{
+}
+
+ScExternalNameToken::ScExternalNameToken( const ScExternalNameToken& r ) :
+    ScOpToken(r),
+    mnFileId(r.mnFileId),
+    maName(r.maName)
+{
+}
+
+ScExternalNameToken::~ScExternalNameToken() {}
+
+USHORT ScExternalNameToken::GetIndex() const
+{
+    return mnFileId;
+}
+
+const String& ScExternalNameToken::GetString() const
+{
+    return maName;
+}
+
+BOOL ScExternalNameToken::operator==( const ScToken& r ) const
+{
+    if ( !ScToken::operator==(r) )
+        return false;
+
+    if (mnFileId != r.GetIndex())
+        return false;
+
+    xub_StrLen nLen = maName.Len();
+    const String& rName = r.GetString();
+    if (nLen != rName.Len())
+        return false;
+
+    const sal_Unicode* p1 = maName.GetBuffer();
+    const sal_Unicode* p2 = rName.GetBuffer();
+    for (xub_StrLen j = 0; j < nLen; ++j)
+    {
+        if (p1[j] != p2[j])
+            return false;
+    }
+    return true;
+}
+
+// ============================================================================
 
 short* ScJumpToken::GetJump() const                     { return pJump; }
 BOOL ScJumpToken::operator==( const ScToken& r ) const
@@ -1873,6 +2047,11 @@ ScToken* ScTokenArray::AddMatrix( ScMatrix* p )
     return Add( new ScMatrixToken( p ) );
 }
 
+ScToken* ScTokenArray::AddExternalName( sal_uInt16 nFileId, const String& rName )
+{
+    return Add( new ScExternalNameToken(nFileId, rName) );
+}
+
 ScToken* ScTokenArray::AddColRowName( const SingleRefData& rRef )
 {
     return Add( new ScSingleRefOpToken( ocColRowName, rRef ) );
diff --git sc/source/filter/excel/excform8.cxx sc/source/filter/excel/excform8.cxx
index ebf8543..da9ded9 100644
--- sc/source/filter/excel/excform8.cxx
+++ sc/source/filter/excel/excform8.cxx
@@ -41,6 +41,7 @@
 #include "xilink.hxx"
 #include "xiname.hxx"
 
+#include "externalrefmgr.hxx"
 
 ExcelToSc8::ExcelToSc8( const XclImpRoot& rRoot ) :
     ExcelToSc( rRoot ),
@@ -608,8 +609,22 @@ ConvErr ExcelToSc8::Convert( const ScTokenArray*& rpTokArray, XclImpStream& aIn,
                     {
                         case xlExtName:
                         {
-                            aStack << aPool.Store( ocNoName, pExtName->GetName() );
-                            GetTracer().TraceFormulaExtName();
+                            const String* pFileUrl = rLinkMan.GetSupbookUrl(nXtiIndex);
+                            if (!pFileUrl)
+                            {    
+                                aStack << aPool.Store(ocNoName, pExtName->GetName());
+                                break;
+                            }
+
+                            String aFileUrl = ScGlobal::GetAbsDocName(*pFileUrl, GetDocShell());
+                            ScExternalRefManager* pRefMgr = GetDoc().GetExternalRefManager();
+                            sal_uInt16 nFileId = pRefMgr->getExternalFileId(aFileUrl);
+                            fprintf(stdout, "ExcelToSc8::Convert:   external name (file: %s; name: %s; file id: %d)\n",
+                                    rtl::OUStringToOString(aFileUrl, RTL_TEXTENCODING_UTF8).getStr(),
+                                    rtl::OUStringToOString(pExtName->GetName(), RTL_TEXTENCODING_UTF8).getStr(),
+                                    nFileId);
+
+                            aStack << aPool.StoreExtName(nFileId, pExtName->GetName());
                         }
                         break;
 
diff --git sc/source/filter/excel/tokstack.cxx sc/source/filter/excel/tokstack.cxx
index 20ada63..821a4ad 100644
--- sc/source/filter/excel/tokstack.cxx
+++ sc/source/filter/excel/tokstack.cxx
@@ -395,6 +395,16 @@ void TokenPool::GetElement( const UINT16 nId )
                         pScToken->AddMatrix( p );
                 }
                 break;
+            case T_ExtName:
+            {
+                UINT16 n = pElement[nId];
+                if (n < maExtNames.size())
+                {
+                    const ExtName& r = maExtNames[n];
+                    pScToken->AddExternalName(r.mnFileId, r.maName);
+                }
+            }
+            break;
 			default:
 				DBG_ERROR("-TokenPool::GetElement(): Zustand undefiniert!?");
 		}
@@ -477,6 +487,16 @@ void TokenPool::GetElementRek( const UINT16 nId )
                             pScToken->AddMatrix( p );
                     }
                     break;
+                case T_ExtName:
+                {
+                    UINT16 n = pElement[*pAkt];
+                    if (n < maExtNames.size())
+                    {
+                        const ExtName& r = maExtNames[n];
+                        pScToken->AddExternalName(r.mnFileId, r.maName);
+                    }
+                }
+                break;
 				default:
 					DBG_ERROR("-TokenPool::GetElementRek(): Zustand undefiniert!?");
 			}
@@ -724,9 +744,28 @@ const TokenId TokenPool::StoreMatrix( SCSIZE nC, SCSIZE nR )
     return ( const TokenId ) nElementAkt;
 }
 
+const TokenId TokenPool::StoreExtName( sal_uInt16 nFileId, const String& rName )
+{
+    if ( nElementAkt >= nElement )
+        GrowElement();
+
+    pElement[nElementAkt] = static_cast<UINT16>(maExtNames.size());
+    pType[nElementAkt] = T_ExtName;
+    
+    maExtNames.push_back(ExtName());
+    ExtName& r = maExtNames.back();
+    r.mnFileId = nFileId;
+    r.maName = rName;
+
+    ++nElementAkt;
+
+    return static_cast<const TokenId>(nElementAkt);
+}
+
 void TokenPool::Reset( void )
 {
     nP_IdAkt = nP_IdLast = nElementAkt = nP_StrAkt = nP_DblAkt = nP_ErrAkt = nP_RefTrAkt = nP_ExtAkt = nP_NlfAkt = nP_MatrixAkt = 0;
+    maExtNames.clear();
 }
 
 
diff --git sc/source/filter/excel/xeformula.cxx sc/source/filter/excel/xeformula.cxx
index c85aad1..0315b6b 100644
--- sc/source/filter/excel/xeformula.cxx
+++ sc/source/filter/excel/xeformula.cxx
@@ -42,6 +42,12 @@
 #include "xelink.hxx"
 #include "xename.hxx"
 
+#include "document.hxx"
+#include "externalrefmgr.hxx"
+
+#include <memory>
+#include <stdio.h>
+
 // External reference log =====================================================
 
 XclExpRefLogEntry::XclExpRefLogEntry() :
@@ -300,6 +306,7 @@ private:
     void                ProcessBoolean( const XclExpTokenData& rTokData );
     void                ProcessDdeLink( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
     void                ProcessExternal( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
+    void                ProcessExternalName( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
 
     void                ProcessFunction( const XclExpTokenData& rTokData, sal_uInt8 nExpClass );
     void                PrepareFunction( XclExpFuncData& rFuncData );
@@ -1115,6 +1122,12 @@ XclExpTokenData XclExpFmlaCompImpl::Factor( XclExpTokenData aTokData, sal_uInt8
     StackVar eTokType = aTokData.GetType();
     OpCode eOpCode = aTokData.GetOpCode();
 
+    if (eOpCode == ocExternalName)
+    {
+        ProcessExternalName( aTokData, nExpClass );
+        return GetNextToken();
+    }
+
     switch( eTokType )
     {
         case svUnknown:     mbOk = false;                           break;
@@ -1249,6 +1262,66 @@ void XclExpFmlaCompImpl::ProcessExternal( const XclExpTokenData& rTokData, sal_u
         ProcessFunction( rTokData, nExpClass );
 }
 
+void XclExpFmlaCompImpl::ProcessExternalName( const XclExpTokenData& rTokData, sal_uInt8 nExpClass )
+{
+    StackVar eType = rTokData.GetType();
+
+    ScExternalRefManager* pRefMgr = GetDoc().GetExternalRefManager();
+    USHORT nFileId = rTokData.mpScToken->GetIndex();
+    switch (eType)
+    {
+        case svSingleRef:
+        {
+            fprintf(stdout, "XclExpFmlaCompImpl::ProcessExternalName:   svSingleRef not supported yet\n");
+        }
+        break;
+        case svDoubleRef:
+        {
+            fprintf(stdout, "XclExpFmlaCompImpl::ProcessExternalName:   svDoubleRef not supported yet\n");
+        }
+        break;
+        case svExternalName:
+        {
+            fprintf(stdout, "XclExpFmlaCompImpl::ProcessExternalName:   svExternalName\n");
+
+            const String& aName = rTokData.mpScToken->GetString();
+            ScTokenArray* pArray = pRefMgr->getRangeNameTokens(nFileId, aName);
+            if (!pArray || !mpScBasePos)
+            {    
+                AppendErrorToken(XclTools::GetXclErrorCode(errNoName), rTokData.mnSpaces);
+                break;
+            }
+
+            for (ScToken* p = pArray->First(); p; p = pArray->Next())
+            {
+                if (p->GetOpCode() == ocExternalName)
+                {
+                    if (p->GetType() == svSingleRef)
+                    {
+                        SingleRefData aData(p->GetSingleRef());
+                        aData.CalcAbsIfRel(*mpScBasePos);
+                        mpLinkMgr->StoreCell(nFileId, aData);
+                    }
+                    else if (p->GetType() == svDoubleRef)
+                    {
+                        ComplRefData aData(p->GetDoubleRef());
+                        aData.CalcAbsIfRel(*mpScBasePos);
+                        mpLinkMgr->StoreCellRange(nFileId, aData);
+                    }
+                }
+            }
+
+            const String* pFile = pRefMgr->getExternalFileName(nFileId);
+            sal_uInt16 nExtSheet, nExtName;
+            if (mpLinkMgr->InsertExtName(nExtSheet, nExtName, *pFile, aName, pArray))
+                AppendNameXToken(nExtSheet, nExtName, nExpClass, rTokData.mnSpaces);
+            else
+                AppendErrorToken(EXC_ERR_REF, rTokData.mnSpaces);
+        }
+        break;
+    }
+}
+
 void XclExpFmlaCompImpl::ProcessFunction( const XclExpTokenData& rTokData, sal_uInt8 nExpClass )
 {
     OpCode eOpCode = rTokData.GetOpCode();
diff --git sc/source/filter/excel/xelink.cxx sc/source/filter/excel/xelink.cxx
index b1bacad..2b54a89 100644
--- sc/source/filter/excel/xelink.cxx
+++ sc/source/filter/excel/xelink.cxx
@@ -38,6 +38,15 @@
 #include "document.hxx"
 #include "cell.hxx"
 #include "scextopt.hxx"
+#include "externalrefmgr.hxx"
+
+#include <vector>
+#include <memory>
+#include <stdio.h>
+
+using ::std::auto_ptr;
+using ::std::find_if;
+using ::std::vector;
 
 // ============================================================================
 // *** Helper classes ***
@@ -102,6 +111,22 @@ private:
     XclExpCachedMatRef  mxMatrix;       /// Cached results of the DDE link.
 };
 
+// ----------------------------------------------------------------------------
+
+class XclExpExtName : public XclExpExtNameBase
+{
+public:
+    explicit            XclExpExtName( const XclExpRoot& rRoot, const String& rName,
+                                       const ScTokenArray* pArray );
+
+private:
+    /** Writes additional record contents. */
+    virtual void        WriteAddData( XclExpStream& rStrm );
+
+private:
+    auto_ptr<ScTokenArray>  mpArray;
+};
+
 // List of external names =====================================================
 
 /** List of all external names of a sheet. */
@@ -117,6 +142,8 @@ public:
         @return  The 1-based (Excel-like) list index of the DDE link. */
     sal_uInt16          InsertDde( const String& rApplic, const String& rTopic, const String& rItem );
 
+    sal_uInt16          InsertExtName( const String& rName, const ScTokenArray* pArray );
+
     /** Writes the EXTERNNAME record list. */
     virtual void        Save( XclExpStream& rStrm );
 
@@ -220,6 +247,9 @@ public:
     /** Stores all cells in the given range in the CRN list. */
     void                StoreCellRange( const XclExpRoot& rRoot, const ScRange& rRange );
 
+    void                StoreCell( const XclExpRoot& rRoot, const ScAddress& rCell, const ScToken& rToken );
+    void                StoreCellRange( const XclExpRoot& rRoot, const ScRange& rRange, const ScToken& rToken );
+
     /** Writes the XCT and all CRN records. */
     virtual void        Save( XclExpStream& rStrm );
 
@@ -319,6 +349,11 @@ public:
     /** Stores all cells in the given range in the CRN list of the specified SUPBOOK sheet. */
     void                StoreCellRange( const ScRange& rRange, sal_uInt16 nSBTab );
 
+    void                StoreCell( sal_uInt16 nSBTab, const ScAddress& rCell, const ScToken& rToken );
+    void                StoreCellRange( sal_uInt16 nSBTab, const ScRange& rRange, const ScToken& rToken );
+
+    sal_uInt16          GetTabIndex( const String& rTabName );
+
     /** Inserts a new sheet name into the SUPBOOK and returns the SUPBOOK internal sheet index. */
     sal_uInt16          InsertTabName( const String& rTabName );
     /** Finds or inserts an EXTERNNAME record for add-ins.
@@ -328,6 +363,8 @@ public:
         @return  The 1-based EXTERNNAME record index; or 0, if the record list is full. */
     sal_uInt16          InsertDde( const String& rItem );
 
+    sal_uInt16          InsertExtName( const String& rName, const ScTokenArray* pArray );
+
     /** Writes the SUPBOOK and all EXTERNNAME, XCT and CRN records. */
     virtual void        Save( XclExpStream& rStrm );
 
@@ -394,6 +431,9 @@ public:
     /** Stores all cells in the given range in a CRN record list. */
     void                StoreCellRange( const ScRange& rRange );
 
+    void                StoreCell( sal_uInt16 nFileId, const ScAddress& rCell );
+    void                StoreCellRange( sal_uInt16 nFileId, const ScRange& rRange );
+
     /** Finds or inserts an EXTERNNAME record for an add-in function name.
         @param rnSupbook  Returns the index of the SUPBOOK record which contains the add-in function name.
         @param rnExtName  Returns the 1-based EXTERNNAME record index. */
@@ -407,9 +447,22 @@ public:
                             sal_uInt16& rnSupbook, sal_uInt16& rnExtName,
                             const String& rApplic, const String& rTopic, const String& rItem );
 
+    bool                InsertExtName(
+                            sal_uInt16& rnSupbook, sal_uInt16& rnExtName, const String& rUrl,
+                            const String& rName, const ScTokenArray* pArray );
+
     /** Writes all SUPBOOK records with their sub records. */
     virtual void        Save( XclExpStream& rStrm );
 
+    struct XclExpSBIndex
+    {
+        sal_uInt16          mnSupbook;          /// SUPBOOK index for an Excel sheet.
+        sal_uInt16          mnSBTab;            /// Sheet name index in SUPBOOK for an Excel sheet.
+        inline void         Set( sal_uInt16 nSupbook, sal_uInt16 nSBTab )
+                                { mnSupbook = nSupbook; mnSBTab = nSBTab; }
+    };
+    typedef ::std::vector< XclExpSBIndex > XclExpSBIndexVec;
+
 private:
     typedef XclExpRecordList< XclExpSupbook >   XclExpSupbookList;
     typedef XclExpSupbookList::RecordRefType    XclExpSupbookRef;
@@ -435,15 +488,6 @@ private:
     void                AddExtSupbook( SCTAB nScTab );
 
 private:
-    struct XclExpSBIndex
-    {
-        sal_uInt16          mnSupbook;          /// SUPBOOK index for an Excel sheet.
-        sal_uInt16          mnSBTab;            /// Sheet name in SUPBOOK for an Excel sheet.
-        inline void         Set( sal_uInt16 nSupbook, sal_uInt16 nSBTab )
-                                { mnSupbook = nSupbook; mnSBTab = nSBTab; }
-    };
-    typedef ::std::vector< XclExpSBIndex > XclExpSBIndexVec;
-
     XclExpSupbookList   maSupbookList;      /// List of all SUPBOOK records.
     XclExpSBIndexVec    maSBIndexVec;       /// SUPBOOK and sheet name index for each Excel sheet.
     sal_uInt16          mnOwnDocSB;         /// Index to SUPBOOK for own document.
@@ -467,6 +511,9 @@ public:
     /** Derived classes store all cells in the given range in a CRN record list. */
     virtual void        StoreCellRange( const SingleRefData& rRef1, const SingleRefData& rRef2 ) = 0;
 
+    virtual void        StoreCell( sal_uInt16 nFileId, const SingleRefData& rRef ) = 0;
+    virtual void        StoreCellRange( sal_uInt16 nFileId, const SingleRefData& rRef1, const SingleRefData& rRef2 ) = 0;
+
     /** Derived classes find or insert an EXTERNNAME record for an add-in function name. */
     virtual bool        InsertAddIn(
                             sal_uInt16& rnExtSheet, sal_uInt16& rnExtName,
@@ -476,6 +523,10 @@ public:
                             sal_uInt16& rnExtSheet, sal_uInt16& rnExtName,
                             const String& rApplic, const String& rTopic, const String& rItem ) = 0;
 
+    virtual bool        InsertExtName(
+                            sal_uInt16& rnExtSheet, sal_uInt16& rnExtName, const String& rUrl,
+                            const String& rName, const ScTokenArray* pArray ) = 0;
+
     /** Derived classes write the entire link table to the passed stream. */
     virtual void        Save( XclExpStream& rStrm ) = 0;
 
@@ -499,13 +550,21 @@ public:
 
     virtual void        StoreCellRange( const SingleRefData& rRef1, const SingleRefData& rRef2 );
 
+    virtual void        StoreCell( sal_uInt16 nFileId, const SingleRefData& rRef );
+    virtual void        StoreCellRange( sal_uInt16 nFileId, const SingleRefData& rRef1, const SingleRefData& rRef2 );
+
     virtual bool        InsertAddIn(
                             sal_uInt16& rnExtSheet, sal_uInt16& rnExtName,
                             const String& rName );
+
     virtual bool        InsertDde(
                             sal_uInt16& rnExtSheet, sal_uInt16& rnExtName,
                             const String& rApplic, const String& rTopic, const String& rItem );
 
+    virtual bool        InsertExtName(
+                            sal_uInt16& rnExtSheet, sal_uInt16& rnExtName, const String& rUrl,
+                            const String& rName, const ScTokenArray* pArray );
+
     virtual void        Save( XclExpStream& rStrm );
 
 private:
@@ -552,13 +611,21 @@ public:
 
     virtual void        StoreCellRange( const SingleRefData& rRef1, const SingleRefData& rRef2 );
 
+    virtual void        StoreCell( sal_uInt16 nFileId, const SingleRefData& rRef );
+    virtual void        StoreCellRange( sal_uInt16 nFileId, const SingleRefData& rRef1, const SingleRefData& rRef2 );
+
     virtual bool        InsertAddIn(
                             sal_uInt16& rnExtSheet, sal_uInt16& rnExtName,
                             const String& rName );
+
     virtual bool        InsertDde(
                             sal_uInt16& rnExtSheet, sal_uInt16& rnExtName,
                             const String& rApplic, const String& rTopic, const String& rItem );
 
+    virtual bool        InsertExtName(
+                            sal_uInt16& rnExtSheet, sal_uInt16& rnExtName, const String& rUrl,
+                            const String& rName, const ScTokenArray* pArray );
+
     virtual void        Save( XclExpStream& rStrm );
 
 private:
@@ -885,6 +952,94 @@ void XclExpExtNameDde::WriteAddData( XclExpStream& rStrm )
         mxMatrix->Save( rStrm );
 }
 
+// ----------------------------------------------------------------------------
+
+XclExpExtName::XclExpExtName( const XclExpRoot& rRoot, const String& rName, const ScTokenArray* pArray ) :
+    XclExpExtNameBase( rRoot, rName ),
+    mpArray(pArray->Clone())
+{
+}
+
+void XclExpExtName::WriteAddData( XclExpStream& rStrm )
+{
+    // Write only if it only has a single token that is either a cell or cell 
+    // range address.  Excel just writes '02 00 1C 17' for all the other types
+    // of external names.
+
+    do
+    {
+        if (mpArray->GetLen() != 1)
+            break;
+
+        const ScToken* p = mpArray->First();
+        if (p->GetOpCode() != ocExternalName)
+            break;
+
+        switch (p->GetType())
+        {
+            case svSingleRef:
+            {
+                const SingleRefData& rRef = p->GetSingleRef();
+                if (rRef.IsTabRel())
+                    break;
+
+                sal_uInt16 nTab = rRef.nTab;
+                bool bColRel = rRef.IsColRel();
+                bool bRowRel = rRef.IsRowRel();
+                sal_uInt16 nCol = bColRel ? rRef.nRelCol : rRef.nCol;
+                sal_uInt16 nRow = bRowRel ? rRef.nRelRow : rRef.nRow;
+                if (bColRel) nCol |= 0x4000;
+                if (bRowRel) nCol |= 0x8000;
+
+                // size is always 9
+                rStrm << static_cast<sal_uInt16>(9);
+                // operator token (3A for cell reference)
+                rStrm << static_cast<sal_uInt8>(0x3A);
+                // cell address (Excel's address has 2 sheet IDs.)
+                rStrm << nTab << nTab << nRow << nCol;
+                return;
+            }
+            case svDoubleRef:
+            {
+                const ComplRefData& rRef = p->GetDoubleRef();
+                const SingleRefData& r1 = rRef.Ref1;
+                const SingleRefData& r2 = rRef.Ref2;
+                if (r1.IsTabRel() || r2.IsTabRel())
+                    break;
+
+                sal_uInt16 nTab1 = r1.nTab;
+                sal_uInt16 nTab2 = r2.nTab;
+                bool bCol1Rel = r1.IsColRel();
+                bool bRow1Rel = r1.IsRowRel();
+                bool bCol2Rel = r2.IsColRel();
+                bool bRow2Rel = r2.IsRowRel();
+
+                sal_uInt16 nCol1 = bCol1Rel ? r1.nRelCol : r1.nCol;
+                sal_uInt16 nCol2 = bCol2Rel ? r2.nRelCol : r2.nCol;
+                sal_uInt16 nRow1 = bRow1Rel ? r1.nRelRow : r1.nRow;
+                sal_uInt16 nRow2 = bRow2Rel ? r2.nRelRow : r2.nRow;
+                if (bCol1Rel) nCol1 |= 0x4000;
+                if (bRow1Rel) nCol1 |= 0x8000;
+                if (bCol2Rel) nCol2 |= 0x4000;
+                if (bRow2Rel) nCol2 |= 0x8000;
+
+                // size is always 13 (0x0D)
+                rStrm << static_cast<sal_uInt16>(13);
+                // operator token (3B for area reference)
+                rStrm << static_cast<sal_uInt8>(0x3B);
+                // range (area) address
+                rStrm << nTab1 << nTab2 << nRow1 << nRow2 << nCol1 << nCol2;
+                return;
+            }
+        }
+    }
+    while (false);
+
+    // special value for #REF! (02 00 1C 17)
+    rStrm << static_cast<sal_uInt16>(0x0002);
+    rStrm << static_cast<sal_uInt16>(0x171C);
+}
+
 // List of external names =====================================================
 
 XclExpExtNameBuffer::XclExpExtNameBuffer( const XclExpRoot& rRoot ) :
@@ -920,6 +1075,12 @@ sal_uInt16 XclExpExtNameBuffer::InsertDde(
     return nIndex;
 }
 
+sal_uInt16 XclExpExtNameBuffer::InsertExtName( const String& rName, const ScTokenArray* pArray )
+{
+    sal_uInt16 nIndex = GetIndex( rName );
+    return nIndex ? nIndex : AppendNew( new XclExpExtName( GetRoot(), rName, pArray ) );
+}
+
 void XclExpExtNameBuffer::Save( XclExpStream& rStrm )
 {
     maNameList.Save( rStrm );
@@ -1066,6 +1227,78 @@ void XclExpXct::StoreCellRange( const XclExpRoot& rRoot, const ScRange& rRange )
     maUsedCells.SetMultiMarkArea( rRange );
 }
 
+void XclExpXct::StoreCell( const XclExpRoot& /*rRoot*/, const ScAddress& rCell, const ScToken& rToken )
+{
+    switch (rToken.GetType())
+    {
+        case svString:
+        {
+            XclExpCrnRef xCrn(
+                new XclExpCrnString(rCell.Col(), rCell.Row(), rToken.GetString()));
+            maCrnList.AppendRecord(xCrn);
+        }
+        break;
+        case svDouble:
+        {
+            XclExpCrnRef xCrn(
+                new XclExpCrnDouble(rCell.Col(), rCell.Row(), rToken.GetDouble()));
+            maCrnList.AppendRecord(xCrn);
+        }
+        break;
+        case svEmptyCell:
+        {
+            XclExpCrnRef xCrn(
+                new XclExpCrnDouble(rCell.Col(), rCell.Row(), 0.0));
+            maCrnList.AppendRecord(xCrn);
+        }
+        break;
+    }
+}
+
+void XclExpXct::StoreCellRange( const XclExpRoot& /*rRoot*/, const ScRange& rRange, const ScToken& rToken )
+{
+    if (rToken.GetType() != svMatrix)
+        return;
+
+    if (rRange.aStart.Tab() != rRange.aEnd.Tab())
+        // multi-table range is not supported here.
+        return;
+
+    const ScMatrix* pMtx = rToken.GetMatrix();
+    if (!pMtx)
+        return;
+
+    SCSIZE nCols, nRows;
+    pMtx->GetDimensions(nCols, nRows);
+    const ScAddress& s = rRange.aStart;
+    const ScAddress& e = rRange.aEnd;
+    if (static_cast<SCCOL>(nCols) != e.Col() - s.Col() + 1 || 
+        static_cast<SCROW>(nRows) != e.Row() - s.Row() + 1)
+    {
+        // size mis-match!
+        return;
+    }
+
+    for (SCSIZE nCol = 0; nCol < nCols; ++nCol)
+    {
+        for (SCSIZE nRow = 0; nRow < nRows; ++nRow)
+        {
+            if (pMtx->IsString(nCol, nRow))
+            {
+                XclExpCrnRef xCrn(new XclExpCrnString(
+                    s.Col() + nCol, s.Row() + nRow, pMtx->GetString(nCol, nRow)));
+                maCrnList.AppendRecord(xCrn);
+            }
+            else if (pMtx->IsValueOrEmpty(nCol, nRow))
+            {
+                XclExpCrnRef xCrn(new XclExpCrnDouble(
+                    s.Col() + nCol, s.Row() + nRow, pMtx->GetDouble(nCol, nRow)));
+                maCrnList.AppendRecord(xCrn);
+            }
+        }
+    }
+}
+
 void XclExpXct::Save( XclExpStream& rStrm )
 {
     XclExpRecord::Save( rStrm );
@@ -1206,6 +1439,41 @@ void XclExpSupbook::StoreCellRange( const ScRange& rRange, sal_uInt16 nSBTab )
         xXct->StoreCellRange( GetRoot(), rRange );
 }
 
+void XclExpSupbook::StoreCell( sal_uInt16 nSBTab, const ScAddress& rCell, const ScToken& rToken )
+{
+    XclExpXctRef xXct = maXctList.GetRecord(nSBTab);
+    if (!xXct.is())
+        return;
+
+    xXct->StoreCell(GetRoot(), rCell, rToken);
+}
+
+void XclExpSupbook::StoreCellRange( sal_uInt16 nSBTab, const ScRange& rRange, const ScToken& rToken )
+{
+    if (rRange.aStart.Tab() != rRange.aEnd.Tab())
+        // multi-table range is not allowed!
+        return;
+
+    XclExpXctRef xXct = maXctList.GetRecord(nSBTab);
+    if (!xXct.is())
+        return;
+
+    xXct->StoreCellRange(GetRoot(), rRange, rToken);
+}
+
+sal_uInt16 XclExpSupbook::GetTabIndex( const String& rTabName )
+{
+    XclExpString aXclName(rTabName);
+    size_t nSize = maXctList.GetSize();
+    for (size_t i = 0; i < nSize; ++i)
+    {
+        XclExpXctRef aRec = maXctList.GetRecord(i);
+        if (aXclName == aRec->GetTabName())
+            return ulimit_cast<sal_uInt16>(i);
+    }
+    return InsertTabName(rTabName);
+}
+
 sal_uInt16 XclExpSupbook::InsertTabName( const String& rTabName )
 {
     DBG_ASSERT( meType == EXC_SBTYPE_EXTERN, "XclExpSupbook::InsertTabName - don't insert sheet names here" );
@@ -1226,6 +1494,11 @@ sal_uInt16 XclExpSupbook::InsertDde( const String& rItem )
     return GetExtNameBuffer().InsertDde( maUrl, maDdeTopic, rItem );
 }
 
+sal_uInt16 XclExpSupbook::InsertExtName( const String& rName, const ScTokenArray* pArray )
+{
+    return GetExtNameBuffer().InsertExtName(rName, pArray);
+}
+
 void XclExpSupbook::Save( XclExpStream& rStrm )
 {
     // SUPBOOK record
@@ -1352,6 +1625,131 @@ void XclExpSupbookBuffer::StoreCellRange( const ScRange& rRange )
     }
 }
 
+namespace {
+
+class FindSBIndexEntry
+{
+public:
+    explicit FindSBIndexEntry(sal_uInt16 nSupbookId, sal_uInt16 nTabId) :
+        mnSupbookId(nSupbookId), mnTabId(nTabId) {}
+
+    bool operator()(const XclExpSupbookBuffer::XclExpSBIndex& r) const
+    {
+        return mnSupbookId == r.mnSupbook && mnTabId == r.mnSBTab;
+    }
+
+private:
+    sal_uInt16 mnSupbookId;
+    sal_uInt16 mnTabId;
+};
+
+}
+
+void XclExpSupbookBuffer::StoreCell( sal_uInt16 nFileId, const ScAddress& rCell )
+{
+    ScExternalRefManager* pRefMgr = GetDoc().GetExternalRefManager();
+    const String* pUrl = pRefMgr->getExternalFileName(nFileId);
+    if (!pUrl)
+        return;
+
+    XclExpSupbookRef xSupbook;
+    sal_uInt16 nSupbookId;
+    if (!GetSupbookUrl(xSupbook, nSupbookId, *pUrl))
+    {
+        xSupbook.reset(new XclExpSupbook(GetRoot(), *pUrl));
+        nSupbookId = Append(xSupbook);
+    }
+
+    ScToken* pToken = pRefMgr->getSingleRefToken(nFileId, rCell, NULL);
+    if (!pToken)
+        return;
+
+    const String* pTabName = pRefMgr->getExternalTableName(nFileId, rCell.Tab());
+    if (!pTabName)
+        return;
+
+    sal_uInt16 nSheetId = xSupbook->GetTabIndex(*pTabName);
+    FindSBIndexEntry f(nSupbookId, nSheetId);
+    XclExpSBIndexVec::iterator itrEnd = maSBIndexVec.end();
+    XclExpSBIndexVec::const_iterator itr = find_if(maSBIndexVec.begin(), itrEnd, f);
+    if (itr == itrEnd)
+    {
+        maSBIndexVec.push_back(XclExpSBIndex());
+        XclExpSBIndex& r = maSBIndexVec.back();
+        r.mnSupbook = nSupbookId;
+        r.mnSBTab   = nSheetId;
+    }
+
+    xSupbook->StoreCell(nSheetId, rCell, *pToken);
+}
+
+void XclExpSupbookBuffer::StoreCellRange( sal_uInt16 nFileId, const ScRange& rRange )
+{
+    ScExternalRefManager* pRefMgr = GetDoc().GetExternalRefManager();
+    const String* pUrl = pRefMgr->getExternalFileName(nFileId);
+    if (!pUrl)
+        return;
+
+    XclExpSupbookRef xSupbook;
+    sal_uInt16 nSupbookId;
+    if (!GetSupbookUrl(xSupbook, nSupbookId, *pUrl))
+    {
+        xSupbook.reset(new XclExpSupbook(GetRoot(), *pUrl));
+        nSupbookId = Append(xSupbook);
+    }
+
+    SCTAB nTab1 = rRange.aStart.Tab(), nTab2 = rRange.aEnd.Tab();
+
+    // If this is a multi-table range, get token for each table.
+    vector<ScToken*> aMatrixList;
+    aMatrixList.reserve(nTab2 - nTab1 + 1);
+    ScTokenArray* pArray = pRefMgr->getDoubleRefTokens(nFileId, rRange, NULL);
+    if (!pArray)
+        return;
+
+    auto_ptr<ScTokenArray> pNew(pArray->Clone());
+    for (ScToken* p = pNew->First(); p; p = pNew->Next())
+    {
+        if (p->GetType() == svMatrix)
+            aMatrixList.push_back(p);
+        else if (p->GetOpCode() != ocSep)
+        {
+            fprintf(stdout, "XclExpSupbookBuffer::StoreCellRange:   this is supposed to be ocSep!!!\n");
+            return;
+        }
+    }
+
+    if (aMatrixList.size() != nTab2 - nTab1 + 1)
+    {
+        // matrix size mis-match !
+        return;
+    }
+
+    ScRange aRange(rRange);
+    aRange.aStart.SetTab(0);
+    aRange.aEnd.SetTab(0);
+    for (SCTAB nTab = nTab1; nTab <= nTab2; ++nTab)
+    {
+        const String* pTabName = pRefMgr->getExternalTableName(nFileId, nTab);
+        if (!pTabName)
+            continue;
+
+        sal_uInt16 nSheetId = xSupbook->GetTabIndex(*pTabName);
+        FindSBIndexEntry f(nSupbookId, nSheetId);
+        XclExpSBIndexVec::iterator itrEnd = maSBIndexVec.end();
+        XclExpSBIndexVec::const_iterator itr = find_if(maSBIndexVec.begin(), itrEnd, f);
+        if (itr == itrEnd)
+        {
+            maSBIndexVec.push_back(XclExpSBIndex());
+            XclExpSBIndex& r = maSBIndexVec.back();
+            r.mnSupbook = nSupbookId;
+            r.mnSBTab   = nSheetId;
+        }
+
+        xSupbook->StoreCellRange(nSheetId, aRange, *aMatrixList[nTab-nTab1]);
+    }
+}
+
 bool XclExpSupbookBuffer::InsertAddIn(
         sal_uInt16& rnSupbook, sal_uInt16& rnExtName, const String& rName )
 {
@@ -1383,6 +1781,20 @@ bool XclExpSupbookBuffer::InsertDde(
     return rnExtName > 0;
 }
 
+bool XclExpSupbookBuffer::InsertExtName(
+        sal_uInt16& rnSupbook, sal_uInt16& rnExtName, const String& rUrl,
+        const String& rName, const ScTokenArray* pArray )
+{
+    XclExpSupbookRef xSupbook;
+    if (!GetSupbookUrl(xSupbook, rnSupbook, rUrl))
+    {
+        xSupbook.reset( new XclExpSupbook(GetRoot(), rUrl) );
+        rnSupbook = Append(xSupbook);
+    }
+    rnExtName = xSupbook->InsertExtName(rName, pArray);
+    return rnExtName > 0;
+}
+
 void XclExpSupbookBuffer::Save( XclExpStream& rStrm )
 {
     maSupbookList.Save( rStrm );
@@ -1490,6 +1902,16 @@ void XclExpLinkManagerImpl5::StoreCellRange( const SingleRefData& /*rRef1*/, con
     // not implemented
 }
 
+void XclExpLinkManagerImpl5::StoreCell( sal_uInt16 /*nFileId*/, const SingleRefData& /*rRef*/ )
+{
+    // not implemented
+}
+
+void XclExpLinkManagerImpl5::StoreCellRange( sal_uInt16 /*nFileId*/, const SingleRefData& /*rRef1*/, const SingleRefData& /*rRef2*/ )
+{
+    // not implemented
+}
+
 bool XclExpLinkManagerImpl5::InsertAddIn(
         sal_uInt16& rnExtSheet, sal_uInt16& rnExtName, const String& rName )
 {
@@ -1510,6 +1932,14 @@ bool XclExpLinkManagerImpl5::InsertDde(
     return false;
 }
 
+bool XclExpLinkManagerImpl5::InsertExtName(
+        sal_uInt16& /*rnExtSheet*/, sal_uInt16& /*rnExtName*/, const String& /*rUrl*/,
+        const String& /*rName*/, const ScTokenArray* /*pArray*/ )
+{
+    // not implemented
+    return false;
+}
+
 void XclExpLinkManagerImpl5::Save( XclExpStream& rStrm )
 {
     if( sal_uInt16 nExtSheetCount = GetExtSheetCount() )
@@ -1652,6 +2082,19 @@ void XclExpLinkManagerImpl8::StoreCellRange( const SingleRefData& rRef1, const S
     }
 }
 
+void XclExpLinkManagerImpl8::StoreCell( sal_uInt16 nFileId, const SingleRefData& rRef )
+{
+    ScAddress aAddr(rRef.nCol, rRef.nRow, rRef.nTab);
+    maSBBuffer.StoreCell(nFileId, aAddr);
+}
+
+void XclExpLinkManagerImpl8::StoreCellRange( sal_uInt16 nFileId, const SingleRefData& rRef1, const SingleRefData& rRef2 )
+{
+    ScRange aRange(static_cast<SCCOL>(rRef1.nCol), static_cast<SCROW>(rRef1.nRow), static_cast<SCTAB>(rRef1.nTab),
+                   static_cast<SCCOL>(rRef2.nCol), static_cast<SCROW>(rRef2.nRow), static_cast<SCTAB>(rRef2.nTab));
+    maSBBuffer.StoreCellRange(nFileId, aRange);
+}
+
 bool XclExpLinkManagerImpl8::InsertAddIn(
         sal_uInt16& rnExtSheet, sal_uInt16& rnExtName, const String& rName )
 {
@@ -1677,6 +2120,18 @@ bool XclExpLinkManagerImpl8::InsertDde(
     return false;
 }
 
+bool XclExpLinkManagerImpl8::InsertExtName(
+    sal_uInt16& rnExtSheet, sal_uInt16& rnExtName, const String& rName, const String& rUrl, const ScTokenArray* pArray )
+{
+    sal_uInt16 nSupbook;
+    if( maSBBuffer.InsertExtName( nSupbook, rnExtName, rUrl, rName, pArray ) )
+    {
+        rnExtSheet = InsertXti( XclExpXti( nSupbook, EXC_TAB_EXTERNAL, EXC_TAB_EXTERNAL ) );
+        return true;
+    }
+    return false;
+}
+
 void XclExpLinkManagerImpl8::Save( XclExpStream& rStrm )
 {
     if( !maXtiVec.empty() )
@@ -1755,6 +2210,16 @@ void XclExpLinkManager::StoreCellRange( const ComplRefData& rRef )
     mxImpl->StoreCellRange( rRef.Ref1, rRef.Ref2 );
 }
 
+void XclExpLinkManager::StoreCell( sal_uInt16 nFileId, const SingleRefData& rRef )
+{
+    mxImpl->StoreCell( nFileId, rRef );
+}
+
+void XclExpLinkManager::StoreCellRange( sal_uInt16 nFileId, const ComplRefData& rRef )
+{
+    mxImpl->StoreCellRange( nFileId, rRef.Ref1, rRef.Ref2 );
+}
+
 bool XclExpLinkManager::InsertAddIn(
         sal_uInt16& rnExtSheet, sal_uInt16& rnExtName, const String& rName )
 {
@@ -1768,6 +2233,13 @@ bool XclExpLinkManager::InsertDde(
     return mxImpl->InsertDde( rnExtSheet, rnExtName, rApplic, rTopic, rItem );
 }
 
+bool XclExpLinkManager::InsertExtName(
+    sal_uInt16& rnExtSheet, sal_uInt16& rnExtName, const String& rName, const String& rUrl,
+    const ScTokenArray* pArray )
+{
+    return mxImpl->InsertExtName( rnExtSheet, rnExtName, rUrl, rName, pArray );
+}
+
 void XclExpLinkManager::Save( XclExpStream& rStrm )
 {
     mxImpl->Save( rStrm );
diff --git sc/source/filter/excel/xilink.cxx sc/source/filter/excel/xilink.cxx
index e351863..b58f6ec 100644
--- sc/source/filter/excel/xilink.cxx
+++ sc/source/filter/excel/xilink.cxx
@@ -191,6 +191,11 @@ public:
                             sal_uInt16 nXtiIndex ) const;
     /** Returns the specified external name or 0 on error. */
     const XclImpExtName* GetExternName( sal_uInt16 nXtiIndex, sal_uInt16 nExtName ) const;
+
+    /** Returns the absolute file URL of a supporting workbook specified by
+        the index. */
+    const String*       GetSupbookUrl( sal_uInt16 nXtiIndex ) const;
+
     /** Tries to decode the URL of the specified XTI entry to OLE or DDE link components.
         @descr  For DDE links: Decodes to application name and topic.
         For OLE object links: Decodes to class name and document URL.
@@ -584,6 +589,14 @@ const XclImpExtName* XclImpLinkManagerImpl::GetExternName( sal_uInt16 nXtiIndex,
     return pSupbook ? pSupbook->GetExternName( nExtName ) : 0;
 }
 
+const String* XclImpLinkManagerImpl::GetSupbookUrl( sal_uInt16 nXtiIndex ) const
+{
+    const XclImpSupbook* p = GetSupbook( nXtiIndex );
+    if (!p)
+        return NULL;
+    return &p->GetXclUrl();
+}
+
 bool XclImpLinkManagerImpl::GetLinkData( String& rApplic, String& rTopic, sal_uInt16 nXtiIndex ) const
 {
     const XclImpSupbook* pSupbook = GetSupbook( nXtiIndex );
@@ -707,6 +720,11 @@ const XclImpExtName* XclImpLinkManager::GetExternName( sal_uInt16 nXtiIndex, sal
     return mxImpl->GetExternName( nXtiIndex, nExtName );
 }
 
+const String* XclImpLinkManager::GetSupbookUrl( sal_uInt16 nXtiIndex ) const
+{
+    return mxImpl->GetSupbookUrl(nXtiIndex);
+}
+
 bool XclImpLinkManager::GetLinkData( String& rApplic, String& rTopic, sal_uInt16 nXtiIndex ) const
 {
     return mxImpl->GetLinkData( rApplic, rTopic, nXtiIndex );
diff --git sc/source/filter/inc/tokstack.hxx sc/source/filter/inc/tokstack.hxx
index fef6b03..c319704 100644
--- sc/source/filter/inc/tokstack.hxx
+++ sc/source/filter/inc/tokstack.hxx
@@ -37,6 +37,8 @@
 #include <tools/debug.hxx>
 #include "compiler.hxx"
 
+#include <vector>
+
 
 typedef OpCode DefTokenId;
 // in PRODUCT version: ambiguity between OpCode (being USHORT) and UINT16
@@ -80,6 +82,7 @@ enum E_TYPE
 	T_Ext,		// irgendwas Unbekanntes mit Funktionsnamen
 	T_Nlf,		// token for natural language formula
 	T_Matrix,	// token for inline arrays
+    T_ExtName,  // token for external names
 	T_Error		// fuer Abfrage im Fehlerfall
 };
 
@@ -136,6 +139,14 @@ class TokenPool
 		UINT16						nP_Matrix;
 		UINT16						nP_MatrixAkt;
 
+        /** for storage of external names */
+        struct ExtName
+        {
+            sal_uInt16  mnFileId;
+            String      maName;
+        };
+        ::std::vector<ExtName>      maExtNames;
+
 		UINT16*						pElement;	// Array mit Indizes fuer Elemente
 		E_TYPE*						pType;		// ...mit Typ-Info
 		UINT16*						pSize;		// ...mit Laengenangabe (Anz. UINT16)
@@ -182,6 +193,7 @@ class TokenPool
 										// 4 externals (e.g. AddIns, Makros...)
 		const TokenId				StoreNlf( const SingleRefData& rTr );
 		const TokenId				StoreMatrix( SCSIZE nC, SCSIZE nR );
+        const TokenId               StoreExtName( sal_uInt16 nFileId, const String& rName );
 
 		inline const TokenId		LastId( void ) const;
 		inline const ScTokenArray*	operator []( const TokenId nId );
diff --git sc/source/filter/inc/xelink.hxx sc/source/filter/inc/xelink.hxx
index 795219c..2d528d9 100644
--- sc/source/filter/inc/xelink.hxx
+++ sc/source/filter/inc/xelink.hxx
@@ -178,6 +178,10 @@ public:
     /** Stores all cells in the given range in a CRN record list. */
     void                StoreCellRange( const ComplRefData& rRef );
 
+    void                StoreCell( sal_uInt16 nFileId, const SingleRefData& rRef );
+
+    void                StoreCellRange( sal_uInt16 nFileId, const ComplRefData& rRef );
+
     /** Finds or inserts an EXTERNNAME record for an add-in function name.
         @param rnExtSheet  (out-param) Returns the index of the EXTSHEET structure for the add-in function name.
         @param rnExtName  (out-param) Returns the 1-based EXTERNNAME record index.
@@ -193,6 +197,10 @@ public:
                             sal_uInt16& rnExtSheet, sal_uInt16& rnExtName,
                             const String& rApplic, const String& rTopic, const String& rItem );
 
+    bool                InsertExtName(
+                            sal_uInt16& rnExtSheet, sal_uInt16& rnExtName, const String& rUrl,
+                            const String& rName, const ScTokenArray* pArray );
+
     /** Writes the entire Link table. */
     virtual void        Save( XclExpStream& rStrm );
 
diff --git sc/source/filter/inc/xilink.hxx sc/source/filter/inc/xilink.hxx
index 0d547fe..3c2d0d9 100644
--- sc/source/filter/inc/xilink.hxx
+++ sc/source/filter/inc/xilink.hxx
@@ -179,6 +179,9 @@ public:
                             sal_uInt16 nXtiIndex ) const;
     /** Returns the specified external name or 0 on error. */
     const XclImpExtName* GetExternName( sal_uInt16 nXtiIndex, sal_uInt16 nExtName ) const;
+
+    const String* GetSupbookUrl( sal_uInt16 nXtiIndex ) const;
+
     /** Tries to decode the URL of the specified XTI entry to OLE or DDE link components.
         @descr  For DDE links: Decodes to application name and topic.
         For OLE object links: Decodes to class name and document URL.
diff --git sc/source/ui/docshell/externalrefmgr.cxx sc/source/ui/docshell/externalrefmgr.cxx
new file mode 100644
index 0000000..c7c0bae
--- /dev/null
+++ sc/source/ui/docshell/externalrefmgr.cxx
@@ -0,0 +1,789 @@
+/*************************************************************************
+ *
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ * 
+ * Copyright 2008 by Sun Microsystems, Inc.
+ *
+ * OpenOffice.org - a multi-platform office productivity suite
+ *
+ * $RCSfile: document.hxx,v $
+ * $Revision: 1.112 $
+ *
+ * This file is part of OpenOffice.org.
+ *
+ * OpenOffice.org is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 3
+ * only, as published by the Free Software Foundation.
+ *
+ * OpenOffice.org is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License version 3 for more details
+ * (a copy is included in the LICENSE file that accompanied this code).
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * version 3 along with OpenOffice.org.  If not, see
+ * <http://www.openoffice.org/license.html>
+ * for a copy of the LGPLv3 License.
+ *
+ ************************************************************************/
+
+// MARKER(update_precomp.py): autogen include statement, do not remove
+#include "precompiled_sc.hxx"
+
+
+
+// INCLUDE ---------------------------------------------------------------
+
+#include "externalrefmgr.hxx"
+#include "document.hxx"
+#include "token.hxx"
+#include "tokenarray.hxx"
+#include "address.hxx"
+#include "tablink.hxx"
+#include "docsh.hxx"
+#include "scextopt.hxx"
+#include "rangenam.hxx"
+#include "cell.hxx"
+#include "viewdata.hxx"
+#include "tabvwsh.hxx"
+#include "sc.hrc"
+
+#include "sfx2/app.hxx"
+#include "sfx2/docfilt.hxx"
+#include "sfx2/docfile.hxx"
+#include "sfx2/fcontnr.hxx"
+#include "sfx2/sfxsids.hrc"
+#include "sfx2/objsh.hxx"
+#include "svtools/broadcast.hxx"
+#include "svtools/smplhint.hxx"
+#include "svtools/itemset.hxx"
+#include "svtools/stritem.hxx"
+#include "svx/linkmgr.hxx"
+
+#include <memory>
+#include <stdio.h>
+
+using ::std::auto_ptr;
+using ::com::sun::star::uno::Any;
+using ::std::vector;
+using ::std::find;
+using ::std::distance;
+
+#define SRCDOC_LIFE_SPAN     6000       // 1 minute (in 100th of sec)
+#define SRCDOC_SCAN_INTERVAL 1000*2     // every 2 seconds (in msec)
+
+ScExternalRefLink::ScExternalRefLink(ScDocument* pDoc, sal_uInt16 nFileId, const String& rFilter) :
+    ::sfx2::SvBaseLink(::sfx2::LINKUPDATE_ONCALL, FORMAT_FILE),
+    mnFileId(nFileId),
+    maFilterName(rFilter),
+    mpDoc(pDoc),
+    mbDoRefresh(true)
+{
+}
+
+ScExternalRefLink::~ScExternalRefLink()
+{
+}
+
+void ScExternalRefLink::Closed()
+{
+    ScExternalRefManager* pMgr = mpDoc->GetExternalRefManager();
+    pMgr->removeSrcDocument(mnFileId, true);
+}
+
+void ScExternalRefLink::DataChanged(const String& /*rMimeType*/, const Any& /*rValue*/)
+{
+    if (!mbDoRefresh)
+        return;
+
+    String aFile, aFilter;
+    mpDoc->GetLinkManager()->GetDisplayNames(this, NULL, &aFile, NULL, &aFilter);
+    ScExternalRefManager* pMgr = mpDoc->GetExternalRefManager();
+    const String* pCurFile = pMgr->getExternalFileName(mnFileId);
+    if (!pCurFile)
+        return;
+
+    if (pCurFile->Equals(aFile))
+    {
+        // Refresh the current source document.
+        pMgr->refreshNames(mnFileId);
+    }
+    else
+    {
+        // The source document has changed.
+        pMgr->switchSrcFile(mnFileId, aFile);
+        maFilterName = aFilter;
+    }
+}
+
+void ScExternalRefLink::Edit(Window* pParent, const Link& /*rEndEditHdl*/)
+{
+    SvBaseLink::Edit(pParent, LINK(this, ScExternalRefLink, EndEditHdl));
+}
+
+void ScExternalRefLink::SetDoReferesh(bool b)
+{
+    mbDoRefresh = b;
+}
+
+IMPL_LINK(ScExternalRefLink, EndEditHdl, void*, EMPTYARG)
+{
+    return 0;
+}
+
+// ============================================================================
+
+static ScToken* lcl_convertToToken(ScBaseCell* pCell)
+{
+    if (!pCell)
+        return NULL;
+
+    switch (pCell->GetCellType())
+    {
+        case CELLTYPE_STRING:
+        {
+            String aStr;
+            static_cast<ScStringCell*>(pCell)->GetString(aStr);
+            ScStringToken aToken(aStr);
+            return aToken.Clone();
+        }
+        break;
+        case CELLTYPE_VALUE:
+        {
+            double fVal = static_cast<ScValueCell*>(pCell)->GetValue();
+            ScDoubleToken aToken(fVal);
+            return aToken.Clone();
+        }
+        break;
+        case CELLTYPE_FORMULA:
+        {
+            ScFormulaCell* pFCell = static_cast<ScFormulaCell*>(pCell);
+            if (pFCell->IsValue())
+            {
+                double fVal = pFCell->GetValue();
+                ScDoubleToken aToken(fVal);
+                return aToken.Clone();
+            }
+            else
+            {
+                String aStr;
+                pFCell->GetString(aStr);
+                ScStringToken aToken(aStr);
+                return aToken.Clone();
+            }
+        }
+        break;
+        default:
+            DBG_ERROR("attempted to convert an unknown cell type.");
+    }
+
+    return NULL;
+}
+
+static ScTokenArray* lcl_convertToTokenArray(ScDocument* pSrcDoc, const ScRange& rRange)
+{
+    const ScAddress& s = rRange.aStart;
+    const ScAddress& e = rRange.aEnd;
+
+    SCTAB nTab1 = s.Tab(), nTab2 = e.Tab();
+    SCCOL nCol1 = s.Col(), nCol2 = e.Col();
+    SCROW nRow1 = s.Row(), nRow2 = e.Row();
+
+    auto_ptr<ScTokenArray> pArray(new ScTokenArray);
+    bool bFirstTab = true;
+    for (SCTAB nTab = nTab1; nTab <= nTab2; ++nTab)
+    {
+        ScMatrixRef xMat = new ScMatrix(
+            static_cast<SCSIZE>(nCol2-nCol1+1),
+            static_cast<SCSIZE>(nRow2-nRow1+1));
+
+        for (SCCOL nCol = nCol1; nCol <= nCol2; ++nCol)
+        {
+            for (SCROW nRow = nRow1; nRow <= nRow2; ++nRow)
+            {
+                SCSIZE nC = nCol - nCol1, nR = nRow - nRow1;
+                ScBaseCell* pCell;
+                pSrcDoc->GetCell(nCol, nRow, nTab, pCell);
+                if (pCell)
+                {
+                    switch (pCell->GetCellType())
+                    {
+                        case CELLTYPE_STRING:
+                        {
+                            String aStr;
+                            static_cast<ScStringCell*>(pCell)->GetString(aStr);
+                            xMat->PutString(aStr, nC, nR);
+                        }
+                        break;
+                        case CELLTYPE_VALUE:
+                        {
+                            double fVal = static_cast<ScValueCell*>(pCell)->GetValue();
+                            xMat->PutDouble(fVal, nC, nR);
+                        }
+                        break;
+                        case CELLTYPE_FORMULA:
+                        {
+                            ScFormulaCell* pFCell = static_cast<ScFormulaCell*>(pCell);
+                            if (pFCell->IsValue())
+                            {
+                                double fVal = pFCell->GetValue();
+                                xMat->PutDouble(fVal, nC, nR);
+                            }
+                            else
+                            {
+                                String aStr;
+                                pFCell->GetString(aStr);
+                                xMat->PutString(aStr, nC, nR);
+                            }
+                        }
+                        break;
+                        default:
+                            DBG_ERROR("attempted to convert an unknown cell type.");
+                    }
+                }
+                else
+                {
+                    xMat->PutEmpty(nC, nR);
+                }
+            }
+        }
+        if (!bFirstTab)
+            pArray->AddOpCode(ocSep);
+
+        ScMatrix* pMat2 = xMat;
+        ScMatrixToken aToken(pMat2);
+        pArray->AddToken(aToken);
+
+        bFirstTab = false;
+    }
+    return pArray.release();
+}
+
+ScExternalRefManager::ScExternalRefManager(ScDocument* pDoc) :
+    mpDoc(pDoc)
+{
+    maSrcDocTimer.SetTimeoutHdl( LINK(this, ScExternalRefManager, TimeOutHdl) );
+    maSrcDocTimer.SetTimeout(SRCDOC_SCAN_INTERVAL);
+}
+
+ScExternalRefManager::~ScExternalRefManager()
+{
+    clear();
+}
+
+ScToken* ScExternalRefManager::getSingleRefToken(sal_uInt16 nFileId, const ScAddress& rCell, const ScAddress* pCurPos)
+{
+    if (pCurPos)
+        insertReferencingCell(nFileId, *pCurPos);
+    return getSingleRefToken(nFileId, rCell);
+}
+
+ScToken* ScExternalRefManager::getSingleRefToken(sal_uInt16 nFileId, const ScAddress& rCell)
+{
+    {
+        String aStr;
+        rCell.Format(aStr, SCA_ABS_3D);
+        const String *pFile = getExternalFileName(nFileId);
+        fprintf(stdout, "ScExternalRefManager::getSingleRefToken: --begin (file = '%s'; address = '%s')\n",
+                rtl::OUStringToOString(*pFile, RTL_TEXTENCODING_UTF8).getStr(),
+                rtl::OUStringToOString(aStr, RTL_TEXTENCODING_UTF8).getStr());
+    }
+
+    SingleTokenMap& rMap = getDocumentCache(nFileId)->maSingleTokens;
+    SingleTokenMap::iterator itr = rMap.find(rCell);
+    if (itr != rMap.end())
+    {
+        fprintf(stdout, "ScExternalRefManager::getSingleRefToken:   reference cached\n");
+        // this single reference is cached.
+        return itr->second.get();
+    }
+
+    // reference not cached.  read from the source document.
+    ScDocument* pSrcDoc = getSrcDocument(nFileId);
+    if (!pSrcDoc)
+        return NULL;
+
+    ScBaseCell* pCell = NULL;
+    pSrcDoc->GetCell(rCell.Col(), rCell.Row(), rCell.Tab(), pCell);
+    TokenRef pTok(lcl_convertToToken(pCell));
+
+    if (!pTok.get())
+    {
+        // Cell in the source document is probably empty.
+        pTok.reset(new ScEmptyCellToken(false, false));
+    }
+
+    rMap.insert(SingleTokenMap::value_type(rCell, pTok));
+    fprintf(stdout, "ScExternalRefManager::getSingleRefToken: --end\n");
+    return pTok.get();
+}
+
+ScTokenArray* ScExternalRefManager::getDoubleRefTokens(sal_uInt16 nFileId, const ScRange& rRange, const ScAddress* pCurPos)
+{
+    if (pCurPos)
+        insertReferencingCell(nFileId, *pCurPos);
+    return getDoubleRefTokens(nFileId, rRange);
+}
+
+ScTokenArray* ScExternalRefManager::getDoubleRefTokens(sal_uInt16 nFileId, const ScRange& rRange)
+{
+    {
+        String aStr;
+        rRange.Format(aStr, SCR_ABS_3D, mpDoc);
+        const String *pFile = getExternalFileName(nFileId);
+        fprintf(stdout, "ScExternalRefManager::getDoubleRefToken: --begin (file = '%s'; range = '%s)\n",
+                rtl::OUStringToOString(*pFile, RTL_TEXTENCODING_UTF8).getStr(), 
+                rtl::OUStringToOString(aStr, RTL_TEXTENCODING_UTF8).getStr());
+    }
+
+    DoubleTokenMap& rMap = getDocumentCache(nFileId)->maDoubleTokens;
+    DoubleTokenMap::iterator itr = rMap.find(rRange);
+    if (itr != rMap.end())
+    {
+        fprintf(stdout, "ScExternalRefManager::getDoubleRefToken:   range reference cached\n");
+        // this range reference is cached.
+        return itr->second.get();
+    }
+
+    // reference not cached.  read from the source document.
+    ScDocument* pSrcDoc = getSrcDocument(nFileId);
+    if (!pSrcDoc)
+        return NULL;
+
+    TokenArrayRef pArray(lcl_convertToTokenArray(pSrcDoc, rRange));
+    if (!pArray.get())
+    {
+        // highly unlikely since lcl_convertToTokenArray never returns NULL.
+        fprintf(stdout, "ScExternalRefManager::getDoubleRefToken: --end (NULL)\n");
+        return NULL;
+    }
+
+    rMap.insert(DoubleTokenMap::value_type(rRange, pArray));
+    fprintf(stdout, "ScExternalRefManager::getDoubleRefToken: --end\n");
+    return pArray.get();
+}
+
+ScTokenArray* ScExternalRefManager::getRangeNameTokens(sal_uInt16 nFileId, const String& rName, const ScAddress* pCurPos)
+{
+    if (pCurPos)
+    {
+        String aCellStr;
+        pCurPos->Format(aCellStr, SCA_ABS_3D);
+        const String* pFile = getExternalFileName(nFileId);
+        fprintf(stdout, "ScExternalRefManager::getRangeNameTokens: --begin (file = '%s' [%d]; name = '%s'; pos = '%s')\n",
+                rtl::OUStringToOString(*pFile, RTL_TEXTENCODING_UTF8).getStr(),
+                nFileId,
+                rtl::OUStringToOString(rName, RTL_TEXTENCODING_UTF8).getStr(),
+                rtl::OUStringToOString(aCellStr, RTL_TEXTENCODING_UTF8).getStr());
+    }
+
+    if (pCurPos)
+        insertReferencingCell(nFileId, *pCurPos);
+
+    // First, check if this name has already been cached.
+    RangeNameMap& rMap = getDocumentCache(nFileId)->maRangeNames;
+    RangeNameMap::iterator itr = rMap.find(rName);
+    if (itr != rMap.end())
+    {
+        fprintf(stdout, "ScExternalRefManager::getRangeNameTokens:   name is cached\n");
+        // this name is cached.
+        return itr->second.get();
+    }
+
+    ScDocument* pSrcDoc = getSrcDocument(nFileId);
+    if (!pSrcDoc)
+        return NULL;
+
+    ScRangeName* pExtNames = pSrcDoc->GetRangeName();
+    String aUpperName = ScGlobal::pCharClass->upper(rName);
+    USHORT n;
+    bool bRes = pExtNames->SearchNameUpper(aUpperName, n);
+    if (!bRes)
+        return NULL;
+
+    ScRangeData* pRangeData = (*pExtNames)[n];
+    if (!pRangeData)
+        return NULL;
+
+    // Parse all tokens in this external range data, and replace each absolute 
+    // reference token with an external reference token, and cache them.  Also
+    // register the source document with the link manager if it's a new
+    // source.
+
+    TokenArrayRef pNew(new ScTokenArray);
+
+    ScTokenArray* pCode = pRangeData->GetCode();
+    for (ScToken* pToken = pCode->First(); pToken; pToken = pCode->Next())
+    {
+        bool bTokenAdded = false;
+        switch (pToken->GetType())
+        {
+            case svSingleRef:
+            {
+                fprintf(stdout, "ScDocument::FindExternalRangeName:   single ref\n");
+                ScExternalSingleRefToken aNewToken(nFileId, pToken->GetSingleRef());
+                pNew->AddToken(aNewToken);
+                bTokenAdded = true;
+            }
+            break;
+            case svDoubleRef:
+            {
+                fprintf(stdout, "ScDocument::FindExternalRangeName:   double ref\n");
+                ScExternalDoubleRefToken aNewToken(nFileId, pToken->GetDoubleRef());
+                pNew->AddToken(aNewToken);
+                bTokenAdded = true;
+            }
+            break;
+        }
+        
+        if (!bTokenAdded)
+            pNew->AddToken(*pToken);
+    }
+
+    rMap.insert(RangeNameMap::value_type(rName, pNew));
+    fprintf(stdout, "ScExternalRefManager::getRangeNameTokens: --end\n");
+    return pNew.get();
+}
+
+void ScExternalRefManager::refreshAllReferencingCells(sal_uInt16 nFileId)
+{
+    fprintf(stdout, "ScExternalRefManager::refreshAllReferencingCells: --begin\n");
+    RefCellMap::iterator itr = maRefCells.find(nFileId);
+    if (itr == maRefCells.end())
+    {
+        const String* pFile = getExternalFileName(nFileId);
+        fprintf(stdout, "ScExternalRefManager::refreshAllReferencingCells:   no referencing cells for names from '%s'\n",
+                rtl::OUStringToOString(*pFile, RTL_TEXTENCODING_UTF8).getStr());
+        return;
+    }
+
+    RefCellSet aNewSet;
+    RefCellSet& rSet = itr->second;
+    RefCellSet::const_iterator itrSet = rSet.begin(), itrSetEnd = rSet.end();
+    for (; itrSet != itrSetEnd; ++itrSet)
+    {
+        if (compileTokensByCell(*itrSet))
+            // Cell still contains an external name/ref token.
+            aNewSet.insert(*itrSet);
+    }
+    rSet.swap(aNewSet);
+
+    ScViewData* pViewData = ScDocShell::GetViewData();
+    if (!pViewData)
+        return;
+
+    ScTabViewShell* pVShell = pViewData->GetViewShell();
+    if (!pVShell)
+        return;
+
+    // Repainting the grid also repaints the texts, but is there a better way
+    // to refresh texts?
+    pVShell->Invalidate(FID_TAB_TOGGLE_GRID);
+    pVShell->PaintGrid();
+}
+
+void ScExternalRefManager::insertReferencingCell(sal_uInt16 nFileId, const ScAddress& rCell)
+{
+    RefCellMap::iterator itr = maRefCells.find(nFileId);
+    if (itr != maRefCells.end())
+    {
+        itr->second.insert(rCell);
+        return;
+    }
+
+    RefCellSet aSet;
+    aSet.insert(rCell);
+    maRefCells.insert(RefCellMap::value_type(nFileId, aSet));
+}
+
+ScExternalRefManager::DocCache* ScExternalRefManager::getDocumentCache(
+    sal_uInt16 nFileId)
+{
+    DocCacheMap::iterator itr = maCachedDocContents.find(nFileId);
+    if (itr != maCachedDocContents.end())
+        return itr->second.get();
+
+    DocCacheRef pCache(new DocCache);
+    maCachedDocContents.insert(DocCacheMap::value_type(nFileId, pCache));
+    return pCache.get();
+}
+
+ScDocument* ScExternalRefManager::getSrcDocument(sal_uInt16 nFileId)
+{
+    DocShellMap::iterator itrEnd = maDocShells.end();
+    DocShellMap::iterator itr = maDocShells.find(nFileId);
+
+    if (itr != itrEnd)
+    {
+        SfxObjectShell* p = itr->second.maShell;
+        itr->second.maLastAccess = Time();
+        return static_cast<ScDocShell*>(p)->GetDocument();
+    }
+
+    const String* pFile = getExternalFileName(nFileId);
+    if (!pFile)
+    {
+        fprintf(stdout, "ScExternalRefManager::getSrcDocument:   no file name associated with the ID of %d\n", nFileId);
+        return NULL;
+    }
+
+    fprintf(stdout, "ScExternalRefManager::getSourceDocument:   file not found: '%s'\n",
+            rtl::OUStringToOString(*pFile, RTL_TEXTENCODING_UTF8).getStr());
+
+    String aFilter;
+    SrcDoc aSrcDoc;
+    aSrcDoc.maShell = loadSrcDocument(*pFile, aFilter);
+    if (maDocShells.empty())
+    {
+        // If this is the first source document insertion, start up the timer.
+        maSrcDocTimer.Start();
+    }
+
+    maDocShells.insert(DocShellMap::value_type(nFileId, aSrcDoc));
+    if (!maLinkedDocs.count(nFileId))
+    {
+        // Source document not linked yet.  Link it now.
+        insertExternalFileLink(nFileId, aFilter);
+        maLinkedDocs.insert(nFileId);
+    }
+    SfxObjectShell* p = aSrcDoc.maShell;
+    ScDocument* pSrcDoc = static_cast<ScDocShell*>(p)->GetDocument();
+
+    // Store all its table names.  Excel exporter needs this info.
+    vector<String> aTableNames;
+    SCTAB nCount = pSrcDoc->GetTableCount();
+    aTableNames.reserve(nCount);
+    for (SCTAB i = 0; i < nCount; ++i)
+    {
+        String aTabName;
+        pSrcDoc->GetName(i, aTabName);
+        aTableNames.push_back(aTabName);
+    }
+    DocCache* pCache = getDocumentCache(nFileId);
+    pCache->maTableNames.swap(aTableNames);
+
+    return pSrcDoc;
+}
+
+SfxObjectShellRef ScExternalRefManager::loadSrcDocument(const String& rFile, String& rFilter)
+{
+    String aOptions;
+    ScDocumentLoader::GetFilterName(rFile, rFilter, aOptions, true, false);
+    const SfxFilter* pFilter = ScDocShell::Factory().GetFilterContainer()->GetFilter4FilterName(rFilter);
+
+    SfxItemSet* pSet = new SfxAllItemSet(SFX_APP()->GetPool());
+    if (aOptions.Len())
+        pSet->Put(SfxStringItem(SID_FILE_FILTEROPTIONS, aOptions));
+
+    auto_ptr<SfxMedium> pMedium(new SfxMedium(rFile, STREAM_STD_READ, FALSE, pFilter, pSet));
+    if (pMedium->GetError() != ERRCODE_NONE)
+        return NULL;
+
+    pMedium->UseInteractionHandler(false);
+
+    ScDocShell* pNewShell = new ScDocShell(SFX_CREATE_MODE_INTERNAL);
+    SfxObjectShellRef aRef = pNewShell;
+
+    // increment the recursive link count of the source document.
+    ScExtDocOptions* pExtOpt = mpDoc->GetExtDocOptions();
+    sal_uInt32 nLinkCount = pExtOpt ? pExtOpt->GetDocSettings().mnLinkCnt : 0;
+    ScDocument* pSrcDoc = pNewShell->GetDocument();
+    ScExtDocOptions* pExtOptNew = pSrcDoc->GetExtDocOptions();
+    if (!pExtOptNew)
+    {
+        pExtOptNew = new ScExtDocOptions;
+        pSrcDoc->SetExtDocOptions(pExtOptNew);
+    }
+    pExtOptNew->GetDocSettings().mnLinkCnt = nLinkCount + 1;
+
+    pNewShell->DoLoad(pMedium.release());
+    return aRef;
+}
+
+void ScExternalRefManager::insertExternalFileLink(sal_uInt16 nFileId, const String& rFilterName)
+{
+    SvxLinkManager* pLinkMgr = mpDoc->GetLinkManager();
+    ScExternalRefLink* pLink = new ScExternalRefLink(mpDoc, nFileId, rFilterName);
+    const String* pFileName = getExternalFileName(nFileId);
+    DBG_ASSERT(pFileName, "ScExternalRefManager::insertExternalFileLink: file name pointer is NULL");
+    pLinkMgr->InsertFileLink(*pLink, OBJECT_CLIENT_FILE, *pFileName, &rFilterName);
+
+    pLink->SetDoReferesh(false);
+    pLink->Update();
+    pLink->SetDoReferesh(true);
+}
+
+bool ScExternalRefManager::compileTokensByCell(const ScAddress& rCell)
+{
+    String aStr;
+    rCell.Format(aStr, SCA_ABS_3D);
+    fprintf(stdout, "ScExternalRefManager::compileTokensByCell: --begin (cell = '%s')\n", 
+            rtl::OUStringToOString(aStr, RTL_TEXTENCODING_UTF8).getStr());
+
+    ScBaseCell* pCell;
+    mpDoc->GetCell(rCell.Col(), rCell.Row(), rCell.Tab(), pCell);
+
+    if (!pCell || pCell->GetCellType() != CELLTYPE_FORMULA)
+    {
+        fprintf(stdout, "ScExternalRefManager::compileTokensByCell: --end (not a valid formula cell)\n");
+        return false;
+    }
+
+    ScFormulaCell* pFC = static_cast<ScFormulaCell*>(pCell);
+
+    // Check to make sure the cell really contains ocExternalName.
+    bool bCompile = false;
+    ScTokenArray* pCode = pFC->GetCode();
+    pCode->Reset();
+    for (ScToken* p = pCode->First(); p; p = pCode->Next())
+    {
+        // TODO: once we have implemented a new token for the external
+        // references, we will also query for that token type.
+        if (p->GetOpCode() == ocExternalName)
+        {
+            bCompile = true;
+            break;
+        }
+    }
+    if (!bCompile)
+    {
+        fprintf(stdout, "ScExternalRefManager::compileTokensByCell: --end (cell doesn't contain any external name)\n");
+        return false;
+    }
+
+    pFC->SetCompile(true);
+    pFC->CompileTokenArray();
+    pFC->SetDirty();
+
+    fprintf(stdout, "ScExternalRefManager::compileTokensByCell: --end (cell re-compiled)\n");
+    return true;
+}
+
+sal_uInt16 ScExternalRefManager::getExternalFileId(const String& rFile)
+{
+    using namespace std;
+
+    vector<String>::const_iterator itrBeg = maFileNames.begin(), itrEnd = maFileNames.end();
+    vector<String>::const_iterator itr = find(itrBeg, itrEnd, rFile);
+    if (itr != itrEnd)
+    {
+        size_t nId = distance(itrBeg, itr);
+        return static_cast<sal_uInt16>(nId);
+    }
+
+    maFileNames.push_back(rFile);
+    return static_cast<sal_uInt16>(maFileNames.size() - 1);
+}
+
+const String* ScExternalRefManager::getExternalFileName(sal_uInt16 nFileId) const
+{
+    if (nFileId >= maFileNames.size())
+        return NULL;
+
+    return &maFileNames[nFileId];
+}
+
+const String* ScExternalRefManager::getExternalTableName(sal_uInt16 nFileId, SCTAB nTabId)
+{
+    if (nFileId >= maFileNames.size())
+        return NULL;
+
+    DocCache* pCache = getDocumentCache(nFileId);
+    if (nTabId >= pCache->maTableNames.size())
+        return NULL;
+
+    return &pCache->maTableNames[nTabId];
+}
+
+template<typename MapContainer>
+static void lcl_removeByFileId(sal_uInt16 nFileId, MapContainer& rMap)
+{
+    typename MapContainer::iterator itr = rMap.find(nFileId);
+    if (itr != rMap.end())
+        rMap.erase(itr);
+}
+
+void ScExternalRefManager::refreshNames(sal_uInt16 nFileId)
+{
+    fprintf(stdout, "ScExternalRefManager::refreshNames: --begin\n");
+
+    removeSrcDocument(nFileId, false);
+
+    // Update all cells containing names from this source document.
+    refreshAllReferencingCells(nFileId);
+    fprintf(stdout, "ScExternalRefManager::refreshNames: --end\n");
+}
+
+void ScExternalRefManager::switchSrcFile(sal_uInt16 nFileId, const String& rNewFile)
+{
+    const String* pOldFile = getExternalFileName(nFileId);
+    fprintf(stdout, "ScExternalRefManager::switchSrcFile: --begin (old file = '%s'; new file = '%s')\n",
+            rtl::OUStringToOString(*pOldFile, RTL_TEXTENCODING_UTF8).getStr(), 
+            rtl::OUStringToOString(rNewFile, RTL_TEXTENCODING_UTF8).getStr());
+
+    maFileNames[nFileId] = rNewFile;
+    refreshNames(nFileId);
+}
+
+void ScExternalRefManager::removeSrcDocument(sal_uInt16 nFileId, bool bBreakLink)
+{
+    const String* pFile = getExternalFileName(nFileId);
+    if (pFile)
+    {
+        fprintf(stdout, "ScExternalRefManager::removeSrcFile: --begin (file = '%s')\n", 
+                rtl::OUStringToOString(*pFile, RTL_TEXTENCODING_UTF8).getStr());
+    }
+
+    lcl_removeByFileId(nFileId, maCachedDocContents);
+    lcl_removeByFileId(nFileId, maDocShells);
+
+    if (bBreakLink)
+        maLinkedDocs.erase(nFileId);
+
+    if (maDocShells.empty())
+        maSrcDocTimer.Stop();
+
+    fprintf(stdout, "ScExternalRefManager::removeSrcFile: --end\n");
+}
+
+void ScExternalRefManager::clear()
+{
+    DocShellMap::iterator itrEnd = maDocShells.end();
+    for (DocShellMap::iterator itr = maDocShells.begin(); itr != itrEnd; ++itr)
+        itr->second.maShell->DoClose();
+
+    maDocShells.clear();
+    maSrcDocTimer.Stop();
+}
+
+void ScExternalRefManager::purgeStaleSrcDocument(sal_Int32 nTimeOut)
+{
+    DocShellMap aNewDocShells;
+    DocShellMap::iterator itr = maDocShells.begin(), itrEnd = maDocShells.end();
+    for (; itr != itrEnd; ++itr)
+    {
+        // in 100th of a second.
+        sal_Int32 nSinceLastAccess = (Time() - itr->second.maLastAccess).GetTime(); 
+//      const String* pStr = getExternalFileName(itr->first);
+//      if (pStr)
+//          fprintf(stdout, "ScExternalRefManager::purgeStaleSrcDocument:   file = '%s'; since last access = %ld\n",
+//                  rtl::OUStringToOString(*pStr, RTL_TEXTENCODING_UTF8).getStr(), nSinceLastAccess);
+
+        if (nSinceLastAccess < nTimeOut)
+            aNewDocShells.insert(*itr);
+    }
+    maDocShells.swap(aNewDocShells);
+
+    if (maDocShells.empty())
+        maSrcDocTimer.Stop();
+}
+
+IMPL_LINK(ScExternalRefManager, TimeOutHdl, AutoTimer*, pTimer)
+{
+    if (pTimer == &maSrcDocTimer)
+        purgeStaleSrcDocument(SRCDOC_LIFE_SPAN);
+
+    return 0;
+}
+
diff --git sc/source/ui/docshell/makefile.mk sc/source/ui/docshell/makefile.mk
index db83fec..6286dfb 100644
--- sc/source/ui/docshell/makefile.mk
+++ sc/source/ui/docshell/makefile.mk
@@ -53,6 +53,7 @@ CXXFILES = \
         docsh6.cxx 	\
         docsh7.cxx 	\
         docsh8.cxx 	\
+        externalrefmgr.cxx \
         tablink.cxx 	\
         arealink.cxx 	\
         dbdocfun.cxx 	\
@@ -79,6 +80,7 @@ SLOFILES =  \
         $(SLO)$/docsh6.obj   	\
         $(SLO)$/docsh7.obj   	\
         $(SLO)$/docsh8.obj   	\
+        $(SLO)$/externalrefmgr.obj \
         $(SLO)$/tablink.obj   	\
         $(SLO)$/arealink.obj   	\
         $(SLO)$/dbdocfun.obj 	\
@@ -101,6 +103,7 @@ EXCEPTIONSFILES= \
         $(SLO)$/docsh3.obj	\
         $(SLO)$/docsh4.obj \
         $(SLO)$/docsh8.obj \
+        $(SLO)$/externalrefmgr.obj \
         $(SLO)$/dbdocimp.obj
 
 SRS1NAME=$(TARGET)
@@ -117,6 +120,7 @@ LIB1OBJFILES =  \
         $(SLO)$/docsh6.obj   	\
         $(SLO)$/docsh7.obj   	\
         $(SLO)$/docsh8.obj   	\
+        $(SLO)$/externalrefmgr.obj \
         $(SLO)$/tablink.obj   	\
         $(SLO)$/arealink.obj   	\
         $(SLO)$/dbdocfun.obj 	\
