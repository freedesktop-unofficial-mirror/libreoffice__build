--- basic/source/inc/token.hxx.orig	2008-07-25 14:36:01.000000000 +0800
+++ basic/source/inc/token.hxx	2008-07-25 15:38:51.000000000 +0800
@@ -162,6 +162,10 @@ public:
 		{ return BOOL( t >= FIRSTKWD && t <= LASTKWD ); }
 	static BOOL IsExtra( SbiToken t )
 		{ return BOOL( t >= FIRSTEXTRA ); }
+
+    // process somthing like dim Name as String
+	virtual BOOL IsSymbol( SbiToken )
+        { return FALSE; }
 };
 
 
--- basic/source/inc/parser.hxx.orig	2008-07-25 15:00:25.000000000 +0800
+++ basic/source/inc/parser.hxx	2008-07-28 14:28:36.000000000 +0800
@@ -40,6 +40,7 @@
 typedef ::std::vector< String > IfaceVector;
 
 struct SbiParseStack;
+struct SbiStatement;
 
 class SbiParser : public SbiTokenizer
 {
@@ -53,6 +54,7 @@ class SbiParser : public SbiTokenizer
 	BOOL		bGblDefs; 			// TRUE globale Definitionen allgemein
 	BOOL		bNewGblDefs; 		// TRUE globale Definitionen vor Sub
 	BOOL		bSingleLineIf; 		// TRUE einzeiliges if-Statement
+	SbiStatement* pCurStat;
 
 	SbiSymDef*  VarDecl( SbiDimList**,BOOL,BOOL );// Variablen-Deklaration
 	SbiProcDef* ProcDecl(BOOL bDecl);// Prozedur-Deklaration
@@ -100,6 +102,7 @@ public:
 	BOOL TestSymbol( BOOL=FALSE );	// Symbol?
 	BOOL TestComma();				// Komma oder EOLN?
 	void TestEoln();				// EOLN?
+	virtual BOOL IsSymbol( SbiToken t ); // Process something like DIM Name as String
 
 	void Symbol();					// Let oder Call
 	void ErrorStmnt(); 				// ERROR n
--- basic/source/comp/token.cxx.orig	2008-07-25 15:35:11.000000000 +0800
+++ basic/source/comp/token.cxx	2008-07-28 15:11:31.000000000 +0800
@@ -538,6 +538,12 @@ SbiToken SbiTokenizer::Next()
 		return eCurTok = SYMBOL;
 	}
 special:
+	// check whether the keyword has been dim as a variable
+	if( IsSymbol( tp->t ) )
+	{
+		return eCurTok = SYMBOL;
+	}
+	
 	// LINE INPUT
 	if( tp->t == LINE )
 	{
--- basic/source/comp/parser.cxx.orig	2008-07-25 15:03:41.000000000 +0800
+++ basic/source/comp/parser.cxx	2008-07-28 15:23:32.000000000 +0800
@@ -138,6 +138,7 @@ SbiParser::SbiParser( StarBASIC* pb, SbM
 	pProc    = NULL;
 	pStack   = NULL;
 	pWithVar = NULL;
+	pCurStat = NULL;
 	nBase	 = 0;
 	bText	 =
 	bGblDefs =
@@ -308,6 +309,24 @@ void SbiParser::TestEoln()
 	}
 }
 
+// If some keywords e.g. Name have been dim as a variable, 
+// they should be treated as symbol
+BOOL SbiParser::IsSymbol( SbiToken t )
+{
+	// FIXME: if "name" is a argument in a subroutine like "Sub Test( name as String )".
+	if( t == NAME && pCurStat && 
+		( pCurStat->eTok == DIM || pCurStat->eTok == PUBLIC ||
+		  pCurStat->eTok == PRIVATE || pCurStat->eTok == GLOBAL	) )
+	{
+		return TRUE;
+	}
+    if( t == NAME && pPool->Find(aSym) )
+    {
+        return TRUE;
+    }
+    return FALSE;
+}
+
 // Parsing eines Statement-Blocks
 // Das Parsing laeuft bis zum Ende-Token.
 
@@ -431,7 +450,9 @@ BOOL SbiParser::Parse()
 				if( ( p->bSubr && (eCurTok != STATIC || Peek() == SUB || Peek() == FUNCTION ) ) ||
 						eCurTok == SUB || eCurTok == FUNCTION )
 					aGen.Statement();
+				pCurStat = p;	
 				(this->*( p->Func ) )();
+				pCurStat = NULL;
 				SbxError nSbxErr = SbxBase::GetError();
 				if( nSbxErr )
 					SbxBase::ResetError(), Error( (SbError)nSbxErr );
