diff -r 8f725fa6b136 basic/source/classes/image.cxx
--- a/basic/source/classes/image.cxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/classes/image.cxx	Fri Apr 23 16:35:00 2010 +0100
@@ -34,6 +34,47 @@
 #include <string.h>		// memset() etc
 #include "image.hxx"
 #include <codegen.hxx>
+
+ProcRefHandler::ProcRefHandler( const String& procName ) : m_sName( procName ), m_nOffsetGen( 0 )
+{
+}
+
+UINT32 
+ProcRefHandler::getProcRefOffset( UINT32 nOp )
+{
+    INT32ToINT32::iterator it = mOpToOffsetMap.find( nOp );
+    if ( it == mOpToOffsetMap.end() )
+    {
+        // generate Offset
+        INT32 nOff =  m_nOffsetGen++; 
+        mOpToOffsetMap[ nOp ] = nOff;
+        mOffsetToOp[ nOff ] = nOp;
+        return nOff;
+    }
+    return it->second;
+}
+
+UINT32 
+ProcRefHandler::getIdForProcRefOffset( UINT32 nOffset )
+{
+    return mOffsetToOp[ nOffset ];
+}
+
+ProcRefHandler* SbiImage::GetProcRef( const String& rProcName )
+{
+    ProcRefHandler* pHandler = NULL;
+    vProcRefHandlers::iterator it_end = m_vPropRefHandlers.end();
+    for ( vProcRefHandlers::iterator it = m_vPropRefHandlers.begin(); it != it_end; ++it )
+    {
+        if ( it->getName() == rProcName )
+        {
+            pHandler = &(*it);
+            break;
+        }
+    }
+    return pHandler;
+}
+
 SbiImage::SbiImage()
 {
 	pStringOff = NULL;
diff -r 8f725fa6b136 basic/source/comp/codegen.cxx
--- a/basic/source/comp/codegen.cxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/comp/codegen.cxx	Fri Apr 23 16:35:00 2010 +0100
@@ -324,7 +324,8 @@
 	nCount = pParser->rEnumArray->Count();
 	for (i = 0; i < nCount; i++)
 		 p->AddEnum((SbxObject *)pParser->rEnumArray->Get(i));
-
+        // Set up local ref offsets for string ids
+        p->SetProcRefs( pParser->GetProcRefs() );
 	if( !p->IsError() )
 		rMod.pImage = p;
 	else
diff -r 8f725fa6b136 basic/source/comp/dim.cxx
--- a/basic/source/comp/dim.cxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/comp/dim.cxx	Fri Apr 23 16:35:00 2010 +0100
@@ -347,10 +347,14 @@
 								nGblChain = 0;
 								bGblDefs = bNewGblDefs = TRUE;
 								break;
-				default:		eOp2 = _LOCAL;
+                default:		
+                                        eOp2 = _LOCAL; 
 			}
+		INT32 nId = pDef->GetId();
+		if ( eOp2 == _LOCAL )
+			nId = GetProcRefOffset( pProc, pDef->GetId() );
 			aGen.Gen(
-                eOp2, pDef->GetId(),
+                eOp2, nId,
                 sal::static_int_cast< UINT16 >( pDef->GetType() ) );
 		}
 
diff -r 8f725fa6b136 basic/source/comp/exprgen.cxx
--- a/basic/source/comp/exprgen.cxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/comp/exprgen.cxx	Fri Apr 23 16:35:00 2010 +0100
@@ -105,7 +105,9 @@
 				 		bTreatFunctionAsParam = false;
 				}
 				if( !bTreatFunctionAsParam )
+                                {
 					eOp = aVar.pDef->IsGlobal() ? _FIND_G : _FIND;
+                                }
 			}
         }
 		// AB: 17.12.1995, Spezialbehandlung fuer WITH
@@ -123,10 +125,9 @@
                 eOp = ( aVar.pDef->GetScope() == SbRTL ) ? _RTL : 
                     (aVar.pDef->IsGlobal() ? _FIND_G : _FIND);
 		}
-
 		if( eOp == _FIND )
 		{
-	
+
 			SbiProcDef* pProc = aVar.pDef->GetProcDef();
 			if ( pGen->GetParser()->bClassModule )
 				eOp = _FIND_CM;
@@ -134,6 +135,10 @@
 			{
 				eOp = _FIND_STATIC;
 			}
+            if ( eOp == _FIND_STATIC || eOp == _FIND_CM || eOp == _FIND )
+            {
+                aVar.pDef->nLocalIndex = pGen->GetParser()->GetProcRefOffset( pGen->GetParser()->GetProc(), aVar.pDef->GetId() );
+            }
 		}
 		for( SbiExprNode* p = this; p; p = p->aVar.pNext )
 		{
@@ -168,7 +173,7 @@
 void SbiExprNode::GenElement( SbiOpcode eOp )
 {
 #ifdef DBG_UTIL
-	if( (eOp < _RTL || eOp > _CALLC) && eOp != _FIND_G && eOp != _FIND_CM )
+	if( ( eOp < _RTL || eOp > _CALLC) && eOp != _FIND_G && eOp != _FIND_CM )
 		pGen->GetParser()->Error( SbERR_INTERNAL_ERROR, "Opcode" );
 #endif
 	SbiSymDef* pDef = aVar.pDef;
@@ -176,6 +181,9 @@
 	// Falls das Bit 0x8000 gesetzt ist, hat die Variable
 	// eine Parameterliste.
 	USHORT nId = ( eOp == _PARAM ) ? pDef->GetPos() : pDef->GetId();
+        if ( eOp == _FIND_STATIC || eOp == _FIND_CM || eOp == _FIND )
+            nId = aVar.pDef->nLocalIndex ;
+
 	// Parameterliste aufbauen
 	if( aVar.pPar && aVar.pPar->GetSize() )
 	{
@@ -194,7 +202,7 @@
 		if( pProc->GetAlias().Len() )
 			nId = ( nId & 0x8000 ) | pGen->GetParser()->aGblStrings.Add( pProc->GetAlias() );
 	}
-	pGen->Gen( eOp, nId, sal::static_int_cast< UINT16 >( GetType() ) );
+        pGen->Gen( eOp, nId, sal::static_int_cast< UINT16 >( GetType() ) );
 
 	if( aVar.pvMorePar )
 	{
diff -r 8f725fa6b136 basic/source/comp/parser.cxx
--- a/basic/source/comp/parser.cxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/comp/parser.cxx	Fri Apr 23 16:35:00 2010 +0100
@@ -118,6 +118,27 @@
 // 'this' : used in base member initializer list
 #pragma warning( disable: 4355 )
 #endif
+
+UINT32 SbiParser::GetProcRefOffset( SbiProcDef* pProcedure, INT32 nOp )
+{
+    INT32 nOffset = 0;
+    // find the ProcRefHandler for Procedure
+	// no procedure means initialization code, just give then a empty procedure name
+        String pName;
+	if ( pProcedure )
+		pName = pProcedure->GetName();
+    vProcRefHandlers::iterator it_end = m_vPropRefHandlers.end();
+    for ( vProcRefHandlers::iterator it = m_vPropRefHandlers.begin(); it != it_end; ++it )
+    {
+        if ( it->getName() == pName )
+            return it->getProcRefOffset( nOp );
+    }
+    // not found create new ProcRefHandler for pProc
+    ProcRefHandler procOffsets( pName );
+    nOffset = procOffsets.getProcRefOffset( nOp );
+    m_vPropRefHandlers.push_back( procOffsets );
+    return  nOffset;
+}
 
 SbiParser::SbiParser( StarBASIC* pb, SbModule* pm )
 		: SbiTokenizer( pm->GetSource32(), pb ),
diff -r 8f725fa6b136 basic/source/comp/symtbl.cxx
--- a/basic/source/comp/symtbl.cxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/comp/symtbl.cxx	Fri Apr 23 16:35:00 2010 +0100
@@ -306,6 +306,7 @@
 	pIn		 =
 	pPool	 = NULL;
 	nDefaultId = 0;
+    nLocalIndex = 0;
 }
 
 SbiSymDef::~SbiSymDef()
@@ -410,7 +411,7 @@
 		 : SbiSymDef( rName )
 		 , aParams( pParser->aGblStrings, SbPARAM )  // wird gedumpt
 		 , aLabels( pParser->aLclStrings, SbLOCAL )	 // wird nicht gedumpt
-		 , mbProcDecl( bProcDecl )
+         , mbProcDecl( bProcDecl )
 {
 	aParams.SetParent( &pParser->aPublics );
 	pPool = new SbiSymPool( pParser->aGblStrings, SbLOCAL ); // Locals
diff -r 8f725fa6b136 basic/source/inc/image.hxx
--- a/basic/source/inc/image.hxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/inc/image.hxx	Fri Apr 23 16:35:00 2010 +0100
@@ -33,11 +33,31 @@
 #include <rtl/ustring.hxx>
 #endif
 #include <filefmt.hxx>
+#include <vector>
+#include <map>
 
 // Diese Klasse liest das vom Compiler erzeugte Image ein und verwaltet
 // den Zugriff auf die einzelnen Elemente.
 
 struct SbPublicEntry;
+
+typedef std::map< UINT32, UINT32 > INT32ToINT32;
+
+class ProcRefHandler
+{
+    INT32ToINT32 mOpToOffsetMap;
+    INT32ToINT32 mOffsetToOp;
+    String m_sName;
+    INT32 m_nOffsetGen;
+public:
+    ProcRefHandler( const String& procName );
+    UINT32 getProcRefOffset( UINT32 nOp );
+    UINT32 getIdForProcRefOffset( UINT32 nOffset );
+    String getName(){ return m_sName; }
+    INT32  getMaxOffset() { return  m_nOffsetGen; }
+};
+
+typedef std::vector< ProcRefHandler > vProcRefHandlers;
 
 class SbiImage {
 	friend class SbiCodeGen;			// Compiler-Klassen, die die private-
@@ -66,7 +86,10 @@
 	void AddType(SbxObject *);      // User-Type mit aufnehmen
 	void AddEnum(SbxObject *);      // Register enum type
 
+        vProcRefHandlers m_vPropRefHandlers;
 public:
+        void SetProcRefs( const vProcRefHandlers& rHandlers ) { m_vPropRefHandlers =  rHandlers; }
+        ProcRefHandler* GetProcRef( const String& rProcName );
 	String aName;					// Makroname
     ::rtl::OUString aOUSource;		// Quellcode
 	String aComment;				// Kommentar
diff -r 8f725fa6b136 basic/source/inc/parser.hxx
--- a/basic/source/inc/parser.hxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/inc/parser.hxx	Fri Apr 23 16:35:00 2010 +0100
@@ -34,14 +34,15 @@
 
 
 #include <vector>
+#include "image.hxx"
 typedef ::std::vector< String > IfaceVector;
 
 struct SbiParseStack;
-
 class SbiParser : public SbiTokenizer
 {
 	friend class SbiExpression;
-
+        vProcRefHandlers m_vPropRefHandlers;
+        
 	SbiParseStack* pStack;   		// Block-Stack
 	SbiProcDef* pProc;				// aktuelle Prozedur
 	SbiExprNode*  pWithVar;			// aktuelle With-Variable
@@ -66,6 +67,9 @@
 	void DefDeclare( BOOL bPrivate );
 	void EnableCompatibility();	
 public:
+        vProcRefHandlers& GetProcRefs() { return m_vPropRefHandlers; }
+        UINT32 GetProcRefOffset( SbiProcDef*, INT32 nOp );
+        SbiProcDef* GetProc() { return pProc;}	
 	SbxArrayRef	  rTypeArray;		// das Type-Array
 	SbxArrayRef	  rEnumArray;		// Enum types
 	SbiStringPool aGblStrings;		// der String-Pool
diff -r 8f725fa6b136 basic/source/inc/runtime.hxx
--- a/basic/source/inc/runtime.hxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/inc/runtime.hxx	Fri Apr 23 16:35:00 2010 +0100
@@ -306,6 +306,7 @@
 	String		  aLibName;			// Lib-Name fuer Declare-Call
 	SbxArrayRef   refParams;        // aktuelle Prozedur-Parameter
 	SbxArrayRef   refLocals;        // lokale Variable
+	std::vector< SbxVariableRef* >*  refLocalDefines;
 	SbxArrayRef   refArgv;          // aktueller Argv
 	// AB, 28.3.2000 #74254, Ein refSaveObj reicht nicht! Neu: pRefSaveList (s.u.)
 	//SbxVariableRef refSaveObj;      // #56368 Bei StepElem Referenz sichern
@@ -432,6 +433,7 @@
 	void StepDCREATE_REDIMP(UINT32,UINT32), StepDCREATE_IMPL(UINT32,UINT32);
 	void StepFIND_CM( UINT32, UINT32 );
 	void StepFIND_STATIC( UINT32, UINT32 );
+    void StepFINDLOCAL( UINT32, UINT32 );
 public:
 	void          SetVBAEnabled( bool bEnabled ) { bVBAEnabled = bEnabled; };
 	USHORT		GetImageFlag( USHORT n ) const;
diff -r 8f725fa6b136 basic/source/inc/symtbl.hxx
--- a/basic/source/inc/symtbl.hxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/inc/symtbl.hxx	Fri Apr 23 16:35:00 2010 +0100
@@ -134,6 +134,7 @@
 	BOOL	   bParamArray : 1;		// TRUE: ParamArray parameter
 	USHORT	   nDefaultId;			// Symbol number of default value
 public:
+    sal_Int32 nLocalIndex;
 	SbiSymDef( const String& );
 	virtual ~SbiSymDef();
 	virtual SbiProcDef* GetProcDef();
diff -r 8f725fa6b136 basic/source/runtime/runtime.cxx
--- a/basic/source/runtime/runtime.cxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/runtime/runtime.cxx	Fri Apr 23 16:35:00 2010 +0100
@@ -529,6 +529,7 @@
 	pRefSaveList = NULL;
 	pItemStoreList = NULL;
 	bVBAEnabled = isVBAEnabled();
+	refLocalDefines = NULL;
 }
 
 SbiRuntime::~SbiRuntime()
@@ -544,6 +545,18 @@
 		RefSaveItem* pToDeleteItem = pItemStoreList;
 		pItemStoreList = pToDeleteItem->pNext;
 		delete pToDeleteItem;
+	}
+        if ( refLocalDefines )
+	{
+		std::vector< SbxVariableRef* >::iterator it_end = refLocalDefines->end();
+		for ( std::vector< SbxVariableRef* >::iterator it = refLocalDefines->begin(); it!=it_end; ++it )
+		{
+			if ( (*it) )
+				delete (*it);
+		}
+		refLocalDefines->clear();
+		delete refLocalDefines;
+		refLocalDefines = NULL;
 	}
 }
 
diff -r 8f725fa6b136 basic/source/runtime/step2.cxx
--- a/basic/source/runtime/step2.cxx	Tue Apr 20 13:21:03 2010 +0100
+++ b/basic/source/runtime/step2.cxx	Fri Apr 23 16:35:00 2010 +0100
@@ -52,6 +52,17 @@
 using com::sun::star::uno::Reference;
 
 SbxVariable* getVBAConstant( const String& rName );
+void initRefDefines( SbiImage* pImage, SbMethod* pMeth, std::vector< SbxVariableRef* >*&  refLocalDefines )
+{
+    // pMeth == NULL ( means this is an initialisation routine running )
+    ProcRefHandler* pHandler = pImage->GetProcRef( pMeth ? pMeth->GetName() : String() );
+    if ( pHandler )
+    {
+	refLocalDefines = new std::vector< SbxVariableRef* >( pHandler->getMaxOffset() ); 	
+    }	
+    else
+       StarBASIC::FatalError( SbERR_INTERNAL_ERROR );
+}
 
 // Suchen eines Elements
 // Die Bits im String-ID:
@@ -60,14 +71,8 @@
 SbxVariable* SbiRuntime::FindElement
 	( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError nNotFound, BOOL bLocal, BOOL bStatic )
 {
-	bool bIsVBAInterOp = SbiRuntime::isVBAEnabled();
-	if( bIsVBAInterOp )
-	{
-		StarBASIC* pMSOMacroRuntimeLib = GetSbData()->pMSOMacroRuntimLib;
-		if( pMSOMacroRuntimeLib != NULL )
-			pMSOMacroRuntimeLib->ResetFlag( SBX_EXTSEARCH );
-	}
-
+	UINT32 nOffSet = nOp1;
+	ProcRefHandler* pHandler = NULL;
 	SbxVariable* pElem = NULL;
 	if( !pObj )
 	{
@@ -78,36 +83,64 @@
 	{
 		BOOL bFatalError = FALSE;
 		SbxDataType t = (SbxDataType) nOp2;
-		String aName( pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) ) );
-		// Hacky capture of Evaluate [] syntax
-		// this should be tackled I feel at the pcode level
-		if ( bIsVBAInterOp && aName.Search('[') == 0 )
-		{
-			// emulate pcode here
-			StepARGC();
-			// psuedo StepLOADSC
-			String sArg = aName.Copy( 1, aName.Len() - 2 );
-			SbxVariable* p = new SbxVariable;
-			p->PutString( sArg );
-			PushVar( p );
-			//
-			StepARGV();
-			nOp1 = nOp1 | 0x8000; // indicate params are present
-			aName = String::CreateFromAscii("Evaluate");
-		}
+		String aName;//( pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) ) );
+
 		if( bLocal )
 		{
-			if ( bStatic )
+			if ( bStatic && pMeth )
 			{	
-				if ( pMeth )
-					pElem = pMeth->GetStatics()->Find( aName, SbxCLASS_DONTCARE );
+				aName = pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) );
+				pElem = pMeth->GetStatics()->Find( aName, SbxCLASS_DONTCARE );
 			}
 
 			if ( !pElem )
-				pElem = refLocals->Find( aName, SbxCLASS_DONTCARE );
+			{
+				SbxVariableRef* pRef = (*refLocalDefines)[ nOp1 & 0x7FFF ];
+				if ( pRef )
+					pElem = *pRef;
+                                if ( !pElem ) // not locally defined
+				{
+					OSL_TRACE("here");
+					pHandler = pMod->pImage->GetProcRef( pMeth ? pMeth->GetName() : String() );
+					if ( pHandler )
+					{
+						bool bHasParams = false;
+						if ( nOp1 & 0x8000 )
+							bHasParams = true;
+						nOp1 = pHandler->getIdForProcRefOffset( nOp1 & 0x7FFF );
+						if ( bHasParams )
+							nOp1 = nOp1 | 0x8000;
+					}
+				}
+			}
 		}
+
+		if( bVBAEnabled )
+		{
+			StarBASIC* pMSOMacroRuntimeLib = GetSbData()->pMSOMacroRuntimLib;
+			if( pMSOMacroRuntimeLib != NULL )
+				pMSOMacroRuntimeLib->ResetFlag( SBX_EXTSEARCH );
+		}
+
 		if( !pElem )
 		{
+			aName = pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) );
+			// Hacky capture of Evaluate [] syntax
+			// this should be tackled I feel at the pcode level
+			if ( bVBAEnabled && aName.Len() && aName.GetBuffer()[0] == '[') 
+			{
+				// emulate pcode here
+				StepARGC();
+				// psuedo StepLOADSC
+				String sArg = aName.Copy( 1, aName.Len() - 2 );
+				SbxVariable* p = new SbxVariable;
+				p->PutString( sArg );
+				PushVar( p );
+				//
+				StepARGV();
+				nOp1 = nOp1 | 0x8000; // indicate params are present
+				aName = String::CreateFromAscii("Evaluate");
+			}
 			// Die RTL brauchen wir nicht mehr zu durchsuchen!
 			BOOL bSave = rBasic.bNoRtl;
 			rBasic.bNoRtl = TRUE;
@@ -168,7 +201,10 @@
 					// deklarierten Vars automatisch global !
 					if ( bSetName )
 						pElem->SetName( aName );
-					refLocals->Put( pElem, refLocals->Count() );
+					if ( bVBAEnabled )
+						( *refLocalDefines )[ nOffSet & 0x7FFF ] = new SbxVariableRef( pElem );
+					else
+						refLocals->Put( pElem, refLocals->Count() );
 				}
 			}
 
@@ -214,7 +250,10 @@
 						if( t != SbxVARIANT )
 							pElem->SetFlag( SBX_FIXED );
 						pElem->SetName( aName );
-						refLocals->Put( pElem, refLocals->Count() );
+						if ( bVBAEnabled )
+							( *refLocalDefines )[ nOffSet & 0x7FFF ] = new SbxVariableRef( pElem );
+						else
+							refLocals->Put( pElem, refLocals->Count() );
 					}
 				}
 			}
@@ -603,8 +642,11 @@
 void
 SbiRuntime::StepFIND_Impl( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError nNotFound, BOOL bLocal, BOOL bStatic )
 {
+
 	if( !refLocals )
 		refLocals = new SbxArray;
+	if( !refLocalDefines )
+		initRefDefines( pMod->pImage, pMeth, refLocalDefines );
 	PushVar( FindElement( pObj, nOp1, nOp2, nNotFound, bLocal, bStatic ) );
 }
 // Laden einer lokalen/globalen Variablen (+StringID+Typ)
@@ -1076,15 +1118,29 @@
 
 void SbiRuntime::StepLOCAL( UINT32 nOp1, UINT32 nOp2 )
 {
-	if( !refLocals.Is() )
-		refLocals = new SbxArray;
-	String aName( pImg->GetString( static_cast<short>( nOp1 ) ) );
-	if( refLocals->Find( aName, SbxCLASS_DONTCARE ) == NULL )
+	if ( bVBAEnabled )
 	{
+		if ( !refLocalDefines )
+		{
+			initRefDefines( pMod->pImage, pMeth, refLocalDefines );
+		}
 		SbxDataType t = (SbxDataType) nOp2;
-		SbxVariable* p = new SbxVariable( t );
-		p->SetName( aName );
-		refLocals->Put( p, refLocals->Count() );
+                (*refLocalDefines)[ nOp1 ] = new SbxVariableRef( new SbxVariable( t ) );
+		//p->SetName( aName );
+		return;
+	}
+        else
+        {
+		if( !refLocals.Is() )
+			refLocals = new SbxArray;
+		String aName( pImg->GetString( static_cast<short>( nOp1 ) ) );
+		if( refLocals->Find( aName, SbxCLASS_DONTCARE ) == NULL )
+		{
+			SbxDataType t = (SbxDataType) nOp2;
+			SbxVariable* p = new SbxVariable( t );
+			p->SetName( aName );
+			refLocals->Put( p, refLocals->Count() );
+		}
 	}
 }
 
