diff -r a8d540977f0a basic/source/classes/image.cxx
--- a/basic/source/classes/image.cxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/classes/image.cxx	Tue May 04 10:02:43 2010 +0100
@@ -37,6 +37,47 @@
 #include <string.h>		// memset() etc
 #include "image.hxx"
 #include <codegen.hxx>
+
+ProcRefHandler::ProcRefHandler( const String& procName ) : m_sName( procName ), m_nOffsetGen( 0 )
+{
+}
+
+UINT32 
+ProcRefHandler::getProcRefOffset( UINT32 nOp )
+{
+    INT32ToINT32::iterator it = mOpToOffsetMap.find( nOp );
+    if ( it == mOpToOffsetMap.end() )
+    {
+        // generate Offset
+        INT32 nOff =  m_nOffsetGen++; 
+        mOpToOffsetMap[ nOp ] = nOff;
+        mOffsetToOp[ nOff ] = nOp;
+        return nOff;
+    }
+    return it->second;
+}
+
+UINT32 
+ProcRefHandler::getIdForProcRefOffset( UINT32 nOffset )
+{
+    return mOffsetToOp[ nOffset ];
+}
+
+ProcRefHandler* SbiImage::GetProcRef( const String& rProcName )
+{
+    ProcRefHandler* pHandler = NULL;
+    vProcRefHandlers::iterator it_end = m_vPropRefHandlers.end();
+    for ( vProcRefHandlers::iterator it = m_vPropRefHandlers.begin(); it != it_end; ++it )
+    {
+        if ( it->getName() == rProcName )
+        {
+            pHandler = &(*it);
+            break;
+        }
+    }
+    return pHandler;
+}
+
 SbiImage::SbiImage()
 {
 	pStringOff = NULL;
@@ -486,6 +527,19 @@
 *    Accessing the image
 *
 **************************************************************************/
+short SbiImage::GetIDForString( const String& rName )
+{
+    short nRes = 0;
+    for ( short nId = 0; nId < nStrings; ++nId )
+    {
+        if ( rName == GetString( nId + 1 ) )
+        {
+            nRes = nId + 1;
+            break; 
+        }
+    }
+    return nRes;
+}
 
 // Note: IDs start with 1
 String SbiImage::GetString( short nId ) const
diff -r a8d540977f0a basic/source/comp/codegen.cxx
--- a/basic/source/comp/codegen.cxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/comp/codegen.cxx	Tue May 04 10:02:44 2010 +0100
@@ -333,7 +333,8 @@
 	nCount = pParser->rEnumArray->Count();
 	for (i = 0; i < nCount; i++)
 		 p->AddEnum((SbxObject *)pParser->rEnumArray->Get(i));
-
+        // Set up local ref offsets for string ids
+        p->SetProcRefs( pParser->GetProcRefs() );
 	if( !p->IsError() )
 		rMod.pImage = p;
 	else
diff -r a8d540977f0a basic/source/comp/dim.cxx
--- a/basic/source/comp/dim.cxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/comp/dim.cxx	Tue May 04 10:02:44 2010 +0100
@@ -352,10 +352,14 @@
 								nGblChain = 0;
 								bGblDefs = bNewGblDefs = TRUE;
 								break;
-				default:		eOp2 = _LOCAL;
+                default:		
+                                        eOp2 = _LOCAL; 
 			}
+		INT32 nId = pDef->GetId();
+		if ( eOp2 == _LOCAL && bVBASupportOn )
+			nId = GetProcRefOffset( pProc, pDef->GetId() );
 			aGen.Gen(
-                eOp2, pDef->GetId(),
+                eOp2, nId,
                 sal::static_int_cast< UINT16 >( pDef->GetType() ) );
 		}
 
diff -r a8d540977f0a basic/source/comp/exprgen.cxx
--- a/basic/source/comp/exprgen.cxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/comp/exprgen.cxx	Tue May 04 10:02:44 2010 +0100
@@ -108,7 +108,9 @@
 				 		bTreatFunctionAsParam = false;
 				}
 				if( !bTreatFunctionAsParam )
+                                {
 					eOp = aVar.pDef->IsGlobal() ? _FIND_G : _FIND;
+                                }
 			}
         }
 		// AB: 17.12.1995, Spezialbehandlung fuer WITH
@@ -126,10 +128,9 @@
                 eOp = ( aVar.pDef->GetScope() == SbRTL ) ? _RTL : 
                     (aVar.pDef->IsGlobal() ? _FIND_G : _FIND);
 		}
-
 		if( eOp == _FIND )
 		{
-	
+
 			SbiProcDef* pProc = aVar.pDef->GetProcDef();
 			if ( pGen->GetParser()->bClassModule )
 				eOp = _FIND_CM;
@@ -137,6 +138,10 @@
 			{
 				eOp = _FIND_STATIC;
 			}
+            if ( pGen->GetParser()->IsVBASupportOn() && ( eOp == _FIND_STATIC || eOp == _FIND_CM || eOp == _FIND ) )
+            {
+                aVar.pDef->nLocalIndex = pGen->GetParser()->GetProcRefOffset( pGen->GetParser()->GetProc(), aVar.pDef->GetId() );
+            }
 		}
 		for( SbiExprNode* p = this; p; p = p->aVar.pNext )
 		{
@@ -179,6 +184,9 @@
 	// Falls das Bit 0x8000 gesetzt ist, hat die Variable
 	// eine Parameterliste.
 	USHORT nId = ( eOp == _PARAM ) ? pDef->GetPos() : pDef->GetId();
+        if ( pGen->GetParser()->IsVBASupportOn() && ( eOp == _FIND_STATIC || eOp == _FIND_CM || eOp == _FIND ) )
+            nId = aVar.pDef->nLocalIndex ;
+
 	// Parameterliste aufbauen
 	if( aVar.pPar && aVar.pPar->GetSize() )
 	{
@@ -197,7 +205,7 @@
 		if( pProc->GetAlias().Len() )
 			nId = ( nId & 0x8000 ) | pGen->GetParser()->aGblStrings.Add( pProc->GetAlias() );
 	}
-	pGen->Gen( eOp, nId, sal::static_int_cast< UINT16 >( GetType() ) );
+        pGen->Gen( eOp, nId, sal::static_int_cast< UINT16 >( GetType() ) );
 
 	if( aVar.pvMorePar )
 	{
diff -r a8d540977f0a basic/source/comp/parser.cxx
--- a/basic/source/comp/parser.cxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/comp/parser.cxx	Tue May 04 10:02:44 2010 +0100
@@ -123,6 +123,27 @@
 // 'this' : used in base member initializer list
 #pragma warning( disable: 4355 )
 #endif
+
+UINT32 SbiParser::GetProcRefOffset( SbiProcDef* pProcedure, INT32 nOp )
+{
+    INT32 nOffset = 0;
+    // find the ProcRefHandler for Procedure
+	// no procedure means initialization code, just give then a empty procedure name
+        String pName;
+	if ( pProcedure )
+		pName = pProcedure->GetName();
+    vProcRefHandlers::iterator it_end = m_vPropRefHandlers.end();
+    for ( vProcRefHandlers::iterator it = m_vPropRefHandlers.begin(); it != it_end; ++it )
+    {
+        if ( it->getName() == pName )
+            return it->getProcRefOffset( nOp );
+    }
+    // not found create new ProcRefHandler for pProc
+    ProcRefHandler procOffsets( pName );
+    nOffset = procOffsets.getProcRefOffset( nOp );
+    m_vPropRefHandlers.push_back( procOffsets );
+    return  nOffset;
+}
 
 SbiParser::SbiParser( StarBASIC* pb, SbModule* pm )
 		: SbiTokenizer( pm->GetSource32(), pb ),
diff -r a8d540977f0a basic/source/comp/symtbl.cxx
--- a/basic/source/comp/symtbl.cxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/comp/symtbl.cxx	Tue May 04 10:02:44 2010 +0100
@@ -309,6 +309,7 @@
 	pIn		 =
 	pPool	 = NULL;
 	nDefaultId = 0;
+    nLocalIndex = 0;
 }
 
 SbiSymDef::~SbiSymDef()
@@ -413,7 +414,7 @@
 		 : SbiSymDef( rName )
 		 , aParams( pParser->aGblStrings, SbPARAM )  // wird gedumpt
 		 , aLabels( pParser->aLclStrings, SbLOCAL )	 // wird nicht gedumpt
-		 , mbProcDecl( bProcDecl )
+         , mbProcDecl( bProcDecl )
 {
 	aParams.SetParent( &pParser->aPublics );
 	pPool = new SbiSymPool( pParser->aGblStrings, SbLOCAL ); // Locals
diff -r a8d540977f0a basic/source/inc/image.hxx
--- a/basic/source/inc/image.hxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/inc/image.hxx	Tue May 04 10:02:44 2010 +0100
@@ -36,11 +36,32 @@
 #include <rtl/ustring.hxx>
 #endif
 #include <filefmt.hxx>
+#include <vector>
+#include <map>
 
 // Diese Klasse liest das vom Compiler erzeugte Image ein und verwaltet
 // den Zugriff auf die einzelnen Elemente.
 
 struct SbPublicEntry;
+
+typedef std::map< UINT32, UINT32 > INT32ToINT32;
+
+class ProcRefHandler
+{
+    INT32ToINT32 mOpToOffsetMap;
+    INT32ToINT32 mOffsetToOp;
+    String m_sName;
+    INT32 m_nOffsetGen;
+public:
+    ProcRefHandler( const String& procName );
+    UINT32 getProcRefOffset( UINT32 nOp );
+    UINT32 getIdForProcRefOffset( UINT32 nOffset );
+    bool hasProcRefOffset( UINT32 nOp ) { return mOpToOffsetMap.find( nOp ) !=  mOpToOffsetMap.end(); }
+    String getName(){ return m_sName; }
+    INT32  getMaxOffset() { return  m_nOffsetGen; }
+};
+
+typedef std::vector< ProcRefHandler > vProcRefHandlers;
 
 class SbiImage {
 	friend class SbiCodeGen;			// Compiler-Klassen, die die private-
@@ -69,7 +90,11 @@
 	void AddType(SbxObject *);      // User-Type mit aufnehmen
 	void AddEnum(SbxObject *);      // Register enum type
 
+        vProcRefHandlers m_vPropRefHandlers;
 public:
+	short GetIDForString( const String& rName );
+        void SetProcRefs( const vProcRefHandlers& rHandlers ) { m_vPropRefHandlers =  rHandlers; }
+        ProcRefHandler* GetProcRef( const String& rProcName );
 	String aName;					// Makroname
     ::rtl::OUString aOUSource;		// Quellcode
 	String aComment;				// Kommentar
diff -r a8d540977f0a basic/source/inc/parser.hxx
--- a/basic/source/inc/parser.hxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/inc/parser.hxx	Tue May 04 10:02:44 2010 +0100
@@ -37,14 +37,15 @@
 
 
 #include <vector>
+#include "image.hxx"
 typedef ::std::vector< String > IfaceVector;
 
 struct SbiParseStack;
-
 class SbiParser : public SbiTokenizer
 {
 	friend class SbiExpression;
-
+        vProcRefHandlers m_vPropRefHandlers;
+        
 	SbiParseStack* pStack;   		// Block-Stack
 	SbiProcDef* pProc;				// aktuelle Prozedur
 	SbiExprNode*  pWithVar;			// aktuelle With-Variable
@@ -69,6 +70,9 @@
 	void DefDeclare( BOOL bPrivate );
 	void EnableCompatibility();	
 public:
+        vProcRefHandlers& GetProcRefs() { return m_vPropRefHandlers; }
+        UINT32 GetProcRefOffset( SbiProcDef*, INT32 nOp );
+        SbiProcDef* GetProc() { return pProc;}	
 	SbxArrayRef	  rTypeArray;		// das Type-Array
 	SbxArrayRef	  rEnumArray;		// Enum types
 	SbiStringPool aGblStrings;		// der String-Pool
diff -r a8d540977f0a basic/source/inc/runtime.hxx
--- a/basic/source/inc/runtime.hxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/inc/runtime.hxx	Tue May 04 10:02:44 2010 +0100
@@ -310,6 +310,7 @@
 	String		  aLibName;			// Lib-Name fuer Declare-Call
 	SbxArrayRef   refParams;        // aktuelle Prozedur-Parameter
 	SbxArrayRef   refLocals;        // lokale Variable
+	std::vector< SbxVariableRef* >*  refLocalDefines;
 	SbxArrayRef   refArgv;          // aktueller Argv
 	// AB, 28.3.2000 #74254, Ein refSaveObj reicht nicht! Neu: pRefSaveList (s.u.)
 	//SbxVariableRef refSaveObj;      // #56368 Bei StepElem Referenz sichern
diff -r a8d540977f0a basic/source/inc/symtbl.hxx
--- a/basic/source/inc/symtbl.hxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/inc/symtbl.hxx	Tue May 04 10:02:44 2010 +0100
@@ -137,6 +137,7 @@
 	BOOL	   bParamArray : 1;		// TRUE: ParamArray parameter
 	USHORT	   nDefaultId;			// Symbol number of default value
 public:
+    sal_Int32 nLocalIndex;
 	SbiSymDef( const String& );
 	virtual ~SbiSymDef();
 	virtual SbiProcDef* GetProcDef();
diff -r a8d540977f0a basic/source/runtime/runtime.cxx
--- a/basic/source/runtime/runtime.cxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/runtime/runtime.cxx	Tue May 04 10:02:44 2010 +0100
@@ -93,6 +93,150 @@
 	short nArgc;						// Argc
 };
 
+char* aStep0Char[] = {
+"SbiRuntime::StepNOP",
+"SbiRuntime::StepEXP",
+"SbiRuntime::StepMUL",
+"SbiRuntime::StepDIV",
+"SbiRuntime::StepMOD",
+"SbiRuntime::StepPLUS",
+"SbiRuntime::StepMINUS",
+"SbiRuntime::StepNEG",
+"SbiRuntime::StepEQ",
+"SbiRuntime::StepNE",
+"SbiRuntime::StepLT",
+"SbiRuntime::StepGT",
+"SbiRuntime::StepLE",
+"SbiRuntime::StepGE",
+"SbiRuntime::StepIDIV",
+"SbiRuntime::StepAND",
+"SbiRuntime::StepOR",
+"SbiRuntime::StepXOR",
+"SbiRuntime::StepEQV",
+"SbiRuntime::StepIMP",
+"SbiRuntime::StepNOT",
+"SbiRuntime::StepCAT",
+"SbiRuntime::StepLIKE",
+"SbiRuntime::StepIS",
+"SbiRuntime::StepARGC",
+"SbiRuntime::StepARGV",
+"SbiRuntime::StepINPUT",
+"SbiRuntime::StepLINPUT",
+"SbiRuntime::StepGET",
+"SbiRuntime::StepSET",
+"SbiRuntime::StepPUT",
+"SbiRuntime::StepPUTC",
+"SbiRuntime::StepDIM",
+"SbiRuntime::StepREDIM",
+"SbiRuntime::StepREDIMP",
+"SbiRuntime::StepERASE",
+"SbiRuntime::StepSTOP",
+"SbiRuntime::StepINITFOR",
+"SbiRuntime::StepNEXT",
+"SbiRuntime::StepCASE",
+"SbiRuntime::StepENDCASE",
+"SbiRuntime::StepSTDERROR",
+"SbiRuntime::StepNOERROR",
+"SbiRuntime::StepLEAVE",
+"SbiRuntime::StepCHANNEL",
+"SbiRuntime::StepPRINT",
+"SbiRuntime::StepPRINTF",
+"SbiRuntime::StepWRITE",
+"SbiRuntime::StepRENAME",
+"SbiRuntime::StepPROMPT",
+"SbiRuntime::StepRESTART",
+"SbiRuntime::StepCHANNEL0",
+"SbiRuntime::StepEMPTY",
+"SbiRuntime::StepERROR",
+"SbiRuntime::StepLSET",
+"SbiRuntime::StepRSET",
+"SbiRuntime::StepREDIMP_ERASE",
+"SbiRuntime::StepINITFOREACH",
+"SbiRuntime::SetVBASET",
+"SbiRuntime::SetERASE_CLEAR",
+}; 
+
+char* aStep1Char[] = {	
+"SbiRuntime::StepLOADNC",
+"SbiRuntime::StepLOADSC",
+"SbiRuntime::StepLOADI",
+"SbiRuntime::StepARGN",
+"SbiRuntime::StepPAD",
+"SbiRuntime::StepJUMP",
+"SbiRuntime::StepJUMPT",
+"SbiRuntime::StepJUMPF",
+"SbiRuntime::StepONJUMP",
+"SbiRuntime::StepGOSUB",
+"SbiRuntime::StepRETURN",
+"SbiRuntime::StepTESTFOR",
+"SbiRuntime::StepCASETO",
+"SbiRuntime::StepERRHDL",
+"SbiRuntime::StepRESUME",
+"SbiRuntime::StepCLOSE",
+"SbiRuntime::StepPRCHAR",
+"SbiRuntime::StepSETCLASS",
+"SbiRuntime::StepTESTCLASS",
+"SbiRuntime::StepLIB",
+"SbiRuntime::StepBASED",
+"SbiRuntime::StepARGTYP",
+};
+char* aStep2Char[] = {
+"SbiRuntime::StepRTL",
+"SbiRuntime::StepFIND",
+"SbiRuntime::StepELEM",
+"SbiRuntime::StepPARAM",
+"SbiRuntime::StepCALL",
+"SbiRuntime::StepCALLC",
+"SbiRuntime::StepCASEIS",
+"SbiRuntime::StepSTMNT",
+"SbiRuntime::StepOPEN",
+"SbiRuntime::StepLOCAL",
+"SbiRuntime::StepPUBLIC",
+"SbiRuntime::StepGLOBAL",
+"SbiRuntime::StepCREATE",
+"SbiRuntime::StepSTATIC",
+"SbiRuntime::StepTCREATE",
+"SbiRuntime::StepDCREATE",
+"SbiRuntime::StepGLOBAL_P",
+"SbiRuntime::StepFIND_G",
+"SbiRuntime::StepDCREATE_REDIMP",
+"SbiRuntime::StepFIND_CM",
+"SbiRuntime::StepPUBLIC_P",
+"SbiRuntime::StepFIND_STATIC"
+};
+void SbiRuntime::DumpPCode()
+{
+	int numBytes = pImg->GetCodeSize();
+	USHORT nOp1, nOp2;
+	int i=0;
+	BYTE* pCodeCopy = (BYTE*)pCode;
+	for ( ; i< numBytes; i++ )
+	{
+		SbiOpcode eOp = (SbiOpcode ) ( *pCodeCopy++ );
+		if( eOp <= SbOP0_END )
+		{
+			OSL_TRACE("Runtime::DumpPCode() aStep0[ %d ] %s",
+				eOp, aStep0Char[ eOp ] );
+		}
+		else if( eOp >= SbOP1_START && eOp <= SbOP1_END )
+		{
+			nOp1 = *pCodeCopy++; nOp1 |= *pCodeCopy++ << 8; nOp1 |= *pCodeCopy++ << 16; nOp1 |= *pCodeCopy++ << 24;
+			i+=2;
+			OSL_TRACE("Runtime::DumpDumpPCode aStep1[ %d ] %s (%d)",
+				eOp, aStep1Char[ eOp - SbOP1_START ], nOp1 );
+		}
+		else if( eOp >= SbOP2_START && eOp <= SbOP2_END )
+		{
+			nOp1 = *pCodeCopy++; nOp1 |= *pCodeCopy++ << 8; nOp1 |= *pCodeCopy++ << 16; nOp1 |= *pCodeCopy++ << 24;
+			nOp2 = *pCodeCopy++; nOp2 |= *pCodeCopy++ << 8; nOp2 |= *pCodeCopy++ << 16; nOp2 |= *pCodeCopy++ << 24;
+			i+=8;
+			OSL_TRACE("Runtime::DumpPCode() aStep2[ %d ] %s (%d, %d)",
+				eOp, aStep2Char[ eOp - SbOP2_START ], nOp1, nOp2 );
+		}
+		
+	}
+	OSL_TRACE("Count = %d, reported size is %d",i,  numBytes);
+}
 SbiRuntime::pStep0 SbiRuntime::aStep0[] = {	// Alle Opcodes ohne Operanden
 	&SbiRuntime::StepNOP,
 	&SbiRuntime::StepEXP,
@@ -553,6 +697,7 @@
 #endif
 	pRefSaveList = NULL;
 	pItemStoreList = NULL;
+        refLocalDefines = NULL;
 }
 
 SbiRuntime::~SbiRuntime()
@@ -568,6 +713,18 @@
 		RefSaveItem* pToDeleteItem = pItemStoreList;
 		pItemStoreList = pToDeleteItem->pNext;
 		delete pToDeleteItem;
+	}
+        if ( refLocalDefines )
+	{
+		std::vector< SbxVariableRef* >::iterator it_end = refLocalDefines->end();
+		for ( std::vector< SbxVariableRef* >::iterator it = refLocalDefines->begin(); it!=it_end; ++it )
+		{
+			if ( (*it) )
+				delete (*it);
+		}
+		refLocalDefines->clear();
+		delete refLocalDefines;
+		refLocalDefines = NULL;
 	}
 }
 
@@ -705,18 +862,23 @@
 		UINT32 nOp1, nOp2;
 		if( eOp <= SbOP0_END )
 		{
+			OSL_TRACE("Runtime::Step() calling aStep0[ %d ] %s",
+				eOp, aStep0Char[ eOp ] );
 			(this->*( aStep0[ eOp ] ) )();
 		}
 		else if( eOp >= SbOP1_START && eOp <= SbOP1_END )
 		{
 			nOp1 = *pCode++; nOp1 |= *pCode++ << 8; nOp1 |= *pCode++ << 16; nOp1 |= *pCode++ << 24;
-			
+			OSL_TRACE("Runtime::Step() calling aStep1[ %d ] %s (%d)",
+				eOp, aStep1Char[ eOp - SbOP1_START ], nOp1 );			
 			(this->*( aStep1[ eOp - SbOP1_START ] ) )( nOp1 );
 		}
 		else if( eOp >= SbOP2_START && eOp <= SbOP2_END )
 		{
 			nOp1 = *pCode++; nOp1 |= *pCode++ << 8; nOp1 |= *pCode++ << 16; nOp1 |= *pCode++ << 24;
 			nOp2 = *pCode++; nOp2 |= *pCode++ << 8; nOp2 |= *pCode++ << 16; nOp2 |= *pCode++ << 24;
+			OSL_TRACE("Runtime::Step() calling aStep2[ %d ] %s (%d, %d)",
+				eOp, aStep2Char[ eOp - SbOP2_START ], nOp1, nOp2 );
 			(this->*( aStep2[ eOp - SbOP2_START ] ) )( nOp1, nOp2 );
 		}
 		else
diff -r a8d540977f0a basic/source/runtime/step2.cxx
--- a/basic/source/runtime/step2.cxx	Wed Apr 28 15:31:22 2010 +0100
+++ b/basic/source/runtime/step2.cxx	Tue May 04 10:02:44 2010 +0100
@@ -55,6 +55,17 @@
 using com::sun::star::uno::Reference;
 
 SbxVariable* getVBAConstant( const String& rName );
+void initRefDefines( SbiImage* pImage, SbMethod* pMeth, std::vector< SbxVariableRef* >*&  refLocalDefines )
+{
+    // pMeth == NULL ( means this is an initialisation routine running )
+    ProcRefHandler* pHandler = pImage->GetProcRef( pMeth ? pMeth->GetName() : String() );
+    if ( pHandler )
+    {
+	refLocalDefines = new std::vector< SbxVariableRef* >( pHandler->getMaxOffset() ); 	
+    }	
+    else
+       StarBASIC::FatalError( SbERR_INTERNAL_ERROR );
+}
 
 // Suchen eines Elements
 // Die Bits im String-ID:
@@ -63,14 +74,8 @@
 SbxVariable* SbiRuntime::FindElement
 	( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError nNotFound, BOOL bLocal, BOOL bStatic )
 {
-	bool bIsVBAInterOp = SbiRuntime::isVBAEnabled();
-	if( bIsVBAInterOp )
-	{
-		StarBASIC* pMSOMacroRuntimeLib = GetSbData()->pMSOMacroRuntimLib;
-		if( pMSOMacroRuntimeLib != NULL )
-			pMSOMacroRuntimeLib->ResetFlag( SBX_EXTSEARCH );
-	}
-
+	UINT32 nOffSet = nOp1;
+	ProcRefHandler* pHandler = NULL;
 	SbxVariable* pElem = NULL;
 	if( !pObj )
 	{
@@ -81,36 +86,66 @@
 	{
 		BOOL bFatalError = FALSE;
 		SbxDataType t = (SbxDataType) nOp2;
-		String aName( pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) ) );
-		// Hacky capture of Evaluate [] syntax
-		// this should be tackled I feel at the pcode level
-		if ( bIsVBAInterOp && aName.Search('[') == 0 )
-		{
-			// emulate pcode here
-			StepARGC();
-			// psuedo StepLOADSC
-			String sArg = aName.Copy( 1, aName.Len() - 2 );
-			SbxVariable* p = new SbxVariable;
-			p->PutString( sArg );
-			PushVar( p );
-			//
-			StepARGV();
-			nOp1 = nOp1 | 0x8000; // indicate params are present
-			aName = String::CreateFromAscii("Evaluate");
-		}
+		String aName;//( pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) ) );
+
 		if( bLocal )
 		{
-			if ( bStatic )
-			{	
-				if ( pMeth )
+
+			SbxVariableRef* pRef = NULL;
+                        if ( bVBAEnabled )
+                        {
+                            pRef = (*refLocalDefines)[ nOp1 & 0x7FFF ];
+			    if ( pRef )
+                                pElem = *pRef;
+                        }
+                        if ( !pElem ) // not locally defined
+			{
+				if ( bVBAEnabled )
+				{
+				        pHandler = pMod->pImage->GetProcRef( pMeth ? pMeth->GetName() : String() );
+					if ( pHandler )
+					{
+						bool bHasParams = false;
+						if ( nOp1 & 0x8000 )
+							bHasParams = true;
+						nOp1 = pHandler->getIdForProcRefOffset( nOp1 & 0x7FFF );
+						if ( bHasParams )
+							nOp1 = nOp1 | 0x8000;
+					}
+				}
+				aName = pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) );
+				if ( bStatic && pMeth )
 					pElem = pMeth->GetStatics()->Find( aName, SbxCLASS_DONTCARE );
 			}
+		}
 
-			if ( !pElem )
-				pElem = refLocals->Find( aName, SbxCLASS_DONTCARE );
+		if( bVBAEnabled )
+		{
+			StarBASIC* pMSOMacroRuntimeLib = GetSbData()->pMSOMacroRuntimLib;
+			if( pMSOMacroRuntimeLib != NULL )
+				pMSOMacroRuntimeLib->ResetFlag( SBX_EXTSEARCH );
 		}
+
 		if( !pElem )
 		{
+			if ( aName.Len() == 0 ) 
+				aName = pImg->GetString( static_cast<short>( nOp1 & 0x7FFF ) );
+			// Hacky capture of Evaluate [] syntax
+			// this should be tackled I feel at the pcode level
+			if ( bVBAEnabled && aName.Len() && aName.GetBuffer()[0] == '[') 
+			{
+				// emulate pcode here
+				StepARGC();
+				// psuedo StepLOADSC
+				String sArg = aName.Copy( 1, aName.Len() - 2 );
+				SbxVariable* p = new SbxVariable;
+				p->PutString( sArg );
+				PushVar( p );
+				//
+				StepARGV();
+				nOp1 = nOp1 | 0x8000; // indicate params are present
+				aName = String::CreateFromAscii("Evaluate");
+			}
 			// Die RTL brauchen wir nicht mehr zu durchsuchen!
 			BOOL bSave = rBasic.bNoRtl;
 			rBasic.bNoRtl = TRUE;
@@ -171,7 +206,10 @@
 					// deklarierten Vars automatisch global !
 					if ( bSetName )
 						pElem->SetName( aName );
-					refLocals->Put( pElem, refLocals->Count() );
+					if ( bVBAEnabled )
+						( *refLocalDefines )[ nOffSet & 0x7FFF ] = new SbxVariableRef( pElem );
+					else
+						refLocals->Put( pElem, refLocals->Count() );
 				}
 			}
 
@@ -217,7 +255,10 @@
 						if( t != SbxVARIANT )
 							pElem->SetFlag( SBX_FIXED );
 						pElem->SetName( aName );
-						refLocals->Put( pElem, refLocals->Count() );
+						if ( bVBAEnabled )
+							( *refLocalDefines )[ nOffSet & 0x7FFF ] = new SbxVariableRef( pElem );
+						else
+							refLocals->Put( pElem, refLocals->Count() );
 					}
 				}
 			}
@@ -294,7 +335,21 @@
 		return NULL;
 
 	// Lokal suchen
-	if( refLocals )
+	if ( bVBAEnabled && refLocalDefines )
+	{
+		INT32 nOp1 = pMod->pImage->GetIDForString( rName );
+		ProcRefHandler* pHandler = pMod->pImage->GetProcRef( pMeth ? pMeth->GetName() : String() );
+		if ( pHandler )
+		{
+			if ( pHandler->hasProcRefOffset( nOp1 ) )
+			{
+				SbxVariableRef* pRef = (*refLocalDefines)[ pHandler->getProcRefOffset( nOp1 ) ];
+				if ( pRef )	
+					pElem = *pRef;
+			}
+		}
+	}
+	else if( refLocals )
 		pElem = refLocals->Find( rName, SbxCLASS_DONTCARE );
 
 	// In Statics suchen
@@ -304,7 +359,10 @@
 		String aMethName = pMeth->GetName();
 		aMethName += ':';
 		aMethName += rName;
-		pElem = pMod->Find(aMethName, SbxCLASS_DONTCARE);
+		if ( !pElem )
+			pElem = pMeth->GetStatics()->Find( aMethName, SbxCLASS_DONTCARE );
+		if ( !pElem )
+			pElem = pMod->Find(aMethName, SbxCLASS_DONTCARE);
 	}
 
 	// In Parameter-Liste suchen
@@ -608,8 +666,11 @@
 void
 SbiRuntime::StepFIND_Impl( SbxObject* pObj, UINT32 nOp1, UINT32 nOp2, SbError nNotFound, BOOL bLocal, BOOL bStatic )
 {
+
 	if( !refLocals )
 		refLocals = new SbxArray;
+	if( bVBAEnabled && !refLocalDefines )
+		initRefDefines( pMod->pImage, pMeth, refLocalDefines );
 	PushVar( FindElement( pObj, nOp1, nOp2, nNotFound, bLocal, bStatic ) );
 }
 // Laden einer lokalen/globalen Variablen (+StringID+Typ)
@@ -1083,15 +1144,38 @@
 
 void SbiRuntime::StepLOCAL( UINT32 nOp1, UINT32 nOp2 )
 {
-	if( !refLocals.Is() )
-		refLocals = new SbxArray;
-	String aName( pImg->GetString( static_cast<short>( nOp1 ) ) );
-	if( refLocals->Find( aName, SbxCLASS_DONTCARE ) == NULL )
+	if ( bVBAEnabled )
 	{
+		if ( !refLocalDefines )
+		{
+			initRefDefines( pMod->pImage, pMeth, refLocalDefines );
+		}
 		SbxDataType t = (SbxDataType) nOp2;
-		SbxVariable* p = new SbxVariable( t );
-		p->SetName( aName );
-		refLocals->Put( p, refLocals->Count() );
+                (*refLocalDefines)[ nOp1 ] = new SbxVariableRef( new SbxVariable( t ) );
+		ProcRefHandler* pHandler = pMod->pImage->GetProcRef( pMeth ? pMeth->GetName() : String() );
+#if 0 // do we need to set the name ?
+		if ( pHandler )
+		{
+			UINT32 nTmpOp1 = pHandler->getIdForProcRefOffset( nOp1 & 0x7FFF );
+			String aName = pImg->GetString( static_cast<short>( nTmpOp1 ) );
+			SbxVariable* pElem = *(*refLocalDefines)[ nOp1 ];
+			pElem->SetName( aName );
+		}
+#endif
+		//p->SetName( aName );
+	}
+        else
+        {
+		if( !refLocals.Is() )
+			refLocals = new SbxArray;
+		String aName( pImg->GetString( static_cast<short>( nOp1 ) ) );
+		if( refLocals->Find( aName, SbxCLASS_DONTCARE ) == NULL )
+		{
+			SbxDataType t = (SbxDataType) nOp2;
+			SbxVariable* p = new SbxVariable( t );
+			p->SetName( aName );
+			refLocals->Put( p, refLocals->Count() );
+		}
 	}
 }
 
